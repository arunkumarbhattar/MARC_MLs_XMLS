<?xml version="1.0" encoding="utf-8"?>
<emails><email><emailId>20111116142743</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-11-16 14:27:43-0400</timestampReceived><subject>Re: make issues</subject><body>

Anna Smith &lt;anna@bit.ly&gt; writes:

&gt; the link provided is broken :(  can you repost?

Works for me. Maybe you accidentally copied the "," at the end? That was
not intended as a part of the url. It should be just

  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110202211550</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-02 21:15:50-0400</timestampReceived><subject>GCM mode and GMAC</subject><body>

Hi,

Nikos Mavrogiannopoulos have been looking into support for Galois
Counter Mode (GCM), see http://www.cryptobarn.com/papers/gcm-spec.pdf

My understanding of GCM is that the main point is a new MAC function
which allows efficient hardware implementation. As far as I see, there's
no clear advantage of using GCM instead of plain CTR mode combined with
the same MAC function (applied to the plaintext).

For Nettle, I think the first step ought to be to properly support the
MAC function, GMAC. The most fundamental difference to other MAC
functions is that it takes two input strings (besides the key). When
used as a plain MAC, the second input is empty, while when used with
GCM, the first input is auxillary data to be authenticated, and the
second input is the cryptotext.

Some questions:

  * Naming: Is "gmac" a good enough name? Or "ghash" (the name of the
    primitive which takes a key and two inputs, in the paper)? Or do we
    need something more verbose, like galois_mac or gmac128 or so?
    
  * Specification: It's not entirely clear to me how the spec is to be
    interpreted when one of the input strings is empty. The most
    reasonable interpretation would be that there should be zero blocks
    to process (n or m equal to zero). This requires some bending of the
    notation in equation (2), for example, with m = 0, n = 1, we should
    have

      X_0 = 0
      X_1 = C_1^* · H
      X_2 = (X_1 + (0 || len(C))) · H

    and with m = 1, n = 0,

      X_0 = 0
      X_1 = A_1^* · H
      X_2 = (X_1 0 (len(A) || 0)) · H

    Do you agree?
    
  * Interface: I think the basic use case with empty second input should
    be just like other MAC:s,

      struct gmac_ctx;
      
      /* Key size fixed to GMAC_KEY_SIZE == 16 */
      void
      gmac_set_key(struct gmac_ctx *ctx, const uint8_t *key);
      
      void
      gmac_update(struct gmac_ctx *ctx,
		  unsigned length, const uint8_t *data);
      
      void
      gmac_digest(struct gmac_ctx *ctx,
		  unsigned length, uint8_t *digest);

    The context struct and the set_key function is essential to be able
    to do any optimizations using key-dependant tables.
    
    But then we need a function to mark the end of the first input and
    the start of the second. Name for that one?

      void
      gmac_next(struct gmac_ctx *ctx);

    This will pad the current input to a block boundary, and switch to
    using a different length counter.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20110317052354</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-17 05:23:54-0400</timestampReceived><subject>nettle perl bindings</subject><body>


Hi Nettle Folks--

I'm building Perl bindings for libnettle.  I hope to claim the
Crypt::Nettle namespace.

The project is in its infancy, but i currently have coverage for all
hash functions and ciphers.

My next steps are adding bindings for Yarrow and RSA.

At the moment, my source code is available via git:

 git clone git://lair.fifthhorseman.net/~dkg/libcrypt-nettle-perl


You can test it with:

 cd libcrypt-nettle-perl
 perl Makefile.PL
 make
 make test


You can read the docs with:

 pod2text lib/Crypt/Nettle.pm
 pod2text lib/Crypt/Nettle/Hash.pm
 pod2text lib/Crypt/Nettle/Cipher.pm

I have not yet uploaded it to CPAN.  I'd be very happy to get feedback
from anyone interested.

Regards,

	--dkg



</body></email><email><emailId>20110402234210</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-04-02 23:42:10-0400</timestampReceived><subject>Re: different lib directories for gnutls and nettle</subject><body>

On 03/31/2011 12:48 AM, Brian Gough wrote:
&gt; Hi, now that GNU TLS is using nettle I notice there is a difference
&gt; between the --libdir for the two packages on 64 bit.
&gt; Nettle installs to $prefix/lib64/ and GNU TLS looks for it in
&gt; $prefix/lib/ -- so it fails and the standard configure/install to a
&gt; prefix doesn't work.

Indeed it seems nettle for some reason uses the /usr/lib64. Niels,
is there really a reason for that? As I understand from the FHS[0]
/usr/lib is the system library directory. /usr/lib64 and /usr/lib32
might not even be there.

regards,
Nikos

[0].
http://www.pathname.com/fhs/pub/fhs-2.3.html#USRLIBLIBRARIESFORPROGRAMMINGANDPA

</body></email><email><emailId>20110412092742</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-04-12 09:27:42-0400</timestampReceived><subject>Re: different lib directories for gnutls and nettle</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Indeed it seems nettle for some reason uses the /usr/lib64. Niels,
&gt; is there really a reason for that? As I understand from the FHS[0]
&gt; /usr/lib is the system library directory. /usr/lib64 and /usr/lib32
&gt; might not even be there.

Sorry for the late reply. A bit down in the same document,
http://www.pathname.com/fhs/pub/fhs-2.3.html, it says

  /lib64 and /lib32 : 64/32-bit libraries (architecture dependent)
  
  The 64-bit architectures PPC64, s390x, sparc64 and AMD64 must place
  64-bit libraries in /lib64, and 32-bit (or 31-bit on s390) libraries in
  /lib.

If you believe this, then it's wrong to install 64-bit libraries in lib.
And I believed so when I wrote this part of the nettle configure.ac...

But then it turned out that at least debian on x86_64 ignores this part
of the FHS, and puts the 64-bit libraries in lib, and 32-bit libraries
in lib32. Which seems to also be the freebsd way of doing it.

In the debian case, lib64 is a symlink to lib, so it doesn't matter for
a 64-bit builds (they will be installed in lib64, which is a symlink to
lib, which is tye right place), while a build with ./configure CC="gcc
-m32" &amp;&amp; make &amp;&amp; make install will install the 32-bit library files in
the wrong place.

I'm not sure what the right thing is. Is there any distribution which
actuallly does what the FHS says? If so, I guess configure needs to
check what directories exists, and install in lib$ABI whenever that
directory exists, otherwise in lib. I haven't got around to fixing that.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110521080810</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-05-21 08:08:10-0400</timestampReceived><subject>memory leak fix</subject><body>

The attached patch fixes a memory leak in DSA key generation.

regards,
Nikos

["0001-Fixed-memory-leak-in-DSA-key-generation.patch" (text/x-patch)]

&gt;From 5c97ca61ab8f05459d2f50e9a6c713dbf982ea1e Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Sat, 21 May 2011 09:55:49 +0200
Subject: [PATCH] Fixed memory leak in DSA key generation

---
 dsa-keygen.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/dsa-keygen.c b/dsa-keygen.c
index be17771..00bd35f 100644
--- a/dsa-keygen.c
+++ b/dsa-keygen.c
@@ -106,7 +106,7 @@ dsa_generate_keypair(struct dsa_public_key *pub,
   if (progress)
     progress (progress_ctx, 'g');
 
-  mpz_init_set(r, pub-&gt;q);
+  mpz_set(r, pub-&gt;q);
   mpz_sub_ui(r, r, 2);
   nettle_mpz_random(key-&gt;x, random_ctx, random, r);
 
-- 
1.7.2.3



</body></email><email><emailId>20110608091846</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-06-08 09:18:46-0400</timestampReceived><subject>Re: patch to fix build of nettle on gcc-2.95 architectures</subject><body>

"Sebastian Reitenbach" &lt;sebastia@l00-bugdead-prods.de&gt; writes:

&gt; I found nettle not compiling on openbsd sparc architecture which uses
&gt; gcc-2.95 as default compiler. Attached little patch against nettle-2.1
&gt; fixes the compilation problem for me.

Thanks, checked in now. Nettle is not supposed to rely on c99 features.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110608094606</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-06-08 09:46:06-0400</timestampReceived><subject>release?</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt;
&gt;&gt; May I suggest an intermediate release with GCM under LGPLv2+?
&gt;&gt; That would ensure that current applications using gnutls can use that
&gt;&gt; code.
&gt;
&gt; An all-LGPL release is not possible until the serpent code is replaced,
&gt; so any releases before that would use the current licensing terms (GPL
&gt; as a whole, certain parts under more permissive license).

The serpent code is replaced, any other issues that we are waiting for?

A new Nettle release would be nice to make GnuTLS with Nettle easier to
install.  I guess anyone can prepare a snapshot, but an official release
is better.

/Simon

</body></email><email><emailId>20110902182136</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-09-02 18:21:36-0400</timestampReceived><subject>ANNOUNCE: Nettle-2.3</subject><body>

I'm happy to announce a new version of GNU Nettle, a low-level
cryptographics library. The Nettle home page can be found at
http://www.lysator.liu.se/~nisse/nettle/. 

NEWS for the 2.3 release

	* Support for the ripemd-160 hash function.

	* Generates and installs nettle.pc and hogweed.pc files, for
          use with pkg-config. Feedback appreciated. For projects
          using autoconf, the traditional non-pkg-config ways of
          detecting libraries, and setting LIBS and LDFLAGS, is still
          recommended.

	* Fixed a bug which made the testsuite fail in the GCM test on
	  certain platforms. Should not affect any documented features
	  of the library.

	* Reorganization of the code for the various Merkle-Damgård
	  hash functions. Some fields in the context structs for md4,
	  md5 and sha1 have been renamed, for consistency.
	  Applications should not peek inside these structs, and the
	  ABI is unchanged.
	  
	* In the manual, fixed mis-placed const in certain function
          prototypes.

	The library is intended to be binary compatible with
	nettle-2.2. The shared library names are libnettle.so.4.2 and
	libhogweed.so.2.1, with sonames still libnettle.so.4 and
	libhogweed.so.2.

Available at

  http://www.lysator.liu.se/~nisse/archive/nettle-2.3.tar.gz

and soon also at

  ftp://ftp.lysator.liu.se/pub/security/lsh/nettle-2.3.tar.gz
  ftp://ftp.gnu.org/gnu/nettle/nettle-2.3.tar.gz

Happy hacking,
/Niels Möller

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20111015011022</emailId><senderName>Ryan Schmidt</senderName><senderEmail>nettle-2011@ryandesign.com</senderEmail><timestampReceived>2011-10-15 01:10:22-0400</timestampReceived><subject>PATCH: Build proper Mac OS X dynamic libraries (dylibs)</subject><body>


Hello,

I've patched nettle in MacPorts to build proper Mac OS X dynamic =
libraries, and wanted to share the patch with you.



</body></email><email><emailId>20111015012835</emailId><senderName>Ryan Schmidt</senderName><senderEmail>nettle-2011@ryandesign.com</senderEmail><timestampReceived>2011-10-15 01:28:35-0400</timestampReceived><subject>Re: PATCH: Build proper Mac OS X dynamic libraries (dylibs)</subject><body>


On Oct 14, 2011, at 20:10, Ryan Schmidt wrote:

&gt; I've patched nettle in MacPorts to build proper Mac OS X dynamic =
libraries, and wanted to share the patch with you.

Since your mailing list software appears to silently strip out =
attachments, I've posted it here:

http://www.ryandesign.com/tmp/nettle-configure.ac.diff




</body></email><email><emailId>20110814075122</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-08-14 07:51:22-0400</timestampReceived><subject>ECC support</subject><body>

Hello,
 This patch adds ECC support using the GnuTLS libtomcrypt adaptation.

regards,
Nikos


btw. I had issues building the cvs version. The compilation was
failing:
nettle-hash.o: In function `list_algorithms':
/home/nmav/cvs/lsh/nettle/tools/nettle-hash.c:49: undefined reference to
`nettle_hashes'


["0001-Added-ECC.patch" (text/x-patch)]

&gt; From 78ba3eb4ade2ee671c6ae0a06b0153979fa77a46 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Sun, 14 Aug 2011 09:48:46 +0200
Subject: [PATCH] Added ECC

---
 Makefile.in                  |    9 ++-
 ecc.h                        |  131 ++++++++++++++++++++++++
 ecc_curves.c                 |   68 ++++++++++++
 ecc_free.c                   |   46 +++++++++
 ecc_make_key.c               |  154 ++++++++++++++++++++++++++++
 ecc_map.c                    |   78 ++++++++++++++
 ecc_mulmod.c                 |  191 +++++++++++++++++++++++++++++++++++
 ecc_points.c                 |   69 +++++++++++++
 ecc_projective_add_point.c   |  230 ++++++++++++++++++++++++++++++++++++++++++
 ecc_projective_dbl_point.c   |  208 ++++++++++++++++++++++++++++++++++++++
 ecc_projective_dbl_point_3.c |  156 ++++++++++++++++++++++++++++
 ecc_shared_secret.c          |   93 +++++++++++++++++
 ecc_sign_hash.c              |  116 +++++++++++++++++++++
 ecc_verify_hash.c            |  158 +++++++++++++++++++++++++++++
 nettle.texinfo               |   75 ++++++++++++++-
 testsuite/Makefile.in        |    2 +-
 testsuite/ecc-test.c         |  153 ++++++++++++++++++++++++++++
 17 files changed, 1933 insertions(+), 4 deletions(-)
 create mode 100644 ecc.h
 create mode 100644 ecc_curves.c
 create mode 100644 ecc_free.c
 create mode 100644 ecc_make_key.c
 create mode 100644 ecc_map.c
 create mode 100644 ecc_mulmod.c
 create mode 100644 ecc_points.c
 create mode 100644 ecc_projective_add_point.c
 create mode 100644 ecc_projective_dbl_point.c
 create mode 100644 ecc_projective_dbl_point_3.c
 create mode 100644 ecc_shared_secret.c
 create mode 100644 ecc_sign_hash.c
 create mode 100644 ecc_verify_hash.c
 create mode 100644 testsuite/ecc-test.c

diff --git a/Makefile.in b/Makefile.in
index 3bd8c4f..2f77c66 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -103,7 +103,12 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  dsa-sha256-sign.c dsa-sha256-verify.c  \
 		  dsa2sexp.c sexp2dsa.c \
 		  pgp-encode.c rsa2openpgp.c \
-		  der-iterator.c der2rsa.c der2dsa.c
+		  der-iterator.c der2rsa.c der2dsa.c \
+		  ecc_free.c ecc_make_key.c ecc_map.c \
+		  ecc_mulmod.c ecc_points.c ecc_projective_add_point.c \
+		  ecc_projective_dbl_point_3.c ecc_projective_dbl_point.c \
+		  ecc_shared_secret.c ecc_sign_hash.c ecc_verify_hash.c \
+		  ecc_curves.c
 
 HEADERS = aes.h arcfour.h arctwo.h asn1.h bignum.h blowfish.h \
 	  base16.h base64.h buffer.h camellia.h cast128.h \
@@ -119,7 +124,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h bignum.h blowfish.h \
 	  pgp.h pkcs1.h realloc.h rsa.h rsa-compat.h \
 	  sexp.h \
 	  serpent.h sha.h twofish.h \
-	  yarrow.h
+	  yarrow.h ecc.h
 
 INSTALL_HEADERS = $(HEADERS) nettle-stdint.h
 
diff --git a/ecc.h b/ecc.h
new file mode 100644
index 0000000..c510740
--- /dev/null
+++ b/ecc.h
@@ -0,0 +1,131 @@
+#include &lt;gmp.h&gt;
+#include &lt;nettle/nettle-types.h&gt;
+#include &lt;nettle/dsa.h&gt;
+#include &lt;nettle/bignum.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;stdint.h&gt;
+#include &lt;string.h&gt;
+#include &lt;assert.h&gt;
+
+/* assume curve is y^2 = x^3 - 3x + b
+ * instead of the generic y^2 = x^3 + ax + b
+ *
+ * (XXX: the generic case has been tested only
+ *  with the SECG curves.)
+ */
+#define ECC_SECP_CURVES_ONLY
+
+#define PK_PRIVATE 1
+#define PK_PUBLIC 2
+
+/* ---- ECC Routines ---- */
+/* size of our temp buffers for exported keys */
+#define ECC_BUF_SIZE 512
+
+/* max private key size */
+#define ECC_MAXSIZE  66
+
+/** Structure defines a NIST GF(p) curve */
+typedef struct {
+   /** The size of the curve in octets */
+   int size;
+
+   /** name of curve */
+   const char *name; 
+   
+   /** curve's OID */
+   const char *oid;
+
+   /** The prime that defines the field the curve is in (encoded in hex) */
+   const char *prime;
+
+   /** The fields A param (hex) */
+   const char *A;
+
+   /** The fields B param (hex) */
+   const char *B;
+
+   /** The order of the curve (hex) */
+   const char *order;
+  
+   /** The x co-ordinate of the base point on the curve (hex) */
+   const char *Gx;
+ 
+   /** The y co-ordinate of the base point on the curve (hex) */
+   const char *Gy;
+} ecc_set_type;
+
+/** A point on a ECC curve, stored in Jacbobian format such that (x,y,z) =&gt; (x/z^2, \
y/z^3, 1) when interpretted as affine */ +typedef struct {
+    /** The x co-ordinate */
+    mpz_t x;
+
+    /** The y co-ordinate */
+    mpz_t y;
+
+    /** The z co-ordinate */
+    mpz_t z;
+} ecc_point;
+
+/** An ECC key */
+typedef struct {
+    /** Type of key, PK_PRIVATE or PK_PUBLIC */
+    int type;
+
+    mpz_t prime;
+    mpz_t order;
+    mpz_t A;
+    mpz_t Gx;
+    mpz_t Gy;
+
+    /** The public key */
+    ecc_point pubkey;
+
+    /** The private key */
+    mpz_t k;
+} ecc_key;
+
+/* supported curves */
+const ecc_set_type ecc_curves_secp[];
+
+/* Key generation */
+int ecc_make_key(void *random_ctx, nettle_random_func random, ecc_key *key, const \
ecc_set_type *dp); +int ecc_make_key_ex(void *random_ctx, nettle_random_func random, \
ecc_key *key, mpz_t prime, mpz_t order, mpz_t A, mpz_t Gx, mpz_t Gy); +void \
ecc_free(ecc_key *key); +
+/* EC-Diffie-Hellman */
+int  ecc_shared_secret(ecc_key *private_key, ecc_key *public_key, 
+                       unsigned char *out, unsigned long *outlen);
+
+/* ECDSA */
+int ecc_sign_hash(const unsigned char *in,  unsigned long inlen, 
+                        struct dsa_signature *signature,
+                        void *random_ctx, nettle_random_func random, ecc_key *key);
+
+int  ecc_verify_hash(struct dsa_signature * signature,
+                     const unsigned char *hash, unsigned long hashlen, 
+                     int *stat, ecc_key *key);
+
+/* (Internal) low level functions */
+ecc_point *ecc_new_point(void);
+void       ecc_del_point(ecc_point *p);
+
+/* point ops (mp == montgomery digit) */
+/* R = 2P */
+int ecc_projective_dbl_point(ecc_point *P, ecc_point *R, mpz_t a,  mpz_t modulus);
+
+/* R = P + Q */
+int ecc_projective_add_point(ecc_point *P, ecc_point *Q, ecc_point *R, mpz_t A, \
mpz_t modulus); +
+/* R = kG */
+int ecc_mulmod(mpz_t k, ecc_point *G, ecc_point *R, mpz_t a, mpz_t modulus, int \
map); +
+/* map P to affine from projective */
+int ecc_map(ecc_point *P, mpz_t modulus);
+
+/* helper functions */
+int mp_init_multi(mpz_t *a, ...);
+void mp_clear_multi(mpz_t *a, ...);
+#define mp_isodd(a)                  (mpz_size(a) &gt; 0 ? (mpz_getlimbn(a, 0) &amp; 1 ? 1 \
: 0) : 0) +
+#define MP_DIGIT_BIT (sizeof(mp_limb_t) * 8 - GMP_NAIL_BITS)
diff --git a/ecc_curves.c b/ecc_curves.c
new file mode 100644
index 0000000..309fe7b
--- /dev/null
+++ b/ecc_curves.c
@@ -0,0 +1,68 @@
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2011 Nikos Mavrogiannopoulos
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+
+#include "ecc.h"
+
+const ecc_set_type ecc_curves_secp[] = {
+{
+    .name = "SECP224R1", 
+    .oid = "1.3.132.0.33",
+    .size = 28,
+    .prime = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001",
+    .A = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE",
+    .B = "B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4",
+    .order = "FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D",
+    .Gx =    "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21",
+    .Gy =    "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34",
+},
+{
+    .name = "SECP256R1", 
+    .oid = "1.2.840.10045.3.1.7",
+    .size = 32,
+    .prime = "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF",
+    .A = "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC",
+    .B = "5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B",
+    .order = "FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551",
+    .Gx = "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296",
+    .Gy = "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5",
+},
+{
+    .name = "SECP384R1",
+    .oid = "1.3.132.0.34",
+    .size = 48,
+    .prime = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF",
 +    .A = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC",
 +    .B = "B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF",
 +    .order = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973",
 +    .Gx = "AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7",
 +    .Gy = "3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F"
 +},
+{
+    .name = "SECP521R1",
+    .oid = "1.3.132.0.35",
+    .size = 66,
+    .prime = "01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
 +    .A = "01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC",
 +    .B = "0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00",
 +    .order = "01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409",
 +    .Gx =    "00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66",
 +    .Gy =    "011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650",
 +}
+};
diff --git a/ecc_free.c b/ecc_free.c
new file mode 100644
index 0000000..1d7dd64
--- /dev/null
+++ b/ecc_free.c
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2011 Free Software Foundation, Inc.
+ *
+ * This file is part of GNUTLS.
+ *
+ * The GNUTLS library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
+ *
+ */
+
+/* Based on public domain code of LibTomCrypt by Tom St Denis.
+ * Adapted to gmp and nettle by Nikos Mavrogiannopoulos.
+ */
+
+#include "ecc.h"
+
+/*
+  @file ecc_free.c
+  ECC Crypto, Tom St Denis
+*/
+
+/*
+  Free an ECC key from memory
+  @param key   The key you wish to free
+*/
+void
+ecc_free (ecc_key * key)
+{
+  assert (key != NULL);
+  mp_clear_multi (&amp;key-&gt;pubkey.x, &amp;key-&gt;pubkey.y, &amp;key-&gt;pubkey.z, &amp;key-&gt;k,
+                  &amp;key-&gt;prime, &amp;key-&gt;order, &amp;key-&gt;Gx, &amp;key-&gt;Gy, NULL);
+}
+
+/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ecc_free.c,v $ */
+/* $Revision: 1.6 $ */
+/* $Date: 2007/05/12 14:32:35 $ */
diff --git a/ecc_make_key.c b/ecc_make_key.c
new file mode 100644
index 0000000..42ac6df
--- /dev/null
+++ b/ecc_make_key.c
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2011 Free Software Foundation, Inc.
+ *
+ * This file is part of GNUTLS.
+ *
+ * The GNUTLS library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
+ *
+ */
+
+/* Based on public domain code of LibTomCrypt by Tom St Denis.
+ * Adapted to gmp and nettle by Nikos Mavrogiannopoulos.
+ */
+
+#include "ecc.h"
+
+/*
+  @file ecc_make_key.c
+  ECC Crypto, Tom St Denis
+*/
+
+/*
+  Make a new ECC key 
+  @param prng         An active PRNG state
+  @param wprng        The index of the PRNG you wish to use
+  @param prime        The prime of curve's field
+  @param order        The order of the G point
+  @param A            The "a" parameter of the curve
+  @param Gx           The x coordinate of the base point
+  @param Gy           The y coordinate of the base point
+  @return 0 if successful, upon error all allocated memory will be freed
+*/
+
+int
+ecc_make_key_ex (void *random_ctx, nettle_random_func random, ecc_key * key,
+                 mpz_t prime, mpz_t order, mpz_t A, mpz_t Gx, mpz_t Gy)
+{
+  int err;
+  ecc_point *base;
+  unsigned char *buf;
+  int keysize;
+
+  assert (key != NULL);
+  assert (random != NULL);
+
+  keysize = nettle_mpz_sizeinbase_256_u (order);
+
+  /* allocate ram */
+  base = NULL;
+  buf = malloc (keysize);
+  if (buf == NULL)
+    {
+      return -1;
+    }
+
+  /* make up random string */
+  random (random_ctx, keysize, buf);
+
+  /* setup the key variables */
+  if ((err =
+       mp_init_multi (&amp;key-&gt;pubkey.x, &amp;key-&gt;pubkey.y, &amp;key-&gt;pubkey.z, &amp;key-&gt;k,
+                      &amp;key-&gt;prime, &amp;key-&gt;order, &amp;key-&gt;A, &amp;key-&gt;Gx, &amp;key-&gt;Gy,
+                      NULL)) != 0)
+    {
+      goto ERR_BUF;
+    }
+  base = ecc_new_point ();
+  if (base == NULL)
+    {
+      err = -1;
+      goto errkey;
+    }
+
+  /* read in the specs for this key */
+  mpz_set (key-&gt;prime, prime);
+  mpz_set (key-&gt;order, order);
+  mpz_set (key-&gt;Gx, Gx);
+  mpz_set (key-&gt;Gy, Gy);
+  mpz_set (key-&gt;A, A);
+
+  mpz_set (base-&gt;x, key-&gt;Gx);
+  mpz_set (base-&gt;y, key-&gt;Gy);
+  mpz_set_ui (base-&gt;z, 1);
+  
+  nettle_mpz_set_str_256_u (key-&gt;k, keysize, buf);
+
+  /* the key should be smaller than the order of base point */
+  if (mpz_cmp (key-&gt;k, key-&gt;order) &gt;= 0)
+    {
+      mpz_mod (key-&gt;k, key-&gt;k, key-&gt;order);
+    }
+  /* make the public key */
+  if ((err =
+       ecc_mulmod (key-&gt;k, base, &amp;key-&gt;pubkey, key-&gt;A, key-&gt;prime,
+                       1)) != 0)
+    {
+      goto errkey;
+    }
+  key-&gt;type = PK_PRIVATE;
+
+  /* free up ram */
+  err = 0;
+  goto cleanup;
+errkey:
+  mp_clear_multi (&amp;key-&gt;pubkey.x, &amp;key-&gt;pubkey.y, &amp;key-&gt;pubkey.z, &amp;key-&gt;k,
+                  &amp;key-&gt;order, &amp;key-&gt;prime, &amp;key-&gt;Gx, &amp;key-&gt;Gy, &amp;key-&gt;A,
+                  NULL);
+cleanup:
+  ecc_del_point (base);
+ERR_BUF:
+  free (buf);
+  return err;
+}
+
+int
+ecc_make_key (void *random_ctx, nettle_random_func random, ecc_key * key,
+              const ecc_set_type * dp)
+{
+  mpz_t prime, order, Gx, Gy, A;
+  int err;
+
+  /* setup the key variables */
+  if ((err = mp_init_multi (′, &amp;order, &amp;A, &amp;Gx, &amp;Gy, NULL)) != 0)
+    {
+      goto cleanup;
+    }
+
+  /* read in the specs for this key */
+  mpz_set_str (prime, (char *) dp-&gt;prime, 16);
+  mpz_set_str (order, (char *) dp-&gt;order, 16);
+  mpz_set_str (Gx, (char *) dp-&gt;Gx, 16);
+  mpz_set_str (Gy, (char *) dp-&gt;Gy, 16);
+  mpz_set_str (A, (char *) dp-&gt;A, 16);
+
+  err = ecc_make_key_ex (random_ctx, random, key, prime, order, A, Gx, Gy);
+
+  mp_clear_multi (′, &amp;order, &amp;A, &amp;Gx, &amp;Gy, NULL);
+cleanup:
+  return err;
+}
+
+/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ecc_make_key.c,v $ */
+/* $Revision: 1.13 $ */
+/* $Date: 2007/05/12 14:32:35 $ */
diff --git a/ecc_map.c b/ecc_map.c
new file mode 100644
index 0000000..561c3b2
--- /dev/null
+++ b/ecc_map.c
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2011 Free Software Foundation, Inc.
+ *
+ * This file is part of GNUTLS.
+ *
+ * The GNUTLS library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
+ *
+ */
+
+/* Based on public domain code of LibTomCrypt by Tom St Denis.
+ * Adapted to gmp and nettle by Nikos Mavrogiannopoulos.
+ */
+
+#include "ecc.h"
+
+/*
+  @file ecc_map.c
+  ECC Crypto, Tom St Denis
+*/
+
+/*
+  Map a projective jacobian point back to affine space
+  @param P        [in/out] The point to map
+  @param modulus  The modulus of the field the ECC curve is in
+  @param mp       The "b" value from montgomery_setup()
+  @return 0 on success
+*/
+int
+ecc_map (ecc_point * P, mpz_t modulus)
+{
+  mpz_t t1, t2;
+  int err;
+
+  assert (P != NULL);
+
+  if ((err = mp_init_multi (&amp;t1, &amp;t2, NULL)) != 0)
+    {
+      return -1;
+    }
+
+  mpz_mod (P-&gt;z, P-&gt;z, modulus);
+
+  /* get 1/z */
+  mpz_invert (t1, P-&gt;z, modulus);
+
+  /* get 1/z^2 and 1/z^3 */
+  mpz_mul (t2, t1, t1);
+  mpz_mod (t2, t2, modulus);
+  mpz_mul (t1, t1, t2);
+  mpz_mod (t1, t1, modulus);
+
+  /* multiply against x/y */
+  mpz_mul (P-&gt;x, P-&gt;x, t2);
+  mpz_mod (P-&gt;x, P-&gt;x, modulus);
+  mpz_mul (P-&gt;y, P-&gt;y, t1);
+  mpz_mod (P-&gt;y, P-&gt;y, modulus);
+  mpz_set_ui (P-&gt;z, 1);
+
+  err = 0;
+
+  mp_clear_multi (&amp;t1, &amp;t2, NULL);
+  return err;
+}
+
+/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ecc_map.c,v $ */
+/* $Revision: 1.7 $ */
+/* $Date: 2007/05/12 14:32:35 $ */
diff --git a/ecc_mulmod.c b/ecc_mulmod.c
new file mode 100644
index 0000000..fff0fd0
--- /dev/null
+++ b/ecc_mulmod.c
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2011 Free Software Foundation, Inc.
+ *
+ * This file is part of GNUTLS.
+ *
+ * The GNUTLS library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
+ *
+ */
+
+/* Based on public domain code of LibTomCrypt by Tom St Denis.
+ * Adapted to gmp and nettle by Nikos Mavrogiannopoulos.
+ */
+
+#include "ecc.h"
+
+/*
+  @file ecc_mulmod_timing.c
+  ECC Crypto, Tom St Denis
+*/
+
+/*
+   Perform a point multiplication  (timing resistant)
+   @param k    The scalar to multiply by
+   @param G    The base point
+   @param R    [out] Destination for kG
+   @param a        The a value of the curve
+   @param modulus  The modulus of the field the ECC curve is in
+   @param map      Boolean whether to map back to affine or not (1==map, 0 == leave \
in projective) +   @return 0 on success
+*/
+int
+ecc_mulmod (mpz_t k, ecc_point * G, ecc_point * R, mpz_t a, mpz_t modulus,
+                int map)
+{
+  ecc_point *tG, *M[3];
+  int i, j, err;
+  unsigned long buf;
+  int bitcnt, mode, digidx;
+
+  assert (k != NULL);
+  assert (G != NULL);
+  assert (R != NULL);
+  assert (modulus != NULL);
+
+  /* alloc ram for window temps */
+  for (i = 0; i &lt; 3; i++)
+    {
+      M[i] = ecc_new_point ();
+      if (M[i] == NULL)
+        {
+          for (j = 0; j &lt; i; j++)
+            {
+              ecc_del_point (M[j]);
+            }
+          return -1;
+        }
+    }
+
+  /* make a copy of G incase R==G */
+  tG = ecc_new_point ();
+  if (tG == NULL)
+    {
+      err = -1;
+      goto done;
+    }
+
+  /* tG = G  and convert to montgomery */
+  mpz_set (tG-&gt;x, G-&gt;x);
+  mpz_set (tG-&gt;y, G-&gt;y);
+  mpz_set (tG-&gt;z, G-&gt;z);
+
+  /* calc the M tab */
+  /* M[0] == G */
+  mpz_set (M[0]-&gt;x, tG-&gt;x);
+  mpz_set (M[0]-&gt;y, tG-&gt;y);
+  mpz_set (M[0]-&gt;z, tG-&gt;z);
+  /* M[1] == 2G */
+  if ((err = ecc_projective_dbl_point (tG, M[1], a, modulus)) != 0)
+    {
+      goto done;
+    }
+
+  /* setup sliding window */
+  mode = 0;
+  bitcnt = 1;
+  buf = 0;
+  digidx = mpz_size (k) - 1;
+
+  /* perform ops */
+  for (;;)
+    {
+      /* grab next digit as required */
+      if (--bitcnt == 0)
+        {
+          if (digidx == -1)
+            {
+              break;
+            }
+          buf = mpz_getlimbn (k, digidx);
+          bitcnt = (int) MP_DIGIT_BIT;
+          --digidx;
+        }
+
+      /* grab the next msb from the ltiplicand */
+      i = (buf &gt;&gt; (MP_DIGIT_BIT - 1)) &amp; 1;
+      buf &lt;&lt;= 1;
+
+      if (mode == 0 &amp;&amp; i == 0)
+        {
+          /* dummy operations */
+          if ((err =
+               ecc_projective_add_point (M[0], M[1], M[2], a,
+                                             modulus)) != 0)
+            {
+              goto done;
+            }
+          if ((err =
+               ecc_projective_dbl_point (M[1], M[2], a, modulus)) != 0)
+            {
+              goto done;
+            }
+          continue;
+        }
+
+      if (mode == 0 &amp;&amp; i == 1)
+        {
+          mode = 1;
+          /* dummy operations */
+          if ((err =
+               ecc_projective_add_point (M[0], M[1], M[2], a,
+                                             modulus)) != 0)
+            {
+              goto done;
+            }
+          if ((err =
+               ecc_projective_dbl_point (M[1], M[2], a, modulus)) != 0)
+            {
+              goto done;
+            }
+          continue;
+        }
+
+      if ((err =
+           ecc_projective_add_point (M[0], M[1], M[i ^ 1], a,
+                                         modulus)) != 0)
+        {
+          goto done;
+        }
+      if ((err = ecc_projective_dbl_point (M[i], M[i], a, modulus)) != 0)
+        {
+          goto done;
+        }
+    }
+
+  /* copy result out */
+  mpz_set (R-&gt;x, M[0]-&gt;x);
+  mpz_set (R-&gt;y, M[0]-&gt;y);
+  mpz_set (R-&gt;z, M[0]-&gt;z);
+
+  /* map R back from projective space */
+  if (map)
+    {
+      err = ecc_map (R, modulus);
+    }
+  else
+    {
+      err = 0;
+    }
+done:
+  ecc_del_point (tG);
+  for (i = 0; i &lt; 3; i++)
+    {
+      ecc_del_point (M[i]);
+    }
+  return err;
+}
+
+/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ecc_mulmod_timing.c,v $ */
+/* $Revision: 1.13 $ */
+/* $Date: 2007/05/12 14:32:35 $ */
diff --git a/ecc_points.c b/ecc_points.c
new file mode 100644
index 0000000..cb57823
--- /dev/null
+++ b/ecc_points.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2011 Free Software Foundation, Inc.
+ *
+ * This file is part of GNUTLS.
+ *
+ * The GNUTLS library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
+ *
+ */
+
+/* Based on public domain code of LibTomCrypt by Tom St Denis.
+ * Adapted to gmp and nettle by Nikos Mavrogiannopoulos.
+ */
+
+#include "ecc.h"
+
+/*
+  @file ecc_points.c
+  ECC Crypto, Tom St Denis
+*/
+
+/*
+   Allocate a new ECC point
+   @return A newly allocated point or NULL on error 
+*/
+ecc_point *
+ecc_new_point (void)
+{
+  ecc_point *p;
+  p = calloc (1, sizeof (*p));
+  if (p == NULL)
+    {
+      return NULL;
+    }
+  if (mp_init_multi (&amp;p-&gt;x, &amp;p-&gt;y, &amp;p-&gt;z, NULL) != 0)
+    {
+      free (p);
+      return NULL;
+    }
+  return p;
+}
+
+/* Free an ECC point from memory
+  @param p   The point to free
+*/
+void
+ecc_del_point (ecc_point * p)
+{
+  /* prevents free'ing null arguments */
+  if (p != NULL)
+    {
+      mp_clear_multi (&amp;p-&gt;x, &amp;p-&gt;y, &amp;p-&gt;z, NULL);       /* note: p-&gt;z may be NULL \
but that's ok with this function anyways */ +      free (p);
+    }
+}
+
+/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ecc_points.c,v $ */
+/* $Revision: 1.7 $ */
+/* $Date: 2007/05/12 14:32:35 $ */
diff --git a/ecc_projective_add_point.c b/ecc_projective_add_point.c
new file mode 100644
index 0000000..5a8caaf
--- /dev/null
+++ b/ecc_projective_add_point.c
@@ -0,0 +1,230 @@
+/*
+ * Copyright (C) 2011 Free Software Foundation, Inc.
+ *
+ * This file is part of GNUTLS.
+ *
+ * The GNUTLS library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
+ *
+ */
+
+/* Based on public domain code of LibTomCrypt by Tom St Denis.
+ * Adapted to gmp and nettle by Nikos Mavrogiannopoulos.
+ */
+
+#include "ecc.h"
+
+/*
+  @file ecc_projective_add_point.c
+  ECC Crypto, Tom St Denis
+*/
+
+/*
+   Add two ECC points
+   @param P        The point to add
+   @param Q        The point to add
+   @param R        [out] The destination of the double
+   @param a        Curve's a value
+   @param modulus  The modulus of the field the ECC curve is in
+   @return 0 on success
+*/
+int
+ecc_projective_add_point (ecc_point * P, ecc_point * Q, ecc_point * R,
+                              mpz_t a, mpz_t modulus)
+{
+  mpz_t t1, t2, x, y, z;
+  int err;
+
+  assert (P != NULL);
+  assert (Q != NULL);
+  assert (R != NULL);
+  assert (modulus != NULL);
+
+  if ((err = mp_init_multi (&amp;t1, &amp;t2, &amp;x, &amp;y, &amp;z, NULL)) != 0)
+    {
+      return err;
+    }
+
+  /* Check if P == Q and do doubling in that case 
+   * If Q == -P then P+Q=point at infinity
+   */
+  if ((mpz_cmp (P-&gt;x, Q-&gt;x) == 0) &amp;&amp;
+      (mpz_cmp (P-&gt;z, Q-&gt;z) == 0))
+    {
+      /* x and z coordinates match. Check if P-&gt;y = Q-&gt;y, or P-&gt;y = -Q-&gt;y
+       */
+      if (mpz_cmp (P-&gt;y, Q-&gt;y) == 0)
+        {
+          mp_clear_multi (&amp;t1, &amp;t2, &amp;x, &amp;y, &amp;z, NULL);
+          return ecc_projective_dbl_point (P, R, a, modulus);
+        }
+      
+      mpz_sub (t1, modulus, Q-&gt;y);
+      if (mpz_cmp (P-&gt;y, t1) == 0)
+        {
+          mp_clear_multi (&amp;t1, &amp;t2, &amp;x, &amp;y, &amp;z, NULL);
+          mpz_set_ui(R-&gt;x, 1);
+          mpz_set_ui(R-&gt;y, 1);
+          mpz_set_ui(R-&gt;z, 0);
+          return 0;
+        }
+    }
+
+
+  mpz_set (x, P-&gt;x);
+  mpz_set (y, P-&gt;y);
+  mpz_set (z, P-&gt;z);
+
+  /* if Z is one then these are no-operations */
+  if (mpz_cmp_ui (Q-&gt;z, 1) != 0)
+    {
+      /* T1 = Z' * Z' */
+      mpz_mul (t1, Q-&gt;z, Q-&gt;z);
+      mpz_mod (t1, t1, modulus);
+      /* X = X * T1 */
+      mpz_mul (x, x, t1);
+      mpz_mod (x, x, modulus);
+      /* T1 = Z' * T1 */
+      mpz_mul (t1, t1, Q-&gt;z);
+      mpz_mod (t1, t1, modulus);
+      /* Y = Y * T1 */
+      mpz_mul (y, y, t1);
+      mpz_mod (y, y, modulus);
+    }
+
+  /* T1 = Z*Z */
+  mpz_mul (t1, z, z);
+  mpz_mod (t1, t1, modulus);
+  /* T2 = X' * T1 */
+  mpz_mul (t2, t1, Q-&gt;x);
+  mpz_mod (t2, t2, modulus);
+  /* T1 = Z * T1 */
+  mpz_mul (t1, t1, z);
+  mpz_mod (t1, t1, modulus);
+  /* T1 = Y' * T1 */
+  mpz_mul (t1, t1, Q-&gt;y);
+  mpz_mod (t1, t1, modulus);
+
+  /* Y = Y - T1 */
+  mpz_sub (y, y, t1);
+  if (mpz_cmp_ui (y, 0) &lt; 0)
+    {
+      mpz_add (y, y, modulus);
+    }
+  /* T1 = 2T1 */
+  mpz_add (t1, t1, t1);
+  if (mpz_cmp (t1, modulus) &gt;= 0)
+    {
+      mpz_sub (t1, t1, modulus);
+    }
+  /* T1 = Y + T1 */
+  mpz_add (t1, t1, y);
+  if (mpz_cmp (t1, modulus) &gt;= 0)
+    {
+      mpz_sub (t1, t1, modulus);
+    }
+  /* X = X - T2 */
+  mpz_sub (x, x, t2);
+  if (mpz_cmp_ui (x, 0) &lt; 0)
+    {
+      mpz_add (x, x, modulus);
+    }
+  /* T2 = 2T2 */
+  mpz_add (t2, t2, t2);
+  if (mpz_cmp (t2, modulus) &gt;= 0)
+    {
+      mpz_sub (t2, t2, modulus);
+    }
+  /* T2 = X + T2 */
+  mpz_add (t2, t2, x);
+  if (mpz_cmp (t2, modulus) &gt;= 0)
+    {
+      mpz_sub (t2, t2, modulus);
+    }
+
+  /* if Z' != 1 */
+  if (mpz_cmp_ui (Q-&gt;z, 1) != 0)
+    {
+      /* Z = Z * Z' */
+      mpz_mul (z, z, Q-&gt;z);
+      mpz_mod (z, z, modulus);
+    }
+
+  /* Z = Z * X */
+  mpz_mul (z, z, x);
+  mpz_mod (z, z, modulus);
+
+  /* T1 = T1 * X  */
+  mpz_mul (t1, t1, x);
+  mpz_mod (t1, t1, modulus);
+  /* X = X * X */
+  mpz_mul (x, x, x);
+  mpz_mod (x, x, modulus);
+  /* T2 = T2 * x */
+  mpz_mul (t2, t2, x);
+  mpz_mod (t2, t2, modulus);
+  /* T1 = T1 * X  */
+  mpz_mul (t1, t1, x);
+  mpz_mod (t1, t1, modulus);
+
+  /* X = Y*Y */
+  mpz_mul (x, y, y);
+  mpz_mod (x, x, modulus);
+  /* X = X - T2 */
+  mpz_sub (x, x, t2);
+  if (mpz_cmp_ui (x, 0) &lt; 0)
+    {
+      mpz_add (x, x, modulus);
+    }
+
+  /* T2 = T2 - X */
+  mpz_sub (t2, t2, x);
+  if (mpz_cmp_ui (t2, 0) &lt; 0)
+    {
+      mpz_add (t2, t2, modulus);
+    }
+  /* T2 = T2 - X */
+  mpz_sub (t2, t2, x);
+  if (mpz_cmp_ui (t2, 0) &lt; 0)
+    {
+      mpz_add (t2, t2, modulus);
+    }
+  /* T2 = T2 * Y */
+  mpz_mul (t2, t2, y);
+  mpz_mod (t2, t2, modulus);
+  /* Y = T2 - T1 */
+  mpz_sub (y, t2, t1);
+  if (mpz_cmp_ui (y, 0) &lt; 0)
+    {
+      mpz_add (y, y, modulus);
+    }
+  /* Y = Y/2 */
+  if (mp_isodd (y))
+    {
+      mpz_add (y, y, modulus);
+    }
+  mpz_divexact_ui (y, y, 2);
+
+  mpz_set (R-&gt;x, x);
+  mpz_set (R-&gt;y, y);
+  mpz_set (R-&gt;z, z);
+
+  err = 0;
+
+  mp_clear_multi (&amp;t1, &amp;t2, &amp;x, &amp;y, &amp;z, NULL);
+  return err;
+}
+
+/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ecc_projective_add_point.c,v $ */
+/* $Revision: 1.16 $ */
+/* $Date: 2007/05/12 14:32:35 $ */
diff --git a/ecc_projective_dbl_point.c b/ecc_projective_dbl_point.c
new file mode 100644
index 0000000..6f73c4e
--- /dev/null
+++ b/ecc_projective_dbl_point.c
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2011 Free Software Foundation, Inc.
+ *
+ * Author: Nikos Mavrogiannopoulos
+ *
+ * This file is part of GNUTLS.
+ *
+ * The GNUTLS library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
+ *
+ */
+
+/* Implements ECC point doubling over Z/pZ for curve y^2 = x^3 + ax + b
+ */
+#include "ecc.h"
+
+#ifndef ECC_SECP_CURVES_ONLY
+
+/*
+   Double an ECC point
+   @param P   The point to double
+   @param R   [out] The destination of the double
+   @param a       The "a" value from curve
+   @param modulus  The modulus of the field the ECC curve is in
+   @return 0 on success
+*/
+int
+ecc_projective_dbl_point (ecc_point * P, ecc_point * R, mpz_t a,
+                              mpz_t modulus)
+{
+  mpz_t t1, m, s;
+  int err;
+
+  assert (P != NULL);
+  assert (R != NULL);
+  assert (modulus != NULL);
+
+  /*
+    algorithm used:
+     if (Y == 0)
+       return POINT_AT_INFINITY
+     S = 4*X*Y^2
+     M = 3*X^2 + a*Z^4
+     X' = M^2 - 2*S
+     Y' = M*(S - X') - 8*Y^4
+     Z' = 2*Y*Z
+     return (X', Y', Z')
+   */
+
+  if (mpz_cmp_ui(P-&gt;y, 0) == 0)
+    {
+      /* point at infinity 
+       * under jacobian coordinates
+       */
+      mpz_set(R-&gt;x, 1);
+      mpz_set(R-&gt;y, 1);
+      mpz_set(R-&gt;z, 0);
+      
+      return 0;
+    }
+
+  if ((err = mp_init_multi (&amp;t1, &amp;m, &amp;s, NULL)) != 0)
+    {
+      return err;
+    }
+
+  if (P != R)
+    {
+      mpz_set (R-&gt;x, P-&gt;x);
+      mpz_set (R-&gt;y, P-&gt;y);
+      mpz_set (R-&gt;z, P-&gt;z);
+    }
+
+
+  /* m = Z * Z */
+  mpz_mul (m, R-&gt;z, R-&gt;z);
+  mpz_mod (m, m, modulus);
+
+  /* Calculate Z and get rid of it */
+  /* Z = Y * Z */
+  mpz_mul (R-&gt;z, R-&gt;y, R-&gt;z);
+  mpz_mod (R-&gt;z, R-&gt;z, modulus);
+  /* Z = 2Z */
+  mpz_add (R-&gt;z, R-&gt;z, R-&gt;z);
+  if (mpz_cmp (R-&gt;z, modulus) &gt;= 0)
+    {
+      mpz_sub (R-&gt;z, R-&gt;z, modulus);
+    }
+
+  /* continue with M and S calculations */
+
+  /* m = m * m = z^4 */
+  mpz_mul (m, m, m);
+  mpz_mod (m, m, modulus);
+
+  /* m = a * m = a*z^4 */
+  mpz_mul (m, a, m);
+  mpz_mod (m, m, modulus);
+
+  /* Y = 2y */
+  mpz_add (R-&gt;y, R-&gt;y, R-&gt;y);
+  if (mpz_cmp (R-&gt;y, modulus) &gt;= 0)
+    {
+      mpz_sub (R-&gt;y, R-&gt;y, modulus);
+    }
+
+  /* Y = Y * Y = 4y^2 */
+  mpz_mul (R-&gt;y, R-&gt;y, R-&gt;y);
+  mpz_mod (R-&gt;y, R-&gt;y, modulus);
+
+  /* s = X*Y = 4xy^2 */
+  mpz_mul (s, R-&gt;x, R-&gt;y);
+  mpz_mod (s, s, modulus);
+
+  /* X = x^2 */
+  mpz_mul (R-&gt;x, R-&gt;x, R-&gt;x);
+  mpz_mod (R-&gt;x, R-&gt;x, modulus);
+
+  /* t1 = 2X = 2x^2 */
+  mpz_add (t1, R-&gt;x, R-&gt;x);
+  if (mpz_cmp (t1, modulus) &gt;= 0)
+    {
+      mpz_sub (t1, t1, modulus);
+    }
+
+  /* t1 = t1+X = 3X =  3x^2 */
+  mpz_add (t1, t1, R-&gt;x);
+  if (mpz_cmp (t1, modulus) &gt;= 0)
+    {
+      mpz_sub (t1, t1, modulus);
+    }
+
+  /* m = t1+m = 3x^2 + a*z^4 */
+  mpz_add (m, m, t1);
+  if (mpz_cmp (m, modulus) &gt;= 0)
+    {
+      mpz_sub (m, m, modulus);
+    }
+
+  /*
+     X' = M^2 - 2*S
+     Y' = M*(S - X') - 8*Y^4
+   */
+
+  /* Y = Y*Y = 16y^4 */
+  mpz_mul (R-&gt;y, R-&gt;y, R-&gt;y);
+  mpz_mod (R-&gt;y, R-&gt;y, modulus);
+
+  /* Y = 8y^4 */
+  if (mp_isodd (R-&gt;y))
+    {
+      mpz_add (R-&gt;y, R-&gt;y, modulus);
+    }
+  mpz_divexact_ui (R-&gt;y, R-&gt;y, 2);
+
+  /* X = m^2 */
+  mpz_mul (R-&gt;x, m, m);
+  mpz_mod (R-&gt;x, R-&gt;x, modulus);
+
+  /* X = X - s = m^2 - s */
+  mpz_sub (R-&gt;x, R-&gt;x, s);
+  if (mpz_cmp_ui (R-&gt;x, 0) &lt; 0)
+    {
+      mpz_add (R-&gt;x, R-&gt;x, modulus);
+    }
+
+  /* X = X - s = m^2 - 2s */
+  mpz_sub (R-&gt;x, R-&gt;x, s);
+  if (mpz_cmp_ui (R-&gt;x, 0) &lt; 0)
+    {
+      mpz_add (R-&gt;x, R-&gt;x, modulus);
+    }
+
+  /* t1 = s - X */
+  mpz_sub (t1, s, R-&gt;x);
+  if (mpz_cmp_ui (t1, 0) &lt; 0)
+    {
+      mpz_add (t1, t1, modulus);
+    }
+
+  /* t1 = M * t1 = M * (s-X) */
+  mpz_mul (t1, m, t1);
+  mpz_mod (t1, t1, modulus);
+
+  /* Y = t1 - Y = (M * (s-X)) - 8y^4 */
+  mpz_sub (R-&gt;y, t1, R-&gt;y);
+  if (mpz_cmp_ui (R-&gt;y, 0) &lt; 0)
+    {
+      mpz_add (R-&gt;y, R-&gt;y, modulus);
+    }
+
+  err = 0;
+
+  mp_clear_multi (&amp;t1, &amp;m, &amp;s, NULL);
+  return err;
+}
+
+#endif
diff --git a/ecc_projective_dbl_point_3.c b/ecc_projective_dbl_point_3.c
new file mode 100644
index 0000000..18f7cb2
--- /dev/null
+++ b/ecc_projective_dbl_point_3.c
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2011 Free Software Foundation, Inc.
+ *
+ * This file is part of GNUTLS.
+ *
+ * The GNUTLS library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
+ *
+ */
+
+/* Based on public domain code of LibTomCrypt by Tom St Denis.
+ * Adapted to gmp and nettle by Nikos Mavrogiannopoulos.
+ */
+
+#include "ecc.h"
+
+/*
+  @file ecc_projective_dbl_point.c
+  ECC Crypto, Tom St Denis
+*/  
+
+#ifdef ECC_SECP_CURVES_ONLY
+
+/*
+   Double an ECC point
+   @param P   The point to double
+   @param R   [out] The destination of the double
+   @param modulus  The modulus of the field the ECC curve is in
+   @param mp       The "b" value from montgomery_setup()
+   @return 0 on success
+*/
+int
+ecc_projective_dbl_point (ecc_point * P, ecc_point * R, mpz_t a /* a is -3 */,
+                              mpz_t modulus)
+{
+   mpz_t t1, t2;
+   int   err;
+
+   assert(P       != NULL);
+   assert(R       != NULL);
+   assert(modulus != NULL);
+
+   if ((err = mp_init_multi(&amp;t1, &amp;t2, NULL)) != 0) {
+      return err;
+   }
+
+   if (P != R) {
+      mpz_set(R-&gt;x, P-&gt;x);
+      mpz_set(R-&gt;y, P-&gt;y);
+      mpz_set(R-&gt;z, P-&gt;z);
+   }
+
+   /* t1 = Z * Z */
+   mpz_mul(t1, R-&gt;z, R-&gt;z);
+   mpz_mod(t1, t1, modulus);
+   /* Z = Y * Z */
+   mpz_mul(R-&gt;z, R-&gt;y, R-&gt;z);
+   mpz_mod(R-&gt;z, R-&gt;z, modulus);
+   /* Z = 2Z */
+   mpz_add(R-&gt;z, R-&gt;z, R-&gt;z);
+   if (mpz_cmp(R-&gt;z, modulus) &gt;= 0) {
+      mpz_sub(R-&gt;z, R-&gt;z, modulus);
+   }
+   
+   /* T2 = X - T1 */
+   mpz_sub(t2, R-&gt;x, t1);
+   if (mpz_cmp_ui(t2, 0) &lt; 0) {
+      mpz_add(t2, t2, modulus);
+   }
+   /* T1 = X + T1 */
+   mpz_add(t1, t1, R-&gt;x);
+   if (mpz_cmp(t1, modulus) &gt;= 0) {
+      mpz_sub(t1, t1, modulus);
+   }
+   /* T2 = T1 * T2 */
+   mpz_mul(t2, t1, t2);
+   mpz_mod(t2, t2, modulus);
+   /* T1 = 2T2 */
+   mpz_add(t1, t2, t2);
+   if (mpz_cmp(t1, modulus) &gt;= 0) {
+      mpz_sub(t1, t1, modulus);
+   }
+   /* T1 = T1 + T2 */
+   mpz_add(t1, t1, t2);
+   if (mpz_cmp(t1, modulus) &gt;= 0) {
+      mpz_sub(t1, t1, modulus);
+   }
+
+   /* Y = 2Y */
+   mpz_add(R-&gt;y, R-&gt;y, R-&gt;y);
+   if (mpz_cmp(R-&gt;y, modulus) &gt;= 0) {
+      mpz_sub(R-&gt;y, R-&gt;y, modulus);
+   }
+   /* Y = Y * Y */
+   mpz_mul(R-&gt;y, R-&gt;y, R-&gt;y);
+   mpz_mod(R-&gt;y, R-&gt;y, modulus);
+   /* T2 = Y * Y */
+   mpz_mul(t2, R-&gt;y, R-&gt;y);
+   mpz_mod(t2, t2, modulus);
+   /* T2 = T2/2 */
+   if (mp_isodd(t2)) {
+      mpz_add(t2, t2, modulus);
+   }
+   mpz_divexact_ui(t2, t2, 2);
+   /* Y = Y * X */
+   mpz_mul(R-&gt;y, R-&gt;y, R-&gt;x);
+   mpz_mod(R-&gt;y, R-&gt;y, modulus);
+
+   /* X  = T1 * T1 */
+   mpz_mul(R-&gt;x, t1, t1);
+   mpz_mod(R-&gt;x, R-&gt;x, modulus);
+   /* X = X - Y */
+   mpz_sub(R-&gt;x, R-&gt;x, R-&gt;y);
+   if (mpz_cmp_ui(R-&gt;x, 0) &lt; 0) {
+      mpz_add(R-&gt;x, R-&gt;x, modulus);
+   }
+   /* X = X - Y */
+   mpz_sub(R-&gt;x, R-&gt;x, R-&gt;y);
+   if (mpz_cmp_ui(R-&gt;x, 0) &lt; 0) {
+      mpz_add(R-&gt;x, R-&gt;x, modulus);
+   }
+
+   /* Y = Y - X */     
+   mpz_sub(R-&gt;y, R-&gt;y, R-&gt;x);
+   if (mpz_cmp_ui(R-&gt;y, 0) &lt; 0) {
+      mpz_add(R-&gt;y, R-&gt;y, modulus);
+   }
+   /* Y = Y * T1 */
+   mpz_mul(R-&gt;y, R-&gt;y, t1);
+   mpz_mod(R-&gt;y, R-&gt;y, modulus);
+   /* Y = Y - T2 */
+   mpz_sub(R-&gt;y, R-&gt;y, t2);
+   if (mpz_cmp_ui(R-&gt;y, 0) &lt; 0) {
+      mpz_add( R-&gt;y, R-&gt;y, modulus);
+   }
+ 
+   err = 0;
+
+   mp_clear_multi(&amp;t1, &amp;t2, NULL);
+   return err;
+}
+#endif
+/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ecc_projective_dbl_point.c,v $ */
+/* $Revision: 1.11 $ */
+/* $Date: 2007/05/12 14:32:35 $ */
+
diff --git a/ecc_shared_secret.c b/ecc_shared_secret.c
new file mode 100644
index 0000000..e24c140
--- /dev/null
+++ b/ecc_shared_secret.c
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2011 Free Software Foundation, Inc.
+ *
+ * This file is part of GNUTLS.
+ *
+ * The GNUTLS library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
+ *
+ */
+
+/* Based on public domain code of LibTomCrypt by Tom St Denis.
+ * Adapted to gmp and nettle by Nikos Mavrogiannopoulos.
+ */
+
+#include "ecc.h"
+#include &lt;string.h&gt;
+
+/*
+  @file ecc_shared_secret.c
+  ECC Crypto, Tom St Denis
+*/
+
+/*
+  Create an ECC shared secret between two keys
+  @param private_key      The private ECC key
+  @param public_key       The public key
+  @param out              [out] Destination of the shared secret (Conforms to EC-DH \
from ANSI X9.63) +  @param outlen           [in/out] The max size and resulting size \
of the shared secret +  @return 0 if successful
+*/
+int
+ecc_shared_secret (ecc_key * private_key, ecc_key * public_key,
+                   unsigned char *out, unsigned long *outlen)
+{
+  unsigned long x;
+  ecc_point *result;
+  int err;
+
+  assert (private_key != NULL);
+  assert (public_key != NULL);
+  assert (out != NULL);
+  assert (outlen != NULL);
+
+  /* type valid? */
+  if (private_key-&gt;type != PK_PRIVATE)
+    {
+      return -1;
+    }
+
+  /* make new point */
+  result = ecc_new_point ();
+  if (result == NULL)
+    {
+      return -1;
+    }
+
+  if ((err =
+       ecc_mulmod (private_key-&gt;k, &amp;public_key-&gt;pubkey, result,
+                       private_key-&gt;A, private_key-&gt;prime, 1)) != 0)
+    {
+      goto done;
+    }
+
+  x = nettle_mpz_sizeinbase_256_u (private_key-&gt;prime);
+  if (*outlen &lt; x)
+    {
+      *outlen = x;
+      err = -1;
+      goto done;
+    }
+  memset (out, 0, x);
+  nettle_mpz_get_str_256(x, out + (x - nettle_mpz_sizeinbase_256_u (result-&gt;x)), \
result-&gt;x); +
+  err = 0;
+  *outlen = x;
+done:
+  ecc_del_point (result);
+  return err;
+}
+
+/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ecc_shared_secret.c,v $ */
+/* $Revision: 1.10 $ */
+/* $Date: 2007/05/12 14:32:35 $ */
diff --git a/ecc_sign_hash.c b/ecc_sign_hash.c
new file mode 100644
index 0000000..cc58a23
--- /dev/null
+++ b/ecc_sign_hash.c
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2011 Free Software Foundation, Inc.
+ *
+ * This file is part of GNUTLS.
+ *
+ * The GNUTLS library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
+ *
+ */
+
+/* Based on public domain code of LibTomCrypt by Tom St Denis.
+ * Adapted to gmp and nettle by Nikos Mavrogiannopoulos.
+ */
+
+#include "ecc.h"
+#include &lt;nettle/dsa.h&gt;
+
+/*
+  @file ecc_sign_hash.c
+  ECC Crypto, Tom St Denis
+*/
+
+/*
+  Sign a message digest
+  @param in        The message digest to sign
+  @param inlen     The length of the digest
+  @param sign      The destination for the signature
+  @param prng      An active PRNG state
+  @param wprng     The index of the PRNG you wish to use
+  @param key       A private ECC key
+  @return 0 if successful
+*/
+int
+ecc_sign_hash (const unsigned char *in, unsigned long inlen,
+               struct dsa_signature *sig,
+               void *random_ctx, nettle_random_func random, ecc_key * key)
+{
+  ecc_key pubkey;
+  mpz_t e;
+  int err;
+
+  assert (in != NULL);
+  assert (sig != NULL);
+  assert (key != NULL);
+
+  /* is this a private key? */
+  if (key-&gt;type != PK_PRIVATE)
+    {
+      return -1;
+    }
+
+  /* get the hash and load it as a bignum into 'e' */
+  /* init the bignums */
+  if ((err = mp_init_multi (&amp;e, NULL)) != 0)
+    {
+      return err;
+    }
+
+  nettle_mpz_set_str_256_u (e, inlen, in);
+
+  /* make up a key and export the public copy */
+  for (;;)
+    {
+      if ((err =
+           ecc_make_key_ex (random_ctx, random, &amp;pubkey, key-&gt;prime,
+                            key-&gt;order, key-&gt;A, key-&gt;Gx, key-&gt;Gy)) != 0)
+        {
+          goto errnokey;
+        }
+
+      /* find r = x1 mod n */
+      mpz_mod (sig-&gt;r, pubkey.pubkey.x, pubkey.order);
+
+      if (mpz_cmp_ui (sig-&gt;r, 0) == 0)
+        {
+          ecc_free (&amp;pubkey);
+        }
+      else
+        {
+          /* find s = (e + xr)/k */
+          mpz_invert (pubkey.k, pubkey.k, pubkey.order);
+
+          /* mulmod */
+          mpz_mul (sig-&gt;s, key-&gt;k, sig-&gt;r);
+          mpz_mod (sig-&gt;s, sig-&gt;s, pubkey.order);
+          mpz_add (sig-&gt;s, e, sig-&gt;s);
+          mpz_mod (sig-&gt;s, sig-&gt;s, pubkey.order);
+
+          mpz_mul (sig-&gt;s, sig-&gt;s, pubkey.k);
+          mpz_mod (sig-&gt;s, sig-&gt;s, pubkey.order);
+          ecc_free (&amp;pubkey);
+          if (mpz_cmp_ui (sig-&gt;s, 0) != 0)
+            {
+              break;
+            }
+        }
+    }
+
+errnokey:
+  mp_clear_multi (&amp;e, NULL);
+  return err;
+}
+
+/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ecc_sign_hash.c,v $ */
+/* $Revision: 1.11 $ */
+/* $Date: 2007/05/12 14:32:35 $ */
diff --git a/ecc_verify_hash.c b/ecc_verify_hash.c
new file mode 100644
index 0000000..92a996e
--- /dev/null
+++ b/ecc_verify_hash.c
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2011 Free Software Foundation, Inc.
+ *
+ * This file is part of GNUTLS.
+ *
+ * The GNUTLS library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
+ *
+ */
+
+/* Based on public domain code of LibTomCrypt by Tom St Denis.
+ * Adapted to gmp and nettle by Nikos Mavrogiannopoulos.
+ */
+
+#include "ecc.h"
+
+/*
+  @file ecc_verify_hash.c
+  ECC Crypto, Tom St Denis
+*/
+
+/* verify 
+ *
+ * w  = s^-1 mod n
+ * u1 = xw 
+ * u2 = rw
+ * X = u1*G + u2*Q
+ * v = X_x1 mod n
+ * accept if v == r
+ */
+
+/*
+   Verify an ECC signature
+   @param signature         The signature to verify
+   @param hash        The hash (message digest) that was signed
+   @param hashlen     The length of the hash (octets)
+   @param stat        Result of signature, 1==valid, 0==invalid
+   @param key         The corresponding public ECC key
+   @return 0 if successful (even if the signature is not valid)
+*/
+int
+ecc_verify_hash (struct dsa_signature *signature,
+                 const unsigned char *hash, unsigned long hashlen,
+                 int *stat, ecc_key * key)
+{
+  ecc_point *mG, *mQ;
+  mpz_t v, w, u1, u2, e;
+  int err;
+
+  assert (signature != NULL);
+  assert (hash != NULL);
+  assert (stat != NULL);
+  assert (key != NULL);
+
+  /* default to invalid signature */
+  *stat = 0;
+
+  /* allocate ints */
+  if ((err = mp_init_multi (&amp;v, &amp;w, &amp;u1, &amp;u2, &amp;e, NULL)) != 0)
+    {
+      return -1;
+    }
+
+  /* allocate points */
+  mG = ecc_new_point ();
+  mQ = ecc_new_point ();
+  if (mQ == NULL || mG == NULL)
+    {
+      err = -1;
+      goto error;
+    }
+
+  /* check for (0) */
+  if (mpz_cmp_ui (signature-&gt;r, 0) == 0 || mpz_cmp_ui (signature-&gt;s, 0) == 0
+      || mpz_cmp (signature-&gt;r, key-&gt;order) &gt;= 0
+      || mpz_cmp (signature-&gt;s, key-&gt;order) &gt;= 0)
+    {
+      err = -1;
+      goto error;
+    }
+
+  /* read hash */
+  nettle_mpz_set_str_256_u (e, hashlen, hash);
+
+  /*  w  = s^-1 mod n */
+  mpz_invert (w, signature-&gt;s, key-&gt;order);
+
+  /* u1 = ew */
+  mpz_mul (u1, e, w);
+  mpz_mod (u1, u1, key-&gt;order);
+
+  /* u2 = rw */
+  mpz_mul (u2, signature-&gt;r, w);
+  mpz_mod (u2, u2, key-&gt;order);
+
+  /* find mG and mQ */
+  mpz_set (mG-&gt;x, key-&gt;Gx);
+  mpz_set (mG-&gt;y, key-&gt;Gy);
+  mpz_set_ui (mG-&gt;z, 1);
+
+  mpz_set (mQ-&gt;x, key-&gt;pubkey.x);
+  mpz_set (mQ-&gt;y, key-&gt;pubkey.y);
+  mpz_set (mQ-&gt;z, key-&gt;pubkey.z);
+
+  /* compute u1*mG + u2*mQ = mG */
+  if ((err = ecc_mulmod (u1, mG, mG, key-&gt;A, key-&gt;prime, 0)) != 0)
+    {
+      goto error;
+    }
+  if ((err = ecc_mulmod (u2, mQ, mQ, key-&gt;A, key-&gt;prime, 0)) != 0)
+    {
+      goto error;
+    }
+
+  /* add them */
+  if ((err =
+       ecc_projective_add_point (mQ, mG, mG, key-&gt;A, key-&gt;prime)) != 0)
+    {
+      goto error;
+    }
+
+  /* reduce */
+  if ((err = ecc_map (mG, key-&gt;prime)) != 0)
+    {
+      goto error;
+    }
+
+  /* v = X_x1 mod n */
+  mpz_mod (v, mG-&gt;x, key-&gt;order);
+
+  /* does v == r */
+  if (mpz_cmp (v, signature-&gt;r) == 0)
+    {
+      *stat = 1;
+    }
+
+  /* clear up and return */
+  err = 0;
+error:
+  ecc_del_point (mG);
+  ecc_del_point (mQ);
+  mp_clear_multi (&amp;v, &amp;w, &amp;u1, &amp;u2, &amp;e, NULL);
+  return err;
+}
+
+/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ecc_verify_hash.c,v $ */
+/* $Revision: 1.14 $ */
+/* $Date: 2007/05/12 14:32:35 $ */
diff --git a/nettle.texinfo b/nettle.texinfo
index 36b9a00..5c32e39 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -85,6 +85,8 @@ Public-key algorithms
 
 * RSA::                         The RSA public key algorithm.
 * DSA::                         The DSA digital signature algorithm.
+* ECDSA::                       The ECDSA digital signature algorithm.
+* ECDH::                        The EC Diffie-Hellman key exchange algorithm.
 
 @end detailmenu
 @end menu
@@ -214,6 +216,11 @@ for bignum operations.
 @item DSA
 Written by @value{AUTHOR}, released under the LGPL. Uses the GMP library
 for bignum operations.
+
+@item ECDSA and ECDH
+Added by Nikos Mavrogiannopoulos, based on code by Tom St. Dennis, released 
+under the LGPL. Uses the GMP library for bignum operations.
+
 @end table
 
 @node Conventions, Example, Copyright, Top
@@ -2040,6 +2047,8 @@ key, and to no others''.
 @menu
 * RSA::                         The RSA public key algorithm.
 * DSA::                         The DSA digital signature algorithm.
+* ECDSA::                       The ECDSA digital signature algorithm.
+* ECDH::                        The EC Diffie-Hellman key exchange algorithm.
 @end menu
 
 @node RSA, DSA, Public-key algorithms, Public-key algorithms
@@ -2255,7 +2264,7 @@ example if if @var{n_size} is too small, or if @var{e_size} is \
zero and  @code{pub-&gt;e} is an even number.
 @end deftypefun
 
-@node DSA,  , RSA, Public-key algorithms
+@node DSA, ECDSA, RSA, Public-key algorithms
 @comment  node-name,  next,  previous,  up
 @subsection Nettle's @acronym{DSA} support
 
@@ -2499,6 +2508,70 @@ Returns one on success, and zero on failure. The function will \
fail if  small.
 @end deftypefun
 
+@node ECDSA, ECDH, DSA, Public-key algorithms
+@comment  node-name,  next,  previous,  up
+@subsection Nettle's @acronym{ECDSA} support
+
+The @acronym{ECDSA} digital signature algorithm is the counter-part
+of @acronym{DSA} over elliptic curves.
+
+Nettle represents @acronym{ECDSA} keys using the @code{ecc_key}
+structure. 
+
+@deftp {Context struct} {ecc_key} prime order A Gx Gy pubkey k
+The public and private parameters.
+@end deftp
+
+Before use, these structs must be initialized by calling one of
+@code{ecc_make_key} or @code{ecc_make_key_ex}.
+When finished with them, the space for the numbers must be
+deallocated by @code{ecc_free}.
+
+Signatures are represented using same structure as with DSA signatures, 
+and need to be initialized and cleared in the same way as for the
+DSA case.
+
+@deftp {Context struct} {dsa_signature} r s
+@end deftp
+
+@deftypefun void dsa_signature_init (struct dsa_signature *@var{signature})
+@deftypefunx void dsa_signature_clear (struct dsa_signature *@var{signature})
+You must call @code{dsa_signature_init} before creating or using a
+signature, and call @code{dsa_signature_clear} when you are finished
+with it.
+@end deftypefun
+
+For signing, you need to provide both the ECC key
+and a source for random numbers.
+
+@deftypefun int ecc_sign_hash (const unsigned char *in,  unsigned long inlen, struct \
dsa_signature *signature, void *random_ctx, nettle_random_func random, ecc_key *key); \
+Creates a signature from the given hash value. +@var{random_ctx} and @var{random} is \
a randomness generator. +For advice, see
+@xref{Randomness}. Returns one on success, or zero on failure.
+Signing fails if the key size and the hash size don't match.
+@end deftypefun
+
+Verifying signatures is a little easier, since no randomness generator is
+needed. The functions are
+
+@deftypefun int ecc_verify_hash (struct dsa_signature * signature, const unsigned \
char *hash, unsigned long hashlen, int *stat, ecc_key *key); +Verifies a signature. \
The status of the signature verification is stored in stat. It is 1 if the signature \
is valid, otherwise 0. +@end deftypefun
+
+@node ECDH,  , ECDSA, Public-key algorithms
+@comment  node-name,  next,  previous,  up
+@subsection Nettle's @acronym{ECDH} support
+
+The @acronym{ECDH} key exchange method is the counter-part
+of Diffie-Hellman over elliptic curves. It uses the same keys
+as @code{ECDSA}.
+
+@acronym{ECDH} keys are also represented using the @code{ecc_key}
+structure. 
+
+For key exchange the @code{ecc_shared_secret} function is used.
+
 @node Randomness, Miscellaneous functions, Public-key algorithms, Reference
 @comment  node-name,  next,  previous,  up
 @section Randomness
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 8a263cb..0d41a13 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -20,7 +20,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    sha1-test.c sha224-test.c sha256-test.c \
 		    sha384-test.c sha512-test.c \
 		    serpent-test.c twofish-test.c \
-		    knuth-lfib-test.c \
+		    knuth-lfib-test.c ecc-test.c \
 		    cbc-test.c ctr-test.c gcm-test.c hmac-test.c \
 		    meta-hash-test.c meta-cipher-test.c meta-armor-test.c \
 		    buffer-test.c yarrow-test.c
diff --git a/testsuite/ecc-test.c b/testsuite/ecc-test.c
new file mode 100644
index 0000000..c8609b0
--- /dev/null
+++ b/testsuite/ecc-test.c
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2011 Free Software Foundation, Inc.
+ *
+ * This file is part of GNUTLS.
+ *
+ * The GNUTLS library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
+ *
+ */
+
+/* Based on public domain code of LibTomCrypt by Tom St Denis.
+ * Adapted to gmp and nettle by Nikos Mavrogiannopoulos.
+ */
+
+#include "ecc.h"
+#include "gnettle.h"
+#include &lt;gnutls_int.h&gt;
+#include &lt;algorithms.h&gt;
+
+/**
+  @file ecc_test.c
+  ECC Crypto, Tom St Denis
+*/
+
+/**
+  Perform on the ECC system
+  @return 0 if successful
+*/
+int
+ecc_test (void)
+{
+  mpz_t modulus, order, A;
+  ecc_point *G, *GG;
+  int i, err;
+
+  if ((err = mp_init_multi (&amp;modulus, &amp;A, &amp;order, NULL)) != 0)
+    {
+      return err;
+    }
+
+  G = ecc_new_point ();
+  GG = ecc_new_point ();
+  if (G == NULL || GG == NULL)
+    {
+      mp_clear_multi (&amp;modulus, &amp;order, NULL);
+      ecc_del_point (G);
+      ecc_del_point (GG);
+      return -1;
+    }
+
+  for (i = 0; i &lt; 16; i++)
+    {
+      const ecc_set_type *st = ecc_curves_secp[i];
+      
+      if (st-&gt;name == NULL)
+        break;
+
+      printf ("Testing %s (%d)\n", st-&gt;name, i);
+
+      if (mpz_set_str (A, (char *) st-&gt;A, 16) != 0)
+        {
+          fprintf (stderr, "Error loading curve %s: %d\n", st-&gt;name, __LINE__);
+          err = -1;
+          goto done;
+        }
+
+      if (mpz_set_str (modulus, (char *) st-&gt;prime, 16) != 0)
+        {
+          fprintf (stderr, "Error loading curve %s: %d\n", st-&gt;name, __LINE__);
+          err = -1;
+          goto done;
+        }
+
+      if (mpz_set_str (order, (char *) st-&gt;order, 16) != 0)
+        {
+          fprintf (stderr, "Error loading curve %s: %d\n", st-&gt;name, __LINE__);
+          err = -1;
+          goto done;
+        }
+
+      /* is prime actually prime? */
+      if ((err = mpz_probab_prime_p (modulus, PRIME_CHECK_PARAM)) &lt;= 0)
+        {
+          fprintf (stderr, "Error loading curve %s: %d\n", st-&gt;name, __LINE__);
+          err = -1;
+          goto done;
+        }
+
+      if ((err = mpz_probab_prime_p (order, PRIME_CHECK_PARAM)) &lt;= 0)
+        {
+          fprintf (stderr, "Error loading curve %s: %d\n", st-&gt;name, __LINE__);
+          err = -1;
+          goto done;
+        }
+
+      if (mpz_set_str (G-&gt;x, (char *) st-&gt;Gx, 16) != 0)
+        {
+          fprintf (stderr, "Error loading curve %s: %d\n", st-&gt;name, __LINE__);
+          err = -1;
+          goto done;
+        }
+
+      if (mpz_set_str (G-&gt;y, (char *) st-&gt;Gy, 16) != 0)
+        {
+          fprintf (stderr, "Error loading curve %s: %d\n", st-&gt;name, __LINE__);
+          err = -1;
+          goto done;
+        }
+      mpz_set_ui (G-&gt;z, 1);
+
+      /* then we should have G == (order + 1)G */
+      mpz_add_ui (order, order, 1);
+      if ((err = ecc_mulmod (order, G, GG, A, modulus, 1)) != 0)
+        {
+          goto done;
+        }
+
+      if (mpz_cmp (G-&gt;y, GG-&gt;y) != 0)
+        {
+          fprintf (stderr, "Error in curve %s: %d\n", st-&gt;name, __LINE__);
+          err = -1;
+          goto done;
+        }
+
+      if (mpz_cmp (G-&gt;x, GG-&gt;x) != 0)
+        {
+          fprintf (stderr, "Error in curve %s: %d\n", st-&gt;name, __LINE__);
+          err = -1;
+          goto done;
+        }
+
+    }
+  err = 0;
+done:
+  ecc_del_point (GG);
+  ecc_del_point (G);
+  mp_clear_multi (&amp;order, &amp;modulus, &amp;A, NULL);
+  return err;
+}
+
+/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ecc_test.c,v $ */
+/* $Revision: 1.12 $ */
+/* $Date: 2007/05/12 14:32:35 $ */
-- 
1.7.4.1



</body></email><email><emailId>20110814174350</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-08-14 17:43:50-0400</timestampReceived><subject>Re: ECC support</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; This patch adds ECC support using the GnuTLS libtomcrypt adaptation.

Nice! Needs some more work to really fit with nettle. Some initial
comments based on the header file:

&gt; +/* assume curve is y^2 = x^3 - 3x + b
&gt; + * instead of the generic y^2 = x^3 + ax + b
&gt; + *
&gt; + * (XXX: the generic case has been tested only
&gt; + *  with the SECG curves.)
&gt; + */

Maybe the naming in the itnerface should reflect that it's a special
case.

&gt; +/* ---- ECC Routines ---- */
&gt; +/* size of our temp buffers for exported keys */
&gt; +#define ECC_BUF_SIZE 512
&gt; +
&gt; +/* max private key size */
&gt; +#define ECC_MAXSIZE  66

Where do these maximums come from?

&gt; +/** Structure defines a NIST GF(p) curve */
&gt; +typedef struct {
&gt; +   /** The size of the curve in octets */
&gt; +   int size;
&gt; +
&gt; +   /** name of curve */
&gt; +   const char *name; 
&gt; +   
&gt; +   /** curve's OID */
&gt; +   const char *oid;
&gt; +
&gt; +   /** The prime that defines the field the curve is in (encoded in hex) */
&gt; +   const char *prime;
&gt; +
&gt; +   /** The fields A param (hex) */
&gt; +   const char *A;
&gt; +
&gt; +   /** The fields B param (hex) */
&gt; +   const char *B;
&gt; +
&gt; +   /** The order of the curve (hex) */
&gt; +   const char *order;
&gt; +  
&gt; +   /** The x co-ordinate of the base point on the curve (hex) */
&gt; +   const char *Gx;
&gt; + 
&gt; +   /** The y co-ordinate of the base point on the curve (hex) */
&gt; +   const char *Gy;
&gt; +} ecc_set_type;

Avoid using typedef for plain structs.

I'm not sure I like using hex strings for the constants. Depends a bit
on usage, of course. E.g., it's a bit difficult to define a constant
mpz_t.

&gt; +/** An ECC key */
&gt; +typedef struct {
&gt; +    /** Type of key, PK_PRIVATE or PK_PUBLIC */
&gt; +    int type;
&gt; +
&gt; +    mpz_t prime;
&gt; +    mpz_t order;
&gt; +    mpz_t A;
&gt; +    mpz_t Gx;
&gt; +    mpz_t Gy;
&gt; +
&gt; +    /** The public key */
&gt; +    ecc_point pubkey;
&gt; +
&gt; +    /** The private key */
&gt; +    mpz_t k;
&gt; +} ecc_key;

I'd follow nettle's DSA interface with separate structs for the public
and private parameters, and eliminate the PK_PRIVATE and PK_PUBLIC
constants. I think it would also make sense to move out the curve
parameters to it's own struct (typed as mpz_t, then, unlike ecc_set_tyep
above).

&gt; +/* Key generation */
&gt; +int ecc_make_key(void *random_ctx, nettle_random_func random, ecc_key *key, const \
&gt; ecc_set_type *dp); +int ecc_make_key_ex(void *random_ctx, nettle_random_func \
&gt; random, ecc_key *key, mpz_t prime, mpz_t order, mpz_t A, mpz_t Gx, mpz_t Gy); +void \
&gt; ecc_free(ecc_key *key);

I haven't figured out exactly what these do, but naming should most
likele be _init and _clear, for consistency with the rest of nettle and
with gmp.

&gt; +/* EC-Diffie-Hellman */
&gt; +int  ecc_shared_secret(ecc_key *private_key, ecc_key *public_key, 
&gt; +                       unsigned char *out, unsigned long *outlen);

Haven't looked at this; for diffie-hellman over the normal ring one
would just use gmp's powm function. I think the corresponding ecc
function should also be public (maybe it already is?).

&gt; +/* ECDSA */
&gt; +int ecc_sign_hash(const unsigned char *in,  unsigned long inlen, 
&gt; +                        struct dsa_signature *signature,
&gt; +                        void *random_ctx, nettle_random_func random, ecc_key \
&gt; *key); +
&gt; +int  ecc_verify_hash(struct dsa_signature * signature,
&gt; +                     const unsigned char *hash, unsigned long hashlen, 
&gt; +                     int *stat, ecc_key *key);

Do these correspond to the _sign_digest and _verify_digest functions for
dsa and rsa?

&gt; +/* (Internal) low level functions */
&gt; +ecc_point *ecc_new_point(void);
&gt; +void       ecc_del_point(ecc_point *p);

It's more nettle style to let the caller allocate the structs.
ecc_point_init and ecc_point_clear would be more appropriate.

&gt; +/* point ops (mp == montgomery digit) */
&gt; +/* R = 2P */
&gt; +int ecc_projective_dbl_point(ecc_point *P, ecc_point *R, mpz_t a,  mpz_t modulus);
&gt; +
&gt; +/* R = P + Q */
&gt; +int ecc_projective_add_point(ecc_point *P, ecc_point *Q, ecc_point *R, mpz_t A, \
&gt; mpz_t modulus);

Is it customary jargon and notation to think about the the ecc group
operation as addition rather than multiplication? (Choice is arbitrary).

&gt; +/* R = kG */
&gt; +int ecc_mulmod(mpz_t k, ecc_point *G, ecc_point *R, mpz_t a, mpz_t modulus, int \
&gt; map);

I'd call the it ecc_scalar_mul or something like that, rather than
mulmod. Algebraically, any (cummutative?) group is a module over Z or
over Z/(group order) or something like that (sorry, I don't recall the
fine details since I studied algebra), and that's the type of
multiplication we're doing: Z x G -&gt; G.

&gt; +int mp_init_multi(mpz_t *a, ...);
&gt; +void mp_clear_multi(mpz_t *a, ...);

Not sure I like these.

&gt; +#define mp_isodd(a)                  (mpz_size(a) &gt; 0 ? (mpz_getlimbn(a, 0) &amp; 1 ? \
&gt; 1 : 0) : 0)

Just use mpz_odd_p.

&gt; +#define MP_DIGIT_BIT (sizeof(mp_limb_t) * 8 - GMP_NAIL_BITS)

Same as GMP_NUMB_BITS.

/nisse

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20110814184713</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-08-14 18:47:13-0400</timestampReceived><subject>Re: ECC support</subject><body>

On 08/14/2011 07:43 PM, Niels Möller wrote:

&gt; &gt; +/* assume curve is y^2 = x^3 - 3x + b
&gt; &gt; + * instead of the generic y^2 = x^3 + ax + b
&gt; &gt; + *
&gt; &gt; + * (XXX: the generic case has been tested only
&gt; &gt; + *  with the SECG curves.)
&gt; &gt; + */
&gt; Maybe the naming in the itnerface should reflect that it's a special
&gt; case.

You can use the generic code by keeping ecc_projective_add_point.c
instead of ecc_projective_add_point_3.c. I have not tested the
generic code though with other curves than the SECP that use
a = -3. The improvement from the special case is not that
significant.

&gt; &gt; +/* ---- ECC Routines ---- */
&gt; &gt; +/* size of our temp buffers for exported keys */
&gt; &gt; +#define ECC_BUF_SIZE 512
&gt; &gt; +/* max private key size */
&gt; &gt; +#define ECC_MAXSIZE  66
&gt; Where do these maximums come from?

&gt; From the sizes of the supported groups.

&gt; &gt; +/* Key generation */
&gt; &gt; +int ecc_make_key(void *random_ctx, nettle_random_func random, ecc_key *key, \
&gt; &gt; const ecc_set_type *dp); +int ecc_make_key_ex(void *random_ctx, \
&gt; &gt; nettle_random_func random, ecc_key *key, mpz_t prime, mpz_t order, mpz_t A, mpz_t \
&gt; &gt; Gx, mpz_t Gy); +void ecc_free(ecc_key *key);
&gt; I haven't figured out exactly what these do, but naming should most
&gt; likele be _init and _clear, for consistency with the rest of nettle and
&gt; with gmp.

make_key is actually _init and _generate in one.

&gt; &gt; +/* EC-Diffie-Hellman */
&gt; &gt; +int  ecc_shared_secret(ecc_key *private_key, ecc_key *public_key, 
&gt; &gt; +                       unsigned char *out, unsigned long *outlen);
&gt; Haven't looked at this; for diffie-hellman over the normal ring one
&gt; would just use gmp's powm function. I think the corresponding ecc
&gt; function should also be public (maybe it already is?).

Could be. This is a convenience function.

&gt; &gt; +/* ECDSA */
&gt; &gt; +int ecc_sign_hash(const unsigned char *in,  unsigned long inlen, 
&gt; &gt; +                        struct dsa_signature *signature,
&gt; &gt; +                        void *random_ctx, nettle_random_func random, ecc_key \
&gt; &gt; *key); +
&gt; &gt; +int  ecc_verify_hash(struct dsa_signature * signature,
&gt; &gt; +                     const unsigned char *hash, unsigned long hashlen, 
&gt; &gt; +                     int *stat, ecc_key *key);
&gt; Do these correspond to the _sign_digest and _verify_digest functions for
&gt; dsa and rsa?

Indeed but they are not limited to a particular digest. Any hash can be
used.

&gt; &gt; +/* point ops (mp == montgomery digit) */
&gt; &gt; +/* R = 2P */
&gt; &gt; +int ecc_projective_dbl_point(ecc_point *P, ecc_point *R, mpz_t a,  mpz_t \
&gt; &gt; modulus); +
&gt; &gt; +/* R = P + Q */
&gt; &gt; +int ecc_projective_add_point(ecc_point *P, ecc_point *Q, ecc_point *R, mpz_t A, \
&gt; &gt; mpz_t modulus);
&gt; Is it customary jargon and notation to think about the the ecc group
&gt; operation as addition rather than multiplication? (Choice is arbitrary).

I've never seen multiplication being used to describe this operation
(either in cryptography or pure mathematics).

&gt; &gt; +int mp_init_multi(mpz_t *a, ...);
&gt; &gt; +void mp_clear_multi(mpz_t *a, ...);
&gt; Not sure I like these.

They simplify code utilizing multiple mpz_ts significantly.

regards,
Nikos


</body></email><email><emailId>20110814200602</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-08-14 20:06:02-0400</timestampReceived><subject>Re: ECC support</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Indeed but they are not limited to a particular digest. Any hash can be
&gt; used.

And the hash algorithm is not encoded into the signature process
(copmare to rsa pkcs#1 signatures)? I have to read up on how these ecc
signatures are done. I think a comment said that it was analogous to
dsa, but dsa is tied quite hard to a particular hash function (and the
digest size should also match the size of the subgroup where the group
operations take place).

&gt; I've never seen multiplication being used to describe this operation
&gt; (either in cryptography or pure mathematics).

I think the group operation of an arbitrary group is usually written as
a multiplication in abstract algebra textbooks. E.g., Herstein's Topics
in Algebra. Maybe the reason for this tradition is that it is natural
when group elements are functions (in particular, permutations), and the
group operation is composition (but then Herstein has an unusual
convention for the argument order of compositions...).

Do I understand you correctly that the group operations is usually
written as an addition in the context of elliptic curves?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110814232321</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-08-14 23:23:21-0400</timestampReceived><subject>Re: ECC support</subject><body>

On 08/14/2011 10:06 PM, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt;&gt; Indeed but they are not limited to a particular digest. Any hash
&gt;&gt; can be used.
&gt; And the hash algorithm is not encoded into the signature process 
&gt; (copmare to rsa pkcs#1 signatures)? I have to read up on how these
&gt; ecc signatures are done. I think a comment said that it was analogous
&gt; to dsa, but dsa is tied quite hard to a particular hash function (and
&gt; the digest size should also match the size of the subgroup where the
&gt; group operations take place).

ECDSA is very similar to DSA. Specific hash functions are used for
specific curves, but it always depends on the profile. E.g. rfc5480
has a table with the allowed combinations and a table with the
recommended combinations.

Unfortunately DSA (and ECDSA) require a profile, or are practically
unimplementable.

&gt;&gt; I've never seen multiplication being used to describe this
&gt;&gt; operation (either in cryptography or pure mathematics).
&gt; I think the group operation of an arbitrary group is usually written
&gt; as a multiplication in abstract algebra textbooks. E.g., Herstein's
&gt; Topics in Algebra. Maybe the reason for this tradition is that it is
&gt; natural when group elements are functions (in particular,
&gt; permutations), and the group operation is composition (but then
&gt; Herstein has an unusual convention for the argument order of
&gt; compositions...). Do I understand you correctly that the group
&gt; operations is usually written as an addition in the context of
&gt; elliptic curves?

You always can avoid the term addition by using the generic term group
operation or so. I've also seen the dot notation to describe operations
in a group, but I've rarely seen the actual term multiplication.
Note however that here you also have the "scalar multiplication", so
if you use this term, addition would be the appropriate for the
group operation.

regards,
Nikos

</body></email><email><emailId>20111018183228</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-10-18 18:32:28-0400</timestampReceived><subject>Re: PATCH: Build proper Mac OS X dynamic libraries (dylibs)</subject><body>

Ryan Schmidt &lt;nettle-2011@ryandesign.com&gt; writes:

&gt;&gt; I've patched nettle in MacPorts to build proper Mac OS X dynamic
&gt;&gt; libraries, and wanted to share the patch with you.

Thanks. One question: You add $(LIBS) to LIBNETTLE_LIBS (and to
LIBHOGWEED_LIBS). Why, and what do you expect $(LIBS) to contain? It
usually contains -lgmp (if configure finds the gmp library), which
shouldn't be needed by the dynamic nettle library, and which is included
explicitly in LIBHOGWEED_LIBS.

&gt; Since your mailing list software appears to silently strip out attachments,

Might depend on the content-type of the attachment. I'm not really
friends with mailman configuration. Sorry for the inconvenience. It's
also perfectly ok to post patches inline (unless perhaps if they're
really huge).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20111018185520</emailId><senderName>Ryan Schmidt</senderName><senderEmail>nettle-2011@ryandesign.com</senderEmail><timestampReceived>2011-10-18 18:55:20-0400</timestampReceived><subject>Re: PATCH: Build proper Mac OS X dynamic libraries (dylibs)</subject><body>


On Oct 18, 2011, at 13:32, Niels Möller wrote:

&gt; Ryan Schmidt writes:
&gt; 
&gt; &gt; &gt; I've patched nettle in MacPorts to build proper Mac OS X dynamic
&gt; &gt; &gt; libraries, and wanted to share the patch with you.
&gt; 
&gt; Thanks. One question: You add $(LIBS) to LIBNETTLE_LIBS (and to
&gt; LIBHOGWEED_LIBS). Why, and what do you expect $(LIBS) to contain? It
&gt; usually contains -lgmp (if configure finds the gmp library), which
&gt; shouldn't be needed by the dynamic nettle library, and which is included
&gt; explicitly in LIBHOGWEED_LIBS.

I expected $(LIBS) to be empty, but I added it for consistency with the mingw32 and \
cygwin cases. But it's not in the solaris or default cases so I don't know if that \
was correct. I figured somebody might want to pass in additional libs in the LIBS \
variable some day. It is listed in "./configure --help" as an "influential \
environment variable" so I wanted its influence to be respected in the event that it \
is used.


&gt; &gt; Since your mailing list software appears to silently strip out attachments,
&gt; 
&gt; Might depend on the content-type of the attachment. I'm not really
&gt; friends with mailman configuration. Sorry for the inconvenience. It's
&gt; also perfectly ok to post patches inline (unless perhaps if they're
&gt; really huge).

I've seen mail programs and mailing list software strip leading whitespace which \
pretty much destroys patches pasted inline so I try to refrain from doing that.


</body></email><email><emailId>20110608114330</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-06-08 11:43:30-0400</timestampReceived><subject>Re: release?</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; The serpent code is replaced, any other issues that we are waiting for?

 * Fix the libdir defaults for linux x86_64 (I think the following
   should work in most cases for for both debian and fhs conventions:
   When building for $ABI (32 or 64), check if /usr/lib$ABI exists. If
   so, install there, otherwise in $prefix/lib. Possibly bail out with
   an error if neither /usr/lib32 nor /usr/lib64 exists).

 * Decide which flavor of LGPL licensing should be used. Options:
   LGPLv2+, LGPLv3+ or dual license LGPLv3+ and GPLv2+.

 * Update NEWS and documentation (regarding serpent and licensing).

Comments appreciated. Anything else?

In the mean time, I'm also hacking further on the serpent code. The
double-block trick in C gave a modest improvement. I think it should
work great with sse2 assembly to do four blocks at a time. Primarily for
x86_64, but maybe also for plain x86 (but then maybe one can's use sse2
unconditionally). But that doesn't have to be completed before release.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110608115548</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-06-08 11:55:48-0400</timestampReceived><subject>Re: release?</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; The serpent code is replaced, any other issues that we are waiting for?
&gt;
&gt;  * Fix the libdir defaults for linux x86_64 (I think the following
&gt;    should work in most cases for for both debian and fhs conventions:
&gt;    When building for $ABI (32 or 64), check if /usr/lib$ABI exists. If
&gt;    so, install there, otherwise in $prefix/lib. Possibly bail out with
&gt;    an error if neither /usr/lib32 nor /usr/lib64 exists).

I don't understand why this is a Nettle problem, since I don't recall
having to do anything like that for any of the libraries I maintain.
Could it be because I use automake and libtool?  If automake would solve
this issue, how about using it in Nettle?

&gt;  * Decide which flavor of LGPL licensing should be used. Options:
&gt;    LGPLv2+, LGPLv3+ or dual license LGPLv3+ and GPLv2+.

Is there a reason to change from the current LGPLv2+ before the next
release?

&gt;  * Update NEWS and documentation (regarding serpent and licensing).

I can help with that, if you want.  I did a diff between 2.1 and the
current code, and it is a fairly small set of changes.

&gt; Comments appreciated. Anything else?

Not that I can think of.

Using UTF-8 encoding for the files instead of ISO-8859-1 could be one.

&gt; In the mean time, I'm also hacking further on the serpent code. The
&gt; double-block trick in C gave a modest improvement. I think it should
&gt; work great with sse2 assembly to do four blocks at a time. Primarily for
&gt; x86_64, but maybe also for plain x86 (but then maybe one can's use sse2
&gt; unconditionally). But that doesn't have to be completed before release.

Right.

/Simon

</body></email><email><emailId>20110608154912</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-06-08 15:49:12-0400</timestampReceived><subject>Re: release?</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; I don't understand why this is a Nettle problem, since I don't recall
&gt; having to do anything like that for any of the libraries I maintain.
&gt; Could it be because I use automake and libtool?

Sure, it's not a very nettle-specific problem. Maybe current automake
and/or libtool does the right thing, but I doubt it.

I think I've tried to explain what the problem is a couple of times
before, but appearantly I failed at that. I'll try one more time:
Please try out the the default behaviour of

  ./configure &amp;&amp; make &amp;&amp; make install

with your libraries (or any random library using autoconf and default
GNU installation conventions). I would expect it to break badly on,
e.g., a x86_64 redhat-based system, with an installed gcc which defaults
to 64-bit objects (-m64 enabled by default). Then make install will
install in /usr/local/lib, destroying any previous 32-bit installation
of the same library. Correct install location on this system, which
follows the linux fhs, is /usr/local/lib64.

Similar problems would occur on the (a bit less likely) combinations of

 64-bit Solaris (sparc or x86_64), if you have installed a gcc to
 default to 64-bit.

 freebsd or debian gnu/linux on x86_64, if for some reason you have
 installed a compiler which defaults to 32-bit.
 
I want the default behavior to not break things, that's all. And it's no
big deal. The bug in the current configure logic should be easy to fix
(I've probably spent about as much time on this email as it will take to
fix the problem).

&gt; If automake would solve this issue, how about using it in Nettle?

No thanks. But I'd be happy to reuse any decent autoconf macros solving
the problem, from automake or elsewhere. If there are any.

&gt;&gt;  * Decide which flavor of LGPL licensing should be used. Options:
&gt;&gt;    LGPLv2+, LGPLv3+ or dual license LGPLv3+ and GPLv2+.
&gt;
&gt; Is there a reason to change from the current LGPLv2+ before the next
&gt; release?

Maybe not. Moving to LGPLv2+ is definitely the easiest and smallest
change.

&gt;&gt;  * Update NEWS and documentation (regarding serpent and licensing).
&gt;
&gt; I can help with that, if you want.  I did a diff between 2.1 and the
&gt; current code, and it is a fairly small set of changes.

That would be appreciated. I started on the NEWS entry a while back, I
just checked in my current version. I don't remember off the top of my
head what the last item, "Interface cleanup", refers to. (I usually
review the ChangeLog rather than actual diffs when updating the NEWS
file).

&gt; Using UTF-8 encoding for the files instead of ISO-8859-1 could be one.

That should be done some time, but I don't think I'll bother about it
now. E.g., the move away from cvs seems more important, and that will
also have to wait until after release.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110701221157</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-07-01 22:11:57-0400</timestampReceived><subject>Re: release?</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; See http://www.lysator.liu.se/~nisse/nettle/plan.html

I think everything on this list is done now. I also checked in the new
serpent sse2 code, and I've looked through my older changes for memxor and
cbs decrypt (the latter can avoid a memcpy by using memxor3 with
overlapping operands), and I think they're ok.

So I think the 2.2 release is near. But I'm travelling with somewhat
limited hacking time and spotty connectivity.

I'm checking http://www.lysator.liu.se/~nisse/xeno-lsh/latest.html
(which also builds nettle). Any additional last minute testing of the
current cvs tree is appreciated.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110702072232</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-07-02 07:22:32-0400</timestampReceived><subject>Re: release?</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; So I think the 2.2 release is near.

Great!

&gt; Any additional last minute testing of the
&gt; current cvs tree is appreciated.

It builds and passes self checks on debian squeeze x86 and a Solaris
2.10 box (without gmp though) I have access to.

Clang-analyze on the code did not raise any errors in the core library,
but some other minor issues in other code:

Bug Group
Bug Type
File
Line

API
Argument with 'nonnull' attribute passed null
tools/sexp-conv.c
274

Dead store
Dead assignment
examples/io.c
88

Dead store
Dead assignment
examples/io.c
90

Logic error
Dereference of null pointer
tools/nettle-hash.c
204

Logic error
Dereference of null pointer
tools/nettle-hash.c
205

Logic error
Dereference of null pointer
examples/io.c
123

/Simon

</body></email><email><emailId>20110412144821</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-04-12 14:48:21-0400</timestampReceived><subject>Re: different lib directories for gnutls and nettle</subject><body>

Brian Gough &lt;bjg@gnu.org&gt; writes:

&gt; I don't know what is the correct interpretation of the FHS, but by
&gt; default all other autoconf'ed and GNU packages always use
&gt; libdir=$prefix/lib (with the --libdir option allowing it to be
&gt; overridden if someone wants to use lib64 or whatever).

And the default is broken for multi-abi systems, since it means that a
plain ./configure &amp;&amp; make &amp;&amp; make install may well overwrite a working
library in /usr/local/lib with a library for a different ABI. With
autoconf defaults, this will happen, e.g., if you compile on Solaris (or
on some gnu/linux siystem which actually obeys the FHS), using a
compiler which by default generates 64-bit code).

Now, most packages are not aware of what ABI they are being compiled
for, but nettle is. It has to figure it out, in order to select the
right assembly files.

&gt; The distributions already have their own ways of using --libdir on
&gt; autoconf'ed packages so you don't need to worry about it yourself.

I don't worry so much for distributors. To use a sane libdir default is
intended to help people who compile nettle from source themselves,
rather than installing their distribution's nettle package.

I'd be happy to have autoconf solve this problem for me, but currently
it doesn't. Library installation is a bit complex, with various
workarounds. Another issue not currently solved by autoconf (nor by
nettle's build system) is w*ndows dlls, which should usually be
installed in bin rather than lib. I've heard that automake (or maybe it
was libtool) uses the workaround to install dlls in $libdir/../bin.
Which is really really ugly, but which appears to work most of the time.
Autoconf simply doesn't solve everything.

Finally: If the current hack doesn't work, I'd appreciate a complete bug
report. What system is it? Which library directories exists (incluing
symlinks)? Which directory is expected to hold libraries for which ABI?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110414082548</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-04-14 08:25:48-0400</timestampReceived><subject>Re: different lib directories for gnutls and nettle</subject><body>

Brian Gough &lt;bjg@gnu.org&gt; writes:

&gt; Nettle should work better with other GNU packages if it follows the
&gt; GNU standards, as the assumption of lib/ as a default is a common one
&gt; in other configure scripts.  

I don't change the default lightly, but I still think it's the right
thing to do when

1. The user has not provided --libdir explicitly.

2. One is building on a multi-abi system, which is a case where the
   autoconf default doesn't even try to do the right thing.

3. The autoconf default is known to be wrong.

&gt; For comparison the GMP library has ABI detection via configure but
&gt; keeps the library directory as lib/ by default.

I'm reasonably familiar with the gmp configure script. It's true that it
currently always uses lib/ as the default, regardless of ABI, but it's
ABI related hacks can also cause other nasty surprises. So it's a good
example to exhibit the complexity of the problem, but it's not currently
solving it.

As for linux on x86_64, it appears that debian (and derivatives, I
imagine) put 64-bit libraries in lib/, while the distributions with
roots in redhat (at least rhel 5 and fedora 14) and gentoo follow the
fhs conventions and put 32-bit libraries in lib/. So to do the right
thing, configure has to distinguish between these two cases. What a mess
(but just the type of mess configure.ac is intended to help sort out).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110317075612</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-17 07:56:12-0400</timestampReceived><subject>Re: nettle perl bindings</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; I'm building Perl bindings for libnettle.  I hope to claim the
&gt; Crypt::Nettle namespace.

Nice!

I'm not very familiar with perl, but I have had a quick look at the
documentation.

&gt; You can read the docs with:
&gt;
&gt;  pod2text lib/Crypt/Nettle.pm

A typo:

:     In the future, it should support asymmetric encrpytion and pseudo-random
                                                    ^^
:     number generation.

: COPYRIGHT AND LICENSE
:     Copyright (c) Daniel Kahn Gillmor Crypt::Nettle is free software, you
:     may redistribute it and/or modify it under the same terms as Perl
:     itself.

The GPL/LGPL license of the nettle library itself may apply to perl
programs using these bindings. I don't know if it's customary to
document this in a bit more detail?

&gt;  pod2text lib/Crypt/Nettle/Hash.pm

:  hmac_data($algo, $data)

How do you provide the key? 

I'm not sure it's the right design to mix hash functions and macs (and
how will you deal with macs that are not based on the hmac construction)?

&gt;  pod2text lib/Crypt/Nettle/Cipher.pm

Typo:

: ABSTRACT
:     Crypt::Nettle::Cipher provides an object interface to symmetric
:     encrpytion and decryption from the nettle C library. Each
        ^^

:  new($is_encrypt, $algo, $key, $mode, $iv)

You include arctwo algorithms twice in the algorithm list. Maybe you
should exclude serpent until the recently discovered interoperability
problems are sorted out?

How do you deal with algorithms with a large number of possible key
sizes? Maybe it would be better to view, e.g., aes and arcfour as just
two algorithm, and let the size of the given key imply the keysize?

The $is_encrypt flag to new seems a bit awkward. Maybe it would be
easier with

  my $ctx = new ($algo, $mode) /* Possibly with $mode defaulting to
                                  ecb?, and not allowed at all for stream ciphers. */

  $ctx-&gt;set_encrypt_key($key, $iv) /* $iv optional and required when applicable */
  $ctx-&gt;set_decrypt_key($key, $iv)

:  process($data)

I think the requirement that the length is a multiple of the block size
needs to be relaxed a bit. For CTR mode, one should allow a partial
block for the last call. And *maybe* for all calls (with an internal block
buffer to let CTR work like a stream cipher), even if that's not how
nettle's ctr mode support works.

Maybe you should think about how to add gcm support. Which is a bit more
complicated, with both per-key state and per-message state, and
additional inputs and outputs.

How do you query if a cipher is a block or a stream cipher?
block_size() returning 0?

Happy hacking,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110317084500</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-17 08:45:00-0400</timestampReceived><subject>Re: nettle perl bindings</subject><body>


Thanks for the quick review Niels!


On 03/17/2011 03:56 AM, Niels Möller wrote:
&gt; A typo:


The typos and stupidly-broken hmac_data() convenience function have been
fixed and pushed.  I also added a unit test for hmac_data() within
t/03-hmac.t which would have caught the mistake in the first place.


&gt; : COPYRIGHT AND LICENSE
&gt; :     Copyright (c) Daniel Kahn Gillmor Crypt::Nettle is free software, you
&gt; :     may redistribute it and/or modify it under the same terms as Perl
&gt; :     itself.
&gt; 
&gt; The GPL/LGPL license of the nettle library itself may apply to perl
&gt; programs using these bindings. I don't know if it's customary to
&gt; document this in a bit more detail?

I welcome suggestions for improved text.  I agree that the intersections
of the various licenses can be a bit confusing.

&gt; You include arctwo algorithms twice in the algorithm list. 

That's what i get for copying/pasting from the docs :P

Section 6.2.11 of http://www.lysator.liu.se/~nisse/nettle/nettle.html
actually lists them twice.

&gt; Maybe you
&gt; should exclude serpent until the recently discovered interoperability
&gt; problems are sorted out?

I'd prefer to expose the functions exposed by the underlying library if
possible.  If there are incompatibilities, we should be catching them in
the test suite (though my test suite for ciphers only covers aes and
cast and camellia at the moment).

&gt; How do you deal with algorithms with a large number of possible key
&gt; sizes? Maybe it would be better to view, e.g., aes and arcfour as just
&gt; two algorithm, and let the size of the given key imply the keysize?

hm, this is an interesting idea.  I'll have to think about how to
implement that, but i think it's doable.

&gt; The $is_encrypt flag to new seems a bit awkward. Maybe it would be
&gt; easier with
&gt; 
&gt;   my $ctx = new ($algo, $mode) /* Possibly with $mode defaulting to
&gt;                                   ecb?, and not allowed at all for stream ciphers. */
&gt; 
&gt;   $ctx-&gt;set_encrypt_key($key, $iv) /* $iv optional and required when applicable */
&gt;   $ctx-&gt;set_decrypt_key($key, $iv)
&gt; 
&gt; :  process($data)

My problem with this is that i then have to handle the case where the
user invokes process() without having remembered to set a key.  I agree
that $is_encrypt seems a little bit clumsy (and it's irrelevant for many
of the ciphers), but i think the fact that it's readable mitigates
things somewhat.

&gt; I think the requirement that the length is a multiple of the block size
&gt; needs to be relaxed a bit. For CTR mode, one should allow a partial
&gt; block for the last call. And *maybe* for all calls (with an internal block
&gt; buffer to let CTR work like a stream cipher), even if that's not how
&gt; nettle's ctr mode support works.

I'm actually not enforcing any of these constraints in the perl code --
they'll just crop up if the user passes the wrong data down to the
library underneath.

&gt; Maybe you should think about how to add gcm support. Which is a bit more
&gt; complicated, with both per-key state and per-message state, and
&gt; additional inputs and outputs.

interesting -- is GCM part of nettle itself, or do you think i should
implement it in the perl wrapper?  I didn't see any mention of GCM in
the online docs.

&gt; How do you query if a cipher is a block or a stream cipher?
&gt; block_size() returning 0?

yep, that's it at the moment.

Let me know what other feedback you have,

	--dkg



</body></email><email><emailId>20110317084519</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-03-17 08:45:19-0400</timestampReceived><subject>Re: nettle perl bindings</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; Hi Nettle Folks--
&gt;
&gt; I'm building Perl bindings for libnettle.  I hope to claim the
&gt; Crypt::Nettle namespace.
&gt;
&gt; The project is in its infancy, but i currently have coverage for all
&gt; hash functions and ciphers.
&gt;
&gt; My next steps are adding bindings for Yarrow and RSA.

Don't forget to add RSA blinding, otherwise it may be vulnerable in the
real world.  I wish Nettle supported this natively, RSA is not generally
safe without it.

/Simon

</body></email><email><emailId>20110317090152</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-17 09:01:52-0400</timestampReceived><subject>Re: nettle perl bindings</subject><body>


Hi Simon--

On 03/17/2011 04:45 AM, Simon Josefsson wrote:
&gt; Don't forget to add RSA blinding, otherwise it may be vulnerable in the=

&gt; real world.  I wish Nettle supported this natively, RSA is not generall=
y
&gt; safe without it.

Thanks for this suggestion -- i'm not sure that the perl bindings are
the right place to do this, though.  Do other Nettle language bindings
handle RSA blinding?  I'd rather have the perl bindings stay fairly
close to the underlying C library.

My understanding is that RSA blinding is a countermeasure against timing
attacks, and that it introduces a new dependency on some sort of RNG
(though perhaps a weak one?) to parts of the process that wouldn't
otherwise need it.  I'd certainly prefer to have that handled within the
lower-level library if possible, though i wouldn't mind creating and
handing in a yarrow context for each of these operations.

	--dkg



</body></email><email><emailId>20110317092953</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-17 09:29:53-0400</timestampReceived><subject>Re: nettle perl bindings</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; I welcome suggestions for improved text.  I agree that the intersections
&gt; of the various licenses can be a bit confusing.

I guess it will be easier when we have moved to LGPL. Then it's going to
take some effort to write a perl program which use these bindings and
violate the licensing terms. (With the GPL, I'm actually not sure myself
under which circumstances the perl program would have to be GPL:ed).

&gt; Section 6.2.11 of http://www.lysator.liu.se/~nisse/nettle/nettle.html
&gt; actually lists them twice.

Ooops. Fixed now.

&gt; My problem with this is that i then have to handle the case where the
&gt; user invokes process() without having remembered to set a key.

Can't you just raise some error ? You'd need to have some flag to
remember if it's been initialized, but you need that anyway for the
is_encrypt method, right?

&gt; I'm actually not enforcing any of these constraints in the perl code --
&gt; they'll just crop up if the user passes the wrong data down to the
&gt; library underneath.

That seems a bit dangerous. I thought the principle was that it
shouldn't be easy to write perl code which triggers some assertion
failure in some C routine.

&gt; interesting -- is GCM part of nettle itself, or do you think i should
&gt; implement it in the perl wrapper?  I didn't see any mention of GCM in
&gt; the online docs.

It's in the CVS version of Nettle, but not yet in any release. Maybe
most of the discussion was private rather than on this list?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110317093550</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-17 09:35:50-0400</timestampReceived><subject>Re: nettle perl bindings</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; My understanding is that RSA blinding is a countermeasure against timing
&gt; attacks, and that it introduces a new dependency on some sort of RNG
&gt; (though perhaps a weak one?) to parts of the process that wouldn't
&gt; otherwise need it.

I confess I don't remember the details of why blinding is desirable.
Does it improve hiding of the key, message, or both? 

Would it help to use a powm function which has data-independent timing?
There's a powm_sec in gmp which is supposed to do this (assuming
underlying arithmetic instructions have data independent timing), and
which is only slighly slower than the general version for sizes of
interest. But a few other functions are still missing to make it really
useful.

It would make sense to add an RSA interface which takes a randomness
source as input (for blinding), and a DSA interface which doesn't need a
randomness source (and instead uses something like the hash of the
message beeing signed as the "random" value needed, like it's done
putty).

But neither is currently a high priority for me.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110317095005</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-17 09:50:05-0400</timestampReceived><subject>Re: nettle perl bindings</subject><body>


On 03/17/2011 05:29 AM, Niels Möller wrote:
&gt; Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:
&gt;&gt; My problem with this is that i then have to handle the case where the
&gt;&gt; user invokes process() without having remembered to set a key.
&gt; 
&gt; Can't you just raise some error ? 

Sure, but that introduces a different kind of ugliness -- i'm not sure
that trading off this ugliness for the other one is worthwhile, though
i'm willing to be convinced.

&gt; You'd need to have some flag to
&gt; remember if it's been initialized, but you need that anyway for the
&gt; is_encrypt method, right?

i'm not sure i see the parallel.  is_encrypt() says whether the
Crypt::Nettle::Cipher object was initialized as an encrypting cipher or
a decrypting cipher.

&gt;&gt; I'm actually not enforcing any of these constraints in the perl code --
&gt;&gt; they'll just crop up if the user passes the wrong data down to the
&gt;&gt; library underneath.
&gt; 
&gt; That seems a bit dangerous. I thought the principle was that it
&gt; shouldn't be easy to write perl code which triggers some assertion
&gt; failure in some C routine.

Yes, that would be ideal.  I think the right way to go in the long term
(as noted in the BUGS section of Cipher.pm) is to add internal buffering
for process() calls so the user can pass arbitrarily-sized data to the
object.

The extra fiddly bits with this arrangement are:

 0) process_in_place() is still brittle: you won't be able to call it at
all if the internal buffer isn't on a clean block boundary, and you also
won't be able to call it with arbitrary-sized data.

 1) the data retrieved from process() isn't guaranteed to be the same
size as the data fed in.

 2) i'll need to introduce a finish() call that handles some sort of
padding and emits the final data.

It's a bunch more bookkeeping internally, but it does seem like it would
let the user treat the block ciphers as something approximating a stream
cipher without having to think much about it, which would be nice.

I think getting RSA working is higher priority for me at the moment, but
i'll certainly keep this suggestion on my plate.

&gt; It's in the CVS version of Nettle, but not yet in any release. Maybe
&gt; most of the discussion was private rather than on this list?

When a new version is released, i'll be happy to update the perl
bindings to enable access to the new features :)

Is the revision control for Nettle publicly visible?

	--dkg



</body></email><email><emailId>20110317095946</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2011-03-17 09:59:46-0400</timestampReceived><subject>Re: nettle perl bindings</subject><body>

On Thu, Mar 17, 2011 at 10:35 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:
&gt; Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:
&gt;
&gt;&gt; My understanding is that RSA blinding is a countermeasure against timing
&gt;&gt; attacks, and that it introduces a new dependency on some sort of RNG
&gt;&gt; (though perhaps a weak one?) to parts of the process that wouldn't
&gt;&gt; otherwise need it.
&gt; I confess I don't remember the details of why blinding is desirable.
&gt; Does it improve hiding of the key, message, or both?

Actually RSA is has pretty much limited utility without blinding since
retrieving  the RSA private key from a web server has been shown
practical since 2003 and attacks were known since 1996 (Kocher).
gnutls implements blinding over nettle's functions. You might add a
warning on the documentation of nettle's functions.

The papers discussion the attacks:
* Timing Attacks on Implementations of Diffie-Hellman, RSA, DSS, and
Other Systems by Kocher (1996)
* Remote timing attacks are practical  by  Boneh and Brumley
* Improving Brumley and Boneh Timing Attack on Unprotected SSL Implementati=
ons

regards,
Nikos

</body></email><email><emailId>20110317102728</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-17 10:27:28-0400</timestampReceived><subject>Re: nettle perl bindings</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt;&gt; You'd need to have some flag to
&gt;&gt; remember if it's been initialized, but you need that anyway for the
&gt;&gt; is_encrypt method, right?
&gt;
&gt; i'm not sure i see the parallel.  is_encrypt() says whether the
&gt; Crypt::Nettle::Cipher object was initialized as an encrypting cipher or
&gt; a decrypting cipher.

I was just thinking of the internal book-keeping, which I imagine would be the
same (but with three possible states rather than two).

&gt; Is the revision control for Nettle publicly visible?

Yes. A little bit awkward, in that you need to get the complete lsh
tree, but follow the instructions at http://www.lysator.liu.se/~nisse/nettle/
and it should work.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110317211913</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-03-17 21:19:13-0400</timestampReceived><subject>Re: nettle perl bindings</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; Hi Simon--
&gt;
&gt; On 03/17/2011 04:45 AM, Simon Josefsson wrote:
&gt;&gt; Don't forget to add RSA blinding, otherwise it may be vulnerable in the
&gt;&gt; real world.  I wish Nettle supported this natively, RSA is not generally
&gt;&gt; safe without it.
&gt;
&gt; Thanks for this suggestion -- i'm not sure that the perl bindings are
&gt; the right place to do this, though.  Do other Nettle language bindings
&gt; handle RSA blinding?  I'd rather have the perl bindings stay fairly
&gt; close to the underlying C library.

Yes -- I agree.

Btw, thanks for working on perl bindings, that sounds really useful.

nisse@lysator.liu.se (Niels Möller) writes:

&gt; It would make sense to add an RSA interface which takes a randomness
&gt; source as input (for blinding), and a DSA interface which doesn't need a
&gt; randomness source (and instead uses something like the hash of the
&gt; message beeing signed as the "random" value needed, like it's done
&gt; putty).

Yes, an interface like that seems like a simple and sufficient solution
to the problem.

/Simon

</body></email><email><emailId>20110317230543</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-17 23:05:43-0400</timestampReceived><subject>Re: nettle perl bindings</subject><body>


On 03/17/2011 05:50 AM, Daniel Kahn Gillmor wrote:
&gt; I think getting RSA working is higher priority for me at the moment, 

And now it's done -- I just wrapped up Crypt::Nettle::Yarrow and
Crypt::Nettle::RSA!  I'm about ready to tag this thing as Crypt::Nettle
version 0.1.  I'll try to do a CPAN upload shortly if i can figure that out.

If anyone can run the test suite and report back, i'd appreciate it.

  git clone git://lair.fifthhorseman.net/~dkg/libcrypt-nettle-perl
  cd libcrypt-nettle-perl
  perl Makefile.PL
  make
  make test

Niels, this is clearly a derivative work of Nettle.  I'm happy to put
whatever free license you think is appropriate on it.  Is GPL-2+ OK?

Regards,

	--dkg



</body></email><email><emailId>20110318055526</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-18 05:55:26-0400</timestampReceived><subject>Re: nettle perl bindings</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; Niels, this is clearly a derivative work of Nettle.  I'm happy to put
&gt; whatever free license you think is appropriate on it.  Is GPL-2+ OK?

If by "GPL-2+" you mean GPL version 2 or (user's option) any later version,
that's fine with me. 

As you know, changing the Nettle license to (some version of) the LPGL
is planned. When that happens, it would make some sense for the perl
bindings to follow, even if sticking to the GPL is still a perfectly
acceptable option.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110203085238</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-02-03 08:52:38-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Hi,
&gt;
&gt; Nikos Mavrogiannopoulos have been looking into support for Galois
&gt; Counter Mode (GCM), see http://www.cryptobarn.com/papers/gcm-spec.pdf

Hi!  NIST Has some other links for it:

http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html

&gt; My understanding of GCM is that the main point is a new MAC function
&gt; which allows efficient hardware implementation. As far as I see, there's
&gt; no clear advantage of using GCM instead of plain CTR mode combined with
&gt; the same MAC function (applied to the plaintext).

Shouldn't you MAC the ciphertext?  That's the proved secure approach.

&gt;   * Naming: Is "gmac" a good enough name? Or "ghash" (the name of the
&gt;     primitive which takes a key and two inputs, in the paper)? Or do we
&gt;     need something more verbose, like galois_mac or gmac128 or so?

The name GMAC is well established:

http://en.wikipedia.org/wiki/Galois/Counter_Mode

&gt;   * Specification: It's not entirely clear to me how the spec is to be
&gt;     interpreted when one of the input strings is empty. The most
&gt;     reasonable interpretation would be that there should be zero blocks
&gt;     to process (n or m equal to zero). This requires some bending of the
&gt;     notation in equation (2), for example, with m = 0, n = 1, we should
&gt;     have

If this is a real problem with latest specification, it might make sense
to bring this up somewhere.

&gt;   * Interface: I think the basic use case with empty second input should
&gt;     be just like other MAC:s,
&gt;
&gt;       struct gmac_ctx;
&gt;       
&gt;       /* Key size fixed to GMAC_KEY_SIZE == 16 */
&gt;       void
&gt;       gmac_set_key(struct gmac_ctx *ctx, const uint8_t *key);
&gt;       
&gt;       void
&gt;       gmac_update(struct gmac_ctx *ctx,
&gt; 		  unsigned length, const uint8_t *data);
&gt;       
&gt;       void
&gt;       gmac_digest(struct gmac_ctx *ctx,
&gt; 		  unsigned length, uint8_t *digest);
&gt;
&gt;     The context struct and the set_key function is essential to be able
&gt;     to do any optimizations using key-dependant tables.
&gt;     
&gt;     But then we need a function to mark the end of the first input and
&gt;     the start of the second. Name for that one?
&gt;
&gt;       void
&gt;       gmac_next(struct gmac_ctx *ctx);
&gt;
&gt;     This will pad the current input to a block boundary, and switch to
&gt;     using a different length counter.

How about gmac_authenticate?

Further, I'm wondering if some other authenticating MACs cannot process
data in parallell, which would argue for an interface like this:

       struct gmac_ctx;
       
       /* Key size fixed to GMAC_KEY_SIZE == 16 */
       void
       gmac_set_key(struct gmac_ctx *ctx, const uint8_t *key);
       
       void
       gmac_update(struct gmac_ctx *ctx,
 		  unsigned length, const uint8_t *data);
       
       void
       gmac_digest(struct gmac_ctx *ctx,
 		  unsigned length, uint8_t *digest);

       void
       gmac_authenticate(struct gmac_ctx *ctx,
 		         unsigned length, const uint8_t *data);

Or something.

/Simon

</body></email><email><emailId>20110203124047</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-03 12:40:47-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html

I was just wondering what an "authoritative" reference would be.

&gt; Shouldn't you MAC the ciphertext?  That's the proved secure approach.

I'm not familiar with those subtleties. Intuitively, it makes sense to me
to MAC the cleartext, since that's closest to the *meaning* of the
message. IIRC I picked up this (possibly outdated) advice from Applied
Cryptography years ago.

If you can trick the receiver to use the wrong key or iv for decryption,
then the receiver gets a garbled message, and if the MAC is applied to
cryptotext rather than cleartext, the message will still apear to be
authentic. So some care is needed when applying the MAC to ciphertext
only (and I'm talking about the general combination of encryption and
MAC, not the specific combination in GCM which I hope gets things
right).

E.g., in ssh the mac is done as

     mac = MAC(key, sequence_number || unencrypted_packet)

and replacing the unencrypted_packet by the corresponding ciphertext,
with no other changes, would likely cause some trouble.

&gt;&gt;   * Naming: Is "gmac" a good enough name? Or "ghash" (the name of the
&gt;&gt;     primitive which takes a key and two inputs, in the paper)? Or do we
&gt;&gt;     need something more verbose, like galois_mac or gmac128 or so?
&gt;
&gt; The name GMAC is well established:
&gt;
&gt; http://en.wikipedia.org/wiki/Galois/Counter_Mode

Ok. gmac it should be then. Or perhaps gmac128, in case anyone is using
64-bit gmac or planning for larger sizes?

&gt; If this is a real problem with latest specification, it might make sense
&gt; to bring this up somewhere.

I'd have to check the NIST version of the spec.

&gt; Further, I'm wondering if some other authenticating MACs cannot process
&gt; data in parallell, which would argue for an interface like this:
&gt;
&gt;        struct gmac_ctx;
&gt;        
&gt;        /* Key size fixed to GMAC_KEY_SIZE == 16 */
&gt;        void
&gt;        gmac_set_key(struct gmac_ctx *ctx, const uint8_t *key);
&gt;        
&gt;        void
&gt;        gmac_update(struct gmac_ctx *ctx,
&gt;  		  unsigned length, const uint8_t *data);
&gt;        
&gt;        void
&gt;        gmac_digest(struct gmac_ctx *ctx,
&gt;  		  unsigned length, uint8_t *digest);
&gt;
&gt;        void
&gt;        gmac_authenticate(struct gmac_ctx *ctx,
&gt;  		         unsigned length, const uint8_t *data);
&gt;
&gt; Or something.

I'm not sure I understand what you are referring to. At least for gmac,
I don't think one can mix the two inputs, one must complete one before
starting on the other. And I'd prefer that this restriction is clearly
expressed in the interface.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110203163525</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2011-02-03 16:35:25-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

On Thu, Feb 3, 2011 at 7:40 AM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wrote=
:
&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html
&gt;
&gt; I was just wondering what an "authoritative" reference would be.
NIST SP800-38D. See
http://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html and
http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf.

[SNIP]

Jeff

</body></email><email><emailId>20110203184911</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-03 18:49:11-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; The name GMAC is well established:
&gt;
&gt; http://en.wikipedia.org/wiki/Galois/Counter_Mode

And if I understand the spec correctly, T = GMAC(K, M) is computed
roughly as follows

  H = E_K(0...0)
  T = GHASH_H(M || ...) XOR E_K(IV)

I.e, the MAC key K is converted to the "hash subkey H" using the
encryption function of some block cipher (typically AES), and this block
cipher is also used together with the IV to get a value XOR:ed to the
output of GHASH.

I imagine the final XOR is essential for the MAC security (to hide the
otherwise very regular algebraic structure of GHASH).

When writing the previous mail, I hadn't realized that also the MAC part
depends on the block cipher, and should be parametrized by the block
cipher used. This makes it less natural to view GMAC as an independent
algorithm.

Also, the need for an IV (never repeated with the same key) necessarily
makes the interface more complex than, e.g., the HMAC interface.

Just like for DSA, where would be some use for a deterministic variant
where the IV (or random number in the case of DSA) is determined as some
function of the message (and possibly also of the key, although the
dependence on the key clearly should be one-way).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110203202057</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-03 20:20:57-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

Replying to myself:

&gt;     The context struct and the set_key function is essential to be able
&gt;     to do any optimizations using key-dependant tables.

It actually gets a bit complicated. I think we need several
context/state structs.

First, the key. The only way the key is directly used is for encrypting
things using the underlying block cipher. So it makes sense to represent
the key as

  const void *cipher_ctx;
  nettle_crypt_func *encrypt;

(except that for historical reasons, the first argument for
nettle_crypt_func is not const).

Next, we have tables derived from the key. These are needed for
otpimized implementations of ghash, and should be reused when several
messages are processed using the same key. E.g., this could be done as

  struct gcm128_ctx
  {
    const void *cipher_ctx;
    nettle_crypt_func *encrypt;

    uint8_t H[16]; /* Hash subkey */
    uint8_t M0[16][256]; /* Key-dependent table. */
  };

  void
  gcm128_ctx_init(struct gcm128_ctx *ctx,
  		  const void *cipher_ctx,
		  nettle_crypt_func *encrypt);

(It would be more consistent with the rest of nettle to not store those
pointers in gcm128_ctx, since its supposed to be ok to memcpy context
structs around. One could either pass them as arguments to all
functions, or inline an aes_ctx if aes is all we care about. I include
them here, to simplify function prototypes).

Functions to process complete gcm messages can take this ctx as
argument. The main ghash iteration would also take this context struct
as argument,

  /* Set state = (state XOR data) dot H */
  void
  ghash_update(const struct gcm128_ctx *ctx,
  	       uint8_t *state,
               const uint8_t *data);

For streaming operations, we also need a per-message state struct,
something like

  struct gcm128_msg
  {
    uint8_t Y[16];  /* counter */
    uint8_t J[16];  /* encryption of that */
    uint8_t J0[16]; /* first encrypted counter block to be used for constructing the digest. */
    uint8_t hash[16]; /* hashing state */

    unsigned index; /* Index when doing partial blocks */
    uint32_t auth_length;
    uint32_t msg_length;
  };

  void
  gcm128_msg_init(struct gcm128_msg *msg, const struct gcm128_ctx *ctx,
  		  uint32_t iv_length, const uint8_t *iv);

  /* Process auxillary auth data */
  void
  gcm128_msg_auth(struct gcm128_msg *msg, const struct gcm128_ctx *ctx,
  		  uint32_t length, const uint8_t *data);

  /* Only difference between encrypt and decrypt is if data is hashed
     before or after xoring with the key stream. */
  void
  gcm128_msg_encrypt(struct gcm128_msg *msg, const struct gcm128_ctx *ctx,
  		     uint32_t length, uint8_t *dst, const uint8_t *src);

  void
  gcm128_msg_decrypt(struct gcm128_msg *msg, const struct gcm128_ctx *ctx,
  		     uint32_t length, uint8_t *dst, const uint8_t *src);

  gcm128_msg_digest(struct gcm128_msg *msg, const struct gcm128_ctx *ctx,
  		    uint32_t length, uint8_t *dst);

Comments? It gets more complicated than almost anything currently in
Nettle.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110205230827</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-05 23:08:27-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Nikos Mavrogiannopoulos have been looking into support for Galois
&gt; Counter Mode (GCM), see http://www.cryptobarn.com/papers/gcm-spec.pdf

I've checked in a first version, based on Nikos' code. Tentative
interface as follows:

  #define GCM_BLOCK_SIZE 16
  #define GCM_IV_SIZE (GCM_BLOCK_SIZE - 4)
  
  #define GCM_TABLE_BITS 0
  
  struct gcm_ctx {
    /* Key-dependent state. */
    /* Hashing subkey */
    uint8_t h[GCM_BLOCK_SIZE];
  #if GCM_TABLE_BITS
    uint8_t h_table[1 &lt;&lt; GCM_TABLE_BITS][GCM_BLOCK_SIZE];
  #endif
    /* Per-message state, depending on the iv */
    /* Original counter block */
    uint8_t iv[GCM_BLOCK_SIZE];
    /* Updated for each block. */
    uint8_t ctr[GCM_BLOCK_SIZE];
    /* Hashing state */
    uint8_t x[GCM_BLOCK_SIZE];
    uint64_t auth_size;
    uint64_t data_size;
  };
  
  /* FIXME: Should use const for the cipher context. Then needs const for
     nettle_crypt_func, which also rules out using that abstraction for
     arcfour. */
  void
  gcm_set_key(struct gcm_ctx *ctx,
  	    void *cipher, nettle_crypt_func *f);
  
  void
  gcm_set_iv(struct gcm_ctx *ctx, unsigned length, const uint8_t *iv);
  
  void
  gcm_auth(struct gcm_ctx *ctx, unsigned length, const uint8_t *data);
  
  void
  gcm_encrypt(struct gcm_ctx *ctx, void *cipher, nettle_crypt_func *f,
  	    unsigned length, uint8_t *dst, const uint8_t *src);
  
  void
  gcm_decrypt(struct gcm_ctx *ctx, void *cipher, nettle_crypt_func *f,
  	    unsigned length, uint8_t *dst, const uint8_t *src);
  
  void
  gcm_digest(struct gcm_ctx *ctx, void *cipher, nettle_crypt_func *f,
  	   unsigned length, uint8_t *digest);

Comments on both structure and naming are welcome.

&gt; My understanding of GCM is that the main point is a new MAC function
&gt; which allows efficient hardware implementation.

The unoptimized GF(2^128) multiply function really is awfully slow. On
x86_64, gmac takes 830 cycles/byte! We can compare to the sha functions,
where sha1, sha256 and sha512 take respectively 8, 18 and 12
cycles/byte, so the current code is two orders of magnitude slower than
hmac-sha1.

It remains to see how much table space and/or assembly hacking is needed
to get reasonable performance.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110205233056</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-02-05 23:30:56-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

On 02/06/2011 12:08 AM, Niels Möller wrote:

&gt; The unoptimized GF(2^128) multiply function really is awfully slow. On
&gt; x86_64, gmac takes 830 cycles/byte! We can compare to the sha functions,
&gt; where sha1, sha256 and sha512 take respectively 8, 18 and 12
&gt; cycles/byte, so the current code is two orders of magnitude slower than
&gt; hmac-sha1.
&gt; It remains to see how much table space and/or assembly hacking is needed
&gt; to get reasonable performance.

There is a special instruction for that on new intel and AMD CPUs...
http://software.intel.com/en-us/articles/intel-carry-less-multiplication-instruction-and-its-usage-for-computing-the-gcm-mode/
 http://en.wikipedia.org/wiki/CLMUL_instruction_set

Unfortunately I don't have anything close to those cpus...

regards,
Nikos


</body></email><email><emailId>20110206212356</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-06 21:23:56-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; On 02/06/2011 12:08 AM, Niels Möller wrote:
&gt; 
&gt; &gt; It remains to see how much table space and/or assembly hacking is needed
&gt; &gt; to get reasonable performance.
&gt; 
&gt; There is a special instruction for that on new intel and AMD CPUs...
&gt; http://software.intel.com/en-us/articles/intel-carry-less-multiplication-instruction-and-its-usage-for-computing-the-gcm-mode/
&gt;  http://en.wikipedia.org/wiki/CLMUL_instruction_set

Interesting. I haven't played with any such special instructions (even
if it ought to make a bit of difference also for aes).

Anyway, I've been hacking a bit on the C-implementation over the day,
and the galois hashing (gmac) is now 18 times(!) faster. Summary of
changes:

  Original unoptimized code:
  
           Algorithm        mode Mbyte/s cycles/byte cycles/block
                gmac        auth    1.49      829.83     13277.27
  
  Optimized rshift, rewritten to use word-sized operations:
  
           Algorithm        mode Mbyte/s cycles/byte cycles/block
                gmac        auth    4.62      268.14      4290.23
  
  Optimized gf_mul, rewritten to use separate byte and bit loops:
  
           Algorithm        mode Mbyte/s cycles/byte cycles/block
                gmac        auth    5.46      227.18      3634.90
  
  Moved reduction into shift function:
  
           Algorithm        mode Mbyte/s cycles/byte cycles/block
                gmac        auth    6.79      182.69      2923.02
  
  Introduced 4-bit tables:
  
           Algorithm        mode Mbyte/s cycles/byte cycles/block
                gmac        auth   27.14       45.68       730.82

Remaining tricks:

* Try 8-bit tables (which increases storage need a lot, the modest 4-bit
  tables need only 256 additional bytes per key, for gf_mul, and a
  32-byte constant table for gf_shift. Extending to 8 bits makes both
  tables 16 times larger).

* See if it makes sense to write any assembler for the hashing function.

* Various smaller microoptimizations, like a public memxor-variant for
  when areas are known to be word-aligned. Or inline that xor:ing.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20110206215349</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-02-06 21:53:49-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

On 02/06/2011 12:08 AM, Niels Möller wrote:

&gt; void gcm_set_key(struct gcm_ctx *ctx, void *cipher, nettle_crypt_func
&gt; *f);

I don't like the name of the function name. It doesn't reveal anything
about its purpose. There is no key to set there. I'd suggest the
original gcm_init.

Moreover by not allowing the setting the blocksize as option any
extension on that code to work with 64-bit ciphers, will require
an abi break, or a new gcm64 mode... (what if 256-bit ciphers are added
in the future?)

&gt; void gcm_encrypt(struct gcm_ctx *ctx, void *cipher, nettle_crypt_func
&gt; *f, unsigned length, uint8_t *dst, const uint8_t *src); void 
&gt; gcm_digest(struct gcm_ctx *ctx, void *cipher, nettle_crypt_func *f, 
&gt; unsigned length, uint8_t *digest);

As I already mentioned I prefer having the cipher and f, to context
to avoid supplying on individual calls. There is no advantage (that I
can see) on having on each function parameters, and it just delegates
the storage of those two pointers, to caller's structures instead. It's
no big deal but it is inconvenience.

regards,
Nikos

</body></email><email><emailId>20110206215446</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-02-06 21:54:46-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

On 02/06/2011 10:23 PM, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt; &gt; On 02/06/2011 12:08 AM, Niels Möller wrote:
&gt; &gt; 
&gt; &gt; &gt; It remains to see how much table space and/or assembly hacking is needed
&gt; &gt; &gt; to get reasonable performance.
&gt; &gt; 
&gt; &gt; There is a special instruction for that on new intel and AMD CPUs...
&gt; &gt; http://software.intel.com/en-us/articles/intel-carry-less-multiplication-instruction-and-its-usage-for-computing-the-gcm-mode/
&gt; &gt;  http://en.wikipedia.org/wiki/CLMUL_instruction_set
&gt; 
&gt; Interesting. I haven't played with any such special instructions (even
&gt; if it ought to make a bit of difference also for aes).
&gt; 
&gt; Anyway, I've been hacking a bit on the C-implementation over the day,
&gt; and the galois hashing (gmac) is now 18 times(!) faster. Summary of
&gt; changes:

[...]
&gt; Introduced 4-bit tables:
&gt; 
&gt; Algorithm        mode Mbyte/s cycles/byte cycles/block
&gt; gmac        auth   27.14       45.68       730.82

That's pretty impressive!


</body></email><email><emailId>20110207092647</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-07 09:26:47-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; On 02/06/2011 12:08 AM, Niels Möller wrote:
&gt;
&gt;&gt; void gcm_set_key(struct gcm_ctx *ctx, void *cipher, nettle_crypt_func
&gt;&gt; *f);
&gt;
&gt; I don't like the name of the function name. It doesn't reveal anything
&gt; about its purpose. There is no key to set there. I'd suggest the
&gt; original gcm_init.

I see your point, and I think I'll change the name. If we introduce a
gcm_aes wrapper, that will have a _set_key method.

&gt; Moreover by not allowing the setting the blocksize as option any
&gt; extension on that code to work with 64-bit ciphers, will require
&gt; an abi break, or a new gcm64 mode... (what if 256-bit ciphers are added
&gt; in the future?)

I don't think it's useful to be that general here. Variants with
different block sizes will likely need a different context struct
anyway.

I could rename gcm to gcm128 in the interface if that's clearer.

&gt; As I already mentioned I prefer having the cipher and f, to context
&gt; to avoid supplying on individual calls. There is no advantage (that I
&gt; can see) on having on each function parameters, and it just delegates
&gt; the storage of those two pointers, to caller's structures instead. It's
&gt; no big deal but it is inconvenience.

I haven't yet made up my mind on this, but let me explain the reason for
having these pointers as function arguments.

The idea is that context structs in nettle should be non-magic with no
pointers, so that it can be copied or relocated in memory at will. Say
we implement gcm_aes as

  struct gcm_aes_ctx {
    struct gcm_ctx gcm;
    struct aes_ctx aes;
  };

  void
  gcm_aes_encrypt(struct gcm_aes_ctx *ctx,
  		  unsigned length, uint8_t *dst, const uint8_t *src)
  {
    gcm_encrypt(&amp;ctx-&gt;gcm, &amp;ctx-&gt;aes, (nettle_crypt_func) aes_encrypt,
    	        length, dst, src);
  }

Then the context struct is still non-magic. We can call gcm_aes_set_key,
and then create multiple copies of gcm_aes_ctx (using plain memcpy)
which are independent. If we add some pointers to struct gcm_ctx (which
*does* increase the storage size of gcm_aes_ctx, although that's maybe
not a big deal), plain copying will leave pointers pointing to other
objects, and we'll have to introduce a function gcm_aes_copy.

And if you think copying here is the wrong thing (since we waste memory
with multiple identical copies of an aes_ctx representing the key), then
I think one should also split gcm_ctx into a key-dependent part (which
should be shared rather than copied, in particular if we go for larger
key-dependent tables) and a message-dependent part (which also shouldn't
be copied, instead multiple instances should be independently
initialized).

We can compare with the hmac code; there's no context struct for the
general construction, but hmac_sha1_ctx and other's defined using the
HMAC_CTX macro put both key-the dependent parts (.inner, .outer) and the
message dependent part (.state) in a single struct.

When thinking about it, maybe the right thing is to redesign the general
gcm-code to use a separate struct for the hash subkey, passed as
argument to the functions needing it.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110207100417</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-02-07 10:04:17-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

On 02/06/2011 10:23 PM, Niels Möller wrote:

&gt; Interesting. I haven't played with any such special instructions (even
&gt; if it ought to make a bit of difference also for aes).
&gt; Anyway, I've been hacking a bit on the C-implementation over the day,
&gt; and the galois hashing (gmac) is now 18 times(!) faster. Summary of
&gt; changes:

I've also done a comparison benchmark of AES-GCM (the 4-bit table one)
versus HMAC-SHAx+AES-CBC... AES-GCM in software is disappointing...

Checking AES-128-GCM (16kb payload)... Encrypted 97.67 Mb in 5.00 secs:
19.53 Mb/sec

Checking AES-128-CBC with SHA256 (16kb payload)... Encrypted and hashed
246.14 Mb in 5.00 secs: 49.23 Mb/sec

Checking AES-128-CBC with SHA1 (16kb payload)... Encrypted and hashed
354.16 Mb in 5.00 secs: 70.83 Mb/sec


regards,
Nikos

</body></email><email><emailId>20110207103515</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-02-07 10:35:15-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

On 02/07/2011 10:26 AM, Niels Möller wrote:

&gt;&gt; Moreover by not allowing the setting the blocksize as option any 
&gt;&gt; extension on that code to work with 64-bit ciphers, will require
&gt;&gt; an abi break, or a new gcm64 mode... (what if 256-bit ciphers are 
&gt;&gt; added in the future?)
&gt; I don't think it's useful to be that general here. Variants with 
&gt; different block sizes will likely need a different context struct 
&gt; anyway.

Indeed...

&gt; I could rename gcm to gcm128 in the interface if that's clearer.

I like the plain gcm...

&gt;&gt; As I already mentioned I prefer having the cipher and f, to context
&gt;&gt; to avoid supplying on individual calls. There is no advantage (that
&gt;&gt; I can see) on having on each function parameters, and it just
&gt;&gt; delegates the storage of those two pointers, to caller's structures
&gt;&gt; instead. It's no big deal but it is inconvenience.
&gt; I haven't yet made up my mind on this, but let me explain the reason 
&gt; for having these pointers as function arguments. The idea is that 
&gt; context structs in nettle should be non-magic with no pointers, so 
&gt; that it can be copied or relocated in memory at will. Say we 
&gt; implement gcm_aes as
[...]
It makes sense, and although I've never used context structs like that
I could understand if someone did. I like to see context structures as
things that will take away my burden of maintaining several pointers and
data that relate to the operation.

Moreover different AEAD modes might have different requirements, but
it might be nice to have a consistent low level interface on them (if
possible of course).
If an AEAD mode doesn't require the encryption function at
the _digest operation, it would mean it would have different function
parameters. For me it would be best if it was consistent, even if
it is low-level... but it's your call...

[...]
&gt; When thinking about it, maybe the right thing is to redesign the 
&gt; general gcm-code to use a separate struct for the hash subkey,
&gt; passed as argument to the functions needing it.

I would like less of the internals of gcm exposed to the user rather
than more. As a user of nettle I wouldn't even want to know that there
is a hash subkey on gcm.

regards,
Nikos

</body></email><email><emailId>20110207112142</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-07 11:21:42-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I would like less of the internals of gcm exposed to the user rather
&gt; than more. As a user of nettle I wouldn't even want to know that there
&gt; is a hash subkey on gcm.

In any case we should probably have a gcm_aes interface (and whatever
other variants are relevant) that is easier to use than the lowest level
gcm interface.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110207122020</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-07 12:20:20-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I've also done a comparison benchmark of AES-GCM (the 4-bit table one)
&gt; versus HMAC-SHAx+AES-CBC... AES-GCM in software is disappointing...

Now I've tried 8-bit tables. Then I get into the same ballpark as md5
and the sha functions (benchmarking on intel x86_64):

         Algorithm        mode Mbyte/s cycles/byte cycles/block
               md5      update  174.20        7.12       455.48
              sha1      update  158.09        7.84       501.89
            sha256      update   68.36       18.14      1160.65
            sha512      update  104.99       11.81      1511.55
              gmac        auth   65.93       18.80       300.87

I think both sha512 and gmac benefit from 64-bit wide registers, while
md5, sha1 and sha256 does not. And I think there are still a couple of
microoptimizations left to do for gmac.

(I'm only benchmarking gmac; the encryption should be about the same as
AES in ECB or CTR mode, which is roughly 17 cycles/byte on the same
hardware).

Now the question is if it's a good tradeoff to expand the key to a 4 KB
table.

BTW, I hadn't noticed before that sha512 is faster per byte than sha256.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110207125521</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-02-07 12:55:21-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

On 02/07/2011 12:21 PM, Niels Möller wrote:
&gt;&gt; I would like less of the internals of gcm exposed to the user
&gt;&gt; rather than more. As a user of nettle I wouldn't even want to know
&gt;&gt; that there is a hash subkey on gcm.
&gt; 
&gt; In any case we should probably have a gcm_aes interface (and
&gt; whatever other variants are relevant) that is easier to use than the
&gt; lowest level gcm interface.

Could be... Another thing. I've implicitly used gcm_set_iv() as a way to
reset the GCM mode. Unfortunately it is not enough. The auth_size and
data_size have to be set to zero as well. Do you think that should
be done in the set_iv function as well?

I've currently done that in gnutls, and with that change gnutls talks
GCM with others servers.

regards,
Nikos

</body></email><email><emailId>20110207130115</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-02-07 13:01:15-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

On 02/07/2011 01:20 PM, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt;&gt; I've also done a comparison benchmark of AES-GCM (the 4-bit table one)
&gt;&gt; versus HMAC-SHAx+AES-CBC... AES-GCM in software is disappointing...
&gt; Now I've tried 8-bit tables. Then I get into the same ballpark as md5
&gt; and the sha functions (benchmarking on intel x86_64):
&gt;          Algorithm        mode Mbyte/s cycles/byte cycles/block
&gt;                md5      update  174.20        7.12       455.48
&gt;               sha1      update  158.09        7.84       501.89
&gt;             sha256      update   68.36       18.14      1160.65
&gt;             sha512      update  104.99       11.81      1511.55
&gt;               gmac        auth   65.93       18.80       300.87
&gt; I think both sha512 and gmac benefit from 64-bit wide registers, while
&gt; md5, sha1 and sha256 does not. And I think there are still a couple of
&gt; microoptimizations left to do for gmac.
&gt; (I'm only benchmarking gmac; the encryption should be about the same as
&gt; AES in ECB or CTR mode, which is roughly 17 cycles/byte on the same
&gt; hardware).
&gt; Now the question is if it's a good tradeoff to expand the key to a 4 KB
&gt; table.

4kb is not much on a desktop. There are constraint systems where this
might be a problem though. Libtomcrypt had a definition to cope with
this issue (e.g. LOW_FOOTPRINT or so).

On the other hand systems that might have an assembler-optimized
version, would need to share the same big state as well... I don't know.
That's why I like hiding that stuff :)

regards,
Nikos

</body></email><email><emailId>20110207160124</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-07 16:01:24-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Could be... Another thing. I've implicitly used gcm_set_iv() as a way to
&gt; reset the GCM mode. Unfortunately it is not enough.

It's intended to work, current gcm_set_iv in cvs does

  /* Reset the rest of the message-dependent state. */
  memset(ctx-&gt;x, 0, sizeof(ctx-&gt;x));
  ctx-&gt;auth_size = ctx-&gt;data_size = 0;

Is there something I'm missing?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110207214922</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-02-07 21:49:22-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

On 02/07/2011 05:01 PM, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt;&gt; Could be... Another thing. I've implicitly used gcm_set_iv() as a
&gt;&gt; way to reset the GCM mode. Unfortunately it is not enough.
&gt; It's intended to work, current gcm_set_iv in cvs does /* Reset the
&gt; rest of the message-dependent state. */ memset(ctx-&gt;x, 0,
&gt; sizeof(ctx-&gt;x)); ctx-&gt;auth_size = ctx-&gt;data_size = 0; Is there
&gt; something I'm missing?

No forget it. I was mistaken on the reason of the issue I had. The
current version is ok and inter-operable with.other TLS-GCM versions.

regards,
Nikos

</body></email><email><emailId>20110208100149</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-02-08 10:01:49-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

On 02/07/2011 10:26 AM, Niels Möller wrote:
&gt; I haven't yet made up my mind on this, but let me explain the reason
&gt; for having these pointers as function arguments. The idea is that
&gt; context structs in nettle should be non-magic with no pointers, so
&gt; that it can be copied or relocated in memory at will. Say we
&gt; implement gcm_aes as

What I was wondering is how would you think of implementing the
cpu-specific optimizations in assembly? What I had in mind is that the
_init function would detect the particular instructions
present and set some function pointers to the structure that
will assist the operations such as gf_mul to select the proper
variant... However as it seems, this is not how it can be done
if function pointers are not stored...

regards,
Nikos

</body></email><email><emailId>20110208111125</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-08 11:11:25-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; What I was wondering is how would you think of implementing the
&gt; cpu-specific optimizations in assembly?

If/when we do that, and if we want to be able to select which code to
use at runtime (rater than compile time), I think we should use global
pointers, one for each routine that can make use special instructions.
Either setup automagically at first use, or at library load time (using
the same mechanisms as C++ constructors).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110208120933</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-02-08 12:09:33-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

On 02/08/2011 12:11 PM, Niels Möller wrote:

&gt;&gt; What I was wondering is how would you think of implementing the 
&gt;&gt; cpu-specific optimizations in assembly?
&gt; If/when we do that, and if we want to be able to select which code
&gt; to use at runtime (rater than compile time),
The compile time will cause problems to distributions that ship a single
library across compatible architectures. Given that they will ship
the version without special instructions for compatibility, most systems
will not be affected by such optimizations.

&gt; I think we should use global pointers, one for each routine that can
&gt; make use special instructions. Either setup automagically at first
&gt; use, or at library load time (using the same mechanisms as C++
&gt; constructors).

I like the latter... An explicit global library initialization function
might also do.

regards,
Nikos

</body></email><email><emailId>20110208122643</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-08 12:26:43-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; On 02/08/2011 12:11 PM, Niels Möller wrote:
&gt;
&gt;&gt; I think we should use global pointers, one for each routine that can
&gt;&gt; make use special instructions. Either setup automagically at first
&gt;&gt; use, or at library load time (using the same mechanisms as C++
&gt;&gt; constructors).
&gt;
&gt; I like the latter... An explicit global library initialization function
&gt; might also do.

GMP does the former. Not as pretty, but seems to work well, and maybe a
bit easier to do portably.

Regards
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110208132140</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-02-08 13:21:40-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

On 02/08/2011 01:26 PM, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt;&gt; On 02/08/2011 12:11 PM, Niels Möller wrote:
&gt;&gt;
&gt;&gt;&gt; I think we should use global pointers, one for each routine that can
&gt;&gt;&gt; make use special instructions. Either setup automagically at first
&gt;&gt;&gt; use, or at library load time (using the same mechanisms as C++
&gt;&gt;&gt; constructors).
&gt;&gt; I like the latter... An explicit global library initialization function
&gt;&gt; might also do.
&gt; GMP does the former. Not as pretty, but seems to work well, and maybe a
&gt; bit easier to do portably.

How does it deal with multi-threaded access?

</body></email><email><emailId>20110208133613</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-08 13:36:13-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; How does it deal with multi-threaded access?

The worst thing that can happen is that several threads examine the
cpuid flags, and then write identical pointers to the same locations at
approximately the same time.

And as far as I have understod, that is no problem, because, reading and
writing a pointer value is an atomic operations on the concerned
architectures.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110209233025</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-02-09 23:30:25-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

I looked at recent GCM code and noticed this:

/* FIXME: Should use const for the cipher context. Then needs const for
   nettle_crypt_func, which also rules out using that abstraction for
   arcfour. */
void
gcm_set_key(struct gcm_key *key,
            void *cipher, nettle_crypt_func *f);

However GCM (like CCM) is only specified for block ciphers, and further,
only for 128-bit block ciphers.  Thus I wonder if avoiding use of const
just to let the abstraction support a stream cipher is wise?

/Simon

</body></email><email><emailId>20110210062745</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-10 06:27:45-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; /* FIXME: Should use const for the cipher context. Then needs const for
&gt;    nettle_crypt_func, which also rules out using that abstraction for
&gt;    arcfour. */
&gt; 
&gt; However GCM (like CCM) is only specified for block ciphers, and further,
&gt; only for 128-bit block ciphers.  Thus I wonder if avoiding use of const
&gt; just to let the abstraction support a stream cipher is wise?

This nettle_Crypt_func is not gcm-specific. It is used primarily for the
nettle_cipher class in nettle-meta.h:

  struct nettle_cipher
  {
    const char *name;
    
    unsigned context_size;
    
    /* Zero for stream ciphers */
    unsigned block_size;
  
    /* Suggested key size; other sizes are sometimes possible. */
    unsigned key_size;
  
    nettle_set_key_func *set_encrypt_key;
    nettle_set_key_func *set_decrypt_key;
  
    nettle_crypt_func *encrypt;
    nettle_crypt_func *decrypt;
  };

This currently is used to represent both block and stream ciphers,

  [...]
  extern const struct nettle_cipher nettle_aes256;
  
  extern const struct nettle_cipher nettle_arcfour128;
  
  extern const struct nettle_cipher nettle_camellia128;
  [...]

Currently, arcfour is the only supported stream cipher (they seem to be
out of fashion, are thare any other stream ciphers in use? A5 maybe?)

So the question is, should we decide that nettle_cipher is för block
ciphers only (where the encrypt and decrypt functions don't change any
state )? Fitting arcfour and block ciphers into the same
abstraction doesn't make much sense anyway, since they should be used
very differently. Then we can make the context argument const for
nettle_crypt_func, but we'd also have to delete

  extern const struct nettle_cipher nettle_arcfour128;

or replace it with something else, which is an incompatible interface
change. As long as it's the only supported stream cipher, it doesn't
make much sense to me create a new general stream cipher construction.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110107211145</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-01-07 21:11:45-0400</timestampReceived><subject>Re: elliptic curve in nettle?</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt;&gt; patents situation,
&gt;
&gt; Unfortunately, the patent system seems to be such that even if i were a
&gt; patent lawyer (i am not, fortunately), i could make no iron-clad
&gt; guarantees.  The best i can offer is a sort of suggestive inference:

I'm aware that there are no guarantees. I think a reasonable requirement
for implementing a new algorithm (ecc or otherwise) is that at least all
known patent holders license related patents on royalty-free (and
otherwise GPL compatible) terms.

Jeffrey Walton &lt;noloader@gmail.com&gt; writes:

&gt; I think Daniel is on the right track by choosing standardized domain
&gt; parameter support. When using standard parameters, you only have to
&gt; choose your private key and publish the public key. In this case, RFC
&gt; 5114 - Additional Diffie-Hellman Groups for Use with IETF Standards
&gt; (et al), would also be of interest.

Noted.

&gt; For those interested, Certicom, which holds many EC patents and is
&gt; owned by RIM, lost a few "slam dunk" cases recently. The events caused
&gt; paralysis in RIM's legal department to the point where the sales team
&gt; has not inked a license in over a year. When I inquired about
&gt; licensing over the summer, I was told to go to RSA Data Securities
&gt; even though RSA is probably violating Certicom. The fellow who advised
&gt; me worked for Certicom.

Intriguing story... as I've said, I haven't been following the area.

My conclusions for now are:

1. It makes sense to add support for certain elliptic curves or types of
   curves to nettle. I'm still not quite sure what the applications are,
   diffie-hellman key exchange have been mentioned, do the most
   important standards also use them for encryption and signatures
   (e.g., ElGamal style)? The implementation ought to include an
   ecc exponentiation primitive that can be used for various applications.

   (BTW, Nettle currently doesn't include any support for ElGamal using
   the usual modular group, is that something that would be useful? I
   try to give higher priority to algorithms that are in used in real
   protocols and applications, and lower priority to more academic
   constructions).
   
2. I will not have much time to spend on ecc in the near future. I'm
   happy to comment on, and integrate, well-written patches. As usual,
   test cases are a very important part of the implementation...

3. On the legal side, I'd like to have some clear evidence that the
   particular curves implemented are unlikely to lead to trouble with
   known patents, possibly with fsf legal staff or sflc in the loop. I'm
   not sure I know the area well enough to provide all needed input to
   legal staff, though, so I may need help with this part as well.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110107214339</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-01-07 21:43:39-0400</timestampReceived><subject>Re: elliptic curve in nettle?</subject><body>


On 01/07/2011 04:11 PM, Niels Möller wrote:
&gt; 1. It makes sense to add support for certain elliptic curves or types of
&gt;    curves to nettle. I'm still not quite sure what the applications are,
&gt;    diffie-hellman key exchange have been mentioned, do the most
&gt;    important standards also use them for encryption and signatures
&gt;    (e.g., ElGamal style)? The implementation ought to include an
&gt;    ecc exponentiation primitive that can be used for various applications.
&gt; 
&gt;    (BTW, Nettle currently doesn't include any support for ElGamal using
&gt;    the usual modular group, is that something that would be useful? I
&gt;    try to give higher priority to algorithms that are in used in real
&gt;    protocols and applications, and lower priority to more academic
&gt;    constructions).

OpenSSH 5.7 (due out later this month) will add the use of Elliptic
Curve DH and DSA.  Interoperability with OpenSSH by ssh clients using
nettle would be an excellent real-world scenario.

ElGamal is still widely used for asymmetric OpenPGP encryption.  Try
scanning the public keyservers for people with ElGamal subkeys (i wish i
had some easy way to present statistics from them -- sorry i don't!)

so yes, both EC and ElGamal have very clear real-world (non-academic)
usefulness.

&gt; 3. On the legal side, I'd like to have some clear evidence that the
&gt;    particular curves implemented are unlikely to lead to trouble with
&gt;    known patents, possibly with fsf legal staff or sflc in the loop. I'm
&gt;    not sure I know the area well enough to provide all needed input to
&gt;    legal staff, though, so I may need help with this part as well.

i'll point the SFLC lawyers at this thread.  hopefully they can get in
touch.

	--dkg



</body></email><email><emailId>20110210160440</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-10 16:04:40-0400</timestampReceived><subject>Re: LGPL blowfish</subject><body>

[ Resending, got list address wrong first time. ]

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;&gt;
&gt;&gt;&gt; I'll look at serpent next.
&gt;&gt;
&gt;&gt; Great!
&gt;
&gt; Turns out it was a bit more complicated, will debug some more...

BTW, how far did you get with serpent?

Regards,
/Niels
-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20111018192847</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-10-18 19:28:47-0400</timestampReceived><subject>Re: PATCH: Build proper Mac OS X dynamic libraries (dylibs)</subject><body>

Ryan Schmidt &lt;nettle-2011@ryandesign.com&gt; writes:

&gt; I expected $(LIBS) to be empty, but I added it for consistency with
&gt; the mingw32 and cygwin cases. But it's not in the solaris or default
&gt; cases so I don't know if that was correct.

I see. The default (mainly linux and bsd) and solaris cases have more
solid testing. I think it's the mingw32 and cygwin cases which get it
wrong (if -l flags when building a dll have any effect at all there; I
don't know).

I've now applied the patch, deleted those occurences of $(LIBS), and
committed the result.

Thanks,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20111026112720</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-10-26 11:27:20-0400</timestampReceived><subject>Re: _nettle_write_be32</subject><body>

On Wed, Oct 26, 2011 at 11:21 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:

&gt;&gt; Aren't they already exported in macros.h?
&gt; It seems you're right, in that macros.h is actually installed in
&gt; $includedir/nettle (unlike, e.g., nettle-internal.h). I must have
&gt; forgotten that when I put the MD_* definitions in that file... In any
&gt; case, they're undocumented, and I won't promise any backwards
&gt; compatibility in future versions.

Since those are macros it wouldn't matter for binary compatibility so
it would be ok.  If you remove them I'll duplicate it in gnutls.

regards,
Nikos

</body></email><email><emailId>20110901152907</emailId><senderName>Andres Mejia</senderName><senderEmail>mcitadel@gmail.com</senderEmail><timestampReceived>2011-09-01 15:29:07-0400</timestampReceived><subject>Re: RIPEMD-160 Implementation</subject><body>

On Aug 29, 2011 2:54 PM, "Niels M=F6ller" &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; nisse@lysator.liu.se (Niels M=F6ller) writes:
&gt;
&gt; &gt;  I'd like to address the things I listed in a previous mail before
&gt; &gt; release.
&gt;
&gt; Now I have went through not only ripemd160, but all the supported hash
&gt; functions. All are of the Merkle-Damg=E5rd type (except md2, which uses
&gt; more stupid padding). I've tried to reduce the code duplication (in the
&gt; source code) using some helper macros, and generally improve consistency
&gt; a bit.
&gt;
&gt; ripemd160.c got reduced to 44 non-comment lines, with all the complexity
&gt; in ripemd160-compress.c, as it should.
&gt;
&gt; Ah, and one other question: Do you want me to add your name to the
&gt; copyright headers of the various ripemd160.c (I don't know how much
&gt; editing you had to do when porting it from libgcrypt).

I don't think my name should be included in the copyright. I mainly strippe=
d
out libgcrypt specific code like gcry_burn_stack() and spelled out some
typedefs (u32 -&gt; uint32_t).

&gt; Documentation for the ripemd160 algorithm remains to do.
&gt;
&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels M=F6ller. PGP-encrypted email is preferred. Keyid C0B98E26.
&gt; Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110903055952</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-09-03 05:59:52-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-2.3</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; 	* Support for the ripemd-160 hash function.

Appears there was a missing #include "config.h" in the
ripemd160-compress.c file in the release, breaking ripemd160 on all
big-endian systems. Sorry for the poor testing...

I'll have to issue a new release soon.

/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110903134939</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-09-03 13:49:39-0400</timestampReceived><subject>ANNOUNCE: Nettle-2.4</subject><body>

Due to a bug discovered in Nettle-2.3, released yesterday, I'm a bit
embarrassed to announce a new release of GNU Nettle.

Nettle is a low-level cryptographic library. Homepage at
http://www.lysator.liu.se/~nisse/nettle/.

NEWS for the 2.4 release

	This is a bugfix release only. It turned out ripemd160 in the
	2.3 release was broken on all big-endian systems, due to a
	missing include of config.h. nettle-2.4 fixes this.

	The library is intended to be binary compatible with
	nettle-2.2 and nettle-2.3. The shared library names are
	libnettle.so.4.3 and libhogweed.so.2.1, with sonames still
	libnettle.so.4 and libhogweed.so.2.
	
NEWS for the 2.3 release

	* Support for the ripemd-160 hash function.

	* Generates and installs nettle.pc and hogweed.pc files, for
          use with pkg-config. Feedback appreciated. For projects
          using autoconf, the traditional non-pkg-config ways of
          detecting libraries, and setting LIBS and LDFLAGS, is still
          recommended.

	* Fixed a bug which made the testsuite fail in the GCM test on
	  certain platforms. Should not affect any documented features
	  of the library.

	* Reorganization of the code for the various Merkle-Damgård
	  hash functions. Some fields in the context structs for md4,
	  md5 and sha1 have been renamed, for consistency.
	  Applications should not peek inside these structs, and the
	  ABI is unchanged.
	  
	* In the manual, fixed mis-placed const in certain function
          prototypes.

	The library is intended to be binary compatible with
	nettle-2.2. The shared library names are libnettle.so.4.2 and
	libhogweed.so.2.1, with sonames still libnettle.so.4 and
	libhogweed.so.2.

The latest version is available at

  http://www.lysator.liu.se/~nisse/archive/nettle-2.4.tar.gz
  ftp://ftp.lysator.liu.se/pub/security/lsh/nettle-2.4.tar.gz
  ftp://ftp.gnu.org/gnu/nettle/nettle-2.4.tar.gz

Happy hacking,
/Niels möller

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20110914062726</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-09-14 06:27:26-0400</timestampReceived><subject>Re: memxor</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt;&gt; I think one should have the possibility to choose between fat and
&gt;&gt; non-fat builds, with the same ABI. There's going to be a small extra
&gt;&gt; call overhead in the fat case.
&gt;
&gt; Disabling the optional architectures would be possible but reducing the
&gt; call overhead in the "thin" case would require a lot of ifdefs. It
&gt; would keep the external api intact, but the internals would look ugly.

Even if fat is default on x86, the non-fat case is important for other
architectures. I think the complexity will be manageable, and most of it
will be in the configure script and assembly code, not in the C files.

&gt; This is not guaranteed. For example AES-NI and padlock require the
&gt; AES key to be aligned to 16-byte boundaries, something that the
&gt; current structures do not offer.

At least that's an ABI change which is harmless for other
implementations. A different question is how to portably tell the C
compiler that a certain structure must be 16-byte aligned.

&gt; In any case, I just noticed that for the x86-64 you don't really need
&gt; to detect SSE2, it is just there by default.

That's my understanding as well. You can test for it, but it's present
in all existing x86_64 cpus.

/nisse

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110926171124</emailId><senderName>Derek Downey</senderName><senderEmail>derek@orange-pants.com</senderEmail><timestampReceived>2011-09-26 17:11:24-0400</timestampReceived><subject>Re: make issues</subject><body>

Coel May &lt;coel@...&gt; writes:

&gt; Downloading the config.guess and replacing the original did the trick. 
&gt; 


I can confirm this worked for me as well


</body></email><email><emailId>20110815050123</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-08-15 05:01:23-0400</timestampReceived><subject>Re: ECC support</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I've also seen the dot notation to describe operations
&gt; in a group, but I've rarely seen the actual term multiplication.

I'm referring to the notation, which somehow determines how how one
thinks about the operation.

&gt; Note however that here you also have the "scalar multiplication", so
&gt; if you use this term, addition would be the appropriate for the
&gt; group operation.

Sure. If one chooses to use multiplicative notation for the group
operation, this operation would be called an exponentiation, not a
multiplication.

Regards,
/nisse

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110826020234</emailId><senderName>Andres Mejia</senderName><senderEmail>mcitadel@gmail.com</senderEmail><timestampReceived>2011-08-26 02:02:34-0400</timestampReceived><subject>Re: Few Questions About Nettle Project</subject><body>

On Thu, Aug 25, 2011 at 1:46 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Andres Mejia &lt;mcitadel@gmail.com&gt; writes:
&gt;
&gt;&gt; On Tue, Aug 23, 2011 at 12:49 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt;&gt;&gt; At some point the license may be upgraded to LGPLv3. Or dual license
&gt;&gt;&gt; LGPLv3 and GPLv2+. The latter, more complex, alternative would be
&gt;&gt;&gt; helpful for you, right?
&gt;&gt;
&gt;&gt; So long as XBMC can remain GPLv2, then it's ok.
&gt;&gt;
&gt;&gt; However, I'm sure there are some projects out there that could benefit
&gt;&gt; from an LGPLv2.1 crypto library. I looked around and so far have found
&gt;&gt; one, libaacs which is itself LGPLv2.1. libaacs is used indirectly by
&gt;&gt; XBMC, through libbluray.

I just remembered another example of an LGPLv2.1 library that can make
use of nettle. It's called GPAC. It currently uses openssl for crypto.
I did at one time try to implement crypto support using libgcrypt,
until I read about the problems that arise when using libgcrypt.

&gt; I have to look at this more closely before upgrading the license (which
&gt; I don't have any immediate plans of doing). I'm not sure, but I actually
&gt; don't see any obvious problem with linking LGPLv2 and LGPLv3 code
&gt; together.
&gt;
&gt; The problem when linking GPLv2 and LGPLv3 code together is not that
&gt; LGPLv3 doesn't allow it (after all, LGPL, any version, allows linking
&gt; even with with proprietary code), but that GPLv2 requires that the
&gt; *entire* work (except system libraries) can be distributed under GPLv2,
&gt; with no additional restrictions, and some of the new conditions in
&gt; (L)GPLv3 (probably the ones related to drm or patents) are additional
&gt; restrictions.
&gt;
&gt; And dual licensing as LGPLv3+ and GPLv2+ solves precisely that problem:
&gt; GPLv2 programs (including tivoized GPLv2 programs) can still use the
&gt; library under the GPLv2 conditions, while all other users of the
&gt; library, in particular, all proprietary applications, must abide by the
&gt; new conditions introduced in LGPLv3.

This matrix here might help.
http://www.gnu.org/licenses/gpl-faq.html#AllCompatibility

So any LGPL program can use another LGPL library regardless of their
versions. However, GPLv2 programs that want to use an LGPLv3 library
will need to upgrade to GPLv3. This would be a problem for XBMC. Dual
licensing would be better for us.

And just to be clear, dual licensing as LGPLv3+ *or* GPLv2+ would be ok.

&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
&gt; Internet email is subject to wholesale government surveillance.
&gt;



-- 
Regards,
Andres Mejia

</body></email><email><emailId>20110828062813</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-08-28 06:28:13-0400</timestampReceived><subject>Re: make in freebsd</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Why don't you use automake for that?

People seem to be asking that every other month...

Because I don't think it's important to be portable to all strange make
programs (anyone can install gnu make). And because automake causes all
sorts of nasty problems if you need to have unusual make rules to work
together with the automake generated rules. I did use automake in nettle
(and lsh) some years back. E.g., the "minor" change of behavior in
automake to stop using suffix rules and instead generate one rule for
each object file totally broke the way nettle sets up building of
assembly files.

I'm *not* going to switch back to automake, and I'm not going to use
libtool either.

/nisse

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110829185449</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-08-29 18:54:49-0400</timestampReceived><subject>Re: RIPEMD-160 Implementation</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt;  I'd like to address the things I listed in a previous mail before
&gt; release.

Now I have went through not only ripemd160, but all the supported hash
functions. All are of the Merkle-Damgård type (except md2, which uses
more stupid padding). I've tried to reduce the code duplication (in the
source code) using some helper macros, and generally improve consistency
a bit.

ripemd160.c got reduced to 44 non-comment lines, with all the complexity
in ripemd160-compress.c, as it should.

Ah, and one other question: Do you want me to add your name to the
copyright headers of the various ripemd160.c (I don't know how much
editing you had to do when porting it from libgcrypt).

Documentation for the ripemd160 algorithm remains to do.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110701155755</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-07-01 15:57:55-0400</timestampReceived><subject>Re: Fwd: Problem compiling gnutls 2.12.7 on Solaris 9</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;  nettle-stdint.h conflicts with gnulib's stdint.h on solaris.

The same or a very similar issue was reported a while ago. On Solaris, I
expect nettle-stdint.h to short circuit, and just include the system's
stdint.h (or maybe inttypes.h).

What I'd like to know is if nettle's configure script sets up
nettle-stdint.h to include the right system include file, as I expect it
to:

* If no, that's clearly a bug in nettle's configure.ac or in the
  AX_CREATE_STDINT_H macro. To track it down, I would need to look at
  the installed nettle-stdint.h and at the config.log when nettle was
  built.

* If yes, then gnulib's definitions don't really conflict with
  *nettle*'s definitions, but with Solaris' definitions.

I'm also not sure if Sun's compiler and gcc agree on what, e.g.
uint_fast32_t should be (they ought to agree though; these types should
be nailed down by the relevant ABI specification, and then also gnulib
should stick to that spec).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110707203606</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-07-07 20:36:06-0400</timestampReceived><subject>Re: release?</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Clang-analyze on the code did not raise any errors in the core library,
&gt; but some other minor issues in other code:

Thanks, I've reviewed the code in questions:

&gt; API
&gt; Argument with 'nonnull' attribute passed null
&gt; tools/sexp-conv.c
&gt; 274

This is a call to strtol.

	    int width = strtol(optarg, &amp;end , 0);

optarg shouldn't be NULL, but that's not really nettle's responsibility
(-w has a required argument in the getopt_long call). Warning seems to
be a false positive.

&gt; Dead store
&gt; Dead assignment
&gt; examples/io.c
&gt; 88

&gt; Dead store
&gt; Dead assignment
&gt; examples/io.c
&gt; 90

This is a minor real bug.

&gt; Logic error
&gt; Dereference of null pointer
&gt; tools/nettle-hash.c
&gt; 204

&gt; Logic error
&gt; Dereference of null pointer
&gt; tools/nettle-hash.c
&gt; 205

This is
    
    length = alg-&gt;digest_size;
  else if (length &gt; alg-&gt;digest_size)

and there's an if (!alg) die(...) earlier, where (at least for gcc) die
is declared as __attribute((__noreturn__)). Warning seems to be a false
positive.

But there's a related copy&amp;paste error, since werror has the same
declaration and it *does* return,

&gt; Logic error
&gt; Dereference of null pointer
&gt; examples/io.c
&gt; 123

  buffer[done] = '\0';

buffer is return value from a realloc call with a NULL check and return.
The logic using feof and ferror looks a bit suspicious, but as long as
feof is false just after fopen, things should be ok (and feof should not
be set until one attempts to read).

Thanks,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110711143454</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-07-11 14:34:54-0400</timestampReceived><subject>ANNOUNCE: Nettle-2.2</subject><body>

I'm happy to announce a new version of GNU Nettle, a low-level
cryptographic library. Unlike earlier releases, nettle is now licenced
under the LGPL, rather then the GPL. The nettle home page can be found
at http://www.lysator.liu.se/~nisse/nettle/

NEWS for the 2.2 release

	Licensing change:
     	
	* Relicensed as LGPL v2.1 or later (user's option).

	* Replaced blowfish and serpent implementation. New code is
          based on the LGPLed code in libgcrypt.

	New features:

	* Support for Galois/Counter Mode (GCM).

	* New interface for enumerating (most) available algorithms,
	  contributed by Daniel Kahn Gillmor.

	* New tool nettle-hash. Can generate hash digests using any
	  supported hash function, with output compatible with md5sum
	  and friends from GNU coreutils. Checking (like md5sum -c)
	  not yet implemented.

	Bug fixes:

	* The old serpent code had a byte order bug (introduced by
	  yours truly about ten years ago). New serpent implementation
	  does not interoperate with earlier versions of nettle.

	* Fixed ABI-dependent libdir default for Linux-based systems
	  which do not follow the Linux File Hierarchy Standard, e.g.,
	  Debian GNU/Linux.

	Optimizations:
	
	* x86_64 implemention of serpent.

	* x86_64 implemention of camellia.

	* Optimized memxor using word rather than byte operations.
          Both generic C and x86_64 assembler.

	* Eliminated a memcpy for in-place CBC decrypt.
	
	Miscellaneous:

	* In command line tools, no longer support -? for requesting
          help, since using it without shell quoting is a dangerous
          habit. Use long option --help instead.

	The shared library names are libnettle.so.4.1 and
	libhogweed.so.2.1, with sonames libnettle.so.4 and
	libhogweed.so.2.

Available at

  http://www.lysator.liu.se/~nisse/archive/nettle-2.2.tar.gz
  ftp://ftp.gnu.org/gnu/nettle/nettle-2.2.tar.gz

Happy hacking,
/Niels Möller

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20111025170636</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-10-25 17:06:36-0400</timestampReceived><subject>_nettle_write_be32</subject><body>

Hello,
 Would it be possible to export _nettle_write_be32? It is a useful
function and can be used on the accelerated versions of SHA in
architectures that support it (i.e. VIA cpus). I currently include a
copy of it, but would be nice if it was exported from the nettle API as
well.

btw. the MD_* macros were also proved to be very useful in that case.

regards,
Nikos

</body></email><email><emailId>20111026081621</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-10-26 08:16:21-0400</timestampReceived><subject>Re: _nettle_write_be32</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;  Would it be possible to export _nettle_write_be32?

This function is simple enough that it can be documented and made
public, if people find it useful.

&gt; It is a useful function and can be used on the accelerated versions of
&gt; SHA in architectures that support it (i.e. VIA cpus).

BTW, how does that acceleration work? Would it be possible/practical to
write a function matching the current _nettle_sha1_compress.

&gt; btw. the MD_* macros were also proved to be very useful in that case.

These macros are really intended for internal use only. I'd prefer to
not export any interfaces like that. If functionality like this should
be exported at all, I'd be more comfortable with a function interface
for doing these things.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110912112245</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2011-09-12 11:22:45-0400</timestampReceived><subject>memxor</subject><body>

Hello,
 I've run some tests with memxor on a x86-64 machine. My results are:
* C implementation (compiled with gcc 4.4):
        Xoring in chunks of 32768 bytes: done. 50.09 Gb in 5.00 secs:
10.02 Gb/sec
        Xoring (unaligned) in chunks of 32768 bytes: done. 39.90 Gb in
5.00 secs: 7.98 Gb/sec

* ASM implementation:
        Xoring in chunks of 32768 bytes: done. 38.32 Gb in 5.00 secs:
7.66 Gb/sec
        Xoring (unaligned) in chunks of 32768 bytes: done. 30.16 Gb in
5.00 secs: 6.03 Gb/sec

It seems that in x86-64 the ASM version is slower than the C one.
Moreover I noticed that the loop unrolling techniques used in the C
code have no visible performance benefit.

However, an SSE2 version of memxor (attached) increases performance by
30% or more in the same CPU.

* SSE2:
        Xoring in chunks of 32768 bytes: done. 69.94 Gb in 5.00 secs:
13.98 Gb/sec
        Xoring (unaligned) in chunks of 32768 bytes: done. 65.96 Gb in
5.00 secs: 13.19 Gb/sec

regards,
Nikos

["memxor2.c" (text/x-csrc)]

/* memxor.c
 *
 */

/* nettle, low-level cryptographics library
 *
 * Copyright (C) 1991, 1993, 1995 Free Software Foundation, Inc.
 * Copyright (C) 2010 Niels Möller
 *  
 * The nettle library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 * 
 * The nettle library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with the nettle library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
 * MA 02111-1307, USA.
 */

/* Implementation inspired by memcmp in glibc, contributed to the FSF
   by Torbjorn Granlund.
 */

#if HAVE_CONFIG_H
# include "config.h"
#endif

#include &lt;limits.h&gt;
#include &lt;emmintrin.h&gt;

#include "memxor.h"

typedef __m128i word_t;

#if SIZEOF_LONG &amp; (SIZEOF_LONG - 1)
#error Word size must be a power of two
#endif

#define ALIGN_OFFSET(p) ((uintptr_t) (p) % sizeof(word_t))

#define WORD_T_THRESH 16

/* XOR word-aligned areas. n is the number of words, not bytes. */
static void
memxor_common_alignment (word_t *dst, const word_t *src, size_t n)
{
  __m128i xmm1,xmm2;
  
  for (; n &gt; 0; dst += 1, src += 1, n--) 
    {
      xmm1 = _mm_load_si128(dst);
      xmm2 = _mm_load_si128(src);

      xmm1 = _mm_xor_si128(xmm1, xmm2);
      _mm_store_si128(dst, xmm1);
    }
}

/* XOR *un-aligned* src-area onto aligned dst area. n is number of
   words, not bytes. Assumes we can read complete words at the start
   and end of the src operand. */
static void
memxor_different_alignment (word_t *dst, const word_t *src, size_t n)
{
  __m128i xmm1,xmm2;
  
  for (; n &gt; 0; dst += 1, src += 1, n--) 
    {
      xmm1 = _mm_loadu_si128(dst);
      xmm2 = _mm_loadu_si128(src);

      xmm1 = _mm_xor_si128(xmm1, xmm2);
      _mm_storeu_si128(dst, xmm1);
    }
}

/* Performance, Intel SU1400 (x86_64): 0.25 cycles/byte aligned, 0.45
   cycles/byte unaligned. */

/* XOR LEN bytes starting at SRCADDR onto DESTADDR. Result undefined
   if the source overlaps with the destination. Return DESTADDR. */
uint8_t *
memxor(uint8_t *dst, const uint8_t *src, size_t n)
{
  uint8_t *orig_dst = dst;

  if (n &gt;= WORD_T_THRESH)
    {
      /* There are at least some bytes to compare.  No need to test
	 for N == 0 in this alignment loop.  */
      while (ALIGN_OFFSET (dst))
	{
	  *dst++ ^= *src++;
	  n--;
	}
      if (ALIGN_OFFSET (src))
	memxor_different_alignment ((word_t *) dst, (const word_t*)src, n / sizeof(word_t));
      else
	memxor_common_alignment ((word_t *) dst, (const word_t *) src, n / sizeof(word_t));

      dst += n &amp; -SIZEOF_LONG;
      src += n &amp; -SIZEOF_LONG;
      n = n &amp; (SIZEOF_LONG - 1);
    }
  for (; n &gt; 0; n--)
    *dst++ ^= *src++;

  return orig_dst;
}



["speed.c" (text/x-csrc)]

/*  cryptodev_test - simple benchmark tool for cryptodev
 *
 *    Copyright (C) 2010 by Phil Sutter &lt;phil.sutter@viprinet.com&gt;
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include &lt;fcntl.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

static double udifftimeval(struct timeval start, struct timeval end)
{
	return (double)(end.tv_usec - start.tv_usec) +
	       (double)(end.tv_sec - start.tv_sec) * 1000 * 1000;
}

static int must_finish = 0;

static void alarm_handler(int signo)
{
        must_finish = 1;
}

static void value2human(double bytes, double time, double* data, double* speed,char* \
metric) {
        if (bytes &gt; 1000 &amp;&amp; bytes &lt; 1000*1000) {
                *data = ((double)bytes)/1000;
                *speed = *data/time;
                strcpy(metric, "Kb");
                return;
        } else if (bytes &gt;= 1000*1000 &amp;&amp; bytes &lt; 1000*1000*1000) {
                *data = ((double)bytes)/(1000*1000);
                *speed = *data/time;
                strcpy(metric, "Mb");
                return;
        } else if (bytes &gt;= 1000*1000*1000) {
                *data = ((double)bytes)/(1000*1000*1000);
                *speed = *data/time;
                strcpy(metric, "Gb");
                return;
        } else {
                *data = (double)bytes;
                *speed = *data/time;
                strcpy(metric, "bytes");
                return;
        }
}


void xor(void)
{
	unsigned char *buffer1, *buffer2, *buffer3;
	static int val = 23;
	struct timeval start, end;
	double total = 0;
	double secs, ddata, dspeed;
	char metric[16];
	int i = 23;
	int chunksize = 32*1024;

	buffer1 = malloc(chunksize+1);
	buffer3 = malloc(chunksize+1);

	memset(buffer1, i, chunksize+1);
	memset(buffer3, i, chunksize+1);

	buffer2 = malloc(chunksize);
	memset(buffer2, 0x78, chunksize);

	/* sanity check first */
	memxor(buffer3, buffer2, chunksize);
	for (i=0;i&lt;chunksize;i++)
	  if (buffer3[i] != (buffer1[i] ^ buffer2[i])) {
	    fprintf(stderr, "memxor is broken! %x found, expected %x ^ %x = %x\n", \
buffer3[i], buffer1[i], buffer2[i], buffer1[i]^buffer2[i]);  abort();
	  }

	memcpy(buffer3, buffer1, chunksize+1);
	memxor(buffer3+1, buffer2, chunksize);
	for (i=0;i&lt;chunksize;i++)
	  if (buffer3[i+1] != (buffer1[i+1] ^ buffer2[i])) {
	    fprintf(stderr, "memxor (unaligned) is broken! in pos %d, found %x, expected %x \
^ %x = %x\n", i, buffer3[i+1], buffer1[i+1], buffer2[i], buffer1[i+1]^buffer2[i]);  \
abort();  }

	printf("\tXoring in chunks of %d bytes: ", chunksize);
	fflush(stdout);
	
	must_finish = 0;
	alarm(5);

	gettimeofday(&amp;start, NULL);
	do {
		size_t output_size;

		memxor(buffer1, buffer2, chunksize);

		total+=chunksize;
	} while(must_finish==0);
	gettimeofday(&amp;end, NULL);

	secs = udifftimeval(start, end)/ 1000000.0;
	
	value2human(total, secs, &amp;ddata, &amp;dspeed, metric);
	printf ("done. %.2f %s in %.2f secs: ", ddata, metric, secs);
	printf ("%.2f %s/sec\n", dspeed, metric);



	printf("\tXoring (unaligned) in chunks of %d bytes: ", chunksize);
	fflush(stdout);
	
	must_finish = 0;
	total = 0;
	alarm(5);

	gettimeofday(&amp;start, NULL);
	do {
		size_t output_size;

		memxor(buffer1+1, buffer2, chunksize);

		total+=chunksize;
	} while(must_finish==0);
	gettimeofday(&amp;end, NULL);

	secs = udifftimeval(start, end)/ 1000000.0;
	
	value2human(total, secs, &amp;ddata, &amp;dspeed, metric);
	printf ("done. %.2f %s in %.2f secs: ", ddata, metric, secs);
	printf ("%.2f %s/sec\n", dspeed, metric);

	return;
}

int main(void)
{
	int fd, i;

	signal(SIGALRM, alarm_handler);
	
	xor();

	return 0;
}



</body></email><email><emailId>20110917011817</emailId><senderName>Coel May</senderName><senderEmail>coel@coelmay.com</senderEmail><timestampReceived>2011-09-17 01:18:17-0400</timestampReceived><subject>make issues</subject><body>

Hi,

In the process of attempting to build gnutls under os x I get an error =
saying libnettle is not found. Ok.

So I download nettle-2.4.tar.gz, extract and run ./configure. No =
problems.

Then I run make. the result is below.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
$ make
make all-here
/usr/bin/m4 ./asm.m4 machine.m4 config.m4 \
		aes-decrypt-internal.asm &gt;aes-decrypt-internal.s
gcc -I.  -DHAVE_CONFIG_H -g -O2 -ggdb3 -Wno-pointer-sign -Wall -W   =
-Wmissing-prototypes -Wmissing-declarations -Wstrict-prototypes   =
-Wpointer-arith -Wbad-function-cast -Wnested-externs -fPIC -MT =
aes-decrypt-internal.o -MD -MP -MF aes-decrypt-internal.o.d -fPIC -c =
aes-decrypt-internal.s
aes-decrypt-internal.asm:109:suffix or operands invalid for `push'
aes-decrypt-internal.asm:110:suffix or operands invalid for `push'
aes-decrypt-internal.asm:111:suffix or operands invalid for `push'
aes-decrypt-internal.asm:112:suffix or operands invalid for `push'
aes-decrypt-internal.asm:328:suffix or operands invalid for `pop'
aes-decrypt-internal.asm:329:suffix or operands invalid for `pop'
aes-decrypt-internal.asm:330:suffix or operands invalid for `pop'
aes-decrypt-internal.asm:331:suffix or operands invalid for `pop'
make[1]: *** [aes-decrypt-internal.o] Error 1
make: *** [all] Error 2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Am I missing something? I must be, right?

Any help appreciated.

coel may
e: coel@coelmay.com
w: http://coelmay.com
t: twitter.com/coelmay


</body></email><email><emailId>20110917045118</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-09-17 04:51:18-0400</timestampReceived><subject>Re: make issues</subject><body>

Coel May &lt;coel@coelmay.com&gt; writes:

&gt; So I download nettle-2.4.tar.gz, extract and run ./configure. No problems.
&gt; Then I run make. the result is below.
&gt; [...]
&gt; aes-decrypt-internal.asm:331:suffix or operands invalid for `pop'
&gt; make[1]: *** [aes-decrypt-internal.o] Error 1
&gt; make: *** [all] Error 2

You don't say which architecture you are running on, but I suspect you
have an x86_x64, and then nettle build tries to use x86 assemler files
(instead of the x86_64 files). The problem is that the config.guess
script shipped with nettle-2.4 is too old and doesn't recognize os x
on x86_64. Check what ./config.guess outputs if you just run it from the
shell.

You could try replacing config.guess with the latest version from
http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD,
and then run configure again.

I've had mixed reports, that worked fine for one user but failed for
another. As a workaround, you could also try to configure with
--disable-assembler.

In any either, if you're using the same build tree, you must first run
make distclean.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110917053441</emailId><senderName>Coel May</senderName><senderEmail>coel@coelmay.com</senderEmail><timestampReceived>2011-09-17 05:34:41-0400</timestampReceived><subject>Re: make issues</subject><body>

On 17/09/2011, at 2:51 PM, Niels Möller wrote:

&gt; You could try replacing config.guess with the latest version from
&gt; http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD,
&gt; and then run configure again.

Downloading the config.guess and replacing the original did the trick. And yes, x86_64 architecture.

Thanks for the help and quick response Niels

Regards
coel may
e: coel@coelmay.com
w: http://coelmay.com
t: twitter.com/coelmay


</body></email><email><emailId>20111102035507</emailId><senderName>Kenton Jacobsen</senderName><senderEmail>kenton.jacobsen@gmail.com</senderEmail><timestampReceived>2011-11-02 03:55:07-0400</timestampReceived><subject>Re: make issues</subject><body>

Another success!


</body></email><email><emailId>20110823025116</emailId><senderName>Andres Mejia</senderName><senderEmail>mcitadel@gmail.com</senderEmail><timestampReceived>2011-08-23 02:51:16-0400</timestampReceived><subject>Few Questions About Nettle Project</subject><body>

Hi,

Keep up the great work. I was looking for an LGPL-2.1 crypto library
that can be used as an alternative to libgcrypt. Reason being can best
be explained at [1].

So here are some questions I have. GNU Nettle is going to stick with
LGPL-2.1+ correct? I ask this since I'm currently working on
implementing full RAR archive support with libarchive, to ultimately
be used in XBMC Media Center. XBMC is GPL-2+ and we have no desire to
go to GPL-3.

Another question, the only thing I see missing in nettle that
libarchive can make use of is RIPEMD-160. In case I want to submit
patches, I should submit them here correct? Also, I suppose if I
wanted to submit patches, there's no issue in porting code from gcrypt
over to nettle correct? I think it would be easier (and faster) to
reuse the implementation in gcrypt than to implement the algorithm
from scratch.

-- 
Regards,
Andres Mejia

1. http://lists.debian.org/debian-devel/2011/04/msg01170.html

</body></email><email><emailId>20110827213535</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-08-27 21:35:35-0400</timestampReceived><subject>make in freebsd</subject><body>

Hello,
  I tried to do a "./configure &amp;&amp; make" in freebsd an got an error 
during make. If I use GNU make instead it works. I attach the error 
output from the make command and the generated Makefile.

regards,
Nikos


["out.txt" (text/plain)]

"Makefile", line 436: Could not find aes-decrypt-internal.o.d aes-decrypt=
=2Eo.d aes-encrypt-internal.o.d aes-encrypt.o.d aes-encrypt-table.o.d aes=
-set-encrypt-key.o.d aes-set-decrypt-key.o.d aes-meta.o.d arcfour.o.d arc=
four-crypt.o.d arcfour-meta.o.d arctwo.o.d arctwo-meta.o.d base16-encode.=
o.d base16-decode.o.d base16-meta.o.d base64-encode.o.d base64-decode.o.d=
 base64-meta.o.d camellia-crypt.o.d camellia-crypt-internal.o.d camellia-=
set-encrypt-key.o.d camellia-set-decrypt-key.o.d camellia-table.o.d camel=
lia-meta.o.d cast128.o.d cast128-meta.o.d blowfish.o.d cbc.o.d ctr.o.d gc=
m.o.d gcm-aes.o.d des.o.d des3.o.d des-compat.o.d hmac.o.d hmac-md5.o.d h=
mac-sha1.o.d hmac-sha224.o.d hmac-sha256.o.d hmac-sha384.o.d hmac-sha512.=
o.d knuth-lfib.o.d md2.o.d md2-meta.o.d md4.o.d md4-meta.o.d md5.o.d md5-=
compress.o.d md5-compat.o.d md5-meta.o.d sha1.o.d sha1-compress.o.d sha1-=
meta.o.d sha256.o.d sha256-compress.o.d sha224-meta.o.d sha256-meta.o.d s=
ha512.o.d sha512-compress.o.d sha384-meta.o.d sha512-meta.o.d serpent-set=
-key.o.d serpent-encrypt.o.d serpent-decrypt.o.d serpent-meta.o.d twofish=
=2Eo.d twofish-meta.o.d yarrow256.o.d yarrow_key_event.o.d buffer.o.d buf=
fer-init.o.d realloc.o.d nettle-meta-hashes.o.d nettle-meta-ciphers.o.d n=
ettle-meta-armors.o.d nettle-internal.o.d write-be32.o.d sexp.o.d sexp-fo=
rmat.o.d sexp-transport.o.d sexp-transport-format.o.d bignum.o.d bignum-n=
ext-prime.o.d bignum-random.o.d bignum-random-prime.o.d sexp2bignum.o.d p=
kcs1.o.d pkcs1-rsa-md5.o.d pkcs1-rsa-sha1.o.d pkcs1-rsa-sha256.o.d pkcs1-=
rsa-sha512.o.d rsa.o.d rsa-sign.o.d rsa-verify.o.d rsa-md5-sign.o.d rsa-m=
d5-verify.o.d rsa-sha1-sign.o.d rsa-sha1-verify.o.d rsa-sha256-sign.o.d r=
sa-sha256-verify.o.d rsa-sha512-sign.o.d rsa-sha512-verify.o.d rsa-encryp=
t.o.d rsa-decrypt.o.d rsa-keygen.o.d rsa-compat.o.d rsa2sexp.o.d sexp2rsa=
=2Eo.d dsa.o.d dsa-sign.o.d dsa-verify.o.d dsa-keygen.o.d dsa-sha1-sign.o=
=2Ed dsa-sha1-verify.o.d dsa-sha256-sign.o.d dsa-sha256-verify.o.d dsa2se=
xp.o.d sexp2dsa.o.d pgp-encode.o.d rsa2openpgp.o.d der-iterator.o.d der2r=
sa.o.d der2dsa.o.d aesdata.o.d desdata.o.d shadata.o.d gcmdata.o.d aes-de=
crypt-internal.po.d aes-decrypt.po.d aes-encrypt-internal.po.d aes-encryp=
t.po.d aes-encrypt-table.po.d aes-set-encrypt-key.po.d aes-set-decrypt-ke=
y.po.d aes-meta.po.d arcfour.po.d arcfour-crypt.po.d arcfour-meta.po.d ar=
ctwo.po.d arctwo-meta.po.d base16-encode.po.d base16-decode.po.d base16-m=
eta.po.d base64-encode.po.d base64-decode.po.d base64-meta.po.d camellia-=
crypt.po.d camellia-crypt-internal.po.d camellia-set-encrypt-key.po.d cam=
ellia-set-decrypt-key.po.d camellia-table.po.d camellia-meta.po.d cast128=
=2Epo.d cast128-meta.po.d blowfish.po.d cbc.po.d ctr.po.d gcm.po.d gcm-ae=
s.po.d des.po.d des3.po.d des-compat.po.d hmac.po.d hmac-md5.po.d hmac-sh=
a1.po.d hmac-sha224.po.d hmac-sha256.po.d hmac-sha384.po.d hmac-sha512.po=
=2Ed knuth-lfib.po.d md2.po.d md2-meta.po.d md4.po.d md4-meta.po.d md5.po=
=2Ed md5-compress.po.d md5-compat.po.d md5-meta.po.d sha1.po.d sha1-compr=
ess.po.d sha1-meta.po.d sha256.po.d sha256-compress.po.d sha224-meta.po.d=
 sha256-meta.po.d sha512.po.d sha512-compress.po.d sha384-meta.po.d sha51=
2-meta.po.d serpent-set-key.po.d serpent-encrypt.po.d serpent-decrypt.po.=
d serpent-meta.po.d twofish.po.d twofish-meta.po.d yarrow256.po.d yarrow_=
key_event.po.d buffer.po.d buffer-init.po.d realloc.po.d nettle-meta-hash=
es.po.d nettle-meta-ciphers.po.d nettle-meta-armors.po.d nettle-internal.=
po.d write-be32.po.d sexp.po.d sexp-format.po.d sexp-transport.po.d sexp-=
transport-format.po.d bignum.po.d bignum-next-prime.po.d bignum-random.po=
=2Ed bignum-random-prime.po.d sexp2bignum.po.d pkcs1.po.d pkcs1-rsa-md5.p=
o.d pkcs1-rsa-sha1.po.d pkcs1-rsa-sha256.po.d pkcs1-rsa-sha512.po.d rsa.p=
o.d rsa-sign.po.d rsa-verify.po.d rsa-md5-sign.po.d rsa-md5-verify.po.d r=
sa-sha1-sign.po.d rsa-sha1-verify.po.d rsa-sha256-sign.po.d rsa-sha256-ve=
rify.po.d rsa-sha512-sign.po.d rsa-sha512-verify.po.d rsa-encrypt.po.d rs=
a-decrypt.po.d rsa-keygen.po.d rsa-compat.po.d rsa2sexp.po.d sexp2rsa.po.=
d dsa.po.d dsa-sign.po.d dsa-verify.po.d dsa-keygen.po.d dsa-sha1-sign.po=
=2Ed dsa-sha1-verify.po.d dsa-sha256-sign.po.d dsa-sha256-verify.po.d dsa=
2sexp.po.d sexp2dsa.po.d pgp-encode.po.d rsa2openpgp.po.d der-iterator.po=
=2Ed der2rsa.po.d der2dsa.po.d aesdata.po.d desdata.po.d shadata.po.d gcm=
data.po.d
make: fatal errors encountered -- cannot continue


</body></email><email><emailId>20110827220654</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-08-27 22:06:54-0400</timestampReceived><subject>Re: make in freebsd</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;  I tried to do a "./configure &amp;&amp; make" in freebsd an got an error
&gt; during make. If I use GNU make instead it works. I attach the error
&gt; output from the make command and the generated Makefile.

I think the problem is that bsd make doesn't allow multiple files to b
listed for a single include command. If you want to use bsd make, you
have to configure with --disable-dependency-tracking. ./configure --help
says

  --disable-dependency-tracking
                            Disable dependency tracking. Dependency tracking
			    doesn't work with BSD make

Any suggestions other places to document that problem?

The Makefile.in does

DEP_FILES = $(SOURCES:.c=.$(OBJEXT).d) $(SOURCES:.c=.p$(OBJEXT).d)
@DEP_INCLUDE@ $(DEP_FILES)

and "include" or "#" is substituted for @DEP_INCLUDE@, depending on
whether or not dependency tracking is enabled.

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110826214321</emailId><senderName>Andres Mejia</senderName><senderEmail>mcitadel@gmail.com</senderEmail><timestampReceived>2011-08-26 21:43:21-0400</timestampReceived><subject>RIPEMD-160 Implementation</subject><body>

Here's a patch that will implement RIPEMD-160 for nettle. It's code
ported from libgcrypt. A reference to RIPEMD-160 is in the source.
Also, this patch includes testcases and I followed what looked to me
as nettle coding conventions.

There's no documentation update in this patch. I didn't look into how
documentation was generated in nettle.

Also, this patch is against the nettle-2.2 release. I couldn't get the
CVS snapshot of nettle building, particularly because of the
integration of LSH.

-- 
Regards,
Andres Mejia

["rmd160-implementation.patch" (text/x-diff)]

diff --git a/Makefile.in b/Makefile.in
index fd486f5..cbb4ce4 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -68,6 +68,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 knuth-lfib.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
+		 rmd160.c rmd160-compress.c rmd160-meta.c \
 		 sha1.c sha1-compress.c sha1-meta.c \
 		 sha256.c sha256-compress.c sha224-meta.c sha256-meta.c \
 		 sha512.c sha512-compress.c sha384-meta.c sha512-meta.c \
@@ -113,7 +114,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h bignum.h blowfish.h \
 	  md5.h md5-compat.h \
 	  memxor.h \
 	  nettle-meta.h nettle-types.h \
-	  pgp.h pkcs1.h realloc.h rsa.h rsa-compat.h \
+	  pgp.h pkcs1.h realloc.h rmd.h rsa.h rsa-compat.h \
 	  sexp.h \
 	  serpent.h sha.h twofish.h \
 	  yarrow.h
diff --git a/nettle-meta-hashes.c b/nettle-meta-hashes.c
index 9007ea1..fdfec2e 100644
--- a/nettle-meta-hashes.c
+++ b/nettle-meta-hashes.c
@@ -31,6 +31,7 @@ const struct nettle_hash * const nettle_hashes[] = {
   &amp;nettle_md2,
   &amp;nettle_md4,
   &amp;nettle_md5,
+  &amp;nettle_rmd160,
   &amp;nettle_sha1,
   &amp;nettle_sha224,
   &amp;nettle_sha256,
diff --git a/nettle-meta.h b/nettle-meta.h
index 0fbfc03..5cb42e3 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -158,6 +158,7 @@ extern const struct nettle_hash * const nettle_hashes[];
 extern const struct nettle_hash nettle_md2;
 extern const struct nettle_hash nettle_md4;
 extern const struct nettle_hash nettle_md5;
+extern const struct nettle_hash nettle_rmd160;
 extern const struct nettle_hash nettle_sha1;
 extern const struct nettle_hash nettle_sha224;
 extern const struct nettle_hash nettle_sha256;
diff --git a/rmd.h b/rmd.h
new file mode 100644
index 0000000..26400d6
--- /dev/null
+++ b/rmd.h
@@ -0,0 +1,78 @@
+/* rmd.h
+ *
+ * RIPEMD hash functions.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2001 Niels Möller
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+
+#ifndef NETTLE_RMD_H_INCLUDED
+#define NETTLE_RMD_H_INCLUDED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include &lt;stdint.h&gt;
+
+/* Name mangling */
+#define rmd160_init nettle_rmd160_init
+#define rmd160_update nettle_rmd160_update
+#define rmd160_digest nettle_rmd160_digest
+
+/* RMD160 */
+
+#define RMD160_DIGEST_SIZE 20
+#define RMD160_DATA_SIZE 64
+
+/* Digest is kept internally as 5 32-bit words. */
+#define _RMD160_DIGEST_LENGTH 5
+
+struct rmd160_ctx
+{
+  uint32_t digest[_RMD160_DIGEST_LENGTH];
+  uint32_t nblocks;
+  uint8_t block[RMD160_DATA_SIZE];
+  unsigned int index;
+};
+
+void
+rmd160_init(struct rmd160_ctx *ctx);
+
+void
+rmd160_update(struct rmd160_ctx *ctx,
+      unsigned length,
+      const uint8_t *data);
+
+void
+rmd160_digest(struct rmd160_ctx *ctx,
+      unsigned length,
+      uint8_t *digest);
+
+/* Internal compression function. STATE points to 5 uint32_t words,
+   and DATA points to 64 bytes of input data, possibly unaligned. */
+void
+_nettle_rmd160_compress(uint32_t *state, const uint8_t *data);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_RMD_H_INCLUDED */
diff --git a/rmd160-compress.c b/rmd160-compress.c
new file mode 100644
index 0000000..6fc2899
--- /dev/null
+++ b/rmd160-compress.c
@@ -0,0 +1,277 @@
+/* rmd160-compress.c  -  RIPE-MD160 (Transform function)
+ * Copyright (C) 1998, 2001, 2002, 2003 Free Software Foundation, Inc.
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+
+#include &lt;string.h&gt;
+
+#include "rmd.h"
+
+/****************
+ * Rotate the 32 bit unsigned integer X by N bits left/right
+ */
+#if defined(__GNUC__) &amp;&amp; defined(__i386__)
+static inline uint32_t
+rol(uint32_t x, int n)
+{
+  __asm__("roll %%cl,%0"
+    :"=r" (x)
+    :"0" (x),"c" (n));
+  return x;
+}
+#else
+#define rol(x,n) ( ((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))) )
+#endif
+
+/****************
+ * Transform the message X which consists of 16 32-bit-words
+ */
+void
+_nettle_rmd160_compress(uint32_t *state, const uint8_t *data)
+{
+  register uint32_t a,b,c,d,e;
+  uint32_t aa,bb,cc,dd,ee,t;
+#ifdef WORDS_BIGENDIAN
+  uint32_t x[16];
+  {
+    int i;
+    uint8_t *p2, *p1;
+    for (i=0, p1=data, p2=(uint8_t*)x; i &lt; 16; i++, p2 += 4 )
+    {
+      p2[3] = *p1++;
+      p2[2] = *p1++;
+      p2[1] = *p1++;
+      p2[0] = *p1++;
+    }
+  }
+#else
+  /* This version is better because it is always aligned;
+   * The performance penalty on a 586-100 is about 6% which
+   * is acceptable - because the data is more local it might
+   * also be possible that this is faster on some machines.
+   * This function (when compiled with -02 on gcc 2.7.2)
+   * executes on a 586-100 (39.73 bogomips) at about 1900kb/sec;
+   * [measured with a 4MB data and "gpgm --print-md rmd160"] */
+  uint32_t x[16];
+  memcpy(x, data, 64);
+#endif
+
+
+#define K0  0x00000000
+#define K1  0x5A827999
+#define K2  0x6ED9EBA1
+#define K3  0x8F1BBCDC
+#define K4  0xA953FD4E
+#define KK0 0x50A28BE6
+#define KK1 0x5C4DD124
+#define KK2 0x6D703EF3
+#define KK3 0x7A6D76E9
+#define KK4 0x00000000
+#define F0(x,y,z)   ( (x) ^ (y) ^ (z) )
+#define F1(x,y,z)   ( ((x) &amp; (y)) | (~(x) &amp; (z)) )
+#define F2(x,y,z)   ( ((x) | ~(y)) ^ (z) )
+#define F3(x,y,z)   ( ((x) &amp; (z)) | ((y) &amp; ~(z)) )
+#define F4(x,y,z)   ( (x) ^ ((y) | ~(z)) )
+#define R(a,b,c,d,e,f,k,r,s) do { t = a + f(b,c,d) + k + x[r]; \
+          a = rol(t,s) + e;        \
+          c = rol(c,10);         \
+        } while(0)
+
+  /* left lane */
+  a = state[0];
+  b = state[1];
+  c = state[2];
+  d = state[3];
+  e = state[4];
+  R( a, b, c, d, e, F0, K0,  0, 11 );
+  R( e, a, b, c, d, F0, K0,  1, 14 );
+  R( d, e, a, b, c, F0, K0,  2, 15 );
+  R( c, d, e, a, b, F0, K0,  3, 12 );
+  R( b, c, d, e, a, F0, K0,  4,  5 );
+  R( a, b, c, d, e, F0, K0,  5,  8 );
+  R( e, a, b, c, d, F0, K0,  6,  7 );
+  R( d, e, a, b, c, F0, K0,  7,  9 );
+  R( c, d, e, a, b, F0, K0,  8, 11 );
+  R( b, c, d, e, a, F0, K0,  9, 13 );
+  R( a, b, c, d, e, F0, K0, 10, 14 );
+  R( e, a, b, c, d, F0, K0, 11, 15 );
+  R( d, e, a, b, c, F0, K0, 12,  6 );
+  R( c, d, e, a, b, F0, K0, 13,  7 );
+  R( b, c, d, e, a, F0, K0, 14,  9 );
+  R( a, b, c, d, e, F0, K0, 15,  8 );
+  R( e, a, b, c, d, F1, K1,  7,  7 );
+  R( d, e, a, b, c, F1, K1,  4,  6 );
+  R( c, d, e, a, b, F1, K1, 13,  8 );
+  R( b, c, d, e, a, F1, K1,  1, 13 );
+  R( a, b, c, d, e, F1, K1, 10, 11 );
+  R( e, a, b, c, d, F1, K1,  6,  9 );
+  R( d, e, a, b, c, F1, K1, 15,  7 );
+  R( c, d, e, a, b, F1, K1,  3, 15 );
+  R( b, c, d, e, a, F1, K1, 12,  7 );
+  R( a, b, c, d, e, F1, K1,  0, 12 );
+  R( e, a, b, c, d, F1, K1,  9, 15 );
+  R( d, e, a, b, c, F1, K1,  5,  9 );
+  R( c, d, e, a, b, F1, K1,  2, 11 );
+  R( b, c, d, e, a, F1, K1, 14,  7 );
+  R( a, b, c, d, e, F1, K1, 11, 13 );
+  R( e, a, b, c, d, F1, K1,  8, 12 );
+  R( d, e, a, b, c, F2, K2,  3, 11 );
+  R( c, d, e, a, b, F2, K2, 10, 13 );
+  R( b, c, d, e, a, F2, K2, 14,  6 );
+  R( a, b, c, d, e, F2, K2,  4,  7 );
+  R( e, a, b, c, d, F2, K2,  9, 14 );
+  R( d, e, a, b, c, F2, K2, 15,  9 );
+  R( c, d, e, a, b, F2, K2,  8, 13 );
+  R( b, c, d, e, a, F2, K2,  1, 15 );
+  R( a, b, c, d, e, F2, K2,  2, 14 );
+  R( e, a, b, c, d, F2, K2,  7,  8 );
+  R( d, e, a, b, c, F2, K2,  0, 13 );
+  R( c, d, e, a, b, F2, K2,  6,  6 );
+  R( b, c, d, e, a, F2, K2, 13,  5 );
+  R( a, b, c, d, e, F2, K2, 11, 12 );
+  R( e, a, b, c, d, F2, K2,  5,  7 );
+  R( d, e, a, b, c, F2, K2, 12,  5 );
+  R( c, d, e, a, b, F3, K3,  1, 11 );
+  R( b, c, d, e, a, F3, K3,  9, 12 );
+  R( a, b, c, d, e, F3, K3, 11, 14 );
+  R( e, a, b, c, d, F3, K3, 10, 15 );
+  R( d, e, a, b, c, F3, K3,  0, 14 );
+  R( c, d, e, a, b, F3, K3,  8, 15 );
+  R( b, c, d, e, a, F3, K3, 12,  9 );
+  R( a, b, c, d, e, F3, K3,  4,  8 );
+  R( e, a, b, c, d, F3, K3, 13,  9 );
+  R( d, e, a, b, c, F3, K3,  3, 14 );
+  R( c, d, e, a, b, F3, K3,  7,  5 );
+  R( b, c, d, e, a, F3, K3, 15,  6 );
+  R( a, b, c, d, e, F3, K3, 14,  8 );
+  R( e, a, b, c, d, F3, K3,  5,  6 );
+  R( d, e, a, b, c, F3, K3,  6,  5 );
+  R( c, d, e, a, b, F3, K3,  2, 12 );
+  R( b, c, d, e, a, F4, K4,  4,  9 );
+  R( a, b, c, d, e, F4, K4,  0, 15 );
+  R( e, a, b, c, d, F4, K4,  5,  5 );
+  R( d, e, a, b, c, F4, K4,  9, 11 );
+  R( c, d, e, a, b, F4, K4,  7,  6 );
+  R( b, c, d, e, a, F4, K4, 12,  8 );
+  R( a, b, c, d, e, F4, K4,  2, 13 );
+  R( e, a, b, c, d, F4, K4, 10, 12 );
+  R( d, e, a, b, c, F4, K4, 14,  5 );
+  R( c, d, e, a, b, F4, K4,  1, 12 );
+  R( b, c, d, e, a, F4, K4,  3, 13 );
+  R( a, b, c, d, e, F4, K4,  8, 14 );
+  R( e, a, b, c, d, F4, K4, 11, 11 );
+  R( d, e, a, b, c, F4, K4,  6,  8 );
+  R( c, d, e, a, b, F4, K4, 15,  5 );
+  R( b, c, d, e, a, F4, K4, 13,  6 );
+
+  aa = a; bb = b; cc = c; dd = d; ee = e;
+
+  /* right lane */
+  a = state[0];
+  b = state[1];
+  c = state[2];
+  d = state[3];
+  e = state[4];
+  R( a, b, c, d, e, F4, KK0,  5,  8);
+  R( e, a, b, c, d, F4, KK0, 14,  9);
+  R( d, e, a, b, c, F4, KK0,  7,  9);
+  R( c, d, e, a, b, F4, KK0,  0, 11);
+  R( b, c, d, e, a, F4, KK0,  9, 13);
+  R( a, b, c, d, e, F4, KK0,  2, 15);
+  R( e, a, b, c, d, F4, KK0, 11, 15);
+  R( d, e, a, b, c, F4, KK0,  4,  5);
+  R( c, d, e, a, b, F4, KK0, 13,  7);
+  R( b, c, d, e, a, F4, KK0,  6,  7);
+  R( a, b, c, d, e, F4, KK0, 15,  8);
+  R( e, a, b, c, d, F4, KK0,  8, 11);
+  R( d, e, a, b, c, F4, KK0,  1, 14);
+  R( c, d, e, a, b, F4, KK0, 10, 14);
+  R( b, c, d, e, a, F4, KK0,  3, 12);
+  R( a, b, c, d, e, F4, KK0, 12,  6);
+  R( e, a, b, c, d, F3, KK1,  6,  9);
+  R( d, e, a, b, c, F3, KK1, 11, 13);
+  R( c, d, e, a, b, F3, KK1,  3, 15);
+  R( b, c, d, e, a, F3, KK1,  7,  7);
+  R( a, b, c, d, e, F3, KK1,  0, 12);
+  R( e, a, b, c, d, F3, KK1, 13,  8);
+  R( d, e, a, b, c, F3, KK1,  5,  9);
+  R( c, d, e, a, b, F3, KK1, 10, 11);
+  R( b, c, d, e, a, F3, KK1, 14,  7);
+  R( a, b, c, d, e, F3, KK1, 15,  7);
+  R( e, a, b, c, d, F3, KK1,  8, 12);
+  R( d, e, a, b, c, F3, KK1, 12,  7);
+  R( c, d, e, a, b, F3, KK1,  4,  6);
+  R( b, c, d, e, a, F3, KK1,  9, 15);
+  R( a, b, c, d, e, F3, KK1,  1, 13);
+  R( e, a, b, c, d, F3, KK1,  2, 11);
+  R( d, e, a, b, c, F2, KK2, 15,  9);
+  R( c, d, e, a, b, F2, KK2,  5,  7);
+  R( b, c, d, e, a, F2, KK2,  1, 15);
+  R( a, b, c, d, e, F2, KK2,  3, 11);
+  R( e, a, b, c, d, F2, KK2,  7,  8);
+  R( d, e, a, b, c, F2, KK2, 14,  6);
+  R( c, d, e, a, b, F2, KK2,  6,  6);
+  R( b, c, d, e, a, F2, KK2,  9, 14);
+  R( a, b, c, d, e, F2, KK2, 11, 12);
+  R( e, a, b, c, d, F2, KK2,  8, 13);
+  R( d, e, a, b, c, F2, KK2, 12,  5);
+  R( c, d, e, a, b, F2, KK2,  2, 14);
+  R( b, c, d, e, a, F2, KK2, 10, 13);
+  R( a, b, c, d, e, F2, KK2,  0, 13);
+  R( e, a, b, c, d, F2, KK2,  4,  7);
+  R( d, e, a, b, c, F2, KK2, 13,  5);
+  R( c, d, e, a, b, F1, KK3,  8, 15);
+  R( b, c, d, e, a, F1, KK3,  6,  5);
+  R( a, b, c, d, e, F1, KK3,  4,  8);
+  R( e, a, b, c, d, F1, KK3,  1, 11);
+  R( d, e, a, b, c, F1, KK3,  3, 14);
+  R( c, d, e, a, b, F1, KK3, 11, 14);
+  R( b, c, d, e, a, F1, KK3, 15,  6);
+  R( a, b, c, d, e, F1, KK3,  0, 14);
+  R( e, a, b, c, d, F1, KK3,  5,  6);
+  R( d, e, a, b, c, F1, KK3, 12,  9);
+  R( c, d, e, a, b, F1, KK3,  2, 12);
+  R( b, c, d, e, a, F1, KK3, 13,  9);
+  R( a, b, c, d, e, F1, KK3,  9, 12);
+  R( e, a, b, c, d, F1, KK3,  7,  5);
+  R( d, e, a, b, c, F1, KK3, 10, 15);
+  R( c, d, e, a, b, F1, KK3, 14,  8);
+  R( b, c, d, e, a, F0, KK4, 12,  8);
+  R( a, b, c, d, e, F0, KK4, 15,  5);
+  R( e, a, b, c, d, F0, KK4, 10, 12);
+  R( d, e, a, b, c, F0, KK4,  4,  9);
+  R( c, d, e, a, b, F0, KK4,  1, 12);
+  R( b, c, d, e, a, F0, KK4,  5,  5);
+  R( a, b, c, d, e, F0, KK4,  8, 14);
+  R( e, a, b, c, d, F0, KK4,  7,  6);
+  R( d, e, a, b, c, F0, KK4,  6,  8);
+  R( c, d, e, a, b, F0, KK4,  2, 13);
+  R( b, c, d, e, a, F0, KK4, 13,  6);
+  R( a, b, c, d, e, F0, KK4, 14,  5);
+  R( e, a, b, c, d, F0, KK4,  0, 15);
+  R( d, e, a, b, c, F0, KK4,  3, 13);
+  R( c, d, e, a, b, F0, KK4,  9, 11);
+  R( b, c, d, e, a, F0, KK4, 11, 11);
+
+
+  t    = state[1] + d + cc;
+  state[1] = state[2] + e + dd;
+  state[2] = state[3] + a + ee;
+  state[3] = state[4] + b + aa;
+  state[4] = state[0] + c + bb;
+  state[0] = t;
+}
diff --git a/rmd160-meta.c b/rmd160-meta.c
new file mode 100644
index 0000000..2054dac
--- /dev/null
+++ b/rmd160-meta.c
@@ -0,0 +1,32 @@
+/* rmd160-meta.c */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2002 Niels Möller
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "rmd.h"
+
+const struct nettle_hash nettle_rmd160
+= _NETTLE_HASH(rmd160, RMD160);
diff --git a/rmd160.c b/rmd160.c
new file mode 100644
index 0000000..71064a5
--- /dev/null
+++ b/rmd160.c
@@ -0,0 +1,257 @@
+/* rmd160.c  -  RIPE-MD160
+ * Copyright (C) 1998, 2001, 2002, 2003 Free Software Foundation, Inc.
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+#include &lt;string.h&gt;
+#include &lt;assert.h&gt;
+
+#include "rmd.h"
+
+/*********************************
+ * RIPEMD-160 is not patented, see (as of 25.10.97)
+ *   http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html
+ * Note that the code uses Little Endian byteorder, which is good for
+ * 386 etc, but we must add some conversion when used on a big endian box.
+ *
+ *
+ * Pseudo-code for RIPEMD-160
+ *
+ * RIPEMD-160 is an iterative hash function that operates on 32-bit words.
+ * The round function takes as input a 5-word chaining variable and a 16-word
+ * message block and maps this to a new chaining variable. All operations are
+ * defined on 32-bit words. Padding is identical to that of MD4.
+ *
+ *
+ * RIPEMD-160: definitions
+ *
+ *
+ *   nonlinear functions at bit level: exor, mux, -, mux, -
+ *
+ *   f(j, x, y, z) = x XOR y XOR z      (0 &lt;= j &lt;= 15)
+ *   f(j, x, y, z) = (x AND y) OR (NOT(x) AND z)  (16 &lt;= j &lt;= 31)
+ *   f(j, x, y, z) = (x OR NOT(y)) XOR z    (32 &lt;= j &lt;= 47)
+ *   f(j, x, y, z) = (x AND z) OR (y AND NOT(z))  (48 &lt;= j &lt;= 63)
+ *   f(j, x, y, z) = x XOR (y OR NOT(z))    (64 &lt;= j &lt;= 79)
+ *
+ *
+ *   added constants (hexadecimal)
+ *
+ *   K(j) = 0x00000000      (0 &lt;= j &lt;= 15)
+ *   K(j) = 0x5A827999     (16 &lt;= j &lt;= 31)  int(2**30 x sqrt(2))
+ *   K(j) = 0x6ED9EBA1     (32 &lt;= j &lt;= 47)  int(2**30 x sqrt(3))
+ *   K(j) = 0x8F1BBCDC     (48 &lt;= j &lt;= 63)  int(2**30 x sqrt(5))
+ *   K(j) = 0xA953FD4E     (64 &lt;= j &lt;= 79)  int(2**30 x sqrt(7))
+ *   K'(j) = 0x50A28BE6     (0 &lt;= j &lt;= 15)      int(2**30 x cbrt(2))
+ *   K'(j) = 0x5C4DD124    (16 &lt;= j &lt;= 31)      int(2**30 x cbrt(3))
+ *   K'(j) = 0x6D703EF3    (32 &lt;= j &lt;= 47)      int(2**30 x cbrt(5))
+ *   K'(j) = 0x7A6D76E9    (48 &lt;= j &lt;= 63)      int(2**30 x cbrt(7))
+ *   K'(j) = 0x00000000    (64 &lt;= j &lt;= 79)
+ *
+ *
+ *   selection of message word
+ *
+ *   r(j)      = j          (0 &lt;= j &lt;= 15)
+ *   r(16..31) = 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8
+ *   r(32..47) = 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12
+ *   r(48..63) = 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2
+ *   r(64..79) = 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
+ *   r0(0..15) = 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12
+ *   r0(16..31)= 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2
+ *   r0(32..47)= 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13
+ *   r0(48..63)= 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14
+ *   r0(64..79)= 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
+ *
+ *
+ *   amount for rotate left (rol)
+ *
+ *   s(0..15)  = 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8
+ *   s(16..31) = 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12
+ *   s(32..47) = 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5
+ *   s(48..63) = 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12
+ *   s(64..79) = 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
+ *   s'(0..15) = 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6
+ *   s'(16..31)= 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11
+ *   s'(32..47)= 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5
+ *   s'(48..63)= 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8
+ *   s'(64..79)= 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
+ *
+ *
+ *   initial value (hexadecimal)
+ *
+ *   h0 = 0x67452301; h1 = 0xEFCDAB89; h2 = 0x98BADCFE; h3 = 0x10325476;
+ *              h4 = 0xC3D2E1F0;
+ *
+ *
+ * RIPEMD-160: pseudo-code
+ *
+ *   It is assumed that the message after padding consists of t 16-word blocks
+ *   that will be denoted with X[i][j], with 0 &lt;= i &lt;= t-1 and 0 &lt;= j &lt;= 15.
+ *   The symbol [+] denotes addition modulo 2**32 and rol_s denotes cyclic left
+ *   shift (rotate) over s positions.
+ *
+ *
+ *   for i := 0 to t-1 {
+ *   A := h0; B := h1; C := h2; D = h3; E = h4;
+ *   A' := h0; B' := h1; C' := h2; D' = h3; E' = h4;
+ *   for j := 0 to 79 {
+ *       T := rol_s(j)(A [+] f(j, B, C, D) [+] X[i][r(j)] [+] K(j)) [+] E;
+ *       A := E; E := D; D := rol_10(C); C := B; B := T;
+ *       T := rol_s'(j)(A' [+] f(79-j, B', C', D') [+] X[i][r'(j)]
+                   [+] K'(j)) [+] E';
+ *       A' := E'; E' := D'; D' := rol_10(C'); C' := B'; B' := T;
+ *   }
+ *   T := h1 [+] C [+] D'; h1 := h2 [+] D [+] E'; h2 := h3 [+] E [+] A';
+ *   h3 := h4 [+] A [+] B'; h4 := h0 [+] B [+] C'; h0 := T;
+ *   }
+ */
+
+/* Some examples:
+ * ""                    9c1185a5c5e9fc54612808977ee8f548b2258d31
+ * "a"                   0bdc9d2d256b3ee9daae347be6f4dc835a467ffe
+ * "abc"                 8eb208f7e05d987a9b044a8e98c6b087f15a0bfc
+ * "message digest"      5d0689ef49d2fae572b881b123a85ffa21595f36
+ * "a...z"               f71c27109c692c1b56bbdceb5b9d2865b3708dbc
+ * "abcdbcde...nopq"     12a053384a9c0c88e405a06c27dcf49ada62eb2b
+ * "A...Za...z0...9"     b0e20b6e3116640286ed3a87a5713079b21f5189
+ * 8 times "1234567890"  9b752e45573d4b39f4dbd3323cab82bf63326bfb
+ * 1 million times "a"   52783243c1697bdbe16d37f97f68f08325dc1528
+ */
+
+void
+rmd160_init(struct rmd160_ctx *ctx)
+{
+  ctx-&gt;digest[0] = 0x67452301;
+  ctx-&gt;digest[1] = 0xEFCDAB89;
+  ctx-&gt;digest[2] = 0x98BADCFE;
+  ctx-&gt;digest[3] = 0x10325476;
+  ctx-&gt;digest[4] = 0xC3D2E1F0;
+  memset(&amp;ctx-&gt;block, 0, sizeof(ctx-&gt;block));
+  ctx-&gt;nblocks = 0;
+  ctx-&gt;index = 0;
+}
+
+/* Update the message digest with the contents
+ * of DATA with length LENGTH.
+ */
+void
+rmd160_update(struct rmd160_ctx *ctx, unsigned length, const uint8_t *data)
+{
+  if(ctx-&gt;index == 64)  /* flush the buffer */
+  {
+    _nettle_rmd160_compress(ctx-&gt;digest, ctx-&gt;block);
+    ctx-&gt;index = 0;
+    ctx-&gt;nblocks++;
+  }
+  if(!data)
+    return;
+  if(ctx-&gt;index)
+  {
+    for(; length &amp;&amp; ctx-&gt;index &lt; 64; length--)
+      ctx-&gt;block[ctx-&gt;index++] = *data++;
+    rmd160_update(ctx, 0, NULL);
+    if(!length)
+      return;
+  }
+
+  while( length &gt;= 64 )
+  {
+    _nettle_rmd160_compress(ctx-&gt;digest, data);
+    ctx-&gt;index = 0;
+    ctx-&gt;nblocks++;
+    length -= 64;
+    data += 64;
+  }
+  for(; length &amp;&amp; ctx-&gt;index &lt; 64; length--)
+    ctx-&gt;block[ctx-&gt;index++] = *data++;
+}
+
+/* The routine terminates the computation */
+static void
+rmd160_final(struct rmd160_ctx *ctx)
+{
+  uint32_t t, msb, lsb;
+  uint8_t *p;
+
+  rmd160_update(ctx, 0, NULL); /* flush */;
+
+  t = ctx-&gt;nblocks;
+  /* multiply by 64 to make a byte count */
+  lsb = t &lt;&lt; 6;
+  msb = t &gt;&gt; 26;
+  /* add the count */
+  t = lsb;
+  if( (lsb += ctx-&gt;index) &lt; t )
+    msb++;
+  /* multiply by 8 to make a bit count */
+  t = lsb;
+  lsb &lt;&lt;= 3;
+  msb &lt;&lt;= 3;
+  msb |= t &gt;&gt; 29;
+
+  if( ctx-&gt;index &lt; 56 )  /* enough room */
+  {
+    ctx-&gt;block[ctx-&gt;index++] = 0x80; /* pad */
+    while( ctx-&gt;index &lt; 56 )
+      ctx-&gt;block[ctx-&gt;index++] = 0;  /* pad */
+  }
+  else  /* need one extra block */
+  {
+    ctx-&gt;block[ctx-&gt;index++] = 0x80; /* pad character */
+    while( ctx-&gt;index &lt; 64 )
+      ctx-&gt;block[ctx-&gt;index++] = 0;
+    rmd160_update(ctx, 0, NULL);  /* flush */;
+    memset(ctx-&gt;block, 0, 56 ); /* fill next block with zeroes */
+  }
+  /* append the 64 bit count */
+  ctx-&gt;block[56] = lsb;
+  ctx-&gt;block[57] = lsb &gt;&gt;  8;
+  ctx-&gt;block[58] = lsb &gt;&gt; 16;
+  ctx-&gt;block[59] = lsb &gt;&gt; 24;
+  ctx-&gt;block[60] = msb;
+  ctx-&gt;block[61] = msb &gt;&gt;  8;
+  ctx-&gt;block[62] = msb &gt;&gt; 16;
+  ctx-&gt;block[63] = msb &gt;&gt; 24;
+  _nettle_rmd160_compress(ctx-&gt;digest, ctx-&gt;block);
+
+  p = ctx-&gt;block;
+#ifdef WORDS_BIGENDIAN
+#define X(a) do { *p++ = ctx-&gt;digest[a]    ; *p++ = ctx-&gt;digest[a] &gt;&gt; 8; \
+  *p++ = ctx-&gt;digest[a] &gt;&gt; 16; *p++ = ctx-&gt;digest[a] &gt;&gt; 24; } while(0)
+#else /* little endian */
+#define X(a) do { *(uint32_t*)p = ctx-&gt;digest[a] ; p += 4; } while(0)
+#endif
+  X(0);
+  X(1);
+  X(2);
+  X(3);
+  X(4);
+#undef X
+}
+
+void
+rmd160_digest(struct rmd160_ctx *ctx, unsigned length, uint8_t *digest)
+{
+  assert(length &lt;= RMD160_DIGEST_SIZE);
+
+  rmd160_final(ctx);
+  memcpy(digest, ctx-&gt;block, length);
+  rmd160_init(ctx);
+}
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 8a263cb..ce949d5 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -17,6 +17,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    des-test.c des3-test.c des-compat-test.c \
 		    md2-test.c md4-test.c md5-test.c md5-compat-test.c \
 		    memxor-test.c \
+		    rmd160-test.c \
 		    sha1-test.c sha224-test.c sha256-test.c \
 		    sha384-test.c sha512-test.c \
 		    serpent-test.c twofish-test.c \
diff --git a/testsuite/rmd160-test.c b/testsuite/rmd160-test.c
new file mode 100644
index 0000000..3be9e70
--- /dev/null
+++ b/testsuite/rmd160-test.c
@@ -0,0 +1,37 @@
+#include "testutils.h"
+#include "rmd.h"
+
+int
+test_main(void)
+{
+  test_hash(&amp;nettle_rmd160, 0, "",
+      H("9c1185a5c5e9fc54612808977ee8f548b2258d31"));
+
+  test_hash(&amp;nettle_rmd160, 1, "a",
+      H("0bdc9d2d256b3ee9daae347be6f4dc835a467ffe"));
+
+  test_hash(&amp;nettle_rmd160, 3, "abc",
+      H("8eb208f7e05d987a9b044a8e98c6b087f15a0bfc"));
+
+  test_hash(&amp;nettle_rmd160, 26, "abcdefghijklmnopqrstuvwxyz",
+      H("f71c27109c692c1b56bbdceb5b9d2865b3708dbc"));
+
+  test_hash(&amp;nettle_rmd160, 14, "message digest",
+      H("5d0689ef49d2fae572b881b123a85ffa21595f36"));
+
+  test_hash(&amp;nettle_rmd160, 62,
+      "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+      "abcdefghijklmnopqrstuvwxyz0123456789",
+      H("b0e20b6e3116640286ed3a87a5713079b21f5189"));
+
+  test_hash(&amp;nettle_rmd160,  80,
+      "1234567890123456789012345678901234567890"
+      "1234567890123456789012345678901234567890",
+      H("9b752e45573d4b39f4dbd3323cab82bf63326bfb"));
+
+  /* Additional test vector, from Daniel Kahn Gillmor */
+  test_hash(&amp;nettle_rmd160, LDATA("38"),
+      H("6b2d075b1cd34cd1c3e43a995f110c55649dad0e"));
+
+  SUCCESS();
+}


</body></email><email><emailId>20110827190509</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-08-27 19:05:09-0400</timestampReceived><subject>Re: RIPEMD-160 Implementation</subject><body>

Andres Mejia &lt;mcitadel@gmail.com&gt; writes:

&gt; Here's a patch that will implement RIPEMD-160 for nettle. It's code
&gt; ported from libgcrypt.

Thanks!

&gt; There's no documentation update in this patch. I didn't look into how
&gt; documentation was generated in nettle.

The documentation "master file" is nettle.texinfo. info, html and pdf
files are all generated from that.

&gt; Also, this patch is against the nettle-2.2 release. I couldn't get the
&gt; CVS snapshot of nettle building, particularly because of the
&gt; integration of LSH.

Did you follow the instructions? If so, I'd be interested to hear how it
failed. Anyway, basing patches on the 2.2 release is fine too.

Some initial comments on the implementation added below. Mostly cosmetic. Let
me know if you plan to make an updated patch, or if I should address
this myself when I intergrate the code.

&gt; +		 rmd160.c rmd160-compress.c rmd160-meta.c \

Naming: Is "rmd" a commonly used abbreviation? Otherwise, I think I'd
prefer to write out "ripemd" both in filenames and C symbols.

Are any other variants of ripemd in use? (According to wikipedia,
there's original ripemd, ripemd-128, ripend-160, ripemd-256 and
ripemd-320, but I have no idea which of them are in use today or are
likely to be used in the future).

&gt; --- /dev/null
&gt; +++ b/rmd160-compress.c
&gt; @@ -0,0 +1,277 @@
&gt; +/* rmd160-compress.c  -  RIPE-MD160 (Transform function)
&gt; + * Copyright (C) 1998, 2001, 2002, 2003 Free Software Foundation, Inc.
&gt; + *
&gt; + * The nettle library is free software; you can redistribute it and/or modify
&gt; + * it under the terms of the GNU Lesser General Public License as published by
&gt; + * the Free Software Foundation; either version 2.1 of the License, or (at your
&gt; + * option) any later version.
&gt; + *
&gt; + * The nettle library is distributed in the hope that it will be useful, but
&gt; + * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&gt; + * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
&gt; + * License for more details.
&gt; + *
&gt; + * You should have received a copy of the GNU Lesser General Public License
&gt; + * along with the nettle library; see the file COPYING.LIB.  If not, write to
&gt; + * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
&gt; + * MA 02111-1307, USA.
&gt; + */
&gt; +
&gt; +#include &lt;string.h&gt;
&gt; +
&gt; +#include "rmd.h"
&gt; +
&gt; +/****************
&gt; + * Rotate the 32 bit unsigned integer X by N bits left/right
&gt; + */
&gt; +#if defined(__GNUC__) &amp;&amp; defined(__i386__)
&gt; +static inline uint32_t
&gt; +rol(uint32_t x, int n)
&gt; +{
&gt; +  __asm__("roll %%cl,%0"
&gt; +    :"=r" (x)
&gt; +    :"0" (x),"c" (n));
&gt; +  return x;
&gt; +}
&gt; +#else
&gt; +#define rol(x,n) ( ((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))) )
&gt; +#endif

I think current gcc may recognize (x &lt;&lt; n) | (x &gt;&gt; (wordsize - n)) and
generate a rotate instruction (but I haven't tested). I don't usually
put very machine dependent things like this in the C source files; if
performance for this function is that important, one can write an
assembler implementation of the compression function.

&gt; +/****************
&gt; + * Transform the message X which consists of 16 32-bit-words
&gt; + */
&gt; +void
&gt; +_nettle_rmd160_compress(uint32_t *state, const uint8_t *data)
&gt; +{
&gt; +  register uint32_t a,b,c,d,e;
&gt; +  uint32_t aa,bb,cc,dd,ee,t;
&gt; +#ifdef WORDS_BIGENDIAN
&gt; +  uint32_t x[16];
&gt; +  {
&gt; +    int i;
&gt; +    uint8_t *p2, *p1;
&gt; +    for (i=0, p1=data, p2=(uint8_t*)x; i &lt; 16; i++, p2 += 4 )
&gt; +    {
&gt; +      p2[3] = *p1++;
&gt; +      p2[2] = *p1++;
&gt; +      p2[1] = *p1++;
&gt; +      p2[0] = *p1++;
&gt; +    }
&gt; +  }

I'd just use READ_UINT32. I'd expect that explicit shifting is faster
than repeated byte writes to memory.

I would also do the little endian special case (with memcpy) only if
memcpy really is measured to be faster (it may well be, I can't guess).

&gt; --- /dev/null
&gt; +++ b/rmd160-meta.c
&gt; @@ -0,0 +1,32 @@
&gt; +/* rmd160-meta.c */
&gt; +
&gt; +/* nettle, low-level cryptographics library
&gt; + *
&gt; + * Copyright (C) 2002 Niels Möller

This copyright notice seems to be wrong (even if the contents of this
file is barely copyrightable).

&gt; + * RIPEMD-160 is not patented, see (as of 25.10.97)

I'd prefer to write the date either in words, or using ISO-format
yyyy-mm-dd (1997-10-25).

&gt; + *   http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html
&gt; + * Note that the code uses Little Endian byteorder, which is good for
&gt; + * 386 etc, but we must add some conversion when used on a big endian box.

Would it be possible to write efficient code using big-endian byteorder
for all intermediate values? My initial guess is no: even if we use
inverse byteorder for input, output, and constants, the rotate
operations will be a problem, and that will kill any performance gain
from omitted byteswapping of inputs and outputs.

&gt; +/* The routine terminates the computation */
&gt; +static void
&gt; +rmd160_final(struct rmd160_ctx *ctx)
&gt; +{
&gt; +  uint32_t t, msb, lsb;
&gt; +  uint8_t *p;
&gt; +
&gt; +  rmd160_update(ctx, 0, NULL); /* flush */;
&gt; +
&gt; +  t = ctx-&gt;nblocks;
&gt; +  /* multiply by 64 to make a byte count */
&gt; +  lsb = t &lt;&lt; 6;
&gt; +  msb = t &gt;&gt; 26;
&gt; +  /* add the count */
&gt; +  t = lsb;
&gt; +  if( (lsb += ctx-&gt;index) &lt; t )
&gt; +    msb++;
&gt; +  /* multiply by 8 to make a bit count */
&gt; +  t = lsb;
&gt; +  lsb &lt;&lt;= 3;
&gt; +  msb &lt;&lt;= 3;
&gt; +  msb |= t &gt;&gt; 29;

If it's really a 64-bit bit count, then I think the context struct needs
a larger counter. Also the logic for adding the counter and padding
could perhaps be borrowed from the corresponding sha1 or md5 code (but I
haven't read the ripemd160 spec, so maybe it's really doing something
different).

&gt; +  /* append the 64 bit count */
&gt; +  ctx-&gt;block[56] = lsb;
&gt; +  ctx-&gt;block[57] = lsb &gt;&gt;  8;
&gt; +  ctx-&gt;block[58] = lsb &gt;&gt; 16;
&gt; +  ctx-&gt;block[59] = lsb &gt;&gt; 24;
&gt; +  ctx-&gt;block[60] = msb;
&gt; +  ctx-&gt;block[61] = msb &gt;&gt;  8;
&gt; +  ctx-&gt;block[62] = msb &gt;&gt; 16;
&gt; +  ctx-&gt;block[63] = msb &gt;&gt; 24;

Use WRITE_UINT32 (or one could have the input to the compression
function by an array of uint32_t rather than uint8_t, but that has the
drawback that an assembler implementation of the compression function
can no longer optimize the byteswapping of the input).

&gt; +  _nettle_rmd160_compress(ctx-&gt;digest, ctx-&gt;block);
&gt; +
&gt; +  p = ctx-&gt;block;
&gt; +#ifdef WORDS_BIGENDIAN
&gt; +#define X(a) do { *p++ = ctx-&gt;digest[a]    ; *p++ = ctx-&gt;digest[a] &gt;&gt; 8; \
&gt; +  *p++ = ctx-&gt;digest[a] &gt;&gt; 16; *p++ = ctx-&gt;digest[a] &gt;&gt; 24; } while(0)
&gt; +#else /* little endian */
&gt; +#define X(a) do { *(uint32_t*)p = ctx-&gt;digest[a] ; p += 4; } while(0)
&gt; +#endif

This looks more obscure than it should be. I think it would be better to
have the _final function not do any byteswapping, but leave it to the
_digest function (which also knows how much data is needed, and which is
the function responsible for converting the internal state to a byte
sequence). And then write a new _nettle_write_le32 function (analogous
to write-be32.c:_nettle_write_be32) and share it with md5_digest.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110827200548</emailId><senderName>Andres Mejia</senderName><senderEmail>mcitadel@gmail.com</senderEmail><timestampReceived>2011-08-27 20:05:48-0400</timestampReceived><subject>Re: RIPEMD-160 Implementation</subject><body>

On Sat, Aug 27, 2011 at 3:05 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Andres Mejia &lt;mcitadel@gmail.com&gt; writes:
&gt;
&gt;&gt; Here's a patch that will implement RIPEMD-160 for nettle. It's code
&gt;&gt; ported from libgcrypt.
&gt;
&gt; Thanks!
&gt;
&gt;&gt; There's no documentation update in this patch. I didn't look into how
&gt;&gt; documentation was generated in nettle.
&gt;
&gt; The documentation "master file" is nettle.texinfo. info, html and pdf
&gt; files are all generated from that.
&gt;
&gt;&gt; Also, this patch is against the nettle-2.2 release. I couldn't get the
&gt;&gt; CVS snapshot of nettle building, particularly because of the
&gt;&gt; integration of LSH.
&gt;
&gt; Did you follow the instructions? If so, I'd be interested to hear how it
&gt; failed. Anyway, basing patches on the 2.2 release is fine too.

It was when I tried to run autoreconf. I'll try again with the instructions.

&gt; Some initial comments on the implementation added below. Mostly cosmetic. Let
&gt; me know if you plan to make an updated patch, or if I should address
&gt; this myself when I intergrate the code.
&gt;
&gt;&gt; +              rmd160.c rmd160-compress.c rmd160-meta.c \
&gt;
&gt; Naming: Is "rmd" a commonly used abbreviation? Otherwise, I think I'd
&gt; prefer to write out "ripemd" both in filenames and C symbols.

Either is fine by me.

&gt; Are any other variants of ripemd in use? (According to wikipedia,
&gt; there's original ripemd, ripemd-128, ripend-160, ripemd-256 and
&gt; ripemd-320, but I have no idea which of them are in use today or are
&gt; likely to be used in the future).

RIPEMD-160 was the only implementation I found in libgcrypt. I'm not
aware if any of the other algorithms are in use.

&gt;&gt; --- /dev/null
&gt;&gt; +++ b/rmd160-compress.c
&gt;&gt; @@ -0,0 +1,277 @@
&gt;&gt; +/* rmd160-compress.c  -  RIPE-MD160 (Transform function)
&gt;&gt; + * Copyright (C) 1998, 2001, 2002, 2003 Free Software Foundation, Inc.
&gt;&gt; + *
&gt;&gt; + * The nettle library is free software; you can redistribute it and/or modify
&gt;&gt; + * it under the terms of the GNU Lesser General Public License as published by
&gt;&gt; + * the Free Software Foundation; either version 2.1 of the License, or (at your
&gt;&gt; + * option) any later version.
&gt;&gt; + *
&gt;&gt; + * The nettle library is distributed in the hope that it will be useful, but
&gt;&gt; + * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&gt;&gt; + * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
&gt;&gt; + * License for more details.
&gt;&gt; + *
&gt;&gt; + * You should have received a copy of the GNU Lesser General Public License
&gt;&gt; + * along with the nettle library; see the file COPYING.LIB.  If not, write to
&gt;&gt; + * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
&gt;&gt; + * MA 02111-1307, USA.
&gt;&gt; + */
&gt;&gt; +
&gt;&gt; +#include &lt;string.h&gt;
&gt;&gt; +
&gt;&gt; +#include "rmd.h"
&gt;&gt; +
&gt;&gt; +/****************
&gt;&gt; + * Rotate the 32 bit unsigned integer X by N bits left/right
&gt;&gt; + */
&gt;&gt; +#if defined(__GNUC__) &amp;&amp; defined(__i386__)
&gt;&gt; +static inline uint32_t
&gt;&gt; +rol(uint32_t x, int n)
&gt;&gt; +{
&gt;&gt; +  __asm__("roll %%cl,%0"
&gt;&gt; +    :"=r" (x)
&gt;&gt; +    :"0" (x),"c" (n));
&gt;&gt; +  return x;
&gt;&gt; +}
&gt;&gt; +#else
&gt;&gt; +#define rol(x,n) ( ((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))) )
&gt;&gt; +#endif
&gt;
&gt; I think current gcc may recognize (x &lt;&lt; n) | (x &gt;&gt; (wordsize - n)) and
&gt; generate a rotate instruction (but I haven't tested). I don't usually
&gt; put very machine dependent things like this in the C source files; if
&gt; performance for this function is that important, one can write an
&gt; assembler implementation of the compression function.
&gt;
&gt;&gt; +/****************
&gt;&gt; + * Transform the message X which consists of 16 32-bit-words
&gt;&gt; + */
&gt;&gt; +void
&gt;&gt; +_nettle_rmd160_compress(uint32_t *state, const uint8_t *data)
&gt;&gt; +{
&gt;&gt; +  register uint32_t a,b,c,d,e;
&gt;&gt; +  uint32_t aa,bb,cc,dd,ee,t;
&gt;&gt; +#ifdef WORDS_BIGENDIAN
&gt;&gt; +  uint32_t x[16];
&gt;&gt; +  {
&gt;&gt; +    int i;
&gt;&gt; +    uint8_t *p2, *p1;
&gt;&gt; +    for (i=0, p1=data, p2=(uint8_t*)x; i &lt; 16; i++, p2 += 4 )
&gt;&gt; +    {
&gt;&gt; +      p2[3] = *p1++;
&gt;&gt; +      p2[2] = *p1++;
&gt;&gt; +      p2[1] = *p1++;
&gt;&gt; +      p2[0] = *p1++;
&gt;&gt; +    }
&gt;&gt; +  }
&gt;
&gt; I'd just use READ_UINT32. I'd expect that explicit shifting is faster
&gt; than repeated byte writes to memory.
&gt;
&gt; I would also do the little endian special case (with memcpy) only if
&gt; memcpy really is measured to be faster (it may well be, I can't guess).
&gt;
&gt;&gt; --- /dev/null
&gt;&gt; +++ b/rmd160-meta.c
&gt;&gt; @@ -0,0 +1,32 @@
&gt;&gt; +/* rmd160-meta.c */
&gt;&gt; +
&gt;&gt; +/* nettle, low-level cryptographics library
&gt;&gt; + *
&gt;&gt; + * Copyright (C) 2002 Niels Möller
&gt;
&gt; This copyright notice seems to be wrong (even if the contents of this
&gt; file is barely copyrightable).
&gt;
&gt;&gt; + * RIPEMD-160 is not patented, see (as of 25.10.97)
&gt;
&gt; I'd prefer to write the date either in words, or using ISO-format
&gt; yyyy-mm-dd (1997-10-25).
&gt;
&gt;&gt; + *   http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html
&gt;&gt; + * Note that the code uses Little Endian byteorder, which is good for
&gt;&gt; + * 386 etc, but we must add some conversion when used on a big endian box.
&gt;
&gt; Would it be possible to write efficient code using big-endian byteorder
&gt; for all intermediate values? My initial guess is no: even if we use
&gt; inverse byteorder for input, output, and constants, the rotate
&gt; operations will be a problem, and that will kill any performance gain
&gt; from omitted byteswapping of inputs and outputs.
&gt;
&gt;&gt; +/* The routine terminates the computation */
&gt;&gt; +static void
&gt;&gt; +rmd160_final(struct rmd160_ctx *ctx)
&gt;&gt; +{
&gt;&gt; +  uint32_t t, msb, lsb;
&gt;&gt; +  uint8_t *p;
&gt;&gt; +
&gt;&gt; +  rmd160_update(ctx, 0, NULL); /* flush */;
&gt;&gt; +
&gt;&gt; +  t = ctx-&gt;nblocks;
&gt;&gt; +  /* multiply by 64 to make a byte count */
&gt;&gt; +  lsb = t &lt;&lt; 6;
&gt;&gt; +  msb = t &gt;&gt; 26;
&gt;&gt; +  /* add the count */
&gt;&gt; +  t = lsb;
&gt;&gt; +  if( (lsb += ctx-&gt;index) &lt; t )
&gt;&gt; +    msb++;
&gt;&gt; +  /* multiply by 8 to make a bit count */
&gt;&gt; +  t = lsb;
&gt;&gt; +  lsb &lt;&lt;= 3;
&gt;&gt; +  msb &lt;&lt;= 3;
&gt;&gt; +  msb |= t &gt;&gt; 29;
&gt;
&gt; If it's really a 64-bit bit count, then I think the context struct needs
&gt; a larger counter. Also the logic for adding the counter and padding
&gt; could perhaps be borrowed from the corresponding sha1 or md5 code (but I
&gt; haven't read the ripemd160 spec, so maybe it's really doing something
&gt; different).
&gt;
&gt;&gt; +  /* append the 64 bit count */
&gt;&gt; +  ctx-&gt;block[56] = lsb;
&gt;&gt; +  ctx-&gt;block[57] = lsb &gt;&gt;  8;
&gt;&gt; +  ctx-&gt;block[58] = lsb &gt;&gt; 16;
&gt;&gt; +  ctx-&gt;block[59] = lsb &gt;&gt; 24;
&gt;&gt; +  ctx-&gt;block[60] = msb;
&gt;&gt; +  ctx-&gt;block[61] = msb &gt;&gt;  8;
&gt;&gt; +  ctx-&gt;block[62] = msb &gt;&gt; 16;
&gt;&gt; +  ctx-&gt;block[63] = msb &gt;&gt; 24;
&gt;
&gt; Use WRITE_UINT32 (or one could have the input to the compression
&gt; function by an array of uint32_t rather than uint8_t, but that has the
&gt; drawback that an assembler implementation of the compression function
&gt; can no longer optimize the byteswapping of the input).
&gt;
&gt;&gt; +  _nettle_rmd160_compress(ctx-&gt;digest, ctx-&gt;block);
&gt;&gt; +
&gt;&gt; +  p = ctx-&gt;block;
&gt;&gt; +#ifdef WORDS_BIGENDIAN
&gt;&gt; +#define X(a) do { *p++ = ctx-&gt;digest[a]    ; *p++ = ctx-&gt;digest[a] &gt;&gt; 8; \
&gt;&gt; +  *p++ = ctx-&gt;digest[a] &gt;&gt; 16; *p++ = ctx-&gt;digest[a] &gt;&gt; 24; } while(0)
&gt;&gt; +#else /* little endian */
&gt;&gt; +#define X(a) do { *(uint32_t*)p = ctx-&gt;digest[a] ; p += 4; } while(0)
&gt;&gt; +#endif
&gt;
&gt; This looks more obscure than it should be. I think it would be better to
&gt; have the _final function not do any byteswapping, but leave it to the
&gt; _digest function (which also knows how much data is needed, and which is
&gt; the function responsible for converting the internal state to a byte
&gt; sequence). And then write a new _nettle_write_le32 function (analogous
&gt; to write-be32.c:_nettle_write_be32) and share it with md5_digest.

All this code is ported from libgcrypt. I'll leave it to you what
modifications you want to do with the code.

&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
&gt; Internet email is subject to wholesale government surveillance.
&gt;

I'm curious, why are the internal transform functions exposed to the public?

-- 
Regards,
Andres Mejia

</body></email><email><emailId>20110827201935</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-08-27 20:19:35-0400</timestampReceived><subject>Re: RIPEMD-160 Implementation</subject><body>

On 08/27/2011 09:05 PM, Niels Möller wrote:

&gt; Are any other variants of ripemd in use? (According to wikipedia,
&gt; there's original ripemd, ripemd-128, ripend-160, ripemd-256 and
&gt; ripemd-320, but I have no idea which of them are in use today or are
&gt; likely to be used in the future).

ripemd and ripemd-128 are considered broken. I don't know if ripemd-x,
x&gt;=256 have been used anywhere. Having the SHA-3 winner instead would be
a much better choice.

regards,
Nikos

</body></email><email><emailId>20110827211943</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-08-27 21:19:43-0400</timestampReceived><subject>Re: RIPEMD-160 Implementation</subject><body>

Andres Mejia &lt;mcitadel@gmail.com&gt; writes:

&gt; I'm curious, why are the internal transform functions exposed to the public?

As long as the compression function is only implemented in C, it can be
declared static and put in the same file as the _update and _final
functions which use it.

But when the compression function is implemented in assembly for some
platforms (there's currently sha1 assembly for x86 and x86_64, and md5
assembly for x86), it's moved to a separate file, so that configure can
decide to link in an assembly file overriding the C version. And then
the function is exposed like any other global function (but with a name
starting with _nettle to indicate that it is internal).

One could play with ELF visibility properties, but I haven't tried that
and it's not a general solution.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110827212418</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-08-27 21:24:18-0400</timestampReceived><subject>Re: RIPEMD-160 Implementation</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; ripemd and ripemd-128 are considered broken. I don't know if ripemd-x,
&gt; x&gt;=256 have been used anywhere. Having the SHA-3 winner instead would be
&gt; a much better choice.

Thanks. The related naming question is: Should the header file be
nettle/ripend160.h (declaring the single algorithm ripemd160) or
nettle/ripemd.h (declaring all supported hash functions in the family)?

Current include file naming is not 100% consistent, with sha.h, md4.h
and md5.h, and luckily it doesn't have to. Question is, what makes the
most sense for ripemd?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110827213309</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-08-27 21:33:09-0400</timestampReceived><subject>Re: RIPEMD-160 Implementation</subject><body>

On 08/27/2011 11:24 PM, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos&lt;nmav@gnutls.org&gt;  writes:
&gt;
&gt;&gt; ripemd and ripemd-128 are considered broken. I don't know if ripemd-x,
&gt;&gt; x&gt;=256 have been used anywhere. Having the SHA-3 winner instead would be
&gt;&gt; a much better choice.
&gt;
&gt; Thanks. The related naming question is: Should the header file be
&gt; nettle/ripend160.h (declaring the single algorithm ripemd160) or
&gt; nettle/ripemd.h (declaring all supported hash functions in the family)?

I'd use ripemd160.h to avoid confusion with the broken ripemd.

regards,
Nikos

</body></email><email><emailId>20110702073052</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-07-02 07:30:52-0400</timestampReceived><subject>Re: gcm crash on ppc</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; What is fishy is that nettle_gcm_aes128 doesn't seem to have been
&gt;&gt; initialized properly:
&gt;
&gt; Did you solve this problem? To me it seems like it could be
&gt;
&gt; * setup of the shared-library magic, for this particular object file,
&gt;   somehow broken.
&gt;
&gt; * bugs in the macos port of gcc (I don't know if you use apples "xcode"
&gt;   or some other gcc port, and I don't really know the difference
&gt;   either). According to the gmp people, there have been *lots* of
&gt;   problems with apple's linker and maybe also with other related tools.
&gt;
&gt; * some other random hardware or software problem.

The problem still occurs, but I'd be inclined to write it off as a
compiler bug because the system is running pretty old software (even if
it is latest published from Apple for this hardware).

espresso:~ jas$ gcc --version
powerpc-apple-darwin8-gcc-4.0.1 (GCC) 4.0.1 (Apple Computer, Inc. build 5370)
Copyright (C) 2005 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

espresso:~ jas$ 

/Simon

</body></email><email><emailId>20110828183146</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-08-28 18:31:46-0400</timestampReceived><subject>Re: RIPEMD-160 Implementation</subject><body>

Andres Mejia &lt;mcitadel@gmail.com&gt; writes:

&gt; Here's a patch that will implement RIPEMD-160 for nettle.

Checked in now, with just some renaming to use "ripemd160" as the prefix
for file names and symbols. I'd like to address the things I listed in a
previous mail before release.

I also added it to examples/nettle-benchmark, to guide the further
modifications.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110828183859</emailId><senderName>Andres Mejia</senderName><senderEmail>mcitadel@gmail.com</senderEmail><timestampReceived>2011-08-28 18:38:59-0400</timestampReceived><subject>Re: RIPEMD-160 Implementation</subject><body>

On Sat, Aug 27, 2011 at 5:19 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Andres Mejia &lt;mcitadel@gmail.com&gt; writes:
&gt;
&gt;&gt; I'm curious, why are the internal transform functions exposed to the public?
&gt;
&gt; As long as the compression function is only implemented in C, it can be
&gt; declared static and put in the same file as the _update and _final
&gt; functions which use it.
&gt;
&gt; But when the compression function is implemented in assembly for some
&gt; platforms (there's currently sha1 assembly for x86 and x86_64, and md5
&gt; assembly for x86), it's moved to a separate file, so that configure can
&gt; decide to link in an assembly file overriding the C version. And then
&gt; the function is exposed like any other global function (but with a name
&gt; starting with _nettle to indicate that it is internal).
&gt;
&gt; One could play with ELF visibility properties, but I haven't tried that
&gt; and it's not a general solution.

You could declare the prototype in a private header, rmd_private.h for example.

&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
&gt; Internet email is subject to wholesale government surveillance.
&gt;



-- 
Regards,
Andres Mejia

</body></email><email><emailId>20110828184117</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-08-28 18:41:17-0400</timestampReceived><subject>Re: RIPEMD-160 Implementation</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I think current gcc may recognize (x &lt;&lt; n) | (x &gt;&gt; (wordsize - n)) and
&gt; generate a rotate instruction (but I haven't tested).

Now I have tested. gcc 4.4.5 seems to recognize it, even without
optimization.

Test program:

  #include &lt;stdint.h&gt;
  
  uint32_t rot32(uint32_t x, int k)
  {
    return (x &lt;&lt; k) | (x &gt;&gt; (32-k));
  }
  
  uint32_t rot64(uint64_t x, int k)
  {
    return (x &lt;&lt; k) | (x &gt;&gt; (64-k));
  }
    
Compile with gcc -S -O0, and examine the generated assembler.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110827221443</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-08-27 22:14:43-0400</timestampReceived><subject>Re: make in freebsd</subject><body>

On 08/28/2011 12:06 AM, Niels Möller wrote:

&gt;&gt;   I tried to do a "./configure&amp;&amp;  make" in freebsd an got an error
&gt;&gt; during make. If I use GNU make instead it works. I attach the error
&gt;&gt; output from the make command and the generated Makefile.
&gt; I think the problem is that bsd make doesn't allow multiple files to b
&gt; listed for a single include command. If you want to use bsd make, you
&gt; have to configure with --disable-dependency-tracking. ./configure --help
&gt; says

Why don't you use automake for that? The automake generated makefiles
seem to be quite portable across different make programs.


regards,
Nikos

</body></email><email><emailId>20110823044939</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-08-23 04:49:39-0400</timestampReceived><subject>Re: Few Questions About Nettle Project</subject><body>

Andres Mejia &lt;mcitadel@gmail.com&gt; writes:

&gt; So here are some questions I have. GNU Nettle is going to stick with
&gt; LGPL-2.1+ correct?

At some point the license may be upgraded to LGPLv3. Or dual license
LGPLv3 and GPLv2+. The latter, more complex, alternative would be
helpful for you, right?

&gt; Another question, the only thing I see missing in nettle that
&gt; libarchive can make use of is RIPEMD-160. In case I want to submit
&gt; patches, I should submit them here correct?

Right.

&gt; Also, I suppose if I wanted to submit patches, there's no issue in
&gt; porting code from gcrypt over to nettle correct?

Copying code from libgcrypt is fine. In general, to make it as easy as possible to
integrate patches, it's nice if they include:

1. An authoritative reference for the implemented algorithm.

2. Test cases.

3. Documentation.

4. And then both interface and implementation should try to follow
   nettle conventions.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110824150815</emailId><senderName>Milan Broz</senderName><senderEmail>mbroz@redhat.com</senderEmail><timestampReceived>2011-08-24 15:08:15-0400</timestampReceived><subject>Re: Few Questions About Nettle Project</subject><body>

On 08/23/2011 04:51 AM, Andres Mejia wrote:
&gt; Another question, the only thing I see missing in nettle that
&gt; libarchive can make use of is RIPEMD-160. In case I want to submit
&gt; patches, I should submit them here correct? Also, I suppose if I
&gt; wanted to submit patches, there's no issue in porting code from gcrypt
&gt; over to nettle correct? I think it would be easier (and faster) to
&gt; reuse the implementation in gcrypt than to implement the algorithm
&gt; from scratch.

Btw cryptsetup uses ripemd160 if used in plain mode
(iow mode where encryption key is directly hashed password).
So despite cryptsetup has already optional Nettle crypto backend
support, is cannot provide backward compatibility without ripemd160.

So you have yet another user for these patches ;-)

Thanks,
Milan

</body></email><email><emailId>20110825141446</emailId><senderName>Andres Mejia</senderName><senderEmail>mcitadel@gmail.com</senderEmail><timestampReceived>2011-08-25 14:14:46-0400</timestampReceived><subject>Re: Few Questions About Nettle Project</subject><body>

On Tue, Aug 23, 2011 at 12:49 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Andres Mejia &lt;mcitadel@gmail.com&gt; writes:
&gt;
&gt;&gt; So here are some questions I have. GNU Nettle is going to stick with
&gt;&gt; LGPL-2.1+ correct?
&gt;
&gt; At some point the license may be upgraded to LGPLv3. Or dual license
&gt; LGPLv3 and GPLv2+. The latter, more complex, alternative would be
&gt; helpful for you, right?

So long as XBMC can remain GPLv2, then it's ok.

However, I'm sure there are some projects out there that could benefit
from an LGPLv2.1 crypto library. I looked around and so far have found
one, libaacs which is itself LGPLv2.1. libaacs is used indirectly by
XBMC, through libbluray. Currently, libaacs uses libgcrypt for crypto,
but it would be nice if the number of crypto libraries in use are kept
to a minimum.

&gt;&gt; Another question, the only thing I see missing in nettle that
&gt;&gt; libarchive can make use of is RIPEMD-160. In case I want to submit
&gt;&gt; patches, I should submit them here correct?
&gt;
&gt; Right.
&gt;
&gt;&gt; Also, I suppose if I wanted to submit patches, there's no issue in
&gt;&gt; porting code from gcrypt over to nettle correct?
&gt;
&gt; Copying code from libgcrypt is fine. In general, to make it as easy as possible to
&gt; integrate patches, it's nice if they include:
&gt;
&gt; 1. An authoritative reference for the implemented algorithm.
&gt;
&gt; 2. Test cases.
&gt;
&gt; 3. Documentation.
&gt;
&gt; 4. And then both interface and implementation should try to follow
&gt;   nettle conventions.
&gt;
&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
&gt; Internet email is subject to wholesale government surveillance.
&gt;



-- 
Regards,
Andres Mejia

</body></email><email><emailId>20110825174659</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-08-25 17:46:59-0400</timestampReceived><subject>Re: Few Questions About Nettle Project</subject><body>

Andres Mejia &lt;mcitadel@gmail.com&gt; writes:

&gt; On Tue, Aug 23, 2011 at 12:49 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:

&gt;&gt; At some point the license may be upgraded to LGPLv3. Or dual license
&gt;&gt; LGPLv3 and GPLv2+. The latter, more complex, alternative would be
&gt;&gt; helpful for you, right?
&gt;
&gt; So long as XBMC can remain GPLv2, then it's ok.
&gt;
&gt; However, I'm sure there are some projects out there that could benefit
&gt; from an LGPLv2.1 crypto library. I looked around and so far have found
&gt; one, libaacs which is itself LGPLv2.1. libaacs is used indirectly by
&gt; XBMC, through libbluray.

I have to look at this more closely before upgrading the license (which
I don't have any immediate plans of doing). I'm not sure, but I actually
don't see any obvious problem with linking LGPLv2 and LGPLv3 code
together.

The problem when linking GPLv2 and LGPLv3 code together is not that
LGPLv3 doesn't allow it (after all, LGPL, any version, allows linking
even with with proprietary code), but that GPLv2 requires that the
*entire* work (except system libraries) can be distributed under GPLv2,
with no additional restrictions, and some of the new conditions in
(L)GPLv3 (probably the ones related to drm or patents) are additional
restrictions.

And dual licensing as LGPLv3+ and GPLv2+ solves precisely that problem:
GPLv2 programs (including tivoized GPLv2 programs) can still use the
library under the GPLv2 conditions, while all other users of the
library, in particular, all proprietary applications, must abide by the
new conditions introduced in LGPLv3.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20111114223444</emailId><senderName>Anna Smith</senderName><senderEmail>anna@bit.ly</senderEmail><timestampReceived>2011-11-14 22:34:44-0400</timestampReceived><subject>Re: make issues</subject><body>

the link provided is broken :(  can you repost?

Niels Möller &lt;nisse@...&gt; writes:

&gt; You could try replacing config.guess with the latest version from
&gt; http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD,
&gt; and then run configure again.




</body></email><email><emailId>20111114230037</emailId><senderName>Coel May</senderName><senderEmail>coel@coelmay.com</senderEmail><timestampReceived>2011-11-14 23:00:37-0400</timestampReceived><subject>Re: make issues</subject><body>


it works ok for me.

try this one:
http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=master

or maybe try navigating from the config.git project root
http://git.savannah.gnu.org/gitweb/?p=config.git


On 15/11/2011, at 09:34 , Anna Smith wrote:

&gt; the link provided is broken :(  can you repost?
&gt; 
&gt; Niels Möller &lt;nisse@...&gt; writes:
&gt; 
&gt;&gt; You could try replacing config.guess with the latest version from
&gt;&gt; http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD,
&gt;&gt; and then run configure again.
&gt; 
&gt; 
&gt; 
&gt; _______________________________________________
&gt; nettle-bugs mailing list
&gt; nettle-bugs@lists.lysator.liu.se
&gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20110912115921</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-09-12 11:59:21-0400</timestampReceived><subject>Re: memxor</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; It seems that in x86-64 the ASM version is slower than the C one.

Hmm, that's different from what I have seen. This is what I get,
benchmarked on a 1.3 GHz Intel SU4100, by running
examples/nettle-benchmark -f 1.3e9 memxor.

C-implementation (compiled with gcc-4.4.5):

         Algorithm        mode Mbyte/s cycles/byte cycles/block
            memxor     aligned 4885.87        0.25         2.03
            memxor   unaligned 2771.14        0.45         3.58
           memxor3     aligned 4569.70        0.27         2.17
           memxor3 unaligned01 2528.03        0.49         3.92
           memxor3 unaligned11 2603.92        0.48         3.81
           memxor3 unaligned12 1496.87        0.83         6.63

x86_64 assembly:

         Algorithm        mode Mbyte/s cycles/byte cycles/block
            memxor     aligned 4895.18        0.25         2.03
            memxor   unaligned 3284.10        0.38         3.02
           memxor3     aligned 4890.66        0.25         2.03
           memxor3 unaligned01 3409.62        0.36         2.91
           memxor3 unaligned11 2697.37        0.46         3.68
           memxor3 unaligned12 2030.06        0.61         4.89

So no difference for the aligned case. I think two cycles per 64-bit
word ("block" above means unsigned long) is the memory bandwidth. While
for the different unaligned cases, the assembly version is a bit faster,
shaving off 0.5-2 cycles per word.

&gt; Moreover I noticed that the loop unrolling techniques used in the C
&gt; code have no visible performance benefit.

That's what I have seen as well. I keep the small amount of manual
unrolling for the benefit of other machines and/or compilers (but I'm
not sure where it really matters).

&gt; However, an SSE2 version of memxor (attached) increases performance by
&gt; 30% or more in the same CPU.

I'll have a look at that.

&gt; * SSE2:
&gt;         Xoring in chunks of 32768 bytes: done. 69.94 Gb in 5.00 secs:
&gt; 13.98 Gb/sec
&gt;         Xoring (unaligned) in chunks of 32768 bytes: done. 65.96 Gb in
&gt; 5.00 secs: 13.19 Gb/sec

I'm a bit puzzled by your results, I didn't expect any speedup with sse2
instructions for the aligned case. What machine are you benchmarking on?

I'm also not quite sure what's the right way to think about memory
bandwidth. nettle-benchmark uses blocks of 10 KByte and processes the
same block repeatedly, which means that it ought to fit in L1 (or at
least L2) cache.

Regards,
/nisse

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110912124320</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2011-09-12 12:43:20-0400</timestampReceived><subject>Re: memxor</subject><body>

On Mon, Sep 12, 2011 at 1:59 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

(2nd reply on list)

&gt;&gt; It seems that in x86-64 the ASM version is slower than the C one.
&gt; Hmm, that's different from what I have seen. This is what I get,
&gt; benchmarked on a 1.3 GHz Intel SU4100, by running
&gt; examples/nettle-benchmark -f 1.3e9 memxor.

The CPU reports itself as Intel(R) Xeon(R) CPU X5670  @ 2.93GHz (the
system has 24 such cpus). The output of nettle-benchmark on that
machine follows.

x86-64 assembly:
[nikos@koninck examples]$ ./nettle-benchmark -f 1.3e9 memxor
sha1_compress: 463.00 cycles

benchmark call overhead: 0.001871 us   2.43 cycles

        Algorithm        mode Mbyte/s cycles/byte cycles/block
           memxor     aligned 11887.63        0.10         0.83
           memxor   unaligned 11194.60        0.11         0.89
          memxor3     aligned 11863.08        0.10         0.84
          memxor3 unaligned01 11167.71        0.11         0.89
          memxor3 unaligned11 6479.55        0.19         1.53
          memxor3 unaligned12 10540.27        0.12         0.94

C-implementation (gcc-4.1.2):
[nikos@koninck nettle-2.4]$ examples/nettle-benchmark -f 1.3e9 memxor
sha1_compress: 463.30 cycles

benchmark call overhead: 0.001872 us   2.43 cycles

        Algorithm        mode Mbyte/s cycles/byte cycles/block
           memxor     aligned 11854.78        0.10         0.84
           memxor   unaligned 11186.80        0.11         0.89
          memxor3     aligned 11896.14        0.10         0.83
          memxor3 unaligned01 11169.13        0.11         0.89
          memxor3 unaligned11 6437.96        0.19         1.54
          memxor3 unaligned12 10485.28        0.12         0.95

I see no big difference between them. However the results we see from
my and your benchmark vary. How do you benchmark? What is ncalls in
time_function()?

My benchmark is simplistic, it counts speed, number of memxors in a
fixed amount of time.

&gt;&gt; Moreover I noticed that the loop unrolling techniques used in the C
&gt;&gt; code have no visible performance benefit.
&gt; That's what I have seen as well. I keep the small amount of manual
&gt; unrolling for the benefit of other machines and/or compilers (but I'm
&gt; not sure where it really matters).

My personal preference would have been cleaner code.

&gt; I'm also not quite sure what's the right way to think about memory
&gt; bandwidth. nettle-benchmark uses blocks of 10 KByte and processes the
&gt; same block repeatedly, which means that it ought to fit in L1 (or at
&gt; least L2) cache.

I saw no differences in my benchmark when I decreased the buffer to 10k.

regards,
Nikos

</body></email><email><emailId>20110912170303</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-09-12 17:03:03-0400</timestampReceived><subject>Re: memxor</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; The CPU reports itself as Intel(R) Xeon(R) CPU X5670  @ 2.93GHz (the
&gt; system has 24 such cpus). The output of nettle-benchmark on that
&gt; machine follows.
&gt;
&gt; x86-64 assembly:
&gt; [nikos@koninck examples]$ ./nettle-benchmark -f 1.3e9 memxor

To get the printed cycle numbers to make sense, you have to pass the
correct clock frequency to the -f option. -f 2.93e9 in your case.

&gt; However the results we see from my and your benchmark vary.

Right, we'll have to figure out why. I'm puzzled.

&gt; How do you benchmark? What is ncalls in time_function()?

time_function loops around the benchmarked function ncalls times, and
reads the clock before and after the loop. Qnd then, if the elapsed time
was too short, it increases ncalls and starts over.

&gt; My benchmark is simplistic, it counts speed, number of memxors in a
&gt; fixed amount of time.

I guess that should be good enough. I'm not so familiar with SIGALARM,
but I don't seen anything obviously wrong with it.

&gt;&gt; That's what I have seen as well. I keep the small amount of manual
&gt;&gt; unrolling for the benefit of other machines and/or compilers (but I'm
&gt;&gt; not sure where it really matters).
&gt;
&gt; My personal preference would have been cleaner code.

Well, for the unaligned case, the unrolling is also a natural way to
avoid moving values between s1 and s0, which I think is nice.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110913081405</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2011-09-13 08:14:05-0400</timestampReceived><subject>Re: memxor</subject><body>

On Mon, Sep 12, 2011 at 7:03 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; To get the printed cycle numbers to make sense, you have to pass the
&gt; correct clock frequency to the -f option. -f 2.93e9 in your case.
&gt;&gt; However the results we see from my and your benchmark vary.
&gt; Right, we'll have to figure out why. I'm puzzled.

It seems --disable-assembler doesn't work for memxor. That is the
figures were so similar with nettle-benchmark because only assembler
was used. To be honest I've not understood how the assembler thing
works so I am not able to disable it even manually.

regards,
Nikos

</body></email><email><emailId>20110913091019</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2011-09-13 09:10:19-0400</timestampReceived><subject>Re: memxor</subject><body>

On Tue, Sep 13, 2011 at 10:14 AM, Nikos Mavrogiannopoulos
&lt;n.mavrogiannopoulos@gmail.com&gt; wrote:

Corrected figures for nettle-benchmark. My previous issue seems to
have been because a new ./configure doesn't really undo the previous
settings. SSE is faster than the previous implementations (asm or C),
but ASM performs better than C in the unaligned case. I cannot figure
out why my benchmark shows otherwise (our unaligned test seem to be
pretty much identical). I include the overhead that you subtract, but
seems to be identical in both cases.

* ASM
benchmark call overhead: 0.001862 us   5.46 cycles

         Algorithm        mode Mbyte/s cycles/byte cycles/block
            memxor     aligned 11980.56        0.23         1.87
            memxor   unaligned 11269.30        0.25         1.98

* C implementation:
benchmark call overhead: 0.001875 us   5.49 cycles

         Algorithm        mode Mbyte/s cycles/byte cycles/block
            memxor     aligned 11777.25        0.24         1.90
            memxor   unaligned 7794.15        0.36         2.87

* SSE2
benchmark call overhead: 0.001868 us   5.47 cycles

         Algorithm        mode Mbyte/s cycles/byte cycles/block
            memxor     aligned 15961.09        0.18         1.40
            memxor   unaligned 15882.32        0.18         1.41


regards,
Nikos

</body></email><email><emailId>20110913093358</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-09-13 09:33:58-0400</timestampReceived><subject>Re: memxor</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; It seems --disable-assembler doesn't work for memxor.

Maybe you forgot to run make distclean? You should do that whenever you
change any interesting configure options.

I usually don't build in the source directory, and than I can have
multiple build directories configured with different options. Currently
I have build trees with plain ./configure, ./configure
--disable-assembler, ./configure --enable-shared, and ./configure
CC="gcc -m32" CXX="g++ -m32".

&gt; To be honest I've not understood how the assembler thing works so I am
&gt; not able to disable it even manually.

I'll try to explain. It's not very complicated.

./configure looks for certain files in the appropriate machine-specific
directory, and creates symlinks in the top-level nettle build directory.
Then if make needs to build foo.o, and it can find both foo.c and
foo.asm, by the order of the suffix list, it will use the foo.asm file.

The rule to build foo.o from foo.asm first runs m4 to produce foo.s, and
then invokes the compiler $(CC) -c ... on foo.s.

The symlinks are created by config.status (which is also run at the end
of ./configure), and deleted by make distclean. If you create or delete
any links by hand, make will follow.

The setup is inspired by gmp. If you look at what gmp does, there are
two main differences:

 1. There's hierarchy of machine specific directories for different
    flavors of the same architecture, and configure searches in multiple
    directories.

 2. It doesn't rely on make ordering the suffix list. Instead, it puts
    all C files in the "mpn/generic" subdirectory, and creates symlinks
    also for the portable C files.

And then gmp also has the possibility of creating a fat binary,
including optimized code for all different flavors of the given
architecture.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110913103954</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2011-09-13 10:39:54-0400</timestampReceived><subject>Re: memxor</subject><body>


On Tue, Sep 13, 2011 at 11:33 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:

&gt;&gt; It seems --disable-assembler doesn't work for memxor.
&gt; Maybe you forgot to run make distclean? You should do that whenever you
&gt; change any interesting configure options.

Indeed. I've now figured out. It would be also better if configure.ac
was self contained.  If I modify it and run autoconf I get:
configure.ac:366: warning: AC_LANG_CONFTEST: no AC_LANG_SOURCE call
detected in body
autoconf/lang.m4:198: AC_LANG_CONFTEST is expanded from...
autoconf/general.m4:2599: _AC_COMPILE_IFELSE is expanded from...
autoconf/general.m4:2609: AC_COMPILE_IFELSE is expanded from...
../../lib/m4sugar/m4sh.m4:610: AS_IF is expanded from...
autoconf/general.m4:2047: AC_CACHE_VAL is expanded from...
autoconf/general.m4:2060: AC_CACHE_CHECK is expanded from...
configure.ac:366: the top level

if I run .bootstrap from the lsh dir it succeeds but running configure
prints the warnings below and make fails.
checking malloc.h presence... no
configure: WARNING: malloc.h: accepted by the compiler, rejected by
the preprocessor!
configure: WARNING: malloc.h: proceeding with the compiler's result

Anyway, I attach an untested patch that shows how SSE2 or other cpu
version specific optimizations can be enabled at run-time.

regards,
Nikos


</body></email><email><emailId>20110913111734</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-09-13 11:17:34-0400</timestampReceived><subject>Re: memxor</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; if I run .bootstrap from the lsh dir it succeeds but running configure
&gt; prints the warnings below and make fails.

Strange. I'm not sure what the warnings mean, but make definitely
shouldn't fail. I take it you have checked it out from cvs? Exactly what
did you do? I'd expect the following to work:

  cvs ... co lsh
  cd lsh
  ./.bootstrap
  cd nettle
  ./configure
  make
 
Then you shouldn't need to bother about the lsh directory again. You
have a symlink to the shared aclocal.m4 (and to some other shared
files).

&gt; Anyway, I attach an untested patch that shows how SSE2 or other cpu
&gt; version specific optimizations can be enabled at run-time.

Thanks. I'll have to think some more on how to organize this. Some
properties I'd like to have:

1. Don't require users to call any init function.

   One could define memxor to jump via a function pointer, and have an
   initial value for that pointer which jumps to the routine to set the
   pointer to the right function, and then use it. Overwriting the
   pointer should be atomic, so no locking needed even for multithreaded
   programs.

   Or for library formats that support that, hook in the initialization
   in the same way as C++ constructors for global data.

2. Have configure options like

   --enable-x86-sse2/--disable-x86-sse2

   which omits that wrapper function and its function pointer.

3. Avoid using gcc-specific things, including inline asm, in the C
   source files.

Other obvious uses for cpu detection in nettle:

  * The AES code could check for the special aes instructions.

  * The serpent code can use %xmm and %ymm registers, when present. On
    x86_64, as far as I'm aware all current implementations have sse2,
    but one could check for, and make use of, the 256-bit %ymm
    registers.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110913124108</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2011-09-13 12:41:08-0400</timestampReceived><subject>memxor</subject><body>


On Tue, Sep 13, 2011 at 1:17 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:

&gt; Then you shouldn't need to bother about the lsh directory again. You
&gt; have a symlink to the shared aclocal.m4 (and to some other shared
&gt; files).

Ok I figured out. I attach a working SSE2 detection.

&gt; Thanks. I'll have to think some more on how to organize this. Some
&gt; properties I'd like to have:
&gt; 1. Don't require users to call any init function.
&gt;    One could define memxor to jump via a function pointer, and have an
&gt;    initial value for that pointer which jumps to the routine to set the
&gt;    pointer to the right function, and then use it. Overwriting the
&gt;    pointer should be atomic, so no locking needed even for multithreaded
&gt;    programs.

I don't think locking is an issue if you only call a function on
initialization. You can expect (and require) that a library isn't
going to be initialized by multiple threads. I don't know however of a
portable way to do initialization transparently without an explicit
function call.

&gt; 3. Avoid using gcc-specific things, including inline asm, in the C
&gt;    source files.

The cpuid test would have then to be moved to an assembly file.

&gt; Other obvious uses for cpu detection in nettle:
&gt;   * The AES code could check for the special aes instructions.

Indeed. Once a framework for overwriting functionality is set, those would
be not very hard to add. However setting such framework in nettle seems to
require substantial work as all exported functions need to be replaced by
function pointers thus breaking ABI. If this is done gradually (it has
to, as you
never know what you would be able to optimize in a new processor) it would
be worse, since every optimization added would break ABI.

Maybe it makes sense to have a libgcrypt-like high level interface and
optimizations
would be used only there. The existing C api remains an API to access
the C implementation.
This could also address the problem with optimized hash algorithms[0],
since most cpu-assisted
sha1 or sha256 implementations work on an output=hash(data,length)
basis and do not map
to the existing API.

[0]. http://www.mail-archive.com/openssl-dev@openssl.org/msg21787.html

&gt;   * The serpent code can use %xmm and %ymm registers, when present. On
&gt;      x86_64, as far as I'm aware all current implementations have sse2,
&gt;      but one could check for, and make use of, the 256-bit %ymm
&gt;      registers.

I wouldn't care of serpent optimizations much :)

regards,
Nikos


</body></email><email><emailId>20110913135658</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-09-13 13:56:58-0400</timestampReceived><subject>Re: memxor</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; I don't know however of a portable way to do initialization
&gt; transparently without an explicit function call.

It works for gmp. Which doesn't imply that we should do it in exactly
the same way, of course.

&gt; The cpuid test would have then to be moved to an assembly file.

Right.

&gt; Indeed. Once a framework for overwriting functionality is set, those would
&gt; be not very hard to add. However setting such framework in nettle seems to
&gt; require substantial work as all exported functions need to be replaced by
&gt; function pointers thus breaking ABI.

I don't think the function pointers should be exported. If "fat" library
is enabled (default for x86), then the exported function should be

  void memxor (...)
  {
    (*memxor_p)(...);
  }

I think one should have the possibility to choose between fat and
non-fat builds, with the same ABI. There's going to be a small extra
call overhead in the fat case.

As long as all implementations can use the same ctx structs, there
should be no problem with the ABI. If we also want to support hardware
acelerators which are like black boxes, then some API and or ABI changes
may be necessary.

&gt; I wouldn't care of serpent optimizations much :)

I'm not surprised ;-) But on processors which lack aes-instructions, but
which have 256-bit %ymm-registers, serpent can most likely be twice as
fast as aes if used in ctr mode (for the current code with 128-bit
%xmm-registers, serpent speed was somewhere between aes-128 and aes-192
last time I measured).

/nisse

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110913164651</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2011-09-13 16:46:51-0400</timestampReceived><subject>Re: memxor</subject><body>

On 09/13/2011 03:56 PM, Niels Möller wrote:

&gt;&gt; Indeed. Once a framework for overwriting functionality is set, those would
&gt;&gt; be not very hard to add. However setting such framework in nettle seems to
&gt;&gt; require substantial work as all exported functions need to be replaced by
&gt;&gt; function pointers thus breaking ABI.
&gt; I don't think the function pointers should be exported. If "fat" library
&gt; is enabled (default for x86), then the exported function should be
&gt;
&gt;    void memxor (...)
&gt;    {
&gt;      (*memxor_p)(...);
&gt;    }
&gt; I think one should have the possibility to choose between fat and
&gt; non-fat builds, with the same ABI. There's going to be a small extra
&gt; call overhead in the fat case.

Disabling the optional architectures would be possible but reducing the
call overhead in the "thin" case would require a lot of ifdefs. It would 
keep the external api intact, but the internals would look ugly.

&gt; As long as all implementations can use the same ctx structs, there
&gt; should be no problem with the ABI. If we also want to support hardware
&gt; acelerators which are like black boxes, then some API and or ABI changes
&gt; may be necessary.

This is not guaranteed. For example AES-NI and padlock require the
AES key to be aligned to 16-byte boundaries, something that the
current structures do not offer.

&gt;&gt; I wouldn't care of serpent optimizations much :)
&gt; I'm not surprised ;-) But on processors which lack aes-instructions, but
&gt; which have 256-bit %ymm-registers, serpent can most likely be twice as
&gt; fast as aes if used in ctr mode (for the current code with 128-bit
&gt; %xmm-registers, serpent speed was somewhere between aes-128 and aes-192
&gt; last time I measured).

Why not use camellia as an alternative? It is newer design than serpent
and is pretty much standardized as the aes alternative.

In any case, I just noticed that for the x86-64 you don't really need to 
detect SSE2, it is just there by default. So maybe the SSE2 xor can just 
replace the x86-64 xor. For the plain x86 though this is not the case.

regards,
Nikos

PS. The ECC patch just got very low in my priority stack. If anyone else 
is interested into porting it to nettle, he would make me a favor.

</body></email><email><emailId>20111026083045</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-10-26 08:30:45-0400</timestampReceived><subject>Re: _nettle_write_be32</subject><body>

On Wed, Oct 26, 2011 at 10:16 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:

&gt;&gt; It is a useful function and can be used on the accelerated versions of
&gt;&gt; SHA in architectures that support it (i.e. VIA cpus).
&gt; BTW, how does that acceleration work? Would it be possible/practical to
&gt; write a function matching the current _nettle_sha1_compress.

The new VIA CPUs (e.g. nano) provide the compression function, i.e.
the fourth argument in MD_UPDATE. Older models (C5,C7) provide a full
compression functionality. I.e. sha1(x) and you get the result, which
proved not to be entirely useful.

&gt;&gt; btw. the MD_* macros were also proved to be very useful in that case.
&gt; These macros are really intended for internal use only. I'd prefer to
&gt; not export any interfaces like that. If functionality like this should
&gt; be exported at all, I'd be more comfortable with a function interface
&gt; for doing these things.

Aren't they already exported in macros.h?

regards,
Nikos

</body></email><email><emailId>20111026092124</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-10-26 09:21:24-0400</timestampReceived><subject>Re: _nettle_write_be32</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Aren't they already exported in macros.h?

It seems you're right, in that macros.h is actually installed in
$includedir/nettle (unlike, e.g., nettle-internal.h). I must have
forgotten that when I put the MD_* definitions in that file... In any
case, they're undocumented, and I won't promise any backwards
compatibility in future versions.

Maybe the internal-use things in macros.h ought to be moved to some
uninstalled *-internal.h file. The *READ_* and *WRITE_* macros should
stay in macros.h, but everything else there is a bit questionable.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110717150643</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-07-17 15:06:43-0400</timestampReceived><subject>Re: gcm crash on ppc</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Did you solve this problem? To me it seems like it could be
&gt;
&gt; * setup of the shared-library magic, for this particular object file,
&gt;   somehow broken.
&gt;
&gt; * bugs in the macos port of gcc (I don't know if you use apples "xcode"
&gt;   or some other gcc port, and I don't really know the difference
&gt;   either). According to the gmp people, there have been *lots* of
&gt;   problems with apple's linker and maybe also with other related tools.
&gt;
&gt; * some other random hardware or software problem.

Several people have reported a bug of the first type: in
nettle-internal.h, the const structs nettle_gcm_* ought to be declared
extern. I guess I will have to issue a bugfix release soon. I.e., 

-const struct nettle_aead nettle_gcm_aes128;
+extern const struct nettle_aead nettle_gcm_aes128;

etc.

Fix checked in now. Simon: It would be nice if you could test if this
also solves the ppc problem.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110720210716</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-07-20 21:07:16-0400</timestampReceived><subject>pkg-config</subject><body>

I just checked in nettle.pc.in and hogweed.pc.in. configure then
generates nettle.pc and hogweed.pc, for use wiith pkg-config.

I don't have any previous experience with pkg-config, so comments are
much appreciated.

Not yet any make rules to install them. I don't know if installation
should be unconditional, or if one should first check, somehow, if
pkg-config is installed. (And then hogweed.pc should be installed only if the
hogweed library is built and installed).

Apparantly, at least one user wants pkg-config support, see
http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=634294

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20110608092444</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2011-06-08 09:24:44-0400</timestampReceived><subject>Re: patch to fix build of nettle on gcc-2.95 architectures</subject><body>

On Wed, Jun 8, 2011 at 11:18 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt;&gt; I found nettle not compiling on openbsd sparc architecture which uses
&gt;&gt; gcc-2.95 as default compiler. Attached little patch against nettle-2.1
&gt;&gt; fixes the compilation problem for me.
&gt; Thanks, checked in now. Nettle is not supposed to rely on c99 features.

These things make you feel really old. I still remember the time where C99
was a new thing, but now it's already 12 years old.

regards,
Nikos

</body></email><email><emailId>20110613145721</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-06-13 14:57:21-0400</timestampReceived><subject>Re: rsa keygen replicability</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; I've actually found that yarrow256 itself *is* repeatable across nettle
&gt; versions (well, 2.0 → 2.1 at least);

That's intended (but not promised). Makes regression testing easier.

There have been one incompatible change to yarrow in recent years,
related to seedfile management. (See ChangeLog for 2008-10-24 -- 2008-10-31).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110615204904</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-06-15 20:49:04-0400</timestampReceived><subject>Re: release?</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt;  * Fix the libdir defaults for linux x86_64 (I think the following
&gt;    should work in most cases for for both debian and fhs conventions:
&gt;    When building for $ABI (32 or 64), check if /usr/lib$ABI exists. If
&gt;    so, install there, otherwise in $prefix/lib. Possibly bail out with
&gt;    an error if neither /usr/lib32 nor /usr/lib64 exists).

I've checked in a fix for this now, and I also wrote up a web page with
the release TODO list (organization copied from corresponding pages for
recent GMP releases). See
http://www.lysator.liu.se/~nisse/nettle/plan.html

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110630193154</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-06-30 19:31:54-0400</timestampReceived><subject>Re: gcm crash on ppc</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; What is fishy is that nettle_gcm_aes128 doesn't seem to have been
&gt; initialized properly:

Did you solve this problem? To me it seems like it could be

* setup of the shared-library magic, for this particular object file,
  somehow broken.

* bugs in the macos port of gcc (I don't know if you use apples "xcode"
  or some other gcc port, and I don't really know the difference
  either). According to the gmp people, there have been *lots* of
  problems with apple's linker and maybe also with other related tools.

* some other random hardware or software problem.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110630215451</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2011-06-30 21:54:51-0400</timestampReceived><subject>Re: serpent on x86_64, using sse2 instructions</subject><body>

On Thu, Jun 30, 2011 at 10:21 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:

&gt; It's conceivable that one can use simd instructions to get some speedup
&gt; also for aes and camellia, but it's not going to be almost trivial like
&gt; it is for serpent. (And for aes, I don't yet have any code using the
&gt; special instructions available in newer x86_64 processors).

In gnutls we use Andy Polyakov's code. It can be found at:

(AES-NI) http://cvs.openssl.org/dir?d=openssl/crypto/aes/asm

(AES-GCM) http://cvs.openssl.org/dir?d=openssl/crypto/modes/asm

Its license is LGPL compatible.

regards,
Nikos

</body></email><email><emailId>20110630223702</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-06-30 22:37:02-0400</timestampReceived><subject>Fwd: Problem compiling gnutls 2.12.7 on Solaris 9</subject><body>

Hello Niels,
 nettle-stdint.h conflicts with gnulib's stdint.h on solaris. Is there
any real reason for nettle to define the uint_t types in the exported
API? Even if it wasn't for gnulib I would expect most applications
to define those types if not available, thus a conflict would anyway occur.


---------- Forwarded message ----------
From: Dagobert Michelsen &lt;dam@opencsw.org&gt;
Date: Wed, Jun 29, 2011 at 5:10 PM
Subject: Problem compiling gnutls 2.12.7 on Solaris 9
To: gnutls-devel@gnu.org


Hi,

I am trying to compile gnutls 2.12.7 with libnettle 2.1 on Solaris 9 Sparc =
with
Sun Studio 12 and get the following error:

gmake[6]: Entering directory
`/home/dam/mgar/pkg/gnutls/trunk/work/solaris9-sparc/build-isa-sparcv8/gnut=
ls-2.12.7/lib/nettle'
=C2=A0CC =C2=A0 =C2=A0 pk.lo
"/opt/csw/include/nettle/nettle-stdint.h", line 237: identifier
redeclared: gl_int_fast8_t
=C2=A0 =C2=A0 =C2=A0 =C2=A0current : signed char
=C2=A0 =C2=A0 =C2=A0 =C2=A0previous: long : "./../gl/stdint.h", line 241
"/opt/csw/include/nettle/nettle-stdint.h", line 238: warning:
modification of typedef with "int" ignored
"/opt/csw/include/nettle/nettle-stdint.h", line 238: identifier
redeclared: gl_int_fast16_t
=C2=A0 =C2=A0 =C2=A0 =C2=A0current : int
=C2=A0 =C2=A0 =C2=A0 =C2=A0previous: long : "./../gl/stdint.h", line 243
"/opt/csw/include/nettle/nettle-stdint.h", line 239: warning:
modification of typedef with "int" ignored
"/opt/csw/include/nettle/nettle-stdint.h", line 239: identifier
redeclared: gl_int_fast32_t
=C2=A0 =C2=A0 =C2=A0 =C2=A0current : int
=C2=A0 =C2=A0 =C2=A0 =C2=A0previous: long : "./../gl/stdint.h", line 245
"/opt/csw/include/nettle/nettle-stdint.h", line 241: warning: typedef
redeclared: int64_t
"/opt/csw/include/nettle/nettle-stdint.h", line 244: identifier
redeclared: gl_uint_fast8_t
=C2=A0 =C2=A0 =C2=A0 =C2=A0current : unsigned char
=C2=A0 =C2=A0 =C2=A0 =C2=A0previous: unsigned long : "./../gl/stdint.h", li=
ne 242
"/opt/csw/include/nettle/nettle-stdint.h", line 245: identifier
redeclared: gl_uint_fast16_t
=C2=A0 =C2=A0 =C2=A0 =C2=A0current : unsigned int
=C2=A0 =C2=A0 =C2=A0 =C2=A0previous: unsigned long : "./../gl/stdint.h", li=
ne 244
"/opt/csw/include/nettle/nettle-stdint.h", line 246: identifier
redeclared: gl_uint_fast32_t
=C2=A0 =C2=A0 =C2=A0 =C2=A0current : unsigned int
=C2=A0 =C2=A0 =C2=A0 =C2=A0previous: unsigned long : "./../gl/stdint.h", li=
ne 246
"/opt/csw/include/nettle/nettle-stdint.h", line 248: warning: typedef
redeclared: uint64_t
cc: acomp failed for pk.c

It looks like a gnulib incompatibility.


Best regards

=C2=A0-- Dago


--
"You don't become great by trying to be great, you become great by
wanting to do something,
and then doing it so hard that you become great in the process." - xkcd #89=
6


_______________________________________________
Gnutls-devel mailing list
Gnutls-devel@gnu.org
https://lists.gnu.org/mailman/listinfo/gnutls-devel

</body></email><email><emailId>20110506121023</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-05-06 12:10:23-0400</timestampReceived><subject>Re: Fwd: Problem with nettle 2.1 and gnutls 2.12.3 on Solaris</subject><body>

Dagobert Michelsen &lt;dam@baltic-online.de&gt; writes:

&gt;&gt; I am trying to compile gnutls 2.12.3 with libnettle 2.1 and get the
&gt;&gt; following errors. From the output I assume an incompatibility between
&gt;&gt; different gnulib inclusions.

For the record, nettle does not use gnulib. It uses AX_CREATE_STDINT_H,
iirc I copied that from autoconf-archive, long ago.

&gt;&gt; "/opt/csw/include/nettle/nettle-stdint.h", line 237: identifier redeclared: gl_int_fast8_t
&gt;&gt;        current : signed char
&gt;&gt;        previous: long : "./../gl/stdint.h", line 241

This is puzzling. On Solaris, nettle-stdint.h is expected to contain

  /* generated using gnu compiler gcc (GCC) 3.4.5 */
  #define _STDINT_HAVE_STDINT_H 1
  
  /* ................... shortcircuit part ........................... */
  
  #if defined HAVE_STDINT_H || defined _STDINT_HAVE_STDINT_H
  #include &lt;stdint.h&gt;
  #else
  ... lots of irrelevant stuff...
  #endif

And there seems to be a /usr/include/stdint.h on the system I look, so I
don't think it's a gcc-specific include file. What does your
nettle-stdin.h look like? If it is different, something went wrong at
configure time when nettle was installed..

And what is "./../gl/stdint.h", that's from gnulib? nettle-stdint.h does
not refer gl_int_fast8_t as far as I can see, so I guess there's a
#define int_fast8_t gl_int_fast8_t somewhere.

The failures seem to all be related to the various *_fast_*_t type,
where the spec leaves a lot of room for the implementation. So if
different packages defines these them selves, it's not very surprising
that they might have different ideas about what they should be. But in
the Solaris case, the right thing is most likely to use the definitions
from /usr/include/stdint.h, and *no* others. I haven't looked at gnulib,
but I *hope* it has some short-circuit code like in nettle-stdint.h, to
fall back to the system's stdint.h or inttypes.h if one of them exists
and works.

/Niels

PS. Sorry the nettle-bugs list is members only, if you want to reply and
are not on that list, please use my personal address instead of
nettle-bugs@lists.lysator.liu.se.

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110521105217</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-05-21 10:52:17-0400</timestampReceived><subject>Re: memory leak fix</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; The attached patch fixes a memory leak in DSA key generation.

Thanks, checked in now.

/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110530180759</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-05-30 18:07:59-0400</timestampReceived><subject>Re: ECC</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I thought the GPL part applies only to the parts that are GPL and not to
&gt; the whole library. 

The manual says the following:

  Nettle is distributed under the GNU General Public License (GPL) (see
  the file COPYING for details). However, most of the individual files
  are dual licensed under less restrictive licenses like the GNU Lesser
  General Public License (LGPL), or are in the public domain. This means
  that if you don't use the parts of nettle that are GPL-only, you have
  the option to use the Nettle library just as if it were licensed under
  the LGPL. To find the current status of particular files, you have to
  read the copyright notices at the top of the files.

Things will get simpler once the serpent code is replaced.

&gt; In any case would you suggest gnutls using nettle a la lsh, i.e.
&gt; include it as a static library? That way we can eliminate licensing
&gt; issues by removing the GPL parts.

My understanding is that as long as gnutls doesn't use the serpent code
(the only remaining GPL-only feature) and has no references to it, it's
ok no matter if you use static or dynamic linking. You can pretend that
the serpent code was never built and included into the library.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110530204716</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-05-30 20:47:16-0400</timestampReceived><subject>serpent again (was: Re: ECC)</subject><body>

I looked at reviving my serpent port from libgcrypt.  As a first step in
testing it, it would help if Nettle had the same test vector as
libgcrypt.  Please consider this patch.

/Simon

2011-05-30  Simon Josefsson  &lt;simon@josefsson.org&gt;

	* testsuite/serpent-test.c (test_main): Add test vectors from
	libgcrypt.

--- serpent-test.c.~1.3.~	2011-05-20 23:02:54.000000000 +0200
+++ serpent-test.c	2011-05-30 22:46:50.837183923 +0200
@@ -25,6 +25,26 @@
 int
 test_main(void)
 {
+  /* From libgcrypt */
+  test_cipher(&amp;nettle_serpent128,
+	      HL("0000000000000000 0000000000000000"),
+	      HL("D29D576FCEA3A3A7 ED9099F29273D78E"),
+	      H("B2288B968AE8B086 48D1CE9606FD992D"));
+  test_cipher(&amp;nettle_serpent192,
+	      HL("0000000000000000 0000000000000000 0000000000000000"),
+	      HL("D29D576FCEABA3A7 ED9899F2927BD78E"),
+	      H("130E353E1037C224 05E8FAEFB2C3C3E9"));
+  test_cipher(&amp;nettle_serpent256,
+	      HL("0000000000000000 0000000000000000"
+		 "0000000000000000 0000000000000000"),
+	      HL("D095576FCEA3E3A7 ED98D9F29073D78E"),
+	      H("B90EE5862DE69168 F2BDD5125B45472B"));
+  test_cipher(&amp;nettle_serpent256,
+	      HL("0000000000000000 0000000000000000"
+		 "0000000000000000 0000000000000000"),
+	      HL("0000000001000000 0200000003000000"),
+	      H("2061A42782BD52EC 691EC383B03BA77C"));
+
   /* The first test for each key size from the ecb_vk.txt and ecb_vt.txt
    * files in the serpent package. */
 
 

</body></email><email><emailId>20110530214753</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-05-30 21:47:53-0400</timestampReceived><subject>gcm crash on ppc (was: Re: serpent again)</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; (However, the 'gcm' self test crashed on PPC.)

Here is a backtrace.

espresso:~/nettle-2.2/testsuite jas$ gdb ./gcm-test
GNU gdb 6.3.50-20050815 (Apple version gdb-696) (Sat Oct 20 18:20:28 GMT 2007)
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "powerpc-apple-darwin"...
warning: --arch option not supported in this gdb.
Reading symbols for shared libraries .. done

(gdb) b main
Breakpoint 1 at 0x3ddc: file testutils.c, line 149.
(gdb) r
Starting program: /Users/jas/nettle-2.2/testsuite/gcm-test 
Reading symbols for shared libraries . done

Breakpoint 1, main (argc=1, argv=0xbffffb34) at testutils.c:149
149	  if (argc &gt; 1)
(gdb) c
Continuing.

Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_PROTECTION_FAILURE at address: 0x00000000
0x00000000 in ?? ()
(gdb) bt
#0  0x00000000 in ?? ()
Cannot access memory at address 0x0
Cannot access memory at address 0x0
Cannot access memory at address 0x0
Cannot access memory at address 0x0
Cannot access memory at address 0x0
#1  0x000049f0 in test_aead (aead=Cannot access memory at address 0x0
Cannot access memory at address 0x0
Cannot access memory at address 0x0
Cannot access memory at address 0x0
Cannot access memory at address 0x0
Cannot access memory at address 0x0
0x80f0, key_length=16, key=0x3000f0 "", auth_length=0, authtext=0x300100 "", \
length=0, cleartext=0x300110 "", ciphertext=0x300120 "", iv_length=12, iv=0x300130 \
"", digest=0x300140 "X����~0a6\035W��EZ") at testutils.c:384 Cannot \
access memory at address 0x0 #2  0x000029ec in test_main () at gcm-test.c:14
Cannot access memory at address 0x0
Cannot access memory at address 0x0
Cannot access memory at address 0x0
#3  0x00003e30 in main (argc=1, argv=0xbffffb34) at testutils.c:161
(gdb) 

What is fishy is that nettle_gcm_aes128 doesn't seem to have been
initialized properly:

espresso:~/nettle-2.2/testsuite jas$ gdb ./gcm-test
GNU gdb 6.3.50-20050815 (Apple version gdb-696) (Sat Oct 20 18:20:28 GMT 2007)
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "powerpc-apple-darwin"...
warning: --arch option not supported in this gdb.
Reading symbols for shared libraries .. done

(gdb) p nettle_gcm_aes128
$1 = {
  name = 0x0, 
  context_size = 0, 
  block_size = 0, 
  key_size = 0, 
  set_key = 0, 
  set_iv = 0, 
  update = 0, 
  encrypt = 0, 
  decrypt = 0, 
  digest = 0
}
(gdb) 

Even stranger is that it is defined properly in other tests:

espresso:~/nettle-2.2/testsuite jas$ gdb ./blowfish-test
GNU gdb 6.3.50-20050815 (Apple version gdb-696) (Sat Oct 20 18:20:28 GMT 2007)
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "powerpc-apple-darwin"...
warning: --arch option not supported in this gdb.
Reading symbols for shared libraries .. done

(gdb) p nettle_gcm_aes128
$1 = {
  name = 0xfabc "gcm-aes128", 
  context_size = 4404, 
  block_size = 16, 
  key_size = 16, 
  set_key = 0xc308 &lt;nettle_gcm_aes_set_key&gt;, 
  set_iv = 0xc37c &lt;nettle_gcm_aes_set_iv&gt;, 
  update = 0xc3d4 &lt;nettle_gcm_aes_update&gt;, 
  encrypt = 0xc42c &lt;nettle_gcm_aes_encrypt&gt;, 
  decrypt = 0xc4a8 &lt;nettle_gcm_aes_decrypt&gt;, 
  digest = 0xc524 &lt;nettle_gcm_aes_digest&gt;
}
(gdb) 

Possibly something could be broken on this machine.

/Simon


</body></email><email><emailId>20110531213144</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-05-31 21:31:44-0400</timestampReceived><subject>Re: serpent again</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I'll try to get this integrated reasonably soon. Have you compared the
&gt; performance of the old and new code?

I've checked in the new code now, and I've fixed serpent_key_prepare to
use LE_READ_UINT32 (with no alignment requirements) and with support for
arbitrary key sizes up to 32 bytes.

This has been really straight forward.

On my development laptop, I get about the same performance for the new
and the old code (x86_64, gcc-4.4.5).

I'd like to get rid of the serpent_block_t typedef (I think the use of an
array may mess up register allcoation with some compilers, and that
might be the source of the large performance difference on Simon's
machine), and it's really silly to have a BLOCK_COPY in the round
function.

So I think I'll want to spend some time on reorganizing the code (and
there's also some purely stylistic things, like using uppercase for all
macros) before adding anything really new, like the two-block trick.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110401092858</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-04-01 09:28:58-0400</timestampReceived><subject>Re: struct nettle_cipher for weak-key ciphers</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; can we define an cipher abstraction that exposes the relevant details
&gt; in C, provides a framework that is suitable for symmetric decryption,
&gt; and doesn't violate the minimalistic flavor of nettle?

Feel free to try...

Some points to keep in mind:

1. I think the current nettle_cipher is useful for some applications,
   even if it's not suitable for language bindings which want to provide
   access to everything available.

2. Error checking at set_key

&gt; So far, i think the errors i've heard are:
&gt;
&gt;  * bad key size
&gt;
&gt;  * weak key
&gt;
&gt; Anything else?

One could possibly add parity error for DES, but I doubt anyone really
cares about that. One *might* want to make some distinction between
"hard" errors, like bad key sizes, and "soft" errors or warnings like
weak keys, where the resulting cipher context still can be used, if
desired.

3. The set of supported key sizes.

This is the issue with most potential for making things hairy (and this
information is not provided by nettle's cipher specific interfaces
either; there's a define for a single "recommended" key size, and when
applicable there are defines for the minimum and maximum key size. But
the user has to look in the documentation to find out which key sizes in
this range are actually supported).

&gt; Do we want a way to report the range of acceptable key sizes for a
&gt; given cipher?

I think a general algorithm abstraction ought to provide that. And I
think the model for this more general abstraction should be that ciphers
are parametrized by key size, which is different from current
nettle_cipher (and the design of your perl bindings) which is unaware
that the two ciphers aes-128 and aes-256 are in fact related.

There are two types of queries one could support:

 a) The ability to ask if a particular key size is ok.

 b) The ability to get the complete set of available key sizes.

&gt;From a minimality perspective, it seems undesirable to have both, since
a) can be done on top of b). But I think it makes a lot of sense to have
the set_key function of this interface check key sizes, thereby almost
supporting a) (one would have to provide a particular key, not just a
key size). For b), the simplest way that occurs to me would be to export
a list of ranges. Something like

 struct keysize_range
 { 
   unsigned short start;
   unsigned short length;
 };

Then put a pointer to an array of those structs, sorted by start, into
the new nettle_cipher struct, terminated by an entry with length == 0.
So for aes, one would have

  {{ 16, 1 }, {24, 1}, {32, 1}, {0, 0}}

and for blowfish,

  {{BLOWFISH_MIN_KEY_SIZE, BLOWFISH_MAX_KEY_SIZE + 1 - BLOWFISH_MIN_KEY_SIZE}, {0,0}}

Would this be useful? For a particular usecase, could you use something
like this in your perl bindings, and would that imply a design change
switching to treat AES as a single cipher with several possible key
sizes, rather than as three different ciphers?

And that said, I think the model of current nettle_cipher, which treats
aes128 and aes256 as different ciphers, is also useful in some cases. I
don't know how to reconcile the two views. I'd prefer to not have
multiple nettle_cipher-like abstractions in nettle itself.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110414085533</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-04-14 08:55:33-0400</timestampReceived><subject>Re: different lib directories for gnutls and nettle</subject><body>

On Thu, Apr 14, 2011 at 10:25 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:
&gt;&gt; Nettle should work better with other GNU packages if it follows the
&gt;&gt; GNU standards, as the assumption of lib/ as a default is a common one
&gt;&gt; in other configure scripts.
&gt; I don't change the default lightly, but I still think it's the right
&gt; thing to do when
&gt; 1. The user has not provided --libdir explicitly.
&gt; 2. One is building on a multi-abi system, which is a case where the
&gt; =C2=A0 autoconf default doesn't even try to do the right thing.
&gt; 3. The autoconf default is known to be wrong.

I don't really find this a serious problem because libdir can be
provided by the one performing compilation and fix any issues,
anyway.

As a matter of policy though, I think the FHS way of
storing in /usr/lib 32-bit binaries, even if the default system compiler
outputs 64-bit binaries, is quite absurd, and looks like a relic from
the era that binary only programs came with 32-bit intel code only.
Systems like debian correctly for me do not follow this approach
because it has no benefit for the user of a multi-lib system and only
causes confusion, as programs in /usr/bin do not use libraries in
/usr/lib. What you call a multi-lib system
is actually a system with a native word size and a compatibility
mode with another (smaller) word size. Why one not using
the compatibility mode have an empty /usr/lib? This requirement
is intended only for the one distributing ancient 32-bit binaries and
I see no compelling reason for free software or open systems to
follow that by default.

regards,
Nikos

</body></email><email><emailId>20110416083919</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-04-16 08:39:19-0400</timestampReceived><subject>Re: Serpent</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt;
&gt;&gt; Would this mean that nettle is now compatible with the libgcrypt version
&gt;&gt; of serpent?
&gt;
&gt; That's the idea.
&gt;
&gt;&gt; In that case would the LGPL libgcrypt code be used instead?
&gt;
&gt; Simon said he was working on that. I don't know current status, so I
&gt; figured it was good to fix the old Nettle code too (it turned out to be
&gt; easy).

I'll resume my work -- I recall that I got it to a stage where it built
and generated ciphertext, however it didn't match the test vectors that
were in Nettle back then.  Hopefully it will match now, and I can submit
the patch shortly.

/Simon

</body></email><email><emailId>20110611052829</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-06-11 05:28:29-0400</timestampReceived><subject>rsa keygen replicability</subject><body>


Hi Nettle folks--

I'm wondering if there's an expectation of repeatable RSA key generation
across different versions of libnettle.

In particular, assuming a statically-seeded PRNG (e.g. seeding with a
fixed number of bytes from /dev/zero), should I be able to call
rsa_generate_keypair() and have it return a predictable result, even
across versions of libnettle?

Obviously, replicability is *not* what you'd want for production; but
for testing, it can be a very handy feature.

Right now, i'm trying with a statically-seeded yarrow256_ctx PRNG
against version 2.0 of nettle, and seeing a different key returned from
rsa_generate_keypair() that i see with version 2.1 of nettle.

Should this variation be expected? has the use of random numbers (or
other parts of the algorithm) changed significantly for
rsa_generate_keypair() between releases?

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110613120235</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-06-13 12:02:35-0400</timestampReceived><subject>Re: rsa keygen replicability</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; I'm wondering if there's an expectation of repeatable RSA key generation
&gt; across different versions of libnettle.

I wouldn't expect it. On the other hand, I think most releases don't
change this.

&gt; Right now, i'm trying with a statically-seeded yarrow256_ctx

When one really wants repeatability, one can use the (otherwise pretty
useless) lfib_knuth generator rather than yarrow256.

&gt; has the use of random numbers (or other parts of the algorithm)
&gt; changed significantly for rsa_generate_keypair() between releases?

The generation method was replaced in nettle-2.1. From the NEWS file.

	* Key generation for RSA and DSA changed to use Maurer's
	  algorithm to generate provably prime numbers (as usual, the
	  mathematical proof does not guaranteee that the
	  implementation is bug free).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110613144332</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-06-13 14:43:32-0400</timestampReceived><subject>Re: rsa keygen replicability</subject><body>


On 06/13/2011 08:02 AM, Niels Möller wrote:
&gt; When one really wants repeatability, one can use the (otherwise pretty
&gt; useless) lfib_knuth generator rather than yarrow256.

I've actually found that yarrow256 itself *is* repeatable across nettle
versions (well, 2.0 → 2.1 at least); it was just the RSA key generation
that was not repeatable.

&gt; The generation method was replaced in nettle-2.1. From the NEWS file.
&gt; 
&gt; 	* Key generation for RSA and DSA changed to use Maurer's
&gt; 	  algorithm to generate provably prime numbers (as usual, the
&gt; 	  mathematical proof does not guaranteee that the
&gt; 	  implementation is bug free).

ah, thanks; this explains why.  Thanks for the pointer.

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110630192146</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-06-30 19:21:46-0400</timestampReceived><subject>serpent on x86_64, using sse2 instructions</subject><body>

I've now tried to write some sse2 assembly code for serpent, to do four
blocks at a time in parallell (which helps for ecb and ctr mode, and cbc
decrypt, but not at all for cbc encrypt). First time I've tried to use
these x86 instructions for anything.

I'm currently under the belief that all existing x86_64 processors have
the needed instructions, so there are no configure time or run time
tests of the corresponding cpuid flags.

Speed is then close to aes128 (aes128 is slightly faster for encypt, and
serpent slightly faster for decrypt), and a bit faster than other aes
variants as well as camellia.

I imagine that with processors with whatever sse extension is needed to
get the 256-bit ymm registers, one can get almost twice the performance
for serpent, compared to the current using only the 128-bit xmm
registers.

And in the other direction, the code could easily be ported to 32-bit
x86 with sse2, with just a small penalty from the fewer registers.

Benchmark results on my laptop (intel SU4100):

         Algorithm        mode Mbyte/s cycles/byte cycles/block

            aes128 ECB encrypt   73.47       16.87       269.98
            aes128 ECB decrypt   71.73       17.28       276.53
            aes128 CBC encrypt   61.99       20.00       320.01
            aes128 CBC decrypt   70.52       17.58       281.29

            aes192 ECB encrypt   63.23       19.61       313.72
            aes192 ECB decrypt   61.86       20.04       320.69
            aes192 CBC encrypt   54.30       22.83       365.31
            aes192 CBC decrypt   61.04       20.31       324.97

            aes256 ECB encrypt   54.35       22.81       364.97
            aes256 ECB decrypt   54.28       22.84       365.42
            aes256 CBC encrypt   48.52       25.55       408.80
            aes256 CBC decrypt   53.56       23.15       370.34

       camellia128 ECB encrypt   57.53       21.55       344.80
       camellia128 ECB decrypt   57.52       21.55       344.86
       camellia128 CBC encrypt   51.99       23.84       381.51
       camellia128 CBC decrypt   56.72       21.86       349.74

       camellia192 ECB encrypt   43.05       28.80       460.72
       camellia192 ECB decrypt   43.01       28.82       461.16
       camellia192 CBC encrypt   39.94       31.04       496.68
       camellia192 CBC decrypt   42.53       29.15       466.40

       camellia256 ECB encrypt   43.03       28.81       461.00
       camellia256 ECB decrypt   43.02       28.82       461.14
       camellia256 CBC encrypt   39.90       31.07       497.11
       camellia256 CBC decrypt   42.61       29.10       465.54

        serpent256 ECB encrypt   68.88       18.00       287.98
        serpent256 ECB decrypt   79.81       15.53       248.54
        serpent256 CBC encrypt   23.20       53.43       854.86
        serpent256 CBC decrypt   78.25       15.84       253.50

It's conceivable that one can use simd instructions to get some speedup
also for aes and camellia, but it's not going to be almost trivial like
it is for serpent. (And for aes, I don't yet have any code using the
special instructions available in newer x86_64 processors).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20110521080806</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-05-21 08:08:06-0400</timestampReceived><subject>ECC</subject><body>

I'm working towards adding ECDH and ECDSA support to gnutls.
I've currently ported libtomcrypt to use gmp directly and nettle's
types. The code is under development, and can be found at:
http://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=tree;f=lib/nettle;h=23d9eaa265f911825b09ee7caa4c20525fc9ff2f;hb=HEAD


The ECC functionality is confined to the ecc* files. It would be nice if
nettle included it or something similar.

btw. Is there any plan on an 2.2 release?

regards,
Nikos


</body></email><email><emailId>20110530210231</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-05-30 21:02:31-0400</timestampReceived><subject>Re: serpent again</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; I looked at reviving my serpent port from libgcrypt.  As a first step in
&gt; testing it, it would help if Nettle had the same test vector as
&gt; libgcrypt.  Please consider this patch.

Thanks, checked in now. And the current (i.e., to-be-replaced) code
passes these tests.

/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110530210938</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-05-30 21:09:38-0400</timestampReceived><subject>Re: serpent again</subject><body>

Fixing a small bug in my 2010-12-07 port of serpent.c from libgcrypt to
nettle was all that was required to make it work.  Please consider this
work, applied as follows:

* Add ChangeLog entry as below.
* Remove serpent_sboxes.h.
* Apply patch to Makefile.in as below.
* Add attached serpent.c in place of the current code.

I have not compared the new file to the old one in Nettle, I'll leave
that to you.

/Simon

2011-05-30  Simon Josefsson  &lt;simon@josefsson.org&gt;

	* serpent.c: Rewrite, based on libgcrypt code.  License changed
	from GPL to LGPL.
	* serpent_sboxes.h: Removed.
	* Makefile.in: Drop serpent_sboxes.h.

Index: Makefile.in
===================================================================
RCS file: /cvsroot/lsh/lsh/nettle/Makefile.in,v
retrieving revision 1.32
diff -u -p -r1.32 Makefile.in
--- Makefile.in 23 Mar 2011 10:34:46 -0000      1.32
+++ Makefile.in 30 May 2011 21:07:01 -0000
@@ -128,7 +128,7 @@ DISTFILES = $(SOURCES) $(HEADERS) .boots
        README AUTHORS COPYING COPYING.LIB INSTALL NEWS TODO ChangeLog \
        memxor.c $(des_headers) descore.README \
        aes-internal.h camellia-internal.h cast128_sboxes.h desinfo.h desCode.h \
-       serpent_sboxes.h nettle-internal.h nettle-write.h prime-list.h \
+       nettle-internal.h nettle-write.h prime-list.h \
        asm.m4 \
        nettle.texinfo nettle.info nettle.html nettle.pdf sha-example.c
 

[Attachment #3 (text/x-csrc)]

/* serpent.c
 *
 * The serpent block cipher.
 *
 * For more details on this algorithm, see the Serpent website at
 * http://www.cl.cam.ac.uk/~rja14/serpent.html
 */

/* nettle, low-level cryptographics library
 *
 * Copyright (C) 2010, 2011  Simon Josefsson
 * Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
 *  
 * The nettle library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 * 
 * The nettle library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with the nettle library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
 * MA 02111-1307, USA.
 */

/* This file is derived from cipher/serpent.c in Libgcrypt v1.4.6.
   The adaption to Nettle was made by Simon Josefsson on 2010-12-07
   with final touches on 2011-05-30.  Changes include replacing
   libgcrypt with nettle in the license template, renaming
   serpent_context to serpent_ctx, renaming u32 to uint32_t, removing
   libgcrypt stubs and selftests, modifying entry function prototypes,
   using FOR_BLOCKS to iterate through data in encrypt/decrypt, using
   LE_READ_UINT32 and LE_WRITE_UINT32 to access data in
   encrypt/decrypt, and running indent on the code. */

#if HAVE_CONFIG_H
#include "config.h"
#endif

#include &lt;assert.h&gt;

#include "serpent.h"

#include "macros.h"

/* Number of rounds per Serpent encrypt/decrypt operation.  */
#define ROUNDS 32

/* Magic number, used during generating of the subkeys.  */
#define PHI 0x9E3779B9

/* Serpent works on 128 bit blocks.  */
typedef uint32_t serpent_block_t[4];

/* Serpent key, provided by the user.  If the original key is shorter
   than 256 bits, it is padded.  */
typedef uint32_t serpent_key_t[8];

#define byte_swap_32(x) \
  (0 \
   | (((x) &amp; 0xff000000) &gt;&gt; 24) | (((x) &amp; 0x00ff0000) &gt;&gt;  8) \
   | (((x) &amp; 0x0000ff00) &lt;&lt;  8) | (((x) &amp; 0x000000ff) &lt;&lt; 24))

#define rol(x,n) ((((uint32_t)(x))&lt;&lt;(n))|	\
                  (((uint32_t)(x))&gt;&gt;(32-(n))))
#define ror(x,n) ((((uint32_t)(x))&lt;&lt;(32-(n)))|	\
                  (((uint32_t)(x))&gt;&gt;(n)))

/* These are the S-Boxes of Serpent.  They are copied from Serpents
   reference implementation (the optimized one, contained in
   `floppy2') and are therefore:

     Copyright (C) 1998 Ross Anderson, Eli Biham, Lars Knudsen.

  To quote the Serpent homepage
  (http://www.cl.cam.ac.uk/~rja14/serpent.html):

  "Serpent is now completely in the public domain, and we impose no
   restrictions on its use.  This was announced on the 21st August at
   the First AES Candidate Conference. The optimised implementations
   in the submission package are now under the GNU PUBLIC LICENSE
   (GPL), although some comments in the code still say otherwise. You
   are welcome to use Serpent for any application."  */

#define SBOX0(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t05, t06, t07, t08, t09; \
    uint32_t t11, t12, t13, t14, t15, t17, t01; \
    t01 = b   ^ c  ; \
    t02 = a   | d  ; \
    t03 = a   ^ b  ; \
    z   = t02 ^ t01; \
    t05 = c   | z  ; \
    t06 = a   ^ d  ; \
    t07 = b   | c  ; \
    t08 = d   &amp; t05; \
    t09 = t03 &amp; t07; \
    y   = t09 ^ t08; \
    t11 = t09 &amp; y  ; \
    t12 = c   ^ d  ; \
    t13 = t07 ^ t11; \
    t14 = b   &amp; t06; \
    t15 = t06 ^ t13; \
    w   =     ~ t15; \
    t17 = w   ^ t14; \
    x   = t12 ^ t17; \
  }

#define SBOX0_INVERSE(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t04, t05, t06, t08, t09, t10; \
    uint32_t t12, t13, t14, t15, t17, t18, t01; \
    t01 = c   ^ d  ; \
    t02 = a   | b  ; \
    t03 = b   | c  ; \
    t04 = c   &amp; t01; \
    t05 = t02 ^ t01; \
    t06 = a   | t04; \
    y   =     ~ t05; \
    t08 = b   ^ d  ; \
    t09 = t03 &amp; t08; \
    t10 = d   | y  ; \
    x   = t09 ^ t06; \
    t12 = a   | t05; \
    t13 = x   ^ t12; \
    t14 = t03 ^ t10; \
    t15 = a   ^ c  ; \
    z   = t14 ^ t13; \
    t17 = t05 &amp; t13; \
    t18 = t14 | t17; \
    w   = t15 ^ t18; \
  }

#define SBOX1(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t04, t05, t06, t07, t08; \
    uint32_t t10, t11, t12, t13, t16, t17, t01; \
    t01 = a   | d  ; \
    t02 = c   ^ d  ; \
    t03 =     ~ b  ; \
    t04 = a   ^ c  ; \
    t05 = a   | t03; \
    t06 = d   &amp; t04; \
    t07 = t01 &amp; t02; \
    t08 = b   | t06; \
    y   = t02 ^ t05; \
    t10 = t07 ^ t08; \
    t11 = t01 ^ t10; \
    t12 = y   ^ t11; \
    t13 = b   &amp; d  ; \
    z   =     ~ t10; \
    x   = t13 ^ t12; \
    t16 = t10 | x  ; \
    t17 = t05 &amp; t16; \
    w   = c   ^ t17; \
  }

#define SBOX1_INVERSE(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t04, t05, t06, t07, t08; \
    uint32_t t09, t10, t11, t14, t15, t17, t01; \
    t01 = a   ^ b  ; \
    t02 = b   | d  ; \
    t03 = a   &amp; c  ; \
    t04 = c   ^ t02; \
    t05 = a   | t04; \
    t06 = t01 &amp; t05; \
    t07 = d   | t03; \
    t08 = b   ^ t06; \
    t09 = t07 ^ t06; \
    t10 = t04 | t03; \
    t11 = d   &amp; t08; \
    y   =     ~ t09; \
    x   = t10 ^ t11; \
    t14 = a   | y  ; \
    t15 = t06 ^ x  ; \
    z   = t01 ^ t04; \
    t17 = c   ^ t15; \
    w   = t14 ^ t17; \
  }

#define SBOX2(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t05, t06, t07, t08; \
    uint32_t t09, t10, t12, t13, t14, t01; \
    t01 = a   | c  ; \
    t02 = a   ^ b  ; \
    t03 = d   ^ t01; \
    w   = t02 ^ t03; \
    t05 = c   ^ w  ; \
    t06 = b   ^ t05; \
    t07 = b   | t05; \
    t08 = t01 &amp; t06; \
    t09 = t03 ^ t07; \
    t10 = t02 | t09; \
    x   = t10 ^ t08; \
    t12 = a   | d  ; \
    t13 = t09 ^ x  ; \
    t14 = b   ^ t13; \
    z   =     ~ t09; \
    y   = t12 ^ t14; \
  }

#define SBOX2_INVERSE(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t04, t06, t07, t08, t09; \
    uint32_t t10, t11, t12, t15, t16, t17, t01; \
    t01 = a   ^ d  ; \
    t02 = c   ^ d  ; \
    t03 = a   &amp; c  ; \
    t04 = b   | t02; \
    w   = t01 ^ t04; \
    t06 = a   | c  ; \
    t07 = d   | w  ; \
    t08 =     ~ d  ; \
    t09 = b   &amp; t06; \
    t10 = t08 | t03; \
    t11 = b   &amp; t07; \
    t12 = t06 &amp; t02; \
    z   = t09 ^ t10; \
    x   = t12 ^ t11; \
    t15 = c   &amp; z  ; \
    t16 = w   ^ x  ; \
    t17 = t10 ^ t15; \
    y   = t16 ^ t17; \
  }

#define SBOX3(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t04, t05, t06, t07, t08; \
    uint32_t t09, t10, t11, t13, t14, t15, t01; \
    t01 = a   ^ c  ; \
    t02 = a   | d  ; \
    t03 = a   &amp; d  ; \
    t04 = t01 &amp; t02; \
    t05 = b   | t03; \
    t06 = a   &amp; b  ; \
    t07 = d   ^ t04; \
    t08 = c   | t06; \
    t09 = b   ^ t07; \
    t10 = d   &amp; t05; \
    t11 = t02 ^ t10; \
    z   = t08 ^ t09; \
    t13 = d   | z  ; \
    t14 = a   | t07; \
    t15 = b   &amp; t13; \
    y   = t08 ^ t11; \
    w   = t14 ^ t15; \
    x   = t05 ^ t04; \
  }

#define SBOX3_INVERSE(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t04, t05, t06, t07, t09; \
    uint32_t t11, t12, t13, t14, t16, t01; \
    t01 = c   | d  ; \
    t02 = a   | d  ; \
    t03 = c   ^ t02; \
    t04 = b   ^ t02; \
    t05 = a   ^ d  ; \
    t06 = t04 &amp; t03; \
    t07 = b   &amp; t01; \
    y   = t05 ^ t06; \
    t09 = a   ^ t03; \
    w   = t07 ^ t03; \
    t11 = w   | t05; \
    t12 = t09 &amp; t11; \
    t13 = a   &amp; y  ; \
    t14 = t01 ^ t05; \
    x   = b   ^ t12; \
    t16 = b   | t13; \
    z   = t14 ^ t16; \
  }

#define SBOX4(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t04, t05, t06, t08, t09; \
    uint32_t t10, t11, t12, t13, t14, t15, t16, t01; \
    t01 = a   | b  ; \
    t02 = b   | c  ; \
    t03 = a   ^ t02; \
    t04 = b   ^ d  ; \
    t05 = d   | t03; \
    t06 = d   &amp; t01; \
    z   = t03 ^ t06; \
    t08 = z   &amp; t04; \
    t09 = t04 &amp; t05; \
    t10 = c   ^ t06; \
    t11 = b   &amp; c  ; \
    t12 = t04 ^ t08; \
    t13 = t11 | t03; \
    t14 = t10 ^ t09; \
    t15 = a   &amp; t05; \
    t16 = t11 | t12; \
    y   = t13 ^ t08; \
    x   = t15 ^ t16; \
    w   =     ~ t14; \
  }

#define SBOX4_INVERSE(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t04, t05, t06, t07, t09; \
    uint32_t t10, t11, t12, t13, t15, t01; \
    t01 = b   | d  ; \
    t02 = c   | d  ; \
    t03 = a   &amp; t01; \
    t04 = b   ^ t02; \
    t05 = c   ^ d  ; \
    t06 =     ~ t03; \
    t07 = a   &amp; t04; \
    x   = t05 ^ t07; \
    t09 = x   | t06; \
    t10 = a   ^ t07; \
    t11 = t01 ^ t09; \
    t12 = d   ^ t04; \
    t13 = c   | t10; \
    z   = t03 ^ t12; \
    t15 = a   ^ t04; \
    y   = t11 ^ t13; \
    w   = t15 ^ t09; \
  }

#define SBOX5(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t04, t05, t07, t08, t09; \
    uint32_t t10, t11, t12, t13, t14, t01; \
    t01 = b   ^ d  ; \
    t02 = b   | d  ; \
    t03 = a   &amp; t01; \
    t04 = c   ^ t02; \
    t05 = t03 ^ t04; \
    w   =     ~ t05; \
    t07 = a   ^ t01; \
    t08 = d   | w  ; \
    t09 = b   | t05; \
    t10 = d   ^ t08; \
    t11 = b   | t07; \
    t12 = t03 | w  ; \
    t13 = t07 | t10; \
    t14 = t01 ^ t11; \
    y   = t09 ^ t13; \
    x   = t07 ^ t08; \
    z   = t12 ^ t14; \
  }

#define SBOX5_INVERSE(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t04, t05, t07, t08, t09; \
    uint32_t t10, t12, t13, t15, t16, t01; \
    t01 = a   &amp; d  ; \
    t02 = c   ^ t01; \
    t03 = a   ^ d  ; \
    t04 = b   &amp; t02; \
    t05 = a   &amp; c  ; \
    w   = t03 ^ t04; \
    t07 = a   &amp; w  ; \
    t08 = t01 ^ w  ; \
    t09 = b   | t05; \
    t10 =     ~ b  ; \
    x   = t08 ^ t09; \
    t12 = t10 | t07; \
    t13 = w   | x  ; \
    z   = t02 ^ t12; \
    t15 = t02 ^ t13; \
    t16 = b   ^ d  ; \
    y   = t16 ^ t15; \
  }

#define SBOX6(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t04, t05, t07, t08, t09, t10; \
    uint32_t t11, t12, t13, t15, t17, t18, t01; \
    t01 = a   &amp; d  ; \
    t02 = b   ^ c  ; \
    t03 = a   ^ d  ; \
    t04 = t01 ^ t02; \
    t05 = b   | c  ; \
    x   =     ~ t04; \
    t07 = t03 &amp; t05; \
    t08 = b   &amp; x  ; \
    t09 = a   | c  ; \
    t10 = t07 ^ t08; \
    t11 = b   | d  ; \
    t12 = c   ^ t11; \
    t13 = t09 ^ t10; \
    y   =     ~ t13; \
    t15 = x   &amp; t03; \
    z   = t12 ^ t07; \
    t17 = a   ^ b  ; \
    t18 = y   ^ t15; \
    w   = t17 ^ t18; \
  }

#define SBOX6_INVERSE(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t04, t05, t06, t07, t08, t09; \
    uint32_t t12, t13, t14, t15, t16, t17, t01; \
    t01 = a   ^ c  ; \
    t02 =     ~ c  ; \
    t03 = b   &amp; t01; \
    t04 = b   | t02; \
    t05 = d   | t03; \
    t06 = b   ^ d  ; \
    t07 = a   &amp; t04; \
    t08 = a   | t02; \
    t09 = t07 ^ t05; \
    x   = t06 ^ t08; \
    w   =     ~ t09; \
    t12 = b   &amp; w  ; \
    t13 = t01 &amp; t05; \
    t14 = t01 ^ t12; \
    t15 = t07 ^ t13; \
    t16 = d   | t02; \
    t17 = a   ^ x  ; \
    z   = t17 ^ t15; \
    y   = t16 ^ t14; \
  }

#define SBOX7(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t04, t05, t06, t08, t09, t10; \
    uint32_t t11, t13, t14, t15, t16, t17, t01; \
    t01 = a   &amp; c  ; \
    t02 =     ~ d  ; \
    t03 = a   &amp; t02; \
    t04 = b   | t01; \
    t05 = a   &amp; b  ; \
    t06 = c   ^ t04; \
    z   = t03 ^ t06; \
    t08 = c   | z  ; \
    t09 = d   | t05; \
    t10 = a   ^ t08; \
    t11 = t04 &amp; z  ; \
    x   = t09 ^ t10; \
    t13 = b   ^ x  ; \
    t14 = t01 ^ x  ; \
    t15 = c   ^ t05; \
    t16 = t11 | t13; \
    t17 = t02 | t14; \
    w   = t15 ^ t17; \
    y   = a   ^ t16; \
  }

#define SBOX7_INVERSE(a, b, c, d, w, x, y, z) \
  { \
    uint32_t t02, t03, t04, t06, t07, t08, t09; \
    uint32_t t10, t11, t13, t14, t15, t16, t01; \
    t01 = a   &amp; b  ; \
    t02 = a   | b  ; \
    t03 = c   | t01; \
    t04 = d   &amp; t02; \
    z   = t03 ^ t04; \
    t06 = b   ^ t04; \
    t07 = d   ^ z  ; \
    t08 =     ~ t07; \
    t09 = t06 | t08; \
    t10 = b   ^ d  ; \
    t11 = a   | d  ; \
    x   = a   ^ t09; \
    t13 = c   ^ t06; \
    t14 = c   &amp; t11; \
    t15 = d   | x  ; \
    t16 = t01 | t10; \
    w   = t13 ^ t15; \
    y   = t14 ^ t16; \
  }

/* XOR BLOCK1 into BLOCK0.  */
#define BLOCK_XOR(block0, block1) \
  {                               \
    block0[0] ^= block1[0];       \
    block0[1] ^= block1[1];       \
    block0[2] ^= block1[2];       \
    block0[3] ^= block1[3];       \
  }

/* Copy BLOCK_SRC to BLOCK_DST.  */
#define BLOCK_COPY(block_dst, block_src) \
  {                                      \
    block_dst[0] = block_src[0];         \
    block_dst[1] = block_src[1];         \
    block_dst[2] = block_src[2];         \
    block_dst[3] = block_src[3];         \
  }

/* Apply SBOX number WHICH to to the block found in ARRAY0 at index
   INDEX, writing the output to the block found in ARRAY1 at index
   INDEX.  */
#define SBOX(which, array0, array1, index)            \
  SBOX##which (array0[index + 0], array0[index + 1],  \
               array0[index + 2], array0[index + 3],  \
               array1[index + 0], array1[index + 1],  \
               array1[index + 2], array1[index + 3]);

/* Apply inverse SBOX number WHICH to to the block found in ARRAY0 at
   index INDEX, writing the output to the block found in ARRAY1 at
   index INDEX.  */
#define SBOX_INVERSE(which, array0, array1, index)              \
  SBOX##which##_INVERSE (array0[index + 0], array0[index + 1],  \
                         array0[index + 2], array0[index + 3],  \
                         array1[index + 0], array1[index + 1],  \
                         array1[index + 2], array1[index + 3]);

/* Apply the linear transformation to BLOCK.  */
#define LINEAR_TRANSFORMATION(block)                  \
  {                                                   \
    block[0] = rol (block[0], 13);                    \
    block[2] = rol (block[2], 3);                     \
    block[1] = block[1] ^ block[0] ^ block[2];        \
    block[3] = block[3] ^ block[2] ^ (block[0] &lt;&lt; 3); \
    block[1] = rol (block[1], 1);                     \
    block[3] = rol (block[3], 7);                     \
    block[0] = block[0] ^ block[1] ^ block[3];        \
    block[2] = block[2] ^ block[3] ^ (block[1] &lt;&lt; 7); \
    block[0] = rol (block[0], 5);                     \
    block[2] = rol (block[2], 22);                    \
  }

/* Apply the inverse linear transformation to BLOCK.  */
#define LINEAR_TRANSFORMATION_INVERSE(block)          \
  {                                                   \
    block[2] = ror (block[2], 22);                    \
    block[0] = ror (block[0] , 5);                    \
    block[2] = block[2] ^ block[3] ^ (block[1] &lt;&lt; 7); \
    block[0] = block[0] ^ block[1] ^ block[3];        \
    block[3] = ror (block[3], 7);                     \
    block[1] = ror (block[1], 1);                     \
    block[3] = block[3] ^ block[2] ^ (block[0] &lt;&lt; 3); \
    block[1] = block[1] ^ block[0] ^ block[2];        \
    block[2] = ror (block[2], 3);                     \
    block[0] = ror (block[0], 13);                    \
  }

/* Apply a Serpent round to BLOCK, using the SBOX number WHICH and the
   subkeys contained in SUBKEYS.  Use BLOCK_TMP as temporary storage.
   This macro increments `round'.  */
#define ROUND(which, subkeys, block, block_tmp) \
  {                                             \
    BLOCK_XOR (block, subkeys[round]);          \
    round++;                                    \
    SBOX (which, block, block_tmp, 0);          \
    LINEAR_TRANSFORMATION (block_tmp);          \
    BLOCK_COPY (block, block_tmp);              \
  }

/* Apply the last Serpent round to BLOCK, using the SBOX number WHICH
   and the subkeys contained in SUBKEYS.  Use BLOCK_TMP as temporary
   storage.  The result will be stored in BLOCK_TMP.  This macro
   increments `round'.  */
#define ROUND_LAST(which, subkeys, block, block_tmp) \
  {                                                  \
    BLOCK_XOR (block, subkeys[round]);               \
    round++;                                         \
    SBOX (which, block, block_tmp, 0);               \
    BLOCK_XOR (block_tmp, subkeys[round]);           \
    round++;                                         \
  }

/* Apply an inverse Serpent round to BLOCK, using the SBOX number
   WHICH and the subkeys contained in SUBKEYS.  Use BLOCK_TMP as
   temporary storage.  This macro increments `round'.  */
#define ROUND_INVERSE(which, subkey, block, block_tmp) \
  {                                                    \
    LINEAR_TRANSFORMATION_INVERSE (block);             \
    SBOX_INVERSE (which, block, block_tmp, 0);         \
    BLOCK_XOR (block_tmp, subkey[round]);              \
    round--;                                           \
    BLOCK_COPY (block, block_tmp);                     \
  }

/* Apply the first Serpent round to BLOCK, using the SBOX number WHICH
   and the subkeys contained in SUBKEYS.  Use BLOCK_TMP as temporary
   storage.  The result will be stored in BLOCK_TMP.  This macro
   increments `round'.  */
#define ROUND_FIRST_INVERSE(which, subkeys, block, block_tmp) \
  {                                                           \
    BLOCK_XOR (block, subkeys[round]);                        \
    round--;                                                  \
    SBOX_INVERSE (which, block, block_tmp, 0);                \
    BLOCK_XOR (block_tmp, subkeys[round]);                    \
    round--;                                                  \
  }

/* Convert the user provided key KEY of KEY_LENGTH bytes into the
   internally used format.  */
static void
serpent_key_prepare (const uint8_t * key, unsigned int key_length,
		     serpent_key_t key_prepared)
{
  unsigned int i;

  /* Copy key.  */
  for (i = 0; i &lt; key_length / 4; i++)
    {
#ifdef WORDS_BIGENDIAN
      key_prepared[i] = byte_swap_32 (((uint32_t *) key)[i]);
#else
      key_prepared[i] = ((uint32_t *) key)[i];
#endif
    }

  if (i &lt; 8)
    {
      /* Key must be padded according to the Serpent
         specification.  */
      key_prepared[i] = 0x00000001;

      for (i++; i &lt; 8; i++)
	key_prepared[i] = 0;
    }
}

/* Derive the 33 subkeys from KEY and store them in SUBKEYS.  */
static void
serpent_subkeys_generate (serpent_key_t key, struct serpent_ctx *ctx)
{
  uint32_t w_real[140];		/* The `prekey'.  */
  uint32_t k[132];
  uint32_t *w = &amp;w_real[8];
  int i, j;

  /* Initialize with key values.  */
  for (i = 0; i &lt; 8; i++)
    w[i - 8] = key[i];

  /* Expand to intermediate key using the affine recurrence.  */
  for (i = 0; i &lt; 132; i++)
    w[i] = rol (w[i - 8] ^ w[i - 5] ^ w[i - 3] ^ w[i - 1] ^ PHI ^ i, 11);

  /* Calculate subkeys via S-Boxes, in bitslice mode.  */
  SBOX (3, w, k, 0);
  SBOX (2, w, k, 4);
  SBOX (1, w, k, 8);
  SBOX (0, w, k, 12);
  SBOX (7, w, k, 16);
  SBOX (6, w, k, 20);
  SBOX (5, w, k, 24);
  SBOX (4, w, k, 28);
  SBOX (3, w, k, 32);
  SBOX (2, w, k, 36);
  SBOX (1, w, k, 40);
  SBOX (0, w, k, 44);
  SBOX (7, w, k, 48);
  SBOX (6, w, k, 52);
  SBOX (5, w, k, 56);
  SBOX (4, w, k, 60);
  SBOX (3, w, k, 64);
  SBOX (2, w, k, 68);
  SBOX (1, w, k, 72);
  SBOX (0, w, k, 76);
  SBOX (7, w, k, 80);
  SBOX (6, w, k, 84);
  SBOX (5, w, k, 88);
  SBOX (4, w, k, 92);
  SBOX (3, w, k, 96);
  SBOX (2, w, k, 100);
  SBOX (1, w, k, 104);
  SBOX (0, w, k, 108);
  SBOX (7, w, k, 112);
  SBOX (6, w, k, 116);
  SBOX (5, w, k, 120);
  SBOX (4, w, k, 124);
  SBOX (3, w, k, 128);

  /* Renumber subkeys.  */
  for (i = 0; i &lt; ROUNDS + 1; i++)
    for (j = 0; j &lt; 4; j++)
      ctx-&gt;keys[i][j] = k[4 * i + j];
}

/* Initialize CONTEXT with the key KEY of KEY_LENGTH bits.  */
void
serpent_set_key (struct serpent_ctx *ctx,
		 unsigned length, const uint8_t * key)
{
  serpent_key_t key_prepared;

  serpent_key_prepare (key, length, key_prepared);
  serpent_subkeys_generate (key_prepared, ctx);
}

void
serpent_encrypt (const struct serpent_ctx *ctx,
		 unsigned length, uint8_t * dst, const uint8_t * src)
{
  FOR_BLOCKS (length, dst, src, SERPENT_BLOCK_SIZE)
  {
    serpent_block_t b, b_next;
    int round = 0;

    b[0] = LE_READ_UINT32 (src);
    b[1] = LE_READ_UINT32 (src + 4);
    b[2] = LE_READ_UINT32 (src + 8);
    b[3] = LE_READ_UINT32 (src + 12);

    ROUND (0, ctx-&gt;keys, b, b_next);
    ROUND (1, ctx-&gt;keys, b, b_next);
    ROUND (2, ctx-&gt;keys, b, b_next);
    ROUND (3, ctx-&gt;keys, b, b_next);
    ROUND (4, ctx-&gt;keys, b, b_next);
    ROUND (5, ctx-&gt;keys, b, b_next);
    ROUND (6, ctx-&gt;keys, b, b_next);
    ROUND (7, ctx-&gt;keys, b, b_next);
    ROUND (0, ctx-&gt;keys, b, b_next);
    ROUND (1, ctx-&gt;keys, b, b_next);
    ROUND (2, ctx-&gt;keys, b, b_next);
    ROUND (3, ctx-&gt;keys, b, b_next);
    ROUND (4, ctx-&gt;keys, b, b_next);
    ROUND (5, ctx-&gt;keys, b, b_next);
    ROUND (6, ctx-&gt;keys, b, b_next);
    ROUND (7, ctx-&gt;keys, b, b_next);
    ROUND (0, ctx-&gt;keys, b, b_next);
    ROUND (1, ctx-&gt;keys, b, b_next);
    ROUND (2, ctx-&gt;keys, b, b_next);
    ROUND (3, ctx-&gt;keys, b, b_next);
    ROUND (4, ctx-&gt;keys, b, b_next);
    ROUND (5, ctx-&gt;keys, b, b_next);
    ROUND (6, ctx-&gt;keys, b, b_next);
    ROUND (7, ctx-&gt;keys, b, b_next);
    ROUND (0, ctx-&gt;keys, b, b_next);
    ROUND (1, ctx-&gt;keys, b, b_next);
    ROUND (2, ctx-&gt;keys, b, b_next);
    ROUND (3, ctx-&gt;keys, b, b_next);
    ROUND (4, ctx-&gt;keys, b, b_next);
    ROUND (5, ctx-&gt;keys, b, b_next);
    ROUND (6, ctx-&gt;keys, b, b_next);

    ROUND_LAST (7, ctx-&gt;keys, b, b_next);

    LE_WRITE_UINT32 (dst, b_next[0]);
    LE_WRITE_UINT32 (dst + 4, b_next[1]);
    LE_WRITE_UINT32 (dst + 8, b_next[2]);
    LE_WRITE_UINT32 (dst + 12, b_next[3]);
  }
}

void
serpent_decrypt (const struct serpent_ctx *ctx,
		 unsigned length, uint8_t * dst, const uint8_t * src)
{
  FOR_BLOCKS (length, dst, src, SERPENT_BLOCK_SIZE)
  {
    serpent_block_t b, b_next;
    int round = ROUNDS;

    b_next[0] = LE_READ_UINT32 (src);
    b_next[1] = LE_READ_UINT32 (src + 4);
    b_next[2] = LE_READ_UINT32 (src + 8);
    b_next[3] = LE_READ_UINT32 (src + 12);

    ROUND_FIRST_INVERSE (7, ctx-&gt;keys, b_next, b);

    ROUND_INVERSE (6, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (5, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (4, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (3, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (2, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (1, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (0, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (7, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (6, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (5, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (4, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (3, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (2, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (1, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (0, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (7, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (6, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (5, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (4, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (3, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (2, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (1, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (0, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (7, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (6, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (5, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (4, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (3, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (2, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (1, ctx-&gt;keys, b, b_next);
    ROUND_INVERSE (0, ctx-&gt;keys, b, b_next);

    LE_WRITE_UINT32 (dst, b_next[0]);
    LE_WRITE_UINT32 (dst + 4, b_next[1]);
    LE_WRITE_UINT32 (dst + 8, b_next[2]);
    LE_WRITE_UINT32 (dst + 12, b_next[3]);
  }
}


</body></email><email><emailId>20110530211657</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-05-30 21:16:57-0400</timestampReceived><subject>Re: serpent again</subject><body>

Btw, I have tested it on a core i7 (little endien) and a PPC machine
(big endian) and it worked.

(However, the 'gcm' self test crashed on PPC.)

/Simon

</body></email><email><emailId>20110530212945</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-05-30 21:29:45-0400</timestampReceived><subject>Re: serpent again</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Fixing a small bug in my 2010-12-07 port of serpent.c from libgcrypt to
&gt; nettle was all that was required to make it work.  Please consider this
&gt; work, applied as follows:

Great!

I'll try to get this integrated reasonably soon. Have you compared the
performance of the old and new code?

Some minor things (which I think I can take care of myself):

&gt; /* Serpent works on 128 bit blocks.  */
&gt; typedef uint32_t serpent_block_t[4];
&gt;
&gt; /* Serpent key, provided by the user.  If the original key is shorter
&gt;    than 256 bits, it is padded.  */
&gt; typedef uint32_t serpent_key_t[8];

I dislike array typedefs.

&gt; #define byte_swap_32(x) \
&gt;   (0 \
&gt;    | (((x) &amp; 0xff000000) &gt;&gt; 24) | (((x) &amp; 0x00ff0000) &gt;&gt;  8) \
&gt;    | (((x) &amp; 0x0000ff00) &lt;&lt;  8) | (((x) &amp; 0x000000ff) &lt;&lt; 24))

This and the endian test where it is used should be replaced by using
LE_READ_UINT32.

&gt; /* Convert the user provided key KEY of KEY_LENGTH bytes into the
&gt;    internally used format.  */
&gt; static void
&gt; serpent_key_prepare (const uint8_t * key, unsigned int key_length,
&gt; 		     serpent_key_t key_prepared)

This function seems to assume that key is aligned on a four-byte
boundary, and that key_length is a multiple of four. The nettle
interface specifies no alignment requirement on the key. And the old
serpent code is supposed to support any key size (although unfortunately
I don't have any testcases for sizes other than 16, 24 and 32 bytes).

After this code is in, I'd like to try to do serpent with two blocks at
a time in parallel, for machines with native 64-bit registers (and change
at least the ctr code to do a couple of blocks at a time). I think that
might be about as fast as aes or camellia.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110530215454</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-05-30 21:54:54-0400</timestampReceived><subject>Re: serpent again</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; Fixing a small bug in my 2010-12-07 port of serpent.c from libgcrypt to
&gt;&gt; nettle was all that was required to make it work.  Please consider this
&gt;&gt; work, applied as follows:
&gt;
&gt; Great!
&gt;
&gt; I'll try to get this integrated reasonably soon. Have you compared the
&gt; performance of the old and new code?

Old:
jas@latte:~/src/lsh/nettle/examples$ ./nettle-benchmark serpent
sha1_compress: 1139.20 cycles

benchmark call overhead: 0.002529 us
         Algorithm        mode Mbyte/s

        serpent256 ECB encrypt   28.69
        serpent256 ECB decrypt   30.94
        serpent256 CBC encrypt   26.99
        serpent256 CBC decrypt   30.82
jas@latte:~/src/lsh/nettle/examples$ 

New:
jas@latte:~/src/lsh/nettle/examples$ ./nettle-benchmark serpent
sha1_compress: 1140.00 cycles

benchmark call overhead: 0.002425 us
         Algorithm        mode Mbyte/s

        serpent256 ECB encrypt   14.26
        serpent256 ECB decrypt   16.34
        serpent256 CBC encrypt   13.93
        serpent256 CBC decrypt   15.93
jas@latte:~/src/lsh/nettle/examples$ 

&gt; Some minor things (which I think I can take care of myself):
&gt;
&gt;&gt; /* Serpent works on 128 bit blocks.  */
&gt;&gt; typedef uint32_t serpent_block_t[4];
&gt;&gt;
&gt;&gt; /* Serpent key, provided by the user.  If the original key is shorter
&gt;&gt;    than 256 bits, it is padded.  */
&gt;&gt; typedef uint32_t serpent_key_t[8];
&gt;
&gt; I dislike array typedefs.
&gt;
&gt;&gt; #define byte_swap_32(x) \
&gt;&gt;   (0 \
&gt;&gt;    | (((x) &amp; 0xff000000) &gt;&gt; 24) | (((x) &amp; 0x00ff0000) &gt;&gt;  8) \
&gt;&gt;    | (((x) &amp; 0x0000ff00) &lt;&lt;  8) | (((x) &amp; 0x000000ff) &lt;&lt; 24))
&gt;
&gt; This and the endian test where it is used should be replaced by using
&gt; LE_READ_UINT32.

Sounds good.

&gt;&gt; /* Convert the user provided key KEY of KEY_LENGTH bytes into the
&gt;&gt;    internally used format.  */
&gt;&gt; static void
&gt;&gt; serpent_key_prepare (const uint8_t * key, unsigned int key_length,
&gt;&gt; 		     serpent_key_t key_prepared)
&gt;
&gt; This function seems to assume that key is aligned on a four-byte
&gt; boundary, and that key_length is a multiple of four. The nettle
&gt; interface specifies no alignment requirement on the key. And the old
&gt; serpent code is supposed to support any key size (although unfortunately
&gt; I don't have any testcases for sizes other than 16, 24 and 32 bytes).

Maybe throw an error for non-16/24/32 key sizes?  I'm not sure how
useful it is to support that.

&gt; After this code is in, I'd like to try to do serpent with two blocks at
&gt; a time in parallel, for machines with native 64-bit registers (and change
&gt; at least the ctr code to do a couple of blocks at a time). I think that
&gt; might be about as fast as aes or camellia.

Did the old code do that?  In any case, it looks like the performance of
serpent has a long way to go to be comparable to aes or camellia:

jas@latte:~/src/lsh/nettle/examples$ ./nettle-benchmark camellia
sha1_compress: 1139.20 cycles

benchmark call overhead: 0.002421 us
         Algorithm        mode Mbyte/s

       camellia128 ECB encrypt  146.18
       camellia128 ECB decrypt  146.37
       camellia128 CBC encrypt  127.87
       camellia128 CBC decrypt  142.89

       camellia192 ECB encrypt  110.03
       camellia192 ECB decrypt  109.84
       camellia192 CBC encrypt   98.50
       camellia192 CBC decrypt  108.31

       camellia256 ECB encrypt  109.72
       camellia256 ECB decrypt  110.03
       camellia256 CBC encrypt   98.46
       camellia256 CBC decrypt  108.29
jas@latte:~/src/lsh/nettle/examples$ ./nettle-benchmark aes
sha1_compress: 1149.60 cycles

benchmark call overhead: 0.002420 us
         Algorithm        mode Mbyte/s

            aes128 ECB encrypt  181.84
            aes128 ECB decrypt  181.58
            aes128 CBC encrypt  149.30
            aes128 CBC decrypt  178.05

            aes192 ECB encrypt  153.40
            aes192 ECB decrypt  155.35
            aes192 CBC encrypt  132.48
            aes192 CBC decrypt  153.33

            aes256 ECB encrypt  135.98
            aes256 ECB decrypt  135.14
            aes256 CBC encrypt  119.54
            aes256 CBC decrypt  134.13

    openssl aes128 ECB encrypt  203.50
    openssl aes128 ECB decrypt  190.98

    openssl aes192 ECB encrypt  171.97
    openssl aes192 ECB decrypt  162.42

    openssl aes256 ECB encrypt  149.75
    openssl aes256 ECB decrypt  142.56
jas@latte:~/src/lsh/nettle/examples$ 

/Simon

</body></email><email><emailId>20110531080649</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-05-31 08:06:49-0400</timestampReceived><subject>Re: serpent again</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt; I'll try to get this integrated reasonably soon. Have you compared the
&gt;&gt; performance of the old and new code?
&gt;
&gt; Old:
&gt;         serpent256 ECB encrypt   28.69
&gt;         serpent256 ECB decrypt   30.94
&gt;         serpent256 CBC encrypt   26.99
&gt;         serpent256 CBC decrypt   30.82

&gt; New:
&gt;         serpent256 ECB encrypt   14.26
&gt;         serpent256 ECB decrypt   16.34
&gt;         serpent256 CBC encrypt   13.93
&gt;         serpent256 CBC decrypt   15.93

Then there's clearly some room for optimization.

&gt; Maybe throw an error for non-16/24/32 key sizes?  I'm not sure how
&gt; useful it is to support that.

Not terribly useful, I guess, but since it's well defined by the serpent
spec, I think it should be supported.

&gt;&gt; After this code is in, I'd like to try to do serpent with two blocks at
&gt;&gt; a time in parallel, for machines with native 64-bit registers (and change
&gt;&gt; at least the ctr code to do a couple of blocks at a time). I think that
&gt;&gt; might be about as fast as aes or camellia.
&gt;
&gt; Did the old code do that?

No, I didn't want to do that work with the old code.

&gt; In any case, it looks like the performance of serpent has a long way
&gt; to go to be comparable to aes or camellia:

On my Intel SU4100 laptop (64 bit), I get (still with the old serpent
code):

            aes256 ECB encrypt   54.72
            aes256 ECB decrypt   54.36

       camellia256 ECB encrypt   43.10
       camellia256 ECB decrypt   43.09

        serpent256 ECB encrypt   22.47
        serpent256 ECB decrypt   26.89

I would expect that the two-block-in-parallel trick can almost double
serpent performance (for ecb, ctr, cbc-decrypt, but not cbc-encrypt).
And then all three algorithms are definitely in the same ballpark.

(And of these algorithms, only aes uses handwritten x86_64 assembly
code).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110531082001</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-05-31 08:20:01-0400</timestampReceived><subject>Re: serpent again</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt;&gt; Maybe throw an error for non-16/24/32 key sizes?  I'm not sure how
&gt;&gt; useful it is to support that.
&gt;
&gt; Not terribly useful, I guess, but since it's well defined by the serpent
&gt; spec, I think it should be supported.

Which spec?  According to wikipedia

https://secure.wikimedia.org/wikipedia/en/wiki/Serpent_%28cipher%29

this is the official serpent homepage:

http://www.cl.cam.ac.uk/~rja14/serpent.html

and the link for "algorithm specification" is

http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf

which says that 

   The user key length is variable, but for the purposes of this
   submission we fix it at 128, 192 or 256 bits

That is a bit vague, either it is variable or it isn't.

The Serpent-0 specification says

   The user key can be of any length between 64 and 256 bits.[5]

   [5] We define key lengths to be multiples of 32 bits for ease of
   implementation, and ...

Thus in any case, it seems, the key size is not completely variable and
always a multiple of 32 bits (which resolves the key alignment issue).

My impression is that Serpent is a bit confusingly specified, and it is
unclear which specification is actually the right one.  The test vector
confusion reinforced my impression here.

/Simon

</body></email><email><emailId>20110531084303</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-05-31 08:43:03-0400</timestampReceived><subject>Re: serpent again</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; and the link for "algorithm specification" is
&gt;
&gt; http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf

I think this is the authoritative spec, and same document which was
included in the submission package (floppy5/serpent.pdf).

&gt;    The user key length is variable, but for the purposes of this
&gt;    submission we fix it at 128, 192 or 256 bits
&gt;
&gt; That is a bit vague, either it is variable or it isn't.

I agree, this is not as definitive as I remembered it. Anyway, it
defines how short keys of any bitsize &lt;= 256 bits should be padded, in
case anybody ever wants to use it, and gives 40-bit keys as an example.

&gt; The Serpent-0 specification says
&gt;
&gt;    The user key can be of any length between 64 and 256 bits.[5]
&gt;
&gt;    [5] We define key lengths to be multiples of 32 bits for ease of
&gt;    implementation, and ...

I don't think this is relevant.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110521110436</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-05-21 11:04:36-0400</timestampReceived><subject>Re: ECC</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I'm working towards adding ECDH and ECDSA support to gnutls.

I don't have time at the moment to read the code. Could you summarize
which curves/algorithms/specifications you're implementing?

&gt; The ECC functionality is confined to the ecc* files. It would be nice if
&gt; nettle included it or something similar.

Contributions are welcome ;-) We'll see if I get any time to look into
it myself.

&gt; btw. Is there any plan on an 2.2 release?

I guess I should put up a release TODO list on the web. Issues I'm aware
of and which I think should be completed before the next release are:

 * Fix the libdir defaults for linux.

 * Port libgrypt's LGPL:ed serpent implementation to nettle.

 * Overall license change to LGPL. Still not decided if it should be
   LGPLv2+, LGPLv3+, or dual license GPLv2+ and LGPLv3+ (in this
   notation, "+" means "or any later version, of the user's choice").

If it's going to take a long time to sort these things out, I could make
a relase sooner and postpone some or all of the above to a later
release. Main new feature since the previous release is the gcm support,
I think.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110521114302</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-05-21 11:43:02-0400</timestampReceived><subject>Re: ECC</subject><body>

On 05/21/2011 01:04 PM, Niels Möller wrote:

&gt;&gt; I'm working towards adding ECDH and ECDSA support to gnutls.
&gt; I don't have time at the moment to read the code. Could you
&gt; summarize which curves/algorithms/specifications you're
&gt; implementing?

For gnutls I care only about the SECG curves (SECP224R1, SECP256R1,
SECP384R1, SECP521R1) and with those I have tested the ECDH support.
The code was fixed for the curves y^2=x^3-3x+b. I tried to make it
apply to generic y^2=x^3+ax+b, but I haven't test that functionality
(nor plan to) because all of the above curves are of the a=-3 format.

libtomcrypt's code style is similar to nettle's thus the changes
required to port this to nettle would not be much, but always depends
on what you want to include there.

&gt; * Port libgrypt's LGPL:ed serpent implementation to nettle. * Overall
&gt; license change to LGPL. Still not decided if it should be LGPLv2+,
&gt; LGPLv3+, or dual license GPLv2+ and LGPLv3+ (in this notation, "+"
&gt; means "or any later version, of the user's choice").

May I suggest an intermediate release with GCM under LGPLv2+?
That would ensure that current applications using gnutls can use that
code.

regards,
Nikos

</body></email><email><emailId>20110530083650</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-05-30 08:36:50-0400</timestampReceived><subject>Re: ECC</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; May I suggest an intermediate release with GCM under LGPLv2+?
&gt; That would ensure that current applications using gnutls can use that
&gt; code.

An all-LGPL release is not possible until the serpent code is replaced,
so any releases before that would use the current licensing terms (GPL
as a whole, certain parts under more permissive license).

So I'm not sure exactly what you are suggesting.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110211100702</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-11 10:07:02-0400</timestampReceived><subject>Re: Serpent</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt; Maybe you can try adding some of the testvectors at
&gt;&gt; http://www.cs.technion.ac.il/~biham/Reports/Serpent/ to nettle and
&gt;&gt; libgcrypt, and see what happens? (On the nettle side, I'll try to give
&gt;&gt; that a reasonably high priority).
&gt;
&gt; As you noted privately, they fail in nettle but work in libgcrypt.

A while ago, the email masquerading setup was broken on the machine
where I write email. Because of this, the invalid adress
nettle-bugs@lysator.liu.se has appeared in headers of some of my emails,
and then copied into replies to those. The correct address is
nettle-bugs@lists.lysator.liu.se.

&gt; According to Eli's page and the AES submission paper, there is Serpent-0
&gt; and Serpent-1 and the paper discuss (page 22-23) that the key schedule
&gt; has changed.

Do you think nettle's implementation is serpent-0, or is it just broken?
I'm puzzled, because I'm fairly sure I got the test vectors from
serpent's submission package (I could try to double check that), which
if I understand correctly ought to be serpent-1. I vaguely remember I
had some difficulty understanding the organization of the test data,
though.

And I'm sorry if you have wasted some time debugging fully correct key
scheduling.

&gt; I updated the wikipedia article on this:
&gt; http://en.wikipedia.org/wiki/Serpent_%28cipher%29

Hmm, I can't find any mention of serpent-0 there?

&gt; Still, I'm not sure it is worth the time to fix Serpent in Nettle.  I
&gt; suggest to remove it, that will save some code size as well.

It's clearly no use to keep the current broken implementation. But I
think it would be nice to have serpent, for a couple of reasons:

* It's generally good to have a couple of ciphers with aes-compatible
  key and block sizes. Besides aes/rijndael and serpent, there's
  twofish and camellia.

* I'm not sure what performance one can get out of serpent compared to
  aes, in particular on 64-bit processors. AES doesn't fit well with
  64-bit operations, camellia is better in that respect but includes
  some awkward operations (current 64-bit code could perhaps be improved
  abit using larger tables). 

* I'd prefer to not remove existing features.

If you have a half-done port of libgrypt's serpent code, maybe you or I
could finish it? 

I'll start by looking into the test vectors, I'd like to figure out
where nettle's came from, and I'd like to have a serpent-test.c
including correct test vectors, even if we end up removing all other
serpent code.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110211103904</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2011-02-11 10:39:04-0400</timestampReceived><subject>Re: Serpent</subject><body>

On Fri, Feb 11, 2011 at 11:07 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:

&gt; I'll start by looking into the test vectors, I'd like to figure out
&gt; where nettle's came from, and I'd like to have a serpent-test.c
&gt; including correct test vectors, even if we end up removing all other
&gt; serpent code.

I'am just repeating myself and might become annoying... but does it
really worth the time? Is there anyone using that algorithm, or anyone
planning to use it? As it stands now serpent is an academic cipher,
it is not used in any protocol.

regards,
Nikos

</body></email><email><emailId>20110211104334</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-11 10:43:34-0400</timestampReceived><subject>Re: Serpent</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I'm puzzled, because I'm fairly sure I got the test vectors from
&gt; serpent's submission package (I could try to double check that),

I have checked that now. I downloaded and unpacked the submission
package http://www.cl.cam.ac.uk/~rja14/Papers/serpent.tar.gz

Test vectors are in the floppy4 directory. In floppy4/ecb_vk.txt, the
first test vector is

  KEYSIZE=128
  
  PT=00000000000000000000000000000000
  
  I=1
  KEY=80000000000000000000000000000000
  CT=49afbfad9d5a34052cd8ffa5986bd2dd

and in floppy4/ecb_vt.txt the first text vector is

  KEYSIZE=128
  
  KEY=00000000000000000000000000000000
  
  I=1
  PT=80000000000000000000000000000000
  CT=10b5ffb720b8cb9002a1142b0ba2e94a

These are the first two testvectors in nettle's serpent-test.c.

On the other hand, the file

http://www.cs.technion.ac.il/~biham/Reports/Serpent/Serpent-128-128.verified.test-vectors

contains the testvector

Set 2, vector#  0:
                           key=00000000000000000000000000000000
                         plain=80000000000000000000000000000000
                        cipher=A3B35DE7C358DDD82644678C64B8BCBB
                     decrypted=80000000000000000000000000000000
            Iterated 100 times=1DDF9883B4663045753758E0B9B2C09B
           Iterated 1000 times=BE5AE44A1CF1BB86DD7A3B61CEEA01EC

Same inputs as in ecb_vt.txt, but different output.

What results do you get with libgcrypt for the above two test vectors?

I think I have to mail the authors...

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110321062422</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-21 06:24:22-0400</timestampReceived><subject>typo in manual for arctwo</subject><body>

Hi Nettle folks--

There's a typo in the Nettle manual about the ARCTWO block size.  the
attached patch (against 2.1) should fix it.

Of course, it might already be fixed on the development trunk.  Is there
a public revision control system for nettle someplace i can look at?

	--dkg

PS i sent this message earlier PGP/MIME-signed, but it was rejected by
the mailing list with "After content filtering, the message was empty"
-- could the content filtering be relaxed a little bit to allow
multipart/signed messages?

The message MIME structure looked like this:

└┬╴multipart/signed
 ├┬╴multipart/mixed
 │├╴text/plain
 │└╴text/x-diff attachment
 └╴application/pgp-signature attachment

I then tried re-sending it without the cryptographic signature, which
produced a message like this:

└┬╴multipart/mixed
 ├╴text/plain
 └╴text/x-diff attachment

This second message was rejected with the message:

"The message's content type was not explicitly allowed"


Both of these seem like pretty reasonable message structures for posts
to a cryptographic software development mailing list; it'd be nice if
they could go through :)

Here is the patch inline:


arctwo-doc-fix.patch

--- nettle.texinfo.orig	2011-03-16 19:08:50.000000000 -0400
+++ nettle.texinfo	2011-03-16 19:09:26.000000000 -0400
@@ -871,7 +871,7 @@
 @end deftp

 @defvr Constant ARCTWO_BLOCK_SIZE
-The AES block-size, 8
+The ARCTWO block-size, 8
 @end defvr

 @defvr Constant ARCTWO_MIN_KEY_SIZE

</body></email><email><emailId>20110321062845</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-21 06:28:45-0400</timestampReceived><subject>Re: typo in manual for arctwo</subject><body>


On 03/21/2011 02:24 AM, Daniel Kahn Gillmor wrote:
&gt; Of course, it might already be fixed on the development trunk.  Is ther=
e
&gt; a public revision control system for nettle someplace i can look at?

Gah, this question was already answered by niels several days ago,
though it was after i sent this patch originally, and this message was
caught up in fighting with the mailing list configuration.

It looks like this fix has not yet been made on the development trunk,
if my reading of the CVS repo is accurate.

	--dkg



</body></email><email><emailId>20110211111141</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-11 11:11:41-0400</timestampReceived><subject>Re: Serpent</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; As it stands now serpent is an academic cipher,
&gt; it is not used in any protocol.

It's specified as an optional algorithm in the ssh protocol (see RFC
4253 and RFC 4344).

That said, I think the main use for serpent or any other of the losing
aes finalists are as backups in case some serious problem is discovered
with aes.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110321134109</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-21 13:41:09-0400</timestampReceived><subject>List configuration (Was: Re: typo in manual for arctwo)</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; PS i sent this message earlier PGP/MIME-signed, but it was rejected by
&gt; the mailing list with "After content filtering, the message was empty"
&gt; -- could the content filtering be relaxed a little bit to allow
&gt; multipart/signed messages?

I agree this rejection was silly. I'm not so good at mailman
configuration. The "pass_mime_types" option was set to

  text/plain
  multipart/signed

I'm now changing it to

  text
  multipart
  application/pgp-signature

Do you think that is good enough? Other suggestions?

Or is it better to completely disable this content-type filtering?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110211112833</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2011-02-11 11:28:33-0400</timestampReceived><subject>Re: Serpent</subject><body>

On Fri, Feb 11, 2011 at 12:11 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:
&gt;&gt; As it stands now serpent is an academic cipher,
&gt;&gt; it is not used in any protocol.
&gt; It's specified as an optional algorithm in the ssh protocol (see RFC
&gt; 4253 and RFC 4344).

Ah, I didn't know that.

&gt; That said, I think the main use for serpent or any other of the losing
&gt; aes finalists are as backups in case some serious problem is discovered
&gt; with aes.

Nowdays this is also camellia for that purpose...

regards,
Nikos

</body></email><email><emailId>20110211154125</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-02-11 15:41:25-0400</timestampReceived><subject>Re: Serpent</subject><body>


On 02/11/2011 05:39 AM, Nikos Mavrogiannopoulos wrote:
&gt; I'am just repeating myself and might become annoying... but does it
&gt; really worth the time? Is there anyone using that algorithm, or anyone
&gt; planning to use it? As it stands now serpent is an academic cipher,
&gt; it is not used in any protocol.

I know people who use serpent with Linux's dm-crypt for encrypted block
devices.  It's not entirely academic.  having multiple implementations
of serpent would be a Good Thing.

	--dkg



</body></email><email><emailId>20110211185147</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-02-11 18:51:47-0400</timestampReceived><subject>Re: Serpent</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt;&gt; According to Eli's page and the AES submission paper, there is Serpent-0
&gt;&gt; and Serpent-1 and the paper discuss (page 22-23) that the key schedule
&gt;&gt; has changed.
&gt;
&gt; Do you think nettle's implementation is serpent-0, or is it just
&gt; broken?

I don't know, I suspect it is serpent-0 but haven't confirmed it.

&gt;&gt; I updated the wikipedia article on this:
&gt;&gt; http://en.wikipedia.org/wiki/Serpent_%28cipher%29
&gt;
&gt; Hmm, I can't find any mention of serpent-0 there?

I see it, maybe there is some caching?

&gt; If you have a half-done port of libgrypt's serpent code, maybe you or I
&gt; could finish it? 

Sure!  I suspect everything except the key schedule is working in my
port.  Should I try to make it compatible with libgcrypt, and presumably
Serpent-1?  Thus modifying serpent-test.c?  I'll send a patch later.

/Simon

</body></email><email><emailId>20110415191329</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-04-15 19:13:29-0400</timestampReceived><subject>Re: Serpent</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I'm puzzled, because I'm fairly sure I got the test vectors from
&gt; serpent's submission package (I could try to double check that), which
&gt; if I understand correctly ought to be serpent-1. I vaguely remember I
&gt; had some difficulty understanding the organization of the test data,
&gt; though.

The files defining these testvectors use an input and output format with
bytes in the reverse order. At the time (2001-06-17, almost ten years
ago), I thought this reversal was part of the cipher operation, rather
than a peculiarity with test programs and test vectors in the serpent
submission package, and incorrectly added byte reversal to the functions
in serpent.c.

I've now reverted this old change, which means that from now on serpent
in Nettle ought to agree with other implementations. And this naturally
also breaks compatibility for anyone using the serpent implementation of
all (or almost all) earlier versions of Nettle.

I've fixed the serpent-test.c to reverse inputs and outputs for the
testvectors copied from the serpent submission package, and added a few
additional test vectors (from
http://www.cs.technion.ac.il/~biham/Reports/Serpent/) using a sane byte
order.

Credits go to Eli Biham and Lars Knudsen for finally putting me on the
right track.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110415195034</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-04-15 19:50:34-0400</timestampReceived><subject>Re: Serpent</subject><body>

On 04/15/2011 09:13 PM, Niels Möller wrote:

[...]
&gt; I've now reverted this old change, which means that from now on serpent
&gt; in Nettle ought to agree with other implementations. And this naturally
&gt; also breaks compatibility for anyone using the serpent implementation of
&gt; all (or almost all) earlier versions of Nettle.

Would this mean that nettle is now compatible with the libgcrypt version
of serpent? In that case would the LGPL libgcrypt code be used instead?

regards,
Nikos

</body></email><email><emailId>20110416065141</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-04-16 06:51:41-0400</timestampReceived><subject>Re: Serpent</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Would this mean that nettle is now compatible with the libgcrypt version
&gt; of serpent?

That's the idea.

&gt; In that case would the LGPL libgcrypt code be used instead?

Simon said he was working on that. I don't know current status, so I
figured it was good to fix the old Nettle code too (it turned out to be
easy).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110530163949</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-05-30 16:39:49-0400</timestampReceived><subject>Re: ECC</subject><body>

On 05/30/2011 10:36 AM, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt;&gt; May I suggest an intermediate release with GCM under LGPLv2+?
&gt;&gt; That would ensure that current applications using gnutls can use that
&gt;&gt; code.
&gt; An all-LGPL release is not possible until the serpent code is replaced,
&gt; so any releases before that would use the current licensing terms (GPL
&gt; as a whole, certain parts under more permissive license).
&gt; So I'm not sure exactly what you are suggesting.

I thought the GPL part applies only to the parts that are GPL and not to
the whole library. In any case would you suggest gnutls using nettle a
la lsh, i.e. include it as a static library? That way we can eliminate
licensing issues by removing the GPL parts.

regards,
Nikos

</body></email><email><emailId>20110318132820</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-18 13:28:20-0400</timestampReceived><subject>Re: nettle perl bindings</subject><body>


On 03/18/2011 01:55 AM, Niels Möller wrote:
&gt; Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:
&gt; 
&gt;&gt; Niels, this is clearly a derivative work of Nettle.  I'm happy to put
&gt;&gt; whatever free license you think is appropriate on it.  Is GPL-2+ OK?
&gt; 
&gt; If by "GPL-2+" you mean GPL version 2 or (user's option) any later version,
&gt; that's fine with me. 

yes, this is what i mean.

&gt; As you know, changing the Nettle license to (some version of) the LPGL
&gt; is planned. When that happens, it would make some sense for the perl
&gt; bindings to follow, even if sticking to the GPL is still a perfectly
&gt; acceptable option.

Sure, I'd be happy to follow the licensing changes.

	--dkg



</body></email><email><emailId>20110321134336</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-21 13:43:36-0400</timestampReceived><subject>Re: typo in manual for arctwo</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; arctwo-doc-fix.patch
&gt;
&gt; --- nettle.texinfo.orig	2011-03-16 19:08:50.000000000 -0400
&gt; +++ nettle.texinfo	2011-03-16 19:09:26.000000000 -0400
&gt; @@ -871,7 +871,7 @@
&gt;  @end deftp
&gt;
&gt;  @defvr Constant ARCTWO_BLOCK_SIZE
&gt; -The AES block-size, 8
&gt; +The ARCTWO block-size, 8
&gt;  @end defvr
&gt;
&gt;  @defvr Constant ARCTWO_MIN_KEY_SIZE

Checked in now. Thanks for spotting it.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110321161247</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-21 16:12:47-0400</timestampReceived><subject>Re: List configuration (Was: Re: typo in manual for arctwo)</subject><body>


On 03/21/2011 09:41 AM, Niels Möller wrote:
&gt; I agree this rejection was silly. I'm not so good at mailman
&gt; configuration. The "pass_mime_types" option was set to
&gt; 
&gt;   text/plain
&gt;   multipart/signed
&gt; 
&gt; I'm now changing it to
&gt; 
&gt;   text
&gt;   multipart
&gt;   application/pgp-signature
&gt; 
&gt; Do you think that is good enough? Other suggestions?

I'm no mailman guru either, but these settings changes seem to have let
my recent message "making algorithms in nettle dynamically enumerable"
go through fine, while signed.  So thanks!

&gt; Or is it better to completely disable this content-type filtering?

I've never used content-type filtering -- i'd lean toward turning it off
unless there is a well-understood problem that it fixes (e.g. if a
spammer is targetting the list with a bunch of garbage).  But i'm happy
with it as it currently stands :)

Thanks for the fix,

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110323155921</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-23 15:59:21-0400</timestampReceived><subject>Re: making algorithms in nettle dynamically enumerable</subject><body>


On 03/23/2011 06:12 AM, Niels Möller wrote:
&gt; Thanks. I'm going to commit this. I noticed some incorrect file names in
&gt; the file headers (which I'll fix), and there's no copyright line. I
&gt; guess I should simply add
&gt; 
&gt;   Copyright (C) 2011 Daniel Kahn Gillmor
&gt; 
&gt; at the top of the new files.

This is fine, thanks.  sorry about the incorrect file names -- i hate
being caught copying and pasting! :P

&gt;&gt; I did not see nettle_armor in the docs at all, so i didn't add any docs
&gt;&gt; about nettle_armors[].  Maybe that whole section needs to be written?
&gt; 
&gt; The reason these functionality is undocumented is most likely that I
&gt; wasn't confident that the interface is right, it's not been used very
&gt; much.

That makes sense to me.  I looked at trying to make a
Crypt::Nettle::Armor in the perl bindings to take advantage of it, and
decided that (a) i wasn't exactly sure how i wanted to use it, and (b)
it probably wasn't worth it because perl has good native base64 and
base16 encoding/decoding anyway.

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110329080310</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-03-29 08:03:10-0400</timestampReceived><subject>Re: developing nettle with git</subject><body>

On 03/28/2011 07:47 PM, Daniel Kahn Gillmor wrote:
&gt; On 03/28/2011 09:07 AM, Niels Möller wrote:
&gt;&gt; Maybe it makes things simpler to stick to a single repository for
&gt;&gt; everything (like the current cvs repository)? Is there any compelling
&gt;&gt; reason why nettle must be a separate repository? (If I understand the
&gt;&gt; docs correctly, one could split off a nettle repository later, using
&gt;&gt; git-subtree split).
&gt; I'd personally like to work on nettle without dealing with the entire
&gt; source of lsh and the other components.

That is the case with me as well. Moreover requiring someone to
checkout a different project to access nettle, just gives the impression
that the library is not intended for general use, but is rather an
internal library of that project.

regards,
Nikos

</body></email><email><emailId>20110329095812</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-03-29 09:58:12-0400</timestampReceived><subject>Re: weak-key ciphers and arcfour</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; There are some keys which are even weaker, for example keys beginning
&gt;&gt; with 00 00 FD and 03 FD FC, see this paper:
&gt;&gt;
&gt;&gt; http://impic.org/papers/WeakKeys-report.pdf
&gt;
&gt; This still exploits statistical properties of the first few generated
&gt; bytes, right?

Yes, that's true.

&gt; So if you generate and discard the first 512 or 1024 bytes or so of
&gt; the keystream, the statistics for these keys shouldn't be much
&gt; different from any oter keys, right?

Right.  I think 512 bytes is a bit on the low end these days,
conservative recommendations are now up 3072 bytes:

http://www.users.zetnet.co.uk/hopwood/crypto/scan/cs.html#RC4-drop

Note that the RC4 keystream can be distinguished from random with only
about a few GB's of stream output regardless of how many initial bytes
are dropped.  This suggests to me that there are attacks that will work
regardless of how much initial output you discard.

/Simon

</body></email><email><emailId>20110331153432</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-31 15:34:32-0400</timestampReceived><subject>Re: struct nettle_cipher for weak-key ciphers</subject><body>


On 03/29/2011 03:38 PM, Niels Möller wrote:
&gt; Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:
&gt; 
&gt;&gt; this is quite a bit of code duplication across bindings.
&gt; 
&gt; Could you be a bit more concrete? Which variant of wrappers and weak-key
&gt; interface are you thinking about?

sorry -- i meant that it seemed like it would be unnecessary code
duplication for me to create a perl_nettle_cipher struct that matched
your pike_nettle_cipher.

&gt; Before getting into specifics, I'd like to point out that the structs
&gt; declared in nettle-meta.h are not intended as a fully general algorithm
&gt; framework (to do that, one could, e.g., implement an interface on the
&gt; same level of abstraction as libgcrypt's, on top of nettle).

hm, ok, i see your point.  it sounds like nettle_cipher might be a
reasonable choice for symmetric encryption (where the tools can select
reasonable key sizes, etc), but *not* a reasonable choice for symmetric
decryption (where we have to cope with arbitrary algorithms and keys
foisted on us by the incoming ciphertext).

&gt; This works better for hash algorithm (more regular properties than for
&gt; the ciphers), and in the Pike bindings, I use nettle_hash as is, but I
&gt; don't use nettle_cipher.

Perhaps what i'm wondering is: can we define an cipher abstraction that
exposes the relevant details in C, provides a framework that is suitable
for symmetric decryption, and doesn't violate the minimalistic flavor of
nettle?

I think having something like this in the canonical sources (instead of
implemented outside of nettle) would make it easier to write and
maintain language bindings.

Or, as you said about your Pike bindings: "the implementation is maybe a
bit too complicated for its own good" -- wouldn't it be better to have
the extra implementation complexity in only one place instead of
expecting every binding that uses it to duplicate it?

&gt; I could consider this, but I'm not convinced that it really solves an
&gt; important problem. To me, a language-specific wrapper like, e.g.,
&gt; 
&gt;   void
&gt;   pike_blowfish_set_key(void *ctx,
&gt;   		        ptrdiff_t length, const char *key,
&gt;   		        int force)
&gt;   {
&gt;     if (length &lt; BLOWFISH_MIN_KEY_SIZE || length &gt; BLOWFISH_MAX_KEY_SIZE)
&gt;       Pike_error("BLOWFISH_Info: Bad keysize for BLOWFISH.\n");
&gt;     if (!blowfish_set_key(ctx, length, (const uint8_t *)key) &amp;&amp; !force)
&gt;       Pike_error("BLOWFISH_Info: Key is weak.\n");
&gt;   }
&gt; 
&gt; seems more useful than a language agnostic wrapper
&gt; 
&gt;   int 
&gt;   aes_set_encrypt_key_wrapper (struct aes_ctx *ctx,
&gt;   			       unsigned length, const uint8_t *key)
&gt;   {
&gt;     aes_set_encrypt_key (ctx, length, key);
&gt;     return 1;
&gt;   }

i think you might be comparing apples and oranges here.  I agree that
language-specific error handling is useful.  I'd expect any bindings to
report errors in some sort of native form.  But that doesn't mean that
we shouldn't have a cipher-agnostic interface in C that is capable of
reporting all the standard classes of errors.  But it would be nice for
the authors of the bindings to have a standard way (in C) to get error
reports that is cipher-agnostic.  Otherwise, we'll end up with a bunch
of duplicate cipher-specific code in each binding.

Maybe it's useful to think through what possible errors could come up
from a *_set_key function, and come up with a C interface that would
cover them all in some sort of distinguishable fashion?

So far, i think the errors i've heard are:

 * bad key size

 * weak key

Anything else?  Do we want a way to report the range of acceptable key
sizes for a given cipher?

&gt; which lacks adequate error handling for bad key sizes. And if we extend
&gt; nettle_cipher to include a description of valid key sizes, and/or
&gt; introduce additional error codes for the set_key functions to signal
&gt; different types of bad keys, then we get quite far from the current
&gt; minimalistic flavor of nettle.
&gt; 
&gt;&gt; And here is "2b", a more involved proposal for (2) -- it's a bigger
&gt;&gt; ABI+API change, but the exposed API becomes more normalized:
&gt; 
&gt; I'm not going to do this. The low level cipher interface is not intended
&gt; to normalize away important differences between ciphers.

That seems reasonable to me.  I'm happy to discard proposal 2b.

&gt; BTW: There's another easy alternative which we could call (3): Keep
&gt; nettle_set_key_func as is. Introduce wrappers for des and blowfish which
&gt; just ignore weak keys, and provide nettle_cipher structs using these
&gt; wrappers. Then you get des and blowfish sans weak key detection, using
&gt; the same interface as the other ciphers. I think this would fit
&gt; reasonably with the nettle design principles. Question is: Would anybody
&gt; find it useful? For a general language binding, I would expect that one
&gt; would want to have the possibility to detect weak keys.

Yes, i agree that general language bindings should allow the user to
detect weak keys.

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110210110219</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-10 11:02:19-0400</timestampReceived><subject>GCM updates Re: GCM mode and GMAC</subject><body>

I've done some further updates.

* I've introduced a specialized function gcm_gf_add, used instead of
  memxor when blocks are aligned, and also avoiding looping overhead and
  (if it is inlined, which I think it should be) call overhead. Current
  performance on x86_64 is 28.5 cycles / byte with 4-bit tables (current
  default), and 8.5 cycles / byte with 8-bit tables. Close to a factor
  of two improvement.

* I've introduced a union gcm_block, which is used internally to ensure
  that the gf elements have the right alignment. Tested on sparc32 and
  sparc64 (big endian and pickier about alignment).

* I've split out the message-independent state to a separate struct
  gcm_key, which needs to be passed as argument to all gcm functions.

* I've added a struct gcm_aes_ctx and related functions. This is an
  all-in-one context, including all of the cipher context, the hashing
  subkey, and message state.

* I've added support for IV:s of arbitrary lengths, and added the rest
  of the testcases from http://www.cryptobarn.com/papers/gcm-spec.pdf

* I've simplified the configuration of internal multiplication routines
  a bit, and rewritten the table generation to use just shifts and adds
  (as suggested in http://www.cryptobarn.com/papers/gcm-spec.pdf), which
  means that when tables are used, there's no need to keep the bitwise
  multiplication function which doesn't use tables.

I think the code is stabilizing a bit now.

One naming question: Should gcm_aes_auth be renamed to gcm_aes_update,
for consistency with other hash and mac functions? I'm tempted to do
that.

Regards,
/Niels
  
-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110210122657</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-02-10 12:26:57-0400</timestampReceived><subject>Stream ciphers (was: Re: GCM mode and GMAC)</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Currently, arcfour is the only supported stream cipher (they seem to be
&gt; out of fashion, are thare any other stream ciphers in use? A5 maybe?)

There are newer stream ciphers, mostly due to eSTREAM:

http://www.ecrypt.eu.org/stream/

I don't understand the rationale for stream ciphers today though.  The
traditional argument for stream ciphers was speed but you get 10GBps+
with nice modes like AES-GCM.  Further, you can build a secure key
stream generator from any secure block cipher (see for example [1]).

Maybe the argument today is cost of hardware, but for that to be
effective in the long run you have to beat Moore's law.

/Simon

[1] http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/kfb/kfb-spec.pdf

</body></email><email><emailId>20110210123819</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-02-10 12:38:19-0400</timestampReceived><subject>Re: GCM mode and GMAC</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; So the question is, should we decide that nettle_cipher is för block
&gt; ciphers only (where the encrypt and decrypt functions don't change any
&gt; state )? Fitting arcfour and block ciphers into the same
&gt; abstraction doesn't make much sense anyway, since they should be used
&gt; very differently. Then we can make the context argument const for
&gt; nettle_crypt_func, but we'd also have to delete
&gt;
&gt;   extern const struct nettle_cipher nettle_arcfour128;
&gt;
&gt; or replace it with something else, which is an incompatible interface
&gt; change. As long as it's the only supported stream cipher, it doesn't
&gt; make much sense to me create a new general stream cipher construction.

Breaking API compatibility is painful.  Other libraries like libgcrypt
also try to use the same interface for both stream ciphers and block
ciphers too.  However, in my experience this makes things difficult at a
higher level -- the distinction perculate up because stream ciphers
doesn't (for example) have a block length so you either have to say it
has a block length of 1 byte (or 1 bit if you support bit-lengths) which
can cause problems if you want to do MAC or other processing on a
block-by-block basis (MAC:ing each byte is not a good idea..).

So I would support making stream ciphers a different beast than block
ciphers as far as the API goes, unless the API change is too painful.

If we had used a object oriented language, there could be a super-class
"cipher" and two sub-classes "block cipher" and "stream cipher".  Then
some functions could take any "cipher" and some (like GCM) could take
any "block cipher".  Fortunately we aren't using OO here though. :-)

/Simon

</body></email><email><emailId>20110321153503</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-21 15:35:03-0400</timestampReceived><subject>making algorithms in nettle dynamically enumerable</subject><body>

Hi Nettle folks--

In the course of writing Crypt::Nettle, it occurs to me that i'm going
to need to update the list of available ciphers and digests for each new
version of nettle that comes out.  This also means that newer versions
of the perl bindings won't work by default against older versions of
libnettle, which seems like it might make the perl bindings less useful
for people who are stuck (for whatever reason) with an older version of
libnettle.

The attached patch would present an interface to dynamically enumerate
the available ciphers and digest algorithms (and armor methods)
supported by the current version of libnettle.  bindings built against
this meta-interface wouldn't need to be closely tied to any particular
version of nettle, and so could be both forward- and backward-compatible.

I'd be happy with any other interface that would give me the same
effect, of course, and i'm not convinced that this is the best way to do
it -- it just seemed the simplest in the current implementation.

It would also be nice to make a similar interface to genericize cipher
modes (ECB, CBC, CTR, and GCM), if that's possible; i'm not sure what
the best approach is for doing that.

Feedback welcome, of course.

	--dkg



["meta-lists.patch" (text/x-diff)]

diff --git a/nettle/Makefile.in b/nettle/Makefile.in
index 1020fd7..06accb4 100644
--- a/nettle/Makefile.in
+++ b/nettle/Makefile.in
@@ -75,7 +75,8 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 twofish.c twofish-meta.c \
 		 yarrow256.c yarrow_key_event.c \
 		 buffer.c buffer-init.c realloc.c \
-		 nettle-internal.c write-be32.c
+		 nettle-meta.c \
+		 nettle-internal.c write-be32.c 
 
 hogweed_SOURCES = sexp.c sexp-format.c \
 		  sexp-transport.c sexp-transport-format.c \
diff --git a/nettle/nettle-meta.c b/nettle/nettle-meta.c
new file mode 100644
index 0000000..184abc1
--- /dev/null
+++ b/nettle/nettle-meta.c
@@ -0,0 +1,69 @@
+/* nettle-meta.c */
+
+/* nettle, low-level cryptographics library
+ *
+ * This file contains an aggregate list of all algorithms
+ * generically-expressed by nettle.  It can be useful for exposing
+ * algorithm lists to higher-level languages or providing user choices.
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+const struct nettle_armor *nettle_armors[] = {
+  &amp;nettle_base64,
+  &amp;nettle_base16,
+  NULL
+};
+
+const struct nettle_hash *nettle_hashes[] = {
+  &amp;nettle_md2,
+  &amp;nettle_md4,
+  &amp;nettle_md5,
+  &amp;nettle_sha1,
+  &amp;nettle_sha224,
+  &amp;nettle_sha256,
+  &amp;nettle_sha384,
+  &amp;nettle_sha512,
+  NULL
+};
+
+const struct nettle_cipher *nettle_ciphers[] = {
+  &amp;nettle_aes128,
+  &amp;nettle_aes192,
+  &amp;nettle_aes256,
+  &amp;nettle_arcfour128,
+  &amp;nettle_camellia128,
+  &amp;nettle_camellia192,
+  &amp;nettle_camellia256,
+  &amp;nettle_cast128,
+  &amp;nettle_serpent128,
+  &amp;nettle_serpent192,
+  &amp;nettle_serpent256,
+  &amp;nettle_twofish128,
+  &amp;nettle_twofish192,
+  &amp;nettle_twofish256,
+  &amp;nettle_arctwo40,
+  &amp;nettle_arctwo64,
+  &amp;nettle_arctwo128,
+  &amp;nettle_arctwo_gutmann128,
+  NULL
+};
diff --git a/nettle/nettle-meta.h b/nettle/nettle-meta.h
index 2a00954..6cbb0a6 100644
--- a/nettle/nettle-meta.h
+++ b/nettle/nettle-meta.h
@@ -96,6 +96,9 @@ struct nettle_cipher
   (nettle_crypt_func *) name##_decrypt,			\
 }
 
+/* null-terminated list of ciphers implemented by this version of nettle */
+extern const struct nettle_cipher *nettle_ciphers[];
+
 extern const struct nettle_cipher nettle_aes128;
 extern const struct nettle_cipher nettle_aes192;
 extern const struct nettle_cipher nettle_aes256;
@@ -149,6 +152,9 @@ struct nettle_hash
  (nettle_hash_digest_func *) name##_digest	\
 } 
 
+/* null-terminated list of digests implemented by this version of nettle */
+extern const struct nettle_hash *nettle_hashes[];
+
 extern const struct nettle_hash nettle_md2;
 extern const struct nettle_hash nettle_md4;
 extern const struct nettle_hash nettle_md5;
@@ -207,6 +213,9 @@ struct nettle_armor
   (nettle_armor_decode_final_func *) name##_decode_final,	\
 }
 
+/* null-terminated list of armor schemes implemented by this version of nettle */
+extern const struct nettle_armor *nettle_armors[];
+
 extern const struct nettle_armor nettle_base64;
 extern const struct nettle_armor nettle_base16;
 


</body></email><email><emailId>20110321182346</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-03-21 18:23:46-0400</timestampReceived><subject>Re: making algorithms in nettle dynamically enumerable</subject><body>

One comment is that it is more difficult to export variables portably
than functions (especially Windows), so sometimes it is preferred to
export a function that returns a static array than exporting the static
array itself.  However, I think nettle already relies on exporting
variables so then this point is moot.  I support the patch otherwise.

/Simon

</body></email><email><emailId>20110321190458</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-21 19:04:58-0400</timestampReceived><subject>Re: making algorithms in nettle dynamically enumerable</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; This also means that newer versions of the perl bindings won't work by
&gt; default against older versions of libnettle,

I don't know how the build system for the perl bindings is setup, but
using something like autoconf should make it easier if you really want
to support multiple nettle versions, with or without public key support.

&gt; The attached patch would present an interface to dynamically enumerate
&gt; the available ciphers and digest algorithms (and armor methods)
&gt; supported by the current version of libnettle. 

The need for this hasn't occured to me, but I see the point. What do
others think?

&gt; bindings built against
&gt; this meta-interface wouldn't need to be closely tied to any particular
&gt; version of nettle, and so could be both forward- and backward-compatible.

But some other parts of the nettle interfaces have not been as stable
between releases, so it doesn't solve the problem completely.

&gt; I'd be happy with any other interface that would give me the same
&gt; effect, of course, and i'm not convinced that this is the best way to do
&gt; it -- it just seemed the simplest in the current implementation.

Right, it's about as simple as one can get, and I like that. I think one
level of indirection like you do is desirable, for linking reasons. 

One may want to think about fancy hardware accelerators (currently not
supported at all), which would require some runtime check on what's
available.

&gt; It would also be nice to make a similar interface to genericize cipher
&gt; modes (ECB, CBC, CTR, and GCM), if that's possible; i'm not sure what
&gt; the best approach is for doing that.

I'm not sure this is as useful. The modes have different properties and
generally don't work well as substitutes for each other. And at least,
the list is expected to be expanded less frequently than the list of
hashes or block ciphers.

Some comments on the implementation:

&gt; +const struct nettle_armor *nettle_armors[] = {
&gt; +  &amp;nettle_base64,
&gt; +  &amp;nettle_base16,
&gt; +  NULL
&gt; +};

The typing should be something like

  const struct nettle_armor * const nettle_armors[]

to say that both the list itself and the pointed to structures are
const.

Also, I think there should be one compilation unit and object file per
list, so that it's, for example, possible to statically link with the
list of all hash algorithms without also dragging in all ciphers.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110321194222</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-21 19:42:22-0400</timestampReceived><subject>Re: making algorithms in nettle dynamically enumerable</subject><body>


On 03/21/2011 03:04 PM, Niels Möller wrote:
&gt; I don't know how the build system for the perl bindings is setup, but
&gt; using something like autoconf should make it easier if you really want
&gt; to support multiple nettle versions, with or without public key support.

that's an interesting suggestion -- i'm afraid i don't know enough about
integrating autoconf with perlxs to know how to go down that path
without a more research, but i'll consider it for the future.  It would
only allow backward-compatibility, though -- not forward-compatibility.
 That is: if you built Crypt::Nettle against libnettle version X, and
then upgraded to libnettle version Y, you'd have to also re-build
Crypt::Nettle.

That's not a horrible tradeoff, i guess.

&gt; But some other parts of the nettle interfaces have not been as stable
&gt; between releases, so it doesn't solve the problem completely.

yes, that's true -- i'm proposing this just for the ciphers and hashes
at the moment.

&gt; One may want to think about fancy hardware accelerators (currently not
&gt; supported at all), which would require some runtime check on what's
&gt; available.

that's an interesting part i hadn't considered.  I'm not certain how to
represent such a change, but i like the idea that one could discover
available/supported hardware dynamically somehow.  Would supporting that
use case suggest a different API?

&gt; I'm not sure this is as useful. The modes have different properties and
&gt; generally don't work well as substitutes for each other. And at least,
&gt; the list is expected to be expanded less frequently than the list of
&gt; hashes or block ciphers.

OK.  Maybe this is a good target for the autoconf approach you mentioned
above.

&gt; Some comments on the implementation:
&gt; 
&gt;&gt; +const struct nettle_armor *nettle_armors[] = {
&gt;&gt; +  &amp;nettle_base64,
&gt;&gt; +  &amp;nettle_base16,
&gt;&gt; +  NULL
&gt;&gt; +};
&gt; 
&gt; The typing should be something like
&gt; 
&gt;   const struct nettle_armor * const nettle_armors[]
&gt; 
&gt; to say that both the list itself and the pointed to structures are
&gt; const.

Yes, you are right, thanks!

&gt; Also, I think there should be one compilation unit and object file per
&gt; list, so that it's, for example, possible to statically link with the
&gt; list of all hash algorithms without also dragging in all ciphers.

Is there any reason to use this approach for statically-linked tools?
Maybe for UI or hardware discoverability, i guess.  It certainly
wouldn't help in terms of software discoverability or forward/backward
compatibility in a statically-linked library.

Do you want me to submit a modified patch with these changes?

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110321200741</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-21 20:07:41-0400</timestampReceived><subject>Re: making algorithms in nettle dynamically enumerable</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; On 03/21/2011 03:04 PM, Niels Möller wrote:

&gt;&gt; One may want to think about fancy hardware accelerators (currently not
&gt;&gt; supported at all), which would require some runtime check on what's
&gt;&gt; available.
&gt;
&gt; that's an interesting part i hadn't considered.  I'm not certain how to
&gt; represent such a change, but i like the idea that one could discover
&gt; available/supported hardware dynamically somehow.  Would supporting that
&gt; use case suggest a different API?

To add hardware acceleration, one would need to either detect hardware
and build a list automatically at loadtime, or have a function to build
and return the list. It can no longer be a compile-time constant.

But I think the API you suggested is good enough for now.

It's hard to guess what really interface is needed before the hardware
support exists, and I'd rather not define something overly complicated
just because it might possibly be needed later.

&gt;&gt; Also, I think there should be one compilation unit and object file per
&gt;&gt; list, so that it's, for example, possible to statically link with the
&gt;&gt; list of all hash algorithms without also dragging in all ciphers.

&gt; Is there any reason to use this approach for statically-linked tools?

The general principle is that independent functionality should be in
separate object files. I don't think this case is an exception. To be a
little more concrete, say you want a tool that can compute a hash sum
using any algorithm supported by nettle, and you then want that tool on
some constrained system with statically linked binaries, or included in
a statically linked busybox executable.

&gt; Do you want me to submit a modified patch with these changes?

That would be nice. Documentation would also be appreciated (it should
probably mention why des is not on the list, but I don't think it needs
to be terribly many words). Test cases are perhaps not essential for
this, but maybe you can think of some relevant test?

It may also be good to review the naming. Until now, the name attribute
in nettle_cipher and similar structs has been intended to be displayed
for informational purposes only. With your interface, users will be
invited to use it as an identifier to look up an algorithm. How do you
intend to use that name in the perl bindings?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110321203256</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-21 20:32:56-0400</timestampReceived><subject>Re: making algorithms in nettle dynamically enumerable</subject><body>


On 03/21/2011 04:07 PM, Niels Möller wrote:
&gt; But I think the API you suggested is good enough for now.

ok.

&gt; The general principle is that independent functionality should be in
&gt; separate object files. I don't think this case is an exception. To be a
&gt; little more concrete, say you want a tool that can compute a hash sum
&gt; using any algorithm supported by nettle, and you then want that tool on
&gt; some constrained system with statically linked binaries, or included in
&gt; a statically linked busybox executable.

Gotcha, this is a useful way to think about things.  Thanks for your
explanation.

&gt; That would be nice. Documentation would also be appreciated (it should
&gt; probably mention why des is not on the list, but I don't think it needs
&gt; to be terribly many words). Test cases are perhaps not essential for
&gt; this, but maybe you can think of some relevant test?

i'll work on a revised patch with docs and a test if i can figure out a
test as well.

&gt; It may also be good to review the naming. Until now, the name attribute
&gt; in nettle_cipher and similar structs has been intended to be displayed
&gt; for informational purposes only. With your interface, users will be
&gt; invited to use it as an identifier to look up an algorithm. How do you
&gt; intend to use that name in the perl bindings?

The perl bindings already expose an enumeration + lookup interface, but
i've implemented it myself outside of nettle.  I'll be happy to keep the
existing perl API but drop the Crypt::Nettle implementation of it in
favor of one in the main library, though.

fwiw, i have no objections to the current naming scheme.  I'll probably
do a case-insensitive match against the exported names.

Your earlier suggestion that the user should be able to say "aes" and
then we would select an algorithm based on the supplied keysize suggests
a particular simple naming convention, where the keysize is always a
strict suffix to the algorithm name.

That is, a library might use a function by comparing the requested
algorithm name as a strict prefix with the size of the keylength.

I suppose that selection function could be part of libnettle as well,
instead of making each binding report it.  something like:

const nettle_cipher*
nettle_select_cipher(const char* algoname, int keylength = 0);

This would not remove the need for the other API, though, since it
doesn't provide algorithm enumeration.

I can try to include such an implementation in the revised patch if
y'all think it would be useful.

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110322210119</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-22 21:01:19-0400</timestampReceived><subject>developing nettle with git</subject><body>


hi folks--

I'm managing my nettle work via git.  I've extracted the cvs history of
the upstream repo (nettle-only -- i'd rather not deal with all of lsh)
and imported it into git.

OF at all possible I plan to keep the "origin" branch up-to-date with
the upstream CVS.

Anyone who prefers to use git is welcome to use my repo as a jumping off
point so you don't have to hassle with git cvsimport yourself.

You can find it here:

 git clone git://lair.fifthhorseman.net/~dkg/nettle

I would be happy to have nettle sources tracked as a separate project
from lsh, just to make it easier for people to hack on it.

Niels, if you want to consider transitioning nettle sources out of the
the lsh repository and into something like git (or any other dvcs), i'd
be happy to help you do that.

Regards,

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110324214052</emailId><senderName>"Hoyt, David"</senderName><senderEmail>hoyt6@llnl.gov</senderEmail><timestampReceived>2011-03-24 21:40:52-0400</timestampReceived><subject>RE: developing nettle with git</subject><body>

&gt; Niels, if you want to consider transitioning nettle sources out of the the lsh repository and into something like git

+1 to that.

</body></email><email><emailId>20110325104505</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-25 10:45:05-0400</timestampReceived><subject>Re: developing nettle with git</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; Niels, if you want to consider transitioning nettle sources out of the
&gt; the lsh repository and into something like git (or any other dvcs), i'd
&gt; be happy to help you do that.

I'm certainly considering it; it would be nice to get away from cvs. I
was involved in the conversion of the gmp repository to mercurial just a
few years ago. That was fairly easy, only serious obstacle was that we
discovered a rcs file where some early revision was corrupt. After
purging that broken revision with cvs admin, things worked well.

But to convert nettle and lsh, there are some issues:

1. I'm familiar with mercurial, but I hear that git is a better choice
   these days, so maybe I should go with git instead. And then I have
   some new stuff to learn.

2. Currently, several more-or-less independent projects are in the lsh
   cvs tree. Besides nettle, there's libspki, argp, sftp. So how should
   this be split up? As far as I understand, neither hg nor git have
   any well-working analogue to cvs modules, which would otherwise have
   been a natural choice.

   Also, I guess this splitting of the repository complicates migration
   a bit.

3. Then there's the shared files which are symlinked by the top-level
   lsh/.bootstrap script. I guess with a split it will be unavoidable to
   have multiple separately version controlled copies of those files.

I guess it's possible to start with migrating nettle from cvs, and leave
the rest of the tree for later. But I'm not sure that's a good way to do
it.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110329042442</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-29 04:24:42-0400</timestampReceived><subject>weak-key ciphers and arcfour</subject><body>


hi nettle folks--

the nettle docs say:

&gt; In Nettle, most key setup functions have no return value, but
&gt; for ciphers with weak keys, the return value indicates whether or not
&gt; the given key is weak. 

 [...]

&gt; A problem is that the key
&gt; setup of ARCFOUR is quite weak, you should never use keys with
&gt; structure, keys that are ordinary passwords, or sequences of keys like
&gt; ``secret:1'', ``secret:2'', ...

 [...]

&gt; void arcfour_set_key (struct arcfour_ctx *ctx, unsigned length, const uint8_t *key)
&gt; Initialize the cipher. The same function is used for both encryption and
&gt; decryption. 

Put together, these three statements seem contradictory.

If arcfour has weak keys, shouldn't arcfour_set_key return an int
indicating whether the key is considered weak (like the key setup
functions for BLOWFISH, DES, and DES3 do)?

Is the problem that there is no clear way to determine if an arcfour key
is weak?

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110329051922</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-29 05:19:22-0400</timestampReceived><subject>Re: weak-key ciphers and arcfour</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt;&gt; A problem is that the key
&gt;&gt; setup of ARCFOUR is quite weak, you should never use keys with
&gt;&gt; structure, keys that are ordinary passwords, or sequences of keys like
&gt;&gt; ``secret:1'', ``secret:2'', ...

The problem with arcfour is not that some particular keys are
unexpectedly weak, but that the key bits are not spread out very well
into the internal state (sorry if this description is a bit vague; my
understanding is also a bit vague...).

So there's unexpectedly high correlation between the first bytes of the
key and the first bytes of the generated key stream, and I think there's
also undesired correlation between key streams for close keys.

I think the recommendations in the manual (hash the key first, and
discard the initial bytes of the key stream) are still adequate.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110329061830</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-29 06:18:30-0400</timestampReceived><subject>struct nettle_cipher for weak-key ciphers</subject><body>


hi nettle folks--

now that Crypt::Nettle seems effective and functional, i'm starting to
look at using it in other systems i'm working on.  Suddenly, i realize
i'm missing access to 3DES and BLOWFISH, which i find i actually want :/

I'm missing them because there is no struct nettle_cipher for these
algorithms (or for DES, for that matter, though i care less about DES).

I seem to have a few options:

 0) Crypt::Nettle could write unique interfaces to those ciphers and
expose them to the user of the perl module as (for example)
Crypt::Nettle::Cipher::3DES and Crypt::Nettle::Cipher::Blowfish .  this
breaks symmetry with the rest of the interface, though.

 1) Crypt::Nettle could create its own struct nettle_cipher objects for
these ciphers, wrapping the weak key checking in some code of that
belongs to the perl module

 2) I could propose that nettle to create struct nettle_cipher objects
for these ciphers directly.


I prefer (1) or (2) because they'll keep a simple interface for
Crypt::Nettle.  I'm not sure how to do (2) without breaking ABI in
nettle somehow (or losing the weak-key error checking).  But going with
option (1) seems likely to cause code duplication in any other
higher-level bindings that use the struct nettle_cipher objects to
present a normalized interface.

Any thoughts on how i should proceed?  I can certainly do (1)
independently of libnettle itself, but if there's a way to handle (2)
more cleanly than i've been able to imagine thus far, i'd be happy to
hear about it.

Or, am i barking up the wrong tree entirely?  I'm imagining (for
example) a user who has in their possession a symmetrically-encrypted
message that they happen to know the key for.  The cipher used was one
of the "weak-key" ciphers, and it's even possible that the key is in
fact a weak key.  The user should still be able to decrypt the message
using Crypt::Nettle (or any other binding).

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110329075929</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-03-29 07:59:29-0400</timestampReceived><subject>Re: struct nettle_cipher for weak-key ciphers</subject><body>

On 03/29/2011 08:18 AM, Daniel Kahn Gillmor wrote:

&gt; now that Crypt::Nettle seems effective and functional, i'm starting to
&gt; look at using it in other systems i'm working on.  Suddenly, i realize
&gt; i'm missing access to 3DES and BLOWFISH, which i find i actually want :/
&gt; I'm missing them because there is no struct nettle_cipher for these
&gt; algorithms (or for DES, for that matter, though i care less about DES).
&gt; I seem to have a few options:
&gt; 
&gt;  0) Crypt::Nettle could write unique interfaces to those ciphers and
&gt; expose them to the user of the perl module as (for example)
&gt; Crypt::Nettle::Cipher::3DES and Crypt::Nettle::Cipher::Blowfish .  this
&gt; breaks symmetry with the rest of the interface, though.
&gt;  1) Crypt::Nettle could create its own struct nettle_cipher objects for
&gt; these ciphers, wrapping the weak key checking in some code of that
&gt; belongs to the perl module
&gt;  2) I could propose that nettle to create struct nettle_cipher objects
&gt; for these ciphers directly.
&gt; I prefer (1) or (2) because they'll keep a simple interface for
&gt; Crypt::Nettle.  I'm not sure how to do (2) without breaking ABI in
&gt; nettle somehow (or losing the weak-key error checking). 

I'd also prefer (2), because it reduces work for nettle consumers.
For gnutls I didn't use nettle_cipher at all and created my own
wrappers, because nettle cipher works only with few ciphers.
At least for TLS, weak key checking is not that important due to
low probability of selecting one, to be of any practical concern.

regards,
Nikos

</body></email><email><emailId>20110222220714</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-02-22 22:07:14-0400</timestampReceived><subject>nettle documentation tweaks?</subject><body>


hi nettle folks--

i've been reading the latest nettle docs [0], and i wanted to say that
they are excellent.  Clear explanations, and useful contextual help
about how various crypto primitives can be used in real-world settings
as well.  Thanks for this!

I have two nit-picks that i'd like to share in hopes of making excellent
documentation even better.

 0) avoid replay attacks in pubkey authorization example.

Section 6.5 contains the following paragraph:

&gt; Besides signing meaningful messages, digital signatures can be used for
&gt; authorization. A server can be configured with a public key, such that
&gt; any client that connects to the service is given a random nonce
&gt; message. If the server gets a reply with a correct signature matching
&gt; the nonce message and the configured public key, the client is granted
&gt; access. So the configuration of the server can be understood as "grant
&gt; access to whoever knows the private key corresponding to this
&gt; particular public key, and to no others". 


This simple scheme is actually vulnerable to a replay attack: an
man-in-the-middle attacker can pose as the service to the user while
simultaneously connecting to the service directly.  The attacker gets a
nonce from the server, passes it to the user for signing, returns the
user's response to the service, and gains access.

One way to avoid this is to ensure that the "random nonce" to be signed
by the user is actually a negotiated value that neither party can fully
control.

I recognize that this documentation shouldn't go into deep detail here,
but i've seen real-world attempts to implement cryptosystems that are
subject to this kind of replay attack :(. i think it would be a good
idea to warn against it somehow.


 1) "bad things may happen", "a few subtle issues", etc. should have
outbound links

There are several places in the docs that mention potential security
concerns implementators should be aware of.  For example, the remark
about CBC providing "information leakage" could link to
http://www.kb.cert.org/vuls/id/958563

Again, i'm not pushing for major changes or lots of intrusive commentary
here (and i don't know how difficult it is to make outbound links in the
documentation system used by nettle) but it would make already good docs
even better.


Thanks again for this library!

Regards,

	--dkg

[0] http://www.lysator.liu.se/~nisse/nettle/nettle.html#Cipher-modes



</body></email><email><emailId>20110329090203</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-29 09:02:03-0400</timestampReceived><subject>Re: struct nettle_cipher for weak-key ciphers</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; I seem to have a few options:
&gt;
&gt;  0) Crypt::Nettle could write unique interfaces to those ciphers and
&gt; expose them to the user of the perl module as (for example)
&gt; Crypt::Nettle::Cipher::3DES and Crypt::Nettle::Cipher::Blowfish .  this
&gt; breaks symmetry with the rest of the interface, though.
&gt;
&gt;  1) Crypt::Nettle could create its own struct nettle_cipher objects for
&gt; these ciphers, wrapping the weak key checking in some code of that
&gt; belongs to the perl module
&gt;
&gt;  2) I could propose that nettle to create struct nettle_cipher objects
&gt; for these ciphers directly.

I recommend (1). The way this is done in the Pike bindings (the
implementation is maybe a bit too complicated for its own good), I use a
struct pike_cipher very similar to nettle_cipher,

  /* Calls Pike_error on errors */ 
  typedef void (*pike_nettle_set_key_func)(void *ctx,
  					 ptrdiff_t length, const char *key,
  					 /* Force means to use key even
                                           if it is weak */
  					 int force);
  
  struct pike_cipher
  {
    const char *name;
    
    unsigned context_size;
  
    unsigned block_size;
  
    /* Suggested key size; other sizes are sometimes possible. */
    unsigned key_size;
  
    pike_nettle_set_key_func set_encrypt_key;
    pike_nettle_set_key_func set_decrypt_key;
  
    nettle_crypt_func encrypt;
    nettle_crypt_func decrypt;
  };

Here, the pike_nettle_set_key_func differs from nettle_set_key_func is
two ways, related to error handling:

1. It checks if the key size is appropriate for the algorithm, and
   raises an exception if not (in contrast, a bad key size passed to the
   nettle set_key function would abort the process with an assertion
   failure).

2. The behaviour for weak keys. If the force argument is zero (for Pike
   calls, it's an optional argument and omitting it also means zero), a
   weak key results in an exception. If the force argument is non-zero,
   a weak key is not not considered an error.

In these bindings, unlike yours, each cipher like AES is a single class,
with multiple supported key sizes. So all ciphers need their own set_key
wrapper for proper error checking.

In your case, where you have one separate class per possible key size, I
think you could do something similar and still use the new enumeration
interface for the "normal" algorithms. 

If you're fine with either having weak keys always raise an exception or
always be accepted, you could write set_key wrappers for the affected
ciphers which do precisely that and which adhere to the
nettle_set_key_func interface (note that des_set_key and des3_set_key
don't have a key size argument so they need wrappers also for that
reason). If you want it to be configurable, things get a bit more
complicated and you may need your own struct perl_cipher to extend
struct nettle_cipher (you could still enumerate the available
nettle_cipher and convert each to a corresponding perl_cipher). Or you
could just define separate classes with and without weak key checking.

There will be a little code duplication. But there ought to be code
*somewhere* to implements the language-specific pieces of the interface,
such as exception based error handling, and new features, like, e.g.,
the optional force argument above.

&gt; Or, am i barking up the wrong tree entirely?  I'm imagining (for
&gt; example) a user who has in their possession a symmetrically-encrypted
&gt; message that they happen to know the key for.  The cipher used was one
&gt; of the "weak-key" ciphers, and it's even possible that the key is in
&gt; fact a weak key.  The user should still be able to decrypt the message
&gt; using Crypt::Nettle (or any other binding).

I agree that there are certainly cases where you don't want to treat
weak keys as errors. Even though I think it makes sense to have a
default behaviour which treats weak keys as errors.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110329090831</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-29 09:08:31-0400</timestampReceived><subject>Re: struct nettle_cipher for weak-key ciphers</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; At least for TLS, weak key checking is not that important due to
&gt; low probability of selecting one, to be of any practical concern.

In lsh, I disconnect when a weak key is detected. 

The problem with relying on "low probability" is that unless you
generate the random key all by yourself, you need that probability to be
low also in the presence of any possible attacks on the key agreement
protocol. The analysis needed to rule out such attacks may cause some
headache, which you can avoid by simply refusing to use weak keys if
they ever occur.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110329150713</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2011-03-29 15:07:13-0400</timestampReceived><subject>Re: struct nettle_cipher for weak-key ciphers</subject><body>

On 03/29/2011 11:08 AM, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt;&gt; At least for TLS, weak key checking is not that important due to
&gt;&gt; low probability of selecting one, to be of any practical concern.
&gt; In lsh, I disconnect when a weak key is detected. 
&gt; The problem with relying on "low probability" is that unless you
&gt; generate the random key all by yourself, you need that probability to be
&gt; low also in the presence of any possible attacks on the key agreement
&gt; protocol. The analysis needed to rule out such attacks may cause some
&gt; headache, which you can avoid by simply refusing to use weak keys if
&gt; they ever occur.

In TLS the generated keys do not only depend on the key exchange
but also on several bytes of randomness contributed by both
peers. Even a key exchange with a malicious party, would produce
random keys with a little more than 224 bits of randomness.

Moreover if you handle weak keys, you should include it into
the protocol, i.e. do you restart the key exchange once
a weak key is detected, or you just terminate the handshake?
TLS has no provisions for a re-handshake once a weak-key
is detected.

regards,
Nikos

</body></email><email><emailId>20110329154741</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-29 15:47:41-0400</timestampReceived><subject>Re: struct nettle_cipher for weak-key ciphers</subject><body>


On 03/29/2011 05:02 AM, Niels M=C3=B6ller wrote:
&gt; If you're fine with either having weak keys always raise an exception o=
r
&gt; always be accepted, you could write set_key wrappers for the affected
&gt; ciphers which do precisely that and which adhere to the
&gt; nettle_set_key_func interface (note that des_set_key and des3_set_key
&gt; don't have a key size argument so they need wrappers also for that
&gt; reason). If you want it to be configurable, things get a bit more
&gt; complicated and you may need your own struct perl_cipher to extend
&gt; struct nettle_cipher (you could still enumerate the available
&gt; nettle_cipher and convert each to a corresponding perl_cipher). Or you
&gt; could just define separate classes with and without weak key checking.

this is quite a bit of code duplication across bindings.  I'd rather
just expose the fact of a weak key to the caller directly (whether
through exceptions, return codes, or some other mechanism.

 -----

Here's a proposal for (2) which i'll name "2a";  I believe it does
involve an ABI+API bump to libnettle, but should allow for a reduction
in the amount of code for all bindings (which in turn might make the
creation of future bindings more likely, thereby getting the nettle
goodness out to more people).  I know i'd be more likely to maintain
additional bindings if they are smaller/simpler.

redefine nettle_set_key_func to return an int instead of a void:

typedef int nettle_set_key_func(void *ctx,
				unsigned length,
				const uint8_t *key);

For the ciphers which have no weak keys, create wrapper functions around
their set_key functions which always return 1, and use those wrapper
functions to populate the standard nettle_cipher objects.

Add a wrapper function around des_set_key and des3_set_key that includes
a key length argument; add corresponding nettle_cipher objects for des
and des3.

Add new nettle_cipher objects for the remaining weak-key ciphers (only
blowfish?) without the wrapping functions.

 -----

And here is "2b", a more involved proposal for (2) -- it's a bigger
ABI+API change, but the exposed API becomes more normalized:

Redefine nettle_set_key_func as in "2a"; and also change all the
*_set_key() functions in nettle to return an int directly.  ciphers with
no weak keys will naturally always return 1.

Change des_set_key() and des3_set_key() to take length arguments like
every other *_set_key() function.

Add new nettle_cipher objects for all missing ciphers.

 -----

I understand the natural reluctance to make an ABI bump, and i think
it's good to do so carefully (and i regret that i didn't make this
proposal before the recent ABI bump to get it all done together).  But i
think the tradeoff in terms of simplicity of new bindings is an overall
positive one.

In either proposal, bindings still retain the ability to report weak
keys using language-specific mechanisms/error handling.

I'd be happy to write a patch for either 2a or 2b, if there was a chance
that they would be accepted upstream.  Either one would make me happy
(and more willing to step up to writing python bindings, which i'd like
to have on my plate for the future).

Regards,

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110329193831</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-29 19:38:31-0400</timestampReceived><subject>Re: struct nettle_cipher for weak-key ciphers</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; this is quite a bit of code duplication across bindings.

Could you be a bit more concrete? Which variant of wrappers and weak-key
interface are you thinking about?

Before getting into specifics, I'd like to point out that the structs
declared in nettle-meta.h are not intended as a fully general algorithm
framework (to do that, one could, e.g., implement an interface on the
same level of abstraction as libgcrypt's, on top of nettle).

Besides missing des and blowfish, it doesn't provide a nettle_cipher
struct for every possible key size for all algorithms, and there's also
no mechanism to query possible key sizes. To me, the lack of a struct
nettle_cipher for des and blowfish-128 is comparable to the lack of
struct nettle_cipher for cast, arcfour and blowfish with 80 bit key. And
to support them all in a reasonable way would require something quite
different from the current struct nettle_cipher.

nettle-meta.h is intended to provide the simplest algorithm abstraction
possible, to cover the simple cases. And also as inspiration for
extended frameworks, either more general or more application specific.

This works better for hash algorithm (more regular properties than for
the ciphers), and in the Pike bindings, I use nettle_hash as is, but I
don't use nettle_cipher.

&gt; Here's a proposal for (2) which i'll name "2a";  I believe it does
&gt; involve an ABI+API bump to libnettle, but should allow for a reduction
&gt; in the amount of code for all bindings (which in turn might make the
&gt; creation of future bindings more likely, thereby getting the nettle
&gt; goodness out to more people).  I know i'd be more likely to maintain
&gt; additional bindings if they are smaller/simpler.
&gt;
&gt; redefine nettle_set_key_func to return an int instead of a void:
&gt;
&gt; typedef int nettle_set_key_func(void *ctx,
&gt; 				unsigned length,
&gt; 				const uint8_t *key);
&gt;
&gt; For the ciphers which have no weak keys, create wrapper functions around
&gt; their set_key functions which always return 1, and use those wrapper
&gt; functions to populate the standard nettle_cipher objects.
&gt;
&gt; Add a wrapper function around des_set_key and des3_set_key that includes
&gt; a key length argument; add corresponding nettle_cipher objects for des
&gt; and des3.

I could consider this, but I'm not convinced that it really solves an
important problem. To me, a language-specific wrapper like, e.g.,

  void
  pike_blowfish_set_key(void *ctx,
  		        ptrdiff_t length, const char *key,
  		        int force)
  {
    if (length &lt; BLOWFISH_MIN_KEY_SIZE || length &gt; BLOWFISH_MAX_KEY_SIZE)
      Pike_error("BLOWFISH_Info: Bad keysize for BLOWFISH.\n");
    if (!blowfish_set_key(ctx, length, (const uint8_t *)key) &amp;&amp; !force)
      Pike_error("BLOWFISH_Info: Key is weak.\n");
  }

seems more useful than a language agnostic wrapper

  int 
  aes_set_encrypt_key_wrapper (struct aes_ctx *ctx,
  			       unsigned length, const uint8_t *key)
  {
    aes_set_encrypt_key (ctx, length, key);
    return 1;
  }

which lacks adequate error handling for bad key sizes. And if we extend
nettle_cipher to include a description of valid key sizes, and/or
introduce additional error codes for the set_key functions to signal
different types of bad keys, then we get quite far from the current
minimalistic flavor of nettle.

&gt; And here is "2b", a more involved proposal for (2) -- it's a bigger
&gt; ABI+API change, but the exposed API becomes more normalized:

I'm not going to do this. The low level cipher interface is not intended
to normalize away important differences between ciphers.

In particular, 

* I don't like dummy return values (which are either unnecessarily
  checked, making code ugly, or get people into the habit if ignoring
  return values). "Can't fail" (except by abort()) is a very simplifying
  property of a function, and then it shouldn't return an error code.

* I also don't like dummy function arguments, used like

  int des_set_key (struct des_ctx *ctx, 
		   unsigned length, const uint8_t *key)
  {
    assert (length == DES_KEY_SIZE);
    ...
  }

  (except in an optional wrapper function, where the above would be the
  right thing).

Remember that the C interface is intended to be nice also for
applications that use just one or two algorithms. These applications
should not suffer from cruft intended to unify the interface with some
other algorithm which the applications couldn't care less about. An
important case would be applications that use only the newer algorithms
like aes or camellia. They shouldn't have to bother about a return value
introduced just because it's needed for des.

BTW: There's another easy alternative which we could call (3): Keep
nettle_set_key_func as is. Introduce wrappers for des and blowfish which
just ignore weak keys, and provide nettle_cipher structs using these
wrappers. Then you get des and blowfish sans weak key detection, using
the same interface as the other ciphers. I think this would fit
reasonably with the nettle design principles. Question is: Would anybody
find it useful? For a general language binding, I would expect that one
would want to have the possibility to detect weak keys.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110329081100</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-03-29 08:11:00-0400</timestampReceived><subject>Re: weak-key ciphers and arcfour</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:
&gt;
&gt;&gt;&gt; A problem is that the key
&gt;&gt;&gt; setup of ARCFOUR is quite weak, you should never use keys with
&gt;&gt;&gt; structure, keys that are ordinary passwords, or sequences of keys like
&gt;&gt;&gt; ``secret:1'', ``secret:2'', ...
&gt;
&gt; The problem with arcfour is not that some particular keys are
&gt; unexpectedly weak, but that the key bits are not spread out very well
&gt; into the internal state (sorry if this description is a bit vague; my
&gt; understanding is also a bit vague...).

There are some keys which are even weaker, for example keys beginning
with 00 00 FD and 03 FD FC, see this paper:

http://impic.org/papers/WeakKeys-report.pdf

On the other hand, RC4 is broken so the function might as well always
return 1 to indicate that the key is weak since it is used with RC4. :-)

/Simon

</body></email><email><emailId>20110329092517</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-29 09:25:17-0400</timestampReceived><subject>Re: weak-key ciphers and arcfour</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; There are some keys which are even weaker, for example keys beginning
&gt; with 00 00 FD and 03 FD FC, see this paper:
&gt;
&gt; http://impic.org/papers/WeakKeys-report.pdf

This still exploits statistical properties of the first few generated
bytes, right? So if you generate and discard the first 512 or 1024 bytes
or so of the keystream, the statistics for these keys shouldn't be much
different from any oter keys, right?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110325192832</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-25 19:28:32-0400</timestampReceived><subject>Re: developing nettle with git</subject><body>


On 03/25/2011 06:45 AM, Niels M=C3=B6ller wrote:
&gt; 1. I'm familiar with mercurial, but I hear that git is a better choice
&gt;    these days, so maybe I should go with git instead. And then I have
&gt;    some new stuff to learn.

i find myself more effective with git than with mercurial, but i
acknowledge that i have spent more time thinking about git (and many
more other projects i collaborate on use git as well, so not spending
time with it isn't much of an option for me).

&gt; 2. Currently, several more-or-less independent projects are in the lsh
&gt;    cvs tree. Besides nettle, there's libspki, argp, sftp. So how should=

&gt;    this be split up? As far as I understand, neither hg nor git have
&gt;    any well-working analogue to cvs modules, which would otherwise have=

&gt;    been a natural choice.

git does have submodule support -- so you can have one repository
reference another at a given commit.  I don't use it often, but i can
help you sort it out if you like.  "git help submodule" for some starter
documentation/reference.

OTOH, if these separate pieces are actually different libraries, i'm not
sure that using submodules really makes a lot of sense.  I think you
just want one git repository per project.  Is there a reason that lsh
would need to be tightly-coupled with any of these libraries instead of
using their exported API?

One git repo per project is a pretty reasonable approach.  And it's not
hard to serve several git repos from a single server.  If you want help
setting that up, i'd be happy to help out.

&gt; 3. Then there's the shared files which are symlinked by the top-level
&gt;    lsh/.bootstrap script. I guess with a split it will be unavoidable t=
o
&gt;    have multiple separately version controlled copies of those files.

i think you might be right here.  For my git development, i took static
copies of those files and placed them directly in my git repo (the
commit log comment starts with "transfer files from lsh".

How often do these files actually change?  Is it critical that they be
kept in sync?

&gt; I guess it's possible to start with migrating nettle from cvs, and leav=
e
&gt; the rest of the tree for later. But I'm not sure that's a good way to d=
o
&gt; it.

I actually don't think that's an unreasonable approach.  If we just
migrate one component (nettle), we can make sure the migrated setup is
OK and that your workflow feels sensible before going through the work
of the other subprojects.  We can apply any new knowledge learned from
the nettle transition to the migration of the other subprojects.

Regards,

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110326074609</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-26 07:46:09-0400</timestampReceived><subject>Re: developing nettle with git</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; git does have submodule support -- so you can have one repository
&gt; reference another at a given commit.

I don't have any first-hand experience with git submodules, but I've
heard some stories saying that it's not yet very usable.

&gt; Is there a reason that lsh would need to be tightly-coupled with any
&gt; of these libraries instead of using their exported API?

The main reason is that lsh is the main testcase. So when introducing
new features one of those those libraries, I usually first hack lsh to
use it, to iron out both interface and implementation bugs. Those
intermediate versions may never be in the API of any released library.

git submodules (assuming that they work well) would probably be the
right tool to keep these libraries in subdirectories of the lsh work
tree.

Ah, and then it's the release procedure. I'd still like to bundle the
libraries with lsh, and having the libraries in subdirectories makes
that easier. And as long as the versions bundled with nettle are
configured for static linking, I see no problem of bundling lsh with
unreleased versions of the libraries.

&gt; How often do these files actually change?  Is it critical that they be
&gt; kept in sync?

It's not critical, it's just for convenience. It's nice to have a single
version, which is used (and tested) with all the projects.

&gt;&gt; I guess it's possible to start with migrating nettle from cvs, and leave
&gt;&gt; the rest of the tree for later. But I'm not sure that's a good way to do
&gt;&gt; it.
&gt;
&gt; I actually don't think that's an unreasonable approach.  If we just
&gt; migrate one component (nettle), we can make sure the migrated setup is
&gt; OK and that your workflow feels sensible before going through the work
&gt; of the other subprojects.

If we do that, I guess we'd need the following steps:

1. migrate the nettle cvs directory to a git repository.

2. cvs rm all those files from the cvs tree (as usual, we can't cvs rm
   the directories themselves).

3. At some later time, migrate the lsh cvs repository to git. Should the
   old nettle subdirectory be excluded somehow? Perhaps not, if I want
   to be able to check out old lsh versions from git.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110327235647</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-27 23:56:47-0400</timestampReceived><subject>Re: developing nettle with git</subject><body>


On 03/26/2011 03:46 AM, Niels Möller wrote:
&gt; The main reason is that lsh is the main testcase. So when introducing
&gt; new features one of those those libraries, I usually first hack lsh to
&gt; use it, to iron out both interface and implementation bugs. Those
&gt; intermediate versions may never be in the API of any released library.
&gt; 
&gt; git submodules (assuming that they work well) would probably be the
&gt; right tool to keep these libraries in subdirectories of the lsh work
&gt; tree.

Yeah, you can definitely do that with git submodules.  I'd be happy to
help you iron out kinks in that workflow if you like.

&gt; Ah, and then it's the release procedure. I'd still like to bundle the
&gt; libraries with lsh, and having the libraries in subdirectories makes
&gt; that easier. And as long as the versions bundled with nettle are
&gt; configured for static linking, I see no problem of bundling lsh with
&gt; unreleased versions of the libraries.

hm, are you talking about making binary releases?  or source releases?

&gt; If we do that, I guess we'd need the following steps:
&gt; 
&gt; 1. migrate the nettle cvs directory to a git repository.

this is already done, if you don't mind using my git repo as the base:

 git://lair.fifthhorseman.net/~dkg/nettle

You can just clone it and then publish it yourself :)

if you want to do the repository conversion yourself, i understand that
too -- i'm just trying to help.

To do it yourself, you want to use git cvsimport (from the git-cvs
package in debian).

&gt; 2. cvs rm all those files from the cvs tree (as usual, we can't cvs rm
&gt;    the directories themselves).
&gt; 
&gt; 3. At some later time, migrate the lsh cvs repository to git. Should the
&gt;    old nettle subdirectory be excluded somehow? Perhaps not, if I want
&gt;    to be able to check out old lsh versions from git.

i don't think you'll need to exclude the old nettle subdirectory from
any future lsh cvs-&gt;git migration, especially if the directory has been
removed from the HEAD already.

hth,

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110328071735</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-28 07:17:35-0400</timestampReceived><subject>Re: developing nettle with git</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; hm, are you talking about making binary releases?  or source releases?

I'm talking about the source releases of lsh.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110328081533</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-28 08:15:33-0400</timestampReceived><subject>Re: developing nettle with git</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; To do it yourself, you want to use git cvsimport (from the git-cvs
&gt; package in debian).

I think I'd prefer to do the conversion myself. I've had a first look at
the man page for git-cvsimport.

I take it I first need to scan the cvs log for all comitters and write a
cvs-authors file (I remember I had some trouble with character set
issues for the corresponding file when doing the hg migration for gmp.
Should the names here be in the $LC_CTYPE charset, or always utf8?).

Then, I'm not sure how to deal with branches, in particular, the -r and
-o options. I'm not used to git, and with hg I also haven't used any
"real" branches, I've just cloned the repository. I'm a bit scared by
"You should never do any work of your own on the branches that are
created by git cvsimport." in the man page.

I think I'd like to keep the possibility of doing cvs import more than
once.

What command line did you use? What branches did you end up with?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110328130745</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-28 13:07:45-0400</timestampReceived><subject>Re: developing nettle with git</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; Yeah, you can definitely do that with git submodules.

Hmm. I'm not sure that will work the way I like. I've been told that if
I have an lsh directory with nettle as a submodule, I can't easily
modify nettle and commit and push changes from that tree.

git-subtree may be more useful (see
https://github.com/apenwarr/git-subtree/blob/master/git-subtree.txt and
http://psionides.jogger.pl/2010/02/04/sharing-code-between-projects-with-git-subtree/)

Maybe it makes things simpler to stick to a single repository for
everything (like the current cvs repository)? Is there any compelling
reason why nettle must be a separate repository? (If I understand the
docs correctly, one could split off a nettle repository later, using
git-subtree split).

Regardss,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110328170308</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-28 17:03:08-0400</timestampReceived><subject>Re: developing nettle with git</subject><body>


On 03/28/2011 03:17 AM, Niels Möller wrote:
&gt; Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:
&gt; 
&gt;&gt; hm, are you talking about making binary releases?  or source releases?
&gt; 
&gt; I'm talking about the source releases of lsh.

I'm a software developer, a sysadmin, and a contributor to a distro
(debian).  No matter which of those three hats i'm wearing, i *strongly*
prefer to have source releases broken out into separable components,
rather than one monolithic tarball.  I prefer this for system
maintenance, for security, for clarity of API, and for ease of modification.

I'm not sure what the argument for monolithic source release is.

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110328172254</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-28 17:22:54-0400</timestampReceived><subject>Re: developing nettle with git</subject><body>


On 03/28/2011 04:15 AM, Niels Möller wrote:
&gt; I take it I first need to scan the cvs log for all comitters and write a
&gt; cvs-authors file (I remember I had some trouble with character set
&gt; issues for the corresponding file when doing the hg migration for gmp.
&gt; Should the names here be in the $LC_CTYPE charset, or always utf8?).

i'd do everything in utf8 myself, but then my LC_CTYPE always uses UTF-8
anyway.  I don't know what the consequences are of doing things other ways.

&gt; Then, I'm not sure how to deal with branches, in particular, the -r and
&gt; -o options. I'm not used to git, and with hg I also haven't used any
&gt; "real" branches, I've just cloned the repository. I'm a bit scared by
&gt; "You should never do any work of your own on the branches that are
&gt; created by git cvsimport." in the man page.
&gt; 
&gt; I think I'd like to keep the possibility of doing cvs import more than
&gt; once.

Meaning you want to update the cvs tree concurrently with the git repo?

This is doable, but it means that your git repo will need to be
regularly rebased against the CVS tree.  I've been doing this with the
git repo i've published, but that's because the CVS tree is still in
use.  doing regular git cvsimports against an active CVS tree will make
it more difficult for other people to develop against the git tree,
which seems like it defeats one of the nice advantages of moving to a
modern dvcs.

&gt; What command line did you use? What branches did you end up with?

I ran something like this:

cvs -d :pserver:anonymous@cvs.lysator.liu.se:/cvsroot/lsh \
   co -d nettle lsh/nettle
cd nettle
git cvsimport

I ended up with no extra branches, though.  Just a handful of tags.
What sort of branches do you want to end up with?

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110328174729</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-28 17:47:29-0400</timestampReceived><subject>Re: developing nettle with git</subject><body>


On 03/28/2011 09:07 AM, Niels M=C3=B6ller wrote:
&gt; Maybe it makes things simpler to stick to a single repository for
&gt; everything (like the current cvs repository)? Is there any compelling
&gt; reason why nettle must be a separate repository? (If I understand the
&gt; docs correctly, one could split off a nettle repository later, using
&gt; git-subtree split).

I'd personally like to work on nettle without dealing with the entire
source of lsh and the other components.

I suspect the same might be true of people who want to hack on the other
components, or on lsh itself.

If you want to encourage external participation, separate repositories
make more sense to me.

How do other folks on this list feel about the tradeoffs here?

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110328175433</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-03-28 17:54:33-0400</timestampReceived><subject>Re: developing nettle with git</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; On 03/28/2011 03:17 AM, Niels Möller wrote:
&gt;&gt; Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:
&gt;&gt; 
&gt;&gt;&gt; hm, are you talking about making binary releases?  or source releases?
&gt;&gt; 
&gt;&gt; I'm talking about the source releases of lsh.
&gt;
&gt; I'm a software developer, a sysadmin, and a contributor to a distro
&gt; (debian).  No matter which of those three hats i'm wearing, i *strongly*
&gt; prefer to have source releases broken out into separable components,
&gt; rather than one monolithic tarball.  I prefer this for system
&gt; maintenance, for security, for clarity of API, and for ease of modification.

+1

As Nettle is looking to become more widely, it seems like a good time to
make a separate repository for it.

Lsh could just import the latest stable Nettle release, couldn't it?

/Simon

</body></email><email><emailId>20110328183929</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-28 18:39:29-0400</timestampReceived><subject>Re: developing nettle with git</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; On 03/28/2011 04:15 AM, Niels Möller wrote:
&gt;&gt; I think I'd like to keep the possibility of doing cvs import more than
&gt;&gt; once.
&gt;
&gt; Meaning you want to update the cvs tree concurrently with the git repo?

Not in the longer term, but maybe during a transition period. But I
guess it's not essential.

&gt; I ran something like this:
&gt;
&gt; cvs -d :pserver:anonymous@cvs.lysator.liu.se:/cvsroot/lsh \
&gt;    co -d nettle lsh/nettle
&gt; cd nettle
&gt; git cvsimport

It all ended up on the "origin" branch then? (I'm still not familiar with
git conventions). 

&gt; I ended up with no extra branches, though.  Just a handful of tags.
&gt; What sort of branches do you want to end up with?

There are a few branches, in the lsh tree I think there's
lsh_1_2_BRANCH, lsh_1_4_2_BRANCH, lsh_2_0_4_BRANCH,
experimental_BRANCH_20050201. I branched and tagged the complete tree at
the time, but appearantly that was before the move from lsh/src/nettle
to lsh/nettle, so there are no tags in the current nettle subdirectory.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110321205013</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-21 20:50:13-0400</timestampReceived><subject>Re: making algorithms in nettle dynamically enumerable</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; That is, a library might use a function by comparing the requested
&gt; algorithm name as a strict prefix with the size of the keylength.

If that works with all algorithms, that's good. I recall I changed or
was about to change these things for the CAST cipher a while back.
"arctwo_gutmann" may also be a corner case.

&gt; const nettle_cipher*
&gt; nettle_select_cipher(const char* algoname, int keylength = 0);

I think this function might fit better as an example in the
documentation. (And you can't do default arguments like that in C).

There are so many queries one might want to do. Beside this example,
"give me all variants of aes", or "give me all block ciphers with a
given block size", so I think it's a bit premature to decide which query
functions to add.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110322210101</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-22 21:01:01-0400</timestampReceived><subject>Re: making algorithms in nettle dynamically enumerable</subject><body>

[Attachment #2 (multipart/mixed)]


On 03/21/2011 04:32 PM, Daniel Kahn Gillmor wrote:
&gt; i'll work on a revised patch with docs and a test if i can figure out a=

&gt; test as well.

Attached is a patch that breaks out separate compilation units,
const-ifies the arrays, and adjusts the docs and the test suite.

I did not see nettle_armor in the docs at all, so i didn't add any docs
about nettle_armors[].  Maybe that whole section needs to be written?

Any further comments?

	--dkg

["make-algorithms-dynamically-enumerable.patch" (text/x-diff)]

commit 35a49c639381b6df7aa83346b46c5afcaabb34ec
Author: Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt;
Date:   Tue Mar 22 16:49:27 2011 -0400

    make algorithms dynamically enumerable

diff --git a/Makefile.in b/Makefile.in
index 1020fd7..c5e911f 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -75,6 +75,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 twofish.c twofish-meta.c \
 		 yarrow256.c yarrow_key_event.c \
 		 buffer.c buffer-init.c realloc.c \
+		 nettle-meta-hashes.c nettle-meta-ciphers.c nettle-meta-armors.c \
 		 nettle-internal.c write-be32.c
 
 hogweed_SOURCES = sexp.c sexp-format.c \
diff --git a/nettle-meta-armors.c b/nettle-meta-armors.c
new file mode 100644
index 0000000..da19ab4
--- /dev/null
+++ b/nettle-meta-armors.c
@@ -0,0 +1,32 @@
+/* nettle-meta.c */
+
+/* nettle, low-level cryptographics library
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;stddef.h&gt;
+#include "nettle-meta.h"
+
+const struct nettle_armor * const nettle_armors[] = {
+  &amp;nettle_base64,
+  &amp;nettle_base16,
+  NULL
+};
diff --git a/nettle-meta-ciphers.c b/nettle-meta-ciphers.c
new file mode 100644
index 0000000..c6d4a5f
--- /dev/null
+++ b/nettle-meta-ciphers.c
@@ -0,0 +1,48 @@
+/* nettle-meta.c */
+
+/* nettle, low-level cryptographics library
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;stddef.h&gt;
+#include "nettle-meta.h"
+
+const struct nettle_cipher * const nettle_ciphers[] = {
+  &amp;nettle_aes128,
+  &amp;nettle_aes192,
+  &amp;nettle_aes256,
+  &amp;nettle_arcfour128,
+  &amp;nettle_camellia128,
+  &amp;nettle_camellia192,
+  &amp;nettle_camellia256,
+  &amp;nettle_cast128,
+  &amp;nettle_serpent128,
+  &amp;nettle_serpent192,
+  &amp;nettle_serpent256,
+  &amp;nettle_twofish128,
+  &amp;nettle_twofish192,
+  &amp;nettle_twofish256,
+  &amp;nettle_arctwo40,
+  &amp;nettle_arctwo64,
+  &amp;nettle_arctwo128,
+  &amp;nettle_arctwo_gutmann128,
+  NULL
+};
diff --git a/nettle-meta-hashes.c b/nettle-meta-hashes.c
new file mode 100644
index 0000000..da6412b
--- /dev/null
+++ b/nettle-meta-hashes.c
@@ -0,0 +1,38 @@
+/* nettle-meta-hashes.c */
+
+/* nettle, low-level cryptographics library
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;stddef.h&gt;
+#include "nettle-meta.h"
+
+const struct nettle_hash * const nettle_hashes[] = {
+  &amp;nettle_md2,
+  &amp;nettle_md4,
+  &amp;nettle_md5,
+  &amp;nettle_sha1,
+  &amp;nettle_sha224,
+  &amp;nettle_sha256,
+  &amp;nettle_sha384,
+  &amp;nettle_sha512,
+  NULL
+};
diff --git a/nettle-meta.h b/nettle-meta.h
index 2a00954..0fbfc03 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -96,6 +96,9 @@ struct nettle_cipher
   (nettle_crypt_func *) name##_decrypt,			\
 }
 
+/* null-terminated list of ciphers implemented by this version of nettle */
+extern const struct nettle_cipher * const nettle_ciphers[];
+
 extern const struct nettle_cipher nettle_aes128;
 extern const struct nettle_cipher nettle_aes192;
 extern const struct nettle_cipher nettle_aes256;
@@ -149,6 +152,9 @@ struct nettle_hash
  (nettle_hash_digest_func *) name##_digest	\
 } 
 
+/* null-terminated list of digests implemented by this version of nettle */
+extern const struct nettle_hash * const nettle_hashes[];
+
 extern const struct nettle_hash nettle_md2;
 extern const struct nettle_hash nettle_md4;
 extern const struct nettle_hash nettle_md5;
@@ -207,6 +213,9 @@ struct nettle_armor
   (nettle_armor_decode_final_func *) name##_decode_final,	\
 }
 
+/* null-terminated list of armor schemes implemented by this version of nettle */
+extern const struct nettle_armor * const nettle_armors[];
+
 extern const struct nettle_armor nettle_base64;
 extern const struct nettle_armor nettle_base16;
 
diff --git a/nettle.texinfo b/nettle.texinfo
index 797ea06..57347eb 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -683,6 +683,12 @@ The last three attributes are function pointers, of types
 @deftypevrx {Constant Struct} {struct nettle_hash} nettle_sha512
 
 These are all the hash functions that Nettle implements.
+
+Nettle also exports a list of all these hashes.  This list can be used
+to dynamically enumerate or search the supported algorithms:
+
+@deftypevrx {Constant Struct * Constant} {struct nettle_hash *} nettle_hashes[]
+
 @end deftypevr
 
 @node Cipher functions, Cipher modes, Hash functions, Reference
@@ -1330,6 +1336,13 @@ struct, which is of size @code{context_size}.
 
 Nettle includes such structs for all the @emph{regular} ciphers, i.e.
 ones without weak keys or other oddities.
+
+Nettle also exports a list of all these ciphers without weak keys or
+other oddities.  This list can be used to dynamically enumerate or
+search the supported algorithms:
+
+@deftypevrx {Constant Struct * const} {struct nettle_cipher *} nettle_ciphers[]
+
 @end deftypevr
 
 @node Cipher modes, Keyed hash functions, Cipher functions, Reference
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 1233307..fc23472 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -82,6 +82,15 @@ gcm-test$(EXEEXT): gcm-test.$(OBJEXT)
 hmac-test$(EXEEXT): hmac-test.$(OBJEXT)
 	$(LINK) hmac-test.$(OBJEXT) $(TEST_OBJS) -o hmac-test$(EXEEXT)
 
+meta-hash-test$(EXEEXT): meta-hash-test.$(OBJEXT)
+	$(LINK) meta-hash-test.$(OBJEXT) $(TEST_OBJS) -o meta-hash-test$(EXEEXT)
+
+meta-cipher-test$(EXEEXT): meta-cipher-test.$(OBJEXT)
+	$(LINK) meta-cipher-test.$(OBJEXT) $(TEST_OBJS) -o meta-cipher-test$(EXEEXT)
+
+meta-armor-test$(EXEEXT): meta-armor-test.$(OBJEXT)
+	$(LINK) meta-armor-test.$(OBJEXT) $(TEST_OBJS) -o meta-armor-test$(EXEEXT)
+
 buffer-test$(EXEEXT): buffer-test.$(OBJEXT)
 	$(LINK) buffer-test.$(OBJEXT) $(TEST_OBJS) -o buffer-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 6eef3dc..8a263cb 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -22,6 +22,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    serpent-test.c twofish-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c ctr-test.c gcm-test.c hmac-test.c \
+		    meta-hash-test.c meta-cipher-test.c meta-armor-test.c \
 		    buffer-test.c yarrow-test.c
 
 TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
diff --git a/testsuite/meta-armor-test.c b/testsuite/meta-armor-test.c
new file mode 100644
index 0000000..a99064b
--- /dev/null
+++ b/testsuite/meta-armor-test.c
@@ -0,0 +1,27 @@
+#include "testutils.h"
+#include "nettle-meta.h"
+
+const char* armors[] = {
+  "base16",
+  "base64"
+};
+
+int
+test_main(void)
+{
+  int i,j;
+  int count = sizeof(armors)/sizeof(*armors);
+  for (i = 0; i &lt; count; i++) {
+    for (j = 0; NULL != nettle_armors[j]; j++) {
+      if (0 == strcmp(armors[i], nettle_armors[j]-&gt;name))
+        break;
+    }
+    ASSERT(NULL != nettle_armors[j]); /* make sure we found a matching armor */
+  }
+  j = 0;
+  while (NULL != nettle_armors[j])
+    j++;
+  ASSERT(j == count); /* we are not missing testing any armors */
+  SUCCESS();
+}
+  
diff --git a/testsuite/meta-cipher-test.c b/testsuite/meta-cipher-test.c
new file mode 100644
index 0000000..1bb74d8
--- /dev/null
+++ b/testsuite/meta-cipher-test.c
@@ -0,0 +1,43 @@
+#include "testutils.h"
+#include "nettle-meta.h"
+
+const char* ciphers[] = {
+  "aes128",
+  "aes192",
+  "aes256",
+  "arctwo40",
+  "arctwo64",
+  "arctwo128",
+  "arctwo_gutmann128",
+  "arcfour128",
+  "camellia128",
+  "camellia192",
+  "camellia256",
+  "cast128",
+  "serpent128",
+  "serpent192",
+  "serpent256",
+  "twofish128",
+  "twofish192",
+  "twofish256"
+};
+
+int
+test_main(void)
+{
+  int i,j;
+  int count = sizeof(ciphers)/sizeof(*ciphers);
+  for (i = 0; i &lt; count; i++) {
+    for (j = 0; NULL != nettle_ciphers[j]; j++) {
+      if (0 == strcmp(ciphers[i], nettle_ciphers[j]-&gt;name))
+        break;
+    }
+    ASSERT(NULL != nettle_ciphers[j]); /* make sure we found a matching cipher */
+  }
+  j = 0;
+  while (NULL != nettle_ciphers[j])
+    j++;
+  ASSERT(j == count); /* we are not missing testing any ciphers */
+  SUCCESS();
+}
+  
diff --git a/testsuite/meta-hash-test.c b/testsuite/meta-hash-test.c
new file mode 100644
index 0000000..d7f251c
--- /dev/null
+++ b/testsuite/meta-hash-test.c
@@ -0,0 +1,33 @@
+#include "testutils.h"
+#include "nettle-meta.h"
+
+const char* hashes[] = {
+  "md2",
+  "md4",
+  "md5",
+  "sha1",
+  "sha224",
+  "sha256",
+  "sha384",
+  "sha512"
+};
+
+int
+test_main(void)
+{
+  int i,j;
+  int count = sizeof(hashes)/sizeof(*hashes);
+  for (i = 0; i &lt; count; i++) {
+    for (j = 0; NULL != nettle_hashes[j]; j++) {
+      if (0 == strcmp(hashes[i], nettle_hashes[j]-&gt;name))
+        break;
+    }
+    ASSERT(NULL != nettle_hashes[j]); /* make sure we found a matching hash */
+  }
+  j = 0;
+  while (NULL != nettle_hashes[j])
+    j++;
+  ASSERT(j == count); /* we are not missing testing any hashes */
+  SUCCESS();
+}
+  

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110323101223</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-23 10:12:23-0400</timestampReceived><subject>Re: making algorithms in nettle dynamically enumerable</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; Attached is a patch that breaks out separate compilation units,
&gt; const-ifies the arrays, and adjusts the docs and the test suite.

Thanks. I'm going to commit this. I noticed some incorrect file names in
the file headers (which I'll fix), and there's no copyright line. I
guess I should simply add

  Copyright (C) 2011 Daniel Kahn Gillmor

at the top of the new files.

&gt; I did not see nettle_armor in the docs at all, so i didn't add any docs
&gt; about nettle_armors[].  Maybe that whole section needs to be written?

The reason these functionality is undocumented is most likely that I
wasn't confident that the interface is right, it's not been used very
much.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110323102538</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-23 10:25:38-0400</timestampReceived><subject>Re: making algorithms in nettle dynamically enumerable</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; Any further comments?

The following (in nettle.texinfo) looks a bit strange.

&gt; +@deftypevrx {Constant Struct * Constant} {struct nettle_hash *} nettle_hashes[]

&gt; +@deftypevrx {Constant Struct * const} {struct nettle_cipher *} nettle_ciphers[]

I'm no texinfo guru, but I think the first {...} is supposed to be just a category
(Function, Macro, Variable, etc), and the second {...} the type. I thik

  @deftypevrx {Constant Struct} {struct nettle_hash **} nettle_hashes

would be more correct (unless we want a new categories "Algorithm List"
which I think is a bit overkill), but I haven't yet checked the
generated output.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110323120720</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-03-23 12:07:20-0400</timestampReceived><subject>Re: making algorithms in nettle dynamically enumerable</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Thanks. I'm going to commit this.

Checked in now. 

I also wrote a program tools/nettle-hash to take advantage of the new
interface. Comments appreciated. 

Should output be more compatible with md5sum, sha1sum et al? But I think
I like to also include information on the algorithm used.

Should it have a -c (check) mode as well?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110323155620</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2011-03-23 15:56:20-0400</timestampReceived><subject>Re: making algorithms in nettle dynamically enumerable</subject><body>


On 03/23/2011 06:25 AM, Niels Möller wrote:
&gt; Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:
&gt; 
&gt;&gt; Any further comments?
&gt; 
&gt; The following (in nettle.texinfo) looks a bit strange.
&gt; 
&gt;&gt; +@deftypevrx {Constant Struct * Constant} {struct nettle_hash *} nettle_hashes[]
&gt; 
&gt;&gt; +@deftypevrx {Constant Struct * const} {struct nettle_cipher *} nettle_ciphers[]
&gt; 
&gt; I'm no texinfo guru, but I think the first {...} is supposed to be just a category
&gt; (Function, Macro, Variable, etc), and the second {...} the type. I thik
&gt; 
&gt;   @deftypevrx {Constant Struct} {struct nettle_hash **} nettle_hashes
&gt; 
&gt; would be more correct (unless we want a new categories "Algorithm List"
&gt; which I think is a bit overkill), but I haven't yet checked the
&gt; generated output.

Ah, ok.  I'm no texinfo guru either -- i just put in what made the pdf
output look reasonable.  Your changes make at least as much sense to me
as what i put in there.

Thanks for fixing it,

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20110210231925</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-10 23:19:25-0400</timestampReceived><subject>Re: LGPL blowfish</subject><body>

[ Resend, the posting originally used an incorrect list address. /nisse ]

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; I wonder which of nettle or libgcrypt is correct -- and further, I
&gt; really wonder if anyone cares at all about Serpent if a problem like
&gt; this haven't been noticed before?

Interesting...

As far as I recall the nettle history (and also looking at the
comments), the nettle adaptation of serpent.c was done by Rafael
Sevilla, if I have touched that code I think it's trivial changes only.

And I think that I wrote serpent-test.c, based on the test vectors in the
serpent AES-competition package.

I don't remember if I have ever done any interoperability testing of
serpent with lsh (which uses nettle's implementation). Trying to connect
to some openssh servers, it seems they don't enable serpent by default.

Maybe you can try adding some of the testvectors at
http://www.cs.technion.ac.il/~biham/Reports/Serpent/ to nettle and
libgcrypt, and see what happens? (On the nettle side, I'll try to give
that a reasonably high priority).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110211190823</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-11 19:08:23-0400</timestampReceived><subject>Re: Serpent</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Should I try to make it compatible with libgcrypt, and presumably
&gt; Serpent-1?

It ought to be serpent-1, the algorithm proposed for AES. RFC 4344
references the algorithm like this:

   [SERPENT]   Anderson, R., Biham, E., and Knudsen, L., "Serpent: A
               proposal for the Advanced Encryption Standard", NIST
               AES Proposal, 1998.
                                 
&gt; Thus modifying serpent-test.c?  I'll send a patch later.

I've already checked in a few new test cases in serpent-test.c (taken
from http://www.cs.technion.ac.il/~biham/Reports/Serpent/), but #if:ed
out for now.

I'd also like to hear what response we get from the serpent people
regarding conflicting test vectors, it seems so strange if the test
vectors in the aes submission were broken.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110228161916</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-02-28 16:19:16-0400</timestampReceived><subject>Re: nettle documentation tweaks?</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; i've been reading the latest nettle docs [0], and i wanted to say that
&gt; they are excellent.  Clear explanations, and useful contextual help
&gt; about how various crypto primitives can be used in real-world settings
&gt; as well. 

Thanks!

&gt; Section 6.5 contains the following paragraph:
&gt;
&gt;&gt; Besides signing meaningful messages, digital signatures can be used for
&gt;&gt; authorization. [...]

&gt; This simple scheme is actually vulnerable to a replay attack: an
&gt; man-in-the-middle attacker can pose as the service to the user while
&gt; simultaneously connecting to the service directly.  The attacker gets a
&gt; nonce from the server, passes it to the user for signing, returns the
&gt; user's response to the service, and gains access.

&gt; One way to avoid this is to ensure that the "random nonce" to be signed
&gt; by the user is actually a negotiated value that neither party can fully
&gt; control.

Right. A common and reasonable way to handle it is by negotiating a
session key using DH, use that key for message authentication of the
session (and why not also encryption, while we're at it). Then either
side can let the other authenticate itself by signing a nonce which is
not an independent random value, but computed in some way from the
session key.

I have to think a bit more on how to explain this in a concise way, any
suggestions? I think it may be appropriate to not recommend any protocol
which doesn't include some kind of authentication of the session. And
from this point of view, the session-key thing can be seen as an
optimization, where the alternative is to sign each message.

&gt;  1) "bad things may happen", "a few subtle issues", etc. should have
&gt; outbound links
&gt;
&gt; There are several places in the docs that mention potential security
&gt; concerns implementators should be aware of.  For example, the remark
&gt; about CBC providing "information leakage" could link to
&gt; http://www.kb.cert.org/vuls/id/958563

I've added this link. Patches for other missing references are
appreciated...

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110105214822</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2011-01-05 21:48:22-0400</timestampReceived><subject>Re: howto use openssl generated rsa keys with nettle</subject><body>

Jyke Jokinen &lt;jyke.jokinen@tut.fi&gt; writes:

&gt; In private key the fields are (openssl rsa -in key.pem -text):
&gt; privateExponent:
&gt; prime1:
&gt; prime2:
&gt; exponent1:
&gt; exponent2:
&gt; coefficient:
&gt;
&gt; Prime1&amp;2 should be the factors p and q in rsa_private_key(?)
&gt; What values should be used for a, b and c?

If n = p q, e is the public exponent and d is the private exponent, then
one should have

  a = d mod (p - 1)
  b = d mod (q - 1)
  c = q^{-1} (mod p)

I've tried to explain this in rsa.h, suggestions for improving the
documentation are welcome.

I'm pretty sure openssl uses the same values. Off the top of my head I
can't say for sure how to pair together nettle's names and openssl's,
but I think they're in the same order, i.e.,

  privateExponent = d
  prime1 = p
  prime2 = q
  exponent1 = a
  exponent2 = b
  coefficient = c

Anyway, a, b, and c are redundant and can be computed from p, q and d,
so you can check if the pairing above is correct.

For converting keys in pkcs#1 format, also have a look at the program
examples/pkcs1-conv.c, and the function rsa_keypair_from_der which it
uses.

Regards,
/Niels

PS. I've added your address to the non-member whitelist. I hope that
works, and that you can now post to the list. (Default posting policy is
members-only, as a desperate anti-spam measure).

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20110107215833</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2011-01-07 21:58:33-0400</timestampReceived><subject>Re: elliptic curve in nettle?</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; 3. On the legal side, I'd like to have some clear evidence that the
&gt;    particular curves implemented are unlikely to lead to trouble with
&gt;    known patents, possibly with fsf legal staff or sflc in the loop. I'm
&gt;    not sure I know the area well enough to provide all needed input to
&gt;    legal staff, though, so I may need help with this part as well.

I believe the SFLC is aware of the ECC situation, so you may want to
talk to them about it.  It is a messy area.

/Simon

</body></email></emails>