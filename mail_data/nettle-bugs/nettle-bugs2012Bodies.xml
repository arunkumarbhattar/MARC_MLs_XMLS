<?xml version="1.0" encoding="utf-8"?>
<emails><email><emailId>20120107200848</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2012-01-07 20:08:48-0400</timestampReceived><subject>Building libnettle on MS-Windows</subject><body>

About a week ago, I built libnettle 2.4 on MS-Windows using the MinGW
tools.  While doing that, I found a few problems; this message reports
them.

For the record, I configured using " --disable-openssl --enable-shared".
This was suggested by the GnuTLS README file; as I needed libnettle to
build GnuTLS, I followed that advice.

Problem #1: Compiler warnings while compiling cbc.c:

     cbc.c: In function `nettle_cbc_decrypt':
     cbc.c:101: warning: implicit declaration of function `alloca'
     cbc.c:101: warning: nested extern declaration of `alloca'

   I fixed this by adding this to config.h.in:

     /* Needed for alloca on MinGW */
     # if HAVE_MALLOC_H
     #  include &lt;malloc.h&gt;
     # endif

   malloc.h in MinGW defines alloca to the GCC builtin; if the above
   is absent, the compiler falls back on "char *alloca()" which causes
   the warnings.

Problem #2: "make install" incorrectly copies the DLL files into
lib/*.dll.a.  *.dll.a are the Windows import libraries for using
during the link stage; the *.dll dynamic libraries themselves should
be copied into the $(bindir) directory.

   My solution was to add commands to corresponding recipes that cater
   to Windows, where *_SONAME variables are empty:

     install-shared-hogweed: $(LIBHOGWEED_FORLINK)
	     $(MKDIR_P) $(DESTDIR)$(libdir)
	     $(MKDIR_P) $(DESTDIR)$(bindir)
	     [ -z "$(LIBHOGWEED_SONAME)" ] \
		     &amp;&amp; $(INSTALL_DATA) $(LIBHOGWEED_FORLINK) $(DESTDIR)$(bindir)
	     [ -z "$(LIBHOGWEED_SONAME)" ] \
		     &amp;&amp; $(INSTALL_DATA) $(LIBHOGWEED_FILE) $(DESTDIR)$(libdir)
	     [ -z "$(LIBHOGWEED_SONAME)" ] \
		     || $(INSTALL_DATA) $(LIBHOGWEED_FORLINK) $(DESTDIR)$(libdir)/$(LIBHOGWEED_FILE)
	     [ -z "$(LIBHOGWEED_SONAME)" ] \
		     || (cd $(DESTDIR)$(libdir) \
		     &amp;&amp; $(LN_S) $(LIBHOGWEED_FILE) $(LIBHOGWEED_SONAME) \
		     &amp;&amp; $(LN_S) $(LIBHOGWEED_FILE) $(LIBHOGWEED_FORLINK))

Problem #3: Tests crash because they don't find libhogweed-2-1.dll.  This is
because Makefile uses "ln -sf" to create .lib/*.dll.

   Solution: add LN_S variable to Makefile.in, and then re-run the
   build with "make LN_S='cp -prf'.  Also, add this command to the
   recipes that build shared libraries:

	[ -z "$(LIBNETTLE_SONAME)" ] &amp;&amp; (cd .lib \
          &amp;&amp; $(LN_S) ../$(LIBNETTLE_FORLINK) $(LIBNETTLE_FORLINK))

   so that the DLLs are copied to .lib/ under the same name.

Problem #4: Tests in `examples' crash, cannot find libhogweed-2-1.

   Solution: add ../.lib to PATH, like testsuite/Makefile.in does.

Problem #5: testsuite/pkcs1-conv fails due to CRLF vs LF issue in compared
files (MinGW programs produce text files where each line ends in CRLF,
while the test expects the Unix-style LF-only end-of-line format).

   Solution: add --strip-trailing-cr switch to diff.

Problem #6: testsuite/sexp-conv fails due to CRLF vs LF issue in compared
files.

   Solution: use "diff --strip-trailing-cr" instead of "cmp".

Problem #7: examples/setup-env fails because it tries to read from
rsa-decrypt, which doesn't exist.  It should instead read from
rsa-decrypt.exe.

  Solution: fix setup-env to check which program file is actually
  present and read from that.

  A similar problem is in examples/rsa-encrypt-test.

Problem #8: examples/rsa-encrypt-test fails because rsa-encrypt.c and
rsa-decrypt.c read/write binary data from stdin to stdout, but do
not set these streams to binary mode.

  To solve this, I added code to the test programs to use binary
  mode.  Let me know if you want me to submit patches for that.

Last, but not least: thanks for developing and maintaining libnettle!

</body></email><email><emailId>20120107201627</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2012-01-07 20:16:27-0400</timestampReceived><subject>Re: Building libnettle on MS-Windows</subject><body>

Hi Eli,

On Sat, 7 Jan 2012, Eli Zaretskii wrote:

&gt; About a week ago, I built libnettle 2.4 on MS-Windows using the MinGW
&gt; tools.  While doing that, I found a few problems; this message reports
&gt; them.

Many of these issues have been fixed in the latest version in CVS - please 
retry with that version and see which ones of them still apply.

Of these, we've at least worked on problem #2, #5, #6, #7, #8, and 
improved the assembler code to work on windows. It's been mostly tested 
when building under linux though (and running tests through wine), so 
there might perhaps still be some issues when running under real windows.

// Martin

</body></email><email><emailId>20120107210830</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-01-07 21:08:30-0400</timestampReceived><subject>Re: Building libnettle on MS-Windows</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt; About a week ago, I built libnettle 2.4 on MS-Windows using the MinGW
&gt; tools.  While doing that, I found a few problems; this message reports
&gt; them.

Thanks for testing. As Martin wrote, there has been some progress on
windows support since the release. It would be great if you could test
the cvs version (sorry it's a little cumbersome; you need to check out
the lsh tree and follow the instructions on
http://www.lysator.liu.se/~nisse/nettle/).

&gt; Problem #1: Compiler warnings while compiling cbc.c:
&gt;
&gt;      cbc.c: In function `nettle_cbc_decrypt':
&gt;      cbc.c:101: warning: implicit declaration of function `alloca'
&gt;      cbc.c:101: warning: nested extern declaration of `alloca'

Not fixed, as far as I know. I don't see this warning when cross
compiling, so I guess this reflects a real difference in native builds.

&gt; Problem #2: "make install" incorrectly copies the DLL files into
&gt; lib/*.dll.a.  *.dll.a are the Windows import libraries for using
&gt; during the link stage; the *.dll dynamic libraries themselves should
&gt; be copied into the $(bindir) directory.

Should be fixed, thanks to Martin.

&gt; Problem #3: Tests crash because they don't find libhogweed-2-1.dll.  This is
&gt; because Makefile uses "ln -sf" to create .lib/*.dll.

Not fixed. Using an LN_S make variable makes sense to me, but there
should also be a corresponding configure check (hopefully there's some
standard autoconf test?). Patch appreciated.

&gt; Problem #4: Tests in `examples' crash, cannot find libhogweed-2-1.
&gt;
&gt;    Solution: add ../.lib to PATH, like testsuite/Makefile.in does.

Seems right. Checked in now.

&gt; Problem #5: testsuite/pkcs1-conv fails due to CRLF vs LF issue in compared
&gt; files (MinGW programs produce text files where each line ends in CRLF,
&gt; while the test expects the Unix-style LF-only end-of-line format).
&gt;
&gt;    Solution: add --strip-trailing-cr switch to diff.

Fixed, I think (and also #6). Files are massaged with tr as needed,
since that's more portable than relying on GNU diff.

&gt; Problem #7: examples/setup-env fails because it tries to read from
&gt; rsa-decrypt, which doesn't exist.  It should instead read from
&gt; rsa-decrypt.exe.
&gt;
&gt;   Solution: fix setup-env to check which program file is actually
&gt;   present and read from that.

Fixed, by passing $EXEEXT in the environment and using it in setup-env
and also in other test scripts.

&gt; Problem #8: examples/rsa-encrypt-test fails because rsa-encrypt.c and
&gt; rsa-decrypt.c read/write binary data from stdin to stdout, but do
&gt; not set these streams to binary mode.
&gt;
&gt;   To solve this, I added code to the test programs to use binary
&gt;   mode.  Let me know if you want me to submit patches for that.

These files now do

#ifdef WIN32
  setmode(0, O_BINARY);
  setmode(1, O_BINARY);
#endif

Do you think this is a correct solution?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120107212417</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2012-01-07 21:24:17-0400</timestampReceived><subject>Re: Building libnettle on MS-Windows</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Cc: nettle-bugs@lists.lysator.liu.se
&gt; Date: Sat, 07 Jan 2012 22:08:30 +0100
&gt; 
&gt; Thanks for testing. As Martin wrote, there has been some progress on
&gt; windows support since the release. It would be great if you could test
&gt; the cvs version (sorry it's a little cumbersome; you need to check out
&gt; the lsh tree and follow the instructions on
&gt; http://www.lysator.liu.se/~nisse/nettle/).

I will try that when I have time, if a new release is too far to wait
until then.

Doesn't building from CVS require additional tools, like Autoconf and
Automake?

&gt; &gt; Problem #3: Tests crash because they don't find libhogweed-2-1.dll.  This is
&gt; &gt; because Makefile uses "ln -sf" to create .lib/*.dll.
&gt; 
&gt; Not fixed. Using an LN_S make variable makes sense to me, but there
&gt; should also be a corresponding configure check (hopefully there's some
&gt; standard autoconf test?). Patch appreciated.

LN_S is a standard autoconf thing, so it should be easy.  Sorry, I
don't know about autoconf enough to send a patch.  However, by looking
at random configure scripts, I found that having this in configure.ac:

  AC_PROG_LN_S

is probably all you need.

&gt; &gt; Problem #8: examples/rsa-encrypt-test fails because rsa-encrypt.c and
&gt; &gt; rsa-decrypt.c read/write binary data from stdin to stdout, but do
&gt; &gt; not set these streams to binary mode.
&gt; &gt;
&gt; &gt;   To solve this, I added code to the test programs to use binary
&gt; &gt;   mode.  Let me know if you want me to submit patches for that.
&gt; 
&gt; These files now do
&gt; 
&gt; #ifdef WIN32
&gt;   setmode(0, O_BINARY);
&gt;   setmode(1, O_BINARY);
&gt; #endif
&gt; 
&gt; Do you think this is a correct solution?

Yes, except that I would use _setmode, as that will also work for
Windows compilers other than MinGW.

Thanks.

</body></email><email><emailId>20120107220542</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-01-07 22:05:42-0400</timestampReceived><subject>Re: Building libnettle on MS-Windows</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt; Doesn't building from CVS require additional tools, like Autoconf and
&gt; Automake?

Autoconf is needed. So if you don't have autoconf on the windows box,
what you'd need to do is check it out to a unix/gnu/linux-system, run
the .bootstrap scripts (as per the instructions), and do a ./configure
&amp;&amp; make &amp;&amp; make dist in the nettle directory. And then copy the
resulting .tar.gz to the windows machine. So it's not very convenient.

When the lsh xenofarm is up and running, you can also cheat and get a
recent lsh snapshot from
http://www.lysator.liu.se/xenofarm/lsh/builds/latest. At the moment, the
most recent snapshot there is from October, but if things goes well a
current one should be prepared within an hour or so.

I'm not sure when I'll get around to making a new release.

&gt;   AC_PROG_LN_S
&gt;
&gt; is probably all you need.

[...]

&gt; Yes, except that I would use _setmode, as that will also work for
&gt; Windows compilers other than MinGW.

Noted. I'll see what I can do.

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120124090101</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-01-24 09:01:01-0400</timestampReceived><subject>Migration from CVS to GIT</subject><body>

I'm finally looking into conversion of the lsh repository from CVS to
GIT, and this naturally also includes nettle.

A public test repository can be found at lysator's gitorious
installation, at http://git.lysator.liu.se/lsh/test-2. The conversion was
done by the pcvs2git.pike program (see
git://pike-git.lysator.liu.se/pcvs2git.git), and I got some help from
Henrik Grubbström to write a config file to handle the few peculiarities
in the lsh repository.

The intention is that the new git repository should include all branches
and tags from the old cvs repository, and record major merge events,
like the 2006-05-16 merge from the experimental branch to the trunk.

Please test, and if all goes well I'll rename this repository to "lsh"
(or recreate, if I can't figure out how to do repository renames with gitorious).

If this first steps works out ok, step two is to do a some cleanups
(switching to utf-8 for the files, deleting old $Id$ tags, etc). And then
step three is to extract the nettle subdirectory as an independent
project and repository, using git subtree of git filter-branch or so
(I'm not sure what's the best tool for that job). Other sub-projects,
e.g., the argp implementation, can be split out later, if desired.

For the few "common files" (e.g., misc/run-tests), they'll simply have
to be duplicated in several repositories. If I still want to bundle
nettle with the lsh distribution, I'll handle that by setting up some
symlink in my working tree. git submodule is probably not a solution,
and git subtree is most likely overkill.

The old CVS repository can be considered read-only now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120124092550</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-01-24 09:25:50-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I'm finally looking into conversion of the lsh repository from CVS to
&gt; GIT, and this naturally also includes nettle.

That is great.  I find that testing and preparing patches is easier with
git than CVS.  I have been wanting to propose patches for adding the new
SHA2/x hashes, and this will be easier for me now.

&gt; Please test, and if all goes well I'll rename this repository to "lsh"
&gt; (or recreate, if I can't figure out how to do repository renames with
&gt; gitorious).

The nettle part worked fine for me.  Let me suggest to populate
.gitignore with some files indicate by 'git status' after building
Nettle once.  For me the output was as below.

/Simon

#	INSTALL
#	aclocal.m4
#	aes-decrypt-internal.asm
#	aes-encrypt-internal.asm
#	camellia-crypt-internal.asm
#	config.guess
#	config.sub
#	examples/getopt.c
#	examples/getopt.h
#	examples/getopt1.c
#	examples/next-prime
#	examples/random-prime
#	examples/run-tests
#	gcmdata
#	hogweed.pc
#	install-sh
#	machine.m4
#	memxor.asm
#	nettle.pc
#	serpent-decrypt.asm
#	serpent-encrypt.asm
#	sha1-compress.asm
#	testsuite/camellia-test
#	testsuite/gcm-test
#	testsuite/memxor-test
#	testsuite/meta-armor-test
#	testsuite/meta-cipher-test
#	testsuite/meta-hash-test
#	testsuite/random-prime-test
#	testsuite/ripemd160-test
#	testsuite/run-tests
#	testsuite/sha224-test
#	testsuite/sha384-test
#	testsuite/sha512-test
#	texinfo.tex
#	tools/getopt.c
#	tools/getopt.h
#	tools/getopt1.c
#	tools/nettle-hash

</body></email><email><emailId>20120124092744</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2012-01-24 09:27:44-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>


Hi,

On Tue, 24 Jan 2012, Niels Möller wrote:

&gt; I'm finally looking into conversion of the lsh repository from CVS to
&gt; GIT, and this naturally also includes nettle.

This is great news!

&gt; If this first steps works out ok, step two is to do a some cleanups
&gt; (switching to utf-8 for the files, deleting old $Id$ tags, etc). And then
&gt; step three is to extract the nettle subdirectory as an independent
&gt; project and repository, using git subtree of git filter-branch or so
&gt; (I'm not sure what's the best tool for that job). Other sub-projects,
&gt; e.g., the argp implementation, can be split out later, if desired.

I'd hope for a round of filter-branch to rewrite author names in git to 
the original author of patches. I haven't done it myself, but I've seen it 
done on other projects. One can do some kind of more or less heuristic 
shell script that e.g. greps the commit message for known strings (either 
known contributors or strings like "From:" or "contributed by") and based 
on these override the author name.

If you don't feel up to doing this yourself, I can try to give it a go.

// Martin

</body></email><email><emailId>20120124121508</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-01-24 12:15:08-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; I'd hope for a round of filter-branch to rewrite author names in git
&gt; to the original author of patches.

I was thinking that it's good enough to convert the information recorded
by cvs. But it's certainly possible to add specified author names for
certain commits, as a part of the conversion process. The
config/Pike-real-authors file (from the
git://pike-git.lysator.liu.se/pcvs2git.git repository) is an example of
what that input file should look like. Since I haven't used it I'm not
sure how it works, but I could try to find out.

But it's going to be some manual work, going through the ChangeLog files
looking for contributed changes, and then looking at the cvs log to
identify affected revisions and writing the input file for
--contributors.

&gt; If you don't feel up to doing this yourself, I can try to give it a go.

If you want to give it a try, I'll explain what's needed.

1. Get pike 7.8 release 550 or later, 
   http://pike.ida.liu.se/pub/pike/beta/7.8.550/Pike-v7.8.550.tar.gz

   Annoyingly enough, it doesn't support the most recent version of
   nettle, resulting in compilation errors on the DES glue. I had to #if
   out the DES and DES3 ciphers from the Nettle module. Alternatively,
   there should be some configure argument to force Pike to build with
   the bundled version of nettle, rather than the installed version.

2. Get git://pike-git.lysator.liu.se/pcvs2git.git. This includes
   Henrik's configuration file in config/lsh.pcvs2git.

3. Get the CVS repository. I'm putting a copy at
   http://www.lysator.liu.se/~nisse/misc/lsh-cvsroot.tar.gz

4. Create an authors.txt file, containing

nisse=Niels Möller &lt;nisse@lysator.liu.se&gt;
uid444=Niels Möller &lt;nisse@lysator.liu.se&gt;
_cvs_pont=Pontus Freyhult &lt;pont@soua.net&gt;

5. To do the conversion, I used the command line

   pike ../pcvs2git/pcvs2git.pike -c ../pcvs2git/config/lsh.pcvs2git \
    -A authors.txt -k -l -C lsh.git -d lsh-cvsroot/lsh

   It spawns a git fast-import process which populates the new
   repository.

The result should be almost identical to the current "test-2" repository
(Henrik has committed some tweaks for the generated .gitattributes
files).

To use a contributors file, add --contributors contributors.txt early
on the above command line (the -d option and argument has to come after
other options).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120131143911</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-01-31 14:39:11-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>

Now I've went through the history, back from the previous millennium,
startig from the authors and contributors files that Martin was kind
enough to prepare. It's taken a few days. The early ChangeLog entries
were a bit messy.

The new repository is now git://git.lysator.liu.se/lsh/test-3.git

And I also found out some things which I had forgotten. E.g.,

* The very first version of the lsh-export-key program was written by
  Jean-Pierre Stierlin.

* Dan Egnor wrote the base64 code in Nettle, with much effort spent on
  finding the right interface design.

* Pieces of Balázs Scheidler's now obsolete lsh_proxy program still
  survives, since current gateway_channel.c evolved from his
  proxy_channel.c.

The recorded authors are listed below. These are all people I have been
able to find who have contributed a larger or smaller change to lsh or
nettle (not counting bug reports or sugestions for changes). Change sets
which mix a contributed patch with other changes also don't get the
contributor listed as author. So we have 37 authors over the years:

   Adam Langley &lt;alangley@gmail.com&gt;
   Andres Mejia &lt;mcitadel@gmail.com&gt;
   Balázs Scheidler &lt;bazsi@balabit.hu&gt;
   Dagobert Michelsen &lt;dam@opencsw.org&gt;
   Dan Egnor &lt;egnor@ofb.net&gt;
   Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt;
   David Hoyt &lt;hoyt6@llnl.gov&gt;
   Gordon Matzigkeit &lt;gord@trick.fig.org&gt;
   Grant Robinson &lt;santiago@mr-r.net&gt;
   Henrik Grubbström &lt;grubba@lysator.liu.se&gt;
   J.H.M. Dassen &lt;jdassen@wi.leidenuniv.nl&gt;
   James Ralston &lt;qralston+ml.nettle-bugs@andrew.cmu.edu&gt;
   Jean-Pierre Stierlin &lt;jps@macssh.com&gt;
   Joseph Galbraith &lt;galb@rt66.com&gt;
   Kalle Olavi Niemitalo &lt;tosi@ees2.oulu.fi&gt;
   Karl Berry &lt;karl@gnu.org&gt;
   Keresztfalvi Gabor Agoston &lt;kg230@hszk.bme.hu&gt;
   Luiz Eduardo Gava &lt;leg@terra.com.br&gt;
   Magnus Holmgren &lt;holmgren@debian.org&gt;
   Martin Storsjö &lt;martin@martin.st&gt;
   Meilof Veeningen &lt;meilof@gmail.com&gt;
   Niels Möller &lt;nisse@lysator.liu.se&gt;
   Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
   Pavel Roskin &lt;proski@gnu.org&gt;
   Per Cederqvist &lt;ceder@lysator.liu.se&gt;
   Pontus Freyhult &lt;pont@soua.net&gt;
   Pontus Sköld &lt;pont@soua.net&gt;
   Rafael Sevilla &lt;dido@pacific.net.ph&gt;
   Rafal Maszkowski &lt;rzm@icm.edu.pl&gt;
   Ruud de Rooij &lt;ruud@debian.org&gt;
   Ryan Schmidt &lt;nettle-2011@ryandesign.com&gt;
   Sebastian Reitenbach &lt;sebastia@l00-bugdead-prods.de&gt;
   Simon Josefsson &lt;simon@josefsson.org&gt;
   Stefan Pfetzing &lt;dreamind@dreamind.de&gt;
   Thayne Harbaugh &lt;thayne@northsky.com&gt;
   Vincent Torri &lt;vincent.torri@gmail.com&gt;
   Volker Zell &lt;dr.volker.zell@oracle.com&gt;

(Some statistics on first and latest contribution for each author, lines
contributed, contributed lines still surviving in the tree, etc, would
be interesting).

Testing and general browsing of the history is appreciated. In a few
days, I think I'll consider the conversion final.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120131145048</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2012-01-31 14:50:48-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>


On Tue, 31 Jan 2012, Niels Möller wrote:

&gt; Testing and general browsing of the history is appreciated. In a few
&gt; days, I think I'll consider the conversion final.

The author mapping looks good to me at least, looking forward to the final 
repo (including separated nettle)! Thanks for your work on this!

// Martin

</body></email><email><emailId>20120203090430</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-02-03 09:04:30-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; The author mapping looks good to me at least, looking forward to the
&gt; final repo

Now "final". Repo url git://git.lysator.liu.se/lsh/lsh.git. I renamed
the old gitorious "project" to get the various test repositories out of
the way.

After the conversion, I have pushed some tags to all branches to mark
the conversion. On master only, I have eliminatd $Id tags in files, and
converted all textfiles to utf-8 (encoding marks in texinfo and html not
yet updated, though).

&gt; (including separated nettle)!

Not there yet.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120203213541</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-02-03 21:35:41-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; The author mapping looks good to me at least, looking forward to the
&gt; final repo (including separated nettle)! Thanks for your work on this!

I now have a first nettle test repo at
git://git.lysator.liu.se/lsh-test/nettle-test.git

It was created by first cloning the lsh repository, all branches. Then

  git filter-branch --subdirectory-filter nettle --prune-empty -- --all

followed by git update-ref -d on all refs which the previous command
warned about being unchanged. Including branches other than master is
probably overkill. One file (nettle/tools/nettle-lfib-stream.c) seems to
have originated on the lsh-1.4.2 branch, but I think it was copied
manually to the main trunk.

However, this conversion loses quite a lot of history, including all
nettle-1.15 releases. To actually build old versions, one would need to
use the lsh repo (due to the shared files linked by lsh's ./.bootstrap),
but it would be nice to still have the history in the nettle repo.

I think the following approach would make some sense, using git
filter-branch --tree-filter or possibly --index-filter:

1. Delete everything except nettle, src/nettle and src/symmetric.

2. If nettle exists, move its contents up one level and delete nettle.

3. Otherwise, if src/nettle exists (and is non-empty), move its contents
   up two levels and delete the original directory.

4. Otherwise, if src/symmetric exists (and is non-empty), move its
   contents up two levels and delete the original directory.

5. Otherwise, the tree should be empty. It's from the first few weeks of
   lsh development, not relevant to nettle.

Help from any git guru on the list is appreciated. In particular if the
more efficient --index-filter method is to be used, it's not obvious to
me how to examine the index and do the right tests and deletions.

One could also try to extract all src/symmetric ChangeLog entries from
lsh's ChangeLog and copy to nettle's (prior to spring 2001 or so) . But
I think that can be done after the git migration; it's not much use to
modify earlier revisions of the ChangeLog.

Regards,
/nisse

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120204084236</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-02-04 08:42:36-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Martin Storsjö &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt; The author mapping looks good to me at least, looking forward to the
&gt;&gt; final repo
&gt;
&gt; Now "final". Repo url git://git.lysator.liu.se/lsh/lsh.git. I renamed
&gt; the old gitorious "project" to get the various test repositories out of
&gt; the way.

Great!  I added it to my batch job to create statistics for, see output
here:

http://gitstats.josefsson.org/lsh/

/Simon

</body></email><email><emailId>20120206184207</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-02-06 18:42:07-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Martin Storsjö &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt; The author mapping looks good to me at least, looking forward to the
&gt;&gt; final repo (including separated nettle)! Thanks for your work on this!
&gt;
&gt; I now have a first nettle test repo at
&gt; git://git.lysator.liu.se/lsh-test/nettle-test.git

It doesn't build:

jas@latte:~/src/nettle-test master$ ./.bootstrap 
jas@latte:~/src/nettle-test master$ ./configure
configure: error: cannot find install-sh, install.sh, or shtool in . "."/.
jas@latte:~/src/nettle-test master$ 

However perhaps that is one of the unresolved issues.

&gt; However, this conversion loses quite a lot of history, including all
&gt; nettle-1.15 releases. To actually build old versions, one would need to
&gt; use the lsh repo (due to the shared files linked by lsh's ./.bootstrap),
&gt; but it would be nice to still have the history in the nettle repo.
&gt;
&gt; I think the following approach would make some sense, using git
&gt; filter-branch --tree-filter or possibly --index-filter:
&gt;
&gt; 1. Delete everything except nettle, src/nettle and src/symmetric.
&gt;
&gt; 2. If nettle exists, move its contents up one level and delete nettle.
&gt;
&gt; 3. Otherwise, if src/nettle exists (and is non-empty), move its contents
&gt;    up two levels and delete the original directory.
&gt;
&gt; 4. Otherwise, if src/symmetric exists (and is non-empty), move its
&gt;    contents up two levels and delete the original directory.
&gt;
&gt; 5. Otherwise, the tree should be empty. It's from the first few weeks of
&gt;    lsh development, not relevant to nettle.

As for these advanced git features, I have no idea.

However, I'm not sure it is that important to make the git repo usable
for building older nettle releases -- for anyone that really wants to go
back in time and build old things can always look at the 'lsh'
repository.  That reflects how nettle was developed before, and
consequently how everyone need to work with those releases.

For most people, working on master and/or the latest stable release is
what's interesting.  So I'd say do a git conversion and then make a
release from git and then work forward from there.

/Simon

</body></email><email><emailId>20120206190408</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2012-02-06 19:04:08-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>

On 02/06/2012 01:42 PM, Simon Josefsson wrote:

&gt; For most people, working on master and/or the latest stable release is
&gt; what's interesting.  So I'd say do a git conversion and then make a
&gt; release from git and then work forward from there.

I'd agree with this.  people who are providing longer-term support for
older releases can also use the nettle repo to create a branch for the
version they're supporting, and cherry-pick any cleanup commits from
stable or master that will make the code generally buildable again.

	--dkg

</body></email><email><emailId>20120206195326</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-02-06 19:53:26-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; configure: error: cannot find install-sh, install.sh, or shtool in . "."/.
&gt; jas@latte:~/src/nettle-test master$ 
&gt;
&gt; However perhaps that is one of the unresolved issues.

This is one of the files that was setup using symlinks in the lsh repo.
I'll add this and other files to the nettle repo, *after* the conversion
of the history is satisfactory.

&gt; However, I'm not sure it is that important to make the git repo usable
&gt; for building older nettle releases

I mostly agree here; you won't be able to build from the nettle repo out
of the box (just like you currently can't build HEAD out of the box).

But I still think it's desirable to have older history, before directory
renames, available for git log.

Another approach I've been considering is to do a conversion which
purges unrelated files (most of src except src/nettle and src/symmetric,
most of misc, all contents in doc, argp, sftp, spki, most top-level
files). And then use version controlled operations for the remaining
cleanup and renames. The aim would then be to make it possible to check
out old versions (with their different directory layout) and build them.

But at the moment, I'm leaning towards moving directories in the
conversion, since I think that will be less confusing with git log and
diff. E.g., I'd expect

  git diff master nettle_1.7_release_20030311 -- configure.ac

to show a diff of nettle's configure.ac in different revisions, not a
diff between nettle's current configure.ac and a historic configure.ac
from lsh.

/nisse

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120208210751</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-02-08 21:07:51-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; However, this conversion loses quite a lot of history, including all
&gt; nettle-1.15 releases. To actually build old versions, one would need to
&gt; use the lsh repo (due to the shared files linked by lsh's ./.bootstrap),
&gt; but it would be nice to still have the history in the nettle repo.

Now I have a new test repo. Not created using git filter-branch on the
lsh git repository, but converted from the same old cvs files, using
pcvs2git and a new configuration file written primarily by Henrik
Grubbström.

The conversion moves files from nettle, src/nettle and src/symmetric
(whichever is found first) to the top level. Also tries to keep the
shared files, also putting them at top-level in the new repo (getopt*,
config.guess, misc/run-tests, and a few more). Some symlinking still
needs to be added to the .bootstrap script before one can build.

See

  git://git.lysator.liu.se/lsh-test/nettle-test-2.git

/nisse

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120209090515</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-02-09 09:05:15-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>

ons 2012-02-08 klockan 22:07 +0100 skrev Niels Möller:
&gt;   git://git.lysator.liu.se/lsh-test/nettle-test-2.git

Looks good to me.  It is probably easier to preserve history by going
from a cvs repository directly to git.  Maybe the CVS repository could
even be tweaked somewhat before the conversion to make it look more like
a "nettle" cvs repository than a lsh repository...

/Simon



</body></email><email><emailId>20120214202731</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-02-14 20:27:31-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Now I have a new test repo. Not created using git filter-branch on the
&gt; lsh git repository, but converted from the same old cvs files, using
&gt; pcvs2git and a new configuration file written primarily by Henrik
&gt; Grubbström.

Yet another try, and unless I discover any problems with this soon, it's
going to be the final one.

  git://git.lysator.liu.se/lsh-test/nettle-test-3.git

Difference from the previous one is that I've hacked the pcvs2git.pike
program to keep track of the original path to each RCS file (as it moves
directories up one or two levels), and use that in the generated Rev:
comments. E.g, for git log -- twofish.c (a file at the top-level in the
new git repo), git log includes the following commits (among others):

commit f9ec0110676f16e263688b208c3a2e8735723e7d
Author: Niels Möller &lt;nisse@lysator.liu.se&gt;
Date:   2010-07-07 21:32:03 +0200

    * aes.h (aes_encrypt, aes_decrypt): Declare ctx argument as const.
    Also updated implementation.
    * blowfish.h (blowfish_encrypt, blowfish_decrypt): Likewise.
    * cast128.h (cast128_encrypt, cast128_decrypt): Likewise.
    * serpent.h (serpent_encrypt, serpent_decrypt): Likewise.
    * twofish.h (twofish_encrypt, twofish_decrypt): Likewise.
    
    Rev: nettle/ChangeLog:1.91
    Rev: nettle/aes-decrypt.c:1.2
    Rev: nettle/aes-encrypt.c:1.2
    Rev: nettle/aes.h:1.2
    Rev: nettle/blowfish.c:1.3
    Rev: nettle/blowfish.h:1.3
    Rev: nettle/cast128.c:1.2
    Rev: nettle/cast128.h:1.2
    Rev: nettle/serpent.c:1.2
    Rev: nettle/serpent.h:1.2
    Rev: nettle/twofish.c:1.2
    Rev: nettle/twofish.h:1.2

commit dd06afa4b49913037dabe6cab40ae1b9d49a0344
Author: Niels Möller &lt;nisse@lysator.liu.se&gt;
Date:   2004-10-05 23:46:33 +0200

    (q_table): Use a const pointer array.
    
    Rev: src/nettle/twofish.c:1.7

commit 7b6ff2dcdaef64e194c9b83eed3354a5acda9168
Author: Niels Möller &lt;nisse@lysator.liu.se&gt;
Date:   1999-03-08 00:52:36 +0100

    Moved UNUSED attribute to be compatible with gcc-2.x, x&lt;8.
    
    Rev: src/symmetric/twofish.c:1.3

Note that the Rev: comments refer to different RCS files, and this
information is needed to locate the corresponding change in the old CVS
repo.

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120215193233</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-02-15 19:32:33-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Yet another try, and unless I discover any problems with this soon, it's
&gt; going to be the final one.

Turns out I had broken the handling of deleted files. So another try,

  git://git.lysator.liu.se/lsh-test/nettle-test-4.git

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120218211936</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-02-18 21:19:36-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>

I think the conversion can be declared final now. New repo at

  git://git.lysator.liu.se/nettle/nettle.git

I have fixed the Makefiles so that they work in the new setting. After
cloning, you need to run the ./.bootstrap script, then ./configure &amp;&amp;
make as usual.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120117125837</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-01-17 12:58:37-0400</timestampReceived><subject>Re: Building libnettle on MS-Windows</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt;I found that having this in configure.ac:
&gt;
&gt;   AC_PROG_LN_S
&gt;
&gt; is probably all you need.

I have added this now.

&gt; Yes, except that I would use _setmode, as that will also work for
&gt; Windows compilers other than MinGW.

And this.

I also found out that dlls apperantly weren't linked into the .lib
directory, so I tried to fix that as well. This directory is added to
LD_LIBRARY_PATH (for ELF systems) and PATH (for windows), when running
the testsuite.

Unfortunately, I couldn't figure out how to get wine to add the .lib
directory to the initial PATH. So for now, as a workaround, I create
symlinks also in the testsuite and examples subdirectories in the build
tree, when cross compiling for windows. With that change,

  ./configure '--host=i586-mingw32msvc' '--enable-shared'
  make
  make check

works for me.

I just put up a prerelease at
http://www.lysator.liu.se/~nisse/archive/nettle-2.5-pre.tar.gz (and
.sig), any testing (in particular on windows) is appreciated.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120117130930</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-01-17 13:09:30-0400</timestampReceived><subject>Re: Building libnettle on MS-Windows</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I just put up a prerelease at
&gt; http://www.lysator.liu.se/~nisse/archive/nettle-2.5-pre.tar.gz (and
&gt; .sig), any testing (in particular on windows) is appreciated.

With MinGW-64 I got the following error when building:

make[1]: Entering directory `/home/jas/src/nettle-2.5-pre/testsuite'
i686-w64-mingw32-g++ -g -O2 -L..  cxx-test.o testutils.o  -lnettle  -o cxx-test.exe
/home/jas/src/mingw-w64-32/build/root/lib/gcc/i686-w64-mingw32/4.5.1/../../../../i686-w64-mingw32/bin/ld: \
                cannot find -lgcc_s
/home/jas/src/mingw-w64-32/build/root/lib/gcc/i686-w64-mingw32/4.5.1/../../../../i686-w64-mingw32/bin/ld: \
                cannot find -lgcc_s
collect2: ld returnerade avslutningsstatus 1
make[1]: *** [cxx-test.exe] Fel 1

It may be that my MinGW-64 g++ installation is not working properly.
When I passed 'CXX=false' to ./configure it built without errors.

Most self-checks works, except if fails at the end:

PASS: sexp-conv
SKIP: pkcs1-conv
PASS: symbols
===================
All 36 tests passed
===================
rm: argument saknas
Försök med "rm --help" för mer information.
FAIL: ./teardown-env
make[1]: *** [check] Fel 1

The call to find in teardown-env turns out empty.  This seems to be the
case when I build with --enable-shared as well -- then there is only one
hit (./.lib/libnettle-4-3.dll), but it is not under testsuite/.  Should
there be more *.dll files?

/Simon


</body></email><email><emailId>20120117133711</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-01-17 13:37:11-0400</timestampReceived><subject>Re: Building libnettle on MS-Windows</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; With MinGW-64 I got the following error when building:

For clarity: Is this MinGW-64 *natively* on a windows machine, or a
cross compiler?

&gt; make[1]: Entering directory `/home/jas/src/nettle-2.5-pre/testsuite'
&gt; i686-w64-mingw32-g++ -g -O2 -L..  cxx-test.o testutils.o  -lnettle  -o cxx-test.exe
&gt; /home/jas/src/mingw-w64-32/build/root/lib/gcc/i686-w64-mingw32/4.5.1/../../../../i686-w64-mingw32/bin/ld: \
&gt; cannot find -lgcc_s make[1]: *** [cxx-test.exe] Fel 1
&gt; 
&gt; It may be that my MinGW-64 g++ installation is not working properly.

Seems likely; I can't see any reason why the compilation command line
should give that error.

&gt; FAIL: ./teardown-env
&gt; make[1]: *** [check] Fel 1
&gt; 
&gt; The call to find in teardown-env turns out empty.

Ooops. I should replace that backtick expression with an -exec argument
to find.

&gt; This seems to be the case when I build with --enable-shared as well --
&gt; then there is only one hit (./.lib/libnettle-4-3.dll), but it is not
&gt; under testsuite/. Should there be more *.dll files?

For a native build: That's how it should be. The .lib directory is added
to PATH, which should be sufficient for running the testprograms. The
additional symlinks in the testsuite and example directories should be
there only when cross compiling (detected by $EMULATOR matching wine*).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120117134746</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-01-17 13:47:46-0400</timestampReceived><subject>Re: Building libnettle on MS-Windows</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; With MinGW-64 I got the following error when building:
&gt;
&gt; For clarity: Is this MinGW-64 *natively* on a windows machine, or a
&gt; cross compiler?

Cross-compiler, running on a Debian Squeeze machine.

&gt;&gt; This seems to be the case when I build with --enable-shared as well --
&gt;&gt; then there is only one hit (./.lib/libnettle-4-3.dll), but it is not
&gt;&gt; under testsuite/. Should there be more *.dll files?
&gt;
&gt; For a native build: That's how it should be. The .lib directory is added
&gt; to PATH, which should be sufficient for running the testprograms. The
&gt; additional symlinks in the testsuite and example directories should be
&gt; there only when cross compiling (detected by $EMULATOR matching wine*).

I have the binfmt-support package installed, so an emulator is not
strictly required -- i.e., running ./foo.exe will work directly and
using 'wine ./foo.exe' is not necessary.  Will $EMULATOR be empty in
this case?

/Simon

</body></email><email><emailId>20120117140620</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-01-17 14:06:20-0400</timestampReceived><subject>Re: Building libnettle on MS-Windows</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; I have the binfmt-support package installed, so an emulator is not
&gt; strictly required -- i.e., running ./foo.exe will work directly and
&gt; using 'wine ./foo.exe' is not necessary.
&gt; Will $EMULATOR be empty in
&gt; this case?

It will most likely have been set automatically to wine64. Check the
substituted variable in config.make. Do you think some additional
configure tests are needed? (Alternatively, one could do something
similar to automake's "make check TESTS_ENVIRONMENT=wine", but that's
not as general since some of the test programs are shell scripts, not
windows executables).

But I think I have found out why the links weren't created. I forgot to
set the executable bit on testsuite/setup-env. And since this is still
cvs, that's a bit painful to get fixed. *sigh*

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120117173846</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2012-01-17 17:38:46-0400</timestampReceived><subject>Re: Building libnettle on MS-Windows</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Cc: nettle-bugs@lists.lysator.liu.se
&gt; Date: Tue, 17 Jan 2012 13:58:37 +0100
&gt; 
&gt; I also found out that dlls apperantly weren't linked into the .lib
&gt; directory, so I tried to fix that as well. This directory is added to
&gt; LD_LIBRARY_PATH (for ELF systems) and PATH (for windows), when running
&gt; the testsuite.
&gt; 
&gt; Unfortunately, I couldn't figure out how to get wine to add the .lib
&gt; directory to the initial PATH.

Is that a wine-specific problem, or a general Windows problem?  If the
latter, maybe I can help if you describe the difficulty.

&gt; I just put up a prerelease at
&gt; http://www.lysator.liu.se/~nisse/archive/nettle-2.5-pre.tar.gz (and
&gt; .sig), any testing (in particular on windows) is appreciated.

Thanks, I will try to do this as soon as I have time.

</body></email><email><emailId>20120117194929</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-01-17 19:49:29-0400</timestampReceived><subject>Re: Building libnettle on MS-Windows</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt;&gt; Unfortunately, I couldn't figure out how to get wine to add the .lib
&gt;&gt; directory to the initial PATH.
&gt;
&gt; Is that a wine-specific problem, or a general Windows problem?

That's wine specific. Wine copies most environment variables from the
unix environment it is started from into the environment of the executed
windows program. With some exceptions for "special" environment
variables, including PATH. After a quick look at the source code, it
looks one should be able to set WINEPATH when starting wine, and have
that copied to the windows path (possibly without any automagic
translation of the filenames). But I couldn't get that to work.

Anyway, it's a wine-specific problem, and I have a workaround.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120121065919</emailId><senderName>Senvey Lee</senderName><senderEmail>senvey@gmail.com</senderEmail><timestampReceived>2012-01-21 06:59:19-0400</timestampReceived><subject>Re: make issues</subject><body>

Niels Möller &lt;nisse@...&gt; writes:

&gt; 
&gt; Anna Smith &lt;anna@...&gt; writes:
&gt; 
&gt; &gt; the link provided is broken :(  can you repost?
&gt; 
&gt; Works for me. Maybe you accidentally copied the "," at the end? That was
&gt; not intended as a part of the url. It should be just
&gt; 
&gt;   http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
&gt; 
&gt; Regards,
&gt; /Niels
&gt; 


Another success! Thanks.

But got an ensuing error:
md5-compress.asm:100:suffix or operands invalid for `push'

Could someone help one this? Thanks.


</body></email><email><emailId>20120131150728</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2012-01-31 15:07:28-0400</timestampReceived><subject>Re: Migration from CVS to GIT</subject><body>


On 01/31/2012 09:50 AM, Martin Storsjö wrote:
&gt; On Tue, 31 Jan 2012, Niels Möller wrote:
&gt; 
&gt;&gt; Testing and general browsing of the history is appreciated. In a few
&gt;&gt; days, I think I'll consider the conversion final.
&gt; 
&gt; The author mapping looks good to me at least, looking forward to the
&gt; final repo (including separated nettle)! Thanks for your work on this!

It also looks good to me.  Thanks for doing this conversion work, Niels.

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20120206193947</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-02-06 19:39:47-0400</timestampReceived><subject>Re: make issues</subject><body>

Senvey Lee &lt;senvey@gmail.com&gt; writes:

&gt; Another success! Thanks.
&gt;
&gt; But got an ensuing error:
&gt; md5-compress.asm:100:suffix or operands invalid for `push'

Sorry  for the late reply.

&gt; Could someone help one this? Thanks.

The md5-compress.asm file exists only for the 32-bit x86 target. I'm
assuming you're building for x86_64? Then either configure and
config.guess stil doesn't recognize your platform correctly, or the
md5.comress.asm link is a left-over from an earlier run of configure.

In the latter case, run make distclean to clean up (with gnu
conventions, this is the make target to use to undo everything done by
configure), and rerun configure.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120808045808</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2012-08-08 04:58:08-0400</timestampReceived><subject>minor documentation patches</subject><body>

[Attachment #2 (multipart/mixed)]


hi nettle folks--

i've pushed a couple minor documentation patches to my git repo at:

 git://lair.fifthhorseman.net/~dkg/nettle

they're also attached below, if you prefer.

Thanks for maintaining nettle,

	--dkg

["semicolons.diff" (text/x-patch)]

diff --git a/nettle.texinfo b/nettle.texinfo
index 0d8b727..cfb4c57 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -1429,10 +1429,10 @@ struct, which is of size @code{context_size}.
 @deftypevrx {Constant Struct} {struct nettle_cipher} nettle_aes192
 @deftypevrx {Constant Struct} {struct nettle_cipher} nettle_aes256
 
-@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_arctwo40;
-@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_arctwo64;
-@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_arctwo128;
-@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_arctwo_gutmann128;
+@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_arctwo40
+@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_arctwo64
+@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_arctwo128
+@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_arctwo_gutmann128
 
 @deftypevrx {Constant Struct} {struct nettle_cipher} nettle_arcfour128
 

["gcm-case.diff" (text/x-patch)]

commit 31f6181defb49d3ebf489376d3da45e30ea98333
Author: Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt;
Date:   Wed Aug 8 00:53:06 2012 -0400

    fix GCM capitalization

diff --git a/nettle.texinfo b/nettle.texinfo
index cfb4c57..4904d91 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -1472,7 +1472,7 @@ processing them independently with the block cipher=
 (Electronic Code
 Book mode, @acronym{ECB}) leaks information. Besides @acronym{ECB},
 Nettle provides three other modes of operation: Cipher Block Chaining
 (@acronym{CBC}), Counter mode (@acronym{CTR}), and Galois/Counter mode
-(@acronym{gcm}). @acronym{CBC} is widely used, but there are a few
+(@acronym{GCM}). @acronym{CBC} is widely used, but there are a few
 subtle issues of information leakage, see, e.g.,
 @uref{http://www.kb.cert.org/vuls/id/958563, @acronym{SSH} @acronym{CBC}=

 vulnerability}. @acronym{CTR} and @acronym{GCM}

commit 1b384831da94458dff63474f9ce66d5637cc86b0
Author: Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt;
Date:   Wed Aug 8 00:52:10 2012 -0400

    clean up stray semicolons in documentation


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20120318104205</emailId><senderName>yyy</senderName><senderEmail>yyy@yyy.id.lv</senderEmail><timestampReceived>2012-03-18 10:42:05-0400</timestampReceived><subject>GNU MP not found (mingw)</subject><body>

Configure fails to find gmp
GMP version 5.0.4
nettle version 2.4
mingw on windows xp sp3

config.log did not contain any recognizable links to missing files
(there were multiple references to "-lgmp", but it was  not a file)
(entire config.log is ~35KB, should I post it here?

Compiling and building GMP was successful, it produced file libgmp.a
with size of 648 236 bytes.

Leaving that file in default lib directory, did not work. Putting it
in nettle directory did not work either. Renaming that file to lgmp.a,
libgmp.a.dll or lgmp.a.dll and copying to nettle directory did not
work either.

Where nettle's configure script is looking for lgmp and what is the
required filename? Could it be, that nettle 2.4 does not work with
GMP 5.0.4 and requires older version?


</body></email><email><emailId>20120406123953</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-04-06 12:39:53-0400</timestampReceived><subject>rsa blinding patch</subject><body>


Hello,
 Attached you'll find an initial patch that adds timing resistant
versions of rsa_compute_root() and rsa_decrypt().

regards,
Nikos


</body></email><email><emailId>20120521140316</emailId><senderName>William Morris</senderName><senderEmail>wrm@hushmail.com</senderEmail><timestampReceived>2012-05-21 14:03:16-0400</timestampReceived><subject>Configure problem on OS-X</subject><body>

Hi.

I obtained the latest nettle using git. 
Running 'configure' on OS-X (10.7.4) fails.

	config.status: error: cannot find input file: config.h.in

Any ideas?
Output from 'configure' given below.
--
William Morris

iMac:nettle $ ./configure 
checking build system type... x86_64-apple-darwin11.4.0
checking host system type... x86_64-apple-darwin11.4.0
checking for -R flag... none
Searching for libraries
checking /usr/local/lib/lib... not found
checking /usr/local/lib... added
checking /sw/local/lib... not found
checking /sw/lib... not found
checking /usr/gnu/lib... not found
checking /opt/gnu/lib... not found
checking /sw/gnu/lib... not found
checking /usr/freeware/lib... not found
checking /usr/pkg/lib... not found
checking for gcc... gcc
checking for C compiler default output file name... a.out
checking whether the C compiler works... yes
checking whether we are cross compiling... no
checking for suffix of executables... 
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking whether gcc accepts -g... yes
checking for gcc option to accept ISO C89... none needed
checking for g++... g++
checking whether we are using the GNU C++ compiler... yes
checking whether g++ accepts -g... yes
checking whether make sets $(MAKE)... yes
checking for ranlib... ranlib
checking for nm... nm
checking for objdump... no
checking for a BSD-compatible install... /usr/bin/install -c
checking for a thread-safe mkdir -p... ./install-sh -c -d
checking whether ln -s works... yes
configure: Compiler uses 64-bit ABI. To change, set CC.
configure: WARNING: Don't know where to install 64-bit libraries on this system.
configure: Libraries to be installed in ${exec_prefix}/lib.
configure: Looking for assembler files in x86_64/.
checking CCPIC... -fPIC
checking if globals are prefixed by underscore... yes
checking if we should use a .note.GNU-stack section... no
checking for ELF-style .type,%function pseudo-ops... no
checking for ELF-style .type,#function pseudo-ops... no
checking if .align assembly directive is logarithmic... yes
checking for m4... /usr/bin/m4
checking for an ANSI C-conforming const... yes
checking for inline... inline
checking how to run the C preprocessor... gcc -E
checking for grep that handles long lines and -e... /usr/bin/grep
checking for egrep... /usr/bin/grep -E
checking for uid_t in sys/types.h... yes
checking for ANSI C header files... yes
checking for sys/types.h... yes
checking for sys/stat.h... yes
checking for stdlib.h... yes
checking for string.h... yes
checking for memory.h... yes
checking for strings.h... yes
checking for inttypes.h... yes
checking for stdint.h... yes
checking for unistd.h... yes
checking for size_t... yes
checking whether time.h and sys/time.h may both be included... yes
checking for long... yes
checking size of long... 8
checking for uint64_t... yes
checking alignment of uint64_t... 8
checking openssl/blowfish.h usability... yes
checking openssl/blowfish.h presence... yes
checking for openssl/blowfish.h... yes
checking openssl/des.h usability... yes
checking openssl/des.h presence... yes
checking for openssl/des.h... yes
checking openssl/cast.h usability... yes
checking openssl/cast.h presence... yes
checking for openssl/cast.h... yes
checking openssl/aes.h usability... yes
checking openssl/aes.h presence... yes
checking for openssl/aes.h... yes
checking for working alloca.h... yes
checking for alloca... yes
checking malloc.h usability... no
checking malloc.h presence... no
checking for malloc.h... no
checking for strerror... yes
checking whether byte ordering is bigendian... no
checking for memxor... no
checking for __attribute__... yes
checking for stdint types... stdint.h (shortcircuit)
make use of stdint.h in nettle-stdint.h (assuming C99 compatible system)
checking for fcntl file locking... yes
checking for __gmpz_getlimbn in -lgmp... no
configure: WARNING: GNU MP not found, or not 3.1 or up, see http://gmplib.org/.
Support for public key algorithms will be unavailable.
checking for __gmpz_powm_sec... no
checking for BF_ecb_encrypt in -lcrypto... yes
checking for library containing clock_gettime... no
configure: creating ./config.status
config.status: creating config.make
config.status: creating config.m4
config.status: creating Makefile
config.status: creating tools/Makefile
config.status: creating testsuite/Makefile
config.status: creating examples/Makefile
config.status: creating nettle.pc
config.status: creating hogweed.pc
config.status: error: cannot find input file: config.h.in
iMac:nettle $ 




</body></email><email><emailId>20120619203429</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-06-19 20:34:29-0400</timestampReceived><subject>Interface for new rsa features</subject><body>

In recent months, some new RSA functions have been added, from
suggestions and work of Nikos. I'd like to hear comments on the
interface before release.

Timing resistant decryption function, using RSA blinding:

  int
  rsa_decrypt_tr(const struct rsa_public_key *pub,
  	       const struct rsa_private_key *key,
  	       void *random_ctx, nettle_random_func *random,	       
  	       unsigned *length, uint8_t *message,
  	       const mpz_t gibberish);


New signing functions taking a "DigestInfo" as input:

  int
  rsa_pkcs1_sign(const struct rsa_private_key *key,
  	       unsigned length, const uint8_t *digest_info,
  	       mpz_t s);
  
  int
  rsa_pkcs1_verify(const struct rsa_public_key *key,
  		 unsigned length, const uint8_t *digest_info,
  		 const mpz_t signature);

Timing-resistant version of the signing function:

  int
  rsa_pkcs1_sign_tr(const struct rsa_public_key *pub,
    	          const struct rsa_private_key *key,
  	          void *random_ctx, nettle_random_func random,
  	          unsigned length, const uint8_t *digest_info,
     	          mpz_t s);

The _tr fucntions use these internal functions for RSA blinding:

  void
  _rsa_blind (const struct rsa_public_key *pub,
  	    void *random_ctx, nettle_random_func random,
  	    mpz_t c, mpz_t ri);
  void
  _rsa_unblind (const struct rsa_public_key *pub, mpz_t c, const mpz_t ri);

Do you think this looks good? I see that there's some inconsistency of
using "nettle_random_func random" vs "nettle_random_func *random", the
latter variant is the preferred form.

It would be nice with timing resistant versions of the other signing
functions, byt I hesitate since we would end up with such a large number
of functions. Some redesign (for some later version) may be appropriate.

It's possible to do deterministic RSA blinding, using something like
HMAC(encoding of private key, message) to generate the random number.
And in similar way, one can do deterministic DSA signatures. That's also
for later, but you may want to take that possibility into account when
commenting on the interface.

In somewhat related reorganization, the interface of the internal
function pkcs1_signature_prefix has changed and is not compatible with
the old version. Questions:

1. Is anyone depending on that function?

2. Does a change of this function require a new solib number? (Depends
   on the answer to previous question).

3. Should I rename it to _pkcs1_signature_prefix, in order to (i) make
   it more clear it's an internal function, and (ii) make applications
   depending on the old behaviour break in a more predictable fashion?

Regards,
/Niels




-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120703193118</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-07-03 19:31:18-0400</timestampReceived><subject>Using alloca on windows</subject><body>

When I try cross-compiling using

  ./configure '--host=i586-mingw32msvc'

I get warnings on alloca usage, e.g.,

  /home/nisse/hack/nettle/cbc.c: In function `nettle_cbc_decrypt':
  /home/nisse/hack/nettle/cbc.c:101: warning: implicit declaration of function \
`alloca'  /home/nisse/hack/nettle/cbc.c:101: warning: incompatible implicit \
declaration of built-in function `alloca'

Which header should I include to get a proper declaration? In config.h,
I have some boilerplate code which includes malloc.h, but only if *not*
using gcc. Should I always include malloc.h if it exists, regardless of
the compiler used?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120913073459</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-13 07:34:59-0400</timestampReceived><subject>Three tests can't be created</subject><body>

Hi,

there are three tests which cannot be build from source:

testsuite/sexp-conv-test
testsuite/symbols-test
testsuite/pkcs1-conv-test

If you remove them the following fails:
make clean
make
make check

Making check in testsuite
make[1]: Entering directory `/usr/oms/src/nettle/testsuite'
make[1]: *** No rule to make target `sexp-conv-test', needed by `check'.  
Stop.

These three binaries are in the git repository ... what's that ?
Shouldn't there be sources a possibility to build the binaries ?

Regards ,Tim

</body></email><email><emailId>20121025195627</emailId><senderName>Dennis Clarke</senderName><senderEmail>dclarke@blastwave.org</senderEmail><timestampReceived>2012-10-25 19:56:27-0400</timestampReceived><subject>nettle-2.5 on solaris 10 Sparc issues</subject><body>


Looks like nettle 2.5 should build pretty much out of the box but the Makefiles seem \
to have a few issues. 

After one tosses a ./configure at it we can build just fine up until a lingage is \
requires thus : 

$ ./configure 
checking build system type... sparc-sun-solaris2.10
checking host system type... sparc-sun-solaris2.10
checking for -R flag... using -R
Searching for libraries
checking /usr/local/lib/lib... not found
checking /usr/local/lib... added
checking /sw/local/lib... not found
checking /sw/lib... not found
checking /usr/gnu/lib... not found
checking /opt/gnu/lib... not found
checking /sw/gnu/lib... not found
checking /usr/freeware/lib... not found
checking /usr/pkg/lib... not found
checking for gcc... /opt/solarisstudio12.3/bin/cc
checking whether the C compiler works... yes
checking for C compiler default output file name... a.out
checking for suffix of executables... 
.
.
.
etc etc 
.
.
.

checking for fcntl file locking... yes
checking for __gmpz_getlimbn in -lgmp... no
configure: WARNING: GNU MP not found, or not 3.1 or up, see http://gmplib.org/.
Support for public key algorithms will be unavailable.
checking for __gmpz_powm_sec... no
checking for library containing clock_gettime... -lrt
configure: creating ./config.status
config.status: creating config.make
config.status: creating config.m4
config.status: creating Makefile
config.status: creating tools/Makefile
config.status: creating testsuite/Makefile
config.status: creating examples/Makefile
config.status: creating nettle.pc
config.status: creating hogweed.pc
config.status: creating config.h
config.status: linking sparc64/aes-encrypt-internal.asm to aes-encrypt-internal.asm
config.status: linking sparc64/aes-decrypt-internal.asm to aes-decrypt-internal.asm
config.status: linking sparc64/arcfour-crypt.asm to arcfour-crypt.asm
config.status: linking sparc64/machine.m4 to machine.m4
config.status: executing nettle-stdint.h commands
config.status: creating nettle-stdint.h : __NETTLE_STDINT_H
configure: summary of build options:

  Version:           nettle 2.5
  Host type:         sparc-sun-solaris2.10
  ABI:               64
  Assembly files:    sparc64
  Install prefix:    /usr/local
  Library directory: ${exec_prefix}/lib/64
  Compiler:          /opt/solarisstudio12.3/bin/cc
  Shared libraries:  yes
  Public key crypto: no


First thing wrong there is that libgmp does exist just fine. 

... anyways .. fire off a gmake and it all looks golden : 

$ gmake 
gmake all-here
gmake[1]: Entering directory `/usr/local/build/nettle-2.5_sparcv9_001'
/opt/solarisstudio12.3/bin/cc -I. -I/usr/local/include:/usr/sfw/include \
-DHAVE_CONFIG_H -errfmt=error -erroff=%none -errshort=full -xstrconst -xildoff -m64 \
-xmemalign=8s -xnolibmil -Xa -xcode=pic32 -xregs=no%appl -xlibmieee -mc -g -xs \
-ftrap=%none -Qy -xbuiltin=%none -xdebugformat=dwarf -xunroll=1 -xtarget=ultraT2 \
-xcache=8/16/4:4096/64/16 -D_TS_ERRNO -D_POSIX_PTHREAD_SEMANTICS \
-D_LARGEFILE64_SOURCE -KPIC -Bdynamic  -KPIC -Bdynamic -c aesdata.c \ &amp;&amp; true
/opt/solarisstudio12.3/bin/cc -errfmt=error -erroff=%none -errshort=full -xstrconst \
-xildoff -m64 -xmemalign=8s -xnolibmil -Xa -xcode=pic32 -xregs=no%appl -xlibmieee -mc \
-g -xs -ftrap=%none -Qy -xbuiltin=%none -xdebugformat=dwarf -xunroll=1 \
-xtarget=ultraT2 -xcache=8/16/4:4096/64/16 -D_TS_ERRNO -D_POSIX_PTHREAD_SEMANTICS \
                -D_LARGEFILE64_SOURCE   aesdata.o  -o aesdata
/opt/solarisstudio12.3/bin/cc -I. -I/usr/local/include:/usr/sfw/include \
-DHAVE_CONFIG_H -errfmt=error -erroff=%none -errshort=full -xstrconst -xildoff -m64 \
-xmemalign=8s -xnolibmil -Xa -xcode=pic32 -xregs=no%appl -xlibmieee -mc -g -xs \
-ftrap=%none -Qy -xbuiltin=%none -xdebugformat=dwarf -xunroll=1 -xtarget=ultraT2 \
-xcache=8/16/4:4096/64/16 -D_TS_ERRNO -D_POSIX_PTHREAD_SEMANTICS \
-D_LARGEFILE64_SOURCE -KPIC -Bdynamic  -KPIC -Bdynamic -c desdata.c \ &amp;&amp; true
.
.
.
... and then link goes boom because of the totally missing options to the \
compiler/linker : 

/opt/solarisstudio12.3/bin/cc -I. -I/usr/local/include:/usr/sfw/include \
-DHAVE_CONFIG_H -errfmt=error -erroff=%none -errshort=full -xstrconst -xildoff -m64 \
-xmemalign=8s -xnolibmil -Xa -xcode=pic32 -xregs=no%appl -xlibmieee -mc -g -xs \
-ftrap=%none -Qy -xbuiltin=%none -xdebugformat=dwarf -xunroll=1 -xtarget=ultraT2 \
-xcache=8/16/4:4096/64/16 -D_TS_ERRNO -D_POSIX_PTHREAD_SEMANTICS \
-D_LARGEFILE64_SOURCE -KPIC -Bdynamic  -KPIC -Bdynamic -c memxor.c -o memxor.po \ &amp;&amp; \
                true
/opt/solarisstudio12.3/bin/cc  -G -h libnettle.so.4 aes-decrypt-internal.po \
aes-decrypt.po aes-encrypt-internal.po aes-encrypt.po aes-encrypt-table.po \
aes-set-encrypt-key.po aes-set-decrypt-key.po aes-meta.po arcfour.po arcfour-crypt.po \
arcfour-meta.po arctwo.po arctwo-meta.po base16-encode.po base16-decode.po \
base16-meta.po base64-encode.po base64-decode.po base64-meta.po camellia-crypt.po \
camellia-crypt-internal.po camellia-set-encrypt-key.po camellia-set-decrypt-key.po \
camellia-table.po camellia-meta.po cast128.po cast128-meta.po blowfish.po cbc.po \
ctr.po gcm.po gcm-aes.po des.po des3.po des-compat.po hmac.po hmac-md5.po \
hmac-ripemd160.po hmac-sha1.po hmac-sha224.po hmac-sha256.po hmac-sha384.po \
hmac-sha512.po knuth-lfib.po md2.po md2-meta.po md4.po md4-meta.po md5.po \
md5-compress.po md5-compat.po md5-meta.po ripemd160.po ripemd160-compress.po \
ripemd160-meta.po salsa20-crypt.po salsa20-set-key.po sha1.po sha1-compress.po \
sha1-meta.po sha256.po sha256-compress.po sha224-me ta.po sha256-meta.po sha512.po \
sha512-compress.po sha384-meta.po sha512-meta.po serpent-set-key.po \
serpent-encrypt.po serpent-decrypt.po serpent-meta.po twofish.po twofish-meta.po \
yarrow256.po yarrow_key_event.po buffer.po buffer-init.po realloc.po \
nettle-meta-hashes.po nettle-meta-ciphers.po nettle-meta-armors.po write-be32.po \
                write-le32.po memxor.po -o libnettle.so 
ld: fatal: file aes-decrypt-internal.po: wrong ELF class: ELFCLASS64
ld: fatal: file processing errors. No output written to libnettle.so
gmake[1]: *** [libnettle.so] Error 2
gmake[1]: Leaving directory `/usr/local/build/nettle-2.5_sparcv9_001'
gmake: *** [all] Error 2
$ 

So let's drop that into a script and kick it off thus : 


$ cat link_hack.sh 
#!/bin/ksh

CFLAGS=\-errfmt=error\ \-erroff=%none\ \-errshort=full\ \-xstrconst\ \
\-xildoff\ \-m64\ \-xmemalign=8s\ \-xnolibmil\ \-Xa\ \-xcode=pic32\ \
\-xregs=no%appl\ \-xlibmieee\ \-mc\ \-g\ \-xs\ \-ftrap=%none\ \-Qy\ \
\-xbuiltin=%none\ \-xdebugformat=dwarf\ \-xunroll=1\ \-xtarget=ultraT2\ \
\-xcache=8/16/4:4096/64/16\ \-D_TS_ERRNO\ \-D_POSIX_PTHREAD_SEMANTICS\ \
\-D_LARGEFILE64_SOURCE
export CFLAGS

/opt/solarisstudio12.3/bin/cc -\# $CFLAGS -G -h libnettle.so.4 \
aes-decrypt-internal.po \
aes-decrypt.po aes-encrypt-internal.po aes-encrypt.po aes-encrypt-table.po \
aes-set-encrypt-key.po aes-set-decrypt-key.po aes-meta.po arcfour.po \
arcfour-crypt.po arcfour-meta.po arctwo.po arctwo-meta.po base16-encode.po \
base16-decode.po base16-meta.po base64-encode.po base64-decode.po \
base64-meta.po camellia-crypt.po camellia-crypt-internal.po \
camellia-set-encrypt-key.po camellia-set-decrypt-key.po camellia-table.po \
camellia-meta.po cast128.po cast128-meta.po blowfish.po cbc.po ctr.po \
gcm.po gcm-aes.po des.po des3.po des-compat.po hmac.po hmac-md5.po \
hmac-ripemd160.po hmac-sha1.po hmac-sha224.po hmac-sha256.po hmac-sha384.po \
hmac-sha512.po knuth-lfib.po md2.po md2-meta.po md4.po md4-meta.po md5.po \
md5-compress.po md5-compat.po md5-meta.po ripemd160.po ripemd160-compress.po \
ripemd160-meta.po salsa20-crypt.po salsa20-set-key.po sha1.po sha1-compress.po \
sha1-meta.po sha256.po sha256-compress.po sha224-meta.po sha256-meta.po \
sha512.po sha512-compress.po sha384-meta.po sha512-meta.po serpent-set-key.po \
serpent-encrypt.po serpent-decrypt.po serpent-meta.po twofish.po \
twofish-meta.po yarrow256.po yarrow_key_event.po buffer.po buffer-init.po \
realloc.po nettle-meta-hashes.po nettle-meta-ciphers.po nettle-meta-armors.po \
write-be32.po write-le32.po memxor.po \
-o libnettle.so 
$ 

beauty .. links fine now : 

$ 
$ ./link_hack.sh 
### cc: Note: NLSPATH = \
/opt/solarisstudio12.3/prod/bin/../lib/locale/%L/LC_MESSAGES/%N.cat:/opt/solarisstudio12.3/prod/bin/../../lib/locale/%L/LC_MESSAGES/%N.cat
 ###     command line files and options (expanded):
### -# -errfmt=error -erroff=%none -errshort=full -xstrconst -m64 -xmemalign=8s \
-xnolibmil -Xa -xcode=pic32 -xregs=no%appl -xlibmieee -mc -g -xs -ftrap=%none -Qy \
-xbuiltin=%none -xdebugformat=dwarf -xunroll=1 -xchip=ultraT2 -xarch=sparcvis2 \
-xcache=8/16/4:4096/64/16 -D_TS_ERRNO -D_POSIX_PTHREAD_SEMANTICS \
-D_LARGEFILE64_SOURCE -G -hlibnettle.so.4 aes-decrypt-internal.po aes-decrypt.po \
aes-encrypt-internal.po aes-encrypt.po aes-encrypt-table.po aes-set-encrypt-key.po \
aes-set-decrypt-key.po aes-meta.po arcfour.po arcfour-crypt.po arcfour-meta.po \
arctwo.po arctwo-meta.po base16-encode.po base16-decode.po base16-meta.po \
base64-encode.po base64-decode.po base64-meta.po camellia-crypt.po \
camellia-crypt-internal.po camellia-set-encrypt-key.po camellia-set-decrypt-key.po \
camellia-table.po camellia-meta.po cast128.po cast128-meta.po blowfish.po cbc.po \
ctr.po gcm.po gcm-aes.po des.po des3.po des-compat.po hmac.po hmac-md5.po \
hmac-ripemd160.po hmac-sha1.po hmac-sha224.po hmac-sha256.po  hmac-sha384.po \
hmac-sha512.po knuth-lfib.po md2.po md2-meta.po md4.po md4-meta.po md5.po \
md5-compress.po md5-compat.po md5-meta.po ripemd160.po ripemd160-compress.po \
ripemd160-meta.po salsa20-crypt.po salsa20-set-key.po sha1.po sha1-compress.po \
sha1-meta.po sha256.po sha256-compress.po sha224-meta.po sha256-meta.po sha512.po \
sha512-compress.po sha384-meta.po sha512-meta.po serpent-set-key.po \
serpent-encrypt.po serpent-decrypt.po serpent-meta.po twofish.po twofish-meta.po \
yarrow256.po yarrow_key_event.po buffer.po buffer-init.po realloc.po \
nettle-meta-hashes.po nettle-meta-ciphers.po nettle-meta-armors.po write-be32.po \
write-le32.po memxor.po -olibnettle.so ### cc: Note: LD_LIBRARY_PATH = (null)
### cc: Note: LD_LIBRARY_PATH_64 = (null)
### cc: Note: LD_RUN_PATH     = /usr/local/lib/$ISALIST:/usr/sfw/lib/$ISALIST
### cc: Note: LD_OPTIONS      = \
-R/usr/local/lib/$ISALIST:/usr/sfw/lib/$ISALIST:/usr/local/lib:/usr/sfw/lib \
-L/usr/local/lib/$ISALIST:/usr/sfw/lib/$ISALIST:/usr/local/lib:/usr/sfw/lib ln -s \
                /opt/solarisstudio12.3/prod/lib /tmp/lib_link.1351194670.1817.01
/usr/ccs/bin/ld -zld32=-S/tmp/lib_link.1351194670.1817.01/libldstab_ws.so \
-zld64=-S/tmp/lib_link.1351194670.1817.01/v9/libldstab_ws.so \
-zld32=-S/tmp/lib_link.1351194670.1817.01/libld_annotate.so \
-zld64=-S/tmp/lib_link.1351194670.1817.01/v9/libld_annotate.so \
/opt/solarisstudio12.3/prod/lib/v9/crti.o \
/opt/solarisstudio12.3/prod/lib/v9/values-xi.o -hlibnettle.so.4 \
aes-decrypt-internal.po aes-decrypt.po aes-encrypt-internal.po aes-encrypt.po \
aes-encrypt-table.po aes-set-encrypt-key.po aes-set-decrypt-key.po aes-meta.po \
arcfour.po arcfour-crypt.po arcfour-meta.po arctwo.po arctwo-meta.po base16-encode.po \
base16-decode.po base16-meta.po base64-encode.po base64-decode.po base64-meta.po \
camellia-crypt.po camellia-crypt-internal.po camellia-set-encrypt-key.po \
camellia-set-decrypt-key.po camellia-table.po camellia-meta.po cast128.po \
cast128-meta.po blowfish.po cbc.po ctr.po gcm.po gcm-aes.po des.po des3.po \
des-compat.po hmac.po hmac-md5.po hmac-ripemd160.po hmac-sha1.po hmac-sha224.po  \
hmac-sha256.po hmac-sha384.po hmac-sha512.po knuth-lfib.po md2.po md2-meta.po md4.po \
md4-meta.po md5.po md5-compress.po md5-compat.po md5-meta.po ripemd160.po \
ripemd160-compress.po ripemd160-meta.po salsa20-crypt.po salsa20-set-key.po sha1.po \
sha1-compress.po sha1-meta.po sha256.po sha256-compress.po sha224-meta.po \
sha256-meta.po sha512.po sha512-compress.po sha384-meta.po sha512-meta.po \
serpent-set-key.po serpent-encrypt.po serpent-decrypt.po serpent-meta.po twofish.po \
twofish-meta.po yarrow256.po yarrow_key_event.po buffer.po buffer-init.po realloc.po \
nettle-meta-hashes.po nettle-meta-ciphers.po nettle-meta-armors.po write-be32.po \
write-le32.po memxor.po -G -o libnettle.so -Y \
"P,/opt/solarisstudio12.3/prod/lib/sparcvis2/64:/opt/solarisstudio12.3/prod/lib/v9:/usr/ccs/lib/sparcv9:/lib/64:/usr/lib/64" \
                -Qy /opt/solarisstudio12.3/prod/lib/v9/crtn.o
/usr/ccs/bin/mcs -c libnettle.so
$ 

$ ls -lap libnettle.so
-rwxr-xr-x   1 dclarke  other     590976 Oct 25 19:51 libnettle.so
$ 
$ file libnettle.so
libnettle.so: ELF 64-bit MSB dynamic lib SPARCV9 Version 1, UltraSPARC3 Extensions \
Required, dynamically linked, not stripped $ elfdump -d libnettle.so

Dynamic Section:  .dynamic
     index  tag                value
       [0]  INIT              0x39f28             
       [1]  FINI              0x39f38             
       [2]  SONAME            0x163d              libnettle.so.4
       [3]  RUNPATH           0x164c              \
                /usr/local/lib/$ISALIST:/usr/sfw/lib/$ISALIST:/usr/local/lib:/usr/sfw/lib
                
       [4]  RPATH             0x164c              \
/usr/local/lib/$ISALIST:/usr/sfw/lib/$ISALIST:/usr/local/lib:/usr/sfw/lib  [5]  HASH  \
0x328                 [6]  STRTAB            0x23a0              
       [7]  STRSZ             0x1896              
       [8]  SYMTAB            0xb58               
       [9]  SYMENT            0x18                
      [10]  CHECKSUM          0xbcd1              
      [11]  RELACOUNT         0x89                
      [12]  PLTRELSZ          0x690               
      [13]  PLTREL            0x7                 
      [14]  JMPREL            0x5ca8              
      [15]  RELA              0x3c38              
      [16]  RELASZ            0x2700              
      [17]  RELAENT           0x18                
      [18]  REGISTER          0x4e                
      [19]  REGISTER          0x60                
      [20]  FLAGS             0                   0
      [21]  FLAGS_1           0                   0
      [22]  SUNW_STRPAD       0x200               
      [23]  SUNW_LDMACH       0x2b                EM_SPARCV9
      [24]  PLTGOT            0x142f00            
   [25-35]  NULL              0                   
$ 

For some reasons your makefiles seem to forget that this may be a 64-bit sparc server \
and you toss away the $CFLAGS entirely. 

If I try to continue from here .. all is beautiful and we get a nice clean build.  \
Piles of warnings and lots of noise about "incompatible with prototype" stuff but \
certainly compilable and buildable. 

$ find . -type f | xargs file | grep ELF | cut -f1 -d\: | grep -v "\.o$" | sort | cat \
-n -  1  ./aes-decrypt-internal.po
     2  ./aes-decrypt.po
     3  ./aes-encrypt-internal.po
     4  ./aes-encrypt-table.po
     5  ./aes-encrypt.po
     6  ./aes-meta.po
     7  ./aes-set-decrypt-key.po
     8  ./aes-set-encrypt-key.po
     9  ./aesdata
    10  ./arcfour-crypt.po
    11  ./arcfour-meta.po
    12  ./arcfour.po
    13  ./arctwo-meta.po
    14  ./arctwo.po
    15  ./base16-decode.po
    16  ./base16-encode.po
    17  ./base16-meta.po
    18  ./base64-decode.po
    19  ./base64-encode.po
    20  ./base64-meta.po
    21  ./blowfish.po
    22  ./buffer-init.po
    23  ./buffer.po
    24  ./camellia-crypt-internal.po
    25  ./camellia-crypt.po
    26  ./camellia-meta.po
    27  ./camellia-set-decrypt-key.po
    28  ./camellia-set-encrypt-key.po
    29  ./camellia-table.po
    30  ./cast128-meta.po
    31  ./cast128.po
    32  ./cbc.po
    33  ./ctr.po
    34  ./des-compat.po
    35  ./des.po
    36  ./des3.po
    37  ./desdata
    38  ./examples/base16dec
    39  ./examples/base16enc
    40  ./examples/base64dec
    41  ./examples/base64enc
    42  ./examples/eratosthenes
    43  ./examples/nettle-benchmark
    44  ./examples/next-prime
    45  ./examples/random-prime
    46  ./examples/rsa-decrypt
    47  ./examples/rsa-encrypt
    48  ./examples/rsa-keygen
    49  ./examples/rsa-sign
    50  ./examples/rsa-verify
    51  ./gcm-aes.po
    52  ./gcm.po
    53  ./gcmdata
    54  ./hmac-md5.po
    55  ./hmac-ripemd160.po
    56  ./hmac-sha1.po
    57  ./hmac-sha224.po
    58  ./hmac-sha256.po
    59  ./hmac-sha384.po
    60  ./hmac-sha512.po
    61  ./hmac.po
    62  ./knuth-lfib.po
    63  ./libhogweed.so
    64  ./libnettle.so
    65  ./md2-meta.po
    66  ./md2.po
    67  ./md4-meta.po
    68  ./md4.po
    69  ./md5-compat.po
    70  ./md5-compress.po
    71  ./md5-meta.po
    72  ./md5.po
    73  ./memxor.po
    74  ./nettle-meta-armors.po
    75  ./nettle-meta-ciphers.po
    76  ./nettle-meta-hashes.po
    77  ./realloc.po
    78  ./ripemd160-compress.po
    79  ./ripemd160-meta.po
    80  ./ripemd160.po
    81  ./salsa20-crypt.po
    82  ./salsa20-set-key.po
    83  ./serpent-decrypt.po
    84  ./serpent-encrypt.po
    85  ./serpent-meta.po
    86  ./serpent-set-key.po
    87  ./sha1-compress.po
    88  ./sha1-meta.po
    89  ./sha1.po
    90  ./sha224-meta.po
    91  ./sha256-compress.po
    92  ./sha256-meta.po
    93  ./sha256.po
    94  ./sha384-meta.po
    95  ./sha512-compress.po
    96  ./sha512-meta.po
    97  ./sha512.po
    98  ./shadata
    99  ./testsuite/aes-test
   100  ./testsuite/arcfour-test
   101  ./testsuite/arctwo-test
   102  ./testsuite/base16-test
   103  ./testsuite/base64-test
   104  ./testsuite/bignum-test
   105  ./testsuite/blowfish-test
   106  ./testsuite/buffer-test
   107  ./testsuite/camellia-test
   108  ./testsuite/cast128-test
   109  ./testsuite/cbc-test
   110  ./testsuite/ctr-test
   111  ./testsuite/cxx-test
   112  ./testsuite/des-compat-test
   113  ./testsuite/des-test
   114  ./testsuite/des3-test
   115  ./testsuite/dsa-keygen-test
   116  ./testsuite/dsa-test
   117  ./testsuite/gcm-test
   118  ./testsuite/hmac-test
   119  ./testsuite/knuth-lfib-test
   120  ./testsuite/md2-test
   121  ./testsuite/md4-test
   122  ./testsuite/md5-compat-test
   123  ./testsuite/md5-test
   124  ./testsuite/memxor-test
   125  ./testsuite/meta-armor-test
   126  ./testsuite/meta-cipher-test
   127  ./testsuite/meta-hash-test
   128  ./testsuite/pkcs1-test
   129  ./testsuite/random-prime-test
   130  ./testsuite/ripemd160-test
   131  ./testsuite/rsa-encrypt-test
   132  ./testsuite/rsa-keygen-test
   133  ./testsuite/rsa-test
   134  ./testsuite/rsa2sexp-test
   135  ./testsuite/salsa20-test
   136  ./testsuite/serpent-test
   137  ./testsuite/sexp-format-test
   138  ./testsuite/sexp-test
   139  ./testsuite/sexp2rsa-test
   140  ./testsuite/sha1-huge-test
   141  ./testsuite/sha1-test
   142  ./testsuite/sha224-test
   143  ./testsuite/sha256-test
   144  ./testsuite/sha384-test
   145  ./testsuite/sha512-test
   146  ./testsuite/twofish-test
   147  ./testsuite/yarrow-test
   148  ./tools/nettle-hash
   149  ./tools/nettle-lfib-stream
   150  ./tools/pkcs1-conv
   151  ./tools/sexp-conv
   152  ./twofish-meta.po
   153  ./twofish.po
   154  ./twofishdata
   155  ./write-be32.po
   156  ./write-le32.po
   157  ./yarrow256.po
   158  ./yarrow_key_event.po
$ 

what the heck is a po file ? 

Anyways ... makefiles seem a bit off and a autoreconf --verbose --install may be \
needed after a tweak to Makefile.am or similar. 

Dennis 


</body></email><email><emailId>20120925180320</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-09-25 18:03:20-0400</timestampReceived><subject>gost hash</subject><body>

Hello,
 The attached patch adds the GOST R 34.11-94 hash algorithm. I based
this code on Alexei Kravchenko's code from librhash. The original code
[0] had inline assembly for x86 and x86-64 which is removed from this
version.

Although this is not a modern algorithm it is being used in the russian
digital signature standard (GOST R 34.11-2001).

I had issue making the test gost94-test compile. For some reason the
makefile wouldn't link it against gmp (all the other tests were ok), and
couldn't figure out why.

regards,
Nikos

[0].
http://hg.splayer.org/splayer/src/5027d6aa04f1/Thirdparty/librhash/librhash/


["0001-Added-GOST-R-34.11-94-hash-algorithm.patch" (text/x-patch)]

&gt;From 9446c0814abc6d3966320a1a384ffbe05dee0c30 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Tue, 25 Sep 2012 19:57:13 +0200
Subject: [PATCH 1/2] Added GOST R 34.11-94 hash algorithm.

---
 Makefile.in             |    4 +-
 gost94-meta.c           |   32 +++
 gost94-tables.c         |  494 +++++++++++++++++++++++++++++++++++++++++++++++
 gost94.c                |  387 +++++++++++++++++++++++++++++++++++++
 gost94.h                |   55 ++++++
 nettle-meta.h           |    1 +
 testsuite/Makefile.in   |    2 +-
 testsuite/gost94-test.c |   21 ++
 8 files changed, 994 insertions(+), 2 deletions(-)
 create mode 100644 gost94-meta.c
 create mode 100644 gost94-tables.c
 create mode 100644 gost94.c
 create mode 100644 gost94.h
 create mode 100644 testsuite/gost94-test.c

diff --git a/Makefile.in b/Makefile.in
index c0ca3ad..ad0db42 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -64,7 +64,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 aes-encrypt-internal.c aes-encrypt.c aes-encrypt-table.c \
 		 aes-set-encrypt-key.c aes-set-decrypt-key.c aes-meta.c \
 		 arcfour.c arcfour-crypt.c arcfour-meta.c \
-		 arctwo.c arctwo-meta.c \
+		 arctwo.c arctwo-meta.c gost94-meta.c \
 		 base16-encode.c base16-decode.c base16-meta.c \
                  base64-encode.c base64-decode.c base64-meta.c \
 		 camellia-crypt.c camellia-crypt-internal.c \
@@ -81,6 +81,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 knuth-lfib.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
+		 gost94.c gost94-tables.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
 		 salsa20-core-internal.c \
 		 salsa20-crypt.c salsa20-set-key.c \
@@ -129,6 +130,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h bignum.h blowfish.h \
 	  knuth-lfib.h \
 	  macros.h \
 	  md2.h md4.h \
+	  gost94.h \
 	  md5.h md5-compat.h \
 	  memxor.h \
 	  nettle-meta.h nettle-types.h \
diff --git a/gost94-meta.c b/gost94-meta.c
new file mode 100644
index 0000000..46d0c45
--- /dev/null
+++ b/gost94-meta.c
@@ -0,0 +1,32 @@
+/* gost3411-94-meta.c */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2002 Niels Möller
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "gost94.h"
+
+const struct nettle_hash nettle_gost94
+= _NETTLE_HASH(gost94, GOST94);
diff --git a/gost94-tables.c b/gost94-tables.c
new file mode 100644
index 0000000..e68467f
--- /dev/null
+++ b/gost94-tables.c
@@ -0,0 +1,494 @@
+/* gost.c - an implementation of GOST Hash Function
+ * based on the Russian Standard GOST R 34.11-94.
+ * See also RFC 4357.
+ *
+ * Implementation written by Alexei Kravchenko.
+ * Ported to nettle by Nikos Mavrogiannopoulos.
+ *
+ * Copyleft:
+ * I hereby release this code into the public domain. This applies worldwide.
+ * I grant any entity the right to use this work for ANY PURPOSE,
+ * without any conditions, unless such conditions are required by law.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include &lt;string.h&gt;
+
+#include "macros.h"
+#include "gost94.h"
+
+#ifdef GENERATE_GOST_LOOKUP_TABLE
+uint32_t gost94_sbox[4][256];
+uint32_t gost94_sbox_cryptpro[4][256];
+
+/**
+ * Calculate a lookup table from S-Boxes.
+ * A substitution table is used to speed up hash calculation.
+ *
+ * @param out pointer to the lookup table to fill
+ * @param src pointer to eight S-Boxes to fill the table from
+ */
+static void
+fill_gost94_sbox (uint32_t out[4][256], const uint8_t src[8][16])
+{
+    int a, b, i;
+    unsigned long ax, bx, cx, dx;
+
+    for (i = 0, a = 0; a &lt; 16; a++)
+      {
+          ax = (unsigned) src[1][a] &lt;&lt; 15;
+          bx = (unsigned) src[3][a] &lt;&lt; 23;
+          cx = ROTL32 ((unsigned) src[5][a], 31);
+          dx = (unsigned) src[7][a] &lt;&lt; 7;
+
+          for (b = 0; b &lt; 16; b++, i++)
+            {
+                out[0][i] = ax | ((unsigned) src[0][b] &lt;&lt; 11);
+                out[1][i] = bx | ((unsigned) src[2][b] &lt;&lt; 19);
+                out[2][i] = cx | ((unsigned) src[4][b] &lt;&lt; 27);
+                out[3][i] = dx | ((unsigned) src[6][b] &lt;&lt; 3);
+            }
+      }
+}
+
+/**
+ * Initialize the GOST lookup tables for both parameters sets.
+ * Two lookup tables contain 8 KiB in total, so calculating
+ * them at rine-time can save a little space in the exutable file
+ * in trade of consuming some time at pogram start.
+ */
+void
+gost94_init_table (void)
+{
+    /* Test parameters set. Eight 4-bit S-Boxes defined by GOST R 34.10-94
+     * standart for testing the hash function. 
+     * Also given by RFC 4357 section 11.2 */
+    static const uint8_t sbox[8][16] = {
+        {4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3},
+        {14, 11, 4, 12, 6, 13, 15, 10, 2, 3, 8, 1, 0, 7, 5, 9},
+        {5, 8, 1, 13, 10, 3, 4, 2, 14, 15, 12, 7, 6, 0, 9, 11},
+        {7, 13, 10, 1, 0, 8, 9, 15, 14, 4, 6, 12, 11, 2, 5, 3},
+        {6, 12, 7, 1, 5, 15, 13, 8, 4, 10, 9, 14, 0, 3, 11, 2},
+        {4, 11, 10, 0, 7, 2, 1, 13, 3, 6, 8, 5, 9, 12, 15, 14},
+        {13, 11, 4, 1, 3, 15, 5, 9, 0, 10, 14, 7, 6, 8, 2, 12},
+        {1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12}
+    };
+
+    /* Parameter set recommended by RFC 4357.
+     * Eight 4-bit S-Boxes as defined by RFC 4357 section 11.2 */
+    static const uint8_t sbox_cryptpro[8][16] = {
+        {10, 4, 5, 6, 8, 1, 3, 7, 13, 12, 14, 0, 9, 2, 11, 15},
+        {5, 15, 4, 0, 2, 13, 11, 9, 1, 7, 6, 3, 12, 14, 10, 8},
+        {7, 15, 12, 14, 9, 4, 1, 0, 3, 11, 5, 2, 6, 10, 8, 13},
+        {4, 10, 7, 12, 0, 15, 2, 8, 14, 1, 6, 5, 13, 11, 9, 3},
+        {7, 6, 4, 11, 9, 12, 2, 10, 1, 8, 0, 14, 15, 13, 3, 5},
+        {7, 6, 2, 4, 13, 9, 15, 0, 10, 1, 5, 11, 8, 14, 12, 3},
+        {13, 14, 4, 1, 7, 0, 5, 10, 3, 12, 8, 15, 6, 2, 9, 11},
+        {1, 3, 10, 9, 5, 11, 4, 15, 8, 6, 7, 14, 13, 0, 2, 12}
+    };
+
+    fill_gost94_sbox (gost94_sbox, sbox);
+    fill_gost94_sbox (gost94_sbox_cryptpro, sbox_cryptpro);
+}
+
+#else /* GENERATE_GOST_LOOKUP_TABLE */
+
+/* pre-initialized GOST lookup tables based on rotated S-Box */
+/* pre-initialized GOST lookup tables based on rotated S-Box */
+const uint32_t gost94_sbox[4][256] = {
+  {
+    0x72000, 0x75000, 0x74800, 0x71000, 0x76800,
+    0x74000, 0x70000, 0x77000, 0x73000, 0x75800,
+    0x70800, 0x76000, 0x73800, 0x77800, 0x72800,
+    0x71800, 0x5A000, 0x5D000, 0x5C800, 0x59000,
+    0x5E800, 0x5C000, 0x58000, 0x5F000, 0x5B000,
+    0x5D800, 0x58800, 0x5E000, 0x5B800, 0x5F800,
+    0x5A800, 0x59800, 0x22000, 0x25000, 0x24800,
+    0x21000, 0x26800, 0x24000, 0x20000, 0x27000,
+    0x23000, 0x25800, 0x20800, 0x26000, 0x23800,
+    0x27800, 0x22800, 0x21800, 0x62000, 0x65000,
+    0x64800, 0x61000, 0x66800, 0x64000, 0x60000,
+    0x67000, 0x63000, 0x65800, 0x60800, 0x66000,
+    0x63800, 0x67800, 0x62800, 0x61800, 0x32000,
+    0x35000, 0x34800, 0x31000, 0x36800, 0x34000,
+    0x30000, 0x37000, 0x33000, 0x35800, 0x30800,
+    0x36000, 0x33800, 0x37800, 0x32800, 0x31800,
+    0x6A000, 0x6D000, 0x6C800, 0x69000, 0x6E800,
+    0x6C000, 0x68000, 0x6F000, 0x6B000, 0x6D800,
+    0x68800, 0x6E000, 0x6B800, 0x6F800, 0x6A800,
+    0x69800, 0x7A000, 0x7D000, 0x7C800, 0x79000,
+    0x7E800, 0x7C000, 0x78000, 0x7F000, 0x7B000,
+    0x7D800, 0x78800, 0x7E000, 0x7B800, 0x7F800,
+    0x7A800, 0x79800, 0x52000, 0x55000, 0x54800,
+    0x51000, 0x56800, 0x54000, 0x50000, 0x57000,
+    0x53000, 0x55800, 0x50800, 0x56000, 0x53800,
+    0x57800, 0x52800, 0x51800, 0x12000, 0x15000,
+    0x14800, 0x11000, 0x16800, 0x14000, 0x10000,
+    0x17000, 0x13000, 0x15800, 0x10800, 0x16000,
+    0x13800, 0x17800, 0x12800, 0x11800, 0x1A000,
+    0x1D000, 0x1C800, 0x19000, 0x1E800, 0x1C000,
+    0x18000, 0x1F000, 0x1B000, 0x1D800, 0x18800,
+    0x1E000, 0x1B800, 0x1F800, 0x1A800, 0x19800,
+    0x42000, 0x45000, 0x44800, 0x41000, 0x46800,
+    0x44000, 0x40000, 0x47000, 0x43000, 0x45800,
+    0x40800, 0x46000, 0x43800, 0x47800, 0x42800,
+    0x41800, 0xA000,  0xD000,  0xC800,  0x9000,
+    0xE800,  0xC000,  0x8000,  0xF000,  0xB000,
+    0xD800,  0x8800,  0xE000,  0xB800,  0xF800,
+    0xA800,  0x9800,  0x2000,  0x5000,  0x4800,
+    0x1000,  0x6800,  0x4000,  0x0,     0x7000,
+    0x3000,  0x5800,  0x800,   0x6000,  0x3800,
+    0x7800,  0x2800,  0x1800,  0x3A000, 0x3D000,
+    0x3C800, 0x39000, 0x3E800, 0x3C000, 0x38000,
+    0x3F000, 0x3B000, 0x3D800, 0x38800, 0x3E000,
+    0x3B800, 0x3F800, 0x3A800, 0x39800, 0x2A000,
+    0x2D000, 0x2C800, 0x29000, 0x2E800, 0x2C000,
+    0x28000, 0x2F000, 0x2B000, 0x2D800, 0x28800,
+    0x2E000, 0x2B800, 0x2F800, 0x2A800, 0x29800,
+    0x4A000, 0x4D000, 0x4C800, 0x49000, 0x4E800,
+    0x4C000, 0x48000, 0x4F000, 0x4B000, 0x4D800,
+    0x48800, 0x4E000, 0x4B800, 0x4F800, 0x4A800,
+    0x49800
+  }, {
+    0x3A80000, 0x3C00000, 0x3880000, 0x3E80000, 0x3D00000,
+    0x3980000, 0x3A00000, 0x3900000, 0x3F00000, 0x3F80000,
+    0x3E00000, 0x3B80000, 0x3B00000, 0x3800000, 0x3C80000,
+    0x3D80000, 0x6A80000, 0x6C00000, 0x6880000, 0x6E80000,
+    0x6D00000, 0x6980000, 0x6A00000, 0x6900000, 0x6F00000,
+    0x6F80000, 0x6E00000, 0x6B80000, 0x6B00000, 0x6800000,
+    0x6C80000, 0x6D80000, 0x5280000, 0x5400000, 0x5080000,
+    0x5680000, 0x5500000, 0x5180000, 0x5200000, 0x5100000,
+    0x5700000, 0x5780000, 0x5600000, 0x5380000, 0x5300000,
+    0x5000000, 0x5480000, 0x5580000, 0xA80000,  0xC00000,
+    0x880000,  0xE80000,  0xD00000,  0x980000,  0xA00000,
+    0x900000,  0xF00000,  0xF80000,  0xE00000,  0xB80000,
+    0xB00000,  0x800000,  0xC80000,  0xD80000,  0x280000,
+    0x400000,  0x80000,   0x680000,  0x500000,  0x180000,
+    0x200000,  0x100000,  0x700000,  0x780000,  0x600000,
+    0x380000,  0x300000,  0x0,       0x480000,  0x580000,
+    0x4280000, 0x4400000, 0x4080000, 0x4680000, 0x4500000,
+    0x4180000, 0x4200000, 0x4100000, 0x4700000, 0x4780000,
+    0x4600000, 0x4380000, 0x4300000, 0x4000000, 0x4480000,
+    0x4580000, 0x4A80000, 0x4C00000, 0x4880000, 0x4E80000,
+    0x4D00000, 0x4980000, 0x4A00000, 0x4900000, 0x4F00000,
+    0x4F80000, 0x4E00000, 0x4B80000, 0x4B00000, 0x4800000,
+    0x4C80000, 0x4D80000, 0x7A80000, 0x7C00000, 0x7880000,
+    0x7E80000, 0x7D00000, 0x7980000, 0x7A00000, 0x7900000,
+    0x7F00000, 0x7F80000, 0x7E00000, 0x7B80000, 0x7B00000,
+    0x7800000, 0x7C80000, 0x7D80000, 0x7280000, 0x7400000,
+    0x7080000, 0x7680000, 0x7500000, 0x7180000, 0x7200000,
+    0x7100000, 0x7700000, 0x7780000, 0x7600000, 0x7380000,
+    0x7300000, 0x7000000, 0x7480000, 0x7580000, 0x2280000,
+    0x2400000, 0x2080000, 0x2680000, 0x2500000, 0x2180000,
+    0x2200000, 0x2100000, 0x2700000, 0x2780000, 0x2600000,
+    0x2380000, 0x2300000, 0x2000000, 0x2480000, 0x2580000,
+    0x3280000, 0x3400000, 0x3080000, 0x3680000, 0x3500000,
+    0x3180000, 0x3200000, 0x3100000, 0x3700000, 0x3780000,
+    0x3600000, 0x3380000, 0x3300000, 0x3000000, 0x3480000,
+    0x3580000, 0x6280000, 0x6400000, 0x6080000, 0x6680000,
+    0x6500000, 0x6180000, 0x6200000, 0x6100000, 0x6700000,
+    0x6780000, 0x6600000, 0x6380000, 0x6300000, 0x6000000,
+    0x6480000, 0x6580000, 0x5A80000, 0x5C00000, 0x5880000,
+    0x5E80000, 0x5D00000, 0x5980000, 0x5A00000, 0x5900000,
+    0x5F00000, 0x5F80000, 0x5E00000, 0x5B80000, 0x5B00000,
+    0x5800000, 0x5C80000, 0x5D80000, 0x1280000, 0x1400000,
+    0x1080000, 0x1680000, 0x1500000, 0x1180000, 0x1200000,
+    0x1100000, 0x1700000, 0x1780000, 0x1600000, 0x1380000,
+    0x1300000, 0x1000000, 0x1480000, 0x1580000, 0x2A80000,
+    0x2C00000, 0x2880000, 0x2E80000, 0x2D00000, 0x2980000,
+    0x2A00000, 0x2900000, 0x2F00000, 0x2F80000, 0x2E00000,
+    0x2B80000, 0x2B00000, 0x2800000, 0x2C80000, 0x2D80000,
+    0x1A80000, 0x1C00000, 0x1880000, 0x1E80000, 0x1D00000,
+    0x1980000, 0x1A00000, 0x1900000, 0x1F00000, 0x1F80000,
+    0x1E00000, 0x1B80000, 0x1B00000, 0x1800000, 0x1C80000,
+    0x1D80000
+  }, {
+    0x30000002, 0x60000002, 0x38000002, 0x8000002,
+    0x28000002, 0x78000002, 0x68000002, 0x40000002, 
+    0x20000002, 0x50000002, 0x48000002, 0x70000002, 
+    0x2,        0x18000002, 0x58000002, 0x10000002, 
+    0xB0000005, 0xE0000005, 0xB8000005, 0x88000005,
+    0xA8000005, 0xF8000005, 0xE8000005, 0xC0000005,
+    0xA0000005, 0xD0000005, 0xC8000005, 0xF0000005, 
+    0x80000005, 0x98000005, 0xD8000005, 0x90000005, 
+    0x30000005, 0x60000005, 0x38000005, 0x8000005, 
+    0x28000005, 0x78000005, 0x68000005, 0x40000005,
+    0x20000005, 0x50000005, 0x48000005, 0x70000005, 
+    0x5,        0x18000005, 0x58000005, 0x10000005, 
+    0x30000000, 0x60000000, 0x38000000, 0x8000000, 
+    0x28000000, 0x78000000, 0x68000000, 0x40000000, 
+    0x20000000, 0x50000000, 0x48000000, 0x70000000,
+    0x0,        0x18000000, 0x58000000, 0x10000000, 
+    0xB0000003, 0xE0000003, 0xB8000003, 0x88000003, 
+    0xA8000003, 0xF8000003, 0xE8000003, 0xC0000003, 
+    0xA0000003, 0xD0000003, 0xC8000003, 0xF0000003, 
+    0x80000003, 0x98000003, 0xD8000003, 0x90000003,
+    0x30000001, 0x60000001, 0x38000001, 0x8000001,
+    0x28000001, 0x78000001, 0x68000001, 0x40000001, 
+    0x20000001, 0x50000001, 0x48000001, 0x70000001, 
+    0x1,        0x18000001, 0x58000001, 0x10000001, 
+    0xB0000000, 0xE0000000, 0xB8000000, 0x88000000,
+    0xA8000000, 0xF8000000, 0xE8000000, 0xC0000000,
+    0xA0000000, 0xD0000000, 0xC8000000, 0xF0000000, 
+    0x80000000, 0x98000000, 0xD8000000, 0x90000000, 
+    0xB0000006, 0xE0000006, 0xB8000006, 0x88000006, 
+    0xA8000006, 0xF8000006, 0xE8000006, 0xC0000006,
+    0xA0000006, 0xD0000006, 0xC8000006, 0xF0000006,
+    0x80000006, 0x98000006, 0xD8000006, 0x90000006, 
+    0xB0000001, 0xE0000001, 0xB8000001, 0x88000001, 
+    0xA8000001, 0xF8000001, 0xE8000001, 0xC0000001, 
+    0xA0000001, 0xD0000001, 0xC8000001, 0xF0000001,
+    0x80000001, 0x98000001, 0xD8000001, 0x90000001,
+    0x30000003, 0x60000003, 0x38000003, 0x8000003, 
+    0x28000003, 0x78000003, 0x68000003, 0x40000003, 
+    0x20000003, 0x50000003, 0x48000003, 0x70000003, 
+    0x3,        0x18000003, 0x58000003, 0x10000003,
+    0x30000004, 0x60000004, 0x38000004, 0x8000004,
+    0x28000004, 0x78000004, 0x68000004, 0x40000004, 
+    0x20000004, 0x50000004, 0x48000004, 0x70000004, 
+    0x4,        0x18000004, 0x58000004, 0x10000004, 
+    0xB0000002, 0xE0000002, 0xB8000002, 0x88000002,
+    0xA8000002, 0xF8000002, 0xE8000002, 0xC0000002,
+    0xA0000002, 0xD0000002, 0xC8000002, 0xF0000002, 
+    0x80000002, 0x98000002, 0xD8000002, 0x90000002, 
+    0xB0000004, 0xE0000004, 0xB8000004, 0x88000004, 
+    0xA8000004, 0xF8000004, 0xE8000004, 0xC0000004,
+    0xA0000004, 0xD0000004, 0xC8000004, 0xF0000004,
+    0x80000004, 0x98000004, 0xD8000004, 0x90000004, 
+    0x30000006, 0x60000006, 0x38000006, 0x8000006, 
+    0x28000006, 0x78000006, 0x68000006, 0x40000006, 
+    0x20000006, 0x50000006, 0x48000006, 0x70000006,
+    0x6,        0x18000006, 0x58000006, 0x10000006, 
+    0xB0000007, 0xE0000007, 0xB8000007, 0x88000007, 
+    0xA8000007, 0xF8000007, 0xE8000007, 0xC0000007, 
+    0xA0000007, 0xD0000007, 0xC8000007, 0xF0000007, 
+    0x80000007, 0x98000007, 0xD8000007, 0x90000007,
+    0x30000007, 0x60000007, 0x38000007, 0x8000007,
+    0x28000007, 0x78000007, 0x68000007, 0x40000007, 
+    0x20000007, 0x50000007, 0x48000007, 0x70000007, 
+    0x7,        0x18000007, 0x58000007, 0x10000007
+  }, {
+    0xE8,  0xD8,  0xA0,  0x88,  0x98,  0xF8,  0xA8,  0xC8,  0x80,  0xD0,
+    0xF0,  0xB8,  0xB0,  0xC0,  0x90,  0xE0,  0x7E8, 0x7D8, 0x7A0, 0x788,
+    0x798, 0x7F8, 0x7A8, 0x7C8, 0x780, 0x7D0, 0x7F0, 0x7B8, 0x7B0, 0x7C0,
+    0x790, 0x7E0, 0x6E8, 0x6D8, 0x6A0, 0x688, 0x698, 0x6F8, 0x6A8, 0x6C8,
+    0x680, 0x6D0, 0x6F0, 0x6B8, 0x6B0, 0x6C0, 0x690, 0x6E0, 0x68,  0x58,
+    0x20,  0x8,   0x18,  0x78,  0x28,   0x48,  0x0,   0x50,  0x70,  0x38,
+    0x30,  0x40,  0x10,  0x60,  0x2E8, 0x2D8, 0x2A0, 0x288, 0x298, 0x2F8,
+    0x2A8, 0x2C8, 0x280, 0x2D0, 0x2F0, 0x2B8, 0x2B0, 0x2C0, 0x290, 0x2E0,
+    0x3E8, 0x3D8, 0x3A0, 0x388, 0x398, 0x3F8, 0x3A8, 0x3C8, 0x380, 0x3D0,
+    0x3F0, 0x3B8, 0x3B0, 0x3C0, 0x390, 0x3E0, 0x568, 0x558, 0x520, 0x508,
+    0x518, 0x578, 0x528, 0x548, 0x500, 0x550, 0x570, 0x538, 0x530, 0x540,
+    0x510, 0x560, 0x268, 0x258, 0x220, 0x208, 0x218, 0x278, 0x228, 0x248,
+    0x200, 0x250, 0x270, 0x238, 0x230, 0x240, 0x210, 0x260, 0x4E8, 0x4D8,
+    0x4A0, 0x488, 0x498, 0x4F8, 0x4A8, 0x4C8, 0x480, 0x4D0, 0x4F0, 0x4B8,
+    0x4B0, 0x4C0, 0x490, 0x4E0, 0x168, 0x158, 0x120, 0x108, 0x118, 0x178,
+    0x128, 0x148, 0x100, 0x150, 0x170, 0x138, 0x130, 0x140, 0x110, 0x160,
+    0x1E8, 0x1D8, 0x1A0, 0x188, 0x198, 0x1F8, 0x1A8, 0x1C8, 0x180, 0x1D0,
+    0x1F0, 0x1B8, 0x1B0, 0x1C0, 0x190, 0x1E0, 0x768, 0x758, 0x720, 0x708,
+    0x718, 0x778, 0x728, 0x748, 0x700, 0x750, 0x770, 0x738, 0x730, 0x740,
+    0x710, 0x760, 0x368, 0x358, 0x320, 0x308, 0x318, 0x378, 0x328, 0x348,
+    0x300, 0x350, 0x370, 0x338, 0x330, 0x340, 0x310, 0x360, 0x5E8, 0x5D8,
+    0x5A0, 0x588, 0x598, 0x5F8, 0x5A8, 0x5C8, 0x580, 0x5D0, 0x5F0, 0x5B8,
+    0x5B0, 0x5C0, 0x590, 0x5E0, 0x468, 0x458, 0x420, 0x408, 0x418, 0x478,
+    0x428, 0x448, 0x400, 0x450, 0x470, 0x438, 0x430, 0x440, 0x410, 0x460,
+    0x668, 0x658, 0x620, 0x608, 0x618, 0x678, 0x628, 0x648, 0x600, 0x650,
+    0x670, 0x638, 0x630, 0x640, 0x610, 0x660
+  }
+};
+
+/* pre-initialized GOST lookup tables based on rotated S-Box */
+const uint32_t gost94_sbox_cryptpro[4][256] = {
+  {
+    0x2d000, 0x2a000, 0x2a800, 0x2b000, 0x2c000,
+    0x28800, 0x29800, 0x2b800, 0x2e800, 0x2e000,
+    0x2f000, 0x28000, 0x2c800, 0x29000, 0x2d800,
+    0x2f800, 0x7d000, 0x7a000, 0x7a800, 0x7b000,
+    0x7c000, 0x78800, 0x79800, 0x7b800, 0x7e800,
+    0x7e000, 0x7f000, 0x78000, 0x7c800, 0x79000,
+    0x7d800, 0x7f800, 0x25000, 0x22000, 0x22800,
+    0x23000, 0x24000, 0x20800, 0x21800, 0x23800,
+    0x26800, 0x26000, 0x27000, 0x20000, 0x24800,
+    0x21000, 0x25800, 0x27800, 0x5000,  0x2000,
+    0x2800,  0x3000,  0x4000,  0x800,   0x1800,
+    0x3800,  0x6800,  0x6000,  0x7000,  0x0,
+    0x4800,  0x1000,  0x5800,  0x7800,  0x15000,
+    0x12000, 0x12800, 0x13000, 0x14000, 0x10800,
+    0x11800, 0x13800, 0x16800, 0x16000, 0x17000,
+    0x10000, 0x14800, 0x11000, 0x15800, 0x17800,
+    0x6d000, 0x6a000, 0x6a800, 0x6b000, 0x6c000,
+    0x68800, 0x69800, 0x6b800, 0x6e800, 0x6e000,
+    0x6f000, 0x68000, 0x6c800, 0x69000, 0x6d800,
+    0x6f800, 0x5d000, 0x5a000, 0x5a800, 0x5b000,
+    0x5c000, 0x58800, 0x59800, 0x5b800, 0x5e800,
+    0x5e000, 0x5f000, 0x58000, 0x5c800, 0x59000,
+    0x5d800, 0x5f800, 0x4d000, 0x4a000, 0x4a800,
+    0x4b000, 0x4c000, 0x48800, 0x49800, 0x4b800,
+    0x4e800, 0x4e000, 0x4f000, 0x48000, 0x4c800,
+    0x49000, 0x4d800, 0x4f800, 0xd000,  0xa000,
+    0xa800,  0xb000,  0xc000,  0x8800,  0x9800,
+    0xb800,  0xe800,  0xe000,  0xf000,  0x8000,
+    0xc800,  0x9000,  0xd800,  0xf800,  0x3d000,
+    0x3a000, 0x3a800, 0x3b000, 0x3c000, 0x38800,
+    0x39800, 0x3b800, 0x3e800, 0x3e000, 0x3f000,
+    0x38000, 0x3c800, 0x39000, 0x3d800, 0x3f800,
+    0x35000, 0x32000, 0x32800, 0x33000, 0x34000,
+    0x30800, 0x31800, 0x33800, 0x36800, 0x36000,
+    0x37000, 0x30000, 0x34800, 0x31000, 0x35800,
+    0x37800, 0x1d000, 0x1a000, 0x1a800, 0x1b000,
+    0x1c000, 0x18800, 0x19800, 0x1b800, 0x1e800,
+    0x1e000, 0x1f000, 0x18000, 0x1c800, 0x19000,
+    0x1d800, 0x1f800, 0x65000, 0x62000, 0x62800,
+    0x63000, 0x64000, 0x60800, 0x61800, 0x63800,
+    0x66800, 0x66000, 0x67000, 0x60000, 0x64800,
+    0x61000, 0x65800, 0x67800, 0x75000, 0x72000,
+    0x72800, 0x73000, 0x74000, 0x70800, 0x71800,
+    0x73800, 0x76800, 0x76000, 0x77000, 0x70000,
+    0x74800, 0x71000, 0x75800, 0x77800, 0x55000,
+    0x52000, 0x52800, 0x53000, 0x54000, 0x50800,
+    0x51800, 0x53800, 0x56800, 0x56000, 0x57000,
+    0x50000, 0x54800, 0x51000, 0x55800, 0x57800,
+    0x45000, 0x42000, 0x42800, 0x43000, 0x44000,
+    0x40800, 0x41800, 0x43800, 0x46800, 0x46000,
+    0x47000, 0x40000, 0x44800, 0x41000, 0x45800, 0x47800
+  }, {
+    0x2380000, 0x2780000, 0x2600000, 0x2700000, 0x2480000,
+    0x2200000, 0x2080000, 0x2000000, 0x2180000, 0x2580000,
+    0x2280000, 0x2100000, 0x2300000, 0x2500000, 0x2400000,
+    0x2680000, 0x5380000, 0x5780000, 0x5600000, 0x5700000,
+    0x5480000, 0x5200000, 0x5080000, 0x5000000, 0x5180000,
+    0x5580000, 0x5280000, 0x5100000, 0x5300000, 0x5500000,
+    0x5400000, 0x5680000, 0x3b80000, 0x3f80000, 0x3e00000,
+    0x3f00000, 0x3c80000, 0x3a00000, 0x3880000, 0x3800000,
+    0x3980000, 0x3d80000, 0x3a80000, 0x3900000, 0x3b00000,
+    0x3d00000, 0x3c00000, 0x3e80000, 0x6380000, 0x6780000,
+    0x6600000, 0x6700000, 0x6480000, 0x6200000, 0x6080000,
+    0x6000000, 0x6180000, 0x6580000, 0x6280000, 0x6100000,
+    0x6300000, 0x6500000, 0x6400000, 0x6680000, 0x380000,
+    0x780000,  0x600000,  0x700000,  0x480000,  0x200000,
+    0x80000,   0x0,       0x180000,  0x580000,  0x280000,
+    0x100000,  0x300000,  0x500000,  0x400000,  0x680000,
+    0x7b80000, 0x7f80000, 0x7e00000, 0x7f00000, 0x7c80000,
+    0x7a00000, 0x7880000, 0x7800000, 0x7980000, 0x7d80000,
+    0x7a80000, 0x7900000, 0x7b00000, 0x7d00000, 0x7c00000,
+    0x7e80000, 0x1380000, 0x1780000, 0x1600000, 0x1700000,
+    0x1480000, 0x1200000, 0x1080000, 0x1000000, 0x1180000,
+    0x1580000, 0x1280000, 0x1100000, 0x1300000, 0x1500000,
+    0x1400000, 0x1680000, 0x4380000, 0x4780000, 0x4600000,
+    0x4700000, 0x4480000, 0x4200000, 0x4080000, 0x4000000,
+    0x4180000, 0x4580000, 0x4280000, 0x4100000, 0x4300000,
+    0x4500000, 0x4400000, 0x4680000, 0x7380000, 0x7780000,
+    0x7600000, 0x7700000, 0x7480000, 0x7200000, 0x7080000,
+    0x7000000, 0x7180000, 0x7580000, 0x7280000, 0x7100000,
+    0x7300000, 0x7500000, 0x7400000, 0x7680000, 0xb80000,
+    0xf80000,  0xe00000,  0xf00000,  0xc80000,  0xa00000,
+    0x880000,  0x800000,  0x980000,  0xd80000,  0xa80000,
+    0x900000,  0xb00000,  0xd00000,  0xc00000,  0xe80000,
+    0x3380000, 0x3780000, 0x3600000, 0x3700000, 0x3480000,
+    0x3200000, 0x3080000, 0x3000000, 0x3180000, 0x3580000,
+    0x3280000, 0x3100000, 0x3300000, 0x3500000, 0x3400000,
+    0x3680000, 0x2b80000, 0x2f80000, 0x2e00000, 0x2f00000,
+    0x2c80000, 0x2a00000, 0x2880000, 0x2800000, 0x2980000,
+    0x2d80000, 0x2a80000, 0x2900000, 0x2b00000, 0x2d00000,
+    0x2c00000, 0x2e80000, 0x6b80000, 0x6f80000, 0x6e00000,
+    0x6f00000, 0x6c80000, 0x6a00000, 0x6880000, 0x6800000,
+    0x6980000, 0x6d80000, 0x6a80000, 0x6900000, 0x6b00000,
+    0x6d00000, 0x6c00000, 0x6e80000, 0x5b80000, 0x5f80000,
+    0x5e00000, 0x5f00000, 0x5c80000, 0x5a00000, 0x5880000,
+    0x5800000, 0x5980000, 0x5d80000, 0x5a80000, 0x5900000,
+    0x5b00000, 0x5d00000, 0x5c00000, 0x5e80000, 0x4b80000,
+    0x4f80000, 0x4e00000, 0x4f00000, 0x4c80000, 0x4a00000,
+    0x4880000, 0x4800000, 0x4980000, 0x4d80000, 0x4a80000,
+    0x4900000, 0x4b00000, 0x4d00000, 0x4c00000, 0x4e80000,
+    0x1b80000, 0x1f80000, 0x1e00000, 0x1f00000, 0x1c80000,
+    0x1a00000, 0x1880000, 0x1800000, 0x1980000, 0x1d80000,
+    0x1a80000, 0x1900000, 0x1b00000, 0x1d00000, 0x1c00000,
+    0x1e80000
+  }, {
+    0xb8000003, 0xb0000003, 0xa0000003, 0xd8000003, 0xc8000003,
+    0xe0000003, 0x90000003, 0xd0000003, 0x88000003, 0xc0000003,
+    0x80000003, 0xf0000003, 0xf8000003, 0xe8000003, 0x98000003,
+    0xa8000003, 0x38000003, 0x30000003, 0x20000003, 0x58000003,
+    0x48000003, 0x60000003, 0x10000003, 0x50000003, 0x8000003,
+    0x40000003, 0x3,        0x70000003, 0x78000003, 0x68000003,
+    0x18000003, 0x28000003, 0x38000001, 0x30000001, 0x20000001,
+    0x58000001, 0x48000001, 0x60000001, 0x10000001, 0x50000001,
+    0x8000001,  0x40000001, 0x1,        0x70000001, 0x78000001,
+    0x68000001, 0x18000001, 0x28000001, 0x38000002, 0x30000002,
+    0x20000002, 0x58000002, 0x48000002, 0x60000002, 0x10000002,
+    0x50000002, 0x8000002,  0x40000002, 0x2,        0x70000002,
+    0x78000002, 0x68000002, 0x18000002, 0x28000002, 0xb8000006,
+    0xb0000006, 0xa0000006, 0xd8000006, 0xc8000006, 0xe0000006,
+    0x90000006, 0xd0000006, 0x88000006, 0xc0000006, 0x80000006,
+    0xf0000006, 0xf8000006, 0xe8000006, 0x98000006, 0xa8000006,
+    0xb8000004, 0xb0000004, 0xa0000004, 0xd8000004, 0xc8000004,
+    0xe0000004, 0x90000004, 0xd0000004, 0x88000004, 0xc0000004,
+    0x80000004, 0xf0000004, 0xf8000004, 0xe8000004, 0x98000004,
+    0xa8000004, 0xb8000007, 0xb0000007, 0xa0000007, 0xd8000007,
+    0xc8000007, 0xe0000007, 0x90000007, 0xd0000007, 0x88000007,
+    0xc0000007, 0x80000007, 0xf0000007, 0xf8000007, 0xe8000007,
+    0x98000007, 0xa8000007, 0x38000000, 0x30000000, 0x20000000,
+    0x58000000, 0x48000000, 0x60000000, 0x10000000, 0x50000000,
+    0x8000000,  0x40000000, 0x0,        0x70000000, 0x78000000,
+    0x68000000, 0x18000000, 0x28000000, 0x38000005, 0x30000005,
+    0x20000005, 0x58000005, 0x48000005, 0x60000005, 0x10000005,
+    0x50000005, 0x8000005,  0x40000005, 0x5,        0x70000005,
+    0x78000005, 0x68000005, 0x18000005, 0x28000005, 0xb8000000,
+    0xb0000000, 0xa0000000, 0xd8000000, 0xc8000000, 0xe0000000,
+    0x90000000, 0xd0000000, 0x88000000, 0xc0000000, 0x80000000,
+    0xf0000000, 0xf8000000, 0xe8000000, 0x98000000, 0xa8000000,
+    0xb8000002, 0xb0000002, 0xa0000002, 0xd8000002, 0xc8000002,
+    0xe0000002, 0x90000002, 0xd0000002, 0x88000002, 0xc0000002,
+    0x80000002, 0xf0000002, 0xf8000002, 0xe8000002, 0x98000002,
+    0xa8000002, 0xb8000005, 0xb0000005, 0xa0000005, 0xd8000005,
+    0xc8000005, 0xe0000005, 0x90000005, 0xd0000005, 0x88000005,
+    0xc0000005, 0x80000005, 0xf0000005, 0xf8000005, 0xe8000005,
+    0x98000005, 0xa8000005, 0x38000004, 0x30000004, 0x20000004,
+    0x58000004, 0x48000004, 0x60000004, 0x10000004, 0x50000004,
+    0x8000004,  0x40000004, 0x4,        0x70000004, 0x78000004,
+    0x68000004, 0x18000004, 0x28000004, 0x38000007, 0x30000007,
+    0x20000007, 0x58000007, 0x48000007, 0x60000007, 0x10000007,
+    0x50000007, 0x8000007,  0x40000007, 0x7,        0x70000007,
+    0x78000007, 0x68000007, 0x18000007, 0x28000007, 0x38000006,
+    0x30000006, 0x20000006, 0x58000006, 0x48000006, 0x60000006,
+    0x10000006, 0x50000006, 0x8000006,  0x40000006, 0x6,
+    0x70000006, 0x78000006, 0x68000006, 0x18000006, 0x28000006,
+    0xb8000001, 0xb0000001, 0xa0000001, 0xd8000001, 0xc8000001,
+    0xe0000001, 0x90000001, 0xd0000001, 0x88000001, 0xc0000001,
+    0x80000001, 0xf0000001, 0xf8000001, 0xe8000001, 0x98000001,
+    0xa8000001
+  }, {
+    0xe8,  0xf0,  0xa0,  0x88,  0xb8,  0x80,  0xa8,  0xd0,  0x98,  0xe0,
+    0xc0,  0xf8,  0xb0,  0x90,  0xc8,  0xd8,  0x1e8, 0x1f0, 0x1a0, 0x188,
+    0x1b8, 0x180, 0x1a8, 0x1d0, 0x198, 0x1e0, 0x1c0, 0x1f8, 0x1b0, 0x190,
+    0x1c8, 0x1d8, 0x568, 0x570, 0x520, 0x508, 0x538, 0x500, 0x528, 0x550,
+    0x518, 0x560, 0x540, 0x578, 0x530, 0x510, 0x548, 0x558, 0x4e8, 0x4f0,
+    0x4a0, 0x488, 0x4b8, 0x480, 0x4a8, 0x4d0, 0x498, 0x4e0, 0x4c0, 0x4f8,
+    0x4b0, 0x490, 0x4c8, 0x4d8, 0x2e8, 0x2f0, 0x2a0, 0x288, 0x2b8, 0x280,
+    0x2a8, 0x2d0, 0x298, 0x2e0, 0x2c0, 0x2f8, 0x2b0, 0x290, 0x2c8, 0x2d8,
+    0x5e8, 0x5f0, 0x5a0, 0x588, 0x5b8, 0x580, 0x5a8, 0x5d0, 0x598, 0x5e0,
+    0x5c0, 0x5f8, 0x5b0, 0x590, 0x5c8, 0x5d8, 0x268, 0x270, 0x220, 0x208,
+    0x238, 0x200, 0x228, 0x250, 0x218, 0x260, 0x240, 0x278, 0x230, 0x210,
+    0x248, 0x258, 0x7e8, 0x7f0, 0x7a0, 0x788, 0x7b8, 0x780, 0x7a8, 0x7d0,
+    0x798, 0x7e0, 0x7c0, 0x7f8, 0x7b0, 0x790, 0x7c8, 0x7d8, 0x468, 0x470,
+    0x420, 0x408, 0x438, 0x400, 0x428, 0x450, 0x418, 0x460, 0x440, 0x478,
+    0x430, 0x410, 0x448, 0x458, 0x368, 0x370, 0x320, 0x308, 0x338, 0x300,
+    0x328, 0x350, 0x318, 0x360, 0x340, 0x378, 0x330, 0x310, 0x348, 0x358,
+    0x3e8, 0x3f0, 0x3a0, 0x388, 0x3b8, 0x380, 0x3a8, 0x3d0, 0x398, 0x3e0,
+    0x3c0, 0x3f8, 0x3b0, 0x390, 0x3c8, 0x3d8, 0x768, 0x770, 0x720, 0x708,
+    0x738, 0x700, 0x728, 0x750, 0x718, 0x760, 0x740, 0x778, 0x730, 0x710,
+    0x748, 0x758, 0x6e8, 0x6f0, 0x6a0, 0x688, 0x6b8, 0x680, 0x6a8, 0x6d0,
+    0x698, 0x6e0, 0x6c0, 0x6f8, 0x6b0, 0x690, 0x6c8, 0x6d8, 0x68,  0x70,
+    0x20,  0x8,   0x38,  0x0,   0x28,  0x50,  0x18,  0x60,  0x40,  0x78,
+    0x30,  0x10,  0x48,  0x58,  0x168, 0x170, 0x120, 0x108, 0x138, 0x100,
+    0x128, 0x150, 0x118, 0x160, 0x140, 0x178, 0x130, 0x110, 0x148, 0x158,
+    0x668, 0x670, 0x620, 0x608, 0x638, 0x600, 0x628, 0x650, 0x618, 0x660,
+    0x640, 0x678, 0x630, 0x610, 0x648, 0x658
+  }
+};
+
+
+#endif /* GENERATE_GOST_LOOKUP_TABLE */
diff --git a/gost94.c b/gost94.c
new file mode 100644
index 0000000..9e04c64
--- /dev/null
+++ b/gost94.c
@@ -0,0 +1,387 @@
+/* gost.c - an implementation of GOST Hash Function
+ * based on the Russian Standard GOST R 34.11-94.
+ * See also RFC 4357.
+ *
+ * Implementation written by Alexei Kravchenko.
+ * Ported to nettle by Nikos Mavrogiannopoulos.
+ *
+ * Copyleft:
+ * I hereby release this code into the public domain. This applies worldwide.
+ * I grant any entity the right to use this work for ANY PURPOSE,
+ * without any conditions, unless such conditions are required by law.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "macros.h"
+#include "nettle-write.h"
+#include "gost94.h"
+
+extern uint32_t gost94_sbox[4][256];
+extern uint32_t gost94_sbox_cryptpro[4][256];
+
+/**
+ * Initialize algorithm context before calculating hash
+ * with test parameters set.
+ *
+ * @param ctx context to initalize
+ */
+void
+gost94_init (gost94_ctx * ctx)
+{
+    memset (ctx, 0, sizeof (gost94_ctx));
+    ctx-&gt;sbox = (uint32_t*)gost94_sbox;
+}
+
+void
+gost94_init2 (gost94_ctx * ctx, unsigned int flag)
+{
+    memset (ctx, 0, sizeof (gost94_ctx));
+    ctx-&gt;flag = flag;
+
+    if (ctx-&gt;flag &amp; GOST_FLAG_CRYPTOPRO)
+      ctx-&gt;sbox = (uint32_t*)gost94_sbox_cryptpro;
+    else 
+      ctx-&gt;sbox = (uint32_t*)gost94_sbox;
+}
+
+/*
+ *  A macro that performs a full encryption round of GOST 28147-89.
+ *  Temporary variables tmp assumed and variables r and l for left and right
+ *  blocks.
+ */
+#define GOST_ENCRYPT_ROUND(key1, key2, sbox) \
+  tmp = (key1) + r; \
+  l ^= (sbox)[tmp &amp; 0xff] ^ ((sbox)+256)[(tmp &gt;&gt; 8) &amp; 0xff] ^ \
+    ((sbox)+512)[(tmp &gt;&gt; 16) &amp; 0xff] ^ ((sbox)+768)[tmp &gt;&gt; 24]; \
+  tmp = (key2) + l; \
+  r ^= (sbox)[tmp &amp; 0xff] ^ ((sbox)+256)[(tmp &gt;&gt; 8) &amp; 0xff] ^ \
+    ((sbox)+512)[(tmp &gt;&gt; 16) &amp; 0xff] ^ ((sbox)+768)[tmp &gt;&gt; 24];
+
+/* encrypt a block with the given key */
+#define GOST_ENCRYPT(result, i, key, hash, sbox) \
+  r = hash[i], l = hash[i + 1]; \
+  GOST_ENCRYPT_ROUND(key[0], key[1], sbox) \
+  GOST_ENCRYPT_ROUND(key[2], key[3], sbox) \
+  GOST_ENCRYPT_ROUND(key[4], key[5], sbox) \
+  GOST_ENCRYPT_ROUND(key[6], key[7], sbox) \
+  GOST_ENCRYPT_ROUND(key[0], key[1], sbox) \
+  GOST_ENCRYPT_ROUND(key[2], key[3], sbox) \
+  GOST_ENCRYPT_ROUND(key[4], key[5], sbox) \
+  GOST_ENCRYPT_ROUND(key[6], key[7], sbox) \
+  GOST_ENCRYPT_ROUND(key[0], key[1], sbox) \
+  GOST_ENCRYPT_ROUND(key[2], key[3], sbox) \
+  GOST_ENCRYPT_ROUND(key[4], key[5], sbox) \
+  GOST_ENCRYPT_ROUND(key[6], key[7], sbox) \
+  GOST_ENCRYPT_ROUND(key[7], key[6], sbox) \
+  GOST_ENCRYPT_ROUND(key[5], key[4], sbox) \
+  GOST_ENCRYPT_ROUND(key[3], key[2], sbox) \
+  GOST_ENCRYPT_ROUND(key[1], key[0], sbox) \
+  result[i] = l, result[i + 1] = r;
+
+/**
+ * The core transformation. Process a 512-bit block.
+ *
+ * @param hash intermediate message hash
+ * @param block the message block to process
+ */
+static void
+gost_block_compress (gost94_ctx * ctx, const uint32_t *block)
+{
+    unsigned i;
+    uint32_t key[8], u[8], v[8], w[8], s[8];
+    uint32_t l, r, tmp;
+
+    /* u := hash, v := &lt;256-bit message block&gt; */
+    memcpy (u, ctx-&gt;hash, sizeof (u));
+    memcpy (v, block, sizeof (v));
+
+    /* w := u xor v */
+    w[0] = u[0] ^ v[0], w[1] = u[1] ^ v[1];
+    w[2] = u[2] ^ v[2], w[3] = u[3] ^ v[3];
+    w[4] = u[4] ^ v[4], w[5] = u[5] ^ v[5];
+    w[6] = u[6] ^ v[6], w[7] = u[7] ^ v[7];
+
+    /* calculate keys, encrypt hash and store result to the s[] array */
+    for (i = 0;; i += 2)
+      {
+          /* key generation: key_i := P(w) */
+          key[0] =
+              (w[0] &amp; 0x000000ff) | ((w[2] &amp; 0x000000ff) &lt;&lt; 8) |
+              ((w[4] &amp; 0x000000ff) &lt;&lt; 16) | ((w[6] &amp; 0x000000ff) &lt;&lt; 24);
+          key[1] =
+              ((w[0] &amp; 0x0000ff00) &gt;&gt; 8) | (w[2] &amp; 0x0000ff00) |
+              ((w[4] &amp; 0x0000ff00) &lt;&lt; 8) | ((w[6] &amp; 0x0000ff00) &lt;&lt; 16);
+          key[2] =
+              ((w[0] &amp; 0x00ff0000) &gt;&gt; 16) | ((w[2] &amp; 0x00ff0000) &gt;&gt; 8) |
+              (w[4] &amp; 0x00ff0000) | ((w[6] &amp; 0x00ff0000) &lt;&lt; 8);
+          key[3] =
+              ((w[0] &amp; 0xff000000) &gt;&gt; 24) | ((w[2] &amp; 0xff000000) &gt;&gt; 16) |
+              ((w[4] &amp; 0xff000000) &gt;&gt; 8) | (w[6] &amp; 0xff000000);
+          key[4] =
+              (w[1] &amp; 0x000000ff) | ((w[3] &amp; 0x000000ff) &lt;&lt; 8) |
+              ((w[5] &amp; 0x000000ff) &lt;&lt; 16) | ((w[7] &amp; 0x000000ff) &lt;&lt; 24);
+          key[5] =
+              ((w[1] &amp; 0x0000ff00) &gt;&gt; 8) | (w[3] &amp; 0x0000ff00) |
+              ((w[5] &amp; 0x0000ff00) &lt;&lt; 8) | ((w[7] &amp; 0x0000ff00) &lt;&lt; 16);
+          key[6] =
+              ((w[1] &amp; 0x00ff0000) &gt;&gt; 16) | ((w[3] &amp; 0x00ff0000) &gt;&gt; 8) |
+              (w[5] &amp; 0x00ff0000) | ((w[7] &amp; 0x00ff0000) &lt;&lt; 8);
+          key[7] =
+              ((w[1] &amp; 0xff000000) &gt;&gt; 24) | ((w[3] &amp; 0xff000000) &gt;&gt; 16) |
+              ((w[5] &amp; 0xff000000) &gt;&gt; 8) | (w[7] &amp; 0xff000000);
+
+          /* encryption: s_i := E_{key_i} (h_i) */
+          GOST_ENCRYPT (s, i, key, ctx-&gt;hash, ctx-&gt;sbox);
+
+          if (i == 0)
+            {
+                /* w:= A(u) ^ A^2(v) */
+                w[0] = u[2] ^ v[4], w[1] = u[3] ^ v[5];
+                w[2] = u[4] ^ v[6], w[3] = u[5] ^ v[7];
+                w[4] = u[6] ^ (v[0] ^= v[2]);
+                w[5] = u[7] ^ (v[1] ^= v[3]);
+                w[6] = (u[0] ^= u[2]) ^ (v[2] ^= v[4]);
+                w[7] = (u[1] ^= u[3]) ^ (v[3] ^= v[5]);
+            }
+          else if ((i &amp; 2) != 0)
+            {
+                if (i == 6)
+                    break;
+
+                /* w := A^2(u) xor A^4(v) xor C_3; u := A(u) xor C_3 */
+                /* C_3=0xff00ffff000000ffff0000ff00ffff0000ff00ff00ff00ffff00ff00ff00ff00 */
+                u[2] ^= u[4] ^ 0x000000ff;
+                u[3] ^= u[5] ^ 0xff00ffff;
+                u[4] ^= 0xff00ff00;
+                u[5] ^= 0xff00ff00;
+                u[6] ^= 0x00ff00ff;
+                u[7] ^= 0x00ff00ff;
+                u[0] ^= 0x00ffff00;
+                u[1] ^= 0xff0000ff;
+
+                w[0] = u[4] ^ v[0];
+                w[2] = u[6] ^ v[2];
+                w[4] = u[0] ^ (v[4] ^= v[6]);
+                w[6] = u[2] ^ (v[6] ^= v[0]);
+                w[1] = u[5] ^ v[1];
+                w[3] = u[7] ^ v[3];
+                w[5] = u[1] ^ (v[5] ^= v[7]);
+                w[7] = u[3] ^ (v[7] ^= v[1]);
+            }
+          else
+            {
+                /* i==4 here */
+                /* w:= A( A^2(u) xor C_3 ) xor A^6(v) */
+                w[0] = u[6] ^ v[4], w[1] = u[7] ^ v[5];
+                w[2] = u[0] ^ v[6], w[3] = u[1] ^ v[7];
+                w[4] = u[2] ^ (v[0] ^= v[2]);
+                w[5] = u[3] ^ (v[1] ^= v[3]);
+                w[6] = (u[4] ^= u[6]) ^ (v[2] ^= v[4]);
+                w[7] = (u[5] ^= u[7]) ^ (v[3] ^= v[5]);
+            }
+      }
+
+    /* step hash function: x(block, hash) := psi^61(hash xor psi(block xor psi^12(S))) */
+
+    /* 12 rounds of the LFSR and xor in &lt;message block&gt; */
+    u[0] = block[0] ^ s[6];
+    u[1] = block[1] ^ s[7];
+    u[2] =
+        block[2] ^ (s[0] &lt;&lt; 16) ^ (s[0] &gt;&gt; 16) ^ (s[0] &amp; 0xffff) ^ (s[1] &amp;
+                                                                    0xffff)
+        ^ (s[1] &gt;&gt; 16) ^ (s[2] &lt;&lt; 16) ^ s[6] ^ (s[6] &lt;&lt; 16) ^ (s[7] &amp;
+                                                               0xffff0000)
+        ^ (s[7] &gt;&gt; 16);
+    u[3] =
+        block[3] ^ (s[0] &amp; 0xffff) ^ (s[0] &lt;&lt; 16) ^ (s[1] &amp; 0xffff) ^ (s[1]
+                                                                       &lt;&lt;
+                                                                       16)
+        ^ (s[1] &gt;&gt; 16) ^ (s[2] &lt;&lt; 16) ^ (s[2] &gt;&gt; 16) ^ (s[3] &lt;&lt; 16) ^ s[6]
+        ^ (s[6] &lt;&lt; 16) ^ (s[6] &gt;&gt; 16) ^ (s[7] &amp; 0xffff) ^ (s[7] &lt;&lt; 16) ^
+        (s[7] &gt;&gt; 16);
+    u[4] =
+        block[4] ^ (s[0] &amp; 0xffff0000) ^ (s[0] &lt;&lt; 16) ^ (s[0] &gt;&gt; 16) ^
+        (s[1] &amp; 0xffff0000) ^ (s[1] &gt;&gt; 16) ^ (s[2] &lt;&lt; 16) ^ (s[2] &gt;&gt; 16) ^
+        (s[3] &lt;&lt; 16) ^ (s[3] &gt;&gt; 16) ^ (s[4] &lt;&lt; 16) ^ (s[6] &lt;&lt; 16) ^ (s[6]
+                                                                     &gt;&gt; 16)
+        ^ (s[7] &amp; 0xffff) ^ (s[7] &lt;&lt; 16) ^ (s[7] &gt;&gt; 16);
+    u[5] =
+        block[5] ^ (s[0] &lt;&lt; 16) ^ (s[0] &gt;&gt; 16) ^ (s[0] &amp; 0xffff0000) ^
+        (s[1] &amp; 0xffff) ^ s[2] ^ (s[2] &gt;&gt; 16) ^ (s[3] &lt;&lt; 16) ^ (s[3] &gt;&gt; 16)
+        ^ (s[4] &lt;&lt; 16) ^ (s[4] &gt;&gt; 16) ^ (s[5] &lt;&lt; 16) ^ (s[6] &lt;&lt; 16) ^ (s[6]
+                                                                       &gt;&gt;
+                                                                       16)
+        ^ (s[7] &amp; 0xffff0000) ^ (s[7] &lt;&lt; 16) ^ (s[7] &gt;&gt; 16);
+    u[6] =
+        block[6] ^ s[0] ^ (s[1] &gt;&gt; 16) ^ (s[2] &lt;&lt; 16) ^ s[3] ^ (s[3] &gt;&gt; 16)
+        ^ (s[4] &lt;&lt; 16) ^ (s[4] &gt;&gt; 16) ^ (s[5] &lt;&lt; 16) ^ (s[5] &gt;&gt; 16) ^ s[6]
+        ^ (s[6] &lt;&lt; 16) ^ (s[6] &gt;&gt; 16) ^ (s[7] &lt;&lt; 16);
+    u[7] =
+        block[7] ^ (s[0] &amp; 0xffff0000) ^ (s[0] &lt;&lt; 16) ^ (s[1] &amp; 0xffff) ^
+        (s[1] &lt;&lt; 16) ^ (s[2] &gt;&gt; 16) ^ (s[3] &lt;&lt; 16) ^ s[4] ^ (s[4] &gt;&gt; 16) ^
+        (s[5] &lt;&lt; 16) ^ (s[5] &gt;&gt; 16) ^ (s[6] &gt;&gt; 16) ^ (s[7] &amp; 0xffff) ^
+        (s[7] &lt;&lt; 16) ^ (s[7] &gt;&gt; 16);
+
+    /* 1 round of the LFSR (a mixing transformation) and xor with &lt;hash&gt; */
+    v[0] = ctx-&gt;hash[0] ^ (u[1] &lt;&lt; 16) ^ (u[0] &gt;&gt; 16);
+    v[1] = ctx-&gt;hash[1] ^ (u[2] &lt;&lt; 16) ^ (u[1] &gt;&gt; 16);
+    v[2] = ctx-&gt;hash[2] ^ (u[3] &lt;&lt; 16) ^ (u[2] &gt;&gt; 16);
+    v[3] = ctx-&gt;hash[3] ^ (u[4] &lt;&lt; 16) ^ (u[3] &gt;&gt; 16);
+    v[4] = ctx-&gt;hash[4] ^ (u[5] &lt;&lt; 16) ^ (u[4] &gt;&gt; 16);
+    v[5] = ctx-&gt;hash[5] ^ (u[6] &lt;&lt; 16) ^ (u[5] &gt;&gt; 16);
+    v[6] = ctx-&gt;hash[6] ^ (u[7] &lt;&lt; 16) ^ (u[6] &gt;&gt; 16);
+    v[7] =
+        ctx-&gt;
+        hash[7] ^ (u[0] &amp; 0xffff0000) ^ (u[0] &lt;&lt; 16) ^ (u[1] &amp; 0xffff0000)
+        ^ (u[1] &lt;&lt; 16) ^ (u[6] &lt;&lt; 16) ^ (u[7] &amp; 0xffff0000) ^ (u[7] &gt;&gt; 16);
+
+    /* 61 rounds of LFSR, mixing up hash */
+    ctx-&gt;hash[0] = (v[0] &amp; 0xffff0000) ^ (v[0] &lt;&lt; 16) ^ (v[0] &gt;&gt; 16) ^
+        (v[1] &gt;&gt; 16) ^ (v[1] &amp; 0xffff0000) ^ (v[2] &lt;&lt; 16) ^
+        (v[3] &gt;&gt; 16) ^ (v[4] &lt;&lt; 16) ^ (v[5] &gt;&gt; 16) ^ v[5] ^
+        (v[6] &gt;&gt; 16) ^ (v[7] &lt;&lt; 16) ^ (v[7] &gt;&gt; 16) ^ (v[7] &amp; 0xffff);
+    ctx-&gt;hash[1] = (v[0] &lt;&lt; 16) ^ (v[0] &gt;&gt; 16) ^ (v[0] &amp; 0xffff0000) ^
+        (v[1] &amp; 0xffff) ^ v[2] ^ (v[2] &gt;&gt; 16) ^ (v[3] &lt;&lt; 16) ^
+        (v[4] &gt;&gt; 16) ^ (v[5] &lt;&lt; 16) ^ (v[6] &lt;&lt; 16) ^ v[6] ^
+        (v[7] &amp; 0xffff0000) ^ (v[7] &gt;&gt; 16);
+    ctx-&gt;hash[2] = (v[0] &amp; 0xffff) ^ (v[0] &lt;&lt; 16) ^ (v[1] &lt;&lt; 16) ^
+        (v[1] &gt;&gt; 16) ^ (v[1] &amp; 0xffff0000) ^ (v[2] &lt;&lt; 16) ^ (v[3] &gt;&gt; 16) ^
+        v[3] ^ (v[4] &lt;&lt; 16) ^ (v[5] &gt;&gt; 16) ^ v[6] ^ (v[6] &gt;&gt; 16) ^
+        (v[7] &amp; 0xffff) ^ (v[7] &lt;&lt; 16) ^ (v[7] &gt;&gt; 16);
+    ctx-&gt;hash[3] = (v[0] &lt;&lt; 16) ^ (v[0] &gt;&gt; 16) ^ (v[0] &amp; 0xffff0000) ^
+        (v[1] &amp; 0xffff0000) ^ (v[1] &gt;&gt; 16) ^ (v[2] &lt;&lt; 16) ^
+        (v[2] &gt;&gt; 16) ^ v[2] ^ (v[3] &lt;&lt; 16) ^ (v[4] &gt;&gt; 16) ^ v[4] ^
+        (v[5] &lt;&lt; 16) ^ (v[6] &lt;&lt; 16) ^ (v[7] &amp; 0xffff) ^ (v[7] &gt;&gt; 16);
+    ctx-&gt;hash[4] =
+        (v[0] &gt;&gt; 16) ^ (v[1] &lt;&lt; 16) ^ v[1] ^ (v[2] &gt;&gt; 16) ^ v[2] ^ (v[3] &lt;&lt;
+                                                                    16) ^
+        (v[3] &gt;&gt; 16) ^ v[3] ^ (v[4] &lt;&lt; 16) ^ (v[5] &gt;&gt; 16) ^ v[5] ^ (v[6] &lt;&lt;
+                                                                    16) ^
+        (v[6] &gt;&gt; 16) ^ (v[7] &lt;&lt; 16);
+    ctx-&gt;hash[5] =
+        (v[0] &lt;&lt; 16) ^ (v[0] &amp; 0xffff0000) ^ (v[1] &lt;&lt; 16) ^ (v[1] &gt;&gt; 16) ^
+        (v[1] &amp; 0xffff0000) ^ (v[2] &lt;&lt; 16) ^ v[2] ^ (v[3] &gt;&gt; 16) ^ v[3] ^
+        (v[4] &lt;&lt; 16) ^ (v[4] &gt;&gt; 16) ^ v[4] ^ (v[5] &lt;&lt; 16) ^ (v[6] &lt;&lt; 16) ^
+        (v[6] &gt;&gt; 16) ^ v[6] ^ (v[7] &lt;&lt; 16) ^ (v[7] &gt;&gt; 16) ^ (v[7] &amp;
+                                                             0xffff0000);
+    ctx-&gt;hash[6] =
+        v[0] ^ v[2] ^ (v[2] &gt;&gt; 16) ^ v[3] ^ (v[3] &lt;&lt; 16) ^ v[4] ^ (v[4] &gt;&gt;
+                                                                   16) ^
+        (v[5] &lt;&lt; 16) ^ (v[5] &gt;&gt; 16) ^ v[5] ^ (v[6] &lt;&lt; 16) ^ (v[6] &gt;&gt; 16) ^
+        v[6] ^ (v[7] &lt;&lt; 16) ^ v[7];
+    ctx-&gt;hash[7] =
+        v[0] ^ (v[0] &gt;&gt; 16) ^ (v[1] &lt;&lt; 16) ^ (v[1] &gt;&gt; 16) ^ (v[2] &lt;&lt; 16) ^
+        (v[3] &gt;&gt; 16) ^ v[3] ^ (v[4] &lt;&lt; 16) ^ v[4] ^ (v[5] &gt;&gt; 16) ^ v[5] ^
+        (v[6] &lt;&lt; 16) ^ (v[6] &gt;&gt; 16) ^ (v[7] &lt;&lt; 16) ^ v[7];
+}
+
+/**
+ * This function calculates hash value by 256-bit blocks.
+ * It updates 256-bit check sum as follows:
+ *    *(uint256_t)(ctx-&gt;sum) += *(uint256_t*)block;
+ * and then updates intermediate hash value ctx-&gt;hash 
+ * by calling gost_block_compress().
+ *
+ * @param ctx algorithm context
+ * @param block the 256-bit message block to process
+ */
+static void
+gost_compute_sum_and_hash (gost94_ctx * ctx, const uint8_t *block)
+{
+    uint32_t block_le[8];
+    unsigned i, carry = 0;
+    uint32_t old;
+
+    /* compute the 256-bit sum */
+    for (i = 0; i &lt; 8; i++)
+      {
+          old = ctx-&gt;sum[i];
+          block_le[i] = LE_READ_UINT32(block);
+          ctx-&gt;sum[i] += block_le[i] + carry;
+          carry = (ctx-&gt;sum[i] &lt; old || ctx-&gt;sum[i] &lt; block_le[i] ? 1 : 0);
+          block += 4;
+      }
+
+    /* update message hash */
+    gost_block_compress (ctx, block_le);
+}
+
+/**
+ * Calculate message hash.
+ * Can be called repeatedly with chunks of the message to be hashed.
+ *
+ * @param ctx the algorithm context containing current hashing state
+ * @param msg message chunk
+ * @param size length of the message chunk
+ */
+void
+gost94_update (gost94_ctx * ctx, unsigned length, const uint8_t *msg)
+{
+    unsigned index = (unsigned) ctx-&gt;length &amp; 31;
+    ctx-&gt;length += length;
+
+    /* fill partial block */
+    if (index)
+      {
+          unsigned left = GOST94_DATA_SIZE - index;
+          memcpy (ctx-&gt;message + index, msg, (length &lt; left ? length : left));
+          if (length &lt; left)
+              return;
+
+          /* process partial block */
+          gost_compute_sum_and_hash (ctx, ctx-&gt;message);
+          msg += left;
+          length -= left;
+      }
+    while (length &gt;= GOST94_DATA_SIZE)
+      {
+          gost_compute_sum_and_hash (ctx, msg);
+          msg += GOST94_DATA_SIZE;
+          length -= GOST94_DATA_SIZE;
+      }
+    if (length)
+      {
+          /* save leftovers */
+          memcpy (ctx-&gt;message, msg, length);
+      }
+}
+
+/**
+ * Finish hashing and store message digest into given array.
+ *
+ * @param ctx the algorithm context containing current hashing state
+ * @param result calculated hash in binary form
+ */
+void
+gost94_digest (gost94_ctx * ctx, unsigned length, uint8_t *result)
+{
+    unsigned index = ctx-&gt;length &amp; 31;
+    uint32_t *msg32 = (uint32_t*)ctx-&gt;message;
+
+    assert(length &lt;= GOST94_DIGEST_SIZE);
+
+    /* pad the last block with zeroes and hash it */
+    if (index &gt; 0)
+      {
+          memset (ctx-&gt;message + index, 0, 32 - index);
+          gost_compute_sum_and_hash (ctx, ctx-&gt;message);
+      }
+
+    /* hash the message length and the sum */
+    msg32[0] = (uint32_t) (ctx-&gt;length &lt;&lt; 3);
+    msg32[1] = (uint32_t) (ctx-&gt;length &gt;&gt; 29);
+    memset (msg32 + 2, 0, sizeof (uint32_t) * 6);
+
+    gost_block_compress (ctx, msg32);
+    gost_block_compress (ctx, ctx-&gt;sum);
+
+    /* convert hash state to result bytes */
+    _nettle_write_le32(length, result, ctx-&gt;hash);
+}
+
diff --git a/gost94.h b/gost94.h
new file mode 100644
index 0000000..dfe79ea
--- /dev/null
+++ b/gost94.h
@@ -0,0 +1,55 @@
+/* md5.h
+ *
+ * The GOST R 34.11-94 hash function, described in RFC 5831.
+ */
+
+#ifndef NETTLE_GOST_H_INCLUDED
+#define NETTLE_GOST_H_INCLUDED
+
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define gost94_init nettle_gost94_init
+#define gost94_init2 nettle_gost94_init2
+#define gost94_init_table nettle_gost94_init_table
+#define gost94_update nettle_gost94_update
+#define gost94_digest nettle_gost94_digest
+
+#undef GENERATE_GOST_LOOKUP_TABLE
+
+#define GOST94_DATA_SIZE 32
+#define GOST94_DIGEST_SIZE 32
+
+/* if set it enables the CryptoPro parameter set */
+#define GOST_FLAG_CRYPTOPRO 1
+
+/* algorithm context */
+typedef struct gost94_ctx
+{
+  uint32_t hash[8]; /* algorithm 256-bit state */
+  uint32_t sum[8];  /* sum of processed message blocks */
+  uint8_t message[GOST94_DATA_SIZE]; /* 256-bit buffer for leftovers */
+  uint64_t length;  /* number of processed bytes */
+  uint32_t *sbox;
+  unsigned flag; /* flag, type of sbox to use */
+} gost94_ctx;
+
+/* hash functions */
+
+void gost94_init(gost94_ctx *ctx);
+void gost94_init2(gost94_ctx *ctx, unsigned int flag);
+void gost94_update(gost94_ctx *ctx, unsigned length, const uint8_t* msg);
+void gost94_digest(gost94_ctx *ctx, unsigned length, uint8_t* result);
+
+#ifdef GENERATE_GOST_LOOKUP_TABLE
+void gost94_init_table(void); /* initialize algorithm static data */
+#endif
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif /* __cplusplus */
+
+#endif /* NETTLE_GOST_H_INCLUDED */
diff --git a/nettle-meta.h b/nettle-meta.h
index c67d29a..325ba39 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -158,6 +158,7 @@ extern const struct nettle_hash * const nettle_hashes[];
 extern const struct nettle_hash nettle_md2;
 extern const struct nettle_hash nettle_md4;
 extern const struct nettle_hash nettle_md5;
+extern const struct nettle_hash nettle_gost94;
 extern const struct nettle_hash nettle_ripemd160;
 extern const struct nettle_hash nettle_sha1;
 extern const struct nettle_hash nettle_sha224;
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 5559886..bb9a06f 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -16,7 +16,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    camellia-test.c \
 		    des-test.c des3-test.c des-compat-test.c \
 		    md2-test.c md4-test.c md5-test.c md5-compat-test.c \
-		    memxor-test.c \
+		    memxor-test.c gost94-test.c \
 		    ripemd160-test.c \
 		    salsa20-test.c \
 		    sha1-test.c sha224-test.c sha256-test.c \
diff --git a/testsuite/gost94-test.c b/testsuite/gost94-test.c
new file mode 100644
index 0000000..502c767
--- /dev/null
+++ b/testsuite/gost94-test.c
@@ -0,0 +1,21 @@
+#include "testutils.h"
+#include "gost94.h"
+
+/* Using test vectors from Wikipedia article on GOST */
+
+void
+test_main(void)
+{
+  test_hash(&amp;nettle_gost94, SDATA("The quick brown fox jumps over the lazy dog"),
+	    SHEX("77b7fa410c9ac58a25f49bca7d0468c9296529315eaca76bd1a10f376d1f4294"));
+
+  test_hash(&amp;nettle_gost94, SDATA("message digest"),
+	    SHEX("ad4434ecb18f2c99b60cbe59ec3d2469582b65273f48de72db2fde16a4889a4d"));
+
+ test_hash(&amp;nettle_gost94, SDATA("a"),
+	    SHEX("d42c539e367c66e9c88a801f6649349c21871b4344c6a573f849fdce62f314dd"));
+
+ test_hash(&amp;nettle_gost94, SDATA(""),
+	    SHEX("ce85b99cc46752fffee35cab9a7b0278abb4c2d2055cff685af4912c49490f8d"));
+}
+
-- 
1.7.10.4


["0002-Do-not-just-abort-but-print-the-expected-and-retriev.patch" (text/x-patch)]

&gt;From 5975af491c4adb8579eb35e109c12965feb4a6cd Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Tue, 25 Sep 2012 19:57:51 +0200
Subject: [PATCH 2/2] Do not just abort but print the expected and retrieved
 values in hash tests.

---
 testsuite/testutils.c |    9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/testsuite/testutils.c b/testsuite/testutils.c
index de9baa4..78cd0d4 100644
--- a/testsuite/testutils.c
+++ b/testsuite/testutils.c
@@ -498,7 +498,14 @@ test_hash(const struct nettle_hash *hash,
   hash-&gt;update(ctx, msg-&gt;length, msg-&gt;data);
   hash-&gt;digest(ctx, hash-&gt;digest_size, buffer);
 
-  ASSERT(MEMEQ(hash-&gt;digest_size, digest-&gt;data, buffer));
+  if (MEMEQ(hash-&gt;digest_size, digest-&gt;data, buffer) == 0)
+    {
+      fprintf(stdout, "\nGot:\n");
+      print_hex(hash-&gt;digest_size, buffer);
+      fprintf(stdout, "\nExpected:\n");
+      print_hex(hash-&gt;digest_size, digest-&gt;data);
+      abort();
+    }
 
   memset(buffer, 0, hash-&gt;digest_size);
 
-- 
1.7.10.4



</body></email><email><emailId>20121203225246</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-12-03 22:52:46-0400</timestampReceived><subject>sha3 optimization</subject><body>

I've spent the evening on optimizing sha3. I've written a first basic
x86_64 implementation of sha3_permute, using 128-bit sse2 operations
where practical, which gave a 30% speedup. And after working with the
algorithm for a bit, I realized that it's fairly easy to reduce the
number of passes each round makes over the data. So I tried that in the
C implementation, and it gave a 20% speedup there.

So now when I understand the algorithm better, I guess I'll have to
rewrite the x86_64 implementation to reduce the number of passes there
too.

Still pretty slow, with sha3-256 at 32 cycles per byte at best. Which is
far behind the claimed performance of 6-7 cycles/byte on x86_64 (close
to the performance of sha1). I guess I should also have a look at that
code (or does aybody on the list know which tricks are relevant?).

The internal state is a 5x5 matrix of 64-bit words. If represented using
128-bit xmm registers, each row fits in two xmm registers and one
regular 64-bit register. The steps which seem hardest to fit with
128-bit instructions is the permutation and rotation steps, which appear
to want to treat 64-bit words individually.

The current code (both C and assembly) keeps the state in memory, using
double buffering, and doesn't try to fit more than one row at a time in
registers. Keeping more of the state in registers is highly desirable.

See http://git.lysator.liu.se/nettle/nettle/blobs/master/sha3-permute.c
and
http://git.lysator.liu.se/nettle/nettle/blobs/master/x86_64/sha3-permute.asm

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120430071058</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-04-30 07:10:58-0400</timestampReceived><subject>Release plans</subject><body>

I've updated the todo page
http://www.lysator.liu.se/~nisse/nettle/plan.html
(also as misc/plan.html in the git repo).

Any missing items?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20121213093109</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-12-13 09:31:09-0400</timestampReceived><subject>Re: sha3 optimization</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; So now when I understand the algorithm better, I guess I'll have to
&gt; rewrite the x86_64 implementation to reduce the number of passes there
&gt; too.

I've rewritten it now. Gives only a slight speedup over the C code,
andruns at roughly 16.5 cycles per byte, compared to 8 for sha1, 18 for
sha256, and 12 for sha512. There surely are microptimizations left to do
with all the juggling around of halves of xmm registers, but I doubt one
can get down below 10 cycles with the current organization of the code.

&gt; The steps which seem hardest to fit with
&gt; 128-bit instructions is the permutation and rotation steps, which appear
&gt; to want to treat 64-bit words individually.

For rotations, the problem is that we need to rotate the two halves of
an xmm register with different rotation counts. And then there are no
rotate instructions, only shifts. So to rotate the two halves of %xmm0
by one and two bits (and not even trying to combine them back into the
same register), one needs to do something like

  movdqa	%xmm0, %xmm1
  movdqa	%xmm0, %xmm2
  movdqa	%xmm0, %xmm3
  psllq		$1, %xmm0
  psrlq		$63, %xmm1
  psllq		$2, %xmm2
  psrlq		$62, %xmm3
  por		%xmm1, %xmm0
  por		%xmm3, %xmm2

which is an awful lot of instructions. Is there any simpler way to do
it?

And the permutations are also quite cumbersome with 128-bit registers,
using puncklqdq and punckhqdq to move 64-bit quantities between
registers, and pshufd for moving data around within a register.

Maybe it would be better to copy data back and forth to 64-bit
registers, but I seem to vaguely recall that moves between regular
registers and xmm registers being slow, is that so? Copy + rotate + copy
would be

  movq		%xmm0, %rax
  psrldq	$1, %xmm0
  rotq		$1, %rax
  movq		%xmm0, %rdx
  rotq		$2, %rdx
  movq		%rax, %xmm0
  movq		%rdx, %xmm1
  puncklqdq	%xmm1, %xmm0
  
for the same two rotations. One instruction less, but then the
permutation can be done for free if applied before copying the data back
to xmm registers. Is there some more efficient way to copy data back and
forth between one xmm register and a pair of regular 64-bit registers?

One non-obvious trick in the current code which I believe is useful is
to also transpose the matrix while permuting it. There are two benefits:

+ The resulting permutation (sha3 "pi" step + transpose) has several
  short cycles rather than a single long cycle, so it can be done
  in-place with fewer temporaries.

+ The next step, the nonlinear "chi" bit fiddling, gets the data in
  suitable form for SIMD operation, since it operates independently on
  each matrix row.

And one obvious drawback:

- The matrix has to be transposed again at the end of the iteration.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120926190357</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-09-26 19:03:57-0400</timestampReceived><subject>gost hash</subject><body>

[this is a resend, sorry if you received it multiple times]

Hello,
 The attached patch adds the GOST R 34.11-94 hash algorithm. I based
this code on Alexei Kravchenko's code from librhash. The original code
[0] had inline assembly for x86 and x86-64 which is removed from this
version.

Although this is not a modern algorithm it is being used in the russian
digital signature standard (GOST R 34.11-2001).

I had issue making the test gost94-test compile. For some reason the
makefile wouldn't link it against gmp (all the other tests were ok), and
couldn't figure out why.

regards,
Nikos

[0].
http://hg.splayer.org/splayer/src/5027d6aa04f1/Thirdparty/librhash/librhash/



["0001-Added-GOST-R-34.11-94-hash-algorithm.patch" (text/x-patch)]

&gt;From 9446c0814abc6d3966320a1a384ffbe05dee0c30 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Tue, 25 Sep 2012 19:57:13 +0200
Subject: [PATCH 1/2] Added GOST R 34.11-94 hash algorithm.

---
 Makefile.in             |    4 +-
 gost94-meta.c           |   32 +++
 gost94-tables.c         |  494 +++++++++++++++++++++++++++++++++++++++++++++++
 gost94.c                |  387 +++++++++++++++++++++++++++++++++++++
 gost94.h                |   55 ++++++
 nettle-meta.h           |    1 +
 testsuite/Makefile.in   |    2 +-
 testsuite/gost94-test.c |   21 ++
 8 files changed, 994 insertions(+), 2 deletions(-)
 create mode 100644 gost94-meta.c
 create mode 100644 gost94-tables.c
 create mode 100644 gost94.c
 create mode 100644 gost94.h
 create mode 100644 testsuite/gost94-test.c

diff --git a/Makefile.in b/Makefile.in
index c0ca3ad..ad0db42 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -64,7 +64,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 aes-encrypt-internal.c aes-encrypt.c aes-encrypt-table.c \
 		 aes-set-encrypt-key.c aes-set-decrypt-key.c aes-meta.c \
 		 arcfour.c arcfour-crypt.c arcfour-meta.c \
-		 arctwo.c arctwo-meta.c \
+		 arctwo.c arctwo-meta.c gost94-meta.c \
 		 base16-encode.c base16-decode.c base16-meta.c \
                  base64-encode.c base64-decode.c base64-meta.c \
 		 camellia-crypt.c camellia-crypt-internal.c \
@@ -81,6 +81,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 knuth-lfib.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
+		 gost94.c gost94-tables.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
 		 salsa20-core-internal.c \
 		 salsa20-crypt.c salsa20-set-key.c \
@@ -129,6 +130,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h bignum.h blowfish.h \
 	  knuth-lfib.h \
 	  macros.h \
 	  md2.h md4.h \
+	  gost94.h \
 	  md5.h md5-compat.h \
 	  memxor.h \
 	  nettle-meta.h nettle-types.h \
diff --git a/gost94-meta.c b/gost94-meta.c
new file mode 100644
index 0000000..46d0c45
--- /dev/null
+++ b/gost94-meta.c
@@ -0,0 +1,32 @@
+/* gost3411-94-meta.c */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2002 Niels Möller
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "gost94.h"
+
+const struct nettle_hash nettle_gost94
+= _NETTLE_HASH(gost94, GOST94);
diff --git a/gost94-tables.c b/gost94-tables.c
new file mode 100644
index 0000000..e68467f
--- /dev/null
+++ b/gost94-tables.c
@@ -0,0 +1,494 @@
+/* gost.c - an implementation of GOST Hash Function
+ * based on the Russian Standard GOST R 34.11-94.
+ * See also RFC 4357.
+ *
+ * Implementation written by Alexei Kravchenko.
+ * Ported to nettle by Nikos Mavrogiannopoulos.
+ *
+ * Copyleft:
+ * I hereby release this code into the public domain. This applies worldwide.
+ * I grant any entity the right to use this work for ANY PURPOSE,
+ * without any conditions, unless such conditions are required by law.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include &lt;string.h&gt;
+
+#include "macros.h"
+#include "gost94.h"
+
+#ifdef GENERATE_GOST_LOOKUP_TABLE
+uint32_t gost94_sbox[4][256];
+uint32_t gost94_sbox_cryptpro[4][256];
+
+/**
+ * Calculate a lookup table from S-Boxes.
+ * A substitution table is used to speed up hash calculation.
+ *
+ * @param out pointer to the lookup table to fill
+ * @param src pointer to eight S-Boxes to fill the table from
+ */
+static void
+fill_gost94_sbox (uint32_t out[4][256], const uint8_t src[8][16])
+{
+    int a, b, i;
+    unsigned long ax, bx, cx, dx;
+
+    for (i = 0, a = 0; a &lt; 16; a++)
+      {
+          ax = (unsigned) src[1][a] &lt;&lt; 15;
+          bx = (unsigned) src[3][a] &lt;&lt; 23;
+          cx = ROTL32 ((unsigned) src[5][a], 31);
+          dx = (unsigned) src[7][a] &lt;&lt; 7;
+
+          for (b = 0; b &lt; 16; b++, i++)
+            {
+                out[0][i] = ax | ((unsigned) src[0][b] &lt;&lt; 11);
+                out[1][i] = bx | ((unsigned) src[2][b] &lt;&lt; 19);
+                out[2][i] = cx | ((unsigned) src[4][b] &lt;&lt; 27);
+                out[3][i] = dx | ((unsigned) src[6][b] &lt;&lt; 3);
+            }
+      }
+}
+
+/**
+ * Initialize the GOST lookup tables for both parameters sets.
+ * Two lookup tables contain 8 KiB in total, so calculating
+ * them at rine-time can save a little space in the exutable file
+ * in trade of consuming some time at pogram start.
+ */
+void
+gost94_init_table (void)
+{
+    /* Test parameters set. Eight 4-bit S-Boxes defined by GOST R 34.10-94
+     * standart for testing the hash function. 
+     * Also given by RFC 4357 section 11.2 */
+    static const uint8_t sbox[8][16] = {
+        {4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3},
+        {14, 11, 4, 12, 6, 13, 15, 10, 2, 3, 8, 1, 0, 7, 5, 9},
+        {5, 8, 1, 13, 10, 3, 4, 2, 14, 15, 12, 7, 6, 0, 9, 11},
+        {7, 13, 10, 1, 0, 8, 9, 15, 14, 4, 6, 12, 11, 2, 5, 3},
+        {6, 12, 7, 1, 5, 15, 13, 8, 4, 10, 9, 14, 0, 3, 11, 2},
+        {4, 11, 10, 0, 7, 2, 1, 13, 3, 6, 8, 5, 9, 12, 15, 14},
+        {13, 11, 4, 1, 3, 15, 5, 9, 0, 10, 14, 7, 6, 8, 2, 12},
+        {1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12}
+    };
+
+    /* Parameter set recommended by RFC 4357.
+     * Eight 4-bit S-Boxes as defined by RFC 4357 section 11.2 */
+    static const uint8_t sbox_cryptpro[8][16] = {
+        {10, 4, 5, 6, 8, 1, 3, 7, 13, 12, 14, 0, 9, 2, 11, 15},
+        {5, 15, 4, 0, 2, 13, 11, 9, 1, 7, 6, 3, 12, 14, 10, 8},
+        {7, 15, 12, 14, 9, 4, 1, 0, 3, 11, 5, 2, 6, 10, 8, 13},
+        {4, 10, 7, 12, 0, 15, 2, 8, 14, 1, 6, 5, 13, 11, 9, 3},
+        {7, 6, 4, 11, 9, 12, 2, 10, 1, 8, 0, 14, 15, 13, 3, 5},
+        {7, 6, 2, 4, 13, 9, 15, 0, 10, 1, 5, 11, 8, 14, 12, 3},
+        {13, 14, 4, 1, 7, 0, 5, 10, 3, 12, 8, 15, 6, 2, 9, 11},
+        {1, 3, 10, 9, 5, 11, 4, 15, 8, 6, 7, 14, 13, 0, 2, 12}
+    };
+
+    fill_gost94_sbox (gost94_sbox, sbox);
+    fill_gost94_sbox (gost94_sbox_cryptpro, sbox_cryptpro);
+}
+
+#else /* GENERATE_GOST_LOOKUP_TABLE */
+
+/* pre-initialized GOST lookup tables based on rotated S-Box */
+/* pre-initialized GOST lookup tables based on rotated S-Box */
+const uint32_t gost94_sbox[4][256] = {
+  {
+    0x72000, 0x75000, 0x74800, 0x71000, 0x76800,
+    0x74000, 0x70000, 0x77000, 0x73000, 0x75800,
+    0x70800, 0x76000, 0x73800, 0x77800, 0x72800,
+    0x71800, 0x5A000, 0x5D000, 0x5C800, 0x59000,
+    0x5E800, 0x5C000, 0x58000, 0x5F000, 0x5B000,
+    0x5D800, 0x58800, 0x5E000, 0x5B800, 0x5F800,
+    0x5A800, 0x59800, 0x22000, 0x25000, 0x24800,
+    0x21000, 0x26800, 0x24000, 0x20000, 0x27000,
+    0x23000, 0x25800, 0x20800, 0x26000, 0x23800,
+    0x27800, 0x22800, 0x21800, 0x62000, 0x65000,
+    0x64800, 0x61000, 0x66800, 0x64000, 0x60000,
+    0x67000, 0x63000, 0x65800, 0x60800, 0x66000,
+    0x63800, 0x67800, 0x62800, 0x61800, 0x32000,
+    0x35000, 0x34800, 0x31000, 0x36800, 0x34000,
+    0x30000, 0x37000, 0x33000, 0x35800, 0x30800,
+    0x36000, 0x33800, 0x37800, 0x32800, 0x31800,
+    0x6A000, 0x6D000, 0x6C800, 0x69000, 0x6E800,
+    0x6C000, 0x68000, 0x6F000, 0x6B000, 0x6D800,
+    0x68800, 0x6E000, 0x6B800, 0x6F800, 0x6A800,
+    0x69800, 0x7A000, 0x7D000, 0x7C800, 0x79000,
+    0x7E800, 0x7C000, 0x78000, 0x7F000, 0x7B000,
+    0x7D800, 0x78800, 0x7E000, 0x7B800, 0x7F800,
+    0x7A800, 0x79800, 0x52000, 0x55000, 0x54800,
+    0x51000, 0x56800, 0x54000, 0x50000, 0x57000,
+    0x53000, 0x55800, 0x50800, 0x56000, 0x53800,
+    0x57800, 0x52800, 0x51800, 0x12000, 0x15000,
+    0x14800, 0x11000, 0x16800, 0x14000, 0x10000,
+    0x17000, 0x13000, 0x15800, 0x10800, 0x16000,
+    0x13800, 0x17800, 0x12800, 0x11800, 0x1A000,
+    0x1D000, 0x1C800, 0x19000, 0x1E800, 0x1C000,
+    0x18000, 0x1F000, 0x1B000, 0x1D800, 0x18800,
+    0x1E000, 0x1B800, 0x1F800, 0x1A800, 0x19800,
+    0x42000, 0x45000, 0x44800, 0x41000, 0x46800,
+    0x44000, 0x40000, 0x47000, 0x43000, 0x45800,
+    0x40800, 0x46000, 0x43800, 0x47800, 0x42800,
+    0x41800, 0xA000,  0xD000,  0xC800,  0x9000,
+    0xE800,  0xC000,  0x8000,  0xF000,  0xB000,
+    0xD800,  0x8800,  0xE000,  0xB800,  0xF800,
+    0xA800,  0x9800,  0x2000,  0x5000,  0x4800,
+    0x1000,  0x6800,  0x4000,  0x0,     0x7000,
+    0x3000,  0x5800,  0x800,   0x6000,  0x3800,
+    0x7800,  0x2800,  0x1800,  0x3A000, 0x3D000,
+    0x3C800, 0x39000, 0x3E800, 0x3C000, 0x38000,
+    0x3F000, 0x3B000, 0x3D800, 0x38800, 0x3E000,
+    0x3B800, 0x3F800, 0x3A800, 0x39800, 0x2A000,
+    0x2D000, 0x2C800, 0x29000, 0x2E800, 0x2C000,
+    0x28000, 0x2F000, 0x2B000, 0x2D800, 0x28800,
+    0x2E000, 0x2B800, 0x2F800, 0x2A800, 0x29800,
+    0x4A000, 0x4D000, 0x4C800, 0x49000, 0x4E800,
+    0x4C000, 0x48000, 0x4F000, 0x4B000, 0x4D800,
+    0x48800, 0x4E000, 0x4B800, 0x4F800, 0x4A800,
+    0x49800
+  }, {
+    0x3A80000, 0x3C00000, 0x3880000, 0x3E80000, 0x3D00000,
+    0x3980000, 0x3A00000, 0x3900000, 0x3F00000, 0x3F80000,
+    0x3E00000, 0x3B80000, 0x3B00000, 0x3800000, 0x3C80000,
+    0x3D80000, 0x6A80000, 0x6C00000, 0x6880000, 0x6E80000,
+    0x6D00000, 0x6980000, 0x6A00000, 0x6900000, 0x6F00000,
+    0x6F80000, 0x6E00000, 0x6B80000, 0x6B00000, 0x6800000,
+    0x6C80000, 0x6D80000, 0x5280000, 0x5400000, 0x5080000,
+    0x5680000, 0x5500000, 0x5180000, 0x5200000, 0x5100000,
+    0x5700000, 0x5780000, 0x5600000, 0x5380000, 0x5300000,
+    0x5000000, 0x5480000, 0x5580000, 0xA80000,  0xC00000,
+    0x880000,  0xE80000,  0xD00000,  0x980000,  0xA00000,
+    0x900000,  0xF00000,  0xF80000,  0xE00000,  0xB80000,
+    0xB00000,  0x800000,  0xC80000,  0xD80000,  0x280000,
+    0x400000,  0x80000,   0x680000,  0x500000,  0x180000,
+    0x200000,  0x100000,  0x700000,  0x780000,  0x600000,
+    0x380000,  0x300000,  0x0,       0x480000,  0x580000,
+    0x4280000, 0x4400000, 0x4080000, 0x4680000, 0x4500000,
+    0x4180000, 0x4200000, 0x4100000, 0x4700000, 0x4780000,
+    0x4600000, 0x4380000, 0x4300000, 0x4000000, 0x4480000,
+    0x4580000, 0x4A80000, 0x4C00000, 0x4880000, 0x4E80000,
+    0x4D00000, 0x4980000, 0x4A00000, 0x4900000, 0x4F00000,
+    0x4F80000, 0x4E00000, 0x4B80000, 0x4B00000, 0x4800000,
+    0x4C80000, 0x4D80000, 0x7A80000, 0x7C00000, 0x7880000,
+    0x7E80000, 0x7D00000, 0x7980000, 0x7A00000, 0x7900000,
+    0x7F00000, 0x7F80000, 0x7E00000, 0x7B80000, 0x7B00000,
+    0x7800000, 0x7C80000, 0x7D80000, 0x7280000, 0x7400000,
+    0x7080000, 0x7680000, 0x7500000, 0x7180000, 0x7200000,
+    0x7100000, 0x7700000, 0x7780000, 0x7600000, 0x7380000,
+    0x7300000, 0x7000000, 0x7480000, 0x7580000, 0x2280000,
+    0x2400000, 0x2080000, 0x2680000, 0x2500000, 0x2180000,
+    0x2200000, 0x2100000, 0x2700000, 0x2780000, 0x2600000,
+    0x2380000, 0x2300000, 0x2000000, 0x2480000, 0x2580000,
+    0x3280000, 0x3400000, 0x3080000, 0x3680000, 0x3500000,
+    0x3180000, 0x3200000, 0x3100000, 0x3700000, 0x3780000,
+    0x3600000, 0x3380000, 0x3300000, 0x3000000, 0x3480000,
+    0x3580000, 0x6280000, 0x6400000, 0x6080000, 0x6680000,
+    0x6500000, 0x6180000, 0x6200000, 0x6100000, 0x6700000,
+    0x6780000, 0x6600000, 0x6380000, 0x6300000, 0x6000000,
+    0x6480000, 0x6580000, 0x5A80000, 0x5C00000, 0x5880000,
+    0x5E80000, 0x5D00000, 0x5980000, 0x5A00000, 0x5900000,
+    0x5F00000, 0x5F80000, 0x5E00000, 0x5B80000, 0x5B00000,
+    0x5800000, 0x5C80000, 0x5D80000, 0x1280000, 0x1400000,
+    0x1080000, 0x1680000, 0x1500000, 0x1180000, 0x1200000,
+    0x1100000, 0x1700000, 0x1780000, 0x1600000, 0x1380000,
+    0x1300000, 0x1000000, 0x1480000, 0x1580000, 0x2A80000,
+    0x2C00000, 0x2880000, 0x2E80000, 0x2D00000, 0x2980000,
+    0x2A00000, 0x2900000, 0x2F00000, 0x2F80000, 0x2E00000,
+    0x2B80000, 0x2B00000, 0x2800000, 0x2C80000, 0x2D80000,
+    0x1A80000, 0x1C00000, 0x1880000, 0x1E80000, 0x1D00000,
+    0x1980000, 0x1A00000, 0x1900000, 0x1F00000, 0x1F80000,
+    0x1E00000, 0x1B80000, 0x1B00000, 0x1800000, 0x1C80000,
+    0x1D80000
+  }, {
+    0x30000002, 0x60000002, 0x38000002, 0x8000002,
+    0x28000002, 0x78000002, 0x68000002, 0x40000002, 
+    0x20000002, 0x50000002, 0x48000002, 0x70000002, 
+    0x2,        0x18000002, 0x58000002, 0x10000002, 
+    0xB0000005, 0xE0000005, 0xB8000005, 0x88000005,
+    0xA8000005, 0xF8000005, 0xE8000005, 0xC0000005,
+    0xA0000005, 0xD0000005, 0xC8000005, 0xF0000005, 
+    0x80000005, 0x98000005, 0xD8000005, 0x90000005, 
+    0x30000005, 0x60000005, 0x38000005, 0x8000005, 
+    0x28000005, 0x78000005, 0x68000005, 0x40000005,
+    0x20000005, 0x50000005, 0x48000005, 0x70000005, 
+    0x5,        0x18000005, 0x58000005, 0x10000005, 
+    0x30000000, 0x60000000, 0x38000000, 0x8000000, 
+    0x28000000, 0x78000000, 0x68000000, 0x40000000, 
+    0x20000000, 0x50000000, 0x48000000, 0x70000000,
+    0x0,        0x18000000, 0x58000000, 0x10000000, 
+    0xB0000003, 0xE0000003, 0xB8000003, 0x88000003, 
+    0xA8000003, 0xF8000003, 0xE8000003, 0xC0000003, 
+    0xA0000003, 0xD0000003, 0xC8000003, 0xF0000003, 
+    0x80000003, 0x98000003, 0xD8000003, 0x90000003,
+    0x30000001, 0x60000001, 0x38000001, 0x8000001,
+    0x28000001, 0x78000001, 0x68000001, 0x40000001, 
+    0x20000001, 0x50000001, 0x48000001, 0x70000001, 
+    0x1,        0x18000001, 0x58000001, 0x10000001, 
+    0xB0000000, 0xE0000000, 0xB8000000, 0x88000000,
+    0xA8000000, 0xF8000000, 0xE8000000, 0xC0000000,
+    0xA0000000, 0xD0000000, 0xC8000000, 0xF0000000, 
+    0x80000000, 0x98000000, 0xD8000000, 0x90000000, 
+    0xB0000006, 0xE0000006, 0xB8000006, 0x88000006, 
+    0xA8000006, 0xF8000006, 0xE8000006, 0xC0000006,
+    0xA0000006, 0xD0000006, 0xC8000006, 0xF0000006,
+    0x80000006, 0x98000006, 0xD8000006, 0x90000006, 
+    0xB0000001, 0xE0000001, 0xB8000001, 0x88000001, 
+    0xA8000001, 0xF8000001, 0xE8000001, 0xC0000001, 
+    0xA0000001, 0xD0000001, 0xC8000001, 0xF0000001,
+    0x80000001, 0x98000001, 0xD8000001, 0x90000001,
+    0x30000003, 0x60000003, 0x38000003, 0x8000003, 
+    0x28000003, 0x78000003, 0x68000003, 0x40000003, 
+    0x20000003, 0x50000003, 0x48000003, 0x70000003, 
+    0x3,        0x18000003, 0x58000003, 0x10000003,
+    0x30000004, 0x60000004, 0x38000004, 0x8000004,
+    0x28000004, 0x78000004, 0x68000004, 0x40000004, 
+    0x20000004, 0x50000004, 0x48000004, 0x70000004, 
+    0x4,        0x18000004, 0x58000004, 0x10000004, 
+    0xB0000002, 0xE0000002, 0xB8000002, 0x88000002,
+    0xA8000002, 0xF8000002, 0xE8000002, 0xC0000002,
+    0xA0000002, 0xD0000002, 0xC8000002, 0xF0000002, 
+    0x80000002, 0x98000002, 0xD8000002, 0x90000002, 
+    0xB0000004, 0xE0000004, 0xB8000004, 0x88000004, 
+    0xA8000004, 0xF8000004, 0xE8000004, 0xC0000004,
+    0xA0000004, 0xD0000004, 0xC8000004, 0xF0000004,
+    0x80000004, 0x98000004, 0xD8000004, 0x90000004, 
+    0x30000006, 0x60000006, 0x38000006, 0x8000006, 
+    0x28000006, 0x78000006, 0x68000006, 0x40000006, 
+    0x20000006, 0x50000006, 0x48000006, 0x70000006,
+    0x6,        0x18000006, 0x58000006, 0x10000006, 
+    0xB0000007, 0xE0000007, 0xB8000007, 0x88000007, 
+    0xA8000007, 0xF8000007, 0xE8000007, 0xC0000007, 
+    0xA0000007, 0xD0000007, 0xC8000007, 0xF0000007, 
+    0x80000007, 0x98000007, 0xD8000007, 0x90000007,
+    0x30000007, 0x60000007, 0x38000007, 0x8000007,
+    0x28000007, 0x78000007, 0x68000007, 0x40000007, 
+    0x20000007, 0x50000007, 0x48000007, 0x70000007, 
+    0x7,        0x18000007, 0x58000007, 0x10000007
+  }, {
+    0xE8,  0xD8,  0xA0,  0x88,  0x98,  0xF8,  0xA8,  0xC8,  0x80,  0xD0,
+    0xF0,  0xB8,  0xB0,  0xC0,  0x90,  0xE0,  0x7E8, 0x7D8, 0x7A0, 0x788,
+    0x798, 0x7F8, 0x7A8, 0x7C8, 0x780, 0x7D0, 0x7F0, 0x7B8, 0x7B0, 0x7C0,
+    0x790, 0x7E0, 0x6E8, 0x6D8, 0x6A0, 0x688, 0x698, 0x6F8, 0x6A8, 0x6C8,
+    0x680, 0x6D0, 0x6F0, 0x6B8, 0x6B0, 0x6C0, 0x690, 0x6E0, 0x68,  0x58,
+    0x20,  0x8,   0x18,  0x78,  0x28,   0x48,  0x0,   0x50,  0x70,  0x38,
+    0x30,  0x40,  0x10,  0x60,  0x2E8, 0x2D8, 0x2A0, 0x288, 0x298, 0x2F8,
+    0x2A8, 0x2C8, 0x280, 0x2D0, 0x2F0, 0x2B8, 0x2B0, 0x2C0, 0x290, 0x2E0,
+    0x3E8, 0x3D8, 0x3A0, 0x388, 0x398, 0x3F8, 0x3A8, 0x3C8, 0x380, 0x3D0,
+    0x3F0, 0x3B8, 0x3B0, 0x3C0, 0x390, 0x3E0, 0x568, 0x558, 0x520, 0x508,
+    0x518, 0x578, 0x528, 0x548, 0x500, 0x550, 0x570, 0x538, 0x530, 0x540,
+    0x510, 0x560, 0x268, 0x258, 0x220, 0x208, 0x218, 0x278, 0x228, 0x248,
+    0x200, 0x250, 0x270, 0x238, 0x230, 0x240, 0x210, 0x260, 0x4E8, 0x4D8,
+    0x4A0, 0x488, 0x498, 0x4F8, 0x4A8, 0x4C8, 0x480, 0x4D0, 0x4F0, 0x4B8,
+    0x4B0, 0x4C0, 0x490, 0x4E0, 0x168, 0x158, 0x120, 0x108, 0x118, 0x178,
+    0x128, 0x148, 0x100, 0x150, 0x170, 0x138, 0x130, 0x140, 0x110, 0x160,
+    0x1E8, 0x1D8, 0x1A0, 0x188, 0x198, 0x1F8, 0x1A8, 0x1C8, 0x180, 0x1D0,
+    0x1F0, 0x1B8, 0x1B0, 0x1C0, 0x190, 0x1E0, 0x768, 0x758, 0x720, 0x708,
+    0x718, 0x778, 0x728, 0x748, 0x700, 0x750, 0x770, 0x738, 0x730, 0x740,
+    0x710, 0x760, 0x368, 0x358, 0x320, 0x308, 0x318, 0x378, 0x328, 0x348,
+    0x300, 0x350, 0x370, 0x338, 0x330, 0x340, 0x310, 0x360, 0x5E8, 0x5D8,
+    0x5A0, 0x588, 0x598, 0x5F8, 0x5A8, 0x5C8, 0x580, 0x5D0, 0x5F0, 0x5B8,
+    0x5B0, 0x5C0, 0x590, 0x5E0, 0x468, 0x458, 0x420, 0x408, 0x418, 0x478,
+    0x428, 0x448, 0x400, 0x450, 0x470, 0x438, 0x430, 0x440, 0x410, 0x460,
+    0x668, 0x658, 0x620, 0x608, 0x618, 0x678, 0x628, 0x648, 0x600, 0x650,
+    0x670, 0x638, 0x630, 0x640, 0x610, 0x660
+  }
+};
+
+/* pre-initialized GOST lookup tables based on rotated S-Box */
+const uint32_t gost94_sbox_cryptpro[4][256] = {
+  {
+    0x2d000, 0x2a000, 0x2a800, 0x2b000, 0x2c000,
+    0x28800, 0x29800, 0x2b800, 0x2e800, 0x2e000,
+    0x2f000, 0x28000, 0x2c800, 0x29000, 0x2d800,
+    0x2f800, 0x7d000, 0x7a000, 0x7a800, 0x7b000,
+    0x7c000, 0x78800, 0x79800, 0x7b800, 0x7e800,
+    0x7e000, 0x7f000, 0x78000, 0x7c800, 0x79000,
+    0x7d800, 0x7f800, 0x25000, 0x22000, 0x22800,
+    0x23000, 0x24000, 0x20800, 0x21800, 0x23800,
+    0x26800, 0x26000, 0x27000, 0x20000, 0x24800,
+    0x21000, 0x25800, 0x27800, 0x5000,  0x2000,
+    0x2800,  0x3000,  0x4000,  0x800,   0x1800,
+    0x3800,  0x6800,  0x6000,  0x7000,  0x0,
+    0x4800,  0x1000,  0x5800,  0x7800,  0x15000,
+    0x12000, 0x12800, 0x13000, 0x14000, 0x10800,
+    0x11800, 0x13800, 0x16800, 0x16000, 0x17000,
+    0x10000, 0x14800, 0x11000, 0x15800, 0x17800,
+    0x6d000, 0x6a000, 0x6a800, 0x6b000, 0x6c000,
+    0x68800, 0x69800, 0x6b800, 0x6e800, 0x6e000,
+    0x6f000, 0x68000, 0x6c800, 0x69000, 0x6d800,
+    0x6f800, 0x5d000, 0x5a000, 0x5a800, 0x5b000,
+    0x5c000, 0x58800, 0x59800, 0x5b800, 0x5e800,
+    0x5e000, 0x5f000, 0x58000, 0x5c800, 0x59000,
+    0x5d800, 0x5f800, 0x4d000, 0x4a000, 0x4a800,
+    0x4b000, 0x4c000, 0x48800, 0x49800, 0x4b800,
+    0x4e800, 0x4e000, 0x4f000, 0x48000, 0x4c800,
+    0x49000, 0x4d800, 0x4f800, 0xd000,  0xa000,
+    0xa800,  0xb000,  0xc000,  0x8800,  0x9800,
+    0xb800,  0xe800,  0xe000,  0xf000,  0x8000,
+    0xc800,  0x9000,  0xd800,  0xf800,  0x3d000,
+    0x3a000, 0x3a800, 0x3b000, 0x3c000, 0x38800,
+    0x39800, 0x3b800, 0x3e800, 0x3e000, 0x3f000,
+    0x38000, 0x3c800, 0x39000, 0x3d800, 0x3f800,
+    0x35000, 0x32000, 0x32800, 0x33000, 0x34000,
+    0x30800, 0x31800, 0x33800, 0x36800, 0x36000,
+    0x37000, 0x30000, 0x34800, 0x31000, 0x35800,
+    0x37800, 0x1d000, 0x1a000, 0x1a800, 0x1b000,
+    0x1c000, 0x18800, 0x19800, 0x1b800, 0x1e800,
+    0x1e000, 0x1f000, 0x18000, 0x1c800, 0x19000,
+    0x1d800, 0x1f800, 0x65000, 0x62000, 0x62800,
+    0x63000, 0x64000, 0x60800, 0x61800, 0x63800,
+    0x66800, 0x66000, 0x67000, 0x60000, 0x64800,
+    0x61000, 0x65800, 0x67800, 0x75000, 0x72000,
+    0x72800, 0x73000, 0x74000, 0x70800, 0x71800,
+    0x73800, 0x76800, 0x76000, 0x77000, 0x70000,
+    0x74800, 0x71000, 0x75800, 0x77800, 0x55000,
+    0x52000, 0x52800, 0x53000, 0x54000, 0x50800,
+    0x51800, 0x53800, 0x56800, 0x56000, 0x57000,
+    0x50000, 0x54800, 0x51000, 0x55800, 0x57800,
+    0x45000, 0x42000, 0x42800, 0x43000, 0x44000,
+    0x40800, 0x41800, 0x43800, 0x46800, 0x46000,
+    0x47000, 0x40000, 0x44800, 0x41000, 0x45800, 0x47800
+  }, {
+    0x2380000, 0x2780000, 0x2600000, 0x2700000, 0x2480000,
+    0x2200000, 0x2080000, 0x2000000, 0x2180000, 0x2580000,
+    0x2280000, 0x2100000, 0x2300000, 0x2500000, 0x2400000,
+    0x2680000, 0x5380000, 0x5780000, 0x5600000, 0x5700000,
+    0x5480000, 0x5200000, 0x5080000, 0x5000000, 0x5180000,
+    0x5580000, 0x5280000, 0x5100000, 0x5300000, 0x5500000,
+    0x5400000, 0x5680000, 0x3b80000, 0x3f80000, 0x3e00000,
+    0x3f00000, 0x3c80000, 0x3a00000, 0x3880000, 0x3800000,
+    0x3980000, 0x3d80000, 0x3a80000, 0x3900000, 0x3b00000,
+    0x3d00000, 0x3c00000, 0x3e80000, 0x6380000, 0x6780000,
+    0x6600000, 0x6700000, 0x6480000, 0x6200000, 0x6080000,
+    0x6000000, 0x6180000, 0x6580000, 0x6280000, 0x6100000,
+    0x6300000, 0x6500000, 0x6400000, 0x6680000, 0x380000,
+    0x780000,  0x600000,  0x700000,  0x480000,  0x200000,
+    0x80000,   0x0,       0x180000,  0x580000,  0x280000,
+    0x100000,  0x300000,  0x500000,  0x400000,  0x680000,
+    0x7b80000, 0x7f80000, 0x7e00000, 0x7f00000, 0x7c80000,
+    0x7a00000, 0x7880000, 0x7800000, 0x7980000, 0x7d80000,
+    0x7a80000, 0x7900000, 0x7b00000, 0x7d00000, 0x7c00000,
+    0x7e80000, 0x1380000, 0x1780000, 0x1600000, 0x1700000,
+    0x1480000, 0x1200000, 0x1080000, 0x1000000, 0x1180000,
+    0x1580000, 0x1280000, 0x1100000, 0x1300000, 0x1500000,
+    0x1400000, 0x1680000, 0x4380000, 0x4780000, 0x4600000,
+    0x4700000, 0x4480000, 0x4200000, 0x4080000, 0x4000000,
+    0x4180000, 0x4580000, 0x4280000, 0x4100000, 0x4300000,
+    0x4500000, 0x4400000, 0x4680000, 0x7380000, 0x7780000,
+    0x7600000, 0x7700000, 0x7480000, 0x7200000, 0x7080000,
+    0x7000000, 0x7180000, 0x7580000, 0x7280000, 0x7100000,
+    0x7300000, 0x7500000, 0x7400000, 0x7680000, 0xb80000,
+    0xf80000,  0xe00000,  0xf00000,  0xc80000,  0xa00000,
+    0x880000,  0x800000,  0x980000,  0xd80000,  0xa80000,
+    0x900000,  0xb00000,  0xd00000,  0xc00000,  0xe80000,
+    0x3380000, 0x3780000, 0x3600000, 0x3700000, 0x3480000,
+    0x3200000, 0x3080000, 0x3000000, 0x3180000, 0x3580000,
+    0x3280000, 0x3100000, 0x3300000, 0x3500000, 0x3400000,
+    0x3680000, 0x2b80000, 0x2f80000, 0x2e00000, 0x2f00000,
+    0x2c80000, 0x2a00000, 0x2880000, 0x2800000, 0x2980000,
+    0x2d80000, 0x2a80000, 0x2900000, 0x2b00000, 0x2d00000,
+    0x2c00000, 0x2e80000, 0x6b80000, 0x6f80000, 0x6e00000,
+    0x6f00000, 0x6c80000, 0x6a00000, 0x6880000, 0x6800000,
+    0x6980000, 0x6d80000, 0x6a80000, 0x6900000, 0x6b00000,
+    0x6d00000, 0x6c00000, 0x6e80000, 0x5b80000, 0x5f80000,
+    0x5e00000, 0x5f00000, 0x5c80000, 0x5a00000, 0x5880000,
+    0x5800000, 0x5980000, 0x5d80000, 0x5a80000, 0x5900000,
+    0x5b00000, 0x5d00000, 0x5c00000, 0x5e80000, 0x4b80000,
+    0x4f80000, 0x4e00000, 0x4f00000, 0x4c80000, 0x4a00000,
+    0x4880000, 0x4800000, 0x4980000, 0x4d80000, 0x4a80000,
+    0x4900000, 0x4b00000, 0x4d00000, 0x4c00000, 0x4e80000,
+    0x1b80000, 0x1f80000, 0x1e00000, 0x1f00000, 0x1c80000,
+    0x1a00000, 0x1880000, 0x1800000, 0x1980000, 0x1d80000,
+    0x1a80000, 0x1900000, 0x1b00000, 0x1d00000, 0x1c00000,
+    0x1e80000
+  }, {
+    0xb8000003, 0xb0000003, 0xa0000003, 0xd8000003, 0xc8000003,
+    0xe0000003, 0x90000003, 0xd0000003, 0x88000003, 0xc0000003,
+    0x80000003, 0xf0000003, 0xf8000003, 0xe8000003, 0x98000003,
+    0xa8000003, 0x38000003, 0x30000003, 0x20000003, 0x58000003,
+    0x48000003, 0x60000003, 0x10000003, 0x50000003, 0x8000003,
+    0x40000003, 0x3,        0x70000003, 0x78000003, 0x68000003,
+    0x18000003, 0x28000003, 0x38000001, 0x30000001, 0x20000001,
+    0x58000001, 0x48000001, 0x60000001, 0x10000001, 0x50000001,
+    0x8000001,  0x40000001, 0x1,        0x70000001, 0x78000001,
+    0x68000001, 0x18000001, 0x28000001, 0x38000002, 0x30000002,
+    0x20000002, 0x58000002, 0x48000002, 0x60000002, 0x10000002,
+    0x50000002, 0x8000002,  0x40000002, 0x2,        0x70000002,
+    0x78000002, 0x68000002, 0x18000002, 0x28000002, 0xb8000006,
+    0xb0000006, 0xa0000006, 0xd8000006, 0xc8000006, 0xe0000006,
+    0x90000006, 0xd0000006, 0x88000006, 0xc0000006, 0x80000006,
+    0xf0000006, 0xf8000006, 0xe8000006, 0x98000006, 0xa8000006,
+    0xb8000004, 0xb0000004, 0xa0000004, 0xd8000004, 0xc8000004,
+    0xe0000004, 0x90000004, 0xd0000004, 0x88000004, 0xc0000004,
+    0x80000004, 0xf0000004, 0xf8000004, 0xe8000004, 0x98000004,
+    0xa8000004, 0xb8000007, 0xb0000007, 0xa0000007, 0xd8000007,
+    0xc8000007, 0xe0000007, 0x90000007, 0xd0000007, 0x88000007,
+    0xc0000007, 0x80000007, 0xf0000007, 0xf8000007, 0xe8000007,
+    0x98000007, 0xa8000007, 0x38000000, 0x30000000, 0x20000000,
+    0x58000000, 0x48000000, 0x60000000, 0x10000000, 0x50000000,
+    0x8000000,  0x40000000, 0x0,        0x70000000, 0x78000000,
+    0x68000000, 0x18000000, 0x28000000, 0x38000005, 0x30000005,
+    0x20000005, 0x58000005, 0x48000005, 0x60000005, 0x10000005,
+    0x50000005, 0x8000005,  0x40000005, 0x5,        0x70000005,
+    0x78000005, 0x68000005, 0x18000005, 0x28000005, 0xb8000000,
+    0xb0000000, 0xa0000000, 0xd8000000, 0xc8000000, 0xe0000000,
+    0x90000000, 0xd0000000, 0x88000000, 0xc0000000, 0x80000000,
+    0xf0000000, 0xf8000000, 0xe8000000, 0x98000000, 0xa8000000,
+    0xb8000002, 0xb0000002, 0xa0000002, 0xd8000002, 0xc8000002,
+    0xe0000002, 0x90000002, 0xd0000002, 0x88000002, 0xc0000002,
+    0x80000002, 0xf0000002, 0xf8000002, 0xe8000002, 0x98000002,
+    0xa8000002, 0xb8000005, 0xb0000005, 0xa0000005, 0xd8000005,
+    0xc8000005, 0xe0000005, 0x90000005, 0xd0000005, 0x88000005,
+    0xc0000005, 0x80000005, 0xf0000005, 0xf8000005, 0xe8000005,
+    0x98000005, 0xa8000005, 0x38000004, 0x30000004, 0x20000004,
+    0x58000004, 0x48000004, 0x60000004, 0x10000004, 0x50000004,
+    0x8000004,  0x40000004, 0x4,        0x70000004, 0x78000004,
+    0x68000004, 0x18000004, 0x28000004, 0x38000007, 0x30000007,
+    0x20000007, 0x58000007, 0x48000007, 0x60000007, 0x10000007,
+    0x50000007, 0x8000007,  0x40000007, 0x7,        0x70000007,
+    0x78000007, 0x68000007, 0x18000007, 0x28000007, 0x38000006,
+    0x30000006, 0x20000006, 0x58000006, 0x48000006, 0x60000006,
+    0x10000006, 0x50000006, 0x8000006,  0x40000006, 0x6,
+    0x70000006, 0x78000006, 0x68000006, 0x18000006, 0x28000006,
+    0xb8000001, 0xb0000001, 0xa0000001, 0xd8000001, 0xc8000001,
+    0xe0000001, 0x90000001, 0xd0000001, 0x88000001, 0xc0000001,
+    0x80000001, 0xf0000001, 0xf8000001, 0xe8000001, 0x98000001,
+    0xa8000001
+  }, {
+    0xe8,  0xf0,  0xa0,  0x88,  0xb8,  0x80,  0xa8,  0xd0,  0x98,  0xe0,
+    0xc0,  0xf8,  0xb0,  0x90,  0xc8,  0xd8,  0x1e8, 0x1f0, 0x1a0, 0x188,
+    0x1b8, 0x180, 0x1a8, 0x1d0, 0x198, 0x1e0, 0x1c0, 0x1f8, 0x1b0, 0x190,
+    0x1c8, 0x1d8, 0x568, 0x570, 0x520, 0x508, 0x538, 0x500, 0x528, 0x550,
+    0x518, 0x560, 0x540, 0x578, 0x530, 0x510, 0x548, 0x558, 0x4e8, 0x4f0,
+    0x4a0, 0x488, 0x4b8, 0x480, 0x4a8, 0x4d0, 0x498, 0x4e0, 0x4c0, 0x4f8,
+    0x4b0, 0x490, 0x4c8, 0x4d8, 0x2e8, 0x2f0, 0x2a0, 0x288, 0x2b8, 0x280,
+    0x2a8, 0x2d0, 0x298, 0x2e0, 0x2c0, 0x2f8, 0x2b0, 0x290, 0x2c8, 0x2d8,
+    0x5e8, 0x5f0, 0x5a0, 0x588, 0x5b8, 0x580, 0x5a8, 0x5d0, 0x598, 0x5e0,
+    0x5c0, 0x5f8, 0x5b0, 0x590, 0x5c8, 0x5d8, 0x268, 0x270, 0x220, 0x208,
+    0x238, 0x200, 0x228, 0x250, 0x218, 0x260, 0x240, 0x278, 0x230, 0x210,
+    0x248, 0x258, 0x7e8, 0x7f0, 0x7a0, 0x788, 0x7b8, 0x780, 0x7a8, 0x7d0,
+    0x798, 0x7e0, 0x7c0, 0x7f8, 0x7b0, 0x790, 0x7c8, 0x7d8, 0x468, 0x470,
+    0x420, 0x408, 0x438, 0x400, 0x428, 0x450, 0x418, 0x460, 0x440, 0x478,
+    0x430, 0x410, 0x448, 0x458, 0x368, 0x370, 0x320, 0x308, 0x338, 0x300,
+    0x328, 0x350, 0x318, 0x360, 0x340, 0x378, 0x330, 0x310, 0x348, 0x358,
+    0x3e8, 0x3f0, 0x3a0, 0x388, 0x3b8, 0x380, 0x3a8, 0x3d0, 0x398, 0x3e0,
+    0x3c0, 0x3f8, 0x3b0, 0x390, 0x3c8, 0x3d8, 0x768, 0x770, 0x720, 0x708,
+    0x738, 0x700, 0x728, 0x750, 0x718, 0x760, 0x740, 0x778, 0x730, 0x710,
+    0x748, 0x758, 0x6e8, 0x6f0, 0x6a0, 0x688, 0x6b8, 0x680, 0x6a8, 0x6d0,
+    0x698, 0x6e0, 0x6c0, 0x6f8, 0x6b0, 0x690, 0x6c8, 0x6d8, 0x68,  0x70,
+    0x20,  0x8,   0x38,  0x0,   0x28,  0x50,  0x18,  0x60,  0x40,  0x78,
+    0x30,  0x10,  0x48,  0x58,  0x168, 0x170, 0x120, 0x108, 0x138, 0x100,
+    0x128, 0x150, 0x118, 0x160, 0x140, 0x178, 0x130, 0x110, 0x148, 0x158,
+    0x668, 0x670, 0x620, 0x608, 0x638, 0x600, 0x628, 0x650, 0x618, 0x660,
+    0x640, 0x678, 0x630, 0x610, 0x648, 0x658
+  }
+};
+
+
+#endif /* GENERATE_GOST_LOOKUP_TABLE */
diff --git a/gost94.c b/gost94.c
new file mode 100644
index 0000000..9e04c64
--- /dev/null
+++ b/gost94.c
@@ -0,0 +1,387 @@
+/* gost.c - an implementation of GOST Hash Function
+ * based on the Russian Standard GOST R 34.11-94.
+ * See also RFC 4357.
+ *
+ * Implementation written by Alexei Kravchenko.
+ * Ported to nettle by Nikos Mavrogiannopoulos.
+ *
+ * Copyleft:
+ * I hereby release this code into the public domain. This applies worldwide.
+ * I grant any entity the right to use this work for ANY PURPOSE,
+ * without any conditions, unless such conditions are required by law.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "macros.h"
+#include "nettle-write.h"
+#include "gost94.h"
+
+extern uint32_t gost94_sbox[4][256];
+extern uint32_t gost94_sbox_cryptpro[4][256];
+
+/**
+ * Initialize algorithm context before calculating hash
+ * with test parameters set.
+ *
+ * @param ctx context to initalize
+ */
+void
+gost94_init (gost94_ctx * ctx)
+{
+    memset (ctx, 0, sizeof (gost94_ctx));
+    ctx-&gt;sbox = (uint32_t*)gost94_sbox;
+}
+
+void
+gost94_init2 (gost94_ctx * ctx, unsigned int flag)
+{
+    memset (ctx, 0, sizeof (gost94_ctx));
+    ctx-&gt;flag = flag;
+
+    if (ctx-&gt;flag &amp; GOST_FLAG_CRYPTOPRO)
+      ctx-&gt;sbox = (uint32_t*)gost94_sbox_cryptpro;
+    else 
+      ctx-&gt;sbox = (uint32_t*)gost94_sbox;
+}
+
+/*
+ *  A macro that performs a full encryption round of GOST 28147-89.
+ *  Temporary variables tmp assumed and variables r and l for left and right
+ *  blocks.
+ */
+#define GOST_ENCRYPT_ROUND(key1, key2, sbox) \
+  tmp = (key1) + r; \
+  l ^= (sbox)[tmp &amp; 0xff] ^ ((sbox)+256)[(tmp &gt;&gt; 8) &amp; 0xff] ^ \
+    ((sbox)+512)[(tmp &gt;&gt; 16) &amp; 0xff] ^ ((sbox)+768)[tmp &gt;&gt; 24]; \
+  tmp = (key2) + l; \
+  r ^= (sbox)[tmp &amp; 0xff] ^ ((sbox)+256)[(tmp &gt;&gt; 8) &amp; 0xff] ^ \
+    ((sbox)+512)[(tmp &gt;&gt; 16) &amp; 0xff] ^ ((sbox)+768)[tmp &gt;&gt; 24];
+
+/* encrypt a block with the given key */
+#define GOST_ENCRYPT(result, i, key, hash, sbox) \
+  r = hash[i], l = hash[i + 1]; \
+  GOST_ENCRYPT_ROUND(key[0], key[1], sbox) \
+  GOST_ENCRYPT_ROUND(key[2], key[3], sbox) \
+  GOST_ENCRYPT_ROUND(key[4], key[5], sbox) \
+  GOST_ENCRYPT_ROUND(key[6], key[7], sbox) \
+  GOST_ENCRYPT_ROUND(key[0], key[1], sbox) \
+  GOST_ENCRYPT_ROUND(key[2], key[3], sbox) \
+  GOST_ENCRYPT_ROUND(key[4], key[5], sbox) \
+  GOST_ENCRYPT_ROUND(key[6], key[7], sbox) \
+  GOST_ENCRYPT_ROUND(key[0], key[1], sbox) \
+  GOST_ENCRYPT_ROUND(key[2], key[3], sbox) \
+  GOST_ENCRYPT_ROUND(key[4], key[5], sbox) \
+  GOST_ENCRYPT_ROUND(key[6], key[7], sbox) \
+  GOST_ENCRYPT_ROUND(key[7], key[6], sbox) \
+  GOST_ENCRYPT_ROUND(key[5], key[4], sbox) \
+  GOST_ENCRYPT_ROUND(key[3], key[2], sbox) \
+  GOST_ENCRYPT_ROUND(key[1], key[0], sbox) \
+  result[i] = l, result[i + 1] = r;
+
+/**
+ * The core transformation. Process a 512-bit block.
+ *
+ * @param hash intermediate message hash
+ * @param block the message block to process
+ */
+static void
+gost_block_compress (gost94_ctx * ctx, const uint32_t *block)
+{
+    unsigned i;
+    uint32_t key[8], u[8], v[8], w[8], s[8];
+    uint32_t l, r, tmp;
+
+    /* u := hash, v := &lt;256-bit message block&gt; */
+    memcpy (u, ctx-&gt;hash, sizeof (u));
+    memcpy (v, block, sizeof (v));
+
+    /* w := u xor v */
+    w[0] = u[0] ^ v[0], w[1] = u[1] ^ v[1];
+    w[2] = u[2] ^ v[2], w[3] = u[3] ^ v[3];
+    w[4] = u[4] ^ v[4], w[5] = u[5] ^ v[5];
+    w[6] = u[6] ^ v[6], w[7] = u[7] ^ v[7];
+
+    /* calculate keys, encrypt hash and store result to the s[] array */
+    for (i = 0;; i += 2)
+      {
+          /* key generation: key_i := P(w) */
+          key[0] =
+              (w[0] &amp; 0x000000ff) | ((w[2] &amp; 0x000000ff) &lt;&lt; 8) |
+              ((w[4] &amp; 0x000000ff) &lt;&lt; 16) | ((w[6] &amp; 0x000000ff) &lt;&lt; 24);
+          key[1] =
+              ((w[0] &amp; 0x0000ff00) &gt;&gt; 8) | (w[2] &amp; 0x0000ff00) |
+              ((w[4] &amp; 0x0000ff00) &lt;&lt; 8) | ((w[6] &amp; 0x0000ff00) &lt;&lt; 16);
+          key[2] =
+              ((w[0] &amp; 0x00ff0000) &gt;&gt; 16) | ((w[2] &amp; 0x00ff0000) &gt;&gt; 8) |
+              (w[4] &amp; 0x00ff0000) | ((w[6] &amp; 0x00ff0000) &lt;&lt; 8);
+          key[3] =
+              ((w[0] &amp; 0xff000000) &gt;&gt; 24) | ((w[2] &amp; 0xff000000) &gt;&gt; 16) |
+              ((w[4] &amp; 0xff000000) &gt;&gt; 8) | (w[6] &amp; 0xff000000);
+          key[4] =
+              (w[1] &amp; 0x000000ff) | ((w[3] &amp; 0x000000ff) &lt;&lt; 8) |
+              ((w[5] &amp; 0x000000ff) &lt;&lt; 16) | ((w[7] &amp; 0x000000ff) &lt;&lt; 24);
+          key[5] =
+              ((w[1] &amp; 0x0000ff00) &gt;&gt; 8) | (w[3] &amp; 0x0000ff00) |
+              ((w[5] &amp; 0x0000ff00) &lt;&lt; 8) | ((w[7] &amp; 0x0000ff00) &lt;&lt; 16);
+          key[6] =
+              ((w[1] &amp; 0x00ff0000) &gt;&gt; 16) | ((w[3] &amp; 0x00ff0000) &gt;&gt; 8) |
+              (w[5] &amp; 0x00ff0000) | ((w[7] &amp; 0x00ff0000) &lt;&lt; 8);
+          key[7] =
+              ((w[1] &amp; 0xff000000) &gt;&gt; 24) | ((w[3] &amp; 0xff000000) &gt;&gt; 16) |
+              ((w[5] &amp; 0xff000000) &gt;&gt; 8) | (w[7] &amp; 0xff000000);
+
+          /* encryption: s_i := E_{key_i} (h_i) */
+          GOST_ENCRYPT (s, i, key, ctx-&gt;hash, ctx-&gt;sbox);
+
+          if (i == 0)
+            {
+                /* w:= A(u) ^ A^2(v) */
+                w[0] = u[2] ^ v[4], w[1] = u[3] ^ v[5];
+                w[2] = u[4] ^ v[6], w[3] = u[5] ^ v[7];
+                w[4] = u[6] ^ (v[0] ^= v[2]);
+                w[5] = u[7] ^ (v[1] ^= v[3]);
+                w[6] = (u[0] ^= u[2]) ^ (v[2] ^= v[4]);
+                w[7] = (u[1] ^= u[3]) ^ (v[3] ^= v[5]);
+            }
+          else if ((i &amp; 2) != 0)
+            {
+                if (i == 6)
+                    break;
+
+                /* w := A^2(u) xor A^4(v) xor C_3; u := A(u) xor C_3 */
+                /* C_3=0xff00ffff000000ffff0000ff00ffff0000ff00ff00ff00ffff00ff00ff00ff00 */
+                u[2] ^= u[4] ^ 0x000000ff;
+                u[3] ^= u[5] ^ 0xff00ffff;
+                u[4] ^= 0xff00ff00;
+                u[5] ^= 0xff00ff00;
+                u[6] ^= 0x00ff00ff;
+                u[7] ^= 0x00ff00ff;
+                u[0] ^= 0x00ffff00;
+                u[1] ^= 0xff0000ff;
+
+                w[0] = u[4] ^ v[0];
+                w[2] = u[6] ^ v[2];
+                w[4] = u[0] ^ (v[4] ^= v[6]);
+                w[6] = u[2] ^ (v[6] ^= v[0]);
+                w[1] = u[5] ^ v[1];
+                w[3] = u[7] ^ v[3];
+                w[5] = u[1] ^ (v[5] ^= v[7]);
+                w[7] = u[3] ^ (v[7] ^= v[1]);
+            }
+          else
+            {
+                /* i==4 here */
+                /* w:= A( A^2(u) xor C_3 ) xor A^6(v) */
+                w[0] = u[6] ^ v[4], w[1] = u[7] ^ v[5];
+                w[2] = u[0] ^ v[6], w[3] = u[1] ^ v[7];
+                w[4] = u[2] ^ (v[0] ^= v[2]);
+                w[5] = u[3] ^ (v[1] ^= v[3]);
+                w[6] = (u[4] ^= u[6]) ^ (v[2] ^= v[4]);
+                w[7] = (u[5] ^= u[7]) ^ (v[3] ^= v[5]);
+            }
+      }
+
+    /* step hash function: x(block, hash) := psi^61(hash xor psi(block xor psi^12(S))) */
+
+    /* 12 rounds of the LFSR and xor in &lt;message block&gt; */
+    u[0] = block[0] ^ s[6];
+    u[1] = block[1] ^ s[7];
+    u[2] =
+        block[2] ^ (s[0] &lt;&lt; 16) ^ (s[0] &gt;&gt; 16) ^ (s[0] &amp; 0xffff) ^ (s[1] &amp;
+                                                                    0xffff)
+        ^ (s[1] &gt;&gt; 16) ^ (s[2] &lt;&lt; 16) ^ s[6] ^ (s[6] &lt;&lt; 16) ^ (s[7] &amp;
+                                                               0xffff0000)
+        ^ (s[7] &gt;&gt; 16);
+    u[3] =
+        block[3] ^ (s[0] &amp; 0xffff) ^ (s[0] &lt;&lt; 16) ^ (s[1] &amp; 0xffff) ^ (s[1]
+                                                                       &lt;&lt;
+                                                                       16)
+        ^ (s[1] &gt;&gt; 16) ^ (s[2] &lt;&lt; 16) ^ (s[2] &gt;&gt; 16) ^ (s[3] &lt;&lt; 16) ^ s[6]
+        ^ (s[6] &lt;&lt; 16) ^ (s[6] &gt;&gt; 16) ^ (s[7] &amp; 0xffff) ^ (s[7] &lt;&lt; 16) ^
+        (s[7] &gt;&gt; 16);
+    u[4] =
+        block[4] ^ (s[0] &amp; 0xffff0000) ^ (s[0] &lt;&lt; 16) ^ (s[0] &gt;&gt; 16) ^
+        (s[1] &amp; 0xffff0000) ^ (s[1] &gt;&gt; 16) ^ (s[2] &lt;&lt; 16) ^ (s[2] &gt;&gt; 16) ^
+        (s[3] &lt;&lt; 16) ^ (s[3] &gt;&gt; 16) ^ (s[4] &lt;&lt; 16) ^ (s[6] &lt;&lt; 16) ^ (s[6]
+                                                                     &gt;&gt; 16)
+        ^ (s[7] &amp; 0xffff) ^ (s[7] &lt;&lt; 16) ^ (s[7] &gt;&gt; 16);
+    u[5] =
+        block[5] ^ (s[0] &lt;&lt; 16) ^ (s[0] &gt;&gt; 16) ^ (s[0] &amp; 0xffff0000) ^
+        (s[1] &amp; 0xffff) ^ s[2] ^ (s[2] &gt;&gt; 16) ^ (s[3] &lt;&lt; 16) ^ (s[3] &gt;&gt; 16)
+        ^ (s[4] &lt;&lt; 16) ^ (s[4] &gt;&gt; 16) ^ (s[5] &lt;&lt; 16) ^ (s[6] &lt;&lt; 16) ^ (s[6]
+                                                                       &gt;&gt;
+                                                                       16)
+        ^ (s[7] &amp; 0xffff0000) ^ (s[7] &lt;&lt; 16) ^ (s[7] &gt;&gt; 16);
+    u[6] =
+        block[6] ^ s[0] ^ (s[1] &gt;&gt; 16) ^ (s[2] &lt;&lt; 16) ^ s[3] ^ (s[3] &gt;&gt; 16)
+        ^ (s[4] &lt;&lt; 16) ^ (s[4] &gt;&gt; 16) ^ (s[5] &lt;&lt; 16) ^ (s[5] &gt;&gt; 16) ^ s[6]
+        ^ (s[6] &lt;&lt; 16) ^ (s[6] &gt;&gt; 16) ^ (s[7] &lt;&lt; 16);
+    u[7] =
+        block[7] ^ (s[0] &amp; 0xffff0000) ^ (s[0] &lt;&lt; 16) ^ (s[1] &amp; 0xffff) ^
+        (s[1] &lt;&lt; 16) ^ (s[2] &gt;&gt; 16) ^ (s[3] &lt;&lt; 16) ^ s[4] ^ (s[4] &gt;&gt; 16) ^
+        (s[5] &lt;&lt; 16) ^ (s[5] &gt;&gt; 16) ^ (s[6] &gt;&gt; 16) ^ (s[7] &amp; 0xffff) ^
+        (s[7] &lt;&lt; 16) ^ (s[7] &gt;&gt; 16);
+
+    /* 1 round of the LFSR (a mixing transformation) and xor with &lt;hash&gt; */
+    v[0] = ctx-&gt;hash[0] ^ (u[1] &lt;&lt; 16) ^ (u[0] &gt;&gt; 16);
+    v[1] = ctx-&gt;hash[1] ^ (u[2] &lt;&lt; 16) ^ (u[1] &gt;&gt; 16);
+    v[2] = ctx-&gt;hash[2] ^ (u[3] &lt;&lt; 16) ^ (u[2] &gt;&gt; 16);
+    v[3] = ctx-&gt;hash[3] ^ (u[4] &lt;&lt; 16) ^ (u[3] &gt;&gt; 16);
+    v[4] = ctx-&gt;hash[4] ^ (u[5] &lt;&lt; 16) ^ (u[4] &gt;&gt; 16);
+    v[5] = ctx-&gt;hash[5] ^ (u[6] &lt;&lt; 16) ^ (u[5] &gt;&gt; 16);
+    v[6] = ctx-&gt;hash[6] ^ (u[7] &lt;&lt; 16) ^ (u[6] &gt;&gt; 16);
+    v[7] =
+        ctx-&gt;
+        hash[7] ^ (u[0] &amp; 0xffff0000) ^ (u[0] &lt;&lt; 16) ^ (u[1] &amp; 0xffff0000)
+        ^ (u[1] &lt;&lt; 16) ^ (u[6] &lt;&lt; 16) ^ (u[7] &amp; 0xffff0000) ^ (u[7] &gt;&gt; 16);
+
+    /* 61 rounds of LFSR, mixing up hash */
+    ctx-&gt;hash[0] = (v[0] &amp; 0xffff0000) ^ (v[0] &lt;&lt; 16) ^ (v[0] &gt;&gt; 16) ^
+        (v[1] &gt;&gt; 16) ^ (v[1] &amp; 0xffff0000) ^ (v[2] &lt;&lt; 16) ^
+        (v[3] &gt;&gt; 16) ^ (v[4] &lt;&lt; 16) ^ (v[5] &gt;&gt; 16) ^ v[5] ^
+        (v[6] &gt;&gt; 16) ^ (v[7] &lt;&lt; 16) ^ (v[7] &gt;&gt; 16) ^ (v[7] &amp; 0xffff);
+    ctx-&gt;hash[1] = (v[0] &lt;&lt; 16) ^ (v[0] &gt;&gt; 16) ^ (v[0] &amp; 0xffff0000) ^
+        (v[1] &amp; 0xffff) ^ v[2] ^ (v[2] &gt;&gt; 16) ^ (v[3] &lt;&lt; 16) ^
+        (v[4] &gt;&gt; 16) ^ (v[5] &lt;&lt; 16) ^ (v[6] &lt;&lt; 16) ^ v[6] ^
+        (v[7] &amp; 0xffff0000) ^ (v[7] &gt;&gt; 16);
+    ctx-&gt;hash[2] = (v[0] &amp; 0xffff) ^ (v[0] &lt;&lt; 16) ^ (v[1] &lt;&lt; 16) ^
+        (v[1] &gt;&gt; 16) ^ (v[1] &amp; 0xffff0000) ^ (v[2] &lt;&lt; 16) ^ (v[3] &gt;&gt; 16) ^
+        v[3] ^ (v[4] &lt;&lt; 16) ^ (v[5] &gt;&gt; 16) ^ v[6] ^ (v[6] &gt;&gt; 16) ^
+        (v[7] &amp; 0xffff) ^ (v[7] &lt;&lt; 16) ^ (v[7] &gt;&gt; 16);
+    ctx-&gt;hash[3] = (v[0] &lt;&lt; 16) ^ (v[0] &gt;&gt; 16) ^ (v[0] &amp; 0xffff0000) ^
+        (v[1] &amp; 0xffff0000) ^ (v[1] &gt;&gt; 16) ^ (v[2] &lt;&lt; 16) ^
+        (v[2] &gt;&gt; 16) ^ v[2] ^ (v[3] &lt;&lt; 16) ^ (v[4] &gt;&gt; 16) ^ v[4] ^
+        (v[5] &lt;&lt; 16) ^ (v[6] &lt;&lt; 16) ^ (v[7] &amp; 0xffff) ^ (v[7] &gt;&gt; 16);
+    ctx-&gt;hash[4] =
+        (v[0] &gt;&gt; 16) ^ (v[1] &lt;&lt; 16) ^ v[1] ^ (v[2] &gt;&gt; 16) ^ v[2] ^ (v[3] &lt;&lt;
+                                                                    16) ^
+        (v[3] &gt;&gt; 16) ^ v[3] ^ (v[4] &lt;&lt; 16) ^ (v[5] &gt;&gt; 16) ^ v[5] ^ (v[6] &lt;&lt;
+                                                                    16) ^
+        (v[6] &gt;&gt; 16) ^ (v[7] &lt;&lt; 16);
+    ctx-&gt;hash[5] =
+        (v[0] &lt;&lt; 16) ^ (v[0] &amp; 0xffff0000) ^ (v[1] &lt;&lt; 16) ^ (v[1] &gt;&gt; 16) ^
+        (v[1] &amp; 0xffff0000) ^ (v[2] &lt;&lt; 16) ^ v[2] ^ (v[3] &gt;&gt; 16) ^ v[3] ^
+        (v[4] &lt;&lt; 16) ^ (v[4] &gt;&gt; 16) ^ v[4] ^ (v[5] &lt;&lt; 16) ^ (v[6] &lt;&lt; 16) ^
+        (v[6] &gt;&gt; 16) ^ v[6] ^ (v[7] &lt;&lt; 16) ^ (v[7] &gt;&gt; 16) ^ (v[7] &amp;
+                                                             0xffff0000);
+    ctx-&gt;hash[6] =
+        v[0] ^ v[2] ^ (v[2] &gt;&gt; 16) ^ v[3] ^ (v[3] &lt;&lt; 16) ^ v[4] ^ (v[4] &gt;&gt;
+                                                                   16) ^
+        (v[5] &lt;&lt; 16) ^ (v[5] &gt;&gt; 16) ^ v[5] ^ (v[6] &lt;&lt; 16) ^ (v[6] &gt;&gt; 16) ^
+        v[6] ^ (v[7] &lt;&lt; 16) ^ v[7];
+    ctx-&gt;hash[7] =
+        v[0] ^ (v[0] &gt;&gt; 16) ^ (v[1] &lt;&lt; 16) ^ (v[1] &gt;&gt; 16) ^ (v[2] &lt;&lt; 16) ^
+        (v[3] &gt;&gt; 16) ^ v[3] ^ (v[4] &lt;&lt; 16) ^ v[4] ^ (v[5] &gt;&gt; 16) ^ v[5] ^
+        (v[6] &lt;&lt; 16) ^ (v[6] &gt;&gt; 16) ^ (v[7] &lt;&lt; 16) ^ v[7];
+}
+
+/**
+ * This function calculates hash value by 256-bit blocks.
+ * It updates 256-bit check sum as follows:
+ *    *(uint256_t)(ctx-&gt;sum) += *(uint256_t*)block;
+ * and then updates intermediate hash value ctx-&gt;hash 
+ * by calling gost_block_compress().
+ *
+ * @param ctx algorithm context
+ * @param block the 256-bit message block to process
+ */
+static void
+gost_compute_sum_and_hash (gost94_ctx * ctx, const uint8_t *block)
+{
+    uint32_t block_le[8];
+    unsigned i, carry = 0;
+    uint32_t old;
+
+    /* compute the 256-bit sum */
+    for (i = 0; i &lt; 8; i++)
+      {
+          old = ctx-&gt;sum[i];
+          block_le[i] = LE_READ_UINT32(block);
+          ctx-&gt;sum[i] += block_le[i] + carry;
+          carry = (ctx-&gt;sum[i] &lt; old || ctx-&gt;sum[i] &lt; block_le[i] ? 1 : 0);
+          block += 4;
+      }
+
+    /* update message hash */
+    gost_block_compress (ctx, block_le);
+}
+
+/**
+ * Calculate message hash.
+ * Can be called repeatedly with chunks of the message to be hashed.
+ *
+ * @param ctx the algorithm context containing current hashing state
+ * @param msg message chunk
+ * @param size length of the message chunk
+ */
+void
+gost94_update (gost94_ctx * ctx, unsigned length, const uint8_t *msg)
+{
+    unsigned index = (unsigned) ctx-&gt;length &amp; 31;
+    ctx-&gt;length += length;
+
+    /* fill partial block */
+    if (index)
+      {
+          unsigned left = GOST94_DATA_SIZE - index;
+          memcpy (ctx-&gt;message + index, msg, (length &lt; left ? length : left));
+          if (length &lt; left)
+              return;
+
+          /* process partial block */
+          gost_compute_sum_and_hash (ctx, ctx-&gt;message);
+          msg += left;
+          length -= left;
+      }
+    while (length &gt;= GOST94_DATA_SIZE)
+      {
+          gost_compute_sum_and_hash (ctx, msg);
+          msg += GOST94_DATA_SIZE;
+          length -= GOST94_DATA_SIZE;
+      }
+    if (length)
+      {
+          /* save leftovers */
+          memcpy (ctx-&gt;message, msg, length);
+      }
+}
+
+/**
+ * Finish hashing and store message digest into given array.
+ *
+ * @param ctx the algorithm context containing current hashing state
+ * @param result calculated hash in binary form
+ */
+void
+gost94_digest (gost94_ctx * ctx, unsigned length, uint8_t *result)
+{
+    unsigned index = ctx-&gt;length &amp; 31;
+    uint32_t *msg32 = (uint32_t*)ctx-&gt;message;
+
+    assert(length &lt;= GOST94_DIGEST_SIZE);
+
+    /* pad the last block with zeroes and hash it */
+    if (index &gt; 0)
+      {
+          memset (ctx-&gt;message + index, 0, 32 - index);
+          gost_compute_sum_and_hash (ctx, ctx-&gt;message);
+      }
+
+    /* hash the message length and the sum */
+    msg32[0] = (uint32_t) (ctx-&gt;length &lt;&lt; 3);
+    msg32[1] = (uint32_t) (ctx-&gt;length &gt;&gt; 29);
+    memset (msg32 + 2, 0, sizeof (uint32_t) * 6);
+
+    gost_block_compress (ctx, msg32);
+    gost_block_compress (ctx, ctx-&gt;sum);
+
+    /* convert hash state to result bytes */
+    _nettle_write_le32(length, result, ctx-&gt;hash);
+}
+
diff --git a/gost94.h b/gost94.h
new file mode 100644
index 0000000..dfe79ea
--- /dev/null
+++ b/gost94.h
@@ -0,0 +1,55 @@
+/* md5.h
+ *
+ * The GOST R 34.11-94 hash function, described in RFC 5831.
+ */
+
+#ifndef NETTLE_GOST_H_INCLUDED
+#define NETTLE_GOST_H_INCLUDED
+
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define gost94_init nettle_gost94_init
+#define gost94_init2 nettle_gost94_init2
+#define gost94_init_table nettle_gost94_init_table
+#define gost94_update nettle_gost94_update
+#define gost94_digest nettle_gost94_digest
+
+#undef GENERATE_GOST_LOOKUP_TABLE
+
+#define GOST94_DATA_SIZE 32
+#define GOST94_DIGEST_SIZE 32
+
+/* if set it enables the CryptoPro parameter set */
+#define GOST_FLAG_CRYPTOPRO 1
+
+/* algorithm context */
+typedef struct gost94_ctx
+{
+  uint32_t hash[8]; /* algorithm 256-bit state */
+  uint32_t sum[8];  /* sum of processed message blocks */
+  uint8_t message[GOST94_DATA_SIZE]; /* 256-bit buffer for leftovers */
+  uint64_t length;  /* number of processed bytes */
+  uint32_t *sbox;
+  unsigned flag; /* flag, type of sbox to use */
+} gost94_ctx;
+
+/* hash functions */
+
+void gost94_init(gost94_ctx *ctx);
+void gost94_init2(gost94_ctx *ctx, unsigned int flag);
+void gost94_update(gost94_ctx *ctx, unsigned length, const uint8_t* msg);
+void gost94_digest(gost94_ctx *ctx, unsigned length, uint8_t* result);
+
+#ifdef GENERATE_GOST_LOOKUP_TABLE
+void gost94_init_table(void); /* initialize algorithm static data */
+#endif
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif /* __cplusplus */
+
+#endif /* NETTLE_GOST_H_INCLUDED */
diff --git a/nettle-meta.h b/nettle-meta.h
index c67d29a..325ba39 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -158,6 +158,7 @@ extern const struct nettle_hash * const nettle_hashes[];
 extern const struct nettle_hash nettle_md2;
 extern const struct nettle_hash nettle_md4;
 extern const struct nettle_hash nettle_md5;
+extern const struct nettle_hash nettle_gost94;
 extern const struct nettle_hash nettle_ripemd160;
 extern const struct nettle_hash nettle_sha1;
 extern const struct nettle_hash nettle_sha224;
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 5559886..bb9a06f 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -16,7 +16,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    camellia-test.c \
 		    des-test.c des3-test.c des-compat-test.c \
 		    md2-test.c md4-test.c md5-test.c md5-compat-test.c \
-		    memxor-test.c \
+		    memxor-test.c gost94-test.c \
 		    ripemd160-test.c \
 		    salsa20-test.c \
 		    sha1-test.c sha224-test.c sha256-test.c \
diff --git a/testsuite/gost94-test.c b/testsuite/gost94-test.c
new file mode 100644
index 0000000..502c767
--- /dev/null
+++ b/testsuite/gost94-test.c
@@ -0,0 +1,21 @@
+#include "testutils.h"
+#include "gost94.h"
+
+/* Using test vectors from Wikipedia article on GOST */
+
+void
+test_main(void)
+{
+  test_hash(&amp;nettle_gost94, SDATA("The quick brown fox jumps over the lazy dog"),
+	    SHEX("77b7fa410c9ac58a25f49bca7d0468c9296529315eaca76bd1a10f376d1f4294"));
+
+  test_hash(&amp;nettle_gost94, SDATA("message digest"),
+	    SHEX("ad4434ecb18f2c99b60cbe59ec3d2469582b65273f48de72db2fde16a4889a4d"));
+
+ test_hash(&amp;nettle_gost94, SDATA("a"),
+	    SHEX("d42c539e367c66e9c88a801f6649349c21871b4344c6a573f849fdce62f314dd"));
+
+ test_hash(&amp;nettle_gost94, SDATA(""),
+	    SHEX("ce85b99cc46752fffee35cab9a7b0278abb4c2d2055cff685af4912c49490f8d"));
+}
+
-- 
1.7.10.4



["0002-Do-not-just-abort-but-print-the-expected-and-retriev.patch" (text/x-patch)]

&gt;From 5975af491c4adb8579eb35e109c12965feb4a6cd Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Tue, 25 Sep 2012 19:57:51 +0200
Subject: [PATCH 2/2] Do not just abort but print the expected and retrieved
 values in hash tests.

---
 testsuite/testutils.c |    9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/testsuite/testutils.c b/testsuite/testutils.c
index de9baa4..78cd0d4 100644
--- a/testsuite/testutils.c
+++ b/testsuite/testutils.c
@@ -498,7 +498,14 @@ test_hash(const struct nettle_hash *hash,
   hash-&gt;update(ctx, msg-&gt;length, msg-&gt;data);
   hash-&gt;digest(ctx, hash-&gt;digest_size, buffer);
 
-  ASSERT(MEMEQ(hash-&gt;digest_size, digest-&gt;data, buffer));
+  if (MEMEQ(hash-&gt;digest_size, digest-&gt;data, buffer) == 0)
+    {
+      fprintf(stdout, "\nGot:\n");
+      print_hex(hash-&gt;digest_size, buffer);
+      fprintf(stdout, "\nExpected:\n");
+      print_hex(hash-&gt;digest_size, digest-&gt;data);
+      abort();
+    }
 
   memset(buffer, 0, hash-&gt;digest_size);
 
-- 
1.7.10.4




</body></email><email><emailId>20120927080929</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-27 08:09:29-0400</timestampReceived><subject>Re: gost hash</subject><body>

&gt; I had issue making the test gost94-test compile. For some reason the
&gt; makefile wouldn't link it against gmp (all the other tests were ok), and
&gt; couldn't figure out why.

cd into testsuite/  and
	make test-rules
	make

Regards,

    Tim R=FChsen

</body></email><email><emailId>20121003202725</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-10-03 20:27:25-0400</timestampReceived><subject>Re: gost hash</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;  The attached patch adds the GOST R 34.11-94 hash algorithm. I based
&gt; this code on Alexei Kravchenko's code from librhash.

Some comments:

&gt; + * Implementation written by Alexei Kravchenko.
&gt; + * Ported to nettle by Nikos Mavrogiannopoulos.
&gt; + *
&gt; + * Copyleft:
&gt; + * I hereby release this code into the public domain. This applies worldwide.
&gt; + * I grant any entity the right to use this work for ANY PURPOSE,
&gt; + * without any conditions, unless such conditions are required by law.
&gt; + */

The public domain notice, that is Alexei's, right? Do you intend your
modified version to also be in the public domain? (If we end up doing
any major changes to the file, I'd prefer to license the Nettle version
as LGPL, but if changes are minor, keeping it public domain is fine with
me).

The rhash license appear to be somewhat different
(see http://rhash.anz.ru/license.php), and the sourceforge page says it's
using the MIT license (see http://sourceforge.net/projects/rhash/).

&gt; +/**
&gt; + * Calculate a lookup table from S-Boxes.
&gt; + * A substitution table is used to speed up hash calculation.
&gt; + *
&gt; + * @param out pointer to the lookup table to fill
&gt; + * @param src pointer to eight S-Boxes to fill the table from
&gt; + */
&gt; +static void
&gt; +fill_gost94_sbox (uint32_t out[4][256], const uint8_t src[8][16])

Maybe this should be moved to a separate file gost-data, to generate the
tables during the build process?

&gt; +void
&gt; +gost94_init2 (gost94_ctx * ctx, unsigned int flag)
&gt; +{
&gt; +    memset (ctx, 0, sizeof (gost94_ctx));
&gt; +    ctx-&gt;flag = flag;
&gt; +
&gt; +    if (ctx-&gt;flag &amp; GOST_FLAG_CRYPTOPRO)
&gt; +      ctx-&gt;sbox = (uint32_t*)gost94_sbox_cryptpro;
&gt; +    else 
&gt; +      ctx-&gt;sbox = (uint32_t*)gost94_sbox;
&gt; +}

Can you explain briefly what this gost94_sbox and gost94_sbox_cryptpro
is about? I don't quite like having to put an sbox pointer into the
context struct, but maybe there's a good reason? Or maybe it's better to
treat them as two distinct hash functions (one could still share
internal functions like gost_block_compress, and pass appropriate sboxes
as an argument).

&gt; --- /dev/null
&gt; +++ b/gost94.h
&gt; @@ -0,0 +1,55 @@
&gt; +/* md5.h

That shouldn't say "md5" ;-)

&gt; +#undef GENERATE_GOST_LOOKUP_TABLE

I don't think GENERATE_GOST_LOOKUP_TABLE belongs in the header file.

&gt; +#define GOST94_DATA_SIZE 32
&gt; +#define GOST94_DIGEST_SIZE 32
&gt; +
&gt; +/* if set it enables the CryptoPro parameter set */
&gt; +#define GOST_FLAG_CRYPTOPRO 1

And neither does this, I think. If "CryptoPro" should be supported, that
should be unconditional (but with any large tables in a separate file).

&gt; +/* algorithm context */
&gt; +typedef struct gost94_ctx
&gt; +{
&gt; +  uint32_t hash[8]; /* algorithm 256-bit state */
&gt; +  uint32_t sum[8];  /* sum of processed message blocks */
&gt; +  uint8_t message[GOST94_DATA_SIZE]; /* 256-bit buffer for leftovers */
&gt; +  uint64_t length;  /* number of processed bytes */
&gt; +  uint32_t *sbox;
&gt; +  unsigned flag; /* flag, type of sbox to use */

The flag is set but unused, as far as I see.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121004183303</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-10-04 18:33:03-0400</timestampReceived><subject>Re: gost hash</subject><body>

On 10/03/2012 10:27 PM, Niels Möller wrote:


&gt;&gt; + * Copyleft:
&gt;&gt; + * I hereby release this code into the public domain. This applies worldwide.
&gt;&gt; + * I grant any entity the right to use this work for ANY PURPOSE,
&gt;&gt; + * without any conditions, unless such conditions are required by law.
&gt;&gt; + */
&gt; The public domain notice, that is Alexei's, right? 


Yes.

&gt; Do you intend your
&gt; modified version to also be in the public domain? (If we end up doing
&gt; any major changes to the file, I'd prefer to license the Nettle version
&gt; as LGPL, but if changes are minor, keeping it public domain is fine with
&gt; me).


I claim no copyright in my changes (they are minor), so the original
license applies. There is no problem with me to change it to LGPL though.

&gt; The rhash license appear to be somewhat different
&gt; (see http://rhash.anz.ru/license.php), and the sourceforge page says it's
&gt; using the MIT license (see http://sourceforge.net/projects/rhash/).


Do you want me to contact him for clarification? However, I think that
the file's license overrides the library license.

&gt;&gt; +/**
&gt;&gt; + * Calculate a lookup table from S-Boxes.
&gt;&gt; + * A substitution table is used to speed up hash calculation.
&gt;&gt; + *
&gt;&gt; + * @param out pointer to the lookup table to fill
&gt;&gt; + * @param src pointer to eight S-Boxes to fill the table from
&gt;&gt; + */
&gt;&gt; +static void
&gt;&gt; +fill_gost94_sbox (uint32_t out[4][256], const uint8_t src[8][16])
&gt; Maybe this should be moved to a separate file gost-data, to generate the
&gt; tables during the build process?


Is it really needed? They are already in gosthash94-tables.c. Is there
any advantage in generating them during build time? I was thinking to
even remove the fill_gost94_sbox() function. The sboxes are comparable
in size to the blowfish sboxes. What do you think?

&gt;&gt; +void
&gt;&gt; +gost94_init2 (gost94_ctx * ctx, unsigned int flag)
&gt;&gt; +{
&gt;&gt; +    memset (ctx, 0, sizeof (gost94_ctx));
&gt;&gt; +    ctx-&gt;flag = flag;
&gt;&gt; +
&gt;&gt; +    if (ctx-&gt;flag &amp; GOST_FLAG_CRYPTOPRO)
&gt;&gt; +      ctx-&gt;sbox = (uint32_t*)gost94_sbox_cryptpro;
&gt;&gt; +    else 
&gt;&gt; +      ctx-&gt;sbox = (uint32_t*)gost94_sbox;
&gt;&gt; +}
&gt; Can you explain briefly what this gost94_sbox and gost94_sbox_cryptpro
&gt; is about? 


I can only speculate on that because I'm not familiar with the standard.
However the gosthash is based on the gost encryption algorithm which had
no fixed sboxes. You could have different application areas of the
algorithm that used different sboxes.

For my use-case the original sboxes are ok. I just kept the
additional ones. I could remove them.

&gt; I don't quite like having to put an sbox pointer into the
&gt; context struct, but maybe there's a good reason? 


If the sboxes are like now in a constant array there are no issues, with
memcpy of contexts (if this is your concern).


&gt; treat them as two distinct hash functions (one could still share
&gt; internal functions like gost_block_compress, and pass appropriate sboxes
&gt; as an argument).


That would deviate from the format of the other hash functions in nettle.

&gt;&gt; +#undef GENERATE_GOST_LOOKUP_TABLE
&gt; I don't think GENERATE_GOST_LOOKUP_TABLE belongs in the header file.


Why would it be better? The header uses this definition.

btw. I've renamed the algorithm to gosthash94, to allow for a future
gost encryption algorithm.


&gt;&gt; +/* algorithm context */
&gt;&gt; +typedef struct gost94_ctx
&gt;&gt; +{
&gt;&gt; +  uint32_t hash[8]; /* algorithm 256-bit state */
&gt;&gt; +  uint32_t sum[8];  /* sum of processed message blocks */
&gt;&gt; +  uint8_t message[GOST94_DATA_SIZE]; /* 256-bit buffer for leftovers */
&gt;&gt; +  uint64_t length;  /* number of processed bytes */
&gt;&gt; +  uint32_t *sbox;
&gt;&gt; +  unsigned flag; /* flag, type of sbox to use */
&gt; 
&gt; The flag is set but unused, as far as I see.

Removed.

regards,
Nikos

</body></email><email><emailId>20121004194650</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-10-04 19:46:50-0400</timestampReceived><subject>Re: gost hash</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Do you want me to contact him for clarification? However, I think that
&gt; the file's license overrides the library license.

It would be nice if the licensing were crystal clear, and I'd like to
have a correct description also in the copyright section of the manual.

&gt; On 10/03/2012 10:27 PM, Niels Möller wrote:

&gt;&gt;&gt; +static void
&gt;&gt;&gt; +fill_gost94_sbox (uint32_t out[4][256], const uint8_t src[8][16])
&gt;&gt; Maybe this should be moved to a separate file gost-data, to generate the
&gt;&gt; tables during the build process?
&gt;
&gt; Is it really needed?

It's not absolutely necessary, but I think it's nice to include code for
generating various magic tables, like in aesdata.c, shadata.c,
gcmdata.c, etc. Even if it's not done consistently for *all* such
tables.

&gt; I was thinking to even remove the fill_gost94_sbox() function.

I don't think that function should be included in the built library.
But if we have a gostdata tool, it obviously belongs there.

&gt;&gt; Can you explain briefly what this gost94_sbox and gost94_sbox_cryptpro
&gt;&gt; is about? 
&gt;
&gt; I can only speculate on that because I'm not familiar with the standard.
&gt; However the gosthash is based on the gost encryption algorithm which had
&gt; no fixed sboxes. You could have different application areas of the
&gt; algorithm that used different sboxes.
&gt;
&gt; For my use-case the original sboxes are ok. I just kept the
&gt; additional ones. I could remove them.

If no one else comes up with a use case for the "cryptpro" sboxes, I
think we can leave them out for now.

&gt;&gt; treat them as two distinct hash functions (one could still share
&gt;&gt; internal functions like gost_block_compress, and pass appropriate sboxes
&gt;&gt; as an argument).
&gt;
&gt; That would deviate from the format of the other hash functions in nettle.

I was thinking that the adveertised interface would be gost_hash_* and
gost_hash_cryptpro_*, each following the same conventions as the other
hash functions. The shared gost_block_compress, with an sbox argument,
would either be purely internal, or a gost-specific piece of the
advertised interface.

&gt;&gt;&gt; +#undef GENERATE_GOST_LOOKUP_TABLE
&gt;&gt; I don't think GENERATE_GOST_LOOKUP_TABLE belongs in the header file.
&gt;
&gt; Why would it be better?

It seemed like an implementation detail to me (maybe that's not how it
was intended?). If it is needed at all, I think it belongs in config.h
or possibly nettle-internal.h or gost-internal.h.

&gt; The header uses this definition.

Only to make the prototype for gost_init_table conditional. But that
function can be declared unconditionally (if we want it at all).

&gt; btw. I've renamed the algorithm to gosthash94, to allow for a future
&gt; gost encryption algorithm.

I guess the "94" is the year. So a gost94 encryption algorithm is
already defained, from the same time? 

I should probably read RFC 5831 and any other relevant reference
material before asking more questions.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121005182605</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-10-05 18:26:05-0400</timestampReceived><subject>Re: gost hash</subject><body>

On 10/04/2012 09:46 PM, Niels Möller wrote:

&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt;&gt; Do you want me to contact him for clarification? However, I think that
&gt;&gt; the file's license overrides the library license.
&gt; 
&gt; It would be nice if the licensing were crystal clear, and I'd like to
&gt; have a correct description also in the copyright section of the manual.


Attached is an updated version of the patch. I have not yet contacted
the author.

regards,
Nikos


["0001-Added-GOST-R-34.11-94-hash-algorithm.patch" (text/x-patch)]

&gt;From 90d406211e263a50760b98adef25665dd45f4f26 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Tue, 25 Sep 2012 19:57:13 +0200
Subject: [PATCH] Added GOST R 34.11-94 hash algorithm.

---
 Makefile.in                 |    4 +-
 gosthash94-meta.c           |   32 ++++
 gosthash94-tables.c         |  225 ++++++++++++++++++++++++++
 gosthash94.c                |  373 +++++++++++++++++++++++++++++++++++++++++++
 gosthash94.h                |   45 ++++++
 nettle-meta.h               |    1 +
 testsuite/.test-rules.make  |    9 +-
 testsuite/Makefile.in       |    2 +-
 testsuite/gosthash94-test.c |   21 +++
 9 files changed, 707 insertions(+), 5 deletions(-)
 create mode 100644 gosthash94-meta.c
 create mode 100644 gosthash94-tables.c
 create mode 100644 gosthash94.c
 create mode 100644 gosthash94.h
 create mode 100644 testsuite/gosthash94-test.c

diff --git a/Makefile.in b/Makefile.in
index c0ca3ad..d4f0b42 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -64,7 +64,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 aes-encrypt-internal.c aes-encrypt.c aes-encrypt-table.c \
 		 aes-set-encrypt-key.c aes-set-decrypt-key.c aes-meta.c \
 		 arcfour.c arcfour-crypt.c arcfour-meta.c \
-		 arctwo.c arctwo-meta.c \
+		 arctwo.c arctwo-meta.c gosthash94-meta.c \
 		 base16-encode.c base16-decode.c base16-meta.c \
                  base64-encode.c base64-decode.c base64-meta.c \
 		 camellia-crypt.c camellia-crypt-internal.c \
@@ -81,6 +81,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 knuth-lfib.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
+		 gosthash94.c gosthash94-tables.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
 		 salsa20-core-internal.c \
 		 salsa20-crypt.c salsa20-set-key.c \
@@ -129,6 +130,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h bignum.h blowfish.h \
 	  knuth-lfib.h \
 	  macros.h \
 	  md2.h md4.h \
+	  gosthash94.h \
 	  md5.h md5-compat.h \
 	  memxor.h \
 	  nettle-meta.h nettle-types.h \
diff --git a/gosthash94-meta.c b/gosthash94-meta.c
new file mode 100644
index 0000000..3eb7be4
--- /dev/null
+++ b/gosthash94-meta.c
@@ -0,0 +1,32 @@
+/* gost3411-94-meta.c */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2002 Niels MÃ¶ller
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "gosthash94.h"
+
+const struct nettle_hash nettle_gosthash94
+= _NETTLE_HASH(gosthash94, GOSTHASH94);
diff --git a/gosthash94-tables.c b/gosthash94-tables.c
new file mode 100644
index 0000000..f65ac0d
--- /dev/null
+++ b/gosthash94-tables.c
@@ -0,0 +1,225 @@
+/* gost.c - an implementation of GOST Hash Function
+ * based on the Russian Standard GOST R 34.11-94.
+ * See also RFC 4357.
+ *
+ * Implementation written by Alexei Kravchenko.
+ * Ported to nettle by Nikos Mavrogiannopoulos.
+ *
+ * Copyleft:
+ * I hereby release this code into the public domain. This applies worldwide.
+ * I grant any entity the right to use this work for ANY PURPOSE,
+ * without any conditions, unless such conditions are required by law.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include &lt;string.h&gt;
+
+#include "macros.h"
+#include "gosthash94.h"
+
+/* pre-initialized GOST lookup tables based on rotated S-Box */
+const uint32_t gosthash94_sbox[4][256] = {
+  {
+    0x72000, 0x75000, 0x74800, 0x71000, 0x76800,
+    0x74000, 0x70000, 0x77000, 0x73000, 0x75800,
+    0x70800, 0x76000, 0x73800, 0x77800, 0x72800,
+    0x71800, 0x5A000, 0x5D000, 0x5C800, 0x59000,
+    0x5E800, 0x5C000, 0x58000, 0x5F000, 0x5B000,
+    0x5D800, 0x58800, 0x5E000, 0x5B800, 0x5F800,
+    0x5A800, 0x59800, 0x22000, 0x25000, 0x24800,
+    0x21000, 0x26800, 0x24000, 0x20000, 0x27000,
+    0x23000, 0x25800, 0x20800, 0x26000, 0x23800,
+    0x27800, 0x22800, 0x21800, 0x62000, 0x65000,
+    0x64800, 0x61000, 0x66800, 0x64000, 0x60000,
+    0x67000, 0x63000, 0x65800, 0x60800, 0x66000,
+    0x63800, 0x67800, 0x62800, 0x61800, 0x32000,
+    0x35000, 0x34800, 0x31000, 0x36800, 0x34000,
+    0x30000, 0x37000, 0x33000, 0x35800, 0x30800,
+    0x36000, 0x33800, 0x37800, 0x32800, 0x31800,
+    0x6A000, 0x6D000, 0x6C800, 0x69000, 0x6E800,
+    0x6C000, 0x68000, 0x6F000, 0x6B000, 0x6D800,
+    0x68800, 0x6E000, 0x6B800, 0x6F800, 0x6A800,
+    0x69800, 0x7A000, 0x7D000, 0x7C800, 0x79000,
+    0x7E800, 0x7C000, 0x78000, 0x7F000, 0x7B000,
+    0x7D800, 0x78800, 0x7E000, 0x7B800, 0x7F800,
+    0x7A800, 0x79800, 0x52000, 0x55000, 0x54800,
+    0x51000, 0x56800, 0x54000, 0x50000, 0x57000,
+    0x53000, 0x55800, 0x50800, 0x56000, 0x53800,
+    0x57800, 0x52800, 0x51800, 0x12000, 0x15000,
+    0x14800, 0x11000, 0x16800, 0x14000, 0x10000,
+    0x17000, 0x13000, 0x15800, 0x10800, 0x16000,
+    0x13800, 0x17800, 0x12800, 0x11800, 0x1A000,
+    0x1D000, 0x1C800, 0x19000, 0x1E800, 0x1C000,
+    0x18000, 0x1F000, 0x1B000, 0x1D800, 0x18800,
+    0x1E000, 0x1B800, 0x1F800, 0x1A800, 0x19800,
+    0x42000, 0x45000, 0x44800, 0x41000, 0x46800,
+    0x44000, 0x40000, 0x47000, 0x43000, 0x45800,
+    0x40800, 0x46000, 0x43800, 0x47800, 0x42800,
+    0x41800, 0xA000,  0xD000,  0xC800,  0x9000,
+    0xE800,  0xC000,  0x8000,  0xF000,  0xB000,
+    0xD800,  0x8800,  0xE000,  0xB800,  0xF800,
+    0xA800,  0x9800,  0x2000,  0x5000,  0x4800,
+    0x1000,  0x6800,  0x4000,  0x0,     0x7000,
+    0x3000,  0x5800,  0x800,   0x6000,  0x3800,
+    0x7800,  0x2800,  0x1800,  0x3A000, 0x3D000,
+    0x3C800, 0x39000, 0x3E800, 0x3C000, 0x38000,
+    0x3F000, 0x3B000, 0x3D800, 0x38800, 0x3E000,
+    0x3B800, 0x3F800, 0x3A800, 0x39800, 0x2A000,
+    0x2D000, 0x2C800, 0x29000, 0x2E800, 0x2C000,
+    0x28000, 0x2F000, 0x2B000, 0x2D800, 0x28800,
+    0x2E000, 0x2B800, 0x2F800, 0x2A800, 0x29800,
+    0x4A000, 0x4D000, 0x4C800, 0x49000, 0x4E800,
+    0x4C000, 0x48000, 0x4F000, 0x4B000, 0x4D800,
+    0x48800, 0x4E000, 0x4B800, 0x4F800, 0x4A800,
+    0x49800
+  }, {
+    0x3A80000, 0x3C00000, 0x3880000, 0x3E80000, 0x3D00000,
+    0x3980000, 0x3A00000, 0x3900000, 0x3F00000, 0x3F80000,
+    0x3E00000, 0x3B80000, 0x3B00000, 0x3800000, 0x3C80000,
+    0x3D80000, 0x6A80000, 0x6C00000, 0x6880000, 0x6E80000,
+    0x6D00000, 0x6980000, 0x6A00000, 0x6900000, 0x6F00000,
+    0x6F80000, 0x6E00000, 0x6B80000, 0x6B00000, 0x6800000,
+    0x6C80000, 0x6D80000, 0x5280000, 0x5400000, 0x5080000,
+    0x5680000, 0x5500000, 0x5180000, 0x5200000, 0x5100000,
+    0x5700000, 0x5780000, 0x5600000, 0x5380000, 0x5300000,
+    0x5000000, 0x5480000, 0x5580000, 0xA80000,  0xC00000,
+    0x880000,  0xE80000,  0xD00000,  0x980000,  0xA00000,
+    0x900000,  0xF00000,  0xF80000,  0xE00000,  0xB80000,
+    0xB00000,  0x800000,  0xC80000,  0xD80000,  0x280000,
+    0x400000,  0x80000,   0x680000,  0x500000,  0x180000,
+    0x200000,  0x100000,  0x700000,  0x780000,  0x600000,
+    0x380000,  0x300000,  0x0,       0x480000,  0x580000,
+    0x4280000, 0x4400000, 0x4080000, 0x4680000, 0x4500000,
+    0x4180000, 0x4200000, 0x4100000, 0x4700000, 0x4780000,
+    0x4600000, 0x4380000, 0x4300000, 0x4000000, 0x4480000,
+    0x4580000, 0x4A80000, 0x4C00000, 0x4880000, 0x4E80000,
+    0x4D00000, 0x4980000, 0x4A00000, 0x4900000, 0x4F00000,
+    0x4F80000, 0x4E00000, 0x4B80000, 0x4B00000, 0x4800000,
+    0x4C80000, 0x4D80000, 0x7A80000, 0x7C00000, 0x7880000,
+    0x7E80000, 0x7D00000, 0x7980000, 0x7A00000, 0x7900000,
+    0x7F00000, 0x7F80000, 0x7E00000, 0x7B80000, 0x7B00000,
+    0x7800000, 0x7C80000, 0x7D80000, 0x7280000, 0x7400000,
+    0x7080000, 0x7680000, 0x7500000, 0x7180000, 0x7200000,
+    0x7100000, 0x7700000, 0x7780000, 0x7600000, 0x7380000,
+    0x7300000, 0x7000000, 0x7480000, 0x7580000, 0x2280000,
+    0x2400000, 0x2080000, 0x2680000, 0x2500000, 0x2180000,
+    0x2200000, 0x2100000, 0x2700000, 0x2780000, 0x2600000,
+    0x2380000, 0x2300000, 0x2000000, 0x2480000, 0x2580000,
+    0x3280000, 0x3400000, 0x3080000, 0x3680000, 0x3500000,
+    0x3180000, 0x3200000, 0x3100000, 0x3700000, 0x3780000,
+    0x3600000, 0x3380000, 0x3300000, 0x3000000, 0x3480000,
+    0x3580000, 0x6280000, 0x6400000, 0x6080000, 0x6680000,
+    0x6500000, 0x6180000, 0x6200000, 0x6100000, 0x6700000,
+    0x6780000, 0x6600000, 0x6380000, 0x6300000, 0x6000000,
+    0x6480000, 0x6580000, 0x5A80000, 0x5C00000, 0x5880000,
+    0x5E80000, 0x5D00000, 0x5980000, 0x5A00000, 0x5900000,
+    0x5F00000, 0x5F80000, 0x5E00000, 0x5B80000, 0x5B00000,
+    0x5800000, 0x5C80000, 0x5D80000, 0x1280000, 0x1400000,
+    0x1080000, 0x1680000, 0x1500000, 0x1180000, 0x1200000,
+    0x1100000, 0x1700000, 0x1780000, 0x1600000, 0x1380000,
+    0x1300000, 0x1000000, 0x1480000, 0x1580000, 0x2A80000,
+    0x2C00000, 0x2880000, 0x2E80000, 0x2D00000, 0x2980000,
+    0x2A00000, 0x2900000, 0x2F00000, 0x2F80000, 0x2E00000,
+    0x2B80000, 0x2B00000, 0x2800000, 0x2C80000, 0x2D80000,
+    0x1A80000, 0x1C00000, 0x1880000, 0x1E80000, 0x1D00000,
+    0x1980000, 0x1A00000, 0x1900000, 0x1F00000, 0x1F80000,
+    0x1E00000, 0x1B80000, 0x1B00000, 0x1800000, 0x1C80000,
+    0x1D80000
+  }, {
+    0x30000002, 0x60000002, 0x38000002, 0x8000002,
+    0x28000002, 0x78000002, 0x68000002, 0x40000002, 
+    0x20000002, 0x50000002, 0x48000002, 0x70000002, 
+    0x2,        0x18000002, 0x58000002, 0x10000002, 
+    0xB0000005, 0xE0000005, 0xB8000005, 0x88000005,
+    0xA8000005, 0xF8000005, 0xE8000005, 0xC0000005,
+    0xA0000005, 0xD0000005, 0xC8000005, 0xF0000005, 
+    0x80000005, 0x98000005, 0xD8000005, 0x90000005, 
+    0x30000005, 0x60000005, 0x38000005, 0x8000005, 
+    0x28000005, 0x78000005, 0x68000005, 0x40000005,
+    0x20000005, 0x50000005, 0x48000005, 0x70000005, 
+    0x5,        0x18000005, 0x58000005, 0x10000005, 
+    0x30000000, 0x60000000, 0x38000000, 0x8000000, 
+    0x28000000, 0x78000000, 0x68000000, 0x40000000, 
+    0x20000000, 0x50000000, 0x48000000, 0x70000000,
+    0x0,        0x18000000, 0x58000000, 0x10000000, 
+    0xB0000003, 0xE0000003, 0xB8000003, 0x88000003, 
+    0xA8000003, 0xF8000003, 0xE8000003, 0xC0000003, 
+    0xA0000003, 0xD0000003, 0xC8000003, 0xF0000003, 
+    0x80000003, 0x98000003, 0xD8000003, 0x90000003,
+    0x30000001, 0x60000001, 0x38000001, 0x8000001,
+    0x28000001, 0x78000001, 0x68000001, 0x40000001, 
+    0x20000001, 0x50000001, 0x48000001, 0x70000001, 
+    0x1,        0x18000001, 0x58000001, 0x10000001, 
+    0xB0000000, 0xE0000000, 0xB8000000, 0x88000000,
+    0xA8000000, 0xF8000000, 0xE8000000, 0xC0000000,
+    0xA0000000, 0xD0000000, 0xC8000000, 0xF0000000, 
+    0x80000000, 0x98000000, 0xD8000000, 0x90000000, 
+    0xB0000006, 0xE0000006, 0xB8000006, 0x88000006, 
+    0xA8000006, 0xF8000006, 0xE8000006, 0xC0000006,
+    0xA0000006, 0xD0000006, 0xC8000006, 0xF0000006,
+    0x80000006, 0x98000006, 0xD8000006, 0x90000006, 
+    0xB0000001, 0xE0000001, 0xB8000001, 0x88000001, 
+    0xA8000001, 0xF8000001, 0xE8000001, 0xC0000001, 
+    0xA0000001, 0xD0000001, 0xC8000001, 0xF0000001,
+    0x80000001, 0x98000001, 0xD8000001, 0x90000001,
+    0x30000003, 0x60000003, 0x38000003, 0x8000003, 
+    0x28000003, 0x78000003, 0x68000003, 0x40000003, 
+    0x20000003, 0x50000003, 0x48000003, 0x70000003, 
+    0x3,        0x18000003, 0x58000003, 0x10000003,
+    0x30000004, 0x60000004, 0x38000004, 0x8000004,
+    0x28000004, 0x78000004, 0x68000004, 0x40000004, 
+    0x20000004, 0x50000004, 0x48000004, 0x70000004, 
+    0x4,        0x18000004, 0x58000004, 0x10000004, 
+    0xB0000002, 0xE0000002, 0xB8000002, 0x88000002,
+    0xA8000002, 0xF8000002, 0xE8000002, 0xC0000002,
+    0xA0000002, 0xD0000002, 0xC8000002, 0xF0000002, 
+    0x80000002, 0x98000002, 0xD8000002, 0x90000002, 
+    0xB0000004, 0xE0000004, 0xB8000004, 0x88000004, 
+    0xA8000004, 0xF8000004, 0xE8000004, 0xC0000004,
+    0xA0000004, 0xD0000004, 0xC8000004, 0xF0000004,
+    0x80000004, 0x98000004, 0xD8000004, 0x90000004, 
+    0x30000006, 0x60000006, 0x38000006, 0x8000006, 
+    0x28000006, 0x78000006, 0x68000006, 0x40000006, 
+    0x20000006, 0x50000006, 0x48000006, 0x70000006,
+    0x6,        0x18000006, 0x58000006, 0x10000006, 
+    0xB0000007, 0xE0000007, 0xB8000007, 0x88000007, 
+    0xA8000007, 0xF8000007, 0xE8000007, 0xC0000007, 
+    0xA0000007, 0xD0000007, 0xC8000007, 0xF0000007, 
+    0x80000007, 0x98000007, 0xD8000007, 0x90000007,
+    0x30000007, 0x60000007, 0x38000007, 0x8000007,
+    0x28000007, 0x78000007, 0x68000007, 0x40000007, 
+    0x20000007, 0x50000007, 0x48000007, 0x70000007, 
+    0x7,        0x18000007, 0x58000007, 0x10000007
+  }, {
+    0xE8,  0xD8,  0xA0,  0x88,  0x98,  0xF8,  0xA8,  0xC8,  0x80,  0xD0,
+    0xF0,  0xB8,  0xB0,  0xC0,  0x90,  0xE0,  0x7E8, 0x7D8, 0x7A0, 0x788,
+    0x798, 0x7F8, 0x7A8, 0x7C8, 0x780, 0x7D0, 0x7F0, 0x7B8, 0x7B0, 0x7C0,
+    0x790, 0x7E0, 0x6E8, 0x6D8, 0x6A0, 0x688, 0x698, 0x6F8, 0x6A8, 0x6C8,
+    0x680, 0x6D0, 0x6F0, 0x6B8, 0x6B0, 0x6C0, 0x690, 0x6E0, 0x68,  0x58,
+    0x20,  0x8,   0x18,  0x78,  0x28,   0x48,  0x0,   0x50,  0x70,  0x38,
+    0x30,  0x40,  0x10,  0x60,  0x2E8, 0x2D8, 0x2A0, 0x288, 0x298, 0x2F8,
+    0x2A8, 0x2C8, 0x280, 0x2D0, 0x2F0, 0x2B8, 0x2B0, 0x2C0, 0x290, 0x2E0,
+    0x3E8, 0x3D8, 0x3A0, 0x388, 0x398, 0x3F8, 0x3A8, 0x3C8, 0x380, 0x3D0,
+    0x3F0, 0x3B8, 0x3B0, 0x3C0, 0x390, 0x3E0, 0x568, 0x558, 0x520, 0x508,
+    0x518, 0x578, 0x528, 0x548, 0x500, 0x550, 0x570, 0x538, 0x530, 0x540,
+    0x510, 0x560, 0x268, 0x258, 0x220, 0x208, 0x218, 0x278, 0x228, 0x248,
+    0x200, 0x250, 0x270, 0x238, 0x230, 0x240, 0x210, 0x260, 0x4E8, 0x4D8,
+    0x4A0, 0x488, 0x498, 0x4F8, 0x4A8, 0x4C8, 0x480, 0x4D0, 0x4F0, 0x4B8,
+    0x4B0, 0x4C0, 0x490, 0x4E0, 0x168, 0x158, 0x120, 0x108, 0x118, 0x178,
+    0x128, 0x148, 0x100, 0x150, 0x170, 0x138, 0x130, 0x140, 0x110, 0x160,
+    0x1E8, 0x1D8, 0x1A0, 0x188, 0x198, 0x1F8, 0x1A8, 0x1C8, 0x180, 0x1D0,
+    0x1F0, 0x1B8, 0x1B0, 0x1C0, 0x190, 0x1E0, 0x768, 0x758, 0x720, 0x708,
+    0x718, 0x778, 0x728, 0x748, 0x700, 0x750, 0x770, 0x738, 0x730, 0x740,
+    0x710, 0x760, 0x368, 0x358, 0x320, 0x308, 0x318, 0x378, 0x328, 0x348,
+    0x300, 0x350, 0x370, 0x338, 0x330, 0x340, 0x310, 0x360, 0x5E8, 0x5D8,
+    0x5A0, 0x588, 0x598, 0x5F8, 0x5A8, 0x5C8, 0x580, 0x5D0, 0x5F0, 0x5B8,
+    0x5B0, 0x5C0, 0x590, 0x5E0, 0x468, 0x458, 0x420, 0x408, 0x418, 0x478,
+    0x428, 0x448, 0x400, 0x450, 0x470, 0x438, 0x430, 0x440, 0x410, 0x460,
+    0x668, 0x658, 0x620, 0x608, 0x618, 0x678, 0x628, 0x648, 0x600, 0x650,
+    0x670, 0x638, 0x630, 0x640, 0x610, 0x660
+  }
+};
+
diff --git a/gosthash94.c b/gosthash94.c
new file mode 100644
index 0000000..cf20342
--- /dev/null
+++ b/gosthash94.c
@@ -0,0 +1,373 @@
+/* gost.c - an implementation of GOST Hash Function
+ * based on the Russian Standard GOST R 34.11-94.
+ * See also RFC 4357.
+ *
+ * Implementation written by Alexei Kravchenko.
+ * Ported to nettle by Nikos Mavrogiannopoulos.
+ *
+ * Copyleft:
+ * I hereby release this code into the public domain. This applies worldwide.
+ * I grant any entity the right to use this work for ANY PURPOSE,
+ * without any conditions, unless such conditions are required by law.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "macros.h"
+#include "nettle-write.h"
+#include "gosthash94.h"
+
+extern uint32_t gosthash94_sbox[4][256];
+
+/**
+ * Initialize algorithm context before calculating hash
+ * with test parameters set.
+ *
+ * @param ctx context to initalize
+ */
+void
+gosthash94_init (gosthash94_ctx * ctx)
+{
+    memset (ctx, 0, sizeof (gosthash94_ctx));
+}
+
+/*
+ *  A macro that performs a full encryption round of GOST 28147-89.
+ *  Temporary variables tmp assumed and variables r and l for left and right
+ *  blocks.
+ */
+#define GOST_ENCRYPT_ROUND(key1, key2, sbox) \
+  tmp = (key1) + r; \
+  l ^= (sbox)[tmp &amp; 0xff] ^ ((sbox)+256)[(tmp &gt;&gt; 8) &amp; 0xff] ^ \
+    ((sbox)+512)[(tmp &gt;&gt; 16) &amp; 0xff] ^ ((sbox)+768)[tmp &gt;&gt; 24]; \
+  tmp = (key2) + l; \
+  r ^= (sbox)[tmp &amp; 0xff] ^ ((sbox)+256)[(tmp &gt;&gt; 8) &amp; 0xff] ^ \
+    ((sbox)+512)[(tmp &gt;&gt; 16) &amp; 0xff] ^ ((sbox)+768)[tmp &gt;&gt; 24];
+
+/* encrypt a block with the given key */
+#define GOST_ENCRYPT(result, i, key, hash, sbox) \
+  r = hash[i], l = hash[i + 1]; \
+  GOST_ENCRYPT_ROUND(key[0], key[1], sbox) \
+  GOST_ENCRYPT_ROUND(key[2], key[3], sbox) \
+  GOST_ENCRYPT_ROUND(key[4], key[5], sbox) \
+  GOST_ENCRYPT_ROUND(key[6], key[7], sbox) \
+  GOST_ENCRYPT_ROUND(key[0], key[1], sbox) \
+  GOST_ENCRYPT_ROUND(key[2], key[3], sbox) \
+  GOST_ENCRYPT_ROUND(key[4], key[5], sbox) \
+  GOST_ENCRYPT_ROUND(key[6], key[7], sbox) \
+  GOST_ENCRYPT_ROUND(key[0], key[1], sbox) \
+  GOST_ENCRYPT_ROUND(key[2], key[3], sbox) \
+  GOST_ENCRYPT_ROUND(key[4], key[5], sbox) \
+  GOST_ENCRYPT_ROUND(key[6], key[7], sbox) \
+  GOST_ENCRYPT_ROUND(key[7], key[6], sbox) \
+  GOST_ENCRYPT_ROUND(key[5], key[4], sbox) \
+  GOST_ENCRYPT_ROUND(key[3], key[2], sbox) \
+  GOST_ENCRYPT_ROUND(key[1], key[0], sbox) \
+  result[i] = l, result[i + 1] = r;
+
+/**
+ * The core transformation. Process a 512-bit block.
+ *
+ * @param hash intermediate message hash
+ * @param block the message block to process
+ */
+static void
+gost_block_compress (gosthash94_ctx * ctx, const uint32_t *block)
+{
+    unsigned i;
+    uint32_t key[8], u[8], v[8], w[8], s[8];
+    uint32_t l, r, tmp;
+
+    /* u := hash, v := &lt;256-bit message block&gt; */
+    memcpy (u, ctx-&gt;hash, sizeof (u));
+    memcpy (v, block, sizeof (v));
+
+    /* w := u xor v */
+    w[0] = u[0] ^ v[0], w[1] = u[1] ^ v[1];
+    w[2] = u[2] ^ v[2], w[3] = u[3] ^ v[3];
+    w[4] = u[4] ^ v[4], w[5] = u[5] ^ v[5];
+    w[6] = u[6] ^ v[6], w[7] = u[7] ^ v[7];
+
+    /* calculate keys, encrypt hash and store result to the s[] array */
+    for (i = 0;; i += 2)
+      {
+          /* key generation: key_i := P(w) */
+          key[0] =
+              (w[0] &amp; 0x000000ff) | ((w[2] &amp; 0x000000ff) &lt;&lt; 8) |
+              ((w[4] &amp; 0x000000ff) &lt;&lt; 16) | ((w[6] &amp; 0x000000ff) &lt;&lt; 24);
+          key[1] =
+              ((w[0] &amp; 0x0000ff00) &gt;&gt; 8) | (w[2] &amp; 0x0000ff00) |
+              ((w[4] &amp; 0x0000ff00) &lt;&lt; 8) | ((w[6] &amp; 0x0000ff00) &lt;&lt; 16);
+          key[2] =
+              ((w[0] &amp; 0x00ff0000) &gt;&gt; 16) | ((w[2] &amp; 0x00ff0000) &gt;&gt; 8) |
+              (w[4] &amp; 0x00ff0000) | ((w[6] &amp; 0x00ff0000) &lt;&lt; 8);
+          key[3] =
+              ((w[0] &amp; 0xff000000) &gt;&gt; 24) | ((w[2] &amp; 0xff000000) &gt;&gt; 16) |
+              ((w[4] &amp; 0xff000000) &gt;&gt; 8) | (w[6] &amp; 0xff000000);
+          key[4] =
+              (w[1] &amp; 0x000000ff) | ((w[3] &amp; 0x000000ff) &lt;&lt; 8) |
+              ((w[5] &amp; 0x000000ff) &lt;&lt; 16) | ((w[7] &amp; 0x000000ff) &lt;&lt; 24);
+          key[5] =
+              ((w[1] &amp; 0x0000ff00) &gt;&gt; 8) | (w[3] &amp; 0x0000ff00) |
+              ((w[5] &amp; 0x0000ff00) &lt;&lt; 8) | ((w[7] &amp; 0x0000ff00) &lt;&lt; 16);
+          key[6] =
+              ((w[1] &amp; 0x00ff0000) &gt;&gt; 16) | ((w[3] &amp; 0x00ff0000) &gt;&gt; 8) |
+              (w[5] &amp; 0x00ff0000) | ((w[7] &amp; 0x00ff0000) &lt;&lt; 8);
+          key[7] =
+              ((w[1] &amp; 0xff000000) &gt;&gt; 24) | ((w[3] &amp; 0xff000000) &gt;&gt; 16) |
+              ((w[5] &amp; 0xff000000) &gt;&gt; 8) | (w[7] &amp; 0xff000000);
+
+          /* encryption: s_i := E_{key_i} (h_i) */
+          GOST_ENCRYPT (s, i, key, ctx-&gt;hash, (uint32_t*)gosthash94_sbox);
+
+          if (i == 0)
+            {
+                /* w:= A(u) ^ A^2(v) */
+                w[0] = u[2] ^ v[4], w[1] = u[3] ^ v[5];
+                w[2] = u[4] ^ v[6], w[3] = u[5] ^ v[7];
+                w[4] = u[6] ^ (v[0] ^= v[2]);
+                w[5] = u[7] ^ (v[1] ^= v[3]);
+                w[6] = (u[0] ^= u[2]) ^ (v[2] ^= v[4]);
+                w[7] = (u[1] ^= u[3]) ^ (v[3] ^= v[5]);
+            }
+          else if ((i &amp; 2) != 0)
+            {
+                if (i == 6)
+                    break;
+
+                /* w := A^2(u) xor A^4(v) xor C_3; u := A(u) xor C_3 */
+                /* C_3=0xff00ffff000000ffff0000ff00ffff0000ff00ff00ff00ffff00ff00ff00ff00 */
+                u[2] ^= u[4] ^ 0x000000ff;
+                u[3] ^= u[5] ^ 0xff00ffff;
+                u[4] ^= 0xff00ff00;
+                u[5] ^= 0xff00ff00;
+                u[6] ^= 0x00ff00ff;
+                u[7] ^= 0x00ff00ff;
+                u[0] ^= 0x00ffff00;
+                u[1] ^= 0xff0000ff;
+
+                w[0] = u[4] ^ v[0];
+                w[2] = u[6] ^ v[2];
+                w[4] = u[0] ^ (v[4] ^= v[6]);
+                w[6] = u[2] ^ (v[6] ^= v[0]);
+                w[1] = u[5] ^ v[1];
+                w[3] = u[7] ^ v[3];
+                w[5] = u[1] ^ (v[5] ^= v[7]);
+                w[7] = u[3] ^ (v[7] ^= v[1]);
+            }
+          else
+            {
+                /* i==4 here */
+                /* w:= A( A^2(u) xor C_3 ) xor A^6(v) */
+                w[0] = u[6] ^ v[4], w[1] = u[7] ^ v[5];
+                w[2] = u[0] ^ v[6], w[3] = u[1] ^ v[7];
+                w[4] = u[2] ^ (v[0] ^= v[2]);
+                w[5] = u[3] ^ (v[1] ^= v[3]);
+                w[6] = (u[4] ^= u[6]) ^ (v[2] ^= v[4]);
+                w[7] = (u[5] ^= u[7]) ^ (v[3] ^= v[5]);
+            }
+      }
+
+    /* step hash function: x(block, hash) := psi^61(hash xor psi(block xor psi^12(S))) */
+
+    /* 12 rounds of the LFSR and xor in &lt;message block&gt; */
+    u[0] = block[0] ^ s[6];
+    u[1] = block[1] ^ s[7];
+    u[2] =
+        block[2] ^ (s[0] &lt;&lt; 16) ^ (s[0] &gt;&gt; 16) ^ (s[0] &amp; 0xffff) ^ (s[1] &amp;
+                                                                    0xffff)
+        ^ (s[1] &gt;&gt; 16) ^ (s[2] &lt;&lt; 16) ^ s[6] ^ (s[6] &lt;&lt; 16) ^ (s[7] &amp;
+                                                               0xffff0000)
+        ^ (s[7] &gt;&gt; 16);
+    u[3] =
+        block[3] ^ (s[0] &amp; 0xffff) ^ (s[0] &lt;&lt; 16) ^ (s[1] &amp; 0xffff) ^ (s[1]
+                                                                       &lt;&lt;
+                                                                       16)
+        ^ (s[1] &gt;&gt; 16) ^ (s[2] &lt;&lt; 16) ^ (s[2] &gt;&gt; 16) ^ (s[3] &lt;&lt; 16) ^ s[6]
+        ^ (s[6] &lt;&lt; 16) ^ (s[6] &gt;&gt; 16) ^ (s[7] &amp; 0xffff) ^ (s[7] &lt;&lt; 16) ^
+        (s[7] &gt;&gt; 16);
+    u[4] =
+        block[4] ^ (s[0] &amp; 0xffff0000) ^ (s[0] &lt;&lt; 16) ^ (s[0] &gt;&gt; 16) ^
+        (s[1] &amp; 0xffff0000) ^ (s[1] &gt;&gt; 16) ^ (s[2] &lt;&lt; 16) ^ (s[2] &gt;&gt; 16) ^
+        (s[3] &lt;&lt; 16) ^ (s[3] &gt;&gt; 16) ^ (s[4] &lt;&lt; 16) ^ (s[6] &lt;&lt; 16) ^ (s[6]
+                                                                     &gt;&gt; 16)
+        ^ (s[7] &amp; 0xffff) ^ (s[7] &lt;&lt; 16) ^ (s[7] &gt;&gt; 16);
+    u[5] =
+        block[5] ^ (s[0] &lt;&lt; 16) ^ (s[0] &gt;&gt; 16) ^ (s[0] &amp; 0xffff0000) ^
+        (s[1] &amp; 0xffff) ^ s[2] ^ (s[2] &gt;&gt; 16) ^ (s[3] &lt;&lt; 16) ^ (s[3] &gt;&gt; 16)
+        ^ (s[4] &lt;&lt; 16) ^ (s[4] &gt;&gt; 16) ^ (s[5] &lt;&lt; 16) ^ (s[6] &lt;&lt; 16) ^ (s[6]
+                                                                       &gt;&gt;
+                                                                       16)
+        ^ (s[7] &amp; 0xffff0000) ^ (s[7] &lt;&lt; 16) ^ (s[7] &gt;&gt; 16);
+    u[6] =
+        block[6] ^ s[0] ^ (s[1] &gt;&gt; 16) ^ (s[2] &lt;&lt; 16) ^ s[3] ^ (s[3] &gt;&gt; 16)
+        ^ (s[4] &lt;&lt; 16) ^ (s[4] &gt;&gt; 16) ^ (s[5] &lt;&lt; 16) ^ (s[5] &gt;&gt; 16) ^ s[6]
+        ^ (s[6] &lt;&lt; 16) ^ (s[6] &gt;&gt; 16) ^ (s[7] &lt;&lt; 16);
+    u[7] =
+        block[7] ^ (s[0] &amp; 0xffff0000) ^ (s[0] &lt;&lt; 16) ^ (s[1] &amp; 0xffff) ^
+        (s[1] &lt;&lt; 16) ^ (s[2] &gt;&gt; 16) ^ (s[3] &lt;&lt; 16) ^ s[4] ^ (s[4] &gt;&gt; 16) ^
+        (s[5] &lt;&lt; 16) ^ (s[5] &gt;&gt; 16) ^ (s[6] &gt;&gt; 16) ^ (s[7] &amp; 0xffff) ^
+        (s[7] &lt;&lt; 16) ^ (s[7] &gt;&gt; 16);
+
+    /* 1 round of the LFSR (a mixing transformation) and xor with &lt;hash&gt; */
+    v[0] = ctx-&gt;hash[0] ^ (u[1] &lt;&lt; 16) ^ (u[0] &gt;&gt; 16);
+    v[1] = ctx-&gt;hash[1] ^ (u[2] &lt;&lt; 16) ^ (u[1] &gt;&gt; 16);
+    v[2] = ctx-&gt;hash[2] ^ (u[3] &lt;&lt; 16) ^ (u[2] &gt;&gt; 16);
+    v[3] = ctx-&gt;hash[3] ^ (u[4] &lt;&lt; 16) ^ (u[3] &gt;&gt; 16);
+    v[4] = ctx-&gt;hash[4] ^ (u[5] &lt;&lt; 16) ^ (u[4] &gt;&gt; 16);
+    v[5] = ctx-&gt;hash[5] ^ (u[6] &lt;&lt; 16) ^ (u[5] &gt;&gt; 16);
+    v[6] = ctx-&gt;hash[6] ^ (u[7] &lt;&lt; 16) ^ (u[6] &gt;&gt; 16);
+    v[7] =
+        ctx-&gt;
+        hash[7] ^ (u[0] &amp; 0xffff0000) ^ (u[0] &lt;&lt; 16) ^ (u[1] &amp; 0xffff0000)
+        ^ (u[1] &lt;&lt; 16) ^ (u[6] &lt;&lt; 16) ^ (u[7] &amp; 0xffff0000) ^ (u[7] &gt;&gt; 16);
+
+    /* 61 rounds of LFSR, mixing up hash */
+    ctx-&gt;hash[0] = (v[0] &amp; 0xffff0000) ^ (v[0] &lt;&lt; 16) ^ (v[0] &gt;&gt; 16) ^
+        (v[1] &gt;&gt; 16) ^ (v[1] &amp; 0xffff0000) ^ (v[2] &lt;&lt; 16) ^
+        (v[3] &gt;&gt; 16) ^ (v[4] &lt;&lt; 16) ^ (v[5] &gt;&gt; 16) ^ v[5] ^
+        (v[6] &gt;&gt; 16) ^ (v[7] &lt;&lt; 16) ^ (v[7] &gt;&gt; 16) ^ (v[7] &amp; 0xffff);
+    ctx-&gt;hash[1] = (v[0] &lt;&lt; 16) ^ (v[0] &gt;&gt; 16) ^ (v[0] &amp; 0xffff0000) ^
+        (v[1] &amp; 0xffff) ^ v[2] ^ (v[2] &gt;&gt; 16) ^ (v[3] &lt;&lt; 16) ^
+        (v[4] &gt;&gt; 16) ^ (v[5] &lt;&lt; 16) ^ (v[6] &lt;&lt; 16) ^ v[6] ^
+        (v[7] &amp; 0xffff0000) ^ (v[7] &gt;&gt; 16);
+    ctx-&gt;hash[2] = (v[0] &amp; 0xffff) ^ (v[0] &lt;&lt; 16) ^ (v[1] &lt;&lt; 16) ^
+        (v[1] &gt;&gt; 16) ^ (v[1] &amp; 0xffff0000) ^ (v[2] &lt;&lt; 16) ^ (v[3] &gt;&gt; 16) ^
+        v[3] ^ (v[4] &lt;&lt; 16) ^ (v[5] &gt;&gt; 16) ^ v[6] ^ (v[6] &gt;&gt; 16) ^
+        (v[7] &amp; 0xffff) ^ (v[7] &lt;&lt; 16) ^ (v[7] &gt;&gt; 16);
+    ctx-&gt;hash[3] = (v[0] &lt;&lt; 16) ^ (v[0] &gt;&gt; 16) ^ (v[0] &amp; 0xffff0000) ^
+        (v[1] &amp; 0xffff0000) ^ (v[1] &gt;&gt; 16) ^ (v[2] &lt;&lt; 16) ^
+        (v[2] &gt;&gt; 16) ^ v[2] ^ (v[3] &lt;&lt; 16) ^ (v[4] &gt;&gt; 16) ^ v[4] ^
+        (v[5] &lt;&lt; 16) ^ (v[6] &lt;&lt; 16) ^ (v[7] &amp; 0xffff) ^ (v[7] &gt;&gt; 16);
+    ctx-&gt;hash[4] =
+        (v[0] &gt;&gt; 16) ^ (v[1] &lt;&lt; 16) ^ v[1] ^ (v[2] &gt;&gt; 16) ^ v[2] ^ (v[3] &lt;&lt;
+                                                                    16) ^
+        (v[3] &gt;&gt; 16) ^ v[3] ^ (v[4] &lt;&lt; 16) ^ (v[5] &gt;&gt; 16) ^ v[5] ^ (v[6] &lt;&lt;
+                                                                    16) ^
+        (v[6] &gt;&gt; 16) ^ (v[7] &lt;&lt; 16);
+    ctx-&gt;hash[5] =
+        (v[0] &lt;&lt; 16) ^ (v[0] &amp; 0xffff0000) ^ (v[1] &lt;&lt; 16) ^ (v[1] &gt;&gt; 16) ^
+        (v[1] &amp; 0xffff0000) ^ (v[2] &lt;&lt; 16) ^ v[2] ^ (v[3] &gt;&gt; 16) ^ v[3] ^
+        (v[4] &lt;&lt; 16) ^ (v[4] &gt;&gt; 16) ^ v[4] ^ (v[5] &lt;&lt; 16) ^ (v[6] &lt;&lt; 16) ^
+        (v[6] &gt;&gt; 16) ^ v[6] ^ (v[7] &lt;&lt; 16) ^ (v[7] &gt;&gt; 16) ^ (v[7] &amp;
+                                                             0xffff0000);
+    ctx-&gt;hash[6] =
+        v[0] ^ v[2] ^ (v[2] &gt;&gt; 16) ^ v[3] ^ (v[3] &lt;&lt; 16) ^ v[4] ^ (v[4] &gt;&gt;
+                                                                   16) ^
+        (v[5] &lt;&lt; 16) ^ (v[5] &gt;&gt; 16) ^ v[5] ^ (v[6] &lt;&lt; 16) ^ (v[6] &gt;&gt; 16) ^
+        v[6] ^ (v[7] &lt;&lt; 16) ^ v[7];
+    ctx-&gt;hash[7] =
+        v[0] ^ (v[0] &gt;&gt; 16) ^ (v[1] &lt;&lt; 16) ^ (v[1] &gt;&gt; 16) ^ (v[2] &lt;&lt; 16) ^
+        (v[3] &gt;&gt; 16) ^ v[3] ^ (v[4] &lt;&lt; 16) ^ v[4] ^ (v[5] &gt;&gt; 16) ^ v[5] ^
+        (v[6] &lt;&lt; 16) ^ (v[6] &gt;&gt; 16) ^ (v[7] &lt;&lt; 16) ^ v[7];
+}
+
+/**
+ * This function calculates hash value by 256-bit blocks.
+ * It updates 256-bit check sum as follows:
+ *    *(uint256_t)(ctx-&gt;sum) += *(uint256_t*)block;
+ * and then updates intermediate hash value ctx-&gt;hash 
+ * by calling gost_block_compress().
+ *
+ * @param ctx algorithm context
+ * @param block the 256-bit message block to process
+ */
+static void
+gost_compute_sum_and_hash (gosthash94_ctx * ctx, const uint8_t *block)
+{
+    uint32_t block_le[8];
+    unsigned i, carry = 0;
+    uint32_t old;
+
+    /* compute the 256-bit sum */
+    for (i = 0; i &lt; 8; i++)
+      {
+          old = ctx-&gt;sum[i];
+          block_le[i] = LE_READ_UINT32(block);
+          ctx-&gt;sum[i] += block_le[i] + carry;
+          carry = (ctx-&gt;sum[i] &lt; old || ctx-&gt;sum[i] &lt; block_le[i] ? 1 : 0);
+          block += 4;
+      }
+
+    /* update message hash */
+    gost_block_compress (ctx, block_le);
+}
+
+/**
+ * Calculate message hash.
+ * Can be called repeatedly with chunks of the message to be hashed.
+ *
+ * @param ctx the algorithm context containing current hashing state
+ * @param msg message chunk
+ * @param size length of the message chunk
+ */
+void
+gosthash94_update (gosthash94_ctx * ctx, unsigned length, const uint8_t *msg)
+{
+    unsigned index = (unsigned) ctx-&gt;length &amp; 31;
+    ctx-&gt;length += length;
+
+    /* fill partial block */
+    if (index)
+      {
+          unsigned left = GOSTHASH94_DATA_SIZE - index;
+          memcpy (ctx-&gt;message + index, msg, (length &lt; left ? length : left));
+          if (length &lt; left)
+              return;
+
+          /* process partial block */
+          gost_compute_sum_and_hash (ctx, ctx-&gt;message);
+          msg += left;
+          length -= left;
+      }
+    while (length &gt;= GOSTHASH94_DATA_SIZE)
+      {
+          gost_compute_sum_and_hash (ctx, msg);
+          msg += GOSTHASH94_DATA_SIZE;
+          length -= GOSTHASH94_DATA_SIZE;
+      }
+    if (length)
+      {
+          /* save leftovers */
+          memcpy (ctx-&gt;message, msg, length);
+      }
+}
+
+/**
+ * Finish hashing and store message digest into given array.
+ *
+ * @param ctx the algorithm context containing current hashing state
+ * @param result calculated hash in binary form
+ */
+void
+gosthash94_digest (gosthash94_ctx * ctx, unsigned length, uint8_t *result)
+{
+    unsigned index = ctx-&gt;length &amp; 31;
+    uint32_t *msg32 = (uint32_t*)ctx-&gt;message;
+
+    assert(length &lt;= GOSTHASH94_DIGEST_SIZE);
+
+    /* pad the last block with zeroes and hash it */
+    if (index &gt; 0)
+      {
+          memset (ctx-&gt;message + index, 0, 32 - index);
+          gost_compute_sum_and_hash (ctx, ctx-&gt;message);
+      }
+
+    /* hash the message length and the sum */
+    msg32[0] = (uint32_t) (ctx-&gt;length &lt;&lt; 3);
+    msg32[1] = (uint32_t) (ctx-&gt;length &gt;&gt; 29);
+    memset (msg32 + 2, 0, sizeof (uint32_t) * 6);
+
+    gost_block_compress (ctx, msg32);
+    gost_block_compress (ctx, ctx-&gt;sum);
+
+    /* convert hash state to result bytes */
+    _nettle_write_le32(length, result, ctx-&gt;hash);
+}
+
diff --git a/gosthash94.h b/gosthash94.h
new file mode 100644
index 0000000..168eba9
--- /dev/null
+++ b/gosthash94.h
@@ -0,0 +1,45 @@
+/* gosthash94.h
+ *
+ * The GOST R 34.11-94 hash function, described in RFC 5831.
+ */
+
+#ifndef NETTLE_GOST_H_INCLUDED
+#define NETTLE_GOST_H_INCLUDED
+
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define gosthash94_init nettle_gosthash94_init
+#define gosthash94_init2 nettle_gosthash94_init2
+#define gosthash94_init_table nettle_gosthash94_init_table
+#define gosthash94_update nettle_gosthash94_update
+#define gosthash94_digest nettle_gosthash94_digest
+
+#undef GENERATE_GOST_LOOKUP_TABLE
+
+#define GOSTHASH94_DATA_SIZE 32
+#define GOSTHASH94_DIGEST_SIZE 32
+
+/* algorithm context */
+typedef struct gosthash94_ctx
+{
+  uint32_t hash[8]; /* algorithm 256-bit state */
+  uint32_t sum[8];  /* sum of processed message blocks */
+  uint8_t message[GOSTHASH94_DATA_SIZE]; /* 256-bit buffer for leftovers */
+  uint64_t length;  /* number of processed bytes */
+} gosthash94_ctx;
+
+/* hash functions */
+
+void gosthash94_init(gosthash94_ctx *ctx);
+void gosthash94_update(gosthash94_ctx *ctx, unsigned length, const uint8_t* msg);
+void gosthash94_digest(gosthash94_ctx *ctx, unsigned length, uint8_t* result);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif /* __cplusplus */
+
+#endif /* NETTLE_GOST_H_INCLUDED */
diff --git a/nettle-meta.h b/nettle-meta.h
index c67d29a..f2dd2c6 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -158,6 +158,7 @@ extern const struct nettle_hash * const nettle_hashes[];
 extern const struct nettle_hash nettle_md2;
 extern const struct nettle_hash nettle_md4;
 extern const struct nettle_hash nettle_md5;
+extern const struct nettle_hash nettle_gosthash94;
 extern const struct nettle_hash nettle_ripemd160;
 extern const struct nettle_hash nettle_sha1;
 extern const struct nettle_hash nettle_sha224;
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index d8f8f23..5e6d712 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -46,6 +46,9 @@ md5-compat-test$(EXEEXT): md5-compat-test.$(OBJEXT)
 memxor-test$(EXEEXT): memxor-test.$(OBJEXT)
 	$(LINK) memxor-test.$(OBJEXT) $(TEST_OBJS) -o memxor-test$(EXEEXT)
 
+gosthash94-test$(EXEEXT): gosthash94-test.$(OBJEXT)
+	$(LINK) gosthash94-test.$(OBJEXT) $(TEST_OBJS) -o gosthash94-test$(EXEEXT)
+
 ripemd160-test$(EXEEXT): ripemd160-test.$(OBJEXT)
 	$(LINK) ripemd160-test.$(OBJEXT) $(TEST_OBJS) -o ripemd160-test$(EXEEXT)
 
@@ -88,9 +91,6 @@ gcm-test$(EXEEXT): gcm-test.$(OBJEXT)
 hmac-test$(EXEEXT): hmac-test.$(OBJEXT)
 	$(LINK) hmac-test.$(OBJEXT) $(TEST_OBJS) -o hmac-test$(EXEEXT)
 
-pbkdf2-test$(EXEEXT): pbkdf2-test.$(OBJEXT)
-	$(LINK) pbkdf2-test.$(OBJEXT) $(TEST_OBJS) -o pbkdf2-test$(EXEEXT)
-
 meta-hash-test$(EXEEXT): meta-hash-test.$(OBJEXT)
 	$(LINK) meta-hash-test.$(OBJEXT) $(TEST_OBJS) -o meta-hash-test$(EXEEXT)
 
@@ -106,6 +106,9 @@ buffer-test$(EXEEXT): buffer-test.$(OBJEXT)
 yarrow-test$(EXEEXT): yarrow-test.$(OBJEXT)
 	$(LINK) yarrow-test.$(OBJEXT) $(TEST_OBJS) -o yarrow-test$(EXEEXT)
 
+pbkdf2-test$(EXEEXT): pbkdf2-test.$(OBJEXT)
+	$(LINK) pbkdf2-test.$(OBJEXT) $(TEST_OBJS) -o pbkdf2-test$(EXEEXT)
+
 sexp-test$(EXEEXT): sexp-test.$(OBJEXT)
 	$(LINK) sexp-test.$(OBJEXT) $(TEST_OBJS) -o sexp-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 5559886..b98fea8 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -16,7 +16,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    camellia-test.c \
 		    des-test.c des3-test.c des-compat-test.c \
 		    md2-test.c md4-test.c md5-test.c md5-compat-test.c \
-		    memxor-test.c \
+		    memxor-test.c gosthash94-test.c \
 		    ripemd160-test.c \
 		    salsa20-test.c \
 		    sha1-test.c sha224-test.c sha256-test.c \
diff --git a/testsuite/gosthash94-test.c b/testsuite/gosthash94-test.c
new file mode 100644
index 0000000..00d5d25
--- /dev/null
+++ b/testsuite/gosthash94-test.c
@@ -0,0 +1,21 @@
+#include "testutils.h"
+#include "gosthash94.h"
+
+/* Using test vectors from Wikipedia article on GOST */
+
+void
+test_main(void)
+{
+  test_hash(&amp;nettle_gosthash94, SDATA("The quick brown fox jumps over the lazy dog"),
+	    SHEX("77b7fa410c9ac58a25f49bca7d0468c9296529315eaca76bd1a10f376d1f4294"));
+
+  test_hash(&amp;nettle_gosthash94, SDATA("message digest"),
+	    SHEX("ad4434ecb18f2c99b60cbe59ec3d2469582b65273f48de72db2fde16a4889a4d"));
+
+ test_hash(&amp;nettle_gosthash94, SDATA("a"),
+	    SHEX("d42c539e367c66e9c88a801f6649349c21871b4344c6a573f849fdce62f314dd"));
+
+ test_hash(&amp;nettle_gosthash94, SDATA(""),
+	    SHEX("ce85b99cc46752fffee35cab9a7b0278abb4c2d2055cff685af4912c49490f8d"));
+}
+
-- 
1.7.10.4



</body></email><email><emailId>20121028143839</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-10-28 14:38:39-0400</timestampReceived><subject>Re: gost hash</subject><body>

On 10/05/2012 08:26 PM, Nikos Mavrogiannopoulos wrote:

&gt;&gt; It would be nice if the licensing were crystal clear, and I'd like to
&gt;&gt; have a correct description also in the copyright section of the manual.
&gt; Attached is an updated version of the patch. I have not yet contacted
&gt; the author.


Hello,
 Any update on adding gost?


</body></email><email><emailId>20121104220406</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-04 22:04:06-0400</timestampReceived><subject>Re: gost hash</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Attached is an updated version of the patch.

&gt; +void
&gt; +gosthash94_digest (gosthash94_ctx * ctx, unsigned length, uint8_t *result)
&gt; +{
&gt; +    unsigned index = ctx-&gt;length &amp; 31;
&gt; +    uint32_t *msg32 = (uint32_t*)ctx-&gt;message;
&gt; +
&gt; +    assert(length &lt;= GOSTHASH94_DIGEST_SIZE);
&gt; +
&gt; +    /* pad the last block with zeroes and hash it */
&gt; +    if (index &gt; 0)
&gt; +      {
&gt; +          memset (ctx-&gt;message + index, 0, 32 - index);
&gt; +          gost_compute_sum_and_hash (ctx, ctx-&gt;message);
&gt; +      }
&gt; +
&gt; +    /* hash the message length and the sum */
&gt; +    msg32[0] = (uint32_t) (ctx-&gt;length &lt;&lt; 3);
&gt; +    msg32[1] = (uint32_t) (ctx-&gt;length &gt;&gt; 29);
&gt; +    memset (msg32 + 2, 0, sizeof (uint32_t) * 6);
&gt; +
&gt; +    gost_block_compress (ctx, msg32);
&gt; +    gost_block_compress (ctx, ctx-&gt;sum);
&gt; +
&gt; +    /* convert hash state to result bytes */
&gt; +    _nettle_write_le32(length, result, ctx-&gt;hash);
&gt; +}

Any good reason for reusing the ctx-&gt;message as msg32? The cast looks
dangerous, even if maybe it isn't (potentially it could have bad
alignment, but not with the current struct layout). I'd replace that
with a local array,

  uint32_t msg32[8];

Also, the _digest function should reset the state when it's done, in the
same way as _init. Which is easy, just call _init, or memset directly.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121105103021</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-11-05 10:30:21-0400</timestampReceived><subject>Re: gost hash</subject><body>

On Sun, Nov 4, 2012 at 11:04 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;&gt; Attached is an updated version of the patch.
&gt;
&gt;&gt; +void
&gt;&gt; +gosthash94_digest (gosthash94_ctx * ctx, unsigned length, uint8_t *result)
&gt;&gt; +{
&gt;&gt; +    unsigned index = ctx-&gt;length &amp; 31;
&gt;&gt; +    uint32_t *msg32 = (uint32_t*)ctx-&gt;message;
&gt;&gt; +
&gt;&gt; +    assert(length &lt;= GOSTHASH94_DIGEST_SIZE);
&gt;&gt; +
&gt;&gt; +    /* pad the last block with zeroes and hash it */
&gt;&gt; +    if (index &gt; 0)
&gt;&gt; +      {
&gt;&gt; +          memset (ctx-&gt;message + index, 0, 32 - index);
&gt;&gt; +          gost_compute_sum_and_hash (ctx, ctx-&gt;message);
&gt;&gt; +      }
&gt;&gt; +
&gt;&gt; +    /* hash the message length and the sum */
&gt;&gt; +    msg32[0] = (uint32_t) (ctx-&gt;length &lt;&lt; 3);
&gt;&gt; +    msg32[1] = (uint32_t) (ctx-&gt;length &gt;&gt; 29);
&gt;&gt; +    memset (msg32 + 2, 0, sizeof (uint32_t) * 6);
&gt;&gt; +
&gt;&gt; +    gost_block_compress (ctx, msg32);
&gt;&gt; +    gost_block_compress (ctx, ctx-&gt;sum);
&gt;&gt; +
&gt;&gt; +    /* convert hash state to result bytes */
&gt;&gt; +    _nettle_write_le32(length, result, ctx-&gt;hash);
&gt;&gt; +}
&gt;
&gt; Any good reason for reusing the ctx-&gt;message as msg32? The cast looks
&gt; dangerous, even if maybe it isn't (potentially it could have bad
&gt; alignment, but not with the current struct layout). I'd replace that
&gt; with a local array,
&gt;
&gt;   uint32_t msg32[8];

Hello,
 I remember I noticed that also, but postponed it for after I finished
the porting. It seems I forgot it then, or had some issue with the
change and abandoned it. I'll add it in my todo list, but if it is an
easy fix you may want to just update it.

&gt; Also, the _digest function should reset the state when it's done, in the
&gt; same way as _init. Which is easy, just call _init, or memset directly.

Added to.

regards,
Nikos

</body></email><email><emailId>20121105113433</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-05 11:34:33-0400</timestampReceived><subject>Re: gost hash</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I'll add it in my todo list, but if it is an
&gt; easy fix you may want to just update it.

I have it fixed in my working tree now (as well as _init at the end of
_digest, and fixes for the carry handling in gost_compute_sum_and_hash
(which I mailed Aleksey about and I hope he will comment on that), and
an MIT-style (c) notice).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121108212713</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-08 21:27:13-0400</timestampReceived><subject>Re: gost hash</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I have it fixed in my working tree now (as well as _init at the end of
&gt; _digest, and fixes for the carry handling in gost_compute_sum_and_hash
&gt; (which I mailed Aleksey about and I hope he will comment on that), and
&gt; an MIT-style (c) notice).

I've pushed the gost code to the repo now, with various smaller changes
compared to your patch. Please have a look, and tell me if I've missed
something. Some remaining things, in order of importance:

1. Documentation (manual and NEWS entry).

2. Support in nettle-benchmark.

3. I think it would be nice to include a program for generating the
   tables (could be based on the code in the first version of your
   patch). It's stil not clear to me if if/when alternative sboxes are
   used.

4. Maybe some reindentation and M-x whitespace-cleanup, for consistency.

BTW, with increasing number of hash functions, I think it would be nice
to add some more structure to the manual, and at least split it into
"recommended hash function" and "other/legacy hash functions". Not sure
which category to put gost in, though.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121110104510</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-11-10 10:45:10-0400</timestampReceived><subject>Re: gost hash</subject><body>

On 11/08/2012 10:27 PM, Niels Möller wrote:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt;&gt; I have it fixed in my working tree now (as well as _init at the end of
&gt;&gt; _digest, and fixes for the carry handling in gost_compute_sum_and_hash
&gt;&gt; (which I mailed Aleksey about and I hope he will comment on that), and
&gt;&gt; an MIT-style (c) notice).
&gt; 
&gt; I've pushed the gost code to the repo now, with various smaller changes
&gt; compared to your patch. Please have a look, and tell me if I've missed
&gt; something. Some remaining things, in order of importance:
&gt; 
&gt; 1. Documentation (manual and NEWS entry).


Attached. I have issues building the nettle documentation though. I get:
nettle.texinfo:744: Must be after `@deftypevr' to use `@deftypevrx'
nettle.texinfo:1469: Must be after `@deftypevr' to use `@deftypevrx'

&gt; 2. Support in nettle-benchmark.


I just added the gosthash struct. It seems to work.

&gt; 3. I think it would be nice to include a program for generating the
&gt;    tables (could be based on the code in the first version of your
&gt;    patch). It's stil not clear to me if if/when alternative sboxes are
&gt;    used.


Not done yet. I also don't know other applications with alternative sboxes.


&gt; BTW, with increasing number of hash functions, I think it would be nice
&gt; to add some more structure to the manual, and at least split it into
&gt; "recommended hash function" and "other/legacy hash functions". Not sure
&gt; which category to put gost in, though.


GOST should be in the legacy functions. It is considered broken (see
Cryptanalysis of the GOST Hash Function, a 2008 paper), but similarly to
SHA-1 attacks aren't practical yet.

regards,
Nikos

["0001-Added-documentation-on-gosthash94.patch" (text/x-patch)]

&gt; From ac219bb3002d7f1df46ec9b591cd050bbcd378a2 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Sat, 10 Nov 2012 11:35:06 +0100
Subject: [PATCH 1/3] Added documentation on gosthash94.

---
 nettle.texinfo |   43 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 43 insertions(+)

diff --git a/nettle.texinfo b/nettle.texinfo
index bfaf0a6..3d976a4 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -220,6 +220,11 @@ released under the LGPL.
 Written by @value{AUTHOR}, using Peter Gutmann's SHA1 code as a model. 
 Released under the LGPL.
 
+@item GOSTHASH94
+The C implementation of the GOST94 message digest is written by 
+Aleksey Kravchenko and was ported from the rhash library by Nikos
+Mavrogiannopoulos. It is released under the MIT license.
+
 @item TWOFISH
 The implementation of the TWOFISH cipher is written by Ruud de Rooij.
 Released under the LGPL.
@@ -711,6 +716,43 @@ This function also resets the context in the same way as
 @code{sha384_init}.
 @end deftypefun
 
+@subsection @acronym{GOSTHASH94}
+
+The GOST94 or GOST R 34.11-94 hash algorithm is a Soviet-era algorithm 
+used in Russian government standards (see @cite{RFC 4357}).
+It outputs message digests of 256 bits, or 32 octets.
+Nettle defines GOSTHASH94 in @file{&lt;nettle/gosthash94.h&gt;}.
+
+@deftp {Context struct} {struct gosthash94_ctx}
+@end deftp
+
+@defvr Constant GOSTHASH94_DIGEST_SIZE
+The size of an GOSTHASH94 digest, i.e. 32.
+@end defvr
+
+@defvr Constant GOSTHASH94_DATA_SIZE
+The internal block size of GOSTHASH94, i.e., 32.
+@end defvr
+
+@deftypefun void gosthash94_init (struct gosthash94_ctx *@var{ctx})
+Initialize the GOSTHASH94 state.
+@end deftypefun
+
+@deftypefun void gosthash94_update (struct gosthash94_ctx *@var{ctx}, unsigned \
@var{length}, const uint8_t *@var{data}) +Hash some more data.
+@end deftypefun
+
+@deftypefun void gosthash94_digest (struct gosthash94_ctx *@var{ctx}, unsigned \
@var{length}, uint8_t *@var{digest}) +Performs final processing and extracts the \
message digest, writing it +to @var{digest}. @var{length} may be smaller than
+@code{GOSTHASH94_DIGEST_SIZE}, in which case only the first @var{length}
+octets of the digest are written.
+
+This function also resets the context in the same way as
+@code{gosthash94_init}.
+@end deftypefun
+
+
 @subsection @code{struct nettle_hash}
 
 Nettle includes a struct including information about the supported hash
@@ -735,6 +777,7 @@ The last three attributes are function pointers, of types
 @deftypevrx {Constant Struct} {struct nettle_hash} nettle_sha256
 @deftypevrx {Constant Struct} {struct nettle_hash} nettle_sha384
 @deftypevrx {Constant Struct} {struct nettle_hash} nettle_sha512
+@deftypevrx {Constant Struct} {struct nettle_hash} nettle_gosthash94
 
 These are all the hash functions that Nettle implements.
 
-- 
1.7.10.4


["0002-Added-gosthash-to-benchmark.patch" (text/x-patch)]

&gt;From 26fdb04326abf7afc52678286e24c26f14fc3a94 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Sat, 10 Nov 2012 11:37:43 +0100
Subject: [PATCH 2/3] Added gosthash to benchmark.

---
 examples/nettle-benchmark.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index 7446fbc..d7f072a 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -651,7 +651,7 @@ main(int argc, char **argv)
       &amp;nettle_sha1, OPENSSL(&amp;nettle_openssl_sha1)
       &amp;nettle_sha224, &amp;nettle_sha256,
       &amp;nettle_sha384, &amp;nettle_sha512,
-      &amp;nettle_ripemd160,
+      &amp;nettle_ripemd160, &amp;nettle_gosthash94,
       NULL
     };
 
-- 
1.7.10.4


["0003-added-news-entry.patch" (text/x-patch)]

&gt;From ee818d8c61a45f734d7356b01b4c893c0e1871af Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Sat, 10 Nov 2012 11:40:07 +0100
Subject: [PATCH 3/3] added news entry.

---
 NEWS |    6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/NEWS b/NEWS
index dcb827b..35439e2 100644
--- a/NEWS
+++ b/NEWS
@@ -5,6 +5,12 @@ NEWS for the 2.6 release
 	* Support for PKCS #5 PBKDF2.  Contributed by Simon Josefsson.
           Specification in RFC 2898 and test vectors in RFC 6070.
 
+	* Support for GOST R 34.11-94 hash algorithm. Ported from librhash 
+	  by Nikos Mavrogiannopoulos. Written by Aleksey Kravchenko.
+	  More information in RFC4357. Test vectors taken from the GOST
+	  hash wikipedia page.
+          
+
 NEWS for the 2.5 release
 
 	This release includes important portability fixes for Windows
-- 
1.7.10.4



</body></email><email><emailId>20121110132234</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-10 13:22:34-0400</timestampReceived><subject>Re: gost hash</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I have issues building the nettle documentation though. I get:
&gt; nettle.texinfo:744: Must be after `@deftypevr' to use `@deftypevrx'
&gt; nettle.texinfo:1469: Must be after `@deftypevr' to use `@deftypevrx'

That's a bug in the markup. Will fix. I wonder why I don't see those
errors (or is it warnings?), maybe you are using a more recent makeinfo
than I? Mine is from texinfo 4.13.

I'll get back to the patches as soon as I can.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121110132626</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-11-10 13:26:26-0400</timestampReceived><subject>Re: gost hash</subject><body>

On 11/10/2012 02:22 PM, Niels Möller wrote:

&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt;&gt; I have issues building the nettle documentation though. I get:
&gt;&gt; nettle.texinfo:744: Must be after `@deftypevr' to use `@deftypevrx'
&gt;&gt; nettle.texinfo:1469: Must be after `@deftypevr' to use `@deftypevrx'
&gt; 
&gt; That's a bug in the markup. Will fix. I wonder why I don't see those
&gt; errors (or is it warnings?), maybe you are using a more recent makeinfo
&gt; than I? Mine is from texinfo 4.13.


They are errors in my version. I tried both the cvs version of texinfo
and 4.13.90.

regards,
Nikos

</body></email><email><emailId>20120913080911</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-13 08:09:11-0400</timestampReceived><subject>Re: Three tests can't be created</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; there are three tests which cannot be build from source:
&gt;
&gt; testsuite/sexp-conv-test
&gt; testsuite/symbols-test
&gt; testsuite/pkcs1-conv-test

Those test cases are shell scripts. Don't remove them. If they were
removed by make clean (but doesn't happen for me, at least), that's a
bug in the Makefile.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120703193530</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2012-07-03 19:35:30-0400</timestampReceived><subject>Re: Using alloca on windows</subject><body>


On Tue, 3 Jul 2012, Niels Möller wrote:

&gt; When I try cross-compiling using
&gt; 
&gt; ./configure '--host=i586-mingw32msvc'
&gt; 
&gt; I get warnings on alloca usage, e.g.,
&gt; 
&gt; /home/nisse/hack/nettle/cbc.c: In function `nettle_cbc_decrypt':
&gt; /home/nisse/hack/nettle/cbc.c:101: warning: implicit declaration of function \
&gt;                 `alloca'
&gt; /home/nisse/hack/nettle/cbc.c:101: warning: incompatible implicit declaration of \
&gt; built-in function `alloca' 
&gt; Which header should I include to get a proper declaration? In config.h,
&gt; I have some boilerplate code which includes malloc.h, but only if *not*
&gt; using gcc. Should I always include malloc.h if it exists, regardless of
&gt; the compiler used?

That sounds like a sane solution to me - if it exists, including it 
shouldn't hurt I guess.

// Martin



</body></email><email><emailId>20120620180324</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-06-20 18:03:24-0400</timestampReceived><subject>Re: Interface for new rsa features</subject><body>

On 06/19/2012 10:34 PM, Niels Möller wrote:

&gt; In recent months, some new RSA functions have been added, from
&gt; suggestions and work of Nikos. I'd like to hear comments on the
&gt; interface before release.
&gt; 
&gt; Do you think this looks good? I see that there's some inconsistency of
&gt; using "nettle_random_func random" vs "nettle_random_func *random", the
&gt; latter variant is the preferred form.


If this is because of me, feel free to correct it. It must have been a typo.

&gt; 3. Should I rename it to _pkcs1_signature_prefix, in order to (i) make
&gt;    it more clear it's an internal function, and (ii) make applications
&gt;    depending on the old behaviour break in a more predictable fashion?


I'd say this is a good option. If you care about backwards compatibility
then the old function could also be present.

regards,
Nikos

</body></email><email><emailId>20120406131218</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2012-04-06 13:12:18-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>


On 04/06/2012 08:39 AM, Nikos Mavrogiannopoulos wrote:
&gt;  Attached you'll find an initial patch that adds timing resistant
&gt; versions of rsa_compute_root() and rsa_decrypt().


No patch was attached to the version of the message i received from the
list.  Maybe try it again?

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20120406144617</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-04-06 14:46:17-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

On Fri, Apr 6, 2012 at 3:12 PM, Daniel Kahn Gillmor
&lt;dkg@fifthhorseman.net&gt; wrote:
&gt; No patch was attached to the version of the message i received from the
&gt; list.  Maybe try it again?

I can see it on my sent folder. Could it be that the list manager removed it?
I've put it at:
http://homes.esat.kuleuven.be/~nikos/0001-Added-timing-resistant-versions-of-rsa_compute_root-.patch

regards,
Nikos

</body></email><email><emailId>20120407084747</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-04-07 08:47:47-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I can see it on my sent folder. Could it be that the list manager removed it?

Possibly. The mailman config is known to be a bit picky (and I'm not
very good at configuring it), but I thought it would usually bounce
messages rather than silently remove attachments.

&gt; I've put it at:
&gt; http://homes.esat.kuleuven.be/~nikos/0001-Added-timing-resistant-versions-of-rsa_compute_root-.patch

Thanks! I've had a quick look. A few comments:

I'm not sure if the low-level rsa_compute_root should be aware of the
blinding, or if it should be the responsibility of its callers (using
_rsa_blind, _rsa_unblind helper functions, put in rsa_blind.c or so).

Support for blinding is desirable not only for rsa_decrypt, but also for
the various rsa_*_sign functions, right?

The blinding function should probably use nettle_mpz_random, which
provides for *almost* uniform distribution mod n by generating a few
extra bits before the mpz_fdiv_r.

As for interface, I have been considering to also add some kind of
deterministic dsa signatures, substituting something like HMAC(private
key, message) for the random input, and if possible, it would be nice to
have a consistent interface for {rsa, dsa} signatures {with, without}
randomness input.

Not sure if we should have separate functions for operation with and
without blidning, or a single function with an optional randomness
source as argument. If we have separate functions, we have to decide on
the name (I don't quite like "_timing": If the name is supposed to
describe intended use, it needs to be more verbose, maybe
"_timing_resistant". I think it may be more handy to rather describe
what it *does*, something like "_blinding" or "_randomized" or so).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120407093454</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-04-07 09:34:54-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

On 04/07/2012 10:47 AM, Niels Möller wrote:


&gt; Thanks! I've had a quick look. A few comments:
&gt; I'm not sure if the low-level rsa_compute_root should be aware of the
&gt; blinding, or if it should be the responsibility of its callers (using
&gt; _rsa_blind, _rsa_unblind helper functions, put in rsa_blind.c or so).


As a user of the library I'd prefer a low level function that provides
the algorithm operation in constant time, so that I don't need to
understand the details of blinding. It might be that in later version
nettle doesn't use blinding but something different to achieve constant
time, so it would be nice existing applications to change automatically.

&gt; Support for blinding is desirable not only for rsa_decrypt, but also for
&gt; the various rsa_*_sign functions, right?


Indeed. I changed rsa_compute_root() because I don't use the *_sign()
functions. They were not very flexible for my needs. I will try
updating making a constant time counterpart of them, but it  will expand
the interface considerably.

&gt; The blinding function should probably use nettle_mpz_random, which
&gt; provides for *almost* uniform distribution mod n by generating a few
&gt; extra bits before the mpz_fdiv_r.


I'll update it for that.

&gt; Not sure if we should have separate functions for operation with and
&gt; without blidning, or a single function with an optional randomness

&gt; source as argument. If we have separate functions, we have to decide on
&gt; the name (I don't quite like "_timing": If the name is supposed to

&gt; describe intended use, it needs to be more verbose, maybe

&gt; "_timing_resistant". I think it may be more handy to rather describe
&gt; what it *does*, something like "_blinding" or "_randomized" or so).


What about _ct for constant time? The _blinding is really specific
on the method used to achieve constant time.

regards,
Nikos

</body></email><email><emailId>20120407133016</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-04-07 13:30:16-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; What about _ct for constant time? The _blinding is really specific
&gt; on the method used to achieve constant time.

But it's not really constant time, is it? Rather, timing is random but
independent of the inputs which are under control of the attacker. While
without RSA blinding, timing depends on the secret key and on data
provided by the attacker, which is a bad combination.

The function mpz_powm_sec in recent GMP is supposed to really be
"constant time" (assuming the underlying multiply-instruction doesn't
have data-dependent timing). I.e., the instructions executed and the
memory access pattern should depend only on the sizes of the input
operands, not on the actual values. Hence it should be resistant both to
timing attacks, and attacks manipulating or observing the memory cache
hit rate.

But RSA operations uses a couple of additional functions, which doesn't
yet have constant-time counterparts, so I don't yet use that function
yet.

BTW, what's a good reference for the recommendation to use RSA blinding?
Is it in Handbook of applied cryptography? (I think pointers to papers
on attacks have been posted previously, but that's describing the
problem, not the solution...).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120407133807</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-04-07 13:38:07-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

lör 2012-04-07 klockan 15:30 +0200 skrev Niels Möller:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt; &gt; What about _ct for constant time? The _blinding is really specific
&gt; &gt; on the method used to achieve constant time.
&gt; 
&gt; But it's not really constant time, is it? Rather, timing is random but
&gt; independent of the inputs which are under control of the attacker. While
&gt; without RSA blinding, timing depends on the secret key and on data
&gt; provided by the attacker, which is a bad combination.

Maybe a better term to use is "reduced side channel" or something.  Not
easy to shorten though.  The generic problem adressed here is side
channels.

/Simon



</body></email><email><emailId>20120407155558</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-04-07 15:55:58-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

On 04/07/2012 03:30 PM, Niels Möller wrote:

&gt;&gt; What about _ct for constant time? The _blinding is really specific
&gt;&gt; on the method used to achieve constant time.
&gt; But it's not really constant time, is it? Rather, timing is random but
&gt; independent of the inputs which are under control of the attacker. While
&gt; without RSA blinding, timing depends on the secret key and on data
&gt; provided by the attacker, which is a bad combination.

Indeed. So is _timing_resistant or _tr better?

&gt; BTW, what's a good reference for the recommendation to use RSA blinding?
&gt; Is it in Handbook of applied cryptography? (I think pointers to papers
&gt; on attacks have been posted previously, but that's describing the
&gt; problem, not the solution...).


I've seen it there:
ftp://ftp.rsasecurity.com/pub/pdfs/bull-2.pdf

regards,
Nikos

</body></email><email><emailId>20120407182819</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-04-07 18:28:19-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

On 04/07/2012 10:47 AM, Niels Möller wrote:


&gt; I'm not sure if the low-level rsa_compute_root should be aware of the
&gt; blinding, or if it should be the responsibility of its callers (using
&gt; _rsa_blind, _rsa_unblind helper functions, put in rsa_blind.c or so).
&gt; 
&gt; Support for blinding is desirable not only for rsa_decrypt, but also for
&gt; the various rsa_*_sign functions, right?

&gt; The blinding function should probably use nettle_mpz_random, which

&gt; provides for *almost* uniform distribution mod n by generating a few

&gt; extra bits before the mpz_fdiv_r.

I've updated the patch to account for that and other issues.
http://homes.esat.kuleuven.be/~nikos/0001-Added-timing-resistant-versions-of-rsa_compute_root-.patch

What I haven't done is to duplicate all the rsa_(hash)_sign functions.
They are quite many and it doesn't make much sense duplicating all of
them. Do you have any suggestion on compacting it?


&gt; As for interface, I have been considering to also add some kind of
&gt; deterministic dsa signatures, substituting something like HMAC(private
&gt; key, message) for the random input, and if possible, it would be nice to
&gt; have a consistent interface for {rsa, dsa} signatures {with, without}
&gt; randomness input.


I don't really think that the random number in DSA relates to RSA
blinding. The random number in DSA is part of the signature scheme,
while the RSA blinding random number is just to prevent timing attacks.

regards,
Nikos


</body></email><email><emailId>20120407183003</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-04-07 18:30:03-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

On 04/07/2012 03:38 PM, Simon Josefsson wrote:

&gt;&gt;&gt; What about _ct for constant time? The _blinding is really specific
&gt;&gt;&gt; on the method used to achieve constant time.
&gt;&gt; But it's not really constant time, is it? Rather, timing is random but
&gt;&gt; independent of the inputs which are under control of the attacker. While
&gt;&gt; without RSA blinding, timing depends on the secret key and on data
&gt;&gt; provided by the attacker, which is a bad combination.
&gt; 
&gt; Maybe a better term to use is "reduced side channel" or something.  Not
&gt; easy to shorten though.  The generic problem adressed here is side
&gt; channels.


Indeed, but side channels also contain the issues due to power analysis,
and I don't know if the same techniques that make an
algorithm timing analysis resistant, also apply for power analysis.

regards,
Nikos

</body></email><email><emailId>20120408054928</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-04-08 05:49:28-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

lör 2012-04-07 klockan 20:30 +0200 skrev Nikos Mavrogiannopoulos:
&gt; On 04/07/2012 03:38 PM, Simon Josefsson wrote:
&gt; 
&gt; &gt;&gt;&gt; What about _ct for constant time? The _blinding is really specific
&gt; &gt;&gt;&gt; on the method used to achieve constant time.
&gt; &gt;&gt; But it's not really constant time, is it? Rather, timing is random but
&gt; &gt;&gt; independent of the inputs which are under control of the attacker. While
&gt; &gt;&gt; without RSA blinding, timing depends on the secret key and on data
&gt; &gt;&gt; provided by the attacker, which is a bad combination.
&gt; &gt; 
&gt; &gt; Maybe a better term to use is "reduced side channel" or something.  Not
&gt; &gt; easy to shorten though.  The generic problem adressed here is side
&gt; &gt; channels.
&gt; 
&gt; 
&gt; Indeed, but side channels also contain the issues due to power analysis,
&gt; and I don't know if the same techniques that make an
&gt; algorithm timing analysis resistant, also apply for power analysis.

Right, but maybe the API name could be general so that it could
implement mitigation against power analysis as well in the future, if
needed.  Or some other side channel attack (cache misses, etc).

/Simon


</body></email><email><emailId>20120409142950</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-04-09 14:29:50-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I've updated the patch to account for that and other issues.
&gt; http://homes.esat.kuleuven.be/~nikos/0001-Added-timing-resistant-versions-of-rsa_compute_root-.patch

Nice. I'm still not sure how to best do this. I've been looking at it
for some time today, and I consider the below patch (with _rsa_blind and
_rsa_unblind helper functions in aseparate file). But on second thought
maybe it's better to do it like you do with an rsa_compute_root_tr
function. In any case, I think it does make sense to have a separate
pkcs1_decrypt function for the common processing of rsa_decrypt and
rsa_decrypt_tr.

&gt; What I haven't done is to duplicate all the rsa_(hash)_sign functions.
&gt; They are quite many and it doesn't make much sense duplicating all of
&gt; them. Do you have any suggestion on compacting it?

One way may be to *always* do blinding. But I hesitate before requiring
the user to setup and provide a randomness function. I note that the
document you pointed to, ftp://ftp.rsasecurity.com/pub/pdfs/bull-2.pdf,
suggests using something similar to HMAC(private-key, input) to generate
the random number to be used for blidning. Doing that (and maybe have an
*optional* randomness source) could make sense.

The needed randomness info has to go either as argument to all private
key operations, or be put somewhere in the private key struct. And
either way makes things more complicated.

&gt; I don't really think that the random number in DSA relates to RSA
&gt; blinding. The random number in DSA is part of the signature scheme,
&gt; while the RSA blinding random number is just to prevent timing attacks.

The purpose is very different, but the interface issues (assuming we do
add deterministic DSA signatures) are very similar: You have a signature
method were a randomness function is optional for all private key
operations.

I think it makes some sense to implement rsa_decrypt_tr now, with no
advertised internals, and give the signature interface more time.

BTW, do you have any test cases? It would be useful both to have test
cases that check that the _tr operations give the correct result (that
should ba a simple addition to testsuite/rsa-encrypt-test, I guess), and
some way to quantitatively check how the timing depends on the inputs,
for both rsa_compute_root and rsa_compute_root_tr.

Regard,
/Niels

diff --git a/Makefile.in b/Makefile.in
index 4d3c89a..bad8103 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -99,7 +99,7 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  bignum.c bignum-next-prime.c \
 		  bignum-random.c bignum-random-prime.c \
 		  sexp2bignum.c \
-		  pkcs1.c pkcs1-rsa-md5.c pkcs1-rsa-sha1.c \
+		  pkcs1.c pkcs1-decrypt.c pkcs1-rsa-md5.c pkcs1-rsa-sha1.c \
 		  pkcs1-rsa-sha256.c pkcs1-rsa-sha512.c \
 		  rsa.c rsa-sign.c rsa-verify.c \
 		  rsa-md5-sign.c rsa-md5-verify.c \
@@ -107,6 +107,7 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  rsa-sha256-sign.c rsa-sha256-verify.c \
 		  rsa-sha512-sign.c rsa-sha512-verify.c \
 		  rsa-encrypt.c rsa-decrypt.c \
+		  rsa-blind.c rsa-decrypt-tr.c \
 		  rsa-keygen.c rsa-compat.c \
 		  rsa2sexp.c sexp2rsa.c \
 		  dsa.c dsa-sign.c dsa-verify.c dsa-keygen.c \
diff --git a/pkcs1-decrypt.c b/pkcs1-decrypt.c
new file mode 100644
index 0000000..bd21f88
--- /dev/null
+++ b/pkcs1-decrypt.c
@@ -0,0 +1,72 @@
+/* pkcs1-decrypt.c
+ *
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2001, 2012 Niels MÃ¶ller
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;string.h&gt;
+
+#include "pkcs1.h"
+
+#include "bignum.h"
+#include "nettle-internal.h"
+
+int
+pkcs1_decrypt (unsigned key_size,
+	       const mpz_t m,
+	       unsigned *length, uint8_t *message)
+{
+  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_BITS / 8);
+  uint8_t *terminator;
+  unsigned padding;
+  unsigned message_length;
+  
+  TMP_ALLOC(em, key_size);
+  nettle_mpz_get_str_256(key_size, em, m);
+
+  /* Check format */
+  if (em[0] || em[1] != 2)
+    return 0;
+
+  terminator = memchr(em + 2, 0, key_size - 2);
+
+  if (!terminator)
+    return 0;
+  
+  padding = terminator - (em + 2);
+  if (padding &lt; 8)
+    return 0;
+
+  message_length = key_size - 3 - padding;
+
+  if (*length &lt; message_length)
+    return 0;
+  
+  memcpy(message, terminator + 1, message_length);
+  *length = message_length;
+
+  return 1;
+}
+	       
diff --git a/pkcs1.h b/pkcs1.h
index 732d0ed..95a6a83 100644
--- a/pkcs1.h
+++ b/pkcs1.h
@@ -43,6 +43,7 @@ extern "C" {
 #define pkcs1_rsa_sha256_encode_digest nettle_pkcs1_rsa_sha256_encode_digest
 #define pkcs1_rsa_sha512_encode nettle_pkcs1_rsa_sha512_encode
 #define pkcs1_rsa_sha512_encode_digest nettle_pkcs1_rsa_sha512_encode_digest
+#define pkcs1_decrypt nettle_pkcs1_decrypt
 
 struct md5_ctx;
 struct sha1_ctx;
@@ -57,6 +58,11 @@ pkcs1_signature_prefix(unsigned size,
 		       unsigned digest_size);
 
 int
+pkcs1_decrypt (unsigned key_size,
+	       const mpz_t m,
+	       unsigned *length, uint8_t *message);
+
+int
 pkcs1_rsa_md5_encode(mpz_t m, unsigned length, struct md5_ctx *hash);
 
 int
diff --git a/rsa-blind.c b/rsa-blind.c
new file mode 100644
index 0000000..f66c169
--- /dev/null
+++ b/rsa-blind.c
@@ -0,0 +1,65 @@
+/* rsa-blind.c
+ *
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012, Nikos Mavrogiannopoulos, Niels MÃ¶ller
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "rsa.h"
+#include "bignum.h"
+
+void
+_rsa_blind (const mpz_t n, const mpz_t e,
+	    void *random_ctx, nettle_random_func random,
+	    mpz_t c, mpz_t ri)
+{
+  mpz_t r;
+
+  mpz_init(r);
+
+  /* c = c*(r^e)
+   * ri = r^(-1)
+   */
+  do 
+    {
+      nettle_mpz_random(r, random_ctx, random, n);
+      /* invert r */
+    }
+  while (!mpz_invert (ri, r, n));
+
+  /* c = c*(r^e) mod n */
+  mpz_powm(r, r, e, n);
+  mpz_mul(c, c, r);
+  mpz_fdiv_r(c, c, n);
+
+  mpz_clear(r);
+}
+
+void
+_rsa_unblind (const mpz_t n, mpz_t c, const mpz_t ri)
+{
+  mpz_mul(c, c, ri);
+  mpz_fdiv_r(c, c, n);
+}
+
diff --git a/rsa-decrypt-tr.c b/rsa-decrypt-tr.c
new file mode 100644
index 0000000..5951a12
--- /dev/null
+++ b/rsa-decrypt-tr.c
@@ -0,0 +1,55 @@
+/* rsa-decrypt-tr.c
+ *
+ * The RSA publickey algorithm. PKCS#1 encryption.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2001, 2012 Niels MÃ¶ller
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "rsa.h"
+
+#include "pkcs1.h"
+
+int
+rsa_decrypt_tr(const struct rsa_public_key *public,
+	       const struct rsa_private_key *key,
+	       void *random_ctx, nettle_random_func random,	       
+	       unsigned *length, uint8_t *message,
+	       const mpz_t gibberish)
+{
+  mpz_t m, ri;
+  int res;
+
+  mpz_init_set(m, gibberish);
+  mpz_init (ri);
+
+  rsa_blind (public-&gt;n, public-&gt;e, random_ctx, random,
+	     m, ri);
+  rsa_compute_root(key, m, m);
+  rsa_unblind (public-&gt;n, m, ri);
+  
+  res = pkcs1_decrypt (key-&gt;size, m, length, message);
+  mpz_clear(m);
+  return res;
+}
diff --git a/rsa-decrypt.c b/rsa-decrypt.c
index fe6de23..cde0d3c 100644
--- a/rsa-decrypt.c
+++ b/rsa-decrypt.c
@@ -1,11 +1,11 @@
-/* rsa_decrypt.c
+/* rsa-decrypt.c
  *
  * The RSA publickey algorithm. PKCS#1 encryption.
  */
 
 /* nettle, low-level cryptographics library
  *
- * Copyright (C) 2001 Niels MÃ¶ller
+ * Copyright (C) 2001, 2012 Niels MÃ¶ller
  *  
  * The nettle library is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
@@ -27,54 +27,22 @@
 # include "config.h"
 #endif
 
-#include &lt;assert.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
 #include "rsa.h"
 
-#include "bignum.h"
-#include "nettle-internal.h"
+#include "pkcs1.h"
 
 int
 rsa_decrypt(const struct rsa_private_key *key,
 	    unsigned *length, uint8_t *message,
 	    const mpz_t gibberish)
 {
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_BITS / 8);
-  uint8_t *terminator;
-  unsigned padding;
-  unsigned message_length;
-  
   mpz_t m;
+  int res;
 
   mpz_init(m);
   rsa_compute_root(key, m, gibberish);
 
-  TMP_ALLOC(em, key-&gt;size);
-  nettle_mpz_get_str_256(key-&gt;size, em, m);
+  res = pkcs1_decrypt (key-&gt;size, m, length, message);
   mpz_clear(m);
-
-  /* Check format */
-  if (em[0] || em[1] != 2)
-    return 0;
-
-  terminator = memchr(em + 2, 0, key-&gt;size - 2);
-
-  if (!terminator)
-    return 0;
-  
-  padding = terminator - (em + 2);
-  if (padding &lt; 8)
-    return 0;
-
-  message_length = key-&gt;size - 3 - padding;
-
-  if (*length &lt; message_length)
-    return 0;
-  
-  memcpy(message, terminator + 1, message_length);
-  *length = message_length;
-
-  return 1;
+  return res;
 }
diff --git a/rsa.h b/rsa.h
index a4ef835..75eaafc 100644
--- a/rsa.h
+++ b/rsa.h
@@ -32,9 +32,6 @@
 #include "md5.h"
 #include "sha.h"
 
-/* For nettle_random_func */
-#include "nettle-meta.h"
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -64,7 +61,10 @@ extern "C" {
 #define rsa_sha512_verify_digest nettle_rsa_sha512_verify_digest
 #define rsa_encrypt nettle_rsa_encrypt
 #define rsa_decrypt nettle_rsa_decrypt
+#define rsa_decrypt_tr nettle_rsa_decrypt_re
 #define rsa_compute_root nettle_rsa_compute_root
+#define _rsa_blind _nettle_rsa_blind
+#define _rsa_unblind _nettle_rsa_unblind  
 #define rsa_generate_keypair nettle_rsa_generate_keypair
 #define rsa_keypair_to_sexp nettle_rsa_keypair_to_sexp
 #define rsa_keypair_from_sexp_alist nettle_rsa_keypair_from_sexp_alist
@@ -260,7 +260,7 @@ rsa_sha512_verify_digest(const struct rsa_public_key *key,
 int
 rsa_encrypt(const struct rsa_public_key *key,
 	    /* For padding */
-	    void *random_ctx, nettle_random_func random,
+	    void *random_ctx, nettle_random_func *random,
 	    unsigned length, const uint8_t *cleartext,
 	    mpz_t cipher);
 
@@ -274,12 +274,31 @@ rsa_decrypt(const struct rsa_private_key *key,
 	    unsigned *length, uint8_t *cleartext,
 	    const mpz_t ciphertext);
 
+/* Timing-resistant version, using randomized RSA blinding. */
+int
+rsa_decrypt_tr(const struct rsa_public_key *public,
+	       const struct rsa_private_key *key,
+	       void *random_ctx, nettle_random_func random,	       
+	       unsigned *length, uint8_t *message,
+	       const mpz_t gibberish);
+
 /* Compute x, the e:th root of m. Calling it with x == m is allowed. */
 void
 rsa_compute_root(const struct rsa_private_key *key,
 		 mpz_t x, const mpz_t m);
 
 
+/* Blinds the c, by computing c *= r^e (mod n), for a random r. Also
+   returns the inverse (ri), for use by rsa_unblind. */
+void
+_rsa_blind (const mpz_t n, const mpz_t e,
+	    void *random_ctx, nettle_random_func *random,
+	    mpz_t c, mpz_t ri);
+
+/* c *= ri mod n */
+void
+_rsa_unblind (const mpz_t n, mpz_t c, const mpz_t ri);
+
 /* Key generation */
 
 /* Note that the key structs must be initialized first. */
@@ -287,8 +306,8 @@ int
 rsa_generate_keypair(struct rsa_public_key *pub,
 		     struct rsa_private_key *key,
 
-		     void *random_ctx, nettle_random_func random,
-		     void *progress_ctx, nettle_progress_func progress,
+		     void *random_ctx, nettle_random_func *random,
+		     void *progress_ctx, nettle_progress_func *progress,
 
 		     /* Desired size of modulo, in bits */
 		     unsigned n_size,

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120409201007</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-04-09 20:10:07-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I think it makes some sense to implement rsa_decrypt_tr now, with no
&gt; advertised internals, and give the signature interface more time.

I've committed an rsa_decrypt_tr now, based on Nikos' code. I reordered
the arguments a bit, in an attempt to be more consistent with other rsa
functions, so the prototype is now

/* Timing-resistant version, using randomized RSA blinding. */
int
rsa_decrypt_tr(const struct rsa_public_key *pub,
	       const struct rsa_private_key *key,
	       void *random_ctx, nettle_random_func *random,	       
	       unsigned *length, uint8_t *message,
	       const mpz_t gibberish);

Does this make sense? If you are using the rsa encrypt/decrypt
functions, and the interface is ok, I guess we should also document
them.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120409203905</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-04-09 20:39:05-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

On 04/09/2012 04:29 PM, Niels Möller wrote:


&gt; One way may be to *always* do blinding. But I hesitate before requiring
&gt; the user to setup and provide a randomness function. I note that the
&gt; document you pointed to, ftp://ftp.rsasecurity.com/pub/pdfs/bull-2.pdf,
&gt; suggests using something similar to HMAC(private-key, input) to generate
&gt; the random number to be used for blidning. Doing that (and maybe have an
&gt; *optional* randomness source) could make sense.

Although the HMAC avoids the need for randomness, you need to get a key
somehow, so the gain might not be much.

&gt; The needed randomness info has to go either as argument to all private
&gt; key operations, or be put somewhere in the private key struct. And
&gt; either way makes things more complicated.


Indeed.

&gt; I think it makes some sense to implement rsa_decrypt_tr now, with no
&gt; advertised internals, and give the signature interface more time.


What about the rsa_compute_root? This is the only function I can use
from nettle for RSA signatures (TLS is peculiar on its signatures thus
the exported interface isn't sufficient). If there was an
rsa_pkcs1_sign() and rsa_pkcs1_verify() with similar interface to
encrypt/decrypt, I could use those instead.

&gt; BTW, do you have any test cases? It would be useful both to have test
&gt; cases that check that the _tr operations give the correct result (that
&gt; should ba a simple addition to testsuite/rsa-encrypt-test, I guess), and
&gt; some way to quantitatively check how the timing depends on the inputs,
&gt; for both rsa_compute_root and rsa_compute_root_tr.


I had modified the rsa-encrypt-test.c to include a test for the
timing resistant version as well. Other than that I have no other test
cases.

regards,
Nikos



</body></email><email><emailId>20120409205725</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-04-09 20:57:25-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Although the HMAC avoids the need for randomness, you need to get a key
&gt; somehow, so the gain might not be much.

The idea is to reuse (hash of) the private RSA key as the HMAC key. And
similarly for deterministic DSA.

&gt; What about the rsa_compute_root? This is the only function I can use
&gt; from nettle for RSA signatures

I wasn't aware of that. That's an argument for an rsa_compute_root_tr
(or alternatively, public rsa_blind and rsa_unblind helpers).

Can you explain briefly what special signatures are used by tls? (It was
more then 10 years since I wrote an implementation, then it was ssl
version 3).

&gt; If there was an rsa_pkcs1_sign() and rsa_pkcs1_verify() with similar
&gt; interface to encrypt/decrypt, I could use those instead.

Can you propose such an interface? Currently, rsa_md5_sign calls
pkcs1_rsa_md5_encode followed by rsa_compute_root. If it's easy for you
to use rsa_compute_root in the same way, then I guess there's no need to
introduce new low-level primitives, but maybe it could be rearranged in
some better way? 

Or, since tls is an important application, it may make sense to directly
add tls-style signatures to Nettle.

&gt; I had modified the rsa-encrypt-test.c to include a test for the
&gt; timing resistant version as well. Other than that I have no other test
&gt; cases.

I see. It would really be helpful with some tools for measuring the
input dependence in the timing of rsa_compute_root. GMP's mpz_powm may
well behave quite differently from openssl's.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120410100405</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-04-10 10:04:05-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

On Mon, Apr 9, 2012 at 10:57 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt;&gt; What about the rsa_compute_root? This is the only function I can use
&gt;&gt; from nettle for RSA signatures
&gt; I wasn't aware of that. That's an argument for an rsa_compute_root_tr
&gt; (or alternatively, public rsa_blind and rsa_unblind helpers).
&gt; Can you explain briefly what special signatures are used by tls? (It was
&gt; more then 10 years since I wrote an implementation, then it was ssl
&gt; version 3).

Out of memory TLS 1.0 uses a concatenation of md5 and sha1. I don't
think however
that, this mode should be added in nettle. It would complicate the API
for no real reason
(if a generic pkcs1, 1.5 signing function is available).

&gt;&gt; If there was an rsa_pkcs1_sign() and rsa_pkcs1_verify() with similar
&gt;&gt; interface to encrypt/decrypt, I could use those instead.
&gt; Can you propose such an interface? Currently, rsa_md5_sign calls
&gt; pkcs1_rsa_md5_encode followed by rsa_compute_root. If it's easy for you
&gt; to use rsa_compute_root in the same way, then I guess there's no need to
&gt; introduce new low-level primitives, but maybe it could be rearranged in
&gt; some better way?

I do the pkcs1 1.5 encoding in gnutls, and you also do it in the high
level functions in nettle, that I cannot use. It would be nice if we
can save some code and reduce error risk by having a common pkcs1 1.5
signing function. I'll try to propose one the next few days.

&gt; Or, since tls is an important application, it may make sense to directly
&gt; add tls-style signatures to Nettle.

I don't think it is a good idea. What might be needed at some point
later is pkcs 1 2.0 signatures. I've come across some passports signed
by certificates using rsa-pss :(

regards,
Nikos

</body></email><email><emailId>20120410102308</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-04-10 10:23:08-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I do the pkcs1 1.5 encoding in gnutls, and you also do it in the high
&gt; level functions in nettle, that I cannot use. It would be nice if we
&gt; can save some code and reduce error risk by having a common pkcs1 1.5
&gt; signing function. I'll try to propose one the next few days.

Have you looked at pkcs1_signature_prefix? It does part of the work, so
maybe it's a good starting point. The reason it leaves space for the
actual digest rather than copying it in place, is to avoid extra copies
for the rsa_md5_sign-style functions.

If this could be simplified, to reduce the amount of duplicated code to
implement signatures for each supported hash function, while keeping low
overhead for applications using only a single variant, that would be
nice.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120413213940</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-04-13 21:39:40-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

On 04/10/2012 12:23 PM, Niels Möller wrote:

&gt;&gt; I do the pkcs1 1.5 encoding in gnutls, and you also do it in the high
&gt;&gt; level functions in nettle, that I cannot use. It would be nice if we
&gt;&gt; can save some code and reduce error risk by having a common pkcs1 1.5
&gt;&gt; signing function. I'll try to propose one the next few days.
&gt; Have you looked at pkcs1_signature_prefix? It does part of the work, so
&gt; maybe it's a good starting point. The reason it leaves space for the
&gt; actual digest rather than copying it in place, is to avoid extra copies
&gt; for the rsa_md5_sign-style functions.


pkcs1_signature_prefix() is very low level to be used by gnutls, as it
assumes no ASN.1 encoder. The most suitable for me would be
something like:

/* RSA signatures, using PKCS#1 1.5
 * Input should be a BER encoded DigestInfo
 */
int
rsa_digest_info_sign(const struct rsa_private_key *key,
        unsigned length, const uint8_t *digest_info,
        mpz_t signature);

int
rsa_digest_info_verify(const struct rsa_public_key *key,
           unsigned length, const uint8_t *digest_info,
           const mpz_t signature);

Those two could also be used in place of all the individual
rsa_(hash)_sign and rsa_(hash)_verify. It requires though another
function is available translate from a digest to the digest_info (this
is not needed for gnutls as we already have that, just a suggestion to
fit those two in nettle).

E.g.
digest_to_digest_info(hash_id, unsigned length, const uint8_t* digest,
unsigned* digest_info_length, uint8_t* digest_info);

The cost is having a single function that will contain the OIDs for all
the supported hash algorithms. The benefit is that there is no need to
have separate sign and verify functions for each supported hash.

regards,
Nikos

</body></email><email><emailId>20120414072833</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-04-14 07:28:33-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; /* RSA signatures, using PKCS#1 1.5
&gt;  * Input should be a BER encoded DigestInfo
&gt;  */
&gt; int
&gt; rsa_digest_info_sign(const struct rsa_private_key *key,
&gt;         unsigned length, const uint8_t *digest_info,
&gt;         mpz_t signature);
&gt;
&gt; int
&gt; rsa_digest_info_verify(const struct rsa_public_key *key,
&gt;            unsigned length, const uint8_t *digest_info,
&gt;            const mpz_t signature);

That seems reasonable (if and how the implementation of nettle's other
rsa sign/verify functions could be reorganized to make use of that, I'm
not sure).

Minor points: It should really be DER encoded, right? And I guess you'd
also want a _sign_tr variant. As for naming, maybe I'd want to have
"pkcs1" int he name, not sure.

A question for all of you: Nettle currently has two flavors of sign
functions for each algorithm. E.g.,

  int
  rsa_sha1_sign(const struct rsa_private_key *key,
                struct sha1_ctx *hash,
                mpz_t signature);
  
  int
  rsa_sha1_sign_digest(const struct rsa_private_key *key,
		       const uint8_t *digest,
                       mpz_t s);

The former could be implemented in terms of the latter (currently it's
not, to avoid an unnecessary copy, which may be a pointless
optimization in this context).

The point of the first function is convenience, where you can create a
signature simply by

  sha1_init
  sha1_update
  rsa_sha1_sign

without bothering with allocating and writing the actual digest.

Do you think this design makes sense?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121203225746</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-12-03 22:57:46-0400</timestampReceived><subject>Re: SHA2 renaming</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; fre 2012-11-30 klockan 12:38 +0100 skrev Niels Möller:

&gt;&gt; I think I'd still like to do the header split, sha.h -&gt; sha1.h and
&gt;&gt; sha2.h, for better consistency within Nettle, but that's less intrusive,
&gt;&gt; and backwards compatibility is trivial, with a sha.h including both.
&gt;
&gt; Yes, doing that split makes sense to me.  SHA256 etc doesn't have much
&gt; in common with SHA1, so they belong in separate header files.

I did that split the other day.

And while updating hash documentation, I also reorganized that section
of the manual a bit.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121213171421</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2012-12-13 17:14:21-0400</timestampReceived><subject>Re: sha3 optimization</subject><body>

On 12/13/2012 10:31 AM, Niels Möller wrote:


&gt; Maybe it would be better to copy data back and forth to 64-bit
&gt; registers, but I seem to vaguely recall that moves between regular
&gt; registers and xmm registers being slow, is that so? 


I don't think you can ever know given the large number of architectures
and designs. If you remember in the memxor using the SSE2 registers
gave a 10x boost in intel processors was running at 0.9x the original
speed in the AMD ones.

I'd say just try it on some stock processors and see what's best on
average (I can test code on i7 if you need).

regards,
Nikos

</body></email><email><emailId>20121215125627</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-12-15 12:56:27-0400</timestampReceived><subject>Re: [PATCH] Probe for archiver tool</subject><body>

Comitted now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121215165859</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-12-15 16:58:59-0400</timestampReceived><subject>Re: Some news for the next year</subject><body>

On 12/15/2012 01:20 PM, Niels Möller wrote:

[I add Ilya to the discussion in case he wants to add something, because
he's more familiar with the elliptic implementation.]

&gt; Not sure which code to reuse. I also wrote a proof-of-concept ecc
&gt; implementation for Yubico last year (targeted at 8-bit and 16-bit
&gt; microcontrollers), which is LGPL licensed.
&gt;&gt; What I submitted was about curves mod p (I think the patch was about
&gt;&gt; arbitrary curves, but had been tested only with curves that had a=-3 -
&gt;&gt; the nist curves).
&gt; For now, I think I'll do only standard mod p curves ("secp192r1",
&gt; "secp224r1", "secp256r1", there are also other names for these curves, I
&gt; don't know which names are the most established ones).


Also secp384r1 and secp521r1 are needed for higher security levels.

&gt; 
&gt;&gt; This code has been further improved by Ilya in the last google summer
&gt;&gt; of code by adding wmNAF multiplication and other optimizations in the
&gt;&gt; code base.
&gt; What's wmNAF? Optimizations I'm aware of:


It is discussed in http://www.bmoeller.de/pdf/fastexp-icisc2002.pdf
(over a prime field), but you can also check
http://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#wNAF_method

It is an optimization in scalar multiplication.

&gt; * Multiplication for an arbitrary point: Use a standard window-based
&gt;   exponentiation algorithm. Not sure if it makes sense to aim for
&gt;   data-independent timing (like GMP mpz_pomw_sec).


This was what I had in the first patch. wmNAF is more efficient.

&gt; * Multiplication for the generator point: Use the "comb" method for
&gt;   fixed-base exponentation (see Handbook of Applied Cryptography). Gives
&gt;   a large speedup for generating ECDSA signatures, at the cost of some
&gt;   constant tables.

&gt; * Representation for multiplication. In the code I've written I've used

&gt;   homogeneous cooordinates, not sure if maybe Jacobi coordinates would
&gt;   be more efficient? Do you know? When using compile-time constant
&gt;   tables, take advantage of normalization in the tabulated values (the
&gt;   homogeneous coordinate Z always 1).


In the affine space Z is 1 in all types of coordinates. Using jacobian
coordinates adds some (minor) complexity but provides several
(performance) advantages in the existing algorithms.

&gt; * At least for the primes used for the 192-bit and 224-bit curve,
&gt;   Montgomery representation is not needed, since the structure of the
&gt;   primes (top 128 bits all ones) makes standard euclidean modulo very
&gt;   efficient. For the 256-bit curve, only the top 32-bits are all ones,
&gt;   so on 64-bit machines one may want to use montgomery, or some other
&gt;   special trick.

Gnutls' code was based on libtomcrypt which used to montgomery
transformation but we don't use it. I'm not sure about the benefits
since I've not measured it.

However, I'd strongly suggest to check what we already have in gnutls
because it is quite heavily optimized (is even faster than openssl's
implementation), and there is no point to try to reinvent it. The
current code is written closely to nettle's coding standards.

regards,
Nikos

</body></email><email><emailId>20121215203243</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-12-15 20:32:43-0400</timestampReceived><subject>Re: [PATCH] build: add --enable-static option</subject><body>

Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:

&gt;&gt; Maybe a make install without a previous make all should be supported?
&gt;
&gt; Usually yes.

I just checked the GNU coding standards, and they seem to agree with
you.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121216162244</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-12-16 16:22:44-0400</timestampReceived><subject>Re: building without fp</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I noticed that trying to build nettle in systems without floating point
&gt; fails at the shadata, aesdata tools. The attached patch adds a flag
&gt; (disable-data-targets) to prevent them from being built.

Which system are you building for, which lack even software floating
point? Is it for native or cross compile? I wonder if it can be handled
better automatically, instead of introducing yet another configure flag.
Some possibilities:

1. Have a configure check for working floating point, and disable
   programs depending on floating point.

2. When cross compiling, don't cross compile those tools, but instead
   create binaries for the build machine.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121221093429</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-12-21 09:34:29-0400</timestampReceived><subject>Re: [PATCH] silence more warnings</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; nettle-hash.c:53:2: warning: ISO C does not allow extra ';' outside of a function [-pedantic]
&gt; testutils.c:1072:2: warning: ISO C does not allow extra ';' outside of a function [-pedantic]
&gt; des-compat-test.c:748:14: warning: old-style function definition [-Wold-style-definition]
&gt; des-compat-test.c:755:17: warning: initialization discards 'const'
&gt; qualifier from pointer target type

I found I still had this mail lying around. Applied now, except for
using NONNULL.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121214161632</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-12-14 16:16:32-0400</timestampReceived><subject>Some news for the next year</subject><body>

The first item is a personal one. From January 7, I'll start working for
Southpole Consulting AB, a small Sockholm-based consulting company
mainly doing embedded (GNU/)Linux development.

Second item is more directly related to Nettle. I will get funding from
Internetfonden, for "Adapting GNU Nettle for embedded systems". This
will mean two things: Support for elliptic curve signatures (and
possibly some other ECC-related things), and optimizations for the ARM
architecture. The funding is for 420 hours of work, most of which will
be spent during the spring, and the project will be carried out under
the umbrella of Southpole Consulting.

A question for the list: Which variants of the ARM family are most
important for Nettle applications? I'm not yet very familiar with the
ARM world, but the following are some alternatives for testing and
benchmarking:

* The current most high-end processor, Cortex-A15, where an affordable
  development system seems to be a recent "chromebook". Not sure exactly
  which model, but I guess it's this one:
  http://www.amazon.co.uk/Samsung-Chromebook-Wifi-Latest-Model/dp/B009RF0AQ8/ref=sr_1_1?s=computers&amp;ie=UTF8&amp;qid=1355494569&amp;sr=1-1


* The previous "most high-end" processor, Cortex-A9. An affordable
  development system is the PandaBoard.
  http://www.omappedia.com/wiki/PandaBoard_FAQ

* The Raspberry Pi computer, featuring an older (obsolete?) ARM1176JFZ,
  "ARMv6" architecture.
  http://www.raspberrypi.org/faqs

* The low-end Cortex-M0, competing with less than $1 microcontrollers.
  Also "ARMv6" architecture. An affordable development system seems to
  be LPCXPRESSO board.
  http://www.embeddedartists.com/products/lpcxpresso/lpc11U14_xpr.php

And if anybody here has some interesting ARM hardware to donate to the
project, this is the right time.

Best regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20121215074435</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-12-15 07:44:35-0400</timestampReceived><subject>Re: [PATCH] build: add --enable-static option</subject><body>

Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:

Thanks. I have one comment on the patch.

&gt; --- a/Makefile.in
&gt; +++ b/Makefile.in
&gt; @@ -21,7 +21,11 @@ include config.make
&gt;  PRE_CPPFLAGS = -I.
&gt;  # FIXME: Add configuration of LIBEXT?
&gt;  LIBTARGETS = libnettle.a @IF_HOGWEED@ libhogweed.a
&gt; -SHLIBTARGETS = $(LIBNETTLE_FORLINK) @IF_HOGWEED@ $(LIBHOGWEED_FORLINK)
&gt; +@IF_STATIC@INSTALL_LIBTARGETS = install-static
&gt; +@IF_STATIC@UNINSTALL_LIBTARGETS = uninstall-static
&gt; +@IF_SHARED@SHLIBTARGETS = $(LIBNETTLE_FORLINK) @IF_HOGWEED@ $(LIBHOGWEED_FORLINK)
&gt; +@IF_SHARED@INSTALL_SHLIBTARGETS = install-shared-nettle @IF_HOGWEED@ install-shared-hogweed
&gt; +@IF_SHARED@UNINSTALL_SHLIBTARGETS = uninstall-shared

I think I'd prefer to make the definitions unconditional, but with
conditional values. E.g.

  UNINSTALL_SHLIBTARGETS = @IF_SHARED@ uninstall-shared

rather than

  @IF_SHARED@UNINSTALL_SHLIBTARGETS = uninstall-shared

Is there any reason that won't work?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121216154949</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-12-16 15:49:49-0400</timestampReceived><subject>building without fp</subject><body>

I noticed that trying to build nettle in systems without floating point
fails at the shadata, aesdata tools. The attached patch adds a flag
(disable-data-targets) to prevent them from being built.

regards,
Nikos

["0001-Do-not-build-the-algorithm-data-generation-if-disabl.patch" (text/x-patch)]

&gt;From 508ee91f87a109a61abfcb02aa06db2cd89c18cf Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Sun, 16 Dec 2012 16:46:26 +0100
Subject: [PATCH] Do not build the algorithm data generation if
 --disable-data-targets is given.

---
 Makefile.in  |    9 +++++----
 configure.ac |   14 ++++++++++++++
 2 files changed, 19 insertions(+), 4 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index d6be465..bac4794 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -29,9 +29,10 @@ getopt_TARGETS = $(getopt_SOURCES:.c=.$(OBJEXT))
 internal_SOURCES = nettle-internal.c
 internal_TARGETS = $(internal_SOURCES:.c=.$(OBJEXT))
 
-TARGETS = aesdata$(EXEEXT) desdata$(EXEEXT) twofishdata$(EXEEXT) \
-	  shadata$(EXEEXT) gcmdata$(EXEEXT) \
-	  $(getopt_TARGETS) $(internal_TARGETS) \
+DATA_TARGETS = @IF_DATA_TARGETS@ aesdata$(EXEEXT) desdata$(EXEEXT) twofishdata$(EXEEXT) \
+	  shadata$(EXEEXT) gcmdata$(EXEEXT)
+
+TARGETS = $(getopt_TARGETS) $(internal_TARGETS) \
 	  $(LIBTARGETS) $(SHLIBTARGETS)
 IMPLICIT_TARGETS = @IF_DLL@ $(LIBNETTLE_FILE) $(LIBHOGWEED_FILE)
 
@@ -58,7 +59,7 @@ check-here:
 dvi installcheck uninstallcheck:
 	true
 
-all-here: $(TARGETS) $(DOCTARGETS)
+all-here: $(TARGETS) $(DOCTARGETS) $(DATA_TARGETS)
 
 nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 aes-encrypt-internal.c aes-encrypt.c aes-encrypt-table.c \
diff --git a/configure.ac b/configure.ac
index 737febb..e232a58 100644
--- a/configure.ac
+++ b/configure.ac
@@ -610,11 +610,24 @@ else
   IF_DOCUMENTATION='#'
 fi
 
+#whether to build data targets
+AC_ARG_ENABLE(data-targets,
+  AC_HELP_STRING([--disable-data-targets], [Omit generation of algorithm data (default=yes)]),
+  [enable_data_targets=$enableval],
+  [enable_data_targets=yes])
+
+if test "x$enable_data_targets" = "xyes" ; then
+  IF_DATA_TARGETS=''
+else
+  IF_DATA_TARGETS='#'
+fi
+
 AC_SUBST(IF_HOGWEED)
 AC_SUBST(IF_STATIC)
 AC_SUBST(IF_SHARED)
 AC_SUBST(IF_DOCUMENTATION)
 AC_SUBST(IF_DLL)
+AC_SUBST(IF_DATA_TARGETS)
 
 OPENSSL_LIBFLAGS=''
 
@@ -697,5 +710,6 @@ AC_MSG_NOTICE([summary of build options:
   Static libraries:  ${enable_static}
   Shared libraries:  ${enable_shared}
   Public key crypto: ${enable_public_key}
+  Data targets:      ${enable_data_targets}
   Documentation:     ${enable_documentation}
 ])
-- 
1.7.10.4



</body></email><email><emailId>20121215125452</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-12-15 12:54:52-0400</timestampReceived><subject>Re: [PATCH] build: add --enable-static option</subject><body>

Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:

&gt; Gentoo bug#405525, support not installing static libraries.

Can you check if the following, simpler, patch to Makefile.in does the
job (still depends on IF_STATIC, from configure, of course)?

It will use the install-static and uninstall-static targets
unconditionally, but they won't do anything when LIBTARGETS is empty.

Regards,
/Niels

diff --git a/Makefile.in b/Makefile.in
index c63465c..d6be465 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -20,8 +20,8 @@ include config.make
 
 PRE_CPPFLAGS = -I.
 # FIXME: Add configuration of LIBEXT?
-LIBTARGETS = libnettle.a @IF_HOGWEED@ libhogweed.a
-SHLIBTARGETS = $(LIBNETTLE_FORLINK) @IF_HOGWEED@ $(LIBHOGWEED_FORLINK)
+LIBTARGETS = @IF_STATIC@ libnettle.a @IF_HOGWEED@ libhogweed.a
+SHLIBTARGETS = @IF_SHARED@ $(LIBNETTLE_FORLINK) @IF_HOGWEED@ $(LIBHOGWEED_FORLINK)
 
 getopt_SOURCES = getopt.c getopt1.c
 getopt_TARGETS = $(getopt_SOURCES:.c=.$(OBJEXT))
@@ -32,7 +32,7 @@ internal_TARGETS = $(internal_SOURCES:.c=.$(OBJEXT))
 TARGETS = aesdata$(EXEEXT) desdata$(EXEEXT) twofishdata$(EXEEXT) \
 	  shadata$(EXEEXT) gcmdata$(EXEEXT) \
 	  $(getopt_TARGETS) $(internal_TARGETS) \
-	  $(LIBTARGETS) @IF_SHARED@ $(SHLIBTARGETS)
+	  $(LIBTARGETS) $(SHLIBTARGETS)
 IMPLICIT_TARGETS = @IF_DLL@ $(LIBNETTLE_FILE) $(LIBHOGWEED_FILE)
 
 DOCTARGETS = @IF_DOCUMENTATION@ nettle.info nettle.html nettle.pdf


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121215195929</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-12-15 19:59:29-0400</timestampReceived><subject>Re: [PATCH] build: add --enable-static option</subject><body>

Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:

&gt; Working, thanks!

Thanks for testing. ---disable-static checked in now.

&gt; BTW:
&gt; There is an issue with:
&gt; $ ./configure
&gt; $ make install DESTDIR=/tmp/xxx

Skipping make is not currently supported. I.e., you're supposed to do

  $ ./configure
  $ make
  $ make install

or even better

  $ ./configure
  $ make
  $ make check &amp;&amp; make install

Maybe a make install without a previous make all should be supported?

Nevertheless, I guess the reported problem is a bug in
tools/Makefile.in, the rule

$(getopt_OBJS):
	( cd .. &amp;&amp; $(MAKE) $@ )

Does it work to replace $@ by `basename $@` ? (I haven't thought this
through, maybe there's some better way to do it...)

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121214174346</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2012-12-14 17:43:46-0400</timestampReceived><subject>Re: Some news for the next year</subject><body>


On Fri, 14 Dec 2012, Niels Möller wrote:

&gt; The first item is a personal one. From January 7, I'll start working for
&gt; Southpole Consulting AB, a small Sockholm-based consulting company
&gt; mainly doing embedded (GNU/)Linux development.

Congrats! You can say hi to Benjamin from me :-)

&gt; Second item is more directly related to Nettle. I will get funding from
&gt; Internetfonden, for "Adapting GNU Nettle for embedded systems". This
&gt; will mean two things: Support for elliptic curve signatures (and
&gt; possibly some other ECC-related things), and optimizations for the ARM
&gt; architecture. The funding is for 420 hours of work, most of which will
&gt; be spent during the spring, and the project will be carried out under
&gt; the umbrella of Southpole Consulting.
&gt; 
&gt; A question for the list: Which variants of the ARM family are most
&gt; important for Nettle applications? I'm not yet very familiar with the
&gt; ARM world, but the following are some alternatives for testing and
&gt; benchmarking:
&gt; 
&gt; * The current most high-end processor, Cortex-A15, where an affordable
&gt; development system seems to be a recent "chromebook". Not sure exactly
&gt; which model, but I guess it's this one:
&gt; http://www.amazon.co.uk/Samsung-Chromebook-Wifi-Latest-Model/dp/B009RF0AQ8/ref=sr_1_1?s=computers&amp;ie=UTF8&amp;qid=1355494569&amp;sr=1-1
&gt;  
&gt; * The previous "most high-end" processor, Cortex-A9. An affordable
&gt; development system is the PandaBoard.
&gt; http://www.omappedia.com/wiki/PandaBoard_FAQ
&gt; 
&gt; * The Raspberry Pi computer, featuring an older (obsolete?) ARM1176JFZ,
&gt; "ARMv6" architecture.
&gt; http://www.raspberrypi.org/faqs
&gt; 
&gt; * The low-end Cortex-M0, competing with less than $1 microcontrollers.
&gt; Also "ARMv6" architecture. An affordable development system seems to
&gt; be LPCXPRESSO board.
&gt; http://www.embeddedartists.com/products/lpcxpresso/lpc11U14_xpr.php
&gt; 
&gt; And if anybody here has some interesting ARM hardware to donate to the
&gt; project, this is the right time.

As far as I know, for use in smartphones and similar, most current ones 
run ARMv7, on Cortex-A8/A9. In general, if targeting say android, your 
baseline ABIs will be either ARMv5TE or ARMv7 (with optional NEON 
support), but finding a good ARMv5 development platform might not be all 
that easy. I'm not too experienced myself with writing ARM assembly, but 
in general I'd guess your target arch simply depends on at what level the 
necessary instructions are introduced - I guess some basic stuff might 
benefit from just being written in general ARM assembly for ARMv5, while 
other things can benefit more from new instructions in v6 or v7.

I'm not sure how well suited the NEON instruction set is for the crypto 
things - if it is, it'll be one important target. Since it's an optional 
part in ARMv7 in general (the iOS ARMv7 baseline includes NEON, since they 
can limit the number of chipsets they run on, while Android ARMv7 doesn't 
include it - in particular, nvidia tegra2 based devices lack it), ideally 
one would be able to enable or disable it using a runtime check.

This is the case for 3rd party app developers at least, for device 
manufacturers it's enough to be able to enable/disable it at build time.

// Martin



</body></email><email><emailId>20121214180720</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2012-12-14 18:07:20-0400</timestampReceived><subject>Re: Some news for the next year</subject><body>


On Fri, 14 Dec 2012, Martin Storsjö wrote:

&gt; On Fri, 14 Dec 2012, Niels Möller wrote:
&gt; 
&gt; &gt; Second item is more directly related to Nettle. I will get funding from
&gt; &gt; Internetfonden, for "Adapting GNU Nettle for embedded systems". This
&gt; &gt; will mean two things: Support for elliptic curve signatures (and
&gt; &gt; possibly some other ECC-related things), and optimizations for the ARM
&gt; &gt; architecture. The funding is for 420 hours of work, most of which will
&gt; &gt; be spent during the spring, and the project will be carried out under
&gt; &gt; the umbrella of Southpole Consulting.
&gt; &gt; 
&gt; &gt; A question for the list: Which variants of the ARM family are most
&gt; &gt; important for Nettle applications? I'm not yet very familiar with the
&gt; &gt; ARM world, but the following are some alternatives for testing and
&gt; &gt; benchmarking:
&gt; &gt; 
&gt; &gt; * The current most high-end processor, Cortex-A15, where an affordable
&gt; &gt; development system seems to be a recent "chromebook". Not sure exactly
&gt; &gt; which model, but I guess it's this one:
&gt; &gt; http://www.amazon.co.uk/Samsung-Chromebook-Wifi-Latest-Model/dp/B009RF0AQ8/ref=sr_1_1?s=computers&amp;ie=UTF8&amp;qid=1355494569&amp;sr=1-1
&gt; &gt;  
&gt; &gt; * The previous "most high-end" processor, Cortex-A9. An affordable
&gt; &gt; development system is the PandaBoard.
&gt; &gt; http://www.omappedia.com/wiki/PandaBoard_FAQ
&gt; &gt; 
&gt; &gt; * The Raspberry Pi computer, featuring an older (obsolete?) ARM1176JFZ,
&gt; &gt; "ARMv6" architecture.
&gt; &gt; http://www.raspberrypi.org/faqs
&gt; &gt; 
&gt; &gt; * The low-end Cortex-M0, competing with less than $1 microcontrollers.
&gt; &gt; Also "ARMv6" architecture. An affordable development system seems to
&gt; &gt; be LPCXPRESSO board.
&gt; &gt; http://www.embeddedartists.com/products/lpcxpresso/lpc11U14_xpr.php
&gt; &gt; 
&gt; &gt; And if anybody here has some interesting ARM hardware to donate to the
&gt; &gt; project, this is the right time.
&gt; 
&gt; As far as I know, for use in smartphones and similar, most current ones run 
&gt; ARMv7, on Cortex-A8/A9.

I forgot to add - one noteworthy detail is that Cortex-A9 has out-of-order 
execution, which the A8 and earlier lack. So for hand-scheduling of 
instructions, you'll want an A8 or older (a beagleboard/beaglebone is a 
good choice for that, especially if you want to hand-schedule NEON 
instructions).

// Martin



</body></email><email><emailId>20121215095649</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-12-15 09:56:49-0400</timestampReceived><subject>Re: Some news for the next year</subject><body>

On 12/14/2012 05:16 PM, Niels Möller wrote:

&gt; The first item is a personal one. From January 7, I'll start working for
&gt; Southpole Consulting AB, a small Sockholm-based consulting company
&gt; mainly doing embedded (GNU/)Linux development.
&gt; 
&gt; Second item is more directly related to Nettle. I will get funding from
&gt; Internetfonden, for "Adapting GNU Nettle for embedded systems". This
&gt; will mean two things: Support for elliptic curve signatures (and
&gt; possibly some other ECC-related things), and optimizations for the ARM
&gt; architecture. The funding is for 420 hours of work, most of which will
&gt; be spent during the spring, and the project will be carried out under
&gt; the umbrella of Southpole Consulting.

Congratulations! About the ECC part, if you plan to base it on what I
submitted last year, some clarifications. What I submitted was about
curves mod p (I think the patch was about arbitrary curves, but had been
tested only with curves that had a=-3 - the nist curves). This code has
been further improved by Ilya in the last google summer of code by
adding wmNAF multiplication and other optimizations in the code base.
The current code is on gnutls' lib/nettle/ directory. Contrary to the
previous patch the current code in gnutls is more coupled with gnutls
due to the precalculations needed in wmNAF (wmNAF gave a 10% improvement
in ECDH).

What is missing is support for curves over F(2^p).


&gt; A question for the list: Which variants of the ARM family are most
&gt; important for Nettle applications? I'm not yet very familiar with the
&gt; ARM world, but the following are some alternatives for testing and
&gt; benchmarking:
&gt; 
&gt; * The current most high-end processor, Cortex-A15, where an affordable
&gt; development system seems to be a recent "chromebook". Not sure exactly
&gt; which model, but I guess it's this one:
&gt; http://www.amazon.co.uk/Samsung-Chromebook-Wifi-Latest-Model/dp/B009RF0AQ8/ref=sr_1_1?s=computers&amp;ie=UTF8&amp;qid=1355494569&amp;sr=1-1
&gt;  
&gt; * The previous "most high-end" processor, Cortex-A9. An affordable
&gt; development system is the PandaBoard.
&gt; http://www.omappedia.com/wiki/PandaBoard_FAQ
&gt; 
&gt; * The Raspberry Pi computer, featuring an older (obsolete?) ARM1176JFZ,
&gt; "ARMv6" architecture.
&gt; http://www.raspberrypi.org/faqs


I wouldn't say that ARMv6 is obsolete. It exists in many embedded devices.

regards,
Nikos


</body></email><email><emailId>20121215122005</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-12-15 12:20:05-0400</timestampReceived><subject>Re: Some news for the next year</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Congratulations!

Thanks!

&gt; About the ECC part, if you plan to base it on what I submitted last
&gt; year, some clarifications.

Not sure which code to reuse. I also wrote a proof-of-concept ecc
implementation for Yubico last year (targeted at 8-bit and 16-bit
microcontrollers), which is LGPL licensed.

&gt; What I submitted was about curves mod p (I think the patch was about
&gt; arbitrary curves, but had been tested only with curves that had a=-3 -
&gt; the nist curves).

For now, I think I'll do only standard mod p curves ("secp192r1",
"secp224r1", "secp256r1", there are also other names for these curves, I
don't know which names are the most established ones).

&gt; This code has been further improved by Ilya in the last google summer
&gt; of code by adding wmNAF multiplication and other optimizations in the
&gt; code base.

What's wmNAF? Optimizations I'm aware of:

* Multiplication for an arbitrary point: Use a standard window-based
  exponentiation algorithm. Not sure if it makes sense to aim for
  data-independent timing (like GMP mpz_pomw_sec).

* Multiplication for the generator point: Use the "comb" method for
  fixed-base exponentation (see Handbook of Applied Cryptography). Gives
  a large speedup for generating ECDSA signatures, at the cost of some
  constant tables.

* Representation for multiplication. In the code I've written I've used
  homogeneous cooordinates, not sure if maybe Jacobi coordinates would
  be more efficient? Do you know? When using compile-time constant
  tables, take advantage of normalization in the tabulated values (the
  homogeneous coordinate Z always 1).

* At least for the primes used for the 192-bit and 224-bit curve,
  Montgomery representation is not needed, since the structure of the
  primes (top 128 bits all ones) makes standard euclidean modulo very
  efficient. For the 256-bit curve, only the top 32-bits are all ones,
  so on 64-bit machines one may want to use montgomery, or some other
  special trick.
  
&gt; What is missing is support for curves over F(2^p).

For a start, I think I'll stick to what's described in RFC 6090, since
then it seems very unlikely that I'll get into patent-related troubles.

&gt; I wouldn't say that ARMv6 is obsolete. It exists in many embedded devices.

I see.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121111130223</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-11 13:02:23-0400</timestampReceived><subject>Re: Keccak is SHA-3</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; It seems that the "Keccak" algorithm is now SHA-3:
&gt; http://www.nist.gov/itl/csd/sha-100212.cfm

I've had a look at the paper and the reference implementation
(http://keccak.noekeon.org/Keccak-reference-3.0.pdf and
http://keccak.noekeon.org/KeccakReferenceAndOptimized-3.2.zip).

I think it may be easiest to write some new code based on the pseudocode
description at http://keccak.noekeon.org/specs_summary.html.

I've also downloaded the test vectors
http://keccak.noekeon.org/KeccakKAT-3.zip and I'll see if I can make
sense of them. It would have been nice if the zip files had included a
readme file...

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121127121742</emailId><senderName>Fredrik Thulin</senderName><senderEmail>fredrik@thulin.net</senderEmail><timestampReceived>2012-11-27 12:17:42-0400</timestampReceived><subject>Fast PBKDF2 in Python, using Nettle</subject><body>

Hi

I just published a module used in some PBKDF2-HMAC-SHA512 testing I've
been doing under a contract with NORDUnet A/S.

  https://github.com/fredrikt/python-ndnkdf

I invoke the new PBKDF2 functions in libnettle using Python ctypes,
which achieves a ~ 25x speedup compared to the standard python-pbkdf2
that uses SHA512 from hashlib (presumably a C function), but does the
xoring in native Python.

PBKDF2-HMAC-SHA512 benchmark result :

  N=    16 -&gt; Python ==     0 ms, Nettle ==     0 ms
  N=    32 -&gt; Python ==     1 ms, Nettle ==     0 ms
  N=    64 -&gt; Python ==     2 ms, Nettle ==     0 ms
  N=   128 -&gt; Python ==     4 ms, Nettle ==     0 ms
  N=   256 -&gt; Python ==     8 ms, Nettle ==     0 ms
  N=   512 -&gt; Python ==    18 ms, Nettle ==     0 ms
  N=  1024 -&gt; Python ==    35 ms, Nettle ==     1 ms
  N=  2048 -&gt; Python ==    68 ms, Nettle ==     2 ms
  N=  4096 -&gt; Python ==   133 ms, Nettle ==     5 ms
  N=  8192 -&gt; Python ==   262 ms, Nettle ==    11 ms
  N= 16384 -&gt; Python ==   521 ms, Nettle ==    22 ms

If someone has access to a modern AMD CPU, I would be very interested in
getting the benchmark output of examples/pbkdf2-plot on that machine.
Thanks.

/Fredrik



</body></email><email><emailId>20121127130612</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-27 13:06:12-0400</timestampReceived><subject>Re: Fast PBKDF2 in Python, using Nettle</subject><body>

Fredrik Thulin &lt;fredrik@thulin.net&gt; writes:

&gt; I just published a module used in some PBKDF2-HMAC-SHA512 testing I've
&gt; been doing under a contract with NORDUnet A/S.
&gt;
&gt;   https://github.com/fredrikt/python-ndnkdf

Cool. Why SHA512 rather than SHA256, is using it specified somewhere?

If PBKDF2-HMAC-SHA512 is widely used, it would sense to add a
convenience function pbkdf2_hmac_sha512 to nettle.

What's the source of your test vectors? It would be nice with additional
test vectors also for nettle's testsuite/pbkdf2-test.c.

&gt; I invoke the new PBKDF2 functions in libnettle using Python ctypes,
&gt; which achieves a ~ 25x speedup compared to the standard python-pbkdf2
&gt; that uses SHA512 from hashlib (presumably a C function), but does the
&gt; xoring in native Python.

Is the speed of sha512 itself comparable? Nettle's implementatiion is
fairly straight-forward C code.

&gt; If someone has access to a modern AMD CPU, I would be very interested in
&gt; getting the benchmark output of examples/pbkdf2-plot on that machine.
&gt; Thanks.

My machine at home is a lowend but reasonably modern AMD, E-350, iirc.
I'm not very familiar with python, but if you tell me the steps needed
to get the benchmark running on a debian system I can give it a try.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121127140159</emailId><senderName>Fredrik Thulin</senderName><senderEmail>fredrik@thulin.net</senderEmail><timestampReceived>2012-11-27 14:01:59-0400</timestampReceived><subject>Re: Fast PBKDF2 in Python, using Nettle</subject><body>

On Tue, 2012-11-27 at 14:06 +0100, Niels Möller wrote:
&gt; Fredrik Thulin &lt;fredrik@thulin.net&gt; writes:
&gt; 
&gt; &gt; I just published a module used in some PBKDF2-HMAC-SHA512 testing I've
&gt; &gt; been doing under a contract with NORDUnet A/S.
&gt; &gt;
&gt; &gt;   https://github.com/fredrikt/python-ndnkdf
&gt; 
&gt; Cool. Why SHA512 rather than SHA256, is using it specified somewhere?

I wanted maximum speed on 64 bits CPUs without settling for SHA-1, but I
won't claim this was a particularly well illuminated decision.

&gt; If PBKDF2-HMAC-SHA512 is widely used, it would sense to add a
&gt; convenience function pbkdf2_hmac_sha512 to nettle.

I wouldn't mind that, although I've already failed to convince Simon =).

It would remove the hack of passing a 1k buffer as sha512ctx
(https://github.com/fredrikt/python-ndnkdf/blob/master/ndnkdf/ndnkdf.py#L76).

&gt; What's the source of your test vectors? It would be nice with additional
&gt; test vectors also for nettle's testsuite/pbkdf2-test.c.

IIRC I actually took the test vectors *from* Nettle - my basic concern
with testing was to verify that I was successfully calling libnettle,
not that libnettle works.

I did implement a test case that compares the output of Nettle with that
of python-pbkdf2 for a number of (key, salt, iterations) though.

&gt; &gt; I invoke the new PBKDF2 functions in libnettle using Python ctypes,
&gt; &gt; which achieves a ~ 25x speedup compared to the standard python-pbkdf2
&gt; &gt; that uses SHA512 from hashlib (presumably a C function), but does the
&gt; &gt; xoring in native Python.
&gt; 
&gt; Is the speed of sha512 itself comparable? Nettle's implementatiion is
&gt; fairly straight-forward C code.

Haven't measured. Optimizing a SHA512 implementation is really above my
head, but I've heard talks about using AMD XOP instruction set to
optimize SHA512 on other mailing lists... 

&gt; &gt; If someone has access to a modern AMD CPU, I would be very interested in
&gt; &gt; getting the benchmark output of examples/pbkdf2-plot on that machine.
&gt; &gt; Thanks.
&gt; 
&gt; My machine at home is a lowend but reasonably modern AMD, E-350, iirc.
&gt; I'm not very familiar with python, but if you tell me the steps needed
&gt; to get the benchmark running on a debian system I can give it a try.

Thanks. Something like

  $ git clone https://github.com/dlitz/python-pbkdf2
  $ git clone https://github.com/fredrikt/python-ndnkdf
  $ cd python-ndnkdf/examples
  $ PYTHONPATH=../../python-pbkdf2 ./pbkdf2-plot

(assuming there is a new enough libnettle in the system library path).

/Fredrik



</body></email><email><emailId>20121127214757</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-27 21:47:57-0400</timestampReceived><subject>Re: Fast PBKDF2 in Python, using Nettle</subject><body>

Fredrik Thulin &lt;fredrik@thulin.net&gt; writes:

&gt; On Tue, 2012-11-27 at 14:06 +0100, Niels Möller wrote:
&gt;&gt; Cool. Why SHA512 rather than SHA256, is using it specified somewhere?
&gt;
&gt; I wanted maximum speed on 64 bits CPUs without settling for SHA-1, but I
&gt; won't claim this was a particularly well illuminated decision.

Makes some sense. But on the other hand, the point of pbkdf2 is to be
slow (for the attacker), so selecting a faster hash function just means
that you need to use a larger iteration count...

&gt; It would remove the hack of passing a 1k buffer as sha512ctx
&gt; (https://github.com/fredrikt/python-ndnkdf/blob/master/ndnkdf/ndnkdf.py#L76).

The right way would be to use some configure test to get the size of
that struct, I guess. (pyconfigure-0.1 was released yesterday, btw. See
http://www.gnu.org/software/pyconfigure/. I haven't done any python
modules since ancient versions of the gmp module, but I imagine
pyconfigure could be useful if you need configure tests for your python
module).

&gt; I did implement a test case that compares the output of Nettle with that
&gt; of python-pbkdf2 for a number of (key, salt, iterations) though.

For lack of more authoritative test vectors, adding a couple of
testvectors generated by python-pbkdf2, to the nettle testsuite would be
nice.

&gt; Haven't measured. Optimizing a SHA512 implementation is really above my
&gt; head, but I've heard talks about using AMD XOP instruction set to
&gt; optimize SHA512 on other mailing lists... 

That's a project for another day. It's some time since I wrote the C
implementation, and I can't guess if a clever assembly implementation
would gain a 10% or a 100% speedup compared to what gcc generates.

&gt;   $ git clone https://github.com/dlitz/python-pbkdf2
&gt;   $ git clone https://github.com/fredrikt/python-ndnkdf
&gt;   $ cd python-ndnkdf/examples
&gt;   $ PYTHONPATH=../../python-pbkdf2 ./pbkdf2-plot

Ok. With

  $ NDNKDF_PATH=~/build/nettle-shared/.lib PYTHONPATH=../../python-pbkdf2:.. ./pbkdf2-plot

I get

PBKDF2-HMAC-SHA512 benchmark result :

  N=    16 -&gt; Python ==     2 ms, Nettle ==     0 ms
  N=    32 -&gt; Python ==     6 ms, Nettle ==     0 ms
  N=    64 -&gt; Python ==     8 ms, Nettle ==     0 ms
  N=   128 -&gt; Python ==    16 ms, Nettle ==     0 ms
  N=   256 -&gt; Python ==    30 ms, Nettle ==     1 ms
  N=   512 -&gt; Python ==    57 ms, Nettle ==     2 ms
  N=  1024 -&gt; Python ==   114 ms, Nettle ==     3 ms
  N=  2048 -&gt; Python ==   229 ms, Nettle ==     7 ms
  N=  4096 -&gt; Python ==   453 ms, Nettle ==    15 ms
  N=  8192 -&gt; Python ==   909 ms, Nettle ==    30 ms
  N= 16384 -&gt; Python ==  1834 ms, Nettle ==    59 ms

The machine has an "AMD E-350" processor, 1.6 GHz dual core (but I guess
the number of cores doesn't matter here). GMP's configure refers to the
cpu as "bobcat", which if I understand these things correctly is AMD's
current low-end.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121112212107</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-12 21:21:07-0400</timestampReceived><subject>Re: Keccak is SHA-3</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I think it may be easiest to write some new code based on the pseudocode
&gt; description at http://keccak.noekeon.org/specs_summary.html.

I just commited an initial implementation. With this code, sha3-256 is
about an order of magnitude slower than either sha1 or sha2. I haven't
yet thought carefully on how to optimize it; I think the current
indexing can be simplified a bit, and it would make sense to unroll some
of the shorter loops inside the round loop (not sure it makes sense to
completely unroll everything except the outer loop).

For naming: I called it sha3_256 (since in nettle "sha256" is sha2. I
guess we should have named it sha2_256 back then). Any other
suggestions?

I haven't looked into other types of uses. E.g, does hmac-sha3 make
sense? The Keccak paper mentions keyed modes of operation, maybe that
would be preferable.

I put the interface declarations in sha3.h. I think it makes for better
consistency if we split the current sha.h into sha1.h and sha2.h (and
then we can keep a deprecated sha.h including both, for backwards
compatibility).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120913215854</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-13 21:58:54-0400</timestampReceived><subject>Salsa20/8 and Salsa20/12</subject><body>

I quickly discovered that I needed the round-reduced variants of
Salsa20.  Here they are.  I didn't update the assembler part, so I would
need help finishing that part.

/Simon

["0001-Support-round-reduced-Salsa20-8-and-Salsa20-12.patch" (text/x-diff)]

&gt; From 0d15d69c41456dfb1fc7b6317d4e9fd00a444ab3 Mon Sep 17 00:00:00 2001
From: Simon Josefsson &lt;simon@josefsson.org&gt;
Date: Thu, 13 Sep 2012 23:55:38 +0200
Subject: [PATCH] Support round-reduced Salsa20/8 and Salsa20/12.

---
 ChangeLog                |   10 +++++
 NEWS                     |    5 +++
 salsa20-crypt.c          |   40 ++++++++++++++---
 salsa20.h                |   12 ++++++
 testsuite/salsa20-test.c |  108 ++++++++++++++++++++++++++++++++++++++++------
 5 files changed, 155 insertions(+), 20 deletions(-)

diff --git a/ChangeLog b/ChangeLog
index fe61ad9..8ca5395 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,13 @@
+2012-09-13  Simon Josefsson  &lt;simon@josefsson.org&gt;
+
+	* NEWS: Mention Salsa20/8 and Salsa20/12.
+	* salsa20.h (salsa20r8_crypt): New prototype.
+	(salsa20r12_crypt): New prototype.
+	* salsa20-crypt.c (salsa20r8_crypt): New function.
+	(salsa20r12_crypt): New function.
+	(salsa20r_crypt): New function, move logic from salsa20_crypt.
+	* testsuite/salsa20-test.c: Test new functions.
+
 2012-09-10  Niels Möller  &lt;nisse@lysator.liu.se&gt;
 
 	* examples/eratosthenes.c (main): Explicitly deallocate storage
diff --git a/NEWS b/NEWS
index 4957f80..8a96752 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,8 @@
+	New features:
+
+	* Support for the round-reduced Salsa20/8 and Salsa20/12
+          variants.
+
 NEWS for the 2.5 release
 
 	This release includes important portability fixes for Windows
diff --git a/salsa20-crypt.c b/salsa20-crypt.c
index eae3cea..a57cb71 100644
--- a/salsa20-crypt.c
+++ b/salsa20-crypt.c
@@ -55,11 +55,12 @@
   x0 ^= ROTL32(18, x3 + x2);	    \
   } while(0)
 
-void
-salsa20_crypt(struct salsa20_ctx *ctx,
-	      unsigned length,
-	      uint8_t *c,
-	      const uint8_t *m)
+static void
+salsa20r_crypt(struct salsa20_ctx *ctx,
+	       int rounds,
+	       unsigned length,
+	       uint8_t *c,
+	       const uint8_t *m)
 {
   if (!length)
     return;
@@ -69,7 +70,7 @@ salsa20_crypt(struct salsa20_ctx *ctx,
       uint32_t x[_SALSA20_INPUT_LENGTH];
       int i;
       memcpy (x, ctx-&gt;input, sizeof(x));
-      for (i = 0;i &lt; 10;i ++)
+      for (i = 0;i &lt; rounds;i += 2)
 	{
 	  QROUND(x[0], x[4], x[8], x[12]);
 	  QROUND(x[5], x[9], x[13], x[1]);
@@ -104,3 +105,30 @@ salsa20_crypt(struct salsa20_ctx *ctx,
       m += SALSA20_BLOCK_SIZE;
   }
 }
+
+void
+salsa20_crypt(struct salsa20_ctx *ctx,
+	      unsigned length,
+	      uint8_t *c,
+	      const uint8_t *m)
+{
+  salsa20r_crypt(ctx, 20, length, c, m);
+}
+
+void
+salsa20r8_crypt(struct salsa20_ctx *ctx,
+	      unsigned length,
+	      uint8_t *c,
+	      const uint8_t *m)
+{
+  salsa20r_crypt(ctx, 8, length, c, m);
+}
+
+void
+salsa20r12_crypt(struct salsa20_ctx *ctx,
+		 unsigned length,
+		 uint8_t *c,
+		 const uint8_t *m)
+{
+  salsa20r_crypt(ctx, 12, length, c, m);
+}
diff --git a/salsa20.h b/salsa20.h
index 7d47f52..ebb28c7 100644
--- a/salsa20.h
+++ b/salsa20.h
@@ -75,6 +75,18 @@ salsa20_crypt(struct salsa20_ctx *ctx,
 	      unsigned length, uint8_t *dst,
 	      const uint8_t *src);
 
+/* Round-reduced Salsa20/8. */
+void
+salsa20r8_crypt(struct salsa20_ctx *ctx,
+		unsigned length, uint8_t *dst,
+		const uint8_t *src);
+
+/* Round-reduced Salsa20/12. */
+void
+salsa20r12_crypt(struct salsa20_ctx *ctx,
+		 unsigned length, uint8_t *dst,
+		 const uint8_t *src);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/salsa20-test.c b/testsuite/salsa20-test.c
index 7a246b9..8ec6c25 100644
--- a/testsuite/salsa20-test.c
+++ b/testsuite/salsa20-test.c
@@ -13,13 +13,18 @@ memzero_p (const uint8_t *p, size_t n)
   return 1;
 }
 
+typedef void (*salsa20_func) (struct salsa20_ctx *ctx,
+			      unsigned length, uint8_t *dst,
+			      const uint8_t *src);
+
 /* The ecrypt testcases encrypt 512 zero bytes (8 blocks), then give
    the xor of all blocks, and the data for block 0 (0-43), 3,4
    (192-319), 7 (448-511) */
 
 #define STREAM_LENGTH 512
 static void
-test_salsa20_stream(unsigned key_length,
+test_salsa20_stream(salsa20_func crypt,
+		    unsigned key_length,
 		    const uint8_t *key,
 		    const uint8_t *iv,
 		    const uint8_t *ciphertext,
@@ -34,7 +39,7 @@ test_salsa20_stream(unsigned key_length,
   salsa20_set_key(&amp;ctx, key_length, key);
   salsa20_set_iv(&amp;ctx, iv);
   memset(stream, 0, STREAM_LENGTH + 1);
-  salsa20_crypt(&amp;ctx, STREAM_LENGTH, stream, stream);
+  crypt(&amp;ctx, STREAM_LENGTH, stream, stream);
   if (stream[STREAM_LENGTH])
     {
       fprintf(stderr, "Stream of %d bytes wrote too much!\n", STREAM_LENGTH);
@@ -90,7 +95,7 @@ test_salsa20_stream(unsigned key_length,
     {
       memset(data, 0, STREAM_LENGTH + 1);
       salsa20_set_iv(&amp;ctx, iv);
-      salsa20_crypt(&amp;ctx, j, data, data);
+      crypt(&amp;ctx, j, data, data);
 
       if (!MEMEQ(j, data, stream))
 	{
@@ -114,7 +119,8 @@ test_salsa20_stream(unsigned key_length,
 }
 
 static void
-test_salsa20(unsigned key_length,
+test_salsa20(salsa20_func crypt,
+	     unsigned key_length,
 	     const uint8_t *key,
 	     const uint8_t *iv,
 	     unsigned length,
@@ -127,7 +133,7 @@ test_salsa20(unsigned key_length,
   salsa20_set_key(&amp;ctx, key_length, key);
   salsa20_set_iv(&amp;ctx, iv);
   data[length] = 17;
-  salsa20_crypt(&amp;ctx, length, data, cleartext);
+  crypt(&amp;ctx, length, data, cleartext);
   if (data[length] != 17)
     {
       fprintf(stderr, "Encrypt of %u bytes wrote too much!\nInput:", length);
@@ -148,7 +154,7 @@ test_salsa20(unsigned key_length,
     }
   salsa20_set_key(&amp;ctx, key_length, key);
   salsa20_set_iv(&amp;ctx, iv);
-  salsa20_crypt(&amp;ctx, length, data, data);
+  crypt(&amp;ctx, length, data, data);
 
   if (!MEMEQ(length, data, cleartext))
     {
@@ -170,40 +176,47 @@ test_main(void)
 {
   /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/full/verified.test-vectors?logsort=rev&amp;rev=210&amp;view=markup \
*/  
-  test_salsa20(HL("80000000 00000000 00000000 00000000"),
+  test_salsa20(salsa20_crypt,
+	       HL("80000000 00000000 00000000 00000000"),
 	       H("00000000 00000000"),
 	       HL("00000000 00000000"),
 	       H("4DFA5E48 1DA23EA0"));
 
-  test_salsa20(HL("00000000 00000000 00000000 00000000"),
+  test_salsa20(salsa20_crypt,
+	       HL("00000000 00000000 00000000 00000000"),
 	       H("80000000 00000000"),
 	       HL("00000000 00000000"),
 	       H("B66C1E44 46DD9557"));
 
-  test_salsa20(HL("0053A6F94C9FF24598EB3E91E4378ADD"),
+  test_salsa20(salsa20_crypt,
+	       HL("0053A6F94C9FF24598EB3E91E4378ADD"),
 	       H("0D74DB42A91077DE"),
 	       HL("00000000 00000000"),
 	       H("05E1E7BE B697D999"));
 
-  test_salsa20(HL("80000000 00000000 00000000 00000000"
+  test_salsa20(salsa20_crypt,
+	       HL("80000000 00000000 00000000 00000000"
 		  "00000000 00000000 00000000 00000000"),
 	       H("00000000 00000000"),
 	       HL("00000000 00000000"),
 	       H("E3BE8FDD 8BECA2E3"));
 
-  test_salsa20(HL("00000000 00000000 00000000 00000000"
+  test_salsa20(salsa20_crypt,
+	       HL("00000000 00000000 00000000 00000000"
 		  "00000000 00000000 00000000 00000000"),
 	       H("80000000 00000000"),
 	       HL("00000000 00000000"),
 	       H("2ABA3DC45B494700"));
 
-  test_salsa20(HL("0053A6F94C9FF24598EB3E91E4378ADD"
+  test_salsa20(salsa20_crypt,
+	       HL("0053A6F94C9FF24598EB3E91E4378ADD"
 		  "3083D6297CCF2275C81B6EC11467BA0D"),
 	       H("0D74DB42A91077DE"),
 	       HL("00000000 00000000"),
 	       H("F5FAD53F 79F9DF58"));
 
-  test_salsa20_stream(HL("80000000000000000000000000000000"),
+  test_salsa20_stream(salsa20_crypt,
+		      HL("80000000000000000000000000000000"),
 		      H("00000000 00000000"),
 		      H("4DFA5E481DA23EA09A31022050859936"
 			"DA52FCEE218005164F267CB65F5CFD7F"
@@ -226,7 +239,8 @@ test_main(void)
 			"5F13AC74D2539570FD34FEAB06C57205"
 			"3949B59585742181A5A760223AFA22D4"));
 
-  test_salsa20_stream(HL("48494A4B4C4D4E4F5051525354555657"
+  test_salsa20_stream(salsa20_crypt,
+		      HL("48494A4B4C4D4E4F5051525354555657"
 			 "58595A5B5C5D5E5F6061626364656667"),
 		      H("0000000000000000"),
 		      H("53AD3698A011F779AD71030F3EFBEBA0"
@@ -250,5 +264,71 @@ test_main(void)
 			"637C7CA2B78B116F83AFF46E40F8F71D"
 			"4CD6D2E1B750D5E011D1DF2E80F7210A"));
 
+  /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/reduced/8-rounds/verified.test-vectors?rev=210&amp;view=markup \
*/ +
+  test_salsa20(salsa20r8_crypt,
+	       HL("80000000 00000000 00000000 00000000"),
+	       H("00000000 00000000"),
+	       HL("00000000 00000000"),
+	       H("A9C9F888 AB552A2D"));
+
+  test_salsa20_stream(salsa20r8_crypt,
+		      HL("48494A4B4C4D4E4F5051525354555657"
+			 "58595A5B5C5D5E5F6061626364656667"),
+		      H("0000000000000000"),
+		      H("A6CC8B404F2AF4FDAF7D6A8795F7CC5D"
+			"9BB2741B787B51538BF9BDA816486BC0"
+			"D334348DB81317951E1DF416988A0942"
+			"7ECC9214B02B8C4AA816A6014758FE06"
+			"D4FA0D1AB59C779C4BA1B64391356884"
+			"06DA8137C88A3642295C6285E9535438"
+			"D86DAC9C5B88628CD04D99CCEA1EC82E"
+			"F58720BF5AEBC02A453A5601A9CFEE46"
+			"1768DEDD9085B9EA5D36B507855B7413"
+			"63500AEEDFEAE88D6996E45DC8A21BDF"
+			"2553BFD191E2CF697FC4D8D6AC7A3AE8"
+			"AF1B140EBABB5F1B8D1524E087147291"
+			"B53ACC37176F2DD5E48250F1334E40B0"
+			"282FBF02B12953AE229A9175CF973DED"
+			"0B8A637E2E55EE26E7E2E8E962AA4BC0"
+			"98B0B1A82348DEEC1BDE9D370859937F"),
+		      H("9EA2C38E03E01567DD7B969946638AFD"
+			"A0EEAB5E0DAE16E6FD33196B923D57FD"
+			"22964B080FCFC07E64EC5464EFA9EB21"
+			"4ADCFE4792CEAAEABC73DB10E4178FD1"));
+
+  /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/reduced/12-rounds/verified.test-vectors?rev=210&amp;view=markup \
*/ +
+  test_salsa20(salsa20r12_crypt,
+	       HL("80000000 00000000 00000000 00000000"),
+	       H("00000000 00000000"),
+	       HL("00000000 00000000"),
+	       H("FC207DBF C76C5E17"));
+
+  test_salsa20_stream(salsa20r12_crypt,
+		      HL("48494A4B4C4D4E4F5051525354555657"
+			 "58595A5B5C5D5E5F6061626364656667"),
+		      H("0000000000000000"),
+		      H("9E1B005B1072B05213869162B5E9940E"
+			"C8847C4A2D196E421C2BF7ACEA349EB7"
+			"4AFCA3DE0A62416A5B7EA34D90E83EF0"
+			"608B45F727326C1DB59ED8C7A82EF46D"
+			"247D730C7FDE4B1CA99F39D29F535DE1"
+			"3ADBA3493B705CC5E279BBB8B190F325"
+			"2F21E742D8057CB3B4715CC696755540"
+			"AA090950A422AE1C6C9087A6AC3C0314"
+			"D6919E05F350D80BF9927EF17004A684"
+			"02FD3A990388478AFC98760FDCF0DDA6"
+			"0797C78224B0C7899721999C8806D6FC"
+			"2C2CE8D428D273FE5FE8D6AD0F0CEE46"
+			"37B8AE6780C719C5F89E9B13147E915B"
+			"4027B0419F52CC68D287391EB3954ED5"
+			"E7BD1F1B653F146D8D0E6A13E6B8253C"
+			"09FE17E11D5A99F719CD0072CEA40E80"),
+		      H("DD32748517CA537D50CE908F5934461B"
+			"B2BAD80FFD6CA8673B4E72A5F0DBDB08"
+			"03DA7BC2F61AB452D570DF1A589783E7"
+			"3F4216C3244D460147749053F4091E3F"));
+
   SUCCESS();
 }
-- 
1.7.9.5



</body></email><email><emailId>20120914063449</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-14 06:34:49-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; I quickly discovered that I needed the round-reduced variants of
&gt; Salsa20.  Here they are.  I didn't update the assembler part, so I would
&gt; need help finishing that part.

Nice. Key setup is the same, just the number of iterations in the main
loop is different?

&gt; +static void
&gt; +salsa20r_crypt(struct salsa20_ctx *ctx,
&gt; +	       int rounds,
&gt; +	       unsigned length,
&gt; +	       uint8_t *c,
&gt; +	       const uint8_t *m)

This is the function which should be implemented in assembly. Do you
think this should be a public, documented function (in which case
salsa20r_crypt sounds like a reasonable name), or internal, in which
case nettle convention would be something like _salsa20_crypt?

&gt; --- a/testsuite/salsa20-test.c
&gt; +++ b/testsuite/salsa20-test.c
&gt; @@ -13,13 +13,18 @@ memzero_p (const uint8_t *p, size_t n)
&gt;    return 1;
&gt;  }
&gt;  
&gt; +typedef void (*salsa20_func) (struct salsa20_ctx *ctx,
&gt; +			      unsigned length, uint8_t *dst,
&gt; +			      const uint8_t *src);
&gt; +

A very minor point... I've decided to try to stick to non-pointer
typedefs for function types. I.e.,

  typedef void salsa20_func (struct salsa20_ctx *ctx,
			     unsigned length, uint8_t *dst,
			     const uint8_t *src);

That way, it is possible (although maybe not useful very often) to use
the typedef for declaring functions, like

  salsa20_func salsa20_crypt;
  salsa20_func salsa20r8_crypt;
  salsa20_func salsa20r12_crypt;

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120914070051</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-14 07:00:51-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; I quickly discovered that I needed the round-reduced variants of
&gt;&gt; Salsa20.  Here they are.  I didn't update the assembler part, so I would
&gt;&gt; need help finishing that part.
&gt;
&gt; Nice. Key setup is the same, just the number of iterations in the main
&gt; loop is different?

Yes.

&gt;&gt; +static void
&gt;&gt; +salsa20r_crypt(struct salsa20_ctx *ctx,
&gt;&gt; +	       int rounds,
&gt;&gt; +	       unsigned length,
&gt;&gt; +	       uint8_t *c,
&gt;&gt; +	       const uint8_t *m)
&gt;
&gt; This is the function which should be implemented in assembly.

Actually, sleeping on this, I realized that we really want to export the
Salsa20 core primitive (this was what I actually needed), and that is
the primitive that should be implemented in assembler.  I've fixed this
in the attached patch.

The Salsa20 core is a hash function (not your typical hash function
though) described here:

http://cr.yp.to/salsa20.html

If we implement that quickly in assembler, with a variable round
parameter, that will be sufficient to build fast C code around.

All of the Salsa20, Salsa20/8, Salsa20/12 and the stream handling code
could then be written in C.

&gt; Do you think this should be a public, documented function (in which
&gt; case salsa20r_crypt sounds like a reasonable name), or internal, in
&gt; which case nettle convention would be something like _salsa20_crypt?

It should be an internal function, I've fixed this in the patch below.

&gt;&gt; --- a/testsuite/salsa20-test.c
&gt;&gt; +++ b/testsuite/salsa20-test.c
&gt;&gt; @@ -13,13 +13,18 @@ memzero_p (const uint8_t *p, size_t n)
&gt;&gt;    return 1;
&gt;&gt;  }
&gt;&gt;  
&gt;&gt; +typedef void (*salsa20_func) (struct salsa20_ctx *ctx,
&gt;&gt; +			      unsigned length, uint8_t *dst,
&gt;&gt; +			      const uint8_t *src);
&gt;&gt; +
&gt;
&gt; A very minor point... I've decided to try to stick to non-pointer
&gt; typedefs for function types. I.e.,
&gt;
&gt;   typedef void salsa20_func (struct salsa20_ctx *ctx,
&gt; 			     unsigned length, uint8_t *dst,
&gt; 			     const uint8_t *src);
&gt;
&gt; That way, it is possible (although maybe not useful very often) to use
&gt; the typedef for declaring functions, like
&gt;
&gt;   salsa20_func salsa20_crypt;
&gt;   salsa20_func salsa20r8_crypt;
&gt;   salsa20_func salsa20r12_crypt;

Sure.

Updated patch below.

/Simon

["0001-Support-Salsa20-core-and-round-reduced-Salsa20-8-and.patch" (text/x-diff)]

&gt; From 0edbad4db412f42321801a23e12d1931fe36b40c Mon Sep 17 00:00:00 2001
From: Simon Josefsson &lt;simon@josefsson.org&gt;
Date: Thu, 13 Sep 2012 23:55:38 +0200
Subject: [PATCH] Support Salsa20 core and round-reduced Salsa20/8 and
 Salsa20/12.

---
 ChangeLog                |   12 ++++++
 NEWS                     |    5 +++
 salsa20-crypt.c          |   91 +++++++++++++++++++++++++++-----------
 salsa20.h                |   18 ++++++++
 testsuite/salsa20-test.c |  108 ++++++++++++++++++++++++++++++++++++++++------
 5 files changed, 194 insertions(+), 40 deletions(-)

diff --git a/ChangeLog b/ChangeLog
index fe61ad9..c4c7d57 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,15 @@
+2012-09-14  Simon Josefsson  &lt;simon@josefsson.org&gt;
+
+	* NEWS: Mention Salsa20 core, Salsa20/8 and Salsa20/12.
+	* salsa20.h (salsa20r8_crypt): New prototype.
+	(salsa20r12_crypt): New prototype.
+	(salsa20_core): New prototype.
+	* salsa20-crypt.c (salsa20r8_crypt): New function.
+	(salsa20r12_crypt): New function.
+	(salsa20_core): New function.
+	(salsa20r_crypt): New function.
+	* testsuite/salsa20-test.c: Test new functions.
+
 2012-09-10  Niels Möller  &lt;nisse@lysator.liu.se&gt;
 
 	* examples/eratosthenes.c (main): Explicitly deallocate storage
diff --git a/NEWS b/NEWS
index 4957f80..6baddd0 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,8 @@
+	New features:
+
+	* Support for the Salsa20 core and round-reduced Salsa20/8 and
+          Salsa20/12.
+
 NEWS for the 2.5 release
 
 	This release includes important portability fixes for Windows
diff --git a/salsa20-crypt.c b/salsa20-crypt.c
index eae3cea..c7ba863 100644
--- a/salsa20-crypt.c
+++ b/salsa20-crypt.c
@@ -56,42 +56,54 @@
   } while(0)
 
 void
-salsa20_crypt(struct salsa20_ctx *ctx,
-	      unsigned length,
-	      uint8_t *c,
-	      const uint8_t *m)
+salsa20_core (uint32_t src[_SALSA20_INPUT_LENGTH],
+	      uint32_t dst[_SALSA20_INPUT_LENGTH],
+	      unsigned rounds)
+{
+  uint32_t x[_SALSA20_INPUT_LENGTH];
+  unsigned i;
+
+  memcpy (x, src, sizeof(x));
+  for (i = 0;i &lt; rounds;i += 2)
+    {
+      QROUND(x[0], x[4], x[8], x[12]);
+      QROUND(x[5], x[9], x[13], x[1]);
+      QROUND(x[10], x[14], x[2], x[6]);
+      QROUND(x[15], x[3], x[7], x[11]);
+
+      QROUND(x[0], x[1], x[2], x[3]);
+      QROUND(x[5], x[6], x[7], x[4]);
+      QROUND(x[10], x[11], x[8], x[9]);
+      QROUND(x[15], x[12], x[13], x[14]);
+    }
+
+  for (i = 0;i &lt; _SALSA20_INPUT_LENGTH;++i)
+    {
+      uint32_t t = x[i] + src[i];
+      dst[i] = LE_SWAP32 (t);
+    }
+}
+
+static void
+_salsa20_crypt(struct salsa20_ctx *ctx,
+	       int rounds,
+	       unsigned length,
+	       uint8_t *c,
+	       const uint8_t *m)
 {
   if (!length)
     return;
-  
+
   for (;;)
     {
       uint32_t x[_SALSA20_INPUT_LENGTH];
-      int i;
-      memcpy (x, ctx-&gt;input, sizeof(x));
-      for (i = 0;i &lt; 10;i ++)
-	{
-	  QROUND(x[0], x[4], x[8], x[12]);
-	  QROUND(x[5], x[9], x[13], x[1]);
-	  QROUND(x[10], x[14], x[2], x[6]);
-	  QROUND(x[15], x[3], x[7], x[11]);
-
-	  QROUND(x[0], x[1], x[2], x[3]);
-	  QROUND(x[5], x[6], x[7], x[4]);
-	  QROUND(x[10], x[11], x[8], x[9]);
-	  QROUND(x[15], x[12], x[13], x[14]);
-	}
 
-      for (i = 0;i &lt; _SALSA20_INPUT_LENGTH;++i)
-	{
-	  uint32_t t = x[i] + ctx-&gt;input[i];
-	  x[i] = LE_SWAP32 (t);
-	}
+      salsa20_core (ctx-&gt;input, x, rounds);
 
       ctx-&gt;input[9] += (++ctx-&gt;input[8] == 0);
 
       /* stopping at 2^70 length per nonce is user's responsibility */
-      
+
       if (length &lt;= SALSA20_BLOCK_SIZE)
 	{
 	  memxor3 (c, m, (uint8_t *) x, length);
@@ -102,5 +114,32 @@ salsa20_crypt(struct salsa20_ctx *ctx,
       length -= SALSA20_BLOCK_SIZE;
       c += SALSA20_BLOCK_SIZE;
       m += SALSA20_BLOCK_SIZE;
-  }
+    }
+}
+
+void
+salsa20_crypt(struct salsa20_ctx *ctx,
+	      unsigned length,
+	      uint8_t *c,
+	      const uint8_t *m)
+{
+  _salsa20_crypt(ctx, 20, length, c, m);
+}
+
+void
+salsa20r8_crypt(struct salsa20_ctx *ctx,
+	      unsigned length,
+	      uint8_t *c,
+	      const uint8_t *m)
+{
+  _salsa20_crypt(ctx, 8, length, c, m);
+}
+
+void
+salsa20r12_crypt(struct salsa20_ctx *ctx,
+		 unsigned length,
+		 uint8_t *c,
+		 const uint8_t *m)
+{
+  _salsa20_crypt(ctx, 12, length, c, m);
 }
diff --git a/salsa20.h b/salsa20.h
index 7d47f52..29b1c0b 100644
--- a/salsa20.h
+++ b/salsa20.h
@@ -75,6 +75,24 @@ salsa20_crypt(struct salsa20_ctx *ctx,
 	      unsigned length, uint8_t *dst,
 	      const uint8_t *src);
 
+/* Round-reduced Salsa20/8. */
+void
+salsa20r8_crypt(struct salsa20_ctx *ctx,
+		unsigned length, uint8_t *dst,
+		const uint8_t *src);
+
+/* Round-reduced Salsa20/12. */
+void
+salsa20r12_crypt(struct salsa20_ctx *ctx,
+		 unsigned length, uint8_t *dst,
+		 const uint8_t *src);
+
+/* Expose the internal Salsa20 core. */
+void
+salsa20_core (uint32_t src[_SALSA20_INPUT_LENGTH],
+	      uint32_t dst[_SALSA20_INPUT_LENGTH],
+	      unsigned rounds);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/salsa20-test.c b/testsuite/salsa20-test.c
index 7a246b9..3d65c94 100644
--- a/testsuite/salsa20-test.c
+++ b/testsuite/salsa20-test.c
@@ -13,13 +13,18 @@ memzero_p (const uint8_t *p, size_t n)
   return 1;
 }
 
+typedef void salsa20_func (struct salsa20_ctx *ctx,
+			   unsigned length, uint8_t *dst,
+			   const uint8_t *src);
+
 /* The ecrypt testcases encrypt 512 zero bytes (8 blocks), then give
    the xor of all blocks, and the data for block 0 (0-43), 3,4
    (192-319), 7 (448-511) */
 
 #define STREAM_LENGTH 512
 static void
-test_salsa20_stream(unsigned key_length,
+test_salsa20_stream(salsa20_func crypt,
+		    unsigned key_length,
 		    const uint8_t *key,
 		    const uint8_t *iv,
 		    const uint8_t *ciphertext,
@@ -34,7 +39,7 @@ test_salsa20_stream(unsigned key_length,
   salsa20_set_key(&amp;ctx, key_length, key);
   salsa20_set_iv(&amp;ctx, iv);
   memset(stream, 0, STREAM_LENGTH + 1);
-  salsa20_crypt(&amp;ctx, STREAM_LENGTH, stream, stream);
+  crypt(&amp;ctx, STREAM_LENGTH, stream, stream);
   if (stream[STREAM_LENGTH])
     {
       fprintf(stderr, "Stream of %d bytes wrote too much!\n", STREAM_LENGTH);
@@ -90,7 +95,7 @@ test_salsa20_stream(unsigned key_length,
     {
       memset(data, 0, STREAM_LENGTH + 1);
       salsa20_set_iv(&amp;ctx, iv);
-      salsa20_crypt(&amp;ctx, j, data, data);
+      crypt(&amp;ctx, j, data, data);
 
       if (!MEMEQ(j, data, stream))
 	{
@@ -114,7 +119,8 @@ test_salsa20_stream(unsigned key_length,
 }
 
 static void
-test_salsa20(unsigned key_length,
+test_salsa20(salsa20_func crypt,
+	     unsigned key_length,
 	     const uint8_t *key,
 	     const uint8_t *iv,
 	     unsigned length,
@@ -127,7 +133,7 @@ test_salsa20(unsigned key_length,
   salsa20_set_key(&amp;ctx, key_length, key);
   salsa20_set_iv(&amp;ctx, iv);
   data[length] = 17;
-  salsa20_crypt(&amp;ctx, length, data, cleartext);
+  crypt(&amp;ctx, length, data, cleartext);
   if (data[length] != 17)
     {
       fprintf(stderr, "Encrypt of %u bytes wrote too much!\nInput:", length);
@@ -148,7 +154,7 @@ test_salsa20(unsigned key_length,
     }
   salsa20_set_key(&amp;ctx, key_length, key);
   salsa20_set_iv(&amp;ctx, iv);
-  salsa20_crypt(&amp;ctx, length, data, data);
+  crypt(&amp;ctx, length, data, data);
 
   if (!MEMEQ(length, data, cleartext))
     {
@@ -170,40 +176,47 @@ test_main(void)
 {
   /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/full/verified.test-vectors?logsort=rev&amp;rev=210&amp;view=markup \
*/  
-  test_salsa20(HL("80000000 00000000 00000000 00000000"),
+  test_salsa20(salsa20_crypt,
+	       HL("80000000 00000000 00000000 00000000"),
 	       H("00000000 00000000"),
 	       HL("00000000 00000000"),
 	       H("4DFA5E48 1DA23EA0"));
 
-  test_salsa20(HL("00000000 00000000 00000000 00000000"),
+  test_salsa20(salsa20_crypt,
+	       HL("00000000 00000000 00000000 00000000"),
 	       H("80000000 00000000"),
 	       HL("00000000 00000000"),
 	       H("B66C1E44 46DD9557"));
 
-  test_salsa20(HL("0053A6F94C9FF24598EB3E91E4378ADD"),
+  test_salsa20(salsa20_crypt,
+	       HL("0053A6F94C9FF24598EB3E91E4378ADD"),
 	       H("0D74DB42A91077DE"),
 	       HL("00000000 00000000"),
 	       H("05E1E7BE B697D999"));
 
-  test_salsa20(HL("80000000 00000000 00000000 00000000"
+  test_salsa20(salsa20_crypt,
+	       HL("80000000 00000000 00000000 00000000"
 		  "00000000 00000000 00000000 00000000"),
 	       H("00000000 00000000"),
 	       HL("00000000 00000000"),
 	       H("E3BE8FDD 8BECA2E3"));
 
-  test_salsa20(HL("00000000 00000000 00000000 00000000"
+  test_salsa20(salsa20_crypt,
+	       HL("00000000 00000000 00000000 00000000"
 		  "00000000 00000000 00000000 00000000"),
 	       H("80000000 00000000"),
 	       HL("00000000 00000000"),
 	       H("2ABA3DC45B494700"));
 
-  test_salsa20(HL("0053A6F94C9FF24598EB3E91E4378ADD"
+  test_salsa20(salsa20_crypt,
+	       HL("0053A6F94C9FF24598EB3E91E4378ADD"
 		  "3083D6297CCF2275C81B6EC11467BA0D"),
 	       H("0D74DB42A91077DE"),
 	       HL("00000000 00000000"),
 	       H("F5FAD53F 79F9DF58"));
 
-  test_salsa20_stream(HL("80000000000000000000000000000000"),
+  test_salsa20_stream(salsa20_crypt,
+		      HL("80000000000000000000000000000000"),
 		      H("00000000 00000000"),
 		      H("4DFA5E481DA23EA09A31022050859936"
 			"DA52FCEE218005164F267CB65F5CFD7F"
@@ -226,7 +239,8 @@ test_main(void)
 			"5F13AC74D2539570FD34FEAB06C57205"
 			"3949B59585742181A5A760223AFA22D4"));
 
-  test_salsa20_stream(HL("48494A4B4C4D4E4F5051525354555657"
+  test_salsa20_stream(salsa20_crypt,
+		      HL("48494A4B4C4D4E4F5051525354555657"
 			 "58595A5B5C5D5E5F6061626364656667"),
 		      H("0000000000000000"),
 		      H("53AD3698A011F779AD71030F3EFBEBA0"
@@ -250,5 +264,71 @@ test_main(void)
 			"637C7CA2B78B116F83AFF46E40F8F71D"
 			"4CD6D2E1B750D5E011D1DF2E80F7210A"));
 
+  /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/reduced/8-rounds/verified.test-vectors?rev=210&amp;view=markup \
*/ +
+  test_salsa20(salsa20r8_crypt,
+	       HL("80000000 00000000 00000000 00000000"),
+	       H("00000000 00000000"),
+	       HL("00000000 00000000"),
+	       H("A9C9F888 AB552A2D"));
+
+  test_salsa20_stream(salsa20r8_crypt,
+		      HL("48494A4B4C4D4E4F5051525354555657"
+			 "58595A5B5C5D5E5F6061626364656667"),
+		      H("0000000000000000"),
+		      H("A6CC8B404F2AF4FDAF7D6A8795F7CC5D"
+			"9BB2741B787B51538BF9BDA816486BC0"
+			"D334348DB81317951E1DF416988A0942"
+			"7ECC9214B02B8C4AA816A6014758FE06"
+			"D4FA0D1AB59C779C4BA1B64391356884"
+			"06DA8137C88A3642295C6285E9535438"
+			"D86DAC9C5B88628CD04D99CCEA1EC82E"
+			"F58720BF5AEBC02A453A5601A9CFEE46"
+			"1768DEDD9085B9EA5D36B507855B7413"
+			"63500AEEDFEAE88D6996E45DC8A21BDF"
+			"2553BFD191E2CF697FC4D8D6AC7A3AE8"
+			"AF1B140EBABB5F1B8D1524E087147291"
+			"B53ACC37176F2DD5E48250F1334E40B0"
+			"282FBF02B12953AE229A9175CF973DED"
+			"0B8A637E2E55EE26E7E2E8E962AA4BC0"
+			"98B0B1A82348DEEC1BDE9D370859937F"),
+		      H("9EA2C38E03E01567DD7B969946638AFD"
+			"A0EEAB5E0DAE16E6FD33196B923D57FD"
+			"22964B080FCFC07E64EC5464EFA9EB21"
+			"4ADCFE4792CEAAEABC73DB10E4178FD1"));
+
+  /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/reduced/12-rounds/verified.test-vectors?rev=210&amp;view=markup \
*/ +
+  test_salsa20(salsa20r12_crypt,
+	       HL("80000000 00000000 00000000 00000000"),
+	       H("00000000 00000000"),
+	       HL("00000000 00000000"),
+	       H("FC207DBF C76C5E17"));
+
+  test_salsa20_stream(salsa20r12_crypt,
+		      HL("48494A4B4C4D4E4F5051525354555657"
+			 "58595A5B5C5D5E5F6061626364656667"),
+		      H("0000000000000000"),
+		      H("9E1B005B1072B05213869162B5E9940E"
+			"C8847C4A2D196E421C2BF7ACEA349EB7"
+			"4AFCA3DE0A62416A5B7EA34D90E83EF0"
+			"608B45F727326C1DB59ED8C7A82EF46D"
+			"247D730C7FDE4B1CA99F39D29F535DE1"
+			"3ADBA3493B705CC5E279BBB8B190F325"
+			"2F21E742D8057CB3B4715CC696755540"
+			"AA090950A422AE1C6C9087A6AC3C0314"
+			"D6919E05F350D80BF9927EF17004A684"
+			"02FD3A990388478AFC98760FDCF0DDA6"
+			"0797C78224B0C7899721999C8806D6FC"
+			"2C2CE8D428D273FE5FE8D6AD0F0CEE46"
+			"37B8AE6780C719C5F89E9B13147E915B"
+			"4027B0419F52CC68D287391EB3954ED5"
+			"E7BD1F1B653F146D8D0E6A13E6B8253C"
+			"09FE17E11D5A99F719CD0072CEA40E80"),
+		      H("DD32748517CA537D50CE908F5934461B"
+			"B2BAD80FFD6CA8673B4E72A5F0DBDB08"
+			"03DA7BC2F61AB452D570DF1A589783E7"
+			"3F4216C3244D460147749053F4091E3F"));
+
   SUCCESS();
 }
-- 
1.7.9.5



</body></email><email><emailId>20120914084204</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-14 08:42:04-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Actually, sleeping on this, I realized that we really want to export the
&gt; Salsa20 core primitive (this was what I actually needed), and that is
&gt; the primitive that should be implemented in assembler.  I've fixed this
&gt; in the attached patch.
&gt;
&gt; The Salsa20 core is a hash function (not your typical hash function
&gt; though) described here:

I guess it could be named salsa20_hash, then? (I think there was such a
function in a previous version of the code).

&gt; If we implement that quickly in assembler, with a variable round
&gt; parameter, that will be sufficient to build fast C code around.

Then you'd first write the hash output to memory, then read it back to
xor it with the message. Since sals20 is pretty fast, I think you'll get
a measurablle performance penalty compared to the currrent code which
keeps the hash output in registers until it is xored to the message. You
really need to get just the hash output, without xoring it to anything?

It would definitely be cleaner to have the hash function separately.

&gt; +salsa20_core (uint32_t src[_SALSA20_INPUT_LENGTH],
&gt; +	      uint32_t dst[_SALSA20_INPUT_LENGTH],
&gt; +	      unsigned rounds)
[...]
&gt; +  for (i = 0;i &lt; _SALSA20_INPUT_LENGTH;++i)
&gt; +    {
&gt; +      uint32_t t = x[i] + src[i];
&gt; +      dst[i] = LE_SWAP32 (t);
&gt; +    }
&gt; +}

This makes for a very peculiar interface for a non-internal function. It
would make more sense from an interface perspectivve to either not do
these byte swaps, or have the output parameter be of type uint8_t *. Or
do something like the union gcm_block in gcm.h (although that's also not
pretty), if we want to be able to store the byte swapped value with a
word-sized store.

I don't remember precisely the background of the current implementation,
but I think the point was to do as much as possible of the processing as
word operations, including the byte swapping.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120914104337</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-14 10:43:37-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; Actually, sleeping on this, I realized that we really want to export the
&gt;&gt; Salsa20 core primitive (this was what I actually needed), and that is
&gt;&gt; the primitive that should be implemented in assembler.  I've fixed this
&gt;&gt; in the attached patch.
&gt;&gt;
&gt;&gt; The Salsa20 core is a hash function (not your typical hash function
&gt;&gt; though) described here:
&gt;
&gt; I guess it could be named salsa20_hash, then? (I think there was such a
&gt; function in a previous version of the code).

The name of the hash is "Salsa20 core" but I think little effort has
gone into tightening up the documentation around the Salsa20 hash (for
example, there are no test vectors that I could find).  salsa20_hash
works for me, but could be confusing as it isn't a normal hash.

&gt;&gt; If we implement that quickly in assembler, with a variable round
&gt;&gt; parameter, that will be sufficient to build fast C code around.
&gt;
&gt; Then you'd first write the hash output to memory, then read it back to
&gt; xor it with the message. Since sals20 is pretty fast, I think you'll get
&gt; a measurablle performance penalty compared to the currrent code which
&gt; keeps the hash output in registers until it is xored to the message.

Right, good point.

&gt; You really need to get just the hash output, without xoring it to
&gt; anything?

Yes, although if necessary I could xor it to a zero buffer if there were
no other way...  however I'll loose performance, and my application
(scrypt) would benefit from good performance.

&gt; It would definitely be cleaner to have the hash function separately.

I agree.

&gt;&gt; +salsa20_core (uint32_t src[_SALSA20_INPUT_LENGTH],
&gt;&gt; +	      uint32_t dst[_SALSA20_INPUT_LENGTH],
&gt;&gt; +	      unsigned rounds)
&gt; [...]
&gt;&gt; +  for (i = 0;i &lt; _SALSA20_INPUT_LENGTH;++i)
&gt;&gt; +    {
&gt;&gt; +      uint32_t t = x[i] + src[i];
&gt;&gt; +      dst[i] = LE_SWAP32 (t);
&gt;&gt; +    }
&gt;&gt; +}
&gt;
&gt; This makes for a very peculiar interface for a non-internal function. It
&gt; would make more sense from an interface perspectivve to either not do
&gt; these byte swaps, or have the output parameter be of type uint8_t *. Or
&gt; do something like the union gcm_block in gcm.h (although that's also not
&gt; pretty), if we want to be able to store the byte swapped value with a
&gt; word-sized store.

Let's use uint8_t.  The first sentence of the Salsa20 core webpage is:

   The Salsa20 core is a function from 64-byte strings to 64-byte
   strings: the Salsa20 core reads a 64-byte string x and produces a
   64-byte string Salsa20(x).

So that is consistent with uint8_t.

&gt; I don't remember precisely the background of the current implementation,
&gt; but I think the point was to do as much as possible of the processing as
&gt; word operations, including the byte swapping.

Yes that will be faster I suppose.

/Simon

</body></email><email><emailId>20121106162413</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-11-06 16:24:13-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; Actually, sleeping on this, I realized that we really want to export the
&gt;&gt; Salsa20 core primitive (this was what I actually needed), and that is
&gt;&gt; the primitive that should be implemented in assembler.
&gt;
&gt; Now that this is in, did you make any use of it yet? I don't quite
&gt; remember what your application was.

For some reason I had missed that this went in, thanks for commiting
this.  How about the attached final cleanup patch, to export the Salsa20
core?  I think that is consistent with the approach you outlined.

My application was scrypt, and I'll update my implementation to use the
latest Nettle interfaces soon.  I'll submit the scrypt part later on...

/Simon

["0001-Add-salsa20_core-function.patch" (text/x-diff)]

&gt; From e03d9fd45bf0693eb358ea0db57cfb5d0c423922 Mon Sep 17 00:00:00 2001
From: Simon Josefsson &lt;simon@josefsson.org&gt;
Date: Tue, 6 Nov 2012 17:12:25 +0100
Subject: [PATCH] Add salsa20_core function.

---
 ChangeLog                |    9 ++++++++
 Makefile.in              |    2 +-
 NEWS                     |    3 +++
 nettle.texinfo           |    6 ++++++
 salsa20-core.c           |   53 ++++++++++++++++++++++++++++++++++++++++++++++
 salsa20.h                |    5 +++++
 testsuite/salsa20-test.c |   16 ++++++++++++++
 7 files changed, 93 insertions(+), 1 deletion(-)
 create mode 100644 salsa20-core.c

diff --git a/ChangeLog b/ChangeLog
index e28b074..8f8f797 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,12 @@
+2012-11-06  Simon Josefsson  &lt;simon@josefsson.org&gt;
+
+	* NEWS: Mention Salsa20 core.
+	* nettle.texinfo: Document salsa20_core.
+	* Makefile.in (nettle_SOURCES): Add salsa20-core.c.
+	* salsa20.h (salsa20_core): Add.
+	* salsa20-core.c: New file.
+	* testsuite/salsa20-test.c (test_main): Self-check salsa20_core.
+
 2012-10-29  Niels Möller  &lt;nisse@lysator.liu.se&gt;
 
 	From Martin Storsjö:
diff --git a/Makefile.in b/Makefile.in
index c0ca3ad..a0d705d 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -83,7 +83,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
 		 salsa20-core-internal.c \
-		 salsa20-crypt.c salsa20-set-key.c \
+		 salsa20-crypt.c salsa20-core.c salsa20-set-key.c \
 		 sha1.c sha1-compress.c sha1-meta.c \
 		 sha256.c sha256-compress.c sha224-meta.c sha256-meta.c \
 		 sha512.c sha512-compress.c sha384-meta.c sha512-meta.c \
diff --git a/NEWS b/NEWS
index 8f7e9e6..a40d6cc 100644
--- a/NEWS
+++ b/NEWS
@@ -2,6 +2,9 @@ NEWS for the 2.6 release
 
 	New features:
 
+	* Support for the Salsa20 core.  Contributed by Simon
+          Josefsson.
+
 	* Support for PKCS #5 PBKDF2.  Contributed by Simon Josefsson.
           Specification in RFC 2898 and test vectors in RFC 6070.
 
diff --git a/nettle.texinfo b/nettle.texinfo
index bfaf0a6..4eb1b13 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -1335,6 +1335,12 @@ all but the last call @emph{must} use a length that is a \
multiple of  
 @end deftypefun
 
+@deftypefun void salsa20_core (uint8_t *@var{dst}, const uint8_t *@var{src}, \
unsigned @var{rounds}) +Hash the 64-byte (@code{SALSA20_BLOCK_SIZE}) message into a \
64-byte +message, using the indicated number of Salsa20 core rounds.
+
+@end deftypefun
+
 @subsection SERPENT
 SERPENT is one of the AES finalists, designed by Ross Anderson, Eli
 Biham and Lars Knudsen. Thus, the interface and properties are similar
diff --git a/salsa20-core.c b/salsa20-core.c
new file mode 100644
index 0000000..3280e54
--- /dev/null
+++ b/salsa20-core.c
@@ -0,0 +1,53 @@
+/* salsa20-core.c
+ *
+ * The Salsa20 core hash.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;string.h&gt;
+
+#include "salsa20.h"
+
+#include "macros.h"
+#include "memxor.h"
+
+void
+salsa20_core (uint8_t *dst,
+	      const uint8_t *src,
+	      unsigned rounds)
+{
+  uint32_t dst32[_SALSA20_INPUT_LENGTH];
+  uint32_t src32[_SALSA20_INPUT_LENGTH];
+  unsigned i;
+
+  for (i = 0; i &lt; _SALSA20_INPUT_LENGTH; i++)
+    src32[i] = LE_READ_UINT32(&amp;src[i * 4]);
+
+  _salsa20_core (dst32, src32, rounds);
+
+  for (i = 0; i &lt; _SALSA20_INPUT_LENGTH; i++)
+    LE_WRITE_UINT32(&amp;dst[i * sizeof (uint32_t)], dst32[i]);
+}
diff --git a/salsa20.h b/salsa20.h
index d95d002..95ee6a1 100644
--- a/salsa20.h
+++ b/salsa20.h
@@ -37,6 +37,7 @@ extern "C" {
 #define salsa20_set_key nettle_salsa20_set_key
 #define salsa20_set_iv nettle_salsa20_set_iv
 #define salsa20_crypt nettle_salsa20_crypt
+#define salsa20_core nettle_salsa20_core
 #define _salsa20_core _nettle_salsa20_core
 
 /* Minimum and maximum keysizes, and a reasonable default. In
@@ -76,6 +77,10 @@ salsa20_crypt(struct salsa20_ctx *ctx,
 	      unsigned length, uint8_t *dst,
 	      const uint8_t *src);
 
+/* Salsa20 core hash function.  Warning: not collision resistant. */
+void
+salsa20_core(uint8_t *dst, const uint8_t *src, unsigned rounds);
+
 void
 _salsa20_core(uint32_t *dst, const uint32_t *src, unsigned rounds);
 
diff --git a/testsuite/salsa20-test.c b/testsuite/salsa20-test.c
index d742ce4..093fb78 100644
--- a/testsuite/salsa20-test.c
+++ b/testsuite/salsa20-test.c
@@ -177,6 +177,22 @@ test_salsa20(const struct tstring *key,
 void
 test_main(void)
 {
+  /* http://tools.ietf.org/html/draft-josefsson-scrypt-kdf */
+
+  {
+    uint8_t dst[SALSA20_BLOCK_SIZE];
+
+    salsa20_core (dst, H("7e879a214f3ec9867ca940e641718f26"
+			 "baee555b8c61c1b50df846116dcd3b1d"
+			 "ee24f319df9b3d8514121e4b5ac5aa32"
+			 "76021d2909c74829edebc68db8b8c25e"), 8);
+    ASSERT(MEMEQ (SALSA20_BLOCK_SIZE, dst,
+		  H("a41f859c6608cc993b81cacb020cef05"
+		    "044b2181a2fd337dfd7b1c6396682f29"
+		    "b4393168e3c9e6bcfe6bc5b7a06d96ba"
+		    "e424cc102c91745c24ad673dc7618f81")));
+  }
+
   /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/full/verified.test-vectors?logsort=rev&amp;rev=210&amp;view=markup \
*/  
   test_salsa20(SHEX("80000000 00000000 00000000 00000000"),
-- 
1.7.9.5



</body></email><email><emailId>20121106165643</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-11-06 16:56:43-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

Also when updating NEWS I noticed that it says:

	* Support for the salsa20 block cipher, including x86_64

Obviously, Salsa20 is a stram cipher, not a block cipher.  Do you want
to fix that (it was for the already released version 2.5 release)?

/Simon

</body></email><email><emailId>20121106172735</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-06 17:27:35-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; For some reason I had missed that this went in, thanks for commiting
&gt; this.  How about the attached final cleanup patch, to export the Salsa20
&gt; core?  I think that is consistent with the approach you outlined.

I've had a quick look, and I think it makes sense. But I'm not sure if
it gets byteorder right.

&gt; +void
&gt; +salsa20_core (uint8_t *dst,
&gt; +	      const uint8_t *src,
&gt; +	      unsigned rounds)
&gt; +{
[...]
&gt; +  _salsa20_core (dst32, src32, rounds);
&gt; +
&gt; +  for (i = 0; i &lt; _SALSA20_INPUT_LENGTH; i++)
&gt; +    LE_WRITE_UINT32(&amp;dst[i * sizeof (uint32_t)], dst32[i]);
&gt; +}

_salsa20_core produces byteswapped output (a somewhat peculiar
interface, but it's an internal function, the reason is to be able do do
any needed swap with word operations). So I think it should be a plain
memcpy above.

Testing on both little-endian and big-endian would be nice (I should try
to get xenofarm up and running again, but last time I tried the git
support seemed somewhat lacking).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121106194037</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-06 19:40:37-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Also when updating NEWS I noticed that it says:
&gt;
&gt; 	* Support for the salsa20 block cipher, including x86_64
&gt;
&gt; Obviously, Salsa20 is a stram cipher, not a block cipher.  Do you want
&gt; to fix that (it was for the already released version 2.5 release)?

Fixed that now. A bit silly to edit an old NEWS entry, but typos and
errors like this should not be left around.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121127195117</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2012-11-27 19:51:17-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>


On 11/06/2012 12:27 PM, Niels Möller wrote:
&gt; _salsa20_core produces byteswapped output (a somewhat peculiar
&gt; interface, but it's an internal function, the reason is to be able do do
&gt; any needed swap with word operations). So I think it should be a plain
&gt; memcpy above.
&gt; 
&gt; Testing on both little-endian and big-endian would be nice

I've tested on a powerpc machine running debian sid, starting at the
current HEAD (1c7d767b4ca224e26b7d7d3875d2d89201accb29); at the HEAD,
"make check" passes all tests with no problems.

With simon's 0001-Add-salsa20_core-function.patch applied (i manually
tuned the Changelog entry), i get:

PASS: gosthash94
PASS: ripemd160
Assert failed 193: MEMEQ (SALSA20_BLOCK_SIZE, dst,
H("a41f859c6608cc993b81cacb020cef05" "044b2181a2fd337dfd7b1c6396682f29"
"b4393168e3c9e6bcfe6bc5b7a06d96ba" "e424cc102c91745c24ad673dc7618f81"))
Aborted
FAIL: salsa20
PASS: sha1

I'd be happy to figure out how to give access to this powerpc machine if
any of y'all want it, or to make other changes and test them on this
big-endian machine.

hth,

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20121127212023</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-27 21:20:23-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; I'd be happy to figure out how to give access to this powerpc machine if
&gt; any of y'all want it,

I have access to a couple of big endian machines (the most convenient
for me being a sparc), but I don't run tests on them very regularly.

&gt; or to make other changes and test them on this big-endian machine.

Now we get to patching patches, which gets a bit messy, but I suspect it
will work fine if you replace

  for (i = 0; i &lt; _SALSA20_INPUT_LENGTH; i++)
    LE_WRITE_UINT32(&amp;dst[i * sizeof (uint32_t)], dst32[i]);

at the end of Simon's salsa20_core.c:salsa20_core by

  /* _salsa20_core does any needed byteswapping of the output. A memcpy
     is needed to support unaligned dst; simply casting like
     _salsa20_core ((uint32_t *) dst, src32, rounds) is not portable. */
  memcpy (dst, dst32, sizeof (dst32));

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121127234026</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2012-11-27 23:40:26-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

[Attachment #2 (multipart/mixed)]


On 11/27/2012 04:20 PM, Niels Möller wrote:
&gt; Now we get to patching patches, which gets a bit messy, but I suspect it
&gt; will work fine if you replace
&gt; 
&gt;   for (i = 0; i &lt; _SALSA20_INPUT_LENGTH; i++)
&gt;     LE_WRITE_UINT32(&amp;dst[i * sizeof (uint32_t)], dst32[i]);
&gt; 
&gt; at the end of Simon's salsa20_core.c:salsa20_core by
&gt; 
&gt;   /* _salsa20_core does any needed byteswapping of the output. A memcpy
&gt;      is needed to support unaligned dst; simply casting like
&gt;      _salsa20_core ((uint32_t *) dst, src32, rounds) is not portable. */
&gt;   memcpy (dst, dst32, sizeof (dst32));

Thanks, that's now tested and "make check" passes on both powerpc and i386.

I've attached a revised version of the patch containing the above change.

Regards,

	--dkg

["0001-Add-salsa20_core-function.patch" (text/x-patch)]

From 55caf2038bd1deecdd50f24e98243d8a8fce81d5 Mon Sep 17 00:00:00 2001
From: Simon Josefsson &lt;simon@josefsson.org&gt;
Date: Tue, 27 Nov 2012 14:46:20 -0500
Subject: [PATCH] Add salsa20_core function

---
 ChangeLog                |    9 ++++++++
 Makefile.in              |    2 +-
 NEWS                     |    3 +++
 nettle.texinfo           |    6 +++++
 salsa20-core.c           |   55 ++++++++++++++++++++++++++++++++++++++++++++++
 salsa20.h                |    5 +++++
 testsuite/salsa20-test.c |   16 ++++++++++++++
 7 files changed, 95 insertions(+), 1 deletion(-)
 create mode 100644 salsa20-core.c

diff --git a/ChangeLog b/ChangeLog
index 3c38a0d..51544a1 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,12 @@
+2012-11-27  Simon Josefsson  &lt;simon@josefsson.org&gt;
+
+	* NEWS: Mention Salsa20 core.
+	* nettle.texinfo: Document salsa20_core.
+	* Makefile.in (nettle_SOURCES): Add salsa20-core.c.
+	* salsa20.h (salsa20_core): Add.
+	* salsa20-core.c: New file.
+	* testsuite/salsa20-test.c (test_main): Self-check salsa20_core.
+
 2012-11-15  Niels Möller  &lt;nisse@lysator.liu.se&gt;
 
 	* sha3-permute.c (sha3_permute): Use ULL suffix on round
diff --git a/Makefile.in b/Makefile.in
index c30149b..8372def 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -84,7 +84,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gosthash94.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
 		 salsa20-core-internal.c \
-		 salsa20-crypt.c salsa20-set-key.c \
+		 salsa20-crypt.c salsa20-core.c salsa20-set-key.c \
 		 sha1.c sha1-compress.c sha1-meta.c \
 		 sha256.c sha256-compress.c sha224-meta.c sha256-meta.c \
 		 sha512.c sha512-compress.c sha384-meta.c sha512-meta.c \
diff --git a/NEWS b/NEWS
index 35439e2..2ffccb9 100644
--- a/NEWS
+++ b/NEWS
@@ -2,6 +2,9 @@ NEWS for the 2.6 release
 
 	New features:
 
+	* Support for the Salsa20 core.  Contributed by Simon
+          Josefsson.
+
 	* Support for PKCS #5 PBKDF2.  Contributed by Simon Josefsson.
           Specification in RFC 2898 and test vectors in RFC 6070.
 
diff --git a/nettle.texinfo b/nettle.texinfo
index ea4b158..840fcb1 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -1378,6 +1378,12 @@ all but the last call @emph{must} use a length that is a \
multiple of  
 @end deftypefun
 
+@deftypefun void salsa20_core (uint8_t *@var{dst}, const uint8_t *@var{src}, \
unsigned @var{rounds}) +Hash the 64-byte (@code{SALSA20_BLOCK_SIZE}) message into a \
64-byte +message, using the indicated number of Salsa20 core rounds.
+
+@end deftypefun
+
 @subsection SERPENT
 SERPENT is one of the AES finalists, designed by Ross Anderson, Eli
 Biham and Lars Knudsen. Thus, the interface and properties are similar
diff --git a/salsa20-core.c b/salsa20-core.c
new file mode 100644
index 0000000..bd88973
--- /dev/null
+++ b/salsa20-core.c
@@ -0,0 +1,55 @@
+/* salsa20-core.c
+ *
+ * The Salsa20 core hash.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;string.h&gt;
+
+#include "salsa20.h"
+
+#include "macros.h"
+#include "memxor.h"
+
+void
+salsa20_core (uint8_t *dst,
+	      const uint8_t *src,
+	      unsigned rounds)
+{
+  uint32_t dst32[_SALSA20_INPUT_LENGTH];
+  uint32_t src32[_SALSA20_INPUT_LENGTH];
+  unsigned i;
+
+  for (i = 0; i &lt; _SALSA20_INPUT_LENGTH; i++)
+    src32[i] = LE_READ_UINT32(&amp;src[i * 4]);
+
+  _salsa20_core (dst32, src32, rounds);
+
+  /* _salsa20_core does any needed byteswapping of the output. A memcpy
+     is needed to support unaligned dst; simply casting like
+     _salsa20_core ((uint32_t *) dst, src32, rounds) is not portable. */
+  memcpy (dst, dst32, sizeof (dst32));
+}
diff --git a/salsa20.h b/salsa20.h
index d95d002..95ee6a1 100644
--- a/salsa20.h
+++ b/salsa20.h
@@ -37,6 +37,7 @@ extern "C" {
 #define salsa20_set_key nettle_salsa20_set_key
 #define salsa20_set_iv nettle_salsa20_set_iv
 #define salsa20_crypt nettle_salsa20_crypt
+#define salsa20_core nettle_salsa20_core
 #define _salsa20_core _nettle_salsa20_core
 
 /* Minimum and maximum keysizes, and a reasonable default. In
@@ -76,6 +77,10 @@ salsa20_crypt(struct salsa20_ctx *ctx,
 	      unsigned length, uint8_t *dst,
 	      const uint8_t *src);
 
+/* Salsa20 core hash function.  Warning: not collision resistant. */
+void
+salsa20_core(uint8_t *dst, const uint8_t *src, unsigned rounds);
+
 void
 _salsa20_core(uint32_t *dst, const uint32_t *src, unsigned rounds);
 
diff --git a/testsuite/salsa20-test.c b/testsuite/salsa20-test.c
index d742ce4..093fb78 100644
--- a/testsuite/salsa20-test.c
+++ b/testsuite/salsa20-test.c
@@ -177,6 +177,22 @@ test_salsa20(const struct tstring *key,
 void
 test_main(void)
 {
+  /* http://tools.ietf.org/html/draft-josefsson-scrypt-kdf */
+
+  {
+    uint8_t dst[SALSA20_BLOCK_SIZE];
+
+    salsa20_core (dst, H("7e879a214f3ec9867ca940e641718f26"
+			 "baee555b8c61c1b50df846116dcd3b1d"
+			 "ee24f319df9b3d8514121e4b5ac5aa32"
+			 "76021d2909c74829edebc68db8b8c25e"), 8);
+    ASSERT(MEMEQ (SALSA20_BLOCK_SIZE, dst,
+		  H("a41f859c6608cc993b81cacb020cef05"
+		    "044b2181a2fd337dfd7b1c6396682f29"
+		    "b4393168e3c9e6bcfe6bc5b7a06d96ba"
+		    "e424cc102c91745c24ad673dc7618f81")));
+  }
+
   /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/full/verified.test-vectors?logsort=rev&amp;rev=210&amp;view=markup \
*/  
   test_salsa20(SHEX("80000000 00000000 00000000 00000000"),
-- 
1.7.10.4


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20121128014733</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-11-28 01:47:33-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt;&gt;   /* _salsa20_core does any needed byteswapping of the output. A memcpy
&gt;&gt;      is needed to support unaligned dst; simply casting like
&gt;&gt;      _salsa20_core ((uint32_t *) dst, src32, rounds) is not portable. */
&gt;&gt;   memcpy (dst, dst32, sizeof (dst32));
&gt;
&gt; Thanks, that's now tested and "make check" passes on both powerpc and i386.

Thanks for testing.  I was about to update this patch too, but then it
occured to me that this interface:

&gt; +void
&gt; +salsa20_core (uint8_t *dst,
&gt; +	      const uint8_t *src,
&gt; +	      unsigned rounds)

is not ideal -- the reason is that the Salsa20 core is not defined with
a parametrised number of rounds, so the interface is somewhat of a
bastardisation.

In my work space, I have used the namespace 'salsa20r_core' instead.
This opens up for later addition of a true 'salsa20_core' function which
would use the official 20 rounds.

What do you think?

The patch below is update to apply against latest master.

/Simon

["0001-Add-salsa20r_core-function.patch" (text/x-diff)]

&gt; From d33b64426e34818c9297de22bfd2cf80daa9472b Mon Sep 17 00:00:00 2001
From: Simon Josefsson &lt;simon@josefsson.org&gt;
Date: Wed, 28 Nov 2012 02:42:53 +0100
Subject: [PATCH] Add salsa20r_core function.

---
 ChangeLog                |    9 ++++++++
 Makefile.in              |    2 +-
 NEWS                     |    2 ++
 nettle.texinfo           |    6 +++++
 salsa20-core.c           |   55 ++++++++++++++++++++++++++++++++++++++++++++++
 salsa20.h                |    5 +++++
 testsuite/salsa20-test.c |   36 ++++++++++++++++++++++++++++++
 7 filer ändrade, 114 tillägg(+), 1 borttagning(-)
 create mode 100644 salsa20-core.c

diff --git a/ChangeLog b/ChangeLog
index 3c38a0d..0299403 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,12 @@
+2012-11-06  Simon Josefsson  &lt;simon@josefsson.org&gt;
+
+	* NEWS: Mention Salsa20 core.
+	* nettle.texinfo: Document salsa20r_core.
+	* Makefile.in (nettle_SOURCES): Add salsa20-core.c.
+	* salsa20.h (salsa20r_core): Add.
+	* salsa20-core.c: New file.
+	* testsuite/salsa20-test.c (test_main): Self-check salsa20r_core.
+
 2012-11-15  Niels Möller  &lt;nisse@lysator.liu.se&gt;
 
 	* sha3-permute.c (sha3_permute): Use ULL suffix on round
diff --git a/Makefile.in b/Makefile.in
index c30149b..8372def 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -84,7 +84,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gosthash94.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
 		 salsa20-core-internal.c \
-		 salsa20-crypt.c salsa20-set-key.c \
+		 salsa20-crypt.c salsa20-core.c salsa20-set-key.c \
 		 sha1.c sha1-compress.c sha1-meta.c \
 		 sha256.c sha256-compress.c sha224-meta.c sha256-meta.c \
 		 sha512.c sha512-compress.c sha384-meta.c sha512-meta.c \
diff --git a/NEWS b/NEWS
index 35439e2..8613056 100644
--- a/NEWS
+++ b/NEWS
@@ -10,6 +10,8 @@ NEWS for the 2.6 release
 	  More information in RFC4357. Test vectors taken from the GOST
 	  hash wikipedia page.
           
+	* Support for the Salsa20 core.  Contributed by Simon
+          Josefsson.
 
 NEWS for the 2.5 release
 
diff --git a/nettle.texinfo b/nettle.texinfo
index ea4b158..e79b81f 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -1378,6 +1378,12 @@ all but the last call @emph{must} use a length that is a \
multiple of  
 @end deftypefun
 
+@deftypefun void salsa20r_core (uint8_t *@var{dst}, const uint8_t *@var{src}, \
unsigned @var{rounds}) +Hash the 64-byte (@code{SALSA20_BLOCK_SIZE}) message into a \
64-byte +message, using the indicated number of Salsa20 core rounds.
+
+@end deftypefun
+
 @subsection SERPENT
 SERPENT is one of the AES finalists, designed by Ross Anderson, Eli
 Biham and Lars Knudsen. Thus, the interface and properties are similar
diff --git a/salsa20-core.c b/salsa20-core.c
new file mode 100644
index 0000000..a5c37d1
--- /dev/null
+++ b/salsa20-core.c
@@ -0,0 +1,55 @@
+/* salsa20-core.c
+ *
+ * The Salsa20 core hash.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;string.h&gt;
+
+#include "salsa20.h"
+
+#include "macros.h"
+#include "memxor.h"
+
+void
+salsa20r_core (uint8_t *dst,
+	       const uint8_t *src,
+	       unsigned rounds)
+{
+  uint32_t dst32[_SALSA20_INPUT_LENGTH];
+  uint32_t src32[_SALSA20_INPUT_LENGTH];
+  unsigned i;
+
+  for (i = 0; i &lt; _SALSA20_INPUT_LENGTH; i++)
+    src32[i] = LE_READ_UINT32(&amp;src[i * 4]);
+
+  _salsa20_core (dst32, src32, rounds);
+
+  /* _salsa20_core does any needed byteswapping of the output. A memcpy
+     is needed to support unaligned dst; simply casting like
+     _salsa20_core ((uint32_t *) dst, src32, rounds) is not portable. */
+  memcpy (dst, dst32, sizeof (dst32));
+}
diff --git a/salsa20.h b/salsa20.h
index d95d002..81754d3 100644
--- a/salsa20.h
+++ b/salsa20.h
@@ -37,6 +37,7 @@ extern "C" {
 #define salsa20_set_key nettle_salsa20_set_key
 #define salsa20_set_iv nettle_salsa20_set_iv
 #define salsa20_crypt nettle_salsa20_crypt
+#define salsa20r_core nettle_salsa20r_core
 #define _salsa20_core _nettle_salsa20_core
 
 /* Minimum and maximum keysizes, and a reasonable default. In
@@ -76,6 +77,10 @@ salsa20_crypt(struct salsa20_ctx *ctx,
 	      unsigned length, uint8_t *dst,
 	      const uint8_t *src);
 
+/* Salsa20 core hash function.  Warning: not collision resistant. */
+void
+salsa20r_core(uint8_t *dst, const uint8_t *src, unsigned rounds);
+
 void
 _salsa20_core(uint32_t *dst, const uint32_t *src, unsigned rounds);
 
diff --git a/testsuite/salsa20-test.c b/testsuite/salsa20-test.c
index d742ce4..44e5095 100644
--- a/testsuite/salsa20-test.c
+++ b/testsuite/salsa20-test.c
@@ -177,6 +177,42 @@ test_salsa20(const struct tstring *key,
 void
 test_main(void)
 {
+  {
+    uint8_t dst[SALSA20_BLOCK_SIZE];
+
+    salsa20r_core (dst, H("00000000000000000000000000000000"
+			  "00000000000000000000000000000000"
+			  "00000000000000000000000000000000"
+			  "00000000000000000000000000000000"), 20);
+    ASSERT(MEMEQ (SALSA20_BLOCK_SIZE, dst,
+		  H("00000000000000000000000000000000"
+		    "00000000000000000000000000000000"
+		    "00000000000000000000000000000000"
+		    "00000000000000000000000000000000")));
+
+    salsa20r_core (dst, H("01000000000000000000000000000000"
+			  "00000000000000000000000000000000"
+			  "00000000000000000000000000000000"
+			  "00000000000000000000000000000000"), 20);
+    ASSERT(MEMEQ (SALSA20_BLOCK_SIZE, dst,
+		  H("b6c5d21c4600e0127366c9309cb8f70c"
+		    "5c03c1019371e8cfac08bcf0eb36bf8f"
+		    "574d421f23420548 525c2ff9c74f3f97"
+		    "1bc9b4d3b594e755 693d4e15a3a6f516")));
+
+    /* http://tools.ietf.org/html/draft-josefsson-scrypt-kdf */
+
+    salsa20r_core (dst, H("7e879a214f3ec9867ca940e641718f26"
+			  "baee555b8c61c1b50df846116dcd3b1d"
+			  "ee24f319df9b3d8514121e4b5ac5aa32"
+			  "76021d2909c74829edebc68db8b8c25e"), 8);
+    ASSERT(MEMEQ (SALSA20_BLOCK_SIZE, dst,
+		  H("a41f859c6608cc993b81cacb020cef05"
+		    "044b2181a2fd337dfd7b1c6396682f29"
+		    "b4393168e3c9e6bcfe6bc5b7a06d96ba"
+		    "e424cc102c91745c24ad673dc7618f81")));
+  }
+
   /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/full/verified.test-vectors?logsort=rev&amp;rev=210&amp;view=markup \
*/  
   test_salsa20(SHEX("80000000 00000000 00000000 00000000"),
-- 
1.7.10.4



</body></email><email><emailId>20121128091851</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-28 09:18:51-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt;&gt; +void
&gt;&gt; +salsa20_core (uint8_t *dst,
&gt;&gt; +	      const uint8_t *src,
&gt;&gt; +	      unsigned rounds)
&gt;
&gt; is not ideal -- the reason is that the Salsa20 core is not defined with
&gt; a parametrised number of rounds, so the interface is somewhat of a
&gt; bastardisation.

Naming is difficult, it's awkward to use the prefix "salsa20" for a
function which is "salsa20, but not really 20"... In sed syntax it would
be salsa20_sx20xrx ;-)

&gt; In my work space, I have used the namespace 'salsa20r_core' instead.
&gt; This opens up for later addition of a true 'salsa20_core' function which
&gt; would use the official 20 rounds.
&gt;
&gt; What do you think?

I have no better suggestions for naming. But if we think of
salsa20r_core as mostly for internal use, maybe we don't need it?

If I understood you correctly, your primary use case is scrypt, which
you intend to implement in Nettle? Then maybe you would be better off
without an extra wrapper function around _salsa20_core? If nothing else,
you could then make sure you have proper alignment so you don't need an
extra memcpy.

I hesitate a bit to add, document and support a new "obscure" function
until there's a clear external use case.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121128200005</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-11-28 20:00:05-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt;&gt; +void
&gt;&gt;&gt; +salsa20_core (uint8_t *dst,
&gt;&gt;&gt; +	      const uint8_t *src,
&gt;&gt;&gt; +	      unsigned rounds)
&gt;&gt;
&gt;&gt; is not ideal -- the reason is that the Salsa20 core is not defined with
&gt;&gt; a parametrised number of rounds, so the interface is somewhat of a
&gt;&gt; bastardisation.
&gt;
&gt; Naming is difficult, it's awkward to use the prefix "salsa20" for a
&gt; function which is "salsa20, but not really 20"... In sed syntax it would
&gt; be salsa20_sx20xrx ;-)

It could be argued that the name of the function is actually "Salsa20
core" and that reduced round versions would be "Salsa20/r core" or
similar.  That would be consistent with the naming scheme for the
Salsa20 stream cipher -- there Salsa20/12 means the Salsa20 stream
cipher but with 12 rounds.  It is not called Salsa12.

&gt;&gt; In my work space, I have used the namespace 'salsa20r_core' instead.
&gt;&gt; This opens up for later addition of a true 'salsa20_core' function which
&gt;&gt; would use the official 20 rounds.
&gt;&gt;
&gt;&gt; What do you think?
&gt;
&gt; I have no better suggestions for naming. But if we think of
&gt; salsa20r_core as mostly for internal use, maybe we don't need it?
&gt;
&gt; If I understood you correctly, your primary use case is scrypt, which
&gt; you intend to implement in Nettle? Then maybe you would be better off
&gt; without an extra wrapper function around _salsa20_core? If nothing else,
&gt; you could then make sure you have proper alignment so you don't need an
&gt; extra memcpy.
&gt;
&gt; I hesitate a bit to add, document and support a new "obscure" function
&gt; until there's a clear external use case.

Good points.  Generally, I think it would be nice to have public
interfaces for the Salsa20 core function, but currently there really
aren't any use-cases for it except for scrypt that I am aware of.  The
conservative approach then is to not expose it right now.

What is driving this particular patch, though, is that the scrypt code
needs a salsa20 core function that takes uint8_t's and return uint8_t's.
I think there are two ways to address that need:

 1) Implement the salsa20r_core uint8_t function in the scrypt file.

 2) Add another internal function in salsa20.h that implement the
 uint8_t interface.

I prefer the second alternative, because then the implementation is done
in the right place if there is ever another need for the salsa20 core
uint8_t interface within Nettle (or externally).  Thoughts?

I'm thinking it could be something like:

void
_salsa20_core8(uint8_t *dst, const uint8_t *src, unsigned rounds);

possibly the current _salsa20_core should be renamed _salsa20_core32 for
consistency.  Having the uint32_t interface be called _salsa20_core even
if it is an internal function seems a bit confusing -- the proper
interface to it is uint8_t's.

/Simon

</body></email><email><emailId>20121113194839</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-13 19:48:39-0400</timestampReceived><subject>Re: Keccak is SHA-3</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I think the current indexing can be simplified a bit, and it would
&gt; make sense to unroll some of the shorter loops inside the round loop

I've now done some microoptimizations along those lines, doubling the
performance on x86_64. I now get

         Algorithm        mode Mbyte/s
            sha224      update   68.82
            sha256      update   68.83
            sha384      update  105.55
            sha512      update  105.56
          sha3_256      update   29.04

(before I had 12 Mbyte/s).

Not sure how to go about assembly implementation, some, but far from
all, of the steps can make use of SSE2 SIMD instructions.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121114091822</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-11-14 09:18:22-0400</timestampReceived><subject>Re: Keccak is SHA-3</subject><body>

On Mon, Nov 12, 2012 at 10:21 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:
&gt; nisse@lysator.liu.se (Niels M=C3=B6ller) writes:
&gt;
&gt;&gt; I think it may be easiest to write some new code based on the pseudocode
&gt;&gt; description at http://keccak.noekeon.org/specs_summary.html.
&gt; For naming: I called it sha3_256 (since in nettle "sha256" is sha2. I
&gt; guess we should have named it sha2_256 back then). Any other
&gt; suggestions?

sha3_256, sounds clear enough.

&gt; I haven't looked into other types of uses. E.g, does hmac-sha3 make
&gt; sense? The Keccak paper mentions keyed modes of operation, maybe that
&gt; would be preferable.

Maybe it is better to wait and see how it is used as a MAC in protocols the=
n.

&gt; I put the interface declarations in sha3.h. I think it makes for better
&gt; consistency if we split the current sha.h into sha1.h and sha2.h (and
&gt; then we can keep a deprecated sha.h including both, for backwards
&gt; compatibility).

Sounds good.

regards,
Nikos

</body></email><email><emailId>20121111134818</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-11 13:48:18-0400</timestampReceived><subject>Re: gost hash</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; [2. text/x-patch; 0001-Added-documentation-on-gosthash94.patch]...
&gt; 
&gt; [3. text/x-patch; 0002-Added-gosthash-to-benchmark.patch]...
&gt; 
&gt; [4. text/x-patch; 0003-added-news-entry.patch]...

Commited now. Thanks.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121115142453</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-15 14:24:53-0400</timestampReceived><subject>Re: Keccak is SHA-3</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I just commited an initial implementation.

Just a warning, it appears not to work at all on big-endian (in
particular it failed when I tested a 32-bit sparc build). No big
problems, so I think I'll check in fixes soon.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121128075921</emailId><senderName>Fredrik Thulin</senderName><senderEmail>fredrik@thulin.net</senderEmail><timestampReceived>2012-11-28 07:59:21-0400</timestampReceived><subject>Re: Fast PBKDF2 in Python, using Nettle</subject><body>

On Tue, 2012-11-27 at 22:47 +0100, Niels Möller wrote:
&gt; Fredrik Thulin &lt;fredrik@thulin.net&gt; writes:
&gt; 
&gt; &gt; On Tue, 2012-11-27 at 14:06 +0100, Niels Möller wrote:
&gt; &gt;&gt; Cool. Why SHA512 rather than SHA256, is using it specified somewhere?
&gt; &gt;
&gt; &gt; I wanted maximum speed on 64 bits CPUs without settling for SHA-1, but I
&gt; &gt; won't claim this was a particularly well illuminated decision.
&gt; 
&gt; Makes some sense. But on the other hand, the point of pbkdf2 is to be
&gt; slow (for the attacker), so selecting a faster hash function just means
&gt; that you need to use a larger iteration count...

Right - I realized it was poorly phrased after I sent it.

To be a bit more elaborate, my reasoning is that to minimize an
attackers advantage (bot nets will always have more CPU than I do), I
have to choose an algorithm that is as fast as possible for me and use
it with as many iterations as I can afford. I know I will have 64 bits,
but not yet if I should go with in Intel or AMD here.

On top of that, it doesn't hurt to choose an algorithm that might me
more expensive for attackers than me. AFAICT, most GPUs today are 32
bits (so SHA512 would be the slowest SHA currently), although I guess it
is safe to assume GPUs will become 64 bits too.

Naturally, what I'm building will be upgradeable with new algorithms
and/or iteration counts over time, but SHA512 seems like the strongest
choice today.

The only reason *not* to go with SHA512 (if we're limiting ourselves to
SHAs) seems to be that it is considered overkill - admittedly by people
that know far more than me about secure hashes. I don't mind the
overkill though, and prefer safe to sorry.

&gt; For lack of more authoritative test vectors, adding a couple of
&gt; testvectors generated by python-pbkdf2, to the nettle testsuite would be
&gt; nice.

I'll see what I can do.

&gt; &gt; Haven't measured. Optimizing a SHA512 implementation is really above my
&gt; &gt; head, but I've heard talks about using AMD XOP instruction set to
&gt; &gt; optimize SHA512 on other mailing lists... 
&gt; 
&gt; That's a project for another day. It's some time since I wrote the C
&gt; implementation, and I can't guess if a clever assembly implementation
&gt; would gain a 10% or a 100% speedup compared to what gcc generates.

An indication could perhaps be gleaned from

  http://cvs.openssl.org/chngview?cn=22648 

If I understand the "Current performance in cycles per processed byte"
data correctly it seems like use of AVX/XOP could give a 50% performance
improvement for SHA256 and a 38% improvement for SHA512 on Sandy Bridge.
I have no idea how OpenSSLs previous implementation performed compared
to Nettle though.

...
&gt; I get
&gt; 
&gt; PBKDF2-HMAC-SHA512 benchmark result :
&gt; 
&gt; ...
&gt;   N= 16384 -&gt; Python ==  1834 ms, Nettle ==    59 ms
&gt; 
&gt; The machine has an "AMD E-350" processor, 1.6 GHz dual core (but I guess
&gt; the number of cores doesn't matter here). GMP's configure refers to the
&gt; cpu as "bobcat", which if I understand these things correctly is AMD's
&gt; current low-end.

Thanks. I know not to use a low-end AMD then ;). You are correct that
the benchmark only uses one core.

/Fredrik



</body></email><email><emailId>20121128212434</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-28 21:24:34-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; It could be argued that the name of the function is actually "Salsa20
&gt; core" and that reduced round versions would be "Salsa20/r core" or
&gt; similar.  That would be consistent with the naming scheme for the
&gt; Salsa20 stream cipher -- there Salsa20/12 means the Salsa20 stream
&gt; cipher but with 12 rounds.  It is not called Salsa12.

I think the name "salsa20r_core" is good enough. If we ever do some
function(s) specifically for 12 rounds, what would they be called?
salsa20r12_*? Make some sense to me.

&gt; What is driving this particular patch, though, is that the scrypt code
&gt; needs a salsa20 core function that takes uint8_t's and return uint8_t's.
&gt; I think there are two ways to address that need:
&gt;
&gt;  1) Implement the salsa20r_core uint8_t function in the scrypt file.
&gt;
&gt;  2) Add another internal function in salsa20.h that implement the
&gt;  uint8_t interface.
&gt;
&gt; I prefer the second alternative, because then the implementation is done
&gt; in the right place if there is ever another need for the salsa20 core
&gt; uint8_t interface within Nettle (or externally).  Thoughts?

I think I prefer 1) for now. At this point, I don't want to rule out the
possibility that it turns out to be preferable to adapt the scrypt code
to call the more awkward _salsa20_core directly (if we can avoid a
memcpy, it may even give a modest performance improvement).

And it's easy to move salsa20r_core to a separate file and make it
non-static later on, whenever the need arises.

&gt; I'm thinking it could be something like:
&gt;
&gt; void
&gt; _salsa20_core8(uint8_t *dst, const uint8_t *src, unsigned rounds);

I see no reason to use a different name than salsa20r_core, as you
suggested above. In nettle, leading underscore names are mainly for
functions with awkward interfaces, dictated by what's suitable for
assembly implementation or other implementation specific issues, and
where it is likely that the interface will change as the implementation
evolves. And the salsa20 core function you want is not of that
character, whether documented or not.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121128213759</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-28 21:37:59-0400</timestampReceived><subject>Re: PBKDF2-HMAC-SHA512 test cases</subject><body>

Fredrik Thulin &lt;fredrik@thulin.net&gt; writes:

&gt; Attached is a patch that tries to validate the Nettle PBKDF2-HMAC-SHA512
&gt; implementation with a few values generated with python-pbkdf2 from
&gt; https://www.dlitz.net/software/python-pbkdf2/.

Thanks. Checked in now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121130135741</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-30 13:57:41-0400</timestampReceived><subject>Re: SHA2 renaming</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; The initial mistake might have been calling the header file sha.h
&gt; instead of sha1.h.

Right. That was many years ago.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121003082554</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-10-03 08:25:54-0400</timestampReceived><subject>Keccak is SHA-3</subject><body>

It seems that the "Keccak" algorithm is now SHA-3:
http://www.nist.gov/itl/csd/sha-100212.cfm

regards,
Nikos

</body></email><email><emailId>20121025201910</emailId><senderName>Dennis Clarke</senderName><senderEmail>dclarke@blastwave.org</senderEmail><timestampReceived>2012-10-25 20:19:10-0400</timestampReceived><subject>nettle-2.5 on Solaris 10 on UltraSPARC-T2+ : flawless</subject><body>


Just an FYI that nettle-2.5 builds and passes all tests flawlessly with Oracle Studio \
12.3 compilers : 

$ fpversion 
 A SPARC-based CPU is available.
 Kernel says CPU's clock rate is 1581.6 MHz.
 The clock rate is probably 14.3 MHz.

 Sun-4 floating-point controller version 0 found.
 An UltraSPARC chip is available.

 Use "-xtarget=generic -xcache=generic" code-generation option.


$ psrinfo -pv 
The physical processor has 64 virtual processors (0-63)
  UltraSPARC-T2+ (chipid 0, clock 1582 MHz)
The physical processor has 64 virtual processors (64-127)
  UltraSPARC-T2+ (chipid 1, clock 1582 MHz)


$ pwd
/usr/local/build/nettle-2.5_sparcv9_001


$  gmake check 
gmake check-here
gmake[1]: Entering directory `/usr/local/build/nettle-2.5_sparcv9_001'
true
gmake[1]: Leaving directory `/usr/local/build/nettle-2.5_sparcv9_001'
set -e; for d in tools testsuite examples; do \
  echo "Making check in $d" ; (cd $d &amp;&amp; gmake check); done
Making check in tools
gmake[1]: Entering directory `/usr/local/build/nettle-2.5_sparcv9_001/tools'
true
gmake[1]: Leaving directory `/usr/local/build/nettle-2.5_sparcv9_001/tools'
Making check in testsuite
gmake[1]: Entering directory `/usr/local/build/nettle-2.5_sparcv9_001/testsuite'
LD_LIBRARY_PATH=../.lib PATH="../.lib:$PATH" srcdir="." \
  EMULATOR="" NM="/usr/ccs/bin/nm" EXEEXT="" \
          ../run-tests aes-test arcfour-test arctwo-test blowfish-test cast128-test \
base16-test base64-test camellia-test des-test des3-test des-compat-test md2-test \
md4-test md5-test md5-compat-test memxor-test ripemd160-test salsa20-test sha1-test \
sha224-test sha256-test sha384-test sha512-test serpent-test twofish-test \
knuth-lfib-test cbc-test ctr-test gcm-test hmac-test meta-hash-test meta-cipher-test \
meta-armor-test buffer-test yarrow-test  cxx-test sexp-conv-test pkcs1-conv-test \
                symbols-test
PASS: aes
PASS: arcfour
PASS: arctwo
PASS: blowfish
PASS: cast128
PASS: base16
PASS: base64
PASS: camellia
PASS: des
PASS: des3
PASS: des-compat
PASS: md2
PASS: md4
PASS: md5
PASS: md5-compat
PASS: memxor
PASS: ripemd160
PASS: salsa20
PASS: sha1
PASS: sha224
PASS: sha256
PASS: sha384
PASS: sha512
PASS: serpent
PASS: twofish
PASS: knuth-lfib
PASS: cbc
PASS: ctr
PASS: gcm
PASS: hmac
PASS: meta-hash
PASS: meta-cipher
PASS: meta-armor
PASS: buffer
PASS: yarrow
PASS: cxx
PASS: sexp-conv
PASS: pkcs1-conv
PASS: symbols
===================
All 39 tests passed
===================
gmake[1]: Leaving directory `/usr/local/build/nettle-2.5_sparcv9_001/testsuite'
Making check in examples
gmake[1]: Entering directory `/usr/local/build/nettle-2.5_sparcv9_001/examples'
LD_LIBRARY_PATH=../.lib PATH="../.lib:$PATH" srcdir="." \
  EMULATOR="" EXEEXT="" \
          ".."/run-tests rsa-sign-test rsa-verify-test rsa-encrypt-test
xxxxx
xxxxx
eeeeeee
PASS: rsa-sign
PASS: rsa-verify
PASS: rsa-encrypt
==================
All 3 tests passed
==================
gmake[1]: Leaving directory `/usr/local/build/nettle-2.5_sparcv9_001/examples'
$


good stuff :-)

Dennis 


</body></email><email><emailId>20121025220541</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-10-25 22:05:41-0400</timestampReceived><subject>Re: nettle-2.5 on solaris 10 Sparc issues</subject><body>

Dennis Clarke &lt;dclarke@blastwave.org&gt; writes:

&gt; Looks like nettle 2.5 should build pretty much out of the box but the Makefiles \
&gt; seem to have a few issues. 

Thanks for testing.

&gt; First thing wrong there is that libgmp does exist just fine. 

To figure out why that configure check failed, you'll have to look in
config.log.

&gt; ... and then link goes boom because of the totally missing options to the \
&gt; compiler/linker :  
&gt; /opt/solarisstudio12.3/bin/cc -I. -I/usr/local/include:/usr/sfw/include \
&gt; -DHAVE_CONFIG_H -errfmt=error -erroff=%none -errshort=full -xstrconst -xildoff -m64 \
&gt; -xmemalign=8s -xnolibmil -Xa -xcode=pic32 -xregs=no%appl -xlibmieee -mc -g -xs \
&gt; -ftrap=%none -Qy -xbuiltin=%none -xdebugformat=dwarf -xunroll=1 -xtarget=ultraT2 \
&gt; -xcache=8/16/4:4096/64/16 -D_TS_ERRNO -D_POSIX_PTHREAD_SEMANTICS \
&gt; -D_LARGEFILE64_SOURCE -KPIC -Bdynamic  -KPIC -Bdynamic -c memxor.c -o memxor.po \ \
&gt;                 &amp;&amp; true
&gt; /opt/solarisstudio12.3/bin/cc  -G -h libnettle.so.4 aes-decrypt-internal.po \
&gt; aes-decrypt.po aes-encrypt-internal.po aes-encrypt.po aes-encrypt-table.po \
&gt; aes-set-encrypt-key.po aes-set-decrypt-key.po aes-meta.po arcfour.po \
&gt; arcfour-crypt.po arcfour-meta.po arctwo.po arctwo-meta.po base16-encode.po \
&gt; base16-decode.po base16-meta.po base64-encode.po base64-decode.po base64-meta.po \
&gt; camellia-crypt.po camellia-crypt-internal.po camellia-set-encrypt-key.po \
&gt; camellia-set-decrypt-key.po camellia-table.po camellia-meta.po cast128.po \
&gt; cast128-meta.po blowfish.po cbc.po ctr.po gcm.po gcm-aes.po des.po des3.po \
&gt; des-compat.po hmac.po hmac-md5.po hmac-ripemd160.po hmac-sha1.po hmac-sha224.po \
&gt; hmac-sha256.po hmac-sha384.po hmac-sha512.po knuth-lfib.po md2.po md2-meta.po \
&gt; md4.po md4-meta.po md5.po md5-compress.po md5-compat.po md5-meta.po ripemd160.po \
&gt; ripemd160-compress.po ripemd160-meta.po salsa20-crypt.po salsa20-set-key.po sha1.po \
&gt; sha1-compress.po sha1-meta.po sha256.po sha256-compress.po sha224-!
 me
&gt; ta.po sha256-meta.po sha512.po sha512-compress.po sha384-meta.po sha512-meta.po \
&gt; serpent-set-key.po serpent-encrypt.po serpent-decrypt.po serpent-meta.po twofish.po \
&gt; twofish-meta.po yarrow256.po yarrow_key_event.po buffer.po buffer-init.po \
&gt; realloc.po nettle-meta-hashes.po nettle-meta-ciphers.po nettle-meta-armors.po \
&gt;                 write-be32.po write-le32.po memxor.po -o libnettle.so 
&gt; ld: fatal: file aes-decrypt-internal.po: wrong ELF class: ELFCLASS64
&gt; ld: fatal: file processing errors. No output written to libnettle.so
&gt; gmake[1]: *** [libnettle.so] Error 2
&gt; gmake[1]: Leaving directory `/usr/local/build/nettle-2.5_sparcv9_001'
&gt; gmake: *** [all] Error 2

If I understand you correctly, the main problem is the linker command
line, with -m64 being the most important missing option.

And indeed, $(CFLAGS) seems not to be included when building shared
libraries. IF you look in configure.in, and the definitions on
LIBNETTLE_LINK and LIBHOGWEED_LINK (a couple of different variants), one
would need to add $(CFLAGS) there. (Or of you want to workaround it
without touching configure.in, the definitions are substituted into
config.make). 

&gt; what the heck is a po file ? 

Here, it's an object file compiled with compiler flags for position
independent code, suitable for a shared library.

&gt; Anyways ... makefiles seem a bit off and a autoreconf --verbose --install may be \
&gt; needed after a tweak to Makefile.am or similar. 

The intention is that there should be make rules for recreating anything
(assuming you ran configure before you started hacking). To generate
autoconf-related files from scrath, e.g., for a fresh checkout, you run
the small ./.bootstrap script, and then rerun configure.

There is no Makefile.am ;-). 

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20121028154502</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-10-28 15:45:02-0400</timestampReceived><subject>Re: gost hash</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;  Any update on adding gost?

I intend to add it, but I haven't yet had the time needed.

I have also intended to write to Aleksey Kravchenko and ask for an
appropriate (c) notice to put in the file (or write one up and ask if he
agrees to it). From the private mail you forwarded to me, it seems clear
that MIT license is intended (or a subset of those requirements, but I
haven't tried to figure out the difference between "rhash license" and
standard MIT). So the notice should include name of author, year(s) of
authorship, and MIT licensing terms. But I haven't gotten around to that
either.

Sorry for the slow response. Most recent checkins try to finalize the
salsa20_core changes from some month ago (I'd like to get the simple
assembly salsa20_core in, and the benchmarking of it).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121029115241</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2012-10-29 11:52:41-0400</timestampReceived><subject>Re: [PATCH] Use an extended sed RE for matching source files when generating dummy deps</subject><body>


On Mon, 29 Oct 2012, Niels Möller wrote:

&gt; Martin Storsjo &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt; On Mac OS X 10.8 sed, the | operator isn't available in basic REs,
&gt;&gt; only in extended ones. The null string also has to be expressed with
&gt;&gt; ().
&gt;
&gt; The first is understandable, but the second seems very odd to me, isn't
&gt; that very buggy?

Not sure - with sed -E 's/\.c(xx|)$//' I get:

sed: 1: "s/\.c(xx|)$//": RE error: empty (sub)expression

&gt;&gt; Another Mac OS X-compatible version of the RE is
&gt;&gt; 's/\.c\(xx\)\{0,1\}//'.
&gt;&gt;
&gt;&gt; Both of these versions have been tested for compatibility with GNU sed.
&gt;
&gt; I'd prefer if we stick to basic regular expression and posix sed (and
&gt; the current regexp using \| is not posix either). Your second variant
&gt; should be fine with posix sed, if I understand
&gt; http://pubs.opengroup.org/onlinepubs/007904975/basedefs/xbd_chap09.html
&gt; correctly. So I think that's the right fix.

Ok, I'll send a new patch with that approach instead then.

&gt;&gt; A third alternative is to omit generating these dummy deps altogether,
&gt;&gt; and prefixing the include statements in the Makefiles with a '-',
&gt;&gt; which haves make ignore any failures in including those files.
&gt;
&gt; The current use of include works at least with GNU make and
&gt; Solaris make, but not with BSD make (the latter wants only a single file
&gt; name after include). Unfortunately, I think the -include trick fails to
&gt; work with Solaris make.

Ok, good to know.

// Martin

</body></email><email><emailId>20121029142450</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2012-10-29 14:24:50-0400</timestampReceived><subject>Re: [PATCH] Use a posix compatible sed RE for matching source files when generating dummy deps</subject><body>


On Mon, 29 Oct 2012, Niels Möller wrote:

&gt; Martin Storsjo &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt; --- a/configure.ac
&gt;&gt; +++ b/configure.ac
&gt;&gt; @@ -122,7 +122,7 @@ if test x$enable_dependency_tracking = xyes ; then
&gt;&gt;
&gt;&gt;    AC_CONFIG_COMMANDS([dummy-dep-files],
&gt;&gt;    [(cd "$srcdir" &amp;&amp; find . '(' -name '*.c' -o -name '*.cxx' ')' -print) \
&gt;&gt; - | sed 's/\.c\(xx\|\)$//' | (while read f; do echo &gt; "$f.o.d"; echo &gt; "$f.po.d"; done)
&gt;&gt; + | sed 's/\.c\(xx\)\{0,1\}//' | (while read f; do echo &gt; "$f.o.d"; echo &gt; "$f.po.d"; done)
&gt;&gt;  ])
&gt;&gt;  fi
&gt;
&gt; Checked in, with the small modification that I keep the $ at the end of
&gt; the regexp. (Actually, since we do pass glob patterns to find, I guess it would
&gt; be sufficient to remove *any* extension, i.e., sed 's/\.[^.]*$//' or
&gt; so).

Thanks, removing the $ was accidental.

// Martin

</body></email><email><emailId>20121031193848</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-10-31 19:38:48-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Actually, sleeping on this, I realized that we really want to export the
&gt; Salsa20 core primitive (this was what I actually needed), and that is
&gt; the primitive that should be implemented in assembler.

Now that this is in, did you make any use of it yet? I don't quite
remember what your application was.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121128161354</emailId><senderName>Fredrik Thulin</senderName><senderEmail>fredrik@thulin.net</senderEmail><timestampReceived>2012-11-28 16:13:54-0400</timestampReceived><subject>PBKDF2-HMAC-SHA512 test cases</subject><body>

&gt;From another thread :

On Tue, 2012-11-27 at 22:47 +0100, Niels Möller wrote:
...
&gt; For lack of more authoritative test vectors, adding a couple of
&gt; testvectors generated by python-pbkdf2, to the nettle testsuite would
&gt; be nice.

Attached is a patch that tries to validate the Nettle PBKDF2-HMAC-SHA512
implementation with a few values generated with python-pbkdf2 from
https://www.dlitz.net/software/python-pbkdf2/.

I also conducted 300,000 semi-random tests comparing the Nettle digest
with corresponding OpenSSL digests, using QuickCheck-like testing, with
good results. I did not use python-pbkdf2 checks for these, because
frankly they were too slow.

In case anyone is interested, I'm attaching the QC test too. Quick
instructions for that one would be to install 'qc' from
git://github.com/dbravender/qc.git, my python-ndnkdf from
https://github.com/fredrikt/python-ndnkdf and then do

  $ nosetests -d qc-test.py

/Fredrik


["0001-Add-PBKDF2-HMAC-SHA512-test-cases.patch" (0001-Add-PBKDF2-HMAC-SHA512-test-cases.patch)]

&gt; From 551421d68dbc68c9d7567a9950b1938a6d996f6f Mon Sep 17 00:00:00 2001
From: Fredrik Thulin &lt;fredrik@thulin.net&gt;
Date: Wed, 28 Nov 2012 17:01:03 +0100
Subject: [PATCH] Add PBKDF2-HMAC-SHA512 test cases.

Test Nettle version using values from another implementation.

Courtesy of NORDUnet A/S.
---
 testsuite/pbkdf2-test.c |   27 ++++++++++++++++++++++++++-
 1 file changed, 26 insertions(+), 1 deletion(-)

diff --git a/testsuite/pbkdf2-test.c b/testsuite/pbkdf2-test.c
index c0d2eae..ffb5580 100644
--- a/testsuite/pbkdf2-test.c
+++ b/testsuite/pbkdf2-test.c
@@ -20,7 +20,7 @@
     ASSERT(dk[expect-&gt;length] == 17);					\
   } while (0)
 
-#define MAX_DKLEN 25
+#define MAX_DKLEN SHA512_DIGEST_SIZE
 
 void
 test_main (void)
@@ -28,6 +28,7 @@ test_main (void)
   uint8_t dk[MAX_DKLEN + 1];
   struct hmac_sha1_ctx sha1ctx;
   struct hmac_sha256_ctx sha256ctx;
+  struct hmac_sha512_ctx sha512ctx;
 
   /* Test vectors for PBKDF2 from RFC 6070. */
 
@@ -78,6 +79,30 @@ test_main (void)
 	       SHA256_DIGEST_SIZE, 80000, LDATA("NaCl"),
 	       SHEX("4ddcd8f60b98be21830cee5ef22701f9"));
 
+  /* PBKDF2-HMAC-SHA-512 test vectors confirmed with another
+     implementation (python-pbkdf2).
+
+     &gt;&gt;&gt; from pbkdf2 import PBKDF2
+     &gt;&gt;&gt; import hmac as HMAC
+     &gt;&gt;&gt; from hashlib import sha512 as SHA512
+     &gt;&gt;&gt; PBKDF2("password", "salt", 50, macmodule=HMAC, \
digestmodule=SHA512).read(64).encode('hex') +  */
+
+  hmac_sha512_set_key (&amp;sha512ctx, 8, "password");
+  PBKDF2_TEST (&amp;sha512ctx, hmac_sha512_update, hmac_sha512_digest,
+	       SHA512_DIGEST_SIZE, 1, LDATA("NaCL"),
+	       SHEX("73decfa58aa2e84f94771a75736bb88bd3c7b38270cfb50cb390ed78b305656af8148e52452b2216b2b8098b761fc6336060a09f76415e9f71ea47f9e9064306"));
 +
+  hmac_sha512_set_key (&amp;sha512ctx, 9, "pass\0word");
+  PBKDF2_TEST (&amp;sha512ctx, hmac_sha512_update, hmac_sha512_digest,
+	       SHA512_DIGEST_SIZE, 1, LDATA("sa\0lt"),
+	       SHEX("71a0ec842abd5c678bcfd145f09d83522f93361560563c4d0d63b88329871090e76604a49af08fe7c9f57156c8790996b20f06bc535e5ab5440df7e878296fa7"));
 +
+  hmac_sha512_set_key (&amp;sha512ctx, 24, "passwordPASSWORDpassword");
+  PBKDF2_TEST (&amp;sha512ctx, hmac_sha512_update, hmac_sha512_digest,
+	       SHA512_DIGEST_SIZE, 50, LDATA("salt\0\0\0"),
+	       SHEX("016871a4c4b75f96857fd2b9f8ca28023b30ee2a39f5adcac8c9375f9bda1ccd1b6f0b2fc3adda505412e79d890056c62e524c7d51154b1a8534575bd02dee39"));
 +
   /* Test convenience functions. */
 
   PBKDF2_HMAC_TEST(pbkdf2_hmac_sha1, LDATA("password"), 1, LDATA("salt"),
-- 
1.7.9.5


["qc-test.py" (qc-test.py)]

#!/usr/bin/python
#
# Copyright (c) 2012, NORDUnet A/S
# All rights reserved.
#
#   Redistribution and use in source and binary forms, with or
#   without modification, are permitted provided that the following
#   conditions are met:
#
#     1. Redistributions of source code must retain the above copyright
#        notice, this list of conditions and the following disclaimer.
#     2. Redistributions in binary form must reproduce the above
#        copyright notice, this list of conditions and the following
#        disclaimer in the documentation and/or other materials provided
#        with the distribution.
#     3. Neither the name of the NORDUnet nor the names of its
#        contributors may be used to endorse or promote products derived
#        from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Author : Fredrik Thulin &lt;fredrik@thulin.net&gt;
#

import ndnkdf
import ctypes
import ctypes.util
import timeit
import sys

from pbkdf2 import PBKDF2
import hmac as HMAC
from hashlib import sha512 as SHA512

from qc import forall, integers


class OSSL():

    _DIGEST_SIZE=64

    def __init__(self, path=None):
        self.ssl = ctypes.cdll.LoadLibrary('libssl.so')

    def pbkdf2_hmac_sha512(self, key, iterations, salt):
        """
        Invoke OpenSSL PBKDF2 using HMAC-SHA-512 on key, iterations and salt.
        """
        self.ssl.EVP_sha512.restype = ctypes.c_void_p
        evp = ctypes.cast(self.ssl.EVP_sha512(), ctypes.POINTER(ctypes.c_void_p))
        buf = ctypes.create_string_buffer('', size = self._DIGEST_SIZE)
        res = self.ssl.PKCS5_PBKDF2_HMAC(key, len(key), \
                                             salt, len(salt), \
                                             int(iterations), \
                                             evp, \
                                             self._DIGEST_SIZE, \
                                             ctypes.byref(buf) \
                                             )
        return buf.raw

nettle = ndnkdf.NDNKDF()
ossl = OSSL()

keys = ['', chr(0) * 8, chr(0) * 64, chr(0) * 100,
        'passwd', 'This is a secret passphrase.',
        'pass\0word',
        'PASSphrase\0',
        'PASS\0\0phrase\0\0',
        'a', 'a' * 32,
        ]
salts = ['', chr(0) * 8, 'saltSALTsaltSALTsalt', 'NaCL',
        'a', 'a' * 32,
         'sa\0lt',
         'salt\0\0',
         ]

forall.verbose=True

@forall(tries=10000,
        iterations=integers(low=1, high=50000),
        keyidx=integers(low=0, high=len(keys) - 1),
        saltidx=integers(low=0, high=len(salts) - 1),
        keymul=integers(low=1, high=100),
        saltmul=integers(low=1, high=100),
        )
def test_pbkdf2_hmac_sha512(iterations, keyidx, saltidx, keymul, saltmul):
    key = keys[keyidx] * keymul
    salt = salts[saltidx] * saltmul
    nettle_res = nettle.pbkdf2_hmac_sha512(key, iterations, salt)
    openssl_res = ossl.pbkdf2_hmac_sha512(key, iterations, salt)
    #py_res = PBKDF2(keys[key], salts[salt], iterations=iterations, \
    #                    macmodule=HMAC, \
    #                    digestmodule=SHA512).read(64)
    sys.stderr.write("%s %s : i=%i k=%s[%i] s=%s[%i]\n" % \
(nettle_res[:5].encode('hex'), openssl_res[:5].encode('hex'),  iterations,
                                                   key[:5], len(key), salt[:5], \
len(salt),))  #assert (nettle_res == py_res)
    assert (nettle_res == openssl_res)



</body></email><email><emailId>20121129201513</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-29 20:15:13-0400</timestampReceived><subject>SHA2 renaming</subject><body>

With support for SHA3, it seems clear that nettle's naming for sha2
functions was a mistake. It should be "sha2_256", rather than "sha256".

This is my current plan. Step 1 is as backwards compatible as practical,
while step 2, to be taken at some later time, drops backwards
compatibility.

Step 1:

  * Split sha.h into sha1.h and sha2.h, and use the new names in sha2.h.
    Except for the name mangling, e.g.,

      #define sha2_256_init nettle_sha256_init
   
    not

      #define sha2_256_init nettle_sha2_256_init

    in order to maintain ABI compatibility.

  * Keep sha.h for backwards compatibility. Have it include sha1.h and
    sha2.h, and use #define to make old names aliases for the new names.

  * Do a thorough rename in the implementation; use new names for all
    internal use of sha2, rename files, etc.

  * For all other interfaces where a sha2 function shows up in a name,
    e.g., hmac_sha256_set_key, and DSA_SHA256_MIN_P_BITS, rename for
    consistency and use #defines to make old names aliases.

  * For nettle_hash, make the new name of the struct an alias for the
    old, e.g.,

      #define nettle_sha2_256 nettle_sha256

    but for now do *not* change the contents of the name. I.e.,
    nettle_sha2_256.name will still contain the string "sha256", not
    "sha2_256".


Step 2:

  * Delete sha.h, and the other compatibility aliases defined elsewhere.

  * Do the rename also on library symbols, i.e., nettle_sha256_init -&gt;
    nettle_sha2_256_init.

  * Change the value of the name fields of the nettle_hash objects.


As far as I see, Step 1 maintains reasonably complete API and ABI
compatibility. The only subtlety I'm aware of is C++ ABI compatibility
for code *using* nettle, where I think

  struct sha256_ctx;

vs
  
  struct sha2_256_ctx;
  #define sha256_ctx sha2_256_ctx

would give different name mangling of C++ functions using arguments of
this type (and not declared extern "C"). I think that is a problem that
I'm going to ignore. Or do you think it is important enough to make the
aliases for the struct tags the other way around?

Comments?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20121130055656</emailId><senderName>Ivan Shmakov</senderName><senderEmail>oneingray@gmail.com</senderEmail><timestampReceived>2012-11-30 05:56:56-0400</timestampReceived><subject>Re: SHA2 renaming</subject><body>

&gt;&gt;&gt;&gt;&gt; Niels Möller writes:

 &gt; With support for SHA3, it seems clear that nettle's naming for sha2
 &gt; functions was a mistake.  It should be "sha2_256", rather than
 &gt; "sha256".

	While such a step would be logical, I'd like to note that while
	SHA-2 algorithms are widely known as SHA-256, etc., it's the
	SHA3-256, etc. forms that seems to be preferred for SHA-3.

	There's a logic in keeping the things as they are, too.  When
	SHA-1 was introduced, it supported only 160 bit size digests, so
	there was no need to mention the size explicitly.  When SHA-2
	appeared, it supported several sizes, but none of them coincided
	with the SHA-1's 160 bits, thus the "version" was apparent from
	the bit size.  At last, came SHA-3, and being the later one, it
	has to bear its explicit version number.

[…]

-- 
FSF associate member #7257


</body></email><email><emailId>20121029100847</emailId><senderName>Martin Storsjo</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2012-10-29 10:08:47-0400</timestampReceived><subject>[PATCH] Use an extended sed RE for matching source files when generating dummy deps</subject><body>

On Mac OS X 10.8 sed, the | operator isn't available in basic REs,
only in extended ones. The null string also has to be expressed with
().

Another Mac OS X-compatible version of the RE is
's/\.c\(xx\)\{0,1\}//'.

Both of these versions have been tested for compatibility with GNU sed.

A third alternative is to omit generating these dummy deps altogether,
and prefixing the include statements in the Makefiles with a '-',
which haves make ignore any failures in including those files.
---
 configure.ac |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index 998ed55..1114c71 100644
--- a/configure.ac
+++ b/configure.ac
@@ -122,7 +122,7 @@ if test x$enable_dependency_tracking = xyes ; then
 
   AC_CONFIG_COMMANDS([dummy-dep-files],
   [(cd "$srcdir" &amp;&amp; find . '(' -name '*.c' -o -name '*.cxx' ')' -print) \
- | sed 's/\.c\(xx\|\)$//' | (while read f; do echo &gt; "$f.o.d"; echo &gt; "$f.po.d"; done)
+ | sed -E 's/\.c(xx|())$//' | (while read f; do echo &gt; "$f.o.d"; echo &gt; "$f.po.d"; done)
 ])
 fi
 
-- 
1.7.9.4


</body></email><email><emailId>20121029104929</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-10-29 10:49:29-0400</timestampReceived><subject>Re: [PATCH] Use an extended sed RE for matching source files when generating dummy deps</subject><body>

Martin Storsjo &lt;martin@martin.st&gt; writes:

&gt; On Mac OS X 10.8 sed, the | operator isn't available in basic REs,
&gt; only in extended ones. The null string also has to be expressed with
&gt; ().

The first is understandable, but the second seems very odd to me, isn't
that very buggy?

&gt; Another Mac OS X-compatible version of the RE is
&gt; 's/\.c\(xx\)\{0,1\}//'.
&gt;
&gt; Both of these versions have been tested for compatibility with GNU sed.

I'd prefer if we stick to basic regular expression and posix sed (and
the current regexp using \| is not posix either). Your second variant
should be fine with posix sed, if I understand
http://pubs.opengroup.org/onlinepubs/007904975/basedefs/xbd_chap09.html
correctly. So I think that's the right fix.

&gt; A third alternative is to omit generating these dummy deps altogether,
&gt; and prefixing the include statements in the Makefiles with a '-',
&gt; which haves make ignore any failures in including those files.

The current use of include works at least with GNU make and
Solaris make, but not with BSD make (the latter wants only a single file
name after include). Unfortunately, I think the -include trick fails to
work with Solaris make.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121029115656</emailId><senderName>Martin Storsjo</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2012-10-29 11:56:56-0400</timestampReceived><subject>[PATCH] Use a posix compatible sed RE for matching source files when generating dummy deps</subject><body>

The | operator isn't supported by posix sed.
---
 configure.ac |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index 998ed55..ca204c3 100644
--- a/configure.ac
+++ b/configure.ac
@@ -122,7 +122,7 @@ if test x$enable_dependency_tracking = xyes ; then
 
   AC_CONFIG_COMMANDS([dummy-dep-files],
   [(cd "$srcdir" &amp;&amp; find . '(' -name '*.c' -o -name '*.cxx' ')' -print) \
- | sed 's/\.c\(xx\|\)$//' | (while read f; do echo &gt; "$f.o.d"; echo &gt; "$f.po.d"; done)
+ | sed 's/\.c\(xx\)\{0,1\}//' | (while read f; do echo &gt; "$f.o.d"; echo &gt; "$f.po.d"; done)
 ])
 fi
 
-- 
1.7.9.4


</body></email><email><emailId>20121029141228</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-10-29 14:12:28-0400</timestampReceived><subject>Re: [PATCH] Use a posix compatible sed RE for matching source files when generating dummy deps</subject><body>

Martin Storsjo &lt;martin@martin.st&gt; writes:

&gt; --- a/configure.ac
&gt; +++ b/configure.ac
&gt; @@ -122,7 +122,7 @@ if test x$enable_dependency_tracking = xyes ; then
&gt;  
&gt;    AC_CONFIG_COMMANDS([dummy-dep-files],
&gt;    [(cd "$srcdir" &amp;&amp; find . '(' -name '*.c' -o -name '*.cxx' ')' -print) \
&gt; - | sed 's/\.c\(xx\|\)$//' | (while read f; do echo &gt; "$f.o.d"; echo &gt; "$f.po.d"; done)
&gt; + | sed 's/\.c\(xx\)\{0,1\}//' | (while read f; do echo &gt; "$f.o.d"; echo &gt; "$f.po.d"; done)
&gt;  ])
&gt;  fi

Checked in, with the small modification that I keep the $ at the end of
the regexp. (Actually, since we do pass glob patterns to find, I guess it would
be sufficient to remove *any* extension, i.e., sed 's/\.[^.]*$//' or
so).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121130085528</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-11-30 08:55:28-0400</timestampReceived><subject>Re: SHA2 renaming</subject><body>

fre 2012-11-30 klockan 12:56 +0700 skrev Ivan Shmakov:
&gt; &gt;&gt;&gt;&gt;&gt; Niels Möller writes:
&gt; 
&gt;  &gt; With support for SHA3, it seems clear that nettle's naming for sha2
&gt;  &gt; functions was a mistake.  It should be "sha2_256", rather than
&gt;  &gt; "sha256".
&gt; 
&gt; 	While such a step would be logical, I'd like to note that while
&gt; 	SHA-2 algorithms are widely known as SHA-256, etc., it's the
&gt; 	SHA3-256, etc. forms that seems to be preferred for SHA-3.
&gt; 
&gt; 	There's a logic in keeping the things as they are, too.  When
&gt; 	SHA-1 was introduced, it supported only 160 bit size digests, so
&gt; 	there was no need to mention the size explicitly.  When SHA-2
&gt; 	appeared, it supported several sizes, but none of them coincided
&gt; 	with the SHA-1's 160 bits, thus the "version" was apparent from
&gt; 	the bit size.  At last, came SHA-3, and being the later one, it
&gt; 	has to bear its explicit version number.

I am inclined to agree -- the name "SHA256" seems to be more popular
than "SHA2-256" or even "SHA2" according to Google hits.  Grep RFCs that
use the term "SHA256" and that is also the more common usage.  Going
back to the NIST specification:

http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf

Quoting:

   This Standard specifies secure hash algorithms - SHA-1, SHA-224,   
   SHA-256, SHA-384, SHA-512, SHA-512/224 and SHA-512/256 - for
   computing a condensed representation of electronic data (message). 

See also the wikipedia page, it never uses the term "sha2-256" but
consistently use the term "SHA-256".

http://en.wikipedia.org/wiki/SHA-2

Is there any other authorative sources on SHA2 and what it should be
called?

If the naming in Nettle isn't an obvious mistake, I would prefer not to
change things.  However, I don't really care strongly.

/Simon



</body></email><email><emailId>20121130113849</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-11-30 11:38:49-0400</timestampReceived><subject>Re: SHA2 renaming</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; fre 2012-11-30 klockan 12:56 +0700 skrev Ivan Shmakov:
&gt;&gt; 
&gt;&gt; 	While such a step would be logical, I'd like to note that while
&gt;&gt; 	SHA-2 algorithms are widely known as SHA-256, etc., it's the
&gt;&gt; 	SHA3-256, etc. forms that seems to be preferred for SHA-3.

&gt; I am inclined to agree -- the name "SHA256" seems to be more popular
&gt; than "SHA2-256" or even "SHA2" according to Google hits.  Grep RFCs that
&gt; use the term "SHA256" and that is also the more common usage.  Going
&gt; back to the NIST specification:

[...]

&gt; If the naming in Nettle isn't an obvious mistake, I would prefer not to
&gt; change things.  However, I don't really care strongly.

If I may rephrase what you're both saying, it's that everybody else
seems to be using the "mistaken" naming, and then it makes more sense
for Nettle to stick to that common usage. That argument makes sense to
me; maybe I got a bit carried away.

I think I'd still like to do the header split, sha.h -&gt; sha1.h and
sha2.h, for better consistency within Nettle, but that's less intrusive,
and backwards compatibility is trivial, with a sha.h including both.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20121130121758</emailId><senderName>Ivan Shmakov</senderName><senderEmail>oneingray@gmail.com</senderEmail><timestampReceived>2012-11-30 12:17:58-0400</timestampReceived><subject>Re: SHA2 renaming</subject><body>

&gt;&gt;&gt;&gt;&gt; Niels Möller writes:
&gt;&gt;&gt;&gt;&gt; Simon Josefsson writes:
&gt;&gt;&gt;&gt;&gt; fre 2012-11-30 klockan 12:56 +0700 skrev Ivan Shmakov:

 &gt;&gt;&gt; While such a step would be logical, I'd like to note that while
 &gt;&gt;&gt; SHA-2 algorithms are widely known as SHA-256, etc., it's the
 &gt;&gt;&gt; SHA3-256, etc. forms that seems to be preferred for SHA-3.

 &gt;&gt; I am inclined to agree — the name "SHA256" seems to be more popular
 &gt;&gt; than "SHA2-256" or even "SHA2" according to Google hits.  Grep RFCs
 &gt;&gt; that use the term "SHA256" and that is also the more common usage.
 &gt;&gt; Going back to the NIST specification:

 &gt;&gt; If the naming in Nettle isn't an obvious mistake, I would prefer not
 &gt;&gt; to change things.  However, I don't really care strongly.

 &gt; If I may rephrase what you're both saying, it's that everybody else
 &gt; seems to be using the "mistaken" naming, and then it makes more sense
 &gt; for Nettle to stick to that common usage.  That argument makes sense
 &gt; to me; maybe I got a bit carried away.

	The point is that back when SHA-2 was designed, there was no
	need to name its individual variants SHA2-224, SHA2-256, etc.
	Perhaps if SHA-3 was anticipated at that time, a more generic
	name scheme would have been devised.  It didn't happen, however,
	and SHA-2 variants are known as SHA-224, SHA-256, etc., and are
	likely to be known under these names from now and forever (as
	long as the algorithms remain in use, that is.)  It isn't a
	"mistake" — just the history.

 &gt; I think I'd still like to do the header split, sha.h -&gt; sha1.h and
 &gt; sha2.h, for better consistency within Nettle, but that's less
 &gt; intrusive, and backwards compatibility is trivial, with a sha.h
 &gt; including both.

	FWIW, I see nothing wrong in such a change.  (And, actually, see
	something right in it.)

-- 
FSF associate member #7257


</body></email><email><emailId>20121130130248</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-11-30 13:02:48-0400</timestampReceived><subject>Re: SHA2 renaming</subject><body>

fre 2012-11-30 klockan 12:38 +0100 skrev Niels Möller:
&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt; 
&gt; &gt; fre 2012-11-30 klockan 12:56 +0700 skrev Ivan Shmakov:
&gt; &gt;&gt; 
&gt; &gt;&gt; 	While such a step would be logical, I'd like to note that while
&gt; &gt;&gt; 	SHA-2 algorithms are widely known as SHA-256, etc., it's the
&gt; &gt;&gt; 	SHA3-256, etc. forms that seems to be preferred for SHA-3.
&gt; 
&gt; &gt; I am inclined to agree -- the name "SHA256" seems to be more popular
&gt; &gt; than "SHA2-256" or even "SHA2" according to Google hits.  Grep RFCs that
&gt; &gt; use the term "SHA256" and that is also the more common usage.  Going
&gt; &gt; back to the NIST specification:
&gt; 
&gt; [...]
&gt; 
&gt; &gt; If the naming in Nettle isn't an obvious mistake, I would prefer not to
&gt; &gt; change things.  However, I don't really care strongly.
&gt; 
&gt; If I may rephrase what you're both saying, it's that everybody else
&gt; seems to be using the "mistaken" naming, and then it makes more sense
&gt; for Nettle to stick to that common usage. That argument makes sense to
&gt; me; maybe I got a bit carried away.

Even further than that, I think I'm saying that I would be inclined to
disagree that SHA256 is a mistaken naming.  What source do you have that
says the name "SHA2-256" is the right name?  From the sources I quoted,
including FIPS 180-4, the name is "SHA256".  I suggest, as a general
rule, that naming should preferrably be consistent with what appears to
be the most authorative specification available for each algorithm.

&gt; I think I'd still like to do the header split, sha.h -&gt; sha1.h and
&gt; sha2.h, for better consistency within Nettle, but that's less intrusive,
&gt; and backwards compatibility is trivial, with a sha.h including both.

Yes, doing that split makes sense to me.  SHA256 etc doesn't have much
in common with SHA1, so they belong in separate header files.  Putting
SHA256 in sha.h might have been the earlier mistake, if any.  The
initial mistake might have been calling the header file sha.h instead of
sha1.h.

/Simon



</body></email><email><emailId>20121130130521</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-11-30 13:05:21-0400</timestampReceived><subject>Re: SHA2 renaming</subject><body>

&gt; Even further than that, I think I'm saying that I would be inclined to
&gt; disagree that SHA256 is a mistaken naming.  What source do you have that
&gt; says the name "SHA2-256" is the right name?  From the sources I quoted,
&gt; including FIPS 180-4, the name is "SHA256".  I suggest, as a general

Err, I meant "SHA-256", not "SHA256", of course.

/Simon


</body></email><email><emailId>20120914064358</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-14 06:43:58-0400</timestampReceived><subject>List administrivia (was: Re: [PATCH] some patches to fix compiler warnings)</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; Yesterday, I send a 170Kb patch to the list... but it did not appear.
&gt; What can/should I do ?

It was held for moderation due to its size (current limit seems to be 40
KB). I just approved it. Did you get any useful reply from the list
manager?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120907085514</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-07 08:55:14-0400</timestampReceived><subject>[PATCH] some patches to fix compiler warnings</subject><body>

Some things I fixed, when having a look at the sources.

Just two points for code reviewing:

1.
#define NONNULL(...) __attribute__ ((nonnull(__VA_ARGS__)))
is contains a C99 feature (...), but there are also C99 long long constants 
somewhere in the code (if you mind C89 compliancy).

2.
In cast128.c I removed the wiping of t, l and r. Instead I set t=0 at the 
beginning of the loops (It seemed to be used uninitialized in F1 macro).
Please just have a short look into it - maybe the "wiping" has some 
undocumented deeper meaning !?

Regards, Tim

["0001-fixed-some-clang-analyzer-issues.patch" (text/x-patch)]

From f2ff94fe5f262901097e38d6f19e3438ba5c999d Mon Sep 17 00:00:00 2001
From: Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt;
Date: Wed, 5 Sep 2012 16:54:43 +0200
Subject: [PATCH 1/4] fixed some clang analyzer issues

---
 aclocal.m4                  |    2 ++
 cast128.c                   |    7 ++-----
 examples/eratosthenes.c     |    5 +++++
 examples/io.c               |   13 ++++++++++---
 examples/nettle-benchmark.c |    2 +-
 tools/misc.h                |   13 ++-----------
 tools/nettle-hash.c         |    3 ++-
 7 files changed, 24 insertions(+), 21 deletions(-)

diff --git a/aclocal.m4 b/aclocal.m4
index a94c20d..4a56165 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -337,10 +337,12 @@ AH_BOTTOM(
 # define NORETURN __attribute__ ((__noreturn__))
 # define PRINTF_STYLE(f, a) __attribute__ ((__format__ (__printf__, f, a)))
 # define UNUSED __attribute__ ((__unused__))
+# define NONNULL(...) __attribute__ ((nonnull(__VA_ARGS__)))
 #else
 # define NORETURN
 # define PRINTF_STYLE(f, a)
 # define UNUSED
+# define NONNULL(a)
 #endif
 ])])
 
diff --git a/cast128.c b/cast128.c
index 5e53bd9..2192e98 100644
--- a/cast128.c
+++ b/cast128.c
@@ -82,6 +82,7 @@ cast128_encrypt(const struct cast128_ctx *ctx,
       /* Get inblock into l,r */
       l = READ_UINT32(src);
       r = READ_UINT32(src+4);
+      t = 0;
 
       /* Do the work */
       F1(l, r,  0);
@@ -106,8 +107,6 @@ cast128_encrypt(const struct cast128_ctx *ctx,
       /* Put l,r into outblock */
       WRITE_UINT32(dst, r);
       WRITE_UINT32(dst + 4, l);
-      /* Wipe clean */
-      t = l = r = 0;
     }
 }
 
@@ -126,6 +125,7 @@ cast128_decrypt(const struct cast128_ctx *ctx,
       /* Get inblock into l,r */
       r = READ_UINT32(src);
       l = READ_UINT32(src+4);
+      t = 0;
 
       /* Do the work */
       /* Only do full 16 rounds if key length &gt; 80 bits */
@@ -151,9 +151,6 @@ cast128_decrypt(const struct cast128_ctx *ctx,
       /* Put l,r into outblock */
       WRITE_UINT32(dst, l);
       WRITE_UINT32(dst + 4, r);
-
-      /* Wipe clean */
-      t = l = r = 0;
     }
 }
 
diff --git a/examples/eratosthenes.c b/examples/eratosthenes.c
index 2b9d04f..0eea941 100644
--- a/examples/eratosthenes.c
+++ b/examples/eratosthenes.c
@@ -399,5 +399,10 @@ main (int argc, char **argv)
 	    printf("%lu\n", n);
 	}
     }
+
+  /* silence static analyzers */
+  free(block);
+  free(sieve);
+
   return EXIT_SUCCESS;
 }
diff --git a/examples/io.c b/examples/io.c
index 7b2289c..cda9ed3 100644
--- a/examples/io.c
+++ b/examples/io.c
@@ -125,7 +125,10 @@ read_file(const char *name, unsigned max_size, char **contents)
   fclose(f);
 
   /* NUL-terminate the data. */
-  buffer[done] = '\0';
+  if (buffer)
+    buffer[done] = '\0';
+  else
+    done = 0;
   *contents = buffer;
   
   return done;
@@ -156,7 +159,7 @@ int
 simple_random(struct yarrow256_ctx *ctx, const char *name)
 {
   unsigned length;
-  char *buffer;
+  char *buffer = NULL; /* silence static analyzer */
 
   if (name)
     length = read_file(name, 0, &amp;buffer);
@@ -164,7 +167,11 @@ simple_random(struct yarrow256_ctx *ctx, const char *name)
     length = read_file(RANDOM_DEVICE, 20, &amp;buffer);
   
   if (!length)
-    return 0;
+    {
+      if (buffer)
+        free(buffer);
+      return 0;
+    }
 
   yarrow256_seed(ctx, length, buffer);
 
diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index b76a91c..48e53d0 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -96,7 +96,7 @@ static double frequency = 0.0;
 #define BENCH_ITERATIONS 10
 #endif
 
-static void
+static void NORETURN
 die(const char *format, ...)
 {
   va_list args;
diff --git a/tools/misc.h b/tools/misc.h
index 70c9eeb..af55998 100644
--- a/tools/misc.h
+++ b/tools/misc.h
@@ -28,19 +28,10 @@
 #endif
 
 void
-die(const char *format, ...)
-#if __GNUC___
-     __attribute__((__format__ (__printf__,1, 2)))
-     __attribute__((__noreturn__))
-#endif
-     ;
+die(const char *format, ...) PRINTF_STYLE(1,2) NORETURN;
 
 void
-werror(const char *format, ...)
-#if __GNUC___
-     __attribute__((__format__ (__printf__,1, 2)))
-#endif
-     ;
+werror(const char *format, ...) PRINTF_STYLE(1,2);
 
 void *
 xalloc(size_t size);
diff --git a/tools/nettle-hash.c b/tools/nettle-hash.c
index 5710216..842f9ff 100644
--- a/tools/nettle-hash.c
+++ b/tools/nettle-hash.c
@@ -39,6 +39,7 @@
 
 #define BUFSIZE 16384
 
+
 static void
 list_algorithms (void)
 {
@@ -51,7 +52,7 @@ list_algorithms (void)
 	    alg-&gt;name, alg-&gt;digest_size, alg-&gt;block_size);
 };
 
-static const struct nettle_hash *
+static const struct nettle_hash * NONNULL(1)
 find_algorithm (const char *name)
 {
   const struct nettle_hash *alg;
-- 
1.7.10.4


["0002-silence-compiler-warnings-for-example-base16enc.c.patch" (text/x-patch)]

From b5bc1345dddab622ef07e09507f91a0ff54c8514 Mon Sep 17 00:00:00 2001
From: Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt;
Date: Fri, 7 Sep 2012 09:55:25 +0200
Subject: [PATCH 2/4] silence compiler warnings for example/base16enc.c

---
 examples/base16enc.c |   16 ----------------
 1 file changed, 16 deletions(-)

diff --git a/examples/base16enc.c b/examples/base16enc.c
index c3cb58f..3fc410e 100644
--- a/examples/base16enc.c
+++ b/examples/base16enc.c
@@ -47,21 +47,6 @@
 int
 main(int argc UNUSED, char **argv UNUSED)
 {
-
-  /* "buffer" will hold the bytes from disk: */
-  uint8_t * buffer = (uint8_t *) malloc (CHUNK_SIZE * sizeof(uint8_t));
-  if (buffer == NULL) {
-    fprintf (stderr, "Cannot allocate read buffer.\n");
-    return EXIT_FAILURE;
-  }
-
-  /* "result" will hold bytes before output: */
-  uint8_t * result = (uint8_t *) malloc (ENCODED_SIZE * sizeof(uint8_t));
-  if (result == NULL) {
-    fprintf (stderr, "Cannot allocate write buffer.\n");
-    return EXIT_FAILURE;
-  }
-
 #ifdef WIN32
   _setmode(0, O_BINARY);
 #endif
@@ -107,4 +92,3 @@ main(int argc UNUSED, char **argv UNUSED)
 	}
     }
 }
-
-- 
1.7.10.4


["0003-removed-unused-variables-from-pgp-encode.c-and-rsa2o.patch" (text/x-patch)]

From 67186919ffa0ba6b13c57ea28e4fa29b71a0ae03 Mon Sep 17 00:00:00 2001
From: Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt;
Date: Fri, 7 Sep 2012 10:26:36 +0200
Subject: [PATCH 3/4] removed unused variables from pgp-encode.c and
 rsa2openpgp.c

---
 pgp-encode.c  |    1 -
 rsa2openpgp.c |    1 -
 2 files changed, 2 deletions(-)

diff --git a/pgp-encode.c b/pgp-encode.c
index 9a69922..f84373c 100644
--- a/pgp-encode.c
+++ b/pgp-encode.c
@@ -246,7 +246,6 @@ pgp_put_rsa_sha1_signature(struct nettle_buffer *buffer,
   unsigned hash_end;
   unsigned sub_packet_start;
   uint8_t trailer[6];
-  uint8_t digest16[2];
   mpz_t s;
   
   /* Signature packet. The packet could reasonably be both smaller and
diff --git a/rsa2openpgp.c b/rsa2openpgp.c
index c4666f3..4c62f49 100644
--- a/rsa2openpgp.c
+++ b/rsa2openpgp.c
@@ -64,7 +64,6 @@ rsa_keypair_to_openpgp(struct nettle_buffer *buffer,
   time_t now = time(NULL);
 
   unsigned key_start;
-  unsigned key_length;
   unsigned userid_start;
   
   struct sha1_ctx key_hash;
-- 
1.7.10.4


["0004-use-PRINTF_STYLE-wherte-possible.patch" (text/x-patch)]

From 74eb0f0b91175f2d77074a9112b5fa6c8f9fa833 Mon Sep 17 00:00:00 2001
From: Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt;
Date: Fri, 7 Sep 2012 10:27:51 +0200
Subject: [PATCH 4/4] use PRINTF_STYLE wherte possible

---
 desdata.c                   |    2 +-
 examples/io.h               |    6 +-----
 examples/nettle-benchmark.c |    2 +-
 3 files changed, 3 insertions(+), 7 deletions(-)

diff --git a/desdata.c b/desdata.c
index fc89c2d..6671b5d 100644
--- a/desdata.c
+++ b/desdata.c
@@ -62,7 +62,7 @@ int sorder[] = {
 	7, 5, 3, 1, 6, 4, 2, 0,
 };
 
-int printf(const char *, ...);
+int printf(const char *, ...) PRINTF_STYLE(1,2);
 
 int
 main(int argc UNUSED, char **argv UNUSED)
diff --git a/examples/io.h b/examples/io.h
index ff4a18d..e83b7eb 100644
--- a/examples/io.h
+++ b/examples/io.h
@@ -37,11 +37,7 @@ void *
 xalloc(size_t size);
 
 void
-werror(const char *format, ...)
-#if __GNUC___
-     __attribute__((__format__ (__printf__,1, 2)))
-#endif
-     ;
+werror(const char *format, ...) PRINTF_STYLE(1,2);
 
 /* If size is &gt; 0, read at most that many bytes. If size == 0,
  * read until EOF. Allocates the buffer dynamically. */
diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index 48e53d0..3d07868 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -96,7 +96,7 @@ static double frequency = 0.0;
 #define BENCH_ITERATIONS 10
 #endif
 
-static void NORETURN
+static void NORETURN PRINTF_STYLE(1,2)
 die(const char *format, ...)
 {
   va_list args;
-- 
1.7.10.4



</body></email><email><emailId>20120907133729</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-07 13:37:29-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; Some things I fixed, when having a look at the sources.

Thanks.

I'm going to a reply to one or a few issues at a time. Feel free to
remind me if some things are still left unaddressed in a few weeks.

&gt; #define NONNULL(...) __attribute__ ((nonnull(__VA_ARGS__)))
&gt; is contains a C99 feature (...), but there are also C99 long long constants 
&gt; somewhere in the code (if you mind C89 compliancy).

I intend to stick to C89, except that I'll happily use features which
have been widely available for a long time even though not standardized.
Maybe the use of long long constants (where?) are of that type?

So I don't want to use __VA_ARGS__. In this particular case, shouldn't
it work fine with

  #define NONNULL(args) __attribute__ ((nonnull args))

to be used as, e.g., NONNULL((1)) ?

About __attribute__ nonnull, I have some questions.

1. Does it give any significant benefit, in terms of significant
   optimizations (I don't think I understand what optimizations it
   should make possible) or real bugs catched?

2. Since when (release and year) is it supported by gcc?

3. To really make use of it, we should add it to a lot of prototypes in
   the installed headers. That makes things a bit more complicated,
   since those headers can't use config.h.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120907140621</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-07 14:06:21-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Am Friday 07 September 2012 schrieb Niels Möller:
&gt; Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:
&gt; &gt; Some things I fixed, when having a look at the sources.
&gt; 
&gt; Thanks.
&gt; 
&gt; I'm going to a reply to one or a few issues at a time. Feel free to
&gt; remind me if some things are still left unaddressed in a few weeks.
&gt; 
&gt; &gt; #define NONNULL(...) __attribute__ ((nonnull(__VA_ARGS__)))
&gt; &gt; is contains a C99 feature (...), but there are also C99 long long
&gt; &gt; constants somewhere in the code (if you mind C89 compliancy).
&gt; 
&gt; I intend to stick to C89, except that I'll happily use features which
&gt; have been widely available for a long time even though not standardized.
&gt; Maybe the use of long long constants (where?) are of that type?
&gt; 
&gt; So I don't want to use __VA_ARGS__. In this particular case, shouldn't
&gt; it work fine with
&gt; 
&gt;   #define NONNULL(args) __attribute__ ((nonnull args))

Yes, functions with several non-null args than need several NONNULL(x) 
occurrences. That isn't too ugly.
Just change it as you like.

&gt; 
&gt; to be used as, e.g., NONNULL((1)) ?
&gt; 
&gt; About __attribute__ nonnull, I have some questions.
&gt; 
&gt; 1. Does it give any significant benefit, in terms of significant
&gt;    optimizations (I don't think I understand what optimizations it
&gt;    should make possible) or real bugs catched?

The idea of nonnull is to enable the compiler detecting possible NULL 
arguments where they must not be. E.g. char *s=NULL; strlen(s); would let the 
compiler print a warning.
Especially static analyzers can make use of nonnull attributes

Of course there is a BUT:
Gcc (IMHO, upto the 4.8) has a problem in detecting indirectly used NULL 
values. At the same time, when optimizing a function with a nonnull argument, 
gcc optimizes away checks against NULL for the appropriate variables.
see http://gcc.gnu.org/bugzilla/show_bug.cgi?id=17308

Example:
void f(char *arg) NONNULL(1) {
	if (arg) *arg=0;
}

would be optimized to
void f(char *arg) NONNULL(1) {
	*arg=0;
}

Since gcc can't detect indirect NULL values, the function may crash the 
process.

I am not shure, but maybe something like
#if defined(__clang__)
#  define NONNULL(args) __attribute__ ((nonnull args))
#endif

to make use of NONNULL at least for clang analyzing.

Different projects handle nonnull in different ways.
I, personally, wouldn't miss that feature...
 
&gt; 2. Since when (release and year) is it supported by gcc?

I found it to be for gcc &gt;= 3.3,
see http://ohse.de/uwe/articles/gcc-attributes.html#func-nonnull

&gt; 3. To really make use of it, we should add it to a lot of prototypes in
&gt;    the installed headers. That makes things a bit more complicated,
&gt;    since those headers can't use config.h.

The more functions we add nonnull to, the more segfaults the compiler should 
catch (see 1.).
The reason I used nonnull were several compiler warnings. The current libc6 
header files seem to use nonnull by default (gcc 4.7.1, libc6 2.13).
Maybe there should be -std=c89 in den CFLAGS to prevent that ?

&gt; Regards,
&gt; /Niels

Regards, Tim

</body></email><email><emailId>20120912211358</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-12 21:13:58-0400</timestampReceived><subject>[PATCH] PKCS #5 PBKDF2</subject><body>

How about adding KDFs?  Here is a starting pointer for the most common
function, PKCS #5 PBKDF2.  Review appreciated.

/Simon

["0001-New-PKCS-5-PBKDF2-function.patch" (text/x-diff)]

&gt; From 2fe9180d4b0afb7acb77622d541d5be21830fc7b Mon Sep 17 00:00:00 2001
From: Simon Josefsson &lt;simon@josefsson.org&gt;
Date: Wed, 12 Sep 2012 22:05:30 +0200
Subject: [PATCH] New PKCS #5 PBKDF2 function.

---
 ChangeLog                  |   14 ++++++
 Makefile.in                |    2 +
 NEWS                       |    6 +++
 nettle-internal.h          |    1 +
 nettle.texinfo             |   38 +++++++++++++++-
 pbkdf2.c                   |  103 ++++++++++++++++++++++++++++++++++++++++++++
 pbkdf2.h                   |   49 +++++++++++++++++++++
 testsuite/.gitignore       |    1 +
 testsuite/.test-rules.make |    3 ++
 testsuite/Makefile.in      |    2 +-
 testsuite/meta-hash-test.c |    3 ++
 testsuite/pbkdf2-test.c    |   51 ++++++++++++++++++++++
 12 files changed, 270 insertions(+), 3 deletions(-)
 create mode 100644 pbkdf2.c
 create mode 100644 pbkdf2.h
 create mode 100644 testsuite/pbkdf2-test.c

diff --git a/ChangeLog b/ChangeLog
index fe61ad9..a35f747 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,17 @@
+2012-09-12  Simon Josefsson  &lt;simon@josefsson.org&gt;
+
+	* NEWS: Mention addition of PBKDF2.
+	* pbkdf2.c (pbkdf2_hmac): New file and function.
+	* pbkdf2.h: Declare it.
+	* Makefile.in (nettle_SOURCES): Add pbkdf2.c.
+	(HEADERS): Add pbkdf2.h.
+	* testsuite/pbkdf2-test.c: New test case.
+	* nettle-internal.h (NETTLE_MAX_HASH_CONTEXT_SIZE): New constant.
+	* testsuite/meta-hash-test.c (test_main): Validate NETTLE_MAX_HASH_CONTEXT_SIZE.
+	* nettle.texinfo (Key derivation functions): New section.
+	* testsuite/Makefile.in (TS_NETTLE_SOURCES): Add pbkdf2-test.c.
+	* testsuite/.test-rules.make (pbkdf2-test): New target.
+
 2012-09-10  Niels Möller  &lt;nisse@lysator.liu.se&gt;
 
 	* examples/eratosthenes.c (main): Explicitly deallocate storage
diff --git a/Makefile.in b/Makefile.in
index cf93593..7c6cf33 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -77,6 +77,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 des3.c des-compat.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
+		 pbkdf2.c \
 		 knuth-lfib.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
@@ -123,6 +124,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h bignum.h blowfish.h \
 	  cbc.h ctr.h gcm.h \
 	  des.h des-compat.h dsa.h \
 	  hmac.h \
+	  pbkdf2.h \
 	  knuth-lfib.h \
 	  macros.h \
 	  md2.h md4.h \
diff --git a/NEWS b/NEWS
index 4957f80..ea846a7 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,9 @@
+
+	New features:
+
+	* Support for PKCS #5 PBKDF2.  Contributed by Simon Josefsson.
+          Specification in RFC 2898 and test vectors in RFC 6070.
+
 NEWS for the 2.5 release
 
 	This release includes important portability fixes for Windows
diff --git a/nettle-internal.h b/nettle-internal.h
index e85e3c5..a7a37f8 100644
--- a/nettle-internal.h
+++ b/nettle-internal.h
@@ -48,6 +48,7 @@ do { if (size &gt; (sizeof(name) / sizeof(name[0]))) abort(); } while \
(0)  #define NETTLE_MAX_BIGNUM_SIZE ((NETTLE_MAX_BIGNUM_BITS + 7)/8)
 #define NETTLE_MAX_HASH_BLOCK_SIZE 128
 #define NETTLE_MAX_HASH_DIGEST_SIZE 64
+#define NETTLE_MAX_HASH_CONTEXT_SIZE 2
 #define NETTLE_MAX_SEXP_ASSOC 17
 #define NETTLE_MAX_CIPHER_BLOCK_SIZE 32
 
diff --git a/nettle.texinfo b/nettle.texinfo
index 4904d91..d887ed9 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -70,6 +70,7 @@ Reference
 * Cipher functions::            
 * Cipher modes::                
 * Keyed hash functions::        
+* Key derivation functions::    
 * Public-key algorithms::       
 * Randomness::                  
 * Ascii encoding::              
@@ -316,6 +317,7 @@ This chapter describes all the Nettle functions, grouped by \
                family.
 * Cipher functions::            
 * Cipher modes::                
 * Keyed hash functions::        
+* Key derivation functions::    
 * Public-key algorithms::       
 * Randomness::                  
 * Ascii encoding::              
@@ -1852,7 +1854,7 @@ only the first @var{length} octets of the digest are written.
 
 
 
-@node Keyed hash functions, Public-key algorithms, Cipher modes, Reference
+@node Keyed hash functions, Key derivation functions, Cipher modes, Reference
 @comment  node-name,  next,  previous,  up
 @section Keyed Hash Functions
 
@@ -2102,7 +2104,39 @@ This function also resets the context for processing new \
messages, with  the same key.
 @end deftypefun
 
-@node Public-key algorithms, Randomness, Keyed hash functions, Reference
+@node Key derivation functions, Public-key algorithms, Keyed hash functions, \
Reference +@comment  node-name,  next,  previous,  up
+@section Key derivation Functions
+
+@cindex Key Derivation Function
+@cindex Password Based Key Derivation Function
+@cindex PKCS #5
+@cindex KDF
+@cindex PBKDF
+
+A @dfn{key derivation function} (@acronym{KDF}) is a function that from
+a given symmetric key derives other symmetric keys.  A sub-class of KDFs
+is the @dfn{password-based key derivation functions} (@acronym{PBKDFs}),
+which take as input a password or passphrase, and its purpose is
+typically to strengthen it and protect against certain pre-computation
+attacks by using salting and expensive computation.  The most well known
+PBKDF is the @code{PKCS #5 PBKDF2} described in @cite{RFC 2898} which
+uses a pseudorandom function such as @acronym{HMAC-SHA1}.
+
+Nettle's @acronym{PBKDF2} function is defined in @file{&lt;nettle/pbkdf2.h&gt;}.
+It contains a function:
+
+@deftypefun void pbkdf2_hmac (unsigned @var{Plen}, const uint8_t *@var{P}, unsigned \
@var{Slen}, const uint8_t *@var{S}, const struct nettle_hash *@var{hash}, unsigned \
int @var{c}, unsigned @var{dkLen}, uint8_t *@var{DK}) +
+Derive symmetric key from a password according to PKCS #5 PBKDF2.  The
+PRF is the HMAC familly with @var{hash} indicating the underlying hash
+function.  Inputs are the password @var{P} of length @var{Plen}, the
+salt @var{S} of length @var{Slen}, the iteration counter @var{C} (&gt; 0),
+and the desired derived output length @var{dkLen}.  The output buffer is
+@var{DK} which must have room for at least @var{dkLen} octets.
+@end deftypefun
+
+@node Public-key algorithms, Randomness, Key derivation functions, Reference
 @comment  node-name,  next,  previous,  up
 @section Public-key algorithms
 
diff --git a/pbkdf2.c b/pbkdf2.c
new file mode 100644
index 0000000..eab8f0a
--- /dev/null
+++ b/pbkdf2.c
@@ -0,0 +1,103 @@
+/* pbkdf2.c
+ *
+ * PKCS #5 password-based key derivation function PBKDF2, see RFC 2898.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "pbkdf2.h"
+
+#include "hmac.h"
+#include "nettle-internal.h"
+
+void
+pbkdf2_hmac (unsigned Plen, const uint8_t * P,
+	     unsigned Slen, const uint8_t * S,
+	     const struct nettle_hash *hash,
+	     unsigned int c, unsigned dkLen, uint8_t * DK)
+{
+  unsigned int hLen = hash-&gt;digest_size;
+  char U[NETTLE_MAX_HASH_DIGEST_SIZE];
+  char T[NETTLE_MAX_HASH_DIGEST_SIZE];
+  unsigned int u;
+  unsigned int l;
+  unsigned int r;
+  unsigned int i;
+  unsigned int k;
+  char tmp[4];
+  TMP_DECL (inner, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
+  TMP_DECL (outer, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
+  TMP_DECL (state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
+
+  if (c == 0)
+    return;
+
+  if (dkLen == 0)
+    return;
+
+  l = ((dkLen - 1) / hLen) + 1;
+  r = dkLen - (l - 1) * hLen;
+
+  TMP_ALLOC (inner, hash-&gt;context_size);
+  TMP_ALLOC (outer, hash-&gt;context_size);
+  TMP_ALLOC (state, hash-&gt;context_size);
+
+  for (i = 1; i &lt;= l; i++)
+    {
+      memset (T, 0, hLen);
+
+      for (u = 1; u &lt;= c; u++)
+	{
+	  hmac_set_key (outer, inner, state, hash, Plen, P);
+
+	  if (u == 1)
+	    {
+	      tmp[0] = (i &amp; 0xff000000) &gt;&gt; 24;
+	      tmp[1] = (i &amp; 0x00ff0000) &gt;&gt; 16;
+	      tmp[2] = (i &amp; 0x0000ff00) &gt;&gt; 8;
+	      tmp[3] = (i &amp; 0x000000ff) &gt;&gt; 0;
+
+	      hmac_update (state, hash, Slen, S);
+	      hmac_update (state, hash, 4, tmp);
+	    }
+	  else
+	    {
+	      hmac_set_key (outer, inner, state, hash, Plen, P);
+	      hmac_update (state, hash, hLen, U);
+	    }
+
+	  hmac_digest (outer, inner, state, hash, hLen, U);
+
+	  for (k = 0; k &lt; hLen; k++)
+	    T[k] ^= U[k];
+	}
+
+      memcpy (DK + (i - 1) * hLen, T, i == l ? r : hLen);
+    }
+}
diff --git a/pbkdf2.h b/pbkdf2.h
new file mode 100644
index 0000000..f2f42c5
--- /dev/null
+++ b/pbkdf2.h
@@ -0,0 +1,49 @@
+/* pbkdf2.c
+ *
+ * PKCS #5 password-based key derivation function PBKDF2, see RFC 2898.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#ifndef NETTLE_PBKDF2_H_INCLUDED
+#define NETTLE_PBKDF2_H_INCLUDED
+
+#include "nettle-meta.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* Namespace mangling */
+#define pbkdf2_hmac nettle_pbkdf2_hmac
+
+void
+pbkdf2_hmac (unsigned Plen, const uint8_t * P,
+	     unsigned Slen, const uint8_t * S,
+	     const struct nettle_hash *hash,
+	     unsigned int c, unsigned dkLen, uint8_t * DK);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_PBKDF2_H_INCLUDED */
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index c9f4698..b7ddd79 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -20,6 +20,7 @@
 /dsa-test
 /gcm-test
 /hmac-test
+/pbkdf2-test
 /knuth-lfib-test
 /md2-test
 /md4-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 10c993f..d8f8f23 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -88,6 +88,9 @@ gcm-test$(EXEEXT): gcm-test.$(OBJEXT)
 hmac-test$(EXEEXT): hmac-test.$(OBJEXT)
 	$(LINK) hmac-test.$(OBJEXT) $(TEST_OBJS) -o hmac-test$(EXEEXT)
 
+pbkdf2-test$(EXEEXT): pbkdf2-test.$(OBJEXT)
+	$(LINK) pbkdf2-test.$(OBJEXT) $(TEST_OBJS) -o pbkdf2-test$(EXEEXT)
+
 meta-hash-test$(EXEEXT): meta-hash-test.$(OBJEXT)
 	$(LINK) meta-hash-test.$(OBJEXT) $(TEST_OBJS) -o meta-hash-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 206a76e..86f365a 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -25,7 +25,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c ctr-test.c gcm-test.c hmac-test.c \
 		    meta-hash-test.c meta-cipher-test.c meta-armor-test.c \
-		    buffer-test.c yarrow-test.c
+		    buffer-test.c yarrow-test.c pbkdf2-test.c
 
 TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
 		     rsa2sexp-test.c sexp2rsa-test.c \
diff --git a/testsuite/meta-hash-test.c b/testsuite/meta-hash-test.c
index 6db279b..0a8c61c 100644
--- a/testsuite/meta-hash-test.c
+++ b/testsuite/meta-hash-test.c
@@ -1,4 +1,5 @@
 #include "testutils.h"
+#include "nettle-internal.h"
 #include "nettle-meta.h"
 
 const char* hashes[] = {
@@ -29,6 +30,8 @@ test_main(void)
   while (NULL != nettle_hashes[j])
     j++;
   ASSERT(j == count); /* we are not missing testing any hashes */
+  for (j = 0; NULL != nettle_hashes[j]; j++)
+    ASSERT(nettle_hashes[j]-&gt;context_size &lt;= NETTLE_MAX_HASH_CONTEXT_SIZE);
   SUCCESS();
 }
   
diff --git a/testsuite/pbkdf2-test.c b/testsuite/pbkdf2-test.c
new file mode 100644
index 0000000..45d11a7
--- /dev/null
+++ b/testsuite/pbkdf2-test.c
@@ -0,0 +1,51 @@
+#include "testutils.h"
+#include "pbkdf2.h"
+
+#define PBKDF2_HMAC_TEST(alg, plen, p, slen, s, c, dklen, expect) do {	\
+    dk[dklen] = 17;							\
+    pbkdf2_hmac (plen, p, slen, s, alg, c, dklen, dk);			\
+    ASSERT(MEMEQ (dklen, dk, expect));					\
+    ASSERT(dk[dklen] == 17);						\
+  } while (0)
+
+#define MAX_DKLEN 25
+
+int
+test_main (void)
+{
+  uint8_t dk[MAX_DKLEN + 1];
+
+  /* Test vectors for PBKDF2 from RFC 6070. */
+
+  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 8, "password", 4, "salt", 1, 20,
+		    H("0c60c80f961f0e71f3a9b524af6012062fe037a6"));
+
+  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 8, "password", 4, "salt", 2, 20,
+		    H("ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957"));
+
+  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 8, "password", 4, "salt", 4096, 20,
+		    H("4b007901b765489abead49d926f721d065a429c1"));
+
+#if 0				/* too slow */
+  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 8, "password", 4, "salt", 16777216, 20,
+		    H("eefe3d61cd4da4e4e9945b3d6ba2158c2634e984"));
+#endif
+
+  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 24, "passwordPASSWORDpassword",
+		    36, "saltSALTsaltSALTsaltSALTsaltSALTsalt", 4096, 25,
+		    H("3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038"));
+
+  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 9, "pass\0word", 5, "sa\0lt", 4096, 16,
+		    H("56fa6aa75548099dcc37d7f03425e0c3"));
+
+  /* PBKDF2-HMAC-SHA-256 test vectors confirmed with another
+     implementation.  */
+
+  PBKDF2_HMAC_TEST (&amp;nettle_sha256, 6, "passwd", 4, "salt", 1, 16,
+		    H("55ac046e56e3089fec1691c22544b605"));
+
+  PBKDF2_HMAC_TEST (&amp;nettle_sha256, 8, "Password", 4, "NaCl", 80000, 16,
+		    H("4ddcd8f60b98be21830cee5ef22701f9"));
+
+  SUCCESS ();
+}
-- 
1.7.9.5



</body></email><email><emailId>20120913080431</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-13 08:04:31-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; How about adding KDFs?  Here is a starting pointer for the most common
&gt; function, PKCS #5 PBKDF2.  Review appreciated.

I don't have time to review it at the moment, but I hope to be able to do
that within a few days. You may also want to have a look at

http://git.lysator.liu.se/lsh/lsh/blobs/master/src/pkcs5.c

which I wrote a long time ago. Probably not very useful for Nettle as
is, but I'll happily relicense it as LGPL if anything is derived from it.

One immediate comment: "PBKDF2" is an awful name :-/

Are there any other key derivation methods which are important?

Regards,
/Niels

&gt; /Simon
&gt; 
&gt; From 2fe9180d4b0afb7acb77622d541d5be21830fc7b Mon Sep 17 00:00:00 2001
&gt; From: Simon Josefsson &lt;simon@josefsson.org&gt;
&gt; Date: Wed, 12 Sep 2012 22:05:30 +0200
&gt; Subject: [PATCH] New PKCS #5 PBKDF2 function.
&gt; 
&gt; ---
&gt; ChangeLog                  |   14 ++++++
&gt; Makefile.in                |    2 +
&gt; NEWS                       |    6 +++
&gt; nettle-internal.h          |    1 +
&gt; nettle.texinfo             |   38 +++++++++++++++-
&gt; pbkdf2.c                   |  103 ++++++++++++++++++++++++++++++++++++++++++++
&gt; pbkdf2.h                   |   49 +++++++++++++++++++++
&gt; testsuite/.gitignore       |    1 +
&gt; testsuite/.test-rules.make |    3 ++
&gt; testsuite/Makefile.in      |    2 +-
&gt; testsuite/meta-hash-test.c |    3 ++
&gt; testsuite/pbkdf2-test.c    |   51 ++++++++++++++++++++++
&gt; 12 files changed, 270 insertions(+), 3 deletions(-)
&gt; create mode 100644 pbkdf2.c
&gt; create mode 100644 pbkdf2.h
&gt; create mode 100644 testsuite/pbkdf2-test.c
&gt; 
&gt; diff --git a/ChangeLog b/ChangeLog
&gt; index fe61ad9..a35f747 100644
&gt; --- a/ChangeLog
&gt; +++ b/ChangeLog
&gt; @@ -1,3 +1,17 @@
&gt; +2012-09-12  Simon Josefsson  &lt;simon@josefsson.org&gt;
&gt; +
&gt; +	* NEWS: Mention addition of PBKDF2.
&gt; +	* pbkdf2.c (pbkdf2_hmac): New file and function.
&gt; +	* pbkdf2.h: Declare it.
&gt; +	* Makefile.in (nettle_SOURCES): Add pbkdf2.c.
&gt; +	(HEADERS): Add pbkdf2.h.
&gt; +	* testsuite/pbkdf2-test.c: New test case.
&gt; +	* nettle-internal.h (NETTLE_MAX_HASH_CONTEXT_SIZE): New constant.
&gt; +	* testsuite/meta-hash-test.c (test_main): Validate NETTLE_MAX_HASH_CONTEXT_SIZE.
&gt; +	* nettle.texinfo (Key derivation functions): New section.
&gt; +	* testsuite/Makefile.in (TS_NETTLE_SOURCES): Add pbkdf2-test.c.
&gt; +	* testsuite/.test-rules.make (pbkdf2-test): New target.
&gt; +
&gt; 2012-09-10  Niels Möller  &lt;nisse@lysator.liu.se&gt;
&gt; 
&gt; 	* examples/eratosthenes.c (main): Explicitly deallocate storage
&gt; diff --git a/Makefile.in b/Makefile.in
&gt; index cf93593..7c6cf33 100644
&gt; --- a/Makefile.in
&gt; +++ b/Makefile.in
&gt; @@ -77,6 +77,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
&gt; 		 des3.c des-compat.c \
&gt; 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
&gt; 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
&gt; +		 pbkdf2.c \
&gt; 		 knuth-lfib.c \
&gt; 		 md2.c md2-meta.c md4.c md4-meta.c \
&gt; 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
&gt; @@ -123,6 +124,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h bignum.h blowfish.h \
&gt; 	  cbc.h ctr.h gcm.h \
&gt; 	  des.h des-compat.h dsa.h \
&gt; 	  hmac.h \
&gt; +	  pbkdf2.h \
&gt; 	  knuth-lfib.h \
&gt; 	  macros.h \
&gt; 	  md2.h md4.h \
&gt; diff --git a/NEWS b/NEWS
&gt; index 4957f80..ea846a7 100644
&gt; --- a/NEWS
&gt; +++ b/NEWS
&gt; @@ -1,3 +1,9 @@
&gt; +
&gt; +	New features:
&gt; +
&gt; +	* Support for PKCS #5 PBKDF2.  Contributed by Simon Josefsson.
&gt; +          Specification in RFC 2898 and test vectors in RFC 6070.
&gt; +
&gt; NEWS for the 2.5 release
&gt; 
&gt; 	This release includes important portability fixes for Windows
&gt; diff --git a/nettle-internal.h b/nettle-internal.h
&gt; index e85e3c5..a7a37f8 100644
&gt; --- a/nettle-internal.h
&gt; +++ b/nettle-internal.h
&gt; @@ -48,6 +48,7 @@ do { if (size &gt; (sizeof(name) / sizeof(name[0]))) abort(); } \
&gt; while (0) #define NETTLE_MAX_BIGNUM_SIZE ((NETTLE_MAX_BIGNUM_BITS + 7)/8)
&gt; #define NETTLE_MAX_HASH_BLOCK_SIZE 128
&gt; #define NETTLE_MAX_HASH_DIGEST_SIZE 64
&gt; +#define NETTLE_MAX_HASH_CONTEXT_SIZE 2
&gt; #define NETTLE_MAX_SEXP_ASSOC 17
&gt; #define NETTLE_MAX_CIPHER_BLOCK_SIZE 32
&gt; 
&gt; diff --git a/nettle.texinfo b/nettle.texinfo
&gt; index 4904d91..d887ed9 100644
&gt; --- a/nettle.texinfo
&gt; +++ b/nettle.texinfo
&gt; @@ -70,6 +70,7 @@ Reference
&gt; * Cipher functions::            
&gt; * Cipher modes::                
&gt; * Keyed hash functions::        
&gt; +* Key derivation functions::    
&gt; * Public-key algorithms::       
&gt; * Randomness::                  
&gt; * Ascii encoding::              
&gt; @@ -316,6 +317,7 @@ This chapter describes all the Nettle functions, grouped by \
&gt;                 family.
&gt; * Cipher functions::            
&gt; * Cipher modes::                
&gt; * Keyed hash functions::        
&gt; +* Key derivation functions::    
&gt; * Public-key algorithms::       
&gt; * Randomness::                  
&gt; * Ascii encoding::              
&gt; @@ -1852,7 +1854,7 @@ only the first @var{length} octets of the digest are written.
&gt; 
&gt; 
&gt; 
&gt; -@node Keyed hash functions, Public-key algorithms, Cipher modes, Reference
&gt; +@node Keyed hash functions, Key derivation functions, Cipher modes, Reference
&gt; @comment  node-name,  next,  previous,  up
&gt; @section Keyed Hash Functions
&gt; 
&gt; @@ -2102,7 +2104,39 @@ This function also resets the context for processing new \
&gt; messages, with the same key.
&gt; @end deftypefun
&gt; 
&gt; -@node Public-key algorithms, Randomness, Keyed hash functions, Reference
&gt; +@node Key derivation functions, Public-key algorithms, Keyed hash functions, \
&gt; Reference +@comment  node-name,  next,  previous,  up
&gt; +@section Key derivation Functions
&gt; +
&gt; +@cindex Key Derivation Function
&gt; +@cindex Password Based Key Derivation Function
&gt; +@cindex PKCS #5
&gt; +@cindex KDF
&gt; +@cindex PBKDF
&gt; +
&gt; +A @dfn{key derivation function} (@acronym{KDF}) is a function that from
&gt; +a given symmetric key derives other symmetric keys.  A sub-class of KDFs
&gt; +is the @dfn{password-based key derivation functions} (@acronym{PBKDFs}),
&gt; +which take as input a password or passphrase, and its purpose is
&gt; +typically to strengthen it and protect against certain pre-computation
&gt; +attacks by using salting and expensive computation.  The most well known
&gt; +PBKDF is the @code{PKCS #5 PBKDF2} described in @cite{RFC 2898} which
&gt; +uses a pseudorandom function such as @acronym{HMAC-SHA1}.
&gt; +
&gt; +Nettle's @acronym{PBKDF2} function is defined in @file{&lt;nettle/pbkdf2.h&gt;}.
&gt; +It contains a function:
&gt; +
&gt; +@deftypefun void pbkdf2_hmac (unsigned @var{Plen}, const uint8_t *@var{P}, \
&gt; unsigned @var{Slen}, const uint8_t *@var{S}, const struct nettle_hash *@var{hash}, \
&gt; unsigned int @var{c}, unsigned @var{dkLen}, uint8_t *@var{DK}) +
&gt; +Derive symmetric key from a password according to PKCS #5 PBKDF2.  The
&gt; +PRF is the HMAC familly with @var{hash} indicating the underlying hash
&gt; +function.  Inputs are the password @var{P} of length @var{Plen}, the
&gt; +salt @var{S} of length @var{Slen}, the iteration counter @var{C} (&gt; 0),
&gt; +and the desired derived output length @var{dkLen}.  The output buffer is
&gt; +@var{DK} which must have room for at least @var{dkLen} octets.
&gt; +@end deftypefun
&gt; +
&gt; +@node Public-key algorithms, Randomness, Key derivation functions, Reference
&gt; @comment  node-name,  next,  previous,  up
&gt; @section Public-key algorithms
&gt; 
&gt; diff --git a/pbkdf2.c b/pbkdf2.c
&gt; new file mode 100644
&gt; index 0000000..eab8f0a
&gt; --- /dev/null
&gt; +++ b/pbkdf2.c
&gt; @@ -0,0 +1,103 @@
&gt; +/* pbkdf2.c
&gt; + *
&gt; + * PKCS #5 password-based key derivation function PBKDF2, see RFC 2898.
&gt; + */
&gt; +
&gt; +/* nettle, low-level cryptographics library
&gt; + *
&gt; + * Copyright (C) 2012 Simon Josefsson
&gt; + *
&gt; + * The nettle library is free software; you can redistribute it and/or modify
&gt; + * it under the terms of the GNU Lesser General Public License as published by
&gt; + * the Free Software Foundation; either version 2.1 of the License, or (at your
&gt; + * option) any later version.
&gt; + *
&gt; + * The nettle library is distributed in the hope that it will be useful, but
&gt; + * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&gt; + * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
&gt; + * License for more details.
&gt; + *
&gt; + * You should have received a copy of the GNU Lesser General Public License
&gt; + * along with the nettle library; see the file COPYING.LIB.  If not, write to
&gt; + * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
&gt; + * MA 02111-1301, USA.
&gt; + */
&gt; +
&gt; +#if HAVE_CONFIG_H
&gt; +# include "config.h"
&gt; +#endif
&gt; +
&gt; +#include &lt;assert.h&gt;
&gt; +#include &lt;stdlib.h&gt;
&gt; +#include &lt;string.h&gt;
&gt; +
&gt; +#include "pbkdf2.h"
&gt; +
&gt; +#include "hmac.h"
&gt; +#include "nettle-internal.h"
&gt; +
&gt; +void
&gt; +pbkdf2_hmac (unsigned Plen, const uint8_t * P,
&gt; +	     unsigned Slen, const uint8_t * S,
&gt; +	     const struct nettle_hash *hash,
&gt; +	     unsigned int c, unsigned dkLen, uint8_t * DK)
&gt; +{
&gt; +  unsigned int hLen = hash-&gt;digest_size;
&gt; +  char U[NETTLE_MAX_HASH_DIGEST_SIZE];
&gt; +  char T[NETTLE_MAX_HASH_DIGEST_SIZE];
&gt; +  unsigned int u;
&gt; +  unsigned int l;
&gt; +  unsigned int r;
&gt; +  unsigned int i;
&gt; +  unsigned int k;
&gt; +  char tmp[4];
&gt; +  TMP_DECL (inner, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt; +  TMP_DECL (outer, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt; +  TMP_DECL (state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt; +
&gt; +  if (c == 0)
&gt; +    return;
&gt; +
&gt; +  if (dkLen == 0)
&gt; +    return;
&gt; +
&gt; +  l = ((dkLen - 1) / hLen) + 1;
&gt; +  r = dkLen - (l - 1) * hLen;
&gt; +
&gt; +  TMP_ALLOC (inner, hash-&gt;context_size);
&gt; +  TMP_ALLOC (outer, hash-&gt;context_size);
&gt; +  TMP_ALLOC (state, hash-&gt;context_size);
&gt; +
&gt; +  for (i = 1; i &lt;= l; i++)
&gt; +    {
&gt; +      memset (T, 0, hLen);
&gt; +
&gt; +      for (u = 1; u &lt;= c; u++)
&gt; +	{
&gt; +	  hmac_set_key (outer, inner, state, hash, Plen, P);
&gt; +
&gt; +	  if (u == 1)
&gt; +	    {
&gt; +	      tmp[0] = (i &amp; 0xff000000) &gt;&gt; 24;
&gt; +	      tmp[1] = (i &amp; 0x00ff0000) &gt;&gt; 16;
&gt; +	      tmp[2] = (i &amp; 0x0000ff00) &gt;&gt; 8;
&gt; +	      tmp[3] = (i &amp; 0x000000ff) &gt;&gt; 0;
&gt; +
&gt; +	      hmac_update (state, hash, Slen, S);
&gt; +	      hmac_update (state, hash, 4, tmp);
&gt; +	    }
&gt; +	  else
&gt; +	    {
&gt; +	      hmac_set_key (outer, inner, state, hash, Plen, P);
&gt; +	      hmac_update (state, hash, hLen, U);
&gt; +	    }
&gt; +
&gt; +	  hmac_digest (outer, inner, state, hash, hLen, U);
&gt; +
&gt; +	  for (k = 0; k &lt; hLen; k++)
&gt; +	    T[k] ^= U[k];
&gt; +	}
&gt; +
&gt; +      memcpy (DK + (i - 1) * hLen, T, i == l ? r : hLen);
&gt; +    }
&gt; +}
&gt; diff --git a/pbkdf2.h b/pbkdf2.h
&gt; new file mode 100644
&gt; index 0000000..f2f42c5
&gt; --- /dev/null
&gt; +++ b/pbkdf2.h
&gt; @@ -0,0 +1,49 @@
&gt; +/* pbkdf2.c
&gt; + *
&gt; + * PKCS #5 password-based key derivation function PBKDF2, see RFC 2898.
&gt; + */
&gt; +
&gt; +/* nettle, low-level cryptographics library
&gt; + *
&gt; + * Copyright (C) 2012 Simon Josefsson
&gt; + *
&gt; + * The nettle library is free software; you can redistribute it and/or modify
&gt; + * it under the terms of the GNU Lesser General Public License as published by
&gt; + * the Free Software Foundation; either version 2.1 of the License, or (at your
&gt; + * option) any later version.
&gt; + *
&gt; + * The nettle library is distributed in the hope that it will be useful, but
&gt; + * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&gt; + * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
&gt; + * License for more details.
&gt; + *
&gt; + * You should have received a copy of the GNU Lesser General Public License
&gt; + * along with the nettle library; see the file COPYING.LIB.  If not, write to
&gt; + * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
&gt; + * MA 02111-1301, USA.
&gt; + */
&gt; +
&gt; +#ifndef NETTLE_PBKDF2_H_INCLUDED
&gt; +#define NETTLE_PBKDF2_H_INCLUDED
&gt; +
&gt; +#include "nettle-meta.h"
&gt; +
&gt; +#ifdef __cplusplus
&gt; +extern "C"
&gt; +{
&gt; +#endif
&gt; +
&gt; +/* Namespace mangling */
&gt; +#define pbkdf2_hmac nettle_pbkdf2_hmac
&gt; +
&gt; +void
&gt; +pbkdf2_hmac (unsigned Plen, const uint8_t * P,
&gt; +	     unsigned Slen, const uint8_t * S,
&gt; +	     const struct nettle_hash *hash,
&gt; +	     unsigned int c, unsigned dkLen, uint8_t * DK);
&gt; +
&gt; +#ifdef __cplusplus
&gt; +}
&gt; +#endif
&gt; +
&gt; +#endif /* NETTLE_PBKDF2_H_INCLUDED */
&gt; diff --git a/testsuite/.gitignore b/testsuite/.gitignore
&gt; index c9f4698..b7ddd79 100644
&gt; --- a/testsuite/.gitignore
&gt; +++ b/testsuite/.gitignore
&gt; @@ -20,6 +20,7 @@
&gt; /dsa-test
&gt; /gcm-test
&gt; /hmac-test
&gt; +/pbkdf2-test
&gt; /knuth-lfib-test
&gt; /md2-test
&gt; /md4-test
&gt; diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
&gt; index 10c993f..d8f8f23 100644
&gt; --- a/testsuite/.test-rules.make
&gt; +++ b/testsuite/.test-rules.make
&gt; @@ -88,6 +88,9 @@ gcm-test$(EXEEXT): gcm-test.$(OBJEXT)
&gt; hmac-test$(EXEEXT): hmac-test.$(OBJEXT)
&gt; 	$(LINK) hmac-test.$(OBJEXT) $(TEST_OBJS) -o hmac-test$(EXEEXT)
&gt; 
&gt; +pbkdf2-test$(EXEEXT): pbkdf2-test.$(OBJEXT)
&gt; +	$(LINK) pbkdf2-test.$(OBJEXT) $(TEST_OBJS) -o pbkdf2-test$(EXEEXT)
&gt; +
&gt; meta-hash-test$(EXEEXT): meta-hash-test.$(OBJEXT)
&gt; 	$(LINK) meta-hash-test.$(OBJEXT) $(TEST_OBJS) -o meta-hash-test$(EXEEXT)
&gt; 
&gt; diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
&gt; index 206a76e..86f365a 100644
&gt; --- a/testsuite/Makefile.in
&gt; +++ b/testsuite/Makefile.in
&gt; @@ -25,7 +25,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
&gt; 		    knuth-lfib-test.c \
&gt; 		    cbc-test.c ctr-test.c gcm-test.c hmac-test.c \
&gt; 		    meta-hash-test.c meta-cipher-test.c meta-armor-test.c \
&gt; -		    buffer-test.c yarrow-test.c
&gt; +		    buffer-test.c yarrow-test.c pbkdf2-test.c
&gt; 
&gt; TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
&gt; 		     rsa2sexp-test.c sexp2rsa-test.c \
&gt; diff --git a/testsuite/meta-hash-test.c b/testsuite/meta-hash-test.c
&gt; index 6db279b..0a8c61c 100644
&gt; --- a/testsuite/meta-hash-test.c
&gt; +++ b/testsuite/meta-hash-test.c
&gt; @@ -1,4 +1,5 @@
&gt; #include "testutils.h"
&gt; +#include "nettle-internal.h"
&gt; #include "nettle-meta.h"
&gt; 
&gt; const char* hashes[] = {
&gt; @@ -29,6 +30,8 @@ test_main(void)
&gt; while (NULL != nettle_hashes[j])
&gt; j++;
&gt; ASSERT(j == count); /* we are not missing testing any hashes */
&gt; +  for (j = 0; NULL != nettle_hashes[j]; j++)
&gt; +    ASSERT(nettle_hashes[j]-&gt;context_size &lt;= NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt; SUCCESS();
&gt; }
&gt; 
&gt; diff --git a/testsuite/pbkdf2-test.c b/testsuite/pbkdf2-test.c
&gt; new file mode 100644
&gt; index 0000000..45d11a7
&gt; --- /dev/null
&gt; +++ b/testsuite/pbkdf2-test.c
&gt; @@ -0,0 +1,51 @@
&gt; +#include "testutils.h"
&gt; +#include "pbkdf2.h"
&gt; +
&gt; +#define PBKDF2_HMAC_TEST(alg, plen, p, slen, s, c, dklen, expect) do {	\
&gt; +    dk[dklen] = 17;							\
&gt; +    pbkdf2_hmac (plen, p, slen, s, alg, c, dklen, dk);			\
&gt; +    ASSERT(MEMEQ (dklen, dk, expect));					\
&gt; +    ASSERT(dk[dklen] == 17);						\
&gt; +  } while (0)
&gt; +
&gt; +#define MAX_DKLEN 25
&gt; +
&gt; +int
&gt; +test_main (void)
&gt; +{
&gt; +  uint8_t dk[MAX_DKLEN + 1];
&gt; +
&gt; +  /* Test vectors for PBKDF2 from RFC 6070. */
&gt; +
&gt; +  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 8, "password", 4, "salt", 1, 20,
&gt; +		    H("0c60c80f961f0e71f3a9b524af6012062fe037a6"));
&gt; +
&gt; +  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 8, "password", 4, "salt", 2, 20,
&gt; +		    H("ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957"));
&gt; +
&gt; +  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 8, "password", 4, "salt", 4096, 20,
&gt; +		    H("4b007901b765489abead49d926f721d065a429c1"));
&gt; +
&gt; +#if 0				/* too slow */
&gt; +  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 8, "password", 4, "salt", 16777216, 20,
&gt; +		    H("eefe3d61cd4da4e4e9945b3d6ba2158c2634e984"));
&gt; +#endif
&gt; +
&gt; +  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 24, "passwordPASSWORDpassword",
&gt; +		    36, "saltSALTsaltSALTsaltSALTsaltSALTsalt", 4096, 25,
&gt; +		    H("3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038"));
&gt; +
&gt; +  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 9, "pass\0word", 5, "sa\0lt", 4096, 16,
&gt; +		    H("56fa6aa75548099dcc37d7f03425e0c3"));
&gt; +
&gt; +  /* PBKDF2-HMAC-SHA-256 test vectors confirmed with another
&gt; +     implementation.  */
&gt; +
&gt; +  PBKDF2_HMAC_TEST (&amp;nettle_sha256, 6, "passwd", 4, "salt", 1, 16,
&gt; +		    H("55ac046e56e3089fec1691c22544b605"));
&gt; +
&gt; +  PBKDF2_HMAC_TEST (&amp;nettle_sha256, 8, "Password", 4, "NaCl", 80000, 16,
&gt; +		    H("4ddcd8f60b98be21830cee5ef22701f9"));
&gt; +
&gt; +  SUCCESS ();
&gt; +}

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120913081651</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-13 08:16:51-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; How about adding KDFs?  Here is a starting pointer for the most common
&gt;&gt; function, PKCS #5 PBKDF2.  Review appreciated.
&gt;
&gt; I don't have time to review it at the moment, but I hope to be able to do
&gt; that within a few days. You may also want to have a look at
&gt;
&gt; http://git.lysator.liu.se/lsh/lsh/blobs/master/src/pkcs5.c
&gt;
&gt; which I wrote a long time ago. Probably not very useful for Nettle as
&gt; is, but I'll happily relicense it as LGPL if anything is derived from it.

Possibly the block_count stuff could be used, although I'm not sure how
it works: if you have a large dkLen wouldn't more than the final octet
be needed?

&gt; One immediate comment: "PBKDF2" is an awful name :-/

Yes...

&gt; Are there any other key derivation methods which are important?

Widely used KDF's include the OpenPGP s2k, TLS (different variants),
Kerberos.  More recent KDF's include HKDF and scrypt.  I'm sure there
are more.

However, I'm not certain 1) it makes sense to implement several KDFs in
nettle, 2) whether an generic interface can be found.  Re 2) it seems
KDFs are highly parametrized for its specialized purpose, and thus
require special parameters.

/Simon

</body></email><email><emailId>20120913083054</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-13 08:30:54-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Possibly the block_count stuff could be used, although I'm not sure how
&gt; it works: if you have a large dkLen wouldn't more than the final octet
&gt; be needed?

In general, one could have something larger. In lsh I use it only for
encrypted private keys, and then I don't need anything larger than, say
256 bits key and 128 bits iv.

&gt; However, I'm not certain 1) it makes sense to implement several KDFs in
&gt; nettle,

I imagine main use would be to decrypt alien password-encrypted data.
E.g., gpg keyrings and private keys for any other tools (what is openssh
using?) So any method which is used in more than one non-obscure
application would make some sense to support.

2) whether an generic interface can be found.

I don't think we need to worry about a generic interface now. I was more
thinking about proper naming for the non-generic interface. E.g, can we
say "pkcs5" rather than "pbdwhatever", or are there other methods
defined in pkcs#5 (or likely to be in the future)? Naming should be
reasonable now, and still not break down if we add other methods later.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120913085243</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-13 08:52:43-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; Possibly the block_count stuff could be used, although I'm not sure how
&gt;&gt; it works: if you have a large dkLen wouldn't more than the final octet
&gt;&gt; be needed?
&gt;
&gt; In general, one could have something larger. In lsh I use it only for
&gt; encrypted private keys, and then I don't need anything larger than, say
&gt; 256 bits key and 128 bits iv.

Ah.  I have some uses that require long outputs, and a generic
implementation should support that.

&gt;&gt; However, I'm not certain 1) it makes sense to implement several KDFs in
&gt;&gt; nettle,
&gt;
&gt; I imagine main use would be to decrypt alien password-encrypted data.
&gt; E.g., gpg keyrings and private keys for any other tools (what is
&gt; openssh using?) So any method which is used in more than one
&gt; non-obscure application would make some sense to support.

Not all KDFs are password-based, though, but I think it is the
password-based KDFs that are most useful to support in the near term.
HKDF is a recent strong candidate though.

&gt; 2) whether an generic interface can be found.
&gt;
&gt; I don't think we need to worry about a generic interface now. I was more
&gt; thinking about proper naming for the non-generic interface. E.g, can we
&gt; say "pkcs5" rather than "pbdwhatever", or are there other methods
&gt; defined in pkcs#5 (or likely to be in the future)? Naming should be
&gt; reasonable now, and still not break down if we add other methods later.

PKCS#5 specify an obsolete PBKDF1 as well, and several other algorithms,
so PKCS#5 as a name is not that unique.  Possibly pkcs5_pbkdf2_hmac
would be more precise, although it is longer.

/Simon

</body></email><email><emailId>20120918072836</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-18 07:28:36-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt;&gt; 2) whether an generic interface can be found.
&gt;&gt;
&gt;&gt; I don't think we need to worry about a generic interface now. I was more
&gt;&gt; thinking about proper naming for the non-generic interface. E.g, can we
&gt;&gt; say "pkcs5" rather than "pbdwhatever", or are there other methods
&gt;&gt; defined in pkcs#5 (or likely to be in the future)? Naming should be
&gt;&gt; reasonable now, and still not break down if we add other methods later.
&gt;
&gt; PKCS#5 specify an obsolete PBKDF1 as well, and several other algorithms,
&gt; so PKCS#5 as a name is not that unique.  Possibly pkcs5_pbkdf2_hmac
&gt; would be more precise, although it is longer.

I noticed this recent document that register the name "PBKDF2" and never
mentions PKCS5 so I think PBKDF2 is the best name we can use.

Is there any other open issue?  I could update the patch to work with
the new testsuite interface, if that would help review.

/Simon

</body></email><email><emailId>20120918074855</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-18 07:48:55-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Is there any other open issue?  I could update the patch to work with
&gt; the new testsuite interface, if that would help review.

Preparing an updated patch was easy, here it is and should apply to git
master.  This improves on a few minor issues compared to the old patch.

/Simon

["0001-Add-support-for-PKCS-5-PBKDF2.patch" (text/x-diff)]

&gt; From a0e9fabe97896ac0b80638472b62b3340b0a4425 Mon Sep 17 00:00:00 2001
From: Simon Josefsson &lt;simon@josefsson.org&gt;
Date: Tue, 18 Sep 2012 09:44:08 +0200
Subject: [PATCH] Add support for PKCS#5 PBKDF2.

---
 ChangeLog                  |   14 ++++++
 Makefile.in                |    2 +
 NEWS                       |    6 +++
 nettle-internal.h          |    1 +
 nettle.texinfo             |   42 +++++++++++++++++-
 pbkdf2.c                   |  103 ++++++++++++++++++++++++++++++++++++++++++++
 pbkdf2.h                   |   49 +++++++++++++++++++++
 testsuite/.gitignore       |    1 +
 testsuite/.test-rules.make |    3 ++
 testsuite/Makefile.in      |    2 +-
 testsuite/meta-hash-test.c |    3 ++
 testsuite/pbkdf2-test.c    |   49 +++++++++++++++++++++
 12 files changed, 272 insertions(+), 3 deletions(-)
 create mode 100644 pbkdf2.c
 create mode 100644 pbkdf2.h
 create mode 100644 testsuite/pbkdf2-test.c

diff --git a/ChangeLog b/ChangeLog
index f2a2010..cc3f661 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,17 @@
+2012-09-12  Simon Josefsson  &lt;simon@josefsson.org&gt;
+
+	* NEWS: Mention addition of PBKDF2.
+	* pbkdf2.c (pbkdf2_hmac): New file and function.
+	* pbkdf2.h: Declare it.
+	* Makefile.in (nettle_SOURCES): Add pbkdf2.c.
+	(HEADERS): Add pbkdf2.h.
+	* nettle-internal.h (NETTLE_MAX_HASH_CONTEXT_SIZE): New constant.
+	* nettle.texinfo (Key derivation functions): New section.
+	* testsuite/pbkdf2-test.c: New test case.
+	* testsuite/meta-hash-test.c (test_main): Validate NETTLE_MAX_HASH_CONTEXT_SIZE.
+	* testsuite/Makefile.in (TS_NETTLE_SOURCES): Add pbkdf2-test.c.
+	* testsuite/.test-rules.make (pbkdf2-test): New target.
+
 2012-09-16  Niels Möller  &lt;nisse@lysator.liu.se&gt;
 
 	* testsuite/: Overhaul of testsuite, affecting almost all files.
diff --git a/Makefile.in b/Makefile.in
index cf93593..7c6cf33 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -77,6 +77,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 des3.c des-compat.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
+		 pbkdf2.c \
 		 knuth-lfib.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
@@ -123,6 +124,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h bignum.h blowfish.h \
 	  cbc.h ctr.h gcm.h \
 	  des.h des-compat.h dsa.h \
 	  hmac.h \
+	  pbkdf2.h \
 	  knuth-lfib.h \
 	  macros.h \
 	  md2.h md4.h \
diff --git a/NEWS b/NEWS
index 4957f80..ea846a7 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,9 @@
+
+	New features:
+
+	* Support for PKCS #5 PBKDF2.  Contributed by Simon Josefsson.
+          Specification in RFC 2898 and test vectors in RFC 6070.
+
 NEWS for the 2.5 release
 
 	This release includes important portability fixes for Windows
diff --git a/nettle-internal.h b/nettle-internal.h
index e85e3c5..510909b 100644
--- a/nettle-internal.h
+++ b/nettle-internal.h
@@ -48,6 +48,7 @@ do { if (size &gt; (sizeof(name) / sizeof(name[0]))) abort(); } while \
(0)  #define NETTLE_MAX_BIGNUM_SIZE ((NETTLE_MAX_BIGNUM_BITS + 7)/8)
 #define NETTLE_MAX_HASH_BLOCK_SIZE 128
 #define NETTLE_MAX_HASH_DIGEST_SIZE 64
+#define NETTLE_MAX_HASH_CONTEXT_SIZE 216
 #define NETTLE_MAX_SEXP_ASSOC 17
 #define NETTLE_MAX_CIPHER_BLOCK_SIZE 32
 
diff --git a/nettle.texinfo b/nettle.texinfo
index 4904d91..a8fd233 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -70,6 +70,7 @@ Reference
 * Cipher functions::            
 * Cipher modes::                
 * Keyed hash functions::        
+* Key derivation functions::    
 * Public-key algorithms::       
 * Randomness::                  
 * Ascii encoding::              
@@ -199,6 +200,10 @@ implementation (in the public domain), adapted to Nettle by \
Simon  Josefsson, and heavily modified by Niels Möller. Assembly for x86_64 by
 Niels Möller. Released under the LGPL.
 
+@item PBKDF2
+The C implementation of PBKDF2 is based on earlier work for Shishi and
+GnuTLS by Simon Josefsson.  Released under the LGPL.
+
 @item SERPENT
 The implementation of the SERPENT cipher is based on the code in libgcrypt,
 copyright owned by the Free Software Foundation. Adapted to Nettle by
@@ -316,6 +321,7 @@ This chapter describes all the Nettle functions, grouped by \
                family.
 * Cipher functions::            
 * Cipher modes::                
 * Keyed hash functions::        
+* Key derivation functions::    
 * Public-key algorithms::       
 * Randomness::                  
 * Ascii encoding::              
@@ -1852,7 +1858,7 @@ only the first @var{length} octets of the digest are written.
 
 
 
-@node Keyed hash functions, Public-key algorithms, Cipher modes, Reference
+@node Keyed hash functions, Key derivation functions, Cipher modes, Reference
 @comment  node-name,  next,  previous,  up
 @section Keyed Hash Functions
 
@@ -2102,7 +2108,39 @@ This function also resets the context for processing new \
messages, with  the same key.
 @end deftypefun
 
-@node Public-key algorithms, Randomness, Keyed hash functions, Reference
+@node Key derivation functions, Public-key algorithms, Keyed hash functions, \
Reference +@comment  node-name,  next,  previous,  up
+@section Key derivation Functions
+
+@cindex Key Derivation Function
+@cindex Password Based Key Derivation Function
+@cindex PKCS #5
+@cindex KDF
+@cindex PBKDF
+
+A @dfn{key derivation function} (@acronym{KDF}) is a function that from
+a given symmetric key derives other symmetric keys.  A sub-class of KDFs
+is the @dfn{password-based key derivation functions} (@acronym{PBKDFs}),
+which take as input a password or passphrase, and its purpose is
+typically to strengthen it and protect against certain pre-computation
+attacks by using salting and expensive computation.  The most well known
+PBKDF is the @code{PKCS #5 PBKDF2} described in @cite{RFC 2898} which
+uses a pseudorandom function such as @acronym{HMAC-SHA1}.
+
+Nettle's @acronym{PBKDF2} function is defined in @file{&lt;nettle/pbkdf2.h&gt;}.
+It contains a function:
+
+@deftypefun void pbkdf2_hmac (unsigned @var{Plen}, const uint8_t *@var{P}, unsigned \
@var{Slen}, const uint8_t *@var{S}, const struct nettle_hash *@var{hash}, unsigned \
int @var{c}, unsigned @var{dkLen}, uint8_t *@var{DK}) +
+Derive symmetric key from a password according to PKCS #5 PBKDF2.  The
+PRF is the HMAC familly with @var{hash} indicating the underlying hash
+function.  Inputs are the password @var{P} of length @var{Plen}, the
+salt @var{S} of length @var{Slen}, the iteration counter @var{C} (&gt; 0),
+and the desired derived output length @var{dkLen}.  The output buffer is
+@var{DK} which must have room for at least @var{dkLen} octets.
+@end deftypefun
+
+@node Public-key algorithms, Randomness, Key derivation functions, Reference
 @comment  node-name,  next,  previous,  up
 @section Public-key algorithms
 
diff --git a/pbkdf2.c b/pbkdf2.c
new file mode 100644
index 0000000..eab8f0a
--- /dev/null
+++ b/pbkdf2.c
@@ -0,0 +1,103 @@
+/* pbkdf2.c
+ *
+ * PKCS #5 password-based key derivation function PBKDF2, see RFC 2898.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "pbkdf2.h"
+
+#include "hmac.h"
+#include "nettle-internal.h"
+
+void
+pbkdf2_hmac (unsigned Plen, const uint8_t * P,
+	     unsigned Slen, const uint8_t * S,
+	     const struct nettle_hash *hash,
+	     unsigned int c, unsigned dkLen, uint8_t * DK)
+{
+  unsigned int hLen = hash-&gt;digest_size;
+  char U[NETTLE_MAX_HASH_DIGEST_SIZE];
+  char T[NETTLE_MAX_HASH_DIGEST_SIZE];
+  unsigned int u;
+  unsigned int l;
+  unsigned int r;
+  unsigned int i;
+  unsigned int k;
+  char tmp[4];
+  TMP_DECL (inner, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
+  TMP_DECL (outer, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
+  TMP_DECL (state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
+
+  if (c == 0)
+    return;
+
+  if (dkLen == 0)
+    return;
+
+  l = ((dkLen - 1) / hLen) + 1;
+  r = dkLen - (l - 1) * hLen;
+
+  TMP_ALLOC (inner, hash-&gt;context_size);
+  TMP_ALLOC (outer, hash-&gt;context_size);
+  TMP_ALLOC (state, hash-&gt;context_size);
+
+  for (i = 1; i &lt;= l; i++)
+    {
+      memset (T, 0, hLen);
+
+      for (u = 1; u &lt;= c; u++)
+	{
+	  hmac_set_key (outer, inner, state, hash, Plen, P);
+
+	  if (u == 1)
+	    {
+	      tmp[0] = (i &amp; 0xff000000) &gt;&gt; 24;
+	      tmp[1] = (i &amp; 0x00ff0000) &gt;&gt; 16;
+	      tmp[2] = (i &amp; 0x0000ff00) &gt;&gt; 8;
+	      tmp[3] = (i &amp; 0x000000ff) &gt;&gt; 0;
+
+	      hmac_update (state, hash, Slen, S);
+	      hmac_update (state, hash, 4, tmp);
+	    }
+	  else
+	    {
+	      hmac_set_key (outer, inner, state, hash, Plen, P);
+	      hmac_update (state, hash, hLen, U);
+	    }
+
+	  hmac_digest (outer, inner, state, hash, hLen, U);
+
+	  for (k = 0; k &lt; hLen; k++)
+	    T[k] ^= U[k];
+	}
+
+      memcpy (DK + (i - 1) * hLen, T, i == l ? r : hLen);
+    }
+}
diff --git a/pbkdf2.h b/pbkdf2.h
new file mode 100644
index 0000000..f2f42c5
--- /dev/null
+++ b/pbkdf2.h
@@ -0,0 +1,49 @@
+/* pbkdf2.c
+ *
+ * PKCS #5 password-based key derivation function PBKDF2, see RFC 2898.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#ifndef NETTLE_PBKDF2_H_INCLUDED
+#define NETTLE_PBKDF2_H_INCLUDED
+
+#include "nettle-meta.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* Namespace mangling */
+#define pbkdf2_hmac nettle_pbkdf2_hmac
+
+void
+pbkdf2_hmac (unsigned Plen, const uint8_t * P,
+	     unsigned Slen, const uint8_t * S,
+	     const struct nettle_hash *hash,
+	     unsigned int c, unsigned dkLen, uint8_t * DK);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_PBKDF2_H_INCLUDED */
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index c9f4698..783c9f5 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -29,6 +29,7 @@
 /meta-armor-test
 /meta-cipher-test
 /meta-hash-test
+/pbkdf2-test
 /pkcs1-test
 /random-prime-test
 /ripemd160-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 10c993f..d8f8f23 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -88,6 +88,9 @@ gcm-test$(EXEEXT): gcm-test.$(OBJEXT)
 hmac-test$(EXEEXT): hmac-test.$(OBJEXT)
 	$(LINK) hmac-test.$(OBJEXT) $(TEST_OBJS) -o hmac-test$(EXEEXT)
 
+pbkdf2-test$(EXEEXT): pbkdf2-test.$(OBJEXT)
+	$(LINK) pbkdf2-test.$(OBJEXT) $(TEST_OBJS) -o pbkdf2-test$(EXEEXT)
+
 meta-hash-test$(EXEEXT): meta-hash-test.$(OBJEXT)
 	$(LINK) meta-hash-test.$(OBJEXT) $(TEST_OBJS) -o meta-hash-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 206a76e..86f365a 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -25,7 +25,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c ctr-test.c gcm-test.c hmac-test.c \
 		    meta-hash-test.c meta-cipher-test.c meta-armor-test.c \
-		    buffer-test.c yarrow-test.c
+		    buffer-test.c yarrow-test.c pbkdf2-test.c
 
 TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
 		     rsa2sexp-test.c sexp2rsa-test.c \
diff --git a/testsuite/meta-hash-test.c b/testsuite/meta-hash-test.c
index d3dba64..cae93e6 100644
--- a/testsuite/meta-hash-test.c
+++ b/testsuite/meta-hash-test.c
@@ -1,4 +1,5 @@
 #include "testutils.h"
+#include "nettle-internal.h"
 #include "nettle-meta.h"
 
 const char* hashes[] = {
@@ -29,5 +30,7 @@ test_main(void)
   while (NULL != nettle_hashes[j])
     j++;
   ASSERT(j == count); /* we are not missing testing any hashes */
+  for (j = 0; NULL != nettle_hashes[j]; j++)
+    ASSERT(nettle_hashes[j]-&gt;context_size &lt;= NETTLE_MAX_HASH_CONTEXT_SIZE);
 }
   
diff --git a/testsuite/pbkdf2-test.c b/testsuite/pbkdf2-test.c
new file mode 100644
index 0000000..c659d61
--- /dev/null
+++ b/testsuite/pbkdf2-test.c
@@ -0,0 +1,49 @@
+#include "testutils.h"
+#include "pbkdf2.h"
+
+#define PBKDF2_HMAC_TEST(alg, plen, p, slen, s, c, dklen, expect) do {	\
+    dk[dklen] = 17;							\
+    pbkdf2_hmac (plen, p, slen, s, alg, c, dklen, dk);			\
+    ASSERT(MEMEQ (dklen, dk, expect-&gt;data));				\
+    ASSERT(dk[dklen] == 17);						\
+  } while (0)
+
+#define MAX_DKLEN 25
+
+void
+test_main (void)
+{
+  uint8_t dk[MAX_DKLEN + 1];
+
+  /* Test vectors for PBKDF2 from RFC 6070. */
+
+  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 8, "password", 4, "salt", 1, 20,
+		    SHEX("0c60c80f961f0e71f3a9b524af6012062fe037a6"));
+
+  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 8, "password", 4, "salt", 2, 20,
+		    SHEX("ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957"));
+
+  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 8, "password", 4, "salt", 4096, 20,
+		    SHEX("4b007901b765489abead49d926f721d065a429c1"));
+
+#if 0				/* too slow */
+  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 8, "password", 4, "salt", 16777216, 20,
+		    SHEX("eefe3d61cd4da4e4e9945b3d6ba2158c2634e984"));
+#endif
+
+  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 24, "passwordPASSWORDpassword",
+		    36, "saltSALTsaltSALTsaltSALTsaltSALTsalt", 4096, 25,
+		    SHEX("3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038"));
+
+  PBKDF2_HMAC_TEST (&amp;nettle_sha1, 9, "pass\0word", 5, "sa\0lt", 4096, 16,
+		    SHEX("56fa6aa75548099dcc37d7f03425e0c3"));
+
+  /* PBKDF2-HMAC-SHA-256 test vectors confirmed with another
+     implementation.  */
+
+  PBKDF2_HMAC_TEST (&amp;nettle_sha256, 6, "passwd", 4, "salt", 1, 16,
+		    SHEX("55ac046e56e3089fec1691c22544b605"));
+
+  PBKDF2_HMAC_TEST (&amp;nettle_sha256, 8, "Password", 4, "NaCl", 80000, 16,
+		    SHEX("4ddcd8f60b98be21830cee5ef22701f9"));
+}
-- 
1.7.9.5



</body></email><email><emailId>20120918081621</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-18 08:16:21-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Preparing an updated patch was easy, here it is and should apply to git
&gt; master.  This improves on a few minor issues compared to the old patch.

Looks solid to me.

I was at first considering if one could do it without the struct
nettle_hash abstraction, but since that is used for the hmac functions
(I think I tried without, and that turned out to be too inconvenient),
I think it makes sense to use it here as well.

  --- a/nettle-internal.h
  +++ b/nettle-internal.h
  @@ -48,6 +48,7 @@ do { if (size &gt; (sizeof(name) / sizeof(name[0]))) abort(); } while (0)
   #define NETTLE_MAX_BIGNUM_SIZE ((NETTLE_MAX_BIGNUM_BITS + 7)/8)
   #define NETTLE_MAX_HASH_BLOCK_SIZE 128
   #define NETTLE_MAX_HASH_DIGEST_SIZE 64
  +#define NETTLE_MAX_HASH_CONTEXT_SIZE 216
   #define NETTLE_MAX_SEXP_ASSOC 17
   #define NETTLE_MAX_CIPHER_BLOCK_SIZE 32

I'm a bit uncomfortable with that magic number. If sha512_ctx is the
largest one, writing sizeof(struct sha512_ctx) is clearer. Or one could
even go for sizeof(union { struct struct sha512_ctx sha512; struct
foo_ctx foo; ... }).

&gt; +Derive symmetric key from a password according to PKCS #5 PBKDF2.  The
&gt; +PRF is the HMAC familly with @var{hash} indicating the underlying hash

s/familly/family/

&gt; +void
&gt; +pbkdf2_hmac (unsigned Plen, const uint8_t * P,
&gt; +	     unsigned Slen, const uint8_t * S,
&gt; +	     const struct nettle_hash *hash,
&gt; +	     unsigned int c, unsigned dkLen, uint8_t * DK)
&gt; +{
&gt; +  unsigned int hLen = hash-&gt;digest_size;
&gt; +  char U[NETTLE_MAX_HASH_DIGEST_SIZE];
&gt; +  char T[NETTLE_MAX_HASH_DIGEST_SIZE];
[...]
&gt; +  TMP_DECL (inner, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt; +  TMP_DECL (outer, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt; +  TMP_DECL (state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);

Any good reason to allocate the digests and the contexts in different
ways? (One issue with the current hash and hmac interfaces is that all
three of inner, outer and state include a buffer, while we really need
only one).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120918091828</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-18 09:18:28-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; Preparing an updated patch was easy, here it is and should apply to git
&gt;&gt; master.  This improves on a few minor issues compared to the old patch.
&gt;
&gt; Looks solid to me.
&gt;
&gt; I was at first considering if one could do it without the struct
&gt; nettle_hash abstraction, but since that is used for the hmac functions
&gt; (I think I tried without, and that turned out to be too inconvenient),
&gt; I think it makes sense to use it here as well.

Yes, this was the trickiest part to resolve when I implemented it.
However, it mimics the hmac interface, so at least there is some
consistency.

&gt;   --- a/nettle-internal.h
&gt;   +++ b/nettle-internal.h
&gt;   @@ -48,6 +48,7 @@ do { if (size &gt; (sizeof(name) / sizeof(name[0]))) abort(); } while (0)
&gt;    #define NETTLE_MAX_BIGNUM_SIZE ((NETTLE_MAX_BIGNUM_BITS + 7)/8)
&gt;    #define NETTLE_MAX_HASH_BLOCK_SIZE 128
&gt;    #define NETTLE_MAX_HASH_DIGEST_SIZE 64
&gt;   +#define NETTLE_MAX_HASH_CONTEXT_SIZE 216
&gt;    #define NETTLE_MAX_SEXP_ASSOC 17
&gt;    #define NETTLE_MAX_CIPHER_BLOCK_SIZE 32
&gt;
&gt; I'm a bit uncomfortable with that magic number. If sha512_ctx is the
&gt; largest one, writing sizeof(struct sha512_ctx) is clearer. Or one could
&gt; even go for sizeof(union { struct struct sha512_ctx sha512; struct
&gt; foo_ctx foo; ... }).

Did you notice that testsuite/meta-hash-test.c was modified as well to
make sure the magic number is OK?  A sizeof or sizeof-union could work
too, but then nettle-internal.h would need more #include's.

&gt;&gt; +Derive symmetric key from a password according to PKCS #5 PBKDF2.  The
&gt;&gt; +PRF is the HMAC familly with @var{hash} indicating the underlying hash
&gt;
&gt; s/familly/family/

Right.

&gt;&gt; +void
&gt;&gt; +pbkdf2_hmac (unsigned Plen, const uint8_t * P,
&gt;&gt; +	     unsigned Slen, const uint8_t * S,
&gt;&gt; +	     const struct nettle_hash *hash,
&gt;&gt; +	     unsigned int c, unsigned dkLen, uint8_t * DK)
&gt;&gt; +{
&gt;&gt; +  unsigned int hLen = hash-&gt;digest_size;
&gt;&gt; +  char U[NETTLE_MAX_HASH_DIGEST_SIZE];
&gt;&gt; +  char T[NETTLE_MAX_HASH_DIGEST_SIZE];
&gt; [...]
&gt;&gt; +  TMP_DECL (inner, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt;&gt; +  TMP_DECL (outer, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt;&gt; +  TMP_DECL (state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt;
&gt; Any good reason to allocate the digests and the contexts in different
&gt; ways? (One issue with the current hash and hmac interfaces is that all
&gt; three of inner, outer and state include a buffer, while we really need
&gt; only one).

Ah, no reason really.  I wrote the inner/outer/state part later, after
settling on the nettle_hash abstraction, so this was code inspired by
hmac.c.  I found the hmac interface a bit odd here, so there may be
better ways to do this.

/Simon

</body></email><email><emailId>20120918102818</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-18 10:28:18-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Did you notice that testsuite/meta-hash-test.c was modified as well to
&gt; make sure the magic number is OK?

Yes, that's good, but I'd still prefer to have it defined in terms of sizeof.

&gt; A sizeof or sizeof-union could work
&gt; too, but then nettle-internal.h would need more #include's.

Since it's for internal use only, I don't think that's a problem. And
including sha.h should be sufficient I guess? (I still haven't checked,
but I would think sha512_ctx is the largest one).

&gt;&gt;&gt; +  TMP_DECL (inner, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt;&gt;&gt; +  TMP_DECL (outer, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt;&gt;&gt; +  TMP_DECL (state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);

[...]

&gt; Ah, no reason really.  I wrote the inner/outer/state part later, after
&gt; settling on the nettle_hash abstraction, so this was code inspired by
&gt; hmac.c.  I found the hmac interface a bit odd here, so there may be
&gt; better ways to do this.

Hmm. I don't think using TMP_DECL like that is right. If HAVE_ALLOCA,
then it's going to be a plain alloca, which is what we really want. The
problem is the fallback case, when we don't use allloca. Then it expands
to

  uint8_t inner[NETTLE_MAX_HASH_CONTEXT_SIZE];

which may not be properly aligned.

We shouldn't use malloc here, so if we can't think up something
completely different, I think nettle-internal.h needs to define some
union type which makes the C compiler to provide sufficient space and
proper alignment. Somewhat like sockaddr_storage.

And the hmac code uses TMP_DECL/TMP_ALLOC for input blocks and digests,
not for the context structs.

(Maybe it should be designed differently? I'll send a separate reply on
that).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120918103313</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-18 10:33:13-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; +void
&gt; +pbkdf2_hmac (unsigned Plen, const uint8_t * P,
&gt; +	     unsigned Slen, const uint8_t * S,
&gt; +	     const struct nettle_hash *hash,
&gt; +	     unsigned int c, unsigned dkLen, uint8_t * DK);

Maybe it would make more sense for pbkdf2 to use an arbitrary mac? The
caller would provide the mac an dinitialize it with the password. And
then the pbkdf2 functions takes the mac, the salt, count, and generates
the key. Like

  void
  pbkdf2 (void *mac_ctx, unsigned digest_size,
          nettle_hash_update_func *update,
          nettle_hash_digest_func *digest,
          unsigned length, uint8_t *dst,
          unsigned iterations,
          unsigned salt_length, const uint8_t *salt);

Example usage:

  hmac_sha1_ctx ctx;
  uint8_t key[57];
  
  hmac_sha1_set_key (&amp;ctx, 8, "password");
  pbkdf2 (&amp;ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
    	  sizeof(key), key,
          4711, 6, "pepper");

Would that make sense? I guess one may also want some convenience
macros/functions for using hmac-sha1 etc.

I think that design would even make the implementation more natural.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120918103902</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-18 10:39:02-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

And a couple of comments on the implementation.

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; +  for (i = 1; i &lt;= l; i++)
&gt; +    {
&gt; +      memset (T, 0, hLen);
&gt; +
&gt; +      for (u = 1; u &lt;= c; u++)
&gt; +	{
&gt; +	  hmac_set_key (outer, inner, state, hash, Plen, P);
&gt; +
&gt; +	  if (u == 1)
&gt; +	    {
&gt; +	      tmp[0] = (i &amp; 0xff000000) &gt;&gt; 24;
&gt; +	      tmp[1] = (i &amp; 0x00ff0000) &gt;&gt; 16;
&gt; +	      tmp[2] = (i &amp; 0x0000ff00) &gt;&gt; 8;
&gt; +	      tmp[3] = (i &amp; 0x000000ff) &gt;&gt; 0;
&gt; +
&gt; +	      hmac_update (state, hash, Slen, S);
&gt; +	      hmac_update (state, hash, 4, tmp);
&gt; +	    }
&gt; +	  else
&gt; +	    {
&gt; +	      hmac_set_key (outer, inner, state, hash, Plen, P);
&gt; +	      hmac_update (state, hash, hLen, U);
&gt; +	    }
&gt; +
&gt; +	  hmac_digest (outer, inner, state, hash, hLen, U);

There's no need for all those hmac_set_key. You can set it once, and
compute several macs usign the same key, each with a sequence of update,
update, ..., update, digest.

If documentation or implementation doesn't agree, patches are appreciated.

&gt; +	  for (k = 0; k &lt; hLen; k++)
&gt; +	    T[k] ^= U[k];
&gt; +	}

And that's what memxor is for ;-)

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120918104732</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-18 10:47:32-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; +void
&gt;&gt; +pbkdf2_hmac (unsigned Plen, const uint8_t * P,
&gt;&gt; +	     unsigned Slen, const uint8_t * S,
&gt;&gt; +	     const struct nettle_hash *hash,
&gt;&gt; +	     unsigned int c, unsigned dkLen, uint8_t * DK);
&gt;
&gt; Maybe it would make more sense for pbkdf2 to use an arbitrary mac?

Yes, PBKDF2 is actually defined to apply to any PRF generally.

&gt; The caller would provide the mac an dinitialize it with the
&gt; password. And then the pbkdf2 functions takes the mac, the salt,
&gt; count, and generates the key. Like
&gt;
&gt;   void
&gt;   pbkdf2 (void *mac_ctx, unsigned digest_size,
&gt;           nettle_hash_update_func *update,
&gt;           nettle_hash_digest_func *digest,
&gt;           unsigned length, uint8_t *dst,
&gt;           unsigned iterations,
&gt;           unsigned salt_length, const uint8_t *salt);

This feels a bit inconsistent with the hmac interface, but it is
slightly more general.  In practice, I'm not aware of anyone using
PBKDF2 with anything non-HMAC though.

&gt; Example usage:
&gt;
&gt;   hmac_sha1_ctx ctx;
&gt;   uint8_t key[57];
&gt;   
&gt;   hmac_sha1_set_key (&amp;ctx, 8, "password");
&gt;   pbkdf2 (&amp;ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
&gt;     	  sizeof(key), key,
&gt;           4711, 6, "pepper");
&gt;
&gt; Would that make sense? I guess one may also want some convenience
&gt; macros/functions for using hmac-sha1 etc.

I suppose this would work. PBKDF2 invokes the PRF many times with
different inputs (however always with the same key).  It seems
hmac_sha1_digest reset the context for new use.

Do you want me to submit an updated patch?

/Simon

</body></email><email><emailId>20120918104954</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-18 10:49:54-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; Did you notice that testsuite/meta-hash-test.c was modified as well to
&gt;&gt; make sure the magic number is OK?
&gt;
&gt; Yes, that's good, but I'd still prefer to have it defined in terms of sizeof.
&gt;
&gt;&gt; A sizeof or sizeof-union could work
&gt;&gt; too, but then nettle-internal.h would need more #include's.
&gt;
&gt; Since it's for internal use only, I don't think that's a problem. And
&gt; including sha.h should be sufficient I guess? (I still haven't checked,
&gt; but I would think sha512_ctx is the largest one).

The sizes are:

md2: 84
md4: 92
md5: 92
ripemd160: 96
sha1: 96
sha224: 108
sha256: 108
sha384: 216
sha512: 216

Do you want me to use this approach in any updated patch?

&gt;&gt;&gt;&gt; +  TMP_DECL (inner, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt;&gt;&gt;&gt; +  TMP_DECL (outer, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt;&gt;&gt;&gt; +  TMP_DECL (state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt;
&gt; [...]
&gt;
&gt;&gt; Ah, no reason really.  I wrote the inner/outer/state part later, after
&gt;&gt; settling on the nettle_hash abstraction, so this was code inspired by
&gt;&gt; hmac.c.  I found the hmac interface a bit odd here, so there may be
&gt;&gt; better ways to do this.
&gt;
&gt; Hmm. I don't think using TMP_DECL like that is right. If HAVE_ALLOCA,
&gt; then it's going to be a plain alloca, which is what we really want. The
&gt; problem is the fallback case, when we don't use allloca. Then it expands
&gt; to
&gt;
&gt;   uint8_t inner[NETTLE_MAX_HASH_CONTEXT_SIZE];
&gt;
&gt; which may not be properly aligned.
&gt;
&gt; We shouldn't use malloc here, so if we can't think up something
&gt; completely different, I think nettle-internal.h needs to define some
&gt; union type which makes the C compiler to provide sufficient space and
&gt; proper alignment. Somewhat like sockaddr_storage.
&gt;
&gt; And the hmac code uses TMP_DECL/TMP_ALLOC for input blocks and digests,
&gt; not for the context structs.
&gt;
&gt; (Maybe it should be designed differently? I'll send a separate reply on
&gt; that).

I'm hoping this issue goes away with your new proposed interface, I
think it does.

/Simon

</body></email><email><emailId>20120918110628</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-18 11:06:28-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; This feels a bit inconsistent with the hmac interface,

Anything in particular which you think is inconsistent?

HMAC is a bit special both in theory and practice. In that it isn't
defined on top of any arbitrary hash function, it's defined only for
hash functions in the Merkle-Damgård family (if I get the terminology
right), and needs to know the underlying blocksize, which is usually
considered an internal property of the hash function.

And then nettle's hmac_update and hmac_digest are a bit peculiar, since
they avoid using types from HMAC_CTX, and use const for the two contexts
which depend on the key only.

PBDKF2 is a more regular construction, which doesn't depend on the
internals of the underlying mac/prf.

&gt; Do you want me to submit an updated patch?

It would be great if you could try out the proposed interface. And if it
works out well, submit a new patch.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120918210017</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-18 21:00:17-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt; 
&gt; &gt; This feels a bit inconsistent with the hmac interface,
&gt; 
&gt; Anything in particular which you think is inconsistent?

That the HMAC interface takes this parameter:

   const struct nettle_hash *hash

but the new PBKDF2 interface would take these:

   void *mac_ctx,
   unsigned digest_size,
   nettle_hash_update_func *update,
   nettle_hash_digest_func *digest

which feels low-level, especially considering that those parameters are
captured through the nettle_hash abstraction together with hard-coding
PBKDF2 for HMAC.

However, I suppose this complexity could be hidden with a utility
function 'pbkdf2_hmac' that is similar to my original function
signature.  I believe HMAC-based PBKDF2's are important enough to
warrant a utility function for easy use.  Then the flexibility is there
in Nettle if someone wants to use PBKDF2 for non-HMACs in the future.

&gt; &gt; Do you want me to submit an updated patch?
&gt; 
&gt; It would be great if you could try out the proposed interface. And if it
&gt; works out well, submit a new patch.

See patch below (only pbkdf2.h, pbkdf2.c, and testsuite/pbkdf2-test.c
update, the rest of the patch is not updated).  It works, however I get
warnings because there is a type conflict:

pbkdf2-test.c:27:3: warning: passing argument 3 of 'nettle_pbkdf2' from incompatible \
                pointer type [enabled by default]
../pbkdf2.h:40:1: note: expected 'void (*)(void *, unsigned int,  const uint8_t *)' \
but argument is of type 'void (*)(struct hmac_sha1_ctx *, unsigned int,  const \
uint8_t *)'

The reason is that pbkdf2 has this signature:

void
pbkdf2 (void *mac_ctx, unsigned digest_size,
	nettle_hash_update_func *update,
	nettle_hash_digest_func *digest,
	unsigned length, uint8_t *dst,
	unsigned iterations,
	unsigned salt_length, const uint8_t *salt)

and nettle_hash_update_func looks like this:

typedef void nettle_hash_update_func(void *ctx,
				     unsigned length,
				     const uint8_t *src);

which is not compatible with any instantiation like this one:

void
sha1_update(struct sha1_ctx *ctx,
	    unsigned length,
	    const uint8_t *data);

Casting the parameter would solve this.  Is there any other way to
resolve the warning?  Do you think casting is an acceptable solution
here?  The problem seems to be that the casting needs to happen in the
application not in the library.

/Simon


["0001-Add-support-for-PKCS-5-PBKDF2.patch" (text/x-diff)]

&gt; From 21cc37f8fd8cdd2dbd5674a14fe2c2fe7acd6ac9 Mon Sep 17 00:00:00 2001
From: Simon Josefsson &lt;simon@josefsson.org&gt;
Date: Tue, 18 Sep 2012 09:44:08 +0200
Subject: [PATCH] Add support for PKCS#5 PBKDF2.

---
 ChangeLog                  |   14 +++++++
 Makefile.in                |    2 +
 NEWS                       |    6 +++
 nettle-internal.h          |    1 +
 nettle.texinfo             |   42 +++++++++++++++++++-
 pbkdf2.c                   |   92 ++++++++++++++++++++++++++++++++++++++++++++
 pbkdf2.h                   |   51 ++++++++++++++++++++++++
 testsuite/.gitignore       |    1 +
 testsuite/.test-rules.make |    3 ++
 testsuite/Makefile.in      |    2 +-
 testsuite/meta-hash-test.c |    3 ++
 testsuite/pbkdf2-test.c    |   73 +++++++++++++++++++++++++++++++++++
 12 files changed, 287 insertions(+), 3 deletions(-)
 create mode 100644 pbkdf2.c
 create mode 100644 pbkdf2.h
 create mode 100644 testsuite/pbkdf2-test.c

diff --git a/ChangeLog b/ChangeLog
index f2a2010..cc3f661 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,17 @@
+2012-09-12  Simon Josefsson  &lt;simon@josefsson.org&gt;
+
+	* NEWS: Mention addition of PBKDF2.
+	* pbkdf2.c (pbkdf2_hmac): New file and function.
+	* pbkdf2.h: Declare it.
+	* Makefile.in (nettle_SOURCES): Add pbkdf2.c.
+	(HEADERS): Add pbkdf2.h.
+	* nettle-internal.h (NETTLE_MAX_HASH_CONTEXT_SIZE): New constant.
+	* nettle.texinfo (Key derivation functions): New section.
+	* testsuite/pbkdf2-test.c: New test case.
+	* testsuite/meta-hash-test.c (test_main): Validate NETTLE_MAX_HASH_CONTEXT_SIZE.
+	* testsuite/Makefile.in (TS_NETTLE_SOURCES): Add pbkdf2-test.c.
+	* testsuite/.test-rules.make (pbkdf2-test): New target.
+
 2012-09-16  Niels Möller  &lt;nisse@lysator.liu.se&gt;
 
 	* testsuite/: Overhaul of testsuite, affecting almost all files.
diff --git a/Makefile.in b/Makefile.in
index cf93593..7c6cf33 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -77,6 +77,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 des3.c des-compat.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
+		 pbkdf2.c \
 		 knuth-lfib.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
@@ -123,6 +124,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h bignum.h blowfish.h \
 	  cbc.h ctr.h gcm.h \
 	  des.h des-compat.h dsa.h \
 	  hmac.h \
+	  pbkdf2.h \
 	  knuth-lfib.h \
 	  macros.h \
 	  md2.h md4.h \
diff --git a/NEWS b/NEWS
index 4957f80..ea846a7 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,9 @@
+
+	New features:
+
+	* Support for PKCS #5 PBKDF2.  Contributed by Simon Josefsson.
+          Specification in RFC 2898 and test vectors in RFC 6070.
+
 NEWS for the 2.5 release
 
 	This release includes important portability fixes for Windows
diff --git a/nettle-internal.h b/nettle-internal.h
index e85e3c5..510909b 100644
--- a/nettle-internal.h
+++ b/nettle-internal.h
@@ -48,6 +48,7 @@ do { if (size &gt; (sizeof(name) / sizeof(name[0]))) abort(); } while \
(0)  #define NETTLE_MAX_BIGNUM_SIZE ((NETTLE_MAX_BIGNUM_BITS + 7)/8)
 #define NETTLE_MAX_HASH_BLOCK_SIZE 128
 #define NETTLE_MAX_HASH_DIGEST_SIZE 64
+#define NETTLE_MAX_HASH_CONTEXT_SIZE 216
 #define NETTLE_MAX_SEXP_ASSOC 17
 #define NETTLE_MAX_CIPHER_BLOCK_SIZE 32
 
diff --git a/nettle.texinfo b/nettle.texinfo
index 4904d91..a8fd233 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -70,6 +70,7 @@ Reference
 * Cipher functions::            
 * Cipher modes::                
 * Keyed hash functions::        
+* Key derivation functions::    
 * Public-key algorithms::       
 * Randomness::                  
 * Ascii encoding::              
@@ -199,6 +200,10 @@ implementation (in the public domain), adapted to Nettle by \
Simon  Josefsson, and heavily modified by Niels Möller. Assembly for x86_64 by
 Niels Möller. Released under the LGPL.
 
+@item PBKDF2
+The C implementation of PBKDF2 is based on earlier work for Shishi and
+GnuTLS by Simon Josefsson.  Released under the LGPL.
+
 @item SERPENT
 The implementation of the SERPENT cipher is based on the code in libgcrypt,
 copyright owned by the Free Software Foundation. Adapted to Nettle by
@@ -316,6 +321,7 @@ This chapter describes all the Nettle functions, grouped by \
                family.
 * Cipher functions::            
 * Cipher modes::                
 * Keyed hash functions::        
+* Key derivation functions::    
 * Public-key algorithms::       
 * Randomness::                  
 * Ascii encoding::              
@@ -1852,7 +1858,7 @@ only the first @var{length} octets of the digest are written.
 
 
 
-@node Keyed hash functions, Public-key algorithms, Cipher modes, Reference
+@node Keyed hash functions, Key derivation functions, Cipher modes, Reference
 @comment  node-name,  next,  previous,  up
 @section Keyed Hash Functions
 
@@ -2102,7 +2108,39 @@ This function also resets the context for processing new \
messages, with  the same key.
 @end deftypefun
 
-@node Public-key algorithms, Randomness, Keyed hash functions, Reference
+@node Key derivation functions, Public-key algorithms, Keyed hash functions, \
Reference +@comment  node-name,  next,  previous,  up
+@section Key derivation Functions
+
+@cindex Key Derivation Function
+@cindex Password Based Key Derivation Function
+@cindex PKCS #5
+@cindex KDF
+@cindex PBKDF
+
+A @dfn{key derivation function} (@acronym{KDF}) is a function that from
+a given symmetric key derives other symmetric keys.  A sub-class of KDFs
+is the @dfn{password-based key derivation functions} (@acronym{PBKDFs}),
+which take as input a password or passphrase, and its purpose is
+typically to strengthen it and protect against certain pre-computation
+attacks by using salting and expensive computation.  The most well known
+PBKDF is the @code{PKCS #5 PBKDF2} described in @cite{RFC 2898} which
+uses a pseudorandom function such as @acronym{HMAC-SHA1}.
+
+Nettle's @acronym{PBKDF2} function is defined in @file{&lt;nettle/pbkdf2.h&gt;}.
+It contains a function:
+
+@deftypefun void pbkdf2_hmac (unsigned @var{Plen}, const uint8_t *@var{P}, unsigned \
@var{Slen}, const uint8_t *@var{S}, const struct nettle_hash *@var{hash}, unsigned \
int @var{c}, unsigned @var{dkLen}, uint8_t *@var{DK}) +
+Derive symmetric key from a password according to PKCS #5 PBKDF2.  The
+PRF is the HMAC familly with @var{hash} indicating the underlying hash
+function.  Inputs are the password @var{P} of length @var{Plen}, the
+salt @var{S} of length @var{Slen}, the iteration counter @var{C} (&gt; 0),
+and the desired derived output length @var{dkLen}.  The output buffer is
+@var{DK} which must have room for at least @var{dkLen} octets.
+@end deftypefun
+
+@node Public-key algorithms, Randomness, Key derivation functions, Reference
 @comment  node-name,  next,  previous,  up
 @section Public-key algorithms
 
diff --git a/pbkdf2.c b/pbkdf2.c
new file mode 100644
index 0000000..929d66f
--- /dev/null
+++ b/pbkdf2.c
@@ -0,0 +1,92 @@
+/* pbkdf2.c
+ *
+ * PKCS #5 password-based key derivation function PBKDF2, see RFC 2898.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "pbkdf2.h"
+
+#include "memxor.h"
+#include "nettle-internal.h"
+
+void
+pbkdf2 (void *mac_ctx, unsigned digest_size,
+	nettle_hash_update_func *update,
+	nettle_hash_digest_func *digest,
+	unsigned length, uint8_t *dst,
+	unsigned iterations,
+	unsigned salt_length, const uint8_t *salt)
+{
+  char U[NETTLE_MAX_HASH_DIGEST_SIZE];
+  char T[NETTLE_MAX_HASH_DIGEST_SIZE];
+  unsigned int u;
+  unsigned int l;
+  unsigned int r;
+  unsigned int i;
+  char tmp[4];
+
+  if (iterations == 0)
+    return;
+
+  if (length == 0)
+    return;
+
+  l = ((length - 1) / digest_size) + 1;
+  r = length - (l - 1) * digest_size;
+
+  for (i = 1; i &lt;= l; i++)
+    {
+      memset (T, 0, digest_size);
+
+      for (u = 1; u &lt;= iterations; u++)
+	{
+	  if (u == 1)
+	    {
+	      tmp[0] = (i &amp; 0xff000000) &gt;&gt; 24;
+	      tmp[1] = (i &amp; 0x00ff0000) &gt;&gt; 16;
+	      tmp[2] = (i &amp; 0x0000ff00) &gt;&gt; 8;
+	      tmp[3] = (i &amp; 0x000000ff) &gt;&gt; 0;
+
+	      update (mac_ctx, salt_length, salt);
+	      update (mac_ctx, 4, tmp);
+	    }
+	  else
+	    {
+	      update (mac_ctx, digest_size, U);
+	    }
+
+	  digest (mac_ctx, digest_size, U);
+
+	  memxor (T, U, digest_size);
+	}
+
+      memcpy (dst + (i - 1) * digest_size, T, i == l ? r : digest_size);
+    }
+}
diff --git a/pbkdf2.h b/pbkdf2.h
new file mode 100644
index 0000000..8e3e4ca
--- /dev/null
+++ b/pbkdf2.h
@@ -0,0 +1,51 @@
+/* pbkdf2.c
+ *
+ * PKCS #5 password-based key derivation function PBKDF2, see RFC 2898.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#ifndef NETTLE_PBKDF2_H_INCLUDED
+#define NETTLE_PBKDF2_H_INCLUDED
+
+#include "nettle-meta.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* Namespace mangling */
+#define pbkdf2 nettle_pbkdf2
+
+void
+pbkdf2 (void *mac_ctx, unsigned digest_size,
+	nettle_hash_update_func *update,
+	nettle_hash_digest_func *digest,
+	unsigned length, uint8_t *dst,
+	unsigned iterations,
+	unsigned salt_length, const uint8_t *salt);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_PBKDF2_H_INCLUDED */
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index c9f4698..783c9f5 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -29,6 +29,7 @@
 /meta-armor-test
 /meta-cipher-test
 /meta-hash-test
+/pbkdf2-test
 /pkcs1-test
 /random-prime-test
 /ripemd160-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 10c993f..d8f8f23 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -88,6 +88,9 @@ gcm-test$(EXEEXT): gcm-test.$(OBJEXT)
 hmac-test$(EXEEXT): hmac-test.$(OBJEXT)
 	$(LINK) hmac-test.$(OBJEXT) $(TEST_OBJS) -o hmac-test$(EXEEXT)
 
+pbkdf2-test$(EXEEXT): pbkdf2-test.$(OBJEXT)
+	$(LINK) pbkdf2-test.$(OBJEXT) $(TEST_OBJS) -o pbkdf2-test$(EXEEXT)
+
 meta-hash-test$(EXEEXT): meta-hash-test.$(OBJEXT)
 	$(LINK) meta-hash-test.$(OBJEXT) $(TEST_OBJS) -o meta-hash-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 206a76e..86f365a 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -25,7 +25,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c ctr-test.c gcm-test.c hmac-test.c \
 		    meta-hash-test.c meta-cipher-test.c meta-armor-test.c \
-		    buffer-test.c yarrow-test.c
+		    buffer-test.c yarrow-test.c pbkdf2-test.c
 
 TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
 		     rsa2sexp-test.c sexp2rsa-test.c \
diff --git a/testsuite/meta-hash-test.c b/testsuite/meta-hash-test.c
index d3dba64..cae93e6 100644
--- a/testsuite/meta-hash-test.c
+++ b/testsuite/meta-hash-test.c
@@ -1,4 +1,5 @@
 #include "testutils.h"
+#include "nettle-internal.h"
 #include "nettle-meta.h"
 
 const char* hashes[] = {
@@ -29,5 +30,7 @@ test_main(void)
   while (NULL != nettle_hashes[j])
     j++;
   ASSERT(j == count); /* we are not missing testing any hashes */
+  for (j = 0; NULL != nettle_hashes[j]; j++)
+    ASSERT(nettle_hashes[j]-&gt;context_size &lt;= NETTLE_MAX_HASH_CONTEXT_SIZE);
 }
   
diff --git a/testsuite/pbkdf2-test.c b/testsuite/pbkdf2-test.c
new file mode 100644
index 0000000..5062701
--- /dev/null
+++ b/testsuite/pbkdf2-test.c
@@ -0,0 +1,73 @@
+#include "testutils.h"
+#include "hmac.h"
+#include "sha.h"
+#include "pbkdf2.h"
+
+#define PBKDF2_TEST(ctx, size, update, digest, slen, s, c, expect)	\
+  do {									\
+    dk[expect-&gt;length] = 17;						\
+    pbkdf2 (ctx, size, update, digest, expect-&gt;length, dk, c, slen, s);	\
+    ASSERT(MEMEQ (expect-&gt;length, dk, expect-&gt;data));			\
+    ASSERT(dk[expect-&gt;length] == 17);					\
+  } while (0)
+
+#define MAX_DKLEN 25
+
+void
+test_main (void)
+{
+  uint8_t dk[MAX_DKLEN + 1];
+  struct hmac_sha1_ctx sha1ctx;
+  struct hmac_sha256_ctx sha256ctx;
+
+  /* Test vectors for PBKDF2 from RFC 6070. */
+
+  hmac_sha1_set_key (&amp;sha1ctx, 8, "password");
+
+  PBKDF2_TEST(&amp;sha1ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
+	      4, "salt", 1,
+	      SHEX("0c60c80f961f0e71f3a9b524af6012062fe037a6"));
+
+  PBKDF2_TEST (&amp;sha1ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
+	       4, "salt", 2,
+	       SHEX("ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957"));
+
+  PBKDF2_TEST (&amp;sha1ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
+	       4, "salt", 4096,
+	       SHEX("4b007901b765489abead49d926f721d065a429c1"));
+
+#if 0				/* too slow */
+  PBKDF2_TEST (&amp;sha1ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
+	       4, "salt", 16777216,
+	       SHEX("eefe3d61cd4da4e4e9945b3d6ba2158c2634e984"));
+#endif
+
+  hmac_sha1_set_key (&amp;sha1ctx, 24, "passwordPASSWORDpassword");
+
+  PBKDF2_TEST (&amp;sha1ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
+	       36, "saltSALTsaltSALTsaltSALTsaltSALTsalt", 4096,
+	       SHEX("3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038"));
+
+  hmac_sha1_set_key (&amp;sha1ctx, 9, "pass\0word");
+
+  PBKDF2_TEST (&amp;sha1ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
+	       5, "sa\0lt", 4096,
+	       SHEX("56fa6aa75548099dcc37d7f03425e0c3"));
+
+  /* PBKDF2-HMAC-SHA-256 test vectors confirmed with another
+     implementation.  */
+
+  hmac_sha256_set_key (&amp;sha256ctx, 6, "passwd");
+
+  PBKDF2_TEST (&amp;sha256ctx, SHA256_DIGEST_SIZE,
+	       hmac_sha256_update, hmac_sha256_digest,
+	       4, "salt", 1,
+	       SHEX("55ac046e56e3089fec1691c22544b605"));
+
+  hmac_sha256_set_key (&amp;sha256ctx, 8, "Password");
+
+  PBKDF2_TEST (&amp;sha256ctx, SHA256_DIGEST_SIZE,
+	       hmac_sha256_update, hmac_sha256_digest,
+	       4, "NaCl", 80000,
+	       SHEX("4ddcd8f60b98be21830cee5ef22701f9"));
+}
-- 
1.7.9.5



</body></email><email><emailId>20120919130434</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-19 13:04:34-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; nisse@lysator.liu.se (Niels Möller) writes:

&gt; That the HMAC interface takes this parameter:
&gt; 
&gt; const struct nettle_hash *hash
&gt; 
&gt; but the new PBKDF2 interface would take these:
&gt; 
&gt; void *mac_ctx,
&gt; unsigned digest_size,
&gt; nettle_hash_update_func *update,
&gt; nettle_hash_digest_func *digest
&gt; 
&gt; which feels low-level, especially considering that those parameters are
&gt; captured through the nettle_hash abstraction together with hard-coding
&gt; PBKDF2 for HMAC.

The "low-level" interface is the preferred style in Nettle. See
cbc_encrypt/cbc_decrypt for other examples. It's intended that the
nettle_hash abstraction should be optional, and not used internally. But
then it's used with hmac anyway, iirc that's because the alternative
interface got *too* clumsy.

&gt; However, I suppose this complexity could be hidden with a utility
&gt; function 'pbkdf2_hmac' that is similar to my original function
&gt; signature.

Do you think a "half-general" pbkdf2_hmac function really is useful? I
think specific wrapper functions, pbkdf2_hmac_sha256, etc, would be more
useful.

&gt; pbkdf2-test.c:27:3: warning: passing argument 3 of 'nettle_pbkdf2' from \
&gt;                 incompatible pointer type [enabled by default]
&gt; ../pbkdf2.h:40:1: note: expected 'void (*)(void *, unsigned int,  const uint8_t *)' \
&gt; but argument is of type 'void (*)(struct hmac_sha1_ctx *, unsigned int,  const \
&gt; uint8_t *)' 
&gt; The reason is that pbkdf2 has this signature:
&gt; typedef void nettle_hash_update_func(void *ctx,
&gt; 				     unsigned length,
&gt; 				     const uint8_t *src);
&gt; 
&gt; which is not compatible with any instantiation like this one:
&gt; 
&gt; void
&gt; sha1_update(struct sha1_ctx *ctx,
&gt; 	    unsigned length,
&gt; 	    const uint8_t *data);

This is a problem shared with almost every function in nettle accepting
function pointer arguments. I think we have to live with casts one way
or the other; I don't see any good solution.

&gt; Casting the parameter would solve this.  Is there any other way to
&gt; resolve the warning?  Do you think casting is an acceptable solution
&gt; here?  The problem seems to be that the casting needs to happen in the
&gt; application not in the library.

At least specific functions like pbkdf2_hmac_sha256 functions will not
expose the problem to users. It's also possible to write some macros to
do the cast but preserve some type checking, something like

#define PBKDF2(ctx, update, digest, ...) \
 (0 ? (update(ctx, 0, NULL), digest(ctx, 0, NULL)) \
    : pbkdf(ctx, (nettle_hash_update_func *) update, (nettle_hash_digest_func *) \
digest, ..,))  
The CBC_ENCRYPT and CBC_DECRYPT macros do this, and it seems to work
fine, but it's not particularly pretty.

Any other ideas?

Thanks for the implementation, I'll try to get it integrated soon. Some
minor comments (which I can fix):

&gt; --- a/nettle-internal.h
&gt; +++ b/nettle-internal.h
&gt; @@ -48,6 +48,7 @@ do { if (size &gt; (sizeof(name) / sizeof(name[0]))) abort(); } \
&gt; while (0) #define NETTLE_MAX_BIGNUM_SIZE ((NETTLE_MAX_BIGNUM_BITS + 7)/8)
&gt; #define NETTLE_MAX_HASH_BLOCK_SIZE 128
&gt; #define NETTLE_MAX_HASH_DIGEST_SIZE 64
&gt; +#define NETTLE_MAX_HASH_CONTEXT_SIZE 216
&gt; #define NETTLE_MAX_SEXP_ASSOC 17
&gt; #define NETTLE_MAX_CIPHER_BLOCK_SIZE 32

This is no longer needed, right?

&gt; +void
&gt; +pbkdf2 (void *mac_ctx, unsigned digest_size,
&gt; +	nettle_hash_update_func *update,
&gt; +	nettle_hash_digest_func *digest,
&gt; +	unsigned length, uint8_t *dst,
&gt; +	unsigned iterations,
&gt; +	unsigned salt_length, const uint8_t *salt)
&gt; +{
&gt; +  char U[NETTLE_MAX_HASH_DIGEST_SIZE];
&gt; +  char T[NETTLE_MAX_HASH_DIGEST_SIZE];

It would make sense to use TMP_ALLOC for those. And I think I'd use uint8_t
rather than char (unless there's some reason for char I'm missing?).

&gt; +	      tmp[0] = (i &amp; 0xff000000) &gt;&gt; 24;
&gt; +	      tmp[1] = (i &amp; 0x00ff0000) &gt;&gt; 16;
&gt; +	      tmp[2] = (i &amp; 0x0000ff00) &gt;&gt; 8;
&gt; +	      tmp[3] = (i &amp; 0x000000ff) &gt;&gt; 0;

There's WRITE_UINT32 for this.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120919132701</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-19 13:27:01-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt;&gt; However, I suppose this complexity could be hidden with a utility
&gt;&gt; function 'pbkdf2_hmac' that is similar to my original function
&gt;&gt; signature.
&gt;
&gt; Do you think a "half-general" pbkdf2_hmac function really is useful? I
&gt; think specific wrapper functions, pbkdf2_hmac_sha256, etc, would be more
&gt; useful.

I agree.  PBKDF2-HMAC-SHA1 is the most important.  If there is also
support for PBKDF2-HMAC-SHA256 then all usual cases are handled.  I
would actually hesistate to add convenience functions for the rest since
it may lead people to use them without thinking that there are costs in
using a new variant.  I feel even PBKDF2-HMAC-SHA256 is wasteful, there
is nothing cryptographically wrong with PBKDF2-HMAC-SHA1, but that is an
uphill battle to fight...

&gt; This is a problem shared with almost every function in nettle accepting
&gt; function pointer arguments. I think we have to live with casts one way
&gt; or the other; I don't see any good solution.

Aha.  I hadn't realized that.

&gt;&gt; Casting the parameter would solve this.  Is there any other way to
&gt;&gt; resolve the warning?  Do you think casting is an acceptable solution
&gt;&gt; here?  The problem seems to be that the casting needs to happen in the
&gt;&gt; application not in the library.
&gt;
&gt; At least specific functions like pbkdf2_hmac_sha256 functions will not
&gt; expose the problem to users. It's also possible to write some macros to
&gt; do the cast but preserve some type checking, something like
&gt;
&gt; #define PBKDF2(ctx, update, digest, ...) \
&gt;  (0 ? (update(ctx, 0, NULL), digest(ctx, 0, NULL)) \
&gt;     : pbkdf(ctx, (nettle_hash_update_func *) update, (nettle_hash_digest_func *) digest, ..,))
&gt;  
&gt; The CBC_ENCRYPT and CBC_DECRYPT macros do this, and it seems to work
&gt; fine, but it's not particularly pretty.
&gt;
&gt; Any other ideas?

This approach seems fine to me.

&gt; Thanks for the implementation, I'll try to get it integrated soon. Some
&gt; minor comments (which I can fix):

I can submit an updated patch if that would speed things up.  Recall
that the ChangeLog, manual etc was not updated for the new interface in
my most recent patch, so there is some cleaning up to do.

&gt;&gt; --- a/nettle-internal.h
&gt;&gt; +++ b/nettle-internal.h
&gt;&gt; @@ -48,6 +48,7 @@ do { if (size &gt; (sizeof(name) / sizeof(name[0])))
&gt;&gt; abort(); } while (0)
&gt;&gt;  #define NETTLE_MAX_BIGNUM_SIZE ((NETTLE_MAX_BIGNUM_BITS + 7)/8)
&gt;&gt;  #define NETTLE_MAX_HASH_BLOCK_SIZE 128
&gt;&gt;  #define NETTLE_MAX_HASH_DIGEST_SIZE 64
&gt;&gt; +#define NETTLE_MAX_HASH_CONTEXT_SIZE 216
&gt;&gt;  #define NETTLE_MAX_SEXP_ASSOC 17
&gt;&gt;  #define NETTLE_MAX_CIPHER_BLOCK_SIZE 32
&gt;
&gt; This is no longer needed, right?

Once the next issue is fixed, agreed.

&gt;&gt; +void
&gt;&gt; +pbkdf2 (void *mac_ctx, unsigned digest_size,
&gt;&gt; +	nettle_hash_update_func *update,
&gt;&gt; +	nettle_hash_digest_func *digest,
&gt;&gt; +	unsigned length, uint8_t *dst,
&gt;&gt; +	unsigned iterations,
&gt;&gt; +	unsigned salt_length, const uint8_t *salt)
&gt;&gt; +{
&gt;&gt; +  char U[NETTLE_MAX_HASH_DIGEST_SIZE];
&gt;&gt; +  char T[NETTLE_MAX_HASH_DIGEST_SIZE];
&gt;
&gt; It would make sense to use TMP_ALLOC for those. And I think I'd use uint8_t
&gt; rather than char (unless there's some reason for char I'm missing?).

Agreed.  It was copy'n'paste from my old implementation.

&gt;&gt; +	      tmp[0] = (i &amp; 0xff000000) &gt;&gt; 24;
&gt;&gt; +	      tmp[1] = (i &amp; 0x00ff0000) &gt;&gt; 16;
&gt;&gt; +	      tmp[2] = (i &amp; 0x0000ff00) &gt;&gt; 8;
&gt;&gt; +	      tmp[3] = (i &amp; 0x000000ff) &gt;&gt; 0;
&gt;
&gt; There's WRITE_UINT32 for this.

Great.  Same reason here.

/Simon

</body></email><email><emailId>20120919134731</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-19 13:47:31-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; I can submit an updated patch if that would speed things up.  Recall
&gt; that the ChangeLog, manual etc was not updated for the new interface in
&gt; my most recent patch, so there is some cleaning up to do.

If you can make an updated patch for manual and ChangeLog, that'd be
great. I'll take care of the code.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120919142706</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-19 14:27:06-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; I can submit an updated patch if that would speed things up.  Recall
&gt;&gt; that the ChangeLog, manual etc was not updated for the new interface in
&gt;&gt; my most recent patch, so there is some cleaning up to do.
&gt;
&gt; If you can make an updated patch for manual and ChangeLog, that'd be
&gt; great. I'll take care of the code.

Here it is.

Thanks,
/Simon

["0001-Add-support-for-PKCS-5-PBKDF2.patch" (text/x-diff)]

&gt; From f3d3ee482dd6b908b988d33a25ef1118d54b42db Mon Sep 17 00:00:00 2001
From: Simon Josefsson &lt;simon@josefsson.org&gt;
Date: Tue, 18 Sep 2012 09:44:08 +0200
Subject: [PATCH] Add support for PKCS#5 PBKDF2.

---
 ChangeLog                  |   12 ++++++
 Makefile.in                |    2 +
 NEWS                       |    6 +++
 nettle.texinfo             |   43 +++++++++++++++++++-
 pbkdf2.c                   |   95 ++++++++++++++++++++++++++++++++++++++++++++
 pbkdf2.h                   |   51 ++++++++++++++++++++++++
 testsuite/.gitignore       |    1 +
 testsuite/.test-rules.make |    3 ++
 testsuite/Makefile.in      |    2 +-
 testsuite/meta-hash-test.c |    1 +
 testsuite/pbkdf2-test.c    |   73 ++++++++++++++++++++++++++++++++++
 11 files changed, 286 insertions(+), 3 deletions(-)
 create mode 100644 pbkdf2.c
 create mode 100644 pbkdf2.h
 create mode 100644 testsuite/pbkdf2-test.c

diff --git a/ChangeLog b/ChangeLog
index f2a2010..fad906d 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,15 @@
+2012-09-12  Simon Josefsson  &lt;simon@josefsson.org&gt;
+
+	* NEWS: Mention addition of PBKDF2.
+	* pbkdf2.c (pbkdf2): New file and function.
+	* pbkdf2.h: Declare it.
+	* Makefile.in (nettle_SOURCES): Add pbkdf2.c.
+	(HEADERS): Add pbkdf2.h.
+	* nettle.texinfo (Key derivation functions): New section.
+	* testsuite/pbkdf2-test.c: New test case.
+	* testsuite/Makefile.in (TS_NETTLE_SOURCES): Add pbkdf2-test.c.
+	* testsuite/.test-rules.make (pbkdf2-test): New target.
+
 2012-09-16  Niels Möller  &lt;nisse@lysator.liu.se&gt;
 
 	* testsuite/: Overhaul of testsuite, affecting almost all files.
diff --git a/Makefile.in b/Makefile.in
index cf93593..7c6cf33 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -77,6 +77,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 des3.c des-compat.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
+		 pbkdf2.c \
 		 knuth-lfib.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
@@ -123,6 +124,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h bignum.h blowfish.h \
 	  cbc.h ctr.h gcm.h \
 	  des.h des-compat.h dsa.h \
 	  hmac.h \
+	  pbkdf2.h \
 	  knuth-lfib.h \
 	  macros.h \
 	  md2.h md4.h \
diff --git a/NEWS b/NEWS
index 4957f80..ea846a7 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,9 @@
+
+	New features:
+
+	* Support for PKCS #5 PBKDF2.  Contributed by Simon Josefsson.
+          Specification in RFC 2898 and test vectors in RFC 6070.
+
 NEWS for the 2.5 release
 
 	This release includes important portability fixes for Windows
diff --git a/nettle.texinfo b/nettle.texinfo
index 4904d91..39f3c68 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -70,6 +70,7 @@ Reference
 * Cipher functions::            
 * Cipher modes::                
 * Keyed hash functions::        
+* Key derivation functions::    
 * Public-key algorithms::       
 * Randomness::                  
 * Ascii encoding::              
@@ -199,6 +200,10 @@ implementation (in the public domain), adapted to Nettle by \
Simon  Josefsson, and heavily modified by Niels Möller. Assembly for x86_64 by
 Niels Möller. Released under the LGPL.
 
+@item PBKDF2
+The C implementation of PBKDF2 is based on earlier work for Shishi and
+GnuTLS by Simon Josefsson.  Released under the LGPL.
+
 @item SERPENT
 The implementation of the SERPENT cipher is based on the code in libgcrypt,
 copyright owned by the Free Software Foundation. Adapted to Nettle by
@@ -316,6 +321,7 @@ This chapter describes all the Nettle functions, grouped by \
                family.
 * Cipher functions::            
 * Cipher modes::                
 * Keyed hash functions::        
+* Key derivation functions::    
 * Public-key algorithms::       
 * Randomness::                  
 * Ascii encoding::              
@@ -1852,7 +1858,7 @@ only the first @var{length} octets of the digest are written.
 
 
 
-@node Keyed hash functions, Public-key algorithms, Cipher modes, Reference
+@node Keyed hash functions, Key derivation functions, Cipher modes, Reference
 @comment  node-name,  next,  previous,  up
 @section Keyed Hash Functions
 
@@ -2102,7 +2108,40 @@ This function also resets the context for processing new \
messages, with  the same key.
 @end deftypefun
 
-@node Public-key algorithms, Randomness, Keyed hash functions, Reference
+@node Key derivation functions, Public-key algorithms, Keyed hash functions, \
Reference +@comment  node-name,  next,  previous,  up
+@section Key derivation Functions
+
+@cindex Key Derivation Function
+@cindex Password Based Key Derivation Function
+@cindex PKCS #5
+@cindex KDF
+@cindex PBKDF
+
+A @dfn{key derivation function} (@acronym{KDF}) is a function that from
+a given symmetric key derives other symmetric keys.  A sub-class of KDFs
+is the @dfn{password-based key derivation functions} (@acronym{PBKDFs}),
+which take as input a password or passphrase, and its purpose is
+typically to strengthen it and protect against certain pre-computation
+attacks by using salting and expensive computation.  The most well known
+PBKDF is the @code{PKCS #5 PBKDF2} described in @cite{RFC 2898} which
+uses a pseudorandom function such as @acronym{HMAC-SHA1}.
+
+Nettle's @acronym{PBKDF2} function is defined in @file{&lt;nettle/pbkdf2.h&gt;}.
+It contains a function:
+
+@deftypefun void pbkdf2 (void *mac_ctx, unsigned digest_size, \
nettle_hash_update_func *update, nettle_hash_digest_func *digest, unsigned length, \
uint8_t *dst, unsigned iterations, unsigned salt_length, const uint8_t *salt) +Derive \
symmetric key from a password according to PKCS #5 PBKDF2.  The +PRF is assumed to \
have been initialized and this function will call the +@var{update} and @var{digest} \
functions passing the @var{mac_ctx} +context parameter as an argument in order to \
compute digest of size +@var{digest_size}.  Inputs are the salt @var{salt} of length
+@var{salt_length}, the iteration counter @var{iterations} (&gt; 0), and the
+desired derived output length @var{length}.  The output buffer is
+@var{dst} which must have room for at least @var{length} octets.
+@end deftypefun
+
+@node Public-key algorithms, Randomness, Key derivation functions, Reference
 @comment  node-name,  next,  previous,  up
 @section Public-key algorithms
 
diff --git a/pbkdf2.c b/pbkdf2.c
new file mode 100644
index 0000000..79bfa5b
--- /dev/null
+++ b/pbkdf2.c
@@ -0,0 +1,95 @@
+/* pbkdf2.c
+ *
+ * PKCS #5 password-based key derivation function PBKDF2, see RFC 2898.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "pbkdf2.h"
+
+#include "memxor.h"
+#include "nettle-internal.h"
+
+void
+pbkdf2 (void *mac_ctx, unsigned digest_size,
+	nettle_hash_update_func *update,
+	nettle_hash_digest_func *digest,
+	unsigned length, uint8_t *dst,
+	unsigned iterations,
+	unsigned salt_length, const uint8_t *salt)
+{
+  unsigned int u;
+  unsigned int l;
+  unsigned int r;
+  unsigned int i;
+  char tmp[4];
+  TMP_DECL(U, uint8_t, NETTLE_MAX_HASH_BLOCK_SIZE);
+  TMP_DECL(T, uint8_t, NETTLE_MAX_HASH_BLOCK_SIZE);
+
+  TMP_ALLOC(U, digest_size);
+  TMP_ALLOC(T, digest_size);
+
+  if (iterations == 0)
+    return;
+
+  if (length == 0)
+    return;
+
+  l = ((length - 1) / digest_size) + 1;
+  r = length - (l - 1) * digest_size;
+
+  for (i = 1; i &lt;= l; i++)
+    {
+      memset (T, 0, digest_size);
+
+      for (u = 1; u &lt;= iterations; u++)
+	{
+	  if (u == 1)
+	    {
+	      tmp[0] = (i &amp; 0xff000000) &gt;&gt; 24;
+	      tmp[1] = (i &amp; 0x00ff0000) &gt;&gt; 16;
+	      tmp[2] = (i &amp; 0x0000ff00) &gt;&gt; 8;
+	      tmp[3] = (i &amp; 0x000000ff) &gt;&gt; 0;
+
+	      update (mac_ctx, salt_length, salt);
+	      update (mac_ctx, 4, tmp);
+	    }
+	  else
+	    {
+	      update (mac_ctx, digest_size, U);
+	    }
+
+	  digest (mac_ctx, digest_size, U);
+
+	  memxor (T, U, digest_size);
+	}
+
+      memcpy (dst + (i - 1) * digest_size, T, i == l ? r : digest_size);
+    }
+}
diff --git a/pbkdf2.h b/pbkdf2.h
new file mode 100644
index 0000000..8e3e4ca
--- /dev/null
+++ b/pbkdf2.h
@@ -0,0 +1,51 @@
+/* pbkdf2.c
+ *
+ * PKCS #5 password-based key derivation function PBKDF2, see RFC 2898.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#ifndef NETTLE_PBKDF2_H_INCLUDED
+#define NETTLE_PBKDF2_H_INCLUDED
+
+#include "nettle-meta.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* Namespace mangling */
+#define pbkdf2 nettle_pbkdf2
+
+void
+pbkdf2 (void *mac_ctx, unsigned digest_size,
+	nettle_hash_update_func *update,
+	nettle_hash_digest_func *digest,
+	unsigned length, uint8_t *dst,
+	unsigned iterations,
+	unsigned salt_length, const uint8_t *salt);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_PBKDF2_H_INCLUDED */
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index c9f4698..783c9f5 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -29,6 +29,7 @@
 /meta-armor-test
 /meta-cipher-test
 /meta-hash-test
+/pbkdf2-test
 /pkcs1-test
 /random-prime-test
 /ripemd160-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 10c993f..d8f8f23 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -88,6 +88,9 @@ gcm-test$(EXEEXT): gcm-test.$(OBJEXT)
 hmac-test$(EXEEXT): hmac-test.$(OBJEXT)
 	$(LINK) hmac-test.$(OBJEXT) $(TEST_OBJS) -o hmac-test$(EXEEXT)
 
+pbkdf2-test$(EXEEXT): pbkdf2-test.$(OBJEXT)
+	$(LINK) pbkdf2-test.$(OBJEXT) $(TEST_OBJS) -o pbkdf2-test$(EXEEXT)
+
 meta-hash-test$(EXEEXT): meta-hash-test.$(OBJEXT)
 	$(LINK) meta-hash-test.$(OBJEXT) $(TEST_OBJS) -o meta-hash-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 206a76e..86f365a 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -25,7 +25,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c ctr-test.c gcm-test.c hmac-test.c \
 		    meta-hash-test.c meta-cipher-test.c meta-armor-test.c \
-		    buffer-test.c yarrow-test.c
+		    buffer-test.c yarrow-test.c pbkdf2-test.c
 
 TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
 		     rsa2sexp-test.c sexp2rsa-test.c \
diff --git a/testsuite/meta-hash-test.c b/testsuite/meta-hash-test.c
index d3dba64..58ad305 100644
--- a/testsuite/meta-hash-test.c
+++ b/testsuite/meta-hash-test.c
@@ -1,4 +1,5 @@
 #include "testutils.h"
+#include "nettle-internal.h"
 #include "nettle-meta.h"
 
 const char* hashes[] = {
diff --git a/testsuite/pbkdf2-test.c b/testsuite/pbkdf2-test.c
new file mode 100644
index 0000000..5062701
--- /dev/null
+++ b/testsuite/pbkdf2-test.c
@@ -0,0 +1,73 @@
+#include "testutils.h"
+#include "hmac.h"
+#include "sha.h"
+#include "pbkdf2.h"
+
+#define PBKDF2_TEST(ctx, size, update, digest, slen, s, c, expect)	\
+  do {									\
+    dk[expect-&gt;length] = 17;						\
+    pbkdf2 (ctx, size, update, digest, expect-&gt;length, dk, c, slen, s);	\
+    ASSERT(MEMEQ (expect-&gt;length, dk, expect-&gt;data));			\
+    ASSERT(dk[expect-&gt;length] == 17);					\
+  } while (0)
+
+#define MAX_DKLEN 25
+
+void
+test_main (void)
+{
+  uint8_t dk[MAX_DKLEN + 1];
+  struct hmac_sha1_ctx sha1ctx;
+  struct hmac_sha256_ctx sha256ctx;
+
+  /* Test vectors for PBKDF2 from RFC 6070. */
+
+  hmac_sha1_set_key (&amp;sha1ctx, 8, "password");
+
+  PBKDF2_TEST(&amp;sha1ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
+	      4, "salt", 1,
+	      SHEX("0c60c80f961f0e71f3a9b524af6012062fe037a6"));
+
+  PBKDF2_TEST (&amp;sha1ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
+	       4, "salt", 2,
+	       SHEX("ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957"));
+
+  PBKDF2_TEST (&amp;sha1ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
+	       4, "salt", 4096,
+	       SHEX("4b007901b765489abead49d926f721d065a429c1"));
+
+#if 0				/* too slow */
+  PBKDF2_TEST (&amp;sha1ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
+	       4, "salt", 16777216,
+	       SHEX("eefe3d61cd4da4e4e9945b3d6ba2158c2634e984"));
+#endif
+
+  hmac_sha1_set_key (&amp;sha1ctx, 24, "passwordPASSWORDpassword");
+
+  PBKDF2_TEST (&amp;sha1ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
+	       36, "saltSALTsaltSALTsaltSALTsaltSALTsalt", 4096,
+	       SHEX("3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038"));
+
+  hmac_sha1_set_key (&amp;sha1ctx, 9, "pass\0word");
+
+  PBKDF2_TEST (&amp;sha1ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
+	       5, "sa\0lt", 4096,
+	       SHEX("56fa6aa75548099dcc37d7f03425e0c3"));
+
+  /* PBKDF2-HMAC-SHA-256 test vectors confirmed with another
+     implementation.  */
+
+  hmac_sha256_set_key (&amp;sha256ctx, 6, "passwd");
+
+  PBKDF2_TEST (&amp;sha256ctx, SHA256_DIGEST_SIZE,
+	       hmac_sha256_update, hmac_sha256_digest,
+	       4, "salt", 1,
+	       SHEX("55ac046e56e3089fec1691c22544b605"));
+
+  hmac_sha256_set_key (&amp;sha256ctx, 8, "Password");
+
+  PBKDF2_TEST (&amp;sha256ctx, SHA256_DIGEST_SIZE,
+	       hmac_sha256_update, hmac_sha256_digest,
+	       4, "NaCl", 80000,
+	       SHEX("4ddcd8f60b98be21830cee5ef22701f9"));
+}
-- 
1.7.9.5



</body></email><email><emailId>20120919213408</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-19 21:34:08-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; nisse@lysator.liu.se (Niels Möller) writes:

&gt;&gt; If you can make an updated patch for manual and ChangeLog, that'd be
&gt;&gt; great. I'll take care of the code.
&gt;
&gt; Here it is.

Thanks. Checked in now. Hope I got all the pieces. I also added a PBKDF2
macro with the casting tricks.

And a pbkdf2_hmac_sha1 function can now be implemented as follows:

  void
  pbkdf2_hmac_sha1 (unsigned key_length, const uint8_t *key,
                    unsigned length, uint8_t *dst,
                    unsigned iterations,
                    unsigned salt_length, const uint8_t *salt)
  {
    struct hmac_sha1_ctx ctx;
    hmac_sha1_set_key (&amp;ctx, key_length, key);
    PBKDF2 (&amp;ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
            length, dst, iterations, salt_length, salt);
  }

Any final interface tweaks? Is the order of the arguments sensible and
consistent with other nettle interfaces? I.e., currently

  void
  pbkdf2 (void *mac_ctx, unsigned digest_size,
          nettle_hash_update_func *update,
          nettle_hash_digest_func *digest,
          unsigned length, uint8_t *dst,
          unsigned iterations,
          unsigned salt_length, const uint8_t *salt);

Hmm, looking at cbc_encrypt/cbc_decrypt, it might be more consistent to
(1) put digest_size after the function pointers, and (2) put the length,
dst arguments last (this depends a bit on whether or not one wants to
think of the salt as an src input or as some auxillary "parameter". At
east the iteration count should go earlier in the list. So maybe

  void
  pbkdf2 (void *mac_ctx,
          nettle_hash_update_func *update,
          nettle_hash_digest_func *digest,
          unsigned digest_size,
          unsigned iterations,
          unsigned salt_length, const uint8_t *salt,
          unsigned length, uint8_t *dst);

What do you think? This *is* nit-picking, but interface consistency is
important and this is the right time to tweak it.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120921085105</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-21 08:51:05-0400</timestampReceived><subject>Salsa20 core</subject><body>

I realized that I didn't have any use for the round-reduced Salsa20
stream functions.  So I'll focus on what I needed instead, which
resulted in a much smaller patch.  What do you think?  Open issues:

* I'm not particular happy about the name SALSA20_CORE_INOUT_SIZE.

* Where could this be documented in the manual?  "Miscellaneous
  functions"?  We could also create a new section "Non-cryptographic
  Hash functions".  There is the FNV and CRC hashes that could be
  implemented under that umbrella.

/Simon

[Attachment #3 (text/x-diff)]

&gt; From 94ed050615fc0435df797da422a665652e8018fd Mon Sep 17 00:00:00 2001
From: Simon Josefsson &lt;simon@josefsson.org&gt;
Date: Fri, 21 Sep 2012 10:21:22 +0200
Subject: [PATCH] Support Salsa20 core.

---
 Makefile.in              |    2 +-
 salsa20-core.c           |   74 ++++++++++++++++++++++++++++++++++++++++++++++
 salsa20.h                |    7 +++++
 testsuite/salsa20-test.c |   14 +++++++++
 4 files changed, 96 insertions(+), 1 deletion(-)
 create mode 100644 salsa20-core.c

diff --git a/Makefile.in b/Makefile.in
index 9904be5..24d9446 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -82,7 +82,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
-		 salsa20-crypt.c salsa20-set-key.c \
+		 salsa20-crypt.c salsa20-set-key.c salsa20-core.c \
 		 sha1.c sha1-compress.c sha1-meta.c \
 		 sha256.c sha256-compress.c sha224-meta.c sha256-meta.c \
 		 sha512.c sha512-compress.c sha384-meta.c sha512-meta.c \
diff --git a/salsa20-core.c b/salsa20-core.c
new file mode 100644
index 0000000..67895cc
--- /dev/null
+++ b/salsa20-core.c
@@ -0,0 +1,74 @@
+/* salsa20-core.c
+ *
+ * The Salsa20 core hash function.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+/* Based on salsa20-crypt.c. */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;string.h&gt;
+
+#include "salsa20.h"
+
+#include "macros.h"
+
+#define QROUND(x0, x1, x2, x3) do { \
+  x1 ^= ROTL32(7, x0 + x3);	    \
+  x2 ^= ROTL32(9, x1 + x0);	    \
+  x3 ^= ROTL32(13, x2 + x1);	    \
+  x0 ^= ROTL32(18, x3 + x2);	    \
+  } while(0)
+
+void
+salsa20_core (unsigned rounds,
+	      uint8_t dst[SALSA20_CORE_INOUT_SIZE],
+	      const uint8_t src[SALSA20_CORE_INOUT_SIZE])
+{
+  uint32_t x[SALSA20_CORE_INOUT_SIZE / sizeof (uint32_t)];
+  unsigned i;
+
+  for (i = 0; i &lt; SALSA20_CORE_INOUT_SIZE / sizeof (uint32_t); i++)
+    x[i] = LE_READ_UINT32(&amp;src[i * 4]);
+
+  for (i = 0; i &lt; rounds; i += 2)
+    {
+      QROUND(x[0], x[4], x[8], x[12]);
+      QROUND(x[5], x[9], x[13], x[1]);
+      QROUND(x[10], x[14], x[2], x[6]);
+      QROUND(x[15], x[3], x[7], x[11]);
+
+      QROUND(x[0], x[1], x[2], x[3]);
+      QROUND(x[5], x[6], x[7], x[4]);
+      QROUND(x[10], x[11], x[8], x[9]);
+      QROUND(x[15], x[12], x[13], x[14]);
+    }
+
+  for (i = 0; i &lt; SALSA20_CORE_INOUT_SIZE / sizeof (uint32_t); i++)
+    {
+      uint32_t t = x[i] + LE_READ_UINT32(&amp;src[i * 4]);
+      LE_WRITE_UINT32(&amp;dst[i * sizeof (uint32_t)], t);
+    }
+}
diff --git a/salsa20.h b/salsa20.h
index 7d47f52..f13fd3d 100644
--- a/salsa20.h
+++ b/salsa20.h
@@ -45,6 +45,8 @@ extern "C" {
 #define SALSA20_KEY_SIZE 32
 #define SALSA20_BLOCK_SIZE 64
 
+#define SALSA20_CORE_INOUT_SIZE 64
+
 #define SALSA20_IV_SIZE 8
 
 #define _SALSA20_INPUT_LENGTH 16
@@ -75,6 +77,11 @@ salsa20_crypt(struct salsa20_ctx *ctx,
 	      unsigned length, uint8_t *dst,
 	      const uint8_t *src);
 
+/* Salsa20 core. */
+void
+salsa20_core (unsigned rounds, uint8_t dst[SALSA20_CORE_INOUT_SIZE],
+	      const uint8_t src[SALSA20_CORE_INOUT_SIZE]);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/salsa20-test.c b/testsuite/salsa20-test.c
index d742ce4..f89d3ce 100644
--- a/testsuite/salsa20-test.c
+++ b/testsuite/salsa20-test.c
@@ -177,6 +177,20 @@ test_salsa20(const struct tstring *key,
 void
 test_main(void)
 {
+  uint8_t dst[SALSA20_CORE_INOUT_SIZE];
+
+  /* http://tools.ietf.org/html/draft-josefsson-scrypt-kdf */
+
+  salsa20_core (8, dst, H("7e879a214f3ec9867ca940e641718f26"
+			  "baee555b8c61c1b50df846116dcd3b1d"
+			  "ee24f319df9b3d8514121e4b5ac5aa32"
+			  "76021d2909c74829edebc68db8b8c25e"));
+  ASSERT(MEMEQ (SALSA20_CORE_INOUT_SIZE, dst,
+		H("a41f859c6608cc993b81cacb020cef05"
+		  "044b2181a2fd337dfd7b1c6396682f29"
+		  "b4393168e3c9e6bcfe6bc5b7a06d96ba"
+		  "e424cc102c91745c24ad673dc7618f81")));
+
   /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/full/verified.test-vectors?logsort=rev&amp;rev=210&amp;view=markup \
*/  
   test_salsa20(SHEX("80000000 00000000 00000000 00000000"),
-- 
1.7.9.5



</body></email><email><emailId>20120921092648</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-21 09:26:48-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; I realized that I didn't have any use for the round-reduced Salsa20
&gt; stream functions.  So I'll focus on what I needed instead, which
&gt; resulted in a much smaller patch.  What do you think?

Looks reasonable to me.

&gt; Open issues:
&gt;
&gt; * I'm not particular happy about the name SALSA20_CORE_INOUT_SIZE.

Just use SALSA20_BLOCK_SIZE. It's the same thing, right?

&gt; * Where could this be documented in the manual?  "Miscellaneous
&gt;   functions"?  We could also create a new section "Non-cryptographic
&gt;   Hash functions".

I think it would make sense to put it in the salsa section, possibly
with a reference from the section on hash functions and any other place
where it may be relevant. As I understand it, it *is* like a
cryptographic function, but with a fixed input size.

What about assembly implementation? Do you think that is desirable? I
think it should be fairly easy. Start with x86_64/salsa20-crypt.asm,
move the QROUND macro to some other file (and maybe define some
additional macros for shared code). And write a new salsa20-core.asm,
which can be pretty simple, in particular, it doesn't need the complex
code for handling partial blocks.

&gt; +void
&gt; +salsa20_core (unsigned rounds,
&gt; +	      uint8_t dst[SALSA20_CORE_INOUT_SIZE],
&gt; +	      const uint8_t src[SALSA20_CORE_INOUT_SIZE])

You settled on uint8_t input, rather than uint32_t? IIRC, the
corresponding function in the salsa20 paper is defined with uint32_t
array as input and an uint8_t array as output. 

I guess little endian byte order of the input (matching the byte order for
the output) is the only sensible choice? This ought to be clearly
documented somewhere.

In nettle I currently don't use array types for function arguments. If
you write them as arrays, like you do here, do current compilers make
any use that for bounds checking, or do you just think it's clearer for
humans?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120921094716</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-21 09:47:16-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt;&gt; * I'm not particular happy about the name SALSA20_CORE_INOUT_SIZE.
&gt;
&gt; Just use SALSA20_BLOCK_SIZE. It's the same thing, right?

It is the same value at least.  I'll use it.

&gt;&gt; * Where could this be documented in the manual?  "Miscellaneous
&gt;&gt;   functions"?  We could also create a new section "Non-cryptographic
&gt;&gt;   Hash functions".
&gt;
&gt; I think it would make sense to put it in the salsa section, possibly
&gt; with a reference from the section on hash functions and any other place
&gt; where it may be relevant. As I understand it, it *is* like a
&gt; cryptographic function, but with a fixed input size.

No, it is not a cryptographic hash function since it is not
collision-resistant.  Think of it as CRC or FNV.

&gt; What about assembly implementation? Do you think that is desirable? I
&gt; think it should be fairly easy. Start with x86_64/salsa20-crypt.asm,
&gt; move the QROUND macro to some other file (and maybe define some
&gt; additional macros for shared code). And write a new salsa20-core.asm,
&gt; which can be pretty simple, in particular, it doesn't need the complex
&gt; code for handling partial blocks.

Right.  I considered it, as a way to learn to assembler stuff in Nettle.
However, I'm not sure there is a lot to gain, since there is no loop
unrolling to speak off.  But it could be considered.

&gt;&gt; +void
&gt;&gt; +salsa20_core (unsigned rounds,
&gt;&gt; +	      uint8_t dst[SALSA20_CORE_INOUT_SIZE],
&gt;&gt; +	      const uint8_t src[SALSA20_CORE_INOUT_SIZE])
&gt;
&gt; You settled on uint8_t input, rather than uint32_t? IIRC, the
&gt; corresponding function in the salsa20 paper is defined with uint32_t
&gt; array as input and an uint8_t array as output. 
&gt;
&gt; I guess little endian byte order of the input (matching the byte order for
&gt; the output) is the only sensible choice? This ought to be clearly
&gt; documented somewhere.

Yes.  I'm struggling with this aspect.  The only canonical resource I
have been able to find on the Salsa20 core function is this page:

http://cr.yp.to/salsa20.html

It says clearly:

   The Salsa20 core is a function from 64-byte strings to 64-byte
   strings: the Salsa20 core reads a 64-byte string x and produces a
   64-byte string Salsa20(x).

and

   The 64-byte input x to Salsa20 is viewed in little-endian form as 16
   words x0, x1, x2, ..., x15 in {0,1,...,2^32-1}. ... producing, in
   little-endian form, the 64-byte output Salsa20(x).

So little endian and byte input/output is clearly intended.

The page goes on to show code that takes and return uint32_t and does no
endian conversion.  It says that this is the callers responsibility, so
we can assume this is intended to be included in the definition.

However, the Salsa20 stream cipher seems to use the core function with
uint32_t inputs, and scrypt does too.  So perhaps we should expose a
uint32_t-&gt;uint32_t interface as well that does no endian conversion.  It
seems scrypt doesn't little endian convert inputs but expects the output
uint32_t to be little endian converted though...  I'll bring this up
with Colin.

&gt; In nettle I currently don't use array types for function arguments. If
&gt; you write them as arrays, like you do here, do current compilers make
&gt; any use that for bounds checking, or do you just think it's clearer for
&gt; humans?

I've always regarded it as something intended for humans.  I'm not sure
what a compiler could do with the information.  Perhaps it could be
useful for optimizations though.

/Simon

</body></email><email><emailId>20120921101908</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-21 10:19:08-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; However, the Salsa20 stream cipher seems to use the core function with
&gt; uint32_t inputs, and scrypt does too.  So perhaps we should expose a
&gt; uint32_t-&gt;uint32_t interface as well that does no endian conversion.  It
&gt; seems scrypt doesn't little endian convert inputs but expects the output
&gt; uint32_t to be little endian converted though...  I'll bring this up
&gt; with Colin.

Nope, I was mistaken.

Still it seems that an uint32_t-&gt;uint32_t interface without endian
conversion may be beneficial for speed.  Then scrypt won't have to
convert from uint32_t to uint8_t just to have salsa convert from uint8_t
to uint32_t back again, do the operation and convert it from uint32_t to
uint8_t and have scrypt convert it from uint8_t to uint32_t.  I haven't
measured how much overhead endian conversion really consumes though.

Do you think a uint32_t-&gt;uint32_t interface would be acceptable?
Externally the uint32 interface could be seen as a convenience function,
although internally it would be the core and the uint8_t interface would
just do endian conversion.

/Simon

</body></email><email><emailId>20120921102021</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-21 10:20:21-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; No, it is not a cryptographic hash function since it is not
&gt; collision-resistant.  Think of it as CRC or FNV.

I'd like to understand better the properties of Salsa. As I see it, we
have a complicated non-linear, but easily invertible, permutation on
blocks of 64 bytes (or 512 bits). Call this function P(X). Then we
construct a hash function

  F(X) = X xor P(X)

The XOR is intended to destroy invertibility both in theory (it's no
longer a one-to-one map, or a permutation) and practice (given F(X),
it's hard to find a preimage). Am I right so far, or is there some
working trick or attack which finds a preimage?

But then I have no idea on the number and structure of the collisions,
and on the difficulty of finding a pair of colliding inputs X != Y, F(X)
= F(Y).

&gt; Right.  I considered it, as a way to learn to assembler stuff in Nettle.
&gt; However, I'm not sure there is a lot to gain, since there is no loop
&gt; unrolling to speak off.

For salsa20 and x86_64, the main gain comes from using sse2 instructions
to exploit the parallelism in the QROUND function.

&gt; However, the Salsa20 stream cipher seems to use the core function with
&gt; uint32_t inputs,

Well, it does use little endian explicitly, when copying key material
into the salsa core input.

&gt; and scrypt does too.

Reading the internet draft, it looks like it treats input and output as
64 bytes. I haven't read any other scrypt materials.

&gt; It seems scrypt doesn't little endian convert inputs but expects the
&gt; output uint32_t to be little endian converted though... I'll bring
&gt; this up with Colin.

Please do, this needs to be sorted out.

&gt;&gt; In nettle I currently don't use array types for function arguments.

&gt; I've always regarded it as something intended for humans.  I'm not sure
&gt; what a compiler could do with the information.  Perhaps it could be
&gt; useful for optimizations though.

I tend to use pointer notation, because (1) it's what really happens,
(2) it's shorter to write, and (3) because arrays may give a casual
reader the impression that something more complicated happens. Neither
is a very good reason, but for now I think we should stick to pointers
for consistency within Nettle. If arrays notation is better, we should
change that in all places where we pass arrays of constant size.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120921102707</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-21 10:27:07-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Do you think a uint32_t-&gt;uint32_t interface would be acceptable?

If that's what is really needed for scrypt (the only application so
far), and it lets you avoid converting back and forth between bytes and
uint32_t, then it seems like the right thing to do.

We may add a function with uint8_t (and little endian convention, I
guess) later if the need arises. So we should take that possibility into
account when naming the function.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120921103956</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-21 10:39:56-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; Do you think a uint32_t-&gt;uint32_t interface would be acceptable?
&gt;
&gt; If that's what is really needed for scrypt (the only application so
&gt; far), and it lets you avoid converting back and forth between bytes and
&gt; uint32_t, then it seems like the right thing to do.
&gt;
&gt; We may add a function with uint8_t (and little endian convention, I
&gt; guess) later if the need arises. So we should take that possibility into
&gt; account when naming the function.

So you don't think we should implement the uint8_t interface now?  I
think there is little cost in doing that directly, and allows us to
directly use the only test vectors that I'm aware of.

What's a good name?  Is there any precedent for something like this in
Nettle?

void
salsa20_core (unsigned rounds,
	      uint8_t dst[SALSA20_BLOCK_SIZE],
	      const uint8_t src[SALSA20_BLOCK_SIZE])

void
salsa20_core32 (unsigned rounds,
	        uint32_t dst[SALSA20_INPUT_LENGTH],
	        const uint32_t src[SALSA20_INPUT_LENGTH])

/Simon

</body></email><email><emailId>20120921105200</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-21 10:52:00-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; No, it is not a cryptographic hash function since it is not
&gt;&gt; collision-resistant.  Think of it as CRC or FNV.
&gt;
&gt; I'd like to understand better the properties of Salsa. As I see it, we
&gt; have a complicated non-linear, but easily invertible, permutation on
&gt; blocks of 64 bytes (or 512 bits). Call this function P(X). Then we
&gt; construct a hash function
&gt;
&gt;   F(X) = X xor P(X)

There is no XOR in the Salsa20 core?

&gt;&gt; and scrypt does too.
&gt;
&gt; Reading the internet draft, it looks like it treats input and output as
&gt; 64 bytes. I haven't read any other scrypt materials.

Yes, the draft treat it that way because the function appears to be
defined that way.  The scrypt paper does too
(&lt;http://www.tarsnap.com/scrypt/scrypt.pdf&gt;).

&gt;&gt; It seems scrypt doesn't little endian convert inputs but expects the
&gt;&gt; output uint32_t to be little endian converted though... I'll bring
&gt;&gt; this up with Colin.
&gt;
&gt; Please do, this needs to be sorted out.

I was mistaken, scrypt uses the uint32_t interface directly and (as
epxected) without any endian conversion.

&gt;&gt;&gt; In nettle I currently don't use array types for function arguments.
&gt;
&gt;&gt; I've always regarded it as something intended for humans.  I'm not sure
&gt;&gt; what a compiler could do with the information.  Perhaps it could be
&gt;&gt; useful for optimizations though.
&gt;
&gt; I tend to use pointer notation, because (1) it's what really happens,
&gt; (2) it's shorter to write, and (3) because arrays may give a casual
&gt; reader the impression that something more complicated happens. Neither
&gt; is a very good reason, but for now I think we should stick to pointers
&gt; for consistency within Nettle. If arrays notation is better, we should
&gt; change that in all places where we pass arrays of constant size.

No problem, I've made this change locally.  Once we sort out the naming
issue I'll submit another patch.

/Simon

</body></email><email><emailId>20120921120218</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-21 12:02:18-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt;&gt; I'd like to understand better the properties of Salsa. As I see it, we
&gt;&gt; have a complicated non-linear, but easily invertible, permutation on
&gt;&gt; blocks of 64 bytes (or 512 bits). Call this function P(X). Then we
&gt;&gt; construct a hash function
&gt;&gt;
&gt;&gt;   F(X) = X xor P(X)
&gt;
&gt; There is no XOR in the Salsa20 core?

Sorry, the final operation is addition (applied independently to 32 bit
pieces), not xor. But structure is the same, P(X) represents the QROUND
loop, where each step is invertible, and then at the end we add together
the output of the QROUNDs and the original input. Collisions are
introduced in the final addition, in the sense that we have

  P(x) == P(y) if and only if x = y

but F(x) = F(y) is possible for x != y. A collision means that

  P(x) xor x == P(y) xor y

which can be rearrange, since P is invertible, as

  x = P^{-1}(x xor y xor P(y)

Examples of such colliding pairs seem non-trivial to find (difficulty
increasing wth the number of rounds).

You write that the function is not collision resistant. I'd like to know
in which way it fails (ideally with either a simple argument, or a
reference).

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120921121049</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-21 12:10:49-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; So you don't think we should implement the uint8_t interface now?  I
&gt; think there is little cost in doing that directly, and allows us to
&gt; directly use the only test vectors that I'm aware of.

I don't have a strong opinion. If it helps testing, and we are confident
that it should be little-endian, let's add it.

&gt; What's a good name?  Is there any precedent for something like this in
&gt; Nettle?

If we look at internal building blocks, there are a couple of examples:
gcm_hash, and sha1_compress (and similar compression functions for other
hashes). Neither of those are advertised/documented.

I think it would make sense to call the uint32_t function salsa_core,
and the uint8_t function salsa_hash. We'll see if we can sort out what
properties it really has, but it definitely has important similarities
to a hash function.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120921125020</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-21 12:50:20-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt;&gt; I'd like to understand better the properties of Salsa. As I see it, we
&gt;&gt;&gt; have a complicated non-linear, but easily invertible, permutation on
&gt;&gt;&gt; blocks of 64 bytes (or 512 bits). Call this function P(X). Then we
&gt;&gt;&gt; construct a hash function
&gt;&gt;&gt;
&gt;&gt;&gt;   F(X) = X xor P(X)
&gt;&gt;
&gt;&gt; There is no XOR in the Salsa20 core?
&gt;
&gt; Sorry, the final operation is addition (applied independently to 32 bit
&gt; pieces), not xor. But structure is the same, P(X) represents the QROUND
&gt; loop, where each step is invertible, and then at the end we add together
&gt; the output of the QROUNDs and the original input. Collisions are
&gt; introduced in the final addition, in the sense that we have
&gt;
&gt;   P(x) == P(y) if and only if x = y
&gt;
&gt; but F(x) = F(y) is possible for x != y. A collision means that
&gt;
&gt;   P(x) xor x == P(y) xor y
&gt;
&gt; which can be rearrange, since P is invertible, as
&gt;
&gt;   x = P^{-1}(x xor y xor P(y)
&gt;
&gt; Examples of such colliding pairs seem non-trivial to find (difficulty
&gt; increasing wth the number of rounds).
&gt;
&gt; You write that the function is not collision resistant. I'd like to know
&gt; in which way it fails (ideally with either a simple argument, or a
&gt; reference).

Try for example:

  salsa20_core (8, dst, H("00000000000000000000000000000000"
			  "00000000000000000000000000000000"
			  "00000000000000000000000000000000"
			  "00000000000000000000000000000000"));
  print_hex(64, dst);

  salsa20_core (8, dst, H("00000080000000800000008000000080"
			  "00000080000000800000008000000080"
			  "00000080000000800000008000000080"
			  "00000080000000800000008000000080"));
  print_hex(64, dst);

both will print the all-zero string, thus illustrating a collision.  In
fact, Salsa20core(x) = Salsa20core(x + c) for c = "0000000800000008...".

See also:

https://groups.google.com/forum/?fromgroups=#!msg/sci.crypt/AkQnSoO40BA/o4eG96rjkgYJ
http://cr.yp.to/snuffle/reoncore-20080224.pdf

/Simon

</body></email><email><emailId>20120921131308</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-21 13:13:08-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; So you don't think we should implement the uint8_t interface now?  I
&gt;&gt; think there is little cost in doing that directly, and allows us to
&gt;&gt; directly use the only test vectors that I'm aware of.
&gt;
&gt; I don't have a strong opinion. If it helps testing, and we are confident
&gt; that it should be little-endian, let's add it.
&gt;
&gt;&gt; What's a good name?  Is there any precedent for something like this in
&gt;&gt; Nettle?
&gt;
&gt; If we look at internal building blocks, there are a couple of examples:
&gt; gcm_hash, and sha1_compress (and similar compression functions for other
&gt; hashes). Neither of those are advertised/documented.
&gt;
&gt; I think it would make sense to call the uint32_t function salsa_core,
&gt; and the uint8_t function salsa_hash. We'll see if we can sort out what
&gt; properties it really has, but it definitely has important similarities
&gt; to a hash function.

It is a hash function, just not a cryptographic hash function.

Below is an updated patch.  What do you think?

/Simon

[Attachment #3 (text/x-diff)]

&gt; From 306cb60ec971aaf36afae99de1183a12838e9f90 Mon Sep 17 00:00:00 2001
From: Simon Josefsson &lt;simon@josefsson.org&gt;
Date: Fri, 21 Sep 2012 10:21:22 +0200
Subject: [PATCH] Support Salsa20 core.

---
 ChangeLog                |    9 +++++
 Makefile.in              |    2 +-
 NEWS                     |    3 ++
 salsa20-core.c           |  100 ++++++++++++++++++++++++++++++++++++++++++++++
 salsa20.h                |   12 +++++-
 testsuite/salsa20-test.c |   29 ++++++++++++++
 6 files changed, 152 insertions(+), 3 deletions(-)
 create mode 100644 salsa20-core.c

diff --git a/ChangeLog b/ChangeLog
index efb578e..683e828 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,12 @@
+2012-09-21  Simon Josefsson  &lt;simon@josefsson.org&gt;
+
+	* NEWS: Mention Salsa20 core.
+	* salsa20.h (salsa20_core, salsa20_hash): Add prototypes.
+	(_SALSA20_INPUT_LENGTH): Rename to SALSA20_INPUT_LENGTH.
+	* salsa20-core.c: New file.
+	* Makefile.in (nettle_SOURCES): Add salsa20-core.c
+	* testsuite/salsa20-test.c (test_main): Test Salsa20 core.
+
 2012-09-20  Simon Josefsson  &lt;simon@josefsson.org&gt;
 
 	* pbkdf2-hmac-sha1.c, pbkdf2-hmac-sha256.c: New files.
diff --git a/Makefile.in b/Makefile.in
index 9904be5..24d9446 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -82,7 +82,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
-		 salsa20-crypt.c salsa20-set-key.c \
+		 salsa20-crypt.c salsa20-set-key.c salsa20-core.c \
 		 sha1.c sha1-compress.c sha1-meta.c \
 		 sha256.c sha256-compress.c sha224-meta.c sha256-meta.c \
 		 sha512.c sha512-compress.c sha384-meta.c sha512-meta.c \
diff --git a/NEWS b/NEWS
index 8f7e9e6..a40d6cc 100644
--- a/NEWS
+++ b/NEWS
@@ -2,6 +2,9 @@ NEWS for the 2.6 release
 
 	New features:
 
+	* Support for the Salsa20 core.  Contributed by Simon
+          Josefsson.
+
 	* Support for PKCS #5 PBKDF2.  Contributed by Simon Josefsson.
           Specification in RFC 2898 and test vectors in RFC 6070.
 
diff --git a/salsa20-core.c b/salsa20-core.c
new file mode 100644
index 0000000..a579bb1
--- /dev/null
+++ b/salsa20-core.c
@@ -0,0 +1,100 @@
+/* salsa20-core.c
+ *
+ * The Salsa20 core hash function.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+/* Based on salsa20-crypt.c. */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;string.h&gt;
+
+#include "salsa20.h"
+
+#include "macros.h"
+
+#define QROUND(x0, x1, x2, x3) do { \
+  x1 ^= ROTL32(7, x0 + x3);	    \
+  x2 ^= ROTL32(9, x1 + x0);	    \
+  x3 ^= ROTL32(13, x2 + x1);	    \
+  x0 ^= ROTL32(18, x3 + x2);	    \
+  } while(0)
+
+static void
+_salsa20 (unsigned rounds,
+	  uint32_t *x)
+{
+  unsigned i;
+
+  for (i = 0; i &lt; rounds; i += 2)
+    {
+      QROUND(x[0], x[4], x[8], x[12]);
+      QROUND(x[5], x[9], x[13], x[1]);
+      QROUND(x[10], x[14], x[2], x[6]);
+      QROUND(x[15], x[3], x[7], x[11]);
+
+      QROUND(x[0], x[1], x[2], x[3]);
+      QROUND(x[5], x[6], x[7], x[4]);
+      QROUND(x[10], x[11], x[8], x[9]);
+      QROUND(x[15], x[12], x[13], x[14]);
+    }
+}
+
+void
+salsa20_hash (unsigned rounds,
+	      uint8_t *dst,
+	      const uint8_t *src)
+{
+  uint32_t x[SALSA20_INPUT_LENGTH];
+  unsigned i;
+
+  for (i = 0; i &lt; SALSA20_INPUT_LENGTH; i++)
+      x[i] = LE_READ_UINT32(&amp;src[i * 4]);
+
+  _salsa20 (rounds, x);
+
+  for (i = 0; i &lt; SALSA20_INPUT_LENGTH; i++)
+    {
+      uint32_t t = x[i] + LE_READ_UINT32(&amp;src[i * 4]);
+      LE_WRITE_UINT32(&amp;dst[i * sizeof (uint32_t)], t);
+    }
+}
+
+void
+salsa20_core (unsigned rounds,
+	      uint32_t *dst,
+	      const uint32_t *src)
+{
+  uint32_t x[SALSA20_INPUT_LENGTH];
+  unsigned i;
+
+  for (i = 0; i &lt; SALSA20_INPUT_LENGTH; i++)
+    x[i] = src[i];
+
+  _salsa20 (rounds, x);
+
+  for (i = 0; i &lt; SALSA20_INPUT_LENGTH; i++)
+    dst[i] = x[i] + src[i];
+}
diff --git a/salsa20.h b/salsa20.h
index 7d47f52..5392b6b 100644
--- a/salsa20.h
+++ b/salsa20.h
@@ -37,6 +37,8 @@ extern "C" {
 #define salsa20_set_key nettle_salsa20_set_key
 #define salsa20_set_iv nettle_salsa20_set_iv
 #define salsa20_crypt nettle_salsa20_crypt
+#define salsa20_core nettle_salsa20_core
+#define salsa20_hash nettle_salsa20_hash
 
 /* Minimum and maximum keysizes, and a reasonable default. In
  * octets.*/
@@ -47,7 +49,7 @@ extern "C" {
 
 #define SALSA20_IV_SIZE 8
 
-#define _SALSA20_INPUT_LENGTH 16
+#define SALSA20_INPUT_LENGTH 16
 
 struct salsa20_ctx
 {
@@ -60,7 +62,7 @@ struct salsa20_ctx
      B B C K
      K K K C
   */
-  uint32_t input[_SALSA20_INPUT_LENGTH];
+  uint32_t input[SALSA20_INPUT_LENGTH];
 };
 
 void
@@ -75,6 +77,12 @@ salsa20_crypt(struct salsa20_ctx *ctx,
 	      unsigned length, uint8_t *dst,
 	      const uint8_t *src);
 
+/* Salsa20 core. */
+void
+salsa20_core (unsigned rounds, uint32_t *dst, const uint32_t *src);
+void
+salsa20_hash (unsigned rounds, uint8_t *dst, const uint8_t *src);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/salsa20-test.c b/testsuite/salsa20-test.c
index d742ce4..2f9bb9e 100644
--- a/testsuite/salsa20-test.c
+++ b/testsuite/salsa20-test.c
@@ -177,6 +177,35 @@ test_salsa20(const struct tstring *key,
 void
 test_main(void)
 {
+  uint8_t dst[SALSA20_BLOCK_SIZE];
+
+  /* http://tools.ietf.org/html/draft-josefsson-scrypt-kdf */
+
+  salsa20_hash (8, dst, H("7e879a214f3ec9867ca940e641718f26"
+			  "baee555b8c61c1b50df846116dcd3b1d"
+			  "ee24f319df9b3d8514121e4b5ac5aa32"
+			  "76021d2909c74829edebc68db8b8c25e"));
+  ASSERT(MEMEQ (SALSA20_BLOCK_SIZE, dst,
+		H("a41f859c6608cc993b81cacb020cef05"
+		  "044b2181a2fd337dfd7b1c6396682f29"
+		  "b4393168e3c9e6bcfe6bc5b7a06d96ba"
+		  "e424cc102c91745c24ad673dc7618f81")));
+
+  {
+    uint32_t src[] = { 0x219a877e, 0x86c93e4f, 0xe640a97c, 0x268f7141,
+		       0x5b55eeba, 0xb5c1618c, 0x1146f80d, 0x1d3bcd6d,
+		       0x19f324ee, 0x853d9bdf, 0x4b1e1214, 0x32aac55a,
+		       0x291d0276, 0x2948c709, 0x8dc6ebed, 0x5ec2b8b8 };
+    uint32_t expect[] = { 0x9c851fa4, 0x99cc0866, 0xcbca813b, 0x05ef0c02,
+			  0x81214b04, 0x7d33fda2, 0x631c7bfd, 0x292f6896,
+			  0x683139b4, 0xbce6c9e3, 0xb7c56bfe, 0xba966da0,
+			  0x10cc24e4, 0x5c74912c, 0x3d67ad24, 0x818f61c7 };
+    uint32_t dst2[SALSA20_INPUT_LENGTH];
+
+    salsa20_core (8, dst2, src);
+    ASSERT(MEMEQ (SALSA20_BLOCK_SIZE, dst2, expect));
+  }
+
   /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/full/verified.test-vectors?logsort=rev&amp;rev=210&amp;view=markup \
*/  
   test_salsa20(SHEX("80000000 00000000 00000000 00000000"),
-- 
1.7.9.5



</body></email><email><emailId>20120921132521</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-21 13:25:21-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; See also:
&gt;
&gt; https://groups.google.com/forum/?fromgroups=#!msg/sci.crypt/AkQnSoO40BA/o4eG96rjkgYJ
&gt; http://cr.yp.to/snuffle/reoncore-20080224.pdf

Thanks for the references. I'm now convinced we should avoid using the
word "hash" here. I should revise the corresponding section of the
Nettle manual as well.

Which leaves us with an unsolved naming problem... I don't quite like
salsa_core and salsa_core32, but I have no better suggestions right now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120921133246</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-21 13:32:46-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; See also:
&gt;&gt;
&gt;&gt; https://groups.google.com/forum/?fromgroups=#!msg/sci.crypt/AkQnSoO40BA/o4eG96rjkgYJ
&gt;&gt; http://cr.yp.to/snuffle/reoncore-20080224.pdf
&gt;
&gt; Thanks for the references. I'm now convinced we should avoid using the
&gt; word "hash" here. I should revise the corresponding section of the
&gt; Nettle manual as well.

Thanks -- I didn't notice that the text in the manual was wrong before.
Fixing that would be good.

&gt; Which leaves us with an unsolved naming problem... I don't quite like
&gt; salsa_core and salsa_core32, but I have no better suggestions right now.

I don't like it a lot either...  I believe the uint8_t version should be
called salsa20_core.  The tricky name is the uint32_t variant.
Ideas:

  salsa_core32
  salsa_core_32
  salsa_core4
  salsa_core_4
  salsa_core_4byte
  salsa_core_word
  salsa_core_uint32
  salsa_core_uint32

I don't either one of them is particulary good, so the choice is
arbitrary.  Updated patch below.

/Simon

[Attachment #3 (text/x-diff)]

&gt; From fdff2851a284247f1e1c839a2913df3bc7068d82 Mon Sep 17 00:00:00 2001
From: Simon Josefsson &lt;simon@josefsson.org&gt;
Date: Fri, 21 Sep 2012 10:21:22 +0200
Subject: [PATCH] Support Salsa20 core.

---
 ChangeLog                |    9 +++++
 Makefile.in              |    2 +-
 NEWS                     |    3 ++
 salsa20-core.c           |  100 ++++++++++++++++++++++++++++++++++++++++++++++
 salsa20.h                |   12 +++++-
 testsuite/salsa20-test.c |   29 ++++++++++++++
 6 files changed, 152 insertions(+), 3 deletions(-)
 create mode 100644 salsa20-core.c

diff --git a/ChangeLog b/ChangeLog
index efb578e..84c8754 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,12 @@
+2012-09-21  Simon Josefsson  &lt;simon@josefsson.org&gt;
+
+	* NEWS: Mention Salsa20 core.
+	* salsa20.h (salsa20_core, salsa20_core32): Add prototypes.
+	(_SALSA20_INPUT_LENGTH): Rename to SALSA20_INPUT_LENGTH.
+	* salsa20-core.c: New file.
+	* Makefile.in (nettle_SOURCES): Add salsa20-core.c
+	* testsuite/salsa20-test.c (test_main): Test Salsa20 core.
+
 2012-09-20  Simon Josefsson  &lt;simon@josefsson.org&gt;
 
 	* pbkdf2-hmac-sha1.c, pbkdf2-hmac-sha256.c: New files.
diff --git a/Makefile.in b/Makefile.in
index 9904be5..24d9446 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -82,7 +82,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
-		 salsa20-crypt.c salsa20-set-key.c \
+		 salsa20-crypt.c salsa20-set-key.c salsa20-core.c \
 		 sha1.c sha1-compress.c sha1-meta.c \
 		 sha256.c sha256-compress.c sha224-meta.c sha256-meta.c \
 		 sha512.c sha512-compress.c sha384-meta.c sha512-meta.c \
diff --git a/NEWS b/NEWS
index 8f7e9e6..a40d6cc 100644
--- a/NEWS
+++ b/NEWS
@@ -2,6 +2,9 @@ NEWS for the 2.6 release
 
 	New features:
 
+	* Support for the Salsa20 core.  Contributed by Simon
+          Josefsson.
+
 	* Support for PKCS #5 PBKDF2.  Contributed by Simon Josefsson.
           Specification in RFC 2898 and test vectors in RFC 6070.
 
diff --git a/salsa20-core.c b/salsa20-core.c
new file mode 100644
index 0000000..fe93527
--- /dev/null
+++ b/salsa20-core.c
@@ -0,0 +1,100 @@
+/* salsa20-core.c
+ *
+ * The Salsa20 core hash function.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+/* Based on salsa20-crypt.c. */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;string.h&gt;
+
+#include "salsa20.h"
+
+#include "macros.h"
+
+#define QROUND(x0, x1, x2, x3) do { \
+  x1 ^= ROTL32(7, x0 + x3);	    \
+  x2 ^= ROTL32(9, x1 + x0);	    \
+  x3 ^= ROTL32(13, x2 + x1);	    \
+  x0 ^= ROTL32(18, x3 + x2);	    \
+  } while(0)
+
+static void
+_salsa20 (unsigned rounds,
+	  uint32_t *x)
+{
+  unsigned i;
+
+  for (i = 0; i &lt; rounds; i += 2)
+    {
+      QROUND(x[0], x[4], x[8], x[12]);
+      QROUND(x[5], x[9], x[13], x[1]);
+      QROUND(x[10], x[14], x[2], x[6]);
+      QROUND(x[15], x[3], x[7], x[11]);
+
+      QROUND(x[0], x[1], x[2], x[3]);
+      QROUND(x[5], x[6], x[7], x[4]);
+      QROUND(x[10], x[11], x[8], x[9]);
+      QROUND(x[15], x[12], x[13], x[14]);
+    }
+}
+
+void
+salsa20_core (unsigned rounds,
+	      uint8_t *dst,
+	      const uint8_t *src)
+{
+  uint32_t x[SALSA20_INPUT_LENGTH];
+  unsigned i;
+
+  for (i = 0; i &lt; SALSA20_INPUT_LENGTH; i++)
+      x[i] = LE_READ_UINT32(&amp;src[i * 4]);
+
+  _salsa20 (rounds, x);
+
+  for (i = 0; i &lt; SALSA20_INPUT_LENGTH; i++)
+    {
+      uint32_t t = x[i] + LE_READ_UINT32(&amp;src[i * 4]);
+      LE_WRITE_UINT32(&amp;dst[i * sizeof (uint32_t)], t);
+    }
+}
+
+void
+salsa20_core32 (unsigned rounds,
+		uint32_t *dst,
+		const uint32_t *src)
+{
+  uint32_t x[SALSA20_INPUT_LENGTH];
+  unsigned i;
+
+  for (i = 0; i &lt; SALSA20_INPUT_LENGTH; i++)
+    x[i] = src[i];
+
+  _salsa20 (rounds, x);
+
+  for (i = 0; i &lt; SALSA20_INPUT_LENGTH; i++)
+    dst[i] = x[i] + src[i];
+}
diff --git a/salsa20.h b/salsa20.h
index 7d47f52..76c65a9 100644
--- a/salsa20.h
+++ b/salsa20.h
@@ -37,6 +37,8 @@ extern "C" {
 #define salsa20_set_key nettle_salsa20_set_key
 #define salsa20_set_iv nettle_salsa20_set_iv
 #define salsa20_crypt nettle_salsa20_crypt
+#define salsa20_core nettle_salsa20_core
+#define salsa20_core32 nettle_salsa20_core32
 
 /* Minimum and maximum keysizes, and a reasonable default. In
  * octets.*/
@@ -47,7 +49,7 @@ extern "C" {
 
 #define SALSA20_IV_SIZE 8
 
-#define _SALSA20_INPUT_LENGTH 16
+#define SALSA20_INPUT_LENGTH 16
 
 struct salsa20_ctx
 {
@@ -60,7 +62,7 @@ struct salsa20_ctx
      B B C K
      K K K C
   */
-  uint32_t input[_SALSA20_INPUT_LENGTH];
+  uint32_t input[SALSA20_INPUT_LENGTH];
 };
 
 void
@@ -75,6 +77,12 @@ salsa20_crypt(struct salsa20_ctx *ctx,
 	      unsigned length, uint8_t *dst,
 	      const uint8_t *src);
 
+/* Salsa20 core. */
+void
+salsa20_core (unsigned rounds, uint8_t *dst, const uint8_t *src);
+void
+salsa20_core32 (unsigned rounds, uint32_t *dst, const uint32_t *src);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/salsa20-test.c b/testsuite/salsa20-test.c
index d742ce4..ca1e8de 100644
--- a/testsuite/salsa20-test.c
+++ b/testsuite/salsa20-test.c
@@ -177,6 +177,35 @@ test_salsa20(const struct tstring *key,
 void
 test_main(void)
 {
+  uint8_t dst[SALSA20_BLOCK_SIZE];
+
+  /* http://tools.ietf.org/html/draft-josefsson-scrypt-kdf */
+
+  salsa20_core (8, dst, H("7e879a214f3ec9867ca940e641718f26"
+			  "baee555b8c61c1b50df846116dcd3b1d"
+			  "ee24f319df9b3d8514121e4b5ac5aa32"
+			  "76021d2909c74829edebc68db8b8c25e"));
+  ASSERT(MEMEQ (SALSA20_BLOCK_SIZE, dst,
+		H("a41f859c6608cc993b81cacb020cef05"
+		  "044b2181a2fd337dfd7b1c6396682f29"
+		  "b4393168e3c9e6bcfe6bc5b7a06d96ba"
+		  "e424cc102c91745c24ad673dc7618f81")));
+
+  {
+    uint32_t src[] = { 0x219a877e, 0x86c93e4f, 0xe640a97c, 0x268f7141,
+		       0x5b55eeba, 0xb5c1618c, 0x1146f80d, 0x1d3bcd6d,
+		       0x19f324ee, 0x853d9bdf, 0x4b1e1214, 0x32aac55a,
+		       0x291d0276, 0x2948c709, 0x8dc6ebed, 0x5ec2b8b8 };
+    uint32_t expect[] = { 0x9c851fa4, 0x99cc0866, 0xcbca813b, 0x05ef0c02,
+			  0x81214b04, 0x7d33fda2, 0x631c7bfd, 0x292f6896,
+			  0x683139b4, 0xbce6c9e3, 0xb7c56bfe, 0xba966da0,
+			  0x10cc24e4, 0x5c74912c, 0x3d67ad24, 0x818f61c7 };
+    uint32_t dst2[SALSA20_INPUT_LENGTH];
+
+    salsa20_core32 (8, dst2, src);
+    ASSERT(MEMEQ (SALSA20_BLOCK_SIZE, dst2, expect));
+  }
+
   /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/full/verified.test-vectors?logsort=rev&amp;rev=210&amp;view=markup \
*/  
   test_salsa20(SHEX("80000000 00000000 00000000 00000000"),
-- 
1.7.9.5



</body></email><email><emailId>20120921134900</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-21 13:49:00-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; It is a hash function, just not a cryptographic hash function.
&gt;
&gt; Below is an updated patch.  What do you think?

Looks pretty good. I'm not sure about naming.

Besides that, a few minor comments. Some of them boil downto simply
inlining current _salsa20 into salsa20_core, and have salsa20_hash call
salsa20_core rather than _salsa20. Do you see any drawbacks with that?

&gt; +static void
&gt; +_salsa20 (unsigned rounds,
&gt; +	  uint32_t *x)

No need to use _ in the name of a static-declared function.

&gt; +  unsigned i;
&gt; +
&gt; +  for (i = 0; i &lt; rounds; i += 2)
&gt; +    {
&gt; +      QROUND(x[0], x[4], x[8], x[12]);
&gt; +      QROUND(x[5], x[9], x[13], x[1]);
&gt; +      QROUND(x[10], x[14], x[2], x[6]);
&gt; +      QROUND(x[15], x[3], x[7], x[11]);
&gt; +
&gt; +      QROUND(x[0], x[1], x[2], x[3]);
&gt; +      QROUND(x[5], x[6], x[7], x[4]);
&gt; +      QROUND(x[10], x[11], x[8], x[9]);
&gt; +      QROUND(x[15], x[12], x[13], x[14]);
&gt; +    }

Any reason not to do the final addition here? Would need separate input
and output arguments, and be organized as

   x = input (memcpy)
   do the rounds
   dst = input + x (loop)

We need a single temporary array somewhere if we want to allow in-place
operation, and this may be that right place. And then we have
implemented all of salsa20_core.

&gt; +void
&gt; +salsa20_hash (unsigned rounds,
&gt; +	      uint8_t *dst,
&gt; +	      const uint8_t *src)
&gt; +{
&gt; +  uint32_t x[SALSA20_INPUT_LENGTH];
&gt; +  unsigned i;
&gt; +
&gt; +  for (i = 0; i &lt; SALSA20_INPUT_LENGTH; i++)
&gt; +      x[i] = LE_READ_UINT32(&amp;src[i * 4]);
&gt; +
&gt; +  _salsa20 (rounds, x);
&gt; +
&gt; +  for (i = 0; i &lt; SALSA20_INPUT_LENGTH; i++)
&gt; +    {
&gt; +      uint32_t t = x[i] + LE_READ_UINT32(&amp;src[i * 4]);

Seems unnecessary to convert (using LE_READ_UINT32) the same data twice.

&gt; +void
&gt; +salsa20_core (unsigned rounds,
&gt; +	      uint32_t *dst,
&gt; +	      const uint32_t *src)
&gt; +{
&gt; +  uint32_t x[SALSA20_INPUT_LENGTH];
&gt; +  unsigned i;
&gt; +
&gt; +  for (i = 0; i &lt; SALSA20_INPUT_LENGTH; i++)
&gt; +    x[i] = src[i];

This should be plain memcpy.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120921142147</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-21 14:21:47-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; I don't like it a lot either...  I believe the uint8_t version should be
&gt; called salsa20_core.

Agreed.

&gt; The tricky name is the uint32_t variant.
&gt; Ideas:

On this list, I think I'd prefer one of

&gt;   salsa_core_word
&gt;   salsa_core_uint32

Another alternative is to consider the function internal, at least for
the time being, and name it _salsa20_core. One motivation to keep it
internal is that it's suboptimal to have a function processing only a
single block, we may need to generalize it if we want implement other
things, e.g., a proper cryptographic hash function, using this
primitive.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120921175127</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-21 17:51:27-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Another alternative is to consider the function internal, at least for
&gt; the time being, and name it _salsa20_core.

After some more thinking, I think this is the way to go. I'd like to
propose the following plan:

* Do a _salsa20_core, working with uint32_t. Consider it an internal
  function, and keep the interface open (maybe it should be able to do
  several blocks, maybe it should byteswap output words, etc).

* Implement and document salsa20_core. It takes uint8_t blocks as input
  and output (together with key and round count), and calls
  _salsa20_core to do the work.

* Implement scrypt, in terms of _salsa20_core.

* Maybe have the C implementation salsa20_crypto also call _salsa20_core
  to do the main work. May require byteswapping in _salsa20_core output,
  to avoid a performance regression. 

* Maybe do an x86_64 implementation of _salsa20_core (should be simpler
  than salsa20_crypt).

What do you think?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120921192402</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-21 19:24:02-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; After some more thinking, I think this is the way to go. I'd like to
&gt; propose the following plan:
&gt;
&gt; * Do a _salsa20_core, working with uint32_t. Consider it an internal
&gt;   function, and keep the interface open (maybe it should be able to do
&gt;   several blocks, maybe it should byteswap output words, etc).

[...]

&gt; * Maybe have the C implementation salsa20_crypto also call _salsa20_core
&gt;   to do the main work. May require byteswapping in _salsa20_core output,
&gt;   to avoid a performance regression. 

I tried extracting a _salsa20_core from salsa20_crypt. See patch below.
The function byteswaps the output words (if needed, i.e., on bigendian
machines).

On my machine (lowend, AMD E-350), the performance penalty is 4%, 12.25
cycles/byte before the change, 12.75 cycles/byte after. I think that's
ok if it can be shared with salsa20_core and scrypt.

(And on this machine there also appears to be no significant gain from
the current assembly implementation).

Regards,
/Niels

diff --git a/Makefile.in b/Makefile.in
index 9904be5..c0ca3ad 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -82,6 +82,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
+		 salsa20-core-internal.c \
 		 salsa20-crypt.c salsa20-set-key.c \
 		 sha1.c sha1-compress.c sha1-meta.c \
 		 sha256.c sha256-compress.c sha224-meta.c sha256-meta.c \
diff --git a/salsa20-core-internal.c b/salsa20-core-internal.c
new file mode 100644
index 0000000..2c1ae3c
--- /dev/null
+++ b/salsa20-core-internal.c
@@ -0,0 +1,85 @@
+/* salsa20-core-internal.c
+ *
+ * Internal interface to the Salsa20 core function.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson, Niels MÃ¶ller
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+/* Based on:
+   salsa20-ref.c version 20051118
+   D. J. Bernstein
+   Public domain.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "salsa20.h"
+
+#include "macros.h"
+
+#ifdef WORDS_BIGENDIAN
+#define LE_SWAP32(v)				\
+  ((ROTL32(8,  v) &amp; 0x00FF00FFUL) |		\
+   (ROTL32(24, v) &amp; 0xFF00FF00UL))
+#else
+#define LE_SWAP32(v) (v)
+#endif
+
+#define QROUND(x0, x1, x2, x3) do { \
+  x1 ^= ROTL32(7, x0 + x3);	    \
+  x2 ^= ROTL32(9, x1 + x0);	    \
+  x3 ^= ROTL32(13, x2 + x1);	    \
+  x0 ^= ROTL32(18, x3 + x2);	    \
+  } while(0)
+
+void
+_salsa20_core(uint32_t *dst, const uint32_t *src, unsigned rounds)
+{
+  uint32_t x[_SALSA20_INPUT_LENGTH];
+  unsigned i;
+
+  assert ( (rounds &amp; 1) == 0);
+      
+  memcpy (x, src, sizeof(x));
+  for (i = 0; i &lt; rounds;i += 2)
+    {
+      QROUND(x[0], x[4], x[8], x[12]);
+      QROUND(x[5], x[9], x[13], x[1]);
+      QROUND(x[10], x[14], x[2], x[6]);
+      QROUND(x[15], x[3], x[7], x[11]);
+
+      QROUND(x[0], x[1], x[2], x[3]);
+      QROUND(x[5], x[6], x[7], x[4]);
+      QROUND(x[10], x[11], x[8], x[9]);
+      QROUND(x[15], x[12], x[13], x[14]);
+    }
+
+  for (i = 0; i &lt; _SALSA20_INPUT_LENGTH; i++)
+    {
+      uint32_t t = x[i] + src[i];
+      dst[i] = LE_SWAP32 (t);
+    }
+}
diff --git a/salsa20-crypt.c b/salsa20-crypt.c
index eae3cea..b061b4b 100644
--- a/salsa20-crypt.c
+++ b/salsa20-crypt.c
@@ -40,21 +40,6 @@
 #include "macros.h"
 #include "memxor.h"
 
-#ifdef WORDS_BIGENDIAN
-#define LE_SWAP32(v)				\
-  ((ROTL32(8,  v) &amp; 0x00FF00FFUL) |		\
-   (ROTL32(24, v) &amp; 0xFF00FF00UL))
-#else
-#define LE_SWAP32(v) (v)
-#endif
-
-#define QROUND(x0, x1, x2, x3) do { \
-  x1 ^= ROTL32(7, x0 + x3);	    \
-  x2 ^= ROTL32(9, x1 + x0);	    \
-  x3 ^= ROTL32(13, x2 + x1);	    \
-  x0 ^= ROTL32(18, x3 + x2);	    \
-  } while(0)
-
 void
 salsa20_crypt(struct salsa20_ctx *ctx,
 	      unsigned length,
@@ -67,26 +52,8 @@ salsa20_crypt(struct salsa20_ctx *ctx,
   for (;;)
     {
       uint32_t x[_SALSA20_INPUT_LENGTH];
-      int i;
-      memcpy (x, ctx-&gt;input, sizeof(x));
-      for (i = 0;i &lt; 10;i ++)
-	{
-	  QROUND(x[0], x[4], x[8], x[12]);
-	  QROUND(x[5], x[9], x[13], x[1]);
-	  QROUND(x[10], x[14], x[2], x[6]);
-	  QROUND(x[15], x[3], x[7], x[11]);
 
-	  QROUND(x[0], x[1], x[2], x[3]);
-	  QROUND(x[5], x[6], x[7], x[4]);
-	  QROUND(x[10], x[11], x[8], x[9]);
-	  QROUND(x[15], x[12], x[13], x[14]);
-	}
-
-      for (i = 0;i &lt; _SALSA20_INPUT_LENGTH;++i)
-	{
-	  uint32_t t = x[i] + ctx-&gt;input[i];
-	  x[i] = LE_SWAP32 (t);
-	}
+      _salsa20_core (x, ctx-&gt;input, 20);
 
       ctx-&gt;input[9] += (++ctx-&gt;input[8] == 0);
 
diff --git a/salsa20.h b/salsa20.h
index 7d47f52..d95d002 100644
--- a/salsa20.h
+++ b/salsa20.h
@@ -37,6 +37,7 @@ extern "C" {
 #define salsa20_set_key nettle_salsa20_set_key
 #define salsa20_set_iv nettle_salsa20_set_iv
 #define salsa20_crypt nettle_salsa20_crypt
+#define _salsa20_core _nettle_salsa20_core
 
 /* Minimum and maximum keysizes, and a reasonable default. In
  * octets.*/
@@ -75,6 +76,9 @@ salsa20_crypt(struct salsa20_ctx *ctx,
 	      unsigned length, uint8_t *dst,
 	      const uint8_t *src);
 
+void
+_salsa20_core(uint32_t *dst, const uint32_t *src, unsigned rounds);
+
 #ifdef __cplusplus
 }
 #endif

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120922075812</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-22 07:58:12-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt; Another alternative is to consider the function internal, at least for
&gt;&gt; the time being, and name it _salsa20_core.
&gt;
&gt; After some more thinking, I think this is the way to go. I'd like to
&gt; propose the following plan:
&gt;
&gt; * Do a _salsa20_core, working with uint32_t. Consider it an internal
&gt;   function, and keep the interface open (maybe it should be able to do
&gt;   several blocks, maybe it should byteswap output words, etc).

Should that function really be declared in salsa20.h then?

&gt; * Implement and document salsa20_core. It takes uint8_t blocks as input
&gt;   and output (together with key and round count), and calls
&gt;   _salsa20_core to do the work.

I assume you didn't mean key here, since it is unkeyed.

&gt; * Implement scrypt, in terms of _salsa20_core.

Works for me.

&gt; * Maybe have the C implementation salsa20_crypto also call _salsa20_core
&gt;   to do the main work. May require byteswapping in _salsa20_core output,
&gt;   to avoid a performance regression. 

Yes, this approach was used in an earlier patch.

&gt; * Maybe do an x86_64 implementation of _salsa20_core (should be simpler
&gt;   than salsa20_crypt).

Benchmarking it first might be good, I'm not sure you actually gain a
lot here since there is no chained block operation like stream ciphers
on bigger buffers.

I won't be able to do any more work on this until Monday though.  I
think we are essentially done though, so feel free to push things
according to the plan above.  Or I can put together something next week.

Thanks,
/Simon

</body></email><email><emailId>20120919215634</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-19 21:56:34-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt;&gt; If you can make an updated patch for manual and ChangeLog, that'd be
&gt;&gt;&gt; great. I'll take care of the code.
&gt;&gt;
&gt;&gt; Here it is.
&gt;
&gt; Thanks. Checked in now. Hope I got all the pieces. I also added a PBKDF2
&gt; macro with the casting tricks.

Thank you!

&gt; And a pbkdf2_hmac_sha1 function can now be implemented as follows:
&gt;
&gt;   void
&gt;   pbkdf2_hmac_sha1 (unsigned key_length, const uint8_t *key,
&gt;                     unsigned length, uint8_t *dst,
&gt;                     unsigned iterations,
&gt;                     unsigned salt_length, const uint8_t *salt)
&gt;   {
&gt;     struct hmac_sha1_ctx ctx;
&gt;     hmac_sha1_set_key (&amp;ctx, key_length, key);
&gt;     PBKDF2 (&amp;ctx, SHA1_DIGEST_SIZE, hmac_sha1_update, hmac_sha1_digest,
&gt;             length, dst, iterations, salt_length, salt);
&gt;   }

Could you add that, or should I submit a patch?  I think having
pbkdf2_hmac_sha256 as well would be good, but no others.

&gt; Any final interface tweaks? Is the order of the arguments sensible and
&gt; consistent with other nettle interfaces? I.e., currently
&gt;
&gt;   void
&gt;   pbkdf2 (void *mac_ctx, unsigned digest_size,
&gt;           nettle_hash_update_func *update,
&gt;           nettle_hash_digest_func *digest,
&gt;           unsigned length, uint8_t *dst,
&gt;           unsigned iterations,
&gt;           unsigned salt_length, const uint8_t *salt);
&gt;
&gt; Hmm, looking at cbc_encrypt/cbc_decrypt, it might be more consistent to
&gt; (1) put digest_size after the function pointers, and (2) put the length,
&gt; dst arguments last (this depends a bit on whether or not one wants to
&gt; think of the salt as an src input or as some auxillary "parameter". At
&gt; east the iteration count should go earlier in the list. So maybe
&gt;
&gt;   void
&gt;   pbkdf2 (void *mac_ctx,
&gt;           nettle_hash_update_func *update,
&gt;           nettle_hash_digest_func *digest,
&gt;           unsigned digest_size,
&gt;           unsigned iterations,
&gt;           unsigned salt_length, const uint8_t *salt,
&gt;           unsigned length, uint8_t *dst);
&gt;
&gt; What do you think? This *is* nit-picking, but interface consistency is
&gt; important and this is the right time to tweak it.

I prefer this new variant.  The pbkdf2_hmac_* functions should follow
this pattern too, so it would be:

   void
   pbkdf2_hmac_sha1 (unsigned key_length, const uint8_t *key,
                     unsigned iterations,
                     unsigned salt_length, const uint8_t *salt,
                     unsigned length, uint8_t *dst)

/Simon

</body></email><email><emailId>20120920192820</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-20 19:28:20-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; nisse@lysator.liu.se (Niels Möller) writes:

&gt;&gt; Thanks. Checked in now. Hope I got all the pieces.

Turned out I forgot to commit your test case. Fixed now.

I've also done the suggested reordering of the arguments (including the
prototype in the manual).

&gt; Could you add that, or should I submit a patch?

A patch including tests and documentation would be very nice. Your
prototype looks right to me,

&gt;    void
&gt;    pbkdf2_hmac_sha1 (unsigned key_length, const uint8_t *key,
&gt;                      unsigned iterations,
&gt;                      unsigned salt_length, const uint8_t *salt,
&gt;                      unsigned length, uint8_t *dst)

The declarations can go i pbkdf2.h, with implementation in separate source
files pkbdf2-hmac-sha1.c and -sha256.c.

And I can now almost write "pbkdf2" correctly without thinking. Scary... ;-)

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120920204523</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-20 20:45:23-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt;&gt; Thanks. Checked in now. Hope I got all the pieces.
&gt;
&gt; Turned out I forgot to commit your test case. Fixed now.
&gt;
&gt; I've also done the suggested reordering of the arguments (including the
&gt; prototype in the manual).

Thank you.

&gt;&gt; Could you add that, or should I submit a patch?
&gt;
&gt; A patch including tests and documentation would be very nice. Your
&gt; prototype looks right to me,
&gt;
&gt;&gt;    void
&gt;&gt;    pbkdf2_hmac_sha1 (unsigned key_length, const uint8_t *key,
&gt;&gt;                      unsigned iterations,
&gt;&gt;                      unsigned salt_length, const uint8_t *salt,
&gt;&gt;                      unsigned length, uint8_t *dst)
&gt;
&gt; The declarations can go i pbkdf2.h, with implementation in separate source
&gt; files pkbdf2-hmac-sha1.c and -sha256.c.

See patch below.  I also improved the manual a bit.

/Simon

["0001-Implement-concrete-PBKDF2-functions.patch" (text/x-diff)]

&gt; From cfad97cf3bd005e13051f359d6afa23d9cda8c41 Mon Sep 17 00:00:00 2001
From: Simon Josefsson &lt;simon@josefsson.org&gt;
Date: Thu, 20 Sep 2012 22:41:17 +0200
Subject: [PATCH] Implement concrete PBKDF2 functions.

---
 ChangeLog               |    9 ++++++++
 Makefile.in             |    2 +-
 nettle.texinfo          |   55 ++++++++++++++++++++++++++++++++++++++++++-----
 pbkdf2-hmac-sha1.c      |   45 ++++++++++++++++++++++++++++++++++++++
 pbkdf2-hmac-sha256.c    |   45 ++++++++++++++++++++++++++++++++++++++
 pbkdf2.h                |   16 ++++++++++++++
 testsuite/pbkdf2-test.c |   17 +++++++++++++++
 7 files changed, 183 insertions(+), 6 deletions(-)
 create mode 100644 pbkdf2-hmac-sha1.c
 create mode 100644 pbkdf2-hmac-sha256.c

diff --git a/ChangeLog b/ChangeLog
index 049c3dd..efb578e 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,12 @@
+2012-09-20  Simon Josefsson  &lt;simon@josefsson.org&gt;
+
+	* pbkdf2-hmac-sha1.c, pbkdf2-hmac-sha256.c: New files.
+	* pbkdf2.h (pbkdf2_hmac_sha1, pbkdf2_hmac_sha256): New prototypes.
+	* Makefile.in (nettle_SOURCES): Add pbkdf2-hmac-sha1.c and
+	pbkdf2-hmac-sha256.c.
+	* nettle.texinfo (Key derivation functions): Improve.
+	* testsuite/pbkdf2-test.c (test_main): Test new functions.
+
 2012-09-20  Niels Möller  &lt;nisse@lysator.liu.se&gt;
 
 	* pbkdf2.c (pbkdf2): Reordered arguments, for consistency.
diff --git a/Makefile.in b/Makefile.in
index 7c6cf33..9904be5 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -77,7 +77,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 des3.c des-compat.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
-		 pbkdf2.c \
+		 pbkdf2.c pbkdf2-hmac-sha1.c pbkdf2-hmac-sha256.c \
 		 knuth-lfib.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
diff --git a/nettle.texinfo b/nettle.texinfo
index a333779..c73861b 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -2123,12 +2123,19 @@ a given symmetric key derives other symmetric keys.  A \
sub-class of KDFs  is the @dfn{password-based key derivation functions} \
(@acronym{PBKDFs}),  which take as input a password or passphrase, and its purpose is
 typically to strengthen it and protect against certain pre-computation
-attacks by using salting and expensive computation.  The most well known
-PBKDF is the @code{PKCS #5 PBKDF2} described in @cite{RFC 2898} which
-uses a pseudorandom function such as @acronym{HMAC-SHA1}.
+attacks by using salting and expensive computation.
 
-Nettle's @acronym{PBKDF2} function is defined in @file{&lt;nettle/pbkdf2.h&gt;}.
-It contains a function:
+@subsection @acronym{PBKDF2}
+The most well known PBKDF is the @code{PKCS #5 PBKDF2} described in
+@cite{RFC 2898} which uses a pseudorandom function such as
+@acronym{HMAC-SHA1}.
+
+Nettle's @acronym{PBKDF2} functions are defined in
+@file{&lt;nettle/pbkdf2.h&gt;}.  There is an abstract function that operate on
+any PRF implemented via the @code{nettle_hash_update_func},
+@code{nettle_hash_digest_func} interfaces.  There is also helper macros
+and concrete functions PBKDF2-HMAC-SHA1 and PBKDF2-HMAC-SHA256.  First,
+the abstract function:
 
 @deftypefun void pbkdf2 (void *mac_ctx, nettle_hash_update_func *update, \
nettle_hash_digest_func *digest, unsigned digest_size, unsigned iterations, unsigned \
salt_length, const uint8_t *salt, unsigned length, uint8_t *dst)  Derive symmetric \
key from a password according to PKCS #5 PBKDF2.  The @@ -2141,6 +2148,44 @@ desired \
derived output length @var{length}.  The output buffer is  @var{dst} which must have \
room for at least @var{length} octets.  @end deftypefun
 
+Like for CBC and HMAC, there is a macros to help use the functions
+correctly.
+
+@deffn Macro PBKDF2 (@var{ctx}, @var{update}, @var{digest}, @var{digest_size}, \
@var{iterations}, @var{salt_length}, @var{salt}, @var{length}, @var{dst}) +@var{ctx} \
is a pointer to a context struct passed to the @var{update} +and @var{digest} \
functions (of the types @code{nettle_hash_update_func} +and \
@code{nettle_hash_digest_func} respectively) to implement the +underlying PRF with \
digest size of @var{digest_size}.  Inputs are the +salt @var{salt} of length \
@var{salt_length}, the iteration counter +@var{iterations} (&gt; 0), and the desired \
derived output length +@var{length}.  The output buffer is @var{dst} which must have \
room for +at least @var{length} octets.
+@end deffn
+
+@subsection Concrete @acronym{PBKDF2} functions
+Now we come to the specialized @acronym{PBKDF2} functions, which are
+easier to use than the general @acronym{PBKDF2} function.
+
+@subsubsection @acronym{PBKDF2-HMAC-SHA1}
+
+@deftypefun void pbkdf2_hmac_sha1 (unsigned @var{key_length}, const uint8_t \
*@var{key}, unsigned @var{iterations}, unsigned @var{salt_length}, const uint8_t \
*@var{salt}, unsigned @var{length}, uint8_t *@var{dst}) +PBKDF2 with HMAC-SHA1.  \
Derive @var{length} bytes of key into buffer +@var{dst} using the password @var{key} \
of length @var{key_length} and +salt @var{salt} of length @var{salt_length}, with \
iteration counter +@var{iterations} (&gt; 0).  The output buffer is @var{dst} which must \
have +room for at least @var{length} octets.
+@end deftypefun
+
+@subsubsection @acronym{PBKDF2-HMAC-SHA256}
+
+@deftypefun void pbkdf2_hmac_sha256 (unsigned @var{key_length}, const uint8_t \
*@var{key}, unsigned @var{iterations}, unsigned @var{salt_length}, const uint8_t \
*@var{salt}, unsigned @var{length}, uint8_t *@var{dst}) +PBKDF2 with HMAC-SHA256.  \
Derive @var{length} bytes of key into buffer +@var{dst} using the password @var{key} \
of length @var{key_length} and +salt @var{salt} of length @var{salt_length}, with \
iteration counter +@var{iterations} (&gt; 0).  The output buffer is @var{dst} which must \
have +room for at least @var{length} octets.
+@end deftypefun
+
 @node Public-key algorithms, Randomness, Key derivation functions, Reference
 @comment  node-name,  next,  previous,  up
 @section Public-key algorithms
diff --git a/pbkdf2-hmac-sha1.c b/pbkdf2-hmac-sha1.c
new file mode 100644
index 0000000..9185503
--- /dev/null
+++ b/pbkdf2-hmac-sha1.c
@@ -0,0 +1,45 @@
+/* pbkdf2-hmac-sha1.c
+ *
+ * PKCS #5 PBKDF2 used with HMAC-SHA1, see RFC 2898.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "pbkdf2.h"
+
+#include "hmac.h"
+
+void
+pbkdf2_hmac_sha1 (unsigned key_length, const uint8_t *key,
+		  unsigned iterations,
+		  unsigned salt_length, const uint8_t *salt,
+		  unsigned length, uint8_t *dst)
+{
+  struct hmac_sha1_ctx sha1ctx;
+
+  hmac_sha1_set_key (&amp;sha1ctx, key_length, key);
+  PBKDF2 (&amp;sha1ctx, hmac_sha1_update, hmac_sha1_digest,
+	  SHA1_DIGEST_SIZE, iterations, salt_length, salt, length, dst);
+}
diff --git a/pbkdf2-hmac-sha256.c b/pbkdf2-hmac-sha256.c
new file mode 100644
index 0000000..448f676
--- /dev/null
+++ b/pbkdf2-hmac-sha256.c
@@ -0,0 +1,45 @@
+/* pbkdf2-hmac-sha256.c
+ *
+ * PKCS #5 PBKDF2 used with HMAC-SHA256, see RFC 2898.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "pbkdf2.h"
+
+#include "hmac.h"
+
+void
+pbkdf2_hmac_sha256 (unsigned key_length, const uint8_t *key,
+		  unsigned iterations,
+		  unsigned salt_length, const uint8_t *salt,
+		  unsigned length, uint8_t *dst)
+{
+  struct hmac_sha256_ctx sha256ctx;
+
+  hmac_sha256_set_key (&amp;sha256ctx, key_length, key);
+  PBKDF2 (&amp;sha256ctx, hmac_sha256_update, hmac_sha256_digest,
+	  SHA256_DIGEST_SIZE, iterations, salt_length, salt, length, dst);
+}
diff --git a/pbkdf2.h b/pbkdf2.h
index aa61567..18816ce 100644
--- a/pbkdf2.h
+++ b/pbkdf2.h
@@ -35,6 +35,8 @@ extern "C"
 
 /* Namespace mangling */
 #define pbkdf2 nettle_pbkdf2
+#define pbkdf2_hmac_sha1 nettle_pbkdf2_sha1
+#define pbkdf2_hmac_sha256 nettle_pbkdf2_sha256
 
 void
 pbkdf2 (void *mac_ctx,
@@ -54,6 +56,20 @@ pbkdf2 (void *mac_ctx,
 	     (digest_size), (iterations),				\
 	     (salt_length), (salt), (length), (dst)))
 
+/* PBKDF2 with specific PRFs. */
+
+void
+pbkdf2_hmac_sha1 (unsigned key_length, const uint8_t *key,
+		  unsigned iterations,
+		  unsigned salt_length, const uint8_t *salt,
+		  unsigned length, uint8_t *dst);
+
+void
+pbkdf2_hmac_sha256 (unsigned key_length, const uint8_t *key,
+		    unsigned iterations,
+		    unsigned salt_length, const uint8_t *salt,
+		    unsigned length, uint8_t *dst);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/pbkdf2-test.c b/testsuite/pbkdf2-test.c
index 6ef5832..c0d2eae 100644
--- a/testsuite/pbkdf2-test.c
+++ b/testsuite/pbkdf2-test.c
@@ -12,6 +12,14 @@
     ASSERT(dk[expect-&gt;length] == 17);					\
   } while (0)
 
+#define PBKDF2_HMAC_TEST(f, key, c, salt, expect)			\
+  do {									\
+    dk[expect-&gt;length] = 17;						\
+    f (key, c, salt, expect-&gt;length, dk);				\
+    ASSERT(MEMEQ (expect-&gt;length, dk, expect-&gt;data));			\
+    ASSERT(dk[expect-&gt;length] == 17);					\
+  } while (0)
+
 #define MAX_DKLEN 25
 
 void
@@ -69,4 +77,13 @@ test_main (void)
   PBKDF2_TEST (&amp;sha256ctx, hmac_sha256_update, hmac_sha256_digest,
 	       SHA256_DIGEST_SIZE, 80000, LDATA("NaCl"),
 	       SHEX("4ddcd8f60b98be21830cee5ef22701f9"));
+
+  /* Test convenience functions. */
+
+  PBKDF2_HMAC_TEST(pbkdf2_hmac_sha1, LDATA("password"), 1, LDATA("salt"),
+		   SHEX("0c60c80f961f0e71f3a9b524af6012062fe037a6"));
+
+  PBKDF2_HMAC_TEST(pbkdf2_hmac_sha256, LDATA("passwd"), 1, LDATA("salt"),
+		   SHEX("55ac046e56e3089fec1691c22544b605"));
+
 }
-- 
1.7.9.5



</body></email><email><emailId>20120921061411</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-21 06:14:11-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; See patch below.  I also improved the manual a bit.

Thanks! Committed now.

&gt; --- a/pbkdf2.h
&gt; +++ b/pbkdf2.h
&gt; @@ -35,6 +35,8 @@ extern "C"
&gt;  
&gt;  /* Namespace mangling */
&gt;  #define pbkdf2 nettle_pbkdf2
&gt; +#define pbkdf2_hmac_sha1 nettle_pbkdf2_sha1
&gt; +#define pbkdf2_hmac_sha256 nettle_pbkdf2_sha256

I changed the symbols to nettle_pbkdf2_hmac_sha1 and
nettle_pbkdf2_hmac_sha256. I take it the abbreviation was unintentional?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120921071710</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-21 07:17:10-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt;&gt; --- a/pbkdf2.h
&gt;&gt; +++ b/pbkdf2.h
&gt;&gt; @@ -35,6 +35,8 @@ extern "C"
&gt;&gt;  
&gt;&gt;  /* Namespace mangling */
&gt;&gt;  #define pbkdf2 nettle_pbkdf2
&gt;&gt; +#define pbkdf2_hmac_sha1 nettle_pbkdf2_sha1
&gt;&gt; +#define pbkdf2_hmac_sha256 nettle_pbkdf2_sha256
&gt;
&gt; I changed the symbols to nettle_pbkdf2_hmac_sha1 and
&gt; nettle_pbkdf2_hmac_sha256. I take it the abbreviation was unintentional?

Right, sorry about that.  Thank you!

I'll proceed cleaning up the Salsa code next, to reach my goal of having
scrypt in here as well (I have it working on
&lt;https://www.gitorious.org/scrypt/nettle-scrypt&gt;).

/Simon

</body></email><email><emailId>20120921075112</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-21 07:51:12-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; I'll proceed cleaning up the Salsa code next, to reach my goal of having
&gt; scrypt in here as well (I have it working on
&gt; &lt;https://www.gitorious.org/scrypt/nettle-scrypt&gt;).

That's the algorihtm described in
https://tools.ietf.org/html/draft-josefsson-scrypt-kdf-00, right?

What features do you need for the salsa interface? After a quick look,
it seems you will not be processing independent blocks with salsa20, so
you will not be able to take any advantage of parallelism there (which I
imagine is an intended feature of scrypt).

It's straight forward to add a round parameter to salsa20. But it's
still not clear to me what's the best way to support hashing only. It
would have been a bit easier if you could replace

  X = Salsa(X xor B[i])

by

  X = Salsa(X) xor B[i]

since the latter is closer to the standard encryption operation. I think
the iteration *can* be rewritten in that form by some change of
variables, but you'd need an extra xor at the end to really get Y[i]
rather than Y[i] xor B[i]. The algorithm specification is already set in
stone?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120907150227</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-07 15:02:27-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt;&gt;   #define NONNULL(args) __attribute__ ((nonnull args))
&gt;
&gt; Yes, functions with several non-null args than need several NONNULL(x) 
&gt; occurrences.

I don't think so. NONNULL((1,3,5)) should work, with "(1,3,5)" treated
as a single argument by the preprocessor. I would actually prefer to
have NONNULL declaration on each argument in question, just like UNUSED,
but if I understand it correctly, that won't work.

&gt; The idea of nonnull is to enable the compiler detecting possible NULL 
&gt; arguments where they must not be. E.g. char *s=NULL; strlen(s); would let the 
&gt; compiler print a warning.

I'm not entirely convinced about the usefulness of that.

&gt; At the same time, when optimizing a function with a nonnull argument, 
&gt; gcc optimizes away checks against NULL for the appropriate variables.

I'm not entirely convinced that makes for any real improvements of
performance on real code. And I think I'd rather get a warning from the
compiler about a useless comparison (like, like gcc warns for for
unsigned x = ...; if (x &gt;= 0)...) than having the optimizer silently
remove the code.

In particular, if I have a funtion where a pointer must not be NULL, and
I have an assert (p != NULL); to that effect, then I will *not* consider
it an improvement if the compiler decides to remove that assert.

Is there anything more useful and interesting that the compiler can do,
knowing that a pointer can't be NULL?

Sorry if I sound extremely negative. I think nonnull declarations in
header files could serve some purpose for documentation, but I doubt it
will improve performance or make it easier to find real bugs.

&gt; Since gcc can't detect indirect NULL values, the function may crash the 
&gt; process.

I'm not sure what you mean here, but I guess it won't work well to have
the nonnull attribute propagate (say, in the same way as const). With
the following code,

int foo (const char *a, const char *b) __attribute__ ((nonnull)
{
  return strcmp (a, b);
}

int bar (const char *a)
{
  return foo (a, "foo");
}

should gcc issue a warning (since as far as we have told the compiler,
bar (NULL) is allowed, but that is not allowed for it's call to foo)?
Does it, or clang, issue warnings for such code?

&gt;&gt; 2. Since when (release and year) is it supported by gcc?
&gt;
&gt; I found it to be for gcc &gt;= 3.3,
&gt; see http://ohse.de/uwe/articles/gcc-attributes.html#func-nonnull

Released back in 2004 (http://gcc.gnu.org/releases.html). Then I guess
it shouldn't be too bad to use it unconditionally when compiling with
gcc. Or check the gcc version predefines, that's not a very big hassle.

&gt; The reason I used nonnull were several compiler warnings. The current libc6 
&gt; header files seem to use nonnull by default (gcc 4.7.1, libc6 2.13).

Can you quote the warnings in question? I'd like to understand why it
complains.

&gt; Maybe there should be -std=c89 in den CFLAGS to prevent that ?

That would make sense. Or at least *some* flag to issue warnings for c99
additions like C++-style comments and declarations not at the start of a
block.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120907165927</emailId><senderName>Tim =?iso-8859-1?q?R=FChsen?=</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-07 16:59:27-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Am Freitag, 7. September 2012 schrieb Niels Möller:
&gt; Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:
&gt; 
&gt; &gt;&gt;   #define NONNULL(args) __attribute__ ((nonnull args))
&gt; &gt;
&gt; &gt; Yes, functions with several non-null args than need several NONNULL(x) 
&gt; &gt; occurrences.
&gt; 
&gt; I don't think so. NONNULL((1,3,5)) should work, with "(1,3,5)" treated
&gt; as a single argument by the preprocessor.

Yes, I didn't think of that.

&gt; I would actually prefer to
&gt; have NONNULL declaration on each argument in question, just like UNUSED,
&gt; but if I understand it correctly, that won't work.

No, that won't work.

&gt; &gt; The idea of nonnull is to enable the compiler detecting possible NULL 
&gt; &gt; arguments where they must not be. E.g. char *s=NULL; strlen(s); would let 
the 
&gt; &gt; compiler print a warning.
&gt; 
&gt; I'm not entirely convinced about the usefulness of that.
&gt; 
&gt; &gt; At the same time, when optimizing a function with a nonnull argument, 
&gt; &gt; gcc optimizes away checks against NULL for the appropriate variables.
&gt; 
&gt; I'm not entirely convinced that makes for any real improvements of
&gt; performance on real code.

Don't get me wrong. It is not about performance. It is about bugs detected by 
the compiler before they happen.
assert() only detects these NULL args if your testing reaches this special 
point. The compiler is theoretically able to find these at compile time.

&gt; And I think I'd rather get a warning from the
&gt; compiler about a useless comparison (like, like gcc warns for for
&gt; unsigned x = ...; if (x &gt;= 0)...) than having the optimizer silently
&gt; remove the code.
&gt; 
&gt; In particular, if I have a funtion where a pointer must not be NULL, and
&gt; I have an assert (p != NULL); to that effect, then I will *not* consider
&gt; it an improvement if the compiler decides to remove that assert.
&gt; 
&gt; Is there anything more useful and interesting that the compiler can do,
&gt; knowing that a pointer can't be NULL?
&gt; 
&gt; Sorry if I sound extremely negative. I think nonnull declarations in
&gt; header files could serve some purpose for documentation, but I doubt it
&gt; will improve performance or make it easier to find real bugs.

Again, not performance. Bug detection while compilation.

&gt; &gt; Since gcc can't detect indirect NULL values, the function may crash the 
&gt; &gt; process.
&gt; 
&gt; I'm not sure what you mean here, but I guess it won't work well to have
&gt; the nonnull attribute propagate (say, in the same way as const). With
&gt; the following code,
&gt; 
&gt; int foo (const char *a, const char *b) __attribute__ ((nonnull)
&gt; {
&gt;   return strcmp (a, b);
&gt; }
&gt; 
&gt; int bar (const char *a)
&gt; {
&gt;   return foo (a, "foo");
&gt; }
&gt; 
&gt; should gcc issue a warning (since as far as we have told the compiler,
&gt; bar (NULL) is allowed, but that is not allowed for it's call to foo)?
&gt; Does it, or clang, issue warnings for such code?

I just put the code into a C file.
As expected (and documented, if you read the link): gcc does not detect the 
implicit call. scan-build (clang analyzer) does !!

&gt; &gt;&gt; 2. Since when (release and year) is it supported by gcc?
&gt; &gt;
&gt; &gt; I found it to be for gcc &gt;= 3.3,
&gt; &gt; see http://ohse.de/uwe/articles/gcc-attributes.html#func-nonnull
&gt; 
&gt; Released back in 2004 (http://gcc.gnu.org/releases.html). Then I guess
&gt; it shouldn't be too bad to use it unconditionally when compiling with
&gt; gcc. Or check the gcc version predefines, that's not a very big hassle.
&gt; 
&gt; &gt; The reason I used nonnull were several compiler warnings. The current 
libc6 
&gt; &gt; header files seem to use nonnull by default (gcc 4.7.1, libc6 2.13).
&gt; 
&gt; Can you quote the warnings in question? I'd like to understand why it
&gt; complains.

Just use scan-build/scan-view and you have in the report.

&gt; &gt; Maybe there should be -std=c89 in den CFLAGS to prevent that ?
&gt; 
&gt; That would make sense. Or at least *some* flag to issue warnings for c99
&gt; additions like C++-style comments and declarations not at the start of a
&gt; block.
&gt; 
&gt; Regards,
&gt; /Niels

Have a nice weekend.

Tim

</body></email><email><emailId>20120907190445</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-07 19:04:45-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; In cast128.c I removed the wiping of t, l and r. Instead I set t=0 at the 
&gt; beginning of the loops (It seemed to be used uninitialized in F1
&gt; macro).

I don't think the wiping has any meaning. Perhaps it was intended to
somehow avoid leaking intermediate values. (I'm not the original author
of this file).

I don't understand the comment on t being used before initialized. As
far as I see, all of F1, F2 and F3 first assign t, then apply some sbox
substitutions on it. Am I missing something?

If you are addressing some compiler warnings, please, *pretty please*,
quote them accurately.

I do get several warnings (false positives) on a different function in
this file when I compile with gcc:

  cast128.c: In function `nettle_cast128_set_key':
  cast128.c:276:1: warning: `t[3]' may be used uninitialized in this function [-Wmaybe-uninitialized]
  cast128.c:210:26: warning: `z[3]' may be used uninitialized in this function [-Wmaybe-uninitialized]

and a bunch more similar ones. I think I'd prefer to reorganize this
function completely, I find the current organization hard to understand.

&gt; diff --git a/examples/eratosthenes.c b/examples/eratosthenes.c
&gt; index 2b9d04f..0eea941 100644
&gt; --- a/examples/eratosthenes.c
&gt; +++ b/examples/eratosthenes.c
&gt; @@ -399,5 +399,10 @@ main (int argc, char **argv)
&gt;  	    printf("%lu\n", n);
&gt;  	}
&gt;      }
&gt; +
&gt; +  /* silence static analyzers */
&gt; +  free(block);
&gt; +  free(sieve);
&gt; +
&gt;    return EXIT_SUCCESS;
&gt;  }

Why this? It ought to be the job of the C library to free all malloced
storage after main returns. Do you get a warning for this? That sounds
overly noisy to me.

&gt; diff --git a/examples/io.c b/examples/io.c
&gt; index 7b2289c..cda9ed3 100644
&gt; --- a/examples/io.c
&gt; +++ b/examples/io.c
&gt; @@ -125,7 +125,10 @@ read_file(const char *name, unsigned max_size, char **contents)
&gt;    fclose(f);
&gt;  
&gt;    /* NUL-terminate the data. */
&gt; -  buffer[done] = '\0';
&gt; +  if (buffer)
&gt; +    buffer[done] = '\0';
&gt; +  else
&gt; +    done = 0;
&gt;    *contents = buffer;

This ought not to happen. Hmm. I think the only way the execution can
omit the realloc call (and the check for NULL return value) in the loop
is if feof returns true immediately after fopen. Does you analyzer agree
with that?

Then the correct fix is to move the feof call to after fread, as
suggested in the preceding FIXME comment.

&gt; diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
&gt; index b76a91c..48e53d0 100644
&gt; --- a/examples/nettle-benchmark.c
&gt; +++ b/examples/nettle-benchmark.c
&gt; @@ -96,7 +96,7 @@ static double frequency = 0.0;
&gt;  #define BENCH_ITERATIONS 10
&gt;  #endif
&gt;  
&gt; -static void
&gt; +static void NORETURN
&gt;  die(const char *format, ...)
&gt;  {
&gt;    va_list args;

Applied.

&gt; diff --git a/tools/misc.h b/tools/misc.h
&gt; index 70c9eeb..af55998 100644
&gt; --- a/tools/misc.h
&gt; +++ b/tools/misc.h
&gt; @@ -28,19 +28,10 @@
&gt;  #endif
&gt;  
&gt;  void
&gt; -die(const char *format, ...)
&gt; -#if __GNUC___
&gt; -     __attribute__((__format__ (__printf__,1, 2)))
&gt; -     __attribute__((__noreturn__))
&gt; -#endif
&gt; -     ;
&gt; +die(const char *format, ...) PRINTF_STYLE(1,2) NORETURN;
&gt;  
&gt;  void
&gt; -werror(const char *format, ...)
&gt; -#if __GNUC___
&gt; -     __attribute__((__format__ (__printf__,1, 2)))
&gt; -#endif
&gt; -     ;
&gt; +werror(const char *format, ...) PRINTF_STYLE(1,2);
&gt;  
&gt;  void *
&gt;  xalloc(size_t size);

Applied. I found one more werror prototype, in examples/io.h, which I
improved in the same way (maybe that was in another patch of yours? I
haven't reviewed all yet).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120910071337</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-10 07:13:37-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; diff --git a/examples/base16enc.c b/examples/base16enc.c
&gt; index c3cb58f..3fc410e 100644
&gt; --- a/examples/base16enc.c
&gt; +++ b/examples/base16enc.c
&gt; @@ -47,21 +47,6 @@
&gt;  int
&gt;  main(int argc UNUSED, char **argv UNUSED)
&gt;  {
&gt; -
&gt; -  /* "buffer" will hold the bytes from disk: */
&gt; -  uint8_t * buffer = (uint8_t *) malloc (CHUNK_SIZE * sizeof(uint8_t));
&gt; -  if (buffer == NULL) {
&gt; -    fprintf (stderr, "Cannot allocate read buffer.\n");
&gt; -    return EXIT_FAILURE;
&gt; -  }
&gt; -
&gt; -  /* "result" will hold bytes before output: */
&gt; -  uint8_t * result = (uint8_t *) malloc (ENCODED_SIZE * sizeof(uint8_t));
&gt; -  if (result == NULL) {
&gt; -    fprintf (stderr, "Cannot allocate write buffer.\n");
&gt; -    return EXIT_FAILURE;
&gt; -  }
&gt; -
&gt;  #ifdef WIN32
&gt;    _setmode(0, O_BINARY);
&gt;  #endif

Applied.

Thanks,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120910072801</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-10 07:28:01-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Am Friday 07 September 2012 schrieb Niels Möller:
&gt; Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:
&gt; &gt; In cast128.c I removed the wiping of t, l and r. Instead I set t=0 at the
&gt; &gt; beginning of the loops (It seemed to be used uninitialized in F1
&gt; &gt; macro).
&gt; 
&gt; I don't think the wiping has any meaning. Perhaps it was intended to
&gt; somehow avoid leaking intermediate values. (I'm not the original author
&gt; of this file).
&gt; 
&gt; I don't understand the comment on t being used before initialized. As
&gt; far as I see, all of F1, F2 and F3 first assign t, then apply some sbox
&gt; substitutions on it. Am I missing something?

You are right (my editor 'macro-expanded' F1 to a pretty ugly term - I just 
oversaw that t is being initialized.). The line t = 0 can be removed in 
cast128_encrypt() and cast128_decrypt(), sorry.

&gt; If you are addressing some compiler warnings, please, *pretty please*,
&gt; quote them accurately.

Some maintainers really want that, others not.
I try to keep that in mind for the nettle project ...

&gt; I do get several warnings (false positives) on a different function in
&gt; this file when I compile with gcc:
&gt; 
&gt;   cast128.c: In function `nettle_cast128_set_key':
&gt;   cast128.c:276:1: warning: `t[3]' may be used uninitialized in this
&gt; function [-Wmaybe-uninitialized] cast128.c:210:26: warning: `z[3]' may be
&gt; used uninitialized in this function [-Wmaybe-uninitialized]
&gt; 
&gt; and a bunch more similar ones. I think I'd prefer to reorganize this
&gt; function completely, I find the current organization hard to understand.

I took a look into these functions and decided not to change them.
It would be pretty easy to silence these warnings (just clear the t[] and z[] 
arrays. The performance penalty will be hardly measurable. But this is a 
decision I did not want to make.


&gt; 
&gt; &gt; diff --git a/examples/eratosthenes.c b/examples/eratosthenes.c
&gt; &gt; index 2b9d04f..0eea941 100644
&gt; &gt; --- a/examples/eratosthenes.c
&gt; &gt; +++ b/examples/eratosthenes.c
&gt; &gt; @@ -399,5 +399,10 @@ main (int argc, char **argv)
&gt; &gt; 
&gt; &gt;  	    printf("%lu\n", n);
&gt; &gt;  	
&gt; &gt;  	}
&gt; &gt;  	
&gt; &gt;      }
&gt; &gt; 
&gt; &gt; +
&gt; &gt; +  /* silence static analyzers */
&gt; &gt; +  free(block);
&gt; &gt; +  free(sieve);
&gt; &gt; +
&gt; &gt; 
&gt; &gt;    return EXIT_SUCCESS;
&gt; &gt;  
&gt; &gt;  }
&gt; 
&gt; Why this? It ought to be the job of the C library to free all malloced
&gt; storage after main returns. Do you get a warning for this? That sounds
&gt; overly noisy to me.

Here are some reasons why silencing 'false positives' makes sense:
1. Each person new to the project will see these warnings and will waste time 
in viewing and understanding the source, just to say "oh yeah, it is a false 
positive - i'll keep that in mind...". It is a waste of precious human 
resources.

2. People might copy&amp;paste the code (for whatever reasons) to a function which 
name is not "main".

3. How do you want to use valgrind for automatic memory leak testing ?

4. "main" is just a function name and only special if you link with the 
standard C library. A static analyzer can't be shure that the programmer will 
use some other mechanisms to start the program, so it complains about memory 
leaks even in the main() function. As a programmer, I really want this 
behaviour. 

5. It is just a matter of good coding style. Are you going to say "ahhh, it is 
the main function - I don't need to call free() here." ? 

There might be more reasons.

&gt; 
&gt; &gt; diff --git a/examples/io.c b/examples/io.c
&gt; &gt; index 7b2289c..cda9ed3 100644
&gt; &gt; --- a/examples/io.c
&gt; &gt; +++ b/examples/io.c
&gt; &gt; @@ -125,7 +125,10 @@ read_file(const char *name, unsigned max_size, char
&gt; &gt; **contents)
&gt; &gt; 
&gt; &gt;    fclose(f);
&gt; &gt;    
&gt; &gt;    /* NUL-terminate the data. */
&gt; &gt; 
&gt; &gt; -  buffer[done] = '\0';
&gt; &gt; +  if (buffer)
&gt; &gt; +    buffer[done] = '\0';
&gt; &gt; +  else
&gt; &gt; +    done = 0;
&gt; &gt; 
&gt; &gt;    *contents = buffer;
&gt; 
&gt; This ought not to happen. Hmm. I think the only way the execution can
&gt; omit the realloc call (and the check for NULL return value) in the loop
&gt; is if feof returns true immediately after fopen. Does you analyzer agree
&gt; with that?
&gt; 
&gt; Then the correct fix is to move the feof call to after fread, as
&gt; suggested in the preceding FIXME comment.

Well, I don't mind how you fix that warning.
But the bare fact, that you have to think about it, tells me that there is 
something wrong in that function. Maybe not practically, but for someone who 
wants to understand the function. If you are not shure, if a variable will be 
initialized or not: just initialize it to make it 100% clear.


Regards, Tim

</body></email><email><emailId>20120910073153</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-10 07:31:53-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; diff --git a/pgp-encode.c b/pgp-encode.c
&gt; index 9a69922..f84373c 100644
&gt; --- a/pgp-encode.c
&gt; +++ b/pgp-encode.c
&gt; @@ -246,7 +246,6 @@ pgp_put_rsa_sha1_signature(struct nettle_buffer *buffer,
&gt;    unsigned hash_end;
&gt;    unsigned sub_packet_start;
&gt;    uint8_t trailer[6];
&gt; -  uint8_t digest16[2];
&gt;    mpz_t s;
&gt;    
&gt;    /* Signature packet. The packet could reasonably be both smaller and
&gt; diff --git a/rsa2openpgp.c b/rsa2openpgp.c
&gt; index c4666f3..4c62f49 100644
&gt; --- a/rsa2openpgp.c
&gt; +++ b/rsa2openpgp.c
&gt; @@ -64,7 +64,6 @@ rsa_keypair_to_openpgp(struct nettle_buffer *buffer,
&gt;    time_t now = time(NULL);
&gt;  
&gt;    unsigned key_start;
&gt; -  unsigned key_length;
&gt;    unsigned userid_start;
&gt;    
&gt;    struct sha1_ctx key_hash;

Applied.

&gt; diff --git a/desdata.c b/desdata.c
&gt; index fc89c2d..6671b5d 100644
&gt; --- a/desdata.c
&gt; +++ b/desdata.c
&gt; @@ -62,7 +62,7 @@ int sorder[] = {
&gt;  	7, 5, 3, 1, 6, 4, 2, 0,
&gt;  };
&gt;  
&gt; -int printf(const char *, ...);
&gt; +int printf(const char *, ...) PRINTF_STYLE(1,2);
&gt;  
&gt;  int
&gt;  main(int argc UNUSED, char **argv UNUSED)

Changed it to include stdio.h instead.

&gt; diff --git a/examples/io.h b/examples/io.h
&gt; index ff4a18d..e83b7eb 100644
&gt; --- a/examples/io.h
&gt; +++ b/examples/io.h
&gt; @@ -37,11 +37,7 @@ void *
&gt;  xalloc(size_t size);
&gt;  
&gt;  void
&gt; -werror(const char *format, ...)
&gt; -#if __GNUC___
&gt; -     __attribute__((__format__ (__printf__,1, 2)))
&gt; -#endif
&gt; -     ;
&gt; +werror(const char *format, ...) PRINTF_STYLE(1,2);
&gt;  
&gt;  /* If size is &gt; 0, read at most that many bytes. If size == 0,
&gt;   * read until EOF. Allocates the buffer dynamically. */

Did this a few days ago.

&gt; index 48e53d0..3d07868 100644
&gt; --- a/examples/nettle-benchmark.c
&gt; +++ b/examples/nettle-benchmark.c
&gt; @@ -96,7 +96,7 @@ static double frequency = 0.0;
&gt;  #define BENCH_ITERATIONS 10
&gt;  #endif
&gt;  
&gt; -static void NORETURN
&gt; +static void NORETURN PRINTF_STYLE(1,2)
&gt;  die(const char *format, ...)
&gt;  {
&gt;    va_list args;

Applied.

Thanks,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120910110903</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-10 11:09:03-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; 5. It is just a matter of good coding style.

I'll consider adding those free calls (motivated by the "good coding
style" argument, with no comment about static analyzers).

&gt; Are you going to say "ahhh, it is the main function - I don't need to
&gt; call free() here." ?

Yes, I'd definitely say that. And I would expect a static analyzer to do
the same (either by default, or with some reasonable command line flag).
I have a hard time to view this as a memory leak or a problem at all.

I'm a bit curious on how you and the analyzer reason about the
following three examples.

1.

  int
  main (int argv, char **argv)
  {
    char *p = malloc (4711);
    return 0;
  }

2.

  int
  main (int argv, char **argv)
  {
    char *p = malloc (4711);
    exit (0);
  }

3.

  static void
  foo (void)
  {
    fprintf (stderr, "Failed!\n");
    exit (1);
  }
  
  int
  main (int argv, char **argv)
  {
    char *p = malloc (4711);
    foo ();
    free (p); /* Let's keep the main function itself "clean" */
    return 0;
  }

Is there any good reason to say that that in one of these cases, it's a
memory leak, while in some of the other cases, it is not?

To arrange for proper freeing before program exit in case (3) (or more
complex real programs with that pattern), one would have to add an
atexit call in main and potentially also in lots of other functions
doing allocation. That would really clutter the code, for very little
benefit.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120911082722</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-11 08:27:22-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; To arrange for proper freeing before program exit in case (3) (or more
&gt; complex real programs with that pattern), one would have to add an
&gt; atexit call in main and potentially also in lots of other functions
&gt; doing allocation. That would really clutter the code, for very little
&gt; benefit.

One benefit is that you can run the program under valgrind and it won't
report any memory leaks.  I find this quite useful for self-tests, when
you want to catch memory leaks in a library.

The case is less strong for examples though, however people tend to
cut'n'paste example code and if the original is missing proper calls to
free, so will the copied code, and it may end up in a library or further
down the call path where the memory leak might actually hurt.

/Simon

</body></email><email><emailId>20120911140148</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-11 14:01:48-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Am Monday 10 September 2012 schrieb Niels Möller:
&gt; &gt; Are you going to say "ahhh, it is the main function - I don't need to
&gt; &gt; call free() here." ?
&gt; 
&gt; Yes, I'd definitely say that. And I would expect a static analyzer to do
&gt; the same (either by default, or with some reasonable command line flag).
&gt; I have a hard time to view this as a memory leak or a problem at all.

Then you don't close files, sockets, locks etc. either just because your are 
in main ? IMHO, you should change your habits... ;-)

As Simon Josefsson made clear, the main reason are automated tests for memory 
leaks using valgrind. Something, that a library test suite should not miss.

In nettle/run-tests just replace the line
    "$1" $testflags
by
    valgrind --error-exitcode=1 --leak-check=full --show-reachable=yes "$1" 
$testflags

and 'make check':
...
=====================
36 of 51 tests failed
=====================

But without freeing resources in main(), you now can't easily say, if you have 
a problem in the library or in the testsuite.

BTW, as you see, the static analyzers won't find all of these problems.


&gt; I'm a bit curious on how you and the analyzer reason about the
&gt; following three examples.
...
&gt; Is there any good reason to say that that in one of these cases, it's a
&gt; memory leak, while in some of the other cases, it is not?
&gt; 
&gt; To arrange for proper freeing before program exit in case (3) (or more
&gt; complex real programs with that pattern), one would have to add an
&gt; atexit call in main and potentially also in lots of other functions
&gt; doing allocation. That would really clutter the code, for very little
&gt; benefit.

Yes and No. It really depends on what YOU - as the programmer - want.

For libraries functions I would say, they should never call exit() etc.
You normally have a matching pair of open/close, init/deinit etc. to be able 
to control resource freeing.

For applications, programmers normally spend some afford to at least be able 
to free all resources right before (non-error) exit(). To have at least some 
test-cases to check for resource leaks. Especially long-running apps need 
something like that.

If you decide, that 'emergency exits' on fatal errors doesn't have to free all 
resources, that is perfectly fine. And I know of none project that doesn't 
handle it in that practical way. Except libraries.

BTW, using the clang static analyzer is easy and straight forward.
- cd into nettle
- make clean
- scan-build ./configure
- scan-build make
scan-build: 3 bugs found.
scan-build: Run 'scan-view /tmp/scan-build-2012-09-11-1' to examine bug 
reports.
- scan-view /tmp/scan-build-2012-09-11-1

Of course, there might be some false positives, but clang 3.1.1 does a pretty 
good job.

There is also cppcheck, another static analyzer. It may find other things than 
clang.
- cd into nettle
- cppcheck --enable=all .

e.g.:
[testsuite/yarrow-test.c:141]: (warning) %d in format string (no. 1) requires 
a signed integer given in the argument list.
[testsuite/yarrow-test.c:163]: (warning) %d in format string (no. 1) requires 
a signed integer given in the argument list.
[testsuite/yarrow-test.c:168]: (warning) %d in format string (no. 1) requires 
a signed integer given in the argument list.
[testsuite/yarrow-test.c:202]: (warning) %d in format string (no. 1) requires 
a signed integer given in the argument list.
[testsuite/yarrow-test.c:220]: (error) Resource leak: input

Happy bug hunting ;-)

Regards, Tim

</body></email><email><emailId>20120912072716</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-12 07:27:16-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; Then you don't close files, sockets, locks etc. either just because your are 
&gt; in main ? IMHO, you should change your habits... ;-)

At some point, I choose to trust that the operating system and C library
does its job. E.g, if I set the close-on-exec flag on some file
descriptors, I don't try to close them explicitly between fork and exec.
And "close-at-exit" seems like a more basic feature of the system.

Then I'm aware that for output files, one ought to close them and check
the return value. In particular if using FILE, since it's bad if closing
fails silently due to full disks at the time buffered data is written
out. But I guess one can't close the C library stdout; there, fflush is
the best one can do.

&gt; As Simon Josefsson made clear, the main reason are automated tests for memory 
&gt; leaks using valgrind. Something, that a library test suite should not miss.
&gt;
&gt; In nettle/run-tests just replace the line
&gt;     "$1" $testflags
&gt; by
&gt;     valgrind --error-exitcode=1 --leak-check=full --show-reachable=yes "$1" 
&gt; $testflags
&gt;
&gt; and 'make check':
&gt; ...
&gt; =====================
&gt; 36 of 51 tests failed
&gt; =====================

I see. So from this perspective, it's desirable that the code path
leading to exit(EXIT_SUCCESS) frees all allocated storage. While it
doesn't matter for failure exits.

And one ought to run the tests both with and without valgrind, to get
proper testing also for testscases where programs are expected to fail
(and I guess one could also make careful use of the value of the exit
code, not jsut chek thhat it's non-zero).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120912214052</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-12 21:40:52-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; As Simon Josefsson made clear, the main reason are automated tests for memory 
&gt; leaks using valgrind. Something, that a library test suite should not miss.
...
&gt; But without freeing resources in main(), you now can't easily say, if
&gt; you have a problem in the library or in the testsuite.

However, as far as I recall, the Nettle library does not contain any
calls to malloc or other memory allocating functions.  So I don't think
there could be any memory leaks from the library?

If it is a huge effort to release memory from the testsuite, it may not
be worth it.  But if it is a small effort, and it leads to being able to
run all the testsuite under valgrind without any warnings, I would
support doing it.

/Simon

</body></email><email><emailId>20120913075610</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-13 07:56:10-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; However, as far as I recall, the Nettle library does not contain any
&gt; calls to malloc or other memory allocating functions.  So I don't think
&gt; there could be any memory leaks from the library?

The publickey functions which use gmp allocate memory for the bignums
(unfortunately). There may even be some leaks there in the form of
missing mpz_clear, so testing for memory leaks would be useful. The
functions using nettle_buffer (mainly sexp_format) may allocate,
depending on how the buffer is initialized.

&gt; But if it is a small effort, and it leads to being able to
&gt; run all the testsuite under valgrind without any warnings, I would
&gt; support doing it.

I don't think it's a big deal to get the testsuite to deallocate
storage. Not a very high priority for me, though.

I think we should also modify the use of $EMULATOR to make it easier to
run with valgrind (mainly, remove quoting when it's expanded for the
shell), and perhaps rename it to TESTS_ENVIRONMENT for consistency with
projects using automake.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120913112753</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-13 11:27:53-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

&gt; If it is a huge effort to release memory from the testsuite, it may not
&gt; be worth it.  But if it is a small effort, and it leads to being able to
&gt; run all the testsuite under valgrind without any warnings, I would
&gt; support doing it.

Yes, it was some hours of work, but here is a patch that releases all memory 
and now runs fine with valgrind.

There is just changed file outside testsuite/ and examples/ : buffer.c.
nettle_buffer_clear() used to call realloc() with a length of 0 to wipe the 
allocated memory. But at least here it comes back with a valid pointer to one 
allocated byte (as valgrind reports). I use free() after the realloc if the 
returned pointer is not NULL (maybe realloc() should not be called at all !?). 
Niels, please have a look at it.

I did not remove or add any tests, just changed / added / removed some stuff 
from testutils.c and of course within the *-test.c(xx).

Niels, please remove the quotes from "$EMULATOR" in run-tests (my run-tests is 
somehow already in the local repo with some other changes I just can't 
revert).
Than we could use
 EMULATOR="valgrind -q --error-exitcode=1 --leak-check=full --show-
reachable=yes"
to do an automated memory check.

A short overview of the changed files:
#       modified:   buffer.c
#       modified:   examples/rsa-encrypt.c
#       modified:   examples/rsa-keygen.c
#       modified:   testsuite/aes-test.c
#       modified:   testsuite/arcfour-test.c
#       modified:   testsuite/arctwo-test.c
#       modified:   testsuite/bignum-test.c
#       modified:   testsuite/blowfish-test.c
#       modified:   testsuite/camellia-test.c
#       modified:   testsuite/cast128-test.c
#       modified:   testsuite/cbc-test.c
#       modified:   testsuite/ctr-test.c
#       modified:   testsuite/cxx-test.cxx
#       modified:   testsuite/des-test.c
#       modified:   testsuite/des3-test.c
#       modified:   testsuite/gcm-test.c
#       modified:   testsuite/hmac-test.c
#       modified:   testsuite/md2-test.c
#       modified:   testsuite/md4-test.c
#       modified:   testsuite/md5-compat-test.c
#       modified:   testsuite/md5-test.c
#       modified:   testsuite/memxor-test.c
#       modified:   testsuite/random-prime-test.c
#       modified:   testsuite/ripemd160-test.c
#       modified:   testsuite/rsa2sexp-test.c
#       modified:   testsuite/salsa20-test.c
#       modified:   testsuite/serpent-test.c
#       modified:   testsuite/sexp-format-test.c
#       modified:   testsuite/sexp-test.c
#       modified:   testsuite/sexp2rsa-test.c
#       modified:   testsuite/sha1-test.c
#       modified:   testsuite/sha224-test.c
#       modified:   testsuite/sha256-test.c
#       modified:   testsuite/sha384-test.c
#       modified:   testsuite/sha512-test.c
#       modified:   testsuite/testutils.c
#       modified:   testsuite/testutils.h
#       modified:   testsuite/twofish-test.c
#       modified:   testsuite/yarrow-test.c
#       modified:   tools/pkcs1-conv.c

Regards, Tim

["memory-cleanup.diff" (text/x-patch)]

diff --git a/buffer.c b/buffer.c
index 869e6a3..b82ea3c 100644
--- a/buffer.c
+++ b/buffer.c
@@ -85,9 +85,13 @@ void
 nettle_buffer_clear(struct nettle_buffer *buffer)
 {
   if (buffer-&gt;realloc)
-    buffer-&gt;realloc(buffer-&gt;realloc_ctx, buffer-&gt;contents, 0);
+    buffer-&gt;contents = buffer-&gt;realloc(buffer-&gt;realloc_ctx, buffer-&gt;contents, 0);
 
-  buffer-&gt;contents = NULL;
+  if (buffer-&gt;contents)
+    {
+      free(buffer-&gt;contents);
+      buffer-&gt;contents = NULL;
+    }
   buffer-&gt;alloc = 0;
   buffer-&gt;size = 0;
 }
diff --git a/examples/rsa-encrypt.c b/examples/rsa-encrypt.c
index 70d1503..ca1a8cd 100644
--- a/examples/rsa-encrypt.c
+++ b/examples/rsa-encrypt.c
@@ -253,7 +253,9 @@ main(int argc, char **argv)
     }
 
   write_bignum(stdout, x);
-  
+
+  mpz_clear(x);
+
   if (!process_file(&amp;ctx,
 		    stdin, stdout))
     return EXIT_FAILURE;
diff --git a/examples/rsa-keygen.c b/examples/rsa-keygen.c
index 0ca39b4..165e6f4 100644
--- a/examples/rsa-keygen.c
+++ b/examples/rsa-keygen.c
@@ -160,5 +160,12 @@ main(int argc, char **argv)
       return EXIT_FAILURE;
     }
 
+  nettle_buffer_clear(&amp;pub_buffer);
+  nettle_buffer_clear(&amp;priv_buffer);
+  rsa_private_key_clear(&amp;priv);
+  rsa_public_key_clear(&amp;pub);
+  free(pub_name);
+
+
   return EXIT_SUCCESS;
 }
diff --git a/testsuite/aes-test.c b/testsuite/aes-test.c
index 87be806..aa9bf59 100644
--- a/testsuite/aes-test.c
+++ b/testsuite/aes-test.c
@@ -2,10 +2,16 @@
 #include "aes.h"
 
 static void
-test_invert(unsigned key_length, const uint8_t *key,
-	    unsigned length, const uint8_t *cleartext,
-	    const uint8_t *ciphertext)
+test_invert(const uint8_t *key_hex,
+	    const uint8_t *cleartext_hex,
+	    const uint8_t *ciphertext_hex)
 {
+  unsigned key_length = decode_hex_length(key_hex);
+  const uint8_t *key = decode_hex_dup(key_hex);
+  unsigned length = decode_hex_length(cleartext_hex);
+  const uint8_t *cleartext = decode_hex_dup(cleartext_hex);
+  const uint8_t *ciphertext = decode_hex_dup(ciphertext_hex);
+
   struct aes_ctx encrypt;
   struct aes_ctx decrypt;
   uint8_t *data = xalloc(length);
@@ -39,61 +45,65 @@ test_invert(unsigned key_length, const uint8_t *key,
       fprintf(stderr, "\n");
       FAIL();
     }
+
   free (data);
+  free((void *)ciphertext);
+  free((void *)cleartext);
+  free((void *)key);
 }
 
 int
 test_main(void)
 {
   /* 128 bit keys */
-  test_cipher(&amp;nettle_aes128, 
-	      HL("0001020305060708 0A0B0C0D0F101112"),
-	      HL("506812A45F08C889 B97F5980038B8359"),
-	      H("D8F532538289EF7D 06B506A4FD5BE9C9"));
+  test_cipher(&amp;nettle_aes128,
+	      "0001020305060708 0A0B0C0D0F101112",
+	      "506812A45F08C889 B97F5980038B8359",
+	      "D8F532538289EF7D 06B506A4FD5BE9C9");
   
   test_cipher(&amp;nettle_aes128, 
-	      HL("14151617191A1B1C 1E1F202123242526"),
-	      HL("5C6D71CA30DE8B8B 00549984D2EC7D4B"),
-	      H("59AB30F4D4EE6E4F F9907EF65B1FB68C"));
+	      "14151617191A1B1C 1E1F202123242526",
+	      "5C6D71CA30DE8B8B 00549984D2EC7D4B",
+	      "59AB30F4D4EE6E4F F9907EF65B1FB68C");
 
   test_cipher(&amp;nettle_aes128, 
-	      HL("28292A2B2D2E2F30 323334353738393A"),
-	      HL("53F3F4C64F8616E4 E7C56199F48F21F6"),
-	      H("BF1ED2FCB2AF3FD4 1443B56D85025CB1"));
+	      "28292A2B2D2E2F30 323334353738393A",
+	      "53F3F4C64F8616E4 E7C56199F48F21F6",
+	      "BF1ED2FCB2AF3FD4 1443B56D85025CB1");
   
   test_cipher(&amp;nettle_aes128, 
-	      HL("A0A1A2A3A5A6A7A8 AAABACADAFB0B1B2"),
-	      HL("F5F4F7F684878689 A6A7A0A1D2CDCCCF"),
-	      H("CE52AF650D088CA5 59425223F4D32694"));
+	      "A0A1A2A3A5A6A7A8 AAABACADAFB0B1B2",
+	      "F5F4F7F684878689 A6A7A0A1D2CDCCCF",
+	      "CE52AF650D088CA5 59425223F4D32694");
 
   /* 192 bit keys */
   
   test_cipher(&amp;nettle_aes192, 
-	      HL("0001020305060708 0A0B0C0D0F101112"
-		"14151617191A1B1C"),
-	      HL("2D33EEF2C0430A8A 9EBF45E809C40BB6"),
-	      H("DFF4945E0336DF4C 1C56BC700EFF837F"));
+	      "0001020305060708 0A0B0C0D0F101112"
+		"14151617191A1B1C",
+	      "2D33EEF2C0430A8A 9EBF45E809C40BB6",
+	      "DFF4945E0336DF4C 1C56BC700EFF837F");
 
   /* 256 bit keys */
   
   test_cipher(&amp;nettle_aes256,
-	      HL("0001020305060708 0A0B0C0D0F101112"
-		"14151617191A1B1C 1E1F202123242526"),
-	      HL("834EADFCCAC7E1B30664B1ABA44815AB"),
-	      H("1946DABF6A03A2A2 C3D0B05080AED6FC"));
+	      "0001020305060708 0A0B0C0D0F101112"
+		"14151617191A1B1C 1E1F202123242526",
+	      "834EADFCCAC7E1B30664B1ABA44815AB",
+	      "1946DABF6A03A2A2 C3D0B05080AED6FC");
 
   
   /* This test case has been problematic with the CBC test case */
   test_cipher(&amp;nettle_aes256,
-	      HL("8d ae 93 ff fc 78 c9 44"
+	      "8d ae 93 ff fc 78 c9 44"
 		"2a bd 0c 1e 68 bc a6 c7"
 		"05 c7 84 e3 5a a9 11 8b"
-		"d3 16 aa 54 9b 44 08 9e"),
-	      HL("a5 ce 55 d4 21 15 a1 c6 4a a4 0c b2 ca a6 d1 37"),
+		"d3 16 aa 54 9b 44 08 9e",
+	      "a5 ce 55 d4 21 15 a1 c6 4a a4 0c b2 ca a6 d1 37",
 	      /* In the cbc test, I once got the bad value
 	       *   "b2 a0 6c d2 2f df 7d 2c  26 d2 42 88 8f 20 74 a2" */
-	      H("1f 94 fc 85 f2 36 21 06"
-		"4a ea e3 c9 cc 38 01 0e"));
+	      "1f 94 fc 85 f2 36 21 06"
+		"4a ea e3 c9 cc 38 01 0e");
   
   /* From draft NIST spec on AES modes.
    *
@@ -102,54 +112,54 @@ test_main(void)
    */
 
   test_cipher(&amp;nettle_aes128,
-	      HL("2b7e151628aed2a6abf7158809cf4f3c"),
-	      HL("6bc1bee22e409f96e93d7e117393172a"
+	      "2b7e151628aed2a6abf7158809cf4f3c",
+	      "6bc1bee22e409f96e93d7e117393172a"
 		"ae2d8a571e03ac9c9eb76fac45af8e51"
 		"30c81c46a35ce411e5fbc1191a0a52ef"
-		"f69f2445df4f9b17ad2b417be66c3710"),
-	      H("3ad77bb40d7a3660a89ecaf32466ef97"
+		"f69f2445df4f9b17ad2b417be66c3710",
+	      "3ad77bb40d7a3660a89ecaf32466ef97"
 		"f5d3d58503b9699de785895a96fdbaaf"
 		"43b1cd7f598ece23881b00e3ed030688"
-		"7b0c785e27e8ad3f8223207104725dd4"));
+		"7b0c785e27e8ad3f8223207104725dd4");
 
   /* F.1.3 ECB-AES192-Encrypt */
 
   test_cipher(&amp;nettle_aes192,
-	      HL("8e73b0f7da0e6452c810f32b809079e5 62f8ead2522c6b7b"),
-	      HL("6bc1bee22e409f96e93d7e117393172a"
+	      "8e73b0f7da0e6452c810f32b809079e5 62f8ead2522c6b7b",
+	      "6bc1bee22e409f96e93d7e117393172a"
 		"ae2d8a571e03ac9c9eb76fac45af8e51"
 		"30c81c46a35ce411e5fbc1191a0a52ef"
-		"f69f2445df4f9b17ad2b417be66c3710"),
-	      H("bd334f1d6e45f25ff712a214571fa5cc"
+		"f69f2445df4f9b17ad2b417be66c3710",
+	      "bd334f1d6e45f25ff712a214571fa5cc"
 		"974104846d0ad3ad7734ecb3ecee4eef"
 		"ef7afd2270e2e60adce0ba2face6444e"
-		"9a4b41ba738d6c72fb16691603c18e0e"));
+		"9a4b41ba738d6c72fb16691603c18e0e");
 
   /* F.1.5 ECB-AES256-Encrypt */
   test_cipher(&amp;nettle_aes256,
-	      HL("603deb1015ca71be2b73aef0857d7781"
-		"1f352c073b6108d72d9810a30914dff4"),
-	      HL("6bc1bee22e409f96e93d7e117393172a"
+	      "603deb1015ca71be2b73aef0857d7781"
+		"1f352c073b6108d72d9810a30914dff4",
+	      "6bc1bee22e409f96e93d7e117393172a"
 		"ae2d8a571e03ac9c9eb76fac45af8e51" 
 		"30c81c46a35ce411e5fbc1191a0a52ef"
-		"f69f2445df4f9b17ad2b417be66c3710"),
-	      H("f3eed1bdb5d2a03c064b5a7e3db181f8"
+		"f69f2445df4f9b17ad2b417be66c3710",
+	      "f3eed1bdb5d2a03c064b5a7e3db181f8"
 		"591ccb10d410ed26dc5ba74a31362870"
 		"b6ed21b99ca6f4f9f153e7b1beafed1d"
-		"23304b7a39f9f3ff067d8d8f9e24ecc7"));
+		"23304b7a39f9f3ff067d8d8f9e24ecc7");
 
   /* Test aes_invert_key with src != dst */
-  test_invert(HL("0001020305060708 0A0B0C0D0F101112"),
-	      HL("506812A45F08C889 B97F5980038B8359"),
-	      H("D8F532538289EF7D 06B506A4FD5BE9C9"));
-  test_invert(HL("0001020305060708 0A0B0C0D0F101112"
-		"14151617191A1B1C"),
-	      HL("2D33EEF2C0430A8A 9EBF45E809C40BB6"),
-	      H("DFF4945E0336DF4C 1C56BC700EFF837F"));
-  test_invert(HL("0001020305060708 0A0B0C0D0F101112"
-		"14151617191A1B1C 1E1F202123242526"),
-	      HL("834EADFCCAC7E1B30664B1ABA44815AB"),
-	      H("1946DABF6A03A2A2 C3D0B05080AED6FC"));
+  test_invert("0001020305060708 0A0B0C0D0F101112",
+	      "506812A45F08C889 B97F5980038B8359",
+	      "D8F532538289EF7D 06B506A4FD5BE9C9");
+  test_invert("0001020305060708 0A0B0C0D0F101112"
+		"14151617191A1B1C",
+	      "2D33EEF2C0430A8A 9EBF45E809C40BB6",
+	      "DFF4945E0336DF4C 1C56BC700EFF837F");
+  test_invert("0001020305060708 0A0B0C0D0F101112"
+		"14151617191A1B1C 1E1F202123242526",
+	      "834EADFCCAC7E1B30664B1ABA44815AB",
+	      "1946DABF6A03A2A2 C3D0B05080AED6FC");
 
   SUCCESS();
 }
diff --git a/testsuite/arcfour-test.c b/testsuite/arcfour-test.c
index 6027c54..99a42bb 100644
--- a/testsuite/arcfour-test.c
+++ b/testsuite/arcfour-test.c
@@ -5,16 +5,16 @@ int
 test_main(void)
 {
   test_cipher_stream(&amp;nettle_arcfour128,
-		     HL("01234567 89ABCDEF 00000000 00000000"),
-		     HL("01234567 89ABCDEF"),
-		     H("69723659 1B5242B1"));
+		     "01234567 89ABCDEF 00000000 00000000",
+		     "01234567 89ABCDEF",
+		     "69723659 1B5242B1");
 
   /* More data. This ensures that we get some collisions between the S
      accesses at index i,j and the access at si + sj. I.e. the cases
      where the ordering of loads and stores matter. */
   test_cipher_stream(&amp;nettle_arcfour128,
-		     HL("aaaaaaaa bbbbbbbb cccccccc dddddddd"),
-		     HL("00000000 00000000 00000000 00000000"
+		     "aaaaaaaa bbbbbbbb cccccccc dddddddd",
+		     "00000000 00000000 00000000 00000000"
 			"00000000 00000000 00000000 00000000"
 			"00000000 00000000 00000000 00000000"
 			"00000000 00000000 00000000 00000000"
@@ -52,8 +52,8 @@ test_main(void)
 			"00000000 00000000 00000000 00000000"
 			"00000000 00000000 00000000 00000000"
 			"00000000 00000000 00000000 00000000"
-			"00000000 00000000 00000000 00000000"),
-		     H("a2b35dc7 bf95ae1e 1c432d15 f4fb8c1c"
+			"00000000 00000000 00000000 00000000",
+		     "a2b35dc7 bf95ae1e 1c432d15 f4fb8c1c"
 		       "f264e1d0 bd090831 6caa7d17 5401ae67"
 		       "3cfbd140 fd3dee42 1012d674 2fb69fa3"
 		       "6522631e bb3d4703 535de1ce 4a81ddce"
@@ -91,7 +91,7 @@ test_main(void)
 		       "613e3067 92cada3e 0e07f599 2f4794f3"
 		       "af01f15a 491732fb 22aa09a3 d2e1e408"
 		       "fe94bdb4 993c68b1 1bb79eb1 bb7ec446"
-		       "760ef7bf 2caa8713 479760e5 a6e143cd"));
+		       "760ef7bf 2caa8713 479760e5 a6e143cd");
   
   SUCCESS();
 }
diff --git a/testsuite/arctwo-test.c b/testsuite/arctwo-test.c
index 4fedfad..cf52d1b 100644
--- a/testsuite/arctwo-test.c
+++ b/testsuite/arctwo-test.c
@@ -25,12 +25,16 @@
 /* For tests with obscure values of ebk. */
 static void
 test_arctwo(unsigned ekb,
-	    unsigned key_length,
-	    const uint8_t *key,
-	    unsigned length,
-	    const uint8_t *cleartext,
-	    const uint8_t *ciphertext)
+	    const uint8_t *key_hex,
+	    const uint8_t *cleartext_hex,
+	    const uint8_t *ciphertext_hex)
 {
+  unsigned key_length = decode_hex_length(key_hex);
+  const uint8_t *key = decode_hex_dup(key_hex);
+  unsigned length = decode_hex_length(cleartext_hex);
+  const uint8_t *cleartext = decode_hex_dup(cleartext_hex);
+  const uint8_t *ciphertext = decode_hex_dup(ciphertext_hex);
+
   struct arctwo_ctx ctx;
   uint8_t *data = xalloc(length);
 
@@ -46,6 +50,9 @@ test_arctwo(unsigned ekb,
     FAIL();
 
   free(data);
+  free((void *)ciphertext);
+  free((void *)cleartext);
+  free((void *)key);
 }
 
 int
@@ -53,63 +60,63 @@ test_main(void)
 {
   /* Test vectors from Peter Gutmann's paper. */
   test_cipher(&amp;nettle_arctwo_gutmann128,
-	      HL("00000000 00000000 00000000 00000000"),
-	      HL("00000000 00000000"),
-	      H ("1c198a83 8df028b7"));
+	      "00000000 00000000 00000000 00000000",
+	      "00000000 00000000",
+	      "1c198a83 8df028b7");
 
   test_cipher(&amp;nettle_arctwo_gutmann128,
-	      HL("00010203 04050607 08090a0b 0c0d0e0f"),
-	      HL("00000000 00000000"),
-	      H ("50dc0162 bd757f31"));
+	      "00010203 04050607 08090a0b 0c0d0e0f",
+	      "00000000 00000000",
+	      "50dc0162 bd757f31");
 
   /* This one was checked against libmcrypt's RFC2268. */
   test_cipher(&amp;nettle_arctwo_gutmann128,
-	      HL("30000000 00000000 00000000 00000000"),
-	      HL("10000000 00000000"),
-	      H ("8fd10389 336bf95e"));
+	      "30000000 00000000 00000000 00000000",
+	      "10000000 00000000",
+	      "8fd10389 336bf95e");
 
   /* Test vectors from RFC 2268. */
   test_cipher(&amp;nettle_arctwo64,
-	      HL("ffffffff ffffffff"),
-	      HL("ffffffff ffffffff"),
-	      H ("278b27e4 2e2f0d49"));
+	      "ffffffff ffffffff",
+	      "ffffffff ffffffff",
+	      "278b27e4 2e2f0d49");
 
   test_cipher(&amp;nettle_arctwo64,
-	      HL("30000000 00000000"),
-	      HL("10000000 00000001"),
-	      H ("30649edf 9be7d2c2"));
+	      "30000000 00000000",
+	      "10000000 00000001",
+	      "30649edf 9be7d2c2");
 
   test_cipher(&amp;nettle_arctwo128,
-	      HL("88bca90e 90875a7f 0f79c384 627bafb2"),
-	      HL("00000000 00000000"),
-	      H ("2269552a b0f85ca6"));
+	      "88bca90e 90875a7f 0f79c384 627bafb2",
+	      "00000000 00000000",
+	      "2269552a b0f85ca6");
 
   /* More obscure tests from RFC 2286 */
   test_arctwo(63,
-	      HL("00000000 00000000"),
-	      HL("00000000 00000000"),
-	      H ("ebb773f9 93278eff"));
+	      "00000000 00000000",
+	      "00000000 00000000",
+	      "ebb773f9 93278eff");
 
   test_arctwo(64,
-	      HL("88"),
-	      HL("00000000 00000000"),
-	      H ("61a8a244 adacccf0"));
+	      "88",
+	      "00000000 00000000",
+	      "61a8a244 adacccf0");
 
   test_arctwo(64,
-	      HL("88bca90e 90875a"),
-	      HL("00000000 00000000"),
-	      H ("6ccf4308 974c267f"));
+	      "88bca90e 90875a",
+	      "00000000 00000000",
+	      "6ccf4308 974c267f");
 
   test_arctwo(64,
-	      HL("88bca90e 90875a7f 0f79c384 627bafb2"),
-	      HL("00000000 00000000"),
-	      H ("1a807d27 2bbe5db1"));
+	      "88bca90e 90875a7f 0f79c384 627bafb2",
+	      "00000000 00000000",
+	      "1a807d27 2bbe5db1");
 
   test_arctwo(129,
-	      HL("88bca90e 90875a7f 0f79c384 627bafb2"
-		 "16f80a6f 85920584 c42fceb0 be255daf 1e"),
-	      HL("00000000 00000000"),
-	      H ("5b78d3a4 3dfff1f1"));
+	      "88bca90e 90875a7f 0f79c384 627bafb2"
+		 "16f80a6f 85920584 c42fceb0 be255daf 1e",
+	      "00000000 00000000",
+	      "5b78d3a4 3dfff1f1");
 
   SUCCESS ();
 }
diff --git a/testsuite/bignum-test.c b/testsuite/bignum-test.c
index 84e0483..91afa9e 100644
--- a/testsuite/bignum-test.c
+++ b/testsuite/bignum-test.c
@@ -11,8 +11,10 @@
 #include "bignum.h"
 
 static void
-test_bignum(const char *hex, unsigned length, const uint8_t *base256)
+test_bignum(const char *hex, const uint8_t *base256_hex)
 {
+  unsigned length = decode_hex_length(base256_hex);
+  const uint8_t *base256 = decode_hex_dup(base256_hex);
   mpz_t a;
   mpz_t b;
   uint8_t *buf;
@@ -35,6 +37,7 @@ test_bignum(const char *hex, unsigned length, const uint8_t \
*base256)  
   mpz_clear(a); mpz_clear(b);
   free(buf);
+  free((void *)base256);
 }
 
 static void
@@ -78,17 +81,17 @@ test_main(void)
   test_size(- 0x8000, 2); /*   8000 */
   test_size(- 0x8001, 3); /* ff7fff */
 
-  test_bignum("0", HL("00"));
-  test_bignum("010203040506", HL("010203040506"));
-  test_bignum("80010203040506", HL("0080010203040506"));
-
-  test_bignum(   "-1", HL(    "ff"));
-  test_bignum(  "-7f", HL(    "81"));
-  test_bignum(  "-80", HL(    "80"));
-  test_bignum(  "-81", HL(  "ff7f"));
-  test_bignum("-7fff", HL(  "8001"));
-  test_bignum("-8000", HL(  "8000"));
-  test_bignum("-8001", HL("ff7fff"));
+  test_bignum("0", "00");
+  test_bignum("010203040506", "010203040506");
+  test_bignum("80010203040506", "0080010203040506");
+
+  test_bignum(   "-1",     "ff");
+  test_bignum(  "-7f",     "81");
+  test_bignum(  "-80",     "80");
+  test_bignum(  "-81",   "ff7f");
+  test_bignum("-7fff",   "8001");
+  test_bignum("-8000",   "8000");
+  test_bignum("-8001", "ff7fff");
   
   SUCCESS();
 #else /* !HAVE_LIBGMP */
diff --git a/testsuite/blowfish-test.c b/testsuite/blowfish-test.c
index c4311bb..560f914 100644
--- a/testsuite/blowfish-test.c
+++ b/testsuite/blowfish-test.c
@@ -2,14 +2,22 @@
 #include "nettle-internal.h"
 #include "blowfish.h"
 
+#define STR_TO_HEX(a) encode_hex_dup(a, strlen(a))
+
 int
 test_main(void)
 {
+  const uint8_t *key_hex = STR_TO_HEX("abcdefghijklmnopqrstuvwxyz");
+  const uint8_t *cleartext_hex = STR_TO_HEX("BLOWFISH");
+
   /* 208 bit key. Test from GNUPG. */
   test_cipher(&amp;nettle_blowfish128,
-	      26, "abcdefghijklmnopqrstuvwxyz",
-	      BLOWFISH_BLOCK_SIZE, "BLOWFISH",
-	      H("32 4E D0 FE F4 13 A2 03"));
+	      key_hex,
+	      cleartext_hex,
+	      "32 4E D0 FE F4 13 A2 03");
+
+  free((void *)cleartext_hex);
+  free((void *)key_hex);
 
   SUCCESS();
 }
diff --git a/testsuite/camellia-test.c b/testsuite/camellia-test.c
index 4f1d118..8e245a4 100644
--- a/testsuite/camellia-test.c
+++ b/testsuite/camellia-test.c
@@ -2,10 +2,16 @@
 #include "camellia.h"
 
 static void
-test_invert(unsigned key_length, const uint8_t *key,
-	    unsigned length, const uint8_t *cleartext,
-	    const uint8_t *ciphertext)
+test_invert(const uint8_t *key_hex,
+	    const uint8_t *cleartext_hex,
+	    const uint8_t *ciphertext_hex)
 {
+  unsigned key_length = decode_hex_length(key_hex);
+  const uint8_t *key = decode_hex_dup(key_hex);
+  unsigned length = decode_hex_length(cleartext_hex);
+  const uint8_t *cleartext = decode_hex_dup(cleartext_hex);
+  const uint8_t *ciphertext = decode_hex_dup(ciphertext_hex);
+
   struct camellia_ctx encrypt;
   struct camellia_ctx decrypt;
   uint8_t *data = xalloc(length);
@@ -39,7 +45,11 @@ test_invert(unsigned key_length, const uint8_t *key,
       fprintf(stderr, "\n");
       FAIL();
     }
+
   free (data);
+  free((void *)ciphertext);
+  free((void *)cleartext);
+  free((void *)key);
 }
 
 int
@@ -48,37 +58,37 @@ test_main(void)
   /* Test vectors from RFC 3713 */
   /* 128 bit keys */
   test_cipher(&amp;nettle_camellia128,
-	      HL("01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"),
-	      HL("01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"),
-	      H("67 67 31 38 54 96 69 73 08 57 06 56 48 ea be 43"));
+	      "01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10",
+	      "01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10",
+	      "67 67 31 38 54 96 69 73 08 57 06 56 48 ea be 43");
 
   /* 192 bit keys */
   test_cipher(&amp;nettle_camellia192, 
-	      HL("01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"
-                 "00 11 22 33 44 55 66 77"),
-	      HL("01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"),
-	      H("b4 99 34 01 b3 e9 96 f8 4e e5 ce e7 d7 9b 09 b9"));
+	      "01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"
+                 "00 11 22 33 44 55 66 77",
+	      "01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10",
+	      "b4 99 34 01 b3 e9 96 f8 4e e5 ce e7 d7 9b 09 b9");
 
   /* 256 bit keys */
   test_cipher(&amp;nettle_camellia256, 
-	      HL("01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"
-                 "00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff"),
-	      HL("01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"),
-	      H("9a cc 23 7d ff 16 d7 6c 20 ef 7c 91 9e 3a 75 09"));
+	      "01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"
+                 "00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff",
+	      "01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10",
+	      "9a cc 23 7d ff 16 d7 6c 20 ef 7c 91 9e 3a 75 09");
 
   /* Test camellia_invert_key with src != dst */
-  test_invert(HL("01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"),
-	      HL("01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"),
-	      H("67 67 31 38 54 96 69 73 08 57 06 56 48 ea be 43"));
+  test_invert("01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10",
+	      "01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10",
+	      "67 67 31 38 54 96 69 73 08 57 06 56 48 ea be 43");
   
-  test_invert(HL("01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"
-                 "00 11 22 33 44 55 66 77"),
-	      HL("01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"),
-	      H("b4 99 34 01 b3 e9 96 f8 4e e5 ce e7 d7 9b 09 b9"));
+  test_invert("01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"
+                 "00 11 22 33 44 55 66 77",
+	      "01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10",
+	      "b4 99 34 01 b3 e9 96 f8 4e e5 ce e7 d7 9b 09 b9");
 
-  test_invert(HL("01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"
-                 "00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff"),
-	      HL("01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"),
-	      H("9a cc 23 7d ff 16 d7 6c 20 ef 7c 91 9e 3a 75 09"));
+  test_invert("01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10"
+                 "00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff",
+	      "01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10",
+	      "9a cc 23 7d ff 16 d7 6c 20 ef 7c 91 9e 3a 75 09");
   SUCCESS();
 }
diff --git a/testsuite/cast128-test.c b/testsuite/cast128-test.c
index e4b7830..e9d8fae 100644
--- a/testsuite/cast128-test.c
+++ b/testsuite/cast128-test.c
@@ -9,22 +9,22 @@ test_main(void)
 
   /* 128 bit key */
   test_cipher(&amp;nettle_cast128,
-	      HL("01 23 45 67 12 34 56 78"
-		 "23 45 67 89 34 56 78 9A"),
-	      HL("01 23 45 67 89 AB CD EF"),
-	      H("23 8B 4F E5 84 7E 44 B2"));
+	      "01 23 45 67 12 34 56 78"
+		 "23 45 67 89 34 56 78 9A",
+	      "01 23 45 67 89 AB CD EF",
+	      "23 8B 4F E5 84 7E 44 B2");
   
   /* 80 bit key */
   test_cipher(&amp;nettle_cast128,
-	      HL("01 23 45 67 12 34 56 78 23 45"),
-	      HL("01 23 45 67 89 AB CD EF"),
-	      H("EB 6A 71 1A 2C 02 27 1B"));
+	      "01 23 45 67 12 34 56 78 23 45",
+	      "01 23 45 67 89 AB CD EF",
+	      "EB 6A 71 1A 2C 02 27 1B");
 
   /* 40 bit key */
   test_cipher(&amp;nettle_cast128,
-	      HL("01 23 45 67 12"),
-	      HL("01 23 45 67 89 AB CD EF"),
-	      H("7A C8 16 D1 6E 9B 30 2E"));
+	      "01 23 45 67 12",
+	      "01 23 45 67 89 AB CD EF",
+	      "7A C8 16 D1 6E 9B 30 2E");
 
   SUCCESS();
 }
diff --git a/testsuite/cbc-test.c b/testsuite/cbc-test.c
index b7bd2dd..d877775 100644
--- a/testsuite/cbc-test.c
+++ b/testsuite/cbc-test.c
@@ -68,13 +68,19 @@ test_cbc_bulk(void)
 
   if (!MEMEQ(CBC_BULK_DATA, clear, cipher))
     FAIL();
+
+  free((void *)end_iv);
+  free((void *)start_iv);
+  free((void *)key);
 }
 
 int
 test_main(void)
 {
   static const uint8_t msg[2 * AES_BLOCK_SIZE] = "Listen, I'll say this only once!";
-  
+
+  const uint8_t *msg_hex = encode_hex_dup(msg, sizeof(msg));
+
   /* Intermediate values:
    *   iv XOR first message block:
    *       "a5 ce 55 d4 21 15 a1 c6 4a a4 0c b2 ca a6 d1 37"
@@ -87,16 +93,18 @@ test_main(void)
    */
 
   test_cipher_cbc(&amp;nettle_aes256,
-		  HL("8d ae 93 ff fc 78 c9 44"
+		  "8d ae 93 ff fc 78 c9 44"
 		     "2a bd 0c 1e 68 bc a6 c7"
 		     "05 c7 84 e3 5a a9 11 8b"
-		     "d3 16 aa 54 9b 44 08 9e"),
-		  2 * AES_BLOCK_SIZE, msg,
-		  H("1f 94 fc 85 f2 36 21 06"
+		     "d3 16 aa 54 9b 44 08 9e",
+		  msg_hex,
+		  "1f 94 fc 85 f2 36 21 06"
 		    "4a ea e3 c9 cc 38 01 0e"
 		    "7b f6 5f c5 02 59 2e 71"
-		    "af bf 34 87 c0 36 2a 16"),
-		  H("e9 a7 26 a0 44 7b 8d e6  03 83 60 de ea d5 b0 4e"));
+		    "af bf 34 87 c0 36 2a 16",
+		  "e9 a7 26 a0 44 7b 8d e6  03 83 60 de ea d5 b0 4e");
+
+  free((void *)msg_hex);
 
   /* From NIST spec 800-38a on AES modes.
    *
@@ -112,16 +120,16 @@ test_main(void)
    *   8521f2fd3c8eef2cdc3da7e5c44ea206 
    */
   test_cipher_cbc(&amp;nettle_aes128,
-		  HL("2b7e151628aed2a6abf7158809cf4f3c"),
-		  HL("6bc1bee22e409f96e93d7e117393172a"
+		  "2b7e151628aed2a6abf7158809cf4f3c",
+		  "6bc1bee22e409f96e93d7e117393172a"
 		     "ae2d8a571e03ac9c9eb76fac45af8e51"
 		     "30c81c46a35ce411e5fbc1191a0a52ef"
-		     "f69f2445df4f9b17ad2b417be66c3710"),
-		  H("7649abac8119b246cee98e9b12e9197d"
+		     "f69f2445df4f9b17ad2b417be66c3710",
+		  "7649abac8119b246cee98e9b12e9197d"
 		    "5086cb9b507219ee95db113a917678b2"
 		    "73bed6b8e3c1743b7116e69e22229516"
-		    "3ff1caa1681fac09120eca307586e1a7"),
-		  H("000102030405060708090a0b0c0d0e0f"));
+		    "3ff1caa1681fac09120eca307586e1a7",
+		  "000102030405060708090a0b0c0d0e0f");
   
   /* F.2.3 CBC-AES192.Encrypt */
   
@@ -134,17 +142,17 @@ test_main(void)
    */
 
   test_cipher_cbc(&amp;nettle_aes192,
-		  HL("8e73b0f7da0e6452c810f32b809079e5"
-		     "62f8ead2522c6b7b"),
-		  HL("6bc1bee22e409f96e93d7e117393172a"
+		  "8e73b0f7da0e6452c810f32b809079e5"
+		     "62f8ead2522c6b7b",
+		  "6bc1bee22e409f96e93d7e117393172a"
 		     "ae2d8a571e03ac9c9eb76fac45af8e51"
 		     "30c81c46a35ce411e5fbc1191a0a52ef"
-		     "f69f2445df4f9b17ad2b417be66c3710"),
-		  H("4f021db243bc633d7178183a9fa071e8"
+		     "f69f2445df4f9b17ad2b417be66c3710",
+		  "4f021db243bc633d7178183a9fa071e8"
 		    "b4d9ada9ad7dedf4e5e738763f69145a"
 		    "571b242012fb7ae07fa9baac3df102e0"
-		    "08b0e27988598881d920a9e64f5615cd"),
-		  H("000102030405060708090a0b0c0d0e0f"));
+		    "08b0e27988598881d920a9e64f5615cd",
+		  "000102030405060708090a0b0c0d0e0f");
    
   /* F.2.5 CBC-AES256.Encrypt */
 
@@ -157,17 +165,17 @@ test_main(void)
    */
 
   test_cipher_cbc(&amp;nettle_aes256,
-		  HL("603deb1015ca71be2b73aef0857d7781"
-		     "1f352c073b6108d72d9810a30914dff4"),
-		  HL("6bc1bee22e409f96e93d7e117393172a"
+		  "603deb1015ca71be2b73aef0857d7781"
+		     "1f352c073b6108d72d9810a30914dff4",
+		  "6bc1bee22e409f96e93d7e117393172a"
 		     "ae2d8a571e03ac9c9eb76fac45af8e51"
 		     "30c81c46a35ce411e5fbc1191a0a52ef"
-		     "f69f2445df4f9b17ad2b417be66c3710"),
-		  H("f58c4c04d6e5f1ba779eabfb5f7bfbd6"
+		     "f69f2445df4f9b17ad2b417be66c3710",
+		  "f58c4c04d6e5f1ba779eabfb5f7bfbd6"
 		    "9cfc4e967edb808d679f777bc6702c7d"
 		    "39f23369a9d9bacfa530e26304231461"
-		    "b2eb05e2c39be9fcda6c19078c6a9d1b"),
-		  H("000102030405060708090a0b0c0d0e0f"));
+		    "b2eb05e2c39be9fcda6c19078c6a9d1b",
+		  "000102030405060708090a0b0c0d0e0f");
 
   test_cbc_bulk();
    
diff --git a/testsuite/ctr-test.c b/testsuite/ctr-test.c
index 15c74d5..6b3c3fa 100644
--- a/testsuite/ctr-test.c
+++ b/testsuite/ctr-test.c
@@ -14,43 +14,43 @@ test_main(void)
 
   /* F.5.1  CTR-AES128.Encrypt */
   test_cipher_ctr(&amp;nettle_aes128,
-		  HL("2b7e151628aed2a6abf7158809cf4f3c"),
-		  HL("6bc1bee22e409f96e93d7e117393172a"
+		  "2b7e151628aed2a6abf7158809cf4f3c",
+		  "6bc1bee22e409f96e93d7e117393172a"
 		     "ae2d8a571e03ac9c9eb76fac45af8e51"
 		     "30c81c46a35ce411e5fbc1191a0a52ef"
-		     "f69f2445df4f9b17ad2b417be66c3710"),
-		  H("874d6191b620e3261bef6864990db6ce"
+		     "f69f2445df4f9b17ad2b417be66c3710",
+		  "874d6191b620e3261bef6864990db6ce"
 		    "9806f66b7970fdff8617187bb9fffdff"
 		    "5ae4df3edbd5d35e5b4f09020db03eab"
-		    "1e031dda2fbe03d1792170a0f3009cee"),
-		  H("f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"));
+		    "1e031dda2fbe03d1792170a0f3009cee",
+		  "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff");
 
   /* F.5.3  CTR-AES192.Encrypt */
   test_cipher_ctr(&amp;nettle_aes192,
-		  HL("8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b"),
-		  HL("6bc1bee22e409f96e93d7e117393172a"
+		  "8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b",
+		  "6bc1bee22e409f96e93d7e117393172a"
 		     "ae2d8a571e03ac9c9eb76fac45af8e51"
 		     "30c81c46a35ce411e5fbc1191a0a52ef"
-		     "f69f2445df4f9b17ad2b417be66c3710"),
-		  H("1abc932417521ca24f2b0459fe7e6e0b"
+		     "f69f2445df4f9b17ad2b417be66c3710",
+		  "1abc932417521ca24f2b0459fe7e6e0b"
 		     "090339ec0aa6faefd5ccc2c6f4ce8e94"
 		     "1e36b26bd1ebc670d1bd1d665620abf7"
-		     "4f78a7f6d29809585a97daec58c6b050"),
-		  H("f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"));
+		     "4f78a7f6d29809585a97daec58c6b050",
+		  "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff");
 
   /* F.5.5  CTR-AES256.Encrypt */
   test_cipher_ctr(&amp;nettle_aes256,
-		  HL("603deb1015ca71be2b73aef0857d7781"
-		     "1f352c073b6108d72d9810a30914dff4"),
-		  HL("6bc1bee22e409f96e93d7e117393172a"
+		  "603deb1015ca71be2b73aef0857d7781"
+		     "1f352c073b6108d72d9810a30914dff4",
+		  "6bc1bee22e409f96e93d7e117393172a"
 		     "ae2d8a571e03ac9c9eb76fac45af8e51"
 		     "30c81c46a35ce411e5fbc1191a0a52ef"
-		     "f69f2445df4f9b17ad2b417be66c3710"),
-		  H("601ec313775789a5b7a7f504bbf3d228"
+		     "f69f2445df4f9b17ad2b417be66c3710",
+		  "601ec313775789a5b7a7f504bbf3d228"
 		     "f443e3ca4d62b59aca84e990cacaf5c5"
 		     "2b0930daa23de94ce87017ba2d84988d"
-		     "dfc9c58db67aada613c2dd08457941a6"),
-		  H("f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"));
+		     "dfc9c58db67aada613c2dd08457941a6",
+		  "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff");
 
   SUCCESS();
 }
diff --git a/testsuite/cxx-test.cxx b/testsuite/cxx-test.cxx
index b5635fb..4411956 100644
--- a/testsuite/cxx-test.cxx
+++ b/testsuite/cxx-test.cxx
@@ -10,15 +10,18 @@ test_main(void)
 {
   struct md5_ctx md5;
   uint8_t digest[MD5_DIGEST_SIZE];
+  const uint8_t *result;
 
   md5_init (&amp;md5);
   md5_update (&amp;md5, 14, reinterpret_cast&lt;const uint8_t *&gt; ("message digest"));
   md5_digest (&amp;md5, MD5_DIGEST_SIZE, digest);
 
-  if (!MEMEQH (MD5_DIGEST_SIZE, digest,
-	       "F96B697D7CB7938D 525A2F31AAF161D0"))
+  result = decode_hex_dup("F96B697D7CB7938D 525A2F31AAF161D0");
+  if (!MEMEQ (MD5_DIGEST_SIZE, digest, result))
     FAIL();
 
+  free((void *)result);
+
 #if WITH_PUBLIC_KEY
 
   struct rsa_public_key pub;
diff --git a/testsuite/des-test.c b/testsuite/des-test.c
index 244e5aa..4d1ce64 100644
--- a/testsuite/des-test.c
+++ b/testsuite/des-test.c
@@ -2,12 +2,18 @@
 #include "nettle-internal.h"
 #include "des.h"
 
+#define STR_TO_HEX(a) encode_hex_dup(a, strlen(a))
+
 static void
-test_des(const uint8_t *key, int expected_parity,
-	 unsigned length,
-	 const uint8_t *cleartext,
-	 const uint8_t *ciphertext)
+test_des(const uint8_t *key_hex, int expected_parity,
+	 const uint8_t *cleartext_hex,
+	 const uint8_t *ciphertext_hex)
 {
+  const uint8_t *key = decode_hex_dup(key_hex);
+  unsigned length = decode_hex_length(cleartext_hex);
+  const uint8_t *cleartext = decode_hex_dup(cleartext_hex);
+  const uint8_t *ciphertext = decode_hex_dup(ciphertext_hex);
+
   struct des_ctx ctx;
   uint8_t *data = xalloc(length);
 
@@ -46,77 +52,98 @@ test_des(const uint8_t *key, int expected_parity,
     }
 
   free(data);
+  free((void *)ciphertext);
+  free((void *)cleartext);
+  free((void *)key);
+}
+
+static int
+test_des_check_parity(const uint8_t *key_hex)
+{
+  unsigned length = decode_hex_length(key_hex);
+  const uint8_t *key = decode_hex_dup(key_hex);
+  int rc = des_check_parity(8, key);
+
+  free((void *)key);
+  return rc;
 }
 
 static void
-test_weak(const uint8_t *key)
+test_weak(const uint8_t *key_hex)
 {
   struct des_ctx ctx;
+  const uint8_t *key = decode_hex_dup(key_hex);
 
   if (des_set_key(&amp;ctx, key))
     FAIL();
+
+  free((void *)key);
 }
 
 int
 test_main(void)
 {
+  const uint8_t *cleartext_hex = STR_TO_HEX("Now is t");
+
   /* From Applied Cryptography */
-  test_des(H("01234567 89ABCDEF"), 1,
-	   HL("01234567 89ABCDE7"),
-	   H("C9574425 6A5ED31D"));
+  test_des("01234567 89ABCDEF", 1,
+	   "01234567 89ABCDE7",
+	   "C9574425 6A5ED31D");
 
-  test_des(H("01 01 01 01 01 01 01 80"), 1,
-	   HL("00 00 00 00 00 00 00 00"),
-	   H("9C C6 2D F4 3B 6E ED 74"));
+  test_des("01 01 01 01 01 01 01 80", 1,
+	   "00 00 00 00 00 00 00 00",
+	   "9C C6 2D F4 3B 6E ED 74");
 
-  test_des(H("80 01 01 01 01 01 01 01"), 1,
-	   HL("00 00 00 00 00 00 00 40"),
-	   H("A3 80 E0 2A 6B E5 46 96"));
+  test_des("80 01 01 01 01 01 01 01", 1,
+	   "00 00 00 00 00 00 00 40",
+	   "A3 80 E0 2A 6B E5 46 96");
 
-  test_des(H("08 19 2A 3B 4C 5D 6E 7F"), 1,
-	   HL("00 00 00 00 00 00 00 00"),
-	   H("25 DD AC 3E 96 17 64 67"));
+  test_des("08 19 2A 3B 4C 5D 6E 7F", 1,
+	   "00 00 00 00 00 00 00 00",
+	   "25 DD AC 3E 96 17 64 67");
 
-  test_des(H("01 23 45 67 89 AB CD EF"), 1,
-	   DES_BLOCK_SIZE, "Now is t",
-	   H("3F A4 0E 8A 98 4D 48 15"));
+  test_des("01 23 45 67 89 AB CD EF", 1,
+	   cleartext_hex,
+	   "3F A4 0E 8A 98 4D 48 15");
 
   /* Same key, but with one bad parity bit, */
-  test_des(H("01 23 45 66 89 AB CD EF"), 0,
-	   DES_BLOCK_SIZE, "Now is t",
-	   H("3F A4 0E 8A 98 4D 48 15"));
+  test_des("01 23 45 66 89 AB CD EF", 0,
+	   cleartext_hex,
+	   "3F A4 0E 8A 98 4D 48 15");
 
   /* Parity check */
-  if (des_check_parity(HL("01 01 01 01 01 01 01 00")))
+  if (test_des_check_parity("01 01 01 01 01 01 01 00"))
     FAIL();
 
   /* The four weak keys */
-  test_weak(H("01 01 01 01 01 01 01 01"));  
-  test_weak(H("FE FE FE FE FE FE FE FE"));
-  test_weak(H("1F 1F 1F 1F 0E 0E 0E 0E"));
-  test_weak(H("E0 E0 E0 E0 F1 F1 F1 F1"));
+  test_weak("01 01 01 01 01 01 01 01");  
+  test_weak("FE FE FE FE FE FE FE FE");
+  test_weak("1F 1F 1F 1F 0E 0E 0E 0E");
+  test_weak("E0 E0 E0 E0 F1 F1 F1 F1");
 
   /* Same weak key, but different parity. */
-  test_weak(H("E0 E0 E0 E0 F0 F1 F1 F1"));
+  test_weak("E0 E0 E0 E0 F0 F1 F1 F1");
 
   /* The six pairs of semiweak keys */
-  test_weak(H("01 FE 01 FE 01 FE 01 FE"));
-  test_weak(H("FE 01 FE 01 FE 01 FE 01"));
+  test_weak("01 FE 01 FE 01 FE 01 FE");
+  test_weak("FE 01 FE 01 FE 01 FE 01");
+
+  test_weak("1F E0 1F E0 0E F1 0E F1");
+  test_weak("E0 1F E0 1F F1 0E F1 0E");
 
-  test_weak(H("1F E0 1F E0 0E F1 0E F1"));
-  test_weak(H("E0 1F E0 1F F1 0E F1 0E"));
+  test_weak("01 E0 01 E0 01 F1 01 F1");
+  test_weak("E0 01 E0 01 F1 01 F1 01");
 
-  test_weak(H("01 E0 01 E0 01 F1 01 F1"));
-  test_weak(H("E0 01 E0 01 F1 01 F1 01"));
+  test_weak("1F FE 1F FE 0E FE 0E FE");
+  test_weak("FE 1F FE 1F FE 0E FE 0E");
 
-  test_weak(H("1F FE 1F FE 0E FE 0E FE"));
-  test_weak(H("FE 1F FE 1F FE 0E FE 0E"));
+  test_weak("01 1F 01 1F 01 0E 01 0E");
+  test_weak("1F 01 1F 01 0E 01 0E 01");
 
-  test_weak(H("01 1F 01 1F 01 0E 01 0E"));
-  test_weak(H("1F 01 1F 01 0E 01 0E 01"));
+  test_weak("E0 FE E0 FE F1 FE F1 FE");
+  test_weak("FE E0 FE E0 FE F1 FE F1");
 
-  test_weak(H("E0 FE E0 FE F1 FE F1 FE"));
-  test_weak(H("FE E0 FE E0 FE F1 FE F1"));
+  free((void *)cleartext_hex);
 
   SUCCESS();
 }
diff --git a/testsuite/des3-test.c b/testsuite/des3-test.c
index 678a235..796e776 100644
--- a/testsuite/des3-test.c
+++ b/testsuite/des3-test.c
@@ -2,20 +2,26 @@
 #include "nettle-internal.h"
 #include "des.h"
 
+#define STR_TO_HEX(a) encode_hex_dup(a, strlen(a))
+
 int
 test_main(void)
 {
+  const uint8_t *cleartext_hex = STR_TO_HEX("Now is t");
+
   /* Intermediate values:
    *   After first DES encryption:  "cd ea 2a 20 c2 e0 9e 48"
    *   After second DES decryption: "69 52 6e 95 8b ea 49 bd"
    */
 
   test_cipher(&amp;nettle_des3,
-	      HL("3e 0b 10 b0 5d 49 c2 54"
+	      "3e 0b 10 b0 5d 49 c2 54"
 		 "6b 46 e0 75 8a 91 61 85"
-		 "cb 04 07 d3 20 16 cb a2"),
-	      DES_BLOCK_SIZE, "Now is t",
-	      H("0a 5d b5 2d 85 74 d1 c9"));
+		 "cb 04 07 d3 20 16 cb a2",
+	      cleartext_hex,
+	      "0a 5d b5 2d 85 74 d1 c9");
+
+  free((void *)cleartext_hex);
 
   SUCCESS();
 }
diff --git a/testsuite/gcm-test.c b/testsuite/gcm-test.c
index a1cf964..ef82f39 100644
--- a/testsuite/gcm-test.c
+++ b/testsuite/gcm-test.c
@@ -12,267 +12,267 @@ test_main(void)
 
   /* Test case 1 */
   test_aead(&amp;nettle_gcm_aes128,
-	    /* key */HL("00000000000000000000000000000000"),
-	    /* auth data */ HL(""),
-	    /* plaintext */HL(""),
-	    /* ciphertext*/H(""),
-	    /* IV */HL("000000000000000000000000"),
-	    /* tag */H("58e2fccefa7e3061367f1d57a4e7455a"));
+	    /* key */"00000000000000000000000000000000",
+	    /* auth data */ "",
+	    /* plaintext */"",
+	    /* ciphertext*/"",
+	    /* IV */"000000000000000000000000",
+	    /* tag */"58e2fccefa7e3061367f1d57a4e7455a");
 
   /* Test case 2 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("00000000000000000000000000000000"),
-	    HL(""),
-	    HL("00000000000000000000000000000000"),
-	    H("0388dace60b6a392f328c2b971b2fe78"),
-	    HL("000000000000000000000000"),
-	    H("ab6e47d42cec13bdf53a67b21257bddf"));
+	    "00000000000000000000000000000000",
+	    "",
+	    "00000000000000000000000000000000",
+	    "0388dace60b6a392f328c2b971b2fe78",
+	    "000000000000000000000000",
+	    "ab6e47d42cec13bdf53a67b21257bddf");
 
   /* Test case 3 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("feffe9928665731c6d6a8f9467308308"),
-	    HL(""),
-	    HL("d9313225f88406e5a55909c5aff5269a"
+	    "feffe9928665731c6d6a8f9467308308",
+	    "",
+	    "d9313225f88406e5a55909c5aff5269a"
 	       "86a7a9531534f7da2e4c303d8a318a72"
 	       "1c3c0c95956809532fcf0e2449a6b525"
-	       "b16aedf5aa0de657ba637b391aafd255"),
-	    H("42831ec2217774244b7221b784d0d49c"
+	       "b16aedf5aa0de657ba637b391aafd255",
+	    "42831ec2217774244b7221b784d0d49c"
 	      "e3aa212f2c02a4e035c17e2329aca12e"
 	      "21d514b25466931c7d8f6a5aac84aa05"
-	      "1ba30b396a0aac973d58e091473f5985"),
-	    HL("cafebabefacedbaddecaf888"),
-	    H("4d5c2af327cd64a62cf35abd2ba6fab4"));
+	      "1ba30b396a0aac973d58e091473f5985",
+	    "cafebabefacedbaddecaf888",
+	    "4d5c2af327cd64a62cf35abd2ba6fab4");
 
   /* Test case 4 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("feffe9928665731c6d6a8f9467308308"),
-	    HL("feedfacedeadbeeffeedfacedeadbeef"
-	       "abaddad2"),
-	    HL("d9313225f88406e5a55909c5aff5269a"
+	    "feffe9928665731c6d6a8f9467308308",
+	    "feedfacedeadbeeffeedfacedeadbeef"
+	       "abaddad2",
+	    "d9313225f88406e5a55909c5aff5269a"
 	       "86a7a9531534f7da2e4c303d8a318a72"
 	       "1c3c0c95956809532fcf0e2449a6b525"
-	       "b16aedf5aa0de657ba637b39"),
-	    H("42831ec2217774244b7221b784d0d49c"
+	       "b16aedf5aa0de657ba637b39",
+	    "42831ec2217774244b7221b784d0d49c"
 	      "e3aa212f2c02a4e035c17e2329aca12e"
 	      "21d514b25466931c7d8f6a5aac84aa05"
-	      "1ba30b396a0aac973d58e091"),
-	    HL("cafebabefacedbaddecaf888"),
-	    H("5bc94fbc3221a5db94fae95ae7121a47"));
+	      "1ba30b396a0aac973d58e091",
+	    "cafebabefacedbaddecaf888",
+	    "5bc94fbc3221a5db94fae95ae7121a47");
 
   /* Test case 5 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("feffe9928665731c6d6a8f9467308308"),
-	    HL("feedfacedeadbeeffeedfacedeadbeef"
-	       "abaddad2"),
-	    HL("d9313225f88406e5a55909c5aff5269a"
+	    "feffe9928665731c6d6a8f9467308308",
+	    "feedfacedeadbeeffeedfacedeadbeef"
+	       "abaddad2",
+	    "d9313225f88406e5a55909c5aff5269a"
 	       "86a7a9531534f7da2e4c303d8a318a72"
 	       "1c3c0c95956809532fcf0e2449a6b525"
-	       "b16aedf5aa0de657ba637b39"),
-	    H("61353b4c2806934a777ff51fa22a4755"
+	       "b16aedf5aa0de657ba637b39",
+	    "61353b4c2806934a777ff51fa22a4755"
 	      "699b2a714fcdc6f83766e5f97b6c7423"
 	      "73806900e49f24b22b097544d4896b42"
-	      "4989b5e1ebac0f07c23f4598"),
-	    HL("cafebabefacedbad"),
-	    H("3612d2e79e3b0785561be14aaca2fccb"));
+	      "4989b5e1ebac0f07c23f4598",
+	    "cafebabefacedbad",
+	    "3612d2e79e3b0785561be14aaca2fccb");
 
   /* Test case 6 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("feffe9928665731c6d6a8f9467308308"),
-	    HL("feedfacedeadbeeffeedfacedeadbeef"
-	       "abaddad2"),
-	    HL("d9313225f88406e5a55909c5aff5269a"
+	    "feffe9928665731c6d6a8f9467308308",
+	    "feedfacedeadbeeffeedfacedeadbeef"
+	       "abaddad2",
+	    "d9313225f88406e5a55909c5aff5269a"
 	       "86a7a9531534f7da2e4c303d8a318a72"
 	       "1c3c0c95956809532fcf0e2449a6b525"
-	       "b16aedf5aa0de657ba637b39"),
-	    H("8ce24998625615b603a033aca13fb894"
+	       "b16aedf5aa0de657ba637b39",
+	    "8ce24998625615b603a033aca13fb894"
 	      "be9112a5c3a211a8ba262a3cca7e2ca7"
 	      "01e4a9a4fba43c90ccdcb281d48c7c6f"
-	      "d62875d2aca417034c34aee5"),
-	    HL("9313225df88406e555909c5aff5269aa"
+	      "d62875d2aca417034c34aee5",
+	    "9313225df88406e555909c5aff5269aa"
 	       "6a7a9538534f7da1e4c303d2a318a728"
 	       "c3c0c95156809539fcf0e2429a6b5254"
-	       "16aedbf5a0de6a57a637b39b"),
-	    H("619cc5aefffe0bfa462af43c1699d050"));
+	       "16aedbf5a0de6a57a637b39b",
+	    "619cc5aefffe0bfa462af43c1699d050");
   
   /* Test case 7 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("00000000000000000000000000000000"
-	       "0000000000000000"),
-	    HL(""),
-	    HL(""),
-	    H(""),
-	    HL("000000000000000000000000"),
-	    H("cd33b28ac773f74ba00ed1f312572435"));
+	    "00000000000000000000000000000000"
+	       "0000000000000000",
+	    "",
+	    "",
+	    "",
+	    "000000000000000000000000",
+	    "cd33b28ac773f74ba00ed1f312572435");
 
   /* Test case 8 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("00000000000000000000000000000000"
-	       "0000000000000000"),
-	    HL(""),
-	    HL("00000000000000000000000000000000"),
-	    H("98e7247c07f0fe411c267e4384b0f600"),
-	    HL("000000000000000000000000"),
-	    H("2ff58d80033927ab8ef4d4587514f0fb"));
+	    "00000000000000000000000000000000"
+	       "0000000000000000",
+	    "",
+	    "00000000000000000000000000000000",
+	    "98e7247c07f0fe411c267e4384b0f600",
+	    "000000000000000000000000",
+	    "2ff58d80033927ab8ef4d4587514f0fb");
 
   /* Test case 9 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("feffe9928665731c6d6a8f9467308308"
-	       "feffe9928665731c"),
-	    HL(""),
-	    HL("d9313225f88406e5a55909c5aff5269a"
+	    "feffe9928665731c6d6a8f9467308308"
+	       "feffe9928665731c",
+	    "",
+	    "d9313225f88406e5a55909c5aff5269a"
 	       "86a7a9531534f7da2e4c303d8a318a72"
 	       "1c3c0c95956809532fcf0e2449a6b525"
-	       "b16aedf5aa0de657ba637b391aafd255"),
-	    H("3980ca0b3c00e841eb06fac4872a2757"
+	       "b16aedf5aa0de657ba637b391aafd255",
+	    "3980ca0b3c00e841eb06fac4872a2757"
 	      "859e1ceaa6efd984628593b40ca1e19c"
 	      "7d773d00c144c525ac619d18c84a3f47"
-	      "18e2448b2fe324d9ccda2710acade256"),
-	    HL("cafebabefacedbaddecaf888"),
-	    H("9924a7c8587336bfb118024db8674a14"));
+	      "18e2448b2fe324d9ccda2710acade256",
+	    "cafebabefacedbaddecaf888",
+	    "9924a7c8587336bfb118024db8674a14");
 
   /* Test case 10 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("feffe9928665731c6d6a8f9467308308"
-	       "feffe9928665731c"),
-	    HL("feedfacedeadbeeffeedfacedeadbeef"
-	       "abaddad2"),
-	    HL("d9313225f88406e5a55909c5aff5269a"
+	    "feffe9928665731c6d6a8f9467308308"
+	       "feffe9928665731c",
+	    "feedfacedeadbeeffeedfacedeadbeef"
+	       "abaddad2",
+	    "d9313225f88406e5a55909c5aff5269a"
 	       "86a7a9531534f7da2e4c303d8a318a72"
 	       "1c3c0c95956809532fcf0e2449a6b525"
-	       "b16aedf5aa0de657ba637b39"),
-	    H("3980ca0b3c00e841eb06fac4872a2757"
+	       "b16aedf5aa0de657ba637b39",
+	    "3980ca0b3c00e841eb06fac4872a2757"
 	      "859e1ceaa6efd984628593b40ca1e19c"
 	      "7d773d00c144c525ac619d18c84a3f47"
-	      "18e2448b2fe324d9ccda2710"),
-	    HL("cafebabefacedbaddecaf888"),
-	    H("2519498e80f1478f37ba55bd6d27618c"));
+	      "18e2448b2fe324d9ccda2710",
+	    "cafebabefacedbaddecaf888",
+	    "2519498e80f1478f37ba55bd6d27618c");
 
   /* Test case 11 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("feffe9928665731c6d6a8f9467308308"
-	       "feffe9928665731c"),
-	    HL("feedfacedeadbeeffeedfacedeadbeef"
-	       "abaddad2"),
-	    HL("d9313225f88406e5a55909c5aff5269a"
+	    "feffe9928665731c6d6a8f9467308308"
+	       "feffe9928665731c",
+	    "feedfacedeadbeeffeedfacedeadbeef"
+	       "abaddad2",
+	    "d9313225f88406e5a55909c5aff5269a"
 	       "86a7a9531534f7da2e4c303d8a318a72"
 	       "1c3c0c95956809532fcf0e2449a6b525"
-	       "b16aedf5aa0de657ba637b39"),
-	    H("0f10f599ae14a154ed24b36e25324db8"
+	       "b16aedf5aa0de657ba637b39",
+	    "0f10f599ae14a154ed24b36e25324db8"
 	      "c566632ef2bbb34f8347280fc4507057"
 	      "fddc29df9a471f75c66541d4d4dad1c9"
-	      "e93a19a58e8b473fa0f062f7"),
-	    HL("cafebabefacedbad"),
-	    H("65dcc57fcf623a24094fcca40d3533f8"));
+	      "e93a19a58e8b473fa0f062f7",
+	    "cafebabefacedbad",
+	    "65dcc57fcf623a24094fcca40d3533f8");
 
   /* Test case 12 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("feffe9928665731c6d6a8f9467308308"
-	       "feffe9928665731c"),
-	    HL("feedfacedeadbeeffeedfacedeadbeef"
-	       "abaddad2"),
-	    HL("d9313225f88406e5a55909c5aff5269a"
+	    "feffe9928665731c6d6a8f9467308308"
+	       "feffe9928665731c",
+	    "feedfacedeadbeeffeedfacedeadbeef"
+	       "abaddad2",
+	    "d9313225f88406e5a55909c5aff5269a"
 	       "86a7a9531534f7da2e4c303d8a318a72"
 	       "1c3c0c95956809532fcf0e2449a6b525"
-	       "b16aedf5aa0de657ba637b39"),
-	    H("d27e88681ce3243c4830165a8fdcf9ff"
+	       "b16aedf5aa0de657ba637b39",
+	    "d27e88681ce3243c4830165a8fdcf9ff"
 	      "1de9a1d8e6b447ef6ef7b79828666e45"
 	      "81e79012af34ddd9e2f037589b292db3"
-	      "e67c036745fa22e7e9b7373b"),
-	    HL("9313225df88406e555909c5aff5269aa"
+	      "e67c036745fa22e7e9b7373b",
+	    "9313225df88406e555909c5aff5269aa"
 	       "6a7a9538534f7da1e4c303d2a318a728"
 	       "c3c0c95156809539fcf0e2429a6b5254"
-	       "16aedbf5a0de6a57a637b39b"),
-	    H("dcf566ff291c25bbb8568fc3d376a6d9"));
+	       "16aedbf5a0de6a57a637b39b",
+	    "dcf566ff291c25bbb8568fc3d376a6d9");
 
   /* Test case 13 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("00000000000000000000000000000000"
-	       "00000000000000000000000000000000"),
-	    HL(""),
-	    HL(""),
-	    H(""),
-	    HL("000000000000000000000000"),
-	    H("530f8afbc74536b9a963b4f1c4cb738b"));
+	    "00000000000000000000000000000000"
+	       "00000000000000000000000000000000",
+	    "",
+	    "",
+	    "",
+	    "000000000000000000000000",
+	    "530f8afbc74536b9a963b4f1c4cb738b");
 
   /* Test case 14 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("00000000000000000000000000000000"
-	       "00000000000000000000000000000000"),
-	    HL(""),
-	    HL("00000000000000000000000000000000"),
-	    H("cea7403d4d606b6e074ec5d3baf39d18"),
-	    HL("000000000000000000000000"),
-	    H("d0d1c8a799996bf0265b98b5d48ab919"));
+	    "00000000000000000000000000000000"
+	       "00000000000000000000000000000000",
+	    "",
+	    "00000000000000000000000000000000",
+	    "cea7403d4d606b6e074ec5d3baf39d18",
+	    "000000000000000000000000",
+	    "d0d1c8a799996bf0265b98b5d48ab919");
 
   /* Test case 15 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("feffe9928665731c6d6a8f9467308308"
-	       "feffe9928665731c6d6a8f9467308308"),
-	    HL(""),
-	    HL("d9313225f88406e5a55909c5aff5269a"
+	    "feffe9928665731c6d6a8f9467308308"
+	       "feffe9928665731c6d6a8f9467308308",
+	    "",
+	    "d9313225f88406e5a55909c5aff5269a"
 	       "86a7a9531534f7da2e4c303d8a318a72"
 	       "1c3c0c95956809532fcf0e2449a6b525"
-	       "b16aedf5aa0de657ba637b391aafd255"),
-	    H("522dc1f099567d07f47f37a32a84427d"
+	       "b16aedf5aa0de657ba637b391aafd255",
+	    "522dc1f099567d07f47f37a32a84427d"
 	      "643a8cdcbfe5c0c97598a2bd2555d1aa"
 	      "8cb08e48590dbb3da7b08b1056828838"
-	      "c5f61e6393ba7a0abcc9f662898015ad"),
-	    HL("cafebabefacedbaddecaf888"),
-	    H("b094dac5d93471bdec1a502270e3cc6c"));
+	      "c5f61e6393ba7a0abcc9f662898015ad",
+	    "cafebabefacedbaddecaf888",
+	    "b094dac5d93471bdec1a502270e3cc6c");
 
   /* Test case 16 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("feffe9928665731c6d6a8f9467308308"
-	       "feffe9928665731c6d6a8f9467308308"),
-	    HL("feedfacedeadbeeffeedfacedeadbeef"
-	       "abaddad2"),
-	    HL("d9313225f88406e5a55909c5aff5269a"
+	    "feffe9928665731c6d6a8f9467308308"
+	       "feffe9928665731c6d6a8f9467308308",
+	    "feedfacedeadbeeffeedfacedeadbeef"
+	       "abaddad2",
+	    "d9313225f88406e5a55909c5aff5269a"
 	       "86a7a9531534f7da2e4c303d8a318a72"
 	       "1c3c0c95956809532fcf0e2449a6b525"
-	       "b16aedf5aa0de657ba637b39"),
-	    H("522dc1f099567d07f47f37a32a84427d"
+	       "b16aedf5aa0de657ba637b39",
+	    "522dc1f099567d07f47f37a32a84427d"
 	      "643a8cdcbfe5c0c97598a2bd2555d1aa"
 	      "8cb08e48590dbb3da7b08b1056828838"
-	      "c5f61e6393ba7a0abcc9f662"),
-	    HL("cafebabefacedbaddecaf888"),
-	    H("76fc6ece0f4e1768cddf8853bb2d551b"));
+	      "c5f61e6393ba7a0abcc9f662",
+	    "cafebabefacedbaddecaf888",
+	    "76fc6ece0f4e1768cddf8853bb2d551b");
 
   /* Test case 17 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("feffe9928665731c6d6a8f9467308308"
-	       "feffe9928665731c6d6a8f9467308308"),
-	    HL("feedfacedeadbeeffeedfacedeadbeef"
-	       "abaddad2"),
-	    HL("d9313225f88406e5a55909c5aff5269a"
+	    "feffe9928665731c6d6a8f9467308308"
+	       "feffe9928665731c6d6a8f9467308308",
+	    "feedfacedeadbeeffeedfacedeadbeef"
+	       "abaddad2",
+	    "d9313225f88406e5a55909c5aff5269a"
 	       "86a7a9531534f7da2e4c303d8a318a72"
 	       "1c3c0c95956809532fcf0e2449a6b525"
-	       "b16aedf5aa0de657ba637b39"),
-	    H("c3762df1ca787d32ae47c13bf19844cb"
+	       "b16aedf5aa0de657ba637b39",
+	    "c3762df1ca787d32ae47c13bf19844cb"
 	      "af1ae14d0b976afac52ff7d79bba9de0"
 	      "feb582d33934a4f0954cc2363bc73f78"
-	      "62ac430e64abe499f47c9b1f"),
-	    HL("cafebabefacedbad"),
-	    H("3a337dbf46a792c45e454913fe2ea8f2"));
+	      "62ac430e64abe499f47c9b1f",
+	    "cafebabefacedbad",
+	    "3a337dbf46a792c45e454913fe2ea8f2");
 
   /* Test case 18 */
   test_aead(&amp;nettle_gcm_aes128,
-	    HL("feffe9928665731c6d6a8f9467308308"
-	       "feffe9928665731c6d6a8f9467308308"),
-	    HL("feedfacedeadbeeffeedfacedeadbeef"
-	       "abaddad2"),
-	    HL("d9313225f88406e5a55909c5aff5269a"
+	    "feffe9928665731c6d6a8f9467308308"
+	       "feffe9928665731c6d6a8f9467308308",
+	    "feedfacedeadbeeffeedfacedeadbeef"
+	       "abaddad2",
+	    "d9313225f88406e5a55909c5aff5269a"
 	       "86a7a9531534f7da2e4c303d8a318a72"
 	       "1c3c0c95956809532fcf0e2449a6b525"
-	       "b16aedf5aa0de657ba637b39"),
-	    H("5a8def2f0c9e53f1f75d7853659e2a20"
+	       "b16aedf5aa0de657ba637b39",
+	    "5a8def2f0c9e53f1f75d7853659e2a20"
 	      "eeb2b22aafde6419a058ab4f6f746bf4"
 	      "0fc0c3b780f244452da3ebf1c5d82cde"
-	      "a2418997200ef82e44ae7e3f"),
-	    HL("9313225df88406e555909c5aff5269aa"
+	      "a2418997200ef82e44ae7e3f",
+	    "9313225df88406e555909c5aff5269aa"
 	       "6a7a9538534f7da1e4c303d2a318a728"
 	       "c3c0c95156809539fcf0e2429a6b5254"
-	       "16aedbf5a0de6a57a637b39b"),
-	    H("a44a8266ee1c8eb0c8b5d4cf5ae9f19a"));
+	       "16aedbf5a0de6a57a637b39b",
+	    "a44a8266ee1c8eb0c8b5d4cf5ae9f19a");
 
   SUCCESS();
 }
diff --git a/testsuite/hmac-test.c b/testsuite/hmac-test.c
index 0f14934..0356cf5 100644
--- a/testsuite/hmac-test.c
+++ b/testsuite/hmac-test.c
@@ -1,349 +1,435 @@
 #include "testutils.h"
 #include "hmac.h"
 
-/* KEY and MSG are supposed to expand to length, data */ 
-#define HMAC_TEST(alg, length, key, msg, mac) do {		\
-  hmac_##alg##_set_key(&amp;alg, key);				\
-  hmac_##alg##_update(&amp;alg, msg);				\
-  digest[length] = 17;						\
-  hmac_##alg##_digest(&amp;alg, length, digest);			\
-  ASSERT(MEMEQ (length, digest, mac));				\
-  ASSERT(digest[length] == 17);					\
-} while (0)
+#define HEX_NONE 0
+#define HEX_KEY  1
+#define HEX_MSG   2
+
+enum {
+  alg_md5,
+  alg_ripemd160,
+  alg_sha1,
+  alg_sha224,
+  alg_sha256,
+  alg_sha384,
+  alg_sha512
+};
+
+static struct hmac_md5_ctx md5;
+static struct hmac_ripemd160_ctx ripemd160;
+static struct hmac_sha1_ctx sha1;
+static struct hmac_sha224_ctx sha224;
+static struct hmac_sha256_ctx sha256;
+static struct hmac_sha384_ctx sha384;
+static struct hmac_sha512_ctx sha512;
+
+/* sha512's digests are longest */
+static uint8_t digest[SHA512_DIGEST_SIZE+1];
+
+static void
+hmac_test(int alg,
+          unsigned digest_length,
+          int flags,
+          const uint8_t *key_hex,
+          const uint8_t *msg_hex,
+          const uint8_t *mac_hex)
+{
+  const uint8_t *key, *msg, *mac = decode_hex_dup(mac_hex);                          \
\ +  unsigned key_length, msg_length;
+
+  if (flags &amp; HEX_KEY)
+    {
+      key_length = decode_hex_length(key_hex);
+      key = decode_hex_dup(key_hex);
+    }
+  else
+    {
+      key_length = strlen(key_hex);
+      key = key_hex;
+    }
+
+  if (flags &amp; HEX_MSG)
+    {
+      msg_length = decode_hex_length(msg_hex);
+      msg = decode_hex_dup(msg_hex);
+    }
+  else
+    {
+      msg_length = strlen(msg_hex);
+      msg = msg_hex;
+    }
+
+  digest[digest_length] = 17;
+
+  switch (alg)
+    {
+    case alg_md5:
+        hmac_md5_set_key(&amp;md5, key_length, key);
+        hmac_md5_update(&amp;md5, msg_length, msg);
+        hmac_md5_digest(&amp;md5, digest_length, digest);
+        break;
+    case alg_ripemd160:
+        hmac_ripemd160_set_key(&amp;ripemd160, key_length, key);
+        hmac_ripemd160_update(&amp;ripemd160, msg_length, msg);
+        hmac_ripemd160_digest(&amp;ripemd160, digest_length, digest);
+        break;
+    case alg_sha1:
+        hmac_sha1_set_key(&amp;sha1, key_length, key);
+        hmac_sha1_update(&amp;sha1, msg_length, msg);
+        hmac_sha1_digest(&amp;sha1, digest_length, digest);
+        break;
+    case alg_sha224:
+        hmac_sha224_set_key(&amp;sha224, key_length, key);
+        hmac_sha224_update(&amp;sha224, msg_length, msg);
+        hmac_sha224_digest(&amp;sha224, digest_length, digest);
+        break;
+    case alg_sha256:
+        hmac_sha256_set_key(&amp;sha256, key_length, key);
+        hmac_sha256_update(&amp;sha256, msg_length, msg);
+        hmac_sha256_digest(&amp;sha256, digest_length, digest);
+        break;
+    case alg_sha384:
+        hmac_sha384_set_key(&amp;sha384, key_length, key);
+        hmac_sha384_update(&amp;sha384, msg_length, msg);
+        hmac_sha384_digest(&amp;sha384, digest_length, digest);
+        break;
+    case alg_sha512:
+        hmac_sha512_set_key(&amp;sha512, key_length, key);
+        hmac_sha512_update(&amp;sha512, msg_length, msg);
+        hmac_sha512_digest(&amp;sha512, digest_length, digest);
+        break;
+    }
+
+  ASSERT(MEMEQ(digest_length, digest, mac));
+  ASSERT(digest[digest_length] == 17);
+
+  free((void *)mac);
+  if (flags &amp; HEX_MSG)
+    free((void *)msg);
+  if (flags &amp; HEX_KEY)
+    free((void *)key);
+}
 
 int
 test_main(void)
 {
-  struct hmac_md5_ctx md5;
-  struct hmac_sha1_ctx sha1;
-  struct hmac_ripemd160_ctx ripemd160;
-  struct hmac_sha224_ctx sha224;
-  struct hmac_sha256_ctx sha256;
-  struct hmac_sha384_ctx sha384;
-  struct hmac_sha512_ctx sha512;
-
-  /* sha512's digests are longest */
-  uint8_t digest[SHA512_DIGEST_SIZE+1];
-
-  memset(digest, 0, sizeof(digest));
-
   /* Test vectors for md5, from RFC-2202 */
 
   /* md5 - 1 */
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    HL("0b0b0b0b0b0b0b0b 0b0b0b0b0b0b0b0b"),
-	    LDATA("Hi There"),
-	    H("9294727a3638bb1c 13f48ef8158bfc9d"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_KEY,
+	    "0b0b0b0b0b0b0b0b 0b0b0b0b0b0b0b0b",
+	    "Hi There",
+	    "9294727a3638bb1c 13f48ef8158bfc9d");
 
 
   /* md5 - 2 */
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("Jefe"),
-	    LDATA("what do ya want for nothing?"),
-	    H("750c783e6ab0b503 eaa86e310a5db738"));	    
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "Jefe",
+	    "what do ya want for nothing?",
+	    "750c783e6ab0b503 eaa86e310a5db738");
 
   /* md5 - 3 */
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"),
-	    HL("dddddddddddddddd dddddddddddddddd"
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
+	    "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa",
+	    "dddddddddddddddd dddddddddddddddd"
 	       "dddddddddddddddd dddddddddddddddd"
 	       "dddddddddddddddd dddddddddddddddd"
-	       "dddd"),
-	    H("56be34521d144c88 dbb8c733f0e8b3f6"));
+	       "dddd",
+	    "56be34521d144c88 dbb8c733f0e8b3f6");
   
   /* md5 - 4 */
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    HL("0102030405060708 090a0b0c0d0e0f10" 
-	       "1112131415161718 19"),
-	    HL("cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd"
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
+	    "0102030405060708 090a0b0c0d0e0f10" 
+	       "1112131415161718 19",
+	    "cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd"
 	       "cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd"
 	       "cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd"
-	       "cdcd"),
-	    H("697eaf0aca3a3aea 3a75164746ffaa79"));
+	       "cdcd",
+	    "697eaf0aca3a3aea 3a75164746ffaa79");
 
   /* md5 - 5 */
-  HMAC_TEST(md5, 12,
-	    HL("0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c"),
-	    LDATA("Test With Truncation"),
-	    H("56461ef2342edc00 f9bab995"));
+  hmac_test(alg_md5, 12, HEX_KEY,
+	    "0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c",
+	    "Test With Truncation",
+	    "56461ef2342edc00 f9bab995");
 
   /* md5 - 6 */
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_KEY,
+	    "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
-	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"),
-	    LDATA("Test Using Larger Than Block-Size Key - Hash Key First"),
-	    H("6b1ab7fe4bd7bf8f 0b62e6ce61b9d0cd"));
+	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa",
+	    "Test Using Larger Than Block-Size Key - Hash Key First",
+	    "6b1ab7fe4bd7bf8f 0b62e6ce61b9d0cd");
 
   /* md5 - 7 */
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_KEY,
+	    "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
-	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"),
-	    LDATA("Test Using Larger Than Block-Size Key and Larger "
-		  "Than One Block-Size Data"),
-	    H("6f630fad67cda0ee 1fb1f562db3aa53e"));
+	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa",
+	    "Test Using Larger Than Block-Size Key and Larger "
+		  "Than One Block-Size Data",
+	    "6f630fad67cda0ee 1fb1f562db3aa53e");
 
   /* Additional test vectors, from Daniel Kahn Gillmor */
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA(""),
-	    H("e84db42a188813f30a15e611d64c7869"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "",
+	    "e84db42a188813f30a15e611d64c7869");
   
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("a"),
-	    H("123662062e67c2aab371cc49db0df134"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "a",
+	    "123662062e67c2aab371cc49db0df134");
   
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("38"),
-	    H("0a46cc10a49d4b7025c040c597bf5d76"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "38",
+	    "0a46cc10a49d4b7025c040c597bf5d76");
   
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("abc"),
-	    H("d1f4d89f0e8b2b6ed0623c99ec298310"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "abc",
+	    "d1f4d89f0e8b2b6ed0623c99ec298310");
   
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("message digest"),
-	    H("1627207b9bed5009a4f6e9ca8d2ca01e"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "message digest",
+	    "1627207b9bed5009a4f6e9ca8d2ca01e");
   
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("abcdefghijklmnopqrstuvwxyz"),
-	    H("922aae6ab3b3a29202e21ce5f916ae9a"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "abcdefghijklmnopqrstuvwxyz",
+	    "922aae6ab3b3a29202e21ce5f916ae9a");
 
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"),
-	    H("ede9cb83679ba82d88fbeae865b3f8fc"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
+	    "ede9cb83679ba82d88fbeae865b3f8fc");
 
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("12345678901234567890123456789012345678901234567890123456789012345678901234567890"),
                
-	    H("939dd45512ee3a594b6654f6b8de27f7"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "12345678901234567890123456789012345678901234567890123456789012345678901234567890",
 +	    "939dd45512ee3a594b6654f6b8de27f7");
 
   /* Test vectors for ripemd160, from
      http://homes.esat.kuleuven.be/~bosselae/ripemd160.html */
-  HMAC_TEST(ripemd160, RIPEMD160_DIGEST_SIZE,
-	    HL("00112233445566778899aabbccddeeff01234567"),
-	    LDATA(""),
-	    H("cf387677bfda8483e63b57e06c3b5ecd8b7fc055"));
-
-  HMAC_TEST(ripemd160, RIPEMD160_DIGEST_SIZE,
-	    HL("00112233445566778899aabbccddeeff01234567"),
-	    LDATA("a"),
-	    H("0d351d71b78e36dbb7391c810a0d2b6240ddbafc"));
-
-  HMAC_TEST(ripemd160, RIPEMD160_DIGEST_SIZE,
-	    HL("00112233445566778899aabbccddeeff01234567"),
-	    LDATA("abc"),
-	    H("f7ef288cb1bbcc6160d76507e0a3bbf712fb67d6"));
-
-  HMAC_TEST(ripemd160, RIPEMD160_DIGEST_SIZE,
-	    HL("00112233445566778899aabbccddeeff01234567"),
-	    LDATA("message digest"),
-	    H("f83662cc8d339c227e600fcd636c57d2571b1c34"));
-
-  HMAC_TEST(ripemd160, RIPEMD160_DIGEST_SIZE,
-	    HL("00112233445566778899aabbccddeeff01234567"),
-	    LDATA("abcdefghijklmnopqrstuvwxyz"),
-	    H("843d1c4eb880ac8ac0c9c95696507957d0155ddb"));
-
-  HMAC_TEST(ripemd160, RIPEMD160_DIGEST_SIZE,
-	    HL("00112233445566778899aabbccddeeff01234567"),
-	    LDATA("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"),
-	    H("60f5ef198a2dd5745545c1f0c47aa3fb5776f881"));
-
-  HMAC_TEST(ripemd160, RIPEMD160_DIGEST_SIZE,
-	    HL("00112233445566778899aabbccddeeff01234567"),
-	    LDATA("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"),
-	    H("e49c136a9e5627e0681b808a3b97e6a6e661ae79"));
+  hmac_test(alg_ripemd160, RIPEMD160_DIGEST_SIZE, HEX_KEY,
+	    "00112233445566778899aabbccddeeff01234567",
+	    "",
+	    "cf387677bfda8483e63b57e06c3b5ecd8b7fc055");
+
+  hmac_test(alg_ripemd160, RIPEMD160_DIGEST_SIZE, HEX_KEY,
+	    "00112233445566778899aabbccddeeff01234567",
+	    "a",
+	    "0d351d71b78e36dbb7391c810a0d2b6240ddbafc");
+
+  hmac_test(alg_ripemd160, RIPEMD160_DIGEST_SIZE, HEX_KEY,
+	    "00112233445566778899aabbccddeeff01234567",
+	    "abc",
+	    "f7ef288cb1bbcc6160d76507e0a3bbf712fb67d6");
+
+  hmac_test(alg_ripemd160, RIPEMD160_DIGEST_SIZE, HEX_KEY,
+	    "00112233445566778899aabbccddeeff01234567",
+	    "message digest",
+	    "f83662cc8d339c227e600fcd636c57d2571b1c34");
+
+  hmac_test(alg_ripemd160, RIPEMD160_DIGEST_SIZE, HEX_KEY,
+	    "00112233445566778899aabbccddeeff01234567",
+	    "abcdefghijklmnopqrstuvwxyz",
+	    "843d1c4eb880ac8ac0c9c95696507957d0155ddb");
+
+  hmac_test(alg_ripemd160, RIPEMD160_DIGEST_SIZE, HEX_KEY,
+	    "00112233445566778899aabbccddeeff01234567",
+	    "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
+	    "60f5ef198a2dd5745545c1f0c47aa3fb5776f881");
+
+  hmac_test(alg_ripemd160, RIPEMD160_DIGEST_SIZE, HEX_KEY,
+	    "00112233445566778899aabbccddeeff01234567",
+	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
+	    "e49c136a9e5627e0681b808a3b97e6a6e661ae79");
 
   /* Other key */
-  HMAC_TEST(ripemd160, RIPEMD160_DIGEST_SIZE,
-	    HL("0123456789abcdeffedcba987654321000112233"),
-	    LDATA(""),
-	    H("fe69a66c7423eea9c8fa2eff8d9dafb4f17a62f5"));
-
-  HMAC_TEST(ripemd160, RIPEMD160_DIGEST_SIZE,
-	    HL("0123456789abcdeffedcba987654321000112233"),
-	    LDATA("a"),
-	    H("85743e899bc82dbfa36faaa7a25b7cfd372432cd"));
-
-  HMAC_TEST(ripemd160, RIPEMD160_DIGEST_SIZE,
-	    HL("0123456789abcdeffedcba987654321000112233"),
-	    LDATA("abc"),
-	    H("6e4afd501fa6b4a1823ca3b10bd9aa0ba97ba182"));
-
-  HMAC_TEST(ripemd160, RIPEMD160_DIGEST_SIZE,
-	    HL("0123456789abcdeffedcba987654321000112233"),
-	    LDATA("message digest"),
-	    H("2e066e624badb76a184c8f90fba053330e650e92"));
-
-  HMAC_TEST(ripemd160, RIPEMD160_DIGEST_SIZE,
-	    HL("0123456789abcdeffedcba987654321000112233"),
-	    LDATA("abcdefghijklmnopqrstuvwxyz"),
-	    H("07e942aa4e3cd7c04dedc1d46e2e8cc4c741b3d9"));
-
-  HMAC_TEST(ripemd160, RIPEMD160_DIGEST_SIZE,
-	    HL("0123456789abcdeffedcba987654321000112233"),
-	    LDATA("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"),
-	    H("b6582318ddcfb67a53a67d676b8ad869aded629a"));
-
-  HMAC_TEST(ripemd160, RIPEMD160_DIGEST_SIZE,
-	    HL("0123456789abcdeffedcba987654321000112233"),
-	    LDATA("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"),
-	    H("f1be3ee877703140d34f97ea1ab3a07c141333e2"));
+  hmac_test(alg_ripemd160, RIPEMD160_DIGEST_SIZE, HEX_KEY,
+	    "0123456789abcdeffedcba987654321000112233",
+	    "",
+	    "fe69a66c7423eea9c8fa2eff8d9dafb4f17a62f5");
+
+  hmac_test(alg_ripemd160, RIPEMD160_DIGEST_SIZE, HEX_KEY,
+	    "0123456789abcdeffedcba987654321000112233",
+	    "a",
+	    "85743e899bc82dbfa36faaa7a25b7cfd372432cd");
+
+  hmac_test(alg_ripemd160, RIPEMD160_DIGEST_SIZE, HEX_KEY,
+	    "0123456789abcdeffedcba987654321000112233",
+	    "abc",
+	    "6e4afd501fa6b4a1823ca3b10bd9aa0ba97ba182");
+
+  hmac_test(alg_ripemd160, RIPEMD160_DIGEST_SIZE, HEX_KEY,
+	    "0123456789abcdeffedcba987654321000112233",
+	    "message digest",
+	    "2e066e624badb76a184c8f90fba053330e650e92");
+
+  hmac_test(alg_ripemd160, RIPEMD160_DIGEST_SIZE, HEX_KEY,
+	    "0123456789abcdeffedcba987654321000112233",
+	    "abcdefghijklmnopqrstuvwxyz",
+	    "07e942aa4e3cd7c04dedc1d46e2e8cc4c741b3d9");
+
+  hmac_test(alg_ripemd160, RIPEMD160_DIGEST_SIZE, HEX_KEY,
+	    "0123456789abcdeffedcba987654321000112233",
+	    "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
+	    "b6582318ddcfb67a53a67d676b8ad869aded629a");
+
+  hmac_test(alg_ripemd160, RIPEMD160_DIGEST_SIZE, HEX_KEY,
+	    "0123456789abcdeffedcba987654321000112233",
+	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
+	    "f1be3ee877703140d34f97ea1ab3a07c141333e2");
 
   /* Test vectors for sha1, from RFC-2202 */
 
   /* sha1 - 1 */
-  HMAC_TEST(sha1, SHA1_DIGEST_SIZE,
-	    HL("0b0b0b0b0b0b0b0b 0b0b0b0b0b0b0b0b 0b0b0b0b"),
-	    LDATA("Hi There"),
-	    H("b617318655057264 e28bc0b6fb378c8e f146be00"));
+  hmac_test(alg_sha1, SHA1_DIGEST_SIZE, HEX_KEY,
+	    "0b0b0b0b0b0b0b0b 0b0b0b0b0b0b0b0b 0b0b0b0b",
+	    "Hi There",
+	    "b617318655057264 e28bc0b6fb378c8e f146be00");
 
   /* sha1 - 2 */
-  HMAC_TEST(sha1, SHA1_DIGEST_SIZE,
-	    LDATA("Jefe"),
-	    LDATA("what do ya want for nothing?"),
-	    H("effcdf6ae5eb2fa2 d27416d5f184df9c 259a7c79"));
+  hmac_test(alg_sha1, SHA1_DIGEST_SIZE, HEX_NONE,
+	    "Jefe",
+	    "what do ya want for nothing?",
+	    "effcdf6ae5eb2fa2 d27416d5f184df9c 259a7c79");
 
   /* sha1 - 3 */
-  HMAC_TEST(sha1, SHA1_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa aaaaaaaa"),
-	    HL("dddddddddddddddd dddddddddddddddd"
+  hmac_test(alg_sha1, SHA1_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
+	    "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa aaaaaaaa",
+	    "dddddddddddddddd dddddddddddddddd"
 	       "dddddddddddddddd dddddddddddddddd"
 	       "dddddddddddddddd dddddddddddddddd"
-	       "dddd"),
-	    H("125d7342b9ac11cd 91a39af48aa17b4f 63f175d3"));
+	       "dddd",
+	    "125d7342b9ac11cd 91a39af48aa17b4f 63f175d3");
 
   /* sha1 - 4 */
-  HMAC_TEST(sha1, SHA1_DIGEST_SIZE,
-	    HL("0102030405060708 090a0b0c0d0e0f10" 
-	       "1112131415161718 19"),
-	    HL("cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd"
+  hmac_test(alg_sha1, SHA1_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
+	    "0102030405060708 090a0b0c0d0e0f10" 
+	       "1112131415161718 19",
+	    "cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd"
 	       "cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd"
 	       "cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd"
-	       "cdcd"),
-	    H("4c9007f4026250c6 bc8414f9bf50c86c 2d7235da"));
+	       "cdcd",
+	    "4c9007f4026250c6 bc8414f9bf50c86c 2d7235da");
 
   /* sha1 - 5 */
-  HMAC_TEST(sha1, 12,
-	    HL("0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c 0c0c0c0c"),
-	    LDATA("Test With Truncation"),
-	    H("4c1a03424b55e07f e7f27be1"));
+  hmac_test(alg_sha1, 12, HEX_KEY,
+	    "0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c 0c0c0c0c",
+	    "Test With Truncation",
+	    "4c1a03424b55e07f e7f27be1");
 
   /* sha1 - 6 */
-  HMAC_TEST(sha1, SHA1_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
+  hmac_test(alg_sha1, SHA1_DIGEST_SIZE, HEX_KEY,
+	    "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
-	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"),
-	    LDATA("Test Using Larger Than Block-Size Key - Hash Key First"),
-	    H("aa4ae5e15272d00e 95705637ce8a3b55 ed402112"));
+	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa",
+	    "Test Using Larger Than Block-Size Key - Hash Key First",
+	    "aa4ae5e15272d00e 95705637ce8a3b55 ed402112");
 
   /* sha1 - 7 */
-  HMAC_TEST(sha1, SHA1_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
+  hmac_test(alg_sha1, SHA1_DIGEST_SIZE, HEX_KEY,
+	    "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
-	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"),
-	    LDATA("Test Using Larger Than Block-Size Key and Larger "
-		  "Than One Block-Size Data"),
-	    H("e8e99d0f45237d78 6d6bbaa7965c7808 bbff1a91"));
+	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa",
+	    "Test Using Larger Than Block-Size Key and Larger "
+		  "Than One Block-Size Data",
+	    "e8e99d0f45237d78 6d6bbaa7965c7808 bbff1a91");
 
   /* Additional test vectors, from Daniel Kahn Gillmor */
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA(""),
-	    H("e84db42a188813f30a15e611d64c7869"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "",
+	    "e84db42a188813f30a15e611d64c7869");
   
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("a"),
-	    H("123662062e67c2aab371cc49db0df134"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "a",
+	    "123662062e67c2aab371cc49db0df134");
   
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("38"),
-	    H("0a46cc10a49d4b7025c040c597bf5d76"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "38",
+	    "0a46cc10a49d4b7025c040c597bf5d76");
   
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("abc"),
-	    H("d1f4d89f0e8b2b6ed0623c99ec298310"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "abc",
+	    "d1f4d89f0e8b2b6ed0623c99ec298310");
   
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("message digest"),
-	    H("1627207b9bed5009a4f6e9ca8d2ca01e"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "message digest",
+	    "1627207b9bed5009a4f6e9ca8d2ca01e");
   
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("abcdefghijklmnopqrstuvwxyz"),
-	    H("922aae6ab3b3a29202e21ce5f916ae9a"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "abcdefghijklmnopqrstuvwxyz",
+	    "922aae6ab3b3a29202e21ce5f916ae9a");
 
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"),
-	    H("ede9cb83679ba82d88fbeae865b3f8fc"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
+	    "ede9cb83679ba82d88fbeae865b3f8fc");
 
-  HMAC_TEST(md5, MD5_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("12345678901234567890123456789012345678901234567890123456789012345678901234567890"),
                
-	    H("939dd45512ee3a594b6654f6b8de27f7"));
+  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "12345678901234567890123456789012345678901234567890123456789012345678901234567890",
 +	    "939dd45512ee3a594b6654f6b8de27f7");
 
   /* Test vectors for sha224, from RFC 4231 */
-  HMAC_TEST(sha224, SHA224_DIGEST_SIZE,
-	    HL("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"
-	       "0b0b0b0b"),
-	    LDATA("Hi There"),
-	    H("896fb1128abbdf196832107cd49df33f"
-	      "47b4b1169912ba4f53684b22"));
-
-  HMAC_TEST(sha224, SHA224_DIGEST_SIZE,
-	    LDATA("Jefe"),
-	    LDATA("what do ya want for nothing?"),
-	    H("a30e01098bc6dbbf45690f3a7e9e6d0f"
-	      "8bbea2a39e6148008fd05e44"));
-
-  HMAC_TEST(sha224, SHA224_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
-	       "aaaaaaaa"),
-	    HL("dddddddddddddddddddddddddddddddd"
+  hmac_test(alg_sha224, SHA224_DIGEST_SIZE, HEX_KEY,
+	    "0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"
+	       "0b0b0b0b",
+	    "Hi There",
+	    "896fb1128abbdf196832107cd49df33f"
+	      "47b4b1169912ba4f53684b22");
+
+  hmac_test(alg_sha224, SHA224_DIGEST_SIZE, HEX_NONE,
+	    "Jefe",
+	    "what do ya want for nothing?",
+	    "a30e01098bc6dbbf45690f3a7e9e6d0f"
+	      "8bbea2a39e6148008fd05e44");
+
+  hmac_test(alg_sha224, SHA224_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
+	    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+	       "aaaaaaaa",
+	    "dddddddddddddddddddddddddddddddd"
 	       "dddddddddddddddddddddddddddddddd"
 	       "dddddddddddddddddddddddddddddddd"
-	       "dddd"),
-	    H("7fb3cb3588c6c1f6ffa9694d7d6ad264"
-	      "9365b0c1f65d69d1ec8333ea"));
-
-  HMAC_TEST(sha224, SHA224_DIGEST_SIZE,
-	    HL("0102030405060708090a0b0c0d0e0f10"
-	       "111213141516171819"),
-	    HL("cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
+	       "dddd",
+	    "7fb3cb3588c6c1f6ffa9694d7d6ad264"
+	      "9365b0c1f65d69d1ec8333ea");
+
+  hmac_test(alg_sha224, SHA224_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
+	    "0102030405060708090a0b0c0d0e0f10"
+	       "111213141516171819",
+	    "cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
 	       "cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
 	       "cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
-	       "cdcd"),
-	    H("6c11506874013cac6a2abc1bb382627c"
-	      "ec6a90d86efc012de7afec5a"));
+	       "cdcd",
+	    "6c11506874013cac6a2abc1bb382627c"
+	      "ec6a90d86efc012de7afec5a");
 
-  HMAC_TEST(sha224, 16,
-	    HL("0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c 0c0c0c0c"),
-	    LDATA("Test With Truncation"),
-	    H("0e2aea68a90c8d37c988bcdb9fca6fa8"));
+  hmac_test(alg_sha224, 16, HEX_KEY,
+	    "0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c 0c0c0c0c",
+	    "Test With Truncation",
+	    "0e2aea68a90c8d37c988bcdb9fca6fa8");
 
-  HMAC_TEST(sha224, SHA224_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+  hmac_test(alg_sha224, SHA224_DIGEST_SIZE, HEX_KEY,
+	    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
@@ -351,13 +437,13 @@ test_main(void)
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
-	       "aaaaaa"),
-	    LDATA("Test Using Larger Than Block-Size Key - Hash Key First"),
-	    H("95e9a0db962095adaebe9b2d6f0dbce2"
-	      "d499f112f2d2b7273fa6870e"));
+	       "aaaaaa",
+	    "Test Using Larger Than Block-Size Key - Hash Key First",
+	    "95e9a0db962095adaebe9b2d6f0dbce2"
+	      "d499f112f2d2b7273fa6870e");
 
-  HMAC_TEST(sha224, SHA224_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+  hmac_test(alg_sha224, SHA224_DIGEST_SIZE, HEX_KEY,
+	    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
@@ -365,104 +451,104 @@ test_main(void)
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
-	       "aaaaaa"),
-	    LDATA("This is a test using a larger than block-size ke"
+	       "aaaaaa",
+	    "This is a test using a larger than block-size ke"
 		  "y and a larger than block-size data. The key nee"
 		  "ds to be hashed before being used by the HMAC al"
-		  "gorithm."),
-	    H("3a854166ac5d9f023f54d517d0b39dbd"
-	      "946770db9c2b95c9f6f565d1"));
+		  "gorithm.",
+	    "3a854166ac5d9f023f54d517d0b39dbd"
+	      "946770db9c2b95c9f6f565d1");
 
   /* Additional test vectors, from Daniel Kahn Gillmor */
-  HMAC_TEST(sha224, SHA224_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA(""),
-	    H("d12a49ae38177ffeaa548b2148bb5238"
-	      "60849772d9391e675b103d89"));
+  hmac_test(alg_sha224, SHA224_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "",
+	    "d12a49ae38177ffeaa548b2148bb5238"
+	      "60849772d9391e675b103d89");
   
-  HMAC_TEST(sha224, SHA224_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("a"),
-	    H("b04ff8522f904f553970bfa8ad3f0086"
-	      "bce1e8580affd8a12c94e31a"));
+  hmac_test(alg_sha224, SHA224_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "a",
+	    "b04ff8522f904f553970bfa8ad3f0086"
+	      "bce1e8580affd8a12c94e31a");
   
-  HMAC_TEST(sha224, SHA224_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("38"),
-	    H("afcfb5511f710334f9350f57faec3c08"
-	      "764b4bd126a6840f4347f116"));
+  hmac_test(alg_sha224, SHA224_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "38",
+	    "afcfb5511f710334f9350f57faec3c08"
+	      "764b4bd126a6840f4347f116");
   
-  HMAC_TEST(sha224, SHA224_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("abc"),
-	    H("9df9907af127900c909376893565c6cf"
-	      "2d7db244fdc4277da1e0b679"));
+  hmac_test(alg_sha224, SHA224_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "abc",
+	    "9df9907af127900c909376893565c6cf"
+	      "2d7db244fdc4277da1e0b679");
   
-  HMAC_TEST(sha224, SHA224_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("message digest"),
-	    H("254ebf6b8ddd7a3271b3d9aca1699b0c"
-	      "0bfb7df61e8a114922c88d27"));
+  hmac_test(alg_sha224, SHA224_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "message digest",
+	    "254ebf6b8ddd7a3271b3d9aca1699b0c"
+	      "0bfb7df61e8a114922c88d27");
   
-  HMAC_TEST(sha224, SHA224_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("abcdefghijklmnopqrstuvwxyz"),
-	    H("6ec5bffba5880c3234a6cf257816e4d5"
-	      "35ab178a7f12929769e378fb"));
-
-  HMAC_TEST(sha224, SHA224_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"),
-	    H("5f768179dbb29ca722875d0f461a2e2f"
-	      "597d0210340a84df1a8e9c63"));
-
-  HMAC_TEST(sha224, SHA224_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("12345678901234567890123456789012345678901234567890123456789012345678901234567890"),
                
-	    H("c7667b0d7e56b2b4f6fcc1d8da9e22da"
-	      "a1556f44c47132a87303c6a2"));
+  hmac_test(alg_sha224, SHA224_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "abcdefghijklmnopqrstuvwxyz",
+	    "6ec5bffba5880c3234a6cf257816e4d5"
+	      "35ab178a7f12929769e378fb");
+
+  hmac_test(alg_sha224, SHA224_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
+	    "5f768179dbb29ca722875d0f461a2e2f"
+	      "597d0210340a84df1a8e9c63");
+
+  hmac_test(alg_sha224, SHA224_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "12345678901234567890123456789012345678901234567890123456789012345678901234567890",
 +	    "c7667b0d7e56b2b4f6fcc1d8da9e22da"
+	      "a1556f44c47132a87303c6a2");
 
   /* Test vectors for sha256, from RFC 4231 */
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    HL("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"
-	       "0b0b0b0b"),
-	    LDATA("Hi There"),
-	    H("b0344c61d8db38535ca8afceaf0bf12b"
-	      "881dc200c9833da726e9376c2e32cff7"));
-
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    LDATA("Jefe"),
-	    LDATA("what do ya want for nothing?"),
-	    H("5bdcc146bf60754e6a042426089575c7"
-	      "5a003f089d2739839dec58b964ec3843"));
-
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
-	       "aaaaaaaa"),
-	    HL("dddddddddddddddddddddddddddddddd"
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_KEY,
+	    "0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"
+	       "0b0b0b0b",
+	    "Hi There",
+	    "b0344c61d8db38535ca8afceaf0bf12b"
+	      "881dc200c9833da726e9376c2e32cff7");
+
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_NONE,
+	    "Jefe",
+	    "what do ya want for nothing?",
+	    "5bdcc146bf60754e6a042426089575c7"
+	      "5a003f089d2739839dec58b964ec3843");
+
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
+	    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+	       "aaaaaaaa",
+	    "dddddddddddddddddddddddddddddddd"
 	       "dddddddddddddddddddddddddddddddd"
 	       "dddddddddddddddddddddddddddddddd"
-	       "dddd"),
-	    H("773ea91e36800e46854db8ebd09181a7"
-	      "2959098b3ef8c122d9635514ced565fe"));
-
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    HL("0102030405060708090a0b0c0d0e0f10"
-	       "111213141516171819"),
-	    HL("cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
+	       "dddd",
+	    "773ea91e36800e46854db8ebd09181a7"
+	      "2959098b3ef8c122d9635514ced565fe");
+
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
+	    "0102030405060708090a0b0c0d0e0f10"
+	       "111213141516171819",
+	    "cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
 	       "cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
 	       "cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
-	       "cdcd"),
-	    H("82558a389a443c0ea4cc819899f2083a"
-	      "85f0faa3e578f8077a2e3ff46729665b"));
+	       "cdcd",
+	    "82558a389a443c0ea4cc819899f2083a"
+	      "85f0faa3e578f8077a2e3ff46729665b");
 
-  HMAC_TEST(sha256, 16,
-	    HL("0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c 0c0c0c0c"),
-	    LDATA("Test With Truncation"),
-	    H("a3b6167473100ee06e0c796c2955552b"));
+  hmac_test(alg_sha256, 16, HEX_KEY,
+	    "0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c 0c0c0c0c",
+	    "Test With Truncation",
+	    "a3b6167473100ee06e0c796c2955552b");
 
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_KEY,
+	    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
@@ -470,13 +556,13 @@ test_main(void)
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
-	       "aaaaaa"),
-	    LDATA("Test Using Larger Than Block-Size Key - Hash Key First"),
-	    H("60e431591ee0b67f0d8a26aacbf5b77f"
-	      "8e0bc6213728c5140546040f0ee37f54"));
+	       "aaaaaa",
+	    "Test Using Larger Than Block-Size Key - Hash Key First",
+	    "60e431591ee0b67f0d8a26aacbf5b77f"
+	      "8e0bc6213728c5140546040f0ee37f54");
 
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_KEY,
+	    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
@@ -484,201 +570,201 @@ test_main(void)
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
-	       "aaaaaa"),
-	    LDATA("This is a test using a larger than block-size ke"
+	       "aaaaaa",
+	    "This is a test using a larger than block-size ke"
 		  "y and a larger than block-size data. The key nee"
 		  "ds to be hashed before being used by the HMAC al"
-		  "gorithm."),
-	    H("9b09ffa71b942fcb27635fbcd5b0e944"
-	      "bfdc63644f0713938a7f51535c3a35e2"));
+		  "gorithm.",
+	    "9b09ffa71b942fcb27635fbcd5b0e944"
+	      "bfdc63644f0713938a7f51535c3a35e2");
 
   /* Additional test vectors for sha256, from
      draft-ietf-ipsec-ciph-sha-256-01.txt */
 
   /* Test Case #1: HMAC-SHA-256 with 3-byte input and 32-byte key */
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    HL("0102030405060708 090a0b0c0d0e0f10"
-	       "1112131415161718 191a1b1c1d1e1f20"),
-	    LDATA("abc"),
-	    H("a21b1f5d4cf4f73a 4dd939750f7a066a"
-		 "7f98cc131cb16a66 92759021cfab8181"));
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_KEY,
+	    "0102030405060708 090a0b0c0d0e0f10"
+	       "1112131415161718 191a1b1c1d1e1f20",
+	    "abc",
+	    "a21b1f5d4cf4f73a 4dd939750f7a066a"
+		 "7f98cc131cb16a66 92759021cfab8181");
 
   /* Test Case #2: HMAC-SHA-256 with 56-byte input and 32-byte key */
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    HL("0102030405060708 090a0b0c0d0e0f10"
-	       "1112131415161718 191a1b1c1d1e1f20"),
-	    LDATA("abcdbcdecdefdefgefghfghighijhijk"
-		  "ijkljklmklmnlmnomnopnopq"),
-	    H("104fdc1257328f08 184ba73131c53cae"
-		 "e698e36119421149 ea8c712456697d30"));
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_KEY,
+	    "0102030405060708 090a0b0c0d0e0f10"
+	       "1112131415161718 191a1b1c1d1e1f20",
+	    "abcdbcdecdefdefgefghfghighijhijk"
+		  "ijkljklmklmnlmnomnopnopq",
+	    "104fdc1257328f08 184ba73131c53cae"
+		 "e698e36119421149 ea8c712456697d30");
 
   /* Test Case #3: HMAC-SHA-256 with 112-byte (multi-block) input
      and 32-byte key */
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    HL("0102030405060708 090a0b0c0d0e0f10"
-	       "1112131415161718 191a1b1c1d1e1f20"),
-	    LDATA("abcdbcdecdefdefgefghfghighijhijk"
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_KEY,
+	    "0102030405060708 090a0b0c0d0e0f10"
+	       "1112131415161718 191a1b1c1d1e1f20",
+	    "abcdbcdecdefdefgefghfghighijhijk"
 		  "ijkljklmklmnlmnomnopnopqabcdbcde"
 		  "cdefdefgefghfghighijhijkijkljklm"
-		  "klmnlmnomnopnopq"),
-	    H("470305fc7e40fe34 d3eeb3e773d95aab"
-	      "73acf0fd060447a5 eb4595bf33a9d1a3"));
+		  "klmnlmnomnopnopq",
+	    "470305fc7e40fe34 d3eeb3e773d95aab"
+	      "73acf0fd060447a5 eb4595bf33a9d1a3");
 
   /* Test Case #4:  HMAC-SHA-256 with 8-byte input and 32-byte key */
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    HL("0b0b0b0b0b0b0b0b 0b0b0b0b0b0b0b0b"
-	       "0b0b0b0b0b0b0b0b 0b0b0b0b0b0b0b0b"),
-	    LDATA("Hi There"),
-	    H("198a607eb44bfbc6 9903a0f1cf2bbdc5"
-	      "ba0aa3f3d9ae3c1c 7a3b1696a0b68cf7"));
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_KEY,
+	    "0b0b0b0b0b0b0b0b 0b0b0b0b0b0b0b0b"
+	       "0b0b0b0b0b0b0b0b 0b0b0b0b0b0b0b0b",
+	    "Hi There",
+	    "198a607eb44bfbc6 9903a0f1cf2bbdc5"
+	      "ba0aa3f3d9ae3c1c 7a3b1696a0b68cf7");
 
   /* Test Case #6: HMAC-SHA-256 with 50-byte input and 32-byte key */
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
-	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"),
-	    HL("dddddddddddddddd dddddddddddddddd"
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
+	    "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
+	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa",
+	    "dddddddddddddddd dddddddddddddddd"
 	       "dddddddddddddddd dddddddddddddddd"
 	       "dddddddddddddddd dddddddddddddddd"
-	       "dddd"),
-	    H("cdcb1220d1ecccea 91e53aba3092f962"
-	      "e549fe6ce9ed7fdc 43191fbde45c30b0"));
+	       "dddd",
+	    "cdcb1220d1ecccea 91e53aba3092f962"
+	      "e549fe6ce9ed7fdc 43191fbde45c30b0");
 
   /* Test Case #7: HMAC-SHA-256 with 50-byte input and 37-byte key */
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    HL("0102030405060708 090a0b0c0d0e0f10"
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
+	    "0102030405060708 090a0b0c0d0e0f10"
 	       "1112131415161718 191a1b1c1d1e1f20"
-	       "2122232425"),
-	    HL("cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd"
+	       "2122232425",
+	    "cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd"
 	       "cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd"
 	       "cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd"
-	       "cdcd"),
-	    H("d4633c17f6fb8d74 4c66dee0f8f07455"
-	      "6ec4af55ef079985 41468eb49bd2e917"));
+	       "cdcd",
+	    "d4633c17f6fb8d74 4c66dee0f8f07455"
+	      "6ec4af55ef079985 41468eb49bd2e917");
 
   /* Test Case #8: HMAC-SHA-256 with 20-byte input and 32-byte key */
-  HMAC_TEST(sha256, 16,
-	    HL("0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c"
-	       "0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c"),
-	    LDATA("Test With Truncation"),
-	    H("7546af01841fc09b 1ab9c3749a5f1c17"));
+  hmac_test(alg_sha256, 16, HEX_KEY,
+	    "0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c"
+	       "0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c",
+	    "Test With Truncation",
+	    "7546af01841fc09b 1ab9c3749a5f1c17");
 
   /* Test Case #9: HMAC-SHA-256 with 54-byte input and 80-byte key */
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_KEY,
+	    "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
-	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"),
-	    LDATA("Test Using Larger Than Block-Size Key - Hash Key First"),
-	    H("6953025ed96f0c09 f80a96f78e6538db"
-	      "e2e7b820e3dd970e 7ddd39091b32352f"));
+	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa",
+	    "Test Using Larger Than Block-Size Key - Hash Key First",
+	    "6953025ed96f0c09 f80a96f78e6538db"
+	      "e2e7b820e3dd970e 7ddd39091b32352f");
 
   /* Test Case #10: HMAC-SHA-256 with 73-byte (multi-block) input
      and 80-byte key */
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_KEY,
+	    "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"
-	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa"),
-	    LDATA("Test Using Larger Than Block-Size Key and Larger Than One Block-Size \
                Data"),
-	    H("6355ac22e890d0a3 c8481a5ca4825bc8"
-	      "84d3e7a1ff98a2fc 2ac7d8e064c3b2e6"));
+	       "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa",
+	    "Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data",
+	    "6355ac22e890d0a3 c8481a5ca4825bc8"
+	      "84d3e7a1ff98a2fc 2ac7d8e064c3b2e6");
 
   /* Additional test vectors, from Daniel Kahn Gillmor */
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA(""),
-	    H("5c780648c90d121c50091c3a0c3afc1f"
-	      "4ab847528005d99d9821ad3f341b651a"));
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "",
+	    "5c780648c90d121c50091c3a0c3afc1f"
+	      "4ab847528005d99d9821ad3f341b651a");
   
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("a"),
-	    H("6142364c0646b0cfe426866f21d613e0"
-	      "55a136a7d9b45d85685e080a09cec463"));
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "a",
+	    "6142364c0646b0cfe426866f21d613e0"
+	      "55a136a7d9b45d85685e080a09cec463");
   
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("38"),
-	    H("e49aa7839977e130ad87b63da9d4eb7b"
-	      "263cd5a27c54a7604b6044eb35901171"));
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "38",
+	    "e49aa7839977e130ad87b63da9d4eb7b"
+	      "263cd5a27c54a7604b6044eb35901171");
   
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("abc"),
-	    H("e5ef49f545c7af933a9d18c7c562bc91"
-	      "08583fd5cf00d9e0db351d6d8f8e41bc"));
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "abc",
+	    "e5ef49f545c7af933a9d18c7c562bc91"
+	      "08583fd5cf00d9e0db351d6d8f8e41bc");
   
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("message digest"),
-	    H("373b04877180fea27a41a8fb8f88201c"
-	      "a6268411ee3c80b01a424483eb9156e1"));
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "message digest",
+	    "373b04877180fea27a41a8fb8f88201c"
+	      "a6268411ee3c80b01a424483eb9156e1");
   
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("abcdefghijklmnopqrstuvwxyz"),
-	    H("eb5945d56eefbdb41602946ea6448d53"
-	      "86b08d7d801a87f439fab52f8bb9736e"));
-
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"),
-	    H("3798f363c57afa6edaffe39016ca7bad"
-	      "efd1e670afb0e3987194307dec3197db"));
-
-  HMAC_TEST(sha256, SHA256_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("12345678901234567890123456789012345678901234567890123456789012345678901234567890"),
                
-	    H("c89a7039a62985ff813fe4509b918a43"
-	      "6d7b1ffd8778e2c24dec464849fb6128"));
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "abcdefghijklmnopqrstuvwxyz",
+	    "eb5945d56eefbdb41602946ea6448d53"
+	      "86b08d7d801a87f439fab52f8bb9736e");
+
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
+	    "3798f363c57afa6edaffe39016ca7bad"
+	      "efd1e670afb0e3987194307dec3197db");
+
+  hmac_test(alg_sha256, SHA256_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "12345678901234567890123456789012345678901234567890123456789012345678901234567890",
 +	    "c89a7039a62985ff813fe4509b918a43"
+	      "6d7b1ffd8778e2c24dec464849fb6128");
 
   /* Test vectors for sha384, from RFC 4231 */
-  HMAC_TEST(sha384, SHA384_DIGEST_SIZE,
-	    HL("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"
-	       "0b0b0b0b"),
-	    LDATA("Hi There"),
-	    H("afd03944d84895626b0825f4ab46907f"
+  hmac_test(alg_sha384, SHA384_DIGEST_SIZE, HEX_KEY,
+	    "0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"
+	       "0b0b0b0b",
+	    "Hi There",
+	    "afd03944d84895626b0825f4ab46907f"
 	      "15f9dadbe4101ec682aa034c7cebc59c"
-	      "faea9ea9076ede7f4af152e8b2fa9cb6"));
+	      "faea9ea9076ede7f4af152e8b2fa9cb6");
 
-  HMAC_TEST(sha384, SHA384_DIGEST_SIZE,
-	    LDATA("Jefe"),
-	    LDATA("what do ya want for nothing?"),
-	    H("af45d2e376484031617f78d2b58a6b1b"
+  hmac_test(alg_sha384, SHA384_DIGEST_SIZE, HEX_NONE,
+	    "Jefe",
+	    "what do ya want for nothing?",
+	    "af45d2e376484031617f78d2b58a6b1b"
 	      "9c7ef464f5a01b47e42ec3736322445e"
-	      "8e2240ca5e69e2c78b3239ecfab21649"));
+	      "8e2240ca5e69e2c78b3239ecfab21649");
 
-  HMAC_TEST(sha384, SHA384_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
-	       "aaaaaaaa"),
-	    HL("dddddddddddddddddddddddddddddddd"
+  hmac_test(alg_sha384, SHA384_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
+	    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+	       "aaaaaaaa",
+	    "dddddddddddddddddddddddddddddddd"
 	       "dddddddddddddddddddddddddddddddd"
 	       "dddddddddddddddddddddddddddddddd"
-	       "dddd"),
-	    H("88062608d3e6ad8a0aa2ace014c8a86f"
+	       "dddd",
+	    "88062608d3e6ad8a0aa2ace014c8a86f"
 	      "0aa635d947ac9febe83ef4e55966144b"
-	      "2a5ab39dc13814b94e3ab6e101a34f27"));
+	      "2a5ab39dc13814b94e3ab6e101a34f27");
 
-  HMAC_TEST(sha384, SHA384_DIGEST_SIZE,
-	    HL("0102030405060708090a0b0c0d0e0f10"
-	       "111213141516171819"),
-	    HL("cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
+  hmac_test(alg_sha384, SHA384_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
+	    "0102030405060708090a0b0c0d0e0f10"
+	       "111213141516171819",
+	    "cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
 	       "cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
 	       "cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
-	       "cdcd"),
-	    H("3e8a69b7783c25851933ab6290af6ca7"
+	       "cdcd",
+	    "3e8a69b7783c25851933ab6290af6ca7"
 	      "7a9981480850009cc5577c6e1f573b4e"
-	      "6801dd23c4a7d679ccf8a386c674cffb"));
+	      "6801dd23c4a7d679ccf8a386c674cffb");
 
-  HMAC_TEST(sha384, 16,
-	    HL("0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c 0c0c0c0c"),
-	    LDATA("Test With Truncation"),
-	    H("3abf34c3503b2a23a46efc619baef897"));
+  hmac_test(alg_sha384, 16, HEX_KEY,
+	    "0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c 0c0c0c0c",
+	    "Test With Truncation",
+	    "3abf34c3503b2a23a46efc619baef897");
 
-  HMAC_TEST(sha384, SHA384_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+  hmac_test(alg_sha384, SHA384_DIGEST_SIZE, HEX_KEY,
+	    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
@@ -686,14 +772,14 @@ test_main(void)
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
-	       "aaaaaa"),
-	    LDATA("Test Using Larger Than Block-Size Key - Hash Key First"),
-	    H("4ece084485813e9088d2c63a041bc5b4"
+	       "aaaaaa",
+	    "Test Using Larger Than Block-Size Key - Hash Key First",
+	    "4ece084485813e9088d2c63a041bc5b4"
 	      "4f9ef1012a2b588f3cd11f05033ac4c6"
-	      "0c2ef6ab4030fe8296248df163f44952"));
+	      "0c2ef6ab4030fe8296248df163f44952");
 
-  HMAC_TEST(sha384, SHA384_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+  hmac_test(alg_sha384, SHA384_DIGEST_SIZE, HEX_KEY,
+	    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
@@ -701,64 +787,64 @@ test_main(void)
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
-	       "aaaaaa"),
-	    LDATA("This is a test using a larger than block-size ke"
+	       "aaaaaa",
+	    "This is a test using a larger than block-size ke"
 		  "y and a larger than block-size data. The key nee"
 		  "ds to be hashed before being used by the HMAC al"
-		  "gorithm."),
-	    H("6617178e941f020d351e2f254e8fd32c"
+		  "gorithm.",
+	    "6617178e941f020d351e2f254e8fd32c"
 	      "602420feb0b8fb9adccebb82461e99c5"
-	      "a678cc31e799176d3860e6110c46523e"));
+	      "a678cc31e799176d3860e6110c46523e");
 
   /* Test vectors for sha512, from RFC 4231 */
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    HL("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"
-	       "0b0b0b0b"),
-	    LDATA("Hi There"),
-	    H("87aa7cdea5ef619d4ff0b4241a1d6cb0"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, HEX_KEY,
+	    "0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"
+	       "0b0b0b0b",
+	    "Hi There",
+	    "87aa7cdea5ef619d4ff0b4241a1d6cb0"
 	      "2379f4e2ce4ec2787ad0b30545e17cde"
 	      "daa833b7d6b8a702038b274eaea3f4e4"
-	      "be9d914eeb61f1702e696c203a126854"));
+	      "be9d914eeb61f1702e696c203a126854");
 
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    LDATA("Jefe"),
-	    LDATA("what do ya want for nothing?"),
-	    H("164b7a7bfcf819e2e395fbe73b56e0a3"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, HEX_NONE,
+	    "Jefe",
+	    "what do ya want for nothing?",
+	    "164b7a7bfcf819e2e395fbe73b56e0a3"
 	      "87bd64222e831fd610270cd7ea250554"
 	      "9758bf75c05a994a6d034f65f8f0e6fd"
-	      "caeab1a34d4a6b4b636e070a38bce737"));
+	      "caeab1a34d4a6b4b636e070a38bce737");
 
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
-	       "aaaaaaaa"),
-	    HL("dddddddddddddddddddddddddddddddd"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
+	    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+	       "aaaaaaaa",
+	    "dddddddddddddddddddddddddddddddd"
 	       "dddddddddddddddddddddddddddddddd"
 	       "dddddddddddddddddddddddddddddddd"
-	       "dddd"),
-	    H("fa73b0089d56a284efb0f0756c890be9"
+	       "dddd",
+	    "fa73b0089d56a284efb0f0756c890be9"
 	      "b1b5dbdd8ee81a3655f83e33b2279d39"
 	      "bf3e848279a722c806b485a47e67c807"
-	      "b946a337bee8942674278859e13292fb"));
+	      "b946a337bee8942674278859e13292fb");
 
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    HL("0102030405060708090a0b0c0d0e0f10"
-	       "111213141516171819"),
-	    HL("cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
+	    "0102030405060708090a0b0c0d0e0f10"
+	       "111213141516171819",
+	    "cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
 	       "cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
 	       "cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
-	       "cdcd"),
-	    H("b0ba465637458c6990e5a8c5f61d4af7"
+	       "cdcd",
+	    "b0ba465637458c6990e5a8c5f61d4af7"
 	      "e576d97ff94b872de76f8050361ee3db"
 	      "a91ca5c11aa25eb4d679275cc5788063"
-	      "a5f19741120c4f2de2adebeb10a298dd"));
+	      "a5f19741120c4f2de2adebeb10a298dd");
 
-  HMAC_TEST(sha512, 16,
-	    HL("0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c 0c0c0c0c"),
-	    LDATA("Test With Truncation"),
-	    H("415fad6271580a531d4179bc891d87a6"));
+  hmac_test(alg_sha512, 16, HEX_KEY,
+	    "0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c 0c0c0c0c",
+	    "Test With Truncation",
+	    "415fad6271580a531d4179bc891d87a6");
 
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, HEX_KEY,
+	    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
@@ -766,15 +852,15 @@ test_main(void)
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
-	       "aaaaaa"),
-	    LDATA("Test Using Larger Than Block-Size Key - Hash Key First"),
-	    H("80b24263c7c1a3ebb71493c1dd7be8b4"
+	       "aaaaaa",
+	    "Test Using Larger Than Block-Size Key - Hash Key First",
+	    "80b24263c7c1a3ebb71493c1dd7be8b4"
 	      "9b46d1f41b4aeec1121b013783f8f352"
 	      "6b56d037e05f2598bd0fd2215d6a1e52"
-	      "95e64f73f63f0aec8b915a985d786598"));
+	      "95e64f73f63f0aec8b915a985d786598");
 
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, HEX_KEY,
+	    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
@@ -782,122 +868,122 @@ test_main(void)
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
-	       "aaaaaa"),
-	    LDATA("This is a test using a larger than block-size ke"
+	       "aaaaaa",
+	    "This is a test using a larger than block-size ke"
 		  "y and a larger than block-size data. The key nee"
 		  "ds to be hashed before being used by the HMAC al"
-		  "gorithm."),
-	    H("e37b6a775dc87dbaa4dfa9f96e5e3ffd"
+		  "gorithm.",
+	    "e37b6a775dc87dbaa4dfa9f96e5e3ffd"
 	      "debd71f8867289865df5a32d20cdc944"
 	      "b6022cac3c4982b10d5eeb55c3e4de15"
-	      "134676fb6de0446065c97440fa8c6a58"));
+	      "134676fb6de0446065c97440fa8c6a58");
 
   /* Additional test vectors, from Daniel Kahn Gillmor */
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA(""),
-	    H("34316413c2d6940572d0bbbf099d529d"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "",
+	    "34316413c2d6940572d0bbbf099d529d"
 	      "148b424533cf562bc1b365f530e21a31"
 	      "799fc51cef78060cc6f448a8e5d780c2"
-	      "6cdf20d4c3e6f27fe5ef576bbd05e855"));
+	      "6cdf20d4c3e6f27fe5ef576bbd05e855");
   
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("a"),
-	    H("cf1948507378bc3ab58cb6ec87f4d456"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "a",
+	    "cf1948507378bc3ab58cb6ec87f4d456"
 	      "b90d3298395c29873f1ded1e111b50fe"
 	      "c336ed24684bf19716efc309212f37aa"
-	      "715cfb9ecccf3af13691ded167b4b336"));
+	      "715cfb9ecccf3af13691ded167b4b336");
   
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("38"),
-	    H("b8201784216ce01b83cdd282616c6e89"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "38",
+	    "b8201784216ce01b83cdd282616c6e89"
 	      "644c6dfd1269ed8580bbc39b92add364"
 	      "c2b2a2018cffb1915e8625e473b67d0f"
-	      "e54a50e475dfa0e2b1a97bac1383792c"));
+	      "e54a50e475dfa0e2b1a97bac1383792c");
   
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("abc"),
-	    H("f097ee08b8c44e847a384f9fd645e35e"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "abc",
+	    "f097ee08b8c44e847a384f9fd645e35e"
 	      "4816baa9791ba39d3dc611210500b044"
 	      "873ee296bf1047dc06daa201a5767192"
-	      "5b73b4ea59c60114881c8287d0699c83"));
+	      "5b73b4ea59c60114881c8287d0699c83");
   
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("message digest"),
-	    H("921a441a884b83c76a8526da8e60d60d"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "message digest",
+	    "921a441a884b83c76a8526da8e60d60d"
 	      "17ded4eee5c29375e0d93717669a4c3e"
 	      "eba7473e95f7c1a2a85afc24a0adbc4d"
-	      "6c2bdd6ca6cab8b18d19f82d4a6c51bc"));
+	      "6c2bdd6ca6cab8b18d19f82d4a6c51bc");
   
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("abcdefghijklmnopqrstuvwxyz"),
-	    H("640054c96f35815095617d0a8c956066"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "abcdefghijklmnopqrstuvwxyz",
+	    "640054c96f35815095617d0a8c956066"
 	      "1a6ff46bfb39110333b2c52c8866abfb"
 	      "59d9152c9b0948c1ed65c3fd72a8fb82"
-	      "190acc8830770afe5b0c5b6414c75a77"));
+	      "190acc8830770afe5b0c5b6414c75a77");
 
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"),
-	    H("835a4f5b3750b4c1fccfa88da2f746a4"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
+	    "835a4f5b3750b4c1fccfa88da2f746a4"
 	      "900160c9f18964309bb736c13b59491b"
 	      "8e32d37b724cc5aebb0f554c6338a3b5"
-	      "94c4ba26862b2dadb59b7ede1d08d53e"));
+	      "94c4ba26862b2dadb59b7ede1d08d53e");
 
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    LDATA("monkey monkey monkey monkey"),
-	    LDATA("12345678901234567890123456789012345678901234567890123456789012345678901234567890"),
                
-	    H("fdf83dc879e3476c8e8aceff2bf6fece"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, HEX_NONE,
+	    "monkey monkey monkey monkey",
+	    "12345678901234567890123456789012345678901234567890123456789012345678901234567890",
 +	    "fdf83dc879e3476c8e8aceff2bf6fece"
 	      "2e4f39c7e1a167845465bb549dfa5ffe"
 	      "997e6c7cf3720eae51ed2b00ad2a8225"
-	      "375092290edfa9d48ec7e4bc8e276088"));
+	      "375092290edfa9d48ec7e4bc8e276088");
 
   /* Additional test vectors, from
      draft-kelly-ipsec-ciph-sha2-01.txt */
 
   /* Test case AUTH512-1: */
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    HL("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, HEX_KEY,
+	    "0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"
 	       "0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"
 	       "0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"
-	       "0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"),
-	    LDATA("Hi There"),
-	    H("637edc6e01dce7e6742a99451aae82df"
+	       "0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b",
+	    "Hi There",
+	    "637edc6e01dce7e6742a99451aae82df"
 	      "23da3e92439e590e43e761b33e910fb8"
 	      "ac2878ebd5803f6f0b61dbce5e251ff8"
-	      "789a4722c1be65aea45fd464e89f8f5b"));
+	      "789a4722c1be65aea45fd464e89f8f5b");
 
   /* Test case AUTH512-2: */
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    LDATA("JefeJefeJefeJefe"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, HEX_NONE,
+	    "JefeJefeJefeJefe"
 		  "JefeJefeJefeJefe"
 		  "JefeJefeJefeJefe"
-		  "JefeJefeJefeJefe"),	    
-	    LDATA("what do ya want for nothing?"),
-	    H("cb370917ae8a7ce28cfd1d8f4705d614"
+		  "JefeJefeJefeJefe",
+	    "what do ya want for nothing?",
+	    "cb370917ae8a7ce28cfd1d8f4705d614"
 	      "1c173b2a9362c15df235dfb251b15454"
 	      "6aa334ae9fb9afc2184932d8695e397b"
-	      "fa0ffb93466cfcceaae38c833b7dba38"));
+	      "fa0ffb93466cfcceaae38c833b7dba38");
 
   /* Test case AUTH512-3: */
-  HMAC_TEST(sha512, SHA512_DIGEST_SIZE,
-	    HL("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+  hmac_test(alg_sha512, SHA512_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
+	    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
 	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
-	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
-	    HL("dddddddddddddddddddddddddddddddd"
+	       "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
+	    "dddddddddddddddddddddddddddddddd"
 	       "dddddddddddddddddddddddddddddddd"
 	       "dddddddddddddddddddddddddddddddd"
-	       "dddd"),
-	    H("2ee7acd783624ca9398710f3ee05ae41"
+	       "dddd",
+	    "2ee7acd783624ca9398710f3ee05ae41"
 	      "b9f9b0510c87e49e586cc9bf961733d8"
 	      "623c7b55cebefccf02d5581acc1c9d5f"
-	      "b1ff68a1de45509fbe4da9a433922655"));
+	      "b1ff68a1de45509fbe4da9a433922655");
 
   /* Test case AUTH512-3 from same document seems broken. */
   
diff --git a/testsuite/md2-test.c b/testsuite/md2-test.c
index 8ab45c1..3d4a064 100644
--- a/testsuite/md2-test.c
+++ b/testsuite/md2-test.c
@@ -5,23 +5,23 @@ int
 test_main(void)
 {
   /* Testcases from RFC 1319 */
-  test_hash(&amp;nettle_md2, 0, "",
-	    H("8350e5a3e24c153df2275c9f80692773"));
-  test_hash(&amp;nettle_md2, LDATA("a"),
-	    H("32ec01ec4a6dac72c0ab96fb34c0b5d1"));
-  test_hash(&amp;nettle_md2, LDATA("abc"),
-	    H("da853b0d3f88d99b30283a69e6ded6bb"));
-  test_hash(&amp;nettle_md2, LDATA("message digest"),
-	    H("ab4f496bfb2a530b219ff33031fe06b0"));
-  test_hash(&amp;nettle_md2, LDATA("abcdefghijklmnopqrstuvwxyz"),
-	    H("4e8ddff3650292ab5a4108c3aa47940b"));
+  test_hash(&amp;nettle_md2, "",
+	    "8350e5a3e24c153df2275c9f80692773");
+  test_hash(&amp;nettle_md2, "a",
+	    "32ec01ec4a6dac72c0ab96fb34c0b5d1");
+  test_hash(&amp;nettle_md2, "abc",
+	    "da853b0d3f88d99b30283a69e6ded6bb");
+  test_hash(&amp;nettle_md2, "message digest",
+	    "ab4f496bfb2a530b219ff33031fe06b0");
+  test_hash(&amp;nettle_md2, "abcdefghijklmnopqrstuvwxyz",
+	    "4e8ddff3650292ab5a4108c3aa47940b");
   test_hash(&amp;nettle_md2,
-	    LDATA("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
-		  "0123456789"),
-	    H("da33def2a42df13975352846c30338cd"));
-  test_hash(&amp;nettle_md2, LDATA("1234567890123456789012345678901234567890"
-			       "1234567890123456789012345678901234567890"),
-	    H("d5976f79d83d3a0dc9806c3c66f3efd8"));
+	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
+		  "0123456789",
+	    "da33def2a42df13975352846c30338cd");
+  test_hash(&amp;nettle_md2, "1234567890123456789012345678901234567890"
+			       "1234567890123456789012345678901234567890",
+	    "d5976f79d83d3a0dc9806c3c66f3efd8");
 
   SUCCESS();
 }
diff --git a/testsuite/md4-test.c b/testsuite/md4-test.c
index 208456d..188c9d1 100644
--- a/testsuite/md4-test.c
+++ b/testsuite/md4-test.c
@@ -4,35 +4,36 @@
 int
 test_main(void)
 {
+// #define x) (sizeof(x) - 1), x
   /* Testcases from RFC 1320 */
-  test_hash(&amp;nettle_md4, LDATA(""),
-	    H("31d6cfe0d16ae931b73c59d7e0c089c0"));
-  test_hash(&amp;nettle_md4, LDATA("a"),
-	    H("bde52cb31de33e46245e05fbdbd6fb24"));
-  test_hash(&amp;nettle_md4, LDATA("abc"),
-	    H("a448017aaf21d8525fc10ae87aa6729d"));
-  test_hash(&amp;nettle_md4, LDATA("message digest"),
-	    H("d9130a8164549fe818874806e1c7014b"));
-  test_hash(&amp;nettle_md4, LDATA("abcdefghijklmnopqrstuvwxyz"),
-	    H("d79e1c308aa5bbcdeea8ed63df412da9"));
+  test_hash(&amp;nettle_md4, "",
+	    "31d6cfe0d16ae931b73c59d7e0c089c0");
+  test_hash(&amp;nettle_md4, "a",
+	    "bde52cb31de33e46245e05fbdbd6fb24");
+  test_hash(&amp;nettle_md4, "abc",
+	    "a448017aaf21d8525fc10ae87aa6729d");
+  test_hash(&amp;nettle_md4, "message digest",
+	    "d9130a8164549fe818874806e1c7014b");
+  test_hash(&amp;nettle_md4, "abcdefghijklmnopqrstuvwxyz",
+	    "d79e1c308aa5bbcdeea8ed63df412da9");
   test_hash(&amp;nettle_md4,
-	    LDATA("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
-		  "0123456789"),
-	    H("043f8582f241db351ce627e153e7f0e4"));
+	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
+		  "0123456789",
+	    "043f8582f241db351ce627e153e7f0e4");
   test_hash(&amp;nettle_md4,
-	    LDATA("12345678901234567890123456789012345678901234567890"
-		  "123456789012345678901234567890"),
-	    H("e33b4ddc9c38f2199c3e7b164fcc0536"));
+	    "12345678901234567890123456789012345678901234567890"
+		  "123456789012345678901234567890",
+	    "e33b4ddc9c38f2199c3e7b164fcc0536");
 
   /* Additional test vectors, from Daniel Kahn Gillmor */
-  test_hash(&amp;nettle_md4, LDATA("38"),
-	    H("ae9c7ebfb68ea795483d270f5934b71d"));
-  test_hash(&amp;nettle_md4, LDATA("abc"),
-	    H("a448017aaf21d8525fc10ae87aa6729d"));
-  test_hash(&amp;nettle_md4, LDATA("message digest"),
-	    H("d9130a8164549fe818874806e1c7014b"));
-  test_hash(&amp;nettle_md4, LDATA("abcdefghijklmnopqrstuvwxyz"),
-	    H("d79e1c308aa5bbcdeea8ed63df412da9"));
+  test_hash(&amp;nettle_md4, "38",
+	    "ae9c7ebfb68ea795483d270f5934b71d");
+  test_hash(&amp;nettle_md4, "abc",
+	    "a448017aaf21d8525fc10ae87aa6729d");
+  test_hash(&amp;nettle_md4, "message digest",
+	    "d9130a8164549fe818874806e1c7014b");
+  test_hash(&amp;nettle_md4, "abcdefghijklmnopqrstuvwxyz",
+	    "d79e1c308aa5bbcdeea8ed63df412da9");
 
   SUCCESS();
 }
diff --git a/testsuite/md5-compat-test.c b/testsuite/md5-compat-test.c
index bffb623..0b5e6d1 100644
--- a/testsuite/md5-compat-test.c
+++ b/testsuite/md5-compat-test.c
@@ -1,60 +1,53 @@
 #include "testutils.h"
 #include "md5-compat.h"
 
-int
-test_main(void)
+static void
+test_md5_compat(const uint8_t *data, const uint8_t *result_hex)
 {
+  const uint8_t *result = decode_hex_dup(result_hex);
+
   MD5_CTX ctx;
   unsigned char digest[MD5_DIGEST_SIZE];
 
   MD5Init(&amp;ctx);
-  MD5Final(digest, &amp;ctx);
-  if (!MEMEQ(MD5_DIGEST_SIZE, digest, H("D41D8CD98F00B204 E9800998ECF8427E")))
-    FAIL();
-
-  MD5Init(&amp;ctx);
-  MD5Update(&amp;ctx, "a", 1);
+  MD5Update(&amp;ctx, data, strlen(data));
   MD5Final(digest, &amp;ctx);
 
-  if (!MEMEQ(MD5_DIGEST_SIZE, digest, H("0CC175B9C0F1B6A8 31C399E269772661")))
+  if (!MEMEQ(MD5_DIGEST_SIZE, digest, result))
     FAIL();
 
-  MD5Init(&amp;ctx);
-  MD5Update(&amp;ctx, "abc", 3);
-  MD5Final(digest, &amp;ctx);
-
-  if (!MEMEQ(MD5_DIGEST_SIZE, digest, H("900150983cd24fb0 D6963F7D28E17F72")))
-    FAIL();
+  free((void *)result);
+}
 
-  MD5Init(&amp;ctx);
-  MD5Update(&amp;ctx, "message digest", 14);
-  MD5Final(digest, &amp;ctx);
+int test_main(void)
+{
+  test_md5_compat("",
+	    "D41D8CD98F00B204 E9800998ECF8427E");
 
-  if (!MEMEQ(MD5_DIGEST_SIZE, digest, H("F96B697D7CB7938D 525A2F31AAF161D0")))
-    FAIL();
+  test_md5_compat("a",
+	    "0CC175B9C0F1B6A8 31C399E269772661");
 
-  MD5Init(&amp;ctx);
-  MD5Update(&amp;ctx, "abcdefghijklmnopqrstuvwxyz", 26);
-  MD5Final(digest, &amp;ctx);
+  test_md5_compat("abc",
+	    "900150983cd24fb0 D6963F7D28E17F72");
 
-  if (!MEMEQ(MD5_DIGEST_SIZE, digest, H("C3FCD3D76192E400 7DFB496CCA67E13B")))
-    FAIL();
+  test_md5_compat("message digest",
+	    "F96B697D7CB7938D 525A2F31AAF161D0");
 
-  MD5Init(&amp;ctx);
-  MD5Update(&amp;ctx, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", \
                62);
-  MD5Final(digest, &amp;ctx);
+  test_md5_compat("abcdefghijklmnopqrstuvwxyz",
+	    "C3FCD3D76192E400 7DFB496CCA67E13B");
 
-  if (!MEMEQ(MD5_DIGEST_SIZE, digest, H("D174AB98D277D9F5 A5611C2C9F419D9F")))
-    FAIL();
+  test_md5_compat("ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+	    "abcdefghijklmnopqrstuvwxyz"
+	    "0123456789",
+	    "D174AB98D277D9F5 A5611C2C9F419D9F");
 
-  MD5Init(&amp;ctx);
-  MD5Update(&amp;ctx, "1234567890123456789012345678901234567890"
+  test_md5_compat("1234567890123456789012345678901234567890"
 	    "1234567890123456789012345678901234567890",
-	    80);
-  MD5Final(digest, &amp;ctx);
+	    "57EDF4A22BE3C955 AC49DA2E2107B67A");
 
-  if (!MEMEQ(MD5_DIGEST_SIZE, digest, H("57EDF4A22BE3C955 AC49DA2E2107B67A")))
-    FAIL();
+  /* Additional test vector, from Daniel Kahn Gillmor */
+  test_md5_compat("38",
+	    "a5771bce93e200c3 6f7cd9dfd0e5deaa");
 
   SUCCESS();
 }
diff --git a/testsuite/md5-test.c b/testsuite/md5-test.c
index 995f304..51ad024 100644
--- a/testsuite/md5-test.c
+++ b/testsuite/md5-test.c
@@ -4,35 +4,35 @@
 int
 test_main(void)
 {
-  test_hash(&amp;nettle_md5, 0, "",
-	    H("D41D8CD98F00B204 E9800998ECF8427E"));
+  test_hash(&amp;nettle_md5, "",
+	    "D41D8CD98F00B204 E9800998ECF8427E");
 
-  test_hash(&amp;nettle_md5, 1, "a",
-	    H("0CC175B9C0F1B6A8 31C399E269772661"));
+  test_hash(&amp;nettle_md5, "a",
+	    "0CC175B9C0F1B6A8 31C399E269772661");
 	    
-  test_hash(&amp;nettle_md5, 3, "abc",
-	    H("900150983cd24fb0 D6963F7D28E17F72"));
+  test_hash(&amp;nettle_md5, "abc",
+	    "900150983cd24fb0 D6963F7D28E17F72");
 
-  test_hash(&amp;nettle_md5, 14, "message digest",
-	    H("F96B697D7CB7938D 525A2F31AAF161D0"));
+  test_hash(&amp;nettle_md5, "message digest",
+	    "F96B697D7CB7938D 525A2F31AAF161D0");
   
-  test_hash(&amp;nettle_md5, 26, "abcdefghijklmnopqrstuvwxyz",
-	    H("C3FCD3D76192E400 7DFB496CCA67E13B"));
+  test_hash(&amp;nettle_md5, "abcdefghijklmnopqrstuvwxyz",
+	    "C3FCD3D76192E400 7DFB496CCA67E13B");
   
-  test_hash(&amp;nettle_md5, 62,
+  test_hash(&amp;nettle_md5,
 	    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
 	    "abcdefghijklmnopqrstuvwxyz"
 	    "0123456789",
-	    H("D174AB98D277D9F5 A5611C2C9F419D9F"));
+	    "D174AB98D277D9F5 A5611C2C9F419D9F");
 
-  test_hash(&amp;nettle_md5, 80,
+  test_hash(&amp;nettle_md5,
 	    "1234567890123456789012345678901234567890"
 	    "1234567890123456789012345678901234567890",
-	    H("57EDF4A22BE3C955 AC49DA2E2107B67A"));
+	    "57EDF4A22BE3C955 AC49DA2E2107B67A");
 
   /* Additional test vector, from Daniel Kahn Gillmor */
-  test_hash(&amp;nettle_md5, LDATA("38"),
-	    H("a5771bce93e200c3 6f7cd9dfd0e5deaa"));
+  test_hash(&amp;nettle_md5, "38",
+	    "a5771bce93e200c3 6f7cd9dfd0e5deaa");
 
   /* Collisions, reported by Xiaoyun Wang1, Dengguo Feng2, Xuejia
      Lai3, Hongbo Yu1, http://eprint.iacr.org/2004/199. */
@@ -82,17 +82,17 @@ test_main(void)
   
 #define H1 "79054025 255fb1a2 6e4bc422 aef54eb4"
   
-  test_hash(&amp;nettle_md5,
-	    HL(M0 N0), H(H0));
+  test_hash_hex(&amp;nettle_md5,
+	    M0 N0, H0);
 
-  test_hash(&amp;nettle_md5,
-	    HL(M1 N1), H(H0));
+  test_hash_hex(&amp;nettle_md5,
+	    M1 N1, H0);
 
-  test_hash(&amp;nettle_md5,
-	    HL(M0 N2), H(H1));
+  test_hash_hex(&amp;nettle_md5,
+	    M0 N2, H1);
 
-  test_hash(&amp;nettle_md5,
-	    HL(M1 N3), H(H1));
+  test_hash_hex(&amp;nettle_md5,
+	    M1 N3, H1);
 
   SUCCESS();
 }
diff --git a/testsuite/memxor-test.c b/testsuite/memxor-test.c
index 8c191f3..8c4388d 100644
--- a/testsuite/memxor-test.c
+++ b/testsuite/memxor-test.c
@@ -145,5 +145,9 @@ test_main(void)
 	    test_memxor3 (a, b, c, size[i], align_dst, align_a, align_b);
 	}
 
+  free((void *)c);
+  free((void *)b);
+  free((void *)a);
+
   SUCCESS();
 }
diff --git a/testsuite/random-prime-test.c b/testsuite/random-prime-test.c
index 6fdb449..ac37576 100644
--- a/testsuite/random-prime-test.c
+++ b/testsuite/random-prime-test.c
@@ -23,6 +23,7 @@ test_main(void)
       ASSERT (mpz_sizeinbase (p, 2) == bits);
       ASSERT (mpz_probab_prime_p(p, 25));
     }
+  mpz_clear(p);
 
   SUCCESS();
 }
diff --git a/testsuite/ripemd160-test.c b/testsuite/ripemd160-test.c
index 1237b70..4d30612 100644
--- a/testsuite/ripemd160-test.c
+++ b/testsuite/ripemd160-test.c
@@ -4,34 +4,34 @@
 int
 test_main(void)
 {
-  test_hash(&amp;nettle_ripemd160, 0, "",
-      H("9c1185a5c5e9fc54612808977ee8f548b2258d31"));
+  test_hash(&amp;nettle_ripemd160, "",
+      "9c1185a5c5e9fc54612808977ee8f548b2258d31");
 
-  test_hash(&amp;nettle_ripemd160, 1, "a",
-      H("0bdc9d2d256b3ee9daae347be6f4dc835a467ffe"));
+  test_hash(&amp;nettle_ripemd160, "a",
+      "0bdc9d2d256b3ee9daae347be6f4dc835a467ffe");
 
-  test_hash(&amp;nettle_ripemd160, 3, "abc",
-      H("8eb208f7e05d987a9b044a8e98c6b087f15a0bfc"));
+  test_hash(&amp;nettle_ripemd160, "abc",
+      "8eb208f7e05d987a9b044a8e98c6b087f15a0bfc");
 
-  test_hash(&amp;nettle_ripemd160, 26, "abcdefghijklmnopqrstuvwxyz",
-      H("f71c27109c692c1b56bbdceb5b9d2865b3708dbc"));
+  test_hash(&amp;nettle_ripemd160, "abcdefghijklmnopqrstuvwxyz",
+      "f71c27109c692c1b56bbdceb5b9d2865b3708dbc");
 
-  test_hash(&amp;nettle_ripemd160, 14, "message digest",
-      H("5d0689ef49d2fae572b881b123a85ffa21595f36"));
+  test_hash(&amp;nettle_ripemd160, "message digest",
+      "5d0689ef49d2fae572b881b123a85ffa21595f36");
 
-  test_hash(&amp;nettle_ripemd160, 62,
+  test_hash(&amp;nettle_ripemd160,
       "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
       "abcdefghijklmnopqrstuvwxyz0123456789",
-      H("b0e20b6e3116640286ed3a87a5713079b21f5189"));
+      "b0e20b6e3116640286ed3a87a5713079b21f5189");
 
-  test_hash(&amp;nettle_ripemd160,  80,
+  test_hash(&amp;nettle_ripemd160,
       "1234567890123456789012345678901234567890"
       "1234567890123456789012345678901234567890",
-      H("9b752e45573d4b39f4dbd3323cab82bf63326bfb"));
+      "9b752e45573d4b39f4dbd3323cab82bf63326bfb");
 
   /* Additional test vector, from Daniel Kahn Gillmor */
-  test_hash(&amp;nettle_ripemd160, LDATA("38"),
-      H("6b2d075b1cd34cd1c3e43a995f110c55649dad0e"));
+  test_hash(&amp;nettle_ripemd160, "38",
+      "6b2d075b1cd34cd1c3e43a995f110c55649dad0e");
 
   SUCCESS();
 }
diff --git a/testsuite/rsa2sexp-test.c b/testsuite/rsa2sexp-test.c
index 596a978..00cfb8d 100644
--- a/testsuite/rsa2sexp-test.c
+++ b/testsuite/rsa2sexp-test.c
@@ -57,7 +57,7 @@ test_main(void)
       print_hex(buffer.size, buffer.contents);  
     }
   
-  ASSERT(MEMEQH(buffer.size, buffer.contents,
+  ASSERT(memeq_hex(buffer.size, buffer.contents,
 		"2831313a707269766174652d6b657928"
 		"333a72736128313a6e36333a085c3408"
 		"989acae4faec3cbbad91c90d34c1d259"
@@ -91,7 +91,8 @@ test_main(void)
       printf("public:");
       print_hex(buffer.size, buffer.contents);  
     }
-  ASSERT(MEMEQH(buffer.size, buffer.contents,
+
+  ASSERT(memeq_hex(buffer.size, buffer.contents,
 		"2831303a7075626c69632d6b65792839"
 		"3a7273612d706b63733128313a6e3633"
 		"3a085c3408989acae4faec3cbbad91c9"
@@ -103,5 +104,7 @@ test_main(void)
   rsa_public_key_clear(&amp;pub);
   rsa_private_key_clear(&amp;priv);
   
+  nettle_buffer_clear(&amp;buffer);
+
   SUCCESS();
 }
diff --git a/testsuite/salsa20-test.c b/testsuite/salsa20-test.c
index 7a246b9..af61dc9 100644
--- a/testsuite/salsa20-test.c
+++ b/testsuite/salsa20-test.c
@@ -13,18 +13,23 @@ memzero_p (const uint8_t *p, size_t n)
   return 1;
 }
 
-/* The ecrypt testcases encrypt 512 zero bytes (8 blocks), then give
-   the xor of all blocks, and the data for block 0 (0-43), 3,4
-   (192-319), 7 (448-511) */
+/* The ecrypt testcases encrypt 512 zero bytes (8 blocks, then give
+   the xor of all blocks, and the data for block 0 (0-43, 3,4
+   (192-319, 7 (448-511) */
 
 #define STREAM_LENGTH 512
 static void
-test_salsa20_stream(unsigned key_length,
-		    const uint8_t *key,
-		    const uint8_t *iv,
-		    const uint8_t *ciphertext,
-		    const uint8_t *xor_ref)
+test_salsa20_stream(const uint8_t *key_hex,
+		    const uint8_t *iv_hex,
+		    const uint8_t *ciphertext_hex,
+		    const uint8_t *xor_ref_hex)
 {
+  unsigned key_length = decode_hex_length(key_hex);
+  const uint8_t *key = decode_hex_dup(key_hex);
+  const uint8_t *iv = decode_hex_dup(iv_hex);
+  const uint8_t *ciphertext = decode_hex_dup(ciphertext_hex);
+  const uint8_t *xor_ref = decode_hex_dup(xor_ref_hex);
+
   struct salsa20_ctx ctx;
   uint8_t data[STREAM_LENGTH + 1];
   uint8_t stream[STREAM_LENGTH + 1];
@@ -111,16 +116,26 @@ test_salsa20_stream(unsigned key_length,
 	  FAIL();
 	}
     }
+
+  free((void *)xor_ref);
+  free((void *)ciphertext);
+  free((void *)iv);
+  free((void *)key);
 }
 
 static void
-test_salsa20(unsigned key_length,
-	     const uint8_t *key,
-	     const uint8_t *iv,
-	     unsigned length,
-	     const uint8_t *cleartext,
-	     const uint8_t *ciphertext)
+test_salsa20(const uint8_t *key_hex,
+	     const uint8_t *iv_hex,
+	     const uint8_t *cleartext_hex,
+	     const uint8_t *ciphertext_hex)
 {
+  unsigned key_length = decode_hex_length(key_hex);
+  const uint8_t *key = decode_hex_dup(key_hex);
+  const uint8_t *iv = decode_hex_dup(iv_hex);
+  unsigned length = decode_hex_length(cleartext_hex);
+  const uint8_t *cleartext = decode_hex_dup(cleartext_hex);
+  const uint8_t *ciphertext = decode_hex_dup(ciphertext_hex);
+
   struct salsa20_ctx ctx;
   uint8_t *data = xalloc(length + 1);
 
@@ -163,6 +178,10 @@ test_salsa20(unsigned key_length,
     }
 
   free(data);
+  free((void *)ciphertext);
+  free((void *)cleartext);
+  free((void *)iv);
+  free((void *)key);
 }
   
 int
@@ -170,42 +189,42 @@ test_main(void)
 {
   /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/full/verified.test-vectors?logsort=rev&amp;rev=210&amp;view=markup \
*/  
-  test_salsa20(HL("80000000 00000000 00000000 00000000"),
-	       H("00000000 00000000"),
-	       HL("00000000 00000000"),
-	       H("4DFA5E48 1DA23EA0"));
-
-  test_salsa20(HL("00000000 00000000 00000000 00000000"),
-	       H("80000000 00000000"),
-	       HL("00000000 00000000"),
-	       H("B66C1E44 46DD9557"));
-
-  test_salsa20(HL("0053A6F94C9FF24598EB3E91E4378ADD"),
-	       H("0D74DB42A91077DE"),
-	       HL("00000000 00000000"),
-	       H("05E1E7BE B697D999"));
-
-  test_salsa20(HL("80000000 00000000 00000000 00000000"
-		  "00000000 00000000 00000000 00000000"),
-	       H("00000000 00000000"),
-	       HL("00000000 00000000"),
-	       H("E3BE8FDD 8BECA2E3"));
-
-  test_salsa20(HL("00000000 00000000 00000000 00000000"
-		  "00000000 00000000 00000000 00000000"),
-	       H("80000000 00000000"),
-	       HL("00000000 00000000"),
-	       H("2ABA3DC45B494700"));
-
-  test_salsa20(HL("0053A6F94C9FF24598EB3E91E4378ADD"
-		  "3083D6297CCF2275C81B6EC11467BA0D"),
-	       H("0D74DB42A91077DE"),
-	       HL("00000000 00000000"),
-	       H("F5FAD53F 79F9DF58"));
-
-  test_salsa20_stream(HL("80000000000000000000000000000000"),
-		      H("00000000 00000000"),
-		      H("4DFA5E481DA23EA09A31022050859936"
+  test_salsa20("80000000 00000000 00000000 00000000",
+	       "00000000 00000000",
+	       "00000000 00000000",
+	       "4DFA5E48 1DA23EA0");
+
+  test_salsa20("00000000 00000000 00000000 00000000",
+	       "80000000 00000000",
+	       "00000000 00000000",
+	       "B66C1E44 46DD9557");
+
+  test_salsa20("0053A6F94C9FF24598EB3E91E4378ADD",
+	       "0D74DB42A91077DE",
+	       "00000000 00000000",
+	       "05E1E7BE B697D999");
+
+  test_salsa20("80000000 00000000 00000000 00000000"
+		  "00000000 00000000 00000000 00000000",
+	       "00000000 00000000",
+	       "00000000 00000000",
+	       "E3BE8FDD 8BECA2E3");
+
+  test_salsa20("00000000 00000000 00000000 00000000"
+		  "00000000 00000000 00000000 00000000",
+	       "80000000 00000000",
+	       "00000000 00000000",
+	       "2ABA3DC45B494700");
+
+  test_salsa20("0053A6F94C9FF24598EB3E91E4378ADD"
+		  "3083D6297CCF2275C81B6EC11467BA0D",
+	       "0D74DB42A91077DE",
+	       "00000000 00000000",
+	       "F5FAD53F 79F9DF58");
+
+  test_salsa20_stream("80000000000000000000000000000000",
+		      "00000000 00000000",
+		      "4DFA5E481DA23EA09A31022050859936"
 			"DA52FCEE218005164F267CB65F5CFD7F"
 			"2B4F97E0FF16924A52DF269515110A07"
 			"F9E460BC65EF95DA58F740B7D1DBB0AA"
@@ -220,16 +239,16 @@ test_main(void)
 			"B375703739DACED4DD4059FD71C3C47F"
 			"C2F9939670FAD4A46066ADCC6A564578"
 			"3308B90FFB72BE04A6B147CBE38CC0C3"
-			"B9267C296A92A7C69873F9F263BE9703"),
-		      H("F7A274D268316790A67EC058F45C0F2A"
+			"B9267C296A92A7C69873F9F263BE9703",
+		      "F7A274D268316790A67EC058F45C0F2A"
 			"067A99FCDE6236C0CEF8E056349FE54C"
 			"5F13AC74D2539570FD34FEAB06C57205"
-			"3949B59585742181A5A760223AFA22D4"));
+			"3949B59585742181A5A760223AFA22D4");
 
-  test_salsa20_stream(HL("48494A4B4C4D4E4F5051525354555657"
-			 "58595A5B5C5D5E5F6061626364656667"),
-		      H("0000000000000000"),
-		      H("53AD3698A011F779AD71030F3EFBEBA0"
+  test_salsa20_stream("48494A4B4C4D4E4F5051525354555657"
+			 "58595A5B5C5D5E5F6061626364656667",
+		      "0000000000000000",
+		      "53AD3698A011F779AD71030F3EFBEBA0"
 			"A7EE3C55789681B1591EF33A7BE521ED"
 			"68FC36E58F53FFD6E1369B00E390E973"
 			"F656ACB097E0D603BE59A0B8F7975B98"
@@ -244,11 +263,11 @@ test_main(void)
 			"B505D41E2C207FA1C0A0E93413DDCFFC"
 			"9BECA8030AFFAC2466E56482DA0EF428"
 			"E63880B5021D3051F18679505A2B9D4F"
-			"9B2C5A2D271D276DE3F51DBEBA934436"),
-		      H("7849651A820B1CDFE36D5D6632716534"
+			"9B2C5A2D271D276DE3F51DBEBA934436",
+		      "7849651A820B1CDFE36D5D6632716534"
 			"E0635EDEFD538122D80870B60FB055DB"
 			"637C7CA2B78B116F83AFF46E40F8F71D"
-			"4CD6D2E1B750D5E011D1DF2E80F7210A"));
+			"4CD6D2E1B750D5E011D1DF2E80F7210A");
 
   SUCCESS();
 }
diff --git a/testsuite/serpent-test.c b/testsuite/serpent-test.c
index d9e193b..715482c 100644
--- a/testsuite/serpent-test.c
+++ b/testsuite/serpent-test.c
@@ -19,31 +19,55 @@ decode_hex_reverse (const char *hex)
   return p;
 }
 
-#define RH(x) decode_hex_reverse(x)
-#define RHL(x) decode_hex_length(x), decode_hex_reverse(x)
+void
+test_cipher_reverse(const struct nettle_cipher *cipher,
+	    const uint8_t *key_hex,
+	    const uint8_t *cleartext_hex,
+	    const uint8_t *ciphertext_hex)
+{
+  unsigned key_length = decode_hex_length(key_hex);
+  const uint8_t *key = decode_hex_reverse(key_hex);
+  unsigned cleartext_length = decode_hex_length(cleartext_hex);
+  const uint8_t *cleartext = decode_hex_reverse(cleartext_hex);
+  unsigned ciphertext_length = decode_hex_length(ciphertext_hex);
+  const uint8_t *ciphertext = decode_hex_reverse(ciphertext_hex);
+
+  key_hex = encode_hex_dup(key, key_length);
+  cleartext_hex = encode_hex_dup(cleartext, cleartext_length);
+  ciphertext_hex = encode_hex_dup(ciphertext, ciphertext_length);
+
+  test_cipher(cipher, key_hex, cleartext_hex, ciphertext_hex);
+
+  free((void *)ciphertext_hex);
+  free((void *)cleartext_hex);
+  free((void *)key_hex);
+  free((void *)ciphertext);
+  free((void *)cleartext);
+  free((void *)key);
+}
 
 int
 test_main(void)
 {
   /* From libgcrypt */
   test_cipher(&amp;nettle_serpent128,
-	      HL("0000000000000000 0000000000000000"),
-	      HL("D29D576FCEA3A3A7 ED9099F29273D78E"),
-	      H("B2288B968AE8B086 48D1CE9606FD992D"));
+	      "0000000000000000 0000000000000000",
+	      "D29D576FCEA3A3A7 ED9099F29273D78E",
+	      "B2288B968AE8B086 48D1CE9606FD992D");
   test_cipher(&amp;nettle_serpent192,
-	      HL("0000000000000000 0000000000000000 0000000000000000"),
-	      HL("D29D576FCEABA3A7 ED9899F2927BD78E"),
-	      H("130E353E1037C224 05E8FAEFB2C3C3E9"));
+	      "0000000000000000 0000000000000000 0000000000000000",
+	      "D29D576FCEABA3A7 ED9899F2927BD78E",
+	      "130E353E1037C224 05E8FAEFB2C3C3E9");
   test_cipher(&amp;nettle_serpent256,
-	      HL("0000000000000000 0000000000000000"
-		 "0000000000000000 0000000000000000"),
-	      HL("D095576FCEA3E3A7 ED98D9F29073D78E"),
-	      H("B90EE5862DE69168 F2BDD5125B45472B"));
+	      "0000000000000000 0000000000000000"
+		 "0000000000000000 0000000000000000",
+	      "D095576FCEA3E3A7 ED98D9F29073D78E",
+	      "B90EE5862DE69168 F2BDD5125B45472B");
   test_cipher(&amp;nettle_serpent256,
-	      HL("0000000000000000 0000000000000000"
-		 "0000000000000000 0000000000000000"),
-	      HL("0000000001000000 0200000003000000"),
-	      H("2061A42782BD52EC 691EC383B03BA77C"));
+	      "0000000000000000 0000000000000000"
+		 "0000000000000000 0000000000000000",
+	      "0000000001000000 0200000003000000",
+	      "2061A42782BD52EC 691EC383B03BA77C");
 
   /* The first test for each key size from the ecb_vk.txt and ecb_vt.txt
    * files in the serpent package. */
@@ -53,48 +77,48 @@ test_main(void)
   /* 128 bit key */
 
   /* vk, 1 */
-  test_cipher(&amp;nettle_serpent128,
-	      RHL("8000000000000000 0000000000000000"),
-	      RHL("0000000000000000 0000000000000000"),
-	      RH("49AFBFAD9D5A3405 2CD8FFA5986BD2DD"));
+  test_cipher_reverse(&amp;nettle_serpent128,
+	      "8000000000000000 0000000000000000",
+	      "0000000000000000 0000000000000000",
+	      "49AFBFAD9D5A3405 2CD8FFA5986BD2DD");
 
   /* vt, 1 */
-  test_cipher(&amp;nettle_serpent128,
-	      RHL("0000000000000000 0000000000000000"),
-	      RHL("8000000000000000 0000000000000000"),
-	      RH("10B5FFB720B8CB90 02A1142B0BA2E94A"));
+  test_cipher_reverse(&amp;nettle_serpent128,
+	      "0000000000000000 0000000000000000",
+	      "8000000000000000 0000000000000000",
+	      "10B5FFB720B8CB90 02A1142B0BA2E94A");
 
   /* 192 bit key */
 
   /* vk, 1 */
-  test_cipher(&amp;nettle_serpent192,
-	      RHL("8000000000000000 0000000000000000"
-		 "0000000000000000"),
-	      RHL("0000000000000000 0000000000000000"),
-	      RH("E78E5402C7195568 AC3678F7A3F60C66"));
+  test_cipher_reverse(&amp;nettle_serpent192,
+	      "8000000000000000 0000000000000000"
+		 "0000000000000000",
+	      "0000000000000000 0000000000000000",
+	      "E78E5402C7195568 AC3678F7A3F60C66");
 
   /* vt, 1 */
-  test_cipher(&amp;nettle_serpent192,
-	      RHL("0000000000000000 0000000000000000"
-		 "0000000000000000"),
-	      RHL("8000000000000000 0000000000000000"),
-	      RH("B10B271BA25257E1 294F2B51F076D0D9"));
+  test_cipher_reverse(&amp;nettle_serpent192,
+	      "0000000000000000 0000000000000000"
+		 "0000000000000000",
+	      "8000000000000000 0000000000000000",
+	      "B10B271BA25257E1 294F2B51F076D0D9");
 
   /* 256 bit key */
 
   /* vk, 1 */
-  test_cipher(&amp;nettle_serpent256,
-	      RHL("8000000000000000 0000000000000000"
-		 "0000000000000000 0000000000000000"),
-	      RHL("0000000000000000 0000000000000000"),
-	      RH("ABED96E766BF28CB C0EBD21A82EF0819"));
+  test_cipher_reverse(&amp;nettle_serpent256,
+	      "8000000000000000 0000000000000000"
+		 "0000000000000000 0000000000000000",
+	      "0000000000000000 0000000000000000",
+	      "ABED96E766BF28CB C0EBD21A82EF0819");
 
   /* vt, 1 */
-  test_cipher(&amp;nettle_serpent256,
-	      RHL("0000000000000000 0000000000000000"
-		 "0000000000000000 0000000000000000"),
-	      RHL("8000000000000000 0000000000000000"),
-	      RH("DA5A7992B1B4AE6F 8C004BC8A7DE5520"));
+  test_cipher_reverse(&amp;nettle_serpent256,
+	      "0000000000000000 0000000000000000"
+		 "0000000000000000 0000000000000000",
+	      "8000000000000000 0000000000000000",
+	      "DA5A7992B1B4AE6F 8C004BC8A7DE5520");
 
   /* Test vectors from
      http://www.cs.technion.ac.il/~biham/Reports/Serpent/ */
@@ -102,190 +126,190 @@ test_main(void)
   /* serpent128 */
   /* Set 4, vector#  0 */
   test_cipher(&amp;nettle_serpent128,
-	      HL("000102030405060708090A0B0C0D0E0F"),
-	      HL("00112233445566778899AABBCCDDEEFF"),
-	      H("563E2CF8740A27C164804560391E9B27"));
+	      "000102030405060708090A0B0C0D0E0F",
+	      "00112233445566778899AABBCCDDEEFF",
+	      "563E2CF8740A27C164804560391E9B27");
 
   /* Set 4, vector#  1 */
   test_cipher(&amp;nettle_serpent128,
-	      HL("2BD6459F82C5B300952C49104881FF48"),
-	      HL("EA024714AD5C4D84EA024714AD5C4D84"),
-	      H("92D7F8EF2C36C53409F275902F06539F"));
+	      "2BD6459F82C5B300952C49104881FF48",
+	      "EA024714AD5C4D84EA024714AD5C4D84",
+	      "92D7F8EF2C36C53409F275902F06539F");
 
   /* serpent192 */
   /* Set 4, vector#  0 */
   test_cipher(&amp;nettle_serpent192,
-	      HL("000102030405060708090A0B0C0D0E0F1011121314151617"),
-	      HL("00112233445566778899AABBCCDDEEFF"),
-	      H("6AB816C82DE53B93005008AFA2246A02"));
+	      "000102030405060708090A0B0C0D0E0F1011121314151617",
+	      "00112233445566778899AABBCCDDEEFF",
+	      "6AB816C82DE53B93005008AFA2246A02");
 
   /* Set 4, vector#  1 */
   test_cipher(&amp;nettle_serpent192,
-	      HL("2BD6459F82C5B300952C49104881FF482BD6459F82C5B300"),
-	      HL("EA024714AD5C4D84EA024714AD5C4D84"),
-	      H("827B18C2678A239DFC5512842000E204"));
+	      "2BD6459F82C5B300952C49104881FF482BD6459F82C5B300",
+	      "EA024714AD5C4D84EA024714AD5C4D84",
+	      "827B18C2678A239DFC5512842000E204");
 
   /* serpent256 */
   /* Set 4, vector#  0 */
   test_cipher(&amp;nettle_serpent256,
-	      HL("000102030405060708090A0B0C0D0E0F"
-		 "101112131415161718191A1B1C1D1E1F"),
-	      HL("00112233445566778899AABBCCDDEEFF"),
-	      H("2868B7A2D28ECD5E4FDEFAC3C4330074"));
+	      "000102030405060708090A0B0C0D0E0F"
+		 "101112131415161718191A1B1C1D1E1F",
+	      "00112233445566778899AABBCCDDEEFF",
+	      "2868B7A2D28ECD5E4FDEFAC3C4330074");
 
   /* Set 4, vector#  1 */
   test_cipher(&amp;nettle_serpent256,
-	      HL("2BD6459F82C5B300952C49104881FF48"
-		 "2BD6459F82C5B300952C49104881FF48"),
-	      HL("EA024714AD5C4D84EA024714AD5C4D84"),
-	      H("3E507730776B93FDEA661235E1DD99F0"));
+	      "2BD6459F82C5B300952C49104881FF48"
+		 "2BD6459F82C5B300952C49104881FF48",
+	      "EA024714AD5C4D84EA024714AD5C4D84",
+	      "3E507730776B93FDEA661235E1DD99F0");
 
   /* Test key padding. We use nettle_serpent256, which actually works
      also with key sizes smaller than 32 bytes. */
   test_cipher(&amp;nettle_serpent256,
-	      HL("00112233440100000000000000000000"
-		 "00000000000000000000000000000000"),
-	      HL("0000000001000000 0200000003000000"),
-	      H("C1415AC653FD7C7F D917482EE8EBFE25"));
+	      "00112233440100000000000000000000"
+		 "00000000000000000000000000000000",
+	      "0000000001000000 0200000003000000",
+	      "C1415AC653FD7C7F D917482EE8EBFE25");
 
   /* Currrently, key sizes smaller than SERPENT_MIN_KEY_SIZE bytes
      (128 bits) are not supported. */
   test_cipher(&amp;nettle_serpent256,
-	      HL("0011223344"),
-	      HL("0000000001000000 0200000003000000"),
-	      H("C1415AC653FD7C7F D917482EE8EBFE25"));
+	      "0011223344",
+	      "0000000001000000 0200000003000000",
+	      "C1415AC653FD7C7F D917482EE8EBFE25");
 
   test_cipher(&amp;nettle_serpent256,
-	      HL("00112233445566778899aabbccddeeff"
-		 "00010000000000000000000000000000"),
-	      HL("0000000001000000 0200000003000000"),
-	      H("8EB9C958EAFFDF42 009755D7B6458838"));
+	      "00112233445566778899aabbccddeeff"
+		 "00010000000000000000000000000000",
+	      "0000000001000000 0200000003000000",
+	      "8EB9C958EAFFDF42 009755D7B6458838");
 
   test_cipher(&amp;nettle_serpent256,
-	      HL("00112233445566778899aabbccddeeff"
-		 "00"),
-	      HL("0000000001000000 0200000003000000"),
-	      H("8EB9C958EAFFDF42 009755D7B6458838"));
+	      "00112233445566778899aabbccddeeff"
+		 "00",
+	      "0000000001000000 0200000003000000",
+	      "8EB9C958EAFFDF42 009755D7B6458838");
 
   test_cipher(&amp;nettle_serpent256,
-	      HL("00112233445566778899aabbccddeeff"
-		 "00112201000000000000000000000000"),
-	      HL("0000000001000000 0200000003000000"),
-	      H("C8A078D8212AC96D 9060E30EC5CBB5C7"));
+	      "00112233445566778899aabbccddeeff"
+		 "00112201000000000000000000000000",
+	      "0000000001000000 0200000003000000",
+	      "C8A078D8212AC96D 9060E30EC5CBB5C7");
 
   test_cipher(&amp;nettle_serpent256,
-	      HL("00112233445566778899aabbccddeeff"
-		 "001122"),
-	      HL("0000000001000000 0200000003000000"),
-	      H("C8A078D8212AC96D 9060E30EC5CBB5C7"));
+	      "00112233445566778899aabbccddeeff"
+		 "001122",
+	      "0000000001000000 0200000003000000",
+	      "C8A078D8212AC96D 9060E30EC5CBB5C7");
 
   /* Test with multiple blocks. */
   test_cipher(&amp;nettle_serpent128,
-	      HL("e87450aa0fd87293fd0371483a459bd2"),
-	      HL("a78a7a8d392f629d bd13674c8dce6fa2"),
-	      H("b3d488986c80dea7 c5ebdab4907871c9"));
+	      "e87450aa0fd87293fd0371483a459bd2",
+	      "a78a7a8d392f629d bd13674c8dce6fa2",
+	      "b3d488986c80dea7 c5ebdab4907871c9");
 
   test_cipher(&amp;nettle_serpent128,
-	      HL("e87450aa0fd87293fd0371483a459bd2"),
-	      HL("a78a7a8d392f629d bd13674c8dce6fa2"
-		 "930c74dec02a11d8 c80d90b5e5c887a7"),
-	      H("b3d488986c80dea7 c5ebdab4907871c9"
-		"a4b92b13b79afb37 5518b01bfd706a37"));
+	      "e87450aa0fd87293fd0371483a459bd2",
+	      "a78a7a8d392f629d bd13674c8dce6fa2"
+		 "930c74dec02a11d8 c80d90b5e5c887a7",
+	      "b3d488986c80dea7 c5ebdab4907871c9"
+		"a4b92b13b79afb37 5518b01bfd706a37");
 
   test_cipher(&amp;nettle_serpent128,
-	      HL("e87450aa0fd87293fd0371483a459bd2"),
-	      HL("a78a7a8d392f629d bd13674c8dce6fa2"
+	      "e87450aa0fd87293fd0371483a459bd2",
+	      "a78a7a8d392f629d bd13674c8dce6fa2"
 		 "930c74dec02a11d8 c80d90b5e5c887a7"
-		 "83c92a921b5b2028 d9cb313a5f07ab09"),
-	      H("b3d488986c80dea7 c5ebdab4907871c9"
+		 "83c92a921b5b2028 d9cb313a5f07ab09",
+	      "b3d488986c80dea7 c5ebdab4907871c9"
 		"a4b92b13b79afb37 5518b01bfd706a37"
-		"8e44c2d463df4531 165461699edbad03"));
+		"8e44c2d463df4531 165461699edbad03");
 
   test_cipher(&amp;nettle_serpent128,
-	      HL("91c8e949e12f0e38 7b2473238a3df1b6"),
-	      HL("00000000 00000001 00000002 00000003"
+	      "91c8e949e12f0e38 7b2473238a3df1b6",
+	      "00000000 00000001 00000002 00000003"
 		 "00000004 00000005 00000006 00000007"
 		 "00000008 00000009 0000000a 0000000b"
-		 "0000000c 0000000d 0000000e 0000000f"),
-	      H("2db9f0a39d4f31a4 b1a83cd1032fe1bd"
+		 "0000000c 0000000d 0000000e 0000000f",
+	      "2db9f0a39d4f31a4 b1a83cd1032fe1bd"
 		"3606caa84a220b1b f6f43ff80a831203"
 		"8c6c8d2793dc10b3 904d30e194f086a6"
-		"b2f3e932b9b3f8d1 d4d074f7bd1ff7a3"));
+		"b2f3e932b9b3f8d1 d4d074f7bd1ff7a3");
 	      
   test_cipher(&amp;nettle_serpent128,
-	      HL("e87450aa0fd87293fd0371483a459bd2"),
-	      HL("a78a7a8d392f629d bd13674c8dce6fa2"
+	      "e87450aa0fd87293fd0371483a459bd2",
+	      "a78a7a8d392f629d bd13674c8dce6fa2"
 		 "930c74dec02a11d8 c80d90b5e5c887a7"
 		 "83c92a921b5b2028 d9cb313a5f07ab09"
-		 "672eadf1624a2ed0 c42d1b08b076f75a"),
-	      H("b3d488986c80dea7 c5ebdab4907871c9"
+		 "672eadf1624a2ed0 c42d1b08b076f75a",
+	      "b3d488986c80dea7 c5ebdab4907871c9"
 		"a4b92b13b79afb37 5518b01bfd706a37"
 		"8e44c2d463df4531 165461699edbad03"
-		"30ac8c52697102ae 3b725dba79ceb250"));
+		"30ac8c52697102ae 3b725dba79ceb250");
 
   test_cipher(&amp;nettle_serpent128,
-	      HL("e87450aa0fd87293fd0371483a459bd2"),
-	      HL("a78a7a8d392f629d bd13674c8dce6fa2"
+	      "e87450aa0fd87293fd0371483a459bd2",
+	      "a78a7a8d392f629d bd13674c8dce6fa2"
 		 "930c74dec02a11d8 c80d90b5e5c887a7"
 		 "83c92a921b5b2028 d9cb313a5f07ab09"
 		 "672eadf1624a2ed0 c42d1b08b076f75a"
-		 "7378272aa57ad7c8 803e326689541266"),
-	      H("b3d488986c80dea7 c5ebdab4907871c9"
+		 "7378272aa57ad7c8 803e326689541266",
+	      "b3d488986c80dea7 c5ebdab4907871c9"
 		"a4b92b13b79afb37 5518b01bfd706a37"
 		"8e44c2d463df4531 165461699edbad03"
 		"30ac8c52697102ae 3b725dba79ceb250"
-		"d308b83478e86dbb 629f18736cca042f"));
+		"d308b83478e86dbb 629f18736cca042f");
 
   test_cipher(&amp;nettle_serpent128,
-	      HL("e87450aa0fd87293fd0371483a459bd2"),
-	      HL("a78a7a8d392f629d bd13674c8dce6fa2"
+	      "e87450aa0fd87293fd0371483a459bd2",
+	      "a78a7a8d392f629d bd13674c8dce6fa2"
 		 "930c74dec02a11d8 c80d90b5e5c887a7"
 		 "83c92a921b5b2028 d9cb313a5f07ab09"
 		 "672eadf1624a2ed0 c42d1b08b076f75a"
 		 "7378272aa57ad7c8 803e326689541266"
-		 "b7a2efda5721776f 4113d63a702ac3ae"),
-	      H("b3d488986c80dea7 c5ebdab4907871c9"
+		 "b7a2efda5721776f 4113d63a702ac3ae",
+	      "b3d488986c80dea7 c5ebdab4907871c9"
 		"a4b92b13b79afb37 5518b01bfd706a37"
 		"8e44c2d463df4531 165461699edbad03"
 		"30ac8c52697102ae 3b725dba79ceb250"
 		"d308b83478e86dbb 629f18736cca042f"
-		"006b89e494469adf 0ee78c60684dff86"));
+		"006b89e494469adf 0ee78c60684dff86");
     
   test_cipher(&amp;nettle_serpent128,
-	      HL("e87450aa0fd87293fd0371483a459bd2"),
-	      HL("a78a7a8d392f629d bd13674c8dce6fa2"
+	      "e87450aa0fd87293fd0371483a459bd2",
+	      "a78a7a8d392f629d bd13674c8dce6fa2"
 		 "930c74dec02a11d8 c80d90b5e5c887a7"
 		 "83c92a921b5b2028 d9cb313a5f07ab09"
 		 "672eadf1624a2ed0 c42d1b08b076f75a"
 		 "7378272aa57ad7c8 803e326689541266"
 		 "b7a2efda5721776f 4113d63a702ac3ae"
-		 "cd1be7bbfad74819 644617f8656e9e5b"),
-	      H("b3d488986c80dea7 c5ebdab4907871c9"
+		 "cd1be7bbfad74819 644617f8656e9e5b",
+	      "b3d488986c80dea7 c5ebdab4907871c9"
 		"a4b92b13b79afb37 5518b01bfd706a37"
 		"8e44c2d463df4531 165461699edbad03"
 		"30ac8c52697102ae 3b725dba79ceb250"
 		"d308b83478e86dbb 629f18736cca042f"
 		"006b89e494469adf 0ee78c60684dff86"
-		"5f2c99908ee77ffe aea3d30cb78a1ce1"));
+		"5f2c99908ee77ffe aea3d30cb78a1ce1");
 
   test_cipher(&amp;nettle_serpent128,
-	      HL("e87450aa0fd87293fd0371483a459bd2"),
-	      HL("a78a7a8d392f629d bd13674c8dce6fa2"
+	      "e87450aa0fd87293fd0371483a459bd2",
+	      "a78a7a8d392f629d bd13674c8dce6fa2"
 		 "930c74dec02a11d8 c80d90b5e5c887a7"
 		 "83c92a921b5b2028 d9cb313a5f07ab09"
 		 "672eadf1624a2ed0 c42d1b08b076f75a"
 		 "7378272aa57ad7c8 803e326689541266"
 		 "b7a2efda5721776f 4113d63a702ac3ae"
 		 "cd1be7bbfad74819 644617f8656e9e5b"
-		 "34d449409c1f850a 4cb6700d6ef3405f"),
-	      H("b3d488986c80dea7 c5ebdab4907871c9"
+		 "34d449409c1f850a 4cb6700d6ef3405f",
+	      "b3d488986c80dea7 c5ebdab4907871c9"
 		"a4b92b13b79afb37 5518b01bfd706a37"
 		"8e44c2d463df4531 165461699edbad03"
 		"30ac8c52697102ae 3b725dba79ceb250"
 		"d308b83478e86dbb 629f18736cca042f"
 		"006b89e494469adf 0ee78c60684dff86"
 		"5f2c99908ee77ffe aea3d30cb78a1ce1"
-		"ebe855dd51532477 4d2d55969e032e6c"));
+		"ebe855dd51532477 4d2d55969e032e6c");
 
   SUCCESS();
 }
diff --git a/testsuite/sexp-format-test.c b/testsuite/sexp-format-test.c
index 33c585f..4136693 100644
--- a/testsuite/sexp-format-test.c
+++ b/testsuite/sexp-format-test.c
@@ -26,6 +26,7 @@ test_main(void)
     
     ASSERT(buffer.size == strlen(e));
     ASSERT(MEMEQ(buffer.size, buffer.contents, e));
+    nettle_buffer_clear(&amp;buffer);
   }
   {
     const uint8_t e[] = "{KDM6Zm9vKDM6YmFyMTc6eHh4eHh4eHh4eHh4eHh4eHgpKQ==}";
@@ -41,6 +42,7 @@ test_main(void)
     
     ASSERT(buffer.size == strlen(e));
     ASSERT(MEMEQ(buffer.size, buffer.contents, e));
+    nettle_buffer_clear(&amp;buffer);
   }
   {
     const uint8_t e[] = "1:\0""1:a2:bc3:def4:ghij5:\x00\xDE\xAD\xBE\xEF";
@@ -52,6 +54,7 @@ test_main(void)
     
     ASSERT(buffer.size == LLENGTH(e));
     ASSERT(MEMEQ(buffer.size, buffer.contents, e));
+    nettle_buffer_clear(&amp;buffer);
   }
 
   {
@@ -64,6 +67,8 @@ test_main(void)
     
     ASSERT(buffer.size == strlen(e));
     ASSERT(MEMEQ(buffer.size, buffer.contents, e));
+
+    nettle_buffer_clear(&amp;buffer);
   }
 
   {
@@ -75,6 +80,7 @@ test_main(void)
 	   == strlen(e));
 
     ASSERT(MEMEQ(buffer.size, buffer.contents, e));
+    nettle_buffer_clear(&amp;buffer);
   }
 
   /* Try literals */
@@ -92,6 +98,7 @@ test_main(void)
     
     ASSERT(buffer.size == strlen(e));
     ASSERT(MEMEQ(buffer.size, buffer.contents, e));
+    nettle_buffer_clear(&amp;buffer);
   }
   {
     const uint8_t e[] = "(3:foo(3:bar17:xxxxxxxxxxxxxxxxx))";
@@ -107,6 +114,7 @@ test_main(void)
     
     ASSERT(buffer.size == strlen(e));
     ASSERT(MEMEQ(buffer.size, buffer.contents, e));
+    nettle_buffer_clear(&amp;buffer);
   }
 
   /* Literal parenthesis */
@@ -122,6 +130,7 @@ test_main(void)
     
     ASSERT(buffer.size == strlen(e));
     ASSERT(MEMEQ(buffer.size, buffer.contents, e));
+    nettle_buffer_clear(&amp;buffer);
   }
   
 #if HAVE_LIBGMP
@@ -133,7 +142,7 @@ test_main(void)
     const uint8_t e[] =
       "(3:foo(3:bar1:\xff""11:abcdefghijk13:\0\x81""abcdefghijk))";
 
-    nettle_buffer_clear(&amp;buffer);
+//    nettle_buffer_clear(&amp;buffer);
 
     mpz_init_set_si(x, -1);
     nettle_mpz_init_set_str_256_u(y, 11, "abcdefghijk");
@@ -153,6 +162,8 @@ test_main(void)
 
     nettle_buffer_clear(&amp;buffer);
     mpz_clear(x);
+    mpz_clear(y);
+    mpz_clear(z);
   }
 #endif /* HAVE_LIBGMP */
 
diff --git a/testsuite/sexp-test.c b/testsuite/sexp-test.c
index 4e68f56..0fdec10 100644
--- a/testsuite/sexp-test.c
+++ b/testsuite/sexp-test.c
@@ -1,12 +1,15 @@
 #include "testutils.h"
 #include "sexp.h"
 
+#define INPUT "{Mzpmb28=} {MDo=} {WzM6YmFyXTEyOnh4eHh4eHh4eHh4eA==}"
+
 int
 test_main(void)
 {
   struct sexp_iterator i;
   uint32_t x;
-  
+  uint8_t *p;
+
   ASSERT(sexp_iterator_first(&amp;i, LDATA("")));
   ASSERT(i.type == SEXP_END);
 
@@ -49,9 +52,9 @@ test_main(void)
 	 &amp;&amp; sexp_iterator_next(&amp;i) &amp;&amp; i.type == SEXP_END);
   
   /* Same data, transport encoded. */
-  
+
   ASSERT(sexp_transport_iterator_first
-	 (&amp;i, LDUP("{Mzpmb28=} {MDo=} {WzM6YmFyXTEyOnh4eHh4eHh4eHh4eA==}")));
+	 (&amp;i, sizeof(INPUT) - 1, p=strdup(INPUT)));
   ASSERT(i.type == SEXP_ATOM
 	 &amp;&amp; !i.display_length &amp;&amp; !i.display
 	 &amp;&amp; i.atom_length == 3 &amp;&amp; MEMEQ(3, "foo", i.atom)
@@ -95,5 +98,7 @@ test_main(void)
 	   &amp;&amp; !sexp_iterator_assoc(&amp;i, 2, keys, v));    
   }
 
+  free((void *)p);
+
   SUCCESS();
 }
diff --git a/testsuite/sexp2rsa-test.c b/testsuite/sexp2rsa-test.c
index 2e7cd91..3555e1e 100644
--- a/testsuite/sexp2rsa-test.c
+++ b/testsuite/sexp2rsa-test.c
@@ -3,15 +3,8 @@
 int
 test_main(void)
 {
-  struct rsa_public_key pub;
-  struct rsa_private_key priv;
-  
-  rsa_public_key_init(&amp;pub);
-  rsa_private_key_init(&amp;priv);
-
-  ASSERT(rsa_keypair_from_sexp
-	 (&amp;pub, &amp;priv, 0,
-	  HL("2831313a707269766174652d6b657928"
+  static const uint8_t *expr_hex =
+	  "2831313a707269766174652d6b657928"
 	     "333a72736128313a6e36333a085c3408"
 	     "989acae4faec3cbbad91c90d34c1d259"
 	     "cd74121a36f38b0b51424a9b2be514a0"
@@ -34,12 +27,24 @@ test_main(void)
 	     "1d068e2ce9f565c5528c4a7473292831"
 	     "3a6333323a00f8a458ea73a018dc6fa5"
 	     "6863e3bc6de405f364f77dee6f096267"
-	     "9ea1a8282e292929")));
+	     "9ea1a8282e292929";
+  unsigned expr_length = decode_hex_length(expr_hex);
+  const uint8_t *expr = decode_hex_dup(expr_hex);
+  struct rsa_public_key pub;
+  struct rsa_private_key priv;
+  
+  rsa_public_key_init(&amp;pub);
+  rsa_private_key_init(&amp;priv);
+
+  ASSERT(rsa_keypair_from_sexp
+	 (&amp;pub, &amp;priv, 0, expr_length, expr));
 
   test_rsa_key(&amp;pub, &amp;priv);
 
   rsa_public_key_clear(&amp;pub);
   rsa_private_key_clear(&amp;priv);
+
+  free((void *)expr);
   
   SUCCESS();
 }
diff --git a/testsuite/sha1-test.c b/testsuite/sha1-test.c
index 8319086..7b6439a 100644
--- a/testsuite/sha1-test.c
+++ b/testsuite/sha1-test.c
@@ -4,34 +4,34 @@
 int
 test_main(void)
 {
-  test_hash(&amp;nettle_sha1, 0, "",
-	    H("DA39A3EE5E6B4B0D 3255BFEF95601890 AFD80709")); 
+  test_hash(&amp;nettle_sha1, "",
+	    "DA39A3EE5E6B4B0D 3255BFEF95601890 AFD80709"); 
 
-  test_hash(&amp;nettle_sha1, 1, "a",
-	    H("86F7E437FAA5A7FC E15D1DDCB9EAEAEA 377667B8")); 
+  test_hash(&amp;nettle_sha1, "a",
+	    "86F7E437FAA5A7FC E15D1DDCB9EAEAEA 377667B8"); 
 
-  test_hash(&amp;nettle_sha1, 3, "abc",
-	    H("A9993E364706816A BA3E25717850C26C 9CD0D89D"));
+  test_hash(&amp;nettle_sha1, "abc",
+	    "A9993E364706816A BA3E25717850C26C 9CD0D89D");
   
-  test_hash(&amp;nettle_sha1, 26, "abcdefghijklmnopqrstuvwxyz",
-	    H("32D10C7B8CF96570 CA04CE37F2A19D84 240D3A89"));
+  test_hash(&amp;nettle_sha1, "abcdefghijklmnopqrstuvwxyz",
+	    "32D10C7B8CF96570 CA04CE37F2A19D84 240D3A89");
   
-  test_hash(&amp;nettle_sha1, 14, "message digest",
-	    H("C12252CEDA8BE899 4D5FA0290A47231C 1D16AAE3")); 
+  test_hash(&amp;nettle_sha1, "message digest",
+	    "C12252CEDA8BE899 4D5FA0290A47231C 1D16AAE3"); 
 
-  test_hash(&amp;nettle_sha1, 62,
+  test_hash(&amp;nettle_sha1,
 	    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
 	    "abcdefghijklmnopqrstuvwxyz0123456789",
-	    H("761C457BF73B14D2 7E9E9265C46F4B4D DA11F940"));
+	    "761C457BF73B14D2 7E9E9265C46F4B4D DA11F940");
   
-  test_hash(&amp;nettle_sha1,  80,
+  test_hash(&amp;nettle_sha1,
 	    "1234567890123456789012345678901234567890"
 	    "1234567890123456789012345678901234567890",
-	    H("50ABF5706A150990 A08B2C5EA40FA0E5 85554732"));
+	    "50ABF5706A150990 A08B2C5EA40FA0E5 85554732");
 
   /* Additional test vector, from Daniel Kahn Gillmor */
-  test_hash(&amp;nettle_sha1, LDATA("38"),
-	    H("5b384ce32d8cdef02bc3a139d4cac0a22bb029e8"));
+  test_hash(&amp;nettle_sha1, "38",
+	    "5b384ce32d8cdef02bc3a139d4cac0a22bb029e8");
 
   SUCCESS();
 }
diff --git a/testsuite/sha224-test.c b/testsuite/sha224-test.c
index cef82af..fef7d47 100644
--- a/testsuite/sha224-test.c
+++ b/testsuite/sha224-test.c
@@ -6,43 +6,43 @@ test_main(void)
 {
   /* From FIPS180-2 addendum
      (http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf) \
                */
-  test_hash(&amp;nettle_sha224, 3, "abc",
-	    H("23097d22 3405d822 8642a477 bda255b3"
-	      "2aadbce4 bda0b3f7 e36c9da7"));
+  test_hash(&amp;nettle_sha224, "abc",
+	    "23097d22 3405d822 8642a477 bda255b3"
+	      "2aadbce4 bda0b3f7 e36c9da7");
 
-  test_hash(&amp;nettle_sha224, 56,
+  test_hash(&amp;nettle_sha224,
 	    "abcdbcdecdefdefgefghfghighij"
 	    "hijkijkljklmklmnlmnomnopnopq",
-	    H("75388b16 512776cc 5dba5da1 fd890150"
-	      "b0c6455c b4f58b19 52522525"));
+	    "75388b16 512776cc 5dba5da1 fd890150"
+	      "b0c6455c b4f58b19 52522525");
 
   /* Additional test vectors, from Daniel Kahn Gillmor */
-  test_hash(&amp;nettle_sha224, LDATA(""),
-	    H("d14a028c2a3a2bc9 476102bb288234c4"
-	      "15a2b01f828ea62a c5b3e42f"));
-  test_hash(&amp;nettle_sha224, LDATA("a"),
-	    H("abd37534c7d9a2ef b9465de931cd7055"
-	      "ffdb8879563ae980 78d6d6d5"));
-  test_hash(&amp;nettle_sha224, LDATA("38"),
-	    H("4cfca6da32da6471 98225460722b7ea1"
-	      "284f98c4b179e8db ae3f93d5"));
-  test_hash(&amp;nettle_sha224, LDATA("message digest"),
-	    H("2cb21c83ae2f004d e7e81c3c7019cbcb"
-	      "65b71ab656b22d6d 0c39b8eb"));
-  test_hash(&amp;nettle_sha224, LDATA("abcdefghijklmnopqrstuvwxyz"),
-	    H("45a5f72c39c5cff2 522eb3429799e49e"
-	      "5f44b356ef926bcf 390dccc2"));
+  test_hash(&amp;nettle_sha224, "",
+	    "d14a028c2a3a2bc9 476102bb288234c4"
+	      "15a2b01f828ea62a c5b3e42f");
+  test_hash(&amp;nettle_sha224, "a",
+	    "abd37534c7d9a2ef b9465de931cd7055"
+	      "ffdb8879563ae980 78d6d6d5");
+  test_hash(&amp;nettle_sha224, "38",
+	    "4cfca6da32da6471 98225460722b7ea1"
+	      "284f98c4b179e8db ae3f93d5");
+  test_hash(&amp;nettle_sha224, "message digest",
+	    "2cb21c83ae2f004d e7e81c3c7019cbcb"
+	      "65b71ab656b22d6d 0c39b8eb");
+  test_hash(&amp;nettle_sha224, "abcdefghijklmnopqrstuvwxyz",
+	    "45a5f72c39c5cff2 522eb3429799e49e"
+	      "5f44b356ef926bcf 390dccc2");
   test_hash(&amp;nettle_sha224,
-	    LDATA("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef"
-		  "ghijklmnopqrstuvwxyz0123456789"),
-	    H("bff72b4fcb7d75e5 632900ac5f90d219"
-	      "e05e97a7bde72e74 0db393d9"));
+	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef"
+		  "ghijklmnopqrstuvwxyz0123456789",
+	    "bff72b4fcb7d75e5 632900ac5f90d219"
+	      "e05e97a7bde72e74 0db393d9");
   test_hash(&amp;nettle_sha224,
-	    LDATA("12345678901234567890123456789012"
+	    "12345678901234567890123456789012"
 		  "34567890123456789012345678901234"
-		  "5678901234567890"),
-	    H("b50aecbe4e9bb0b5 7bc5f3ae760a8e01"
-	      "db24f203fb3cdcd1 3148046e"));
+		  "5678901234567890",
+	    "b50aecbe4e9bb0b5 7bc5f3ae760a8e01"
+	      "db24f203fb3cdcd1 3148046e");
 
   SUCCESS();
 }
diff --git a/testsuite/sha256-test.c b/testsuite/sha256-test.c
index 7499521..b113419 100644
--- a/testsuite/sha256-test.c
+++ b/testsuite/sha256-test.c
@@ -5,51 +5,51 @@ int
 test_main(void)
 {
   /* From FIPS180-2 */
-  test_hash(&amp;nettle_sha256, 3, "abc",
-	    H("ba7816bf8f01cfea 414140de5dae2223"
-	      "b00361a396177a9c b410ff61f20015ad"));
+  test_hash(&amp;nettle_sha256, "abc",
+	    "ba7816bf8f01cfea 414140de5dae2223"
+	      "b00361a396177a9c b410ff61f20015ad");
 
-  test_hash(&amp;nettle_sha256, 56,
+  test_hash(&amp;nettle_sha256,
 	    "abcdbcdecdefdefgefghfghighij"
 	    "hijkijkljklmklmnlmnomnopnopq",
-	    H("248d6a61d20638b8 e5c026930c3e6039"
-	      "a33ce45964ff2167 f6ecedd419db06c1"));
+	    "248d6a61d20638b8 e5c026930c3e6039"
+	      "a33ce45964ff2167 f6ecedd419db06c1");
 
-  test_hash(&amp;nettle_sha256, 112,
+  test_hash(&amp;nettle_sha256,
 	    "abcdefghbcdefghicdefghijdefg"
 	    "hijkefghijklfghijklmghijklmn"
 	    "hijklmnoijklmnopjklmnopqklmn"
 	    "opqrlmnopqrsmnopqrstnopqrstu",
-	    H("cf5b16a778af8380 036ce59e7b049237"
-	      "0b249b11e8f07a51 afac45037afee9d1"));
+	    "cf5b16a778af8380 036ce59e7b049237"
+	      "0b249b11e8f07a51 afac45037afee9d1");
 
   /* Additional test vectors, from Daniel Kahn Gillmor */
-  test_hash(&amp;nettle_sha256, LDATA(""),
-	    H("e3b0c44298fc1c14 9afbf4c8996fb924"
-	      "27ae41e4649b934c a495991b7852b855"));
-  test_hash(&amp;nettle_sha256, LDATA("a"),
-	    H("ca978112ca1bbdca fac231b39a23dc4d"
-	      "a786eff8147c4e72 b9807785afee48bb"));
-  test_hash(&amp;nettle_sha256, LDATA("38"),
-	    H("aea92132c4cbeb26 3e6ac2bf6c183b5d"
-	      "81737f179f21efdc 5863739672f0f470"));
-  test_hash(&amp;nettle_sha256, LDATA("message digest"),
-	    H("f7846f55cf23e14e ebeab5b4e1550cad"
-	      "5b509e3348fbc4ef a3a1413d393cb650"));
-  test_hash(&amp;nettle_sha256, LDATA("abcdefghijklmnopqrstuvwxyz"),
-	    H("71c480df93d6ae2f 1efad1447c66c952"
-	      "5e316218cf51fc8d 9ed832f2daf18b73"));
+  test_hash(&amp;nettle_sha256, "",
+	    "e3b0c44298fc1c14 9afbf4c8996fb924"
+	      "27ae41e4649b934c a495991b7852b855");
+  test_hash(&amp;nettle_sha256, "a",
+	    "ca978112ca1bbdca fac231b39a23dc4d"
+	      "a786eff8147c4e72 b9807785afee48bb");
+  test_hash(&amp;nettle_sha256, "38",
+	    "aea92132c4cbeb26 3e6ac2bf6c183b5d"
+	      "81737f179f21efdc 5863739672f0f470");
+  test_hash(&amp;nettle_sha256, "message digest",
+	    "f7846f55cf23e14e ebeab5b4e1550cad"
+	      "5b509e3348fbc4ef a3a1413d393cb650");
+  test_hash(&amp;nettle_sha256, "abcdefghijklmnopqrstuvwxyz",
+	    "71c480df93d6ae2f 1efad1447c66c952"
+	      "5e316218cf51fc8d 9ed832f2daf18b73");
   test_hash(&amp;nettle_sha256,
-	    LDATA("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef"
-		  "ghijklmnopqrstuvwxyz0123456789"),
-	    H("db4bfcbd4da0cd85 a60c3c37d3fbd880"
-	      "5c77f15fc6b1fdfe 614ee0a7c8fdb4c0"));
+	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef"
+		  "ghijklmnopqrstuvwxyz0123456789",
+	    "db4bfcbd4da0cd85 a60c3c37d3fbd880"
+	      "5c77f15fc6b1fdfe 614ee0a7c8fdb4c0");
   test_hash(&amp;nettle_sha256,
-	    LDATA("12345678901234567890123456789012"
+	    "12345678901234567890123456789012"
 		  "34567890123456789012345678901234"
-		  "5678901234567890"),
-	    H("f371bc4a311f2b00 9eef952dd83ca80e"
-	      "2b60026c8e935592 d0f9c308453c813e"));
+		  "5678901234567890",
+	    "f371bc4a311f2b00 9eef952dd83ca80e"
+	      "2b60026c8e935592 d0f9c308453c813e");
 
   SUCCESS();
 }
diff --git a/testsuite/sha384-test.c b/testsuite/sha384-test.c
index 086e115..702e73b 100644
--- a/testsuite/sha384-test.c
+++ b/testsuite/sha384-test.c
@@ -4,54 +4,54 @@
 int
 test_main(void)
 {
-  test_hash(&amp;nettle_sha384, 3, "abc",
-	    H("cb00753f45a35e8b b5a03d699ac65007"
+  test_hash(&amp;nettle_sha384, "abc",
+	    "cb00753f45a35e8b b5a03d699ac65007"
 	      "272c32ab0eded163 1a8b605a43ff5bed"
-	      "8086072ba1e7cc23 58baeca134c825a7"));
+	      "8086072ba1e7cc23 58baeca134c825a7");
   
-  test_hash(&amp;nettle_sha384, 112,
+  test_hash(&amp;nettle_sha384,
 	    "abcdefghbcdefghicdefghijdefg"
 	    "hijkefghijklfghijklmghijklmn"
 	    "hijklmnoijklmnopjklmnopqklmn"
 	    "opqrlmnopqrsmnopqrstnopqrstu",
-	    H("09330c33f71147e8 3d192fc782cd1b47"
+	    "09330c33f71147e8 3d192fc782cd1b47"
 	      "53111b173b3b05d2 2fa08086e3b0f712"
-	      "fcc7c71a557e2db9 66c3e9fa91746039"));
+	      "fcc7c71a557e2db9 66c3e9fa91746039");
 
   /* Additional test vectors, from Daniel Kahn Gillmor */
-  test_hash(&amp;nettle_sha384, LDATA(""),
-	    H("38b060a751ac9638 4cd9327eb1b1e36a"
+  test_hash(&amp;nettle_sha384, "",
+	    "38b060a751ac9638 4cd9327eb1b1e36a"
 	      "21fdb71114be0743 4c0cc7bf63f6e1da"
-	      "274edebfe76f65fb d51ad2f14898b95b"));
-  test_hash(&amp;nettle_sha384, LDATA("a"),
-	    H("54a59b9f22b0b808 80d8427e548b7c23"
+	      "274edebfe76f65fb d51ad2f14898b95b");
+  test_hash(&amp;nettle_sha384, "a",
+	    "54a59b9f22b0b808 80d8427e548b7c23"
 	      "abd873486e1f035d ce9cd697e8517503"
-	      "3caa88e6d57bc35e fae0b5afd3145f31"));
-  test_hash(&amp;nettle_sha384, LDATA("38"),
-	    H("c071d202ad950b6a 04a5f15c24596a99"
+	      "3caa88e6d57bc35e fae0b5afd3145f31");
+  test_hash(&amp;nettle_sha384, "38",
+	    "c071d202ad950b6a 04a5f15c24596a99"
 	      "3af8b212467958d5 70a3ffd478006063"
-	      "8e3a3d06637691d3 012bd31122071b2c"));
-  test_hash(&amp;nettle_sha384, LDATA("message digest"),
-	    H("473ed35167ec1f5d 8e550368a3db39be"
+	      "8e3a3d06637691d3 012bd31122071b2c");
+  test_hash(&amp;nettle_sha384, "message digest",
+	    "473ed35167ec1f5d 8e550368a3db39be"
 	      "54639f828868e945 4c239fc8b52e3c61"
-	      "dbd0d8b4de1390c2 56dcbb5d5fd99cd5"));
-  test_hash(&amp;nettle_sha384, LDATA("abcdefghijklmnopqrstuvwxyz"),
-	    H("feb67349df3db6f5 924815d6c3dc133f"
+	      "dbd0d8b4de1390c2 56dcbb5d5fd99cd5");
+  test_hash(&amp;nettle_sha384, "abcdefghijklmnopqrstuvwxyz",
+	    "feb67349df3db6f5 924815d6c3dc133f"
 	      "091809213731fe5c 7b5f4999e463479f"
-	      "f2877f5f2936fa63 bb43784b12f3ebb4"));
+	      "f2877f5f2936fa63 bb43784b12f3ebb4");
   test_hash(&amp;nettle_sha384,
-	    LDATA("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef"
-		  "ghijklmnopqrstuvwxyz0123456789"),
-	    H("1761336e3f7cbfe5 1deb137f026f89e0"
+	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef"
+		  "ghijklmnopqrstuvwxyz0123456789",
+	    "1761336e3f7cbfe5 1deb137f026f89e0"
 	      "1a448e3b1fafa640 39c1464ee8732f11"
-	      "a5341a6f41e0c202 294736ed64db1a84"));
+	      "a5341a6f41e0c202 294736ed64db1a84");
   test_hash(&amp;nettle_sha384,
-	    LDATA("12345678901234567890123456789012"
+	    "12345678901234567890123456789012"
 		  "34567890123456789012345678901234"
-		  "5678901234567890"),
-	    H("b12932b0627d1c06 0942f54477641556"
+		  "5678901234567890",
+	    "b12932b0627d1c06 0942f54477641556"
 	      "55bd4da0c9afa6dd 9b9ef53129af1b8f"
-	      "b0195996d2de9ca0 df9d821ffee67026"));
+	      "b0195996d2de9ca0 df9d821ffee67026");
 
   SUCCESS();
 }
diff --git a/testsuite/sha512-test.c b/testsuite/sha512-test.c
index 97bde53..d97b384 100644
--- a/testsuite/sha512-test.c
+++ b/testsuite/sha512-test.c
@@ -4,63 +4,63 @@
 int
 test_main(void)
 {
-  test_hash(&amp;nettle_sha512, 3, "abc",
-	    H("ddaf35a193617aba cc417349ae204131"
+  test_hash(&amp;nettle_sha512, "abc",
+	    "ddaf35a193617aba cc417349ae204131"
 	      "12e6fa4e89a97ea2 0a9eeee64b55d39a"
 	      "2192992a274fc1a8 36ba3c23a3feebbd"
-	      "454d4423643ce80e 2a9ac94fa54ca49f"));
+	      "454d4423643ce80e 2a9ac94fa54ca49f");
   
-  test_hash(&amp;nettle_sha512, 112,
+  test_hash(&amp;nettle_sha512,
 	    "abcdefghbcdefghicdefghijdefg"
 	    "hijkefghijklfghijklmghijklmn"
 	    "hijklmnoijklmnopjklmnopqklmn"
 	    "opqrlmnopqrsmnopqrstnopqrstu",
-	    H("8e959b75dae313da 8cf4f72814fc143f"
+	    "8e959b75dae313da 8cf4f72814fc143f"
 	      "8f7779c6eb9f7fa1 7299aeadb6889018"
 	      "501d289e4900f7e4 331b99dec4b5433a"
-	      "c7d329eeb6dd2654 5e96e55b874be909"));
+	      "c7d329eeb6dd2654 5e96e55b874be909");
 
   /* Additional test vectors, from Daniel Kahn Gillmor */
-  test_hash(&amp;nettle_sha512, LDATA(""),
-	    H("cf83e1357eefb8bd f1542850d66d8007"
+  test_hash(&amp;nettle_sha512, "",
+	    "cf83e1357eefb8bd f1542850d66d8007"
 	      "d620e4050b5715dc 83f4a921d36ce9ce"
 	      "47d0d13c5d85f2b0 ff8318d2877eec2f"
-	      "63b931bd47417a81 a538327af927da3e"));
-  test_hash(&amp;nettle_sha512, LDATA("a"),
-	    H("1f40fc92da241694 750979ee6cf582f2"
+	      "63b931bd47417a81 a538327af927da3e");
+  test_hash(&amp;nettle_sha512, "a",
+	    "1f40fc92da241694 750979ee6cf582f2"
 	      "d5d7d28e18335de0 5abc54d0560e0f53"
 	      "02860c652bf08d56 0252aa5e74210546"
-	      "f369fbbbce8c12cf c7957b2652fe9a75"));
-  test_hash(&amp;nettle_sha512, LDATA("38"),
-	    H("caae34a5e8103126 8bcdaf6f1d8c04d3"
+	      "f369fbbbce8c12cf c7957b2652fe9a75");
+  test_hash(&amp;nettle_sha512, "38",
+	    "caae34a5e8103126 8bcdaf6f1d8c04d3"
 	      "7b7f2c349afb705b 575966f63e2ebf0f"
 	      "d910c3b05160ba08 7ab7af35d40b7c71"
-	      "9c53cd8b947c9611 1f64105fd45cc1b2"));
-  test_hash(&amp;nettle_sha512, LDATA("message digest"),
-	    H("107dbf389d9e9f71 a3a95f6c055b9251"
+	      "9c53cd8b947c9611 1f64105fd45cc1b2");
+  test_hash(&amp;nettle_sha512, "message digest",
+	    "107dbf389d9e9f71 a3a95f6c055b9251"
 	      "bc5268c2be16d6c1 3492ea45b0199f33"
 	      "09e16455ab1e9611 8e8a905d5597b720"
-	      "38ddb372a8982604 6de66687bb420e7c"));
-  test_hash(&amp;nettle_sha512, LDATA("abcdefghijklmnopqrstuvwxyz"),
-	    H("4dbff86cc2ca1bae 1e16468a05cb9881"
+	      "38ddb372a8982604 6de66687bb420e7c");
+  test_hash(&amp;nettle_sha512, "abcdefghijklmnopqrstuvwxyz",
+	    "4dbff86cc2ca1bae 1e16468a05cb9881"
 	      "c97f1753bce36190 34898faa1aabe429"
 	      "955a1bf8ec483d74 21fe3c1646613a59"
-	      "ed5441fb0f321389 f77f48a879c7b1f1"));
+	      "ed5441fb0f321389 f77f48a879c7b1f1");
   test_hash(&amp;nettle_sha512,
-	    LDATA("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef"
-		  "ghijklmnopqrstuvwxyz0123456789"),
-	    H("1e07be23c26a86ea 37ea810c8ec78093"
+	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef"
+		  "ghijklmnopqrstuvwxyz0123456789",
+	    "1e07be23c26a86ea 37ea810c8ec78093"
 	      "52515a970e9253c2 6f536cfc7a9996c4"
 	      "5c8370583e0a78fa 4a90041d71a4ceab"
-	      "7423f19c71b9d5a3 e01249f0bebd5894"));
+	      "7423f19c71b9d5a3 e01249f0bebd5894");
   test_hash(&amp;nettle_sha512,
-	    LDATA("12345678901234567890123456789012"
+	    "12345678901234567890123456789012"
 		  "34567890123456789012345678901234"
-		  "5678901234567890"),
-	    H("72ec1ef1124a45b0 47e8b7c75a932195"
+		  "5678901234567890",
+	    "72ec1ef1124a45b0 47e8b7c75a932195"
 	      "135bb61de24ec0d1 914042246e0aec3a"
 	      "2354e093d76f3048 b456764346900cb1"
-	      "30d2a4fd5dd16abb 5e30bcb850dee843"));
+	      "30d2a4fd5dd16abb 5e30bcb850dee843");
 
   SUCCESS();
 }
diff --git a/testsuite/testutils.c b/testsuite/testutils.c
index 1b0fd88..47c7693 100644
--- a/testsuite/testutils.c
+++ b/testsuite/testutils.c
@@ -46,6 +46,33 @@ xalloc(size_t size)
   return p;
 }
 
+int
+memeq_hex(unsigned length, const uint8_t *s1, const uint8_t *s2_hex)
+{
+  unsigned s2_length = decode_hex_length(s2_hex);
+  const uint8_t *s2 = decode_hex_dup(s2_hex);
+  int result = (length == s2_length) &amp;&amp; !memcmp(s1, s2, length);
+
+  free((void *)s2);
+  return result;
+}
+
+const uint8_t *
+encode_hex_dup(const uint8_t *data, unsigned length)
+{
+  unsigned i;
+  uint8_t *hex = xalloc(length * 2 + 1);
+
+  *hex = 0;
+
+  for (i = 0; i &lt; length; i++)
+    {
+      sprintf(&amp;hex[i*2], "%02x", data[i]);
+    }
+
+  return hex;
+}
+
 unsigned
 decode_hex_length(const char *h)
 {
@@ -163,12 +190,16 @@ main(int argc, char **argv)
 
 void
 test_cipher(const struct nettle_cipher *cipher,
-	    unsigned key_length,
-	    const uint8_t *key,
-	    unsigned length,
-	    const uint8_t *cleartext,
-	    const uint8_t *ciphertext)
+	    const uint8_t *key_hex,
+	    const uint8_t *cleartext_hex,
+	    const uint8_t *ciphertext_hex)
 {
+  unsigned key_length = decode_hex_length(key_hex);
+  const uint8_t *key = decode_hex_dup(key_hex);
+  unsigned length = decode_hex_length(cleartext_hex);
+  const uint8_t *cleartext = decode_hex_dup(cleartext_hex);
+  const uint8_t *ciphertext = decode_hex_dup(ciphertext_hex);
+
   void *ctx = xalloc(cipher-&gt;context_size);
   uint8_t *data = xalloc(length);
 
@@ -201,19 +232,27 @@ test_cipher(const struct nettle_cipher *cipher,
       FAIL();
     }
 
-  free(ctx);
   free(data);
+  free(ctx);
+  free((void *)ciphertext);
+  free((void *)cleartext);
+  free((void *)key);
 }
 
 void
 test_cipher_cbc(const struct nettle_cipher *cipher,
-		unsigned key_length,
-		const uint8_t *key,
-		unsigned length,
-		const uint8_t *cleartext,
-		const uint8_t *ciphertext,
-		const uint8_t *iiv)
+		const uint8_t *key_hex,
+		const uint8_t *cleartext_hex,
+		const uint8_t *ciphertext_hex,
+		const uint8_t *iiv_hex)
 {
+  unsigned key_length = decode_hex_length(key_hex);
+  const uint8_t *key = decode_hex_dup(key_hex);
+  unsigned length = decode_hex_length(cleartext_hex);
+  const uint8_t *cleartext = decode_hex_dup(cleartext_hex);
+  const uint8_t *ciphertext = decode_hex_dup(ciphertext_hex);
+  const uint8_t *iiv = decode_hex_dup(iiv_hex);
+
   void *ctx = xalloc(cipher-&gt;context_size);
   uint8_t *data = xalloc(length);
   uint8_t *iv = xalloc(cipher-&gt;block_size);
@@ -254,20 +293,30 @@ test_cipher_cbc(const struct nettle_cipher *cipher,
       fprintf(stderr, "\n");
       FAIL();
     }
-  free(ctx);
-  free(data);
+
   free(iv);
+  free(data);
+  free(ctx);
+  free((void *)iiv);
+  free((void *)ciphertext);
+  free((void *)cleartext);
+  free((void *)key);
 }
 
 void
 test_cipher_ctr(const struct nettle_cipher *cipher,
-		unsigned key_length,
-		const uint8_t *key,
-		unsigned length,
-		const uint8_t *cleartext,
-		const uint8_t *ciphertext,
-		const uint8_t *ictr)
+		const uint8_t *key_hex,
+		const uint8_t *cleartext_hex,
+		const uint8_t *ciphertext_hex,
+		const uint8_t *ictr_hex)
 {
+  unsigned key_length = decode_hex_length(key_hex);
+  const uint8_t *key = decode_hex_dup(key_hex);
+  unsigned length = decode_hex_length(cleartext_hex);
+  const uint8_t *cleartext = decode_hex_dup(cleartext_hex);
+  const uint8_t *ciphertext = decode_hex_dup(ciphertext_hex);
+  const uint8_t *ictr = decode_hex_dup(ictr_hex);
+
   void *ctx = xalloc(cipher-&gt;context_size);
   uint8_t *data = xalloc(length);
   uint8_t *ctr = xalloc(cipher-&gt;block_size);
@@ -309,21 +358,29 @@ test_cipher_ctr(const struct nettle_cipher *cipher,
       FAIL();
     }
 
-  free(ctx);
-  free(data);
   free(ctr);
+  free(data);
+  free(ctx);
+  free((void *)ictr);
+  free((void *)ciphertext);
+  free((void *)cleartext);
+  free((void *)key);
 }
 
 void
 test_cipher_stream(const struct nettle_cipher *cipher,
-		   unsigned key_length,
-		   const uint8_t *key,
-		   unsigned length,
-		   const uint8_t *cleartext,
-		   const uint8_t *ciphertext)
+		   const uint8_t *key_hex,
+		   const uint8_t *cleartext_hex,
+		   const uint8_t *ciphertext_hex)
 {
+  unsigned key_length = decode_hex_length(key_hex);
+  const uint8_t *key = decode_hex_dup(key_hex);
+  unsigned length = decode_hex_length(cleartext_hex);
+  const uint8_t *cleartext = decode_hex_dup(cleartext_hex);
+  const uint8_t *ciphertext = decode_hex_dup(ciphertext_hex);
+
   unsigned block;
-  
+
   void *ctx = xalloc(cipher-&gt;context_size);
   uint8_t *data = xalloc(length + 1);
   
@@ -376,23 +433,33 @@ test_cipher_stream(const struct nettle_cipher *cipher,
       FAIL();	    
     }
 
-  free(ctx);
   free(data);
+  free(ctx);
+  free((void *)ciphertext);
+  free((void *)cleartext);
+  free((void *)key);
 }
 
 void
 test_aead(const struct nettle_aead *aead,
-	  unsigned key_length,
-	  const uint8_t *key,
-	  unsigned auth_length,
-	  const uint8_t *authtext,
-	  unsigned length,
-	  const uint8_t *cleartext,
-	  const uint8_t *ciphertext,
-	  unsigned iv_length,
-	  const uint8_t *iv,
-	  const uint8_t *digest)
+	  const uint8_t *key_hex,
+	  const uint8_t *authtext_hex,
+	  const uint8_t *cleartext_hex,
+	  const uint8_t *ciphertext_hex,
+	  const uint8_t *iv_hex,
+	  const uint8_t *digest_hex)
 {
+  unsigned key_length = decode_hex_length(key_hex);
+  const uint8_t *key = decode_hex_dup(key_hex);
+  unsigned auth_length = decode_hex_length(authtext_hex);
+  const uint8_t *authtext = decode_hex_dup(authtext_hex);
+  unsigned length = decode_hex_length(cleartext_hex);
+  const uint8_t *cleartext = decode_hex_dup(cleartext_hex);
+  const uint8_t *ciphertext = decode_hex_dup(ciphertext_hex);
+  unsigned iv_length = decode_hex_length(iv_hex);
+  const uint8_t *iv = decode_hex_dup(iv_hex);
+  const uint8_t *digest = decode_hex_dup(digest_hex);
+
   void *ctx = xalloc(aead-&gt;context_size);
   uint8_t *data = xalloc(length);
   uint8_t *buffer = xalloc(aead-&gt;block_size);
@@ -438,14 +505,22 @@ test_aead(const struct nettle_aead *aead,
   free(ctx);
   free(data);
   free(buffer);
+  free((void *)digest);
+  free((void *)iv);
+  free((void *)ciphertext);
+  free((void *)cleartext);
+  free((void *)authtext);
+  free((void *)key);
 }
 
 void
-test_hash(const struct nettle_hash *hash,
-	  unsigned length,
+test_hash_mem(const struct nettle_hash *hash,
+          unsigned length,
 	  const uint8_t *data,
-	  const uint8_t *digest)
+	  const uint8_t *digest_hex)
 {
+  const uint8_t *digest = decode_hex_dup(digest_hex);
+
   void *ctx = xalloc(hash-&gt;context_size);
   uint8_t *buffer = xalloc(hash-&gt;digest_size);
 
@@ -468,8 +543,32 @@ test_hash(const struct nettle_hash *hash,
   if (buffer[hash-&gt;digest_size - 1])
     FAIL();
 
-  free(ctx);
   free(buffer);
+  free(ctx);
+  free((void *)digest);
+}
+
+void
+test_hash(const struct nettle_hash *hash,
+	  const uint8_t *data,
+	  const uint8_t *digest_hex)
+{
+  unsigned length = strlen(data);
+
+  test_hash_mem(hash, length, data, digest_hex);
+}
+
+void
+test_hash_hex(const struct nettle_hash *hash,
+	  const uint8_t *data_hex,
+	  const uint8_t *digest_hex)
+{
+  unsigned length = decode_hex_length(data_hex);
+  const uint8_t *data = decode_hex_dup(data_hex);
+
+  test_hash_mem(hash, length, data, digest_hex);
+
+  free((void *)data);
 }
 
 void
@@ -1069,6 +1168,8 @@ test_dsa_key(struct dsa_public_key *pub,
   
   mpz_powm(t, pub-&gt;g, key-&gt;x, pub-&gt;p);
   ASSERT(0 == mpz_cmp(t, pub-&gt;y));
+
+  mpz_clear(t);
 }
 
 #endif /* WITH_HOGWEED */
diff --git a/testsuite/testutils.h b/testsuite/testutils.h
index d7ced9a..8b35160 100644
--- a/testsuite/testutils.h
+++ b/testsuite/testutils.h
@@ -32,6 +32,12 @@ extern "C" {
 void *
 xalloc(size_t size);
 
+int
+memeq_hex(unsigned length, const uint8_t *s1, const uint8_t *s2_hex);
+
+const uint8_t *
+encode_hex_dup(const uint8_t *data, unsigned length);
+
 /* Decodes a NUL-terminated hex string. */
 
 unsigned
@@ -84,56 +90,54 @@ struct nettle_mac
  
 void
 test_cipher(const struct nettle_cipher *cipher,
-	    unsigned key_length,
-	    const uint8_t *key,
-	    unsigned length,
-	    const uint8_t *cleartext,
-	    const uint8_t *ciphertext);
+	    const uint8_t *key_hex,
+	    const uint8_t *cleartext_hex,
+	    const uint8_t *ciphertext_hex);
 
 void
 test_cipher_cbc(const struct nettle_cipher *cipher,
-		unsigned key_length,
 		const uint8_t *key,
-		unsigned length,
 		const uint8_t *cleartext,
 		const uint8_t *ciphertext,
 		const uint8_t *iv);
 
 void
 test_cipher_ctr(const struct nettle_cipher *cipher,
-		unsigned key_length,
-		const uint8_t *key,
-		unsigned length,
-		const uint8_t *cleartext,
-		const uint8_t *ciphertext,
-		const uint8_t *iv);
+		const uint8_t *key_hex,
+		const uint8_t *cleartext_hex,
+		const uint8_t *ciphertext_hex,
+		const uint8_t *iv_hex);
 
 void
 test_cipher_stream(const struct nettle_cipher *cipher,
-		   unsigned key_length,
-		   const uint8_t *key,
-		   unsigned length,
-		   const uint8_t *cleartext,
-		   const uint8_t *ciphertext);
+		   const uint8_t *key_hex,
+		   const uint8_t *cleartext_hex,
+		   const uint8_t *ciphertext_hex);
 
 void
 test_aead(const struct nettle_aead *aead,
-	  unsigned key_length,
-	  const uint8_t *key,
-	  unsigned auth_length,
-	  const uint8_t *authtext,
+	  const uint8_t *key_hex,
+	  const uint8_t *authtext_hex,
+	  const uint8_t *cleartext_hex,
+	  const uint8_t *ciphertext_hex,
+	  const uint8_t *iv_hex,
+	  const uint8_t *digest_hex);
+
+void
+test_hash_mem(const struct nettle_hash *hash,
 	  unsigned length,
-	  const uint8_t *cleartext,
-	  const uint8_t *ciphertext,
-	  unsigned iv_length,
-	  const uint8_t *iv,
-	  const uint8_t *digest);
+	  const uint8_t *data,
+	  const uint8_t *digest_hex);
 
 void
 test_hash(const struct nettle_hash *hash,
-	  unsigned length,
 	  const uint8_t *data,
-	  const uint8_t *digest);
+	  const uint8_t *digest_hex);
+
+void
+test_hash_hex(const struct nettle_hash *hash,
+	  const uint8_t *data_hex,
+	  const uint8_t *digest_hex);
 
 void
 test_hash_large(const struct nettle_hash *hash,
@@ -203,19 +207,13 @@ test_dsa_key(struct dsa_public_key *pub,
 }
 #endif
 
-#define H2(d, s) decode_hex((d), (s))
 #define H(x) decode_hex_dup(x)
-#define HL(x) decode_hex_length(x), decode_hex_dup(x)
 
 /* LDATA needs to handle NUL characters. */
 #define LLENGTH(x) (sizeof(x) - 1)
 #define LDATA(x) (sizeof(x) - 1), x
-#define LDUP(x) strlen(x), strdup(x)
 
 #define MEMEQ(length, a, b) (!memcmp((a), (b), (length)))
-#define MEMEQH(length, a, b) \
-((length) == decode_hex_length((b)) \
- &amp;&amp; !memcmp((a), decode_hex_dup((b)), (length)))
 
 #define FAIL() abort()
 #define SKIP() exit(77)
diff --git a/testsuite/twofish-test.c b/testsuite/twofish-test.c
index 65558d3..5a50a99 100644
--- a/testsuite/twofish-test.c
+++ b/testsuite/twofish-test.c
@@ -6,23 +6,23 @@ test_main(void)
 {
   /* 128 bit key */
   test_cipher(&amp;nettle_twofish128,
-	      HL("0000000000000000 0000000000000000"),
-	      HL("0000000000000000 0000000000000000"),
-	      H("9F589F5CF6122C32 B6BFEC2F2AE8C35A"));
+	      "0000000000000000 0000000000000000",
+	      "0000000000000000 0000000000000000",
+	      "9F589F5CF6122C32 B6BFEC2F2AE8C35A");
 
   /* 192 bit key */
   test_cipher(&amp;nettle_twofish192,
-	      HL("0123456789ABCDEF FEDCBA9876543210"
-		 "0011223344556677"),
-	      HL("0000000000000000 0000000000000000"),
-	      H("CFD1D2E5A9BE9CDF 501F13B892BD2248"));
+	      "0123456789ABCDEF FEDCBA9876543210"
+		 "0011223344556677",
+	      "0000000000000000 0000000000000000",
+	      "CFD1D2E5A9BE9CDF 501F13B892BD2248");
 
   /* 256 bit key */
   test_cipher(&amp;nettle_twofish256,
-	      HL("0123456789ABCDEF FEDCBA9876543210"
-		 "0011223344556677 8899AABBCCDDEEFF"),
-	      HL("0000000000000000 0000000000000000"),
-	      H("37527BE0052334B8 9F0CFCCAE87CFA20"));
+	      "0123456789ABCDEF FEDCBA9876543210"
+		 "0011223344556677 8899AABBCCDDEEFF",
+	      "0000000000000000 0000000000000000",
+	      "37527BE0052334B8 9F0CFCCAE87CFA20");
 
   SUCCESS();
 }
diff --git a/testsuite/yarrow-test.c b/testsuite/yarrow-test.c
index 5f01e76..007a650 100644
--- a/testsuite/yarrow-test.c
+++ b/testsuite/yarrow-test.c
@@ -39,6 +39,8 @@ get_event(FILE *f, struct sha256_ctx *hash,
 static FILE *
 open_file(const char *name)
 {
+  FILE *fp;
+
   /* Tries opening the file in $srcdir, if set, otherwise the current
    * working directory */
 
@@ -48,11 +50,17 @@ open_file(const char *name)
       /* Leaks this name, but that doesn't matter. */
       char *buf = xalloc(strlen(name) + strlen(srcdir) + 10);
       sprintf(buf, "%s/%s", srcdir, name);
-      name = buf;
+      /* Opens the file in text mode. */
+      fp = fopen(buf, "r");
+      free(buf);
+    }
+  else
+    {
+      /* Opens the file in text mode. */
+      fp = fopen(name, "r");
     }
 
-  /* Opens the file in text mode. */
-  return fopen(name, "r");
+  return fp;
 }
 
 int
@@ -216,6 +224,11 @@ test_main(void)
       fprintf(stderr, "Failed.\n");
       return EXIT_FAILURE;
     }
-  
+
+  fclose(input);
+  free((void *)expected_seed_file);
+  free((void *)expected_input);
+  free((void *)expected_output);
+
   return EXIT_SUCCESS;
 }
diff --git a/tools/pkcs1-conv.c b/tools/pkcs1-conv.c
index 40420c4..042b203 100644
--- a/tools/pkcs1-conv.c
+++ b/tools/pkcs1-conv.c
@@ -438,6 +438,8 @@ convert_public_key(struct nettle_buffer *buffer, unsigned length, \
const uint8_t  nettle_buffer_reset(buffer);
 		      res = rsa_keypair_to_sexp(buffer, NULL, &amp;pub, NULL) &gt; 0;
 		    }
+
+		  rsa_public_key_clear(&amp;pub);
 		}
 	      if (!res)
 		werror("SubjectPublicKeyInfo: Invalid RSA key.\n");
@@ -656,5 +658,8 @@ main(int argc, char **argv)
 	  fclose(f);
 	}
     }
+
+  nettle_buffer_clear(&amp;buffer);
+
   return EXIT_SUCCESS;
 }



</body></email><email><emailId>20120914063220</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-14 06:32:20-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

&gt; If it is a huge effort to release memory from the testsuite, it may not
&gt; be worth it.  But if it is a small effort, and it leads to being able to
&gt; run all the testsuite under valgrind without any warnings, I would
&gt; support doing it.

Yesterday, I send a 170Kb patch to the list... but it did not appear.
What can/should I do ?

Regards, Tim

</body></email><email><emailId>20120914072353</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-14 07:23:53-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; There is just changed file outside testsuite/ and examples/ : buffer.c.
&gt; nettle_buffer_clear() used to call realloc() with a length of 0 to wipe the 
&gt; allocated memory. But at least here it comes back with a valid pointer to one 
&gt; allocated byte (as valgrind reports). I use free() after the realloc if the 
&gt; returned pointer is not NULL (maybe realloc() should not be called at all !?). 

This is a bit tricky. The nettle_buffer interface lets the user
configure memory allocation using a single function pointer to the
user's realloc function. It's not required to be compatible in any way
with libc free.

My man page for realloc says

       realloc() changes the size of the memory block pointed to by ptr
       to size bytes. [...] if size is equal to zero,
       and ptr is not NULL, then the call is equivalent to free(ptr).

The spec at

  http://pubs.opengroup.org/onlinepubs/9699919799/functions/realloc.html

seems to agree. But when describing the return value, it allows a valid
pointer to be returned,

  If size is 0, either a null pointer or a unique pointer that can be
  successfully passed to free() shall be returned.

Does that mean that the spec allows the program

  int main (int argc, char **argv)
  {
    void *p;
    while ( (p = malloc(1)) )
      realloc (p, 0);
    return 1;
  }

to leak one byte of storage per iteration? If we need a workaround, the
right place is in the realloc wrapppers in realloc.c.

&gt; I did not remove or add any tests, just changed / added / removed some stuff 
&gt; from testutils.c and of course within the *-test.c(xx).

I think it would have been good to discuss the aproach on list, before
doing that work.

&gt; Niels, please remove the quotes from "$EMULATOR" in run-tests (my run-tests is 
&gt; somehow already in the local repo with some other changes I just can't 
&gt; revert).

I'm aware that needs fixing.

&gt;  int
&gt;  test_main(void)
&gt;  {
&gt;    /* 128 bit keys */
&gt; -  test_cipher(&amp;nettle_aes128, 
&gt; -	      HL("0001020305060708 0A0B0C0D0F101112"),
&gt; -	      HL("506812A45F08C889 B97F5980038B8359"),
&gt; -	      H("D8F532538289EF7D 06B506A4FD5BE9C9"));
&gt; +  test_cipher(&amp;nettle_aes128,
&gt; +	      "0001020305060708 0A0B0C0D0F101112",
&gt; +	      "506812A45F08C889 B97F5980038B8359",
&gt; +	      "D8F532538289EF7D 06B506A4FD5BE9C9");

The reason I introduced the HL and LDATA macros was that I find it
useful that the testcases can chose either hex data or raw binary data.
A change requiring hex everywhare is not so attractive. Maybe the macros
can be fixed to arrange for deallocation (e.g, put all allocated strings
on a list and free it at the end of main). Or, of we pass only a const
char * to the various functions, include some prefix to say if it's hex
or raw data (with length; I'd prefer to not rely on strlen here).

&gt; +  unsigned key_length = decode_hex_length(key_hex);
&gt; +  const uint8_t *key = decode_hex_dup(key_hex);
&gt; +  unsigned length = decode_hex_length(cleartext_hex);
&gt; +  const uint8_t *cleartext = decode_hex_dup(cleartext_hex);
&gt; +  const uint8_t *ciphertext = decode_hex_dup(ciphertext_hex);
&gt; +
&gt;    struct arctwo_ctx ctx;
&gt;    uint8_t *data = xalloc(length);
&gt;  
&gt; @@ -46,6 +50,9 @@ test_arctwo(unsigned ekb,
&gt;      FAIL();
&gt;  
&gt;    free(data);
&gt; +  free((void *)ciphertext);
&gt; +  free((void *)cleartext);
&gt; +  free((void *)key);
&gt;  }

It's unfortunate that the free prototype doesn't take a const void *,
but we have to live with that. In this case, I think it's preferable to
drop const from the declaration of those pointers, so there's no need
for those explicit casts.

The less intrusive changes I'll try to get to within a few days.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120914075644</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-14 07:56:44-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Am Friday 14 September 2012 schrieb Niels Möller:
&gt; Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:
&gt; &gt; There is just changed file outside testsuite/ and examples/ : buffer.c.
&gt; &gt; nettle_buffer_clear() used to call realloc() with a length of 0 to wipe
&gt; &gt; the allocated memory. But at least here it comes back with a valid
&gt; &gt; pointer to one allocated byte (as valgrind reports). I use free() after
&gt; &gt; the realloc if the returned pointer is not NULL (maybe realloc() should
&gt; &gt; not be called at all !?).
&gt; 
&gt; This is a bit tricky. The nettle_buffer interface lets the user
&gt; configure memory allocation using a single function pointer to the
&gt; user's realloc function. It's not required to be compatible in any way
&gt; with libc free.
&gt; 
&gt; My man page for realloc says
&gt; 
&gt;        realloc() changes the size of the memory block pointed to by ptr
&gt;        to size bytes. [...] if size is equal to zero,
&gt;        and ptr is not NULL, then the call is equivalent to free(ptr).

My man page says (Embedded GNU C Library 2.13)
       If size was equal to 0, either
       NULL or a pointer suitable to be passed to free() is returned.
       CONFORMING TO
         C89, C99.

My change handles both cases.

&gt; If we need a workaround, the
&gt; right place is in the realloc wrapppers in realloc.c.

We need a workaround since different libraries handle it differently.
But simplified it is just a if (p) free(p);

&gt; &gt;  int
&gt; &gt;  test_main(void)
&gt; &gt;  {
&gt; &gt;  
&gt; &gt;    /* 128 bit keys */
&gt; &gt; 
&gt; &gt; -  test_cipher(&amp;nettle_aes128,
&gt; &gt; -	      HL("0001020305060708 0A0B0C0D0F101112"),
&gt; &gt; -	      HL("506812A45F08C889 B97F5980038B8359"),
&gt; &gt; -	      H("D8F532538289EF7D 06B506A4FD5BE9C9"));
&gt; &gt; +  test_cipher(&amp;nettle_aes128,
&gt; &gt; +	      "0001020305060708 0A0B0C0D0F101112",
&gt; &gt; +	      "506812A45F08C889 B97F5980038B8359",
&gt; &gt; +	      "D8F532538289EF7D 06B506A4FD5BE9C9");
&gt; 
&gt; The reason I introduced the HL and LDATA macros was that I find it
&gt; useful that the testcases can chose either hex data or raw binary data.
&gt; A change requiring hex everywhare is not so attractive.

I handled that case in hmac-test.c by introducing a 'flags' param that gives a 
hint which of the data params is hex and which is not.

e.g.
  hmac_test(alg_md5, MD5_DIGEST_SIZE, HEX_NONE,
	    "Jefe",
	    "what do ya want for nothing?",
	    "750c783e6ab0b503 eaa86e310a5db738");

  hmac_test(alg_md5, MD5_DIGEST_SIZE, (HEX_KEY|HEX_MSG),
	    "aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa",
	    "dddddddddddddddd dddddddddddddddd"
	       "dddddddddddddddd dddddddddddddddd"
	       "dddddddddddddddd dddddddddddddddd"
	       "dddd",
	    "56be34521d144c88 dbb8c733f0e8b3f6");


&gt; &gt; +  unsigned key_length = decode_hex_length(key_hex);
&gt; &gt; +  const uint8_t *key = decode_hex_dup(key_hex);
&gt; &gt; +  unsigned length = decode_hex_length(cleartext_hex);
&gt; &gt; +  const uint8_t *cleartext = decode_hex_dup(cleartext_hex);
&gt; &gt; +  const uint8_t *ciphertext = decode_hex_dup(ciphertext_hex);
...
&gt; &gt; +  free((void *)ciphertext);
&gt; &gt; +  free((void *)cleartext);
&gt; &gt; +  free((void *)key);
&gt; 
&gt; It's unfortunate that the free prototype doesn't take a const void *,
&gt; but we have to live with that. In this case, I think it's preferable to
&gt; drop const from the declaration of those pointers, so there's no need
&gt; for those explicit casts.

I personally prefer a macro, something like
#define xfree(a) do { if (a) { free((void *)(a)); a=NULL; } } while (0)

&gt; The less intrusive changes I'll try to get to within a few days.

You could tell which points you would like to have changed, and i'll change 
them here. After we are done, the patch could be applied in whole.
I'll do the coding and you the review...

Regards, Tim

</body></email><email><emailId>20120914082250</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-14 08:22:50-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; Am Friday 14 September 2012 schrieb Niels Möller:
&gt;&gt; If we need a workaround, the
&gt;&gt; right place is in the realloc wrapppers in realloc.c.
&gt;
&gt; We need a workaround since different libraries handle it differently.
&gt; But simplified it is just a if (p) free(p);

I think something like this (untested) should solve the problem. We
should also document somewhere that buffer-&gt;realloc(p, 0) is expected to
free the storage completely.

--- a/realloc.c
+++ b/realloc.c
@@ -34,13 +34,25 @@
 void *
 nettle_realloc(void *ctx UNUSED, void *p, unsigned length)
 {
+  if (length == 0)
+    {
+      free (p);
+      return NULL;
+    }
   return realloc(p, length);
 }
 
 void *
 nettle_xrealloc(void *ctx UNUSED, void *p, unsigned length)
 {
-  void *n = realloc(p, length);
-  if (length &amp;&amp; !n)
+  void *n;
+  if (length == 0)
+    {
+      free (p);
+      return NULL;
+    }
+
+  n = realloc(p, length);
+  if (!n)
     {
       fprintf(stderr, "Virtual memory exhausted.\n");

&gt; You could tell which points you would like to have changed, and i'll change 
&gt; them here. After we are done, the patch could be applied in whole.
&gt; I'll do the coding and you the review...

Thanks. Then I'd like you to try to keep the interface of the HL, H,
LDATA, LDUP macros intact, so you don't need to modify each and every
test case, but add whatever additional machinery is needed to avoid
memory leaks (linked list of allocated strings, GNU obstack, allocation
from a static area, or whatever seems suitable). For the test files, I
don't think it's a problem if we keep the allocations a bit longer than
necessary. If that approach gets too painful, we'll have to consider
some other way.

I prefer to do things in small pieces, so if I get to it before the rest
of the fixes are ready, I'll check in missing mpz_clear and similar.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120914092353</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-14 09:23:53-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

&gt; &gt; You could tell which points you would like to have changed, and i'll
&gt; &gt; change them here. After we are done, the patch could be applied in
&gt; &gt; whole. I'll do the coding and you the review...
&gt; 
&gt; Thanks. Then I'd like you to try to keep the interface of the HL, H,
&gt; LDATA, LDUP macros intact, so you don't need to modify each and every
&gt; test case, but add whatever additional machinery is needed to avoid
&gt; memory leaks (linked list of allocated strings, GNU obstack, allocation
&gt; from a static area, or whatever seems suitable).

Here is just my opinion - it is not meant to offend you:

The HL and LDUP macros were really ugly and in very most cases not even 
needed.
I already replaced them by extending the basic testroutines. So there is no 
need for linked list or whatever to keep track of allocated memory.
Keeping it simple should be the preferred way.

If the day comes, that we have to further extend basic testroutines, because 
we *need* some mixture or HEX/BASE64/String/memory or whatever, we will extend 
them. Not now, because it is just not needed right now.

You are the maintainer and you decide what you like and what not.
But if you insist in keeping the H, HL, LDUP macros, I have to cancel my 
offer, sorry. I can't work against my strong conviction.

Regards, Tim

</body></email><email><emailId>20120914114826</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-14 11:48:26-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; The HL and LDUP macros were really ugly and in very most cases not even 
&gt; needed.

They're intended as a kind of "mini-language" for the tests. I have
earlier (in the lsh project, years ago) tried using m4 for the same
purpose, but in the end I concluded that it was overal less trouble to
just use the C preprocessor.

What in particular do you find ugly? That they expand to two arguments?
Short cryptic names? Something else?

Wold you like them better if they expanded to some constructor calls for
proper string objects olding both length and data, which were then
passed to the various test helper functions? I don't care very much
about the implementation of the mini-language.

&gt; But if you insist in keeping the H, HL, LDUP macros, I have to cancel my 
&gt; offer, sorry.

I'll do that myself then.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120914130557</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-14 13:05:57-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Am Friday 14 September 2012 schrieb Niels Möller:
&gt; Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:
&gt; &gt; The HL and LDUP macros were really ugly and in very most cases not even
&gt; &gt; needed.
&gt; 
&gt; They're intended as a kind of "mini-language" for the tests. I have
&gt; earlier (in the lsh project, years ago) tried using m4 for the same
&gt; purpose, but in the end I concluded that it was overal less trouble to
&gt; just use the C preprocessor.

But after all, you still won't need them. Just have a look in the patched 
hmac-test.c, where you can find are mixtures of hex data and strings.

&gt; What in particular do you find ugly? That they expand to two arguments?
&gt; Short cryptic names? Something else?

Yes. Yes. Yes.
But the main uglyness is that they don't track memory allocations. You could 
of course (as you proposed) include some memory tracking structures/functions. 
But that would even be less elegant (brrr..., it shakes me a bit).

&gt; Wold you like them better if they expanded to some constructor calls for
&gt; proper string objects olding both length and data, which were then
&gt; passed to the various test helper functions? I don't care very much
&gt; about the implementation of the mini-language.

Yes, that is an alternative, though it requires to throw away most of the 
already working patches (sniff). H() would merge into HL().

Proposal (not tested):
typedef struct {
  unsigned length;
  uint8_t *data;
} testdata_t;

/* example HL() implementation with just one malloc() */
testdata_t *HL(const uint8_t *hex)
{
  unsigned length = decode_hex_length(hex);
  testdata_t *data = xalloc(sizeof(testdata_t) + length);

  data.length = length;
  data.data = &amp;data.data + sizeof(data.data);
  decode_hex(data.data, hex);

  return data;
}

/* example test function with my first patch */
void
test_cipher(const struct nettle_cipher *cipher,
	    const uint8_t *key_hex,
	    const uint8_t *cleartext_hex,
	    const uint8_t *ciphertext_hex)
{
  unsigned key_length = decode_hex_length(key_hex);
  const uint8_t *key = decode_hex_dup(key_hex);
  unsigned length = decode_hex_length(cleartext_hex);
  const uint8_t *cleartext = decode_hex_dup(cleartext_hex);
  const uint8_t *ciphertext = decode_hex_dup(ciphertext_hex);

  ...

  free((void *)ciphertext);
  free((void *)cleartext);
  free((void *)key);
}

/* example test function with testdata_t */
void
test_cipher(const struct nettle_cipher *cipher,
	    testdata_t *key,
	    testdata_t *cleartext,
	    testdata_t *ciphertext)
{
  // use key.length instead of key_length, etc.
  ...

  free(ciphertext);
  free(cleartext);
  free(key);
}

/* example call to test function */
  test_cipher(&amp;nettle_aes128,
	      HL("0001020305060708 0A0B0C0D0F101112"),
	      HL("506812A45F08C889 B97F5980038B8359"),
	      HL("D8F532538289EF7D 06B506A4FD5BE9C9"));

BTW
xmalloc should be slightly changed to not allow size 0 (either fail or 
allocated a 1 byte size).
From my man pages:
If size is 0, then malloc() returns either NULL, or a unique pointer value 
that  can  later  be successfully passed to free().


Regards, Tim


</body></email><email><emailId>20120914135756</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-14 13:57:56-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; But after all, you still won't need them. Just have a look in the patched 
&gt; hmac-test.c, where you can find are mixtures of hex data and strings.

I haven't read the complete patch very carefully. In hmac-test.c, you
have introduced a flag argument, which is not as clumsy as I had
expected (but I prefer my preprocessor hack before your algorithm enum
and corresponding switch statement; I think it's clear that we have
somewhat different taste).

In other places, you have introduced additional functions, like
test_hash and test_hash_hex. I prefer a style which looks more like
functional programming, with a single test_hash using a canonical
representation of the input, and then the caller invokes any helper
macro or function needed to convert data from whatever form is most
convenient in the test file.

Then I happily admit that the current implementation with macros is not
very beautiful.

&gt; /* example test function with testdata_t */
&gt; void
&gt; test_cipher(const struct nettle_cipher *cipher,
&gt; 	    testdata_t *key,
&gt; 	    testdata_t *cleartext,
&gt; 	    testdata_t *ciphertext)
&gt; {
&gt;   // use key.length instead of key_length, etc.
&gt;   ...
&gt;
&gt;   free(ciphertext);
&gt;   free(cleartext);
&gt;   free(key);
&gt; }

In this model, we have a producer/consumer convention. The passed in
data is *always* malloced, to be freed by the test function. That's a
good idea, if we now consider deallocation important, that convention
will simplify things (at the cost of an unnecessary allocation in the
few cases where we now pass a string literal as the pointer).

&gt; xmalloc should be slightly changed to not allow size 0 (either fail or 
&gt; allocated a 1 byte size).
&gt; From my man pages:
&gt; If size is 0, then malloc() returns either NULL, or a unique pointer value 
&gt; that  can  later  be successfully passed to free().

I don't see the problem.

First, it is important to note that callers of xalloc are not expected
to check the return value of xalloc, it will never return NULL except
maybe when size == 0, and in that case it does *not* indicate that
allocation failed. By definition, if xalloc returned, then it did not
fail.

Noow, xalloc is sometimes called with size 0, for example if you do
decode_hex_dup(""). That's why its check for malloc failing also has to
check size. It will succeed (i.e., not abort) no matter which convention
for size == 0 which malloc follows, and simply return whatever malloc
returns.

As far as I see, it doesn't matter if malloc (and hence xalloc) returns
NULL or a valid pointer, in either case, the caller should not
dereference the pointer, and eventually pass it to on to free. 

In which way do you think it fails?

Reggards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120914152809</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-14 15:28:09-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Am Friday 14 September 2012 schrieb Niels Möller:
&gt; Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:
&gt; &gt; But after all, you still won't need them. Just have a look in the patched
&gt; &gt; hmac-test.c, where you can find are mixtures of hex data and strings.
&gt; 
&gt; I haven't read the complete patch very carefully. In hmac-test.c, you
&gt; have introduced a flag argument, which is not as clumsy as I had
&gt; expected (but I prefer my preprocessor hack before your algorithm enum
&gt; and corresponding switch statement; I think it's clear that we have
&gt; somewhat different taste).

I just saw how the _NETTLE_HASH macro is working. Using that, the enum could 
be removed. E.g. by including md5-meta.h, we have a nettle_md5 variable 
declared, which holds all we need (context, init, update, maybe not a set_key 
function). At least something like that.

&gt; In other places, you have introduced additional functions, like
&gt; test_hash and test_hash_hex. I prefer a style which looks more like
&gt; functional programming, with a single test_hash using a canonical
&gt; representation of the input, and then the caller invokes any helper
&gt; macro or function needed to convert data from whatever form is most
&gt; convenient in the test file.

Ok, the proposed HL() function would obsolete test_hash_hex().

&gt; Then I happily admit that the current implementation with macros is not
&gt; very beautiful.

:-)


&gt; &gt; /* example test function with testdata_t */
&gt; &gt; void
&gt; &gt; test_cipher(const struct nettle_cipher *cipher,
&gt; &gt; 
&gt; &gt; 	    testdata_t *key,
&gt; &gt; 	    testdata_t *cleartext,
&gt; &gt; 	    testdata_t *ciphertext)
&gt; &gt; 
&gt; &gt; {
&gt; &gt; 
&gt; &gt;   // use key.length instead of key_length, etc.
&gt; &gt;   ...
&gt; &gt;   
&gt; &gt;   free(ciphertext);
&gt; &gt;   free(cleartext);
&gt; &gt;   free(key);
&gt; &gt; 
&gt; &gt; }
&gt; 
&gt; In this model, we have a producer/consumer convention. The passed in
&gt; data is *always* malloced, to be freed by the test function. That's a
&gt; good idea, if we now consider deallocation important, that convention
&gt; will simplify things (at the cost of an unnecessary allocation in the
&gt; few cases where we now pass a string literal as the pointer).

Not the allocation/strdup in unnecessary. It is just the call to 
decode_hex_length().

&gt; &gt; xmalloc should be slightly changed to not allow size 0 (either fail or
&gt; &gt; allocated a 1 byte size).
&gt; &gt; From my man pages:
&gt; &gt; If size is 0, then malloc() returns either NULL, or a unique pointer
&gt; &gt; value that  can  later  be successfully passed to free().
&gt; 
&gt; I don't see the problem.
&gt; 
&gt; First, it is important to note that callers of xalloc are not expected
&gt; to check the return value of xalloc, it will never return NULL except
&gt; maybe when size == 0, and in that case it does *not* indicate that
&gt; allocation failed. By definition, if xalloc returned, then it did not
&gt; fail.
&gt; 
&gt; Noow, xalloc is sometimes called with size 0, for example if you do
&gt; decode_hex_dup(""). That's why its check for malloc failing also has to
&gt; check size. It will succeed (i.e., not abort) no matter which convention
&gt; for size == 0 which malloc follows, and simply return whatever malloc
&gt; returns.
&gt; 
&gt; As far as I see, it doesn't matter if malloc (and hence xalloc) returns
&gt; NULL or a valid pointer, in either case, the caller should not
&gt; dereference the pointer, and eventually pass it to on to free.

My proposed HL() routine expects xalloc never to return NULL.
But that is easy to check.

The only argument for a change is, that malloc and thus xalloc behaves 
different on different plattforms. A defined behaviour of xalloc for all 
plattforms would make it more predictable. It is just a practical 
consideration for testing. Does not really matter to me.

Regards, Tim

</body></email><email><emailId>20120916192252</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-16 19:22:52-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; Yes, it was some hours of work, but here is a patch that releases all memory 
&gt; and now runs fine with valgrind.

I've now done the same, in a slightly different manner. I first tried to
keep the convention that strings are passed as two arguments (length,
pointer), and tried to make callers always allocate the data, and
callees always free it. That turned out to be a bit inconvenient in a
few places. So I rewrote it with a simple string class, and then I could
just as well put all allocated strings on a linked list to be freed at
the end.

I'll try to clean it up and commit it soon.

I just pushed two simpler fixes, not quoting $EMULATOR in run-tests, and
memory leaks in the pkcs1-conv command line tool.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120919150610</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-19 15:06:10-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Am Sunday 16 September 2012 schrieb Niels Möller:
&gt; Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:
&gt; &gt; Yes, it was some hours of work, but here is a patch that releases all
&gt; &gt; memory and now runs fine with valgrind.
&gt; 
&gt; I've now done the same, in a slightly different manner. I first tried to
&gt; keep the convention that strings are passed as two arguments (length,
&gt; pointer), and tried to make callers always allocate the data, and
&gt; callees always free it. That turned out to be a bit inconvenient in a
&gt; few places. So I rewrote it with a simple string class, and then I could
&gt; just as well put all allocated strings on a linked list to be freed at
&gt; the end.
&gt; 
&gt; I'll try to clean it up and commit it soon.

Looks like you meanwhile comitted it.

There are just two little things left open:
* added mpz_clear in rsa-encrypt.c
* added nettle_buffer_clear, rsa_private_key_clear and free in rsa-keygen.c

Regards, Tim


diff --git a/examples/rsa-encrypt.c b/examples/rsa-encrypt.c
index 70d1503..ca1a8cd 100644
--- a/examples/rsa-encrypt.c
+++ b/examples/rsa-encrypt.c
@@ -253,7 +253,9 @@ main(int argc, char **argv)
     }
 
   write_bignum(stdout, x);
-  
+
+  mpz_clear(x);
+
   if (!process_file(&amp;ctx,
                    stdin, stdout))
     return EXIT_FAILURE;
diff --git a/examples/rsa-keygen.c b/examples/rsa-keygen.c
index 0ca39b4..165e6f4 100644
--- a/examples/rsa-keygen.c
+++ b/examples/rsa-keygen.c
@@ -160,5 +160,12 @@ main(int argc, char **argv)
       return EXIT_FAILURE;
     }
 
+  nettle_buffer_clear(&amp;pub_buffer);
+  nettle_buffer_clear(&amp;priv_buffer);
+  rsa_private_key_clear(&amp;priv);
+  rsa_public_key_clear(&amp;pub);
+  free(pub_name);
+
+
   return EXIT_SUCCESS;
 }

</body></email><email><emailId>20120911145025</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-11 14:50:25-0400</timestampReceived><subject>[PATCH] silence more warnings</subject><body>

some little fixes for

nettle-hash.c:53:2: warning: ISO C does not allow extra ';' outside of a function \
[-pedantic] testutils.c:1072:2: warning: ISO C does not allow extra ';' outside of a \
function [-pedantic] des-compat-test.c:748:14: warning: old-style function definition \
[-Wold-style-definition] des-compat-test.c:755:17: warning: initialization discards \
'const' qualifier from pointer target type [enabled by default]

Regards, Tim

diff --cc testsuite/des-compat-test.c
index 257c343,257c343..4021ee8
--- a/testsuite/des-compat-test.c
+++ b/testsuite/des-compat-test.c
@@@ -745,14 -745,14 +745,13 @@@ plain[8+4], plain[8+5], plain[8+6], pla
        return(0);
        }
  
--static char *pt(p)
--const unsigned char *p;
++static char *pt(const unsigned char *p)
        {
        static char bufs[10][20];
        static int bnum=0;
        char *ret;
        int i;
--      static char *f="0123456789ABCDEF";
++      static const char *f="0123456789ABCDEF";
  
        ret= &amp;(bufs[bnum++][0]);
        bnum%=10;
diff --cc testsuite/testutils.c
index d77bb7e,d77bb7e..1b0fd88
--- a/testsuite/testutils.c
+++ b/testsuite/testutils.c
@@@ -1069,7 -1069,7 +1069,7 @@@ test_dsa_key(struct dsa_public_key *pub
    
    mpz_powm(t, pub-&gt;g, key-&gt;x, pub-&gt;p);
    ASSERT(0 == mpz_cmp(t, pub-&gt;y));
--};
++}
  
  #endif /* WITH_HOGWEED */
  
diff --cc tools/nettle-hash.c
index 842f9ff,5710216..bd03b18
--- a/tools/nettle-hash.c
+++ b/tools/nettle-hash.c
@@@ -50,9 -49,9 +50,9 @@@ list_algorithms (void
    for (i = 0; (alg = nettle_hashes[i]); i++)
      printf ("%10s %d (%d)\n",
            alg-&gt;name, alg-&gt;digest_size, alg-&gt;block_size);
--};
++}
  
 -static const struct nettle_hash *
 +static const struct nettle_hash * NONNULL(1)
  find_algorithm (const char *name)
  {
    const struct nettle_hash *alg;


</body></email><email><emailId>20120913081304</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-13 08:13:04-0400</timestampReceived><subject>Re: Three tests can't be created</subject><body>

Ups, sorry. I just didn't realize they are scripts.

Am Thursday 13 September 2012 schrieb Niels Möller:
&gt; Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:
&gt; &gt; there are three tests which cannot be build from source:
&gt; &gt; 
&gt; &gt; testsuite/sexp-conv-test
&gt; &gt; testsuite/symbols-test
&gt; &gt; testsuite/pkcs1-conv-test
&gt; 
&gt; Those test cases are shell scripts. Don't remove them. If they were
&gt; removed by make clean (but doesn't happen for me, at least), that's a
&gt; bug in the Makefile.
&gt; 
&gt; Regards,
&gt; /Niels

Regards, Tim

</body></email><email><emailId>20120914065711</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2012-09-14 06:57:11-0400</timestampReceived><subject>Re: List administrivia (was: Re: [PATCH] some patches to fix compiler warnings)</subject><body>

Am Friday 14 September 2012 schrieb Niels Möller:
&gt; Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:
&gt; &gt; Yesterday, I send a 170Kb patch to the list... but it did not appear.
&gt; &gt; What can/should I do ?
&gt; 
&gt; It was held for moderation due to its size (current limit seems to be 40
&gt; KB). I just approved it. Did you get any useful reply from the list
&gt; manager?

No, I didn't.

Regards, Tim

</body></email><email><emailId>20120914121115</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-14 12:11:15-0400</timestampReceived><subject>Re: Salsa20/8 and Salsa20/12</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Yes, although if necessary I could xor it to a zero buffer if there were
&gt; no other way...  

I was going to suggest using something like

void
salsa20_core (const uint32_t *input,
	      unsigned rounds,
	      unsigned length,
	      uint8_t *dst,
              const uint8_t *src)

which would compute the hash of the INPUT. If SRC is NULL, it would just
store the LENGTH first bytes at DST. And if SRC is non-NULL, it would
xor that data before storing.

A bit clumsy, but reasonably general.

But then I remembered that for high performance encryption, it's not
sufficient with an assembly function which does only one block. You can
gain a lot of performance (current code doesn't do that) by hashing two
input blocks in parallel.

So at the moment, I'm inclined to let the assembly function do
encryption, including xoring data and incrementing the counter. And if
you only need the hash, you'd need a wrapper which encrypts a zero
buffer and undoes the incrementing (the assembly
function could leave the input block unmodified and maintain the updated
counter locally; that would be a bit extra hassle but I don't think it
would impact performance). Then we have sufficient freedom for
optimizing salsa20 encryption, with a small performance disadvantage for
using just the hash.

&gt; however I'll loose performance, and my application
&gt; (scrypt) would benefit from good performance.

Will you be hashing several independent blocks? If so, for highest
perforamnce you would also neeed an interface which lets the assembly
routines do several blocks in parallel.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120919211310</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-19 21:13:10-0400</timestampReceived><subject>Re: [PATCH] some patches to fix compiler warnings</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; There are just two little things left open:
&gt; * added mpz_clear in rsa-encrypt.c
&gt; * added nettle_buffer_clear, rsa_private_key_clear and free in rsa-keygen.c

Thanks. Applied.

/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120921085455</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-09-21 08:54:55-0400</timestampReceived><subject>Re: [PATCH] PKCS #5 PBKDF2</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; I'll proceed cleaning up the Salsa code next, to reach my goal of having
&gt;&gt; scrypt in here as well (I have it working on
&gt;&gt; &lt;https://www.gitorious.org/scrypt/nettle-scrypt&gt;).
&gt;
&gt; That's the algorihtm described in
&gt; https://tools.ietf.org/html/draft-josefsson-scrypt-kdf-00, right?

Yes.

&gt; What features do you need for the salsa interface? After a quick look,
&gt; it seems you will not be processing independent blocks with salsa20, so
&gt; you will not be able to take any advantage of parallelism there (which I
&gt; imagine is an intended feature of scrypt).

Right.  See the patch in the last e-mail for the feature I need.

&gt; It's straight forward to add a round parameter to salsa20. But it's
&gt; still not clear to me what's the best way to support hashing only. It
&gt; would have been a bit easier if you could replace
&gt;
&gt;   X = Salsa(X xor B[i])
&gt;
&gt; by
&gt;
&gt;   X = Salsa(X) xor B[i]
&gt;
&gt; since the latter is closer to the standard encryption operation. I think
&gt; the iteration *can* be rewritten in that form by some change of
&gt; variables, but you'd need an extra xor at the end to really get Y[i]
&gt; rather than Y[i] xor B[i]. The algorithm specification is already set in
&gt; stone?

Setting it stone is my goal.  Scrypt has been in use for around 3 years
and is implemented in several languages.  Admittedly, several people
(including myself) have ideas about various tweaks to the algorithm that
may improve it, but I believe it is better for those ideas to be
described separately under a different name.  It would be extremely
confusing for "scrypt" to mean anything but the algorithm described in
the original paper.

/Simon

</body></email><email><emailId>20120923195422</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-23 19:54:22-0400</timestampReceived><subject>Re: Salsa20 core</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; nisse@lysator.liu.se (Niels Möller) writes:

&gt;&gt; * Do a _salsa20_core, working with uint32_t. Consider it an internal
&gt;&gt;   function, and keep the interface open (maybe it should be able to do
&gt;&gt;   several blocks, maybe it should byteswap output words, etc).
&gt;
&gt; Should that function really be declared in salsa20.h then?

Other internal but exported functions are declared in public headers, so
at least it's consistent.

&gt;&gt; * Implement and document salsa20_core. It takes uint8_t blocks as input
&gt;&gt;   and output (together with key and round count), and calls
&gt;&gt;   _salsa20_core to do the work.
&gt;
&gt; I assume you didn't mean key here, since it is unkeyed.

You're right, of course.

&gt;&gt; * Maybe do an x86_64 implementation of _salsa20_core (should be simpler
&gt;&gt;   than salsa20_crypt).
&gt;
&gt; Benchmarking it first might be good, I'm not sure you actually gain a
&gt; lot here since there is no chained block operation like stream ciphers
&gt; on bigger buffers.

Now benchmarking on my laptop, the C implementation takes 611 cycles
(9.5 cycles / byte), with 20 rounds. I just tried an assembly implementation based on
salsa20-crypt.asm. That takes 475 cycles (7.4 cycles / byte). Compared to
salsa20_crypt, which currently takes 6.5 cycles / byte.

&gt; I think we are essentially done though, so feel free to push things
&gt; according to the plan above. Or I can put together something next
&gt; week.

I've pushed _salsa20_core now. Note that it does byteswapping of the
output words, we'll see if that turns out to be good or bad for other
applications of it.

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120928185739</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-09-28 18:57:39-0400</timestampReceived><subject>Re: gost hash</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;  The attached patch adds the GOST R 34.11-94 hash algorithm. I based
&gt; this code on Alexei Kravchenko's code from librhash. The original code
&gt; [0] had inline assembly for x86 and x86-64 which is removed from this
&gt; version.

Thanks! I'll be a bit busy with other things in the weekend. I hope I
get time to look into it within a week.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120703210138</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-07-03 21:01:38-0400</timestampReceived><subject>Re: Using alloca on windows</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; That sounds like a sane solution to me - if it exists, including it
&gt; shouldn't hurt I guess.

Ok. Done and pushed now. Another windows problem: I get link warnings,
e.g.,

i586-mingw32msvc-gcc -g -O2 -ggdb3 -Wno-pointer-sign -Wall -W -Wmissing-prototypes \
-Wmissing-declarations -Wstrict-prototypes -Wpointer-arith -Wbad-function-cast \
-Wnested-externs -L.. nettle-benchmark.o nettle-openssl.o ../getopt.o ../getopt1.o \
                ../nettle-internal.o -lnettle   -o nettle-benchmark.exe
Info: resolving _nettle_aes128 by linking to __imp__nettle_aes128 (auto-import)
Info: resolving _nettle_aes192 by linking to __imp__nettle_aes192 (auto-import)
Info: resolving _nettle_aes256 by linking to __imp__nettle_aes256 (auto-import)
Info: resolving _nettle_arcfour128 by linking to __imp__nettle_arcfour128 \
                (auto-import)
Info: resolving _nettle_camellia128 by linking to __imp__nettle_camellia128 \
                (auto-import)
Info: resolving _nettle_camellia192 by linking to __imp__nettle_camellia192 \
                (auto-import)
Info: resolving _nettle_camellia256 by linking to __imp__nettle_camellia256 \
                (auto-import)
Info: resolving _nettle_cast128 by linking to __imp__nettle_cast128 (auto-import)
Info: resolving _nettle_serpent256 by linking to __imp__nettle_serpent256 \
                (auto-import)
Info: resolving _nettle_twofish128 by linking to __imp__nettle_twofish128 \
                (auto-import)
Info: resolving _nettle_twofish192 by linking to __imp__nettle_twofish192 \
                (auto-import)
Info: resolving _nettle_twofish256 by linking to __imp__nettle_twofish256 \
                (auto-import)
Info: resolving _nettle_md2 by linking to __imp__nettle_md2 (auto-import)
Info: resolving _nettle_md4 by linking to __imp__nettle_md4 (auto-import)
Info: resolving _nettle_md5 by linking to __imp__nettle_md5(auto-import)
Info: resolving _nettle_sha1 by linking to __imp__nettle_sha1 (auto-import)
Info: resolving _nettle_sha224 by linking to __imp__nettle_sha224 (auto-import)
Info: resolving _nettle_sha256 by linking to __imp__nettle_sha256 (auto-import)
Info: resolving _nettle_sha384 by linking to __imp__nettle_sha384 (auto-import)
Info: resolving _nettle_sha512 by linking to __imp__nettle_sha512 (auto-import)
Info: resolving _nettle_ripemd160 by linking to __imp__nettle_ripemd160 (auto-import)
Info: resolving __nettle_sha1_compress by linking to __imp___nettle_sha1_compress \
                (auto-import)
/usr/lib/gcc/i586-mingw32msvc/4.4.4/../../../../i586-mingw32msvc/bin/ld: warning: \
auto-importing has been activated without --enable-auto-import specified on the \
command line. This should work unless it involves constant data structures \
referencingsymbols from auto-imported DLLs.

I get similar warnings for building most or all executables. Most seem
harmless; make check succeeds (running all testprograms via wine).
However

  wine examples/nettle-benchmark.exe

crashes.

  wine: Unhandled page fault on execute access to 0x66210226 at address 0x66210226 \
(thread 0009), starting debugger...  Unhandled exception: page fault on execute \
access to 0x66210226 in 32-bit code (0x66210226).  [...]
  Backtrace:
  =&gt;1 0x66210226 (0x0062feb8)
    2 0x004010a7 in nettle-benchmark (+0x10a7) (0x0062fee8)
    3 0x00401143 in nettle-benchmark (+0x1143) (0x0062ff08)
    4 0x7b8783a8 in kernel32 (+0x583a8) (0x0062ffe8)
        
And it links in nettle-internal.o, which indeed defines a couple of
constant structures with pointers to functions in nettle.dll. Is there
any easy way to improve the situation? At this time, I don't want to
redo the dll rules and add dllimport and dllexport clutter to headers
(if that would even help?).

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120705080421</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-07-05 08:04:21-0400</timestampReceived><subject>Re: Getting a bit closer to release</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I think I'll double check that, and then check in that change.

Done now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120706203604</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-07-06 20:36:04-0400</timestampReceived><subject>Final nettle-2.5 prerelease</subject><body>

I think everything's in shape for release. But I'll postpone the formal
release to an evening *before* having a glass or two of wine. ;-)

So here's a final prerelease

  http://www.lysator.liu.se/~nisse/archive/nettle-2.5-pre2.tar.gz
  http://www.lysator.liu.se/~nisse/archive/nettle-2.5-pre2.tar.gz.sig

Hopefully the 2.5 release will differ in filename only.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120707140109</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-07-07 14:01:09-0400</timestampReceived><subject>ANNOUNCE: Nettle-2.5</subject><body>

I'm happy to annnounce a new version of GNU Nettle, a low-level
cryptographics library. The Nettle home page can be found at
http://www.lysator.liu.se/~nisse/nettle/.

NEWS for the 2.5 release

	This release includes important portability fixes for Windows
	and MacOS. There are also a few new features.

	First a *warning*: Some internal functions have been removed
	from the library. Since the functions in question are internal
	and not documented, this is not considered a change of ABI or
	API. Programs explicitly using any of these functions will
	break.
	
	* The function pkcs1_signature_prefix has been renamed to
	  _pkcs1_signature_prefix, and with slightly different
	  behavior.

	* The file nettle-internal.c is no longer included in the
          library (the features defined there are used by the
          benchmark and test programs, and were never intended for
          public use).

	New features:

	* Support for the salsa20 block cipher, including x86_64
          assembler. Originally contributed by Simon Josefsson, based
          on the reference implementation, then further optimized.

	* Tentative interface for timing-resistant RSA functions,
          contributed by Nikos Mavrogiannopoulos.

	* A more general interface for PKCS#1 signatures, taking the
          input in the form of a "DigestInfo". Suggested by Nikos
          Mavrogiannopoulos.

	Configuration:
	
	* Building of shared libraries (./configure --enable-shared)
          is now enabled by default.

	* Various portability fixes for MacOS and M$ Windows. A lot of
	  this work done by Martin Storsjö.

	* In particular, Nettle now hopefully works on 64-bit Windows
	  builds, "W64", including the x86_64 assembly code.

	Miscellaneous:
	
	* Documentation and example programs for the base16 and base64
	  functions. Was contributed by Jeronimo Pellegrini back in
	  2006, but unfortunately forgotten until now.

	* Use an additional table to avoid GF2^8 multiplications in
	  aes_invert_key (mainly used by aes_set_decrypt_key). Also
	  tabulate round constants in aes_set_encrypt_key.

	* The nettle repository has been migrated from cvs to git,
	  with a public repository at
	  http://git.lysator.liu.se/nettle. To make it independent of
	  the LSH repository, a few files have been moved around.
	  While at it, files have also been converted from latin-1 to
	  utf-8.

	The libraries are intended to be binary compatible with
	nettle-2.2 and later. The shared library names are
	libnettle.so.4.4 and libhogweed.so.2.2, with sonames still
	libnettle.so.4 and libhogweed.so.2

Available at

  http://www.lysator.liu.se/~nisse/archive/nettle-2.5.tar.gz
  ftp://ftp.gnu.org/gnu/nettle/nettle-2.5.tar.gz

and soon also at

  ftp://ftp.lysator.liu.se/pub/security/lsh/nettle-2.5.tar.gz

Happy hacking,
/Niels Möller

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120707204444</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-07-07 20:44:44-0400</timestampReceived><subject>Re: Patch: Fix building of nettle-benchmark on uclibc systems</subject><body>

"Anthony G. Basile" &lt;basile@opensource.dyc.edu&gt; writes:

&gt; Attached is a patch to fix the building of examples/nettle-benchmark
&gt; on uclibc systems while not introducing a regression on glibc.

If the use of ldexp is the only reason libm is needed, maybe it's better
to rewrite bench_sha1_compress (or the GET_CYCLE_COUNTER macro)?

For now, I'm adding -lm to BENCH_LIBS.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120620200721</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-06-20 20:07:21-0400</timestampReceived><subject>Re: Interface for new rsa features</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;&gt; I see that there's some inconsistency of
&gt;&gt; using "nettle_random_func random" vs "nettle_random_func *random", the
&gt;&gt; latter variant is the preferred form.

&gt; If this is because of me, feel free to correct it. It must have been a typo.

I don't think you introduced that. I changed the typedef from

typedef void (*nettle_random_func)(void *ctx,
				unsigned length, uint8_t *dst);

to

typedef void nettle_random_func(void *ctx,
				unsigned length, uint8_t *dst);

some versions ago (and similarly for other typedefs for function type).
And I tried to update all uses at the time, but I'm afraid I didn't get
them all (rsa_encrypt, rsa_generate_keypair). And then we got it wrong
for the recent rsa_decrypt_tr. So I'll fix them as I find them.
Technically, that may be an API change, but I think it's very unlikely
to cause any problems.

&gt;&gt; 3. Should I rename it to _pkcs1_signature_prefix, in order to (i) make
&gt;&gt;    it more clear it's an internal function, and (ii) make applications
&gt;&gt;    depending on the old behaviour break in a more predictable fashion?
&gt;
&gt; I'd say this is a good option. If you care about backwards compatibility
&gt; then the old function could also be present.

The possibility of keeping the old one hadn't occured to me, but that's
a good suggestion. It's easy to do, and nice to users. Maybe I should
also read up on how to tell gcc that it is considered both internal and
obsolete.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120521212600</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-05-21 21:26:00-0400</timestampReceived><subject>Re: Configure problem on OS-X</subject><body>

William Morris &lt;wrm@hushmail.com&gt; writes:

&gt; I obtained the latest nettle using git. 
&gt; Running 'configure' on OS-X (10.7.4) fails.
&gt;
&gt; 	config.status: error: cannot find input file: config.h.in
&gt;
&gt; Any ideas?

config.h.in is generated from configure.ac. You need to run the
.bootstrap script after you check out the sources from git. Currently,
that script just runs autoconf and autoheader, and it's the latter
program which generates config.h.in.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120523083705</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-05-23 08:37:05-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

Dagobert Michelsen &lt;dam@opencsw.org&gt; writes:

&gt; Sorry for the delay, I got distracted. I just tested the latest stdint.in.h from gnulib
&gt; master and gnutls 3.0.19 passes this stage now.

Thanks.

&gt; However, I didn't change anything on the nettle includes and now get
&gt; lots of warnings.

Are these warnings harmless? If so, I think this is good enough.

&gt; Probably the gl_* definitions should not belong to the installed
&gt; nettle headers?

They don't, they're defined in gnulib, and appear in the nettle-stdint.h
warnings because of gnulib's preprocessor macros.

In gnutls/gl/stdint.h:

  typedef signed char gl_int_fast8_t;
  ...
  #define int_fast8_t gl_int_fast8_t;

In nettle-stdint.h (included later in the compilation unit):

  typedef int8_t int_fast8_t;

&gt;   CC     pkcs12_bag.lo
&gt; "/opt/csw/include/nettle/nettle-stdint.h", line 237: warning: typedef redeclared: gl_int_fast8_t
&gt; "/opt/csw/include/nettle/nettle-stdint.h", line 238: warning: typedef redeclared: gl_int_fast16_t
&gt; "/opt/csw/include/nettle/nettle-stdint.h", line 239: warning: typedef redeclared: gl_int_fast32_t
&gt; "/opt/csw/include/nettle/nettle-stdint.h", line 241: warning: typedef redeclared: int64_t
&gt; "/opt/csw/include/nettle/nettle-stdint.h", line 244: warning: typedef redeclared: gl_uint_fast8_t
&gt; "/opt/csw/include/nettle/nettle-stdint.h", line 245: warning: typedef redeclared: gl_uint_fast16_t
&gt; "/opt/csw/include/nettle/nettle-stdint.h", line 246: warning: typedef redeclared: gl_uint_fast32_t
&gt; "/opt/csw/include/nettle/nettle-stdint.h", line 248: warning: typedef redeclared: uint64_t

I don't understand why you get "uint64_t" rather than "gl_uint64_t", it
seems gnulib handles this type (and int64_t) differently from the rest.
But if it works now, despite these warnings, I think we can consider
this problem solved. Do you agree?

(And then I also have the fix in nettle to avoid defining the
*int_fast*_t types at all, which you have tested previously and which
also solved the problem, right?)

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120401184201</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-04-01 18:42:01-0400</timestampReceived><subject>comparison between crypto libraries</subject><body>

Hello,
 Actually this comparison is pretty old, but was unknown to me until
today. It compares the various cryptographic libraries on cipher
performance.
https://idlebox.net/2008/0714-cryptography-speedtest-comparison/

Since then many things might have changed, but I also noticed the AES
performance difference on a 32-bit processor. However, in RSA and DH
nettle/gmp seem to offer much better performance than openssl [0].

regards,
Nikos

[0].
http://nikmav.blogspot.com/2012/04/in-some-embedded-systems-space-may.html
https://bitbucket.org/yarosla/nxweb/wiki/Benchmarks

</body></email><email><emailId>20120414131953</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-04-14 13:19:53-0400</timestampReceived><subject>Re: rsa blinding patch</subject><body>

On 04/14/2012 09:28 AM, Niels Möller wrote:

&gt;&gt; /* RSA signatures, using PKCS#1 1.5
&gt;&gt;  * Input should be a BER encoded DigestInfo
&gt;&gt;  */
&gt;&gt; int
&gt;&gt; rsa_digest_info_sign(const struct rsa_private_key *key,
&gt;&gt;         unsigned length, const uint8_t *digest_info,
&gt;&gt;         mpz_t signature);
&gt;&gt;
&gt;&gt; int
&gt;&gt; rsa_digest_info_verify(const struct rsa_public_key *key,
&gt;&gt;            unsigned length, const uint8_t *digest_info,
&gt;&gt;            const mpz_t signature);
&gt; That seems reasonable (if and how the implementation of nettle's other
&gt; rsa sign/verify functions could be reorganized to make use of that, I'm
&gt; not sure).
&gt; Minor points: It should really be DER encoded, right? 


PKCS #1 1.5 says BER and there were quite some implementations that used
BER for encoding instead of DER.

&gt; And I guess you'd also want a _sign_tr variant. 


Indeed. I only listed the basic interface for review.

&gt; As for naming, maybe I'd want to have

&gt; "pkcs1" int he name, not sure.


I wanted to use PKCS1 but it might be misleading as PKCS #1 1.5 has
a different padding method than PKCS #1 2.1 which uses OAEP. I don't
know if rsa_pkcs1_1_5_sign is reasonable...

&gt; A question for all of you: Nettle currently has two flavors of sign
&gt; functions for each algorithm. E.g.,
&gt;   int
&gt;   rsa_sha1_sign(const struct rsa_private_key *key,
&gt;                 struct sha1_ctx *hash,
&gt;                 mpz_t signature);
&gt;   
&gt;   int
&gt;   rsa_sha1_sign_digest(const struct rsa_private_key *key,
&gt; 		       const uint8_t *digest,
&gt;                        mpz_t s);
&gt; The former could be implemented in terms of the latter (currently it's
&gt; not, to avoid an unnecessary copy, which may be a pointless
&gt; optimization in this context).

&gt; The point of the first function is convenience, where you can create a

&gt; signature simply by
&gt; 
&gt;   sha1_init
&gt;   sha1_update
&gt;   rsa_sha1_sign
&gt; without bothering with allocating and writing the actual digest.
&gt; Do you think this design makes sense?


IMO it makes sense, but I think the drawbacks, which are maintaining one
extra function per hash, do not really outweigh the benefit which
is not really noticeable in the RSA operation.

regards,
Nikos

</body></email><email><emailId>20120426081006</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-04-26 08:10:06-0400</timestampReceived><subject>Re: AES assembler not compatible with Windows x64</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; This should already be fixed in the latest git version (and latest cvs
&gt; version prior to the conversion), and in the 2.5-prerelease at
&gt; http://www.lysator.liu.se/~nisse/archive/nettle-2.5-pre.tar.gz.

Guess I should make a 2.5 release soon. I had planned to get xenofarm up
and running for the new repository before release, but that has turned
out to be harder than I expected. So maybe the release shouldn't have to
wait for that.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120426185455</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-04-26 18:54:55-0400</timestampReceived><subject>Re: Salsa20</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; I don't know of any reason today, e.g., no important Internet
&gt; applications uses it.  It has some interesting properties though, so
&gt; maybe there is uptake.

It seems the main selling point is speed. Internally, it seems a bit
unorthodox,

* hash function in counter mode (when everybody seems to move to block
  ciphers in counter mode, the invertibility of the underlying block
  cipher is an irrelevant feature).

* No sboxes or other "large" non-linearities. Just mix of xor and mod
  2^32 add, and ten rotations to speed up diffusion. Everybody else
  seems to think non-linear sboxes (or things like the majority function
  in sha hashes) are essential. Possibly with the exception of idea?
  Which uses similar primitives, iirc, but with mod (2^16 + 1)
  multiplies instead of simple rotations to help the bit diffusion.

&gt; Somewhat, although I think the distinction between stream ciphers and
&gt; block ciphers is not a good one to make in an API.  Usually applications
&gt; want to use ciphers in some mode, and some modes used with block ciphers
&gt; make them essentially stream ciphers.  I think an good API should be
&gt; modeled around "symmetric encryption" as the concept.

Such an API would make some sense, but I don't think it's a substitute
for a block cipher API. E.g., in ssh, the application has to be aware of
the block size, and the message padding is application specific (isn't
it the same in tls?). An API for encrypting a stream would not be of
much help here. And when using cbc, I think it's not even possible.

&gt;&gt; Including the arcfour stream cipher there may well be a mistake. One
&gt;&gt; annoying problem with the current design is that for block ciphers, the
&gt;&gt; ctx argument of the encrypt and decrypt functions naturally is const,
&gt;&gt; but due arcfour being fittted in the same nettle_cipher abstraction, the
&gt;&gt; function typedef nettle_crypt_func can't use a const ctx.
&gt;
&gt; I always found rc4 the odd cipher in nettle.

That the nettle_cipher abstraction treats the stream ciphers (arcfour
being the only supported one) as a block cipher with block size zero
goes back to my and Henrik Grubbström's design for Pike's crypto
library, some 15 years ago...

Is that what you're finding odd, or is there anything else which is
strange with arcfour?

&gt;&gt; Then there's also the tentative (nettle-internal.h) nettle_aead
&gt;&gt; abstraction. Salsa20 could perhaps fit there, if we allow algorithms
&gt;&gt; with no authentication (NULL digest function pointer).
&gt;
&gt; Possibly...  or just have one abstract "symmetric encryption" that
&gt; embodies all these variants.  Or does that lead to other disadvantages?

In general, it's not much point to have a general interface, if the
application has to query particulars before using it (e.g, does this
mechanism provide any authentication, or do I need to combine it with
some other MAC?). So I don't think what I sketched is a good idea. 

&gt;&gt;&gt; --- /dev/null
&gt;&gt;&gt; +++ b/salsa20.c
&gt;&gt;&gt; +#define ROTL32(x,n) ((((x))&lt;&lt;(n)) | (((x))&gt;&gt;(32-(n))))
&gt;&gt;
&gt;&gt; There are several different variants of that macro. It would be nice
&gt;&gt; with a unified one in macros.h.
&gt;
&gt; I agree.

Done.

&gt;&gt;&gt; +#define SWAP32(v)				\
&gt;&gt;&gt; +  ((ROTL32(v,  8) &amp; 0x00FF00FFUL) |		\
&gt;&gt;&gt; +   (ROTL32(v, 24) &amp; 0xFF00FF00UL))

[...]

&gt;&gt; That's a clever byte swapping trick (at least if a true rot instruction
&gt;&gt; is available). In Nettle conversion between bytes and integers are
&gt;&gt; usually done with READ_UINT32, LE_READ_UINT32 and friends. It's usually
&gt;&gt; not very performance critical, and it deals naturally with any
&gt;&gt; alignment. I suspect U8TO32_LITTLE above breaks if the input is
&gt;&gt; unaligned but the architecture doesn't allow unaligned word reads.
&gt;
&gt; Using READ_UINT32 etc is probably better.

I ended up keeping that kind of byte swapping, to be able to stick to
word accesses to memory until the final plaintext/cryptotext xor.

&gt; I put the majority of my changes above that header, to make it easy to
&gt; sync and compare the code

I'm afraid that not easy any more... I made quite a lot of changes.

&gt;&gt; * Try an sse2 assembly implementation (the djb:s papers outline how to
&gt;&gt;   do that). Or copy some existing implementation.
&gt;
&gt; Take a look at the link above, most likely there exists something.  I'm
&gt; not sure how important it is though.

I had a look, but I found that assembly code hard to read (apparantly
automatically generated by some tool of djb's).

&gt;&gt; * One advertised feature of the cipher is random access. I think we
&gt;&gt;   should have something like a salsa20_set_pos, taking a block count as
&gt;&gt;   argument.
&gt;
&gt; Yes.

Suggestions for name?

I think set_iv should still set the count to zero, so you need to use
the new function only if you want to do seeeks in the data.

&gt;&gt; Do any of you know of any protocols which specify use of salsa20? Is it
&gt;&gt; usually combined with some *fast* MAC algorithm?
&gt;
&gt; I suspect people who like Salsa are inclined to also like CubeHash,
&gt; which could be used in HMAC variants.  CubeHash is fast with optimistic
&gt; parameters, but the "default" is pretty conservative making it not so
&gt; fast.

Maybe it's possible to do something in the style of ofb, to get
authentication cheaply as a side effect (haven't looked very closely at
ofb, though, and ofb itself seems to be unusable in Nettle due to
patents). Maybe I should mail djb and ask.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120703191501</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-07-03 19:15:01-0400</timestampReceived><subject>Getting a bit closer to release</subject><body>

I've done some documentatiion for Salsa20, so we're getting closer to
release. See http://www.lysator.liu.se/~nisse/nettle/plan.html.

NEWS-file review and some more testing remains on the list.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120707193950</emailId><senderName>"Anthony G. Basile"</senderName><senderEmail>basile@opensource.dyc.edu</senderEmail><timestampReceived>2012-07-07 19:39:50-0400</timestampReceived><subject>Patch: Fix building of nettle-benchmark on uclibc systems</subject><body>

Attached is a patch to fix the building of examples/nettle-benchmark on 
uclibc systems while not introducing a regression on glibc.

The downstream bug is https://bugs.gentoo.org/show_bug.cgi?id=415193

-- 
Anthony G. Basile, Ph. D.
Chair of Information Technology
D'Youville College
Buffalo, NY 14201
(716) 829-8197

["fix-link-nettle-benchmark-uclibc.patch" (text/x-patch)]

Fix building of nettle-benchmark on uclibc systems

nettle-benchmark makes a call to ldexp but the build system
doesn't add linking to libm.  On a uclibc system, this causes
the build to fail.

This patch addresses the issue while not affecting glibc systems.

Signed-off-by: Anthony G. Basile &lt;blueness@gentoo.org&gt;

diff -Naur a/examples/Makefile.in b/examples/Makefile.in
--- a/examples/Makefile.in	2012-07-07 13:27:55.000000000 +0000
+++ b/examples/Makefile.in	2012-07-07 18:19:58.825910243 +0000
@@ -94,7 +94,7 @@
 BENCH_OBJS = nettle-benchmark.$(OBJEXT) nettle-openssl.$(OBJEXT) \
 	$(GETOPT_OBJS) ../nettle-internal.$(OBJEXT)
 nettle-benchmark$(EXEEXT): $(BENCH_OBJS)
-	$(LINK) $(BENCH_OBJS) -lnettle $(BENCH_LIBS) $(OPENSSL_LIBFLAGS) -o nettle-benchmark$(EXEEXT)
+	$(LINK) $(BENCH_OBJS) -lnettle -lm $(BENCH_LIBS) $(OPENSSL_LIBFLAGS) -o nettle-benchmark$(EXEEXT)
 
 $(TARGETS) : io.$(OBJEXT) ../libnettle.a
 


</body></email><email><emailId>20120703193457</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2012-07-03 19:34:57-0400</timestampReceived><subject>Re: Getting a bit closer to release</subject><body>


On Tue, 3 Jul 2012, Niels Möller wrote:

&gt; I've done some documentatiion for Salsa20, so we're getting closer to
&gt; release. See http://www.lysator.liu.se/~nisse/nettle/plan.html.
&gt;
&gt; NEWS-file review and some more testing remains on the list.

Re testing, I tried doing a build on 64 bit OS X, which fails at:

salsa20-crypt.s:364:suffix or operands invalid for `movq'
salsa20-crypt.s:370:suffix or operands invalid for `movq'

With --disable-assembler it builds fine though.


// Martin

</body></email><email><emailId>20120703204029</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-07-03 20:40:29-0400</timestampReceived><subject>Re: Getting a bit closer to release</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; Re testing, I tried doing a build on 64 bit OS X, which fails at:
&gt;
&gt; salsa20-crypt.s:364:suffix or operands invalid for `movq'
&gt; salsa20-crypt.s:370:suffix or operands invalid for `movq'

That sounds vaguely familiar. I think it has been reported earlier, but
not fixed.

This instruction, "movq %xmm4, %r8" is used to copy the low 64 bits from
an %xmm register to a regular 64-bit register. Any idea on how to write
that in a way which makes the osx assembler happy? I'm not aware of any
other instruction for doing that type of copy, but any reasonable
workaround is appreciated.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120704111755</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2012-07-04 11:17:55-0400</timestampReceived><subject>Re: Getting a bit closer to release</subject><body>


On Tue, 3 Jul 2012, Niels Möller wrote:

&gt; Martin Storsjö &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt; Re testing, I tried doing a build on 64 bit OS X, which fails at:
&gt;&gt;
&gt;&gt; salsa20-crypt.s:364:suffix or operands invalid for `movq'
&gt;&gt; salsa20-crypt.s:370:suffix or operands invalid for `movq'
&gt;
&gt; That sounds vaguely familiar. I think it has been reported earlier, but
&gt; not fixed.
&gt;
&gt; This instruction, "movq %xmm4, %r8" is used to copy the low 64 bits from
&gt; an %xmm register to a regular 64-bit register. Any idea on how to write
&gt; that in a way which makes the osx assembler happy? I'm not aware of any
&gt; other instruction for doing that type of copy, but any reasonable
&gt; workaround is appreciated.

If I change it into movd instead of movq, it builds fine on OS X, and the 
tests pass.

On Linux, it doesn't seem to break anything either. And if checking the 
output with objdump -d, it is encoded into the same opcode (which objdump 
reports as movq).

// Martin

</body></email><email><emailId>20120704202731</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-07-04 20:27:31-0400</timestampReceived><subject>Re: Getting a bit closer to release</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; If I change it into movd instead of movq, it builds fine on OS X, and
&gt; the tests pass.

Curious. That use of movd is not in accord with my intel manuals, as far
as I understand them.

&gt; On Linux, it doesn't seem to break anything either. And if checking
&gt; the output with objdump -d, it is encoded into the same opcode (which
&gt; objdump reports as movq).

I think I'll double check that, and then check in that change.

Thanks for the help!

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120426004917</emailId><senderName>Mann Ern Kang</senderName><senderEmail>mann.ern.kang@gmail.com</senderEmail><timestampReceived>2012-04-26 00:49:17-0400</timestampReceived><subject>AES assembler not compatible with Windows x64</subject><body>

Hi all,

An issue arose while testing gnutls, which has a dependency on nettle, on
Windows x64. The x86_64 aes assembler code in nettle is not compatible with
the Windows calling convention, leading to crashes.

The related gnutls item is here: https://savannah.gnu.org/support/?108038

This can be worked around for now with --disable-assembler during
./configure. Going forward, will there be any plans to support assembler
for x64 Windows?

Cheers,
Mann Ern

</body></email><email><emailId>20120322075714</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-03-22 07:57:14-0400</timestampReceived><subject>Salsa20</subject><body>

Hi!  Please find attached a port of DJB's public domain code for Salsa20
to nettle.  The patch is not meant to be applied as-is but to start a
discussion.  Review of the code itself is welcome.

While writing this I noticed a sub-optimal design of Nettle, in that it
overloads the meaning of struct nettle_cipher-&gt;block_size as a flag of
whether the cipher is a stream cipher or not.  Before arcfour was the
only stream cipher in nettle, and using block_size=0 to signal that it
is a stream cipher worked fine.  However, Salsa20 has a block size of 8
bytes.  Another odd thing is that Salsa20 requires an IV.  So some
changes to the nettle_cipher struct are required.

This could be resolved better than I have done in the patch below.  I
see two reasonable alternatives:

1) Introduce a new struct 'struct nettle_stream_cipher' that applies to
stream ciphers and use that.

2) Add a flag in 'struct nettle_cipher' to tell whether the cipher is a
stream cipher or not.

I started out strongly prefering 1) because it appeared cleaner.  After
thinking about the changes required to implement that, I am now leaning
towards 2) because of:

A) a lot of code would have to be duplicated if we have both 'struct
nettle_cipher' and 'struct nettle_stream_cipher' for apparently little
gain.  Otherwise, most code could be the same, and where the distinction
matters there could be a simple if-test.

B) it allows for full backwards compatibility in a clean way.  With 1)
we would have a transition period where people switch arcfour usage from
nettle_cipher to nettle_stream_cipher.  With 2) arcfour would continue
to have block_size==0 but it would also set the new stream cipher flag.
External code could incrementally be updated to check the new flag
instead of block_size==0 (if it does that at all) but that is something
that doesn't uglify nettle.

What do you think?  I'd be happy to propose a patch to implement 2) and
then a follow-on patch to add support for Salsa20.

/Simon

&gt; From 600ae2815634ad95c4d2d93821316ce20df19ae3 Mon Sep 17 00:00:00 2001
From: Simon Josefsson &lt;simon@josefsson.org&gt;
Date: Wed, 21 Mar 2012 17:06:13 +0100
Subject: [PATCH] Implement Salsa20.

---
 Makefile.in                  |    3 +-
 examples/nettle-benchmark.c  |    3 +
 nettle-meta-ciphers.c        |    2 +
 nettle-meta.h                |    8 ++-
 nettle-types.h               |    5 +
 salsa20-meta.c               |   49 ++++++++++++
 salsa20.c                    |  172 ++++++++++++++++++++++++++++++++++++++++++
 salsa20.h                    |   71 +++++++++++++++++
 testsuite/.gitignore         |    1 +
 testsuite/.test-rules.make   |    3 +
 testsuite/Makefile.in        |    1 +
 testsuite/meta-cipher-test.c |    2 +
 testsuite/salsa20-test.c     |   49 ++++++++++++
 testsuite/testutils.c        |   36 +++++++--
 testsuite/testutils.h        |   10 +++
 15 files changed, 407 insertions(+), 8 deletions(-)
 create mode 100644 salsa20-meta.c
 create mode 100644 salsa20.c
 create mode 100644 salsa20.h
 create mode 100644 testsuite/salsa20-test.c

diff --git a/Makefile.in b/Makefile.in
index 1813a0d..6e2ec60 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -79,6 +79,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
+		 salsa20.c salsa20-meta.c \
 		 sha1.c sha1-compress.c sha1-meta.c \
 		 sha256.c sha256-compress.c sha224-meta.c sha256-meta.c \
 		 sha512.c sha512-compress.c sha384-meta.c sha512-meta.c \
@@ -113,7 +114,7 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  pgp-encode.c rsa2openpgp.c \
 		  der-iterator.c der2rsa.c der2dsa.c
 
-HEADERS = aes.h arcfour.h arctwo.h asn1.h bignum.h blowfish.h \
+HEADERS = aes.h arcfour.h salsa20.h arctwo.h asn1.h bignum.h blowfish.h \
 	  base16.h base64.h buffer.h camellia.h cast128.h \
 	  cbc.h ctr.h gcm.h \
 	  des.h des-compat.h dsa.h \
diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index 424ef19..44fca4e 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -40,6 +40,7 @@
 
 #include "aes.h"
 #include "arcfour.h"
+#include "salsa20.h"
 #include "blowfish.h"
 #include "cast128.h"
 #include "cbc.h"
@@ -612,6 +613,8 @@ main(int argc, char **argv)
       OPENSSL(&amp;nettle_openssl_aes192)
       OPENSSL(&amp;nettle_openssl_aes256)
       &amp;nettle_arcfour128, OPENSSL(&amp;nettle_openssl_arcfour128)
+      &amp;nettle_salsa20_128,
+      &amp;nettle_salsa20_256,
       &amp;nettle_blowfish128, OPENSSL(&amp;nettle_openssl_blowfish128)
       &amp;nettle_camellia128, &amp;nettle_camellia192, &amp;nettle_camellia256,
       &amp;nettle_cast128, OPENSSL(&amp;nettle_openssl_cast128)
diff --git a/nettle-meta-ciphers.c b/nettle-meta-ciphers.c
index 1f07595..aae90f9 100644
--- a/nettle-meta-ciphers.c
+++ b/nettle-meta-ciphers.c
@@ -36,6 +36,8 @@ const struct nettle_cipher * const nettle_ciphers[] = {
   &amp;nettle_camellia192,
   &amp;nettle_camellia256,
   &amp;nettle_cast128,
+  &amp;nettle_salsa20_128,
+  &amp;nettle_salsa20_256,
   &amp;nettle_serpent128,
   &amp;nettle_serpent192,
   &amp;nettle_serpent256,
diff --git a/nettle-meta.h b/nettle-meta.h
index 54cbbd2..c8aabda 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -5,6 +5,7 @@
 
 /* nettle, low-level cryptographics library
  *
+ * Copyright (C) 2012 Simon Josefsson
  * Copyright (C) 2002 Niels Möller
  *  
  * The nettle library is free software; you can redistribute it and/or modify
@@ -39,7 +40,7 @@ struct nettle_cipher
   
   unsigned context_size;
   
-  /* Zero for stream ciphers */
+  /* Block size; 0 for byte-oriented stream ciphers. */
   unsigned block_size;
 
   /* Suggested key size; other sizes are sometimes possible. */
@@ -50,6 +51,8 @@ struct nettle_cipher
 
   nettle_crypt_func *encrypt;
   nettle_crypt_func *decrypt;
+
+  nettle_set_iv_func *set_iv;
 };
 
 #define _NETTLE_CIPHER(name, NAME, key_size) {	\
@@ -105,6 +108,9 @@ extern const struct nettle_cipher nettle_aes256;
 
 extern const struct nettle_cipher nettle_arcfour128;
 
+extern const struct nettle_cipher nettle_salsa20_128;
+extern const struct nettle_cipher nettle_salsa20_256;
+
 extern const struct nettle_cipher nettle_camellia128;
 extern const struct nettle_cipher nettle_camellia192;
 extern const struct nettle_cipher nettle_camellia256;
diff --git a/nettle-types.h b/nettle-types.h
index b694332..e68cacb 100644
--- a/nettle-types.h
+++ b/nettle-types.h
@@ -2,6 +2,7 @@
 
 /* nettle, low-level cryptographics library
  *
+ * Copyright (C) 2012 Simon Josefsson
  * Copyright (C) 2005 Niels Möller
  *  
  * The nettle library is free software; you can redistribute it and/or modify
@@ -44,6 +45,10 @@ typedef void nettle_set_key_func(void *ctx,
 				 unsigned length,
 				 const uint8_t *key);
 
+typedef void nettle_set_iv_func(void *ctx,
+				unsigned length,
+				const uint8_t *iv);
+
 /* Uses a void * for cipher contexts.
 
    For block ciphers it would make sense with a const void * for the
diff --git a/salsa20-meta.c b/salsa20-meta.c
new file mode 100644
index 0000000..8278e09
--- /dev/null
+++ b/salsa20-meta.c
@@ -0,0 +1,49 @@
+/* salsa20-meta.c */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "salsa20.h"
+
+const struct nettle_cipher nettle_salsa20_128 =
+  { "salsa20-128", sizeof(struct salsa20_ctx),
+    8, 16,
+    (nettle_set_key_func *) salsa20_set_key,
+    (nettle_set_key_func *) salsa20_set_key,
+    (nettle_crypt_func *) salsa20_crypt,
+    (nettle_crypt_func *) salsa20_crypt,
+    (nettle_set_iv_func *) salsa20_set_iv
+  };
+
+const struct nettle_cipher nettle_salsa20_256 =
+  { "salsa20-256", sizeof(struct salsa20_ctx),
+    8, 32,
+    (nettle_set_key_func *) salsa20_set_key,
+    (nettle_set_key_func *) salsa20_set_key,
+    (nettle_crypt_func *) salsa20_crypt,
+    (nettle_crypt_func *) salsa20_crypt,
+    (nettle_set_iv_func *) salsa20_set_iv
+  };
diff --git a/salsa20.c b/salsa20.c
new file mode 100644
index 0000000..7885199
--- /dev/null
+++ b/salsa20.c
@@ -0,0 +1,172 @@
+/* salsa20.c
+ *
+ * The Salsa20 stream cipher.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "salsa20.h"
+
+#define ROTL32(x,n) ((((x))&lt;&lt;(n)) | (((x))&gt;&gt;(32-(n))))
+
+#define SWAP32(v)				\
+  ((ROTL32(v,  8) &amp; 0x00FF00FFUL) |		\
+   (ROTL32(v, 24) &amp; 0xFF00FF00UL))
+
+#ifdef WORDS_BIGENDIAN
+#define U32TO32_LITTLE(v) SWAP32(v)
+#else
+#define U32TO32_LITTLE(v) (v)
+#endif
+
+#define U8TO32_LITTLE(p) U32TO32_LITTLE(((uint32_t*)(p))[0])
+#define U32TO8_LITTLE(p, v) (((uint32_t*)(p))[0] = U32TO32_LITTLE(v))
+
+/*
+salsa20-ref.c version 20051118
+D. J. Bernstein
+Public domain.
+*/
+
+#define ROTATE(v,c) (ROTL32(v,c))
+#define XOR(v,w) ((v) ^ (w))
+#define PLUS(v,w) ((v) + (w))
+#define PLUSONE(v) (PLUS((v),1))
+
+static void salsa20_wordtobyte(uint8_t output[64],const uint32_t input[16])
+{
+  uint32_t x[16];
+  int i;
+
+  for (i = 0;i &lt; 16;++i) x[i] = input[i];
+  for (i = 20;i &gt; 0;i -= 2) {
+    x[ 4] = XOR(x[ 4],ROTATE(PLUS(x[ 0],x[12]), 7));
+    x[ 8] = XOR(x[ 8],ROTATE(PLUS(x[ 4],x[ 0]), 9));
+    x[12] = XOR(x[12],ROTATE(PLUS(x[ 8],x[ 4]),13));
+    x[ 0] = XOR(x[ 0],ROTATE(PLUS(x[12],x[ 8]),18));
+    x[ 9] = XOR(x[ 9],ROTATE(PLUS(x[ 5],x[ 1]), 7));
+    x[13] = XOR(x[13],ROTATE(PLUS(x[ 9],x[ 5]), 9));
+    x[ 1] = XOR(x[ 1],ROTATE(PLUS(x[13],x[ 9]),13));
+    x[ 5] = XOR(x[ 5],ROTATE(PLUS(x[ 1],x[13]),18));
+    x[14] = XOR(x[14],ROTATE(PLUS(x[10],x[ 6]), 7));
+    x[ 2] = XOR(x[ 2],ROTATE(PLUS(x[14],x[10]), 9));
+    x[ 6] = XOR(x[ 6],ROTATE(PLUS(x[ 2],x[14]),13));
+    x[10] = XOR(x[10],ROTATE(PLUS(x[ 6],x[ 2]),18));
+    x[ 3] = XOR(x[ 3],ROTATE(PLUS(x[15],x[11]), 7));
+    x[ 7] = XOR(x[ 7],ROTATE(PLUS(x[ 3],x[15]), 9));
+    x[11] = XOR(x[11],ROTATE(PLUS(x[ 7],x[ 3]),13));
+    x[15] = XOR(x[15],ROTATE(PLUS(x[11],x[ 7]),18));
+    x[ 1] = XOR(x[ 1],ROTATE(PLUS(x[ 0],x[ 3]), 7));
+    x[ 2] = XOR(x[ 2],ROTATE(PLUS(x[ 1],x[ 0]), 9));
+    x[ 3] = XOR(x[ 3],ROTATE(PLUS(x[ 2],x[ 1]),13));
+    x[ 0] = XOR(x[ 0],ROTATE(PLUS(x[ 3],x[ 2]),18));
+    x[ 6] = XOR(x[ 6],ROTATE(PLUS(x[ 5],x[ 4]), 7));
+    x[ 7] = XOR(x[ 7],ROTATE(PLUS(x[ 6],x[ 5]), 9));
+    x[ 4] = XOR(x[ 4],ROTATE(PLUS(x[ 7],x[ 6]),13));
+    x[ 5] = XOR(x[ 5],ROTATE(PLUS(x[ 4],x[ 7]),18));
+    x[11] = XOR(x[11],ROTATE(PLUS(x[10],x[ 9]), 7));
+    x[ 8] = XOR(x[ 8],ROTATE(PLUS(x[11],x[10]), 9));
+    x[ 9] = XOR(x[ 9],ROTATE(PLUS(x[ 8],x[11]),13));
+    x[10] = XOR(x[10],ROTATE(PLUS(x[ 9],x[ 8]),18));
+    x[12] = XOR(x[12],ROTATE(PLUS(x[15],x[14]), 7));
+    x[13] = XOR(x[13],ROTATE(PLUS(x[12],x[15]), 9));
+    x[14] = XOR(x[14],ROTATE(PLUS(x[13],x[12]),13));
+    x[15] = XOR(x[15],ROTATE(PLUS(x[14],x[13]),18));
+  }
+  for (i = 0;i &lt; 16;++i) x[i] = PLUS(x[i],input[i]);
+  for (i = 0;i &lt; 16;++i) U32TO8_LITTLE(output + 4 * i,x[i]);
+}
+
+static const char sigma[16] = "expand 32-byte k";
+static const char tau[16] = "expand 16-byte k";
+
+void
+salsa20_set_key(struct salsa20_ctx *ctx,
+		unsigned length, const uint8_t *key)
+{
+  const char *constants;
+
+  assert (length == SALSA20_MIN_KEY_SIZE || length == SALSA20_MAX_KEY_SIZE);
+
+  ctx-&gt;input[1] = U8TO32_LITTLE(key + 0);
+  ctx-&gt;input[2] = U8TO32_LITTLE(key + 4);
+  ctx-&gt;input[3] = U8TO32_LITTLE(key + 8);
+  ctx-&gt;input[4] = U8TO32_LITTLE(key + 12);
+  if (length == SALSA20_MAX_KEY_SIZE) { /* recommended */
+    key += 16;
+    constants = sigma;
+  } else { /* kbits == 128 */
+    constants = tau;
+  }
+  ctx-&gt;input[11] = U8TO32_LITTLE(key + 0);
+  ctx-&gt;input[12] = U8TO32_LITTLE(key + 4);
+  ctx-&gt;input[13] = U8TO32_LITTLE(key + 8);
+  ctx-&gt;input[14] = U8TO32_LITTLE(key + 12);
+  ctx-&gt;input[0] = U8TO32_LITTLE(constants + 0);
+  ctx-&gt;input[5] = U8TO32_LITTLE(constants + 4);
+  ctx-&gt;input[10] = U8TO32_LITTLE(constants + 8);
+  ctx-&gt;input[15] = U8TO32_LITTLE(constants + 12);
+}
+
+void
+salsa20_set_iv(struct salsa20_ctx *ctx, unsigned length, const uint8_t *iv)
+{
+  assert (length == SALSA20_IV_SIZE);
+
+  ctx-&gt;input[6] = U8TO32_LITTLE(iv + 0);
+  ctx-&gt;input[7] = U8TO32_LITTLE(iv + 4);
+  ctx-&gt;input[8] = 0;
+  ctx-&gt;input[9] = 0;
+}
+
+void
+salsa20_crypt(struct salsa20_ctx *ctx,
+	      unsigned length,
+	      uint8_t *c,
+	      const uint8_t *m)
+{
+  uint8_t output[64];
+  unsigned i;
+
+  if (!length) return;
+  for (;;) {
+    salsa20_wordtobyte(output,ctx-&gt;input);
+    ctx-&gt;input[8] = PLUSONE(ctx-&gt;input[8]);
+    if (!ctx-&gt;input[8]) {
+      ctx-&gt;input[9] = PLUSONE(ctx-&gt;input[9]);
+      /* stopping at 2^70 length per nonce is user's responsibility */
+    }
+    if (length &lt;= 64) {
+      for (i = 0;i &lt; length;++i) c[i] = m[i] ^ output[i];
+      return;
+    }
+    for (i = 0;i &lt; 64;++i) c[i] = m[i] ^ output[i];
+    length -= 64;
+    c += 64;
+    m += 64;
+  }
+}
diff --git a/salsa20.h b/salsa20.h
new file mode 100644
index 0000000..79f1505
--- /dev/null
+++ b/salsa20.h
@@ -0,0 +1,71 @@
+/* salsa20.h
+ *
+ * The Salsa20 stream cipher.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2012 Simon Josefsson
+ * Copyright (C) 2001 Niels Möller
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+ * MA 02111-1307, USA.
+ */
+ 
+#ifndef NETTLE_SALSA20_H_INCLUDED
+#define NETTLE_SALSA20_H_INCLUDED
+
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define salsa20_set_key nettle_salsa20_set_key
+#define salsa20_set_iv nettle_salsa20_set_iv
+#define salsa20_crypt nettle_salsa20_crypt
+
+/* Minimum and maximum keysizes, and a reasonable default. In
+ * octets.*/
+#define SALSA20_MIN_KEY_SIZE 16
+#define SALSA20_MAX_KEY_SIZE 32
+#define SALSA20_KEY_SIZE 32
+
+#define SALSA20_IV_SIZE 8
+
+struct salsa20_ctx
+{
+    uint32_t input[16];
+};
+
+void
+salsa20_set_key(struct salsa20_ctx *ctx,
+		unsigned length, const uint8_t *key);
+
+void
+salsa20_set_iv(struct salsa20_ctx *ctx,
+	       unsigned length, const uint8_t *iv);
+
+void
+salsa20_crypt(struct salsa20_ctx *ctx,
+	      unsigned length, uint8_t *dst,
+	      const uint8_t *src);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_SALSA20_H_INCLUDED */
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index 1147cfb..c9f4698 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -36,6 +36,7 @@
 /rsa-keygen-test
 /rsa-test
 /rsa2sexp-test
+/salsa20-test
 /serpent-test
 /sexp-format-test
 /sexp-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index e8f6650..10c993f 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -49,6 +49,9 @@ memxor-test$(EXEEXT): memxor-test.$(OBJEXT)
 ripemd160-test$(EXEEXT): ripemd160-test.$(OBJEXT)
 	$(LINK) ripemd160-test.$(OBJEXT) $(TEST_OBJS) -o ripemd160-test$(EXEEXT)
 
+salsa20-test$(EXEEXT): salsa20-test.$(OBJEXT)
+	$(LINK) salsa20-test.$(OBJEXT) $(TEST_OBJS) -o salsa20-test$(EXEEXT)
+
 sha1-test$(EXEEXT): sha1-test.$(OBJEXT)
 	$(LINK) sha1-test.$(OBJEXT) $(TEST_OBJS) -o sha1-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 8dfc62b..10ffae9 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -18,6 +18,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    md2-test.c md4-test.c md5-test.c md5-compat-test.c \
 		    memxor-test.c \
 		    ripemd160-test.c \
+		    salsa20-test.c \
 		    sha1-test.c sha224-test.c sha256-test.c \
 		    sha384-test.c sha512-test.c \
 		    serpent-test.c twofish-test.c \
diff --git a/testsuite/meta-cipher-test.c b/testsuite/meta-cipher-test.c
index 1bb74d8..50a02ba 100644
--- a/testsuite/meta-cipher-test.c
+++ b/testsuite/meta-cipher-test.c
@@ -14,6 +14,8 @@ const char* ciphers[] = {
   "camellia192",
   "camellia256",
   "cast128",
+  "salsa20-128",
+  "salsa20-256",
   "serpent128",
   "serpent192",
   "serpent256",
diff --git a/testsuite/salsa20-test.c b/testsuite/salsa20-test.c
new file mode 100644
index 0000000..e1c13dd
--- /dev/null
+++ b/testsuite/salsa20-test.c
@@ -0,0 +1,49 @@
+#include "testutils.h"
+#include "salsa20.h"
+
+int
+test_main(void)
+{
+  /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/full/verified.test-vectors?logsort=rev&amp;rev=210&amp;view=markup \
*/ +
+  test_cipher_iv(&amp;nettle_salsa20_128,
+		 HL("80000000 00000000 00000000 00000000"),
+		 HL("00000000 00000000"),
+		 HL("00000000 00000000"),
+		 H("4DFA5E48 1DA23EA0"));
+
+  test_cipher_iv(&amp;nettle_salsa20_128,
+		 HL("00000000 00000000 00000000 00000000"),
+		 HL("80000000 00000000"),
+		 HL("00000000 00000000"),
+		 H("B66C1E44 46DD9557"));
+
+  test_cipher_iv(&amp;nettle_salsa20_128,
+		 HL("0053A6F94C9FF24598EB3E91E4378ADD"),
+		 HL("0D74DB42A91077DE"),
+		 HL("00000000 00000000"),
+		 H("05E1E7BE B697D999"));
+
+  test_cipher_iv(&amp;nettle_salsa20_256,
+		 HL("80000000 00000000 00000000 00000000"
+		    "00000000 00000000 00000000 00000000"),
+		 HL("00000000 00000000"),
+		 HL("00000000 00000000"),
+		 H("E3BE8FDD 8BECA2E3"));
+
+  test_cipher_iv(&amp;nettle_salsa20_256,
+		 HL("00000000 00000000 00000000 00000000"
+		    "00000000 00000000 00000000 00000000"),
+		 HL("80000000 00000000"),
+		 HL("00000000 00000000"),
+		 H("2ABA3DC45B494700"));
+
+  test_cipher_iv(&amp;nettle_salsa20_256,
+		 HL("0053A6F94C9FF24598EB3E91E4378ADD"
+		    "3083D6297CCF2275C81B6EC11467BA0D"),
+		 HL("0D74DB42A91077DE"),
+		 HL("00000000 00000000"),
+		 H("F5FAD53F 79F9DF58"));
+
+  SUCCESS();
+}
diff --git a/testsuite/testutils.c b/testsuite/testutils.c
index d77bb7e..8f5dab0 100644
--- a/testsuite/testutils.c
+++ b/testsuite/testutils.c
@@ -162,17 +162,21 @@ main(int argc, char **argv)
 }
 
 void
-test_cipher(const struct nettle_cipher *cipher,
-	    unsigned key_length,
-	    const uint8_t *key,
-	    unsigned length,
-	    const uint8_t *cleartext,
-	    const uint8_t *ciphertext)
+test_cipher_iv(const struct nettle_cipher *cipher,
+	       unsigned key_length,
+	       const uint8_t *key,
+	       unsigned iv_length,
+	       const uint8_t *iv,
+	       unsigned length,
+	       const uint8_t *cleartext,
+	       const uint8_t *ciphertext)
 {
   void *ctx = xalloc(cipher-&gt;context_size);
   uint8_t *data = xalloc(length);
 
   cipher-&gt;set_encrypt_key(ctx, key_length, key);
+  if (iv_length &gt; 0 &amp;&amp; iv)
+    cipher-&gt;set_iv(ctx, iv_length, iv);
   cipher-&gt;encrypt(ctx, length, data, cleartext);
 
   if (!MEMEQ(length, data, ciphertext))
@@ -187,6 +191,8 @@ test_cipher(const struct nettle_cipher *cipher,
       FAIL();
     }
   cipher-&gt;set_decrypt_key(ctx, key_length, key);
+  if (iv_length &gt; 0 &amp;&amp; iv)
+    cipher-&gt;set_iv(ctx, iv_length, iv);
   cipher-&gt;decrypt(ctx, length, data, data);
 
   if (!MEMEQ(length, data, cleartext))
@@ -206,6 +212,24 @@ test_cipher(const struct nettle_cipher *cipher,
 }
 
 void
+test_cipher(const struct nettle_cipher *cipher,
+	    unsigned key_length,
+	    const uint8_t *key,
+	    unsigned length,
+	    const uint8_t *cleartext,
+	    const uint8_t *ciphertext)
+{
+  test_cipher_iv(cipher,
+		 key_length,
+		 key,
+		 0,
+		 NULL,
+		 length,
+		 cleartext,
+		 ciphertext);
+}
+
+void
 test_cipher_cbc(const struct nettle_cipher *cipher,
 		unsigned key_length,
 		const uint8_t *key,
diff --git a/testsuite/testutils.h b/testsuite/testutils.h
index d7ced9a..9d13dff 100644
--- a/testsuite/testutils.h
+++ b/testsuite/testutils.h
@@ -91,6 +91,16 @@ test_cipher(const struct nettle_cipher *cipher,
 	    const uint8_t *ciphertext);
 
 void
+test_cipher_iv(const struct nettle_cipher *cipher,
+	       unsigned key_length,
+	       const uint8_t *key,
+	       unsigned iv_length,
+	       const uint8_t *iv,
+	       unsigned length,
+	       const uint8_t *cleartext,
+	       const uint8_t *ciphertext);
+
+void
 test_cipher_cbc(const struct nettle_cipher *cipher,
 		unsigned key_length,
 		const uint8_t *key,
-- 
1.7.2.5


</body></email><email><emailId>20120329103059</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-03-29 10:30:59-0400</timestampReceived><subject>Re: Salsa20</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Hi!  Please find attached a port of DJB's public domain code for Salsa20
&gt; to nettle.  The patch is not meant to be applied as-is but to start a
&gt; discussion.

I'm not familiar with this cipher... Could you explain briefly why one
may want to use it?

&gt; While writing this I noticed a sub-optimal design of Nettle, in that it
&gt; overloads the meaning of struct nettle_cipher-&gt;block_size as a flag of
&gt; whether the cipher is a stream cipher or not.  Before arcfour was the
&gt; only stream cipher in nettle, and using block_size=0 to signal that it
&gt; is a stream cipher worked fine.  However, Salsa20 has a block size of 8
&gt; bytes.

If Salsa20 doesn't fit in the nettle_cipher abstraction, then I think we
should start by implementing Salsa20 *without* trying to get it to fit
there. To me, a "stream cipher" with a block size and iv seems a bit
like a contradiction.

In general, I don't think it makes much sense to include algorithms
which behave very differently under the "nettle_cipher" umbrella, since
the point of that abstraction is to collect algorithms which are easily
exchangable. Code accepting a nettle_cipher are not expected to check
flags or behave fundamentally different for different algorithms.

Including the arcfour stream cipher there may well be a mistake. One
annoying problem with the current design is that for block ciphers, the
ctx argument of the encrypt and decrypt functions naturally is const,
but due arcfour being fittted in the same nettle_cipher abstraction, the
function typedef nettle_crypt_func can't use a const ctx.

Anyway, I'd prefer to treat redesign in that area as an independent
problem from adding support for Salsa20.

Then there's also the tentative (nettle-internal.h) nettle_aead
abstraction. Salsa20 could perhaps fit there, if we allow algorithms
with no authentication (NULL digest function pointer).

&gt; What do you think?  I'd be happy to propose a patch to implement 2) and
&gt; then a follow-on patch to add support for Salsa20.

I'd prefer the opposite order...

Some quick comments on the code and algorithm below. This is the first
I hear about it, so I may well be misunderstanding how it is supposed to
work.

&gt; --- /dev/null
&gt; +++ b/salsa20.c
&gt; +#define ROTL32(x,n) ((((x))&lt;&lt;(n)) | (((x))&gt;&gt;(32-(n))))

There are several different variants of that macro. It would be nice
with a unified one in macros.h.

&gt; +#define SWAP32(v)				\
&gt; +  ((ROTL32(v,  8) &amp; 0x00FF00FFUL) |		\
&gt; +   (ROTL32(v, 24) &amp; 0xFF00FF00UL))
&gt; +
&gt; +#ifdef WORDS_BIGENDIAN
&gt; +#define U32TO32_LITTLE(v) SWAP32(v)
&gt; +#else
&gt; +#define U32TO32_LITTLE(v) (v)
&gt; +#endif
&gt; +
&gt; +#define U8TO32_LITTLE(p) U32TO32_LITTLE(((uint32_t*)(p))[0])
&gt; +#define U32TO8_LITTLE(p, v) (((uint32_t*)(p))[0] = U32TO32_LITTLE(v))

That's a clever byte swapping trick (at least if a true rot instruction
is available). In Nettle conversion between bytes and integers are
usually done with READ_UINT32, LE_READ_UINT32 and friends. It's usually
not very performance critical, and it deals naturally with any
alignment. I suspect U8TO32_LITTLE above breaks if the input is
unaligned but the architecture doesn't allow unaligned word reads.

&gt; +/*
&gt; +salsa20-ref.c version 20051118
&gt; +D. J. Bernstein
&gt; +Public domain.
&gt; +*/

Shouldn't that be moved up closer to the (C) header?

&gt; +#define ROTATE(v,c) (ROTL32(v,c))
&gt; +#define XOR(v,w) ((v) ^ (w))
&gt; +#define PLUS(v,w) ((v) + (w))
&gt; +#define PLUSONE(v) (PLUS((v),1))

I'm not sure these macros improve readability...

&gt; +static void salsa20_wordtobyte(uint8_t output[64],const uint32_t input[16])

Despite the name, this is the main encryption function. Or rather, a
(hopefully) one-way function? "input" is really the context struct,
which contains some mix of the key and the iv?

&gt; +    x[ 4] = XOR(x[ 4],ROTATE(PLUS(x[ 0],x[12]), 7));

And what's wrong with writing that as

  x[ 4] ^= ROTATE(x[ 0] + x[12], 7)

&gt; +void
&gt; +salsa20_set_key(struct salsa20_ctx *ctx,
&gt; +		unsigned length, const uint8_t *key)
&gt; +{

Ok, this initializes the input arrray at indices 0-5, and 10-15.

&gt; +void
&gt; +salsa20_set_iv(struct salsa20_ctx *ctx, unsigned length, const uint8_t *iv)
&gt; +{
&gt; +  assert (length == SALSA20_IV_SIZE);

And this initializes indices 6-9. I'd remove the length argument, if
only one value is allowed anyway.

&gt; +void
&gt; +salsa20_crypt(struct salsa20_ctx *ctx,
&gt; +	      unsigned length,
&gt; +	      uint8_t *c,
&gt; +	      const uint8_t *m)
&gt; +{
&gt; +  uint8_t output[64];
&gt; +  unsigned i;
&gt; +
&gt; +  if (!length) return;
&gt; +  for (;;) {
&gt; +    salsa20_wordtobyte(output,ctx-&gt;input);

That's applying a oneway function to the input,

&gt; +    ctx-&gt;input[8] = PLUSONE(ctx-&gt;input[8]);
&gt; +    if (!ctx-&gt;input[8]) {
&gt; +      ctx-&gt;input[9] = PLUSONE(ctx-&gt;input[9]);
&gt; +      /* stopping at 2^70 length per nonce is user's responsibility */
&gt; +    }

followed by an increment of the iv, where the second half appearantly is
used as a counter.

&gt; +    if (length &lt;= 64) {
&gt; +      for (i = 0;i &lt; length;++i) c[i] = m[i] ^ output[i];
&gt; +      return;
&gt; +    }
&gt; +    for (i = 0;i &lt; 64;++i) c[i] = m[i] ^ output[i];

Followed by xoring the generated key stream to get the ciphertext.

Do I understand it correctly that there's nothing really non-linear
anywhere in this cipher? Only a mix of + and ^ which both are linear,
but over different rings. So the security aginst a known plaintext
attack would rest on the carry propagation, together with the large
state space of 512 bits (448 bits of expanded key material, and 64 bits
counter).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120329142703</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-03-29 14:27:03-0400</timestampReceived><subject>Re: Salsa20</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I'm not familiar with this cipher... Could you explain briefly why one
&gt; may want to use it?

I've done some more homework, reading some of djb's papers and the
wikipedia page. Some questions:

1. Any protocols that specify use of salsa20? And in combination with
   which MAC? With claimed cycle numbers, hmac with sha1 or sha2 is
   going to take much more time than the encryption.

2. What about the later "ChaCha" cipher? As far as I see, it has not
   been studied as much as Salsa20.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120329202036</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-03-29 20:20:36-0400</timestampReceived><subject>Re: Salsa20</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Please find attached a port of DJB's public domain code for Salsa20
&gt; to nettle.  The patch is not meant to be applied as-is but to start a
&gt; discussion.

Nevertheless, I have now commited salsa20.[ch] and the testcase,
postponing remaining work for later. ;-)

Needed:

* Support in nettle-benchmark in some way (can probably get away with a
  stupid nettle_cipher setting the iv to some fixed value).

* A bit of cleanup of the code.

* Try optimization of the C code for 64-bit machines. One ought to be
  able to do two column or row operations in parallel by putting two
  salsa20 words into a uint64_t variable. May need some tricks to avoid
  carry propagation between the words, but I suspect it may be a win due
  to lower register pressure. A bit similar to the HAVE_NATIVE_64_BIT in
  camellia-crypt-internal.c.

* Try an sse2 assembly implementation (the djb:s papers outline how to
  do that). Or copy some existing implementation.

* Documentation.

As for the salsa20_* interface:

* It would be possible to change the interface to not expose the block
  size, doing a little buffering instead. But I think it's better to not
  do that, and follow what the ctr code and gcm code does.

* One advertised feature of the cipher is random access. I think we
  should have something like a salsa20_set_pos, taking a block count as
  argument.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120330201224</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-03-30 20:12:24-0400</timestampReceived><subject>Re: Salsa20</subject><body>

And now I've added support for salsa20 benchmarking as well. Performance
is pretty good, even for this reference implementation. Seems to run at
12 cycles per byte on my laptop, a little faster than 128-bit aes.

To get that working, I added a very kludgy

  const struct nettle_cipher nettle_salsa20 = {...};

to nettle-internal.c, for benchmarking only.

I also arranged in the Makefile so that nettle-internal.o no longer is
included in the nettle library. Will that cause any trouble for anybody?

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120418194714</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-04-18 19:47:14-0400</timestampReceived><subject>Re: Salsa20</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; For x86_64 (and maybe x86_32), assembly implementation also seems
&gt; attractive,

I just push an x86_64 implementation of salsa20_crypt. Runs at 6.6
cycles/byte on my laptop (or 189 Mbyte/s), which is more than twice the
speed of aes128, and slightly faster than arcfour.

It's likely possible to squeeze out a cycle or two more, by doing two
blocks in parallel (I think djb's x86_64 code does that, but I found it
very hard to read), or by other micro-optimizations.

Do any of you know of any protocols which specify use of salsa20? Is it
usually combined with some *fast* MAC algorithm?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120426122943</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-04-26 12:29:43-0400</timestampReceived><subject>Re: Salsa20</subject><body>

Hi!  Sorry for not following up on the Salsa20 thread, other things
needed my attention...   primarily my reason for saying this shouldn't
be committed directly was that it used the first reference
implementation from:

 http://cr.yp.to/snuffle.html

and that page contains other implementations as well, which may be
faster.  However speed can always be improved later on, I suppose the
important aspect is to get the API right from the start.

I'm replying to all your replies in this e-mail, see below.

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;
&gt;&gt; Hi!  Please find attached a port of DJB's public domain code for Salsa20
&gt;&gt; to nettle.  The patch is not meant to be applied as-is but to start a
&gt;&gt; discussion.
&gt;
&gt; I'm not familiar with this cipher... Could you explain briefly why one
&gt; may want to use it?

I don't know of any reason today, e.g., no important Internet
applications uses it.  It has some interesting properties though, so
maybe there is uptake.

&gt;&gt; While writing this I noticed a sub-optimal design of Nettle, in that it
&gt;&gt; overloads the meaning of struct nettle_cipher-&gt;block_size as a flag of
&gt;&gt; whether the cipher is a stream cipher or not.  Before arcfour was the
&gt;&gt; only stream cipher in nettle, and using block_size=0 to signal that it
&gt;&gt; is a stream cipher worked fine.  However, Salsa20 has a block size of 8
&gt;&gt; bytes.
&gt;
&gt; If Salsa20 doesn't fit in the nettle_cipher abstraction, then I think we
&gt; should start by implementing Salsa20 *without* trying to get it to fit
&gt; there. To me, a "stream cipher" with a block size and iv seems a bit
&gt; like a contradiction.

Somewhat, although I think the distinction between stream ciphers and
block ciphers is not a good one to make in an API.  Usually applications
want to use ciphers in some mode, and some modes used with block ciphers
make them essentially stream ciphers.  I think an good API should be
modeled around "symmetric encryption" as the concept.  Possibly just
"encryption", but I think public-key and symmetric encryption are such
different beasts that they shouldn't be exposed through the same API.

&gt; In general, I don't think it makes much sense to include algorithms
&gt; which behave very differently under the "nettle_cipher" umbrella, since
&gt; the point of that abstraction is to collect algorithms which are easily
&gt; exchangable. Code accepting a nettle_cipher are not expected to check
&gt; flags or behave fundamentally different for different algorithms.

Sure.

&gt; Including the arcfour stream cipher there may well be a mistake. One
&gt; annoying problem with the current design is that for block ciphers, the
&gt; ctx argument of the encrypt and decrypt functions naturally is const,
&gt; but due arcfour being fittted in the same nettle_cipher abstraction, the
&gt; function typedef nettle_crypt_func can't use a const ctx.

I always found rc4 the odd cipher in nettle.

&gt; Anyway, I'd prefer to treat redesign in that area as an independent
&gt; problem from adding support for Salsa20.

That is a good idea.

&gt; Then there's also the tentative (nettle-internal.h) nettle_aead
&gt; abstraction. Salsa20 could perhaps fit there, if we allow algorithms
&gt; with no authentication (NULL digest function pointer).

Possibly...  or just have one abstract "symmetric encryption" that
embodies all these variants.  Or does that lead to other disadvantages?

&gt;&gt; --- /dev/null
&gt;&gt; +++ b/salsa20.c
&gt;&gt; +#define ROTL32(x,n) ((((x))&lt;&lt;(n)) | (((x))&gt;&gt;(32-(n))))
&gt;
&gt; There are several different variants of that macro. It would be nice
&gt; with a unified one in macros.h.

I agree.

&gt;&gt; +#define SWAP32(v)				\
&gt;&gt; +  ((ROTL32(v,  8) &amp; 0x00FF00FFUL) |		\
&gt;&gt; +   (ROTL32(v, 24) &amp; 0xFF00FF00UL))
&gt;&gt; +
&gt;&gt; +#ifdef WORDS_BIGENDIAN
&gt;&gt; +#define U32TO32_LITTLE(v) SWAP32(v)
&gt;&gt; +#else
&gt;&gt; +#define U32TO32_LITTLE(v) (v)
&gt;&gt; +#endif
&gt;&gt; +
&gt;&gt; +#define U8TO32_LITTLE(p) U32TO32_LITTLE(((uint32_t*)(p))[0])
&gt;&gt; +#define U32TO8_LITTLE(p, v) (((uint32_t*)(p))[0] = U32TO32_LITTLE(v))
&gt;
&gt; That's a clever byte swapping trick (at least if a true rot instruction
&gt; is available). In Nettle conversion between bytes and integers are
&gt; usually done with READ_UINT32, LE_READ_UINT32 and friends. It's usually
&gt; not very performance critical, and it deals naturally with any
&gt; alignment. I suspect U8TO32_LITTLE above breaks if the input is
&gt; unaligned but the architecture doesn't allow unaligned word reads.

Using READ_UINT32 etc is probably better.

&gt;&gt; +/*
&gt;&gt; +salsa20-ref.c version 20051118
&gt;&gt; +D. J. Bernstein
&gt;&gt; +Public domain.
&gt;&gt; +*/
&gt;
&gt; Shouldn't that be moved up closer to the (C) header?

I put the majority of my changes above that header, to make it easy to
sync and compare the code

&gt;&gt; +#define ROTATE(v,c) (ROTL32(v,c))
&gt;&gt; +#define XOR(v,w) ((v) ^ (w))
&gt;&gt; +#define PLUS(v,w) ((v) + (w))
&gt;&gt; +#define PLUSONE(v) (PLUS((v),1))
&gt;
&gt; I'm not sure these macros improve readability...

They are from the reference code.

&gt;&gt; +static void salsa20_wordtobyte(uint8_t output[64],const uint32_t input[16])
&gt;
&gt; Despite the name, this is the main encryption function. Or rather, a
&gt; (hopefully) one-way function? "input" is really the context struct,
&gt; which contains some mix of the key and the iv?

I must admit I haven't looked into the details of the code.

&gt;&gt; +    x[ 4] = XOR(x[ 4],ROTATE(PLUS(x[ 0],x[12]), 7));
&gt;
&gt; And what's wrong with writing that as
&gt;
&gt;   x[ 4] ^= ROTATE(x[ 0] + x[12], 7)

That's clearer to me.

&gt;&gt; +void
&gt;&gt; +salsa20_set_iv(struct salsa20_ctx *ctx, unsigned length, const uint8_t *iv)
&gt;&gt; +{
&gt;&gt; +  assert (length == SALSA20_IV_SIZE);
&gt;
&gt; And this initializes indices 6-9. I'd remove the length argument, if
&gt; only one value is allowed anyway.

I added it only for compatibility with the internal nettle interface.

&gt; I've done some more homework, reading some of djb's papers and the
&gt; wikipedia page. Some questions:
&gt;
&gt; 1. Any protocols that specify use of salsa20? And in combination with
&gt;    which MAC? With claimed cycle numbers, hmac with sha1 or sha2 is
&gt;    going to take much more time than the encryption.

I don't know of any protocols right now.

&gt; 2. What about the later "ChaCha" cipher? As far as I see, it has not
&gt;    been studied as much as Salsa20.

Yeah, I looked at it too, but preferred something that people seems more
familiar with.

&gt; * A bit of cleanup of the code.
&gt;
&gt; * Try optimization of the C code for 64-bit machines. One ought to be
&gt;   able to do two column or row operations in parallel by putting two
&gt;   salsa20 words into a uint64_t variable. May need some tricks to avoid
&gt;   carry propagation between the words, but I suspect it may be a win due
&gt;   to lower register pressure. A bit similar to the HAVE_NATIVE_64_BIT in
&gt;   camellia-crypt-internal.c.
&gt;
&gt; * Try an sse2 assembly implementation (the djb:s papers outline how to
&gt;   do that). Or copy some existing implementation.

Take a look at the link above, most likely there exists something.  I'm
not sure how important it is though.

&gt; * Documentation.

Yes.

&gt; As for the salsa20_* interface:
&gt;
&gt; * It would be possible to change the interface to not expose the block
&gt;   size, doing a little buffering instead. But I think it's better to not
&gt;   do that, and follow what the ctr code and gcm code does.

I agree.

&gt; * One advertised feature of the cipher is random access. I think we
&gt;   should have something like a salsa20_set_pos, taking a block count as
&gt;   argument.

Yes.

&gt; I also arranged in the Makefile so that nettle-internal.o no longer is
&gt; included in the nettle library. Will that cause any trouble for anybody?

Didn't GnuTLS use some
thought-to-be-internal-functions-but-apparently-not?  Maybe it was just
the macros.h header file though.

&gt; Do any of you know of any protocols which specify use of salsa20? Is it
&gt; usually combined with some *fast* MAC algorithm?

I suspect people who like Salsa are inclined to also like CubeHash,
which could be used in HMAC variants.  CubeHash is fast with optimistic
parameters, but the "default" is pretty conservative making it not so
fast.

/Simon

</body></email><email><emailId>20120426072109</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2012-04-26 07:21:09-0400</timestampReceived><subject>Re: AES assembler not compatible with Windows x64</subject><body>

Hi,

On Thu, 26 Apr 2012, Mann Ern Kang wrote:

&gt; This can be worked around for now with --disable-assembler during
&gt; ./configure. Going forward, will there be any plans to support assembler
&gt; for x64 Windows?

This should already be fixed in the latest git version (and latest cvs 
version prior to the conversion), and in the 2.5-prerelease at 
http://www.lysator.liu.se/~nisse/archive/nettle-2.5-pre.tar.gz.

// Martin

</body></email><email><emailId>20120507171302</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-05-07 17:13:02-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

Paul Eggert &lt;eggert@cs.ucla.edu&gt; writes:

&gt; Hmm, well, the latter point is dubious.  SunOS 5.10 standard headers do not
&gt; mention int_fast*_t, except in stdint.h where C requires their definition.

I'd consider that definition to be authoritative...

&gt; Presumably this is for the same reason that Gnulib avoids these types.
&gt; Arguably these types are not part of the SunOS 5.10 ABI, since nothing
&gt; in the SunOS library binary interface use them.

C is still the system programming language, and int_fast*_t are part of
the language. But maybe we're splitting hairs now.

&gt; The main reason is to keep gnulib simple and maintainable.
&gt; I'd rather not have to hand-maintain details about an
&gt; operating system that hasn't shipped since 2009.

I thought the point of gnulib was to do those annoying things to keep
the maintanance in one place. But I guess I'll have to leave to the
judgment of the gnulib maintainers which systems are too old and
obsolete to care about.

&gt; How does the nettle stuff work?  Does it #define int_fast8_t etc
&gt; in config.h?

It is defined in a generated file nettle-stdint.h. And the names of the
types are all typedefs, no #defines.

With AX_CREATE_STDINT_H, it's a file generated independently of
config.h. The file starts with a section with a bunch of #defines set up
by configure, and then the rest of the file uses various tests on these
to decide what file to include and which types to define. Where the
common case is to just include the system's &lt;stdint.h&gt;. The file is then
installed with the other nettle header files.

&gt; If so, there's a simple workaround in gnulib:
&gt; don't futz with int_fast8_t if it's already #defined.

If one could get that to work, it might solve the problem for the case
that the types are defined but not used. But if it implies that size of
those types will depend on #include order, it seems very brittle to me.
I think it would be better to let the gnulib application say explicitly
whether or not it needs those types, and not define them at all in the
common case that they aren't needed. I.e.,

#ifdef GL_WANT_INTX_FAST_T
# define int_fast8_t gl_int_fast8_t
#endif

Not sure where one would define GL_WANT_INTX_FAST_T, if desired, though.
Should be specified in some way in configure.ac, but it can't be put in
config.h if the stdint.h types are needed for installed header files.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120508085551</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-05-08 08:55:51-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

Paul Eggert &lt;eggert@cs.ucla.edu&gt; writes:

&gt; Thanks.  This seems to be a win regardless of whether it
&gt; fixes the nettle problems,

Dago, can you test if it solves the SunOS-5.9 problem for you? I.e.,
apply Paul's patch to gnutls/gnulib, then *unapply* the nettle
workaround I comitted yesterday, and see if you still get compilation
errors related to nettle-stdint.h.

I'm not sure how picky the compiler is about multiple but equivalent
typedefs of the same name. 

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120508155649</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-05-08 15:56:49-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

Paul Eggert &lt;eggert@cs.ucla.edu&gt; writes:

&gt; Such usage violates the C standard: even if one compiler
&gt; is not picky about it, your're likely to run into another that
&gt; does.  So a better solution is needed.

I've committed a workaround to nettle-types.h. It now does

  /* Pretend these types always exists. Nettle doesn't use them. */
  #define _STDINT_HAVE_INT_FAST32_T 1
  
  #include "nettle-stdint.h"

which overrides the result of the configure checks used in the generated
nettle-stdint.h. Maybe not the prettiest way to do it, but apparantly
it solves the problem, independently of your fixes to gnulib. (But I'd
still like to know if your fixes also solves this problem, independently
of that Nettle workaround).

&gt; I'd rather have an approach where the code simply does "#include
&gt; &lt;stdint.h&gt;" and assumes that int_fast8_t works. I don't understand the
&gt; overall situation, though, so I don't know what exactly to suggest.

I think when you build gnutls on a system lacking stdint.h, a
typical compilation unit will contain

  /* From gnulib's stdint.h */
  typedef unsigned int gl_uint32_t;
  #define uint32_t gl_uint32_t
  ...
  
  /* From nettle/nettle-stdint.h */
  typedef unsigned int uint32_t;

where the final line is macro-expanded to

  typedef unsigned int gl_uint32_t;

&gt;From what I've seen, this has been no problem. And I hope
nettle-stdint.h and gnulib/stdint.h always do these types in the same
way. There is some freedom in how to define these types; on a system
where for example int and long are the same size, 

  typedef unsigned long uint32_t;
  typedef unsigned int uint32_t;

would be a two distinct but correct definitions, and I imagine the
compiler would complain. And to consider the problematic int_fast*_t
types, until a day or two ago, you got

  /* From gnulib's stdint.h */
  typedef long gl_int_fast8_t;
  #define int_fast8_t gl_int_fast8_t
  ...
  
  /* From nettle/nettle-stdint.h */
  typedef char int_fast8_t;

which no reasonable compiler will accept.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120430091632</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-04-30 09:16:32-0400</timestampReceived><subject>RSA private key abstraction</subject><body>

I'm thinking about how to represent private keys. The context is the
desire to support RSA blinding. I'd like to avoid having to duplicate
all the signature functions (of which there's already a large number).
This email is an expansion of a 3.0 entry in plan.txt.

One way would be to pass a function pointer (and some optional ctx) for
doing the private key operation. This would then be used wherever the
current code calls _rsa_compute_root, and it would represent an RSA
private key oracle.

If we stick to software implementation, one could pass it as an extra
argument, or one could extend the private key struct like

  struct rsa_private_key
  {
    mpz_t d;
    ...
    rsa_compute_root_func *f;
  };

and one could then "subclass" that as

  struct rsa_private_key_blinding
  {
    struct rsa_private_key super;
    struct whatever_random_ctx_needed ctx;
  };

(not sure this is the best design, but it's one possibility).

Now I have a question: Would it be feasible to support smartcards (and
similar hardware) at the same time? Then the secret key wouldn't be
available at all to nettle, and a signature function might have an
interface like

  int
  rsa_sha1_sign(rsa_compute_root_func *f, void *private,
                struct sha1_ctx *hash,
                mpz_t signature);

where the actual private key data is totally dependent on the smartcard
and its interface software.

But what interfaces do typical smartcards use? Do they allow you to
compute an arbitrary rsa root, or do they only more specific operations
like "pkcs#1 v1.5 decrypt", "pkcs#1 v1.5 sha1 sign", #pkcs#1 v2.0 sha256
sign"?

I want to figure out if smartcard support at this level is at all
feasible. If not, we have to leave that for applications and libraries
on top of nettle, and then the nettle interface should be tailored for
software keys only.

I've also had a quick look at the ssh-agent and gpgagent protocols. Both
seems a bit too application specific, so I don't think it's feasible to
hook in those as general "private key oracles" here.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20120508193543</emailId><senderName>Dagobert Michelsen</senderName><senderEmail>dam@opencsw.org</senderEmail><timestampReceived>2012-05-08 19:35:43-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

Hi Niels,

Am 08.05.2012 um 10:55 schrieb Niels Möller:
&gt; Paul Eggert &lt;eggert@cs.ucla.edu&gt; writes:
&gt;&gt; Thanks.  This seems to be a win regardless of whether it
&gt;&gt; fixes the nettle problems,
&gt; 
&gt; Dago, can you test if it solves the SunOS-5.9 problem for you? I.e.,
&gt; apply Paul's patch to gnutls/gnulib, then *unapply* the nettle
&gt; workaround I comitted yesterday, and see if you still get compilation
&gt; errors related to nettle-stdint.h.
&gt; 
&gt; I'm not sure how picky the compiler is about multiple but equivalent
&gt; typedefs of the same name. 

If Paul or you could provide a bootstrapped tarball I'll be happy to test it as
I am not really familiar with gnulib bootstrapping.


Best regards

  -- Dago

-- 
"You don't become great by trying to be great, you become great by wanting to do something,
and then doing it so hard that you become great in the process." - xkcd #896


</body></email><email><emailId>20120505191909</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-05-05 19:19:09-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

Dagobert Michelsen &lt;dam@opencsw.org&gt; writes:

&gt; I see different possibilities on how this can be resolved:
&gt;
&gt; 1. nettle uses the gnulib definitions

I currently have no plans to switch to using gnulib.

As far as I'm aware, there's no problem with the types which nettle
actually uses. So it would be a reasonable workaround to simply not
define the int_fast*_t types; then they won't collide with the
incompatible definitions gnutls gets from gnulib. Question is just
what's the least intrusive way to do that (*if* it's easy to avoid, I'd
prefer not to modify the definition of AX_CREATE_STDINT_H). I would
appreciate if you can try the workarounds I suggested the other day and
let me know how it works.

&gt; 2. gnulib changes the definitions to conform to nettle

The problem with gnulib is not primarily that it doesn't "conform to
nettle", but that it defines some types in a way that differs both from
&lt;stdint.h&gt; on later releases on the OS (where the types are included),
and from the definition in the stdint.h which comes with gcc.

So code which uses the int_fast*_t types and relies on gnulib will get a
slightly different ABI if compiled on SunOS-5.9 (or earlier) using Sun's
compiler, than if compiled with gcc on the same system, or compiled with
Sun's compiler on any later release of the OS. I think that's what needs
to be fixed in gnulib. Do the gnulib folks agree?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120506071343</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-05-06 07:13:43-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

Paul Eggert &lt;eggert@cs.ucla.edu&gt; writes:

&gt; Generally speaking, it's unwise to use
&gt; the int_fast*_t types in a public header file.

Why (feel free to point to the relevant section of gnulib docs, if it's
explained well there)?

Maybe nobody uses these types so it's an academic issue, but if these
types are used in the interface to any library (possibly some system
library), then it's important that applications agree on the definition.
To me, it seems like the authoritative definition of int_fast*_t ought
to be the system's ABI specification.

And in the case of SunOS-5.9, where the types are missing, I think it
makes the most sense to adopt the ABI of SunOS-5.10. Which also seems to
be what gcc does.

I'm a bit confused by your statement. I had the impression that gnulib
*does* fall back on the definitions in public headers like &lt;stdint.h&gt;
and &lt;inttypes.h&gt;, for the types which *are* defined there. And that's
why nettle and gnutls seem to work together on SunOS-10. Correct?

&gt; This is a documented issue in Gnulib.
&gt; It's hard to imagine a general fix for this.

One possibility might be to not define the types at all, unless the
gnulib application *explicitly* asks for them. Lots of applications want
uint32_t, and I imagine a lot fewer have any need for int_fast*_t.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120506074716</emailId><senderName>Dagobert Michelsen</senderName><senderEmail>dam@opencsw.org</senderEmail><timestampReceived>2012-05-06 07:47:16-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

Hi Niels,

Am 06.05.2012 um 07:02 schrieb Paul Eggert:
&gt; On 05/05/2012 12:19 PM, Niels Möller wrote:
&gt;&gt; So code which uses the int_fast*_t types and relies on gnulib will get a
&gt;&gt; slightly different ABI
&gt; 
&gt; Generally speaking, it's unwise to use
&gt; the int_fast*_t types in a public header file.
&gt; This is a documented issue in Gnulib.
&gt; It's hard to imagine a general fix for this.

Do you see a chance to adjust the nettle header files to avoid the fast-types?
The current situation makes gnutls uncompilable on platforms like Solaris.


Best regards

  -- Dago

-- 
"You don't become great by trying to be great, you become great by wanting to do something,
and then doing it so hard that you become great in the process." - xkcd #896


</body></email><email><emailId>20120506104907</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-05-06 10:49:07-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

On 05/06/2012 12:34 PM, Bruno Haible wrote:

&gt; Niels Möller wrote:
&gt;&gt; One possibility might be to not define the types at all, unless the
&gt;&gt; gnulib application explicitly asks for them. Lots of applications want
&gt;&gt; uint32_t, and I imagine a lot fewer have any need for int_fast*_t.
&gt; Yes. For this reason, libunistring installs a trimmed-down version of
&gt; gnulib's stdint.h, that defines only the int{8,16,32}_t types and not
&gt; all the rest (int64_t, int_least*_t, int_fast*_t, etc.). [1]


Is there a gnulib module that only provides the basic types?

regards,
Nikos


</body></email><email><emailId>20120506145237</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-05-06 14:52:37-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

Bruno Haible &lt;bruno@clisp.org&gt; writes:

&gt; It doesn't exist so far. But it is feasible. - On the other hand, it
&gt; looks like nettle-stdint.h can already be easily trimmed in this way,
&gt; by undefining _STDINT_NEED_INT_LEAST_T and _STDINT_NEED_INT_FAST_T ?

I think that makes sense. I just need someone (Dagobert Michelsen?) who
can try it out. Nettle uses the AX_CREATE_STDINT_H macro to generate
that file. If it's easy, I'd prefer not to touch that and just add some
extra #define in nettle-types.h before it includes nettle-stdint.h. Or
if that doesn't work out, it's fine to hack away in the definition in
aclocal.m4 to take out the unneded types.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120506193847</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-05-06 19:38:47-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

Paul Eggert &lt;eggert@cs.ucla.edu&gt; writes:

&gt; Intuitively, it's because the int_fast* types are so fragile: they
&gt; depend so much on choice of compiler and compiler option.

Short version: I think gnulib should either make an effort to define
int_fast*_t in the common way on each system (always doing the same as
gcc would be very close to the Right Thing), or by default generate a
stdint.h without these types and define the int_fast*_t types only when
explicitly asked to.

Longer version (sorry I fail to be more concise):

I think I misread "public headers" in your previous mail, I thought you
meant system header files, rather than public header files provided by
portable non-system libraries. Sorry for the confusion. I agree one can
expect these types to be a fragile and compiler dependent whenever
they're left undefined by system headers and ABI spec, which will be the
usual assumption for portable code.

But in the particular case of SunOS, the types are defined by system
headers in release 5.10 (and presumably nailed down by the ABI spec),
but missing in release 5.9. Do you see any good reason for gnulib to not
define the types in the same way as on 5.10, if building on 5.9? 

To me, that really looks like the Right Thing to do, and it also looks
like the kind of job gnulib is supposed to do. Defining them in a way
which differs from SunOS-5.10 definitely seems broken. In the case of
gnutls and nettle, one gets compilation errors when another packed
defines the same types, and does it using a configure hack which *is*
compatible with SunOS-5.10. Of course, that fix doesn't magically make
int_fast*_t universally non-fragile, but it definitely improves
compatibility for the system in question.

As for nettle, I think it's best to not define these types, which aren't
used. On Solaris, it happens that AX_CREATE_STDINT_H defines them more
correctly (in my view) than gnulib, but it may well cause problems on
other system, so it seems more robust to not try to define them at all.

But please also consider the hypothetical situation that nettle *did*
use those types, even if only internally. Then I couldn't simply omit
the definitions. To not cause problems for gnulib users I'd be forced to
either change my definitions to prefer compatibility with gnulib over
compatibility with SunOS-5.10, which seems really backwards, or
introduce additional complexity in nettle-stdint.h to omit the
definitions when my public headers need uint32_t.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120508200543</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-05-08 20:05:43-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

Dagobert Michelsen &lt;dam@opencsw.org&gt; writes:

&gt; If Paul or you could provide a bootstrapped tarball I'll be happy to test it as
&gt; I am not really familiar with gnulib bootstrapping.

I'm also not very familiar with gnulib. 

But I think it should work fine to just get the gnutls release and apply
Paul's patch to the file gnutls-3.0.9/gl/stdint.in.h before running the
configure script.

Regards,
/Niels



-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120522205350</emailId><senderName>Dagobert Michelsen</senderName><senderEmail>dam@opencsw.org</senderEmail><timestampReceived>2012-05-22 20:53:50-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

Hi,

Am 08.05.2012 um 23:17 schrieb Paul Eggert:
&gt; On 05/08/2012 01:05 PM, Niels Möller wrote:
&gt;&gt; I think it should work fine to just get the gnutls release and apply
&gt;&gt; Paul's patch to the file gnutls-3.0.9/gl/stdint.in.h before running the
&gt;&gt; configure script.
&gt; 
&gt; Yes, that's the idea.  Thanks.

Sorry for the delay, I got distracted. I just tested the latest stdint.in.h from gnulib
master and gnutls 3.0.19 passes this stage now. However, I didn't change anything on the nettle
includes and now get lots of warnings. Probably the gl_* definitions should not belong
to the installed nettle headers?

  CC     pkcs12_bag.lo
"/opt/csw/include/nettle/nettle-stdint.h", line 237: warning: typedef redeclared: gl_int_fast8_t
"/opt/csw/include/nettle/nettle-stdint.h", line 238: warning: typedef redeclared: gl_int_fast16_t
"/opt/csw/include/nettle/nettle-stdint.h", line 239: warning: typedef redeclared: gl_int_fast32_t
"/opt/csw/include/nettle/nettle-stdint.h", line 241: warning: typedef redeclared: int64_t
"/opt/csw/include/nettle/nettle-stdint.h", line 244: warning: typedef redeclared: gl_uint_fast8_t
"/opt/csw/include/nettle/nettle-stdint.h", line 245: warning: typedef redeclared: gl_uint_fast16_t
"/opt/csw/include/nettle/nettle-stdint.h", line 246: warning: typedef redeclared: gl_uint_fast32_t
"/opt/csw/include/nettle/nettle-stdint.h", line 248: warning: typedef redeclared: uint64_t


Best regards

  -- Dago

-- 
"You don't become great by trying to be great, you become great by wanting to do something,
and then doing it so hard that you become great in the process." - xkcd #896


</body></email><email><emailId>20120427152420</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-04-27 15:24:20-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Yes. Understanding what the differences is, and which one is right,
&gt; seems useful first though. If the problem is in gnulib, we can fix
&gt; that and GnuTLS will have the new variant soon.

Quoting my investigation from an old (off-list) email thread, from
November last year:

  And the problem seems to be that inttypes.h doesn't define int_fast8_t
  types. And then AX_CREATE_STDINT_H (used by nettle) and gnulib (used by
  gnutls) both decide to define them, and they do that in an incompatible
  way.

---

  From a quick look at gl/stdint.h.in and on posted error messages, I
  think glib uses long for all of int_fast8_t, int_fast16_t and
  int_fast32_t, and int64_t for int_fast64_t, while nettle uses int8_t,
  int, int32_t and int64_t.

---

  &gt;&gt; Actually, one ought to have a look at the definitions in the stdint.h
  &gt;&gt; provided by gcc (and at the definitions in the solaris10 stdint.h), and
  &gt;&gt; make sure the definitions of the int_fast* types are equivalent.
  &gt;&gt; Otherwise one might end up with subtle ABI differences and errors when
  &gt;&gt; linking together code compiled by different compilers.
  &gt;
  &gt; Agreed.
  
  I did a quick check. The following seems to be the correct sizes:
  
  int_fast8_t: 1
  int_fast16_t: 4
  int_fast32_t: 4
  int_fast64_t: 8
  
  This is using sizeof on the types defined in stdint.h, trying:
  
  gcc -m32 on solaris 9
  gcc -m64 on solaris 9
  cc -m32 on solaris 10
  cc -m64 on solaris 10
  
  Remarkably enough, they all agree. I also get the same sizes from
  nettle-stdint.h, for both 32 bit and 64 bit configurations. So I think
  nettle (or really, AX_CREATE_STDINT_H) gets this right.
  
  While if I understand gl correctly, it uses 4,4,4,8 for a 32-bit build
  and 8,8,8,8 for a 64-bit build (the size of long is different). This
  seems wrong. Sure, these are perfectly ok sizes according to C99, but
  they differ from the sparc conventions (and possibly conventions for
  other architectures as well).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120430165314</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2012-04-30 16:53:14-0400</timestampReceived><subject>Re: Release plans</subject><body>

A comment on the last point. I don't think a smart-card interface
suits nettle. It is a software (low-level) library. Smart card support
could be added only if nettle supported a higher level API, but even
then I don't know how useful it would be as pkcs11 is already there
for that reason.

regards,
Nikos

On Mon, Apr 30, 2012 at 4:10 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt; I've updated the todo page
&gt; http://www.lysator.liu.se/~nisse/nettle/plan.html
&gt; (also as misc/plan.html in the git repo).
&gt;
&gt; Any missing items?
&gt;
&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels M=C3=B6ller. PGP-encrypted email is preferred. Keyid C0B98E26.
&gt; Internet email is subject to wholesale government surveillance.
&gt;
&gt; _______________________________________________
&gt; nettle-bugs mailing list
&gt; nettle-bugs@lists.lysator.liu.se
&gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20120430170808</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2012-04-30 17:08:08-0400</timestampReceived><subject>Re: RSA private key abstraction</subject><body>

On Mon, Apr 30, 2012 at 6:16 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; and one could then "subclass" that as
&gt; =C2=A0struct rsa_private_key_blinding
&gt; =C2=A0{
&gt; =C2=A0 =C2=A0struct rsa_private_key super;
&gt; =C2=A0 =C2=A0struct whatever_random_ctx_needed ctx;
&gt; =C2=A0};

It might be too  complicated for a low level library. If all those
were hidden from applications it would be all right, but this
complication will lead to a moment where something has to be
changed/updated/added. I'd suggest to keep the low level interface as
simple.

&gt; (not sure this is the best design, but it's one possibility).
&gt; Now I have a question: Would it be feasible to support smartcards (and
&gt; similar hardware) at the same time? Then the secret key wouldn't be
&gt; available at all to nettle, and a signature function might have an
&gt; interface like&gt;
&gt; =C2=A0int
&gt; =C2=A0rsa_sha1_sign(rsa_compute_root_func *f, void *private,
&gt; =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0struct sha1_ctx *h=
ash,
&gt; =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0mpz_t signature);

Then you'd need to cope with smart card drivers and all. Opensc does
all that and provides a pkcs11 interface. All (or most) commercial
smart cards also provide a pkcs11 interface. So I'd expect that
applications that do that, already use it (we do it in gnutls and the
high level functions abstract between keys in software -&gt; nettle and
keys in hardware -&gt; pkcs11).

&gt; where the actual private key data is totally dependent on the smartcard
&gt; and its interface software.
&gt; But what interfaces do typical smartcards use? Do they allow you to
&gt; compute an arbitrary rsa root, or do they only more specific operations
&gt; like "pkcs#1 v1.5 decrypt", "pkcs#1 v1.5 sha1 sign", #pkcs#1 v2.0 sha256
&gt; sign"?

They can do either, depending on the capabilities of the card.

&gt; I want to figure out if smartcard support at this level is at all
&gt; feasible. If not, we have to leave that for applications and libraries
&gt; on top of nettle, and then the nettle interface should be tailored for
&gt; software keys only.

I think it would make sense for a high level interface.

regards,
Nikos

</body></email><email><emailId>20120329093956</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-03-29 09:39:56-0400</timestampReceived><subject>Re: GNU MP not found (mingw)</subject><body>

Sorry for the late reply.

yyy &lt;yyy@yyy.id.lv&gt; writes:

&gt; config.log did not contain any recognizable links to missing files
&gt; (there were multiple references to "-lgmp", but it was  not a file)
&gt; (entire config.log is ~35KB, should I post it here?

In the config.log there should be a line like

configure:6551: checking for __gmpz_getlimbn in -lgmp

(possibly with a different line number). If that test fails, you should
find the test program, the compiler command line, and error messages,
close by.

Have you tried writing any testprogram of your own to link to gmp?

One possible issue is if you have compiled gmp in 64-bit mode (gmp's
configure does this by default, whenever possible), but you're compiling
nettle in 32-bit mode. If so, try

  ./configure CC="gcc -m64"

when building nettle.

&gt; Compiling and building GMP was successful, it produced file libgmp.a
&gt; with size of 648 236 bytes.

So it's a static library. May make things simpler.

&gt; Where nettle's configure script is looking for lgmp and what is the
&gt; required filename?

The answer to those questions are "whatever the used compiler and linker
does.". To get nettle's configure to look in different directories for
libraries (and include files! It also needs gmp.h), either use the
-with-library-path and --with-include-path flags, or set LDFLAGS and
CPPFLAGS on the configure command line.

&gt; Could it be, that nettle 2.4 does not work with
&gt; GMP 5.0.4 and requires older version?

I think it should work fine with the most recent gmp version.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120331221320</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-03-31 22:13:20-0400</timestampReceived><subject>Re: Salsa20</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; And now I've added support for salsa20 benchmarking as well. Performance
&gt; is pretty good, even for this reference implementation. Seems to run at
&gt; 12 cycles per byte on my laptop, a little faster than 128-bit aes.

Now I've done some cleanup and reorganization work. Using memxor3 for
the actual xoring saves almost 3 cycles per byte, so it's a considerable
speedup in this case (and then memxor3 can maybe be sped up a bit more
on this platform, from Nikos' work a while ago).

I wonder if there's any potential for simd-style parallel processing
using plain 64-bit operations (no sse2 assembly). If one puts two 32-bit
values in a 64-bit variable, parallel xor is trivial, but we also need
32-bit rotations and adds.

Parallel rotations are possible as two shifts and some extra masking, so
it might be slightly faster than two 32-bit rotations of two shifts
each.

For parallel mod 2^32 additions, one need to cancel one of the carries.
Something like

  uint64_t x, y, z;

  z = x + y;
  z += (- (uint64_t) ((uint32_t) z &lt; (uint32_t) y)) &lt;&lt; 32;

This can hardly be faster than two 32-bit additions (two lea, cmp, cmov
on x86_64, or alternatively, one lea, cmp, sbb, shl, add, depending on
code genereration).

Any speedup depends on the relative speedup or slowdown of each
primitive, the cost of permuting values as needed, and then the effects
of reduced register pressure on top of that.

For x86_64 (and maybe x86_32), assembly implementation also seems
attractive, but I'd like to do any general or 64-bit specific
optimizations in the C code first.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120427125448</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2012-04-27 12:54:48-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

Dagobert Michelsen &lt;dam@opencsw.org&gt; writes:

&gt; I just verified that the problem persists with nettle 2.4 and gnutls-3.0.19. As you seem to have
&gt; access to the Solaris buildfarm it would be cool if you could finally fix this as it blocks
&gt; new releases of gnutls for the OpenCSW distribution.

It's some time since I looked in to this. My understaning of the problem
is that

1. This Solaris version lack both &lt;stdint.h&gt; and &lt;inttypes.h&gt;. (A
   comment in AX_CREATE_STDINT_H seems to imply that it does have a
   &lt;sys/inttypes.h&gt;, should we use that?)

2. Nettle defines uint32_t and friends using the AX_CREATE_STDINT_H
   autoconf macro.

3. gnulib defines them in a different way.

4. The multiple definitions of, e.g., uint32_t, agree and are no
   problem.

5. The definitions of some other (unused) types are incompatible, e.g.,
   int_fast8_t, and cause the compilation errors.

6. The definitions from AX_CREATE_STDINT_H is compatible with the
   definitions of these types in Solaris 10. gnulib's definitions
   aren't, so any code using them can potentially break if linked
   together with code compiled on Solaris 10.

Hence I think it ought to be fixed in gnulib. Simon (and any other
gnulib people on these lists), do you agree?

To address (1), maybe you can try

diff --git a/configure.ac b/configure.ac
index 6bf2b8b..77bb9b1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -518,7 +518,7 @@ LSH_GCC_ATTRIBUTES
 
 # According to Simon Josefsson, looking for uint32_t and friends in
 # sys/types.h is needed on some systems, in particular cygwin.
-AX_CREATE_STDINT_H([nettle-stdint.h], [sys/types.h])
+AX_CREATE_STDINT_H([nettle-stdint.h], [sys/types.h], [sys/inttypes.h])
 
 # Check for file locking. We (AC_PROG_CC?) have already checked for
 # sys/types.h and unistd.h.

but I suspect you would still get compilation errors due to incompatible
definitions in gnulib and sys/inttypes.h.

Maybe the easiest nettle workaround would be to somehow disable the
definitions of the problematic types, which we don't use anyway.

Could you try something like the following?

diff --git a/nettle-types.h b/nettle-types.h
index b694332..d0aa332 100644
--- a/nettle-types.h
+++ b/nettle-types.h
@@ -23,6 +23,9 @@
 #ifndef NETTLE_TYPES_H
 #define NETTLE_TYPES_H
 
+/* Pretend this type always exists. Nettle doesn't use it. */
+#define _STDINT_HAVE_INT_FAST32_T 1
+
 #include "nettle-stdint.h"
 
 #ifdef __cplusplus

Have a look into the generated nettle-stdint.h (or the template in
aclocal.m4) for other potentially useful defines.

The closest Solaris 5.8 box I used to have acccess to
(hanna.lysator.liu.se) seems to have been decomissioned.

Regardss,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20120427134618</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2012-04-27 13:46:18-0400</timestampReceived><subject>Re: Problem with int types persists on nettle 2.4 and gnutls 3.0.19 on Solaris 9 Sparc</subject><body>

fre 2012-04-27 klockan 14:54 +0200 skrev Niels Möller:
&gt; Dagobert Michelsen &lt;dam@opencsw.org&gt; writes:
&gt; 
&gt; &gt; I just verified that the problem persists with nettle 2.4 and gnutls-3.0.19. As \
&gt; &gt; you seem to have access to the Solaris buildfarm it would be cool if you could \
&gt; &gt; finally fix this as it blocks new releases of gnutls for the OpenCSW \
&gt; &gt; distribution.
&gt; 
&gt; It's some time since I looked in to this. My understaning of the problem
&gt; is that
&gt; 
&gt; 1. This Solaris version lack both &lt;stdint.h&gt; and &lt;inttypes.h&gt;. (A
&gt; comment in AX_CREATE_STDINT_H seems to imply that it does have a
&gt; &lt;sys/inttypes.h&gt;, should we use that?)

Using system headers if available seems like a good idea.

&gt; 2. Nettle defines uint32_t and friends using the AX_CREATE_STDINT_H
&gt; autoconf macro.
&gt; 
&gt; 3. gnulib defines them in a different way.

What is the difference?  This sounds bad.

&gt; 5. The definitions of some other (unused) types are incompatible, e.g.,
&gt; int_fast8_t, and cause the compilation errors.

If they are unused, we could remove the definitions.

&gt; 6. The definitions from AX_CREATE_STDINT_H is compatible with the
&gt; definitions of these types in Solaris 10. gnulib's definitions
&gt; aren't, so any code using them can potentially break if linked
&gt; together with code compiled on Solaris 10.
&gt; 
&gt; Hence I think it ought to be fixed in gnulib. Simon (and any other
&gt; gnulib people on these lists), do you agree?

Yes.  Understanding what the differences is, and which one is right, seems useful \
first though.  If the problem is in gnulib, we can fix that and GnuTLS will have the \
new variant soon.

/Simon


</body></email></emails>