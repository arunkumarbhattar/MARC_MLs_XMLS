<?xml version="1.0" encoding="utf-8"?>
<emails><email><emailId>20180217225532</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-17 22:55:32-0400</timestampReceived><subject>Re: [PATCH v2 1/2] Implement PSS encoding functions</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Daiki Ueno &lt;ueno@gnu.org&gt; writes:
&gt;
&gt;&gt; I have incorporated the suggested changes here:
&gt;&gt; https://gitlab.com/dueno/nettle/commits/wip/dueno/rsa-padding
&gt;
&gt; Thanks!
&gt;
&gt; I've added these changes on a branch merge-pss in the main repo,
&gt; together with some smaller post-merge cleanups. 

Some late comments. 

In testsuite/Makefile.in, pss-mgf1-test.c is listed in
TS_NETTLE_SOURCES. Should be moved to TS_HOGWEED_SOURCES, to not get
link failured in builds without hogweed. Right? 

Alternatively, we could move pss-mgf1.c from libhogweed to libnettle,
but that doesn't seem very useful to me.

Both pss_mgf1 and pss_encode_mgf1 allocate the hash context using

  TMP_DECL(state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
  ...
  TMP_ALLOC(state, hash-&gt;context_size);

That should work fine if we are using alloca, which provides suitable
alignment, but if !HAVE_ALLOCA, we're only guaranteed uint8_t
alignment.

Nikos recent SIV patch does something similar. I'm thinking that maybe
we need some variant of TMP_DECL/TMP_ALLOC which takes a size in bytes
and guarantees alignment of at least uint64_t or so.

Alternatively, can we drop support for compilers lacking alloca, or
substitute malloc rather than fixed size stack allocation? In the latter
case, we'd need to augment TMP_* facilities with TMP_FREE to deallocate
properly in that case (like we already do for TMP_GMP_ALLOC).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180218210244</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-18 21:02:44-0400</timestampReceived><subject>Re: [PATCH v2 1/2] Implement PSS encoding functions</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; In testsuite/Makefile.in, pss-mgf1-test.c is listed in
&gt; TS_NETTLE_SOURCES. Should be moved to TS_HOGWEED_SOURCES, to not get
&gt; link failured in builds without hogweed. Right? 

Moved now.

&gt; Both pss_mgf1 and pss_encode_mgf1 allocate the hash context using
&gt; 
&gt; TMP_DECL(state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt; ...
&gt; TMP_ALLOC(state, hash-&gt;context_size);
&gt; 
&gt; That should work fine if we are using alloca, which provides suitable
&gt; alignment, but if !HAVE_ALLOCA, we're only guaranteed uint8_t
&gt; alignment.

It seems this currently doesn't work at all without alloca. If I delete
"#define HAVE_ALLOCA 1 " from config.h, compilation fails with

In file included from /home/nisse/hack/nettle/pss.c:48:0:
/home/nisse/hack/nettle/pss.c: In function ‘nettle_pss_encode_mgf1':
/home/nisse/hack/nettle/nettle-internal.h:57:46: error: invalid application of \
‘sizeof' to incomplete type ‘struct sha3_224_ctx'  #define \
NETTLE_MAX_HASH_CONTEXT_SIZE (sizeof(struct sha3_224_ctx))  ^
/home/nisse/hack/nettle/nettle-internal.h:49:46: note: in definition of macro \
‘TMP_DECL'  # define TMP_DECL(name, type, max) type name[max]
                                              ^~~
/home/nisse/hack/nettle/pss.c:70:28: note: in expansion of macro \
‘NETTLE_MAX_HASH_CONTEXT_SIZE'  TMP_DECL(state, uint8_t, \
NETTLE_MAX_HASH_CONTEXT_SIZE);  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~

For now, I think I'll fix this, and add a TMP_ALIGN_DECL,
TMP_ALIGN_ALLOC. I still wonder if support for compilers without alloca
is relevant?

Regards, 
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20180219115452</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-02-19 11:54:52-0400</timestampReceived><subject>Re: [PATCH v2 1/2] Implement PSS encoding functions</subject><body>

On Sat, 2018-02-17 at 23:55 +0100, Niels Möller wrote:
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt; &gt; Daiki Ueno &lt;ueno@gnu.org&gt; writes:
&gt; &gt; 
&gt; &gt; &gt; I have incorporated the suggested changes here:
&gt; &gt; &gt; https://gitlab.com/dueno/nettle/commits/wip/dueno/rsa-padding
&gt; &gt; 
&gt; &gt; Thanks!
&gt; &gt; 
&gt; &gt; I've added these changes on a branch merge-pss in the main repo,
&gt; &gt; together with some smaller post-merge cleanups. 
&gt; 
&gt; Some late comments. 
&gt; 
&gt; In testsuite/Makefile.in, pss-mgf1-test.c is listed in
&gt; TS_NETTLE_SOURCES. Should be moved to TS_HOGWEED_SOURCES, to not get
&gt; link failured in builds without hogweed. Right? 
&gt; 
&gt; Alternatively, we could move pss-mgf1.c from libhogweed to libnettle,
&gt; but that doesn't seem very useful to me.
&gt; 
&gt; Both pss_mgf1 and pss_encode_mgf1 allocate the hash context using
&gt; 
&gt;   TMP_DECL(state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
&gt;   ...
&gt;   TMP_ALLOC(state, hash-&gt;context_size);
&gt; 
&gt; That should work fine if we are using alloca, which provides suitable
&gt; alignment, but if !HAVE_ALLOCA, we're only guaranteed uint8_t
&gt; alignment.

What if TMP_ALLOC() allocates 16 bytes more and makes sure it returns a
16-byte aligned buffer? That is, return something passed from:

#define ALIGN16(x) \
        ((void *)(((ptrdiff_t)(x)+(ptrdiff_t)0x0f)&amp;~((ptrdiff_t)0x0f)))

(the 16-byte alignment is because that's the worse case alignment
needed, e.g., for AESNI keys etc).

&gt; Alternatively, can we drop support for compilers lacking alloca, or
&gt; substitute malloc rather than fixed size stack allocation? In the
&gt; latter
&gt; case, we'd need to augment TMP_* facilities with TMP_FREE to
&gt; deallocate
&gt; properly in that case (like we already do for TMP_GMP_ALLOC).

What about switching to C99 buffers like:
uint8_t buffer[buffer_size]; and fallback to alloca otherwise?

That would still require additional allocation for alignment handling,
but it would be standard C. The current macros would also be simplified
by such a move.

regards,
Nikos


</body></email><email><emailId>20180403160816</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-04-03 16:08:16-0400</timestampReceived><subject>Re: symbol versioning update</subject><body>

On Fri, 2018-03-30 at 09:29 +0200, Niels Möller wrote:
&gt; Daniel P. Berrangé &lt;berrange@redhat.com&gt; writes:
&gt; 
&gt; &gt; The traditional way is for developers to update the dependancies to
&gt; &gt; have
&gt; &gt; an explicit version against the library they require. eg if libvirt
&gt; &gt; requires
&gt; &gt; some symbol introduced in nettle x.y, the maintainer would add
&gt; &gt; 
&gt; &gt;   Requires: nettle &gt;= x.y
&gt; &gt; 
&gt; &gt; the problem is that humans are fallible and so these versioned
&gt; &gt; dependancies
&gt; &gt; frequently get missed, because package maintainers don't often have
&gt; &gt; accurate
&gt; &gt; info on which min version is needed by a build.
&gt; 
&gt; I agree it's going to be a bit brittle to do that manually. E.g., in
&gt; the
&gt; example at hand, the package source code only used the old
&gt; nettle_hashes
&gt; symbol, but the new version of nettle headers turned that into a
&gt; macro
&gt; calling a new function.

A colleague is working on a script to automate that version script
creation. That tool is on its infancy, but if you find it useful please
send feedback at:
https://github.com/ansasaki/symbol_version

The idea is that if the exported symbols per release can be provided to
the script, it will create the right symbol map file.

regards,
Nikos


</body></email><email><emailId>20180531151718</emailId><senderName>Miroslav Lichvar</senderName><senderEmail>mlichvar@redhat.com</senderEmail><timestampReceived>2018-05-31 15:17:18-0400</timestampReceived><subject>RFC: SIV-CMAC interface [was: API for new AEAD modes]</subject><body>

On Fri, Feb 16, 2018 at 10:17:31AM +0100, Nikos Mavrogiannopoulos wrote:
&gt; Thus, I'm sending an RFC for a high level SIV-CMAC interface with an
&gt; abstraction function set, which abstract on the cipher. The cipher is
&gt; then used for both CTR encryption and CMAC.
&gt; (Initially I tried abstracting over cipher and MAC, which caused a very
&gt; complex interface, such as functions with 13+ parameters).
&gt; 
&gt; That abstraction seems to have a cost on safety as in _siv_s2v()
&gt; function I simulated the cipher context using an array. Is there a
&gt; better way to capture that on nettle?

Is there any feedback on this RFC?

I'd be very interested in the AES-SIV-CMAC support in nettle+gnutls.
It will be needed for authenticating NTP packets using the upcoming
Network Time Security protocol [1], which I'd like to see supported in
the chrony NTP client/server implementation.

[1] https://datatracker.ietf.org/doc/draft-ietf-ntp-using-nts-for-ntp/

-- 
Miroslav Lichvar

</body></email><email><emailId>20180414174706</emailId><senderName>Tim_Rühsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2018-04-14 17:47:06-0400</timestampReceived><subject>https://git.lysator.liu.se/ seems to be offline...</subject><body>



</body></email><email><emailId>20180103183624</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-03 18:36:24-0400</timestampReceived><subject>Re: Performance of AESNI impl vs other crypto libraries</subject><body>

"Daniel P. Berrange" &lt;berrange@redhat.com&gt; writes:

&gt; I wrote a crude/simple test program to compare the performance of
&gt; AES-128-CBC across openssl, gcrypt, nettle and gnutls, and was
&gt; surprised to find that nettle is consistently ~25% slower than
&gt; the other libraries for its AESNI implementation.

I've now pushed new aesni code to the master-updates branch. It reads
all subkeys into registers upfront, and unrolls the round loop. This
brings a great speedup when calling the aes functions with many blocks
at a time, but little difference when doing only one block at a time.
Results for aes128, when benchmarkign on my machine (intel broadwell):

ECB encrypt and decrypt: About 90% speedup, from 1.25 cycles/byte to
0.65, about the same as openssl, or even *slightly* faster.

CBC encrypt: No significant change, about 5.7 cycles/byte.
CBC decrypt: About 60% speedup, from 1,5 cycles/byte down to 0.93.

CTR mode: No significant change, about 2.5 cycles/byte. 

I think it's reasonble to speed up CTR mode by passing more blocks per
call to the encryption function (currently it does 4 blocks at a time),
and maybe by some more efficient routine to generate the counter input.

To improve CBC would need some structural and possibly ugly changes.

For now, I don't have separate assembly functions for aes128, aes192 and
aes256, and I've tried to organize it so that aes128 gets the least
penalty for this generality. See
https://git.lysator.liu.se/nettle/nettle/blob/master-updates/x86_64/aesni/aes-encrypt-internal.asm

I wonder if there are any chips that can execute two independent aesenc
instructions in parallel? If so, it would be pretty straight forward to
do two blocks at a time in parallel, doubling the speed for aes128 and
aes192 (for aes256, we don't have enough registers for all 15 subkeys
and two blocks of data).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180103094452</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-01-03 09:44:52-0400</timestampReceived><subject>Re: [PATCH v3 0/1] Add Cipher FeedBack mode support</subject><body>

On Sat, Oct 7, 2017 at 8:55 PM, Dmitry Eremin-Solenikov
&lt;dbaryshkov@gmail.com&gt; wrote:
&gt; Add CFB mode support. CFB uses segment size = block size.
&gt; 
&gt; Changes since V2:
&gt; 
&gt; - Dropped CFB8, isn't widely used.

I'm getting late into this discussion, but it seems that samba (which
uses nettle and gnutls), could benefit from an 8-bit CFB mode as well.
They are already implementing it on top of nettle, and it is being
used on the newer samba versions:

https://git.samba.org/?p=samba.git;a=blob;f=lib/crypto/REQUIREMENTS;h=351c2bb99b4d760aeaf47ef47b3a489187f60488;hb=refs/heads/master


regards,
Nikos


</body></email><email><emailId>20180312184942</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-12 18:49:42-0400</timestampReceived><subject>Re: Deleting old AES api</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; #ifdef __GNUC__
&gt; # define _GNUTLS_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 +
&gt; __GNUC_PATCHLEVEL__)
&gt;
&gt; # if _GNUTLS_GCC_VERSION &gt;= 30100
&gt; #  define _GNUTLS_GCC_ATTR_DEPRECATED __attribute__ ((__deprecated__))
&gt; # endif
&gt; #endif

That means that __attribute__ ((__deprecated__)) was introduced in
gcc-3.1 ? Is that documented somewhere? I find no mention in
https://gcc.gnu.org/gcc-3.1/changes.html.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180312185616</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2018-03-12 18:56:16-0400</timestampReceived><subject>Re: Deleting old AES api</subject><body>

On Mon, Mar 12, 2018 at 2:49 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt;
&gt;&gt; #ifdef __GNUC__
&gt;&gt; # define _GNUTLS_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 +
&gt;&gt; __GNUC_PATCHLEVEL__)
&gt;&gt;
&gt;&gt; # if _GNUTLS_GCC_VERSION &gt;= 30100
&gt;&gt; #  define _GNUTLS_GCC_ATTR_DEPRECATED __attribute__ ((__deprecated__))
&gt;&gt; # endif
&gt;&gt; #endif
&gt;
&gt; That means that __attribute__ ((__deprecated__)) was introduced in
&gt; gcc-3.1 ? Is that documented somewhere? I find no mention in
&gt; https://gcc.gnu.org/gcc-3.1/changes.html.

I believe the versions for '__attribute__((deprecated (msg)))' are:

    * GCC 4.5
    * LLVM Clang 2.8
    * Apple Clang 4.2

There is a version without 'msg' that has been around since the GCC 3
days. But I can't find it either. If the 'msg' version is not
available you are usually safe to fall back to the non-msg version
with GCC. I've never seen the non-msg version break a compile.

Jeff

</body></email><email><emailId>20180104075611</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-01-04 07:56:11-0400</timestampReceived><subject>Re: Performance of AESNI impl vs other crypto libraries</subject><body>

On Wed, Jan 3, 2018 at 7:36 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; wr=
ote:
&gt; "Daniel P. Berrange" &lt;berrange@redhat.com&gt; writes:
&gt;
&gt;&gt; I wrote a crude/simple test program to compare the performance of
&gt;&gt; AES-128-CBC across openssl, gcrypt, nettle and gnutls, and was
&gt;&gt; surprised to find that nettle is consistently ~25% slower than
&gt;&gt; the other libraries for its AESNI implementation.
&gt;
&gt; I've now pushed new aesni code to the master-updates branch. It reads
&gt; all subkeys into registers upfront, and unrolls the round loop. This
&gt; brings a great speedup when calling the aes functions with many blocks
&gt; at a time, but little difference when doing only one block at a time.
&gt; Results for aes128, when benchmarkign on my machine (intel broadwell):
&gt;
&gt; ECB encrypt and decrypt: About 90% speedup, from 1.25 cycles/byte to
&gt; 0.65, about the same as openssl, or even *slightly* faster.

That's great news.

&gt; CBC encrypt: No significant change, about 5.7 cycles/byte.
&gt; CBC decrypt: About 60% speedup, from 1,5 cycles/byte down to 0.93.
&gt;
&gt; CTR mode: No significant change, about 2.5 cycles/byte.
&gt;
&gt; I think it's reasonble to speed up CTR mode by passing more blocks per
&gt; call to the encryption function (currently it does 4 blocks at a time),
&gt; and maybe by some more efficient routine to generate the counter input.
&gt;
&gt; To improve CBC would need some structural and possibly ugly changes.

If I had to chose between optimizing one of two, I'd say CTR. All the
modern AEAD modes (GCM, CCM) use CTR, while CBC is only used as legacy
and backwards compatible mode.

regards,
Nikos

</body></email><email><emailId>20180104131504</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-04 13:15:04-0400</timestampReceived><subject>Re: Performance of AESNI impl vs other crypto libraries</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; If I had to chose between optimizing one of two, I'd say CTR.

I agree CTR seems more important. I'm guessing that the loop

	  for (p = dst, left = length;
	       left &gt;= block_size;
	       left -= block_size, p += block_size)
	    {
	      memcpy (p, ctr, block_size);
	      INCREMENT(block_size, ctr);
	    }

in ctr_crypt contribudes quite a few cycles per byte. It would be faster
to use an always word-aligned area, and do the copying and incrementing
using word operations (and final byteswap when running on a
little-endian platform), and with no intermediate stores.

Would be a pretty simple routine (maybe we don't even need to go to
assembly) if we require that the block size is a multiple of
sizeof(unsigned long), and even simpler if we restrict to block size 16.
But uglier and less efficient, if it needs to support the general case.

Maybe we could have a special case for blocksize 16, and accept that
unusual blocksizes will be much slower. Or could we drop support for all
but the most relevant block sizes here?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180207210339</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-07 21:03:39-0400</timestampReceived><subject>x86 sha_ni</subject><body>

Hi,

I've been trying out the sha_ni instructions available on some newer
x86_64 processors.

Below replacement for sha1-compress.asm seems to run on roughly 2
cycles/byte when I benchmark it on an "AMD Ryzen 7 1700X" cpu in the gcc
compile farm. Still sligthly slower than openssl, to squeeze out a few
more cycles, it might help to change the sha1_compress interface to let
it process more than one 64-byte block at a time.

I hope to be able to wire it up via fat-x86_64.c reasonably soon. In the
mean time, if anyone wants to try it out, just change the
sha1-compress.asm symlink to point to this file.

Regards,
/Niels

-----8&lt;--------

C x86_64/sha_ni/sha1-compress.asm

ifelse(&lt;
   Copyright (C) 2018 Niels Möller

   This file is part of GNU Nettle.

   GNU Nettle is free software: you can redistribute it and/or
   modify it under the terms of either:

     * the GNU Lesser General Public License as published by the Free
       Software Foundation; either version 3 of the License, or (at your
       option) any later version.

   or

     * the GNU General Public License as published by the Free
       Software Foundation; either version 2 of the License, or (at your
       option) any later version.

   or both in parallel, as here.

   GNU Nettle is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received copies of the GNU General Public License and
   the GNU Lesser General Public License along with this program.  If
   not, see http://www.gnu.org/licenses/.
&gt;)

C Register usage.

C Arguments
define(&lt;STATE&gt;,&lt;%rdi&gt;)dnl
define(&lt;INPUT&gt;,&lt;%rsi&gt;)dnl

define(&lt;MSG0&gt;,&lt;%xmm0&gt;)
define(&lt;MSG1&gt;,&lt;%xmm1&gt;)
define(&lt;MSG2&gt;,&lt;%xmm2&gt;)
define(&lt;MSG3&gt;,&lt;%xmm3&gt;)
define(&lt;ABCD&gt;,&lt;%xmm4&gt;)
define(&lt;E0&gt;,&lt;%xmm5&gt;)
define(&lt;E1&gt;,&lt;%xmm6&gt;)
define(&lt;ABCD_ORIG&gt;, &lt;%xmm7&gt;)
define(&lt;E_ORIG&gt;, &lt;%xmm8&gt;)
define(&lt;SWAP_MASK&gt;,&lt;%xmm9&gt;)

C QROUND(M0, M1, M2, M3, E0, E1, TYPE)
define(&lt;QROUND&gt;, &lt;
	sha1nexte $1, $5
	movdqa	ABCD, $6
	sha1msg2 $1, $2
	sha1rnds4 &lt;$&gt;$7, $5, ABCD
	sha1msg1 $1, $4
	pxor	$1, $3
&gt;)

	.file "sha1-compress.asm"

	C _nettle_sha1_compress(uint32_t *state, uint8_t *input)

	.text
	ALIGN(16)
.Lswap_mask:
	.byte 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0
PROLOGUE(_nettle_sha1_compress)
	C save all registers that need to be saved
	W64_ENTRY(2, 10)
	movups	(STATE), ABCD
	movd	16(STATE), E0
	movups	(INPUT), MSG0
	movdqa	.Lswap_mask(%rip), SWAP_MASK
	pshufd	$0x1b, ABCD, ABCD
	pshufd	$0x1b, E0, E0
	movdqa	ABCD, ABCD_ORIG
	movdqa	E0, E_ORIG
	pshufb	SWAP_MASK, MSG0

	paddd	MSG0, E0
	movdqa	ABCD, E1
	sha1rnds4 $0, E0, ABCD	C Rounds 0-3

	movups	16(INPUT), MSG1
	pshufb	SWAP_MASK, MSG1

	sha1nexte MSG1, E1
	movdqa	ABCD, E0
	sha1rnds4 $0, E1, ABCD	C Rounds 4-7
	sha1msg1 MSG1, MSG0

	movups	32(INPUT), MSG2
	pshufb	SWAP_MASK, MSG2

	sha1nexte MSG2, E0
	movdqa	ABCD, E1
	sha1rnds4 $0, E0, ABCD	C Rounds 8-11
	sha1msg1 MSG2, MSG1
	pxor	MSG2, MSG0

	movups	48(INPUT), MSG3
	pshufb	SWAP_MASK, MSG3

	QROUND(MSG3, MSG0, MSG1, MSG2, E1, E0, 0)	C Rounds 12-15
	QROUND(MSG0, MSG1, MSG2, MSG3, E0, E1, 0)	C Rounds 16-19

	QROUND(MSG1, MSG2, MSG3, MSG0, E1, E0, 1)	C Rounds 20-23
	QROUND(MSG2, MSG3, MSG0, MSG1, E0, E1, 1)	C Rounds 24-27
	QROUND(MSG3, MSG0, MSG1, MSG2, E1, E0, 1)	C Rounds 28-31
	QROUND(MSG0, MSG1, MSG2, MSG3, E0, E1, 1)	C Rounds 32-35
	QROUND(MSG1, MSG2, MSG3, MSG0, E1, E0, 1)	C Rounds 36-39

	QROUND(MSG2, MSG3, MSG0, MSG1, E0, E1, 2)	C Rounds 40-43
	QROUND(MSG3, MSG0, MSG1, MSG2, E1, E0, 2)	C Rounds 44-47
	QROUND(MSG0, MSG1, MSG2, MSG3, E0, E1, 2)	C Rounds 48-51
	QROUND(MSG1, MSG2, MSG3, MSG0, E1, E0, 2)	C Rounds 52-55
	QROUND(MSG2, MSG3, MSG0, MSG1, E0, E1, 2)	C Rounds 56-59

	QROUND(MSG3, MSG0, MSG1, MSG2, E1, E0, 3)	C Rounds 60-63
	QROUND(MSG0, MSG1, MSG2, MSG3, E0, E1, 3)	C Rounds 64-67

	sha1nexte MSG1, E1
	movdqa	ABCD, E0
	sha1msg2 MSG1, MSG2
	sha1rnds4 $3, E1, ABCD	C Rounds 68-71
	pxor	MSG1, MSG3

	sha1nexte MSG2, E0
	movdqa	ABCD, E1
	sha1msg2 MSG2, MSG3
	sha1rnds4 $3, E0, ABCD	C Rounds 72-75

	sha1nexte MSG3, E1
	movdqa	ABCD, E0
	sha1rnds4 $3, E1, ABCD	C Rounds 76-79

	sha1nexte E_ORIG, E0
	paddd	ABCD_ORIG, ABCD

	pshufd	$0x1b, ABCD, ABCD
	movups	ABCD, (STATE)
	pshufd	$0x1b, E0, E0
	movd	E0, 16(STATE)

	W64_EXIT(2, 10)
	ret
EPILOGUE(_nettle_sha1_compress)

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20180208171805</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-08 17:18:05-0400</timestampReceived><subject>Re: x86 sha_ni</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Below replacement for sha1-compress.asm seems to run on roughly 2
&gt; cycles/byte when I benchmark it on an "AMD Ryzen 7 1700X" cpu in the gcc
&gt; compile farm. Still sligthly slower than openssl, to squeeze out a few
&gt; more cycles, it might help to change the sha1_compress interface to let
&gt; it process more than one 64-byte block at a time.
&gt;
&gt; I hope to be able to wire it up via fat-x86_64.c reasonably soon. In the
&gt; mean time, if anyone wants to try it out, just change the
&gt; sha1-compress.asm symlink to point to this file.

Enabled via fat-x86_64 now, and pushed to a branch named
x86_64-sha_ni-sha1.

I intend to merge to master soon.

Testing and benchmarking appreciated.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180208221505</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-08 22:15:05-0400</timestampReceived><subject>Re: x86 sha_ni</subject><body>

Jeffrey Walton &lt;noloader@gmail.com&gt; writes:

&gt; Looks good on a Celeron J3455, which is a [low-end] Goldmont machine
&gt; with the instructions:

[...]

&gt; goldmont:nettle$ LD_LIBRARY_PATH=.lib:/usr/local/lib64/
&gt; ./examples/nettle-benchmark
&gt; sha1_compress: 84.60 cycles

85 cycles is a lot less than than 136 cycles I observed in my testing.
The function is 131 instructions long, so it's approximately 1.5
instructions per cycle.

&gt;               sha1       update 1194.33
&gt;       openssl sha1       update 1321.71

And this is a 11% difference (compared to 8% in my benckmarks). Makes
sense if the main crunching is fewer cycles, then the per block function
call overhead is relatively larger.

&gt; A small suggestion may be to update Section 8 Installation
&gt; (https://www.lysator.liu.se/~nisse/nettle/nettle.html). It was not
&gt; obvious to me how to enable the hardware acceleration.

There's an --enable-x86-aesni configure option which should enable the
aesni code unconditionally in non-fat builds. And an --enable-arm-neon.
But it seems I forgot to add a corresponding --enable-x86-sha-ni.

But --enable-fat is the most common way to enable the support. I'm
considering enabling it by default in the next release.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180208222847</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2018-02-08 22:28:47-0400</timestampReceived><subject>Re: x86 sha_ni</subject><body>

On Thu, Feb 8, 2018 at 5:15 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Jeffrey Walton &lt;noloader@gmail.com&gt; writes:
&gt;
&gt;&gt; Looks good on a Celeron J3455, which is a [low-end] Goldmont machine
&gt;&gt; with the instructions:
&gt;
&gt; [...]
&gt;
&gt;&gt; goldmont:nettle$ LD_LIBRARY_PATH=.lib:/usr/local/lib64/
&gt;&gt; ./examples/nettle-benchmark
&gt;&gt; sha1_compress: 84.60 cycles
&gt;
&gt; 85 cycles is a lot less than than 136 cycles I observed in my testing.
&gt; The function is 131 instructions long, so it's approximately 1.5
&gt; instructions per cycle.
&gt;
&gt;&gt;               sha1       update 1194.33
&gt;&gt;       openssl sha1       update 1321.71
&gt;
&gt; And this is a 11% difference (compared to 8% in my benckmarks). Makes
&gt; sense if the main crunching is fewer cycles, then the per block function
&gt; call overhead is relatively larger.

I think this might be explained by root access. I can put the Celeron
in performance mode. Using
https://github.com/weidai11/cryptopp/blob/master/TestScripts/governor.sh
(based on a script by Andy Polyakov):

$ sudo ./governor.sh perf
Current CPU governor scaling settings:
  CPU 0: powersave
  CPU 1: powersave
  CPU 2: powersave
  CPU 3: powersave
New CPU governor scaling settings:
  CPU 0: performance
  CPU 1: performance
  CPU 2: performance
  CPU 3: performance

The benchmarks are then performed using the new governor scaling,
which I believe is max freq.

&gt;&gt; A small suggestion may be to update Section 8 Installation
&gt;&gt; (https://www.lysator.liu.se/~nisse/nettle/nettle.html). It was not
&gt;&gt; obvious to me how to enable the hardware acceleration.
&gt;
&gt; There's an --enable-x86-aesni configure option which should enable the
&gt; aesni code unconditionally in non-fat builds. And an --enable-arm-neon.
&gt; But it seems I forgot to add a corresponding --enable-x86-sha-ni.
&gt;
&gt; But --enable-fat is the most common way to enable the support. I'm
&gt; considering enabling it by default in the next release.

+1.

Jeff

</body></email><email><emailId>20180312184015</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-12 18:40:15-0400</timestampReceived><subject>Re: x86 sha_ni</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt; I've been trying out the sha_ni instructions available on some newer
&gt;&gt; x86_64 processors.
&gt;
&gt; And now that the gcc67 machine is up again, I got my sha256
&gt; implementation working too. Pushed to branch x86_64-sha_ni-sha256.
&gt;
&gt; Not yet wired up in fat builds, but can be tested with
&gt; --enable-x86-sha-ni to configure.

Now wired up for fat builds, changes pushed to the same branch.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180312193400</emailId><senderName>Amos Jeffries</senderName><senderEmail>squid3@treenet.co.nz</senderEmail><timestampReceived>2018-03-12 19:34:00-0400</timestampReceived><subject>Re: x86 sha_ni</subject><body>

On 13/03/18 07:40, Niels Möller wrote:
&gt; nisse (Niels Möller) writes:
&gt; 
&gt;&gt; nisse (Niels Möller) writes:
&gt;&gt;
&gt;&gt;&gt; I've been trying out the sha_ni instructions available on some newer
&gt;&gt;&gt; x86_64 processors.
&gt;&gt;
&gt;&gt; And now that the gcc67 machine is up again, I got my sha256
&gt;&gt; implementation working too. Pushed to branch x86_64-sha_ni-sha256.
&gt;&gt;
&gt;&gt; Not yet wired up in fat builds, but can be tested with
&gt;&gt; --enable-x86-sha-ni to configure.
&gt; 
&gt; Now wired up for fat builds, changes pushed to the same branch.
&gt; 
&gt; Regards,
&gt; /Niels
&gt; 

I have a new machine with Intel KabyLake CPU + GPU which apparently has
AES and related crypto support available. Running Debian sid with GCC-6,
7, and 8 all available.

Is there anything you would like in the way of tests or benchmarking
done with this hardware and environment?
Just let me know what build and/or test commands you want run, and on
which git branch.

AYJ

</body></email><email><emailId>20180312201746</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-12 20:17:46-0400</timestampReceived><subject>Re: x86 sha_ni</subject><body>

Amos Jeffries &lt;squid3@treenet.co.nz&gt; writes:

&gt; Is there anything you would like in the way of tests or benchmarking
&gt; done with this hardware and environment?
&gt; Just let me know what build and/or test commands you want run, and on
&gt; which git branch.

It would be nice if you could verify the code on branch
x86_64-sha_ni-sha256. Build with and without --enable-fat (and if you
don't want to mess with setting LD_LIBRARY_PATH=.lib, I'd recommend also
using --disable-shared).

Run make check and 

NETTLE_FAT_VERBOSE=1 ./examples/nettle-benchmark

and see if results look right (NETTLE_FAT_VERBOSE, naturally has effect
only in fat builds).

If you like, also compare the performance with the nettle-3.4 release.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180312202359</emailId><senderName>Amos Jeffries</senderName><senderEmail>squid3@treenet.co.nz</senderEmail><timestampReceived>2018-03-12 20:23:59-0400</timestampReceived><subject>Re: x86 sha_ni</subject><body>

On 13/03/18 08:44, Jeffrey Walton wrote:
&gt; Check /proc/cpuinfo for the sha_ni flag. If present, then you can test
&gt; the SHA extensions.
&gt;
&gt; SHA extensions made their debut in Goldmont. They are also available
&gt; in Goldmont+. They were scheduled for one of the lakes but they did
&gt; not make it in.
&gt;
&gt; I have a Goldmont machine for testing SHA but it is a turd. It is a
&gt; Celeron J3455 (https://www.amazon.com/dp/B01LYCDG4H).
&gt;
&gt; Jeff
&gt;

Ah, okay. That Goldmont info matches my /proc/cpuinfo.
No "sha_ni" listed :-(, just the aes-ni instruction set.

AYJ

</body></email><email><emailId>20180312202801</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2018-03-12 20:28:01-0400</timestampReceived><subject>Re: x86 sha_ni</subject><body>

On Mon, Mar 12, 2018 at 2:40 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt; nisse@lysator.liu.se (Niels M=C3=B6ller) writes:
&gt; ...
&gt;
&gt; Now wired up for fat builds, changes pushed to the same branch.

Looks good on a Celeron J3455 (https://www.amazon.com/dp/B01LYCDG4H):

Without --enable-fat

               md2       update    6.88
               md4       update  570.47
               md5       update  383.59
       openssl md5       update  444.94
              sha1       update  238.53
      openssl sha1       update 1323.53
            sha224       update  110.07
            sha256       update  110.25
            sha384       update  173.90
            sha512       update  174.35
        sha512-224       update  174.30
        sha512-256       update  174.08

With --enable-fat

               md2       update    6.89
               md4       update  569.68
               md5       update  382.82
       openssl md5       update  444.76
              sha1       update 1192.25
      openssl sha1       update 1324.47
            sha224       update  494.33
            sha256       update  495.22
            sha384       update  173.87
            sha512       update  174.33

Jeff

</body></email><email><emailId>20180312203028</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2018-03-12 20:30:28-0400</timestampReceived><subject>Re: x86 sha_ni</subject><body>

On Mon, Mar 12, 2018 at 4:23 PM, Amos Jeffries &lt;squid3@treenet.co.nz&gt; wrote:
&gt; On 13/03/18 08:44, Jeffrey Walton wrote:
&gt;&gt; Check /proc/cpuinfo for the sha_ni flag. If present, then you can test
&gt;&gt; the SHA extensions.
&gt;&gt;
&gt;&gt; SHA extensions made their debut in Goldmont. They are also available
&gt;&gt; in Goldmont+. They were scheduled for one of the lakes but they did
&gt;&gt; not make it in.
&gt;&gt;
&gt;&gt; I have a Goldmont machine for testing SHA but it is a turd. It is a
&gt;&gt; Celeron J3455 (https://www.amazon.com/dp/B01LYCDG4H).
&gt;
&gt; Ah, okay. That Goldmont info matches my /proc/cpuinfo.
&gt; No "sha_ni" listed :-(, just the aes-ni instruction set.

Yeah, if I recall correctly, SHA was supposed to be in Kaby Lake. It
looks like it slipped, and SHA was added to the non-turd machines at
Cannon Lake. Also see
https://en.wikipedia.org/wiki/Cannon_Lake_(microarchitecture)

Jeff

</body></email><email><emailId>20180104170219</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-01-04 17:02:19-0400</timestampReceived><subject>Re: Performance of AESNI impl vs other crypto libraries</subject><body>

On Thu, Jan 4, 2018 at 2:15 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt;
&gt;&gt; If I had to chose between optimizing one of two, I'd say CTR.
&gt;
&gt; I agree CTR seems more important. I'm guessing that the loop
&gt;
&gt;           for (p = dst, left = length;
&gt;                left &gt;= block_size;
&gt;                left -= block_size, p += block_size)
&gt;             {
&gt;               memcpy (p, ctr, block_size);
&gt;               INCREMENT(block_size, ctr);
&gt;             }
&gt;
&gt; in ctr_crypt contribudes quite a few cycles per byte. It would be faster
&gt; to use an always word-aligned area, and do the copying and incrementing
&gt; using word operations (and final byteswap when running on a
&gt; little-endian platform), and with no intermediate stores.
&gt;
&gt; Would be a pretty simple routine (maybe we don't even need to go to
&gt; assembly) if we require that the block size is a multiple of
&gt; sizeof(unsigned long), and even simpler if we restrict to block size 16.
&gt; But uglier and less efficient, if it needs to support the general case.
&gt;
&gt; Maybe we could have a special case for blocksize 16, and accept that
&gt; unusual blocksizes will be much slower. Or could we drop support for all
&gt; but the most relevant block sizes here?

I wouldn't expect if anyone uses 3des in CTR mode, but I wouldn't be
surprised by it either.
What about introducing ctr_crypt128() and having it used by CCM, and
EAX? (it seems gcm is not using it anyway)

regards,
Nikos

</body></email><email><emailId>20180104183637</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-04 18:36:37-0400</timestampReceived><subject>Re: Performance of AESNI impl vs other crypto libraries</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; I wouldn't expect if anyone uses 3des in CTR mode, but I wouldn't be
&gt; surprised by it either.

It's in the ssh specs, with "recommended" status. See RFC 4344. I'd
guess it's rarely used, though.

Back to AESNI, I've now pushed the change to the master branch. It would
be interesting with some benchmarks on other machines than mine.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180104204300</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-01-04 20:43:00-0400</timestampReceived><subject>Re: Performance of AESNI impl vs other crypto libraries</subject><body>

Hello,

2018-01-04 21:36 GMT+03:00 Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt;
&gt;&gt; I wouldn't expect if anyone uses 3des in CTR mode, but I wouldn't be
&gt;&gt; surprised by it either.
&gt;
&gt; It's in the ssh specs, with "recommended" status. See RFC 4344. I'd
&gt; guess it's rarely used, though.
&gt;
&gt; Back to AESNI, I've now pushed the change to the master branch. It would
&gt; be interesting with some benchmarks on other machines than mine.

I'm attaching log on my i3-4005U @ 1.6GHz box.

BTW: it might be interesting to enable 'fat' binaries by default. Otherwise
distributions might easily built nettle w/o optimized function versions.

-- 
With best wishes
Dmitry

["aes.log" (text/x-log)]

sha1_compress: 457.70 cycles
salsa20_core: 403.80 cycles
sha3_permute: 1840.70 cycles (76.70 / round)

benchmark call overhead: 0.003147 us   5.03 cycles

         Algorithm        mode Mbyte/s cycles/byte cycles/block
      poly1305-aes      update  948.37        1.61      1647.57

            aes128 ECB encrypt 2073.64        0.74        11.77
            aes128 ECB decrypt 2311.80        0.66        10.56
            aes128 CBC encrypt  264.57        5.77        92.28
            aes128 CBC decrypt 1581.36        0.96        15.44
            aes128         CTR  541.75        2.82        45.07

            aes192 ECB encrypt 1617.96        0.94        15.09
            aes192 ECB decrypt 1727.50        0.88        14.13
            aes192 CBC encrypt  231.42        6.59       105.50
            aes192 CBC decrypt 1310.68        1.16        18.63
            aes192         CTR  564.71        2.70        43.23

            aes256 ECB encrypt 1458.93        1.05        16.73
            aes256 ECB decrypt 1423.67        1.07        17.15
            aes256 CBC encrypt  204.05        7.48       119.65
            aes256 CBC decrypt 1077.16        1.42        22.67
            aes256         CTR  537.63        2.84        45.41

    openssl aes128 ECB encrypt 2284.86        0.67        10.69
    openssl aes128 ECB decrypt 2113.66        0.72        11.55

    openssl aes192 ECB encrypt 1844.14        0.83        13.24
    openssl aes192 ECB decrypt 1898.40        0.80        12.86

    openssl aes256 ECB encrypt 1649.87        0.92        14.80
    openssl aes256 ECB decrypt 1666.01        0.92        14.65

        gcm_aes128     encrypt  122.46       12.46       199.37
        gcm_aes128     decrypt  122.38       12.47       199.49
        gcm_aes128      update  240.65        6.34       101.45

        gcm_aes192     encrypt  113.77       13.41       214.58
        gcm_aes192     decrypt  114.59       13.32       213.05
        gcm_aes192      update  233.10        6.55       104.74

        gcm_aes256     encrypt  105.91       14.41       230.52
        gcm_aes256     decrypt  106.66       14.31       228.90
        gcm_aes256      update  236.71        6.45       103.14

openssl gcm_aes128     encrypt 1476.57        1.03        16.53
openssl gcm_aes128     decrypt 1454.30        1.05        16.79
openssl gcm_aes128      update 3613.26        0.42         6.76

openssl gcm_aes192     encrypt 1258.41        1.21        19.40
openssl gcm_aes192     decrypt 1271.49        1.20        19.20
openssl gcm_aes192      update 3609.83        0.42         6.76

openssl gcm_aes256     encrypt 1132.60        1.35        21.56
openssl gcm_aes256     decrypt 1139.72        1.34        21.42
openssl gcm_aes256      update 3674.99        0.42         6.64

        eax_aes128     encrypt  197.66        7.72       123.52
        eax_aes128     decrypt  198.21        7.70       123.18
        eax_aes128      update  288.92        5.28        84.50


</body></email><email><emailId>20180105081633</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-01-05 08:16:33-0400</timestampReceived><subject>Re: Performance of AESNI impl vs other crypto libraries</subject><body>

On Thu, 2018-01-04 at 23:43 +0300, Dmitry Eremin-Solenikov wrote:
&gt; Hello,
&gt; 
&gt; 2018-01-04 21:36 GMT+03:00 Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt; &gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt; &gt; 
&gt; &gt; &gt; I wouldn't expect if anyone uses 3des in CTR mode, but I wouldn't
&gt; &gt; &gt; be
&gt; &gt; &gt; surprised by it either.
&gt; &gt; 
&gt; &gt; It's in the ssh specs, with "recommended" status. See RFC 4344. I'd
&gt; &gt; guess it's rarely used, though.
&gt; &gt; 
&gt; &gt; Back to AESNI, I've now pushed the change to the master branch. It
&gt; &gt; would
&gt; &gt; be interesting with some benchmarks on other machines than mine.
&gt; 
&gt; I'm attaching log on my i3-4005U @ 1.6GHz box.

Attached also my log for Intel i7-5600U @ 2.60GHz

regards,
Nikos

</body></email><email><emailId>20180109072911</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-09 07:29:11-0400</timestampReceived><subject>Re: Performance of AESNI impl vs other crypto libraries</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I agree CTR seems more important. I'm guessing that the loop
&gt;
&gt; 	  for (p = dst, left = length;
&gt; 	       left &gt;= block_size;
&gt; 	       left -= block_size, p += block_size)
&gt; 	    {
&gt; 	      memcpy (p, ctr, block_size);
&gt; 	      INCREMENT(block_size, ctr);
&gt; 	    }
&gt;
&gt; in ctr_crypt contribudes quite a few cycles per byte. It would be faster
&gt; to use an always word-aligned area, and do the copying and incrementing
&gt; using word operations (and final byteswap when running on a
&gt; little-endian platform), and with no intermediate stores.

I've tried this, with special code for block size 16. (Without any
assembly, but using __builtin_bswap64). Pushed to the ctr-opt branch.
Gives a nice speedup. On my machine:

Nettle-3.4:

         Algorithm         mode Mbyte/s cycles/byte cycles/block

            aes128  ECB encrypt 1589.75        1.26        20.16
            aes128  ECB decrypt 1642.91        1.22        19.50
            aes128  CBC encrypt  354.43        5.65        90.41
            aes128  CBC decrypt 1519.10        1.32        21.09
            aes128   (in-place) 1338.70        1.50        23.94
            aes128          CTR  727.24        2.75        44.06
            aes128   (in-place)  774.78        2.58        41.36

master branch:

         Algorithm         mode Mbyte/s cycles/byte cycles/block

            aes128  ECB encrypt 3143.18        0.64        10.19
            aes128  ECB decrypt 3159.88        0.63        10.14
            aes128  CBC encrypt  351.37        5.70        91.20
            aes128  CBC decrypt 2726.47        0.73        11.75
            aes128   (in-place) 2131.99        0.94        15.03
            aes128          CTR  970.08        2.06        33.03
            aes128   (in-place)  796.31        2.51        40.24

ctr-opt branch:

         Algorithm         mode Mbyte/s cycles/byte cycles/block

            aes128  ECB encrypt 3159.18        0.63        10.14
            aes128  ECB decrypt 3159.82        0.63        10.14
            aes128  CBC encrypt  351.80        5.69        91.08
            aes128  CBC decrypt 2723.80        0.74        11.76
            aes128   (in-place) 2156.27        0.93        14.86
            aes128          CTR 1778.84        1.13        18.01
            aes128   (in-place) 1550.39        1.29        20.67

Which means that aes128-ctr is twice as fast as in 3.4.

If anyone has a big-endian machine handy, it would be nice with
additional testing for both correctness and performance (I have access
to a few virtual machines with non-x86 architectures, where I can test
this before merging to the master branch, but that's not so useful for
benchmarking).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180109081746</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-01-09 08:17:46-0400</timestampReceived><subject>Re: Performance of AESNI impl vs other crypto libraries</subject><body>

On Tue, 2018-01-09 at 08:29 +0100, Niels Möller wrote:
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt; &gt; I agree CTR seems more important. I'm guessing that the loop
&gt; &gt; 
&gt; &gt; 	  for (p = dst, left = length;
&gt; &gt; 	       left &gt;= block_size;
&gt; &gt; 	       left -= block_size, p += block_size)
&gt; &gt; 	    {
&gt; &gt; 	      memcpy (p, ctr, block_size);
&gt; &gt; 	      INCREMENT(block_size, ctr);
&gt; &gt; 	    }
&gt; &gt; 
&gt; &gt; in ctr_crypt contribudes quite a few cycles per byte. It would be
&gt; &gt; faster
&gt; &gt; to use an always word-aligned area, and do the copying and
&gt; &gt; incrementing
&gt; &gt; using word operations (and final byteswap when running on a
&gt; &gt; little-endian platform), and with no intermediate stores.
&gt; 
&gt; I've tried this, with special code for block size 16. (Without any
&gt; assembly, but using __builtin_bswap64). Pushed to the ctr-opt branch.
&gt; Gives a nice speedup. On my machine:

I see a quite large speedup on my x86_64 too on CTR. Note however that
GCM performance is not affected.

regards,
Nikos


</body></email><email><emailId>20180130191607</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-01-30 19:16:07-0400</timestampReceived><subject>Re: Performance of AESNI impl vs other crypto libraries</subject><body>

On Tue, 2018-01-09 at 09:17 +0100, Nikos Mavrogiannopoulos wrote:

&gt; &gt; &gt; in ctr_crypt contribudes quite a few cycles per byte. It would be
&gt; &gt; &gt; faster
&gt; &gt; &gt; to use an always word-aligned area, and do the copying and
&gt; &gt; &gt; incrementing
&gt; &gt; &gt; using word operations (and final byteswap when running on a
&gt; &gt; &gt; little-endian platform), and with no intermediate stores.
&gt; &gt; 
&gt; &gt; I've tried this, with special code for block size 16. (Without any
&gt; &gt; assembly, but using __builtin_bswap64). Pushed to the ctr-opt
&gt; &gt; branch.
&gt; &gt; Gives a nice speedup. On my machine:
&gt; 
&gt; I see a quite large speedup on my x86_64 too on CTR. Note however
&gt; that GCM performance is not affected.

To follow up on this, gcm would get an 8% (on my system) speedup by
switching gcm_crypt() with ctr_crypt(). With that change as is however,
 the 32-bit counter is replaced with an "unlimited" counter. Wouldn't
introducing an assert on decrypt and encrypt length be sufficient to
share that code?

regards,
Nikos

["gcm.patch" (gcm.patch)]

diff --git a/gcm.c b/gcm.c
index 0a2102f1..1b1c077a 100644
--- a/gcm.c
+++ b/gcm.c
@@ -51,6 +51,7 @@
 #include "memxor.h"
 #include "nettle-internal.h"
 #include "macros.h"
+#include "ctr.h"
 
 #define GHASH_POLYNOMIAL 0xE1UL
 
@@ -434,43 +435,6 @@ gcm_update(struct gcm_ctx *ctx, const struct gcm_key *key,
   ctx-&gt;auth_size += length;
 }
 
-static void
-gcm_crypt(struct gcm_ctx *ctx, const void *cipher, nettle_cipher_func *f,
-	  size_t length, uint8_t *dst, const uint8_t *src)
-{
-  uint8_t buffer[GCM_BLOCK_SIZE];
-
-  if (src != dst)
-    {
-      for (; length &gt;= GCM_BLOCK_SIZE;
-           (length -= GCM_BLOCK_SIZE,
-	    src += GCM_BLOCK_SIZE, dst += GCM_BLOCK_SIZE))
-        {
-          f (cipher, GCM_BLOCK_SIZE, dst, ctx-&gt;ctr.b);
-          memxor (dst, src, GCM_BLOCK_SIZE);
-          INC32 (ctx-&gt;ctr);
-        }
-    }
-  else
-    {
-      for (; length &gt;= GCM_BLOCK_SIZE;
-           (length -= GCM_BLOCK_SIZE,
-	    src += GCM_BLOCK_SIZE, dst += GCM_BLOCK_SIZE))
-        {
-          f (cipher, GCM_BLOCK_SIZE, buffer, ctx-&gt;ctr.b);
-          memxor (dst, buffer, GCM_BLOCK_SIZE);
-          INC32 (ctx-&gt;ctr);
-        }
-    }
-  if (length &gt; 0)
-    {
-      /* A final partial block */
-      f (cipher, GCM_BLOCK_SIZE, buffer, ctx-&gt;ctr.b);
-      memxor3 (dst, src, buffer, length);
-      INC32 (ctx-&gt;ctr);
-    }
-}
-
 void
 gcm_encrypt (struct gcm_ctx *ctx, const struct gcm_key *key,
 	     const void *cipher, nettle_cipher_func *f,
@@ -478,7 +442,7 @@ gcm_encrypt (struct gcm_ctx *ctx, const struct gcm_key *key,
 {
   assert(ctx-&gt;data_size % GCM_BLOCK_SIZE == 0);
 
-  gcm_crypt(ctx, cipher, f, length, dst, src);
+  ctr_crypt(cipher, f, GCM_BLOCK_SIZE, ctx-&gt;ctr.b, length, dst, src);
   gcm_hash(key, &amp;ctx-&gt;x, length, dst);
 
   ctx-&gt;data_size += length;
@@ -492,7 +456,7 @@ gcm_decrypt(struct gcm_ctx *ctx, const struct gcm_key *key,
   assert(ctx-&gt;data_size % GCM_BLOCK_SIZE == 0);
 
   gcm_hash(key, &amp;ctx-&gt;x, length, src);
-  gcm_crypt(ctx, cipher, f, length, dst, src);
+  ctr_crypt(cipher, f, GCM_BLOCK_SIZE, ctx-&gt;ctr.b, length, dst, src);
 
   ctx-&gt;data_size += length;
 }


</body></email><email><emailId>20180130195734</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-30 19:57:34-0400</timestampReceived><subject>Re: Performance of AESNI impl vs other crypto libraries</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; To follow up on this, gcm would get an 8% (on my system) speedup by
&gt; switching gcm_crypt() with ctr_crypt(). With that change as is however,
&gt;  the 32-bit counter is replaced with an "unlimited" counter. Wouldn't
&gt; introducing an assert on decrypt and encrypt length be sufficient to
&gt; share that code?

I think it's valid to use gcm with an IV which makes the 32-bit counter
start close to 2^32 - 1, and then propagating carry further then 32 bits
would produce incorrect results. Right? (I'm afraid there's no test case
for that, though).

I agree it would be very nice to reuse ctr_crypt and not duplicate most
of the logic. But I think we need a gcm-specific variant of ctr_fill. To
do that, it would make sense to add a field

 uint32_t u32[4];

to the nettle_block16 union.

To reduce code duplication, we could add a fill function pointer as
argument to ctr_crypt16, and use that for gcm. Not sure if that's a good
idea, but it might be nice and clean and indirect call to the fill
function should be negligible.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180201102115</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-01 10:21:15-0400</timestampReceived><subject>Re: Performance of AESNI impl vs other crypto libraries</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; It seems that ctr_crypt16() would not handle the whole input and that
&gt; was complicating things.

I was afraid of that. Doing the extra block would be something like

  done = ctr_crypt16(cipher, f, gcm_fill, ctx-&gt;ctr.b, length, dst, src);
  if (done &lt; length) 
    { 
      uint8_t block[16];
      assert (done % 16 == 0);
      assert (length - done &lt; 16);
      f(ctx, block, ctx-&gt;ctr.b, 16, 16);
      memxor3(dst + done, src + done, block, length - done);
    }

(if we skip updating the counter in this case; I don't think gcm
promises anything about the counter after a partial block).

But I agree it makes sense to let ctr_crypt16 do that.

More detailed comments later.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180310180420</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-10 18:04:20-0400</timestampReceived><subject>Improved ECC tables</subject><body>

Nettle uses precomputed tables for ecc scalar multiplication involving
the fixed base point. I've found that parameters for those tables were
somewhat poorly chosen.

Updated parameters just pushed to branch ecc-params-tweak. The size of
the tables is unchanged (except for the 192-bit curve, where they are
reduced from 15 KB to 12 KB). In my benchmarking, 10%-15% speedup of
ecdsa with the 256-, 384- and 521-bit curves, and 24% speedup of
eddsa25519 (all for the signature operation, changes for the verify
operation are more modest).

I target table sizes of around 16 KB per curve. Would it be useful with
a configure option to use smaller or larger table size? For the larger
curves, one could perhaps get an additional 50% speedup with
considerable larger curves. (But due to the requirements for
side-channel silence, huge tables are impractical, since each access
reads the entire table.)

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20180312191041</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2018-03-12 19:10:41-0400</timestampReceived><subject>Re: Deleting old AES api</subject><body>

On Mon, Mar 12, 2018 at 2:56 PM, Jeffrey Walton &lt;noloader@gmail.com&gt; wrote:
&gt; On Mon, Mar 12, 2018 at 2:49 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt;&gt;
&gt;&gt;&gt; #ifdef __GNUC__
&gt;&gt;&gt; # define _GNUTLS_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 +
&gt;&gt;&gt; __GNUC_PATCHLEVEL__)
&gt;&gt;&gt;
&gt;&gt;&gt; # if _GNUTLS_GCC_VERSION &gt;= 30100
&gt;&gt;&gt; #  define _GNUTLS_GCC_ATTR_DEPRECATED __attribute__ ((__deprecated__))
&gt;&gt;&gt; # endif
&gt;&gt;&gt; #endif
&gt;&gt;
&gt;&gt; That means that __attribute__ ((__deprecated__)) was introduced in
&gt;&gt; gcc-3.1 ? Is that documented somewhere? I find no mention in
&gt;&gt; https://gcc.gnu.org/gcc-3.1/changes.html.
&gt;
&gt; I believe the versions for '__attribute__((deprecated (msg)))' are:
&gt;
&gt;     * GCC 4.5
&gt;     * LLVM Clang 2.8
&gt;     * Apple Clang 4.2
&gt;
&gt; There is a version without 'msg' that has been around since the GCC 3
&gt; days....

Here it is. It first surfaces in the GCC 3.1.1 manual:
https://gcc.gnu.org/onlinedocs/gcc-3.1.1/gcc/Function-Attributes.html#Function%20Attributes

It is missing from the 2.95 and 3.0.4 manuals.

Jeff

</body></email><email><emailId>20180312211217</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-12 21:12:17-0400</timestampReceived><subject>Re: x86 sha_ni</subject><body>

Jeffrey Walton &lt;noloader@gmail.com&gt; writes:

&gt; On Mon, Mar 12, 2018 at 2:40 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;&gt; ...
&gt;&gt;
&gt;&gt; Now wired up for fat builds, changes pushed to the same branch.
&gt;
&gt; Looks good on a Celeron J3455 (https://www.amazon.com/dp/B01LYCDG4H):
&gt;
&gt; Without --enable-fat
&gt;
&gt;                md2       update    6.88
&gt;                md4       update  570.47
&gt;                md5       update  383.59
&gt;        openssl md5       update  444.94
&gt;               sha1       update  238.53
&gt;       openssl sha1       update 1323.53
&gt;             sha224       update  110.07
&gt;             sha256       update  110.25
&gt;             sha384       update  173.90
&gt;             sha512       update  174.35
&gt;         sha512-224       update  174.30
&gt;         sha512-256       update  174.08
&gt;
&gt; With --enable-fat
&gt;
&gt;                md2       update    6.89
&gt;                md4       update  569.68
&gt;                md5       update  382.82
&gt;        openssl md5       update  444.76
&gt;               sha1       update 1192.25
&gt;       openssl sha1       update 1324.47
&gt;             sha224       update  494.33
&gt;             sha256       update  495.22
&gt;             sha384       update  173.87
&gt;             sha512       update  174.33

So you get 5 times speedup of sha1 and 4.5 times for sha256. Nice!

On gcc67 (AMD Ryzen 5 2400G), I measure 3 times and 4.8 times speedup,
respectively.

Now, I think there are opportunities for improvements also for sha1 and
sha256 without sha_ni, but that's a more difficult project, to carefully
take data dependencies into account, and deal with hard-to-predict x86
scheduling.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180313194955</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-13 19:49:55-0400</timestampReceived><subject>Efficient ED25519 on microcontrollers</subject><body>

This is vaguely related to Nettle, but may be of interest to some people
on the list. I've tried to summarize how to implement ed25519
efficiently on low-end hardware, with MSP430 as a concrete example. Most
of the tricks are used by Nettle's implementation as well.

Not sure if it would make any sense to try to port Nettle to such
systems, but might be doable if there's interest in it. I would imagine
that the need for good crypto on cheap devices is only going to increase
in coming years.

See https://www.lysator.liu.se/~nisse/misc/ed25519-msp430.html.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20180320060946</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-03-20 06:09:46-0400</timestampReceived><subject>Re: mailing list archives</subject><body>

On Mon, 2018-03-19 at 22:44 +0100, Niels Möller wrote:
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt; &gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt; &gt; 
&gt; &gt; &gt;   On certain occasions I was trying to link to posts in that list
&gt; &gt; &gt; however it seems that the official archives are not updated on a
&gt; &gt; &gt; reasonable frequency.
&gt; &gt; 
&gt; &gt; Thanks for the reminder. I've asked the volunteers maintaining the
&gt; &gt; mailinglist infrastructure to have a look.
&gt; 
&gt; Archives have now been regenerated, let me know if the problem
&gt; reappears.
&gt; 

Thank you!


</body></email><email><emailId>20180325195848</emailId><senderName>Michael Weiser</senderName><senderEmail>michael.weiser@gmx.de</senderEmail><timestampReceived>2018-03-25 19:58:48-0400</timestampReceived><subject>Re: [PATCH 1/3] Add arm endianness-aware assembly infrastructure</subject><body>

Hi Niels,

On Sun, Mar 25, 2018 at 11:51:38AM +0200, Niels Möller wrote:

&gt; &gt; Introduce m4 macros to conditionally handle differences of little- and
&gt; &gt; big-endian arm in assembler code.
&gt; This and the next two patches now merged to master-updates for some final
&gt; testing.

&gt; At the moment, I'm only able to test that plain little-endian arm is
&gt; still working.

I have rebased my GitLab fork of the GnuTLS nettle mirror to
master-updates and run it through the work-in-progress Debian- and
Gentoo-based CI builds. The results are here:

https://gitlab.com/michaelweiser/nettle/pipelines/19448987
https://gitlab.com/michaelweiser/nettle/pipelines/19459855

Particularly:
https://gitlab.com/michaelweiser/nettle/-/jobs/59289372
https://gitlab.com/michaelweiser/nettle/-/jobs/59324659

Build and test suite succeed for armeb as well as the other platforms.
(The fix for alpha and hppa failures with Gentoo is upcoming in the next
image build, aarch64_be was due to overenthusiasm on my part because
qemu-2.12.0 will have that target for user mode, sparc64 is currently
broken in Debian and hppa Debian failure is under investigation.)
-- 
Thanks!
Michael

</body></email><email><emailId>20180327210921</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-27 21:09:21-0400</timestampReceived><subject>Re: What should nettle-3.5 be like?</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Yes. It is at:
&gt; https://gitlab.com/gnutls/nettle/-/jobs/59417145
&gt;
&gt; and seems to pass. Thank you.

Good!

Change now merged to master-updates.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180330072951</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-30 07:29:51-0400</timestampReceived><subject>Re: symbol versioning update</subject><body>

Daniel P. Berrangé &lt;berrange@redhat.com&gt; writes:

&gt; The traditional way is for developers to update the dependancies to have
&gt; an explicit version against the library they require. eg if libvirt requires
&gt; some symbol introduced in nettle x.y, the maintainer would add
&gt;
&gt;   Requires: nettle &gt;= x.y
&gt;
&gt; the problem is that humans are fallible and so these versioned dependancies
&gt; frequently get missed, because package maintainers don't often have accurate
&gt; info on which min version is needed by a build.

I agree it's going to be a bit brittle to do that manually. E.g., in the
example at hand, the package source code only used the old nettle_hashes
symbol, but the new version of nettle headers turned that into a macro
calling a new function.

What I would suggest is filling out the &gt;= x.y automatically based on
the version of nettle header files actually used when compiling the
package. As far as I see, that should be both reliable and fairly easy
(get the version either from package metadata, or from nettle/version.h,
whatever fits the package building tools best). It might sometimes
produce an unnecessarily strict dependency (specifying a version higher
than really necessary), but I think that's a lot better then erring in
the other direction.

&gt; The only scope for errors here is when the
&gt; nettle developers are creating the symbol version file,

That's me... And I imagine we'll get into the territory of subtle
breakages the first time I mess up an update to that file.

&gt; and this is pretty
&gt; minor IME maintaining such version files for libvirt.

How do you write testcases to verify that the version list is correct?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180319063718</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-03-19 06:37:18-0400</timestampReceived><subject>mailing list archives</subject><body>

Hi,
 On certain occasions I was trying to link to posts in that list
however it seems that the official archives are not updated on a
reasonable frequency. For example the current archives [0] were last
updated on January 4. Is it possible to increase the archive generation
frequency to weekly or sooner?

regards,
Nikos

[0].
https://lists.lysator.liu.se/pipermail/nettle-bugs/2018/date.html


</body></email><email><emailId>20180319082907</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-19 08:29:07-0400</timestampReceived><subject>Re: mailing list archives</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt;  On certain occasions I was trying to link to posts in that list
&gt; however it seems that the official archives are not updated on a
&gt; reasonable frequency.

Thanks for the reminder. I've asked the volunteers maintaining the
mailinglist infrastructure to have a look.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180325095138</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-25 09:51:38-0400</timestampReceived><subject>Re: [PATCH 1/3] Add arm endianness-aware assembly infrastructure</subject><body>

Michael Weiser &lt;michael.weiser@gmx.de&gt; writes:

&gt; Introduce m4 macros to conditionally handle differences of little- and
&gt; big-endian arm in assembler code.

This and the next two patches now merged to master-updates for some final
testing.

At the moment, I'm only able to test that plain little-endian arm is
still working.

Thanks!
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180319214436</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-19 21:44:36-0400</timestampReceived><subject>Re: mailing list archives</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt;
&gt;&gt;  On certain occasions I was trying to link to posts in that list
&gt;&gt; however it seems that the official archives are not updated on a
&gt;&gt; reasonable frequency.
&gt;
&gt; Thanks for the reminder. I've asked the volunteers maintaining the
&gt; mailinglist infrastructure to have a look.

Archives have now been regenerated, let me know if the problem
reappears.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180218204627</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-18 20:46:27-0400</timestampReceived><subject>What should nettle-3.5 be like?</subject><body>

I used to think that next Nettle release should be focused on
performance and add a few more features, no incompatible changes.

But since the gcm changes breaks gnutls (fix in
https://gitlab.com/gnutls/gnutls/commit/176aa191380e5d63a981f08f537deffdd78f491a),
best way to reduce damage might be to bump the nettle soname. And if we
do that, there are a couple of other things that could be done at the
same time. Some changes to consider:

1. Remove the the symbols nettle_hashes and nettle_secp_384r1 and
   friends from the interface. They should be renamed with leading
   underscore. Important to be able to merge ed448 work without breaking
   the abi again.

2. Delete the old aes_* interface, in favor of aes128_, aes192_* and
   aes256_*. This could help aesni performance, where it might be nice
   with separately completely unrolled code for each key size.

3. Change struct nettle_aead to be more message-oriented.

4. Hide undocumented and internal symbols (the ones with leading
   underscore) more. Move declarations to internal uninstalled headers,
   possible tweak linker script to not expose at all in the shared
   library.

5. Revamp hmac and underlying hash functions with a separate state
   struct. Probably low priority, but it is a bit silly that, e.g.,
   hmac_sha512_ctx includes three 128-byte large block buffers.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20180227130106</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-02-27 13:01:06-0400</timestampReceived><subject>symbol versioning update</subject><body>

Hi,
 When we initially introduced symbol versioning in nettle we bundled
all symbols from the library in a single version. That means that new
symbols added to a release like nettle_get_hashes() may cause issues
like this:
https://bugzilla.redhat.com/show_bug.cgi?id=1549190

The underlying issue is in rpm-based systems which detect which symbols
exist in which library version based on the version. That way, when a
dependency is tracked, the version with the right symbol will be
retrieved. Debian-based systems work differently so that shouldn't
affect it.

To address these problems in gnutls, I follow these additional rules in
to having a map file:
https://gitlab.com/gnutls/gnutls/blob/master/CONTRIBUTING.md#symbol-and-library-versioning

which in turn comes from libvirt:
https://www.berrange.com/posts/2011/01/13/versioning-in-the-libvirt-library/

That of course adds overhead on releases.

nettle doesn't necessarily need to follow that process, I send that
issue in order to spark discussion on whether that's desirable to have.

regards,
Nikos


</body></email><email><emailId>20180207103058</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-02-07 10:30:58-0400</timestampReceived><subject>easier version checks</subject><body>

What about extending the macros in version.h with a simple to use
combined version number?



["0001-version.h-introduce-NETTLE_VERSION.patch" (0001-version.h-introduce-NETTLE_VERSION.patch)]

From e96108cbb92a923e02349a0d3b672a9b2b94c8b9 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 7 Feb 2018 11:29:07 +0100
Subject: [PATCH] version.h: introduce NETTLE_VERSION

That macro is more easy to use on #if clauses. E.g.,
do that
---
 configure.ac | 1 +
 version.h.in | 2 ++
 2 files changed, 3 insertions(+)

diff --git a/configure.ac b/configure.ac
index 41bf0998..d06f55c9 100644
--- a/configure.ac
+++ b/configure.ac
@@ -21,6 +21,7 @@ MAJOR_VERSION=`echo $PACKAGE_VERSION | sed 's/^\([[^.]]*\)\..*/\1/'`
 MINOR_VERSION=`echo $PACKAGE_VERSION | sed 's/^[[^.]]*\.\([[0-9]]*\).*/\1/'`
 AC_SUBST([MAJOR_VERSION])
 AC_SUBST([MINOR_VERSION])
+AC_SUBST([NUMBER_VERSION], $(printf "0x%02x%02x" ${MAJOR_VERSION} ${MINOR_VERSION}))
 
 AC_CANONICAL_HOST
 
diff --git a/version.h.in b/version.h.in
index cf429f25..7f10b995 100644
--- a/version.h.in
+++ b/version.h.in
@@ -43,6 +43,8 @@ extern "C" {
 #define NETTLE_VERSION_MAJOR @MAJOR_VERSION@
 #define NETTLE_VERSION_MINOR @MINOR_VERSION@
 
+#define NETTLE_VERSION @NUMBER_VERSION@
+
 #define NETTLE_USE_MINI_GMP @NETTLE_USE_MINI_GMP@
 
 /* We need a preprocessor constant for GMP_NUMB_BITS, simply using
-- 
2.14.3



</body></email><email><emailId>20180206232905</emailId><senderName>Michael Weiser</senderName><senderEmail>michael@weiser.dinsnail.net</senderEmail><timestampReceived>2018-02-06 23:29:05-0400</timestampReceived><subject>Re: Miscomputation with big-endian arm asm</subject><body>

Hi Niels,

thanks for getting back to me so quickly.

On Tue, Feb 06, 2018 at 07:36:22PM +0100, Niels Möller wrote:

&gt; &gt; Is there maybe a problem with the list or my email that you can discern?
&gt; None previously known to me (it's a plain mailman installation). I think
&gt; the most commonly used way to subscribe is to use the web frontend, and
&gt; then go to the link in the confirmation email using a web browser.

Mhmm, with another From address and a few more tries I now got myself
subscribed. Before that I had a number of confirmation emails leave my
server and be accepted by mail.lysator.liu.se but the responses never
getting back to my server even with that other From address.

Anywho, I'll leave all the quoted text for now so people can myabe still
pick up on the conversion. Sorry for the mess.

&gt; &gt; &gt; I just ran into a problem where gnutls's certificate verification fails
&gt; &gt; &gt; only on big-endian arm Linux boards but not on the otherwise identical
&gt; &gt; &gt; little-endian ones. After recompiling nettle with --disable-assembler
&gt; &gt; &gt; the problem goes away on big-endian arm as well. Considering that
&gt; &gt; &gt; big-endian arm isn't all that common, I suspect nettle's optimised arm
&gt; &gt; &gt; asm might have some endianness issues.
&gt; I have done no testing on big-endian arm. My recent big-endian tests
&gt; have been on the ultrasparc t5 in the gcc compile farm
&gt; (gcc202.fsffrance.org), and locally using debian's mips cross compiler
&gt; and qemu. So I'm fairly confident that the C code is endian-safe.

&gt; Lots of questions, since I'm unfamiliar with such systems:

&gt; What board and linux (dist?) are you running this on?

I have a number of Cubieboard2s that run Gentoo Linux with a vanilla,
mainline Linus kernel.

# uname -a
Linux b 4.15.0-gentoo #2 SMP Sun Feb 4 18:46:30 CET 2018 armv7b
ARMv7 Processor rev 4 (v7b) Allwinner sun7i (A20) Family GNU/Linux

The only difference between little- and big-endian boards is the
following Linux kernel config options:

-# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_BIG_ENDIAN=y
+CONFIG_CPU_ENDIAN_BE8=y

This makes the kernel switch the CPU to big-endian mode on boot.
Userland is big-endian as well.

Big-endian on ARM is somewhat curious in that instruction encoding stays
little-endian but loads and stores use big-endian byte order - if the
CPU is in that mode. It can be switched back and forth at will and it
basically only changes where it starts loading/storing bytes and in
which order it continues.

Because that would be too easy, it has two different big-endian
operating modes called BE32 and BE8. From what I understand, BE32
actually stores bytes the same order as little-endian in memory but
redirects accesses to individual bytes of words to make them appear to
be stored big-endian while BE8 actually stores words in big-endian byte
order and accesses individual bytes directly. The gory details are here
if you're interested:
http://infocenter.arm.com/help/topic/com.arm.doc.ddi0290g/ch06s05s01.html.
https://blog.richliu.com/2010/04/08/907/arm11-be8-and-be32

BE32 is deprecated, newer cores don't even support it.

I'm running BE8, so kernel and userland are BE8:

# file /usr/bin/nettle-hash 
/usr/bin/nettle-hash: ELF 32-bit MSB shared object, ARM, EABI5 BE8
version 1 (SYSV), dynamically linked, interpreter
/lib/ld-linux-armhf.so.3, for GNU/Linux 3.2.0, stripped

&gt; What's the host triplet?

armv7veb-hardfloat-linux-gnueabi

gcc:
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/libexec/gcc/armv7veb-hardfloat-linux-gnueabi/7.2.0/lto-wrapper
                
Target: armv7veb-hardfloat-linux-gnueabi
Configured with:
/var/tmp/portage/sys-devel/gcc-7.2.0-r1/work/gcc-7.2.0/configure
--host=armv7veb-hardfloat-linux-gnueabi
--build=armv7veb-hardfloat-linux-gnueabi --prefix=/usr
--bindir=/usr/armv7veb-hardfloat-linux-gnueabi/gcc-bin/7.2.0
--includedir=/usr/lib/gcc/armv7veb-hardfloat-linux-gnueabi/7.2.0/include
--datadir=/usr/share/gcc-data/armv7veb-hardfloat-linux-gnueabi/7.2.0
--mandir=/usr/share/gcc-data/armv7veb-hardfloat-linux-gnueabi/7.2.0/man
--infodir=/usr/share/gcc-data/armv7veb-hardfloat-linux-gnueabi/7.2.0/info
--with-gxx-include-dir=/usr/lib/gcc/armv7veb-hardfloat-linux-gnueabi/7.2.0/include/g++-v7
                
--with-python-dir=/share/gcc-data/armv7veb-hardfloat-linux-gnueabi/7.2.0/python
--enable-languages=c,c++ --enable-obsolete --enable-secureplt
--disable-werror --with-system-zlib --disable-nls
--enable-checking=release --with-bugurl=https://bugs.gentoo.org/
--with-pkgversion='Gentoo Hardened 7.2.0-r1 p1.1' --enable-esp
--enable-libstdcxx-time --disable-libstdcxx-pch --enable-shared
--enable-threads=posix --enable-__cxa_atexit --enable-clocale=gnu
--disable-multilib --disable-altivec --disable-fixed-point
--with-float=hard --with-float=hard --with-fpu=vfpv3-d16
--disable-libgcj --disable-libgomp --disable-libmudflap --disable-libssp
--disable-libcilkrts --disable-libmpx --enable-vtable-verify
--enable-libvtv --disable-libquadmath --enable-lto --without-isl
--disable-libsanitizer --enable-default-pie --enable-default-ssp
--with-arch=armv7ve
Thread model: posix
gcc version 7.2.0 (Gentoo Hardened 7.2.0-r1 p1.1) 

&gt; Are you cross compiling, or compiling natively?

It's all native on the board. I have a cross-toolchain and qemu on
standby on x86_64 if necessary.

&gt; Does configure detect it as big-endian (check for WORDS_BIGENDIAN in config.h)?

It seems so:

nettle-3.4 # grep WORDS_BIG config.h
/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the
most
#  define WORDS_BIGENDIAN 1
# ifndef WORDS_BIGENDIAN
#  define WORDS_BIGENDIAN 1

&gt; Which of nettle's own tests (make check) fail?

With --disable-assembler all checks pass. Here's the make check output
with arm asm:

PASS: aes
PASS: arcfour
PASS: arctwo
PASS: blowfish
PASS: cast128
PASS: base16
PASS: base64
PASS: camellia
Error, expected:

3e00ef2f895f40d6 7f5bb8e81f09a5a1
2c840ec3ce9a7f3b 181be188ef711a1e
984ce172b9216f41 9f445367456d5619
314a42a3da86b001 387bfdb80e0cfe42
Got:

4c4389ad2c1a14e5 9a58af4d26f726c8
2beb7f103f529dc2 a8a203e7c69fb546
141dc7988d5106d1 c03d895bb6576d0f
9718ecc1ae929e8d c8dc1f6ee7038bbb
../run-tests: line 57:  7819 Aborted                 "$1" $testflags
FAIL: chacha
PASS: des
PASS: des3
PASS: des-compat
PASS: md2
PASS: md4
PASS: md5
PASS: md5-compat
PASS: memeql
Assert failed: memxor-test.c:106: MEMEQ (size, dst, c)
../run-tests: line 57:  7865 Aborted                 "$1" $testflags
FAIL: memxor
PASS: gosthash94
PASS: ripemd160

Got:

f278b7b482ad71f2 83dcb4f9fe864547
5ed675894046fbeb 59de3b76052dfd99

Expected:

077709362c2e32df 0ddc3f0dc47bba63
90b6c73bb50f9c31 22ec844ad7c2b3e5
../run-tests: line 57:  7881 Aborted                 "$1" $testflags
FAIL: hkdf
Encrypt failed:
Input:
0000000000000000

Output:
0ab22555fbcab5ce

Expected:
fc207dbfc76c5e17

../run-tests: line 57:  7887 Aborted                 "$1" $testflags
FAIL: salsa20

Got:

9844f81e1408f6ec b932137d33bed7cf
dcf518a3

Expected:

da39a3ee5e6b4b0d 3255bfef95601890
afd80709
../run-tests: line 57:  7893 Aborted                 "$1" $testflags
FAIL: sha1
Got:

51a8a435f33f1941 a7646a966b9f99e5
095b59c1072c0acd 2a893d99

Expected:

23097d223405d822 8642a477bda255b3
2aadbce4bda0b3f7 e36c9da7
../run-tests: line 57:  7899 Aborted                 "$1" $testflags
FAIL: sha224

Got:

312892d3e4bda557 75e12e46320ed33a
329b15d73167b830 ec07ba0845c7b4cf

Expected:

ba7816bf8f01cfea 414140de5dae2223
b00361a396177a9c b410ff61f20015ad
../run-tests: line 57:  7905 Aborted                 "$1" $testflags
FAIL: sha256
PASS: sha384
PASS: sha512
PASS: sha512-224
PASS: sha512-256
PASS: sha3-permute
PASS: sha3-224
PASS: sha3-256
PASS: sha3-384
PASS: sha3-512
PASS: serpent
PASS: twofish
PASS: version
PASS: knuth-lfib
PASS: cbc
PASS: cfb
PASS: ctr
PASS: gcm
PASS: eax
CCM digest failed:
Adata:
0001020304050607

Input:
20212223

Output:
98055abb

Expected:
4dac255d

../run-tests: line 57:  8001 Aborted                 "$1" $testflags
FAIL: ccm
PASS: poly1305
Assert failed: testutils.c:619: MEMEQ(length, data, ciphertext-&gt;data)
../run-tests: line 57:  8012 Aborted                 "$1" $testflags
FAIL: chacha-poly1305
Assert failed: hmac-test.c:205: MEMEQ ((tstring_hex("b617318655057264
e28bc0b6fb378c8e f146be00"))-&gt;length, digest,
(tstring_hex("b617318655057264 e28bc0b6fb378c8e f146be00"))-&gt;data)
../run-tests: line 57:  8018 Aborted                 "$1" $testflags
FAIL: hmac
umac32 failed
msg:
length: 0
tag:
9f972a17
ref:
113145fb
../run-tests: line 57:  8024 Aborted                 "$1" $testflags
FAIL: umac
PASS: meta-hash
PASS: meta-cipher
PASS: meta-aead
PASS: meta-armor
PASS: buffer
Assert failed: yarrow-test.c:185: memcmp(digest, expected_input,
sizeof(digest)) == 0
../run-tests: line 57:  8055 Aborted                 "$1" $testflags
FAIL: yarrow
Assert failed: pbkdf2-test.c:38: MEMEQ
((tstring_hex("0c60c80f961f0e71f3a9b524af6012062fe037a6"))-&gt;length, dk,
(tstring_hex("0c60c80f961f0e71f3a9b524af6012062fe037a6"))-&gt;data)
../run-tests: line 57:  8061 Aborted                 "$1" $testflags
FAIL: pbkdf2
Assert failed: pss-mgf1-test.c:22: MEMEQ (expected-&gt;length, mask,
expected-&gt;data)
../run-tests: line 57:  8067 Aborted                 "$1" $testflags
FAIL: pss-mgf1
PASS: sexp
PASS: sexp-format
PASS: rsa2sexp
PASS: sexp2rsa
PASS: bignum
PASS: random-prime
PASS: pkcs1
Assert failed: pss-test.c:29: mpz_cmp(m, expected) == 0
../run-tests: line 57:  8108 Aborted                 "$1" $testflags
FAIL: pss
PASS: rsa-sign-tr
Assert failed: rsa-pss-sign-tr-test.c:72: mpz_cmp(signature, expected)
== 0
../run-tests: line 57:  8119 Aborted                 "$1" $testflags
FAIL: rsa-pss-sign-tr
Assert failed: testutils.c:1004: mpz_cmp (signature, expected) == 0
../run-tests: line 57:  8125 Aborted                 "$1" $testflags
FAIL: rsa
PASS: rsa-encrypt
Assert failed: testutils.c:1004: mpz_cmp (signature, expected) == 0
../run-tests: line 57:  8136 Aborted                 "$1" $testflags
FAIL: rsa-keygen
Assert failed: testutils.c:1189: mpz_cmp (signature.r, expected-&gt;r) == 0
&amp;&amp; mpz_cmp (signature.s, expected-&gt;s) == 0
../run-tests: line 57:  8142 Aborted                 "$1" $testflags
FAIL: dsa
PASS: dsa-keygen
PASS: curve25519-dh
PASS: ecc-mod
PASS: ecc-modinv
PASS: ecc-redc
PASS: ecc-sqrt
PASS: ecc-dup
PASS: ecc-add
PASS: ecc-mul-g
PASS: ecc-mul-a
PASS: ecdsa-sign
PASS: ecdsa-verify
PASS: ecdsa-keygen
PASS: ecdh
PASS: eddsa-compress
PASS: eddsa-sign
PASS: eddsa-verify
PASS: ed25519
PASS: cxx
PASS: sexp-conv
1c1
&lt;
2de201fee759dffb05a5ff127f4b0b134bf10f466cf174ebff52d387e551225a61e30ec850c38681574a1a \
8cefa1aa6030481cebc92268863871796ed1afd017969a1d70bb1c936fa1a71a975ddcc07a8d492d6caf59 \
                42182b03fa69fea603d904e1cd7c2c9f78e060662d7cf5ec2a5d5af7988e3054513f9f356b749360ec13
                
---
&gt; 5c96ffe7e925224ce6e98648bf2ed3193cab2fc82af9c7fa7fdc5b623bde1d77c5409129d16d1127ae4f \
&gt; ad519c24059fe85f4a4360a900f3dee906e6de2ecd010fa56c02d3f7d0772d43439464a91b025722a6f0 \
&gt; b6cb65aee1017b29aff4511f90315caae0be74c2ac496474896e7e3ad200cb7c609ddef5c674272964e4b780
&gt; 
FAIL: pkcs1-conv
test1.out test2.out differ: char 1, line 1
FAIL: nettle-pbkdf2
PASS: symbols
PASS: dlopen
=====================
21 of 94 tests failed
=====================
make[1]: *** [Makefile:136: check] Error 1

Looks bad.

&gt; &gt; &gt; I've not narrowed this down to a proper test case yet because I'm
&gt; &gt; &gt; wondering if this is even warrants digging into. Might this be an easy
&gt; &gt; &gt; fix or do I have to expect this to get so involved that I might just as
&gt; &gt; &gt; well just disable asm on big-endian arm and leave it at that? I *am* all
&gt; &gt; &gt; set to dive into this to provide a better test case and perhaps even
&gt; &gt; &gt; patch - just asking for the odds to solve this with only a beginner's
&gt; &gt; &gt; arm asm skills.
&gt; &gt; &gt; 
&gt; &gt; &gt; Note how all the SHA1/256 digests below differ for the same certificate.
&gt; &gt; From these symptoms, the main suspect is the data load in
&gt; arm/v6/sha1-compress.asm (see the LOAD macro) and
&gt; arm/v6/sha256-compress.asm (look at the code after the .Lcopy label).

&gt; As a quick test, you could try just deleting all use of the "rev"
&gt; instruction in those two files.

&gt; I'm not sure what's needed to properly support big-endian there, maybe
&gt; deleting rev isn't enough, one might also need to shift differently in
&gt; the unaligned case. If you want to use the same assembly source file for
&gt; both big- and little-endian, with only some m4 ifelse to do conditional
&gt; things in the asm files, you should let configure substitute something
&gt; in config.m4.in to test on.

Yes, the masking and shifting needs some adjustment, too. I got
sha1-test to succeed with below patch. What do you think: Could we go
some route like that for the other arm asm code as well? I'd be willing
to throw in aarch64 as well because I've got some Pine64s running BE
floating around also. :)

&gt; The aes code also loads unaligned data, but it reads it byte-by-byte,
&gt; without the tricks to use aligned word loads + rotate + sel.

&gt; Before attempting to support big-endian arm, I'd need some idea on how
&gt; to test it.

Any halfway current ARM cross toolchain should be able to also output
big-endian arm binaries (-mbig-endian). Then you could test those with
qemu-user-armeb, which is very light-weight in that it doesn't need a
kernel or emulated system and allows to run binaries directly.

&gt; If it's hard for me to test, the safest change may be to
&gt; just disable all arm assembly on big-endian.

I'm not ready to go there yet. Poking around ARM ASM unexpectedly is
fun. :)

&gt; From f876368b333c72878808e74a0af5aa631d42d357 Mon Sep 17 00:00:00 2001
From: Michael Weiser &lt;michael.weiser@gmx.de&gt;
Date: Wed, 7 Feb 2018 00:11:24 +0100
Subject: [PATCH] Support big-endian arm in sha1 armv6 assembly code

---
 arm/v6/sha1-compress.asm | 10 ++++++++++
 asm.m4                   | 10 ++++++++++
 config.m4.in             |  1 +
 configure.ac             |  2 ++
 4 files changed, 23 insertions(+)

diff --git a/arm/v6/sha1-compress.asm b/arm/v6/sha1-compress.asm
index 59d6297e..116a80f0 100644
--- a/arm/v6/sha1-compress.asm
+++ b/arm/v6/sha1-compress.asm
@@ -52,7 +52,9 @@ define(&lt;LOAD&gt;, &lt;
 	sel	W, WPREV, T0
 	ror	W, W, SHIFT
 	mov	WPREV, T0
+NOT_IF_BE(&lt;
 	rev	W, W
+&gt;)
 	str	W, [SP,#eval(4*$1)]
 &gt;)
 define(&lt;EXPN&gt;, &lt;
@@ -127,8 +129,16 @@ PROLOGUE(_nettle_sha1_compress)
 	lsl	SHIFT, SHIFT, #3
 	mov	T0, #0
 	movne	T0, #-1
+IF_BE(&lt;
+	lsr	W, T0, SHIFT
+&gt;, &lt;
 	lsl	W, T0, SHIFT
+&gt;)
 	uadd8	T0, T0, W		C Sets APSR.GE bits
+IF_BE(&lt;
+	neg     SHIFT, SHIFT		C Rotate right by 32-SHIFT bits
+	add     SHIFT, SHIFT, #32	C because there's no rotate left
+&gt;, &lt;&gt;)
 	
 	ldr	K, .LK1
 	ldm	STATE, {SA,SB,SC,SD,SE}
diff --git a/asm.m4 b/asm.m4
index 4018c235..34e39317 100644
--- a/asm.m4
+++ b/asm.m4
@@ -51,6 +51,16 @@ define(&lt;ALIGN&gt;,
 &lt;.align ifelse(ALIGN_LOG,yes,&lt;m4_log2($1)&gt;,$1)
 &gt;)
 
+define(&lt;IF_BE&gt;,
+&lt;ifelse(WORDS_BIGENDIAN,yes,
+&lt;$1&gt;,
+&lt;$2&gt;)&gt;)
+
+define(&lt;NOT_IF_BE&gt;,
+&lt;ifelse(WORDS_BIGENDIAN,no,
+&lt;$1&gt;,
+&lt;&gt;)&gt;)
+
 dnl Struct defining macros
 
 dnl STRUCTURE(prefix) 
diff --git a/config.m4.in b/config.m4.in
index e39c880c..11f90a40 100644
--- a/config.m4.in
+++ b/config.m4.in
@@ -7,6 +7,7 @@ define(&lt;TYPE_PROGBITS&gt;, &lt;@ASM_TYPE_PROGBITS@&gt;)dnl
 define(&lt;ALIGN_LOG&gt;, &lt;@ASM_ALIGN_LOG@&gt;)dnl
 define(&lt;W64_ABI&gt;, &lt;@W64_ABI@&gt;)dnl
 define(&lt;RODATA&gt;, &lt;@ASM_RODATA@&gt;)dnl
+define(&lt;WORDS_BIGENDIAN&gt;, &lt;@ASM_WORDS_BIGENDIAN@&gt;)dnl
 divert(1)
 @ASM_MARK_NOEXEC_STACK@
 divert
diff --git a/configure.ac b/configure.ac
index 41bf0998..5db72be8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -691,6 +691,7 @@ ASM_TYPE_FUNCTION='@function'
 ASM_TYPE_PROGBITS='@progbits'
 ASM_MARK_NOEXEC_STACK=''
 ASM_ALIGN_LOG=''
+ASM_WORDS_BIGENDIAN="$ac_cv_c_bigendian"
 
 if test x$enable_assembler = xyes ; then
   AC_CACHE_CHECK([if globals are prefixed by underscore],
@@ -811,6 +812,7 @@ AC_SUBST(ASM_TYPE_PROGBITS)
 AC_SUBST(ASM_MARK_NOEXEC_STACK)
 AC_SUBST(ASM_ALIGN_LOG)
 AC_SUBST(W64_ABI)
+AC_SUBST(ASM_WORDS_BIGENDIAN)
 AC_SUBST(EMULATOR)
 
 AC_SUBST(LIBNETTLE_MAJOR)
-- 
2.16.1

-- 
Thanks,
Michael


</body></email><email><emailId>20180120201408</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-01-20 20:14:08-0400</timestampReceived><subject>Re: [PATCH 1/2] Provide wrappers around OpenSSL AES GCM</subject><body>

Hello,

2017-12-12 3:54 GMT+03:00 Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;:
&gt; For benchmarking purposes provide wrappers around OpenSSL AES GCM
&gt; implementation. Note, digest callback will work only for encryption due
&gt; to OpenSSL internals.
&gt;
&gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt; ---
&gt;  examples/nettle-openssl.c | 109 +++++++++++++++++++++++++++++++++++++++++++++-
&gt;  nettle-internal.h         |   3 ++
&gt;  2 files changed, 110 insertions(+), 2 deletions(-)

What about these two patches? They allow comparing nettle vs OpenSSL
speed for AES-GCM.

-- 
With best wishes
Dmitry

</body></email><email><emailId>20180217095712</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-02-17 09:57:12-0400</timestampReceived><subject>[PATCH] Move expressions with side effects out of asserts</subject><body>

It is wrong to use expressions with side-effects in asserts, they can
easily be compiled away. Move them out of assert() macro and just
compare the result.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 examples/nettle-openssl.c | 29 ++++++++++++++++++++---------
 1 file changed, 20 insertions(+), 9 deletions(-)

diff --git a/examples/nettle-openssl.c b/examples/nettle-openssl.c
index a0b20d3c2a77..bb2e6627514a 100644
--- a/examples/nettle-openssl.c
+++ b/examples/nettle-openssl.c
@@ -79,8 +79,10 @@ openssl_evp_set_encrypt_key(void *p, const uint8_t *key,
 			    const EVP_CIPHER *cipher)
 {
   struct openssl_cipher_ctx *ctx = p;
+  int ret;
   ctx-&gt;evp = EVP_CIPHER_CTX_new();
-  assert(EVP_CipherInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL, 1) == 1);
+  ret = EVP_CipherInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL, 1);
+  assert(ret == 1);
   EVP_CIPHER_CTX_set_padding(ctx-&gt;evp, 0);
 }
 static void
@@ -88,8 +90,10 @@ openssl_evp_set_decrypt_key(void *p, const uint8_t *key,
 			    const EVP_CIPHER *cipher)
 {
   struct openssl_cipher_ctx *ctx = p;
+  int ret;
   ctx-&gt;evp = EVP_CIPHER_CTX_new();
-  assert(EVP_CipherInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL, 0) == 1);
+  ret = EVP_CipherInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL, 0);
+  assert(ret == 1);
   EVP_CIPHER_CTX_set_padding(ctx-&gt;evp, 0);
 }
 
@@ -99,7 +103,8 @@ openssl_evp_encrypt(const void *p, size_t length,
 {
   const struct openssl_cipher_ctx *ctx = p;
   int len;
-  assert(EVP_EncryptUpdate(ctx-&gt;evp, dst, &amp;len, src, length) == 1);
+  int ret = EVP_EncryptUpdate(ctx-&gt;evp, dst, &amp;len, src, length);
+  assert(ret == 1);
 }
 static void
 openssl_evp_decrypt(const void *p, size_t length,
@@ -107,14 +112,16 @@ openssl_evp_decrypt(const void *p, size_t length,
 {
   const struct openssl_cipher_ctx *ctx = p;
   int len;
-  assert(EVP_DecryptUpdate(ctx-&gt;evp, dst, &amp;len, src, length) == 1);
+  int ret = EVP_DecryptUpdate(ctx-&gt;evp, dst, &amp;len, src, length);
+  assert(ret == 1);
 }
 
 static void
 openssl_evp_set_nonce(void *p, const uint8_t *nonce)
 {
   const struct openssl_cipher_ctx *ctx = p;
-  assert(EVP_CipherInit_ex(ctx-&gt;evp, NULL, NULL, NULL, nonce, -1) == 1);
+  int ret = EVP_CipherInit_ex(ctx-&gt;evp, NULL, NULL, NULL, nonce, -1);
+  assert(ret == 1);
 }
 
 static void
@@ -122,7 +129,8 @@ openssl_evp_update(void *p, size_t length, const uint8_t *src)
 {
   const struct openssl_cipher_ctx *ctx = p;
   int len;
-  assert(EVP_EncryptUpdate(ctx-&gt;evp, NULL, &amp;len, src, length) == 1);
+  int ret = EVP_EncryptUpdate(ctx-&gt;evp, NULL, &amp;len, src, length);
+  assert(ret == 1);
 }
 
 /* This will work for encryption only! */
@@ -130,7 +138,8 @@ static void
 openssl_evp_gcm_digest(void *p, size_t length, uint8_t *dst)
 {
   const struct openssl_cipher_ctx *ctx = p;
-  assert(EVP_CIPHER_CTX_ctrl(ctx-&gt;evp, EVP_CTRL_GCM_GET_TAG, length, dst) == 1);
+  int ret = EVP_CIPHER_CTX_ctrl(ctx-&gt;evp, EVP_CTRL_GCM_GET_TAG, length, dst);
+  assert(ret == 1);
 }
 
 static void
@@ -139,7 +148,8 @@ openssl_evp_aead_encrypt(void *p, size_t length,
 {
   const struct openssl_cipher_ctx *ctx = p;
   int len;
-  assert(EVP_EncryptUpdate(ctx-&gt;evp, dst, &amp;len, src, length) == 1);
+  int ret = EVP_EncryptUpdate(ctx-&gt;evp, dst, &amp;len, src, length);
+  assert(ret == 1);
 }
 
 static void
@@ -148,7 +158,8 @@ openssl_evp_aead_decrypt(void *p, size_t length,
 {
   const struct openssl_cipher_ctx *ctx = p;
   int len;
-  assert(EVP_DecryptUpdate(ctx-&gt;evp, dst, &amp;len, src, length) == 1);
+  int ret = EVP_DecryptUpdate(ctx-&gt;evp, dst, &amp;len, src, length);
+  assert(ret == 1);
 }
 
 /* AES */
-- 
2.16.1


</body></email><email><emailId>20180217093534</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-17 09:35:34-0400</timestampReceived><subject>Re: [PATCH 1/2] Provide wrappers around OpenSSL AES GCM</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; For benchmarking purposes provide wrappers around OpenSSL AES GCM
&gt; implementation. Note, digest callback will work only for encryption due
&gt; to OpenSSL internals.

This patch and the next now merged to master-updates.

&gt; @@ -80,7 +80,7 @@ openssl_evp_set_encrypt_key(void *p, const uint8_t *key,
&gt;  {
&gt;    struct openssl_cipher_ctx *ctx = p;
&gt;    ctx-&gt;evp = EVP_CIPHER_CTX_new();
&gt; -  assert(EVP_EncryptInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL) == 1);
&gt; +  assert(EVP_CipherInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL, 1) == 1);
&gt;    EVP_CIPHER_CTX_set_padding(ctx-&gt;evp, 0);
&gt;  }

It's not right to use assert on expressions with side-effects. Since will
break builds with ./configure CFLAGS='-DNDEBUG'. 

One would need to either assign return value to a variable and assert on
that, or define some alternative assert-like makro which always
evaluates its argument.

Not a big problem if only in the benchmark code, but it should be
avoided. It was introduced earlier, in commit
https://git.lysator.liu.se/nettle/nettle/commit/5c78bb737c553f2064271f1a7c4768b88a09b665,
but I didn't notice at the time.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180217095230</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-17 09:52:30-0400</timestampReceived><subject>Re: [PATCH 1/2] Provide wrappers around OpenSSL AES GCM</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt; 
&gt; &gt; For benchmarking purposes provide wrappers around OpenSSL AES GCM
&gt; &gt; implementation. Note, digest callback will work only for encryption due
&gt; &gt; to OpenSSL internals.

And regarding the numbers, I think it is gcm_hash which is the
bottleneck for gcm. Nettle's x86_64 assembly does the gf operations with
one table lookup + shifting per byte. One could do something faster and
more clever with pclmul
https://software.intel.com/en-us/articles/intel-carry-less-multiplication-instruction-and-its-usage-for-computing-the-gcm-mode/.


I remember that in the "embedded nettle" project a few years ago, I
looked at ARM neon instructions for carry-less multiplication. And it
seems to be quite complicated, since it offered only carryless mul only
on 8-bit values (with nice SIMD parallelism).

On my machine, Nettle's gcm_aes128 encrypt is roughly 8 cycles per byte,
compared to 1.25 for aes128 in plain ecb mode. Openssl numbers 0.75 and
0.65, respectively.

Regards,
/Niels
-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20180217095928</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2018-02-17 09:59:28-0400</timestampReceived><subject>Re: [PATCH 1/2] Provide wrappers around OpenSSL AES GCM</subject><body>

On Sat, Feb 17, 2018 at 4:35 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; ...
&gt;&gt; @@ -80,7 +80,7 @@ openssl_evp_set_encrypt_key(void *p, const uint8_t *key,
&gt;&gt;  {
&gt;&gt;    struct openssl_cipher_ctx *ctx = p;
&gt;&gt;    ctx-&gt;evp = EVP_CIPHER_CTX_new();
&gt;&gt; -  assert(EVP_EncryptInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL) == 1);
&gt;&gt; +  assert(EVP_CipherInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL, 1) == 1);
&gt;&gt;    EVP_CIPHER_CTX_set_padding(ctx-&gt;evp, 0);
&gt;&gt;  }
&gt;
&gt; It's not right to use assert on expressions with side-effects. Since will
&gt; break builds with ./configure CFLAGS='-DNDEBUG'.

No asserts, period. They should not get through an audit.

What happens when an assert fires? According to Posix an abort()
happens (http://pubs.opengroup.org/onlinepubs/009695399/functions/assert.html).

What happens when the abort happens? The sensitive information inside
the app's security boundary leaves the security boundary. It is
egressed from the app and written to a core file.

It gets worse. If services are engaged like Windows Error Reporting,
Appport, Apple Crash Reporter, Crashlytics , and friends, then the
sensitive information leaves the computer or device, too. It just
crossed another security boundary and a third party owns it.

Everything that used to be private, like password lists and private
keys, are now public information. The NSA, GCHQ and law enforcement
thanks you.

The library that really perplexes me is libsodium. It is used in
software like Bitcoin and Monero. Every time an assert fires it is
like opening the wallet up for thieves to take what they want.

Please ensure you always build high integrity software with -DNDEBUG
to remove the asserts.

Jeff

</body></email><email><emailId>20180217100223</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-02-17 10:02:23-0400</timestampReceived><subject>Re: [PATCH 1/2] Provide wrappers around OpenSSL AES GCM</subject><body>

2018-02-17 12:35 GMT+03:00 Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt;&gt; For benchmarking purposes provide wrappers around OpenSSL AES GCM
&gt;&gt; implementation. Note, digest callback will work only for encryption due
&gt;&gt; to OpenSSL internals.
&gt;
&gt; This patch and the next now merged to master-updates.

Thank you!

&gt;
&gt;&gt; @@ -80,7 +80,7 @@ openssl_evp_set_encrypt_key(void *p, const uint8_t *key,
&gt;&gt;  {
&gt;&gt;    struct openssl_cipher_ctx *ctx = p;
&gt;&gt;    ctx-&gt;evp = EVP_CIPHER_CTX_new();
&gt;&gt; -  assert(EVP_EncryptInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL) == 1);
&gt;&gt; +  assert(EVP_CipherInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL, 1) == 1);
&gt;&gt;    EVP_CIPHER_CTX_set_padding(ctx-&gt;evp, 0);
&gt;&gt;  }
&gt;
&gt; It's not right to use assert on expressions with side-effects. Since will
&gt; break builds with ./configure CFLAGS='-DNDEBUG'.
&gt;
&gt; One would need to either assign return value to a variable and assert on
&gt; that, or define some alternative assert-like makro which always
&gt; evaluates its argument.

I've sent a followup patch with an additional variable. It is easier
to maintain.


Regarding the numbers, here is what I see on my laptop (i3-4005U):

libnettle: fat library initialization.
libnettle: cpu features: vendor:intel,aesni
libnettle: using aes instructions.
libnettle: not using sha_ni instructions.
libnettle: intel SSE2 will be used for memxor.
sha1_compress: 463.20 cycles
salsa20_core: 403.70 cycles
sha3_permute: 1838.10 cycles (76.59 / round)

benchmark call overhead: 0.003764 us   6.02 cycles

         Algorithm         mode Mbyte/s cycles/byte cycles/block
      poly1305-aes       update  951.68        1.60      1641.84

            aes128  ECB encrypt 2328.39        0.66        10.49
            aes128  ECB decrypt 1850.82        0.82        13.19
            aes128  CBC encrypt  267.16        5.71        91.38
            aes128  CBC decrypt 2015.34        0.76        12.11
            aes128   (in-place) 1598.20        0.95        15.28
            aes128          CTR 1683.51        0.91        14.50
            aes128   (in-place) 1343.33        1.14        18.17

            aes192  ECB encrypt 1695.07        0.90        14.40
            aes192  ECB decrypt 1737.14        0.88        14.05
            aes192  CBC encrypt  231.50        6.59       105.46
            aes192  CBC decrypt 1548.88        0.99        15.76
            aes192   (in-place) 1290.06        1.18        18.92
            aes192          CTR 1349.77        1.13        18.09
            aes192   (in-place) 1135.87        1.34        21.49

            aes256  ECB encrypt 1462.52        1.04        16.69
            aes256  ECB decrypt 1371.13        1.11        17.81
            aes256  CBC encrypt  204.46        7.46       119.41
            aes256  CBC decrypt 1296.66        1.18        18.83
            aes256   (in-place) 1056.29        1.44        23.11
            aes256          CTR 1123.06        1.36        21.74
            aes256   (in-place)  981.12        1.56        24.88

    openssl aes128  ECB encrypt 2308.04        0.66        10.58
    openssl aes128  ECB decrypt 2294.12        0.67        10.64

    openssl aes192  ECB encrypt 1929.11        0.79        12.66
    openssl aes192  ECB decrypt 1926.87        0.79        12.67

    openssl aes256  ECB encrypt 1653.41        0.92        14.77
    openssl aes256  ECB decrypt 1666.08        0.92        14.65

        gcm_aes128      encrypt  200.26        7.62       121.91
        gcm_aes128      decrypt  200.26        7.62       121.91
        gcm_aes128       update  240.93        6.33       101.33

        gcm_aes192      encrypt  193.38        7.89       126.25
        gcm_aes192      decrypt  194.50        7.85       125.52
        gcm_aes192       update  241.02        6.33       101.29

        gcm_aes256      encrypt  189.66        8.05       128.73
        gcm_aes256      decrypt  189.74        8.04       128.67
        gcm_aes256       update  240.14        6.35       101.67

openssl gcm_aes128      encrypt 1492.12        1.02        16.36
openssl gcm_aes128      decrypt 1496.77        1.02        16.31
openssl gcm_aes128       update 3683.07        0.41         6.63

openssl gcm_aes192      encrypt 1308.33        1.17        18.66
openssl gcm_aes192      decrypt 1315.36        1.16        18.56
openssl gcm_aes192       update 3662.13        0.42         6.67

openssl gcm_aes256      encrypt 1170.64        1.30        20.86
openssl gcm_aes256      decrypt 1173.83        1.30        20.80
openssl gcm_aes256       update 3489.30        0.44         7.00


-- 
With best wishes
Dmitry

</body></email><email><emailId>20180217113025</emailId><senderName>Amos Jeffries</senderName><senderEmail>squid3@treenet.co.nz</senderEmail><timestampReceived>2018-02-17 11:30:25-0400</timestampReceived><subject>Re: [PATCH 1/2] Provide wrappers around OpenSSL AES GCM</subject><body>

On 17/02/18 22:59, Jeffrey Walton wrote:
&gt; On Sat, Feb 17, 2018 at 4:35 AM, Niels Möller wrote:
&gt;&gt; ...
&gt;&gt;&gt; @@ -80,7 +80,7 @@ openssl_evp_set_encrypt_key(void *p, const uint8_t *key,
&gt;&gt;&gt;  {
&gt;&gt;&gt;    struct openssl_cipher_ctx *ctx = p;
&gt;&gt;&gt;    ctx-&gt;evp = EVP_CIPHER_CTX_new();
&gt;&gt;&gt; -  assert(EVP_EncryptInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL) == 1);
&gt;&gt;&gt; +  assert(EVP_CipherInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL, 1) == 1);
&gt;&gt;&gt;    EVP_CIPHER_CTX_set_padding(ctx-&gt;evp, 0);
&gt;&gt;&gt;  }
&gt;&gt;
&gt;&gt; It's not right to use assert on expressions with side-effects. Since will
&gt;&gt; break builds with ./configure CFLAGS='-DNDEBUG'.
&gt; 
&gt; No asserts, period. They should not get through an audit.
&gt; 

This is the QA code for testing. Asserting that it works correctly and
aborting to fail the test ASAP is the whole purpose of these.

The -DNDEBUG has to be accounted for even in test code because
additional compiler optimization may introduce issues for production
builds that do not show up when debug info clutters the binary.


No production systems should ever be running the test code on sensitive
data. Test data maybe, but not real PII.

AYJ

</body></email><email><emailId>20180217113926</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-02-17 11:39:26-0400</timestampReceived><subject>Re: [PATCH 1/2] Provide wrappers around OpenSSL AES GCM</subject><body>

That's a nice point. Operating systems evolved to be able to obtain crash at a level which is not reflected to low level functions like abort and assert. Can that be addressed in the nettle or individual lib level or at the POSIX level with the introduction of secure-assert or so? Removing asserts on production will cause more harm than good.

On February 17, 2018 9:59:28 AM UTC, Jeffrey Walton &lt;noloader@gmail.com&gt; wrote:
&gt;On Sat, Feb 17, 2018 at 4:35 AM, Niels Möller &lt;nisse@lysator.liu.se&gt;
&gt;wrote:
&gt;&gt; ...
&gt;&gt;&gt; @@ -80,7 +80,7 @@ openssl_evp_set_encrypt_key(void *p, const uint8_t
&gt;*key,
&gt;&gt;&gt;  {
&gt;&gt;&gt;    struct openssl_cipher_ctx *ctx = p;
&gt;&gt;&gt;    ctx-&gt;evp = EVP_CIPHER_CTX_new();
&gt;&gt;&gt; -  assert(EVP_EncryptInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL) ==
&gt;1);
&gt;&gt;&gt; +  assert(EVP_CipherInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL, 1) ==
&gt;1);
&gt;&gt;&gt;    EVP_CIPHER_CTX_set_padding(ctx-&gt;evp, 0);
&gt;&gt;&gt;  }
&gt;&gt;
&gt;&gt; It's not right to use assert on expressions with side-effects. Since
&gt;will
&gt;&gt; break builds with ./configure CFLAGS='-DNDEBUG'.
&gt;
&gt;No asserts, period. They should not get through an audit.
&gt;
&gt;What happens when an assert fires? According to Posix an abort()
&gt;happens
&gt;(http://pubs.opengroup.org/onlinepubs/009695399/functions/assert.html).
&gt;
&gt;What happens when the abort happens? The sensitive information inside
&gt;the app's security boundary leaves the security boundary. It is
&gt;egressed from the app and written to a core file.
&gt;
&gt;It gets worse. If services are engaged like Windows Error Reporting,
&gt;Appport, Apple Crash Reporter, Crashlytics , and friends, then the
&gt;sensitive information leaves the computer or device, too. It just
&gt;crossed another security boundary and a third party owns it.
&gt;
&gt;Everything that used to be private, like password lists and private
&gt;keys, are now public information. The NSA, GCHQ and law enforcement
&gt;thanks you.
&gt;
&gt;The library that really perplexes me is libsodium. It is used in
&gt;software like Bitcoin and Monero. Every time an assert fires it is
&gt;like opening the wallet up for thieves to take what they want.
&gt;
&gt;Please ensure you always build high integrity software with -DNDEBUG
&gt;to remove the asserts.
&gt;
&gt;Jeff
&gt;_______________________________________________
&gt;nettle-bugs mailing list
&gt;nettle-bugs@lists.lysator.liu.se
&gt;http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20180217114501</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2018-02-17 11:45:01-0400</timestampReceived><subject>Re: [PATCH 1/2] Provide wrappers around OpenSSL AES GCM</subject><body>

On Sat, Feb 17, 2018 at 6:30 AM, Amos Jeffries &lt;squid3@treenet.co.nz&gt; wrote:
&gt; On 17/02/18 22:59, Jeffrey Walton wrote:
&gt;&gt; On Sat, Feb 17, 2018 at 4:35 AM, Niels Möller wrote:
&gt;&gt;&gt; ...
&gt;&gt;&gt;&gt; ...
&gt;&gt;&gt; It's not right to use assert on expressions with side-effects. Since will
&gt;&gt;&gt; break builds with ./configure CFLAGS='-DNDEBUG'.
&gt;&gt;
&gt;&gt; No asserts, period. They should not get through an audit.
&gt;
&gt; This is the QA code for testing. Asserting that it works correctly and
&gt; aborting to fail the test ASAP is the whole purpose of these.

My bad, I should have said:

    No asserts in production, period

I use them prodigiously during development. Everything is validated
with an assert. I usually don't have to debug because the asserts
debug for me. My code can't fart or sneeze without me knowing about
it.

But production is a different story.... The time for debugging is over...

Jeff

</body></email><email><emailId>20180217114816</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-02-17 11:48:16-0400</timestampReceived><subject>Re: [PATCH 1/2] Provide wrappers around OpenSSL AES GCM</subject><body>



On February 17, 2018 9:35:34 AM UTC, nisse@lysator.liu.se wrote:
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt; 
&gt; &gt; For benchmarking purposes provide wrappers around OpenSSL AES GCM
&gt; &gt; implementation. Note, digest callback will work only for encryption
&gt; due
&gt; &gt; to OpenSSL internals.
&gt; 
&gt; This patch and the next now merged to master-updates.
&gt; 
&gt; &gt; @@ -80,7 +80,7 @@ openssl_evp_set_encrypt_key(void *p, const uint8_t
&gt; *key,
&gt; &gt; {
&gt; &gt; struct openssl_cipher_ctx *ctx = p;
&gt; &gt; ctx-&gt;evp = EVP_CIPHER_CTX_new();
&gt; &gt; -  assert(EVP_EncryptInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL) ==
&gt; 1);
&gt; &gt; +  assert(EVP_CipherInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL, 1) ==
&gt; 1);
&gt; &gt; EVP_CIPHER_CTX_set_padding(ctx-&gt;evp, 0);
&gt; &gt; }
&gt; 
&gt; It's not right to use assert on expressions with side-effects. Since
&gt; will
&gt; break builds with ./configure CFLAGS='-DNDEBUG'. 
&gt; 
&gt; One would need to either assign return value to a variable and assert
&gt; on
&gt; that, or define some alternative assert-like makro which always
&gt; evaluates its argument.
&gt; 
&gt; Not a big problem if only in the benchmark code, but it should be
&gt; avoided. It was introduced earlier, in commit
&gt; https://git.lysator.liu.se/nettle/nettle/commit/5c78bb737c553f2064271f1a7c4768b88a09b665,
&gt;  but I didn't notice at the time.

An alternative fix for that could be to introduce a check in a header which will fail \
compilation if ndebug is used.


</body></email><email><emailId>20180218213050</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-18 21:30:50-0400</timestampReceived><subject>TMP_DECL_ALIGN (was: Re: [PATCH v2 1/2] Implement PSS encoding functions)</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; For now, I think I'll fix this, and add a TMP_ALIGN_DECL,
&gt; TMP_ALIGN_ALLOC.

Below patch seems to work. Other options?

Regards,
/Niels

diff --git a/nettle-internal.h b/nettle-internal.h
index 38c8d2a8..b109e944 100644
--- a/nettle-internal.h
+++ b/nettle-internal.h
@@ -35,20 +35,41 @@
 #ifndef NETTLE_INTERNAL_H_INCLUDED
 #define NETTLE_INTERNAL_H_INCLUDED
 
+#include &lt;assert.h&gt;
+
 #include "nettle-meta.h"
 
+/* For definition of NETTLE_MAX_HASH_CONTEXT_SIZE. */
+#include "sha3.h"
+
 /* Temporary allocation, for systems that don't support alloca. Note
  * that the allocation requests should always be reasonably small, so
  * that they can fit on the stack. For non-alloca systems, we use a
- * fix maximum size, and abort if we ever need anything larger. */
+ * fix maximum size + an assert.
+ *
+ * TMP_DECL and TMP_ALLOC allocate an array of the given type, and
+ * take the array size (not byte size) as argument.
+ *
+ * TMP_DECL_ALIGN and TMP_ALLOC_ALIGN are intended for context
+ * structs, with void * pointer, size in bytes, and alignment
+ * requirements. On systems without alloca, implemented as an array of
+ * uint64_t, to ensure alignment. Since it is used as void * argument,
+ * no type casts are needed.
+ */
 
 #if HAVE_ALLOCA
 # define TMP_DECL(name, type, max) type *name
 # define TMP_ALLOC(name, size) (name = alloca(sizeof (*name) * (size)))
+# define TMP_DECL_ALIGN(name, max) void *name
+# define TMP_ALLOC_ALIGN(name, size) (name = alloca(size))
 #else /* !HAVE_ALLOCA */
 # define TMP_DECL(name, type, max) type name[max]
 # define TMP_ALLOC(name, size) \
-  do { if ((size) &gt; (sizeof(name) / sizeof(name[0]))) abort(); } while (0)
+  do { assert((size_t)(size) &lt;= (sizeof(name) / sizeof(name[0]))); } while (0)
+# define TMP_DECL_ALIGN(name, max) \
+  uint64_t name[((max) + (sizeof(uint64_t) - 1))/ sizeof(uint64_t)]
+# define TMP_ALLOC_ALIGN(name, size) \
+  do { assert((size_t)(size) &lt;= (sizeof(name))); } while (0)
 #endif 
 
 /* Arbitrary limits which apply to systems that don't have alloca */
diff --git a/pss-mgf1.c b/pss-mgf1.c
index 67df5570..3f5e204b 100644
--- a/pss-mgf1.c
+++ b/pss-mgf1.c
@@ -48,12 +48,12 @@ pss_mgf1(const void *seed, const struct nettle_hash *hash,
 	 size_t length, uint8_t *mask)
 {
   TMP_DECL(h, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);
-  TMP_DECL(state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
+  TMP_DECL_ALIGN(state, NETTLE_MAX_HASH_CONTEXT_SIZE);
   size_t i;
   uint8_t c[4];
 
   TMP_ALLOC(h, hash-&gt;digest_size);
-  TMP_ALLOC(state, hash-&gt;context_size);
+  TMP_ALLOC_ALIGN(state, hash-&gt;context_size);
 
   for (i = 0;;
        i++, mask += hash-&gt;digest_size, length -= hash-&gt;digest_size)
diff --git a/pss.c b/pss.c
index 88125c06..d28e7b13 100644
--- a/pss.c
+++ b/pss.c
@@ -67,12 +67,12 @@ pss_encode_mgf1(mpz_t m, size_t bits,
 		const uint8_t *digest)
 {
   TMP_GMP_DECL(em, uint8_t);
-  TMP_DECL(state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
+  TMP_DECL_ALIGN(state, NETTLE_MAX_HASH_CONTEXT_SIZE);
   size_t key_size = (bits + 7) / 8;
   size_t j;
 
   TMP_GMP_ALLOC(em, key_size);
-  TMP_ALLOC(state, hash-&gt;context_size);
+  TMP_ALLOC_ALIGN(state, hash-&gt;context_size);
 
   if (key_size &lt; hash-&gt;digest_size + salt_length + 2)
     {
@@ -127,7 +127,7 @@ pss_verify_mgf1(const mpz_t m, size_t bits,
 {
   TMP_GMP_DECL(em, uint8_t);
   TMP_DECL(h2, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);
-  TMP_DECL(state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);
+  TMP_DECL_ALIGN(state, NETTLE_MAX_HASH_CONTEXT_SIZE);
   uint8_t *h, *db, *salt;
   size_t key_size = (bits + 7) / 8;
   size_t j;
@@ -138,7 +138,7 @@ pss_verify_mgf1(const mpz_t m, size_t bits,
   TMP_GMP_ALLOC(em, key_size * 2);
 
   TMP_ALLOC(h2, hash-&gt;digest_size);
-  TMP_ALLOC(state, hash-&gt;context_size);
+  TMP_ALLOC_ALIGN(state, hash-&gt;context_size);
 
   if (key_size &lt; hash-&gt;digest_size + salt_length + 2)
     goto cleanup;


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180219071154</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-19 07:11:54-0400</timestampReceived><subject>Re: TMP_DECL_ALIGN</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt; For now, I think I'll fix this, and add a TMP_ALIGN_DECL,
&gt;&gt; TMP_ALIGN_ALLOC.
&gt;
&gt; Below patch seems to work. Other options?

Replying to myself again, I guess one other option is to drop alloca
completely in favor of c99 (and gnuc) variable length arrays. alloca
isn't exactly equivalent, but I'm fairly confident that all use of
alloca within nettle can be easily replaced with variable length arrays.
Two slight drawbacks:

1. It's unfortunately demoted to an optional feature in c11 (see
   https://en.wikipedia.org/wiki/C11_(C_standard_revision)). I would
   guess this is unlikely to be a real problem.

2. When allocating a context struct where we only know the size, we'd
   still need some hack to allocate as a uint64_t array or so, to ensure
   sufficient alignment. Unlike alloca, which will to whatever is needed
   with the stack pointer to get same minimum alignment as malloc.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180110091719</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-01-10 09:17:19-0400</timestampReceived><subject>cmac</subject><body>

Hi,
 The attached patch brings support for AES-128-CMAC. The code is based
on the samba code. The rshift and lshift functions come from the AES
implementation bundled with samba.

regards,
Nikos

["0001-Added-support-for-CMAC.patch" (0001-Added-support-for-CMAC.patch)]

From e68adc5e81ff8814707cddba47118f99778deabc Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 10 Jan 2018 09:29:17 +0100
Subject: [PATCH] Added support for CMAC

That adds support for CMAC as a generic framework for
128-bit block and key ciphers, as well as API for AES-128-CMAC.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 Makefile.in                 |   3 +
 cmac-aes128.c               |  60 +++++
 cmac-internal.h             | 588 ++++++++++++++++++++++++++++++++++++++++++++
 cmac.c                      | 139 +++++++++++
 cmac.h                      | 117 +++++++++
 examples/nettle-benchmark.c |  24 +-
 testsuite/.test-rules.make  |   3 +
 testsuite/Makefile.in       |   1 +
 testsuite/cmac-test.c       |  57 +++++
 9 files changed, 991 insertions(+), 1 deletion(-)
 create mode 100644 cmac-aes128.c
 create mode 100644 cmac-internal.h
 create mode 100644 cmac.c
 create mode 100644 cmac.h
 create mode 100644 testsuite/cmac-test.c

diff --git a/Makefile.in b/Makefile.in
index 6a0c13ec..8d6219b6 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -103,6 +103,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-aes256.c gcm-aes256-meta.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
+		 cmac.c cmac-aes128.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
@@ -195,6 +196,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  gcm.h gosthash94.h hmac.h \
 	  knuth-lfib.h hkdf.h \
 	  macros.h \
+	  cmac.h \
 	  md2.h md4.h \
 	  md5.h md5-compat.h \
 	  memops.h memxor.h \
@@ -226,6 +228,7 @@ DISTFILES = $(SOURCES) $(HEADERS) getopt.h getopt_int.h \
 	nettle.pc.in hogweed.pc.in \
 	$(des_headers) descore.README \
 	aes-internal.h camellia-internal.h serpent-internal.h \
+	cmac-internal.h \
 	cast128_sboxes.h desinfo.h desCode.h \
 	memxor-internal.h nettle-internal.h nettle-write.h \
 	gmp-glue.h ecc-internal.h fat-setup.h \
diff --git a/cmac-aes128.c b/cmac-aes128.c
new file mode 100644
index 00000000..e53e114e
--- /dev/null
+++ b/cmac-aes128.c
@@ -0,0 +1,60 @@
+/* cmac-aes128.c
+
+   CMAC using AES128 as the underlying cipher.
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "cmac.h"
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key)
+{
+  CMAC128_SET_KEY(ctx, aes128_set_encrypt_key, aes128_encrypt, key);
+}
+
+void
+cmac_aes128_update (struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  CMAC128_UPDATE (ctx, aes128_encrypt, length, data);
+}
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  CMAC128_DIGEST(ctx, aes128_encrypt, length, digest);
+}
diff --git a/cmac-internal.h b/cmac-internal.h
new file mode 100644
index 00000000..51b4b014
--- /dev/null
+++ b/cmac-internal.h
@@ -0,0 +1,588 @@
+/*
+ * Copyright (c) 2003-2004 Kungliga Tekniska Högskolan
+ * (Royal Institute of Technology, Stockholm, Sweden).
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/* $Id$ */
+
+#ifndef LIB_CRYPTO_AES_H
+#define LIB_CRYPTO_AES_H 1
+
+#include "aes.h"
+
+static inline void block_lshift(const uint8_t in[AES_BLOCK_SIZE],
+				uint8_t out[AES_BLOCK_SIZE])
+{
+	static const struct block_lshift_entry {
+		uint8_t lshift;
+		uint8_t overflow;
+	} block_lshift_table[UINT8_MAX+1] = {
+		[0x00] = { .lshift = 0x00, .overflow = 0x00 },
+		[0x01] = { .lshift = 0x02, .overflow = 0x00 },
+		[0x02] = { .lshift = 0x04, .overflow = 0x00 },
+		[0x03] = { .lshift = 0x06, .overflow = 0x00 },
+		[0x04] = { .lshift = 0x08, .overflow = 0x00 },
+		[0x05] = { .lshift = 0x0a, .overflow = 0x00 },
+		[0x06] = { .lshift = 0x0c, .overflow = 0x00 },
+		[0x07] = { .lshift = 0x0e, .overflow = 0x00 },
+		[0x08] = { .lshift = 0x10, .overflow = 0x00 },
+		[0x09] = { .lshift = 0x12, .overflow = 0x00 },
+		[0x0a] = { .lshift = 0x14, .overflow = 0x00 },
+		[0x0b] = { .lshift = 0x16, .overflow = 0x00 },
+		[0x0c] = { .lshift = 0x18, .overflow = 0x00 },
+		[0x0d] = { .lshift = 0x1a, .overflow = 0x00 },
+		[0x0e] = { .lshift = 0x1c, .overflow = 0x00 },
+		[0x0f] = { .lshift = 0x1e, .overflow = 0x00 },
+		[0x10] = { .lshift = 0x20, .overflow = 0x00 },
+		[0x11] = { .lshift = 0x22, .overflow = 0x00 },
+		[0x12] = { .lshift = 0x24, .overflow = 0x00 },
+		[0x13] = { .lshift = 0x26, .overflow = 0x00 },
+		[0x14] = { .lshift = 0x28, .overflow = 0x00 },
+		[0x15] = { .lshift = 0x2a, .overflow = 0x00 },
+		[0x16] = { .lshift = 0x2c, .overflow = 0x00 },
+		[0x17] = { .lshift = 0x2e, .overflow = 0x00 },
+		[0x18] = { .lshift = 0x30, .overflow = 0x00 },
+		[0x19] = { .lshift = 0x32, .overflow = 0x00 },
+		[0x1a] = { .lshift = 0x34, .overflow = 0x00 },
+		[0x1b] = { .lshift = 0x36, .overflow = 0x00 },
+		[0x1c] = { .lshift = 0x38, .overflow = 0x00 },
+		[0x1d] = { .lshift = 0x3a, .overflow = 0x00 },
+		[0x1e] = { .lshift = 0x3c, .overflow = 0x00 },
+		[0x1f] = { .lshift = 0x3e, .overflow = 0x00 },
+		[0x20] = { .lshift = 0x40, .overflow = 0x00 },
+		[0x21] = { .lshift = 0x42, .overflow = 0x00 },
+		[0x22] = { .lshift = 0x44, .overflow = 0x00 },
+		[0x23] = { .lshift = 0x46, .overflow = 0x00 },
+		[0x24] = { .lshift = 0x48, .overflow = 0x00 },
+		[0x25] = { .lshift = 0x4a, .overflow = 0x00 },
+		[0x26] = { .lshift = 0x4c, .overflow = 0x00 },
+		[0x27] = { .lshift = 0x4e, .overflow = 0x00 },
+		[0x28] = { .lshift = 0x50, .overflow = 0x00 },
+		[0x29] = { .lshift = 0x52, .overflow = 0x00 },
+		[0x2a] = { .lshift = 0x54, .overflow = 0x00 },
+		[0x2b] = { .lshift = 0x56, .overflow = 0x00 },
+		[0x2c] = { .lshift = 0x58, .overflow = 0x00 },
+		[0x2d] = { .lshift = 0x5a, .overflow = 0x00 },
+		[0x2e] = { .lshift = 0x5c, .overflow = 0x00 },
+		[0x2f] = { .lshift = 0x5e, .overflow = 0x00 },
+		[0x30] = { .lshift = 0x60, .overflow = 0x00 },
+		[0x31] = { .lshift = 0x62, .overflow = 0x00 },
+		[0x32] = { .lshift = 0x64, .overflow = 0x00 },
+		[0x33] = { .lshift = 0x66, .overflow = 0x00 },
+		[0x34] = { .lshift = 0x68, .overflow = 0x00 },
+		[0x35] = { .lshift = 0x6a, .overflow = 0x00 },
+		[0x36] = { .lshift = 0x6c, .overflow = 0x00 },
+		[0x37] = { .lshift = 0x6e, .overflow = 0x00 },
+		[0x38] = { .lshift = 0x70, .overflow = 0x00 },
+		[0x39] = { .lshift = 0x72, .overflow = 0x00 },
+		[0x3a] = { .lshift = 0x74, .overflow = 0x00 },
+		[0x3b] = { .lshift = 0x76, .overflow = 0x00 },
+		[0x3c] = { .lshift = 0x78, .overflow = 0x00 },
+		[0x3d] = { .lshift = 0x7a, .overflow = 0x00 },
+		[0x3e] = { .lshift = 0x7c, .overflow = 0x00 },
+		[0x3f] = { .lshift = 0x7e, .overflow = 0x00 },
+		[0x40] = { .lshift = 0x80, .overflow = 0x00 },
+		[0x41] = { .lshift = 0x82, .overflow = 0x00 },
+		[0x42] = { .lshift = 0x84, .overflow = 0x00 },
+		[0x43] = { .lshift = 0x86, .overflow = 0x00 },
+		[0x44] = { .lshift = 0x88, .overflow = 0x00 },
+		[0x45] = { .lshift = 0x8a, .overflow = 0x00 },
+		[0x46] = { .lshift = 0x8c, .overflow = 0x00 },
+		[0x47] = { .lshift = 0x8e, .overflow = 0x00 },
+		[0x48] = { .lshift = 0x90, .overflow = 0x00 },
+		[0x49] = { .lshift = 0x92, .overflow = 0x00 },
+		[0x4a] = { .lshift = 0x94, .overflow = 0x00 },
+		[0x4b] = { .lshift = 0x96, .overflow = 0x00 },
+		[0x4c] = { .lshift = 0x98, .overflow = 0x00 },
+		[0x4d] = { .lshift = 0x9a, .overflow = 0x00 },
+		[0x4e] = { .lshift = 0x9c, .overflow = 0x00 },
+		[0x4f] = { .lshift = 0x9e, .overflow = 0x00 },
+		[0x50] = { .lshift = 0xa0, .overflow = 0x00 },
+		[0x51] = { .lshift = 0xa2, .overflow = 0x00 },
+		[0x52] = { .lshift = 0xa4, .overflow = 0x00 },
+		[0x53] = { .lshift = 0xa6, .overflow = 0x00 },
+		[0x54] = { .lshift = 0xa8, .overflow = 0x00 },
+		[0x55] = { .lshift = 0xaa, .overflow = 0x00 },
+		[0x56] = { .lshift = 0xac, .overflow = 0x00 },
+		[0x57] = { .lshift = 0xae, .overflow = 0x00 },
+		[0x58] = { .lshift = 0xb0, .overflow = 0x00 },
+		[0x59] = { .lshift = 0xb2, .overflow = 0x00 },
+		[0x5a] = { .lshift = 0xb4, .overflow = 0x00 },
+		[0x5b] = { .lshift = 0xb6, .overflow = 0x00 },
+		[0x5c] = { .lshift = 0xb8, .overflow = 0x00 },
+		[0x5d] = { .lshift = 0xba, .overflow = 0x00 },
+		[0x5e] = { .lshift = 0xbc, .overflow = 0x00 },
+		[0x5f] = { .lshift = 0xbe, .overflow = 0x00 },
+		[0x60] = { .lshift = 0xc0, .overflow = 0x00 },
+		[0x61] = { .lshift = 0xc2, .overflow = 0x00 },
+		[0x62] = { .lshift = 0xc4, .overflow = 0x00 },
+		[0x63] = { .lshift = 0xc6, .overflow = 0x00 },
+		[0x64] = { .lshift = 0xc8, .overflow = 0x00 },
+		[0x65] = { .lshift = 0xca, .overflow = 0x00 },
+		[0x66] = { .lshift = 0xcc, .overflow = 0x00 },
+		[0x67] = { .lshift = 0xce, .overflow = 0x00 },
+		[0x68] = { .lshift = 0xd0, .overflow = 0x00 },
+		[0x69] = { .lshift = 0xd2, .overflow = 0x00 },
+		[0x6a] = { .lshift = 0xd4, .overflow = 0x00 },
+		[0x6b] = { .lshift = 0xd6, .overflow = 0x00 },
+		[0x6c] = { .lshift = 0xd8, .overflow = 0x00 },
+		[0x6d] = { .lshift = 0xda, .overflow = 0x00 },
+		[0x6e] = { .lshift = 0xdc, .overflow = 0x00 },
+		[0x6f] = { .lshift = 0xde, .overflow = 0x00 },
+		[0x70] = { .lshift = 0xe0, .overflow = 0x00 },
+		[0x71] = { .lshift = 0xe2, .overflow = 0x00 },
+		[0x72] = { .lshift = 0xe4, .overflow = 0x00 },
+		[0x73] = { .lshift = 0xe6, .overflow = 0x00 },
+		[0x74] = { .lshift = 0xe8, .overflow = 0x00 },
+		[0x75] = { .lshift = 0xea, .overflow = 0x00 },
+		[0x76] = { .lshift = 0xec, .overflow = 0x00 },
+		[0x77] = { .lshift = 0xee, .overflow = 0x00 },
+		[0x78] = { .lshift = 0xf0, .overflow = 0x00 },
+		[0x79] = { .lshift = 0xf2, .overflow = 0x00 },
+		[0x7a] = { .lshift = 0xf4, .overflow = 0x00 },
+		[0x7b] = { .lshift = 0xf6, .overflow = 0x00 },
+		[0x7c] = { .lshift = 0xf8, .overflow = 0x00 },
+		[0x7d] = { .lshift = 0xfa, .overflow = 0x00 },
+		[0x7e] = { .lshift = 0xfc, .overflow = 0x00 },
+		[0x7f] = { .lshift = 0xfe, .overflow = 0x00 },
+		[0x80] = { .lshift = 0x00, .overflow = 0x01 },
+		[0x81] = { .lshift = 0x02, .overflow = 0x01 },
+		[0x82] = { .lshift = 0x04, .overflow = 0x01 },
+		[0x83] = { .lshift = 0x06, .overflow = 0x01 },
+		[0x84] = { .lshift = 0x08, .overflow = 0x01 },
+		[0x85] = { .lshift = 0x0a, .overflow = 0x01 },
+		[0x86] = { .lshift = 0x0c, .overflow = 0x01 },
+		[0x87] = { .lshift = 0x0e, .overflow = 0x01 },
+		[0x88] = { .lshift = 0x10, .overflow = 0x01 },
+		[0x89] = { .lshift = 0x12, .overflow = 0x01 },
+		[0x8a] = { .lshift = 0x14, .overflow = 0x01 },
+		[0x8b] = { .lshift = 0x16, .overflow = 0x01 },
+		[0x8c] = { .lshift = 0x18, .overflow = 0x01 },
+		[0x8d] = { .lshift = 0x1a, .overflow = 0x01 },
+		[0x8e] = { .lshift = 0x1c, .overflow = 0x01 },
+		[0x8f] = { .lshift = 0x1e, .overflow = 0x01 },
+		[0x90] = { .lshift = 0x20, .overflow = 0x01 },
+		[0x91] = { .lshift = 0x22, .overflow = 0x01 },
+		[0x92] = { .lshift = 0x24, .overflow = 0x01 },
+		[0x93] = { .lshift = 0x26, .overflow = 0x01 },
+		[0x94] = { .lshift = 0x28, .overflow = 0x01 },
+		[0x95] = { .lshift = 0x2a, .overflow = 0x01 },
+		[0x96] = { .lshift = 0x2c, .overflow = 0x01 },
+		[0x97] = { .lshift = 0x2e, .overflow = 0x01 },
+		[0x98] = { .lshift = 0x30, .overflow = 0x01 },
+		[0x99] = { .lshift = 0x32, .overflow = 0x01 },
+		[0x9a] = { .lshift = 0x34, .overflow = 0x01 },
+		[0x9b] = { .lshift = 0x36, .overflow = 0x01 },
+		[0x9c] = { .lshift = 0x38, .overflow = 0x01 },
+		[0x9d] = { .lshift = 0x3a, .overflow = 0x01 },
+		[0x9e] = { .lshift = 0x3c, .overflow = 0x01 },
+		[0x9f] = { .lshift = 0x3e, .overflow = 0x01 },
+		[0xa0] = { .lshift = 0x40, .overflow = 0x01 },
+		[0xa1] = { .lshift = 0x42, .overflow = 0x01 },
+		[0xa2] = { .lshift = 0x44, .overflow = 0x01 },
+		[0xa3] = { .lshift = 0x46, .overflow = 0x01 },
+		[0xa4] = { .lshift = 0x48, .overflow = 0x01 },
+		[0xa5] = { .lshift = 0x4a, .overflow = 0x01 },
+		[0xa6] = { .lshift = 0x4c, .overflow = 0x01 },
+		[0xa7] = { .lshift = 0x4e, .overflow = 0x01 },
+		[0xa8] = { .lshift = 0x50, .overflow = 0x01 },
+		[0xa9] = { .lshift = 0x52, .overflow = 0x01 },
+		[0xaa] = { .lshift = 0x54, .overflow = 0x01 },
+		[0xab] = { .lshift = 0x56, .overflow = 0x01 },
+		[0xac] = { .lshift = 0x58, .overflow = 0x01 },
+		[0xad] = { .lshift = 0x5a, .overflow = 0x01 },
+		[0xae] = { .lshift = 0x5c, .overflow = 0x01 },
+		[0xaf] = { .lshift = 0x5e, .overflow = 0x01 },
+		[0xb0] = { .lshift = 0x60, .overflow = 0x01 },
+		[0xb1] = { .lshift = 0x62, .overflow = 0x01 },
+		[0xb2] = { .lshift = 0x64, .overflow = 0x01 },
+		[0xb3] = { .lshift = 0x66, .overflow = 0x01 },
+		[0xb4] = { .lshift = 0x68, .overflow = 0x01 },
+		[0xb5] = { .lshift = 0x6a, .overflow = 0x01 },
+		[0xb6] = { .lshift = 0x6c, .overflow = 0x01 },
+		[0xb7] = { .lshift = 0x6e, .overflow = 0x01 },
+		[0xb8] = { .lshift = 0x70, .overflow = 0x01 },
+		[0xb9] = { .lshift = 0x72, .overflow = 0x01 },
+		[0xba] = { .lshift = 0x74, .overflow = 0x01 },
+		[0xbb] = { .lshift = 0x76, .overflow = 0x01 },
+		[0xbc] = { .lshift = 0x78, .overflow = 0x01 },
+		[0xbd] = { .lshift = 0x7a, .overflow = 0x01 },
+		[0xbe] = { .lshift = 0x7c, .overflow = 0x01 },
+		[0xbf] = { .lshift = 0x7e, .overflow = 0x01 },
+		[0xc0] = { .lshift = 0x80, .overflow = 0x01 },
+		[0xc1] = { .lshift = 0x82, .overflow = 0x01 },
+		[0xc2] = { .lshift = 0x84, .overflow = 0x01 },
+		[0xc3] = { .lshift = 0x86, .overflow = 0x01 },
+		[0xc4] = { .lshift = 0x88, .overflow = 0x01 },
+		[0xc5] = { .lshift = 0x8a, .overflow = 0x01 },
+		[0xc6] = { .lshift = 0x8c, .overflow = 0x01 },
+		[0xc7] = { .lshift = 0x8e, .overflow = 0x01 },
+		[0xc8] = { .lshift = 0x90, .overflow = 0x01 },
+		[0xc9] = { .lshift = 0x92, .overflow = 0x01 },
+		[0xca] = { .lshift = 0x94, .overflow = 0x01 },
+		[0xcb] = { .lshift = 0x96, .overflow = 0x01 },
+		[0xcc] = { .lshift = 0x98, .overflow = 0x01 },
+		[0xcd] = { .lshift = 0x9a, .overflow = 0x01 },
+		[0xce] = { .lshift = 0x9c, .overflow = 0x01 },
+		[0xcf] = { .lshift = 0x9e, .overflow = 0x01 },
+		[0xd0] = { .lshift = 0xa0, .overflow = 0x01 },
+		[0xd1] = { .lshift = 0xa2, .overflow = 0x01 },
+		[0xd2] = { .lshift = 0xa4, .overflow = 0x01 },
+		[0xd3] = { .lshift = 0xa6, .overflow = 0x01 },
+		[0xd4] = { .lshift = 0xa8, .overflow = 0x01 },
+		[0xd5] = { .lshift = 0xaa, .overflow = 0x01 },
+		[0xd6] = { .lshift = 0xac, .overflow = 0x01 },
+		[0xd7] = { .lshift = 0xae, .overflow = 0x01 },
+		[0xd8] = { .lshift = 0xb0, .overflow = 0x01 },
+		[0xd9] = { .lshift = 0xb2, .overflow = 0x01 },
+		[0xda] = { .lshift = 0xb4, .overflow = 0x01 },
+		[0xdb] = { .lshift = 0xb6, .overflow = 0x01 },
+		[0xdc] = { .lshift = 0xb8, .overflow = 0x01 },
+		[0xdd] = { .lshift = 0xba, .overflow = 0x01 },
+		[0xde] = { .lshift = 0xbc, .overflow = 0x01 },
+		[0xdf] = { .lshift = 0xbe, .overflow = 0x01 },
+		[0xe0] = { .lshift = 0xc0, .overflow = 0x01 },
+		[0xe1] = { .lshift = 0xc2, .overflow = 0x01 },
+		[0xe2] = { .lshift = 0xc4, .overflow = 0x01 },
+		[0xe3] = { .lshift = 0xc6, .overflow = 0x01 },
+		[0xe4] = { .lshift = 0xc8, .overflow = 0x01 },
+		[0xe5] = { .lshift = 0xca, .overflow = 0x01 },
+		[0xe6] = { .lshift = 0xcc, .overflow = 0x01 },
+		[0xe7] = { .lshift = 0xce, .overflow = 0x01 },
+		[0xe8] = { .lshift = 0xd0, .overflow = 0x01 },
+		[0xe9] = { .lshift = 0xd2, .overflow = 0x01 },
+		[0xea] = { .lshift = 0xd4, .overflow = 0x01 },
+		[0xeb] = { .lshift = 0xd6, .overflow = 0x01 },
+		[0xec] = { .lshift = 0xd8, .overflow = 0x01 },
+		[0xed] = { .lshift = 0xda, .overflow = 0x01 },
+		[0xee] = { .lshift = 0xdc, .overflow = 0x01 },
+		[0xef] = { .lshift = 0xde, .overflow = 0x01 },
+		[0xf0] = { .lshift = 0xe0, .overflow = 0x01 },
+		[0xf1] = { .lshift = 0xe2, .overflow = 0x01 },
+		[0xf2] = { .lshift = 0xe4, .overflow = 0x01 },
+		[0xf3] = { .lshift = 0xe6, .overflow = 0x01 },
+		[0xf4] = { .lshift = 0xe8, .overflow = 0x01 },
+		[0xf5] = { .lshift = 0xea, .overflow = 0x01 },
+		[0xf6] = { .lshift = 0xec, .overflow = 0x01 },
+		[0xf7] = { .lshift = 0xee, .overflow = 0x01 },
+		[0xf8] = { .lshift = 0xf0, .overflow = 0x01 },
+		[0xf9] = { .lshift = 0xf2, .overflow = 0x01 },
+		[0xfa] = { .lshift = 0xf4, .overflow = 0x01 },
+		[0xfb] = { .lshift = 0xf6, .overflow = 0x01 },
+		[0xfc] = { .lshift = 0xf8, .overflow = 0x01 },
+		[0xfd] = { .lshift = 0xfa, .overflow = 0x01 },
+		[0xfe] = { .lshift = 0xfc, .overflow = 0x01 },
+		[0xff] = { .lshift = 0xfe, .overflow = 0x01 },
+	};
+	int8_t i;
+	uint8_t overflow = 0;
+
+	for (i = AES_BLOCK_SIZE - 1; i &gt;= 0; i--) {
+		const struct block_lshift_entry *e = &amp;block_lshift_table[in[i]];
+		out[i] = e-&gt;lshift | overflow;
+		overflow = e-&gt;overflow;
+	}
+}
+
+static inline void block_rshift(const uint8_t in[AES_BLOCK_SIZE],
+				    uint8_t out[AES_BLOCK_SIZE])
+{
+	static const struct block_rshift_entry {
+		uint8_t rshift;
+		uint8_t overflow;
+	} block_rshift_table[UINT8_MAX+1] = {
+		[0x00] = { .rshift = 0x00, .overflow = 0x00 },
+		[0x01] = { .rshift = 0x00, .overflow = 0x80 },
+		[0x02] = { .rshift = 0x01, .overflow = 0x00 },
+		[0x03] = { .rshift = 0x01, .overflow = 0x80 },
+		[0x04] = { .rshift = 0x02, .overflow = 0x00 },
+		[0x05] = { .rshift = 0x02, .overflow = 0x80 },
+		[0x06] = { .rshift = 0x03, .overflow = 0x00 },
+		[0x07] = { .rshift = 0x03, .overflow = 0x80 },
+		[0x08] = { .rshift = 0x04, .overflow = 0x00 },
+		[0x09] = { .rshift = 0x04, .overflow = 0x80 },
+		[0x0a] = { .rshift = 0x05, .overflow = 0x00 },
+		[0x0b] = { .rshift = 0x05, .overflow = 0x80 },
+		[0x0c] = { .rshift = 0x06, .overflow = 0x00 },
+		[0x0d] = { .rshift = 0x06, .overflow = 0x80 },
+		[0x0e] = { .rshift = 0x07, .overflow = 0x00 },
+		[0x0f] = { .rshift = 0x07, .overflow = 0x80 },
+		[0x10] = { .rshift = 0x08, .overflow = 0x00 },
+		[0x11] = { .rshift = 0x08, .overflow = 0x80 },
+		[0x12] = { .rshift = 0x09, .overflow = 0x00 },
+		[0x13] = { .rshift = 0x09, .overflow = 0x80 },
+		[0x14] = { .rshift = 0x0a, .overflow = 0x00 },
+		[0x15] = { .rshift = 0x0a, .overflow = 0x80 },
+		[0x16] = { .rshift = 0x0b, .overflow = 0x00 },
+		[0x17] = { .rshift = 0x0b, .overflow = 0x80 },
+		[0x18] = { .rshift = 0x0c, .overflow = 0x00 },
+		[0x19] = { .rshift = 0x0c, .overflow = 0x80 },
+		[0x1a] = { .rshift = 0x0d, .overflow = 0x00 },
+		[0x1b] = { .rshift = 0x0d, .overflow = 0x80 },
+		[0x1c] = { .rshift = 0x0e, .overflow = 0x00 },
+		[0x1d] = { .rshift = 0x0e, .overflow = 0x80 },
+		[0x1e] = { .rshift = 0x0f, .overflow = 0x00 },
+		[0x1f] = { .rshift = 0x0f, .overflow = 0x80 },
+		[0x20] = { .rshift = 0x10, .overflow = 0x00 },
+		[0x21] = { .rshift = 0x10, .overflow = 0x80 },
+		[0x22] = { .rshift = 0x11, .overflow = 0x00 },
+		[0x23] = { .rshift = 0x11, .overflow = 0x80 },
+		[0x24] = { .rshift = 0x12, .overflow = 0x00 },
+		[0x25] = { .rshift = 0x12, .overflow = 0x80 },
+		[0x26] = { .rshift = 0x13, .overflow = 0x00 },
+		[0x27] = { .rshift = 0x13, .overflow = 0x80 },
+		[0x28] = { .rshift = 0x14, .overflow = 0x00 },
+		[0x29] = { .rshift = 0x14, .overflow = 0x80 },
+		[0x2a] = { .rshift = 0x15, .overflow = 0x00 },
+		[0x2b] = { .rshift = 0x15, .overflow = 0x80 },
+		[0x2c] = { .rshift = 0x16, .overflow = 0x00 },
+		[0x2d] = { .rshift = 0x16, .overflow = 0x80 },
+		[0x2e] = { .rshift = 0x17, .overflow = 0x00 },
+		[0x2f] = { .rshift = 0x17, .overflow = 0x80 },
+		[0x30] = { .rshift = 0x18, .overflow = 0x00 },
+		[0x31] = { .rshift = 0x18, .overflow = 0x80 },
+		[0x32] = { .rshift = 0x19, .overflow = 0x00 },
+		[0x33] = { .rshift = 0x19, .overflow = 0x80 },
+		[0x34] = { .rshift = 0x1a, .overflow = 0x00 },
+		[0x35] = { .rshift = 0x1a, .overflow = 0x80 },
+		[0x36] = { .rshift = 0x1b, .overflow = 0x00 },
+		[0x37] = { .rshift = 0x1b, .overflow = 0x80 },
+		[0x38] = { .rshift = 0x1c, .overflow = 0x00 },
+		[0x39] = { .rshift = 0x1c, .overflow = 0x80 },
+		[0x3a] = { .rshift = 0x1d, .overflow = 0x00 },
+		[0x3b] = { .rshift = 0x1d, .overflow = 0x80 },
+		[0x3c] = { .rshift = 0x1e, .overflow = 0x00 },
+		[0x3d] = { .rshift = 0x1e, .overflow = 0x80 },
+		[0x3e] = { .rshift = 0x1f, .overflow = 0x00 },
+		[0x3f] = { .rshift = 0x1f, .overflow = 0x80 },
+		[0x40] = { .rshift = 0x20, .overflow = 0x00 },
+		[0x41] = { .rshift = 0x20, .overflow = 0x80 },
+		[0x42] = { .rshift = 0x21, .overflow = 0x00 },
+		[0x43] = { .rshift = 0x21, .overflow = 0x80 },
+		[0x44] = { .rshift = 0x22, .overflow = 0x00 },
+		[0x45] = { .rshift = 0x22, .overflow = 0x80 },
+		[0x46] = { .rshift = 0x23, .overflow = 0x00 },
+		[0x47] = { .rshift = 0x23, .overflow = 0x80 },
+		[0x48] = { .rshift = 0x24, .overflow = 0x00 },
+		[0x49] = { .rshift = 0x24, .overflow = 0x80 },
+		[0x4a] = { .rshift = 0x25, .overflow = 0x00 },
+		[0x4b] = { .rshift = 0x25, .overflow = 0x80 },
+		[0x4c] = { .rshift = 0x26, .overflow = 0x00 },
+		[0x4d] = { .rshift = 0x26, .overflow = 0x80 },
+		[0x4e] = { .rshift = 0x27, .overflow = 0x00 },
+		[0x4f] = { .rshift = 0x27, .overflow = 0x80 },
+		[0x50] = { .rshift = 0x28, .overflow = 0x00 },
+		[0x51] = { .rshift = 0x28, .overflow = 0x80 },
+		[0x52] = { .rshift = 0x29, .overflow = 0x00 },
+		[0x53] = { .rshift = 0x29, .overflow = 0x80 },
+		[0x54] = { .rshift = 0x2a, .overflow = 0x00 },
+		[0x55] = { .rshift = 0x2a, .overflow = 0x80 },
+		[0x56] = { .rshift = 0x2b, .overflow = 0x00 },
+		[0x57] = { .rshift = 0x2b, .overflow = 0x80 },
+		[0x58] = { .rshift = 0x2c, .overflow = 0x00 },
+		[0x59] = { .rshift = 0x2c, .overflow = 0x80 },
+		[0x5a] = { .rshift = 0x2d, .overflow = 0x00 },
+		[0x5b] = { .rshift = 0x2d, .overflow = 0x80 },
+		[0x5c] = { .rshift = 0x2e, .overflow = 0x00 },
+		[0x5d] = { .rshift = 0x2e, .overflow = 0x80 },
+		[0x5e] = { .rshift = 0x2f, .overflow = 0x00 },
+		[0x5f] = { .rshift = 0x2f, .overflow = 0x80 },
+		[0x60] = { .rshift = 0x30, .overflow = 0x00 },
+		[0x61] = { .rshift = 0x30, .overflow = 0x80 },
+		[0x62] = { .rshift = 0x31, .overflow = 0x00 },
+		[0x63] = { .rshift = 0x31, .overflow = 0x80 },
+		[0x64] = { .rshift = 0x32, .overflow = 0x00 },
+		[0x65] = { .rshift = 0x32, .overflow = 0x80 },
+		[0x66] = { .rshift = 0x33, .overflow = 0x00 },
+		[0x67] = { .rshift = 0x33, .overflow = 0x80 },
+		[0x68] = { .rshift = 0x34, .overflow = 0x00 },
+		[0x69] = { .rshift = 0x34, .overflow = 0x80 },
+		[0x6a] = { .rshift = 0x35, .overflow = 0x00 },
+		[0x6b] = { .rshift = 0x35, .overflow = 0x80 },
+		[0x6c] = { .rshift = 0x36, .overflow = 0x00 },
+		[0x6d] = { .rshift = 0x36, .overflow = 0x80 },
+		[0x6e] = { .rshift = 0x37, .overflow = 0x00 },
+		[0x6f] = { .rshift = 0x37, .overflow = 0x80 },
+		[0x70] = { .rshift = 0x38, .overflow = 0x00 },
+		[0x71] = { .rshift = 0x38, .overflow = 0x80 },
+		[0x72] = { .rshift = 0x39, .overflow = 0x00 },
+		[0x73] = { .rshift = 0x39, .overflow = 0x80 },
+		[0x74] = { .rshift = 0x3a, .overflow = 0x00 },
+		[0x75] = { .rshift = 0x3a, .overflow = 0x80 },
+		[0x76] = { .rshift = 0x3b, .overflow = 0x00 },
+		[0x77] = { .rshift = 0x3b, .overflow = 0x80 },
+		[0x78] = { .rshift = 0x3c, .overflow = 0x00 },
+		[0x79] = { .rshift = 0x3c, .overflow = 0x80 },
+		[0x7a] = { .rshift = 0x3d, .overflow = 0x00 },
+		[0x7b] = { .rshift = 0x3d, .overflow = 0x80 },
+		[0x7c] = { .rshift = 0x3e, .overflow = 0x00 },
+		[0x7d] = { .rshift = 0x3e, .overflow = 0x80 },
+		[0x7e] = { .rshift = 0x3f, .overflow = 0x00 },
+		[0x7f] = { .rshift = 0x3f, .overflow = 0x80 },
+		[0x80] = { .rshift = 0x40, .overflow = 0x00 },
+		[0x81] = { .rshift = 0x40, .overflow = 0x80 },
+		[0x82] = { .rshift = 0x41, .overflow = 0x00 },
+		[0x83] = { .rshift = 0x41, .overflow = 0x80 },
+		[0x84] = { .rshift = 0x42, .overflow = 0x00 },
+		[0x85] = { .rshift = 0x42, .overflow = 0x80 },
+		[0x86] = { .rshift = 0x43, .overflow = 0x00 },
+		[0x87] = { .rshift = 0x43, .overflow = 0x80 },
+		[0x88] = { .rshift = 0x44, .overflow = 0x00 },
+		[0x89] = { .rshift = 0x44, .overflow = 0x80 },
+		[0x8a] = { .rshift = 0x45, .overflow = 0x00 },
+		[0x8b] = { .rshift = 0x45, .overflow = 0x80 },
+		[0x8c] = { .rshift = 0x46, .overflow = 0x00 },
+		[0x8d] = { .rshift = 0x46, .overflow = 0x80 },
+		[0x8e] = { .rshift = 0x47, .overflow = 0x00 },
+		[0x8f] = { .rshift = 0x47, .overflow = 0x80 },
+		[0x90] = { .rshift = 0x48, .overflow = 0x00 },
+		[0x91] = { .rshift = 0x48, .overflow = 0x80 },
+		[0x92] = { .rshift = 0x49, .overflow = 0x00 },
+		[0x93] = { .rshift = 0x49, .overflow = 0x80 },
+		[0x94] = { .rshift = 0x4a, .overflow = 0x00 },
+		[0x95] = { .rshift = 0x4a, .overflow = 0x80 },
+		[0x96] = { .rshift = 0x4b, .overflow = 0x00 },
+		[0x97] = { .rshift = 0x4b, .overflow = 0x80 },
+		[0x98] = { .rshift = 0x4c, .overflow = 0x00 },
+		[0x99] = { .rshift = 0x4c, .overflow = 0x80 },
+		[0x9a] = { .rshift = 0x4d, .overflow = 0x00 },
+		[0x9b] = { .rshift = 0x4d, .overflow = 0x80 },
+		[0x9c] = { .rshift = 0x4e, .overflow = 0x00 },
+		[0x9d] = { .rshift = 0x4e, .overflow = 0x80 },
+		[0x9e] = { .rshift = 0x4f, .overflow = 0x00 },
+		[0x9f] = { .rshift = 0x4f, .overflow = 0x80 },
+		[0xa0] = { .rshift = 0x50, .overflow = 0x00 },
+		[0xa1] = { .rshift = 0x50, .overflow = 0x80 },
+		[0xa2] = { .rshift = 0x51, .overflow = 0x00 },
+		[0xa3] = { .rshift = 0x51, .overflow = 0x80 },
+		[0xa4] = { .rshift = 0x52, .overflow = 0x00 },
+		[0xa5] = { .rshift = 0x52, .overflow = 0x80 },
+		[0xa6] = { .rshift = 0x53, .overflow = 0x00 },
+		[0xa7] = { .rshift = 0x53, .overflow = 0x80 },
+		[0xa8] = { .rshift = 0x54, .overflow = 0x00 },
+		[0xa9] = { .rshift = 0x54, .overflow = 0x80 },
+		[0xaa] = { .rshift = 0x55, .overflow = 0x00 },
+		[0xab] = { .rshift = 0x55, .overflow = 0x80 },
+		[0xac] = { .rshift = 0x56, .overflow = 0x00 },
+		[0xad] = { .rshift = 0x56, .overflow = 0x80 },
+		[0xae] = { .rshift = 0x57, .overflow = 0x00 },
+		[0xaf] = { .rshift = 0x57, .overflow = 0x80 },
+		[0xb0] = { .rshift = 0x58, .overflow = 0x00 },
+		[0xb1] = { .rshift = 0x58, .overflow = 0x80 },
+		[0xb2] = { .rshift = 0x59, .overflow = 0x00 },
+		[0xb3] = { .rshift = 0x59, .overflow = 0x80 },
+		[0xb4] = { .rshift = 0x5a, .overflow = 0x00 },
+		[0xb5] = { .rshift = 0x5a, .overflow = 0x80 },
+		[0xb6] = { .rshift = 0x5b, .overflow = 0x00 },
+		[0xb7] = { .rshift = 0x5b, .overflow = 0x80 },
+		[0xb8] = { .rshift = 0x5c, .overflow = 0x00 },
+		[0xb9] = { .rshift = 0x5c, .overflow = 0x80 },
+		[0xba] = { .rshift = 0x5d, .overflow = 0x00 },
+		[0xbb] = { .rshift = 0x5d, .overflow = 0x80 },
+		[0xbc] = { .rshift = 0x5e, .overflow = 0x00 },
+		[0xbd] = { .rshift = 0x5e, .overflow = 0x80 },
+		[0xbe] = { .rshift = 0x5f, .overflow = 0x00 },
+		[0xbf] = { .rshift = 0x5f, .overflow = 0x80 },
+		[0xc0] = { .rshift = 0x60, .overflow = 0x00 },
+		[0xc1] = { .rshift = 0x60, .overflow = 0x80 },
+		[0xc2] = { .rshift = 0x61, .overflow = 0x00 },
+		[0xc3] = { .rshift = 0x61, .overflow = 0x80 },
+		[0xc4] = { .rshift = 0x62, .overflow = 0x00 },
+		[0xc5] = { .rshift = 0x62, .overflow = 0x80 },
+		[0xc6] = { .rshift = 0x63, .overflow = 0x00 },
+		[0xc7] = { .rshift = 0x63, .overflow = 0x80 },
+		[0xc8] = { .rshift = 0x64, .overflow = 0x00 },
+		[0xc9] = { .rshift = 0x64, .overflow = 0x80 },
+		[0xca] = { .rshift = 0x65, .overflow = 0x00 },
+		[0xcb] = { .rshift = 0x65, .overflow = 0x80 },
+		[0xcc] = { .rshift = 0x66, .overflow = 0x00 },
+		[0xcd] = { .rshift = 0x66, .overflow = 0x80 },
+		[0xce] = { .rshift = 0x67, .overflow = 0x00 },
+		[0xcf] = { .rshift = 0x67, .overflow = 0x80 },
+		[0xd0] = { .rshift = 0x68, .overflow = 0x00 },
+		[0xd1] = { .rshift = 0x68, .overflow = 0x80 },
+		[0xd2] = { .rshift = 0x69, .overflow = 0x00 },
+		[0xd3] = { .rshift = 0x69, .overflow = 0x80 },
+		[0xd4] = { .rshift = 0x6a, .overflow = 0x00 },
+		[0xd5] = { .rshift = 0x6a, .overflow = 0x80 },
+		[0xd6] = { .rshift = 0x6b, .overflow = 0x00 },
+		[0xd7] = { .rshift = 0x6b, .overflow = 0x80 },
+		[0xd8] = { .rshift = 0x6c, .overflow = 0x00 },
+		[0xd9] = { .rshift = 0x6c, .overflow = 0x80 },
+		[0xda] = { .rshift = 0x6d, .overflow = 0x00 },
+		[0xdb] = { .rshift = 0x6d, .overflow = 0x80 },
+		[0xdc] = { .rshift = 0x6e, .overflow = 0x00 },
+		[0xdd] = { .rshift = 0x6e, .overflow = 0x80 },
+		[0xde] = { .rshift = 0x6f, .overflow = 0x00 },
+		[0xdf] = { .rshift = 0x6f, .overflow = 0x80 },
+		[0xe0] = { .rshift = 0x70, .overflow = 0x00 },
+		[0xe1] = { .rshift = 0x70, .overflow = 0x80 },
+		[0xe2] = { .rshift = 0x71, .overflow = 0x00 },
+		[0xe3] = { .rshift = 0x71, .overflow = 0x80 },
+		[0xe4] = { .rshift = 0x72, .overflow = 0x00 },
+		[0xe5] = { .rshift = 0x72, .overflow = 0x80 },
+		[0xe6] = { .rshift = 0x73, .overflow = 0x00 },
+		[0xe7] = { .rshift = 0x73, .overflow = 0x80 },
+		[0xe8] = { .rshift = 0x74, .overflow = 0x00 },
+		[0xe9] = { .rshift = 0x74, .overflow = 0x80 },
+		[0xea] = { .rshift = 0x75, .overflow = 0x00 },
+		[0xeb] = { .rshift = 0x75, .overflow = 0x80 },
+		[0xec] = { .rshift = 0x76, .overflow = 0x00 },
+		[0xed] = { .rshift = 0x76, .overflow = 0x80 },
+		[0xee] = { .rshift = 0x77, .overflow = 0x00 },
+		[0xef] = { .rshift = 0x77, .overflow = 0x80 },
+		[0xf0] = { .rshift = 0x78, .overflow = 0x00 },
+		[0xf1] = { .rshift = 0x78, .overflow = 0x80 },
+		[0xf2] = { .rshift = 0x79, .overflow = 0x00 },
+		[0xf3] = { .rshift = 0x79, .overflow = 0x80 },
+		[0xf4] = { .rshift = 0x7a, .overflow = 0x00 },
+		[0xf5] = { .rshift = 0x7a, .overflow = 0x80 },
+		[0xf6] = { .rshift = 0x7b, .overflow = 0x00 },
+		[0xf7] = { .rshift = 0x7b, .overflow = 0x80 },
+		[0xf8] = { .rshift = 0x7c, .overflow = 0x00 },
+		[0xf9] = { .rshift = 0x7c, .overflow = 0x80 },
+		[0xfa] = { .rshift = 0x7d, .overflow = 0x00 },
+		[0xfb] = { .rshift = 0x7d, .overflow = 0x80 },
+		[0xfc] = { .rshift = 0x7e, .overflow = 0x00 },
+		[0xfd] = { .rshift = 0x7e, .overflow = 0x80 },
+		[0xfe] = { .rshift = 0x7f, .overflow = 0x00 },
+		[0xff] = { .rshift = 0x7f, .overflow = 0x80 },
+	};
+	uint8_t i;
+	uint8_t overflow = 0;
+
+	for (i = 0; i &lt; AES_BLOCK_SIZE; i++) {
+		const struct block_rshift_entry *e = &amp;block_rshift_table[in[i]];
+		out[i] = e-&gt;rshift | overflow;
+		overflow = e-&gt;overflow;
+	}
+}
+#endif /* LIB_CRYPTO_AES_H */
diff --git a/cmac.c b/cmac.c
new file mode 100644
index 00000000..afea79fd
--- /dev/null
+++ b/cmac.c
@@ -0,0 +1,139 @@
+/*
+   AES-CMAC-128 (rfc 4493)
+   Copyright (C) Stefan Metzmacher 2012
+   Copyright (C) Jeremy Allison 2012
+   Copyright (C) Michael Adam 2012
+   Copyright (C) 2017, Red Hat Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "cmac.h"
+#include "cmac-internal.h"
+
+#include "memxor.h"
+#include "nettle-internal.h"
+#include "macros.h"
+
+static const uint8_t const_Zero[] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
+};
+
+static const uint8_t const_Rb[] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x87
+};
+
+#define _MSB(x) (((x)[0] &amp; 0x80)?1:0)
+
+void cmac128_set_key(struct cmac128 *ctx, void *key,
+		     nettle_cipher_func *encrypt)
+{
+	memset(ctx, 0, sizeof(*ctx));
+
+	/* step 1 - generate subkeys k1 and k2 */
+	encrypt(key, 16, ctx-&gt;L, const_Zero);
+
+	if (_MSB(ctx-&gt;L) == 0) {
+		block_lshift(ctx-&gt;L, ctx-&gt;K1);
+	} else {
+		block_lshift(ctx-&gt;L, ctx-&gt;K1);
+		memxor(ctx-&gt;K1, const_Rb, 16);
+	}
+
+	if (_MSB(ctx-&gt;K1) == 0) {
+		block_lshift(ctx-&gt;K1, ctx-&gt;K2);
+	} else {
+		block_lshift(ctx-&gt;K1, ctx-&gt;K2);
+		memxor(ctx-&gt;K2, const_Rb, 16);
+	}
+}
+
+#define MIN(x,y) ((x)&lt;(y)?(x):(y))
+
+void cmac128_update(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    size_t msg_len, const uint8_t *msg)
+{
+	/*
+	 * check if we expand the block
+	 */
+	if (ctx-&gt;last_len &lt; 16) {
+		size_t len = MIN(16 - ctx-&gt;last_len, msg_len);
+		memcpy(&amp;ctx-&gt;last[ctx-&gt;last_len], msg, len);
+		msg += len;
+		msg_len -= len;
+		ctx-&gt;last_len += len;
+	}
+
+	if (msg_len == 0) {
+		/* if it is still the last block, we are done */
+		return;
+	}
+
+	/*
+	 * now checksum everything but the last block
+	 */
+	memxor3(ctx-&gt;Y, ctx-&gt;X, ctx-&gt;last, 16);
+	encrypt(key, 16, ctx-&gt;X, ctx-&gt;Y);
+
+	while (msg_len &gt; 16) {
+		memxor3(ctx-&gt;Y, ctx-&gt;X, msg, 16);
+		encrypt(key, 16, ctx-&gt;X, ctx-&gt;Y);
+		msg += 16;
+		msg_len -= 16;
+	}
+
+	/*
+	 * copy the last block, it will be processed in
+	 * cmac128_digest().
+	 */
+	memset(ctx-&gt;last, 0, sizeof(ctx-&gt;last));
+	memcpy(ctx-&gt;last, msg, msg_len);
+	ctx-&gt;last_len = msg_len;
+}
+
+void cmac128_digest(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *out)
+{
+	uint8_t tmp[16];
+
+	if (ctx-&gt;last_len &lt; 16) {
+		ctx-&gt;last[ctx-&gt;last_len] = 0x80;
+		memxor3(tmp, ctx-&gt;last, ctx-&gt;K2, 16);
+	} else {
+		memxor3(tmp, ctx-&gt;last, ctx-&gt;K1, 16);
+	}
+
+	memxor3(ctx-&gt;Y, tmp, ctx-&gt;X, 16);
+
+	assert(length &lt;= 16);
+	if (length == 16) {
+		encrypt(key, length, out, ctx-&gt;Y);
+	} else {
+		encrypt(key, length, tmp, ctx-&gt;Y);
+		memcpy(out, tmp, length);
+	}
+}
diff --git a/cmac.h b/cmac.h
new file mode 100644
index 00000000..832cf38d
--- /dev/null
+++ b/cmac.h
@@ -0,0 +1,117 @@
+/* cmac.h
+
+   CMAC mode, as specified in RFC4493
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   Contributed by Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_CMAC_H_INCLUDED
+#define NETTLE_CMAC_H_INCLUDED
+
+#include "aes.h"
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define cmac128_set_key nettle_cmac128_set_key
+#define cmac128_update nettle_cmac128_update
+#define cmac128_digest nettle_cmac128_digest
+#define cmac_aes128_set_key nettle_cmac_aes128_set_key
+#define cmac_aes128_update nettle_cmac_aes128_update
+#define cmac_aes128_digest nettle_cmac_aes128_digest
+
+struct cmac128 {
+	uint8_t K1[16];
+	uint8_t K2[16];
+
+	uint8_t L[16];
+	uint8_t X[16];
+	uint8_t Y[16];
+
+	uint8_t last[16];
+	size_t last_len;
+};
+
+void cmac128_set_key(struct cmac128 *ctx, void *key,
+		     nettle_cipher_func *encrypt);
+void cmac128_update(struct cmac128 *ctx, void *key,
+		 nettle_cipher_func *encrypt,
+		 size_t msg_len, const uint8_t *msg);
+void cmac128_digest(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *out);
+
+
+#define CMAC128_CTX(type) \
+  { struct cmac128 data; type cipher; }
+
+/* NOTE: Avoid using NULL, as we don't include anything defining it. */
+#define CMAC128_SET_KEY(ctx, set_key, encrypt, cmac_key)		\
+  do {								\
+    (set_key)(&amp;(ctx)-&gt;cipher, (cmac_key));			\
+    if (0) (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,		\
+		     (uint8_t *) 0, (const uint8_t *) 0);	\
+    cmac128_set_key(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		(nettle_cipher_func *) (encrypt));		\
+  } while (0)
+
+#define CMAC128_UPDATE(ctx, encrypt, length, data)			\
+  cmac128_update(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher, \
+	      (nettle_cipher_func *)encrypt, (length), (data))
+
+#define CMAC128_DIGEST(ctx, encrypt, length, digest)			\
+  (0 ? (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,				\
+		 (uint8_t *) 0, (const uint8_t *) 0)			\
+     : cmac128_digest(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		  (nettle_cipher_func *) (encrypt),			\
+		  (length), (digest)))
+
+struct cmac_aes128_ctx CMAC128_CTX(struct aes128_ctx);
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key);
+
+void
+cmac_aes128_update(struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CMAC_H_INCLUDED */
diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index b73196b0..b9cef924 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -64,6 +64,7 @@
 #include "sha3.h"
 #include "twofish.h"
 #include "umac.h"
+#include "cmac.h"
 #include "poly1305.h"
 
 #include "nettle-meta.h"
@@ -403,7 +404,7 @@ time_umac(void)
   struct umac64_ctx ctx64;
   struct umac96_ctx ctx96;
   struct umac128_ctx ctx128;
-  
+
   uint8_t key[16];
 
   umac32_set_key (&amp;ctx32, key);
@@ -439,6 +440,24 @@ time_umac(void)
 	  time_function(bench_hash, &amp;info));
 }
 
+static void
+time_cmac(void)
+{
+  static uint8_t data[BENCH_BLOCK];
+  struct bench_hash_info info;
+  struct cmac_aes128_ctx ctx;
+  
+  uint8_t key[16];
+
+  cmac_aes128_set_key (&amp;ctx, key);
+  info.ctx = 
+  info.update = (nettle_hash_update_func *) cmac_aes128_update;
+  info.data = data;
+
+  display("cmac-aes128", "update", AES_BLOCK_SIZE,
+	  time_function(bench_hash, &amp;info));
+}
+
 static void
 time_poly1305_aes(void)
 {
@@ -843,6 +862,9 @@ main(int argc, char **argv)
   if (!alg || strstr ("umac", alg))
     time_umac();
 
+  if (!alg || strstr ("cmac", alg))
+    time_cmac();
+
   if (!alg || strstr ("poly1305-aes", alg))
     time_poly1305_aes();
 
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 1f780310..c7e04cb4 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -130,6 +130,9 @@ eax-test$(EXEEXT): eax-test.$(OBJEXT)
 ccm-test$(EXEEXT): ccm-test.$(OBJEXT)
 	$(LINK) ccm-test.$(OBJEXT) $(TEST_OBJS) -o ccm-test$(EXEEXT)
 
+cmac-test$(EXEEXT): cmac-test.$(OBJEXT)
+	$(LINK) cmac-test.$(OBJEXT) $(TEST_OBJS) -o cmac-test$(EXEEXT)
+
 poly1305-test$(EXEEXT): poly1305-test.$(OBJEXT)
 	$(LINK) poly1305-test.$(OBJEXT) $(TEST_OBJS) -o poly1305-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 3117d66d..dd1ecf41 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -26,6 +26,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    serpent-test.c twofish-test.c version-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c cfb-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
+		    cmac-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
new file mode 100644
index 00000000..45cad3c2
--- /dev/null
+++ b/testsuite/cmac-test.c
@@ -0,0 +1,57 @@
+#include "testutils.h"
+#include "nettle-internal.h"
+#include "cmac.h"
+
+static void
+test_cmac_hash (const struct tstring *key, const struct tstring *msg, const struct tstring *ref)
+{
+  struct cmac_aes128_ctx ctx;
+  uint8_t digest[16];
+
+  ASSERT (ref-&gt;length == sizeof(digest));
+  ASSERT (key-&gt;length == 16);
+  cmac_aes128_set_key (&amp;ctx, key-&gt;data);
+  cmac_aes128_update (&amp;ctx, msg-&gt;length, msg-&gt;data);
+  cmac_aes128_digest (&amp;ctx, sizeof(digest), digest);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, digest))
+    {
+      fprintf (stderr, "cmac_hash failed, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, digest);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+}
+
+void
+test_main(void)
+{
+  /* 
+   * CMAC-AES Test Vectors from RFC4493.
+   */
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SDATA(""),
+		  SHEX("bb1d6929e95937287fa37d129b756746"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
+		  SHEX("070a16b46b4d4144f79bdd9dd04a287c"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("dfa66747de9ae63030ca32611497c827"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411e5fbc1191a0a52ef"
+		       "f69f2445df4f9b17ad2b417be66c3710"),
+		  SHEX("51f0bebf7e3b9d92fc49741779363cfe"));
+}
+
-- 
2.14.3



</body></email><email><emailId>20180110102455</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-10 10:24:55-0400</timestampReceived><subject>Re: cmac</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt;  The attached patch brings support for AES-128-CMAC. The code is based
&gt; on the samba code.

Nice. I think I'll have to read up a bit to understand what it's doing.

&gt; The rshift and lshift functions come from the AES
&gt; implementation bundled with samba.

These to just a single bit right or left shift of a 16-byte block? To me
it seems odd to do that with a table lookup for each byte.

May be natural as functions operating on nettle_block16, and if platform
endianness is right, could do the shifts in units of unsigned long or
uint64_t. Shift and mask on 64-bit values may be preferable also if the
endiannness is wrong.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180112105154</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-01-12 10:51:54-0400</timestampReceived><subject>Re: cmac</subject><body>

On Wed, 2018-01-10 at 11:24 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; 
&gt; &gt;  The attached patch brings support for AES-128-CMAC. The code is
&gt; &gt; based
&gt; &gt; on the samba code.
&gt; 
&gt; Nice. I think I'll have to read up a bit to understand what it's
&gt; doing.
&gt; 
&gt; &gt; The rshift and lshift functions come from the AES
&gt; &gt; implementation bundled with samba.
&gt; 
&gt; These to just a single bit right or left shift of a 16-byte block? To
&gt; me
&gt; it seems odd to do that with a table lookup for each byte.

Indeed, and I don't see any obvious benefit of that code. I've replaced
it with a simpler version.

&gt; May be natural as functions operating on nettle_block16, and if
&gt; platform
&gt; endianness is right, could do the shifts in units of unsigned long or
&gt; uint64_t. Shift and mask on 64-bit values may be preferable also if
&gt; the endiannness is wrong.

I've now used the nettle_block16 to ensure values are aligned. I didn't
try to optimize the shift as it is only used on set_key which doesn't
really affect performance.

regards,
Nikos

["0001-Added-support-for-CMAC.patch" (0001-Added-support-for-CMAC.patch)]

From 7ca5eb00a2a3d3b07f8bec2172975d5a4cb58cc0 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 10 Jan 2018 09:29:17 +0100
Subject: [PATCH] Added support for CMAC

That adds support for CMAC as a generic framework for
128-bit block and key ciphers, as well as API for AES-128-CMAC.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 Makefile.in                 |   3 +
 cmac-aes128.c               |  60 ++++++++++++++++++
 cmac.c                      | 150 ++++++++++++++++++++++++++++++++++++++++++++
 cmac.h                      | 117 ++++++++++++++++++++++++++++++++++
 examples/nettle-benchmark.c |  24 ++++++-
 testsuite/.test-rules.make  |   3 +
 testsuite/Makefile.in       |   1 +
 testsuite/cmac-test.c       |  57 +++++++++++++++++
 8 files changed, 414 insertions(+), 1 deletion(-)
 create mode 100644 cmac-aes128.c
 create mode 100644 cmac.c
 create mode 100644 cmac.h
 create mode 100644 testsuite/cmac-test.c

diff --git a/Makefile.in b/Makefile.in
index 6a0c13ec..8d6219b6 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -103,6 +103,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-aes256.c gcm-aes256-meta.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
+		 cmac.c cmac-aes128.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
@@ -195,6 +196,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  gcm.h gosthash94.h hmac.h \
 	  knuth-lfib.h hkdf.h \
 	  macros.h \
+	  cmac.h \
 	  md2.h md4.h \
 	  md5.h md5-compat.h \
 	  memops.h memxor.h \
@@ -226,6 +228,7 @@ DISTFILES = $(SOURCES) $(HEADERS) getopt.h getopt_int.h \
 	nettle.pc.in hogweed.pc.in \
 	$(des_headers) descore.README \
 	aes-internal.h camellia-internal.h serpent-internal.h \
+	cmac-internal.h \
 	cast128_sboxes.h desinfo.h desCode.h \
 	memxor-internal.h nettle-internal.h nettle-write.h \
 	gmp-glue.h ecc-internal.h fat-setup.h \
diff --git a/cmac-aes128.c b/cmac-aes128.c
new file mode 100644
index 00000000..e53e114e
--- /dev/null
+++ b/cmac-aes128.c
@@ -0,0 +1,60 @@
+/* cmac-aes128.c
+
+   CMAC using AES128 as the underlying cipher.
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "cmac.h"
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key)
+{
+  CMAC128_SET_KEY(ctx, aes128_set_encrypt_key, aes128_encrypt, key);
+}
+
+void
+cmac_aes128_update (struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  CMAC128_UPDATE (ctx, aes128_encrypt, length, data);
+}
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  CMAC128_DIGEST(ctx, aes128_encrypt, length, digest);
+}
diff --git a/cmac.c b/cmac.c
new file mode 100644
index 00000000..b4886808
--- /dev/null
+++ b/cmac.c
@@ -0,0 +1,150 @@
+/*
+   AES-CMAC-128 (rfc 4493)
+   Copyright (C) Stefan Metzmacher 2012
+   Copyright (C) Jeremy Allison 2012
+   Copyright (C) Michael Adam 2012
+   Copyright (C) 2017, Red Hat Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "cmac.h"
+
+#include "memxor.h"
+#include "nettle-internal.h"
+#include "macros.h"
+
+static const uint8_t const_Zero[] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
+};
+
+static const uint8_t const_Rb[] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x87
+};
+
+static inline void block_lshift(const union nettle_block16 *in,
+				union nettle_block16 *out)
+{
+	uint64_t b1 = READ_UINT64(in-&gt;b);
+	uint64_t b2 = READ_UINT64(in-&gt;b+8);
+	unsigned overflow = b2 &amp; 0x8000000000000000;
+
+	b1 &lt;&lt;= 1;
+	b2 &lt;&lt;= 1;
+
+	if (overflow)
+		b1 |= 0x01;
+
+	WRITE_UINT64(out-&gt;b, b1);
+	WRITE_UINT64(out-&gt;b+8, b2);
+
+}
+
+void cmac128_set_key(struct cmac128 *ctx, void *key,
+		     nettle_cipher_func *encrypt)
+{
+	memset(ctx, 0, sizeof(*ctx));
+
+	/* step 1 - generate subkeys k1 and k2 */
+	encrypt(key, 16, ctx-&gt;L.b, const_Zero);
+
+	block_lshift(ctx-&gt;L.b, ctx-&gt;K1.b);
+	if (ctx-&gt;L.b[0] &amp; 0x80) {
+		memxor(ctx-&gt;K1.b, const_Rb, 16);
+	}
+
+	block_lshift(ctx-&gt;K1.b, ctx-&gt;K2.b);
+	if (ctx-&gt;K1.b[0] &amp; 0x80) {
+		memxor(ctx-&gt;K2.b, const_Rb, 16);
+	}
+}
+
+#define MIN(x,y) ((x)&lt;(y)?(x):(y))
+
+void cmac128_update(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    size_t msg_len, const uint8_t *msg)
+{
+	/*
+	 * check if we expand the block
+	 */
+	if (ctx-&gt;last_len &lt; 16) {
+		size_t len = MIN(16 - ctx-&gt;last_len, msg_len);
+		memcpy(&amp;ctx-&gt;last.b[ctx-&gt;last_len], msg, len);
+		msg += len;
+		msg_len -= len;
+		ctx-&gt;last_len += len;
+	}
+
+	if (msg_len == 0) {
+		/* if it is still the last block, we are done */
+		return;
+	}
+
+	/*
+	 * now checksum everything but the last block
+	 */
+	memxor3(ctx-&gt;Y.b, ctx-&gt;X.b, ctx-&gt;last.b, 16);
+	encrypt(key, 16, ctx-&gt;X.b, ctx-&gt;Y.b);
+
+	while (msg_len &gt; 16) {
+		memxor3(ctx-&gt;Y.b, ctx-&gt;X.b, msg, 16);
+		encrypt(key, 16, ctx-&gt;X.b, ctx-&gt;Y.b);
+		msg += 16;
+		msg_len -= 16;
+	}
+
+	/*
+	 * copy the last block, it will be processed in
+	 * cmac128_digest().
+	 */
+	memset(ctx-&gt;last.b, 0, sizeof(ctx-&gt;last.b));
+	memcpy(ctx-&gt;last.b, msg, msg_len);
+	ctx-&gt;last_len = msg_len;
+}
+
+void cmac128_digest(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *out)
+{
+	uint8_t tmp[16];
+
+	if (ctx-&gt;last_len &lt; 16) {
+		ctx-&gt;last.b[ctx-&gt;last_len] = 0x80;
+		memxor3(tmp, ctx-&gt;last.b, ctx-&gt;K2.b, 16);
+	} else {
+		memxor3(tmp, ctx-&gt;last.b, ctx-&gt;K1.b, 16);
+	}
+
+	memxor3(ctx-&gt;Y.b, tmp, ctx-&gt;X.b, 16);
+
+	assert(length &lt;= 16);
+	if (length == 16) {
+		encrypt(key, length, out, ctx-&gt;Y.b);
+	} else {
+		encrypt(key, length, tmp, ctx-&gt;Y.b);
+		memcpy(out, tmp, length);
+	}
+}
diff --git a/cmac.h b/cmac.h
new file mode 100644
index 00000000..5f0553b7
--- /dev/null
+++ b/cmac.h
@@ -0,0 +1,117 @@
+/* cmac.h
+
+   CMAC mode, as specified in RFC4493
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   Contributed by Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_CMAC_H_INCLUDED
+#define NETTLE_CMAC_H_INCLUDED
+
+#include "aes.h"
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define cmac128_set_key nettle_cmac128_set_key
+#define cmac128_update nettle_cmac128_update
+#define cmac128_digest nettle_cmac128_digest
+#define cmac_aes128_set_key nettle_cmac_aes128_set_key
+#define cmac_aes128_update nettle_cmac_aes128_update
+#define cmac_aes128_digest nettle_cmac_aes128_digest
+
+struct cmac128 {
+	union nettle_block16 K1;
+	union nettle_block16 K2;
+
+	union nettle_block16 L;
+	union nettle_block16 X;
+	union nettle_block16 Y;
+
+	union nettle_block16 last;
+	size_t last_len;
+};
+
+void cmac128_set_key(struct cmac128 *ctx, void *key,
+		     nettle_cipher_func *encrypt);
+void cmac128_update(struct cmac128 *ctx, void *key,
+		 nettle_cipher_func *encrypt,
+		 size_t msg_len, const uint8_t *msg);
+void cmac128_digest(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *out);
+
+
+#define CMAC128_CTX(type) \
+  { struct cmac128 data; type cipher; }
+
+/* NOTE: Avoid using NULL, as we don't include anything defining it. */
+#define CMAC128_SET_KEY(ctx, set_key, encrypt, cmac_key)		\
+  do {								\
+    (set_key)(&amp;(ctx)-&gt;cipher, (cmac_key));			\
+    if (0) (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,		\
+		     (uint8_t *) 0, (const uint8_t *) 0);	\
+    cmac128_set_key(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		(nettle_cipher_func *) (encrypt));		\
+  } while (0)
+
+#define CMAC128_UPDATE(ctx, encrypt, length, data)			\
+  cmac128_update(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher, \
+	      (nettle_cipher_func *)encrypt, (length), (data))
+
+#define CMAC128_DIGEST(ctx, encrypt, length, digest)			\
+  (0 ? (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,				\
+		 (uint8_t *) 0, (const uint8_t *) 0)			\
+     : cmac128_digest(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		  (nettle_cipher_func *) (encrypt),			\
+		  (length), (digest)))
+
+struct cmac_aes128_ctx CMAC128_CTX(struct aes128_ctx);
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key);
+
+void
+cmac_aes128_update(struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CMAC_H_INCLUDED */
diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index b73196b0..b9cef924 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -64,6 +64,7 @@
 #include "sha3.h"
 #include "twofish.h"
 #include "umac.h"
+#include "cmac.h"
 #include "poly1305.h"
 
 #include "nettle-meta.h"
@@ -403,7 +404,7 @@ time_umac(void)
   struct umac64_ctx ctx64;
   struct umac96_ctx ctx96;
   struct umac128_ctx ctx128;
-  
+
   uint8_t key[16];
 
   umac32_set_key (&amp;ctx32, key);
@@ -439,6 +440,24 @@ time_umac(void)
 	  time_function(bench_hash, &amp;info));
 }
 
+static void
+time_cmac(void)
+{
+  static uint8_t data[BENCH_BLOCK];
+  struct bench_hash_info info;
+  struct cmac_aes128_ctx ctx;
+  
+  uint8_t key[16];
+
+  cmac_aes128_set_key (&amp;ctx, key);
+  info.ctx = 
+  info.update = (nettle_hash_update_func *) cmac_aes128_update;
+  info.data = data;
+
+  display("cmac-aes128", "update", AES_BLOCK_SIZE,
+	  time_function(bench_hash, &amp;info));
+}
+
 static void
 time_poly1305_aes(void)
 {
@@ -843,6 +862,9 @@ main(int argc, char **argv)
   if (!alg || strstr ("umac", alg))
     time_umac();
 
+  if (!alg || strstr ("cmac", alg))
+    time_cmac();
+
   if (!alg || strstr ("poly1305-aes", alg))
     time_poly1305_aes();
 
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 1f780310..c7e04cb4 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -130,6 +130,9 @@ eax-test$(EXEEXT): eax-test.$(OBJEXT)
 ccm-test$(EXEEXT): ccm-test.$(OBJEXT)
 	$(LINK) ccm-test.$(OBJEXT) $(TEST_OBJS) -o ccm-test$(EXEEXT)
 
+cmac-test$(EXEEXT): cmac-test.$(OBJEXT)
+	$(LINK) cmac-test.$(OBJEXT) $(TEST_OBJS) -o cmac-test$(EXEEXT)
+
 poly1305-test$(EXEEXT): poly1305-test.$(OBJEXT)
 	$(LINK) poly1305-test.$(OBJEXT) $(TEST_OBJS) -o poly1305-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 3117d66d..dd1ecf41 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -26,6 +26,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    serpent-test.c twofish-test.c version-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c cfb-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
+		    cmac-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
new file mode 100644
index 00000000..45cad3c2
--- /dev/null
+++ b/testsuite/cmac-test.c
@@ -0,0 +1,57 @@
+#include "testutils.h"
+#include "nettle-internal.h"
+#include "cmac.h"
+
+static void
+test_cmac_hash (const struct tstring *key, const struct tstring *msg, const struct tstring *ref)
+{
+  struct cmac_aes128_ctx ctx;
+  uint8_t digest[16];
+
+  ASSERT (ref-&gt;length == sizeof(digest));
+  ASSERT (key-&gt;length == 16);
+  cmac_aes128_set_key (&amp;ctx, key-&gt;data);
+  cmac_aes128_update (&amp;ctx, msg-&gt;length, msg-&gt;data);
+  cmac_aes128_digest (&amp;ctx, sizeof(digest), digest);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, digest))
+    {
+      fprintf (stderr, "cmac_hash failed, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, digest);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+}
+
+void
+test_main(void)
+{
+  /* 
+   * CMAC-AES Test Vectors from RFC4493.
+   */
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SDATA(""),
+		  SHEX("bb1d6929e95937287fa37d129b756746"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
+		  SHEX("070a16b46b4d4144f79bdd9dd04a287c"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("dfa66747de9ae63030ca32611497c827"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411e5fbc1191a0a52ef"
+		       "f69f2445df4f9b17ad2b417be66c3710"),
+		  SHEX("51f0bebf7e3b9d92fc49741779363cfe"));
+}
+
-- 
2.14.3



</body></email><email><emailId>20180222065420</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-22 06:54:20-0400</timestampReceived><subject>Deleting old AES api (was: Re: What should nettle-3.5 be like?)</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt;&gt; 2. Delete the old aes_* interface, in favor of aes128_, aes192_* and
&gt;&gt;    aes256_*.
&gt;
&gt; I've now made a branch for this, delete-old-aes.

And it seems building gnutls with this branch fails, see
https://gitlab.com/gnutls/nettle/-/jobs/53760965

  aes-padlock.c: In function 'padlock_aes_cipher_setkey':
  aes-padlock.c:65:17: error: storage size of 'nc' isn't known
    struct aes_ctx nc;
                   ^~

It's great to have that ci job set up.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180222104110</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-02-22 10:41:10-0400</timestampReceived><subject>Re: Deleting old AES api (was: Re: What should nettle-3.5 be like?)</subject><body>

On Thu, 2018-02-22 at 07:54 +0100, Niels Möller wrote:
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt; &gt; &gt; 2. Delete the old aes_* interface, in favor of aes128_, aes192_*
&gt; &gt; &gt; and
&gt; &gt; &gt;    aes256_*.
&gt; &gt; 
&gt; &gt; I've now made a branch for this, delete-old-aes.
&gt; 
&gt; And it seems building gnutls with this branch fails, see
&gt; https://gitlab.com/gnutls/nettle/-/jobs/53760965
&gt; 
&gt;   aes-padlock.c: In function 'padlock_aes_cipher_setkey':
&gt;   aes-padlock.c:65:17: error: storage size of 'nc' isn't known
&gt;     struct aes_ctx nc;
&gt;                    ^~
&gt; 
&gt; It's great to have that ci job set up.

Thanks for bringing that up. I have a quick fix for that, although I no
longer have such systems for checking. I dropped AES-192 accelerated
support as part of that patch as well.
https://gitlab.com/gnutls/gnutls/merge_requests/602

How widely used are these macros? Searching debian code:
https://codesearch.debian.net/search?q=aes_set_encrypt_key&amp;page=1&amp;perpkg=1

seems to show gnutls (in fips140 drbg code), stoken, qemu, rdup,
filezilla, pike, cmake, uanytun, haskell-bindings-nettle, libarchive,
anytun, and mosh.

That seems to be quite a popular API and removing it would break those
projects. Why not keep it as backwards compatible and mark it as
deprecated with a macro (copied from gnutls):

#ifdef __GNUC__
# define _GNUTLS_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 +
__GNUC_PATCHLEVEL__)

# if _GNUTLS_GCC_VERSION &gt;= 30100
#  define _GNUTLS_GCC_ATTR_DEPRECATED __attribute__ ((__deprecated__))
# endif
#endif


#ifndef _GNUTLS_GCC_ATTR_DEPRECATED
#define _GNUTLS_GCC_ATTR_DEPRECATED
#endif
?

regards,
Nikos


</body></email><email><emailId>20180222105115</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-02-22 10:51:15-0400</timestampReceived><subject>Re: Deleting old AES api (was: Re: What should nettle-3.5 be like?)</subject><body>

Hello,

2018-02-22 13:41 GMT+03:00 Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;:
&gt; On Thu, 2018-02-22 at 07:54 +0100, Niels Möller wrote:
&gt;&gt; nisse@lysator.liu.se (Niels Möller) writes:

&gt; Thanks for bringing that up. I have a quick fix for that, although I no
&gt; longer have such systems for checking.

Do you need one? Maybe we can buy you smth. from eBay if it's not too costly?


&gt; seems to show gnutls (in fips140 drbg code), stoken, qemu, rdup,
&gt; filezilla, pike, cmake, uanytun, haskell-bindings-nettle, libarchive,
&gt; anytun, and mosh.
&gt;
&gt; That seems to be quite a popular API and removing it would break those
&gt; projects. Why not keep it as backwards compatible and mark it as
&gt; deprecated with a macro (copied from gnutls):

Dropping API is always painfull. Maybe it can be verbally deprecated now
and removed before 4.0 in future?

It is not possible to deprecate a macro. Deprecation attributes are handled
by compiler, while macros are resolved by preprocessor.

&gt;
&gt; #ifdef __GNUC__
&gt; # define _GNUTLS_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 +
&gt; __GNUC_PATCHLEVEL__)
&gt;
&gt; # if _GNUTLS_GCC_VERSION &gt;= 30100
&gt; #  define _GNUTLS_GCC_ATTR_DEPRECATED __attribute__ ((__deprecated__))
&gt; # endif
&gt; #endif



-- 
With best wishes
Dmitry

</body></email><email><emailId>20180112105417</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-01-12 10:54:17-0400</timestampReceived><subject>Re: cmac</subject><body>

On Fri, 2018-01-12 at 11:51 +0100, Nikos Mavrogiannopoulos wrote:
&gt; On Wed, 2018-01-10 at 11:24 +0100, Niels Möller wrote:
&gt; &gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; &gt; 
&gt; &gt; &gt;  The attached patch brings support for AES-128-CMAC. The code is
&gt; &gt; &gt; based
&gt; &gt; &gt; on the samba code.
&gt; &gt; 
&gt; &gt; Nice. I think I'll have to read up a bit to understand what it's
&gt; &gt; doing.
&gt; &gt; 
&gt; &gt; &gt; The rshift and lshift functions come from the AES
&gt; &gt; &gt; implementation bundled with samba.
&gt; &gt; 
&gt; &gt; These to just a single bit right or left shift of a 16-byte block?
&gt; &gt; To
&gt; &gt; me
&gt; &gt; it seems odd to do that with a table lookup for each byte.
&gt; 
&gt; Indeed, and I don't see any obvious benefit of that code. I've
&gt; replaced
&gt; it with a simpler version.

Re-sending as it seems I forgot to remove cmac-internal from makefile.

regards,
Nikos

["0001-Added-support-for-CMAC.patch" (0001-Added-support-for-CMAC.patch)]

From 929f1a4cb927bf7e16df7980e4d9c30586a894fb Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 10 Jan 2018 09:29:17 +0100
Subject: [PATCH] Added support for CMAC

That adds support for CMAC as a generic framework for
128-bit block and key ciphers, as well as API for AES-128-CMAC.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 Makefile.in                 |   2 +
 cmac-aes128.c               |  60 ++++++++++++++++++
 cmac.c                      | 150 ++++++++++++++++++++++++++++++++++++++++++++
 cmac.h                      | 117 ++++++++++++++++++++++++++++++++++
 examples/nettle-benchmark.c |  24 ++++++-
 testsuite/.test-rules.make  |   3 +
 testsuite/Makefile.in       |   1 +
 testsuite/cmac-test.c       |  57 +++++++++++++++++
 8 files changed, 413 insertions(+), 1 deletion(-)
 create mode 100644 cmac-aes128.c
 create mode 100644 cmac.c
 create mode 100644 cmac.h
 create mode 100644 testsuite/cmac-test.c

diff --git a/Makefile.in b/Makefile.in
index 6a0c13ec..a25c0f99 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -103,6 +103,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-aes256.c gcm-aes256-meta.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
+		 cmac.c cmac-aes128.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
@@ -195,6 +196,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  gcm.h gosthash94.h hmac.h \
 	  knuth-lfib.h hkdf.h \
 	  macros.h \
+	  cmac.h \
 	  md2.h md4.h \
 	  md5.h md5-compat.h \
 	  memops.h memxor.h \
diff --git a/cmac-aes128.c b/cmac-aes128.c
new file mode 100644
index 00000000..e53e114e
--- /dev/null
+++ b/cmac-aes128.c
@@ -0,0 +1,60 @@
+/* cmac-aes128.c
+
+   CMAC using AES128 as the underlying cipher.
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "cmac.h"
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key)
+{
+  CMAC128_SET_KEY(ctx, aes128_set_encrypt_key, aes128_encrypt, key);
+}
+
+void
+cmac_aes128_update (struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  CMAC128_UPDATE (ctx, aes128_encrypt, length, data);
+}
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  CMAC128_DIGEST(ctx, aes128_encrypt, length, digest);
+}
diff --git a/cmac.c b/cmac.c
new file mode 100644
index 00000000..b4886808
--- /dev/null
+++ b/cmac.c
@@ -0,0 +1,150 @@
+/*
+   AES-CMAC-128 (rfc 4493)
+   Copyright (C) Stefan Metzmacher 2012
+   Copyright (C) Jeremy Allison 2012
+   Copyright (C) Michael Adam 2012
+   Copyright (C) 2017, Red Hat Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "cmac.h"
+
+#include "memxor.h"
+#include "nettle-internal.h"
+#include "macros.h"
+
+static const uint8_t const_Zero[] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
+};
+
+static const uint8_t const_Rb[] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x87
+};
+
+static inline void block_lshift(const union nettle_block16 *in,
+				union nettle_block16 *out)
+{
+	uint64_t b1 = READ_UINT64(in-&gt;b);
+	uint64_t b2 = READ_UINT64(in-&gt;b+8);
+	unsigned overflow = b2 &amp; 0x8000000000000000;
+
+	b1 &lt;&lt;= 1;
+	b2 &lt;&lt;= 1;
+
+	if (overflow)
+		b1 |= 0x01;
+
+	WRITE_UINT64(out-&gt;b, b1);
+	WRITE_UINT64(out-&gt;b+8, b2);
+
+}
+
+void cmac128_set_key(struct cmac128 *ctx, void *key,
+		     nettle_cipher_func *encrypt)
+{
+	memset(ctx, 0, sizeof(*ctx));
+
+	/* step 1 - generate subkeys k1 and k2 */
+	encrypt(key, 16, ctx-&gt;L.b, const_Zero);
+
+	block_lshift(ctx-&gt;L.b, ctx-&gt;K1.b);
+	if (ctx-&gt;L.b[0] &amp; 0x80) {
+		memxor(ctx-&gt;K1.b, const_Rb, 16);
+	}
+
+	block_lshift(ctx-&gt;K1.b, ctx-&gt;K2.b);
+	if (ctx-&gt;K1.b[0] &amp; 0x80) {
+		memxor(ctx-&gt;K2.b, const_Rb, 16);
+	}
+}
+
+#define MIN(x,y) ((x)&lt;(y)?(x):(y))
+
+void cmac128_update(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    size_t msg_len, const uint8_t *msg)
+{
+	/*
+	 * check if we expand the block
+	 */
+	if (ctx-&gt;last_len &lt; 16) {
+		size_t len = MIN(16 - ctx-&gt;last_len, msg_len);
+		memcpy(&amp;ctx-&gt;last.b[ctx-&gt;last_len], msg, len);
+		msg += len;
+		msg_len -= len;
+		ctx-&gt;last_len += len;
+	}
+
+	if (msg_len == 0) {
+		/* if it is still the last block, we are done */
+		return;
+	}
+
+	/*
+	 * now checksum everything but the last block
+	 */
+	memxor3(ctx-&gt;Y.b, ctx-&gt;X.b, ctx-&gt;last.b, 16);
+	encrypt(key, 16, ctx-&gt;X.b, ctx-&gt;Y.b);
+
+	while (msg_len &gt; 16) {
+		memxor3(ctx-&gt;Y.b, ctx-&gt;X.b, msg, 16);
+		encrypt(key, 16, ctx-&gt;X.b, ctx-&gt;Y.b);
+		msg += 16;
+		msg_len -= 16;
+	}
+
+	/*
+	 * copy the last block, it will be processed in
+	 * cmac128_digest().
+	 */
+	memset(ctx-&gt;last.b, 0, sizeof(ctx-&gt;last.b));
+	memcpy(ctx-&gt;last.b, msg, msg_len);
+	ctx-&gt;last_len = msg_len;
+}
+
+void cmac128_digest(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *out)
+{
+	uint8_t tmp[16];
+
+	if (ctx-&gt;last_len &lt; 16) {
+		ctx-&gt;last.b[ctx-&gt;last_len] = 0x80;
+		memxor3(tmp, ctx-&gt;last.b, ctx-&gt;K2.b, 16);
+	} else {
+		memxor3(tmp, ctx-&gt;last.b, ctx-&gt;K1.b, 16);
+	}
+
+	memxor3(ctx-&gt;Y.b, tmp, ctx-&gt;X.b, 16);
+
+	assert(length &lt;= 16);
+	if (length == 16) {
+		encrypt(key, length, out, ctx-&gt;Y.b);
+	} else {
+		encrypt(key, length, tmp, ctx-&gt;Y.b);
+		memcpy(out, tmp, length);
+	}
+}
diff --git a/cmac.h b/cmac.h
new file mode 100644
index 00000000..5f0553b7
--- /dev/null
+++ b/cmac.h
@@ -0,0 +1,117 @@
+/* cmac.h
+
+   CMAC mode, as specified in RFC4493
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   Contributed by Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_CMAC_H_INCLUDED
+#define NETTLE_CMAC_H_INCLUDED
+
+#include "aes.h"
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define cmac128_set_key nettle_cmac128_set_key
+#define cmac128_update nettle_cmac128_update
+#define cmac128_digest nettle_cmac128_digest
+#define cmac_aes128_set_key nettle_cmac_aes128_set_key
+#define cmac_aes128_update nettle_cmac_aes128_update
+#define cmac_aes128_digest nettle_cmac_aes128_digest
+
+struct cmac128 {
+	union nettle_block16 K1;
+	union nettle_block16 K2;
+
+	union nettle_block16 L;
+	union nettle_block16 X;
+	union nettle_block16 Y;
+
+	union nettle_block16 last;
+	size_t last_len;
+};
+
+void cmac128_set_key(struct cmac128 *ctx, void *key,
+		     nettle_cipher_func *encrypt);
+void cmac128_update(struct cmac128 *ctx, void *key,
+		 nettle_cipher_func *encrypt,
+		 size_t msg_len, const uint8_t *msg);
+void cmac128_digest(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *out);
+
+
+#define CMAC128_CTX(type) \
+  { struct cmac128 data; type cipher; }
+
+/* NOTE: Avoid using NULL, as we don't include anything defining it. */
+#define CMAC128_SET_KEY(ctx, set_key, encrypt, cmac_key)		\
+  do {								\
+    (set_key)(&amp;(ctx)-&gt;cipher, (cmac_key));			\
+    if (0) (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,		\
+		     (uint8_t *) 0, (const uint8_t *) 0);	\
+    cmac128_set_key(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		(nettle_cipher_func *) (encrypt));		\
+  } while (0)
+
+#define CMAC128_UPDATE(ctx, encrypt, length, data)			\
+  cmac128_update(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher, \
+	      (nettle_cipher_func *)encrypt, (length), (data))
+
+#define CMAC128_DIGEST(ctx, encrypt, length, digest)			\
+  (0 ? (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,				\
+		 (uint8_t *) 0, (const uint8_t *) 0)			\
+     : cmac128_digest(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		  (nettle_cipher_func *) (encrypt),			\
+		  (length), (digest)))
+
+struct cmac_aes128_ctx CMAC128_CTX(struct aes128_ctx);
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key);
+
+void
+cmac_aes128_update(struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CMAC_H_INCLUDED */
diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index b73196b0..b9cef924 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -64,6 +64,7 @@
 #include "sha3.h"
 #include "twofish.h"
 #include "umac.h"
+#include "cmac.h"
 #include "poly1305.h"
 
 #include "nettle-meta.h"
@@ -403,7 +404,7 @@ time_umac(void)
   struct umac64_ctx ctx64;
   struct umac96_ctx ctx96;
   struct umac128_ctx ctx128;
-  
+
   uint8_t key[16];
 
   umac32_set_key (&amp;ctx32, key);
@@ -439,6 +440,24 @@ time_umac(void)
 	  time_function(bench_hash, &amp;info));
 }
 
+static void
+time_cmac(void)
+{
+  static uint8_t data[BENCH_BLOCK];
+  struct bench_hash_info info;
+  struct cmac_aes128_ctx ctx;
+  
+  uint8_t key[16];
+
+  cmac_aes128_set_key (&amp;ctx, key);
+  info.ctx = 
+  info.update = (nettle_hash_update_func *) cmac_aes128_update;
+  info.data = data;
+
+  display("cmac-aes128", "update", AES_BLOCK_SIZE,
+	  time_function(bench_hash, &amp;info));
+}
+
 static void
 time_poly1305_aes(void)
 {
@@ -843,6 +862,9 @@ main(int argc, char **argv)
   if (!alg || strstr ("umac", alg))
     time_umac();
 
+  if (!alg || strstr ("cmac", alg))
+    time_cmac();
+
   if (!alg || strstr ("poly1305-aes", alg))
     time_poly1305_aes();
 
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 1f780310..c7e04cb4 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -130,6 +130,9 @@ eax-test$(EXEEXT): eax-test.$(OBJEXT)
 ccm-test$(EXEEXT): ccm-test.$(OBJEXT)
 	$(LINK) ccm-test.$(OBJEXT) $(TEST_OBJS) -o ccm-test$(EXEEXT)
 
+cmac-test$(EXEEXT): cmac-test.$(OBJEXT)
+	$(LINK) cmac-test.$(OBJEXT) $(TEST_OBJS) -o cmac-test$(EXEEXT)
+
 poly1305-test$(EXEEXT): poly1305-test.$(OBJEXT)
 	$(LINK) poly1305-test.$(OBJEXT) $(TEST_OBJS) -o poly1305-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 3117d66d..dd1ecf41 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -26,6 +26,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    serpent-test.c twofish-test.c version-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c cfb-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
+		    cmac-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
new file mode 100644
index 00000000..45cad3c2
--- /dev/null
+++ b/testsuite/cmac-test.c
@@ -0,0 +1,57 @@
+#include "testutils.h"
+#include "nettle-internal.h"
+#include "cmac.h"
+
+static void
+test_cmac_hash (const struct tstring *key, const struct tstring *msg, const struct tstring *ref)
+{
+  struct cmac_aes128_ctx ctx;
+  uint8_t digest[16];
+
+  ASSERT (ref-&gt;length == sizeof(digest));
+  ASSERT (key-&gt;length == 16);
+  cmac_aes128_set_key (&amp;ctx, key-&gt;data);
+  cmac_aes128_update (&amp;ctx, msg-&gt;length, msg-&gt;data);
+  cmac_aes128_digest (&amp;ctx, sizeof(digest), digest);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, digest))
+    {
+      fprintf (stderr, "cmac_hash failed, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, digest);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+}
+
+void
+test_main(void)
+{
+  /* 
+   * CMAC-AES Test Vectors from RFC4493.
+   */
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SDATA(""),
+		  SHEX("bb1d6929e95937287fa37d129b756746"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
+		  SHEX("070a16b46b4d4144f79bdd9dd04a287c"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("dfa66747de9ae63030ca32611497c827"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411e5fbc1191a0a52ef"
+		       "f69f2445df4f9b17ad2b417be66c3710"),
+		  SHEX("51f0bebf7e3b9d92fc49741779363cfe"));
+}
+
-- 
2.14.3



</body></email><email><emailId>20180115203706</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-15 20:37:06-0400</timestampReceived><subject>Re: cmac</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; Re-sending as it seems I forgot to remove cmac-internal from makefile.

I've had a first reading, and a few comments.

&gt; diff --git a/cmac.c b/cmac.c
&gt; new file mode 100644
&gt; index 00000000..b4886808
&gt; --- /dev/null
&gt; +++ b/cmac.c

&gt; +static const uint8_t const_Rb[] = {
&gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
&gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x87
&gt; +};
&gt; +
&gt; +static inline void block_lshift(const union nettle_block16 *in, +
&gt; union nettle_block16 *out)
&gt; +{
&gt; +	uint64_t b1 = READ_UINT64(in-&gt;b);
&gt; +	uint64_t b2 = READ_UINT64(in-&gt;b+8);
&gt; +	unsigned overflow = b2 &amp; 0x8000000000000000;
&gt; +
&gt; +	b1 &lt;&lt;= 1;
&gt; +	b2 &lt;&lt;= 1;
&gt; +
&gt; +	if (overflow)
&gt; +		b1 |= 0x01;

I'd write the shift as

   b1 = (b1 &lt;&lt; 1) | (b2 &gt;&gt; 63);
   b2 &lt;&lt;= 1;

I think it could return the bit shifted out (since the next thing done
is examining that bit). Or maybe even better, move the 

  if (one-bit shifted out) { memxor const_Rb } 

into this function, which would then correspond to multiplication by in
Z_2[x] / (Rb polynomial). Nettle conventions would also put the
destination argument first. I'd suggest rewriting the function as

 static void block_mulx(union nettle_block16 *dst, 
		        const union nettle_block16 *src)
 {
   uint64_t s1 = READ_UINT64(src-&gt;b);
   uint64_t s0 = READ_UINT64(src-&gt;b+8);
   uint64_t d1 = (s1 &lt;&lt; 1) | (s0 &gt;&gt; 63);
   uint64_t d0 = s0 &lt;&lt; 1;
   if (s1 &gt;&gt; 63)
      d0 ^= 0x87; /* If that's what the const_Rb memxor boils down to? */
 
   WRITE_UINT64(dst-&gt;b, d1);
   WRITE_UINT64(dst-&gt;b+8, d0);
 }

Further cleverness is possible, but further optimization might not be
needed, since, as you say, it's for key setup only.

&gt; +void cmac128_set_key(struct cmac128 *ctx, void *key,
&gt; +		     nettle_cipher_func *encrypt)
&gt; +{
&gt; +	memset(ctx, 0, sizeof(*ctx));
&gt; +
&gt; +	/* step 1 - generate subkeys k1 and k2 */
&gt; +	encrypt(key, 16, ctx-&gt;L.b, const_Zero);
&gt; +
&gt; +	block_lshift(ctx-&gt;L.b, ctx-&gt;K1.b);
&gt; +	if (ctx-&gt;L.b[0] &amp; 0x80) {
&gt; +		memxor(ctx-&gt;K1.b, const_Rb, 16);
&gt; +	}

Is ctx-&gt;L used for anything after key setup? If not, it should be moved
to a local variable, out of the context struct.

&gt; +	block_lshift(ctx-&gt;K1.b, ctx-&gt;K2.b);
&gt; +	if (ctx-&gt;K1.b[0] &amp; 0x80) {
&gt; +		memxor(ctx-&gt;K2.b, const_Rb, 16);
&gt; +	}
&gt; +}
&gt; +
&gt; +#define MIN(x,y) ((x)&lt;(y)?(x):(y))
&gt; +
&gt; +void cmac128_update(struct cmac128 *ctx, void *key,
&gt; +		    nettle_cipher_func *encrypt,
&gt; +		    size_t msg_len, const uint8_t *msg)
&gt; +{
&gt; +	/*
&gt; +	 * check if we expand the block
&gt; +	 */
&gt; +	if (ctx-&gt;last_len &lt; 16) {
&gt; +		size_t len = MIN(16 - ctx-&gt;last_len, msg_len);
&gt; +		memcpy(&amp;ctx-&gt;last.b[ctx-&gt;last_len], msg, len);
&gt; +		msg += len;
&gt; +		msg_len -= len;
&gt; +		ctx-&gt;last_len += len;
&gt; +	}

Other similar code uses different naming convenstions, in particular
ctx-&gt;block rather than ctx-&gt;last, and ctx-&gt;index rather than
ctx-&gt;last_len. Not terribly important, but it is nice to have some
consistency in style.

&gt; +	if (msg_len == 0) {
&gt; +		/* if it is still the last block, we are done */
&gt; +		return;
&gt; +	}
&gt; +
&gt; +	/*
&gt; +	 * now checksum everything but the last block
&gt; +	 */
&gt; +	memxor3(ctx-&gt;Y.b, ctx-&gt;X.b, ctx-&gt;last.b, 16);
&gt; +	encrypt(key, 16, ctx-&gt;X.b, ctx-&gt;Y.b);
&gt; +
&gt; +	while (msg_len &gt; 16) {
&gt; +		memxor3(ctx-&gt;Y.b, ctx-&gt;X.b, msg, 16);
&gt; +		encrypt(key, 16, ctx-&gt;X.b, ctx-&gt;Y.b);
&gt; +		msg += 16;
&gt; +		msg_len -= 16;
&gt; +	}
&gt; +
&gt; +	/*
&gt; +	 * copy the last block, it will be processed in
&gt; +	 * cmac128_digest().
&gt; +	 */
&gt; +	memset(ctx-&gt;last.b, 0, sizeof(ctx-&gt;last.b));

I'd prefer to postpone the memset/zero-padding until cmac128_digest.

&gt; +	memcpy(ctx-&gt;last.b, msg, msg_len);
&gt; +	ctx-&gt;last_len = msg_len;
&gt; +}
&gt; +
&gt; +void cmac128_digest(struct cmac128 *ctx, void *key,
&gt; +		    nettle_cipher_func *encrypt,
&gt; +		    unsigned length,
&gt; +		    uint8_t *out)
&gt; +{
&gt; +	uint8_t tmp[16];

Is both last_len == 0 and last_len == 16 possible here? If practical, it
would be nice to arrange so that the update function above
processes all full blocks. 

&gt; +	if (ctx-&gt;last_len &lt; 16) {
&gt; +		ctx-&gt;last.b[ctx-&gt;last_len] = 0x80;
&gt; +		memxor3(tmp, ctx-&gt;last.b, ctx-&gt;K2.b, 16);
&gt; +	} else {
&gt; +		memxor3(tmp, ctx-&gt;last.b, ctx-&gt;K1.b, 16);
&gt; +	}

If that works out, this conditional would be replaced by

  if (ctx-&gt;last_len &gt; 0) 
    {
      /* Pad last block, xor with K2 rather than K1 */
      assert (ctx-&gt;last_len &lt; 16);
      ctx-&gt;last.b[ctx-&gt;last_len] = 0x80;
      memset(last.b + ctx-&gt;last_len + 1, 0, 15 - ctx-&gt;last_len);
      memxor3(tmp, ctx-&gt;last.b, ctx-&gt;K2.b, 16)
    }
  /* Note: No else clause */

Other code reuses the block buffer for temporary values in the digest
function. Maybe that would work here too, with memxor rather than
memxor3. Since memxor is a byte-by-byte operation, one could also
consider eliminating the memset, and instead do memxor + memcpy, but not
sure if that's an improvement in perforamance or readability.

&gt; +	memxor3(ctx-&gt;Y.b, tmp, ctx-&gt;X.b, 16);
&gt; +
&gt; +	assert(length &lt;= 16);
&gt; +	if (length == 16) {
&gt; +		encrypt(key, length, out, ctx-&gt;Y.b);
&gt; +	} else {
&gt; +		encrypt(key, length, tmp, ctx-&gt;Y.b);
&gt; +		memcpy(out, tmp, length);
&gt; +	}

Maybe I'm missing something, but to me both clauses look equivalent?

&gt; diff --git a/cmac.h b/cmac.h
&gt; new file mode 100644
&gt; index 00000000..5f0553b7
&gt; --- /dev/null
&gt; +++ b/cmac.h
&gt; @@ -0,0 +1,117 @@
&gt; +struct cmac128 {
&gt; +	union nettle_block16 K1;
&gt; +	union nettle_block16 K2;
&gt; +
&gt; +	union nettle_block16 L;
&gt; +	union nettle_block16 X;
&gt; +	union nettle_block16 Y;
&gt; +
&gt; +	union nettle_block16 last;
&gt; +	size_t last_len;
&gt; +};

To me, it looks like L and Y don't belong in the context struct. As I
understand it, K1 and K2 are the mmac key, X is the state, and last is
the buffer needed to handle one block at a time.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180116091659</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-01-16 09:16:59-0400</timestampReceived><subject>Re: cmac</subject><body>

On Mon, Jan 15, 2018 at 9:37 PM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:

&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt;
&gt; &gt; Re-sending as it seems I forgot to remove cmac-internal from makefile.
&gt;
&gt; I've had a first reading, and a few comments.
&gt;

Thank you for the review. I reply inline.


&gt; &gt; diff --git a/cmac.c b/cmac.c
&gt; &gt; new file mode 100644
&gt; &gt; index 00000000..b4886808
&gt; &gt; --- /dev/null
&gt; &gt; +++ b/cmac.c
&gt;
&gt; &gt; +static const uint8_t const_Rb[] = {
&gt; &gt; +     0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
&gt; &gt; +     0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x87
&gt; &gt; +};
&gt; &gt; +
&gt; &gt; +static inline void block_lshift(const union nettle_block16 *in, +
&gt; &gt; union nettle_block16 *out)
&gt; &gt; +{
&gt; &gt; +     uint64_t b1 = READ_UINT64(in-&gt;b);
&gt; &gt; +     uint64_t b2 = READ_UINT64(in-&gt;b+8);
&gt; &gt; +     unsigned overflow = b2 &amp; 0x8000000000000000;
&gt; &gt; +
&gt; &gt; +     b1 &lt;&lt;= 1;
&gt; &gt; +     b2 &lt;&lt;= 1;
&gt; &gt; +
&gt; &gt; +     if (overflow)
&gt; &gt; +             b1 |= 0x01;
&gt;
&gt; I'd write the shift as
&gt;
&gt;    b1 = (b1 &lt;&lt; 1) | (b2 &gt;&gt; 63);
&gt;    b2 &lt;&lt;= 1;
&gt;

I have bad experience with shifts over 31. I could switch it to that, but
my understanding is that they don't universally work especially in 32-bit
systems offerring 64-bit quantities. Given that this code is being used
unconditionally and is not performance critical, I'd stay with the safe
version, unless you have strong opinion about it.


&gt; I think it could return the bit shifted out (since the next thing done
&gt; is examining that bit). Or maybe even better, move the
&gt;
&gt;   if (one-bit shifted out) { memxor const_Rb }
&gt;

&gt; into this function, which would then correspond to multiplication by in
&gt; Z_2[x] / (Rb polynomial). Nettle conventions would also put the
&gt; destination argument first. I'd suggest rewriting the function as
&gt;

Nice suggestion. Done.


&gt;
&gt; &gt; +void cmac128_set_key(struct cmac128 *ctx, void *key,
&gt; &gt; +                  nettle_cipher_func *encrypt)
&gt; &gt; +{
&gt; &gt; +     memset(ctx, 0, sizeof(*ctx));
&gt; &gt; +
&gt; &gt; +     /* step 1 - generate subkeys k1 and k2 */
&gt; &gt; +     encrypt(key, 16, ctx-&gt;L.b, const_Zero);
&gt; &gt; +
&gt; &gt; +     block_lshift(ctx-&gt;L.b, ctx-&gt;K1.b);
&gt; &gt; +     if (ctx-&gt;L.b[0] &amp; 0x80) {
&gt; &gt; +             memxor(ctx-&gt;K1.b, const_Rb, 16);
&gt; &gt; +     }
&gt;
&gt; Is ctx-&gt;L used for anything after key setup? If not, it should be moved
&gt; to a local variable, out of the context struct.
&gt;

No. The reason it was used like than in samba is was so that when
overwritting the state, any intermediate data of the operation were erased.
That's not a bad idea, though, we don't need an additional variable as
'block' is available for temp use at this stage. I've modified it to use
that.


&gt;
&gt; &gt; +     block_lshift(ctx-&gt;K1.b, ctx-&gt;K2.b);
&gt; &gt; +     if (ctx-&gt;K1.b[0] &amp; 0x80) {
&gt; &gt; +             memxor(ctx-&gt;K2.b, const_Rb, 16);
&gt; &gt; +     }
&gt; &gt; +}
&gt; &gt; +
&gt; &gt; +#define MIN(x,y) ((x)&lt;(y)?(x):(y))
&gt; &gt; +
&gt; &gt; +void cmac128_update(struct cmac128 *ctx, void *key,
&gt; &gt; +                 nettle_cipher_func *encrypt,
&gt; &gt; +                 size_t msg_len, const uint8_t *msg)
&gt; &gt; +{
&gt; &gt; +     /*
&gt; &gt; +      * check if we expand the block
&gt; &gt; +      */
&gt; &gt; +     if (ctx-&gt;last_len &lt; 16) {
&gt; &gt; +             size_t len = MIN(16 - ctx-&gt;last_len, msg_len);
&gt; &gt; +             memcpy(&amp;ctx-&gt;last.b[ctx-&gt;last_len], msg, len);
&gt; &gt; +             msg += len;
&gt; &gt; +             msg_len -= len;
&gt; &gt; +             ctx-&gt;last_len += len;
&gt; &gt; +     }
&gt;
&gt; Other similar code uses different naming convenstions, in particular
&gt; ctx-&gt;block rather than ctx-&gt;last, and ctx-&gt;index rather than
&gt; ctx-&gt;last_len. Not terribly important, but it is nice to have some
&gt; consistency in style.
&gt;

Done.


&gt;
&gt; &gt; +     if (msg_len == 0) {
&gt; &gt; +             /* if it is still the last block, we are done */
&gt; &gt; +             return;
&gt; &gt; +     }
&gt; &gt; +
&gt; &gt; +     /*
&gt; &gt; +      * now checksum everything but the last block
&gt; &gt; +      */
&gt; &gt; +     memxor3(ctx-&gt;Y.b, ctx-&gt;X.b, ctx-&gt;last.b, 16);
&gt; &gt; +     encrypt(key, 16, ctx-&gt;X.b, ctx-&gt;Y.b);
&gt; &gt; +
&gt; &gt; +     while (msg_len &gt; 16) {
&gt; &gt; +             memxor3(ctx-&gt;Y.b, ctx-&gt;X.b, msg, 16);
&gt; &gt; +             encrypt(key, 16, ctx-&gt;X.b, ctx-&gt;Y.b);
&gt; &gt; +             msg += 16;
&gt; &gt; +             msg_len -= 16;
&gt; &gt; +     }
&gt; &gt; +
&gt; &gt; +     /*
&gt; &gt; +      * copy the last block, it will be processed in
&gt; &gt; +      * cmac128_digest().
&gt; &gt; +      */
&gt; &gt; +     memset(ctx-&gt;last.b, 0, sizeof(ctx-&gt;last.b));
&gt; I'd prefer to postpone the memset/zero-padding until cmac128_digest.
&gt;

Done.


&gt;
&gt; &gt; +     memcpy(ctx-&gt;last.b, msg, msg_len);
&gt; &gt; +     ctx-&gt;last_len = msg_len;
&gt; &gt; +}
&gt; &gt; +
&gt; &gt; +void cmac128_digest(struct cmac128 *ctx, void *key,
&gt; &gt; +                 nettle_cipher_func *encrypt,
&gt; &gt; +                 unsigned length,
&gt; &gt; +                 uint8_t *out)
&gt; &gt; +{
&gt; &gt; +     uint8_t tmp[16];
&gt;
&gt; Is both last_len == 0 and last_len == 16 possible here? If practical, it
&gt; would be nice to arrange so that the update function above
&gt; processes all full blocks.
&gt;




&gt;
&gt; &gt; +     if (ctx-&gt;last_len &lt; 16) {
&gt; &gt; +             ctx-&gt;last.b[ctx-&gt;last_len] = 0x80;
&gt; &gt; +             memxor3(tmp, ctx-&gt;last.b, ctx-&gt;K2.b, 16);
&gt; &gt; +     } else {
&gt; &gt; +             memxor3(tmp, ctx-&gt;last.b, ctx-&gt;K1.b, 16);
&gt; &gt; +     }
&gt;
&gt; If that works out, this conditional would be replaced by
&gt;
&gt;   if (ctx-&gt;last_len &gt; 0)
&gt;     {
&gt;       /* Pad last block, xor with K2 rather than K1 */
&gt;       assert (ctx-&gt;last_len &lt; 16);
&gt;       ctx-&gt;last.b[ctx-&gt;last_len] = 0x80;
&gt;       memset(last.b + ctx-&gt;last_len + 1, 0, 15 - ctx-&gt;last_len);
&gt;       memxor3(tmp, ctx-&gt;last.b, ctx-&gt;K2.b, 16)
&gt;     }
&gt;   /* Note: No else clause */
&gt;
&gt; Other code reuses the block buffer for temporary values in the digest
&gt; function. Maybe that would work here too, with memxor rather than
&gt; memxor3. Since memxor is a byte-by-byte operation, one could also
&gt; consider eliminating the memset, and instead do memxor + memcpy, but not
&gt; sure if that's an improvement in perforamance or readability.
&gt;
&gt; &gt; +     memxor3(ctx-&gt;Y.b, tmp, ctx-&gt;X.b, 16);
&gt; &gt; +
&gt; &gt; +     assert(length &lt;= 16);
&gt; &gt; +     if (length == 16) {
&gt; &gt; +             encrypt(key, length, out, ctx-&gt;Y.b);
&gt; &gt; +     } else {
&gt; &gt; +             encrypt(key, length, tmp, ctx-&gt;Y.b);
&gt; &gt; +             memcpy(out, tmp, length);
&gt; &gt; +     }
&gt;
&gt; Maybe I'm missing something, but to me both clauses look equivalent?
&gt;

They are updated to:
     if (length == 16) {
              encrypt(key, 16, out, ctx-&gt;Y.b);
     } else {
              encrypt(key, 16, tmp, ctx-&gt;Y.b);
             memcpy(out, tmp, length);
     }

The difference is that tmp is used to store the output of encrypt() in the
second clause.


&gt;
&gt; &gt; diff --git a/cmac.h b/cmac.h
&gt; &gt; new file mode 100644
&gt; &gt; index 00000000..5f0553b7
&gt; &gt; --- /dev/null
&gt; &gt; +++ b/cmac.h
&gt; &gt; @@ -0,0 +1,117 @@
&gt; &gt; +struct cmac128 {
&gt; &gt; +     union nettle_block16 K1;
&gt; &gt; +     union nettle_block16 K2;
&gt; &gt; +
&gt; &gt; +     union nettle_block16 L;
&gt; &gt; +     union nettle_block16 X;
&gt; &gt; +     union nettle_block16 Y;
&gt; &gt; +
&gt; &gt; +     union nettle_block16 last;
&gt; &gt; +     size_t last_len;
&gt; &gt; +};
&gt;
&gt; To me, it looks like L and Y don't belong in the context struct. As I
&gt; understand it, K1 and K2 are the mmac key, X is the state, and last is
&gt; the buffer needed to handle one block at a time.
&gt;

Updated.


I've also added some documentation and  enhanced the cmac test to check
operation on re-use of structure, as well as on byte-to-byte encryption.

["0001-Added-support-for-CMAC.patch" (text/x-patch)]

From 4df5b4531bf360f97e8b3ef1fef8439e31e379ec Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 10 Jan 2018 09:29:17 +0100
Subject: [PATCH] Added support for CMAC

That adds support for CMAC as a generic framework for
128-bit block and key ciphers, as well as API for AES-128-CMAC.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 Makefile.in                 |   2 +
 cmac-aes128.c               |  60 ++++++++++++++++
 cmac.c                      | 162 ++++++++++++++++++++++++++++++++++++++++++++
 cmac.h                      | 118 ++++++++++++++++++++++++++++++++
 examples/nettle-benchmark.c |  24 ++++++-
 nettle.texinfo              |  47 ++++++++++++-
 testsuite/.test-rules.make  |   3 +
 testsuite/Makefile.in       |   1 +
 testsuite/cmac-test.c       | 111 ++++++++++++++++++++++++++++++
 9 files changed, 526 insertions(+), 2 deletions(-)
 create mode 100644 cmac-aes128.c
 create mode 100644 cmac.c
 create mode 100644 cmac.h
 create mode 100644 testsuite/cmac-test.c

diff --git a/Makefile.in b/Makefile.in
index 6a0c13ec..a25c0f99 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -103,6 +103,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-aes256.c gcm-aes256-meta.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
+		 cmac.c cmac-aes128.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
@@ -195,6 +196,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  gcm.h gosthash94.h hmac.h \
 	  knuth-lfib.h hkdf.h \
 	  macros.h \
+	  cmac.h \
 	  md2.h md4.h \
 	  md5.h md5-compat.h \
 	  memops.h memxor.h \
diff --git a/cmac-aes128.c b/cmac-aes128.c
new file mode 100644
index 00000000..e53e114e
--- /dev/null
+++ b/cmac-aes128.c
@@ -0,0 +1,60 @@
+/* cmac-aes128.c
+
+   CMAC using AES128 as the underlying cipher.
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "cmac.h"
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key)
+{
+  CMAC128_SET_KEY(ctx, aes128_set_encrypt_key, aes128_encrypt, key);
+}
+
+void
+cmac_aes128_update (struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  CMAC128_UPDATE (ctx, aes128_encrypt, length, data);
+}
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  CMAC128_DIGEST(ctx, aes128_encrypt, length, digest);
+}
diff --git a/cmac.c b/cmac.c
new file mode 100644
index 00000000..15b6e094
--- /dev/null
+++ b/cmac.c
@@ -0,0 +1,162 @@
+/*
+   AES-CMAC-128 (rfc 4493)
+   Copyright (C) Stefan Metzmacher 2012
+   Copyright (C) Jeremy Allison 2012
+   Copyright (C) Michael Adam 2012
+   Copyright (C) 2017, Red Hat Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "cmac.h"
+
+#include "memxor.h"
+#include "nettle-internal.h"
+#include "macros.h"
+
+static const uint8_t const_zero[] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
+};
+
+/* shift one and XOR with 0x87. */
+static inline void block_mulx(union nettle_block16 *out,
+			      const union nettle_block16 *in)
+{
+	uint64_t b1 = READ_UINT64(in-&gt;b);
+	uint64_t b2 = READ_UINT64(in-&gt;b+8);
+	unsigned overflow = b2 &amp; 0x8000000000000000;
+
+	b1 &lt;&lt;= 1;
+	b2 &lt;&lt;= 1;
+
+	if (overflow)
+		b1 |= 0x01;
+
+	if (in-&gt;b[0] &amp; 0x80)
+		b2 ^= 0x87;
+
+	WRITE_UINT64(out-&gt;b, b1);
+	WRITE_UINT64(out-&gt;b+8, b2);
+}
+
+void cmac128_set_key(struct cmac128 *ctx, void *key,
+		     nettle_cipher_func *encrypt)
+{
+	union nettle_block16 *L = &amp;ctx-&gt;block;
+	memset(ctx, 0, sizeof(*ctx));
+
+	/* step 1 - generate subkeys k1 and k2 */
+	encrypt(key, 16, L-&gt;b, const_zero);
+
+	block_mulx(&amp;ctx-&gt;K1, L);
+	block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
+}
+
+#define MIN(x,y) ((x)&lt;(y)?(x):(y))
+
+void cmac128_update(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    size_t msg_len, const uint8_t *msg)
+{
+	union nettle_block16 Y;
+	/*
+	 * check if we expand the block
+	 */
+	if (ctx-&gt;index &lt; 16) {
+		size_t len = MIN(16 - ctx-&gt;index, msg_len);
+		memcpy(&amp;ctx-&gt;block.b[ctx-&gt;index], msg, len);
+		msg += len;
+		msg_len -= len;
+		ctx-&gt;index += len;
+	}
+
+	if (msg_len == 0) {
+		/* if it is still the last block, we are done */
+		return;
+	}
+
+	/*
+	 * now checksum everything but the last block
+	 */
+	memxor3(Y.b, ctx-&gt;X.b, ctx-&gt;block.b, 16);
+	encrypt(key, 16, ctx-&gt;X.b, Y.b);
+
+	while (msg_len &gt; 16) {
+		memxor3(Y.b, ctx-&gt;X.b, msg, 16);
+		encrypt(key, 16, ctx-&gt;X.b, Y.b);
+		msg += 16;
+		msg_len -= 16;
+	}
+
+	/*
+	 * copy the last block, it will be processed in
+	 * cmac128_digest().
+	 */
+	memcpy(ctx-&gt;block.b, msg, msg_len);
+	ctx-&gt;index = msg_len;
+}
+
+void cmac128_digest(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *out)
+{
+	union nettle_block16 Y;
+
+	memset(ctx-&gt;block.b+ctx-&gt;index, 0, sizeof(ctx-&gt;block.b)-ctx-&gt;index);
+
+	/* re-use ctx-&gt;block for memxor output */
+	if (ctx-&gt;index &lt; 16) {
+		ctx-&gt;block.b[ctx-&gt;index] = 0x80;
+		memxor(ctx-&gt;block.b, ctx-&gt;K2.b, 16);
+	} else {
+		memxor(ctx-&gt;block.b, ctx-&gt;K1.b, 16);
+	}
+
+	memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 16);
+
+	assert(length &lt;= 16);
+	if (length == 16) {
+		encrypt(key, 16, out, Y.b);
+	} else {
+		encrypt(key, 16, ctx-&gt;block.b, Y.b);
+		memcpy(out, ctx-&gt;block.b, length);
+	}
+
+	/* reset state for re-use */
+	memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
+	ctx-&gt;index = 0;
+}
diff --git a/cmac.h b/cmac.h
new file mode 100644
index 00000000..168ca95a
--- /dev/null
+++ b/cmac.h
@@ -0,0 +1,118 @@
+/* cmac.h
+
+   CMAC mode, as specified in RFC4493
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   Contributed by Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_CMAC_H_INCLUDED
+#define NETTLE_CMAC_H_INCLUDED
+
+#include "aes.h"
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CMAC128_KEY_SIZE 16
+#define CMAC128_DIGEST_SIZE 16
+
+#define cmac128_set_key nettle_cmac128_set_key
+#define cmac128_update nettle_cmac128_update
+#define cmac128_digest nettle_cmac128_digest
+#define cmac_aes128_set_key nettle_cmac_aes128_set_key
+#define cmac_aes128_update nettle_cmac_aes128_update
+#define cmac_aes128_digest nettle_cmac_aes128_digest
+
+struct cmac128 {
+	union nettle_block16 K1;
+	union nettle_block16 K2;
+
+	union nettle_block16 X;
+
+	union nettle_block16 block;
+	size_t index;
+};
+
+void cmac128_set_key(struct cmac128 *ctx, void *key,
+		     nettle_cipher_func *encrypt);
+void cmac128_update(struct cmac128 *ctx, void *key,
+		 nettle_cipher_func *encrypt,
+		 size_t msg_len, const uint8_t *msg);
+void cmac128_digest(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *out);
+
+
+#define CMAC128_CTX(type) \
+  { struct cmac128 data; type cipher; }
+
+/* NOTE: Avoid using NULL, as we don't include anything defining it. */
+#define CMAC128_SET_KEY(ctx, set_key, encrypt, cmac_key)		\
+  do {								\
+    (set_key)(&amp;(ctx)-&gt;cipher, (cmac_key));			\
+    if (0) (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,		\
+		     (uint8_t *) 0, (const uint8_t *) 0);	\
+    cmac128_set_key(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		(nettle_cipher_func *) (encrypt));		\
+  } while (0)
+
+#define CMAC128_UPDATE(ctx, encrypt, length, data)			\
+  cmac128_update(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher, \
+	      (nettle_cipher_func *)encrypt, (length), (data))
+
+#define CMAC128_DIGEST(ctx, encrypt, length, digest)			\
+  (0 ? (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,				\
+		 (uint8_t *) 0, (const uint8_t *) 0)			\
+     : cmac128_digest(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		  (nettle_cipher_func *) (encrypt),			\
+		  (length), (digest)))
+
+struct cmac_aes128_ctx CMAC128_CTX(struct aes128_ctx);
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key);
+
+void
+cmac_aes128_update(struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CMAC_H_INCLUDED */
diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index 9327881b..9ecc095e 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -64,6 +64,7 @@
 #include "sha3.h"
 #include "twofish.h"
 #include "umac.h"
+#include "cmac.h"
 #include "poly1305.h"
 
 #include "nettle-meta.h"
@@ -403,7 +404,7 @@ time_umac(void)
   struct umac64_ctx ctx64;
   struct umac96_ctx ctx96;
   struct umac128_ctx ctx128;
-  
+
   uint8_t key[16];
 
   umac32_set_key (&amp;ctx32, key);
@@ -439,6 +440,24 @@ time_umac(void)
 	  time_function(bench_hash, &amp;info));
 }
 
+static void
+time_cmac(void)
+{
+  static uint8_t data[BENCH_BLOCK];
+  struct bench_hash_info info;
+  struct cmac_aes128_ctx ctx;
+
+  uint8_t key[16];
+
+  cmac_aes128_set_key (&amp;ctx, key);
+  info.ctx = 
+  info.update = (nettle_hash_update_func *) cmac_aes128_update;
+  info.data = data;
+
+  display("cmac-aes128", "update", AES_BLOCK_SIZE,
+	  time_function(bench_hash, &amp;info));
+}
+
 static void
 time_poly1305_aes(void)
 {
@@ -845,6 +864,9 @@ main(int argc, char **argv)
       if (!alg || strstr ("umac", alg))
 	time_umac();
 
+      if (!alg || strstr ("cmac", alg))
+	time_cmac();
+
       if (!alg || strstr ("poly1305-aes", alg))
 	time_poly1305_aes();
 
diff --git a/nettle.texinfo b/nettle.texinfo
index aa374449..4a2d286f 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -101,6 +101,7 @@ Keyed Hash Functions
 
 * HMAC::
 * UMAC::
+* CMAC::
 
 Public-key algorithms
 
@@ -271,6 +272,9 @@ The implementation of the TWOFISH cipher is written by Ruud de \
Rooij.  @item UMAC
 Written by @value{AUTHOR}.
 
+@item CMAC
+Written by Nikos Mavrogiannopoulos, @value{AUTHOR}, Jeremy Allison, Michael Adam and \
Stefan Metzmacher. +
 @item RSA
 Written by @value{AUTHOR}. Uses the GMP library for bignum operations.
 
@@ -3066,6 +3070,7 @@ as well.
 @menu
 * HMAC::
 * UMAC::
+* CMAC::
 * Poly1305::
 @end menu
 
@@ -3408,7 +3413,47 @@ as described above, the new value is used unless you call the
 @code{_set_nonce} function explicitly for each message.
 @end deftypefun
 
-@node Poly1305,, UMAC, Keyed hash functions
+@node CMAC,, UMAC, Keyed hash functions
+@subsection @acronym{CMAC}
+@cindex CMAC
+
+@acronym{CMAC} is a message authentication code based on CBC encryption
+mode. It is suitable for systems where block ciphers are preferrable
+and perform better than hash functions. @acronym{CMAC} is specified in
+@cite{RFC4493}. The secret key is always 128 bits (16 octets).
+
+Nettle provides helper functions for @acronym{CMAC } with
+the @acronym{AES} block cipher.
+
+Nettle defines @acronym{CMAC} in @file{&lt;nettle/cmac.h&gt;}.
+
+@deftp {Context struct} {struct cmac128_ctx}
+@end deftp
+
+@defvr Constant CMAC128_KEY_SIZE
+The CMAC key size, 16.
+@end defvr
+@defvr Constant CMAC128_DIGEST_SIZE
+The size of an CMAC digest, 16.
+@end defvr
+
+@deftypefun void cmac_aes128_set_key (struct cmac_aes128_ctx *@var{ctx}, const \
uint8_t *@var{key}) +This function initializes the @acronym{CMAC} context struct.
+@end deftypefun
+
+@deftypefun void cmac_aes128_update (struct cmac_aes128_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +This function is called zero or more times \
to process the message. +@end deftypefun
+
+@deftypefun void cmac_aes128_digest (struct cmac_aes128_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Extracts the @acronym{MAC} of the message, \
writing it to @var{digest}. +@var{length} is usually equal to the specified output \
size, but if you +provide a smaller value, only the first @var{length} octets of the
+@acronym{MAC} are written. This function resets the context for
+processing of a new message with the same key.
+@end deftypefun
+
+@node Poly1305,, CMAC, Keyed hash functions
 @comment  node-name,  next,  previous,  up
 @subsection Poly1305
 
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 1f780310..c7e04cb4 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -130,6 +130,9 @@ eax-test$(EXEEXT): eax-test.$(OBJEXT)
 ccm-test$(EXEEXT): ccm-test.$(OBJEXT)
 	$(LINK) ccm-test.$(OBJEXT) $(TEST_OBJS) -o ccm-test$(EXEEXT)
 
+cmac-test$(EXEEXT): cmac-test.$(OBJEXT)
+	$(LINK) cmac-test.$(OBJEXT) $(TEST_OBJS) -o cmac-test$(EXEEXT)
+
 poly1305-test$(EXEEXT): poly1305-test.$(OBJEXT)
 	$(LINK) poly1305-test.$(OBJEXT) $(TEST_OBJS) -o poly1305-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 3117d66d..dd1ecf41 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -26,6 +26,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    serpent-test.c twofish-test.c version-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c cfb-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
+		    cmac-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
new file mode 100644
index 00000000..983c5127
--- /dev/null
+++ b/testsuite/cmac-test.c
@@ -0,0 +1,111 @@
+#include "testutils.h"
+#include "nettle-internal.h"
+#include "cmac.h"
+
+static void
+test_cmac_hash (const struct tstring *key, const struct tstring *msg, const struct \
tstring *ref) +{
+  struct cmac_aes128_ctx ctx;
+  uint8_t digest[16];
+  unsigned i;
+
+  ASSERT (ref-&gt;length == sizeof(digest));
+  ASSERT (key-&gt;length == 16);
+  cmac_aes128_set_key (&amp;ctx, key-&gt;data);
+  cmac_aes128_update (&amp;ctx, msg-&gt;length, msg-&gt;data);
+  cmac_aes128_digest (&amp;ctx, sizeof(digest), digest);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, digest))
+    {
+      fprintf (stderr, "cmac_hash failed, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, digest);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt to re-use the structure */
+  cmac_aes128_update (&amp;ctx, msg-&gt;length, msg-&gt;data);
+  cmac_aes128_digest (&amp;ctx, sizeof(digest), digest);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, digest))
+    {
+      fprintf (stderr, "cmac_hash failed on re-use, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, digest);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt byte-by-byte hashing */
+  cmac_aes128_set_key (&amp;ctx, key-&gt;data);
+  for (i=0;i&lt;msg-&gt;length;i++)
+    cmac_aes128_update (&amp;ctx, 1, msg-&gt;data+i);
+  cmac_aes128_digest (&amp;ctx, sizeof(digest), digest);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, digest))
+    {
+      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, digest);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+}
+
+void
+test_main(void)
+{
+  /*
+   * CMAC-AES Test Vectors from RFC4493.
+   */
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SDATA(""),
+		  SHEX("bb1d6929e95937287fa37d129b756746"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
+		  SHEX("070a16b46b4d4144f79bdd9dd04a287c"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("dfa66747de9ae63030ca32611497c827"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411e5fbc1191a0a52ef"
+		       "f69f2445df4f9b17ad2b417be66c3710"),
+		  SHEX("51f0bebf7e3b9d92fc49741779363cfe"));
+
+  /* Additional tests with different keys (same plaintext)
+   * to check all variants of set_key() */
+  test_cmac_hash (SHEX("2b7e151628aed2a8abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("87dd33c2945a4e228028690ae8954945"));
+
+  test_cmac_hash (SHEX("2b7e1ab628aed2a8abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("f0dc613a88886c7ed76eeb51f1c5e8d3"));
+
+  test_cmac_hash (SHEX("2b7e1ab628aed2a8abf7158809cf4f3d"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("b9d092dc387a9e42cdfeb9f9930cf567"));
+
+}
+
-- 
2.14.3



</body></email><email><emailId>20180116132525</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-16 13:25:25-0400</timestampReceived><subject>Re: cmac</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; On Mon, Jan 15, 2018 at 9:37 PM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt;&gt; &gt; +     unsigned overflow = b2 &amp; 0x8000000000000000;
&gt;&gt; &gt; +
&gt;&gt; &gt; +     b1 &lt;&lt;= 1;
&gt;&gt; &gt; +     b2 &lt;&lt;= 1;
&gt;&gt; &gt; +
&gt;&gt; &gt; +     if (overflow)
&gt;&gt; &gt; +             b1 |= 0x01;
&gt;&gt;
&gt;&gt; I'd write the shift as
&gt;&gt;
&gt;&gt;    b1 = (b1 &lt;&lt; 1) | (b2 &gt;&gt; 63);
&gt;&gt;    b2 &lt;&lt;= 1;
&gt;&gt;
&gt;
&gt; I have bad experience with shifts over 31. I could switch it to that, but
&gt; my understanding is that they don't universally work especially in 32-bit
&gt; systems offerring 64-bit quantities. Given that this code is being used
&gt; unconditionally and is not performance critical, I'd stay with the safe
&gt; version, unless you have strong opinion about it.

What problems have you seen? I've not heard of any C compilers which
have uint64_t but doesn't support shift properly (and this is the
simplest case, with unsigned values and constant shift count). The idiom
I proposed is used all over the place in gmp, but there I guess we don't
use 64-bit types on 32-bit platforms.

On the other hand, I think

  unsigned overflow = b2 &amp; 0x8000000000000000;

is incorrect if int is 32 bit, won't the result be always zero?

In your updated patch you write

+	if (overflow)
+		b1 |= 0x01;
+
+	if (in-&gt;b[0] &amp; 0x80)
+		b2 ^= 0x87;

It would be nice to at least handle the twp top bits in the same way. If
you're worried 64-bit shifts are not supported by 32-bit compilers,
maybe replace "overflow" by "in-&gt;b[8] &amp; 0x80", for consistency ?

And it would be good with proper test coverage for all four values of
the two bits in questions.

&gt; They are updated to:
&gt;      if (length == 16) {
&gt;               encrypt(key, 16, out, ctx-&gt;Y.b);
&gt;      } else {
&gt;               encrypt(key, 16, tmp, ctx-&gt;Y.b);
&gt;              memcpy(out, tmp, length);
&gt;      }
&gt;
&gt; The difference is that tmp is used to store the output of encrypt() in the
&gt; second clause.

Sorry for the confusion. I read "length" as the length of the final
partial block, but here it's the desired digest size, and the memcpy is
needed for truncation.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180117095945</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-01-17 09:59:45-0400</timestampReceived><subject>Re: cmac</subject><body>

On Tue, 2018-01-16 at 14:25 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt; 
&gt; &gt; On Mon, Jan 15, 2018 at 9:37 PM Niels Möller &lt;nisse@lysator.liu.se&gt;
&gt; &gt; wrote:
&gt; &gt; 
&gt; &gt; &gt; &gt; +     unsigned overflow = b2 &amp; 0x8000000000000000;
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; +     b1 &lt;&lt;= 1;
&gt; &gt; &gt; &gt; +     b2 &lt;&lt;= 1;
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; +     if (overflow)
&gt; &gt; &gt; &gt; +             b1 |= 0x01;
&gt; &gt; &gt; 
&gt; &gt; &gt; I'd write the shift as
&gt; &gt; &gt; 
&gt; &gt; &gt;    b1 = (b1 &lt;&lt; 1) | (b2 &gt;&gt; 63);
&gt; &gt; &gt;    b2 &lt;&lt;= 1;
&gt; &gt; &gt; 
&gt; &gt; 
&gt; &gt; I have bad experience with shifts over 31. I could switch it to
&gt; &gt; that, but
&gt; &gt; my understanding is that they don't universally work especially in
&gt; &gt; 32-bit
&gt; &gt; systems offerring 64-bit quantities. Given that this code is being
&gt; &gt; used
&gt; &gt; unconditionally and is not performance critical, I'd stay with the
&gt; &gt; safe
&gt; &gt; version, unless you have strong opinion about it.
&gt; 
&gt; What problems have you seen? I've not heard of any C compilers which
&gt; have uint64_t but doesn't support shift properly (and this is the
&gt; simplest case, with unsigned values and constant shift count). The
&gt; idiom
&gt; I proposed is used all over the place in gmp, but there I guess we
&gt; don't
&gt; use 64-bit types on 32-bit platforms.

I do not seem to find any references for similar issues. Out of memory
it was a report on the failure of a longer than 32-bit shift on an
mips64 system. It's been long time ago and it may have been a compiler
issue.

I attach a patch to switch to the 63-bit switch on top of the previous
one in case you prefer that version (seems simpler).

&gt; On the other hand, I think
&gt; 
&gt;   unsigned overflow = b2 &amp; 0x8000000000000000;
&gt; is incorrect if int is 32 bit, won't the result be always zero?

Thank you for the catch. Hopefully the x86 run on our CI would have
caught it but I never run it there. I've now sent a build with the 0001
patch at:
https://gitlab.com/nmav/nettle/pipelines/16256301

regards,
Nikos

["0001-Added-support-for-CMAC.patch" (0001-Added-support-for-CMAC.patch)]

From 396f2ba4f3f238073e88364c7a6635d17505687e Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 10 Jan 2018 09:29:17 +0100
Subject: [PATCH 1/2] Added support for CMAC

That adds support for CMAC as a generic framework for
128-bit block and key ciphers, as well as API for AES-128-CMAC.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 Makefile.in                 |   2 +
 cmac-aes128.c               |  60 ++++++++++++++++
 cmac.c                      | 162 ++++++++++++++++++++++++++++++++++++++++++++
 cmac.h                      | 118 ++++++++++++++++++++++++++++++++
 examples/nettle-benchmark.c |  24 ++++++-
 nettle.texinfo              |  47 ++++++++++++-
 testsuite/.test-rules.make  |   3 +
 testsuite/Makefile.in       |   1 +
 testsuite/cmac-test.c       | 111 ++++++++++++++++++++++++++++++
 9 files changed, 526 insertions(+), 2 deletions(-)
 create mode 100644 cmac-aes128.c
 create mode 100644 cmac.c
 create mode 100644 cmac.h
 create mode 100644 testsuite/cmac-test.c

diff --git a/Makefile.in b/Makefile.in
index 6a0c13ec..a25c0f99 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -103,6 +103,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-aes256.c gcm-aes256-meta.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
+		 cmac.c cmac-aes128.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
@@ -195,6 +196,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  gcm.h gosthash94.h hmac.h \
 	  knuth-lfib.h hkdf.h \
 	  macros.h \
+	  cmac.h \
 	  md2.h md4.h \
 	  md5.h md5-compat.h \
 	  memops.h memxor.h \
diff --git a/cmac-aes128.c b/cmac-aes128.c
new file mode 100644
index 00000000..e53e114e
--- /dev/null
+++ b/cmac-aes128.c
@@ -0,0 +1,60 @@
+/* cmac-aes128.c
+
+   CMAC using AES128 as the underlying cipher.
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "cmac.h"
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key)
+{
+  CMAC128_SET_KEY(ctx, aes128_set_encrypt_key, aes128_encrypt, key);
+}
+
+void
+cmac_aes128_update (struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  CMAC128_UPDATE (ctx, aes128_encrypt, length, data);
+}
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  CMAC128_DIGEST(ctx, aes128_encrypt, length, digest);
+}
diff --git a/cmac.c b/cmac.c
new file mode 100644
index 00000000..a4d2468a
--- /dev/null
+++ b/cmac.c
@@ -0,0 +1,162 @@
+/*
+   AES-CMAC-128 (rfc 4493)
+   Copyright (C) Stefan Metzmacher 2012
+   Copyright (C) Jeremy Allison 2012
+   Copyright (C) Michael Adam 2012
+   Copyright (C) 2017, Red Hat Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "cmac.h"
+
+#include "memxor.h"
+#include "nettle-internal.h"
+#include "macros.h"
+
+static const uint8_t const_zero[] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
+};
+
+/* shift one and XOR with 0x87. */
+static inline void block_mulx(union nettle_block16 *out,
+			      const union nettle_block16 *in)
+{
+	uint64_t b1 = READ_UINT64(in-&gt;b);
+	uint64_t b2 = READ_UINT64(in-&gt;b+8);
+	unsigned overflow = (b2 &amp; UINT64_C(0x8000000000000000))?1:0;
+
+	b1 &lt;&lt;= 1;
+	b2 &lt;&lt;= 1;
+
+	if (overflow)
+		b1 |= 0x01;
+
+	if (in-&gt;b[0] &amp; 0x80)
+		b2 ^= 0x87;
+
+	WRITE_UINT64(out-&gt;b, b1);
+	WRITE_UINT64(out-&gt;b+8, b2);
+}
+
+void cmac128_set_key(struct cmac128 *ctx, void *key,
+		     nettle_cipher_func *encrypt)
+{
+	union nettle_block16 *L = &amp;ctx-&gt;block;
+	memset(ctx, 0, sizeof(*ctx));
+
+	/* step 1 - generate subkeys k1 and k2 */
+	encrypt(key, 16, L-&gt;b, const_zero);
+
+	block_mulx(&amp;ctx-&gt;K1, L);
+	block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
+}
+
+#define MIN(x,y) ((x)&lt;(y)?(x):(y))
+
+void cmac128_update(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    size_t msg_len, const uint8_t *msg)
+{
+	union nettle_block16 Y;
+	/*
+	 * check if we expand the block
+	 */
+	if (ctx-&gt;index &lt; 16) {
+		size_t len = MIN(16 - ctx-&gt;index, msg_len);
+		memcpy(&amp;ctx-&gt;block.b[ctx-&gt;index], msg, len);
+		msg += len;
+		msg_len -= len;
+		ctx-&gt;index += len;
+	}
+
+	if (msg_len == 0) {
+		/* if it is still the last block, we are done */
+		return;
+	}
+
+	/*
+	 * now checksum everything but the last block
+	 */
+	memxor3(Y.b, ctx-&gt;X.b, ctx-&gt;block.b, 16);
+	encrypt(key, 16, ctx-&gt;X.b, Y.b);
+
+	while (msg_len &gt; 16) {
+		memxor3(Y.b, ctx-&gt;X.b, msg, 16);
+		encrypt(key, 16, ctx-&gt;X.b, Y.b);
+		msg += 16;
+		msg_len -= 16;
+	}
+
+	/*
+	 * copy the last block, it will be processed in
+	 * cmac128_digest().
+	 */
+	memcpy(ctx-&gt;block.b, msg, msg_len);
+	ctx-&gt;index = msg_len;
+}
+
+void cmac128_digest(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *out)
+{
+	union nettle_block16 Y;
+
+	memset(ctx-&gt;block.b+ctx-&gt;index, 0, sizeof(ctx-&gt;block.b)-ctx-&gt;index);
+
+	/* re-use ctx-&gt;block for memxor output */
+	if (ctx-&gt;index &lt; 16) {
+		ctx-&gt;block.b[ctx-&gt;index] = 0x80;
+		memxor(ctx-&gt;block.b, ctx-&gt;K2.b, 16);
+	} else {
+		memxor(ctx-&gt;block.b, ctx-&gt;K1.b, 16);
+	}
+
+	memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 16);
+
+	assert(length &lt;= 16);
+	if (length == 16) {
+		encrypt(key, 16, out, Y.b);
+	} else {
+		encrypt(key, 16, ctx-&gt;block.b, Y.b);
+		memcpy(out, ctx-&gt;block.b, length);
+	}
+
+	/* reset state for re-use */
+	memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
+	ctx-&gt;index = 0;
+}
diff --git a/cmac.h b/cmac.h
new file mode 100644
index 00000000..168ca95a
--- /dev/null
+++ b/cmac.h
@@ -0,0 +1,118 @@
+/* cmac.h
+
+   CMAC mode, as specified in RFC4493
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   Contributed by Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_CMAC_H_INCLUDED
+#define NETTLE_CMAC_H_INCLUDED
+
+#include "aes.h"
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CMAC128_KEY_SIZE 16
+#define CMAC128_DIGEST_SIZE 16
+
+#define cmac128_set_key nettle_cmac128_set_key
+#define cmac128_update nettle_cmac128_update
+#define cmac128_digest nettle_cmac128_digest
+#define cmac_aes128_set_key nettle_cmac_aes128_set_key
+#define cmac_aes128_update nettle_cmac_aes128_update
+#define cmac_aes128_digest nettle_cmac_aes128_digest
+
+struct cmac128 {
+	union nettle_block16 K1;
+	union nettle_block16 K2;
+
+	union nettle_block16 X;
+
+	union nettle_block16 block;
+	size_t index;
+};
+
+void cmac128_set_key(struct cmac128 *ctx, void *key,
+		     nettle_cipher_func *encrypt);
+void cmac128_update(struct cmac128 *ctx, void *key,
+		 nettle_cipher_func *encrypt,
+		 size_t msg_len, const uint8_t *msg);
+void cmac128_digest(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *out);
+
+
+#define CMAC128_CTX(type) \
+  { struct cmac128 data; type cipher; }
+
+/* NOTE: Avoid using NULL, as we don't include anything defining it. */
+#define CMAC128_SET_KEY(ctx, set_key, encrypt, cmac_key)		\
+  do {								\
+    (set_key)(&amp;(ctx)-&gt;cipher, (cmac_key));			\
+    if (0) (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,		\
+		     (uint8_t *) 0, (const uint8_t *) 0);	\
+    cmac128_set_key(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		(nettle_cipher_func *) (encrypt));		\
+  } while (0)
+
+#define CMAC128_UPDATE(ctx, encrypt, length, data)			\
+  cmac128_update(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher, \
+	      (nettle_cipher_func *)encrypt, (length), (data))
+
+#define CMAC128_DIGEST(ctx, encrypt, length, digest)			\
+  (0 ? (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,				\
+		 (uint8_t *) 0, (const uint8_t *) 0)			\
+     : cmac128_digest(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		  (nettle_cipher_func *) (encrypt),			\
+		  (length), (digest)))
+
+struct cmac_aes128_ctx CMAC128_CTX(struct aes128_ctx);
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key);
+
+void
+cmac_aes128_update(struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CMAC_H_INCLUDED */
diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index 9327881b..9ecc095e 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -64,6 +64,7 @@
 #include "sha3.h"
 #include "twofish.h"
 #include "umac.h"
+#include "cmac.h"
 #include "poly1305.h"
 
 #include "nettle-meta.h"
@@ -403,7 +404,7 @@ time_umac(void)
   struct umac64_ctx ctx64;
   struct umac96_ctx ctx96;
   struct umac128_ctx ctx128;
-  
+
   uint8_t key[16];
 
   umac32_set_key (&amp;ctx32, key);
@@ -439,6 +440,24 @@ time_umac(void)
 	  time_function(bench_hash, &amp;info));
 }
 
+static void
+time_cmac(void)
+{
+  static uint8_t data[BENCH_BLOCK];
+  struct bench_hash_info info;
+  struct cmac_aes128_ctx ctx;
+
+  uint8_t key[16];
+
+  cmac_aes128_set_key (&amp;ctx, key);
+  info.ctx = 
+  info.update = (nettle_hash_update_func *) cmac_aes128_update;
+  info.data = data;
+
+  display("cmac-aes128", "update", AES_BLOCK_SIZE,
+	  time_function(bench_hash, &amp;info));
+}
+
 static void
 time_poly1305_aes(void)
 {
@@ -845,6 +864,9 @@ main(int argc, char **argv)
       if (!alg || strstr ("umac", alg))
 	time_umac();
 
+      if (!alg || strstr ("cmac", alg))
+	time_cmac();
+
       if (!alg || strstr ("poly1305-aes", alg))
 	time_poly1305_aes();
 
diff --git a/nettle.texinfo b/nettle.texinfo
index aa374449..4a2d286f 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -101,6 +101,7 @@ Keyed Hash Functions
 
 * HMAC::
 * UMAC::
+* CMAC::
 
 Public-key algorithms
 
@@ -271,6 +272,9 @@ The implementation of the TWOFISH cipher is written by Ruud de \
Rooij.  @item UMAC
 Written by @value{AUTHOR}.
 
+@item CMAC
+Written by Nikos Mavrogiannopoulos, @value{AUTHOR}, Jeremy Allison, Michael Adam and \
Stefan Metzmacher. +
 @item RSA
 Written by @value{AUTHOR}. Uses the GMP library for bignum operations.
 
@@ -3066,6 +3070,7 @@ as well.
 @menu
 * HMAC::
 * UMAC::
+* CMAC::
 * Poly1305::
 @end menu
 
@@ -3408,7 +3413,47 @@ as described above, the new value is used unless you call the
 @code{_set_nonce} function explicitly for each message.
 @end deftypefun
 
-@node Poly1305,, UMAC, Keyed hash functions
+@node CMAC,, UMAC, Keyed hash functions
+@subsection @acronym{CMAC}
+@cindex CMAC
+
+@acronym{CMAC} is a message authentication code based on CBC encryption
+mode. It is suitable for systems where block ciphers are preferrable
+and perform better than hash functions. @acronym{CMAC} is specified in
+@cite{RFC4493}. The secret key is always 128 bits (16 octets).
+
+Nettle provides helper functions for @acronym{CMAC } with
+the @acronym{AES} block cipher.
+
+Nettle defines @acronym{CMAC} in @file{&lt;nettle/cmac.h&gt;}.
+
+@deftp {Context struct} {struct cmac128_ctx}
+@end deftp
+
+@defvr Constant CMAC128_KEY_SIZE
+The CMAC key size, 16.
+@end defvr
+@defvr Constant CMAC128_DIGEST_SIZE
+The size of an CMAC digest, 16.
+@end defvr
+
+@deftypefun void cmac_aes128_set_key (struct cmac_aes128_ctx *@var{ctx}, const \
uint8_t *@var{key}) +This function initializes the @acronym{CMAC} context struct.
+@end deftypefun
+
+@deftypefun void cmac_aes128_update (struct cmac_aes128_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +This function is called zero or more times \
to process the message. +@end deftypefun
+
+@deftypefun void cmac_aes128_digest (struct cmac_aes128_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Extracts the @acronym{MAC} of the message, \
writing it to @var{digest}. +@var{length} is usually equal to the specified output \
size, but if you +provide a smaller value, only the first @var{length} octets of the
+@acronym{MAC} are written. This function resets the context for
+processing of a new message with the same key.
+@end deftypefun
+
+@node Poly1305,, CMAC, Keyed hash functions
 @comment  node-name,  next,  previous,  up
 @subsection Poly1305
 
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 1f780310..c7e04cb4 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -130,6 +130,9 @@ eax-test$(EXEEXT): eax-test.$(OBJEXT)
 ccm-test$(EXEEXT): ccm-test.$(OBJEXT)
 	$(LINK) ccm-test.$(OBJEXT) $(TEST_OBJS) -o ccm-test$(EXEEXT)
 
+cmac-test$(EXEEXT): cmac-test.$(OBJEXT)
+	$(LINK) cmac-test.$(OBJEXT) $(TEST_OBJS) -o cmac-test$(EXEEXT)
+
 poly1305-test$(EXEEXT): poly1305-test.$(OBJEXT)
 	$(LINK) poly1305-test.$(OBJEXT) $(TEST_OBJS) -o poly1305-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 3117d66d..dd1ecf41 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -26,6 +26,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    serpent-test.c twofish-test.c version-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c cfb-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
+		    cmac-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
new file mode 100644
index 00000000..983c5127
--- /dev/null
+++ b/testsuite/cmac-test.c
@@ -0,0 +1,111 @@
+#include "testutils.h"
+#include "nettle-internal.h"
+#include "cmac.h"
+
+static void
+test_cmac_hash (const struct tstring *key, const struct tstring *msg, const struct \
tstring *ref) +{
+  struct cmac_aes128_ctx ctx;
+  uint8_t digest[16];
+  unsigned i;
+
+  ASSERT (ref-&gt;length == sizeof(digest));
+  ASSERT (key-&gt;length == 16);
+  cmac_aes128_set_key (&amp;ctx, key-&gt;data);
+  cmac_aes128_update (&amp;ctx, msg-&gt;length, msg-&gt;data);
+  cmac_aes128_digest (&amp;ctx, sizeof(digest), digest);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, digest))
+    {
+      fprintf (stderr, "cmac_hash failed, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, digest);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt to re-use the structure */
+  cmac_aes128_update (&amp;ctx, msg-&gt;length, msg-&gt;data);
+  cmac_aes128_digest (&amp;ctx, sizeof(digest), digest);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, digest))
+    {
+      fprintf (stderr, "cmac_hash failed on re-use, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, digest);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt byte-by-byte hashing */
+  cmac_aes128_set_key (&amp;ctx, key-&gt;data);
+  for (i=0;i&lt;msg-&gt;length;i++)
+    cmac_aes128_update (&amp;ctx, 1, msg-&gt;data+i);
+  cmac_aes128_digest (&amp;ctx, sizeof(digest), digest);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, digest))
+    {
+      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, digest);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+}
+
+void
+test_main(void)
+{
+  /*
+   * CMAC-AES Test Vectors from RFC4493.
+   */
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SDATA(""),
+		  SHEX("bb1d6929e95937287fa37d129b756746"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
+		  SHEX("070a16b46b4d4144f79bdd9dd04a287c"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("dfa66747de9ae63030ca32611497c827"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411e5fbc1191a0a52ef"
+		       "f69f2445df4f9b17ad2b417be66c3710"),
+		  SHEX("51f0bebf7e3b9d92fc49741779363cfe"));
+
+  /* Additional tests with different keys (same plaintext)
+   * to check all variants of set_key() */
+  test_cmac_hash (SHEX("2b7e151628aed2a8abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("87dd33c2945a4e228028690ae8954945"));
+
+  test_cmac_hash (SHEX("2b7e1ab628aed2a8abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("f0dc613a88886c7ed76eeb51f1c5e8d3"));
+
+  test_cmac_hash (SHEX("2b7e1ab628aed2a8abf7158809cf4f3d"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("b9d092dc387a9e42cdfeb9f9930cf567"));
+
+}
+
-- 
2.14.3


["0002-cmac-block_mulx-simplify-shifts.patch" (0002-cmac-block_mulx-simplify-shifts.patch)]

From ace3ada217319019663b4dec92b6e2980324c077 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 17 Jan 2018 10:47:23 +0100
Subject: [PATCH 2/2] cmac: block_mulx: simplify shifts

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 cmac.c | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/cmac.c b/cmac.c
index a4d2468a..27df917e 100644
--- a/cmac.c
+++ b/cmac.c
@@ -57,14 +57,10 @@ static inline void block_mulx(union nettle_block16 *out,
 {
 	uint64_t b1 = READ_UINT64(in-&gt;b);
 	uint64_t b2 = READ_UINT64(in-&gt;b+8);
-	unsigned overflow = (b2 &amp; UINT64_C(0x8000000000000000))?1:0;
 
-	b1 &lt;&lt;= 1;
+	b1 = (b1 &lt;&lt; 1) | (b2 &gt;&gt; 63);
 	b2 &lt;&lt;= 1;
 
-	if (overflow)
-		b1 |= 0x01;
-
 	if (in-&gt;b[0] &amp; 0x80)
 		b2 ^= 0x87;
 
-- 
2.14.3



</body></email><email><emailId>20180214214947</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-14 21:49:47-0400</timestampReceived><subject>Re: cmac</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; On Wed, 2018-01-17 at 10:59 +0100, Nikos Mavrogiannopoulos wrote:
&gt;
&gt; Following up on my patchset, this (hopefully final) version introduces
&gt; CMAC with AES-256 as well. It also removes the CMAC128_KEY_SIZE
&gt; definition as the key size only depends on the block algorithm used.

Thanks. I'm about to merge this, but it will probably take a day or two
more.

&gt; +void cmac128_set_key(struct cmac128 *ctx, void *key,
&gt; +		     nettle_cipher_func *encrypt);

I was a bit confused by "key" here, but it's the context struct of the
underlying cipher? It should be const void *. In the ccm and eax code,
it seems we use the name "cipher" for this, e.g.,

void
eax_set_key (struct eax_key *key, const void *cipher, nettle_cipher_func *f);

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180215065331</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-15 06:53:31-0400</timestampReceived><subject>Re: cmac</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; +@acronym{CMAC} is a message authentication code based on CBC encryption
&gt; +mode. It is suitable for systems where block ciphers are preferrable
&gt; +and perform better than hash functions. @acronym{CMAC} is specified in
&gt; +@cite{RFC4493}. The secret key is always 128 bits (16 octets).

Should be "block size", not "secret key", right?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180215084508</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-02-15 08:45:08-0400</timestampReceived><subject>Re: cmac</subject><body>

On Thu, 2018-02-15 at 07:53 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; 
&gt; &gt; +@acronym{CMAC} is a message authentication code based on CBC
&gt; &gt; encryption
&gt; &gt; +mode. It is suitable for systems where block ciphers are
&gt; &gt; preferrable
&gt; &gt; +and perform better than hash functions. @acronym{CMAC} is
&gt; &gt; specified in
&gt; &gt; +@cite{RFC4493}. The secret key is always 128 bits (16 octets).
&gt; 
&gt; Should be "block size", not "secret key", right?

Right. Updated patch (and merged all), to include this fix, and the naming
of variables (including changing out to dst).

regards,
Nikos

["0001-Added-support-for-CMAC.patch" (0001-Added-support-for-CMAC.patch)]

From 7737e2c9fdd5fd175014a8b97cfad044ed808317 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 10 Jan 2018 09:29:17 +0100
Subject: [PATCH] Added support for CMAC

That adds support for CMAC as a generic framework for
128-bit block and key ciphers, as well as API for AES-128-CMAC,
and AES-256-CMAC.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 Makefile.in                 |   2 +
 cmac-aes128.c               |  60 +++++++++++++++++
 cmac-aes256.c               |  60 +++++++++++++++++
 cmac.c                      | 158 ++++++++++++++++++++++++++++++++++++++++++++
 cmac.h                      | 133 +++++++++++++++++++++++++++++++++++++
 examples/nettle-benchmark.c |  24 ++++++-
 nettle.texinfo              |  60 ++++++++++++++++-
 testsuite/.test-rules.make  |   3 +
 testsuite/Makefile.in       |   1 +
 testsuite/cmac-test.c       | 146 ++++++++++++++++++++++++++++++++++++++++
 10 files changed, 645 insertions(+), 2 deletions(-)
 create mode 100644 cmac-aes128.c
 create mode 100644 cmac-aes256.c
 create mode 100644 cmac.c
 create mode 100644 cmac.h
 create mode 100644 testsuite/cmac-test.c

diff --git a/Makefile.in b/Makefile.in
index 4444e8bd..de12bb3f 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -100,6 +100,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-aes256.c gcm-aes256-meta.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
+		 cmac.c cmac-aes128.c cmac-aes256.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
@@ -192,6 +193,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  gcm.h gosthash94.h hmac.h \
 	  knuth-lfib.h hkdf.h \
 	  macros.h \
+	  cmac.h \
 	  md2.h md4.h \
 	  md5.h md5-compat.h \
 	  memops.h memxor.h \
diff --git a/cmac-aes128.c b/cmac-aes128.c
new file mode 100644
index 00000000..e53e114e
--- /dev/null
+++ b/cmac-aes128.c
@@ -0,0 +1,60 @@
+/* cmac-aes128.c
+
+   CMAC using AES128 as the underlying cipher.
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "cmac.h"
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key)
+{
+  CMAC128_SET_KEY(ctx, aes128_set_encrypt_key, aes128_encrypt, key);
+}
+
+void
+cmac_aes128_update (struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  CMAC128_UPDATE (ctx, aes128_encrypt, length, data);
+}
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  CMAC128_DIGEST(ctx, aes128_encrypt, length, digest);
+}
diff --git a/cmac-aes256.c b/cmac-aes256.c
new file mode 100644
index 00000000..ec3b50db
--- /dev/null
+++ b/cmac-aes256.c
@@ -0,0 +1,60 @@
+/* cmac-aes256.c
+
+   CMAC using AES256 as the underlying cipher.
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "cmac.h"
+
+void
+cmac_aes256_set_key(struct cmac_aes256_ctx *ctx, const uint8_t *key)
+{
+  CMAC128_SET_KEY(ctx, aes256_set_encrypt_key, aes256_encrypt, key);
+}
+
+void
+cmac_aes256_update (struct cmac_aes256_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  CMAC128_UPDATE (ctx, aes256_encrypt, length, data);
+}
+
+void
+cmac_aes256_digest(struct cmac_aes256_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  CMAC128_DIGEST(ctx, aes256_encrypt, length, digest);
+}
diff --git a/cmac.c b/cmac.c
new file mode 100644
index 00000000..95d45de4
--- /dev/null
+++ b/cmac.c
@@ -0,0 +1,158 @@
+/*
+   AES-CMAC-128 (rfc 4493)
+   Copyright (C) Stefan Metzmacher 2012
+   Copyright (C) Jeremy Allison 2012
+   Copyright (C) Michael Adam 2012
+   Copyright (C) 2017, Red Hat Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "cmac.h"
+
+#include "memxor.h"
+#include "nettle-internal.h"
+#include "macros.h"
+
+static const uint8_t const_zero[] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
+};
+
+/* shift one and XOR with 0x87. */
+static inline void block_mulx(union nettle_block16 *dst,
+			      const union nettle_block16 *src)
+{
+	uint64_t b1 = READ_UINT64(src-&gt;b);
+	uint64_t b2 = READ_UINT64(src-&gt;b+8);
+
+	b1 = (b1 &lt;&lt; 1) | (b2 &gt;&gt; 63);
+	b2 &lt;&lt;= 1;
+
+	if (src-&gt;b[0] &amp; 0x80)
+		b2 ^= 0x87;
+
+	WRITE_UINT64(dst-&gt;b, b1);
+	WRITE_UINT64(dst-&gt;b+8, b2);
+}
+
+void cmac128_set_key(struct cmac128 *ctx, void *cipher,
+		     nettle_cipher_func *encrypt)
+{
+	union nettle_block16 *L = &amp;ctx-&gt;block;
+	memset(ctx, 0, sizeof(*ctx));
+
+	/* step 1 - generate subkeys k1 and k2 */
+	encrypt(cipher, 16, L-&gt;b, const_zero);
+
+	block_mulx(&amp;ctx-&gt;K1, L);
+	block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
+}
+
+#define MIN(x,y) ((x)&lt;(y)?(x):(y))
+
+void cmac128_update(struct cmac128 *ctx, void *cipher,
+		    nettle_cipher_func *encrypt,
+		    size_t msg_len, const uint8_t *msg)
+{
+	union nettle_block16 Y;
+	/*
+	 * check if we expand the block
+	 */
+	if (ctx-&gt;index &lt; 16) {
+		size_t len = MIN(16 - ctx-&gt;index, msg_len);
+		memcpy(&amp;ctx-&gt;block.b[ctx-&gt;index], msg, len);
+		msg += len;
+		msg_len -= len;
+		ctx-&gt;index += len;
+	}
+
+	if (msg_len == 0) {
+		/* if it is still the last block, we are done */
+		return;
+	}
+
+	/*
+	 * now checksum everything but the last block
+	 */
+	memxor3(Y.b, ctx-&gt;X.b, ctx-&gt;block.b, 16);
+	encrypt(cipher, 16, ctx-&gt;X.b, Y.b);
+
+	while (msg_len &gt; 16) {
+		memxor3(Y.b, ctx-&gt;X.b, msg, 16);
+		encrypt(cipher, 16, ctx-&gt;X.b, Y.b);
+		msg += 16;
+		msg_len -= 16;
+	}
+
+	/*
+	 * copy the last block, it will be processed in
+	 * cmac128_digest().
+	 */
+	memcpy(ctx-&gt;block.b, msg, msg_len);
+	ctx-&gt;index = msg_len;
+}
+
+void cmac128_digest(struct cmac128 *ctx, void *cipher,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *dst)
+{
+	union nettle_block16 Y;
+
+	memset(ctx-&gt;block.b+ctx-&gt;index, 0, sizeof(ctx-&gt;block.b)-ctx-&gt;index);
+
+	/* re-use ctx-&gt;block for memxor output */
+	if (ctx-&gt;index &lt; 16) {
+		ctx-&gt;block.b[ctx-&gt;index] = 0x80;
+		memxor(ctx-&gt;block.b, ctx-&gt;K2.b, 16);
+	} else {
+		memxor(ctx-&gt;block.b, ctx-&gt;K1.b, 16);
+	}
+
+	memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 16);
+
+	assert(length &lt;= 16);
+	if (length == 16) {
+		encrypt(cipher, 16, dst, Y.b);
+	} else {
+		encrypt(cipher, 16, ctx-&gt;block.b, Y.b);
+		memcpy(dst, ctx-&gt;block.b, length);
+	}
+
+	/* reset state for re-use */
+	memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
+	ctx-&gt;index = 0;
+}
diff --git a/cmac.h b/cmac.h
new file mode 100644
index 00000000..4d7dffb2
--- /dev/null
+++ b/cmac.h
@@ -0,0 +1,133 @@
+/* cmac.h
+
+   CMAC mode, as specified in RFC4493
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   Contributed by Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_CMAC_H_INCLUDED
+#define NETTLE_CMAC_H_INCLUDED
+
+#include "aes.h"
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CMAC128_DIGEST_SIZE 16
+
+#define cmac128_set_key nettle_cmac128_set_key
+#define cmac128_update nettle_cmac128_update
+#define cmac128_digest nettle_cmac128_digest
+#define cmac_aes128_set_key nettle_cmac_aes128_set_key
+#define cmac_aes128_update nettle_cmac_aes128_update
+#define cmac_aes128_digest nettle_cmac_aes128_digest
+#define cmac_aes256_set_key nettle_cmac_aes256_set_key
+#define cmac_aes256_update nettle_cmac_aes256_update
+#define cmac_aes256_digest nettle_cmac_aes256_digest
+
+struct cmac128 {
+	union nettle_block16 K1;
+	union nettle_block16 K2;
+
+	union nettle_block16 X;
+
+	union nettle_block16 block;
+	size_t index;
+};
+
+void cmac128_set_key(struct cmac128 *ctx, void *cipher,
+		     nettle_cipher_func *encrypt);
+void cmac128_update(struct cmac128 *ctx, void *cipher,
+		 nettle_cipher_func *encrypt,
+		 size_t msg_len, const uint8_t *msg);
+void cmac128_digest(struct cmac128 *ctx, void *cipher,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *out);
+
+
+#define CMAC128_CTX(type) \
+  { struct cmac128 data; type cipher; }
+
+/* NOTE: Avoid using NULL, as we don't include anything defining it. */
+#define CMAC128_SET_KEY(ctx, set_key, encrypt, cmac_key)		\
+  do {								\
+    (set_key)(&amp;(ctx)-&gt;cipher, (cmac_key));			\
+    if (0) (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,		\
+		     (uint8_t *) 0, (const uint8_t *) 0);	\
+    cmac128_set_key(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		(nettle_cipher_func *) (encrypt));		\
+  } while (0)
+
+#define CMAC128_UPDATE(ctx, encrypt, length, data)			\
+  cmac128_update(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher, \
+	      (nettle_cipher_func *)encrypt, (length), (data))
+
+#define CMAC128_DIGEST(ctx, encrypt, length, digest)			\
+  (0 ? (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,				\
+		 (uint8_t *) 0, (const uint8_t *) 0)			\
+     : cmac128_digest(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		  (nettle_cipher_func *) (encrypt),			\
+		  (length), (digest)))
+
+struct cmac_aes128_ctx CMAC128_CTX(struct aes128_ctx);
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key);
+
+void
+cmac_aes128_update(struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
+struct cmac_aes256_ctx CMAC128_CTX(struct aes256_ctx);
+
+void
+cmac_aes256_set_key(struct cmac_aes256_ctx *ctx, const uint8_t *key);
+
+void
+cmac_aes256_update(struct cmac_aes256_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+cmac_aes256_digest(struct cmac_aes256_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CMAC_H_INCLUDED */
diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index 4efcca5c..b8062c5b 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -64,6 +64,7 @@
 #include "sha3.h"
 #include "twofish.h"
 #include "umac.h"
+#include "cmac.h"
 #include "poly1305.h"
 
 #include "nettle-meta.h"
@@ -403,7 +404,7 @@ time_umac(void)
   struct umac64_ctx ctx64;
   struct umac96_ctx ctx96;
   struct umac128_ctx ctx128;
-  
+
   uint8_t key[16];
 
   umac32_set_key (&amp;ctx32, key);
@@ -439,6 +440,24 @@ time_umac(void)
 	  time_function(bench_hash, &amp;info));
 }
 
+static void
+time_cmac(void)
+{
+  static uint8_t data[BENCH_BLOCK];
+  struct bench_hash_info info;
+  struct cmac_aes128_ctx ctx;
+
+  uint8_t key[16];
+
+  cmac_aes128_set_key (&amp;ctx, key);
+  info.ctx = 
+  info.update = (nettle_hash_update_func *) cmac_aes128_update;
+  info.data = data;
+
+  display("cmac-aes128", "update", AES_BLOCK_SIZE,
+	  time_function(bench_hash, &amp;info));
+}
+
 static void
 time_poly1305_aes(void)
 {
@@ -846,6 +865,9 @@ main(int argc, char **argv)
       if (!alg || strstr ("umac", alg))
 	time_umac();
 
+      if (!alg || strstr ("cmac", alg))
+	time_cmac();
+
       if (!alg || strstr ("poly1305-aes", alg))
 	time_poly1305_aes();
 
diff --git a/nettle.texinfo b/nettle.texinfo
index f501cfbe..bfc97b5e 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -101,6 +101,7 @@ Keyed Hash Functions
 
 * HMAC::
 * UMAC::
+* CMAC::
 
 Public-key algorithms
 
@@ -271,6 +272,9 @@ The implementation of the TWOFISH cipher is written by Ruud de \
Rooij.  @item UMAC
 Written by @value{AUTHOR}.
 
+@item CMAC
+Written by Nikos Mavrogiannopoulos, @value{AUTHOR}, Jeremy Allison, Michael Adam and \
Stefan Metzmacher. +
 @item RSA
 Written by @value{AUTHOR}. Uses the GMP library for bignum operations.
 
@@ -3134,6 +3138,7 @@ as well.
 @menu
 * HMAC::
 * UMAC::
+* CMAC::
 * Poly1305::
 @end menu
 
@@ -3476,7 +3481,60 @@ as described above, the new value is used unless you call the
 @code{_set_nonce} function explicitly for each message.
 @end deftypefun
 
-@node Poly1305,, UMAC, Keyed hash functions
+@node CMAC,, UMAC, Keyed hash functions
+@subsection @acronym{CMAC}
+@cindex CMAC
+
+@acronym{CMAC} is a message authentication code based on CBC encryption
+mode. It is suitable for systems where block ciphers are preferrable
+and perform better than hash functions. @acronym{CMAC} is specified in
+@cite{RFC4493}. The block size is always 128 bits (16 octets).
+
+Nettle provides helper functions for @acronym{CMAC } with
+the @acronym{AES} block cipher.
+
+Nettle defines @acronym{CMAC} in @file{&lt;nettle/cmac.h&gt;}.
+
+@deftp {Context struct} {struct cmac128_ctx}
+@end deftp
+
+@defvr Constant CMAC128_DIGEST_SIZE
+The size of an CMAC digest, 16.
+@end defvr
+
+@deftypefun void cmac_aes128_set_key (struct cmac_aes128_ctx *@var{ctx}, const \
uint8_t *@var{key}) +This function initializes the @acronym{CMAC} context struct for \
AES-128. +@end deftypefun
+
+@deftypefun void cmac_aes128_update (struct cmac_aes128_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +This function is called zero or more times \
to process the message. +@end deftypefun
+
+@deftypefun void cmac_aes128_digest (struct cmac_aes128_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Extracts the @acronym{MAC} of the message, \
writing it to @var{digest}. +@var{length} is usually equal to the specified output \
size, but if you +provide a smaller value, only the first @var{length} octets of the
+@acronym{MAC} are written. This function resets the context for
+processing of a new message with the same key.
+@end deftypefun
+
+@deftypefun void cmac_aes256_set_key (struct cmac_aes256_ctx *@var{ctx}, const \
uint8_t *@var{key}) +This function initializes the @acronym{CMAC} context struct for \
AES-256. +@end deftypefun
+
+@deftypefun void cmac_aes256_update (struct cmac_aes256_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +This function is called zero or more times \
to process the message. +@end deftypefun
+
+@deftypefun void cmac_aes256_digest (struct cmac_aes256_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Extracts the @acronym{MAC} of the message, \
writing it to @var{digest}. +@var{length} is usually equal to the specified output \
size, but if you +provide a smaller value, only the first @var{length} octets of the
+@acronym{MAC} are written. This function resets the context for
+processing of a new message with the same key.
+@end deftypefun
+
+@node Poly1305,, CMAC, Keyed hash functions
 @comment  node-name,  next,  previous,  up
 @subsection Poly1305
 
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 1f780310..c7e04cb4 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -130,6 +130,9 @@ eax-test$(EXEEXT): eax-test.$(OBJEXT)
 ccm-test$(EXEEXT): ccm-test.$(OBJEXT)
 	$(LINK) ccm-test.$(OBJEXT) $(TEST_OBJS) -o ccm-test$(EXEEXT)
 
+cmac-test$(EXEEXT): cmac-test.$(OBJEXT)
+	$(LINK) cmac-test.$(OBJEXT) $(TEST_OBJS) -o cmac-test$(EXEEXT)
+
 poly1305-test$(EXEEXT): poly1305-test.$(OBJEXT)
 	$(LINK) poly1305-test.$(OBJEXT) $(TEST_OBJS) -o poly1305-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 3117d66d..dd1ecf41 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -26,6 +26,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    serpent-test.c twofish-test.c version-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c cfb-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
+		    cmac-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
new file mode 100644
index 00000000..58544f2a
--- /dev/null
+++ b/testsuite/cmac-test.c
@@ -0,0 +1,146 @@
+#include "testutils.h"
+#include "nettle-internal.h"
+#include "cmac.h"
+
+typedef void set_key_func(void *ctx, const uint8_t *key);
+typedef void update_func(void *ctx, size_t length, const uint8_t *data);
+typedef void digest_func(void *ctx, size_t length, uint8_t *digest);
+
+#define test_cmac_aes128(key, msg, ref) \
+	test_cmac_hash ((set_key_func*)cmac_aes128_set_key, \
(update_func*)cmac_aes128_update, \ +			(digest_func*)cmac_aes128_digest, \
sizeof(struct cmac_aes128_ctx), \ +			key, msg, ref)
+
+#define test_cmac_aes256(key, msg, ref) \
+	test_cmac_hash ((set_key_func*)cmac_aes256_set_key, \
(update_func*)cmac_aes256_update, \ +			(digest_func*)cmac_aes256_digest, \
sizeof(struct cmac_aes256_ctx), \ +			key, msg, ref)
+
+static void
+test_cmac_hash (set_key_func *set_key, update_func *update,
+		digest_func *digest, size_t ctx_size,
+		const struct tstring *key, const struct tstring *msg,
+		const struct tstring *ref)
+{
+  void *ctx;
+  uint8_t hash[16];
+  unsigned i;
+
+  ctx = xalloc(ctx_size);
+
+  ASSERT (ref-&gt;length == sizeof(hash));
+  ASSERT (key-&gt;length == 16 || key-&gt;length == 32);
+  set_key (ctx, key-&gt;data);
+  update (ctx, msg-&gt;length, msg-&gt;data);
+  digest (ctx, sizeof(hash), hash);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
+    {
+      fprintf (stderr, "cmac_hash failed, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt to re-use the structure */
+  update (ctx, msg-&gt;length, msg-&gt;data);
+  digest (ctx, sizeof(hash), hash);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
+    {
+      fprintf (stderr, "cmac_hash failed on re-use, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt byte-by-byte hashing */
+  set_key (ctx, key-&gt;data);
+  for (i=0;i&lt;msg-&gt;length;i++)
+    update (ctx, 1, msg-&gt;data+i);
+  digest (ctx, sizeof(hash), hash);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
+    {
+      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+}
+
+void
+test_main(void)
+{
+  /*
+   * CMAC-AES Test Vectors from RFC4493.
+   */
+  test_cmac_aes128 (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SDATA(""),
+		  SHEX("bb1d6929e95937287fa37d129b756746"));
+
+  test_cmac_aes128 (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
+		  SHEX("070a16b46b4d4144f79bdd9dd04a287c"));
+
+  test_cmac_aes128 (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("dfa66747de9ae63030ca32611497c827"));
+
+  test_cmac_aes128 (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411e5fbc1191a0a52ef"
+		       "f69f2445df4f9b17ad2b417be66c3710"),
+		  SHEX("51f0bebf7e3b9d92fc49741779363cfe"));
+
+  /* Additional tests with different keys (same plaintext)
+   * to check all variants of set_key() */
+  test_cmac_aes128 (SHEX("2b7e151628aed2a8abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("87dd33c2945a4e228028690ae8954945"));
+
+  test_cmac_aes128 (SHEX("2b7e1ab628aed2a8abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("f0dc613a88886c7ed76eeb51f1c5e8d3"));
+
+  test_cmac_aes128 (SHEX("2b7e1ab628aed2a8abf7158809cf4f3d"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("b9d092dc387a9e42cdfeb9f9930cf567"));
+
+  /* CMAC-AES256 vectors taken from phplib */
+  test_cmac_aes256 (SHEX("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"),
 +		  SDATA(""),
+		  SHEX("028962f61b7bf89efc6b551f4667d983"));
+
+  test_cmac_aes256 (SHEX("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"),
 +		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
+		  SHEX("28a7023f452e8f82bd4bf28d8c37c35c"));
+
+  test_cmac_aes256 (SHEX("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"),
 +		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411"),
 +		  SHEX("aaf3d8f1de5640c232f5b169b9c911e6"));
+
+  test_cmac_aes256 (SHEX("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"),
 +		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710"),
 +		  SHEX("e1992190549f6ed5696a2c056c315410"));
+
+}
+
-- 
2.14.3



</body></email><email><emailId>20180216085215</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-02-16 08:52:15-0400</timestampReceived><subject>Re: cmac</subject><body>

On Thu, 2018-02-15 at 09:45 +0100, Nikos Mavrogiannopoulos wrote:
&gt; On Thu, 2018-02-15 at 07:53 +0100, Niels Möller wrote:
&gt; &gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; &gt; 
&gt; &gt; &gt; +@acronym{CMAC} is a message authentication code based on CBC
&gt; &gt; &gt; encryption
&gt; &gt; &gt; +mode. It is suitable for systems where block ciphers are
&gt; &gt; &gt; preferrable
&gt; &gt; &gt; +and perform better than hash functions. @acronym{CMAC} is
&gt; &gt; &gt; specified in
&gt; &gt; &gt; +@cite{RFC4493}. The secret key is always 128 bits (16 octets).
&gt; &gt; 
&gt; &gt; Should be "block size", not "secret key", right?
&gt; 
&gt; Right. Updated patch (and merged all), to include this fix, and the
&gt; naming
&gt; of variables (including changing out to dst).

While using that code, I realized that the CMAC128_UPDATE was misusing
the 'data' field. In the attached patch I've renamed it to 'src' to
avoid ambiguities.

regards,
Nikos

["0001-Added-support-for-CMAC.patch" (0001-Added-support-for-CMAC.patch)]

From 409e1f703858b25a0a66b0e9923b4f1b6f1e1b41 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 10 Jan 2018 09:29:17 +0100
Subject: [PATCH] Added support for CMAC

That adds support for CMAC as a generic framework for
128-bit block and key ciphers, as well as API for AES-128-CMAC,
and AES-256-CMAC.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 Makefile.in                 |   2 +
 cmac-aes128.c               |  60 +++++++++++++++++
 cmac-aes256.c               |  60 +++++++++++++++++
 cmac.c                      | 158 ++++++++++++++++++++++++++++++++++++++++++++
 cmac.h                      | 133 +++++++++++++++++++++++++++++++++++++
 examples/nettle-benchmark.c |  24 ++++++-
 nettle.texinfo              |  60 ++++++++++++++++-
 testsuite/.test-rules.make  |   3 +
 testsuite/Makefile.in       |   1 +
 testsuite/cmac-test.c       | 146 ++++++++++++++++++++++++++++++++++++++++
 10 files changed, 645 insertions(+), 2 deletions(-)
 create mode 100644 cmac-aes128.c
 create mode 100644 cmac-aes256.c
 create mode 100644 cmac.c
 create mode 100644 cmac.h
 create mode 100644 testsuite/cmac-test.c

diff --git a/Makefile.in b/Makefile.in
index 4444e8bd..de12bb3f 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -100,6 +100,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-aes256.c gcm-aes256-meta.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
+		 cmac.c cmac-aes128.c cmac-aes256.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
@@ -192,6 +193,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  gcm.h gosthash94.h hmac.h \
 	  knuth-lfib.h hkdf.h \
 	  macros.h \
+	  cmac.h \
 	  md2.h md4.h \
 	  md5.h md5-compat.h \
 	  memops.h memxor.h \
diff --git a/cmac-aes128.c b/cmac-aes128.c
new file mode 100644
index 00000000..e53e114e
--- /dev/null
+++ b/cmac-aes128.c
@@ -0,0 +1,60 @@
+/* cmac-aes128.c
+
+   CMAC using AES128 as the underlying cipher.
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "cmac.h"
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key)
+{
+  CMAC128_SET_KEY(ctx, aes128_set_encrypt_key, aes128_encrypt, key);
+}
+
+void
+cmac_aes128_update (struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  CMAC128_UPDATE (ctx, aes128_encrypt, length, data);
+}
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  CMAC128_DIGEST(ctx, aes128_encrypt, length, digest);
+}
diff --git a/cmac-aes256.c b/cmac-aes256.c
new file mode 100644
index 00000000..ec3b50db
--- /dev/null
+++ b/cmac-aes256.c
@@ -0,0 +1,60 @@
+/* cmac-aes256.c
+
+   CMAC using AES256 as the underlying cipher.
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "cmac.h"
+
+void
+cmac_aes256_set_key(struct cmac_aes256_ctx *ctx, const uint8_t *key)
+{
+  CMAC128_SET_KEY(ctx, aes256_set_encrypt_key, aes256_encrypt, key);
+}
+
+void
+cmac_aes256_update (struct cmac_aes256_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  CMAC128_UPDATE (ctx, aes256_encrypt, length, data);
+}
+
+void
+cmac_aes256_digest(struct cmac_aes256_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  CMAC128_DIGEST(ctx, aes256_encrypt, length, digest);
+}
diff --git a/cmac.c b/cmac.c
new file mode 100644
index 00000000..95d45de4
--- /dev/null
+++ b/cmac.c
@@ -0,0 +1,158 @@
+/*
+   AES-CMAC-128 (rfc 4493)
+   Copyright (C) Stefan Metzmacher 2012
+   Copyright (C) Jeremy Allison 2012
+   Copyright (C) Michael Adam 2012
+   Copyright (C) 2017, Red Hat Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "cmac.h"
+
+#include "memxor.h"
+#include "nettle-internal.h"
+#include "macros.h"
+
+static const uint8_t const_zero[] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
+};
+
+/* shift one and XOR with 0x87. */
+static inline void block_mulx(union nettle_block16 *dst,
+			      const union nettle_block16 *src)
+{
+	uint64_t b1 = READ_UINT64(src-&gt;b);
+	uint64_t b2 = READ_UINT64(src-&gt;b+8);
+
+	b1 = (b1 &lt;&lt; 1) | (b2 &gt;&gt; 63);
+	b2 &lt;&lt;= 1;
+
+	if (src-&gt;b[0] &amp; 0x80)
+		b2 ^= 0x87;
+
+	WRITE_UINT64(dst-&gt;b, b1);
+	WRITE_UINT64(dst-&gt;b+8, b2);
+}
+
+void cmac128_set_key(struct cmac128 *ctx, void *cipher,
+		     nettle_cipher_func *encrypt)
+{
+	union nettle_block16 *L = &amp;ctx-&gt;block;
+	memset(ctx, 0, sizeof(*ctx));
+
+	/* step 1 - generate subkeys k1 and k2 */
+	encrypt(cipher, 16, L-&gt;b, const_zero);
+
+	block_mulx(&amp;ctx-&gt;K1, L);
+	block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
+}
+
+#define MIN(x,y) ((x)&lt;(y)?(x):(y))
+
+void cmac128_update(struct cmac128 *ctx, void *cipher,
+		    nettle_cipher_func *encrypt,
+		    size_t msg_len, const uint8_t *msg)
+{
+	union nettle_block16 Y;
+	/*
+	 * check if we expand the block
+	 */
+	if (ctx-&gt;index &lt; 16) {
+		size_t len = MIN(16 - ctx-&gt;index, msg_len);
+		memcpy(&amp;ctx-&gt;block.b[ctx-&gt;index], msg, len);
+		msg += len;
+		msg_len -= len;
+		ctx-&gt;index += len;
+	}
+
+	if (msg_len == 0) {
+		/* if it is still the last block, we are done */
+		return;
+	}
+
+	/*
+	 * now checksum everything but the last block
+	 */
+	memxor3(Y.b, ctx-&gt;X.b, ctx-&gt;block.b, 16);
+	encrypt(cipher, 16, ctx-&gt;X.b, Y.b);
+
+	while (msg_len &gt; 16) {
+		memxor3(Y.b, ctx-&gt;X.b, msg, 16);
+		encrypt(cipher, 16, ctx-&gt;X.b, Y.b);
+		msg += 16;
+		msg_len -= 16;
+	}
+
+	/*
+	 * copy the last block, it will be processed in
+	 * cmac128_digest().
+	 */
+	memcpy(ctx-&gt;block.b, msg, msg_len);
+	ctx-&gt;index = msg_len;
+}
+
+void cmac128_digest(struct cmac128 *ctx, void *cipher,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *dst)
+{
+	union nettle_block16 Y;
+
+	memset(ctx-&gt;block.b+ctx-&gt;index, 0, sizeof(ctx-&gt;block.b)-ctx-&gt;index);
+
+	/* re-use ctx-&gt;block for memxor output */
+	if (ctx-&gt;index &lt; 16) {
+		ctx-&gt;block.b[ctx-&gt;index] = 0x80;
+		memxor(ctx-&gt;block.b, ctx-&gt;K2.b, 16);
+	} else {
+		memxor(ctx-&gt;block.b, ctx-&gt;K1.b, 16);
+	}
+
+	memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 16);
+
+	assert(length &lt;= 16);
+	if (length == 16) {
+		encrypt(cipher, 16, dst, Y.b);
+	} else {
+		encrypt(cipher, 16, ctx-&gt;block.b, Y.b);
+		memcpy(dst, ctx-&gt;block.b, length);
+	}
+
+	/* reset state for re-use */
+	memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
+	ctx-&gt;index = 0;
+}
diff --git a/cmac.h b/cmac.h
new file mode 100644
index 00000000..2d63eb73
--- /dev/null
+++ b/cmac.h
@@ -0,0 +1,133 @@
+/* cmac.h
+
+   CMAC mode, as specified in RFC4493
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   Contributed by Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_CMAC_H_INCLUDED
+#define NETTLE_CMAC_H_INCLUDED
+
+#include "aes.h"
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CMAC128_DIGEST_SIZE 16
+
+#define cmac128_set_key nettle_cmac128_set_key
+#define cmac128_update nettle_cmac128_update
+#define cmac128_digest nettle_cmac128_digest
+#define cmac_aes128_set_key nettle_cmac_aes128_set_key
+#define cmac_aes128_update nettle_cmac_aes128_update
+#define cmac_aes128_digest nettle_cmac_aes128_digest
+#define cmac_aes256_set_key nettle_cmac_aes256_set_key
+#define cmac_aes256_update nettle_cmac_aes256_update
+#define cmac_aes256_digest nettle_cmac_aes256_digest
+
+struct cmac128 {
+	union nettle_block16 K1;
+	union nettle_block16 K2;
+
+	union nettle_block16 X;
+
+	union nettle_block16 block;
+	size_t index;
+};
+
+void cmac128_set_key(struct cmac128 *ctx, void *cipher,
+		     nettle_cipher_func *encrypt);
+void cmac128_update(struct cmac128 *ctx, void *cipher,
+		 nettle_cipher_func *encrypt,
+		 size_t msg_len, const uint8_t *msg);
+void cmac128_digest(struct cmac128 *ctx, void *cipher,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *out);
+
+
+#define CMAC128_CTX(type) \
+  { struct cmac128 data; type cipher; }
+
+/* NOTE: Avoid using NULL, as we don't include anything defining it. */
+#define CMAC128_SET_KEY(ctx, set_key, encrypt, cmac_key)		\
+  do {								\
+    (set_key)(&amp;(ctx)-&gt;cipher, (cmac_key));			\
+    if (0) (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,		\
+		     (uint8_t *) 0, (const uint8_t *) 0);	\
+    cmac128_set_key(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		(nettle_cipher_func *) (encrypt));		\
+  } while (0)
+
+#define CMAC128_UPDATE(ctx, encrypt, length, src)			\
+  cmac128_update(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher, \
+	      (nettle_cipher_func *)encrypt, (length), (src))
+
+#define CMAC128_DIGEST(ctx, encrypt, length, digest)			\
+  (0 ? (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,				\
+		 (uint8_t *) 0, (const uint8_t *) 0)			\
+     : cmac128_digest(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		  (nettle_cipher_func *) (encrypt),			\
+		  (length), (digest)))
+
+struct cmac_aes128_ctx CMAC128_CTX(struct aes128_ctx);
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key);
+
+void
+cmac_aes128_update(struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
+struct cmac_aes256_ctx CMAC128_CTX(struct aes256_ctx);
+
+void
+cmac_aes256_set_key(struct cmac_aes256_ctx *ctx, const uint8_t *key);
+
+void
+cmac_aes256_update(struct cmac_aes256_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+cmac_aes256_digest(struct cmac_aes256_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CMAC_H_INCLUDED */
diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index 4efcca5c..b8062c5b 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -64,6 +64,7 @@
 #include "sha3.h"
 #include "twofish.h"
 #include "umac.h"
+#include "cmac.h"
 #include "poly1305.h"
 
 #include "nettle-meta.h"
@@ -403,7 +404,7 @@ time_umac(void)
   struct umac64_ctx ctx64;
   struct umac96_ctx ctx96;
   struct umac128_ctx ctx128;
-  
+
   uint8_t key[16];
 
   umac32_set_key (&amp;ctx32, key);
@@ -439,6 +440,24 @@ time_umac(void)
 	  time_function(bench_hash, &amp;info));
 }
 
+static void
+time_cmac(void)
+{
+  static uint8_t data[BENCH_BLOCK];
+  struct bench_hash_info info;
+  struct cmac_aes128_ctx ctx;
+
+  uint8_t key[16];
+
+  cmac_aes128_set_key (&amp;ctx, key);
+  info.ctx = 
+  info.update = (nettle_hash_update_func *) cmac_aes128_update;
+  info.data = data;
+
+  display("cmac-aes128", "update", AES_BLOCK_SIZE,
+	  time_function(bench_hash, &amp;info));
+}
+
 static void
 time_poly1305_aes(void)
 {
@@ -846,6 +865,9 @@ main(int argc, char **argv)
       if (!alg || strstr ("umac", alg))
 	time_umac();
 
+      if (!alg || strstr ("cmac", alg))
+	time_cmac();
+
       if (!alg || strstr ("poly1305-aes", alg))
 	time_poly1305_aes();
 
diff --git a/nettle.texinfo b/nettle.texinfo
index f501cfbe..bfc97b5e 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -101,6 +101,7 @@ Keyed Hash Functions
 
 * HMAC::
 * UMAC::
+* CMAC::
 
 Public-key algorithms
 
@@ -271,6 +272,9 @@ The implementation of the TWOFISH cipher is written by Ruud de \
Rooij.  @item UMAC
 Written by @value{AUTHOR}.
 
+@item CMAC
+Written by Nikos Mavrogiannopoulos, @value{AUTHOR}, Jeremy Allison, Michael Adam and \
Stefan Metzmacher. +
 @item RSA
 Written by @value{AUTHOR}. Uses the GMP library for bignum operations.
 
@@ -3134,6 +3138,7 @@ as well.
 @menu
 * HMAC::
 * UMAC::
+* CMAC::
 * Poly1305::
 @end menu
 
@@ -3476,7 +3481,60 @@ as described above, the new value is used unless you call the
 @code{_set_nonce} function explicitly for each message.
 @end deftypefun
 
-@node Poly1305,, UMAC, Keyed hash functions
+@node CMAC,, UMAC, Keyed hash functions
+@subsection @acronym{CMAC}
+@cindex CMAC
+
+@acronym{CMAC} is a message authentication code based on CBC encryption
+mode. It is suitable for systems where block ciphers are preferrable
+and perform better than hash functions. @acronym{CMAC} is specified in
+@cite{RFC4493}. The block size is always 128 bits (16 octets).
+
+Nettle provides helper functions for @acronym{CMAC } with
+the @acronym{AES} block cipher.
+
+Nettle defines @acronym{CMAC} in @file{&lt;nettle/cmac.h&gt;}.
+
+@deftp {Context struct} {struct cmac128_ctx}
+@end deftp
+
+@defvr Constant CMAC128_DIGEST_SIZE
+The size of an CMAC digest, 16.
+@end defvr
+
+@deftypefun void cmac_aes128_set_key (struct cmac_aes128_ctx *@var{ctx}, const \
uint8_t *@var{key}) +This function initializes the @acronym{CMAC} context struct for \
AES-128. +@end deftypefun
+
+@deftypefun void cmac_aes128_update (struct cmac_aes128_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +This function is called zero or more times \
to process the message. +@end deftypefun
+
+@deftypefun void cmac_aes128_digest (struct cmac_aes128_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Extracts the @acronym{MAC} of the message, \
writing it to @var{digest}. +@var{length} is usually equal to the specified output \
size, but if you +provide a smaller value, only the first @var{length} octets of the
+@acronym{MAC} are written. This function resets the context for
+processing of a new message with the same key.
+@end deftypefun
+
+@deftypefun void cmac_aes256_set_key (struct cmac_aes256_ctx *@var{ctx}, const \
uint8_t *@var{key}) +This function initializes the @acronym{CMAC} context struct for \
AES-256. +@end deftypefun
+
+@deftypefun void cmac_aes256_update (struct cmac_aes256_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +This function is called zero or more times \
to process the message. +@end deftypefun
+
+@deftypefun void cmac_aes256_digest (struct cmac_aes256_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Extracts the @acronym{MAC} of the message, \
writing it to @var{digest}. +@var{length} is usually equal to the specified output \
size, but if you +provide a smaller value, only the first @var{length} octets of the
+@acronym{MAC} are written. This function resets the context for
+processing of a new message with the same key.
+@end deftypefun
+
+@node Poly1305,, CMAC, Keyed hash functions
 @comment  node-name,  next,  previous,  up
 @subsection Poly1305
 
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 1f780310..c7e04cb4 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -130,6 +130,9 @@ eax-test$(EXEEXT): eax-test.$(OBJEXT)
 ccm-test$(EXEEXT): ccm-test.$(OBJEXT)
 	$(LINK) ccm-test.$(OBJEXT) $(TEST_OBJS) -o ccm-test$(EXEEXT)
 
+cmac-test$(EXEEXT): cmac-test.$(OBJEXT)
+	$(LINK) cmac-test.$(OBJEXT) $(TEST_OBJS) -o cmac-test$(EXEEXT)
+
 poly1305-test$(EXEEXT): poly1305-test.$(OBJEXT)
 	$(LINK) poly1305-test.$(OBJEXT) $(TEST_OBJS) -o poly1305-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 3117d66d..dd1ecf41 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -26,6 +26,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    serpent-test.c twofish-test.c version-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c cfb-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
+		    cmac-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
new file mode 100644
index 00000000..58544f2a
--- /dev/null
+++ b/testsuite/cmac-test.c
@@ -0,0 +1,146 @@
+#include "testutils.h"
+#include "nettle-internal.h"
+#include "cmac.h"
+
+typedef void set_key_func(void *ctx, const uint8_t *key);
+typedef void update_func(void *ctx, size_t length, const uint8_t *data);
+typedef void digest_func(void *ctx, size_t length, uint8_t *digest);
+
+#define test_cmac_aes128(key, msg, ref) \
+	test_cmac_hash ((set_key_func*)cmac_aes128_set_key, \
(update_func*)cmac_aes128_update, \ +			(digest_func*)cmac_aes128_digest, \
sizeof(struct cmac_aes128_ctx), \ +			key, msg, ref)
+
+#define test_cmac_aes256(key, msg, ref) \
+	test_cmac_hash ((set_key_func*)cmac_aes256_set_key, \
(update_func*)cmac_aes256_update, \ +			(digest_func*)cmac_aes256_digest, \
sizeof(struct cmac_aes256_ctx), \ +			key, msg, ref)
+
+static void
+test_cmac_hash (set_key_func *set_key, update_func *update,
+		digest_func *digest, size_t ctx_size,
+		const struct tstring *key, const struct tstring *msg,
+		const struct tstring *ref)
+{
+  void *ctx;
+  uint8_t hash[16];
+  unsigned i;
+
+  ctx = xalloc(ctx_size);
+
+  ASSERT (ref-&gt;length == sizeof(hash));
+  ASSERT (key-&gt;length == 16 || key-&gt;length == 32);
+  set_key (ctx, key-&gt;data);
+  update (ctx, msg-&gt;length, msg-&gt;data);
+  digest (ctx, sizeof(hash), hash);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
+    {
+      fprintf (stderr, "cmac_hash failed, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt to re-use the structure */
+  update (ctx, msg-&gt;length, msg-&gt;data);
+  digest (ctx, sizeof(hash), hash);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
+    {
+      fprintf (stderr, "cmac_hash failed on re-use, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt byte-by-byte hashing */
+  set_key (ctx, key-&gt;data);
+  for (i=0;i&lt;msg-&gt;length;i++)
+    update (ctx, 1, msg-&gt;data+i);
+  digest (ctx, sizeof(hash), hash);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
+    {
+      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+}
+
+void
+test_main(void)
+{
+  /*
+   * CMAC-AES Test Vectors from RFC4493.
+   */
+  test_cmac_aes128 (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SDATA(""),
+		  SHEX("bb1d6929e95937287fa37d129b756746"));
+
+  test_cmac_aes128 (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
+		  SHEX("070a16b46b4d4144f79bdd9dd04a287c"));
+
+  test_cmac_aes128 (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("dfa66747de9ae63030ca32611497c827"));
+
+  test_cmac_aes128 (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411e5fbc1191a0a52ef"
+		       "f69f2445df4f9b17ad2b417be66c3710"),
+		  SHEX("51f0bebf7e3b9d92fc49741779363cfe"));
+
+  /* Additional tests with different keys (same plaintext)
+   * to check all variants of set_key() */
+  test_cmac_aes128 (SHEX("2b7e151628aed2a8abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("87dd33c2945a4e228028690ae8954945"));
+
+  test_cmac_aes128 (SHEX("2b7e1ab628aed2a8abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("f0dc613a88886c7ed76eeb51f1c5e8d3"));
+
+  test_cmac_aes128 (SHEX("2b7e1ab628aed2a8abf7158809cf4f3d"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("b9d092dc387a9e42cdfeb9f9930cf567"));
+
+  /* CMAC-AES256 vectors taken from phplib */
+  test_cmac_aes256 (SHEX("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"),
 +		  SDATA(""),
+		  SHEX("028962f61b7bf89efc6b551f4667d983"));
+
+  test_cmac_aes256 (SHEX("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"),
 +		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
+		  SHEX("28a7023f452e8f82bd4bf28d8c37c35c"));
+
+  test_cmac_aes256 (SHEX("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"),
 +		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411"),
 +		  SHEX("aaf3d8f1de5640c232f5b169b9c911e6"));
+
+  test_cmac_aes256 (SHEX("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"),
 +		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710"),
 +		  SHEX("e1992190549f6ed5696a2c056c315410"));
+
+}
+
-- 
2.14.3



</body></email><email><emailId>20180219220131</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-19 22:01:31-0400</timestampReceived><subject>Re: cmac</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; While using that code, I realized that the CMAC128_UPDATE was misusing
&gt; the 'data' field. In the attached patch I've renamed it to 'src' to
&gt; avoid ambiguities.

Pushed to a branch "cmac-support", together with ChangeLog and some
cleanups:

	* cmac.h (struct cmac128): Rename, to cmac128_ctx.
	(CMAC128_CTX): Rename first member from data to ctx.

	* cmac.c: Use const void * as the type for cipher arguments.
	(block_mulx): Un-inline.
	(cmac128_set_key): Make a constant function local.

	* testsuite/cmac-test.c: Delete local typedefs.

Thanks!
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180219142725</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-19 14:27:25-0400</timestampReceived><subject>Re: TMP_DECL_ALIGN</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; #define ALIGN16(x) \
&gt;         ((void *)(((ptrdiff_t)(x)+(ptrdiff_t)0x0f)&amp;~((ptrdiff_t)0x0f)))

I think I'd prefer allocating a uint64_t array (largest type used in
nettle context structs), and leave to the compiler to figure out what
alignment is needed and how to get it.

&gt; What about this macros (untested, just idea demo):
&gt;
&gt; #if defined(HAVE_ALLOCA)
&gt; # define TMP_DECL_ALLOC(name, type, max, size) type *name =
&gt; alloca(sizeof (*name) * (size)))
&gt; #else if __STDC_VERSION__ &gt;= 199901L
&gt; # define TMP_DECL_ALLOC(name, type, max, size) \
&gt;   type _tmp##name[size+16]; \
&gt;   type *name = ALIGN16(_tmp##name)
&gt; #else /* fallback for pre-C99 and pre-alloca() times
&gt; # define TMP_DECL_ALLOC(name, type, max, size) \
&gt;   type _tmp##name[max+16]; \
&gt;   type *name = ALIGN16(_tmp##name); \
&gt;   assert(size &lt;= max)
&gt; #endif

Not so nice with number of cases increased from two to three. But as you
suggest, maybe we don't need the third case.

But I wonder if we can get down to just one case. Which relevant
compilers don't support variable length arrays? I'd guess this could be
expeted mainly for embedded platforms with either older compilers, or
c11 compilers taking advantage of variable-length arrays being optional.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180219150523</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-02-19 15:05:23-0400</timestampReceived><subject>Re: TMP_DECL_ALIGN</subject><body>

On Mon, 2018-02-19 at 15:27 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; 
&gt; &gt; #define ALIGN16(x) \
&gt; &gt;         ((void
&gt; &gt; *)(((ptrdiff_t)(x)+(ptrdiff_t)0x0f)&amp;~((ptrdiff_t)0x0f)))
&gt; 
&gt; I think I'd prefer allocating a uint64_t array (largest type used in
&gt; nettle context structs), and leave to the compiler to figure out what
&gt; alignment is needed and how to get it.

That way you get 8-byte alignment which is ok, but if you use it for
aesni key state for example, it results to slower operations.

&gt; &gt; What about this macros (untested, just idea demo):
&gt; &gt; 
&gt; &gt; #if defined(HAVE_ALLOCA)
&gt; &gt; # define TMP_DECL_ALLOC(name, type, max, size) type *name =
&gt; &gt; alloca(sizeof (*name) * (size)))
&gt; &gt; #else if __STDC_VERSION__ &gt;= 199901L
&gt; &gt; # define TMP_DECL_ALLOC(name, type, max, size) \
&gt; &gt;   type _tmp##name[size+16]; \
&gt; &gt;   type *name = ALIGN16(_tmp##name)
&gt; &gt; #else /* fallback for pre-C99 and pre-alloca() times
&gt; &gt; # define TMP_DECL_ALLOC(name, type, max, size) \
&gt; &gt;   type _tmp##name[max+16]; \
&gt; &gt;   type *name = ALIGN16(_tmp##name); \
&gt; &gt;   assert(size &lt;= max)
&gt; &gt; #endif
&gt; 
&gt; Not so nice with number of cases increased from two to three. But as
&gt; you
&gt; suggest, maybe we don't need the third case.
&gt; 
&gt; But I wonder if we can get down to just one case. Which relevant
&gt; compilers don't support variable length arrays? I'd guess this could
&gt; be
&gt; expeted mainly for embedded platforms with either older compilers, or
&gt; c11 compilers taking advantage of variable-length arrays being
&gt; optional.

I don't really know. gnutls requires C99 to work, though I couldn't
find any usage of variable arrays on the code.

Said that, variable arrays and alloca() are ok when the input doesn't
come externally but I'm not sure if we can enforce that in nettle. What
about moving to malloc() unconditionally?

regards,
Nikos


</body></email><email><emailId>20180217122741</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-17 12:27:41-0400</timestampReceived><subject>Re: [PATCH 1/2] Provide wrappers around OpenSSL AES GCM</subject><body>

Jeffrey Walton &lt;noloader@gmail.com&gt; writes:

&gt; No asserts, period. They should not get through an audit.

I see that you have a strong opinion on the subject. I'll state my
opinion, but I don't want to get into a heated debate.

When the condition in an assert is fails, that's evidence of a software
bug. In my experience, it's usually prefable to crash immediately and in
a controlled manner, to reduce risk of silent data corruption,
exploitable buffer overruns, and the like. I guess there are a few
applications where it might be better for the program to continua
running and hope for the best, but those are exceptions.

&gt; What happens when the abort happens?

That depends on various per-process and system-level settings.

Thaere are lots of possibly software bugs that can lead to a crash of
the process, not all involving any asserts. I think it's common practice
in security critical applications to disable core dumps using the
standard ulimit facility. I can't see asserts as a problem at all in
this context.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180217123647</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-17 12:36:47-0400</timestampReceived><subject>Re: [PATCH 1/2] Provide wrappers around OpenSSL AES GCM</subject><body>

Jeffrey Walton &lt;noloader@gmail.com&gt; writes:

&gt; But production is a different story.... The time for debugging is over...

I would generally assume that there are a few bugs left in also the
production code. And I think that in most cases, the bug manifesting
itself as an assertion failure is a lot better then the alternatives.

I know there are different opinions. We should support -DNDEBUG builds,
but it's not going to be the default in Nettle.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180217124318</emailId><senderName>Amos Jeffries</senderName><senderEmail>squid3@treenet.co.nz</senderEmail><timestampReceived>2018-02-17 12:43:18-0400</timestampReceived><subject>Re: [PATCH 1/2] Provide wrappers around OpenSSL AES GCM</subject><body>

On 18/02/18 00:48, Nikos Mavrogiannopoulos wrote:
&gt; 
&gt; 
&gt; On February 17, 2018 9:35:34 AM UTC, nisse wrote:
&gt; &gt; Dmitry Eremin-Solenikov writes:
&gt; &gt; 
&gt; &gt; &gt; For benchmarking purposes provide wrappers around OpenSSL AES GCM
&gt; &gt; &gt; implementation. Note, digest callback will work only for encryption
&gt; &gt; due
&gt; &gt; &gt; to OpenSSL internals.
&gt; &gt; 
&gt; &gt; This patch and the next now merged to master-updates.
&gt; &gt; 
&gt; &gt; &gt; @@ -80,7 +80,7 @@ openssl_evp_set_encrypt_key(void *p, const uint8_t
&gt; &gt; *key,
&gt; &gt; &gt; {
&gt; &gt; &gt; struct openssl_cipher_ctx *ctx = p;
&gt; &gt; &gt; ctx-&gt;evp = EVP_CIPHER_CTX_new();
&gt; &gt; &gt; -  assert(EVP_EncryptInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL) ==
&gt; &gt; 1);
&gt; &gt; &gt; +  assert(EVP_CipherInit_ex(ctx-&gt;evp, cipher, NULL, key, NULL, 1) ==
&gt; &gt; 1);
&gt; &gt; &gt; EVP_CIPHER_CTX_set_padding(ctx-&gt;evp, 0);
&gt; &gt; &gt; }
&gt; &gt; 
&gt; &gt; It's not right to use assert on expressions with side-effects. Since
&gt; &gt; will
&gt; &gt; break builds with ./configure CFLAGS='-DNDEBUG'. 
&gt; &gt; 
&gt; &gt; One would need to either assign return value to a variable and assert
&gt; &gt; on
&gt; &gt; that, or define some alternative assert-like makro which always
&gt; &gt; evaluates its argument.
&gt; &gt; 
&gt; &gt; Not a big problem if only in the benchmark code, but it should be
&gt; &gt; avoided. It was introduced earlier, in commit
&gt; &gt; https://git.lysator.liu.se/nettle/nettle/commit/5c78bb737c553f2064271f1a7c4768b88a09b665,
&gt; &gt;  but I didn't notice at the time.
&gt; 
&gt; An alternative fix for that could be to introduce a check in a header which will \
&gt; fail compilation if ndebug is used.

That alternative is worse than the actual bug. Which was context members
not being initialized for -DNDEBUG builds.

Forcing all builds to avoid NDEBUG (ie asserts in production) is where
the issues Jeffrey mentioned start to have relevance to other parts of
the library dealing with PII.

AYJ


</body></email><email><emailId>20180217124636</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2018-02-17 12:46:36-0400</timestampReceived><subject>Re: [PATCH 1/2] Provide wrappers around OpenSSL AES GCM</subject><body>

On Sat, Feb 17, 2018 at 7:36 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt; Jeffrey Walton &lt;noloader@gmail.com&gt; writes:
&gt;
&gt;&gt; But production is a different story.... The time for debugging is over..=
.
&gt;
&gt; I would generally assume that there are a few bugs left in also the
&gt; production code. And I think that in most cases, the bug manifesting
&gt; itself as an assertion failure is a lot better then the alternatives.
&gt;
&gt; I know there are different opinions. We should support -DNDEBUG builds,
&gt; but it's not going to be the default in Nettle.

Yes, please do support NDEBUG. I build all my software with it because
I don't want to lose the sensitive information.

It is easy enough to audit. Everywhere there is an assert() to assert
a condition, then there should be an if() statement with the same test
that returns failure. It is OK to avoid processing if you don't like
the condition.

Postel's law is dangerous nowadays. The threat landscape has changed.
Look for any reason you can to fail processing. If you can't find a
reason, then begrudgingly process the data.

I found using the anit-Postel law made my software incredibly stable.
It was nearly impossible to make it fail or crash.

Jeff

</body></email><email><emailId>20180207121332</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-07 12:13:32-0400</timestampReceived><subject>Re: Miscomputation with big-endian arm asm</subject><body>

Michael Weiser &lt;michael@weiser.dinsnail.net&gt; writes:

&gt;&gt; What board and linux (dist?) are you running this on?
&gt;
&gt; I have a number of Cubieboard2s that run Gentoo Linux with a vanilla,
&gt; mainline Linus kernel.
&gt;
&gt; # uname -a
&gt; Linux b 4.15.0-gentoo #2 SMP Sun Feb 4 18:46:30 CET 2018 armv7b
&gt; ARMv7 Processor rev 4 (v7b) Allwinner sun7i (A20) Family GNU/Linux
&gt;
&gt; The only difference between little- and big-endian boards is the
&gt; following Linux kernel config options:
&gt;
&gt; -# CONFIG_CPU_BIG_ENDIAN is not set
&gt; +CONFIG_CPU_BIG_ENDIAN=y
&gt; +CONFIG_CPU_ENDIAN_BE8=y
&gt;
&gt; This makes the kernel switch the CPU to big-endian mode on boot.
&gt; Userland is big-endian as well.

Cool. 

&gt;&gt; What's the host triplet?
&gt;
&gt; armv7veb-hardfloat-linux-gnueabi
        ^^

And the "eb" is for big-endian?

&gt;&gt;  Are you cross compiling, or compiling natively?
&gt;
&gt; It's all native on the board. I have a cross-toolchain and qemu on
&gt; standby on x86_64 if necessary.
&gt;
&gt;&gt; Does configure detect it as big-endian (check for WORDS_BIGENDIAN in config.h)?
&gt;
&gt; It seems so:
&gt;
&gt; nettle-3.4 # grep WORDS_BIG config.h
&gt; /* Define WORDS_BIGENDIAN to 1 if your processor stores words with the
&gt; most
&gt; #  define WORDS_BIGENDIAN 1
&gt; # ifndef WORDS_BIGENDIAN
&gt; #  define WORDS_BIGENDIAN 1

Can you check if it's detected correctly also when cross-compiling?

&gt;&gt; Which of nettle's own tests (make check) fail?
&gt;
&gt; With --disable-assembler all checks pass. Here's the make check output
&gt; with arm asm:

&gt; FAIL: chacha

The chacha code doesn't look endian-dependent to me. I'd guess it's a
consequence of incorrect memxor (below).

&gt; FAIL: memxor

This also does some tricks with word reads and rotate. (The C code does
that too, but with conditions on WORDS_BIGENDIAN).

&gt; FAIL: hkdf

Probably due to broken sha1 or sha256.

&gt; FAIL: sha1

This one you have already looked into.

&gt; FAIL: sha256

Similar problems.

&gt; FAIL: umac

Similar problem, I would guess. But this time, loading 64 bits at a time
into neon registers.

The remaining failures are most likely not independent issues.

&gt; Yes, the masking and shifting needs some adjustment, too. I got
&gt; sha1-test to succeed with below patch. What do you think: Could we go
&gt; some route like that for the other arm asm code as well?

Sounds reasonable, I'm happy to apply patches. If you feel like,
v6/aes-*.asm could also use better code for aligned reading of input
data. 

&gt; I'd be willing to throw in aarch64 as well because I've got some
&gt; Pine64s running BE floating around also. :)

Aarch64 assembly (for both endian flavors) would be nice, but it's a
separate project. I haven't yet looked into aarch64-assembly. I made an
attempt to build nettle under termux on my android phone a while ago,
but it failed because it didn't provide /bin/sh at the expected place.

&gt;&gt; Before attempting to support big-endian arm, I'd need some idea on how
&gt;&gt; to test it.
&gt;
&gt; Any halfway current ARM cross toolchain should be able to also output
&gt; big-endian arm binaries (-mbig-endian). Then you could test those with
&gt; qemu-user-armeb, which is very light-weight in that it doesn't need a
&gt; kernel or emulated system and allows to run binaries directly.

Sounds good. I hope the needed tools are packaged in debian, I'll have
to check that.

&gt; From f876368b333c72878808e74a0af5aa631d42d357 Mon Sep 17 00:00:00 2001
&gt; From: Michael Weiser &lt;michael.weiser@gmx.de&gt;
&gt; Date: Wed, 7 Feb 2018 00:11:24 +0100
&gt; Subject: [PATCH] Support big-endian arm in sha1 armv6 assembly code
&gt;
&gt; ---
&gt;  arm/v6/sha1-compress.asm | 10 ++++++++++
&gt;  asm.m4                   | 10 ++++++++++
&gt;  config.m4.in             |  1 +
&gt;  configure.ac             |  2 ++
&gt;  4 files changed, 23 insertions(+)
&gt;
&gt; diff --git a/arm/v6/sha1-compress.asm b/arm/v6/sha1-compress.asm
&gt; index 59d6297e..116a80f0 100644
&gt; --- a/arm/v6/sha1-compress.asm
&gt; +++ b/arm/v6/sha1-compress.asm
&gt; @@ -52,7 +52,9 @@ define(&lt;LOAD&gt;, &lt;
&gt;  	sel	W, WPREV, T0
&gt;  	ror	W, W, SHIFT
&gt;  	mov	WPREV, T0
&gt; +NOT_IF_BE(&lt;
&gt;  	rev	W, W
&gt; +&gt;)

I'd prefer IF_LE or IF_NOT_BE or UNLESS_BE over NOT_IF_BE. And it might
look better as a single line,

IF_LE(&lt;	rev	W, W&gt;)

&gt; +IF_BE(&lt;
&gt; +	neg     SHIFT, SHIFT		C Rotate right by 32-SHIFT bits
&gt; +	add     SHIFT, SHIFT, #32	C because there's no rotate left
&gt; +&gt;, &lt;&gt;)

Can the rsb instruction be used for this?

&gt; +define(&lt;IF_BE&gt;,
&gt; +&lt;ifelse(WORDS_BIGENDIAN,yes,
&gt; +&lt;$1&gt;,
&gt; +&lt;$2&gt;)&gt;)

Would be good to check explicitly for the supported values "yes" and
"no" (m4 ifelse can have more than two alternatives), and fail with
m4exit if configure produced any other value, e.g., "unknown".

&gt; +define(&lt;NOT_IF_BE&gt;,
&gt; +&lt;ifelse(WORDS_BIGENDIAN,no,
&gt; +&lt;$1&gt;,
&gt; +&lt;&gt;)&gt;)

As above, I'm not so fond of the name. And for symmetry, it would be
nice with an else clause just as for IF_BE.

&gt; --- a/configure.ac
&gt; +++ b/configure.ac
&gt; @@ -691,6 +691,7 @@ ASM_TYPE_FUNCTION='@function'
&gt;  ASM_TYPE_PROGBITS='@progbits'
&gt;  ASM_MARK_NOEXEC_STACK=''
&gt;  ASM_ALIGN_LOG=''
&gt; +ASM_WORDS_BIGENDIAN="$ac_cv_c_bigendian"

If you have the time, it would be good to file an autoconf bug report,
asking them to document (and support) that AC_C_BIGENDIAN sets the shell
variable ac_cv_c_bigendian.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180208071529</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-02-08 07:15:29-0400</timestampReceived><subject>Re: Miscomputation with big-endian arm asm</subject><body>

On Wed, 2018-02-07 at 13:13 +0100, Niels Möller wrote:
&gt; 
&gt; &gt; I'd be willing to throw in aarch64 as well because I've got some
&gt; &gt; Pine64s running BE floating around also. :)
&gt; 
&gt; Aarch64 assembly (for both endian flavors) would be nice, but it's a
&gt; separate project. I haven't yet looked into aarch64-assembly. I made
&gt; an
&gt; attempt to build nettle under termux on my android phone a while ago,
&gt; but it failed because it didn't provide /bin/sh at the expected
&gt; place.

If you need access to the aarch64 CI server, let me know.

regards,
Nikos


</body></email><email><emailId>20180210222610</emailId><senderName>Michael Weiser</senderName><senderEmail>michael@weiser.dinsnail.net</senderEmail><timestampReceived>2018-02-10 22:26:10-0400</timestampReceived><subject>Re: Miscomputation with big-endian arm asm</subject><body>

Hi Niels,

On Wed, Feb 07, 2018 at 01:13:32PM +0100, Niels Möller wrote:

&gt; &gt; &gt; What's the host triplet?
&gt; &gt; 
&gt; &gt; armv7veb-hardfloat-linux-gnueabi
&gt; ^^

&gt; And the "eb" is for big-endian?

Only the b actually. ve stands for virtualization extensions:
http://gcc.gnu.org/ml/gcc-patches/2013-12/msg01783.html.
But that's just my fancy. More common triples would most likely use
armv7b or armv7eb and the above should perhaps have been armv7veeb. :)

&gt; &gt; #  define WORDS_BIGENDIAN 1
&gt; Can you check if it's detected correctly also when cross-compiling?

# ./configure --host=armv7veb-hardfloat-linux-gnueabi
checking build system type... x86_64-unknown-linux-gnu
checking host system type... armv7veb-hardfloat-linux-gnueabi
[...]
configure: summary of build options:

  Version:           nettle 3.4
  Host type:         armv7veb-hardfloat-linux-gnueabi
  ABI:               standard
  Assembly files:    arm/v6 arm
  Install prefix:    /usr/local
  Library directory: ${exec_prefix}/lib
  Compiler:          armv7veb-hardfloat-linux-gnueabi-gcc
  Static libraries:  yes
  Shared libraries:  yes
  Public key crypto: no
  Using mini-gmp:    no
  Documentation:     yes

# grep WORDS_BIG config.h
/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
#  define WORDS_BIGENDIAN 1
# ifndef WORDS_BIGENDIAN
#  define WORDS_BIGENDIAN 1

Seems fine.

&gt; &gt; FAIL: memxor
&gt; This also does some tricks with word reads and rotate. (The C code does
&gt; that too, but with conditions on WORDS_BIGENDIAN).

I think I got memxor, sha1 and sha256 sorted. Patch below.

&gt; &gt; FAIL: chacha
&gt; The chacha code doesn't look endian-dependent to me. I'd guess it's a
&gt; consequence of incorrect memxor (below).

This one is still failing, even though memxor and sha are fixed. I've
been looking at the code and can't find any apparent reason. In
chacha-core-internal.c I see the following bit of code that does seem to
do endianness handling:

      dst[i] = LE_SWAP32 (t);

Would this apply to chacha-core-internal.asm, too?

&gt; &gt; FAIL: umac
&gt; Similar problem, I would guess. But this time, loading 64 bits at a time
&gt; into neon registers.

I'm drawing a bit of a blank on this one. It fails on the very first
test case of umac32 where only umac-nh is used and all the input is
zeroes. So there does seem to be another endianness dependency in the
actual computation code. Have I understood correctly, that vld1.8 reads
a byte stream and should be endianness-neutral anyway and the keys are
in host endianness?

&gt; If you feel like,
&gt; v6/aes-*.asm could also use better code for aligned reading of input
&gt; data. 

Huh, getting existing code to work again is one thing. But actual better
code is certainly beyond me. :-/

&gt; Aarch64 assembly (for both endian flavors) would be nice, but it's a
&gt; separate project. I haven't yet looked into aarch64-assembly. I made an
&gt; attempt to build nettle under termux on my android phone a while ago,
&gt; but it failed because it didn't provide /bin/sh at the expected place.

Sorry, I think I had confused nettle with an other library I came across
during debugging which had armv8 code. Again, I think I should leave
producing actually working and efficient assembler code to someone who
knows what they're doing. :)

&gt; &gt; &gt; Before attempting to support big-endian arm, I'd need some idea on how
&gt; &gt; &gt; to test it.
&gt; &gt; 
&gt; &gt; Any halfway current ARM cross toolchain should be able to also output
&gt; &gt; big-endian arm binaries (-mbig-endian). Then you could test those with
&gt; &gt; qemu-user-armeb, which is very light-weight in that it doesn't need a
&gt; &gt; kernel or emulated system and allows to run binaries directly.
&gt; Sounds good. I hope the needed tools are packaged in debian, I'll have
&gt; to check that.

I was wrong: While the compiler is able to output big-endian objects
with -mbig-endian, it needs matching libs as well (e.g. libgcc_s).
Debian doesn't have anything precompiled for armeb. They refer you to
Linaro's toolchains or rebootstrap for building from scratch instead (I do
something similar with crossdev on Gentoo).

This Linaro toolchain works for me:
https://releases.linaro.org/components/toolchain/binaries/latest/armeb-linux-gnueabihf/gcc-linaro-7.2.1-2017.11-x86_64_armeb-linux-gnueabihf.tar.xz


michael@debian:~/nettle$ \
PATH=$HOME/gcc-linaro-7.2.1-2017.11-x86_64_armeb-linux-gnueabihf/bin:$PATH \
./configure --host=armeb-linux-gnueabihf michael@debian:~/nettle$ make
[...]
michael@debian:~/nettle$ file libnettle.so
libnettle.so: ELF 32-bit MSB shared object, ARM, EABI5 BE8 version 1
(SYSV), dynamically linked,
BuildID[sha1]=1a8daa9c1d3e61b9d99d34f462337d02c47c9d74, with debug_info,
not stripped
michael@debian:~/nettle$ make testsuite/sha1-test

Now qemu can be installed, which automatically registers with binfmt so
that arm binaries can just be executed:

michael@debian:~/nettle$ sudo apt-get install qemu-user-static
michael@debian:~/nettle$ file testsuite/sha1-test
testsuite/sha1-test: ELF 32-bit MSB executable, ARM, EABI5 BE8 version 1
(SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for
GNU/Linux 3.2.0, BuildID[sha1]=ec39b7153f4c09d11cac92d34c8e509bb1f4d0a0,
with debug_info, not stripped
michael@debian:~/nettle$ testsuite/sha1-test
/lib/ld-linux-armhf.so.3: No such file or directory
michael@debian:~/nettle$ \
QEMU_LD_PREFIX=$HOME/gcc-linaro-7.2.1-2017.11-x86_64_armeb-linux-gnueabihf/armeb-linux-gnueabihf/libc \
                testsuite/sha1-test
qemu: uncaught target signal 11 (Segmentation fault) - core dumped
Segmentation fault

This segfaults because of a bug in qemu where it tries to use the host's
/etc/ld.so.cache. Deleting it "solves" that. Alternatively, it could be
run in a chroot to avoid the segfault but would require some fiddling
with the compiler's sysroot.

michael@debian:~/nettle$ sudo rm /etc/ld.so.cache 
michael@debian:~/nettle$ \
QEMU_LD_PREFIX=$HOME/gcc-linaro-7.2.1-2017.11-x86_64_armeb-linux-gnueabihf/armeb-linux-gnueabihf/libc \
                testsuite/sha1-test
testsuite/sha1-test: error while loading shared libraries: libnettle.so.6: cannot \
open shared object file: No such file or directory michael@debian:~/nettle$ ln -sfn \
libnettle.so libnettle.so.6 michael@debian:~/nettle$ \
QEMU_LD_PREFIX=$HOME/gcc-linaro-7.2.1-2017.11-x86_64_armeb-linux-gnueabihf/armeb-linux-gnueabihf/libc \
LD_LIBRARY_PATH=. testsuite/sha1-test

This worked because configure detected only generic arm support:

  Assembly files:    arm

So plain arm assembly seems to be BE-safe. :)
After hacking configure to also enable arm/v6 with this triple I get:

michael@debian:~/nettle$ \
QEMU_LD_PREFIX=$HOME/gcc-linaro-7.2.1-2017.11-x86_64_armeb-linux-gnueabihf/armeb-linux-gnueabihf/libc \
LD_LIBRARY_PATH=. testsuite/sha1-test

Got:

9844f81e1408f6ec b932137d33bed7cf
dcf518a3

Expected:

da39a3ee5e6b4b0d 3255bfef95601890
afd80709
qemu: uncaught target signal 6 (Aborted) - core dumped
Aborted

Which seems about right. With the patch that goes away:

michael@debian:~/nettle$ git am \
                0001-Support-big-endian-arm-in-sha1-armv6-assembly-code.patch 
Applying: Support big-endian arm in sha1 armv6 assembly code
[make &amp;&amp; make check]
michael@debian:~/nettle$ \
QEMU_LD_PREFIX=$HOME/gcc-linaro-7.2.1-2017.11-x86_64_armeb-linux-gnueabihf/armeb-linux-gnueabihf/libc \
LD_LIBRARY_PATH=. testsuite/sha1-test michael@debian:~/nettle$

I also tried rebootstrap but this quickly got really involved.

&gt; &gt; --- a/configure.ac
&gt; &gt; +++ b/configure.ac
&gt; &gt; @@ -691,6 +691,7 @@ ASM_TYPE_FUNCTION='@function'
&gt; &gt; ASM_TYPE_PROGBITS='@progbits'
&gt; &gt; ASM_MARK_NOEXEC_STACK=''
&gt; &gt; ASM_ALIGN_LOG=''
&gt; &gt; +ASM_WORDS_BIGENDIAN="$ac_cv_c_bigendian"
&gt; If you have the time, it would be good to file an autoconf bug report,
&gt; asking them to document (and support) that AC_C_BIGENDIAN sets the shell
&gt; variable ac_cv_c_bigendian.

Instead I augmented the default action (which is documented and
shouldn't change) by setting ASM_WORDS_BIGENDIAN directly. Also this
should make the explicit value checking in IF_BE redundant because we
now know for sure configure will never emit anything other than yes and
no. Documentation says that AC_C_BIGENDIAN will abort if endianness
can't be determined.

&gt; From db70ecccdc65a97c103f3900b4f45d8370c1dd62 Mon Sep 17 00:00:00 2001
From: Michael Weiser &lt;michael.weiser@gmx.de&gt;
Date: Wed, 7 Feb 2018 00:11:24 +0100
Subject: [PATCH] Support big-endian arm in assembly code

Introduce m4 macros to conditionally handle differences of little- and
big-endian arm in assembler code. Adjust sha1-compress, sha256-compress
and memxor for arm to work in big-endian mode.
---
 arm/memxor.asm             | 21 +++++++++++++++-----
 arm/memxor3.asm            | 49 ++++++++++++++++++++++++++++++----------------
 arm/v6/sha1-compress.asm   |  8 ++++++--
 arm/v6/sha256-compress.asm | 14 ++++++++-----
 asm.m4                     |  3 +++
 config.m4.in               |  1 +
 configure.ac               |  5 ++++-
 7 files changed, 71 insertions(+), 30 deletions(-)

diff --git a/arm/memxor.asm b/arm/memxor.asm
index a50e91bc..239a4034 100644
--- a/arm/memxor.asm
+++ b/arm/memxor.asm
@@ -44,6 +44,11 @@ define(&lt;N&gt;, &lt;r2&gt;)
 define(&lt;CNT&gt;, &lt;r6&gt;)
 define(&lt;TNC&gt;, &lt;r12&gt;)
 
+C little-endian and big-endian need to shift in different directions for
+C alignment correction
+define(&lt;S0ADJ&gt;, IF_LE(&lt;lsr&gt;, &lt;lsl&gt;))
+define(&lt;S1ADJ&gt;, IF_LE(&lt;lsl&gt;, &lt;lsr&gt;))
+
 	.syntax unified
 
 	.file "memxor.asm"
@@ -99,6 +104,8 @@ PROLOGUE(nettle_memxor)
 	C
 	C With little-endian, we need to do
 	C DST[i] ^= (SRC[i] &gt;&gt; CNT) ^ (SRC[i+1] &lt;&lt; TNC)
+	C With big-endian, we need to do
+	C DST[i] ^= (SRC[i] &lt;&lt; CNT) ^ (SRC[i+1] &gt;&gt; TNC)
 
 	push	{r4,r5,r6}
 	
@@ -117,14 +124,14 @@ PROLOGUE(nettle_memxor)
 .Lmemxor_word_loop:
 	ldr	r5, [SRC], #+4
 	ldr	r3, [DST]
-	eor	r3, r3, r4, lsr CNT
-	eor	r3, r3, r5, lsl TNC
+	eor	r3, r3, r4, S0ADJ CNT
+	eor	r3, r3, r5, S1ADJ TNC
 	str	r3, [DST], #+4
 .Lmemxor_odd:
 	ldr	r4, [SRC], #+4
 	ldr	r3, [DST]
-	eor	r3, r3, r5, lsr CNT
-	eor	r3, r3, r4, lsl TNC
+	eor	r3, r3, r5, S0ADJ CNT
+	eor	r3, r3, r4, S1ADJ TNC
 	str	r3, [DST], #+4
 	subs	N, #8
 	bcs	.Lmemxor_word_loop
@@ -132,10 +139,14 @@ PROLOGUE(nettle_memxor)
 	beq	.Lmemxor_odd_done
 
 	C We have TNC/8 left-over bytes in r4, high end
-	lsr	r4, CNT
+	S0ADJ	r4, CNT
 	ldr	r3, [DST]
 	eor	r3, r4
 
+	C memxor_leftover does an LSB store
+	C so we need to reverse if actually BE
+IF_BE(&lt;	rev	r3, r3&gt;)
+
 	pop	{r4,r5,r6}
 
 	C Store bytes, one by one.
diff --git a/arm/memxor3.asm b/arm/memxor3.asm
index 139fd208..69598e1c 100644
--- a/arm/memxor3.asm
+++ b/arm/memxor3.asm
@@ -49,6 +49,11 @@ define(&lt;ATNC&gt;, &lt;r10&gt;)
 define(&lt;BCNT&gt;, &lt;r11&gt;)
 define(&lt;BTNC&gt;, &lt;r12&gt;)
 
+C little-endian and big-endian need to shift in different directions for
+C alignment correction
+define(&lt;S0ADJ&gt;, IF_LE(&lt;lsr&gt;, &lt;lsl&gt;))
+define(&lt;S1ADJ&gt;, IF_LE(&lt;lsl&gt;, &lt;lsr&gt;))
+
 	.syntax unified
 
 	.file "memxor3.asm"
@@ -124,6 +129,8 @@ PROLOGUE(nettle_memxor3)
 	C
 	C With little-endian, we need to do
 	C DST[i-i] ^= (SRC[i-i] &gt;&gt; CNT) ^ (SRC[i] &lt;&lt; TNC)
+	C With big-endian, we need to do
+	C DST[i-i] ^= (SRC[i-i] &lt;&lt; CNT) ^ (SRC[i] &gt;&gt; TNC)
 	rsb	ATNC, ACNT, #32
 	bic	BP, #3
 
@@ -138,14 +145,14 @@ PROLOGUE(nettle_memxor3)
 .Lmemxor3_au_loop:
 	ldr	r5, [BP, #-4]!
 	ldr	r6, [AP, #-4]!
-	eor	r6, r6, r4, lsl ATNC
-	eor	r6, r6, r5, lsr ACNT
+	eor	r6, r6, r4, S1ADJ ATNC
+	eor	r6, r6, r5, S0ADJ ACNT
 	str	r6, [DST, #-4]!
 .Lmemxor3_au_odd:
 	ldr	r4, [BP, #-4]!
 	ldr	r6, [AP, #-4]!
-	eor	r6, r6, r5, lsl ATNC
-	eor	r6, r6, r4, lsr ACNT
+	eor	r6, r6, r5, S1ADJ ATNC
+	eor	r6, r6, r4, S0ADJ ACNT
 	str	r6, [DST, #-4]!
 	subs	N, #8
 	bcs	.Lmemxor3_au_loop
@@ -154,7 +161,11 @@ PROLOGUE(nettle_memxor3)
 
 	C Leftover bytes in r4, low end
 	ldr	r5, [AP, #-4]
-	eor	r4, r5, r4, lsl ATNC
+	eor	r4, r5, r4, S1ADJ ATNC
+
+	C leftover does an LSB store
+	C so we need to reverse if actually BE
+IF_BE(&lt;	rev	r4, r4&gt;)
 
 .Lmemxor3_au_leftover:
 	C Store a byte at a time
@@ -247,21 +258,25 @@ PROLOGUE(nettle_memxor3)
 	ldr	r5, [AP, #-4]!
 	ldr	r6, [BP, #-4]!
 	eor	r5, r6
-	lsl	r4, ATNC
-	eor	r4, r4, r5, lsr ACNT
+	S1ADJ	r4, ATNC
+	eor	r4, r4, r5, S0ADJ ACNT
 	str	r4, [DST, #-4]!
 .Lmemxor3_uu_odd:
 	ldr	r4, [AP, #-4]!
 	ldr	r6, [BP, #-4]!
 	eor	r4, r6
-	lsl	r5, ATNC
-	eor	r5, r5, r4, lsr ACNT
+	S1ADJ	r5, ATNC
+	eor	r5, r5, r4, S0ADJ ACNT
 	str	r5, [DST, #-4]!
 	subs	N, #8
 	bcs	.Lmemxor3_uu_loop
 	adds	N, #8
 	beq	.Lmemxor3_done
 
+	C leftover does an LSB store
+	C so we need to reverse if actually BE
+IF_BE(&lt;	rev	r4, r4&gt;)
+
 	C Leftover bytes in a4, low end
 	ror	r4, ACNT
 .Lmemxor3_uu_leftover:
@@ -290,18 +305,18 @@ PROLOGUE(nettle_memxor3)
 .Lmemxor3_uud_loop:
 	ldr	r5, [AP, #-4]!
 	ldr	r7, [BP, #-4]!
-	lsl	r4, ATNC
-	eor	r4, r4, r6, lsl BTNC
-	eor	r4, r4, r5, lsr ACNT
-	eor	r4, r4, r7, lsr BCNT
+	S1ADJ	r4, ATNC
+	eor	r4, r4, r6, S1ADJ BTNC
+	eor	r4, r4, r5, S0ADJ ACNT
+	eor	r4, r4, r7, S0ADJ BCNT
 	str	r4, [DST, #-4]!
 .Lmemxor3_uud_odd:
 	ldr	r4, [AP, #-4]!
 	ldr	r6, [BP, #-4]!
-	lsl	r5, ATNC
-	eor	r5, r5, r7, lsl BTNC
-	eor	r5, r5, r4, lsr ACNT
-	eor	r5, r5, r6, lsr BCNT
+	S1ADJ	r5, ATNC
+	eor	r5, r5, r7, S1ADJ BTNC
+	eor	r5, r5, r4, S0ADJ ACNT
+	eor	r5, r5, r6, S0ADJ BCNT
 	str	r5, [DST, #-4]!
 	subs	N, #8
 	bcs	.Lmemxor3_uud_loop
diff --git a/arm/v6/sha1-compress.asm b/arm/v6/sha1-compress.asm
index 59d6297e..52739b69 100644
--- a/arm/v6/sha1-compress.asm
+++ b/arm/v6/sha1-compress.asm
@@ -52,7 +52,7 @@ define(&lt;LOAD&gt;, &lt;
 	sel	W, WPREV, T0
 	ror	W, W, SHIFT
 	mov	WPREV, T0
-	rev	W, W
+IF_LE(&lt; rev	W, W&gt;)
 	str	W, [SP,#eval(4*$1)]
 &gt;)
 define(&lt;EXPN&gt;, &lt;
@@ -127,8 +127,12 @@ PROLOGUE(_nettle_sha1_compress)
 	lsl	SHIFT, SHIFT, #3
 	mov	T0, #0
 	movne	T0, #-1
-	lsl	W, T0, SHIFT
+IF_LE(&lt;	lsl	W, T0, SHIFT&gt;)
+IF_BE(&lt;	lsr	W, T0, SHIFT&gt;)
 	uadd8	T0, T0, W		C Sets APSR.GE bits
+	C on BE rotate right by 32-SHIFT bits
+	C because there is no rotate left
+IF_BE(&lt;	rsb     SHIFT, SHIFT, #32&gt;)
 	
 	ldr	K, .LK1
 	ldm	STATE, {SA,SB,SC,SD,SE}
diff --git a/arm/v6/sha256-compress.asm b/arm/v6/sha256-compress.asm
index e6f4e1e9..324730c7 100644
--- a/arm/v6/sha256-compress.asm
+++ b/arm/v6/sha256-compress.asm
@@ -137,8 +137,12 @@ PROLOGUE(_nettle_sha256_compress)
 	lsl	SHIFT, SHIFT, #3
 	mov	T0, #0
 	movne	T0, #-1
-	lsl	I1, T0, SHIFT
+IF_LE(&lt;	lsl	I1, T0, SHIFT&gt;)
+IF_BE(&lt;	lsr	I1, T0, SHIFT&gt;)
 	uadd8	T0, T0, I1		C Sets APSR.GE bits
+	C on BE rotate right by 32-SHIFT bits
+	C because there is no rotate left
+IF_BE(&lt;	rsb	SHIFT, SHIFT, #32&gt;)
 
 	mov	DST, sp
 	mov	ILEFT, #4
@@ -146,16 +150,16 @@ PROLOGUE(_nettle_sha256_compress)
 	ldm	INPUT!, {I1,I2,I3,I4}
 	sel	I0, I0, I1
 	ror	I0, I0, SHIFT
-	rev	I0, I0
+IF_LE(&lt;	rev	I0, I0&gt;)
 	sel	I1, I1, I2
 	ror	I1, I1, SHIFT
-	rev	I1, I1
+IF_LE(&lt;	rev	I1, I1&gt;)
 	sel	I2, I2, I3
 	ror	I2, I2, SHIFT
-	rev	I2, I2
+IF_LE(&lt;	rev	I2, I2&gt;)
 	sel	I3, I3, I4
 	ror	I3, I3, SHIFT
-	rev	I3, I3
+IF_LE(&lt;	rev	I3, I3&gt;)
 	subs	ILEFT, ILEFT, #1
 	stm	DST!, {I0,I1,I2,I3}
 	mov	I0, I4	
diff --git a/asm.m4 b/asm.m4
index 4018c235..343a55fc 100644
--- a/asm.m4
+++ b/asm.m4
@@ -51,6 +51,9 @@ define(&lt;ALIGN&gt;,
 &lt;.align ifelse(ALIGN_LOG,yes,&lt;m4_log2($1)&gt;,$1)
 &gt;)
 
+define(&lt;IF_BE&gt;, &lt;ifelse(WORDS_BIGENDIAN,yes,&lt;$1&gt;,&lt;$2&gt;)&gt;)
+define(&lt;IF_LE&gt;, &lt;IF_BE(&lt;$2&gt;, &lt;$1&gt;)&gt;)
+
 dnl Struct defining macros
 
 dnl STRUCTURE(prefix) 
diff --git a/config.m4.in b/config.m4.in
index e39c880c..11f90a40 100644
--- a/config.m4.in
+++ b/config.m4.in
@@ -7,6 +7,7 @@ define(&lt;TYPE_PROGBITS&gt;, &lt;@ASM_TYPE_PROGBITS@&gt;)dnl
 define(&lt;ALIGN_LOG&gt;, &lt;@ASM_ALIGN_LOG@&gt;)dnl
 define(&lt;W64_ABI&gt;, &lt;@W64_ABI@&gt;)dnl
 define(&lt;RODATA&gt;, &lt;@ASM_RODATA@&gt;)dnl
+define(&lt;WORDS_BIGENDIAN&gt;, &lt;@ASM_WORDS_BIGENDIAN@&gt;)dnl
 divert(1)
 @ASM_MARK_NOEXEC_STACK@
 divert
diff --git a/configure.ac b/configure.ac
index 41bf0998..21eba3b5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -201,7 +201,9 @@ LSH_FUNC_STRERROR
 # getenv_secure is used for fat overrides,
 # getline is used in the testsuite
 AC_CHECK_FUNCS(secure_getenv getline)
-AC_C_BIGENDIAN
+AC_C_BIGENDIAN([AC_DEFINE([WORDS_BIGENDIAN], 1)
+	[ASM_WORDS_BIGENDIAN=yes]],
+	[ASM_WORDS_BIGENDIAN=no])
 
 AC_CACHE_CHECK([for __builtin_bswap64],
 		nettle_cv_c_builtin_bswap64,
@@ -811,6 +813,7 @@ AC_SUBST(ASM_TYPE_PROGBITS)
 AC_SUBST(ASM_MARK_NOEXEC_STACK)
 AC_SUBST(ASM_ALIGN_LOG)
 AC_SUBST(W64_ABI)
+AC_SUBST(ASM_WORDS_BIGENDIAN)
 AC_SUBST(EMULATOR)
 
 AC_SUBST(LIBNETTLE_MAJOR)
-- 
2.16.1

-- 
bye, Micha


</body></email><email><emailId>20180211100341</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-11 10:03:41-0400</timestampReceived><subject>Re: Miscomputation with big-endian arm asm</subject><body>

Michael Weiser &lt;michael@weiser.dinsnail.net&gt; writes:

&gt; Hi Niels,
&gt;
&gt; On Wed, Feb 07, 2018 at 01:13:32PM +0100, Niels Möller wrote:
&gt;
&gt;&gt; Can you check if it's detected correctly also when cross-compiling?
&gt; [...]
&gt; Seems fine.

Good!

&gt;&gt; &gt; FAIL: memxor
&gt;&gt; This also does some tricks with word reads and rotate. (The C code does
&gt;&gt; that too, but with conditions on WORDS_BIGENDIAN).
&gt;
&gt; I think I got memxor, sha1 and sha256 sorted. Patch below.

Nice. Only some quick comments for now.

&gt; This one is still failing, even though memxor and sha are fixed. I've
&gt; been looking at the code and can't find any apparent reason. In
&gt; chacha-core-internal.c I see the following bit of code that does seem to
&gt; do endianness handling:
&gt;
&gt;       dst[i] = LE_SWAP32 (t);
&gt;
&gt; Would this apply to chacha-core-internal.asm, too?

That's right, it is expected to produce the output as an array of 16
32-bit words, stored in *little* endian order. So byteswap is needed
before the final 

	vstm	DST, {X0,X1,X2,X3}

instruction. The idea is that the buffer can be used directly with
memxor, without the C code having to do any byte swaps.

&gt;&gt; &gt; FAIL: umac
&gt;&gt; Similar problem, I would guess. But this time, loading 64 bits at a time
&gt;&gt; into neon registers.
&gt;
&gt; I'm drawing a bit of a blank on this one. It fails on the very first
&gt; test case of umac32 where only umac-nh is used and all the input is
&gt; zeroes. So there does seem to be another endianness dependency in the
&gt; actual computation code.

It could be that if the all-zero input is misaligned, the aligned read +
rotation tricks gets non-zero data from outside of the input area into
the computation.

&gt; Have I understood correctly, that vld1.8 reads a byte stream and
&gt; should be endianness-neutral

Don't remember, have to consult the arm docs.

&gt; and the keys are in host endianness?

I think so.

&gt; I was wrong: While the compiler is able to output big-endian objects
&gt; with -mbig-endian, it needs matching libs as well (e.g. libgcc_s).
&gt; Debian doesn't have anything precompiled for armeb.

Maybe full-system qemu is easier then (assuming there's some dist
supporting big-endian arm)?

&gt; Instead I augmented the default action (which is documented and
&gt; shouldn't change) by setting ASM_WORDS_BIGENDIAN directly. Also this
&gt; should make the explicit value checking in IF_BE redundant because we
&gt; now know for sure configure will never emit anything other than yes and
&gt; no. Documentation says that AC_C_BIGENDIAN will abort if endianness
&gt; can't be determined.

[...]

&gt; --- a/configure.ac
&gt; +++ b/configure.ac
&gt; @@ -201,7 +201,9 @@ LSH_FUNC_STRERROR
&gt;  # getenv_secure is used for fat overrides,
&gt;  # getline is used in the testsuite
&gt;  AC_CHECK_FUNCS(secure_getenv getline)
&gt; -AC_C_BIGENDIAN
&gt; +AC_C_BIGENDIAN([AC_DEFINE([WORDS_BIGENDIAN], 1)
&gt; +	[ASM_WORDS_BIGENDIAN=yes]],
&gt; +	[ASM_WORDS_BIGENDIAN=no])

I think I'd indent differently, to group the two parts ACTION-IF-TRUE
together, and drop the redundant square brackets in
"[ASM_WORDS_BIGENDIAN=yes]".

You leave the ACTION-IS-UNIVERSAL as default, which I think is good. I
hope that's not relevant for arm. Might still be good to set
ASM_WORDS_BIGENDIAN to some default value before this check, and have
IF_BE fail if used with an unknown endianness.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180211223728</emailId><senderName>Michael Weiser</senderName><senderEmail>michael@weiser.dinsnail.net</senderEmail><timestampReceived>2018-02-11 22:37:28-0400</timestampReceived><subject>Re: Miscomputation with big-endian arm asm</subject><body>

Hello Niels,

On Sun, Feb 11, 2018 at 11:03:41AM +0100, Niels Möller wrote:

&gt; &gt;       dst[i] = LE_SWAP32 (t);
&gt; &gt; Would this apply to chacha-core-internal.asm, too?
&gt; That's right, it is expected to produce the output as an array of 16
&gt; 32-bit words, stored in *little* endian order. So byteswap is needed

Right. When this still didn't fix it, I compared little- and big-endian
behaviour and found that a.) vldm and vstm switch doublewords for no
reason I can see or find documentation about and b.) vext extracts from
the top of the vector, not bottom. Taking both into account, I now have
chacha and salsa20 passing tests.

&gt; &gt;&gt; &gt; FAIL: umac
&gt; &gt; I'm drawing a bit of a blank on this one. It fails on the very first
&gt; It could be that if the all-zero input is misaligned, the aligned read +
&gt; rotation tricks gets non-zero data from outside of the input area into
&gt; the computation.

Apparently, NEON adjusts for endianness, meaning shifts switch direction
as well. Which would explain why chacha and salsa20 didn't need more
adjustment. All I needed to do in the end was change the order of
registers for the 64bit return value in umac-nh and the checks passed.

I now have the whole testsuite passing apart from these two:

PASS: cxx
./sexp-conv-test: line 17: ../tools/sexp-conv: No such file or directory
cmp: EOF on test1.out which is empty
FAIL: sexp-conv
SKIP: pkcs1-conv
./nettle-pbkdf2-test: line 18: ../tools/nettle-pbkdf2: No such file or
directory
cmp: EOF on test1.out which is empty
FAIL: nettle-pbkdf2
PASS: symbols
PASS: dlopen
====================
2 of 93 tests failed
====================

They've been failing all along. Can they be ignored?

&gt; &gt; I was wrong: While the compiler is able to output big-endian objects
&gt; &gt; with -mbig-endian, it needs matching libs as well (e.g. libgcc_s).
&gt; &gt; Debian doesn't have anything precompiled for armeb.
&gt; Maybe full-system qemu is easier then (assuming there's some dist
&gt; supporting big-endian arm)?

Weeell, depends on what you consider easier: I haven't found any binary
distribution that supports armeb. Yocto and buildroot seem to support it
but still require compiling the whole thing.

&gt; &gt; -AC_C_BIGENDIAN
&gt; &gt; +AC_C_BIGENDIAN([AC_DEFINE([WORDS_BIGENDIAN], 1)
&gt; &gt; +	[ASM_WORDS_BIGENDIAN=yes]],
&gt; &gt; +	[ASM_WORDS_BIGENDIAN=no])
&gt; I think I'd indent differently, to group the two parts ACTION-IF-TRUE
&gt; together, and drop the redundant square brackets in
&gt; "[ASM_WORDS_BIGENDIAN=yes]".

Done.

&gt; You leave the ACTION-IS-UNIVERSAL as default, which I think is good. I
&gt; hope that's not relevant for arm.

Ahem, seems I was looking at old documentation of autoconf which didn't
have action-if-universal.

Apple does do arm and someone could potentially want to build a fat
nettle that supports x86_64 and arm or rather arm and arm64.

Does nettle currently support being compiled fat with assembly at all?
It would require building the individual platform's asm source and then
lipo-ing them together, I guess. I'm not clear on the specifics.

&gt; Might still be good to set
&gt; ASM_WORDS_BIGENDIAN to some default value before this check, and have
&gt; IF_BE fail if used with an unknown endianness.

But then I want to have a nice error message so as to not leave the user
with an aborted build and no apparent reason. :) Is this portable?

The patch got quite large now. Should I better make a series out of it?

&gt;From 67de31a70f8b8076681d6ddd221605365080103f Mon Sep 17 00:00:00 2001
From: Michael Weiser &lt;michael.weiser@gmx.de&gt;
Date: Wed, 7 Feb 2018 00:11:24 +0100
Subject: [PATCH] Support big-endian arm in assembly code

Introduce m4 macros to conditionally handle differences of little- and
big-endian arm in assembler code. Adjust sha1-compress, sha256-compress,
umac-nh, chacha-core-internal, salsa20-core-internal and memxor for arm
to work in big-endian mode.
---
 arm/memxor.asm                     | 21 ++++++++++++----
 arm/memxor3.asm                    | 49 +++++++++++++++++++++++++-------------
 arm/neon/chacha-core-internal.asm  | 37 +++++++++++++++++++++++-----
 arm/neon/salsa20-core-internal.asm | 43 ++++++++++++++++++++++++++++-----
 arm/neon/umac-nh.asm               |  4 +++-
 arm/v6/sha1-compress.asm           |  8 +++++--
 arm/v6/sha256-compress.asm         | 14 +++++++----
 asm.m4                             |  8 +++++++
 config.m4.in                       |  1 +
 configure.ac                       |  7 +++++-
 10 files changed, 149 insertions(+), 43 deletions(-)

diff --git a/arm/memxor.asm b/arm/memxor.asm
index a50e91bc..239a4034 100644
--- a/arm/memxor.asm
+++ b/arm/memxor.asm
@@ -44,6 +44,11 @@ define(&lt;N&gt;, &lt;r2&gt;)
 define(&lt;CNT&gt;, &lt;r6&gt;)
 define(&lt;TNC&gt;, &lt;r12&gt;)
 
+C little-endian and big-endian need to shift in different directions for
+C alignment correction
+define(&lt;S0ADJ&gt;, IF_LE(&lt;lsr&gt;, &lt;lsl&gt;))
+define(&lt;S1ADJ&gt;, IF_LE(&lt;lsl&gt;, &lt;lsr&gt;))
+
 	.syntax unified
 
 	.file "memxor.asm"
@@ -99,6 +104,8 @@ PROLOGUE(nettle_memxor)
 	C
 	C With little-endian, we need to do
 	C DST[i] ^= (SRC[i] &gt;&gt; CNT) ^ (SRC[i+1] &lt;&lt; TNC)
+	C With big-endian, we need to do
+	C DST[i] ^= (SRC[i] &lt;&lt; CNT) ^ (SRC[i+1] &gt;&gt; TNC)
 
 	push	{r4,r5,r6}
 	
@@ -117,14 +124,14 @@ PROLOGUE(nettle_memxor)
 .Lmemxor_word_loop:
 	ldr	r5, [SRC], #+4
 	ldr	r3, [DST]
-	eor	r3, r3, r4, lsr CNT
-	eor	r3, r3, r5, lsl TNC
+	eor	r3, r3, r4, S0ADJ CNT
+	eor	r3, r3, r5, S1ADJ TNC
 	str	r3, [DST], #+4
 .Lmemxor_odd:
 	ldr	r4, [SRC], #+4
 	ldr	r3, [DST]
-	eor	r3, r3, r5, lsr CNT
-	eor	r3, r3, r4, lsl TNC
+	eor	r3, r3, r5, S0ADJ CNT
+	eor	r3, r3, r4, S1ADJ TNC
 	str	r3, [DST], #+4
 	subs	N, #8
 	bcs	.Lmemxor_word_loop
@@ -132,10 +139,14 @@ PROLOGUE(nettle_memxor)
 	beq	.Lmemxor_odd_done
 
 	C We have TNC/8 left-over bytes in r4, high end
-	lsr	r4, CNT
+	S0ADJ	r4, CNT
 	ldr	r3, [DST]
 	eor	r3, r4
 
+	C memxor_leftover does an LSB store
+	C so we need to reverse if actually BE
+IF_BE(&lt;	rev	r3, r3&gt;)
+
 	pop	{r4,r5,r6}
 
 	C Store bytes, one by one.
diff --git a/arm/memxor3.asm b/arm/memxor3.asm
index 139fd208..69598e1c 100644
--- a/arm/memxor3.asm
+++ b/arm/memxor3.asm
@@ -49,6 +49,11 @@ define(&lt;ATNC&gt;, &lt;r10&gt;)
 define(&lt;BCNT&gt;, &lt;r11&gt;)
 define(&lt;BTNC&gt;, &lt;r12&gt;)
 
+C little-endian and big-endian need to shift in different directions for
+C alignment correction
+define(&lt;S0ADJ&gt;, IF_LE(&lt;lsr&gt;, &lt;lsl&gt;))
+define(&lt;S1ADJ&gt;, IF_LE(&lt;lsl&gt;, &lt;lsr&gt;))
+
 	.syntax unified
 
 	.file "memxor3.asm"
@@ -124,6 +129,8 @@ PROLOGUE(nettle_memxor3)
 	C
 	C With little-endian, we need to do
 	C DST[i-i] ^= (SRC[i-i] &gt;&gt; CNT) ^ (SRC[i] &lt;&lt; TNC)
+	C With big-endian, we need to do
+	C DST[i-i] ^= (SRC[i-i] &lt;&lt; CNT) ^ (SRC[i] &gt;&gt; TNC)
 	rsb	ATNC, ACNT, #32
 	bic	BP, #3
 
@@ -138,14 +145,14 @@ PROLOGUE(nettle_memxor3)
 .Lmemxor3_au_loop:
 	ldr	r5, [BP, #-4]!
 	ldr	r6, [AP, #-4]!
-	eor	r6, r6, r4, lsl ATNC
-	eor	r6, r6, r5, lsr ACNT
+	eor	r6, r6, r4, S1ADJ ATNC
+	eor	r6, r6, r5, S0ADJ ACNT
 	str	r6, [DST, #-4]!
 .Lmemxor3_au_odd:
 	ldr	r4, [BP, #-4]!
 	ldr	r6, [AP, #-4]!
-	eor	r6, r6, r5, lsl ATNC
-	eor	r6, r6, r4, lsr ACNT
+	eor	r6, r6, r5, S1ADJ ATNC
+	eor	r6, r6, r4, S0ADJ ACNT
 	str	r6, [DST, #-4]!
 	subs	N, #8
 	bcs	.Lmemxor3_au_loop
@@ -154,7 +161,11 @@ PROLOGUE(nettle_memxor3)
 
 	C Leftover bytes in r4, low end
 	ldr	r5, [AP, #-4]
-	eor	r4, r5, r4, lsl ATNC
+	eor	r4, r5, r4, S1ADJ ATNC
+
+	C leftover does an LSB store
+	C so we need to reverse if actually BE
+IF_BE(&lt;	rev	r4, r4&gt;)
 
 .Lmemxor3_au_leftover:
 	C Store a byte at a time
@@ -247,21 +258,25 @@ PROLOGUE(nettle_memxor3)
 	ldr	r5, [AP, #-4]!
 	ldr	r6, [BP, #-4]!
 	eor	r5, r6
-	lsl	r4, ATNC
-	eor	r4, r4, r5, lsr ACNT
+	S1ADJ	r4, ATNC
+	eor	r4, r4, r5, S0ADJ ACNT
 	str	r4, [DST, #-4]!
 .Lmemxor3_uu_odd:
 	ldr	r4, [AP, #-4]!
 	ldr	r6, [BP, #-4]!
 	eor	r4, r6
-	lsl	r5, ATNC
-	eor	r5, r5, r4, lsr ACNT
+	S1ADJ	r5, ATNC
+	eor	r5, r5, r4, S0ADJ ACNT
 	str	r5, [DST, #-4]!
 	subs	N, #8
 	bcs	.Lmemxor3_uu_loop
 	adds	N, #8
 	beq	.Lmemxor3_done
 
+	C leftover does an LSB store
+	C so we need to reverse if actually BE
+IF_BE(&lt;	rev	r4, r4&gt;)
+
 	C Leftover bytes in a4, low end
 	ror	r4, ACNT
 .Lmemxor3_uu_leftover:
@@ -290,18 +305,18 @@ PROLOGUE(nettle_memxor3)
 .Lmemxor3_uud_loop:
 	ldr	r5, [AP, #-4]!
 	ldr	r7, [BP, #-4]!
-	lsl	r4, ATNC
-	eor	r4, r4, r6, lsl BTNC
-	eor	r4, r4, r5, lsr ACNT
-	eor	r4, r4, r7, lsr BCNT
+	S1ADJ	r4, ATNC
+	eor	r4, r4, r6, S1ADJ BTNC
+	eor	r4, r4, r5, S0ADJ ACNT
+	eor	r4, r4, r7, S0ADJ BCNT
 	str	r4, [DST, #-4]!
 .Lmemxor3_uud_odd:
 	ldr	r4, [AP, #-4]!
 	ldr	r6, [BP, #-4]!
-	lsl	r5, ATNC
-	eor	r5, r5, r7, lsl BTNC
-	eor	r5, r5, r4, lsr ACNT
-	eor	r5, r5, r6, lsr BCNT
+	S1ADJ	r5, ATNC
+	eor	r5, r5, r7, S1ADJ BTNC
+	eor	r5, r5, r4, S0ADJ ACNT
+	eor	r5, r5, r6, S0ADJ BCNT
 	str	r5, [DST, #-4]!
 	subs	N, #8
 	bcs	.Lmemxor3_uud_loop
diff --git a/arm/neon/chacha-core-internal.asm b/arm/neon/chacha-core-internal.asm
index 6f623106..43bacda6 100644
--- a/arm/neon/chacha-core-internal.asm
+++ b/arm/neon/chacha-core-internal.asm
@@ -90,31 +90,50 @@ PROLOGUE(_nettle_chacha_core)
 	vmov	S2, X2
 	vmov	S3, X3
 
-	C Input rows:
+	C Input rows little-endian:
 	C	 0  1  2  3	X0
 	C	 4  5  6  7	X1
 	C	 8  9 10 11	X2
 	C	12 13 14 15	X3
 
+	C Input rows big-endian:
+	C	 2  3  0  1	X0
+	C	 6  7  4  5	X1
+	C	10 11  8  9	X2
+	C	14 15 12 13	X3
+	C because vldm switches doublewords
+
 .Loop:
 	QROUND(X0, X1, X2, X3)
 
-	C Rotate rows, to get
+	C In little-endian rotate rows, to get
 	C	 0  1  2  3
 	C	 5  6  7  4  &gt;&gt;&gt; 3
 	C	10 11  8  9  &gt;&gt;&gt; 2
 	C	15 12 13 14  &gt;&gt;&gt; 1
-	vext.32	X1, X1, X1, #1
+
+	C In big-endian rotate rows, to get
+	C	 2  3  0  1
+	C	 7  4  5  6  &gt;&gt;&gt; 3
+	C	 8  9 10 11  &gt;&gt;&gt; 2
+	C	13 14 15 12  &gt;&gt;&gt; 1
+
+	C vext extracts from the top of the vector instead of bottom
+IF_LE(&lt;	vext.32	X1, X1, X1, #1&gt;)
+IF_BE(&lt;	vext.32	X1, X1, X1, #3&gt;)
 	vext.32	X2, X2, X2, #2
-	vext.32	X3, X3, X3, #3
+IF_LE(&lt;	vext.32	X3, X3, X3, #3&gt;)
+IF_BE(&lt;	vext.32	X3, X3, X3, #1&gt;)
 
 	QROUND(X0, X1, X2, X3)
 
 	subs	ROUNDS, ROUNDS, #2
 	C Inverse rotation
-	vext.32	X1, X1, X1, #3
+IF_LE(&lt;	vext.32	X1, X1, X1, #3&gt;)
+IF_BE(&lt;	vext.32	X1, X1, X1, #1&gt;)
 	vext.32	X2, X2, X2, #2
-	vext.32	X3, X3, X3, #1
+IF_LE(&lt;	vext.32	X3, X3, X3, #1&gt;)
+IF_BE(&lt;	vext.32	X3, X3, X3, #3&gt;)
 
 	bhi	.Loop
 
@@ -123,6 +142,12 @@ PROLOGUE(_nettle_chacha_core)
 	vadd.u32	X2, X2, S2
 	vadd.u32	X3, X3, S3
 
+	C caller expects result little-endian
+IF_BE(&lt;	vrev32.u8	X0, X0
+	vrev32.u8	X1, X1
+	vrev32.u8	X2, X2
+	vrev32.u8	X3, X3&gt;)
+
 	vstm	DST, {X0,X1,X2,X3}
 	bx	lr
 EPILOGUE(_nettle_chacha_core)
diff --git a/arm/neon/salsa20-core-internal.asm b/arm/neon/salsa20-core-internal.asm
index 34eb1fba..12a812d8 100644
--- a/arm/neon/salsa20-core-internal.asm
+++ b/arm/neon/salsa20-core-internal.asm
@@ -88,7 +88,7 @@ define(&lt;QROUND&gt;, &lt;
 PROLOGUE(_nettle_salsa20_core)
 	vldm	SRC, {X0,X1,X2,X3}
 
-	C Input rows:
+	C Input rows little-endian:
 	C	 0  1  2  3	X0
 	C	 4  5  6  7	X1
 	C	 8  9 10 11	X2
@@ -99,6 +99,18 @@ PROLOGUE(_nettle_salsa20_core)
 	C	 8 13  2  7
 	C	12  1  6 11
 
+	C Input rows big-endian:
+	C	 2  3  0  1	X0
+	C	 6  7  4  5	X1
+	C	10 11  8  9	X2
+	C	14 15 12 13	X3
+	C because vldm switches doublewords
+	C Permuted to:
+	C	10 15  0  5
+	C	14  3  4  9
+	C	 2  7  8 13
+	C	 6 11 12  1
+
 	C FIXME: Construct in some other way?
 	adr	r12, .Lmasks
 	vldm	r12, {M0101, M0110, M0011}
@@ -112,6 +124,7 @@ PROLOGUE(_nettle_salsa20_core)
 	C	 4  1  6  3	T0 v
 	C	 8 13 10 15	T1  ^
 	C	12  9 14 11	X3  v
+	C same in big endian just with transposed double-rows
 	vmov	T0, X1
 	vmov	T1, X2
 	vbit	T0, X0, M0101
@@ -140,22 +153,34 @@ PROLOGUE(_nettle_salsa20_core)
 .Loop:
 	QROUND(X0, X1, X2, X3)
 
-	C Rotate rows, to get
+	C In little-endian rotate rows, to get
 	C	 0  5 10 15
 	C	 3  4  9 14  &gt;&gt;&gt; 1
 	C	 2  7  8 13  &gt;&gt;&gt; 2
 	C	 1  6 11 12  &gt;&gt;&gt; 3
-	vext.32	X1, X1, X1, #3
+
+	C In big-endian rotate rows, to get
+	C	10 15  0  5
+	C	 9 14  3  4  &gt;&gt;&gt; 1
+	C	 8 13  2  7  &gt;&gt;&gt; 2
+	C	11 12  1  6  &gt;&gt;&gt; 3
+
+	C vext extracts from the top of the vector instead of bottom
+IF_LE(&lt;	vext.32	X1, X1, X1, #3&gt;)
+IF_BE(&lt;	vext.32	X1, X1, X1, #1&gt;)
 	vext.32	X2, X2, X2, #2
-	vext.32	X3, X3, X3, #1
+IF_LE(&lt;	vext.32	X3, X3, X3, #1&gt;)
+IF_BE(&lt;	vext.32	X3, X3, X3, #3&gt;)
 
 	QROUND(X0, X3, X2, X1)
 
 	subs	ROUNDS, ROUNDS, #2
 	C Inverse rotation
-	vext.32	X1, X1, X1, #1
+IF_LE(&lt;	vext.32	X1, X1, X1, #1&gt;)
+IF_BE(&lt;	vext.32	X1, X1, X1, #3&gt;)
 	vext.32	X2, X2, X2, #2
-	vext.32	X3, X3, X3, #3
+IF_LE(&lt;	vext.32	X3, X3, X3, #3&gt;)
+IF_BE(&lt;	vext.32	X3, X3, X3, #1&gt;)
 
 	bhi	.Loop
 
@@ -181,6 +206,12 @@ PROLOGUE(_nettle_salsa20_core)
 	vadd.u32	X2, X2, S2
 	vadd.u32	X3, X3, S3
 
+	C caller expects result little-endian
+IF_BE(&lt;	vrev32.u8	X0, X0
+	vrev32.u8	X1, X1
+	vrev32.u8	X2, X2
+	vrev32.u8	X3, X3&gt;)
+
 	vstm	DST, {X0,X1,X2,X3}
 	bx	lr
 EPILOGUE(_nettle_salsa20_core)
diff --git a/arm/neon/umac-nh.asm b/arm/neon/umac-nh.asm
index 158a5686..2b617202 100644
--- a/arm/neon/umac-nh.asm
+++ b/arm/neon/umac-nh.asm
@@ -97,6 +97,8 @@ PROLOGUE(_nettle_umac_nh)
 	bhi	.Loop
 
 	vadd.i64 D0REG(QY), D0REG(QY), D1REG(QY)
-	vmov	r0, r1, D0REG(QY)
+	C return values use memory endianness
+IF_LE(&lt;	vmov	r0, r1, D0REG(QY)&gt;)
+IF_BE(&lt;	vmov	r1, r0, D0REG(QY)&gt;)
 	bx	lr
 EPILOGUE(_nettle_umac_nh)
diff --git a/arm/v6/sha1-compress.asm b/arm/v6/sha1-compress.asm
index 59d6297e..8cc22be7 100644
--- a/arm/v6/sha1-compress.asm
+++ b/arm/v6/sha1-compress.asm
@@ -52,7 +52,7 @@ define(&lt;LOAD&gt;, &lt;
 	sel	W, WPREV, T0
 	ror	W, W, SHIFT
 	mov	WPREV, T0
-	rev	W, W
+IF_LE(&lt;	rev	W, W&gt;)
 	str	W, [SP,#eval(4*$1)]
 &gt;)
 define(&lt;EXPN&gt;, &lt;
@@ -127,8 +127,12 @@ PROLOGUE(_nettle_sha1_compress)
 	lsl	SHIFT, SHIFT, #3
 	mov	T0, #0
 	movne	T0, #-1
-	lsl	W, T0, SHIFT
+IF_LE(&lt;	lsl	W, T0, SHIFT&gt;)
+IF_BE(&lt;	lsr	W, T0, SHIFT&gt;)
 	uadd8	T0, T0, W		C Sets APSR.GE bits
+	C on BE rotate right by 32-SHIFT bits
+	C because there is no rotate left
+IF_BE(&lt;	rsb     SHIFT, SHIFT, #32&gt;)
 	
 	ldr	K, .LK1
 	ldm	STATE, {SA,SB,SC,SD,SE}
diff --git a/arm/v6/sha256-compress.asm b/arm/v6/sha256-compress.asm
index e6f4e1e9..324730c7 100644
--- a/arm/v6/sha256-compress.asm
+++ b/arm/v6/sha256-compress.asm
@@ -137,8 +137,12 @@ PROLOGUE(_nettle_sha256_compress)
 	lsl	SHIFT, SHIFT, #3
 	mov	T0, #0
 	movne	T0, #-1
-	lsl	I1, T0, SHIFT
+IF_LE(&lt;	lsl	I1, T0, SHIFT&gt;)
+IF_BE(&lt;	lsr	I1, T0, SHIFT&gt;)
 	uadd8	T0, T0, I1		C Sets APSR.GE bits
+	C on BE rotate right by 32-SHIFT bits
+	C because there is no rotate left
+IF_BE(&lt;	rsb	SHIFT, SHIFT, #32&gt;)
 
 	mov	DST, sp
 	mov	ILEFT, #4
@@ -146,16 +150,16 @@ PROLOGUE(_nettle_sha256_compress)
 	ldm	INPUT!, {I1,I2,I3,I4}
 	sel	I0, I0, I1
 	ror	I0, I0, SHIFT
-	rev	I0, I0
+IF_LE(&lt;	rev	I0, I0&gt;)
 	sel	I1, I1, I2
 	ror	I1, I1, SHIFT
-	rev	I1, I1
+IF_LE(&lt;	rev	I1, I1&gt;)
 	sel	I2, I2, I3
 	ror	I2, I2, SHIFT
-	rev	I2, I2
+IF_LE(&lt;	rev	I2, I2&gt;)
 	sel	I3, I3, I4
 	ror	I3, I3, SHIFT
-	rev	I3, I3
+IF_LE(&lt;	rev	I3, I3&gt;)
 	subs	ILEFT, ILEFT, #1
 	stm	DST!, {I0,I1,I2,I3}
 	mov	I0, I4	
diff --git a/asm.m4 b/asm.m4
index 4018c235..8c290551 100644
--- a/asm.m4
+++ b/asm.m4
@@ -51,6 +51,14 @@ define(&lt;ALIGN&gt;,
 &lt;.align ifelse(ALIGN_LOG,yes,&lt;m4_log2($1)&gt;,$1)
 &gt;)
 
+define(&lt;IF_BE&gt;, &lt;ifelse(
+WORDS_BIGENDIAN,yes,&lt;$1&gt;,
+WORDS_BIGENDIAN,no,&lt;$2&gt;,
+&lt;errprint(__file__:__line__:,&lt;Unsupported endianness value&gt;,WORDS_BIGENDIAN,&lt;
+&gt;)
+  m4exit(1)&gt;)&gt;)
+define(&lt;IF_LE&gt;, &lt;IF_BE(&lt;$2&gt;, &lt;$1&gt;)&gt;)
+
 dnl Struct defining macros
 
 dnl STRUCTURE(prefix) 
diff --git a/config.m4.in b/config.m4.in
index e39c880c..11f90a40 100644
--- a/config.m4.in
+++ b/config.m4.in
@@ -7,6 +7,7 @@ define(&lt;TYPE_PROGBITS&gt;, &lt;@ASM_TYPE_PROGBITS@&gt;)dnl
 define(&lt;ALIGN_LOG&gt;, &lt;@ASM_ALIGN_LOG@&gt;)dnl
 define(&lt;W64_ABI&gt;, &lt;@W64_ABI@&gt;)dnl
 define(&lt;RODATA&gt;, &lt;@ASM_RODATA@&gt;)dnl
+define(&lt;WORDS_BIGENDIAN&gt;, &lt;@ASM_WORDS_BIGENDIAN@&gt;)dnl
 divert(1)
 @ASM_MARK_NOEXEC_STACK@
 divert
diff --git a/configure.ac b/configure.ac
index 41bf0998..b57d2fb8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -201,7 +201,11 @@ LSH_FUNC_STRERROR
 # getenv_secure is used for fat overrides,
 # getline is used in the testsuite
 AC_CHECK_FUNCS(secure_getenv getline)
-AC_C_BIGENDIAN
+
+ASM_WORDS_BIGENDIAN=unknown
+AC_C_BIGENDIAN([AC_DEFINE([WORDS_BIGENDIAN], 1)
+		ASM_WORDS_BIGENDIAN=yes],
+	[ASM_WORDS_BIGENDIAN=no])
 
 AC_CACHE_CHECK([for __builtin_bswap64],
 		nettle_cv_c_builtin_bswap64,
@@ -811,6 +815,7 @@ AC_SUBST(ASM_TYPE_PROGBITS)
 AC_SUBST(ASM_MARK_NOEXEC_STACK)
 AC_SUBST(ASM_ALIGN_LOG)
 AC_SUBST(W64_ABI)
+AC_SUBST(ASM_WORDS_BIGENDIAN)
 AC_SUBST(EMULATOR)
 
 AC_SUBST(LIBNETTLE_MAJOR)
-- 
2.16.1

-- 
bye, Michael
I hate forms!

</body></email><email><emailId>20180212075916</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-12 07:59:16-0400</timestampReceived><subject>Re: Miscomputation with big-endian arm asm</subject><body>

Michael Weiser &lt;michael@weiser.dinsnail.net&gt; writes:

&gt; Right. When this still didn't fix it, I compared little- and big-endian
&gt; behaviour and found that a.) vldm and vstm switch doublewords for no
&gt; reason I can see or find documentation about and b.) 

By "doublewords", you mean 64-bit words, right?

It might make sense to view it as big-endian or little-endian load of
128-bit values, and a 128-bit (16-byte) byte swap will then also swap
the low and high 64-bit halves.

&gt; vext extracts from
&gt; the top of the vector, not bottom. Taking both into account, I now have
&gt; chacha and salsa20 passing tests.

If it's hard to find docs, I take it as a sign big-endian arm is a bit
obscure... Could you add a short note to arm/README with your findings?
(It's quite some time since I did neon assembly, so I don't recall off
the top of my head any details on what the various instructions, in
particular vextr, do).

&gt; PASS: cxx
&gt; ./sexp-conv-test: line 17: ../tools/sexp-conv: No such file or directory
&gt; cmp: EOF on test1.out which is empty
&gt; FAIL: sexp-conv
&gt; SKIP: pkcs1-conv
&gt; ./nettle-pbkdf2-test: line 18: ../tools/nettle-pbkdf2: No such file or
&gt; directory
&gt; cmp: EOF on test1.out which is empty
&gt; FAIL: nettle-pbkdf2
&gt; PASS: symbols
&gt; PASS: dlopen
&gt; ====================
&gt; 2 of 93 tests failed
&gt; ====================
&gt;
&gt; They've been failing all along. Can they be ignored?

They're not that relevant to your changes, but I'd like to understand
why they fail. What's the contents of the tools dir in your buld tree?
You haven't done something like switched from building in the source
tree build to a separate build tree, without a proper cleaning (make
distclean) in the source tree?

&gt; Weeell, depends on what you consider easier: I haven't found any binary
&gt; distribution that supports armeb. Yocto and buildroot seem to support it
&gt; but still require compiling the whole thing.

Hmm. Sounds more than a bit inconvenient.

&gt; Apple does do arm and someone could potentially want to build a fat
&gt; nettle that supports x86_64 and arm or rather arm and arm64.

My concern is not breaking any setup which currently works, e.g, a non
assebly "universal" build involving architectures with different
endianness.

&gt; Does nettle currently support being compiled fat with assembly at all?

I don't think so. I'd expect one would have to build for one arch at a
time, and have some postprocessing scripts to produce apple-fat
libraries.

&gt; But then I want to have a nice error message so as to not leave the user
&gt; with an aborted build and no apparent reason. :) Is this portable?

According to
http://pubs.opengroup.org/onlinepubs/9699919799/utilities/m4.html,
errprint and m4exit are standard m4. (If they're also supported in
practice is a different question, it's desirable to at least work with
both GNU and BSD m4). If __file__ and __line__ are unportable, you could
omit that. Since the error message reports a pretty global config
problem, precise location isn't that important.

&gt; The patch got quite large now. Should I better make a series out of it?

As you prefer, I think it is workable as is. It might help to split out
the configure-related changes.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180207205321</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-07 20:53:21-0400</timestampReceived><subject>Re: easier version checks</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; What about extending the macros in version.h with a simple to use
&gt; combined version number?

I think I'd prefer to leave that out. The formatting is very arbitrary, and any
application which needs it can 

#define NETTLE_COMBINED_VERSION \
  ((NETTLE_VERSION_MAJOR &lt;&lt; 16) + NETTLE_VERSION_MINOR).

or

#define NETTLE_AT_LEAST(major, minor) \
  ((NETTLE_VERSION_MAJOR &lt;&lt; 16) + NETTLE_VERSION_MINOR \
   &gt;= (((major) &lt;&lt; 16) + (minor)))

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180327210428</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-27 21:04:28-0400</timestampReceived><subject>Re: symbol versioning update</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt;  When we initially introduced symbol versioning in nettle we bundled
&gt; all symbols from the library in a single version. That means that new
&gt; symbols added to a release like nettle_get_hashes() may cause issues
&gt; like this:
&gt; https://bugzilla.redhat.com/show_bug.cgi?id=1549190

I aim to ensure that a program compiled with nettle version x should
work fine when linked with nettle version x+1, with exceptions told to
the linker by changing the soname. When I talk about backwards
compatibility, it's always this case I have in mind.

In general, I don't try to support compiling a program using libnettle
version x, and then linking it with libnettle version x-1, and I think
that should be referred to as forward compatibility rather backward
comatibility. (I might try if I do releases with only bug fixes,
typically with unchanged minor version).

Maybe that's the old-fashioned way, but if you want to be sure the
program can link successfully with nettle version x-1, you need to
compile it using nettle x-1 development files.

So if a distro builds stuff using nettle version x on the build machine,
the dependency on the resulting binary packages should express that it
needs shared nettle libraries which 

  (i) correspond to a package version &gt;= x, and 
  (ii) uses the same soname.

&gt; The underlying issue is in rpm-based systems which detect which symbols
&gt; exist in which library version based on the version. That way, when a
&gt; dependency is tracked, the version with the right symbol will be
&gt; retrieved.

That's clever, and should work fine for packages that make the extra
effort to have fine-grained symbol versions, but it can't be the *only*
way to handle libraries with rpm?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180328083848</emailId><senderName>Daniel =?utf-8?B?UC4gQmVycmFuZ8Op?=</senderName><senderEmail>berrange@redhat.com</senderEmail><timestampReceived>2018-03-28 08:38:48-0400</timestampReceived><subject>Re: symbol versioning update</subject><body>

On Tue, Mar 27, 2018 at 11:04:28PM +0200, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; 
&gt; &gt;  When we initially introduced symbol versioning in nettle we bundled
&gt; &gt; all symbols from the library in a single version. That means that new
&gt; &gt; symbols added to a release like nettle_get_hashes() may cause issues
&gt; &gt; like this:
&gt; &gt; https://bugzilla.redhat.com/show_bug.cgi?id=1549190
&gt; 
&gt; I aim to ensure that a program compiled with nettle version x should
&gt; work fine when linked with nettle version x+1, with exceptions told to
&gt; the linker by changing the soname. When I talk about backwards
&gt; compatibility, it's always this case I have in mind.
&gt; 
&gt; In general, I don't try to support compiling a program using libnettle
&gt; version x, and then linking it with libnettle version x-1, and I think
&gt; that should be referred to as forward compatibility rather backward
&gt; comatibility. (I might try if I do releases with only bug fixes,
&gt; typically with unchanged minor version).
&gt; 
&gt; Maybe that's the old-fashioned way, but if you want to be sure the
&gt; program can link successfully with nettle version x-1, you need to
&gt; compile it using nettle x-1 development files.
&gt; 
&gt; So if a distro builds stuff using nettle version x on the build machine,
&gt; the dependency on the resulting binary packages should express that it
&gt; needs shared nettle libraries which 
&gt; 
&gt;   (i) correspond to a package version &gt;= x, and 
&gt;   (ii) uses the same soname.
&gt; 
&gt; &gt; The underlying issue is in rpm-based systems which detect which symbols
&gt; &gt; exist in which library version based on the version. That way, when a
&gt; &gt; dependency is tracked, the version with the right symbol will be
&gt; &gt; retrieved.
&gt; 
&gt; That's clever, and should work fine for packages that make the extra
&gt; effort to have fine-grained symbol versions, but it can't be the *only*
&gt; way to handle libraries with rpm?

The traditional way is for developers to update the dependancies to have
an explicit version against the library they require. eg if libvirt requires
some symbol introduced in nettle x.y, the maintainer would add

  Requires: nettle &gt;= x.y

the problem is that humans are fallible and so these versioned dependancies
frequently get missed, because package maintainers don't often have accurate
info on which min version is needed by a build. By adding fine grained symbol
versioning to the nettle library, humans are taken out of the loop, in favour
of automation in the toolchain. The linker embeds elf versions in the
downstream app linking to nettle, so the linker will refuse to load against
an outdated nettle. RPM automatically extracts these versions and turns
then into correct versioned dependancies ensuring old versions can't be
installed in the first place. The only scope for errors here is when the
nettle developers are creating the symbol version file, and this is pretty
minor IME maintaining such version files for libvirt.

Regards,
Daniel
-- 
|: https://berrange.com      -o-    https://www.flickr.com/photos/dberrange :|
|: https://libvirt.org         -o-            https://fstop138.berrange.com :|
|: https://entangle-photo.org    -o-    https://www.instagram.com/dberrange :|

</body></email><email><emailId>20180403100738</emailId><senderName>Daniel =?utf-8?B?UC4gQmVycmFuZ8Op?=</senderName><senderEmail>berrange@redhat.com</senderEmail><timestampReceived>2018-04-03 10:07:38-0400</timestampReceived><subject>Re: symbol versioning update</subject><body>

On Fri, Mar 30, 2018 at 09:29:51AM +0200, Niels Möller wrote:
&gt; Daniel P. Berrangé &lt;berrange@redhat.com&gt; writes:
&gt; &gt; The only scope for errors here is when the
&gt; &gt; nettle developers are creating the symbol version file,
&gt; 
&gt; That's me... And I imagine we'll get into the territory of subtle
&gt; breakages the first time I mess up an update to that file.
&gt; 
&gt; &gt; and this is pretty
&gt; &gt; minor IME maintaining such version files for libvirt.
&gt; 
&gt; How do you write testcases to verify that the version list is correct?

We've not added any tests for symbol versioning correctness - we just
rely on whoever adds the API to pay attention to the file comments.

eg the tail of the libvirt_public.syms file current looks like this...

  ...
  LIBVIRT_3.9.0 {
      global:
          virDomainSetLifecycleAction;
  } LIBVIRT_3.7.0;

  LIBVIRT_4.1.0 {
      global:
          virStoragePoolLookupByTargetPath;
  } LIBVIRT_3.9.0;

  # .... define new API here using predicted next version number ....

and we rely on our code reviewers to watch for people making mistakes.
We've not had any mistakes committed before but then we are lucky to have
a large pool of active reviewers to notice this.

Regards,
Daniel
-- 
|: https://berrange.com      -o-    https://www.flickr.com/photos/dberrange :|
|: https://libvirt.org         -o-            https://fstop138.berrange.com :|
|: https://entangle-photo.org    -o-    https://www.instagram.com/dberrange :|

</body></email><email><emailId>20180317163001</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-17 16:30:01-0400</timestampReceived><subject>Re: What should nettle-3.5 be like?</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; 1. Remove the the symbols nettle_hashes and nettle_secp_384r1 and
&gt;    friends from the interface. They should be renamed with leading
&gt;    underscore. Important to be able to merge ed448 work without breaking
&gt;    the abi again.

I've made this change, and pushed to a branch rename-data-symbols.
Might break gnutls, if it hasn't yet been updated to use functions
nettle_get_secp_256r1 and friends.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180318132051</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-03-18 13:20:51-0400</timestampReceived><subject>Re: What should nettle-3.5 be like?</subject><body>

On Sat, 2018-03-17 at 17:30 +0100, Niels Möller wrote:
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt; &gt; 1. Remove the the symbols nettle_hashes and nettle_secp_384r1 and
&gt; &gt;    friends from the interface. They should be renamed with leading
&gt; &gt;    underscore. Important to be able to merge ed448 work without
&gt; &gt; breaking
&gt; &gt;    the abi again.
&gt; 
&gt; I've made this change, and pushed to a branch rename-data-symbols.
&gt; Might break gnutls, if it hasn't yet been updated to use functions
&gt; nettle_get_secp_256r1 and friends.

It has but the detection is done through major and minor lib version.
Are they updated? (btw. I'd really recommend providing easy to use
macros for version detection)

However what is the goal with this rename? As far as I see the _nettle
symbols are also exported from the library and thus the new symbols are
as well. Wouldn't it make sense to remove them from the map file as
well, and only export symbols starting with nettle_*?

regards,
Nikos


</body></email><email><emailId>20180318155919</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-18 15:59:19-0400</timestampReceived><subject>Re: What should nettle-3.5 be like?</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; It has but the detection is done through major and minor lib version.
&gt; Are they updated?

Not yet. I could add a version number bump on that branch, and see if
the tests then pass. I generally recommend configure checks for features
used rather than version checks, whenever practical.

&gt; (btw. I'd really recommend providing easy to use
&gt; macros for version detection)

I know... As I see it, that could be motivated by convenience primarily
for projects not using autoconf.

&gt; However what is the goal with this rename?

To be able to change the size in later releases, without *subtle*
breakages of applications using the old and documented api.

&gt; Wouldn't it make sense to remove them from the map file as
&gt; well, and only export symbols starting with nettle_*?

I'm considing it, but it's not trivial. A related option is to move
declarations into internal, uninstalled headers.

First, symbols have underscores for a few different reasons; the symbols
I'm renaming here have it only because size is private and it may leak
into the abi with some flavors of linking. Otherwise, they're well
documented and unlikely to see any incompatible changes.

Other symbols, e.g., _nettle_sha256_compress and _nettle_umac_nh, are
internal interfaces which might change if nettle gets new or different
optimizations.

And there are different kinds of possible uses:

0. From within the nettle library.

1. From test and benchmarking executables in Nettle.

2. From user's experimental code, which don't care much about api or abi
   compatibilities with other versions.

3. Statically linked binaries, e.g, on embedded systems, might access
   _nettle_secp_256r1 directly to avoid an extra level of indirection
   and runtime lookup, with no real problem.

4. Plain applications relying on both api and abi stability.

We need to allow (1) (at least for some of the _nettle_* symbols).
We need to strongly discourage (4). For (2) and (3), it would be nice to
be liberal, but it might be fine to simply export more symbols in the
static library.

Removing declarations from internal header files would allow (1) and
(2), and strongly discourage all other use (if anyone adds their own
declarations to be able to call internal functions in a library they are
using, they ought to understand they're in unsupported territory).

What would it take to hide all _nettle symbols in libnettle.se? Just
delete the _nettle_* line in libnettle.map.in, like

--- a/libnettle.map.in
+++ b/libnettle.map.in
@@ -9,7 +9,6 @@ NETTLE_@LIBNETTLE_MAJOR@
 {
   global:
     nettle_*;
-    _nettle_*;
 
   local:
     *;

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180319131913</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-03-19 13:19:13-0400</timestampReceived><subject>Re: What should nettle-3.5 be like?</subject><body>

On Sun, 2018-03-18 at 16:59 +0100, Niels Möller wrote:
&gt; 
&gt; &gt; Wouldn't it make sense to remove them from the map file as
&gt; &gt; well, and only export symbols starting with nettle_*?
&gt; 
&gt; I'm considing it, but it's not trivial. A related option is to move
&gt; declarations into internal, uninstalled headers.

That would be sufficient. In gnutls I group these internal symbols
outside the main version used for symbols. That is:

https://gitlab.com/gnutls/gnutls/blob/master/lib/libgnutls.map#L1244

These are not present in any header, and tests use the internal headers
to see them. Another approach could be to put them into a version which
has variable (per release name). That would allow linking with them,
but will always break software that uses them.

&gt; First, symbols have underscores for a few different reasons; the
&gt; symbols
&gt; I'm renaming here have it only because size is private and it may
&gt; leak
&gt; into the abi with some flavors of linking. Otherwise, they're well
&gt; documented and unlikely to see any incompatible changes.

&gt; Other symbols, e.g., _nettle_sha256_compress and _nettle_umac_nh, are
&gt; internal interfaces which might change if nettle gets new or
&gt; different optimizations.

We can list the ones that are unlike to see incompatible changes and
are useful in applications explicitly, and move any others to either
local, or to a private version.

&gt; 
&gt; And there are different kinds of possible uses:
&gt; 
&gt; 0. From within the nettle library.
&gt; 
&gt; 1. From test and benchmarking executables in Nettle.
&gt; 
&gt; 2. From user's experimental code, which don't care much about api or
&gt; abi
&gt;    compatibilities with other versions.
&gt; 
&gt; 3. Statically linked binaries, e.g, on embedded systems, might access
&gt;    _nettle_secp_256r1 directly to avoid an extra level of indirection
&gt;    and runtime lookup, with no real problem.
&gt; 
&gt; 4. Plain applications relying on both api and abi stability.
&gt; 
&gt; We need to allow (1) (at least for some of the _nettle_* symbols).
&gt; We need to strongly discourage (4). For (2) and (3), it would be nice
&gt; to
&gt; be liberal, but it might be fine to simply export more symbols in the
&gt; static library.
&gt; 
&gt; Removing declarations from internal header files would allow (1) and
&gt; (2), and strongly discourage all other use (if anyone adds their own
&gt; declarations to be able to call internal functions in a library they
&gt; are using, they ought to understand they're in unsupported
&gt; territory).
&gt; 
&gt; What would it take to hide all _nettle symbols in libnettle.se? Just
&gt; delete the _nettle_* line in libnettle.map.in

Yes.

regards,
Nikos


</body></email><email><emailId>20180319215720</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-19 21:57:20-0400</timestampReceived><subject>Re: What should nettle-3.5 be like?</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; Another approach could be to put them into a version which
&gt; has variable (per release name). That would allow linking with them,
&gt; but will always break software that uses them.

I think I like this. Should be easy to implement, document and
understand. 

A version like

NETTLE_INTERNAL_@PACKAGE_VERSION@ 

in libnettle.map.in would do, I guess? By definition, this gets a new
value for every release, and we don't need to care about structure of the
version string (major, minor, patchlevel, rcX, whatever).

I guess I'd need to read up a bit on how linker scripts work.

&gt;&gt; Other symbols, e.g., _nettle_sha256_compress and _nettle_umac_nh, are
&gt;&gt; internal interfaces which might change if nettle gets new or
&gt;&gt; different optimizations.
&gt;
&gt; We can list the ones that are unlike to see incompatible changes and
&gt; are useful in applications explicitly, and move any others to either
&gt; local, or to a private version.

Right, we can decide case by case if those symbols should be in
installed headers (I think that's ok for the hash *_compress functions),
and if so, whether or not they should be document beyond header
comments.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180319220840</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-19 22:08:40-0400</timestampReceived><subject>Re: What should nettle-3.5 be like?</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; It has but the detection is done through major and minor lib version.
&gt; Are they updated?

Hmm, I'm looking at

https://gitlab.com/gnutls/gnutls/blob/master/lib/nettle/pk.c, line 1066:

#if NETTLE_MAJOR_VERSION &lt; 3 || (NETTLE_MAJOR_VERSION == 3 &amp;&amp; NETTLE_MINOR_VERSION &lt; 4)

That should use the old symbols only prior to nettle-3.4, which seems
correct, since the new accessors were introduced in nettle-3.4. But
the rename-data-symbols branch also carries version 3.4, so the failure 

https://gitlab.com/gnutls/nettle/-/jobs/57981115

is a bit strange. Maybe it's missing an #include &lt;nettle/version.h&gt; ?

It would be good to always compile with -Wundef, but that might break
other checks.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180320071842</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-03-20 07:18:42-0400</timestampReceived><subject>Re: What should nettle-3.5 be like?</subject><body>

On Mon, 2018-03-19 at 23:08 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt; 
&gt; &gt; It has but the detection is done through major and minor lib
&gt; &gt; version.
&gt; &gt; Are they updated?
&gt; 
&gt; Hmm, I'm looking at
&gt; 
&gt; https://gitlab.com/gnutls/gnutls/blob/master/lib/nettle/pk.c, line
&gt; 1066:
&gt; 
&gt; #if NETTLE_MAJOR_VERSION &lt; 3 || (NETTLE_MAJOR_VERSION == 3 &amp;&amp;
&gt; NETTLE_MINOR_VERSION &lt; 4)
&gt; 
&gt; That should use the old symbols only prior to nettle-3.4, which seems
&gt; correct, since the new accessors were introduced in nettle-3.4. But
&gt; the rename-data-symbols branch also carries version 3.4, so the
&gt; failure  
&gt; 
&gt; https://gitlab.com/gnutls/nettle/-/jobs/57981115
&gt; 
&gt; is a bit strange. Maybe it's missing an #include &lt;nettle/version.h&gt; ?

That's very strange. bignum.h already includes version.h, so that
should have been ok. I've also explicitly added it and re-run with the
same results:
https://gitlab.com/gnutls/nettle/-/jobs/58340605

What is even more strange is that gnutls in fedora is already using the
new functions, and we got two bugs about it already:
https://bugzilla.redhat.com/show_bug.cgi?id=1556890
https://bugzilla.redhat.com/show_bug.cgi?id=1549190

regards,
Nikos


</body></email><email><emailId>20180325081145</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-25 08:11:45-0400</timestampReceived><subject>Re: What should nettle-3.5 be like?</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt;&gt; is a bit strange. Maybe it's missing an #include &lt;nettle/version.h&gt; ?
&gt;
&gt; That's very strange. bignum.h already includes version.h, so that
&gt; should have been ok. I've also explicitly added it and re-run with the
&gt; same results:
&gt; https://gitlab.com/gnutls/nettle/-/jobs/58340605

I'll try reproducing locally.

I hade a quick look at the config.log for clues. I noticed that the test 

if test "$enable_non_suiteb" = "yes";then
	dnl nettle_secp_192r1 is not really a function
	AC_CHECK_LIB(hogweed, nettle_secp_192r1, enable_non_suiteb=yes,	enable_non_suiteb=no, [$HOGWEED_LIBS])

fails, but that's an unrelated problem.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180325083707</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-25 08:37:07-0400</timestampReceived><subject>Re: What should nettle-3.5 be like?</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt;
&gt;&gt;&gt; is a bit strange. Maybe it's missing an #include &lt;nettle/version.h&gt; ?
&gt;&gt;
&gt;&gt; That's very strange. bignum.h already includes version.h, so that
&gt;&gt; should have been ok. I've also explicitly added it and re-run with the
&gt;&gt; same results:
&gt;&gt; https://gitlab.com/gnutls/nettle/-/jobs/58340605
&gt;
&gt; I'll try reproducing locally.

It turns out it was a typo, with below fix, compilation works fine:

--- a/lib/nettle/pk.c
+++ b/lib/nettle/pk.c
@@ -1062,7 +1062,7 @@ _wrap_nettle_pk_verify(gnutls_pk_algorithm_t algo,
 	return ret;
 }
 
-#if NETTLE_MAJOR_VERSION &lt; 3 || (NETTLE_MAJOR_VERSION == 3 &amp;&amp; NETTLE_MINOR_VERSION &lt; 4)
+#if NETTLE_VERSION_MAJOR &lt; 3 || (NETTLE_VERSION_MAJOR == 3 &amp;&amp; NETTLE_VERSION_MINOR &lt; 4)
 # ifdef ENABLE_NON_SUITEB_CURVES
 #  define nettle_get_secp_192r1() &amp;nettle_secp_192r1
 #  define nettle_get_secp_224r1() &amp;nettle_secp_224r1

The compilation flag -Wundef would have caught this. 

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180325182129</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-03-25 18:21:29-0400</timestampReceived><subject>Re: What should nettle-3.5 be like?</subject><body>

On Sun, 2018-03-25 at 10:37 +0200, Niels Möller wrote:
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt; &gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt; &gt; 
&gt; &gt; &gt; &gt; is a bit strange. Maybe it's missing an #include
&gt; &gt; &gt; &gt; &lt;nettle/version.h&gt; ?
&gt; &gt; &gt; 
&gt; &gt; &gt; That's very strange. bignum.h already includes version.h, so that
&gt; &gt; &gt; should have been ok. I've also explicitly added it and re-run
&gt; &gt; &gt; with the
&gt; &gt; &gt; same results:
&gt; &gt; &gt; https://gitlab.com/gnutls/nettle/-/jobs/58340605
&gt; &gt; 
&gt; &gt; I'll try reproducing locally.
&gt; 
&gt; It turns out it was a typo, with below fix, compilation works fine:
&gt; 
&gt; --- a/lib/nettle/pk.c
&gt; +++ b/lib/nettle/pk.c
&gt; @@ -1062,7 +1062,7 @@ _wrap_nettle_pk_verify(gnutls_pk_algorithm_t
&gt; algo,
&gt;  	return ret;
&gt;  }
&gt;  
&gt; -#if NETTLE_MAJOR_VERSION &lt; 3 || (NETTLE_MAJOR_VERSION == 3 &amp;&amp;
&gt; NETTLE_MINOR_VERSION &lt; 4)
&gt; +#if NETTLE_VERSION_MAJOR &lt; 3 || (NETTLE_VERSION_MAJOR == 3 &amp;&amp;
&gt; NETTLE_VERSION_MINOR &lt; 4)
&gt;  # ifdef ENABLE_NON_SUITEB_CURVES
&gt;  #  define nettle_get_secp_192r1() &amp;nettle_secp_192r1
&gt;  #  define nettle_get_secp_224r1() &amp;nettle_secp_224r1

Thank you. I've committed a fix at:
https://gitlab.com/gnutls/gnutls/merge_requests/614

&gt; The compilation flag -Wundef would have caught this. 

I have never tried it, but it looks easy to fail on legal scenarios. If
for example we compile with any version of nettle 3.1 or later (3.1 
doesn't have version.h), that macro would make it fail. Extrapolating
it to more dependencies would make a valid run extremely likely to fail
compilation.

regards,
Nikos


</body></email><email><emailId>20180325192208</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-03-25 19:22:08-0400</timestampReceived><subject>Re: What should nettle-3.5 be like?</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Thank you. I've committed a fix at:
&gt; https://gitlab.com/gnutls/gnutls/merge_requests/614

Good. And you'll trigger a new test run when it's in?

&gt;&gt; The compilation flag -Wundef would have caught this. 
&gt;
&gt; I have never tried it, but it looks easy to fail on legal scenarios. If
&gt; for example we compile with any version of nettle 3.1 or later (3.1 
&gt; doesn't have version.h),

I'm not sure how hard it would be to migrate to building with -Wundef (I
haven't yet tried it in Nettle or any of my own projects). But it's of
course still possible check if a preprocessor symbol is defined, one
just has to use #ifdef FOO or #if defined(FOO) where appropriate.

I think it's very rare that the implicit expansion of undefined symbols
to 0 (in the context of the preprocessor evaluating the value of an
#if) really is important or desired.

A potential problem is the conventions around autoconf AC_DEFINE, where
symbols are usually either undefined or defined with the value 1. So
with -Wundef, I think one would need to use

  #ifdef HAVE_FOO 

rahter than 

  #if HAVE_FOO

(unless there's some recent features to change config.h convention, to
always define the symbols, to 0 or 1 depending on corresponding test).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180326102359</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-03-26 10:23:59-0400</timestampReceived><subject>Re: What should nettle-3.5 be like?</subject><body>

On Sun, 2018-03-25 at 21:22 +0200, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt; 
&gt; &gt; Thank you. I've committed a fix at:
&gt; &gt; https://gitlab.com/gnutls/gnutls/merge_requests/614
&gt; 
&gt; Good. And you'll trigger a new test run when it's in?

Yes. It is at:
https://gitlab.com/gnutls/nettle/-/jobs/59417145

and seems to pass. Thank you.

regards,
Nikos


</body></email><email><emailId>20180201200512</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-01 20:05:12-0400</timestampReceived><subject>Re: Performance of AESNI impl vs other crypto libraries</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; It seems that ctr_crypt16() would not handle the whole input and that
&gt; was complicating things. I've modified it towards that, and added the
&gt; parameter. I did a gcm_fill(), but I didn't see the need for the
&gt; nettle_block16 update, as the version I did (quite simplistic), didn't
&gt; seem to differ in performance comparing to ctr_fill16.

I've applied first part with some reorganization. ctr-internal.h now
declares 

  /* Fill BUFFER (n blocks) with incrementing CTR values. It would be
     nice if CTR was always 64-bit aligned, but it isn't when called
     from ctr_crypt. */
  typedef void
  nettle_fill16_func(uint8_t *ctr, size_t n, union nettle_block16 *buffer);
  
  void
  _ctr_crypt16(const void *ctx, nettle_cipher_func *f,
  	     nettle_fill16_func *fill, uint8_t *ctr,
  	     size_t length, uint8_t *dst,
  	     const uint8_t *src);

And I moved the implementation to a separate file ctr16.c.

Your change to gcm.c is then applied almost unchanged on top of that.
Result pushed to a branch named "gcm-ctr-opt". On my machine, it gives a
gcm_aes128 speedup of 54% (from 12.2 cycles/byte to 7.9).

Very nice! Needs a little testing on big-endian before merge to master.

Thanks,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180208071632</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-02-08 07:16:32-0400</timestampReceived><subject>Re: easier version checks</subject><body>

On Wed, 2018-02-07 at 21:53 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; 
&gt; &gt; What about extending the macros in version.h with a simple to use
&gt; &gt; combined version number?
&gt; 
&gt; I think I'd prefer to leave that out. The formatting is very
&gt; arbitrary, and any
&gt; application which needs it can 
&gt; 
&gt; #define NETTLE_COMBINED_VERSION \
&gt;   ((NETTLE_VERSION_MAJOR &lt;&lt; 16) + NETTLE_VERSION_MINOR).
&gt; 
&gt; or
&gt; 
&gt; #define NETTLE_AT_LEAST(major, minor) \
&gt;   ((NETTLE_VERSION_MAJOR &lt;&lt; 16) + NETTLE_VERSION_MINOR \
&gt;    &gt;= (((major) &lt;&lt; 16) + (minor)))

I'm fine with them also. Should we put them in version.h?


regards,
Nikos


</body></email><email><emailId>20180208215525</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-08 21:55:25-0400</timestampReceived><subject>[Jeffrey Walton] Fwd: x86 sha_ni</subject><body>

Forwarded to the list.

---------- Forwarded message ----------
From: Jeffrey Walton &lt;noloader@gmail.com&gt;
To: "Niels Möller" &lt;nisse@lysator.liu.se&gt;
Cc: nettle-bugs@lists.lysator.liu.se
Bcc:
Date: Thu, 8 Feb 2018 16:34:43 -0500
Subject: Re: x86 sha_ni
On Thu, Feb 8, 2018 at 12:18 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt; Below replacement for sha1-compress.asm seems to run on roughly 2
&gt;&gt; cycles/byte when I benchmark it on an "AMD Ryzen 7 1700X" cpu in the gcc
&gt;&gt; compile farm. Still sligthly slower than openssl, to squeeze out a few
&gt;&gt; more cycles, it might help to change the sha1_compress interface to let
&gt;&gt; it process more than one 64-byte block at a time.
&gt;&gt;
&gt;&gt; I hope to be able to wire it up via fat-x86_64.c reasonably soon. In the
&gt;&gt; mean time, if anyone wants to try it out, just change the
&gt;&gt; sha1-compress.asm symlink to point to this file.
&gt;
&gt; Enabled via fat-x86_64 now, and pushed to a branch named
&gt; x86_64-sha_ni-sha1.

Looks good on a Celeron J3455, which is a [low-end] Goldmont machine
with the instructions:

goldmont:nettle$ autoreconf -f -i
...

goldmont:nettle$ ./configure --enable-fat
...

goldmont:nettle$ make &amp;&amp; make check
...

goldmont:nettle$ LD_LIBRARY_PATH=.lib:/usr/local/lib64/
./examples/nettle-benchmark
sha1_compress: 84.60 cycles
salsa20_core: 282.80 cycles
sha3_permute: 1542.60 cycles (64.27 / round)

benchmark call overhead: 0.001604 us
         Algorithm         mode Mbyte/s
           ...

               md2       update    6.90
               md4       update  568.11
               md5       update  384.08
       openssl md5       update  443.76
              sha1       update 1194.33
      openssl sha1       update 1321.71
            sha224       update  110.31
            sha256       update  110.10
            sha384       update  174.32
            sha512       update  173.99
        sha512-224       update  174.35
        sha512-256       update  174.16
          sha3_224       update  136.77
          sha3_256       update  129.46
          sha3_384       update   99.23
          sha3_512       update   69.25
         ripemd160       update  161.00
        gosthash94       update   39.48
            umac32       update 6560.05
            umac64       update 3130.26
            umac96       update 2457.21
           umac128       update 1936.56
      poly1305-aes       update  914.79
           ...

A small suggestion may be to update Section 8 Installation
(https://www.lysator.liu.se/~nisse/nettle/nettle.html). It was not
obvious to me how to enable the hardware acceleration. A quick
sentence on how to enable AES-NI and SHA would make it obvious for
future readers. (Thanks for the offline help).

Jeff

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20180213211027</emailId><senderName>Michael Weiser</senderName><senderEmail>michael@weiser.dinsnail.net</senderEmail><timestampReceived>2018-02-13 21:10:27-0400</timestampReceived><subject>Re: Miscomputation with big-endian arm asm</subject><body>

Hi Niels,

On Mon, Feb 12, 2018 at 08:59:16AM +0100, Niels Möller wrote:

&gt; &gt; Right. When this still didn't fix it, I compared little- and big-endian
&gt; &gt; behaviour and found that a.) vldm and vstm switch doublewords for no
&gt; &gt; reason I can see or find documentation about and b.) 
&gt; By "doublewords", you mean 64-bit words, right?

Yes. ARM talks in bytes, halfwords, words, doublewords and quadwords.

&gt; It might make sense to view it as big-endian or little-endian load of
&gt; 128-bit values, and a 128-bit (16-byte) byte swap will then also swap
&gt; the low and high 64-bit halves.
[...]
&gt; If it's hard to find docs, I take it as a sign big-endian arm is a bit
&gt; obscure...

Actually, it's all quite well-documented, just not always as obviously
as I'd like: The ARM ARM (Architecture Reference Manual) spells out the
low-level details. With additionally looking very closely at the gdb
output, I found for the chacha and salsa implementations:

1. There's no vldm or vstm on quadword registers in the architecture. It
gets translated into vldm on the corresponding number of doubleword
registers.

Disassembly of section .text:

00000000 &lt;_nettle_chacha_core&gt;:
   0:   ec910b10        vldmia  r1, {d0-d7}

This is hinted at here
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Bcfchhif.html
by saying: "If Q registers are specified, on disassembly they are shown
as D registers."

2. vldm and vstm on doubleword registers swap 32-bit words inside the
doubleword to get a full byte-swap in addition to the byte- and
halfword-swapping the word-access already does. Since chacha and salsa
input is a matrix of 32-bit words, the word swap transposes even and odd
columns (not doublewords):

// Combine the word-aligned words in the correct order for current endianness. 
D[d+r] = if BigEndian() then word1:word2 else word2:word1; 

3. The input to chacha-core is 32bit words in host endianness.

4. gdb's print output ordering is really confusing.

So all that's basically happening is that odd and even columns get
switched. The individual words' values are exactly the same because the
input is in host endianness already. So NEON doesn't adjust for
endianness after all.

What's been fooling me is that apparently gdb tries to show the values
of vector registers as if they had been stored to memory by an operation
of the full bit-size of the register shown and then read back again as
consecutive elements of various other sizes (8, 16, 32, 64-bit):

p/x $q0
le: u8 = {0x65, 0x78, 0x70, 0x61, 0x6e, 0x64, 0x20, 0x33, 0x32, 0x2d, 0x62, 0x79, \
                0x74, 0x65, 0x20, 0x6b}
be: u8 = {0x79, 0x62, 0x2d, 0x32, 0x6b, 0x20, 0x65, 0x74, 0x61, 0x70, 0x78, 0x65, \
0x33, 0x20, 0x64, 0x6e}  ^ bytes reversed by 128-bit store + read as byte sequence -&gt; \
vldm 1:0:3:2 column swap still visible

le: u32 = {0x61707865, 0x3320646e, 0x79622d32, 0x6b206574}
be: u32 = {0x79622d32, 0x6b206574, 0x61707865, 0x3320646e}
	   ^ bytes reversed by 128-bit store + read as four consecutive
big-endian 32-bit words + vldm column swap -&gt; makes it appear
doublewords have been swapped

The realisation that even and odd columns get switched also explains the
necessary vext adjustments. So it's also not true that vext changes the
end of the vector where it extracts.

Regarding umac it's similar: vld1.8 loads a byte sequence from memory
without any swapping with either le or be. vld1.i32 reads the keys
stored in host endianness as words from memory. So the representation
ending up in the registers is the same as well which is why the code
doesn't need any adjustment.

Finally, the register switch for the return value with vmov in umac-nh
stems from the calling convention. AAPCS says:

"Fundamental types larger than 32 bits may be passed as parameters to, or
returned as the result of, function calls. When these types are in core
registers the following rules apply:
* A doubleword sized type is passed in two consecutive registers (e.g.,
r0 and r1, or r2 and r3). The content of the registers is as if the
value had been loaded from memory representation with a single LDM
instruction."

When loading a big-endian doubleword using ldm, the words end up in the
registers with the right values but transposed. Since the calling
convention mandates exactly this, we have to transpose the words upon
function exit as well.

Phew.

&gt; Could you add a short note to arm/README with your findings?
&gt; (It's quite some time since I did neon assembly, so I don't recall off
&gt; the top of my head any details on what the various instructions, in
&gt; particular vextr, do).

Done.

&gt; &gt; FAIL: sexp-conv
&gt; &gt; FAIL: nettle-pbkdf2
&gt; &gt; They've been failing all along. Can they be ignored?
&gt; They're not that relevant to your changes, but I'd like to understand
&gt; why they fail. What's the contents of the tools dir in your buld tree?
&gt; You haven't done something like switched from building in the source
&gt; tree build to a separate build tree, without a proper cleaning (make
&gt; distclean) in the source tree?

No. But I have been ignoring an annoying build failure due to TeX being
missing. After reconfiguring with --disable-documentation build and
testsuite succeed. My bad.

&gt; &gt; Weeell, depends on what you consider easier: I haven't found any binary
&gt; &gt; distribution that supports armeb. Yocto and buildroot seem to support it
&gt; &gt; but still require compiling the whole thing.
&gt; Hmm. Sounds more than a bit inconvenient.

The qemu-user chroot route with the linaro cross toolchain isn't too bad
actually:

cd $HOME/gcc-linaro-7.2.1-2017.11-x86_64_armeb-linux-gnueabihf/armeb-linux-gnueabihf/libc
 cp /usr/bin/qemu-armeb-static usr/bin
wget https://gmplib.org/download/gmp/gmp-6.1.2.tar.lz
tar -xf gmp-6.1.2.tar.lz
cd gmp-6.1.2
# segfaults in qemu with -march=armv4 default
PATH=$PWD/../../../bin:$PATH CFLAGS="-march=armv7-a" ./configure \
--host=armeb-linux-gnueabihf --prefix=$PWD/../gmp PATH=$PWD/../../../bin:$PATH make \
-j4 install

git clone https://git.lysator.liu.se/nettle/nettle.git
cd nettle
autoreconf
PATH=$PWD/../../../bin:$PATH ./configure --host=armeb-linux-gnueabihf \
--enable-arm-neon --with-include-path=$PWD/../gmp/include \
--with-lib-path=$PWD/../gmp/lib PATH=$PWD/../../../bin:$PATH make -j4
NETTLE_TEST_ROOT=/nettle/testsuite PATH=$PWD/../../../bin:$PATH make -j4 check \
EMULATOR="sudo QEMU_SET_ENV=LD_LIBRARY_PATH=/nettle/.lib:/gmp/lib chroot $PWD/.."

with this small patch to run-tests:
diff --git a/run-tests b/run-tests
index 3d5655cf..bbc2bb4c 100755
--- a/run-tests
+++ b/run-tests
@@ -37,7 +37,7 @@ find_program () {
          ;;
        *)
          if [ -x "$1" ] ; then
-             echo "./$1"
+             echo "${NETTLE_TEST_ROOT:=.}/$1"
          else
              echo "$srcdir/$1"
          fi


&gt; &gt; Apple does do arm and someone could potentially want to build a fat
&gt; &gt; nettle that supports x86_64 and arm or rather arm and arm64.
&gt; My concern is not breaking any setup which currently works, e.g, a non
&gt; assebly "universal" build involving architectures with different
&gt; endianness.

Right, that should be fine then.

&gt; &gt; Does nettle currently support being compiled fat with assembly at all?
&gt; I don't think so. I'd expect one would have to build for one arch at a
&gt; time, and have some postprocessing scripts to produce apple-fat
&gt; libraries.

Apple have wrapped this in the compiler driver using multiple -arch
arguments. "gcc -arch x86_64 -arch arm" will run the compiler twice on
the same file and lipo the resulting objects together into a fat object.
The linker supports linking those into fat binaries.

If all the assembler implementations of the same routine were in one
file wrapped by #ifdefs the same could be done there. Otherwise,
assembly and lipoing would have to be done explicitly for those files.

# clang -v -arch x86_64 -arch i386 -c -o t.o t.c
[...]
Apple LLVM version 9.0.0 (clang-900.0.39.2)
Target: i386-apple-darwin17.4.0
Thread model: posix
InstalledDir: /Library/Developer/CommandLineTools/usr/bin
 "/Library/Developer/CommandLineTools/usr/bin/clang" -cc1 -triple
x86_64-apple-macosx10.13.0 ...
[...]
 "/Library/Developer/CommandLineTools/usr/bin/clang" -cc1 -triple
i386-apple-macosx10.13.0 ...
[...]
"/Library/Developer/CommandLineTools/usr/bin/lipo" -create -output t.o
/var/folders/ft/dp06pw254ybbzt42f1qn65pm0000gp/T/t-5eeded.o
/var/folders/ft/dp06pw254ybbzt42f1qn65pm0000gp/T/t-b25776.o
# file t.o
t.o: Mach-O universal binary with 2 architectures: [x86_64:Mach-O 64-bit
object x86_64] [i386:Mach-O object i386]
t.o (for architecture x86_64):	Mach-O 64-bit object x86_64
t.o (for architecture i386):	Mach-O object i386

&gt; &gt; But then I want to have a nice error message so as to not leave the user
&gt; &gt; with an aborted build and no apparent reason. :) Is this portable?
&gt; According to
&gt; http://pubs.opengroup.org/onlinepubs/9699919799/utilities/m4.html,
&gt; errprint and m4exit are standard m4. (If they're also supported in
&gt; practice is a different question, it's desirable to at least work with
&gt; both GNU and BSD m4). If __file__ and __line__ are unportable, you could
&gt; omit that. Since the error message reports a pretty global config
&gt; problem, precise location isn't that important.

Not critical, __file__ and __line__ dropped. Net/Free/OpenBSD m4
support them though.

&gt; &gt; The patch got quite large now. Should I better make a series out of it?
&gt; As you prefer, I think it is workable as is. It might help to split out
&gt; the configure-related changes.

Series forthcoming.
-- 
Thanks,
Michael


</body></email><email><emailId>20180216091731</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-02-16 09:17:31-0400</timestampReceived><subject>RFC: SIV-CMAC interface [was: API for new AEAD modes]</subject><body>

On Sat, 2018-01-27 at 09:57 +0100, Nikos Mavrogiannopoulos wrote:

&gt; &gt; 
&gt; 
&gt; But then when would generate the actual IV? When data are added
&gt; gradually, one would have to require order in the calling of
&gt; functions,
&gt; to ensure that one would generate the IV to be used by the encryption
&gt; functions. For  example require
&gt; 
&gt; siv_aes128_cmac_set_key
&gt; siv_aes128_cmac_extra_adata
&gt; siv_aes128_cmac_extra_adata
&gt; siv_aes_128_cmac_set_nonce (must be last and must be called even if
&gt; there is no nonce, and will generate and save the IV)
&gt; siv_aes128_cmac_decrypt (which will use the saved in ctx IV)
&gt; 
&gt; or
&gt; 
&gt; siv_aes128_cmac_set_key
&gt; siv_aes128_cmac_extra_adata
&gt; siv_aes128_cmac_extra
&gt; _adata
&gt; siv_aes_128_cmac_set_nonce
&gt; siv_aes_128_cmac_get_iv
&gt; siv_aes128_cmac_
&gt; decrypt (which will use the provided in param IV)
&gt; 
&gt; I'm also not sure how to check the tag? Make
&gt; siv_aes128_cmac_decrypt()
&gt; check it and return an int, or provide a digest function which will
&gt; return the generated IV and let the caller do something with it?
&gt; 
&gt; Shouldn't the siv_aes128_cmac_extra_adata be named
&gt; siv_aes128_cmac_update? (though its semantics would be different from
&gt; other AEAD ciphers as updating with "ab" is different than two calls
&gt; with "a" and "b").
&gt; 
&gt; Overall, the more I look how a low level API for SIV would look like,
&gt; the more I think of having only a high level one.

I've gave up on my attempts for a low-level mode as they were resulting
to a very complex to use interface when following nettle conventions,
or a very unique interface when trying to capture SIV-CMAC intentions.

Thus, I'm sending an RFC for a high level SIV-CMAC interface with an
abstraction function set, which abstract on the cipher. The cipher is
then used for both CTR encryption and CMAC.
(Initially I tried abstracting over cipher and MAC, which caused a very
complex interface, such as functions with 13+ parameters).

That abstraction seems to have a cost on safety as in _siv_s2v()
function I simulated the cipher context using an array. Is there a
better way to capture that on nettle?

This patch works on top of the proposed CMAC interface.

regards,
Nikos

["0001-Added-support-for-AES_SIV_CMAC_256-and-AES_SIV_CMAC_.patch" (0001-Added-support-for-AES_SIV_CMAC_256-and-AES_SIV_CMAC_.patch)]

From 4798372c92332c3637048523a12052abea85b831 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Sat, 20 Jan 2018 10:36:05 +0100
Subject: [PATCH] Added support for AES_SIV_CMAC_256 and AES_SIV_CMAC_512

This AEAD algorithm provides a way to make nonce-reuse a not critical
issue. That is particular useful to stateless servers that cannot ensure
that the nonce will not repeat. It is used by draft-ietf-ntp-using-nts-for-ntp-10.

Only a high level interface is provided.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
---
 Makefile.in                |   4 +-
 cmac-internal.h            |  54 ++++++++
 cmac.c                     |   9 +-
 nettle-internal.h          |   2 +
 nettle-types.h             |  15 ++
 nettle.texinfo             |  82 ++++++++++-
 siv-aes128-cmac.c          |  79 +++++++++++
 siv-aes256-cmac.c          |  79 +++++++++++
 siv-cmac.c                 | 190 ++++++++++++++++++++++++++
 siv-cmac.h                 | 139 +++++++++++++++++++
 testsuite/.test-rules.make |   3 +
 testsuite/Makefile.in      |   2 +-
 testsuite/siv-test.c       | 332 +++++++++++++++++++++++++++++++++++++++++++++
 13 files changed, 983 insertions(+), 7 deletions(-)
 create mode 100644 cmac-internal.h
 create mode 100644 siv-aes128-cmac.c
 create mode 100644 siv-aes256-cmac.c
 create mode 100644 siv-cmac.c
 create mode 100644 siv-cmac.h
 create mode 100644 testsuite/siv-test.c

diff --git a/Makefile.in b/Makefile.in
index de12bb3f..b4101de2 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -89,6 +89,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 camellia256-meta.c \
 		 cast128.c cast128-meta.c cbc.c \
 		 ccm.c ccm-aes128.c ccm-aes192.c ccm-aes256.c cfb.c \
+		 siv-cmac.c siv-aes128-cmac.c siv-aes256-cmac.c \
 		 chacha-crypt.c chacha-core-internal.c \
 		 chacha-poly1305.c chacha-poly1305-meta.c \
 		 chacha-set-key.c chacha-set-nonce.c \
@@ -193,7 +194,8 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  gcm.h gosthash94.h hmac.h \
 	  knuth-lfib.h hkdf.h \
 	  macros.h \
-	  cmac.h \
+	  cmac.h cmac-internal.h \
+	  siv-cmac.h siv-cmac-internal.h \
 	  md2.h md4.h \
 	  md5.h md5-compat.h \
 	  memops.h memxor.h \
diff --git a/cmac-internal.h b/cmac-internal.h
new file mode 100644
index 00000000..789588e6
--- /dev/null
+++ b/cmac-internal.h
@@ -0,0 +1,54 @@
+/* cmac.h
+
+   CMAC mode internal functions
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   Contributed by Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_CMAC_INTERNAL_H_INCLUDED
+#define NETTLE_CMAC_INTERNAL_H_INCLUDED
+
+#include "cmac.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define _cmac128_block_mulx _nettle_cmac128_block_mulx
+
+void _cmac128_block_mulx(union nettle_block16 *out,
+			 const union nettle_block16 *in);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CMAC_INTERNAL_H_INCLUDED */
diff --git a/cmac.c b/cmac.c
index 95d45de4..4d124e7e 100644
--- a/cmac.c
+++ b/cmac.c
@@ -44,6 +44,7 @@
 
 #include "memxor.h"
 #include "nettle-internal.h"
+#include "cmac-internal.h"
 #include "macros.h"
 
 static const uint8_t const_zero[] = {
@@ -52,8 +53,8 @@ static const uint8_t const_zero[] = {
 };
 
 /* shift one and XOR with 0x87. */
-static inline void block_mulx(union nettle_block16 *dst,
-			      const union nettle_block16 *src)
+void _cmac128_block_mulx(union nettle_block16 *dst,
+			 const union nettle_block16 *src)
 {
 	uint64_t b1 = READ_UINT64(src-&gt;b);
 	uint64_t b2 = READ_UINT64(src-&gt;b+8);
@@ -77,8 +78,8 @@ void cmac128_set_key(struct cmac128 *ctx, void *cipher,
 	/* step 1 - generate subkeys k1 and k2 */
 	encrypt(cipher, 16, L-&gt;b, const_zero);
 
-	block_mulx(&amp;ctx-&gt;K1, L);
-	block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
+	_cmac128_block_mulx(&amp;ctx-&gt;K1, L);
+	_cmac128_block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
 }
 
 #define MIN(x,y) ((x)&lt;(y)?(x):(y))
diff --git a/nettle-internal.h b/nettle-internal.h
index 0b0d25c9..bc8e1df7 100644
--- a/nettle-internal.h
+++ b/nettle-internal.h
@@ -57,6 +57,8 @@
 #define NETTLE_MAX_HASH_CONTEXT_SIZE (sizeof(struct sha3_224_ctx))
 #define NETTLE_MAX_SEXP_ASSOC 17
 #define NETTLE_MAX_CIPHER_BLOCK_SIZE 32
+/* maximum context size of 128-bit block ciphers */
+#define NETTLE_MAX_CIPHER16_CONTEXT_SIZE (sizeof(struct aes256_ctx))
 
 /* Doesn't quite fit with the other algorithms, because of the weak
  * keys. Weak keys are not reported, the functions will simply crash
diff --git a/nettle-types.h b/nettle-types.h
index f04655d6..1828ca43 100644
--- a/nettle-types.h
+++ b/nettle-types.h
@@ -64,6 +64,21 @@ typedef void *nettle_realloc_func(void *ctx, void *p, size_t \
length);  /* Ciphers */
 typedef void nettle_set_key_func(void *ctx, const uint8_t *key);
 
+/* AEAD ciphers */
+typedef void
+nettle_encrypt_message(void *ctx,
+		       size_t nlength, const uint8_t *nonce,
+		       size_t alength, const uint8_t *adata,
+		       size_t tlength,
+		       size_t clength, uint8_t *dst, const uint8_t *src);
+
+typedef int
+nettle_decrypt_message(void *ctx,
+		       size_t nlength, const uint8_t *nonce,
+		       size_t alength, const uint8_t *adata,
+		       size_t tlength,
+		       size_t mlength, uint8_t *dst, const uint8_t *src);
+
 /* For block ciphers, const context. */
 typedef void nettle_cipher_func(const void *ctx,
 				size_t length, uint8_t *dst,
diff --git a/nettle.texinfo b/nettle.texinfo
index bfc97b5e..13de5cde 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -96,6 +96,7 @@ Cipher modes
 * CFB and CFB8::
 * GCM::                         
 * CCM::                         
+* SIV-CMAC::
 
 Keyed Hash Functions
 
@@ -2329,6 +2330,7 @@ more adventurous alternative, in particular if performance is \
                important.
 * GCM::                         
 * CCM::                         
 * ChaCha-Poly1305::
+* SIV-CMAC::
 * nettle_aead abstraction::
 @end menu
 
@@ -2976,7 +2978,7 @@ These are identical to @code{ccm_encrypt_message} and \
@code{ccm_decrypt_message}  except that @var{cipher} and @var{f} are replaced with a \
context structure.  @end deftypefun
 
-@node ChaCha-Poly1305, nettle_aead abstraction, CCM, Authenticated encryption
+@node ChaCha-Poly1305, SIV-CMAC, CCM, Authenticated encryption
 @comment  node-name,  next,  previous,  up
 @subsection ChaCha-Poly1305
 
@@ -3059,6 +3061,84 @@ smaller than @code{CHACHA_POLY1305_DIGEST_SIZE}, only the \
first  @var{length} octets of the digest are written.
 @end deftypefun
 
+@node SIV-CMAC, nettle_aead abstraction, ChaCha-Poly1305, Authenticated encryption
+@comment  node-name,  next,  previous,  up
+@subsection Counter with CBC-MAC mode
+
+@cindex SIV mode
+@cindex SIV-CMAC mode
+
+@acronym{SIV-CMAC} mode is a combination of counter mode with message
+authentication based on @acronym{CMAC}. Unlike other counter @acronym{AEAD}
+modes, it provides protection against accidental nonce misuse, making it
+a good choice for stateless-servers that cannot ensure nonce uniqueness.
+It is constructed on top of a block cipher which must have a block size of
+128 bits. Nettle's support for @acronym{SIV-CMAC} consists of
+a message encryption and authentication interface,
+for @acronym{SIV-CMAC} using AES as the underlying
+block cipher. These interfaces are defined in @file{&lt;nettle/siv-cmac.h&gt;}.
+
+Unlike other @acronym{AEAD} mode in @acronym{SIV-CMAC} the initialization
+vector serves as the tag. That means that in the generated ciphertext
+the tag precedes the ciphertext.
+
+@subsubsection General interface
+
+@defvr Constant SIV_BLOCK_SIZE
+@acronym{SIV-CMAC}'s block size, 16.
+@end defvr
+
+@defvr Constant SIV_DIGEST_SIZE
+Size of the @acronym{SIV-CMAC} digest or initialization vector, 16.
+@end defvr
+
+@defvr Constant SIV_MIN_NONCE_SIZE
+The the minimumsizes for an @acronym{SIV-CMAC} nonce, 0
+@end defvr
+
+@subsubsection @acronym{SIV-CMAC}-@acronym{AES} interface
+
+The @acronym{AES} @acronym{SIV-CMAC} functions provide an API for using
+@acronym{SIV-CMAC} mode with the @acronym{AES} block ciphers. The parameters
+all have the same meaning as the general and message interfaces, except
+that the @var{cipher}, @var{f}, and @var{ctx} parameters are replaced
+with an @acronym{AES} context structure, and a set-key function must be
+called before using any of the other functions in this interface.
+
+@deftp {Context struct} {struct siv_aes128_cmac_ctx}
+Holds state corresponding to a particular message encrypted using the
+AES-128 block cipher.
+@end deftp
+
+@deftp {Context struct} {struct siv_aes256_cmac_ctx}
+Holds state corresponding to a particular message encrypted using the
+AES-256 block cipher.
+@end deftp
+
+@deftypefun void siv_aes128_cmac_set_key (struct siv_aes128_cmac_ctx *@var{ctx}, \
const uint8_t *@var{key}) +@deftypefunx void siv_aes256_cmac_set_key (struct \
siv_aes256_cmac_ctx *@var{ctx}, const uint8_t *@var{key}) +Initializes the encryption \
key for the AES block cipher. One of these +functions must be called before any of \
the other functions in the +@acronym{AES} @acronym{SIV-CMAC} interface.
+@end deftypefun
+
+@deftypefun void siv_aes128_cmac_encrypt_message (struct siv_aes128_cmac_ctx \
*@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, \
const uint8_t *@var{adata}, size_t @var{tlength}, size_t @var{clength}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +@deftypefunx void \
siv_aes256_cmac_encrypt_message (struct siv_aes256_cmac_ctx *@var{ctx}, size_t \
@var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, const uint8_t \
*@var{adata}, size_t @var{tlength}, size_t @var{clength}, uint8_t *@var{dst}, const \
uint8_t *@var{src}) +Computes the message digest from the @var{adata} and @var{src}
+parameters, encrypts the plaintext from @var{src}, prepends the
+initialization vector to the ciphertext and outputs it to @var{dst}.
+@end deftypefun
+
+@deftypefun int siv_aes128_cmac_decrypt_message (struct siv_aes128_cmac_ctx \
*@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, \
const uint8_t *@var{adata}, size_t @var{tlength}, size_t @var{mlength}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +@deftypefunx int \
siv_aes256_cmac_decrypt_message (struct siv_aes128_cmac_ctx *@var{ctx}, size_t \
@var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, const uint8_t \
*@var{adata}, size_t @var{tlength}, size_t @var{mlength}, uint8_t *@var{dst}, const \
uint8_t *@var{src}) +Decrypts the ciphertext from @var{src}, outputs the plaintext to
+@var{dst}, recalculates the initialization vector from @var{adata} and the
+plaintext, and compares it to the final @var{tlength} bytes of
+@var{src}. If the values of the received and calculated initialization vector
+are equal, this will return 1 indicating a valid and authenticated
+message. Otherwise, this function will return zero.
+@end deftypefun
+
 @node nettle_aead abstraction, , ChaCha-Poly1305, Authenticated encryption
 @comment  node-name,  next,  previous,  up
 @subsection The @code{struct nettle_aead} abstraction
diff --git a/siv-aes128-cmac.c b/siv-aes128-cmac.c
new file mode 100644
index 00000000..2acfc9a5
--- /dev/null
+++ b/siv-aes128-cmac.c
@@ -0,0 +1,79 @@
+/* siv-aes128.c
+
+   AES-SIV, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "aes.h"
+#include "siv-cmac.h"
+#include "cmac.h"
+#include "ctr.h"
+#include "memxor.h"
+#include "memops.h"
+#include "cmac-internal.h"
+
+void
+siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const uint8_t *key)
+{
+  siv_cmac_set_key(&amp;ctx-&gt;siv_cmac, &amp;ctx-&gt;cipher, &amp;nettle_aes128, key);
+}
+
+void
+siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t tlength,
+				size_t slength, uint8_t *dst, const uint8_t *src)
+{
+  assert(tlength == SIV_DIGEST_SIZE);
+  siv_cmac_encrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes128, &amp;ctx-&gt;cipher,
+			   nlength, nonce, alength, adata,
+			   slength, dst, src);
+}
+
+int
+siv_aes128_cmac_decrypt_message(struct siv_aes128_cmac_ctx *ctx,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t tlength,
+			 size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  assert(tlength == SIV_DIGEST_SIZE);
+  return siv_cmac_decrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes128, &amp;ctx-&gt;cipher,
+				  nlength, nonce, alength, adata,
+				  mlength, dst, src);
+}
diff --git a/siv-aes256-cmac.c b/siv-aes256-cmac.c
new file mode 100644
index 00000000..c85feebe
--- /dev/null
+++ b/siv-aes256-cmac.c
@@ -0,0 +1,79 @@
+/* siv-aes128.c
+
+   AES-SIV, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "aes.h"
+#include "siv-cmac.h"
+#include "cmac.h"
+#include "ctr.h"
+#include "memxor.h"
+#include "memops.h"
+#include "cmac-internal.h"
+
+void
+siv_aes256_cmac_set_key(struct siv_aes256_cmac_ctx *ctx, const uint8_t *key)
+{
+  siv_cmac_set_key(&amp;ctx-&gt;siv_cmac, &amp;ctx-&gt;cipher, &amp;nettle_aes256, key);
+}
+
+void
+siv_aes256_cmac_encrypt_message(struct siv_aes256_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t tlength,
+				size_t slength, uint8_t *dst, const uint8_t *src)
+{
+  assert(tlength == SIV_DIGEST_SIZE);
+  siv_cmac_encrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes256, &amp;ctx-&gt;cipher,
+			   nlength, nonce, alength, adata,
+			   slength, dst, src);
+}
+
+int
+siv_aes256_cmac_decrypt_message(struct siv_aes256_cmac_ctx *ctx,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t tlength,
+			 size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  assert(tlength == SIV_DIGEST_SIZE);
+  return siv_cmac_decrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes256, &amp;ctx-&gt;cipher,
+				  nlength, nonce, alength, adata,
+				  mlength, dst, src);
+}
diff --git a/siv-cmac.c b/siv-cmac.c
new file mode 100644
index 00000000..46fcd8ab
--- /dev/null
+++ b/siv-cmac.c
@@ -0,0 +1,190 @@
+/* siv-cmac.c
+
+   SIV-CMAC, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "aes.h"
+#include "siv-cmac.h"
+#include "cmac.h"
+#include "ctr.h"
+#include "memxor.h"
+#include "memops.h"
+#include "cmac-internal.h"
+#include "nettle-internal.h"
+
+struct cmac128_syn {
+  struct cmac128 data;
+  struct {
+    uint8_t pad[NETTLE_MAX_CIPHER16_CONTEXT_SIZE];
+  } cipher;
+};
+
+static
+void _siv_s2v(const struct nettle_cipher *nc,
+	      const uint8_t *s2vk, size_t alength, const uint8_t *adata,
+              size_t nlength, const uint8_t *nonce,
+              size_t plength, const uint8_t *pdata,
+              uint8_t *v)
+{
+  struct cmac128_syn ctx;
+  union nettle_block16 D, S, T;
+  const uint8_t const_one[16] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x01
+  };
+  const uint8_t const_zero[16] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
+  };
+
+  assert(nc-&gt;context_size &lt;= NETTLE_MAX_CIPHER16_CONTEXT_SIZE);
+
+  /* ensure we have enough size of context plus any padding size */
+  CMAC128_SET_KEY(&amp;ctx, nc-&gt;set_encrypt_key, nc-&gt;encrypt, s2vk);
+
+  if (nlength == 0 &amp;&amp; alength == 0) {
+    CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, 16, const_one);
+    CMAC128_DIGEST(&amp;ctx, nc-&gt;encrypt, 16, v);
+    return;
+  }
+
+  CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, 16, const_zero);
+  CMAC128_DIGEST(&amp;ctx, nc-&gt;encrypt, 16, D.b);
+
+  if (alength &gt; 0) {
+    _cmac128_block_mulx(&amp;D, &amp;D);
+    CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, alength, adata);
+    CMAC128_DIGEST(&amp;ctx, nc-&gt;encrypt, 16, S.b);
+
+    memxor(D.b, S.b, 16);
+  }
+
+  if (nlength &gt; 0) {
+    _cmac128_block_mulx(&amp;D, &amp;D);
+    CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, nlength, nonce);
+    CMAC128_DIGEST(&amp;ctx, nc-&gt;encrypt, 16, S.b);
+
+    memxor(D.b, S.b, 16);
+  }
+
+  /* Sn */
+  if (plength &gt; 16) {
+    CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, plength-16, pdata);
+
+    pdata += plength-16;
+
+    memxor3(T.b, pdata, D.b, 16);
+  } else {
+    union nettle_block16 pad;
+
+    _cmac128_block_mulx(&amp;T, &amp;D);
+    memcpy(pad.b, pdata, plength);
+    pad.b[plength] = 0x80;
+    if (plength+1 &lt; 16)
+      memset(&amp;pad.b[plength+1], 0, 16-plength-1);
+
+    memxor(T.b, pad.b, 16);
+  }
+
+  CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, 16, T.b);
+  CMAC128_DIGEST(&amp;ctx, nc-&gt;encrypt, 16, v);
+}
+
+void
+siv_cmac_set_key(struct siv_cmac_ctx *ctx, void *cipher,
+		 const struct nettle_cipher *nc,
+		 const uint8_t *key)
+{
+	unsigned skey_size = nc-&gt;key_size;
+
+	assert(skey_size &lt;= SIV_MAX_KEY_SIZE/2);
+	memcpy(ctx-&gt;s2vk, key, skey_size);
+
+	nc-&gt;set_encrypt_key(cipher, key+skey_size);
+}
+
+void
+siv_cmac_encrypt_message(struct siv_cmac_ctx *ctx,
+			 const struct nettle_cipher *nc,
+			 void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t slength, uint8_t *dst, const uint8_t *src)
+{
+	union nettle_block16 siv;
+
+	/* create CTR nonce */
+	_siv_s2v(nc,
+		 ctx-&gt;s2vk, alength, adata,
+		 nlength, nonce, slength, src, siv.b);
+
+	memcpy(dst, siv.b, SIV_DIGEST_SIZE);
+	siv.b[8] &amp;= ~0x80;
+	siv.b[12] &amp;= ~0x80;
+
+	ctr_crypt(cipher, nc-&gt;encrypt, AES_BLOCK_SIZE, siv.b, slength, dst+SIV_DIGEST_SIZE, \
src); +}
+
+int
+siv_cmac_decrypt_message(struct siv_cmac_ctx *ctx,
+			 const struct nettle_cipher *nc,
+			 void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  union nettle_block16 siv;
+  union nettle_block16 ctr;
+
+  assert(mlength &gt; SIV_DIGEST_SIZE);
+
+  memcpy(ctr.b, src, SIV_DIGEST_SIZE);
+  ctr.b[8] &amp;= ~0x80;
+  ctr.b[12] &amp;= ~0x80;
+
+  ctr_crypt(cipher, nc-&gt;encrypt, AES_BLOCK_SIZE, ctr.b,
+            mlength-SIV_DIGEST_SIZE, dst, src+SIV_DIGEST_SIZE);
+
+  /* create CTR nonce */
+  _siv_s2v(nc,
+	   ctx-&gt;s2vk, alength, adata,
+	   nlength, nonce, mlength-SIV_DIGEST_SIZE, dst, siv.b);
+
+  return memeql_sec(siv.b, src, SIV_DIGEST_SIZE);
+}
+
diff --git a/siv-cmac.h b/siv-cmac.h
new file mode 100644
index 00000000..26371b8a
--- /dev/null
+++ b/siv-cmac.h
@@ -0,0 +1,139 @@
+/* siv.h
+
+   AES-SIV, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_SIV_H_INCLUDED
+#define NETTLE_SIV_H_INCLUDED
+
+#include "nettle-types.h"
+#include "nettle-meta.h"
+#include "aes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define siv_cmac_set_key nettle_siv_cmac_set_key
+#define siv_cmac_encrypt_message nettle_siv_cmac_encrypt_message
+#define siv_cmac_decrypt_message nettle_siv_cmac_decrypt_message
+#define siv_aes128_cmac_set_key nettle_siv_aes128_cmac_set_key
+#define siv_aes128_cmac_encrypt_message nettle_siv_aes128_cmac_encrypt_message
+#define siv_aes128_cmac_decrypt_message nettle_siv_aes128_cmac_decrypt_message
+#define siv_aes256_cmac_set_key nettle_siv_aes256_cmac_set_key
+#define siv_aes256_cmac_encrypt_message nettle_siv_aes256_cmac_encrypt_message
+#define siv_aes256_cmac_decrypt_message nettle_siv_aes256_cmac_decrypt_message
+
+/* For SIV, the block size of the block cipher shall be 128 bits. */
+#define SIV_BLOCK_SIZE  16
+#define SIV_DIGEST_SIZE 16
+#define SIV_MIN_NONCE_SIZE 0
+#define SIV_MAX_KEY_SIZE (AES_MAX_KEY_SIZE*2)
+
+struct siv_cmac_ctx {
+    uint8_t s2vk[SIV_MAX_KEY_SIZE/2];
+};
+
+void
+siv_cmac_set_key(struct siv_cmac_ctx *ctx, void *cipher,
+		 const struct nettle_cipher *nc,
+		 const uint8_t *key);
+
+void
+siv_cmac_encrypt_message(struct siv_cmac_ctx *ctx,
+			 const struct nettle_cipher *nc,
+			 void *cipher, 
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t slength, uint8_t *dst, const uint8_t *src);
+
+int
+siv_cmac_decrypt_message(struct siv_cmac_ctx *ctx,
+			 const struct nettle_cipher *nc,
+			 void *cipher, 
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src);
+
+/*
+ * SIV mode requires the aad and plaintext when building the IV, which
+ * prevents streaming processing and it incompatible with the AEAD API.
+ */
+
+#define SIV_CMAC_CTX(type) \
+  { struct siv_cmac_ctx siv_cmac; type cipher; }
+
+/* AES_SIV_CMAC_256 */
+struct siv_aes128_cmac_ctx SIV_CMAC_CTX(struct aes128_ctx);
+
+void
+siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const uint8_t *key);
+
+void
+siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t tlength,
+				size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+siv_aes128_cmac_decrypt_message(struct siv_aes128_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t tlength,
+				size_t mlength, uint8_t *dst, const uint8_t *src);
+
+/* AES_SIV_CMAC_512 */
+struct siv_aes256_cmac_ctx SIV_CMAC_CTX(struct aes256_ctx);
+
+void
+siv_aes256_cmac_set_key(struct siv_aes256_cmac_ctx *ctx, const uint8_t *key);
+
+void
+siv_aes256_cmac_encrypt_message(struct siv_aes256_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t tlength,
+				size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+siv_aes256_cmac_decrypt_message(struct siv_aes256_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t tlength,
+				size_t mlength, uint8_t *dst, const uint8_t *src);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_SIV_H_INCLUDED */
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index c7e04cb4..98936b87 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -133,6 +133,9 @@ ccm-test$(EXEEXT): ccm-test.$(OBJEXT)
 cmac-test$(EXEEXT): cmac-test.$(OBJEXT)
 	$(LINK) cmac-test.$(OBJEXT) $(TEST_OBJS) -o cmac-test$(EXEEXT)
 
+siv-test$(EXEEXT): siv-test.$(OBJEXT)
+	$(LINK) siv-test.$(OBJEXT) $(TEST_OBJS) -o siv-test$(EXEEXT)
+
 poly1305-test$(EXEEXT): poly1305-test.$(OBJEXT)
 	$(LINK) poly1305-test.$(OBJEXT) $(TEST_OBJS) -o poly1305-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index dd1ecf41..d08b1754 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -26,7 +26,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    serpent-test.c twofish-test.c version-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c cfb-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
-		    cmac-test.c \
+		    cmac-test.c siv-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
diff --git a/testsuite/siv-test.c b/testsuite/siv-test.c
new file mode 100644
index 00000000..dd58e679
--- /dev/null
+++ b/testsuite/siv-test.c
@@ -0,0 +1,332 @@
+/* siv-test.c
+
+   Self-test and vectors for AES-SIV mode ciphers
+
+   Copyright (C) 2018 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+/* The
+ * test vectors have been collected from the following standards:
+ *  RFC5297
+ */
+
+#include "testutils.h"
+#include "aes.h"
+#include "nettle-types.h"
+#include "siv-cmac.h"
+#include "knuth-lfib.h"
+
+static void
+test_compare_results(const char *name,
+        const struct tstring *adata,
+        /* Expected results. */
+        const struct tstring *e_clear,
+	const struct tstring *e_cipher,
+        /* Actual results. */
+        const void *clear,
+        const void *cipher,
+        const void *digest) /* digest optional. */
+{
+  int tlength = (e_cipher-&gt;length - e_clear-&gt;length);
+  if (digest &amp;&amp; tlength &amp;&amp; !MEMEQ(tlength, e_cipher-&gt;data, digest))
+    {
+      fprintf(stderr, "%s digest failed:\nAdata:", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(tlength, digest);
+      fprintf(stderr, "\nExpected:");
+      print_hex(tlength, e_cipher-&gt;data);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  if (!MEMEQ(e_cipher-&gt;length, e_cipher-&gt;data, cipher))
+    {
+      fprintf(stderr, "%s: encryption failed\nAdata: ", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_cipher-&gt;length, cipher);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_cipher);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  if (!MEMEQ(e_clear-&gt;length, e_clear-&gt;data, clear))
+    {
+      fprintf(stderr, "%s decrypt failed:\nAdata:", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_cipher);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_clear-&gt;length, clear);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+} /* test_compare_results */
+
+static void
+test_cipher_siv(const char *name,
+		nettle_set_key_func *siv_set_key,
+		nettle_encrypt_message *siv_encrypt,
+		nettle_decrypt_message *siv_decrypt,
+		unsigned context_size,
+		const struct nettle_cipher *cipher,
+		const struct tstring *key,
+		const struct tstring *nonce,
+		const struct tstring *authdata,
+		const struct tstring *cleartext,
+		const struct tstring *ciphertext)
+{
+  void *ctx = xalloc(context_size);
+  uint8_t *en_data;
+  uint8_t *de_data;
+  size_t tlength;
+  int ret;
+
+  ASSERT (key-&gt;length == cipher-&gt;key_size*2);
+  ASSERT (cleartext-&gt;length &lt;= ciphertext-&gt;length);
+  ASSERT ((cleartext-&gt;length + SIV_BLOCK_SIZE) &gt;= ciphertext-&gt;length);
+  tlength = ciphertext-&gt;length - cleartext-&gt;length;
+
+  de_data = xalloc(cleartext-&gt;length+SIV_DIGEST_SIZE);
+  en_data = xalloc(ciphertext-&gt;length);
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+
+  /* Ensure we get the same answers using the all-in-one API. */
+  memset(de_data, 0, cleartext-&gt;length);
+  memset(en_data, 0, ciphertext-&gt;length);
+
+  siv_set_key(ctx, key-&gt;data);
+  siv_encrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+				  authdata-&gt;length, authdata-&gt;data, tlength,
+				  cleartext-&gt;length, en_data, cleartext-&gt;data);
+
+  ret = siv_decrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+				        authdata-&gt;length, authdata-&gt;data, tlength,
+				        ciphertext-&gt;length, de_data, ciphertext-&gt;data);
+
+  if (ret != 1) fprintf(stderr, "siv_decrypt_message failed to validate message\n");
+    test_compare_results(name, authdata,
+			 cleartext, ciphertext, de_data, en_data, NULL);
+
+  test_compare_results(name, authdata,
+		       cleartext, ciphertext, de_data, en_data, en_data);
+
+
+  /* Ensure that we can detect corrupted message or tag data. */
+  if (tlength) {
+    en_data[0] ^= 1;
+    ret = siv_decrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+				          authdata-&gt;length, authdata-&gt;data, tlength,
+				          ciphertext-&gt;length, de_data, en_data);
+    if (ret != 0) fprintf(stderr, "siv_decrypt_message failed to detect corrupted \
message\n"); +  }
+
+  /* Ensure we can detect corrupted adata. */
+  if (tlength &amp;&amp; authdata-&gt;length) {
+    en_data[0] ^= 1;
+    ret = siv_decrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+				         authdata-&gt;length-1, authdata-&gt;data, tlength,
+				         ciphertext-&gt;length, de_data, en_data);
+    if (ret != 0) fprintf(stderr, "siv_decrypt_message failed to detect corrupted \
message\n"); +  }
+
+
+  free(ctx);
+  free(en_data);
+  free(de_data);
+}
+
+#define test_siv_aes128(name, ctx_size, cipher, key, nonce, authdata, cleartext, \
ciphertext) \ +	test_cipher_siv(name, (nettle_set_key_func*)siv_aes128_cmac_set_key, \
\ +			(nettle_encrypt_message*)siv_aes128_cmac_encrypt_message, \
+			(nettle_decrypt_message*)siv_aes128_cmac_decrypt_message, ctx_size, cipher, \
+			key, nonce, authdata, cleartext, ciphertext)
+
+#define test_siv_aes256(name, ctx_size, cipher, key, nonce, authdata, cleartext, \
ciphertext) \ +	test_cipher_siv(name, (nettle_set_key_func*)siv_aes256_cmac_set_key, \
\ +			(nettle_encrypt_message*)siv_aes256_cmac_encrypt_message, \
+			(nettle_decrypt_message*)siv_aes256_cmac_decrypt_message, ctx_size, cipher, \
+			key, nonce, authdata, cleartext, ciphertext)
+
+void
+test_main(void)
+{
+  /* Create a pattern of 00010203 04050607 08090a00b 0c0d0e0f ... */
+  struct tstring *adata;
+  unsigned int i;
+  adata = tstring_alloc(256);
+  for (i=0; i&lt;adata-&gt;length; i++) adata-&gt;data[i] = (i &amp; 0xff);
+
+  /*
+   * Example without nonce length &lt; 16 (RFC5297)
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"),
+		  SHEX(""),
+		  SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+		       "20212223 24252627"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("85632d07 c6e8f37f 950acd32 0a2ecc93"
+		       "40c02b96 90c4dc04 daef7f6a fe5c"));
+
+  /*
+   * Example without nonce length &gt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX(""),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("c12ccaa7 54e1b3fa 4f416c18 415625ca"
+		       "472fbee de5bc03f 34934819 a9abb20b5"
+		       "8cd019c 470ac832 f6eb9ddf 0656c5dce"
+		       "ffe611a 5a5ca3e1 c3c12da5 6e4bb87"));
+
+  /*
+   * Example with single AAD, length &gt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+	          &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("85825e22 e90cf2dd da2c548d c7c1b631"
+		       "0dcdaca0 cebf9dc6 cb90583f 5bf1506e"
+		       "02cd4883 2b00e4e5 98b2b22a 53e6199d"
+		       "4df0c166 6a35a043 3b250dc1 34d776"));
+
+  /*
+   * Example with single AAD, length &lt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+	          &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("15f83882 14bdc94e 3ec4c7c3 69863746"
+		       "cd72d317 4b20a1e4 a0894fb7 cd78"));
+
+
+  /* AES-SIV-CMAC-512 (AES-256) from dchest/siv repo
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+		  &amp;nettle_aes256,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "6f6e6d6c 6b6a6968 67666564 63626160"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"
+		       "00010203 04050607 08090a0b 0c0d0e0f"),
+		  SHEX(""),
+		  SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+		       "20212223 24252627"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("f125274c 598065cf c26b0e71 57502908"
+		       "8b035217 e380cac8 919ee800 c126"));
+
+
+  /* AES-SIV-CMAC-512 (AES-256)
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+		  &amp;nettle_aes256,
+		  SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+		       "2d568e91 a38e5414 8abdc0b6 e86caf87"
+		       "695c0a8a df4c5f8e b2c6c8b1 36529864"
+		       "f3b84b3a e8e3676c e760c461 f3a13e83"),
+		  SHEX(""),
+		  SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+		       "20212223 24252627"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("ae2b1bd1 ba7fcd6a 4f9f7eb2 4b40f766"
+		       "86053ffd c384cb19 76031f46 3013"));
+
+  /*
+   * Example without nonce length &gt; 16
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+		  &amp;nettle_aes256,
+		  SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+		       "2d568e91 a38e5414 8abdc0b6 e86caf87"
+		       "695c0a8a df4c5f8e b2c6c8b1 36529864"
+		       "f3b84b3a e8e3676c e760c461 f3a13e83"),
+		  SHEX(""),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("79476aaa 388374fe 97d0db51 596cb5ee"
+		       "a933e001 412026c7 956c82dd b753b1af"
+		       "3d7d49ac 474a800a c14b4bab a4542067"
+		       "83647ef9 51315dab b7a2c05b 288ba8"));
+
+  /*
+   * Example with single AAD, length &gt; 16
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+	          &amp;nettle_aes256,
+		  SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+		       "2d568e91 a38e5414 8abdc0b6 e86caf87"
+		       "695c0a8a df4c5f8e b2c6c8b1 36529864"
+		       "f3b84b3a e8e3676c e760c461 f3a13e83"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("5a979b0d a58fde80 51621ae6 bf96feda"
+		       "50933da8 047bc306 fabaf0c3 d9fa8471"
+		       "c70a7def 39a2f91d 68a2021c 99ac7e2a"
+		       "24535a13 4ba23ec1 5787cebe 5c53cc"));
+}
-- 
2.14.3



</body></email><email><emailId>20180217203054</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-17 20:30:54-0400</timestampReceived><subject>Re: [PATCH 1/2] Provide wrappers around OpenSSL AES GCM</subject><body>

Jeffrey Walton &lt;noloader@gmail.com&gt; writes:

&gt; It is easy enough to audit. Everywhere there is an assert() to assert
&gt; a condition, then there should be an if() statement with the same test
&gt; that returns failure.

Sorry for getting a bit off-topic, but I would like to advice against
that practice.

In particular, it makes the error handling for the "return failure" case
awkward to test properly. At least, in my experience it is desirable to
be able to run the same testsuite on either release or debug builds. But
any tests intended to exercise that error handling will crash with an
assertion failure when testing a debug build. I don't like that at all.

Getting back to Nettle, I strive to design the interfaces so that there
are no ways to fail, given valid inputs. No return value, and no error
handling required from callers. And where practical, documented input
requirements are backed up with asserts.

E.g, consider the _set_key method for some cipher. Due to an application
bug, this function might be called with an empty key, with a null key
pointer or zero key length. Nettle will then crash with either an
assertion failure or fatal signal from a null pointer dereference.

We could avoid crashing, by silently ignoring the error and doing
nothing. That seems dangerous to me, the application might end up
sending sensitive data encrypted with an uninitialized cipher, and where
the value of uninitialized subkeys is likely easy to guess by the
attacker.

We could return a error code, but for that to be a real improvement,
*all* applications must clutter up their code to check errors from
_set_key, which are not expected to ever happen, and with error handling
which is inconvenient to test properly. If the applications with the
empty key bug fails to check the return value, or checks it but with
bugs in the error handling code, it will end up in the same case of
silently using a cipher with uninitialized easy-to-guess subkeys.

On the other hand, the _set_key function for ciphers with weak keys does
have a return value in Nettle. I think this makes sense because

1. It's Nettle's job to know which keys are weak, not the application's.

2. Checking for weak keys is somewhat optional. It might useful in some
   cases, but not terribly useful if the application selects the key
   using some random process where the probability of weak keys are
   negligible. And for the applications where it does matter, the error
   handling should be reasonably easy to test.

&gt; Postel's law is dangerous nowadays. The threat landscape has changed.
&gt; Look for any reason you can to fail processing. If you can't find a
&gt; reason, then begrudgingly process the data.

I'm afraid I can't make much sense of this remark. You probably read the
robustness principle (RFC 1112) differently than I do.

The way I read it, one should be prepared to receive all possible input
from the remote end, make sure that everything allowed by the spec is
handled correctly, and with proper error handling for anything invalid.

While when sending data, one should stay in the main stream. Avoid any
obscure and rarely used protocol features and corner cases, even when
they are technically correct according to the spec.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180218090514</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-18 09:05:14-0400</timestampReceived><subject>Re: [PATCH] Move expressions with side effects out of asserts</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; It is wrong to use expressions with side-effects in asserts, they can
&gt; easily be compiled away. Move them out of assert() macro and just
&gt; compare the result.

Thanks! Applied now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180219120721</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-02-19 12:07:21-0400</timestampReceived><subject>Re: TMP_DECL_ALIGN (was: Re: [PATCH v2 1/2] Implement PSS encoding functions)</subject><body>

On Sun, 2018-02-18 at 22:30 +0100, Niels Möller wrote:
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt; &gt; For now, I think I'll fix this, and add a TMP_ALIGN_DECL,
&gt; &gt; TMP_ALIGN_ALLOC.
&gt; 
&gt; Below patch seems to work. Other options?
&gt; 
&gt; Regards,
&gt; /Niels
&gt; 
&gt; diff --git a/nettle-internal.h b/nettle-internal.h
&gt; index 38c8d2a8..b109e944 100644
&gt; --- a/nettle-internal.h
&gt; +++ b/nettle-internal.h
&gt; @@ -35,20 +35,41 @@
&gt;  #ifndef NETTLE_INTERNAL_H_INCLUDED
&gt;  #define NETTLE_INTERNAL_H_INCLUDED
&gt;  
&gt; +#include &lt;assert.h&gt;
&gt; +
&gt;  #include "nettle-meta.h"
&gt;  
&gt; +/* For definition of NETTLE_MAX_HASH_CONTEXT_SIZE. */
&gt; +#include "sha3.h"
&gt; +
&gt;  /* Temporary allocation, for systems that don't support alloca. Note
&gt;   * that the allocation requests should always be reasonably small,
&gt; so
&gt;   * that they can fit on the stack. For non-alloca systems, we use a
&gt; - * fix maximum size, and abort if we ever need anything larger. */
&gt; + * fix maximum size + an assert.
&gt; + *
&gt; + * TMP_DECL and TMP_ALLOC allocate an array of the given type, and
&gt; + * take the array size (not byte size) as argument.
&gt; + *
&gt; + * TMP_DECL_ALIGN and TMP_ALLOC_ALIGN are intended for context
&gt; + * structs, with void * pointer, size in bytes, and alignment
&gt; + * requirements. On systems without alloca, implemented as an array
&gt; of
&gt; + * uint64_t, to ensure alignment. Since it is used as void *
&gt; argument,
&gt; + * no type casts are needed.
&gt; + */

#define ALIGN16(x) \
        ((void *)(((ptrdiff_t)(x)+(ptrdiff_t)0x0f)&amp;~((ptrdiff_t)0x0f)))
 
&gt;  #if HAVE_ALLOCA
&gt;  # define TMP_DECL(name, type, max) type *name
&gt;  # define TMP_ALLOC(name, size) (name = alloca(sizeof (*name) *
&gt; (size)))
&gt; +# define TMP_DECL_ALIGN(name, max) void *name
&gt; +# define TMP_ALLOC_ALIGN(name, size) (name = alloca(size))

What about this macros (untested, just idea demo):

#if defined(HAVE_ALLOCA)
# define TMP_DECL_ALLOC(name, type, max, size) type *name =
alloca(sizeof (*name) * (size)))
#else if __STDC_VERSION__ &gt;= 199901L
# define TMP_DECL_ALLOC(name, type, max, size) \
  type _tmp##name[size+16]; \
  type *name = ALIGN16(_tmp##name)
#else /* fallback for pre-C99 and pre-alloca() times
# define TMP_DECL_ALLOC(name, type, max, size) \
  type _tmp##name[max+16]; \
  type *name = ALIGN16(_tmp##name); \
  assert(size &lt;= max)
#endif

A more simplified version would be by eliminating the need to calculate
max, and this removing support for compilers which don't have alloca()
or C99 support (not sure if there are any of these).

regards,
Nikos


</body></email><email><emailId>20180219174657</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-19 17:46:57-0400</timestampReceived><subject>Re: TMP_DECL_ALIGN</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; On Mon, 2018-02-19 at 15:27 +0100, Niels Möller wrote:
&gt;&gt; I think I'd prefer allocating a uint64_t array (largest type used in
&gt;&gt; nettle context structs), and leave to the compiler to figure out what
&gt;&gt; alignment is needed and how to get it.
&gt;
&gt; That way you get 8-byte alignment which is ok, but if you use it for
&gt; aesni key state for example, it results to slower operations.

My concern now is not performance, but correctness on platforms that
require proper data alignment.

But to nevertheless comment about performance, for the benefit of x86_64
simd instructions, I've been thinking about specifying 16-byte alignment
for things like union nettle_block16 and aes subkeys, but I'm not aware
of any nice and portable way to do that. And if we do it only for some
of the possible compilers on a platform, we get an inconsistent ABI.

And I doubt it makes much difference for performance, the bottleneck for
AES isn't the reading of subkeys (at least not since recent aesni
changes which loads the subkeys into registers outside of the block
loop). memxor is the only function in Nettle which is likely to be
limited by memory accesses, and it uses its own logic to do aligned
accesses.

Speaking of memxor, I wonder if one could take advantage of alignment
info propagated by recent versions of gcc, and do something like

#define COMPILE_TIME_ZERO(x) (__builtin_constant_p((x) == 0) &amp;&amp; (x) == 0))

inline void memxor (void *src, void *dst, size_t n) 
{
   if (COMPILE_TIME_ZERO((intptr_t) src &amp; 7)
       &amp;&amp; COMPILE_TIME_ZERO((intptr_t) dst &amp; 7)
       &amp;&amp; COMPILE_TIME_ZERO(n &amp; 7))
     memxor_words(...);
   else 
     ...
}

to skip some runtime alignment checks when alignment can be derived at
compile time.

&gt; Said that, variable arrays and alloca() are ok when the input doesn't
&gt; come externally but I'm not sure if we can enforce that in nettle. What
&gt; about moving to malloc() unconditionally?

The intention is to use TMP_ALLOC only for allocations with small
bounds, like digest or block sizes, other small buffers (e.g., 512 bytes
used in ctr.c and cbc.c), and in the pss code, hash context sizes.

You fixed a few potentially larger allocations to use TMP_GMP_ALLOC some
time ago, iirc.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180221221620</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-21 22:16:20-0400</timestampReceived><subject>Re: cmac</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Pushed to a branch "cmac-support"

Merged to master now, with the additional fix for deallocating memory in
the test.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180221222002</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-21 22:20:02-0400</timestampReceived><subject>Re: x86 sha_ni</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I've been trying out the sha_ni instructions available on some newer
&gt; x86_64 processors.

And now that the gcc67 machine is up again, I got my sha256
implementation working too. Pushed to branch x86_64-sha_ni-sha256.

Not yet wired up in fat builds, but can be tested with
--enable-x86-sha-ni to configure.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180221224951</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-21 22:49:51-0400</timestampReceived><subject>Re: What should nettle-3.5 be like?</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; 2. Delete the old aes_* interface, in favor of aes128_, aes192_* and
&gt;    aes256_*.

I've now made a branch for this, delete-old-aes.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180222123336</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-02-22 12:33:36-0400</timestampReceived><subject>Re: Deleting old AES api (was: Re: What should nettle-3.5 be like?)</subject><body>

On Thu, 2018-02-22 at 13:51 +0300, Dmitry Eremin-Solenikov wrote:
&gt; Hello,
&gt; 
&gt; 2018-02-22 13:41 GMT+03:00 Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;:
&gt; &gt; On Thu, 2018-02-22 at 07:54 +0100, Niels Möller wrote:
&gt; &gt; &gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; &gt; Thanks for bringing that up. I have a quick fix for that, although
&gt; &gt; I no
&gt; &gt; longer have such systems for checking.
&gt; 
&gt; Do you need one? Maybe we can buy you smth. from eBay if it's not too
&gt; costly?

The hw cost is not really a blocker. Maintenance costs are, such as,
installing everything and making sure that system is online and part of
the gnutls CI, and when something breaks (disks etc) replace it. I've
tried it before, but I gave up on that approach. If there is a cloud
provider which provides Via cpus we can most likely include it in
gnutls' CI. Otherwise I think it would be too time consuming.

regards,
Nikos


</body></email><email><emailId>20180222132748</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-02-22 13:27:48-0400</timestampReceived><subject>Re: Deleting old AES api</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; How widely used are these macros? Searching debian code:
&gt; https://codesearch.debian.net/search?q=aes_set_encrypt_key&amp;page=1&amp;perpkg=1
&gt;
&gt; seems to show gnutls (in fips140 drbg code), stoken, qemu, rdup,
&gt; filezilla, pike, cmake, uanytun, haskell-bindings-nettle, libarchive,
&gt; anytun, and mosh.

If we want to keep it, and still make it possible to replace
x86_64/aesni/aes-encrypt-internal.asm with three
x86_64/aesni/aesKEYSIZE-encrypt.asm, we could do that by redefining
aes_ctx as something like

struct aes_ctx
{ 
  unsigned keysize;
  union 
    {
      struct aes128_ctx aes128;
      struct aes192_ctx aes192;
      struct aes256_ctx aes256;
    } u;
};

and write each aes_* function as a switch on the keysize. Since we
already have the tests, that should be fairly cheap in terms of
maintenance.

Deprecation was announced with nettle-3.0, 3.5 years ago:

   The old interface, with struct aes_ctx and struct camellia_ctx, is kept
   for backwards compatibility, but might be removed in later
   versions.   (NEWS file)

but I guess noone saw any urgent need to update old code to the new
interfaces. (We never do, do we?).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180227133559</emailId><senderName>Daniel =?utf-8?B?UC4gQmVycmFuZ8Op?=</senderName><senderEmail>berrange@redhat.com</senderEmail><timestampReceived>2018-02-27 13:35:59-0400</timestampReceived><subject>Re: symbol versioning update</subject><body>

On Tue, Feb 27, 2018 at 02:01:06PM +0100, Nikos Mavrogiannopoulos wrote:
&gt; Hi,
&gt;  When we initially introduced symbol versioning in nettle we bundled
&gt; all symbols from the library in a single version. That means that new
&gt; symbols added to a release like nettle_get_hashes() may cause issues
&gt; like this:
&gt; https://bugzilla.redhat.com/show_bug.cgi?id=1549190
&gt; 
&gt; The underlying issue is in rpm-based systems which detect which symbols
&gt; exist in which library version based on the version. That way, when a
&gt; dependency is tracked, the version with the right symbol will be
&gt; retrieved. Debian-based systems work differently so that shouldn't
&gt; affect it.
&gt; 
&gt; To address these problems in gnutls, I follow these additional rules in
&gt; to having a map file:
&gt; https://gitlab.com/gnutls/gnutls/blob/master/CONTRIBUTING.md#symbol-and-library-versioning

You mention here that symbol versioning lets you expose multiple symbols
with the same name, but different versions, as is commonly seen with glibc.

That is correct, but beware that this trick only works on platforms using
certain linkers. In particular Windows linker scripts will not support
this. In fact windows doesn't support versioning at all - you just have a
single flat list of exported symbols. For libvirt we just take the list
of versioned symbols &amp; merge them into a list suitable for Wndows DLL
linking. So while using versioned symbols is fine if you only ever export
one symbol for a given name, you should wary of relying on the ability to
export the same name twice with different versions as that's non-portable.

&gt; which in turn comes from libvirt:
&gt; https://www.berrange.com/posts/2011/01/13/versioning-in-the-libvirt-library/
&gt; 
&gt; That of course adds overhead on releases.

IME, this per-release versioning has not actually caused any notable
overhead on libvirt's upstream development. At worst, you get contributors
sending patches with old versions and have to point out to update the patch
to use the correct next version number.

The only overhead we experianced falls on downstream vendors, if they try
to fork the library ABI/API, by backporting new symbols to older releases.
You can't make the backported symbol use the old version number, as that
will cause an ABI incompatibilty if you later rebase to the new version.
Using the new version number on the backported symbol, gives a false
record of the ABI, as it makes the old version appear to support the new
version's ABI whereas in fact it only supports 1 out of potentially many
APIs from the new version.

For libvirt we simply refuse to do backporting of APIs in distros where I
am involved of maintenence. If someone needs a newer API, libvirt just
has to be rebased to the suitable version.


Regards,
Daniel
-- 
|: https://berrange.com      -o-    https://www.flickr.com/photos/dberrange :|
|: https://libvirt.org         -o-            https://fstop138.berrange.com :|
|: https://entangle-photo.org    -o-    https://www.instagram.com/dberrange :|

</body></email><email><emailId>20180101131030</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-01 13:10:30-0400</timestampReceived><subject>Skein status</subject><body>

I'm looking at the skein code I wrote a while ago, and I might merge it
pretty soon, just need a little cleanup. I'm doing skein256 and skein512
(other variants, in particular, skein512-256, mey be of interest).

For skein256, it works quite well with two-way unrolling (by which I
mean that each loop iteration performs 8 mixing rounds, adding in
subkeys twice). 

I did an x86_64 assembly version, but I'm not being able to beat C code
compiled by gcc, so I think I'll scrap that. Which isn't so surprising,
since skein uses only operations that the C compiler knows well, and I'm
not trying anything clever with scheduling or register allocation.

For skein512, subkeys are accessed with mod 9 indexing, which is
challenging to do with high performance, if indexes need to be
constructed at runtime. I get pretty good performance with full
unrolling (so indices are constant), and I'm afraid we have to do either
that, or copy subkeys into an area where they are repeated multiple
times.

As I think I wrote earlier, skein looks similar in spirit to salsa20 and
chacha, but unlike those, it's doesn't fit well with simd instructions.
To use simd instructions for skein, one would like to put put 2 64-bit
values in one xmm register, but one then needs a way to rotate the two
halves with different shift counts, which I haven't found any good way
to do. Also the odd number of subkeys (five for skein256, and nine for
skein512, with the last subkey being the xor of all the other keys and a
magic constant), usued in a rotationg fashion, doesn't fit well with
storing keys in simd registers.

I'm benchmarking on a intel broadwell cpu (marketing name "core
i3-5010U") running at 2.1 GHz.

         Algorithm        mode Mbyte/s cycles/byte cycles/block
          skein256      update  242.45        8.26       264.33
          skein512      update  350.44        5.71       365.75

For comparison, timing for sha1, sha2 and sha3:

         Algorithm        mode Mbyte/s cycles/byte cycles/block
              sha1      update  326.40        6.14       392.69
      openssl sha1      update  560.98        3.57       228.48
            sha256      update  156.07       12.83       821.24
            sha512      update  252.54        7.93      1015.10
          sha3_224      update  161.90       12.37      1781.33
          sha3_256      update  152.83       13.10      1782.18
          sha3_384      update  117.06       17.11      1779.22
          sha3_512      update   80.52       24.87      1790.77

So skein512 is faster than both sha2 and sha3 (and one can also see that
for sha1 we currently lose to openssl). skein256 is fastet than sha3,
but slightly slower than sha512. So maybe we shouldn't do skein256 at
all, but skein512-256 (skein can be used with arbitrary output size).

Code size for is 408 bytes for skein256, and 3992 bytes for skein512
(which is completely unrolled). Counting only the main block processing
function.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180104015738</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-01-04 01:57:38-0400</timestampReceived><subject>Re: [PATCH v3 0/1] Add Cipher FeedBack mode support</subject><body>

2018-01-03 12:44 GMT+03:00 Nikos Mavrogiannopoulos
&lt;n.mavrogiannopoulos@gmail.com&gt;:
&gt; On Sat, Oct 7, 2017 at 8:55 PM, Dmitry Eremin-Solenikov
&gt; &lt;dbaryshkov@gmail.com&gt; wrote:
&gt; &gt; Add CFB mode support. CFB uses segment size = block size.
&gt; &gt; 
&gt; &gt; Changes since V2:
&gt; &gt; 
&gt; &gt; - Dropped CFB8, isn't widely used.
&gt; 
&gt; I'm getting late into this discussion, but it seems that samba (which
&gt; uses nettle and gnutls), could benefit from an 8-bit CFB mode as well.
&gt; They are already implementing it on top of nettle, and it is being
&gt; used on the newer samba versions:
&gt; 
&gt; https://git.samba.org/?p=samba.git;a=blob;f=lib/crypto/REQUIREMENTS;h=351c2bb99b4d760aeaf47ef47b3a489187f60488;hb=refs/heads/master
&gt; 

Hmm, interesting. It looks like they miss CFB8 and CMAC. However
from the first glance I could not understand, do they reference nettle/
GNUTLS as code reference, or are they using them as crypto backends?
Skimming over WAF scripts did not give me the answer.

I can (re-)post CFB8 if that will be helpful to Samba (or other parties).
CMAC also sounds like and interesting topic.

-- 
With best wishes
Dmitry


</body></email><email><emailId>20180104075403</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-01-04 07:54:03-0400</timestampReceived><subject>possible new modes (was: [PATCH v3 0/1] Add Cipher FeedBack mode support)</subject><body>

On Thu, Jan 4, 2018 at 2:57 AM, Dmitry Eremin-Solenikov
&lt;dbaryshkov@gmail.com&gt; wrote:
&gt; 2018-01-03 12:44 GMT+03:00 Nikos Mavrogiannopoulos
&gt; &lt;n.mavrogiannopoulos@gmail.com&gt;:
&gt; &gt; On Sat, Oct 7, 2017 at 8:55 PM, Dmitry Eremin-Solenikov
&gt; &gt; &lt;dbaryshkov@gmail.com&gt; wrote:
&gt; &gt; &gt; Add CFB mode support. CFB uses segment size = block size.
&gt; &gt; &gt; 
&gt; &gt; &gt; Changes since V2:
&gt; &gt; &gt; 
&gt; &gt; &gt; - Dropped CFB8, isn't widely used.
&gt; &gt; 
&gt; &gt; I'm getting late into this discussion, but it seems that samba (which
&gt; &gt; uses nettle and gnutls), could benefit from an 8-bit CFB mode as well.
&gt; &gt; They are already implementing it on top of nettle, and it is being
&gt; &gt; used on the newer samba versions:
&gt; &gt; 
&gt; &gt; https://git.samba.org/?p=samba.git;a=blob;f=lib/crypto/REQUIREMENTS;h=351c2bb99b4d760aeaf47ef47b3a489187f60488;hb=refs/heads/master
&gt; &gt; 
&gt; 
&gt; Hmm, interesting. It looks like they miss CFB8 and CMAC. However
&gt; from the first glance I could not understand, do they reference nettle/
&gt; GNUTLS as code reference, or are they using them as crypto backends?
&gt; Skimming over WAF scripts did not give me the answer.

They are used as backends, though they also re-implement quite few
stuff. My understanding is that they would like to get rid of their
crypto implementations, and rely on nettle and gnutls for that.

&gt; I can (re-)post CFB8 if that will be helpful to Samba (or other parties).
&gt; CMAC also sounds like and interesting topic.

Niels what do think about CFB8?

On that view, I've compiled a list of new modes which seem to be
useful in other applications:
AES-CMAC: fast MAC used in samba and there is a draft for NTP
protocol. There is implementation in samba at [1].
AES-XTS: it is a mode used in disk volume encryption when no
authentication is to be present (ntfs and luks can use it). It is
implemented in qemu [0] which already has a nettle back-end.
AES-SIV-CMAC: An AES AEAD mode which does not fail
secrecy/catastrophically when a nonce is repeated. There is a draft
for its use under NTP (draft-ietf-ntp-using-nts-for-ntp-10).

regards,
Nikos


[0]. https://github.com/qemu/qemu/blob/507e4ddc3abf67391bcbc9624fd60b969c159b78/crypto/xts.c
 [1]. https://github.com/samba-team/samba/blob/d8a5565ae647352d11d622bd4e73ff4568678a7c/lib/crypto/aes_cmac_128.c



</body></email><email><emailId>20180105080102</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-01-05 08:01:02-0400</timestampReceived><subject>Re: possible new modes</subject><body>

On Thu, 2018-01-04 at 14:02 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt; 
&gt; &gt; Niels what do think about CFB8?
&gt; 
&gt; If there applications for it, it makes sense to add it. My main
&gt; question
&gt; is, should it be a separate set of functions, or should we make the
&gt; reasonably straightforward extension to cfb_encrypt and cfb_decrypt
&gt; so
&gt; that passing length == 1 implies cfb8? All needed, if I remember the
&gt; earlier discussion, is to add the appopriate iv update to the 
&gt; 
&gt;   if (left &gt; 0) { .... }

Do you think we need this generality? The CFB mode is a legacy mode,
and the only existing uses in software are cfb8 or cfb with block size.
NIST SP800-38a defines CFB1, CFB8 and CFB128, so even such a
generalized mode wouldn't cope with CFB1 (and it shouldn't as CFB1
looks like something defined for compatibility with old hw).

&gt; What's samba's usecase for CFB8? As far as I understand, CFB8 (or
&gt; small-symbol CFB in general) makes sense only when one needs to
&gt; encrypt
&gt; and transmit each byte before the next cleartext byte becomes
&gt; available.

It's for the netlogon protocol as far as I understand. They use CFB8 to
encrypt arbitrary data, as if it was with a stream cipher. I can only
speculate why CFB8 was chosen, but I guess it was selected as a way to
convert a block cipher to a stream and avoid thinking about padding.

&gt; &gt; On that view, I've compiled a list of new modes which seem to be
&gt; &gt; useful in other applications:
&gt; &gt; AES-CMAC: fast MAC used in samba and there is a draft for NTP
&gt; &gt; protocol. There is implementation in samba at [1].
&gt; &gt; AES-XTS: it is a mode used in disk volume encryption when no
&gt; &gt; authentication is to be present (ntfs and luks can use it). It is
&gt; &gt; implemented in qemu [0] which already has a nettle back-end.
&gt; &gt; AES-SIV-CMAC: An AES AEAD mode which does not fail
&gt; &gt; secrecy/catastrophically when a nonce is repeated. There is a draft
&gt; &gt; for its use under NTP (draft-ietf-ntp-using-nts-for-ntp-10).
&gt; 
&gt; Do they fit well with current nettle interfaces?
&gt; I take it CMAC is related (but slightly different?) to the CBC-MAC
&gt; used in CCM mode?

Right.

For the AES-CMAC, there doesn't seem to be a generic MAC interface in
nettle, but even if it was, it is a straightforward MAC with setkey(),
update() and digest().

AES-SIV-CMAC is an AEAD cipher so I guess an interface like
ccm_encrypt_message() and ccm_decrypt_message() would be sufficient.

XTS looks like something along CBC api-wise. It will require the
storage of two cipher states, but nothing special.

regards,
Nikos


</body></email><email><emailId>20180112154843</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2018-01-12 15:48:43-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I think there are three main pieces left to integrate.
&gt; 
&gt; 1. Curve operations to support Curve448 (i.e., diffie-hellman
&gt; operations). I have made some progress, on my curve448 branch,
&gt; 
&gt; 2. SHAKE 128/256. I think I had some question on the interface design.
&gt; 
&gt; 3. EdDSA 448.
&gt; 
&gt; Optimization of the mod p arithmetic isn't that important yet,

I see.  I thought that the performance of curve operations should at
least be comparable to P-521.  However, even with the generic ecc_mod
for mod p, those are already close.  So let's look at the above items
first.  I have rebased my patch implementing (1) on the curve448 branch:
https://gitlab.com/dueno/nettle/commits/wip/dueno/curve448-2

One thing I noticed is that the point addition formula for untwisted
curves doesn't look correct:
https://gitlab.com/dueno/nettle/commit/4e3a50f4a50d8d03536dc107d7b77c84462e3068#6c80341e16ba39077bf2507d8450393d7e7e677a_261_262


&gt; but I'll nevertheless try to explain how I think about it.

Thank you for the detailed explanation.  I ran the benchmark for those 3
variants: (1) the original version using ecc_mod, (2) the two step
reduction as you suggest, and (3) my formula optimized with single
7-limbs operations:

size   modp reduce   modq modinv mi_gcd mi_pow dup_jj ad_jja ad_hhh  mul_g  mul_a \
(us)  448 0.0727 0.0720 0.0739  44.01  1.451  52.92  1.088  1.456  1.406  299.6  \
557.6  521 0.0139 0.0151 0.1003  77.72  1.703 101.59  0.728  0.995  1.277  255.8  \
588.4

 448 0.0496 0.0497 0.0764  34.77  1.500  49.59  0.923  1.158  1.169  273.5  500.1
 521 0.0147 0.0144 0.1027  77.63  1.816  88.57  0.716  0.934  1.276  237.2  589.9

 448 0.0641 0.0644 0.0809  52.76  1.570  49.42  1.007  1.340  1.343  288.1  570.5
 521 0.0139 0.0141 0.0967  78.22  1.697  99.44  0.714  1.012  1.264  235.8  589.2

on Core i7-6600U CPU @ 2.60GHz.

My code could be wrong or inefficient, but actually (2) is the fastest.
(3) is slower due to the final carry handling; the carry is accumulated
at most 3 and wrapping around it with cnd_add_n seems to be costly.

Regards,
-- 
Daiki Ueno


</body></email><email><emailId>20180113095912</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-13 09:59:12-0400</timestampReceived><subject>Re: [PATCH] Allow user to specify multiple algorithms to nettle-benchmark</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt;  examples/nettle-benchmark.c | 47 +++++++++++++++++++++++++--------------------
&gt;  1 file changed, 26 insertions(+), 21 deletions(-)

Thanks, pushed now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180113100138</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-13 10:01:38-0400</timestampReceived><subject>Big-endian testing (was: Re: Performance of AESNI impl vs other crypto libraries)</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I've tried this, with special code for block size 16. (Without any
&gt; assembly, but using __builtin_bswap64). Pushed to the ctr-opt branch.

For the ctr changes, I need some testing on big-endian before merging to
master. Most of the gmp virtual test machines are down at the moment,
pending security upgrades related to spectre and meltdown.

I've applied for a gcc compile farm account, and was approved Wednesday
evening, but it seems my account and ssh key hasn't yet been propageted
to the farm machines.

Is anyone on the list familiar with debian cross compilers? It would be
convenient to be able to locally cross compile for, e.g., debian mips
and run tests with qemu-user, if needed things are packaged.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180114092341</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-14 09:23:41-0400</timestampReceived><subject>Re: Big-endian testing</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I've applied for a gcc compile farm account, and was approved Wednesday
&gt; evening, but it seems my account and ssh key hasn't yet been propageted
&gt; to the farm machines.

Got this set up now, and tested successfully on an Ultrasparc T5
(gcc202.fsffrance.org). Speedup of aes128 ctr was around 20%.

Speaking of sparc, recent chips have some crypto instructions which
could be used to speedup aes considerably. I don't think I'm going to do
any more sparc assembly hacking soon, but if someone else is interested
in sparc performance, it might be a reasonably easy project with large
speedup.

Current sparc aes code was written back in 2005, using the 32-bit
sparcstation I had at home at the time, running Redhat linux. It was
adapted for sparc64 by Henrik Grubbström, and essentially the same code
is used for both 32-bit and 64-bit.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180115190735</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-15 19:07:35-0400</timestampReceived><subject>Re: [PATCH] Add CFB8 - Cipher Feedback 8-bit block cipher mode</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; Add CFB variant with 8-bit segment size.

Thanks. I'm fine with separate functions like you do, that seems to be
the most straightforward interface.

&gt; +void
&gt; +cfb8_decrypt(const void *ctx, nettle_cipher_func *f,
&gt; +	     size_t block_size, uint8_t *iv,
&gt; +	     size_t length, uint8_t *dst,
&gt; +	     const uint8_t *src)
&gt; +{
&gt; +  TMP_DECL(buffer, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE * 2);
&gt; +  TMP_DECL(outbuf, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE * 2);
&gt; +  TMP_ALLOC(buffer, block_size * 2);
&gt; +  TMP_ALLOC(outbuf, block_size * 2);
&gt; +  uint8_t i = 0;
&gt; +
&gt; +  memcpy(buffer, iv, block_size);
&gt; +  memcpy(buffer + block_size, src,
&gt; +	 length &lt; block_size ? length : block_size);
&gt; +
&gt; +  while (length)
&gt; +    {
&gt; +
&gt; +      for (i = 0; i &lt; length &amp;&amp; i &lt; block_size; i++)
&gt; +	f(ctx, block_size, outbuf + i, buffer + i);
&gt; +
&gt; +      if (src != dst)
&gt; +	memxor3(dst, src, outbuf, i);
&gt; +      else
&gt; +	memxor(dst, outbuf, i);

If there's no other reason to handle src == dst and src != dst
separately in this function, I think it's better to use memxor3
unconditionally.

&gt; diff --git a/nettle.texinfo b/nettle.texinfo
&gt; index aa374449c527..e610e74c79ab 100644

&gt; +@node CFB8, , CFB, Cipher modes
&gt; +@comment  node-name,  next,  previous,  up
&gt; +@subsection Cipher Feedback 8-bit mode
&gt; +
&gt; +@cindex Cipher Feedback 8-bit Mode
&gt; +@cindex CFB8 Mode
&gt; +
&gt; +Cipher Feedback 8-bit mode (@acronym{CFB8}) transforms block cipher into a stream
&gt; +cipher. The message is encrypted byte after byte, not requiring any padding.

Do you think it would help the reader if the CFB and CFB8 docs were
merged into a single section?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180120110729</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-20 11:07:29-0400</timestampReceived><subject>Re: [PATCH v2] Add CFB8 - Cipher Feedback 8-bit block cipher mode</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; Add CFB variant with 8-bit segment size.

Thanks! Now merged to the master-updates branch for testing.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180104130246</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-04 13:02:46-0400</timestampReceived><subject>Re: possible new modes</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Niels what do think about CFB8?

If there applications for it, it makes sense to add it. My main question
is, should it be a separate set of functions, or should we make the
reasonably straightforward extension to cfb_encrypt and cfb_decrypt so
that passing length == 1 implies cfb8? All needed, if I remember the
earlier discussion, is to add the appopriate iv update to the 

  if (left &gt; 0) { .... }

blocks at the end of these functions. This has the advantage that we get
support for CFBn for any 0 &lt; n &lt; block size, more or less for free.

What's samba's usecase for CFB8? As far as I understand, CFB8 (or
small-symbol CFB in general) makes sense only when one needs to encrypt
and transmit each byte before the next cleartext byte becomes available.

&gt; On that view, I've compiled a list of new modes which seem to be
&gt; useful in other applications:
&gt; AES-CMAC: fast MAC used in samba and there is a draft for NTP
&gt; protocol. There is implementation in samba at [1].
&gt; AES-XTS: it is a mode used in disk volume encryption when no
&gt; authentication is to be present (ntfs and luks can use it). It is
&gt; implemented in qemu [0] which already has a nettle back-end.
&gt; AES-SIV-CMAC: An AES AEAD mode which does not fail
&gt; secrecy/catastrophically when a nonce is repeated. There is a draft
&gt; for its use under NTP (draft-ietf-ntp-using-nts-for-ntp-10).

Do they fit well with current nettle interfaces?

I take it CMAC is related (but slightly different?) to the CBC-MAC used
in CCM mode?

What about OCB (for which RFC 7253 may be the most appropriate spec)? As
far as I'm aware, it's one of few AEAD modes which provides a
significant performance advantage over doing MAC and encryption
separately.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180104170530</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-01-04 17:05:30-0400</timestampReceived><subject>Re: possible new modes</subject><body>

On Thu, Jan 4, 2018 at 2:02 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; wr=
ote:

&gt; What about OCB (for which RFC 7253 may be the most appropriate spec)? As
&gt; far as I'm aware, it's one of few AEAD modes which provides a
&gt; significant performance advantage over doing MAC and encryption
&gt; separately.

(I'll need some time to check about the other questions)

I'd stay away from OCB. libgcrypt had to amend their license for that:
https://github.com/gpg/libgcrypt/blob/master/LICENSES


regards,
Nikos

</body></email><email><emailId>20180104182651</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-04 18:26:51-0400</timestampReceived><subject>Re: possible new modes</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; I'd stay away from OCB. libgcrypt had to amend their license for that:
&gt; https://github.com/gpg/libgcrypt/blob/master/LICENSES

I see. I thought their "open source" patent license might be good
enough, but probably not (for one, it doesn't cover proprietary
applications using nettle, which collides with LGPL terms, and, possibly
less important, it doesn't cover derived works which are hardware rather
than software). Latest of the mentioned patents (8321675) seems to be
applied for in 2011, so I guess it won't expire for quite some time.

So I agree we can't use it without some possibly painful legal work.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180109153724</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2018-01-09 15:37:24-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

Hello,

Thank you for the suggestions and sorry for the shameless delay.

nisse@lysator.liu.se (Niels Möller) writes:

&gt;&gt; Also, optimized implementation of modular reduction is currently
&gt;&gt; missing, which is beyond my expertise.  I would appreciate any
&gt;&gt; suggestions regarding that.
&gt;
&gt; If we do Euclidean reduction, we should use the property that
&gt;
&gt;   2^448 = 2^224 + 1 (mod)
&gt;
&gt; And we'd need to use this twice to reduce a 896-bit product to 448 bits.
&gt; On 64-bit machines, we'll get some shifting since 224 isn't a multiple
&gt; of 64.

Due to my ignorance, I probably don't get what you mean, but as far as I
read the implementations of other curves in Nettle, some of them seem to
use the property of generalized Mersenne numbers described in:
http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.2133
and it's also applicable to the Curve448 prime.

So a 896-bit product here:

  a0 + a1 * 2^k + a2 * 2^2k + a3 * 2^3k (k = 224)

can be reduced to:

  b0 + b1 * 2^k (mod p)

through modular additions of the smaller numbers:

  b0 = a0 + a2 + a3 (mod p)
  b1 = a1 + a2 + a3 + a3 (mod p)

I tried to implement it (as attached) and got 20-30% speed-up with
mini-gmp.

size   modp reduce   modq modinv mi_gcd mi_pow dup_jj ad_jja ad_hhh  mul_g  mul_a (us)
 192 0.0066 0.0061 0.0770  28.90  0.000   0.00  0.698  0.811  1.014   44.2  188.5
 224 0.0091 0.0091 0.1231  47.57  0.000   0.00  0.969  1.285  1.566   90.2  329.1
 255 0.0081 0.0078 0.1550  18.70  0.000   0.00  0.767  1.014  1.082   88.7  278.4
 256 0.1288 0.0115 0.1464  50.22  0.000   0.00  1.004  1.457  1.701  105.6  380.1
 384 0.0170 0.0170 0.1260 106.51  0.000   0.00  1.791  2.240  3.113  305.9 1015.7
 448 0.1892 0.1886 0.1886 171.57  0.000   0.00  3.630  4.914  4.940  842.1 1966.8
 521 0.0163 0.0158 0.2821 217.44  0.000   0.00  3.555  4.507  6.107  788.8 2637.8

size   modp reduce   modq modinv mi_gcd mi_pow dup_jj ad_jja ad_hhh  mul_g  mul_a (us)
 192 0.0080 0.0082 0.0748  30.61  0.000   0.00  0.663  0.810  1.007   43.9  189.9
 224 0.0103 0.0108 0.1281  47.48  0.000   0.00  0.968  1.481  1.632   89.4  323.2
 255 0.0095 0.0090 0.1545  18.71  0.000   0.00  0.828  1.081  1.085   90.8  284.9
 256 0.1353 0.0123 0.1423  51.25  0.000   0.00  0.992  1.326  1.726  107.4  379.3
 384 0.0174 0.0171 0.1253 108.82  0.000   0.00  1.760  2.233  2.991  302.9 1004.2
 448 0.1382 0.1380 0.1865 147.87  0.000   0.00  3.167  4.161  4.211  738.6 1668.3
 521 0.0186 0.0179 0.2750 216.30  0.000   0.00  3.438  4.249  5.756  743.5 2510.6

Do you think this is acceptable or need further optimization?

Regards,
-- 
Daiki Ueno

[Attachment #3 (text/x-patch)]

&gt;From bc210d94144d6b5d1e050f78b7261d58a58d8f19 Mon Sep 17 00:00:00 2001
From: Daiki Ueno &lt;dueno@redhat.com&gt;
Date: Tue, 9 Jan 2018 16:13:53 +0100
Subject: [PATCH] ecc: Add optimized modp implementation for curve448

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 ecc-448.c | 72 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 70 insertions(+), 2 deletions(-)

diff --git a/ecc-448.c b/ecc-448.c
index f98616d8..d62e8e1b 100644
--- a/ecc-448.c
+++ b/ecc-448.c
@@ -45,6 +45,74 @@
 
 #include "ecc-448.h"
 
+#if HAVE_NATIVE_ecc_448_modp
+
+#define ecc_448_modp nettle_ecc_448_modp
+void
+ecc_448_modp (const struct ecc_modulo *m, mp_limb_t *rp);
+
+#elif GMP_NUMB_BITS == 64
+/*
+ * Use 2^448 = 2^224 + 1 (mod p), compute:
+ *   b0 + b1 * 2^224 = a0 + a1 * 2^224 + a2 * 2^448 + a3 * 2^672 (mod p)
+ *
+ * as p is considered as a generalized Mersenne number, b0 and b1 can
+ * be calculated with the following shortcut:
+ *
+ *   b0 = a0 + a2 + a3 (mod p)
+ *   b1 = a1 + a2 + a3 + a3 (mod p)
+ */
+static void
+ecc_448_modp (const struct ecc_modulo *m, mp_limb_t *rp)
+{
+  mp_limb_t a1[4], a3[4], cy, mask;
+
+  /* Extract a1 */
+  mpn_copyi (a1, rp + 3, 4);
+  mpn_rshift (a1, a1, 4, 32);
+  rp[3] &amp;= 0xFFFFFFFF;
+
+  /* Extract a3 */
+  mpn_copyi (a3, rp + 10, 4);
+  mpn_rshift (a3, a3, 4, 32);
+  rp[10] &amp;= 0xFFFFFFFF;
+
+  /* a2 = a2 + a3 */
+  mpn_add_n (rp + 7, rp + 7, a3, 4);
+
+  /* a0 = a0 + a2 (carry propagated to a2) */
+  mpn_add_n (rp, rp, rp + 7, 4);
+  mpn_rshift (&amp;cy, rp + 3, 1, 32);
+  sec_add_1 (rp + 7, rp + 7, 4, cy);
+
+  /* a2 = a2 + a1 */
+  mpn_add_n (rp + 7, rp + 7, a1, 4);
+
+  /* a2 = a2 + a3 */
+  mpn_add_n (rp + 7, rp + 7, a3, 4);
+  mpn_rshift (&amp;cy, rp + 10, 1, 32);
+
+  /* Move a2 next to a0 */
+  rp[6] = 0;
+  mpn_lshift (rp + 6, rp + 7, 4, 32);
+  rp[3] &amp;= 0xFFFFFFFF;
+  rp[3] |= rp[6];
+  mpn_copyi (rp + 4, rp + 7, 3);
+
+  assert (cy &lt;= 3);
+  mask = (1 &lt;&lt; cy) - 1;
+  cy = cnd_add_n (mask &amp; 1, rp, ecc_Bmodp, 7);
+  assert (cy == 0);
+  cy = cnd_add_n (mask &amp; 2, rp, ecc_Bmodp, 7);
+  assert (cy == 0);
+  cy = cnd_add_n (mask &amp; 4, rp, ecc_Bmodp, 7);
+  assert (cy == 0);
+}
+
+#else
+#define ecc_448_modp ecc_mod
+#endif
+
 /* Needs 2*ecc-&gt;size limbs at rp, and 2*ecc-&gt;size additional limbs of
    scratch space. No overlap allowed. */
 static void
@@ -221,8 +289,8 @@ const struct ecc_curve _nettle_curve448 =
     NULL,
     ecc_pp1h,
 
-    ecc_mod,	      /* FIXME: Implement optimized mod function */
-    ecc_mod,	      /* FIXME: Implement optimized reduce function */
+    ecc_448_modp,
+    ecc_448_modp,
     ecc_448_inv,
     ecc_448_sqrt,
   },
-- 
2.13.6



</body></email><email><emailId>20180112215604</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-01-12 21:56:04-0400</timestampReceived><subject>[PATCH] Add CFB8 - Cipher Feedback 8-bit block cipher mode</subject><body>

Add CFB variant with 8-bit segment size.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 cfb.c                 |  75 +++++++++++++++++++++
 cfb.h                 |  35 ++++++++++
 nettle.texinfo        |  96 +++++++++++++++++++++++++--
 testsuite/cfb-test.c  | 103 +++++++++++++++++++++++++++++
 testsuite/testutils.c | 178 ++++++++++++++++++++++++++++++++++++++++++++++++++
 testsuite/testutils.h |   7 ++
 6 files changed, 487 insertions(+), 7 deletions(-)

---

	CFB8 support, contributed by Dmitry Eremin-Solenikov.
	* cfb.c (cfb8_encrypt, cfb8_decrypt): New functions.
	* cfb.h (CFB8_CTX, CFB8_SET_IV, CFB8_ENCRYPT, CFB8_DECRYPT): New
	macros.
	* testsuite/cfb-test.c: CFB8 test cases.
	* testsuite/testutils.c (test_cipher_cfb8): New function.
	* nettle.texinfo (CFB8): Documentation.

diff --git a/cfb.c b/cfb.c
index 805b8c4533a0..8e0ca47130d4 100644
--- a/cfb.c
+++ b/cfb.c
@@ -162,3 +162,78 @@ cfb_decrypt(const void *ctx, nettle_cipher_func *f,
 	}
     }
 }
+
+/* CFB-8 uses slight optimization: it encrypts or decrypts up to block_size
+ * bytes and does memcpy/memxor afterwards */
+void
+cfb8_encrypt(const void *ctx, nettle_cipher_func *f,
+	    size_t block_size, uint8_t *iv,
+	    size_t length, uint8_t *dst,
+	    const uint8_t *src)
+{
+  TMP_DECL(buffer, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE * 2);
+  TMP_DECL(outbuf, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE);
+  TMP_ALLOC(buffer, block_size * 2);
+  TMP_ALLOC(outbuf, block_size);
+  uint8_t pos;
+
+  memcpy(buffer, iv, block_size);
+  pos = 0;
+  while (length)
+    {
+      uint8_t t;
+
+      if (pos == block_size)
+	{
+	  memcpy(buffer, buffer + block_size, block_size);
+	  pos = 0;
+	}
+
+      f(ctx, block_size, outbuf, buffer + pos);
+      t = *(dst++) = *(src++) ^ outbuf[0];
+      buffer[pos + block_size] = t;
+      length--;
+      pos ++;
+    }
+  memcpy(iv, buffer + pos, block_size);
+}
+
+void
+cfb8_decrypt(const void *ctx, nettle_cipher_func *f,
+	     size_t block_size, uint8_t *iv,
+	     size_t length, uint8_t *dst,
+	     const uint8_t *src)
+{
+  TMP_DECL(buffer, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE * 2);
+  TMP_DECL(outbuf, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE * 2);
+  TMP_ALLOC(buffer, block_size * 2);
+  TMP_ALLOC(outbuf, block_size * 2);
+  uint8_t i = 0;
+
+  memcpy(buffer, iv, block_size);
+  memcpy(buffer + block_size, src,
+	 length &lt; block_size ? length : block_size);
+
+  while (length)
+    {
+
+      for (i = 0; i &lt; length &amp;&amp; i &lt; block_size; i++)
+	f(ctx, block_size, outbuf + i, buffer + i);
+
+      if (src != dst)
+	memxor3(dst, src, outbuf, i);
+      else
+	memxor(dst, outbuf, i);
+
+      length -= i;
+      src += i;
+      dst += i;
+
+      memcpy(buffer, buffer + block_size, block_size);
+      memcpy(buffer + block_size, src,
+	     length &lt; block_size ? length : block_size);
+
+    }
+
+  memcpy(iv, buffer + i, block_size);
+}
diff --git a/cfb.h b/cfb.h
index 16660df9b8ab..782ac133aa1c 100644
--- a/cfb.h
+++ b/cfb.h
@@ -45,6 +45,9 @@ extern "C" {
 #define cfb_encrypt nettle_cfb_encrypt
 #define cfb_decrypt nettle_cfb_decrypt
 
+#define cfb8_encrypt nettle_cfb8_encrypt
+#define cfb8_decrypt nettle_cfb8_decrypt
+
 void
 cfb_encrypt(const void *ctx, nettle_cipher_func *f,
 	    size_t block_size, uint8_t *iv,
@@ -57,12 +60,28 @@ cfb_decrypt(const void *ctx, nettle_cipher_func *f,
 	    size_t length, uint8_t *dst,
 	    const uint8_t *src);
 
+void
+cfb8_encrypt(const void *ctx, nettle_cipher_func *f,
+	     size_t block_size, uint8_t *iv,
+	     size_t length, uint8_t *dst,
+	     const uint8_t *src);
+
+void
+cfb8_decrypt(const void *ctx, nettle_cipher_func *f,
+	     size_t block_size, uint8_t *iv,
+	     size_t length, uint8_t *dst,
+	     const uint8_t *src);
+
+
 #define CFB_CTX(type, size) \
 { type ctx; uint8_t iv[size]; }
 
 #define CFB_SET_IV(ctx, data) \
 memcpy((ctx)-&gt;iv, (data), sizeof((ctx)-&gt;iv))
 
+#define CFB8_CTX CFB_CTX
+#define CFB8_SET_IV CFB_SET_IV
+
 /* NOTE: Avoid using NULL, as we don't include anything defining it. */
 #define CFB_ENCRYPT(self, f, length, dst, src)		\
   (0 ? ((f)(&amp;(self)-&gt;ctx, ~(size_t) 0,			\
@@ -80,6 +99,22 @@ memcpy((ctx)-&gt;iv, (data), sizeof((ctx)-&gt;iv))
 		 sizeof((self)-&gt;iv), (self)-&gt;iv,	\
 		 (length), (dst), (src)))
 
+#define CFB8_ENCRYPT(self, f, length, dst, src)		\
+  (0 ? ((f)(&amp;(self)-&gt;ctx, ~(size_t) 0,			\
+	    (uint8_t *) 0, (const uint8_t *) 0))	\
+   : cfb8_encrypt((void *) &amp;(self)-&gt;ctx,		\
+		  (nettle_cipher_func *) (f),		\
+		  sizeof((self)-&gt;iv), (self)-&gt;iv,	\
+		  (length), (dst), (src)))
+
+#define CFB8_DECRYPT(self, f, length, dst, src)		\
+  (0 ? ((f)(&amp;(self)-&gt;ctx, ~(size_t) 0,			\
+	    (uint8_t *) 0, (const uint8_t *) 0))	\
+   : cfb8_decrypt((void *) &amp;(self)-&gt;ctx,		\
+		  (nettle_cipher_func *) (f),		\
+		  sizeof((self)-&gt;iv), (self)-&gt;iv,	\
+		  (length), (dst), (src)))
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/nettle.texinfo b/nettle.texinfo
index aa374449c527..e610e74c79ab 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -94,6 +94,7 @@ Cipher modes
 * CBC::                         
 * CTR::                         
 * CFB::
+* CFB8::
 * GCM::                         
 * CCM::                         
 
@@ -1904,21 +1905,22 @@ Book mode, @acronym{ECB}), leaks information.
 
 Besides @acronym{ECB}, Nettle provides several other modes of operation:
 Cipher Block Chaining (@acronym{CBC}), Counter mode (@acronym{CTR}), Cipher
-Feedback (@acronym{CFB}) and a couple of @acronym{AEAD} modes
-(@pxref{Authenticated encryption}).  @acronym{CBC} is widely used, but
+Feedback (@acronym{CFB} and @acronym{CFB8}) and a couple of @acronym{AEAD}
+modes (@pxref{Authenticated encryption}).  @acronym{CBC} is widely used, but
 there are a few subtle issues of information leakage, see, e.g.,
 @uref{http://www.kb.cert.org/vuls/id/958563, @acronym{SSH} @acronym{CBC}
 vulnerability}. Today, @acronym{CTR} is usually preferred over @acronym{CBC}.
 
-Modes like @acronym{CBC}, @acronym{CTR} and @acronym{CFB} provide @emph{no}
-message authentication, and should always be used together with a
-@acronym{MAC} (@pxref{Keyed hash functions}) or signature to authenticate
-the message.
+Modes like @acronym{CBC}, @acronym{CTR}, @acronym{CFB} and @acronym{CFB8}
+provide @emph{no} message authentication, and should always be used together
+with a @acronym{MAC} (@pxref{Keyed hash functions}) or signature to
+authenticate the message.
 
 @menu
 * CBC::                         
 * CTR::                         
 * CFB::
+* CFB8::
 @end menu
 
 @node CBC, CTR, Cipher modes, Cipher modes
@@ -2090,7 +2092,7 @@ last three arguments define the source and destination area for \
the  operation.
 @end deffn
 
-@node CFB, , CTR, Cipher modes
+@node CFB, CFB8, CTR, Cipher modes
 @comment  node-name,  next,  previous,  up
 @subsection Cipher Feedback mode
 
@@ -2175,6 +2177,86 @@ last three arguments define the source and destination area \
for the  operation.
 @end deffn
 
+@node CFB8, , CFB, Cipher modes
+@comment  node-name,  next,  previous,  up
+@subsection Cipher Feedback 8-bit mode
+
+@cindex Cipher Feedback 8-bit Mode
+@cindex CFB8 Mode
+
+Cipher Feedback 8-bit mode (@acronym{CFB8}) transforms block cipher into a stream
+cipher. The message is encrypted byte after byte, not requiring any padding.
+
+If @code{E_k} is the encryption function of a block cipher, @code{b} is
+@code{E_k} block size, @code{IV} is the initialization vector, then the
+@code{n} plaintext bytes are transformed into @code{n} ciphertext bytes
+@code{C_1},@dots{} @code{C_n} as follows:
+
+@example
+I_1 = IV
+C_1 = E_k(I_1) [1..8] XOR M_1
+I_2 = I_1 [9..b] &lt;&lt; 8 | C_1
+C_2 = E_k(I_2) [1..8] XOR M_2
+
+@dots{}
+
+I_(n-1) = I_(n-2) [9..b] &lt;&lt; 8 | C_(n-2)
+C_(n-1) = E_k(I_(n-1)) [1..8] XOR M_(n-1)
+I_n = I_(n-1) [9..b] &lt;&lt; 8 | C_(n-1)
+C_n = E_k(I_n) [1..8] XOR M_n
+@end example
+
+Nettle's includes two functions for applying a block cipher in Cipher
+Feedback 8-bit (@acronym{CFB8}) mode, one for encryption and one for
+decryption. These functions uses @code{void *} to pass cipher contexts
+around.
+
+@deftypefun {void} cfb8_encrypt (const void *@var{ctx}, nettle_cipher_func *@var{f}, \
size_t @var{block_size}, uint8_t *@var{iv}, size_t @var{length}, uint8_t *@var{dst}, \
const uint8_t *@var{src}) +@deftypefunx {void} cfb8_decrypt (const void *@var{ctx}, \
nettle_cipher_func *@var{f}, size_t @var{block_size}, uint8_t *@var{iv}, size_t \
@var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +
+Applies the encryption or decryption function @var{f} in @acronym{CFB8}
+mode. The final IV block processed is copied into @var{iv}
+before returning, so that a large message can be processed by a sequence of
+calls to @code{cfb8_encrypt}. Note that for @acronym{CFB8} mode internally
+uses encryption only function and hence @var{f} should always be the
+encryption function for the underlying block cipher.
+
+@end deftypefun
+
+Like for @acronym{CBC}, there are also a couple of helper macros.
+
+@deffn Macro CFB8_CTX (@var{context_type}, @var{block_size})
+Expands to
+@example
+@{
+   context_type ctx;
+   uint8_t iv[block_size];
+@}
+@end example
+@end deffn
+
+@deffn Macro CFB8_SET_IV(@var{ctx}, @var{iv})
+First argument is a pointer to a context struct as defined by
+@code{CFB8_CTX}, and the second is a pointer to an initialization vector
+that is copied into that context.
+@end deffn
+
+@deffn Macro CFB8_ENCRYPT (@var{ctx}, @var{f}, @var{length}, @var{dst}, @var{src})
+A simpler way to invoke @code{cfb8_encrypt}. The first argument is a
+pointer to a context struct as defined by @code{CFB8_CTX}, and the
+second argument is an encryption function following Nettle's
+conventions. The last three arguments define the source and destination
+area for the operation.
+@end deffn
+
+@deffn Macro CFB8_DECRYPT (@var{ctx}, @var{f}, @var{length}, @var{dst}, @var{src})
+A simpler way to invoke @code{cfb8_decrypt}. The first argument is a
+pointer to a context struct as defined by @code{CFB8_CTX}, and the
+second argument is an encryption function following Nettle's
+conventions. The last three arguments define the source and destination
+area for the operation.
+@end deffn
+
 @node Authenticated encryption, Keyed hash functions, Cipher modes, Reference
 @comment  node-name,  next,  previous,  up
 
diff --git a/testsuite/cfb-test.c b/testsuite/cfb-test.c
index b59bee225bf8..b83233830b5a 100644
--- a/testsuite/cfb-test.c
+++ b/testsuite/cfb-test.c
@@ -6,6 +6,7 @@
 /* Test with more data and inplace decryption, to check that the
  * cfb_decrypt buffering works. */
 #define CFB_BULK_DATA 10000
+#define CFB8_BULK_DATA CFB_BULK_DATA
 
 static void
 test_cfb_bulk(void)
@@ -64,9 +65,110 @@ test_cfb_bulk(void)
   ASSERT (MEMEQ(CFB_BULK_DATA, clear, cipher));
 }
 
+static void
+test_cfb8_bulk(void)
+{
+  struct knuth_lfib_ctx random;
+
+  uint8_t clear[CFB8_BULK_DATA];
+
+  uint8_t cipher[CFB8_BULK_DATA + 1];
+
+  const uint8_t *key = H("966c7bf00bebe6dc 8abd37912384958a"
+			 "743008105a08657d dcaad4128eee38b3");
+
+  const uint8_t *start_iv = H("11adbff119749103 207619cfa0e8d13a");
+  const uint8_t *end_iv = H("f84bfd48206f5803 6ef86f4e69e9aec0");
+
+  struct CFB8_CTX(struct aes_ctx, AES_BLOCK_SIZE) aes;
+
+  knuth_lfib_init(&amp;random, CFB8_BULK_DATA);
+  knuth_lfib_random(&amp;random, CFB8_BULK_DATA, clear);
+
+  /* Byte that should not be overwritten */
+  cipher[CFB8_BULK_DATA] = 17;
+
+  aes_set_encrypt_key(&amp;aes.ctx, 32, key);
+  CFB8_SET_IV(&amp;aes, start_iv);
+
+  CFB8_ENCRYPT(&amp;aes, aes_encrypt, CFB8_BULK_DATA, cipher, clear);
+
+  ASSERT(cipher[CFB8_BULK_DATA] == 17);
+
+  if (verbose)
+    {
+      printf("IV after bulk encryption: ");
+      print_hex(AES_BLOCK_SIZE, aes.iv);
+      printf("\n");
+    }
+
+  ASSERT(MEMEQ(AES_BLOCK_SIZE, aes.iv, end_iv));
+
+  /* Decrypt, in place */
+  aes_set_encrypt_key(&amp;aes.ctx, 32, key);
+  CFB8_SET_IV(&amp;aes, start_iv);
+  CFB8_DECRYPT(&amp;aes, aes_encrypt, CFB8_BULK_DATA, cipher, cipher);
+
+  ASSERT(cipher[CFB8_BULK_DATA] == 17);
+
+  if (verbose)
+    {
+      printf("IV after bulk decryption: ");
+      print_hex(AES_BLOCK_SIZE, aes.iv);
+      printf("\n");
+    }
+
+  ASSERT (MEMEQ(AES_BLOCK_SIZE, aes.iv, end_iv));
+  ASSERT (MEMEQ(CFB8_BULK_DATA, clear, cipher));
+}
+
 void
 test_main(void)
 {
+  /* From NIST spec 800-38a on AES modes.
+   *
+   * F.3  CFB Example Vectors
+   * F.3.7 CFB8-AES128.Encrypt
+   */
+
+  test_cipher_cfb8(&amp;nettle_aes128,
+		   SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		   SHEX("6bc1bee22e409f96e93d7e117393172a"
+		        "ae2d"),
+		   SHEX("3b79424c9c0dd436bace9e0ed4586a4f"
+		        "32b9"),
+		   SHEX("000102030405060708090a0b0c0d0e0f"));
+
+  /* From NIST spec 800-38a on AES modes.
+   *
+   * F.3  CFB Example Vectors
+   * F.3.9 CFB8-AES192.Encrypt
+   */
+
+  test_cipher_cfb8(&amp;nettle_aes192,
+		   SHEX("8e73b0f7da0e6452c810f32b809079e5"
+			"62f8ead2522c6b7b"),
+		   SHEX("6bc1bee22e409f96e93d7e117393172a"
+		        "ae2d"),
+		   SHEX("cda2521ef0a905ca44cd057cbf0d47a0"
+			"678a"),
+		   SHEX("000102030405060708090a0b0c0d0e0f"));
+
+  /* From NIST spec 800-38a on AES modes.
+   *
+   * F.3  CFB Example Vectors
+   * F.3.11 CFB8-AES256.Encrypt
+   */
+
+  test_cipher_cfb8(&amp;nettle_aes256,
+		   SHEX("603deb1015ca71be2b73aef0857d7781"
+                        "1f352c073b6108d72d9810a30914dff4"),
+		   SHEX("6bc1bee22e409f96e93d7e117393172a"
+		        "ae2d"),
+		   SHEX("dc1f1a8520a64db55fcc8ac554844e88"
+			"9700"),
+		   SHEX("000102030405060708090a0b0c0d0e0f"));
+
   /* From NIST spec 800-38a on AES modes.
    *
    * F.3  CFB Example Vectors
@@ -139,6 +241,7 @@ test_main(void)
 		  SHEX("000102030405060708090a0b0c0d0e0f"));
 
   test_cfb_bulk();
+  test_cfb8_bulk();
 }
 
 /*
diff --git a/testsuite/testutils.c b/testsuite/testutils.c
index 08471958fbc0..5ee9eda35264 100644
--- a/testsuite/testutils.c
+++ b/testsuite/testutils.c
@@ -423,6 +423,184 @@ test_cipher_cfb(const struct nettle_cipher *cipher,
   free(iv);
 }
 
+void
+test_cipher_cfb8(const struct nettle_cipher *cipher,
+		 const struct tstring *key,
+		 const struct tstring *cleartext,
+		 const struct tstring *ciphertext,
+		 const struct tstring *iiv)
+{
+  void *ctx = xalloc(cipher-&gt;context_size);
+  uint8_t *data, *data2;
+  uint8_t *iv = xalloc(cipher-&gt;block_size);
+  size_t length;
+
+  ASSERT (cleartext-&gt;length == ciphertext-&gt;length);
+  length = cleartext-&gt;length;
+
+  ASSERT (key-&gt;length == cipher-&gt;key_size);
+  ASSERT (iiv-&gt;length == cipher-&gt;block_size);
+
+  data = xalloc(length);
+  data2 = xalloc(length);
+
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+
+  cfb8_encrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data, cleartext-&gt;data);
+
+  if (!MEMEQ(length, data, ciphertext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 encrypt failed:\nInput:");
+      tstring_print_hex(cleartext);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(ciphertext);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+
+  cfb8_decrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data2, data);
+
+  if (!MEMEQ(length, data2, cleartext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 decrypt failed:\nInput:");
+      tstring_print_hex(ciphertext);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data2);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(cleartext);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+  memcpy(data, cleartext-&gt;data, length);
+
+  cfb8_encrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data, data);
+
+  if (!MEMEQ(length, data, ciphertext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 inplace encrypt failed:\nInput:");
+      tstring_print_hex(cleartext);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(ciphertext);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+
+  cfb8_decrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data, data);
+
+  if (!MEMEQ(length, data, cleartext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 inplace decrypt failed:\nInput:");
+      tstring_print_hex(ciphertext);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(cleartext);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* Repeat all tests with incomplete last block */
+  length -= 1;
+
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+
+  cfb8_encrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data, cleartext-&gt;data);
+
+  if (!MEMEQ(length, data, ciphertext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 encrypt failed:\nInput:");
+      print_hex(length, cleartext-&gt;data);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      print_hex(length, ciphertext-&gt;data);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+
+  cfb8_decrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data2, data);
+
+  if (!MEMEQ(length, data2, cleartext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 decrypt failed:\nInput:");
+      print_hex(length, ciphertext-&gt;data);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data2);
+      fprintf(stderr, "\nExpected:");
+      print_hex(length, cleartext-&gt;data);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+  memcpy(data, cleartext-&gt;data, length);
+
+  cfb8_encrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data, data);
+
+  if (!MEMEQ(length, data, ciphertext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 inplace encrypt failed:\nInput:");
+      print_hex(length, cleartext-&gt;data);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      print_hex(length, ciphertext-&gt;data);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+
+  cfb8_decrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data, data);
+
+  if (!MEMEQ(length, data, cleartext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 inplace decrypt failed:\nInput:");
+      print_hex(length, ciphertext-&gt;data);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      print_hex(length, cleartext-&gt;data);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  free(ctx);
+  free(data);
+  free(data2);
+  free(iv);
+}
+
 void
 test_cipher_ctr(const struct nettle_cipher *cipher,
 		const struct tstring *key,
diff --git a/testsuite/testutils.h b/testsuite/testutils.h
index fbbba7b9fab5..ded57db6ab4f 100644
--- a/testsuite/testutils.h
+++ b/testsuite/testutils.h
@@ -129,6 +129,13 @@ test_cipher_cfb(const struct nettle_cipher *cipher,
 		const struct tstring *ciphertext,
 		const struct tstring *iv);
 
+void
+test_cipher_cfb8(const struct nettle_cipher *cipher,
+		 const struct tstring *key,
+		 const struct tstring *cleartext,
+		 const struct tstring *ciphertext,
+		 const struct tstring *iv);
+
 void
 test_cipher_ctr(const struct nettle_cipher *cipher,
 		const struct tstring *key,
-- 
2.15.1


</body></email><email><emailId>20180117141718</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-01-17 14:17:18-0400</timestampReceived><subject>[PATCH v2] Add CFB8 - Cipher Feedback 8-bit block cipher mode</subject><body>

Add CFB variant with 8-bit segment size.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 cfb.c                 |  72 ++++++++++++++++++++
 cfb.h                 |  35 ++++++++++
 nettle.texinfo        | 106 ++++++++++++++++++++++++------
 testsuite/cfb-test.c  | 103 +++++++++++++++++++++++++++++
 testsuite/testutils.c | 178 ++++++++++++++++++++++++++++++++++++++++++++++++++
 testsuite/testutils.h |   7 ++
 6 files changed, 482 insertions(+), 19 deletions(-)

---

	CFB8 support, contributed by Dmitry Eremin-Solenikov.
	* cfb.c (cfb8_encrypt, cfb8_decrypt): New functions.
	* cfb.h (CFB8_CTX, CFB8_SET_IV, CFB8_ENCRYPT, CFB8_DECRYPT): New
	macros.
	* testsuite/cfb-test.c: CFB8 test cases.
	* testsuite/testutils.c (test_cipher_cfb8): New function.
	* nettle.texinfo (CFB8): Documentation.

diff --git a/cfb.c b/cfb.c
index 805b8c4533a0..19cba4b5ba5d 100644
--- a/cfb.c
+++ b/cfb.c
@@ -162,3 +162,75 @@ cfb_decrypt(const void *ctx, nettle_cipher_func *f,
 	}
     }
 }
+
+/* CFB-8 uses slight optimization: it encrypts or decrypts up to block_size
+ * bytes and does memcpy/memxor afterwards */
+void
+cfb8_encrypt(const void *ctx, nettle_cipher_func *f,
+	    size_t block_size, uint8_t *iv,
+	    size_t length, uint8_t *dst,
+	    const uint8_t *src)
+{
+  TMP_DECL(buffer, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE * 2);
+  TMP_DECL(outbuf, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE);
+  TMP_ALLOC(buffer, block_size * 2);
+  TMP_ALLOC(outbuf, block_size);
+  uint8_t pos;
+
+  memcpy(buffer, iv, block_size);
+  pos = 0;
+  while (length)
+    {
+      uint8_t t;
+
+      if (pos == block_size)
+	{
+	  memcpy(buffer, buffer + block_size, block_size);
+	  pos = 0;
+	}
+
+      f(ctx, block_size, outbuf, buffer + pos);
+      t = *(dst++) = *(src++) ^ outbuf[0];
+      buffer[pos + block_size] = t;
+      length--;
+      pos ++;
+    }
+  memcpy(iv, buffer + pos, block_size);
+}
+
+void
+cfb8_decrypt(const void *ctx, nettle_cipher_func *f,
+	     size_t block_size, uint8_t *iv,
+	     size_t length, uint8_t *dst,
+	     const uint8_t *src)
+{
+  TMP_DECL(buffer, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE * 2);
+  TMP_DECL(outbuf, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE * 2);
+  TMP_ALLOC(buffer, block_size * 2);
+  TMP_ALLOC(outbuf, block_size * 2);
+  uint8_t i = 0;
+
+  memcpy(buffer, iv, block_size);
+  memcpy(buffer + block_size, src,
+	 length &lt; block_size ? length : block_size);
+
+  while (length)
+    {
+
+      for (i = 0; i &lt; length &amp;&amp; i &lt; block_size; i++)
+	f(ctx, block_size, outbuf + i, buffer + i);
+
+      memxor3(dst, src, outbuf, i);
+
+      length -= i;
+      src += i;
+      dst += i;
+
+      memcpy(buffer, buffer + block_size, block_size);
+      memcpy(buffer + block_size, src,
+	     length &lt; block_size ? length : block_size);
+
+    }
+
+  memcpy(iv, buffer + i, block_size);
+}
diff --git a/cfb.h b/cfb.h
index 16660df9b8ab..782ac133aa1c 100644
--- a/cfb.h
+++ b/cfb.h
@@ -45,6 +45,9 @@ extern "C" {
 #define cfb_encrypt nettle_cfb_encrypt
 #define cfb_decrypt nettle_cfb_decrypt
 
+#define cfb8_encrypt nettle_cfb8_encrypt
+#define cfb8_decrypt nettle_cfb8_decrypt
+
 void
 cfb_encrypt(const void *ctx, nettle_cipher_func *f,
 	    size_t block_size, uint8_t *iv,
@@ -57,12 +60,28 @@ cfb_decrypt(const void *ctx, nettle_cipher_func *f,
 	    size_t length, uint8_t *dst,
 	    const uint8_t *src);
 
+void
+cfb8_encrypt(const void *ctx, nettle_cipher_func *f,
+	     size_t block_size, uint8_t *iv,
+	     size_t length, uint8_t *dst,
+	     const uint8_t *src);
+
+void
+cfb8_decrypt(const void *ctx, nettle_cipher_func *f,
+	     size_t block_size, uint8_t *iv,
+	     size_t length, uint8_t *dst,
+	     const uint8_t *src);
+
+
 #define CFB_CTX(type, size) \
 { type ctx; uint8_t iv[size]; }
 
 #define CFB_SET_IV(ctx, data) \
 memcpy((ctx)-&gt;iv, (data), sizeof((ctx)-&gt;iv))
 
+#define CFB8_CTX CFB_CTX
+#define CFB8_SET_IV CFB_SET_IV
+
 /* NOTE: Avoid using NULL, as we don't include anything defining it. */
 #define CFB_ENCRYPT(self, f, length, dst, src)		\
   (0 ? ((f)(&amp;(self)-&gt;ctx, ~(size_t) 0,			\
@@ -80,6 +99,22 @@ memcpy((ctx)-&gt;iv, (data), sizeof((ctx)-&gt;iv))
 		 sizeof((self)-&gt;iv), (self)-&gt;iv,	\
 		 (length), (dst), (src)))
 
+#define CFB8_ENCRYPT(self, f, length, dst, src)		\
+  (0 ? ((f)(&amp;(self)-&gt;ctx, ~(size_t) 0,			\
+	    (uint8_t *) 0, (const uint8_t *) 0))	\
+   : cfb8_encrypt((void *) &amp;(self)-&gt;ctx,		\
+		  (nettle_cipher_func *) (f),		\
+		  sizeof((self)-&gt;iv), (self)-&gt;iv,	\
+		  (length), (dst), (src)))
+
+#define CFB8_DECRYPT(self, f, length, dst, src)		\
+  (0 ? ((f)(&amp;(self)-&gt;ctx, ~(size_t) 0,			\
+	    (uint8_t *) 0, (const uint8_t *) 0))	\
+   : cfb8_decrypt((void *) &amp;(self)-&gt;ctx,		\
+		  (nettle_cipher_func *) (f),		\
+		  sizeof((self)-&gt;iv), (self)-&gt;iv,	\
+		  (length), (dst), (src)))
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/nettle.texinfo b/nettle.texinfo
index aa374449c527..f501cfbeb2d7 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -93,7 +93,7 @@ Cipher modes
 
 * CBC::                         
 * CTR::                         
-* CFB::
+* CFB and CFB8::
 * GCM::                         
 * CCM::                         
 
@@ -1904,21 +1904,21 @@ Book mode, @acronym{ECB}), leaks information.
 
 Besides @acronym{ECB}, Nettle provides several other modes of operation:
 Cipher Block Chaining (@acronym{CBC}), Counter mode (@acronym{CTR}), Cipher
-Feedback (@acronym{CFB}) and a couple of @acronym{AEAD} modes
-(@pxref{Authenticated encryption}).  @acronym{CBC} is widely used, but
+Feedback (@acronym{CFB} and @acronym{CFB8}) and a couple of @acronym{AEAD}
+modes (@pxref{Authenticated encryption}).  @acronym{CBC} is widely used, but
 there are a few subtle issues of information leakage, see, e.g.,
 @uref{http://www.kb.cert.org/vuls/id/958563, @acronym{SSH} @acronym{CBC}
 vulnerability}. Today, @acronym{CTR} is usually preferred over @acronym{CBC}.
 
-Modes like @acronym{CBC}, @acronym{CTR} and @acronym{CFB} provide @emph{no}
-message authentication, and should always be used together with a
-@acronym{MAC} (@pxref{Keyed hash functions}) or signature to authenticate
-the message.
+Modes like @acronym{CBC}, @acronym{CTR}, @acronym{CFB} and @acronym{CFB8}
+provide @emph{no} message authentication, and should always be used together
+with a @acronym{MAC} (@pxref{Keyed hash functions}) or signature to
+authenticate the message.
 
 @menu
 * CBC::                         
 * CTR::                         
-* CFB::
+* CFB and CFB8::
 @end menu
 
 @node CBC, CTR, Cipher modes, Cipher modes
@@ -2014,7 +2014,7 @@ These macros use some tricks to make the compiler display a \
warning if  the types of @var{f} and @var{ctx} don't match, e.g. if you try to use
 an @code{struct aes_ctx} context with the @code{des_encrypt} function.
 
-@node CTR, CFB, CBC, Cipher modes
+@node CTR, CFB and CFB8, CBC, Cipher modes
 @comment  node-name,  next,  previous,  up
 @subsection Counter mode
 
@@ -2090,18 +2090,21 @@ last three arguments define the source and destination area \
for the  operation.
 @end deffn
 
-@node CFB, , CTR, Cipher modes
+@node CFB and CFB8, , CTR, Cipher modes
 @comment  node-name,  next,  previous,  up
 @subsection Cipher Feedback mode
 
 @cindex Cipher Feedback Mode
-@cindex CFB Mode
+@cindex Cipher Feedback 8-bit Mode
+@cindex CFB Modes
+@cindex CFB8 Mode
 
-Cipher Feedback mode (@acronym{CFB}) being a close relative to both
-@acronym{CBC} mode and @acronym{CTR} mode borrows some characteristics
-from stream ciphers.
 
-The message is divided into @code{n} blocks @code{M_1},@dots{}
+Cipher Feedback mode (@acronym{CFB}) and Cipher Feedback 8-bit mode
+(@acronym{CFB8}) being close relatives to both @acronym{CBC} mode and
+@acronym{CTR} mode borrow some characteristics from stream ciphers.
+
+For CFB the message is divided into @code{n} blocks @code{M_1},@dots{}
 @code{M_n}, where @code{M_n} is of size @code{m} which may be smaller
 than the block size. Except for the last block, all the message blocks
 must be of size equal to the cipher's block size.
@@ -2121,10 +2124,31 @@ C_(n-1) = E_k(C_(n - 2)) XOR M_(n-1)
 C_n = E_k(C_(n - 1)) [1..m] XOR M_n
 @end example
 
-Nettle's includes two functions for applying a block cipher in Cipher
-Feedback (@acronym{CFB}) mode, one for encryption and one for
-decryption. These functions uses @code{void *} to pass cipher contexts
-around.
+Cipher Feedback 8-bit mode (@acronym{CFB8}) transforms block cipher into a stream
+cipher. The message is encrypted byte after byte, not requiring any padding.
+
+If @code{E_k} is the encryption function of a block cipher, @code{b} is
+@code{E_k} block size, @code{IV} is the initialization vector, then the
+@code{n} plaintext bytes are transformed into @code{n} ciphertext bytes
+@code{C_1},@dots{} @code{C_n} as follows:
+
+@example
+I_1 = IV
+C_1 = E_k(I_1) [1..8] XOR M_1
+I_2 = I_1 [9..b] &lt;&lt; 8 | C_1
+C_2 = E_k(I_2) [1..8] XOR M_2
+
+@dots{}
+
+I_(n-1) = I_(n-2) [9..b] &lt;&lt; 8 | C_(n-2)
+C_(n-1) = E_k(I_(n-1)) [1..8] XOR M_(n-1)
+I_n = I_(n-1) [9..b] &lt;&lt; 8 | C_(n-1)
+C_n = E_k(I_n) [1..8] XOR M_n
+@end example
+
+Nettle's includes functions for applying a block cipher in Cipher
+Feedback (@acronym{CFB}) and Cipher Feedback 8-bit (@acronym{CFB8})
+modes. These functions uses @code{void *} to pass cipher contexts around.
 
 @deftypefun {void} cfb_encrypt (const void *@var{ctx}, nettle_cipher_func *@var{f}, \
size_t @var{block_size}, uint8_t *@var{iv}, size_t @var{length}, uint8_t *@var{dst}, \
const uint8_t *@var{src})  @deftypefunx {void} cfb_decrypt (const void *@var{ctx}, \
nettle_cipher_func *@var{f}, size_t @var{block_size}, uint8_t *@var{iv}, size_t \
@var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) @@ -2141,6 +2165,18 @@ \
When a message is encrypted using a sequence of calls to  is a multiple of the block \
size.  @end deftypefun
 
+@deftypefun {void} cfb8_encrypt (const void *@var{ctx}, nettle_cipher_func *@var{f}, \
size_t @var{block_size}, uint8_t *@var{iv}, size_t @var{length}, uint8_t *@var{dst}, \
const uint8_t *@var{src}) +@deftypefunx {void} cfb8_decrypt (const void *@var{ctx}, \
nettle_cipher_func *@var{f}, size_t @var{block_size}, uint8_t *@var{iv}, size_t \
@var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +
+Applies the encryption or decryption function @var{f} in @acronym{CFB8}
+mode. The final IV block processed is copied into @var{iv}
+before returning, so that a large message can be processed by a sequence of
+calls to @code{cfb8_encrypt}. Note that for @acronym{CFB8} mode internally
+uses encryption only function and hence @var{f} should always be the
+encryption function for the underlying block cipher.
+
+@end deftypefun
+
 Like for @acronym{CBC}, there are also a couple of helper macros.
 
 @deffn Macro CFB_CTX (@var{context_type}, @var{block_size})
@@ -2175,6 +2211,38 @@ last three arguments define the source and destination area \
for the  operation.
 @end deffn
 
+@deffn Macro CFB8_CTX (@var{context_type}, @var{block_size})
+Expands to
+@example
+@{
+   context_type ctx;
+   uint8_t iv[block_size];
+@}
+@end example
+@end deffn
+
+@deffn Macro CFB8_SET_IV(@var{ctx}, @var{iv})
+First argument is a pointer to a context struct as defined by
+@code{CFB8_CTX}, and the second is a pointer to an initialization vector
+that is copied into that context.
+@end deffn
+
+@deffn Macro CFB8_ENCRYPT (@var{ctx}, @var{f}, @var{length}, @var{dst}, @var{src})
+A simpler way to invoke @code{cfb8_encrypt}. The first argument is a
+pointer to a context struct as defined by @code{CFB8_CTX}, and the
+second argument is an encryption function following Nettle's
+conventions. The last three arguments define the source and destination
+area for the operation.
+@end deffn
+
+@deffn Macro CFB8_DECRYPT (@var{ctx}, @var{f}, @var{length}, @var{dst}, @var{src})
+A simpler way to invoke @code{cfb8_decrypt}. The first argument is a
+pointer to a context struct as defined by @code{CFB8_CTX}, and the
+second argument is an encryption function following Nettle's
+conventions. The last three arguments define the source and destination
+area for the operation.
+@end deffn
+
 @node Authenticated encryption, Keyed hash functions, Cipher modes, Reference
 @comment  node-name,  next,  previous,  up
 
diff --git a/testsuite/cfb-test.c b/testsuite/cfb-test.c
index b59bee225bf8..b83233830b5a 100644
--- a/testsuite/cfb-test.c
+++ b/testsuite/cfb-test.c
@@ -6,6 +6,7 @@
 /* Test with more data and inplace decryption, to check that the
  * cfb_decrypt buffering works. */
 #define CFB_BULK_DATA 10000
+#define CFB8_BULK_DATA CFB_BULK_DATA
 
 static void
 test_cfb_bulk(void)
@@ -64,9 +65,110 @@ test_cfb_bulk(void)
   ASSERT (MEMEQ(CFB_BULK_DATA, clear, cipher));
 }
 
+static void
+test_cfb8_bulk(void)
+{
+  struct knuth_lfib_ctx random;
+
+  uint8_t clear[CFB8_BULK_DATA];
+
+  uint8_t cipher[CFB8_BULK_DATA + 1];
+
+  const uint8_t *key = H("966c7bf00bebe6dc 8abd37912384958a"
+			 "743008105a08657d dcaad4128eee38b3");
+
+  const uint8_t *start_iv = H("11adbff119749103 207619cfa0e8d13a");
+  const uint8_t *end_iv = H("f84bfd48206f5803 6ef86f4e69e9aec0");
+
+  struct CFB8_CTX(struct aes_ctx, AES_BLOCK_SIZE) aes;
+
+  knuth_lfib_init(&amp;random, CFB8_BULK_DATA);
+  knuth_lfib_random(&amp;random, CFB8_BULK_DATA, clear);
+
+  /* Byte that should not be overwritten */
+  cipher[CFB8_BULK_DATA] = 17;
+
+  aes_set_encrypt_key(&amp;aes.ctx, 32, key);
+  CFB8_SET_IV(&amp;aes, start_iv);
+
+  CFB8_ENCRYPT(&amp;aes, aes_encrypt, CFB8_BULK_DATA, cipher, clear);
+
+  ASSERT(cipher[CFB8_BULK_DATA] == 17);
+
+  if (verbose)
+    {
+      printf("IV after bulk encryption: ");
+      print_hex(AES_BLOCK_SIZE, aes.iv);
+      printf("\n");
+    }
+
+  ASSERT(MEMEQ(AES_BLOCK_SIZE, aes.iv, end_iv));
+
+  /* Decrypt, in place */
+  aes_set_encrypt_key(&amp;aes.ctx, 32, key);
+  CFB8_SET_IV(&amp;aes, start_iv);
+  CFB8_DECRYPT(&amp;aes, aes_encrypt, CFB8_BULK_DATA, cipher, cipher);
+
+  ASSERT(cipher[CFB8_BULK_DATA] == 17);
+
+  if (verbose)
+    {
+      printf("IV after bulk decryption: ");
+      print_hex(AES_BLOCK_SIZE, aes.iv);
+      printf("\n");
+    }
+
+  ASSERT (MEMEQ(AES_BLOCK_SIZE, aes.iv, end_iv));
+  ASSERT (MEMEQ(CFB8_BULK_DATA, clear, cipher));
+}
+
 void
 test_main(void)
 {
+  /* From NIST spec 800-38a on AES modes.
+   *
+   * F.3  CFB Example Vectors
+   * F.3.7 CFB8-AES128.Encrypt
+   */
+
+  test_cipher_cfb8(&amp;nettle_aes128,
+		   SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		   SHEX("6bc1bee22e409f96e93d7e117393172a"
+		        "ae2d"),
+		   SHEX("3b79424c9c0dd436bace9e0ed4586a4f"
+		        "32b9"),
+		   SHEX("000102030405060708090a0b0c0d0e0f"));
+
+  /* From NIST spec 800-38a on AES modes.
+   *
+   * F.3  CFB Example Vectors
+   * F.3.9 CFB8-AES192.Encrypt
+   */
+
+  test_cipher_cfb8(&amp;nettle_aes192,
+		   SHEX("8e73b0f7da0e6452c810f32b809079e5"
+			"62f8ead2522c6b7b"),
+		   SHEX("6bc1bee22e409f96e93d7e117393172a"
+		        "ae2d"),
+		   SHEX("cda2521ef0a905ca44cd057cbf0d47a0"
+			"678a"),
+		   SHEX("000102030405060708090a0b0c0d0e0f"));
+
+  /* From NIST spec 800-38a on AES modes.
+   *
+   * F.3  CFB Example Vectors
+   * F.3.11 CFB8-AES256.Encrypt
+   */
+
+  test_cipher_cfb8(&amp;nettle_aes256,
+		   SHEX("603deb1015ca71be2b73aef0857d7781"
+                        "1f352c073b6108d72d9810a30914dff4"),
+		   SHEX("6bc1bee22e409f96e93d7e117393172a"
+		        "ae2d"),
+		   SHEX("dc1f1a8520a64db55fcc8ac554844e88"
+			"9700"),
+		   SHEX("000102030405060708090a0b0c0d0e0f"));
+
   /* From NIST spec 800-38a on AES modes.
    *
    * F.3  CFB Example Vectors
@@ -139,6 +241,7 @@ test_main(void)
 		  SHEX("000102030405060708090a0b0c0d0e0f"));
 
   test_cfb_bulk();
+  test_cfb8_bulk();
 }
 
 /*
diff --git a/testsuite/testutils.c b/testsuite/testutils.c
index 08471958fbc0..5ee9eda35264 100644
--- a/testsuite/testutils.c
+++ b/testsuite/testutils.c
@@ -423,6 +423,184 @@ test_cipher_cfb(const struct nettle_cipher *cipher,
   free(iv);
 }
 
+void
+test_cipher_cfb8(const struct nettle_cipher *cipher,
+		 const struct tstring *key,
+		 const struct tstring *cleartext,
+		 const struct tstring *ciphertext,
+		 const struct tstring *iiv)
+{
+  void *ctx = xalloc(cipher-&gt;context_size);
+  uint8_t *data, *data2;
+  uint8_t *iv = xalloc(cipher-&gt;block_size);
+  size_t length;
+
+  ASSERT (cleartext-&gt;length == ciphertext-&gt;length);
+  length = cleartext-&gt;length;
+
+  ASSERT (key-&gt;length == cipher-&gt;key_size);
+  ASSERT (iiv-&gt;length == cipher-&gt;block_size);
+
+  data = xalloc(length);
+  data2 = xalloc(length);
+
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+
+  cfb8_encrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data, cleartext-&gt;data);
+
+  if (!MEMEQ(length, data, ciphertext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 encrypt failed:\nInput:");
+      tstring_print_hex(cleartext);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(ciphertext);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+
+  cfb8_decrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data2, data);
+
+  if (!MEMEQ(length, data2, cleartext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 decrypt failed:\nInput:");
+      tstring_print_hex(ciphertext);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data2);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(cleartext);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+  memcpy(data, cleartext-&gt;data, length);
+
+  cfb8_encrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data, data);
+
+  if (!MEMEQ(length, data, ciphertext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 inplace encrypt failed:\nInput:");
+      tstring_print_hex(cleartext);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(ciphertext);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+
+  cfb8_decrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data, data);
+
+  if (!MEMEQ(length, data, cleartext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 inplace decrypt failed:\nInput:");
+      tstring_print_hex(ciphertext);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(cleartext);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* Repeat all tests with incomplete last block */
+  length -= 1;
+
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+
+  cfb8_encrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data, cleartext-&gt;data);
+
+  if (!MEMEQ(length, data, ciphertext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 encrypt failed:\nInput:");
+      print_hex(length, cleartext-&gt;data);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      print_hex(length, ciphertext-&gt;data);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+
+  cfb8_decrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data2, data);
+
+  if (!MEMEQ(length, data2, cleartext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 decrypt failed:\nInput:");
+      print_hex(length, ciphertext-&gt;data);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data2);
+      fprintf(stderr, "\nExpected:");
+      print_hex(length, cleartext-&gt;data);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+  memcpy(data, cleartext-&gt;data, length);
+
+  cfb8_encrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data, data);
+
+  if (!MEMEQ(length, data, ciphertext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 inplace encrypt failed:\nInput:");
+      print_hex(length, cleartext-&gt;data);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      print_hex(length, ciphertext-&gt;data);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+
+  cfb8_decrypt(ctx, cipher-&gt;encrypt,
+	      cipher-&gt;block_size, iv,
+	      length, data, data);
+
+  if (!MEMEQ(length, data, cleartext-&gt;data))
+    {
+      fprintf(stderr, "CFB8 inplace decrypt failed:\nInput:");
+      print_hex(length, ciphertext-&gt;data);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      print_hex(length, cleartext-&gt;data);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  free(ctx);
+  free(data);
+  free(data2);
+  free(iv);
+}
+
 void
 test_cipher_ctr(const struct nettle_cipher *cipher,
 		const struct tstring *key,
diff --git a/testsuite/testutils.h b/testsuite/testutils.h
index fbbba7b9fab5..ded57db6ab4f 100644
--- a/testsuite/testutils.h
+++ b/testsuite/testutils.h
@@ -129,6 +129,13 @@ test_cipher_cfb(const struct nettle_cipher *cipher,
 		const struct tstring *ciphertext,
 		const struct tstring *iv);
 
+void
+test_cipher_cfb8(const struct nettle_cipher *cipher,
+		 const struct tstring *key,
+		 const struct tstring *cleartext,
+		 const struct tstring *ciphertext,
+		 const struct tstring *iv);
+
 void
 test_cipher_ctr(const struct nettle_cipher *cipher,
 		const struct tstring *key,
-- 
2.15.1


</body></email><email><emailId>20180109214423</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-09 21:44:23-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

Daiki Ueno &lt;ueno@gnu.org&gt; writes:

&gt; Thank you for the suggestions and sorry for the shameless delay.

No problem, I'm also quite slow. I think there are three main pieces
left to integrate.

1. Curve operations to support Curve448 (i.e., diffie-hellman
   operations). I have made some progress, on my curve448 branch,

2. SHAKE 128/256. I think I had some question on the interface design.

3. EdDSA 448.

Optimization of the mod p arithmetic isn't that important yet, but I'll
nevertheless try to explain how I think about it.

&gt; Due to my ignorance, I probably don't get what you mean, but as far as I
&gt; read the implementations of other curves in Nettle, some of them seem to
&gt; use the property of generalized Mersenne numbers described in:
&gt; http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.2133
&gt; and it's also applicable to the Curve448 prime.

The way I think about it, we have p = 2^448 - 2^224 - 1. This implies
that

   2^448 = 2^224 + 1 (mod p)

(since a = b (mod p) means that a - b is a multiple of p, and in this
case, the difference between left and right hand is exactly p).

&gt; So a 896-bit product here:
&gt;
&gt;   a0 + a1 * 2^k + a2 * 2^2k + a3 * 2^3k (k = 224)

And in this notation, 2^2k = 2^k + 1 (mod p) and 2^3k = 2^2k + 2^k (mod p). If
we use these relations to replace the high powers of two, we get
precisely your formulas:

&gt; can be reduced to:
&gt;
&gt;   b0 + b1 * 2^k (mod p)
&gt;
&gt; through modular additions of the smaller numbers:
&gt;
&gt;   b0 = a0 + a2 + a3 (mod p)
&gt;   b1 = a1 + a2 + a3 + a3 (mod p)

I'm not sure what's the best way to organize this. I suggested doing it
in two steps, first reduce the high three chunks to two and leave a0 unchanged:

    a1 +              a2 2^k + a3 2^2k 
 = (a1 + a3) + (a2 + a3) 2^k
 =  b1 +             b_2 2^k  (mod p)

where we can do the carry propagation and carry wrap-around to get b0
and b1 as 224-bit numbers.

And then repeat the same procedure once more

    a0 +              b1 2^k + b2 2^2k 
 = (a0 + b2) + (b1 + b2) 2^k
 =  c0 +              c1 2^k

This is going to work out nicely on 32-bit platforms. For 64-bit, one
should get better performance the more shift operations can be avoided,
and your variant might be faster then the above. 

On the other hand, for assembly implementation keeping values in
registers, the two step way needs fewer registers, since loading the
lowest limbs can be postponed until after the higher order limbs are
eliminated and no longer need any registers.

Looking at your formulas,

&gt;   b0 = a0 + a2 + a3 (mod p)
&gt;   b1 = a1 + a2 + a3 + a3 (mod p)

I think it should be possible to implement with only a single 7-limb
shift: In the b0 formula, only a3 needs shifting, a0 and a2 are already
at the right position. And in the b1 formula, a1 and a2 are at the right
position, but a2 needs a shift. I think I'd try the following:

1. Do the additions a0 += a2, a1 += a3, which I think can be done as a
   single 7-limb add, with plain carry propagation between the pieces.
   Carry out can be folded immediately, or saved for later.

2. Do the second a1 += a3 (needs some masking to extract the a3 bits,
   but no shift). Or maybe skip the masking, and handle the low 32 bits
   of a3 some other way.

3. Do an in-place 32-bit left shift of a2, a3.

4. Add the shifted terms, a0 += a3, a1 += a2. This gets even better if
   we make the a2, a3 shift above a rotate storing the shifted out high
   bits of a3 back at the position of the low bits of a2.

5. Do final carry handling.

There's no need to try to find the optimal reduction strategy right
away, though, other missing pieces are more important.

&gt; I tried to implement it (as attached) and got 20-30% speed-up with
&gt; mini-gmp.

For good test coverage of these functions, I recommend building with the real gmp (to get access to
its mpz_rrandomb function), and then let

  while NETTLE_TEST_SEED=0 ./ecc-mod-test ; do : ; done

run over night. And possibly also hacking ecc_mod_test.c to only test
the curve of interest.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180104141614</emailId><senderName>blargh</senderName><senderEmail>youp1one1@gmail.com</senderEmail><timestampReceived>2018-01-04 14:16:14-0400</timestampReceived><subject>Build system bug with assembler and clang</subject><body>

Hi,

I've been building nettle with Clang from a generated toolchain with the 
latest Android NDK (16b).

Form architecture with available assembler code (x86 in particular), 
compilation fails because the generated asm is not compatible with clang.
So I use --disable-assembler, thinking it would fix the problem. But it 
still fails (see log below):

The workaround has been to entirely disable (comment) the asm rule in 
Makefile.in:


#.asm.$(OBJEXT): $(srcdir)/asm.m4 machine.m4 config.m4
#       $(M4) $(srcdir)/asm.m4 machine.m4 config.m4 $&lt; &gt;$*.s
#       $(COMPILE) -c $*.s
#       @echo "$@ : $&lt; $(srcdir)/asm.m4 machine.m4 config.m4" &gt;$@.d


For some reason, this rule generates asm files even when 
--disable-assembler is specified and it gets in the way later in the build.

The proper fix would be to make sure this rule never kicks in with 
--disable-assembler.
And also maybe force --disable-assembler when clang is the compiler, or 
update the asm generation macro (asm.m4)
to produce .s files compatible with clang.


/////////


   Version:           nettle 3.4
   Host type:         x86-unknown-none
   ABI:               standard
   Assembly files:    none
   Install prefix: /home/bobbie/ffmpeg-android-3.4.1/toolchain-android
   Library directory: ${exec_prefix}/lib
   Compiler: 
/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/bin/i686-linux-android-clang 
--sysroot=/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/sysroot
   Static libraries:  yes
   Shared libraries:  no
   Public key crypto: yes
   Using mini-gmp:    no
   Documentation:     no

make install-here
make[1]: Entering directory `/home/bobbie/ffmpeg-android-3.4.1/nettle-3.4'
/bin/mkdir -p 
/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/include/nettle
/usr/bin/m4 ./asm.m4 machine.m4 config.m4 aes-decrypt-internal.asm 
 &gt;aes-decrypt-internal.s
/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/bin/i686-linux-android-clang 
--sysroot=/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/sysroot 
-I.  -DHAVE_CONFIG_H 
-I/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/include -ggdb3 
-Wall -W   -Wmissing-prototypes -Wmissing-declarations 
-Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast 
-Wnested-externs -fpic -MT aes-decrypt.o -MD -MP -MF aes-decrypt.o.d -c 
aes-decrypt.c \
     &amp;&amp; true
for f in aes.h arcfour.h arctwo.h asn1.h blowfish.h base16.h base64.h 
bignum.h buffer.h camellia.h cast128.h cbc.h ccm.h cfb.h chacha.h 
chacha-poly1305.h ctr.h curve25519.h des.h des-compat.h dsa.h 
dsa-compat.h eax.h ecc-curve.h ecc.h ecdsa.h eddsa.h gcm.h gosthash94.h 
hmac.h knuth-lfib.h hkdf.h macros.h md2.h md4.h md5.h md5-compat.h 
memops.h memxor.h nettle-meta.h nettle-types.h pbkdf2.h pgp.h pkcs1.h 
pss.h pss-mgf1.h realloc.h ripemd160.h rsa.h salsa20.h sexp.h serpent.h 
sha.h sha1.h sha2.h sha3.h twofish.h umac.h yarrow.h poly1305.h 
nettle-stdint.h version.h  ; do \
       if [ -f "$f" ] ; then \
         /usr/bin/install -c -m 644 "$f" 
/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/include/nettle ; \
       else \
         /usr/bin/install -c -m 644 "./$f" 
/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/include/nettle ; \
       fi ; done
/usr/bin/m4 ./asm.m4 machine.m4 config.m4 aes-encrypt-internal.asm 
 &gt;aes-encrypt-internal.s
/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/bin/i686-linux-android-clang 
--sysroot=/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/sysroot 
-I.  -DHAVE_CONFIG_H 
-I/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/include -ggdb3 
-Wall -W   -Wmissing-prototypes -Wmissing-declarations 
-Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast 
-Wnested-externs -fpic -MT aes-encrypt.o -MD -MP -MF aes-encrypt.o.d -c 
aes-encrypt.c \
     &amp;&amp; true
/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/bin/i686-linux-android-clang 
--sysroot=/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/sysroot 
-I.  -DHAVE_CONFIG_H 
-I/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/include -ggdb3 
-Wall -W   -Wmissing-prototypes -Wmissing-declarations 
-Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast 
-Wnested-externs -fpic -MT aes-encrypt-table.o -MD -MP -MF 
aes-encrypt-table.o.d -c aes-encrypt-table.c \
     &amp;&amp; true
/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/bin/i686-linux-android-clang 
--sysroot=/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/sysroot 
-I.  -DHAVE_CONFIG_H 
-I/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/include -ggdb3 
-Wall -W   -Wmissing-prototypes -Wmissing-declarations 
-Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast 
-Wnested-externs -fpic -MT aes-invert-internal.o -MD -MP -MF 
aes-invert-internal.o.d -c aes-invert-internal.c \
     &amp;&amp; true
/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/bin/i686-linux-android-clang 
--sysroot=/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/sysroot 
-I.  -DHAVE_CONFIG_H 
-I/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/include -ggdb3 
-Wall -W   -Wmissing-prototypes -Wmissing-declarations 
-Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast 
-Wnested-externs -fpic -MT aes-set-key-internal.o -MD -MP -MF 
aes-set-key-internal.o.d -c aes-set-key-internal.c \
     &amp;&amp; true
/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/bin/i686-linux-android-clang 
--sysroot=/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/sysroot 
-I.  -DHAVE_CONFIG_H 
-I/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/include -ggdb3 
-Wall -W   -Wmissing-prototypes -Wmissing-declarations 
-Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast 
-Wnested-externs -fpic -MT aes-decrypt-internal.o -MD -MP -MF 
aes-decrypt-internal.o.d -c aes-decrypt-internal.s
/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/bin/i686-linux-android-clang 
--sysroot=/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/sysroot 
-I.  -DHAVE_CONFIG_H 
-I/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/include -ggdb3 
-Wall -W   -Wmissing-prototypes -Wmissing-declarations 
-Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast 
-Wnested-externs -fpic -MT aes-encrypt-internal.o -MD -MP -MF 
aes-encrypt-internal.o.d -c aes-encrypt-internal.s
/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/bin/i686-linux-android-clang 
--sysroot=/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/sysroot 
-I.  -DHAVE_CONFIG_H 
-I/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/include -ggdb3 
-Wall -W   -Wmissing-prototypes -Wmissing-declarations 
-Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast 
-Wnested-externs -fpic -MT aes-set-encrypt-key.o -MD -MP -MF 
aes-set-encrypt-key.o.d -c aes-set-encrypt-key.c \
     &amp;&amp; true
clang50/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/bin/i686-linux-android-clang 
--sysroot=/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/sysroot 
-I.  -DHAVE_CONFIG_H 
-I/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/include -ggdb3 
-Wall -W   -Wmissing-prototypes -Wmissing-declarations 
-Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast 
-Wnested-externs -fpic -MT aes-set-decrypt-key.o -MD -MP -MF 
aes-set-decrypt-key.o.d -c aes-set-decrypt-key.c \
     &amp;&amp; true
/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/bin/i686-linux-android-clang 
--sysroot=/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/sysroot 
-I.  -DHAVE_CONFIG_H 
-I/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/include -ggdb3 
-Wall -W   -Wmissing-prototypes -Wmissing-declarations 
-Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast 
-Wnested-externs -fpic -MT aes128-set-encrypt-key.o -MD -MP -MF 
aes128-set-encrypt-key.o.d -c aes128-set-encrypt-key.c \
     &amp;&amp; true
: warning: argument unused during compilation: '-D __ANDROID_API__=14' 
[-Wunused-command-line-argument]
clang50: warning: argument unused during compilation: '-D HAVE_CONFIG_H' 
[-Wunused-command-line-argument]
clang50: warning: argument unused during compilation: '-MT 
aes-decrypt-internal.o' [-Wunused-command-line-argument]
clang50: warning: argument unused during compilation: '-MD' 
[-Wunused-command-line-argument]
clang50: warning: argument unused during compilation: '-MP' 
[-Wunused-command-line-argument]
clang50: warning: argument unused during compilation: '-MF 
aes-decrypt-internal.o.d' [-Wunused-command-line-argument]
aes-decrypt-internal.s:67:10: error: unknown token in expression
         teq     r3, #0
                     ^
aes-decrypt-internal.s:68:2: error: invalid instruction mnemonic 'beq'
         beq     .Lend
         ^~~
aes-decrypt-internal.s:70:7: error: Unexpected '{' in expression
         push    {r0,r1,r3, r4,r5,r6,r7,r8,r10,r11,lr}
                 ^
clang50: warning: argument unused during compilation: '-D 
__ANDROID_API__=14' [-Wunused-command-line-argument]
/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/bin/i686-linux-android-clang 
--sysroot=/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/sysroot 
-I.  -DHAVE_CONFIG_H 
-I/home/bobbie/ffmpeg-android-3.4.1/toolchain-android/include -ggdb3 
-Wall -W   -Wmissing-prototypes -Wmissing-declarations 
-Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast 
-Wnested-externs -fpic -MT aes128-set-decrypt-key.o -MD -MP -MF 
aes128-set-decrypt-key.o.d -c aes128-set-decrypt-key.c \
     &amp;&amp; true
clang50: warning: argument unused during compilation: '-D HAVE_CONFIG_H' 
[-Wunused-command-line-argument]
clang50: warning: argument unused during compilation: '-MT 
aes-encrypt-internal.o' [-Wunused-command-line-argument]
clang50: warning: argument unused during compilation: '-MD' 
[-Wunused-command-line-argument]
clang50: warning: argument unused during compilation: '-MP' 
[-Wunused-command-line-argument]
clang50: warning: argument unused during compilation: '-MF 
aes-encrypt-internal.o.d' [-Wunused-command-line-argument]
aes-decrypt-internal.s:71:10: error: unknown token in expression
         mov     r0, #0x3fc
                     ^
aes-decrypt-internal.s:75:13: error: expected ']' in brackets expression
         ldr     r1, [sp, #+48]
                        ^
aes-decrypt-internal.s:76:10: error: Unexpected '{' in expression
         ldm     sp, {r10, r11}
                     ^
aes-decrypt-internal.s:79:17: error: unknown token in expression
         ldrb    r4, [r1], #+1


</body></email><email><emailId>20180122074241</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-01-22 07:42:41-0400</timestampReceived><subject>API for new AEAD modes</subject><body>

Hi,
 As it is now AEAD ciphers in nettle are supported with their own API.
AES-CCM provides:
ccm_aes128_set_key
ccm_aes128_set_nonce
ccm_aes128_update
ccm_aes128_encrypt
ccm_aes128_decrypt
ccm_aes128_digest
ccm_aes128_encrypt_message
ccm_aes128_decrypt_message

AES-GCM:
gcm_aes128_set_key
gcm_aes128_update
gcm_aes128_set_iv
gcm_aes128_encrypt
gcm_aes128_decrypt
gcm_aes128_digest

chacha-poly1305:
chacha_poly1305_set_key
chacha_poly1305_set_nonce
chacha_poly1305_update
chacha_poly1305_encrypt
chacha_poly1305_decrypt
chacha_poly1305_digest

ccm_aes128_set_nonce takes different parameters from the chacha and gcm
equivalent function.

Furthermore the AEAD modes for block ciphers include an abstract layer
which can be re-used of other ciphers. For example the GCM mode
abstraction is re-used for camellia as well.

So overall there is a kind of "abstract" API followed with the set_key,
set_nonce, update, encrypt/decrypt, however these have not always the
same parameters as in the CCM case. I'm checking the AES-SIV-CMAC mode
which cannot even be put in that abstraction as the MAC in SIV is the
IV and thus the MAC-style API doesn't really suit it.

My understanding is that AEAD modes according to RFC5116 need to have 4
inputs: key, nonce, associated data, plaintext so the CCM encrypt and
decrypt message seem to be the closer to that API. Would it make sense
to standardize on these, and only provide that API for AEAD modes?

The reason I'm asking is because SIV could benefit of a very custom API
as well because it can take advantage of multiple associated data, but
in the end I believe AEAD is about simplicity. Providing a unique API
per AEAD cipher seems to me quite contradictory to that goal.

regards,
Nikos


</body></email><email><emailId>20180123183408</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-23 18:34:08-0400</timestampReceived><subject>Re: API for new AEAD modes</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt;  As it is now AEAD ciphers in nettle are supported with their own API.
&gt; AES-CCM provides:
&gt; ccm_aes128_set_key
&gt; ccm_aes128_set_nonce
&gt; ccm_aes128_update
&gt; ccm_aes128_encrypt
&gt; ccm_aes128_decrypt
&gt; ccm_aes128_digest
&gt; ccm_aes128_encrypt_message
&gt; ccm_aes128_decrypt_message

I've considered ccm odd because it doesn't support a "streaming" mode
where the mesage length isn't known up-front.

&gt; AES-GCM:
&gt; gcm_aes128_set_key
&gt; gcm_aes128_update
&gt; gcm_aes128_set_iv

And gcm is a bit special because it uses pretty large tables which
depend on the key but not the nonce. And it would make sense to rename
set_iv to set_nonce, for consitency.

&gt; chacha-poly1305:
&gt; chacha_poly1305_set_key
&gt; chacha_poly1305_set_nonce
&gt; chacha_poly1305_update
&gt; chacha_poly1305_encrypt
&gt; chacha_poly1305_decrypt
&gt; chacha_poly1305_digest

These are the methods I'd expect "most" AEADs to have, and it's what the
nettle_aead struct is intended to capture. But maybe there are too many
exceptions. It's good to have several examples to consider.

&gt; I'm checking the AES-SIV-CMAC mode
&gt; which cannot even be put in that abstraction as the MAC in SIV is the
&gt; IV and thus the MAC-style API doesn't really suit it.

Does that mean that it processes data twice (first mac, then
encryption), so that it can't support "streaming" mode at all, even if
lenghts are provided up front?

&gt; My understanding is that AEAD modes according to RFC5116 need to have 4
&gt; inputs: key, nonce, associated data, plaintext so the CCM encrypt and
&gt; decrypt message seem to be the closer to that API. Would it make sense
&gt; to standardize on these, and only provide that API for AEAD modes?

It would make a lot of sense to have some convenience functions to do
that, which are consistent between AEADs. However, I think I'd prefer to
at least make the set_key method separate, to avoid redoing all of the
key setup per message.

So then we'de have something similar to the ccm_*_message functions.
Should the nonce length and tag length be variable per message? Would it
be useful with a separate area for reading and writing the tag, or
should we always attach the tag at the end of the ciphertext, like the
current _message functions?

&gt; The reason I'm asking is because SIV could benefit of a very custom API
&gt; as well because it can take advantage of multiple associated data, but
&gt; in the end I believe AEAD is about simplicity. Providing a unique API
&gt; per AEAD cipher seems to me quite contradictory to that goal.

I think it's nice to support special features of SIV, but using those
functions should be optional.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180124072530</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-01-24 07:25:30-0400</timestampReceived><subject>Re: API for new AEAD modes</subject><body>

On Tue, Jan 23, 2018 at 7:34 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt;
&gt;&gt;  As it is now AEAD ciphers in nettle are supported with their own API.
&gt;&gt; AES-CCM provides:
&gt;&gt; ccm_aes128_set_key
&gt;&gt; ccm_aes128_set_nonce
&gt;&gt; ccm_aes128_update
&gt;&gt; ccm_aes128_encrypt
&gt;&gt; ccm_aes128_decrypt
&gt;&gt; ccm_aes128_digest
&gt;&gt; ccm_aes128_encrypt_message
&gt;&gt; ccm_aes128_decrypt_message
&gt; I've considered ccm odd because it doesn't support a "streaming" mode
&gt; where the mesage length isn't known up-front.

It seems that the streaming mode is not a feature of AEAD ciphers. The
AES-SIV-CMAC is similar in that aspect as the whole plaintext is
needed to create the IV.

&gt;&gt; AES-GCM:
&gt;&gt; gcm_aes128_set_key
&gt;&gt; gcm_aes128_update
&gt;&gt; gcm_aes128_set_iv
&gt;
&gt; And gcm is a bit special because it uses pretty large tables which
&gt; depend on the key but not the nonce. And it would make sense to rename
&gt; set_iv to set_nonce, for consitency.

Would be nice.

&gt;&gt; chacha-poly1305:
&gt;&gt; chacha_poly1305_set_key
&gt;&gt; chacha_poly1305_set_nonce
&gt;&gt; chacha_poly1305_update
&gt;&gt; chacha_poly1305_encrypt
&gt;&gt; chacha_poly1305_decrypt
&gt;&gt; chacha_poly1305_digest
&gt;
&gt; These are the methods I'd expect "most" AEADs to have, and it's what the
&gt; nettle_aead struct is intended to capture. But maybe there are too many
&gt; exceptions. It's good to have several examples to consider.

I think that the nettle_aead is too specific to gcm. chacha20-poly1305
fitted in there, but it seems that other AEAD ciphers would not fit.

&gt;&gt; I'm checking the AES-SIV-CMAC mode
&gt;&gt; which cannot even be put in that abstraction as the MAC in SIV is the
&gt;&gt; IV and thus the MAC-style API doesn't really suit it.
&gt;
&gt; Does that mean that it processes data twice (first mac, then
&gt; encryption), so that it can't support "streaming" mode at all, even if
&gt; lenghts are provided up front?

Right. It is tailored towards packet/message encryption.

&gt;&gt; My understanding is that AEAD modes according to RFC5116 need to have 4
&gt;&gt; inputs: key, nonce, associated data, plaintext so the CCM encrypt and
&gt;&gt; decrypt message seem to be the closer to that API. Would it make sense
&gt;&gt; to standardize on these, and only provide that API for AEAD modes?
&gt; It would make a lot of sense to have some convenience functions to do
&gt; that, which are consistent between AEADs. However, I think I'd prefer to
&gt; at least make the set_key method separate, to avoid redoing all of the
&gt; key setup per message.
&gt; So then we'de have something similar to the ccm_*_message functions.
&gt; Should the nonce length and tag length be variable per message?

The tag is fixed since it is used as the IV. On the branch I'm working
on I have the following interface:

struct siv_aes128_cmac_ctx {
    struct aes128_ctx         cipher;
    uint8_t s2vk[AES128_KEY_SIZE];
};

void
siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const uint8_t *key=
);

void
siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
                                size_t nlength, const uint8_t *nonce,
                                size_t alength, const uint8_t *adata,
                                size_t tlength,
                                size_t clength, uint8_t *dst, const
uint8_t *src);

int
siv_aes128_cmac_decrypt_message(struct siv_aes128_cmac_ctx *ctx,
                                size_t nlength, const uint8_t *nonce,
                                size_t alength, const uint8_t *adata,
                                size_t tlength,
                                size_t mlength, uint8_t *dst, const
uint8_t *src);


&gt; Would it
&gt; be useful with a separate area for reading and writing the tag, or
&gt; should we always attach the tag at the end of the ciphertext, like the
&gt; current _message functions?

I think the expectation is to prepend the tag/IV to the message. As
the message interface above doesn't distinguish between tag and
ciphertext, I think it  quite conveniently fits it.

&gt;&gt; The reason I'm asking is because SIV could benefit of a very custom API
&gt;&gt; as well because it can take advantage of multiple associated data, but
&gt;&gt; in the end I believe AEAD is about simplicity. Providing a unique API
&gt;&gt; per AEAD cipher seems to me quite contradictory to that goal.
&gt;
&gt; I think it's nice to support special features of SIV, but using those
&gt; functions should be optional.

A possible interface could be:
void siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const
uint8_t *key)
void siv_aes128_cmac_s2v(struct siv_aes128_cmac_ctx *ctx, size_t
nlength, const uint8_t *nonce,
                            size_t adatalen, size_t *alength, const
uint8_t **adata,
                            size_t plength, size_t pdata);

(notice the pointer to pointer for adata)

The generic non-aes version of it should also contain the pointers to
relevant CMAC functions such as:
nettle_set_key_func *cmac_set_key, nettle_hash_update_func *cmac_update,
nettle_hash_digest_func *cmac_digest and the size of context.

I think with all these parameters, the current API I have could be
classified as unbearable even for a low-level one.

regards,
Nikos

</body></email><email><emailId>20180124084656</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-24 08:46:56-0400</timestampReceived><subject>Re: API for new AEAD modes</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; On Tue, Jan 23, 2018 at 7:34 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;&gt; These are the methods I'd expect "most" AEADs to have, and it's what the
&gt;&gt; nettle_aead struct is intended to capture. But maybe there are too many
&gt;&gt; exceptions. It's good to have several examples to consider.
&gt;
&gt; I think that the nettle_aead is too specific to gcm. chacha20-poly1305
&gt; fitted in there, but it seems that other AEAD ciphers would not fit.

I'm afraid you're right. Then we'll either have to change nettle_aead,
or introduce a new struct, say nettle_message_aead or so.

&gt;&gt; So then we'de have something similar to the ccm_*_message functions.
&gt;&gt; Should the nonce length and tag length be variable per message?
&gt;
&gt; The tag is fixed since it is used as the IV. On the branch I'm working
&gt; on I have the following interface:
&gt;
&gt; struct siv_aes128_cmac_ctx {
&gt;     struct aes128_ctx         cipher;
&gt;     uint8_t s2vk[AES128_KEY_SIZE];
&gt; };
&gt;
&gt; void
&gt; siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const uint8_t *key);
&gt;
&gt; void
&gt; siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
&gt;                                 size_t nlength, const uint8_t *nonce,
&gt;                                 size_t alength, const uint8_t *adata,
&gt;                                 size_t tlength,
&gt;                                 size_t clength, uint8_t *dst, const
&gt; uint8_t *src);
&gt;
&gt; int
&gt; siv_aes128_cmac_decrypt_message(struct siv_aes128_cmac_ctx *ctx,
&gt;                                 size_t nlength, const uint8_t *nonce,
&gt;                                 size_t alength, const uint8_t *adata,
&gt;                                 size_t tlength,
&gt;                                 size_t mlength, uint8_t *dst, const
&gt; uint8_t *src);

I think this is the right level for most applications. But I'm a bit
confused with regards to my questions. Are the tlength and nlength
arguments useful (for siv, and and for aead in general)?

Or should at least tag length be considered parameter of the aead
algorithm, not something which can vary from message to message?

For hashes and macs, use of truncated outputs seemed fairly common,
which is why the current interfaces includes a digest length argument.
But aeads are a bit different. For SIV, would a shortened tag just
reduce the strength of authentication, or would it make it impossible to
decrypt the message?

&gt; I think the expectation is to prepend the tag/IV to the message. As
&gt; the message interface above doesn't distinguish between tag and
&gt; ciphertext, I think it  quite conveniently fits it.

For authenticated decryption one needs three pieces of data:

1. The nonce.

2. The ciphertext.

3. The tag.

The nonce should most likely be a separate argument, it might not be
attached at all to the data on the wire. E.g., it could be derived from
an implicit message number.

The current ccm_*_ message functions represents ciphertext and tag as a
single blob,

  +--------------+-------+ 
  |  ciphertext  |  tag  |
  +--------------+-------+ 

It seems you're saying that for siv, you put them together in the
opposite order,

  +-------+--------------+ 
  |  tag  |  ciphertext  |
  +-------+--------------+ 

Should we treat the encrypted message as a single blob, with any
internal structure being an internal detail of the aead? That seems to
be the RFC 5116 view.

In case there are protocols or applications that specify that ciphertext
and tag are sent/stored as separately byte strings, we would need to
expose that distinction in the api. E.g., say we do in-place
block-by-block encryption on disk, and treat nonce and tag for each
block as metadata, stored elsewhere.

&gt; A possible interface could be:
&gt; void siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const
&gt; uint8_t *key)
&gt; void siv_aes128_cmac_s2v(struct siv_aes128_cmac_ctx *ctx, size_t
&gt; nlength, const uint8_t *nonce,
&gt;                             size_t adatalen, size_t *alength, const
&gt; uint8_t **adata,
&gt;                             size_t plength, size_t pdata);
&gt;
&gt; (notice the pointer to pointer for adata)

I think I'd prefer something like

void 
siv_aes128_cmac_extra_adata(struct siv_aes128_cmac_ctx *ctx, 
                            size_t length, const uint8_t *data);

to be called zero or more times between _set_key and the call with the
body of the message. (Probably need a separate set_nonce function too,
if nonce must be known before processing and associated data).

I hope it should be possible to design something reasonable. (And we
don't need to expose it in the general aead interface).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180104145522</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2018-01-04 14:55:22-0400</timestampReceived><subject>Re: Build system bug with assembler and clang</subject><body>

On Thu, 4 Jan 2018, blargh wrote:

&gt; Hi,
&gt;
&gt; I've been building nettle with Clang from a generated toolchain with the 
&gt; latest Android NDK (16b).
&gt;
&gt; Form architecture with available assembler code (x86 in particular), 
&gt; compilation fails because the generated asm is not compatible with clang.
&gt; So I use --disable-assembler, thinking it would fix the problem. But it 
&gt; still fails (see log below):
&gt;
&gt; The workaround has been to entirely disable (comment) the asm rule in 
&gt; Makefile.in:
&gt;
&gt;
&gt; #.asm.$(OBJEXT): $(srcdir)/asm.m4 machine.m4 config.m4
&gt; #       $(M4) $(srcdir)/asm.m4 machine.m4 config.m4 $&lt; &gt;$*.s
&gt; #       $(COMPILE) -c $*.s
&gt; #       @echo "$@ : $&lt; $(srcdir)/asm.m4 machine.m4 config.m4" &gt;$@.d
&gt;
&gt;
&gt; For some reason, this rule generates asm files even when 
&gt; --disable-assembler is specified and it gets in the way later in the build.
&gt;
&gt; The proper fix would be to make sure this rule never kicks in with 
&gt; --disable-assembler.
&gt; And also maybe force --disable-assembler when clang is the compiler, or 
&gt; update the asm generation macro (asm.m4)
&gt; to produce .s files compatible with clang.

The error messages you quoted below show an attempt of assembling arm 
assembly when targeting i686. This sounds like a case of not running "make 
distclean" in the nettle source repo before reconfiguring for a different 
target.

Once you've cleaned the build tree properly, you could maybe retry even 
without the hacks and without --disable-assembler to see if it works even 
without that.

// Martin

</body></email><email><emailId>20180104151859</emailId><senderName>blargh</senderName><senderEmail>youp1one1@gmail.com</senderEmail><timestampReceived>2018-01-04 15:18:59-0400</timestampReceived><subject>Re: Build system bug with assembler and clang</subject><body>

Thanks, you were right:

Using 'make distclean' fixes it. As you guessed, I was building for 
several archs and did just 'make clean'
between builds.

I removed --disable-assembler and it compiled for x86. Although the 
assembler was not picked up.
It turns out it is due to the host (from configure output):

...
checking host system type... x86-unknown-none
...

This host type is not covered in configure.ac:

asm_path=
if test "x$enable_assembler" = xyes ; then
   case "$host_cpu" in
     [i?86* | k[5-8]* | pentium* | athlon])
       asm_path=x86
       ;;


Adding  x86-* fixed it:

asm_path=
if test "x$enable_assembler" = xyes ; then
   case "$host_cpu" in
     [i?86* | k[5-8]* | pentium* | athlon | x86])
       asm_path=x86
       ;;


After this change nettle compiles fine with clang targeting x86 for 
Android, with asm.

On 04/01/2018 15:55, Martin Storsjö wrote:
&gt; On Thu, 4 Jan 2018, blargh wrote:
&gt;
&gt;&gt; Hi,
&gt;&gt;
&gt;&gt; I've been building nettle with Clang from a generated toolchain with 
&gt;&gt; the latest Android NDK (16b).
&gt;&gt;
&gt;&gt; Form architecture with available assembler code (x86 in particular), 
&gt;&gt; compilation fails because the generated asm is not compatible with 
&gt;&gt; clang.
&gt;&gt; So I use --disable-assembler, thinking it would fix the problem. But 
&gt;&gt; it still fails (see log below):
&gt;&gt;
&gt;&gt; The workaround has been to entirely disable (comment) the asm rule in 
&gt;&gt; Makefile.in:
&gt;&gt;
&gt;&gt;
&gt;&gt; #.asm.$(OBJEXT): $(srcdir)/asm.m4 machine.m4 config.m4
&gt;&gt; #       $(M4) $(srcdir)/asm.m4 machine.m4 config.m4 $&lt; &gt;$*.s
&gt;&gt; #       $(COMPILE) -c $*.s
&gt;&gt; #       @echo "$@ : $&lt; $(srcdir)/asm.m4 machine.m4 config.m4" &gt;$@.d
&gt;&gt;
&gt;&gt;
&gt;&gt; For some reason, this rule generates asm files even when 
&gt;&gt; --disable-assembler is specified and it gets in the way later in the 
&gt;&gt; build.
&gt;&gt;
&gt;&gt; The proper fix would be to make sure this rule never kicks in with 
&gt;&gt; --disable-assembler.
&gt;&gt; And also maybe force --disable-assembler when clang is the compiler, 
&gt;&gt; or update the asm generation macro (asm.m4)
&gt;&gt; to produce .s files compatible with clang.
&gt;
&gt; The error messages you quoted below show an attempt of assembling arm 
&gt; assembly when targeting i686. This sounds like a case of not running 
&gt; "make distclean" in the nettle source repo before reconfiguring for a 
&gt; different target.
&gt;
&gt; Once you've cleaned the build tree properly, you could maybe retry 
&gt; even without the hacks and without --disable-assembler to see if it 
&gt; works even without that.
&gt;
&gt; // Martin



On 04/01/2018 15:55, Martin Storsjö wrote:
&gt; On Thu, 4 Jan 2018, blargh wrote:
&gt;
&gt;&gt; Hi,
&gt;&gt;
&gt;&gt; I've been building nettle with Clang from a generated toolchain with 
&gt;&gt; the latest Android NDK (16b).
&gt;&gt;
&gt;&gt; Form architecture with available assembler code (x86 in particular), 
&gt;&gt; compilation fails because the generated asm is not compatible with 
&gt;&gt; clang.
&gt;&gt; So I use --disable-assembler, thinking it would fix the problem. But 
&gt;&gt; it still fails (see log below):
&gt;&gt;
&gt;&gt; The workaround has been to entirely disable (comment) the asm rule in 
&gt;&gt; Makefile.in:
&gt;&gt;
&gt;&gt;
&gt;&gt; #.asm.$(OBJEXT): $(srcdir)/asm.m4 machine.m4 config.m4
&gt;&gt; #       $(M4) $(srcdir)/asm.m4 machine.m4 config.m4 $&lt; &gt;$*.s
&gt;&gt; #       $(COMPILE) -c $*.s
&gt;&gt; #       @echo "$@ : $&lt; $(srcdir)/asm.m4 machine.m4 config.m4" &gt;$@.d
&gt;&gt;
&gt;&gt;
&gt;&gt; For some reason, this rule generates asm files even when 
&gt;&gt; --disable-assembler is specified and it gets in the way later in the 
&gt;&gt; build.
&gt;&gt;
&gt;&gt; The proper fix would be to make sure this rule never kicks in with 
&gt;&gt; --disable-assembler.
&gt;&gt; And also maybe force --disable-assembler when clang is the compiler, 
&gt;&gt; or update the asm generation macro (asm.m4)
&gt;&gt; to produce .s files compatible with clang.
&gt;
&gt; The error messages you quoted below show an attempt of assembling arm 
&gt; assembly when targeting i686. This sounds like a case of not running 
&gt; "make distclean" in the nettle source repo before reconfiguring for a 
&gt; different target.
&gt;
&gt; Once you've cleaned the build tree properly, you could maybe retry 
&gt; even without the hacks and without --disable-assembler to see if it 
&gt; works even without that.
&gt;
&gt; // Martin


</body></email><email><emailId>20180104204621</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-01-04 20:46:21-0400</timestampReceived><subject>Re: possible new modes</subject><body>

Hello,

2018-01-04 16:02 GMT+03:00 Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt;
&gt;&gt; Niels what do think about CFB8?
&gt;
&gt; If there applications for it, it makes sense to add it. My main question
&gt; is, should it be a separate set of functions, or should we make the
&gt; reasonably straightforward extension to cfb_encrypt and cfb_decrypt so
&gt; that passing length == 1 implies cfb8? All needed, if I remember the
&gt; earlier discussion, is to add the appopriate iv update to the
&gt;
&gt;   if (left &gt; 0) { .... }
&gt;
&gt; blocks at the end of these functions. This has the advantage that we get
&gt; support for CFBn for any 0 &lt; n &lt; block size, more or less for free.

Well, it's not for free. This will require an additional CFB parameter
(chunk size).
Also code will be much more complicate. I'd prefer to have separate
cfb8_* functions. They are simple and clean enough.

&gt; What's samba's usecase for CFB8? As far as I understand, CFB8 (or
&gt; small-symbol CFB in general) makes sense only when one needs to encrypt
&gt; and transmit each byte before the next cleartext byte becomes available.

Not really. It's just another 'strange' block mode. Compare it to CFB1, where
each bit requires new block encipherment (and IV update).


-- 
With best wishes
Dmitry

</body></email><email><emailId>20180104211556</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-04 21:15:56-0400</timestampReceived><subject>Re: possible new modes</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; 2018-01-04 16:02 GMT+03:00 Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;&gt; All needed, if I remember the
&gt;&gt; earlier discussion, is to add the appopriate iv update to the
&gt;&gt;
&gt;&gt;   if (left &gt; 0) { .... }
&gt;&gt;
&gt;&gt; blocks at the end of these functions. This has the advantage that we get
&gt;&gt; support for CFBn for any 0 &lt; n &lt; block size, more or less for free.
&gt;
&gt; Well, it's not for free. This will require an additional CFB parameter
&gt; (chunk size).

I was thinking that to use CFB8, one could process only a single byte
per call. On the theory that anyone using CFB8 either wants to process
one byte at a time anyway, or isn't caring much about performance.

I.e., when calling cfb_encrypt(..., block_size, iv, length, dst, src),
length &lt; block_size implies chunk_size == length. While length &gt;=
block_size implies chunk_size == block_size, except that the final chunk
might be shorter (which is non-standard, but in real use, if I
understood you correctly).

Then the proper iv update for a short chunk is the only thing missing in
the implementation.

&gt;&gt; What's samba's usecase for CFB8? As far as I understand, CFB8 (or
&gt;&gt; small-symbol CFB in general) makes sense only when one needs to encrypt
&gt;&gt; and transmit each byte before the next cleartext byte becomes available.
&gt;
&gt; Not really. It's just another 'strange' block mode. Compare it to CFB1, where
&gt; each bit requires new block encipherment (and IV update).

Can anyone explain why samba needs that? Is it required for
compatibility with some microsoft protocols? If one doesn't really need
to transmit one or a few bytes at time, choosing CFB8 rather than CFB16
implies a 16 time loss in performance, and I see no benefit at all.
Why??? I could be missing something, of course.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180123105222</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-01-23 10:52:22-0400</timestampReceived><subject>Re: cmac</subject><body>

On Wed, 2018-01-17 at 10:59 +0100, Nikos Mavrogiannopoulos wrote:

&gt; Thank you for the catch. Hopefully the x86 run on our CI would have
&gt; caught it but I never run it there. I've now sent a build with the
&gt; 0001
&gt; patch at:
&gt; https://gitlab.com/nmav/nettle/pipelines/16256301

Following up on my patchset, this (hopefully final) version introduces
CMAC with AES-256 as well. It also removes the CMAC128_KEY_SIZE
definition as the key size only depends on the block algorithm used.

regards,
Nikos

["0001-Added-support-for-CMAC.patch" (0001-Added-support-for-CMAC.patch)]

From cc60df9f2e083633fe1d258f3d0ddc17da251508 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 10 Jan 2018 09:29:17 +0100
Subject: [PATCH 1/3] Added support for CMAC

That adds support for CMAC as a generic framework for
128-bit block and key ciphers, as well as API for AES-128-CMAC.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 Makefile.in                 |   2 +
 cmac-aes128.c               |  60 ++++++++++++++++
 cmac.c                      | 162 ++++++++++++++++++++++++++++++++++++++++++++
 cmac.h                      | 118 ++++++++++++++++++++++++++++++++
 examples/nettle-benchmark.c |  24 ++++++-
 nettle.texinfo              |  47 ++++++++++++-
 testsuite/.test-rules.make  |   3 +
 testsuite/Makefile.in       |   1 +
 testsuite/cmac-test.c       | 111 ++++++++++++++++++++++++++++++
 9 files changed, 526 insertions(+), 2 deletions(-)
 create mode 100644 cmac-aes128.c
 create mode 100644 cmac.c
 create mode 100644 cmac.h
 create mode 100644 testsuite/cmac-test.c

diff --git a/Makefile.in b/Makefile.in
index 6a0c13ec..a25c0f99 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -103,6 +103,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-aes256.c gcm-aes256-meta.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
+		 cmac.c cmac-aes128.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
@@ -195,6 +196,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  gcm.h gosthash94.h hmac.h \
 	  knuth-lfib.h hkdf.h \
 	  macros.h \
+	  cmac.h \
 	  md2.h md4.h \
 	  md5.h md5-compat.h \
 	  memops.h memxor.h \
diff --git a/cmac-aes128.c b/cmac-aes128.c
new file mode 100644
index 00000000..e53e114e
--- /dev/null
+++ b/cmac-aes128.c
@@ -0,0 +1,60 @@
+/* cmac-aes128.c
+
+   CMAC using AES128 as the underlying cipher.
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "cmac.h"
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key)
+{
+  CMAC128_SET_KEY(ctx, aes128_set_encrypt_key, aes128_encrypt, key);
+}
+
+void
+cmac_aes128_update (struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  CMAC128_UPDATE (ctx, aes128_encrypt, length, data);
+}
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  CMAC128_DIGEST(ctx, aes128_encrypt, length, digest);
+}
diff --git a/cmac.c b/cmac.c
new file mode 100644
index 00000000..a4d2468a
--- /dev/null
+++ b/cmac.c
@@ -0,0 +1,162 @@
+/*
+   AES-CMAC-128 (rfc 4493)
+   Copyright (C) Stefan Metzmacher 2012
+   Copyright (C) Jeremy Allison 2012
+   Copyright (C) Michael Adam 2012
+   Copyright (C) 2017, Red Hat Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "cmac.h"
+
+#include "memxor.h"
+#include "nettle-internal.h"
+#include "macros.h"
+
+static const uint8_t const_zero[] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
+};
+
+/* shift one and XOR with 0x87. */
+static inline void block_mulx(union nettle_block16 *out,
+			      const union nettle_block16 *in)
+{
+	uint64_t b1 = READ_UINT64(in-&gt;b);
+	uint64_t b2 = READ_UINT64(in-&gt;b+8);
+	unsigned overflow = (b2 &amp; UINT64_C(0x8000000000000000))?1:0;
+
+	b1 &lt;&lt;= 1;
+	b2 &lt;&lt;= 1;
+
+	if (overflow)
+		b1 |= 0x01;
+
+	if (in-&gt;b[0] &amp; 0x80)
+		b2 ^= 0x87;
+
+	WRITE_UINT64(out-&gt;b, b1);
+	WRITE_UINT64(out-&gt;b+8, b2);
+}
+
+void cmac128_set_key(struct cmac128 *ctx, void *key,
+		     nettle_cipher_func *encrypt)
+{
+	union nettle_block16 *L = &amp;ctx-&gt;block;
+	memset(ctx, 0, sizeof(*ctx));
+
+	/* step 1 - generate subkeys k1 and k2 */
+	encrypt(key, 16, L-&gt;b, const_zero);
+
+	block_mulx(&amp;ctx-&gt;K1, L);
+	block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
+}
+
+#define MIN(x,y) ((x)&lt;(y)?(x):(y))
+
+void cmac128_update(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    size_t msg_len, const uint8_t *msg)
+{
+	union nettle_block16 Y;
+	/*
+	 * check if we expand the block
+	 */
+	if (ctx-&gt;index &lt; 16) {
+		size_t len = MIN(16 - ctx-&gt;index, msg_len);
+		memcpy(&amp;ctx-&gt;block.b[ctx-&gt;index], msg, len);
+		msg += len;
+		msg_len -= len;
+		ctx-&gt;index += len;
+	}
+
+	if (msg_len == 0) {
+		/* if it is still the last block, we are done */
+		return;
+	}
+
+	/*
+	 * now checksum everything but the last block
+	 */
+	memxor3(Y.b, ctx-&gt;X.b, ctx-&gt;block.b, 16);
+	encrypt(key, 16, ctx-&gt;X.b, Y.b);
+
+	while (msg_len &gt; 16) {
+		memxor3(Y.b, ctx-&gt;X.b, msg, 16);
+		encrypt(key, 16, ctx-&gt;X.b, Y.b);
+		msg += 16;
+		msg_len -= 16;
+	}
+
+	/*
+	 * copy the last block, it will be processed in
+	 * cmac128_digest().
+	 */
+	memcpy(ctx-&gt;block.b, msg, msg_len);
+	ctx-&gt;index = msg_len;
+}
+
+void cmac128_digest(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *out)
+{
+	union nettle_block16 Y;
+
+	memset(ctx-&gt;block.b+ctx-&gt;index, 0, sizeof(ctx-&gt;block.b)-ctx-&gt;index);
+
+	/* re-use ctx-&gt;block for memxor output */
+	if (ctx-&gt;index &lt; 16) {
+		ctx-&gt;block.b[ctx-&gt;index] = 0x80;
+		memxor(ctx-&gt;block.b, ctx-&gt;K2.b, 16);
+	} else {
+		memxor(ctx-&gt;block.b, ctx-&gt;K1.b, 16);
+	}
+
+	memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 16);
+
+	assert(length &lt;= 16);
+	if (length == 16) {
+		encrypt(key, 16, out, Y.b);
+	} else {
+		encrypt(key, 16, ctx-&gt;block.b, Y.b);
+		memcpy(out, ctx-&gt;block.b, length);
+	}
+
+	/* reset state for re-use */
+	memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
+	ctx-&gt;index = 0;
+}
diff --git a/cmac.h b/cmac.h
new file mode 100644
index 00000000..168ca95a
--- /dev/null
+++ b/cmac.h
@@ -0,0 +1,118 @@
+/* cmac.h
+
+   CMAC mode, as specified in RFC4493
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   Contributed by Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_CMAC_H_INCLUDED
+#define NETTLE_CMAC_H_INCLUDED
+
+#include "aes.h"
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CMAC128_KEY_SIZE 16
+#define CMAC128_DIGEST_SIZE 16
+
+#define cmac128_set_key nettle_cmac128_set_key
+#define cmac128_update nettle_cmac128_update
+#define cmac128_digest nettle_cmac128_digest
+#define cmac_aes128_set_key nettle_cmac_aes128_set_key
+#define cmac_aes128_update nettle_cmac_aes128_update
+#define cmac_aes128_digest nettle_cmac_aes128_digest
+
+struct cmac128 {
+	union nettle_block16 K1;
+	union nettle_block16 K2;
+
+	union nettle_block16 X;
+
+	union nettle_block16 block;
+	size_t index;
+};
+
+void cmac128_set_key(struct cmac128 *ctx, void *key,
+		     nettle_cipher_func *encrypt);
+void cmac128_update(struct cmac128 *ctx, void *key,
+		 nettle_cipher_func *encrypt,
+		 size_t msg_len, const uint8_t *msg);
+void cmac128_digest(struct cmac128 *ctx, void *key,
+		    nettle_cipher_func *encrypt,
+		    unsigned length,
+		    uint8_t *out);
+
+
+#define CMAC128_CTX(type) \
+  { struct cmac128 data; type cipher; }
+
+/* NOTE: Avoid using NULL, as we don't include anything defining it. */
+#define CMAC128_SET_KEY(ctx, set_key, encrypt, cmac_key)		\
+  do {								\
+    (set_key)(&amp;(ctx)-&gt;cipher, (cmac_key));			\
+    if (0) (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,		\
+		     (uint8_t *) 0, (const uint8_t *) 0);	\
+    cmac128_set_key(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		(nettle_cipher_func *) (encrypt));		\
+  } while (0)
+
+#define CMAC128_UPDATE(ctx, encrypt, length, data)			\
+  cmac128_update(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher, \
+	      (nettle_cipher_func *)encrypt, (length), (data))
+
+#define CMAC128_DIGEST(ctx, encrypt, length, digest)			\
+  (0 ? (encrypt)(&amp;(ctx)-&gt;cipher, ~(size_t) 0,				\
+		 (uint8_t *) 0, (const uint8_t *) 0)			\
+     : cmac128_digest(&amp;(ctx)-&gt;data, &amp;(ctx)-&gt;cipher,			\
+		  (nettle_cipher_func *) (encrypt),			\
+		  (length), (digest)))
+
+struct cmac_aes128_ctx CMAC128_CTX(struct aes128_ctx);
+
+void
+cmac_aes128_set_key(struct cmac_aes128_ctx *ctx, const uint8_t *key);
+
+void
+cmac_aes128_update(struct cmac_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CMAC_H_INCLUDED */
diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index 4efcca5c..b8062c5b 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -64,6 +64,7 @@
 #include "sha3.h"
 #include "twofish.h"
 #include "umac.h"
+#include "cmac.h"
 #include "poly1305.h"
 
 #include "nettle-meta.h"
@@ -403,7 +404,7 @@ time_umac(void)
   struct umac64_ctx ctx64;
   struct umac96_ctx ctx96;
   struct umac128_ctx ctx128;
-  
+
   uint8_t key[16];
 
   umac32_set_key (&amp;ctx32, key);
@@ -439,6 +440,24 @@ time_umac(void)
 	  time_function(bench_hash, &amp;info));
 }
 
+static void
+time_cmac(void)
+{
+  static uint8_t data[BENCH_BLOCK];
+  struct bench_hash_info info;
+  struct cmac_aes128_ctx ctx;
+
+  uint8_t key[16];
+
+  cmac_aes128_set_key (&amp;ctx, key);
+  info.ctx = 
+  info.update = (nettle_hash_update_func *) cmac_aes128_update;
+  info.data = data;
+
+  display("cmac-aes128", "update", AES_BLOCK_SIZE,
+	  time_function(bench_hash, &amp;info));
+}
+
 static void
 time_poly1305_aes(void)
 {
@@ -846,6 +865,9 @@ main(int argc, char **argv)
       if (!alg || strstr ("umac", alg))
 	time_umac();
 
+      if (!alg || strstr ("cmac", alg))
+	time_cmac();
+
       if (!alg || strstr ("poly1305-aes", alg))
 	time_poly1305_aes();
 
diff --git a/nettle.texinfo b/nettle.texinfo
index f501cfbe..4c7b5312 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -101,6 +101,7 @@ Keyed Hash Functions
 
 * HMAC::
 * UMAC::
+* CMAC::
 
 Public-key algorithms
 
@@ -271,6 +272,9 @@ The implementation of the TWOFISH cipher is written by Ruud de \
Rooij.  @item UMAC
 Written by @value{AUTHOR}.
 
+@item CMAC
+Written by Nikos Mavrogiannopoulos, @value{AUTHOR}, Jeremy Allison, Michael Adam and \
Stefan Metzmacher. +
 @item RSA
 Written by @value{AUTHOR}. Uses the GMP library for bignum operations.
 
@@ -3134,6 +3138,7 @@ as well.
 @menu
 * HMAC::
 * UMAC::
+* CMAC::
 * Poly1305::
 @end menu
 
@@ -3476,7 +3481,47 @@ as described above, the new value is used unless you call the
 @code{_set_nonce} function explicitly for each message.
 @end deftypefun
 
-@node Poly1305,, UMAC, Keyed hash functions
+@node CMAC,, UMAC, Keyed hash functions
+@subsection @acronym{CMAC}
+@cindex CMAC
+
+@acronym{CMAC} is a message authentication code based on CBC encryption
+mode. It is suitable for systems where block ciphers are preferrable
+and perform better than hash functions. @acronym{CMAC} is specified in
+@cite{RFC4493}. The secret key is always 128 bits (16 octets).
+
+Nettle provides helper functions for @acronym{CMAC } with
+the @acronym{AES} block cipher.
+
+Nettle defines @acronym{CMAC} in @file{&lt;nettle/cmac.h&gt;}.
+
+@deftp {Context struct} {struct cmac128_ctx}
+@end deftp
+
+@defvr Constant CMAC128_KEY_SIZE
+The CMAC key size, 16.
+@end defvr
+@defvr Constant CMAC128_DIGEST_SIZE
+The size of an CMAC digest, 16.
+@end defvr
+
+@deftypefun void cmac_aes128_set_key (struct cmac_aes128_ctx *@var{ctx}, const \
uint8_t *@var{key}) +This function initializes the @acronym{CMAC} context struct.
+@end deftypefun
+
+@deftypefun void cmac_aes128_update (struct cmac_aes128_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +This function is called zero or more times \
to process the message. +@end deftypefun
+
+@deftypefun void cmac_aes128_digest (struct cmac_aes128_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Extracts the @acronym{MAC} of the message, \
writing it to @var{digest}. +@var{length} is usually equal to the specified output \
size, but if you +provide a smaller value, only the first @var{length} octets of the
+@acronym{MAC} are written. This function resets the context for
+processing of a new message with the same key.
+@end deftypefun
+
+@node Poly1305,, CMAC, Keyed hash functions
 @comment  node-name,  next,  previous,  up
 @subsection Poly1305
 
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 1f780310..c7e04cb4 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -130,6 +130,9 @@ eax-test$(EXEEXT): eax-test.$(OBJEXT)
 ccm-test$(EXEEXT): ccm-test.$(OBJEXT)
 	$(LINK) ccm-test.$(OBJEXT) $(TEST_OBJS) -o ccm-test$(EXEEXT)
 
+cmac-test$(EXEEXT): cmac-test.$(OBJEXT)
+	$(LINK) cmac-test.$(OBJEXT) $(TEST_OBJS) -o cmac-test$(EXEEXT)
+
 poly1305-test$(EXEEXT): poly1305-test.$(OBJEXT)
 	$(LINK) poly1305-test.$(OBJEXT) $(TEST_OBJS) -o poly1305-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 3117d66d..dd1ecf41 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -26,6 +26,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    serpent-test.c twofish-test.c version-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c cfb-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
+		    cmac-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
new file mode 100644
index 00000000..983c5127
--- /dev/null
+++ b/testsuite/cmac-test.c
@@ -0,0 +1,111 @@
+#include "testutils.h"
+#include "nettle-internal.h"
+#include "cmac.h"
+
+static void
+test_cmac_hash (const struct tstring *key, const struct tstring *msg, const struct \
tstring *ref) +{
+  struct cmac_aes128_ctx ctx;
+  uint8_t digest[16];
+  unsigned i;
+
+  ASSERT (ref-&gt;length == sizeof(digest));
+  ASSERT (key-&gt;length == 16);
+  cmac_aes128_set_key (&amp;ctx, key-&gt;data);
+  cmac_aes128_update (&amp;ctx, msg-&gt;length, msg-&gt;data);
+  cmac_aes128_digest (&amp;ctx, sizeof(digest), digest);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, digest))
+    {
+      fprintf (stderr, "cmac_hash failed, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, digest);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt to re-use the structure */
+  cmac_aes128_update (&amp;ctx, msg-&gt;length, msg-&gt;data);
+  cmac_aes128_digest (&amp;ctx, sizeof(digest), digest);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, digest))
+    {
+      fprintf (stderr, "cmac_hash failed on re-use, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, digest);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt byte-by-byte hashing */
+  cmac_aes128_set_key (&amp;ctx, key-&gt;data);
+  for (i=0;i&lt;msg-&gt;length;i++)
+    cmac_aes128_update (&amp;ctx, 1, msg-&gt;data+i);
+  cmac_aes128_digest (&amp;ctx, sizeof(digest), digest);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, digest))
+    {
+      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, digest);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(ref);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+}
+
+void
+test_main(void)
+{
+  /*
+   * CMAC-AES Test Vectors from RFC4493.
+   */
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SDATA(""),
+		  SHEX("bb1d6929e95937287fa37d129b756746"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
+		  SHEX("070a16b46b4d4144f79bdd9dd04a287c"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("dfa66747de9ae63030ca32611497c827"));
+
+  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411e5fbc1191a0a52ef"
+		       "f69f2445df4f9b17ad2b417be66c3710"),
+		  SHEX("51f0bebf7e3b9d92fc49741779363cfe"));
+
+  /* Additional tests with different keys (same plaintext)
+   * to check all variants of set_key() */
+  test_cmac_hash (SHEX("2b7e151628aed2a8abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("87dd33c2945a4e228028690ae8954945"));
+
+  test_cmac_hash (SHEX("2b7e1ab628aed2a8abf7158809cf4f3c"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("f0dc613a88886c7ed76eeb51f1c5e8d3"));
+
+  test_cmac_hash (SHEX("2b7e1ab628aed2a8abf7158809cf4f3d"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"
+		       "ae2d8a571e03ac9c9eb76fac45af8e51"
+		       "30c81c46a35ce411"),
+		  SHEX("b9d092dc387a9e42cdfeb9f9930cf567"));
+
+}
+
-- 
2.14.3


["0002-cmac-block_mulx-simplify-shifts.patch" (0002-cmac-block_mulx-simplify-shifts.patch)]

From 627ddf9b745f4fa8da61e0cedb11d024c5b0ddeb Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 17 Jan 2018 10:47:23 +0100
Subject: [PATCH 2/3] cmac: block_mulx: simplify shifts

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 cmac.c | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/cmac.c b/cmac.c
index a4d2468a..27df917e 100644
--- a/cmac.c
+++ b/cmac.c
@@ -57,14 +57,10 @@ static inline void block_mulx(union nettle_block16 *out,
 {
 	uint64_t b1 = READ_UINT64(in-&gt;b);
 	uint64_t b2 = READ_UINT64(in-&gt;b+8);
-	unsigned overflow = (b2 &amp; UINT64_C(0x8000000000000000))?1:0;
 
-	b1 &lt;&lt;= 1;
+	b1 = (b1 &lt;&lt; 1) | (b2 &gt;&gt; 63);
 	b2 &lt;&lt;= 1;
 
-	if (overflow)
-		b1 |= 0x01;
-
 	if (in-&gt;b[0] &amp; 0x80)
 		b2 ^= 0x87;
 
-- 
2.14.3


["0003-Added-support-for-cmac-with-aes-256.patch" (0003-Added-support-for-cmac-with-aes-256.patch)]

From 6551e67f07eb5cf0ed08ab5324492c5d56edfde7 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Tue, 23 Jan 2018 11:33:56 +0100
Subject: [PATCH 3/3] Added support for cmac with aes-256

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 Makefile.in           |  2 +-
 cmac-aes256.c         | 60 ++++++++++++++++++++++++++++++++++
 cmac.h                | 17 +++++++++-
 nettle.texinfo        | 21 +++++++++---
 testsuite/cmac-test.c | 89 +++++++++++++++++++++++++++++++++++----------------
 5 files changed, 156 insertions(+), 33 deletions(-)
 create mode 100644 cmac-aes256.c

diff --git a/Makefile.in b/Makefile.in
index a25c0f99..f6d92755 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -103,7 +103,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-aes256.c gcm-aes256-meta.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
-		 cmac.c cmac-aes128.c \
+		 cmac.c cmac-aes128.c cmac-aes256.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
diff --git a/cmac-aes256.c b/cmac-aes256.c
new file mode 100644
index 00000000..ec3b50db
--- /dev/null
+++ b/cmac-aes256.c
@@ -0,0 +1,60 @@
+/* cmac-aes256.c
+
+   CMAC using AES256 as the underlying cipher.
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "cmac.h"
+
+void
+cmac_aes256_set_key(struct cmac_aes256_ctx *ctx, const uint8_t *key)
+{
+  CMAC128_SET_KEY(ctx, aes256_set_encrypt_key, aes256_encrypt, key);
+}
+
+void
+cmac_aes256_update (struct cmac_aes256_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  CMAC128_UPDATE (ctx, aes256_encrypt, length, data);
+}
+
+void
+cmac_aes256_digest(struct cmac_aes256_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  CMAC128_DIGEST(ctx, aes256_encrypt, length, digest);
+}
diff --git a/cmac.h b/cmac.h
index 168ca95a..1632f54e 100644
--- a/cmac.h
+++ b/cmac.h
@@ -43,7 +43,6 @@
 extern "C" {
 #endif
 
-#define CMAC128_KEY_SIZE 16
 #define CMAC128_DIGEST_SIZE 16
 
 #define cmac128_set_key nettle_cmac128_set_key
@@ -52,6 +51,9 @@ extern "C" {
 #define cmac_aes128_set_key nettle_cmac_aes128_set_key
 #define cmac_aes128_update nettle_cmac_aes128_update
 #define cmac_aes128_digest nettle_cmac_aes128_digest
+#define cmac_aes256_set_key nettle_cmac_aes256_set_key
+#define cmac_aes256_update nettle_cmac_aes256_update
+#define cmac_aes256_digest nettle_cmac_aes256_digest
 
 struct cmac128 {
 	union nettle_block16 K1;
@@ -111,6 +113,19 @@ void
 cmac_aes128_digest(struct cmac_aes128_ctx *ctx,
 		   size_t length, uint8_t *digest);
 
+struct cmac_aes256_ctx CMAC128_CTX(struct aes256_ctx);
+
+void
+cmac_aes256_set_key(struct cmac_aes256_ctx *ctx, const uint8_t *key);
+
+void
+cmac_aes256_update(struct cmac_aes256_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+cmac_aes256_digest(struct cmac_aes256_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/nettle.texinfo b/nettle.texinfo
index 4c7b5312..657c4d4c 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -3498,15 +3498,12 @@ Nettle defines @acronym{CMAC} in @file{&lt;nettle/cmac.h&gt;}.
 @deftp {Context struct} {struct cmac128_ctx}
 @end deftp
 
-@defvr Constant CMAC128_KEY_SIZE
-The CMAC key size, 16.
-@end defvr
 @defvr Constant CMAC128_DIGEST_SIZE
 The size of an CMAC digest, 16.
 @end defvr
 
 @deftypefun void cmac_aes128_set_key (struct cmac_aes128_ctx *@var{ctx}, const \
                uint8_t *@var{key})
-This function initializes the @acronym{CMAC} context struct.
+This function initializes the @acronym{CMAC} context struct for AES-128.
 @end deftypefun
 
 @deftypefun void cmac_aes128_update (struct cmac_aes128_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) @@ -3521,6 +3518,22 @@ provide a smaller \
value, only the first @var{length} octets of the  processing of a new message with \
the same key.  @end deftypefun
 
+@deftypefun void cmac_aes256_set_key (struct cmac_aes256_ctx *@var{ctx}, const \
uint8_t *@var{key}) +This function initializes the @acronym{CMAC} context struct for \
AES-256. +@end deftypefun
+
+@deftypefun void cmac_aes256_update (struct cmac_aes256_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +This function is called zero or more times \
to process the message. +@end deftypefun
+
+@deftypefun void cmac_aes256_digest (struct cmac_aes256_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Extracts the @acronym{MAC} of the message, \
writing it to @var{digest}. +@var{length} is usually equal to the specified output \
size, but if you +provide a smaller value, only the first @var{length} octets of the
+@acronym{MAC} are written. This function resets the context for
+processing of a new message with the same key.
+@end deftypefun
+
 @node Poly1305,, CMAC, Keyed hash functions
 @comment  node-name,  next,  previous,  up
 @subsection Poly1305
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
index 983c5127..58544f2a 100644
--- a/testsuite/cmac-test.c
+++ b/testsuite/cmac-test.c
@@ -2,24 +2,43 @@
 #include "nettle-internal.h"
 #include "cmac.h"
 
+typedef void set_key_func(void *ctx, const uint8_t *key);
+typedef void update_func(void *ctx, size_t length, const uint8_t *data);
+typedef void digest_func(void *ctx, size_t length, uint8_t *digest);
+
+#define test_cmac_aes128(key, msg, ref) \
+	test_cmac_hash ((set_key_func*)cmac_aes128_set_key, \
(update_func*)cmac_aes128_update, \ +			(digest_func*)cmac_aes128_digest, \
sizeof(struct cmac_aes128_ctx), \ +			key, msg, ref)
+
+#define test_cmac_aes256(key, msg, ref) \
+	test_cmac_hash ((set_key_func*)cmac_aes256_set_key, \
(update_func*)cmac_aes256_update, \ +			(digest_func*)cmac_aes256_digest, \
sizeof(struct cmac_aes256_ctx), \ +			key, msg, ref)
+
 static void
-test_cmac_hash (const struct tstring *key, const struct tstring *msg, const struct \
tstring *ref) +test_cmac_hash (set_key_func *set_key, update_func *update,
+		digest_func *digest, size_t ctx_size,
+		const struct tstring *key, const struct tstring *msg,
+		const struct tstring *ref)
 {
-  struct cmac_aes128_ctx ctx;
-  uint8_t digest[16];
+  void *ctx;
+  uint8_t hash[16];
   unsigned i;
 
-  ASSERT (ref-&gt;length == sizeof(digest));
-  ASSERT (key-&gt;length == 16);
-  cmac_aes128_set_key (&amp;ctx, key-&gt;data);
-  cmac_aes128_update (&amp;ctx, msg-&gt;length, msg-&gt;data);
-  cmac_aes128_digest (&amp;ctx, sizeof(digest), digest);
-  if (!MEMEQ (ref-&gt;length, ref-&gt;data, digest))
+  ctx = xalloc(ctx_size);
+
+  ASSERT (ref-&gt;length == sizeof(hash));
+  ASSERT (key-&gt;length == 16 || key-&gt;length == 32);
+  set_key (ctx, key-&gt;data);
+  update (ctx, msg-&gt;length, msg-&gt;data);
+  digest (ctx, sizeof(hash), hash);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
     {
       fprintf (stderr, "cmac_hash failed, msg: ");
       print_hex (msg-&gt;length, msg-&gt;data);
       fprintf(stderr, "Output:");
-      print_hex (16, digest);
+      print_hex (16, hash);
       fprintf(stderr, "Expected:");
       tstring_print_hex(ref);
       fprintf(stderr, "\n");
@@ -27,14 +46,14 @@ test_cmac_hash (const struct tstring *key, const struct tstring \
*msg, const stru  }
 
   /* attempt to re-use the structure */
-  cmac_aes128_update (&amp;ctx, msg-&gt;length, msg-&gt;data);
-  cmac_aes128_digest (&amp;ctx, sizeof(digest), digest);
-  if (!MEMEQ (ref-&gt;length, ref-&gt;data, digest))
+  update (ctx, msg-&gt;length, msg-&gt;data);
+  digest (ctx, sizeof(hash), hash);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
     {
       fprintf (stderr, "cmac_hash failed on re-use, msg: ");
       print_hex (msg-&gt;length, msg-&gt;data);
       fprintf(stderr, "Output:");
-      print_hex (16, digest);
+      print_hex (16, hash);
       fprintf(stderr, "Expected:");
       tstring_print_hex(ref);
       fprintf(stderr, "\n");
@@ -42,16 +61,16 @@ test_cmac_hash (const struct tstring *key, const struct tstring \
*msg, const stru  }
 
   /* attempt byte-by-byte hashing */
-  cmac_aes128_set_key (&amp;ctx, key-&gt;data);
+  set_key (ctx, key-&gt;data);
   for (i=0;i&lt;msg-&gt;length;i++)
-    cmac_aes128_update (&amp;ctx, 1, msg-&gt;data+i);
-  cmac_aes128_digest (&amp;ctx, sizeof(digest), digest);
-  if (!MEMEQ (ref-&gt;length, ref-&gt;data, digest))
+    update (ctx, 1, msg-&gt;data+i);
+  digest (ctx, sizeof(hash), hash);
+  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
     {
       fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
       print_hex (msg-&gt;length, msg-&gt;data);
       fprintf(stderr, "Output:");
-      print_hex (16, digest);
+      print_hex (16, hash);
       fprintf(stderr, "Expected:");
       tstring_print_hex(ref);
       fprintf(stderr, "\n");
@@ -65,22 +84,21 @@ test_main(void)
   /*
    * CMAC-AES Test Vectors from RFC4493.
    */
-
-  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+  test_cmac_aes128 (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
 		  SDATA(""),
 		  SHEX("bb1d6929e95937287fa37d129b756746"));
 
-  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+  test_cmac_aes128 (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
 		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
 		  SHEX("070a16b46b4d4144f79bdd9dd04a287c"));
 
-  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+  test_cmac_aes128 (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
 		  SHEX("6bc1bee22e409f96e93d7e117393172a"
 		       "ae2d8a571e03ac9c9eb76fac45af8e51"
 		       "30c81c46a35ce411"),
 		  SHEX("dfa66747de9ae63030ca32611497c827"));
 
-  test_cmac_hash (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+  test_cmac_aes128 (SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
 		  SHEX("6bc1bee22e409f96e93d7e117393172a"
 		       "ae2d8a571e03ac9c9eb76fac45af8e51"
 		       "30c81c46a35ce411e5fbc1191a0a52ef"
@@ -89,23 +107,40 @@ test_main(void)
 
   /* Additional tests with different keys (same plaintext)
    * to check all variants of set_key() */
-  test_cmac_hash (SHEX("2b7e151628aed2a8abf7158809cf4f3c"),
+  test_cmac_aes128 (SHEX("2b7e151628aed2a8abf7158809cf4f3c"),
 		  SHEX("6bc1bee22e409f96e93d7e117393172a"
 		       "ae2d8a571e03ac9c9eb76fac45af8e51"
 		       "30c81c46a35ce411"),
 		  SHEX("87dd33c2945a4e228028690ae8954945"));
 
-  test_cmac_hash (SHEX("2b7e1ab628aed2a8abf7158809cf4f3c"),
+  test_cmac_aes128 (SHEX("2b7e1ab628aed2a8abf7158809cf4f3c"),
 		  SHEX("6bc1bee22e409f96e93d7e117393172a"
 		       "ae2d8a571e03ac9c9eb76fac45af8e51"
 		       "30c81c46a35ce411"),
 		  SHEX("f0dc613a88886c7ed76eeb51f1c5e8d3"));
 
-  test_cmac_hash (SHEX("2b7e1ab628aed2a8abf7158809cf4f3d"),
+  test_cmac_aes128 (SHEX("2b7e1ab628aed2a8abf7158809cf4f3d"),
 		  SHEX("6bc1bee22e409f96e93d7e117393172a"
 		       "ae2d8a571e03ac9c9eb76fac45af8e51"
 		       "30c81c46a35ce411"),
 		  SHEX("b9d092dc387a9e42cdfeb9f9930cf567"));
 
+  /* CMAC-AES256 vectors taken from phplib */
+  test_cmac_aes256 (SHEX("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"),
 +		  SDATA(""),
+		  SHEX("028962f61b7bf89efc6b551f4667d983"));
+
+  test_cmac_aes256 (SHEX("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"),
 +		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
+		  SHEX("28a7023f452e8f82bd4bf28d8c37c35c"));
+
+  test_cmac_aes256 (SHEX("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"),
 +		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411"),
 +		  SHEX("aaf3d8f1de5640c232f5b169b9c911e6"));
+
+  test_cmac_aes256 (SHEX("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4"),
 +		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710"),
 +		  SHEX("e1992190549f6ed5696a2c056c315410"));
+
 }
 
-- 
2.14.3



</body></email><email><emailId>20180123200356</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-23 20:03:56-0400</timestampReceived><subject>Re: Build system bug with assembler and clang</subject><body>

blargh &lt;youp1one1@gmail.com&gt; writes:

&gt; Adding   x86-* fixed it:
&gt;
&gt; asm_path=
&gt; if test "x$enable_assembler" = xyes ; then
&gt;    case "$host_cpu" in
&gt;        [i?86* | k[5-8]* | pentium* | athlon | x86])
&gt;            asm_path=x86
&gt;            ;;

Done, except that I added it at the front.

Did I understand you correctly, that this was needed for x86 android
builds?

When building for multiple platforms, I recommend using a separate build
directory per platform.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180123220611</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-01-23 22:06:11-0400</timestampReceived><subject>Re: [PATCH 1/2] Provide wrappers around OpenSSL AES GCM</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; What about these two patches? They allow comparing nettle vs OpenSSL
&gt; speed for AES-GCM.

They look ok, but I haven't yet had time to merge them.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180127085733</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-01-27 08:57:33-0400</timestampReceived><subject>Re: API for new AEAD modes</subject><body>

On Wed, 2018-01-24 at 09:46 +0100, Niels Möller wrote:
&gt; 
&gt; &gt; &gt; So then we'de have something similar to the ccm_*_message
&gt; &gt; &gt; functions.
&gt; &gt; &gt; Should the nonce length and tag length be variable per message?
&gt; &gt; 
&gt; &gt; The tag is fixed since it is used as the IV. On the branch I'm
&gt; &gt; working
&gt; &gt; on I have the following interface:
&gt; &gt; 
&gt; &gt; struct siv_aes128_cmac_ctx {
&gt; &gt;     struct aes128_ctx         cipher;
&gt; &gt;     uint8_t s2vk[AES128_KEY_SIZE];
&gt; &gt; };
&gt; &gt; 
&gt; &gt; void
&gt; &gt; siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const
&gt; &gt; uint8_t *key);
&gt; &gt; 
&gt; &gt; void
&gt; &gt; siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
&gt; &gt;                                 size_t nlength, const uint8_t
&gt; &gt; *nonce,
&gt; &gt;                                 size_t alength, const uint8_t
&gt; &gt; *adata,
&gt; &gt;                                 size_t tlength,
&gt; &gt;                                 size_t clength, uint8_t *dst, const
&gt; &gt; uint8_t *src);
&gt; &gt; 
&gt; &gt; int
&gt; &gt; siv_aes128_cmac_decrypt_message(struct siv_aes128_cmac_ctx *ctx,
&gt; &gt;                                 size_t nlength, const uint8_t
&gt; &gt; *nonce,
&gt; &gt;                                 size_t alength, const uint8_t
&gt; &gt; *adata,
&gt; &gt;                                 size_t tlength,
&gt; &gt;                                 size_t mlength, uint8_t *dst, const
&gt; &gt; uint8_t *src);
&gt; 
&gt; I think this is the right level for most applications. But I'm a bit
&gt; confused with regards to my questions. Are the tlength and nlength
&gt; arguments useful (for siv, and and for aead in general)?

The tag length is not. There is an assert in my current code to ensure
its value is right. I've keeped this interface compatible with the CCM
version (assuming that this will be the generic AEAD interface).

The nlength is variable (0 or more) on SIV so it makes sense to have it
there.

&gt; Or should at least tag length be considered parameter of the aead
&gt; algorithm, not something which can vary from message to message?

In CCM removing the tag length will require to introduce a new
interface for CCM-8 vs CCM-16. Other modes like GCM can also use
shorter auth tags, thus fixing the tag to the interface would require a
handful of new functions for each tag length possibility.

&gt; For hashes and macs, use of truncated outputs seemed fairly common,
&gt; which is why the current interfaces includes a digest length
&gt; argument.

Right, RFC5116's text for AEAD ciphers says about tags:
"Each AEAD algorithm MUST provide a description relating the length of
   the plaintext to that of the ciphertext.  This relation MUST NOT
   depend on external parameters, such as an authentication strength
   parameter (e.g., authentication tag length).  That sort of
dependence
   would complicate the use of the algorithm by creating a situation in
   which the information from the AEAD registry was not sufficient to
   ensure interoperability."
(from https://tools.ietf.org/html/rfc5116#section-4 )

So I think that when implementing that API, the tag should be indeed
implicit per AEAD cipher, meaning that CCM-8 should be treated
differently to CCM-16, as well as any GCM variants. The current nettle
interface allows more flexibility in that aspect at the cost of another
function parameter.

&gt; But aeads are a bit different. For SIV, would a shortened tag just
&gt; reduce the strength of authentication, or would it make it impossible
&gt; to decrypt the message?

It is not possible in the sense that the IV should be 128-bits and
having a shortened tag to be used as IV wouldn't be possible by
following the protocol.

&gt; &gt; I think the expectation is to prepend the tag/IV to the message. As
&gt; &gt; the message interface above doesn't distinguish between tag and
&gt; &gt; ciphertext, I think it  quite conveniently fits it.
&gt; 
&gt; For authenticated decryption one needs three pieces of data:
&gt; 
&gt; 1. The nonce.
&gt; 
&gt; 2. The ciphertext.
&gt; 
&gt; 3. The tag.
&gt; 
&gt; The nonce should most likely be a separate argument, it might not be
&gt; attached at all to the data on the wire. E.g., it could be derived
&gt; from an implicit message number.
&gt; 
&gt; The current ccm_*_ message functions represents ciphertext and tag as
&gt; a single blob,
&gt; 
&gt;   +--------------+-------+ 
&gt;   |  ciphertext  |  tag  |
&gt;   +--------------+-------+ 
&gt; 
&gt; It seems you're saying that for siv, you put them together in the
&gt; opposite order,
&gt; 
&gt;   +-------+--------------+ 
&gt;   |  tag  |  ciphertext  |
&gt;   +-------+--------------+ 
&gt; 
&gt; Should we treat the encrypted message as a single blob, with any
&gt; internal structure being an internal detail of the aead? That seems
&gt; to be the RFC 5116 view.

I think that's reasonable expectation.

&gt; In case there are protocols or applications that specify that
&gt; ciphertext
&gt; and tag are sent/stored as separately byte strings, we would need to
&gt; expose that distinction in the api. E.g., say we do in-place
&gt; block-by-block encryption on disk, and treat nonce and tag for each
&gt; block as metadata, stored elsewhere.

I'm not sure whether that's a possibility. A protocol which would use
an AEAD cipher (e.g., like NTP), would use the formatting required by
the AEAD cipher. 


&gt; &gt; A possible interface could be:
&gt; &gt; void siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const
&gt; &gt; uint8_t *key)
&gt; &gt; void siv_aes128_cmac_s2v(struct siv_aes128_cmac_ctx *ctx, size_t
&gt; &gt; nlength, const uint8_t *nonce,
&gt; &gt;                             size_t adatalen, size_t *alength, const
&gt; &gt; uint8_t **adata,
&gt; &gt;                             size_t plength, size_t pdata);
&gt; &gt; 
&gt; &gt; (notice the pointer to pointer for adata)
&gt; 
&gt; I think I'd prefer something like
&gt; 
&gt; void 
&gt; siv_aes128_cmac_extra_adata(struct siv_aes128_cmac_ctx *ctx, 
&gt;                             size_t length, const uint8_t *data);
&gt; 
&gt; to be called zero or more times between _set_key and the call with
&gt; the
&gt; body of the message. (Probably need a separate set_nonce function
&gt; too,
&gt; if nonce must be known before processing and associated data).

But then when would generate the actual IV? When data are added
gradually, one would have to require order in the calling of functions,
to ensure that one would generate the IV to be used by the encryption
functions. For  example require

siv_aes128_cmac_set_key
siv_aes128_cmac_extra_adata
siv_aes128_cmac_extra_adata
siv_aes_128_cmac_set_nonce (must be last and must be called even if
there is no nonce, and will generate and save the IV)
siv_aes128_cmac_decrypt (which will use the saved in ctx IV)

or

siv_aes128_cmac_set_key
siv_aes128_cmac_extra_adata
siv_aes128_cmac_extra
_adata
siv_aes_128_cmac_set_nonce
siv_aes_128_cmac_get_iv
siv_aes128_cmac_
decrypt (which will use the provided in param IV)

I'm also not sure how to check the tag? Make siv_aes128_cmac_decrypt()
check it and return an int, or provide a digest function which will
return the generated IV and let the caller do something with it?

Shouldn't the siv_aes128_cmac_extra_adata be named
siv_aes128_cmac_update? (though its semantics would be different from
other AEAD ciphers as updating with "ab" is different than two calls
with "a" and "b").

Overall, the more I look how a low level API for SIV would look like,
the more I think having only a high level one.

regards,
Nikos


</body></email><email><emailId>20180131152213</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-01-31 15:22:13-0400</timestampReceived><subject>Re: Performance of AESNI impl vs other crypto libraries</subject><body>

On Tue, 2018-01-30 at 20:57 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt; 
&gt; &gt; To follow up on this, gcm would get an 8% (on my system) speedup by
&gt; &gt; switching gcm_crypt() with ctr_crypt(). With that change as is
&gt; &gt; however,
&gt; &gt;  the 32-bit counter is replaced with an "unlimited" counter.
&gt; &gt; Wouldn't
&gt; &gt; introducing an assert on decrypt and encrypt length be sufficient
&gt; &gt; to
&gt; &gt; share that code?
&gt; 
&gt; I think it's valid to use gcm with an IV which makes the 32-bit
&gt; counter
&gt; start close to 2^32 - 1, and then propagating carry further then 32
&gt; bits
&gt; would produce incorrect results. Right? (I'm afraid there's no test
&gt; case
&gt; for that, though).
&gt; 
&gt; I agree it would be very nice to reuse ctr_crypt and not duplicate
&gt; most
&gt; of the logic. But I think we need a gcm-specific variant of ctr_fill.
&gt; To
&gt; do that, it would make sense to add a field
&gt; 
&gt;  uint32_t u32[4];
&gt; 
&gt; to the nettle_block16 union.
&gt; 
&gt; To reduce code duplication, we could add a fill function pointer as
&gt; argument to ctr_crypt16, and use that for gcm. Not sure if that's a
&gt; good
&gt; idea, but it might be nice and clean and indirect call to the fill
&gt; function should be negligible.

It seems that ctr_crypt16() would not handle the whole input and that
was complicating things. I've modified it towards that, and added the
parameter. I did a gcm_fill(), but I didn't see the need for the
nettle_block16 update, as the version I did (quite simplistic), didn't
seem to differ in performance comparing to ctr_fill16.

regards,
Nikos

["0001-gcm-use-ctr_crypt16-for-improved-performance.patch" (0001-gcm-use-ctr_crypt16-for-improved-performance.patch)]

From 10ce4feedec9df53636aa64e41e43e01d260f42c Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 31 Jan 2018 13:22:20 +0100
Subject: [PATCH] gcm: use ctr_crypt16() for improved performance

That also enhances ctr_crypt16() to be complete and handle
the full input.
---
 Makefile.in    |  1 +
 ctr-internal.h | 39 +++++++++++++++++++++++++++++++++++++++
 ctr.c          | 44 ++++++++++++++++++++++++++++++--------------
 gcm.c          | 50 ++++++++++++++++++--------------------------------
 4 files changed, 88 insertions(+), 46 deletions(-)
 create mode 100644 ctr-internal.h

diff --git a/Makefile.in b/Makefile.in
index 6a0c13ec..58980341 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -228,6 +228,7 @@ DISTFILES = $(SOURCES) $(HEADERS) getopt.h getopt_int.h \
 	aes-internal.h camellia-internal.h serpent-internal.h \
 	cast128_sboxes.h desinfo.h desCode.h \
 	memxor-internal.h nettle-internal.h nettle-write.h \
+	ctr-internal.h \
 	gmp-glue.h ecc-internal.h fat-setup.h \
 	mini-gmp.h asm.m4 \
 	nettle.texinfo nettle.info nettle.html nettle.pdf sha-example.c
diff --git a/ctr-internal.h b/ctr-internal.h
new file mode 100644
index 00000000..246afaba
--- /dev/null
+++ b/ctr-internal.h
@@ -0,0 +1,39 @@
+/* ctr.c
+
+   Cipher counter mode.
+
+   Copyright (C) 2005-2018 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+void
+ctr_crypt16(const void *ctx, nettle_cipher_func *f,
+	    void (*fillfunc)(uint8_t *ctr, size_t blocks, uint64_t *buffer),
+	    uint8_t *ctr,
+	    size_t length, uint8_t *dst,
+	    const uint8_t *src);
diff --git a/ctr.c b/ctr.c
index 8295e1af..2c7ddf3d 100644
--- a/ctr.c
+++ b/ctr.c
@@ -40,6 +40,7 @@
 #include &lt;string.h&gt;
 
 #include "ctr.h"
+#include "ctr-internal.h"
 
 #include "macros.h"
 #include "memxor.h"
@@ -106,20 +107,37 @@ ctr_fill16(uint8_t *ctr, size_t blocks, uint64_t *buffer)
 # endif
 #endif /* !WORDS_BIGENDIAN */
 
-#if USE_CTR_CRYPT16
-static size_t
+void
 ctr_crypt16(const void *ctx, nettle_cipher_func *f,
+	    void (*fill)(uint8_t *ctr, size_t blocks, uint64_t *buffer),
 	    uint8_t *ctr,
 	    size_t length, uint8_t *dst,
 	    const uint8_t *src)
 {
   if (dst != src &amp;&amp; !((uintptr_t) dst % sizeof(uint64_t)))
     {
+      size_t done;
       size_t blocks = length / 16u;
-      ctr_fill16 (ctr, blocks, (uint64_t *) dst);
-      f(ctx, blocks * 16, dst, dst);
-      memxor (dst, src, blocks * 16);
-      return blocks * 16;
+      fill (ctr, blocks, (uint64_t *) dst);
+
+      done = blocks * 16;
+      f(ctx, done, dst, dst);
+      memxor (dst, src, done);
+
+      dst += done;
+      src += done;
+      length -= done;
+
+      /* remainder &lt; 1 block */
+      if (length &gt; 0)
+        {
+	  uint8_t block[16];
+
+	  f(ctx, 16, block, ctr);
+	  fill (ctr, 1, (uint64_t *) ctr);
+	  memxor3(dst, src, block, length);
+	}
+      return;
     }
   else
     {
@@ -133,7 +151,7 @@ ctr_crypt16(const void *ctx, nettle_cipher_func *f,
       for (i = 0; blocks &gt;= CTR_BUFFER_LIMIT / 16;
 	   i += CTR_BUFFER_LIMIT, blocks -= CTR_BUFFER_LIMIT / 16)
 	{
-	  ctr_fill16 (ctr, CTR_BUFFER_LIMIT / 16, buffer-&gt;u64);
+	  fill (ctr, CTR_BUFFER_LIMIT / 16, buffer-&gt;u64);
 	  f(ctx, CTR_BUFFER_LIMIT, buffer-&gt;b, buffer-&gt;b);
 	  if (length - i &lt; CTR_BUFFER_LIMIT)
 	    goto done;
@@ -143,15 +161,14 @@ ctr_crypt16(const void *ctx, nettle_cipher_func *f,
       if (blocks &gt; 0)
 	{
 	  assert (length - i &lt; CTR_BUFFER_LIMIT);
-	  ctr_fill16 (ctr, blocks, buffer-&gt;u64);
+	  fill (ctr, blocks, buffer-&gt;u64);
 	  f(ctx, blocks * 16, buffer-&gt;b, buffer-&gt;b);
 	done:
 	  memxor3 (dst + i, src + i, buffer-&gt;b, length - i);
       }
-      return length;
+      return;
     }
 }
-#endif /* USE_CTR_CRYPT16 */
 
 void
 ctr_crypt(const void *ctx, nettle_cipher_func *f,
@@ -162,10 +179,9 @@ ctr_crypt(const void *ctx, nettle_cipher_func *f,
 #if USE_CTR_CRYPT16
   if (block_size == 16)
     {
-      size_t done = ctr_crypt16(ctx, f, ctr, length, dst, src);
-      length -= done;
-      src += done;
-      dst += done;
+      ctr_crypt16(ctx, f, ctr_fill16, ctr, length, dst, src);
+
+      return;
     }
 #endif
 
diff --git a/gcm.c b/gcm.c
index 0a2102f1..062410e9 100644
--- a/gcm.c
+++ b/gcm.c
@@ -51,6 +51,7 @@
 #include "memxor.h"
 #include "nettle-internal.h"
 #include "macros.h"
+#include "ctr.h"
 
 #define GHASH_POLYNOMIAL 0xE1UL
 
@@ -435,40 +436,25 @@ gcm_update(struct gcm_ctx *ctx, const struct gcm_key *key,
 }
 
 static void
-gcm_crypt(struct gcm_ctx *ctx, const void *cipher, nettle_cipher_func *f,
-	  size_t length, uint8_t *dst, const uint8_t *src)
+gcm_fill(uint8_t *ctr, size_t blocks, uint64_t *_buffer)
 {
-  uint8_t buffer[GCM_BLOCK_SIZE];
+  uint8_t *buffer = _buffer;
+  uint32_t c;
 
-  if (src != dst)
-    {
-      for (; length &gt;= GCM_BLOCK_SIZE;
-           (length -= GCM_BLOCK_SIZE,
-	    src += GCM_BLOCK_SIZE, dst += GCM_BLOCK_SIZE))
-        {
-          f (cipher, GCM_BLOCK_SIZE, dst, ctx-&gt;ctr.b);
-          memxor (dst, src, GCM_BLOCK_SIZE);
-          INC32 (ctx-&gt;ctr);
-        }
-    }
-  else
-    {
-      for (; length &gt;= GCM_BLOCK_SIZE;
-           (length -= GCM_BLOCK_SIZE,
-	    src += GCM_BLOCK_SIZE, dst += GCM_BLOCK_SIZE))
-        {
-          f (cipher, GCM_BLOCK_SIZE, buffer, ctx-&gt;ctr.b);
-          memxor (dst, buffer, GCM_BLOCK_SIZE);
-          INC32 (ctx-&gt;ctr);
-        }
-    }
-  if (length &gt; 0)
+  c = READ_UINT32(ctr + GCM_BLOCK_SIZE - 4);
+
+  while (blocks-- &gt; 0)
     {
-      /* A final partial block */
-      f (cipher, GCM_BLOCK_SIZE, buffer, ctx-&gt;ctr.b);
-      memxor3 (dst, src, buffer, length);
-      INC32 (ctx-&gt;ctr);
+      memcpy(buffer, ctr, GCM_BLOCK_SIZE - 4);
+      buffer += GCM_BLOCK_SIZE - 4;
+
+      WRITE_UINT32(buffer, c);
+      buffer += 4;
+
+      c++;
     }
+
+  WRITE_UINT32(ctr + GCM_BLOCK_SIZE - 4, c);
 }
 
 void
@@ -478,7 +464,7 @@ gcm_encrypt (struct gcm_ctx *ctx, const struct gcm_key *key,
 {
   assert(ctx-&gt;data_size % GCM_BLOCK_SIZE == 0);
 
-  gcm_crypt(ctx, cipher, f, length, dst, src);
+  ctr_crypt16(cipher, f, gcm_fill, ctx-&gt;ctr.b, length, dst, src);
   gcm_hash(key, &amp;ctx-&gt;x, length, dst);
 
   ctx-&gt;data_size += length;
@@ -492,7 +478,7 @@ gcm_decrypt(struct gcm_ctx *ctx, const struct gcm_key *key,
   assert(ctx-&gt;data_size % GCM_BLOCK_SIZE == 0);
 
   gcm_hash(key, &amp;ctx-&gt;x, length, src);
-  gcm_crypt(ctx, cipher, f, length, dst, src);
+  ctr_crypt16(cipher, f, gcm_fill, ctx-&gt;ctr.b, length, dst, src);
 
   ctx-&gt;data_size += length;
 }
-- 
2.14.3



</body></email><email><emailId>20180613094140</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-06-13 09:41:40-0400</timestampReceived><subject>[PATCH] Fix quoting in autoconf ifunc test</subject><body>

* aclocal.m4 (NETTLE_CHECK_IFUNC): fix quoting so that
  AC_LINK_IFELSE/AC_TRY_LINK is defined outside of this test.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 aclocal.m4 | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/aclocal.m4 b/aclocal.m4
index 783dbc492b5c..772f68e8eb9d 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -650,7 +650,7 @@ AC_DEFUN([NETTLE_CHECK_IFUNC],
 [AC_REQUIRE([AC_PROG_CC])
 AC_CACHE_CHECK([for ifunc support],
   nettle_cv_link_ifunc,
-  AC_LINK_IFELSE([AC_LANG_PROGRAM([
+  [AC_LINK_IFELSE([AC_LANG_PROGRAM([
 static int
 foo_imp(int x)
 {
@@ -671,7 +671,7 @@ int foo (int x) __attribute__ ((ifunc("foo_resolv")));
 
 ])],
 [nettle_cv_link_ifunc=yes],
-[nettle_cv_link_ifunc=no]))
+[nettle_cv_link_ifunc=no])])
 AH_TEMPLATE([HAVE_LINK_IFUNC], [Define if compiler and linker supports __attribute__ ifunc])
 if test "x$nettle_cv_link_ifunc" = xyes ; then
   AC_DEFINE(HAVE_LINK_IFUNC)
-- 
2.17.1


</body></email><email><emailId>20180606141059</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-06-06 14:10:59-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

Hi,
 This patch makes the exported symbols explicit in the map file.
Furthermore it moves symbols only listed in internal headers in a
special section which makes them valid only for testing. I've tested
it with abi-compliance-checker and it detects the following missing
from nettle:
nettle_aeads, nettle_armors, nettle_ciphers, nettle_hashes
and from hogweed the nettle_secp_*r1, which seem expected.

Niels, I'm not sure however if that was your intention. Didn't you
want to deprecate some of the _nettle symbols as well like
_nettle_secp_256r1? These are however still present in the exported
headers and unless we remove them, they seem to be part of the API and
ABI.

I also attach the script which generated the files in case you'd like
to play with it.

regards,
Nikos
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0001-map-files-explicitly-add-exported-symbols.patch
Type: text/x-patch
Size: 22432 bytes
Desc: not available
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20180606/dc7e0025/attachment.bin&gt;

</body></email><email><emailId>20180608084139</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-06-08 08:41:39-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos at gmail.com&gt; writes:

&gt; Niels, I'm not sure however if that was your intention. Didn't you
&gt; want to deprecate some of the _nettle symbols as well like
&gt; _nettle_secp_256r1?

I was thinking of doing something simple, with nettle_* symbols going
into the supported ABI (symbol version NETTLE_ at LIBNETTLE_MAJOR@), and
all _nettle_* symbols getting symbol version
NETTLE_ at LIBNETTLE_MAJOR@_ at LIBNETTLE_MINOR@, which explicitly makes them
*not* binary compatible between minor versions.

I think it's helpful that ABI status corresponds to the names used in
the source and header files, both for maintenance and for user
documentation.

What do you think? Are there any of the current _nettle_* symbols that
should be in the advertised API (and hence renamed)?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180809201617</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-08-09 20:16:17-0400</timestampReceived><subject>Deprecation</subject><body>

I've looked into using __attribute__ ((deprecated)).

See branch attribute-deprecated. I define _NETTLE_ATTRIBUTE_DEPRECATED
in nettle-types.h (and _NETTLE_ATTRIBUTE_PURE, needed in a few places).
For a start, I've marked the old aes and gcm-aes interfaces as deprecated,
as discussed earlier, and the obsolete _rsa_blind and _rsa_unblind
functions.

Some more functions are candidates for deprecation:

1. Everything in des-compat.h and md5-compat.h. Unless we think it can
   be deleted without deprecation; I'm not aware of any usage, and they
   made more sense back in 2001 when Nettle-1.0 was brand new.

2. The "general" hmac functions: hmac_set_key, hmac_update, hmac_digest.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180920113253</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-09-20 11:32:53-0400</timestampReceived><subject>[PATCH] ctr16: fix encryption if src == dst</subject><body>

If src == dst, ctr16 code will fail to increment src and dst pointers,
always overwriting first block.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 ctr16.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ctr16.c b/ctr16.c
index 60418e8b9032..7e1c23d20832 100644
--- a/ctr16.c
+++ b/ctr16.c
@@ -91,7 +91,7 @@ _ctr_crypt16(const void *ctx, nettle_cipher_func *f,
 	  f(ctx, CTR_BUFFER_LIMIT, buffer-&gt;b, buffer-&gt;b);
 	  if (length - i &lt; CTR_BUFFER_LIMIT)
 	    goto done;
-	  memxor3 (dst, src, buffer-&gt;b, CTR_BUFFER_LIMIT);
+	  memxor3 (dst + i, src + i, buffer-&gt;b, CTR_BUFFER_LIMIT);
 	}
 
       if (blocks &gt; 0)
-- 
2.18.0


</body></email><email><emailId>20181118104224</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-11-18 10:42:24-0400</timestampReceived><subject>nettle-3.4.1</subject><body>

It turns out there's a need for a bugfix-only release nettle-3.4.1, to
be released in a few weeks.

I've created a branch release-3.4-fixes, and backported a few bugfixes
(see commit history or ChangeLog on that branch),
https://git.lysator.liu.se/nettle/nettle/blob/release-3.4-fixes/ChangeLog

I'm sorry I haven't been able to respond to the recently posted patches
on this list. I'll get back to that after 3.4.1.

If you think I've missed some important bugfixes, please speak up.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20181202120250</emailId><senderName>=?UTF-8?Q?Tim_R=c3=bchsen?=</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2018-12-02 12:02:50-0400</timestampReceived><subject>Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

Hi Niels,

thank you (and all involved) for the fixes !

Are you going to merge all of those into your master branch, so that
e.g. latest GnuTLS can be build it ?

Reason:
Currently I see a several automated builds breaking. It's those with
the latest GnuTLS (from git master) as dependency. They normally pull in
all dependencies (nettle and others) in their latest version from git
repos (mostly branch 'master'). Latest nettle master would need the
fixes *and* a version 3.4.1 tag (or higher) to build with GnuTLS here.

Thank you !

Regards, Tim

On 30.11.18 17:41, Niels Möller wrote:
&gt; A release candidate for nettle-3.4.1 is now available, as 
&gt; 
&gt;   https://www.lysator.liu.se/~nisse/archive/nettle-3.4.1rc1.tar.gz
&gt;   https://www.lysator.liu.se/~nisse/archive/nettle-3.4.1rc1.tar.gz.sig
&gt; 
&gt; Corresponding changes are also pushed to the branch
&gt; https://git.lysator.liu.se/nettle/nettle/tree/release-3.4-fixes
&gt; ...

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20181202/ed4d0851/attachment.sig&gt;

</body></email><email><emailId>20181202155640</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-12-02 15:56:40-0400</timestampReceived><subject>Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

Tim Rühsen &lt;tim.ruehsen at gmx.de&gt; writes:

&gt; Are you going to merge all of those into your master branch, so that
&gt; e.g. latest GnuTLS can be build it ?

I will, but not with urgency. And possibly with slightly different
organization (but the implementation and the new rsa_sec_decrypt api
will be the same). And I'll be a bit busy both coming week and next
weekend.

And naturally, getting the 3.4.1 release out has the highest priority,
which should happen in a day or two. I would have hoped for a bit more
testing, but I'll have to make release very soon regardless.

&gt; Currently I see a several automated builds breaking. It's those with
&gt; the latest GnuTLS (from git master) as dependency. They normally pull in
&gt; all dependencies (nettle and others) in their latest version from git
&gt; repos (mostly branch 'master').

There's both a branch "release-3.4-fixes", and a tag "nettle_3.4.1rc1".
Could you use either of them for the Nettle dependency in the mean
time?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20181202164626</emailId><senderName>=?UTF-8?Q?Tim_R=c3=bchsen?=</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2018-12-02 16:46:26-0400</timestampReceived><subject>Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

On 02.12.18 16:56, Niels Möller wrote:
&gt; Tim Rühsen &lt;tim.ruehsen at gmx.de&gt; writes:
&gt; 
&gt;&gt; Are you going to merge all of those into your master branch, so that
&gt;&gt; e.g. latest GnuTLS can be build it ?
&gt; 
&gt; I will, but not with urgency. And possibly with slightly different
&gt; organization (but the implementation and the new rsa_sec_decrypt api
&gt; will be the same). And I'll be a bit busy both coming week and next
&gt; weekend.
&gt; 
&gt; And naturally, getting the 3.4.1 release out has the highest priority,
&gt; which should happen in a day or two. I would have hoped for a bit more
&gt; testing, but I'll have to make release very soon regardless.
&gt; 
&gt;&gt; Currently I see a several automated builds breaking. It's those with
&gt;&gt; the latest GnuTLS (from git master) as dependency. They normally pull in
&gt;&gt; all dependencies (nettle and others) in their latest version from git
&gt;&gt; repos (mostly branch 'master').
&gt; 
&gt; There's both a branch "release-3.4-fixes", and a tag "nettle_3.4.1rc1".
&gt; Could you use either of them for the Nettle dependency in the mean
&gt; time?

That's an option, but needs manual work (testing, PR/MRs, review, etc).
So for my part I would just wait until the merge is done.

Thanks for the info !

Regards, Tim

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20181202/23e02a30/attachment.sig&gt;

</body></email><email><emailId>20181203080929</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-12-03 08:09:29-0400</timestampReceived><subject>Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

On Sun, 2018-12-02 at 17:46 +0100, Tim Rühsen wrote:

&gt; &gt; &gt; Currently I see a several automated builds breaking. It's those
&gt; &gt; &gt; with
&gt; &gt; &gt; the latest GnuTLS (from git master) as dependency. They normally
&gt; &gt; &gt; pull in
&gt; &gt; &gt; all dependencies (nettle and others) in their latest version from
&gt; &gt; &gt; git
&gt; &gt; &gt; repos (mostly branch 'master').
&gt; &gt; 
&gt; &gt; There's both a branch "release-3.4-fixes", and a tag
&gt; &gt; "nettle_3.4.1rc1".
&gt; &gt; Could you use either of them for the Nettle dependency in the mean
&gt; &gt; time?
&gt; 
&gt; That's an option, but needs manual work (testing, PR/MRs, review,
&gt; etc).
&gt; So for my part I would just wait until the merge is done.

Was it oss-fuzz you had in mind? Indeed it's unfortunate that our
automation breaks on such situations, but I guess if that's temporary,
that's ok.

regards,
Nikos



</body></email><email><emailId>20181203082309</emailId><senderName>=?UTF-8?Q?Tim_R=c3=bchsen?=</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2018-12-03 08:23:09-0400</timestampReceived><subject>Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

On 12/3/18 9:09 AM, Nikos Mavrogiannopoulos wrote:
&gt; On Sun, 2018-12-02 at 17:46 +0100, Tim Rühsen wrote:
&gt; 
&gt;&gt;&gt;&gt; Currently I see a several automated builds breaking. It's those
&gt;&gt;&gt;&gt; with
&gt;&gt;&gt;&gt; the latest GnuTLS (from git master) as dependency. They normally
&gt;&gt;&gt;&gt; pull in
&gt;&gt;&gt;&gt; all dependencies (nettle and others) in their latest version from
&gt;&gt;&gt;&gt; git
&gt;&gt;&gt;&gt; repos (mostly branch 'master').
&gt;&gt;&gt;
&gt;&gt;&gt; There's both a branch "release-3.4-fixes", and a tag
&gt;&gt;&gt; "nettle_3.4.1rc1".
&gt;&gt;&gt; Could you use either of them for the Nettle dependency in the mean
&gt;&gt;&gt; time?
&gt;&gt;
&gt;&gt; That's an option, but needs manual work (testing, PR/MRs, review,
&gt;&gt; etc).
&gt;&gt; So for my part I would just wait until the merge is done.
&gt; 
&gt; Was it oss-fuzz you had in mind? Indeed it's unfortunate that our
&gt; automation breaks on such situations, but I guess if that's temporary,
&gt; that's ok.

OSS-Fuzz and some Gitlab CI images (Debian based MinGW) where I have to
build all MinGW dependencies. And yes, I am pretty relaxed knowing the
break is temporary.

Regards, Tim

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20181203/2dd55458/attachment.sig&gt;

</body></email><email><emailId>20181226142848</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-12-26 14:28:48-0400</timestampReceived><subject>Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

Tim Rühsen &lt;tim.ruehsen at gmx.de&gt; writes:

&gt; Are you going to merge all of those into your master branch, so that
&gt; e.g. latest GnuTLS can be build it ?

I've now done a merge from the release-3.4-fixes branch to master. The
gnutls build on gitlab still fails one test, 

FAIL: testcompat-tls13-openssl.sh

See https://gitlab.com/gnutls/nettle/pipelines/41333133.

But at least it seems to build fine now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20181227141852</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-12-27 14:18:52-0400</timestampReceived><subject>Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

I am not at home to check but most likely a newer openssl is needed. You can use fedora:29 or fedora:latest


On December 26, 2018 2:28:48 PM UTC, nisse at lysator.liu.se wrote:
&gt;Tim Rühsen &lt;tim.ruehsen at gmx.de&gt; writes:
&gt;
&gt;&gt; Are you going to merge all of those into your master branch, so that
&gt;&gt; e.g. latest GnuTLS can be build it ?
&gt;
&gt;I've now done a merge from the release-3.4-fixes branch to master. The
&gt;gnutls build on gitlab still fails one test, 
&gt;
&gt;FAIL: testcompat-tls13-openssl.sh
&gt;
&gt;See https://gitlab.com/gnutls/nettle/pipelines/41333133.
&gt;
&gt;But at least it seems to build fine now.
&gt;
&gt;Regards,
&gt;/Niels
&gt;
&gt;-- 
&gt;Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
&gt;Internet email is subject to wholesale government surveillance.
&gt;_______________________________________________
&gt;nettle-bugs mailing list
&gt;nettle-bugs at lists.lysator.liu.se
&gt;http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

-- 
Sent from my mobile. Please excuse my brevity.

</body></email><email><emailId>20181228121842</emailId><senderName>=?UTF-8?Q?Tim_R=c3=bchsen?=</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2018-12-28 12:18:42-0400</timestampReceived><subject>Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

Thank you, Niels !

On 26.12.18 15:28, Niels Möller wrote:
&gt; Tim Rühsen &lt;tim.ruehsen at gmx.de&gt; writes:
&gt; 
&gt;&gt; Are you going to merge all of those into your master branch, so that
&gt;&gt; e.g. latest GnuTLS can be build it ?
&gt; 
&gt; I've now done a merge from the release-3.4-fixes branch to master. The
&gt; gnutls build on gitlab still fails one test, 
&gt; 
&gt; FAIL: testcompat-tls13-openssl.sh
&gt; 
&gt; See https://gitlab.com/gnutls/nettle/pipelines/41333133.
&gt; 
&gt; But at least it seems to build fine now.
&gt; 
&gt; Regards,
&gt; /Niels
&gt; 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20181228/a942df95/attachment.sig&gt;

</body></email><email><emailId>20181229094048</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-12-29 09:40:48-0400</timestampReceived><subject>Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos at gmail.com&gt; writes:

&gt; I am not at home to check but most likely a newer openssl is needed. You can use \
&gt; fedora:29 or fedora:latest

Ok, I'm trying 

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 166de71b..f4ed3496 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -1,7 +1,7 @@
 variables:
   BUILD_IMAGES_PROJECT: gnutls/build-images
   DEBIAN_CROSS_BUILD: buildenv-debian-cross
-  FEDORA_BUILD: buildenv-f28
+  FEDORA_BUILD: buildenv-f29
   FEDORA_X86_BUILD: buildenv-f28-x86
   GET_SOURCES_ATTEMPTS: "3"

(Also changing FEDORA_X86_BUILD in a similar way failed).

I've also added needed asserts in eccdata, to satisfy the static
analyzer (and I guess eccdata's validation of command line args isn't
that robust even efter these changes, but it doesn't really need to be).

Ouch, and it seems the static analyzer now has even more warnings on
eccdata. Maybe more asserts needed to tell it that accesses are within
the allocated and initialized table size.

Besides that, there's one remaining warning from the static analyzer, on
examples/eratosthenes.c. I'm considering just deleting that file.

It was used for generating tables used by bignum-next-prime.c, but that
file was deleted a few years ago. It was unused since prime generation
was rewritten in 2010. The new (in 2010) code in nettle_random_prime
uses a smaller table of the 171 odd primes &lt; 1024, and some auxillary
tables to aid trial division. I'm afraid I don't recall what tools were
used to prepare those tables.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20181229113635</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-12-29 11:36:35-0400</timestampReceived><subject>Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

For x86 builds the new image uses debian because it has a simpler and has a \
reproducible way to generate it. The x86 fedora image will remain though.

With the current nettle master oss fuzz still fails to compile (does link statically) \
due to cnd_memcpy not found:

https://oss-fuzz-build-logs.storage.googleapis.com/log-8fca2d38-422a-47bf-84b5-e6fe3b6a9c73.txt



On December 29, 2018 9:40:48 AM UTC, nisse at lysator.liu.se wrote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos at gmail.com&gt; writes:
&gt; 
&gt; &gt; I am not at home to check but most likely a newer openssl is needed.
&gt; You can use fedora:29 or fedora:latest
&gt; 
&gt; Ok, I'm trying 
&gt; 
&gt; diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
&gt; index 166de71b..f4ed3496 100644
&gt; --- a/.gitlab-ci.yml
&gt; +++ b/.gitlab-ci.yml
&gt; @@ -1,7 +1,7 @@
&gt; variables:
&gt; BUILD_IMAGES_PROJECT: gnutls/build-images
&gt; DEBIAN_CROSS_BUILD: buildenv-debian-cross
&gt; -  FEDORA_BUILD: buildenv-f28
&gt; +  FEDORA_BUILD: buildenv-f29
&gt; FEDORA_X86_BUILD: buildenv-f28-x86
&gt; GET_SOURCES_ATTEMPTS: "3"
&gt; 
&gt; (Also changing FEDORA_X86_BUILD in a similar way failed).
&gt; 
&gt; I've also added needed asserts in eccdata, to satisfy the static
&gt; analyzer (and I guess eccdata's validation of command line args isn't
&gt; that robust even efter these changes, but it doesn't really need to
&gt; be).
&gt; 
&gt; Ouch, and it seems the static analyzer now has even more warnings on
&gt; eccdata. Maybe more asserts needed to tell it that accesses are within
&gt; the allocated and initialized table size.
&gt; 
&gt; Besides that, there's one remaining warning from the static analyzer,
&gt; on
&gt; examples/eratosthenes.c. I'm considering just deleting that file.
&gt; 
&gt; It was used for generating tables used by bignum-next-prime.c, but that
&gt; file was deleted a few years ago. It was unused since prime generation
&gt; was rewritten in 2010. The new (in 2010) code in nettle_random_prime
&gt; uses a smaller table of the 171 odd primes &lt; 1024, and some auxillary
&gt; tables to aid trial division. I'm afraid I don't recall what tools were
&gt; used to prepare those tables.
&gt; 
&gt; Regards,
&gt; /Niels

-- 
Sent from my mobile. Please excuse my brevity.


</body></email><email><emailId>20181009075400</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-10-09 07:54:00-0400</timestampReceived><subject>[PATCH] ctr16: fix encryption if src == dst</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt; writes:

&gt; This is an important bugfix. Current code will just silently skip higher blocks.
&gt; Do you want a demonstration/testcase from me?

A patch to extend the testsuite is highly appreciated. I agree it's a
severe bug, thanks for reporting.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20181010172917</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-10-10 17:29:17-0400</timestampReceived><subject>[PATCH] ctr16: fix encryption if src == dst</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt; writes:

&gt; If src == dst, ctr16 code will fail to increment src and dst pointers,
&gt; always overwriting first block.
&gt;
&gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
&gt; ---
&gt;  ctr16.c | 2 +-
&gt;  1 file changed, 1 insertion(+), 1 deletion(-)
&gt;
&gt; diff --git a/ctr16.c b/ctr16.c
&gt; index 60418e8b9032..7e1c23d20832 100644
&gt; --- a/ctr16.c
&gt; +++ b/ctr16.c
&gt; @@ -91,7 +91,7 @@ _ctr_crypt16(const void *ctx, nettle_cipher_func *f,
&gt;  	  f(ctx, CTR_BUFFER_LIMIT, buffer-&gt;b, buffer-&gt;b);
&gt;  	  if (length - i &lt; CTR_BUFFER_LIMIT)
&gt;  	    goto done;
&gt; -	  memxor3 (dst, src, buffer-&gt;b, CTR_BUFFER_LIMIT);
&gt; +	  memxor3 (dst + i, src + i, buffer-&gt;b, CTR_BUFFER_LIMIT);
&gt;  	}
&gt;  
&gt;        if (blocks &gt; 0)

Applied, thanks!

If I understand this correctly, bug is triggered only when processing &gt;=
1024 bytes (2 * CTR_BUFFER_LIMIT) at a time. If you would like to write
a test case, that's appreciated.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180608090729</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-06-08 09:07:29-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

On Fri, 2018-06-08 at 10:41 +0200, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos at gmail.com&gt; writes:
&gt; 
&gt; &gt; Niels, I'm not sure however if that was your intention. Didn't you
&gt; &gt; want to deprecate some of the _nettle symbols as well like
&gt; &gt; _nettle_secp_256r1?
&gt; 
&gt; I was thinking of doing something simple, with nettle_* symbols going
&gt; into the supported ABI (symbol version NETTLE_ at LIBNETTLE_MAJOR@), and
&gt; all _nettle_* symbols getting symbol version
&gt; NETTLE_ at LIBNETTLE_MAJOR@_ at LIBNETTLE_MINOR@, which explicitly makes
&gt; them
&gt; *not* binary compatible between minor versions.

&gt; I think it's helpful that ABI status corresponds to the names used in
&gt; the source and header files, both for maintenance and for user
&gt; documentation.

If you mean removing them from the public headers and placing them in
one (or multiple) internal ones,  it makes sense to me. Otherwise it
would be confusing on why they are listed in headers if they are
unavailable or break ABI.

&gt; What do you think? Are there any of the current _nettle_* symbols
&gt; that should be in the advertised API (and hence renamed)?

I do not use any of them in gnutls, but searching at the debian code, I
see: _nettle_md5_compress (sogo), _nettle_sha1_compress
(filezilla/putty)

regards,
Nikos


</body></email><email><emailId>20180608113429</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-06-08 11:34:29-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:

&gt; If you mean removing them from the public headers and placing them in
&gt; one (or multiple) internal ones,  it makes sense to me.

Sounds reasonable. Then it's harder to use them without realizing
they're internal and not compatible over version changes (even though we
ought to document the conventions).

&gt;&gt; What do you think? Are there any of the current _nettle_* symbols
&gt;&gt; that should be in the advertised API (and hence renamed)?
&gt;
&gt; I do not use any of them in gnutls, but searching at the debian code, I
&gt; see: _nettle_md5_compress (sogo), _nettle_sha1_compress
&gt; (filezilla/putty)

We could promote those to advertised ABI, then. I.e., linker symbols
nettle_*_compress after the ABI change, while we could keep
_nettle_*_compress as aliases in the header file, not not also break the
API.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180612115752</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-06-12 11:57:52-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

On Fri, 2018-06-08 at 13:34 +0200, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:
&gt; 
&gt; &gt; If you mean removing them from the public headers and placing them
&gt; &gt; in
&gt; &gt; one (or multiple) internal ones,  it makes sense to me.
&gt; 
&gt; Sounds reasonable. Then it's harder to use them without realizing
&gt; they're internal and not compatible over version changes (even though
&gt; we
&gt; ought to document the conventions).
&gt; 
&gt; &gt; &gt; What do you think? Are there any of the current _nettle_* symbols
&gt; &gt; &gt; that should be in the advertised API (and hence renamed)?
&gt; &gt; 
&gt; &gt; I do not use any of them in gnutls, but searching at the debian
&gt; &gt; code, I
&gt; &gt; see: _nettle_md5_compress (sogo), _nettle_sha1_compress
&gt; &gt; (filezilla/putty)
&gt; 
&gt; We could promote those to advertised ABI, then. I.e., linker symbols
&gt; nettle_*_compress after the ABI change, while we could keep
&gt; _nettle_*_compress as aliases in the header file, not not also break
&gt; the API.

I attach the current state. It does move all internal symbols into
multiple internal headers and removes them from exported list. The last
patch renames _nettle_md5_compress and _nettle_sha1_compress and
includes it into the exported list (quite ugly, maybe we skip that
rename?).

regards,
Nikos
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0001-abi-explicitly-export-intended-symbols-and-hide-othe.patch
Type: text/x-patch
Size: 84774 bytes
Desc: not available
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20180612/90e22df0/attachment.bin&gt;
                
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0002-.gitlab-ci.yml-link-with-shared-library-on-x86-64-bu.patch
Type: text/x-patch
Size: 850 bytes
Desc: not available
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20180612/90e22df0/attachment-0001.bin&gt;
                
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0003-nettle_md5-sha1_compress-are-now-part-of-API.patch
Type: text/x-patch
Size: 14855 bytes
Desc: not available
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20180612/90e22df0/attachment-0002.bin&gt;



</body></email><email><emailId>20180617175513</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-06-17 17:55:13-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:

&gt; I attach the current state. It does move all internal symbols into
&gt; multiple internal headers

Makes sense to me.

&gt; The last
&gt; patch renames _nettle_md5_compress and _nettle_sha1_compress and
&gt; includes it into the exported list

I think this makes sense too. We should leave 

  #define _nettle_md5_compress nettle_md5_compress
  #define _nettle_sha1_compress nettle_sha1_compress

in the header files, for API (source level) backwards compatibility.

If we do that too, can we use glob patterns in the linker scripts,
instead of listing all symbols explicitly? It might make sense to do
this in three steps:

1. Rename the above compress functions.

2. Move declarations if internal functions to uninstalled headers.

3. Update the linker script to handle _nettle_*-symbols differently.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180618115357</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-06-18 11:53:57-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

On Sun, 2018-06-17 at 19:55 +0200, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:
&gt; 
&gt; &gt; I attach the current state. It does move all internal symbols into
&gt; &gt; multiple internal headers
&gt; 
&gt; Makes sense to me.
&gt; 
&gt; &gt; The last
&gt; &gt; patch renames _nettle_md5_compress and _nettle_sha1_compress and
&gt; &gt; includes it into the exported list
&gt; 
&gt; I think this makes sense too. We should leave 
&gt; 
&gt;   #define _nettle_md5_compress nettle_md5_compress
&gt;   #define _nettle_sha1_compress nettle_sha1_compress
&gt; 
&gt; in the header files, for API (source level) backwards compatibility.

Definitions are already in place.

&gt; 
&gt; If we do that too, can we use glob patterns in the linker scripts,
&gt; instead of listing all symbols explicitly? It might make sense to do
&gt; this in three steps:

I'd suggest against doing that because there will be no way to achieve
symbol versioning. See the previous discussion at:
https://lists.lysator.liu.se/pipermail/nettle-bugs/2018/007287.html


&gt; 1. Rename the above compress functions.
&gt; 
&gt; 2. Move declarations if internal functions to uninstalled headers.

These are already done.

regards,
Nikos


</body></email><email><emailId>20180708063635</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-07-08 06:36:35-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:

&gt; The attached version only exports symbols by wildcards and combines
&gt; patches.

Thanks a lot. I've tried this out now (currently on master-updates
branch for testing). I've noticed two problems:

1. x86_64 --enable-fat builds are broken, errors like 

   /home/nisse/hack/nettle/fat-x86_64.c:178:34: error:
   ‘nettle_sha1_compress_sha_ni' undeclared (first use in this function)
          nettle_sha1_compress_vec = nettle_sha1_compress_sha_ni;

   We have to decide if the name of this assembly function should be
   "nettle_sha1_compress_sha_ni" (and if so, update the macro
   DECLARE_FAT_FUNC_VAR in fat-setup.h and all uses), or
   "_nettle_sha1_compress_sha_ni" (and update definitions of m4 macro
   fat_transform in x86_64/fat/sha1-compress*.asm). The latter
   alternative seems best to me.

2. The gnutls build fails with 

   Submodule path 'tests/suite/tls-fuzzer/tlslite-ng': checked out \
                'd976188fe7fd7466dc5cf0818a4ef87e37381897'
   ./bootstrap
   ./bootstrap: Bootstrapping from checked-out gnutls sources...
   ./bootstrap: consider installing git-merge-changelog from gnulib
   ./bootstrap: getting gnulib files...
   ./bootstrap: getting translations into po/.reference for gnutls...
   ./bootstrap: line 702: rsync: command not found
   wget: relocation error: /lib64/libgnutls.so.30: symbol
   nettle_secp_521r1, version HOGWEED_4 not defined in file libhogweed.so.4 with link \
time reference  make: *** [cfg.mk:63: autoreconf] Error 127
   
   My best guess that wget somehow got linked at runtime with the
   version of libhogweed under test (where the bump of soname and
   version numbers isn't done yet). If that's right, it should work if
   either the test scripts ensure that the system version of libhogweed
   is used here, or I check in a change to the soname to tell the linker
   that the development version under test is incompatible with the wget
   executable.

I think I'll first try to sort this out on the master-updates branch. If
it turns out to be more complicated, I'll back out of these changes, and
try to do the sha1_compress and md5_compress renaming first, to get less
problems at a time.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20180709065833</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-07-09 06:58:33-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

On Sun, Jul 8, 2018 at 8:36 AM Niels Möller &lt;nisse at lysator.liu.se&gt; wrote:

&gt; Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:
&gt;
&gt; &gt; The attached version only exports symbols by wildcards and combines
&gt; &gt; patches.
&gt;
&gt; Thanks a lot. I've tried this out now (currently on master-updates
&gt; branch for testing). I've noticed two problems:
&gt;
&gt; 1. x86_64 --enable-fat builds are broken, errors like
&gt;
&gt;    /home/nisse/hack/nettle/fat-x86_64.c:178:34: error:
&gt;    ‘nettle_sha1_compress_sha_ni' undeclared (first use in this function)
&gt;           nettle_sha1_compress_vec = nettle_sha1_compress_sha_ni;
&gt;
&gt;    We have to decide if the name of this assembly function should be
&gt;    "nettle_sha1_compress_sha_ni" (and if so, update the macro
&gt;    DECLARE_FAT_FUNC_VAR in fat-setup.h and all uses), or
&gt;    "_nettle_sha1_compress_sha_ni" (and update definitions of m4 macro
&gt;    fat_transform in x86_64/fat/sha1-compress*.asm). The latter
&gt;    alternative seems best to me.
&gt;

That would also mean the latter would be part of the ABI as we agreed on
exporting symbols by wildcard. Seeing it further it seems that fat
subsystem was not made for wildcard exporting of symbols, as it creates new
symbols which can be exported.



&gt; 2. The gnutls build fails with
&gt;
&gt;    Submodule path 'tests/suite/tls-fuzzer/tlslite-ng': checked out
&gt; 'd976188fe7fd7466dc5cf0818a4ef87e37381897'
&gt;    ./bootstrap
&gt;    ./bootstrap: Bootstrapping from checked-out gnutls sources...
&gt;    ./bootstrap: consider installing git-merge-changelog from gnulib
&gt;    ./bootstrap: getting gnulib files...
&gt;    ./bootstrap: getting translations into po/.reference for gnutls...
&gt;    ./bootstrap: line 702: rsync: command not found
&gt;    wget: relocation error: /lib64/libgnutls.so.30: symbol
&gt;    nettle_secp_521r1, version HOGWEED_4 not defined in file
&gt; libhogweed.so.4 with link time reference
&gt;    make: *** [cfg.mk:63: autoreconf] Error 127
&gt;
&gt;    My best guess that wget somehow got linked at runtime with the
&gt;    version of libhogweed under test (where the bump of soname and
&gt;    version numbers isn't done yet). If that's right, it should work if
&gt;    either the test scripts ensure that the system version of libhogweed
&gt;    is used here, or I check in a change to the soname to tell the linker
&gt;    that the development version under test is incompatible with the wget
&gt;    executable.
&gt;
&gt; I think I'll first try to sort this out on the master-updates branch. If
&gt; it turns out to be more complicated, I'll back out of these changes, and
&gt; try to do the sha1_compress and md5_compress renaming first, to get less
&gt; problems at a time.
&gt;

I've updated the image of building gnutls. The f26 is no longer updated and
cannot build the current master.

regards,
Nikos
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0002-.gitlab-ci.yml-updated-build-images-to-latest-used-b.patch
Type: text/x-patch
Size: 796 bytes
Desc: not available
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20180709/a88a124d/attachment.bin&gt;

</body></email><email><emailId>20180709094418</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-07-09 09:44:18-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:

&gt; On Sun, Jul 8, 2018 at 8:36 AM Niels Möller &lt;nisse at lysator.liu.se&gt; wrote:
&gt;
&gt;&gt;    We have to decide if the name of this assembly function should be
&gt;&gt;    "nettle_sha1_compress_sha_ni" (and if so, update the macro
&gt;&gt;    DECLARE_FAT_FUNC_VAR in fat-setup.h and all uses), or
&gt;&gt;    "_nettle_sha1_compress_sha_ni" (and update definitions of m4 macro
&gt;&gt;    fat_transform in x86_64/fat/sha1-compress*.asm). The latter
&gt;&gt;    alternative seems best to me.
&gt;&gt;
&gt;
&gt; That would also mean the latter would be part of the ABI as we agreed on
&gt; exporting symbols by wildcard. Seeing it further it seems that fat
&gt; subsystem was not made for wildcard exporting of symbols, as it creates new
&gt; symbols which can be exported.

I went for the latter alternative, which gives us
_nettle_sha1_compress_sha_ni and _nettle_sha1_compress_x86_64 (with
NETTLE_INTERNAL_* symbol version, by the wildcard rule)), and
nettle_sha_compress is a public symbols which jumps via a function
pointer (or uses ifunc indirection, if glibc is changed to resolve libc
ifunc relocations before other libraries).

I think that should be right; the set of public symols is the same in a
fat and non-fat build.

FYI, I also did a forced update of the master-updates branch, to fix a
commit message typo. 

&gt; diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
&gt; index abfb81a3..52f41c74 100644
&gt; --- a/.gitlab-ci.yml
&gt; +++ b/.gitlab-ci.yml
&gt; @@ -1,7 +1,7 @@
&gt;  variables:
&gt;    BUILD_IMAGES_PROJECT: gnutls/build-images
&gt; -  FEDORA_BUILD: buildenv-f26
&gt; -  FEDORA_X86_BUILD: buildenv-f26-x86
&gt; +  FEDORA_BUILD: buildenv-f28
&gt; +  FEDORA_X86_BUILD: buildenv-f28-x86
&gt;    GET_SOURCES_ATTEMPTS: "3"
&gt;  
&gt;  # remove any pre-installed headers from nettle

Applied. Should hopefully make the gnutls build pass, leaving only the
aarch64 ci failures.

Is it easy to add a (32-bit) arm build in .gitlab-ci? Any of real
hardware, qemu virtual machine, or cross compile + qemu-user testing,
would be good to have. Otherwise, I'll have to do some local testing to
ensure that arm fat and non-fat builds still work.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180710185417</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-07-10 18:54:17-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

On Mon, Jul 9, 2018 at 11:44 AM, Niels Möller &lt;nisse at lysator.liu.se&gt; wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:
&gt;
&gt;&gt; On Sun, Jul 8, 2018 at 8:36 AM Niels Möller &lt;nisse at lysator.liu.se&gt; wrote:
&gt;&gt;
&gt;&gt;&gt;    We have to decide if the name of this assembly function should be
&gt;&gt;&gt;    "nettle_sha1_compress_sha_ni" (and if so, update the macro
&gt;&gt;&gt;    DECLARE_FAT_FUNC_VAR in fat-setup.h and all uses), or
&gt;&gt;&gt;    "_nettle_sha1_compress_sha_ni" (and update definitions of m4 macro
&gt;&gt;&gt;    fat_transform in x86_64/fat/sha1-compress*.asm). The latter
&gt;&gt;&gt;    alternative seems best to me.
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt; That would also mean the latter would be part of the ABI as we agreed on
&gt;&gt; exporting symbols by wildcard. Seeing it further it seems that fat
&gt;&gt; subsystem was not made for wildcard exporting of symbols, as it creates new
&gt;&gt; symbols which can be exported.
&gt;
&gt; I went for the latter alternative, which gives us
&gt; _nettle_sha1_compress_sha_ni and _nettle_sha1_compress_x86_64 (with
&gt; NETTLE_INTERNAL_* symbol version, by the wildcard rule)), and
&gt; nettle_sha_compress is a public symbols which jumps via a function
&gt; pointer (or uses ifunc indirection, if glibc is changed to resolve libc
&gt; ifunc relocations before other libraries).
&gt;
&gt; I think that should be right; the set of public symols is the same in a
&gt; fat and non-fat build.
&gt;
&gt; FYI, I also did a forced update of the master-updates branch, to fix a
&gt; commit message typo.

That shouldn't be a problem.

&gt;
&gt;&gt; diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
&gt;&gt; index abfb81a3..52f41c74 100644
&gt;&gt; --- a/.gitlab-ci.yml
&gt;&gt; +++ b/.gitlab-ci.yml
&gt;&gt; @@ -1,7 +1,7 @@
&gt;&gt;  variables:
&gt;&gt;    BUILD_IMAGES_PROJECT: gnutls/build-images
&gt;&gt; -  FEDORA_BUILD: buildenv-f26
&gt;&gt; -  FEDORA_X86_BUILD: buildenv-f26-x86
&gt;&gt; +  FEDORA_BUILD: buildenv-f28
&gt;&gt; +  FEDORA_X86_BUILD: buildenv-f28-x86
&gt;&gt;    GET_SOURCES_ATTEMPTS: "3"
&gt;&gt;
&gt;&gt;  # remove any pre-installed headers from nettle
&gt;
&gt; Applied. Should hopefully make the gnutls build pass, leaving only the
&gt; aarch64 ci failures.
&gt;
&gt; Is it easy to add a (32-bit) arm build in .gitlab-ci? Any of real
&gt; hardware, qemu virtual machine, or cross compile + qemu-user testing,
&gt; would be good to have. Otherwise, I'll have to do some local testing to
&gt; ensure that arm fat and non-fat builds still work.

Yes and most likely we can re-use the images Michael added in gnutls.
I'll check to it.

regards,
Nikos

</body></email><email><emailId>20180710193516</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-07-10 19:35:16-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

On Mon, Jul 9, 2018 at 11:44 AM, Niels Möller &lt;nisse at lysator.liu.se&gt; wrote:
&gt; &gt; @@ -1,7 +1,7 @@
&gt; &gt; variables:
&gt; &gt; BUILD_IMAGES_PROJECT: gnutls/build-images
&gt; &gt; -  FEDORA_BUILD: buildenv-f26
&gt; &gt; -  FEDORA_X86_BUILD: buildenv-f26-x86
&gt; &gt; +  FEDORA_BUILD: buildenv-f28
&gt; &gt; +  FEDORA_X86_BUILD: buildenv-f28-x86
&gt; &gt; GET_SOURCES_ATTEMPTS: "3"
&gt; &gt; 
&gt; &gt; # remove any pre-installed headers from nettle
&gt; 
&gt; Applied. Should hopefully make the gnutls build pass, leaving only the
&gt; aarch64 ci failures.
&gt; 
&gt; Is it easy to add a (32-bit) arm build in .gitlab-ci? Any of real
&gt; hardware, qemu virtual machine, or cross compile + qemu-user testing,
&gt; would be good to have. Otherwise, I'll have to do some local testing to
&gt; ensure that arm fat and non-fat builds still work.

Patch is attached adding the builds from gnutls (mips,arm,aarch64).

The output is at:
https://gitlab.com/nmav/nettle/pipelines/25504684

The fat-arm build fails with:

fat-arm.c: In function 'fat_init':
fat-arm.c:194:7: error: '_nettle_sha1_compress_vec' undeclared (first
use in this function); did you mean 'nettle_sha1_compress_vec'?
       _nettle_sha1_compress_vec = _nettle_sha1_compress_armv6;
       ^~~~~~~~~~~~~~~~~~~~~~~~~
       nettle_sha1_compress_vec
fat-arm.c:194:7: note: each undeclared identifier is reported only
once for each function it appears in
Makefile:258: recipe for target 'fat-arm.o' failed
make[1]: *** [fat-arm.o] Error 1




btw. Note that fat-arm.c capabilities detection can be simplified with
getauxval:

https://community.arm.com/android-community/b/android/posts/runtime-detection-of-cpu-features-on-an-armv8-a-cpu


I've modified gnutls to use that too:
https://gitlab.com/gnutls/gnutls/blob/master/lib/accelerated/aarch64/aarch64-common.c#L69


regards,
Nikos
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0001-.gitlab-ci.yml-added-cross-compilation-and-tests-on-.patch
Type: text/x-patch
Size: 2439 bytes
Desc: not available
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20180710/37d7f076/attachment.bin&gt;



</body></email><email><emailId>20180712083143</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-07-12 08:31:43-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos at gmail.com&gt; writes:

&gt; The fat-arm build fails with:
&gt; 
&gt; fat-arm.c: In function 'fat_init':
&gt; fat-arm.c:194:7: error: '_nettle_sha1_compress_vec' undeclared (first
&gt; use in this function); did you mean 'nettle_sha1_compress_vec'?
&gt; _nettle_sha1_compress_vec = _nettle_sha1_compress_armv6;
&gt; ^~~~~~~~~~~~~~~~~~~~~~~~~
&gt; nettle_sha1_compress_vec
&gt; fat-arm.c:194:7: note: each undeclared identifier is reported only
&gt; once for each function it appears in
&gt; Makefile:258: recipe for target 'fat-arm.o' failed
&gt; make[1]: *** [fat-arm.o] Error 1

I've noticed the same in a local cross-compilation environment. I'm
about to check in the fixes.

&gt; btw. Note that fat-arm.c capabilities detection can be simplified with
&gt; getauxval:
&gt; 
&gt; https://community.arm.com/android-community/b/android/posts/runtime-detection-of-cpu-features-on-an-armv8-a-cpu
&gt; 

Ok, maybe we should revisit that. When I wrote the current code, which
is a few years ago now, I think I considered using getauxval, but
concluded that it was less portable than reading /proc/cpuinfo. (And
nettle currently only has arm-specific code for 32-bit arm; portability
considerations for 64-bit arm may be different since there's less old
stuff to care about).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20180712083712</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-07-12 08:37:12-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos at gmail.com&gt; writes:

&gt; Patch is attached adding the builds from gnutls (mips,arm,aarch64).

Excellent! Now applied to the master-updates branch, together with arm
fat fixes.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180712094105</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-07-12 09:41:05-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

On Thu, 2018-07-12 at 10:31 +0200, Niels Möller wrote:
&gt; 
&gt; &gt; btw. Note that fat-arm.c capabilities detection can be simplified
&gt; &gt; with
&gt; &gt; getauxval:
&gt; &gt; 
&gt; &gt; https://community.arm.com/android-community/b/android/posts/runtime
&gt; &gt; -detection-of-cpu-features-on-an-armv8-a-cpu
&gt; 
&gt; Ok, maybe we should revisit that. When I wrote the current code,
&gt; which
&gt; is a few years ago now, I think I considered using getauxval, but
&gt; concluded that it was less portable than reading /proc/cpuinfo. (And
&gt; nettle currently only has arm-specific code for 32-bit arm;
&gt; portability
&gt; considerations for 64-bit arm may be different since there's less old
&gt; stuff to care about).

The main problem with the /proc/cpuinfo was that in the qemu-user
environment this is not emulated, and thus you'll be reading the CI
server's cpu information. We could work-around that by setting multiple
environment overrides during make check to ensure all code paths are
run.

regards,
Nikos


</body></email><email><emailId>20180712094300</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-07-12 09:43:00-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

On Thu, 2018-07-12 at 10:37 +0200, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos at gmail.com&gt; writes:
&gt; 
&gt; &gt; Patch is attached adding the builds from gnutls (mips,arm,aarch64).
&gt; 
&gt; Excellent! Now applied to the master-updates branch, together with
&gt; arm
&gt; fat fixes.

Did you push it? I don't seem to see a pipeline with the f28 build
systems:
https://gitlab.com/gnutls/nettle/pipelines



</body></email><email><emailId>20180712132822</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-07-12 13:28:22-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:

&gt; Did you push it? I don't seem to see a pipeline with the f28 build
&gt; systems:
&gt; https://gitlab.com/gnutls/nettle/pipelines

History info on https://gitlab.com/gnutls/nettle/commits/master-updates
says "This project is mirrored from
https://git.lysator.liu.se/nettle/nettle.git. Updated 19 minutes ago.
This branch has diverged from upstream."
            ^^^^^^^^^^^^

So I'd guess my force update on that branch has confused the mirroring.
Maybe you need to somehow force push the right version to the mirror
version of that branch to get it back in sync.

Sorry about that.

Regards,
/Niels



-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180712154022</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-07-12 15:40:22-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

On Thu, 2018-07-12 at 15:28 +0200, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:
&gt; 
&gt; &gt; Did you push it? I don't seem to see a pipeline with the f28 build
&gt; &gt; systems:
&gt; &gt; https://gitlab.com/gnutls/nettle/pipelines
&gt; 
&gt; History info on https://gitlab.com/gnutls/nettle/commits/master-updat
&gt; es
&gt; says "This project is mirrored from
&gt; https://git.lysator.liu.se/nettle/nettle.git. Updated 19 minutes ago.
&gt; This branch has diverged from upstream."
&gt;             ^^^^^^^^^^^^

I've deleted the branches on gitlab and now it seems to work. It seems
that static analyzer in F28 finds few issues:
https://gitlab.com/gnutls/nettle/-/jobs/81332560 (click on browse for
artifacts)

They are mem leaks on examples and one which relates to gmp-mini.

regards,
Nikos


</body></email><email><emailId>20180712160447</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-07-12 16:04:47-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:

&gt; I've deleted the branches on gitlab and now it seems to work. It seems
&gt; that static analyzer in F28 finds few issues:
&gt; https://gitlab.com/gnutls/nettle/-/jobs/81332560 (click on browse for
&gt; artifacts)

We'll see how to deal with those failures, but I don't think they
should block merging to the master branch. 

There are also two "runner system failures", see
https://gitlab.com/gnutls/nettle/-/jobs/81332562. Can that be restarted?
It would be nice to see a successful arm build before merging to master.

&gt; They are mem leaks on examples and one which relates to gmp-mini.

I'll try to take care of the examples. The mini-gmp issue is more
confusing.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180617173212</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-06-17 17:32:12-0400</timestampReceived><subject>[PATCH] Fix quoting in autoconf ifunc test</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt; writes:

&gt; * aclocal.m4 (NETTLE_CHECK_IFUNC): fix quoting so that
&gt;   AC_LINK_IFELSE/AC_TRY_LINK is defined outside of this test.

Thanks, applied. What concrete errors did the incorrect quoting cause?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20181229191739</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2018-12-29 19:17:39-0400</timestampReceived><subject>sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize</subject><body>

Hi Everyone,

I'm trying to build Nettle 3.4.1 on Fedora 29, x64 (fully patched).
Self tests are failing at:

    PASS: rsa-sec-decrypt
    sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize
    ../run-tests: line 57: 22997 Aborted (core dumped) "$1" $testflags
    FAIL: rsa-compute-root
    PASS: dsa
    PASS: dsa-keygen

GMP is 6.1.2, which is the latest version.

Could someone please advise.

Thanks.

</body></email><email><emailId>20181230020715</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2018-12-30 02:07:15-0400</timestampReceived><subject>sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize</subject><body>

On Sat, Dec 29, 2018 at 2:17 PM Jeffrey Walton &lt;noloader at gmail.com&gt; wrote:
&gt;
&gt; I'm trying to build Nettle 3.4.1 on Fedora 29, x64 (fully patched).
&gt; Self tests are failing at:
&gt;
&gt;     PASS: rsa-sec-decrypt
&gt;     sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize
&gt;     ../run-tests: line 57: 22997 Aborted (core dumped) "$1" $testflags
&gt;     FAIL: rsa-compute-root
&gt;     PASS: dsa
&gt;     PASS: dsa-keygen
&gt;
&gt; GMP is 6.1.2, which is the latest version.

This is failing on Aarch64, too.

Jeff

</body></email><email><emailId>20181230222738</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-12-30 22:27:38-0400</timestampReceived><subject>sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize</subject><body>

Jeffrey Walton &lt;noloader at gmail.com&gt; writes:

&gt; I'm trying to build Nettle 3.4.1 on Fedora 29, x64 (fully patched).
&gt; Self tests are failing at:
&gt;
&gt;     PASS: rsa-sec-decrypt
&gt;     sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize
&gt;     ../run-tests: line 57: 22997 Aborted (core dumped) "$1" $testflags
&gt;     FAIL: rsa-compute-root
&gt;     PASS: dsa
&gt;     PASS: dsa-keygen

This is an ASSERT_ALWAYS in gmp's mpn/generic/sec_powm.c, checking the
return value from the win_size function. To debug, it would be helpful
to know

1. The value of enb and windowsize at the crash.

2. The definition of POWM_SEC_TABLE (defined in the platform specific
   gmp-mparam.h), and used by the win_size function in this file.

To me, it looks like the assert validates that POWM_SEC_TABLE confoems
to expectations.

It might also be a bug in the book-keeping of scratch space, leading to
some memory overwrite. Try running the test program under valgrind
and/or asan?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20181230230633</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2018-12-30 23:06:33-0400</timestampReceived><subject>sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize</subject><body>

On Sun, Dec 30, 2018 at 5:27 PM Niels Möller &lt;nisse at lysator.liu.se&gt; wrote:
&gt;
&gt; Jeffrey Walton &lt;noloader at gmail.com&gt; writes:
&gt;
&gt; &gt; I'm trying to build Nettle 3.4.1 on Fedora 29, x64 (fully patched).
&gt; &gt; Self tests are failing at:
&gt; &gt;
&gt; &gt;     PASS: rsa-sec-decrypt
&gt; &gt;     sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize
&gt; &gt;     ../run-tests: line 57: 22997 Aborted (core dumped) "$1" $testflags
&gt; &gt;     FAIL: rsa-compute-root
&gt; &gt;     PASS: dsa
&gt; &gt;     PASS: dsa-keygen
&gt;
&gt; This is an ASSERT_ALWAYS in gmp's mpn/generic/sec_powm.c, checking the
&gt; return value from the win_size function. To debug, it would be helpful
&gt; to know

Here are the options I used to build GMP 6.1.2 and Nettle 3.1.4. It
looks fairly easy to duplicate on 64-bit platforms.

   BUILD_BITS: 64-bits
 INSTX_PREFIX: /usr/local
 INSTX_LIBDIR: /usr/local/lib64

  PKGCONFPATH: /usr/local/lib64/pkgconfig
     CPPFLAGS: -I/usr/local/include -DNDEBUG
       CFLAGS: -g2 -O2 -march=native -fPIC
     CXXFLAGS: -g2 -O2 -march=native -fPIC
      LDFLAGS: -L/usr/local/lib64 -Wl,-R,/usr/local/lib64 -Wl,--enable-new-dtags
       LDLIBS: -ldl -lpthread

Then, I run configure. There's nothing special about what I am doing.
I'm just getting into a Release Build state.

&gt; 1. The value of enb and windowsize at the crash.
&gt;
&gt; 2. The definition of POWM_SEC_TABLE (defined in the platform specific
&gt;    gmp-mparam.h), and used by the win_size function in this file.
&gt;
&gt; To me, it looks like the assert validates that POWM_SEC_TABLE conforms
&gt; to expectations.
&gt;
&gt; It might also be a bug in the book-keeping of scratch space, leading to
&gt; some memory overwrite. Try running the test program under valgrind
&gt; and/or asan?

Thanks Niels.

I'll try to get to it later tonight or tomorrow.

In the meantime you might provide your test data to GMP. It looks like
it would make a good test case for them.

Jeff

</body></email><email><emailId>20181231000141</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2018-12-31 00:01:41-0400</timestampReceived><subject>sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize</subject><body>

On Sun, Dec 30, 2018 at 5:27 PM Niels Möller &lt;nisse at lysator.liu.se&gt; wrote:
&gt;
&gt; It might also be a bug in the book-keeping of scratch space, leading to
&gt; some memory overwrite. Try running the test program under valgrind
&gt; and/or asan?

Hey Niels,

What is the test name and how do I run it?

Given I've built the library and the test suite, what are the next
steps? (I'm guessing cd somewhere and and valgrind &lt;some program&gt;).

Jeff

</body></email><email><emailId>20181231000458</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2018-12-31 00:04:58-0400</timestampReceived><subject>sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize</subject><body>

On Sat, Dec 29, 2018 at 9:07 PM Jeffrey Walton &lt;noloader at gmail.com&gt; wrote:
&gt;
&gt; On Sat, Dec 29, 2018 at 2:17 PM Jeffrey Walton &lt;noloader at gmail.com&gt; wrote:
&gt; &gt;
&gt; &gt; I'm trying to build Nettle 3.4.1 on Fedora 29, x64 (fully patched).
&gt; &gt; Self tests are failing at:
&gt; &gt;
&gt; &gt;     PASS: rsa-sec-decrypt
&gt; &gt;     sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize
&gt; &gt;     ../run-tests: line 57: 22997 Aborted (core dumped) "$1" $testflags
&gt; &gt;     FAIL: rsa-compute-root
&gt; &gt;     PASS: dsa
&gt; &gt;     PASS: dsa-keygen
&gt; &gt;
&gt; &gt; GMP is 6.1.2, which is the latest version.
&gt;
&gt; This is failing on Aarch64, too.

And I just duplicated with 32-bit code on Solaris. I have not been
able to test ARM A-32. GMP build is broken.

Jeff

</body></email><email><emailId>20181231081747</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-12-31 08:17:47-0400</timestampReceived><subject>sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize</subject><body>

Jeffrey Walton &lt;noloader at gmail.com&gt; writes:

&gt; Here are the options I used to build GMP 6.1.2 and Nettle 3.1.4. It
&gt; looks fairly easy to duplicate on 64-bit platforms.
&gt;
&gt;    BUILD_BITS: 64-bits
&gt;  INSTX_PREFIX: /usr/local
&gt;  INSTX_LIBDIR: /usr/local/lib64
&gt;
&gt;   PKGCONFPATH: /usr/local/lib64/pkgconfig
&gt;      CPPFLAGS: -I/usr/local/include -DNDEBUG
&gt;        CFLAGS: -g2 -O2 -march=native -fPIC
&gt;      CXXFLAGS: -g2 -O2 -march=native -fPIC
&gt;       LDFLAGS: -L/usr/local/lib64 -Wl,-R,/usr/local/lib64 -Wl,--enable-new-dtags
&gt;        LDLIBS: -ldl -lpthread
&gt;
&gt; Then, I run configure. There's nothing special about what I am doing.
&gt; I'm just getting into a Release Build state.

What platform did configure detect? And in particular, which file is the
gmp-mparam.h symlink at the top of the gmp build tree pointed to, and
what's the definition of POWM_SEC_TABLE there?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20181204221400</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-12-04 22:14:00-0400</timestampReceived><subject>ANNOUNCE: Nettle-3.4.1</subject><body>

I'm happy to announce a new release of GNU Nettle, a low-level
cryptographics library. The main change in this release is that RSA
private key operations are now side-channel silent, thanks to
contributions by Simo Sorce, at Red Hat Inc. The release also includes a
few smaller bugfixes.

The Nettle home page can be found at
https://www.lysator.liu.se/~nisse/nettle/, and the manual at
https://www.lysator.liu.se/~nisse/nettle/nettle.html.

The release can be downloaded from

  https://ftp.gnu.org/gnu/nettle/nettle-3.4.1.tar.gz
  ftp://ftp.gnu.org/gnu/nettle/nettle-3.4.tar.gz
  https://www.lysator.liu.se/~nisse/archive/nettle-3.4.1.tar.gz

There are no code changes since the release candidate announced on the
Nettle mailing list November 30.

Release timing is prompted by the publication of http://cat.eyalro.net/.
Nettle and GnuTLS authors (as well as developers of other TLS
implementations) were notified by the research team a few months ago.
Related CVE ids:

  CVE-2018-16868 gnutls: Bleichenbacher-like side channel leakage in
  PKCS#1 1.5 verification and padding oracle verification

  CVE-2018-16869 nettle: Leaky data conversion exposing a manager oracle

For Nettle, the RSA code, which was written some 15 years ago, have seen
an overhawl. Not only making the handling of PKCS#1 on decryption
side-channel silent (the vulnerabilities that could be exploited by the
methods of the above paper), but also ensuring that underlying bignum
arithmetic uses side-channel silent functions.

The attack directly affects RSA decryption, not signatures. And it
requires some resources to be pulled off. As far as I understand it, a
successful attack lets the attacker decrypt or sign a targeted message,
e.g., compromising the TLS "premaster secret" of a particular session,
corresponding session keys, and any transmitted passwords or login
cookies supposedly protected by those session keys, but it does not
expose the private key itself.

Upgrading the Nettle and GnuTLS libraries is recommended. If you operate
a TLS server, you should consider if you can completely disable key
exchange based on RSA decryption. If you need to keep it for backwards
compatibility, it is *strongly* encouraged to use a separate RSA key for
this purpose, *not* reused or authorized for any other purpose.

Regards,
/Niels

NEWS for the Nettle 3.4.1 release

	This release fixes a few bugs, and makes the RSA private key
	operations side channel silent. The RSA improvements are
	contributed by Simo Sorce and Red Hat, and include one new
	public function, rsa_sec_decrypt, see below.

	All functions using RSA private keys are now side-channel
	silent, meaning that they try hard to avoid any branches or
	memory accesses depending on secret data. This applies both to
	the bignum calculations, which now use GMP's mpn_sec_* family
	of functions, and the processing of PKCS#1 padding needed for
	RSA decryption.

	Nettle's ECC functions were already side-channel silent, while
	the DSA functions still aren't. There's also one caveat
	regarding the improved RSA functions: due to small table
	lookups in relevant mpn_sec_* functions in GMP-6.1.2, the
	lowest and highest few bits of the secret factors p and q may
	still leak. I'm not aware of any attacks on RSA where knowing
	a few bits of the factors makes a significant difference. This
	leak will likely be plugged in later GMP versions.

	Changes in behavior:

	* The functions rsa_decrypt and rsa_decrypt_tr may now clobber
	  all of the provided message buffer, independent of the
	  actual message length. They are side-channel silent, in that
	  branches and memory accesses don't depend on the validity or
	  length of the message. Side-channel leakage from the
	  caller's use of length and return value may still provide an
	  oracle useable for a Bleichenbacher-style chosen ciphertext
	  attack. Which is why the new function rsa_sec_decrypt is
	  recommended.

	New features:

	* A new function rsa_sec_decrypt. It differs from
	  rsa_decrypt_tr in that the length of the decrypted message
	  is given a priori, and PKCS#1 padding indicating a different
	  length is treated as an error. For applications that may be
	  subject to chosen ciphertext attacks, it is recommended to
	  initialize the message area with random data, call this
	  function, and ignore the return value. This applies in
	  particular to RSA-based key exchange in the TLS protocol.

	Bug fixes:

	* Fix bug in pkcs1-conv, missing break statements in the
	  parsing of PEM input files.

	* Fix link error on the pss-mgf1-test test, affecting builds
	  without public key support.

	Performance regression:

	* All RSA private key operations employing RSA blinding, i.e.,
	  rsa_decrypt_tr, rsa_*_sign_tr, the new rsa_sec_decrypt, and
	  rsa_compute_root_tr, are significantly slower. This is
	  because (i) RSA blinding now use side-channel silent
	  operations, (ii) blinding includes a modular inversion, and
	  (iii) side-channel silent modular inversion, implemented as
	  mpn_sec_invert, is very expensive. A 60% slowdown for
	  2048-bit RSA keys have been measured.

	Miscellaneous:

	* Building the public key support of nettle now requires GMP
	  version 6.0 or later (unless --enable-mini-gmp is used).

	The shared library names are libnettle.so.6.5 and
	libhogweed.so.4.5, with sonames still libnettle.so.6 and
	libhogweed.so.4. It is intended to be fully binary compatible
	with nettle-3.1.

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 487 bytes
Desc: not available
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20181204/b5be189e/attachment.sig&gt;

</body></email><email><emailId>20181229163252</emailId><senderName>=?UTF-8?Q?Tim_R=c3=bchsen?=</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2018-12-29 16:32:52-0400</timestampReceived><subject>Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

On 29.12.18 12:36, Nikos Mavrogiannopoulos wrote:
&gt; For x86 builds the new image uses debian because it has a simpler and has a \
&gt; reproducible way to generate it. The x86 fedora image will remain though. 
&gt; With the current nettle master oss fuzz still fails to compile (does link \
&gt; statically) due to cnd_memcpy not found: 
&gt; https://oss-fuzz-build-logs.storage.googleapis.com/log-8fca2d38-422a-47bf-84b5-e6fe3b6a9c73.txt
&gt; 

I had the same problem with wget and wget2. Fixed it by changing
-lnettle -lhogweed` to `-lhogweed -lnettle`. The current clang linker on
oss-fuzz changed the way it works, at least for static linking.

Regards, Tim

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20181229/17edf787/attachment.sig&gt;



</body></email><email><emailId>20181230012118</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2018-12-30 01:21:18-0400</timestampReceived><subject>=?UTF-8?Q?error=3A_=E2=80=98for=E2=80=99_loop_initial_declarations_are_only_?= =?UTF-8?Q?allowed_in_</subject><body>

Building on my HiKey, which is Aarch64.

==========

$ gcc --version
gcc (Debian/Linaro 4.9.2-10+deb8u1) 4.9.2
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

==========

gcc -I. -I/usr/local/include -DNDEBUG -DHAVE_CONFIG_H -g2 -O2 -fPIC
-ggdb3 -Wno-pointer-sign -Wall -W   -Wmissing-prototypes
-Wmissing-declarations -Wstrict-prototypes   -Wpointer-arith
-Wbad-function-cast -Wnested-externs -fpic -MT rsa-sign-tr.o -MD -MP
-MF rsa-sign-tr.o.d -c rsa-sign-tr.c \
&amp;&amp; true
gcc -I. -I/usr/local/include -DNDEBUG -DHAVE_CONFIG_H -g2 -O2 -fPIC
-ggdb3 -Wno-pointer-sign -Wall -W   -Wmissing-prototypes
-Wmissing-declarations -Wstrict-prototypes   -Wpointer-arith
-Wbad-function-cast -Wnested-externs -fpic -MT rsa-verify.o -MD -MP
-MF rsa-verify.o.d -c rsa-verify.c \
&amp;&amp; true
rsa-sign-tr.c: In function ‘sec_equal':
rsa-sign-tr.c:243:3: error: ‘for' loop initial declarations are only
allowed in C99 or C11 mode
   for (size_t i = 0; i &lt; limbs; i++)
   ^
rsa-sign-tr.c:243:3: note: use option -std=c99, -std=gnu99, -std=c11
or -std=gnu11 to compile your code
Makefile:260: recipe for target 'rsa-sign-tr.o' failed
make[1]: *** [rsa-sign-tr.o] Error 1
make[1]: *** Waiting for unfinished jobs....
make[1]: Leaving directory '/home/build/nettle-3.4.1'
Makefile:49: recipe for target 'all' failed
make: *** [all] Error 2

</body></email><email><emailId>20181230221525</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-12-30 22:15:25-0400</timestampReceived><subject>error: =?utf-8?B?4oCYZm9y4oCZ?= loop initial declarations are only allowed in C99 or C11 mode</subject><body>

Jeffrey Walton &lt;noloader at gmail.com&gt; writes:

&gt; rsa-sign-tr.c: In function ‘sec_equal':
&gt; rsa-sign-tr.c:243:3: error: ‘for' loop initial declarations are only
&gt; allowed in C99 or C11 mode
&gt;    for (size_t i = 0; i &lt; limbs; i++)
&gt;    ^
&gt; rsa-sign-tr.c:243:3: note: use option -std=c99, -std=gnu99, -std=c11
&gt; or -std=gnu11 to compile your code

This has been fixed in
https://git.lysator.liu.se/nettle/nettle/commit/f5a3a224bf00bef5669366d2ae23c2b2b13b8016

Not sure if there will be a bug-fix release 3.4.2, before we get till
3.5.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20181231083729</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-12-31 08:37:29-0400</timestampReceived><subject>sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize</subject><body>

Jeffrey Walton &lt;noloader at gmail.com&gt; writes:

&gt; What is the test name and how do I run it?

At the top of the nettle build tree, to run just that test:

  LD_LIBRARY_PATH=.lib ./testsuite/rsa-sec-decrypt-test

To run it (or some other set of tests under valgrind), one can also use

  make -C testsuite/ check EMULATOR='$(VALGRIND)' TS_ALL=rsa-sec-decrypt-test

&gt; Given I've built the library and the test suite, what are the next
&gt; steps?

If you don't find any bug with the aid of valgrind, next step would be
to run the test program under gdb (it looks like you already built gmp
with debug info enabled), set a break point on __gmpn_sec_powm
(name-mangled symbol name for mpn_pown_sec), and try to find out where
the bad value for windowsize comes from.

BTW, you did run gmp's make check, I hope?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20181101102813</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-11-01 10:28:13-0400</timestampReceived><subject>[PATCH 1/3] Move MAC testing code to generic place from cmac-test</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 testsuite/cmac-test.c | 100 +++++++++++-------------------------------
 testsuite/testutils.c |  64 +++++++++++++++++++++++++++
 testsuite/testutils.h |   6 +++
 3 files changed, 96 insertions(+), 74 deletions(-)

diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
index 31662d1b6c1b..b1d4aa30dfbe 100644
--- a/testsuite/cmac-test.c
+++ b/testsuite/cmac-test.c
@@ -2,83 +2,35 @@
 #include "nettle-internal.h"
 #include "cmac.h"
 
+const struct nettle_mac nettle_cmac_aes128 =
+{
+  "CMAC-AES128",
+  sizeof(struct cmac_aes128_ctx),
+  CMAC128_DIGEST_SIZE,
+  AES128_KEY_SIZE,
+
+  (nettle_set_key_func*) cmac_aes128_set_key,
+  (nettle_hash_update_func*) cmac_aes128_update,
+  (nettle_hash_digest_func*) cmac_aes128_digest
+};
+
+const struct nettle_mac nettle_cmac_aes256 =
+{
+  "CMAC-AES256",
+  sizeof(struct cmac_aes256_ctx),
+  CMAC128_DIGEST_SIZE,
+  AES256_KEY_SIZE,
+
+  (nettle_set_key_func*) cmac_aes256_set_key,
+  (nettle_hash_update_func*) cmac_aes256_update,
+  (nettle_hash_digest_func*) cmac_aes256_digest
+};
+
 #define test_cmac_aes128(key, msg, ref)					\
-  test_cmac_hash ((nettle_set_key_func*) cmac_aes128_set_key,		\
-		  (nettle_hash_update_func*) cmac_aes128_update,	\
-		  (nettle_hash_digest_func*) cmac_aes128_digest,	\
-		  sizeof(struct cmac_aes128_ctx),			\
-		  key, msg, ref)
+  test_mac(&amp;nettle_cmac_aes128, key, msg, ref)
 
 #define test_cmac_aes256(key, msg, ref)					\
-  test_cmac_hash ((nettle_set_key_func*) cmac_aes256_set_key,		\
-		  (nettle_hash_update_func*) cmac_aes256_update,	\
-		  (nettle_hash_digest_func*) cmac_aes256_digest,	\
-		  sizeof(struct cmac_aes256_ctx),			\
-		  key, msg, ref)
-
-static void
-test_cmac_hash (nettle_set_key_func *set_key,
-		nettle_hash_update_func *update,
-		nettle_hash_digest_func *digest, size_t ctx_size,
-		const struct tstring *key, const struct tstring *msg,
-		const struct tstring *ref)
-{
-  void *ctx;
-  uint8_t hash[16];
-  unsigned i;
-
-  ctx = xalloc(ctx_size);
-
-  ASSERT (ref-&gt;length == sizeof(hash));
-  ASSERT (key-&gt;length == 16 || key-&gt;length == 32);
-  set_key (ctx, key-&gt;data);
-  update (ctx, msg-&gt;length, msg-&gt;data);
-  digest (ctx, sizeof(hash), hash);
-  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
-    {
-      fprintf (stderr, "cmac_hash failed, msg: ");
-      print_hex (msg-&gt;length, msg-&gt;data);
-      fprintf(stderr, "Output:");
-      print_hex (16, hash);
-      fprintf(stderr, "Expected:");
-      tstring_print_hex(ref);
-      fprintf(stderr, "\n");
-      FAIL();
-    }
-
-  /* attempt to re-use the structure */
-  update (ctx, msg-&gt;length, msg-&gt;data);
-  digest (ctx, sizeof(hash), hash);
-  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
-    {
-      fprintf (stderr, "cmac_hash failed on re-use, msg: ");
-      print_hex (msg-&gt;length, msg-&gt;data);
-      fprintf(stderr, "Output:");
-      print_hex (16, hash);
-      fprintf(stderr, "Expected:");
-      tstring_print_hex(ref);
-      fprintf(stderr, "\n");
-      FAIL();
-    }
-
-  /* attempt byte-by-byte hashing */
-  set_key (ctx, key-&gt;data);
-  for (i=0;i&lt;msg-&gt;length;i++)
-    update (ctx, 1, msg-&gt;data+i);
-  digest (ctx, sizeof(hash), hash);
-  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
-    {
-      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
-      print_hex (msg-&gt;length, msg-&gt;data);
-      fprintf(stderr, "Output:");
-      print_hex (16, hash);
-      fprintf(stderr, "Expected:");
-      tstring_print_hex(ref);
-      fprintf(stderr, "\n");
-      FAIL();
-    }
-  free (ctx);
-}
+  test_mac(&amp;nettle_cmac_aes256, key, msg, ref)
 
 void
 test_main(void)
diff --git a/testsuite/testutils.c b/testsuite/testutils.c
index 1812ff4f52b0..ba0b41131925 100644
--- a/testsuite/testutils.c
+++ b/testsuite/testutils.c
@@ -924,6 +924,70 @@ test_hash_large(const struct nettle_hash *hash,
   free(data);
 }
 
+void
+test_mac(const struct nettle_mac *mac,
+	 const struct tstring *key,
+	 const struct tstring *msg,
+	 const struct tstring *digest)
+{
+  void *ctx = xalloc(mac-&gt;context_size);
+  uint8_t *hash = xalloc(mac-&gt;digest_size);
+  unsigned i;
+
+
+  ASSERT (digest-&gt;length == mac-&gt;digest_size);
+  ASSERT (key-&gt;length == mac-&gt;key_size);
+  mac-&gt;set_key (ctx, key-&gt;data);
+  mac-&gt;update (ctx, msg-&gt;length, msg-&gt;data);
+  mac-&gt;digest (ctx, digest-&gt;length, hash);
+
+  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
+    {
+      fprintf (stderr, "test_mac failed, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (mac-&gt;digest_size, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(digest);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt to re-use the structure */
+  mac-&gt;update (ctx, msg-&gt;length, msg-&gt;data);
+  mac-&gt;digest (ctx, digest-&gt;length, hash);
+  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
+    {
+      fprintf (stderr, "test_mac: failed on re-use, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (mac-&gt;digest_size, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(digest);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt byte-by-byte hashing */
+  mac-&gt;set_key (ctx, key-&gt;data);
+  for (i=0;i&lt;msg-&gt;length;i++)
+    mac-&gt;update (ctx, 1, msg-&gt;data+i);
+  mac-&gt;digest (ctx, digest-&gt;length, hash);
+  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
+    {
+      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(digest);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  free (ctx);
+  free (hash);
+}
+
 void
 test_armor(const struct nettle_armor *armor,
            size_t data_length,
diff --git a/testsuite/testutils.h b/testsuite/testutils.h
index ded57db6ab4f..f4ea38da9deb 100644
--- a/testsuite/testutils.h
+++ b/testsuite/testutils.h
@@ -170,6 +170,12 @@ test_hash_large(const struct nettle_hash *hash,
 		uint8_t c,
 		const struct tstring *digest);
 
+void
+test_mac(const struct nettle_mac *mac,
+	 const struct tstring *key,
+	 const struct tstring *msg,
+	 const struct tstring *digest);
+
 void
 test_armor(const struct nettle_armor *armor,
            size_t data_length,
-- 
2.19.1


</body></email><email><emailId>20181101102814</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-11-01 10:28:14-0400</timestampReceived><subject>[PATCH 2/3] cmac: add 64-bit mode CMAC</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 cmac.c         | 115 +++++++++++++++++++++++++++++++++++++++++++++++++
 cmac.h         |  58 +++++++++++++++++++++++++
 nettle-types.h |   7 +++
 3 files changed, 180 insertions(+)

diff --git a/cmac.c b/cmac.c
index d08bd8325b16..8a70f595b14b 100644
--- a/cmac.c
+++ b/cmac.c
@@ -64,6 +64,20 @@ block_mulx(union nettle_block16 *dst,
   WRITE_UINT64(dst-&gt;b+8, b2);
 }
 
+static void
+block_mulx8(union nettle_block8 *dst,
+	    const union nettle_block8 *src)
+{
+  uint64_t b1 = READ_UINT64(src-&gt;b);
+
+  b1 &lt;&lt;= 1;
+
+  if (src-&gt;b[0] &amp; 0x80)
+    b1 ^= 0x1b;
+
+  WRITE_UINT64(dst-&gt;b, b1);
+}
+
 void
 cmac128_set_key(struct cmac128_ctx *ctx, const void *cipher,
 		nettle_cipher_func *encrypt)
@@ -167,3 +181,104 @@ cmac128_digest(struct cmac128_ctx *ctx, const void *cipher,
   memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
   ctx-&gt;index = 0;
 }
+
+void
+cmac64_set_key(struct cmac64_ctx *ctx, const void *cipher,
+		nettle_cipher_func *encrypt)
+{
+  static const uint8_t const_zero[] = {
+    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+  };
+  union nettle_block8 *L = &amp;ctx-&gt;block;
+  memset(ctx, 0, sizeof(*ctx));
+
+  /* step 1 - generate subkeys k1 and k2 */
+  encrypt(cipher, 8, L-&gt;b, const_zero);
+
+  block_mulx8(&amp;ctx-&gt;K1, L);
+  block_mulx8(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
+}
+
+void
+cmac64_update(struct cmac64_ctx *ctx, const void *cipher,
+	       nettle_cipher_func *encrypt,
+	       size_t msg_len, const uint8_t *msg)
+{
+  union nettle_block16 Y;
+  /*
+   * check if we expand the block
+   */
+  if (ctx-&gt;index &lt; 8)
+    {
+      size_t len = MIN(8 - ctx-&gt;index, msg_len);
+      memcpy(&amp;ctx-&gt;block.b[ctx-&gt;index], msg, len);
+      msg += len;
+      msg_len -= len;
+      ctx-&gt;index += len;
+    }
+
+  if (msg_len == 0) {
+    /* if it is still the last block, we are done */
+    return;
+  }
+
+  /*
+   * now checksum everything but the last block
+   */
+  memxor3(Y.b, ctx-&gt;X.b, ctx-&gt;block.b, 8);
+  encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
+
+  while (msg_len &gt; 8)
+    {
+      memxor3(Y.b, ctx-&gt;X.b, msg, 8);
+      encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
+      msg += 8;
+      msg_len -= 8;
+    }
+
+  /*
+   * copy the last block, it will be processed in
+   * cmac64_digest().
+   */
+  memcpy(ctx-&gt;block.b, msg, msg_len);
+  ctx-&gt;index = msg_len;
+}
+
+void
+cmac64_digest(struct cmac64_ctx *ctx, const void *cipher,
+	       nettle_cipher_func *encrypt,
+	       unsigned length,
+	       uint8_t *dst)
+{
+  union nettle_block16 Y;
+
+  memset(ctx-&gt;block.b+ctx-&gt;index, 0, sizeof(ctx-&gt;block.b)-ctx-&gt;index);
+
+  /* re-use ctx-&gt;block for memxor output */
+  if (ctx-&gt;index &lt; 8)
+    {
+      ctx-&gt;block.b[ctx-&gt;index] = 0x80;
+      memxor(ctx-&gt;block.b, ctx-&gt;K2.b, 8);
+    }
+  else
+    {
+      memxor(ctx-&gt;block.b, ctx-&gt;K1.b, 8);
+    }
+
+  memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 8);
+
+  assert(length &lt;= 8);
+  if (length == 8)
+    {
+      encrypt(cipher, 8, dst, Y.b);
+    }
+  else
+    {
+      encrypt(cipher, 8, ctx-&gt;block.b, Y.b);
+      memcpy(dst, ctx-&gt;block.b, length);
+    }
+
+  /* reset state for re-use */
+  memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
+  ctx-&gt;index = 0;
+}
diff --git a/cmac.h b/cmac.h
index 6d107982273e..ddd0248e5e4f 100644
--- a/cmac.h
+++ b/cmac.h
@@ -44,6 +44,7 @@ extern "C" {
 #endif
 
 #define CMAC128_DIGEST_SIZE 16
+#define CMAC64_DIGEST_SIZE 8
 
 #define cmac128_set_key nettle_cmac128_set_key
 #define cmac128_update nettle_cmac128_update
@@ -55,6 +56,10 @@ extern "C" {
 #define cmac_aes256_update nettle_cmac_aes256_update
 #define cmac_aes256_digest nettle_cmac_aes256_digest
 
+#define cmac64_set_key nettle_cmac64_set_key
+#define cmac64_update nettle_cmac64_update
+#define cmac64_digest nettle_cmac64_digest
+
 struct cmac128_ctx
 {
   /* Key */
@@ -69,6 +74,21 @@ struct cmac128_ctx
   size_t index;
 };
 
+struct cmac64_ctx
+{
+  /* Key */
+  union nettle_block8 K1;
+  union nettle_block8 K2;
+
+  /* MAC state */
+  union nettle_block8 X;
+
+  /* Block buffer */
+  union nettle_block8 block;
+  size_t index;
+};
+
+
 void
 cmac128_set_key(struct cmac128_ctx *ctx, const void *cipher,
 		nettle_cipher_func *encrypt);
@@ -107,6 +127,44 @@ cmac128_digest(struct cmac128_ctx *ctx, const void *cipher,
 		  (nettle_cipher_func *) (encrypt),		\
 		  (length), (digest)))
 
+void
+cmac64_set_key(struct cmac64_ctx *ctx, const void *cipher,
+		nettle_cipher_func *encrypt);
+void
+cmac64_update(struct cmac64_ctx *ctx, const void *cipher,
+	       nettle_cipher_func *encrypt,
+	       size_t msg_len, const uint8_t *msg);
+void
+cmac64_digest(struct cmac64_ctx *ctx, const void *cipher,
+	       nettle_cipher_func *encrypt,
+	       unsigned length,
+	       uint8_t *digest);
+
+
+#define CMAC64_CTX(type) \
+  { struct cmac64_ctx ctx; type cipher; }
+
+/* NOTE: Avoid using NULL, as we don't include anything defining it. */
+#define CMAC64_SET_KEY(self, set_key, encrypt, cmac_key)	\
+  do {								\
+    (set_key)(&amp;(self)-&gt;cipher, (cmac_key));			\
+    if (0) (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,		\
+		     (uint8_t *) 0, (const uint8_t *) 0);	\
+    cmac64_set_key(&amp;(self)-&gt;ctx, &amp;(self)-&gt;cipher,		\
+		(nettle_cipher_func *) (encrypt));		\
+  } while (0)
+
+#define CMAC64_UPDATE(self, encrypt, length, src)		\
+  cmac64_update(&amp;(self)-&gt;ctx, &amp;(self)-&gt;cipher,			\
+	      (nettle_cipher_func *)encrypt, (length), (src))
+
+#define CMAC64_DIGEST(self, encrypt, length, digest)		\
+  (0 ? (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,			\
+		 (uint8_t *) 0, (const uint8_t *) 0)		\
+     : cmac64_digest(&amp;(self)-&gt;ctx, &amp;(self)-&gt;cipher,		\
+		  (nettle_cipher_func *) (encrypt),		\
+		  (length), (digest)))
+
 struct cmac_aes128_ctx CMAC128_CTX(struct aes128_ctx);
 
 void
diff --git a/nettle-types.h b/nettle-types.h
index 4576b7c7b5b3..84e9706d8364 100644
--- a/nettle-types.h
+++ b/nettle-types.h
@@ -68,6 +68,13 @@ union nettle_block16
   uint64_t u64[2];
 };
 
+union nettle_block8
+{
+  uint8_t b[8];
+  unsigned long w[8 / sizeof(unsigned long)];
+  uint64_t u64;
+};
+
 /* Randomness. Used by key generation and dsa signature creation. */
 typedef void nettle_random_func(void *ctx,
 				size_t length, uint8_t *dst);
-- 
2.19.1


</body></email><email><emailId>20181101102815</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-11-01 10:28:15-0400</timestampReceived><subject>[PATCH 3/3] cmac: add CMAC-DES3 (CMAC-TDES) implementation</subject><body>

Implement CMAC using TrippleDES as underlying cipher.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 Makefile.in           |  2 +-
 cmac-des3.c           | 61 +++++++++++++++++++++++++++++++++++++++++++
 cmac.h                | 17 ++++++++++++
 testsuite/cmac-test.c | 32 +++++++++++++++++++++++
 4 files changed, 111 insertions(+), 1 deletion(-)
 create mode 100644 cmac-des3.c

diff --git a/Makefile.in b/Makefile.in
index d4fa628a4490..2651109b0807 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -100,7 +100,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-aes256.c gcm-aes256-meta.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
-		 cmac.c cmac-aes128.c cmac-aes256.c \
+		 cmac.c cmac-aes128.c cmac-aes256.c cmac-des3.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
diff --git a/cmac-des3.c b/cmac-des3.c
new file mode 100644
index 000000000000..271021e275b3
--- /dev/null
+++ b/cmac-des3.c
@@ -0,0 +1,61 @@
+/* cmac-des3.c
+
+   CMAC using TrippleDES as the underlying cipher.
+
+   Copyright (C) 2018 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "cmac.h"
+
+void
+cmac_des3_set_key(struct cmac_des3_ctx *ctx, const uint8_t *key)
+{
+  CMAC64_SET_KEY(ctx, des3_set_key, des3_encrypt, key);
+}
+
+void
+cmac_des3_update (struct cmac_des3_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  CMAC64_UPDATE (ctx, des3_encrypt, length, data);
+}
+
+void
+cmac_des3_digest(struct cmac_des3_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  CMAC64_DIGEST(ctx, des3_encrypt, length, digest);
+}
+
diff --git a/cmac.h b/cmac.h
index ddd0248e5e4f..7a6caf175076 100644
--- a/cmac.h
+++ b/cmac.h
@@ -37,6 +37,7 @@
 #define NETTLE_CMAC_H_INCLUDED
 
 #include "aes.h"
+#include "des.h"
 #include "nettle-types.h"
 
 #ifdef __cplusplus
@@ -59,6 +60,9 @@ extern "C" {
 #define cmac64_set_key nettle_cmac64_set_key
 #define cmac64_update nettle_cmac64_update
 #define cmac64_digest nettle_cmac64_digest
+#define cmac_des3_set_key nettle_cmac_des3_set_key
+#define cmac_des3_update nettle_cmac_des3_update
+#define cmac_des3_digest nettle_cmac_des3_digest
 
 struct cmac128_ctx
 {
@@ -191,6 +195,19 @@ void
 cmac_aes256_digest(struct cmac_aes256_ctx *ctx,
 		   size_t length, uint8_t *digest);
 
+struct cmac_des3_ctx CMAC64_CTX(struct des3_ctx);
+
+void
+cmac_des3_set_key(struct cmac_des3_ctx *ctx, const uint8_t *key);
+
+void
+cmac_des3_update(struct cmac_des3_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+cmac_des3_digest(struct cmac_des3_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
index b1d4aa30dfbe..9d6682777dcf 100644
--- a/testsuite/cmac-test.c
+++ b/testsuite/cmac-test.c
@@ -26,12 +26,27 @@ const struct nettle_mac nettle_cmac_aes256 =
   (nettle_hash_digest_func*) cmac_aes256_digest
 };
 
+const struct nettle_mac nettle_cmac_des3 =
+{
+  "CMAC-3DES",
+  sizeof(struct cmac_des3_ctx),
+  CMAC64_DIGEST_SIZE,
+  DES3_KEY_SIZE,
+
+  (nettle_set_key_func*) cmac_des3_set_key,
+  (nettle_hash_update_func*) cmac_des3_update,
+  (nettle_hash_digest_func*) cmac_des3_digest
+};
+
 #define test_cmac_aes128(key, msg, ref)					\
   test_mac(&amp;nettle_cmac_aes128, key, msg, ref)
 
 #define test_cmac_aes256(key, msg, ref)					\
   test_mac(&amp;nettle_cmac_aes256, key, msg, ref)
 
+#define test_cmac_des3(key, msg, ref)					\
+  test_mac(&amp;nettle_cmac_des3, key, msg, ref)
+
 void
 test_main(void)
 {
@@ -96,4 +111,21 @@ test_main(void)
 		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710"),
  SHEX("e1992190549f6ed5696a2c056c315410"));
 
+  /* CMAC-3DES vectors from NIST SP800-38B examples */
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SDATA(""),
+		  SHEX("7db0d37df936c550"));
+
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
+		  SHEX("30239cf1f52e6609"));
+
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a57"),
+		  SHEX("6c9f3ee4923f6be2"));
+
+
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e51"),
+		  SHEX("99429bd0bf7904e5"));
 }
-- 
2.19.1


</body></email><email><emailId>20181119093548</emailId><senderName>=?UTF-8?Q?Tim_R=c3=bchsen?=</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2018-11-19 09:35:48-0400</timestampReceived><subject>nettle-3.4.1</subject><body>

Hi,

are you going to upload a tarball to https://ftp.gnu.org/gnu/nettle/ ?

Regards, Tim

On 11/18/18 11:42 AM, Niels Möller wrote:
&gt; It turns out there's a need for a bugfix-only release nettle-3.4.1, to
&gt; be released in a few weeks.
&gt; 
&gt; I've created a branch release-3.4-fixes, and backported a few bugfixes
&gt; (see commit history or ChangeLog on that branch),
&gt; https://git.lysator.liu.se/nettle/nettle/blob/release-3.4-fixes/ChangeLog
&gt; 
&gt; I'm sorry I haven't been able to respond to the recently posted patches
&gt; on this list. I'll get back to that after 3.4.1.
&gt; 
&gt; If you think I've missed some important bugfixes, please speak up.
&gt; 
&gt; Regards,
&gt; /Niels
&gt; 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20181119/df8e1c06/attachment.sig&gt;

</body></email><email><emailId>20181130164114</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-11-30 16:41:14-0400</timestampReceived><subject>Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

A release candidate for nettle-3.4.1 is now available, as 

  https://www.lysator.liu.se/~nisse/archive/nettle-3.4.1rc1.tar.gz
  https://www.lysator.liu.se/~nisse/archive/nettle-3.4.1rc1.tar.gz.sig

Corresponding changes are also pushed to the branch
https://git.lysator.liu.se/nettle/nettle/tree/release-3.4-fixes

Release timing is prompted by the publication of http://cat.eyalro.net/.
Nettle and GnuTLS authors (as well as developers of other TLS
implementations) were notified by the research team a few months ago.
Related CVE ids:

  CVE-2018-16868 gnutls: Bleichenbacher-like side channel leakage in
  PKCS#1 1.5 verification and padding oracle verification

  CVE-2018-16869 nettle: Leaky data conversion exposing a manager oracle

For Nettle, the RSA code, which I wrote some 15 years ago, have seen an
overhawl. Not only making the handling of PKCS#1 on decryption
side-channel silent (the vulnerabilities that could be exploited by the
methods of the above paper), but also ensuring that we use side-channel
silent functions for the needed bignum arithmetic.

This has been a lot of work, and most of it not done by me, but by Simo
Sorce, at Red Hat Inc. Without this help, it would have been difficult
to get a good release out on time.

Testing of the release candidate is highly appreciated. I intend to make
and announce the non-candidate release soon, possibly as early as
tomorrow morning (i.e., December 1, in European timezone). A GnuTLS
release, depending on the new rsa_sec_decrypt function in Nettle-3.4.1,
is also being made about now.

My understanding is that there's no need to panic. The attack directly
affects RSA decryption, not signatures. And it requires some resources
to be pulled off. As far as I understand, a successful attack lets the
attacker decrypt or sign a targeted message, e.g., compromising the TLS
"premaster secret", corresponding session keys, and any transmitted
passwords or login cookies sent in a single TLS session, but it does not
expose the private key itself.

However, if you operate a TLS server, you should consider if you can
completely disable key exchange based on RSA decryption. If you need to
keep it for backwards compatibility, it is *strongly* encouraged to use
a separate RSA key for this purpose, *not* reused or authorized for any
other purpose.

Regards,
/Niels

NEWS for the Nettle 3.4.1 release

	This release fixes a few bugs, and makes the RSA private key
	operations side channel silent. The RSA improvements are
	contributed by Simo Sorce and Red Hat, and include one new
	public function, rsa_sec_decrypt, see below.

	All functions using RSA private keys are now side-channel
	silent, meaning that they try hard to avoid any branches or
	memory accesses depending on secret data. This applies both to
	the bignum calculations, which now use GMP's mpn_sec_* family
	of functions, and the processing of PKCS#1 padding needed for
	RSA decryption.

	Nettle's ECC functions were already side-channel silent, while
	the DSA functions still aren't. There's also one caveat
	regarding the improved RSA functions: due to small table
	lookups in relevant mpn_sec_* functions in GMP-6.1.2, the
	lowest and highest few bits of the secret factors p and q may
	still leak. I'm not aware of any attacks on RSA where knowing
	a few bits of the factors makes a significant difference. This
	leak will likely be plugged in later GMP versions.

	Changes in behavior:

	* The functions rsa_decrypt and rsa_decrypt_tr may now clobber
	  all of the provided message buffer, independent of the
	  actual message length. They are side-channel silent, in that
	  branches and memory accesses don't depend on the validity or
	  length of the message. Side-channel leakage from the
	  caller's use of length and return value may still provide an
	  oracle useable for a Bleichenbacher-style chosen ciphertext
	  attack. Which is why the new function rsa_sec_decrypt is
	  recommended.

	New features:

	* A new function rsa_sec_decrypt. It differs from
	  rsa_decrypt_tr in that the length of the decrypted message
	  is given a priori, and PKCS#1 padding indicating a different
	  length is treated as an error. For applications that may be
	  subject to chosen ciphertext attacks, it is recommended to
	  initialize the message area with random data, call this
	  function, and ignore the return value. This applies in
	  particular to RSA-based key exchange in the TLS protocol.

	Bug fixes:

	* Fix bug in pkcs1-conv, missing break statements in the
	  parsing of PEM input files.

	* Fix link error on the pss-mgf1-test test, affecting builds
	  without public key support.

	Performance regression:

	* All RSA private key operations employing RSA blinding, i.e.,
	  rsa_decrypt_tr, rsa_*_sign_tr, the new rsa_sec_decrypt, and
	  rsa_compute_root_tr, are significantly slower. This is
	  because (i) RSA blinding now use side-channel silent
	  operations, (ii) blinding includes a modular inversion, and
	  (iii) side-channel silent modular inversion, implemented as
	  mpn_sec_invert, is very expensive. A 60% slowdown for
	  2048-bit RSA keys have been measured.

	Miscellaneous:

	* Building the public key support of nettle now requires GMP
	  version 6.0 or later (unless --enable-mini-gmp is used).

	The shared library names are libnettle.so.6.5 and
	libhogweed.so.4.5, with sonames still libnettle.so.6 and
	libhogweed.so.4. It is intended to be fully binary compatible
	with nettle-3.1.

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20181008185833</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2018-10-08 18:58:33-0400</timestampReceived><subject>Implement XTS block cipher mode</subject><body>

Hello,

The attached patch implements the XTS block cipher mode, as specified
in IEEE P1619. The interface is split into a generic pair of functions
for encryption and decryption and additional AES-128/AES-256 variants.

The function signatures follows the same pattern used by other block-
cipher modes like ctr, cfb, ccm, etc...

Basic tests using a small selection of NIST CAVS vectors are provided.

XTS is use in several disk encryption algorithms and programs because
it allows to use a block cipher even when the input length is not a
perfect multiple of the block cipher length by using ciphertext
stealing.

Thanks to Daiki Ueno for initial review.

Feedback is appreciated.

Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0001-Add-support-for-XTS-encryption-mode.patch
Type: text/x-patch
Size: 33201 bytes
Desc: not available
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20181008/9ad533f7/attachment.bin&gt;

</body></email><email><emailId>20181011055815</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-10-11 05:58:15-0400</timestampReceived><subject>[PATCH] ctr16: fix encryption if src == dst</subject><body>

ср, 10 окт. 2018 г. в 20:29, Niels Möller &lt;nisse at lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt; writes:
&gt;
&gt; &gt; If src == dst, ctr16 code will fail to increment src and dst pointers,
&gt; &gt; always overwriting first block.
&gt; &gt;
&gt; &gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
&gt; &gt; ---
&gt; &gt;  ctr16.c | 2 +-
&gt; &gt;  1 file changed, 1 insertion(+), 1 deletion(-)
&gt; &gt;
&gt; &gt; diff --git a/ctr16.c b/ctr16.c
&gt; &gt; index 60418e8b9032..7e1c23d20832 100644
&gt; &gt; --- a/ctr16.c
&gt; &gt; +++ b/ctr16.c
&gt; &gt; @@ -91,7 +91,7 @@ _ctr_crypt16(const void *ctx, nettle_cipher_func *f,
&gt; &gt;         f(ctx, CTR_BUFFER_LIMIT, buffer-&gt;b, buffer-&gt;b);
&gt; &gt;         if (length - i &lt; CTR_BUFFER_LIMIT)
&gt; &gt;           goto done;
&gt; &gt; -       memxor3 (dst, src, buffer-&gt;b, CTR_BUFFER_LIMIT);
&gt; &gt; +       memxor3 (dst + i, src + i, buffer-&gt;b, CTR_BUFFER_LIMIT);
&gt; &gt;       }
&gt; &gt;
&gt; &gt;        if (blocks &gt; 0)
&gt;
&gt; Applied, thanks!

Thank you!

&gt; If I understand this correctly, bug is triggered only when processing &gt;=
&gt; 1024 bytes (2 * CTR_BUFFER_LIMIT) at a time.

Yes.

&gt; If you would like to write
&gt; a test case, that's appreciated.

I will try to, though I'm busy with other tasks.

-- 
With best wishes
Dmitry

</body></email><email><emailId>20180921142434</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-09-21 14:24:34-0400</timestampReceived><subject>[PATCH 0/3] Add CMAC-64 and CMAC-DES3 support</subject><body>

To further improve GOST ciphers support in GnuTLS I need 64-bit CMAC
variant (since one of GOST ciphers is 64-bit one). Implement CMAC-64 and
CMAC-DES3 as a way to prove CMAC-64 correctness.

-- 
With best wishes
Dmitry



</body></email><email><emailId>20180921142435</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-09-21 14:24:35-0400</timestampReceived><subject>[PATCH 1/3] Move MAC testing code to generic place from cmac-test</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 testsuite/cmac-test.c | 100 +++++++++++-------------------------------
 testsuite/testutils.c |  64 +++++++++++++++++++++++++++
 testsuite/testutils.h |   6 +++
 3 files changed, 96 insertions(+), 74 deletions(-)

diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
index 31662d1b6c1b..b1d4aa30dfbe 100644
--- a/testsuite/cmac-test.c
+++ b/testsuite/cmac-test.c
@@ -2,83 +2,35 @@
 #include "nettle-internal.h"
 #include "cmac.h"
 
+const struct nettle_mac nettle_cmac_aes128 =
+{
+  "CMAC-AES128",
+  sizeof(struct cmac_aes128_ctx),
+  CMAC128_DIGEST_SIZE,
+  AES128_KEY_SIZE,
+
+  (nettle_set_key_func*) cmac_aes128_set_key,
+  (nettle_hash_update_func*) cmac_aes128_update,
+  (nettle_hash_digest_func*) cmac_aes128_digest
+};
+
+const struct nettle_mac nettle_cmac_aes256 =
+{
+  "CMAC-AES256",
+  sizeof(struct cmac_aes256_ctx),
+  CMAC128_DIGEST_SIZE,
+  AES256_KEY_SIZE,
+
+  (nettle_set_key_func*) cmac_aes256_set_key,
+  (nettle_hash_update_func*) cmac_aes256_update,
+  (nettle_hash_digest_func*) cmac_aes256_digest
+};
+
 #define test_cmac_aes128(key, msg, ref)					\
-  test_cmac_hash ((nettle_set_key_func*) cmac_aes128_set_key,		\
-		  (nettle_hash_update_func*) cmac_aes128_update,	\
-		  (nettle_hash_digest_func*) cmac_aes128_digest,	\
-		  sizeof(struct cmac_aes128_ctx),			\
-		  key, msg, ref)
+  test_mac(&amp;nettle_cmac_aes128, key, msg, ref)
 
 #define test_cmac_aes256(key, msg, ref)					\
-  test_cmac_hash ((nettle_set_key_func*) cmac_aes256_set_key,		\
-		  (nettle_hash_update_func*) cmac_aes256_update,	\
-		  (nettle_hash_digest_func*) cmac_aes256_digest,	\
-		  sizeof(struct cmac_aes256_ctx),			\
-		  key, msg, ref)
-
-static void
-test_cmac_hash (nettle_set_key_func *set_key,
-		nettle_hash_update_func *update,
-		nettle_hash_digest_func *digest, size_t ctx_size,
-		const struct tstring *key, const struct tstring *msg,
-		const struct tstring *ref)
-{
-  void *ctx;
-  uint8_t hash[16];
-  unsigned i;
-
-  ctx = xalloc(ctx_size);
-
-  ASSERT (ref-&gt;length == sizeof(hash));
-  ASSERT (key-&gt;length == 16 || key-&gt;length == 32);
-  set_key (ctx, key-&gt;data);
-  update (ctx, msg-&gt;length, msg-&gt;data);
-  digest (ctx, sizeof(hash), hash);
-  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
-    {
-      fprintf (stderr, "cmac_hash failed, msg: ");
-      print_hex (msg-&gt;length, msg-&gt;data);
-      fprintf(stderr, "Output:");
-      print_hex (16, hash);
-      fprintf(stderr, "Expected:");
-      tstring_print_hex(ref);
-      fprintf(stderr, "\n");
-      FAIL();
-    }
-
-  /* attempt to re-use the structure */
-  update (ctx, msg-&gt;length, msg-&gt;data);
-  digest (ctx, sizeof(hash), hash);
-  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
-    {
-      fprintf (stderr, "cmac_hash failed on re-use, msg: ");
-      print_hex (msg-&gt;length, msg-&gt;data);
-      fprintf(stderr, "Output:");
-      print_hex (16, hash);
-      fprintf(stderr, "Expected:");
-      tstring_print_hex(ref);
-      fprintf(stderr, "\n");
-      FAIL();
-    }
-
-  /* attempt byte-by-byte hashing */
-  set_key (ctx, key-&gt;data);
-  for (i=0;i&lt;msg-&gt;length;i++)
-    update (ctx, 1, msg-&gt;data+i);
-  digest (ctx, sizeof(hash), hash);
-  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
-    {
-      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
-      print_hex (msg-&gt;length, msg-&gt;data);
-      fprintf(stderr, "Output:");
-      print_hex (16, hash);
-      fprintf(stderr, "Expected:");
-      tstring_print_hex(ref);
-      fprintf(stderr, "\n");
-      FAIL();
-    }
-  free (ctx);
-}
+  test_mac(&amp;nettle_cmac_aes256, key, msg, ref)
 
 void
 test_main(void)
diff --git a/testsuite/testutils.c b/testsuite/testutils.c
index 1812ff4f52b0..ba0b41131925 100644
--- a/testsuite/testutils.c
+++ b/testsuite/testutils.c
@@ -924,6 +924,70 @@ test_hash_large(const struct nettle_hash *hash,
   free(data);
 }
 
+void
+test_mac(const struct nettle_mac *mac,
+	 const struct tstring *key,
+	 const struct tstring *msg,
+	 const struct tstring *digest)
+{
+  void *ctx = xalloc(mac-&gt;context_size);
+  uint8_t *hash = xalloc(mac-&gt;digest_size);
+  unsigned i;
+
+
+  ASSERT (digest-&gt;length == mac-&gt;digest_size);
+  ASSERT (key-&gt;length == mac-&gt;key_size);
+  mac-&gt;set_key (ctx, key-&gt;data);
+  mac-&gt;update (ctx, msg-&gt;length, msg-&gt;data);
+  mac-&gt;digest (ctx, digest-&gt;length, hash);
+
+  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
+    {
+      fprintf (stderr, "test_mac failed, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (mac-&gt;digest_size, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(digest);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt to re-use the structure */
+  mac-&gt;update (ctx, msg-&gt;length, msg-&gt;data);
+  mac-&gt;digest (ctx, digest-&gt;length, hash);
+  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
+    {
+      fprintf (stderr, "test_mac: failed on re-use, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (mac-&gt;digest_size, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(digest);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt byte-by-byte hashing */
+  mac-&gt;set_key (ctx, key-&gt;data);
+  for (i=0;i&lt;msg-&gt;length;i++)
+    mac-&gt;update (ctx, 1, msg-&gt;data+i);
+  mac-&gt;digest (ctx, digest-&gt;length, hash);
+  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
+    {
+      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(digest);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  free (ctx);
+  free (hash);
+}
+
 void
 test_armor(const struct nettle_armor *armor,
            size_t data_length,
diff --git a/testsuite/testutils.h b/testsuite/testutils.h
index ded57db6ab4f..f4ea38da9deb 100644
--- a/testsuite/testutils.h
+++ b/testsuite/testutils.h
@@ -170,6 +170,12 @@ test_hash_large(const struct nettle_hash *hash,
 		uint8_t c,
 		const struct tstring *digest);
 
+void
+test_mac(const struct nettle_mac *mac,
+	 const struct tstring *key,
+	 const struct tstring *msg,
+	 const struct tstring *digest);
+
 void
 test_armor(const struct nettle_armor *armor,
            size_t data_length,
-- 
2.19.0


</body></email><email><emailId>20180921142436</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-09-21 14:24:36-0400</timestampReceived><subject>[PATCH 2/3] cmac: add 64-bit mode CMAC</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 cmac.c         | 115 +++++++++++++++++++++++++++++++++++++++++++++++++
 cmac.h         |  58 +++++++++++++++++++++++++
 nettle-types.h |   7 +++
 3 files changed, 180 insertions(+)

diff --git a/cmac.c b/cmac.c
index d08bd8325b16..8a70f595b14b 100644
--- a/cmac.c
+++ b/cmac.c
@@ -64,6 +64,20 @@ block_mulx(union nettle_block16 *dst,
   WRITE_UINT64(dst-&gt;b+8, b2);
 }
 
+static void
+block_mulx8(union nettle_block8 *dst,
+	    const union nettle_block8 *src)
+{
+  uint64_t b1 = READ_UINT64(src-&gt;b);
+
+  b1 &lt;&lt;= 1;
+
+  if (src-&gt;b[0] &amp; 0x80)
+    b1 ^= 0x1b;
+
+  WRITE_UINT64(dst-&gt;b, b1);
+}
+
 void
 cmac128_set_key(struct cmac128_ctx *ctx, const void *cipher,
 		nettle_cipher_func *encrypt)
@@ -167,3 +181,104 @@ cmac128_digest(struct cmac128_ctx *ctx, const void *cipher,
   memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
   ctx-&gt;index = 0;
 }
+
+void
+cmac64_set_key(struct cmac64_ctx *ctx, const void *cipher,
+		nettle_cipher_func *encrypt)
+{
+  static const uint8_t const_zero[] = {
+    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+  };
+  union nettle_block8 *L = &amp;ctx-&gt;block;
+  memset(ctx, 0, sizeof(*ctx));
+
+  /* step 1 - generate subkeys k1 and k2 */
+  encrypt(cipher, 8, L-&gt;b, const_zero);
+
+  block_mulx8(&amp;ctx-&gt;K1, L);
+  block_mulx8(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
+}
+
+void
+cmac64_update(struct cmac64_ctx *ctx, const void *cipher,
+	       nettle_cipher_func *encrypt,
+	       size_t msg_len, const uint8_t *msg)
+{
+  union nettle_block16 Y;
+  /*
+   * check if we expand the block
+   */
+  if (ctx-&gt;index &lt; 8)
+    {
+      size_t len = MIN(8 - ctx-&gt;index, msg_len);
+      memcpy(&amp;ctx-&gt;block.b[ctx-&gt;index], msg, len);
+      msg += len;
+      msg_len -= len;
+      ctx-&gt;index += len;
+    }
+
+  if (msg_len == 0) {
+    /* if it is still the last block, we are done */
+    return;
+  }
+
+  /*
+   * now checksum everything but the last block
+   */
+  memxor3(Y.b, ctx-&gt;X.b, ctx-&gt;block.b, 8);
+  encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
+
+  while (msg_len &gt; 8)
+    {
+      memxor3(Y.b, ctx-&gt;X.b, msg, 8);
+      encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
+      msg += 8;
+      msg_len -= 8;
+    }
+
+  /*
+   * copy the last block, it will be processed in
+   * cmac64_digest().
+   */
+  memcpy(ctx-&gt;block.b, msg, msg_len);
+  ctx-&gt;index = msg_len;
+}
+
+void
+cmac64_digest(struct cmac64_ctx *ctx, const void *cipher,
+	       nettle_cipher_func *encrypt,
+	       unsigned length,
+	       uint8_t *dst)
+{
+  union nettle_block16 Y;
+
+  memset(ctx-&gt;block.b+ctx-&gt;index, 0, sizeof(ctx-&gt;block.b)-ctx-&gt;index);
+
+  /* re-use ctx-&gt;block for memxor output */
+  if (ctx-&gt;index &lt; 8)
+    {
+      ctx-&gt;block.b[ctx-&gt;index] = 0x80;
+      memxor(ctx-&gt;block.b, ctx-&gt;K2.b, 8);
+    }
+  else
+    {
+      memxor(ctx-&gt;block.b, ctx-&gt;K1.b, 8);
+    }
+
+  memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 8);
+
+  assert(length &lt;= 8);
+  if (length == 8)
+    {
+      encrypt(cipher, 8, dst, Y.b);
+    }
+  else
+    {
+      encrypt(cipher, 8, ctx-&gt;block.b, Y.b);
+      memcpy(dst, ctx-&gt;block.b, length);
+    }
+
+  /* reset state for re-use */
+  memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
+  ctx-&gt;index = 0;
+}
diff --git a/cmac.h b/cmac.h
index 6d107982273e..ddd0248e5e4f 100644
--- a/cmac.h
+++ b/cmac.h
@@ -44,6 +44,7 @@ extern "C" {
 #endif
 
 #define CMAC128_DIGEST_SIZE 16
+#define CMAC64_DIGEST_SIZE 8
 
 #define cmac128_set_key nettle_cmac128_set_key
 #define cmac128_update nettle_cmac128_update
@@ -55,6 +56,10 @@ extern "C" {
 #define cmac_aes256_update nettle_cmac_aes256_update
 #define cmac_aes256_digest nettle_cmac_aes256_digest
 
+#define cmac64_set_key nettle_cmac64_set_key
+#define cmac64_update nettle_cmac64_update
+#define cmac64_digest nettle_cmac64_digest
+
 struct cmac128_ctx
 {
   /* Key */
@@ -69,6 +74,21 @@ struct cmac128_ctx
   size_t index;
 };
 
+struct cmac64_ctx
+{
+  /* Key */
+  union nettle_block8 K1;
+  union nettle_block8 K2;
+
+  /* MAC state */
+  union nettle_block8 X;
+
+  /* Block buffer */
+  union nettle_block8 block;
+  size_t index;
+};
+
+
 void
 cmac128_set_key(struct cmac128_ctx *ctx, const void *cipher,
 		nettle_cipher_func *encrypt);
@@ -107,6 +127,44 @@ cmac128_digest(struct cmac128_ctx *ctx, const void *cipher,
 		  (nettle_cipher_func *) (encrypt),		\
 		  (length), (digest)))
 
+void
+cmac64_set_key(struct cmac64_ctx *ctx, const void *cipher,
+		nettle_cipher_func *encrypt);
+void
+cmac64_update(struct cmac64_ctx *ctx, const void *cipher,
+	       nettle_cipher_func *encrypt,
+	       size_t msg_len, const uint8_t *msg);
+void
+cmac64_digest(struct cmac64_ctx *ctx, const void *cipher,
+	       nettle_cipher_func *encrypt,
+	       unsigned length,
+	       uint8_t *digest);
+
+
+#define CMAC64_CTX(type) \
+  { struct cmac64_ctx ctx; type cipher; }
+
+/* NOTE: Avoid using NULL, as we don't include anything defining it. */
+#define CMAC64_SET_KEY(self, set_key, encrypt, cmac_key)	\
+  do {								\
+    (set_key)(&amp;(self)-&gt;cipher, (cmac_key));			\
+    if (0) (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,		\
+		     (uint8_t *) 0, (const uint8_t *) 0);	\
+    cmac64_set_key(&amp;(self)-&gt;ctx, &amp;(self)-&gt;cipher,		\
+		(nettle_cipher_func *) (encrypt));		\
+  } while (0)
+
+#define CMAC64_UPDATE(self, encrypt, length, src)		\
+  cmac64_update(&amp;(self)-&gt;ctx, &amp;(self)-&gt;cipher,			\
+	      (nettle_cipher_func *)encrypt, (length), (src))
+
+#define CMAC64_DIGEST(self, encrypt, length, digest)		\
+  (0 ? (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,			\
+		 (uint8_t *) 0, (const uint8_t *) 0)		\
+     : cmac64_digest(&amp;(self)-&gt;ctx, &amp;(self)-&gt;cipher,		\
+		  (nettle_cipher_func *) (encrypt),		\
+		  (length), (digest)))
+
 struct cmac_aes128_ctx CMAC128_CTX(struct aes128_ctx);
 
 void
diff --git a/nettle-types.h b/nettle-types.h
index 4576b7c7b5b3..84e9706d8364 100644
--- a/nettle-types.h
+++ b/nettle-types.h
@@ -68,6 +68,13 @@ union nettle_block16
   uint64_t u64[2];
 };
 
+union nettle_block8
+{
+  uint8_t b[8];
+  unsigned long w[8 / sizeof(unsigned long)];
+  uint64_t u64;
+};
+
 /* Randomness. Used by key generation and dsa signature creation. */
 typedef void nettle_random_func(void *ctx,
 				size_t length, uint8_t *dst);
-- 
2.19.0


</body></email><email><emailId>20180921142437</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-09-21 14:24:37-0400</timestampReceived><subject>[PATCH 3/3] cmac: add CMAC-DES3 (CMAC-TDES) implementation</subject><body>

Implement CMAC using TrippleDES as underlying cipher.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 Makefile.in           |  2 +-
 cmac-des3.c           | 61 +++++++++++++++++++++++++++++++++++++++++++
 cmac.h                | 17 ++++++++++++
 testsuite/cmac-test.c | 32 +++++++++++++++++++++++
 4 files changed, 111 insertions(+), 1 deletion(-)
 create mode 100644 cmac-des3.c

diff --git a/Makefile.in b/Makefile.in
index d4fa628a4490..2651109b0807 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -100,7 +100,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-aes256.c gcm-aes256-meta.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
-		 cmac.c cmac-aes128.c cmac-aes256.c \
+		 cmac.c cmac-aes128.c cmac-aes256.c cmac-des3.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
diff --git a/cmac-des3.c b/cmac-des3.c
new file mode 100644
index 000000000000..271021e275b3
--- /dev/null
+++ b/cmac-des3.c
@@ -0,0 +1,61 @@
+/* cmac-des3.c
+
+   CMAC using TrippleDES as the underlying cipher.
+
+   Copyright (C) 2018 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "cmac.h"
+
+void
+cmac_des3_set_key(struct cmac_des3_ctx *ctx, const uint8_t *key)
+{
+  CMAC64_SET_KEY(ctx, des3_set_key, des3_encrypt, key);
+}
+
+void
+cmac_des3_update (struct cmac_des3_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  CMAC64_UPDATE (ctx, des3_encrypt, length, data);
+}
+
+void
+cmac_des3_digest(struct cmac_des3_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  CMAC64_DIGEST(ctx, des3_encrypt, length, digest);
+}
+
diff --git a/cmac.h b/cmac.h
index ddd0248e5e4f..7a6caf175076 100644
--- a/cmac.h
+++ b/cmac.h
@@ -37,6 +37,7 @@
 #define NETTLE_CMAC_H_INCLUDED
 
 #include "aes.h"
+#include "des.h"
 #include "nettle-types.h"
 
 #ifdef __cplusplus
@@ -59,6 +60,9 @@ extern "C" {
 #define cmac64_set_key nettle_cmac64_set_key
 #define cmac64_update nettle_cmac64_update
 #define cmac64_digest nettle_cmac64_digest
+#define cmac_des3_set_key nettle_cmac_des3_set_key
+#define cmac_des3_update nettle_cmac_des3_update
+#define cmac_des3_digest nettle_cmac_des3_digest
 
 struct cmac128_ctx
 {
@@ -191,6 +195,19 @@ void
 cmac_aes256_digest(struct cmac_aes256_ctx *ctx,
 		   size_t length, uint8_t *digest);
 
+struct cmac_des3_ctx CMAC64_CTX(struct des3_ctx);
+
+void
+cmac_des3_set_key(struct cmac_des3_ctx *ctx, const uint8_t *key);
+
+void
+cmac_des3_update(struct cmac_des3_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+cmac_des3_digest(struct cmac_des3_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
index b1d4aa30dfbe..9d6682777dcf 100644
--- a/testsuite/cmac-test.c
+++ b/testsuite/cmac-test.c
@@ -26,12 +26,27 @@ const struct nettle_mac nettle_cmac_aes256 =
   (nettle_hash_digest_func*) cmac_aes256_digest
 };
 
+const struct nettle_mac nettle_cmac_des3 =
+{
+  "CMAC-3DES",
+  sizeof(struct cmac_des3_ctx),
+  CMAC64_DIGEST_SIZE,
+  DES3_KEY_SIZE,
+
+  (nettle_set_key_func*) cmac_des3_set_key,
+  (nettle_hash_update_func*) cmac_des3_update,
+  (nettle_hash_digest_func*) cmac_des3_digest
+};
+
 #define test_cmac_aes128(key, msg, ref)					\
   test_mac(&amp;nettle_cmac_aes128, key, msg, ref)
 
 #define test_cmac_aes256(key, msg, ref)					\
   test_mac(&amp;nettle_cmac_aes256, key, msg, ref)
 
+#define test_cmac_des3(key, msg, ref)					\
+  test_mac(&amp;nettle_cmac_des3, key, msg, ref)
+
 void
 test_main(void)
 {
@@ -96,4 +111,21 @@ test_main(void)
 		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710"),
  SHEX("e1992190549f6ed5696a2c056c315410"));
 
+  /* CMAC-3DES vectors from NIST SP800-38B examples */
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SDATA(""),
+		  SHEX("7db0d37df936c550"));
+
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
+		  SHEX("30239cf1f52e6609"));
+
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a57"),
+		  SHEX("6c9f3ee4923f6be2"));
+
+
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e51"),
+		  SHEX("99429bd0bf7904e5"));
 }
-- 
2.19.0


</body></email><email><emailId>20180926124912</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-09-26 12:49:12-0400</timestampReceived><subject>[PATCH] ctr16: fix encryption if src == dst</subject><body>

Niels,

This is an important bugfix. Current code will just silently skip higher blocks.
Do you want a demonstration/testcase from me?
чт, 20 сент. 2018 г. в 14:32, Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;:
&gt;
&gt; If src == dst, ctr16 code will fail to increment src and dst pointers,
&gt; always overwriting first block.
&gt;
&gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
&gt; ---
&gt;  ctr16.c | 2 +-
&gt;  1 file changed, 1 insertion(+), 1 deletion(-)
&gt;
&gt; diff --git a/ctr16.c b/ctr16.c
&gt; index 60418e8b9032..7e1c23d20832 100644
&gt; --- a/ctr16.c
&gt; +++ b/ctr16.c
&gt; @@ -91,7 +91,7 @@ _ctr_crypt16(const void *ctx, nettle_cipher_func *f,
&gt;           f(ctx, CTR_BUFFER_LIMIT, buffer-&gt;b, buffer-&gt;b);
&gt;           if (length - i &lt; CTR_BUFFER_LIMIT)
&gt;             goto done;
&gt; -         memxor3 (dst, src, buffer-&gt;b, CTR_BUFFER_LIMIT);
&gt; +         memxor3 (dst + i, src + i, buffer-&gt;b, CTR_BUFFER_LIMIT);
&gt;         }
&gt;
&gt;        if (blocks &gt; 0)
&gt; --
&gt; 2.18.0
&gt;


-- 
With best wishes
Dmitry

</body></email><email><emailId>20180813085427</emailId><senderName>=?UTF-8?Q?Tim_R=c3=bchsen?=</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2018-08-13 08:54:27-0400</timestampReceived><subject>Deprecation</subject><body>

Hi Niels,

#defines should not start with an underscore. C standards say this is
reserved (for system headers !?) and some static analyzers complain
about it.

7.1.3 Reserved Identifiers
...
All identifiers that begin with an underscore and either an uppercase
letter or another underscore are always reserved for any use.
...


Regards, Tim

On 08/09/2018 10:16 PM, Niels Möller wrote:
&gt; I've looked into using __attribute__ ((deprecated)).
&gt; 
&gt; See branch attribute-deprecated. I define _NETTLE_ATTRIBUTE_DEPRECATED
&gt; in nettle-types.h (and _NETTLE_ATTRIBUTE_PURE, needed in a few places).
&gt; For a start, I've marked the old aes and gcm-aes interfaces as deprecated,
&gt; as discussed earlier, and the obsolete _rsa_blind and _rsa_unblind
&gt; functions.
&gt; 
&gt; Some more functions are candidates for deprecation:
&gt; 
&gt; 1. Everything in des-compat.h and md5-compat.h. Unless we think it can
&gt;    be deleted without deprecation; I'm not aware of any usage, and they
&gt;    made more sense back in 2001 when Nettle-1.0 was brand new.
&gt; 
&gt; 2. The "general" hmac functions: hmac_set_key, hmac_update, hmac_digest.
&gt; 
&gt; Regards,
&gt; /Niels
&gt; 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20180813/6e74703c/attachment.sig&gt;

</body></email><email><emailId>20180813095610</emailId><senderName>=?UTF-8?Q?Tim_R=c3=bchsen?=</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2018-08-13 09:56:10-0400</timestampReceived><subject>Leading underscores (was: Re: Deprecation)</subject><body>

On 08/13/2018 11:30 AM, Niels Möller wrote:
&gt; Tim Rühsen &lt;tim.ruehsen at gmx.de&gt; writes:
&gt; 
&gt;&gt; #defines should not start with an underscore. C standards say this is
&gt;&gt; reserved (for system headers !?) and some static analyzers complain
&gt;&gt; about it.
&gt; 
&gt; Note that Nettle has violated this rule since the very beginnings. E.g,
&gt; 
&gt; #define _MD5_DIGEST_LENGTH 4
&gt; 
&gt; has been in md5.h since the initial commit (back in April 2001, around
&gt; midnight). I haven't seen any reports about this causing problems.
&gt; 
&gt; I agree it's not quite right, and maybe we should clean this up at some
&gt; point, replacing the leading underscore by nettle_internal_ (or maybe
&gt; trailing underscore or nettle__ (double underscore). But not now.
&gt; 
&gt; Which static analyzers complain?

AFAIR it was lgtm.com complaining the header guards in libpsl (which I
meanwhile changed to not use leading underscores).

And you are right, I also have never experienced any problems with such
defines. Except that people keep complaining about not following the
standards ;-)

Getting automated static analyzers to 0 issues has the nice side-effect
that you can fail your CI / build when 1+ issue pops up. So any
contributor is (automatically) forced to deliver clean code.
That takes some burden from the maintainer and reduces iteration /
discussions about certain kind of 'cleanups'.

So nothing serious that needs to be addressed immediately.

Regards, Tim

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20180813/44c8c713/attachment.sig&gt;

</body></email><email><emailId>20180713085656</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-07-13 08:56:56-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

On Thu, 2018-07-12 at 18:04 +0200, Niels Möller wrote:
&gt; 
&gt; We'll see how to deal with those failures, but I don't think they
&gt; should block merging to the master branch. 
&gt; 
&gt; There are also two "runner system failures", see
&gt; https://gitlab.com/gnutls/nettle/-/jobs/81332562. Can that be
&gt; restarted?
&gt; It would be nice to see a successful arm build before merging to
&gt; master.

I've restarted it. It passes. If you have a gitlab account I will give
you access to the repo.

regards,
Nikos


</body></email><email><emailId>20180713085935</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-07-13 08:59:35-0400</timestampReceived><subject>Static analyzer (was: Re: nettle symbols: improve map files)</subject><body>

On Fri, 2018-07-13 at 10:08 +0200, Niels Möller wrote:
&gt; 
&gt; I've had a closer look now, and I think both are of similar type. In
&gt; eratosthenes.c, we have a bitmap initialized with
&gt; 
&gt;   static void
&gt;   vector_init(unsigned long *vector, unsigned long size)
&gt;   {
&gt;     unsigned long end = (size + BITS_PER_LONG - 1) / BITS_PER_LONG;
&gt;     unsigned long i;
&gt;   
&gt;     for (i = 0; i &lt; end; i++)
&gt;       vector[i] = ~0UL;
&gt;   }
&gt; 
&gt; and later updated with the loop
&gt; 
&gt;   static void
&gt;   vector_clear_bits (unsigned long *vector, unsigned long step,
&gt;                      unsigned long start, unsigned long size)
&gt;   {
&gt;     unsigned long bit;
&gt;   
&gt;     for (bit = start; bit &lt; size; bit += step)
&gt;       {
&gt;         unsigned long i = bit / BITS_PER_LONG;
&gt;         unsigned long mask = 1L &lt;&lt; (bit % BITS_PER_LONG);
&gt;   
&gt;         vector[i] &amp;= ~mask;
&gt;       }
&gt;   }
&gt; 
&gt; The value of the size argument is the same in both places (named
&gt; "sieve_nbits" in the calling code). The static analyzer complains
&gt; that
&gt; vector[i] is not properly initialized. And it's kind-of right: In
&gt; case
&gt; (size + BITS_PER_LONG - 1) wraps around, the bitmap will not be
&gt; initialized properly. But I would classify it as an out-of-bounds
&gt; access, not use of uninitialized data.
&gt; 
&gt; I could add an overflow check in the vector_alloc function, which
&gt; uses
&gt; the same expression, and where it might make sense. I wonder of that
&gt; would make the analyzer happy.
&gt; 
&gt; In eccdata.c, the allocation function is ecc_alloc, which alllocates
&gt; an
&gt; array and loops over it to initialize all elements. The complant is
&gt; in
&gt; ecc_pippenger_precompute, which allocates an array with
&gt; 
&gt;   ecc-&gt;table = ecc_alloc (ecc-&gt;table_size);
&gt; 
&gt; and the complaint is the assignment of element 1,
&gt; 
&gt;   ecc_set (&amp;ecc-&gt;table[1], &amp;ecc-&gt;g);
&gt; 
&gt; where ecc-&gt;table[1].x-&gt;_mp_alloc is claimed to be uninitialized.
&gt; 
&gt; This also is kind-of right; if the program is run with strange
&gt; parameters, we might get ecc-&gt;table_size &lt; 2 (and again, in that
&gt; case,
&gt; it's an out of bounds access).
&gt; 
&gt; I don't have that much experience with the static analyzer. Should I
&gt; just add error handling for the corner cases, and see if that solves
&gt; the problem?

An assert() should be sufficient to inform it of the constraints.

regards,
Nikos


</body></email><email><emailId>20180716071632</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-07-16 07:16:32-0400</timestampReceived><subject>Static analyzer</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos at gmail.com&gt; writes:

&gt; Given that it is only an example maybe use #ifndef __clang_analyzer__
&gt; in the whole file?

Could be an option, if nothing else works. But one would need a dummy
main function, otherwise we'd get link errors.

For eccdata.c we'd need something less drastic.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180724083803</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-07-24 08:38:03-0400</timestampReceived><subject>[PATCH 1/2] hmac: provide alternative HMAC interface</subject><body>

Provide alternative HMAC interface, with context struct having just
derived key and single hash state instead of three hash states at once.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 hmac.c | 66 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 hmac.h | 32 ++++++++++++++++++++++++++++
 2 files changed, 98 insertions(+)

diff --git a/hmac.c b/hmac.c
index 6ac5e11a0686..6d57f8c9197c 100644
--- a/hmac.c
+++ b/hmac.c
@@ -115,3 +115,69 @@ hmac_digest(const void *outer, const void *inner, void *state,
 
   memcpy(state, inner, hash-&gt;context_size);
 }
+
+static void
+hmac2_reinit_state(void *state, void *derived_key,
+		   const struct nettle_hash *hash,
+		   uint8_t padc)
+{
+  TMP_DECL(pad, uint8_t, NETTLE_MAX_HASH_BLOCK_SIZE);
+  TMP_ALLOC(pad, hash-&gt;block_size);
+
+  memset(pad, padc, hash-&gt;block_size);
+  memxor(pad, derived_key, hash-&gt;block_size);
+
+  hash-&gt;init(state);
+  hash-&gt;update(state, hash-&gt;block_size, pad);
+}
+
+void
+hmac2_set_key(void *state, void *derived_key,
+	      const struct nettle_hash *hash,
+	      size_t key_length, const uint8_t *key)
+{
+  memset(derived_key, 0, hash-&gt;block_size);
+
+  if (key_length &gt; hash-&gt;block_size)
+    {
+      assert(hash-&gt;digest_size &lt;= hash-&gt;block_size);
+
+      /* Reduce key to the algorithm's hash size. Use the area pointed
+       * to by state for the temporary state. */
+      hash-&gt;init(state);
+      hash-&gt;update(state, key_length, key);
+      hash-&gt;digest(state, hash-&gt;digest_size, derived_key);
+    }
+  else
+    {
+      memcpy(derived_key, key, key_length);
+    }
+
+  hmac2_reinit_state(state, derived_key, hash, IPAD);
+}
+
+void
+hmac2_update(void *state,
+	     const struct nettle_hash *hash,
+	     size_t length, const uint8_t *data)
+{
+  hash-&gt;update(state, length, data);
+}
+
+void
+hmac2_digest(void *state, void *derived_key,
+	     const struct nettle_hash *hash,
+	     size_t length, uint8_t *dst)
+{
+  TMP_DECL(digest, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);
+  TMP_ALLOC(digest, hash-&gt;digest_size);
+
+  hash-&gt;digest(state, hash-&gt;digest_size, digest);
+
+  hmac2_reinit_state(state, derived_key, hash, OPAD);
+
+  hash-&gt;update(state, hash-&gt;digest_size, digest);
+  hash-&gt;digest(state, length, dst);
+
+  hmac2_reinit_state(state, derived_key, hash, IPAD);
+}
diff --git a/hmac.h b/hmac.h
index 40a8e77aab6d..29a2798ffc21 100644
--- a/hmac.h
+++ b/hmac.h
@@ -49,6 +49,9 @@ extern "C" {
 #define hmac_set_key nettle_hmac_set_key
 #define hmac_update nettle_hmac_update
 #define hmac_digest nettle_hmac_digest
+#define hmac2_set_key nettle_hmac2_set_key
+#define hmac2_update nettle_hmac2_update
+#define hmac2_digest nettle_hmac2_digest
 #define hmac_md5_set_key nettle_hmac_md5_set_key
 #define hmac_md5_update nettle_hmac_md5_update
 #define hmac_md5_digest nettle_hmac_md5_digest
@@ -87,6 +90,24 @@ hmac_digest(const void *outer, const void *inner, void *state,
 	    size_t length, uint8_t *digest);
 
 
+void
+hmac2_set_key(void *state, void *derived_key,
+	      const struct nettle_hash *hash,
+	      size_t length, const uint8_t *key);
+
+/* This function is not strictly needed, it's s just the same as the
+ * hash update or hmac2_update functions. */
+void
+hmac2_update(void *state,
+	     const struct nettle_hash *hash,
+	     size_t length, const uint8_t *data);
+
+void
+hmac2_digest(void *state, void *derived_key,
+	     const struct nettle_hash *hash,
+	     size_t length, uint8_t *digest);
+
+
 #define HMAC_CTX(type) \
 { type outer; type inner; type state; }
 
@@ -98,6 +119,17 @@ hmac_digest(const void *outer, const void *inner, void *state,
   hmac_digest( &amp;(ctx)-&gt;outer, &amp;(ctx)-&gt;inner, &amp;(ctx)-&gt;state,	\
                (hash), (length), (digest) )
 
+#define HMAC2_CTX(type, block_size) \
+{ type state; uint8_t key[block_size]; }
+
+#define HMAC2_SET_KEY(ctx, hash, length, key)			\
+  hmac2_set_key( &amp;(ctx)-&gt;state, &amp;(ctx)-&gt;key,			\
+                (hash), (length), (key) )
+
+#define HMAC2_DIGEST(ctx, hash, length, digest)			\
+  hmac2_digest( &amp;(ctx)-&gt;state, &amp;(ctx)-&gt;key,			\
+               (hash), (length), (digest) )
+
 /* HMAC using specific hash functions */
 
 /* hmac-md5 */
-- 
2.18.0


</body></email><email><emailId>20180724083804</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-07-24 08:38:04-0400</timestampReceived><subject>[PATCH 2/2] Update hash-specific HMAC functions to use new interface</subject><body>

Note, this does change ABI of these functions, as context size changes.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 hmac-md5.c       |  4 ++--
 hmac-ripemd160.c |  4 ++--
 hmac-sha1.c      |  4 ++--
 hmac-sha224.c    |  4 ++--
 hmac-sha256.c    |  4 ++--
 hmac-sha384.c    |  4 ++--
 hmac-sha512.c    |  4 ++--
 hmac.h           | 11 ++++++-----
 8 files changed, 20 insertions(+), 19 deletions(-)

diff --git a/hmac-md5.c b/hmac-md5.c
index a27e64f6f61b..01670af88f2d 100644
--- a/hmac-md5.c
+++ b/hmac-md5.c
@@ -41,7 +41,7 @@ void
 hmac_md5_set_key(struct hmac_md5_ctx *ctx,
 		 size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_md5, key_length, key);
+  HMAC2_SET_KEY(ctx, &amp;nettle_md5, key_length, key);
 }
 
 void
@@ -55,5 +55,5 @@ void
 hmac_md5_digest(struct hmac_md5_ctx *ctx,
 		size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_md5, length, digest);
+  HMAC2_DIGEST(ctx, &amp;nettle_md5, length, digest);
 }
diff --git a/hmac-ripemd160.c b/hmac-ripemd160.c
index 24e2cbe7a578..376d66822a6b 100644
--- a/hmac-ripemd160.c
+++ b/hmac-ripemd160.c
@@ -41,7 +41,7 @@ void
 hmac_ripemd160_set_key(struct hmac_ripemd160_ctx *ctx,
 		       size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_ripemd160, key_length, key);
+  HMAC2_SET_KEY(ctx, &amp;nettle_ripemd160, key_length, key);
 }
 
 void
@@ -55,5 +55,5 @@ void
 hmac_ripemd160_digest(struct hmac_ripemd160_ctx *ctx,
 		      size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_ripemd160, length, digest);
+  HMAC2_DIGEST(ctx, &amp;nettle_ripemd160, length, digest);
 }
diff --git a/hmac-sha1.c b/hmac-sha1.c
index 5e7188f92cf2..e696f608b25f 100644
--- a/hmac-sha1.c
+++ b/hmac-sha1.c
@@ -41,7 +41,7 @@ void
 hmac_sha1_set_key(struct hmac_sha1_ctx *ctx,
 		  size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_sha1, key_length, key);
+  HMAC2_SET_KEY(ctx, &amp;nettle_sha1, key_length, key);
 }
 
 void
@@ -55,5 +55,5 @@ void
 hmac_sha1_digest(struct hmac_sha1_ctx *ctx,
 		 size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_sha1, length, digest);
+  HMAC2_DIGEST(ctx, &amp;nettle_sha1, length, digest);
 }
diff --git a/hmac-sha224.c b/hmac-sha224.c
index c5bc8750a054..74ad061a6bd2 100644
--- a/hmac-sha224.c
+++ b/hmac-sha224.c
@@ -41,12 +41,12 @@ void
 hmac_sha224_set_key(struct hmac_sha224_ctx *ctx,
 		    size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_sha224, key_length, key);
+  HMAC2_SET_KEY(ctx, &amp;nettle_sha224, key_length, key);
 }
 
 void
 hmac_sha224_digest(struct hmac_sha224_ctx *ctx,
 		   size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_sha224, length, digest);
+  HMAC2_DIGEST(ctx, &amp;nettle_sha224, length, digest);
 }
diff --git a/hmac-sha256.c b/hmac-sha256.c
index af5cc0f1cbef..25e69deb44f8 100644
--- a/hmac-sha256.c
+++ b/hmac-sha256.c
@@ -41,7 +41,7 @@ void
 hmac_sha256_set_key(struct hmac_sha256_ctx *ctx,
 		    size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_sha256, key_length, key);
+  HMAC2_SET_KEY(ctx, &amp;nettle_sha256, key_length, key);
 }
 
 void
@@ -55,5 +55,5 @@ void
 hmac_sha256_digest(struct hmac_sha256_ctx *ctx,
 		   size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_sha256, length, digest);
+  HMAC2_DIGEST(ctx, &amp;nettle_sha256, length, digest);
 }
diff --git a/hmac-sha384.c b/hmac-sha384.c
index 30008b5f85c1..2ab8430e11e7 100644
--- a/hmac-sha384.c
+++ b/hmac-sha384.c
@@ -41,12 +41,12 @@ void
 hmac_sha384_set_key(struct hmac_sha512_ctx *ctx,
 		    size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_sha384, key_length, key);
+  HMAC2_SET_KEY(ctx, &amp;nettle_sha384, key_length, key);
 }
 
 void
 hmac_sha384_digest(struct hmac_sha512_ctx *ctx,
 		   size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_sha384, length, digest);
+  HMAC2_DIGEST(ctx, &amp;nettle_sha384, length, digest);
 }
diff --git a/hmac-sha512.c b/hmac-sha512.c
index de64637a8216..325b2d8a8642 100644
--- a/hmac-sha512.c
+++ b/hmac-sha512.c
@@ -41,7 +41,7 @@ void
 hmac_sha512_set_key(struct hmac_sha512_ctx *ctx,
 		    size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_sha512, key_length, key);
+  HMAC2_SET_KEY(ctx, &amp;nettle_sha512, key_length, key);
 }
 
 void
@@ -55,5 +55,5 @@ void
 hmac_sha512_digest(struct hmac_sha512_ctx *ctx,
 		   size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_sha512, length, digest);
+  HMAC2_DIGEST(ctx, &amp;nettle_sha512, length, digest);
 }
diff --git a/hmac.h b/hmac.h
index 29a2798ffc21..50daa401100b 100644
--- a/hmac.h
+++ b/hmac.h
@@ -77,6 +77,7 @@ hmac_set_key(void *outer, void *inner, void *state,
 	     const struct nettle_hash *hash,
 	     size_t length, const uint8_t *key);
 
+
 /* This function is not strictly needed, it's s just the same as the
  * hash update function. */
 void
@@ -133,7 +134,7 @@ hmac2_digest(void *state, void *derived_key,
 /* HMAC using specific hash functions */
 
 /* hmac-md5 */
-struct hmac_md5_ctx HMAC_CTX(struct md5_ctx);
+struct hmac_md5_ctx HMAC2_CTX(struct md5_ctx, MD5_BLOCK_SIZE);
 
 void
 hmac_md5_set_key(struct hmac_md5_ctx *ctx,
@@ -149,7 +150,7 @@ hmac_md5_digest(struct hmac_md5_ctx *ctx,
 
 
 /* hmac-ripemd160 */
-struct hmac_ripemd160_ctx HMAC_CTX(struct ripemd160_ctx);
+struct hmac_ripemd160_ctx HMAC2_CTX(struct ripemd160_ctx, RIPEMD160_BLOCK_SIZE);
 
 void
 hmac_ripemd160_set_key(struct hmac_ripemd160_ctx *ctx,
@@ -165,7 +166,7 @@ hmac_ripemd160_digest(struct hmac_ripemd160_ctx *ctx,
 
 
 /* hmac-sha1 */
-struct hmac_sha1_ctx HMAC_CTX(struct sha1_ctx);
+struct hmac_sha1_ctx HMAC2_CTX(struct sha1_ctx, SHA1_BLOCK_SIZE);
 
 void
 hmac_sha1_set_key(struct hmac_sha1_ctx *ctx,
@@ -180,7 +181,7 @@ hmac_sha1_digest(struct hmac_sha1_ctx *ctx,
 		 size_t length, uint8_t *digest);
 
 /* hmac-sha256 */
-struct hmac_sha256_ctx HMAC_CTX(struct sha256_ctx);
+struct hmac_sha256_ctx HMAC2_CTX(struct sha256_ctx, SHA256_BLOCK_SIZE);
 
 void
 hmac_sha256_set_key(struct hmac_sha256_ctx *ctx,
@@ -208,7 +209,7 @@ hmac_sha224_digest(struct hmac_sha224_ctx *ctx,
 		   size_t length, uint8_t *digest);
 
 /* hmac-sha512 */
-struct hmac_sha512_ctx HMAC_CTX(struct sha512_ctx);
+struct hmac_sha512_ctx HMAC2_CTX(struct sha512_ctx, SHA512_BLOCK_SIZE);
 
 void
 hmac_sha512_set_key(struct hmac_sha512_ctx *ctx,
-- 
2.18.0


</body></email><email><emailId>20180725094412</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-07-25 09:44:12-0400</timestampReceived><subject>[PATCH 0/2] Rework HMAC interface</subject><body>

On Wed, 2018-07-25 at 07:31 +0200, Niels Möller wrote:
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt; writes:
&gt; 
&gt; &gt; True. I'll look into adding HMAC functions to nettle-benchmark
&gt; &gt; then.
&gt; &gt; It would be interesting to compare performance.
&gt; 
&gt; That would be great. It's better to measure performance than to
&gt; speculate about it.
&gt; 
&gt; &gt; It might be worth moving both index and block out of 'state'
&gt; &gt; function
&gt; &gt; and then updating compress/MD_* macros to accept separate
&gt; &gt; 'compression state' and 'buffer state' structures. This might
&gt; &gt; result
&gt; &gt; in some code cleanups. I'll give this idea a thought.
&gt; 
&gt; That would be conceptually very nice. I suspect there might be some
&gt; complications from the count field (counter of compressed blocks),
&gt; which
&gt; most hash function have, but, e.g., sha3 doesn't. On the other hand,
&gt; hmac is designed to be used only with MD-style hash functions, so I'm
&gt; not sure hmac-sha3 is of any use.

It would be an overkill to have hmac-sha3, first because it is slow,
and secondly because it was designed to be a MAC as simple as SHA3(K,
msg).

regards,
Nikos



</body></email><email><emailId>20180725204145</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-07-25 20:41:45-0400</timestampReceived><subject>[RFC 1/4] hmac: provide alternative HMAC interface</subject><body>

Provide alternative HMAC interface, with context struct having just
derived key and single hash state instead of three hash states at once.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 hmac.c | 68 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 hmac.h | 34 ++++++++++++++++++++++++++++-
 2 files changed, 101 insertions(+), 1 deletion(-)

diff --git a/hmac.c b/hmac.c
index 6ac5e11a0686..44ac705856ad 100644
--- a/hmac.c
+++ b/hmac.c
@@ -115,3 +115,71 @@ hmac_digest(const void *outer, const void *inner, void *state,
 
   memcpy(state, inner, hash-&gt;context_size);
 }
+
+void
+hmac2_set_key(void *outer, void *inner, void *state,
+	      const struct nettle_hash *hash,
+	      size_t key_length, const uint8_t *key)
+{
+  TMP_DECL(pad, uint8_t, NETTLE_MAX_HASH_BLOCK_SIZE);
+  TMP_ALLOC(pad, hash-&gt;block_size);
+
+  hash-&gt;init(state);
+  if (key_length &gt; hash-&gt;block_size)
+    {
+      /* Reduce key to the algorithm's hash size. Use the area pointed
+       * to by state for the temporary state. */
+
+      TMP_DECL(digest, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);
+      TMP_ALLOC(digest, hash-&gt;digest_size);
+
+      hash-&gt;update(state, key_length, key);
+      hash-&gt;digest(state, hash-&gt;digest_size, digest);
+
+      key = digest;
+      key_length = hash-&gt;digest_size;
+    }
+
+  assert(key_length &lt;= hash-&gt;block_size);
+
+  memset(pad, OPAD, hash-&gt;block_size);
+  memxor(pad, key, key_length);
+
+  /* Init happened before */
+  hash-&gt;update(state, hash-&gt;block_size, pad);
+  memcpy(outer, state, hash-&gt;state_size);
+
+  memset(pad, IPAD, hash-&gt;block_size);
+  memxor(pad, key, key_length);
+
+  hash-&gt;init(state);
+  hash-&gt;update(state, hash-&gt;block_size, pad);
+
+  memcpy(inner, state, hash-&gt;state_size);
+}
+
+void
+hmac2_update(void *state,
+	     const struct nettle_hash *hash,
+	     size_t length, const uint8_t *data)
+{
+  hash-&gt;update(state, length, data);
+}
+
+void
+hmac2_digest(const void *outer, const void *inner, void *state,
+	     const struct nettle_hash *hash,
+	     size_t length, uint8_t *dst)
+{
+  TMP_DECL(digest, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);
+  TMP_ALLOC(digest, hash-&gt;digest_size);
+
+  hash-&gt;digest(state, hash-&gt;digest_size, digest);
+
+  memcpy(state, outer, hash-&gt;state_size);
+
+  hash-&gt;update(state, hash-&gt;digest_size, digest);
+  hash-&gt;digest(state, length, dst);
+
+  memcpy(state, inner, hash-&gt;state_size);
+}
diff --git a/hmac.h b/hmac.h
index 40a8e77aab6d..e6519023d259 100644
--- a/hmac.h
+++ b/hmac.h
@@ -49,6 +49,9 @@ extern "C" {
 #define hmac_set_key nettle_hmac_set_key
 #define hmac_update nettle_hmac_update
 #define hmac_digest nettle_hmac_digest
+#define hmac2_set_key nettle_hmac2_set_key
+#define hmac2_update nettle_hmac2_update
+#define hmac2_digest nettle_hmac2_digest
 #define hmac_md5_set_key nettle_hmac_md5_set_key
 #define hmac_md5_update nettle_hmac_md5_update
 #define hmac_md5_digest nettle_hmac_md5_digest
@@ -87,6 +90,24 @@ hmac_digest(const void *outer, const void *inner, void *state,
 	    size_t length, uint8_t *digest);
 
 
+void
+hmac2_set_key(void *outer, void *inner, void *state,
+	      const struct nettle_hash *hash,
+	      size_t length, const uint8_t *key);
+
+/* This function is not strictly needed, it's s just the same as the
+ * hash update or hmac2_update functions. */
+void
+hmac2_update(void *state,
+	     const struct nettle_hash *hash,
+	     size_t length, const uint8_t *data);
+
+void
+hmac2_digest(const void *outer, const void *inner, void *state,
+	     const struct nettle_hash *hash,
+	     size_t length, uint8_t *digest);
+
+
 #define HMAC_CTX(type) \
 { type outer; type inner; type state; }
 
@@ -98,10 +119,21 @@ hmac_digest(const void *outer, const void *inner, void *state,
   hmac_digest( &amp;(ctx)-&gt;outer, &amp;(ctx)-&gt;inner, &amp;(ctx)-&gt;state,	\
                (hash), (length), (digest) )
 
+#define HMAC2_CTX(ctx_type, type) \
+{ type outer; type inner; ctx_type state; }
+
+#define HMAC2_SET_KEY(ctx, hash, length, key)			\
+  hmac2_set_key( &amp;(ctx)-&gt;outer, &amp;(ctx)-&gt;inner, &amp;(ctx)-&gt;state,	\
+                (hash), (length), (key) )
+
+#define HMAC2_DIGEST(ctx, hash, length, digest)			\
+  hmac2_digest( &amp;(ctx)-&gt;outer, &amp;(ctx)-&gt;inner, &amp;(ctx)-&gt;state,	\
+               (hash), (length), (digest) )
+
 /* HMAC using specific hash functions */
 
 /* hmac-md5 */
-struct hmac_md5_ctx HMAC_CTX(struct md5_ctx);
+struct hmac_md5_ctx HMAC2_CTX(struct md5_ctx, struct md5_state);
 
 void
 hmac_md5_set_key(struct hmac_md5_ctx *ctx,
-- 
2.18.0


</body></email><email><emailId>20180725204146</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-07-25 20:41:46-0400</timestampReceived><subject>[RFC 2/4] meta: support splitting hash context into compress and block states</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 examples/nettle-openssl.c |  2 ++
 nettle-meta.h             | 13 +++++++++++++
 sha512-224-meta.c         |  1 +
 sha512-256-meta.c         |  1 +
 4 files changed, 17 insertions(+)

diff --git a/examples/nettle-openssl.c b/examples/nettle-openssl.c
index bb2e6627514a..fc48a10c40b3 100644
--- a/examples/nettle-openssl.c
+++ b/examples/nettle-openssl.c
@@ -413,6 +413,7 @@ openssl_md5_digest(void *ctx,
 const struct nettle_hash
 nettle_openssl_md5 = {
   "openssl md5", sizeof(SHA_CTX),
+  sizeof(SHA_CTX),
   SHA_DIGEST_LENGTH, SHA_CBLOCK,
   openssl_md5_init,
   openssl_md5_update,
@@ -449,6 +450,7 @@ openssl_sha1_digest(void *ctx,
 const struct nettle_hash
 nettle_openssl_sha1 = {
   "openssl sha1", sizeof(SHA_CTX),
+  sizeof(SHA_CTX),
   SHA_DIGEST_LENGTH, SHA_CBLOCK,
   openssl_sha1_init,
   openssl_sha1_update,
diff --git a/nettle-meta.h b/nettle-meta.h
index 8fe1cf84651b..366bd801b55c 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -98,6 +98,7 @@ struct nettle_hash
 
   /* Size of the context struct */
   unsigned context_size;
+  unsigned state_size;
 
   /* Size of digests */
   unsigned digest_size;
@@ -113,6 +114,7 @@ struct nettle_hash
 #define _NETTLE_HASH(name, NAME) {		\
  #name,						\
  sizeof(struct name##_ctx),			\
+ sizeof(struct name##_ctx),			\
  NAME##_DIGEST_SIZE,				\
  NAME##_BLOCK_SIZE,				\
  (nettle_hash_init_func *) name##_init,		\
@@ -120,6 +122,17 @@ struct nettle_hash
  (nettle_hash_digest_func *) name##_digest	\
 } 
 
+#define _NETTLE_HASH_STATE(name, NAME) {	\
+ #name,						\
+ sizeof(struct name##_ctx),			\
+ sizeof(struct name##_state),			\
+ NAME##_DIGEST_SIZE,				\
+ NAME##_BLOCK_SIZE,				\
+ (nettle_hash_init_func *) name##_init,		\
+ (nettle_hash_update_func *) name##_update,	\
+ (nettle_hash_digest_func *) name##_digest	\
+}
+
 /* null-terminated list of digests implemented by this version of nettle */
 const struct nettle_hash * const *
 #ifdef __GNUC__
diff --git a/sha512-224-meta.c b/sha512-224-meta.c
index 24c42bfc23d9..c134ead0cedd 100644
--- a/sha512-224-meta.c
+++ b/sha512-224-meta.c
@@ -40,6 +40,7 @@
 const struct nettle_hash nettle_sha512_224 =
   {
     "sha512-224", sizeof(struct sha512_ctx),
+    sizeof(struct sha512_ctx),
     SHA512_224_DIGEST_SIZE,
     SHA512_224_BLOCK_SIZE,
     (nettle_hash_init_func *) sha512_224_init,
diff --git a/sha512-256-meta.c b/sha512-256-meta.c
index 37d17c351878..458aa53ae47b 100644
--- a/sha512-256-meta.c
+++ b/sha512-256-meta.c
@@ -40,6 +40,7 @@
 const struct nettle_hash nettle_sha512_256 =
   {
     "sha512-256", sizeof(struct sha512_ctx),
+    sizeof(struct sha512_ctx),
     SHA512_256_DIGEST_SIZE,
     SHA512_256_BLOCK_SIZE,
     (nettle_hash_init_func *) sha512_256_init,
-- 
2.18.0


</body></email><email><emailId>20180725204148</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-07-25 20:41:48-0400</timestampReceived><subject>[RFC 4/4] hmac-md5: switch to new HMAC interface</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 hmac-md5.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/hmac-md5.c b/hmac-md5.c
index a27e64f6f61b..01670af88f2d 100644
--- a/hmac-md5.c
+++ b/hmac-md5.c
@@ -41,7 +41,7 @@ void
 hmac_md5_set_key(struct hmac_md5_ctx *ctx,
 		 size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_md5, key_length, key);
+  HMAC2_SET_KEY(ctx, &amp;nettle_md5, key_length, key);
 }
 
 void
@@ -55,5 +55,5 @@ void
 hmac_md5_digest(struct hmac_md5_ctx *ctx,
 		size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_md5, length, digest);
+  HMAC2_DIGEST(ctx, &amp;nettle_md5, length, digest);
 }
-- 
2.18.0


</body></email><email><emailId>20180730163655</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-07-30 16:36:55-0400</timestampReceived><subject>[PATCH] Add benchmarking for HMAC functions</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt; writes:

&gt; In preparation of changing internal HMAC interface add benchmarking for
&gt; HMAC functions.
&gt;
&gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;

Thanks, applied.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180730171702</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-07-30 17:17:02-0400</timestampReceived><subject>[RFC 3/4] md5: split context into compress and block states</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt; writes:

&gt; --- a/md5.c
&gt; +++ b/md5.c
&gt; @@ -56,19 +56,19 @@ md5_init(struct md5_ctx *ctx)
&gt;        0x98badcfe,
&gt;        0x10325476,
&gt;      };
&gt; -  memcpy(ctx-&gt;state, iv, sizeof(ctx-&gt;state));
&gt; -  ctx-&gt;count = 0;
&gt; +  memcpy(ctx-&gt;state.state, iv, sizeof(ctx-&gt;state.state));
&gt; +  ctx-&gt;state.count = 0;
&gt;    ctx-&gt;index = 0;
&gt;  }

Could have the same memcpy handle all of state.

&gt; --- a/md5.h
&gt; +++ b/md5.h
&gt; @@ -53,10 +53,15 @@ extern "C" {
&gt;  /* Digest is kept internally as 4 32-bit words. */
&gt;  #define _MD5_DIGEST_LENGTH 4
&gt;  
&gt; -struct md5_ctx
&gt; +struct md5_state
&gt;  {
&gt;    uint32_t state[_MD5_DIGEST_LENGTH];
&gt;    uint64_t count;               /* Block count */
&gt; +};
&gt; +
&gt; +struct md5_ctx
&gt; +{
&gt; +  struct md5_state state;
&gt;    uint8_t block[MD5_BLOCK_SIZE]; /* Block buffer */
&gt;    unsigned index;               /* Into buffer */
&gt;  };

When reworking these structs, I think we should generally have index
before block, since index has a larger required alignment. Even if it
doesn't matter in this particular case, with MD5_BLOCK_SIZE == 64.

I wonder if we can find some better naming. "state.state" isn't so
pretty, and I think the conventional terminology would be to refer to
the 4 32-bit words as the md5 "state", not including the block count.
What we're trying to capture actually is somewhat hmac-specific.

It's the part that needs to be copied to the start at an md5_ctx to
reset it to some block boundary, and the reason we need a named type
(rather than offsetof(struct md5_ctx, block), is that code needs to
allocate it. Perhaps

  struct md5_init_state 
  {
    uint32_t state[_MD5_DIGEST_LENGTH];
    uint64_t count;               /* Block count */
    unsigned index;
  };

or struct md5_internal_ctx_no_buffer or so.

Then both plain md5 reset and md5-hmac could use a single memcpy. And we
could use some internal variant of md5_digest to avoid the redundant
memcpy done by md5_digest (in your patch set, the hmac code depends on
md5_digest resetting the index field, while it overwrites the rest of
the state).

I'm starting to think that it probably was a mistake to advertise and
document the internal hmac_set_key, hmac_update and hmac_digest methods.
Maybe we can deprecate them (without immediately breaking them); I find
no usage on codesearch.debian.net. We'de get more flexibility if we
could implement hmac_md5_* without going via struct nettle_hash
nettle_md5.

I think it would make sense to start with reordering fields in the
current context structs.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180813093001</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-08-13 09:30:01-0400</timestampReceived><subject>Leading underscores (was: Re: Deprecation)</subject><body>

Tim Rühsen &lt;tim.ruehsen at gmx.de&gt; writes:

&gt; #defines should not start with an underscore. C standards say this is
&gt; reserved (for system headers !?) and some static analyzers complain
&gt; about it.

Note that Nettle has violated this rule since the very beginnings. E.g,

#define _MD5_DIGEST_LENGTH 4

has been in md5.h since the initial commit (back in April 2001, around
midnight). I haven't seen any reports about this causing problems.

I agree it's not quite right, and maybe we should clean this up at some
point, replacing the leading underscore by nettle_internal_ (or maybe
trailing underscore or nettle__ (double underscore). But not now.

Which static analyzers complain?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180713080820</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-07-13 08:08:20-0400</timestampReceived><subject>Static analyzer (was: Re: nettle symbols: improve map files)</subject><body>

Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:

&gt; It seems
&gt; that static analyzer in F28 finds few issues:
&gt; https://gitlab.com/gnutls/nettle/-/jobs/81332560 (click on browse for
&gt; artifacts)
&gt; 
&gt; They are mem leaks on examples and one which relates to gmp-mini.

I fixed the leaks. Remaining issues listed on
https://gnutls.gitlab.io/-/nettle/-/jobs/81425078/artifacts/scan-build-lib/2018-07-12-205643-1877-1/index.html
 (but will disappear in a few days; should we increase the expire_in
parameter in .gitlab-cy.yml?)..

I've had a closer look now, and I think both are of similar type. In
eratosthenes.c, we have a bitmap initialized with

  static void
  vector_init(unsigned long *vector, unsigned long size)
  {
    unsigned long end = (size + BITS_PER_LONG - 1) / BITS_PER_LONG;
    unsigned long i;
  
    for (i = 0; i &lt; end; i++)
      vector[i] = ~0UL;
  }

and later updated with the loop

  static void
  vector_clear_bits (unsigned long *vector, unsigned long step,
                     unsigned long start, unsigned long size)
  {
    unsigned long bit;
  
    for (bit = start; bit &lt; size; bit += step)
      {
        unsigned long i = bit / BITS_PER_LONG;
        unsigned long mask = 1L &lt;&lt; (bit % BITS_PER_LONG);
  
        vector[i] &amp;= ~mask;
      }
  }

The value of the size argument is the same in both places (named
"sieve_nbits" in the calling code). The static analyzer complains that
vector[i] is not properly initialized. And it's kind-of right: In case
(size + BITS_PER_LONG - 1) wraps around, the bitmap will not be
initialized properly. But I would classify it as an out-of-bounds
access, not use of uninitialized data.

I could add an overflow check in the vector_alloc function, which uses
the same expression, and where it might make sense. I wonder of that
would make the analyzer happy.

In eccdata.c, the allocation function is ecc_alloc, which alllocates an
array and loops over it to initialize all elements. The complant is in
ecc_pippenger_precompute, which allocates an array with

  ecc-&gt;table = ecc_alloc (ecc-&gt;table_size);

and the complaint is the assignment of element 1,

  ecc_set (&amp;ecc-&gt;table[1], &amp;ecc-&gt;g);

where ecc-&gt;table[1].x-&gt;_mp_alloc is claimed to be uninitialized.

This also is kind-of right; if the program is run with strange
parameters, we might get ecc-&gt;table_size &lt; 2 (and again, in that case,
it's an out of bounds access).

I don't have that much experience with the static analyzer. Should I
just add error handling for the corner cases, and see if that solves the
problem?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20180713181933</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-07-13 18:19:33-0400</timestampReceived><subject>Static analyzer</subject><body>

Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:

&gt; An assert() should be sufficient to inform it of the constraints.

I've added two asserts for the eratosthenes.c warning, we'lll see if
that helps (only vector_alloc wasn't enough). For the other case,
eccdata.c, I think some additional checks of the input arguments would
be appropriate, in addition to an assert.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180713192626</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-07-13 19:26:26-0400</timestampReceived><subject>Static analyzer</subject><body>

nisse at lysator.liu.se (Niels Möller) writes:

&gt; Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:
&gt; 
&gt; &gt; An assert() should be sufficient to inform it of the constraints.
&gt; 
&gt; I've added two asserts for the eratosthenes.c warning, we'lll see if
&gt; that helps (only vector_alloc wasn't enough).

Another analysis run has completed, and it still complains. See
https://gnutls.gitlab.io/-/nettle/-/jobs/81674466/artifacts/scan-build-lib/2018-07-13-184526-1877-1/report-535c8d.html


Any other suggestions?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20180715180220</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2018-07-15 18:02:20-0400</timestampReceived><subject>Static analyzer</subject><body>

On Fri, Jul 13, 2018 at 9:26 PM, Niels Möller &lt;nisse at lysator.liu.se&gt; wrote:
&gt; nisse at lysator.liu.se (Niels Möller) writes:
&gt; 
&gt; &gt; Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:
&gt; &gt; 
&gt; &gt; &gt; An assert() should be sufficient to inform it of the constraints.
&gt; &gt; 
&gt; &gt; I've added two asserts for the eratosthenes.c warning, we'lll see if
&gt; &gt; that helps (only vector_alloc wasn't enough).
&gt; 
&gt; Another analysis run has completed, and it still complains. See
&gt; https://gnutls.gitlab.io/-/nettle/-/jobs/81674466/artifacts/scan-build-lib/2018-07-13-184526-1877-1/report-535c8d.html
&gt;  
&gt; Any other suggestions?

Given that it is only an example maybe use #ifndef __clang_analyzer__
in the whole file?

regards,
Nikos


</body></email><email><emailId>20180724083802</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-07-24 08:38:02-0400</timestampReceived><subject>[PATCH 0/2] Rework HMAC interface</subject><body>

Hello colleagues,


I gave a little thought to Niels' idea:

5. Revamp hmac and underlying hash functions with a separate state
   struct. Probably low priority, but it is a bit silly that, e.g.,
   hmac_sha512_ctx includes three 128-byte large block buffers.

I've implemented new approach using hmac2 prefix, but if you like this
approach I can switch hmac2 prefix to just hmac and drop older API.

-- 
With best wishes
Dmitry



</body></email><email><emailId>20180724124017</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-07-24 12:40:17-0400</timestampReceived><subject>[PATCH 0/2] Rework HMAC interface</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt; writes:

&gt; Hello colleagues,
&gt;
&gt;
&gt; I gave a little thought to Niels' idea:
&gt;
&gt; 5. Revamp hmac and underlying hash functions with a separate state
&gt;    struct. Probably low priority, but it is a bit silly that, e.g.,
&gt;    hmac_sha512_ctx includes three 128-byte large block buffers.
&gt;
&gt; I've implemented new approach using hmac2 prefix, but if you like this
&gt; approach I can switch hmac2 prefix to just hmac and drop older API.

Nice!

&gt; diff --git a/hmac.c b/hmac.c
&gt; index 6ac5e11a0686..6d57f8c9197c 100644
&gt; --- a/hmac.c
&gt; +++ b/hmac.c
&gt; @@ -115,3 +115,69 @@ hmac_digest(const void *outer, const void *inner, void *state,
&gt;  
&gt;    memcpy(state, inner, hash-&gt;context_size);
&gt;  }
&gt; +
&gt; +static void
&gt; +hmac2_reinit_state(void *state, void *derived_key,
&gt; +		   const struct nettle_hash *hash,
&gt; +		   uint8_t padc)
&gt; +{
&gt; +  TMP_DECL(pad, uint8_t, NETTLE_MAX_HASH_BLOCK_SIZE);
&gt; +  TMP_ALLOC(pad, hash-&gt;block_size);
&gt; +
&gt; +  memset(pad, padc, hash-&gt;block_size);
&gt; +  memxor(pad, derived_key, hash-&gt;block_size);
&gt; +
&gt; +  hash-&gt;init(state);
&gt; +  hash-&gt;update(state, hash-&gt;block_size, pad);
&gt; +}

This reinit function is used instead of a plain memcpy (of the complete
ctx, including buffer). That's less efficient, since we'll get more
calls to the heavy compression function for each message.

In principle, it should be possible to replace derived_key with the
relevant part of hash context, except the buffer, and memcpy that. If
it's possible to arrange it in that way without things getting too ugly,
I think that might be worth the effort. 

A typical context struct looks like

  struct sha256_ctx
  {
    uint32_t state[_SHA256_DIGEST_LENGTH];    /* State variables */
    uint64_t count;                           /* 64-bit block count */
    uint8_t block[SHA256_BLOCK_SIZE];          /* SHA256 data buffer */
    unsigned int index;                       /* index into buffer */
  };

Here, we should first reorder fields so that the block buffer is last,

  struct sha256_ctx
  {
    uint32_t state[_SHA256_DIGEST_LENGTH];    /* State variables */
    uint64_t count;                           /* 64-bit block count */
    unsigned int index;                       /* index into buffer */
    uint8_t block[SHA256_BLOCK_SIZE];          /* SHA256 data buffer */
  };

(and we can do that, since we're planning an abi break).

Then at the time reinit is called, we would memcpy the first three
fields. state here depends on the key, while count will be always 1 and
index always zero (but it's likely not a useful optimization to handle
the constat part separately). To make reasonably clean, we may have to
take out the non-block fields to a separate struct, say

  struct sha256_state
  {
    uint32_t state[_SHA256_DIGEST_LENGTH];    /* State variables */
    uint64_t count;                           /* 64-bit block count */
    unsigned int index;                       /* index into buffer */
  };

  struct sha256_ctx
  {
    struct sha256_state state;
    uint8_t block[SHA256_BLOCK_SIZE];          /* SHA256 data buffer */
  };

and let

  struct hmac_sha256 
  {
    struct sha256_state inner;
    struct sha256_state outer;
    struct sha256_ctx hash_ctx;  /* Initialized from key, updated as the
                                    message is processed */
  };

We'd need to add a state_size field to struct nettle_hash, and then
reinit would be 

  memcpy(&amp;hmac_ctx-&gt;hash_ctx, hmac_ctx-&gt;inner /* or outer */, hash-&gt;state_size);

And the nice thing is that any hash function not matching this internal
structure can let state_size == context_size, and things will keep
working.

What do you think?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180724205245</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-07-24 20:52:45-0400</timestampReceived><subject>[PATCH 0/2] Rework HMAC interface</subject><body>

Hello,

вт, 24 июл. 2018 г. в 15:40, Niels Möller &lt;nisse at lysator.liu.se&gt;:
&gt; This reinit function is used instead of a plain memcpy (of the complete
&gt; ctx, including buffer). That's less efficient, since we'll get more
&gt; calls to the heavy compression function for each message.

True. I'll look into adding HMAC functions to nettle-benchmark then.
It would be interesting to compare performance.

&gt;   struct sha256_state
&gt;   {
&gt;     uint32_t state[_SHA256_DIGEST_LENGTH];    /* State variables */
&gt;     uint64_t count;                           /* 64-bit block count */
&gt;     unsigned int index;                       /* index into buffer */
&gt;   };
&gt;
&gt;   struct sha256_ctx
&gt;   {
&gt;     struct sha256_state state;
&gt;     uint8_t block[SHA256_BLOCK_SIZE];          /* SHA256 data buffer */
&gt;   };

It might be worth moving both index and block out of 'state' function
and then updating compress/MD_* macros to accept separate
'compression state' and 'buffer state' structures. This might result
in some code cleanups. I'll give this idea a thought.


&gt; and let
&gt;
&gt;   struct hmac_sha256
&gt;   {
&gt;     struct sha256_state inner;
&gt;     struct sha256_state outer;
&gt;     struct sha256_ctx hash_ctx;  /* Initialized from key, updated as the
&gt;                                     message is processed */
&gt;   };
&gt;
&gt; We'd need to add a state_size field to struct nettle_hash, and then
&gt; reinit would be
&gt;
&gt;   memcpy(&amp;hmac_ctx-&gt;hash_ctx, hmac_ctx-&gt;inner /* or outer */, hash-&gt;state_size);
&gt;
&gt; And the nice thing is that any hash function not matching this internal
&gt; structure can let state_size == context_size, and things will keep
&gt; working.
&gt;
&gt; What do you think?

What about having following functions:

_FOO_init(state);
FOO_init(ctx);
_FOO_compress(state, block[])
FOO_update(ctx, length, data);
_FOO_digest(state, buffer_state);
FOO_digest(ctx);

Users will call typical FOO_* functions, while HMAC code can call
internal _FOO_* functions.

-- 
With best wishes
Dmitry

</body></email><email><emailId>20180725053154</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-07-25 05:31:54-0400</timestampReceived><subject>[PATCH 0/2] Rework HMAC interface</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt; writes:

&gt; True. I'll look into adding HMAC functions to nettle-benchmark then.
&gt; It would be interesting to compare performance.

That would be great. It's better to measure performance than to
speculate about it.

&gt; It might be worth moving both index and block out of 'state' function
&gt; and then updating compress/MD_* macros to accept separate
&gt; 'compression state' and 'buffer state' structures. This might result
&gt; in some code cleanups. I'll give this idea a thought.

That would be conceptually very nice. I suspect there might be some
complications from the count field (counter of compressed blocks), which
most hash function have, but, e.g., sha3 doesn't. On the other hand,
hmac is designed to be used only with MD-style hash functions, so I'm
not sure hmac-sha3 is of any use.

&gt; What about having following functions:
&gt;
&gt; _FOO_init(state);
&gt; FOO_init(ctx);
&gt; _FOO_compress(state, block[])
&gt; FOO_update(ctx, length, data);
&gt; _FOO_digest(state, buffer_state);
&gt; FOO_digest(ctx);
&gt;
&gt; Users will call typical FOO_* functions, while HMAC code can call
&gt; internal _FOO_* functions.

What would _FOO_digest be used for? Also note that all functions needed
by hmac would need to be exposed in struct nettle_hash.

We already have a couple of FOO_compress functions, mainly because
those functions are candidates for assembly implementation.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180614105254</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-06-14 10:52:54-0400</timestampReceived><subject>[Dominyk Tiller] Fwd: Xcode/CLT 10+ Patch</subject><body>


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20180725115321</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-07-25 11:53:21-0400</timestampReceived><subject>[PATCH] Add benchmarking for HMAC functions</subject><body>

In preparation of changing internal HMAC interface add benchmarking for
HMAC functions.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 examples/nettle-benchmark.c | 154 ++++++++++++++++++++++++++++++++++++
 1 file changed, 154 insertions(+)

diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index 5a88e72dd678..101ba7d4abcc 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -67,6 +67,7 @@
 #include "umac.h"
 #include "cmac.h"
 #include "poly1305.h"
+#include "hmac.h"
 
 #include "nettle-meta.h"
 #include "nettle-internal.h"
@@ -476,6 +477,147 @@ time_poly1305_aes(void)
 	  time_function(bench_hash, &amp;info));
 }
 
+struct bench_hmac_info
+{
+  void *ctx;
+  nettle_hash_update_func *update;
+  nettle_hash_digest_func *digest;
+  size_t length;
+  size_t digest_length;
+  const uint8_t *data;
+};
+
+static void
+bench_hmac(void *arg)
+{
+  struct bench_hmac_info *info = arg;
+  uint8_t digest[NETTLE_MAX_HASH_DIGEST_SIZE];
+  size_t pos, length;
+
+  length = info-&gt;length;
+  for (pos = 0; pos &lt; BENCH_BLOCK; pos += length)
+    {
+      size_t single = pos + length &lt; BENCH_BLOCK ?
+			length :
+			BENCH_BLOCK - pos;
+      info-&gt;update(info-&gt;ctx, single, info-&gt;data + pos);
+      info-&gt;digest(info-&gt;ctx, info-&gt;digest_length, digest);
+    }
+}
+
+static const struct
+{
+  size_t length;
+  const char *msg;
+} hmac_tests[] = {
+  { 64, "64 bytes" },
+  { 256, "256 bytes" },
+  { 1024, "1024 bytes" },
+  { 4096, "4096 bytes" },
+  { BENCH_BLOCK, "single msg" },
+  { 0, NULL },
+};
+
+static void
+time_hmac_md5(void)
+{
+  static uint8_t data[BENCH_BLOCK];
+  struct bench_hmac_info info;
+  struct hmac_md5_ctx md5_ctx;
+  unsigned int pos;
+
+  init_data(data);
+  info.data = data;
+
+  hmac_md5_set_key(&amp;md5_ctx, MD5_BLOCK_SIZE, data);
+  info.ctx = &amp;md5_ctx;
+  info.update = (nettle_hash_update_func *) hmac_md5_update;
+  info.digest = (nettle_hash_digest_func *) hmac_md5_digest;
+  info.digest_length = MD5_DIGEST_SIZE;
+
+  for (pos = 0; hmac_tests[pos].length != 0; pos++)
+    {
+      info.length = hmac_tests[pos].length;
+      display("hmac-md5", hmac_tests[pos].msg, MD5_BLOCK_SIZE,
+	      time_function(bench_hmac, &amp;info));
+    }
+}
+
+static void
+time_hmac_sha1(void)
+{
+  static uint8_t data[BENCH_BLOCK];
+  struct bench_hmac_info info;
+  struct hmac_sha1_ctx sha1_ctx;
+  unsigned int pos;
+
+  init_data(data);
+  info.data = data;
+
+  hmac_sha1_set_key(&amp;sha1_ctx, SHA1_BLOCK_SIZE, data);
+  info.ctx = &amp;sha1_ctx;
+  info.update = (nettle_hash_update_func *) hmac_sha1_update;
+  info.digest = (nettle_hash_digest_func *) hmac_sha1_digest;
+  info.digest_length = SHA1_DIGEST_SIZE;
+
+  for (pos = 0; hmac_tests[pos].length != 0; pos++)
+    {
+      info.length = hmac_tests[pos].length;
+      display("hmac-sha1", hmac_tests[pos].msg, SHA1_BLOCK_SIZE,
+	      time_function(bench_hmac, &amp;info));
+    }
+}
+
+static void
+time_hmac_sha256(void)
+{
+  static uint8_t data[BENCH_BLOCK];
+  struct bench_hmac_info info;
+  struct hmac_sha256_ctx sha256_ctx;
+  unsigned int pos;
+
+  init_data(data);
+  info.data = data;
+
+  hmac_sha256_set_key(&amp;sha256_ctx, SHA256_BLOCK_SIZE, data);
+  info.ctx = &amp;sha256_ctx;
+  info.update = (nettle_hash_update_func *) hmac_sha256_update;
+  info.digest = (nettle_hash_digest_func *) hmac_sha256_digest;
+  info.digest_length = SHA256_DIGEST_SIZE;
+
+  for (pos = 0; hmac_tests[pos].length != 0; pos++)
+    {
+      info.length = hmac_tests[pos].length;
+      display("hmac-sha256", hmac_tests[pos].msg, SHA256_BLOCK_SIZE,
+	      time_function(bench_hmac, &amp;info));
+    }
+}
+
+static void
+time_hmac_sha512(void)
+{
+  static uint8_t data[BENCH_BLOCK];
+  struct bench_hmac_info info;
+  struct hmac_sha512_ctx sha512_ctx;
+  unsigned int pos;
+
+  init_data(data);
+  info.data = data;
+
+  hmac_sha512_set_key(&amp;sha512_ctx, SHA512_BLOCK_SIZE, data);
+  info.ctx = &amp;sha512_ctx;
+  info.update = (nettle_hash_update_func *) hmac_sha512_update;
+  info.digest = (nettle_hash_digest_func *) hmac_sha512_digest;
+  info.digest_length = SHA512_DIGEST_SIZE;
+
+  for (pos = 0; hmac_tests[pos].length != 0; pos++)
+    {
+      info.length = hmac_tests[pos].length;
+      display("hmac-sha512", hmac_tests[pos].msg, SHA512_BLOCK_SIZE,
+	      time_function(bench_hmac, &amp;info));
+    }
+}
+
 static int
 prefix_p(const char *prefix, const char *s)
 {
@@ -883,6 +1025,18 @@ main(int argc, char **argv)
 	if (!alg || strstr(aeads[i]-&gt;name, alg))
 	  time_aead(aeads[i]);
 
+      if (!alg || strstr ("hmac-md5", alg))
+	time_hmac_md5();
+
+      if (!alg || strstr ("hmac-sha1", alg))
+	time_hmac_sha1();
+
+      if (!alg || strstr ("hmac-sha256", alg))
+	time_hmac_sha256();
+
+      if (!alg || strstr ("hmac-sha512", alg))
+	time_hmac_sha512();
+
       optind++;
     } while (alg &amp;&amp; argv[optind]);
 
-- 
2.18.0


</body></email><email><emailId>20180725204147</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-07-25 20:41:47-0400</timestampReceived><subject>[RFC 3/4] md5: split context into compress and block states</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 md5-meta.c |  2 +-
 md5.c      | 14 +++++++-------
 md5.h      |  7 ++++++-
 3 files changed, 14 insertions(+), 9 deletions(-)

diff --git a/md5-meta.c b/md5-meta.c
index e4013edfd233..9d17be000f0a 100644
--- a/md5-meta.c
+++ b/md5-meta.c
@@ -38,4 +38,4 @@
 #include "md5.h"
 
 const struct nettle_hash nettle_md5
-= _NETTLE_HASH(md5, MD5);
+= _NETTLE_HASH_STATE(md5, MD5);
diff --git a/md5.c b/md5.c
index cc009b4a8dc8..4ffa064bacc5 100644
--- a/md5.c
+++ b/md5.c
@@ -56,19 +56,19 @@ md5_init(struct md5_ctx *ctx)
       0x98badcfe,
       0x10325476,
     };
-  memcpy(ctx-&gt;state, iv, sizeof(ctx-&gt;state));
-  ctx-&gt;count = 0;
+  memcpy(ctx-&gt;state.state, iv, sizeof(ctx-&gt;state.state));
+  ctx-&gt;state.count = 0;
   ctx-&gt;index = 0;
 }
 
-#define COMPRESS(ctx, data) (nettle_md5_compress((ctx)-&gt;state, (data)))
+#define COMPRESS(ctx, data) (nettle_md5_compress((ctx)-&gt;state.state, (data)))
 
 void
 md5_update(struct md5_ctx *ctx,
 	   size_t length,
 	   const uint8_t *data)
 {
-  MD_UPDATE(ctx, length, data, COMPRESS, ctx-&gt;count++);
+  MD_UPDATE(ctx, length, data, COMPRESS, ctx-&gt;state.count++);
 }
 
 void
@@ -83,11 +83,11 @@ md5_digest(struct md5_ctx *ctx,
   MD_PAD(ctx, 8, COMPRESS);
 
   /* There are 512 = 2^9 bits in one block */
-  bit_count = (ctx-&gt;count &lt;&lt; 9) | (ctx-&gt;index &lt;&lt; 3);
+  bit_count = (ctx-&gt;state.count &lt;&lt; 9) | (ctx-&gt;index &lt;&lt; 3);
 
   LE_WRITE_UINT64(ctx-&gt;block + (MD5_BLOCK_SIZE - 8), bit_count);
-  nettle_md5_compress(ctx-&gt;state, ctx-&gt;block);
+  nettle_md5_compress(ctx-&gt;state.state, ctx-&gt;block);
 
-  _nettle_write_le32(length, digest, ctx-&gt;state);
+  _nettle_write_le32(length, digest, ctx-&gt;state.state);
   md5_init(ctx);
 }
diff --git a/md5.h b/md5.h
index 6feb39cc380b..258415479354 100644
--- a/md5.h
+++ b/md5.h
@@ -53,10 +53,15 @@ extern "C" {
 /* Digest is kept internally as 4 32-bit words. */
 #define _MD5_DIGEST_LENGTH 4
 
-struct md5_ctx
+struct md5_state
 {
   uint32_t state[_MD5_DIGEST_LENGTH];
   uint64_t count;               /* Block count */
+};
+
+struct md5_ctx
+{
+  struct md5_state state;
   uint8_t block[MD5_BLOCK_SIZE]; /* Block buffer */
   unsigned index;               /* Into buffer */
 };
-- 
2.18.0


</body></email><email><emailId>20180617212802</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-06-17 21:28:02-0400</timestampReceived><subject>[PATCH] Fix quoting in autoconf ifunc test</subject><body>

вс, 17 июн. 2018 г. в 20:32, Niels Möller &lt;nisse at lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt; writes:
&gt;
&gt; &gt; * aclocal.m4 (NETTLE_CHECK_IFUNC): fix quoting so that
&gt; &gt;   AC_LINK_IFELSE/AC_TRY_LINK is defined outside of this test.
&gt;
&gt; Thanks, applied. What concrete errors did the incorrect quoting cause?

Failure of the test on second (and following) configure runs if config.cache
was enabled:

configure: loading cache config.cache
checking build system type... (cached) x86_64-unknown-linux-gnu
checking host system type... (cached) x86_64-unknown-linux-gnu
[skipped]
checking whether g++ accepts -g... (cached) yes
checking if LD -Wl,--version-script works... ../nettle/configure: line
4023: ac_fn_c_try_link: command not found
../nettle/configure: line 4051: ac_fn_c_try_link: command not found
no

-- 
With best wishes
Dmitry

</body></email><email><emailId>20180617213800</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-06-17 21:38:00-0400</timestampReceived><subject>[PATCH] Add support for reading/writing integers in Little Endian format</subject><body>

Hello,

вс, 17 июн. 2018 г. в 20:47, Niels Möller &lt;nisse at lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt; writes:
&gt;
&gt; &gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
&gt; &gt; ---
&gt; &gt;  bignum.c                | 35 +++++++++++++++++++++++++++++++++++
&gt; &gt;  bignum.h                | 17 +++++++++++++++++
&gt; &gt;  testsuite/bignum-test.c | 29 +++++++++++++++++++++++++++++
&gt; &gt;  3 files changed, 81 insertions(+)
&gt;
&gt; Hmm, I'm not sure we should add more gmp wrappers to bignum.[hc]. The
&gt; code dates back to before Nettle was split out of LSH, as can be seen in
&gt; the _s functions which do formatting according to the ssh binary format.
&gt;
&gt; We also have some related functions in gmp-glue.c (for internal
&gt; use only),
&gt;
&gt;   mpn_set_base256_le
&gt;   mpn_get_base256_le
&gt;
&gt; but those work with the mpn layer, which lacks the general export/import
&gt; functions.
&gt;
&gt; What use for these functions do you have in mind? Application use, or
&gt; some code you'd like to add to Nettle?

Unfortunately Russian crypto standards prefer to use LE representation
for MPIs, so I'd like to use native Nettle functions to import/export LE
values (to make GnuTLS code more or less symmetrical). Basically I'm
using those functions through GnuTLS'es lib/nettle/mpi.c wrappers.

-- 
With best wishes
Dmitry

</body></email><email><emailId>20180618224021</emailId><senderName>Dominyk Tiller</senderName><senderEmail>dominyktiller@gmail.com</senderEmail><timestampReceived>2018-06-18 22:40:21-0400</timestampReceived><subject>Xcode/CLT 10+ Patch</subject><body>

Hi Niels,

Thanks for folding the fix in, I appreciate that.

Apologies for the confusion on the context. CLT is indeed a reference to
Apple's "Command Line Tools" package. As you're likely aware Apple offer
both Xcode (which is a full IDE) and the CLT package (which is more or
less the absolute minimum set of tools required to do development work
on macOS).

Both Xcode &amp; the CLT package provide LLVM, which is where Apple has
shipped a stack checking addition which embeds the new symbol into most
binaries &amp; libraries. If you'd prefer to reference the LLVM/Clang
version rather than the Xcode/CLT version, the string for that is
currently: Apple LLVM version 10.0.0 (clang-1000.10.25.5). That string
will change over time, but could safely be summarised as Apple LLVM
version 10+ or such.

A minor complication trying to describe the new feature in the patch is
that Apple have been trying to upstream the change to LLVM for quite
some time (https://reviews.llvm.org/D40864#1100905) but it hasn't yet
been merged there. Eventually though it seems likely that the feature
will be supported in both "Apple LLVM" &amp; LLVM itself, at which point the
description I added to `symbols-test` will need updating; I'll do my
best to spot if/when that happens.

I think I've managed to add a fair dose of complication to the
explanation here but hopefully the context is somewhat clearer. Let me
know if not.

Dominyk
===
Sent from macOS.

If you wish to communicate more securely my PGP Public Key is at:
https://pgp.mit.edu/pks/lookup?search=0xE5F21DD98E4DF470&amp;op=index

On 17/06/2018 18:21, Niels Möller wrote:
&gt; Dominyk Tiller &lt;dominyktiller at gmail.com&gt; writes:
&gt; 
&gt;&gt; With the obvious enough disclaimer that Xcode/CLT 10 are very much beta
&gt;&gt; releases at this point and will remain so for several months yet, I've
&gt;&gt; attached a diff to fix the only current build issue with the new
&gt;&gt; developer tools available for macOS 10.13/10.14.
&gt; 
&gt; Thanks, looks like an easy fix. Applied 
&gt; 
&gt; Context isn't entirely clear to me, though. "CLT" means command line
&gt; tools, it seems, it's not a particular piece of software? So I take it
&gt; the name and version of the compiler package is simply "Xcode 10"?
&gt; 
&gt; Regards,
&gt; /Niels
&gt; 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20180618/1eb0302e/attachment.sig&gt;

</body></email><email><emailId>20180626100519</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2018-06-26 10:05:19-0400</timestampReceived><subject>nettle symbols: improve map files</subject><body>

On Mon, 2018-06-18 at 13:53 +0200, Nikos Mavrogiannopoulos wrote:
&gt; On Sun, 2018-06-17 at 19:55 +0200, Niels Möller wrote:
&gt; &gt; Nikos Mavrogiannopoulos &lt;nmav at redhat.com&gt; writes:
&gt; &gt; 
&gt; &gt; &gt; I attach the current state. It does move all internal symbols
&gt; &gt; &gt; into
&gt; &gt; &gt; multiple internal headers
&gt; &gt; 
&gt; &gt; Makes sense to me.
&gt; &gt; 
&gt; &gt; &gt; The last
&gt; &gt; &gt; patch renames _nettle_md5_compress and _nettle_sha1_compress and
&gt; &gt; &gt; includes it into the exported list
&gt; &gt; 
&gt; &gt; I think this makes sense too. We should leave 
&gt; &gt; 
&gt; &gt; #define _nettle_md5_compress nettle_md5_compress
&gt; &gt; #define _nettle_sha1_compress nettle_sha1_compress
&gt; &gt; 
&gt; &gt; in the header files, for API (source level) backwards
&gt; &gt; compatibility.
&gt; 
&gt; Definitions are already in place.
&gt; 
&gt; &gt; 
&gt; &gt; If we do that too, can we use glob patterns in the linker scripts,
&gt; &gt; instead of listing all symbols explicitly? It might make sense to
&gt; &gt; do
&gt; &gt; this in three steps:
&gt; 
&gt; I'd suggest against doing that because there will be no way to
&gt; achieve
&gt; symbol versioning. See the previous discussion at:
&gt; https://lists.lysator.liu.se/pipermail/nettle-bugs/2018/007287.html

The attached version only exports symbols by wildcards and combines
patches.

regards,
Nikos
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0001-abi-explicitly-export-intended-symbols-and-hide-othe.patch
Type: text/x-patch
Size: 76444 bytes
Desc: not available
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20180626/8c58ddfb/attachment.bin&gt;
                
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0002-.gitlab-ci.yml-link-with-shared-library-on-x86-64-bu.patch
Type: text/x-patch
Size: 850 bytes
Desc: not available
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20180626/8c58ddfb/attachment-0001.bin&gt;



</body></email><email><emailId>20180614102312</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2018-06-14 10:23:12-0400</timestampReceived><subject>[PATCH] Add support for reading/writing integers in Little Endian format</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
---
 bignum.c                | 35 +++++++++++++++++++++++++++++++++++
 bignum.h                | 17 +++++++++++++++++
 testsuite/bignum-test.c | 29 +++++++++++++++++++++++++++++
 3 files changed, 81 insertions(+)

diff --git a/bignum.c b/bignum.c
index 335252876544..413a630cb3aa 100644
--- a/bignum.c
+++ b/bignum.c
@@ -133,12 +133,32 @@ nettle_mpz_get_str_256(size_t length, uint8_t *s, const mpz_t x)
     }
 }
 
+void
+nettle_mpz_get_str_256_u_le(size_t length, uint8_t *s, const mpz_t x)
+{
+  if (!length)
+    {
+      /* x must be zero */
+      assert(!mpz_sgn(x));
+      return;
+    }
+
+  size_t count;
+
+  assert(nettle_mpz_sizeinbase_256_u(x) &lt;= length);
+  mpz_export(s, &amp;count, -1, 1, 0, 0, x);
+  memset(s + count, 0, length - count);
+}
+
 /* Converting from strings */
 
 /* mpz_import was introduced in GMP-4.1 */
 #define nettle_mpz_from_octets(x, length, s) \
    mpz_import((x), (length), 1, 1, 0, 0, (s))
 
+#define nettle_mpz_from_octets_le(x, length, s) \
+   mpz_import((x), (length), -1, 1, 0, 0, (s))
+
 void
 nettle_mpz_set_str_256_u(mpz_t x,
 			 size_t length, const uint8_t *s)
@@ -154,6 +174,21 @@ nettle_mpz_init_set_str_256_u(mpz_t x,
   nettle_mpz_from_octets(x, length, s);
 }
 
+void
+nettle_mpz_set_str_256_u_le(mpz_t x,
+			    size_t length, const uint8_t *s)
+{
+  nettle_mpz_from_octets_le(x, length, s);
+}
+
+void
+nettle_mpz_init_set_str_256_u_le(mpz_t x,
+				 size_t length, const uint8_t *s)
+{
+  mpz_init(x);
+  nettle_mpz_from_octets_le(x, length, s);
+}
+
 void
 nettle_mpz_set_str_256_s(mpz_t x,
 			 size_t length, const uint8_t *s)
diff --git a/bignum.h b/bignum.h
index 7871d843168c..42a97e63d6b6 100644
--- a/bignum.h
+++ b/bignum.h
@@ -68,11 +68,19 @@ nettle_mpz_sizeinbase_256_s(const mpz_t x);
 size_t
 nettle_mpz_sizeinbase_256_u(const mpz_t x);
 
+#define nettle_mpz_sizeinbase_256_u_le nettle_mpz_sizeinbase_256_u
+
 /* Writes an integer as length octets, using big endian byte order,
  * and two's complement for negative numbers. */
 void
 nettle_mpz_get_str_256(size_t length, uint8_t *s, const mpz_t x);
 
+/* Writes an integer as length octets, using big endian byte order,
+ * and unsigned number format. */
+void
+nettle_mpz_get_str_256_u_le(size_t length, uint8_t *s, const mpz_t x);
+
+
 /* Reads a big endian, two's complement, integer. */
 void
 nettle_mpz_set_str_256_s(mpz_t x,
@@ -92,6 +100,15 @@ void
 nettle_mpz_init_set_str_256_u(mpz_t x,
 			      size_t length, const uint8_t *s);
 
+/* Similar, but for little endian byte order. */
+void
+nettle_mpz_set_str_256_u_le(mpz_t x,
+			    size_t length, const uint8_t *s);
+
+void
+nettle_mpz_init_set_str_256_u_le(mpz_t x,
+				 size_t length, const uint8_t *s);
+
 /* Returns a uniformly distributed random number 0 &lt;= x &lt; 2^n */
 void
 nettle_mpz_random_size(mpz_t x,
diff --git a/testsuite/bignum-test.c b/testsuite/bignum-test.c
index 602554b53941..79fd92e2d37d 100644
--- a/testsuite/bignum-test.c
+++ b/testsuite/bignum-test.c
@@ -34,6 +34,30 @@ test_bignum(const char *hex, const struct tstring *base256)
   free(buf);
 }
 
+static void
+test_bignum_le(const char *hex, const struct tstring *base256)
+{
+  mpz_t a;
+  mpz_t b;
+  uint8_t *buf;
+
+  mpz_init_set_str(a, hex, 16);
+  nettle_mpz_init_set_str_256_u_le(b, base256-&gt;length, base256-&gt;data);
+
+  ASSERT(mpz_cmp(a, b) == 0);
+
+  buf = xalloc(base256-&gt;length + 1);
+  memset(buf, 17, base256-&gt;length + 1);
+
+  nettle_mpz_get_str_256_u_le(base256-&gt;length, buf, a);
+  ASSERT(MEMEQ(base256-&gt;length, buf, base256-&gt;data));
+
+  ASSERT(buf[base256-&gt;length] == 17);
+
+  mpz_clear(a); mpz_clear(b);
+  free(buf);
+}
+
 static void
 test_size(long x, unsigned size)
 {
@@ -86,6 +110,11 @@ test_main(void)
   test_bignum("-7fff", SHEX(  "8001"));
   test_bignum("-8000", SHEX(  "8000"));
   test_bignum("-8001", SHEX("ff7fff"));
+
+  test_bignum_le("0", SHEX("00"));
+  test_bignum_le("010203040506", SHEX("060504030201"));
+  test_bignum_le("80010203040506", SHEX("06050403020180"));
+  test_bignum_le("01020304050680", SHEX("80060504030201"));
   
 #else /* !WITH_HOGWEED */
   SKIP();
-- 
2.17.1


</body></email><email><emailId>20180617174747</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-06-17 17:47:47-0400</timestampReceived><subject>[PATCH] Add support for reading/writing integers in Little Endian format</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt; writes:

&gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov at gmail.com&gt;
&gt; ---
&gt;  bignum.c                | 35 +++++++++++++++++++++++++++++++++++
&gt;  bignum.h                | 17 +++++++++++++++++
&gt;  testsuite/bignum-test.c | 29 +++++++++++++++++++++++++++++
&gt;  3 files changed, 81 insertions(+)

Hmm, I'm not sure we should add more gmp wrappers to bignum.[hc]. The
code dates back to before Nettle was split out of LSH, as can be seen in
the _s functions which do formatting according to the ssh binary format.

We also have some related functions in gmp-glue.c (for internal
use only),

  mpn_set_base256_le
  mpn_get_base256_le

but those work with the mpn layer, which lacks the general export/import
functions.

What use for these functions do you have in mind? Application use, or
some code you'd like to add to Nettle?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20180614225821</emailId><senderName>Dominyk Tiller</senderName><senderEmail>dominyktiller@gmail.com</senderEmail><timestampReceived>2018-06-14 22:58:21-0400</timestampReceived><subject>Xcode/CLT 10+ Patch</subject><body>

Hey folks,

With the obvious enough disclaimer that Xcode/CLT 10 are very much beta
releases at this point and will remain so for several months yet, I've
attached a diff to fix the only current build issue with the new
developer tools available for macOS 10.13/10.14.

The new Apple LLVM (10.0.0) ships with a new stack probing function,
which embeds the symbol `____chkstk_darwin` into seemingly the vast
majority of libraries &amp; binaries, including both libnettle.a &amp;
libhogweed.a, which in turn currently blows up nettle's `make check`
stage on the symbol check:

----------------------
PASS: sexp-conv
PASS: pkcs1-conv
PASS: nettle-pbkdf2
Exported symbols in libnettle.a, lacking the nettle prefix:
00000000000001b0 T ____chkstk_darwin
0000000000000230 T ____chkstk_darwin
0000000000000350 T ____chkstk_darwin
0000000000000360 T ____chkstk_darwin
0000000000000380 T ____chkstk_darwin
FAIL: symbols
PASS: dlopen
====================
1 of 94 tests failed
====================
make[1]: *** [check] Error 1
make: *** [check] Error 2
----------------------

The attached diff simply scopes out an exception to the check, with a
short explanatory note.

I appreciate fully y'all may decide it's too soon to be accepting
patches for prerelease developer tools, but the chances of Apple
removing the new function or disabling it by default seem pretty low.

Let me know if anything further is needed.

Thanks,

Dominyk
-- 
Sent from macOS.

If you wish to communicate more securely my PGP Public Key is at:
https://pgp.mit.edu/pks/lookup?search=0xE5F21DD98E4DF470&amp;op=index
-------------- next part --------------
diff --git a/testsuite/symbols-test b/testsuite/symbols-test
index 051d3d2..01ca30c 100755
--- a/testsuite/symbols-test
+++ b/testsuite/symbols-test
@@ -15,9 +15,12 @@ fi
 #
 # * gcc on x86 generates functions like __i686.get_pc_thunk.bx in pic
 #   code.
+# * LLVM shipped with Xcode/CLT 10+ on macOS builds the symbol
+#   ____chkstk_darwin into the majority of binaries/libraries, including
+#   both the libraries checked here.
 
 ( $NM -g ../libnettle.a || $NM ../libnettle.a ) \
-    | grep ' [DRT] ' | egrep -v '( |^|\.)(\.?_?(_?nettle_)|get_pc_thunk)' \
+    | grep ' [DRT] ' | egrep -v '( |^|\.)(\.?_?(_?nettle_)|get_pc_thunk|(_*chkstk_darwin))' \
     | sort -k3 &gt; test1.out
 
 if [ -s test1.out ] ; then
@@ -27,7 +30,7 @@ if [ -s test1.out ] ; then
 fi
 
 if [ -s ../libhogweed.a ] ; then
-    PATTERN='\.?_?_?nettle_|get_pc_thunk'
+    PATTERN='\.?_?_?nettle_|get_pc_thunk|(_*chkstk_darwin)'
     if grep '^#define.*NETTLE_USE_MINI_GMP.*1$' ../version.h &gt;/dev/null ; then
 	PATTERN="$PATTERN|_?(mp_|mpz_|mpn_)"
     fi
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: &lt;http://lists.lysator.liu.se/pipermail/nettle-bugs/attachments/20180614/7c180c69/attachment.sig&gt;

</body></email><email><emailId>20180617172150</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2018-06-17 17:21:50-0400</timestampReceived><subject>Xcode/CLT 10+ Patch</subject><body>

Dominyk Tiller &lt;dominyktiller at gmail.com&gt; writes:

&gt; With the obvious enough disclaimer that Xcode/CLT 10 are very much beta
&gt; releases at this point and will remain so for several months yet, I've
&gt; attached a diff to fix the only current build issue with the new
&gt; developer tools available for macOS 10.13/10.14.

Thanks, looks like an easy fix. Applied 

Context isn't entirely clear to me, though. "CLT" means command line
tools, it seems, it's not a particular piece of software? So I take it
the name and version of the compiler package is simply "Xcode 10"?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email></emails>