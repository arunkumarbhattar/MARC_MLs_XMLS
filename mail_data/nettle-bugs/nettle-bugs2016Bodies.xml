<?xml version="1.0" encoding="utf-8"?>
<emails><email><emailId>20160107121128</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2016-01-07 12:11:28-0400</timestampReceived><subject>Hashing with short input assertion question</subject><body>


Hi,

just experienced a crash (assertion) when using md5 on short input.

test: md5.c:81: nettle_md5_digest: Assertion `length &lt;= 16' failed.

The code is
	struct md5_ctx md5;
	md5_init(&amp;md5);
	md5_update(&amp;md5, "moin", 4);
	md5_digest(&amp;md5, 20, digest);


My system is Debian SID (libnettle6:amd64  3.1.1-4).

The example (http://www.lysator.liu.se/~nisse/nettle/nettle.html#Example) does 
not mention special handling for short input (nettle_sha1_digest() has a 
similar assert()).
I searched the document for 'padding' but found nothing relevant.
How should I proceed ? Pad with 0 bytes ? 

Is it reasonable to open a Debian bug suggesting to use -DNDEBUG ?
IMO, these assertions needs to be disabled on a production system or replaced 
by proper error handling. It would be fine to have them in the respective -dbg 
(debugging) package though.

Best regards,
 
	Tim
["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20160207151913</emailId><senderName>Girish Kumar</senderName><senderEmail>girish.kumar@al-enterprise.com</senderEmail><timestampReceived>2016-02-07 15:19:13-0400</timestampReceived><subject>cross compiling nettle-3.2  for armv7 on linux</subject><body>

Hi All,

I am cross compiling nettle-3.2  for armv7 on linux. But I  am getting following \
error. Could you please help me on this


nettle_deps = $(shell find $(LTOP)/nettle-3.2 -type f)
$(OBJS)/nettle/nettle.configured: $(nettle_deps)
    @rm -rf $(OBJS)/nettle;
    @mkdir -p $(OBJS)/nettle;
    @cd $(OBJS)/nettle;\
    declare -x PATH=$(CCPATH):$(PATH);\
    declare -x ac_cv_func_malloc_0_nonnull="yes";\
    declare -x ac_cv_func_realloc_0_nonnull="yes";\
    declare -x CFLAGS="$(PLATFORM_CFLAGS) ";\
    declare -x LDFLAGS="$(PLATFORM_LDFLAGS) -L$(CROSSLIBS) -L$(BUILT_LIBS)";\
    declare -x CPPFLAGS="$(PLATFORM_CPPFLAGS) -I$(CROSSINCS) -I$(BUILT_INCLUDES) ";\
    $(LTOP)/nettle-3.2/configure --prefix=$(BUILT_BASE) --host=$(CCPREFIX)  \
--disable-static&amp;&gt; $(OBJS)/nettle/configure.out  @touch \
$(OBJS)/nettle/nettle.configured

$(RAMDISK_LIB)/nettle.so: $(OBJS)/nettle/nettle.configured
    @cd $(OBJS)/nettle;\
    declare -x HOSTCC=`which gcc`;\
    declare -x PATH=$(CCPATH):$(PATH);\
    declare -x CFLAGS="$(PLATFORM_CFLAGS) ";\
    declare -x LDFLAGS="$(PLATFORM_LDFLAGS) -L$(CROSSLIBS) -L$(BUILT_LIBS)";\
    declare -x CPPFLAGS="$(PLATFORM_CPPFLAGS) -I$(CROSSINCS) -I$(BUILT_INCLUDES) ";\
    $(MAKE) &amp;&gt; $(OBJS)/nettle/make.out;\
    $(MAKE) install  &amp;&gt; $(OBJS)/nettle/install.out
checking build system compiler gcc... no
checking build system compiler cc... no
checking build system compiler c89... no
checking build system compiler c99... no
configure: error: Cannot find a build system compiler
make[1]: *** [/home/gkuma020/PERFORCE/7.X.X.R01-gkuma020-new/engr/sw/tps/objs/46/7.X.X.R01/armv7/nettle/nettle.configured] \
Error 1 make[1]: Leaving directory \
                `/home/gkuma020/PERFORCE/7.X.X.R01-gkuma020-new/engr/sw/tps'
make: *** [tps-build] Error 2
+ set +x

My make file changes. Please let me know if anything is wrong.

Regards,
Girish


</body></email><email><emailId>20160310165545</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-03-10 16:55:45-0400</timestampReceived><subject>Re: patch to use gitlab runners with libasan and libubsan</subject><body>

The attached patches address the undefined behavior dependence
for blowfish, twofish and des, and enable gitlab builds with
asan and ubsan.

On Mon, 2016-02-29 at 13:29 +0100, Nikos Mavrogiannopoulos wrote:
&gt; Hello,
&gt;  I've now completed enabling the undefined sanitizer for gnutls, and
&gt; may be a good idea to use it for nettle to.  The following patch
&gt; enables running the test suite of nettle under libasan (to detect any
&gt; invalid memory accesses/writes), and the undefined sanitizer.
&gt; 
&gt; I've run a test build, and the libasan build succeeds but the
&gt; libubsan
&gt; builds fail:
&gt; https://gitlab.com/gnutls/nettle/builds/773956
&gt; 
&gt; Its complaints are not that critical for the targetted platforms but
&gt; may be nice not to rely on undefined behavior.
&gt; 
&gt; regards,
&gt; Nikos

["0001-Enforce-casting-to-unsigned-type-when-needed-to-avoi.patch" (0001-Enforce-casting-to-unsigned-type-when-needed-to-avoi.patch)]

From bfde220ad7709040f3fef4e51d86265eedfeba98 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Thu, 10 Mar 2016 17:37:36 +0100
Subject: [PATCH 1/3] Enforce casting to unsigned type when needed to avoid
 undefined behavior

This corrects issues of the following type caught with -fsanitize=undefined
runtime error: left shift of 184 by 24 places cannot be represented in type 'int'
---
 blowfish.c | 4 ++--
 twofish.c  | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/blowfish.c b/blowfish.c
index ba921e7..4d1b1ec 100644
--- a/blowfish.c
+++ b/blowfish.c
@@ -359,8 +359,8 @@ blowfish_decrypt (const struct blowfish_ctx *ctx,
     {
       uint32_t d1, d2;
 
-      d1 = src[0] &lt;&lt; 24 | src[1] &lt;&lt; 16 | src[2] &lt;&lt; 8 | src[3];
-      d2 = src[4] &lt;&lt; 24 | src[5] &lt;&lt; 16 | src[6] &lt;&lt; 8 | src[7];
+      d1 = (((uint32_t)src[0]) &lt;&lt; 24) | src[1] &lt;&lt; 16 | src[2] &lt;&lt; 8 | src[3];
+      d2 = (((uint32_t)src[4]) &lt;&lt; 24) | src[5] &lt;&lt; 16 | src[6] &lt;&lt; 8 | src[7];
       decrypt (ctx, &amp;d1, &amp;d2);
       dst[0] = (d1 &gt;&gt; 24) &amp; 0xff;
       dst[1] = (d1 &gt;&gt; 16) &amp; 0xff;
diff --git a/twofish.c b/twofish.c
index 45b0854..5bc375c 100644
--- a/twofish.c
+++ b/twofish.c
@@ -190,14 +190,14 @@ compute_s(uint32_t m1, uint32_t m2)
   uint32_t s = 0;
   int i;
   for (i = 0; i &lt; 4; i++)
-    s |=  ((  gf_multiply(0x4D, m1,       rs_matrix[i][0])
+    s |= ((uint32_t)((  gf_multiply(0x4D, m1,       rs_matrix[i][0])
 	    ^ gf_multiply(0x4D, m1 &gt;&gt; 8,  rs_matrix[i][1])
 	    ^ gf_multiply(0x4D, m1 &gt;&gt; 16, rs_matrix[i][2])
 	    ^ gf_multiply(0x4D, m1 &gt;&gt; 24, rs_matrix[i][3])
 	    ^ gf_multiply(0x4D, m2,       rs_matrix[i][4])
 	    ^ gf_multiply(0x4D, m2 &gt;&gt; 8,  rs_matrix[i][5])
 	    ^ gf_multiply(0x4D, m2 &gt;&gt; 16, rs_matrix[i][6])
-	    ^ gf_multiply(0x4D, m2 &gt;&gt; 24, rs_matrix[i][7])) &lt;&lt; (i*8));
+	    ^ gf_multiply(0x4D, m2 &gt;&gt; 24, rs_matrix[i][7]))) &lt;&lt; (i*8));
   return s;
 }
 
-- 
2.5.0


["0002-des-assign-value-after-sanity-check-to-avoid-undefin.patch" (0002-des-assign-value-after-sanity-check-to-avoid-undefin.patch)]

From e107af6c768a6d45d74e34635c169175b068ab29 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Thu, 10 Mar 2016 17:53:01 +0100
Subject: [PATCH 2/3] des: assign value after sanity check to avoid undefined
 behavior

This corrects issues of the following type caught with -fsanitize=undefined
des.c:176:42: runtime error: index 42 out of bounds for type 'int8_t [26][4]'
---
 des.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/des.c b/des.c
index f880f8f..ebde935 100644
--- a/des.c
+++ b/des.c
@@ -173,10 +173,13 @@ des_weak_p(const uint8_t *key)
   int8_t k1 = key[1] &gt;&gt; 1;
 
   unsigned hash = asso_values[k1 + 1] + asso_values[k0];
-  const int8_t *candidate = weak_key_hash[hash];
+  const int8_t *candidate;
 
   if (hash &gt; 25)
     return 0;
+
+  candidate = weak_key_hash[hash];
+
   if (k0 != candidate[0]
       || k1 != candidate[1])
     return 0;
-- 
2.5.0


["0003-.gitlab-ci.yml-enhance-with-builds-using-asan-and-ub.patch" (0003-.gitlab-ci.yml-enhance-with-builds-using-asan-and-ub.patch)]

From d96d6757bccf064f07dbe6f6144c58ad4e5b206f Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Mon, 29 Feb 2016 13:08:36 +0100
Subject: [PATCH 3/3] .gitlab-ci.yml: enhance with builds using asan and ubsan

This allows running the test suite under address sanitizer and undefined
sanitizer.
---
 .gitlab-ci.yml | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 99b241e..8d44cbb 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -17,3 +17,19 @@ Build and Check (x86):
   - x86
   except:
   - tags
+Build and Check with ubsan:
+  script:
+  - ./.bootstrap &amp;&amp; 
+    CXXFLAGS="-fsanitize=undefined -fno-sanitize-recover -g -O2" \
CFLAGS="-fsanitize=undefined -fno-sanitize-recover -g -O2" ./configure  +    \
--disable-documentation &amp;&amp; make -j4 &amp;&amp; make check -j4 +  tags:
+  - ubsan
+  except:
+  - tags
+Build and Check with asan:
+  script:
+  - ./.bootstrap &amp;&amp; 
+  - CXXFLAGS="-fsanitize=address -g -O2" CFLAGS="-fsanitize=address -g -O2" \
./configure --disable-documentation &amp;&amp; +    make -j4 &amp;&amp; make check -j4
+  except:
+  - tags
-- 
2.5.0



</body></email><email><emailId>20160425194353</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-04-25 19:43:53-0400</timestampReceived><subject>Curve25519 and RFC 7748</subject><body>

Hi,

Nikos pointed out to me that there's a slight difference between
curve25519 as implemented by Nettle and the spec in RFC 7748.

As far as I see, the difference is that RFC 7748 says that bit 255 of an
encoded x coordinates is ignored. Or more precisely, the high bit of the
31:st octet in the x input string is cleared before convertion into an
integer. While nettle's curve25519_mul includes it in the computation,
with the usual wrap-around, 2^255 = 19 (mod p). I don't see any
difference in handling scalars. Do you agree?

So I'm considering this change,

diff --git a/curve25519-mul.c b/curve25519-mul.c
index adb20cb..f5127d7 100644
--- a/curve25519-mul.c
+++ b/curve25519-mul.c
@@ -72,7 +72,11 @@ curve25519_mul (uint8_t *q, const uint8_t *n, const uint8_t *p)
   itch = ecc-&gt;p.size * 12;
   scratch = gmp_alloc_limbs (itch);
 
+  /* Note that 255 % GMP_NUMB_BITS == 0 isn't supported, so x1 always
+     holds at least 256 bits. */
   mpn_set_base256_le (x1, ecc-&gt;p.size, p, CURVE25519_SIZE);
+  /* Clear bit 255, as required by RFC 7748. */
+  x1[255/GMP_NUMB_BITS] &amp;= ~((mp_limb_t) 1 &lt;&lt; (255 % GMP_NUMB_BITS));
 
   /* Initialize, x2 = x1, z2 = 1 */
   mpn_copyi (x2, x1, ecc-&gt;p.size);

I wouldn't expect any problems from this, its a corner case with input
values which are arguably invalid. 

The motivation in the RFC, as I understand it, is to leave open for
protocols to use the top bit for their own, without bothering to clear
it before invoking curve25519. Which at first seems a bit silly, but
there's some value in not leaving corner cases implementation defined,
and it would maybe have been even more silly to require that
implementations do wraparound of that improper high bit.

This change would also need some updates of testcases and documentation.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20160525184601</emailId><senderName>Aaron Boxer</senderName><senderEmail>boxerab@gmail.com</senderEmail><timestampReceived>2016-05-25 18:46:01-0400</timestampReceived><subject>Porting openssl code to nettle</subject><body>

Hello!

I am porting some openssl code to nettle. It involves working with SHA1
keys.
What would people recommend as a guide to doing this port? I know very
little
about cryptography.

The code can be found here:

https://github.com/GrokImageCompression/asdcplib/blob/master/src/KM_prng.cpp

Thanks so much,
Aaron

</body></email><email><emailId>20160620053047</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-06-20 05:30:47-0400</timestampReceived><subject>Using mpz_powm_sec</subject><body>

I'm considering the below patch, making use of the side-channel silent
mpz_powm_sec function. The idea is to make the RSA and DSA code less
vulnerable to side-channel attacks.

Exponentiation routines typically build a small table of powers at run
time, and then look up exponent bits in the table, a few bits at the
time. This table lookup may leak information about the exponent bits
(which in the case of RSA and DSA are secret) to an attacker running
other processes on the same physical machine.

mpz_powm_sec uses a slower table-lookup function, which for each lookup
does a sequential read of the entire table. Some caveats:

* The CRT code used for RSA signing uses other functions which may leak,
  in particular division functions with branches depending on secret
  data.

* Since we still use the mpz interface rather than the mpn interface in
  gmp, the exponents use a normalized size field (so top limb is
  non-zero). This might still leak information about the top exponent
  bits.

* The patch drops support for GMP versions older than GMP-5.0, relased
  in 2010. 

* Mini-gmp builds don't try to be side-channel silent, they will use
  a #define mpz_powm_sec mpz_powm.

* I haven't yet had time to do proper benchmarks. Signing should get a
  bit slower, but I don't know how much.

Despite not plugging *all* potential leaks in the RSA code, I think the
simple change to use use mpz_powm_sec should make attacks using the
cache side-channel considerably more difficult.

Regards,
/Niels


[Attachment #3 (text/x-diff)]

diff --git a/bignum.h b/bignum.h
index 24158e0..64ed278 100644
--- a/bignum.h
+++ b/bignum.h
@@ -53,6 +53,8 @@
 # define mpz_combit mpz_combit
 # define mpz_import mpz_import
 # define mpz_export mpz_export
+/* Side-channel silent powm not available in mini-gmp. */
+# define mpz_powm_sec mpz_pwm
 #else
 # include &lt;gmp.h&gt;
 #endif
diff --git a/configure.ac b/configure.ac
index e1ee64c..92a3605 100644
--- a/configure.ac
+++ b/configure.ac
@@ -236,9 +236,9 @@ fi
 # Checks for libraries
 if test "x$enable_public_key" = "xyes" ; then
   if test "x$enable_mini_gmp" = "xno" ; then
-    AC_CHECK_LIB(gmp, __gmpz_getlimbn,,
+    AC_CHECK_LIB(gmp, __gmpz_mpz_powm,,
         [AC_MSG_WARN(
-    [GNU MP not found, or not 3.1 or up, see http://gmplib.org/.
+    [GNU MP not found, or too old. GMP-5.0 or later is needed, see http://gmplib.org/.
     Support for public key algorithms will be unavailable.])]
         enable_public_key=no)
 
diff --git a/dsa-sign.c b/dsa-sign.c
index 62c7d4a..9d6bb18 100644
--- a/dsa-sign.c
+++ b/dsa-sign.c
@@ -65,7 +65,7 @@ dsa_sign(const struct dsa_params *params,
   mpz_add_ui(k, k, 1);
 
   /* Compute r = (g^k (mod p)) (mod q) */
-  mpz_powm(tmp, params-&gt;g, k, params-&gt;p);
+  mpz_powm_sec(tmp, params-&gt;g, k, params-&gt;p);
   mpz_fdiv_r(signature-&gt;r, tmp, params-&gt;q);
 
   /* Compute hash */
diff --git a/rsa-blind.c b/rsa-blind.c
index 7662f50..16b03d7 100644
--- a/rsa-blind.c
+++ b/rsa-blind.c
@@ -61,7 +61,7 @@ _rsa_blind (const struct rsa_public_key *pub,
   while (!mpz_invert (ri, r, pub-&gt;n));
 
   /* c = c*(r^e) mod n */
-  mpz_powm(r, r, pub-&gt;e, pub-&gt;n);
+  mpz_powm_sec(r, r, pub-&gt;e, pub-&gt;n);
   mpz_mul(c, c, r);
   mpz_fdiv_r(c, c, pub-&gt;n);
 
diff --git a/rsa-sign-tr.c b/rsa-sign-tr.c
index 3d80ed4..68233a3 100644
--- a/rsa-sign-tr.c
+++ b/rsa-sign-tr.c
@@ -60,7 +60,7 @@ rsa_blind (const struct rsa_public_key *pub,
   while (!mpz_invert (ri, r, pub-&gt;n));
 
   /* c = c*(r^e) mod n */
-  mpz_powm(r, r, pub-&gt;e, pub-&gt;n);
+  mpz_powm_sec(r, r, pub-&gt;e, pub-&gt;n);
   mpz_mul(c, m, r);
   mpz_fdiv_r(c, c, pub-&gt;n);
 
@@ -97,7 +97,7 @@ rsa_compute_root_tr(const struct rsa_public_key *pub,
 
   rsa_compute_root (key, xb, mb);
 
-  mpz_powm(t, xb, pub-&gt;e, pub-&gt;n);
+  mpz_powm_sec(t, xb, pub-&gt;e, pub-&gt;n);
   res = (mpz_cmp(mb, t) == 0);
 
   if (res)
diff --git a/rsa-sign.c b/rsa-sign.c
index eba7388..4832352 100644
--- a/rsa-sign.c
+++ b/rsa-sign.c
@@ -96,11 +96,11 @@ rsa_compute_root(const struct rsa_private_key *key,
 
   /* Compute xq = m^d % q = (m%q)^b % q */
   mpz_fdiv_r(xq, m, key-&gt;q);
-  mpz_powm(xq, xq, key-&gt;b, key-&gt;q);
+  mpz_powm_sec(xq, xq, key-&gt;b, key-&gt;q);
 
   /* Compute xp = m^d % p = (m%p)^a % p */
   mpz_fdiv_r(xp, m, key-&gt;p);
-  mpz_powm(xp, xp, key-&gt;a, key-&gt;p);
+  mpz_powm_sec(xp, xp, key-&gt;a, key-&gt;p);
 
   /* Set xp' = (xp - xq) c % p. */
   mpz_sub(xp, xp, xq);


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.



</body></email><email><emailId>20160707150633</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-07-07 15:06:33-0400</timestampReceived><subject>plan for 3.3</subject><body>

Hi,
 Some comments on the 3.3, plan:
&gt; +    Add larger "safe" curves, e.g., M-383, curve41417, curve448 and
&gt; +    E-521.

I think curve448 should be prioritized over anything else since it
seems to be the only thing being standardized at the moment by CFRG:
https://tools.ietf.org/html/rfc7748

For password hashing (pbkdf2), it may also worth considering to add
support for argon2,which seems to be the only password hashing
algorithm coming out of a competition: https://password-hashing.net/

&gt; Side-channel silent mem_equalp.
Do you mean a function with run time independent of its input values?
I have such a function at gnutls:
https://gitlab.com/gnutls/gnutls/blob/master/lib/safe-memfuncs.c#L70

regards,
Nikos

</body></email><email><emailId>20160801132253</emailId><senderName>Tomas Chvatal</senderName><senderEmail>tchvatal@suse.com</senderEmail><timestampReceived>2016-08-01 13:22:53-0400</timestampReceived><subject>[patch] Nettle add missing cflags to some objects</subject><body>

[Attachment #2 (multipart/mixed)]


Hello,

I noticed that some objects are compiled without cflags.

See attached patch that fixes the situation. :)

Cheers

Tom
["nettle-respect-cflags.patch" (nettle-respect-cflags.patch)]

Index: nettle-3.2/Makefile.in
===================================================================
--- nettle-3.2.orig/Makefile.in
+++ nettle-3.2/Makefile.in
@@ -278,27 +278,27 @@ $(LIBHOGWEED_FORLINK): $(hogweed_OBJS) $
 # executable. Avoid object file targets to make it easy to run the
 # right compiler.
 aesdata$(EXEEXT_FOR_BUILD): aesdata.c
-	$(CC_FOR_BUILD) `test -f aesdata.c || echo '$(srcdir)/'`aesdata.c \
+	$(CC_FOR_BUILD) $(CFLAGS) `test -f aesdata.c || echo '$(srcdir)/'`aesdata.c \
 	-o aesdata$(EXEEXT_FOR_BUILD)
 
 desdata$(EXEEXT_FOR_BUILD): desdata.c
-	$(CC_FOR_BUILD) `test -f desdata.c || echo '$(srcdir)/'`desdata.c \
+	$(CC_FOR_BUILD) $(CFLAGS) `test -f desdata.c || echo '$(srcdir)/'`desdata.c \
 	-o desdata$(EXEEXT_FOR_BUILD)
 
 twofishdata$(EXEEXT_FOR_BUILD): twofishdata.c
-	$(CC_FOR_BUILD) `test -f twofishdata.c || echo '$(srcdir)/'`twofishdata.c \
+	$(CC_FOR_BUILD) $(CFLAGS) `test -f twofishdata.c || echo '$(srcdir)/'`twofishdata.c \
 	-o twofishdata$(EXEEXT_FOR_BUILD)
 
 shadata$(EXEEXT_FOR_BUILD): shadata.c
-	$(CC_FOR_BUILD) `test -f shadata.c || echo '$(srcdir)/'`shadata.c -lm \
+	$(CC_FOR_BUILD) $(CFLAGS) `test -f shadata.c || echo '$(srcdir)/'`shadata.c -lm \
 	-o shadata$(EXEEXT_FOR_BUILD)
 
 gcmdata$(EXEEXT_FOR_BUILD): gcmdata.c
-	$(CC_FOR_BUILD) `test -f gcmdata.c || echo '$(srcdir)/'`gcmdata.c \
+	$(CC_FOR_BUILD) $(CFLAGS) `test -f gcmdata.c || echo '$(srcdir)/'`gcmdata.c \
 	-o gcmdata$(EXEEXT_FOR_BUILD)
 
 eccdata$(EXEEXT_FOR_BUILD): eccdata.c mini-gmp.c mini-gmp.h
-	$(CC_FOR_BUILD) `test -f eccdata.c || echo '$(srcdir)/'`eccdata.c \
+	$(CC_FOR_BUILD) $(CFLAGS) `test -f eccdata.c || echo '$(srcdir)/'`eccdata.c \
 	-o eccdata$(EXEEXT_FOR_BUILD)
 
 # desCore rules

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20160905100929</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-09-05 10:09:29-0400</timestampReceived><subject>display code coverage</subject><body>

Hi,
 The attached patch uses lcov to display the code coverage of the test
suite. It uses ax_code_coverage.m4 which assumes automake, so this
patch modifies it to be able to work. This is a preliminary patch to
demo the functionality, as I haven't gone through all the automake-
related variables.

regards,
Nikos

["0001-Added-support-for-code-coverage-output.patch" (0001-Added-support-for-code-coverage-output.patch)]

From 91ffc91675ec4f7b8009ba0aa86aadc8da7cb7be Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Mon, 5 Sep 2016 12:06:08 +0200
Subject: [PATCH] Added support for code coverage output

Configure with:
  ./configure --enable-code-coverage
Show coverage output with:
  make &amp;&amp; make check &amp;&amp; make code-coverage-capture
---
 Makefile.in  |  15 +++-
 aclocal.m4   | 275 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 configure.ac |   2 +
 3 files changed, 289 insertions(+), 3 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 9d47552..2531127 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -11,6 +11,13 @@ INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = $(INSTALL_PROGRAM) -s
 MKDIR_P = @MKDIR_P@
+LCOV = @LCOV@
+GCOV = @GCOV@
+GENHTML = @GENHTML@
+CODE_COVERAGE_ENABLED = @CODE_COVERAGE_ENABLED@
+CODE_COVERAGE_CFLAGS = @CODE_COVERAGE_CFLAGS@
+CODE_COVERAGE_LDFLAGS = @CODE_COVERAGE_LDFLAGS@
+CODE_COVERAGE_DIRECTORY = .
 
 OPT_NETTLE_OBJS = @OPT_NETTLE_OBJS@
 OPT_HOGWEED_OBJS = @OPT_HOGWEED_OBJS@
@@ -21,8 +28,10 @@ SUBDIRS = tools testsuite examples
 
 include config.make
 
+@CODE_COVERAGE_RULES@
+
 PRE_CPPFLAGS = -I.
-EXTRA_CFLAGS = $(CCPIC)
+EXTRA_CFLAGS = $(CCPIC) $(CODE_COVERAGE_CFLAGS)
 
 # FIXME: Add configuration of LIBEXT?
 LIBTARGETS = @IF_STATIC@ libnettle.a @IF_HOGWEED@ libhogweed.a
@@ -253,7 +262,7 @@ libhogweed.a: $(hogweed_OBJS)
 
 # Rules building shared libraries.
 $(LIBNETTLE_FORLINK): $(nettle_OBJS)
-	$(LIBNETTLE_LINK) $(nettle_OBJS) @EXTRA_LINKER_FLAGS@ -o $@ $(LIBNETTLE_LIBS)
+	$(LIBNETTLE_LINK) $(nettle_OBJS) @EXTRA_LINKER_FLAGS@ $(CODE_COVERAGE_LDFLAGS) -o \
                $@ $(LIBNETTLE_LIBS)
 	-mkdir .lib 2&gt;/dev/null
 	(cd .lib \
           &amp;&amp; rm -f $(LIBNETTLE_FORLINK) \
@@ -264,7 +273,7 @@ $(LIBNETTLE_FORLINK): $(nettle_OBJS)
 	echo nettle &gt; libnettle.stamp
 
 $(LIBHOGWEED_FORLINK): $(hogweed_OBJS) $(LIBNETTLE_FORLINK)
-	$(LIBHOGWEED_LINK) $(hogweed_OBJS) @EXTRA_HOGWEED_LINKER_FLAGS@ -o $@ \
$(LIBHOGWEED_LIBS) +	$(LIBHOGWEED_LINK) $(hogweed_OBJS) @EXTRA_HOGWEED_LINKER_FLAGS@ \
                $(CODE_COVERAGE_LDFLAGS) -o $@ $(LIBHOGWEED_LIBS)
 	-mkdir .lib 2&gt;/dev/null
 	(cd .lib \
           &amp;&amp; rm -f $(LIBHOGWEED_FORLINK) \
diff --git a/aclocal.m4 b/aclocal.m4
index debcf9c..9686acd 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -1305,3 +1305,278 @@ EOF
 	AC_SUBST(EXTRA_HOGWEED_LINKER_FLAGS)
   fi
 ])
+
+# ===========================================================================
+#     http://www.gnu.org/software/autoconf-archive/ax_code_coverage.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CODE_COVERAGE()
+#
+# DESCRIPTION
+#
+#   Defines CODE_COVERAGE_CPPFLAGS, CODE_COVERAGE_CFLAGS,
+#   CODE_COVERAGE_CXXFLAGS and CODE_COVERAGE_LDFLAGS which should be
+#   included in the CPPFLAGS, CFLAGS CXXFLAGS and LIBS/LDFLAGS variables of
+#   every build target (program or library) which should be built with code
+#   coverage support. Also defines CODE_COVERAGE_RULES which should be
+#   substituted in your Makefile; and $enable_code_coverage which can be
+#   used in subsequent configure output. CODE_COVERAGE_ENABLED is defined
+#   and substituted, and corresponds to the value of the
+#   --enable-code-coverage option, which defaults to being disabled.
+#
+#   Test also for gcov program and create GCOV variable that could be
+#   substituted.
+#
+#   Note that all optimisation flags in CFLAGS must be disabled when code
+#   coverage is enabled.
+#
+#   Usage example:
+#
+#   configure.ac:
+#
+#     AX_CODE_COVERAGE
+#
+#   Makefile.am:
+#
+#     @CODE_COVERAGE_RULES@
+#     my_program_LIBS = ... $(CODE_COVERAGE_LDFLAGS) ...
+#     my_program_CPPFLAGS = ... $(CODE_COVERAGE_CPPFLAGS) ...
+#     my_program_CFLAGS = ... $(CODE_COVERAGE_CFLAGS) ...
+#     my_program_CXXFLAGS = ... $(CODE_COVERAGE_CXXFLAGS) ...
+#
+#   This results in a "check-code-coverage" rule being added to any
+#   Makefile.am which includes "@CODE_COVERAGE_RULES@" (assuming the module
+#   has been configured with --enable-code-coverage). Running `make
+#   check-code-coverage` in that directory will run the module's test suite
+#   (`make check`) and build a code coverage report detailing the code which
+#   was touched, then print the URI for the report.
+#
+#   This code was derived from Makefile.decl in GLib, originally licenced
+#   under LGPLv2.1+.
+#
+# LICENSE
+#
+#   Copyright (c) 2012, 2016 Philip Withnall
+#   Copyright (c) 2012 Xan Lopez
+#   Copyright (c) 2012 Christian Persch
+#   Copyright (c) 2012 Paolo Borelli
+#   Copyright (c) 2012 Dan Winship
+#   Copyright (c) 2015 Bastien ROUCARIES
+#
+#   This library is free software; you can redistribute it and/or modify it
+#   under the terms of the GNU Lesser General Public License as published by
+#   the Free Software Foundation; either version 2.1 of the License, or (at
+#   your option) any later version.
+#
+#   This library is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
+#   General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public License
+#   along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
+
+#serial 16
+
+AC_DEFUN([AX_CODE_COVERAGE],[
+	dnl Check for --enable-code-coverage
+	AC_REQUIRE([AC_PROG_SED])
+
+	# allow to override gcov location
+	AC_ARG_WITH([gcov],
+	  [AS_HELP_STRING([--with-gcov[=GCOV]], [use given GCOV for coverage \
(GCOV=gcov).])], +	  [_AX_CODE_COVERAGE_GCOV_PROG_WITH=$with_gcov],
+	  [_AX_CODE_COVERAGE_GCOV_PROG_WITH=gcov])
+
+	AC_MSG_CHECKING([whether to build with code coverage support])
+	AC_ARG_ENABLE([code-coverage],
+	  AS_HELP_STRING([--enable-code-coverage],
+	  [Whether to enable code coverage support]),,
+	  enable_code_coverage=no)
+
+dnl	AM_CONDITIONAL([CODE_COVERAGE_ENABLED], [test x$enable_code_coverage = xyes])
+	AC_SUBST([CODE_COVERAGE_ENABLED], [$enable_code_coverage])
+	AC_MSG_RESULT($enable_code_coverage)
+
+	AS_IF([ test "$enable_code_coverage" = "yes" ], [
+		# check for gcov
+		AC_CHECK_TOOL([GCOV],
+		  [$_AX_CODE_COVERAGE_GCOV_PROG_WITH],
+		  [:])
+		AS_IF([test "X$GCOV" = "X:"],
+		  [AC_MSG_ERROR([gcov is needed to do coverage])])
+		AC_SUBST([GCOV])
+
+		dnl Check if gcc is being used
+		AS_IF([ test "$GCC" = "no" ], [
+			AC_MSG_ERROR([not compiling with gcc, which is required for gcov code coverage])
+		])
+
+		# List of supported lcov versions.
+		lcov_version_list="1.6 1.7 1.8 1.9 1.10 1.11 1.12"
+
+		AC_CHECK_PROG([LCOV], [lcov], [lcov])
+		AC_CHECK_PROG([GENHTML], [genhtml], [genhtml])
+
+		AS_IF([ test "$LCOV" ], [
+			AC_CACHE_CHECK([for lcov version], ax_cv_lcov_version, [
+				ax_cv_lcov_version=invalid
+				lcov_version=`$LCOV -v 2&gt;/dev/null | $SED -e 's/^.* //'`
+				for lcov_check_version in $lcov_version_list; do
+					if test "$lcov_version" = "$lcov_check_version"; then
+						ax_cv_lcov_version="$lcov_check_version (ok)"
+					fi
+				done
+			])
+		], [
+			lcov_msg="To enable code coverage reporting you must have one of the following \
lcov versions installed: $lcov_version_list" +			AC_MSG_ERROR([$lcov_msg])
+		])
+
+		case $ax_cv_lcov_version in
+			""|invalid[)]
+				lcov_msg="You must have one of the following versions of lcov: \
$lcov_version_list (found: $lcov_version)." +				AC_MSG_ERROR([$lcov_msg])
+				LCOV="exit 0;"
+			;;
+		esac
+
+		AS_IF([ test -z "$GENHTML" ], [
+			AC_MSG_ERROR([Could not find genhtml from the lcov package])
+		])
+
+		dnl Build the code coverage flags
+		CODE_COVERAGE_CPPFLAGS="-DNDEBUG"
+		CODE_COVERAGE_CFLAGS="-O0 -g -fprofile-arcs -ftest-coverage"
+		CODE_COVERAGE_CXXFLAGS="-O0 -g -fprofile-arcs -ftest-coverage"
+		CODE_COVERAGE_LDFLAGS="-lgcov"
+
+		AC_SUBST([CODE_COVERAGE_CPPFLAGS])
+		AC_SUBST([CODE_COVERAGE_CFLAGS])
+		AC_SUBST([CODE_COVERAGE_CXXFLAGS])
+		AC_SUBST([CODE_COVERAGE_LDFLAGS])
+	])
+
+[CODE_COVERAGE_RULES='
+# Code coverage
+#
+# Optional:
+#  - CODE_COVERAGE_DIRECTORY: Top-level directory for code coverage reporting.
+#    Multiple directories may be specified, separated by whitespace.
+#    (Default: $(top_builddir))
+#  - CODE_COVERAGE_OUTPUT_FILE: Filename and path for the .info file generated
+#    by lcov for code coverage. (Default:
+#    $(PACKAGE_NAME)-$(PACKAGE_VERSION)-coverage.info)
+#  - CODE_COVERAGE_OUTPUT_DIRECTORY: Directory for generated code coverage
+#    reports to be created. (Default:
+#    $(PACKAGE_NAME)-$(PACKAGE_VERSION)-coverage)
+#  - CODE_COVERAGE_BRANCH_COVERAGE: Set to 1 to enforce branch coverage,
+#    set to 0 to disable it and leave empty to stay with the default.
+#    (Default: empty)
+#  - CODE_COVERAGE_LCOV_SHOPTS_DEFAULT: Extra options shared between both lcov
+#    instances. (Default: based on $CODE_COVERAGE_BRANCH_COVERAGE)
+#  - CODE_COVERAGE_LCOV_SHOPTS: Extra options to shared between both lcov
+#    instances. (Default: $CODE_COVERAGE_LCOV_SHOPTS_DEFAULT)
+#  - CODE_COVERAGE_LCOV_OPTIONS_GCOVPATH: --gcov-tool pathtogcov
+#  - CODE_COVERAGE_LCOV_OPTIONS_DEFAULT: Extra options to pass to the
+#    collecting lcov instance. (Default: $CODE_COVERAGE_LCOV_OPTIONS_GCOVPATH)
+#  - CODE_COVERAGE_LCOV_OPTIONS: Extra options to pass to the collecting lcov
+#    instance. (Default: $CODE_COVERAGE_LCOV_OPTIONS_DEFAULT)
+#  - CODE_COVERAGE_LCOV_RMOPTS_DEFAULT: Extra options to pass to the filtering
+#    lcov instance. (Default: empty)
+#  - CODE_COVERAGE_LCOV_RMOPTS: Extra options to pass to the filtering lcov
+#    instance. (Default: $CODE_COVERAGE_LCOV_RMOPTS_DEFAULT)
+#  - CODE_COVERAGE_GENHTML_OPTIONS_DEFAULT: Extra options to pass to the
+#    genhtml instance. (Default: based on $CODE_COVERAGE_BRANCH_COVERAGE)
+#  - CODE_COVERAGE_GENHTML_OPTIONS: Extra options to pass to the genhtml
+#    instance. (Default: $CODE_COVERAGE_GENHTML_OPTIONS_DEFAULT)
+#  - CODE_COVERAGE_IGNORE_PATTERN: Extra glob pattern of files to ignore
+#
+# The generated report will be titled using the $(PACKAGE_NAME) and
+# $(PACKAGE_VERSION). In order to add the current git hash to the title,
+# use the git-version-gen script, available online.
+
+# Optional variables
+CODE_COVERAGE_DIRECTORY ?= $(top_builddir)
+CODE_COVERAGE_OUTPUT_FILE ?= $(PACKAGE_NAME)-$(PACKAGE_VERSION)-coverage.info
+CODE_COVERAGE_OUTPUT_DIRECTORY ?= $(PACKAGE_NAME)-$(PACKAGE_VERSION)-coverage
+CODE_COVERAGE_BRANCH_COVERAGE ?=
+CODE_COVERAGE_LCOV_SHOPTS_DEFAULT ?= $(if $(CODE_COVERAGE_BRANCH_COVERAGE),\
+--rc lcov_branch_coverage=$(CODE_COVERAGE_BRANCH_COVERAGE))
+CODE_COVERAGE_LCOV_SHOPTS ?= $(CODE_COVERAGE_LCOV_SHOPTS_DEFAULT)
+CODE_COVERAGE_LCOV_OPTIONS_GCOVPATH ?= --gcov-tool "$(GCOV)"
+CODE_COVERAGE_LCOV_OPTIONS_DEFAULT ?= $(CODE_COVERAGE_LCOV_OPTIONS_GCOVPATH)
+CODE_COVERAGE_LCOV_OPTIONS ?= $(CODE_COVERAGE_LCOV_OPTIONS_DEFAULT)
+CODE_COVERAGE_LCOV_RMOPTS_DEFAULT ?=
+CODE_COVERAGE_LCOV_RMOPTS ?= $(CODE_COVERAGE_LCOV_RMOPTS_DEFAULT)
+CODE_COVERAGE_GENHTML_OPTIONS_DEFAULT ?=\
+$(if $(CODE_COVERAGE_BRANCH_COVERAGE),\
+--rc genhtml_branch_coverage=$(CODE_COVERAGE_BRANCH_COVERAGE))
+CODE_COVERAGE_GENHTML_OPTIONS ?= $(CODE_COVERAGE_GENHTML_OPTIONS_DEFAULTS)
+CODE_COVERAGE_IGNORE_PATTERN ?=
+
+code_coverage_v_lcov_cap = $(code_coverage_v_lcov_cap_$(V))
+code_coverage_v_lcov_cap_ = $(code_coverage_v_lcov_cap_1)
+code_coverage_v_lcov_cap_0 = @echo "  LCOV   --capture"\
+ $(CODE_COVERAGE_OUTPUT_FILE);
+code_coverage_v_lcov_ign = $(code_coverage_v_lcov_ign_$(V))
+code_coverage_v_lcov_ign_ = $(code_coverage_v_lcov_ign_1)
+code_coverage_v_lcov_ign_0 = @echo "  LCOV   --remove /tmp/*"\
+ $(CODE_COVERAGE_IGNORE_PATTERN);
+code_coverage_v_genhtml = $(code_coverage_v_genhtml_$(V))
+code_coverage_v_genhtml_ = $(code_coverage_v_genhtml_1)
+code_coverage_v_genhtml_0 = @echo "  GEN   " $(CODE_COVERAGE_OUTPUT_DIRECTORY);
+code_coverage_quiet = $(code_coverage_quiet_$(V))
+code_coverage_quiet_ = $(code_coverage_quiet_1)
+code_coverage_quiet_0 = --quiet
+
+# sanitizes the test-name: replaces with underscores: dashes and dots
+code_coverage_sanitize = $(subst -,_,$(subst .,_,$(1)))
+
+# Use recursive makes in order to ignore errors during check
+check-code-coverage:
+ifeq ($(CODE_COVERAGE_ENABLED),yes)
+	-$(A''M_V_at)$(MAKE) -k check
+	$(A''M_V_at)$(MAKE) code-coverage-capture
+else
+	@echo "Need to reconfigure with --enable-code-coverage"
+endif
+
+# Capture code coverage data
+code-coverage-capture: code-coverage-capture-hook
+ifeq ($(CODE_COVERAGE_ENABLED),yes)
+	$(code_coverage_v_lcov_cap)$(LCOV) $(code_coverage_quiet) $(addprefix --directory \
,$(CODE_COVERAGE_DIRECTORY)) --capture --output-file \
"$(CODE_COVERAGE_OUTPUT_FILE).tmp" --test-name "$(call \
code_coverage_sanitize,$(PACKAGE_NAME)-$(PACKAGE_VERSION))" --no-checksum \
--compat-libtool $(CODE_COVERAGE_LCOV_SHOPTS) $(CODE_COVERAGE_LCOV_OPTIONS) \
+	$(code_coverage_v_lcov_ign)$(LCOV) $(code_coverage_quiet) $(addprefix --directory \
,$(CODE_COVERAGE_DIRECTORY)) --remove "$(CODE_COVERAGE_OUTPUT_FILE).tmp" "/tmp/*" \
$(CODE_COVERAGE_IGNORE_PATTERN) --output-file "$(CODE_COVERAGE_OUTPUT_FILE)" \
$(CODE_COVERAGE_LCOV_SHOPTS) $(CODE_COVERAGE_LCOV_RMOPTS) +	-@rm -f \
$(CODE_COVERAGE_OUTPUT_FILE).tmp +	$(code_coverage_v_genhtml)LANG=C $(GENHTML) \
$(code_coverage_quiet) $(addprefix --prefix ,$(CODE_COVERAGE_DIRECTORY)) \
--output-directory "$(CODE_COVERAGE_OUTPUT_DIRECTORY)" --title \
"$(PACKAGE_NAME)-$(PACKAGE_VERSION) Code Coverage" --legend --show-details \
"$(CODE_COVERAGE_OUTPUT_FILE)" $(CODE_COVERAGE_GENHTML_OPTIONS) +	@echo \
"file://$(abs_builddir)/$(CODE_COVERAGE_OUTPUT_DIRECTORY)/index.html" +else
+	@echo "Need to reconfigure with --enable-code-coverage"
+endif
+
+# Hook rule executed before code-coverage-capture, overridable by the user
+code-coverage-capture-hook:
+
+ifeq ($(CODE_COVERAGE_ENABLED),yes)
+clean: code-coverage-clean
+distclean: code-coverage-clean
+code-coverage-clean:
+	-$(LCOV) --directory $(top_builddir) -z
+	-rm -rf $(CODE_COVERAGE_OUTPUT_FILE) $(CODE_COVERAGE_OUTPUT_FILE).tmp \
$(CODE_COVERAGE_OUTPUT_DIRECTORY) +	-find . \( -name "*.gcda" -o -name "*.gcno" -o \
-name "*.gcov" \) -delete +endif
+
+GITIGNOREFILES ?=
+GITIGNOREFILES += $(CODE_COVERAGE_OUTPUT_FILE) $(CODE_COVERAGE_OUTPUT_DIRECTORY)
+
+A''M_DISTCHECK_CONFIGURE_FLAGS ?=
+A''M_DISTCHECK_CONFIGURE_FLAGS += --disable-code-coverage
+
+.PHONY: check-code-coverage code-coverage-capture code-coverage-capture-hook \
code-coverage-clean +']
+
+	AC_SUBST([CODE_COVERAGE_RULES])
+	m4_ifdef([_AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE([CODE_COVERAGE_RULES])])
+])
diff --git a/configure.ac b/configure.ac
index 1e88477..d0985ef 100644
--- a/configure.ac
+++ b/configure.ac
@@ -99,6 +99,8 @@ fi
 AC_SUBST([NETTLE_USE_MINI_GMP])
 AC_SUBST([HOGWEED_EXTRA_SYMBOLS])
 
+AX_CODE_COVERAGE
+
 LSH_RPATH_INIT([`echo $with_lib_path | sed 's/:/ /g'` \
     `echo $exec_prefix | sed "s@^NONE@$prefix/lib@g" | sed \
"s@^NONE@$ac_default_prefix/lib@g"` \  /usr/local/lib /sw/local/lib /sw/lib \
-- 
2.7.4



</body></email><email><emailId>20161001195105</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-10-01 19:51:05-0400</timestampReceived><subject>ANNOUNCE: Nettle-3.3</subject><body>


I'm happy to announce a new release of GNU Nettle, a low-level
cryptographics library. This is mainly a bug fix release.

The Nettle home page can be found at
https://www.lysator.liu.se/~nisse/nettle/, and the manual at
https://www.lysator.liu.se/~nisse/nettle/nettle.html.

NEWS for the Nettle 3.3 release

	This release fixes a couple of bugs, and improves resistance
	to side-channel attacks on RSA and DSA private key operations.

	Changes in behavoir:

	* Invalid private RSA keys, with an even modulo, are now
	  rejected by rsa_private_key_prepare. (Earlier versions
	  allowed such keys, even if results of using them were
	  bogus).

	  Nettle applications are required to call
	  rsa_private_key_prepare and check the return value, before
	  using any other RSA private key functions; failing to do so
	  may result in crashes for invalid private keys. As a
	  workaround for versions of Gnutls which don't use
	  rsa_private_key_prepare, additional checks for even moduli
	  are added to the rsa_*_tr functions which are used by all
	  recent versions of Gnutls.

	* Ignore bit 255 of the x coordinate of the input point to
	  curve25519_mul, as required by RFC 7748. To differentiate at
	  compile time, curve25519.h defines the constant
	  NETTLE_CURVE25519_RFC7748.

	Security:

	* RSA and DSA now use side-channel silent modular
	  exponentiation, to defend against attacks on the private key
	  from evil processes sharing the same processor cache. This
	  attack scenario is of particular relevance when running an
	  HTTPS server on a virtual machine, where you don't know who
	  you share the cache hardware with.

	  (Private key operations on elliptic curves were already
	  side-channel silent).

	Bug fixes:

	* Fix sexp-conv crashes on invalid input. Reported by Hanno
	  Böck.

	* Fix out-of-bounds read in des_weak_p. Fixed by Nikos
	  Mavrogiannopoulos.

	* Fix a couple of formally undefined shift operations,
	  reported by Nikos Mavrogiannopoulos.

	* Fix compilation with c89. Reported by Henrik Grubbström.

	New features:

	* New function memeql_sec, for side-channel silent comparison
	  of two memory areas.

	Miscellaneous:

	* Building the public key support of nettle now requires GMP
	  version 5.0 or later (unless --enable-mini-gmp is used).

	* Filenames of windows DLL libraries now include major number
	  only. So the dll names change at the same time as the
	  corresponding soname on ELF platforms. Fixed by Nikos
	  Mavrogiannopoulos.

	* Eliminate most pointer-signedness warnings. In the process,
	  the strings representing expression type for sexp_interator
	  functions were changed from const uint8_t * to const char *.
	  These functions are undocumented, and it doesn't change the
	  ABI on any platform I'm aware of.

	The shared library names are libnettle.so.6.3 and
	libhogweed.so.4.3, with sonames still libnettle.so.6 and
	libhogweed.so.4. It is intended to be fully binary compatible
	with nettle-3.1.

  https://ftp.gnu.org/gnu/nettle/nettle-3.3.tar.gz
  ftp://ftp.gnu.org/gnu/nettle/nettle-3.3.tar.gz
  https://www.lysator.liu.se/~nisse/archive/nettle-3.3.tar.gz

Happy hacking,
/Niels Möller

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20161108081535</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2016-11-08 08:15:35-0400</timestampReceived><subject>Some ideas for new algorithms in Nettle</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

I've thought about som algorithms and constructs that I think would be
useful, good to add to Nettle.


We are seeing in an interest in using EC keys for both DH and DSA
operations. Esp in embedded systems. One should be careful of reusing
keys for more than one purpose. But for EC there seem to be some
circumstances when using the keys for the two constructions does not
harm each other, see:

"On the Joint Security of Encryption and Signature in EMV." Cryptology
ePrint Archive, Report 2011/615, 2011. http://eprint.iacr.org/2011/6

Recently, Trevor Perrin from Openwhispersystems wrote a paper that
describes how given a Curve25519 (or Curve448) keypair can reuse them in
a specific DSA construction called XEdDSA. The XEdDSA is in fact a way
to convert the Curve-keys in a specific way and then use them with
Ed25519, Ed448 to sign or verify messages. Openwhispersystems have also
code for XEd25519 on Github. I've looked at it and compared to the Curve
code in Nettle. It seems that we could add this algorithm with basically
a small wrapper.

https://whispersystems.org/docs/specifications/xeddsa/xeddsa.pdf

https://github.com/WhisperSystems/curve25519-java/blob/master/android/jni/ed25519/additions/xeddsa.h

https://github.com/WhisperSystems/curve25519-java/blob/master/android/jni/ed25519/additions/xeddsa.c


Another algorithm that I've seen been used in embedded space is the
SipHash PRF/keyed hash function. It is very fast on Cortex-M devices and
have low code and RAM resource requirements. If implemented in Nettle I
think we should support both 64 and 128 bit digests.

https://131002.net/siphash/
https://github.com/veorq/SipHash


When it comes to block cipher modes, CMAC and OCB are two modes that are
very interesting for embedded space. CMAC is a "better CBC-MAC" that can
be/is used as KDF, MAC etc.

http://csrc.nist.gov/publications/nistpubs/800-38B/SP_800-38B.pdf

OCB is an aead construction that has seen little used until now due to
licensing issues. But the licensing has been changed by Rogaway et al
and there is a RFC for OCB. The cost for OCB goes asymptotically towards
one cipher block operation/message block.

https://www.rfc-editor.org/rfc/rfc7253.txt
http://web.cs.ucdavis.edu/~rogaway/ocb/


I don't know what the idea is in relation to password hashing,
memory/computational hard functions. PBKDF2 is in Nettle, but not
bcrypt, scrypt or the PHC winner Argon2. Are there any interest in
adding them to Nettle?

https://github.com/P-H-C/phc-winner-argon2


Finally. Since Skein was being developed, how about adding blake2?
Blake2 was one of the runner ups for SHA-3 and is faster than Keccak.
There is also versions of Blake2 suitable for embedded systems.

https://blake2.net/





- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIcBAEBCAAGBQJYIYmnAAoJEF3cfFQkIuyN1FQQALQdER6bmnvN6fV5M2CQuVPR
mMZPzm/V6DK2+WcQnB8m5X4F3t3wB6svOO0qRGJfp13+r+xftlhBR1yGhZdA/sh+
uFVEdDl71eRgg6wFlnfKB7oo1z8gVaBDiUeZFnmnB33nttXIJTS6uL+5u+c1443L
4gdylLwL/TdJzttyPUIWdiqVkqKlJCC3VX1dfvTGbXdK5NuTypZYnfESY3XI4z+m
uMNsHTQtTy3JPmL0KDawPQr33ZJNYItdxLNTOae5bePMyeOTWBA52OX+SN7te/xV
eFUNjMA0j7Z3haAOqAwjP5WwMwzcDbkpK1qHNuN2rbtnbqVdS8MoR66Te4y04x7t
YOhtZqbV9DOVRBTNaqprHjV+4K0m6xDN6YWWOwb1fKi54mGjM6h1VvybyfKHCKpu
rBRVj6uhU7gRSAQnnUhCGK4i6s0dDfS0qFikb64r9P22BtNE3KQantpdDX9M+kVH
+iskZKMAqbb/i+9Yi+wm/oAnJRoaXPy44V6NXOpzlh4Leau1LeVnaesrkruo2HMd
X5UvbIv7OUsbgiTt8W9fjCECP5Ub2qA1w8aV8GjiAzY27E5qiRTKoRC31uDrNymt
bdwLogZmHny6kuRJADdbVcWtMaZp5gtoX53akA4obu8Ub45bA8nl+n2yHuz480+L
FeU8Gr/go+MkcCRygnfW
=iQua
-----END PGP SIGNATURE-----

</body></email><email><emailId>20161213072024</emailId><senderName>Ron Frederick</senderName><senderEmail>ronf@timeheart.net</senderEmail><timestampReceived>2016-12-13 07:20:24-0400</timestampReceived><subject>Language bindings question</subject><body>

Hello,

I recently discovered the Nettle crypto library and noticed that it has an \
implementation of UMAC in it, which I haven't been able to find in most of the other \
popular crypto libraries out there. I was hoping to call into the UMAC functions from \
Python, and I see Python mentioned on the Nettle home page at \
http://www.lysator.liu.se/~nisse/nettle/ &lt;http://www.lysator.liu.se/~nisse/nettle/&gt;, \
but there's no link for it down in the "Language bindings" section, and in fact many \
of the other links in that section seem to point at dead pages.

I tried searching for Python bindings elsewhere, but haven't had any luck so far. \
Does anyone know of any?

Assuming there aren't Python bindings yet, I would be tempted to try and craft my own \
(at least for UMAC for now). However, I'd like to be able to do it using the Python \
‘ctypes' library, and one difficulty I can see with doing that is knowing the \
amount of memory I should allocate for some of the structures used by this code. \
Specifically, for UMAC, I'd need to know the size things like "struct umac32_ctx", \
"struct umac64_ctx", "struct umac96_ctx", and "struct umac128_ctx". These sizes are \
trivial to get from C code using sizeof(), but I don't believe there's any good way \
to get them from Python using ctypes unless there's an API call that can be made to a \
C function in the library which returns this information.

As an example of this, libsodium provides functions like \
crypto_stream_chacha20_keybytes() and crypto_stream_chacha20_noncebytes() which can \
be called to return the size of a Chacha20 key and nonce, respectively. In the C \
header file, these look like:

#define crypto_stream_chacha20_KEYBYTES 32U
SODIUM_EXPORT
size_t crypto_stream_chacha20_keybytes(void);

#define crypto_stream_chacha20_NONCEBYTES 8U
SODIUM_EXPORT
size_t crypto_stream_chacha20_noncebytes(void);

The corresponding functions in the code just return the constants defined in the \
header file shown above.

For this UMAC example in Nettle, I could imagine similar functions which returned the \
value computed by sizeof() for these context structures, and also things like the \
UMAC key size, digest sizes, block size, and allowed nonce sizes. Has a use-case like \
this been considered? Is there some other way to call into Nettle from Python without \
                writing additional glue code in C?
-- 
Ron Frederick
ronf@timeheart.net


</body></email><email><emailId>20161221210150</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-12-21 21:01:50-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

Ron Frederick &lt;ronf@timeheart.net&gt; writes:

&gt; I recently discovered the Nettle crypto library and noticed that it
&gt; has an implementation of UMAC in it, which I haven't been able to find
&gt; in most of the other popular crypto libraries out there. I was hoping
&gt; to call into the UMAC functions from Python, and I see Python
&gt; mentioned on the Nettle home page at
&gt; http://www.lysator.liu.se/~nisse/nettle/
&gt; &lt;http://www.lysator.liu.se/~nisse/nettle/&gt;, but there's no link for it
&gt; down in the "Language bindings" section, and in fact many of the other
&gt; links in that section seem to point at dead pages.
&gt;
&gt; I tried searching for Python bindings elsewhere, but haven't had any
&gt; luck so far. Does anyone know of any?

Sorry for the late reply. Python bindings for nettle would make a lot of
sense, but I'm afraid I'm not aware of any.

&gt; Assuming there aren't Python bindings yet, I would be tempted to try
&gt; and craft my own (at least for UMAC for now). However, I'd like to be
&gt; able to do it using the Python ‘ctypes' library, and one difficulty I
&gt; can see with doing that is knowing the amount of memory I should
&gt; allocate for some of the structures used by this code. Specifically,
&gt; for UMAC, I'd need to know the size things like "struct umac32_ctx",
&gt; "struct umac64_ctx", "struct umac96_ctx", and "struct umac128_ctx".
&gt; These sizes are trivial to get from C code using sizeof(), but I don't
&gt; believe there's any good way to get them from Python using ctypes
&gt; unless there's an API call that can be made to a C function in the
&gt; library which returns this information.

These sizes are arhitecture dependent. And may change between nettle
release (with an ABI break, new soname, etc). It's technically possible
to add functions you suggest, but it seems both ugly and unusual to me.
I hope you can solve the problem in another way.

&gt; As an example of this, libsodium provides functions like
&gt; crypto_stream_chacha20_keybytes() and
&gt; crypto_stream_chacha20_noncebytes() which can be called to return the
&gt; size of a Chacha20 key and nonce, respectively. In the C header file,
&gt; these look like:

These are different; these constants are part of the algorithm
specification. The defines in the header files are for convenience, but
not the ultimate definition of the values.

&gt; For this UMAC example in Nettle, I could imagine similar functions
&gt; which returned the value computed by sizeof() for these context
&gt; structures, and also things like the UMAC key size, digest sizes,
&gt; block size, and allowed nonce sizes. Has a use-case like this been
&gt; considered? Is there some other way to call into Nettle from Python
&gt; without writing additional glue code in C?

For hashes and ciphers without odd quirks, you can use the corresponding
structs nettle_cipher and nettle_hash, defined in nettle-meta.h.
Currently, not available for MAC algorithms.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20161222182043</emailId><senderName>Ron Frederick</senderName><senderEmail>ronf@timeheart.net</senderEmail><timestampReceived>2016-12-22 18:20:43-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

On Dec 21, 2016, at 1:01 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; &gt; Assuming there aren't Python bindings yet, I would be tempted to try
&gt; &gt; and craft my own (at least for UMAC for now). However, I'd like to be
&gt; &gt; able to do it using the Python ‘ctypes' library, and one difficulty I
&gt; &gt; can see with doing that is knowing the amount of memory I should
&gt; &gt; allocate for some of the structures used by this code. Specifically,
&gt; &gt; for UMAC, I'd need to know the size things like "struct umac32_ctx",
&gt; &gt; "struct umac64_ctx", "struct umac96_ctx", and "struct umac128_ctx".
&gt; &gt; These sizes are trivial to get from C code using sizeof(), but I don't
&gt; &gt; believe there's any good way to get them from Python using ctypes
&gt; &gt; unless there's an API call that can be made to a C function in the
&gt; &gt; library which returns this information.
&gt; 
&gt; These sizes are arhitecture dependent. And may change between nettle
&gt; release (with an ABI break, new soname, etc). It's technically possible
&gt; to add functions you suggest, but it seems both ugly and unusual to me.
&gt; I hope you can solve the problem in another way.

[Ron] Thanks very much for getting back to me, Niels!

Rather than adding a function to return the structure size here, what do you think \
about adding functions such as umac32_new() which would do the allocation of the \
structure and return a pointer to it? This would address the issue I'm seeing with \
ctypes in Python and remain completely compatible with the existing API. I understand \
the distaste for having libraries like this allocate memory, but the only options I \
know of to provide cross-language support like this is to either provide an allocator \
function that knows how much space to allocate or to provide a function which returns \
the amount of space needed to pass to an external allocator.

To make sure there weren't any other issues in doing this, I did a proof of concept \
where I simply did a fixed-size allocation of 4 KB for the contexts (since the \
largest context is currently only about 2800 bytes on the system I'm running on) and \
I was able to make everything after that work fine. Here's a snippet of some Python 3 \
test code (without a pretty wrapper yet):

import binascii
import ctypes


UMAC_CTX_SIZE = 4096

UMAC32_DIGEST_SIZE = 4

_nettle_lib = ctypes.cdll.LoadLibrary('/opt/local/lib/libnettle.dylib')

_umac32_set_key = _nettle_lib.nettle_umac32_set_key
_umac32_set_nonce = _nettle_lib.nettle_umac32_set_nonce
_umac32_update = _nettle_lib.nettle_umac32_update
_umac32_digest = _nettle_lib.nettle_umac32_digest

ctx = ctypes.create_string_buffer(UMAC_CTX_SIZE)

key = b'abcdefghijklmnop'
nonce = b'bcdefghi'
digest = ctypes.create_string_buffer(UMAC32_DIGEST_SIZE)

for msg in (b'', 3*b'a', 1024*b'a', 32768*b'a', 1024*1024*b'a',
            32768*1024*b'a', b'abc', 500*b'abc'): 
    _umac32_set_key(ctx, key)
    _umac32_set_nonce(ctx, ctypes.c_size_t(len(nonce)), nonce)
    _umac32_update(ctx, ctypes.c_size_t(len(msg)), msg)
    _umac32_digest(ctx, ctypes.c_size_t(len(digest)), digest)
    print(binascii.b2a_hex(digest.raw).decode())

I really don't want to rely on a hard-coded size like this, though, in case future \
versions of the context structure grow much larger for some reason. Also, even if \
they don't, rounding up like this is a waste of memory. Can you think of any other \
options here?


&gt; &gt; As an example of this, libsodium provides functions like
&gt; &gt; crypto_stream_chacha20_keybytes() and
&gt; &gt; crypto_stream_chacha20_noncebytes() which can be called to return the
&gt; &gt; size of a Chacha20 key and nonce, respectively. In the C header file,
&gt; &gt; these look like:
&gt; 
&gt; These are different; these constants are part of the algorithm
&gt; specification. The defines in the header files are for convenience, but
&gt; not the ultimate definition of the values.

[Ron] Fair enough. For these, I could potentially just replicate the definitions in \
the Python code, without worry that they would change. It was just nice in the \
                libsodium case that I didn't have to.
-- 
Ron Frederick
ronf@timeheart.net


</body></email><email><emailId>20161222201627</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-12-22 20:16:27-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

Ron Frederick &lt;ronf@timeheart.net&gt; writes:

&gt; Rather than adding a function to return the structure size here, what
&gt; do you think about adding functions such as umac32_new() which would
&gt; do the allocation of the structure and return a pointer to it?

Actually, I think I'd prefer a way to get the struct size at run time;
otherwise I'd have to consider interfaces to let an application override
the allocation function used by the *_new functions.

Are you sure the ctypes package you use doesn't provide any general way
to extract struct sizes from a C interface? I know it's common practice
to design libraries to have only opaque types, with function calls for
allocation, use, and deallocation. But I wouldn't expect nettle to be
the only library which tries to be more low-level and expose some
internals.

For example, if one ever wants to let the python code read or write
fields of a struct used in a C interface, then, I imagine, the python
glue magic needs to either extract the layout from the header file, or
generate a litte C code, including the header file, to get proper sizes
and offsets or accesor functions. 

I think that, in general, it makes little sense to use C code in a
shared library without also using the corresponding header file in some
way or the other.

In principle, the compiler could insert information about sizes and
struct layouts (for more general use than just debug info) into the
object files, so that the python glue code could extract it from the
shared library itself. But as far as I'm aware, common compilers and
linkers don't do that.

&gt; ctx = ctypes.create_string_buffer(UMAC_CTX_SIZE)

Note that nettle's context structs have stricter alignment requirements
than a string. Maybe you need to use a different allocation method, to
guarantedd you at least as much alignment as the system's malloc?

&gt; I really don't want to rely on a hard-coded size like this,

I totally agree that's a bad workaround.

/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20161223031352</emailId><senderName>Ron Frederick</senderName><senderEmail>ronf@timeheart.net</senderEmail><timestampReceived>2016-12-23 03:13:52-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

On Dec 22, 2016, at 12:16 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Ron Frederick &lt;ronf@timeheart.net&gt; writes:
&gt; &gt; Rather than adding a function to return the structure size here, what
&gt; &gt; do you think about adding functions such as umac32_new() which would
&gt; &gt; do the allocation of the structure and return a pointer to it?
&gt; 
&gt; Actually, I think I'd prefer a way to get the struct size at run time;
&gt; otherwise I'd have to consider interfaces to let an application override
&gt; the allocation function used by the *_new functions.
&gt; 
&gt; Are you sure the ctypes package you use doesn't provide any general way
&gt; to extract struct sizes from a C interface? I know it's common practice
&gt; to design libraries to have only opaque types, with function calls for
&gt; allocation, use, and deallocation. But I wouldn't expect nettle to be
&gt; the only library which tries to be more low-level and expose some
&gt; internals.

[Ron] Keep in mind that the binding we're talking about here is all happening \
dynamically at run time of the Python program. At that point in time, source code to \
the C module wouldn't even be available on the system (not even header files) in many \
cases, and there'd be no C compiler or preprocessor available to parse them even if \
they were. The only thing available is the information in the dynamic library itself, \
readable by the linker.

There is a "sizeof" function in ctypes for structures, but the exact types and \
ordering of the members of the structure would have to be provided in the Python \
code, which in this case would be translating the C structure definitions (and CPP \
macros in this case) into the ctypes equivalent, meaning the structure is no longer \
opaque.


&gt; For example, if one ever wants to let the python code read or write
&gt; fields of a struct used in a C interface, then, I imagine, the python
&gt; glue magic needs to either extract the layout from the header file, or
&gt; generate a litte C code, including the header file, to get proper sizes
&gt; and offsets or accesor functions.

[Ron] There are other ways to interface to C code in Python that can auto-generate \
shims to do something like this, but they would involve actually generating and \
compiling additional C code at build time and shipping an additional C shared library \
with the Python code, which means multiple versions of the package are needed to \
cover each of the supported architectures. That's what I'm trying to avoid here, as \
up until now my package is 100% pure Python and the exact same code runs on all \
architectures and OSes (MacOS/Windows/UNIX). The only calls out to C code are either \
provided by other Python modules or involve dynamic linking against third-party C \
libraries using ctypes operating at the ABI level.


&gt; I think that, in general, it makes little sense to use C code in a
&gt; shared library without also using the corresponding header file in some
&gt; way or the other.
&gt; 
&gt; In principle, the compiler could insert information about sizes and
&gt; struct layouts (for more general use than just debug info) into the
&gt; object files, so that the python glue code could extract it from the
&gt; shared library itself. But as far as I'm aware, common compilers and
&gt; linkers don't do that.

[Ron] Yeah - I think that sort of information may be available when libraries are \
compiled with debug information, but it's not something available to the linker as \
far as I know and I've never seen anything to allow languages like Python to use that \
data to access structures like this.


&gt; &gt; ctx = ctypes.create_string_buffer(UMAC_CTX_SIZE)
&gt; 
&gt; Note that nettle's context structs have stricter alignment requirements
&gt; than a string. Maybe you need to use a different allocation method, to
&gt; guarantedd you at least as much alignment as the system's malloc?

[Ron] This is a good point. Based on some simple tests, the returned memory always \
seems to be at least 16-byte aligned similar to malloc(), but I can't actually find \
documentation that explicitly promises this. I'll have to do more research on this.


&gt; &gt; I really don't want to rely on a hard-coded size like this,
&gt; 
&gt; I totally agree that's a bad workaround.

[Ron] Unfortunately, my options at the moment seem to be to either do this or keep \
looking for alternate implementations of UMAC I can attempt to link against if I want \
to continue to keep my code 100% Python, and the Nettle version of UMAC is by far the \
                cleanest thing I've found so far.
-- 
Ron Frederick
ronf@timeheart.net


</body></email><email><emailId>20161223102736</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-12-23 10:27:36-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

On Thu, Dec 22, 2016 at 9:16 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt; Ron Frederick &lt;ronf@timeheart.net&gt; writes:
&gt;
&gt;&gt; Rather than adding a function to return the structure size here, what
&gt;&gt; do you think about adding functions such as umac32_new() which would
&gt;&gt; do the allocation of the structure and return a pointer to it?
&gt;
&gt; Actually, I think I'd prefer a way to get the struct size at run time;
&gt; otherwise I'd have to consider interfaces to let an application override
&gt; the allocation function used by the *_new functions.
&gt;
&gt; Are you sure the ctypes package you use doesn't provide any general way
&gt; to extract struct sizes from a C interface? I know it's common practice
&gt; to design libraries to have only opaque types, with function calls for
&gt; allocation, use, and deallocation. But I wouldn't expect nettle to be
&gt; the only library which tries to be more low-level and expose some
&gt; internals.

The internals exposure makes it hard to keep an ABI (for the reasons
you also outlined in the email with nettle hashes). Nettle is special
in that aspect because is intentionally low-level, but it is also
offered as a shared library with an ABI.

An approach for Ron to overcome the specific problem could be to use
wrappers over nettle which hide the details, such as the gnutls
functions (e.g., gnutls_mac_fast etc.).

The more long term question, is should nettle be striving to provide
an ABI? If not, it could transform to low-level library gnulib or ccan
are (i.e. like a copy-lib)... or alternatively, if yes, provide a high
level stable API which hides details and the ABI is easier to provide.

regards,
Nikos

</body></email><email><emailId>20161223160758</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-12-23 16:07:58-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

Ron Frederick &lt;ronf@timeheart.net&gt; writes:

&gt; [Ron] There are other ways to interface to C code in Python that can
&gt; auto-generate shims to do something like this, but they would involve
&gt; actually generating and compiling additional C code at build time and
&gt; shipping an additional C shared library with the Python code, which
&gt; means multiple versions of the package are needed to cover each of the
&gt; supported architectures.

That's they way I would expect language bindings to work. And I don't
think any other way can work if one aims to have python glue for
everything in Nettle.

That said, for umac and other mac algorithms, I think it would make
sense to provide structs similar to nettle_hash which includes all needed
sizes and function pointers. 

Would that solve your problem? You could try to see if you can make 100%
python wrapper for the supported hash functions in the nettle_hashes
list (I think Daniel Kahn Gillmor did something similar in his perl
bindings). I guess you'd still need to access struct members, though.
If useful, it's also possible to add accessor functions like

  size_t nettle_hash_ctx_size(const struct nettle_hash *hash)
  { return hash-&gt;ctx_size; }

  nettle_hash_init_func *nettle_hash_init(const struct nettle_hash *hash)
  { return hash-&gt;init; }

etc. (Other variants are possible, if one aims for a function-call-only api).

And then there's a known ABI problem with exporting that list, discussed
in another mail to the list, which needs to be solved in one way or the
other.

&gt; [Ron] This is a good point. Based on some simple tests, the returned
&gt; memory always seems to be at least 16-byte aligned similar to
&gt; malloc(), but I can't actually find documentation that explicitly
&gt; promises this. I'll have to do more research on this.

If you don't find any better way, maybe you can use ctype to call
libc malloc directly?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20161223192638</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-12-23 19:26:38-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; An approach for Ron to overcome the specific problem could be to use
&gt; wrappers over nettle which hide the details, such as the gnutls
&gt; functions (e.g., gnutls_mac_fast etc.).

If gnutls has sutable wrappers for umac, that sounds like an easy
solution, at least until needed interfaces are added to nettle.

&gt; The more long term question, is should nettle be striving to provide
&gt; an ABI? If not, it could transform to low-level library gnulib or ccan
&gt; are (i.e. like a copy-lib)... or alternatively, if yes, provide a high
&gt; level stable API which hides details and the ABI is easier to provide.

We could add a thin layer of functions involving only opaque pointers,
byte strings, and ints. If we really want, it could be a separate
.so-file, which could have an ABI more stable than nettle's. But I'm not
sure if that's really solves Ron's problem of using the functions
without depending on the header file. E.g, say we add a function like

  void *mac_ctx_new(enum nettle_mac_algorithm);

and it's called like

  void *umac_ctx = mac_ctx_new(NETTLE_ALGORITHM_UMAC);

And then the python glue loads libnettle.so, and wants to make this
function call. How would it find the numeric value of
NETTLE_ALGORITHM_UMAC? Would it duplicate the definitions in the C
header (which is ok, since these constants are (i) part of the ABI and
supposedly stable, and (ii) not architecture dependent), or would we
need some interface using plain strings to identify algorithms?

Happy holidays,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20161224021505</emailId><senderName>Ron Frederick</senderName><senderEmail>ronf@timeheart.net</senderEmail><timestampReceived>2016-12-24 02:15:05-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

On Dec 23, 2016, at 8:07 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Ron Frederick &lt;ronf@timeheart.net&gt; writes:
&gt; &gt; [Ron] There are other ways to interface to C code in Python that can
&gt; &gt; auto-generate shims to do something like this, but they would involve
&gt; &gt; actually generating and compiling additional C code at build time and
&gt; &gt; shipping an additional C shared library with the Python code, which
&gt; &gt; means multiple versions of the package are needed to cover each of the
&gt; &gt; supported architectures.
&gt; 
&gt; That's they way I would expect language bindings to work. And I don't
&gt; think any other way can work if one aims to have python glue for
&gt; everything in Nettle.
&gt; 
&gt; That said, for umac and other mac algorithms, I think it would make
&gt; sense to provide structs similar to nettle_hash which includes all needed
&gt; sizes and function pointers. 
&gt; 
&gt; Would that solve your problem? You could try to see if you can make 100%
&gt; python wrapper for the supported hash functions in the nettle_hashes
&gt; list (I think Daniel Kahn Gillmor did something similar in his perl
&gt; bindings). I guess you'd still need to access struct members, though.
&gt; If useful, it's also possible to add accessor functions like
&gt; 
&gt; size_t nettle_hash_ctx_size(const struct nettle_hash *hash)
&gt; { return hash-&gt;ctx_size; }
&gt; 
&gt; nettle_hash_init_func *nettle_hash_init(const struct nettle_hash *hash)
&gt; { return hash-&gt;init; }
&gt; 
&gt; etc. (Other variants are possible, if one aims for a function-call-only api).

Thanks - a function-call based API that didn't rely on the Python code needing to \
access any Nettle-specific structures sounds good, and would be preferred to \
something that involves declaring a struct to access function pointers and other \
static data.

I've confirmed that for UMAC the only such function I would need to build a Python \
wrapper is something that returns the context size. In fact, I have a first cut of \
such a module written and working with a "try" clause that shows how I could call \
such a function to request the size if it existed, with a fallback which uses a \
hard-coded size if that's not present.

Regarding the init function, that shouldn't be necessary if Nettle guarantees that a \
call to set_key() resets the context structure and performs all necessarily \
initialization. I can see where init() would be needed for the key-less hash \
functions, but it may not be needed here.

That actually leads to one other wrinkle I've run into. According to the Nettle docs:
&gt; Function: void umac32_digest (struct umac32_ctx *ctx, size_t length, uint8_t \
&gt; *digest) &lt;&gt;Function: void umac64_digest (struct umac64_ctx *ctx, size_t length, \
&gt; uint8_t *digest) &lt;&gt;Function: void umac96_digest (struct umac96_ctx *ctx, size_t \
&gt; length, uint8_t *digest) &lt;&gt;Function: void umac128_digest (struct umac128_ctx *ctx, \
&gt; size_t length, uint8_t *digest) Extracts the MAC of the message, writing it to \
&gt; digest. length is usually equal to the specified output size, but if you provide a \
&gt; smaller value, only the first length octets of the MAC are written. These functions \
&gt; reset the context for processing of a new message with the same key. The nonce is \
&gt; incremented as described above, the new value is used unless you call the \
&gt; _set_nonce function explicitly for each message. 

While this wouldn't really be a problem for my use case, the Python cryptographic \
hash standard API (defined in PEP 452) states the following about the digest() \
method:

&gt; digest()
&gt; 
&gt; Return the hash value of this hashing object as a bytes
&gt; containing 8-bit data.  The object is not altered in any way
&gt; by this function; you can continue updating the object after
&gt; calling this function.

So, if I wanted to provide a Python module which adhered to this API, the automatic \
reset of the context and increment of the nonce would be a problem. Mind you, I think \
this is a very useful feature in Nettle and wouldn't want to see it go away. However, \
do you think it would be possible to make this configurable? There could be something \
like a umac32_auto_increment_nonce() function that takes a context and a true/false \
value as an argument to determine whether calling digest() does this or not. If it \
didn't, you could continue to append to a message even after requesting a hash of the \
data provided so far, without the need to make a copy of the context structure first.


&gt; And then there's a known ABI problem with exporting that list, discussed
&gt; in another mail to the list, which needs to be solved in one way or the
&gt; other.

Yeah, I saw the earlier e-mail on that. My vote would be for option 2 in your list \
where a function is defined that returns a pointer to the list, and I think that \
would probably be a good approach for accessing any static data in the library.

That said, I like the suggestion in your other e-mail about providing both an ABI and \
API level interface, leaving it up to callers to decide if they're willing to deal \
with the upgrade/downgrade issues of replacing the libnettle library without \
recompiling the calling code against the latest header file. More on that shortly in \
a follow-up to that other e-mail.


&gt; &gt; [Ron] This is a good point. Based on some simple tests, the returned
&gt; &gt; memory always seems to be at least 16-byte aligned similar to
&gt; &gt; malloc(), but I can't actually find documentation that explicitly
&gt; &gt; promises this. I'll have to do more research on this.
&gt; 
&gt; If you don't find any better way, maybe you can use ctype to call
&gt; libc malloc directly?

Yes - this definitely seems like it would work if the Python allocator didn't already \
                provide such a guarantee.
-- 
Ron Frederick
ronf@timeheart.net


</body></email><email><emailId>20161224023005</emailId><senderName>Ron Frederick</senderName><senderEmail>ronf@timeheart.net</senderEmail><timestampReceived>2016-12-24 02:30:05-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

On Dec 23, 2016, at 11:26 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt; &gt; An approach for Ron to overcome the specific problem could be to use
&gt; &gt; wrappers over nettle which hide the details, such as the gnutls
&gt; &gt; functions (e.g., gnutls_mac_fast etc.).
&gt; 
&gt; If gnutls has sutable wrappers for umac, that sounds like an easy
&gt; solution, at least until needed interfaces are added to nettle.

I did run across gnutls when looking around for UMAC implementations. From what I can \
tell, gnutls only exposes UMAC 96 and 128, though, and I was hoping to be able to \
provide options for all of UMAC-32, -64, -96, and -128.


&gt; &gt; The more long term question, is should nettle be striving to provide
&gt; &gt; an ABI? If not, it could transform to low-level library gnulib or ccan
&gt; &gt; are (i.e. like a copy-lib)... or alternatively, if yes, provide a high
&gt; &gt; level stable API which hides details and the ABI is easier to provide.
&gt; 
&gt; We could add a thin layer of functions involving only opaque pointers,
&gt; byte strings, and ints. If we really want, it could be a separate
&gt; .so-file, which could have an ABI more stable than nettle's. But I'm not
&gt; sure if that's really solves Ron's problem of using the functions
&gt; without depending on the header file. E.g, say we add a function like
&gt; 
&gt; void *mac_ctx_new(enum nettle_mac_algorithm);
&gt; 
&gt; and it's called like
&gt; 
&gt; void *umac_ctx = mac_ctx_new(NETTLE_ALGORITHM_UMAC);
&gt; 
&gt; And then the python glue loads libnettle.so, and wants to make this
&gt; function call. How would it find the numeric value of
&gt; NETTLE_ALGORITHM_UMAC? Would it duplicate the definitions in the C
&gt; header (which is ok, since these constants are (i) part of the ABI and
&gt; supposedly stable, and (ii) not architecture dependent), or would we
&gt; need some interface using plain strings to identify algorithms?

Python's approach to this in "hashlib" is to use string names to identify algorithms, \
so that would definitely be a good option here. I don't really see a problem using a \
set of enum values here which got replicated in a Python wrapper to identify \
algorithms if the mapping was guaranteed to remain stable, but it wouldn't be as easy \
to add new algorithms later. Numbers would need to be assigned for them, and both the \
Python and C code would have to be updated to know about these new numbers before the \
new algorithms could be used.

Since you already have string names defined in your meta structures, allowing a \
lookup by name doesn't seem like much of a stretch.  You could potentially provide \
both options, with a function to map the name to the enum value. This would be an \
extra step for a caller who wanted to do the name-based lookup, but that could be \
                hidden inside the wrapper.
-- 
Ron Frederick
ronf@timeheart.net


</body></email><email><emailId>20161224070031</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-12-24 07:00:31-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

Ron Frederick &lt;ronf@timeheart.net&gt; writes:

&gt; Regarding the init function, that shouldn't be necessary if Nettle
&gt; guarantees that a call to set_key() resets the context structure and
&gt; performs all necessarily initialization. I can see where init() would
&gt; be needed for the key-less hash functions, but it may not be needed
&gt; here.

You're right, umac needs no init call.

&gt; While this wouldn't really be a problem for my use case, the Python
&gt; cryptographic hash standard API (defined in PEP 452) states the
&gt; following about the digest() method:
&gt;
&gt;&gt;     digest()
&gt;&gt; 
&gt;&gt;         Return the hash value of this hashing object as a bytes
&gt;&gt;         containing 8-bit data.  The object is not altered in any way
&gt;&gt;         by this function; you can continue updating the object after
&gt;&gt;         calling this function.
&gt;
&gt; So, if I wanted to provide a Python module which adhered to this API,
&gt; the automatic reset of the context and increment of the nonce would be
&gt; a problem.

The way you'd do this with Nettle is to make a copy (plain memcpy or
struct assignment) of the context struct, and extract the digest from
the copy.

The nettle design is based on the assumption that it's an uncommon use
case to hash (or mac) both a string and a prefix thereof. So it's
possible, but not optimized for.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20161224122635</emailId><senderName>Ron Frederick</senderName><senderEmail>ronf@timeheart.net</senderEmail><timestampReceived>2016-12-24 12:26:35-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

On Dec 23, 2016, at 11:00 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Ron Frederick &lt;ronf@timeheart.net&gt; writes:
&gt; &gt; While this wouldn't really be a problem for my use case, the Python
&gt; &gt; cryptographic hash standard API (defined in PEP 452) states the
&gt; &gt; following about the digest() method:
&gt; &gt; 
&gt; &gt; &gt; digest()
&gt; &gt; &gt; 
&gt; &gt; &gt; Return the hash value of this hashing object as a bytes
&gt; &gt; &gt; containing 8-bit data.  The object is not altered in any way
&gt; &gt; &gt; by this function; you can continue updating the object after
&gt; &gt; &gt; calling this function.
&gt; &gt; 
&gt; &gt; So, if I wanted to provide a Python module which adhered to this API,
&gt; &gt; the automatic reset of the context and increment of the nonce would be
&gt; &gt; a problem.
&gt; 
&gt; The way you'd do this with Nettle is to make a copy (plain memcpy or
&gt; struct assignment) of the context struct, and extract the digest from
&gt; the copy.
&gt; 
&gt; The nettle design is based on the assumption that it's an uncommon use
&gt; case to hash (or mac) both a string and a prefix thereof. So it's
&gt; possible, but not optimized for.

Understood, and I've already implemented a copy() method on the wrapper which \
allocates a new context structure and initializes it with the contents of the \
existing context. However, it seems very expensive to do that malloc &amp; memcpy on \
_every_ call to digest(), since as you've said this is the uncommon case. Given the \
documented behavior of the digest() function in PEP 452 though, that's what I would \
have to do, since there's no way in the wrapper to know if the caller might want to \
continue feeding data after digest() is called.

It makes sense to me to have Nettle default to doing the reset &amp; auto-increment of \
the nonce, as I agree that would be the common case for someone using Nettle \
directly.. However, if this could be made configurable when the context is created, \
it would make it possible to avoid the cost of the malloc &amp; memcpy in the Python \
wrapper unless the caller actually wanted to "fork" a context and hash multiple \
independent streams of data which had a common prefix.

What I'd suggest is to split out the nonce increment into its own externally callable \
function, and add a flag on the context about whether to call that function \
automatically or not. The flag would default to true to preserve existing behavior, \
but a function could be provided to disable this for callers that wanted to be able \
to do partial hashing. They could then call the increment manually if they wanted to \
reuse a context for multiple messages, avoiding the malloc &amp; memcpy even in both \
cases. The copy would only be needed in the case I mention above when hashing \
                multiple streams that start with a common prefix.
-- 
Ron Frederick
ronf@timeheart.net


</body></email><email><emailId>20161224124855</emailId><senderName>Ron Frederick</senderName><senderEmail>ronf@timeheart.net</senderEmail><timestampReceived>2016-12-24 12:48:55-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

On Dec 24, 2016, at 4:26 AM, Ron Frederick &lt;ronf@timeheart.net&gt; wrote:
&gt; What I'd suggest is to split out the nonce increment into its own externally \
&gt; callable function, and add a flag on the context about whether to call that \
&gt; function automatically or not. The flag would default to true to preserve existing \
&gt; behavior, but a function could be provided to disable this for callers that wanted \
&gt; to be able to do partial hashing. They could then call the increment manually if \
&gt; they wanted to reuse a context for multiple messages, avoiding the malloc &amp; memcpy \
&gt; even in both cases. The copy would only be needed in the case I mention above when \
&gt; hashing multiple streams that start with a common prefix.


One other thought on this: Since the sender and receiver of a message need to both \
know the nonce, I think it would be useful for Nettle to provide a get_nonce() \
function if it is going to auto-increment the nonce. While this wouldn't be needed in \
a simple point-to-point case where both sides are maintaining a context which stays \
in sync, there are other use cases where a sender might want to take advantage of the \
auto-increment behavior but send the nonce explicitly with their messages, so a \
receiver who sees only a subset of the messages can verify them. If the sender had a \
way to get the nonce back out of the context before they called digest(), they \
wouldn't need to replicate the increment functionality in their own code.

This use case is also another argument for being able to make the auto-increment \
optional. If a receiver is receiving an explicit nonce with each message, there's no \
reason for them to pay the cost of doing the increment function every time they call \
digest() to verify a message, as they're just going to reset the nonce to something \
else when the next message arrives. This would apply on senders as well when using a \
randomly generated nonce for each message, or when they create a new context for \
                every message they send.
-- 
Ron Frederick
ronf@timeheart.net


</body></email><email><emailId>20161227091128</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-12-27 09:11:28-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

Ron Frederick &lt;ronf@timeheart.net&gt; writes:

&gt; Understood, and I've already implemented a copy() method on the
&gt; wrapper which allocates a new context structure and initializes it
&gt; with the contents of the existing context. However, it seems very
&gt; expensive to do that malloc &amp; memcpy on _every_ call to digest(),
&gt; since as you've said this is the uncommon case. Given the documented
&gt; behavior of the digest() function in PEP 452 though, that's what I
&gt; would have to do, since there's no way in the wrapper to know if the
&gt; caller might want to continue feeding data after digest() is called.

One problem is that many hash functions have an end-of-data padding
which, if implemented in the simple way, clobbers the block buffer. So
if the digest() wasn't allowed to modify the context, that would
introduce some extra copying or complexity for the common case where
digest is the final operation on the data.

And most hashes have a pretty small context, so that an extra copy in
the uncommon case isn't a big deal. Now, umac differs from plain hash
functions in that it has a much larger context, making copying more
expensive.

The nonce auto-increment is less of a problem.

I would also like to say that for a MAC which depends on a nonce (in
contrast to plain hash functions and HMAC), the python "PEP 452" API
allowing multiple calls to digest seems dangerous. I'd expect that the
key could be attacked if you expose both UMAC(key, nonce, "foo") and
UMAC(key, nonce, "foobar"), since the nonce is supposed to be unique for
each message.

Maybe one reasonable way to implement the python API could be to
require an explicit set_nonce, and raise an exception if digest is
called without a corresponding set_nonce? I.e., if set_nonce was never
called, or if there are two digest calls without an intervening
set_nonce. And then do any helper methods you want for managing the
nonce value in the python code?

&gt; It makes sense to me to have Nettle default to doing the reset &amp;
&gt; auto-increment of the nonce, as I agree that would be the common case
&gt; for someone using Nettle directly.. However, if this could be made
&gt; configurable when the context is created, it would make it possible to
&gt; avoid the cost of the malloc &amp; memcpy in the Python wrapper unless the
&gt; caller actually wanted to "fork" a context and hash multiple
&gt; independent streams of data which had a common prefix.

If you'd like to experiment, you could try writing a 

  umac32_digest_pure (const struct umac32_ctx *ctx, ...)

which doesn't modify the context, to see what it takes. Probably can't
use the "padding cache" optimization, though. 

I'd prefer a separate function (naming is a bit difficult, as usual)
over a flag in the context.

What would probably be better (but a larger reorg), is to separate the
state which depends on the key from the state which depends on message
and nonce. The only MAC-like algoritm currently done like that is GCM,
which also has a large key-dependent table. That allows several contexts
sharing the same key-dependent tables.

It would make sense to do something similar for HMAC too. Currently, a
hmac_sha256_ctx consists of three sha256_ctx, which is three SHA256
state vectors of 32 bytes each, plus three block buffers of 64 bytes
each. So a total of 300 bytes or so. But it really needs only one block
buffer, so if state vectors and block buffers were better separated, it
could be trimmed down to about 170 bytes.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20161227092916</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-12-27 09:29:16-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

Ron Frederick &lt;ronf@timeheart.net&gt; writes:

&gt; One other thought on this: Since the sender and receiver of a message
&gt; need to both know the nonce, I think it would be useful for Nettle to
&gt; provide a get_nonce() function if it is going to auto-increment the
&gt; nonce.

One can access it directly from the nonce field of the context struct,
but it makes some sense to provide a more abstract method. If we want to
do this consistently, the details are not entirely obvious, though:

1. Should it return a pointer to the nonce, assuming that it is present
   in raw form in the context, so that it can be returned cheaply, or
   should it make a copy into an area provided by the caller?

2. Should a get_nonce method be added to the nettle_aead struct?

&gt; If a receiver is receiving an explicit nonce
&gt; with each message, there's no reason for them to pay the cost of doing
&gt; the increment function every time they call digest() to verify a
&gt; message, as they're just going to reset the nonce to something else
&gt; when the next message arrives.

It's true that the auto-increment is unnecessary in that case, but it is
such a small cost that I don't think it's a good tradeoff to optimize
for. (It's an invocation of the INCREMENT macro in macros.h). I think
it's going to be negligible compared to all other processing done by
digest(). Making it optional (via a flag in the context, or an extra
function) will increase the code size for a performance gain (in some
use cases) which is hardly measurable.


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20161227105951</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-12-27 10:59:51-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; The more long term question, is should nettle be striving to provide
&gt; an ABI? If not, it could transform to low-level library gnulib or ccan
&gt; are (i.e. like a copy-lib)... or alternatively, if yes, provide a high
&gt; level stable API which hides details and the ABI is easier to provide.

I'm experimenting with this... Starting with hashes which are the
simplest primitive. Header file changes below. Comments appreciated,
including naming suggestions.

Regards,
/Niels

--- a/nettle-hash.h
+++ b/nettle-hash.h
@@ -0,0 +1,66 @@
+/* nettle-hash.h
+
+   This file defines an opaque API for Nettle hash functions.
+
+   Copyright (C) 2016 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_HASH_H_INCLUDED
+#define NETTLE_HASH_H_INCLUDED
+
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct nettle_hash;
+
+size_t
+nettle_hash_get_context_size(const struct nettle_hash *hash);
+
+size_t
+nettle_hash_get_digest_size(const struct nettle_hash *hash);
+
+void
+nettle_hash_init(const struct nettle_hash *hash, void *ctx);
+
+void
+nettle_hash_update(const struct nettle_hash *hash,
+		   void *ctx, size_t length, const uint8_t *src);
+
+void
+nettle_hash_digest(const struct nettle_hash *hash,
+		   void *ctx, size_t length, uint8_t *dst);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_HASH_H_INCLUDED */
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -115,7 +115,18 @@ struct nettle_hash
 } 
 
 /* null-terminated list of digests implemented by this version of nettle */
-extern const struct nettle_hash * const nettle_hashes[];
+extern const struct nettle_hash * const _nettle_hashes[];
+
+const struct nettle_hash * const *
+#ifdef __GNUC__
+__attribute__((pure))
+#endif
+nettle_get_hashes (void);
+
+#define nettle_hashes (nettle_get_hashes())
+
+const struct nettle_hash *
+nettle_lookup_hash (const char *name);
 
 extern const struct nettle_hash nettle_md2;
 extern const struct nettle_hash nettle_md4;


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20161227143754</emailId><senderName>Ron Frederick</senderName><senderEmail>ronf@timeheart.net</senderEmail><timestampReceived>2016-12-27 14:37:54-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

On Dec 27, 2016, at 1:29 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Ron Frederick &lt;ronf@timeheart.net&gt; writes:
&gt; &gt; One other thought on this: Since the sender and receiver of a message
&gt; &gt; need to both know the nonce, I think it would be useful for Nettle to
&gt; &gt; provide a get_nonce() function if it is going to auto-increment the
&gt; &gt; nonce.
&gt; 
&gt; One can access it directly from the nonce field of the context struct,
&gt; but it makes some sense to provide a more abstract method. If we want to
&gt; do this consistently, the details are not entirely obvious, though:
&gt; 
&gt; 1. Should it return a pointer to the nonce, assuming that it is present
&gt; in raw form in the context, so that it can be returned cheaply, or
&gt; should it make a copy into an area provided by the caller?

I would have this always copy into a buffer provided by the caller similar to how the \
digest() method works, to avoid concerns about memory lifetime. Callers who had \
access to the members of the struct could always use that instead to avoid the copy \
cost, but they'd now be required to make sure the version of the library they linked \
against matched the version of the header file they compiled against.


&gt; 2. Should a get_nonce method be added to the nettle_aead struct?

Since that has a set_nonce() function, this could make sense, but it's really only \
needed in the case where something like an auto-increment is occurring. If the \
library is never modifying the nonce provided by the caller, there's probably no need \
for a function to return the currently set nonce. Do any of the AEAD functions modify \
the nonce after it is set?


&gt; &gt; If a receiver is receiving an explicit nonce
&gt; &gt; with each message, there's no reason for them to pay the cost of doing
&gt; &gt; the increment function every time they call digest() to verify a
&gt; &gt; message, as they're just going to reset the nonce to something else
&gt; &gt; when the next message arrives.
&gt; 
&gt; It's true that the auto-increment is unnecessary in that case, but it is
&gt; such a small cost that I don't think it's a good tradeoff to optimize
&gt; for. (It's an invocation of the INCREMENT macro in macros.h). I think
&gt; it's going to be negligible compared to all other processing done by
&gt; digest(). Making it optional (via a flag in the context, or an extra
&gt; function) will increase the code size for a performance gain (in some
&gt; use cases) which is hardly measurable.

Fair enough. I consider this more of a minor side benefit that we'd get in the \
process of supporting the digest_pure() capability than an independent reason to do \
this. While the benefit of this would be small, the ability to avoid the full copy of \
the context and especially to avoid an additional memory allocation associated with \
                that is a much more compelling reason.
-- 
Ron Frederick
ronf@timeheart.net


</body></email><email><emailId>20161227144419</emailId><senderName>Ron Frederick</senderName><senderEmail>ronf@timeheart.net</senderEmail><timestampReceived>2016-12-27 14:44:19-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

On Dec 27, 2016, at 2:59 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; I'm experimenting with this... Starting with hashes which are the
&gt; simplest primitive. Header file changes below. Comments appreciated,
&gt; including naming suggestions.
&gt; 
&gt; [snip]
&gt; 
&gt; +struct nettle_hash;
&gt; +
&gt; +size_t
&gt; +nettle_hash_get_context_size(const struct nettle_hash *hash);
&gt; +
&gt; +size_t
&gt; +nettle_hash_get_digest_size(const struct nettle_hash *hash);
&gt; +
&gt; +void
&gt; +nettle_hash_init(const struct nettle_hash *hash, void *ctx);
&gt; +
&gt; +void
&gt; +nettle_hash_update(const struct nettle_hash *hash,
&gt; +		   void *ctx, size_t length, const uint8_t *src);
&gt; +
&gt; +void
&gt; +nettle_hash_digest(const struct nettle_hash *hash,
&gt; +		   void *ctx, size_t length, uint8_t *dst);
&gt; 
&gt; +const struct nettle_hash *
&gt; +nettle_lookup_hash (const char *name);


This looks good to me, for non-keyed hashes.
-- 
Ron Frederick
ronf@timeheart.net




</body></email><email><emailId>20161227175749</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-12-27 17:57:49-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

Ron Frederick &lt;ronf@timeheart.net&gt; writes:

&gt; Do any of the AEAD functions modify the nonce
&gt; after it is set?

poly1305_aes_digest also increments the nonce. And it's in the same
category as umac: A keyed hash with a per-message nonce. It seems the
AEAD functions don't, so it's not entirely consistent.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20161227183525</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-12-27 18:35:25-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

Ron Frederick &lt;ronf@timeheart.net&gt; writes:

&gt; I'm not a cryptographer

And I'm an amateur when it comes to cryptanalysis.

&gt; but how would this be different than supporting a copy() function for
&gt; something like HMAC, where you generate a digest for both a message
&gt; and its prefix?

Difference is that HMAC doesn't have a nonce. When the attacker gets
the HMAC of two messages (related or not) using the same key, the
attacker is supposed to only be able to tell if the messages were
identical or not.

&gt; I thought the main attack against UMAC when you reused
&gt; both a key and a nonce for two different messages was that the key
&gt; stream for both messages was identical and it was only later mixed
&gt; with data from the messages.

I'm afraid I can't give a concrete attack, but my gut feeling is that
the security analysis depends on nonces being unique, it's generally a
bad idea to depart from that.

I don't recall all details of UMAC; it's some years since I wrote it.
But the way I understand it, it works by computing a relatively weak
low-complexity function of the expanded key and message. IIRC, L1 is a
plain linear convolution, and L2 is some kind of polynomial evaluation.
And then to hide the low-complexity structure from the attacker, a value
derived from the key and nonce is XORed to the tag at the end. Looking
at the code, that final "whitening" is the only use of the nonce I see.

So basically,

  umac(key, nonce, msg) = F(key, msg) ^ AES(pdf_key, nonce)

where F(key, msg) is a low-complexity function. So if you compute

  t0 = umac(key, nonce, "foo")
  t1 = umac(key, nonce, "foobar")

then 

  t0 XOR t1 = F(key, "foo") ^ F(key,"foobar")

which looks a bit too well structured, and defeats the whitening step. I
can't tell if it leads to practical attacks, but I wouldn't be suprised
of a few of these would let the attacker derive the parts of the
expanded key corresponding to the suffix, and then forge additional
messages with identical tag.

&gt; Admittedly, PEP 247/452
&gt; doesn't explicitly contemplate hash functions with nonces, but it
&gt; would cover cases where multiple digests were generated using the same
&gt; key and no other randomization to make the two digests independent.

As I said, multiple messages with the same key is pretty normal use of
HMAC, and if one doesn't want the attacker to be able to identify
identical messages from the MACs, one can prepend a sequence number to
the message. Supposedly unique per-message nonces make the situation
quite different.

&gt; I agree that a separate function is probably better than a flag. What
&gt; do you think of the name partial_digest(), or perhaps
&gt; running_digest()?

running_digest sounds quite clear to me. Or maybe snapshot_digest?

&gt; So, would you basically have two different context objects in this
&gt; case, one associated with just the key and a separate one associated
&gt; with the nonce and the message data provided so far? It seems like
&gt; you'd still need to make a copy of the second object before
&gt; calculating a digest if you wanted to support partial digests and
&gt; didn't have a "pure" digest function that could do that without
&gt; modifying the state, but at least the amount of data you had to copy
&gt; might be smaller.

That's the idea. For umac, the second part is quite large too, so it
would make some sense with a function that can produce the digest
without clobbering (or copying) it.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20161228023219</emailId><senderName>Ron Frederick</senderName><senderEmail>ronf@timeheart.net</senderEmail><timestampReceived>2016-12-28 02:32:19-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

On Dec 27, 2016, at 1:11 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; If you'd like to experiment, you could try writing a 
&gt; 
&gt; umac32_digest_pure (const struct umac32_ctx *ctx, ...)
&gt; 
&gt; which doesn't modify the context, to see what it takes. Probably can't
&gt; use the "padding cache" optimization, though.

I looked over the code today, and it turns out that it's a fairly clean change. We \
can even keep the "padding cache" optimization. A key thing to realize is that it ok \
to modify parts of the context, as long as they don't affect future calculations. In \
other words, it's ok to write things like padding data to the input buffer which are \
"beyond the end", since later calls update() will simply overwrite this padding as \
long as the "index" value is unchanged. Similarly, it's ok to update the padding \
cache and set the flag for that, as long as the two low-order bits of the nonce_low \
value aren't changed and the nonce is never incremented.

More specifically, the only parts of the context which need to be updated but which \
should not be modified in place are the l2_state[] array and the count value. If a \
local copy of these values is made on the stack and used in place of the values in \
the context, you get the right result. Other things like the index value and the \
nonce only need to be read and not updated, and the nonce increment and the final \
reset of the index and count can just be removed entirely.

Attached is a patch which implements new snapshot_digest() functions for all of \
umac32, umac64, umac96, and umac128. I tested these against a full range of input \
buffer sizes and incremental buffer additions to make sure I caught all the different \
edge cases and I feel pretty confident in the results. The resulting digest values \
were validated by calling the original unmodified digest function as a reference. I \
tested both the output of snapshot_digest() against digest() and then the result of \
calling update(), snapshot_digest(), update() again, and the original digest(), \
making sure I got the same results as I would have when calculating digest() on the \
combined data from both updates in a separate umac context.



-- 
Ron Frederick
ronf@timeheart.net





</body></email><email><emailId>20161228024948</emailId><senderName>Ron Frederick</senderName><senderEmail>ronf@timeheart.net</senderEmail><timestampReceived>2016-12-28 02:49:48-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

On Dec 27, 2016, at 9:57 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Ron Frederick &lt;ronf@timeheart.net&gt; writes:
&gt; &gt; Do any of the AEAD functions modify the nonce
&gt; &gt; after it is set?
&gt; 
&gt; poly1305_aes_digest also increments the nonce. And it's in the same
&gt; category as umac: A keyed hash with a per-message nonce. It seems the
&gt; AEAD functions don't, so it's not entirely consistent.


It looks like poly1305_aes_digest isn't actually in the set of nettle_aead \
constructions. So, it probably doesn't make sense to add a get_nonce() just yet to \
nettle_aead. If you added a meta structure for keyed hashes, though, it might make \
sense to have both a set_nonce() and get_nonce(), and just have those be NULL for \
                keyed hashes where there was no nonce.
-- 
Ron Frederick
ronf@timeheart.net


</body></email><email><emailId>20161108082620</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2016-11-08 08:26:20-0400</timestampReceived><subject>Re: Some ideas for new algorithms in Nettle</subject><body>


Joachim Str=F6mbergson &lt;joachim@secworks.se&gt; writes:

&gt; I don't know what the idea is in relation to password hashing,
&gt; memory/computational hard functions. PBKDF2 is in Nettle, but not
&gt; bcrypt, scrypt or the PHC winner Argon2. Are there any interest in
&gt; adding them to Nettle?

I have a personal fork of nettle with scrypt support.  I should put it
up somewhere for review and possible inclusion in Nettle.  It is a
clean-room implementation and I did not spend any time on optimization,
so there is room for improvement but I think functionality is more
important as a first step.

/Simon

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20161108084553</emailId><senderName>Aapo Talvensaari</senderName><senderEmail>aapo.talvensaari@gmail.com</senderEmail><timestampReceived>2016-11-08 08:45:53-0400</timestampReceived><subject>Re: Some ideas for new algorithms in Nettle</subject><body>

This would be a great thing to have.

Nettle already contains PBKDF2, and having scrypt would be a really nice
thing to have especially because there is no scrypt in practically any libs
and no official library.

Then Nettle would only miss, as you said, Argon2, and bcrypt. If Nettle had
all these, it would become the ultimate pasword hashing / key derivation
lib, :-).

On Tue, 8 Nov 2016 at 10.26 Simon Josefsson &lt;simon@josefsson.org&gt; wrote:

&gt; Joachim Str=C3=B6mbergson &lt;joachim@secworks.se&gt; writes:
&gt;
&gt; &gt; I don't know what the idea is in relation to password hashing,
&gt; &gt; memory/computational hard functions. PBKDF2 is in Nettle, but not
&gt; &gt; bcrypt, scrypt or the PHC winner Argon2. Are there any interest in
&gt; &gt; adding them to Nettle?
&gt;
&gt; I have a personal fork of nettle with scrypt support.  I should put it
&gt; up somewhere for review and possible inclusion in Nettle.  It is a
&gt; clean-room implementation and I did not spend any time on optimization,
&gt; so there is room for improvement but I think functionality is more
&gt; important as a first step.
&gt;
&gt; /Simon
&gt; _______________________________________________
&gt; nettle-bugs mailing list
&gt; nettle-bugs@lists.lysator.liu.se
&gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs
&gt;

</body></email><email><emailId>20161108092130</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-11-08 09:21:30-0400</timestampReceived><subject>Re: Some ideas for new algorithms in Nettle</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; Recently, Trevor Perrin from Openwhispersystems wrote a paper that
&gt; describes how given a Curve25519 (or Curve448) keypair can reuse them in
&gt; a specific DSA construction called XEdDSA. The XEdDSA is in fact a way
&gt; to convert the Curve-keys in a specific way and then use them with
&gt; Ed25519, Ed448 to sign or verify messages.

I haven't read the paper, but I guess it's just a change of coordinates,
the same or the inverse of what's done in curve25519_mul_g? Which uses
the Edwards curve representation for speed and to reuse precomputed
tables. If so, should be quite easy.

Not sure why key reuse is desirable, though, since curve25519 keys are
both small and cheap to generate.

&gt; Another algorithm that I've seen been used in embedded space is the
&gt; SipHash PRF/keyed hash function. It is very fast on Cortex-M devices and
&gt; have low code and RAM resource requirements. If implemented in Nettle I
&gt; think we should support both 64 and 128 bit digests.

This is new to me. Also the keyed-hash mode of skein looks like it can
be pretty fast and use little RAM.

&gt; OCB is an aead construction that has seen little used until now due to
&gt; licensing issues. But the licensing has been changed by Rogaway et al
&gt; and there is a RFC for OCB. The cost for OCB goes asymptotically towards
&gt; one cipher block operation/message block.

OCB is definitely an interesting construction, it's more or less the
only reasonable aead I'm aware of which isn't a cipher + separate mac +
new packaging.

CMAC, I don't know. 

OFB have also been requested in the past, not because it's technically
better than other modes, but because it's in real use.
 
&gt; I don't know what the idea is in relation to password hashing,
&gt; memory/computational hard functions. PBKDF2 is in Nettle, but not
&gt; bcrypt, scrypt or the PHC winner Argon2. Are there any interest in
&gt; adding them to Nettle?

Maybe. The main feature of scrypt is to make hardware accelleration
expensive. Which makes sense to me. What are the features of the others?
Unlike most other constructions, speed isn't really a desirable
feature... And for embedded systems, it makes a lot of sense to reuse
some primitive which is already used for other purposes.

&gt; Finally. Since Skein was being developed, how about adding blake2?
&gt; Blake2 was one of the runner ups for SHA-3 and is faster than Keccak.
&gt; There is also versions of Blake2 suitable for embedded systems.

Last time I looked at blake2, it seemed there were so into high
performance, that they had defined multiple incompatible versions
intended for different machines. Which put me off a bit. But if there's
an agreed upon general-purpose version of blake2, that would make more
sense.

I'm also not sure how to deal with research and Nettle. On one hand,
it's nice if people use Nettle as a base for implementing new
algorithms, and that makes it easier to integrate code once a new
algorithm matures. But on the other hand, for a practical library, it's
not really useful to include dozens of obscure algorithms and research
projects. And supported algorithms also need documentation, which has a
cost both to writing and reading. A compromise might be an
--enable-experimental configure flag to include unsupported algorithms
for research and evaluation purposes? Or some recommended practices for
forking and extending Nettle. 

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20161108101816</emailId><senderName>Joachim StrÃ¶mbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2016-11-08 10:18:16-0400</timestampReceived><subject>Re: Some ideas for new algorithms in Nettle</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

Niels MÃ¶ller wrote:
&gt; I haven't read the paper, but I guess it's just a change of
&gt; coordinates, the same or the inverse of what's done in
&gt; curve25519_mul_g? Which uses the Edwards curve representation for
&gt; speed and to reuse precomputed tables. If so, should be quite easy.
&gt; 
&gt; Not sure why key reuse is desirable, though, since curve25519 keys
&gt; are both small and cheap to generate.

I'm at least seeing several projects where the ability to have a single
keypair is highly desirable.

...

&gt; Last time I looked at blake2, it seemed there were so into high 
&gt; performance, that they had defined multiple incompatible versions 
&gt; intended for different machines. Which put me off a bit. But if
&gt; there's an agreed upon general-purpose version of blake2, that would
&gt; make more sense.

Yes, the versions are different. blake2b is focused on high performance,
64-bit systems. Blake2s is for 8- to 32-bit systems. Having blake2s
would imho be a good addition to sha2- and sha3.


&gt; I'm also not sure how to deal with research and Nettle. On one hand, 
&gt; it's nice if people use Nettle as a base for implementing new 
&gt; algorithms, and that makes it easier to integrate code once a new 
&gt; algorithm matures. But on the other hand, for a practical library,
&gt; it's not really useful to include dozens of obscure algorithms and
&gt; research projects.

With the exception of the new XEdDS, Argon2 and possibly OCB mode, I
would say that the suggested additions I listed are not for obscure
research algorithms, but algorithms that see concrete usage. And OCB is
taking off. My focus in general is not research, but embedded industry
usage and needs.

The XEDdsa is very new, but is used in OpenWhisperSystems, and as I've
said before meets a concrete need. The XEdDSA brings is a concrete and
well defined way to transform Curve-keys to allow usage for signing too.

CMAC is very much not a research modem but an establish NIST standard.
CMAC is much better (harder to misuse) than CBC-MAC and is used in
massively deployed protocols.


But hey, It ¨s just suggestions. I intended to provide code, but only if
there is an interest for it.

- -- 
Med vÃ¤nlig hÃ¤lsning, Yours

Joachim StrÃ¶mbergson - Alltid i harmonisk svÃ¤ngning.
========================================================================
 Joachim StrÃ¶mbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIcBAEBCAAGBQJYIaZoAAoJEF3cfFQkIuyNW4gP+wdRYUcSyLg8l8TdUcG5aD1O
99SWnCmOWobmYm8ijqMv40aJXcc1VhIgr5betklecDso/Ty1QtEPtCZ7UDDAqg1w
suC5qc66J4cYwmmZ9/QblXA11OOoC0SQjUrbZkgTM7lBfW3tLmodEFHPvKCjL9Tz
k8AF0E4nAcaC6U+aH9eR8oUFDj32yD9PuZ8Ip2juxhkQq+S2n6xqln4kgAem5HBz
VbMV4riPsVuY6feOhs5b98+B2kBggntDKh9Y6cFqZ7B/HK3FzJsuBl6HSYazFlfn
dMwcoX+J6gOoV0yMbq1+ABWvXjsCBxXFWEahvf4rOibFl47tU++q37+GXARbECUU
ykncZGHj/LXRT54o6/hMMMf8Uisu2voKWXJCpDNmB2rxHDl/ywsAc8gDTB5FQl6i
rAQBKHRq4Z8+7wHj6R+kTBr9aByYZXt6ofFGKSMIrbghaLoHSsa08/2e0ZrZK4AP
eN29sqylh9P9pn1kI7QvBd877e8TwL/RpwfCfLsZTiu4z49kpu+om2+Kpry1kTQn
zTyXmYoRGFPthgaT1tU+xRjBiQALrddNtyN8g0mvr5w+1NahFBc7y9NPkIFm/AQP
heS+NwzDFrceFmyJ9SORYafuRlfDR3BBAPRU7niELnNRY7oli7E6gvlnwMlYWV1c
1r92qLiAQexn9DjIXLO3
=0pnf
-----END PGP SIGNATURE-----

</body></email><email><emailId>20161002061412</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2016-10-02 06:14:12-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.3</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Date: Sat, 01 Oct 2016 21:51:05 +0200
&gt; 
&gt; I'm happy to announce a new release of GNU Nettle, a low-level
&gt; cryptographics library. This is mainly a bug fix release.

Thanks!

&gt; 	* Eliminate most pointer-signedness warnings. In the process,
&gt; 	  the strings representing expression type for sexp_interator
&gt; 	  functions were changed from const uint8_t * to const char *.
&gt; 	  These functions are undocumented, and it doesn't change the
&gt; 	  ABI on any platform I'm aware of.

Building with MinGW on MS-Windows, I still see a few warnings of this
kind, like the ones below:

nettle-hash.c: In function 'digest_file':
nettle-hash.c:123:25: warning: pointer targets in passing argument 1 of \
'nettle_base16_encode_update' differ in signedness [-Wpointer-sign]  \
base16_encode_update(hex, 8, digest + i);  ^
In file included from nettle-hash.c:44:0:
../base16.h:46:30: note: expected 'uint8_t * {aka unsigned char *}' but argument is \
of type 'char *'  #define base16_encode_update nettle_base16_encode_update
                              ^
../base16.h:64:1: note: in expansion of macro 'base16_encode_update'
 base16_encode_update(uint8_t *dst,
 ^
nettle-hash.c:127:28: warning: pointer targets in passing argument 1 of \
'nettle_base16_encode_update' differ in signedness [-Wpointer-sign]  \
base16_encode_update(hex, digest_length - i, digest + i);  ^
In file included from nettle-hash.c:44:0:
../base16.h:46:30: note: expected 'uint8_t * {aka unsigned char *}' but argument is \
of type 'char *'  #define base16_encode_update nettle_base16_encode_update
                              ^
../base16.h:64:1: note: in expansion of macro 'base16_encode_update'
 base16_encode_update(uint8_t *dst,
 ^

nettle-pbkdf2.c: In function 'main':
nettle-pbkdf2.c:181:25: warning: pointer targets in passing argument 1 of \
'nettle_base16_encode_update' differ in signedness [-Wpointer-sign]  \
base16_encode_update(hex, 8, output + i);  ^
In file included from nettle-pbkdf2.c:44:0:
../base16.h:46:30: note: expected 'uint8_t * {aka unsigned char *}' but argument is \
of type 'char *'  #define base16_encode_update nettle_base16_encode_update
                              ^
../base16.h:64:1: note: in expansion of macro 'base16_encode_update'
 base16_encode_update(uint8_t *dst,
 ^
nettle-pbkdf2.c:185:28: warning: pointer targets in passing argument 1 of \
'nettle_base16_encode_update' differ in signedness [-Wpointer-sign]  \
base16_encode_update(hex, output_length - i, output + i);  ^
In file included from nettle-pbkdf2.c:44:0:
../base16.h:46:30: note: expected 'uint8_t * {aka unsigned char *}' but argument is \
of type 'char *'  #define base16_encode_update nettle_base16_encode_update
                              ^
../base16.h:64:1: note: in expansion of macro 'base16_encode_update'
 base16_encode_update(uint8_t *dst,
 ^

In file included from testutils.c:3:0:
testutils.c: In function 'tstring_hex':
testutils.c:82:13: warning: pointer targets in passing argument 5 of \
'nettle_base16_decode_update' differ in signedness [-Wpointer-sign]  length, hex));
             ^
testutils.h:293:11: note: in definition of macro 'ASSERT'
     if (!(x))        \
           ^
In file included from testutils.c:5:0:
../base16.h:49:30: note: expected 'const uint8_t * {aka const unsigned char *}' but \
argument is of type 'const char *'  #define base16_decode_update \
nettle_base16_decode_update  ^
../base16.h:96:1: note: in expansion of macro 'base16_decode_update'
 base16_decode_update(struct base16_decode_ctx *ctx,
 ^


</body></email><email><emailId>20161002072036</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2016-10-02 07:20:36-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.3</subject><body>

&gt; Date: Sun, 02 Oct 2016 09:14:12 +0300
&gt; From: Eli Zaretskii &lt;eliz@gnu.org&gt;
&gt; 
&gt; &gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; &gt; Date: Sat, 01 Oct 2016 21:51:05 +0200
&gt; &gt; 
&gt; &gt; I'm happy to announce a new release of GNU Nettle, a low-level
&gt; &gt; cryptographics library. This is mainly a bug fix release.
&gt; 
&gt; Thanks!
&gt; 
&gt; &gt; 	* Eliminate most pointer-signedness warnings. In the process,
&gt; &gt; 	  the strings representing expression type for sexp_interator
&gt; &gt; 	  functions were changed from const uint8_t * to const char *.
&gt; &gt; 	  These functions are undocumented, and it doesn't change the
&gt; &gt; 	  ABI on any platform I'm aware of.
&gt; 
&gt; Building with MinGW on MS-Windows, I still see a few warnings of this
&gt; kind, like the ones below:

And one more gripe: why doesn't Nettle have the standard
'install-strip' target in its Makefile?  Or did I miss something?

</body></email><email><emailId>20161002075320</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-10-02 07:53:20-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.3</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt;&gt; 	* Eliminate most pointer-signedness warnings. In the process,
&gt;&gt; 	  the strings representing expression type for sexp_interator
&gt;&gt; 	  functions were changed from const uint8_t * to const char *.
&gt;&gt; 	  These functions are undocumented, and it doesn't change the
&gt;&gt; 	  ABI on any platform I'm aware of.
&gt;
&gt; Building with MinGW on MS-Windows, I still see a few warnings of this
&gt; kind, like the ones below:

I see these on gnu/linux too, that's why I wrote "most"...

I'm considering changing the type of the ascii inputs and outputs for
ascii armoring functions to use plain char, but I didn't get to that for
this release. A few of the functions also support in-place conversion,
making it somewhat messy to use different types for input and output.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20161002082204</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-10-02 08:22:04-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.3</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt; And one more gripe: why doesn't Nettle have the standard
&gt; 'install-strip' target in its Makefile?

TL;DR: I guess that's an oversight, I'd need sme advice to get it right.

What's the simplest way to to that? Is it enough to patch the top-level
Makefile.in like below? (Automake seems to produce something slightly
more complicated).

And then exactly what is it that should be stripped? I see that the make
targets for installing both shared and static libraries use
$(INSTALL_DATA) rather than $(INSTALL_PROGRAM), so libraries won't be
affected. Those targets are a decade old, but I think it followed GNU
standards at the time.

When handling libraries, I imagine one need to be a little careful to
use the right one of

  strip 
  strip -s
  strip --strip-debug
  strip --strip-unneded

and I'm not sure which is implied by install -s.

Regards,
/Niels

diff --git a/Makefile.in b/Makefile.in
index 135542f..2103665 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -50,6 +50,9 @@ all check install uninstall:
 	set -e; for d in $(SUBDIRS); do \
 	  echo "Making $@ in $$d" ; (cd $$d &amp;&amp; $(MAKE) $@); done
 
+install-strip:
+	$(MAKE) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" install
+
 clean distclean mostlyclean maintainer-clean tags:
 	set -e; for d in $(SUBDIRS); do \
 	  echo "Making $@ in $$d" ; (cd $$d &amp;&amp; $(MAKE) $@); done


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20161002084945</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2016-10-02 08:49:45-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.3</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Cc: nettle-bugs@lists.lysator.liu.se
&gt; Date: Sun, 02 Oct 2016 10:22:04 +0200
&gt; 
&gt; Eli Zaretskii &lt;eliz@gnu.org&gt; writes:
&gt; 
&gt; &gt; And one more gripe: why doesn't Nettle have the standard
&gt; &gt; 'install-strip' target in its Makefile?
&gt; 
&gt; TL;DR: I guess that's an oversight, I'd need sme advice to get it right.

I'm not an expert, but I will try to tell what I know.

&gt; What's the simplest way to to that? Is it enough to patch the top-level
&gt; Makefile.in like below?

That's a start, although libraries need extra care, as you suspect.

&gt; And then exactly what is it that should be stripped? I see that the make
&gt; targets for installing both shared and static libraries use
&gt; $(INSTALL_DATA) rather than $(INSTALL_PROGRAM), so libraries won't be
&gt; affected. Those targets are a decade old, but I think it followed GNU
&gt; standards at the time.
&gt; 
&gt; When handling libraries, I imagine one need to be a little careful to
&gt; use the right one of
&gt; 
&gt;   strip 
&gt;   strip -s
&gt;   strip --strip-debug
&gt;   strip --strip-unneded

Shared libraries need --strip-unneded, static libraries need
--strip-debug followed by ranlib.

&gt; and I'm not sure which is implied by install -s.

It's a synonym for --strip-all, so it's only pertinent to executable
programs.

</body></email><email><emailId>20161002100135</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-10-02 10:01:35-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.3</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt;&gt; When handling libraries, I imagine one need to be a little careful to
&gt;&gt; use the right one of
&gt;&gt; 
&gt;&gt;   strip 
&gt;&gt;   strip -s
&gt;&gt;   strip --strip-debug
&gt;&gt;   strip --strip-unneded
&gt;
&gt; Shared libraries need --strip-unneded, static libraries need
&gt; --strip-debug followed by ranlib.

Makes sense. Are you saying that for static libraries, one has to redo
ranlib after strip?

&gt;&gt; and I'm not sure which is implied by install -s.
&gt;
&gt; It's a synonym for --strip-all, so it's only pertinent to executable
&gt; programs.

And you're also saying that a "default strip", invoking strip without
any options, is the same as strip --strip-all?

I wonder if one can persuade the install program to do the right thing.
It should be straightforward to use separate variables
INSTALL_STATIC_LIB and INSTALL_SHARED_LIB, to override in the
install-strip target. But it seems overriding the strip command, e.g.,
to use strip --strip-unneeded, is going to be messy.

For install-sh, is one can set STRIPPROG="strip --strip-unneeded". For
GNU /usr/bin/install, one can set STRIPPROG="strip --strip-unneeded" in
the environment (untested, not sure if it is passed to the shell to
split into command and arguments). But that won't work with BSD install.
Checking on freebsd, it seems it checks an environment named STRIPBIN,
(not sure if there's also a BSD strip not accepting GNU options; on my
closest freebsd system, /usr/bin/strip is an ancient GNU binutils).

Since install-strip is an optional thing, I think I'd be happy to
support only the most mainstream cases here.

The alternative to using install -s would be to produce additional files
in the build directory, e.g., libnettle.a.stripped and install that. But
having that done as part of make install-strip breaks the expectation
that install targets shouldn't create or modify any files in the build
tree, and producing them in make all doesn't seem quite right either.

A third alternative is to have the install-strip target do things like

    $(INSTALL_DATA) libnettle.a $(DESTDIR)$(libdir)
    strip --strip-debug $(DESTDIR)$(libdir)/libnettle.a
    ranlib $(DESTDIR)$(libdir)/libnettle.a # Rebuild index

and use install -s *only* for (non-script) executables.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160802150957</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-08-02 15:09:57-0400</timestampReceived><subject>Re: [patch] Nettle add missing cflags to some objects</subject><body>

Tomas Chvatal &lt;TChvatal@suse.com&gt; writes:

&gt; I noticed that some objects are compiled without cflags.

Was there any concrete problem?

&gt; See attached patch that fixes the situation. :)

I'm afraid it can break cross compilation. CFLAGS are for flags
appropriate for the cross compiler. While the various programs built
using $(CC_FOR_BUILD) are always native binaries. To be concrete,
consider cross compiling for arm on a x86 build machine, and $(CFLAGS)
choosen to select whether or not to enable generation of arm neon
instructions. Passing those flags also to the native compiler won't
work.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160803091002</emailId><senderName>Tomas Chvatal</senderName><senderEmail>tchvatal@suse.com</senderEmail><timestampReceived>2016-08-03 09:10:02-0400</timestampReceived><subject>Re: [patch] Nettle add missing cflags to some objects</subject><body>


Niels Möller píše v Út 02. 08. 2016 v 17:09 +0200:
&gt; Tomas Chvatal &lt;TChvatal@suse.com&gt; writes:
&gt; 
&gt; &gt; 
&gt; &gt; I noticed that some objects are compiled without cflags.
&gt; 
&gt; Was there any concrete problem?
&gt; 
&gt; &gt; 
&gt; &gt; See attached patch that fixes the situation. :)
&gt; 
&gt; I'm afraid it can break cross compilation. CFLAGS are for flags
&gt; appropriate for the cross compiler. While the various programs built
&gt; using $(CC_FOR_BUILD) are always native binaries. To be concrete,
&gt; consider cross compiling for arm on a x86 build machine, and
&gt; $(CFLAGS)
&gt; choosen to select whether or not to enable generation of arm neon
&gt; instructions. Passing those flags also to the native compiler won't
&gt; work.
&gt; 
&gt; Regards,
&gt; /Niels
&gt; 

Hello,
we have checks that verify all objects are compiled with respecting
cflags set in the distribution (hardening, optimization, etc.).

If there is object not doing that I get errors on it. Thus it should be
able to do so.

Hmm with the cross-compilation I am not sure how that should be handled
properly but simply ignoring all other cflags on those objects does not
seem like right solution.

Tom
["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20160803124538</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-08-03 12:45:38-0400</timestampReceived><subject>Re: [patch] Nettle add missing cflags to some objects</subject><body>

Tomas Chvatal &lt;TChvatal@suse.com&gt; writes:

&gt; we have checks that verify all objects are compiled with respecting
&gt; cflags set in the distribution (hardening, optimization, etc.).

I see. And you can't easily exclude executables which are never installed?
Note that the Makefile rules where CC_FOR_BUILD is used produce
executables directly from a .c file, with no explicit object files.

&gt; Hmm with the cross-compilation I am not sure how that should be handled
&gt; properly but simply ignoring all other cflags on those objects does not
&gt; seem like right solution.

I see two reasonable solutions. If possible, try both and report what
works. Either explicitly pass CC_FOR_BUILD="gcc
--whatever-flags-you-want" on the configure command line produced by
your build scripts. Or change the no-cross default, like

--- a/aclocal.m4
+++ b/aclocal.m4
@@ -514,7 +514,7 @@ elif test -n "$HOST_CC"; then
     [AC_MSG_ERROR([Specified HOST_CC doesn't seem to work])])
 else
   if test $cross_compiling = no ; then
-    CC_FOR_BUILD="$CC"  
+    CC_FOR_BUILD="$(CC) $(CFLAGS)"  
   else
     for i in gcc cc c89 c99; do
       GMP_PROG_CC_FOR_BUILD_WORKS($i,

(untested, not sure if this makefile syntax in CC_FOR_BUILD breaks any
use outside of Makefile).

And I guess you'll have the same problem when building gmp, so I'm
cc:ing the gmp-devel list as well.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160903150518</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-09-03 15:05:18-0400</timestampReceived><subject>Re: plan for 3.3</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt;&gt;&gt; Side-channel silent mem_equalp.

[...]

&gt; Difficulty is proper naming... Since it doesn't distinguish between lexically smaller
&gt; and larger like memcmp, I don't think it should be named like *_memcmp.
&gt; And we also need a name for the nettle header file.

See patch below. Header file "memops.h", and function called memeql_sec.
Any comments or opinions before I merge to master?

Regards,
/Niels

diff --git a/ChangeLog b/ChangeLog
index b315011..09f41b0 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,17 @@
+2016-09-03  Niels Möller  &lt;nisse@lysator.liu.se&gt;
+
+	* testsuite/memeql-test.c (test_main): New test case.
+	(memeql_sec_for_test): Wrapper to get valgrind to check for
+	side-channel silence.
+
+	* examples/rsa-decrypt.c (process_file): Use memeql_sec to check
+	the digest.
+
+	* memeql-sec.c (memeql_sec): New public function, moved from...
+	* ccm.c (memeql_sec): ... previous location.
+
+	* memops.h: New header file, generalizing memxor.h.
+
 2016-08-29  Niels Möller  &lt;nisse@lysator.liu.se&gt;
 
 	* sexp-format.c (strlen_u8): New helper function.
diff --git a/Makefile.in b/Makefile.in
index 9d47552..135542f 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -109,7 +109,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 knuth-lfib.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
-		 memxor.c memxor3.c \
+		 memeql-sec.c memxor.c memxor3.c \
 		 nettle-meta-aeads.c nettle-meta-armors.c \
 		 nettle-meta-ciphers.c nettle-meta-hashes.c \
 		 pbkdf2.c pbkdf2-hmac-sha1.c pbkdf2-hmac-sha256.c \
@@ -193,7 +193,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  macros.h \
 	  md2.h md4.h \
 	  md5.h md5-compat.h \
-	  memxor.h \
+	  memops.h memxor.h \
 	  nettle-meta.h nettle-types.h \
 	  pbkdf2.h \
 	  pgp.h pkcs1.h realloc.h ripemd160.h rsa.h \
diff --git a/ccm.c b/ccm.c
index b98bc9c..bdbd595 100644
--- a/ccm.c
+++ b/ccm.c
@@ -44,7 +44,7 @@
 #include "ccm.h"
 #include "ctr.h"
 
-#include "memxor.h"
+#include "memops.h"
 #include "nettle-internal.h"
 #include "macros.h"
 
@@ -246,19 +246,6 @@ ccm_encrypt_message(const void *cipher, nettle_cipher_func *f,
   ccm_digest(&amp;ctx, cipher, f, tlength, tag);
 }
 
-/* FIXME: Should be made public, under some suitable name. */
-static int
-memeql_sec (const void *a, const void *b, size_t n)
-{
-  volatile const unsigned char *ap = (const unsigned char *) a;
-  volatile const unsigned char *bp = (const unsigned char *) b;
-  volatile unsigned char d;
-  size_t i;
-  for (d = i = 0; i &lt; n; i++)
-    d |= (ap[i] ^ bp[i]);
-  return d == 0;
-}
-
 int
 ccm_decrypt_message(const void *cipher, nettle_cipher_func *f,
 		    size_t nlength, const uint8_t *nonce,
diff --git a/examples/rsa-decrypt.c b/examples/rsa-decrypt.c
index 0168821..94c2219 100644
--- a/examples/rsa-decrypt.c
+++ b/examples/rsa-decrypt.c
@@ -49,6 +49,7 @@
 #include "cbc.h"
 #include "hmac.h"
 #include "macros.h"
+#include "memops.h"
 #include "rsa.h"
 #include "yarrow.h"
 
@@ -189,7 +190,7 @@ process_file(struct rsa_session *ctx,
 	}
     }
   hmac_sha1_digest(&amp;ctx-&gt;hmac, SHA1_DIGEST_SIZE, digest);
-  if (memcmp(digest, buffer + AES_BLOCK_SIZE, SHA1_DIGEST_SIZE) != 0)
+  if (!memeql_sec(digest, buffer + AES_BLOCK_SIZE, SHA1_DIGEST_SIZE))
     {
       werror("Decryption failed: Invalid mac.\n");
       return 0;
diff --git a/memeql-sec.c b/memeql-sec.c
new file mode 100644
index 0000000..b19052e
--- /dev/null
+++ b/memeql-sec.c
@@ -0,0 +1,51 @@
+/* memeql-sec.c
+
+   Copyright (C) 2016 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "memops.h"
+
+int
+memeql_sec (const void *a, const void *b, size_t n)
+{
+  volatile const unsigned char *ap = (const unsigned char *) a;
+  volatile const unsigned char *bp = (const unsigned char *) b;
+
+  volatile unsigned char diff;
+  size_t i;
+
+  for (i = diff = 0; i &lt; n; i++)
+    diff |= (ap[i] ^ bp[i]);
+
+  return diff == 0;
+}
diff --git a/memops.h b/memops.h
new file mode 100644
index 0000000..8e40594
--- /dev/null
+++ b/memops.h
@@ -0,0 +1,51 @@
+/* memops.h
+
+   Copyright (C) 2016 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_MEMOPS_H_INCLUDED
+#define NETTLE_MEMOPS_H_INCLUDED
+
+#include "memxor.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define memeql_sec nettle_memeql_sec
+
+int
+memeql_sec (const void *a, const void *b, size_t n);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_MEMOPS_H_INCLUDED */
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 3c74b88..b263e1f 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -46,6 +46,9 @@ md5-test$(EXEEXT): md5-test.$(OBJEXT)
 md5-compat-test$(EXEEXT): md5-compat-test.$(OBJEXT)
 	$(LINK) md5-compat-test.$(OBJEXT) $(TEST_OBJS) -o md5-compat-test$(EXEEXT)
 
+memeql-test$(EXEEXT): memeql-test.$(OBJEXT)
+	$(LINK) memeql-test.$(OBJEXT) $(TEST_OBJS) -o memeql-test$(EXEEXT)
+
 memxor-test$(EXEEXT): memxor-test.$(OBJEXT)
 	$(LINK) memxor-test.$(OBJEXT) $(TEST_OBJS) -o memxor-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 02c18fc..689d432 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -16,7 +16,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    camellia-test.c chacha-test.c \
 		    des-test.c des3-test.c des-compat-test.c \
 		    md2-test.c md4-test.c md5-test.c md5-compat-test.c \
-		    memxor-test.c gosthash94-test.c \
+		    memeql-test.c memxor-test.c gosthash94-test.c \
 		    ripemd160-test.c \
 		    salsa20-test.c \
 		    sha1-test.c sha224-test.c sha256-test.c \
diff --git a/testsuite/memeql-test.c b/testsuite/memeql-test.c
new file mode 100644
index 0000000..356671d
--- /dev/null
+++ b/testsuite/memeql-test.c
@@ -0,0 +1,53 @@
+#include "testutils.h"
+#include "knuth-lfib.h"
+#include "memops.h"
+
+#if HAVE_VALGRIND_MEMCHECK_H
+# include &lt;valgrind/memcheck.h&gt;
+static int
+memeql_sec_for_test(const void *a, const void *b, size_t n)
+{
+  int res;
+
+  /* Makes valgrind trigger on any branches depending on the input
+     data. */
+  VALGRIND_MAKE_MEM_UNDEFINED (a, n);
+  VALGRIND_MAKE_MEM_UNDEFINED (b, n);
+
+  res = memeql_sec (a, b, n);
+  VALGRIND_MAKE_MEM_DEFINED (&amp;res, sizeof(res));
+  return res;
+}
+#else
+#define memeql_sec_for_test memeql_sec
+#endif
+
+#define MAX_SIZE 50
+void
+test_main(void)
+{
+  uint8_t orig[MAX_SIZE];
+  uint8_t a[MAX_SIZE];
+  uint8_t b[MAX_SIZE];
+  struct knuth_lfib_ctx random_ctx;
+
+  knuth_lfib_init (&amp;random_ctx, 11);
+
+  size_t size;
+  for (size = 0; size &lt; 50; size++)
+    {
+      size_t i;
+      uint8_t bit;
+      knuth_lfib_random (&amp;random_ctx, size, orig);
+      memcpy (a, orig, size);
+      memcpy (b, orig, size);
+      ASSERT (memeql_sec_for_test (a, b, size));
+      for (i = 0; i &lt; size; i++)
+	for (bit = 0x80; bit; bit &gt;&gt;= 1)
+	  {
+	    b[i] = orig[i] ^ bit;
+	    ASSERT (!memeql_sec_for_test (a, b, size));
+	    b[i] = orig[i];
+	  }
+    }
+}


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160712141303</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-07-12 14:13:03-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

On Mon, 2016-06-20 at 07:30 +0200, Niels Möller wrote:
&gt; I'm considering the below patch, making use of the side-channel
&gt; silent
&gt; mpz_powm_sec function. The idea is to make the RSA and DSA code less
&gt; vulnerable to side-channel attacks.
&gt; 
&gt; Exponentiation routines typically build a small table of powers at
&gt; run
&gt; time, and then look up exponent bits in the table, a few bits at the
&gt; time. This table lookup may leak information about the exponent bits
&gt; (which in the case of RSA and DSA are secret) to an attacker running
&gt; other processes on the same physical machine.
&gt; 
&gt; mpz_powm_sec uses a slower table-lookup function, which for each
&gt; lookup
&gt; does a sequential read of the entire table. Some caveats:
&gt; 
&gt; * The CRT code used for RSA signing uses other functions which may
&gt; leak,
&gt;   in particular division functions with branches depending on secret
&gt;   data.
&gt; 
&gt; * Since we still use the mpz interface rather than the mpn interface
&gt; in
&gt;   gmp, the exponents use a normalized size field (so top limb is
&gt;   non-zero). This might still leak information about the top exponent
&gt;   bits.
&gt; 
&gt; * The patch drops support for GMP versions older than GMP-5.0,
&gt; relased
&gt;   in 2010. 
&gt; 
&gt; * Mini-gmp builds don't try to be side-channel silent, they will use
&gt;   a #define mpz_powm_sec mpz_powm.
&gt; 
&gt; * I haven't yet had time to do proper benchmarks. Signing should get
&gt; a
&gt;   bit slower, but I don't know how much.
&gt; Despite not plugging *all* potential leaks in the RSA code, I think
&gt; the
&gt; simple change to use use mpz_powm_sec should make attacks using the
&gt; cache side-channel considerably more difficult.

+1


</body></email><email><emailId>20160717095441</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-07-17 09:54:41-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I'm considering the below patch, making use of the side-channel silent
&gt; mpz_powm_sec function. The idea is to make the RSA and DSA code less
&gt; vulnerable to side-channel attacks.

Committed and pushed now, with some additional fixes. 

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160729084558</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-07-29 08:45:58-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

On Mon, Jun 20, 2016 at 7:30 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt; I'm considering the below patch, making use of the side-channel silent
&gt; mpz_powm_sec function. The idea is to make the RSA and DSA code less
&gt; vulnerable to side-channel attacks.
&gt; Exponentiation routines typically build a small table of powers at run
&gt; time, and then look up exponent bits in the table, a few bits at the
&gt; time. This table lookup may leak information about the exponent bits
&gt; (which in the case of RSA and DSA are secret) to an attacker running
&gt; other processes on the same physical machine.

I've checked the patch, and it seems to use mpz_powm_sec() in the
blinding part (which uses only public parameters). Is that
intentional? As far as that shouldn't affect the existing
cache-exploiting attacks.

regards,
Nikos

</body></email><email><emailId>20160730005912</emailId><senderName>Hanno =?UTF-8?B?QsO2Y2s=?=</senderName><senderEmail>hanno@hboeck.de</senderEmail><timestampReceived>2016-07-30 00:59:12-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

This is a MIME-formatted message.  If you see this text it means that your
E-mail software does not support MIME-formatted messages.


Hi,

On Mon, 20 Jun 2016 07:30:47 +0200
nisse@lysator.liu.se (Niels Möller) wrote:

&gt; I'm considering the below patch, making use of the side-channel silent
&gt; mpz_powm_sec function. The idea is to make the RSA and DSA code less
&gt; vulnerable to side-channel attacks.

This change introduces a security risk.

The function mpz_powm_sec() is not a drop in replacement for mpz_powm(),
although it may sound like it. If you look at the docs [1] a
requirement for mpz_powm_sec() is that the modulus must be odd.

If the modulus is even / divisible by 2 then mpz_powm_sec() will crash
with a floating point exception.
Quite frankly, I think this is bad from GMPs side as well. At the very
least it shouldn't crash for invalid inputs, but return an error.
(Ideally it would just work for all inputs that mathematically make
sense). But nettle has to handle things with gmp as they are.

Attached is a certificate + key where I manually changed the modulus to
be even (P.S.: This tool [2] fis very useful for such cases). The
certificate is therefore obviously bogus, but that doesn't matter in
our case.

Just try to run nettle with the mpz_powm_sec() patch and try to run
gnutls with this crafted cert:
gnutls-serv --x509keyfile=crashnettle.pem --x509certfile=crashnettle.pem

This crashes as expected with a floating point exception.

Now it may not be obvious that this is a security risk, because I
usually control my own certificates. But there may well be situations
where that's not so clear. E.g. think of a webhoster that allows his
customers to set custom certificates and private keys. That doesn't
mean one wants his customers to allow crashing the servers.

It may be that there are other situations where this matters.

Anyway: Changing to mpz_pown_sec() probably should only be done if the
code is carefully checked to make sure that an even modulus never enters
this function.


(P.S.: The autoconf gmp detection part of this patch breaks on my
system and nettle gets built without gmp, so there seems to be
something wrong with that, too. I have Gentoo with gmp 6.1.1. I
haven't further analyzed this, I simply removed that part of the patch
for my testing.)


[1] https://gmplib.org/manual/Integer-Exponentiation.html
[2] https://github.com/google/der-ascii

-- 
Hanno Böck
https://hboeck.de/

mail/jabber: hanno@hboeck.de
GPG: BBB51E42

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20160730092209</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-07-30 09:22:09-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; I've checked the patch, and it seems to use mpz_powm_sec() in the
&gt; blinding part (which uses only public parameters). Is that
&gt; intentional? 

Kind-of, I wasn't sure what to do here, but since the number r should
be considered secret, it seemed safest.

Let me first recap my understanding if RSA blinding (which I find a bit
questionable). When computing m^d (mod n), the point of blinding is to
obscure the bits of m, not the bits if d. It adds no protection against
side-channel attacks directly on the exponent bits, since they're the
same before and after blinding. The point of blinding is instead to
defend against attacks exploiting side-channnel leaks in the mod p
reduction code, which typically depend on a chosen-ciphertect attack
scenario or similar, where m is carefully chosen by the attacker. Do you
agree?

Since the secret value r goes into the input that blinding tries to
obscure, using powm_sec makes sme sense to me, even if it may be
overkill.

Now, in recent GMP versions, powm_sec uses a reduction method which is
intended to be side-channel silent. So when using it, blinding is
perhaps not adding any benefit at all. But I think it's best to
nevertheless keep RSA-bliding for now, as a belt-and-suspenders measure.
And because I'd prefer not to have to think of the PR issues when
deleting a established security feature...

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160730093839</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-07-30 09:38:39-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

Hanno Böck &lt;hanno@hboeck.de&gt; writes:

&gt; If the modulus is even / divisible by 2 then mpz_powm_sec() will crash
&gt; with a floating point exception.
&gt; Quite frankly, I think this is bad from GMPs side as well. At the very
&gt; least it shouldn't crash for invalid inputs, but return an error.

I think the GMP design is to leave any easy sanity checks to the
application. While for more complex conditions, like modular inversion
(which fails if inputs have any non-trivial common factor), gmp checks
for this and returns an error indication.

&gt; (Ideally it would just work for all inputs that mathematically make
&gt; sense). But nettle has to handle things with gmp as they are.

I think it should be easy and reasonable to add code to
rsa_public_key_prepare and rsa_private_key_prepare to check that the
modulo is odd. What do you think? It's reasonable to have those
functions do enough key validation to be able to handle the key without
crashing.

&gt; Attached is a certificate + key where I manually changed the modulus to
&gt; be even (P.S.: This tool [2] fis very useful for such cases). The
&gt; certificate is therefore obviously bogus, but that doesn't matter in
&gt; our case.

If you can transform this into a nettle testcase, that would be nice. I
think it would fit best either with the high-level tests
examples/rsa-sign-test and examples/rsa-verify-test, or as unit tests in
testsuite/rsa-test.c.

&gt; (P.S.: The autoconf gmp detection part of this patch breaks on my
&gt; system and nettle gets built without gmp,

With the patch as posted to the list, or using the master branch of the
repo? I'm aware of configure bugs in the former but not the latter.

Thanks for the review,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160731084401</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-07-31 08:44:01-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I think it should be easy and reasonable to add code to
&gt; rsa_public_key_prepare and rsa_private_key_prepare to check that the
&gt; modulo is odd. What do you think? It's reasonable to have those
&gt; functions do enough key validation to be able to handle the key without
&gt; crashing.

Done now (or rather, added to the shared helper function _rsa_check_size).

&gt;&gt; Attached is a certificate + key where I manually changed the modulus to
&gt;&gt; be even (P.S.: This tool [2] fis very useful for such cases). The
&gt;&gt; certificate is therefore obviously bogus, but that doesn't matter in
&gt;&gt; our case.

Any other easy checks for bogus keys that should be added? I would
expect that code parsing key formats, e.g., asn.1, would check sign and
range of parameters and catch bogus values early (e.g., the code in
nettle's der2rsa.c does that). It's possible to add additional sanity
checks to the _key_prepare functions, if desired. It's not entirely
obvious where that responsibility should be placed.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160731094131</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-07-31 09:41:31-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

On Sun, Jul 31, 2016 at 10:44 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:
&gt;&gt;&gt; Attached is a certificate + key where I manually changed the modulus to
&gt;&gt;&gt; be even (P.S.: This tool [2] fis very useful for such cases). The
&gt;&gt;&gt; certificate is therefore obviously bogus, but that doesn't matter in
&gt;&gt;&gt; our case.
&gt; Any other easy checks for bogus keys that should be added? I would
&gt; expect that code parsing key formats, e.g., asn.1, would check sign and
&gt; range of parameters and catch bogus values early (e.g., the code in
&gt; nettle's der2rsa.c does that). It's possible to add additional sanity
&gt; checks to the _key_prepare functions, if desired. It's not entirely
&gt; obvious where that responsibility should be placed.

It depends what that means. Would these values cause a crash or a
function to return an error? Also unless they are well documented in
the nettle API documentation, I wouldn't expect the caller to know the
constraints of the underlying gmp API.

regards,
Nikos

</body></email><email><emailId>20160731133102</emailId><senderName>Hanno =?UTF-8?B?QsO2Y2s=?=</senderName><senderEmail>hanno@hboeck.de</senderEmail><timestampReceived>2016-07-31 13:31:02-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

This is a MIME-formatted message.  If you see this text it means that your
E-mail software does not support MIME-formatted messages.


On Sun, 31 Jul 2016 10:44:01 +0200
nisse@lysator.liu.se (Niels Möller) wrote:

&gt; Done now (or rather, added to the shared helper function
&gt; _rsa_check_size).

I think this is incomplete. Looking at the patch:
https://git.lysator.liu.se/nettle/nettle/commit/5eb30d94f6f5f3f0cb9ba9ed24bc52b7376176b6

You're only checking n (for both private and public keys), I could
probably still craft a private key that crashes by choosing one of p or
q to be even.

&gt; Any other easy checks for bogus keys that should be added? I would
&gt; expect that code parsing key formats, e.g., asn.1, would check sign
&gt; and range of parameters and catch bogus values early (e.g., the code
&gt; in nettle's der2rsa.c does that). It's possible to add additional
&gt; sanity checks to the _key_prepare functions, if desired.

Depends on how far you want to go.
Easy checks:
* d, e must not be 0, 1, 2

More expensive checks:
* Make sure n = p * q
* p, q prime


&gt; It's not
&gt; entirely obvious where that responsibility should be placed.

Yeah, I've been thinking a bit about it yesterday, I could still see
problems with this approach.
E.g. imagine someone does sanity checks with openssl and then assumes
the key can be used with a nettle-based TLS stack. Even if we prevent
it from crashing it may still prevent something from starting.

I ended up wishing that there'd be a defined standard set of key sanity
checks shared among implementations... but I'm probably just dreaming
here...

-- 
Hanno Böck
https://hboeck.de/

mail/jabber: hanno@hboeck.de
GPG: BBB51E42

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20160801073027</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-08-01 07:30:27-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

On Sun, Jul 31, 2016 at 10:44 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:
&gt; nisse@lysator.liu.se (Niels M=C3=B6ller) writes:
&gt;
&gt;&gt; I think it should be easy and reasonable to add code to
&gt;&gt; rsa_public_key_prepare and rsa_private_key_prepare to check that the
&gt;&gt; modulo is odd. What do you think? It's reasonable to have those
&gt;&gt; functions do enough key validation to be able to handle the key without
&gt;&gt; crashing.
&gt; Done now (or rather, added to the shared helper function _rsa_check_size)=
.

But where is this helper function used? As far as I see it is not used
by rsa_pkcs1_verify() or similar functions, and it only applies if
rsa_public_key_prepare() is used; otherwise the crash still applies.
Gnutls for example doesn't use any of the *prepare functions.

regards,
Nikos

</body></email><email><emailId>20160801075915</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-08-01 07:59:15-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; But where is this helper function used? As far as I see it is not used
&gt; by rsa_pkcs1_verify() or similar functions, and it only applies if
&gt; rsa_public_key_prepare() is used; otherwise the crash still applies.

Correct.

&gt; Gnutls for example doesn't use any of the *prepare functions.

I think it should. It's a fairly well documented requirement:

:    When you have assigned values to the attributes of a key, you must
: call
: 
:  -- Function: int rsa_public_key_prepare (struct rsa_public_key *PUB)
:  -- Function: int rsa_private_key_prepare (struct rsa_private_key *KEY)
:      Computes the octet size of the key (stored in the ‘size' attribute,
:      and may also do other basic sanity checks.  Returns one if
:      successful, or zero if the key can't be used, for instance if the
:      modulo is smaller than the minimum size needed for RSA operations
:      specified by PKCS#1.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160801091610</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-08-01 09:16:10-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

On Mon, Aug 1, 2016 at 9:59 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; wr=
ote:
&gt;&gt; Gnutls for example doesn't use any of the *prepare functions.
&gt;
&gt; I think it should. It's a fairly well documented requirement:
&gt; :    When you have assigned values to the attributes of a key, you must
&gt; : call

That can certainly be done on future versions; however it also means
that if nettle is updated without an update on gnutls, the fix for
cache silence may bring more issues than it solves.

regards,
Nikos

</body></email><email><emailId>20160803085344</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-08-03 08:53:44-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; That can certainly be done on future versions; however it also means
&gt; that if nettle is updated without an update on gnutls, the fix for
&gt; cache silence may bring more issues than it solves.

I guess one can add some workaround for applications, in particuar
gnutls, which don't use _prepare. But please fix that before you make
the next release.

Do you think it is sufficient for gnutls to add an extra check that p
and q are odd in nettle's rsa_compute_root? (Used also by
rsa_compute_root_tr).

Regards, 
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160804065722</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-08-04 06:57:22-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

On Wed, Aug 3, 2016 at 10:53 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt; I guess one can add some workaround for applications, in particuar
&gt; gnutls, which don't use _prepare. But please fix that before you make
&gt; the next release.

My main concern is that rsa_private_key_prepare() multiplies q and p,
and for gnutls it is a temporary object, i.e., constructed on the fly
from the internal format for keys that gnutls uses. Switching to this
function would mean an additional multiplication per RSA operation.
The equivalent public key function is fine to use.

Said that, I have already replaced the manual setting of size with a
call to the prepare functions, but I'd prefer the prepare functions to
come at no significant cost (especially since when calling prepare I
already know the size of n).

&gt; Do you think it is sufficient for gnutls to add an extra check that p
&gt; and q are odd in nettle's rsa_compute_root? (Used also by
&gt; rsa_compute_root_tr).

It makes sense for sanity check reasons as well (detect broken keys
early rather than late).

regards,
Nikos

</body></email><email><emailId>20160804075312</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-08-04 07:53:12-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; My main concern is that rsa_private_key_prepare() multiplies q and p,

I don't quite like that either, but I don't think it matters much for
performance. The time for that multiplication is only a tiny fraction of
the time needed to create a single signature.

It's needed to get the correct octet size of n. And it's possible to get
rid of it in the common cases, although I'm not sure it's worth the
effort.

Say sp is the bit size of p and sq is the bit size of q. Then sn, the
bit size of n, is either sp + sq, or sp + sq - 1. And the octet size is
ceil (sn / 8).

Now for typical RSA keys, p and q both have the top 2 bits set, and then
we know that sn = sp + sq. Furthermore, typically sp + sq is a multiple
of 8, but ceil ((sp + sq - 1)/8) differs from ceil ((sp + sq)/8) only if
sp + sq = 1 (mod 8).

&gt;&gt; Do you think it is sufficient for gnutls to add an extra check that p
&gt;&gt; and q are odd in nettle's rsa_compute_root? (Used also by
&gt;&gt; rsa_compute_root_tr).
&gt;
&gt; It makes sense for sanity check reasons as well (detect broken keys
&gt; early rather than late).

I'll add that then.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160804080529</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-08-04 08:05:29-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Do you think it is sufficient for gnutls to add an extra check that p
&gt; and q are odd in nettle's rsa_compute_root? (Used also by
&gt; rsa_compute_root_tr).

On second look, it can't be rsa_compute_root, since that function has no
return value. Is it sufficient for gnutls to do this check in
rsa_compute_root_tr instead?

I also note that a check is needed in dsa_sign, which otherwise would
crash if the group is invalid, with an even p.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160804082741</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-08-04 08:27:41-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; On second look, it can't be rsa_compute_root, since that function has no
&gt; return value. Is it sufficient for gnutls to do this check in
&gt; rsa_compute_root_tr instead?
&gt;
&gt; I also note that a check is needed in dsa_sign, which otherwise would
&gt; crash if the group is invalid, with an even p.

I've comitted additional checks to dsa_sign and rsa_compute_root_tr.

I have one remaining question: Should there be additional sanity checks
in the rsa_*_prepare functions, to reject keys with negative or
out-of-range parameters? Out-of-range parameters will not, as far as I
am aware, result in any crashes, only in bogus outputs.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160804112110</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-08-04 11:21:10-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

On Thu, 2016-08-04 at 10:05 +0200, Niels Möller wrote:
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt; &gt; 
&gt; &gt; Do you think it is sufficient for gnutls to add an extra check that
&gt; &gt; p
&gt; &gt; and q are odd in nettle's rsa_compute_root? (Used also by
&gt; &gt; rsa_compute_root_tr).
&gt; 
&gt; On second look, it can't be rsa_compute_root, since that function has
&gt; no return value. Is it sufficient for gnutls to do this check in
&gt; rsa_compute_root_tr instead?

Yes. Although if this is only for the versions prior to using the
prepare function, this is not a significant threat (the private key
computations are typically done on trusted values by the server).

What is more important for older versions of gnutls are the public key
operations such as  ecdsa_verify(), dsa_verify() and rsa_encrypt().


regards,
Nikos


</body></email><email><emailId>20160805065528</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-08-05 06:55:28-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

On Thu, 2016-08-04 at 09:53 +0200, Niels Möller wrote:

&gt; &gt; My main concern is that rsa_private_key_prepare() multiplies q and
&gt; &gt; p,
&gt; 
&gt; I don't quite like that either, but I don't think it matters much for
&gt; performance. The time for that multiplication is only a tiny fraction
&gt; of the time needed to create a single signature.

That's correct, but it still bugs me as a cost that gets added into
busy servers. What about adding a version of prepare that takes both
the public key and the pubkey as in the attached patch?

regards,
Nikos

["0001-Added-rsa_private_key_prepare2.patch" (0001-Added-rsa_private_key_prepare2.patch)]

From 40b6546cfeb45e48bfa616cb96b36873ec58ea33 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Fri, 5 Aug 2016 08:50:38 +0200
Subject: [PATCH] Added rsa_private_key_prepare2

This function behaves as rsa_private_key_prepare but does not
need to calculate n from p and q.
---
 nettle.texinfo | 4 +++-
 rsa-sign.c     | 8 ++++++++
 rsa.h          | 4 ++++
 3 files changed, 15 insertions(+), 1 deletion(-)

diff --git a/nettle.texinfo b/nettle.texinfo
index e539dbe..5e416c5 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -3645,8 +3645,10 @@ When you have assigned values to the attributes of a key, you \
must call  
 @deftypefun int rsa_public_key_prepare (struct rsa_public_key *@var{pub})
 @deftypefunx int rsa_private_key_prepare (struct rsa_private_key *@var{key})
+@deftypefunx int rsa_private_key_prepare2 (struct rsa_private_key *@var{key}, const \
struct rsa_public_key *@var{pub})  Computes the octet size of the key (stored in the \
                @code{size} attribute,
-and may also do other basic sanity checks. Returns one if successful, or
+and may also do other basic sanity checks. @code{rsa_private_key_prepare2}
+is an optimized version of @code{rsa_private_key_prepare}. Return one if successful, \
or  zero if the key can't be used, for instance if the modulo is smaller
 than the minimum size needed for @acronym{RSA} operations specified by PKCS#1.
 @end deftypefun
diff --git a/rsa-sign.c b/rsa-sign.c
index 4832352..18eb635 100644
--- a/rsa-sign.c
+++ b/rsa-sign.c
@@ -84,6 +84,14 @@ rsa_private_key_prepare(struct rsa_private_key *key)
   return (key-&gt;size &gt; 0);
 }
 
+int
+rsa_private_key_prepare2(struct rsa_private_key *key, const struct rsa_public_key \
*pub) +{
+  key-&gt;size = _rsa_check_size(pub-&gt;n);
+
+  return (key-&gt;size &gt; 0);
+}
+
 /* Computing an rsa root. */
 void
 rsa_compute_root(const struct rsa_private_key *key,
diff --git a/rsa.h b/rsa.h
index 6d2574b..4e31e6d 100644
--- a/rsa.h
+++ b/rsa.h
@@ -52,6 +52,7 @@ extern "C" {
 #define rsa_private_key_init nettle_rsa_private_key_init
 #define rsa_private_key_clear nettle_rsa_private_key_clear
 #define rsa_private_key_prepare nettle_rsa_private_key_prepare
+#define rsa_private_key_prepare2 nettle_rsa_private_key_prepare2
 #define rsa_pkcs1_verify nettle_rsa_pkcs1_verify
 #define rsa_pkcs1_sign nettle_rsa_pkcs1_sign
 #define rsa_pkcs1_sign_tr nettle_rsa_pkcs1_sign_tr
@@ -187,6 +188,9 @@ rsa_private_key_clear(struct rsa_private_key *key);
 int
 rsa_private_key_prepare(struct rsa_private_key *key);
 
+int
+rsa_private_key_prepare2(struct rsa_private_key *key, const struct rsa_public_key \
*pub); +
 
 /* PKCS#1 style signatures */
 int
-- 
2.7.4



</body></email><email><emailId>20160805075613</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-08-05 07:56:13-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; That's correct, but it still bugs me as a cost that gets added into
&gt; busy servers.

But only once per hostkey and server restart, right?

&gt; What about adding a version of prepare that takes both
&gt; the public key and the pubkey as in the attached patch?

Makes some sense. But I wonder what the failure mode is if the input
keys don't match, so that the rsa_private_key struct ends up with an
incorrect size field?

One could also have an rsa_keypair_prepare that takes a pair of private and
public keys, instead of calling the other two prepare functions. Similar
issues if keys don't match as they are supposed to.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160805080413</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-08-05 08:04:13-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; Yes. Although if this is only for the versions prior to using the
&gt; prepare function, this is not a significant threat (the private key
&gt; computations are typically done on trusted values by the server).

One scanario is a web hosting provider that handles private server keys
provided by untrusted customers. No idea how common that is, but one
wouldn't want one customer to crash the webserver also used by others.

&gt; What is more important for older versions of gnutls are the public key
&gt; operations such as  ecdsa_verify(), dsa_verify() and rsa_encrypt().

Now I'm confused, I hope I didn't introduce any mpz_powm_sec calls on
the code paths operating on public keys only? I don't think we have to
care too much about obscure use cases where the supposedly public
exponent actually needs to be well protected.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160805105220</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-08-05 10:52:20-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

On Fri, 2016-08-05 at 09:56 +0200, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; 
&gt; &gt; 
&gt; &gt; That's correct, but it still bugs me as a cost that gets added into
&gt; &gt; busy servers.
&gt; 
&gt; But only once per hostkey and server restart, right?

As it is now I do not set the size explicitly and call the prepare
function on every RSA operation (sign/decrypt).

&gt; &gt; What about adding a version of prepare that takes both
&gt; &gt; the public key and the pubkey as in the attached patch?
&gt; Makes some sense. But I wonder what the failure mode is if the input
&gt; keys don't match, so that the rsa_private_key struct ends up with an
&gt; incorrect size field?

That's correct, but I think that's the responsibility of the caller to
supply the corresponding keys.

regards,
Nikos


</body></email><email><emailId>20160805105418</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-08-05 10:54:18-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

On Fri, 2016-08-05 at 10:04 +0200, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; 
&gt; &gt; 
&gt; &gt; Yes. Although if this is only for the versions prior to using the
&gt; &gt; prepare function, this is not a significant threat (the private key
&gt; &gt; computations are typically done on trusted values by the server).
&gt; One scanario is a web hosting provider that handles private server
&gt; keys
&gt; provided by untrusted customers. No idea how common that is, but one
&gt; wouldn't want one customer to crash the webserver also used by
&gt; others.

right.

&gt; &gt; What is more important for older versions of gnutls are the public
&gt; &gt; key
&gt; &gt; operations such as  ecdsa_verify(), dsa_verify() and rsa_encrypt().
&gt; 
&gt; Now I'm confused, I hope I didn't introduce any mpz_powm_sec calls on
&gt; the code paths operating on public keys only? I don't think we have
&gt; to care too much about obscure use cases where the supposedly public
&gt; exponent actually needs to be well protected.

Correct, it seems I replied prior to thinking.

regards,
Nikos


</body></email><email><emailId>20160805185735</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-08-05 18:57:35-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; On Fri, 2016-08-05 at 09:56 +0200, Niels Möller wrote:
&gt;&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt;&gt; 
&gt;&gt; &gt; 
&gt;&gt; &gt; That's correct, but it still bugs me as a cost that gets added into
&gt;&gt; &gt; busy servers.
&gt;&gt; 
&gt;&gt; But only once per hostkey and server restart, right?
&gt;
&gt; As it is now I do not set the size explicitly and call the prepare
&gt; function on every RSA operation (sign/decrypt).

Hmm. I'd imagine that you would create and initialize nettle's struct
rsa_public_key and rsa_private_key at the time you read the key files on
disk, and then that's also the right time to call _prepare. Is tharre
any reason it's hard to organize that way?

&gt; That's correct, but I think that's the responsibility of the caller to
&gt; supply the corresponding keys.

But I think we'de want to ensure that nettle doesn't crash; an
application should be able to read key files controlled by an attacker
and use them with nettle without crashing (bogus outputs are of course
expected).

And I feel a little uneasy about ensuring that nettle's rsa functions
work without crashing if the size field is too large or too small; that
violates assumptions I made when writing the code quite some time ago...
It might be not too difficult, but I'd feel better about having the
_prepare functions be responsible for setting the size correctly.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160526071621</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-05-26 07:16:21-0400</timestampReceived><subject>Re: Porting openssl code to nettle</subject><body>

Aaron Boxer &lt;boxerab@gmail.com&gt; writes:

&gt; Hello!
&gt;
&gt; I am porting some openssl code to nettle. It involves working with SHA1
&gt; keys.
&gt; What would people recommend as a guide to doing this port? 

[...]

&gt; https://github.com/GrokImageCompression/asdcplib/blob/master/src/KM_prng.cpp

For SHA1 and AES, start by checking the Nettle manual and the sha1
example program:

https://www.lysator.liu.se/~nisse/nettle/nettle.html#Example
https://www.lysator.liu.se/~nisse/nettle/nettle.html#Conventions
https://www.lysator.liu.se/~nisse/nettle/nettle.html#AES
https://www.lysator.liu.se/~nisse/nettle/nettle.html#SHA1

Then your Gen_FIPS_186_Value function also uses some basic bignum
arithmetic. You'd need to rewrite this to use GNU GMP, and I guess you'd
want to use the C++ interface, gmpxx.h, which I'm not very familiar
with. See
https://gmplib.org/manual/C_002b_002b-Interface-Integers.html#C_002b_002b-Interface-Integers

Not sure how to do base256 conversion (the BN_bin2bn and BN_bn2bin
in openssl) in the C++ interface, you may need to use the functions
mpz_import and mpz_export on the underlying C type mpz_t.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160526133417</emailId><senderName>Aaron Boxer</senderName><senderEmail>boxerab@gmail.com</senderEmail><timestampReceived>2016-05-26 13:34:17-0400</timestampReceived><subject>Re: Porting openssl code to nettle</subject><body>

Hi Niels,

Thanks so much for your replay.
I stayed with the c interface, and I think I correctly ported most of the
code, following your
guides.

The only remaining issue is converting between big endian byte arrays and
gmp types, but I have
asked about this on the gmp forum.

Would you be able to do a quick review of the port once I am done?

Thanks again,
Aaron



On Thu, May 26, 2016 at 3:16 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; Aaron Boxer &lt;boxerab@gmail.com&gt; writes:
&gt;
&gt; &gt; Hello!
&gt; &gt;
&gt; &gt; I am porting some openssl code to nettle. It involves working with SHA1
&gt; &gt; keys.
&gt; &gt; What would people recommend as a guide to doing this port?
&gt;
&gt; [...]
&gt;
&gt; &gt;
&gt; https://github.com/GrokImageCompression/asdcplib/blob/master/src/KM_prng.=
cpp
&gt;
&gt; For SHA1 and AES, start by checking the Nettle manual and the sha1
&gt; example program:
&gt;
&gt; https://www.lysator.liu.se/~nisse/nettle/nettle.html#Example
&gt; https://www.lysator.liu.se/~nisse/nettle/nettle.html#Conventions
&gt; https://www.lysator.liu.se/~nisse/nettle/nettle.html#AES
&gt; https://www.lysator.liu.se/~nisse/nettle/nettle.html#SHA1
&gt;
&gt; Then your Gen_FIPS_186_Value function also uses some basic bignum
&gt; arithmetic. You'd need to rewrite this to use GNU GMP, and I guess you'd
&gt; want to use the C++ interface, gmpxx.h, which I'm not very familiar
&gt; with. See
&gt;
&gt; https://gmplib.org/manual/C_002b_002b-Interface-Integers.html#C_002b_002b=
-Interface-Integers
&gt;
&gt; Not sure how to do base256 conversion (the BN_bin2bn and BN_bn2bin
&gt; in openssl) in the C++ interface, you may need to use the functions
&gt; mpz_import and mpz_export on the underlying C type mpz_t.
&gt;
&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels M=C3=B6ller. PGP-encrypted email is preferred. Keyid C0B98E26.
&gt; Internet email is subject to wholesale government surveillance.
&gt;

</body></email><email><emailId>20160526134758</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-05-26 13:47:58-0400</timestampReceived><subject>Re: Porting openssl code to nettle</subject><body>

Aaron Boxer &lt;boxerab@gmail.com&gt; writes:

&gt; The only remaining issue is converting between big endian byte arrays and
&gt; gmp types, but I have
&gt; asked about this on the gmp forum.

For an example, you can also look at the nettle_mpz_to_octets and
nettle_mpz_from_octets functions in
https://git.lysator.liu.se/nettle/nettle/blob/master/bignum.c. If you
use the mpz_ interface (not mpn_), mpz_import and mpz_export are the
functions to use.

&gt; Would you be able to do a quick review of the port once I am done?

I could probably do a basic review.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160526140751</emailId><senderName>Aaron Boxer</senderName><senderEmail>boxerab@gmail.com</senderEmail><timestampReceived>2016-05-26 14:07:51-0400</timestampReceived><subject>Re: Porting openssl code to nettle</subject><body>

On Thu, May 26, 2016 at 9:47 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; Aaron Boxer &lt;boxerab@gmail.com&gt; writes:
&gt;
&gt; &gt; The only remaining issue is converting between big endian byte arrays a=
nd
&gt; &gt; gmp types, but I have
&gt; &gt; asked about this on the gmp forum.
&gt;
&gt; For an example, you can also look at the nettle_mpz_to_octets and
&gt; nettle_mpz_from_octets functions in
&gt; https://git.lysator.liu.se/nettle/nettle/blob/master/bignum.c. If you
&gt; use the mpz_ interface (not mpn_), mpz_import and mpz_export are the
&gt; functions to use.
&gt;


Thanks, I will try this.  I am also having trouble with the BN_num_bytes
method.
Do you know of an equivalent method in gmp ?


&gt; &gt; Would you be able to do a quick review of the port once I am done?
&gt;
&gt; I could probably do a basic review.
&gt;
&gt; Even a 5 minute review would be very much appreciated.

Regards,
Aaron

</body></email><email><emailId>20160526173822</emailId><senderName>Aaron Boxer</senderName><senderEmail>boxerab@gmail.com</senderEmail><timestampReceived>2016-05-26 17:38:22-0400</timestampReceived><subject>Re: Porting openssl code to nettle</subject><body>

Niels,
Here is a link to my changes, if you have time to take a look.

https://github.com/GrokImageCompression/asdcplib/commit/39cbb6188bce7112d82=
6e6045cb739bfd1c8653b

Thanks again,
Aaron

On Thu, May 26, 2016 at 9:47 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; Aaron Boxer &lt;boxerab@gmail.com&gt; writes:
&gt;
&gt; &gt; The only remaining issue is converting between big endian byte arrays a=
nd
&gt; &gt; gmp types, but I have
&gt; &gt; asked about this on the gmp forum.
&gt;
&gt; For an example, you can also look at the nettle_mpz_to_octets and
&gt; nettle_mpz_from_octets functions in
&gt; https://git.lysator.liu.se/nettle/nettle/blob/master/bignum.c. If you
&gt; use the mpz_ interface (not mpn_), mpz_import and mpz_export are the
&gt; functions to use.
&gt;
&gt; &gt; Would you be able to do a quick review of the port once I am done?
&gt;
&gt; I could probably do a basic review.
&gt;
&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels M=C3=B6ller. PGP-encrypted email is preferred. Keyid C0B98E26.
&gt; Internet email is subject to wholesale government surveillance.
&gt;

</body></email><email><emailId>20160526213451</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-05-26 21:34:51-0400</timestampReceived><subject>Re: Porting openssl code to nettle</subject><body>

Aaron Boxer &lt;boxerab@gmail.com&gt; writes:

&gt; Thanks, I will try this.  I am also having trouble with the BN_num_bytes
&gt; method.
&gt; Do you know of an equivalent method in gmp ?

You'd use something like (mpz_sizeinbase(x, 2) + 7) / 8. 

But in your code, don't you know the byte size a priori?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160530135733</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-05-30 13:57:33-0400</timestampReceived><subject>Re: Porting openssl code to nettle</subject><body>

Aaron Boxer &lt;boxerab@gmail.com&gt; writes:

&gt; Here is a link to my changes, if you have time to take a look.
&gt;
&gt; https://github.com/GrokImageCompression/asdcplib/commit/39cbb6188bce7112d826e6045cb739bfd1c8653b

I've had a quick look. I'm assuming you intend to delete the commented
out parts, so I'm not saying anything more about them? 

src/AS_DCP_AES.cpp:

* If you use only 128-bit aes, then it's better to use the aes128_ctx
  and related functions. aes_ctx should be used only if for some reason
  you really need an interface with variable key size at runtime.

* The m_KeyBuf member variable seems useless.

* You may want to use nettle's HMAC implementation, instead of
  implementing it yourself.

src/KM_prng.cpp:

+    sha1_update(&amp;SHA, sizeof(m_Context), (byte_t*)&amp;m_Context );

This won't work, m_Context is an aes_ctx, and you'll get different
results on big-endian and little-endian. Worse, it has space for more
subkeys than are used for aes128, so you will hash uninitialized data.
You probably want to hash the original, unexpanded, 128-bit key?

+    sha1_digest(&amp;SHA,SHA1_DIGEST_SIZE, sha_buf);

I tend to use the style 

     sha1_digest (sizeof(sha_buf), sha_buf);

+    aes_set_encrypt_key(&amp;m_Context, RNG_KEY_SIZE_BITS, sha_buf);

Size argument to aes_set_encrypt_key is in octets, not bits. (And if you
use aes128_set_encrypt_key instead, as I suggest, there's no size
argument).

+	aes_encrypt(&amp;m_Context,AES128_KEY_SIZE, buf + gen_count,  m_ctr_buf);

AES128_KEYSIZE here looks a bit strange. sizeof(m_ctr_buf)? (Even if the
value, 16, is intentionally the same).

Delete the code computing c_2powb, and use mpz_fdiv_r_2exp instead of
mpz_mod.

You don't need bn_tmp, the mpz interface allows in-place operations.

Dob't access _mp_size field, if you really want the (platform dependent)
limb size, use the mpz_size function. But generally, mpz_sizeinbase is
more useful.

I don't think your use of mpz_export is correct in the case that the
base-256 representation has leading zeros. I think you need to handle
the zero-padding yourself (or maybe the initial memset is enough? But
for big-endian, you still have to know the number of leading zeros).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160530150637</emailId><senderName>Aaron Boxer</senderName><senderEmail>boxerab@gmail.com</senderEmail><timestampReceived>2016-05-30 15:06:37-0400</timestampReceived><subject>Re: Porting openssl code to nettle</subject><body>

Niels,

Thank you so much for taking the time to look at my code.
I really do appreciate it.

I have made the modifications you suggested on AS_DCP_AES.cpp file,
and pushed to github.

For KM_prng.cpp , are you suggesting that I use 128 bit AES instead of 256
bit ?
I think the original code used 256 bit.

Still working on the mpz changes that you suggested.

Thanks again,
Aaron





On Mon, May 30, 2016 at 9:57 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; Aaron Boxer &lt;boxerab@gmail.com&gt; writes:
&gt;
&gt; &gt; Here is a link to my changes, if you have time to take a look.
&gt; &gt;
&gt; &gt;
&gt; https://github.com/GrokImageCompression/asdcplib/commit/39cbb6188bce7112d=
826e6045cb739bfd1c8653b
&gt;
&gt; I've had a quick look. I'm assuming you intend to delete the commented
&gt; out parts, so I'm not saying anything more about them?
&gt;
&gt; src/AS_DCP_AES.cpp:
&gt;
&gt; * If you use only 128-bit aes, then it's better to use the aes128_ctx
&gt;   and related functions. aes_ctx should be used only if for some reason
&gt;   you really need an interface with variable key size at runtime.
&gt;
&gt; * The m_KeyBuf member variable seems useless.
&gt;
&gt; * You may want to use nettle's HMAC implementation, instead of
&gt;   implementing it yourself.
&gt;
&gt; src/KM_prng.cpp:
&gt;
&gt; +    sha1_update(&amp;SHA, sizeof(m_Context), (byte_t*)&amp;m_Context );
&gt;
&gt; This won't work, m_Context is an aes_ctx, and you'll get different
&gt; results on big-endian and little-endian. Worse, it has space for more
&gt; subkeys than are used for aes128, so you will hash uninitialized data.
&gt; You probably want to hash the original, unexpanded, 128-bit key?
&gt;
&gt; +    sha1_digest(&amp;SHA,SHA1_DIGEST_SIZE, sha_buf);
&gt;
&gt; I tend to use the style
&gt;
&gt;      sha1_digest (sizeof(sha_buf), sha_buf);
&gt;
&gt; +    aes_set_encrypt_key(&amp;m_Context, RNG_KEY_SIZE_BITS, sha_buf);
&gt;
&gt; Size argument to aes_set_encrypt_key is in octets, not bits. (And if you
&gt; use aes128_set_encrypt_key instead, as I suggest, there's no size
&gt; argument).
&gt;
&gt; +       aes_encrypt(&amp;m_Context,AES128_KEY_SIZE, buf + gen_count,
&gt; m_ctr_buf);
&gt;
&gt; AES128_KEYSIZE here looks a bit strange. sizeof(m_ctr_buf)? (Even if the
&gt; value, 16, is intentionally the same).
&gt;
&gt; Delete the code computing c_2powb, and use mpz_fdiv_r_2exp instead of
&gt; mpz_mod.
&gt;
&gt; You don't need bn_tmp, the mpz interface allows in-place operations.
&gt;
&gt; Dob't access _mp_size field, if you really want the (platform dependent)
&gt; limb size, use the mpz_size function. But generally, mpz_sizeinbase is
&gt; more useful.
&gt;
&gt; I don't think your use of mpz_export is correct in the case that the
&gt; base-256 representation has leading zeros. I think you need to handle
&gt; the zero-padding yourself (or maybe the initial memset is enough? But
&gt; for big-endian, you still have to know the number of leading zeros).
&gt;
&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels M=C3=B6ller. PGP-encrypted email is preferred. Keyid C0B98E26.
&gt; Internet email is subject to wholesale government surveillance.
&gt;

</body></email><email><emailId>20160530191659</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-05-30 19:16:59-0400</timestampReceived><subject>Re: Porting openssl code to nettle</subject><body>

Aaron Boxer &lt;boxerab@gmail.com&gt; writes:

&gt; For KM_prng.cpp , are you suggesting that I use 128 bit AES instead of 256
&gt; bit ?
&gt; I think the original code used 256 bit.

I might have misread the code. If the original code used 256-bit aes,
always, you should use nettle's aes256_ctx when porting it over.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160425211615</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-04-25 21:16:15-0400</timestampReceived><subject>Re: Curve25519 and RFC 7748</subject><body>

On Mon, 2016-04-25 at 21:43 +0200, Niels Möller wrote:
&gt; Hi,

&gt; I wouldn't expect any problems from this, its a corner case with
&gt; input
&gt; values which are arguably invalid.  
&gt; 
&gt; The motivation in the RFC, as I understand it, is to leave open for
&gt; protocols to use the top bit for their own, without bothering to
&gt; clear
&gt; it before invoking curve25519. Which at first seems a bit silly, but
&gt; there's some value in not leaving corner cases implementation
&gt; defined,
&gt; and it would maybe have been even more silly to require that
&gt; implementations do wraparound of that improper high bit.
&gt; 
&gt; This change would also need some updates of testcases and
&gt; documentation.

It would make sense to document the version of nettle after which this
behavior is followed, and probably add some ifdef similarly to FIPS202
for sha3.

regards,
Nikos


</body></email><email><emailId>20160207152522</emailId><senderName>Girish Kumar</senderName><senderEmail>girish.kumar@al-enterprise.com</senderEmail><timestampReceived>2016-02-07 15:25:22-0400</timestampReceived><subject>cross compiling nettle-3.2  for armv7 on linux</subject><body>


Hi All,

I am cross compiling nettle-3.2  for armv7 on linux. But I  am getting following \
error. Could you please help me on this


checking build system compiler gcc... no checking build system compiler cc... no \
                checking build system compiler c89... no checking build system \
                compiler c99... no
configure: error: Cannot find a build system compiler
make[1]: *** [/home/gkuma020/PERFORCE/7.X.X.R01-gkuma020-new/engr/sw/tps/objs/46/7.X.X.R01/armv7/nettle/nettle.configured] \
Error 1 make[1]: Leaving directory \
                `/home/gkuma020/PERFORCE/7.X.X.R01-gkuma020-new/engr/sw/tps'
make: *** [tps-build] Error 2
+ set +x

Following is my make file changes. Please let me know if anything is wrong.

nettle_deps = $(shell find $(LTOP)/nettle-3.2 -type f)
$(OBJS)/nettle/nettle.configured: $(nettle_deps)
    @rm -rf $(OBJS)/nettle;
    @mkdir -p $(OBJS)/nettle;
    @cd $(OBJS)/nettle;\
    declare -x PATH=$(CCPATH):$(PATH);\
    declare -x ac_cv_func_malloc_0_nonnull="yes";\
    declare -x ac_cv_func_realloc_0_nonnull="yes";\
    declare -x CFLAGS="$(PLATFORM_CFLAGS) ";\
    declare -x LDFLAGS="$(PLATFORM_LDFLAGS) -L$(CROSSLIBS) -L$(BUILT_LIBS)";\
    declare -x CPPFLAGS="$(PLATFORM_CPPFLAGS) -I$(CROSSINCS) -I$(BUILT_INCLUDES) ";\
    $(LTOP)/nettle-3.2/configure --prefix=$(BUILT_BASE) --host=$(CCPREFIX)  \
--disable-static&amp;&gt; $(OBJS)/nettle/configure.out  @touch \
$(OBJS)/nettle/nettle.configured

$(RAMDISK_LIB)/nettle.so: $(OBJS)/nettle/nettle.configured
    @cd $(OBJS)/nettle;\
    declare -x HOSTCC=`which gcc`;\
    declare -x PATH=$(CCPATH):$(PATH);\
    declare -x CFLAGS="$(PLATFORM_CFLAGS) ";\
    declare -x LDFLAGS="$(PLATFORM_LDFLAGS) -L$(CROSSLIBS) -L$(BUILT_LIBS)";\
    declare -x CPPFLAGS="$(PLATFORM_CPPFLAGS) -I$(CROSSINCS) -I$(BUILT_INCLUDES) ";\
    $(MAKE) &amp;&gt; $(OBJS)/nettle/make.out;\
    $(MAKE) install  &amp;&gt; $(OBJS)/nettle/install.out

Regards,
Girish
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20160107122637</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-01-07 12:26:37-0400</timestampReceived><subject>Re: Hashing with short input assertion question</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; just experienced a crash (assertion) when using md5 on short input.
&gt;
&gt; test: md5.c:81: nettle_md5_digest: Assertion `length &lt;= 16' failed.
&gt;
&gt; The code is
&gt; 	struct md5_ctx md5;
&gt; 	md5_init(&amp;md5);
&gt; 	md5_update(&amp;md5, "moin", 4);
&gt; 	md5_digest(&amp;md5, 20, digest);
                         ^^

The problem isn't the *input* length, but the output length. The length
argument for md5_digest can be at most MD5_DIGEST_SIZE, i.e., 16.

&gt; Is it reasonable to open a Debian bug suggesting to use -DNDEBUG ?

IMO, no. 

Asserts in nettle are triggered when bugs in nettle or in the
application violate necessary assumptions required for correct
operation. In most cases, an immediate crash is preferable to follow on
problems such data corruption or invalid memory accesses. Right, I know
there are some exceptional production systems (e.g, the Ariadne
rocket...) where it *might* be preferable to ignore problems and hope
for the best, and I also know there are different opinions. But my view
is that in general, it makes sense to keep asserts also in production
code.

Best regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160107135138</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2016-01-07 13:51:38-0400</timestampReceived><subject>Re: Hashing with short input assertion question</subject><body>

On Thursday 07 January 2016 13:26:37 Niels Möller wrote:
&gt; Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:
&gt; &gt; just experienced a crash (assertion) when using md5 on short input.
&gt; &gt; 
&gt; &gt; test: md5.c:81: nettle_md5_digest: Assertion `length &lt;= 16' failed.
&gt; &gt; 
&gt; &gt; The code is
&gt; &gt; 
&gt; &gt; 	struct md5_ctx md5;
&gt; &gt; 	md5_init(&amp;md5);
&gt; &gt; 	md5_update(&amp;md5, "moin", 4);
&gt; &gt; 	md5_digest(&amp;md5, 20, digest);
&gt; 
&gt;                          ^^
&gt; 
&gt; The problem isn't the *input* length, but the output length.
&gt; The length argument for md5_digest can be at most MD5_DIGEST_SIZE, i.e., 16.

When walking back from lunch everything sorted out in my brain. I was too 
hungry when I wrote that text. Sorry for the noise.

But what's wrong with providing a larger buffer than needed ?
Imagine snprintf would throw an assertion if the provided buffer is 'too 
large'.

&gt; Asserts in nettle are triggered when bugs in nettle or in the
&gt; application violate necessary assumptions required for correct
&gt; operation. In most cases, an immediate crash is preferable to follow on
&gt; problems such data corruption or invalid memory accesses. Right, I know
&gt; there are some exceptional production systems (e.g, the Ariadne
&gt; rocket...) where it *might* be preferable to ignore problems and hope
&gt; for the best, and I also know there are different opinions. But my view
&gt; is that in general, it makes sense to keep asserts also in production
&gt; code.

Some admins have their jobs due to 'stop-by-assertion' software - at least 
that is good thing about assertions ;)

Best Regards

	Tim


</body></email><email><emailId>20160107140538</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-01-07 14:05:38-0400</timestampReceived><subject>Re: Hashing with short input assertion question</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; But what's wrong with providing a larger buffer than needed ?

I don't think about it as the size of the provided buffer, but as the
requested size of the digest (intended for the usecase of truncated
digests). And it's not defined how to produce a 20-byte md5 digest. If

  md5_digest(&amp;md5, 20, digest);

were allowed, what should it do? Write 16 bytes, and leave the remaining
4 bytes untouched?

&gt; Some admins have their jobs due to 'stop-by-assertion' software - at least 
&gt; that is good thing about assertions ;)

I suspect that 'continue-with-silent-data-corruption' software would
give them even more work...

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160107153026</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2016-01-07 15:30:26-0400</timestampReceived><subject>Re: Hashing with short input assertion question</subject><body>

On Thursday 07 January 2016 15:05:38 Niels Möller wrote:
&gt; Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:
&gt; &gt; But what's wrong with providing a larger buffer than needed ?
&gt; 
&gt; I don't think about it as the size of the provided buffer, but as the
&gt; requested size of the digest (intended for the usecase of truncated
&gt; digests). And it's not defined how to produce a 20-byte md5 digest. If
&gt; 
&gt;   md5_digest(&amp;md5, 20, digest);
&gt; 
&gt; were allowed, what should it do? Write 16 bytes, and leave the remaining
&gt; 4 bytes untouched?

You put the answer into my mouth... yes, that seems intuitive to me.

&gt; &gt; Some admins have their jobs due to 'stop-by-assertion' software - at least
&gt; &gt; that is good thing about assertions ;)
&gt; 
&gt; I suspect that 'continue-with-silent-data-corruption' software would
&gt; give them even more work...

Definitely. That's why I try to avoid either of them.

An assertion doesn't give the higher layers a chance to intervene. The process 
is being killed, eventually leaving corrupted data in persistent memory while 
all information to recover anything is gone with the killed process.
Returning a proper error value at least gives the ones who care for the chance 
to recover. I am working in the telephony area where recovering from faults is 
a basic design (even on protocol level). Also in mind that a single process 
may control hundreds of connections - a sudden stop may kill people (just 
calling the ambulance / police, maybe no chance to call again).

Regards

	Tim


</body></email><email><emailId>20160107175754</emailId><senderName>Amos Jeffries</senderName><senderEmail>squid3@treenet.co.nz</senderEmail><timestampReceived>2016-01-07 17:57:54-0400</timestampReceived><subject>Re: Hashing with short input assertion question</subject><body>

On 8/01/2016 4:30 a.m., Tim Ruehsen wrote:
&gt; On Thursday 07 January 2016 15:05:38 Niels Möller wrote:
&gt;&gt; Tim Ruehsen writes:
&gt;&gt;&gt; But what's wrong with providing a larger buffer than needed ?
&gt;&gt;
&gt;&gt; I don't think about it as the size of the provided buffer, but as the
&gt;&gt; requested size of the digest (intended for the usecase of truncated
&gt;&gt; digests). And it's not defined how to produce a 20-byte md5 digest. If
&gt;&gt;
&gt;&gt;   md5_digest(&amp;md5, 20, digest);
&gt;&gt;
&gt;&gt; were allowed, what should it do? Write 16 bytes, and leave the remaining
&gt;&gt; 4 bytes untouched?
&gt; 
&gt; You put the answer into my mouth... yes, that seems intuitive to me.

Then what will the application do with 4 random bytes of output?
It clearly is not aware of the 16-byte digest size limit. So what basis
do we have to be certain it will output or use only those 16 bytes, and
not doing something such as sending the buffer to snprintf with length
parameter of 20 there as well. Or worse, passing just the (unterminated)
buffer start pointer to sprintf.

It is a very bad policy for any code, let alone security code, to just
blindly trust that the external software will operate correctly.


The choice is also not so black and white. There are a bunch of other
"intuitive" actions that could be performed:
* wipe the entire digest and emit 20 bytes of 0's, or
* wipe the entire digest and emit 20 bytes of 1's, or
* wipe the extra 4 bytes with 0's, or
* wipe the extra 4 bytes with 1's, or
* wipe the 1st of the extra bytes with a null byte, or
* throw an exception.

Each of which has its own set of problems and nasty side effects
depending on what the external software is doing or assuming.

&gt; 
&gt;&gt;&gt; Some admins have their jobs due to 'stop-by-assertion' software - at least
&gt;&gt;&gt; that is good thing about assertions ;)
&gt;&gt;
&gt;&gt; I suspect that 'continue-with-silent-data-corruption' software would
&gt;&gt; give them even more work...
&gt; 
&gt; Definitely. That's why I try to avoid either of them.
&gt; 
&gt; An assertion doesn't give the higher layers a chance to intervene.

The higher layers are clearly broken in their designed use of the nettle
API. This is not a dynamic limit being checked, but an explicit and
fixed global value of MD5_DIGEST_SIZE.

Amos

</body></email><email><emailId>20160108100841</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2016-01-08 10:08:41-0400</timestampReceived><subject>Re: Hashing with short input assertion question</subject><body>


On Friday 08 January 2016 06:57:54 Amos Jeffries wrote:
&gt; On 8/01/2016 4:30 a.m., Tim Ruehsen wrote:
&gt; &gt; On Thursday 07 January 2016 15:05:38 Niels Möller wrote:
&gt; &gt;&gt; Tim Ruehsen writes:
&gt; &gt;&gt;&gt; But what's wrong with providing a larger buffer than needed ?
&gt; &gt;&gt; 
&gt; &gt;&gt; I don't think about it as the size of the provided buffer, but as the
&gt; &gt;&gt; requested size of the digest (intended for the usecase of truncated
&gt; &gt;&gt; digests). And it's not defined how to produce a 20-byte md5 digest. If
&gt; &gt;&gt; 
&gt; &gt;&gt;   md5_digest(&amp;md5, 20, digest);
&gt; &gt;&gt; 
&gt; &gt;&gt; were allowed, what should it do? Write 16 bytes, and leave the remaining
&gt; &gt;&gt; 4 bytes untouched?
&gt; &gt; 
&gt; &gt; You put the answer into my mouth... yes, that seems intuitive to me.
&gt; 
&gt; Then what will the application do with 4 random bytes of output?
&gt; It clearly is not aware of the 16-byte digest size limit. So what basis
&gt; do we have to be certain it will output or use only those 16 bytes, and
&gt; not doing something such as sending the buffer to snprintf with length
&gt; parameter of 20 there as well. Or worse, passing just the (unterminated)
&gt; buffer start pointer to sprintf.

??? 

&gt; It is a very bad policy for any code, let alone security code, to just
&gt; blindly trust that the external software will operate correctly.

Sorry, that is IMO bullshit. You say a low-level function is responsible for 
what the (high-level caller | application) is doing. *head shake*
It is absolutely in the callers responsibility to use the output of any 
function correctly - and his basis is the documentation.

&gt; The choice is also not so black and white. There are a bunch of other
&gt; "intuitive" actions that could be performed:

You are right, 'intuition' is not the point. The point is what is documented 
and what not.

Here on Debian I have no man pages for any nettle functions - so I looked into 
the header files to find the function prototypes and used them 'intuitive'. 
Which worked immediately until I started to use a larger digest buffer than 
'allowed'. I am using the same buffer for other algorithms/hash functions as 
well, so using 'sizeof' was straight forward. Nettle functions unexpectedly 
crashed of my application instead of a sane return value(all those function 
are void, *_digest() could return error or the number of bytes written).

I meanwhile found the nettle docs on the web 
(http://www.lysator.liu.se/~nisse/nettle/nettle.html#MD5):

###########
Function: void md5_digest (struct md5_ctx *ctx, size_t length, uint8_t 
*digest)

Performs final processing and extracts the message digest, writing it to 
digest. length may be smaller than MD5_DIGEST_SIZE, in which case only the 
first length octets of the digest are written. 
###########

Not a simple word saying 'If length is larger than MD5_DIGEST_SIZE' the 
function does not return - it calls abort()'.

I would like to see that documented for every *_digest() function !


&gt; &gt;&gt;&gt; Some admins have their jobs due to 'stop-by-assertion' software - at
&gt; &gt;&gt;&gt; least
&gt; &gt;&gt;&gt; that is good thing about assertions ;)
&gt; &gt;&gt; 
&gt; &gt;&gt; I suspect that 'continue-with-silent-data-corruption' software would
&gt; &gt;&gt; give them even more work...
&gt; &gt; 
&gt; &gt; Definitely. That's why I try to avoid either of them.
&gt; &gt; 
&gt; &gt; An assertion doesn't give the higher layers a chance to intervene.
&gt; 
&gt; The higher layers are clearly broken in their designed use of the nettle
&gt; API. This is not a dynamic limit being checked, but an explicit and
&gt; fixed global value of MD5_DIGEST_SIZE.

See the excerpt from the docs above. What you say is not correct, you can 
provide a smaller digest buffer than MD5_DIGEST_SIZE. If you were right, the 
'length' param wouldn't make sense.
In my eyes it makes sense as saying: 'digest' is 'length' bytes large - please 
do not overwrite (= put at most 'length' bytes into 'digest'). The typical C 
buffer over flow prevention. But any such functions generally are fine with 
larger buffers - they put their payload into the buffer and leave the rest 
alone (except otherwise documented). Returning the actual number of bytes put 
into 'digest' would be of large help as well.


Just an impression for you what I am doing and why fixed digest sizes doesn't 
matter resp. are uninteresting here:

For my high-level hash function I use GnuTLS (wrapper around nettle|other), 
Nettle or Gcrypt (configurable). 

unsigned char digest[128]; // *should* be large enough, if not we get an error
char *algo = &lt;user input&gt;
if ((len=hash(algo,text,textlen,digest,digestsize)) &lt; 0) {
  // error like 'unknown algo', 'digest size too small', ... 
} else {
  // got &lt;len&gt; bytes in digest, e.g. print as hex values
}

At this level MD5_DIGEST_SIZE etc. is unknown and not interesting.

(For nettle i found the nettle_hash structure variables and it's digest_size 
variable. Everything is working fine.)

Regards, Tim

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20160108121627</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-01-08 12:16:27-0400</timestampReceived><subject>Re: Hashing with short input assertion question</subject><body>

Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; I meanwhile found the nettle docs on the web 
&gt; (http://www.lysator.liu.se/~nisse/nettle/nettle.html#MD5):

I'm happy you found the documentation. The manual should also be
included in debian's nettle-dev package, in info, html and pdf formats.

&gt; ###########
&gt; Function: void md5_digest (struct md5_ctx *ctx, size_t length, uint8_t 
&gt; *digest)
&gt;
&gt; Performs final processing and extracts the message digest, writing it to 
&gt; digest. length may be smaller than MD5_DIGEST_SIZE, in which case only the 
&gt; first length octets of the digest are written. 
&gt; ###########

Sorry you find this unclear. Can you suggest a concise improvement?

&gt; unsigned char digest[128]; // *should* be large enough, if not we get an error
&gt; char *algo = &lt;user input&gt;
&gt; if ((len=hash(algo,text,textlen,digest,digestsize)) &lt; 0) {
&gt;   // error like 'unknown algo', 'digest size too small', ... 
&gt; } else {
&gt;   // got &lt;len&gt; bytes in digest, e.g. print as hex values
&gt; }

For simplicity, let's assume that algoriths are represented by struct
nettle_hash, rather than an ascii name. Then a hash function
in that style should be implemented like

  int hash (const struct nettle_hash *hash, 
               const uint8_t *msg, size_t length, 
               uint8_t *digest, size_t digest_size)
  {
    void *ctx;
    if (digest_size &lt; hash-&gt;digest_size)
      /* Too small */
      return -1;

    ctx = alloca(hash-&gt;context_size);
    hash-&gt;init(ctx);
    hash-&gt;update(ctx, length, msg);
    hash-&gt;digest(ctx, hash-&gt;digest_size, digest);
    return hash-&gt;digest_size;
  }

I don't think that passing a valid digest size to hash-&gt;digest here
should be a big deal.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20161204090656</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2016-12-04 09:06:56-0400</timestampReceived><subject>Re: Some ideas for new algorithms in Nettle</subject><body>


nisse@lysator.liu.se (Niels Möller) writes:

&gt; I'm also not sure how to deal with research and Nettle. On one hand,
&gt; it's nice if people use Nettle as a base for implementing new
&gt; algorithms, and that makes it easier to integrate code once a new
&gt; algorithm matures. But on the other hand, for a practical library, it's
&gt; not really useful to include dozens of obscure algorithms and research
&gt; projects. And supported algorithms also need documentation, which has a
&gt; cost both to writing and reading. A compromise might be an
&gt; --enable-experimental configure flag to include unsupported algorithms
&gt; for research and evaluation purposes? Or some recommended practices for
&gt; forking and extending Nettle. 

An --enable-foo approach seems useful to me.  It is good to have
well-integrated versions of algorithms available in the nettle
repository, but there is a high cost to inflict them to every
installation.  Maybe if a --enable-foo approach was introduced, we could
even reduce the number of algorithms that are enabled by default.

/Simon

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20161221215226</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-12-21 21:52:26-0400</timestampReceived><subject>Subtle ABI problem with nettle_hashes</subject><body>

The idea of the interface

  /* null-terminated list of digests implemented by this version of nettle */
  extern const struct nettle_hash * const nettle_hashes[];

was that the size of the array isn't part of the ABI; a new Nettle version
should be able to extend it with more entries, without breaking the ABI.

However, I've recently learnt that it does break, in a subtle way. (See
https://bugs.gentoo.org/show_bug.cgi?id=601512 and
http://trofi.github.io/posts/195-dynamic-linking-ABI-is-hard.html).

The problematic case is a traditional non-PIC executable linking with a
nettle shared library; in this post, I care exclusively about this case.

All symbol references in the executable are resolved at link time, and
at load time it is mapped at a fixed address (traditionally 0, I don't
know if current systems skip the first page), without any relocations.

Now, if the executable links with libnettle.so, and contains a reference
to the symbol nettle_hashes, the address where nettle.so is going to be
mapped isn't known at link time? So how can the executable refer to it
without load-time relocation of its references? The linker solves that
problem using the curious relocation type R_X86_64_COPY.

What the linker does is that it allocates space for a copy of the data
in the BSS segment of the executable, and resolve all references to
point to that copy. At the time libnettle.so is loaded, the list in the
library is copied (after relocating it, but that's a minor complication
in this context) to the space in the BSS. I imagine the dynamic linker
also adjusts the pointers in libnettle.so's GOT table to refer to the
copy rather than the original.

Now the problem is that the allocation in the BSS segment, as well as
the copying operation, are based on the size of the data object as
recorded in the version of libnettle.so available at the time the
executable was linked.

If the array size is larger in the version of libnettle.so actally
loaded, the copy operation is truncates it, which is particularly bad
when it's NULL-terminated. So the array size, which was intended to not
be part of the ABI, creeps into the ABI.

So what to do about this? We have to break the ABI, but I'd prefer if we
keep the API unchanged. Some alternatives:

1. Define nettle_hashesp as a constant pointer to the current
   nettle_hashes list, and
   
     #define nettle_hashes (*nettle_hashesp)
   
   Then nettle_hashesp will still get a R_X86_64_COPY relocation, but now
   the size is always a single pointer, regardless of the array size. At
   load time, it will be set to point directly to the list in the
   data segment of the loaded libnettle.so.
  
2. Define a function get_nettle_hashes returning a pointer to the list,
   and
   
     #define nettle_hashes (get_nettle_hashes())
   
   In this case, the indirection is via a PLT entry in the executable.

3. Define the array with a size explicitly part of the ABI, 

      extern const struct nettle_hash * const nettle_hashes[17];

   Add a some reasonable number of reserved NULL entries at the end, and
   make an ABI break whenever we run out of reserved places and have to
   increase the size.
   
We also have other public data, e.g., individual nettle_hash structs,
like

  extern const struct nettle_hash nettle_sha256;

These will also get a R_X86_64_COPY relocation if referenced (and all
internal references within libnettle.so will be relocated to the copy in
the executable's BSS, I guess). But that's less of a problem, since the
size and layout is already part of the ABI.

More problematic are the objects declared in ecc-curve.h; the size and
layout of struct ecc_curve was intended to be an implementation detail,
not part of the ABI, but isn't, when R_X86_64_COPY is involved.

Advice appreciated. I'd also like to hear if anyone on the list knows
how these things work with windows dlls. I've read sometime that
exporting data (in contrast to functions) from a dll is extra tricky,
but I don't remember any details. If we make any changes to fix the
exported-data issues with ELF, it would be good if we could ensure that
we solve any related problems for libnettle.dll too.

I understand why R_X86_64_COPY is needed, but it works in a way that was
pretty counter-intutive to me. The effect is, more or less, that the
library's data is *statically* linked into the executable. And then
initialized at load time based on the contents of the loaded library.
And we then get a mix of statically linked and dynamically linked parts
which might originate in different versions of the library.

It would be prettier if we could force the executable to always access
library data via GOT (like it works for PIC code), and never use
R_X86_64_COPY. But I guess that has to be known at code generation time,
and likely too late to fixup at link time, which is when we know which
external data objects are defined by some shared library, and which
aren't. But if anyone knows how to fix the issue in this way, I'd be
delighted.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20161228030346</emailId><senderName>Ron Frederick</senderName><senderEmail>ronf@timeheart.net</senderEmail><timestampReceived>2016-12-28 03:03:46-0400</timestampReceived><subject>Re: Language bindings question</subject><body>

On Dec 27, 2016, at 10:35 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; I don't recall all details of UMAC; it's some years since I wrote it.
&gt; But the way I understand it, it works by computing a relatively weak
&gt; low-complexity function of the expanded key and message. IIRC, L1 is a
&gt; plain linear convolution, and L2 is some kind of polynomial evaluation.
&gt; And then to hide the low-complexity structure from the attacker, a value
&gt; derived from the key and nonce is XORed to the tag at the end. Looking
&gt; at the code, that final "whitening" is the only use of the nonce I see.
&gt; 
&gt; So basically,
&gt; 
&gt; umac(key, nonce, msg) = F(key, msg) ^ AES(pdf_key, nonce)
&gt; 
&gt; where F(key, msg) is a low-complexity function. So if you compute
&gt; 
&gt; t0 = umac(key, nonce, "foo")
&gt; t1 = umac(key, nonce, "foobar")
&gt; 
&gt; then 
&gt; 
&gt; t0 XOR t1 = F(key, "foo") ^ F(key,"foobar")
&gt; 
&gt; which looks a bit too well structured, and defeats the whitening step. I
&gt; can't tell if it leads to practical attacks, but I wouldn't be suprised
&gt; of a few of these would let the attacker derive the parts of the
&gt; expanded key corresponding to the suffix, and then forge additional
&gt; messages with identical tag.

Ok, I see. Given that the nonce is only folded in with XOR at the last stage of \
generating the digest, I can see how it'd be a problem to ever generate two digest \
values with the same PDF key and nonce, independent of what was going on with the \
other function which operated on the message. If F() is good enough, knowing the XOR \
of F() on two different messages (even if one is a prefix of another) still shouldn't \
tell you much, but the AES pad (and any additional strength it provides) has \
essentially been removed entirely in this case.

This definitely raises questions about whether it would ever make sense to support \
either snapshot_digest() or copy() for UMAC. For my specific use case in AsyncSSH, I \
can get by without either. I was only trying to support these to be compatible with \
                PEP 452, but perhaps that's not a good idea in this case.
-- 
Ron Frederick
ronf@timeheart.net


</body></email><email><emailId>20161108104644</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-11-08 10:46:44-0400</timestampReceived><subject>Re: Some ideas for new algorithms in Nettle</subject><body>

Joachim StrÃ¶mbergson &lt;joachim@secworks.se&gt; writes:

&gt; I'm at least seeing several projects where the ability to have a single
&gt; keypair is highly desirable.

You're making me curious, can you give some example? For private keys,
it should be easy to derive as many as one needs from a single secret
using something like hash(secret | counter).

But for the corresponding public keys, there's no obvious way to link
them together, so maybe a single key is more beneficial in that end? As
a simpler alternative than having a main key and a signed certificate
for each additional public key used for different purposes.

&gt; With the exception of the new XEdDS, Argon2 and possibly OCB mode, I
&gt; would say that the suggested additions I listed are not for obscure
&gt; research algorithms, but algorithms that see concrete usage.

Sorry, I didn't mean to discourage you. I imagine you have a much better
overview of what's used in practice than I have.

&gt; But hey, It ¨s just suggestions. I intended to provide code, but only if
&gt; there is an interest for it.

Your contributions, past and future, are much appreciated. The attempt
at separating research from mainstream wasn't intended to be a high bar,
but it makes it easier for me if a proposed algorithm addition is
accompanied by one or two examples of applications or protocols using it
(like you surely did, for some of your suggestions). And from the set of
non-obscure algorithms, which it makes sense to support in Nettle, I'd
try to prioritize those most widely used.

Regards,
/Niels

-- 
Niels MÃ¶ller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20161002101212</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2016-10-02 10:12:12-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.3</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Cc: nettle-bugs@lists.lysator.liu.se
&gt; Date: Sun, 02 Oct 2016 12:01:35 +0200
&gt; 
&gt; &gt; Shared libraries need --strip-unneded, static libraries need
&gt; &gt; --strip-debug followed by ranlib.
&gt; 
&gt; Makes sense. Are you saying that for static libraries, one has to redo
&gt; ranlib after strip?

That's what libtool does, but I don't really know if that's needed.
maybe it's needed with non-GNU 'strip'?

&gt; &gt;&gt; and I'm not sure which is implied by install -s.
&gt; &gt;
&gt; &gt; It's a synonym for --strip-all, so it's only pertinent to executable
&gt; &gt; programs.
&gt; 
&gt; And you're also saying that a "default strip", invoking strip without
&gt; any options, is the same as strip --strip-all?

Sounds like that, although the documentation doesn't seem to say that
explicitly.  FWIW, I always use just "strip", without any options,
when I need to strip an executable.

</body></email><email><emailId>20161019192559</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-10-19 19:25:59-0400</timestampReceived><subject>skein</subject><body>

I've done some hacking to implement the skein hash function (one of the
sha3 candidates, see
https://en.wikipedia.org/wiki/Skein_%28hash_function%29). Development is
done on the "skein" branch of the repo.

At low-level it has some similarities to salsa20 and chacha: An input
block is mangled in a perfectly invertible way using only add, xor and
rotation, followed by an addition of the original input, which destroys
invertibility. And then this primitive is used to construct a hash
function.

I've implemented skein256, both for portable C and x86_64 assembly.
The current implementation is written for small footprint in both code
and data, it could perhaps be made a little faster with more unrolling.

On x86_64, it's slightly slower than sha1, slightly faster than sha512,
and considerably faster than sha256 and sha3 (and these relations are
likely to be similar on all platforms with a reasonable number of 64-bit
registers). Performance is a bit behind the numbers reported in the
skein paper http://www.skein-hash.info/sites/default/files/skein1.3.pdf;
not sure if the difference is due to unrolling, different benchmarking
machines, or additional implementation tricks. (On my current x86_64
machines, benchmarking using the nettle-enchmark is not very accurate,
numbers vary quite a bit from one run to the next).

And it's a pity there's no easy way to rotate different pieces of an xmm
register by different counts; that makes it hard to get any advantage of
the parts of the skein/threefish round which do fit SIMD. So the design
is a lot less SIMD-friendly than chacha.

skein512 is in progress; there it's not possible to fit all inputs in
registers (unless one can make good use of SIMD registers in some way),
and I haven't yet figured out a good way to organize it for performance.

Skein can be used in additional ways than a plain hash function, e.g.,
as a mac, or key derivation function. I don't plan to implement such
additional skein features until there's some clear use case for them.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20160903202440</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-09-03 20:24:40-0400</timestampReceived><subject>Re: char vs uint8_t</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; On Sun, 2016-07-17 at 12:14 +0200, Niels Möller wrote:
&gt;&gt; I'd like to eliminate pointer-signedness warnings. I'm afraid some
&gt;&gt; ugly
&gt;&gt; casts will have to be involved, since most functions work with
&gt;&gt; uint8_t,
&gt;&gt; and at least test code needs to pass literal strings, of type char *.

I've now gotten rid of most of those warnings, pushing the changes soon.

&gt;&gt; I have one question, on the ascii-armor funtions: Would ie make sense
&gt;&gt; to change the type of ascii inputs and outputs to char? I.e.,
&gt;&gt; 
&gt;&gt;  size_t
&gt;&gt;  base64_encode_update(struct base64_encode_ctx *ctx,
&gt;&gt; -		     uint8_t *dst,
&gt;&gt; +		     char *dst,
&gt;&gt;  		     size_t length,
&gt;&gt;  		     const uint8_t *src);
&gt;
&gt; I think it would be good API-wise. I had to casted these parameters in
&gt; almost every use I had for them.

I've given this a try (on a local branch). It makes sense most of the
time. But where are a couple of places where encoding and decoding is
done in-place. Typical example, from the nettle-pbkdf2 command line tool:

  salt = (uint8_t *) strdup (argv[0]);
  salt_length = strlen(argv[0]);
  
  if (hex_salt)
    {
      struct base16_decode_ctx base16;

      base16_decode_init (&amp;base16);
      if (!base16_decode_update (&amp;base16,
				 &amp;salt_length, salt, 
				 salt_length, salt)
	  || !base16_decode_final (&amp;base16))
	die ("Invalid salt (expecting hex encoding).\n");
    }

This gets a bit awkward with different types for src and dst. Should we
care about this somewhat obscure usecase? Can it be handled in a clean
way?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160905080712</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-09-05 08:07:12-0400</timestampReceived><subject>use gitlab's shared runners</subject><body>

Hi,
  This patch converts nettle's CI to use gitlab's infrastructure. Red
Hat's specific runners currently used for CI will be phased out, so it
makes sense to switch to gitlab.com shared infrastructure. An other
advantage is that more (Linux) systems can be checked due to the fact
that this CI is based on docker.

An example run can be seen at:
https://gitlab.com/gnutls/nettle/pipelines/4146073

regards,
Nikos

["0001-Use-gitlab.com-s-shared-runners.patch" (0001-Use-gitlab.com-s-shared-runners.patch)]

From 48e8333d8508a37db5320022c8244c9481b3e140 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Mon, 5 Sep 2016 09:57:24 +0200
Subject: [PATCH] Use gitlab.com's shared runners

That is, phase out our specific runners to reduce administrative
burden, and rely on gitlab.com shared infrastructure.

http://docs.gitlab.com/ce/ci/runners/README.html
---
 .gitlab-ci.yml | 21 +++++++++++++++++----
 1 file changed, 17 insertions(+), 4 deletions(-)

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index eafe0d6..f839416 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -1,20 +1,27 @@
+image: centos:7
+
+before_script:
+ - yum install -y git make autoconf libtool automake gettext-devel glibc-devel gcc \
valgrind libasan-static libgcc.i686 glibc-devel.i686 +
 # See http://doc.gitlab.com/ce/ci/yaml/ for documentation.
 Build and Check (x86-64):
   script:
+  - yum install -y gmp-devel
   - ./.bootstrap &amp;&amp;
     ./configure --disable-documentation &amp;&amp; make -j4 &amp;&amp;
     make check -j4
   tags:
-  - x86-64
+  - shared
   except:
   - tags
 Build and Check (x86):
   script:
+  - yum install -y gmp-devel.i686
   - ./.bootstrap &amp;&amp;
-    ./configure --disable-documentation &amp;&amp; make -j4 &amp;&amp;
+    PKG_CONFIG_PATH="/usr/lib/pkgconfig/" CFLAGS="-O2 -g -m32" LDFLAGS="-m32" \
./configure --build=i686-redhat-linux --disable-documentation &amp;&amp; make -j4 &amp;&amp;  make \
check -j4  tags:
-  - x86
+  - shared
   except:
   - tags
 Build and Check with mini-gmp:
@@ -23,21 +30,27 @@ Build and Check with mini-gmp:
     ./configure --disable-documentation --enable-mini-gmp &amp;&amp; make -j4 &amp;&amp;
     make check -j4
   tags:
+  - shared
   except:
   - tags
 Build and Check with ubsan:
+  image: fedora:24
   script:
+  - yum install -y gmp-devel libubsan-static libubsan
   - ./.bootstrap &amp;&amp; 
     CXXFLAGS="-fsanitize=undefined -fno-sanitize-recover -g -O2" \
                CFLAGS="-fsanitize=undefined -fno-sanitize-recover -g -O2" \
                ./configure 
     --disable-documentation &amp;&amp; make -j4 &amp;&amp; make check -j4
   tags:
-  - ubsan
+  - shared
   except:
   - tags
 Build and Check with asan:
   script:
+  - yum install -y gmp-devel
   - ./.bootstrap &amp;&amp; 
   - CXXFLAGS="-fsanitize=address -g -O2" CFLAGS="-fsanitize=address -g -O2" \
./configure --disable-documentation &amp;&amp;  make -j4 &amp;&amp; make check -j4
+  tags:
+  - shared
   except:
   - tags
-- 
2.7.4



</body></email><email><emailId>20160905135337</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-09-05 13:53:37-0400</timestampReceived><subject>Re: display code coverage</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; The attached patch uses lcov to display the code coverage of the test
&gt; suite.

Nice initiative. Some comments and questions:

Last time I used gcov, all needed was adding -ftest-coverage
-fprofile-arcs to CFLAGS. So this seems somewhat over-engineered...

Does one really have to use -O0?

Some or all new Makefile substitutions should probably go in
config.make.in, not Makefile.in.

I have to read up on how these things work.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160905164617</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-09-05 16:46:17-0400</timestampReceived><subject>Re: TLS 1.3 in gnutls</subject><body>

On Mon, 2016-09-05 at 18:15 +0200, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt; 
&gt; &gt; 
&gt; &gt; [0]. https://gitlab.com/gnutls/gnutls/milestones/8
&gt; Nettle additions:
&gt; 
&gt; * HKDF (RFC 5869): Should be reasonably straight forward. Any use
&gt;   besides TLS 1.3?

I'm not aware of any other, but I didn't really searched. I expect that
since it is well-specified and standardized by TLS 1.3, it will be used
by other protocols, but that's more of a speculation. 

&gt; * RSA-PSS. I take it's mandatory? I had the impression that pss was
&gt;   almost dead (specified more than a decade ago, and very rarely
&gt; used,
&gt;   hard to do constant time). We'll have to support it, I guess.

The latest draft has fallback to PKCS#1 1.5. It however states:
"A TLS-compliant application MUST support digital signatures with
rsa_pkcs1_sha256 (for certificates), rsa_pss_sha256 (for
CertificateVerify and certificates), and ecdsa_secp256r1_sha256."
so having it is a "must".

The constant time point is worrying.

&gt;  Andy Lawrence expressed some interest on the Nettle list last
&gt; December, but I don't know what's happened since.

Andy do you have any update on that?

&gt;   If I quote Peter Gutmann on the secsh mailing list:
&gt; 
&gt;    : However, PSS has seen so little interest from both the crypto
&gt;    : community and implementers that we can't really say much about
&gt; it.  For
&gt;    : example for some years the NIST test vectors for RSA-PSS were
&gt; completely wrong
&gt;    : (every single test except the SHA-224 ones failed), and no-one
&gt; noticed.
&gt;    : 
&gt;    : I'll just let that sink in for a second.  The published test
&gt; vectors from a
&gt;    : major, effectively global in reach, standards body for RSA-PSS
&gt; were wrong, and
&gt;    : no-one noticed.  How much attention do you think that indicates
&gt; PSS has got in
&gt;    : practice?

PKCS#1 1.5 worked well for signing. There were no real-world attacks
known so I guess there was no incentive to switch to PSS. I only saw
PSS signatures in some certificates issues by governments for inclusion
in passports.

&gt; * x448. Should be able to reuse some of the curve25519 code, but not
&gt;   all. for curve25519, multiplying a point by a scalar is doen using
&gt; a
&gt;   Montgomery ladder (see curve25519-mul.c), and I'd expect it to be
&gt;   reasonably straight forward to generalize to x448. On the other
&gt; hand,
&gt;   multiplying the fixed generator by a scalar is done on the
&gt;   corresponding (twisted) edwards curve, using Pippenger's algorithm,
&gt;   and then transformed back by a change of coordinates, see below.
&gt; * ed448. This curve has slightly different structure from ed25519
&gt; (not
&gt;   twisted). Current point add code for ed25519 is suboptimal, it uses
&gt;   formulas for non-twisted curve with appropriate only sign changes,
&gt; and
&gt;   it could save a mod mul by taking better advantage of the twist. So
&gt;   ed448 needs its own point addition code.

These are of lower priority. We already have x25519 and the ECDSA
curves, so there is something to start with.

regards,
Nikos


</body></email><email><emailId>20160906185327</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-09-06 18:53:27-0400</timestampReceived><subject>Re: plan for 3.3</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; See patch below. Header file "memops.h", and function called memeql_sec.
&gt; Any comments or opinions before I merge to master?

Merged now. I've also updated
http://www.lysator.liu.se/~nisse/nettle/plan.html

/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160914075839</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-09-14 07:58:39-0400</timestampReceived><subject>Re: Pre-release testing (was: Re: use gitlab's shared runners)</subject><body>

On Tue, Sep 13, 2016 at 11:03 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;&gt; An other advantage is that more (Linux) systems can be checked due to
&gt;&gt; the fact that this CI is based on docker.
&gt;
&gt; Do they provide any non-x86 systems?

None that I'm aware of. Of course you could run something under qemu.

&gt; I've done some manual pre-release builds for x86_64 and x86 on
&gt; gnu/linux, freebsd, and windows (using mingw + wine, this time with some
&gt; trouble, see https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=837108).

I compile and test gnutls dlls under wine. I use the following setup
under fedora24 in case you are interested:
https://gitlab.com/gnutls/gnutls/blob/master/.gitlab-ci.yml#L243

&gt; So this is a good time to be testing nettle on other architectures and
&gt; other operating systems. In particular, help testing with Mac OSX and
&gt; Android is appreciated (and maybe Apple ios; I'm not familiar with the
&gt; details of Apple's appstore terms, so I'm not sure whether or not Nettle
&gt; can be used in ios apps distributed to non-rooted devices, but I guess
&gt; it might be possible for GPLv2 apps).

I've never compiled on osx using a CI, but I'm aware that it is
possible. The stoken project does that:
https://github.com/cernekee/stoken/blob/master/.travis.yml

So I guess you could simply add a .travis.yml and that job will be
pulled from the github mirror of nettle:
https://github.com/gnutls/nettle

You may want to test their proper operation on a branch first.

regards,
Nikos

</body></email><email><emailId>20160914090001</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-09-14 09:00:01-0400</timestampReceived><subject>Re: Pre-release testing</subject><body>

On Wed, Sep 14, 2016 at 6:54 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt; nisse@lysator.liu.se (Niels M=C3=B6ller) writes:
&gt;&gt; So this is a good time to be testing nettle on other architectures and
&gt;&gt; other operating systems.
&gt; I've prepared a tarball,
&gt; https://www.lysator.liu.se/~nisse/archive/nettle-3.3rc1.tar.gz, so it
&gt; can be build with a plain ./configure &amp;&amp; make &amp;&amp; make check, without
&gt; having autoconf installed.

I've installed it on fedora24, and run the gnutls test suite over it.
Everything ok.

regards,
Nikos

</body></email><email><emailId>20160804064410</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-08-04 06:44:10-0400</timestampReceived><subject>Re: [patch] Nettle add missing cflags to some objects</subject><body>

On Wed, Aug 3, 2016 at 11:10 AM, Tomas Chvatal &lt;TChvatal@suse.com&gt; wrote:
&gt; Hello,
&gt; we have checks that verify all objects are compiled with respecting
&gt; cflags set in the distribution (hardening, optimization, etc.).

That shouldn't matter because the code you mentioned is not installed
in the target system. It is code that generates tables used in nettle.

regards,
Nikos

</body></email><email><emailId>20160808060859</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-08-08 06:08:59-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

On Fri, Aug 5, 2016 at 8:57 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; wr=
ote:

&gt;&gt; That's correct, but I think that's the responsibility of the caller to
&gt;&gt; supply the corresponding keys.
&gt; But I think we'de want to ensure that nettle doesn't crash; an
&gt; application should be able to read key files controlled by an attacker
&gt; and use them with nettle without crashing (bogus outputs are of course
&gt; expected).
&gt; And I feel a little uneasy about ensuring that nettle's rsa functions
&gt; work without crashing if the size field is too large or too small; that
&gt; violates assumptions I made when writing the code quite some time ago...
&gt; It might be not too difficult, but I'd feel better about having the
&gt; _prepare functions be responsible for setting the size correctly.

I think that's fair. And providing an efficient variant would be an
incentive for applications to use them much easier. Anyway I believe I
can work-around that.

regards,
Nikos

</body></email><email><emailId>20160707145554</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-07-07 14:55:54-0400</timestampReceived><subject>gitlab merge requests</subject><body>

Hi,
 The gitlab pages on git.lysator.liu.se seem like they are not
actively being followed. Although pull and merge requests are the norm
for some, if they are not followed, it may make more sense to turn off
from the admin interface the merge request option (btw. also the
builds option because it tries to build although no runners are
configured).

Some merge requests in gitlab which look reasonable:
https://git.lysator.liu.se/nettle/nettle/merge_requests/1
https://git.lysator.liu.se/nettle/nettle/merge_requests/4 (btw. I have
an automatically updated mirror of nettle at
https://github.com/gnutls/nettle )

Not sure about the usefulness of:
https://git.lysator.liu.se/nettle/nettle/merge_requests/2
https://git.lysator.liu.se/nettle/nettle/merge_requests/3 (this seems
identical to 4)

regards,
Nikos

</body></email><email><emailId>20160708122619</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-07-08 12:26:19-0400</timestampReceived><subject>Re: plan for 3.3</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Hi,
&gt;  Some comments on the 3.3, plan:
&gt;&gt; +    Add larger "safe" curves, e.g., M-383, curve41417, curve448 and
&gt;&gt; +    E-521.
&gt;
&gt; I think curve448 should be prioritized over anything else since it
&gt; seems to be the only thing being standardized at the moment by CFRG:
&gt; https://tools.ietf.org/html/rfc7748

Makes sense. IIRC, the corresponding Edwards curve for curve448 needs
slightly different equations for scalar multiply with a fixed point.

&gt;&gt; Side-channel silent mem_equalp.
&gt; Do you mean a function with run time independent of its input values?

Exactly. 

&gt; I have such a function at gnutls:
&gt; https://gitlab.com/gnutls/gnutls/blob/master/lib/safe-memfuncs.c#L70

Difficulty is proper naming... Since it doesn't distinguish between lexically smaller
and larger like memcmp, I don't think it should be named like *_memcmp.
And we also need a name for the nettle header file.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160718092453</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-07-18 09:24:53-0400</timestampReceived><subject>Re: char vs uint8_t</subject><body>

On Sun, 2016-07-17 at 12:14 +0200, Niels Möller wrote:
&gt; I'd like to eliminate pointer-signedness warnings. I'm afraid some
&gt; ugly
&gt; casts will have to be involved, since most functions work with
&gt; uint8_t,
&gt; and at least test code needs to pass literal strings, of type char *.
&gt; 
&gt; I have one question, on the ascii-armor funtions: Would ie make sense
&gt; to change the type of ascii inputs and outputs to char? I.e.,
&gt; 
&gt;  size_t
&gt;  base64_encode_update(struct base64_encode_ctx *ctx,
&gt; -		     uint8_t *dst,
&gt; +		     char *dst,
&gt;  		     size_t length,
&gt;  		     const uint8_t *src);

I think it would be good API-wise. I had to casted these parameters in
almost every use I had for them.

&gt; not an ABI change for any ABI spec I'm aware of. What do you think?

As long as it doesn't break the ABI it's good to have such changes.
It's less code to type to use these functions.

btw. Would you be interested in a patch which adds automatic x86-64 abi
check via the CI? Something like:

https://gitlab.com/gnutls/gnutls/commit/99b4b7bb53f6d36ee991e2a2679776faf433c9af



</body></email><email><emailId>20160731184946</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-07-31 18:49:46-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

Hanno Böck &lt;hanno@hboeck.de&gt; writes:

&gt; You're only checking n (for both private and public keys), I could
&gt; probably still craft a private key that crashes by choosing one of p or
&gt; q to be even.

Nettle's private key struct doesn't include n, it's computed as the
product of p and q. So if either is even, n will be even too.

&gt; Depends on how far you want to go.
&gt; Easy checks:
&gt; * d, e must not be 0, 1, 2

For public keys, with this fix, _prepare_key checks that n is odd and
that |n| isn't too small. I'm considering adding the checks that n &gt; 0,
and 1 &lt; e &lt; n. In addition, the application ought to check that n isn't
unreasonably large, to avoid denial of service, but I don't think that
limit belongs in nettle.

For private keys, with the fix the same checks are applied to p * q. One
could also check p &gt; 0, q &gt; 0, and that CRT parameters are in the
expected range, 0 &lt; a &lt; p - 1, 0 &lt; b &lt; q - 1, 0 &lt; c &lt; p.

&gt; Yeah, I've been thinking a bit about it yesterday, I could still see
&gt; problems with this approach.

I guess part of the problem is that key format standards, like pkcs#1,
define valid ranges for parameters. But when using Nettle's
rsa_public_key_prepare, the input isn't a key blob defined by some
particular standard, but a couple of (big) integers.

Not sure if gnutls uses rsa_public_key_prepare directly, or via
rsa_keypair_from_der.

&gt; I ended up wishing that there'd be a defined standard set of key sanity
&gt; checks shared among implementations... but I'm probably just dreaming
&gt; here...

Valid ranges are defined by key format standards (fine details might
differ, I imagine, e.g., one may or may not require that p &gt; q), but
there are no standards for deeper sanity checks, as far as I'm aware.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160620173339</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2016-06-20 17:33:39-0400</timestampReceived><subject>Re: Using mpz_powm_sec</subject><body>

Hi Niels--

On Mon 2016-06-20 01:30:47 -0400, Niels Möller wrote:
&gt; I'm considering the below patch, making use of the side-channel silent
&gt; mpz_powm_sec function. The idea is to make the RSA and DSA code less
&gt; vulnerable to side-channel attacks.

This is a good goal for Nettle to have.  Thanks!

&gt; Exponentiation routines typically build a small table of powers at run
&gt; time, and then look up exponent bits in the table, a few bits at the
&gt; time. This table lookup may leak information about the exponent bits
&gt; (which in the case of RSA and DSA are secret) to an attacker running
&gt; other processes on the same physical machine.

This is increasingly relevant in today's virtualized world.

&gt; * The patch drops support for GMP versions older than GMP-5.0, relased
&gt;   in 2010. 

I don't think this bump in dependencies is a problem.

&gt; Despite not plugging *all* potential leaks in the RSA code, I think the
&gt; simple change to use use mpz_powm_sec should make attacks using the
&gt; cache side-channel considerably more difficult.

I agree that this is a step in the right direction.  the closer to
constant time, the better.

         --dkg

</body></email><email><emailId>20160502202806</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-05-02 20:28:06-0400</timestampReceived><subject>Re: Curve25519 and RFC 7748</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; So I'm considering this change,
&gt;
&gt; diff --git a/curve25519-mul.c b/curve25519-mul.c
&gt; index adb20cb..f5127d7 100644
&gt; --- a/curve25519-mul.c
&gt; +++ b/curve25519-mul.c
&gt; @@ -72,7 +72,11 @@ curve25519_mul (uint8_t *q, const uint8_t *n, const uint8_t *p)
&gt;    itch = ecc-&gt;p.size * 12;
&gt;    scratch = gmp_alloc_limbs (itch);
&gt;  
&gt; +  /* Note that 255 % GMP_NUMB_BITS == 0 isn't supported, so x1 always
&gt; +     holds at least 256 bits. */
&gt;    mpn_set_base256_le (x1, ecc-&gt;p.size, p, CURVE25519_SIZE);
&gt; +  /* Clear bit 255, as required by RFC 7748. */
&gt; +  x1[255/GMP_NUMB_BITS] &amp;= ~((mp_limb_t) 1 &lt;&lt; (255 % GMP_NUMB_BITS));
&gt;  
&gt;    /* Initialize, x2 = x1, z2 = 1 */
&gt;    mpn_copyi (x2, x1, ecc-&gt;p.size);
&gt;

Checked in now, together with updates of tests and docs.

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; It would make sense to document the version of nettle after which this
&gt; behavior is followed, and probably add some ifdef similarly to FIPS202
&gt; for sha3.

Not done yet.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160905142925</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-09-05 14:29:25-0400</timestampReceived><subject>TLS 1.3 in gnutls</subject><body>

Hi,
 I've tried to make a rough sketch of the requirements needed to
support TLS 1.3 in gnutls. I've split the task in sub-tasks on [0].
Some need to be handled in gnutls and some need to be handled in
nettle. Do you think I've missed something, or there are tasks that
can be further split? About the nettle additions, is there anyone
already working or willing to work on these? On the gnutls part is
there anyone already working or willing to work on the missing parts?

regards,
Nikos

[0]. https://gitlab.com/gnutls/gnutls/milestones/8

</body></email><email><emailId>20160913210344</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-09-13 21:03:44-0400</timestampReceived><subject>Pre-release testing (was: Re: use gitlab's shared runners)</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; This patch converts nettle's CI to use gitlab's infrastructure. Red
&gt; Hat's specific runners currently used for CI will be phased out, so it
&gt; makes sense to switch to gitlab.com shared infrastructure.

Applied.

&gt; An other advantage is that more (Linux) systems can be checked due to
&gt; the fact that this CI is based on docker.

Do they provide any non-x86 systems?

I've done some manual pre-release builds for x86_64 and x86 on
gnu/linux, freebsd, and windows (using mingw + wine, this time with some
trouble, see https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=837108).

So this is a good time to be testing nettle on other architectures and
other operating systems. In particular, help testing with Mac OSX and
Android is appreciated (and maybe Apple ios; I'm not familiar with the
details of Apple's appstore terms, so I'm not sure whether or not Nettle
can be used in ios apps distributed to non-rooted devices, but I guess
it might be possible for GPLv2 apps).

I have access to some emulated machines with gnu/linux or freebsd on
non-x86, which I hope I get the time to run some tests on.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160905161518</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-09-05 16:15:18-0400</timestampReceived><subject>Re: TLS 1.3 in gnutls</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; [0]. https://gitlab.com/gnutls/gnutls/milestones/8

Nettle additions:

* HKDF (RFC 5869): Should be reasonably straight forward. Any use
  besides TLS 1.3?

* RSA-PSS. I take it's mandatory? I had the impression that pss was
  almost dead (specified more than a decade ago, and very rarely used,
  hard to do constant time). We'll have to support it, I guess. Andy
  Lawrence expressed some interest on the Nettle list last December, but
  I don't know what's happened since.

  If I quote Peter Gutmann on the secsh mailing list:

   : However, PSS has seen so little interest from both the crypto
   : community and implementers that we can't really say much about it.  For
   : example for some years the NIST test vectors for RSA-PSS were completely wrong
   : (every single test except the SHA-224 ones failed), and no-one noticed.
   : 
   : I'll just let that sink in for a second.  The published test vectors from a
   : major, effectively global in reach, standards body for RSA-PSS were wrong, and
   : no-one noticed.  How much attention do you think that indicates PSS has got in
   : practice?

* x448. Should be able to reuse some of the curve25519 code, but not
  all. for curve25519, multiplying a point by a scalar is doen using a
  Montgomery ladder (see curve25519-mul.c), and I'd expect it to be
  reasonably straight forward to generalize to x448. On the other hand,
  multiplying the fixed generator by a scalar is done on the
  corresponding (twisted) edwards curve, using Pippenger's algorithm,
  and then transformed back by a change of coordinates, see below.

* ed448. This curve has slightly different structure from ed25519 (not
  twisted). Current point add code for ed25519 is suboptimal, it uses
  formulas for non-twisted curve with appropriate only sign changes, and
  it could save a mod mul by taking better advantage of the twist. So
  ed448 needs its own point addition code.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160530231402</emailId><senderName>Aaron Boxer</senderName><senderEmail>boxerab@gmail.com</senderEmail><timestampReceived>2016-05-30 23:14:02-0400</timestampReceived><subject>Re: Porting openssl code to nettle</subject><body>

On Mon, May 30, 2016 at 3:16 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; Aaron Boxer &lt;boxerab@gmail.com&gt; writes:
&gt;
&gt; &gt; For KM_prng.cpp , are you suggesting that I use 128 bit AES instead of
&gt; 256
&gt; &gt; bit ?
&gt; &gt; I think the original code used 256 bit.
&gt;
&gt; I might have misread the code. If the original code used 256-bit aes,
&gt; always, you should use nettle's aes256_ctx when porting it over.
&gt;

Niels, you were right, the code does use 128 bit encryption.

Thanks so much,
Aaron

</body></email><email><emailId>20160914045445</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-09-14 04:54:45-0400</timestampReceived><subject>Re: Pre-release testing</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; So this is a good time to be testing nettle on other architectures and
&gt; other operating systems.

I've prepared a tarball,
https://www.lysator.liu.se/~nisse/archive/nettle-3.3rc1.tar.gz, so it
can be build with a plain ./configure &amp;&amp; make &amp;&amp; make check, without
having autoconf installed.

/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160426050628</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-04-26 05:06:28-0400</timestampReceived><subject>Re: Curve25519 and RFC 7748</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; It would make sense to document the version of nettle after which this
&gt; behavior is followed,

Makes sense, I guess. Note that current behaviour is quite explicitly
undocumented, "The output value is defined only when the input @var{p}
is a string produced by @code{curve25519_mul_g}", and that function
shouldn't produce any strings with the top bit set.

It would also be relevant to compare with NaCl's crypto_scalar_mult_base
function, does anyone on the list know how it behaves in this respect?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160315182659</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-03-15 18:26:59-0400</timestampReceived><subject>Re: patch to use gitlab runners with libasan and libubsan</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; The attached patches address the undefined behavior dependence
&gt; for blowfish, twofish and des, and enable gitlab builds with
&gt; asan and ubsan.

Thanks. I'm applying the last two patches (the des error was a little
embarrassing...). For the first patch, I'd prefer to solve the problem
slightly differently, see comments below.

&gt; @@ -359,8 +359,8 @@ blowfish_decrypt (const struct blowfish_ctx *ctx,
&gt;      {
&gt;        uint32_t d1, d2;
&gt;  
&gt; -      d1 = src[0] &lt;&lt; 24 | src[1] &lt;&lt; 16 | src[2] &lt;&lt; 8 | src[3];
&gt; -      d2 = src[4] &lt;&lt; 24 | src[5] &lt;&lt; 16 | src[6] &lt;&lt; 8 | src[7];
&gt; +      d1 = (((uint32_t)src[0]) &lt;&lt; 24) | src[1] &lt;&lt; 16 | src[2] &lt;&lt; 8 | src[3];
&gt; +      d2 = (((uint32_t)src[4]) &lt;&lt; 24) | src[5] &lt;&lt; 16 | src[6] &lt;&lt; 8 | src[7];

Use the READ_UINT32 macro instead, which includes the needed cast. And
the same must be done for the blowfish_encrypt function just above, too.

&gt; --- a/twofish.c
&gt; +++ b/twofish.c
&gt; @@ -190,14 +190,14 @@ compute_s(uint32_t m1, uint32_t m2)
&gt;    uint32_t s = 0;
&gt;    int i;
&gt;    for (i = 0; i &lt; 4; i++)
&gt; -    s |=  ((  gf_multiply(0x4D, m1,       rs_matrix[i][0])
&gt; +    s |= ((uint32_t)((  gf_multiply(0x4D, m1,       rs_matrix[i][0])

I think it's simpler to change the return type of gf_multiply to
uint32_t, and delete similar casts in the other places where it is used.

I'll try to take care of it, remind me if it isn't fixed within a few
days.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160318094813</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-03-18 09:48:13-0400</timestampReceived><subject>Re: mini-gmp builds enhancements</subject><body>

On Wed, 2016-03-16 at 10:46 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; 
&gt; &gt; 
&gt; &gt; One other approach would to be keep a different namespace for
&gt; &gt; private
&gt; &gt; symbols that need to be exported for test applications and so.
&gt; That makes sense. But I don't understand what type of "namespaces"
&gt; you
&gt; refer to here. Can you explain? How would a test program gain access
&gt; to
&gt; functions in the internal namespace?

In gnutls I keep the supported ABI under the GNUTLS_3_4 namespace while
functions that need to be exported for testing or other purposes are
assigned to GNUTLS_PRIVATE_3_4.

I set that using the version script:
https://gitlab.com/gnutls/gnutls/blob/master/lib/libgnutls.map

I don't know if there are any other best practices.

regards,
Nikos


</body></email><email><emailId>20160330173131</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-03-30 17:31:31-0400</timestampReceived><subject>Re: dll file names</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; On Thu, 2016-02-18 at 15:16 +0100, Niels Möller wrote:
&gt;&gt; Following the libtool convention makes some sense. And then the dll
&gt;&gt; name follows the soname in the ELF world. Do others agree?
&gt;
&gt; Would it make sense to include the patch?

Thanks for the reminder. Committed and pushed now.

/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160207154408</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-02-07 15:44:08-0400</timestampReceived><subject>Re: cross compiling nettle-3.2  for armv7 on linux</subject><body>

Girish Kumar &lt;girish.kumar@al-enterprise.com&gt; writes:

&gt; I am cross compiling nettle-3.2  for armv7 on linux. But I  am getting following error.

&gt;     $(LTOP)/nettle-3.2/configure --prefix=$(BUILT_BASE)
&gt; --host=$(CCPREFIX) --disable-static&amp;&gt; $(OBJS)/nettle/configure.out
&gt;     @touch $(OBJS)/nettle/nettle.configured

You don't say what CCPREFIX is?

&gt;     declare -x HOSTCC=`which gcc`;\

You probably want CC_FOR_BUILD, or the old name HOST_CC. Nothing I'm
aware of examines the variable HOSTCC. And for it to have effect,
you should set it when invoking configure, not when invoking make. But
it gcc is in your PATH (which it has to be for which to find it), you
shouldn't need to set any environment variables to point it out.

&gt;     $(MAKE) install  &amp;&gt; $(OBJS)/nettle/install.out
&gt; checking build system compiler gcc... no
&gt; checking build system compiler cc... no
&gt; checking build system compiler c89... no
&gt; checking build system compiler c99... no
&gt; configure: error: Cannot find a build system compiler

For trouble-shooting configure problems liek this, you have to look in
config.log. There you should find the commands configure tries to run,
and error messages when they fail.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160717101427</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-07-17 10:14:27-0400</timestampReceived><subject>char vs uint8_t</subject><body>

I'd like to eliminate pointer-signedness warnings. I'm afraid some ugly
casts will have to be involved, since most functions work with uint8_t,
and at least test code needs to pass literal strings, of type char *.

I have one question, on the ascii-armor funtions: Would ie make sense
to change the type of ascii inputs and outputs to char? I.e.,

 size_t
 base64_encode_update(struct base64_encode_ctx *ctx,
-		     uint8_t *dst,
+		     char *dst,
 		     size_t length,
 		     const uint8_t *src);

and similarly for all related functions. It would be an API change but
not an ABI change for any ABI spec I'm aware of. What do you think? So
the input to encoding is an octet string (uint8_t), and the output is a
string of plain char. And vice versa for decoding functions.

Also applies to the type arguments for sexp_iterator_check_type,
sexp_iterator_check_types and sexp_iterator_assoc, currently using
uint8_t. They are usually called with literal ascii strings, so it would
make some sense to type as char rather than uint8_t. (I don't think
these are used much by any application except lsh and libspki).

And no matter how things are typed, I wouldn't expect nettle to work out
of the box on platforms where char and uint8_t are of different size, or
where string literals use a non-asciii character set.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20160717123559</emailId><senderName>Amos Jeffries</senderName><senderEmail>squid3@treenet.co.nz</senderEmail><timestampReceived>2016-07-17 12:35:59-0400</timestampReceived><subject>Re: char vs uint8_t</subject><body>

On 17/07/2016 10:14 p.m., Niels Möller wrote:
&gt; I'd like to eliminate pointer-signedness warnings. I'm afraid some ugly
&gt; casts will have to be involved, since most functions work with uint8_t,
&gt; and at least test code needs to pass literal strings, of type char *.
&gt; 
&gt; I have one question, on the ascii-armor funtions: Would ie make sense
&gt; to change the type of ascii inputs and outputs to char? I.e.,
&gt; 
&gt;  size_t
&gt;  base64_encode_update(struct base64_encode_ctx *ctx,
&gt; -		     uint8_t *dst,
&gt; +		     char *dst,
&gt;  		     size_t length,
&gt;  		     const uint8_t *src);
&gt; 
&gt; and similarly for all related functions. It would be an API change but
&gt; not an ABI change for any ABI spec I'm aware of. What do you think? So
&gt; the input to encoding is an octet string (uint8_t), and the output is a
&gt; string of plain char. And vice versa for decoding functions.
&gt; 

As one user of these functions from nettle it is only long-term gain. We
already have nasty casting to get from char to uint8_t at our end. In
the 5yr-10yr short term we still need to support older libraries API, so
that annoyance wont disappear for a long while. It is only a minor
change to convert with a helper macro or function though.

Our uses of nettle are Base-64 and MD5 currently. With SHA and AES on
the semi-distant horizon. The remaining crypto done indirectly through
GnuTLS.

Amos


</body></email><email><emailId>20160209153706</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-02-09 15:37:06-0400</timestampReceived><subject>Re: backporting ecc patches</subject><body>

On Tue, 2016-02-09 at 15:52 +0100, Niels Möller wrote:

&gt; &gt; Do you plan a backport of the carry propagation fix in secp384 [0]
&gt; &gt; for
&gt; &gt; nettle 2.7.1?  
&gt; I hadn't planned to do that. Do you think I should?

It's up to you. We plan to keep using this version of the library for
quite long time.


&gt; &gt; My limited understanding of the 3.2 assembly file
&gt; &gt; wouldn't work out of the box in 2.7 due to the change from
&gt; &gt; ecc_curve to
&gt; &gt; ecc_modulus.
&gt; 
&gt; I don't think that should be a problem, since the first argument to
&gt; ecc_384_modp isn't used by the assembly implementation.
&gt; 
&gt; Hanno already pointed to the patches prepared by the debian
&gt; maintainer.
&gt; https://bugs.debian.org/cgi-bin/bugreport.cgi?msg=15;bug=813679;filen
&gt; ame=nettle_2.7.1-5%2Bdeb8u1.debian.tar.xz;att=1
&gt; (not yet available at
&gt; https://sources.debian.net/src/nettle/2.7.1-5/debian/patches/, it
&gt; seems).

Thank you. One more thing on that. The Debian fix uses the new asm code
under the LGPLv2+ license. Could I assume that you grant an exception
for this file?

regards,
Nikos


</body></email><email><emailId>20160216073610</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-02-16 07:36:10-0400</timestampReceived><subject>Re: abort / assert issues in sexp-conv</subject><body>

Hanno Böck &lt;hanno@hboeck.de&gt; writes:

&gt; I did a quick fuzzing test of the command line tools coming with nettle.

Fixes checked in now.

&gt; echo "{MiM}"|sexp-conv
&gt; causes an assert:
&gt; sexp-conv: /var/tmp/portage/dev-libs/nettle-3.2/work/nettle-3.2/tools/input.c:128:
&gt; sexp_input_start_coding: Assertion `!input-&gt;coding' failed.

This one was interesting. {} indicates "transport syntax", which is
canonical syntax wrapped in base64 encoding. MiM is not a valid base64
encoding, but it nevertheless decodes to the two characters "2#" before
the truncation is detected. And "2#" is the start of hex string in
advanced syntax, but invalid in canonical syntax. 

The code used to improperly accept it as a hex string and configure the
input for base16 decoding. And then triggered an assertion failure
because the code wasn't prepared to handle several layers of decoding,
with base16 inside base64.

This case (and other uses of advanced syntax in this context) should now
be rejected with an error message.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160218141652</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-02-18 14:16:52-0400</timestampReceived><subject>Re: dll file names</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; The libtool approach is to give the major number only, e.g., libgnutls-
&gt; 28.dll.

Following the libtool convention makes some sense. And then the dll name
follows the soname in the ELF world. Do others agree?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160229122953</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-02-29 12:29:53-0400</timestampReceived><subject>patch to use gitlab runners with libasan and libubsan</subject><body>

Hello,
 I've now completed enabling the undefined sanitizer for gnutls, and
may be a good idea to use it for nettle to.  The following patch
enables running the test suite of nettle under libasan (to detect any
invalid memory accesses/writes), and the undefined sanitizer.

I've run a test build, and the libasan build succeeds but the libubsan
builds fail:
https://gitlab.com/gnutls/nettle/builds/773956

Its complaints are not that critical for the targetted platforms but
may be nice not to rely on undefined behavior.

regards,
Nikos

["0001-.gitlab-ci.yml-enhance-with-builds-using-asan-and-ub.patch" (text/x-patch)]

From ec91a25e8e40ff58b532e2291eeeaece355504ab Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Mon, 29 Feb 2016 13:08:36 +0100
Subject: [PATCH] .gitlab-ci.yml: enhance with builds using asan and ubsan

This allows running the test suite under address sanitizer and undefined
sanitizer.
---
 .gitlab-ci.yml | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 99b241e..8d44cbb 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -17,3 +17,19 @@ Build and Check (x86):
   - x86
   except:
   - tags
+Build and Check with ubsan:
+  script:
+  - ./.bootstrap &amp;&amp; 
+    CXXFLAGS="-fsanitize=undefined -fno-sanitize-recover -g -O2" \
CFLAGS="-fsanitize=undefined -fno-sanitize-recover -g -O2" ./configure  +    \
--disable-documentation &amp;&amp; make -j4 &amp;&amp; make check -j4 +  tags:
+  - ubsan
+  except:
+  - tags
+Build and Check with asan:
+  script:
+  - ./.bootstrap &amp;&amp; 
+  - CXXFLAGS="-fsanitize=address -g -O2" CFLAGS="-fsanitize=address -g -O2" \
./configure --disable-documentation &amp;&amp; +    make -j4 &amp;&amp; make check -j4
+  except:
+  - tags
-- 
2.5.0



</body></email><email><emailId>20160108141446</emailId><senderName>Tim Ruehsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2016-01-08 14:14:46-0400</timestampReceived><subject>Re: Hashing with short input assertion question</subject><body>


On Friday 08 January 2016 13:16:27 Niels Möller wrote:
&gt; Tim Ruehsen &lt;tim.ruehsen@gmx.de&gt; writes:
&gt; &gt; I meanwhile found the nettle docs on the web
&gt; 
&gt; &gt; (http://www.lysator.liu.se/~nisse/nettle/nettle.html#MD5):
&gt; I'm happy you found the documentation. The manual should also be
&gt; included in debian's nettle-dev package, in info, html and pdf formats.
&gt; 
&gt; &gt; ###########
&gt; &gt; Function: void md5_digest (struct md5_ctx *ctx, size_t length, uint8_t
&gt; &gt; *digest)
&gt; &gt; 
&gt; &gt; Performs final processing and extracts the message digest, writing it to
&gt; &gt; digest. length may be smaller than MD5_DIGEST_SIZE, in which case only the
&gt; &gt; first length octets of the digest are written.
&gt; &gt; ###########
&gt; 
&gt; Sorry you find this unclear. Can you suggest a concise improvement?

Never said the text is unclear. It just misses the case when 'length' is too 
large.
Citing my proposal from my previous email:
&gt; 'If length is larger than MD5_DIGEST_SIZE the 
&gt; function does not return - it calls abort()'

Or more precise
If length is larger than MD5_DIGEST_SIZE an assertion is generated and by that 
the program is terminated by abort(). To avoid this behavior nettle has to be 
compiled with -DNDEBUG (additional bytes will not be touched).


&gt;     ctx = alloca(hash-&gt;context_size);
&gt;     hash-&gt;init(ctx);
&gt;     hash-&gt;update(ctx, length, msg);
&gt;     hash-&gt;digest(ctx, hash-&gt;digest_size, digest);
&gt;     return hash-&gt;digest_size;
&gt;   }
&gt; 
&gt; I don't think that passing a valid digest size to hash-&gt;digest here
&gt; should be a big deal.

Thanks Niels. This part is already up and running.
My writing was for Amos to make clear that MD5_DIGEST_SIZE and the like are 
not needed from a higher level perspective.

Regards, Tim

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20160125102953</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-01-25 10:29:53-0400</timestampReceived><subject>Re: using gitlab CI for nettle</subject><body>

On Thu, Jan 21, 2016 at 8:53 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt;&gt; I tested it and it works (you need to remove the git pull step as this
&gt;&gt; is already done by gitlab ci).
&gt; Ok, deleted the git pull commands, and checked in now.

Nice. I do not see new builds being spawned but this seems related to
an issue gitlab guys had with mirrored project builds [0]. I hope that
this is resolved soon.

regards,
Nikos

[0]. https://gitlab.com/gitlab-org/gitlab-ee/issues/190

</body></email><email><emailId>20160126215017</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-01-26 21:50:17-0400</timestampReceived><subject>Re: nettle-pbkdf2 dumps core when executed with an unknown option</subject><body>

dongsheng zhang &lt;dongsheng.zhang@oracle.com&gt; writes:

&gt; Will a newer version of nettle with the fix be released soon please?

Your bug report was very timely, a new relase, nettle-3.2, is planned
this week.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160310171000</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-03-10 17:10:00-0400</timestampReceived><subject>mini-gmp builds enhancements</subject><body>

The attached patches fix compilation issues with mini-gmp, add a gitlab
build rule, and prevent the symbols defined in gmp-glue.h from being
exported into nettle's ABI.

The latter was to avoid abidiff differences to hogweed's ABI when built
with different gmp versions. For that I renamed the gmp-glue _nettle_*
symbols to _inettle_*.

regards,
Nikos

["0001-gmp-glue-don-t-export-internal-symbols-used-by-gmp-g.patch" (0001-gmp-glue-don-t-export-internal-symbols-used-by-gmp-g.patch)]

From 14878f9e463ecd5b8c86cfb644e56174c175d04d Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Thu, 10 Mar 2016 16:45:35 +0100
Subject: [PATCH 1/3] gmp-glue: don't export internal symbols used by gmp-glue

---
 gmp-glue.h             | 40 ++++++++++++++++++++--------------------
 testsuite/Makefile.in  |  4 ++--
 testsuite/symbols-test |  2 +-
 3 files changed, 23 insertions(+), 23 deletions(-)

diff --git a/gmp-glue.h b/gmp-glue.h
index 7713757..8cf2962 100644
--- a/gmp-glue.h
+++ b/gmp-glue.h
@@ -49,35 +49,35 @@
 
 /* Name mangling. */
 #if !GMP_HAVE_mpz_limbs_read
-#define mpz_limbs_read _nettle_mpz_limbs_read
-#define mpz_limbs_write _nettle_mpz_limbs_write
-#define mpz_limbs_modify _nettle_mpz_limbs_modify
-#define mpz_limbs_finish _nettle_mpz_limbs_finish
-#define mpz_roinit_n _nettle_mpz_roinit_n
+#define mpz_limbs_read _inettle_mpz_limbs_read
+#define mpz_limbs_write _inettle_mpz_limbs_write
+#define mpz_limbs_modify _inettle_mpz_limbs_modify
+#define mpz_limbs_finish _inettle_mpz_limbs_finish
+#define mpz_roinit_n _inettle_mpz_roinit_n
 #endif
 
 #if !GMP_HAVE_mpn_copyd
-#define mpn_copyd _nettle_mpn_copyd
-#define mpn_copyi _nettle_mpn_copyi
-#define mpn_zero  _nettle_mpn_zero
+#define mpn_copyd _inettle_mpn_copyd
+#define mpn_copyi _inettle_mpn_copyi
+#define mpn_zero  _inettle_mpn_zero
 #endif
 
 #ifndef mpn_sqr
 #define mpn_sqr(rp, ap, n) mpn_mul_n((rp), (ap), (ap), (n))
 #endif
 
-#define cnd_swap _nettle_cnd_swap
-#define mpz_limbs_cmp _nettle_mpz_limbs_cmp
-#define mpz_limbs_read_n _nettle_mpz_limbs_read_n
-#define mpz_limbs_copy _nettle_mpz_limbs_copy
-#define mpz_set_n _nettle_mpz_set_n
-#define mpn_set_base256 _nettle_mpn_set_base256
-#define mpn_set_base256_le _nettle_mpn_set_base256_le
-#define mpn_get_base256_le _nettle_mpn_get_base256_le
-#define gmp_alloc_limbs _nettle_gmp_alloc_limbs
-#define gmp_free_limbs _nettle_gmp_free_limbs
-#define gmp_free _nettle_gmp_free
-#define gmp_alloc _nettle_gmp_alloc
+#define cnd_swap _inettle_cnd_swap
+#define mpz_limbs_cmp _inettle_mpz_limbs_cmp
+#define mpz_limbs_read_n _inettle_mpz_limbs_read_n
+#define mpz_limbs_copy _inettle_mpz_limbs_copy
+#define mpz_set_n _inettle_mpz_set_n
+#define mpn_set_base256 _inettle_mpn_set_base256
+#define mpn_set_base256_le _inettle_mpn_set_base256_le
+#define mpn_get_base256_le _inettle_mpn_get_base256_le
+#define gmp_alloc_limbs _inettle_gmp_alloc_limbs
+#define gmp_free_limbs _inettle_gmp_free_limbs
+#define gmp_free _inettle_gmp_free
+#define gmp_alloc _inettle_gmp_alloc
 
 #define TMP_GMP_DECL(name, type) type *name;	\
   size_t tmp_##name##_size
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 02c18fc..aa84141 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -63,7 +63,7 @@ EXTRA_TARGETS = $(EXTRA_SOURCES:.c=$(EXEEXT))
 
 
 # Includes all C source files, regardless of configuration
-SOURCES = $(TS_SOURCES) $(EXTRA_SOURCES) testutils.c dlopen-test.c
+SOURCES = $(TS_SOURCES) $(EXTRA_SOURCES) testutils.c dlopen-test.c ../gmp-glue.c
 
 DISTFILES = $(SOURCES) $(CXX_SOURCES) Makefile.in .test-rules.make \
 	    $(TS_SH) setup-env teardown-env \
@@ -84,7 +84,7 @@ all: $(EXTRA_TARGETS)
 # explicit rule for each and every executable.
 
 LIB_HOGWEED = @IF_HOGWEED@ -lhogweed
-TEST_OBJS = testutils.$(OBJEXT) ../nettle-internal.$(OBJEXT) \
+TEST_OBJS = testutils.$(OBJEXT) ../gmp-glue.$(OBJEXT) ../nettle-internal.$(OBJEXT) \
 	    $(LIB_HOGWEED) -lnettle $(LIBS)
 
 ../nettle-internal.$(OBJEXT):
diff --git a/testsuite/symbols-test b/testsuite/symbols-test
index 051d3d2..2aaac33 100755
--- a/testsuite/symbols-test
+++ b/testsuite/symbols-test
@@ -27,7 +27,7 @@ if [ -s test1.out ] ; then
 fi
 
 if [ -s ../libhogweed.a ] ; then
-    PATTERN='\.?_?_?nettle_|get_pc_thunk'
+    PATTERN='\.?_?_?nettle_|_inettle_|get_pc_thunk'
     if grep '^#define.*NETTLE_USE_MINI_GMP.*1$' ../version.h &gt;/dev/null ; then
 	PATTERN="$PATTERN|_?(mp_|mpz_|mpn_)"
     fi
-- 
2.5.0


["0002-configure-export-mp_-symbols-when-compiling-with-min.patch" (0002-configure-export-mp_-symbols-when-compiling-with-min.patch)]

From f13aae72cba67bb8bc7462b88d79a7e29ca2d6bb Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Thu, 10 Mar 2016 17:44:08 +0100
Subject: [PATCH 2/3] configure: export mp_ symbols when compiling with
 mini-gmp

This addresses build issue when compiling with --enable-mini-gmp
and the symbol script being used.
---
 configure.ac | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index 3d804db..029a15c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -91,7 +91,7 @@ AC_ARG_ENABLE(mini-gmp,
 
 if test "x$enable_mini_gmp" = xyes ; then
   NETTLE_USE_MINI_GMP=1
-  HOGWEED_EXTRA_SYMBOLS="mpz_*;gmp_*;mpn_*;"
+  HOGWEED_EXTRA_SYMBOLS="mpz_*;gmp_*;mpn_*;mp_*;"
 else
   NETTLE_USE_MINI_GMP=0
   HOGWEED_EXTRA_SYMBOLS=""
-- 
2.5.0


["0003-.gitlab-ci.yml-enhance-with-mini-gmp-builds.patch" (0003-.gitlab-ci.yml-enhance-with-mini-gmp-builds.patch)]

From 97731353e81dba097c533a1b5be285508efc3384 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Thu, 10 Mar 2016 17:45:07 +0100
Subject: [PATCH 3/3] .gitlab-ci.yml: enhance with mini-gmp builds

---
 .gitlab-ci.yml | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 8d44cbb..eafe0d6 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -17,6 +17,14 @@ Build and Check (x86):
   - x86
   except:
   - tags
+Build and Check with mini-gmp:
+  script:
+  - ./.bootstrap &amp;&amp;
+    ./configure --disable-documentation --enable-mini-gmp &amp;&amp; make -j4 &amp;&amp;
+    make check -j4
+  tags:
+  except:
+  - tags
 Build and Check with ubsan:
   script:
   - ./.bootstrap &amp;&amp; 
-- 
2.5.0



</body></email><email><emailId>20160315185034</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-03-15 18:50:34-0400</timestampReceived><subject>Re: mini-gmp builds enhancements</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; The latter was to avoid abidiff differences to hogweed's ABI when built
&gt; with different gmp versions. For that I renamed the gmp-glue _nettle_*
&gt; symbols to _inettle_*.

Can you explain what the problem is? I know there's been some hassle
also for the debian maintainer, but apparently solvable by other means.

I don't like the "_inettle_" prefix, though. We shouldn't add even more
prefixes to the symbol namespace (for an ELF shared library, it might
not matter much, if the point is to make the symbols in question
unexported, but we also have static libraries).

Would it work to instead exclude _nettle_mp?_* or so?

&gt; --- a/testsuite/Makefile.in
&gt; +++ b/testsuite/Makefile.in
&gt; @@ -84,7 +84,7 @@ all: $(EXTRA_TARGETS)
&gt;  # explicit rule for each and every executable.
&gt;  
&gt;  LIB_HOGWEED = @IF_HOGWEED@ -lhogweed
&gt; -TEST_OBJS = testutils.$(OBJEXT) ../nettle-internal.$(OBJEXT) \
&gt; +TEST_OBJS = testutils.$(OBJEXT) ../gmp-glue.$(OBJEXT) ../nettle-internal.$(OBJEXT) \
&gt;  	    $(LIB_HOGWEED) -lnettle $(LIBS)

Why is this? Test code using the gmp-glue functions, and they're now hidden
in the library?

&gt; From f13aae72cba67bb8bc7462b88d79a7e29ca2d6bb Mon Sep 17 00:00:00 2001
&gt; From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
&gt; Date: Thu, 10 Mar 2016 17:44:08 +0100
&gt; Subject: [PATCH 2/3] configure: export mp_ symbols when compiling with
&gt;  mini-gmp
&gt;
&gt; This addresses build issue when compiling with --enable-mini-gmp
&gt; and the symbol script being used.

Applied.

&gt; From 97731353e81dba097c533a1b5be285508efc3384 Mon Sep 17 00:00:00 2001
&gt; From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
&gt; Date: Thu, 10 Mar 2016 17:45:07 +0100
&gt; Subject: [PATCH 3/3] .gitlab-ci.yml: enhance with mini-gmp builds

Applied.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160218100616</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-02-18 10:06:16-0400</timestampReceived><subject>dll file names</subject><body>

Hello,
 The attached patch corrects the name used for the windows dlls. With
the current naming, it is not possible to update an existing version
of nettle by dropping the new files in place and the patch fixes that.

regards,
Nikos

</body></email><email><emailId>20160218132728</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-02-18 13:27:28-0400</timestampReceived><subject>Re: dll file names</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt;  The attached patch corrects the name used for the windows dlls.

Patch didn't make it to the list.

&gt; With the current naming, it is not possible to update an existing
&gt; version of nettle by dropping the new files in place and the patch
&gt; fixes that.

I don't have a clear idea about how it should work. It would be good to
document the intended dll naming scheme in configure.ac and/or the
manual.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160218133342</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-02-18 13:33:42-0400</timestampReceived><subject>Re: dll file names</subject><body>

On Thu, 2016-02-18 at 14:27 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt; 
&gt; &gt;   The attached patch corrects the name used for the windows dlls.
&gt; 
&gt; Patch didn't make it to the list.
&gt; 
&gt; &gt; With the current naming, it is not possible to update an existing
&gt; &gt; version of nettle by dropping the new files in place and the patch
&gt; &gt; fixes that.
&gt; 
&gt; I don't have a clear idea about how it should work. It would be good
&gt; to document the intended dll naming scheme in configure.ac and/or the
&gt; manual.

The libtool approach is to give the major number only, e.g., libgnutls-
28.dll. Currently nettle 3.0 is libnettle-3-0.dll while 3.2 is
libnettle-3-2.dll. That means that applications linked to libnettle-3-
0.dll will not use libnettle-3-2.dll if copied on the same directory.

regards,
Nikos

["0001-Corrected-the-name-of-the-windows-dll-files.patch" (0001-Corrected-the-name-of-the-windows-dll-files.patch)]

From 8b74c5e5fd85b5f08aeb24942605632e7a59a3ce Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Thu, 18 Feb 2016 11:03:25 +0100
Subject: [PATCH] Corrected the name of the windows dll files

The new name doesn't include the minor number and thus
allows to replace with a minor update of the library.
---
 configure.ac | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/configure.ac b/configure.ac
index 3d804db..c41e453 100644
--- a/configure.ac
+++ b/configure.ac
@@ -576,12 +576,12 @@ case "$host_os" in
     # linking to the DLL, is installed into the lib dir.
     case "$host_os" in
       mingw32*)
-        LIBNETTLE_FORLINK='libnettle-$(LIBNETTLE_MAJOR)-$(LIBNETTLE_MINOR).dll'
-        LIBHOGWEED_FORLINK='libhogweed-$(LIBHOGWEED_MAJOR)-$(LIBHOGWEED_MINOR).dll'
+        LIBNETTLE_FORLINK='libnettle-$(LIBNETTLE_MAJOR).dll'
+        LIBHOGWEED_FORLINK='libhogweed-$(LIBHOGWEED_MAJOR).dll'
         ;;
       cygwin*)
-        LIBNETTLE_FORLINK='cygnettle-$(LIBNETTLE_MAJOR)-$(LIBNETTLE_MINOR).dll'
-        LIBHOGWEED_FORLINK='cyghogweed-$(LIBHOGWEED_MAJOR)-$(LIBHOGWEED_MINOR).dll'
+        LIBNETTLE_FORLINK='cygnettle-$(LIBNETTLE_MAJOR).dll'
+        LIBHOGWEED_FORLINK='cyghogweed-$(LIBHOGWEED_MAJOR).dll'
         ;;
     esac
     if test "x$cross_compiling" = xyes ; then
-- 
2.5.0



</body></email><email><emailId>20160330085836</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-03-30 08:58:36-0400</timestampReceived><subject>Re: dll file names</subject><body>

On Thu, 2016-02-18 at 15:16 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; 
&gt; &gt; 
&gt; &gt; The libtool approach is to give the major number only, e.g.,
&gt; &gt; libgnutls-
&gt; &gt; 28.dll.
&gt; Following the libtool convention makes some sense. And then the dll
&gt; name follows the soname in the ELF world. Do others agree?

Would it make sense to include the patch?


</body></email><email><emailId>20160316084539</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-03-16 08:45:39-0400</timestampReceived><subject>Re: mini-gmp builds enhancements</subject><body>

On Tue, 2016-03-15 at 19:50 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; 
&gt; &gt; 
&gt; &gt; The latter was to avoid abidiff differences to hogweed's ABI when
&gt; &gt; built
&gt; &gt; with different gmp versions. For that I renamed the gmp-glue
&gt; &gt; _nettle_*
&gt; &gt; symbols to _inettle_*.
&gt; Can you explain what the problem is? I know there's been some hassle
&gt; also for the debian maintainer, but apparently solvable by other
&gt; means.

It's a question of, if they are not part of the ABI then why export
them to applications? By exporting internal functions you allow
applications to use them and you'll have issues when you try to
refactor them; see previous discussion with RSA blinding:
https://lists.lysator.liu.se/pipermail/nettle-bugs/2015/002995.html

One other approach would to be keep a different namespace for private
symbols that need to be exported for test applications and so.

&gt; I don't like the "_inettle_" prefix, though. We shouldn't add even
&gt; more
&gt; prefixes to the symbol namespace (for an ELF shared library, it might
&gt; not matter much, if the point is to make the symbols in question
&gt; unexported, but we also have static libraries).
&gt; 
&gt; Would it work to instead exclude _nettle_mp?_* or so?

That could be an option if it would work with the version script.
However, that would make the version script a place to list the
functions not to be exported, rather than vice-versa, and thus would be
hard to manage.

&gt; --- a/testsuite/Makefile.in
&gt; &gt; +++ b/testsuite/Makefile.in
&gt; &gt; @@ -84,7 +84,7 @@ all: $(EXTRA_TARGETS)
&gt; &gt;  # explicit rule for each and every executable.
&gt; &gt;  
&gt; &gt;  LIB_HOGWEED = @IF_HOGWEED@ -lhogweed
&gt; &gt; -TEST_OBJS = testutils.$(OBJEXT) ../nettle-internal.$(OBJEXT) \
&gt; &gt; +TEST_OBJS = testutils.$(OBJEXT) ../gmp-glue.$(OBJEXT) ../nettle-
&gt; &gt; internal.$(OBJEXT) \
&gt; &gt;  	    $(LIB_HOGWEED) -lnettle $(LIBS)
&gt; Why is this? Test code using the gmp-glue functions, and they're now
&gt; hidden in the library?

It includes the gmp-glue functions directly since they are not
available for use.

regards,
Nikos


</body></email><email><emailId>20160316094642</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-03-16 09:46:42-0400</timestampReceived><subject>Re: mini-gmp builds enhancements</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; One other approach would to be keep a different namespace for private
&gt; symbols that need to be exported for test applications and so.

That makes sense. But I don't understand what type of "namespaces" you
refer to here. Can you explain? How would a test program gain access to
functions in the internal namespace?

&gt;&gt; Would it work to instead exclude _nettle_mp?_* or so?
&gt;
&gt; That could be an option if it would work with the version script.
&gt; However, that would make the version script a place to list the
&gt; functions not to be exported, rather than vice-versa, and thus would be
&gt; hard to manage.

Hmm. And yet another option might be to use visibility attributes (an
ELF feature, I understand roughly how they work, but I don't have any
real experience).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160128002032</emailId><senderName>Mark H Weaver</senderName><senderEmail>mhw@netris.org</senderEmail><timestampReceived>2016-01-28 00:20:32-0400</timestampReceived><subject>Re: Nettle-3.2 plans</subject><body>

nisse@lysator.liu.se (Niels M=C3=B6ller) writes:

&gt; Now I think the documentation of the new RSA tr functions is in
&gt; reasonable shape, and I'd like to get a release out real soon now.
&gt;
&gt; I've put a release candidate at
&gt; https://www.lysator.liu.se/~nisse/archive/nettle-3.2rc1.tar.gz, and I've

I tested this on bare metal armhf with NEON (Novena) and mips64el N32
(Loongson 3A) systems running Guix, and both of them passed "make check".

     Regards,
       Mark

</body></email><email><emailId>20160209133122</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2016-02-09 13:31:22-0400</timestampReceived><subject>backporting ecc patches</subject><body>

Hello Niels,
 Do you plan a backport of the carry propagation fix in secp384 [0] for
nettle 2.7.1? My limited understanding of the 3.2 assembly file
wouldn't work out of the box in 2.7 due to the change from ecc_curve to
ecc_modulus.

The fix for the secp256r1 issue [1] looks quite trivial to backport if
p-&gt;m is replaced by ecc-&gt;p. Is my understanding correct?

regards,
Nikos


[0]. https://git.lysator.liu.se/nettle/nettle/commit/fa269b6ad06dd13c90
1dbd84a12e52b918a09cd7

[1]. https://git.lysator.liu.se/nettle/nettle/commit/c71d2c9d20eeebb985
e3872e4550137209e3ce4d


</body></email><email><emailId>20160213101359</emailId><senderName>Hanno =?UTF-8?B?QsO2Y2s=?=</senderName><senderEmail>hanno@hboeck.de</senderEmail><timestampReceived>2016-02-13 10:13:59-0400</timestampReceived><subject>abort / assert issues in sexp-conv</subject><body>

This is a MIME-formatted message.  If you see this text it means that your
E-mail software does not support MIME-formatted messages.


Hi,

I did a quick fuzzing test of the command line tools coming with nettle.

echo "]"|sexp-conv
will cause an abort call and
echo "{MiM}"|sexp-conv
causes an assert:
sexp-conv: /var/tmp/portage/dev-libs/nettle-3.2/work/nettle-3.2/tools/input.c:128:
sexp_input_start_coding: Assertion `!input-&gt;coding' failed.

Not sure how relevant these tools are, but usually abort/assert calls
are debugging tools for situations in a software that should never
happen on normal operations.

-- 
Hanno Böck
https://hboeck.de/

mail/jabber: hanno@hboeck.de
GPG: BBB51E42

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20160120191344</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-01-20 19:13:44-0400</timestampReceived><subject>Re: using gitlab CI for nettle</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; On Mon, Dec 21, 2015 at 11:25 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;&gt;&gt; +  script:
&gt;&gt;&gt; +  - git submodule update --init &amp;&amp; autoreconf -fvi &amp;&amp;
&gt;&gt; ./.bootstrap is nettle's advertised method to generate files needed
&gt;&gt; pre-configure. So I think it's better to use that than autoreconf.
&gt;&gt;
&gt;&gt; Why submodule, is nettle used as a submodule of gnutls, or is it some
&gt;&gt; magic for the continuous integration system?
&gt;
&gt; Seems like a copy paste thing from the gnutls file. I suggest that you
&gt; setup the configurations that you like and send me to test.

Sorry for the late reply. I think this could be quite useful.

Do you think this file looks ok? Is there any easy way to test before
checking it in?

-----8&lt;---------
Build and Check (x86-64):
  script:
  - git pull &amp;&amp; ./.bootstrap &amp;&amp;
    ./configure --disable-documentation &amp;&amp; make -j4 &amp;&amp; 
    make check -j4
  tags:
  - x86-64
  except:
  - tags
Build and Check (x86):
  script:
  - git pull &amp;&amp; ./.bootstrap &amp;&amp;
    ./configure --disable-documentation &amp;&amp; make -j4 &amp;&amp; 
    make check -j4
  tags:
  - x86
  except:
  - tags
-----8&lt;---------

I don't quite understand the details, e.g, environment in which the
script is run. If it's in a fresh git checkout, I guess git pull can be
omitted?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160121074436</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2016-01-21 07:44:36-0400</timestampReceived><subject>Re: using gitlab CI for nettle</subject><body>

I tested it and it works (you need to remove the git pull step as this
is already done by gitlab ci).

regards,
Nikos


On Wed, Jan 20, 2016 at 8:13 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt;
&gt;&gt; On Mon, Dec 21, 2015 at 11:25 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.s=
e&gt; wrote:
&gt;&gt;&gt;&gt; +  script:
&gt;&gt;&gt;&gt; +  - git submodule update --init &amp;&amp; autoreconf -fvi &amp;&amp;
&gt;&gt;&gt; ./.bootstrap is nettle's advertised method to generate files needed
&gt;&gt;&gt; pre-configure. So I think it's better to use that than autoreconf.
&gt;&gt;&gt;
&gt;&gt;&gt; Why submodule, is nettle used as a submodule of gnutls, or is it some
&gt;&gt;&gt; magic for the continuous integration system?
&gt;&gt;
&gt;&gt; Seems like a copy paste thing from the gnutls file. I suggest that you
&gt;&gt; setup the configurations that you like and send me to test.
&gt;
&gt; Sorry for the late reply. I think this could be quite useful.
&gt;
&gt; Do you think this file looks ok? Is there any easy way to test before
&gt; checking it in?
&gt;
&gt; -----8&lt;---------
&gt; Build and Check (x86-64):
&gt;   script:
&gt;   - git pull &amp;&amp; ./.bootstrap &amp;&amp;
&gt;     ./configure --disable-documentation &amp;&amp; make -j4 &amp;&amp;
&gt;     make check -j4
&gt;   tags:
&gt;   - x86-64
&gt;   except:
&gt;   - tags
&gt; Build and Check (x86):
&gt;   script:
&gt;   - git pull &amp;&amp; ./.bootstrap &amp;&amp;
&gt;     ./configure --disable-documentation &amp;&amp; make -j4 &amp;&amp;
&gt;     make check -j4
&gt;   tags:
&gt;   - x86
&gt;   except:
&gt;   - tags
&gt; -----8&lt;---------
&gt;
&gt; I don't quite understand the details, e.g, environment in which the
&gt; script is run. If it's in a fresh git checkout, I guess git pull can be
&gt; omitted?
&gt;
&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels M=C3=B6ller. PGP-encrypted email is preferred. Keyid C0B98E26.
&gt; Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160126184458</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-01-26 18:44:58-0400</timestampReceived><subject>Re: nettle-pbkdf2 dumps core when executed with an unknown option</subject><body>

dongsheng zhang &lt;dongsheng.zhang@oracle.com&gt; writes:

&gt; We have found that nettle-pbkdf2 dumps core when executed with an
&gt; unknown option.

Thanks for the bug report. There was a missing "case '?':" in the option
handling, and a similar bug also in nettle-hash. Fix checked in now, the
programs should display a usage message and exit. (Some of the other
programs just call exit (EXIT_FAILURE) in this situation, and some lack
usage messages, so it's not completely consistent).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160123201938</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-01-23 20:19:38-0400</timestampReceived><subject>Nettle-3.2 plans</subject><body>

Now I think the documentation of the new RSA tr functions is in
reasonable shape, and I'd like to get a release out real soon now.

I've put a release candidate at
https://www.lysator.liu.se/~nisse/archive/nettle-3.2rc1.tar.gz, and I've
updated the release planning at
https://www.lysator.liu.se/~nisse/nettle/plan.html.

I've spent the day doing tests on various emulated systems. The ARM and
PPC emulators have completed the tests with no issues, MIPS and M68K
emulators still working hard. Currently, I'm doing tests on gnu/linux
and freebsd (the sparc solaris systems I used to do some testing on have
been powered down).

If no last minute problems are discovered, I plan to make the release
earliest on Wednesday evening (January 27). 

All testing is highly appreciated. In particular, if Mac, Windows, or
some more obscure systems are important to you, now is the time to test.
As a reminder, non-GNU make programs are not really supported.

Review of the NEWS file and the new RSA material in the
manual would also be very nice.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20160124171059</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2016-01-24 17:10:59-0400</timestampReceived><subject>Re: Nettle-3.2 plans</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Date: Sat, 23 Jan 2016 21:19:38 +0100
&gt; 
&gt; I've put a release candidate at
&gt; https://www.lysator.liu.se/~nisse/archive/nettle-3.2rc1.tar.gz, and I've
&gt; updated the release planning at
&gt; https://www.lysator.liu.se/~nisse/nettle/plan.html.
&gt; 
&gt; I've spent the day doing tests on various emulated systems. The ARM and
&gt; PPC emulators have completed the tests with no issues, MIPS and M68K
&gt; emulators still working hard. Currently, I'm doing tests on gnu/linux
&gt; and freebsd (the sparc solaris systems I used to do some testing on have
&gt; been powered down).
&gt; 
&gt; If no last minute problems are discovered, I plan to make the release
&gt; earliest on Wednesday evening (January 27). 
&gt; 
&gt; All testing is highly appreciated. In particular, if Mac, Windows, or
&gt; some more obscure systems are important to you, now is the time to test.
&gt; As a reminder, non-GNU make programs are not really supported.

Builds OK with MinGW as 32-bit libraries on MS-Windows, and passes all
tests.

I see compilation warnings about getopt.h and getopt.c, shown below.
I ignored them, because they don't seem to indicate a real problem,
but it might be nice to avoid these and have a cleaner build.

Thanks.

Here are the warning messages (this is GCC 4.8.1, btw):

     gcc -static-libgcc -I.  -DHAVE_CONFIG_H -O2 -gdwarf-4 -g3 -ggdb3 \
-Wno-pointer-sign -Wall -W   -Wmissing-prototypes -Wmissing-declarations \
-Wstrict-prototypes -Wpointer-arith -Wbad-function-cast -Wnested-externs  -MT \
getopt.o -MD -MP -MF getopt.o.d -c getopt.c \  &amp;&amp; true
     In file included from getopt.c:98:0:
     getopt.h:169:1: warning: function declaration isn't a prototype \
[-Wstrict-prototypes]  extern int getopt ();
      ^
     getopt.c:146:1: warning: function declaration isn't a prototype \
[-Wstrict-prototypes]  extern char *getenv ();
      ^
     getopt.c: In function '_getopt_initialize':
     getopt.c:272:25: warning: unused parameter 'argc' [-Wunused-parameter]
      _getopt_initialize (int argc, char *const *argv, const char *optstring,
			      ^
     getopt.c:272:44: warning: unused parameter 'argv' [-Wunused-parameter]
      _getopt_initialize (int argc, char *const *argv, const char *optstring,
						 ^
     getopt.c: At top level:
     getopt.c:1188:1: warning: no previous prototype for 'getopt' \
[-Wmissing-prototypes]  getopt (int argc, char *const *argv, const char *optstring)
      ^


</body></email><email><emailId>20160125130532</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-01-25 13:05:32-0400</timestampReceived><subject>Re: Nettle-3.2 plans</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt; Builds OK with MinGW as 32-bit libraries on MS-Windows, and passes all
&gt; tests.

Thanks for testing.

&gt; I see compilation warnings about getopt.h and getopt.c, shown below.

I'd prefer not to modify these files myself (I could update them from
the canonical source if/when that is changed to use ANSI-C), current
version was copied from glibc-2.19, according to ChangeLog).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160121195305</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-01-21 19:53:05-0400</timestampReceived><subject>Re: using gitlab CI for nettle</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; I tested it and it works (you need to remove the git pull step as this
&gt; is already done by gitlab ci).

Ok, deleted the git pull commands, and checked in now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160215213808</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-02-15 21:38:08-0400</timestampReceived><subject>Re: abort / assert issues in sexp-conv</subject><body>

Hanno Böck &lt;hanno@hboeck.de&gt; writes:

&gt; I did a quick fuzzing test of the command line tools coming with nettle.
&gt;
&gt; echo "]"|sexp-conv
&gt; will cause an abort call and
&gt; echo "{MiM}"|sexp-conv
&gt; causes an assert:

Thanks for the bug report. I'm investigating.

&gt; usually abort/assert calls are debugging tools for situations in a
&gt; software that should never happen on normal operations.

That's my intention too. For invalid invalid input data, the program
should terminate with a more-or-less friendly error message, not crash.
Assertion failures are always bugs.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20160209133845</emailId><senderName>Hanno =?UTF-8?B?QsO2Y2s=?=</senderName><senderEmail>hanno@hboeck.de</senderEmail><timestampReceived>2016-02-09 13:38:45-0400</timestampReceived><subject>Re: backporting ecc patches</subject><body>

This is a MIME-formatted message.  If you see this text it means that your
E-mail software does not support MIME-formatted messages.


On Tue, 09 Feb 2016 14:31:22 +0100
Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; wrote:

&gt;   Do you plan a backport of the carry propagation fix in secp384 [0]
&gt; for nettle 2.7.1? My limited understanding of the 3.2 assembly file
&gt; wouldn't work out of the box in 2.7 due to the change from ecc_curve
&gt; to ecc_modulus.
&gt; 
&gt; The fix for the secp256r1 issue [1] looks quite trivial to backport if
&gt; p-&gt;m is replaced by ecc-&gt;p. Is my understanding correct?

Debian has backported the patches already it seems:
https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=813679

(Haven't checked them though)

-- 
Hanno Böck
https://hboeck.de/

mail/jabber: hanno@hboeck.de
GPG: BBB51E42

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20160209145204</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-02-09 14:52:04-0400</timestampReceived><subject>Re: backporting ecc patches</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; Do you plan a backport of the carry propagation fix in secp384 [0] for
&gt; nettle 2.7.1? 

I hadn't planned to do that. Do you think I should?

&gt; My limited understanding of the 3.2 assembly file
&gt; wouldn't work out of the box in 2.7 due to the change from ecc_curve to
&gt; ecc_modulus.

I don't think that should be a problem, since the first argument to
ecc_384_modp isn't used by the assembly implementation.

Hanno already pointed to the patches prepared by the debian maintainer.
https://bugs.debian.org/cgi-bin/bugreport.cgi?msg=15;bug=813679;filename=nettle_2.7.1-5%2Bdeb8u1.debian.tar.xz;att=1
 (not yet available at
https://sources.debian.net/src/nettle/2.7.1-5/debian/patches/, it
seems).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20160128203025</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2016-01-28 20:30:25-0400</timestampReceived><subject>ANNOUNCE: Nettle-3.2</subject><body>


I'm happy to announce a new release of GNU Nettle, a low-level
cryptographics library. This is mainly a bug fix release, with few new
features.

The Nettle home page can be found at
https://www.lysator.liu.se/~nisse/nettle/, and the manual at
https://www.lysator.liu.se/~nisse/nettle/nettle.html.

NEWS for the Nettle 3.2 release

	Bug fixes:

	* The SHA3 implementation is updated according to the FIPS 202
	  standard. It is not interoperable with earlier versions of
	  Nettle. Thanks to Nikos Mavrogiannopoulos. To easily
	  differentiate at compile time, sha3.h defines the constant
	  NETTLE_SHA3_FIPS202.

	* Fix corner-case carry propagation bugs affecting elliptic
	  curve operations on the curves secp_256r1 and secp_384r1 on
	  certain platforms, including x86_64. Reported by Hanno Böck.

	New features:

	* New functions for RSA private key operations, identified by
	  the "_tr" suffix, with better resistance to side channel
	  attacks and to hardware or software failures which could
	  break the CRT optimization. See the Nettle manual for
	  details. Initial patch by Nikos Mavrogiannopoulos.

	* New functions nettle_version_major, nettle_version_minor, as
	  a run-time variant of the compile-time constants
	  NETTLE_VERSION_MAJOR and NETTLE_VERSION_MINOR.

	Optimizations:

	* New ARM Neon implementation of the chacha stream cipher.

	Miscellaneous:

	* ABI detection on mips, with improved default libdir
	  location. Contributed by Klaus Ziegler.

	* Fixes for ARM assembly syntax, to work better with the clang
	  assembler. Thanks to Jukka Ukkonen.

	* Disabled use of ifunc relocations for fat builds, to fix
	  problems most easily triggered by using dlopen RTLD_NOW.

	The shared library names are libnettle.so.6.2 and
	libhogweed.so.4.2, with sonames still libnettle.so.6 and
	libhogweed.so.4. It is intended to be fully binary compatible
	with nettle-3.1.

  https://ftp.gnu.org/gnu/nettle/nettle-3.2.tar.gz
  ftp://ftp.gnu.org/gnu/nettle/nettle-3.2.tar.gz
  https://www.lysator.liu.se/~nisse/archive/nettle-3.2.tar.gz

Happy hacking,
/Niels Möller

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


["signature.asc" (application/pgp-signature)]

</body></email></emails>