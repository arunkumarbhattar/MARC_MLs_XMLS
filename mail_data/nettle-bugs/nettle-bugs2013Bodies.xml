<?xml version="1.0" encoding="utf-8"?>
<emails><email><emailId>20130102204549</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-01-02 20:45:49-0400</timestampReceived><subject>Getting closer to nettle-2.6</subject><body>

I think I'd like to make a nettle-2.6 release fairly soon. Recent
changes:

1. I disabled the x86_64 assembly for sha3_permute. It gave a very
   modest speedup on the Intel processor I benchmarked it on, and a
   sever slowdown on the AMD processor I also benchmarked it on. The
   latter machine seemed to execute the loop at only one instruction per
   cycle, rather than three as it should; my best guess is that it's the
   moves of data between regular registers and xmm registers that
   somehow stall.

   Maybe it could be rewritten to use xmm registers exclusively, but
   then register allocation gets *very* tight, so one might need to keep
   a few words of the state on the stack instead. But I don't think I'll
   try that soon; the current C implementation is reasonably efficient,
   with performance of sha256 and sha3-256 in the same ballbark (but
   both slower than sha512).
   
2. I think I fixed the bugs in some subdirectory make targets which
   broke "make install" without a preceding "make all".

Ah, and a technical detail. There are no new features added to to
libhogweed, but I still intend to increment the minor number of that
shared library in the release. Is that right, or should I keep the same
hogweed minor number as in nettle-2.5 (i.e., libhogweed.so.4.4)?

I've updated the NEWS file (current version of the 2.6 entries appended
below, for convenience). Are you aware of any missing pieces, either in
the code, in NEWS, or in other documentation?

Regards,
/Niels

NEWS for the 2.6 release

	Bug fixes:

	* Fixed a bug in ctr_crypt. For zero length (which should be a
	  NOP), it sometimes incremented the counter. Reported by Tim
	  Kosse.

	* Fixed a small memory leak in nettle_realloc and
          nettle_xrealloc.

	New features:

	* Support for PKCS #5 PBKDF2. Contributed by Simon Josefsson.
          Specification in RFC 2898 and test vectors in RFC 6070.

	* Support for GOST R 34.11-94 hash algorithm. Ported from librhash 
	  by Nikos Mavrogiannopoulos. Written by Aleksey Kravchenko.
	  More information in RFC4357. Test vectors taken from the GOST
	  hash wikipedia page.

	* Support for SHA3.
	  
	Miscellaneous:

	* The include file &lt;nettle/sha.h&gt; has been split into
          &lt;nettle/sha1.h&gt; and &lt;nettle/sha2.h&gt;. For now, sha.h is kept
          for backwards compatibility and it simply includes both
          files, but applications are encouraged to use the new names.
          The new SHA3 functions are declared in &lt;nettle/sha3.h&gt;.

	* Testsuite can be run under valgrind, using

	  make check EMULATOR='$(VALGRIND)'

	  For this to work, test programs and other executables now
	  deallocate storage.
	  
	* New configure options --disable-documentation and
          --disable-static. Contributed by Sam Thursfield and Alon
	  Bar-Lev, respectively.
	  
	* The section on hash functions in the manual is split into
          separate nodes for recommended hash functions and legacy
          hash functions.

	* Various smaller improvements, most of them portability
          fixes. Credits go to David Woodhouse, Tim Rühsen, Martin
          Storsjö, Nikos Mavrogiannopoulos, Fredrik Thulin and Dennis
          Clarke.

	Finally, a note on the naming of the various "SHA" hash
	functions. Naming is a bit inconsistent; we have, e.g.,

	  SHA1: sha1_digest
	  SHA2: sha256_digest   (not sha2_256_digest)
	  SHA3: sha3_256_digest

	Renaming the SHA2 functions to make Nettle's naming more
	consistent has been considered, but the current naming follows
	common usage. Most documents (including the specification for
	SHA2) refer to 256-bit SHA2 as "SHA-256" or "SHA256" rather
	than "SHA2-256".

	The libraries are intended to be binary compatible with
	nettle-2.2 and later. The shared library names are
	libnettle.so.4.5 and libhogweed.so.2.3, with sonames still
	libnettle.so.4 and libhogweed.so.2

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130213153401</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-02-13 15:34:01-0400</timestampReceived><subject>ECC benchmarks</subject><body>

It's some time since I posted benchmark figures. The speed dropped a bit
when I started to use the slow side-channel silent modinv, but I think
it's reasonable. For comparison, I just added openssl's ecdsa functions
to my benchmark program. These are the current figures for x86_64:

size       modp       redc       modq    add_jja     dup_jj (us)
 192     0.0248     0.0265     0.0450     0.6319     0.5151
 224     0.0519     0.0467     0.0680     0.9136     0.7149
 256     0.0834     0.0409     0.0802     0.8222     0.6617
 384     0.0927     0.0000     0.0607     1.6663     1.2559
 521     0.0347     0.0514     0.1289     1.5239     1.1670

           name size  sign / ms verify / ms
            rsa 1024     6.3180   102.7909
            rsa 2048     0.9562    29.2339
            dsa 1024    11.1780     5.7492
          ecdsa  192    14.9983     4.5612
          ecdsa  224     8.0952     2.6880
          ecdsa  256     7.7640     2.5785
          ecdsa  384     2.9131     0.9155
          ecdsa  521     1.7974     0.6594
ecdsa (openssl)  224     3.4939     3.0582
ecdsa (openssl)  384     1.4637     1.2603
ecdsa (openssl)  521     0.6962     0.5981

If we extract common functions for openssl (it seemed to lack secp192r1
and secp256r1), we get

          ecdsa  224     8.0952     2.6880
ecdsa (openssl)  224     3.4939     3.0582

          ecdsa  384     2.9131     0.9155
ecdsa (openssl)  384     1.4637     1.2603

          ecdsa  521     1.7974     0.6594
ecdsa (openssl)  521     0.6962     0.5981

So it looks like for signing, the current code beats openssl by a factor
of two. While for verify, we're a little behind. And my code tries hard
to be side-channel silent (even for verify, where it doesn't matter).
I'm not sure if openssl tries to be side-channel silent.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130312095115</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-12 09:51:15-0400</timestampReceived><subject>ARM assembly</subject><body>

I've new written some ARM assembly files for AES, SHA1 and SHA256. I
haven't tried any clever scheduling (it seems quite unpredictable), so I
think I win over the C code is mainly because I fit the important values
in registers. I have benchmarked on a cortex-a9 system, with nice but
not earth-shattering improvements over the C implementation.

In my benchmarks, AES decrypt is significantly slower than AES decrypt,
for no reason that I understand, and I have tried some other variants of
instruction scheduling.

I have one question on the ABI, if there's anyone on the list with more
ARM experience: In the ABI spec, register r9 is reserved for use for
things such as thread local storage. I'm almost sure that a leaf
function can use r9 like any other callee-save register, but I'd like to
have that confirmed before I make use of it. Potential problem case is
if the function is interrupted by a signal and signal handler somehow
depends on having a valid value in r9, or if context switching somehow
assumes that r9 is never modified.

Any suggestion for what to try optimizing next? I imagine all algorithms
that make use of 64-bit data or are designed for simd operations could
be sped up a bit using the neon simd instructions (which I so far
haven't made any use of). This includes sha512, sha3, serpent, salsa,
maybe camellia.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130402084544</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-02 08:45:44-0400</timestampReceived><subject>Release plans</subject><body>

I have updated the release plans, at
http://www.lysator.liu.se/~nisse/nettle/plan.html. I aim to get a
release out within a month or two.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130402215801</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2013-04-02 21:58:01-0400</timestampReceived><subject>Re: Release plans</subject><body>

tis 2013-04-02 klockan 10:45 +0200 skrev Niels Möller:
&gt; I have updated the release plans, at
&gt; http://www.lysator.liu.se/~nisse/nettle/plan.html. I aim to get a
&gt; release out within a month or two.

Re the 3.0 plans, it seems that making a 3.0 release that implement the
first two items on the list (unsigned-&gt;size_t, memxor namespace) would
be possible to achieve relatively soon with modest investment in work.
I think it would be good to get that part out sooner rather than later.

Considering the significant time it takes for people to bump library
versions with ABI incompatibilities, I suggest to consider making a 3.0
release with only those two changes soon after 2.7, and then postpone
the rest of the current 3.0 items for a future 3.1 or similar.  That
way, we'll get a API/ABI clean version of the library out soon that
people can start to migrate to.

Just an idea.  I always feel that these "distant future" release plans
raraly materialize, you just keep on adding nice to do features on to
the "distant future" release without ever getting closer to implementing
them.  Eventually the list becomes so long it is practically impossible
to implement all of them for a single major release.

Just an idea, and keep up the good work.

/Simon


</body></email><email><emailId>20130408202541</emailId><senderName>Perry Smith</senderName><senderEmail>pedzsan@gmail.com</senderEmail><timestampReceived>2013-04-08 20:25:41-0400</timestampReceived><subject>Building on AIX 6.1</subject><body>

Hi Guys,

I got libnettle to build on AIX 6.1 but I had to edit the Makefile.in
and the configure.ac file.

Editing the configure.ac is fine.  But I had to change the make rules
so the shared library depended upon nettle_OBJS instead of
nettle_PURE_OBJS.  I *think* (but I'm not sure) that the .po suffix
confuses the linker.  It appears as if it was just ignoring all the
.po files.

I'm happy to post my diffs but they may not help much.

I've never seen "pure" objects before.  Is this really a useful
concept?

Thank you,
Perry


</body></email><email><emailId>20130409193513</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-09 19:35:13-0400</timestampReceived><subject>Re: Building on AIX 6.1</subject><body>

Perry Smith &lt;pedzsan@gmail.com&gt; writes:

&gt; Editing the configure.ac is fine.  But I had to change the make rules
&gt; so the shared library depended upon nettle_OBJS instead of
&gt; nettle_PURE_OBJS.  I *think* (but I'm not sure) that the .po suffix
&gt; confuses the linker.  It appears as if it was just ignoring all the
&gt; .po files.

Maybe that suffix was poorly choosen.

&gt; I've never seen "pure" objects before.  Is this really a useful
&gt; concept?

The idea is that objects that go into a shared library should be
compiled as position independent code (so that the code pages really can
be shared, with no relocations depending on the address at which they
are mapped), while objects that go into a static library usually should
not (except for the --enable-pic / --disable-pic options, see below). So
foo.c is compiled to foo.o and to foo.po, with different compiler flags.

To make things work on AIX, I guess we need to do one or more of

* Replace the .po suffix by .p.o or _p.o, which should make it more
  obvious to various tools that they really are object files.

* Patch configure with whatever is needed to actually compile position
  independent code on AIX (I hope the current defaults should work if
  you build with gcc, but most likely they won't work at all with the
  system compiler).

* Add some configure option (or use --disable-pic) to not try to compile
  anything as position independent code.

About the --enable-pic / --disable-pic configure options, I'm not sure
if they currently work as intended. --enable-pic was introduced a long
time ago to make also the objects for the static library compiled as
position independent code, which was useful if you built some plugin.so
intended to be loaded dynamically into some application, and that
plugin.so was linked statically with nettle. And it seems that
currently, --enable-pic is the default.

So I'm not sure, is it still useful to use non-pic code for the static
library, or can we drop support for that, always using
position-independent code whenever the configure script can figure out
how to do it?

Also, I think the current use of CCPIC_MAYBE is a bit ugly. In the
(currently default) case that the static libnettle.a library uses
position independent code, it would be better to simply have it depend
on the .po files, and not build the "regular" .o files at all.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130409204155</emailId><senderName>Perry Smith</senderName><senderEmail>pedzsan@gmail.com</senderEmail><timestampReceived>2013-04-09 20:41:55-0400</timestampReceived><subject>Re: Building on AIX 6.1</subject><body>


On Apr 9, 2013, at 2:35 PM, Niels Möller wrote:

&gt; Perry Smith &lt;pedzsan@gmail.com&gt; writes:
&gt; 
&gt;&gt; Editing the configure.ac is fine.  But I had to change the make rules
&gt;&gt; so the shared library depended upon nettle_OBJS instead of
&gt;&gt; nettle_PURE_OBJS.  I *think* (but I'm not sure) that the .po suffix
&gt;&gt; confuses the linker.  It appears as if it was just ignoring all the
&gt;&gt; .po files.
&gt; 
&gt; Maybe that suffix was poorly choosen.
&gt; 
&gt;&gt; I've never seen "pure" objects before.  Is this really a useful
&gt;&gt; concept?
&gt; 
&gt; The idea is that objects that go into a shared library should be
&gt; compiled as position independent code (so that the code pages really can
&gt; be shared, with no relocations depending on the address at which they
&gt; are mapped), while objects that go into a static library usually should
&gt; not (except for the --enable-pic / --disable-pic options, see below). So
&gt; foo.c is compiled to foo.o and to foo.po, with different compiler flags.
&gt; 
&gt; To make things work on AIX, I guess we need to do one or more of
&gt; 
&gt; * Replace the .po suffix by .p.o or _p.o, which should make it more
&gt;  obvious to various tools that they really are object files.
&gt; 
&gt; * Patch configure with whatever is needed to actually compile position
&gt;  independent code on AIX (I hope the current defaults should work if
&gt;  you build with gcc, but most likely they won't work at all with the
&gt;  system compiler).
&gt; 
&gt; * Add some configure option (or use --disable-pic) to not try to compile
&gt;  anything as position independent code.
&gt; 
&gt; About the --enable-pic / --disable-pic configure options, I'm not sure
&gt; if they currently work as intended. --enable-pic was introduced a long
&gt; time ago to make also the objects for the static library compiled as
&gt; position independent code, which was useful if you built some plugin.so
&gt; intended to be loaded dynamically into some application, and that
&gt; plugin.so was linked statically with nettle. And it seems that
&gt; currently, --enable-pic is the default.
&gt; 
&gt; So I'm not sure, is it still useful to use non-pic code for the static
&gt; library, or can we drop support for that, always using
&gt; position-independent code whenever the configure script can figure out
&gt; how to do it?
&gt; 
&gt; Also, I think the current use of CCPIC_MAYBE is a bit ugly. In the
&gt; (currently default) case that the static libnettle.a library uses
&gt; position independent code, it would be better to simply have it depend
&gt; on the .po files, and not build the "regular" .o files at all.

It would be interesting to see what platforms need the non-pic mode.
I've not heard of anything other than position independent code for
a fairly long time now.

The default output of IBM's xlc compiler as well as GNU's gcc compiler
is to produce position independent code for AIX.  I believe that is true
for any Power PC platform.  And I thought that that was true for almost
any modern chip (Intel, etc).

I fear that I don't know enough about the history of the code to help
much.  The only very general comment I have is the other open source
projects that I compile (for Mac and AIX) almost all create a shared
library and they do it with what appears to be normal calls to GCC.

Hope this helps...
Perry


</body></email><email><emailId>20130326144740</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-26 14:47:40-0400</timestampReceived><subject>umac</subject><body>

I have now read the UMAC spec (RFC 4418) a bit more carefully. I haven't
yet read Niko's code (or any other code, for that matter). Some
thoughts:

o  I don't like the way endian conversion is done in the spec. I'd
   prefer to think about the various functions as operating on arrays of
   32-bit words, and implementation should use integer types of the
   right size to get correct alignment etc.

o  The "NH" function looks like a candidate for for assembly
   implementation. I don't know if there's anything else in the
   algorithm which really is performance critical? (And here we get a
   contradiction to point (1), it may be best for performance to have
   the NH function get the unaligned byte array as input, do be able to
   use assembly tricks when reading it into integers. Anyway, we should
   really avoid byte arrays in the internal interfaces between
   L1/L2/L3). 

o  *Maybe* optimization of the L2 and L3 hashes will be important.
   Profiling is needed, I guess, and they should be optimized *after*
   L1/NH.

o  Since I have been work with side-channel silence recently, it seems
   natural to try to make the POLY function silent, On the other hand,
   I'm not sure what the threats are. If the MAC is applied to a secret
   message, we may leak some information about the message, I guess?

o  I think we ought to handle large messages correctly, which means we
   need the POLY function also over the 128-bit prime. Performance is
   not terribly important, at least not initially.

o  I'm not sure exactly how the building blocks fit together, but we
   should strive for pipelining. When we have the first message block
   M_1, apply L1 to that block, then apply L2 and L3 to the output as
   soon as possible. And for the larger tag lengths, also try to make
   that looping inside the loop processing the sequence of message
   blocks, so we can discard M_1 before starting to work on the next
   block M_2.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130327100054</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-03-27 10:00:54-0400</timestampReceived><subject>Re: umac</subject><body>

On Tue, Mar 26, 2013 at 3:47 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; I have now read the UMAC spec (RFC 4418) a bit more carefully. I haven't
&gt; yet read Niko's code (or any other code, for that matter). Some

To put the discussion on some context for the others, I have sent a
patch that adds support for the UMAC algorithm. The patch did not made
it to the list due to size and was forwarded directly to Niels.

btw. It would be nice if the list would notify the poster when
messages are being held. In that case I only figured out it was held
some days later by checking the archives. Also please use Nikos for my
name. The Niko sounds very Italian (and I am not one :).

&gt; o  Since I have been work with side-channel silence recently, it seems
&gt;    natural to try to make the POLY function silent, On the other hand,
&gt;    I'm not sure what the threats are. If the MAC is applied to a secret
&gt;    message, we may leak some information about the message, I guess?

Do you think the current function could provide information on the
plaintext? From a quick look it is not obvious to me, but I haven't
checked thoroughly.

&gt; o  I think we ought to handle large messages correctly, which means we
&gt;    need the POLY function also over the 128-bit prime. Performance is
&gt;    not terribly important, at least not initially.

Note that the current limit on the code is 16MB messages per tag, not
per key, so it is oversufficient for all practical uses of a MAC
(which is not the same as a hash). It would be nice not to have the
limit, but it would be nicer if anyone actually cared about it :) I
haven't checked but if adding support for larger messages per tag
would reduce performance, but if this is the case I think it would be
pretty counter-productive.

regards,
Nikos

</body></email><email><emailId>20130327122902</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-27 12:29:02-0400</timestampReceived><subject>Re: umac</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; btw. It would be nice if the list would notify the poster when
&gt; messages are being held.

It's intended to do that, but I'm not very good at mailman
configuration, so I guess I have messed that up somehow.

&gt; Also please use Nikos for my name.

Noted, sorry about that.

&gt; Do you think the current function could provide information on the
&gt; plaintext? From a quick look it is not obvious to me, but I haven't
&gt; checked thoroughly.

The poly_hash function clearly has data-dependent timing. If it is
useful for the attacker, I don't know.

&gt; Note that the current limit on the code is 16MB messages per tag, not
&gt; per key, so it is oversufficient for all practical uses of a MAC
&gt; (which is not the same as a hash).

I consider handling of large files to be an important application of any
MAC. When encrypting a large file (typical cases: session key derived
from a passphrase, or random session key encrypted with RSA), the
session key should always include a MAC key for authenticating the data.
And streaming operation is important, and then you don't even know in
advance if the file is going to be small or large.

&gt; I haven't checked but if adding support for larger messages per tag
&gt; would reduce performance, but if this is the case I think it would be
&gt; pretty counter-productive.

It should make no difference for short messages. The "layer-2" hashing
for large messages will be some four times slower than for short
messages. Not sure what the overall slowdown would be; the layer-2 work
may still be a small fraction of the time spent in the layer-1 hashing.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130327145256</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-03-27 14:52:56-0400</timestampReceived><subject>Re: umac</subject><body>

On Wed, Mar 27, 2013 at 1:29 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:

&gt;&gt; Do you think the current function could provide information on the
&gt;&gt; plaintext? From a quick look it is not obvious to me, but I haven't
&gt;&gt; checked thoroughly.
&gt; The poly_hash function clearly has data-dependent timing. If it is
&gt; useful for the attacker, I don't know.

I see what you mean; i was checking only the poly64 part. Indeed there
is an additional evaluation of the poly64 when m &gt;= some size.
In the description it is like that:
       if (m &gt;= maxwordrange) then
         y = (k * y + marker) mod p
         y = (k * y + (m - offset)) mod p
       else
         y = (k * y + m) mod p
       end if

which doesn't look to provide much, but the time spent it seems it
could be used to distinguish text consisting of 0xfffffffff, to text
that is other than that. I don't know how practical is that because
the overall instructions needed for an evaluation of poly64() are very
few, but still looks like an issue. It could be fixed by adding an
additional evaluation of poly64 (i.e., do an additional multiplication
on the else case), but it looks it is going to affect negatively the
performance of all cases except 0xffffffffff. I don't know if the
expression
         y = (k * y + marker) mod p
         y = (k * y + (m - offset)) mod p

can be optimized to a single evaluation by using a separate poly64
function for it (that would be fine if the difference is just one or
two multiplications more than the original poly64).

&gt;&gt; Note that the current limit on the code is 16MB messages per tag, not
&gt;&gt; per key, so it is oversufficient for all practical uses of a MAC
&gt;&gt; (which is not the same as a hash).
&gt; I consider handling of large files to be an important application of any
&gt; MAC. When encrypting a large file (typical cases: session key derived
&gt; from a passphrase, or random session key encrypted with RSA), the
&gt; session key should always include a MAC key for authenticating the data.

Encryption of big data is seldom happening on a single run. If there
is a bit flip on the hard disk all the data are gone (decryption and
mac will fail for all) and so is any possibility of recovery. I'd
expect data to be encrypted in chunks (i think gpg and the other hard
disk encryption tools work like that). In any case if you consider
that limitation, a stopper, I could check it further.

regards,
Nikos

</body></email><email><emailId>20130327175626</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-27 17:56:26-0400</timestampReceived><subject>Re: umac</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; In any case if you consider that limitation, a stopper, I could check
&gt; it further.

To get to understand the algorithm better, I'm writing a toy
implementation. I'll let you know when I have a poly128-routine
which passes the tests.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130327175917</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-03-27 17:59:17-0400</timestampReceived><subject>Re: umac</subject><body>

On 03/27/2013 06:56 PM, Niels Möller wrote:

&gt;&gt; In any case if you consider that limitation, a stopper, I could check
&gt;&gt; it further.
&gt; To get to understand the algorithm better, I'm writing a toy
&gt; implementation. I'll let you know when I have a poly128-routine
&gt; which passes the tests.


Note also that I realized that in the implementation I submitted the
nonce is restricted to 64-bits, while up to 128-bits may also be used.

regards,
Nikos


</body></email><email><emailId>20130328130636</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-28 13:06:36-0400</timestampReceived><subject>Re: umac</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; To get to understand the algorithm better, I'm writing a toy
&gt; implementation. I'll let you know when I have a poly128-routine
&gt; which passes the tests.

Done now. Available at
http://www.lysator.liu.se/~nisse/misc/umac-0.1.tar.gz. The code is not
seriously optimized, and it supports only 32-bit tags. The functions in
poly128.c might be useful.

I'm a bit worried about testing; the test vectors in RFC4418 seem
inadequate to get confidence in an implementation. I include the README
file (an extended version of the notes I mailed earlier) below.

Regards,
/Niels

This is a "toy implementation" of UMAC, which I wrote to understand
the algorithm, and try to figure out the proper interfaces for
implementing it in Nettle. The current code only does the smallest tag
size, 32 bits.

Some lessons learned:

* I was initially confused about endianness in the spec. It turns out
  the data being hashed is read into 32-bit integers using
  little-endian byteorder. *Everything* else uses big-endian
  conventions.

* Testing is poor. There are a lot of corner cases in the algorithm,
  primarily in the layer two hashing. First, there are a bunch of
  conditions depending on the message length (no POLY, only POLY64,
  combination of POLY64 and POLY128), and then there's the "marker"
  words in the POLY algorithm which are very unlikely for random input
  and hence a bit tricky to get properly tested.

  So to get confidence in any UMAC implementation, it would be highly
  desirable with a set of known test vectors which provide for
  complete code coverage, but I haven't found any.

* The nh function is expected to be the main work-horse (but I haven't
  profiled anything). So it's a candidate for assembly implementation.
  To avoid having to read (and deal with unaligned data and
  endianness) more than once, it would make sense with an nh function
  which gets the tag length as an argument, and does all needed
  processing of a single block. An alternative is to copy the input
  block into an aligned uint32_t array before calling nh, but I think
  it's better not to make any extra copy of the input, and just
  process it on the fly as it is read.

* Optimization of the layer two hash, in particular the poly64 and
  poly128 operations, may be important. Profiling will tell.
  
* Since I have been working with side-channel silence recently, it
  seems natural to try to make the POLY function silent. On the other
  hand, I'm not sure what the threats are. If the MAC is applied to a
  secret message, we may leak some information about the message, I
  guess? Is it a problem worth bothering about?

* One can expect the POLY128 operations, used for large messages, to
  be roughly four times slower than POLY64 (quadratic
  multiplication). Benchmarking is needed to see if it makes a
  noticeable difference, layer two hashing may still be a small
  fraction of the work done in layer one.

About the proper interface (primarily for Nettle).

* It's natural to provide the nonce at the time the digest (or "tag")
  is extracted, since (i) that's when it is needed, and (ii) for other
  macs, that's the only function which is called precisely once per
  message. (Current code doesn't do that).

* It's desirable to keep the underlying AES cipher separate from the
  rest of the UMAC code, and provide it only for key setup. But that
  doesn't work, since nonce handling also needs the block cipher. I
  think it would be possible to still use some abstract KDF to provide
  the key, but that seems a bit pointless if we hard-code use of AES
  anyway.

* I'm leaning towards having separate types and functions for
  UMAC-AES-32, UMAC-AES-64, UMAC-AES-96 and UMAC-AES-128, which would
  all use common primitives for layer 1, 2 and 3 hashing. The
  primitives should be independent of AES. It would then be easy to
  define UMAC with other ciphers and KDFs if ever needed (and as far
  as I understand, a *block* cipher shouldn't be strictly necessary,
  since it's essentially used in CTR mode anyway, e.g., UMAC-SALSA20
  should be possible).

  Or we can have a common UMAC-AES type, with the digest size as an
  argument to key setup. For smaller tag sizes, we then allocate space
  for more subkeys than needed. This is a drawback shared with, e.g.,
  the current AES code in Nettle. There's also some additional non-key
  state for larger tag sizes (running variables for the polynomials),
  but that's a small issue.

* Speaking of storage micro-optimizations, it might make sense to have
  poly64 and poly128 share storage, or to combine them into an "layer
  two hash" abstraction.

* To improve performance for small messages, it would make some sense
  to compute the subkeys lazily, and not compute keys which aren't
  going to be used.

* In some ways it would be nice and proper to separate the subkeys,
  which are constant while messages are being processed, from the
  per-message state (applies also to the HMAC code). One potential use
  would be to have a single key and several threads using it to
  process messages. Also not sure if that is worth bothering about. If
  we go that way, it more or less rules out lazy computation of
  subkeys.

  
LocalWords:  UMAC endianness endian byteorder nh uint AES KDF KDFs
LocalWords:  subkeys HMAC


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130328154510</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-03-28 15:45:10-0400</timestampReceived><subject>Re: umac</subject><body>

On Thu, Mar 28, 2013 at 2:06 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; I'm a bit worried about testing; the test vectors in RFC4418 seem
&gt; inadequate to get confidence in an implementation. I include the README
&gt; file (an extended version of the notes I mailed earlier) below.

Unfortunately yes. Moreover vectors of the UMAC-128 tags are not even
mentioned. It may be better to generate any desired vectors using
Krovetz' implementation.

&gt; * Since I have been working with side-channel silence recently, it
&gt;   seems natural to try to make the POLY function silent. On the other
&gt;   hand, I'm not sure what the threats are. If the MAC is applied to a
&gt;   secret message, we may leak some information about the message, I
&gt;   guess? Is it a problem worth bothering about?

Well, it seems that hiding information about the data being protected
isn't one of the main properties of a MAC algorithm. MAC algorithms
struggle to protect against key recovery, insertion attacks and
modification attacks. Your remark about the possibility of extracting
information about the plaintext is indeed interesting and one more
argument for applying the MAC after encryption.

&gt; * It's natural to provide the nonce at the time the digest (or "tag")
&gt;   is extracted, since (i) that's when it is needed, and (ii) for other
&gt;   macs, that's the only function which is called precisely once per
&gt;   message. (Current code doesn't do that).

I think a generic interface for macs should be followed. The fact that
this algorithm requires the nonce during digest extraction seem pretty
UMAC-specific. Having a set_nonce function to be called after init
seem reasonable.

&gt; * It's desirable to keep the underlying AES cipher separate from the
&gt;   rest of the UMAC code, and provide it only for key setup.

UMAC is only specified with AES, and RFC4418 when it mentions UMAC it
means UMAC-AES. I'd keep the UMAC-AES/UMAC a single algorithm and not
separate the AES part. The fact that other ciphers could be used isn't
very interesting since these options are neither standardized nor
studied. Once such an other option is available sometime in the future
it can be another algorithm e.g. umac-des.

&gt; * I'm leaning towards having separate types and functions for
&gt;   UMAC-AES-32, UMAC-AES-64, UMAC-AES-96 and UMAC-AES-128, which would
&gt;   all use common primitives for layer 1, 2 and 3 hashing. The
&gt;   primitives should be independent of AES. It would then be easy to
&gt;   define UMAC with other ciphers and KDFs if ever needed (and as far
&gt;   as I understand, a *block* cipher shouldn't be strictly necessary,
&gt;   since it's essentially used in CTR mode anyway, e.g., UMAC-SALSA20
&gt;   should be possible).

Making things so general would actually complicate the interface
without any benefit for the time being. Yes it would be future-proof,
but there is no guarantee that another variant of UMAC will be defined
in the future - it may be VMAC - nor something like that is planned.

&gt; * In some ways it would be nice and proper to separate the subkeys,
&gt;   which are constant while messages are being processed, from the
&gt;   per-message state (applies also to the HMAC code). One potential use
&gt;   would be to have a single key and several threads using it to
&gt;   process messages.

Does this property exist in any other nettle algorithms? If not I'd
say don't bother. My impression with the contexts in nettle is that a
single context is used in a single thread.

regards,
Nikos

</body></email><email><emailId>20130328172445</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-28 17:24:45-0400</timestampReceived><subject>Re: umac</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; On Thu, Mar 28, 2013 at 2:06 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt;&gt; I'm a bit worried about testing; the test vectors in RFC4418 seem
&gt;&gt; inadequate to get confidence in an implementation. I include the README
&gt;&gt; file (an extended version of the notes I mailed earlier) below.
&gt;
&gt; Unfortunately yes. Moreover vectors of the UMAC-128 tags are not even
&gt; mentioned. It may be better to generate any desired vectors using
&gt; Krovetz' implementation.

I mailed him and asked, and he also suggested using rthe python (or
ruby) implementation. Will be some work though.

&gt; Well, it seems that hiding information about the data being protected
&gt; isn't one of the main properties of a MAC algorithm.

Right, maybe we don't need to care about that.

&gt;&gt; * It's natural to provide the nonce at the time the digest (or "tag")
&gt;&gt;   is extracted, since (i) that's when it is needed, and (ii) for other
&gt;&gt;   macs, that's the only function which is called precisely once per
&gt;&gt;   message. (Current code doesn't do that).
&gt;
&gt; I think a generic interface for macs should be followed. The fact that
&gt; this algorithm requires the nonce during digest extraction seem pretty
&gt; UMAC-specific. Having a set_nonce function to be called after init
&gt; seem reasonable.

It's something like that in the gcm code (but called set_iv). So we
should aim for some consistency.

Maybe one could also have a default autoincrementing nonce?

&gt;&gt; * It's desirable to keep the underlying AES cipher separate from the
&gt;&gt;   rest of the UMAC code, and provide it only for key setup.
&gt;
&gt; UMAC is only specified with AES, and RFC4418 when it mentions UMAC it
&gt; means UMAC-AES.

[...]

&gt; Making things so general would actually complicate the interface
&gt; without any benefit for the time being.

I agree that it's not worth to make the user-level interface, nor the
implementation, more complex to achieve separation, but some level of
separation may actually make implementation clearer.

&gt;&gt; * In some ways it would be nice and proper to separate the subkeys,
&gt;&gt;   which are constant while messages are being processed, from the
&gt;&gt;   per-message state (applies also to the HMAC code). One potential use
&gt;&gt;   would be to have a single key and several threads using it to
&gt;&gt;   process messages.
&gt;
&gt; Does this property exist in any other nettle algorithms?

It's (trivially) true for the block ciphers, and the gcm code separates
key state (struct gcm_key) from message state (struct gcm_ctx). The hmac
code does not, and I'd like to change that *if* I can find some reasonable
way to do it.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130402063519</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-02 06:35:19-0400</timestampReceived><subject>Re: umac</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; On 03/28/2013 06:24 PM, Niels Möller wrote:
&gt;
&gt;
&gt;&gt; Maybe one could also have a default autoincrementing nonce?
&gt;
&gt; If you do that please don't make it the default. There are several cases
&gt; in DTLS where the nonce isn't simply incrementing (e.g. when receiving
&gt; packets out-of-order).

I was thinking of _init setting it to zero, and have _digest do post
increment. So then you could chose between

  _init

  per message:
  _set_nonce
  _update (0 or more times)
  _digest

to get a nonce of your choice for each message, or

  _init

  per message:
  _update (0 or more times)
  _digest

to get an incrementing nonce, starting from zero, or

  _init
  _set_nonce

  per message:
  _update (0 or more times)
  _digest

to get an incrementing nonce, with a starting value of your choice.

Do you think this makes sense? There's a slight disadvantage that in the
case that you call set_nonce for each message, the automatic
inititializing and updating of the nonce is some useless work. I'm not
sure what the typical usecases are.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130402201618</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-04-02 20:16:18-0400</timestampReceived><subject>Re: umac</subject><body>

On 04/02/2013 08:35 AM, Niels Möller wrote:


&gt;&gt;&gt; Maybe one could also have a default autoincrementing nonce?
&gt;&gt;
&gt;&gt; If you do that please don't make it the default. There are several cases
&gt;&gt; in DTLS where the nonce isn't simply incrementing (e.g. when receiving
&gt;&gt; packets out-of-order).
&gt; 
&gt; I was thinking of _init setting it to zero, and have _digest do post
&gt; increment. So then you could chose between


Looks ok but I don't like that cycles are wasted in the case one doesn't
use it. They are not much but I wouldn't expect that from a low-level
library.

I think having an other interface to increment any kind of nonce/iv may
be more interesting.

regards,
Nikos

</body></email><email><emailId>20130404150536</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-04-04 15:05:36-0400</timestampReceived><subject>Re: umac</subject><body>

On Tue, Apr 2, 2013 at 10:16 PM, Nikos Mavrogiannopoulos &lt;
n.mavrogiannopoulos@gmail.com&gt; wrote:

&gt; &gt;&gt; If you do that please don't make it the default. There are several cases
&gt; &gt;&gt; in DTLS where the nonce isn't simply incrementing (e.g. when receiving
&gt; &gt;&gt; packets out-of-order).
&gt; &gt; I was thinking of _init setting it to zero, and have _digest do post
&gt; &gt; increment. So then you could chose between
&gt;
&gt; Looks ok but I don't like that cycles are wasted in the case one doesn't
&gt; use it. They are not much but I wouldn't expect that from a low-level
&gt; library.
&gt;

I may be wrong here. I'd expect the library to do similarly to what it does
in CBC mode encryption. If it updates the IV there, then it would be
natural to expect that it will update the nonce in that interface as well.

regards,
Nikos

</body></email><email><emailId>20130405081300</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-05 08:13:00-0400</timestampReceived><subject>Re: umac</subject><body>

Here's a tentative Nettle interface for umac. Comments appreciated.

I'll be traveling over the weekend, more or less offline, so I may not
respond until Tuesday or so.

Regards,
/Niels

/* umac.h
 *
 * UMAC message authentication code (RFC-4418).
 */

/* nettle, low-level cryptographics library
 *
 * Copyright (C) 2013 Niels MÃ¶ller
 *  
 * The nettle library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 * 
 * The nettle library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with the nettle library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02111-1301, USA.
 */

#ifndef NETTLE_UMAC_H_INCLUDED
#define NETTLE_UMAC_H_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#define UMAC_BLOCK_SIZE 1024
#define UMAC_KEY_SIZE 16

/* Subkeys and state for UMAC with tag size 32*n bits. */
#define _UMAC_STATE(n)					\
  uint32_t l1_key[UMAC_BLOCK_SIZE/4 + 4*((n)-1)];	\
  /* Keys in 32-bit pieces, low first */		\
  uint32_t p64_key[2*(n)];				\
  uint32_t p128_key[4*(n)];				\
  uint64_t l3_key1[8*(n)];				\
  uint32_t l3_key2[(n)];				\
  /* AES cipher for encrypting the nonce */		\
  struct aes_ctx pdf_key;				\
  /* Buffer l1 output for one block */			\
  uint64_t l1_out[(n)];					\
  /* For both poly64-hashing and poly128 hashing */	\
  uint64_t poly_state[2*(n)];

struct umac_buffer
{
  unsigned blocks;
  unsigned pos;
  uint8_t buffer[UMAC_BLOCK_SIZE];  
}

struct umac32_ctx
{
  _UMAC_STATE(1);
  /* Input to the pdf_key, zero-padded and low bits cleared. */
  uint8_t nonce[AES_BLOCK_SIZE];
  int nonce_low; /* Low bits, plus some flag for the pad cache. */
  /* Previous padding block */
  uint8_t pad_cache[AES_BLOCK_SIZE];

  struct umac_buffer buffer;
};

struct umac64_ctx
{
  _UMAC_STATE(2);
  /* Input to the pdf_key, zero-padded and low bits cleared. */
  uint8_t nonce[AES_BLOCK_SIZE];
  int nonce_low; /* Low bits, plus some flag for the pad cache. */
  /* Previous padding block */
  uint8_t pad_cache[AES_BLOCK_SIZE];

  struct umac_buffer buffer;
};

struct umac96_ctx
{
  _UMAC_STATE(3);
  /* Input to the pdf_key, zero-padded if needed. */
  uint8_t nonce[AES_BLOCK_SIZE];

  struct umac_buffer buffer;
};

struct umac128_ctx
{
  _UMAC_STATE(4);
  /* Input to the pdf_key, zero-padded if needed. */
  uint8_t nonce[AES_BLOCK_SIZE];

  struct umac_buffer buffer;
};

/* The _set_key function initialize the nonce to zero. */
void
umac32_set_key (struct umac32_ctx *ctx, const uint8_t *key);
void
umac64_set_key (struct umac64_ctx *ctx, const uint8_t *key);
void
umac96_set_key (struct umac96_ctx *ctx, const uint8_t *key);
void
umac128_set_key (struct umac128_ctx *ctx, const uint8_t *key);

/* Optional, if not used, messages get incrementing nonces starting from zero. */
void
umac32_set_nonce (struct umac32_ctx *ctx,
		  unsigned nonce_length, const uint8_t *nonce);
void
umac64_set_nonce (struct umac64_ctx *ctx,
		  unsigned nonce_length, const uint8_t *nonce);
void
umac96_set_nonce (struct umac96_ctx *ctx,
		  unsigned nonce_length, const uint8_t *nonce);
void
umac128_set_nonce (struct umac128_ctx *ctx,
		   unsigned nonce_length, const uint8_t *nonce);

void
umac32_update (struct umac32_ctx *ctx,
	       unsigned length, const uint8_t *data);
void
umac64_update (struct umac64_ctx *ctx,
	       unsigned length, const uint8_t *data);
void
umac96_update (struct umac96_ctx *ctx,
	       unsigned length, const uint8_t *data);
void
umac128_update (struct umac128_ctx *ctx,
		unsigned length, const uint8_t *data);

/* The _digest functions increment the nonce */
void
umac32_digest (struct umac32_ctx *ctx,
	       unsigned length, uint8_t *digest);
void
umac64_digest (struct umac64_ctx *ctx,
	       unsigned length, uint8_t *digest);
void
umac96_digest (struct umac96_ctx *ctx,
	       unsigned length, uint8_t *digest);
void
umac128_digest (struct umac128_ctx *ctx,
		unsigned length, uint8_t *digest);


/* Internal functions */
#define _UMAC_POLY64_BLOCKS 16384

uint64_t
_umac_nh (const uint32_t *key, unsigned length, const uint8_t *msg);

/* Equivalent to

   for (i = 0; i &lt; n; i++)
     out[i] = _umac_nh (key + 4*i, length, msg);

   but processing input only once.
*/
void
_umac_nh_n (uint64_t *out, unsigned n, const uint32_t *key,
	    unsigned length, const uint8_t *msg);

/* Returns y*k + m (mod p), including "marker" processing. Return
   value is *not* in canonical representation, and must be normalized
   before the output is used. */
uint64_t
_umac_poly64 (uint32_t kh, uint32_t kl, uint64_t y, uint64_t m);

void
_umac_poly128 (const uint32_t *k, uint32_t *y, uint64_t mh, uint64_t ml);

uint32_t
_umac_l3 (const uint64_t *key_1, uint32_t key_2, const uint64_t *m);

#ifdef __cplusplus
}
#endif

#endif /* NETTLE_UMAC_H_INCLUDED */



-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130405145802</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-04-05 14:58:02-0400</timestampReceived><subject>Re: umac</subject><body>

On Fri, Apr 5, 2013 at 10:13 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; Here's a tentative Nettle interface for umac. Comments appreciated.
&gt;
&gt;
Looks fine to me.

regards,
Nikos

</body></email><email><emailId>20130411193840</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-11 19:38:40-0400</timestampReceived><subject>Re: umac</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Here's a tentative Nettle interface for umac. Comments appreciated.

Implemented now. I added some more testvectors, using the python code as
reference (I should check that in some day soon too). Still no coverage
of all unlikely cases, I'm afraid.

I also added some benchmark code, but I'm not sure if it measures short
(&lt; 16 Mbyte) or larger messages, since the benchmarking function keeps
calling the update function with a stop condition based on elapsed time.
It's clearly a bit faster than the other hash functions, even with
128-bit output.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130411213321</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-04-11 21:33:21-0400</timestampReceived><subject>Re: umac</subject><body>

On 04/11/2013 09:38 PM, Niels Möller wrote:

&gt;&gt; Here's a tentative Nettle interface for umac. Comments appreciated.
&gt; Implemented now. 


Nice.


&gt; I also added some benchmark code, but I'm not sure if it measures short
&gt; (&lt; 16 Mbyte) or larger messages, since the benchmarking function keeps
&gt; calling the update function with a stop condition based on elapsed time.
&gt; It's clearly a bit faster than the other hash functions, even with
&gt; 128-bit output.


It is a bit unfair to compare umac with plain hashes. In the last patch
there was an addition to the benchmarks to have HMAC performance as well.

regards,
Nikos

</body></email><email><emailId>20130412072052</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-04-12 07:20:52-0400</timestampReceived><subject>Re: umac</subject><body>

On 04/11/2013 09:38 PM, Niels Möller wrote:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt;&gt; Here's a tentative Nettle interface for umac. Comments appreciated.


I modified gnutls to use that code. I noticed that the context size is
quite excessive (may be an issue when is used as stack variable), but as
I understand there is not much that can be done about it.

Something I noticed is that for the nonce increment you could also use
the INCREMENT macro used in ctr.

Also because I work using an abstraction layer, and the umac_set_key()
is different from hmac_xhash_set_key() which all have a length
parameter, requires me to use a wrapper over it. It may be nicer (for me
at least) if umac_set_key() accepted the length as well.

regards,
Nikos


</body></email><email><emailId>20130412083654</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-12 08:36:54-0400</timestampReceived><subject>Re: umac</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; I modified gnutls to use that code. I noticed that the context size is
&gt; quite excessive (may be an issue when is used as stack variable), but as
&gt; I understand there is not much that can be done about it.

The block buffer and the l1 subkeys need about 1 Kbyte each.

&gt; Something I noticed is that for the nonce increment you could also use
&gt; the INCREMENT macro used in ctr.

Right. But I first need to modify the INCREMENT macro to support length
== 1, otherwise it wont work for a single-byte nonce.

&gt; Also because I work using an abstraction layer, and the umac_set_key()
&gt; is different from hmac_xhash_set_key() which all have a length
&gt; parameter, requires me to use a wrapper over it. It may be nicer (for me
&gt; at least) if umac_set_key() accepted the length as well.

I don't think I want to add a key_length parameter, if all I can do with
it is an assert (key_length == 16). Is there any other reasonable use? I
guess one could pass a longer key (192 or 256 bits) to
aes_set_encrypt_key, but that's beyond the umac spec.

In nettle in general, algorithms with a fix key size never gets a key
size argument; that's for the next abstraction layer to unify, if
desired.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130412084346</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-12 08:43:46-0400</timestampReceived><subject>Re: umac</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; It is a bit unfair to compare umac with plain hashes.

For large messages I think it is fair; the O(n) work is the same for
hash and hmac-hash; hmac only adds O(1) work of hashing some short
constant-size strings. And the benchmark program only tries to measure
the O(n) term.

&gt; In the last patch
&gt; there was an addition to the benchmarks to have HMAC performance as well.

Sorry I missed that. Was there really any measureable difference between
hash and hmac-hash? The "update" processing is the same (except perhaps
an additional function call).

BTW, I'm currently debugging some ARM neon code for umac_nh. Looks like
umac32 will be about 10 times faster than sha1. And neon is *so* much
nicer to work with than the sse instructions on x86.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130410070739</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-10 07:07:39-0400</timestampReceived><subject>Re: Building on AIX 6.1</subject><body>

Perry Smith &lt;pedzsan@gmail.com&gt; writes:

&gt; It would be interesting to see what platforms need the non-pic mode.
&gt; I've not heard of anything other than position independent code for
&gt; a fairly long time now.

I think it matters in two ways.

1. On processors that lack general pc-relative addressing, e.g., x86_32,
   pic code causes additonal overhead when, e.g., addressing constant
   data tables. I think there are some issues on x86_64 darwin as well,
   but I guess that's just problems with Apple's tools, nothing
   fundamental.

2. Constant data structures which contain absolute pointers, like
   nettle's

     const struct nettle_cipher nettle_aes128;

   If you do position independent code, the pointers have to be
   relocated at load time, so the structure has to be allocated in the
   data segment (despite "const"). If we allow position dependent code,
   the structure can be put into the rodata segment where one might
   expect it, with relocation done only at link time.
   
&gt; The default output of IBM's xlc compiler as well as GNU's gcc compiler
&gt; is to produce position independent code for AIX.  I believe that is true
&gt; for any Power PC platform.  And I thought that that was true for almost
&gt; any modern chip (Intel, etc).

Ok, so on those platforms we shouldn't pass any special flags for
compilation. I guess we still need some xlc-specific options if we use
xlc for *linking* the shared library?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130312170533</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2013-03-12 17:05:33-0400</timestampReceived><subject>Re: ARM assembly</subject><body>


On 03/12/2013 05:51 AM, Niels M=C3=B6ller wrote:

&gt; In my benchmarks, AES decrypt is significantly slower than AES decrypt,=

&gt; for no reason that I understand, and I have tried some other variants o=
f
&gt; instruction scheduling.

You've got "AES decrypt" in both parts of the sentence above -- i assume
one of them is supposed to be "AES encrypt", but i'm not sure which one.
I'm curious, though :)

Sorry to not have anything helpful to offer on the questions you asked.

Regards,

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20130312173743</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-12 17:37:43-0400</timestampReceived><subject>Re: ARM assembly</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; You've got "AES decrypt" in both parts of the sentence above -- i assume
&gt; one of them is supposed to be "AES encrypt", but i'm not sure which one.
&gt; I'm curious, though :)

Ooops. In my enchmarks, decrypt is slower than encrypt (it had been a
bit worse if it were the other way round, since some constructions, in
particular CTR mode, uses encrypt only).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130213194232</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2013-02-13 19:42:32-0400</timestampReceived><subject>Re: ECC benchmarks</subject><body>

ons 2013-02-13 klockan 16:34 +0100 skrev Niels Möller:
&gt; While for verify, we're a little behind. And my code tries hard
&gt; to be side-channel silent (even for verify, where it doesn't matter).

Why is that?  Is it because you re-use code that is also used by
signing?  Maybe it makes sense to implement the time consuming functions
in a side-channel leaky (but faster) way for use with verify?  It will
make the code somewhat bigger, but I'm not sure anyone cares.

Btw, it would be nice to compare with GnuTLS' ECDSA as well, it contains
some nice optimizations.

/Simon


</body></email><email><emailId>20130213203556</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-02-13 20:35:56-0400</timestampReceived><subject>Re: ECC benchmarks</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Why is that?  Is it because you re-use code that is also used by
&gt; signing?

Exactly, for now I stick to using the same primitives.

&gt; Maybe it makes sense to implement the time consuming functions
&gt; in a side-channel leaky (but faster) way for use with verify?  It will
&gt; make the code somewhat bigger, but I'm not sure anyone cares.

It would certainly make sense to use separate functions for verifying
(or other computations on public values only), but I think I'd like to
integrate the current code in Nettle first. And there are other possible
optimizations too, so I think one should go for the lowest hanging fruit
first.

&gt; Btw, it would be nice to compare with GnuTLS' ECDSA as well, it contains
&gt; some nice optimizations.

Do you have an example on how to do that? Corresponding to the (quite
ugly) openssl interface at
https://www.openssl.org/docs/crypto/ecdsa.html, including an almost
working example. I have to admit that I'm not very familiar with gnutls,
so I'm probably not looking at the right places.

Regards,
/Niels
-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130213222818</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-02-13 22:28:18-0400</timestampReceived><subject>Re: ECC benchmarks</subject><body>

On 02/13/2013 04:34 PM, Niels Möller wrote:

&gt; So it looks like for signing, the current code beats openssl by a factor
&gt; of two. While for verify, we're a little behind. 


How can it be like that? Signing requires:
modulo n, 1 inversion, 2 multiplications, and 1 addition, as well as 1
multiplication with the EC generator point.

The verification requires:
modulo n, 1 inversion, 2 multiplications, 1 multiplication with a random
elliptic curve point, 1 multiplication with the EC generator point and
an elliptic curve addition.

If nettle is faster on signing it means (if we ignore operations mod n),
that EC multiplication with the curve generator  point is 2x faster on
nettle.

The fact that openssl is a bit faster on verification it would mean that
nettle is really slower than openssl in multiplying a random point, and
adding points on the curve. Could that be?

regards,
Nikos

</body></email><email><emailId>20130214071748</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-02-14 07:17:48-0400</timestampReceived><subject>Re: ECC benchmarks</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; If nettle is faster on signing it means (if we ignore operations mod n),
&gt; that EC multiplication with the curve generator  point is 2x faster on
&gt; nettle.

Probably a bit more than a factor of two, since the silent modular
inversion is likely much slower than openssl's.

&gt; The fact that openssl is a bit faster on verification it would mean that
&gt; nettle is really slower than openssl in multiplying a random point, and
&gt; adding points on the curve. Could that be?

The point multiplication with the random point takes much longer time
than the point multiplication involving the generator. So if we have,
say, 40% slowdown for the random point, and 200% speedup for the
generator, the net result could still be 20% slowdown. (I made those
figures up, but I think they are in the right ballpark).

I guess the penalty for side-channel silence is generally some 10-30%.
Except for modinv, where it's even worse.

The reason we get pretty good performance for signing is that I use the
Pippenger/comb algorithm for multiplication involving the generator.
With current parameters, there's roughly 16 KByte of data for each
curve, and multiplication takes n/6 dups and n/6 adds, where n is the
bit size. While algorithms like wmNAF may use even fewer adds, but it
still needs n dups. And for all the adds, one point is precomputed, so
in Jacobian coordinates we have Z=1.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130214081627</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-02-14 08:16:27-0400</timestampReceived><subject>Re: ECC benchmarks</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; The point multiplication with the random point takes much longer time
&gt; than the point multiplication involving the generator.

I added some more functions to the benchmarking (at the cost of a bit
too long lines):

size      modp      redc      modq    modinv    dup_jj   add_jja   add_jjj     mul_g     mul_a (us)
 192    0.0250    0.0261    0.0442   13.7320    0.4994    0.6127    0.6138   37.7651  147.9455
 224    0.0546    0.0435    0.0665   22.8033    0.7316    0.9063    0.9075   75.1715  256.2235
 256    0.0714    0.0391    0.0798   23.1066    0.6377    0.7910    0.7912   80.2991  254.6769
 384    0.0834    0.0000    0.0614   47.6998    1.2428    1.6319    1.6311  241.0215  734.5506
 521    0.0344    0.0533    0.1296  105.0090    1.1316    1.4764    1.4775  343.3341  915.2812

So mul_a appears to be about 3 times slower than mul_g. And modinv is
awful, at 1/3 of the time of a mul_g, signing will spend 1/4 of the time
in modinv. (I have some ideas on how to simplify modinv and make it a
little less slow).

(BTW, the 0.0 for 384-bit redc just means that no redc function is
implemented for that prime. It's more of an anomaly that modp is slower
than modq; that's an opportunity for optimization).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130216182501</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-02-16 18:25:01-0400</timestampReceived><subject>Re: ECC benchmarks</subject><body>

On 02/14/2013 09:16 AM, Niels Möller wrote:

&gt;&gt; The point multiplication with the random point takes much longer time
&gt;&gt; than the point multiplication involving the generator.
&gt; 
&gt; I added some more functions to the benchmarking (at the cost of a bit
&gt; too long lines):
&gt; 
&gt; size      modp      redc      modq    modinv    dup_jj   add_jja   add_jjj     mul_g     mul_a (us)
&gt;  192    0.0250    0.0261    0.0442   13.7320    0.4994    0.6127    0.6138   37.7651  147.9455
&gt;  224    0.0546    0.0435    0.0665   22.8033    0.7316    0.9063    0.9075   75.1715  256.2235
&gt;  256    0.0714    0.0391    0.0798   23.1066    0.6377    0.7910    0.7912   80.2991  254.6769
&gt;  384    0.0834    0.0000    0.0614   47.6998    1.2428    1.6319    1.6311  241.0215  734.5506
&gt;  521    0.0344    0.0533    0.1296  105.0090    1.1316    1.4764    1.4775  343.3341  915.2812
&gt; 
&gt; So mul_a appears to be about 3 times slower than mul_g. And modinv is
&gt; awful, at 1/3 of the time of a mul_g, signing will spend 1/4 of the time
&gt; in modinv. (I have some ideas on how to simplify modinv and make it a

&gt; little less slow).

That's pretty good table. It would be nice to have a comparison of
modinv with mpz_invert as a baseline (you also don't need to use a
timing resistant modinv during verification).

How hard could it be to add the wmNAF multiplication from ecc_mulmod.c
in gnutls to this list for comparison? If it is much faster than mul_a,
then it would be a good candidate for the multiplication needed in DH
(which doesn't need to be side-channel resistant).

regards,
Nikos

</body></email><email><emailId>20130217084740</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-02-17 08:47:40-0400</timestampReceived><subject>Re: ECC benchmarks</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; That's pretty good table. It would be nice to have a comparison of
&gt; modinv with mpz_invert as a baseline (you also don't need to use a
&gt; timing resistant modinv during verification).

That would make sense. On the mpn level, the corresponding GMP function
is mpn_gcdext.

&gt; How hard could it be to add the wmNAF multiplication from ecc_mulmod.c
&gt; in gnutls to this list for comparison?

Do you have some example code to use this gnutls function? Then I'm
afraid it might also be a bit tricky to get linking right if we want to
have it all in the same benchmark executable.

&gt; If it is much faster than mul_a, then it would be a good candidate for
&gt; the multiplication needed in DH (which doesn't need to be side-channel
&gt; resistant).

There are two potential gains from using gnutls code or something
similar: (i) Fewer point additions, due to more clever window hadling
and/or exponent recoding. (ii) The add and dup primitives could be sped
up a little if they're not required to be side-channel silent.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130102230746</emailId><senderName>James Cloos</senderName><senderEmail>cloos@jhcloos.com</senderEmail><timestampReceived>2013-01-02 23:07:46-0400</timestampReceived><subject>Re: Getting closer to nettle-2.6</subject><body>

&gt;&gt;&gt;&gt;&gt; "NM" == Niels MÃ¶ller &lt;nisse@lysator.liu.se&gt; writes:

NM&gt;    my best guess is that it's the
NM&gt;    moves of data between regular registers and xmm registers that
NM&gt;    somehow stall.

IIRC, the advice I've seen is to always move data between the integer
registers and the xmm registers via the stack.

All of the relevant gcc- and llvm-produced code I've looked (at least
over the last few months; I can't remember too far back) follows that
pattern.

Yes, The 47414_15h_sw_opt_guide.pdf, in  §10.4 says:

,----&lt;  §10.4, p169 of 47414_15h_sw_opt_guide.pdf ¹ &gt;
| Optimization
| 
| When moving data from a GPR to an XMM register, use separate store and
| load instructions to move the data first from the source register to a
| temporary location in memory and then from memory into the destination
| register, taking the memory latency into account when scheduling both
| stages of the load-store sequence.
| 
| When moving data from an XMM register to a general-purpose register,
| use the VMOVD instruction.
| 
| Whenever possible, use loads and stores of the same data length. (See
| 6.3, â€˜Store-to-Load Forwarding Restrictions" on page 98 for more
| information.)
`----

VMOVD, obviosuly, doesn't apply for fam10 and earlier; I didn't look
through my archive to find the sw_opt_guide for earlier processors, though.

1] http://support.amd.com/us/Processor_TechDocs/47414_15h_sw_opt_guide.pdf

-JimC
-- 
James Cloos &lt;cloos@jhcloos.com&gt;         OpenPGP: 1024D/ED7DAEA6

</body></email><email><emailId>20130103075222</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-01-03 07:52:22-0400</timestampReceived><subject>Re: Getting closer to nettle-2.6</subject><body>

James Cloos &lt;cloos@jhcloos.com&gt; writes:

&gt; ,----&lt;  §10.4, p169 of 47414_15h_sw_opt_guide.pdf ¹ &gt;
&gt; | Optimization
&gt; | 
&gt; | When moving data from a GPR to an XMM register, use separate store and
&gt; | load instructions to move the data first from the source register to a
&gt; | temporary location in memory and then from memory into the destination
&gt; | register, taking the memory latency into account when scheduling both
&gt; | stages of the load-store sequence.

Thanks for the hint. Maybe I can try that, it sounds like a fairly easy
fix. If I can get the code run at three instructions per cycle, that
would be a pretty nice speedup on amd processors.

&gt; | Whenever possible, use loads and stores of the same data length. (See
&gt; | 6.3, â€˜Store-to-Load Forwarding Restrictions" on page 98 for more
&gt; | information.)

Not sure how to interpret this. The interesting cases here are:

1. Writing the 64 low bits of an xmm register, (movq with memory
   destination) and reading it back into a gpr.

2. Writing a 128-bit xmm register (movaps), and reading it back into two gpr
   registers.

And then the opposite direction.

Regards,
/Niels

-- 
Niels MÃ¶ller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130103083321</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-01-03 08:33:21-0400</timestampReceived><subject>Re: Getting closer to nettle-2.6</subject><body>

On Wed, Jan 2, 2013 at 9:45 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; wr=
ote:
&gt; I think I'd like to make a nettle-2.6 release fairly soon.

I tried to use the new stream algorithm salsa20, but noticed that the
variant implemented is mentioned neither in the header nor in the
documentation. From the code and the previous discussion in the ML I
see that the 20 rounds variant is there. While this is nice, I do
think that having the 12 round variant as well is advantageous since
this is the variant accepted in profile 1 of estream
(http://www.ecrypt.eu.org/stream/).

regards,
Nikos

</body></email><email><emailId>20130103170921</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-01-03 17:09:21-0400</timestampReceived><subject>Re: Getting closer to nettle-2.6</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; I tried to use the new stream algorithm salsa20, but noticed that the
&gt; variant implemented is mentioned neither in the header nor in the
&gt; documentation.

What's missing, more precisely? E.g., salsa20_crypt is both in the
salsa20.h header file and in the Salsa20 section in the manual.

&gt; From the code and the previous discussion in the ML I
&gt; see that the 20 rounds variant is there.

Right, other variants where postponed for lack of clear use cases.

&gt; While this is nice, I do think that having the 12 round variant as
&gt; well is advantageous since this is the variant accepted in profile 1
&gt; of estream (http://www.ecrypt.eu.org/stream/).

What name should it use, salsa20_12_crypt? I imagine there are some
testvectors somewhere on the ecrypt site?

It should be straightforward to implement on top of _salsa20_core, just
like in salsa20-crypt.c. For an all-assembly implementation including
the xor:ing, I guess one would want a _salsa20_crypt with an argument
specifying number of rounds.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130103173724</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-01-03 17:37:24-0400</timestampReceived><subject>Re: Getting closer to nettle-2.6</subject><body>

On 01/03/2013 06:09 PM, Niels Möller wrote:

&gt; What's missing, more precisely? E.g., salsa20_crypt is both in the
&gt; salsa20.h header file and in the Salsa20 section in the manual.


It may be better to refer to it as salsa20/20. Then it would be clear
which variant it is.

&gt; 
&gt;&gt; From the code and the previous discussion in the ML I
&gt;&gt; see that the 20 rounds variant is there.
&gt; Right, other variants where postponed for lack of clear use cases.

As far as I know Salsa20 isn't standardized in a protocol. However if
that occurs it may be that the 20/12 variant is selected because of estream.

&gt; What name should it use, salsa20_12_crypt? I imagine there are some
&gt; testvectors somewhere on the ecrypt site?


No idea.

regards,
Nikos

</body></email><email><emailId>20130403103419</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-03 10:34:19-0400</timestampReceived><subject>Re: Release plans</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Just an idea.  I always feel that these "distant future" release plans
&gt; raraly materialize,

True. We'll see what to do after 2.7.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130404083359</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-04 08:33:59-0400</timestampReceived><subject>ECC status update for March</subject><body>

Nettle project funded by Internetfonden

Status update for March 2013

* Summary

ARM optimizations of cryptographic primitives.

* Activities

The time in March have been spent mainly on ARM assembly
implementation of various cryptographic primitives. The portability of
the new ECC code has been improved, with contributions from Martin
StorsjÃ¶. In the process, also the non-ARM code and the testsuite has
seen some improvements.

The GNU GMP library is used by Nettle for general arithmetic on large
integers. For example, each multiplication of two ECC coordinates is
done as a call to a general multiplication routine in GMP, followed by
a call to an optimized curve-specific function for reducing the
product modulo a fixed prime p. During the month, some work has been
done to make more low-level operations in GMP available for users of
the library. The functions mpn_cnd_add_n and mpn_cnd_sub_n, for
side-channel silent conditional addition and subtraction, are now
available and documented, as well as some functions for easy
conversion betwen GMP's higher-level "mpz" interface and the
lower-level "mpn" interface.

On the GMP side, TorbjÃ¶rn Granlund have been improving the ARM code.
Relinking Nettle code with the development version of GMP also give
nice performance improvements.

During March, 103 working hours have been spent on the project.

* Results

The "normal" ARM instruction set offers 16 general purpose registers,
of 32 bits each. Some ARM processors, including the Cortex-A9, also
offer an extension for single-instruction-multiple-data (SIMD). The
ARM "Neon" instruction set is in some ways similar to the SSE2
instructions available on current x86_64 processors, but well designed
and much easier to work with. It offers 16 additional registers of 128
bits each, with both integer operations on up to 64-bit quantities,
and floating point operations (which are not used in Nettle).

Using Neon instructions gives a dramatic speedup for the SHA512 and
SHA3 hash functions, which make heavy use of 64-bit operations. The
ARM assembly code for the other algorithms don't make any use of Neon,
but they have nevertheless beeen sped up compared to the C
implementation, due to better register allocation, and tricks to use
aligned reads for possibly unaligned input data.

There is certainly room for additional optimizations to the assembly
code, in particular improving instruction scheduling.

* Benchmarks

For these cryptographic primitives, the numbers are in units of
MByte/s, benchmarked on a 1GHz ARM Cortex-A9.

Algorithm		Before	After	Speedup

  memxor (aligned)	988	1906	93%
  memxor (unaligned)	511	638 	25%
			            
  aes-128		17.3	21.9	27%
  aes-192		14.5	16.7	15%
  aes-256		12.5	16.1	29%
  			            
  salsa20		39.9	58.1	46%
  			            
  sha1			55.7	60.7	9%
  sha256		24.6	31.7	29%
  sha512		7.8	30.4	290%
  			            
  sha3-224		5.77	27.5	377%
  sha3-256		5.45	26.0	377%
  sha3-384		4.18	20.0	378%
  sha3-512		2.90	13.9	379%

Public key operations:

           name size   sign/ms         verify/ms
            rsa 1024    0.5014 ( +90%)    9.1323 (+101%)
            rsa 2048    0.0835 (+113%)    2.6942 (+116%)
            dsa 1024    0.9857 (+110%)    0.5026 (+111%)
          ecdsa  192    1.4312 ( +16%)    0.5530 ( +28%)
          ecdsa  224    1.0072 ( +18%)    0.4037 ( +31%)
          ecdsa  256    0.7846 ( +25%)    0.3094 ( +38%)
          ecdsa  384    0.3308 ( +31%)    0.1307 ( +49%)
          ecdsa  521    0.1823 ( +38%)    0.0719 ( +60%)
ecdsa (openssl)  224    0.1842            0.1545
ecdsa (openssl)  384    0.0695            0.0590
ecdsa (openssl)  521    0.0261            0.0216

The improvements here are due to GMP work.


* Remaining tasks

The most important remaining task is documentation and release work.
Plan and progress for the release is maintained at
http://www.lysator.liu.se/~nisse/nettle/plan.html.

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130406093301</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-06 09:33:01-0400</timestampReceived><subject>Re: [PATCH] sha3: Correct _sha3_update for incremental hashing</subject><body>

edgar.iglesias@gmail.com writes:

&gt; diff --git a/sha3.c b/sha3.c
&gt; index d7aec46..21e7beb 100644
&gt; --- a/sha3.c
&gt; +++ b/sha3.c
&gt; @@ -61,7 +61,7 @@ _sha3_update (struct sha3_state *state,
&gt;    if (pos &gt; 0)
&gt;      {
&gt;        unsigned left = block_size - pos;
&gt; -      if (length &lt; pos)
&gt; +      if (length &lt; left)
&gt;  	{
&gt;  	  memcpy (block + pos, data, length);
&gt;  	  return pos + length;

Thanks, checked in now. Unfortunately, testutils.c:test_hash doesn't
exercise this logic.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130410163714</emailId><senderName>Perry Smith</senderName><senderEmail>pedzsan@gmail.com</senderEmail><timestampReceived>2013-04-10 16:37:14-0400</timestampReceived><subject>Re: Building on AIX 6.1</subject><body>


On Apr 10, 2013, at 2:07 AM, Niels Möller wrote:

&gt; Perry Smith &lt;pedzsan@gmail.com&gt; writes:
&gt; 
&gt;&gt; It would be interesting to see what platforms need the non-pic mode.
&gt;&gt; I've not heard of anything other than position independent code for
&gt;&gt; a fairly long time now.
&gt; 
&gt; I think it matters in two ways.
&gt; 
&gt; 1. On processors that lack general pc-relative addressing, e.g., x86_32,
&gt;   pic code causes additonal overhead when, e.g., addressing constant
&gt;   data tables. I think there are some issues on x86_64 darwin as well,
&gt;   but I guess that's just problems with Apple's tools, nothing
&gt;   fundamental.
&gt; 
&gt; 2. Constant data structures which contain absolute pointers, like
&gt;   nettle's
&gt; 
&gt;     const struct nettle_cipher nettle_aes128;
&gt; 
&gt;   If you do position independent code, the pointers have to be
&gt;   relocated at load time, so the structure has to be allocated in the
&gt;   data segment (despite "const"). If we allow position dependent code,
&gt;   the structure can be put into the rodata segment where one might
&gt;   expect it, with relocation done only at link time.
&gt; 
&gt;&gt; The default output of IBM's xlc compiler as well as GNU's gcc compiler
&gt;&gt; is to produce position independent code for AIX.  I believe that is true
&gt;&gt; for any Power PC platform.  And I thought that that was true for almost
&gt;&gt; any modern chip (Intel, etc).
&gt; 
&gt; Ok, so on those platforms we shouldn't pass any special flags for
&gt; compilation. I guess we still need some xlc-specific options if we use
&gt; xlc for *linking* the shared library?

Ok.  I looked at the gcc manual about -fPIC.  I'm surprised.  I thought
hardware had evolved more.

In any case, it did confirm: "Code generated for the IBM RS/6000 is always 
position-independent."  (This is true for both compilers.)  Also, just to be clear,
I'm using GCC.

The suggestion I had was to have SUFFIX (like you have) and PIC_SUFFIX.
For the RS/6000 and Power PC, PIC_SUFFIX could be .o so it would not
recompile all the code a second time.

The other idea I had is to have a .pic directory and put the PIC objects in
that directory with a normal .o suffix.

Perry


</body></email><email><emailId>20130412095630</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-04-12 09:56:30-0400</timestampReceived><subject>Re: umac</subject><body>

On Fri, Apr 12, 2013 at 10:43 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:

&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt;
&gt; &gt; It is a bit unfair to compare umac with plain hashes.
&gt; For large messages I think it is fair; the O(n) work is the same for
&gt; hash and hmac-hash; hmac only adds O(1) work of hashing some short
&gt; constant-size strings. And the benchmark program only tries to measure
&gt; the O(n) term.
&gt;

That's correct if you are thinking about long messages. In practice,
however, MACs are used with short messages. In TLS a MAC is used with a
message that has a maximum of a 15kb, and in DTLS most messages are around
the ethernet packet size (1500 bytes). At these sizes any overhead O(1) may
be critical to performance.


&gt; &gt; In the last patch
&gt; &gt; there was an addition to the benchmarks to have HMAC performance as wel=
l.
&gt; Sorry I missed that. Was there really any measureable difference between
&gt; hash and hmac-hash? The "update" processing is the same (except perhaps
&gt; an additional function call).
&gt;

I don't remember. It was a different test. I only have a copy of the mail I
sent you and the numbers were the following:
        umac-aes-4        full  737.86
        umac-aes-8        full  801.11
       umac-aes-12        full  771.41
       umac-aes-16        full  724.91
          hmac-md5        full  481.41
         hmac-sha1        full  437.43
       hmac-sha256        full  171.49
     hmac-sha3_256        full  200.44

On the same system now I get:
               md5      update  506.93
              sha1      update  446.76
            sha256      update  197.33
          sha3_256      update  231.99

and for UMAC:
            umac32      update 3596.71
            umac64      update 1967.24
            umac96      update 1564.06
           umac128      update 1304.87


regards,
Nikos

</body></email><email><emailId>20130416094304</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-16 09:43:04-0400</timestampReceived><subject>Internal vs installed headers</subject><body>

I'm considering moving some macros from macros.h (installad as
&lt;nettle/macros.h&gt;) to nettle-internal.h (not installed). Only the
various READ, WRITE and ROTL macros seem generally useful. Comments?

I'm also looking at the current umac.h. It could be split into umac.h
and umac-internal.h, but I'm not sure that's needed; the "internal"
definitions are reasonably clean and seem unlikely to cause problems.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130416095500</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-16 09:55:00-0400</timestampReceived><subject>Micro optimizations of the umac context structs</subject><body>

Speaking of umac, I'm also looking at the umac context structs, for
potential micro optimizations and fixes before it becomes a part of the
ABI.

Some fields, like nonce_length, index, and (for umac32 and umac64)
nonce_low, fit in 16 or even 8 bits. So it might make sense to make them
adjacent.

And on the other hand, the umac block count is currently unsigned, and
will wraparound after 2*32 blocks or 2^42 bytes. Other hash functions
typically support data sizes up to 2^64 (except sha512 which uses a
128-bit coutner, which seems gross overkill).

For umac, the block counter is only needed to keep track of when to
switch to different layer 2 hashing, and to keep track of odd and even
blocks for poly128. So it could probably be made to work with only 16
bits and some saturation logic. But extending it to 64 bits seems
simpler.

It would also be nice if we could force 16-byte alignment for the l1_key
array (this is important for assembly routines), which would them imply
16-byte alignment for the complete context struct. Could help x86 sse2
assembly. And could help also on ARM, but I'm not sure if the system
(primarily linker and malloc) really makes 16-byte alignment possible
there.

And it would also be good to get a reasonably large alignment for the
block buffer.

In gcc, there's __attribute__ ((aligned (16))), but since this gets part
of the ABI, we can't use it in public headers unless we can specify the
same alignment for *all* reasonable compilers for the given architecture.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130323191648</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-03-23 19:16:48-0400</timestampReceived><subject>[PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

---
 gmp-glue.c |   26 ++++++++++++++++++++++++++
 gmp-glue.h |   26 ++++++++++++++++++++++++++
 2 files changed, 52 insertions(+)

diff --git a/gmp-glue.c b/gmp-glue.c
index b468699..a2633a5 100644
--- a/gmp-glue.c
+++ b/gmp-glue.c
@@ -106,6 +106,32 @@ mpz_roinit_n (mpz_ptr x, const mp_limb_t *xp, mp_size_t xs)
 }
 #endif /* !GMP_HAVE_mpz_limbs_read */
 
+#if !GMP_HAVE_mpn_copyd
+void
+mpn_copyd (mp_ptr dst, mp_srcptr src, mp_size_t n)
+{
+  mp_size_t i;
+  for (i = n - 1; i &gt;= 0; i--)
+    dst[i] = src[i];
+}
+
+void
+mpn_copyi (mp_ptr dst, mp_srcptr src, mp_size_t n)
+{
+  mp_size_t i;
+  for (i = 0; i &lt; n; i++)
+    dst[i] = src[i];
+}
+
+void
+mpn_zero (mp_ptr ptr, mp_size_t n)
+{
+  mp_size_t i;
+  for (i = 0; i &lt; n; i++)
+    ptr[i] = 0;
+}
+#endif /* !GMP_HAVE_mpn_copyd */
+
 /* Additional convenience functions. */
 
 int
diff --git a/gmp-glue.h b/gmp-glue.h
index ef17c2f..27c0942 100644
--- a/gmp-glue.h
+++ b/gmp-glue.h
@@ -33,6 +33,12 @@
 #define GMP_HAVE_mpz_limbs_read 0
 #endif
 
+#ifdef mpz_copyd
+#define GMP_HAVE_mpz_copyd 1
+#else
+#define GMP_HAVE_mpz_copyd 0
+#endif
+
 #if __GNU_MP__ &lt; 5
 typedef unsigned long int mp_bitcnt_t;
 #endif
@@ -46,6 +52,12 @@ typedef unsigned long int mp_bitcnt_t;
 #define mpz_roinit_n _nettle_mpz_roinit_n
 #endif
 
+#if !GMP_HAVE_mpn_copyd
+#define mpn_copyd _nettle_mpn_copyd
+#define mpn_copyi _nettle_mpn_copyi
+#define mpn_zero  _nettle_mpn_zero
+#endif
+
 #define mpz_limbs_cmp _nettle_mpz_limbs_cmp
 #define mpz_limbs_read_n _nettle_mpz_limbs_read_n
 #define mpz_limbs_copy _nettle_mpz_limbs_copy
@@ -87,6 +99,20 @@ mpz_roinit_n (mpz_ptr x, const mp_limb_t *xp, mp_size_t xs);
 
 #endif /* !GMP_HAVE_mpz_limbs_read */
 
+#if !GMP_HAVE_mpn_copyd
+/* Copy elements, backwards */
+void
+mpn_copyd (mp_ptr dst, mp_srcptr src, mp_size_t n);
+
+/* Copy elements, forwards */
+void
+mpn_copyi (mp_ptr dst, mp_srcptr src, mp_size_t n);
+
+/* Zero elements */
+void
+mpn_zero (mp_ptr ptr, mp_size_t n);
+#endif /* !GMP_HAVE_mpn_copyd */
+
 /* Convenience functions */
 int
 mpz_limbs_cmp (mpz_srcptr a, const mp_limb_t *bp, mp_size_t bn);
-- 
1.7.9.4


</body></email><email><emailId>20130413115956</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-04-13 11:59:56-0400</timestampReceived><subject>rename of salsa20r12</subject><body>

The attached patch renames the salsa20r12_crypt function to
estream_salsa20_crypt(), and adds it in the benchmarks.

What is missing is an equivalent of x86_64/salsa20-crypt.asm for the
estream variant.

regards,
Nikos

["0001-Salsa20r12-renamed-to-estream-salsa20.patch" (text/x-patch)]

&gt; From 62201a70415b5e75c966487394a6e92eea32e9c6 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Sat, 13 Apr 2013 13:52:37 +0200
Subject: [PATCH] Salsa20r12 renamed to estream-salsa20

---
 Makefile.in                 |    2 +-
 estream-salsa20-crypt.c     |   74 +++++++++++++++++++++++++++++++++++++++++++
 examples/nettle-benchmark.c |    1 +
 nettle-internal.c           |   10 ++++++
 nettle-internal.h           |    1 +
 salsa20.h                   |    4 +--
 salsa20r12-crypt.c          |   74 -------------------------------------------
 testsuite/salsa20-test.c    |   16 +++++-----
 8 files changed, 97 insertions(+), 85 deletions(-)
 create mode 100644 estream-salsa20-crypt.c
 delete mode 100644 salsa20r12-crypt.c

diff --git a/Makefile.in b/Makefile.in
index ae20a67..7431b85 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -86,7 +86,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gosthash94.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
 		 salsa20-core-internal.c \
-		 salsa20-crypt.c salsa20r12-crypt.c salsa20-set-key.c \
+		 salsa20-crypt.c estream-salsa20-crypt.c salsa20-set-key.c \
 		 sha1.c sha1-compress.c sha1-meta.c \
 		 sha256.c sha256-compress.c sha224-meta.c sha256-meta.c \
 		 sha512.c sha512-compress.c sha384-meta.c sha512-meta.c \
diff --git a/estream-salsa20-crypt.c b/estream-salsa20-crypt.c
new file mode 100644
index 0000000..cb8c367
--- /dev/null
+++ b/estream-salsa20-crypt.c
@@ -0,0 +1,74 @@
+/* salsa20r12-crypt.c
+ *
+ * The Salsa20 stream cipher.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Nikos Mavrogiannopoulos
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+/* Based on:
+   salsa20-ref.c version 20051118
+   D. J. Bernstein
+   Public domain.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;string.h&gt;
+
+#include "salsa20.h"
+
+#include "macros.h"
+#include "memxor.h"
+
+void
+estream_salsa20_crypt(struct salsa20_ctx *ctx,
+	      unsigned length,
+	      uint8_t *c,
+	      const uint8_t *m)
+{
+  uint32_t x[_SALSA20_INPUT_LENGTH];
+
+  if (!length)
+    return;
+  
+  for (;;)
+    {
+
+      _salsa20_core (x, ctx-&gt;input, 12);
+
+      ctx-&gt;input[9] += (++ctx-&gt;input[8] == 0);
+
+      /* stopping at 2^70 length per nonce is user's responsibility */
+      
+      if (length &lt;= SALSA20_BLOCK_SIZE)
+	{
+	  memxor3 (c, m, (uint8_t *) x, length);
+	  return;
+	}
+      memxor3 (c, m, (uint8_t *) x, SALSA20_BLOCK_SIZE);
+
+      length -= SALSA20_BLOCK_SIZE;
+      c += SALSA20_BLOCK_SIZE;
+      m += SALSA20_BLOCK_SIZE;
+    }
+}
diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index 5be3d49..57a49fc 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -663,6 +663,7 @@ main(int argc, char **argv)
       &amp;nettle_serpent256,
       &amp;nettle_twofish128, &amp;nettle_twofish192, &amp;nettle_twofish256,
       &amp;nettle_salsa20,
+      &amp;nettle_estream_salsa20,
       NULL
     };
 
diff --git a/nettle-internal.c b/nettle-internal.c
index d1d7675..5c5bd74 100644
--- a/nettle-internal.c
+++ b/nettle-internal.c
@@ -97,6 +97,16 @@ nettle_salsa20 = {
   (nettle_crypt_func *) salsa20_crypt
 };
 
+
+const struct nettle_cipher
+nettle_estream_salsa20 = {
+  "estream-salsa20", sizeof(struct salsa20_ctx),
+  0, SALSA20_KEY_SIZE,
+  salsa20_set_key_hack, salsa20_set_key_hack,
+  (nettle_crypt_func *) estream_salsa20_crypt,
+  (nettle_crypt_func *) estream_salsa20_crypt
+};
+
 const struct nettle_aead
 nettle_gcm_aes128 = _NETTLE_AEAD(gcm, GCM, aes, 128);
 const struct nettle_aead
diff --git a/nettle-internal.h b/nettle-internal.h
index 3b7f771..892b008 100644
--- a/nettle-internal.h
+++ b/nettle-internal.h
@@ -62,6 +62,7 @@ extern const struct nettle_cipher nettle_blowfish128;
 
 /* For benchmarking only, sets no iv and lies about the block size. */
 extern const struct nettle_cipher nettle_salsa20;
+extern const struct nettle_cipher nettle_estream_salsa20;
 
 /* Glue to openssl, for comparative benchmarking. Code in
  * examples/nettle-openssl.c. */
diff --git a/salsa20.h b/salsa20.h
index be2662c..366e801 100644
--- a/salsa20.h
+++ b/salsa20.h
@@ -39,7 +39,7 @@ extern "C" {
 #define salsa20_crypt nettle_salsa20_crypt
 #define _salsa20_core _nettle_salsa20_core
 
-#define salsa20r12_crypt nettle_salsa20r12_crypt
+#define estream_salsa20_crypt nettle_estream_salsa20_crypt
 
 /* Minimum and maximum keysizes, and a reasonable default. In
  * octets.*/
@@ -79,7 +79,7 @@ salsa20_crypt(struct salsa20_ctx *ctx,
 	      const uint8_t *src);
 
 void
-salsa20r12_crypt(struct salsa20_ctx *ctx,
+estream_salsa20_crypt(struct salsa20_ctx *ctx,
 		 unsigned length, uint8_t *dst,
 		 const uint8_t *src);
 
diff --git a/salsa20r12-crypt.c b/salsa20r12-crypt.c
deleted file mode 100644
index 0c82217..0000000
--- a/salsa20r12-crypt.c
+++ /dev/null
@@ -1,74 +0,0 @@
-/* salsa20r12-crypt.c
- *
- * The Salsa20 stream cipher.
- */
-
-/* nettle, low-level cryptographics library
- *
- * Copyright (C) 2013 Nikos Mavrogiannopoulos
- *  
- * The nettle library is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2.1 of the License, or (at your
- * option) any later version.
- * 
- * The nettle library is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
- * License for more details.
- * 
- * You should have received a copy of the GNU Lesser General Public License
- * along with the nettle library; see the file COPYING.LIB.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA 02111-1301, USA.
- */
-
-/* Based on:
-   salsa20-ref.c version 20051118
-   D. J. Bernstein
-   Public domain.
-*/
-
-#if HAVE_CONFIG_H
-# include "config.h"
-#endif
-
-#include &lt;string.h&gt;
-
-#include "salsa20.h"
-
-#include "macros.h"
-#include "memxor.h"
-
-void
-salsa20r12_crypt(struct salsa20_ctx *ctx,
-	      unsigned length,
-	      uint8_t *c,
-	      const uint8_t *m)
-{
-  uint32_t x[_SALSA20_INPUT_LENGTH];
-
-  if (!length)
-    return;
-  
-  for (;;)
-    {
-
-      _salsa20_core (x, ctx-&gt;input, 12);
-
-      ctx-&gt;input[9] += (++ctx-&gt;input[8] == 0);
-
-      /* stopping at 2^70 length per nonce is user's responsibility */
-      
-      if (length &lt;= SALSA20_BLOCK_SIZE)
-	{
-	  memxor3 (c, m, (uint8_t *) x, length);
-	  return;
-	}
-      memxor3 (c, m, (uint8_t *) x, SALSA20_BLOCK_SIZE);
-
-      length -= SALSA20_BLOCK_SIZE;
-      c += SALSA20_BLOCK_SIZE;
-      m += SALSA20_BLOCK_SIZE;
-    }
-}
diff --git a/testsuite/salsa20-test.c b/testsuite/salsa20-test.c
index 4b0906f..c3bf993 100644
--- a/testsuite/salsa20-test.c
+++ b/testsuite/salsa20-test.c
@@ -181,41 +181,41 @@ _test_salsa20(salsa20_func *crypt,
 #define test_salsa20(key, iv, cleartext, ciphertext) \
   _test_salsa20 (salsa20_crypt, (key), (iv), (cleartext), (ciphertext))
 
-#define test_salsa20r12(key, iv, cleartext, ciphertext) \
-  _test_salsa20 (salsa20r12_crypt, (key), (iv), (cleartext), (ciphertext))
+#define test_estream_salsa20(key, iv, cleartext, ciphertext) \
+  _test_salsa20 (estream_salsa20_crypt, (key), (iv), (cleartext), (ciphertext))
 
   
 void
 test_main(void)
 {
   /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/reduced/12-rounds/verified.test-vectors?logsort=rev&amp;rev=210&amp;view=markup \
                */
-  test_salsa20r12(SHEX("80000000 00000000 00000000 00000000"),
+  test_estream_salsa20(SHEX("80000000 00000000 00000000 00000000"),
 		  SHEX("00000000 00000000"),
 		  SHEX("00000000 00000000"),
 		  SHEX("FC207DBF C76C5E17"));
 
-  test_salsa20r12(SHEX("00400000 00000000 00000000 00000000"),
+  test_estream_salsa20(SHEX("00400000 00000000 00000000 00000000"),
 		  SHEX("00000000 00000000"),
 		  SHEX("00000000 00000000"),
 		  SHEX("6C11A3F9 5FEC7F48"));
 
-  test_salsa20r12(SHEX("09090909090909090909090909090909"),
+  test_estream_salsa20(SHEX("09090909090909090909090909090909"),
 		  SHEX("0000000000000000"),
 		  SHEX("00000000 00000000"),
 		  SHEX("78E11FC3 33DEDE88"));
 
-  test_salsa20r12(SHEX("1B1B1B1B1B1B1B1B1B1B1B1B1B1B1B1B"),
+  test_estream_salsa20(SHEX("1B1B1B1B1B1B1B1B1B1B1B1B1B1B1B1B"),
 		  SHEX("00000000 00000000"),
 		  SHEX("00000000 00000000"),
 		  SHEX("A6747461 1DF551FF"));
 
-  test_salsa20r12(SHEX("80000000000000000000000000000000"
+  test_estream_salsa20(SHEX("80000000000000000000000000000000"
 		       "00000000000000000000000000000000"),
 		  SHEX("00000000 00000000"),
 		  SHEX("00000000 00000000"),
 		  SHEX("AFE411ED 1C4E07E4"));
 
-  test_salsa20r12(SHEX("0053A6F94C9FF24598EB3E91E4378ADD"
+  test_estream_salsa20(SHEX("0053A6F94C9FF24598EB3E91E4378ADD"
 		       "3083D6297CCF2275C81B6EC11467BA0D"),
 		  SHEX("0D74DB42A91077DE"),
 		  SHEX("00000000 00000000"),
-- 
1.7.10.4



</body></email><email><emailId>20130413124242</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-13 12:42:42-0400</timestampReceived><subject>Re: rename of salsa20r12</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; The attached patch renames the salsa20r12_crypt function to
&gt; estream_salsa20_crypt(),

Why? Is "estream" clearer than "r12"? Do you expect more functions with
the estream prefix? I'm not sure I like it as a prefix (I mean, we don't
call it "nist_aes", just "aes").

If we think "estream variant of salsa20" is somehow clearer than
"12-round variant of salsa", then I think "estream" should be a suffix
rather than a prefix.

&gt; What is missing is an equivalent of x86_64/salsa20-crypt.asm for the
&gt; estream variant.

One could add a round argument (and rename it _salsa20_crypt, with
wrappers for useful variants).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130417122911</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-17 12:29:11-0400</timestampReceived><subject>ARM/NEON optimizations</subject><body>

Hi,

Before the upcoming(?) release, it might be good to tweak the way the NEON 
optimizations are enabled. Currently, as far as I've seen, they're enabled 
as soon as you target ARMv7, even if not all ARMv7 CPUs have NEON.

I've seen that you've discussed this on the GMP list a few times as well. 
For static detection in configure, one way is to check whether the 
assembler can do the neon instructions without actually adding the ".fpu 
neon" line. If this succeeds, the compiler/assembler is configured with 
-mfpu=neon, and we can freely use neon instructions wherever.

Since there's AFAIK no runtime detection for anything else in nettle so 
far (nor any state or global variables), I guess you're not going to add 
it anytime soon - for that case, detecting it statically in configure 
based on the target configuration is probably good enough.


Anyway, for reference on the topic of runtime detection (which is 
necessary e.g. on Android ARMv7, which explicitly supports a number of 
ARMv7 devices without NEON), there's a number of ways of doing it. One way 
that was mentioned on the gmp mailing list was using getauxval from glibc. 
This obviously isn't available on non-glibc platforms such as Android (or 
other platforms as well).

On general linux, one pretty straightforward way is to parse 
/proc/self/auxv (which is pretty well structured), the other is parsing 
/proc/cpuinfo (which requires a little bit more code to parse).

The Android NDK comes with a small support library that detects cpu 
extensions - previously it used to parse /proc/self/auxv, but in recent 
Android versions this file isn't accessible within release mode processes, 
so now it parses /proc/cpuinfo. See 
http://git.libav.org/?p=libav.git;a=blob;f=libavutil/arm/cpu.c or 
https://android.googlesource.com/platform/ndk/+/a92ba07e8abf397e74285e90d080ebbeaae7ed90/sources/android/cpufeatures/cpu-features.c \
 for examples on how to parse these files.

A third option is to allow the caller to set it, so the caller can use 
whatever runtime detection that is available on the app level and 
configure the library accordingly. But this both goes against the design 
of nettle, and additionally isn't too useful when nettle in many cases is 
used indirectly via a number of other libraries, and the calling app might 
not even know much about what lower level libraries are used.

// Martin


</body></email><email><emailId>20130417135737</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-17 13:57:37-0400</timestampReceived><subject>Re: ARM/NEON optimizations</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; Before the upcoming(?) release, it might be good to tweak the way the
&gt; NEON optimizations are enabled. Currently, as far as I've seen,
&gt; they're enabled as soon as you target ARMv7, even if not all ARMv7
&gt; CPUs have NEON.

The name "armv7" on the directory is maybe not entirely correct either.
I just noticed that config.guess classifies my pandaboard
"armv7l-unknown-linux-gnueabihf". gmp uses a script on top of the
standard config.guess to give more fine-graned classification, and it
says "armcortexa9neon-unknown-linux-gnueabihf". Seems this is based on
parsing of /proc/cpuinfo.

I'm not going to do anything sophisticated about this before the 2.7
release (which I'd like to get out within a few days, at most two
weeks). I could add an --enable-neon/--disable-neon flag, with default
based either on /proc/cpuinfo (and some fix default for cross
compilation), or on what the assembler accepts, as you suggest. Would
that make sense?

To just detect neon, something like grep '^Features.*neon' /proc/cpuinfo
seems simple enough. And then I guess we can follow gmp conventions and
have some subdirectories arm, arm/v6, arm/neon, searched in
configure-dependent order.

&gt; I've seen that you've discussed this on the GMP list a few times as
&gt; well. For static detection in configure, one way is to check whether
&gt; the assembler can do the neon instructions without actually adding the
&gt; ".fpu neon" line.

Then one would essentially configure it by setting CC, to something like
CC='gcc -mfpu=neon". Somehow logical, and analoguous to how ABI is
configured, but not entirely user friendly.

&gt; Since there's AFAIK no runtime detection for anything else in nettle
&gt; so far (nor any state or global variables), I guess you're not going
&gt; to add it anytime soon

I'd definitely like to have run-time detection, but you're right that
it's unlikely to happen soon. It could use atomic writes to some pointer
variables, but there's no need for locking or any user-visible
initialization functions.

I should also look into IFUNC relocations. Nettle can't rely exclusively
on IFUNC, since it's not portable, but when available it makes it
possible to eliminate one level of indirection, and install a pointer to
the right routine directly in the PLT entry.

&gt; Anyway, for reference on the topic of runtime detection (which is
&gt; necessary e.g. on Android ARMv7, which explicitly supports a number of
&gt; ARMv7 devices without NEON), there's a number of ways of doing it.

I've recently got some android devices to play with, but I'm not yet
very familiar with android at all. I haven't tried to compile anything
for android yet, and I haven't looked at google's sdk. I'd prefer a
standard cross-compilation setup, like what I get with

  apt-get gcc-arm-linux-gnueabihf

for cross-compiling to a ARM  gnu/linux system. Is that possible yet?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130417182448</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-17 18:24:48-0400</timestampReceived><subject>Re: ARM/NEON optimizations</subject><body>


On Wed, 17 Apr 2013, Niels Möller wrote:

&gt; Martin Storsjö &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt; Before the upcoming(?) release, it might be good to tweak the way the
&gt;&gt; NEON optimizations are enabled. Currently, as far as I've seen,
&gt;&gt; they're enabled as soon as you target ARMv7, even if not all ARMv7
&gt;&gt; CPUs have NEON.
&gt;
&gt; The name "armv7" on the directory is maybe not entirely correct either.
&gt; I just noticed that config.guess classifies my pandaboard
&gt; "armv7l-unknown-linux-gnueabihf". gmp uses a script on top of the
&gt; standard config.guess to give more fine-graned classification, and it
&gt; says "armcortexa9neon-unknown-linux-gnueabihf". Seems this is based on
&gt; parsing of /proc/cpuinfo.
&gt;
&gt; I'm not going to do anything sophisticated about this before the 2.7
&gt; release (which I'd like to get out within a few days, at most two
&gt; weeks). I could add an --enable-neon/--disable-neon flag, with default
&gt; based either on /proc/cpuinfo (and some fix default for cross
&gt; compilation), or on what the assembler accepts, as you suggest. Would
&gt; that make sense?

That's certainly a good start. The test for what the assembler accepts at 
least should be the safest - then no neon instructions are produced unless 
this would be allowed by the C compiler in general. I'm not sure how well 
detecting from /proc/cpuinfo would work for something e.g. like debian 
(unless the packager overrides it with arm specific options), where the 
package might be built on a pandaboard but is intended for distribution on 
a wider range of devices. But as long as it can be disabled with 
--disable-neon, packagers/users can always get it working right with more 
or less effort. OTOH, if the /proc/cpuinfo approach works for GMP, doing 
something similar probably makes sense as well.

&gt; To just detect neon, something like grep '^Features.*neon' /proc/cpuinfo
&gt; seems simple enough. And then I guess we can follow gmp conventions and
&gt; have some subdirectories arm, arm/v6, arm/neon, searched in
&gt; configure-dependent order.

Yes, that regexp probably is enough, and that directory structure seems 
sensible.

&gt;&gt; I've seen that you've discussed this on the GMP list a few times as
&gt;&gt; well. For static detection in configure, one way is to check whether
&gt;&gt; the assembler can do the neon instructions without actually adding the
&gt;&gt; ".fpu neon" line.
&gt;
&gt; Then one would essentially configure it by setting CC, to something like
&gt; CC='gcc -mfpu=neon". Somehow logical, and analoguous to how ABI is
&gt; configured, but not entirely user friendly.

Not entirely user friendly, no, but I've seen the same pattern elsewhere. 
And since you don't want to produce neon instructions (at least not 
guarded by proper runtime detection) unless the baseline ABI supports it, 
it's a pretty decent safeguard as well.

&gt;&gt; Since there's AFAIK no runtime detection for anything else in nettle
&gt;&gt; so far (nor any state or global variables), I guess you're not going
&gt;&gt; to add it anytime soon
&gt;
&gt; I'd definitely like to have run-time detection, but you're right that
&gt; it's unlikely to happen soon. It could use atomic writes to some pointer
&gt; variables, but there's no need for locking or any user-visible
&gt; initialization functions.
&gt;
&gt; I should also look into IFUNC relocations. Nettle can't rely exclusively
&gt; on IFUNC, since it's not portable, but when available it makes it
&gt; possible to eliminate one level of indirection, and install a pointer to
&gt; the right routine directly in the PLT entry.
&gt;
&gt;&gt; Anyway, for reference on the topic of runtime detection (which is
&gt;&gt; necessary e.g. on Android ARMv7, which explicitly supports a number of
&gt;&gt; ARMv7 devices without NEON), there's a number of ways of doing it.
&gt;
&gt; I've recently got some android devices to play with, but I'm not yet
&gt; very familiar with android at all. I haven't tried to compile anything
&gt; for android yet, and I haven't looked at google's sdk. I'd prefer a
&gt; standard cross-compilation setup, like what I get with
&gt;
&gt;  apt-get gcc-arm-linux-gnueabihf
&gt;
&gt; for cross-compiling to a ARM  gnu/linux system. Is that possible yet?

Yes, that's quite possible. If you unpack an android NDK, you've got a 
directory like 
android-ndk-r8e/toolchains/arm-linux-androideabi-4.7/prebuilt/darwin-x86_64/bin, 
where you find the normal GCC cross toolchain, with tools like 
arm-linux-androideabi-gcc. When using this directly, you need to add a 
parameter like --sysroot=android-ndk/platforms/android-3/arch-arm to the 
compiler, to find the right platform headers. Alternatively, you can run a 
script in ndk/build/tools/make-standalone-toolchain.sh, which copies out a 
toolchain and set of platform headers/libs and bundles them together so 
you don't need the sysroot parameter. All of this is documented within 
ndk/docs/STANDALONE-TOOLCHAIN.html.

For building static libraries, this works pretty much exactly as you'd do 
on any other platform with a normal gcc cross toolchain. If you've got a 
rooted device, you can build normal executables as well and run them on 
the device ("adb push mybinary /data; adb shell /data/mybinary"). If you 
haven't got a rooted device, you'd want to set up a normal android app 
project (either a "pure native" project, or a full java project which 
calls native code via JNI - in either case which then would link to the 
static library you've built externally).

For a shared library, there's a few small extra gotchas. The built shared 
object would need to be named libnettle.so without trailing version 
numbers. Additionally, due to deficiencies in the android app environment 
when it comes to shared library loading, you'd need to load them in 
reverse order from java; first a System.loadLibrary("nettle"), then 
System.loadLibrary("myapp"), so that all dependencies of the shared 
library libmyapp.so is loaded before trying to load it. For a number of 
layered libraries, this is a bit of an issue, but it's mostly the burden 
of the app developer who wants to release it and wants to keep the 
libraries linked separately for license reasons (combining LGPL code with 
proprietary code), otherwise linking it statically obviously is simpler.

// Martin

</body></email><email><emailId>20130421195043</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-21 19:50:43-0400</timestampReceived><subject>nettle-2.7 release candidate</subject><body>

I've generated a release candidate, available at

  http://www.lysator.liu.se/~nisse/archive/nettle-2.7rc1.tar.gz

Testing appreciated.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130423112300</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-23 11:23:00-0400</timestampReceived><subject>Re: nettle-2.7 release candidate</subject><body>


On Sun, 21 Apr 2013, Niels Möller wrote:

&gt; I've generated a release candidate, available at
&gt;
&gt;  http://www.lysator.liu.se/~nisse/archive/nettle-2.7rc1.tar.gz
&gt;
&gt; Testing appreciated.

With the patch I just sent, nettle 2.7 builds in the "tricky" cross build 
envs I normally build nettle in.

// Martin

</body></email><email><emailId>20130425074440</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-25 07:44:40-0400</timestampReceived><subject>Switching to size_t (was: Re: Release plans)</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Re the 3.0 plans, it seems that making a 3.0 release that implement the
&gt; first two items on the list (unsigned-&gt;size_t, memxor namespace) would
&gt; be possible to achieve relatively soon with modest investment in work.

I've done the memxor thing now, and I'm looking into size_t. When
switching to size_t, should we use it for *all* lengths, or only all
lengths which potentially are large? For an example, consider aes.h:

I think it's clear that we ought to switch to size_t for

  void
  aes_encrypt(const struct aes_ctx *ctx,
  	    unsigned length, uint8_t *dst,
  	    const uint8_t *src);
  void
  aes_decrypt(const struct aes_ctx *ctx,
  	    unsigned length, uint8_t *dst,
  	    const uint8_t *src);

(not that it seems particularly likely that those functions will be
called with more than 4GB at a time, but the API shouldn't make it
impossible). But what about

  void
  aes_set_encrypt_key(struct aes_ctx *ctx,
  		    unsigned length, const uint8_t *key);

The length here must be one of the integers 16, 24 or 32. Should we stick
to unsigned here, or use size_t for consistency?

Other key sizes are a bit more subtle. E.g., hmac keys can be up to 2^64
bits (or whatever is the maximum size of the underlying hash function,
like the ridiculously large limit of 2^128 bits for SHA512), but all
keys used in practice are going to have a size which fit in 32 bits (or
even 16 bits. RSA bitsizes are similarly unlimited in theory but pretty
small in any reasonable practice.

I think it would make some sense to adopt the principle that key sizes
use unsigned (since keys by definition are small objects), and message
sizes use size_t. Which would still leave some corner cases, like
rsa_encrypt where only messages of small size (depending on the key
size) are possible.

Comments?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130427122918</emailId><senderName>Florian Pritz</senderName><senderEmail>bluewind@xinu.at</senderEmail><timestampReceived>2013-04-27 12:29:18-0400</timestampReceived><subject>Problems when compiling 32bit version on 64bit host (multilib)</subject><body>


Hi,

I'm compiling nettle for the Arch Linux multilib repository (32bit
libraries for a 64bit system so people can run skype and wine without
needing a chroot). Looks like the new ecc code doesn't properly handle
integer type sizes.

Here[1] is the output of make, make check along with the PKGBUILD used
to build this and a sample of the generated ecc-*.h files.

[1]: http://flo.server-speed.net/tmp/lib32-nettle/

Can I fix that by setting some env variable or does it need code changes?=


If you need any more files, please tell me.




["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20130425115555</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-25 11:55:55-0400</timestampReceived><subject>Re: Switching to size_t</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Is this the only reason to break binary compatibility?

The other obvious thing is to get memxor in the nettle_ symbol name
space. And changing memxor argument types from uint8_t * to void *
(strictly speaking, that's an API change, not an ABI change).

There are some other, less trivial, changes I'm considering.

* Making the ctx argument of nettle_cipher_func const, and restrict it
  to block ciphers only. (And then do some different abstraction(s) for
  for arcfour and salsa20).

* Doing something about the hash/hmac interface, to avoid having to
  allocate three different buffers for a single hmac context.

* Tweaks to other context structs. E.g., for AES we have the nrounds
  field last, after the subkeys. If one could move it first, then one
  could allocate less space for subkeys when using shorter AES key sizes
  (not entirely sure how to make a decent C API for that, though).

* See if we can arrange for 16-byte alignment for structures where it
  matters.

The ABI break for nettle-2.1 didn't cause any large problems, as
far as I'm aware. But I guess nettle has more users now than it had
three years ago.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130429064147</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-29 06:41:47-0400</timestampReceived><subject>AEs interface (was: Re: Switching to size_t)</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; There are some other, less trivial, changes I'm considering.

&gt; * Tweaks to other context structs. E.g., for AES we have the nrounds
&gt;   field last, after the subkeys. If one could move it first, then one
&gt;   could allocate less space for subkeys when using shorter AES key sizes
&gt;   (not entirely sure how to make a decent C API for that, though).

I think it's going to get a bit messy to handle structs of varying size.
I think the simplest way would be to arrange the internal aes functions
to take number of rounds and the subkey as separate arguments. And then
define separate context structs and functions for each key size, like

  struct aes128_ctx
  {
    uint32_t keys[44];
  };

  struct aes192_ctx
  {
    uint32_t keys[52];
  };

  struct aes256_ctx
  {
    uint32_t keys[60];
  };

There should be no problem to also keep the current AES interface (with
variable key size) for backwards compatibility.

All the public AES functions would then call the same internal
functions, specifying the approproate number of rounds/subkeys in each
case.

Does that make sense? My impression is that most applications and
protocols typically treat AES128 and AES256 as different algorithms, and
have little use for an interface where the same function accepts a
variable key size.

And to recall, the motivation for the change is to avoid useless
allocation for the common case of AES128.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130425151505</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-04-25 15:15:05-0400</timestampReceived><subject>Re: Switching to size_t</subject><body>

On Thu, Apr 25, 2013 at 2:55 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; * Doing something about the hash/hmac interface, to avoid having to
&gt;   allocate three different buffers for a single hmac context.

Moreover, I need two hmac contexts in order to implement reset().
Since TLS is using the same key per packet, I would need to call
hmac_set_key() on every packet (which is expensive), or save all
states and reload them on reset(). On plain HMAC the memory for the
hashes was not that significant, but on umac that method is quite
wasteful. I don't see a straightforward solution to that though,
without a high level API.

regards,
Nikos

</body></email><email><emailId>20130425165148</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-25 16:51:48-0400</timestampReceived><subject>Re: Switching to size_t</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Moreover, I need two hmac contexts in order to implement reset().

Can you explain how this works and what is needed? I don't remember much
of TLS, so I have no idea what "reset" means here.

&gt; On plain HMAC the memory for the hashes was not that significant, but
&gt; on umac that method is quite wasteful. I don't see a straightforward
&gt; solution to that though, without a high level API.

Would it help to have a separate struct for the expanded key, and use
that key with several per-message contexts? A bit like the split between
struct gcm_key and struct gcm_ctx, in gcm.h? The same could be done also
with hmac, if needed.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130426133607</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-04-26 13:36:07-0400</timestampReceived><subject>Re: Switching to size_t</subject><body>

On Thu, Apr 25, 2013 at 7:51 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt;
&gt;&gt; Moreover, I need two hmac contexts in order to implement reset().
&gt; Can you explain how this works and what is needed? I don't remember much
&gt; of TLS, so I have no idea what "reset" means here.

The current HMAC API assumes that the hashing state is kept per call.
That is if I have to hash a series of packets with contents X_0, X_1,
..., X_n I do:
hmac_set_key(s);
for (i=1;i&lt;n;i++) {
  hmac_update(s, X_i)
  hmac_digest(s, output)
}

In this approach the output of X_i contains the state which resulted
from hashing X_(i-1). In TLS, however, hmac is used simply as:
for (i=1;i&lt;n;i++) {
  hmac_set_key(s);
  hmac_update(s, X_i)
  hmac_digest(s, output)
}

that is the MAC of X_i is independent of X_(i-1), and no state is kept
across records. The reset I am mentioning is a simplification of the
above as:
hmac_set_key(s);
for (i=1;i&lt;n;i++) {
  hmac_update(s, X_i)
  hmac_digest(s, output)
  hmac_reset(s)
}

and effectively sets the state s, to the same values it was after
hmac_set_key().

&gt;&gt; On plain HMAC the memory for the hashes was not that significant, but
&gt;&gt; on umac that method is quite wasteful. I don't see a straightforward
&gt;&gt; solution to that though, without a high level API.
&gt; Would it help to have a separate struct for the expanded key, and use
&gt; that key with several per-message contexts? A bit like the split between
&gt; struct gcm_key and struct gcm_ctx, in gcm.h? The same could be done also
&gt; with hmac, if needed.

That looks like a nice and clean solution. Would it be something like:
hmac_set_key(struct hmac_key*)
hmac_init(struct hmac_ctx*, struct hmac_key*)
hmac_update(struct hmac_ctx*)
hmac_digest(struct hmac_ctx*, output)
?

It would be nice if umac could be used under such an abstraction (or
if the umac_set_nonce would imply the reset).

regards,
Nikos

</body></email><email><emailId>20130426172115</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-26 17:21:15-0400</timestampReceived><subject>Re: Switching to size_t</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; The current HMAC API assumes that the hashing state is kept per call.

I don't think so, but maybe I misunderstand you (or maybe you have found
a bug?).

&gt; That is if I have to hash a series of packets with contents X_0, X_1,
&gt; ..., X_n I do:
&gt; hmac_set_key(s);
&gt; for (i=1;i&lt;n;i++) {
&gt;   hmac_update(s, X_i)
&gt;   hmac_digest(s, output)
&gt; }

That loop should compute HMAC(key, X_0), HMAC(key, X_1), and so on, with
X_0 affecting only the first digest.

&gt; for (i=1;i&lt;n;i++) {
&gt;   hmac_set_key(s);
&gt;   hmac_update(s, X_i)
&gt;   hmac_digest(s, output)
&gt; }

And so should this (assuming you pass the same key to set_key every
time).

Both hmac_set_key and hmac_digest end with identical calls

  memcpy(state, inner, hash-&gt;context_size);

to set the state properly for hashing a new message.

&gt; hmac_set_key(struct hmac_key*)
&gt; hmac_init(struct hmac_ctx*, struct hmac_key*)
&gt; hmac_update(struct hmac_ctx*)
&gt; hmac_digest(struct hmac_ctx*, output)

Something like that would make sense.

&gt; It would be nice if umac could be used under such an abstraction (or
&gt; if the umac_set_nonce would imply the reset).

umac_digest should imply a reset (and an increment of the nonce, if you don't
call set_nonce explicitly).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130426214906</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-04-26 21:49:06-0400</timestampReceived><subject>Re: Switching to size_t</subject><body>

On Fri, Apr 26, 2013 at 8:21 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt;&gt; The current HMAC API assumes that the hashing state is kept per call.
&gt; I don't think so, but maybe I misunderstand you (or maybe you have found
&gt; a bug?).

It seems you're correct, sorry for the noise. I interpreted the
_digest() functions of nettle similarly to digest output functions in
gcrypt which don't cause a reset of the hash. I should have read the
documentation carefully. The current code is thus fine for my usage.

regards,
Nikos

</body></email><email><emailId>20130427054938</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-27 05:49:38-0400</timestampReceived><subject>Re: Switching to size_t</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; It seems you're correct, sorry for the noise. I interpreted the
&gt; _digest() functions of nettle similarly to digest output functions in
&gt; gcrypt which don't cause a reset of the hash.

So in nettle, instead you need to copy the state (or start over) if you
want to have the digest of X_0 and the digest of the concatenation X_0 +
X_1. Which I'd expect to be a less common use case.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130423113452</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-23 11:34:52-0400</timestampReceived><subject>Re: nettle-2.7 release candidate</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; With the patch I just sent, nettle 2.7 builds in the "tricky" cross
&gt; build envs I normally build nettle in.

Thanks!

BTW, is there any interest for some kind of release party in Stockholm?
Possibly on Friday.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130423123834</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-23 12:38:34-0400</timestampReceived><subject>Re: nettle-2.7 release candidate</subject><body>


On Tue, 23 Apr 2013, Niels Möller wrote:

&gt; Martin Storsjö &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt; With the patch I just sent, nettle 2.7 builds in the "tricky" cross
&gt;&gt; build envs I normally build nettle in.
&gt;
&gt; Thanks!
&gt;
&gt; BTW, is there any interest for some kind of release party in Stockholm?
&gt; Possibly on Friday.

I'm not in the area, and wouldn't be able to make it this week anyway.


I built and tested the rc on native windows as well - in 32 bit mode, all 
tests succeed, while in 64 bit mode, quite a few of them seem to fail - 
the failing tests are:

salsa20
sha224 sha256 sha384 sha512
hmac umac
yarrow
pbkdf2
rsa
dsa dsa-keygen

Haven't checked yet whether the same failures can be reproduced with 
wine64.

// Martin

</body></email><email><emailId>20130423131001</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-23 13:10:01-0400</timestampReceived><subject>Re: nettle-2.7 release candidate</subject><body>


On Tue, 23 Apr 2013, Martin Storsjö wrote:

&gt; I built and tested the rc on native windows as well - in 32 bit mode, all 
&gt; tests succeed, while in 64 bit mode, quite a few of them seem to fail - the 
&gt; failing tests are:
&gt;
&gt; salsa20
&gt; sha224 sha256 sha384 sha512
&gt; hmac umac
&gt; yarrow
&gt; pbkdf2
&gt; rsa
&gt; dsa dsa-keygen
&gt;
&gt; Haven't checked yet whether the same failures can be reproduced with wine64.

The exact same tests fail with wine64 when built and run from linux as 
well (with gmp 5.1.1 if that's of any relevance).

// Martin

</body></email><email><emailId>20130423145525</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-23 14:55:25-0400</timestampReceived><subject>Re: nettle-2.7 release candidate</subject><body>


On Tue, 23 Apr 2013, Martin Storsjö wrote:

&gt; On Tue, 23 Apr 2013, Martin Storsjö wrote:
&gt;
&gt;&gt; I built and tested the rc on native windows as well - in 32 bit mode, all 
&gt;&gt; tests succeed, while in 64 bit mode, quite a few of them seem to fail - the 
&gt;&gt; failing tests are:
&gt;&gt; 
&gt;&gt; salsa20
&gt;&gt; sha224 sha256 sha384 sha512
&gt;&gt; hmac umac
&gt;&gt; yarrow
&gt;&gt; pbkdf2
&gt;&gt; rsa
&gt;&gt; dsa dsa-keygen
&gt;&gt; 
&gt;&gt; Haven't checked yet whether the same failures can be reproduced with 
&gt;&gt; wine64.
&gt;
&gt; The exact same tests fail with wine64 when built and run from linux as well 
&gt; (with gmp 5.1.1 if that's of any relevance).

With the final two patches I've just sent, all of these pass, both on 
wine64 and on real windows.

// Martin

</body></email><email><emailId>20130423170619</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-23 17:06:19-0400</timestampReceived><subject>Re: nettle-2.7 release candidate</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; With the final two patches I've just sent, all of these pass, both on
&gt; wine64 and on real windows.

Many thanks for tracking these w64-related bugs down. Do you have a
debugging environment for w64, or did you find the bugs be reading the
(preprocessed) assembly code?

Looking at W64_ENTRY, do you remember why the stack allocation for saved
xmm registers is done as

      sub	[$]eval(8 + 16*($2 - 6)), %rsp

Subtracting the extra 8 bytes seems useless; at least I don't see
anything stored at that location. I wonder if maybe that was an
incomplete attempt at getting a 16-byte aligned pointer for the the xmm
stores?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130423191754</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-23 19:17:54-0400</timestampReceived><subject>Re: nettle-2.7 release candidate</subject><body>


On Tue, 23 Apr 2013, Niels Möller wrote:

&gt; Martin Storsjö &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt; With the final two patches I've just sent, all of these pass, both on
&gt;&gt; wine64 and on real windows.
&gt;
&gt; Many thanks for tracking these w64-related bugs down. Do you have a
&gt; debugging environment for w64, or did you find the bugs be reading the
&gt; (preprocessed) assembly code?

I have access to a real windows environment as well, where I used gdb to 
help me track them down, which really helped a lot this time. I've never 
taken the time to figure out how to use winedbg properly...

&gt; Looking at W64_ENTRY, do you remember why the stack allocation for saved
&gt; xmm registers is done as
&gt;
&gt;      sub	[$]eval(8 + 16*($2 - 6)), %rsp
&gt;
&gt; Subtracting the extra 8 bytes seems useless; at least I don't see
&gt; anything stored at that location. I wonder if maybe that was an
&gt; incomplete attempt at getting a 16-byte aligned pointer for the the xmm
&gt; stores?

Hmm, yes, I think that might have been the case. So since we can't rely on 
that being aligned anyway, we could just as well skip the 8 byte offset.

// Martin

</body></email><email><emailId>20130423193419</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-23 19:34:19-0400</timestampReceived><subject>Re: nettle-2.7 release candidate</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; Hmm, yes, I think that might have been the case. So since we can't
&gt; rely on that being aligned anyway, we could just as well skip the 8
&gt; byte offset.

If it works now, I don't think we should touch this code further before
release.

For later optimization (if it really makes a difference to performance
if we use aligned or unaligned loads and stores here? I don't know),
one could keep the 8 byte extra allocation, then do something like

	lea	8(%rsp), %r10
        and	$-16, %r10

(%r10 should always be free for scratch use at both entry and exit,
right?). Then %r10 will be 16 byte aligned, and hold either %rsp or %rsp
+ 8. And we can then do fully aligned loads and stores of the xmm
registers via offsets from %r10.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130418132357</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-18 13:23:57-0400</timestampReceived><subject>Re: ARM/NEON optimizations</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; On Wed, 17 Apr 2013, Niels Möller wrote:
&gt;
&gt;&gt; I'm not going to do anything sophisticated about this before the 2.7
&gt;&gt; release (which I'd like to get out within a few days, at most two
&gt;&gt; weeks). I could add an --enable-neon/--disable-neon flag, with default
&gt;&gt; based either on /proc/cpuinfo (and some fix default for cross
&gt;&gt; compilation), or on what the assembler accepts, as you suggest. Would
&gt;&gt; that make sense?
&gt;
&gt; That's certainly a good start.

Something along those lines checked in now. Testing appreciated.

For native compilation, configure checks /proc/cpuinfo, and for cross
compilation, it checks what the assembler accepts.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130418143410</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-18 14:34:10-0400</timestampReceived><subject>Re: ARM/NEON optimizations</subject><body>


On Thu, 18 Apr 2013, Niels Möller wrote:

&gt; Martin Storsjö &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt; On Wed, 17 Apr 2013, Niels Möller wrote:
&gt;&gt;
&gt;&gt;&gt; I'm not going to do anything sophisticated about this before the 2.7
&gt;&gt;&gt; release (which I'd like to get out within a few days, at most two
&gt;&gt;&gt; weeks). I could add an --enable-neon/--disable-neon flag, with default
&gt;&gt;&gt; based either on /proc/cpuinfo (and some fix default for cross
&gt;&gt;&gt; compilation), or on what the assembler accepts, as you suggest. Would
&gt;&gt;&gt; that make sense?
&gt;&gt;
&gt;&gt; That's certainly a good start.
&gt;
&gt; Something along those lines checked in now. Testing appreciated.
&gt;
&gt; For native compilation, configure checks /proc/cpuinfo, and for cross
&gt; compilation, it checks what the assembler accepts.

This seems to be work as intended (after some very brief testing), thanks!

// Martin

</body></email><email><emailId>20130421111959</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-04-21 11:19:59-0400</timestampReceived><subject>Re: ARM/NEON optimizations</subject><body>

On Thu, Apr 18, 2013 at 4:23 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt; Something along those lines checked in now. Testing appreciated.
&gt; For native compilation, configure checks /proc/cpuinfo, and for cross
&gt; compilation, it checks what the assembler accepts.

On which algorithms are the neon instructions used? I don't know if
that makes much sense performance-wise, but if they could be
auto-detected maybe I could include the neon code unconditionally on
the arm architecture and enable them in gnutls if the instructions are
there, the same way we use for padlock and aes-ni.

regards,
Nikos

</body></email><email><emailId>20130413132714</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-04-13 13:27:14-0400</timestampReceived><subject>Re: rename of salsa20r12</subject><body>

On 04/13/2013 02:42 PM, Niels Möller wrote:

&gt; Why? Is "estream" clearer than "r12"? Do you expect more functions with
&gt; the estream prefix? I'm not sure I like it as a prefix (I mean, we don't
&gt; call it "nist_aes", just "aes").


Do you think that using salsa20r12 is better? I thought that associating
a name (estream) is more memorable than just the number of rounds. And
if you use the number of rounds as a distinguisher then it comes the
question why 12 and not 8 or 16? So at some point you'll have to clarify
that r12 is actually the estream salsa20.

Estream doesn't really compare with AES because estream selected 5
ciphers as winners instead of one so it cannot be given simply the
estream name (estream was the stream cipher competition, ecrypt was the
organizer).

That's why I prefer the name estream-salsa20 (and also because we used
the same name in the proposal for Salsa20
http://tools.ietf.org/html/draft-josefsson-salsa20-tls-02 )

regards,
Nikos

</body></email><email><emailId>20130417115130</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-17 11:51:30-0400</timestampReceived><subject>Re: rename of salsa20r12</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Do you think that using salsa20r12 is better?

Yes.

&gt; Estream doesn't really compare with AES because estream selected 5
&gt; ciphers as winners instead of one so it cannot be given simply the
&gt; estream name (estream was the stream cipher competition, ecrypt was the
&gt; organizer).

The authorative reference on estream ciphers seems to be
http://www.ecrypt.eu.org/stream/finallist.html.

I note that it uses the name "Salsa20/12", and that the original "final"
list includes "Salsa20", which I think means the original 20-round
variant. And from reading
http://www.ecrypt.eu.org/stream/portfolio_revision1.pdf, it seems
possible that a future revision of the list might tweak the recommended
number of rounds again.

  we view the portfolio as being a snap-shot of a fast-moving field. All
  the designs in the eSTREAM portfolio are relatively immature and it is
  possible that more analysis will change the picture dramatically. With
  this in mind, we intend to maintain the eSTREAM web-pages for the
  foreseeable future and to update the portfolio as circumstances
  dictate.

So the list is volatile, which makes the "estream" name unsuitable for
algorithm identifiers.

&gt; That's why I prefer the name estream-salsa20 (and also because we used
&gt; the same name in the proposal for Salsa20
&gt; http://tools.ietf.org/html/draft-josefsson-salsa20-tls-02 )

I'd recommend making the substitition "ESTREAM_SALSA20" -&gt; "SALSA20R12"
there too.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130323192327</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-03-23 19:23:27-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd,	mpn_copyi and mpn_zero</subject><body>


On Sat, 23 Mar 2013, Martin Storsjö wrote:

&gt; ---
&gt; gmp-glue.c |   26 ++++++++++++++++++++++++++
&gt; gmp-glue.h |   26 ++++++++++++++++++++++++++
&gt; 2 files changed, 52 insertions(+)

In addition to these, a fallback is needed for mpn_sqr if building with 
GMP 4.2.1 (which people who want to stay away from LGPLv3 might want to 
do), but that one doesn't seem to be quite as trivial as these.


Additionally, I now see that eccdata.c (which is built for the build 
system, not for the target) requires GMP as well - this does complicate 
some situations where one cross-builds nettle on a system that doesn't 
have GMP installed system wide already. (E.g., cross building from OS X to 
windows, which I do regularly.) In these setups, one obviously 
cross-builds GMP for the target, but adding a step to build a local copy 
of GMP just for the build-time tools does complicate things slightly.

Or would the files produced by eccdata.c be architecture/target 
independent? In those cases, they could perhaps be included in release 
tarballs, to avoid the host-GMP-requirement when crosscompiling?

// Martin

</body></email><email><emailId>20130325085318</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-25 08:53:18-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; In addition to these, a fallback is needed for mpn_sqr if building
&gt; with GMP 4.2.1 (which people who want to stay away from LGPLv3 might
&gt; want to do), but that one doesn't seem to be quite as trivial as
&gt; these.

I guess the simplest workaround is something like

  #define mpn_sqr(rp, ap, n) mpn_mul_n((rp), (ap), (ap), (n))

IIRC, the squaring function is available also in older GMP releases,
under the name mpn_sqr_n, but it was undocumented and intended for
internal use only.

At some point, we have to abandon older GMP releases. As for supporting
GPLv2-only applications, I know that GMP developers have considered
doing GPLv2+ and LGPLv3+ dual licensing. People who have a *real*
interest in that (rather than hypotheticals like "some other people
might not like LGPLv3") should contact GMP developers and offer help and
encouragement. 

&gt; Additionally, I now see that eccdata.c (which is built for the build
&gt; system, not for the target) requires GMP [...]

&gt; Or would the files produced by eccdata.c be architecture/target
&gt; independent?

They're archtecture dependent, depending mainly on GMP_NUMB_BITS on the
target system. One option is to bundle mini-gmp, see
http://gmplib.org:8000/gmp/file/mini-gmp. Or if one is prepared to limit
the support to 32-bit and 64-bit limbs, one could generate tables for
both sizes and include in the tarballs.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130325091857</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-03-25 09:18:57-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd,	mpn_copyi and mpn_zero</subject><body>


On Mon, 25 Mar 2013, Niels Möller wrote:

&gt; Martin Storsjö &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt; In addition to these, a fallback is needed for mpn_sqr if building
&gt;&gt; with GMP 4.2.1 (which people who want to stay away from LGPLv3 might
&gt;&gt; want to do), but that one doesn't seem to be quite as trivial as
&gt;&gt; these.
&gt;
&gt; I guess the simplest workaround is something like
&gt;
&gt;  #define mpn_sqr(rp, ap, n) mpn_mul_n((rp), (ap), (ap), (n))
&gt;
&gt; IIRC, the squaring function is available also in older GMP releases,
&gt; under the name mpn_sqr_n, but it was undocumented and intended for
&gt; internal use only.

Right, thanks.

&gt; At some point, we have to abandon older GMP releases.

Yes, that's quite true. For these cases where the fallback is pretty 
simple I'd rather put off requiring the newer version thogh.

&gt; As for supporting GPLv2-only applications, I know that GMP developers 
&gt; have considered doing GPLv2+ and LGPLv3+ dual licensing. People who have 
&gt; a *real* interest in that (rather than hypotheticals like "some other 
&gt; people might not like LGPLv3") should contact GMP developers and offer 
&gt; help and encouragement.
&gt;
&gt;&gt; Additionally, I now see that eccdata.c (which is built for the build
&gt;&gt; system, not for the target) requires GMP [...]
&gt;
&gt;&gt; Or would the files produced by eccdata.c be architecture/target
&gt;&gt; independent?
&gt;
&gt; They're archtecture dependent, depending mainly on GMP_NUMB_BITS on the
&gt; target system. One option is to bundle mini-gmp, see
&gt; http://gmplib.org:8000/gmp/file/mini-gmp. Or if one is prepared to limit
&gt; the support to 32-bit and 64-bit limbs, one could generate tables for
&gt; both sizes and include in the tarballs.

Hmm, both solutions do sound pretty sensible - and thanks for the pointer 
to mini-gmp. Hooking that up during the cross-builds I mentioned should 
possibly be easier than building and installing a full GMP, even if it 
isn't included in release tarballs.

// Martin

</body></email><email><emailId>20130325092650</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-03-25 09:26:50-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

On Mon, Mar 25, 2013 at 9:53 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt; At some point, we have to abandon older GMP releases. As for supporting
&gt; GPLv2-only applications, I know that GMP developers have considered
&gt; doing GPLv2+ and LGPLv3+ dual licensing. People who have a *real*
&gt; interest in that (rather than hypotheticals like "some other people
&gt; might not like LGPLv3") should contact GMP developers and offer help and
&gt; encouragement.

Well, I feel a bit awkward now because my understanding from our
previous discussion that this was a planned move for gmp.
I believe I gave you concrete examples of projects that have issues. I
add here that my GPLv2 project [0] has issues since because of gmp it
can only be distributed under GPLv3. Feel free to forward that to any
mailing list (I don't see the point of repeating oneself though; there
have already been discussions [1], what is missing is the actual
action.)

I really don't understand what you mean about help and encouragement.
If it is about practicalities, wouldn't placing a copy of GPLv2 in the
directory and saing in a readme that you provide an exception to
distribute the library under GPLv2, be sufficient? Why would you need
to do anything more than that? If by encouragement you mean something
else could you please clarify that?

regards,
Nikos

[0]. http://www.infradead.org/ocserv/
[1]. http://gmplib.org/list-archives/gmp-devel/2011-May/001946.html

</body></email><email><emailId>20130325095705</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-25 09:57:05-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

I'm not sure I want to add a lot of compatibility code for older gmp
versions right now. I'm planning to use more new gmp function (like the
mpn_cnd_add_n which I plan to make a public gmp feature). We'll see
later what it takes to support older gmp versions.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130325103115</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-25 10:31:15-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Well, I feel a bit awkward now because my understanding from our
&gt; previous discussion that this was a planned move for gmp.

Sorry if I've been unclear. My understanding is that none of the gmp
developers have any objections, but also that all of them think they
have more interesting things to work on. (And Torbjörn himself is on a
pretty tight schedule for his PhD thesis; he can get distracted from
that by interesting GMP work (maybe too easily...) , but he will not be
distracted by anything uninteresting).

So it's been discussed, but not yet "planned" in any concrete sense. No
one has been saying "Ok, I'll get it done, it's no big deal."

&gt; I believe I gave you concrete examples of projects that have issues. I
&gt; add here that my GPLv2 project [0] has issues since because of gmp it
&gt; can only be distributed under GPLv3.

That appears to be GPLv2 or (user's option) later, (I just looked at the
header on one file, so I may have missed something). If so, this is the
first time I hear anybody having problems with GPLv2+ and LGPLv3.
Honestly.
 
&gt; I really don't understand what you mean about help and encouragement.
&gt; If it is about practicalities, wouldn't placing a copy of GPLv2 in the
&gt; directory and saing in a readme that you provide an exception to
&gt; distribute the library under GPLv2, be sufficient?

I think the recomended way
(http://www.gnu.org/prep/maintain/maintain.html#Licensing-of-GNU-Packages)
is to put a dual licensing notice in every source file. And then various
documentation files will need updating as well. So a nice script to
update all copyright notices, and a patch for relevant documentation
files, would be a great help for the practicalities.

And Simon, who iirc was the one initially driving the relicensing
discussion, has been silent for a while. I can understand if he (and you
too) has been frustrated by the lack of activity from the GMP side,
though.

&gt; If by encouragement you mean something else could you please clarify
&gt; that?

CUPS seems to be the most well-known example of a GPLv2-only program
which uses (or should use) gnutls, which then depends on gmp and nettle.
I know almost nothing about CUPS. So if GMP relicensing is required to
suit CUPS' needs, then it would be encouraging if someone who actually
*knows* CUPS (both technically and the licensing/policy issues) would
step forward and be willing to discuss it.

If we go only by third-party information, we might end up going through
a relicensing process which distracts us from real work, only to learn
later thet the CUPS maintainers decided to use openssl exclusively
anyway.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130325110525</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-03-25 11:05:25-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

On Mon, Mar 25, 2013 at 11:31 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:

&gt;&gt; I believe I gave you concrete examples of projects that have issues. I
&gt;&gt; add here that my GPLv2 project [0] has issues since because of gmp it
&gt;&gt; can only be distributed under GPLv3.
&gt; That appears to be GPLv2 or (user's option) later, (I just looked at the
&gt; header on one file, so I may have missed something). If so, this is the
&gt; first time I hear anybody having problems with GPLv2+ and LGPLv3.

Well there is first time for everything :) The issue here is that I
have chosen GPLv2+ and _not_ GPLv3+, and the license of GMP forces me
to distribute under GPLv3+. Note that GPLv2+ says, "you can distribute
under this license ... or (at your option) any later version". Now the
"at your option" part is gone and I am forced to distribute under
GPLv3+.  If I wanted to release my code under GPLv3+ I would have done
it already.

&gt; I think the recomended way
&gt; (http://www.gnu.org/prep/maintain/maintain.html#Licensing-of-GNU-Packages=
)
&gt; is to put a dual licensing notice in every source file.

I wouldn't go into that. I see the GPLv2+/LGPLv3+ dual license as a
temporal solution until FSF solves that issue either by releasing
LGPLv4 or something similar. Also you are most probably not required
to have the precise boilerplate on every file. If you see other gnu
projects (i.e. gnulib) their license terms are made explicit in the
module text files rather than the .c/h files (that typically contain a
GPLv2+ boilerplate).

&gt; CUPS seems to be the most well-known example of a GPLv2-only program
&gt; which uses (or should use) gnutls, which then depends on gmp and nettle.
&gt; I know almost nothing about CUPS. So if GMP relicensing is required to
&gt; suit CUPS' needs, then it would be encouraging if someone who actually
&gt; *knows* CUPS (both technically and the licensing/policy issues) would
&gt; step forward and be willing to discuss it.

I really don't understand what is there to discuss but please contact
them directly if you think there is something that needs to be
discussed (if you check my previous mails an the discussion in gmplib
there are more packages than CUPS with that issue). As I said I don't
care about handling the case on an individual case for each package
(that may even have already reverted to using openssl due to the long
time taken to handle the issue), but rather solving the GPLv2
incompatibility issue in gnutls.

regards,
Nikos

</body></email><email><emailId>20130327084010</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-03-27 08:40:10-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

On Mon, Mar 25, 2013 at 9:53 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; IIRC, the squaring function is available also in older GMP releases,
&gt; under the name mpn_sqr_n, but it was undocumented and intended for
&gt; internal use only.
&gt; At some point, we have to abandon older GMP releases. As for supporting
&gt; GPLv2-only applications,

I think there is benefit from Martin's patches irrespective of the
LGPL argument. The system I'm using at work has an old gmp (not for
license reasons, just an old distribution which is not up to me to
upgrade) and I needed Martin's patches in order to compile nettle.
Being able to compile nettle in older distributions is I think an
advantage.

regards,
Nikos

</body></email><email><emailId>20130402150910</emailId><senderName>Rafaël_Carré</senderName><senderEmail>funman@videolan.org</senderEmail><timestampReceived>2013-04-02 15:09:10-0400</timestampReceived><subject>Re: Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

Hello,

Le 25/03/2013 11:31, Niels Möller a écrit :
&gt; Nikos Mavrogiannopoulos \
&gt; &lt;n.mavrogiannopoulos-Re5JQEeQqe8AvxtiuMwx3w@public.gmane.org&gt; writes:

&gt; &gt; If by encouragement you mean something else could you please clarify
&gt; &gt; that?
&gt; 
&gt; CUPS seems to be the most well-known example of a GPLv2-only program
&gt; which uses (or should use) gnutls, which then depends on gmp and nettle.

We also use gnutls (and nettle, and thus gmp) in VLC media player.

While technically our code is GPLv2 or later, we would prefer to
distribute binaries under GPLv2, as stated in our press release:
http://www.videolan.org/press/2007-1.html

To remain compatible with GPLv2 we are using an old release (4.2.1)
http://git.videolan.org/?p=vlc.git;a=commitdiff;h=7e69850c6cf579dc01ff2e7c20caceef9b71867b;hp=7b3e31f94abd5b71f26ec096b78520e57cd887f4


which lacks for example compatibility with Windows 64bits, and according
to Martin Storsjö, it also gives problems on MacOSX.

I'm willing to help you with dual-licensing LGPLv3/GPLv2 as it would
very much help us on VLC.

&gt; I know almost nothing about CUPS. So if GMP relicensing is required to
&gt; suit CUPS' needs, then it would be encouraging if someone who actually
&gt; *knows* CUPS (both technically and the licensing/policy issues) would
&gt; step forward and be willing to discuss it.
&gt; 
&gt; If we go only by third-party information, we might end up going through
&gt; a relicensing process which distracts us from real work, only to learn
&gt; later thet the CUPS maintainers decided to use openssl exclusively
&gt; anyway.

Regards,


</body></email><email><emailId>20130404161519</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-04 16:15:19-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I think there is benefit from Martin's patches irrespective of the
&gt; LGPL argument. The system I'm using at work has an old gmp (not for
&gt; license reasons, just an old distribution which is not up to me to
&gt; upgrade)

Checked in now. I think I have all Martin's patches in now (let me know
if I forgot something). It would be good if you or Martin could check if
it works with older gmp releases now.

Other recent changes:

* Today, I wrote some documentation on the high-level ecc functions
  (basically, the highest level ecdsa functions and what's needed to use
  them). Comments appreciated.

* I added the ecc_point_mul and ecc_point_mul_g functions (but testcases
  missing).

* I added the salsa20r12 testvectors you sent me a while ago.

* I have arranged the ecc code to use gmp's mpn_cnd_{add,sub}_n functions
  when available (not yet in any release). Mixed benchmarking results on
  ARM; I use mpn_addmul_1 and mpn_submul_1 as fallbacks, and
  for small operands mpn_addmul_1 appears to be slightly faster than
  mpn_add_n on that machine, slowing some operations down a little.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130404163402</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-04 16:34:02-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>


On Thu, 4 Apr 2013, Niels Möller wrote:

&gt; Checked in now. I think I have all Martin's patches in now (let me know
&gt; if I forgot something). It would be good if you or Martin could check if
&gt; it works with older gmp releases now.

Didn't compile test it yet, but I rebased my local patches on top of your 
master, and it seems that the mp_bitcnt_t fallback still is missing.

// Martin

</body></email><email><emailId>20130404172818</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-04 17:28:18-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; Didn't compile test it yet, but I rebased my local patches on top of
&gt; your master, and it seems that the mp_bitcnt_t fallback still is
&gt; missing.

Ooops, I missed that one. Looking at it again now, I wonder if a
fallback is the right solution, maybe it's easier to replace all uses of
mp_bitcnt_t (it's used only for some local variables, it seems) by a
plain unsigned. Like in bignum-random-prime.c, which carries the comment

  /* Avoid the mp_bitcnt_t type for compatibility with older GMP
     versions. */

Or maybe we should use unsigned long, but I think plain unsigned should
be fine even on platforms where unsigned is 16 bits; we don't handle any
numbers beyond 65000 bits, in particular not on 16-bit platforms.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130404182210</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-04-04 18:22:10-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

On 04/04/2013 06:15 PM, Niels Möller wrote:

&gt; Checked in now. I think I have all Martin's patches in now (let me know
&gt; if I forgot something). It would be good if you or Martin could check if
&gt; it works with older gmp releases now.

&gt; * I added the ecc_point_mul and ecc_point_mul_g functions (but testcases

&gt;   missing).

Thank you. A utility function such as the attached is also quite useful.

regards,
Nikos

["patch.txt" (text/plain)]

diff --git a/ecc.h b/ecc.h
index b78e86d..07d8bc8 100644
--- a/ecc.h
+++ b/ecc.h
@@ -124,6 +124,14 @@ ecc_point_mul (struct ecc_point *r, const struct ecc_scalar *n,
 void
 ecc_point_mul_g (struct ecc_point *r, const struct ecc_scalar *n);
 
+/* Returns the size in bytes needed to store a coordinate of the curve.
+ */
+inline static unsigned
+ecc_coordinate_size (const struct ecc_curve *ecc)
+{
+	return (ecc-&gt;bit_size+7)/8;
+}
+
 
 /* Low-level interface */
   


</body></email><email><emailId>20130404195128</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-04 19:51:28-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>


On Thu, 4 Apr 2013, Niels Möller wrote:

&gt; Martin Storsjö &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt; Didn't compile test it yet, but I rebased my local patches on top of
&gt;&gt; your master, and it seems that the mp_bitcnt_t fallback still is
&gt;&gt; missing.
&gt;
&gt; Ooops, I missed that one. Looking at it again now, I wonder if a
&gt; fallback is the right solution, maybe it's easier to replace all uses of
&gt; mp_bitcnt_t (it's used only for some local variables, it seems) by a
&gt; plain unsigned. Like in bignum-random-prime.c, which carries the comment
&gt;
&gt;  /* Avoid the mp_bitcnt_t type for compatibility with older GMP
&gt;     versions. */
&gt;
&gt; Or maybe we should use unsigned long, but I think plain unsigned should
&gt; be fine even on platforms where unsigned is 16 bits; we don't handle any
&gt; numbers beyond 65000 bits, in particular not on 16-bit platforms.

Yes, this is probably easier.

And I do agree that long probably isn't needed (does nettle even run on a 
platform where the native ints are 16 bit?).

// Martin

</body></email><email><emailId>20130411192851</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-11 19:28:51-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; Didn't compile test it yet, but I rebased my local patches on top of
&gt; your master, and it seems that the mp_bitcnt_t fallback still is
&gt; missing.

I think I have replaced all uses of mp_bitcnt_t now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130417084208</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-17 08:42:08-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; On Mon, 25 Mar 2013, Niels Möller wrote:
&gt;
&gt;&gt; They're archtecture dependent, depending mainly on GMP_NUMB_BITS on the
&gt;&gt; target system. One option is to bundle mini-gmp, see
&gt;&gt; http://gmplib.org:8000/gmp/file/mini-gmp. Or if one is prepared to limit
&gt;&gt; the support to 32-bit and 64-bit limbs, one could generate tables for
&gt;&gt; both sizes and include in the tarballs.
&gt;
&gt; Hmm, both solutions do sound pretty sensible - and thanks for the
&gt; pointer to mini-gmp. Hooking that up during the cross-builds I
&gt; mentioned should possibly be easier than building and installing a
&gt; full GMP, even if it isn't included in release tarballs.

I'm about to add mini-gmp now. Should help also for native compilation,
in the case that -lgmp isn't enough for the linker to find a suitable
gmp library.

eccdata needs some tedious changes to work with mini-gmp, since it lacks
gmp_f?printf. Those calls have to be replaced by a mix of regular printf
and mpz_out_str.

(Note that mini-gmp is LGPLv3, just like recent GMP, but that shouldn't
matter for nettle users as long as mini-gmp is used only for the eccdata
program).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130416102636</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-04-16 10:26:36-0400</timestampReceived><subject>Re: Micro optimizations of the umac context structs</subject><body>

On Tue, Apr 16, 2013 at 11:55 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:

It would also be nice if we could force 16-byte alignment for the l1_key
&gt; array (this is important for assembly routines), which would them imply
&gt; 16-byte alignment for the complete context struct. Could help x86 sse2
&gt; assembly. And could help also on ARM, but I'm not sure if the system
&gt; (primarily linker and malloc) really makes 16-byte alignment possible
&gt; there.
&gt;

Would it make sense to force allocation of the context (i.e., no context on
the stack) via ctx_alloc() function that will use posix_memalign or
memalign?

Alternatively you could have a separate set of functions that would operate
on aligned data.

regards,
Nikos

</body></email><email><emailId>20130416110849</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-16 11:08:49-0400</timestampReceived><subject>Re: Micro optimizations of the umac context structs</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Would it make sense to force allocation of the context (i.e., no context on
&gt; the stack) via ctx_alloc() function that will use posix_memalign or
&gt; memalign?

I don't think so. That would be a departure from how Nettle's interfaces
currently work, "no memory allcoation".

As far as I understand, if we could tell the compiler that the structure
must be 16-byte aligned, then it should arrange that also for stack
allocated objects.

But maybe it won't be reliable. For example,

  struct some_ctx *ctx = alloca (sizeof(*ctx));

is a valid use, which depends on what alignment for alloca provides. Not
sure exactly how that would work, but the ABI typically specifies
required alignment of the stack pointer, and I suspect that (i) alloca
won't round to a larger alignment than that, and (ii) the ABIs or
relevant platforms is unlikely to specify larger alignment than 8 bytes.

Another ugly alternative would be to allocate one or a few extra
elements and align manually, something like

  uint32_t a[SIZE + 3];

  #define ALIGNED_A ((uint32t_*)(((ptrdiff_t) a + 15) &amp; -16))

But that's *too* ugly, I think.

And I'm not sure how much difference to performance it would really
make. I guess it's not worth doing unless there's a large demonstraded
gain in performance.

(And umac is not the only case where the x86 assembly files use
movups/movupd where I'd prefer to use movaps/movapd).

Regards,
/Niels
-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130416115517</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-04-16 11:55:17-0400</timestampReceived><subject>Re: Micro optimizations of the umac context structs</subject><body>

On Tue, Apr 16, 2013 at 1:08 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; Another ugly alternative would be to allocate one or a few extra
&gt; elements and align manually, something like
&gt;   uint32_t a[SIZE + 3];
&gt;   #define ALIGNED_A ((uint32t_*)(((ptrdiff_t) a + 15) &amp; -16))
&gt; But that's *too* ugly, I think.
&gt;

Indeed, from what I see I don't think there is a non-ugly solution to that
problem :)
If you want to ignore alignment you may provide aligned and unaligned
versions of the functions and let the caller cope with the alignment means.


&gt; And I'm not sure how much difference to performance it would really
&gt; make. I guess it's not worth doing unless there's a large demonstraded
&gt; gain in performance.
&gt;

The results will be very CPU-specific. If you have any benchmark or test
code, I could test on i7 and amd 64 cpus.

regards,
Nikos

</body></email><email><emailId>20130416122013</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-16 12:20:13-0400</timestampReceived><subject>Re: Micro optimizations of the umac context structs</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; On Tue, Apr 16, 2013 at 1:08 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt;&gt; And I'm not sure how much difference to performance it would really
&gt;&gt; make. I guess it's not worth doing unless there's a large demonstraded
&gt;&gt; gain in performance.
&gt;
&gt; The results will be very CPU-specific. If you have any benchmark or test
&gt; code, I could test on i7 and amd 64 cpus.

No, I don't have any good benchmark. But maybe it matters mostly for
code which is close to memory bandwidth limits.

Speaking of benchmarks, I've written some more umac assembly (not yet in
the public repo, I'll try to get it in later today).

x86_64 (Intel i5, 3.4 GHz):

         Algorithm        mode Mbyte/s
            sha256      update  286.04
            sha512      update  433.52
            umac32      update 17837.65
            umac64      update 8364.80
            umac96      update 6447.72
           umac128      update 5270.74

ARM (Cortex-A9, 1 GHz):

         Algorithm        mode Mbyte/s
            sha256      update   31.69
            sha512      update   30.38
            umac32      update  937.02
            umac64      update  464.81
            umac96      update  383.02
           umac128      update  350.13

So umac128 seems to be an order of magnitude faster than sha2. On
machines with decent multiplication performance.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130416103004</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-04-16 10:30:04-0400</timestampReceived><subject>Re: Internal vs installed headers</subject><body>

On Tue, Apr 16, 2013 at 11:43 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:

&gt; I'm considering moving some macros from macros.h (installad as
&gt; &lt;nettle/macros.h&gt;) to nettle-internal.h (not installed). Only the
&gt; various READ, WRITE and ROTL macros seem generally useful. Comments?
&gt;

I use some of these macros in gnutls (in the via padlock code). I think
they are the MD_* ones. If you remove them I'll have to duplicate them.

regards,
Nikos

</body></email><email><emailId>20130416111239</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-16 11:12:39-0400</timestampReceived><subject>Re: Internal vs installed headers</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; I use some of these macros in gnutls (in the via padlock code). I think
&gt; they are the MD_* ones. If you remove them I'll have to duplicate them.

I see. I'll leave them in for now. If we ever have to make any
incompatible changes to those macros, we can reconsider moving them.

BTW, with the gnutls padlock code, would it work to use nettle's struct
sha1_ctx with a different _sha1_compress?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130416114024</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-04-16 11:40:24-0400</timestampReceived><subject>Re: Internal vs installed headers</subject><body>

On Tue, Apr 16, 2013 at 1:12 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; &gt; I use some of these macros in gnutls (in the via padlock code). I think
&gt; &gt; they are the MD_* ones. If you remove them I'll have to duplicate them.
&gt; I see. I'll leave them in for now. If we ever have to make any
&gt; incompatible changes to those macros, we can reconsider moving them.
&gt; BTW, with the gnutls padlock code, would it work to use nettle's struct
&gt; sha1_ctx with a different _sha1_compress?
&gt;

I believe that's what I am doing, and that's why I found those macros quite
useful.
https://gitorious.org/gnutls/gnutls/blobs/master/lib/accelerated/x86/sha-pa=
dlock.c

regards,
Nikos

</body></email><email><emailId>20130416193324</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-16 19:33:24-0400</timestampReceived><subject>Re: Micro optimizations of the umac context structs</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Speaking of benchmarks, I've written some more umac assembly (not yet in
&gt; the public repo, I'll try to get it in later today).

Pushed in now. I also updated
http://www.lysator.liu.se/~nisse/nettle/plan.html

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130417120319</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-17 12:03:19-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd,	mpn_copyi and mpn_zero</subject><body>


On Wed, 17 Apr 2013, Niels Möller wrote:

&gt; Martin Storsjö &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt; On Mon, 25 Mar 2013, Niels Möller wrote:
&gt;&gt;
&gt;&gt;&gt; They're archtecture dependent, depending mainly on GMP_NUMB_BITS on the
&gt;&gt;&gt; target system. One option is to bundle mini-gmp, see
&gt;&gt;&gt; http://gmplib.org:8000/gmp/file/mini-gmp. Or if one is prepared to limit
&gt;&gt;&gt; the support to 32-bit and 64-bit limbs, one could generate tables for
&gt;&gt;&gt; both sizes and include in the tarballs.
&gt;&gt;
&gt;&gt; Hmm, both solutions do sound pretty sensible - and thanks for the
&gt;&gt; pointer to mini-gmp. Hooking that up during the cross-builds I
&gt;&gt; mentioned should possibly be easier than building and installing a
&gt;&gt; full GMP, even if it isn't included in release tarballs.
&gt;
&gt; I'm about to add mini-gmp now. Should help also for native compilation,
&gt; in the case that -lgmp isn't enough for the linker to find a suitable
&gt; gmp library.

Great, that sounds promising, and will absolutely help a lot in at least 
two setups I know of.

&gt; eccdata needs some tedious changes to work with mini-gmp, since it lacks
&gt; gmp_f?printf. Those calls have to be replaced by a mix of regular printf
&gt; and mpz_out_str.
&gt;
&gt; (Note that mini-gmp is LGPLv3, just like recent GMP, but that shouldn't
&gt; matter for nettle users as long as mini-gmp is used only for the eccdata
&gt; program).

Yes, this shouldn't be an issue.

// Martin

</body></email><email><emailId>20130417121258</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-04-17 12:12:58-0400</timestampReceived><subject>Re: rename of salsa20r12</subject><body>

On Wed, Apr 17, 2013 at 1:51 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; The authorative reference on estream ciphers seems to be
&gt; http://www.ecrypt.eu.org/stream/finallist.html.
The latest report is from 2012 at:
http://www.ecrypt.eu.org/documents/D.SYM.10-v1.pdf

It still lists the Salsa20/12 in the cipher list.

&gt; I'd recommend making the substitition "ESTREAM_SALSA20" -&gt; "SALSA20R12"
&gt; there too.

I don't find the SALSA20R12 a reasonable name, it contains far too
many numbers that may mean something to me and you but mean nothing to
anyone else (and thus cannot be memorized). Estream-salsa20 is far
more simple, and as I previously mentioned it automatically justifies
the reason and need for the variant. It is the variant chosen by the
estream project when it finished in sept. 2008. Yes they said they may
update the list, as sha1 was replaced by sha2 and later sha3. However,
sha1 is still called sha1 :)

regards,
Nikos

</body></email><email><emailId>20130418143306</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-18 14:33:06-0400</timestampReceived><subject>[PATCH] Fix a typo in a comment</subject><body>

---
 aclocal.m4 |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/aclocal.m4 b/aclocal.m4
index 0d24fc2..98b399b 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -610,8 +610,8 @@ AC_SUBST(EXEEXT_FOR_BUILD,$gmp_cv_prog_exeext_for_build)
 
 dnl NETTLE_CHECK_ARM_NEON
 dnl ---------------------
-dnl Check if ARM Neon instructinos should be used.
-dnl Obeys enable_arn_neon, which should be set earlier.
+dnl Check if ARM Neon instructions should be used.
+dnl Obeys enable_arm_neon, which should be set earlier.
 AC_DEFUN([NETTLE_CHECK_ARM_NEON],
 [if test "$enable_arm_neon" = auto ; then
   if test "$cross_compiling" = yes ; then
-- 
1.7.9.4


</body></email><email><emailId>20130420195257</emailId><senderName>Shaun Murphy</senderName><senderEmail>shaunmurphy@outlook.com</senderEmail><timestampReceived>2013-04-20 19:52:57-0400</timestampReceived><subject>=?windows-1256?Q?Support_fo?= =?windows-1256?Q?r_via_quad?= =?windows-1256?Q?core_SHA51?= =?windows-</subject><body>

The limited literature for the newer VIA QuadCore E-Series embedded platform says \
that it now supports "Secure Hash Algorithm: SHA-1, SHA-256, SHA-384, SHA-512" but \
I'm not seeing any acceleration for SHA512 in the kernel modules or nettle / gnutls. \
I would appreciate some pointers on what I need to do to access that SHA512 \
acceleration in nettle. Here's my setup:Via Artigo A1250 Ubuntu 12.04 x86_64Gnutls - \
built from git Nettle - built from 2.6 source Kernel modules: padlock_aes, \
padlock_sha Here's my dmesg output for the loaded modules:[    2.345061] padlock_aes: \
Using VIA PadLock ACE for AES algorithm.[    2.364105] padlock_sha: Using VIA PadLock \
ACE for SHA1/SHA256 algorithms. gnutls Benchmark Soft Ciphers:Checking SHA1 (16kb \
payload)...  Processed 464.73 MB in 5.00 secs: 92.95 MB/secChecking SHA256 (16kb \
payload)...  Processed 180.04 MB in 5.00 secs: 36.01 MB/secChecking SHA512 (16kb \
payload)...  Processed 267.39 MB in 5.00 secs: 53.48 MB/sec gnutls Benchmark \
Ciphers:Checking SHA1 (16kb payload)...  Processed 1.51 GB in 5.00 secs: 0.30 \
GB/secChecking SHA256 (16kb payload)...  Processed 1.30 GB in 5.00 secs: 0.26 \
GB/secChecking SHA512 (16kb payload)...  Processed 267.45 MB in 5.00 secs: 53.49 \
MB/sec The SHA256 numbers are great but I really need SHA512 for my application.
Thank you. 		 	   		  


</body></email><email><emailId>20130421081924</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-21 08:19:24-0400</timestampReceived><subject>Re: Support for via quadcore SHA512 hw =?utf-8?Q?acceleration?= =?utf-8?Q?=E2=80=8F?=</subject><body>

Shaun Murphy &lt;shaunmurphy@outlook.com&gt; writes:

&gt; The limited literature for the newer VIA QuadCore E-Series embedded
&gt; platform says that it now supports "Secure Hash Algorithm: SHA-1,
&gt; SHA-256, SHA-384, SHA-512" but I'm not seeing any acceleration for
&gt; SHA512 in the kernel modules or nettle / gnutls.

I think the optimizations you are looking at are in gnutls. Nettle
itself only includes pretty generic x86_64 assembly for these
algorithms. (Support for special code for certain processors, and
runtime selection of the best routines, is desirable, but will most
likely not be implemented soon).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130421144614</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-21 14:46:14-0400</timestampReceived><subject>Re: ARM/NEON optimizations</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; On which algorithms are the neon instructions used?

sha512, sha3, salsa20 and umac.

They make a big difference for sha512 and sha3, since they depend a lot
on 64-bit operations. For umac, it would make some sense to also write
some non-neon ARM assembly, using the umaal instruction as the main work
horse.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130423111949</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-23 11:19:49-0400</timestampReceived><subject>[PATCH 1/2] Consistently use EXEEXT_FOR_BUILD</subject><body>

This fixes cross building for cases where EXEEXT differs from
EXEEXT_FOR_BUILD, such as when building for windows from unix.
---
 Makefile.in |   19 ++++++++++---------
 1 file changed, 10 insertions(+), 9 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index c96e3a3..cbc001c 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -31,8 +31,9 @@ getopt_TARGETS = $(getopt_SOURCES:.c=.$(OBJEXT))
 internal_SOURCES = nettle-internal.c
 internal_TARGETS = $(internal_SOURCES:.c=.$(OBJEXT))
 
-TARGETS = aesdata$(EXEEXT) desdata$(EXEEXT) twofishdata$(EXEEXT) \
-	  shadata$(EXEEXT) gcmdata$(EXEEXT) \
+TARGETS = aesdata$(EXEEXT_FOR_BUILD) desdata$(EXEEXT_FOR_BUILD) \
+          twofishdata$(EXEEXT_FOR_BUILD) shadata$(EXEEXT_FOR_BUILD) \
+          gcmdata$(EXEEXT_FOR_BUILD) \
 	  $(getopt_TARGETS) $(internal_TARGETS) \
 	  $(LIBTARGETS) $(SHLIBTARGETS)
 IMPLICIT_TARGETS = @IF_DLL@ $(LIBNETTLE_FILE) $(LIBHOGWEED_FILE)
@@ -273,7 +274,7 @@ des.$(OBJEXT): des.c des.h $(des_headers)
 #	k =  7, c = 6, 320 entries, ~15 KB
 #	k =  9, c = 7, 512 entries, ~24 KB
 ecc-192.h: eccdata.stamp
-	./eccdata$(EXEEXT) 192 7 6 $(GMP_NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+	./eccdata$(EXEEXT_FOR_BUILD) 192 7 6 $(GMP_NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 # Some possible choices for 224:
 #	k = 18, c = 4,  64 entries,  ~4 KB
 #	k = 24, c = 6, 128 entries,  ~8 KB
@@ -281,7 +282,7 @@ ecc-192.h: eccdata.stamp
 #	k =  8, c = 6, 320 entries, ~20 KB
 #	k = 10, c = 7, 512 entries, ~32 KB
 ecc-224.h: eccdata.stamp
-	./eccdata$(EXEEXT) 224 12 6 $(GMP_NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+	./eccdata$(EXEEXT_FOR_BUILD) 224 12 6 $(GMP_NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 # Some possible choices for 256:
 #	k = 20, c = 4,  64 entries,  ~4 KB
 #	k = 27, c = 6, 128 entries,  ~8 KB
@@ -289,7 +290,7 @@ ecc-224.h: eccdata.stamp
 #	k =  9, c = 6, 320 entries, ~20 KB
 #	k = 12, c = 7, 512 entries, ~32 KB
 ecc-256.h: eccdata.stamp
-	./eccdata$(EXEEXT) 256 14 6 $(GMP_NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+	./eccdata$(EXEEXT_FOR_BUILD) 256 14 6 $(GMP_NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 # Some possible choices for 384:
 #	k = 31, c = 4,  64 entries,  ~6 KB
 #	k = 41, c = 6, 128 entries, ~12 KB
@@ -297,7 +298,7 @@ ecc-256.h: eccdata.stamp
 #	k = 14, c = 6, 320 entries, ~30 KB
 #	k = 18, c = 7, 512 entries, ~48 KB
 ecc-384.h: eccdata.stamp
-	./eccdata$(EXEEXT) 384 41 6 $(GMP_NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+	./eccdata$(EXEEXT_FOR_BUILD) 384 41 6 $(GMP_NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 # Some possible choices for 521:
 #	k = 42, c = 4,  64 entries,  ~9 KB
 #	k = 56, c = 6, 128 entries, ~18 KB
@@ -305,10 +306,10 @@ ecc-384.h: eccdata.stamp
 #	k = 19, c = 6, 320 entries, ~44 KB
 #	k = 24, c = 7, 512 entries, ~70 KB
 ecc-521.h: eccdata.stamp
-	./eccdata$(EXEEXT) 521 56 6 $(GMP_NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+	./eccdata$(EXEEXT_FOR_BUILD) 521 56 6 $(GMP_NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 eccdata.stamp: eccdata.c
-	$(MAKE) eccdata$(EXEEXT)
+	$(MAKE) eccdata$(EXEEXT_FOR_BUILD)
 	echo stamp &gt; eccdata.stamp
 
 ecc-192.$(OBJEXT): ecc-192.h
@@ -575,7 +576,7 @@ distcheck: dist
 clean-here:
 	-rm -f $(TARGETS) $(IMPLICIT_TARGETS) *.$(OBJEXT) *.p$(OBJEXT) *.s \
 		ecc-192.h ecc-224.h ecc-256.h ecc-384.h ecc-521.h \
-		eccdata$(EXEEXT) eccdata.stamp
+		eccdata$(EXEEXT_FOR_BUILD) eccdata.stamp
 	-rm -rf .lib
 
 distclean-here: clean-here
-- 
1.7.9.4


</body></email><email><emailId>20130423111950</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-23 11:19:50-0400</timestampReceived><subject>[PATCH 2/2] Ignore the umac-test binary</subject><body>

---
 testsuite/.gitignore |    1 +
 1 file changed, 1 insertion(+)

diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index 642d8c4..3b836af 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -63,6 +63,7 @@
 /sha384-test
 /sha512-test
 /twofish-test
+/umac-test
 /yarrow-test
 
 /test.in
-- 
1.7.9.4


</body></email><email><emailId>20130423141244</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-23 14:12:44-0400</timestampReceived><subject>[PATCH 1/2] Use movdqu instead of movdqa for saving xmm registers</subject><body>

The stack is not guaranteed to be 16-byte aligned on win64.
---
 x86_64/machine.m4 |   40 ++++++++++++++++++++--------------------
 1 file changed, 20 insertions(+), 20 deletions(-)

diff --git a/x86_64/machine.m4 b/x86_64/machine.m4
index dc23dde..d5d5b37 100644
--- a/x86_64/machine.m4
+++ b/x86_64/machine.m4
@@ -71,34 +71,34 @@ define(&lt;W64_ENTRY&gt;, &lt;
   ifelse(W64_ABI,yes,[
     ifelse(eval($2 &gt; 6), 1, [
       sub	[$]eval(8 + 16*($2 - 6)), %rsp
-      movdqa	%xmm6, 0(%rsp)
+      movdqu	%xmm6, 0(%rsp)
     ])
     ifelse(eval($2 &gt; 7), 1, [
-      movdqa	%xmm7, 16(%rsp)
+      movdqu	%xmm7, 16(%rsp)
     ])
     ifelse(eval($2 &gt; 8), 1, [
-      movdqa	%xmm8, 32(%rsp)
+      movdqu	%xmm8, 32(%rsp)
     ])
     ifelse(eval($2 &gt; 9), 1, [
-      movdqa	%xmm9, 48(%rsp)
+      movdqu	%xmm9, 48(%rsp)
     ])
     ifelse(eval($2 &gt; 10), 1, [
-      movdqa	%xmm10, 64(%rsp)
+      movdqu	%xmm10, 64(%rsp)
     ])
     ifelse(eval($2 &gt; 11), 1, [
-      movdqa	%xmm11, 80(%rsp)
+      movdqu	%xmm11, 80(%rsp)
     ])
     ifelse(eval($2 &gt; 12), 1, [
-      movdqa	%xmm12, 96(%rsp)
+      movdqu	%xmm12, 96(%rsp)
     ])
     ifelse(eval($2 &gt; 13), 1, [
-      movdqa	%xmm13, 112(%rsp)
+      movdqu	%xmm13, 112(%rsp)
     ])
     ifelse(eval($2 &gt; 14), 1, [
-      movdqa	%xmm14, 128(%rsp)
+      movdqu	%xmm14, 128(%rsp)
     ])
     ifelse(eval($2 &gt; 15), 1, [
-      movdqa	%xmm15, 144(%rsp)
+      movdqu	%xmm15, 144(%rsp)
     ])
     ifelse(eval($1 &gt;= 1), 1, [
       push	%rdi
@@ -133,34 +133,34 @@ define(&lt;W64_EXIT&gt;, &lt;
       pop	%rdi
     ])
     ifelse(eval($2 &gt; 15), 1, [
-      movdqa	144(%rsp), %xmm15
+      movdqu	144(%rsp), %xmm15
     ])
     ifelse(eval($2 &gt; 14), 1, [
-      movdqa	128(%rsp), %xmm14
+      movdqu	128(%rsp), %xmm14
     ])
     ifelse(eval($2 &gt; 13), 1, [
-      movdqa	112(%rsp), %xmm13
+      movdqu	112(%rsp), %xmm13
     ])
     ifelse(eval($2 &gt; 12), 1, [
-      movdqa	96(%rsp), %xmm12
+      movdqu	96(%rsp), %xmm12
     ])
     ifelse(eval($2 &gt; 11), 1, [
-      movdqa	80(%rsp), %xmm11
+      movdqu	80(%rsp), %xmm11
     ])
     ifelse(eval($2 &gt; 10), 1, [
-      movdqa	64(%rsp), %xmm10
+      movdqu	64(%rsp), %xmm10
     ])
     ifelse(eval($2 &gt; 9), 1, [
-      movdqa	48(%rsp), %xmm9
+      movdqu	48(%rsp), %xmm9
     ])
     ifelse(eval($2 &gt; 8), 1, [
-      movdqa	32(%rsp), %xmm8
+      movdqu	32(%rsp), %xmm8
     ])
     ifelse(eval($2 &gt; 7), 1, [
-      movdqa	16(%rsp), %xmm7
+      movdqu	16(%rsp), %xmm7
     ])
     ifelse(eval($2 &gt; 6), 1, [
-      movdqa	0(%rsp), %xmm6
+      movdqu	0(%rsp), %xmm6
       add	[$]eval(8 + 16*($2 - 6)), %rsp
     ])
   ])
-- 
1.7.9.5


</body></email><email><emailId>20130423141245</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-23 14:12:45-0400</timestampReceived><subject>[PATCH 2/2] salsa20: Don't return via W64_EXIT within the Lpartial subfunction</subject><body>

The Lpartial subfunction is entered with plain call instructions,
and the win64 epilogue should only run when actually exiting the
whole salsa20_crypt function.
---
 x86_64/salsa20-crypt.asm |    5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/x86_64/salsa20-crypt.asm b/x86_64/salsa20-crypt.asm
index 25b7e49..9d1b53d 100644
--- a/x86_64/salsa20-crypt.asm
+++ b/x86_64/salsa20-crypt.asm
@@ -224,10 +224,11 @@ PROLOGUE(nettle_salsa20_crypt)
 	shr	$16, XREG(T64)
 .Llt2:
 	test	$1, LENGTH
-	jz	.Lend
+	jz	.Lret
 	xor	(SRC, POS), LREG(T64)
 	mov	LREG(T64), (DST, POS)
 
-	jmp	.Lend
+.Lret:
+	ret
 
 EPILOGUE(nettle_salsa20_crypt)
-- 
1.7.9.5


</body></email><email><emailId>20130423145459</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-23 14:54:59-0400</timestampReceived><subject>[PATCH 1/2] sha: Add the missing W64_EXIT epilogue macro</subject><body>

---
 x86_64/sha256-compress.asm |    1 +
 x86_64/sha512-compress.asm |    1 +
 2 files changed, 2 insertions(+)

diff --git a/x86_64/sha256-compress.asm b/x86_64/sha256-compress.asm
index 6bfb7a7..385654c 100644
--- a/x86_64/sha256-compress.asm
+++ b/x86_64/sha256-compress.asm
@@ -192,5 +192,6 @@ PROLOGUE(_nettle_sha256_compress)
 	mov	112(%rsp),%r15
 
 	add	$120, %rsp
+	W64_EXIT(3, 0)
 	ret
 EPILOGUE(_nettle_sha256_compress)
diff --git a/x86_64/sha512-compress.asm b/x86_64/sha512-compress.asm
index 21df82a..663e68e 100644
--- a/x86_64/sha512-compress.asm
+++ b/x86_64/sha512-compress.asm
@@ -192,5 +192,6 @@ PROLOGUE(_nettle_sha512_compress)
 	mov	176(%rsp),%r15
 
 	add	$184, %rsp
+	W64_EXIT(3, 0)
 	ret
 EPILOGUE(_nettle_sha512_compress)
-- 
1.7.9.5


</body></email><email><emailId>20130423145500</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-23 14:55:00-0400</timestampReceived><subject>[PATCH 2/2] win64: Correctly read the fifth parameter from the stack if we've pushed xmm registers</subject><body>

This fixes the umac test on win64.
---
 x86_64/machine.m4 |    8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/x86_64/machine.m4 b/x86_64/machine.m4
index d5d5b37..b9556a2 100644
--- a/x86_64/machine.m4
+++ b/x86_64/machine.m4
@@ -67,7 +67,7 @@ define(&lt;XREG&gt;,&lt;ifelse(
 dnl W64_ENTRY(nargs, xmm_used)
 define(&lt;W64_ENTRY&gt;, &lt;
   changequote([,])dnl
-  ifelse(&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ignored; only for balancing)
+  ifelse(&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ignored; only for balancing)
   ifelse(W64_ABI,yes,[
     ifelse(eval($2 &gt; 6), 1, [
       sub	[$]eval(8 + 16*($2 - 6)), %rsp
@@ -115,7 +115,11 @@ define(&lt;W64_ENTRY&gt;, &lt;
       mov	%r9, %rcx
     ])
     ifelse(eval($1 &gt;= 5), 1, [
-      mov	56(%rsp), %r8
+      ifelse(eval($2 &gt; 6), 1, [
+        mov	eval(8 + 16*($2 - 6) + 56)(%rsp), %r8
+      ], [
+        mov	56(%rsp), %r8
+      ])
     ])
   ])
   changequote(&lt;,&gt;)dnl
-- 
1.7.9.5


</body></email><email><emailId>20130424120140</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-04-24 12:01:40-0400</timestampReceived><subject>Re: nettle-2.7 release candidate</subject><body>


On Tue, 23 Apr 2013, Niels Möller wrote:

&gt; Martin Storsjö &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt; Hmm, yes, I think that might have been the case. So since we can't
&gt;&gt; rely on that being aligned anyway, we could just as well skip the 8
&gt;&gt; byte offset.
&gt;
&gt; If it works now, I don't think we should touch this code further before
&gt; release.

Yes, that's probably wisest.

&gt; For later optimization (if it really makes a difference to performance
&gt; if we use aligned or unaligned loads and stores here? I don't know),
&gt; one could keep the 8 byte extra allocation, then do something like
&gt;
&gt; 	lea	8(%rsp), %r10
&gt;        and	$-16, %r10
&gt;
&gt; (%r10 should always be free for scratch use at both entry and exit,
&gt; right?). Then %r10 will be 16 byte aligned, and hold either %rsp or %rsp
&gt; + 8. And we can then do fully aligned loads and stores of the xmm
&gt; registers via offsets from %r10.

That would probably work. I don't know these things well enough to say 
whether there's any serious performance to be gained by doing this, 
compared to the inconvenience of wasting one register.

// Martin

</body></email><email><emailId>20130424141740</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-24 14:17:40-0400</timestampReceived><subject>ANNOUNCE: Nettle-2.7</subject><body>

I'm happy to annnounce a new version of GNU Nettle, a low-level
cryptographics library. The Nettle home page can be found at
http://www.lysator.liu.se/~nisse/nettle/.

NEWS for the 2.7 release

	This release includes an implementation of elliptic curve
	cryptography (ECC) and optimizations for the ARM architecture.
	This work was done at the offices of South Pole AB, and
	generously funded by the .SE Internet Fund.

	Bug fixes:

	* Fixed a bug in the buffer handling for incremental SHA3
	  hashing, with a possible buffer overflow. Patch by Edgar
	  E. Iglesias.

	New features:

	* Support for ECDSA signatures. Elliptic curve operations over
	  the following curves: secp192r1, secp224r1, secp256r1,
	  secp384r1 and secp521r1, including x86_64 and ARM assembly
	  for the most important primitives.
	  
	* Support for UMAC, including x86_64 and ARM assembly.

	* Support for 12-round salsa20, "salsa20r12", as specified by
	  eSTREAM. Contributed by Nikos Mavrogiannopoulos.
	
	Optimizations:

	* ARM assembly code for several additional algorithms,
	  including AES, Salsa20, and the SHA family of hash
	  functions. 

	* x86_64 assembly for SHA256, SHA512, and SHA3. (SHA3 assembly
          was included in the 2.6 release, but disabled due to poor
          performance on some AMD processors. Hopefully, that
          performance problem is fixed now).
	
	The ARM code was tested and benchmarked on Cortex-A9. Some of
	the functions use "neon" instructions. The configure script
	decides if neon instructions can be used, and the command line
	options --enable-arm-neon and --disable-arm-neon can be used
	to override its choice. Feedback appreciated.
	  
	The libraries are intended to be binary compatible with
	nettle-2.2 and later. The shared library names are
	libnettle.so.4.6 and libhogweed.so.2.4, with sonames still
	libnettle.so.4 and libhogweed.so.2.

  http://ftp.gnu.org/gnu/nettle/nettle-2.7.tar.gz
  ftp://ftp.gnu.org/gnu/nettle/nettle-2.7.tar.gz
  http://www.lysator.liu.se/~nisse/archive/nettle-2.7.tar.gz
  ftp://ftp.lysator.liu.se/pub/security/lsh/nettle-2.7.tar.gz (soon)

Happy hacking,
/Niels Möller

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130425112432</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-04-25 11:24:32-0400</timestampReceived><subject>Re: Switching to size_t (was: Re: Release plans)</subject><body>

On Thu, Apr 25, 2013 at 10:44 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:
&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt;&gt; Re the 3.0 plans, it seems that making a 3.0 release that implement the
&gt;&gt; first two items on the list (unsigned-&gt;size_t, memxor namespace) would
&gt;&gt; be possible to achieve relatively soon with modest investment in work.
&gt; I've done the memxor thing now, and I'm looking into size_t. When
&gt; switching to size_t, should we use it for *all* lengths, or only all
&gt; lengths which potentially are large? For an example, consider aes.h:
&gt; I think it's clear that we ought to switch to size_t for
&gt;   void
&gt;   aes_encrypt(const struct aes_ctx *ctx,
&gt;             unsigned length, uint8_t *dst,
&gt;             const uint8_t *src);

Is this the only reason to break binary compatibility? If yes I'd say
delay that change until there is another more important reason to
break compatibility. GnuTLS 3.x broke compatibility with 2.12.x and
hasn't been included in most distributions yet, 2 years after its
release.

On the practical side, I don't think switching unsigned to size_t in
cryptographic functions would buy much, and would actually occupy 4
more bytes on the stack on 64-bit systems. There aren't many
applications (that I'm aware of) that require more than 4GB of
encrypted data in a single run. Even if there are, it is much simpler
(and memory efficient) to break the encryption in chunks, and as far
as I remember some encryption modes (I think it was in-place cbc)
allocate memory equal to input size, which make them anyway unsuitable
for such large sizes.

regards,
Nikos

</body></email><email><emailId>20130427204547</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-27 20:45:47-0400</timestampReceived><subject>Re: Problems when compiling 32bit version on 64bit host (multilib)</subject><body>

Florian Pritz &lt;bluewind@xinu.at&gt; writes:

&gt; Here[1] is the output of make, make check along with the PKGBUILD used
&gt; to build this and a sample of the generated ecc-*.h files.
&gt;
&gt; [1]: http://flo.server-speed.net/tmp/lib32-nettle/

Not entirely sure what's happening, but I suspect something is wrong
with your GMP installation. I take it you configure nettle with CC='gcc
-m32'? Nettle's configure detects that you are building for the 32-bit
ABI. But then the test

  checking for GMP limb size... 64 bits

indicates that you are using a gmp.h for a 64-bit installation. Also the warning

  ecc-mod.c:48:3: warning: left shift count &gt;= width of type [enabled by default]
     if (bp[bn-1] &lt; ((mp_limb_t) 1 &lt;&lt; (GMP_NUMB_BITS - 1)))

indicates that the definitions of mp_limb_t and GMP_NUMB_BITS (both in
gmp.h) are inconsistent. So you probably have a gmp.h with

  typedef unsigned long mp_limb_t;
  #define GMP_LIMB_BITS 64
  #define GMP_NUMB_BITS 64

which is typical for a 64-bit installation of GMP, but is bogus if
unsigned long is only 32 bits.

Maybe you can fix it by setting CPPFLAGS (or passing the
--with-include-path option to Nettle's configure) to point out a
directory with a 32-bit installation of the gmp.h header file.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130427210222</emailId><senderName>Florian Pritz</senderName><senderEmail>bluewind@xinu.at</senderEmail><timestampReceived>2013-04-27 21:02:22-0400</timestampReceived><subject>[SOLVED] Re: Problems when compiling 32bit version on 64bit host (multilib)</subject><body>


On 27.04.2013 22:45, Niels Möller wrote:
&gt; indicates that you are using a gmp.h for a 64-bit installation.
&gt; [..]
&gt; 
&gt; Maybe you can fix it by setting CPPFLAGS (or passing the
&gt; --with-include-path option to Nettle's configure) to point out a
&gt; directory with a 32-bit installation of the gmp.h header file.

Adding --with-include-path=/usr/lib32/gmp worked like a charm.

Thank you very much



["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20130429062856</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-29 06:28:56-0400</timestampReceived><subject>Re: Switching to size_t</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I think it would make some sense to adopt the principle that key sizes
&gt; use unsigned (since keys by definition are small objects), and message
&gt; sizes use size_t.

I'm now leaning towards using size_t also for all function arguments
which are key sizes. There should be no performance penalty in most
cases, and very small penalty also when arguments are passed on the
stack. And it may reduce warnings about truncation to smaller type if
one passes, e.g, the output of strlen. I'll stick to unsigned in struct
nettle_cipher and some of the internal functions, though.

I created the branch size_t-changes, now available also in the public
repo. I think I have converted everything except the unfinished openpgp
code.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130429113307</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-04-29 11:33:07-0400</timestampReceived><subject>Re: AEs interface (was: Re: Switching to size_t)</subject><body>

On Mon, Apr 29, 2013 at 9:41 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; Does that make sense? My impression is that most applications and
&gt; protocols typically treat AES128 and AES256 as different algorithms, and
&gt; have little use for an interface where the same function accepts a
&gt; variable key size.

At least for gnutls, that's looks fine.

regards,
Nikos

</body></email><email><emailId>20130430133305</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-04-30 13:33:05-0400</timestampReceived><subject>raspberry pi</subject><body>

I finally got a Raspberry Pi setup. Took almost 20 minutes to compile
nettle, and the configure script figured out not to use neon
instructions. It passes the testsuite. Benchmark for the public key
functions:

           name size   sign/ms verify/ms
            rsa 1024    0.1073    1.9099
            rsa 2048    0.0167    0.5539
            dsa 1024    0.1992    0.1014
          ecdsa  192    0.5297    0.1922
          ecdsa  224    0.3623    0.1354
          ecdsa  256    0.2621    0.0971
          ecdsa  384    0.1125    0.0391
          ecdsa  521    0.0551    0.0190

So 3 to 5 times slower than the pandaboard (although that's not a
completely fair comparison, since the raspberry pi is using gmp-5.0.5,
not the gmp bleeding edge).

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130305134855</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-05 13:48:55-0400</timestampReceived><subject>ECC status update for February</subject><body>

Here's a copy of the second status update, which I just submitted to
Internetfonden.

Regards,
/Niels

Nettle project funded by Internetfonden

Status update for February 2013


* Summary

New ECC code integrated in the Nettle repository. The code has been
optimized with respect to both storage and computation requirements.


* Activities

Most of the time in February has been spent on the ECC code, both
optimization, and integration work. The ECC code has been integrated
into Nettle, including a preliminary high-level interface for ECDSA
signatures. The code is available in the branch "ecc-support" in the
repository at git://git.lysator.liu.se/nettle/nettle.git.

Final days and first days of February have been used to implement the
most important curve-specific functions in ARM assembly. Independently
if the ECC support, also the function memxor has been optimized for
ARM.

During the month, roughly 120 working hours have been spent on the
project.


* Elliptic curves

Point multiplication involving an arbitrary point now uses a
side-channel silent window based algorithm. This gave a speedup of
around 30% for ECDSA signature verification.

For each curve, arithmetic on the coordinates is done modulo a curve
specific prime number, e.g., p = 2^192 - 2^64 + 1 for the curve
"secp-192r1", and p = 2^224 - 2^96 - 1 for the curve "secp-224r1".
These primes all have special structure, which can be used to speed up
the modp operation following each multiplication of two coordinates.
Since the key operation is add with carry, which is poorly supported
by the C programming language, writing these functions in assembly is
attractive. Reducing a 384 bit number, typically the product of two
192-bit numbers, modulo the 192-bit prime above can be done with 12
add with carry instructions on the x86_64 architecture, or 26 on the
32-bit ARM.

ARM assembly implementation gave a speedup of 2-4 times of the modulo
operations, corresponding to a speedup around 50% for ECDSA sign and
verify operations.

The functions for doing ECC point addition have also been optimized to
reduce the amount of temporary storage. E.g, with the current code,
ECDSA signatures over the curve secp-256r1 requires 384 bytes of
temporary storage for signing, and 2080 bytes to verify a signature.

A few operations did not use side-channel silent algorithms earlier.
These have been replaced by side-channel silent versions, which causes
some slowdown. In particular, the side-channel silent modular
inversion is very slow.

Benchmarks, as of March 5, including changes relative the the numbers
in the previous status report:

Intel i5, 3.4 GHz:

           name size   sign/ms      verify/ms
            rsa 1024    6.3299       105.0161
            rsa 2048    0.9573        29.5316
            dsa 1024   11.1947         5.7647
          ecdsa  192   18.1878 +1.4%   6.2035 +64%
          ecdsa  224    8.9302 -11%    2.8714 +41%
          ecdsa  256    8.1958 -13%    2.6707 +20%
          ecdsa  384    3.1515 -10%    0.9866 +25%
          ecdsa  521    1.8874 -13%    0.6858 +30%
ecdsa (openssl)  224    3.4829         3.0458
ecdsa (openssl)  384    1.4516         1.2711
ecdsa (openssl)  521    0.6855         0.5831

ARM Cortex A9, 1 GHz:

           name size   sign/ms      verify/ms
            rsa 1024    0.2634         4.5464
            rsa 2048    0.0392         1.2481
            dsa 1024    0.4688         0.2381
          ecdsa  192    1.2303 -4.5%   0.4318 +50%
          ecdsa  224    0.8526 +8.5%   0.3075 +72%
          ecdsa  256    0.6286 +6.5%   0.2243 +75%
          ecdsa  384    0.2532 +4.5%   0.0876 +61%
          ecdsa  521    0.1319 -0.6%   0.0448 +51%
ecdsa (openssl)  224    0.1843         0.1563
ecdsa (openssl)  384    0.0693         0.0589
ecdsa (openssl)  521    0.0259         0.0214

So in these benchmarks, the net effect of the development is a great
improvement of the speed of signature verification, with more mixed
results for signature creation.

For comparison, the benchmark also includes figures for the ECDSA
functions provided by the OpenSSL library (for the three curves
supported by both Nettle and OpenSSL). On x86_64, signing is 2.2 --
2.8 times faster than OpenSSL, and verification is from 22% slower to
18% faster. On ARM, signature performance is 3.6 -- 5 times faster,
and verify performance is 1.5 -- 2 times faster.

Speaking of benchmarks, the ARM assembly for Nettle's memxor function,
also developed during February, gave a speedup of 20% -- 50% depending
on the input alignment.


* Remaining tasks

The ECC interface needs to be finalized and documented.

There are always additional optimizations that are possible. Writing
x86_64 assembly for the modulo functions is tempting, but of low
priority within this project. As mentioned, the modular inversion is
slow, with the current code, 20% -- 30% of the time to create an ECDSA
signature is spent computing a modular inverse. This could be sped up
by assembly implementation of the primitives this algorithm needs, or
by writing the complete function in assembler.

The optimization of other cryptographic primitives such as the AES
cipher and the SHA256 hash function remains to do.

It has turned out that some internal functions in the GMP library,
used for arithmetic on larger numbers, would be useful for the ECC
implementation. One possible direction is to extend the public GMP
interface so these functions can be used.

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130316121440</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-03-16 12:14:40-0400</timestampReceived><subject>Re: ARM assembly</subject><body>

On 03/12/2013 10:51 AM, Niels Möller wrote:

&gt; I've new written some ARM assembly files for AES, SHA1 and SHA256. I
&gt; haven't tried any clever scheduling (it seems quite unpredictable), so I
&gt; think I win over the C code is mainly because I fit the important values
&gt; in registers. I have benchmarked on a cortex-a9 system, with nice but
&gt; not earth-shattering improvements over the C implementation.

Have you performed comparisons with the openssl AES-arm implementation?
I would be curious about it because the openssl's version was for armv4
and as far as I remembered it outperformed nettle's C implementation for
around 10-15% more (values out of memory I couldn't find out my
measurements).

regards,
Nikos

</body></email><email><emailId>20130323191647</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-03-23 19:16:47-0400</timestampReceived><subject>[PATCH 4/5] Add a fallback definition of mp_bitcnt_t, for GMP &lt; 5</subject><body>

The fallback is duplicated in eccdata.c to avoid having this file
(which is built for the host) to include other target specific
headers.
---
 ecc-internal.h |    1 +
 eccdata.c      |    4 ++++
 gmp-glue.h     |    4 ++++
 3 files changed, 9 insertions(+)

diff --git a/ecc-internal.h b/ecc-internal.h
index 0df8c9e..23207c7 100644
--- a/ecc-internal.h
+++ b/ecc-internal.h
@@ -29,6 +29,7 @@
 
 #include "nettle-types.h"
 #include "ecc-curve.h"
+#include "gmp-glue.h"
 
 /* Name mangling */
 #define ecc_generic_modp _nettle_ecc_generic_modp
diff --git a/eccdata.c b/eccdata.c
index ea922b5..a52e3ae 100644
--- a/eccdata.c
+++ b/eccdata.c
@@ -31,6 +31,10 @@
 
 #include &lt;gmp.h&gt;
 
+#if __GNU_MP__ &lt; 5
+typedef unsigned long int mp_bitcnt_t;
+#endif
+
 /* Affine coordinates, for simplicity. Infinity point represented as x
    == y == 0. */
 struct ecc_point
diff --git a/gmp-glue.h b/gmp-glue.h
index e764571..ef17c2f 100644
--- a/gmp-glue.h
+++ b/gmp-glue.h
@@ -33,6 +33,10 @@
 #define GMP_HAVE_mpz_limbs_read 0
 #endif
 
+#if __GNU_MP__ &lt; 5
+typedef unsigned long int mp_bitcnt_t;
+#endif
+
 /* Name mangling. */
 #if !GMP_HAVE_mpz_limbs_read
 #define mpz_limbs_read _nettle_mpz_limbs_read
-- 
1.7.9.4


</body></email><email><emailId>20130323212109</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-03-23 21:21:09-0400</timestampReceived><subject>[PATCHv2 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

---
I had accidentally botched the name of some of the functions
and defines in gmp-glue.h in the previous iteration.
---

 gmp-glue.c |   26 ++++++++++++++++++++++++++
 gmp-glue.h |   26 ++++++++++++++++++++++++++
 2 files changed, 52 insertions(+)

diff --git a/gmp-glue.c b/gmp-glue.c
index b468699..a2633a5 100644
--- a/gmp-glue.c
+++ b/gmp-glue.c
@@ -106,6 +106,32 @@ mpz_roinit_n (mpz_ptr x, const mp_limb_t *xp, mp_size_t xs)
 }
 #endif /* !GMP_HAVE_mpz_limbs_read */
 
+#if !GMP_HAVE_mpn_copyd
+void
+mpn_copyd (mp_ptr dst, mp_srcptr src, mp_size_t n)
+{
+  mp_size_t i;
+  for (i = n - 1; i &gt;= 0; i--)
+    dst[i] = src[i];
+}
+
+void
+mpn_copyi (mp_ptr dst, mp_srcptr src, mp_size_t n)
+{
+  mp_size_t i;
+  for (i = 0; i &lt; n; i++)
+    dst[i] = src[i];
+}
+
+void
+mpn_zero (mp_ptr ptr, mp_size_t n)
+{
+  mp_size_t i;
+  for (i = 0; i &lt; n; i++)
+    ptr[i] = 0;
+}
+#endif /* !GMP_HAVE_mpn_copyd */
+
 /* Additional convenience functions. */
 
 int
diff --git a/gmp-glue.h b/gmp-glue.h
index ef17c2f..0cde62f 100644
--- a/gmp-glue.h
+++ b/gmp-glue.h
@@ -33,6 +33,12 @@
 #define GMP_HAVE_mpz_limbs_read 0
 #endif
 
+#ifdef mpn_copyd
+#define GMP_HAVE_mpn_copyd 1
+#else
+#define GMP_HAVE_mpn_copyd 0
+#endif
+
 #if __GNU_MP__ &lt; 5
 typedef unsigned long int mp_bitcnt_t;
 #endif
@@ -46,6 +52,12 @@ typedef unsigned long int mp_bitcnt_t;
 #define mpz_roinit_n _nettle_mpz_roinit_n
 #endif
 
+#if !GMP_HAVE_mpn_copyd
+#define mpn_copyd _nettle_mpn_copyd
+#define mpn_copyi _nettle_mpn_copyi
+#define mpn_zero  _nettle_mpn_zero
+#endif
+
 #define mpz_limbs_cmp _nettle_mpz_limbs_cmp
 #define mpz_limbs_read_n _nettle_mpz_limbs_read_n
 #define mpz_limbs_copy _nettle_mpz_limbs_copy
@@ -87,6 +99,20 @@ mpz_roinit_n (mpz_ptr x, const mp_limb_t *xp, mp_size_t xs);
 
 #endif /* !GMP_HAVE_mpz_limbs_read */
 
+#if !GMP_HAVE_mpn_copyd
+/* Copy elements, backwards */
+void
+mpn_copyd (mp_ptr dst, mp_srcptr src, mp_size_t n);
+
+/* Copy elements, forwards */
+void
+mpn_copyi (mp_ptr dst, mp_srcptr src, mp_size_t n);
+
+/* Zero elements */
+void
+mpn_zero (mp_ptr ptr, mp_size_t n);
+#endif /* !GMP_HAVE_mpn_copyd */
+
 /* Convenience functions */
 int
 mpz_limbs_cmp (mpz_srcptr a, const mp_limb_t *bp, mp_size_t bn);
-- 
1.7.9.4


</body></email><email><emailId>20130323212135</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-03-23 21:21:35-0400</timestampReceived><subject>[PATCH] Use local paths for including headers in examples and tests</subject><body>

This makes sure a plain "make" succeeds without doing "make install".
---
 examples/hogweed-benchmark.c  |   10 +++++-----
 testsuite/ecdsa-keygen-test.c |    2 +-
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/examples/hogweed-benchmark.c b/examples/hogweed-benchmark.c
index 803f056..b1a0e89 100644
--- a/examples/hogweed-benchmark.c
+++ b/examples/hogweed-benchmark.c
@@ -34,12 +34,12 @@
 
 #include &lt;time.h&gt;
 
-#include &lt;nettle/dsa.h&gt;
-#include &lt;nettle/rsa.h&gt;
+#include "dsa.h"
+#include "rsa.h"
 
-#include &lt;nettle/nettle-meta.h&gt;
-#include &lt;nettle/sexp.h&gt;
-#include &lt;nettle/knuth-lfib.h&gt;
+#include "nettle-meta.h"
+#include "sexp.h"
+#include "knuth-lfib.h"
 
 #include "../ecdsa.h"
 #include "../ecc-internal.h"
diff --git a/testsuite/ecdsa-keygen-test.c b/testsuite/ecdsa-keygen-test.c
index 4f46d0d..7c25421 100644
--- a/testsuite/ecdsa-keygen-test.c
+++ b/testsuite/ecdsa-keygen-test.c
@@ -1,5 +1,5 @@
 #include "testutils.h"
-#include &lt;nettle/knuth-lfib.h&gt;
+#include "knuth-lfib.h"
 
 /* Check if y^2 = x^3 - 3x + b */
 static int
-- 
1.7.9.4


</body></email><email><emailId>20130325091943</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-03-25 09:19:43-0400</timestampReceived><subject>[PATCH] Add a fallback definition for mpn_sqr</subject><body>

---
 gmp-glue.h |    4 ++++
 1 file changed, 4 insertions(+)

diff --git a/gmp-glue.h b/gmp-glue.h
index 0cde62f..d154a50 100644
--- a/gmp-glue.h
+++ b/gmp-glue.h
@@ -58,6 +58,10 @@ typedef unsigned long int mp_bitcnt_t;
 #define mpn_zero  _nettle_mpn_zero
 #endif
 
+#ifndef mpn_sqr
+#define mpn_sqr(rp, ap, n) mpn_mul_n((rp), (ap), (ap), (n))
+#endif
+
 #define mpz_limbs_cmp _nettle_mpz_limbs_cmp
 #define mpz_limbs_read_n _nettle_mpz_limbs_read_n
 #define mpz_limbs_copy _nettle_mpz_limbs_copy
-- 
1.7.9.4


</body></email><email><emailId>20130325093236</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-25 09:32:36-0400</timestampReceived><subject>Re: [PATCH 1/5] Don't include OPT_ASM_SOURCES twice in hogweed_PURE_OBJS</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; --- a/Makefile.in
&gt; +++ b/Makefile.in
&gt; @@ -180,7 +180,7 @@ nettle_OBJS = $(nettle_SOURCES:.c=.$(OBJEXT)) $(LIBOBJS)
&gt;  nettle_PURE_OBJS = $(nettle_OBJS:.$(OBJEXT)=.p$(OBJEXT))
&gt;  
&gt;  hogweed_OBJS = $(hogweed_SOURCES:.c=.$(OBJEXT)) $(OPT_ASM_SOURCES:.asm=.$(OBJEXT))
&gt; -hogweed_PURE_OBJS = $(hogweed_OBJS:.$(OBJEXT)=.p$(OBJEXT)) $(OPT_ASM_SOURCES:.asm=.p$(OBJEXT))
&gt; +hogweed_PURE_OBJS = $(hogweed_OBJS:.$(OBJEXT)=.p$(OBJEXT))
&gt;  
&gt;  libnettle.a: $(nettle_OBJS)
&gt;  	-rm -f $@

Checked in now. This was reported earlier (privately) by Nikos, but I
didn't get the fix comitted at the time.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130325094503</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-03-25 09:45:03-0400</timestampReceived><subject>Re: [PATCH 3/5] Don't unconditionally use clock_gettime in {ecc, hogweed}-benchmark</subject><body>


On Mon, 25 Mar 2013, Niels Möller wrote:

&gt; Martin Storsjö &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt; This falls back to clock(), just like in e.g. nettle-benchmark.
&gt;
&gt; For reduced code duplication, it would be nice to move the timing things
&gt; to separate files, say timing.c and timing.h. Would you like to do that?

I can do that, sure.

// Martin

</body></email><email><emailId>20130325102514</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-03-25 10:25:14-0400</timestampReceived><subject>=?UTF-8?q?=5BPATCH=5D=20Factorize=20timing=20functions=20to=20a=20separate=20file?=</subject><body>

This avoids unconditionally using clock_gettime in
{ecc,hogweed}-benchmark, falling back to clock() in these
as well.

This makes building succeed on e.g. OS X.
---
 examples/Makefile.in         |   16 +++---
 examples/ecc-benchmark.c     |   26 ++--------
 examples/hogweed-benchmark.c |   26 ++--------
 examples/nettle-benchmark.c  |   69 ++------------------------
 examples/timing.c            |  110 ++++++++++++++++++++++++++++++++++++++++++
 examples/timing.h            |   30 ++++++++++++
 6 files changed, 162 insertions(+), 115 deletions(-)
 create mode 100644 examples/timing.c
 create mode 100644 examples/timing.h

diff --git a/examples/Makefile.in b/examples/Makefile.in
index 3455a58..563d0dc 100644
--- a/examples/Makefile.in
+++ b/examples/Makefile.in
@@ -28,7 +28,7 @@ SOURCES = nettle-benchmark.c hogweed-benchmark.c ecc-benchmark.c \
 	nettle-openssl.c \
 	io.c read_rsa_key.c \
 	rsa-encrypt.c rsa-decrypt.c rsa-keygen.c rsa-sign.c rsa-verify.c \
-	base16enc.c base16dec.c base64enc.c base64dec.c
+	base16enc.c base16dec.c base64enc.c base64dec.c timing.c
 
 
 GETOPT_OBJS = ../getopt.$(OBJEXT) ../getopt1.$(OBJEXT)
@@ -36,7 +36,7 @@ GETOPT_OBJS = ../getopt.$(OBJEXT) ../getopt1.$(OBJEXT)
 TS_ALL = rsa-sign-test rsa-verify-test rsa-encrypt-test
 
 DISTFILES= $(SOURCES) Makefile.in $(TS_ALL) setup-env teardown-env \
-	io.h rsa-session.h
+	io.h rsa-session.h timing.h
 
 all: $(TARGETS)
 
@@ -102,16 +102,18 @@ eratosthenes$(EXEEXT): eratosthenes.$(OBJEXT) $(GETOPT_OBJS)
 	$(LINK) eratosthenes.$(OBJEXT) $(GETOPT_OBJS) -o eratosthenes$(EXEEXT)
 
 BENCH_OBJS = nettle-benchmark.$(OBJEXT) nettle-openssl.$(OBJEXT) \
-	$(GETOPT_OBJS) ../nettle-internal.$(OBJEXT)
+	$(GETOPT_OBJS) ../nettle-internal.$(OBJEXT) timing.$(OBJEXT)
 nettle-benchmark$(EXEEXT): $(BENCH_OBJS)
 	$(LINK) $(BENCH_OBJS) -lnettle $(BENCH_LIBS) $(OPENSSL_LIBFLAGS) -o nettle-benchmark$(EXEEXT)
 
-ecc-benchmark$(EXEEXT): ecc-benchmark.$(OBJEXT)
-	$(LINK) ecc-benchmark.$(OBJEXT) -lhogweed -lnettle $(BENCH_LIBS) $(LIBS) \
+ECC_BENCH_OBJS = ecc-benchmark.$(OBJEXT) timing.$(OBJEXT)
+ecc-benchmark$(EXEEXT): $(ECC_BENCH_OBJS)
+	$(LINK) $(ECC_BENCH_OBJS) -lhogweed -lnettle $(BENCH_LIBS) $(LIBS) \
 	-o ecc-benchmark$(EXEEXT)
 
-hogweed-benchmark$(EXEEXT): hogweed-benchmark.$(OBJEXT)
-	$(LINK) hogweed-benchmark.$(OBJEXT) \
+HOGWEED_BENCH_OBJS = hogweed-benchmark.$(OBJEXT) timing.$(OBJEXT)
+hogweed-benchmark$(EXEEXT): $(HOGWEED_BENCH_OBJS)
+	$(LINK) $(HOGWEED_BENCH_OBJS) \
 	-lhogweed -lnettle $(BENCH_LIBS) $(LIBS) $(OPENSSL_LIBFLAGS) \
 	-o hogweed-benchmark$(EXEEXT)
 
diff --git a/examples/ecc-benchmark.c b/examples/ecc-benchmark.c
index 596b2ff..e14e55e 100644
--- a/examples/ecc-benchmark.c
+++ b/examples/ecc-benchmark.c
@@ -35,6 +35,8 @@
 
 #include &lt;time.h&gt;
 
+#include "timing.h"
+
 #include "../ecc.h"
 #include "../ecc-internal.h"
 #include "../gmp-glue.h"
@@ -70,24 +72,6 @@ xalloc_limbs (mp_size_t size)
   return xalloc (size * sizeof(mp_limb_t));
 }
 
-inline static void
-time_start(struct timespec *start)
-{
-  if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, start) &lt; 0)
-    die("clock_gettime failed: %s\n", strerror(errno));
-}
-
-static inline double
-time_end(struct timespec *start)
-{
-  struct timespec end;
-  if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;end) &lt; 0)
-    die("clock_gettime failed: %s\n", strerror(errno));
-
-  return end.tv_sec - start-&gt;tv_sec
-    + 1e-9 * (end.tv_nsec - start-&gt;tv_nsec);
-}
-
 /* Returns second per function call */
 static double
 time_function(void (*f)(void *arg), void *arg)
@@ -100,12 +84,11 @@ time_function(void (*f)(void *arg), void *arg)
   for (ncalls = 10 ;;)
     {
       unsigned i;
-      struct timespec t;
 
-      time_start(&amp;t);
+      time_start();
       for (i = 0; i &lt; ncalls; i++)
 	f(arg);
-      elapsed = time_end(&amp;t);
+      elapsed = time_end();
       if (elapsed &gt; BENCH_INTERVAL)
 	break;
       else if (elapsed &lt; BENCH_INTERVAL / 10)
@@ -293,6 +276,7 @@ main (int argc UNUSED, char **argv UNUSED)
 {
   unsigned i;
 
+  time_init();
   printf ("%4s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s (us)\n",
 	  "size", "modp", "redc", "modq", "modinv", "mi_gcd",
 	  "dup_jj", "ad_jja", "ad_jjj",
diff --git a/examples/hogweed-benchmark.c b/examples/hogweed-benchmark.c
index f6ceda9..56860e0 100644
--- a/examples/hogweed-benchmark.c
+++ b/examples/hogweed-benchmark.c
@@ -34,6 +34,8 @@
 
 #include &lt;time.h&gt;
 
+#include "timing.h"
+
 #include "dsa.h"
 #include "rsa.h"
 
@@ -90,24 +92,6 @@ hash_string (const struct nettle_hash *hash,
   return digest;
 }
 
-inline static void
-time_start(struct timespec *start)
-{
-  if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, start) &lt; 0)
-    die("clock_gettime failed: %s\n", strerror(errno));
-}
-
-static inline double
-time_end(struct timespec *start)
-{
-  struct timespec end;
-  if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;end) &lt; 0)
-    die("clock_gettime failed: %s\n", strerror(errno));
-
-  return end.tv_sec - start-&gt;tv_sec
-    + 1e-9 * (end.tv_nsec - start-&gt;tv_nsec);
-}
-
 struct alg {
   const char *name;
   unsigned size;
@@ -129,12 +113,11 @@ time_function(void (*f)(void *arg), void *arg)
   for (ncalls = 10 ;;)
     {
       unsigned i;
-      struct timespec t;
 
-      time_start(&amp;t);
+      time_start();
       for (i = 0; i &lt; ncalls; i++)
 	f(arg);
-      elapsed = time_end(&amp;t);
+      elapsed = time_end();
       if (elapsed &gt; BENCH_INTERVAL)
 	break;
       else if (elapsed &lt; BENCH_INTERVAL / 10)
@@ -625,6 +608,7 @@ main (int argc, char **argv)
   if (argc &gt; 1)
     filter = argv[1];
 
+  time_init();
   printf ("%15s %4s %9s %9s\n",
 	  "name", "size", "sign/ms", "verify/ms");
 
diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index 90d6c72..852baef 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -38,6 +38,8 @@
 
 #include &lt;time.h&gt;
 
+#include "timing.h"
+
 #include "aes.h"
 #include "arcfour.h"
 #include "blowfish.h"
@@ -112,58 +114,6 @@ die(const char *format, ...)
 
 static double overhead = 0.0; 
 
-#if HAVE_CLOCK_GETTIME &amp;&amp; defined CLOCK_PROCESS_CPUTIME_ID
-#define TRY_CLOCK_GETTIME 1
-struct timespec cgt_start;
-
-static int
-cgt_works_p(void)
-{
-  struct timespec now;
-  return clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;now) == 0;
-}
-
-static void
-cgt_time_start(void)
-{
-  if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;cgt_start) &lt; 0)
-    die("clock_gettime failed: %s\n", strerror(errno));
-}
-
-static double
-cgt_time_end(void)
-{
-    struct timespec end;
-    if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;end) &lt; 0)
-      die("clock_gettime failed: %s\n", strerror(errno));
-
-    return end.tv_sec - cgt_start.tv_sec
-      + 1e-9 * (end.tv_nsec - cgt_start.tv_nsec);
-}
-
-static void (*time_start)(void);
-static double (*time_end)(void);
-
-#else /* !HAVE_CLOCK_GETTIME */
-#define TRY_CLOCK_GETTIME 0
-#define time_start clock_time_start
-#define time_end clock_time_end
-#endif /* !HAVE_CLOCK_GETTIME */
-
-static clock_t clock_start;
-
-static void
-clock_time_start(void)
-{
-  clock_start = clock();
-}
-
-static double
-clock_time_end(void)
-{
-  return (double) (clock() - (clock_start)) / CLOCKS_PER_SEC;
-}
-
 /* Returns second per function call */
 static double
 time_function(void (*f)(void *arg), void *arg)
@@ -700,20 +650,7 @@ main(int argc, char **argv)
 
   alg = argv[optind];
 
-  /* Choose timing function */
-#if TRY_CLOCK_GETTIME
-  if (cgt_works_p())
-    {
-      time_start = cgt_time_start;
-      time_end = cgt_time_end;
-    }
-  else
-    {
-      fprintf(stderr, "clock_gettime not working, falling back to clock\n");
-      time_start = clock_time_start;
-      time_end = clock_time_end;
-    }
-#endif
+  time_init();
   bench_sha1_compress();
   bench_salsa20_core();
   bench_sha3_permute();
diff --git a/examples/timing.c b/examples/timing.c
new file mode 100644
index 0000000..108399a
--- /dev/null
+++ b/examples/timing.c
@@ -0,0 +1,110 @@
+/* timing.c */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Niels Möller
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "timing.h"
+
+#include &lt;errno.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;time.h&gt;
+
+#if HAVE_CLOCK_GETTIME &amp;&amp; defined CLOCK_PROCESS_CPUTIME_ID
+#define TRY_CLOCK_GETTIME 1
+struct timespec cgt_start;
+
+static void NORETURN PRINTF_STYLE(1,2)
+die(const char *format, ...)
+{
+  va_list args;
+  va_start(args, format);
+  vfprintf(stderr, format, args);
+  va_end(args);
+
+  exit(EXIT_FAILURE);
+}
+
+static int
+cgt_works_p(void)
+{
+  struct timespec now;
+  return clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;now) == 0;
+}
+
+static void
+cgt_time_start(void)
+{
+  if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;cgt_start) &lt; 0)
+    die("clock_gettime failed: %s\n", strerror(errno));
+}
+
+static double
+cgt_time_end(void)
+{
+  struct timespec end;
+  if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;end) &lt; 0)
+    die("clock_gettime failed: %s\n", strerror(errno));
+
+  return end.tv_sec - cgt_start.tv_sec
+    + 1e-9 * (end.tv_nsec - cgt_start.tv_nsec);
+}
+#endif /* !HAVE_CLOCK_GETTIME */
+
+static clock_t clock_start;
+
+static void
+clock_time_start(void)
+{
+  clock_start = clock();
+}
+
+static double
+clock_time_end(void)
+{
+  return (double) (clock() - (clock_start)) / CLOCKS_PER_SEC;
+}
+
+void (*time_start)(void) = clock_time_start;
+double (*time_end)(void) = clock_time_end;
+
+void time_init(void)
+{
+  /* Choose timing function */
+#if TRY_CLOCK_GETTIME
+  if (cgt_works_p())
+    {
+      time_start = cgt_time_start;
+      time_end = cgt_time_end;
+    }
+  else
+    {
+      fprintf(stderr, "clock_gettime not working, falling back to clock\n");
+      time_start = clock_time_start;
+      time_end = clock_time_end;
+    }
+#endif
+}
diff --git a/examples/timing.h b/examples/timing.h
new file mode 100644
index 0000000..7307fa1
--- /dev/null
+++ b/examples/timing.h
@@ -0,0 +1,30 @@
+/* timing.c */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Niels Möller
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#ifndef NETTLE_EXAMPLES_TIMING_H_INCLUDED
+#define NETTLE_EXAMPLES_TIMING_H_INCLUDED
+
+void time_init(void);
+extern void (*time_start)(void);
+extern double (*time_end)(void);
+
+#endif /* NETTLE_EXAMPLES_TIMING_H_INCLUDED */
-- 
1.7.9.4


</body></email><email><emailId>20130323191644</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-03-23 19:16:44-0400</timestampReceived><subject>[PATCH 1/5] Don't include OPT_ASM_SOURCES twice in hogweed_PURE_OBJS</subject><body>

OPT_ASM_SOURCES is already included via hogweed_OBJS.

This avoids build errors about duplicate symbols in the shared
library.
---
 Makefile.in |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Makefile.in b/Makefile.in
index 1ec807b..2db76c5 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -180,7 +180,7 @@ nettle_OBJS = $(nettle_SOURCES:.c=.$(OBJEXT)) $(LIBOBJS)
 nettle_PURE_OBJS = $(nettle_OBJS:.$(OBJEXT)=.p$(OBJEXT))
 
 hogweed_OBJS = $(hogweed_SOURCES:.c=.$(OBJEXT)) $(OPT_ASM_SOURCES:.asm=.$(OBJEXT))
-hogweed_PURE_OBJS = $(hogweed_OBJS:.$(OBJEXT)=.p$(OBJEXT)) $(OPT_ASM_SOURCES:.asm=.p$(OBJEXT))
+hogweed_PURE_OBJS = $(hogweed_OBJS:.$(OBJEXT)=.p$(OBJEXT))
 
 libnettle.a: $(nettle_OBJS)
 	-rm -f $@
-- 
1.7.9.4


</body></email><email><emailId>20130323191646</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-03-23 19:16:46-0400</timestampReceived><subject>[PATCH 3/5] Don't unconditionally use clock_gettime in {ecc, hogweed}-benchmark</subject><body>

This falls back to clock(), just like in e.g. nettle-benchmark.

This makes building succeed on e.g. OS X.
---
 examples/ecc-benchmark.c     |   69 +++++++++++++++++++++++++++++++++++++-----
 examples/hogweed-benchmark.c |   69 +++++++++++++++++++++++++++++++++++++-----
 2 files changed, 122 insertions(+), 16 deletions(-)

diff --git a/examples/ecc-benchmark.c b/examples/ecc-benchmark.c
index 596b2ff..e2ee3d5 100644
--- a/examples/ecc-benchmark.c
+++ b/examples/ecc-benchmark.c
@@ -70,22 +70,75 @@ xalloc_limbs (mp_size_t size)
   return xalloc (size * sizeof(mp_limb_t));
 }
 
+#if HAVE_CLOCK_GETTIME &amp;&amp; defined CLOCK_PROCESS_CPUTIME_ID
+#define TRY_CLOCK_GETTIME 1
+struct timespec cgt_start;
+
+static int
+cgt_works_p(void)
+{
+  struct timespec now;
+  return clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;now) == 0;
+}
+
 inline static void
-time_start(struct timespec *start)
+cgt_time_start(void)
 {
-  if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, start) &lt; 0)
+  if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;cgt_start) &lt; 0)
     die("clock_gettime failed: %s\n", strerror(errno));
 }
 
 static inline double
-time_end(struct timespec *start)
+cgt_time_end(void)
 {
   struct timespec end;
   if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;end) &lt; 0)
     die("clock_gettime failed: %s\n", strerror(errno));
 
-  return end.tv_sec - start-&gt;tv_sec
-    + 1e-9 * (end.tv_nsec - start-&gt;tv_nsec);
+  return end.tv_sec - cgt_start.tv_sec
+    + 1e-9 * (end.tv_nsec - cgt_start.tv_nsec);
+}
+
+static void (*time_start)(void);
+static double (*time_end)(void);
+static void clock_time_start(void);
+static double clock_time_end(void);
+
+static void time_init(void)
+{
+  /* Choose timing function */
+  if (cgt_works_p())
+    {
+      time_start = cgt_time_start;
+      time_end = cgt_time_end;
+    }
+  else
+    {
+      fprintf(stderr, "clock_gettime not working, falling back to clock\n");
+      time_start = clock_time_start;
+      time_end = clock_time_end;
+    }
+}
+
+#else /* !HAVE_CLOCK_GETTIME */
+#define TRY_CLOCK_GETTIME 0
+#define time_start clock_time_start
+#define time_end clock_time_end
+#define time_init()
+#endif /* !HAVE_CLOCK_GETTIME */
+
+static clock_t clock_start;
+
+static void
+clock_time_start(void)
+{
+  clock_start = clock();
+}
+
+static double
+clock_time_end(void)
+{
+  return (double) (clock() - (clock_start)) / CLOCKS_PER_SEC;
 }
 
 /* Returns second per function call */
@@ -100,12 +153,11 @@ time_function(void (*f)(void *arg), void *arg)
   for (ncalls = 10 ;;)
     {
       unsigned i;
-      struct timespec t;
 
-      time_start(&amp;t);
+      time_start();
       for (i = 0; i &lt; ncalls; i++)
 	f(arg);
-      elapsed = time_end(&amp;t);
+      elapsed = time_end();
       if (elapsed &gt; BENCH_INTERVAL)
 	break;
       else if (elapsed &lt; BENCH_INTERVAL / 10)
@@ -293,6 +345,7 @@ main (int argc UNUSED, char **argv UNUSED)
 {
   unsigned i;
 
+  time_init();
   printf ("%4s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s (us)\n",
 	  "size", "modp", "redc", "modq", "modinv", "mi_gcd",
 	  "dup_jj", "ad_jja", "ad_jjj",
diff --git a/examples/hogweed-benchmark.c b/examples/hogweed-benchmark.c
index 6a7da96..803f056 100644
--- a/examples/hogweed-benchmark.c
+++ b/examples/hogweed-benchmark.c
@@ -90,22 +90,75 @@ hash_string (const struct nettle_hash *hash,
   return digest;
 }
 
+#if HAVE_CLOCK_GETTIME &amp;&amp; defined CLOCK_PROCESS_CPUTIME_ID
+#define TRY_CLOCK_GETTIME 1
+struct timespec cgt_start;
+
+static int
+cgt_works_p(void)
+{
+  struct timespec now;
+  return clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;now) == 0;
+}
+
 inline static void
-time_start(struct timespec *start)
+cgt_time_start(void)
 {
-  if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, start) &lt; 0)
+  if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;cgt_start) &lt; 0)
     die("clock_gettime failed: %s\n", strerror(errno));
 }
 
 static inline double
-time_end(struct timespec *start)
+cgt_time_end(void)
 {
   struct timespec end;
   if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;end) &lt; 0)
     die("clock_gettime failed: %s\n", strerror(errno));
 
-  return end.tv_sec - start-&gt;tv_sec
-    + 1e-9 * (end.tv_nsec - start-&gt;tv_nsec);
+  return end.tv_sec - cgt_start.tv_sec
+    + 1e-9 * (end.tv_nsec - cgt_start.tv_nsec);
+}
+
+static void (*time_start)(void);
+static double (*time_end)(void);
+static void clock_time_start(void);
+static double clock_time_end(void);
+
+static void time_init(void)
+{
+  /* Choose timing function */
+  if (cgt_works_p())
+    {
+      time_start = cgt_time_start;
+      time_end = cgt_time_end;
+    }
+  else
+    {
+      fprintf(stderr, "clock_gettime not working, falling back to clock\n");
+      time_start = clock_time_start;
+      time_end = clock_time_end;
+    }
+}
+
+#else /* !HAVE_CLOCK_GETTIME */
+#define TRY_CLOCK_GETTIME 0
+#define time_start clock_time_start
+#define time_end clock_time_end
+#define time_init()
+#endif /* !HAVE_CLOCK_GETTIME */
+
+static clock_t clock_start;
+
+static void
+clock_time_start(void)
+{
+  clock_start = clock();
+}
+
+static double
+clock_time_end(void)
+{
+  return (double) (clock() - (clock_start)) / CLOCKS_PER_SEC;
 }
 
 struct alg {
@@ -129,12 +182,11 @@ time_function(void (*f)(void *arg), void *arg)
   for (ncalls = 10 ;;)
     {
       unsigned i;
-      struct timespec t;
 
-      time_start(&amp;t);
+      time_start();
       for (i = 0; i &lt; ncalls; i++)
 	f(arg);
-      elapsed = time_end(&amp;t);
+      elapsed = time_end();
       if (elapsed &gt; BENCH_INTERVAL)
 	break;
       else if (elapsed &lt; BENCH_INTERVAL / 10)
@@ -625,6 +677,7 @@ main (int argc, char **argv)
   if (argc &gt; 1)
     filter = argv[1];
 
+  time_init();
   printf ("%15s %4s %9s %9s\n",
 	  "name", "size", "sign/ms", "verify/ms");
 
-- 
1.7.9.4


</body></email><email><emailId>20130323191645</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-03-23 19:16:45-0400</timestampReceived><subject>[PATCH 2/5] Do the movd/movq workaround for the osx assembler, for sha3-permute</subject><body>

This is the same workaround as done in f58d1c288f6 for salsa20-crypt.
---
 x86_64/sha3-permute.asm |   40 ++++++++++++++++++++++------------------
 1 file changed, 22 insertions(+), 18 deletions(-)

diff --git a/x86_64/sha3-permute.asm b/x86_64/sha3-permute.asm
index 0ebd70c..360a1f4 100644
--- a/x86_64/sha3-permute.asm
+++ b/x86_64/sha3-permute.asm
@@ -72,6 +72,10 @@ define(&lt;STATE&gt;, &lt;OFFSET($1)(CTX)&gt;)
 
 define(&lt;SWAP64&gt;, &lt;pshufd	&lt;$&gt;0x4e,&gt;)
 
+C movq calls that are equal to the corresponding movd,
+C where the Apple assembler requires them to be written as movd.
+define(&lt;MOVQ&gt;, &lt;movd&gt;)
+
 C ROTL64(rot, register, temp)
 C Caller needs to or together the result.
 define(&lt;ROTL64&gt;, &lt;
@@ -147,12 +151,12 @@ PROLOGUE(nettle_sha3_permute)
 
 	SWAP64	C34, C34		C Holds C4, C3
 	movdqa	C12, D34
-	movq	C0, D12
+	MOVQ	C0, D12
 	punpcklqdq	C12, D12	C Holds C0, C1
 	punpckhqdq	C34, D34	C Holds C2, C3
 	punpcklqdq	D12, C34	C Holds	C4, C0
-	movq	C34, D0
-	movq	C12, T0
+	MOVQ	C34, D0
+	MOVQ	C12, T0
 	rolq	$1, T0
 	xorq	T0, D0
 
@@ -236,8 +240,8 @@ PROLOGUE(nettle_sha3_permute)
 	C   `-_________-^`-^
 	
 	rolq	$36, A05
-	movq	A05, W0
-	movq	A0607, A05
+	MOVQ	A05, W0
+	MOVQ	A0607, A05
 	rolq	$44, A05		C Done A05
 	ROTL64(6, A0607, W1)
 	por	A0607, W1
@@ -260,8 +264,8 @@ PROLOGUE(nettle_sha3_permute)
 
 	rolq	$42, A10		C 42 + 25 = 3 (mod 64)
 	SWAP64	A1112, W0
-	movq	A10, A1112
-	movq	W0, A10
+	MOVQ	A10, A1112
+	MOVQ	W0, A10
 	rolq	$43, A10		C Done A10
 
 	punpcklqdq	A1314, A1112
@@ -285,8 +289,8 @@ PROLOGUE(nettle_sha3_permute)
 
 	SWAP64	A1819, W0
 	rolq	$41, A15
-	movq	A15, W1
-	movq	A1819, A15
+	MOVQ	A15, W1
+	MOVQ	A1819, A15
 	rolq	$21, A15		C Done A15
 	SWAP64	A1617, A1819
 	ROTL64(45, A1617, W2)
@@ -308,7 +312,7 @@ PROLOGUE(nettle_sha3_permute)
 	C    \_______/
 
 	rolq	$18, A20
-	movq	A20, W0
+	MOVQ	A20, W0
 	SWAP64	A2324, W1
 	movd	W1, A20
 	rolq	$14, A20		C Done A20
@@ -386,21 +390,21 @@ PROLOGUE(nettle_sha3_permute)
 	C Swap (A05, A10) &lt;-&gt;  A0102, and (A15, A20) &lt;-&gt;  A0304,
 	C and also copy to C12 and C34 while at it.
 	
-	movq	A05, C12
-	movq	A15, C34
-	movq	A10, W0
-	movq	A20, W1
+	MOVQ	A05, C12
+	MOVQ	A15, C34
+	MOVQ	A10, W0
+	MOVQ	A20, W1
 	movq	A00, C0
 	punpcklqdq	W0, C12
 	punpcklqdq	W1, C34
-	movq	A0102, A05
-	movq	A0304, A15
+	MOVQ	A0102, A05
+	MOVQ	A0304, A15
 	psrldq	$8, A0102
 	psrldq	$8, A0304
 	xorq	A05, C0
 	xorq	A15, C0
-	movq	A0102, A10
-	movq	A0304, A20
+	MOVQ	A0102, A10
+	MOVQ	A0304, A20
 
 	movdqa	C12, A0102
 	movdqa	C34, A0304
-- 
1.7.9.4


</body></email><email><emailId>20130325094206</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-25 09:42:06-0400</timestampReceived><subject>Re: [PATCH 3/5] Don't unconditionally use clock_gettime in {ecc, hogweed}-benchmark</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; This falls back to clock(), just like in e.g. nettle-benchmark.

For reduced code duplication, it would be nice to move the timing things
to separate files, say timing.c and timing.h. Would you like to do that?

Regards,
/Niels

</body></email><email><emailId>20130325121147</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-25 12:11:47-0400</timestampReceived><subject>Re: [PATCH 2/5] Do the movd/movq workaround for the osx assembler, for sha3-permute</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; --- a/x86_64/sha3-permute.asm
&gt; +++ b/x86_64/sha3-permute.asm

BTW, this really file needs a rewrite. It runs much slower than the C
version on some (or all?) AMD processors. Probably because the movq/movd
between general registers and xmm registers have a large latency
penalty. One would either need to move data via memory (maybe with a
separate permute/rotate passworking with general registers and memory),
or squeeze (almost) all state into the xmm registers, a bit like the arm
neon sha3 code I wrote the other week.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130317131923</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-03-17 13:19:23-0400</timestampReceived><subject>salsa20r12</subject><body>

Hello,
 This patch adds a function to use the Salsa20 with 12 rounds.

regards,
Nikos

["0001-Added-encryption-function-for-12-round-salsa20.patch" (text/x-patch)]

&gt;From a90fd43ef7e1bbd9e39df7b612aac430169f3f5b Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Sun, 17 Mar 2013 14:16:09 +0100
Subject: [PATCH] Added encryption function for 12-round salsa20.

---
 Makefile.in        |    2 +-
 salsa20-crypt.c    |    5 ++--
 salsa20.h          |    7 +++++
 salsa20r12-crypt.c |   74 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 85 insertions(+), 3 deletions(-)
 create mode 100644 salsa20r12-crypt.c

diff --git a/Makefile.in b/Makefile.in
index 1ec807b..3e939c7 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -86,7 +86,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gosthash94.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
 		 salsa20-core-internal.c \
-		 salsa20-crypt.c salsa20-set-key.c \
+		 salsa20-crypt.c salsa20r12-crypt.c salsa20-set-key.c \
 		 sha1.c sha1-compress.c sha1-meta.c \
 		 sha256.c sha256-compress.c sha224-meta.c sha256-meta.c \
 		 sha512.c sha512-compress.c sha384-meta.c sha512-meta.c \
diff --git a/salsa20-crypt.c b/salsa20-crypt.c
index b061b4b..d395d36 100644
--- a/salsa20-crypt.c
+++ b/salsa20-crypt.c
@@ -46,12 +46,13 @@ salsa20_crypt(struct salsa20_ctx *ctx,
 	      uint8_t *c,
 	      const uint8_t *m)
 {
+  uint32_t x[_SALSA20_INPUT_LENGTH];
+
   if (!length)
     return;
   
   for (;;)
     {
-      uint32_t x[_SALSA20_INPUT_LENGTH];
 
       _salsa20_core (x, ctx-&gt;input, 20);
 
@@ -69,5 +70,5 @@ salsa20_crypt(struct salsa20_ctx *ctx,
       length -= SALSA20_BLOCK_SIZE;
       c += SALSA20_BLOCK_SIZE;
       m += SALSA20_BLOCK_SIZE;
-  }
+    }
 }
diff --git a/salsa20.h b/salsa20.h
index d95d002..1c5cc4a 100644
--- a/salsa20.h
+++ b/salsa20.h
@@ -39,6 +39,8 @@ extern "C" {
 #define salsa20_crypt nettle_salsa20_crypt
 #define _salsa20_core _nettle_salsa20_core
 
+#define salsa20r12_crypt nettle_salsa20r12_crypt
+
 /* Minimum and maximum keysizes, and a reasonable default. In
  * octets.*/
 #define SALSA20_MIN_KEY_SIZE 16
@@ -77,6 +79,11 @@ salsa20_crypt(struct salsa20_ctx *ctx,
 	      const uint8_t *src);
 
 void
+salsa20r12_crypt(struct salsa20_ctx *ctx,
+	      unsigned length, uint8_t *dst,
+	      const uint8_t *src);
+
+void
 _salsa20_core(uint32_t *dst, const uint32_t *src, unsigned rounds);
 
 #ifdef __cplusplus
diff --git a/salsa20r12-crypt.c b/salsa20r12-crypt.c
new file mode 100644
index 0000000..0c82217
--- /dev/null
+++ b/salsa20r12-crypt.c
@@ -0,0 +1,74 @@
+/* salsa20r12-crypt.c
+ *
+ * The Salsa20 stream cipher.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Nikos Mavrogiannopoulos
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+/* Based on:
+   salsa20-ref.c version 20051118
+   D. J. Bernstein
+   Public domain.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;string.h&gt;
+
+#include "salsa20.h"
+
+#include "macros.h"
+#include "memxor.h"
+
+void
+salsa20r12_crypt(struct salsa20_ctx *ctx,
+	      unsigned length,
+	      uint8_t *c,
+	      const uint8_t *m)
+{
+  uint32_t x[_SALSA20_INPUT_LENGTH];
+
+  if (!length)
+    return;
+  
+  for (;;)
+    {
+
+      _salsa20_core (x, ctx-&gt;input, 12);
+
+      ctx-&gt;input[9] += (++ctx-&gt;input[8] == 0);
+
+      /* stopping at 2^70 length per nonce is user's responsibility */
+      
+      if (length &lt;= SALSA20_BLOCK_SIZE)
+	{
+	  memxor3 (c, m, (uint8_t *) x, length);
+	  return;
+	}
+      memxor3 (c, m, (uint8_t *) x, SALSA20_BLOCK_SIZE);
+
+      length -= SALSA20_BLOCK_SIZE;
+      c += SALSA20_BLOCK_SIZE;
+      m += SALSA20_BLOCK_SIZE;
+    }
+}
-- 
1.7.10.4



</body></email><email><emailId>20130325115723</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-25 11:57:23-0400</timestampReceived><subject>Re: salsa20r12</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;  This patch adds a function to use the Salsa20 with 12 rounds.

Committed, except for the change to salsa20-crypt.c, which seemed
unrelated.

Do you have any test vectors?

I haven't had time to read your latest umac code yet. I was offline
skiing all of last week.

Thanks,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130327083319</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-03-27 08:33:19-0400</timestampReceived><subject>openssl tests</subject><body>


Hello,
 In some systems the elliptic curves part of openssl is disabled. This
patch disables the openssl examples/tests if it does not exist (I had
issue with the EC tests).

Also in some issue I replaced an #if with and #ifdef, because the rule
didn't work.
-#if WITH_OPENSSL
+#ifdef WITH_OPENSSL

In general I noticed a lot of uses of "#if" that actually mean ifdef.
Are these intentional? I'm not really sure what #if does if followed
by an undefined expression.

regards,
Nikos


</body></email><email><emailId>20130327090745</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-27 09:07:45-0400</timestampReceived><subject>Re: openssl tests</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;  In some systems the elliptic curves part of openssl is disabled. This
&gt; patch disables the openssl examples/tests if it does not exist (I had
&gt; issue with the EC tests).

Actual patch missing?

&gt; Also in some issue I replaced an #if with and #ifdef, because the rule
&gt; didn't work.
&gt; -#if WITH_OPENSSL
&gt; +#ifdef WITH_OPENSSL

Hmm. I'd like to understand what the problem is. 

&gt; In general I noticed a lot of uses of "#if" that actually mean ifdef.
&gt; Are these intentional?

I think I have tried to use plain #if consistently. I don't remember the
reason, maybe it was recommended in the autoconf manual or the GNU
coding standards.

&gt; I'm not really sure what #if does if followed
&gt; by an undefined expression.

When evaluation the argument to #if, I think the preprocessor replaces
all unknown symbols by 0. So #if vs #ifdef should matter only if the
symbol is #defined, but the definition is zero or empty or strange in
some other way.

In config.h, all defined symbols should be defined to have the value 1,
which should make a plain #if work fine. Maybe there's something wrong
with how WITH_OPENSSL is handled?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130325192244</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-03-25 19:22:44-0400</timestampReceived><subject>Re: salsa20r12</subject><body>

On 03/25/2013 12:57 PM, Niels Möller wrote:

&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt;&gt;  This patch adds a function to use the Salsa20 with 12 rounds.
&gt; 
&gt; Committed, except for the change to salsa20-crypt.c, which seemed
&gt; unrelated.
&gt; 
&gt; Do you have any test vectors?


Attached.

btw. the current _salsa20_core takes rounds as a variable. Wouldn't it
allow for better optimizations (loop unrolling actually) if that was a
static function, or that doesn't matter much? As far as I understand it
is highly unlikely that salsa20 will be used with anything else than 20
or 12 rounds.

regards,
Nikos

["0001-Added-salsa20-12-test-vectors.patch" (text/x-patch)]

&gt; From 173eff458fdc791826f7c8e0ee4dabd92296a746 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Mon, 25 Mar 2013 20:18:14 +0100
Subject: [PATCH] Added salsa20/12 test vectors.

---
 testsuite/salsa20-test.c |   52 ++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 48 insertions(+), 4 deletions(-)

diff --git a/testsuite/salsa20-test.c b/testsuite/salsa20-test.c
index d742ce4..958b4e7 100644
--- a/testsuite/salsa20-test.c
+++ b/testsuite/salsa20-test.c
@@ -116,11 +116,14 @@ test_salsa20_stream(const struct tstring *key,
     }
 }
 
+#define test_salsa20(key, iv, cl, ci) _test_salsa20(key, iv, cl, ci, 0)
+#define test_salsa20r12(key, iv, cl, ci) _test_salsa20(key, iv, cl, ci, 1)
+
 static void
-test_salsa20(const struct tstring *key,
+_test_salsa20(const struct tstring *key,
 	     const struct tstring *iv,
 	     const struct tstring *cleartext,
-	     const struct tstring *ciphertext)
+	     const struct tstring *ciphertext, int r12)
 {
   struct salsa20_ctx ctx;
   uint8_t *data;
@@ -136,7 +139,11 @@ test_salsa20(const struct tstring *key,
   salsa20_set_key(&amp;ctx, key-&gt;length, key-&gt;data);
   salsa20_set_iv(&amp;ctx, iv-&gt;data);
   data[length] = 17;
-  salsa20_crypt(&amp;ctx, length, data, cleartext-&gt;data);
+
+  if (r12)
+    salsa20r12_crypt(&amp;ctx, length, data, cleartext-&gt;data);
+  else
+    salsa20_crypt(&amp;ctx, length, data, cleartext-&gt;data);
   if (data[length] != 17)
     {
       fprintf(stderr, "Encrypt of %u bytes wrote too much!\nInput:", length);
@@ -157,7 +164,10 @@ test_salsa20(const struct tstring *key,
     }
   salsa20_set_key(&amp;ctx, key-&gt;length, key-&gt;data);
   salsa20_set_iv(&amp;ctx, iv-&gt;data);
-  salsa20_crypt(&amp;ctx, length, data, data);
+  if (r12)
+    salsa20r12_crypt(&amp;ctx, length, data, data);
+  else
+    salsa20_crypt(&amp;ctx, length, data, data);
 
   if (!MEMEQ(length, data, cleartext-&gt;data))
     {
@@ -177,6 +187,40 @@ test_salsa20(const struct tstring *key,
 void
 test_main(void)
 {
+  /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/reduced/12-rounds/verified.test-vectors?logsort=rev&amp;rev=210&amp;view=markup \
*/ +  test_salsa20r12(SHEX("80000000 00000000 00000000 00000000"),
+	       SHEX("00000000 00000000"),
+	       SHEX("00000000 00000000"),
+	       SHEX("FC207DBF C76C5E17"));
+
+  test_salsa20r12(SHEX("00400000 00000000 00000000 00000000"),
+	       SHEX("00000000 00000000"),
+	       SHEX("00000000 00000000"),
+	       SHEX("6C11A3F9 5FEC7F48"));
+
+  test_salsa20r12(SHEX("09090909090909090909090909090909"),
+	       SHEX("0000000000000000"),
+	       SHEX("00000000 00000000"),
+	       SHEX("78E11FC3 33DEDE88"));
+
+  test_salsa20r12(SHEX("1B1B1B1B1B1B1B1B1B1B1B1B1B1B1B1B"),
+	       SHEX("00000000 00000000"),
+	       SHEX("00000000 00000000"),
+	       SHEX("A6747461 1DF551FF"));
+
+  test_salsa20r12(SHEX("80000000000000000000000000000000"
+		    "00000000000000000000000000000000"),
+	       SHEX("00000000 00000000"),
+	       SHEX("00000000 00000000"),
+	       SHEX("AFE411ED 1C4E07E4"));
+
+  test_salsa20r12(SHEX("0053A6F94C9FF24598EB3E91E4378ADD"
+		    "3083D6297CCF2275C81B6EC11467BA0D"),
+	       SHEX("0D74DB42A91077DE"),
+	       SHEX("00000000 00000000"),
+	       SHEX("52E20CF8 775AE882"));
+
+
   /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/full/verified.test-vectors?logsort=rev&amp;rev=210&amp;view=markup \
*/  
   test_salsa20(SHEX("80000000 00000000 00000000 00000000"),
-- 
1.7.10.4



</body></email><email><emailId>20130325142408</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-25 14:24:08-0400</timestampReceived><subject>Re: [PATCH] Factorize timing functions to a separate file</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; This avoids unconditionally using clock_gettime in
&gt; {ecc,hogweed}-benchmark, falling back to clock() in these
&gt; as well.

Thanks a lot, checked in now.

I'm old fashioned enough to still value the ChangeLog file, so these
well done patches would be even better if they included GNU-style
ChangeLog entries. Maybe it would be easiest with ChangeLog separately
from the patch, since ChangeLog patches are very likely to create
conflicts, I could then apply the patch with git am (which I used for
the first time today), insert entries in the ChangeLog, and commit
--amend to get the ChangeLog together with the rest of the commit.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130325201302</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-25 20:13:02-0400</timestampReceived><subject>Re: salsa20r12</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; btw. the current _salsa20_core takes rounds as a variable. Wouldn't it
&gt; allow for better optimizations (loop unrolling actually) if that was a
&gt; static function, or that doesn't matter much?

I don't think it matters very much. But I haven't tried it.

My understanding is that this type of looping branches are handled
well by the branch predictor in current cpu:s. (In contrast to
unpredictable branches, which cost lots of cycles).

And since a single iteration should be 60-100 instructions, loop
overhead should be almost negligible. Unrolling is more important for
small loops.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130327090840</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-03-27 09:08:40-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Being able to compile nettle in older distributions is I think an
&gt; advantage.

Point taken.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130327093902</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-03-27 09:39:02-0400</timestampReceived><subject>Re: openssl tests</subject><body>

On Wed, Mar 27, 2013 at 10:07 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:

&gt;&gt;  In some systems the elliptic curves part of openssl is disabled. This
&gt;&gt; patch disables the openssl examples/tests if it does not exist (I had
&gt;&gt; issue with the EC tests).
&gt; Actual patch missing?

I was attached on the original e-mail. I'll send it in private if it
was removed by the list.

&gt; In config.h, all defined symbols should be defined to have the value 1,
&gt; which should make a plain #if work fine. Maybe there's something wrong
&gt; with how WITH_OPENSSL is handled?

The same issue was in the #if HAVE_CONFIG_H. See the original patch.

regards,
Nikos

</body></email><email><emailId>20130329072355</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-03-29 07:23:55-0400</timestampReceived><subject>Re: umac</subject><body>

On 03/28/2013 06:24 PM, Niels Möller wrote:


&gt; Maybe one could also have a default autoincrementing nonce?


If you do that please don't make it the default. There are several cases
in DTLS where the nonce isn't simply incrementing (e.g. when receiving
packets out-of-order).

&gt;&gt; Does this property exist in any other nettle algorithms?
&gt; It's (trivially) true for the block ciphers, and the gcm code separates
&gt; key state (struct gcm_key) from message state (struct gcm_ctx). The hmac
&gt; code does not, and I'd like to change that *if* I can find some reasonable
&gt; way to do it.


It is pretty trivial to overcome though, i.e., just use different
contexts on each thread (you don't even need to re-initialize - just
copy the context), so I wouldn't spend resources on it unless there is
some obvious advantage which I don't see.

regards,
Nikos

</body></email><email><emailId>20130204090757</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-02-04 09:07:57-0400</timestampReceived><subject>ECC status update for January</subject><body>

Here's a copy of the status update for January which I just submitted to
Internetfonden.

Regards,
/Niels

Nettle project funded by Internetfonden

Status update for January 2013


* Summary

Project has started. ARM-based test system is up and running. A
first implementation of elliptic curve-based signatures is done.


* Activities

Work on the project was initiated January 9, installing the test
hardware: A Pandaboard, based on a dual core Arm Cortex-A9 processor,
now running Debian GNU/Linux. I used the instructions on
http://www.eewiki.net/display/linuxonarm/PandaBoard for the
installation, but after cross compiling kernel etc, I can now use
native compiler and debugger for development.

I have confirmed that current versions of GNU Nettle and GNU GMP work
fine on this hardware. I have been reading ARM manuals (but not yet
done any ARM assembly coding), and reading up on relevant methods for
elliptic curve operations.

For the elliptic curves, I have decided to aim for "side-channel
silent" algorithms. This means that for each curve, instructions
executed and memory access pattern must not depend on the input data.
This is to avoid leaking information about secret keys to an attacker
monitoring the timing of operations, as well as to an attacker running
an untrusted process which can manipulate and observe cache misses.

Most of January have been spent on implementing the elliptic curve
machinery needed for creating and verifying ECDSA signatures, over the
standard curves secp192r1, secp224r1, secp256r1, secp384r1 and
secp521r1.

The work-in-progress code as, well as various working notes, is
published as a public git repository, see
http://git.lysator.liu.se/nettle/se-nettle-2013.

During the month, roughly 130 working hours have been spent on the
project.


* About elliptic curves

Elliptic curve operations are based on Jacobi coordinates
(http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html).

Multiplication involving the group generator use a special case of
Pippenger's algorithm (described in Daniel J. Bernstein's draft paper
http://cr.yp.to/papers.html#pippenger). This algorithm has later been
rediscovered and is covered by a couple of, most likely invalid,
patents (also explained by Daniel J. Bernstein). With current
parameter choices, we use precomputed tables of modest size, roughly
16 KByte for each supported curve, which are compiled into the
library.

I have not yet decided on the algorithm to use for multiplication
involving an arbitrary point. The current implementation uses a
side-channel silent variant of the most basic binary multiplication;
it can be improved by using window-based algorithm, similar to what
GMP uses for the function mpz_powm_sec.

The implementation includes a testsuite, and it is tested both on
x86_64 (a 64-bit PC platform) and on the Pandaboard (32-bit ARM
platform). It is also benchmarked on both those platforms. To give
some quantitative numbers, I compare performance to 2048-bit RSA, and
measure number of signing and verifications operations that can be
done per ms.

Intel i5, 3.4 GHz:

 name size  sign / ms verify / ms
  rsa 1024     6.3228   102.9886
  rsa 2048     0.9559    29.5987
  dsa 1024    11.1867     5.7500
ecdsa  192    17.9380     3.7946
ecdsa  224    10.0423     2.0285
ecdsa  256     9.3953     2.2191
ecdsa  384     3.5025     0.7830
ecdsa  521     2.1572     0.5291

ARM Cortex A9, 1 GHz:

 name size  sign / ms verify / ms
  rsa 1024     0.2627     4.5487
  rsa 2048     0.0392     1.2488
  dsa 1024     0.4691     0.2377
ecdsa  192     1.2888     0.2883
ecdsa  224     0.7856     0.1790
ecdsa  256     0.5900     0.1280
ecdsa  384     0.2423     0.0545
ecdsa  521     0.1327     0.0296

When looking at the verify operations, ECDSA is not competitive to
RSA, and maybe never will. RSA has the advantage of using a small
public exponent; in these benchmarks, I use e = 65537.

For signing operations, let us focus on ECDSA 224, which is believed
to give slightly higher security than RSA 2048 (see
http://www.keylength.com/en/3/). Then ECDSA signatures, with the
current code, is a factor 10 faster on ARM, and a factor 20 faster on
x86_64.

When comparing the benchmark numbers, one should keep in mind that
performance is not everything. In some applications, the smaller size
of keys and signatures for ECDSA is also of high importance.


* Remaining tasks

For elliptic curve signatures, one large remaining task is designing,
implementing, and documenting the public programming interface. This
is part of the integration work required, before the elliptic curve
implementation can be incorporated in the Nettle library.

For optimizations, performance of the verify operations can be
improved by algorithmic improvements. Performance of all operations
can be further improved by platform-specific optimizations,
implementing a few key functions in assembly.

It's also possible to write alternative elliptic curve primitives,
without the requirement of side-channel silence. These could be used
to speed up operations which don't have any secret inputs, in
particular, verification of signatures. I give that a lower priority
than the other potential optimizations, though.

For the other sub-project, to do ARM-specific optimizations for
cryptographic primitives unrelated to elliptic curves, no work has
been done during January, beyond a general study of the ARM
architecture. Most important functions are the AES block cipher and
the hash functions in the SHA family: SHA1, SHA256, SHA512, and
possibly also the recently standardized SHA3 hash function. Also the
memxor function is a candidate to be the first ARM-assembly function
in Nettle.

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130206185702</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-02-06 18:57:02-0400</timestampReceived><subject>ARM support</subject><body>

I've now pushed in some configure tweaks to support arm (more
specifically, configure recognizes armv7l*.

As a warmup, I implemented memxor in arm assembly. Seems to work, and
it's a modest performance improvement over the C code (in the aligned
case, both memxor and memxor3 do 0.75 cycles per byte when I benchmark on
Cortex-A9). Could surely be further improved.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130217200958</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-02-17 20:09:58-0400</timestampReceived><subject>Re: ECC benchmarks</subject><body>

On 02/17/2013 09:47 AM, Niels Möller wrote:

&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt; 
&gt;&gt; That's pretty good table. It would be nice to have a comparison of
&gt;&gt; modinv with mpz_invert as a baseline (you also don't need to use a
&gt;&gt; timing resistant modinv during verification).
&gt; 
&gt; That would make sense. On the mpn level, the corresponding GMP function
&gt; is mpn_gcdext.
&gt; 
&gt;&gt; How hard could it be to add the wmNAF multiplication from ecc_mulmod.c
&gt;&gt; in gnutls to this list for comparison?
&gt; Do you have some example code to use this gnutls function? Then I'm
&gt; afraid it might also be a bit tricky to get linking right if we want to
&gt; have it all in the same benchmark executable.


This is not exported from gnutls (we only export the high level API). I
meant copying it from there with the functions it depends on (they
aren't be many) and adding it to the test you have.

regards,
Nikos

</body></email><email><emailId>20130218151836</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-02-18 15:18:36-0400</timestampReceived><subject>Re: ECC low-level interface</subject><body>

On Mon, Feb 18, 2013 at 2:30 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;&gt; So has this particular case higher probability than k being randomly
&gt;&gt; chosen to be 3? (I've not seen this test anywhere else, that's why I'd
&gt;&gt; be curious on why you mention this test).
&gt; If the verify code is done as
&gt;   P1 = u1*G
&gt;   P2 = u2*Y
&gt;   P = P1 + P2
&gt; then an equivalent test is needed there, sine we have to do
&gt;   if (P1 == P2)
&gt;     P = ecc_dup (P1)
&gt;   else
&gt;     P = ecc_add(P1 ,P2)
&gt; And if we do this test, it's trivial to extend it to
&gt;
&gt;   if (P1 == P2)
&gt;     {
&gt;       P = ecc_dup (P1)
&gt;       output private key (it's -u2/u1 (mod q) or something like that)

That's an interesting case :) Several implementations do not include
that case. I was told of a fault injection attack in hardware
implementations to force them reach that state (and do an addition
instead), but that wouldn't be of much importance here (since it is a
verification function). I don't know if caring about that case makes
sense. At best I think that looks like the definition for the
unlikely() macro.

regards,
Nikos

</body></email><email><emailId>20130218161205</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-02-18 16:12:05-0400</timestampReceived><subject>ECC integration</subject><body>

I'm working on integration of the new ECC code into nettle, on a
separate branch, see
http://git.lysator.liu.se/nettle/nettle/commits/ecc-support

I've probably broken cross-compilation support, but otherwise it should
be working.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130104202847</emailId><senderName>James Cloos</senderName><senderEmail>cloos@jhcloos.com</senderEmail><timestampReceived>2013-01-04 20:28:47-0400</timestampReceived><subject>Re: Getting closer to nettle-2.6</subject><body>

&gt;&gt;&gt;&gt;&gt; "NM" == Niels Möller &lt;nisse@lysator.liu.se&gt; writes:

NM&gt; Thanks for the hint. Maybe I can try that, it sounds like a fairly easy
NM&gt; fix. If I can get the code run at three instructions per cycle, that
NM&gt; would be a pretty nice speedup on amd processors.

Indeed.

&gt;&gt; | Whenever possible, use loads and stores of the same data length. (See
&gt;&gt; | 6.3, ‘Store-to-Load Forwarding Restrictions" on page 98 for more
&gt;&gt; | information.)

NM&gt; Not sure how to interpret this. The interesting cases here are:

In the context of saving a 128-bit xmm register and reading the halves
into two 64-big integer registers, I think it means make sure you use
the instruction which includes the 0x66 prefix octet (which specifies
that the 128 bits are two 64-bit values rather than four 32-bit values).

I don't see a 4x32 version of MOVDQA in the original xmm book, just the
2x64, so it shouldn't be an issue for this application.  If there were,
you'd want to be sure to use the '66 0F 6F /r' version and not the
putative '0F 6F /r' version.

It is more of an issue when dealing with packed floats vs packed doubles.
Eg, the XORPS and XORPD both do a 128-bit bit-for-bit XOR, but if you
use the XORPS version in code otherwise dealing with packed doubles, or
visa-versa, the pipeline will stall.

There is a similar issue when mixing float or double instructions with
non-floating-point loads and stores.

I think that, internally, they use different register files for packed
doubles and packed singles.  Or, more generally, packed 64-bit-at-a-time
vs packed-32-bit-at-a-time.  But that is conjecture.

-JimC
-- 
James Cloos &lt;cloos@jhcloos.com&gt;         OpenPGP: 1024D/ED7DAEA6

</body></email><email><emailId>20130116211132</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-01-16 21:11:32-0400</timestampReceived><subject>ANNOUNCE: Nettle-2.6</subject><body>

I'm happy to annnounce a new version of GNU Nettle, a low-level
cryptographics library. The Nettle home page can be found at
http://www.lysator.liu.se/~nisse/nettle/.

The release is signed using a new gpg key (2560R/28C67298). That key is
also signed by the previous, 13 year old, release key (1024D/A8F4C2FD).

NEWS for the 2.6 release

	Bug fixes:

	* Fixed a bug in ctr_crypt. For zero length (which should be a
	  NOP), it sometimes incremented the counter. Reported by Tim
	  Kosse.

	* Fixed a small memory leak in nettle_realloc and
          nettle_xrealloc.

	New features:

	* Support for PKCS #5 PBKDF2, to generate a key from a
          password or passphrase. Contributed by Simon Josefsson.
          Specification in RFC 2898 and test vectors in RFC 6070.

	* Support for SHA3.
	  
	* Support for the GOST R 34.11-94 hash algorithm. Ported from
	  librhash by Nikos Mavrogiannopoulos. Written by Aleksey
	  Kravchenko. More information in RFC4357. Test vectors taken
	  from the GOST hash wikipedia page.

	Miscellaneous:

	* The include file &lt;nettle/sha.h&gt; has been split into
          &lt;nettle/sha1.h&gt; and &lt;nettle/sha2.h&gt;. For now, sha.h is kept
          for backwards compatibility and it simply includes both
          files, but applications are encouraged to use the new names.
          The new SHA3 functions are declared in &lt;nettle/sha3.h&gt;.

	* Testsuite can be run under valgrind, using

	  make check EMULATOR='$(VALGRIND)'

	  For this to work, test programs and other executables now
	  deallocate storage.
	  
	* New configure options --disable-documentation and
          --disable-static. Contributed by Sam Thursfield and Alon
	  Bar-Lev, respectively.
	  
	* The section on hash functions in the manual is split into
          separate nodes for recommended hash functions and legacy
          hash functions.

	* Various smaller improvements, most of them portability
          fixes. Credits go to David Woodhouse, Tim Rühsen, Martin
          Storsjö, Nikos Mavrogiannopoulos, Fredrik Thulin and Dennis
          Clarke.

	Finally, a note on the naming of the various "SHA" hash
	functions. Naming is a bit inconsistent; we have, e.g.,

	  SHA1: sha1_digest
	  SHA2: sha256_digest   (not sha2_256_digest)
	  SHA3: sha3_256_digest

	Renaming the SHA2 functions to make Nettle's naming more
	consistent has been considered, but the current naming follows
	common usage. Most documents (including the specification for
	SHA2) refer to 256-bit SHA2 as "SHA-256" or "SHA256" rather
	than "SHA2-256".

	The libraries are intended to be binary compatible with
	nettle-2.2 and later. The shared library names are
	libnettle.so.4.5 and libhogweed.so.2.3, with sonames still
	libnettle.so.4 and libhogweed.so.2

Available at

  http://ftp.gnu.org/gnu/nettle/nettle-2.6.tar.gz
  ftp://ftp.gnu.org/gnu/nettle/nettle-2.6.tar.gz
  http://www.lysator.liu.se/~nisse/archive/nettle-2.6.tar.gz

and soon also at

  ftp://ftp.lysator.liu.se/pub/security/lsh/nettle-2.6.tar.gz

Happy hacking,
/Niels Möller

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130126014459</emailId><senderName>James Cloos</senderName><senderEmail>cloos@jhcloos.com</senderEmail><timestampReceived>2013-01-26 01:44:59-0400</timestampReceived><subject>Re: ECC plans</subject><body>

&gt;&gt;&gt;&gt;&gt; "NM" == Niels Möller &lt;nisse@lysator.liu.se&gt; writes:

NM&gt; So first question is naming; what's the most established names for
NM&gt; these curves? It seems gnutls uses, e.g., "SECP256R1", I guess we
NM&gt; can just follow that (rather than, e.g, "P-256", as it's called in
NM&gt; the DSA spec fips-186-3)?

RFC 6239 (Suite B Crypto Suites for SSH) has this to say about naming:

,----&lt; excerpt from rfc6239.txt &gt;
|  Curve        NIST name        SECG name     OID [SEC2]
|  ---------------------------------------------------------------
|  P-256        nistp256         secp256r1     1.2.840.10045.3.1.7
|  P-384        nistp384         secp384r1     1.3.132.0.34
`----

(Based on [SEC2], I presume the next line would be:

   ?-???        nistp521         secp521r1     1.3.132.0.35
)

So it looks liek the secp...r1 names are as good as any.

-JimC
-- 
James Cloos &lt;cloos@jhcloos.com&gt;         OpenPGP: 1024D/ED7DAEA6

</body></email><email><emailId>20130212115659</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-02-12 11:56:59-0400</timestampReceived><subject>ECC low-level interface</subject><body>

I'd like to post the interface I use for low-level ecc functions.

All functions are intended to be side-channel silent. I have tried to
stick to the nettle principle of "no allocation" (I mostly call
low-level gmp functions which don't allocate storage). Functions which
need scratch space gets this space from the caller, as an extra
argument. And for the function foo, there's a corresponding function
foo_itch, saying how much working storage is needed. Sizes are in units
of mp_limb_t.

Of these low-level functions, the highest level ones are ecc_mul_g and
ecc_mul_a. Feedback is appreciated. The rest of the code is available at
http://git.lysator.liu.se/nettle/se-nettle-2013

Regards,
/Niels

/* ecc.h */

/* nettle, low-level cryptographics library
 *
 * Copyright (C) 2013 Niels MÃ¶ller
 *  
 * The nettle library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 * 
 * The nettle library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with the nettle library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02111-1301, USA.
 */

/* Development of Nettle's ECC support was funded by Internetfonden. */

#ifndef NETTLE_ECC_H_INCLUDED
#define NETTLE_ECC_H_INCLUDED

#include &lt;stdint.h&gt;

#include &lt;gmp.h&gt;

/* The contets of this struct is internal. */
struct ecc_curve;

extern const struct ecc_curve ecc_secp_192r1;
extern const struct ecc_curve ecc_secp_224r1;
extern const struct ecc_curve ecc_secp_256r1;
extern const struct ecc_curve ecc_secp_384r1;
extern const struct ecc_curve ecc_secp_521r1;

/* Points on a curve are represented as arrays of mp_limb_t. For some
   curves, point coordinates are represented in montgomery form. We
   use either affine coordinates x,y, or Jacobian coordinates X, Y, Z,
   where x = X/Z^2 and y = X/Z^2.

   Since we use additive notation for the groups, the infinity point
   on the curve is denoted 0. The infinity point can be represented
   with x = y = 0 in affine coordinates, and Z = 0 in Jacobian
   coordinates. However, note that most of the ECC functions do *not*
   support infinity as an input or output.
*/

/* FIXME: Also provided some compile time constants? */

/* Returns the size of a single coordinate. */
mp_size_t
ecc_size (const struct ecc_curve *ecc);

/* Size of a point, using affine coordinates x, y. */
mp_size_t
ecc_size_a (const struct ecc_curve *ecc);

/* Size of a point, using jacobian coordinates X, Y and Z. */
mp_size_t
ecc_size_j (const struct ecc_curve *ecc);

/* FIXME: Rename the low-level (and side-channel silent) functions to
   _ecc_*, and provide public ecc_* functions which handle the
   infinity points properly? */

/* Converts the affine coordinates of a point into montgomery form, if
   used for this curve. */
mp_size_t
ecc_a_to_a_itch (const struct ecc_curve *ecc);
void
ecc_a_to_a (const struct ecc_curve *ecc,
	    mp_limb_t *r, const mp_limb_t *p,
	    mp_limb_t *scratch);

/* Converts a point P in affine coordinates into a point R in jacobian
   coordinates. If INITIAL is non-zero, and the curve uses montgomery
   coordinates, also convert coordinates to montgomery form. */
void
ecc_a_to_j (const struct ecc_curve *ecc,
	    int initial,
	    mp_limb_t *r, const mp_limb_t *p);

/* Converts a point P in jacobian coordinates into a point R in affine
   coordinates. If FLAGS has bit 0 set, and the curve uses montgomery
   coordinates, also undo the montgomery conversion. If flags has bit
   1 set, produce x coordinate only. */
mp_size_t
ecc_j_to_a_itch (const struct ecc_curve *ecc);
void
ecc_j_to_a (const struct ecc_curve *ecc,
	    int flags,
	    mp_limb_t *r, const mp_limb_t *p,
	    mp_limb_t *scratch);

/* Group operations */


/* Point doubling, with jacobian output and affine input. Corner
   cases: Correctly sets R = 0 (r_Z = 0) if p = 0 or 2p = 0. */
mp_size_t
ecc_dup_ja_itch (const struct ecc_curve *ecc);
void
ecc_dup_ja (const struct ecc_curve *ecc,
	    mp_limb_t *r, const mp_limb_t *p,
	    mp_limb_t *scratch);

/* Point doubling, with jacobian input and output. Corner cases:
   Correctly sets R = 0 (r_Z = 0) if p = 0 or 2p = 0. */
mp_size_t
ecc_dup_jj_itch (const struct ecc_curve *ecc);
void
ecc_dup_jj (const struct ecc_curve *ecc,
	    mp_limb_t *r, const mp_limb_t *p,
	    mp_limb_t *scratch);


/* Point addition, with jacobian output, one jacobian input and one
   affine input. Corner cases: Fails for the cases

     P = Q != 0                       Duplication of non-zero point
     P = 0, Q != 0 or P != 0, Q = 0   One input zero
   
     Correctly gives R = 0 if P = Q = 0 or P = -Q. */
mp_size_t
ecc_add_jja_itch (const struct ecc_curve *ecc);
void
ecc_add_jja (const struct ecc_curve *ecc,
	     mp_limb_t *r, const mp_limb_t *p, const mp_limb_t *q,
	     mp_limb_t *scratch);

/* Point addition with Jacobian input and output. */
mp_size_t
ecc_add_jjj_itch (const struct ecc_curve *ecc);
void
ecc_add_jjj (const struct ecc_curve *ecc,
	     mp_limb_t *r, const mp_limb_t *p, const mp_limb_t *q,
	     mp_limb_t *scratch);


/* Computes N * the group generator. N is an array of ecc_size()
   limbs. It must be in the range 0 &lt; N &lt; group order, then R != 0,
   and the algorithm can work without any intermediate values getting
   to zero. */ 
mp_size_t
ecc_mul_g_itch (const struct ecc_curve *ecc);
void
ecc_mul_g (const struct ecc_curve *ecc, mp_limb_t *r,
	   const mp_limb_t *np, mp_limb_t *scratch);

/* Computes N * P. The scalar N is the same as for ecc_mul_g. P is a
   non-zero point on the curve, in affine coordinates. Pass a non-zero
   INITIAL if the point coordinates have not previously been converted
   to Montgomery representation. Output R is a non-zero point, in
   Jacobian coordinates. */
mp_size_t
ecc_mul_a_itch (const struct ecc_curve *ecc);
void
ecc_mul_a (const struct ecc_curve *ecc,
	   int initial, mp_limb_t *r,
	   const mp_limb_t *np, const mp_limb_t *p,
	   mp_limb_t *scratch);

#endif /* NETTLE_ECC_H_INCLUDED */



-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130213135135</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-02-13 13:51:35-0400</timestampReceived><subject>Re: ECC low-level interface</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I'd like to post the interface I use for low-level ecc functions.

And here's the current interface for ECDSA functions. Low-level
functions with similar conventions as the low-level ecc functions. And
high-level functions using mpz_t for arguments, and using the same
allocation function as GMP for storage.

For the RSA signature functions, we have a larger number of functions of
the form rsa_&lt;hash-algorithm&gt;_sign, mostly because the pkcs#1 padding
wants to embed the hash algorithm object identifier.

But for ecdsa, do we need any functions like that? I guess, for
convenience and consistency, it would make sense with some functions
like

  void
  ecdsa_sha256_sign (const struct ecdsa_private_key *key,
                     void *random_ctx, nettle_random_func *random,
                     struct sha256_ctx *hash,
                     struct dsa_signature *signature);

which take a hashing context as argument. Which hash functions are
people using for ecdsa with the various curves? RFC 4754 (IKE and IKEv2
Authentication Using ECDSA) defines:

        Digital
       Signature
       Algorithm            Elliptic Curve Group        Hash Function
      -----------        --------------------------    ---------------
       ECDSA-256          256-bit random ECP group        SHA-256
       ECDSA-384          384-bit random ECP group        SHA-384
       ECDSA-521          521-bit random ECP group        SHA-512

Is this typical? (Then it's the first time I've seen a specification
using). I implement also secp192r1 and secp224r1, which I guess would be
used with sha256 (or possibly sha224).

Regards,
/Niels

/* ecdsa.h */

/* nettle, low-level cryptographics library
 *
 * Copyright (C) 2013 Niels Möller
 *  
 * The nettle library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 * 
 * The nettle library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with the nettle library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02111-1301, USA.
 */

/* Development of Nettle's ECC support was funded by Internetfonden. */

#ifndef NETTLE_ECDSA_H_INCLUDED
#define NETTLE_ECDSA_H_INCLUDED

#include &lt;nettle/dsa.h&gt;

#include "ecc.h"

/* High-level ECDSA interface. Uses mpz interface, and allocates
   storage using the same allocation functions as GMP. */
struct ecdsa_public_key
{
  const struct ecc_curve *ecc;
  /* Allocated using the same allocation function as GMP. */
  mp_limb_t *Y;
};

struct ecdsa_private_key
{
  const struct ecc_curve *ecc;
  /* Size ecc-&gt;size. */
  mp_limb_t *z;
};

void
ecdsa_public_key_init (struct ecdsa_public_key *pub,
		       const struct ecc_curve *ecc);
void
ecdsa_public_key_clear (struct ecdsa_public_key *pub);

int
ecdsa_set_public_key (struct ecdsa_public_key *pub,
		      const mpz_t x, const mpz_t y);
void
ecdsa_get_public_key (struct ecdsa_public_key *pub,
		      mpz_t x, mpz_t y);

void
ecdsa_private_key_init (struct ecdsa_private_key *key,
			const struct ecc_curve *ecc);
void
ecdsa_private_key_clear (struct ecdsa_private_key *key);

int
ecdsa_set_private_key (struct ecdsa_private_key *key,
		       const mpz_t z);
void
ecdsa_get_private_key (struct ecdsa_private_key *key,
		       mpz_t z);

void
ecdsa_sign (const struct ecdsa_private_key *key,
	    void *random_ctx, nettle_random_func *random,
	    unsigned digest_length,
	    const uint8_t *digest,
	    struct dsa_signature *signature);

int
ecdsa_verify (const struct ecdsa_public_key *pub,
	      unsigned length, const uint8_t *digest,
	      const struct dsa_signature *signature);

void
ecdsa_generate_keypair (struct ecdsa_public_key *pub,
			struct ecdsa_private_key *key,
			void *random_ctx, nettle_random_func *random);

/* Low-level ECDSA interface. */

mp_size_t
_ecdsa_sign_itch (const struct ecc_curve *ecc);
void
_ecdsa_sign (const struct ecc_curve *ecc,
	     /* Private key */
	     const mp_limb_t *zp,
	     /* Random nonce, must be invertible mod ecc group
		order. */
	     const mp_limb_t *kp,
	     unsigned length, const uint8_t *digest,
	     mp_limb_t *rp, mp_limb_t *sp, mp_limb_t *scratch);


mp_size_t
_ecdsa_verify_itch (const struct ecc_curve *ecc);
int
_ecdsa_verify (const struct ecc_curve *ecc,
	       const mp_limb_t *pp, /* Public key */
	       unsigned length, const uint8_t *digest,
	       const mp_limb_t *rp, const mp_limb_t *sp,
	       mp_limb_t *scratch);

#endif /* NETTLE_ECDSA_H_INCLUDED */

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130117090021</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-01-17 09:00:21-0400</timestampReceived><subject>ECC plans</subject><body>

I've started to read up on ECC again (and I've also spent some time
reading up on ARM architecture, but that's for a different message).

As I wrote earlier, for a start I'll limit the support to standard NIST
curves. So first question is naming; what's the most established names
for these curves? It seems gnutls uses, e.g., "SECP256R1", I guess we
can just follow that (rather than, e.g, "P-256", as it's called in the
DSA spec fips-186-3)?

My current plan is as follows:

1. The top-level functions for ECDSA and the like will use mpz_t to
   represent point coordinates, exponents, etc, just like the current
   DSA code.
  
2. Internally, I think I want to use GMP's lower-level mpn interface,
   for two reasons: (i) that should make it possible, with some effort,
   to use ecc functions without any allocation inside Nettle. (ii) For
   performance, I'd like to do specific mod p functions for the various
   curves, and this is done best on top of functions such as mpn_add_n
   and mpn_addmul_1. After all, the primes p used for the curves are
   carefully chosen to have special structure, to enable optimizations.

3. Representation of a curve will for now be an opaque struct. The
   header will just declare
  
     struct ecc_curve;
     extern const struct ecc_curve nettle secp256r1;
  
   Tables for point multiplication will be compiled into the library.
   They will be somewhat machine dependent, depending on the GMP limb
   size, so they have to be generated at build time.
  
4. I think I'll use Jacobian coordinates. These have a penalty for
   addition of arbitrary points, but we can try to use multiplication
   algorithms where one of the points being added always is a constant,
   which can be represented in normalized form. Then there's no penalty
   over plain homogeneous coordinates (this is the operation called
   "madd" in gnutls sources).

   I've been intrigued by the recent (2007) breakthrough of Edwards
   curves, but as far as I understand, that can't easily be applied to
   the standard NIST curves. See
   http://cr.yp.to/newelliptic/newelliptic.html.
  
5. For point multiplication with the fixed generator, I think I'll use
   the L=1 special case of Pippenger's algorithm, described in Daniel
   Bernstein's paper http://cr.yp.to/papers/pippenger.pdf. I think this
   is more or less the same as the "comb" method or "Lim-Lee"-method, but
   predating any bogus patents on the algorithm.
  
   (I can try to summarize the algorithm later, but it's pretty simple
   once one gets past the notation).
   
   I think it's fairly easy to silence with regards to timing and cache
   side-channels. One nice feature is that even with pretty large
   tables, not all of the table index bits are data-dependent (extracted
   from the exponent). Then it should be practical to read all possible
   table entries and use masking to copy the selected one, see
   http://gmplib.org:8000/gmp/file/eee6b8e54765/mpn/generic/tabselect.c.
  
   This operation is the working horse for ECDSA signing, and for the
   first half of ECDH.
  
   I'm not sure how large tables it makes sense to create for each
   curve, but I guess somewehere between a few KByte to at most 100
   Kbyte. This could be made configurable at compile time, but I'd
   expect almost all users to stick to the default tables.
  
6. For general point multiplication, I tend towards using a simple
   non-sliding window, with a small point-specific table computed at run
   time. If the table is small enough, it might make sense to normalize
   the entries. As far as I understand, one can't beat the plain binary
   algorithm by a large factor; the algorithms I'm aware of only reduce
   the number of adds, but not the number of dups.
  
   This operation is the working horse for the second half of ECDH.
  
7. For verifying ECDSA signatures, one needs to operate on two points,
   computing e_1 G + e_2 Y, where G is the generator (and hence offers
   possibilities for precomputation), and Y is the public key.
  
   I haven't yet looked into this in detail, but it seems clear this
   should be done as a single operation, with only one chain of point
   duplications. Preferably, it should be implemented in such a way that
   the tables for G (from 5 above) can be reused.

Comments? Does this make sense, or is it anything which ought to be done
differently?

I have had a quick look at the gnutls code. wmNAF makes me a bit uneasy
when I think about side channels; there seems to be a lot of branches
depending on exponent bits.

In the point addition, it seems hard to avoid special cases when adding
a point to itself or to its negation, or adding the zero point. Which
will cause sidechannel leaks. Not sure what to do about that, but there
are some papers on "unified" ecc operations, or maybe one can do
something analogous to rsa blinding.

As far as I understand, for point multiplication in both ECDSA and ECDH,
it's only the scalar that ever is secret, the points multiplied are
always public. Are there other uses of point multiplication where also
the point is secret?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130117195454</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-01-17 19:54:54-0400</timestampReceived><subject>Re: ECC plans</subject><body>

On 01/17/2013 10:00 AM, Niels Möller wrote:

&gt; As I wrote earlier, for a start I'll limit the support to standard NIST
&gt; curves. So first question is naming; what's the most established names
&gt; for these curves? It seems gnutls uses, e.g., "SECP256R1", I guess we
&gt; can just follow that (rather than, e.g, "P-256", as it's called in the
&gt; DSA spec fips-186-3)?


Any would do. In any case both are used, so aliases from one to another
should be good. In the context of TLS the SECP names are used.

&gt; 5. For point multiplication with the fixed generator, I think I'll use
&gt;    the L=1 special case of Pippenger's algorithm, described in Daniel
&gt;    Bernstein's paper http://cr.yp.to/papers/pippenger.pdf. I think this
&gt;    is more or less the same as the "comb" method or "Lim-Lee"-method, but
&gt;    predating any bogus patents on the algorithm.


How does this algorithm compare to others? The reason I insist on
performance is that it would be hard for gnutls to switch to the new
functions if they are significantly slower than the current ones, and
I'd like to switch eventually to nettle for all operations including ECC.

&gt; 6. For general point multiplication, I tend towards using a simple

&gt;    non-sliding window, with a small point-specific table computed at run
&gt;    time. If the table is small enough, it might make sense to normalize
&gt;    the entries. As far as I understand, one can't beat the plain binary
&gt;    algorithm by a large factor; the algorithms I'm aware of only reduce
&gt;    the number of adds, but not the number of dups.


I really cannot answer with any facts since I need to check the details,
but I've not seen other efficient implementations using a non-sliding
window for that. Are you sure that the effect is insignificant?
Additions aren't that negligible. Also for that part you don't need
constant time. In ECDSA you only multiply the fixed generator with the
key (in ECDH you also don't care unless it is fixed key ECDH).

&gt; 7. For verifying ECDSA signatures, one needs to operate on two points,
&gt;    computing e_1 G + e_2 Y, where G is the generator (and hence offers
&gt;    possibilities for precomputation), and Y is the public key.


I would put that of lower priority that signing. Servers (where
performance matters) rarely verify ECDSA keys.

&gt; I have had a quick look at the gnutls code. wmNAF makes me a bit uneasy
&gt; when I think about side channels; there seems to be a lot of branches
&gt; depending on exponent bits.


Why is that? Did you see any issues on the timing resistant version of
the function?

&gt; In the point addition, it seems hard to avoid special cases when adding
&gt; a point to itself or to its negation, or adding the zero point. 


Do you mean the infinity points or the point (0,0,0)? I think it can be
catched by checking whether a point lies on a curve prior to the
verification operation (0,0,0 isn't a point in the projective space either).

&gt; As far as I understand, for point multiplication in both ECDSA and ECDH,
&gt; it's only the scalar that ever is secret, the points multiplied are
&gt; always public.


Yes.

&gt; Are there other uses of point multiplication where also
&gt; the point is secret?


None that I'm aware of in ECDH or ECDSA.

regards,
Nikos

</body></email><email><emailId>20130117201906</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-01-17 20:19:06-0400</timestampReceived><subject>Re: ECC plans</subject><body>

On 01/17/2013 08:54 PM, Nikos Mavrogiannopoulos wrote:

&gt;&gt; 6. For general point multiplication, I tend towards using a simple
&gt;&gt;    non-sliding window, with a small point-specific table computed at run
&gt;&gt;    time. If the table is small enough, it might make sense to normalize
&gt;&gt;    the entries. As far as I understand, one can't beat the plain binary
&gt;&gt;    algorithm by a large factor; the algorithms I'm aware of only reduce
&gt;&gt;    the number of adds, but not the number of dups.


btw. moving from the sliding window version (the one I submitted last
year) to wmnaf, gave 7-16% performance boost in transaction/sec on
ECDH/ECDSA depending on the size of the curve. So given that the sliding
window method is faster than the simple, it could be quite a difference.

regards,
Nikos

</body></email><email><emailId>20130118083529</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-01-18 08:35:29-0400</timestampReceived><subject>Re: ECC plans</subject><body>

Many thanks for your comments.

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; On 01/17/2013 10:00 AM, Niels Möller wrote:
&gt;
&gt;&gt; So first question is naming; what's the most established names
&gt;&gt; for these curves?

&gt; Any would do. In any case both are used, so aliases from one to another
&gt; should be good. In the context of TLS the SECP names are used.

I'll stick to secp names for now then. And I think aliases are for the
documentation.

&gt;&gt; 5. For point multiplication with the fixed generator, I think I'll use
&gt;&gt;    the L=1 special case of Pippenger's algorithm, described in Daniel
&gt;&gt;    Bernstein's paper http://cr.yp.to/papers/pippenger.pdf. I think this
&gt;&gt;    is more or less the same as the "comb" method or "Lim-Lee"-method, but
&gt;&gt;    predating any bogus patents on the algorithm.
&gt;
&gt;
&gt; How does this algorithm compare to others?

If I read the gnutls code right, ecc_mulmod_cache makes the same number
of ecc_projective_dbl_point calls as the non-cached version? If that is
right, any comb-like algorithm should be able to beat it, since those
algorithms reduce the number of point doublings and the number of
iterations in the outer loop. Depending on selected table size, of
course.

Do you have any ecc benchmarking code I could borrow?

&gt; The reason I insist on
&gt; performance is that it would be hard for gnutls to switch to the new
&gt; functions if they are significantly slower than the current ones,

I understand that. But there's going to be a some cost to make
operations side-channel silent (a lot more on what I mean by that
below).

&gt;&gt; 6. For general point multiplication, I tend towards using a simple
&gt;
&gt;&gt;    non-sliding window, with a small point-specific table computed at run
&gt;&gt;    time. If the table is small enough, it might make sense to normalize
&gt;&gt;    the entries. As far as I understand, one can't beat the plain binary
&gt;&gt;    algorithm by a large factor; the algorithms I'm aware of only reduce
&gt;&gt;    the number of adds, but not the number of dups.
&gt;
&gt;
&gt; I really cannot answer with any facts since I need to check the details,
&gt; but I've not seen other efficient implementations using a non-sliding
&gt; window for that.

gmp's mpz_powm_sec uses a non-sliding window (and other alternative
algorithms to make running time depend only on input size, not on actual
values; the most sever slowdown is for division, used when converting
inputs to montgomery representation).

It seems to be 20% slower them mpz_powm for sizes comparable to ecc
parameters (I tried with limbs size 16),

  ~/hack/gmp/tune$ ./speed -s16 -r mpz_powm mpz_powm_sec
  overhead 0.000000003 secs, precision 10000 units of 6.25e-10 secs, CPU
  freq 1600.00 MHz
               mpz_powm  mpz_powm_sec
  16       #0.000414344        1.2084

Not all of the slowdown are from the non-sliding window.

&gt; Also for that part you don't need
&gt; constant time. [...] (in ECDH you also don't care unless it is fixed key ECDH).

In ECDH, any data dependent timing does leak some information about your
secret exponent. What you're saying, if I understand you correctly, is
that since you usually use each secret exponent only once, an attacker
will in most cases not be able to collect enough information to do any
damage. 

Anyway, algorithm choice for this operation is not set in stone, and if
we do version which doesn't promise constant time, there's more freedom
in choosing algorithm.

&gt; Additions aren't that negligible. Also for that part you don't need
&gt; constant time. In ECDSA you only multiply the fixed generator with the
&gt; key (in ECDH you also don't care unless it is fixed key ECDH).
&gt;
&gt;&gt; 7. For verifying ECDSA signatures, one needs to operate on two points,
&gt;&gt;    computing e_1 G + e_2 Y, where G is the generator (and hence offers
&gt;&gt;    possibilities for precomputation), and Y is the public key.
&gt;
&gt;
&gt; I would put that of lower priority that signing. Servers (where
&gt; performance matters) rarely verify ECDSA keys.

Noted (although I'm not sure I agree it's less important than signing
performance).

&gt;&gt; I have had a quick look at the gnutls code. wmNAF makes me a bit uneasy
&gt;&gt; when I think about side channels; there seems to be a lot of branches
&gt;&gt; depending on exponent bits.
&gt;
&gt;
&gt; Why is that? Did you see any issues on the timing resistant version of
&gt; the function?

Let me first explain what I mean when I talk about a "side-channel
silent" function. That means that if we call the function with operands
which are of the same size, but otherwise different, the function should
execute exactly the same sequence of instructions in both cases, and
access memory in exactly the same pattern.

If one then assumes that the underlying machine instructions have data
independent timing (true for most current cpus), we leak no side
information from timing or cache behaviour. We may still leak
information through power analysis, if, e.g., executing a multiplication
instructions consumes different amount of energy depending on the input
bit patterns.

Maybe this is unnecessarily strict (I haven't really thought about what
the side-channel attack models are for particular cryptographic uses of
ecc), but I think this is what one should aim for. And I think it's
possible to achieve, at a moderate cost in performance.

I'm not intimately familiar with wmnaf, but it looks like the function
ecc_wMNAF has a lot of branches depending on the exponent bits. I also
suspect (but please correct me if I'm wrong) that the number of
generated digits is not determined by the exponent size only, it also
depends on the actual bits?

Next, in the main ecc_mulmod functions, the timing resistant versions
calls the madd primitive the same number of times independent of the
values of the digits. But there are some small remaining leaks (by the
above pretty high standard):

1. If wmnaf_len depends on the exponent bit pattern, then so does the
   number of iterations through the loop.

2. Branches depending on whether digit is &gt; 0, &lt; 0 or == 0. Those will
   have slightly different timing. Since digit == 0 is unlikely, that
   branch will be badly predicted. And it also affects instruction
   cache.

3. For the data cache, accesses to the wmnaf table are obviously data
   dependent. Also, data is written to different locations in memory (R
   or T) depending on whether or not the current digit is non-zero.

&gt;&gt; In the point addition, it seems hard to avoid special cases when adding
&gt;&gt; a point to itself or to its negation, or adding the zero point. 
&gt;
&gt;
&gt; Do you mean the infinity points or the point (0,0,0)?

The infinity point, which is the unit element of the group. I denote it
0 below (P + 0 = P for all P).

The core operation of a typical point multiplication algorithm is

  R += T[digit];

where R is where the result is accumulated, and T is a table indexed by
current digit (plain window, wmnaf, pippenger, whatever). Now there are
a couple of cases where this operation will not end up in the
common-case point-addition code:

1. R = 0. If the scalar n is in the range 0 &lt; n &lt; group order, this
   should happen only for the very first iterations of the loop.

2. R = - T[digit] (so R = 0 on output). For the above range of n, should
   also not happen (except as R = T[digit] = 0 initially in the loop).

3. T[digit] = 0. This is the digit == 0 case. For best average
   performance, one wants to handle this case specially and not do any
   addition at all (and much of the "exponent recoding" tricks are aimed
   at making this a more common case).

   But for constant-time, one wants to do an addition just as for any
   other value. I have to double check how jacobian coordinates work,
   but I think usual formulas for ecc point addition don't work in this
   case.

3. R = T[digit]. The point addition code must check for this case, and
   have a special case branching to point doubling instead. I'm not sure
   if this can happen; it clearly depends on which point multiplication
   algorithm is used. E.g, if the tabulated values in T are i*P for 0 &lt;= i &lt; M, and we
   know that R = j*P for some j in the range M &lt;= j &lt; prime group order,
   then this case can be excluded.

   And in any case, I imagine it will be extremely unlikely for a random
   scalar.
   
Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130118160925</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-01-18 16:09:25-0400</timestampReceived><subject>Re: ECC plans</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Let me first explain what I mean when I talk about a "side-channel
&gt; silent" function. That means that if we call the function with operands
&gt; which are of the same size, but otherwise different, the function should
&gt; execute exactly the same sequence of instructions in both cases, and
&gt; access memory in exactly the same pattern.

To give a flavor of what this means, here's some code (totally untested)
I wrote earlier today. It's basic binary point multiplication, but
intended to have running time independent of the exponent bits.

Regards,
/Niels

/* nettle, low-level cryptographics library
 *
 * Copyright (C) 2013 Niels Möller
 *  
 * The nettle library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 * 
 * The nettle library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with the nettle library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02111-1301, USA.
 */

/* Development of Nettle's ECC support was funded by Internetfonden. */

#include &lt;assert.h&gt;

#include "ecc.h"

void
cnd_copy (int cnd, mp_limb_t *rp, const mp_limb_t *ap, mp_size_t n)
{
  mp_limb_t mask, keep;
  mp_size_t i;

  mask = -(mp_limb_t) (cnd !=0);
  keep = ~mask;

  for (i = 0; i &lt; n; i++)
    rp[i] = (rp[i] &amp; keep) + (ap[i] &amp; mask);
}

void
ecc_mul_binary (const struct ecc_curve *ecc,
		mp_limb_t *r, const mp_limb_t *np, const mp_limb_t *p)
{
  mp_limb_t tp[9*ecc-&gt;size];
  mp_limb_t *rj = tp + 3*ecc-&gt;size;
  mp_limb_t *pj = tp + 6*ecc-&gt;size;
  int is_zero;

  unsigned i;

  mpn_zero (rj, 3*ecc-&gt;size);

  /* Extend p to jacobian coordinates, with z = 1 */
  mpn_copyi (pj, p, 2*ecc-&gt;size);
  pj[2*ecc-&gt;size] = 1;
  mpn_zero (pj + 2*ecc-&gt;size+1, ecc-&gt;size - 1);

  for (i = ecc-&gt;size, is_zero = 1; i-- &gt; 0; )
    {
      mp_limb_t w = np[i];
      mp_limb_t bit;
      
      for (bit = (mp_limb_t) 1 &lt;&lt; (GMP_NUMB_BITS - 1);
	   bit &gt; 0;
	   bit &gt;&gt;= 1)
	{
	  int digit;
	  
	  ecc_dup_jj (ecc, rj, rj);
	  ecc_add_jja (ecc, tp, rj, p);

	  digit = (w &amp; bit) &gt; 0;
	  /* If is_zero is set, rj is the zero point,
	     and ecc_add_jja produced garbage. */
	  cnd_copy (is_zero, tp, pj, 3*ecc-&gt;size);
	  is_zero &amp;= ~digit;
	  /* If we had a one-bit, use the sum. */
	  cnd_copy (digit, rj, tp, 3*ecc-&gt;size);
	}
    }
  ecc_normalize (ecc, r, rj);
}

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130123102009</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-01-23 10:20:09-0400</timestampReceived><subject>Re: ECC plans</subject><body>

On Fri, Jan 18, 2013 at 9:35 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:

&gt;&gt; How does this algorithm compare to others?
&gt;
&gt; If I read the gnutls code right, ecc_mulmod_cache makes the same number
&gt; of ecc_projective_dbl_point calls as the non-cached version? If that is
&gt; right, any comb-like algorithm should be able to beat it, since those
&gt; algorithms reduce the number of point doublings and the number of
&gt; iterations in the outer loop. Depending on selected table size, of
&gt; course.

In the main loop there is no difference in the wmnaf code, but outside
the loop the cached version does one doubling less and several
additions less.

&gt; Do you have any ecc benchmarking code I could borrow?

I use gnutls-cli's benchmark-tls-kx option. It measures TLS key
exchange time (one of them is ECDHE-ECDSA using an 192-bit curve).

&gt;&gt; Also for that part you don't need
&gt;&gt; constant time. [...] (in ECDH you also don't care unless it is fixed key ECDH).
&gt; In ECDH, any data dependent timing does leak some information about your
&gt; secret exponent. What you're saying, if I understand you correctly, is
&gt; that since you usually use each secret exponent only once, an attacker
&gt; will in most cases not be able to collect enough information to do any
&gt; damage.

Yes. That's the way ECDHE is used in gnutls. No key is reused and the
timing information from a single session isn't sufficient to recover
it.

&gt;&gt; I would put that of lower priority that signing. Servers (where
&gt;&gt; performance matters) rarely verify ECDSA keys.
&gt; Noted (although I'm not sure I agree it's less important than signing
&gt; performance).

Sorry, indeed, that's for TLS only. In TLS usually only the server is
authenticated. If there is client authentication too, then this is
also important.

&gt;&gt; Why is that? Did you see any issues on the timing resistant version of
&gt;&gt; the function?
&gt; Let me first explain what I mean when I talk about a "side-channel
&gt; silent" function. That means that if we call the function with operands
&gt; which are of the same size, but otherwise different, the function should
&gt; execute exactly the same sequence of instructions in both cases, and
&gt; access memory in exactly the same pattern.
&gt;
&gt; If one then assumes that the underlying machine instructions have data
&gt; independent timing (true for most current cpus), we leak no side
&gt; information from timing or cache behaviour. We may still leak
&gt; information through power analysis, if, e.g., executing a multiplication
&gt; instructions consumes different amount of energy depending on the input
&gt; bit patterns.

You are correct, but power analysis is useful for dedicated devices
such as smart cards. A generic-purpose library will not be used there
anyway. Protection from timing analysis is important, and while it is
not precisely measured, the gnutls wmnaf code contains
counter-measures for that. If you check the main loop in
ecc_mulmod_cached_timing() there is an "else" case where a dummy
addition is being performed. That is to make the number of operations
used independent of the input data.

&gt; I'm not intimately familiar with wmnaf, but it looks like the function
&gt; ecc_wMNAF has a lot of branches depending on the exponent bits.

Could be, but ecc_wMNAF is a fixed conversion that doesn't depend on
any input from an attacker. That is the best you can do is associate
the key with a time needed for its wmNAF conversion. I don't think
this is better than the association with its public key.

&gt; Next, in the main ecc_mulmod functions, the timing resistant versions
&gt; calls the madd primitive the same number of times independent of the
&gt; values of the digits. But there are some small remaining leaks (by the
&gt; above pretty high standard):
&gt;
&gt; 1. If wmnaf_len depends on the exponent bit pattern, then so does the
&gt;    number of iterations through the loop.

This is a fixed association again. An attack cannot control wmnaf_len
or the number of iterations. Timing attacks usually work by the
attacker trying different inputs and measuring the different timings.
In the cases you describe, as far as I understand, different input
will not provide additional timing information.

&gt; 2. Branches depending on whether digit is &gt; 0, &lt; 0 or == 0. Those will
&gt;    have slightly different timing. Since digit == 0 is unlikely, that
&gt;    branch will be badly predicted. And it also affects instruction
&gt;    cache.
&gt; 3. For the data cache, accesses to the wmnaf table are obviously data
&gt;    dependent. Also, data is written to different locations in memory (R
&gt;    or T) depending on whether or not the current digit is non-zero.

Could be, these are very cpu dependent. If your argumentation is that
a really safe timing resistant multiplication version has to be used,
then I wouldn't disagree, if it's up to the level that is not so slow
that no-one uses it. However, there is no reason for the code that
does not need to be timing resistant, not to be as fast as possible.

&gt;&gt;&gt; In the point addition, it seems hard to avoid special cases when adding
&gt;&gt;&gt; a point to itself or to its negation, or adding the zero point.
&gt;&gt; Do you mean the infinity points or the point (0,0,0)?
&gt; The infinity point, which is the unit element of the group. I denote it
&gt; 0 below (P + 0 = P for all P).

I've seen some implementations do not handle that at all, but I agree
that it has to be handled properly.

regards,
Nikos

</body></email><email><emailId>20130123114534</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-01-23 11:45:34-0400</timestampReceived><subject>Re: ECC plans</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; On Fri, Jan 18, 2013 at 9:35 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:

&gt;&gt; 1. If wmnaf_len depends on the exponent bit pattern, then so does the
&gt;&gt;    number of iterations through the loop.
&gt;
&gt; This is a fixed association again.

Now I'm getting confused. In ECDSA signing, the point multiplication is

  k * G

where k is a nonce (used only once), and G is the (public) group
generator. If you are saying that leaking a little information about k
via the timing of this multiplication is no problem, then the conclusion
seem to be that, for ECDSA, there's no need whatsoever to make the point
multiplication timing resistant? Right?

What is the main argument here, that the attacker has no control over k,
or that k is used only once?

For each signature (r, s) on hash h using secret key z, the attacker
gets to observe the values

  h, r, s, with s = (h + z r)/k

I think there *is* a problem with leaking just a little bit of
information about each k, since z = (k s - h) / r, and hence every piece
of information about k implies a piece of information about z, and the
information about z accumulates the more signatures you get.

And this issues is the same for plain DSA. Daniel Bleichenbacher's
attack on biased generation of k, from back in 2001, could be related,
even though you would get a different type of partial information about
k from timing-attacks.

If it's not already done, this type of timing attack on DSA should be a
great topic for a side-channel cryptanalysis paper (I'm not really
following current cryptanalysis research, unfortyunately).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130123140412</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-01-23 14:04:12-0400</timestampReceived><subject>Re: ECC plans</subject><body>

On Wed, Jan 23, 2013 at 12:45 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;&gt; This is a fixed association again.
&gt; Now I'm getting confused. In ECDSA signing, the point multiplication is
&gt;   k * G
&gt; where k is a nonce (used only once), and G is the (public) group
&gt; generator. If you are saying that leaking a little information about k
&gt; via the timing of this multiplication is no problem, then the conclusion
&gt; seem to be that, for ECDSA, there's no need whatsoever to make the point
&gt; multiplication timing resistant? Right?

My comments were not for ECDSA specifically. ECDSA is pretty fragile.
k although used once per signature, if known, it can be used to obtain
the (long term) private key. Because it is the private key you want to
protect, any value that may leak info on that should be protected as
well.

&gt; What is the main argument here, that the attacker has no control over k,
&gt; or that k is used only once?

It is used only once and for this reason the attacker can only get a
single timing for it. However, because the security of the ECDSA
private key depends on that value, I would reasonably protect it.

&gt; I think there *is* a problem with leaking just a little bit of
&gt; information about each k, since z = (k s - h) / r, and hence every piece
&gt; of information about k implies a piece of information about z, and the
&gt; information about z accumulates the more signatures you get.

Could be. Unfortunately unlike RSA there is not much on timing attacks
on (EC)DSA or preventions (or at least known to me).

regards,
Nikos

</body></email><email><emailId>20130123153717</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-01-23 15:37:17-0400</timestampReceived><subject>Re: ECC plans</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; My comments were not for ECDSA specifically. ECDSA is pretty fragile.

For me, ECDSA is the primary application of elliptic curves. So then it
seems important to use a point multiplication k * G which has a running
time independent of the bits in k. That's why I find the method used in
gnutls a bit worrying.

&gt; Could be. Unfortunately unlike RSA there is not much on timing attacks
&gt; on (EC)DSA or preventions (or at least known to me).

Maybe one could get some insights from Bleichenbacher's paper. I have
not read up on the details, but as far as I understand, the point was
that k in the range 1 &lt;= k &lt; 2^bit_size - q were generated with a higher
probability density than numbers in the range 2^bit_size - q &lt; k &lt; q.

And for a wnaf timing attack, one idea would be to divide signatures
into two classes, those generated with a k expanding to n wnaf digits,
and those generated with a k expanding to n+1 digits. Each class
corresponds to a different set of possible k, and if the classification
is not perfect, you still have a bias in each guessed class.

And I don't think prevention is too difficult. Just write the algorithm
to not include any branches depending on bits in k, and preferably (for
side-channels related to caches) also with all memory accesses
idnependent of the k bits. There's going to be some performance penalty,
of course.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130123213751</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-01-23 21:37:51-0400</timestampReceived><subject>Re: ECC plans</subject><body>

On 01/23/2013 04:37 PM, Niels Möller wrote:

&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt; 
&gt;&gt; My comments were not for ECDSA specifically. ECDSA is pretty fragile.
&gt; 
&gt; For me, ECDSA is the primary application of elliptic curves. So then it
&gt; seems important to use a point multiplication k * G which has a running
&gt; time independent of the bits in k. That's why I find the method used in
&gt; gnutls a bit worrying.


Not for TLS. In TLS ECDHE is the primary application of elliptic curves.
In the last SSL observatory data the RSA keys on the internet were 4
million+, whereas the ECDSA keys were only 6 (that's three years ago,
but I don't think there was a radical change since then). Typically one
uses ECDHE with RSA keys in TLS.

Nevertheless, the method that you use for the timing sensitive parts of
the code, doesn't need to match the optimized version.

regards,
Nikos

</body></email><email><emailId>20130124073827</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-01-24 07:38:27-0400</timestampReceived><subject>Re: ECC plans</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Not for TLS. In TLS ECDHE is the primary application of elliptic
&gt; curves. [...] Typically one uses ECDHE with RSA keys in TLS.

I see. What's the motivation, saving cycles in the key exchange, or
smaller messages, or higher security, or something else?

&gt; Nevertheless, the method that you use for the timing sensitive parts of
&gt; the code, doesn't need to match the optimized version.

If the performance penalty for the timing-resistant functions is more
than, say, 10%, it would make some sense to include a seperate set of
functions optimized for speed. But I think I want to do the
timing-resistant things first.

Here are some benchmarks for my first working version (the unit is
operations per millisecond):

On matrix (Intel i5, 3.4 GHz):

 name size  sign / ms verify / ms
  rsa 1024     6.3145   104.0742
  rsa 2048     0.9555    29.4275
  dsa 1024    11.1746     5.7460
ecdsa  192     2.1167     1.5355
ecdsa  224     1.2371     1.0234
ecdsa  256     1.3845     1.0182
ecdsa  384     0.6415     0.4751
ecdsa  521     0.2515     0.2037

On pandix (ARM Cortex A9, 1 GHz):

 name size  sign / ms verify / ms
  rsa 1024     0.2626     4.5527
  rsa 2048     0.0392     1.2490
  dsa 1024     0.4694     0.2377
ecdsa  192     0.1906     0.1445
ecdsa  224     0.1418     0.1058
ecdsa  256     0.1050     0.0796
ecdsa  384     0.0431     0.0327
ecdsa  521     0.0173     0.0135

For the verify operation, RSA is by far fastest. I benchmark RSA using a
small public exponent, 65537, which I think is typical.

For signing, plain DSA is currently fastest (I'd like to also include
"DSA2", with 2048 bit p and 256 bit q, but my closest key generation
programs didn't support that).

Still, signing with 256-bit ecdsa is a bit faster than 2048 bit RSA.

When optimizing, I think one can aim for a factor 10 speedup for signing
and maybe a factor 2 for verification (the higher potential for signing
is that it uses point multiplication only with the fixed generator,
which can be sped up a lot using some precomputed tables. Current code
uses the binary algorithm I posted the other day, and no serious
curve-specific optimizations.

I could set up a public repository for my work-in-progress code, if
there's some interest.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130124092709</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-01-24 09:27:09-0400</timestampReceived><subject>Re: ECC plans</subject><body>

On Thu, Jan 24, 2013 at 8:38 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt;&gt; Not for TLS. In TLS ECDHE is the primary application of elliptic
&gt;&gt; curves. [...] Typically one uses ECDHE with RSA keys in TLS.
&gt; I see. What's the motivation, saving cycles in the key exchange, or
&gt; smaller messages, or higher security, or something else?

If perfect forward secrecy is required then DHE is pretty inefficient
on security levels of 96 bits or more. ECDHE provides a fast
equivalent.

&gt; On matrix (Intel i5, 3.4 GHz):
&gt;  name size  sign / ms verify / ms
&gt;   rsa 1024     6.3145   104.0742
&gt;   rsa 2048     0.9555    29.4275
&gt;   dsa 1024    11.1746     5.7460
&gt; ecdsa  192     2.1167     1.5355
&gt; ecdsa  224     1.2371     1.0234
&gt; ecdsa  256     1.3845     1.0182
&gt; ecdsa  384     0.6415     0.4751
&gt; ecdsa  521     0.2515     0.2037

I usually use the table of ECRYPT II, to compare equivalent security levels=
.
http://www.keylength.com/en/3/
Otherwise the comparison may be unfair to ECDSA. RSA-1024 is used much
even today but it is roughly equivalent to an ECDSA key of 144 bits.

&gt; For signing, plain DSA is currently fastest (I'd like to also include
&gt; "DSA2", with 2048 bit p and 256 bit q, but my closest key generation
&gt; programs didn't support that).

certtool does that.

&gt; I could set up a public repository for my work-in-progress code, if
&gt; there's some interest.

Why not on the main repository as a branch?

regards,
Nikos

</body></email><email><emailId>20130124104238</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-01-24 10:42:38-0400</timestampReceived><subject>Re: ECC plans</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Why not on the main repository as a branch?

I already started working with a separate repository, and I'd like to
have overall structure decided adding any files to the main repo. And I
see no real gain from using branches as long as the sets of files are
disjoint.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130213215515</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-02-13 21:55:15-0400</timestampReceived><subject>Re: ECC low-level interface</subject><body>

On 02/13/2013 02:51 PM, Niels Möller wrote:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt;&gt; I'd like to post the interface I use for low-level ecc functions.
&gt; 
&gt; And here's the current interface for ECDSA functions. Low-level
&gt; functions with similar conventions as the low-level ecc functions. And
&gt; high-level functions using mpz_t for arguments, and using the same
&gt; allocation function as GMP for storage.


Hello Niels,
 I've checked the high level functions and they seem fine. As far as I
am concerned I think they can easily update the current gnutls code.

About the naming you use ecdsa_private_key and public_key. Note that
this is the same key for static ECDH, and I think MQV.

If there is a function to do the DH multiplication k*(ecdsa_public_key)
I think the gnutls could be tested with that interface, if I get some
time to do that.

&gt; But for ecdsa, do we need any functions like that? I guess, for


I don't know. I wouldn't probably use them, but others may.

&gt; which take a hashing context as argument. Which hash functions are

&gt; people using for ecdsa with the various curves? RFC 4754 (IKE and IKEv2
&gt; Authentication Using ECDSA) defines:
&gt;        ECDSA-256          256-bit random ECP group        SHA-256
&gt;        ECDSA-384          384-bit random ECP group        SHA-384

&gt;        ECDSA-521          521-bit random ECP group        SHA-512

As far as I know these are the only allowed by the DSS standard (I was
under the impression that SHA-224 was also allowed).

regards,
Nikos

</body></email><email><emailId>20130214074608</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-02-14 07:46:08-0400</timestampReceived><subject>Re: ECC low-level interface</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; About the naming you use ecdsa_private_key and public_key. Note that
&gt; this is the same key for static ECDH, and I think MQV.

Do you have any suggestions for improved naming? I understand ECDH,
although it has been a very low priority for me so far, but I'm not
familiar with MQV. Would it be better with more algorithm-neutral names,
like "ecc_point" and "ecc_scalar"?

The way I think about it, the ecdsa_public key is a combination of a
point and a curve-specification. If I add a highlevel "ecc_point" type,
should that include a pointer to the curve or not?

&gt; If there is a function to do the DH multiplication k*(ecdsa_public_key)
&gt; I think the gnutls could be tested with that interface,

For ECDH, you could generate a new keypair (P, z) with ecdsa_generate_keypair,
send the "public key" P as a point Q to the other party, receive another
point Q, and then to compute Y one would need a function like

void
ecdsa_private_key_mul (const struct ecdsa_private_key *key,
		       mpz_t new_x, mpz_t new_y, const mpz_t x, const mpz_t y);

(these are not very good names, but I hope you get the idea). At least,
if we think about ECDH as using a temporary keypair, then I think it's
clearest to view the above operation as an operation using out private
key, not as an operation involving the other party's public key.

&gt;&gt;        ECDSA-256          256-bit random ECP group        SHA-256
&gt;&gt;        ECDSA-384          384-bit random ECP group        SHA-384
&gt;
&gt;&gt;        ECDSA-521          521-bit random ECP group        SHA-512
&gt;
&gt; As far as I know these are the only allowed by the DSS standard (I was
&gt; under the impression that SHA-224 was also allowed).

At least, fips-186-3 is not very specific, I think it allows any any
"approved" hash function with security level high enough for the
application. Or even any combination of approved curve and approved hash
function where *both* have high enough security level for the
application.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130216114559</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-02-16 11:45:59-0400</timestampReceived><subject>Re: ECC low-level interface</subject><body>

On 02/14/2013 08:46 AM, Niels Möller wrote:

&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt;&gt; About the naming you use ecdsa_private_key and public_key. Note that
&gt;&gt; this is the same key for static ECDH, and I think MQV.
&gt; Do you have any suggestions for improved naming? I understand ECDH,
&gt; although it has been a very low priority for me so far, but I'm not
&gt; familiar with MQV. Would it be better with more algorithm-neutral names,
&gt; like "ecc_point" and "ecc_scalar"?

&gt; The way I think about it, the ecdsa_public key is a combination of a
&gt; point and a curve-specification. If I add a highlevel "ecc_point" type,
&gt; should that include a pointer to the curve or not?

Any of those would be fine (I prefer point as more intuitive). Having a
pointer to the curve is a good thing I believe (a point on that curve).
I don't think there are cases where a point can be used in multiple
curves. It should be easy to generate those structures from
x,y pairs and knowledge of the curve.

&gt; void
&gt; ecdsa_private_key_mul (const struct ecdsa_private_key *key,
&gt; 		       mpz_t new_x, mpz_t new_y, const mpz_t x, const mpz_t y);
&gt; 
&gt; (these are not very good names, but I hope you get the idea). At least,
&gt; if we think about ECDH as using a temporary keypair, then I think it's
&gt; clearest to view the above operation as an operation using out private
&gt; key, not as an operation involving the other party's public key.


Also a function that checks whether a point lies on a curve would be
needed (may already be there, didn't check).

&gt; At least, fips-186-3 is not very specific, I think it allows any any
&gt; "approved" hash function with security level high enough for the
&gt; application. Or even any combination of approved curve and approved hash
&gt; function where *both* have high enough security level for the
&gt; application.

Then you may allow hashing directly the output of the hash and not
bother with that.

regards,
Nikos



</body></email><email><emailId>20130217084903</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-02-17 08:49:03-0400</timestampReceived><subject>Re: ECC low-level interface</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Also a function that checks whether a point lies on a curve would be
&gt; needed (may already be there, didn't check).

ecc_set_public_key should do that check. 

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130218095509</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-02-18 09:55:09-0400</timestampReceived><subject>Re: ECC low-level interface</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; If there is a function to do the DH multiplication k*(ecdsa_public_key)
&gt; I think the gnutls could be tested with that interface, if I get some
&gt; time to do that.

I'm looking into an interface redesign of the high-level ecdsa, using
types

  /* Represents a point on the ECC curve */
  struct ecc_point
  {
    const struct ecc_curve *ecc;
    /* Allocated using the same allocation function as GMP. */
    mp_limb_t *p;
  };
  
  /* Represents a non-zero scalar, an element of Z_q^*, where q is the
     group order of the curve. */
  struct ecc_scalar
  {
    const struct ecc_curve *ecc;
    /* Allocated using the same allocation function as GMP. */
    mp_limb_t *p;
  };

(which are identical, except that they use different allocation size and
contents for p...). I think this will be good enough for both ECDH and
ECDSA. Some questions:

1. For the final multiplication in ECDH, do you want the complete point,
   or do you need the x coordinate only?

2. I wonder if I should somehow add some aliases, ecdsa_public_key &lt;=&gt;
   ecc_point, ecdsa_private_key &lt;=&gt; ecc_scalar?

3. Is there any need to support operations involving the zero point
   (group zero, curve infinity)? For now, I don't have any high-level
   function to add two points.

About the zero point, here's a comment from my current implementation of
ecdsa_verify.

  /* u = 0 can happen only if h = 0 or h = q, which is extremely
     unlikely. */
  if (!zero_p (ecc, u1))
    {
      /* Total storage: 6*ecc-&gt;size + ECC_MUL_G_ITCH (ecc-&gt;size) */
      ecc_mul_g (ecc, P1, u1, u1 + ecc-&gt;size);

      /* NOTE: ecc_add_jjj and/or ecc_j_to_a will produce garbage in
         case u1 G = +/- u2 V. However, anyone who gets his or her
         hands on a signature where this happens during verification,
	 can also get the private key as z = +/- u1 / u_2 (mod q). And
	 then it doesn't matter very much if verification of
	 signatures with that key succeeds or fails.

	 u1 G = - u2 V can never happen for a correctly generated
	 signature, since it implies k = 0.

	 u1 G = u2 V is possible, if we are unlucky enough to get h /
	 s_1 = z. Hitting that is about as unlikely as finding the
	 private key by guessing.
       */
      /* Total storage: 6*ecc-&gt;size + ECC_ADD_JJJ_ITCH (ecc-&gt;size) */
      ecc_add_jjj (ecc, P1, P1, P2, u1);
    }

If/when I switch to different primitives for ecdsa_verify, which are not
side-channel silent, I ought to handle those corner cases correctly. But
I wonder how important that really is.

And during signing, would it make sense to check if z s_1 = h (here, z
is the private key, s_1 is the x coordinate of k G, and h is the message
digest), and try a new random k in that case? In addition to the checks
for s_1 == 0 or s_2 == 0?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130218102722</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-02-18 10:27:22-0400</timestampReceived><subject>Re: ECC low-level interface</subject><body>

On Mon, Feb 18, 2013 at 10:55 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt;
&gt;&gt; If there is a function to do the DH multiplication k*(ecdsa_public_key)
&gt;&gt; I think the gnutls could be tested with that interface, if I get some
&gt;&gt; time to do that.
&gt;
&gt; I'm looking into an interface redesign of the high-level ecdsa, using
&gt; types
&gt;
&gt;   /* Represents a point on the ECC curve */
&gt;   struct ecc_point
&gt;   {
&gt;     const struct ecc_curve *ecc;
&gt;     /* Allocated using the same allocation function as GMP. */
&gt;     mp_limb_t *p;
&gt;   };

Wouldn't you need more than one members there? I'd expect x,y,z. Or
you plan to work internally using X9.62 format?
Would you also need to keep the size of limb_t?

&gt;   /* Represents a non-zero scalar, an element of Z_q^*, where q is the
&gt;      group order of the curve. */
&gt;   struct ecc_scalar
&gt;   {
&gt;     const struct ecc_curve *ecc;
&gt;     /* Allocated using the same allocation function as GMP. */
&gt;     mp_limb_t *p;
&gt;   };

Why not keep the scalar as just a number (i.e. mpz_t)? Is there any
advantage in treating it as related to the curve?

&gt; 1. For the final multiplication in ECDH, do you want the complete point,
&gt;    or do you need the x coordinate only?

For TLS we only need x. I don't know about other protocols. P1363
should discuss some but it is not publicly available (and it is a
shame that IETF ECC-TLS only refers to that).

&gt; 2. I wonder if I should somehow add some aliases, ecdsa_public_key &lt;=&gt;
&gt;    ecc_point, ecdsa_private_key &lt;=&gt; ecc_scalar?

They could typedefs, or defines, but I don't know whether this would
make it more clear.

&gt; 3. Is there any need to support operations involving the zero point
&gt;    (group zero, curve infinity)? For now, I don't have any high-level
&gt;    function to add two points.

Few implementations don't handle it at all, but couldn't that be the
result of an intermediate calculation? (quite unlikely though but
still possible). In that case I'm not sure what happens (those
implementations would still return some result).

&gt; And during signing, would it make sense to check if z s_1 = h (here, z
&gt; is the private key, s_1 is the x coordinate of k G, and h is the message
&gt; digest), and try a new random k in that case? In addition to the checks
&gt; for s_1 == 0 or s_2 == 0?

The check looks like a good one on a first read, but isn't it the same
as checking for k being 3?  (or whatever fixed value).

regards,
Nikos

</body></email><email><emailId>20130218121004</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-02-18 12:10:04-0400</timestampReceived><subject>Re: ECC low-level interface</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; On Mon, Feb 18, 2013 at 10:55 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;&gt; I'm looking into an interface redesign of the high-level ecdsa, using
&gt;&gt; types
&gt;&gt;
&gt;&gt;   /* Represents a point on the ECC curve */
&gt;&gt;   struct ecc_point
&gt;&gt;   {
&gt;&gt;     const struct ecc_curve *ecc;
&gt;&gt;     /* Allocated using the same allocation function as GMP. */
&gt;&gt;     mp_limb_t *p;
&gt;&gt;   };
&gt;
&gt; Wouldn't you need more than one members there? I'd expect x,y,z.

The idea is to use an internal representation which is the same as what
the low-level interface expects. So, e.g, if we have 64 bit limbs, and
work over the secp256r1 curve, p would point at an area of 8 limbs,
where the first 4 represent x and the next 4 represent y.

But you're not expected to need to know the internal representation,
just use the get and set functions with coordinates in mpz_t form.

&gt;&gt;   /* Represents a non-zero scalar, an element of Z_q^*, where q is the
&gt;&gt;      group order of the curve. */
&gt;&gt;   struct ecc_scalar
&gt;&gt;   {
&gt;&gt;     const struct ecc_curve *ecc;
&gt;&gt;     /* Allocated using the same allocation function as GMP. */
&gt;&gt;     mp_limb_t *p;
&gt;&gt;   };
&gt;
&gt; Why not keep the scalar as just a number (i.e. mpz_t)?

mpz_t is not suitable for side-channel silent operations, since it uses
a limb count dependent on the actual value. So if you put a value
related to the 521-bit curve in an mpz_t, most values would use 9 64-bit
limbs, but with a probability of about 1/512 you'd get only 8 limbs.

&gt; Is there any advantage in treating it as related to the curve?

Not sure, but if we add some operations, like add, mul, invert, ..., they
should all be mod the curve order, and hence need the curve data.

&gt;&gt; 1. For the final multiplication in ECDH, do you want the complete point,
&gt;&gt;    or do you need the x coordinate only?
&gt;
&gt; For TLS we only need x. I don't know about other protocols. P1363
&gt; should discuss some but it is not publicly available (and it is a
&gt; shame that IETF ECC-TLS only refers to that).

Ok, then it makes sense to have a function to return x only.

&gt;&gt; 2. I wonder if I should somehow add some aliases, ecdsa_public_key &lt;=&gt;
&gt;&gt;    ecc_point, ecdsa_private_key &lt;=&gt; ecc_scalar?
&gt;
&gt; They could typedefs, or defines, but I don't know whether this would
&gt; make it more clear.

First question is if it is desirable. If it is, it may be a bit
difficult to define cleanly, since I use struct tags rather than
typedefs for naming.

&gt;&gt; 3. Is there any need to support operations involving the zero point
&gt;&gt;    (group zero, curve infinity)? For now, I don't have any high-level
&gt;&gt;    function to add two points.
&gt;
&gt; Few implementations don't handle it at all, but couldn't that be the
&gt; result of an intermediate calculation?

For the most important operation, n * P, you should not get any zero
intermediates assuming that P is non-zero to start with, and that n != 0
(mod group order). Except initially when processing leading zero bits of
n, which I handle specially in the multiplication code.

So it doesn't seem essential until we support addition of arbitrary
points.

&gt;&gt; And during signing, would it make sense to check if z s_1 = h (here, z
&gt;&gt; is the private key, s_1 is the x coordinate of k G, and h is the message
&gt;&gt; digest), and try a new random k in that case? In addition to the checks
&gt;&gt; for s_1 == 0 or s_2 == 0?
&gt;
&gt; The check looks like a good one on a first read, but isn't it the same
&gt; as checking for k being 3?  (or whatever fixed value).

No, just as for the other checks, the condition depends on both k and h.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130218131347</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-02-18 13:13:47-0400</timestampReceived><subject>Re: ECC low-level interface</subject><body>

On Mon, Feb 18, 2013 at 1:10 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:

&gt;&gt;&gt; And during signing, would it make sense to check if z s_1 = h (here, z
&gt;&gt;&gt; is the private key, s_1 is the x coordinate of k G, and h is the message
&gt;&gt;&gt; digest), and try a new random k in that case? In addition to the checks
&gt;&gt;&gt; for s_1 == 0 or s_2 == 0?
&gt;&gt;
&gt;&gt; The check looks like a good one on a first read, but isn't it the same
&gt;&gt; as checking for k being 3?  (or whatever fixed value).
&gt; No, just as for the other checks, the condition depends on both k and h.

So has this particular case higher probability than k being randomly
chosen to be 3? (I've not seen this test anywhere else, that's why I'd
be curious on why you mention this test).

regards,
Nikos

</body></email><email><emailId>20130218133038</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-02-18 13:30:38-0400</timestampReceived><subject>Re: ECC low-level interface</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; So has this particular case higher probability than k being randomly
&gt; chosen to be 3? (I've not seen this test anywhere else, that's why I'd
&gt; be curious on why you mention this test).

If the verify code is done as

  P1 = u1*G
  P2 = u2*Y

  P = P1 + P2

then an equivalent test is needed there, sine we have to do

  if (P1 == P2)
    P = ecc_dup (P1)
  else
    P = ecc_add(P1 ,P2)

And if we do this test, it's trivial to extend it to

  if (P1 == P2)
    {
      P = ecc_dup (P1)
      output private key (it's -u2/u1 (mod q) or something like that)
    }
  else
    P = ecc_add(P1 ,P2)

So *if* we think that handling this case correctly on the verify side is
appropriate, then it seems reasonable, on the signing side, to make sure
that it never occurs.

And conversely, if it's too unlikely to bother about when signing, do we
need to bother about it when verifying signatures, or is it ok if
ecdsa_verify outputs some incorrect result, most likely always
"invalid", for this case ?

I have also not seen this case mentioned anywhere, so I'm not sure
what's the right thing to do.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130814105226</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-08-14 10:52:26-0400</timestampReceived><subject>Re: AES interface</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I think the simplest way would be to arrange the internal aes functions
&gt; to take number of rounds and the subkey as separate arguments. And then
&gt; define separate context structs and functions for each key size, like
&gt;
&gt;   struct aes128_ctx
&gt;   {
&gt;     uint32_t keys[44];
&gt;   };
&gt;
&gt;   struct aes192_ctx
&gt;   {
&gt;     uint32_t keys[52];
&gt;   };
&gt;
&gt;   struct aes256_ctx
&gt;   {
&gt;     uint32_t keys[60];
&gt;   };
&gt;
&gt; There should be no problem to also keep the current AES interface (with
&gt; variable key size) for backwards compatibility.

I've pushed a branch "aes-reorg" to the public repo, implementing this
change.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130508071943</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-05-08 07:19:43-0400</timestampReceived><subject>arm compilation</subject><body>

Hello,
 Trying to build nettle 2.7 for an arm10 system of mine using its (old)
toolchain fails with assembler errors.

arm-linux-gcc -Os  -I[...] -I.  -DHAVE_CONFIG_H -g -O2 -ggdb3
-Wno-pointer-sign -Wall -W   -Wmissing-prototypes -Wmissing-declarations
-Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast
-Wnested-externs -fpic -MT aes-decrypt-internal.o -MD -MP -MF
aes-decrypt-internal.o.d -fpic -c aes-decrypt-internal.s
aes-decrypt-internal.s: Assembler messages:
aes-decrypt-internal.s:81: Error: bad instruction `push
{r4,r5,r6,r7,r8,r10,r11,lr}'
aes-decrypt-internal.s:87: Error: register or shift expression expected
-- `orr r4,r8,lsl#8'
aes-decrypt-internal.s:89: Error: register or shift expression expected
-- `orr r4,r8,lsl#16'
aes-decrypt-internal.s:91: Error: register or shift expression expected
-- `orr r4,r8,lsl#24'
aes-decrypt-internal.s:93: Error: bad arguments to instruction -- `eor
r4,r8'
[...]
make[2]: *** [aes-decrypt-internal.o] Error 1

$ arm-linux-as -v
GNU assembler version 2.16.1 (arm-linux-uclibc) using BFD version 2.16.1

Trying with the latest buildroot another error is issued:

arm-buildroot-linux-uclibcgnueabi-as -v
GNU assembler version 2.21.1 (arm-buildroot-linux-uclibcgnueabi) using
BFD version (GNU Binutils) 2.21.1

arm-buildroot-linux-uclibcgnueabi-gcc -I.  -DHAVE_CONFIG_H -pipe -Os
-Wno-pointer-sign -Wall -W   -Wmissing-prototypes -Wmissing-declarations
-Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast
-Wnested-externs -fpic -MT aes-encrypt-internal.o -MD -MP -MF
aes-encrypt-internal.o.d -fpic -c aes-encrypt-internal.s
aes-encrypt-internal.s: Assembler messages:
aes-encrypt-internal.s:140: Error: selected processor does not support
ARM mode `uxtb r8,r2'
aes-encrypt-internal.s:142: Error: selected processor does not support
ARM mode `uxtb r8,r3'
aes-encrypt-internal.s:144: Error: selected processor does not support
ARM mode `uxtb r8,r12'
aes-encrypt-internal.s:146: Error: selected processor does not support
ARM mode `uxtb r8,r14'


Any ideas?


regards,
Nikos

</body></email><email><emailId>20130620084714</emailId><senderName>manish kanchan</senderName><senderEmail>manishdkanchan00@gmail.com</senderEmail><timestampReceived>2013-06-20 08:47:14-0400</timestampReceived><subject>query on nettle support.</subject><body>

Hi ,
I am trying to used Nettle cryptolibrary.
I download the source, installed on ubuntu wrote a some sample application
using the readme, examples files.

There are couple of thing which i am still unsure. Can you help me
understand this.

1. Does nettle support on PKCS1 encoding fro RSA encrytpion and signing?
2. In the PrivateKey structure, Is the d ( private expoenent ) never used?
Does nettle use private key in CRT format only? and not in expoenent format
( i.e modulus and priv exp)

I would be glad if you can clarify this to me.

Regards
Manish Kanchan

</body></email><email><emailId>20130916200435</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-09-16 20:04:35-0400</timestampReceived><subject>Re: GCM vs SHA1</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Nikos noted (off list) that Nettle's gcm hashing is slower than sha1.
&gt; Which seems contrary to what's expected.

If people expect that gcm is faster than ha1, I'm curious how they reaon.

sha1 needs 80 rounds to process 64 input bytes. Each round needs some 15
instruction, and with sufficient independence for reasonable instruction
level parallelism. So that's roughly 20 instructions per byte. Nettle's
current x86_64 code seems to get down to 7.7 cycles/byte on the machine
I have here, with some room for further optimization. openssl gets it
down a bit further, to 6 cycles/byte.

gcm hashing is one gf2 multiplication, which needs 16 instructions.
Dependencies doesn't look too bad. It seems posible to get this routine
alone to run at about 6 cycles/byte. On top of that is the xoring the
input data, which should be less than a cycle/byte, a bit depending on
the alignment of the callers' data buffer.

I think my attemps at assembly implementation, which haven't made much
progress, suffer from memxor overhead. I have so far only done the gf2
multiplication in assembly, but that gives little, if any, gain over the
code generated by gcc. Around 9-10 cycles/byte (benchmarking the
top-level gcm_update). I think I'd need to reimplement the gcm_hash
function, inlining the xoring of the input data.

But I doubt it's possible to get gcm down to 6 cycles/byte. And then it
still wouldn't be faster than a well optimized sha1. Machines with a
fast shld (two-register shift) could have a couple of instructino and
maybe a cycle or so per byte.

And then there's specialized instruction, like pclmul, which should be
helpful. I haven't yet looked into that.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131005103313</emailId><senderName>Ted Zlatanov</senderName><senderEmail>tzz@lifelogs.com</senderEmail><timestampReceived>2013-10-05 10:33:13-0400</timestampReceived><subject>PBKDF2 generic hashing method: unclear usage, examples needed</subject><body>

Hi,

I'm trying to use the Nettle PBKDF2 functionality from Emacs.

This call (assume that the macros and variables are correct):

   pbkdf2_hmac_sha1 (SCHARS (key), SDATA (key), XINT (iterations), SCHARS (salt), \
SDATA (salt), outlength, digest);

works great, but I'd like to be able to use any generic nettle_hash.

I tried this, given alg is a pointer to a nettle_hash:

   HMAC_SET_KEY(ctx, alg, SCHARS (key), SDATA (key));
   PBKDF2 (ctx, alg-&gt;update, alg-&gt;digest, alg-&gt;digest_size, XINT (iterations), SCHARS \
(salt), SDATA (salt), outlength, digest);

in many combinations but couldn't get it to work (the tests don't match
up), and the docs don't explain how the PRF needs to be initialized.  I
tried to copy what pbkdf2_hmac_sha1() does but wasn't successful.  Is
there an example you could provide here or in the Nettle sources?

(The confusing part is that "ctx" is used for both the HMAC context (the
one with inner, outer, and state contexts) and for the hashing state
context itself.  At one point in the macro chain the HMAC context is
passed where a hashing state context is expected, I think, and I really
need an example to ensure I'm doing it correctly.  I am verifying with
the RFC 6070 test vectors and can provide the full source if necessary.)

Thanks!
Ted


</body></email><email><emailId>20131112201732</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-11-12 20:17:32-0400</timestampReceived><subject>poly1305 nonce increments</subject><body>

As I wrote, I'm working with poly1305. One question: The _digest
function will update the nonce value, so that by default one gets a
nonce sequence of 0, 1, 2, .... In the code I'm working with
(contributed by Nikos), this increment is done in a big-endian fashion,
just like increments for CTR mode.

Is this going to be the common way to generate nonces for poly1305?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20131206181426</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-12-06 18:14:26-0400</timestampReceived><subject>dsa_generate_keypair</subject><body>

Hello,
 I tried to switch gnutls to use dsa_generate_keypair() to generate
primes for the DH key exchange, but unfortunately this interface has the
strict DSS checks for q_bits. Would it be possible to have a
dh_generate_keypair() that does the exact same thing without the q_bits
and p_bits limitations?

regards,
Nikos



</body></email><email><emailId>20131206190032</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-06 19:00:32-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;  I tried to switch gnutls to use dsa_generate_keypair() to generate
&gt; primes for the DH key exchange, but unfortunately this interface has the
&gt; strict DSS checks for q_bits.

I'm not sure what's the right thing is here.

Simplest would be to just drop these requirements from
dsa_generate_keypair, and let it do whatever the caller asks for. Do you
think that makes sense?

&gt; Would it be possible to have a dh_generate_keypair() that does the
&gt; exact same thing without the q_bits and p_bits limitations?

Do you need exactly the same thing for DH? I.e., a group of relatively
small size q, which is a subgroup of Z_p^* for some much larger p?

I imagine one might want to rather use primes like p = 2q + 1 or so, so
the size q subgroup is almost as large as Z_p. I'm not sure the current
code works with q_size = p_size-1.

Related issue, which soemone else asked about some week ago, is
separating generation of DSA parameters (i.e., p, q, g) from generation
of the key pair. Currently, there's no easy way in nettle to generate a
key for some pre-specified DSA group. It might be better to have
something like

  struct dsa_params
  {
    mpz_t p;
    mpz_t q;
    mpz_t g;
  };

  struct dsa_private_key
  {
    const struct dsa_params *params;
    mpz_t x;
  };
  
  struct dsa_private_key
  {
    const struct dsa_params *params;
    mpz_t y;
  };

(a bit analogous to the new ecdsa code). But that would be a pretty
large and incompatible change, so we maybe shouldn't do that, or at
least think carefully about compatibility.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131206193551</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2013-12-06 19:35:51-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>


On 12/06/2013 02:00 PM, Niels Möller wrote:
&gt; Simplest would be to just drop these requirements from
&gt; dsa_generate_keypair, and let it do whatever the caller asks for. Do you
&gt; think that makes sense?

This seems reasonable to me, even for people who want to make DSA keys.
 If they want to follow the strict requirements about the sizes of p and
q, they have all the tools at their disposal to follow them, and i'm not
sure nettle should be enforcing that behavior.

&gt; Do you need exactly the same thing for DH? I.e., a group of relatively
&gt; small size q, which is a subgroup of Z_p^* for some much larger p?
&gt;
&gt; I imagine one might want to rather use primes like p = 2q + 1 or so, so
&gt; the size q subgroup is almost as large as Z_p. I'm not sure the current
&gt; code works with q_size = p_size-1.

Why would a DH key exchange need the larger group but a DSA signature be
secure with the smaller group?  This is a serious question and not a
rhetorical one -- if you have a pointer to any sort of writeup that
explains the difference of these two uses of the discrete log, i'd like
to try to understand it.  Sorry if this is a dumb question!

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20131206201257</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-06 20:12:57-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; Why would a DH key exchange need the larger group but a DSA signature be
&gt; secure with the smaller group?

I think the main point of the smaller group in DSA is to get small
signatures.

And discrete logs in the large group and discrete logs in the small
subgroup are of comparable difficulty, because there's more structure in
the larger group ("index calculus" is the name of the trick, iirc).

For DH, I don't think there's any particular reason to prefer to work in
a small subgroup. But I may be missing something, of course.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131206204859</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2013-12-06 20:48:59-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>


On 12/06/2013 03:12 PM, Niels Möller wrote:
&gt; I think the main point of the smaller group in DSA is to get small
&gt; signatures.
&gt; 
&gt; And discrete logs in the large group and discrete logs in the small
&gt; subgroup are of comparable difficulty, because there's more structure in
&gt; the larger group ("index calculus" is the name of the trick, iirc).

cool, thanks, i'll look into that further.

&gt; For DH, I don't think there's any particular reason to prefer to work in
&gt; a small subgroup. But I may be missing something, of course.

I can think of a few, but i'm not sure how legitimate they are:

one is a minimized-entropy:  If you know your small subgroup is of size
q, then you need less entropy to choose your secret A in the DH key
exchange, since it never needs to exceed q.

Another might be efficiency of modular exponentiation: if you use
exponentiation by squaring, then the cost of generating the public DH
value A' from A where 1 &lt; A &lt; q should be O(log_2(q)) instead of
O(log_2(p)) where 1 &lt; A &lt; p.  The cost of the second exponentiation
(from B') will still be O(log_2(p)), of course, but it still seems like
a non-trivial reduction in computation.

I've heard complaints about both the additional round-trip of the DH

	--dkg



["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20131206220600</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-06 22:06:00-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>

I wrote:

&gt; I think the main point of the smaller group in DSA is to get small
&gt; signatures.

And it should also gets a bit faster, with smaller exponents. Which
might be an advantage also for DH, but I don't know if that's considered
important?

&gt; And discrete logs in the large group and discrete logs in the small
&gt; subgroup are of comparable difficulty, because there's more structure in
&gt; the larger group ("index calculus" is the name of the trick, iirc).

Let me say a bit more about this. There's one class of "abstract"
discrete logarithm algorithms which work on any group where the group
operations are computable.

If n is the size of the group, there's an "obvious" meet-in-the-middle
algorithm with O(sqrt(n)) computation and O(sqrt(n)) storage: To find x
such that g^x = y, let s = ceil(sqrt(s)). First tabulate g^{k s} for k =
0, 1, ..., s. Then compute y g^{-m}, for m = 0, 1, ..., and stop when
you get a value which is present in the table. Then x = k s + m.
(Different time-memory tradeoffs are possible, of course).

Even better is to use the Pollard-rho discrete log algorithm, with
computation O(sqrt(n)), and very little storage.

As far as I'm aware, these abstract group algorithms are the best known
for directly attacking the DSA subgroup, or for attacking the elliptic
curve groups used for cryptographic purposes.

On the other hand, to compute discrete logarithms in the multiplicative
group of Z_p, there's the index calculus algorithm which is somewhat
similar to the number number field sieve factoring algorithm, and with
similar computational complexity (I'm not sure exactly what the
complexity is, though. But a *lot* better than O(sqrt(n))).

To break DSA, it's the attacker's choice to try the index calculus
algorithm on the large group, or the pollard-rho algorithm on the
smaller subgroup. Parameters should be chosen so that both attacks are
too expensive. But for reasonable parameters, the cost should be roughly
the same, e.g., it makes little sense to increase the size of p to 4096
bits, while sticking to only 160 bits for q.

I think it's a bit curious that each of the discrete logarithm above are
closely related to a factoring algorithm.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131206221019</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2013-12-06 22:10:19-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>


On Fri 2013-12-06 15:12:57 -0500, Niels Möller wrote:
&gt; I think the main point of the smaller group in DSA is to get small
&gt; signatures.
&gt;
&gt; And discrete logs in the large group and discrete logs in the small
&gt; subgroup are of comparable difficulty, because there's more structure in
&gt; the larger group ("index calculus" is the name of the trick, iirc).

cool, thanks, i'll look into that further.

&gt; For DH, I don't think there's any particular reason to prefer to work in
&gt; a small subgroup. But I may be missing something, of course.

I can think of a few, but i'm not sure how legitimate they are:

One is based on minimized entropy: If you know your small subgroup is of
size q, then you need less entropy to choose your secret A in the DH key
exchange, since it never needs to exceed q.

another might be efficiency of modular exponentiation: if you use
exponentiation by squaring, then the cost of calculating A' = g^A mod p
where A &lt; q should be O(log_2(q)) instead of O(log_2(p)) where A &lt; p.
So if q has half the bits of p, you'd halve the amount of computation.

The second modular exponentiation (B'^A mod p) would be similarly
faster.  Both of these factors seem like they might be significant in a
TLS endpoint that terminates many DHE sessions per second, but i haven't
profiled them.

what do you think?

         --dkg

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20131206223143</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-06 22:31:43-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; cool, thanks, i'll look into that further.

You can start with Handbook of Applied Cryptography, sec. 3.6 (available
as pdfs at http://cacr.uwaterloo.ca/hac/).

&gt;&gt; For DH, I don't think there's any particular reason to prefer to work in
&gt;&gt; a small subgroup. But I may be missing something, of course.
&gt;
&gt; I can think of a few, but i'm not sure how legitimate they are:
&gt;
&gt; One is based on minimized entropy: If you know your small subgroup is of
&gt; size q, then you need less entropy to choose your secret A in the DH key
&gt; exchange, since it never needs to exceed q.

I doubt this matters, if you have a decent and properly seeded
pseudorandomness generator.

&gt; another might be efficiency of modular exponentiation: if you use
&gt; exponentiation by squaring, then the cost of calculating A' = g^A mod p
&gt; where A &lt; q should be O(log_2(q)) instead of O(log_2(p)) where A &lt; p.
&gt; So if q has half the bits of p, you'd halve the amount of computation.

I think this is true also for more sophisticated exponentiation
algorithms. Cost is linear in exponent size.

&gt; The second modular exponentiation (B'^A mod p) would be similarly
&gt; faster.  Both of these factors seem like they might be significant in a
&gt; TLS endpoint that terminates many DHE sessions per second, but i haven't
&gt; profiled them.

Could well be. I'd like to hear what Nikos says about this.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131207065123</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-12-07 06:51:23-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>

On Fri, 2013-12-06 at 23:31 +0100, Niels Möller wrote:

&gt; &gt; The second modular exponentiation (B'^A mod p) would be similarly
&gt; &gt; faster.  Both of these factors seem like they might be significant in a
&gt; &gt; TLS endpoint that terminates many DHE sessions per second, but i haven't
&gt; &gt; profiled them.
&gt; Could well be. I'd like to hear what Nikos says about this.

Yes, this is the reason I used this format for primes in gnutls. Other
implementations use a prime that as you suggested has a very large prime
factor of p-1 (comparable to p), and then select their key with a size
based on a security parameter (e.g. 256 bits). Both cases are considered
secure, but I find the former format and usage of the group more
elegant.

To make things interesting, in TLS the client has no information on the
construction of p (or the order of g), so it has to select an 1&lt;x&lt;p-1,
which make his computation a bit slower.

regards,
Nikos



</body></email><email><emailId>20131207065352</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-12-07 06:53:52-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>

On Fri, 2013-12-06 at 20:00 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt; &gt;  I tried to switch gnutls to use dsa_generate_keypair() to generate
&gt; &gt; primes for the DH key exchange, but unfortunately this interface has the
&gt; &gt; strict DSS checks for q_bits.
&gt; 
&gt; I'm not sure what's the right thing is here.
&gt; 
&gt; Simplest would be to just drop these requirements from
&gt; dsa_generate_keypair, and let it do whatever the caller asks for. Do you
&gt; think that makes sense?

Sounds reasonable. Nettle is low-level anyway.

&gt; Related issue, which soemone else asked about some week ago, is
&gt; separating generation of DSA parameters (i.e., p, q, g) from generation
&gt; of the key pair. Currently, there's no easy way in nettle to generate a
&gt; key for some pre-specified DSA group. It might be better to have
&gt; something like

I find that also useful. Now I just discard to values of x and y when I
generate parameters, and generate the keys at later point (when there is
an actual TLS connection).

&gt; (a bit analogous to the new ecdsa code). But that would be a pretty
&gt; large and incompatible change, so we maybe shouldn't do that, or at
&gt; least think carefully about compatibility.

In the master branch you break the ABI anyway, so it may be a good time
to introduce that. Otherwise you may simply introduce new functions for
the new structures and leave the old API intact.

regards,
Nikos



</body></email><email><emailId>20131209162347</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-09 16:23:47-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; On Fri, 2013-12-06 at 20:00 +0100, Niels Möller wrote:
&gt;&gt; Simplest would be to just drop these requirements from
&gt;&gt; dsa_generate_keypair, and let it do whatever the caller asks for. Do you
&gt;&gt; think that makes sense?
&gt;
&gt; Sounds reasonable. Nettle is low-level anyway.

I'll strive for that then. It's some work to support arbitrary p_size &gt;
q_size, though. I've spent some of the day looking into pocklington's
theorem and variants again. The cases q_size &lt; p_size/2 and q_size &gt;
p_size / 2 need different handling.

&gt; In the master branch you break the ABI anyway, so it may be a good time
&gt; to introduce that. Otherwise you may simply introduce new functions for
&gt; the new structures and leave the old API intact.

I think I can do that *almost* without breaking source-level
compatibility. API draft:

New structs:

  struct dsa_params
  {  
    /* Modulo */
    mpz_t p;
  
    /* Group order */
    mpz_t q;
  
    /* Generator */
    mpz_t g;
  };

  struct dsa_value
  {
    const struct dsa_params *params;
    /* For private keys, represents an exponent (0 &lt; x &lt; q). For public
       keys, represents a group element, 0 &lt; x &lt; p) */
    mpz_t x;
  };           

New functions:

  int
  dsa_sign(const struct dsa_value *key,
  	 void *random_ctx, nettle_random_func *random,
  	 size_t digest_size,
  	 const uint8_t *digest,
  	 struct dsa_signature *signature);
  
  int
  dsa_verify(const struct dsa_value *pub,
  	   size_t digest_size,
  	   const uint8_t *digest,
  	   const struct dsa_signature *signature);

These two names exists in the repo since a few weeks ago, but in no
released version, so it's no problem to change them.

  void
  dsa_generate_params (struct dsa_params *params,
  
  		     void *random_ctx, nettle_random_func *random,
  
  		     void *progress_ctx, nettle_progress_func *progress,
  		     unsigned p_bits, unsigned q_bits);

New, obviously.

  int
  dsa_generate_keypair (struct dsa_value *pub,
  		      struct dsa_value *key,
  
  		      void *random_ctx, nettle_random_func *random);

THis is a change of an advertised function in the API, and it existing
code. Not sure what to do, either, give a new name to the new function.
Or rename the old function, and let applications do preprocessor tricks
like

#ifdef dsa_generate_keypair_old
#undef dsa_generate_keypair
#define dsa_generate_keypair dsa_generate_keypair_old
#endif

if they want to keep using the old function with no other changes. Or
check some define #NETTLE_OLD_DSA_API in the header file to do that
extra name mangling for the application.

And the rest of the old DSA API kept with no changes, possibly to be
retired in the distant future.

Comments?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131209190640</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-12-09 19:06:40-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>

On Mon, 2013-12-09 at 17:23 +0100, Niels Möller wrote:

&gt; &gt;&gt; Simplest would be to just drop these requirements from
&gt; &gt;&gt; dsa_generate_keypair, and let it do whatever the caller asks for. Do you
&gt; &gt;&gt; think that makes sense?
&gt; &gt; Sounds reasonable. Nettle is low-level anyway.
&gt; 
&gt; I'll strive for that then. It's some work to support arbitrary p_size &gt;
&gt; q_size, though. I've spent some of the day looking into pocklington's
&gt; theorem and variants again. The cases q_size &lt; p_size/2 and q_size &gt;
&gt; p_size / 2 need different handling.

I think having a limitation that q_size &lt; p_size/2 is pretty much
reasonable. The recommendations for DH parameters have q_size &lt;&lt;
p_size/2.

&gt; I think I can do that *almost* without breaking source-level
&gt; compatibility. API draft:

Looks reasonable.

&gt; THis is a change of an advertised function in the API, and it existing
&gt; code. Not sure what to do, either, give a new name to the new function.
&gt; Or rename the old function, and let applications do preprocessor tricks
&gt; like
&gt; 
&gt; #ifdef dsa_generate_keypair_old
&gt; #undef dsa_generate_keypair
&gt; #define dsa_generate_keypair dsa_generate_keypair_old
&gt; #endif

I don't think it makes much sense to keep the old function if the ABI
breaks anyway. It's not that big deal of a change, but it's up to you.

regards,
Nikos



</body></email><email><emailId>20131209213412</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-09 21:34:12-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I think having a limitation that q_size &lt; p_size/2 is pretty much
&gt; reasonable. The recommendations for DH parameters have q_size &lt;&lt;
&gt; p_size/2.

Good to know. I was thinking that, e.g., p_size = q_size + 1 (and p = 2q
+ 1) was important. But maybe that's a special case, and the general
case of q_size close to p_size is not very important?

&gt; I don't think it makes much sense to keep the old function if the ABI
&gt; breaks anyway. It's not that big deal of a change, but it's up to you.

My concerns here are mainly with source-level API (since we already know
there will be an ABI break). It helps applications to transition to the
new version if it's reasonably easy to write code which works with both
the new and the old version. So they can do minimal changes to be able
to compile with either version, and later move over to use the new API.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131005134503</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-10-05 13:45:03-0400</timestampReceived><subject>Re: PBKDF2 generic hashing method: unclear usage, examples needed</subject><body>

Ted Zlatanov &lt;tzz@lifelogs.com&gt; writes:

&gt; I'm trying to use the Nettle PBKDF2 functionality from Emacs.

Cool! What will it be used for?

&gt; I tried this, given alg is a pointer to a nettle_hash:
&gt;
&gt;    HMAC_SET_KEY(ctx, alg, SCHARS (key), SDATA (key));
&gt;    PBKDF2 (ctx, alg-&gt;update, alg-&gt;digest, alg-&gt;digest_size, XINT
&gt; (iterations), SCHARS (salt), SDATA (salt), outlength, digest);

I'm afraid the HMAC_CTX macro, if that's what you are using, doesn't
work so well with the nettle_hash abstraction. It wants to know the
concrete type, e.g., struct sha1_ctx, which you don't have if you work
with the struct nettle_hash interface.

In the above example, the ctx argument to HMAC_SET_KEY needs to have
fields outer, inner and state, each with size (and struct offsets)
matching alg-&gt;context_size. And the update and digest pointers passed to
PBKDF2 must be update and digest for the HMAC operation, *not* for the
underlying hash.

To use hmac with an arbitrary nettle_hash object, I'd suggest something like

  struct hmac_gen_ctx
  {
    const struct nettle_hash *alg;
    uint8_t state[1]; /* Variable size; three hashing contexts */
  };

  struct hmac_gen_ctx *
  hmac_gen_new (const struct nettle_hash *alg,
  	        unsigned length, const uint8_t *key)
  {
    /* NOTE: This could possibly produce bad alignment; if so, allocate
     * separate storage for outer, inner and state, or round up the
     * context size. */
    struct hmac_gen_ctx *ctx = xalloc (sizeof(*ctx) - 1 + 3*alg-&gt;context_size);
    ctx-&gt;alg = alg;
    hmac_set_key (ctx-&gt;state, /* outer */
		  ctx-&gt;state + ctx-&gt;alg-&gt;context_size, /* inner */
		  ctx-&gt;state + 2*ctx-&gt;alg-&gt;context_size, /* hmac state */
		  ctx-&gt;alg, length, key);
  
    return ctx;
  }

  void
  hmac_gen_update (struct hmac_gen_ctx *ctx, unsigned length, const uint8_t *data)
  {
    hmac_update(ctx-&gt;state + 2*ctx-&gt;alg-&gt;context_size,
		ctx-&gt;alg, length, data);
  }
  
  void
  hmac_gen_digest (struct hmac_gen_ctx *ctx, unsigned length, uint8_t *digest)
  {
    hmac_digest (ctx-&gt;state, /* outer */
		 ctx-&gt;state + ctx-&gt;alg-&gt;context_size, /* inner */
		 ctx-&gt;state + 2*ctx-&gt;alg-&gt;context_size, /* hmac state */
		 ctx-&gt;alg, length, digest);
  }

Then you can can pass a struct hmac_gen_ctx * pointer together with the
hmac_gen_update and hmac_gen_digest functions to the pbkdf2 call, like

  pbkdf2_gen (const struct nettle_hash *alg,
              unsigned key_length, const uint8_t *key,
              unsigned iterations,
              unsigned salt_length, const uint8_t *salt,
              unsigned length, uint8_t *dst)
  {
    struct hmac_gen_ctx *prf = hmac_gen_new (alg, key_length, key);
    pbkdf2 (prf, (nettle_hash_update_func *) hmac_gen_update,
	    (nettle_hash_digest_func *) hmac_gen_digest,
            alg-&gt;digest_size, iterations,
            salt_length, salt,
            length, *dst);
    free (prf);
}

Code above totally untested, but I hope you get the idea.

Any concrete suggestions on how to improve the documentation?

Happy hacking,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130916224620</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-09-16 22:46:20-0400</timestampReceived><subject>Re: GCM vs SHA1</subject><body>

On 09/16/2013 10:04 PM, Niels Möller wrote:
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt;&gt; Nikos noted (off list) that Nettle's gcm hashing is slower than sha1.
&gt;&gt; Which seems contrary to what's expected.
&gt; 
&gt; If people expect that gcm is faster than ha1, I'm curious how they reaon.

Hello Niels,
 It seems that also the original GCM description claims as such,
although no details are given:
http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/gcm/gcm-spec.pdf

There is also some talk that claims the same, but I couldn't access the
(possibly more detailed) papers from the author, as they were behind a
paywall.
https://crypto.stanford.edu/RealWorldCrypto/slides/gueron.pdf‎

regards,
Nikos


</body></email><email><emailId>20130508072953</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-05-08 07:29:53-0400</timestampReceived><subject>Re: arm compilation</subject><body>

On Wed, 8 May 2013, Nikos Mavrogiannopoulos wrote:

&gt; Trying with the latest buildroot another error is issued:
&gt;
&gt; arm-buildroot-linux-uclibcgnueabi-as -v
&gt; GNU assembler version 2.21.1 (arm-buildroot-linux-uclibcgnueabi) using
&gt; BFD version (GNU Binutils) 2.21.1
&gt;
&gt; arm-buildroot-linux-uclibcgnueabi-gcc -I.  -DHAVE_CONFIG_H -pipe -Os
&gt; -Wno-pointer-sign -Wall -W   -Wmissing-prototypes -Wmissing-declarations
&gt; -Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast
&gt; -Wnested-externs -fpic -MT aes-encrypt-internal.o -MD -MP -MF
&gt; aes-encrypt-internal.o.d -fpic -c aes-encrypt-internal.s
&gt; aes-encrypt-internal.s: Assembler messages:
&gt; aes-encrypt-internal.s:140: Error: selected processor does not support
&gt; ARM mode `uxtb r8,r2'
&gt; aes-encrypt-internal.s:142: Error: selected processor does not support
&gt; ARM mode `uxtb r8,r3'
&gt; aes-encrypt-internal.s:144: Error: selected processor does not support
&gt; ARM mode `uxtb r8,r12'
&gt; aes-encrypt-internal.s:146: Error: selected processor does not support
&gt; ARM mode `uxtb r8,r14'

The uxtb instruction requires ARMv6, while an ARM10 is ARMv5, afaik.

So the functions using uxtb should only be enabled if the target is &gt;= 
ARMv6, not arm in general. (The check can probably be done by testing to 
assemble such instructions, just as the check for neon does.)

// Martin

</body></email><email><emailId>20130508074130</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-05-08 07:41:30-0400</timestampReceived><subject>Re: arm compilation</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;  Trying to build nettle 2.7 for an arm10 system of mine using its (old)
&gt; toolchain fails with assembler errors.
&gt;
&gt; arm-linux-gcc -Os  -I[...] -I.  -DHAVE_CONFIG_H -g -O2 -ggdb3
&gt; -Wno-pointer-sign -Wall -W   -Wmissing-prototypes -Wmissing-declarations
&gt; -Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast
&gt; -Wnested-externs -fpic -MT aes-decrypt-internal.o -MD -MP -MF
&gt; aes-decrypt-internal.o.d -fpic -c aes-decrypt-internal.s
&gt; aes-decrypt-internal.s: Assembler messages:
&gt; aes-decrypt-internal.s:81: Error: bad instruction `push
&gt; {r4,r5,r6,r7,r8,r10,r11,lr}'
&gt; aes-decrypt-internal.s:87: Error: register or shift expression expected
&gt; -- `orr r4,r8,lsl#8'
&gt; aes-decrypt-internal.s:89: Error: register or shift expression expected
&gt; -- `orr r4,r8,lsl#16'
&gt; aes-decrypt-internal.s:91: Error: register or shift expression expected
&gt; -- `orr r4,r8,lsl#24'
&gt; aes-decrypt-internal.s:93: Error: bad arguments to instruction -- `eor
&gt; r4,r8'
&gt; [...]
&gt; make[2]: *** [aes-decrypt-internal.o] Error 1

I recently got a similar bugreport from a user with an arm system
running freebsd with an ancient GNU as. I think it would make sense to
use more traditional ARM asm syntax. Things I'm aware of:

1. Always use 3-operand form instructions, i.e.,

     add r1, r1, r2

   rather then

     add r1, r2

2. Write shift and rotate instructions as mov with a shift/rotate
   operand.

3. Add explicit ia/db suffixes on push, pop, ldm, stm.

4. Some file uses "unified" assembler syntax. Revert to traditional arm
   syntax (unless we have a good reason to support compiling to thumb
   instructions? I don't really understand pros and cons there).

I don't have time to test that right now, but patches are welcome. Is it
a common enough problem that it motivates a bug-fix release?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130508074751</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-05-08 07:47:51-0400</timestampReceived><subject>Re: arm compilation</subject><body>


On Wed, 8 May 2013, Niels Möller wrote:

&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt;
&gt;&gt;  Trying to build nettle 2.7 for an arm10 system of mine using its (old)
&gt;&gt; toolchain fails with assembler errors.
&gt;&gt;
&gt;&gt; arm-linux-gcc -Os  -I[...] -I.  -DHAVE_CONFIG_H -g -O2 -ggdb3
&gt;&gt; -Wno-pointer-sign -Wall -W   -Wmissing-prototypes -Wmissing-declarations
&gt;&gt; -Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast
&gt;&gt; -Wnested-externs -fpic -MT aes-decrypt-internal.o -MD -MP -MF
&gt;&gt; aes-decrypt-internal.o.d -fpic -c aes-decrypt-internal.s
&gt;&gt; aes-decrypt-internal.s: Assembler messages:
&gt;&gt; aes-decrypt-internal.s:81: Error: bad instruction `push
&gt;&gt; {r4,r5,r6,r7,r8,r10,r11,lr}'
&gt;&gt; aes-decrypt-internal.s:87: Error: register or shift expression expected
&gt;&gt; -- `orr r4,r8,lsl#8'
&gt;&gt; aes-decrypt-internal.s:89: Error: register or shift expression expected
&gt;&gt; -- `orr r4,r8,lsl#16'
&gt;&gt; aes-decrypt-internal.s:91: Error: register or shift expression expected
&gt;&gt; -- `orr r4,r8,lsl#24'
&gt;&gt; aes-decrypt-internal.s:93: Error: bad arguments to instruction -- `eor
&gt;&gt; r4,r8'
&gt;&gt; [...]
&gt;&gt; make[2]: *** [aes-decrypt-internal.o] Error 1
&gt;
&gt; I recently got a similar bugreport from a user with an arm system
&gt; running freebsd with an ancient GNU as. I think it would make sense to
&gt; use more traditional ARM asm syntax. Things I'm aware of:
&gt;
&gt; 1. Always use 3-operand form instructions, i.e.,
&gt;
&gt;     add r1, r1, r2
&gt;
&gt;   rather then
&gt;
&gt;     add r1, r2
&gt;
&gt; 2. Write shift and rotate instructions as mov with a shift/rotate
&gt;   operand.
&gt;
&gt; 3. Add explicit ia/db suffixes on push, pop, ldm, stm.
&gt;
&gt; 4. Some file uses "unified" assembler syntax. Revert to traditional arm
&gt;   syntax (unless we have a good reason to support compiling to thumb
&gt;   instructions? I don't really understand pros and cons there).

I wouldn't suggest moving away from the unified syntax - being able to 
build for both thumb and arm from the same source is useful. Normally it's 
sufficient to support only arm mode, but there are certain cases where you 
want/need to build in thumb mode. One of them is the fact that windows 8 
on arm (WinRT and Windows Phone 8) only supports thumb mode.

If the instructions can be written more elaborately to allow older tools 
to assemble them, without making the code itself worse, it's probably a 
good tradeoff.

// Martin

</body></email><email><emailId>20130508080518</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-05-08 08:05:18-0400</timestampReceived><subject>Re: arm compilation</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; The uxtb instruction requires ARMv6, while an ARM10 is ARMv5, afaik.

I see.

&gt; So the functions using uxtb should only be enabled if the target is &gt;=
&gt; ARMv6, not arm in general. (The check can probably be done by testing
&gt; to assemble such instructions, just as the check for neon does.)

So the aes functions could be moved to an arm/v6 subdirectory (the uxtb
occurs in aes.m4, included in the aes-*.asm).

What alternative are there to uxtb? The easiest alternative is to have a
series of rotates and ands.

But if we sacrifice a register to hold the byte mask 0xff, uxtb can be
replaced by an and with rotate.

This even has the advantage that we can offset the rotate by two bits,
and avoid shifting the index when it is used for the table lookup.

So instead of, e.g,

	uxtb	T0, X, ror #8
	ldr	[TABLE, T0, lsl #2]

put the value 0x3fc in MASK, and do

	and	T0, MASK, X, ror#6
	ldr	[TABLE, T0]
    
Eliminating a shift/rotate operation might even make the code faster.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130508081256</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-05-08 08:12:56-0400</timestampReceived><subject>Re: arm compilation</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; I wouldn't suggest moving away from the unified syntax - being able to
&gt; build for both thumb and arm from the same source is useful.

Ok, if that is useful, I guess we should move in the opposite direction
and use it for *all* arm assembly files. But I'm worrying that the same
old assemblers which barf on

  orr r4,r8,lsl#8

may also barf on the itee instruction which is required for conditional
execution in unified syntax. Except possibly conditional branches, I
don't remember. Could of course use some configure/m4 magic to get
around that, if we think it's worth the effort.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130508082011</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-05-08 08:20:11-0400</timestampReceived><subject>Re: arm compilation</subject><body>


On Wed, 8 May 2013, Niels Möller wrote:

&gt; Martin Storsjö &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt; I wouldn't suggest moving away from the unified syntax - being able to
&gt;&gt; build for both thumb and arm from the same source is useful.
&gt;
&gt; Ok, if that is useful, I guess we should move in the opposite direction
&gt; and use it for *all* arm assembly files. But I'm worrying that the same
&gt; old assemblers which barf on
&gt;
&gt;  orr r4,r8,lsl#8
&gt;
&gt; may also barf on the itee instruction which is required for conditional
&gt; execution in unified syntax. Except possibly conditional branches, I
&gt; don't remember. Could of course use some configure/m4 magic to get
&gt; around that, if we think it's worth the effort.

Hmm, I don't have much experience with the older binutils so I don't know 
for sure if they've got a problem with the it instructions or not. In 
general this might be a good direction, but there's probably not much need 
to actually make it all the way and finish it unless someone steps up to 
do it (having an actual need at the time), as long as we aren't moving in 
the opposite direction.

// Martin

</body></email><email><emailId>20130515112541</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-05-15 11:25:41-0400</timestampReceived><subject>Re: arm compilation</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; So instead of, e.g,
&gt;
&gt; 	uxtb	T0, X, ror #8
&gt; 	ldr	[TABLE, T0, lsl #2]
&gt;
&gt; put the value 0x3fc in MASK, and do
&gt;
&gt; 	and	T0, MASK, X, ror#6
&gt; 	ldr	[TABLE, T0]
&gt;     
&gt; Eliminating a shift/rotate operation might even make the code faster.

I have tried this now. I get same speed if I do this trick to the main
round transformations. But uxtb is also used in the final round, and I'm
having some difficulty replacing that with and without making it slower.

Timing on the A9 appears to be very sensitive, adding a single
instruction, even a nop, can slow it down a lot. And for the final
round, we do substitutions via the sbox table, and hence need the mask
0xff rather than 0x3fc, and the single instruction to set that up seems
remarkably expensive. 

So I think we may need separate versions.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130516145731</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-05-16 14:57:31-0400</timestampReceived><subject>Re: arm compilation</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Trying with the latest buildroot another error is issued:
&gt;
&gt; arm-buildroot-linux-uclibcgnueabi-as -v
&gt; GNU assembler version 2.21.1 (arm-buildroot-linux-uclibcgnueabi) using
&gt; BFD version (GNU Binutils) 2.21.1
&gt;
&gt; arm-buildroot-linux-uclibcgnueabi-gcc -I.  -DHAVE_CONFIG_H -pipe -Os
&gt; -Wno-pointer-sign -Wall -W   -Wmissing-prototypes -Wmissing-declarations
&gt; -Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast
&gt; -Wnested-externs -fpic -MT aes-encrypt-internal.o -MD -MP -MF
&gt; aes-encrypt-internal.o.d -fpic -c aes-encrypt-internal.s
&gt; aes-encrypt-internal.s: Assembler messages:
&gt; aes-encrypt-internal.s:140: Error: selected processor does not support
&gt; ARM mode `uxtb r8,r2'
&gt; aes-encrypt-internal.s:142: Error: selected processor does not support
&gt; ARM mode `uxtb r8,r3'
&gt; aes-encrypt-internal.s:144: Error: selected processor does not support
&gt; ARM mode `uxtb r8,r12'
&gt; aes-encrypt-internal.s:146: Error: selected processor does not support
&gt; ARM mode `uxtb r8,r14'

I've checked in new AES code for pre-v6 processors. Can you test if it
works now? Haven't yet tried to address the other issue, with supporting
older assemblers.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130518130504</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-05-18 13:05:04-0400</timestampReceived><subject>Re: arm compilation</subject><body>

On 05/16/2013 04:57 PM, Niels Möller wrote:


&gt;&gt; arm-buildroot-linux-uclibcgnueabi-as -v
&gt;&gt; GNU assembler version 2.21.1 (arm-buildroot-linux-uclibcgnueabi) using
&gt;&gt; BFD version (GNU Binutils) 2.21.1
&gt;&gt;
&gt;&gt; arm-buildroot-linux-uclibcgnueabi-gcc -I.  -DHAVE_CONFIG_H -pipe -Os
&gt;&gt; -Wno-pointer-sign -Wall -W   -Wmissing-prototypes -Wmissing-declarations
&gt;&gt; -Wstrict-prototypes   -Wpointer-arith -Wbad-function-cast
&gt;&gt; -Wnested-externs -fpic -MT aes-encrypt-internal.o -MD -MP -MF
&gt;&gt; aes-encrypt-internal.o.d -fpic -c aes-encrypt-internal.s
&gt;&gt; aes-encrypt-internal.s: Assembler messages:
&gt;&gt; aes-encrypt-internal.s:140: Error: selected processor does not support
&gt;&gt; ARM mode `uxtb r8,r2'
&gt;&gt; aes-encrypt-internal.s:142: Error: selected processor does not support
&gt;&gt; ARM mode `uxtb r8,r3'
&gt;&gt; aes-encrypt-internal.s:144: Error: selected processor does not support
&gt;&gt; ARM mode `uxtb r8,r12'
&gt;&gt; aes-encrypt-internal.s:146: Error: selected processor does not support
&gt;&gt; ARM mode `uxtb r8,r14'
&gt; 
&gt; I've checked in new AES code for pre-v6 processors. Can you test if it
&gt; works now? Haven't yet tried to address the other issue, with supporting
&gt; older assemblers.


I now get errors in sha1 and sha256 code. I used make -i and no other
code seems to fail.

/home/nmav/cvs/buildroot/output/host/usr/bin/ccache
/home/nmav/cvs/buildroot/output/host/usr/bin/arm-buildroot-linux-uclibcgnueabi-gcc
-I.  -DHAVE_CONFIG_H -pipe -Os  -Wno-pointer-sign -Wall -W
-Wmissing-prototypes -Wmissing-declarations -Wstrict-prototypes
-Wpointer-arith -Wbad-function-cast -Wnested-externs -fpic -MT
sha1-compress.o -MD -MP -MF sha1-compress.o.d -fpic -c sha1-compress.s
sha1-compress.s: Assembler messages:
sha1-compress.s:79: Error: selected processor does not support ARM mode
`uadd8 r7,r7,r12'
sha1-compress.s:86: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:89: Error: selected processor does not support ARM mode
`rev r12,r12'
sha1-compress.s:103: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:106: Error: selected processor does not support ARM mode
`rev r12,r12'
sha1-compress.s:120: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:123: Error: selected processor does not support ARM mode
`rev r12,r12'
sha1-compress.s:137: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:140: Error: selected processor does not support ARM mode
`rev r12,r12'
sha1-compress.s:154: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:157: Error: selected processor does not support ARM mode
`rev r12,r12'
sha1-compress.s:172: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:175: Error: selected processor does not support ARM mode
`rev r12,r12'
sha1-compress.s:189: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:192: Error: selected processor does not support ARM mode
`rev r12,r12'
sha1-compress.s:206: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:209: Error: selected processor does not support ARM mode
`rev r12,r12'
sha1-compress.s:223: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:226: Error: selected processor does not support ARM mode
`rev r12,r12'
sha1-compress.s:240: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:243: Error: selected processor does not support ARM mode
`rev r12,r12'
sha1-compress.s:258: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:261: Error: selected processor does not support ARM mode
`rev r12,r12'
sha1-compress.s:275: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:278: Error: selected processor does not support ARM mode
`rev r12,r12'
sha1-compress.s:292: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:295: Error: selected processor does not support ARM mode
`rev r12,r12'
sha1-compress.s:309: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:312: Error: selected processor does not support ARM mode
`rev r12,r12'
sha1-compress.s:326: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:329: Error: selected processor does not support ARM mode
`rev r12,r12'
sha1-compress.s:344: Error: selected processor does not support ARM mode
`sel r12,r10,r7'
sha1-compress.s:347: Error: selected processor does not support ARM mode
`rev r12,r12'

/home/nmav/cvs/buildroot/output/host/usr/bin/ccache
/home/nmav/cvs/buildroot/output/host/usr/bin/arm-buildroot-linux-uclibcgnueabi-gcc
-I.  -DHAVE_CONFIG_H -pipe -Os  -Wno-pointer-sign -Wall -W
-Wmissing-prototypes -Wmissing-declarations -Wstrict-prototypes
-Wpointer-arith -Wbad-function-cast -Wnested-externs -fpic -MT
sha256-compress.o -MD -MP -MF sha256-compress.o.d -fpic -c sha256-compress.s
sha256-compress.s: Assembler messages:
sha256-compress.s:93: Error: selected processor does not support ARM
mode `uadd8 r12,r12,r4'
sha256-compress.s:99: Error: selected processor does not support ARM
mode `sel r3,r3,r4'
sha256-compress.s:101: Error: selected processor does not support ARM
mode `rev r3,r3'
sha256-compress.s:102: Error: selected processor does not support ARM
mode `sel r4,r4,r5'
sha256-compress.s:104: Error: selected processor does not support ARM
mode `rev r4,r4'
sha256-compress.s:105: Error: selected processor does not support ARM
mode `sel r5,r5,r6'
sha256-compress.s:107: Error: selected processor does not support ARM
mode `rev r5,r5'
sha256-compress.s:108: Error: selected processor does not support ARM
mode `sel r6,r6,r7'
sha256-compress.s:110: Error: selected processor does not support ARM
mode `rev r6,r6'
make[1]: [sha256-compress.o] Error 1 (ignored)
rm -f libnettle.a

regards,
Nikos

</body></email><email><emailId>20130519061220</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-05-19 06:12:20-0400</timestampReceived><subject>Re: arm compilation</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I now get errors in sha1 and sha256 code. I used make -i and no other
&gt; code seems to fail.

I see. Does it work if you move the offending source files in arm/ to
the subdirectory arm/v6? In the build tree, you need either make
distclean, or remove corresponding symlinks manually.

The instructions which fail are used for reading the possibly unaliged
input area, and it seems some different tricks will be needed for pre-v6
ARM. (I haven't yet checked the ARM manual, so I'm not 100% sure in
which arch version they were introduced, but I guess they're also ARMv6)

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130519075805</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-05-19 07:58:05-0400</timestampReceived><subject>Re: arm compilation</subject><body>

On 05/19/2013 08:12 AM, Niels Möller wrote:

&gt;&gt; I now get errors in sha1 and sha256 code. I used make -i and no other
&gt;&gt; code seems to fail.
&gt; I see. Does it work if you move the offending source files in arm/ to
&gt; the subdirectory arm/v6? In the build tree, you need either make
&gt; distclean, or remove corresponding symlinks manually.


Yes, this is what I eventually did (i deleted those files).

regards,
Nikos

</body></email><email><emailId>20130521142559</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-05-21 14:25:59-0400</timestampReceived><subject>Re: arm compilation</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I see. Does it work if you move the offending source files in arm/ to
&gt; the subdirectory arm/v6? In the build tree, you need either make
&gt; distclean, or remove corresponding symlinks manually.

I just pushed a branch "nettle-2.7-fixes" to the public repo, intended to
also fix the pre-v6 ARM problems.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130521195625</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-05-21 19:56:25-0400</timestampReceived><subject>Re: arm compilation</subject><body>

On 05/21/2013 04:25 PM, Niels Möller wrote:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt;&gt; I see. Does it work if you move the offending source files in arm/ to
&gt;&gt; the subdirectory arm/v6? In the build tree, you need either make
&gt;&gt; distclean, or remove corresponding symlinks manually.
&gt; 
&gt; I just pushed a branch "nettle-2.7-fixes" to the public repo, intended to
&gt; also fix the pre-v6 ARM problems.


I tried to build this branch using mingw32 and I got linking issues with
libnettle.a and libhogweed.a (in that system I get libnettle.dll.a.

By fixing the makefiles to link with the LIBNETTLE_FILE and
LIBHOGWEED_FILE fixes the issue in mingw, but creates a problem on linux
where libnettle.so is built but LIBNETTLE_FILE is libnettle.so.4.7.

Any ideas?

regards,
Nikos

["patch.txt" (text/plain)]

diff --git a/examples/Makefile.in b/examples/Makefile.in
index 563d0dc..98f1d75 100644
--- a/examples/Makefile.in
+++ b/examples/Makefile.in
@@ -117,8 +117,8 @@ hogweed-benchmark$(EXEEXT): $(HOGWEED_BENCH_OBJS)
 	-lhogweed -lnettle $(BENCH_LIBS) $(LIBS) $(OPENSSL_LIBFLAGS) \
 	-o hogweed-benchmark$(EXEEXT)
 
-$(TARGETS) : io.$(OBJEXT) ../libnettle.a
-$(HOGWEED_TARGETS): ../libhogweed.a
+$(TARGETS) : io.$(OBJEXT) ../$(LIBNETTLE_FILE)
+$(HOGWEED_TARGETS): ../$(LIBHOGWEED_FILE)
 
 check: $(TS_ALL)
 	LD_LIBRARY_PATH=../.lib PATH="../.lib:$$PATH" srcdir="$(srcdir)" \
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 91f6e2a..f88b2dc 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -96,7 +96,7 @@ test-rules:
 include $(srcdir)/.test-rules.make
 
 $(TARGETS) $(EXTRA_TARGETS): testutils.$(OBJEXT) ../nettle-internal.$(OBJEXT) \
-	../libnettle.a @IF_HOGWEED@ ../libhogweed.a
+	../$(LIBNETTLE_FILE) @IF_HOGWEED@ ../$(LIBHOGWEED_FILE)
 
 # For use as, e.g.,
 #
diff --git a/tools/Makefile.in b/tools/Makefile.in
index 29d55e8..932e904 100644
--- a/tools/Makefile.in
+++ b/tools/Makefile.in
@@ -34,19 +34,19 @@ SOURCES = $(sexp_conv_SOURCES) nettle-hash.c nettle-lfib-stream.c pkcs1-conv.c
 DISTFILES = $(SOURCES) Makefile.in input.h misc.h output.h parse.h
 
 sexp_conv_OBJS = $(sexp_conv_SOURCES:.c=.$(OBJEXT)) $(getopt_OBJS)
-sexp-conv$(EXEEXT): $(sexp_conv_OBJS) ../libnettle.a
+sexp-conv$(EXEEXT): $(sexp_conv_OBJS) ../$(LIBNETTLE_FILE)
 	$(LINK) $(sexp_conv_OBJS) -lnettle $(LIBS) -o $@
 
-nettle-lfib-stream$(EXEEXT): nettle-lfib-stream.$(OBJEXT) ../libnettle.a
+nettle-lfib-stream$(EXEEXT): nettle-lfib-stream.$(OBJEXT) ../$(LIBNETTLE_FILE)
 	$(LINK) nettle-lfib-stream.$(OBJEXT) -lnettle $(LIBS) -o $@
 
 pkcs1_conv_OBJS = $(pkcs1_conv_SOURCES:.c=.$(OBJEXT)) $(getopt_OBJS)
-pkcs1-conv$(EXEEXT): $(pkcs1_conv_OBJS) ../libnettle.a ../libhogweed.a
+pkcs1-conv$(EXEEXT): $(pkcs1_conv_OBJS) ../$(LIBNETTLE_FILE) ../$(LIBHOGWEED_FILE)
 	$(LINK) $(pkcs1_conv_OBJS) -lhogweed -lnettle $(LIBS) -o $@
 
 # FIXME: Avoid linking with gmp
 nettle_hash_OBJS = $(nettle_hash_SOURCES:.c=.$(OBJEXT)) $(getopt_OBJS)
-nettle-hash$(EXEEXT): $(nettle_hash_OBJS) ../libnettle.a
+nettle-hash$(EXEEXT): $(nettle_hash_OBJS) ../$(LIBNETTLE_FILE)
 	$(LINK) $(nettle_hash_OBJS) -lnettle $(LIBS) -o $@
 
 


</body></email><email><emailId>20130521203555</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-05-21 20:35:55-0400</timestampReceived><subject>Re: arm compilation</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I tried to build this branch using mingw32 and I got linking issues with
&gt; libnettle.a and libhogweed.a (in that system I get libnettle.dll.a.

Is that a general problem, or just with this branch? There shouldn't be
any windows-related changes there.

I just tested

  $ ~/hack/nettle-stable/configure --host=i586-mingw32msvc
  $ make check

and that works fine for me (EMULATOR=wine). I guess you're doing
something differently, maybe native compilation, or w*ndows-8 on arm, or
something?

&gt; By fixing the makefiles to link with the LIBNETTLE_FILE and
&gt; LIBHOGWEED_FILE fixes the issue in mingw, but creates a problem on linux
&gt; where libnettle.so is built but LIBNETTLE_FILE is libnettle.so.4.7.

If the currrent setup doesn't work, you need to change the setup of
LIBNETTLE_FILE (or invent some new variables if required) and set it all
up inside the

  case "$host_os"

in configure.ac. And then substitute those values at the right place in
Makefile.in. I don't remember exactly how it's supposed to work, but
maybe the _FORLINK variables are the ones you need.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130522070406</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-05-22 07:04:06-0400</timestampReceived><subject>Re: arm compilation</subject><body>

On 05/21/2013 10:35 PM, Niels Möller wrote:

&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt;&gt; I tried to build this branch using mingw32 and I got linking issues with
&gt;&gt; libnettle.a and libhogweed.a (in that system I get libnettle.dll.a.
&gt; 
&gt; Is that a general problem, or just with this branch? There shouldn't be
&gt; any windows-related changes there.
&gt; I just tested
&gt; 
&gt;   $ ~/hack/nettle-stable/configure --host=i586-mingw32msvc
&gt;   $ make check
&gt; and that works fine for me (EMULATOR=wine). I guess you're doing
&gt; something differently, maybe native compilation, or w*ndows-8 on arm, or
&gt; something?


I was using the additional flags: --enable-shared --disable-static

It seems the issue was due to --disable-static with which built cannot
complete (the Makefile.ins assume that the static libraries are always
there).

regards,
Nikos

</body></email><email><emailId>20130522075352</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-05-22 07:53:52-0400</timestampReceived><subject>Re: arm compilation</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; It seems the issue was due to --disable-static with which built cannot
&gt; complete (the Makefile.ins assume that the static libraries are always
&gt; there).

I see, I haven't tested --disable-static very much, and definitely not
in this setup. Then I should be able to reproduce the problem.

About the pre-v6 ARM problems, are those solved now?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131226093923</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-12-26 09:39:23-0400</timestampReceived><subject>memxor3 could lead to invalid mem accesses</subject><body>

Hello and best wishes for new year,
 I was debugging an invalid memory access in gnutls and realized that
the issue is in memxor3 of nettle (2.7.x branch). I have not yet a fix
for that, but the attached patch modifies the memxor-test.c to reproduce 
the issue. 

regards,
Nikos

$ valgrind ./memxor-test
[...]
==26108== Invalid read of size 8
==26108==    at 0x4E817BD: memxor3 (memxor.s:137)
==26108==    by 0x4029D8: test_main (memxor-test.c:157)
==26108==    by 0x4024C6: main (testutils.c:204)
==26108==  Address 0x5094498 is 104 bytes inside a block of size 111
alloc'd
==26108==    at 0x4A0645D: malloc
(in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
==26108==    by 0x402909: test_main (memxor-test.c:152)
==26108==    by 0x4024C6: main (testutils.c:204)
==26108== 
==26108== 



["patch.txt" (patch.txt)]

diff --git a/testsuite/memxor-test.c b/testsuite/memxor-test.c
index 3319433..84d0a7d 100644
--- a/testsuite/memxor-test.c
+++ b/testsuite/memxor-test.c
@@ -73,11 +73,15 @@ test_memxor3 (const uint8_t *ain, const uint8_t *bin, const uint8_t *c,
   ASSERT (MEMEQ (size, dst, c));
   ASSERT (dst[-1] == 17);
   ASSERT (dst[size] == 17);
+
 }
 
 void
 test_main(void)
 {
+  uint8_t dst_buf[MAX_SIZE];
+  uint8_t *c_buf;
+  uint8_t *d_buf;
   const uint8_t *a = H("ecc8737f 38f2f9e8 86b9d84c 42a9c7ef"
 		       "27a50860 49c6be97 c5cc6c35 3981b367"
 		       "f8b4397b 951e3b2f 35749fe1 25884fa6"
@@ -144,4 +148,15 @@ test_main(void)
 	  for (align_b = 0; align_b &lt; ALIGN_SIZE; align_b++)
 	    test_memxor3 (a, b, c, size[i], align_dst, align_a, align_b);
 	}
+
+  c_buf = malloc(111);
+  d_buf = malloc(111);
+  memset(c_buf, 1, 111);
+  memset(d_buf, 3, 111);
+
+  memxor3 (dst_buf+13, c_buf+96, d_buf, 15);
+
+  ASSERT(dst_buf[14] == 2);
+  free(c_buf);
+  free(d_buf);
 }


</body></email><email><emailId>20131211214404</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-11 21:44:04-0400</timestampReceived><subject>Status of Poly1305 and use of AES-NI in Poly1305, UMAC?</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

What is the status of Poly1305 in Nettle, i.e. is the branch ready to be
merged into master or when might that happen?

I have to admit that I haven't studied how UMAC and Poly1305 uses (in
what phase) the block cipher. Would they gain any substantial
performance if they could use AES-NI when available?

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKo3KQACgkQZoPr8HT30QH6gwCg5Ry4e20cHvqpd8MzuFNkzhC3
fisAn0olck6OFNqh6FHkvd9Kx/YKD7mn
=Zn5G
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131226210017</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-26 21:00:17-0400</timestampReceived><subject>Re: memxor3 could lead to invalid mem accesses</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;  I was debugging an invalid memory access in gnutls and realized that
&gt; the issue is in memxor3 of nettle (2.7.x branch). I have not yet a fix
&gt; for that, but the attached patch modifies the memxor-test.c to reproduce 
&gt; the issue. 

Hmm. If you have, e.g., a 14 byte block starting at address 0x1001, it
usually harmless to do read that data as a two aligned reads at address
0x1000 and 0x1008, and then ignore the data outside of the area.
Valgrind usually doesn't warn about that.

Now memxor on x86_64 is a bit special, since it tries to align the
*writes*, but it does full-word *unaligned* reads. In this case, reading
outside of the input area may cause serious problems, e.g, crossing a
page boundary.

So this might be a fairly serious bug in the memxor assembly code.

&gt;  void
&gt;  test_main(void)
&gt;  {
&gt; +  uint8_t dst_buf[MAX_SIZE];
&gt; +  uint8_t *c_buf;
&gt; +  uint8_t *d_buf;
&gt;    const uint8_t *a = H("ecc8737f 38f2f9e8 86b9d84c 42a9c7ef"
&gt;  		       "27a50860 49c6be97 c5cc6c35 3981b367"
&gt;  		       "f8b4397b 951e3b2f 35749fe1 25884fa6"
&gt; @@ -144,4 +148,15 @@ test_main(void)
&gt;  	  for (align_b = 0; align_b &lt; ALIGN_SIZE; align_b++)
&gt;  	    test_memxor3 (a, b, c, size[i], align_dst, align_a, align_b);
&gt;  	}
&gt; +
&gt; +  c_buf = malloc(111);
&gt; +  d_buf = malloc(111);
&gt; +  memset(c_buf, 1, 111);
&gt; +  memset(d_buf, 3, 111);
&gt; +
&gt; +  memxor3 (dst_buf+13, c_buf+96, d_buf, 15);
&gt; +
&gt; +  ASSERT(dst_buf[14] == 2);
&gt; +  free(c_buf);
&gt; +  free(d_buf);
&gt;  }

What result do you get with this test? Does it fail the assert, or does
it exit successfuly when running without valgrind, but generate
warnings/errors with valgrind?

The memxor-test.c in the repo tries to run memxor and memxor3 with all
combinations of alignments and a selection of different sizes. And I get
no warnings from

  make check EMULATOR='$(VALGRIND)' TS_ALL=memxor-test

As far as I see, those tests *should* include the same size and alignments
as in your test, so I wonder what's going on here.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131227092156</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-12-27 09:21:56-0400</timestampReceived><subject>Re: memxor3 could lead to invalid mem accesses</subject><body>

On Thu, 2013-12-26 at 22:00 +0100, Niels Möller wrote:

&gt; What result do you get with this test? Does it fail the assert, or does
&gt; it exit successfuly when running without valgrind, but generate
&gt; warnings/errors with valgrind?

It exits successfully but prints the valgrind warning (shown in the
previous message). 

&gt; The memxor-test.c in the repo tries to run memxor and memxor3 with all
&gt; combinations of alignments and a selection of different sizes. And I get
&gt; no warnings from

Do you get a warning after applying the patch?
The alignment in the patch is exactly the same combination that causes
the issue in the gnutls test cases, and seems to be dst:13, buf1:0,
buf2:0.

In the memxor tests, do you put the buffers at a zone exactly at the
ending position of the buffer, or there is some slack size at the end?
In the latter case you'll not see any read past the boundary (though I
see that you catch any write).

regards,
Nikos



</body></email><email><emailId>20131210080809</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-12-10 08:08:09-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>

On Mon, Dec 9, 2013 at 10:34 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:

&gt;&gt; I think having a limitation that q_size &lt; p_size/2 is pretty much
&gt;&gt; reasonable. The recommendations for DH parameters have q_size &lt;&lt;
&gt;&gt; p_size/2.
&gt; Good to know. I was thinking that, e.g., p_size = q_size + 1 (and p = 2q
&gt; + 1) was important. But maybe that's a special case, and the general
&gt; case of q_size close to p_size is not very important?

Other implementations use it (or more precise they use safe primes
rather than set q explicitly). If that use-case is required, having a
different function to generate safe primes seems good enough.

regards,
Nikos

</body></email><email><emailId>20131210195358</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-10 19:53:58-0400</timestampReceived><subject>Re: benchmarks</subject><body>

Werner Koch &lt;wk@gnupg.org&gt; writes:

&gt; But the whole discussion is moot; Nettle and Libgcrypt are very
&gt; different and there is no need to merge them.

I imagine that it would be technically possible to write libgcrypt so
that parts of it is a thin layer on top of Nettle. For a simple example,
in libcgrypt/cipher/md5.c, either replace the transform function with a
call to _nettle_md5_compress (which is implemented in assembly on some
platforms, and somewhat internal).

Or write the internal (not visible in libgcrypt's ABI) MD5_CONTEXT as
something like

#include &lt;nettle/md5.h&gt;
typedef struct
{
  struct md5_ctx ctx;
  uint8_t digest[MD5_DIGEST_SIZE];
} MD5_CONTEXT;

and redefine _gcr_digest_spec_md5 to point to corresponding nettle
functions, or trivial wrappers if needed.

I see that there's some impedance mismatch, e.g.,
(init,write,final,read), vs (init,update,digest). I can't say if that's
a big deal, aesthetically or in terms of performance overhead.

Now, there may sure be good reasons why that's an undesirable change,
but I'd like to understand what the obstacles are. The advantage is
sharing of more low-level code. And if libgcrypt is faster than nettle
for some particular algorithm, we'd obviously want to get the faster
code into Nettle before changing libgcrypt.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131211093729</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-11 09:37:29-0400</timestampReceived><subject>Safe curves (was: brainpool, Curve25519)</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

New to the list and responding to an old thread re curves.

In September Nikos mentioned the Brainpool curves:
http://tools.ietf.org/html/rfc5639

Daniel responded by pointing to Curve25519 by DJB:
http://ed25519.cr.yp.to/

DJB and Tanja Lange has a good page about different specified and
standardized curves:

http://safecurves.cr.yp.to/

Note that they don't consider the Brainpool curves as safe. I myself is
somewhat cautious due to their origin.

Having Curve25519 and its sister Curve3617 would be really nice albeit
for acceptance, support for the NIST curves might be needed.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKoMlkACgkQZoPr8HT30QGyvQCfcTSEnhWXy12zEWmsdb7SPK9M
isYAoO7BJ1FeJxBaqIw1UROxFf1T9rXO
=mHZ7
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131211121255</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-11 12:12:55-0400</timestampReceived><subject>Re: Adding number of rounds to context for Salsa20?</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; I'm looking at the source for Salsa20 and notice that there are separate
&gt; versions for Salsa20 with 20 rounds and Salsa20 with 12 rounds (with
&gt; specific r12 function names).
&gt;
&gt; Would it be possible to instead add the given number of rounds to the
&gt; context?

Nettle is slowly moving away from the style of a context struct
including fields which differentiate between variants of an algorithm.

If such a salsa20 context is convenient for you, you could easily define
your own context struct as

  struct salsa20_any_ctx
  {
    struct salsa20_ctx ctx;
    unsigned nrounds;
  };

But you'd also need a variant of salsa20_crypt, say salsa20r_crypt,
which takes the number of rounds as argument, so you could define

  void
  salsa20_any_crypt (struct salsa20_any_ctx *ctx, ...)
  {
    salsa20r_crypt (&amp;ctx-&gt;ctx, ctx-&gt;nrounds, ...);
  }

To add such a function has been discussed earlier, but it has not been
added because there was no clear use case for it. If you want to
experiment, you can write one based on salsa20_crypt and salsa20r12.

The internal function _salsa20_core does take the number of rounds as an
argument. I can't say, 	without checking the various implementations of
that function (C, x86_64 and arm), which values besides 12 and 20 really
work.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131212073308</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-12 07:33:08-0400</timestampReceived><subject>Re: Status of Poly1305 and use of AES-NI in Poly1305, UMAC?</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; What is the status of Poly1305 in Nettle, i.e. is the branch ready to be
&gt; merged into master

There are a couple of things I'd like to do. Quoting a mail from 21/11:

* Take out the nonce from struct poly1305_ctx, and let poly1305_aes do
  all nonce handling. poly1305_digest gets the encrypted nonce as
  argument.

* For poly1305_aes, use aes128_ctx (it's hard coded for 128-bit AES
  anyway), and perhaps rename it to poly1305_aes128.

* Introduce a poly1305_update function, and use preprocessor casting
  tricks to define poly1305_aes128_update (and any other
  poly1305_*_update) as an alias.

* Promote union gcm_block to a more general abstraction, renaming it to
  nettle_block16 or so, and use it to guarantee nicer alignment for
  block buffer and nonce in poly1305.

&gt; or when might that happen?

Not sure, I'd need a day or so of hacking time to finish the above.

&gt; I have to admit that I haven't studied how UMAC and Poly1305 uses (in
&gt; what phase) the block cipher. Would they gain any substantial
&gt; performance if they could use AES-NI when available?

Improving aes performance would sure be generally good, but it doesn't
matter much for umac and poly1305. umac uses aes to generate its subkeys
(which can be a fair amount of data), and both use aes to encrypt the
nonce. But the heavy mangling of the message bytes doesn't depend on
aes.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131213094022</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-13 09:40:22-0400</timestampReceived><subject>Re: ChaCha stream cipher for Nettle available</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Niels Möller wrote:
&gt; Right, and this time in openssl's favour. I think that speed is
&gt; quite impressive. I haven't written any arcfour assembly for x86_64,
&gt; but I have tried earlied for x86 and sparc. It's a very serial loop
&gt; doing one byte at a time. It's tempting to try to do two bytes at a
&gt; time, but the easy way gives incorrect results when the i and j
&gt; indices happen to collide.

Yes, that is a problem. I've implemented RC4 in HW running at 2
cycles/byte but you end up dealing with collisions (and deep logic in
combination with mem/reg lookup for state. And overlapping scheduling.
And many memory ports.)


&gt; An easier trick is to generate 4 or eight bytes of the keystream at
&gt; a time, collecting result in a register, so the xoring of the data
&gt; can be done a word at a time. The sparc implementation does something
&gt; along those lines, and at least does the data writes as aligned
&gt; words.

Sounds like the best strategy, there really isn't much parallelism in
RC4 and initialization is costly esp if one want to removed bias by
throwing awat 256, 512, 768, 1024 etc bytes (depending in which
suggested recommendation you want to follow.)

I tried looking at the OpenSSL ASM-code to see if one could to a simple
fix to Nettle. Naive I admit.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKq1gYACgkQZoPr8HT30QH5LwCcDiyV8R16OurwBRBx5E+ocHlR
X8EAoMjA92kIZ4DbC1M445+bgAhzbC55
=qsEd
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131213114637</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-13 11:46:37-0400</timestampReceived><subject>[PATCH] source files for chacha</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Here is the patch for the chacha implementation. I will create and send
patches for the benchmark, meta, testsuite code when I get nettle to
properly build. The code in this patch and my own test program builds
and runs as available at:

https://github.com/secworks/nettle/tree/master/chacha

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKq85wACgkQZoPr8HT30QG8JgCfc/scXdxeXKJQSMWsWe7LNDHV
8qwAoN43hGYj1VkXadW65INvvm9OnSyY
=AAyY
-----END PGP SIGNATURE-----

["0001-Moved-chacha-files-into-the-repo.patch" (text/plain)]

From 1ca7b54879045f7f3a61db73ae1540d22cba8871 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Joachim Strömbergson?= &lt;joachim@secworks.se&gt;
Date: Fri, 13 Dec 2013 10:01:34 +0100
Subject: [PATCH] Moved chacha files into the repo.

---
 chacha-core-internal.c | 120 +++++++++++++++++++++++++++++++++++++++++++++++++
 chacha-crypt.c         |  89 ++++++++++++++++++++++++++++++++++++
 chacha-init.c          |  92 +++++++++++++++++++++++++++++++++++++
 chacha.h               |  99 ++++++++++++++++++++++++++++++++++++++++
 4 files changed, 400 insertions(+)
 create mode 100644 chacha-core-internal.c
 create mode 100644 chacha-crypt.c
 create mode 100644 chacha-init.c
 create mode 100644 chacha.h

diff --git a/chacha-core-internal.c b/chacha-core-internal.c
new file mode 100644
index 0000000..1c80f57
--- /dev/null
+++ b/chacha-core-internal.c
@@ -0,0 +1,120 @@
+/* chacha-core-internal.c
+ *
+ * Core functionality of the ChaCha stream cipher.
+ * Heavily based on the Salsa20 implementation in Nettle.
+ *
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Joachim Strömbergson
+ * Copyright (C) 2012 Simon Josefsson, Niels Möller
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+/* Based on:
+   chacha-ref.c version 2008.01.20.
+   D. J. Bernstein
+   Public domain.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "chacha.h"
+
+#include "macros.h"
+
+#ifndef CHACHA_DEBUG
+# define CHACHA_DEBUG 0
+#endif
+
+#if CHACHA_DEBUG
+# include &lt;stdio.h&gt;
+# define DEBUG(i) do {				\
+    unsigned debug_j;				\
+    for (debug_j = 0; debug_j &lt; 16; debug_j++)	\
+      {						\
+	if (debug_j == 0)			\
+	  fprintf(stderr, "%2d:", (i));		\
+	else if (debug_j % 4 == 0)		\
+	  fprintf(stderr, "\n   ");		\
+	fprintf(stderr, " %8x", x[debug_j]);	\
+      }						\
+    fprintf(stderr, "\n");			\
+  } while (0)
+#else
+# define DEBUG(i)
+#endif
+
+#ifdef WORDS_BIGENDIAN
+#define LE_SWAP32(v)				\
+  ((ROTL32(8,  v) &amp; 0x00FF00FFUL) |		\
+   (ROTL32(24, v) &amp; 0xFF00FF00UL))
+#else
+#define LE_SWAP32(v) (v)
+#endif
+
+#define QROUND(x0, x1, x2, x3) do { \
+  x0 = x0 + x1; x3 = ROTL32(16, (x0 ^ x3)); \
+  x2 = x2 + x3; x1 = ROTL32(12, (x1 ^ x2)); \
+  x0 = x0 + x1; x3 = ROTL32(8,  (x0 ^ x3)); \
+  x2 = x2 + x3; x1 = ROTL32(7,  (x1 ^ x2)); \
+  } while(0)
+
+void
+_chacha_core(uint32_t *dst, const uint32_t *src, uint8_t rounds)
+{
+  uint32_t x[_CHACHA_STATE_LENGTH];
+  unsigned i;
+
+  assert ( (rounds &amp; 1) == 0);
+
+  memcpy (x, src, sizeof(x));
+  for (i = 0; i &lt; rounds;i += 2)
+    {
+      DEBUG (i);
+      QROUND(x[0], x[4], x[8],  x[12]);
+      QROUND(x[1], x[5], x[9],  x[13]);
+      QROUND(x[2], x[6], x[10], x[14]);
+      QROUND(x[3], x[7], x[11], x[15]);
+
+      DEBUG (i+1);
+      QROUND(x[0], x[5], x[10], x[15]);
+      QROUND(x[1], x[6], x[11], x[12]);
+      QROUND(x[2], x[7], x[8],  x[13]);
+      QROUND(x[3], x[4], x[9],  x[14]);
+    }
+  DEBUG (i);
+
+  for (i = 0; i &lt; _CHACHA_STATE_LENGTH; i++)
+    {
+      uint32_t t = x[i] + src[i];
+      dst[i] = LE_SWAP32 (t);
+    }
+}
+
+
+
+
+
+
+
diff --git a/chacha-crypt.c b/chacha-crypt.c
new file mode 100644
index 0000000..c2e94e8
--- /dev/null
+++ b/chacha-crypt.c
@@ -0,0 +1,89 @@
+/* salsa20-crypt.c
+ *
+ * The crypt function in the ChaCha stream cipher.
+ * Heavily based on the Salsa20 implementation in Nettle.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Joachim Strömbergson
+ * Copyright (C) 2012 Simon Josefsson
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+/* Based on:
+   chacha-ref.c version 2008.01.20.
+   D. J. Bernstein
+   Public domain.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;string.h&gt;
+
+#include "chacha.h"
+
+#include "macros.h"
+#include "memxor.h"
+
+void
+chachar12_crypt(struct chacha_ctx *ctx, size_t length,
+                uint8_t *dst, const uint8_t *src)
+{
+  chacha_crypt(ctx, length, 12, dst, src);
+}
+
+
+void
+chachar20_crypt(struct chacha_ctx *ctx, size_t length,
+                uint8_t *dst, const uint8_t *src)
+{
+  chacha_crypt(ctx, length, 20, dst, src);
+}
+
+
+void
+chacha_crypt(struct chacha_ctx *ctx, size_t length, uint8_t rounds,
+             uint8_t *c, const uint8_t *m)
+{
+  if (!length)
+    return;
+
+  for (;;)
+    {
+      uint32_t x[_CHACHA_STATE_LENGTH];
+
+      _chacha_core (x, ctx-&gt;state, rounds);
+
+      ctx-&gt;state[9] += (++ctx-&gt;state[8] == 0);
+
+      /* stopping at 2^70 length per nonce is user's responsibility */
+
+      if (length &lt;= CHACHA_BLOCK_SIZE)
+	{
+	  memxor3 (c, m, x, length);
+	  return;
+	}
+      memxor3 (c, m, x, CHACHA_BLOCK_SIZE);
+
+      length -= CHACHA_BLOCK_SIZE;
+      c += CHACHA_BLOCK_SIZE;
+      m += CHACHA_BLOCK_SIZE;
+  }
+}
diff --git a/chacha-init.c b/chacha-init.c
new file mode 100644
index 0000000..a413c1f
--- /dev/null
+++ b/chacha-init.c
@@ -0,0 +1,92 @@
+/* chacha-init.c
+ *
+ * Initialization functions for the ChaCha stream cipher.
+ * Based on the Salsa20 implementation in Nettle.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Joachim Strömbergon
+ * Copyright (C) 2012 Simon Josefsson, Niels Möller
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+/* Based on:
+   ChaCha specification (doc id: 4027b5256e17b9796842e6d0f68b0b5e) and reference
+   implementation dated 2008.01.20
+   D. J. Bernstein
+   Public domain.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "chacha.h"
+
+#include "macros.h"
+
+void
+chacha_set_key(struct chacha_ctx *ctx,
+		size_t length, const uint8_t *key)
+{
+  static const uint32_t sigma[4] = {
+    /* "expand 32-byte k" */
+    0x61707865, 0x3320646e, 0x79622d32, 0x6b206574
+  };
+  static const uint32_t tau[4] = {
+    /* "expand 16-byte k" */
+    0x61707865, 0x3120646e, 0x79622d36, 0x6b206574
+  };
+  const uint32_t *constants;
+
+  assert (length == CHACHA_MIN_KEY_SIZE || length == CHACHA_MAX_KEY_SIZE);
+
+  ctx-&gt;state[4] = LE_READ_UINT32(key + 0);
+  ctx-&gt;state[5] = LE_READ_UINT32(key + 4);
+  ctx-&gt;state[6] = LE_READ_UINT32(key + 8);
+  ctx-&gt;state[7] = LE_READ_UINT32(key + 12);
+  if (length == CHACHA_MAX_KEY_SIZE) { /* recommended */
+    ctx-&gt;state[8]  = LE_READ_UINT32(key + 16);
+    ctx-&gt;state[9]  = LE_READ_UINT32(key + 20);
+    ctx-&gt;state[10] = LE_READ_UINT32(key + 24);
+    ctx-&gt;state[11] = LE_READ_UINT32(key + 28);
+    constants = sigma;
+  } else { /* kbits == 128 */
+    ctx-&gt;state[8]  = ctx-&gt;state[4];
+    ctx-&gt;state[9]  = ctx-&gt;state[5];
+    ctx-&gt;state[10] = ctx-&gt;state[6];
+    ctx-&gt;state[11] = ctx-&gt;state[7];
+    constants = tau;
+  }
+  ctx-&gt;state[0] = constants[0];
+  ctx-&gt;state[1] = constants[1];
+  ctx-&gt;state[2] = constants[2];
+  ctx-&gt;state[3] = constants[3];
+}
+
+void
+chacha_set_iv(struct chacha_ctx *ctx, const uint8_t *iv)
+{
+  ctx-&gt;state[12] = 0;
+  ctx-&gt;state[13] = 0;
+  ctx-&gt;state[14] = LE_READ_UINT32(iv + 0);
+  ctx-&gt;state[15] = LE_READ_UINT32(iv + 4);
+}
+
diff --git a/chacha.h b/chacha.h
new file mode 100644
index 0000000..269f838
--- /dev/null
+++ b/chacha.h
@@ -0,0 +1,99 @@
+/* chacha.h
+ *
+ * The ChaCha stream cipher.
+ * Heavily based on the Salsa20 source code in Nettle.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Joachim Strömbergson
+ * Copyright (C) 2012 Simon Josefsson
+ * Copyright (C) 2001 Niels Möller
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#ifndef NETTLE_CHACHA_H_INCLUDED
+#define NETTLE_CHACHA_H_INCLUDED
+
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define chacha_set_key nettle_chacha_set_key
+#define chacha_set_iv nettle_chacha_set_iv
+#define chacha_crypt nettle_chacha_crypt
+#define _chacha_core _nettle_chacha_core
+
+/* Minimum and maximum keysizes, and a reasonable default.
+   In octets. */
+#define CHACHA_MIN_KEY_SIZE 16
+#define CHACHA_MAX_KEY_SIZE 32
+#define CHACHA_KEY_SIZE 32
+#define CHACHA_BLOCK_SIZE 64
+
+#define CHACHA_IV_SIZE 8
+
+#define CHACHA_NUM_ROUNDS 8
+
+#define _CHACHA_STATE_LENGTH 16
+
+struct chacha_ctx
+{
+  /* Indices 0-3 holds a constant (SIGMA or TAU).
+     Indices 4-11 holds the key.
+     Indices 12-13 holds the block counter.
+     Indices 14-15 holds the IV:
+
+     This creates the state matrix:
+     C C C C
+     K K K K
+     K K K K
+     B B I I
+  */
+  uint32_t state[_CHACHA_STATE_LENGTH];
+};
+
+void
+chacha_set_key(struct chacha_ctx *ctx,
+		size_t length, const uint8_t *key);
+
+void
+chacha_set_iv(struct chacha_ctx *ctx, const uint8_t *iv);
+
+void
+chacha_crypt(struct chacha_ctx *ctx, size_t length,
+             uint8_t rounds, uint8_t *dst, const uint8_t *src);
+
+void
+chachar12_crypt(struct chacha_ctx *ctx, size_t length,
+                uint8_t *dst, const uint8_t *src);
+
+void
+chachar20_crypt(struct chacha_ctx *ctx, size_t length,
+                uint8_t *dst, const uint8_t *src);
+
+void
+_chacha_core(uint32_t *dst, const uint32_t *src, uint8_t rounds);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_CHACHA_H_INCLUDED */
--
1.8.3.4 (Apple Git-47)



</body></email><email><emailId>20131217092742</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-12-17 09:27:42-0400</timestampReceived><subject>Re: TMP_ALLOC and size_t change</subject><body>

On Tue, Dec 17, 2013 at 8:57 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt; I don't currently plan any 2.7.2 bugfix release. I'm thinking that this
&gt; problem is not serious enough to motivate a new release. If some more
&gt; urgent reason to make a release comes up, we can consider backporting
&gt; this change.
&gt; Or have you seen any real problems caused by this? That would be an
&gt; application accepting an arbitrarily large RSA keys from an untrusted
&gt; source, and passing it on to nettle without any limit to prevent DoS. In
&gt; that scenario, it could be a real problem.

The limit in gnutls for public keys was 16k. The undocumented abort()
limit in these functions is 10k. Thus even if an application doesn't
allow arbitrary limits it risks a crash. Even worse this crash can be
simply from data coming from the network. So I find that a pretty
serious issue (although, I think that issue is mitigated on systems
that alloca() is available).

A release on the 2.7 could also include to lift the q_bit limits in
generating a dsa key (so that nettle could be used for generating DH
keys as well).

regards,
Nikos

</body></email><email><emailId>20131217215905</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-17 21:59:05-0400</timestampReceived><subject>Re: Mentioning of  .bootstrap in INSTALL?</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Niels Möller wrote:
&gt; Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:
&gt; 
&gt;&gt; At least not having one indirection in documentation. I think the 
&gt;&gt; bootstrap should be mentioned directly in a README, INSTALL etc
&gt;&gt; file directly in the reop.
&gt; 
&gt; I did some small changes to the README, to try to make it clearer.

Much better, thanks!

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKwySkACgkQZoPr8HT30QGNawCfZ+JTG37yNIRr2KMPWtnojAVD
CQEAnjkUw/RcmVstpQPM6B2E0bVi/FU+
=ZifI
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131218085716</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-12-18 08:57:16-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>


On Tue, 17 Dec 2013, Niels Möller wrote:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt; Below is an untested patch for the configure machinery. Can you try this?
&gt;
&gt; I haven't seen any feedback on this, but I have now checked it in
&gt; nonetheless.
&gt;
&gt; It would be nice if you could confirm that it actually works. If you or
&gt; Martin also have a real gcc and GNU binutils installed on macosx, it
&gt; would be nice if you could test that it works also when building with
&gt; the GNU tools.

Yes, now it works fine here as well - sorry for not reacting on testing 
the patch earlier.

I don't have a real gcc and GNU binutils available unfortunately so I 
can't test if detecting that works as it should.

// Martin

</body></email><email><emailId>20131218111926</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-12-18 11:19:26-0400</timestampReceived><subject>Re: arm-neon/v6 auto-detection</subject><body>

On Wed, Dec 18, 2013 at 11:55 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:

&gt;&gt; I tried to use the android NDK on nettle and the cpu detected was simply
&gt;&gt; 'arm'.
&gt; You could configure with something like
&gt;   --host=armv6-linux-androideabi CC="arm-linux-androideabi -march=armv6t2"
&gt; No idea how much problems, if any, that will cause for real android devices.

Most probably none, but developers on these devices compile with the flags
provided by the BSP provider (in that case the NDK). Given what Martin says
if we follow the split approach, on android ARMv6 systems we get the
nettle's armv5
code, and only on ARMv7 ones we get the optimized code. Maybe splitting the
arm code isn't that good idea.

regards,
Nikos

</body></email><email><emailId>20131219110115</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-12-19 11:01:15-0400</timestampReceived><subject>Re: acoustic cryptanalysis</subject><body>

On Thu, Dec 19, 2013 at 11:46 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:

&gt;&gt;  It seems that some guys managed to "listen" gnupg private keys. While
&gt;&gt; some parts of the attack are gnupg specific, similar attacks could
&gt;&gt; apply in nettle as well (and I guess every implementation that does
&gt;&gt; RSA decryption).
&gt; I have only had a very quick look at the paper.
&gt;&gt; I see on their mitigation section that "ciphertext normalization",
&gt;&gt; i.e., c=c%n, avoids their key recovery attack,
&gt; Wouldn't it make more sense to simply reject ciphertexts with c &gt;= n?
&gt; And since this condition depends on no secret information, there's no
&gt; harm in returning failure early in this case, right?

Yes. That would also avoid the complex patch (which should be now attached).

&gt; Or do they mean c &gt;= q, where q is the secret factor? I think the right
&gt; way for the CRT processing is to always zero pad c to the same size of
&gt; n, and then reduce it mod p and mod q using a side-channel silent
&gt; reduction algorithm. Not entirely trivial to do with the mpz interface,
&gt; though.

My understanding was that c&gt;=n.

&gt; On mitigation, it also sounds like RSA blinding (which you implemented a
&gt; while ago) is effective. It ought to be effective against any attacks
&gt; relying on *chosen* ciphertexts.

Indeed. I realized after that gnupg's code didn't use the blinding
part (that attack
worked on the old gnupg versions, something that isn't very apparent
in the paper :)

However, checking for ciphertext validity prior to getting to the actual
operation is a good thing to have. Not as serious as I initially thought though.

regards,
Nikos

["patch.txt" (text/plain)]

diff --git a/rsa-decrypt-tr.c b/rsa-decrypt-tr.c
index 4705137..33ea3d5 100644
--- a/rsa-decrypt-tr.c
+++ b/rsa-decrypt-tr.c
@@ -47,7 +47,7 @@ rsa_decrypt_tr(const struct rsa_public_key *pub,
   mpz_init (ri);
 
   _rsa_blind (pub, random_ctx, random, m, ri);
-  rsa_compute_root(key, m, m);
+  rsa_compute_root_ar(pub, key, m, m);
   _rsa_unblind (pub, m, ri);
   mpz_clear (ri);
 
diff --git a/rsa-pkcs1-sign-tr.c b/rsa-pkcs1-sign-tr.c
index 16de2f9..31417c5 100644
--- a/rsa-pkcs1-sign-tr.c
+++ b/rsa-pkcs1-sign-tr.c
@@ -45,7 +45,7 @@ rsa_pkcs1_sign_tr(const struct rsa_public_key *pub,
       mpz_init (ri);
 
       _rsa_blind (pub, random_ctx, random, s, ri);
-      rsa_compute_root(key, s, s);
+      rsa_compute_root_ar(pub, key, s, s);
       _rsa_unblind (pub, s, ri);
 
       mpz_clear (ri);
diff --git a/rsa-sign.c b/rsa-sign.c
index 56adda3..cc80faa 100644
--- a/rsa-sign.c
+++ b/rsa-sign.c
@@ -78,13 +78,20 @@ rsa_private_key_prepare(struct rsa_private_key *key)
 
 /* Computing an rsa root. */
 void
-rsa_compute_root(const struct rsa_private_key *key,
-		 mpz_t x, const mpz_t m)
+rsa_compute_root_ar(const struct rsa_public_key *pub,
+		    const struct rsa_private_key *key,
+		    mpz_t x, const mpz_t _m)
 {
   mpz_t xp; /* modulo p */
   mpz_t xq; /* modulo q */
+  mpz_t m; /* m=_m mod n */
+
+  mpz_init(xp); mpz_init(xq); mpz_init(m);
 
-  mpz_init(xp); mpz_init(xq);    
+  if (pub != NULL)
+    mpz_fdiv_r(m, _m, pub-&gt;n);
+  else
+    mpz_set(m, _m);
 
   /* Compute xq = m^d % q = (m%q)^b % q */
   mpz_fdiv_r(xq, m, key-&gt;q);
@@ -132,5 +139,12 @@ rsa_compute_root(const struct rsa_private_key *key,
   mpz_mul(x, key-&gt;q, xp);
   mpz_add(x, x, xq);
 
-  mpz_clear(xp); mpz_clear(xq);
+  mpz_clear(xp); mpz_clear(xq); mpz_clear(m);
+}
+
+void
+rsa_compute_root(const struct rsa_private_key *key,
+		 mpz_t x, const mpz_t m)
+{
+	return rsa_compute_root_ar(NULL, key, x, m);
 }
diff --git a/rsa.h b/rsa.h
index 38455a7..34c0992 100644
--- a/rsa.h
+++ b/rsa.h
@@ -67,6 +67,7 @@ extern "C" {
 #define rsa_decrypt nettle_rsa_decrypt
 #define rsa_decrypt_tr nettle_rsa_decrypt_tr
 #define rsa_compute_root nettle_rsa_compute_root
+#define rsa_compute_root_ar nettle_rsa_compute_root_ar
 #define rsa_generate_keypair nettle_rsa_generate_keypair
 #define rsa_keypair_to_sexp nettle_rsa_keypair_to_sexp
 #define rsa_keypair_from_sexp_alist nettle_rsa_keypair_from_sexp_alist
@@ -307,6 +308,12 @@ void
 rsa_compute_root(const struct rsa_private_key *key,
 		 mpz_t x, const mpz_t m);
 
+/* The acoustic resistant version: http://www.cs.tau.ac.il/~tromer/acoustic/ */
+void
+rsa_compute_root_ar(const struct rsa_public_key *pub,
+		    const struct rsa_private_key *key,
+		    mpz_t x, const mpz_t m);
+
 
 /* Key generation */
 


</body></email><email><emailId>20131209175746</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-12-09 17:57:46-0400</timestampReceived><subject>Re: benchmarks</subject><body>

On Mon, 2013-12-09 at 18:04 +0100, Werner Koch wrote:
&gt; Hi,
&gt; 
&gt; I did some benchmark charts for Libgcrypt.  See
&gt;   ftp://ftp.g10code.com/g10code/scratch/gcrypt-bench-x220-2300.gnumeric
&gt; or just the charts:
&gt;   ftp://ftp.g10code.com/g10code/scratch/gcrypt-bench-x220-2300.pdf
&gt; this nicely shows Jussi's improvements.  The values for Nettle have been
&gt; taken from the nettle-benchmark example program.  I did not add data for
&gt; OpenSSL because it is a bit of work to extract the numbers from "openssl
&gt; speed".  It would be nice to have wrapper for openssl so that
&gt; bench-slope can be used to create compatible numbers.  

Could libgcrypt and nettle share the low level algorithms so
improvements on one project will be shared with the other? As it is now
I think there is quite some duplicate effort being spent in making the
two libraries faster and there is no much reason they couldn't be
combined.

In the end I feel disappointed to see that because of that, even the
gnulib people will use openssl's libcrypto because it is faster:
http://lists.gnu.org/archive/html/bug-gnulib/2013-12/msg00058.html

regards,
Nikos



</body></email><email><emailId>20131211110515</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-11 11:05:15-0400</timestampReceived><subject>Adding number of rounds to context for Salsa20?</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

I'm looking at the source for Salsa20 and notice that there are separate
versions for Salsa20 with 20 rounds and Salsa20 with 12 rounds (with
specific r12 function names).

Would it be possible to instead add the given number of rounds to the
context? This would allow the user to select at key-init time to select
the number of rounds being used and also declutter the interface with
round specific functions.

The default could still be 20, but allows for such things as using 8
rounds, 12, 14 or even 24 rounds etc.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKoRusACgkQZoPr8HT30QEiXgCgwTUIbpFeXgh2gNk+WCSrlSw1
E/sAoNWKDrSdVhTh4bw9s8YgOau+NpLf
=znL7
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131209204853</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-09 20:48:53-0400</timestampReceived><subject>Re: benchmarks</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Could libgcrypt and nettle share the low level algorithms so
&gt; improvements on one project will be shared with the other?

To me, it would make sense to have gcrypt add its interfaces on top of
Nettle. I hope there should be minimal overhead (in code complexity as
well as running time overhead). It was my intention from the start that
it should be easy to build other frameworks on top of Nettle.

I'm not sure what obstacles, technical or others, there are. At least
Nettle is now LGPL licenced (v2 or later). Any pieces missing which are
essential for gcrypt? (E.g., currently Nettle has no runtime selection
of cpu-specific code).

&gt; In the end I feel disappointed to see that because of that, even the
&gt; gnulib people will use openssl's libcrypto because it is faster:
&gt; http://lists.gnu.org/archive/html/bug-gnulib/2013-12/msg00058.html

I totally agree.

(And OpenSSL is not always faster than Nettle. On my home machine, a
low end x86_64 AMD E-350, Nettle's AES is some 130% faster than
openssl (which surprises me), sha1 is 20% faster than openssl, ecdsa is
300% faster for signing and 75% faster for verification. But on
many machines, Nettle is a bit slower than openssl for sha1 and md5,
which might be the most important things for gnulib).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131211200707</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-11 20:07:07-0400</timestampReceived><subject>ChaCha stream cipher for Nettle available</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

I've taken a shot at implementing the ChaCha stream cipher for Nettle.
Nettle is a modified version of Salsa20 done by DJB in order to improve
both performance (esp on CPUs with support for data parallelism) and
somewhat improved performance. ChaCha has been suggested as replacement
for RC4 both by Adam Langley from Google and separately by Nikos and Me.

http://cr.yp.to/chacha.html


The code in this implementation is heavily based on the Salsa20
implementation in Nettle. The major changes beside name changes are the
quarterround schedules, the different state init and the quarterround.
This implementation also supports different number of rounds.

There is a pretty simple test program that verifies the functionality
for 128 and 256 keys as well as 8, 12 and 20 rounds using the testt
vectors in the chacha test vectors draft:

http://tools.ietf.org/html/draft-strombergson-chacha-test-vectors-00


The code for the chacha implementation is available at:

https://github.com/secworks/nettle

The following files comprises the implementation:
chacha-core-internal.c
chacha-crypt.c
chacha-init.c
chacha.h

And the test program
testsuite/chacha-test.c

(The other files are clones from Nettle to be able to build.)

ChaCha _should_ be a bit faster than Salsa20 and should esp be easier to
optimize in asm for modern CPUs. I have however not done any benchmarks
nor asm implementation (yet).

Since I'm new as a contributor I don't know how you Niels want to have
patches. Please let me know if this looks good and something you want to
integrate and if so how.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKoxesACgkQZoPr8HT30QE6vACfTIV44gkDKJcsoxR9BjnElBfE
zGQAnjbRimEsTp8arbDPtsT/RLrkgw5K
=cz3W
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131211110117</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-12-11 11:01:17-0400</timestampReceived><subject>TMP_ALLOC and size_t change</subject><body>

Hello,
 In master (unsigned int) was replaced with (size_t), that allows for
even larger sizes to be input to encryption and decryption functions.
However, the usage of TMP_ALLOC to make a copy of the input data
(e.g., in ctr.c) contradicts that goal.

In general I think the usage of alloca() is dangerous as it not always
known whether the stack is limited, e.g, when nettle is called in a
co-routine or in application with non-growing stack. I think there can
be an easy modification of TMP_ALLOC to use malloc for larger than 128
(or any other fixed number), and alloca otherwise. Would you be
interested in such a patch? (it would require the introduction of a
TMP_FREE as well)

regards,
Nikos

</body></email><email><emailId>20131213095152</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-13 09:51:52-0400</timestampReceived><subject>Mentioning of  .bootstrap in INSTALL?</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Cloned nettle and noticed that INSTALL states:

"Briefly, the shell commands `./configure; make; make install' should
configure, build, and install this package."

But at least in the repo there is only a config.ac and you need to run
the .bootstrap shell script in order to invoke autoconf and autoheaders
in order to get the configure script.

Shouldn't INSTALL mention this?

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKq2LgACgkQZoPr8HT30QEIbACfWjUuo8IAbigziPGwnw4Pbmx5
P8cAni2UtPVOqH52XlBlZmmsGnRfNz7L
=ioBH
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131213102943</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-13 10:29:43-0400</timestampReceived><subject>Building nettle in OSX</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

(Sorry for this stupid question.)

I'm trying to get nettle to build in OSX but are having some problems.
If i simply do the bootstrap-configure-make I get problems in the
assembly phase:

&lt;quote&gt;
/Applications/Xcode.app/Contents/Developer/usr/bin/make all-here
gcc -I.  -DHAVE_CONFIG_H -g -O2 -ggdb3 -Wall -W   -Wmissing-prototypes
- -Wmissing-declarations -Wstrict-prototypes   -Wpointer-arith
- -Wbad-function-cast -Wnested-externs -fPIC -MT gcm-hash8.o -MD -MP -MF
gcm-hash8.o.d -fPIC -c gcm-hash8.s
gcm-hash8.s:220:18: error: unexpected token in '.section' directive
 .section .rodata
                 ^

gcm-hash8.s:224:1: error: unknown directive
.hword 0x0000,0xc201,0x8403,0x4602,0x0807,0xca06,0x8c04,0x4e05
^

gcm-hash8.s:225:1: error: unknown directive
.hword 0x100e,0xd20f,0x940d,0x560c,0x1809,0xda08,0x9c0a,0x5e0b
^
....
&lt;/quote&gt;

Googling I found some other people having problems:
https://gist.github.com/morgant/1753095

Turning of assembly (--disable-assembler to configure) I get through the
compilation, assembly, but linking fails (similarly the link above):

&lt;quote&gt;
Undefined symbols for architecture x86_64:
  "__nettle_aes_decrypt", referenced from:
      _nettle_aes_decrypt in aes-decrypt.po
      _nettle_aes128_decrypt in aes-decrypt.po
      _nettle_aes192_decrypt in aes-decrypt.po
      _nettle_aes256_decrypt in aes-decrypt.po
  "__nettle_aes_encrypt", referenced from:
      _nettle_aes_encrypt in aes-encrypt.po
      _nettle_aes128_encrypt in aes-encrypt.po
      _nettle_aes192_encrypt in aes-encrypt.po
      _nettle_aes256_encrypt in aes-encrypt.po
     (maybe you meant: __nettle_aes_encrypt_table)
...
&lt;/quote&gt;

This is on OSX 10.9 with gcc being a wrapper around clang:

Apple LLVM version 5.0 (clang-500.2.79) (based on LLVM 3.3svn)
Target: x86_64-apple-darwin13.0.0
Thread model: posix

and as being:
Apple Inc version cctools-846.2.4, GNU assembler version 1.38

and ld being:
@(#)PROGRAM:ld  PROJECT:ld64-224.1
configured to support archs: armv6 armv7 armv7s arm64 i386 x86_64 armv6m
armv7m armv7em
LTO support using: LLVM version 3.3svn, from Apple Clang 5.0 (build
500.2.79)

Anybody succeeding and building nettle on OSX and if so how. Being able
to use the optimized assembler versions would also be good.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKq4ZcACgkQZoPr8HT30QEy2QCffi/BpWVuYyNKV5oqFLvDlLg0
CeAAoK0VLGcek5vHcUXkMG9QPHgypl2z
=a0RI
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131217133200</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-12-17 13:32:00-0400</timestampReceived><subject>arm-neon/v6 auto-detection</subject><body>

Hello,
 As it is now the ARM-neon and v6 optimizations are enabled when
nettle is compiled on the exact system it is supposed to run. This is
very unlikely to happen in some scenarios, as applications intended to
run on an arm mobile (eg [0]) cannot know in advance the target. That
is a petty because nettle is pretty unique in having support for
assembly in ARMv6 or neon.

A solution to that issue would be to have a nettle library constructor
that runs the equivalent of cpuid in ARM, and stores it to a global
variable. Then each assembly module (e.g., aes-arm) will jump to the
correct implementation detected at runtime.

This requires no global initialization functions or anything like
that. In the systems where library constructors are not available
(i.e., static linking), the cost would be running the oldest arm
assembly version (unless the constructor is called explicitly).

This is similar to what openssl is doing already (with the exception
that they use a global initialization function instead of a
constructor). To me that seems quite a simple way to improve the
current situation.

regards,
Nikos

[0]. https://github.com/cernekee/ics-openconnect

</body></email><email><emailId>20131219100708</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-12-19 10:07:08-0400</timestampReceived><subject>acoustic cryptanalysis</subject><body>

Hello,
 It seems that some guys managed to "listen" gnupg private keys. While
some parts of the attack are gnupg specific, similar attacks could
apply in nettle as well (and I guess every implementation that does
RSA decryption). This could affect TLS sessions where the server is
decrypting client provided ciphertext. I see on their mitigation
section that "ciphertext normalization", i.e., c=c%n, avoids their key
recovery attack, so given that there is no harm to have this step
anyway, it would be nice to have it in nettle as well (patch
attached).

http://www.cs.tau.ac.il/~tromer/acoustic/

regards,
Nikos

</body></email><email><emailId>20131227133854</emailId><senderName>rajesh</senderName><senderEmail>rajesh@linux.vnet.ibm.com</senderEmail><timestampReceived>2013-12-27 13:38:54-0400</timestampReceived><subject>Request to release new version of nettle to support new architecture ppc64le</subject><body>

Hi

We are adding support for new ppc64le (IBM powerPC Little Endian) 
architecture. I was looking at the package nettle from the latest 
release tarball ( 
http://www.lysator.liu.se/~nisse/archive/nettle-2.7.1.tar.gz ) and also 
from the git source (git://git.lysator.liu.se/nettle/nettle.git) and it 
failed to build the package on ppc64le machine because of outdated 
config.guess. since currently available config.guess does not have 
support for ppc64le it  fails to guess correct build type.

Latest config.guess with ppc64le support is available at :
http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD

I verified building the package with latest config.guess mentioned above 
and it built fine in ppc64le platform.
I would also like to inform that all make check test cases successfully 
passed in the new platform ppc64le.

Would it be possible to spin up a newer version of nettle  for the 
distros to pick up from the upstream release tarball, which would 
support ppc64le.
Please do let me know if you will be picking up the patches from 
upstream or you would require local patches to be provided. I can send 
out the patches to you.

I can help to validate the new release of the package works well by 
compiling on ppc64le machine.

Appreciate your response

Thanks and Regards
Rajeshkumar S
Linux Technology Centre, IBM


</body></email><email><emailId>20131219104650</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-19 10:46:50-0400</timestampReceived><subject>Re: acoustic cryptanalysis</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt;  It seems that some guys managed to "listen" gnupg private keys. While
&gt; some parts of the attack are gnupg specific, similar attacks could
&gt; apply in nettle as well (and I guess every implementation that does
&gt; RSA decryption).

I have only had a very quick look at the paper.

&gt; I see on their mitigation section that "ciphertext normalization",
&gt; i.e., c=c%n, avoids their key recovery attack,

Wouldn't it make more sense to simply reject ciphertexts with c &gt;= n?
And since this condition depends on no secret information, there's no
harm in returning failure early in this case, right?

Or do they mean c &gt;= q, where q is the secret factor? I think the right
way for the CRT processing is to always zero pad c to the same size of
n, and then reduce it mod p and mod q using a side-channel silent
reduction algorithm. Not entirely trivial to do with the mpz interface,
though.

On mitigation, it also sounds like RSA blinding (which you implemented a
while ago) is effective. It ought to be effective against any attacks
relying on *chosen* ciphertexts.

(And I think you forgot to attach the patch).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131217151219</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-17 15:12:19-0400</timestampReceived><subject>Re: arm-neon/v6 auto-detection</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; A solution to that issue would be to have a nettle library constructor
&gt; that runs the equivalent of cpuid in ARM, and stores it to a global
&gt; variable. Then each assembly module (e.g., aes-arm) will jump to the
&gt; correct implementation detected at runtime.

The difficult part is the configure work. We'd either have to build
multiple object files for each function, with different link names, and
then have some glue to select the right one at runtime.

Or use a "master file" for each function, say arm/fat/foo.asm, which
includes the other files and makes the right thing happen.

Things get a bit more complex if we need to use the C version on some
machines, since the current build setup assumes that an assembly file
completely replaces the corresponding C file.

There's also IFUNC relocations, but I'm not sure which systems beyond
vanilla gnu/linux support them. Are they usable on android, e.g.?

I clearly see the need for a runtime test for neon. Say,
--enable-arm-neon=fat or a more general --enable-fat.

But you also mention v6 optimizations, for clarity, do you mean that
you'd like to see runtime tests for that as too? To me, it seems a bit
unlikely to need a fat binary which supports both pre-v6 arm, and v6 and
later. I'd expect pre-v6 arm to be used only in embedded systems where
the cpu flavor is known at build time.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131217162959</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-12-17 16:29:59-0400</timestampReceived><subject>Re: arm-neon/v6 auto-detection</subject><body>

On Tue, Dec 17, 2013 at 4:12 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:

&gt;&gt; A solution to that issue would be to have a nettle library constructor
&gt;&gt; that runs the equivalent of cpuid in ARM, and stores it to a global
&gt;&gt; variable. Then each assembly module (e.g., aes-arm) will jump to the
&gt;&gt; correct implementation detected at runtime.
&gt; The difficult part is the configure work. We'd either have to build
&gt; multiple object files for each function, with different link names, and
&gt; then have some glue to select the right one at runtime.

Why not a big assembly function that contains everything? In the
start it simply checks which CPU optimization is available and
jumps to the appropriate label (i'm thinking x86 asm here but I hope what
I say applies to arm as well).

&gt; Or use a "master file" for each function, say arm/fat/foo.asm, which
&gt; includes the other files and makes the right thing happen.

That could work too.

&gt; Things get a bit more complex if we need to use the C version on some
&gt; machines, since the current build setup assumes that an assembly file
&gt; completely replaces the corresponding C file.

If everything were in a single file it would work like charm, but even splitting
them to multiple files would work if subdirectories are used, and only the
main file is considered the "real" asm. (I suppose you are referring to
--disable-assember?)

&gt; I clearly see the need for a runtime test for neon. Say,
&gt; --enable-arm-neon=fat or a more general --enable-fat.

I like the name :) I think the latter makes more sense if it is to be used
for x86 as well.

&gt; But you also mention v6 optimizations, for clarity, do you mean that
&gt; you'd like to see runtime tests for that as too? To me, it seems a bit
&gt; unlikely to need a fat binary which supports both pre-v6 arm, and v6 and
&gt; later. I'd expect pre-v6 arm to be used only in embedded systems where
&gt; the cpu flavor is known at build time.

You may be right; it may make sense to treat them separately.

regards,
Nikos

</body></email><email><emailId>20131217164513</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-12-17 16:45:13-0400</timestampReceived><subject>Re: arm-neon/v6 auto-detection</subject><body>


On Tue, 17 Dec 2013, Niels Möller wrote:

&gt; There's also IFUNC relocations, but I'm not sure which systems beyond
&gt; vanilla gnu/linux support them. Are they usable on android, e.g.?

Not sure - and even if they are they might not have been supported from 
the beginning, so it might only be usable from some particular android 
version.

Can you provide some small example that I could try on a range of 
versions?

&gt; I'd expect pre-v6 arm to be used only in embedded systems where the cpu 
&gt; flavor is known at build time.

ARMv5 is the baseline for the Android ARM ABI, which might be the main 
reason why anybody would care. In practice I'm not sure if any such 
devices actually have shipped - at least the first devices actually were 
ARMv6.

// Martin

</body></email><email><emailId>20131217203344</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-17 20:33:44-0400</timestampReceived><subject>Re: arm-neon/v6 auto-detection</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Why not a big assembly function that contains everything?

Two reasons: 1. To make the fat binary thing optional, just using a
simple cpu-specific file when the cpu is known at compile time. 2. In
case we'd like to fallback to the C implementation for some function.

&gt;&gt; Or use a "master file" for each function, say arm/fat/foo.asm, which
&gt;&gt; includes the other files and makes the right thing happen.
&gt;
&gt; That could work too.

I'm leaning towards this, at least for a start. We'll see when I get
time to play with this.

&gt;&gt; I clearly see the need for a runtime test for neon. Say,
&gt;&gt; --enable-arm-neon=fat or a more general --enable-fat.
&gt;
&gt; I like the name :) I think the latter makes more sense if it is to be used
&gt; for x86 as well.

--enable-fat is what gmp uses. And "fat binaries/libraries" is almost
standard terminology.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131217204236</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-17 20:42:36-0400</timestampReceived><subject>Re: arm-neon/v6 auto-detection</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; On Tue, 17 Dec 2013, Niels Möller wrote:
&gt;
&gt;&gt; There's also IFUNC relocations, but I'm not sure which systems beyond
&gt;&gt; vanilla gnu/linux support them. Are they usable on android, e.g.?
&gt;
&gt; Not sure - and even if they are they might not have been supported
&gt; from the beginning, so it might only be usable from some particular
&gt; android version.
&gt;
&gt; Can you provide some small example that I could try on a range of
&gt; versions?

No, sorry. I'm not very familier with IFUNC and have never used it
myself. I just know it's a feature in glibc and ld.so. The basic idea,
as far as I understand, is that you register a custom resolve function
to a symbol. When ld.so tries to resolve that symbol, the registered
function is called, and it returns the address of the real function,
which ld.so then installs it the proper place (in the PLT array, I
guess).

Using it avoids one level of indirection, compared to using a wrapper
function in Nettle which jumps through a function pointer.

I also don't know if it works at all with static libraries.

&gt;&gt; I'd expect pre-v6 arm to be used only in embedded systems where the
&gt;&gt; cpu flavor is known at build time.
&gt;
&gt; ARMv5 is the baseline for the Android ARM ABI, which might be the main
&gt; reason why anybody would care. In practice I'm not sure if any such
&gt; devices actually have shipped - at least the first devices actually
&gt; were ARMv6.

If in practice, ARMv5 isn't used, I think we can ignore this for now
(and simply disable fat when nettle is configured for pre-v6 ARM).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131218073701</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-18 07:37:01-0400</timestampReceived><subject>Re: arm-neon/v6 auto-detection</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Two reasons: 1. To make the fat binary thing optional, just using a
&gt; simple cpu-specific file when the cpu is known at compile time. 2. In
&gt; case we'd like to fallback to the C implementation for some function.

I checked what functions are involved. The ARM neon assembly is for
salsa20, sha3, sha512, and umac. There's no non-neon assembly code, so
the fat mechanism needs to choose between the C implementation and the
neon implementation.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131218081845</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-12-18 08:18:45-0400</timestampReceived><subject>Re: arm-neon/v6 auto-detection</subject><body>

On Tue, 2013-12-17 at 21:42 +0100, Niels Möller wrote:

&gt; &gt; ARMv5 is the baseline for the Android ARM ABI, which might be the main
&gt; &gt; reason why anybody would care. In practice I'm not sure if any such
&gt; &gt; devices actually have shipped - at least the first devices actually
&gt; &gt; were ARMv6.
&gt; If in practice, ARMv5 isn't used, I think we can ignore this for now
&gt; (and simply disable fat when nettle is configured for pre-v6 ARM).

I tried to use the android NDK on nettle and the cpu detected was simply
'arm'. It seems that the android NDK compiler compiles with
-march=arv5te, so I don't think that separating armv5 and armv6 would
work (for android at least).

regards,
Nikos




</body></email><email><emailId>20131218105503</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-18 10:55:03-0400</timestampReceived><subject>Re: arm-neon/v6 auto-detection</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I tried to use the android NDK on nettle and the cpu detected was simply
&gt; 'arm'.

You could configure with something like

  --host=armv6-linux-androideabi CC="arm-linux-androideabi -march=armv6t2"

No idea how much problems, if any, that will cause for real android devices.

But it seems fairly common that android apps are compiled for newer
processors only (if they include native code at all), e.g., I think the
firefox app I got from f-droid is armv7 only.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131218111414</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-12-18 11:14:14-0400</timestampReceived><subject>Re: arm-neon/v6 auto-detection</subject><body>


On Wed, 18 Dec 2013, Niels Möller wrote:

&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt;
&gt;&gt; I tried to use the android NDK on nettle and the cpu detected was simply
&gt;&gt; 'arm'.
&gt;
&gt; You could configure with something like
&gt;
&gt;  --host=armv6-linux-androideabi CC="arm-linux-androideabi -march=armv6t2"
&gt;
&gt; No idea how much problems, if any, that will cause for real android devices.
&gt;
&gt; But it seems fairly common that android apps are compiled for newer
&gt; processors only (if they include native code at all), e.g., I think the
&gt; firefox app I got from f-droid is armv7 only.

Yes - there's two separate ABIs that they support automatically, ARMv5 and 
ARMv7 (without neon) - you can build two separate versions of your library 
and the device will install the right one (and use the v5 one on v7 if 
there's no v7 specific binary). Since there are ARMv7 devices without 
neon, those features would have to be enabled at runtime though.

// Martin

</body></email><email><emailId>20131213114607</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-13 11:46:07-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; I'm trying to get nettle to build in OSX but are having some problems.
&gt; If i simply do the bootstrap-configure-make I get problems in the
&gt; assembly phase:

I don't use osx myself, and I'm not very familiar with it.

&gt; gcc -I.  -DHAVE_CONFIG_H -g -O2 -ggdb3 -Wall -W   -Wmissing-prototypes
&gt; -Wmissing-declarations -Wstrict-prototypes   -Wpointer-arith
&gt; -Wbad-function-cast -Wnested-externs -fPIC -MT gcm-hash8.o -MD -MP -MF
&gt; gcm-hash8.o.d -fPIC -c gcm-hash8.s
&gt; gcm-hash8.s:220:18: error: unexpected token in '.section' directive
&gt;  .section .rodata

What does the assembler/linker expect? What do you get from a C file
containing

  static const uint16_t t[4] = {1,2,3,4};

?

&gt; and as being:
&gt; Apple Inc version cctools-846.2.4, GNU assembler version 1.38

That sounds like an ancient version of gas. Searching for it turns up
a fred fish CD from 1994. I most likely had it installed back in the
days. See
http://ftp.back2roots.org/back2roots/cds/fred_fish/freshfish_vol05_9407/gnu/src/baseline/

But it must have been patched heavily by Apple if it supports x86_64...

I'd strongly suggest first trying to build with modern gcc and binutils,
before trying to find workarounds for apple's tools.

/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131213120641</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-12-13 12:06:41-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>


On Fri, 13 Dec 2013, Niels Möller wrote:

&gt; Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:
&gt;
&gt;&gt; I'm trying to get nettle to build in OSX but are having some problems.
&gt;&gt; If i simply do the bootstrap-configure-make I get problems in the
&gt;&gt; assembly phase:
&gt;
&gt; I don't use osx myself, and I'm not very familiar with it.

Just for what it's worth - I've been using nettle on OS X and it has 
worked just fine up including the 2.7 release.

&gt;&gt; gcc -I.  -DHAVE_CONFIG_H -g -O2 -ggdb3 -Wall -W   -Wmissing-prototypes
&gt;&gt; -Wmissing-declarations -Wstrict-prototypes   -Wpointer-arith
&gt;&gt; -Wbad-function-cast -Wnested-externs -fPIC -MT gcm-hash8.o -MD -MP -MF
&gt;&gt; gcm-hash8.o.d -fPIC -c gcm-hash8.s
&gt;&gt; gcm-hash8.s:220:18: error: unexpected token in '.section' directive
&gt;&gt;  .section .rodata
&gt;
&gt; What does the assembler/linker expect? What do you get from a C file
&gt; containing
&gt;
&gt;  static const uint16_t t[4] = {1,2,3,4};
&gt;
&gt; ?

This seems to output something like this:
         .section        __TEXT,__const


&gt;&gt; and as being:
&gt;&gt; Apple Inc version cctools-846.2.4, GNU assembler version 1.38
&gt;
&gt; That sounds like an ancient version of gas. Searching for it turns up
&gt; a fred fish CD from 1994. I most likely had it installed back in the
&gt; days. See
&gt; http://ftp.back2roots.org/back2roots/cds/fred_fish/freshfish_vol05_9407/gnu/src/baseline/
&gt;
&gt; But it must have been patched heavily by Apple if it supports x86_64...

It's indeed an old version forked from binutils, heavily patched and 
maintained by Apple since, but it's diverged pretty much from most things 
that have been added since.

&gt; I'd strongly suggest first trying to build with modern gcc and binutils,
&gt; before trying to find workarounds for apple's tools.

Well - this is the stock compiler toolchain that you get with the system - 
the vast majority of developers on OS X use that instead of building their 
own toolchains. As said before, all previous releases of nettle have 
worked just fine on OS X.

// Martin

</body></email><email><emailId>20131213121933</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-13 12:19:33-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Martin Storsjö wrote:
&gt; Just for what it's worth - I've been using nettle on OS X and it has 
&gt; worked just fine up including the 2.7 release.

Thanks for responding! What happens if you clone the repo, do the
bootstrap-configure-make dance with the current repo?
And what version of OSX and Xcode, command line tools are you running?


&gt; It's indeed an old version forked from binutils, heavily patched and 
&gt; maintained by Apple since, but it's diverged pretty much from most 
&gt; things that have been added since.
&gt; 
&gt; Well - this is the stock compiler toolchain that you get with the
&gt; system - the vast majority of developers on OS X use that instead of
&gt; building their own toolchains. As said before, all previous releases
&gt; of nettle have worked just fine on OS X.

In my experience, things normally do unless very Linux specific or GNU
specific. Since gcc in Xcode is actually a wrapper around clang/llvw.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKq+1UACgkQZoPr8HT30QGZnACfRuCQuywmKMNWqAHwFxQXQCR3
010Ani+Zk7KjzFe/P3xkN0yvni5t4P3i
=kMIL
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131213121956</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-13 12:19:56-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt;&gt;  static const uint16_t t[4] = {1,2,3,4};
&gt;&gt;
&gt;&gt; ?
&gt;
&gt; This seems to output something like this:
&gt;         .section        __TEXT,__const

I see. So we need to define a system-dependent RODATA macro in
config.m4, expanding to the right directive.

Second problem was .hword, what pseudoop does Apple's assembler use for
16-bit constants? I think current GNU as has a couple of different names
for the same thing, so if we can find a name accepted by both assemblers
that's nice, otherwise it's another problem which requires a macro in
config.m4.

&gt; As said before, all previous releases of nettle
&gt; have worked just fine on OS X.

That's very nice, and in a large part that's thanks to your work.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131213122529</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-12-13 12:25:29-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>


On Fri, 13 Dec 2013, Niels Möller wrote:

&gt; Martin Storsjö &lt;martin@martin.st&gt; writes:
&gt;
&gt;&gt;&gt;  static const uint16_t t[4] = {1,2,3,4};
&gt;&gt;&gt;
&gt;&gt;&gt; ?
&gt;&gt;
&gt;&gt; This seems to output something like this:
&gt;&gt;         .section        __TEXT,__const
&gt;
&gt; I see. So we need to define a system-dependent RODATA macro in
&gt; config.m4, expanding to the right directive.
&gt;
&gt; Second problem was .hword, what pseudoop does Apple's assembler use for
&gt; 16-bit constants? I think current GNU as has a couple of different names
&gt; for the same thing, so if we can find a name accepted by both assemblers
&gt; that's nice, otherwise it's another problem which requires a macro in
&gt; config.m4.

Ah right, I missed this part. Your C code snippet seemed to use .short - 
the whole relevant part is:

         .section        __TEXT,__const
         .align  1                       ## @t
_t:
         .short  1                       ## 0x1
         .short  2                       ## 0x2
         .short  3                       ## 0x3
         .short  4                       ## 0x4


// Martin

</body></email><email><emailId>20131213122908</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-12-13 12:29:08-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>


On Fri, 13 Dec 2013, Joachim Strömbergson wrote:

&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt;
&gt; Aloha!
&gt;
&gt; Martin Storsjö wrote:
&gt;&gt; Just for what it's worth - I've been using nettle on OS X and it has
&gt;&gt; worked just fine up including the 2.7 release.
&gt;
&gt; Thanks for responding! What happens if you clone the repo, do the
&gt; bootstrap-configure-make dance with the current repo?

I do run into the same issues as you - sorry for not making that clearer.

&gt; And what version of OSX and Xcode, command line tools are you running?

I'm using 10.8.5, xcode 5.0 - dunno where I see the version of the command 
line tools.

&gt;
&gt;&gt; It's indeed an old version forked from binutils, heavily patched and
&gt;&gt; maintained by Apple since, but it's diverged pretty much from most
&gt;&gt; things that have been added since.
&gt;&gt;
&gt;&gt; Well - this is the stock compiler toolchain that you get with the
&gt;&gt; system - the vast majority of developers on OS X use that instead of
&gt;&gt; building their own toolchains. As said before, all previous releases
&gt;&gt; of nettle have worked just fine on OS X.
&gt;
&gt; In my experience, things normally do unless very Linux specific or GNU
&gt; specific. Since gcc in Xcode is actually a wrapper around clang/llvw.

Well - hand-written assembly is one of the more problematic parts indeed. 
For x86 assembly, some other projects use nasm/yasm, but for non-x86, most 
projects end up with more elaborate tools for converting the gas source to 
something that the apple version of it can handle, such as 
https://github.com/libav/gas-preprocessor. But I'm pleasantly surprised by 
how well it has worked with nettle so far without requiring any external 
tools.

// Martin

</body></email><email><emailId>20131213123120</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-13 12:31:20-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Martin Storsjö wrote:
&gt; I'm using 10.8.5, xcode 5.0 - dunno where I see the version of the 
&gt; command line tools.

Ah, on a tool by tool basis. Such as

#&gt; gcc --version:
Apple LLVM version 5.0 (clang-500.2.79) (based on LLVM 3.3svn)
Target: x86_64-apple-darwin13.0.0

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKq/hcACgkQZoPr8HT30QEJiQCfYLm/iqNvoEi07JynKT4zRQTi
WScAoPJ85xce7uEcJOYPsCZm4O+EhQl6
=Ke80
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131213125427</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-13 12:54:27-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Martin Storsjö wrote:
&gt; Well - hand-written assembly is one of the more problematic parts 
&gt; indeed. For x86 assembly, some other projects use nasm/yasm, but for 
&gt; non-x86, most projects end up with more elaborate tools for
&gt; converting the gas source to something that the apple version of it
&gt; can handle, such as https://github.com/libav/gas-preprocessor. But
&gt; I'm pleasantly surprised by how well it has worked with nettle so far
&gt; without requiring any external tools.

Just to check: Are you saying that normally/previously you have been
able to build nettle on OSX, but not now?

And if so did you then disable usage of the asm versions in nettle?

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKrA4MACgkQZoPr8HT30QEMtwCfRg1FJyKh9Te8yRUNpQyHM990
4MEAn1vTnVDblnBT9qW75NanvrZGEDzP
=UjBK
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131213125741</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2013-12-13 12:57:41-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>


On Fri, 13 Dec 2013, Joachim Strömbergson wrote:

&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt;
&gt; Aloha!
&gt;
&gt; Martin Storsjö wrote:
&gt;&gt; Well - hand-written assembly is one of the more problematic parts
&gt;&gt; indeed. For x86 assembly, some other projects use nasm/yasm, but for
&gt;&gt; non-x86, most projects end up with more elaborate tools for
&gt;&gt; converting the gas source to something that the apple version of it
&gt;&gt; can handle, such as https://github.com/libav/gas-preprocessor. But
&gt;&gt; I'm pleasantly surprised by how well it has worked with nettle so far
&gt;&gt; without requiring any external tools.
&gt;
&gt; Just to check: Are you saying that normally/previously you have been
&gt; able to build nettle on OSX, but not now?

Yes, previously I've been able to build nettle on OSX including all 
assembler optimizations.

&gt; And if so did you then disable usage of the asm versions in nettle?

With the current git master version it fails, but if I disable assembly 
using --disable-assembler, it works.

Do note that if you've previously tried (unsuccessfully) to build in the 
same directory and change the configuration, you'll need to do "make 
distclean" inbetween, otherwise the new configuration won't take effect 
properly. This sounds like the issue you're running into when trying to 
use --disable-assembler.

// Martin

</body></email><email><emailId>20131213131409</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-13 13:14:09-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Martin Storsjö wrote:
&gt; With the current git master version it fails, but if I disable
&gt; assembly using --disable-assembler, it works.
&gt; 
&gt; Do note that if you've previously tried (unsuccessfully) to build in
&gt; the same directory and change the configuration, you'll need to do
&gt; "make distclean" inbetween, otherwise the new configuration won't
&gt; take effect properly. This sounds like the issue you're running into
&gt; when trying to use --disable-assembler.

Yes, yes, yes! Thanks. It now builds.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKrCCEACgkQZoPr8HT30QEkiwCdGYHOUk2ABxx7FFmgtVCG2FdG
5FMAoNkg+71UWNXJYM2o+Fa0pWt9h0zx
=kLq+
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131214093050</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-14 09:30:50-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; Your C code snippet seemed to use .short

Ok, I've now changed gcm-hash8.asm to also use .short.

Remains the configure test for rodata. Not sure what's best, but perhaps
easiest to just check of $host_os is darwin.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131214192951</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-14 19:29:51-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Niels Möller wrote:
&gt; Martin Storsjö &lt;martin@martin.st&gt; writes:
&gt; 
&gt;&gt; Your C code snippet seemed to use .short
&gt; 
&gt; Ok, I've now changed gcm-hash8.asm to also use .short.

I just tested a clean clone and it fails on the gcm-hash8.s due do the
final section is being set to .rodata in the asm file. I changed it to
__TEXT,__const and then it builds. Patch below.


diff --git a/x86_64/gcm-hash8.asm b/x86_64/gcm-hash8.asm
index 60f444d..d33dfea 100644
- --- a/x86_64/gcm-hash8.asm
+++ b/x86_64/gcm-hash8.asm
@@ -188,7 +188,7 @@ ALIGN(16)
 EPILOGUE(_nettle_gcm_hash8)

 define(&lt;W&gt;, &lt;0x$2$1&gt;)
- -       .section .rodata
+       .section __TEXT,__const
        ALIGN(2)
 .Lshift_table:
 .short
W(00,00),W(01,c2),W(03,84),W(02,46),W(07,08),W(06,ca),W(04,8c),W(05,4e)

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKssa8ACgkQZoPr8HT30QG0vQCgniwTrmRad40bFG41q1ogpGtp
CfkAoM/ztZe1kAXL883d5oMUIoOXpvYv
=0ODh
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131215215807</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-15 21:58:07-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; I just tested a clean clone and it fails on the gcm-hash8.s due do the
&gt; final section is being set to .rodata in the asm file. I changed it to
&gt; __TEXT,__const and then it builds. Patch below.

Good progress.

Below is an untested patch for the configure machinery. Can you try this?

BTW, is ".section __TEXT,__const" different from the text segment used
for the executable code? Or would it work just sas well to have an
definition of RODATA, and get the table in the same section as the code?

Regards,
/Niels

diff --git a/config.m4.in b/config.m4.in
index 4c6565f..da57e25 100644
--- a/config.m4.in
+++ b/config.m4.in
@@ -6,6 +6,7 @@ define(&lt;TYPE_PROGBITS&gt;, &lt;@ASM_TYPE_PROGBITS@&gt;)dnl
 define(&lt;ALIGN_LOG&gt;, &lt;@ASM_ALIGN_LOG@&gt;)dnl
 define(&lt;ALIGNOF_UINT64_T&gt;, &lt;@ALIGNOF_UINT64_T@&gt;)dnl
 define(&lt;W64_ABI&gt;, &lt;@W64_ABI@&gt;)dnl
+define(&lt;RODATA&gt;, &lt;@ASM_RODATA@&gt;)dnl
 divert(1)
 @ASM_MARK_NOEXEC_STACK@
 divert
diff --git a/configure.ac b/configure.ac
index a4deaae..acfc59c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -332,10 +332,19 @@ EOF
       AC_MSG_WARN([No assembler files found.])
     fi
   fi
+  case "$host_os" in
+    darwin*)
+      ASM_RODATA='.section __TEXT,__const'
+      ;;
+    *)
+      ASM_RODATA='.section .rodata'
+      ;;
+  esac
 fi
 
 AC_SUBST([OPT_ASM_NETTLE_SOURCES])
 AC_SUBST([OPT_ASM_HOGWEED_SOURCES])
+AC_SUBST([ASM_RODATA])
 
 AH_VERBATIM([HAVE_NATIVE],
 [/* Define to 1 each of the following for which a native (ie. CPU specific)
diff --git a/x86_64/gcm-hash8.asm b/x86_64/gcm-hash8.asm
index 60f444d..e742cec 100644
--- a/x86_64/gcm-hash8.asm
+++ b/x86_64/gcm-hash8.asm
@@ -188,7 +188,7 @@ ALIGN(16)
 EPILOGUE(_nettle_gcm_hash8)
 
 define(&lt;W&gt;, &lt;0x$2$1&gt;)
-	.section .rodata
+	RODATA
 	ALIGN(2)
 .Lshift_table:
 .short W(00,00),W(01,c2),W(03,84),W(02,46),W(07,08),W(06,ca),W(04,8c),W(05,4e)

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131217212118</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-17 21:21:18-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Below is an untested patch for the configure machinery. Can you try this?

I haven't seen any feedback on this, but I have now checked it in
nonetheless.

It would be nice if you could confirm that it actually works. If you or
Martin also have a real gcc and GNU binutils installed on macosx, it
would be nice if you could test that it works also when building with
the GNU tools.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131217215754</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-17 21:57:54-0400</timestampReceived><subject>Re: Building nettle in OSX</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Niels Möller wrote:
&gt; I haven't seen any feedback on this, but I have now checked it in 
&gt; nonetheless.
&gt; 
&gt; It would be nice if you could confirm that it actually works. If you
&gt; or Martin also have a real gcc and GNU binutils installed on macosx,
&gt; it would be nice if you could test that it works also when building
&gt; with the GNU tools.

Sorry for the late response, Christmas coming up soon.

I just made a fresh clone of the repo and can confirm that it builds
fine on OSX 10.9 with the latest Xcode and command line tools from
Apple. Good work, thanks!

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEUEARECAAYFAlKwyOIACgkQZoPr8HT30QHJ/QCdFCt/4CCwYPcNn2oM1UEovFMK
YQoAlAgZ9j07tz1ytYIn4uamFuVgv/g=
=VE4e
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131213104023</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-13 10:40:23-0400</timestampReceived><subject>Re: Mentioning of  .bootstrap in INSTALL?</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; Shouldn't INSTALL mention this?

INSTALL is the generic GNU installation instructions, and intended for
the user who has downloaded a release tarball. I'd prefer to not add any
nettle-specific info there.

The README file mentions building from git and refers to
http://www.lysator.liu.se/~nisse/nettle/ for instructions. That page
says "After checkout, you need to run the .bootstrap script before the
standard ./configure &amp;&amp; make.". Maybe that could be made clearer in some
way?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131213112344</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-13 11:23:44-0400</timestampReceived><subject>Re: Mentioning of  .bootstrap in INSTALL?</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Niels Möller wrote:
&gt; Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:
&gt; 
&gt;&gt; Shouldn't INSTALL mention this?
&gt; 
&gt; INSTALL is the generic GNU installation instructions, and intended
&gt; for the user who has downloaded a release tarball. I'd prefer to not
&gt; add any nettle-specific info there.

Reading the INSTALL file it wasn't obvious it only related to users
using the dist tarball. If it was me I would have added a paragraph
noting that for users cloning the repo they should do something
else/additionally to INSTALL the sw.


&gt; The README file mentions building from git and refers to 
&gt; http://www.lysator.liu.se/~nisse/nettle/ for instructions. That page 
&gt; says "After checkout, you need to run the .bootstrap script before
&gt; the standard ./configure &amp;&amp; make.". Maybe that could be made clearer
&gt; in some way?

At least not having one indirection in documentation. I think the
bootstrap should be mentioned directly in a README, INSTALL etc file
directly in the reop. REPO might also be a good name for info on the
contents and usage of the repo.

Also, should the build process for users of the distributiion be
mentioned also in the README? It is basically the same info in README
and INSTALL. I suggest changing to "see INSTALL for build instructions."
in the README. And place something about the git repo and bootstrap in
that file.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKq7kAACgkQZoPr8HT30QGp+QCg3wPGF+Wn/jtqxtO5d+NbH+1H
t6UAn2Ns4F1lYe1A7JI2jjtGUB9UPDGH
=BPol
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131217211709</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-17 21:17:09-0400</timestampReceived><subject>Re: Mentioning of  .bootstrap in INSTALL?</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; At least not having one indirection in documentation. I think the
&gt; bootstrap should be mentioned directly in a README, INSTALL etc file
&gt; directly in the reop.

I did some small changes to the README, to try to make it clearer.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131211115632</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-11 11:56:32-0400</timestampReceived><subject>Re: TMP_ALLOC and size_t change</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt;  In master (unsigned int) was replaced with (size_t), that allows for
&gt; even larger sizes to be input to encryption and decryption functions.
&gt; However, the usage of TMP_ALLOC to make a copy of the input data
&gt; (e.g., in ctr.c) contradicts that goal.

The intention is that TMP_ALLOC should only ever be used for small
allocations. And each use must specify a maximum size. If you see any
TMP_ALLOC with a potentially large size, that is a bug. (In case anyone
else here is also hacking gmp, I should point out that gmp's TMP_ALLOC
is different))

In ctr.c, the max size is 128 bytes (NBLOCKS *
NETTLE_MAX_CIPHER_BLOCK_SIZE).

I see no problem there, except that an

  assert (block_size &lt;= NETTLE_MAX_CIPHER_BLOCK_SIZE);

might be appropriate.

&gt; I think there can be an easy modification of TMP_ALLOC to use malloc
&gt; for larger than 128 (or any other fixed number), and alloca otherwise.

As far as possible, I think we should avoid large allocations. So I
don't think such a change is needed.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131211132653</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-12-11 13:26:53-0400</timestampReceived><subject>Re: TMP_ALLOC and size_t change</subject><body>

On Wed, Dec 11, 2013 at 12:56 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:
&gt; In ctr.c, the max size is 128 bytes (NBLOCKS *
&gt; NETTLE_MAX_CIPHER_BLOCK_SIZE).

Ok didn't notice that. However, the bignum functions like
pkcs1_decrypt, pkcs1_encrypt, pkcs1_rsa_digest_encode,
nettle_mpz_random_size seem to have no such limits.

regards,
Nikos

</body></email><email><emailId>20131211134718</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-11 13:47:18-0400</timestampReceived><subject>Re: TMP_ALLOC and size_t change</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Ok didn't notice that. However, the bignum functions like
&gt; pkcs1_decrypt, pkcs1_encrypt, pkcs1_rsa_digest_encode,
&gt; nettle_mpz_random_size seem to have no such limits.

They work under the assumption that key_size is less than 10000 bits
(see NETTLE_MAX_BIGNUM_BITS, 10000, and NETTLE_MAX_BIGNUM_SIZE, 1250).

I agree this is a bit more questionable.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131211141326</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-12-11 14:13:26-0400</timestampReceived><subject>Re: TMP_ALLOC and size_t change</subject><body>

On Wed, Dec 11, 2013 at 2:47 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt;&gt; Ok didn't notice that. However, the bignum functions like
&gt;&gt; pkcs1_decrypt, pkcs1_encrypt, pkcs1_rsa_digest_encode,
&gt;&gt; nettle_mpz_random_size seem to have no such limits.
&gt; They work under the assumption that key_size is less than 10000 bits
&gt; (see NETTLE_MAX_BIGNUM_BITS, 10000, and NETTLE_MAX_BIGNUM_SIZE, 1250).
&gt; I agree this is a bit more questionable.

As far as I understand that size assumption is only enforced on
systems without alloca using an assert. In systems with alloca there
is no such check. In both cases, it seems to be easy to abuse them for
a denial of service.

I think it would be better for these functions to fail rather than
abort() if parameters are out of supported range.

regards,
Nikos

</body></email><email><emailId>20131212115504</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-12-12 11:55:04-0400</timestampReceived><subject>Re: TMP_ALLOC and size_t change</subject><body>

On Wed, Dec 11, 2013 at 3:13 PM, Nikos Mavrogiannopoulos
&lt;n.mavrogiannopoulos@gmail.com&gt; wrote:

&gt; As far as I understand that size assumption is only enforced on
&gt; systems without alloca using an assert. In systems with alloca there
&gt; is no such check. In both cases, it seems to be easy to abuse them for
&gt; a denial of service.
&gt; I think it would be better for these functions to fail rather than
&gt; abort() if parameters are out of supported range.

A fix that could suit the master branch is attached. That adds the
possibility to return an error if the maximum sizes are exceeded. For
2.7.x though this can be handled by an abort which is less than ideal,
as it looks trivial to exploit for DoS. Even worse,
nettle_mpz_set_str_256*() does not enforce the maximum limits on big
numbers and doesn't even have the ability to return an error.

The patch is pretty ugly because it introduces unused variables, but
couldn't think of a cleaner way to fix that.

Any other ideas on how the issue can be gracefully solved (especially
in the 2.7 branch)?

regards,
Nikos

["patch.txt" (text/plain)]

diff --git a/bignum-next-prime.c b/bignum-next-prime.c
index 58a4df8..9c17e09 100644
--- a/bignum-next-prime.c
+++ b/bignum-next-prime.c
@@ -72,7 +72,7 @@ static const uint16_t primes[] = {
 #endif
 
 /* NOTE: The mpz_nextprime in current GMP is unoptimized. */
-void
+int
 nettle_next_prime(mpz_t p, mpz_t n, unsigned count, unsigned prime_limit,
 		  void *progress_ctx, nettle_progress_func *progress)
 {
@@ -88,13 +88,13 @@ nettle_next_prime(mpz_t p, mpz_t n, unsigned count, unsigned prime_limit,
   if (mpz_cmp_ui(n, 2) &lt;= 0)
     {
       mpz_set_ui(p, 2);
-      return;
+      return 1;
     }
   mpz_set(p, n);
   mpz_setbit(p, 0);
 
   if (mpz_cmp_ui(p, 8) &lt; 0)
-    return;
+    return 1;
 
   mpz_init(tmp);
 
@@ -112,7 +112,7 @@ nettle_next_prime(mpz_t p, mpz_t n, unsigned count, unsigned prime_limit,
      between the 5760 odd numbers in this interval that have no factor
      in common with 15015.
    */
-  TMP_ALLOC(moduli, prime_limit);
+  TMP_ALLOC_SAFE_ERR(moduli, prime_limit);
   {
     unsigned i;
     for (i = 0; i &lt; prime_limit; i++)
@@ -159,4 +159,6 @@ nettle_next_prime(mpz_t p, mpz_t n, unsigned count, unsigned prime_limit,
 #endif
     }
   mpz_clear(tmp);
+  
+  return 1;
 }
diff --git a/bignum-random.c b/bignum-random.c
index f305f04..a584ba2 100644
--- a/bignum-random.c
+++ b/bignum-random.c
@@ -32,14 +32,14 @@
 #include "bignum.h"
 #include "nettle-internal.h"
 
-void
+int
 nettle_mpz_random_size(mpz_t x,
 		       void *ctx, nettle_random_func *random,
 		       unsigned bits)
 {
   unsigned length = (bits + 7) / 8;
   TMP_DECL(data, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(data, length);
+  TMP_ALLOC_SAFE_ERR(data, length);
 
   random(ctx, length, data);
 
@@ -47,14 +47,17 @@ nettle_mpz_random_size(mpz_t x,
 
   if (bits % 8)
     mpz_fdiv_r_2exp(x, x, bits);
+  
+  return 1;
 }
 
 /* Returns a random number x, 0 &lt;= x &lt; n */
-void
+int
 nettle_mpz_random(mpz_t x,
 		  void *ctx, nettle_random_func *random,
 		  const mpz_t n)
 {
+int ret;
   /* NOTE: This leaves some bias, which may be bad for DSA. A better
    * way might be to generate a random number of mpz_sizeinbase(n, 2)
    * bits, and loop until one smaller than n is found. */
@@ -78,9 +81,12 @@ nettle_mpz_random(mpz_t x,
    * operation. NIST FIPS 186-3 specifies 64 extra bits, for use with
    * DSA. */
 
-  nettle_mpz_random_size(x, 
+  ret = nettle_mpz_random_size(x, 
 			 ctx, random,
 			 mpz_sizeinbase(n, 2) + 64);
-  
+  if (ret == 0)
+    return ret;
   mpz_fdiv_r(x, x, n);
+  
+  return 1;
 }
diff --git a/bignum.h b/bignum.h
index b5b9f1a..039b64c 100644
--- a/bignum.h
+++ b/bignum.h
@@ -69,19 +69,19 @@ nettle_mpz_init_set_str_256_u(mpz_t x,
 			      size_t length, const uint8_t *s);
 
 /* Returns a uniformly distributed random number 0 &lt;= x &lt; 2^n */
-void
+int
 nettle_mpz_random_size(mpz_t x,
 		       void *ctx, nettle_random_func *random,
 		       unsigned bits);
 
 /* Returns a number x, almost uniformly random in the range
  * 0 &lt;= x &lt; n. */
-void
+int
 nettle_mpz_random(mpz_t x, 
 		  void *ctx, nettle_random_func *random,
 		  const mpz_t n);
 
-void
+int
 nettle_next_prime(mpz_t p, mpz_t n, unsigned count, unsigned prime_limit,
 		  void *progress_ctx, nettle_progress_func *progress);
 
diff --git a/nettle-internal.h b/nettle-internal.h
index 10689d4..4af90f3 100644
--- a/nettle-internal.h
+++ b/nettle-internal.h
@@ -37,12 +37,25 @@
  * fix maximum size, and abort if we ever need anything larger. */
 
 #if HAVE_ALLOCA
-# define TMP_DECL(name, type, max) type *name
-# define TMP_ALLOC(name, size) (name = alloca(sizeof (*name) * (size)))
+# define TMP_DECL(name, type, max) \
+	type *name; \
+	static const unsigned name##_max = max
+# define TMP_ALLOC_SAFE_ERR(name, size) \
+	do { \
+	if (name##_max &lt; (sizeof (*name) * (size))) \
+		return 0; \
+	(name = alloca(sizeof (*name) * (size))); \
+	} while (0)
+# define TMP_ALLOC(name, size) \
+	(name = alloca(sizeof (*name) * (size)))
 #else /* !HAVE_ALLOCA */
-# define TMP_DECL(name, type, max) type name[max]
+# define TMP_DECL(name, type, max) \
+	type name[max]; \
+	const unsigned name##_tmp_max = max
 # define TMP_ALLOC(name, size) \
   do { if ((size) &gt; (sizeof(name) / sizeof(name[0]))) abort(); } while (0)
+# define TMP_ALLOC_SAFE_ERR(name, size) \
+  do { if ((size) &gt; (sizeof(name) / sizeof(name[0]))) return 0; } while (0)
 #endif 
 
 /* Arbitrary limits which apply to systems that don't have alloca */
diff --git a/pkcs1-decrypt.c b/pkcs1-decrypt.c
index 02d3728..b685b09 100644
--- a/pkcs1-decrypt.c
+++ b/pkcs1-decrypt.c
@@ -43,7 +43,7 @@ pkcs1_decrypt (size_t key_size,
   size_t padding;
   size_t message_length;
 
-  TMP_ALLOC(em, key_size);
+  TMP_ALLOC_SAFE_ERR(em, key_size);
   nettle_mpz_get_str_256(key_size, em, m);
 
   /* Check format */
diff --git a/pkcs1-encrypt.c b/pkcs1-encrypt.c
index 69ef5bc..cceeeca 100644
--- a/pkcs1-encrypt.c
+++ b/pkcs1-encrypt.c
@@ -63,7 +63,7 @@ pkcs1_encrypt (size_t key_size,
   padding = key_size - length - 3;
   assert(padding &gt;= 8);
   
-  TMP_ALLOC(em, key_size - 1);
+  TMP_ALLOC_SAFE_ERR(em, key_size - 1);
   em[0] = 2;
 
   random(random_ctx, padding, em + 1);
diff --git a/pkcs1-rsa-digest.c b/pkcs1-rsa-digest.c
index debfb28..35b4777 100644
--- a/pkcs1-rsa-digest.c
+++ b/pkcs1-rsa-digest.c
@@ -36,7 +36,7 @@ pkcs1_rsa_digest_encode(mpz_t m, size_t key_size,
 			size_t di_length, const uint8_t *digest_info)
 {
   TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_ALLOC_SAFE_ERR(em, key_size);
 
   if (_pkcs1_signature_prefix(key_size, em,
 			      di_length, digest_info, 0))
diff --git a/pkcs1-rsa-md5.c b/pkcs1-rsa-md5.c
index b118b4f..440242a 100644
--- a/pkcs1-rsa-md5.c
+++ b/pkcs1-rsa-md5.c
@@ -66,7 +66,7 @@ pkcs1_rsa_md5_encode(mpz_t m, size_t key_size, struct md5_ctx *hash)
 {
   uint8_t *p;
   TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_ALLOC_SAFE_ERR(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(md5_prefix),
@@ -87,7 +87,7 @@ pkcs1_rsa_md5_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
 {
   uint8_t *p;
   TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_ALLOC_SAFE_ERR(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(md5_prefix),
diff --git a/pkcs1-rsa-sha1.c b/pkcs1-rsa-sha1.c
index 781d75d..3996ecf 100644
--- a/pkcs1-rsa-sha1.c
+++ b/pkcs1-rsa-sha1.c
@@ -66,7 +66,7 @@ pkcs1_rsa_sha1_encode(mpz_t m, size_t key_size, struct sha1_ctx *hash)
 {
   uint8_t *p;
   TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_ALLOC_SAFE_ERR(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha1_prefix),
@@ -87,7 +87,7 @@ pkcs1_rsa_sha1_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
 {
   uint8_t *p;
   TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_ALLOC_SAFE_ERR(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha1_prefix),
diff --git a/pkcs1-rsa-sha256.c b/pkcs1-rsa-sha256.c
index a4d5bb1..12d355d 100644
--- a/pkcs1-rsa-sha256.c
+++ b/pkcs1-rsa-sha256.c
@@ -64,7 +64,7 @@ pkcs1_rsa_sha256_encode(mpz_t m, size_t key_size, struct sha256_ctx *hash)
 {
   uint8_t *p;
   TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_ALLOC_SAFE_ERR(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha256_prefix),
@@ -85,7 +85,7 @@ pkcs1_rsa_sha256_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
 {
   uint8_t *p;
   TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_ALLOC_SAFE_ERR(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha256_prefix),
diff --git a/pkcs1-rsa-sha512.c b/pkcs1-rsa-sha512.c
index 03acb69..e6f54f1 100644
--- a/pkcs1-rsa-sha512.c
+++ b/pkcs1-rsa-sha512.c
@@ -64,7 +64,7 @@ pkcs1_rsa_sha512_encode(mpz_t m, size_t key_size, struct sha512_ctx *hash)
 {
   uint8_t *p;
   TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_ALLOC_SAFE_ERR(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha512_prefix),
@@ -85,7 +85,7 @@ pkcs1_rsa_sha512_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
 {
   uint8_t *p;
   TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_ALLOC_SAFE_ERR(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha512_prefix),


</body></email><email><emailId>20131212144044</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-12 14:40:44-0400</timestampReceived><subject>Re: TMP_ALLOC and size_t change</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; A fix that could suit the master branch is attached. That adds the
&gt; possibility to return an error if the maximum sizes are exceeded.

For the functions involving bignums, I wonder if it's better to allocate
the needed storage, either with malloc or with gmp allocation functions.
gmp is going to be allocating things anyway, so there's little point in
avoiding malloc (which is a different situation than, e.g, ctr.c). And
it's not really the right place for arbitrary limits.

&gt; 2.7.x though this can be handled by an abort which is less than ideal,
&gt; as it looks trivial to exploit for DoS.

I'm not too concerned about DoS here. An application receiving an RSA
key from an untrusted source should impose some reasonable limit on
keysize before it is used. If I send you a public RSA key with n and e
of 100000 bits, and some signature for you to verify, and you don't
impose any limit on key size, I'll hog your cpu for quite a while.

And the application really has to choose the limit, that's not Nettle's
job.

That said, Nettle shouldn't do unbounded stack allocations in this case,
it ought to use malloc, or abort or fail in some other *reliable*
fashion. (I think having some documented limit on keysize would be
acceptable, but I'm leaning towards saying that it's better to just use
heap allcoation).

Do you agree?

&gt; Even worse, nettle_mpz_set_str_256*() does not enforce the maximum
&gt; limits on big numbers and doesn't even have the ability to return an
&gt; error.

I'm not entirely sure what problem you see here.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131212152014</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-12-12 15:20:14-0400</timestampReceived><subject>Re: TMP_ALLOC and size_t change</subject><body>

On Thu, Dec 12, 2013 at 3:40 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; I'm not too concerned about DoS here. An application receiving an RSA
&gt; key from an untrusted source should impose some reasonable limit on
&gt; keysize before it is used. If I send you a public RSA key with n and e
&gt; of 100000 bits, and some signature for you to verify, and you don't
&gt; impose any limit on key size, I'll hog your cpu for quite a while.

Indeed, but this reasonable limit has to be somehow known to the applicatio=
n
to be enforced prior to calling the nettle functions. Now my limits in
gnutls and nettle's
limits are disconnected (as I only now realized that some functions of
nettle could
abort after 10000 bits).

&gt; That said, Nettle shouldn't do unbounded stack allocations in this case,
&gt; it ought to use malloc, or abort or fail in some other *reliable*
&gt; fashion. (I think having some documented limit on keysize would be
&gt; acceptable, but I'm leaning towards saying that it's better to just use
&gt; heap allcoation).
&gt; Do you agree?

Yes, that would be much better. Do you want me to send an updated patch?

regards,
Nikos

</body></email><email><emailId>20131212163150</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-12 16:31:50-0400</timestampReceived><subject>Re: TMP_ALLOC and size_t change</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt;&gt; That said, Nettle shouldn't do unbounded stack allocations in this case,
&gt;&gt; it ought to use malloc, or abort or fail in some other *reliable*
&gt;&gt; fashion. (I think having some documented limit on keysize would be
&gt;&gt; acceptable, but I'm leaning towards saying that it's better to just use
&gt;&gt; heap allcoation).
&gt;&gt; Do you agree?
&gt;
&gt; Yes, that would be much better. Do you want me to send an updated patch?

That would be good. I think it makes sense to use gmp's allocation
functions here, so the user can override allocation, without having to
do it separately for nettle and gmp. See gmp-glue.c:gmp_alloc_limbs.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131213100104</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-12-13 10:01:04-0400</timestampReceived><subject>Re: TMP_ALLOC and size_t change</subject><body>

On Thu, Dec 12, 2013 at 5:31 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt;&gt;&gt; That said, Nettle shouldn't do unbounded stack allocations in this case=
,
&gt;&gt;&gt; it ought to use malloc, or abort or fail in some other *reliable*
&gt;&gt;&gt; fashion. (I think having some documented limit on keysize would be
&gt;&gt;&gt; acceptable, but I'm leaning towards saying that it's better to just use
&gt;&gt;&gt; heap allcoation).
&gt;&gt;&gt; Do you agree?
&gt;&gt; Yes, that would be much better. Do you want me to send an updated patch?
&gt; That would be good. I think it makes sense to use gmp's allocation
&gt; functions here, so the user can override allocation, without having to
&gt; do it separately for nettle and gmp. See gmp-glue.c:gmp_alloc_limbs.

What about the attached patch?

["0001-Introduced-TMP_GMP_ALLOC-macro-for-temporary-allocat.patch" (text/x-patch)]

From c1ddf689f217e87504080331290ba8dc5ab24365 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Fri, 13 Dec 2013 10:58:30 +0100
Subject: [PATCH] Introduced TMP_GMP_ALLOC macro for temporary allocations of
 potentially large data.

This prevents big data allocations on stack by using TMP_GMP_ALLOC in places
where TMP_ALLOC was called with potentially large data size.
---
 Makefile.in         |  2 +-
 bignum-internal.h   | 57 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 bignum-next-prime.c |  8 +++++---
 bignum-random.c     |  9 ++++++---
 pkcs1-decrypt.c     | 31 ++++++++++++++++++++++-------
 pkcs1-encrypt.c     |  7 +++++--
 pkcs1-rsa-digest.c  | 12 ++++++++---
 pkcs1-rsa-md5.c     | 23 +++++++++++++++------
 pkcs1-rsa-sha1.c    | 23 +++++++++++++++------
 pkcs1-rsa-sha256.c  | 23 +++++++++++++++------
 pkcs1-rsa-sha512.c  | 23 +++++++++++++++------
 11 files changed, 175 insertions(+), 43 deletions(-)
 create mode 100644 bignum-internal.h

diff --git a/Makefile.in b/Makefile.in
index 05e6ade..39274df 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -182,7 +182,7 @@ DISTFILES = $(SOURCES) $(HEADERS) getopt.h .bootstrap run-tests \
 	cast128_sboxes.h desinfo.h desCode.h \
 	nettle-internal.h nettle-write.h prime-list.h \
 	gmp-glue.h ecc-internal.h \
-	mini-gmp.h mini-gmp.c asm.m4 \
+	mini-gmp.h mini-gmp.c asm.m4 bignum-internal.h \
 	nettle.texinfo nettle.info nettle.html nettle.pdf sha-example.c
 
 # Rules building static libraries
diff --git a/bignum-internal.h b/bignum-internal.h
new file mode 100644
index 0000000..c73ea47
--- /dev/null
+++ b/bignum-internal.h
@@ -0,0 +1,57 @@
+/* bignum-internal.h
+ *
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Red Hat
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#ifndef BIGNUM_INTERNAL_H
+# define BIGNUM_INTERNAL_H
+
+#include &lt;assert.h&gt;
+
+inline static void* _tmp_gmp_alloc(unsigned* out_n, size_t n)
+{
+	void *(*alloc_func)(size_t);
+	assert (n &gt; 0);
+
+	mp_get_memory_functions(&amp;alloc_func, NULL, NULL);
+	
+	*out_n = n;
+	return alloc_func (n);
+}
+
+inline static void _tmp_gmp_free(void* p, size_t n)
+{
+  void (*free_func)(void *, size_t);
+  assert (n &gt; 0);
+  assert (p != 0);
+  mp_get_memory_functions (NULL, NULL, &amp;free_func);
+
+  free_func (p, (size_t) n);
+}
+
+#define TMP_GMP_DECL(name, type) type *name; \
+	unsigned name##_gmp_size
+#define TMP_GMP_ALLOC(name, size) \
+	(name = _tmp_gmp_alloc(&amp;name##_gmp_size, sizeof (*name) * (size)))
+#define TMP_GMP_FREE(name) (_tmp_gmp_free(name, name##_gmp_size))
+
+#endif
diff --git a/bignum-next-prime.c b/bignum-next-prime.c
index 58a4df8..bc89399 100644
--- a/bignum-next-prime.c
+++ b/bignum-next-prime.c
@@ -31,6 +31,7 @@
 #include &lt;stdlib.h&gt;
 
 #include "bignum.h"
+#include "bignum-internal.h"
 
 #include "nettle-internal.h"
 
@@ -77,9 +78,8 @@ nettle_next_prime(mpz_t p, mpz_t n, unsigned count, unsigned prime_limit,
 		  void *progress_ctx, nettle_progress_func *progress)
 {
   mpz_t tmp;
-  TMP_DECL(moduli, unsigned, NUMBER_OF_PRIMES);
-  
   unsigned difference;
+  TMP_GMP_DECL(moduli, unsigned);
 
   if (prime_limit &gt; NUMBER_OF_PRIMES)
     prime_limit = NUMBER_OF_PRIMES;
@@ -112,7 +112,8 @@ nettle_next_prime(mpz_t p, mpz_t n, unsigned count, unsigned prime_limit,
      between the 5760 odd numbers in this interval that have no factor
      in common with 15015.
    */
-  TMP_ALLOC(moduli, prime_limit);
+  TMP_GMP_ALLOC(moduli, prime_limit);
+
   {
     unsigned i;
     for (i = 0; i &lt; prime_limit; i++)
@@ -159,4 +160,5 @@ nettle_next_prime(mpz_t p, mpz_t n, unsigned count, unsigned prime_limit,
 #endif
     }
   mpz_clear(tmp);
+  TMP_GMP_FREE(moduli);
 }
diff --git a/bignum-random.c b/bignum-random.c
index f305f04..07ae1ba 100644
--- a/bignum-random.c
+++ b/bignum-random.c
@@ -30,6 +30,7 @@
 #include &lt;stdlib.h&gt;
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "nettle-internal.h"
 
 void
@@ -38,15 +39,17 @@ nettle_mpz_random_size(mpz_t x,
 		       unsigned bits)
 {
   unsigned length = (bits + 7) / 8;
-  TMP_DECL(data, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(data, length);
+  TMP_GMP_DECL(data, uint8_t);
 
-  random(ctx, length, data);
+  TMP_GMP_ALLOC(data, length);
 
+  random(ctx, length, data);
   nettle_mpz_set_str_256_u(x, length, data);
 
   if (bits % 8)
     mpz_fdiv_r_2exp(x, x, bits);
+  
+  TMP_GMP_FREE(data);
 }
 
 /* Returns a random number x, 0 &lt;= x &lt; n */
diff --git a/pkcs1-decrypt.c b/pkcs1-decrypt.c
index 02d3728..96016e0 100644
--- a/pkcs1-decrypt.c
+++ b/pkcs1-decrypt.c
@@ -31,6 +31,7 @@
 #include "pkcs1.h"
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "nettle-internal.h"
 
 int
@@ -38,35 +39,51 @@ pkcs1_decrypt (size_t key_size,
 	       const mpz_t m,
 	       size_t *length, uint8_t *message)
 {
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
+  TMP_GMP_DECL(em, uint8_t);
   uint8_t *terminator;
   size_t padding;
   size_t message_length;
+  int ret;
 
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_ALLOC(em, key_size);
   nettle_mpz_get_str_256(key_size, em, m);
 
   /* Check format */
   if (em[0] || em[1] != 2)
-    return 0;
+    {
+      ret = 0;
+      goto err;
+    }
 
   terminator = memchr(em + 2, 0, key_size - 2);
 
   if (!terminator)
-    return 0;
+    {
+      ret = 0;
+      goto err;
+    }
   
   padding = terminator - (em + 2);
   if (padding &lt; 8)
-    return 0;
+    {
+      ret = 0;
+      goto err;
+    }
 
   message_length = key_size - 3 - padding;
 
   if (*length &lt; message_length)
-    return 0;
+    {
+      ret = 0;
+      goto err;
+    }
   
   memcpy(message, terminator + 1, message_length);
   *length = message_length;
 
-  return 1;
+  ret = 1;
+err:
+  TMP_GMP_FREE(em);
+  return ret;
 }
 	       
diff --git a/pkcs1-encrypt.c b/pkcs1-encrypt.c
index 69ef5bc..9f34343 100644
--- a/pkcs1-encrypt.c
+++ b/pkcs1-encrypt.c
@@ -34,6 +34,7 @@
 #include "pkcs1.h"
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "nettle-internal.h"
 
 int
@@ -43,7 +44,7 @@ pkcs1_encrypt (size_t key_size,
 	       size_t length, const uint8_t *message,
 	       mpz_t m)
 {
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
+  TMP_GMP_DECL(em, uint8_t);
   size_t padding;
   size_t i;
 
@@ -63,7 +64,7 @@ pkcs1_encrypt (size_t key_size,
   padding = key_size - length - 3;
   assert(padding &gt;= 8);
   
-  TMP_ALLOC(em, key_size - 1);
+  TMP_GMP_ALLOC(em, key_size - 1);
   em[0] = 2;
 
   random(random_ctx, padding, em + 1);
@@ -77,5 +78,7 @@ pkcs1_encrypt (size_t key_size,
   memcpy(em + padding + 2, message, length);
 
   nettle_mpz_set_str_256_u(m, key_size - 1, em);
+  
+  TMP_GMP_FREE(em);
   return 1;
 }
diff --git a/pkcs1-rsa-digest.c b/pkcs1-rsa-digest.c
index debfb28..5f348ae 100644
--- a/pkcs1-rsa-digest.c
+++ b/pkcs1-rsa-digest.c
@@ -29,21 +29,27 @@
 #include "pkcs1.h"
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "nettle-internal.h"
 
 int
 pkcs1_rsa_digest_encode(mpz_t m, size_t key_size,
 			size_t di_length, const uint8_t *digest_info)
 {
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   if (_pkcs1_signature_prefix(key_size, em,
 			      di_length, digest_info, 0))
     {
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
diff --git a/pkcs1-rsa-md5.c b/pkcs1-rsa-md5.c
index b118b4f..87b423a 100644
--- a/pkcs1-rsa-md5.c
+++ b/pkcs1-rsa-md5.c
@@ -34,6 +34,7 @@
 #include "rsa.h"
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "pkcs1.h"
 
 #include "nettle-internal.h"
@@ -65,8 +66,9 @@ int
 pkcs1_rsa_md5_encode(mpz_t m, size_t key_size, struct md5_ctx *hash)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(md5_prefix),
@@ -76,18 +78,23 @@ pkcs1_rsa_md5_encode(mpz_t m, size_t key_size, struct md5_ctx *hash)
     {
       md5_digest(hash, MD5_DIGEST_SIZE, p);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
 
 int
 pkcs1_rsa_md5_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(md5_prefix),
@@ -97,8 +104,12 @@ pkcs1_rsa_md5_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
     {
       memcpy(p, digest, MD5_DIGEST_SIZE);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
diff --git a/pkcs1-rsa-sha1.c b/pkcs1-rsa-sha1.c
index 781d75d..84ebb4c 100644
--- a/pkcs1-rsa-sha1.c
+++ b/pkcs1-rsa-sha1.c
@@ -34,6 +34,7 @@
 #include "rsa.h"
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "pkcs1.h"
 
 #include "nettle-internal.h"
@@ -65,8 +66,9 @@ int
 pkcs1_rsa_sha1_encode(mpz_t m, size_t key_size, struct sha1_ctx *hash)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha1_prefix),
@@ -76,18 +78,23 @@ pkcs1_rsa_sha1_encode(mpz_t m, size_t key_size, struct sha1_ctx *hash)
     {
       sha1_digest(hash, SHA1_DIGEST_SIZE, p);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
 
 int
 pkcs1_rsa_sha1_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha1_prefix),
@@ -97,8 +104,12 @@ pkcs1_rsa_sha1_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
     {
       memcpy(p, digest, SHA1_DIGEST_SIZE);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
diff --git a/pkcs1-rsa-sha256.c b/pkcs1-rsa-sha256.c
index a4d5bb1..2fde45f 100644
--- a/pkcs1-rsa-sha256.c
+++ b/pkcs1-rsa-sha256.c
@@ -34,6 +34,7 @@
 #include "rsa.h"
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "pkcs1.h"
 
 #include "nettle-internal.h"
@@ -63,8 +64,9 @@ int
 pkcs1_rsa_sha256_encode(mpz_t m, size_t key_size, struct sha256_ctx *hash)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha256_prefix),
@@ -74,18 +76,23 @@ pkcs1_rsa_sha256_encode(mpz_t m, size_t key_size, struct sha256_ctx *hash)
     {
       sha256_digest(hash, SHA256_DIGEST_SIZE, p);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;	
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
 
 int
 pkcs1_rsa_sha256_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha256_prefix),
@@ -95,8 +102,12 @@ pkcs1_rsa_sha256_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
     {
       memcpy(p, digest, SHA256_DIGEST_SIZE);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
diff --git a/pkcs1-rsa-sha512.c b/pkcs1-rsa-sha512.c
index 03acb69..078851d 100644
--- a/pkcs1-rsa-sha512.c
+++ b/pkcs1-rsa-sha512.c
@@ -34,6 +34,7 @@
 #include "rsa.h"
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "pkcs1.h"
 
 #include "nettle-internal.h"
@@ -63,8 +64,9 @@ int
 pkcs1_rsa_sha512_encode(mpz_t m, size_t key_size, struct sha512_ctx *hash)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha512_prefix),
@@ -74,18 +76,23 @@ pkcs1_rsa_sha512_encode(mpz_t m, size_t key_size, struct sha512_ctx *hash)
     {
       sha512_digest(hash, SHA512_DIGEST_SIZE, p);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
 
 int
 pkcs1_rsa_sha512_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha512_prefix),
@@ -95,8 +102,12 @@ pkcs1_rsa_sha512_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
     {
       memcpy(p, digest, SHA512_DIGEST_SIZE);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
-- 
1.8.4.2



</body></email><email><emailId>20131213103327</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-13 10:33:27-0400</timestampReceived><subject>Re: TMP_ALLOC and size_t change</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; What about the attached patch?

Looks good! Some minor comments:

--- /dev/null
+++ b/bignum-internal.h

&gt; +inline static void* _tmp_gmp_alloc(unsigned* out_n, size_t n)

&gt; +inline static void _tmp_gmp_free(void* p, size_t n)

I don't think the _tmp prefix is needed, since these are declared
static.

Do you think it's important that these are inline functions? The
alternative is to put them in gmp-glue.c together with with
gmp_{alloc,free}_limbs, and then the TMP_GMP_*-macros could go in
nettle-internal.h.

&gt; +#define TMP_GMP_DECL(name, type) type *name; \
&gt; +	unsigned name##_gmp_size

Here, on the other hand, it might make sense with a prefix on the size
variable. Maybe __tmp_gmp_size##name or so (I tend to use __{NAME OF
MACRO}_ as prefix).

&gt; diff --git a/pkcs1-decrypt.c b/pkcs1-decrypt.c
&gt; index 02d3728..96016e0 100644
&gt; --- a/pkcs1-decrypt.c
&gt; +++ b/pkcs1-decrypt.c

&gt;    if (*length &lt; message_length)
&gt; -    return 0;
&gt; +    {
&gt; +      ret = 0;
&gt; +      goto err;
&gt; +    }
&gt;    
&gt;    memcpy(message, terminator + 1, message_length);
&gt;    *length = message_length;
&gt;  
&gt; -  return 1;
&gt; +  ret = 1;
&gt; +err:
&gt; +  TMP_GMP_FREE(em);
&gt; +  return ret;
&gt;  }

"err" is maybe not the right name for the label, since the code is also
for successful termination. "done" or "cleanup" would be better.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131213132311</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-12-13 13:23:11-0400</timestampReceived><subject>Re: TMP_ALLOC and size_t change</subject><body>

On Fri, Dec 13, 2013 at 11:33 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt;
&gt;&gt; What about the attached patch?
&gt; Looks good! Some minor comments:

updated.

regards,
Nikos

["0001-Introduced-TMP_GMP_ALLOC-macro-for-temporary-allocat.patch" (text/x-patch)]

From 87a82925c955024c1b20e45a810cc252170842c4 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Fri, 13 Dec 2013 10:58:30 +0100
Subject: [PATCH] Introduced TMP_GMP_ALLOC macro for temporary allocations of
 potentially large data.

This prevents big data allocations on stack by using TMP_GMP_ALLOC in places
where TMP_ALLOC was called with potentially large data size.
---
 Makefile.in         |  2 +-
 bignum-internal.h   | 36 ++++++++++++++++++++++++++++++++++++
 bignum-next-prime.c |  8 +++++---
 bignum-random.c     |  9 ++++++---
 gmp-glue.c          | 21 +++++++++++++++++++++
 gmp-glue.h          |  4 ++++
 pkcs1-decrypt.c     | 31 ++++++++++++++++++++++++-------
 pkcs1-encrypt.c     |  7 +++++--
 pkcs1-rsa-digest.c  | 12 +++++++++---
 pkcs1-rsa-md5.c     | 23 +++++++++++++++++------
 pkcs1-rsa-sha1.c    | 23 +++++++++++++++++------
 pkcs1-rsa-sha256.c  | 23 +++++++++++++++++------
 pkcs1-rsa-sha512.c  | 23 +++++++++++++++++------
 13 files changed, 179 insertions(+), 43 deletions(-)
 create mode 100644 bignum-internal.h

diff --git a/Makefile.in b/Makefile.in
index 05e6ade..39274df 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -182,7 +182,7 @@ DISTFILES = $(SOURCES) $(HEADERS) getopt.h .bootstrap run-tests \
 	cast128_sboxes.h desinfo.h desCode.h \
 	nettle-internal.h nettle-write.h prime-list.h \
 	gmp-glue.h ecc-internal.h \
-	mini-gmp.h mini-gmp.c asm.m4 \
+	mini-gmp.h mini-gmp.c asm.m4 bignum-internal.h \
 	nettle.texinfo nettle.info nettle.html nettle.pdf sha-example.c
 
 # Rules building static libraries
diff --git a/bignum-internal.h b/bignum-internal.h
new file mode 100644
index 0000000..26a7cdb
--- /dev/null
+++ b/bignum-internal.h
@@ -0,0 +1,36 @@
+/* bignum-internal.h
+ *
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Red Hat
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#ifndef BIGNUM_INTERNAL_H
+# define BIGNUM_INTERNAL_H
+
+#include &lt;gmp-glue.h&gt;
+
+#define TMP_GMP_DECL(name, type) type *name; \
+	unsigned tmp_##name##_size
+#define TMP_GMP_ALLOC(name, size) \
+	(name = gmp_alloc(&amp;tmp_##name##_size, sizeof (*name) * (size)))
+#define TMP_GMP_FREE(name) (gmp_free(name, tmp_##name##_size))
+
+#endif
diff --git a/bignum-next-prime.c b/bignum-next-prime.c
index 58a4df8..bc89399 100644
--- a/bignum-next-prime.c
+++ b/bignum-next-prime.c
@@ -31,6 +31,7 @@
 #include &lt;stdlib.h&gt;
 
 #include "bignum.h"
+#include "bignum-internal.h"
 
 #include "nettle-internal.h"
 
@@ -77,9 +78,8 @@ nettle_next_prime(mpz_t p, mpz_t n, unsigned count, unsigned prime_limit,
 		  void *progress_ctx, nettle_progress_func *progress)
 {
   mpz_t tmp;
-  TMP_DECL(moduli, unsigned, NUMBER_OF_PRIMES);
-  
   unsigned difference;
+  TMP_GMP_DECL(moduli, unsigned);
 
   if (prime_limit &gt; NUMBER_OF_PRIMES)
     prime_limit = NUMBER_OF_PRIMES;
@@ -112,7 +112,8 @@ nettle_next_prime(mpz_t p, mpz_t n, unsigned count, unsigned prime_limit,
      between the 5760 odd numbers in this interval that have no factor
      in common with 15015.
    */
-  TMP_ALLOC(moduli, prime_limit);
+  TMP_GMP_ALLOC(moduli, prime_limit);
+
   {
     unsigned i;
     for (i = 0; i &lt; prime_limit; i++)
@@ -159,4 +160,5 @@ nettle_next_prime(mpz_t p, mpz_t n, unsigned count, unsigned prime_limit,
 #endif
     }
   mpz_clear(tmp);
+  TMP_GMP_FREE(moduli);
 }
diff --git a/bignum-random.c b/bignum-random.c
index f305f04..07ae1ba 100644
--- a/bignum-random.c
+++ b/bignum-random.c
@@ -30,6 +30,7 @@
 #include &lt;stdlib.h&gt;
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "nettle-internal.h"
 
 void
@@ -38,15 +39,17 @@ nettle_mpz_random_size(mpz_t x,
 		       unsigned bits)
 {
   unsigned length = (bits + 7) / 8;
-  TMP_DECL(data, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(data, length);
+  TMP_GMP_DECL(data, uint8_t);
 
-  random(ctx, length, data);
+  TMP_GMP_ALLOC(data, length);
 
+  random(ctx, length, data);
   nettle_mpz_set_str_256_u(x, length, data);
 
   if (bits % 8)
     mpz_fdiv_r_2exp(x, x, bits);
+  
+  TMP_GMP_FREE(data);
 }
 
 /* Returns a random number x, 0 &lt;= x &lt; n */
diff --git a/gmp-glue.c b/gmp-glue.c
index a2633a5..991e793 100644
--- a/gmp-glue.c
+++ b/gmp-glue.c
@@ -239,3 +239,24 @@ gmp_free_limbs (mp_limb_t *p, mp_size_t n)
 
   free_func (p, (size_t) n * sizeof(mp_limb_t));
 }
+
+void* gmp_alloc(unsigned* out_n, size_t n)
+{
+	void *(*alloc_func)(size_t);
+	assert (n &gt; 0);
+
+	mp_get_memory_functions(&amp;alloc_func, NULL, NULL);
+	
+	*out_n = n;
+	return alloc_func (n);
+}
+
+void gmp_free(void* p, size_t n)
+{
+  void (*free_func)(void *, size_t);
+  assert (n &gt; 0);
+  assert (p != 0);
+  mp_get_memory_functions (NULL, NULL, &amp;free_func);
+
+  free_func (p, (size_t) n);
+}
diff --git a/gmp-glue.h b/gmp-glue.h
index 269667f..ff936a1 100644
--- a/gmp-glue.h
+++ b/gmp-glue.h
@@ -65,6 +65,8 @@
 #define mpn_set_base256 _nettle_mpn_set_base256
 #define gmp_alloc_limbs _nettle_gmp_alloc_limbs
 #define gmp_free_limbs _nettle_gmp_free_limbs
+#define gmp_free _nettle_gmp_free
+#define gmp_alloc _nettle_gmp_alloc
 
 /* Use only in-place operations, so we can fall back to addmul_1/submul_1 */
 #ifdef mpn_cnd_add_n
@@ -155,5 +157,7 @@ gmp_alloc_limbs (mp_size_t n);
 void
 gmp_free_limbs (mp_limb_t *p, mp_size_t n);
 
+void* gmp_alloc(unsigned* out_n, size_t n);
+void gmp_free(void* p, size_t n);
 
 #endif /* NETTLE_GMP_GLUE_H_INCLUDED */
diff --git a/pkcs1-decrypt.c b/pkcs1-decrypt.c
index 02d3728..71bd663 100644
--- a/pkcs1-decrypt.c
+++ b/pkcs1-decrypt.c
@@ -31,6 +31,7 @@
 #include "pkcs1.h"
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "nettle-internal.h"
 
 int
@@ -38,35 +39,51 @@ pkcs1_decrypt (size_t key_size,
 	       const mpz_t m,
 	       size_t *length, uint8_t *message)
 {
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
+  TMP_GMP_DECL(em, uint8_t);
   uint8_t *terminator;
   size_t padding;
   size_t message_length;
+  int ret;
 
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_ALLOC(em, key_size);
   nettle_mpz_get_str_256(key_size, em, m);
 
   /* Check format */
   if (em[0] || em[1] != 2)
-    return 0;
+    {
+      ret = 0;
+      goto cleanup;
+    }
 
   terminator = memchr(em + 2, 0, key_size - 2);
 
   if (!terminator)
-    return 0;
+    {
+      ret = 0;
+      goto cleanup;
+    }
   
   padding = terminator - (em + 2);
   if (padding &lt; 8)
-    return 0;
+    {
+      ret = 0;
+      goto cleanup;
+    }
 
   message_length = key_size - 3 - padding;
 
   if (*length &lt; message_length)
-    return 0;
+    {
+      ret = 0;
+      goto cleanup;
+    }
   
   memcpy(message, terminator + 1, message_length);
   *length = message_length;
 
-  return 1;
+  ret = 1;
+cleanup:
+  TMP_GMP_FREE(em);
+  return ret;
 }
 	       
diff --git a/pkcs1-encrypt.c b/pkcs1-encrypt.c
index 69ef5bc..9f34343 100644
--- a/pkcs1-encrypt.c
+++ b/pkcs1-encrypt.c
@@ -34,6 +34,7 @@
 #include "pkcs1.h"
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "nettle-internal.h"
 
 int
@@ -43,7 +44,7 @@ pkcs1_encrypt (size_t key_size,
 	       size_t length, const uint8_t *message,
 	       mpz_t m)
 {
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
+  TMP_GMP_DECL(em, uint8_t);
   size_t padding;
   size_t i;
 
@@ -63,7 +64,7 @@ pkcs1_encrypt (size_t key_size,
   padding = key_size - length - 3;
   assert(padding &gt;= 8);
   
-  TMP_ALLOC(em, key_size - 1);
+  TMP_GMP_ALLOC(em, key_size - 1);
   em[0] = 2;
 
   random(random_ctx, padding, em + 1);
@@ -77,5 +78,7 @@ pkcs1_encrypt (size_t key_size,
   memcpy(em + padding + 2, message, length);
 
   nettle_mpz_set_str_256_u(m, key_size - 1, em);
+  
+  TMP_GMP_FREE(em);
   return 1;
 }
diff --git a/pkcs1-rsa-digest.c b/pkcs1-rsa-digest.c
index debfb28..5f348ae 100644
--- a/pkcs1-rsa-digest.c
+++ b/pkcs1-rsa-digest.c
@@ -29,21 +29,27 @@
 #include "pkcs1.h"
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "nettle-internal.h"
 
 int
 pkcs1_rsa_digest_encode(mpz_t m, size_t key_size,
 			size_t di_length, const uint8_t *digest_info)
 {
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   if (_pkcs1_signature_prefix(key_size, em,
 			      di_length, digest_info, 0))
     {
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
diff --git a/pkcs1-rsa-md5.c b/pkcs1-rsa-md5.c
index b118b4f..87b423a 100644
--- a/pkcs1-rsa-md5.c
+++ b/pkcs1-rsa-md5.c
@@ -34,6 +34,7 @@
 #include "rsa.h"
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "pkcs1.h"
 
 #include "nettle-internal.h"
@@ -65,8 +66,9 @@ int
 pkcs1_rsa_md5_encode(mpz_t m, size_t key_size, struct md5_ctx *hash)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(md5_prefix),
@@ -76,18 +78,23 @@ pkcs1_rsa_md5_encode(mpz_t m, size_t key_size, struct md5_ctx *hash)
     {
       md5_digest(hash, MD5_DIGEST_SIZE, p);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
 
 int
 pkcs1_rsa_md5_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(md5_prefix),
@@ -97,8 +104,12 @@ pkcs1_rsa_md5_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
     {
       memcpy(p, digest, MD5_DIGEST_SIZE);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
diff --git a/pkcs1-rsa-sha1.c b/pkcs1-rsa-sha1.c
index 781d75d..84ebb4c 100644
--- a/pkcs1-rsa-sha1.c
+++ b/pkcs1-rsa-sha1.c
@@ -34,6 +34,7 @@
 #include "rsa.h"
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "pkcs1.h"
 
 #include "nettle-internal.h"
@@ -65,8 +66,9 @@ int
 pkcs1_rsa_sha1_encode(mpz_t m, size_t key_size, struct sha1_ctx *hash)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha1_prefix),
@@ -76,18 +78,23 @@ pkcs1_rsa_sha1_encode(mpz_t m, size_t key_size, struct sha1_ctx *hash)
     {
       sha1_digest(hash, SHA1_DIGEST_SIZE, p);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
 
 int
 pkcs1_rsa_sha1_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha1_prefix),
@@ -97,8 +104,12 @@ pkcs1_rsa_sha1_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
     {
       memcpy(p, digest, SHA1_DIGEST_SIZE);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
diff --git a/pkcs1-rsa-sha256.c b/pkcs1-rsa-sha256.c
index a4d5bb1..2fde45f 100644
--- a/pkcs1-rsa-sha256.c
+++ b/pkcs1-rsa-sha256.c
@@ -34,6 +34,7 @@
 #include "rsa.h"
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "pkcs1.h"
 
 #include "nettle-internal.h"
@@ -63,8 +64,9 @@ int
 pkcs1_rsa_sha256_encode(mpz_t m, size_t key_size, struct sha256_ctx *hash)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha256_prefix),
@@ -74,18 +76,23 @@ pkcs1_rsa_sha256_encode(mpz_t m, size_t key_size, struct sha256_ctx *hash)
     {
       sha256_digest(hash, SHA256_DIGEST_SIZE, p);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;	
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
 
 int
 pkcs1_rsa_sha256_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha256_prefix),
@@ -95,8 +102,12 @@ pkcs1_rsa_sha256_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
     {
       memcpy(p, digest, SHA256_DIGEST_SIZE);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
diff --git a/pkcs1-rsa-sha512.c b/pkcs1-rsa-sha512.c
index 03acb69..078851d 100644
--- a/pkcs1-rsa-sha512.c
+++ b/pkcs1-rsa-sha512.c
@@ -34,6 +34,7 @@
 #include "rsa.h"
 
 #include "bignum.h"
+#include "bignum-internal.h"
 #include "pkcs1.h"
 
 #include "nettle-internal.h"
@@ -63,8 +64,9 @@ int
 pkcs1_rsa_sha512_encode(mpz_t m, size_t key_size, struct sha512_ctx *hash)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha512_prefix),
@@ -74,18 +76,23 @@ pkcs1_rsa_sha512_encode(mpz_t m, size_t key_size, struct sha512_ctx *hash)
     {
       sha512_digest(hash, SHA512_DIGEST_SIZE, p);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
 
 int
 pkcs1_rsa_sha512_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
 {
   uint8_t *p;
-  TMP_DECL(em, uint8_t, NETTLE_MAX_BIGNUM_SIZE);
-  TMP_ALLOC(em, key_size);
+  TMP_GMP_DECL(em, uint8_t);
+
+  TMP_GMP_ALLOC(em, key_size);
 
   p = _pkcs1_signature_prefix(key_size, em,
 			      sizeof(sha512_prefix),
@@ -95,8 +102,12 @@ pkcs1_rsa_sha512_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)
     {
       memcpy(p, digest, SHA512_DIGEST_SIZE);
       nettle_mpz_set_str_256_u(m, key_size, em);
+      TMP_GMP_FREE(em);
       return 1;
     }
   else
-    return 0;
+    {
+      TMP_GMP_FREE(em);
+      return 0;
+    }
 }
-- 
1.8.4.2


["0002-Added-changelog-entry.patch" (text/x-patch)]

From 249e09f27648d96f331e23c62d2961ff2d71e0c9 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Fri, 13 Dec 2013 14:20:46 +0100
Subject: [PATCH 2/2] Added changelog entry

---
 ChangeLog | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/ChangeLog b/ChangeLog
index e3ad66b..c9d3eb2 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,10 @@
+2013-12-13  Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
+
+	* Introduced TMP_GMP_ALLOC macro for temporary allocations of
+	potentially large data.  This prevents big data allocations on stack 
+        by using TMP_GMP_ALLOC in places where TMP_ALLOC was called with 
+        potentially large data size.
+
 2013-12-03  Niels Möller  &lt;nisse@lysator.liu.se&gt;
 
 	* x86_64/sha1-compress.asm: Reorganized, to get closer to the x86
-- 
1.8.4.2



</body></email><email><emailId>20131215181906</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-15 18:19:06-0400</timestampReceived><subject>Re: TMP_ALLOC and size_t change</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; updated.

Checked in now, with minor changes (deleted the out_n argument for
gmp_alloc, and moved the TMP_GMP_* macros to gmp-glue.h).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131217074242</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-12-17 07:42:42-0400</timestampReceived><subject>Re: TMP_ALLOC and size_t change</subject><body>


On Sun, 2013-12-15 at 19:19 +0100, Niels Möller wrote:

&gt; Checked in now, with minor changes (deleted the out_n argument for
&gt; gmp_alloc, and moved the TMP_GMP_* macros to gmp-glue.h).

Would that be included in a 2.7 release?






</body></email><email><emailId>20131217075705</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-17 07:57:05-0400</timestampReceived><subject>Re: TMP_ALLOC and size_t change</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; On Sun, 2013-12-15 at 19:19 +0100, Niels Möller wrote:
&gt;
&gt;&gt; Checked in now, with minor changes (deleted the out_n argument for
&gt;&gt; gmp_alloc, and moved the TMP_GMP_* macros to gmp-glue.h).
&gt;
&gt; Would that be included in a 2.7 release?

I don't currently plan any 2.7.2 bugfix release. I'm thinking that this
problem is not serious enough to motivate a new release. If some more
urgent reason to make a release comes up, we can consider backporting
this change.

Or have you seen any real problems caused by this? That would be an
application accepting an arbitrarily large RSA keys from an untrusted
source, and passing it on to nettle without any limit to prevent DoS. In
that scenario, it could be a real problem.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131211221008</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-11 22:10:08-0400</timestampReceived><subject>Re: ChaCha stream cipher for Nettle available</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; I've taken a shot at implementing the ChaCha stream cipher for Nettle.
&gt; Nettle is a modified version of Salsa20 done by DJB in order to improve
&gt; both performance (esp on CPUs with support for data parallelism) and
&gt; somewhat improved performance.

Cool! I looked briefly at ChaCha last time I worked on salsa20. I
understand it has potential to be a bit faster than salsa20, so it will
be interesting to see how that turns out.

&gt; This implementation also supports different number of rounds.

Which variants are recommended, or in real use? 20 and 12, just like for
salsa20?

&gt; ChaCha _should_ be a bit faster than Salsa20 and should esp be easier to
&gt; optimize in asm for modern CPUs. I have however not done any benchmarks
&gt; nor asm implementation (yet).

Adding chacha benchmarking in examples/nettle-benchmark should be easy.

And if you like playing with either x86_64 sse2 (ugly) or arm neon
(nicer), I think it's a not too difficult exercise to implement chacha
based on the salsa20 assembly files (in the x86_64 and arm/neon
directories).

&gt; Since I'm new as a contributor I don't know how you Niels want to have
&gt; patches. Please let me know if this looks good and something you want to
&gt; integrate and if so how.

I'm used to patches on the mailing list (I still feel a bit like a git
newbie. I could also pull changes from a repository of yours, but I'd
prefer a mailed patch unless I'm confident I want to integrate the work
directly with no changes). An ideal patch set for chacha would include

* The implementation, more or less what you have now,

* A const struct nettle_cipher defined in chacha-meta.c, for each
  important variant (number of rounds and key size)

* A testcase following the conventions of the testsuite/*-c files.

* Integration in examples/nettle-benchmark.c (should be trivial). (Both
  benchmark and testcode would use the chacha-meta glue).

* Documentation for nettle.texinfo (but maybe that should wait until
  interface has settled).

* GNU-style ChangeLog entries for each change.

Preferably arranged so that independent changes (C implementation, docs,
assembly implementation) can be applied one at a time. This is a wish
list, to make integration quick and easy, but you don't have to get
everything in order for the contribution to be useful.

I've only had a quick look at the actual code now, but my first
impression is that it looks pretty good. I think I'd prefer to not have
the number of rounds in the context, though, and instead have separate
functions for different variants, possibly calling a common function
taking the number of rounds as argument.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131212090614</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-12 09:06:14-0400</timestampReceived><subject>Re: ChaCha stream cipher for Nettle available</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Niels Möller wrote:
&gt; Which variants are recommended, or in real use? 20 and 12, just like
&gt; for salsa20?

DJB does not state anything about recommended number of rounds but 8 i
bare minimum. Both Adam Langley and we use 20 rounds:

http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-00

http://tools.ietf.org/html/draft-mavrogiannopoulos-chacha-tls-00

I assume that 12 is today the lower limit. But being able to use
something in between 12 and 20, or more than 20 is good (imgho)


&gt; Adding chacha benchmarking in examples/nettle-benchmark should be
&gt; easy.

Ok, I'll look at that.


&gt; I'm used to patches on the mailing list (I still feel a bit like a
&gt; git newbie. I could also pull changes from a repository of yours, but
&gt; I'd prefer a mailed patch unless I'm confident I want to integrate
&gt; the work directly with no changes). An ideal patch set for chacha
&gt; would include

I haven't worked that much with Gitorios and esp not the one at Lysator.
But Git and es Github supports good mechanism for an owner/integrator
such as you to receive merge requests from downstream clones, test them
as branches and then decided if to include them as a whole or cherry pick.

I've used Gitorious before but really think Github is a much better
service. This might be a stupid question but have you considered to move
Nettle to Github? It would I assume get more exposure and probably more
contributions. If that is what you want. ;-)


[list of deliverables]
&gt; Preferably arranged so that independent changes (C implementation,
&gt; docs, assembly implementation) can be applied one at a time. This is
&gt; a wish list, to make integration quick and easy, but you don't have
&gt; to get everything in order for the contribution to be useful.

I'll try and get them done for you hopefully this week. A lot of peeking
at previous paytches in the maillist archive and stealint/borrowing from
other code (salsa20) should help me out. If not I'll post on the list.


&gt; I've only had a quick look at the actual code now, but my first 
&gt; impression is that it looks pretty good. I think I'd prefer to not
&gt; have the number of rounds in the context, though, and instead have
&gt; separate functions for different variants, possibly calling a common
&gt; function taking the number of rounds as argument.

I can agree that the number of rounds is not really something to keep in
the context. But I think that the solution of having the number of
rounds fixed and having separate functions for the different versions is
pretty ugly and inflexible.

I can see the need for applications to easily and dynamically change
from 12 to 14 rounds by simply updating a variable, possibly even a
loadable value instead of changing the code forcing a recompile.

The salsa20 implementation does not come with different function calls
for 128 and 256 bit keys. Instead the length is given as a parameter. I
don't see the number of rounds being that much different.

I suggest that the chacha_crypt function is accepting number of rounds
as a parameter. You can then if you want add specific named functions
that wrap this function. But the user can always call the base function
and change the number of rounds for each message (if needed). Sounds ok?

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKpfIYACgkQZoPr8HT30QGfgACghZ+gzAR/X4+jO72b9eAN2N5Z
fK8An0JKSSJAyVGN0EjAN5W9IfYwy7bw
=kC3u
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131212103708</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-12 10:37:08-0400</timestampReceived><subject>Re: ChaCha stream cipher for Nettle available</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; I haven't worked that much with Gitorios and esp not the one at Lysator.
&gt; But Git and es Github supports good mechanism for an owner/integrator
&gt; such as you to receive merge requests from downstream clones, test them
&gt; as branches and then decided if to include them as a whole or cherry pick.

I've never really used the web stuff of either gitorious or github. If
you put up a repo I can pull from, I'll most likely add it as a remote
and fetch from it using the git command line tools.

&gt; I've used Gitorious before but really think Github is a much better
&gt; service. This might be a stupid question but have you considered to move
&gt; Nettle to Github? It would I assume get more exposure and probably more
&gt; contributions. If that is what you want. ;-)

As a GNU maintainer, I'd like to avoid depending on things which are
proprietary software, or software-as-a-service. But as long as github
does plain git, I can fetch changes from github repos if the need
arises.

&gt; I'll try and get them done for you hopefully this week. A lot of peeking
&gt; at previous paytches in the maillist archive and stealint/borrowing from
&gt; other code (salsa20) should help me out. If not I'll post on the list.

I look forward to that. I can't promise I'll be as quick with
integration, but hopefully I'll get some hacking time during the
Christmas break.

&gt; I can agree that the number of rounds is not really something to keep in
&gt; the context. But I think that the solution of having the number of
&gt; rounds fixed and having separate functions for the different versions is
&gt; pretty ugly and inflexible.

That's a judgement, of course. In nettle, I don't think it makes sense
to add flexibility for the sole purpose of convenient support for
obscure algorithms or settings. If a wider range of rounds gets used in
practice, we can reconsider this. With salsa 20, with only two variants
(12 or 20 rounds) in use, I don't think separate functions gets too
ugly.

&gt; I can see the need for applications to easily and dynamically change
&gt; from 12 to 14 rounds by simply updating a variable, possibly even a
&gt; loadable value instead of changing the code forcing a recompile.

That's not my experience. The typical crypto application has some
configuration or protocol handshake to select between aes128-ctr,
aes256-ctr, salsa20, salsa20r12, etc. For each choice, it needs some
logic to allocate the right context struct and call the right functions
(struct nettle_cipher is an example of a minimalistic framework to
collect that info).

Then, from the application's point of view, salsa20r12 is as different
from salsa20 as it is from aes128-ctr, none can be be substituted for the
other except via the algorithm selection procedures, and it really
doesn't matter which of the different algorithms are unified below that
algorithm-selection framework.

And the particular change from 12 to 14 might add significant complexity
to an optimized implementations with 4-way unrolling, so flexibility
isn't always as cheap as it looks.

&gt; The salsa20 implementation does not come with different function calls
&gt; for 128 and 256 bit keys. Instead the length is given as a parameter. I
&gt; don't see the number of rounds being that much different.

The difference is that the key size matters *only* for the set_key
function, there's no need to store it in the context struct.

And I think functions for specific would make a lot of sense also for
salsa20. In Nettle, passing a key size as argument to the set_key
functions used to be the norm, with a few exceptions for single key size
algorithms like DES. But I'm now reconsidering that design. Today, I
think a set_key function with a key_size parameter is appropriate only
for algorithms which support more or less arbitrary keysizes. When only
two or three discrete key sizes are specified, I prefer to view them as
distict algorithms. In particular, I prefer that view if the keysetup
really uses different logic for the different key sizes.

&gt; I suggest that the chacha_crypt function is accepting number of rounds
&gt; as a parameter. You can then if you want add specific named functions
&gt; that wrap this function.

That's a perfectly valid implementation choice to me. A similar function
for sala20 has been discussed earlier. We might need to think a bit
about naming. And the wrapper functions are necessary, for nettle_cipher
if nothing else.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131212114246</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2013-12-12 11:42:46-0400</timestampReceived><subject>Re: ChaCha stream cipher for Nettle available</subject><body>

You wrote:

&gt; &gt; I can see the need for applications to easily and dynamically change
&gt; &gt; from 12 to 14 rounds by simply updating a variable, possibly even a
&gt; &gt; loadable value instead of changing the code forcing a recompile.
&gt; 
&gt; That's not my experience. The typical crypto application has some
&gt; configuration or protocol handshake to select between aes128-ctr,
&gt; aes256-ctr, salsa20, salsa20r12, etc. For each choice, it needs some
&gt; logic to allocate the right context struct and call the right
&gt; functions (struct nettle_cipher is an example of a minimalistic
&gt; framework to collect that info).
&gt; 
&gt; Then, from the application's point of view, salsa20r12 is as different
&gt; from salsa20 as it is from aes128-ctr, none can be be substituted for
&gt; the other except via the algorithm selection procedures, and it really
&gt; doesn't matter which of the different algorithms are unified below
&gt; that algorithm-selection framework.
&gt; 
&gt; And the particular change from 12 to 14 might add significant
&gt; complexity to an optimized implementations with 4-way unrolling, so
&gt; flexibility isn't always as cheap as it looks.

I agree -- please just add 20 rounds ChaCha initially.

I am beginning to think that the introducing the 12 rounds Salsa20 was
a really bad/harmful outcome of eSTREAM, as it leads to all these
discussions around number of rounds to support, which slows adoption.
The speed of 20 rounds Salsa20 and ChaCha is high. If speed is more
important than security for someone, I've heard of this nice cipher
called ROT13 that we could probably implement very efficiently.

/Simon

</body></email><email><emailId>20131212133436</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-12 13:34:36-0400</timestampReceived><subject>Re: ChaCha stream cipher for Nettle available</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Simon Josefsson wrote:
&gt; I agree -- please just add 20 rounds ChaCha initially.

I've added specific functions for 12 and 20 rounds.

&gt; I've heard of this nice cipher called ROT13 that we could probably
&gt; implement very efficiently.

Now, now, lets try and stay focused on security here - everybody knows
that you always should two rounds of ROT13. Please add rot13r2 patch.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKpu2wACgkQZoPr8HT30QGusACg6exsI6Oej+C4jnF1ScVcW9MH
c6oAoJmnGpefqd4jMwJgQU3xtmYM6cus
=eL9O
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131212133728</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-12 13:37:28-0400</timestampReceived><subject>Re: ChaCha stream cipher for Nettle available</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Niels Möller wrote:
&gt; * A const struct nettle_cipher defined in chacha-meta.c, for each 
&gt; important variant (number of rounds and key size)

Can't seem to find a similar meta file for salsa20. I'm looking at the
the arcfour-meta and the twofish-meta where the latter seems easier to
grokk.


- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKpvBgACgkQZoPr8HT30QHIrwCgpthT0kw/fOUcNr0kDySsSieW
GbkAoPMFJ9jfaFIbgXTQwuteL/WoI5yx
=w4gz
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131212144834</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-12 14:48:34-0400</timestampReceived><subject>Re: ChaCha stream cipher for Nettle available</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; Can't seem to find a similar meta file for salsa20. I'm looking at the
&gt; the arcfour-meta and the twofish-meta where the latter seems easier to
&gt; grokk.

Ah, it's hidden in nettle-internal.c (which is used by testcases and
benchmark only). That's because the nettle_cipher abstraction lacks a
mechanism to set the iv, which is essential for salsa20.

I think we ought to introduce something slightly different than
nettle_cipher for stream ciphers.

And if you find the _NETTLE_CIPHER* macros confusing, you don't need to
use them.


Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131212204225</emailId><senderName>James Cloos</senderName><senderEmail>cloos@jhcloos.com</senderEmail><timestampReceived>2013-12-12 20:42:25-0400</timestampReceived><subject>Re: ChaCha stream cipher for Nettle available</subject><body>

&gt;&gt;&gt;&gt;&gt; "SJ" == Simon Josefsson &lt;simon@josefsson.org&gt; writes:

SJ&gt; The speed of 20 rounds Salsa20 and ChaCha is high.

To give an example of how high, openssh's C implementation of chacha20
with poly1305 is faster than openssl's non-aesni amd64 assembly for
aes128-gcm, and both significantly outperform ssh's use of openssl's
aes128-ctr or -ccb assembly with openssh's umac-64.

On top of that, the sse2 assembly code for chacha20 at:

  https://github.com/floodyberry/chacha-opt

is 3-4 times as fast as pure C, and the avx and avx2 assembly is about
50% faster still.

All for a cipher which is inherently easier securely to code than gcm
and, like gcm, safer than most current usage of separate macs.
(Given the various known attacks on TLS and the widely repeated
statements that gcm is hard to code w/o timing leaks, et alia.)

-JimC
--
James Cloos &lt;cloos@jhcloos.com&gt;         OpenPGP: 1024D/ED7DAEA6

</body></email><email><emailId>20131213072720</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-13 07:27:20-0400</timestampReceived><subject>Re: ChaCha stream cipher for Nettle available</subject><body>

James Cloos &lt;cloos@jhcloos.com&gt; writes:

&gt; To give an example of how high, openssh's C implementation of chacha20
&gt; with poly1305 is faster than openssl's non-aesni amd64 assembly for
&gt; aes128-gcm, and both significantly outperform ssh's use of openssl's
&gt; aes128-ctr or -ccb assembly with openssh's umac-64.

Benchmarking nettle's implementation on my office machine (core i5),

algorithm	cycles/byte
salsa20		5.3
aes128		11
aes128		22 (openssl)
arcfour		7.5
arcfour		3.75 (openssl)

(For aes, I'm surprised by the big difference to openssl. Nettle's aes
assembly is pretty basic, and on this machine it seems to give a very
marginal improvement over the C implementation, which runs at 12
cycles/byte. Maybe something is fishy with the ubuntu openssl package,
or there's some problem with my benchmarking).

Anyway, getting back to chacha, it will be interesting to see how much
faster chacha is than salsa20.

If I remember the chacha changes correctly, one gets rid of a
permutation of the matrix, and I think some of the rotations in the
round function (done as movaps, pslld, psrld, pxor) can be replaced by a
pshufd. I think that can reduce the instruction count for the round
function by 25-50%, depending on how many of the rotations can be
replaced (there ought to be at least one rotation left with a rotation
count which isn't a multiple of 8).

&gt; like gcm, safer than most current usage of separate macs.

Are you saying that chacha + poly1305 is not used in the obvious way as
a stream cipher + a separate mac? Care to elaborate?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131213081054</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-13 08:10:54-0400</timestampReceived><subject>Re: ChaCha stream cipher for Nettle available</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Niels Möller wrote:
&gt; Benchmarking nettle's implementation on my office machine (core i5),
&gt; 
&gt; algorithm	cycles/byte salsa20		5.3 aes128		11 aes128		22 (openssl) 
&gt; arcfour		7.5 arcfour		3.75 (openssl)

Side issue: Pretty big difference in performance also for arcfour.


&gt; Anyway, getting back to chacha, it will be interesting to see how
&gt; much faster chacha is than salsa20.

DJB and some other benchmarks shows anything from zero to 30% better
performance. The chacha paper states some ideas about the difference in
parallelability.


&gt; If I remember the chacha changes correctly, one gets rid of a 
&gt; permutation of the matrix, and I think some of the rotations in the 
&gt; round function (done as movaps, pslld, psrld, pxor) can be replaced
&gt; by a pshufd. I think that can reduce the instruction count for the
&gt; round function by 25-50%, depending on how many of the rotations can
&gt; be replaced (there ought to be at least one rotation left with a
&gt; rotation count which isn't a multiple of 8).

The big difference is that you update the variables in a QR twice during
the QR processing, but the QR is more regular and can easily (easier) be
scheduled with fewer register active in a given cycle.

The DR processing is more regular to allow easier parallelism. The tight
spot is between QR3 and QR4 where x15 is used in both. Otherwise it is
really the 4 separate QRs in each half of the DR that provides parallelism.

This is why I got a bit curious when you Niels stated: "And the
particular change from 12 to 14 might add significant complexity
to an optimized implementations with 4-way unrolling"

If we constrain ourselves to an even number of rounds I have a bit of a
problem to see how that would add significant complexity since we still
will be doing the DR processing the same way. I guess I'm missing
something, but I have spent some time doodling and thinking on the
dependency constraints in ChaCha since I've done a HW implementation:

https://github.com/secworks/swchacha

The current implementation does only contain a single QR, but will be
extended with support for 2 and 4 parallel QRs. There is a good paper
[0] on HW implementation of Salsa20 and ChaCha that shows depencency
within the QR. Looking at the clock frequency achieved one can clearly
see when the dependency between QR3 and QR4 happens.

Oh, and in that paper Salsa20 is actually neck and neck with or slightly
faster than ChaCha. ;-)


[0] L. Henzen, F. Carbognani, N. Felber, and W. Fichtner. VLSI Hardware
Evaluation of the Stream Ciphers Salsa20 and ChaCha, and the Compression
Function Rumba.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKqwQ0ACgkQZoPr8HT30QFC6ACfcp5RTbFmIPxgFBfuwQ9VlOvq
PKoAoJUE3pM/O/es3OWxR8J3pHheLhQt
=L3hD
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131213085346</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2013-12-13 08:53:46-0400</timestampReceived><subject>Re: ChaCha stream cipher for Nettle available</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

James Cloos wrote:
&gt; https://github.com/floodyberry/chacha-opt

Look Niels, it has number of rounds as part of the context! ;-)

(The usage and need is somewhat different though.)

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlKqyxoACgkQZoPr8HT30QFKoQCggH50y4ALPfMQL7fABSheaq//
suUAnRWkQnHgBl3sn+R0NqkHHAvOrKz8
=adUD
-----END PGP SIGNATURE-----

</body></email><email><emailId>20131213091816</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-13 09:18:16-0400</timestampReceived><subject>Re: ChaCha stream cipher for Nettle available</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; The big difference is that you update the variables in a QR twice during
&gt; the QR processing, but the QR is more regular and can easily (easier) be
&gt; scheduled with fewer register active in a given cycle.

Sounds like I have to look closer at the chacha spec to understand the
details.

&gt; This is why I got a bit curious when you Niels stated: "And the
&gt; particular change from 12 to 14 might add significant complexity
&gt; to an optimized implementations with 4-way unrolling"

There was no deep thought behind that comment. It's just that if an
assembly loop is unrolled 4 times, it simplifies the code if you can
assume that that the number of rounds you need is always divisible by 4.

Now, current salsa20 implementation don't do that, _salsa20_core seems
to support any even and non-zero number, for both C, x86_64 and arm
neon. And there's no obvious gain in doing more unrolling. Could
possibly make more sense for chacha, if each round is shorter in terms
of number of instructions, cycles, and dependencies.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131213093348</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-13 09:33:48-0400</timestampReceived><subject>Re: ChaCha stream cipher for Nettle available</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; Niels Möller wrote:
&gt;&gt; Benchmarking nettle's implementation on my office machine (core i5),
&gt;&gt;
&gt;&gt; algorithm	cycles/byte
&gt;&gt; arcfour		7.5
&gt;&gt; arcfour		3.75 (openssl)
&gt;
&gt; Side issue: Pretty big difference in performance also for arcfour.

Right, and this time in openssl's favour. I think that speed is quite
impressive. I haven't written any arcfour assembly for x86_64, but I
have tried earlied for x86 and sparc. It's a very serial loop doing one
byte at a time. It's tempting to try to do two bytes at a time, but the
easy way gives incorrect results when the i and j indices happen to
collide.

One approach I played a bit with was to nevertheless do two bytes at a
time, and then add some unlikely condition to detect collisions and fix
them. But I couldn't manage to make that fast.

An easier trick is to generate 4 or eight bytes of the keystream at a
time, collecting result in a register, so the xoring of the data can be
done a word at a time. The sparc implementation does something along
those lines, and at least does the data writes as aligned words.

But, I'd rather spend time on making salsa20 (and/or chacha) fast,
than optimizing arcfour.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131210075833</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-12-10 07:58:33-0400</timestampReceived><subject>Re: benchmarks</subject><body>

On Mon, Dec 9, 2013 at 9:48 PM, Werner Koch &lt;wk@gnupg.org&gt; wrote:

&gt;&gt; Could libgcrypt and nettle share the low level algorithms so
&gt;&gt; improvements on one project will be shared with the other? As it is now
&gt; Fell free to take whatever you need from Libgcrypt.

Of course that is possible, it always was. However, copying isn't easy
when different low-level interfaces are involved, and pretty much that
just prolongs the current situation.

&gt; They both you the
&gt; same license me thinks.

Only for the cipher/hash/mac part which was the part I suggested to be
shared. Nettle's PK interface is effectively LGPLv3 due to reliance on
GMP. So that part would be more hard to benefit from a sharing.

&gt;&gt; I think there is quite some duplicate effort being spent in making the
&gt;&gt; two libraries faster and there is no much reason they couldn't be
&gt;&gt; combined.
&gt; That is what free software is about, right?

Well, I really want to think that it is also about collaboration.
While I understand that everyone has a different agenda on the things
that need to be done, schedules etc., a compromise that will benefit
everyone may be possible.

regards,
Nikos

</body></email><email><emailId>20131210123919</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-12-10 12:39:19-0400</timestampReceived><subject>Re: benchmarks</subject><body>

On Tue, Dec 10, 2013 at 11:15 AM, Werner Koch &lt;wk@gnupg.org&gt; wrote:

&gt;&gt; Well, I really want to think that it is also about collaboration.
&gt; Right, I thought about the same lines but back then Niels decided to
&gt; compile his own library without the need to comply to the strict GNU
&gt; rules.  Thus he was able to use all kind of code while I was not.  A
&gt; decade or more ago I had to reject Brian Gladman's offer to use his code
&gt; due simply due to the CA requirement.  Latter then the GNU project seems
&gt; to have concluded that CAs are not important anymore unless they are
&gt; already in use.  The effect was that GNUTLS silently started to use
&gt; Nettle instead of helping to convince the GNU towers to drop the CA
&gt; requirement for Libgcrypt.

I thought that this was done quite vocally :) There was quite a long
discussion in this list about the issues I had back then, that if I
remember well were (a) libgcrypt could not be used in setuid
processes, and (b) that it was much slower -more than 2x- than openssl
(and nettle). The conclusion of that discussion was that libgcrypt
wouldn't change. I now understand that (b) was because you were
strictly following the gnu rules, but that provided no comfort to me
who was seeing gnutls being at the bottom of any benchmark. That's why
I switched to nettle and as it is now we are more than 2x faster
compared to openssl in public key operations.

&gt;&gt; While I understand that everyone has a different agenda on the things
&gt;&gt; that need to be done, schedules etc., a compromise that will benefit
&gt;&gt; everyone may be possible.
&gt; Well, you removed all support for Libgcrypt from GNUTLS.  If you want to
&gt; use it again, you only need to add that layer again.

I removed it because I changed the internal API and libgcrypt support
would be incomplete (gcm was missing at the time). I don't think it is
would be trivial to re-add, but it is not hard either. Nevertheless,
even if such a switch would be possible today, it would solve nothing,
as now we have some few parts that libgcrypt is better than nettle,
and other parts which nettle is better than libgcrypt. My
argumentation for the merging was with the intention to have the best
implementations of each library merged.

regards,
Nikos

</body></email><email><emailId>20131210140117</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-10 14:01:17-0400</timestampReceived><subject>Re: benchmarks</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;&gt;&gt; Well, I really want to think that it is also about collaboration.

&gt; On Tue, Dec 10, 2013 at 11:15 AM, Werner Koch &lt;wk@gnupg.org&gt; wrote:

&gt;&gt; Right, I thought about the same lines but back then Niels decided to
&gt;&gt; compile his own library without the need to comply to the strict GNU
&gt;&gt; rules.  Thus he was able to use all kind of code while I was not.

I'm sorry you feel like this. There are historic reasons (and the first
release of Nettle happened more than a decade ago). The code started as
the Pike cryptographic toolkit which I and Henrik Grubbström did in 1996
or so, we needed this to implement SSL for the Roxen webserver, which is
written in Pike (Henrik first wrote some glue to use openssl, or
"ssleay" as it was known back in the day, but we then decided to write
our own SSL implementation).

This was GPLd, but neither Pike nor Roxen are GNU projects, copyright
assignments were never considered. A few years later, 1998, I started on
LSH, and reused the low-level C code. Half a year later, LSH was dubbed
a GNU package, with no large changes to the way it was developed. No
copyright assignment policy was imposed at that time (and since I wasn't
the sole author, it wouldn't have been trivial).

Then Nettle was spun off from LSH in 2001. Time went by, and in 2009 it
was dubbed a GNU package on its own, despite concerns about duplication
with libgcrypt. Maybe I could have done some things differently back
then, but I can't feel particularly guilty.

So what about today? Is FSF copyright assignment important to you, and
lack of Nettle CA a main show stopper for using Nettle in any way? I'd
like to know the obstacles, technical or other.

It would be possible, although some amount of boring work, to transfer
most nettle copyrights to the FSF. I think I understand both the
advantages and disadvantages which come with FSF copyright assignment.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131227202617</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-27 20:26:17-0400</timestampReceived><subject>Re: memxor3 could lead to invalid mem accesses</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; It exits successfully but prints the valgrind warning (shown in the
&gt; previous message). 

Then I know what to expect.

&gt; Do you get a warning after applying the patch?

Haven't had time to try it yet.

I just had a look at x86_64/memxor.asm. As far as I see, it's written to
not read anything outside of the input buffers. Initial and final
portions are done with loops doing one byte at a time. It's not clear
how it could read beyond the input area without also clobbering bytes
outside of the destination area. Some debugging needed.

&gt; In the memxor tests, do you put the buffers at a zone exactly at the
&gt; ending position of the buffer,

No. That's probably why valgrind doesn't warn about it. I just allocate
a buffer of 16 + MAX_SIZE bytes, and try with starting address buf,
buf+1, ..., buf + 15.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131227204055</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-12-27 20:40:55-0400</timestampReceived><subject>Re: Request to release new version of nettle to support new architecture ppc64le</subject><body>

rajesh &lt;rajesh@linux.vnet.ibm.com&gt; writes:

&gt; Latest config.guess with ppc64le support is available at :
&gt; http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
&gt;
&gt; I verified building the package with latest config.guess mentioned
&gt; above and it built fine in ppc64le platform.
&gt; I would also like to inform that all make check test cases
&gt; successfully passed in the new platform ppc64le.

Good to know this solves the problem. I recently updated config.guess in
GMP for the same reason, iirc.

&gt; Would it be possible to spin up a newer version of nettle  for the
&gt; distros to pick up from the upstream release tarball, which would
&gt; support ppc64le.

config.guess should be updated before the next release, but I don't plan
any 2.7.2 release in the near future.

&gt; Please do let me know if you will be picking up the patches from
&gt; upstream or you would require local patches to be provided. I can send
&gt; out the patches to you.

I can get config.guess from the above git repo. I guess it's the
"timestamp='2013-11-29'" version you used?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131113104649</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2013-11-13 10:46:49-0400</timestampReceived><subject>Re: poly1305 nonce increments</subject><body>

On Tue, Nov 12, 2013 at 9:17 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt; As I wrote, I'm working with poly1305. One question: The _digest
&gt; function will update the nonce value, so that by default one gets a
&gt; nonce sequence of 0, 1, 2, .... In the code I'm working with
&gt; (contributed by Nikos), this increment is done in a big-endian fashion,
&gt; just like increments for CTR mode.
&gt; Is this going to be the common way to generate nonces for poly1305?

There is no common way as poly1305-aes isn't used in any standard
(that I know) yet.

There is: draft-agl-tls-chacha20poly1305-03, but it uses a very
different construction than the poly1305-aes.

regards,
Nikos

</body></email><email><emailId>20131113105340</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-11-13 10:53:40-0400</timestampReceived><subject>Re: added functions to zeroize</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I've checked it a bit further. Would the following on top of nettle be
&gt; equivalent?
&gt; void ecc_point_zeroize (struct ecc_point *p)
&gt; {
&gt;   memset(p-&gt;p, 0, 2*ecc_size(p-&gt;ecc)*sizeof(mp_limb_t));
&gt;   /* or using ecc_size_a() be better here? */
&gt; }

&gt; void ecc_scalar_zeroize (struct ecc_scalar *s);
&gt; {
&gt;   memset(s-&gt;p, 0, ecc_size(s-&gt;ecc)*sizeof(mp_limb_t));
&gt; }

I think that should work fine. And using ecc_size_a seems to be
appropriate for the first function.

&gt; Then the only change needed in nettle would be for those sizes to be documented.

Right, it seems all three ecc_size* functions are undocumented, and at
least ecc_size () and ecc_size_a () make sense for users.

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131113163321</emailId><senderName>John Regehr</senderName><senderEmail>regehr@cs.utah.edu</senderEmail><timestampReceived>2013-11-13 16:33:21-0400</timestampReceived><subject>Re: undefined behaviors</subject><body>

Niels, sorry, of course you're right that your updated macro fixes the 
n==0 case.

It sounds like both the GCC and LLVM people are interested in optimizing 
the safe rotate idioms, nice.

John



On 11/13/2013 12:27 AM, Niels Möller wrote:
&gt; John Regehr &lt;regehr@cs.utah.edu&gt; writes:
&gt;
&gt;&gt;&gt;&gt;     #define ROTL32(n,x) (((x)&lt;&lt;(n)) | ((x)&gt;&gt;((-(n)&amp;31))))
&gt;&gt;
&gt;&gt; The problem is n==0, not n==32.
&gt;
&gt; Exactly. The old rotation macro (still in nettle-2.7.1, it seems) used
&gt; the subexpression x &gt;&gt; (32 - n), which gives undefined behavior for n ==
&gt; 0. And with cast, this rotation macro is used with key-dependent n in
&gt; the range 0 &lt;= n &lt; 32.
&gt;
&gt; But doesn't the above version of the rotation macro work fine for all n
&gt; in the needed range? The intention is that for n == 0, it should boil
&gt; down to (x &lt;&lt; 0) | (x &gt;&gt; 0), which is perfectly well defined C. I really
&gt; want to avoid conditionals here.
&gt;
&gt; About gcc optimizations, see my corresponding bug report,
&gt; http://gcc.gnu.org/bugzilla/show_bug.cgi?id=57157. As far as I
&gt; understand, recognition of rotates has been considerably improved since.
&gt;
&gt; Regards,
&gt; /Niels
&gt;

</body></email><email><emailId>20131116214613</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-11-16 21:46:13-0400</timestampReceived><subject>Re: Make error on CentOS 6.4 x64</subject><body>

Martin Lambev &lt;fsh3mve@gmail.com&gt; writes:

&gt; I'm trying to build GnuTLS 3.2.6 on CentOS 6.4 x64, but having some
&gt; issues with nettle during compilation.
[...]
&gt; $ ./configre --disable-openssl       #Do not include openssl glue in the benchmark program
&gt;
&gt; after doing this "make" successfully finished and I can install "nettle"
&gt;
&gt; Is this proper workaround or not? If not how should be handed properly? 

I guess the benchmark code expects a more recent version of openssl than
you have (but then there should have been additional errors, about
missing openssl include files). --disable-openssl is the right option to
use.

You could also try the below (untested) patch to configure.ac, and then run

  $ autoconf
  $ make distclean
  $ ./configure
  $ make
  $ make check
  
The idea is that openssl code in the benchmark program should be
disabled automatically.

Regards,
/Niels

diff --git a/configure.ac b/configure.ac
index 037fbe9..7ce4d5a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -622,7 +622,7 @@ AC_CHECK_ALIGNOF(uint64_t)
 ALIGNOF_UINT64_T="$ac_cv_alignof_uint64_t"
 AC_SUBST(ALIGNOF_UINT64_T)
 
-AC_CHECK_HEADERS([openssl/blowfish.h openssl/des.h openssl/cast.h openssl/aes.h],,
+AC_CHECK_HEADERS([openssl/blowfish.h openssl/des.h openssl/cast.h openssl/aes.h openssl/ecdsa.h],,
 [enable_openssl=no
  break])
 

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131121222312</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-11-21 22:23:12-0400</timestampReceived><subject>poly1305</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; As I wrote, I'm working with poly1305.

I just pushed a poly1305 branch to the public repo. Includes the code
contributed by Nikos, based on MIT-licensed code by Andrew M.
(floodyberry), with some modifications, and an initial x86_64
implementation, which needs fixes to support the w64 abi, and better
testing.

The C implementation runs at 5.4 cycles/byte, and the assembly code at 3
cycles/byte.

Some further changes I think I will do:

* Take out the nonce from struct poly1305_ctx, and let poly1305_aes do
  all nonce handling. poly1305_digest gets the encrypted nonce as
  argument.

* For poly1305_aes, use aes128_ctx (it's hard coded for 128-bit AES
  anyway), and perhaps rename it to poly1305_aes128.

* Introduce a poly1305_update function, and use preprocessor casting
  tricks to define poly1305_aes128_update (and any other
  poly1305_*_update) as an alias.

* Promote union gcm_block to a more general abstraction, renaming it to
  nettle_block16 or so, and use it to guarantee nicer alignment for
  block buffer and nonce in poly1305.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131128054846</emailId><senderName>Paul Tagliamonte</senderName><senderEmail>paultag@debian.org</senderEmail><timestampReceived>2013-11-28 05:48:46-0400</timestampReceived><subject>Re: Apparent bug in SHA-1 digests</subject><body>


On Thu, Nov 28, 2013 at 06:38:47AM +0100, Niels Möller wrote:
&gt; You must call sha1_init(&amp;hash_ctx) before the first sha1_update.

Erm, yes. Sorry, the real code has this :)

&gt; &gt; Does doing the sha1_digest alter state in some way? I can't image it is, but
&gt; &gt; then how does this behavior crop up?
&gt; 
&gt; sha1_digest implies a sha1_init. So with sha1_digest(...);
&gt; sha1_digest(...), the second call gives you the sha1 digest of the empty
&gt; string. I think this is explained in the manual,
&gt; http://www.lysator.liu.se/~nisse/nettle/nettle.html#Legacy-hash-functions

Erm, so it is. Sorry 'bout that. Thanks!

&gt; 
&gt; Regards,
&gt; /Niels
&gt; 
&gt; -- 
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
&gt; Internet email is subject to wholesale government surveillance.

Cheers,
  Paul

-- 
 .''`.  Paul Tagliamonte &lt;paultag@debian.org&gt;
: :'  : Proud Debian Developer
`. `'`  4096R / 8F04 9AD8 2C92 066C 7352  D28A 7B58 5B30 807C 2A87
 `-     http://people.debian.org/~paultag

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20131129072951</emailId><senderName>Alexey Pavlov</senderName><senderEmail>alexpux@gmail.com</senderEmail><timestampReceived>2013-11-29 07:29:51-0400</timestampReceived><subject>Building nettle-2.7.1 with static GMP bug</subject><body>

Hi!

I'm try to build nettle-2.7.1 with static GMP with mingw-w64 toolchain
GCC-4.8.2 and got error while linking with static GMP:

i686-w64-mingw32-gcc -march=i686 -mtune=generic -O2 -pipe
-I/mingw32/include -ggdb3 -Wno-pointer-sign -Wall -W
-Wmissing-prototypes -Wmissing-declarations -Wstrict-prototypes
-Wpointer-arith -Wbad-function-cast -Wnested-externs -L.. -pipe
-L/mingw32/lib ecc-mod-test.o testutils.o ../nettle-internal.o
-lhogweed -lnettle -lgmp  -o ecc-mod-test.exe

C:/msys64/mingw32/lib/libgmp.a(sub_n.o):(.text+0x0): multiple
definition of `__gmpn_sub_n'
../libhogweed.dll.a(d000131.o):(.text+0x0): first defined here
collect2.exe: error: ld returned 1 exit status
/msys_repo/mingw-w64-nettle/src/nettle-2.7.1/testsuite/.test-rules.make:167:
recipe for target 'ecc-mod-test.exe' failed
make[1]: *** [ecc-mod-test.exe] Error 1


Is any fix for this?

Regards,
Alexey.

</body></email><email><emailId>20131130084118</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2013-11-30 08:41:18-0400</timestampReceived><subject>Re: Nettle-2.7.1 with static GMP error</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Cc: alexpux@gmail.com, nettle-bugs@lists.lysator.liu.se
&gt; Date: Fri, 29 Nov 2013 16:53:11 +0100
&gt; 
&gt; And it's equally impossible to omit -lgmp when linking libhogweed.dll,
&gt; and only add -lgmp when linking the executable?

Not if libhogweed calls functions from libgmp.

&gt; For ELF systems, if libhogweed is dynamic and libgmp is static, is it
&gt; still the right thing to do to link libhogweed with -lgmp, which will
&gt; copy needed gmp objects into libhogweed.so?

I'm not an expert, but I think it is.  Unix allows a shared library to
be generated with unresolved references, which are then resolved at
run time.  By contrast, on Windows all the references must be visible
at link time, and are hard-coded into the DLL.  This is why Windows
will refuse to run an executable that references a DLL which is
missing.

&gt; &gt; No, the symbols from libgmp are copied into the libhogweed _import_
&gt; &gt; library libhogweed.dll.a.  The import library is a static library.
&gt; 
&gt; I admit I don't understand all the fine details here. But that sounds
&gt; undesirable, the import library is intended to only contain thin glue to
&gt; the dll?

The import library contains short functions each of which has a single
instruction: an indirect jump to the address of the real function in
its DLL.  The import library itself is a static library, so that these
indirect jumps are statically linked into the program.

</body></email><email><emailId>20131005142754</emailId><senderName>Ted Zlatanov</senderName><senderEmail>tzz@lifelogs.com</senderEmail><timestampReceived>2013-10-05 14:27:54-0400</timestampReceived><subject>Re: PBKDF2 generic hashing method: unclear usage, examples needed</subject><body>

On Sat, 05 Oct 2013 15:45:03 +0200 nisse@lysator.liu.se (Niels Möller) wrote: 

NM&gt; Ted Zlatanov &lt;tzz@lifelogs.com&gt; writes:
&gt;&gt; I'm trying to use the Nettle PBKDF2 functionality from Emacs.

NM&gt; Cool! What will it be used for?

Exposing it for other packages (so it's a very bare implementation); my
first goal is to write an OpenPGP-compatible signature verification
package.

...
NM&gt; Code above totally untested, but I hope you get the idea.

Thanks, will try it ASAP :)

NM&gt; Any concrete suggestions on how to improve the documentation?

It's pretty good, this was the one area not well covered so far.  Let me
finish the Emacs integration and then I can say better what's missing.
I'll post issues with the code as I find them.

Ted


</body></email><email><emailId>20131112152125</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-11-12 15:21:25-0400</timestampReceived><subject>added functions to zeroize</subject><body>

Hello,
 Attached is a patch that allows overwriting values (points and
scalars) in the ECC API.

regards,
Nikos

["0001-Added-ecc_scalar_zeroize-and-ecc_point_zeroize.patch" (text/x-patch)]

From 7e979007b4c79d7072ce265c92cc0548b8dabd6e Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Tue, 12 Nov 2013 16:18:17 +0100
Subject: [PATCH] Added ecc_scalar_zeroize() and ecc_point_zeroize().

These two functions allow overwriting a value with zeros.
Without those functions it was impossible to overwrite values with
the exported API.
---
 ecc-point.c  | 7 +++++++
 ecc-scalar.c | 7 +++++++
 ecc.h        | 7 +++++++
 3 files changed, 21 insertions(+)

diff --git a/ecc-point.c b/ecc-point.c
index 3f356b9..3bded8a 100644
--- a/ecc-point.c
+++ b/ecc-point.c
@@ -28,6 +28,7 @@
 
 #include "ecc.h"
 #include "ecc-internal.h"
+#include &lt;string.h&gt;
 
 void
 ecc_point_init (struct ecc_point *p, const struct ecc_curve *ecc)
@@ -42,6 +43,12 @@ ecc_point_clear (struct ecc_point *p)
   gmp_free_limbs (p-&gt;p, 2*p-&gt;ecc-&gt;size);
 }
 
+void
+ecc_point_zeroize (struct ecc_point *p)
+{
+  memset(p-&gt;p, 0, 2*p-&gt;ecc-&gt;size);
+}
+
 int
 ecc_point_set (struct ecc_point *p, const mpz_t x, const mpz_t y)
 {
diff --git a/ecc-scalar.c b/ecc-scalar.c
index 27d6571..ff08733 100644
--- a/ecc-scalar.c
+++ b/ecc-scalar.c
@@ -28,6 +28,7 @@
 
 #include "ecc.h"
 #include "ecc-internal.h"
+#include &lt;string.h&gt;
 
 void
 ecc_scalar_init (struct ecc_scalar *s, const struct ecc_curve *ecc)
@@ -42,6 +43,12 @@ ecc_scalar_clear (struct ecc_scalar *s)
   gmp_free_limbs (s-&gt;p, s-&gt;ecc-&gt;size);
 }
 
+void
+ecc_scalar_zeroize (struct ecc_scalar *s)
+{
+  memset(s-&gt;p, 0, s-&gt;ecc-&gt;size*sizeof(mp_limb_t));
+}
+
 int
 ecc_scalar_set (struct ecc_scalar *s, const mpz_t z)
 {
diff --git a/ecc.h b/ecc.h
index 609d246..c795140 100644
--- a/ecc.h
+++ b/ecc.h
@@ -36,12 +36,14 @@ extern "C" {
 /* Name mangling */
 #define ecc_point_init nettle_ecc_point_init
 #define ecc_point_clear nettle_ecc_point_clear
+#define ecc_point_zeroize nettle_ecc_point_zeroize
 #define ecc_point_set nettle_ecc_point_set
 #define ecc_point_get nettle_ecc_point_get
 #define ecc_point_mul nettle_ecc_point_mul
 #define ecc_point_mul_g nettle_ecc_point_mul_g
 #define ecc_scalar_init nettle_ecc_scalar_init
 #define ecc_scalar_clear nettle_ecc_scalar_clear
+#define ecc_scalar_zeroize nettle_ecc_scalar_zeroize
 #define ecc_scalar_set nettle_ecc_scalar_set
 #define ecc_scalar_get nettle_ecc_scalar_get
 #define ecc_scalar_random nettle_ecc_scalar_random
@@ -92,6 +94,8 @@ void
 ecc_point_init (struct ecc_point *p, const struct ecc_curve *ecc);
 void
 ecc_point_clear (struct ecc_point *p);
+void
+ecc_point_zeroize (struct ecc_point *p);
 
 /* Fails and returns zero if the point is not on the curve. */
 int
@@ -104,6 +108,9 @@ ecc_scalar_init (struct ecc_scalar *s, const struct ecc_curve *ecc);
 void
 ecc_scalar_clear (struct ecc_scalar *s);
 
+void
+ecc_scalar_zeroize (struct ecc_scalar *s);
+
 /* Fails and returns zero if the scalar is not in the proper range. */
 int
 ecc_scalar_set (struct ecc_scalar *s, const mpz_t z);
-- 
1.8.4.2



</body></email><email><emailId>20131112202132</emailId><senderName>John Regehr</senderName><senderEmail>regehr@cs.utah.edu</senderEmail><timestampReceived>2013-11-12 20:21:32-0400</timestampReceived><subject>Re: undefined behaviors</subject><body>

&gt; I imagine you intended to mail the nettle-bugs list, rather than
&gt; nettle-bugs-owner administrative address? Feel free to reply on list.

Ugh, sorry, cut and paste...

&gt; That's unexpected. Hmm. The NEWS file for 2.7.1 claims that this problem
&gt; was fixed in that release, but appearantly it wasn't. You can check if
&gt; the error disappears if you replace the definition of ROT32 in macros.h
&gt; by
&gt;
&gt;    #define ROTL32(n,x) (((x)&lt;&lt;(n)) | ((x)&gt;&gt;((-(n)&amp;31))))

I'll check this tonight.

&gt;&gt; blowfish.c:353:19: runtime error: left shift of 244 by 24 places
&gt;&gt; cannot be represented in type 'int'
&gt;&gt; twofish.c:196:54: runtime error: left shift of 184 by 24 places cannot
&gt;&gt; be represented in type 'int'
&gt;
&gt; These should have some casts to uint32_t, I think. Unlikely to cause
&gt; real problems.

Right, I don't know of any compiler that exploits these, and in fact in 
C++ (but not C) this particular case is covered by a defect report that 
makes it defined.

Thanks,

John


</body></email><email><emailId>20131116021221</emailId><senderName>Martin Lambev</senderName><senderEmail>fsh3mve@gmail.com</senderEmail><timestampReceived>2013-11-16 02:12:21-0400</timestampReceived><subject>Make error on CentOS 6.4 x64</subject><body>

Hello nettle gurus,

I'm trying to build GnuTLS 3.2.6 on CentOS 6.4 x64, but having some issues with \
nettle during compilation.

nettle 2.7.1 make errors:

configure: summary of build options:

  Version:           nettle 2.7.1
  Host type:         x86_64-unknown-linux-gnu
  ABI:               64
  Assembly files:    x86_64
  Install prefix:    /usr/local
  Library directory: ${exec_prefix}/lib64
  Compiler:          gcc
  Static libraries:  yes
  Shared libraries:  yes
  Public key crypto: yes
  Documentation:     no

During "$ make" exits with error:

hogweed-benchmark.c:575: error: ‘struct openssl_ctx’ has no member named ‘key’
hogweed-benchmark.c:576: error: ‘struct openssl_ctx’ has no member named ‘digest’
make[1]: *** [hogweed-benchmark.o] Error 1
make[1]: Leaving directory `/home/mve/Downloads/ocserv/nettle/nettle-2.7.1/examples'
make: *** [all] Error 1

It fails "error: ‘struct openssl_ctx’" so I looked configure help options…
$ make clean
$ ./configure --help  #give a few options so I disabled this one as I'm assuming it's \
not used in my case isn't it? $ ./configre --disable-openssl       #Do not include \
openssl glue in the benchmark program

after doing this "make" successfully finished and I can install "nettle"

Is this proper workaround or not? If not how should be handed properly? 

Thank you! Regards,

Martin


["signature.asc" (signature.asc)]

-----BEGIN PGP SIGNATURE-----
Comment: GPGTools - http://gpgtools.org

iQEcBAEBCgAGBQJShtSFAAoJEND4J2ZB1gqIvTwIAKGBgK6txOK47o6wAPpYywm3
fS2nd/rplrODXjOpbiDlPEy+3pWNK3zqspzhVv7/HmjfqMNJNFZE9saqPkGhSlI6
fDHiBv5VKy0oKolE9zuLx/MYkL/K/Svwt8kuFOD99tt9R774G/Do28dDJqMaZuZc
38h6e2jaOh/W8gE9xdc73Ye8MtXe+20ezESHGtMJnAFIlAALVaMfL+5drMfgm+x4
Ve5McrnsfsV2MvC6pGpMa9LGfeLKUeXXF2M3E9LZYBOeQ29fB2XgAGrRz/x3Yeh4
VUZwkAEuteBARdaoB1L1JdpXVMHiEZqchBHKPUnzimvaqgqx8x5IELlm1nqnS7A=
=xtga
-----END PGP SIGNATURE-----


</body></email><email><emailId>20131113035506</emailId><senderName>John Regehr</senderName><senderEmail>regehr@cs.utah.edu</senderEmail><timestampReceived>2013-11-13 03:55:06-0400</timestampReceived><subject>Re: undefined behaviors</subject><body>

&gt;&gt;    #define ROTL32(n,x) (((x)&lt;&lt;(n)) | ((x)&gt;&gt;((-(n)&amp;31))))

The problem is n==0, not n==32.  So this fixes the undefined behavior:

#define ROTL32(n,x) ((n)==0?(x):(((x)&lt;&lt;(n)) | ((x)&gt;&gt;(32-(n)))))

John


</body></email><email><emailId>20131113043124</emailId><senderName>John Regehr</senderName><senderEmail>regehr@cs.utah.edu</senderEmail><timestampReceived>2013-11-13 04:31:24-0400</timestampReceived><subject>Re: undefined behaviors</subject><body>

Note that the safer rotate macro can be compiled into a rotate 
instruction just like the current macro.  But LLVM and GCC don't know 
this.  I've made requests to both compiler teams to implement this 
optimization, but I have no idea if they'll go for it.

http://llvm.org/bugs/show_bug.cgi?id=17904
http://gcc.gnu.org/bugzilla/show_bug.cgi?id=59100

John Regehr



On 11/12/2013 08:55 PM, John Regehr wrote:
&gt;&gt;&gt;    #define ROTL32(n,x) (((x)&lt;&lt;(n)) | ((x)&gt;&gt;((-(n)&amp;31))))
&gt;
&gt; The problem is n==0, not n==32.  So this fixes the undefined behavior:
&gt;
&gt; #define ROTL32(n,x) ((n)==0?(x):(((x)&lt;&lt;(n)) | ((x)&gt;&gt;(32-(n)))))
&gt;
&gt; John
&gt;
&gt; _______________________________________________
&gt; nettle-bugs mailing list
&gt; nettle-bugs@lists.lysator.liu.se
&gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs
&gt;

</body></email><email><emailId>20131113072759</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-11-13 07:27:59-0400</timestampReceived><subject>Re: undefined behaviors</subject><body>

John Regehr &lt;regehr@cs.utah.edu&gt; writes:

&gt;&gt;&gt;    #define ROTL32(n,x) (((x)&lt;&lt;(n)) | ((x)&gt;&gt;((-(n)&amp;31))))
&gt;
&gt; The problem is n==0, not n==32.

Exactly. The old rotation macro (still in nettle-2.7.1, it seems) used
the subexpression x &gt;&gt; (32 - n), which gives undefined behavior for n ==
0. And with cast, this rotation macro is used with key-dependent n in
the range 0 &lt;= n &lt; 32.

But doesn't the above version of the rotation macro work fine for all n
in the needed range? The intention is that for n == 0, it should boil
down to (x &lt;&lt; 0) | (x &gt;&gt; 0), which is perfectly well defined C. I really
want to avoid conditionals here.

About gcc optimizations, see my corresponding bug report,
http://gcc.gnu.org/bugzilla/show_bug.cgi?id=57157. As far as I
understand, recognition of rotates has been considerably improved since.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131112155643</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-11-12 15:56:43-0400</timestampReceived><subject>Re: added functions to zeroize</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;  Attached is a patch that allows overwriting values (points and
&gt; scalars) in the ECC API.

What's the use case? Just to clear sensitive memory, or do you do any
operations on these values after zeroize?

In the former case, maybe it's better to just let the ecc_*_clear
functions do that? Cost should be negligible, compared to doing any real
ecc operation.

Other nettle functions don't ovewrite any memory, and leaves that for
the application. Some examples:

1. AES context. The caller can easily do memset (ctx, 0, sizeof (*ctx))
   if desired, and that will overwrite the subkeys. And there's no
   *_clear function to hang that functionality on.

2. RSA private key. Sensitive data is in mpz_t variables, and one reason
   nettle's rsa_private_key_clear doesn't try to overwrite them is that
   I don't think there's any easy GMP interface to do that.

And struct ecc_scalar (and struct ecc_point) is different from both
these examples, since the space is explicitly allocated in
ecc_scalar_init.

Independently of what nettle does, I imagine you might want to use
mp_set_memory_functions to make sure that all memory reallocated or
freed by gmp is also overwritten.

Regards,
/Niels

PS. I've started with integrating the poly1305 code. I think we need the
internal representation of the key and state to be implementation
dependent. The C code you sent me uses 5 uint32_t, with 26 bits used in
each. x86_64 assembly most likely wants to use 2 fully used uint64_t and
one (smaller) variable for the top two bits, and 32-bit assembly would
want 4 full uint32_t + top bits. All variants could be accomodated with
something like

  struct poly1305_value
  {
    union
      {
        uint32_t s[4];
        uint64_t d[2];
      } u;
    uint32_t hi;
  };

Everything depending on the internel representation would be collected
into files poly1305-internal.{c,asm}, both the block processing, and
code for installing a key and extracting a digest.

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131112163231</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-11-12 16:32:31-0400</timestampReceived><subject>Re: added functions to zeroize</subject><body>

On Tue, Nov 12, 2013 at 4:56 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt;&gt;  Attached is a patch that allows overwriting values (points and
&gt;&gt; scalars) in the ECC API.
&gt; What's the use case? Just to clear sensitive memory, or do you do any
&gt; operations on these values after zeroize?

The former.

&gt; In the former case, maybe it's better to just let the ecc_*_clear
&gt; functions do that? Cost should be negligible, compared to doing any real
&gt; ecc operation.

That would be different to practices in other parts of nettle... but
would work as well.

&gt; And struct ecc_scalar (and struct ecc_point) is different from both
&gt; these examples, since the space is explicitly allocated in
&gt; ecc_scalar_init.

Note that from the nettle user's perspective one cannot zeroize the
memory, as access to the structure that has the size requires
"ecc-internals.h" which isn't installed.

&gt; Independently of what nettle does, I imagine you might want to use
&gt; mp_set_memory_functions to make sure that all memory reallocated or
&gt; freed by gmp is also overwritten.

That would work if I had full control on the application. If I use
mp_set_memory as a library, other parts of the application could crash
(we had such issue when gnutls was used together with another library
that was setting the gmp allocation functions). Reallocations are not
much of an issue to private keys, as they are typically added as a
singleton. You've got a point here though.

regards,
Nikos


&gt; PS. I've started with integrating the poly1305 code. I think we need the
&gt; internal representation of the key and state to be implementation
&gt; dependent. The C code you sent me uses 5 uint32_t, with 26 bits used in
&gt; each. x86_64 assembly most likely wants to use 2 fully used uint64_t and
&gt; one (smaller) variable for the top two bits, and 32-bit assembly would
&gt; want 4 full uint32_t + top bits. All variants could be accomodated with
&gt; something like
[...]
&gt; Everything depending on the internel representation would be collected
&gt; into files poly1305-internal.{c,asm}, both the block processing, and
&gt; code for installing a key and extracting a digest.

Sounds reasonable.

</body></email><email><emailId>20131113094633</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-11-13 09:46:33-0400</timestampReceived><subject>Re: added functions to zeroize</subject><body>

On Tue, Nov 12, 2013 at 4:56 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:
&gt;&gt;  Attached is a patch that allows overwriting values (points and
&gt;&gt; scalars) in the ECC API.
&gt; What's the use case? Just to clear sensitive memory, or do you do any
&gt; operations on these values after zeroize?
&gt; In the former case, maybe it's better to just let the ecc_*_clear
&gt; functions do that? Cost should be negligible, compared to doing any real
&gt; ecc operation.

I've checked it a bit further. Would the following on top of nettle be
equivalent?
void ecc_point_zeroize (struct ecc_point *p)
{
  memset(p-&gt;p, 0, 2*ecc_size(p-&gt;ecc)*sizeof(mp_limb_t));
  /* or using ecc_size_a() be better here? */
}


void ecc_scalar_zeroize (struct ecc_scalar *s);
{
  memset(s-&gt;p, 0, ecc_size(s-&gt;ecc)*sizeof(mp_limb_t));
}

Then the only change needed in nettle would be for those sizes to be docume=
nted.

regards,
Nikos

</body></email><email><emailId>20131005193658</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-10-05 19:36:58-0400</timestampReceived><subject>Re: AES interface</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Also, other AES-style algorithms, in particular, twofish and camellia,
&gt; could have similar changes as AES.

I've had a closer look now. I was a bit mistaken about twofish; it uses
the same number of rounds and subkeys independent of the key size. So
the remanining algorithms with a number of subkeys depending on the key
size are camellia and cast128.

Camellia uses fewer subkeys for 128 bit keys than for 192 or 256 bit
keys. So this is a bit similar to AES, and I think an analogous reorg
would make sense.

As for cast128, the smaller number of rounds apply only for keysizes
shorter than 80 bits (possible choices: 40, 48, 56, 64 or 72 bits).
Maybe we can totally drop support for that, and limit possible key sizes
to 80, 88, 96, 104, 112, or 128 bits? Does anyone has a usecase, e.g.,
interop with some old applications, where CAST128 with shorter keys are
important? I'd imagine anyone using CAST128 today is using the maximum
key size of 128 bits.

If I go through with the plan to drop the length argument from
nettle_cipher.set_*_key, I think I should also add some public wrapper
functions like, e.g.,

  void
  twofish128_set_key (struct twofish_ctx *ctx, const uint8_t *key)
  {
    twofish_set_key (ctx, 16, key);
  }

for algorithms which allow variable key size. (Current situation is that
instead, ciphers with *fixed* key size, like the new
aes128_set_encrypt_key, need wrappers for their corresponding
nettle_cipher instance). Naming the cast128 wrapper function for the
common case of 128-bit keys will be a challenge, though...

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131128042110</emailId><senderName>Paul Tagliamonte</senderName><senderEmail>paultag@gmail.com</senderEmail><timestampReceived>2013-11-28 04:21:10-0400</timestampReceived><subject>Apparent bug in SHA-1 digests</subject><body>


Hey hackers,


I'm seeing some behavior that confuses me a bit. I'm sure I'm doing
something wrong, but I can't tell.

Here's a minimal example:

/
| #include &lt;stdio.h&gt;
| #include &lt;nettle/rsa.h&gt;
| 
| int main ( int argc, char ** argv ) {
|     struct sha1_ctx hash_ctx;
|     uint8_t headers[] = {
|         0xDE, 0xEA, 0xAD,
|         0xBE, 0xEF
|     };
|     sha1_update(&amp;hash_ctx, 5, headers);
| 
|     for (int i = 0; i &lt; 3; ++i) {
|         uint8_t _fingerprint[SHA1_DIGEST_SIZE];
|         sha1_digest(&amp;hash_ctx, SHA1_DIGEST_SIZE, _fingerprint);
|         for (int i = 0; i &lt; SHA1_DIGEST_SIZE; ++i)
|             printf("%02X ", _fingerprint[i]);
|         printf("\n");
|     }
| }
\

The output, when run is:

/
| 89 22 AA 95 F2 02 C9 BB 35 FC 2D A2 DE 22 BE 48 2B B6 6C 1D 
| DA 39 A3 EE 5E 6B 4B 0D 32 55 BF EF 95 60 18 90 AF D8 07 09 
| DA 39 A3 EE 5E 6B 4B 0D 32 55 BF EF 95 60 18 90 AF D8 07 09 
\

(that last line is stable after the inital hash)

Does doing the sha1_digest alter state in some way? I can't image it is, but
then how does this behavior crop up?

Much love, thanks all!

Cheers,
  Paul

--
#define sizeof(x) rand()
:wq

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20131128053847</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-11-28 05:38:47-0400</timestampReceived><subject>Re: Apparent bug in SHA-1 digests</subject><body>

Paul Tagliamonte &lt;paultag@gmail.com&gt; writes:

&gt; Here's a minimal example:
&gt;
&gt; /
&gt; | #include &lt;stdio.h&gt;
&gt; | #include &lt;nettle/rsa.h&gt;
&gt; | 
&gt; | int main ( int argc, char ** argv ) {
&gt; |     struct sha1_ctx hash_ctx;
&gt; |     uint8_t headers[] = {
&gt; |         0xDE, 0xEA, 0xAD,
&gt; |         0xBE, 0xEF
&gt; |     };
&gt; |     sha1_update(&amp;hash_ctx, 5, headers);

You must call sha1_init(&amp;hash_ctx) before the first sha1_update.

&gt; Does doing the sha1_digest alter state in some way? I can't image it is, but
&gt; then how does this behavior crop up?

sha1_digest implies a sha1_init. So with sha1_digest(...);
sha1_digest(...), the second call gives you the sha1 digest of the empty
string. I think this is explained in the manual,
http://www.lysator.liu.se/~nisse/nettle/nettle.html#Legacy-hash-functions

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131129130205</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-11-29 13:02:05-0400</timestampReceived><subject>Re: Nettle-2.7.1 with static GMP error</subject><body>

Alexey Pavlov &lt;alexpux@gmail.com&gt; writes:

&gt; 2013/11/29 Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;&gt; What failed? Can I repost your message to the list?
&gt;
&gt; I do it already. I receive subscribing message now.

Ok. I'm now cc:ing the list. Context: Link error when building a dynamic
libnettle.dll and libhogweed.dll, and statically linking to libgmp.a.

&gt;&gt;&gt; i686-w64-mingw32-gcc -march=i686 -mtune=generic -O2 -pipe
&gt;&gt;&gt; -I/mingw32/include -ggdb3 -Wno-pointer-sign -Wall -W
&gt;&gt;&gt; -Wmissing-prototypes -Wmissing-declarations -Wstrict-prototypes
&gt;&gt;&gt; -Wpointer-arith -Wbad-function-cast -Wnested-externs -L.. -pipe
&gt;&gt;&gt; -L/mingw32/lib ecc-mod-test.o testutils.o ../nettle-internal.o
&gt;&gt;&gt; -lhogweed -lnettle -lgmp  -o ecc-mod-test.exe
&gt;&gt;&gt;
&gt;&gt;&gt; C:/msys64/mingw32/lib/libgmp.a(sub_n.o):(.text+0x0): multiple
&gt;&gt;&gt; definition of `__gmpn_sub_n'
&gt;&gt;&gt;
&gt;&gt;&gt; ../libhogweed.dll.a(d000131.o):(.text+0x0): first defined here
&gt;&gt;&gt;
&gt;&gt;&gt; collect2.exe: error: ld returned 1 exit status
&gt;&gt;
&gt;&gt; So you're building shared libraries for nettle, but you have a static
&gt;&gt; gmp library? The way I understand the error, the used gmp functions gets
&gt;&gt; copied into libhogweed.dll. Not sure if that is the best behavior.
&gt;&gt;
&gt; Yes I have static GMP because we build toolchains with static
&gt; prerequisites and don't want to has dynamic dependencies from them
&gt; (gmp, mpc, mpfr, clog, isl). I prefer to use static versions of them.

&gt;&gt; But I'm not sure I understand the link error. There's some function
&gt;&gt; depending on __gmpn_sub_n ("mpn_sub_n" to user code), but if that
&gt;&gt; function is included in libhogweed.dll, why isn't that function just
&gt;&gt; skipped when the linker processes libgmp.a?
&gt;
&gt; A program in C can have only one definition (declaration which assigns
&gt; a value) for each object (storage space for a variable).

But when doing linking with static libraries, multiple definitions are
generally ok. The linker copies only the object files which are needed,
and when it needs a symbol, it includes only the first object file in
any of the libraries, which define the symbol.

One may still get clashes if each object file includes multiple symbols,
since in the set of object files selected by the linker in the end,
multiple definitions of the same symbol are not allowed.

&gt; As I understand, somewhere  header file contains definitions for
&gt; several functions __gmpn_sub_n  which when included in several
&gt; different translation units results in the linker throwing this error.

I don't think so. My understanding is that

1. The symbol __gmp_sub_n is defined in some object file included in
   libgmp.a, and nowhere in the nettle source or object code (and
   mini-gmp.c doesn't count, it's not involved in the link, and it uses
   different linker symbol names than the real gmp).

2. This object file gets copied from libgmp.a into libhogweed.dll by the
   linker. Not sure if this is right; -lgmp was added to the libhogweed
   link command primarily to get dependencies between *shared* libraries
   right.

3. You then link the executable ecc-mod-test.exe with -lhogweed and
   -lgmp. The linked sees two definitions of the symbol __gmpn_sub_n,
   one in libgmp.a, and one in libhogweed.dll, and it considers this an
   error.

What I don't understand, is why, in (3) above, the linker doesn't just
ignore the object in libgmp.a which defines the symbol.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131005143956</emailId><senderName>Ted Zlatanov</senderName><senderEmail>tzz@lifelogs.com</senderEmail><timestampReceived>2013-10-05 14:39:56-0400</timestampReceived><subject>loading RSA keys from a PEM file</subject><body>

If I generate a public RSA key into a PEM file and then base64-decode the
contents (this is in Emacs):

(string-to-unibyte (base64-decode-string \
"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAreGA/Qky9W3izQV0kzba \
7wKl/wzwxkbbQxvcUqUT1krgAbO/n1tYFjXdJZoWwbMO/qv7NRoMDY4yPWGpsQfY \
+PSIknAhTZVbgwXrm/wb37+hKRKax2UZ9A/Rx4vJZRYlkpvZ9LbBziseFNN7SMWW \
qkjBO/NeT8/I9mURDa+4RoYfT6ZwjTvt808PH7uIghk+MHAx9EMBAfafF1Jn9TqW \
y+Hgdqik9sZteMvCumvGK4grSwzdfPO5I05tt/0I7QVPxlXbHIk/bBsE7mpgOxur \
P0DAkFKtYDM7oZPBwB6X778ba2EEFKPpVIyzw/jlDPd9PB6gE6dixmax3Hlg69RI EwIDAQAB"))

I seem unable to load that as a public key (SCHARS macro == length,
SDATA macro == data):

struct rsa_public_key key;
rsa_public_key_init(&amp;key);
rsa_keypair_from_der (&amp;key, NULL, 0, SCHARS (public_key), SDATA (public_key))

It keeps failing.  From the docs and example it seems like that should
work.  Can you see what I'm doing wrong?  I've spent a few hours on
it and can't trace the problem.  If not I will start digging into the
key loading functions, but was hoping it's something obvious (and if you
have a working example that would be great).

As soon as I have this working I will publish my work for review; the
RSA signatures are the last piece missing.

Ted


</body></email><email><emailId>20131014231841</emailId><senderName>Paul Tagliamonte</senderName><senderEmail>paultag@gmail.com</senderEmail><timestampReceived>2013-10-14 23:18:41-0400</timestampReceived><subject>internal bug in pgp_put_public_rsa_key</subject><body>


Howdy folks!


Thanks for working on nettle,

pgp_put_public_rsa_key seems to throw an assertion error:

&gt;  assert(buffer-&gt;size == start + length)

buffer-&gt;size is 3 larger than (start + length).

Removing the PGP_LENGTH_TWO_OCTETS works (but this is wrong, since 4880
defines it as it's written, I think, still new with the spec), so I
think there might be a bug in the assert.

Can someone who groks the code confirm this?

Thanks!
  Paul

-- 
#define sizeof(x) rand()
:wq

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20131016100042</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-10-16 10:00:42-0400</timestampReceived><subject>Re: Git repository down?</subject><body>

Andrew Walrond &lt;andrew@walrond.org&gt; writes:

&gt; Is the git repository down?

Appearantly, yes. The machine is still up, though, and responding to http.
I'll ask sysadm what's happening.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131017105549</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-10-17 10:55:49-0400</timestampReceived><subject>Re: Git repository down?</subject><body>

Andrew Walrond &lt;andrew@walrond.org&gt; writes:

&gt; Is the git repository down?

Now it seems to work again. Some deamon had died, for unknown reason,
and has been restarted.

BTW, switching git.lysator.liu.se from gitorious to some other software
is under consideraton. Any recommendations?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131017125407</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2013-10-17 12:54:07-0400</timestampReceived><subject>Re: Git repository down?</subject><body>

You wrote:

&gt; BTW, switching git.lysator.liu.se from gitorious to some other
&gt; software is under consideraton. Any recommendations?

What's wrong with or missing from gitorious?

/Simon

</body></email><email><emailId>20131017170505</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-10-17 17:05:05-0400</timestampReceived><subject>Re: Git repository down?</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; What's wrong with or missing from gitorious?

Nothing very fundamental, but I think it was a bit cumbersome to
install. Looking at the instructions at
http://getgitorious.com/installer, there's a magic installation script
supporting only centos 6, which I don't think is what that lysator
server is running. And instructions as a video.

Furthermore, git.lysator.liu.se was pretty unstable after the gitorious
upgrade a while ago (was it last spring?) and it was a bit hard to
understand why.

I'm not involved in administration of that server, but I think it's that
previous experience that makes the lysator roots look for alternatives.

(As for the features of the web interface, I can't really say much; I
haven't using anything but the most basic functions to browse the source
tree and create new repos, and that seems to work with no problems).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131015064636</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-10-15 06:46:36-0400</timestampReceived><subject>Re: internal bug in pgp_put_public_rsa_key</subject><body>

Paul Tagliamonte &lt;paultag@gmail.com&gt; writes:

&gt; pgp_put_public_rsa_key seems to throw an assertion error:

Note that the pgp functions in Nettle are undocumented and unfinished.
Cool that anybody else is having a look at them.

&gt; Can someone who groks the code confirm this?

Can't say I really grok the code either, I wrote those functions back in
2007... But it looks fishy to me with two calls to pgp_put_header, using
the same tag value PGP_TAG_PUBLIC_KEY. If you have read the spec
recently, is there any way that could be correct?

I'd suggest deleting the second call to pgp_put_header (the one with the
PGP_LENGTH_TWO_OCTETS argument). The the correct body length should be
passed to the first pgp_put_header call, and the variable start, and the
assert, check that we really generate a packet body matching that
length.

In case you'd like to try to get some more of the pgp code in shape,
additional testcases would be a good place to start.

The way I remember it, I tried passing the generated pckets to gpg, but
it was a bit difficult to get any interoperability by supporting only
the "new" openpgp formats. Things might have changed since then, of
course.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131005145521</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2013-10-05 14:55:21-0400</timestampReceived><subject>Re: loading RSA keys from a PEM file</subject><body>

&gt; From: Ted Zlatanov &lt;tzz@lifelogs.com&gt;
&gt; Date: Sat, 05 Oct 2013 10:39:56 -0400
&gt; 
&gt; If I generate a public RSA key into a PEM file and then base64-decode the
&gt; contents (this is in Emacs):
&gt; 
&gt; (string-to-unibyte (base64-decode-string \
&gt; "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAreGA/Qky9W3izQV0kzba \
&gt; 7wKl/wzwxkbbQxvcUqUT1krgAbO/n1tYFjXdJZoWwbMO/qv7NRoMDY4yPWGpsQfY \
&gt; +PSIknAhTZVbgwXrm/wb37+hKRKax2UZ9A/Rx4vJZRYlkpvZ9LbBziseFNN7SMWW \
&gt; qkjBO/NeT8/I9mURDa+4RoYfT6ZwjTvt808PH7uIghk+MHAx9EMBAfafF1Jn9TqW \
&gt; y+Hgdqik9sZteMvCumvGK4grSwzdfPO5I05tt/0I7QVPxlXbHIk/bBsE7mpgOxur \
&gt; P0DAkFKtYDM7oZPBwB6X778ba2EEFKPpVIyzw/jlDPd9PB6gE6dixmax3Hlg69RI EwIDAQAB"))
&gt; 
&gt; I seem unable to load that as a public key (SCHARS macro == length,
&gt; SDATA macro == data):

You don't need string-to-unibyte, the result of base64-decode-string
is already a unibyte string.  Just use it.


</body></email><email><emailId>20131005160537</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-10-05 16:05:37-0400</timestampReceived><subject>Re: loading RSA keys from a PEM file</subject><body>

Ted Zlatanov &lt;tzz@lifelogs.com&gt; writes:

&gt; If I generate a public RSA key into a PEM file and then base64-decode the
&gt; contents (this is in Emacs):
&gt;
&gt; (string-to-unibyte (base64-decode-string
&gt; "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAreGA/Qky9W3izQV0kzba
[...]
&gt; EwIDAQAB"))

&gt; rsa_keypair_from_der (&amp;key, NULL, 0, SCHARS (public_key), SDATA (public_key))
&gt;
&gt; It keeps failing.  From the docs and example it seems like that should
&gt; work.  Can you see what I'm doing wrong?

The data corresponds to (according to dumpasn1):

  0 290: SEQUENCE {
  4  13:   SEQUENCE {
  6   9:     OBJECT IDENTIFIER rsaEncryption (1 2 840 113549 1 1 1)
 17   0:     NULL
       :     }
 19 271:   BIT STRING
       :     30 82 01 0A 02 82 01 01 00 AD E1 80 FD 09 32 F5
       :     6D E2 CD 05 74 93 36 DA EF 02 A5 FF 0C F0 C6 46
       :     DB 43 1B DC 52 A5 13 D6 4A E0 01 B3 BF 9F 5B 58
       :     16 35 DD 25 9A 16 C1 B3 0E FE AB FB 35 1A 0C 0D
       :     8E 32 3D 61 A9 B1 07 D8 F8 F4 88 92 70 21 4D 95
       :     5B 83 05 EB 9B FC 1B DF BF A1 29 12 9A C7 65 19
       :     F4 0F D1 C7 8B C9 65 16 25 92 9B D9 F4 B6 C1 CE
       :     2B 1E 14 D3 7B 48 C5 96 AA 48 C1 3B F3 5E 4F CF
       :             [ Another 142 bytes skipped ]
       :   }

Which looks ok to me. But Nettle's rsa_keypair_from_der wants the
contents of that BIT STRING only, not the complete object. Hava a look
at tools/pkcs1-conv.c, which I think is the only example code using
these functions.

BTW, you might want to have a look at the unfinished openpgp code in
Nettle (pgp.h, pgp-encode.c and rsa2openpgp.c). But it's not very useful
in the current state.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131006085938</emailId><senderName>Ted Zlatanov</senderName><senderEmail>tzz@lifelogs.com</senderEmail><timestampReceived>2013-10-06 08:59:38-0400</timestampReceived><subject>Re: loading RSA keys from a PEM file</subject><body>

On Sat, 05 Oct 2013 17:55:21 +0300 Eli Zaretskii &lt;eliz@gnu.org&gt; wrote: 

EZ&gt; You don't need string-to-unibyte, the result of base64-decode-string
EZ&gt; is already a unibyte string.  Just use it.

Thanks.  I was playing around with the tests to see if I had missed
something :)

Ted


</body></email><email><emailId>20131006093752</emailId><senderName>Ted Zlatanov</senderName><senderEmail>tzz@lifelogs.com</senderEmail><timestampReceived>2013-10-06 09:37:52-0400</timestampReceived><subject>Re: loading RSA keys from a PEM file</subject><body>

On Sat, 05 Oct 2013 18:05:37 +0200 nisse@lysator.liu.se (Niels Möller) wrote: 

NM&gt; Ted Zlatanov &lt;tzz@lifelogs.com&gt; writes:

&gt; &gt; It keeps failing.  From the docs and example it seems like that should
&gt; &gt; work.  Can you see what I'm doing wrong?

NM&gt; The data corresponds to (according to dumpasn1):

NM&gt;   0 290: SEQUENCE {
NM&gt;   4  13:   SEQUENCE {
NM&gt;   6   9:     OBJECT IDENTIFIER rsaEncryption (1 2 840 113549 1 1 1)
NM&gt;  17   0:     NULL
NM&gt;        :     }
NM&gt;  19 271:   BIT STRING
NM&gt;        :     30 82 01 0A 02 82 01 01 00 AD E1 80 FD 09 32 F5
NM&gt;        :     6D E2 CD 05 74 93 36 DA EF 02 A5 FF 0C F0 C6 46
NM&gt;        :     DB 43 1B DC 52 A5 13 D6 4A E0 01 B3 BF 9F 5B 58
NM&gt;        :     16 35 DD 25 9A 16 C1 B3 0E FE AB FB 35 1A 0C 0D
NM&gt;        :     8E 32 3D 61 A9 B1 07 D8 F8 F4 88 92 70 21 4D 95
NM&gt;        :     5B 83 05 EB 9B FC 1B DF BF A1 29 12 9A C7 65 19
NM&gt;        :     F4 0F D1 C7 8B C9 65 16 25 92 9B D9 F4 B6 C1 CE
NM&gt;        :     2B 1E 14 D3 7B 48 C5 96 AA 48 C1 3B F3 5E 4F CF
NM&gt;        :             [ Another 142 bytes skipped ]
NM&gt;        :   }

NM&gt; Which looks ok to me. But Nettle's rsa_keypair_from_der wants the
NM&gt; contents of that BIT STRING only, not the complete object. Hava a look
NM&gt; at tools/pkcs1-conv.c, which I think is the only example code using
NM&gt; these functions.

Aha, thank you for the tip.  For the tests I don't need the generic ASN1
parser, just to extract the data, so I hard-coded the bitstring offsets
in nettle.el:

#+begin_src lisp
    ;; key generated with:
    ;; openssl genrsa -out privkey.pem 2048
    ;; openssl rsa -in privkey.pem -pubout &gt; pubkey.pem
    (let* ((key (substring "
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAreGA/Qky9W3izQV0kzba
7wKl/wzwxkbbQxvcUqUT1krgAbO/n1tYFjXdJZoWwbMO/qv7NRoMDY4yPWGpsQfY
+PSIknAhTZVbgwXrm/wb37+hKRKax2UZ9A/Rx4vJZRYlkpvZ9LbBziseFNN7SMWW
qkjBO/NeT8/I9mURDa+4RoYfT6ZwjTvt808PH7uIghk+MHAx9EMBAfafF1Jn9TqW
y+Hgdqik9sZteMvCumvGK4grSwzdfPO5I05tt/0I7QVPxlXbHIk/bBsE7mpgOxur
P0DAkFKtYDM7oZPBwB6X778ba2EEFKPpVIyzw/jlDPd9PB6gE6dixmax3Hlg69RI
EwIDAQAB
-----END PUBLIC KEY-----
" 28 426))
           ;; 24 skipped bytes are the header
           (key-bitstring (substring (base64-decode-string key) 24)))
    ;; invalid signature, valid key
    (should-not (nettle-rsa-verify "Test the Nettle RSA signature"
                                   "Test the Nettle RSA signature"
                                   key-bitstring
                                   "sha1"))
    ;; valid signature, valid key
    ; doesn't work; generated with "openssl rsautl -sign -in /tmp/test -inkey \
/tmp/privkey.pem" but contains other baggage  (should (nettle-rsa-verify "Test the \
Nettle RSA signature"  (decode-hex-string \
"abf710d920de0a210167e62995d5cb06fb0ff6a3f81e2f1965dd3f4716883ab61b7dec40d1ebde89b0657 \
473a434d0333177f183f71a9f4b84a49781b1e4bc440e042f2eb4441000ba07168cdb190c5aebba8c43342 \
0f6fc28b6997cbfee061170210bfa65294199e6d6c8c5e1a16421942371f6115d77263b859a75645b6b70d \
56f14ad378c8499318ff05eda9d24a61d854a3d7f6b67b037abb8d25e4b11ca3e42bdb823cfac34c70057e \
cd55cbb8449346c0824b46f6c668d14f1744bad7d05470953981df32fde24d2a1f27e58bf9e7d99b20b39b \
25844c53945dcbbd8b406e78bc0b8aee48c0ec8a26e70301eeeb12ba733e0baf7b82c8e25ac3ee89291") \
key-bitstring  "sha1")))
#+end_src

Take a look at the second test above; this is the signed text but it
contains baggage (including the original data).  This last test fails
currently (all the others in nettle.el pass).  Can you give me a similar
hint of how to extract just the signature, for testing purposes only?
The OpenSSL docs were not helpful in figuring out the structure of the
signed content.  In the comments I note how I generated the signature
and I can post the privkey.pem file if that would help.

I have cross-posted version 1 of the patch here and to the emacs-devel
mailing list for comments.  I hope the Emacs C syntax is not a big
impediment to your review.  Later I will add the PBKDF2 rewrite you
suggested, so please ignore that bit.

Most of the work has actually been in writing the tests, not the C-level
integration!

(I have to note that arcfour (RC4) generates a FPE sometimes in my
testing so I removed it from `test-nettle-002-ciphers'.  I will file a
bug separately on that if I can replicate it.)

NM&gt; BTW, you might want to have a look at the unfinished openpgp code in
NM&gt; Nettle (pgp.h, pgp-encode.c and rsa2openpgp.c). But it's not very useful
NM&gt; in the current state.

After I finish the first-level TODO items to complete the Emacs-Nettle
integration, I will certainly take a look at these files.  Thanks for
the pointer.

Ted


</body></email><email><emailId>20131129143506</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2013-11-29 14:35:06-0400</timestampReceived><subject>Re: Nettle-2.7.1 with static GMP error</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Date: Fri, 29 Nov 2013 14:02:05 +0100
&gt; Cc: Nettle Crypto Library &lt;nettle-bugs@lists.lysator.liu.se&gt;
&gt; 
&gt; Alexey Pavlov &lt;alexpux@gmail.com&gt; writes:
&gt; 
&gt; &gt; 2013/11/29 Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt; &gt;&gt; What failed? Can I repost your message to the list?
&gt; &gt;
&gt; &gt; I do it already. I receive subscribing message now.
&gt; 
&gt; Ok. I'm now cc:ing the list. Context: Link error when building a dynamic
&gt; libnettle.dll and libhogweed.dll, and statically linking to libgmp.a.

AFAIK, this cannot possibly work on Windows.  A DLL cannot depend on a
static library.  And if the linker is clever enough to copy the entire
libgmp into the DLL, you will have trouble while linking programs
against such a DLL, like the trouble we see here.

&gt; &gt;&gt; So you're building shared libraries for nettle, but you have a static
&gt; &gt;&gt; gmp library? The way I understand the error, the used gmp functions gets
&gt; &gt;&gt; copied into libhogweed.dll. Not sure if that is the best behavior.

No, the symbols from libgmp are copied into the libhogweed _import_
library libhogweed.dll.a.  The import library is a static library.

&gt; 1. The symbol __gmp_sub_n is defined in some object file included in
&gt;    libgmp.a, and nowhere in the nettle source or object code (and
&gt;    mini-gmp.c doesn't count, it's not involved in the link, and it uses
&gt;    different linker symbol names than the real gmp).
&gt; 
&gt; 2. This object file gets copied from libgmp.a into libhogweed.dll by the
&gt;    linker. Not sure if this is right; -lgmp was added to the libhogweed
&gt;    link command primarily to get dependencies between *shared* libraries
&gt;    right.
&gt; 
&gt; 3. You then link the executable ecc-mod-test.exe with -lhogweed and
&gt;    -lgmp. The linked sees two definitions of the symbol __gmpn_sub_n,
&gt;    one in libgmp.a, and one in libhogweed.dll, and it considers this an
&gt;    error.
&gt; 
&gt; What I don't understand, is why, in (3) above, the linker doesn't just
&gt; ignore the object in libgmp.a which defines the symbol.

It could be because the module sub_n.o, which is taken from libgmp.a,
is needed to satisfy other externals, and that module brings with it a
second definition of __gmpn_sub_n.

But anyway, I think this is unworkable on Windows.  If Alexey doesn't
want dependencies on shared libraries, he needs to build static
libraries from libhogweed and libnettle (I think --disable-shared at
configure time will achieve that effect).

</body></email><email><emailId>20131129155311</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-11-29 15:53:11-0400</timestampReceived><subject>Re: Nettle-2.7.1 with static GMP error</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt;&gt; Ok. I'm now cc:ing the list. Context: Link error when building a dynamic
&gt;&gt; libnettle.dll and libhogweed.dll, and statically linking to libgmp.a.
&gt;
&gt; AFAIK, this cannot possibly work on Windows.  A DLL cannot depend on a
&gt; static library.  And if the linker is clever enough to copy the entire
&gt; libgmp into the DLL, you will have trouble while linking programs
&gt; against such a DLL, like the trouble we see here.

Thanks. I wasn't entirely sure if this problem was windows-specific or
not.

And it's equally impossible to omit -lgmp when linking libhogweed.dll,
and only add -lgmp when linking the executable?

For ELF systems, if libhogweed is dynamic and libgmp is static, is it
still the right thing to do to link libhogweed with -lgmp, which will
copy needed gmp objects into libhogweed.so?

&gt; No, the symbols from libgmp are copied into the libhogweed _import_
&gt; library libhogweed.dll.a.  The import library is a static library.

I admit I don't understand all the fine details here. But that sounds
undesirable, the import library is intended to only contain thin glue to
the dll?

&gt; But anyway, I think this is unworkable on Windows.  If Alexey doesn't
&gt; want dependencies on shared libraries, he needs to build static
&gt; libraries from libhogweed and libnettle (I think --disable-shared at
&gt; configure time will achieve that effect).

Right, --disable-shared should do that.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131006163011</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-10-06 16:30:11-0400</timestampReceived><subject>Re: loading RSA keys from a PEM file</subject><body>

Ted Zlatanov &lt;tzz@lifelogs.com&gt; writes:

&gt; ;; valid signature, valid key
&gt; ; doesn't work; generated with "openssl rsautl -sign -in /tmp/test -inkey \
&gt; /tmp/privkey.pem" but contains other baggage (should (nettle-rsa-verify "Test the \
&gt; Nettle RSA signature" (decode-hex-string \
&gt; "abf710d920de0a210167e62995d5cb06fb0ff6a3f81e2f1965dd3f4716883ab61b7dec40d1ebde89b06 \
&gt; 57473a434d0333177f183f71a9f4b84a49781b1e4bc440e042f2eb4441000ba07168cdb190c5aebba8c4 \
&gt; 33420f6fc28b6997cbfee061170210bfa65294199e6d6c8c5e1a16421942371f6115d77263b859a75645 \
&gt; b6b70d56f14ad378c8499318ff05eda9d24a61d854a3d7f6b67b037abb8d25e4b11ca3e42bdb823cfac3 \
&gt; 4c70057ecd55cbb8449346c0824b46f6c668d14f1744bad7d05470953981df32fde24d2a1f27e58bf9e7 \
&gt; d99b20b39b25844c53945dcbbd8b406e78bc0b8aee48c0ec8a26e70301eeeb12ba733e0baf7b82c8e25ac3ee89291")
&gt;  key-bitstring
&gt; "sha1")))
&gt; #+end_src
&gt; 
&gt; Take a look at the second test above; this is the signed text but it
&gt; contains baggage (including the original data).

Are you sure it includes the data? If the hex string is interpreted as a
raw bignum, it's 2048 bits, which sounds plausible. I guess "Test the
Nettle RSA signature" is the mesage being signed? Maybe double check
that you didn't get a trailing newline or something when generating the
openssl signture.

I'm not very familiar with the openssl tools. What's the correct command
line to let openssl verify the signature using the given public key?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20131009165807</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-10-09 16:58:07-0400</timestampReceived><subject>Camellia reorg (was Re: AES interface)</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Camellia uses fewer subkeys for 128 bit keys than for 192 or 256 bit
&gt; keys. So this is a bit similar to AES, and I think an analogous reorg
&gt; would make sense.

I tried this out now. New header file below.

camellia192 and camellia256 are really the same, except for the key
schedule. Hence some #defines to make several camellia192 symbols
aliases to the corresponding camellia256 things. I don't quite like use
a define on the struct tag, but I hope that's ok. And maybe I should
substitute _CAMELLIA*_NKEYS for _CAMELLIA*_ROUNDS, since it's not
exactly a round count.

Comments appreciated.

Regards,
/Niels


/* camellia.h
 *
 * Copyright (C) 2006,2007
 * NTT (Nippon Telegraph and Telephone Corporation).
 *
 * Copyright (C) 2010, 2013 Niels Möller
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#ifndef NETTLE_CAMELLIA_H_INCLUDED
#define NETTLE_CAMELLIA_H_INCLUDED

#include "nettle-types.h"

#ifdef __cplusplus
extern "C" {
#endif

/* Name mangling */
#define camellia128_set_encrypt_key nettle_camellia128_set_encrypt_key
#define camellia128_set_decrypt_key nettle_camellia_set_decrypt_key
#define camellia128_invert_key nettle_camellia128_invert_key
#define camellia128_crypt nettle_camellia128_crypt

#define camellia192_set_encrypt_key nettle_camellia192_set_encrypt_key
#define camellia192_set_decrypt_key nettle_camellia192_set_decrypt_key

#define camellia256_set_encrypt_key nettle_camellia256_set_encrypt_key
#define camellia256_set_decrypt_key nettle_camellia256_set_decrypt_key
#define camellia256_invert_key nettle_camellia256_invert_key
#define camellia256_crypt nettle_camellia256_crypt


#define CAMELLIA_BLOCK_SIZE 16
/* Valid key sizes are 128, 192 or 256 bits (16, 24 or 32 bytes) */
#define CAMELLIA128_KEY_SIZE 16
#define CAMELLIA192_KEY_SIZE 24
#define CAMELLIA256_KEY_SIZE 32

/* For 128-bit keys, there are 18 regular rounds, pre- and
   post-whitening, and two FL and FLINV rounds, using a total of 26
   subkeys, each of 64 bit. For 192- and 256-bit keys, there are 6
   additional regular rounds and one additional FL and FLINV, using a
   total of 34 subkeys. */
/* The clever combination of subkeys imply one of the pre- and
   post-whitening keys is folded with the round keys, so that subkey
   #1 and the last one (#25 or #33) is not used. The result is that we
   have only 24 or 32 subkeys at the end of key setup. */

#define _CAMELLIA128_ROUNDS 24
#define _CAMELLIA256_ROUNDS 32

struct camellia128_ctx
{
  uint64_t keys[_CAMELLIA128_ROUNDS];
};

void
camellia128_set_encrypt_key(struct camellia128_ctx *ctx,
			    const uint8_t *key);

void
camellia128_set_decrypt_key(struct camellia128_ctx *ctx,
			    const uint8_t *key);

void
camellia128_invert_key(struct camellia128_ctx *dst,
		       const struct camellia128_ctx *src);
  
void
camellia128_crypt(const struct camellia128_ctx *ctx,
		  size_t length, uint8_t *dst,
		  const uint8_t *src);

struct camellia256_ctx
{
  uint64_t keys[_CAMELLIA256_ROUNDS];
};

void
camellia256_set_encrypt_key(struct camellia256_ctx *ctx,
			    const uint8_t *key);

void
camellia256_set_decrypt_key(struct camellia256_ctx *ctx,
			    const uint8_t *key);

void
camellia256_invert_key(struct camellia256_ctx *dst,
		       const struct camellia256_ctx *src);
  
void
camellia256_crypt(const struct camellia256_ctx *ctx,
		  size_t length, uint8_t *dst,
		  const uint8_t *src);

/* camellia192 is the same as camellia256, except for the key
   schedule. */
/* Slightly ugly with a #define on a struct tag, since it might cause
   surprises if also used as a name of a variable. */
#define camellia192_ctx camellia256_ctx

void
camellia192_set_encrypt_key(struct camellia256_ctx *ctx,
			    const uint8_t *key);

void
camellia192_set_decrypt_key(struct camellia256_ctx *ctx,
			    const uint8_t *key);

#define camellia192_invert_key camellia256_invert_key
#define camellia192_crypt camellia256_crypt

#ifdef  __cplusplus
}
#endif

#endif /* NETTLE_CAMELLIA_H_INCLUDED */


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20131015151723</emailId><senderName>Paul Tagliamonte</senderName><senderEmail>paultag@gmail.com</senderEmail><timestampReceived>2013-10-15 15:17:23-0400</timestampReceived><subject>Re: internal bug in pgp_put_public_rsa_key</subject><body>


Good morning, Niels,

On Tue, Oct 15, 2013 at 08:46:36AM +0200, Niels Möller wrote:
&gt; &gt; pgp_put_public_rsa_key seems to throw an assertion error:
&gt; 
&gt; Note that the pgp functions in Nettle are undocumented and unfinished.

Yeah, I noticed that in the source; but that never stoped me before! :)

&gt; Cool that anybody else is having a look at them.

Yeah! I've been a bit keen to learn a bit more about PGP in general, so
I figured I'd play around. Lo and behold I get the chance to read some
spec as well.

&gt; &gt; Can someone who groks the code confirm this?
&gt; 
&gt; Can't say I really grok the code either, I wrote those functions back in
&gt; 2007... But it looks fishy to me with two calls to pgp_put_header, using
&gt; the same tag value PGP_TAG_PUBLIC_KEY.

Yeah, to me as well.

&gt; If you have read the spec
&gt; recently, is there any way that could be correct?

I don't know yet. It seems like no, at least not for v4. After sending
this email, I tried to implement it myself a bit, and got a bit
further. My gut's telling me there's something wonky there.

&gt; I'd suggest deleting the second call to pgp_put_header (the one with the
&gt; PGP_LENGTH_TWO_OCTETS argument). The the correct body length should be
&gt; passed to the first pgp_put_header call, and the variable start, and the
&gt; assert, check that we really generate a packet body matching that
&gt; length.

Aye. I have that in a local copy of the function, but gpg was kicking
back exported keys - I'm thinking I might have to hack a bit on it.

&gt; In case you'd like to try to get some more of the pgp code in shape,
&gt; additional testcases would be a good place to start.

I think I'll do that, thank you!

&gt; The way I remember it, I tried passing the generated pckets to gpg, but
&gt; it was a bit difficult to get any interoperability by supporting only
&gt; the "new" openpgp formats. Things might have changed since then, of
&gt; course.

ACK. I'll see what I can learn / document.

&gt; 
&gt; Regards,
&gt; /Niels

Thanks for the quick reply!
  Paul

&gt; 
&gt; -- 
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
&gt; Internet email is subject to wholesale government surveillance.

-- 
#define sizeof(x) rand()
:wq

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20131016210303</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2013-10-16 21:03:03-0400</timestampReceived><subject>Curve25519 [was: Re: brainpool curves]</subject><body>


On 09/30/2013 08:46 AM, Nikos Mavrogiannopoulos wrote:

&gt; There has been lately an attempt to avoid the NIST's curves due to
&gt; suspicions about their generation. One of them are the brainpool curves=

&gt; at: http://tools.ietf.org/html/rfc5639
&gt; which seem to be sponsored by the German BSI. Having them in nettle
&gt; would be a good thing (the same authors are working on standardizing
&gt; these curves in TLS and PKIX).

Similarly, an implementation of Curve25519 [0] would probably also be
useful to have in the library, as it is also under active discussion in
several contexts.

	--dkg

[0] http://ed25519.cr.yp.to/


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20131017174902</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2013-10-17 17:49:02-0400</timestampReceived><subject>Re: Git repository down?</subject><body>

You wrote:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt; 
&gt; &gt; What's wrong with or missing from gitorious?
&gt; 
&gt; Nothing very fundamental, but I think it was a bit cumbersome to
&gt; install.

Then maybe gitorious was just overkill -- to me, I only need a git
repository available over ssh or https and a way to browse it via the
web (e.g., cgit or gitweb).

/Simon

</body></email><email><emailId>20130922192842</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-09-22 19:28:42-0400</timestampReceived><subject>Re: GCM vs SHA1</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; sha1 needs 80 rounds to process 64 input bytes. Each round needs some 15
&gt; instruction, and with sufficient independence for reasonable instruction
&gt; level parallelism. So that's roughly 20 instructions per byte. Nettle's
&gt; current x86_64 code seems to get down to 7.7 cycles/byte on the machine
&gt; I have here, with some room for further optimization. openssl gets it
&gt; down a bit further, to 6 cycles/byte.

[...]

&gt; I think my attemps at assembly implementation, which haven't made much
&gt; progress, suffer from memxor overhead. [...] Around 9-10 cycles/byte
&gt; (benchmarking the top-level gcm_update). I think I'd need to
&gt; reimplement the gcm_hash function, inlining the xoring of the input
&gt; data.

I just checked in a rewrite. Down to 7.5 cycles/byte on the above Intel
machine. I have a per-block iteration which isn't completely unrolled,
but without any subroutine calls and only two simple subloops running 7
iterations each. I get it to 252 instructions, executed, or almost 16
instructions per byte. So 7.5 cycles means I get two instructions
executed per cycle, which is the best possible on this cpu.

For some reason, the current loop is slower on my AMD machine, at 8.4
cycles per byte. *If* scheduling could be improved to get the maximum of
3 instructions per cycle, I'd get down to 5.5 cycles/byte or so.

The file in questions is
https://git.lysator.liu.se/nettle/nettle/blobs/master/x86_64/gcm-hash8.asm.


Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130929183203</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2013-09-29 18:32:03-0400</timestampReceived><subject>Re: AES interface</subject><body>

You wrote:

&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt; 
&gt; &gt; If you bump the ABI, is there any reason to keep backwards
&gt; &gt; compatible functions?
&gt; 
&gt; The ABI will break, but I'm also considering source-level "API"
&gt; compatibility. Which isn't an all-or-nothing issue; different
&gt; applications use different subsets of the API.

Sure.  If it was easier, one would want to for example build all
reverse-dependencies in Debian using an updated Nettle to see what
percentage of packages break and how... but this is not that simple to
do.

/Simon

</body></email><email><emailId>20130930124659</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-09-30 12:46:59-0400</timestampReceived><subject>brainpool curves</subject><body>

Hello,
 There has been lately an attempt to avoid the NIST's curves due to
suspicions about their generation. One of them are the brainpool curves
at: http://tools.ietf.org/html/rfc5639
which seem to be sponsored by the German BSI. Having them in nettle
would be a good thing (the same authors are working on standardizing
these curves in TLS and PKIX).

regards,
Nikos

</body></email><email><emailId>20130814112438</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-08-14 11:24:38-0400</timestampReceived><subject>GCM vs SHA1</subject><body>

Nikos noted (off list) that Nettle's gcm hashing is slower than sha1.
Which seems contrary to what's expected.

Should gcm be faster, or a lot faster, than sha1 in software (even
without fancy instructions for the gf2 arithmetic)?

Below is a first rough assembly implementation of the main step of gcm
hashing. Gives a speedup of about 20%, making it *slightly* faster than
sha1 on my system.

BTW, I'm back from some 40 days of travelling with my familiy, and I'm
just trying to remember how to do some hacking ;-)

Regards,
/Niels

diff --git a/Makefile.in b/Makefile.in
index ebc9357..c900c58 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -12,7 +12,8 @@ INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = $(INSTALL_PROGRAM) -s
 MKDIR_P = @MKDIR_P@
 
-OPT_ASM_SOURCES = @OPT_ASM_SOURCES@
+OPT_ASM_NETTLE_SOURCES = @OPT_ASM_NETTLE_SOURCES@
+OPT_ASM_HOGWEED_SOURCES = @OPT_ASM_HOGWEED_SOURCES@
 
 SUBDIRS = tools testsuite examples
 
@@ -179,10 +180,10 @@ DISTFILES = $(SOURCES) $(HEADERS) getopt.h .bootstrap run-tests \
 	nettle.texinfo nettle.info nettle.html nettle.pdf sha-example.c
 
 # Rules building static libraries
-nettle_OBJS = $(nettle_SOURCES:.c=.$(OBJEXT))
+nettle_OBJS = $(nettle_SOURCES:.c=.$(OBJEXT)) $(OPT_ASM_NETTLE_SOURCES:.asm=.$(OBJEXT))
 nettle_PURE_OBJS = $(nettle_OBJS:.$(OBJEXT)=.p$(OBJEXT))
 
-hogweed_OBJS = $(hogweed_SOURCES:.c=.$(OBJEXT)) $(OPT_ASM_SOURCES:.asm=.$(OBJEXT))
+hogweed_OBJS = $(hogweed_SOURCES:.c=.$(OBJEXT)) $(OPT_ASM_HOGWEED_SOURCES:.asm=.$(OBJEXT))
 hogweed_PURE_OBJS = $(hogweed_OBJS:.$(OBJEXT)=.p$(OBJEXT))
 
 libnettle.a: $(nettle_OBJS)
diff --git a/configure.ac b/configure.ac
index 3dd3a99..72da6d7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -266,14 +266,15 @@ asm_replace_list="aes-encrypt-internal.asm aes-decrypt-internal.asm \
 		sha3-permute.asm umac-nh.asm umac-nh-n.asm machine.m4"
 
 # Assembler files which generate additional object files if they are used.
-asm_optional_list=""
-
+asm_nettle_optional_list="gcm-gf-mul-8.asm"
+asm_hogweed_optional_list=""
 if test "x$enable_public_key" = "xyes" ; then
-  asm_optional_list="ecc-192-modp.asm ecc-224-modp.asm ecc-256-redc.asm \
-      ecc-384-modp.asm ecc-521-modp.asm"
+  asm_hogweed_optional_list="ecc-192-modp.asm ecc-224-modp.asm \
+    ecc-256-redc.asm ecc-384-modp.asm ecc-521-modp.asm"
 fi
 
-OPT_ASM_SOURCES=""
+OPT_ASM_NETTLE_SOURCES=""
+OPT_ASM_HOGWEED_SOURCES=""
 
 asm_file_list=""
 
@@ -291,18 +292,34 @@ if test "x$enable_assembler" = xyes ; then
     done
     dnl Workaround for AC_CONFIG_LINKS, which complains if we use the
     dnl same destination argument $tmp_f multiple times.
-    for tmp_o in $asm_optional_list ; do
+    for tmp_n in $asm_nettle_optional_list ; do
+      for asm_dir in $asm_path ; do
+	if test -f "$srcdir/$asm_dir/$tmp_n"; then
+	  asm_file_list="$asm_file_list $tmp_n"
+	  AC_CONFIG_LINKS($tmp_n:$asm_dir/$tmp_n)
+	  while read tmp_func ; do
+	    AC_DEFINE_UNQUOTED(HAVE_NATIVE_$tmp_func)
+	    eval HAVE_NATIVE_$tmp_func=yes
+	  done &lt;&lt;EOF
+[`sed -n 's/[^ 	]*PROLOGUE(_*\(nettle_\)*\([^)]*\)).*$/\2/p' &lt; "$srcdir/$asm_dir/$tmp_n"`]
+EOF
+	  OPT_ASM_NETTLE_SOURCES="$OPT_ASM_NETTLE_SOURCES $tmp_n"
+	  break
+	fi
+      done
+    done	
+    for tmp_h in $asm_hogweed_optional_list ; do
       for asm_dir in $asm_path ; do
-	if test -f "$srcdir/$asm_dir/$tmp_o"; then
-	  asm_file_list="$asm_file_list $tmp_o"
-	  AC_CONFIG_LINKS($tmp_o:$asm_dir/$tmp_o)
+	if test -f "$srcdir/$asm_dir/$tmp_h"; then
+	  asm_file_list="$asm_file_list $tmp_h"
+	  AC_CONFIG_LINKS($tmp_h:$asm_dir/$tmp_h)
 	  while read tmp_func ; do
 	    AC_DEFINE_UNQUOTED(HAVE_NATIVE_$tmp_func)
 	    eval HAVE_NATIVE_$tmp_func=yes
 	  done &lt;&lt;EOF
-[`sed -n 's/[^ 	]*PROLOGUE(_*\(nettle_\)*\([^)]*\)).*$/\2/p' &lt; "$srcdir/$asm_dir/$tmp_o"`]
+[`sed -n 's/[^ 	]*PROLOGUE(_*\(nettle_\)*\([^)]*\)).*$/\2/p' &lt; "$srcdir/$asm_dir/$tmp_h"`]
 EOF
-	  OPT_ASM_SOURCES="$OPT_ASM_SOURCES $tmp_o"
+	  OPT_ASM_HOGWEED_SOURCES="$OPT_ASM_HOGWEED_SOURCES $tmp_h"
 	  break
 	fi
       done
@@ -314,7 +331,8 @@ EOF
   fi
 fi
 
-AC_SUBST([OPT_ASM_SOURCES])
+AC_SUBST([OPT_ASM_NETTLE_SOURCES])
+AC_SUBST([OPT_ASM_HOGWEED_SOURCES])
 
 AH_VERBATIM([HAVE_NATIVE],
 [/* Define to 1 each of the following for which a native (ie. CPU specific)
@@ -328,7 +346,8 @@ AH_VERBATIM([HAVE_NATIVE],
 #undef HAVE_NATIVE_ecc_384_modp
 #undef HAVE_NATIVE_ecc_384_redc
 #undef HAVE_NATIVE_ecc_521_modp
-#undef HAVE_NATIVE_ecc_521_redc])
+#undef HAVE_NATIVE_ecc_521_redc
+#undef HAVE_NATIVE_gcm_gf_mul_8])
 
 # Besides getting correct dependencies, the explicit rules also tell
 # make that the .s files "ought to exist", so they are preferred over
diff --git a/gcm.c b/gcm.c
index 6893d51..7b387ba 100644
--- a/gcm.c
+++ b/gcm.c
@@ -214,6 +214,12 @@ gcm_gf_mul (union gcm_block *x, const union gcm_block *table)
   memcpy (x-&gt;b, Z.b, sizeof(Z));
 }
 # elif GCM_TABLE_BITS == 8
+#  if HAVE_NATIVE_gcm_gf_mul_8
+
+#define gcm_gf_mul _nettle_gcm_gf_mul_8
+void
+gcm_gf_mul (union gcm_block *x, const union gcm_block *y);
+#  else /* !HAVE_NATIVE_gcm_gf_mul_8 */
 static const uint16_t
 shift_table[0x100] = {
   W(00,00),W(01,c2),W(03,84),W(02,46),W(07,08),W(06,ca),W(04,8c),W(05,4e),
@@ -304,7 +310,7 @@ gcm_gf_mul (union gcm_block *x, const union gcm_block *table)
   gcm_gf_shift_8(&amp;Z);
   gcm_gf_add(x, &amp;Z, &amp;table[x-&gt;b[0]]);
 }
-
+#  endif /* ! HAVE_NATIVE_gcm_gf_mul_8 */
 # else /* GCM_TABLE_BITS != 8 */
 #  error Unsupported table size. 
 # endif /* GCM_TABLE_BITS != 8 */
diff --git a/x86_64/gcm-gf-mul-8.asm b/x86_64/gcm-gf-mul-8.asm
new file mode 100644
index 0000000..2296ba8
--- /dev/null
+++ b/x86_64/gcm-gf-mul-8.asm
@@ -0,0 +1,130 @@
+C nettle, low-level cryptographics library
+C 
+C Copyright (C) 2013, Niels MÃ¶ller
+C  
+C The nettle library is free software; you can redistribute it and/or modify
+C it under the terms of the GNU Lesser General Public License as published by
+C the Free Software Foundation; either version 2.1 of the License, or (at your
+C option) any later version.
+C 
+C The nettle library is distributed in the hope that it will be useful, but
+C WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+C or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+C License for more details.
+C 
+C You should have received a copy of the GNU Lesser General Public License
+C along with the nettle library; see the file COPYING.LIB.  If not, write to
+C the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+C MA 02111-1301, USA.
+
+C Register usage:
+
+define(&lt;XP&gt;, &lt;%rdi&gt;)
+define(&lt;TABLE&gt;, &lt;%rsi&gt;)
+define(&lt;XW&gt;, &lt;%rax&gt;)
+define(&lt;CNT&gt;, &lt;%ecx&gt;)
+define(&lt;Z0&gt;, &lt;%rdx&gt;)
+define(&lt;Z1&gt;, &lt;%r8&gt;)
+define(&lt;T0&gt;, &lt;%r9&gt;)
+define(&lt;T1&gt;, &lt;%r10&gt;)
+define(&lt;T2&gt;, &lt;%r11&gt;)
+define(&lt;SHIFT_TABLE&gt;, &lt;%rbx&gt;)
+	
+C The C code is 12.5 c/byte, slower than sha1 (10.6), while this code runs
+C at 10.2, slightly faster. Benchmarked on a low-end AMD E-350.
+
+	.file "gcm-gf-mul-8.asm"
+	
+	C void _gcm_gf_mul_8(union gcm_block *x, const union gcm_block *table)
+	.text
+	ALIGN(16)
+PROLOGUE(_nettle_gcm_gf_mul_8)
+	W64_ENTRY(2, 0)
+	push	%rbx
+	mov	8(XP), XW
+	rol	$8, XW
+	movzbl	LREG(XW), XREG(T0)
+	shl	$4, T0
+	mov	(TABLE, T0), Z0
+	mov	8(TABLE, T0), Z1
+	lea	.Lshift_table(%rip), SHIFT_TABLE
+	movl	$7, CNT
+	call	.Lmul_word
+	mov	(XP), XW
+	movl	$8, CNT
+	call	.Lmul_word
+	mov	Z0, (XP)
+	mov	Z1, 8(XP)
+	W64_EXIT(2, 0)
+	pop	%rbx
+	ret
+
+.Lmul_word:
+	C shift Z1, Z0, transforming
+	C +-----------------------+-----------------------+
+	C |15 14 13 12 11 10 09 08|07 06 05 04 03 02 01 00|
+	C +-----------------------+-----------------------+
+	C into
+	C +-----------------------+-----------------------+
+	C |14 13 12 11 10 09 08 07|06 05 04 03 02 01 00   |
+	C +-----------------------+-----------------+-----+
+	C                               xor         |T[15]|
+	C                                           +-----+
+	mov	Z1, T1
+	mov	Z0, T0
+	shl	$8, Z1		C Use shld?
+	shl	$8, Z0
+	shr	$56, T1
+	shr	$56, T0
+	movzwl	(SHIFT_TABLE, T1, 2), XREG(T1)
+	rol	$8, XW
+	add	T0, Z1
+	xor	T1, Z0
+	movzbl	LREG(XW), XREG(T2)
+	shl	$4, T2
+	xor	(TABLE, T2), Z0
+	xor	8(TABLE, T2), Z1
+	decl	CNT
+	jne	.Lmul_word
+	ret
+	
+EPILOGUE(_nettle_gcm_gf_mul_8)
+
+define(&lt;W&gt;, &lt;0x$2$1&gt;)
+	.section .rodata
+	ALIGN(2)
+.Lshift_table:
+.hword W(00,00),W(01,c2),W(03,84),W(02,46),W(07,08),W(06,ca),W(04,8c),W(05,4e)
+.hword W(0e,10),W(0f,d2),W(0d,94),W(0c,56),W(09,18),W(08,da),W(0a,9c),W(0b,5e)
+.hword W(1c,20),W(1d,e2),W(1f,a4),W(1e,66),W(1b,28),W(1a,ea),W(18,ac),W(19,6e)
+.hword W(12,30),W(13,f2),W(11,b4),W(10,76),W(15,38),W(14,fa),W(16,bc),W(17,7e)
+.hword W(38,40),W(39,82),W(3b,c4),W(3a,06),W(3f,48),W(3e,8a),W(3c,cc),W(3d,0e)
+.hword W(36,50),W(37,92),W(35,d4),W(34,16),W(31,58),W(30,9a),W(32,dc),W(33,1e)
+.hword W(24,60),W(25,a2),W(27,e4),W(26,26),W(23,68),W(22,aa),W(20,ec),W(21,2e)
+.hword W(2a,70),W(2b,b2),W(29,f4),W(28,36),W(2d,78),W(2c,ba),W(2e,fc),W(2f,3e)
+.hword W(70,80),W(71,42),W(73,04),W(72,c6),W(77,88),W(76,4a),W(74,0c),W(75,ce)
+.hword W(7e,90),W(7f,52),W(7d,14),W(7c,d6),W(79,98),W(78,5a),W(7a,1c),W(7b,de)
+.hword W(6c,a0),W(6d,62),W(6f,24),W(6e,e6),W(6b,a8),W(6a,6a),W(68,2c),W(69,ee)
+.hword W(62,b0),W(63,72),W(61,34),W(60,f6),W(65,b8),W(64,7a),W(66,3c),W(67,fe)
+.hword W(48,c0),W(49,02),W(4b,44),W(4a,86),W(4f,c8),W(4e,0a),W(4c,4c),W(4d,8e)
+.hword W(46,d0),W(47,12),W(45,54),W(44,96),W(41,d8),W(40,1a),W(42,5c),W(43,9e)
+.hword W(54,e0),W(55,22),W(57,64),W(56,a6),W(53,e8),W(52,2a),W(50,6c),W(51,ae)
+.hword W(5a,f0),W(5b,32),W(59,74),W(58,b6),W(5d,f8),W(5c,3a),W(5e,7c),W(5f,be)
+.hword W(e1,00),W(e0,c2),W(e2,84),W(e3,46),W(e6,08),W(e7,ca),W(e5,8c),W(e4,4e)
+.hword W(ef,10),W(ee,d2),W(ec,94),W(ed,56),W(e8,18),W(e9,da),W(eb,9c),W(ea,5e)
+.hword W(fd,20),W(fc,e2),W(fe,a4),W(ff,66),W(fa,28),W(fb,ea),W(f9,ac),W(f8,6e)
+.hword W(f3,30),W(f2,f2),W(f0,b4),W(f1,76),W(f4,38),W(f5,fa),W(f7,bc),W(f6,7e)
+.hword W(d9,40),W(d8,82),W(da,c4),W(db,06),W(de,48),W(df,8a),W(dd,cc),W(dc,0e)
+.hword W(d7,50),W(d6,92),W(d4,d4),W(d5,16),W(d0,58),W(d1,9a),W(d3,dc),W(d2,1e)
+.hword W(c5,60),W(c4,a2),W(c6,e4),W(c7,26),W(c2,68),W(c3,aa),W(c1,ec),W(c0,2e)
+.hword W(cb,70),W(ca,b2),W(c8,f4),W(c9,36),W(cc,78),W(cd,ba),W(cf,fc),W(ce,3e)
+.hword W(91,80),W(90,42),W(92,04),W(93,c6),W(96,88),W(97,4a),W(95,0c),W(94,ce)
+.hword W(9f,90),W(9e,52),W(9c,14),W(9d,d6),W(98,98),W(99,5a),W(9b,1c),W(9a,de)
+.hword W(8d,a0),W(8c,62),W(8e,24),W(8f,e6),W(8a,a8),W(8b,6a),W(89,2c),W(88,ee)
+.hword W(83,b0),W(82,72),W(80,34),W(81,f6),W(84,b8),W(85,7a),W(87,3c),W(86,fe)
+.hword W(a9,c0),W(a8,02),W(aa,44),W(ab,86),W(ae,c8),W(af,0a),W(ad,4c),W(ac,8e)
+.hword W(a7,d0),W(a6,12),W(a4,54),W(a5,96),W(a0,d8),W(a1,1a),W(a3,5c),W(a2,9e)
+.hword W(b5,e0),W(b4,22),W(b6,64),W(b7,a6),W(b2,e8),W(b3,2a),W(b1,6c),W(b0,ae)
+.hword W(bb,f0),W(ba,32),W(b8,74),W(b9,b6),W(bc,f8),W(bd,3a),W(bf,7c),W(be,be)
+	
+	

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130621072138</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-06-21 07:21:38-0400</timestampReceived><subject>Re: query on nettle support.</subject><body>

manish kanchan &lt;manishdkanchan00@gmail.com&gt; writes:

&gt; 1. Does nettle support on PKCS1 encoding fro RSA encrytpion and
&gt; signing?

Yes, if you are asking about the padding used internally. The resulting
signatures are simply represented as mpz_t bignums, and you have to
encode and decode them to the representation you need for your protocol
or file format of interest.

&gt; 2. In the PrivateKey structure, Is the d ( private expoenent ) never
&gt; used?

It's not used. It is set by rsa_generate_keypair, though.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130621201245</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-06-21 20:12:45-0400</timestampReceived><subject>Re: Supported Algorithms/Key Format</subject><body>

Mallikarjun Bailamanavar &lt;mallugb@gmail.com&gt; writes:

&gt; - Does nettle not support PKCS#1 v2.1 padding mechanisms e.g.
&gt; RSASSA-PSS?

It doesn't.

&gt; - Does nettle not support exponent format for private key?. Meaning private
&gt; key is made up of modulus and private exponent.

No, it uses CRT optimization and the auxillary data needed for that,
including the two secret factors. If you have only n and d, it's possible
to recover the factorization (you need also the public exponent e). One
could add functions for using only d to nettle, but so far that hasn't
seemed to be an important feature.

&gt; - Is there an API for raw RSA crypto operation? Raw meaning, API must not
&gt; do any encoding with input data but just has to sign/encrypt it.

See rsa_compute_root. Or if you don't want to use CRT, just use GMP's
mpz_powm or mpz_powm_sec.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130625153221</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-06-25 15:32:21-0400</timestampReceived><subject>EAX mode</subject><body>

For fun, I've tried implementing the EAX mode for "authenticated
encryption with associated data". Patch below. It's pretty simple, the
main file, eax.c, is only some 150 lines including comments.

Comments appreciated, particularly on the interface.

Some features suggested in the paper,
http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf, and currently not
implemented:

1. There's no interface for providing the nonce incrementally. I don't
   think that's needed. In any case, the nonce must be provided before
   any of the plaintext can be processed. The interface could be
   extended if there are any reasonable use-cases.

2. There's no interface for reusing the same associated data for
   multiple messages, which might be an important optimization in some
   cases. I don't quite like the suggestion that not providing any
   associated data should imply reuse of the previous message; it seems
   cleaner that not providing associated data means that the associated
   data is the empty string. So some additional functions may be needed
   to provide that feature (if it is deemed important enough).
   
For blocking, the convention is the same as for the CTR and GCM
implementations: When the message (or associated data) is provided using
multiple calls to _encrypt (or _decrypt or _update), the data size for
each call, except the final one, *must* be a multiple of the block size.

Regards,
/Niels


diff --git a/Makefile.in b/Makefile.in
index ebc9357..e7eb2e0 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -74,8 +74,8 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 cast128.c cast128-meta.c \
 		 blowfish.c \
 		 cbc.c ctr.c gcm.c gcm-aes.c \
-		 des.c \
-		 des3.c des-compat.c \
+		 des.c des3.c des-compat.c \
+		 eax.c eax-aes.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
 		 pbkdf2.c pbkdf2-hmac-sha1.c pbkdf2-hmac-sha256.c \
diff --git a/eax-aes.c b/eax-aes.c
index e69de29..24a5560 100644
--- a/eax-aes.c
+++ b/eax-aes.c
@@ -0,0 +1,70 @@
+/* eax-aes.c
+ *
+ * EAX mode using AES as the underlying cipher.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2011, 2013 Niels MÃ¶ller
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "eax.h"
+
+void
+eax_aes_set_key(struct eax_aes_ctx *ctx, size_t length, const uint8_t *key)
+{
+  EAX_SET_KEY(ctx, aes_set_encrypt_key, aes_encrypt, length, key);
+}
+
+void
+eax_aes_set_nonce(struct eax_aes_ctx *ctx,
+	       size_t length, const uint8_t *iv)
+{
+  EAX_SET_NONCE(ctx, aes_encrypt, length, iv);
+}
+
+void
+eax_aes_update(struct eax_aes_ctx *ctx, size_t length, const uint8_t *data)
+{
+  EAX_UPDATE(ctx, aes_encrypt, length, data);
+}
+
+void
+eax_aes_encrypt(struct eax_aes_ctx *ctx,
+		size_t length, uint8_t *dst, const uint8_t *src)
+{
+  EAX_ENCRYPT(ctx, aes_encrypt, length, dst, src);
+}
+
+void
+eax_aes_decrypt(struct eax_aes_ctx *ctx,
+		size_t length, uint8_t *dst, const uint8_t *src)
+{
+  EAX_DECRYPT(ctx, aes_encrypt, length, dst, src);
+}
+
+void
+eax_aes_digest(struct eax_aes_ctx *ctx,
+	       size_t length, uint8_t *digest)
+{
+  EAX_DIGEST(ctx, aes_encrypt, length, digest);
+}
diff --git a/eax.c b/eax.c
index e69de29..ec0dda9 100644
--- a/eax.c
+++ b/eax.c
@@ -0,0 +1,152 @@
+/* eax.c
+ *
+ * EAX mode, see http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Niels MÃ¶ller
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "eax.h"
+
+#include "ctr.h"
+#include "memxor.h"
+
+static void
+omac_init (uint8_t *state, unsigned t)
+{
+  memset (state, 0, EAX_BLOCK_SIZE - 1);
+  state[EAX_BLOCK_SIZE - 1] = t;
+}
+
+static void
+omac_update (uint8_t *state, const struct eax_key *key,
+	     void *cipher, nettle_crypt_func *f,
+	     size_t length, const uint8_t *data)
+{
+  for (; length &gt;= EAX_BLOCK_SIZE;
+       length -= EAX_BLOCK_SIZE, data += EAX_BLOCK_SIZE)
+    {
+      f (cipher, EAX_BLOCK_SIZE, state, state);
+      memxor (state, data, EAX_BLOCK_SIZE);
+    }
+  if (length &gt; 0)
+    {
+      /* Allowed only for the last call */
+      f (cipher, EAX_BLOCK_SIZE, state, state);
+      memxor (state, data, length);
+      state[length] ^= 0x80;
+      /* XOR with (P ^ B), since the digest processing
+       * unconditionally XORs with B */
+      memxor (state, key-&gt;pad_partial, EAX_BLOCK_SIZE);
+    }
+}
+
+static void
+omac_final (uint8_t *state, const struct eax_key *key,
+	    void *cipher, nettle_crypt_func *f)
+{
+  memxor (state, key-&gt;pad_block, EAX_BLOCK_SIZE);
+  f (cipher, EAX_BLOCK_SIZE, state, state);
+}
+
+/* Allows r == a */
+static void
+gf2_double (uint8_t *r, const uint8_t *a)
+{
+  unsigned high = - (a[0] &gt;&gt; 7);
+  unsigned i;
+  /* Shift left */
+  for (i = 0; i &lt; EAX_BLOCK_SIZE - 1; i++)
+    r[i] = (a[i] &lt;&lt; 1) + (a[i+1] &gt;&gt; 7);
+
+  /* Wrap around for x^{128} = x^7 + x^2 + x + 1 */
+  r[EAX_BLOCK_SIZE - 1] = (a[EAX_BLOCK_SIZE - 1] &lt;&lt; 1) ^ (high &amp; 0x87);
+}
+
+void
+eax_set_key (struct eax_key *key, void *cipher, nettle_crypt_func *f)
+{
+  static const uint8_t zero_block[EAX_BLOCK_SIZE];
+  f (cipher, EAX_BLOCK_SIZE, key-&gt;pad_block, zero_block);
+  gf2_double (key-&gt;pad_block, key-&gt;pad_block);
+  gf2_double (key-&gt;pad_partial, key-&gt;pad_block);
+  memxor (key-&gt;pad_partial, key-&gt;pad_block, EAX_BLOCK_SIZE);
+}
+
+void
+eax_set_nonce (struct eax_ctx *eax, const struct eax_key *key,
+	       void *cipher, nettle_crypt_func *f,
+	       size_t nonce_length, const uint8_t *nonce)
+{
+  omac_init (eax-&gt;omac_nonce, 0);
+  omac_update (eax-&gt;omac_nonce, key, cipher, f, nonce_length, nonce);
+  omac_final (eax-&gt;omac_nonce, key, cipher, f);
+  memcpy (eax-&gt;ctr, eax-&gt;omac_nonce, EAX_BLOCK_SIZE);
+
+  omac_init (eax-&gt;omac_data, 1);
+  omac_init (eax-&gt;omac_message, 2);
+}
+
+void
+eax_update (struct eax_ctx *eax, const struct eax_key *key,
+	    void *cipher, nettle_crypt_func *f,
+	    size_t data_length, const uint8_t *data)
+{
+  omac_update (eax-&gt;omac_data, key, cipher, f, data_length, data);
+}
+
+void
+eax_encrypt (struct eax_ctx *eax, const struct eax_key *key,
+	     void *cipher, nettle_crypt_func *f,
+	     size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ctr_crypt (cipher, f, EAX_BLOCK_SIZE, eax-&gt;ctr, length, dst, src);
+  omac_update (eax-&gt;omac_message, key, cipher, f, length, dst);
+}
+
+void
+eax_decrypt (struct eax_ctx *eax, const struct eax_key *key,
+	     void *cipher, nettle_crypt_func *f,
+	     size_t length, uint8_t *dst, const uint8_t *src)
+{
+  omac_update (eax-&gt;omac_message, key, cipher, f, length, src);
+  ctr_crypt (cipher, f, EAX_BLOCK_SIZE, eax-&gt;ctr, length, dst, src);
+}
+
+void
+eax_digest (struct eax_ctx *eax, const struct eax_key *key,
+	    void *cipher, nettle_crypt_func *f,
+	    size_t length, uint8_t *digest)
+{
+  assert (length &gt; 0);
+  assert (length &lt;= EAX_BLOCK_SIZE);
+  omac_final (eax-&gt;omac_data, key, cipher, f);
+  omac_final (eax-&gt;omac_message, key, cipher, f);
+
+  memxor (eax-&gt;omac_nonce, eax-&gt;omac_data, length);
+  memxor3 (digest, eax-&gt;omac_nonce, eax-&gt;omac_message, length);
+}
diff --git a/eax.h b/eax.h
index e69de29..0177767 100644
--- a/eax.h
+++ b/eax.h
@@ -0,0 +1,169 @@
+/* eax.h
+ *
+ * EAX mode, see http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Niels MÃ¶ller
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#ifndef NETTLE_EAX_H_INCLUDED
+#define NETTLE_EAX_H_INCLUDED
+
+#include "aes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define eax_set_key nettle_eax_set_key
+#define eax_set_nonce nettle_eax_set_nonce
+#define eax_update nettle_eax_update
+#define eax_encrypt nettle_eax_encrypt
+#define eax_decrypt nettle_eax_decrypt
+#define eax_digest nettle_eax_digest
+
+#define eax_aes_set_key nettle_eax_aes_set_key
+#define eax_aes_set_nonce nettle_eax_aes_set_nonce
+#define eax_aes_update nettle_eax_aes_update
+#define eax_aes_encrypt nettle_eax_aes_encrypt
+#define eax_aes_decrypt nettle_eax_aes_decrypt
+#define eax_aes_digest nettle_eax_aes_digest
+
+/* Restricted to block ciphers with 128 bit block size. FIXME: Reflect
+   this in naming? */
+
+#define EAX_BLOCK_SIZE 16
+
+/* FIXME: Ensure nice alignment. See gcm.h, union gcm_block. */
+
+/* Values independent of message and nonce */
+struct eax_key
+{
+  uint8_t pad_block[EAX_BLOCK_SIZE];
+  uint8_t pad_partial[EAX_BLOCK_SIZE];
+};
+
+struct eax_ctx
+{
+  uint8_t omac_nonce[EAX_BLOCK_SIZE];
+  uint8_t omac_data[EAX_BLOCK_SIZE];
+  uint8_t omac_message[EAX_BLOCK_SIZE];
+  uint8_t ctr[EAX_BLOCK_SIZE];
+};
+
+void
+eax_set_key (struct eax_key *key, void *cipher, nettle_crypt_func *f);
+
+void
+eax_set_nonce (struct eax_ctx *eax, const struct eax_key *key,
+	       void *cipher, nettle_crypt_func *f,
+	       size_t nonce_length, const uint8_t *nonce);
+
+void
+eax_update (struct eax_ctx *eax, const struct eax_key *key,
+	    void *cipher, nettle_crypt_func *f,
+	    size_t data_length, const uint8_t *data);
+
+void
+eax_encrypt (struct eax_ctx *eax, const struct eax_key *key,
+	     void *cipher, nettle_crypt_func *f,
+	     size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+eax_decrypt (struct eax_ctx *eax, const struct eax_key *key,
+	     void *cipher, nettle_crypt_func *f,
+	     size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+eax_digest (struct eax_ctx *eax, const struct eax_key *key,
+	    void *cipher, nettle_crypt_func *f,
+	    size_t length, uint8_t *digest);
+
+#define EAX_CTX(type) \
+  { type cipher; struct eax_key key; struct eax_ctx eax; }
+
+#define EAX_SET_KEY(ctx, set_key, encrypt, length, data)		\
+  do {									\
+    (set_key)(&amp;(ctx)-&gt;cipher, (length), (data));			\
+    if (0) (encrypt) (&amp;(ctx)-&gt;cipher, 0, (void *) 0, (void *) 0);	\
+    eax_set_key (&amp;(ctx)-&gt;key, &amp;(ctx)-&gt;cipher, (nettle_crypt_func *) encrypt); \
+  } while (0)
+
+#define EAX_SET_NONCE(ctx, encrypt, length, nonce) \
+  (0 ? (encrypt) (&amp;(ctx)-&gt;cipher, 0, (void *) 0, (void *) 0)	\
+   : eax_set_nonce (&amp;(ctx)-&gt;eax, &amp;(ctx)-&gt;key,			\
+		    &amp;(ctx)-&gt;cipher, (nettle_crypt_func *) (encrypt),	\
+		    (length), (nonce)))
+
+#define EAX_UPDATE(ctx, encrypt, length, data)				\
+  (0 ? (encrypt) (&amp;(ctx)-&gt;cipher, 0, (void *) 0, (void *) 0)		\
+   : eax_update (&amp;(ctx)-&gt;eax, &amp;(ctx)-&gt;key,				\
+		 &amp;(ctx)-&gt;cipher, (nettle_crypt_func *) (encrypt),	\
+		 (length), (data)))
+
+#define EAX_ENCRYPT(ctx, encrypt, length, dst, src)			\
+  (0 ? (encrypt) (&amp;(ctx)-&gt;cipher, 0, (void *) 0, (void *) 0)		\
+   : eax_encrypt (&amp;(ctx)-&gt;eax, &amp;(ctx)-&gt;key,				\
+		 &amp;(ctx)-&gt;cipher, (nettle_crypt_func *) (encrypt),	\
+		  (length), (dst), (src)))
+
+#define EAX_DECRYPT(ctx, encrypt, length, dst, src)			\
+  (0 ? (encrypt) (&amp;(ctx)-&gt;cipher, 0, (void *) 0, (void *) 0)		\
+   : eax_decrypt (&amp;(ctx)-&gt;eax, &amp;(ctx)-&gt;key,				\
+		 &amp;(ctx)-&gt;cipher, (nettle_crypt_func *) (encrypt),	\
+		  (length), (dst), (src)))
+
+#define EAX_DIGEST(ctx, encrypt, length, digest)			\
+  (0 ? (encrypt) (&amp;(ctx)-&gt;cipher, 0, (void *) 0, (void *) 0)		\
+   : eax_digest (&amp;(ctx)-&gt;eax, &amp;(ctx)-&gt;key,				\
+		 &amp;(ctx)-&gt;cipher, (nettle_crypt_func *) (encrypt),	\
+		 (length), (digest)))
+
+struct eax_aes_ctx EAX_CTX(struct aes_ctx);
+
+void
+eax_aes_set_key(struct eax_aes_ctx *ctx,
+		size_t length, const uint8_t *key);
+
+void
+eax_aes_set_nonce(struct eax_aes_ctx *ctx,
+		  size_t length, const uint8_t *iv);
+
+void
+eax_aes_update(struct eax_aes_ctx *ctx,
+	       size_t length, const uint8_t *data);
+
+void
+eax_aes_encrypt(struct eax_aes_ctx *ctx,
+		size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+eax_aes_decrypt(struct eax_aes_ctx *ctx,
+		size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+eax_aes_digest(struct eax_aes_ctx *ctx, size_t length, uint8_t *digest);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_EAX_H_INCLUDED */
diff --git a/nettle-internal.c b/nettle-internal.c
index 5cd5828..f6ff864 100644
--- a/nettle-internal.c
+++ b/nettle-internal.c
@@ -34,6 +34,7 @@
 #include "nettle-internal.h"
 #include "blowfish.h"
 #include "des.h"
+#include "eax.h"
 #include "gcm.h"
 #include "salsa20.h"
 
@@ -112,3 +113,12 @@ const struct nettle_aead
 nettle_gcm_aes192 = _NETTLE_AEAD(gcm, GCM, aes, 192);
 const struct nettle_aead
 nettle_gcm_aes256 = _NETTLE_AEAD(gcm, GCM, aes, 256);
+
+#define eax_aes_set_iv eax_aes_set_nonce
+
+const struct nettle_aead
+nettle_eax_aes128 = _NETTLE_AEAD(eax, EAX, aes, 128);
+const struct nettle_aead
+nettle_eax_aes192 = _NETTLE_AEAD(eax, EAX, aes, 192);
+const struct nettle_aead
+nettle_eax_aes256 = _NETTLE_AEAD(eax, EAX, aes, 256);
diff --git a/nettle-internal.h b/nettle-internal.h
index e094064..d9f1195 100644
--- a/nettle-internal.h
+++ b/nettle-internal.h
@@ -127,4 +127,8 @@ extern const struct nettle_aead nettle_gcm_twofish128;
 extern const struct nettle_aead nettle_gcm_twofish192;
 extern const struct nettle_aead nettle_gcm_twofish256;
 
+extern const struct nettle_aead nettle_eax_aes128;
+extern const struct nettle_aead nettle_eax_aes192;
+extern const struct nettle_aead nettle_eax_aes256;
+
 #endif /* NETTLE_INTERNAL_H_INCLUDED */
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 93ba9a8..5549fc0 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -103,6 +103,9 @@ ctr-test$(EXEEXT): ctr-test.$(OBJEXT)
 gcm-test$(EXEEXT): gcm-test.$(OBJEXT)
 	$(LINK) gcm-test.$(OBJEXT) $(TEST_OBJS) -o gcm-test$(EXEEXT)
 
+eax-test$(EXEEXT): eax-test.$(OBJEXT)
+	$(LINK) eax-test.$(OBJEXT) $(TEST_OBJS) -o eax-test$(EXEEXT)
+
 hmac-test$(EXEEXT): hmac-test.$(OBJEXT)
 	$(LINK) hmac-test.$(OBJEXT) $(TEST_OBJS) -o hmac-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index bf0e53c..4a4aa69 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -25,7 +25,8 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    sha3-384-test.c sha3-512-test.c \
 		    serpent-test.c twofish-test.c \
 		    knuth-lfib-test.c \
-		    cbc-test.c ctr-test.c gcm-test.c hmac-test.c umac-test.c \
+		    cbc-test.c ctr-test.c gcm-test.c eax-test \
+		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c meta-armor-test.c \
 		    buffer-test.c yarrow-test.c pbkdf2-test.c
 
diff --git a/testsuite/eax-test.c b/testsuite/eax-test.c
index e69de29..5fe0b3f 100644
--- a/testsuite/eax-test.c
+++ b/testsuite/eax-test.c
@@ -0,0 +1,87 @@
+#include "testutils.h"
+#include "nettle-internal.h"
+
+void
+test_main(void)
+{
+  /* From the EAX specification, http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf */
+  test_aead(&amp;nettle_eax_aes128,
+	    SHEX("233952DEE4D5ED5F9B9C6D6FF80FF478"),	/* key */
+	    SHEX("6BFB914FD07EAE6B"),			/* auth data */
+	    SHEX(""),					/* plaintext */
+	    SHEX(""),					/* ciphertext */
+	    SHEX("62EC67F9C3A4A407FCB2A8C49031A8B3"),	/* nonce */
+	    SHEX("E037830E8389F27B025A2D6527E79D01"));	/* tag */
+
+  test_aead(&amp;nettle_eax_aes128,
+	    SHEX("91945D3F4DCBEE0BF45EF52255F095A4"),
+	    SHEX("FA3BFD4806EB53FA"),
+	    SHEX("F7FB"),
+	    SHEX("19DD"),
+	    SHEX("BECAF043B0A23D843194BA972C66DEBD"),
+	    SHEX("5C4C9331049D0BDAB0277408F67967E5"));
+  
+  test_aead(&amp;nettle_eax_aes128,
+	    SHEX("01F74AD64077F2E704C0F60ADA3DD523"),
+	    SHEX("234A3463C1264AC6"),
+	    SHEX("1A47CB4933"),
+	    SHEX("D851D5BAE0"),
+	    SHEX("70C3DB4F0D26368400A10ED05D2BFF5E"),
+	    SHEX("3A59F238A23E39199DC9266626C40F80"));
+
+  test_aead(&amp;nettle_eax_aes128,
+	    SHEX("D07CF6CBB7F313BDDE66B727AFD3C5E8"),
+	    SHEX("33CCE2EABFF5A79D"),
+	    SHEX("481C9E39B1"),
+	    SHEX("632A9D131A"),
+	    SHEX("8408DFFF3C1A2B1292DC199E46B7D617"),
+	    SHEX("D4C168A4225D8E1FF755939974A7BEDE"));
+
+  test_aead(&amp;nettle_eax_aes128,
+	    SHEX("35B6D0580005BBC12B0587124557D2C2"),
+	    SHEX("AEB96EAEBE2970E9"),
+	    SHEX("40D0C07DA5E4"),
+	    SHEX("071DFE16C675"),
+	    SHEX("FDB6B06676EEDC5C61D74276E1F8E816"),
+	    SHEX("CB0677E536F73AFE6A14B74EE49844DD"));
+
+  test_aead(&amp;nettle_eax_aes128,
+	    SHEX("BD8E6E11475E60B268784C38C62FEB22"),
+	    SHEX("D4482D1CA78DCE0F"),
+	    SHEX("4DE3B35C3FC039245BD1FB7D"),
+	    SHEX("835BB4F15D743E350E728414"),
+	    SHEX("6EAC5C93072D8E8513F750935E46DA1B"),
+	    SHEX("ABB8644FD6CCB86947C5E10590210A4F"));
+
+  test_aead(&amp;nettle_eax_aes128,
+	    SHEX("7C77D6E813BED5AC98BAA417477A2E7D"),
+	    SHEX("65D2017990D62528"),
+	    SHEX("8B0A79306C9CE7ED99DAE4F87F8DD61636"),
+	    SHEX("02083E3979DA014812F59F11D52630DA30"),
+	    SHEX("1A8C98DCD73D38393B2BF1569DEEFC19"),
+	    SHEX("137327D10649B0AA6E1C181DB617D7F2"));
+  
+  test_aead(&amp;nettle_eax_aes128,
+	    SHEX("5FFF20CAFAB119CA2FC73549E20F5B0D"),
+	    SHEX("54B9F04E6A09189A"),
+	    SHEX("1BDA122BCE8A8DBAF1877D962B8592DD2D56"),
+	    SHEX("2EC47B2C4954A489AFC7BA4897EDCDAE8CC3"),
+	    SHEX("DDE59B97D722156D4D9AFF2BC7559826"),
+	    SHEX("3B60450599BD02C96382902AEF7F832A"));
+  
+  test_aead(&amp;nettle_eax_aes128,
+	    SHEX("A4A4782BCFFD3EC5E7EF6D8C34A56123"),
+	    SHEX("899A175897561D7E"),
+	    SHEX("6CF36720872B8513F6EAB1A8A44438D5EF11"),
+	    SHEX("0DE18FD0FDD91E7AF19F1D8EE8733938B1E8"),
+	    SHEX("B781FCF2F75FA5A8DE97A9CA48E522EC"),
+	    SHEX("E7F6D2231618102FDB7FE55FF1991700"));
+  
+  test_aead(&amp;nettle_eax_aes128,
+	    SHEX("8395FCF1E95BEBD697BD010BC766AAC3"),
+	    SHEX("126735FCC320D25A"),
+	    SHEX("CA40D7446E545FFAED3BD12A740A659FFBBB3CEAB7"),
+	    SHEX("CB8920F87A6C75CFF39627B56E3ED197C552D295A7"),
+	    SHEX("22E7ADD93CFC6393C57EC0B3C17D6B44"),
+	    SHEX("CFC46AFC253B4652B1AF3795B124AB6E"));
+}

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130503104709</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-05-03 10:47:09-0400</timestampReceived><subject>Portable rotates</subject><body>

I'm rewriting the cast128 key schedule, to get rid of false warnings, and
avoid lots of conditions, and to separate the rotation and the mask
subkeys.

Then I noticed a portability problem with the rotation macros,

  #define ROTL32(n,x) (((x)&lt;&lt;(n)) | ((x)&gt;&gt;(32-(n))))

For n == 0, this will work on most machines, but it's not portable,
since x &gt;&gt; 32 gives undefined behaviour according to the C spec (when x
is a 32-bit type). (On typical hardware, the result of x &gt;&gt; 32 will be
either x or 0, and the rotation macro gives the intended result in
either case).

In most of nettle, there's no problem, because rotation counts are
constant and non-zero.

cast128 is an exception, with key-dependent rotation counts, which can
well be zero (don't know if that's exercised by the test suite, though).

A fix is to redefine the macro as

  #define ROTL32(n,x) (((x)&lt;&lt;(n)) | ((x)&gt;&gt;((-(n))&amp;31)))

It should make no difference when n is constant, but for cast128, this
portability fix makes the code almost 20% slower. Apparently, gcc,
doens't recognize this as a rotate. I just filed a bug report at

  http://gcc.gnu.org/bugzilla/show_bug.cgi?id=57157

Is there any other trick I'm missing, which is portable C but which
doesn't slow it down when compiled with gcc?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130517073918</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-05-17 07:39:18-0400</timestampReceived><subject>Bug in nettle-2.7 ecc code</subject><body>

Testing on the debian build machines revealed a bug in the new ecc code.
Curiously enough, causing failures only on 32-bit sparc (see
https://buildd.debian.org/status/fetch.php?pkg=nettle&amp;arch=sparc&amp;ver=2.7-2&amp;stamp=1368128015),
but the bug is not really platform-specific.

It turned out that ecc_j_to_a called GMP:s mpn_mul_n (via ecc_modp_mul)
with overlapping input and output arguments, which is not supported.

The following patch seems to solve the problem:

diff --git a/ecc-j-to-a.c b/ecc-j-to-a.c
index df8b876..26c1a03 100644
--- a/ecc-j-to-a.c
+++ b/ecc-j-to-a.c
@@ -46,6 +46,7 @@ ecc_j_to_a (const struct ecc_curve *ecc,
 #define up   (scratch + ecc-&gt;size)
 #define iz2p (scratch + ecc-&gt;size)
 #define iz3p (scratch + 2*ecc-&gt;size)
+#define izBp (scratch + 3*ecc-&gt;size)
 #define tp    scratch
 
   mp_limb_t cy;
@@ -72,11 +73,11 @@ ecc_j_to_a (const struct ecc_curve *ecc,
       if (flags &amp; 1)
 	{
 	  /* Divide this common factor by B */
-	  mpn_copyi (iz3p, izp, ecc-&gt;size);
-	  mpn_zero (iz3p + ecc-&gt;size, ecc-&gt;size);
-	  ecc-&gt;redc (ecc, iz3p);
-      
-	  ecc_modp_mul (ecc, iz2p, izp, iz3p);
+	  mpn_copyi (izBp, izp, ecc-&gt;size);
+	  mpn_zero (izBp + ecc-&gt;size, ecc-&gt;size);
+	  ecc-&gt;redc (ecc, izBp);
+
+	  ecc_modp_mul (ecc, iz2p, izp, izBp);
 	}
       else
 	ecc_modp_sqr (ecc, iz2p, izp);	

Thanks to Magnus Holmgren for tracking this down.

Note that this bug causes overwrites *within* a properly allocated limb
array, which gives incorrect results, but it does not overwrite any
pointers or code.

I should plan for a bugfix release reasonably soon.

Testing with a GMP library compiled with --enable-assert would have
revealed the bug earlier.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130528193009</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2013-05-28 19:30:09-0400</timestampReceived><subject>Re: arm compilation</subject><body>

On 05/22/2013 09:53 AM, Niels Möller wrote:

&gt; About the pre-v6 ARM problems, are those solved now?


Yes. It seems to compile with the new assembler.

regards,
Nikos

</body></email><email><emailId>20130529080820</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-05-29 08:08:20-0400</timestampReceived><subject>ANNOUNCE: Nettle-2.7.1</subject><body>

I'm happy to annnounce a new version of GNU Nettle, a low-level
cryptographics library. The Nettle home page can be found at
http://www.lysator.liu.se/~nisse/nettle/.

One serious bug has been found in the new ECC code shipped in
nettle-2.7. Thanks to Magnus Holmgren for help tracking down this
problem.

NEWS for the 2.7.1 release

	This is a bugfix release.

	Bug fixes:

	* Fixed a bug in the new ECC code. The ecc_j_to_a function
	  called GMP:s mpn_mul_n (via ecc_modp_mul) with overlapping
	  input and output arguments, which is not supported.

	* The assembly files for SHA1, SHA256 and AES depend on ARMv6
          instructions, breaking nettle-2.7 for pre-v6 ARM processors.
          The configure script now enables those assembly files only
          when building for ARMv6 or later.
	  
	* Use a more portable C expression for rotations. The
	  previous version used the following "standard" expression
	  for 32-bit rotation:

	    (x &lt;&lt; n) | (x &gt;&gt; (32 - n))

	  But this gives undefined behavior (according to the C
	  specification) for n = 0. The rotate expression is replaced
	  by the more portable:

	    (x &lt;&lt; n) | (x &gt;&gt; ((-n)&amp;31))

	  This change affects only CAST128, which uses non-constant
	  rotation counts. Unfortunately, the new expression is poorly
	  optimized by released versions of gcc, making CAST128 a bit
	  slower. This is being fixed by the gcc hackers, see
	  http://gcc.gnu.org/bugzilla/show_bug.cgi?id=57157.
	  
	The following problems have been reported, but are *not* fixed
	in this release:

	* ARM assembly files use instruction syntax which is not
          supported by all assemblers. Workaround: Use a current
          version of GNU as, or configure with --disable-assembler.

	* Configuring with --disable-static doesn't work on windows.
	
	The libraries are intended to be binary compatible with
	nettle-2.2 and later. The shared library names are
	libnettle.so.4.7 and libhogweed.so.2.5, with sonames still
	libnettle.so.4 and libhogweed.so.2.

Available at

  http://ftp.gnu.org/gnu/nettle/nettle-2.7.1.tar.gz
  ftp://ftp.gnu.org/gnu/nettle/nettle-2.7.1.tar.gz
  http://www.lysator.liu.se/~nisse/archive/nettle-2.7.1.tar.gz

and in the "nettle-2.7-fixes" branch in the git repository, see
http://git.lysator.liu.se/nettle/nettle.

Happy hacking,
/Niels Möller

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130530174716</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-05-30 17:47:16-0400</timestampReceived><subject>git.lysator.liu.se temporarily down</subject><body>

The machine git.lysator.liu.se is being upgraded to a more recent debian
version. Not sure when it will be operational again (it's maintained on
a volunteer basis), but hopefully within a day or two.

Possibly the gitorious web interface will be replaced by something
different (gitolite, gitlab, ...), since gitorious seems to require quite
a bit of work to install.

Sorry for the inconvenience.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20130928112320</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-09-28 11:23:20-0400</timestampReceived><subject>Re: AES interface</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I've pushed a branch "aes-reorg" to the public repo, implementing this
&gt; change.

I'm now about to merge this into the master branch. Some questions:

Now that the more ciphers in nettle work with fix key size, maybe it
would be a good idea to drop the length argument also from the
nettle_set_key_func typedef? This is used primarily for struct
nettle_cipher (nettle-meta.h), where using a function pointer with more
than one size makes little sense. Since various incompatible changes are
being made for nettle-2.8 anyway, this could be a good time.

Also, other AES-style algorithms, in particular, twofish and camellia,
could have similar changes as AES. E.g., the twofish implementation
appear to zero-pad keys of unusual sizes up to the next standard size.
Is that an important feature, or can I change it to just have
twofishN_setkey (struct twofishN_ctx *, const uint8_t *key), for n =
128, 192 and 256?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130928123041</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2013-09-28 12:30:41-0400</timestampReceived><subject>Re: AES interface</subject><body>

You wrote:

&gt; Now that the more ciphers in nettle work with fix key size, maybe it
&gt; would be a good idea to drop the length argument also from the
&gt; nettle_set_key_func typedef? This is used primarily for struct
&gt; nettle_cipher (nettle-meta.h), where using a function pointer with
&gt; more than one size makes little sense.

How would you then handle ciphers that accepts arbitrary key sizes?

&gt; Also, other AES-style algorithms, in particular, twofish and camellia,
&gt; could have similar changes as AES. E.g., the twofish implementation
&gt; appear to zero-pad keys of unusual sizes up to the next standard size.
&gt; Is that an important feature, or can I change it to just have
&gt; twofishN_setkey (struct twofishN_ctx *, const uint8_t *key), for n =
&gt; 128, 192 and 256?

I'd say drop it unless someone has a use-case for it.

/Simon

</body></email><email><emailId>20130621122804</emailId><senderName>Mallikarjun Bailamanavar</senderName><senderEmail>mallugb@gmail.com</senderEmail><timestampReceived>2013-06-21 12:28:04-0400</timestampReceived><subject>Supported Algorithms/Key Format</subject><body>

Hi *,

My name is Malik and I just started using the Nettle.

I am looking for APIs for RSA crypto operations.

&gt;From rsa.h header file, I can make out that Nettle supports,
- RSA crypto APIs only for PKCS#1 v1.5 padding mechanisms and
- CRT format for RSA private key

My questions,
- Does nettle not support PKCS#1 v2.1 padding mechanisms e.g. RSASSA-PSS?
- Does nettle not support exponent format for private key?. Meaning private
key is made up of modulus and private exponent.
- Is there an API for raw RSA crypto operation? Raw meaning, API must not
do any encoding with input data but just has to sign/encrypt it.

Can someone please clarify my questions?
Thanks very much indeed in advance for the clarifications.

Regards,
Malik

</body></email><email><emailId>20130928164343</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-09-28 16:43:43-0400</timestampReceived><subject>Re: AES interface</subject><body>

I wrote:

&gt; Now that the more ciphers in nettle work with fix key size, maybe it
&gt; would be a good idea to drop the length argument also from the
&gt; nettle_set_key_func typedef?

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; How would you then handle ciphers that accepts arbitrary key sizes?

You should call the algorithm-specific functions which accepts variable
key size, e.g., cast128_set_key. But you will no longer be able to pass
arbitrary key size via the function pointers nettle_cast128.set_*_key,
which will then be a wrapper function specifying a fix key size.

So this change affects the interface via the structs in nettle-meta.h.
And any application code which use the nettle_crypt_func typedef for
other purposes. Direct use via algorithm specific function keeps
following the same principle: Algorithms with variable key size have a
_set_key function with a length parameter. Algorithms with a fix key
size take no length parameter.

I think this makes sense, because struct nettle_cipher contains no
information about possible key sizes, only a single value. So if other
key sizes are possible, there's no way to tell from looking at the
struct nettle_cipher instance that represents the algorithm. Except by
examining the name field...

For aes, aes_set_*_key (which is kept for backwards compatibility)
accepts a length parameter, but the new and recommended functions,
aes128_set_*_key, aes192_set_*_key, aes256_set_*_key, do not. In effect,
the new interface treats aes128, aes192 and aes256 as distinct
algorithms, with any similarities being an implementation detail. And
I'm now considering doing the same with other aes-style algorithms.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20130929080819</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2013-09-29 08:08:19-0400</timestampReceived><subject>Re: AES interface</subject><body>

You wrote:

&gt; I wrote:
&gt; 
&gt; &gt; Now that the more ciphers in nettle work with fix key size, maybe it
&gt; &gt; would be a good idea to drop the length argument also from the
&gt; &gt; nettle_set_key_func typedef?
&gt; 
&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt; 
&gt; &gt; How would you then handle ciphers that accepts arbitrary key sizes?
&gt; 
&gt; You should call the algorithm-specific functions which accepts
&gt; variable key size, e.g., cast128_set_key. But you will no longer be
&gt; able to pass arbitrary key size via the function pointers
&gt; nettle_cast128.set_*_key, which will then be a wrapper function
&gt; specifying a fix key size.

Ok, sounds fine to me.

&gt; For aes, aes_set_*_key (which is kept for backwards compatibility)
&gt; accepts a length parameter, but the new and recommended functions,

If you bump the ABI, is there any reason to keep backwards compatible
functions?  It sounds like the changes you are considering may break
applications anyway, so they might as well take the time to upgrade to
the new API.

/Simon

</body></email><email><emailId>20130929085447</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2013-09-29 08:54:47-0400</timestampReceived><subject>Re: AES interface</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; If you bump the ABI, is there any reason to keep backwards compatible
&gt; functions?

The ABI will break, but I'm also considering source-level "API"
compatibility. Which isn't an all-or-nothing issue; different
applications use different subsets of the API.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email></emails>