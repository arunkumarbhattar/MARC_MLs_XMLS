<?xml version="1.0" encoding="utf-8"?>
<emails><email><emailId>20190425111202</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-04-25 11:12:02-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

Hello Niels,

Daiki Ueno &lt;ueno@gnu.org&gt; writes:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt; I think there are three main pieces left to integrate.
&gt;&gt;
&gt;&gt; 1. Curve operations to support Curve448 (i.e., diffie-hellman
&gt;&gt;    operations). I have made some progress, on my curve448 branch,
&gt;&gt;
&gt;&gt; 2. SHAKE 128/256. I think I had some question on the interface design.
&gt;&gt;
&gt;&gt; 3. EdDSA 448.
&gt;&gt;
&gt;&gt; Optimization of the mod p arithmetic isn't that important yet,

Is there anything I can do to get this merged in upstream?  Now that
OpenSSL supports the curve and EdDSA, it would be interesting to add it
in GnuTLS.

I tried to integrate it into GnuTLS bundling the current code, and it
can interoperate with OpenSSL:
https://gitlab.com/gnutls/gnutls/merge_requests/984

For convenience I am attaching the remaining patches for nettle.

Regards,
-- 
Daiki Ueno
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191201193233</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-01 19:32:33-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

Daiki Ueno &lt;ueno@gnu.org&gt; writes:

&gt; From 8bc6e735d4b40cbab5e187a28e01b63a04ecd92b Mon Sep 17 00:00:00 2001
&gt; From: Daiki Ueno &lt;dueno@redhat.com&gt;
&gt; Date: Fri, 23 Jun 2017 17:26:18 +0200
&gt; Subject: [PATCH 2/4] Implement Curve448 primitives
&gt;
&gt; This patch adds the necessary primitives for "curve448", defined in
&gt; RFC 7748.  Those primitives are namely: addition, doubling, scalar
&gt; multiplication of the generator or an arbitrary point, inversion, and
&gt; square root.

At last, I've now merged this onto the curve448 branch.

I see you've made some chenges to the needed scratch space, if I
understand it correctly, you need to allow h_to_a_itch larger than
mul_itch or mul_g_itch. You increase the value of ECC_ECDSA_SIGN_ITCH
and add a new ECC_ECDSA_KEYGEN_ITCH. Can you comment on that?

The only reason ECDSA is affected at all by curve448, is that we have
tests for ecdsa over the curve25519 and curve448, even though that's not
the way these curves are intended to be used. Maybe that should just be
deleted.

Performance for the scalar multiplication primitives seem to be slower
than secp384 and slightly faster than secp521, and looking at point
addition, it's slower than secp521. I hope that will be improved a quite
a bit with an optimized mod operation for the curve448 prime.

&gt; While the interface is similar to curve25519, the implementation is
&gt; slightly different.  For curve25519, the Pippenger tables are
&gt; generated through the coordinates on the Montgomery curve.  On the
&gt; other hand, the tables for curve448 are directly generated from the
&gt; coordinates on the corresponding Edwards curve ("edwards448").

This is no longer the case, since the handling curve 25519 was changed
early on, based on your patches back then.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191202145800</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-12-02 14:58:00-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Daiki Ueno &lt;ueno@gnu.org&gt; writes:
&gt;
&gt;&gt; From 8bc6e735d4b40cbab5e187a28e01b63a04ecd92b Mon Sep 17 00:00:00 2001
&gt;&gt; From: Daiki Ueno &lt;dueno@redhat.com&gt;
&gt;&gt; Date: Fri, 23 Jun 2017 17:26:18 +0200
&gt;&gt; Subject: [PATCH 2/4] Implement Curve448 primitives
&gt;&gt;
&gt;&gt; This patch adds the necessary primitives for "curve448", defined in
&gt;&gt; RFC 7748.  Those primitives are namely: addition, doubling, scalar
&gt;&gt; multiplication of the generator or an arbitrary point, inversion, and
&gt;&gt; square root.
&gt;
&gt; At last, I've now merged this onto the curve448 branch.

That's a great news, thank you Niels!

&gt; I see you've made some chenges to the needed scratch space, if I
&gt; understand it correctly, you need to allow h_to_a_itch larger than
&gt; mul_itch or mul_g_itch. You increase the value of ECC_ECDSA_SIGN_ITCH
&gt; and add a new ECC_ECDSA_KEYGEN_ITCH. Can you comment on that?
&gt;
&gt; The only reason ECDSA is affected at all by curve448, is that we have
&gt; tests for ecdsa over the curve25519 and curve448, even though that's
&gt; not the way these curves are intended to be used. Maybe that should
&gt; just be deleted.

Indeed, I agree to remove the tests and affected parts in the library.

&gt; Performance for the scalar multiplication primitives seem to be slower
&gt; than secp384 and slightly faster than secp521, and looking at point
&gt; addition, it's slower than secp521. I hope that will be improved a quite
&gt; a bit with an optimized mod operation for the curve448 prime.
&gt;
&gt;&gt; While the interface is similar to curve25519, the implementation is
&gt;&gt; slightly different.  For curve25519, the Pippenger tables are
&gt;&gt; generated through the coordinates on the Montgomery curve.  On the
&gt;&gt; other hand, the tables for curve448 are directly generated from the
&gt;&gt; coordinates on the corresponding Edwards curve ("edwards448").
&gt;
&gt; This is no longer the case, since the handling curve 25519 was changed
&gt; early on, based on your patches back then.

Thank you.  By the way, one thing I realized in my past rebase attempts
is that, this commit doing the final reduction of a value by mod q seems
to be incorrect for curve448 and should probably be reverted:

  commit 6cf6abd68eb3d6c8c8e5ab217be734f9c537037f
  Author: Daiki Ueno &lt;dueno@redhat.com&gt;
  Date:   Sat Aug 5 09:43:47 2017 +0200

      ecc-eh-to-a, eddsa-sign: Parameterize hard-coded value
      
      This allows the same code to be reused in curve448 and Ed448.
      
      Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;

-         shift = 252 - GMP_NUMB_BITS * (ecc-&gt;p.size - 1);
+         shift = ecc-&gt;q.bit_size - 1 - GMP_NUMB_BITS * (ecc-&gt;p.size - 1);
          cy = mpn_submul_1 (r, ecc-&gt;q.m, ecc-&gt;p.size,
                             r[ecc-&gt;p.size-1] &gt;&gt; shift);

For curve25519, q is defined as:

  2^252 + 0x14def9dea2f79cd65812631a5cf5d3ed

whose bit pattern starts with 0x1000, so r - q * (r&gt;&gt;252) should
work.

On the other hand, for curve448, q is defined as:

  2^446 - 0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d

whose bit pattern starts with 0xFFFF.  In that case the formula (r - q *
(r&gt;&gt;445)) could be incorrect due to the accumulated errors by
multiplication (i.e. q * 0x7FFF...).

Therefore, I suggest using r - q * (r&gt;&gt;446) instead, though it would
introduce another hard-coded value.

Regards,
-- 
Daiki Ueno
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191202201726</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-02 20:17:26-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

Daiki Ueno &lt;ueno@gnu.org&gt; writes:

&gt; Thank you.  By the way, one thing I realized in my past rebase attempts
&gt; is that, this commit doing the final reduction of a value by mod q seems
&gt; to be incorrect for curve448 and should probably be reverted:
&gt;
&gt;   commit 6cf6abd68eb3d6c8c8e5ab217be734f9c537037f
&gt;   Author: Daiki Ueno &lt;dueno@redhat.com&gt;
&gt;   Date:   Sat Aug 5 09:43:47 2017 +0200
&gt;
&gt;       ecc-eh-to-a, eddsa-sign: Parameterize hard-coded value
&gt;       
&gt;       This allows the same code to be reused in curve448 and Ed448.
&gt;       
&gt;       Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
&gt;
&gt; -         shift = 252 - GMP_NUMB_BITS * (ecc-&gt;p.size - 1);
&gt; +         shift = ecc-&gt;q.bit_size - 1 - GMP_NUMB_BITS * (ecc-&gt;p.size - 1);
&gt;           cy = mpn_submul_1 (r, ecc-&gt;q.m, ecc-&gt;p.size,
&gt;                              r[ecc-&gt;p.size-1] &gt;&gt; shift);
&gt;
&gt; For curve25519, q is defined as:
&gt;
&gt;   2^252 + 0x14def9dea2f79cd65812631a5cf5d3ed
&gt;
&gt; whose bit pattern starts with 0x1000, so r - q * (r&gt;&gt;252) should
&gt; work.
&gt;
&gt; On the other hand, for curve448, q is defined as:
&gt;
&gt;   2^446 - 0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d
&gt;
&gt; whose bit pattern starts with 0xFFFF.  In that case the formula (r - q *
&gt; (r&gt;&gt;445)) could be incorrect due to the accumulated errors by
&gt; multiplication (i.e. q * 0x7FFF...).

Good catch! Right, this needs a bit more analysis. Fur curve25519, the
subtraction can underflow (unlikely), which is addressed with the
conditional addition a few lines down.

&gt; Therefore, I suggest using r - q * (r&gt;&gt;446) instead, though it would
&gt; introduce another hard-coded value.

But for curve448, that subtraction will never underflow, instead it will
sometimes produce a non-canonical result, r &gt;= q. So correcting the
shift isn't enough.

On the other hand, this code should perhaps be deleted altogether, I
think h_to_a with flags == 2 is used only for ecdsa. It might make sense
to instead add a function pointer to struct ecc_modulo to do canonical
reduction; that's needed in a few different places, not only here.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191202205635</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-02 20:56:35-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Performance for the scalar multiplication primitives seem to be slower
&gt; than secp384 and slightly faster than secp521, and looking at point
&gt; addition, it's slower than secp521. I hope that will be improved a quite
&gt; a bit with an optimized mod operation for the curve448 prime.

I've tried out this mod function (for 64-bit):

static void
ecc_448_modp(const struct ecc_modulo *m, mp_limb_t *rp)
{
  /* Let B = 2^64, b = 2^32 = sqrt(B).
     p = B^7 - b B^3 - 1 ==&gt; B^7 = b B^3 + 1

     {x_{13}, ..., x_0} =
       {x_6,...,x_0} 
     + {x_{10},...,x_7}
     + 2 {x_{13},x_{12}, x_{11}} B^4 
     + b {x_{10},...,x_7,x_{13},x_{12},x_{11}
  */
  mp_limb_t c3, c4, c7;
  mp_limb_t *tp = rp + 7;

  c4 = mpn_add_n (rp, rp, rp + 7, 4);
  c7 = mpn_addmul_1 (rp + 4, rp + 11, 3, 2);
  c3 = mpn_addmul_1 (rp, rp + 11, 3, (mp_limb_t) 1 &lt;&lt; 32);
  c7 += mpn_addmul_1 (rp + 3, rp + 7, 4, (mp_limb_t) 1 &lt;&lt; 32);
  tp[0] = c7;
  tp[1] = tp[2] = 0;
  tp[3] = c3 + (c7 &lt;&lt; 32);
  tp[4] = c4 + (c7 &gt;&gt; 32) + (tp[3] &lt; c3);
  tp[5] = tp[6] = 0;
  c7 = mpn_add_n (rp, rp, tp, 7);
  c7 = cnd_add_n (c7, rp, m-&gt;B, 7);
  assert(c7 == 0);  
}

This gives a speedup of 85% over the general ecc_mod (on my machine),
and gives about 35% speedup for scalar multiplication (both mul_g and
mul_a). So with this change, performance of mul_g and mul_1 is roughly
midway between secp384 and secp521.

Not sure if replacing the addmul_1 calls with shifts is worthwhile for
the C code (we'll get more function calls and more passes over the data,
which should still be worthwhile for machines with slow multiplication),
but for assembly implementation, the addmul_1(..., 2) call should be adds
only, in registers, and the addmul_1(,..., 1&lt;&lt;32) should be shift and
add, preferably in registers.

I'm going to leave randomized testing running for a few hours.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191204205155</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-04 20:51:55-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

Daiki Ueno &lt;ueno@gnu.org&gt; writes:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt; I see you've made some chenges to the needed scratch space, if I
&gt;&gt; understand it correctly, you need to allow h_to_a_itch larger than
&gt;&gt; mul_itch or mul_g_itch. You increase the value of ECC_ECDSA_SIGN_ITCH
&gt;&gt; and add a new ECC_ECDSA_KEYGEN_ITCH. Can you comment on that?
&gt;&gt;
&gt;&gt; The only reason ECDSA is affected at all by curve448, is that we have
&gt;&gt; tests for ecdsa over the curve25519 and curve448, even though that's
&gt;&gt; not the way these curves are intended to be used. Maybe that should
&gt;&gt; just be deleted.
&gt;
&gt; Indeed, I agree to remove the tests and affected parts in the library.

I'm considering the below patch. I think there's room for further
improvement, maybe splitting the h_to_a method up (it's called with op
== 0, and with op == 2 from the ecdsa, but never with op == 1). Maybe
adding a some ecc_mod_canonical function. But deleting this unneeded
code right away seems like an improvement in itself.

Regards,
/Niels

diff --git a/ecc-eh-to-a.c b/ecc-eh-to-a.c
index 8173b887..89d2b6e3 100644
--- a/ecc-eh-to-a.c
+++ b/ecc-eh-to-a.c
@@ -56,6 +56,8 @@ ecc_eh_to_a (const struct ecc_curve *ecc,
 
   mp_limb_t cy;
 
+  assert(op == 0);
+
   /* Needs 2*size + scratch for the invert call. */
   ecc-&gt;p.invert (&amp;ecc-&gt;p, izp, zp, tp + ecc-&gt;p.size);
 
@@ -63,25 +65,6 @@ ecc_eh_to_a (const struct ecc_curve *ecc,
   cy = mpn_sub_n (r, tp, ecc-&gt;p.m, ecc-&gt;p.size);
   cnd_copy (cy, r, tp, ecc-&gt;p.size);
 
-  if (op)
-    {
-      /* Skip y coordinate */
-      if (op &gt; 1)
-	{
-	  /* Reduce modulo q. Hardcoded for curve25519, duplicates end
-	     of ecc_25519_modq. FIXME: Is this needed at all? op &gt; 0
-	     is only used by ecdsa code, and ecdsa on Edwards curves
-	     makes little sense and is is only used by tests. */
-	  unsigned shift;
-	  assert (ecc-&gt;p.bit_size == 255);
-	  shift = ecc-&gt;q.bit_size - 1 - GMP_NUMB_BITS * (ecc-&gt;p.size - 1);
-	  cy = mpn_submul_1 (r, ecc-&gt;q.m, ecc-&gt;p.size,
-			     r[ecc-&gt;p.size-1] &gt;&gt; shift);
-	  assert (cy &lt; 2);
-	  cnd_add_n (cy, r, ecc-&gt;q.m, ecc-&gt;p.size);
-	}
-      return;
-    }
   ecc_modp_mul (ecc, tp, yp, izp);
   cy = mpn_sub_n (r + ecc-&gt;p.size, tp, ecc-&gt;p.m, ecc-&gt;p.size);
   cnd_copy (cy, r + ecc-&gt;p.size, tp, ecc-&gt;p.size);
diff --git a/testsuite/ecdsa-keygen-test.c b/testsuite/ecdsa-keygen-test.c
index a96c09ef..0deb7214 100644
--- a/testsuite/ecdsa-keygen-test.c
+++ b/testsuite/ecdsa-keygen-test.c
@@ -78,6 +78,10 @@ test_main (void)
       struct ecc_point pub;
       struct ecc_scalar key;
 
+      if (ecc-&gt;p.bit_size == 255)
+	/* Exclude curve25519, which isn't supported with ECDSA. */
+	continue;
+
       if (verbose)
 	fprintf (stderr, "Curve %d\n", ecc-&gt;p.bit_size);
 
diff --git a/testsuite/ecdsa-sign-test.c b/testsuite/ecdsa-sign-test.c
index 23275357..b240a31b 100644
--- a/testsuite/ecdsa-sign-test.c
+++ b/testsuite/ecdsa-sign-test.c
@@ -156,18 +156,4 @@ test_main (void)
 	      "97536710 1F67D1CF 9BCCBF2F 3D239534"
 	      "FA509E70 AAC851AE 01AAC68D 62F86647"
 	      "2660"); /* s */
-
-  /* Non-standard ecdsa using curve25519. Not interop-tested with
-     anything else. */
-  test_ecdsa (&amp;_nettle_curve25519,
-	      "1db511101b8fd16f e0212c5679ef53f3"
-	      "323bde77f9efa442 617314d576d1dbcb", /* z */
-	      "aa2fa8facfdc3a99 ec466d41a2c9211c"
-	      "e62e1706f54037ff 8486e26153b0fa79", /* k */
-	      SHEX("e99df2a098c3c590 ea1e1db6d9547339"
-		   "ae760d5331496119 5d967fd881e3b0f5"), /* h */
-	      " 515c3a485f57432 0daf3353a0d08110"
-	      "64157c556296de09 4132f74865961b37", /* r */
-	      "  78f23367291b01 3fc430fb09322d95"
-	      "4384723649868d8e 88effc7ac8b141d7"); /* s */
 }
diff --git a/testsuite/ecdsa-verify-test.c b/testsuite/ecdsa-verify-test.c
index 971988c3..6a593d6f 100644
--- a/testsuite/ecdsa-verify-test.c
+++ b/testsuite/ecdsa-verify-test.c
@@ -145,17 +145,4 @@ test_main (void)
 	      "97536710 1F67D1CF 9BCCBF2F 3D239534" 
 	      "FA509E70 AAC851AE 01AAC68D 62F86647"
 	      "2660"); /* s */
-
-  test_ecdsa (&amp;_nettle_curve25519,
-	      /* Public key corresponding to the key in ecdsa-sign-test */
-	      "59f8f317fd5f4e82 c02f8d4dec665fe1"
-	      "230f83b8572638e1 b2ac34a30028e24d", /* x */
-	      "1902a72dc1a6525a 811b9c1845978d56"
-	      "fd97dce5e278ebdd ec695349d7e41498", /* y */
-	      SHEX("e99df2a098c3c590 ea1e1db6d9547339"
-		   "ae760d5331496119 5d967fd881e3b0f5"), /* h */
-	      " 515c3a485f57432 0daf3353a0d08110"
-	      "64157c556296de09 4132f74865961b37", /* r */
-	      "  78f23367291b01 3fc430fb09322d95"
-	      "4384723649868d8e 88effc7ac8b141d7"); /* s */
 }

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191207071546</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-07 07:15:46-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I'm considering the below patch. I think there's room for further
&gt; improvement, maybe splitting the h_to_a method up (it's called with op
&gt; == 0, and with op == 2 from the ecdsa, but never with op == 1). Maybe
&gt; adding a some ecc_mod_canonical function. But deleting this unneeded
&gt; code right away seems like an improvement in itself.

Now pushed to master-updates.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191207131226</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-07 13:12:26-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt; I'm considering the below patch. I think there's room for further
&gt;&gt; improvement, maybe splitting the h_to_a method up (it's called with op
&gt;&gt; == 0, and with op == 2 from the ecdsa, but never with op == 1). Maybe
&gt;&gt; adding a some ecc_mod_canonical function. But deleting this unneeded
&gt;&gt; code right away seems like an improvement in itself.
&gt;
&gt; Now pushed to master-updates.

Failed the gnutls test "testcompat-openssl",

  ###############################################
  # Server mode tests (gnutls server-openssl cli#
  ###############################################
  Check TLS 1.0 with DHE-RSA ciphersuite
  %NO_ETM: Check TLS 1.0 with DHE-RSA ciphersuite
  %DISABLE_SAFE_RENEGOTIATION: Check TLS 1.0 with DHE-RSA ciphersuite
  %NO_TICKETS: Check TLS 1.0 with DHE-RSA ciphersuite
  %COMPAT: Check TLS 1.0 with DHE-RSA ciphersuite
  %SAFE_RENEGOTIATION: Check TLS 1.0 with DHE-RSA ciphersuite
  HTTP Server listening on IPv4 0.0.0.0 port 18033...done
  HTTP Server listening on IPv6 :: port 18033...done
  HTTP Server listening on IPv4 0.0.0.0 port 22536...done
  HTTP Server listening on IPv6 :: port 22536...done
  HTTP Server listening on IPv4 0.0.0.0 port 15595...done
  HTTP Server listening on IPv6 :: port 15595...done
  HTTP Server listening on IPv4 0.0.0.0 port 22743...done
  HTTP Server listening on IPv6 :: port 22743...done
  HTTP Server listening on IPv4 0.0.0.0 port 10935...done
  HTTP Server listening on IPv6 :: port 10935...done
  HTTP Server listening on IPv4 0.0.0.0 port 43747...done
  HTTP Server listening on IPv6 :: port 43747...done
  Exiting via signal 15

Maybe unrelated to this change?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191207164602</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-07 16:46:02-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I've tried out this mod function (for 64-bit):
&gt;
&gt; static void
&gt; ecc_448_modp(const struct ecc_modulo *m, mp_limb_t *rp)
...

&gt; This gives a speedup of 85% over the general ecc_mod (on my machine),
&gt; and gives about 35% speedup for scalar multiplication (both mul_g and
&gt; mul_a). So with this change, performance of mul_g and mul_1 is roughly
&gt; midway between secp384 and secp521.

Tried the below first implementation of an x86_64 mod function. Gives a
speedup of almost three times over the above C function. With this, the
mul_g operation is 20% slower than for secp384, and the mul_a operation
is slightly faster.

Rgards,
/Niels

diff --git a/configure.ac b/configure.ac
index 3547cae4..2933facf 100644
--- a/configure.ac
+++ b/configure.ac
@@ -476,7 +476,8 @@ asm_nettle_optional_list="gcm-hash8.asm cpuid.asm \
 asm_hogweed_optional_list=""
 if test "x$enable_public_key" = "xyes" ; then
   asm_hogweed_optional_list="ecc-192-modp.asm ecc-224-modp.asm \
-    ecc-25519-modp.asm ecc-256-redc.asm ecc-384-modp.asm ecc-521-modp.asm"
+    ecc-256-redc.asm ecc-384-modp.asm ecc-521-modp.asm \
+    ecc-25519-modp.asm ecc-curve448-modp.asm"
 fi
 
 OPT_NETTLE_OBJS=""
@@ -580,6 +581,7 @@ AH_VERBATIM([HAVE_NATIVE],
 #undef HAVE_NATIVE_ecc_256_redc
 #undef HAVE_NATIVE_ecc_384_modp
 #undef HAVE_NATIVE_ecc_384_redc
+#undef HAVE_NATIVE_ecc_curve448_modp
 #undef HAVE_NATIVE_ecc_521_modp
 #undef HAVE_NATIVE_ecc_521_redc
 #undef HAVE_NATIVE_gcm_hash8
diff --git a/ecc-448.c b/ecc-448.c
index 7d68e1c8..2e840024 100644
--- a/ecc-448.c
+++ b/ecc-448.c
@@ -45,7 +45,11 @@
 
 #include "ecc-448.h"
 
-#if GMP_NUMB_BITS == 64
+#if HAVE_NATIVE_ecc_curve448_modp
+#define ecc_448_modp nettle_ecc_curve448_modp
+void
+ecc_448_modp (const struct ecc_modulo *m, mp_limb_t *rp);
+#elif GMP_NUMB_BITS == 64
 static void
 ecc_448_modp(const struct ecc_modulo *m, mp_limb_t *rp)
 {
diff --git a/x86_64/ecc-curve448-modp.asm b/x86_64/ecc-curve448-modp.asm
new file mode 100644
index 00000000..5ce81960
--- /dev/null
+++ b/x86_64/ecc-curve448-modp.asm
@@ -0,0 +1,141 @@
+C x86_64/ecc-curve448-modp.asm
+
+ifelse(&lt;
+   Copyright (C) 2019 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+&gt;)
+
+	.file "ecc-curve448-modp.asm"
+
+define(&lt;RP&gt;, &lt;%rsi&gt;)
+define(&lt;X0&gt;, &lt;%rax&gt;)
+define(&lt;X1&gt;, &lt;%rbx&gt;)
+define(&lt;X2&gt;, &lt;%rcx&gt;)
+define(&lt;X3&gt;, &lt;%rdx&gt;)
+define(&lt;X4&gt;, &lt;%rbp&gt;)
+define(&lt;X5&gt;, &lt;%rdi&gt;)
+define(&lt;X6&gt;, &lt;%r8&gt;)
+define(&lt;X7&gt;, &lt;%r9&gt;)
+define(&lt;T0&gt;, &lt;%r10&gt;)
+define(&lt;T1&gt;, &lt;%r11&gt;)
+define(&lt;T2&gt;, &lt;%r12&gt;)
+
+PROLOGUE(nettle_ecc_curve448_modp)
+	W64_ENTRY(2, 0)
+
+	push	%rbx
+	push	%rbp
+	push	%r12
+
+	C First load the values to be shifted by 32.
+	mov 88(RP), X1
+	mov X1, X0
+	mov 96(RP), X2
+	mov X1, T0
+	mov 104(RP), X3
+	mov X2, T1
+	mov 56(RP), X4
+	mov X3, T2
+	mov 64(RP), X5
+	mov 72(RP), X6
+	mov 80(RP), X7
+
+	C Multiply by 2^32
+	shl $32, X0
+	shrd $32, X2, X1
+	shrd $32, X3, X2
+	shrd $32, X4, X3
+	shrd $32, X5, X4
+	shrd $32, X6, X5
+	shrd $32, X7, X6
+	shr $32, X7
+
+	C Multiply by 2
+	add T0, T0
+	adc T1, T1
+	adc T2, T2
+	adc $0, X7
+
+	C Main additions
+	add 56(RP), X0
+	adc 64(RP), X1
+	adc 72(RP), X2
+	adc 80(RP), X3
+	adc T0, X4
+	adc T1, X5
+	adc T2, X6
+	adc $0, X7
+
+	add (RP), X0
+	adc 8(RP), X1
+	adc 16(RP), X2
+	adc 24(RP), X3
+	adc 32(RP), X4
+	adc 40(RP), X5
+	adc 48(RP), X6
+	adc $0, X7
+
+	mov X7, T0
+	mov X7, T1
+	shl $32, T0
+	shr $32, T1
+	xor T2, T2
+	add X7, X0
+	adc $0, X1
+	adc $0, X2
+	adc T0, X3
+	adc T1, X4
+	adc $0, X5
+	adc $0, X6
+	adc $0, T2
+
+	mov T2, T0
+	shl $32, T0
+
+	add T2, X0
+	mov X0, (RP)
+	adc $0, X1
+	mov X1, 8(RP)
+	adc $0, X2
+	mov X2, 16(RP)
+	adc T0, X3
+	mov X3, 24(RP)
+	adc $0, X4
+	mov X4, 32(RP)
+	adc $0, X5
+	mov X5, 40(RP)
+	adc $0, X6
+	mov X6, 48(RP)
+
+	pop	%r12
+	pop	%rbp
+	pop	%rbx
+
+	W64_EXIT(2, 0)
+	ret
+EPILOGUE(nettle_ecc_curve448_modp)

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191208212450</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-08 21:24:50-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

Daiki Ueno &lt;ueno@gnu.org&gt; writes:

&gt; From 8bc6e735d4b40cbab5e187a28e01b63a04ecd92b Mon Sep 17 00:00:00 2001
&gt; From: Daiki Ueno &lt;dueno@redhat.com&gt;
&gt; Date: Fri, 23 Jun 2017 17:26:18 +0200
&gt; Subject: [PATCH 2/4] Implement Curve448 primitives
&gt;
&gt; This patch adds the necessary primitives for "curve448", defined in
&gt; RFC 7748.  Those primitives are namely: addition, doubling, scalar
&gt; multiplication of the generator or an arbitrary point, inversion, and
&gt; square root.

[...]

&gt; +/* Computes a^{(p-3)/4} = a^{2^446-2^222-1} mod m. Needs 9 * n scratch
&gt; +   space. */
&gt; +static void
&gt; +ecc_mod_pow_446m224m1 (const struct ecc_modulo *p,
&gt; +		       mp_limb_t *rp, const mp_limb_t *ap,
&gt; +		       mp_limb_t *scratch)
&gt; +{
&gt; +#define t0 scratch
&gt; +#define t1 (scratch + 3*ECC_LIMB_SIZE)
&gt; +#define t2 (scratch + 6*ECC_LIMB_SIZE)

I think 6*n scratch space should be enough (with no other changes to
this function),

  #define t0 scratch
  #define t1 (scratch + 2*ECC_LIMB_SIZE)
  #define t2 (scratch + 4*ECC_LIMB_SIZE)

(And it could possibly be trimmed down a bit further, by storing the
reused value a^{2^222 - 1} first).

Do you agree? Then storage for a few other things can likely be trimmed
down too, in particular, curve448_mul would get the same scratch need as
curve25519_mul, 12*n rather than 14*n. 

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191208213727</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-08 21:37:27-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;&gt;
&gt;&gt;&gt; I'm considering the below patch. I think there's room for further
&gt;&gt;&gt; improvement, maybe splitting the h_to_a method up (it's called with op
&gt;&gt;&gt; == 0, and with op == 2 from the ecdsa, but never with op == 1). Maybe
&gt;&gt;&gt; adding a some ecc_mod_canonical function. But deleting this unneeded
&gt;&gt;&gt; code right away seems like an improvement in itself.
&gt;&gt;
&gt;&gt; Now pushed to master-updates.
&gt;
&gt; Failed the gnutls test "testcompat-openssl",
&gt;
&gt;   ###############################################
&gt;   # Server mode tests (gnutls server-openssl cli#
&gt;   ###############################################
&gt;   Check TLS 1.0 with DHE-RSA ciphersuite
&gt;   %NO_ETM: Check TLS 1.0 with DHE-RSA ciphersuite
&gt;   %DISABLE_SAFE_RENEGOTIATION: Check TLS 1.0 with DHE-RSA ciphersuite
&gt;   %NO_TICKETS: Check TLS 1.0 with DHE-RSA ciphersuite
&gt;   %COMPAT: Check TLS 1.0 with DHE-RSA ciphersuite
&gt;   %SAFE_RENEGOTIATION: Check TLS 1.0 with DHE-RSA ciphersuite
&gt;   HTTP Server listening on IPv4 0.0.0.0 port 18033...done
&gt;   HTTP Server listening on IPv6 :: port 18033...done
&gt;   HTTP Server listening on IPv4 0.0.0.0 port 22536...done
&gt;   HTTP Server listening on IPv6 :: port 22536...done
&gt;   HTTP Server listening on IPv4 0.0.0.0 port 15595...done
&gt;   HTTP Server listening on IPv6 :: port 15595...done
&gt;   HTTP Server listening on IPv4 0.0.0.0 port 22743...done
&gt;   HTTP Server listening on IPv6 :: port 22743...done
&gt;   HTTP Server listening on IPv4 0.0.0.0 port 10935...done
&gt;   HTTP Server listening on IPv6 :: port 10935...done
&gt;   HTTP Server listening on IPv4 0.0.0.0 port 43747...done
&gt;   HTTP Server listening on IPv6 :: port 43747...done
&gt;   Exiting via signal 15
&gt;
&gt; Maybe unrelated to this change?

I don't understand the gnutls failure. I've logged in to gitlab and
pressed the "Retry"-button. If it keeps failing, I'll need some help
investigating.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191209061358</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-09 06:13:58-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I don't understand the gnutls failure. I've logged in to gitlab and
&gt; pressed the "Retry"-button. If it keeps failing, I'll need some help
&gt; investigating.

The retry passed. Merged this deletion (ecdsa over curve25519) to master
now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191225190026</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-25 19:00:26-0400</timestampReceived><subject>Re: [PATCH 0/8] Implement Curve448 ECDH and Ed448</subject><body>

Daiki Ueno &lt;ueno@gnu.org&gt; writes:

&gt;   Implement SHAKE128/256 functions

I've merged a stripped-down version of this patch, introducing a single new
function sha3_256_shake. If I've understood it correctly, that's what is
needed for ed448 signatures.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190201204358</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-02-01 20:43:58-0400</timestampReceived><subject>Re: nettle-stdint.h</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt;&gt; &gt; This file needs just uint8_t/uint64_t, so it might be easier to fix gnutls
&gt;&gt; &gt; to just include &lt;stdint.h&gt; there. I'll open a MR.
&gt;
&gt; I'm sorry for the delay. I've opened
&gt; https://gitlab.com/gnutls/gnutls/merge_requests/901 .

Excellent! And now the gnutls build in nettle's gitlab ci succeed.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190806134648</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-08-06 13:46:48-0400</timestampReceived><subject>[PATCH] nettle-meta: add meta interface for CMAC-DES3 functions</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in               |  2 +-
 cmac-des3-meta.c          | 43 +++++++++++++++++++++++++++++++++++++++
 nettle-meta-macs.c        |  1 +
 nettle-meta.h             | 13 ++++++++++++
 testsuite/cmac-test.c     | 12 -----------
 testsuite/meta-mac-test.c |  1 +
 6 files changed, 59 insertions(+), 13 deletions(-)
 create mode 100644 cmac-des3-meta.c

diff --git a/Makefile.in b/Makefile.in
index 409c655b2cee..de46bb5619f3 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -103,7 +103,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
 		 cmac.c cmac64.c cmac-aes128.c cmac-aes256.c cmac-des3.c \
-		 cmac-aes128-meta.c cmac-aes256-meta.c \
+		 cmac-aes128-meta.c cmac-aes256-meta.c cmac-des3-meta.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
diff --git a/cmac-des3-meta.c b/cmac-des3-meta.c
new file mode 100644
index 000000000000..40b27feaccdc
--- /dev/null
+++ b/cmac-des3-meta.c
@@ -0,0 +1,43 @@
+/* cmac-des3-meta.c
+
+   Copyright (C) 2013, 2014 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "nettle-meta.h"
+
+#include "cmac.h"
+
+const struct nettle_mac nettle_cmac_des3
+= _NETTLE_CMAC64(cmac_des3, DES3);
diff --git a/nettle-meta-macs.c b/nettle-meta-macs.c
index 6575ed661db3..201b30847147 100644
--- a/nettle-meta-macs.c
+++ b/nettle-meta-macs.c
@@ -40,6 +40,7 @@
 const struct nettle_mac * const _nettle_macs[] = {
   &amp;nettle_cmac_aes128,
   &amp;nettle_cmac_aes256,
+  &amp;nettle_cmac_des3,
   &amp;nettle_hmac_md5,
   &amp;nettle_hmac_ripemd160,
   &amp;nettle_hmac_sha1,
diff --git a/nettle-meta.h b/nettle-meta.h
index 4b4d312dfe0f..668c90924f1f 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -303,8 +303,21 @@ nettle_get_macs (void);
 
 #define nettle_macs (nettle_get_macs())
 
+#define _NETTLE_CMAC64(name, AES) {		\
+  #name,					\
+  sizeof(struct name##_ctx),			\
+  CMAC64_DIGEST_SIZE,				\
+  AES##_KEY_SIZE,				\
+  0,						\
+  (nettle_set_key_func *) name##_set_key,	\
+  NULL,						\
+  (nettle_hash_update_func *) name##_update,	\
+  (nettle_hash_digest_func *) name##_digest,	\
+}
+
 extern const struct nettle_mac nettle_cmac_aes128;
 extern const struct nettle_mac nettle_cmac_aes256;
+extern const struct nettle_mac nettle_cmac_des3;
 
 extern const struct nettle_mac nettle_hmac_md5;
 extern const struct nettle_mac nettle_hmac_ripemd160;
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
index 1a2cd0e591cf..a71baa086d01 100644
--- a/testsuite/cmac-test.c
+++ b/testsuite/cmac-test.c
@@ -2,18 +2,6 @@
 #include "nettle-internal.h"
 #include "cmac.h"
 
-const struct nettle_mac nettle_cmac_des3 =
-{
-  "CMAC-3DES",
-  sizeof(struct cmac_des3_ctx),
-  CMAC64_DIGEST_SIZE,
-  DES3_KEY_SIZE,
-
-  (nettle_set_key_func*) cmac_des3_set_key,
-  (nettle_hash_update_func*) cmac_des3_update,
-  (nettle_hash_digest_func*) cmac_des3_digest
-};
-
 #define test_cmac_aes128(key, msg, ref)					\
   test_mac(&amp;nettle_cmac_aes128, key, msg, ref)
 
diff --git a/testsuite/meta-mac-test.c b/testsuite/meta-mac-test.c
index 09cb5e9fd11c..4f61c3173ec3 100644
--- a/testsuite/meta-mac-test.c
+++ b/testsuite/meta-mac-test.c
@@ -5,6 +5,7 @@
 const char* macs[] = {
   "cmac_aes128",
   "cmac_aes256",
+  "cmac_des3",
   "hmac_md5",
   "hmac_ripemd160",
   "hmac_sha1",
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190806203013</emailId><senderName>johnjmar</senderName><senderEmail>johnjmar@linux.vnet.ibm.com</senderEmail><timestampReceived>2019-08-06 20:30:13-0400</timestampReceived><subject>PPC64le GHASH Vector Acceleration</subject><body>


Would like to reach community to help improve the performance of GHASH 
using POWER8 and POWER9 ISA enhancements, and to provide proof that 
achieved performance of AES-GCM is close to optimal for the platform.

Optimized implementations in the Cryptogams repository[1] may serve as 
useful references.  Financial bounty upon completion and community 
acceptance of patches.

[1] https://github.com/dot-asm/cryptogams/

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190811165925</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-08-11 16:59:25-0400</timestampReceived><subject>Re: [PATCH v2 1/6] Start separating GOST 28147-89 from GOST R 34.11-94</subject><body>

Hello,

чт, 11 июл. 2019 г. в 21:43, Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;:
&gt;
&gt; Hash function GOST R 34.11-94 (gosthash94) in its compression function
&gt; uses Russian block cipher (GOST 28147-89, Magma). Start separating block
&gt; cipher code from hash function code. For now there is no public
&gt; interface for this cipher, it will be added later.

Any feedback on v2 of patchset?

&gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190826182021</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-08-26 18:20:21-0400</timestampReceived><subject>[PATCH 1/5] gcm: use uint64_t member of nettle_block16</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Remove last usage of unsigned long member of nettle_block16.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 gcm.c | 47 ++++++++++++-----------------------------------
 1 file changed, 12 insertions(+), 35 deletions(-)

diff --git a/gcm.c b/gcm.c
index a55f603f66d5..627097b24218 100644
--- a/gcm.c
+++ b/gcm.c
@@ -133,45 +133,22 @@ shift_table[0x10] = {
 static void
 gcm_gf_shift_4(union nettle_block16 *x)
 {
-  unsigned long *w = x-&gt;w;
-  unsigned long reduce;
+  uint64_t *u64 = x-&gt;u64;
+  uint64_t reduce;
 
   /* Shift uses big-endian representation. */
 #if WORDS_BIGENDIAN
-# if SIZEOF_LONG == 4
-  reduce = shift_table[w[3] &amp; 0xf];
-  w[3] = (w[3] &gt;&gt; 4) | ((w[2] &amp; 0xf) &lt;&lt; 28);
-  w[2] = (w[2] &gt;&gt; 4) | ((w[1] &amp; 0xf) &lt;&lt; 28);
-  w[1] = (w[1] &gt;&gt; 4) | ((w[0] &amp; 0xf) &lt;&lt; 28);
-  w[0] = (w[0] &gt;&gt; 4) ^ (reduce &lt;&lt; 16);
-# elif SIZEOF_LONG == 8
-  reduce = shift_table[w[1] &amp; 0xf];
-  w[1] = (w[1] &gt;&gt; 4) | ((w[0] &amp; 0xf) &lt;&lt; 60);
-  w[0] = (w[0] &gt;&gt; 4) ^ (reduce &lt;&lt; 48);
-# else
-#  error Unsupported word size. */
-#endif
+  reduce = shift_table[u64[1] &amp; 0xf];
+  u64[1] = (u64[1] &gt;&gt; 4) | ((u64[0] &amp; 0xf) &lt;&lt; 60);
+  u64[0] = (u64[0] &gt;&gt; 4) ^ (reduce &lt;&lt; 48);
 #else /* ! WORDS_BIGENDIAN */
-# if SIZEOF_LONG == 4
-#define RSHIFT_WORD(x) \
-  ((((x) &amp; 0xf0f0f0f0UL) &gt;&gt; 4)			\
-   | (((x) &amp; 0x000f0f0f) &lt;&lt; 12))
-  reduce = shift_table[(w[3] &gt;&gt; 24) &amp; 0xf];
-  w[3] = RSHIFT_WORD(w[3]) | ((w[2] &gt;&gt; 20) &amp; 0xf0);
-  w[2] = RSHIFT_WORD(w[2]) | ((w[1] &gt;&gt; 20) &amp; 0xf0);
-  w[1] = RSHIFT_WORD(w[1]) | ((w[0] &gt;&gt; 20) &amp; 0xf0);
-  w[0] = RSHIFT_WORD(w[0]) ^ reduce;
-# elif SIZEOF_LONG == 8
-#define RSHIFT_WORD(x) \
-  ((((x) &amp; 0xf0f0f0f0f0f0f0f0UL) &gt;&gt; 4) \
-   | (((x) &amp; 0x000f0f0f0f0f0f0fUL) &lt;&lt; 12))
-  reduce = shift_table[(w[1] &gt;&gt; 56) &amp; 0xf];
-  w[1] = RSHIFT_WORD(w[1]) | ((w[0] &gt;&gt; 52) &amp; 0xf0);
-  w[0] = RSHIFT_WORD(w[0]) ^ reduce;
-# else
-#  error Unsupported word size. */
-# endif
-# undef RSHIFT_WORD
+#define RSHIFT_WORD_4(x) \
+  ((((x) &amp; UINT64_C(0xf0f0f0f0f0f0f0f0)) &gt;&gt; 4) \
+   | (((x) &amp; UINT64_C(0x000f0f0f0f0f0f0f)) &lt;&lt; 12))
+  reduce = shift_table[(u64[1] &gt;&gt; 56) &amp; 0xf];
+  u64[1] = RSHIFT_WORD_4(u64[1]) | ((u64[0] &gt;&gt; 52) &amp; 0xf0);
+  u64[0] = RSHIFT_WORD_4(u64[0]) ^ reduce;
+# undef RSHIFT_WORD_4
 #endif /* ! WORDS_BIGENDIAN */
 }
 
-- 
2.23.0.rc1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190111162609</emailId><senderName>"Yuriy M. Kaminskiy"</senderName><senderEmail>yumkam@gmail.com</senderEmail><timestampReceived>2019-01-11 16:26:09-0400</timestampReceived><subject>[repost] [PATCH] Add --enable-fat support for arm neon chacha20</subject><body>

["0001-Add-enable-fat-support-for-arm-neon-chacha20.patch" (0001-Add-enable-fat-support-for-arm-neon-chacha20.patch)]

&gt; From e86ec9188319ef08d635da38c2f8bf891e56f995 Mon Sep 17 00:00:00 2001
From: "Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt;
Date: Wed, 2 Jan 2019 19:41:32 +0300
Subject: [PATCH] Add --enable-fat support for arm neon chacha20

On BCM2837B0 (Cortex-A53) @1.4GHz (Raspberry Pi 3B+),
Before:
`gnutls-cli --benchmark-ciphers`
       CHACHA20-POLY1305 (16384) 51.54 MB/sec
`gnutls-cli --benchmark-tls-ciphers`:
       ECDHE_RSA_CHACHA20_POLY1305 (payload 1400)  21.31 MB/sec
       ECDHE_RSA_CHACHA20_POLY1305 (payload 15360)  24.60 MB/sec
`nettle-benchmark`
		 chacha     encrypt   71.90
		 chacha     decrypt   71.89
	chacha_poly1305     encrypt   48.17
	chacha_poly1305     decrypt   48.17
	chacha_poly1305      update  146.03

After:
`gnutls-cli --benchmark-ciphers`
       CHACHA20-POLY1305 (16384) 68.44 MB/sec
`gnutls-cli --benchmark-tls-ciphers`:
       ECDHE_RSA_CHACHA20_POLY1305 (payload 1400) 27.25 MB/sec
       ECDHE_RSA_CHACHA20_POLY1305 (payload 15360) 32.41 MB/sec
`nettle-benchmark`
		 chacha     encrypt  106.00
		 chacha     decrypt  105.94
	chacha_poly1305     encrypt   65.94
	chacha_poly1305     decrypt   65.96
	chacha_poly1305      update  175.24
---
 arm/fat/chacha-core-internal-2.asm | 37 +++++++++++++++++++++++++++++++++++++
 chacha-core-internal.c             |  7 +++++++
 configure.ac                       |  2 ++
 fat-arm.c                          | 10 ++++++++++
 fat-setup.h                        |  2 ++
 5 files changed, 58 insertions(+)
 create mode 100644 arm/fat/chacha-core-internal-2.asm

P.S. for reference, on same machine,
	 openssl chacha20     encrypt  236.08
	 openssl chacha20     decrypt  236.14
openssl chacha20-poly1305     encrypt  181.26
openssl chacha20-poly1305     decrypt  182.09
openssl chacha20-poly1305      update  782.67
(with openssl 1.1.0j-1~deb9u1 from debian-stretch/armhf)

diff --git a/arm/fat/chacha-core-internal-2.asm b/arm/fat/chacha-core-internal-2.asm
new file mode 100644
index 00000000..66a5c145
--- /dev/null
+++ b/arm/fat/chacha-core-internal-2.asm
@@ -0,0 +1,37 @@
+C arm/fat/chacha-core-internal-2.asm
+
+
+ifelse(&lt;
+   Copyright (C) 2015 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+&gt;)
+
+dnl PROLOGUE(_nettle_chacha_core) picked up by configure
+
+define(&lt;fat_transform&gt;, &lt;$1_neon&gt;)
+include_src(&lt;arm/neon/chacha-core-internal.asm&gt;)
diff --git a/chacha-core-internal.c b/chacha-core-internal.c
index af278bb0..0905834e 100644
--- a/chacha-core-internal.c
+++ b/chacha-core-internal.c
@@ -51,6 +51,13 @@
 
 #include "macros.h"
 
+/* For fat builds */
+#if HAVE_NATIVE_chacha_core
+void
+_nettle_chacha_core_c(uint32_t *dst, const uint32_t *src, unsigned rounds);
+#define _nettle_chacha_core  _nettle_chacha_core_c
+#endif
+
 #ifndef CHACHA_DEBUG
 # define CHACHA_DEBUG 0
 #endif
diff --git a/configure.ac b/configure.ac
index 305977d1..3f409fa4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -472,6 +472,7 @@ asm_replace_list="aes-encrypt-internal.asm aes-decrypt-internal.asm \
 # Assembler files which generate additional object files if they are used.
 asm_nettle_optional_list="gcm-hash8.asm cpuid.asm \
   aes-encrypt-internal-2.asm aes-decrypt-internal-2.asm memxor-2.asm \
+  chacha-core-internal-2.asm \
   salsa20-core-internal-2.asm sha1-compress-2.asm sha256-compress-2.asm \
   sha3-permute-2.asm sha512-compress-2.asm \
   umac-nh-n-2.asm umac-nh-2.asm"
@@ -573,6 +574,7 @@ AC_SUBST([IF_ASM])
 AH_VERBATIM([HAVE_NATIVE],
 [/* Define to 1 each of the following for which a native (ie. CPU specific)
     implementation of the corresponding routine exists.  */
+#undef HAVE_NATIVE_chacha_core
 #undef HAVE_NATIVE_ecc_192_modp
 #undef HAVE_NATIVE_ecc_192_redc
 #undef HAVE_NATIVE_ecc_224_modp
diff --git a/fat-arm.c b/fat-arm.c
index 5e656359..56099e6f 100644
--- a/fat-arm.c
+++ b/fat-arm.c
@@ -171,6 +171,10 @@ DECLARE_FAT_FUNC(_nettle_umac_nh_n, umac_nh_n_func)
 DECLARE_FAT_FUNC_VAR(umac_nh_n, umac_nh_n_func, c);
 DECLARE_FAT_FUNC_VAR(umac_nh_n, umac_nh_n_func, neon);
 
+DECLARE_FAT_FUNC(_nettle_chacha_core, chacha_core_func)
+DECLARE_FAT_FUNC_VAR(_chacha_core, chacha_core_func, c);
+DECLARE_FAT_FUNC_VAR(_chacha_core, chacha_core_func, neon);
+
 static void CONSTRUCTOR
 fat_init (void)
 {
@@ -212,6 +216,7 @@ fat_init (void)
       nettle_sha3_permute_vec = _nettle_sha3_permute_neon;
       _nettle_umac_nh_vec = _nettle_umac_nh_neon;
       _nettle_umac_nh_n_vec = _nettle_umac_nh_n_neon;
+      _nettle_chacha_core_vec = _nettle_chacha_core_neon;
     }
   else
     {
@@ -222,6 +227,7 @@ fat_init (void)
       nettle_sha3_permute_vec = _nettle_sha3_permute_c;
       _nettle_umac_nh_vec = _nettle_umac_nh_c;
       _nettle_umac_nh_n_vec = _nettle_umac_nh_n_c;
+      _nettle_chacha_core_vec = _nettle_chacha_core_c;
     }
 }
   
@@ -267,3 +273,7 @@ DEFINE_FAT_FUNC(_nettle_umac_nh_n, void,
 		 unsigned length, const uint8_t *msg),
 		(out, n, key, length, msg))
 
+DEFINE_FAT_FUNC(_nettle_chacha_core, void,
+		(uint32_t *dst, const uint32_t *src, unsigned rounds),
+		(dst, src, rounds))
+
diff --git a/fat-setup.h b/fat-setup.h
index eb7166a7..b623ebf9 100644
--- a/fat-setup.h
+++ b/fat-setup.h
@@ -174,3 +174,5 @@ typedef void sha512_compress_func (uint64_t *state, const uint8_t *input, const
 typedef uint64_t umac_nh_func (const uint32_t *key, unsigned length, const uint8_t *msg);
 typedef void umac_nh_n_func (uint64_t *out, unsigned n, const uint32_t *key,
 			     unsigned length, const uint8_t *msg);
+
+typedef void chacha_core_func(uint32_t *dst, const uint32_t *src, unsigned rounds);
-- 
2.11.0


[Attachment #3 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190310083837</emailId><senderName>"Yuriy M. Kaminskiy"</senderName><senderEmail>yumkam@gmail.com</senderEmail><timestampReceived>2019-03-10 08:38:37-0400</timestampReceived><subject>FYI: fast gcm/ghash for arm neon</subject><body>

Currently ghash/gcm performance on arm in both gcrypt and nettle is a bit abysmal:
=== bench-slopes-nettle ===
       GCM auth |     28.43 ns/B     33.54 MiB/s     39.81 c/B    1400.2
=== bench-slopes-gcrypt ===
       GCM auth |     21.86 ns/B     43.62 MiB/s     30.52 c/B    1396.0
=== bench-slopes-openssl [1.1.1a] ===
       GCM auth |      5.99 ns/B     159.3 MiB/s      8.38 c/B    1399.6
=== cut ===
Current openssl/cryptograms code is based on ideas from
https://hal.inria.fr/hal-01506572 (licensed CC BY 4.0)
and there are linked implementation
https://conradoplg.cryptoland.net/software/ecc-and-ae-for-arm-neon/
(licensed LGPL 2.1+), which I guess should be acceptable to borrow.

Very preliminary patch for nettle will be posted as reply (passes nettle
regression test, but needs more extensive testing);
=== bench-slopes-nettle [w/ patched nettle 3.3] ===
 aes128         |  nanosecs/byte   mebibytes/sec   cycles/byte
       GCM auth |      7.07 ns/B     134.9 MiB/s      9.90 c/B
=== cut ===
(And not only it is notably faster, it should be completely free of all
cache/timing leaks).
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190119084643</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-01-19 08:46:43-0400</timestampReceived><subject>Re: [repost] [PATCH] Add --enable-fat support for arm neon chacha20</subject><body>

"Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt; writes:

&gt; [PATCH] Add --enable-fat support for arm neon chacha20

Thanks, applied! Just pushed to the master-updates branch.

When the currrent ARM assembly was written, it was benchmarked on cortex
a9 and a15.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190410032308</emailId><senderName>"Yu, Mingli"</senderName><senderEmail>mingli.yu@windriver.com</senderEmail><timestampReceived>2019-04-10 03:23:08-0400</timestampReceived><subject>nettle-pbkdf2 Segmentation fault</subject><body>



# echo -n passwd| nettle-pbkdf2 -i 1 -l 16
[65534.886509] nettle-pbkdf2[708]: segfault at 1f594260 ip 
00007f3332256998 sp 00007fff60d44410 error 4 in 
libnettle.so.6.5[7f3332244000+1d00]
[65534.887525] Code: e8 6d db fe ff 44 01 6d 68 48 83 c4 08 5b 5d 41 5c 
41 5d 41 5e 41 5f c3 66 2e 0f 1f 84 00 00 00 00 00 49 89 dc e9 68 ff f
Segmentation fault
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190508123219</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-08 12:32:19-0400</timestampReceived><subject>curve448 branch</subject><body>

Hello,

Niels, Daiki, do you have plans to update/merge curve448 branch?
I'd benefit from generalized Edwards curves support, which is part of
that branch.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190511080938</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-05-11 08:09:38-0400</timestampReceived><subject>Re: curve448 branch</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; Niels, Daiki, do you have plans to update/merge curve448 branch?
&gt; I'd benefit from generalized Edwards curves support, which is part of
&gt; that branch.

My plan was to merge it after the 3.5 release, in order to (i) to be able to do it
without another abi breakage (in 3.4.x, the ecc curve symbols are exposed
directly, and then changing the size of those structs breaks linking in
some cases, due to copy relocations), and (ii) not delay 3.5 further.

And now 3.5 is severely delayed compared to what I had hoped for. Not
sure if re-plan is needed, or if I ought to focus on getting 3.5 out
asap.

Regards,
/Niels 

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190602105232</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2019-06-02 10:52:32-0400</timestampReceived><subject>Does SHA-1 switch to accelerated automatically?</subject><body>

Hi Everyone,

Re: https://www.lysator.liu.se/~nisse/nettle/nettle.html#SHA1

Does SHA-1 switch to hardware acceleration for x86 and ARMv8
automatically? Or is a different call required?

Jeff
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190603093145</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-03 09:31:45-0400</timestampReceived><subject>Re: Does SHA-1 switch to accelerated automatically?</subject><body>

Jeffrey Walton &lt;noloader@gmail.com&gt; writes:

&gt; Does SHA-1 switch to hardware acceleration for x86 and ARMv8
&gt; automatically? Or is a different call required?

If Nettle is configured with --enable-fat, choice of assembly routines
is done at runtime. Otherwise, it's a compile-time choice.

Regarding sha1, development version (to be nettle-3.5) can use sha_ni
instructions on x86_64, for both sha1 and sha256.

There isn't yet any assembly code for ARMv8.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190603095902</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2019-06-03 09:59:02-0400</timestampReceived><subject>Re: Does SHA-1 switch to accelerated automatically?</subject><body>

On Mon, Jun 3, 2019 at 5:31 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; Jeffrey Walton &lt;noloader@gmail.com&gt; writes:
&gt;
&gt; &gt; Does SHA-1 switch to hardware acceleration for x86 and ARMv8
&gt; &gt; automatically? Or is a different call required?
&gt;
&gt; If Nettle is configured with --enable-fat, choice of assembly routines
&gt; is done at runtime. Otherwise, it's a compile-time choice.
&gt;
&gt; Regarding sha1, development version (to be nettle-3.5) can use sha_ni
&gt; instructions on x86_64, for both sha1 and sha256.
&gt;
&gt; There isn't yet any assembly code for ARMv8.

Thanks Niels.

Are there any plans for ARMv8?

The reason I ask is, I want to recommend Nettle for a project. The two
biggest use cases are x86 and ARM (both 32-bit and 64-bit flavors).
Candidate libraries should have support for Intel and ARM
acceleration.

If ARMv8 is several months away then Nettle is a candidate. If there
are no plans then other libraries should be evaluated.

Jeff
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190603122144</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-03 12:21:44-0400</timestampReceived><subject>Re: Does SHA-1 switch to accelerated automatically?</subject><body>

Jeffrey Walton &lt;noloader@gmail.com&gt; writes:

&gt; Are there any plans for ARMv8?

I'm not planning to work on that soon, and I don't have any convenient
access to ARMv8 hardware. Contributions welcome.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190606212703</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-06 21:27:03-0400</timestampReceived><subject>Re: curve448 branch</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; I'm still playing around HMAC/digest refactoring, but I'm not happy with the
&gt; way code looks in my tree.

Below patch is a faitly simple way to do it. It adds internal functions
with a state_size argument, uses that when saving and restoring state,
and switches hmac_md5 to a new smaller context struct.

Key change is defining

struct hmac_md5_ctx
{
  /* Same as struct md5_ctx without the buffer. */
  struct {
    uint32_t state[_MD5_DIGEST_LENGTH];
    uint64_t count;               /* Block count */
    unsigned index;               /* Into buffer */
  } outer, inner;
  struct md5_ctx state;
};

It would be a bit cleaner to not include count and index in this struct.
hmac_md5_digest can know that when resetting the state, we always have
index == 0 and count == 1. But the general _hmac_digest doesn't know how
to write those fields.

One could consider rewriting hmac_md5_digest without using _hmac_digest.
Or rethink what helpers really are needed to implement hmac_foo_set_key
and hmac_foo_digest without too much duplication.

If one looks closer, the hmac_set_key has code for the specal case to do
an initial hashing the key if key_size &gt; block_size, but except for
that, it's really wants to invoke the compression function.

I imagine what you're working on is quite similar?

Regards,
/Niels

diff --git a/hmac-internal.h b/hmac-internal.h
new file mode 100644
index 00000000..ee486dab
--- /dev/null
+++ b/hmac-internal.h
@@ -0,0 +1,51 @@
+/* hmac-internal.h
+
+   HMAC message authentication code (RFC-2104).
+
+   Copyright (C) 2001, 2002, 2019 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_HMAC_INTERNAL_H_INCLUDED
+#define NETTLE_HMAC_INTERNAL_H_INCLUDED
+
+/* Namespace mangling */
+#define _hmac_set_key _nettle_hmac_set_key
+#define _hmac_digest _nettle_hmac_digest
+
+void
+_hmac_set_key(void *outer, void *inner, size_t state_size,
+	      void *ctx, const struct nettle_hash *hash,
+	      size_t length, const uint8_t *key);
+
+void
+_hmac_digest(const void *outer, const void *inner, size_t state_size,
+	     void *ctx, const struct nettle_hash *hash,
+	     size_t length, uint8_t *digest);
+
+#endif /* NETTLE_HMAC_H_INCLUDED */
diff --git a/hmac-md5.c b/hmac-md5.c
index a27e64f6..e0da397c 100644
--- a/hmac-md5.c
+++ b/hmac-md5.c
@@ -35,13 +35,24 @@
 # include "config.h"
 #endif
 
+#include &lt;stddef.h&gt;
+
 #include "hmac.h"
+#include "hmac-internal.h"
+
+#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))
+
+/* Padding may be different in struct md5_ctx and struct hmac_md5_ctx,
+   so use the smallest one when saving and restoring state. */
+#define MD5_STATE_SIZE MIN(sizeof(((struct hmac_md5_ctx *)NULL)-&gt;outer), \
+			   offsetof(struct md5_ctx, block))
 
 void
 hmac_md5_set_key(struct hmac_md5_ctx *ctx,
 		 size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_md5, key_length, key);
+  _hmac_set_key(&amp;ctx-&gt;outer, &amp;ctx-&gt;inner, MD5_STATE_SIZE,
+		&amp;ctx-&gt;state, &amp;nettle_md5, key_length, key);
 }
 
 void
@@ -55,5 +66,7 @@ void
 hmac_md5_digest(struct hmac_md5_ctx *ctx,
 		size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_md5, length, digest);
+  _hmac_digest(&amp;ctx-&gt;outer, &amp;ctx-&gt;inner, MD5_STATE_SIZE,
+	       &amp;ctx-&gt;state, &amp;nettle_md5,
+	       length, digest);
 }
diff --git a/hmac.c b/hmac.c
index 6ac5e11a..318de8a2 100644
--- a/hmac.c
+++ b/hmac.c
@@ -2,7 +2,7 @@
 
    HMAC message authentication code (RFC-2104).
 
-   Copyright (C) 2001 Niels Möller
+   Copyright (C) 2001, 2019 Niels Möller
 
    This file is part of GNU Nettle.
 
@@ -42,6 +42,7 @@
 
 #include "hmac.h"
 
+#include "hmac-internal.h"
 #include "memxor.h"
 #include "nettle-internal.h"
 
@@ -49,15 +50,15 @@
 #define OPAD 0x5c
 
 void
-hmac_set_key(void *outer, void *inner, void *state,
-	     const struct nettle_hash *hash,
-	     size_t key_length, const uint8_t *key)
+_hmac_set_key(void *outer, void *inner, size_t state_size,
+	      void *ctx,
+	      const struct nettle_hash *hash,
+	      size_t key_length, const uint8_t *key)
 {
   TMP_DECL(pad, uint8_t, NETTLE_MAX_HASH_BLOCK_SIZE);
   TMP_ALLOC(pad, hash-&gt;block_size);
   
-  hash-&gt;init(outer);
-  hash-&gt;init(inner);
+  hash-&gt;init(ctx);
 
   if (key_length &gt; hash-&gt;block_size)
     {
@@ -67,9 +68,8 @@ hmac_set_key(void *outer, void *inner, void *state,
       TMP_DECL(digest, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);
       TMP_ALLOC(digest, hash-&gt;digest_size);
 
-      hash-&gt;init(state);
-      hash-&gt;update(state, key_length, key);
-      hash-&gt;digest(state, hash-&gt;digest_size, digest);
+      hash-&gt;update(ctx, key_length, key);
+      hash-&gt;digest(ctx, hash-&gt;digest_size, digest);
 
       key = digest;
       key_length = hash-&gt;digest_size;
@@ -80,14 +80,24 @@ hmac_set_key(void *outer, void *inner, void *state,
   memset(pad, OPAD, hash-&gt;block_size);
   memxor(pad, key, key_length);
 
-  hash-&gt;update(outer, hash-&gt;block_size, pad);
+  hash-&gt;update(ctx, hash-&gt;block_size, pad);
+  memcpy(outer, ctx, state_size);
 
   memset(pad, IPAD, hash-&gt;block_size);
   memxor(pad, key, key_length);
+  hash-&gt;init(ctx);
+  hash-&gt;update(ctx, hash-&gt;block_size, pad);
 
-  hash-&gt;update(inner, hash-&gt;block_size, pad);
+  memcpy(inner, ctx, state_size);
+}
 
-  memcpy(state, inner, hash-&gt;context_size);
+void
+hmac_set_key(void *outer, void *inner, void *state,
+	     const struct nettle_hash *hash,
+	     size_t key_length, const uint8_t *key)
+{
+  _hmac_set_key(outer, inner, hash-&gt;context_size,
+		state, hash, key_length, key);
 }
 
 void
@@ -99,19 +109,28 @@ hmac_update(void *state,
 }
 
 void
-hmac_digest(const void *outer, const void *inner, void *state,
-	    const struct nettle_hash *hash, 	    
-	    size_t length, uint8_t *dst)
+_hmac_digest(const void *outer, const void *inner, size_t state_size,
+	     void *ctx,
+	     const struct nettle_hash *hash,
+	     size_t length, uint8_t *dst)
 {
   TMP_DECL(digest, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);
   TMP_ALLOC(digest, hash-&gt;digest_size);
 
-  hash-&gt;digest(state, hash-&gt;digest_size, digest);
+  hash-&gt;digest(ctx, hash-&gt;digest_size, digest);
 
-  memcpy(state, outer, hash-&gt;context_size);
+  memcpy(ctx, outer, state_size);
 
-  hash-&gt;update(state, hash-&gt;digest_size, digest);
-  hash-&gt;digest(state, length, dst);
+  hash-&gt;update(ctx, hash-&gt;digest_size, digest);
+  hash-&gt;digest(ctx, length, dst);
 
-  memcpy(state, inner, hash-&gt;context_size);
+  memcpy(ctx, inner, state_size);
+}
+
+void
+hmac_digest(const void *outer, const void *inner, void *state,
+	    const struct nettle_hash *hash,
+	    size_t length, uint8_t *dst)
+{
+  _hmac_digest(outer, inner, hash-&gt;context_size, state, hash, length, dst);
 }
diff --git a/hmac.h b/hmac.h
index 40a8e77a..b574ab2f 100644
--- a/hmac.h
+++ b/hmac.h
@@ -101,7 +101,16 @@ hmac_digest(const void *outer, const void *inner, void *state,
 /* HMAC using specific hash functions */
 
 /* hmac-md5 */
-struct hmac_md5_ctx HMAC_CTX(struct md5_ctx);
+struct hmac_md5_ctx
+{
+  /* Same as struct md5_ctx without the buffer. */
+  struct {
+    uint32_t state[_MD5_DIGEST_LENGTH];
+    uint64_t count;               /* Block count */
+    unsigned index;               /* Into buffer */
+  } outer, inner;
+  struct md5_ctx state;
+};
 
 void
 hmac_md5_set_key(struct hmac_md5_ctx *ctx,

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190609120455</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-06-09 12:04:55-0400</timestampReceived><subject>Re: curve448 branch</subject><body>

Hi,

пт, 7 июн. 2019 г. в 00:27, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; I'm still playing around HMAC/digest refactoring, but I'm not happy with the
&gt; &gt; way code looks in my tree.
&gt;
&gt; Below patch is a faitly simple way to do it. It adds internal functions
&gt; with a state_size argument, uses that when saving and restoring state,
&gt; and switches hmac_md5 to a new smaller context struct.

I have pushed my current state to
https://gitlab.com/GostCrypt/nettle/tree/hmac-2

MD5 and HMAC-MD5 were converted to demonstrate my proposal.

The key change is the split of md5_ctx into md5_state and block_ctx
and later reusal
of common block_ctx in all operations. Unfortunately this changes nettle_hash
interface.

I have kept old HMAC interface in place. It can be deprecated and/or
removed later.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190410043114</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2019-04-10 04:31:14-0400</timestampReceived><subject>Re: nettle-pbkdf2 Segmentation fault</subject><body>

Which version do you use?
I am getting usage in 3.6.1 as SALT parameter is missing.

On Wed, Apr 10, 2019 at 6:19 AM Yu, Mingli &lt;mingli.yu@windriver.com&gt; wrote:

&gt;
&gt;
&gt; # echo -n passwd| nettle-pbkdf2 -i 1 -l 16
&gt; [65534.886509] nettle-pbkdf2[708]: segfault at 1f594260 ip
&gt; 00007f3332256998 sp 00007fff60d44410 error 4 in
&gt; libnettle.so.6.5[7f3332244000+1d00]
&gt; [65534.887525] Code: e8 6d db fe ff 44 01 6d 68 48 83 c4 08 5b 5d 41 5c
&gt; 41 5d 41 5e 41 5f c3 66 2e 0f 1f 84 00 00 00 00 00 49 89 dc e9 68 ff f
&gt; Segmentation fault
&gt; _______________________________________________
&gt; nettle-bugs mailing list
&gt; nettle-bugs@lists.lysator.liu.se
&gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs
&gt;
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702123535</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 12:35:35-0400</timestampReceived><subject>Re: Changes after 3.5.1</subject><body>

Hello,

вт, 2 июл. 2019 г. в 15:03, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; I have several patch series that were sitting in my local gost tree.
&gt; &gt; Most of them were posted to this mailing list for review with little
&gt; &gt; to no feedback.
&gt;
&gt; &gt;  - CMAC-64 support (together with CMAC-TDES for testing).
&gt; &gt;  - Changes to GOST R 34.11-94 (gosthash94) code
&gt; &gt;  - GOST 28147-89/Magma 64-bit cipher (depend on gosthash94 changes)
&gt; &gt;  - Additional cipher modes required for full GOST 28147-89 support
&gt; &gt;  - Streebog hash algorithm (GOST R 34.11-2012)
&gt; &gt;  - Several GOST curves (2 for now, other require changes to ecc backend)
&gt; &gt;  - GOST ECC-based digital signature scheme
&gt; &gt;  - GOST ECC-based key agreement
&gt; &gt;  - small chunks of additional support code
&gt;
&gt; Except for the last one (not sure what those changes are), this looks
&gt; like a reasonable order. For the ecc things, I think I'd give the ed448
&gt; changes higher priority.
&gt;
&gt; Can you resend links for the first two or thee changes, or resend latest
&gt; patches?

OK, I will just resend patches for CMAC-64 and for gosthash94/gost28147.


-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702123857</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 12:38:57-0400</timestampReceived><subject>[PATCH 3/4] cmac: add CMAC-DES3 (CMAC-TDES) implementation</subject><body>

Implement CMAC using TrippleDES as underlying cipher.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in           |  2 +-
 cmac-des3.c           | 61 +++++++++++++++++++++++++++++++++++++++++++
 cmac.h                | 17 ++++++++++++
 testsuite/cmac-test.c | 32 +++++++++++++++++++++++
 4 files changed, 111 insertions(+), 1 deletion(-)
 create mode 100644 cmac-des3.c

diff --git a/Makefile.in b/Makefile.in
index 537e97d19bea..2e60c2f70ac6 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -101,7 +101,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-aes256.c gcm-aes256-meta.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
-		 cmac.c cmac-aes128.c cmac-aes256.c \
+		 cmac.c cmac-aes128.c cmac-aes256.c cmac-des3.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
diff --git a/cmac-des3.c b/cmac-des3.c
new file mode 100644
index 000000000000..d2d55ca43e75
--- /dev/null
+++ b/cmac-des3.c
@@ -0,0 +1,61 @@
+/* cmac-des3.c
+
+   CMAC using TrippleDES as the underlying cipher.
+
+   Copyright (C) 2019 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "cmac.h"
+
+void
+cmac_des3_set_key (struct cmac_des3_ctx *ctx, const uint8_t *key)
+{
+  CMAC64_SET_KEY (ctx, des3_set_key, des3_encrypt, key);
+}
+
+void
+cmac_des3_update (struct cmac_des3_ctx *ctx,
+		  size_t length, const uint8_t *data)
+{
+  CMAC64_UPDATE (ctx, des3_encrypt, length, data);
+}
+
+void
+cmac_des3_digest (struct cmac_des3_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  CMAC64_DIGEST (ctx, des3_encrypt, length, digest);
+}
+
diff --git a/cmac.h b/cmac.h
index 0cf9462d2120..ecad3778f71e 100644
--- a/cmac.h
+++ b/cmac.h
@@ -37,6 +37,7 @@
 #define NETTLE_CMAC_H_INCLUDED
 
 #include "aes.h"
+#include "des.h"
 #include "nettle-types.h"
 
 #ifdef __cplusplus
@@ -61,6 +62,9 @@ extern "C" {
 #define cmac64_init nettle_cmac64_init
 #define cmac64_update nettle_cmac64_update
 #define cmac64_digest nettle_cmac64_digest
+#define cmac_des3_set_key nettle_cmac_des3_set_key
+#define cmac_des3_update nettle_cmac_des3_update
+#define cmac_des3_digest nettle_cmac_des3_digest
 
 struct cmac128_key
 {
@@ -213,6 +217,19 @@ void
 cmac_aes256_digest(struct cmac_aes256_ctx *ctx,
 		   size_t length, uint8_t *digest);
 
+struct cmac_des3_ctx CMAC64_CTX(struct des3_ctx);
+
+void
+cmac_des3_set_key(struct cmac_des3_ctx *ctx, const uint8_t *key);
+
+void
+cmac_des3_update(struct cmac_des3_ctx *ctx,
+		 size_t length, const uint8_t *data);
+
+void
+cmac_des3_digest(struct cmac_des3_ctx *ctx,
+		 size_t length, uint8_t *digest);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
index b1d4aa30dfbe..9d6682777dcf 100644
--- a/testsuite/cmac-test.c
+++ b/testsuite/cmac-test.c
@@ -26,12 +26,27 @@ const struct nettle_mac nettle_cmac_aes256 =
   (nettle_hash_digest_func*) cmac_aes256_digest
 };
 
+const struct nettle_mac nettle_cmac_des3 =
+{
+  "CMAC-3DES",
+  sizeof(struct cmac_des3_ctx),
+  CMAC64_DIGEST_SIZE,
+  DES3_KEY_SIZE,
+
+  (nettle_set_key_func*) cmac_des3_set_key,
+  (nettle_hash_update_func*) cmac_des3_update,
+  (nettle_hash_digest_func*) cmac_des3_digest
+};
+
 #define test_cmac_aes128(key, msg, ref)					\
   test_mac(&amp;nettle_cmac_aes128, key, msg, ref)
 
 #define test_cmac_aes256(key, msg, ref)					\
   test_mac(&amp;nettle_cmac_aes256, key, msg, ref)
 
+#define test_cmac_des3(key, msg, ref)					\
+  test_mac(&amp;nettle_cmac_des3, key, msg, ref)
+
 void
 test_main(void)
 {
@@ -96,4 +111,21 @@ test_main(void)
 		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710"),
  SHEX("e1992190549f6ed5696a2c056c315410"));
 
+  /* CMAC-3DES vectors from NIST SP800-38B examples */
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SDATA(""),
+		  SHEX("7db0d37df936c550"));
+
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
+		  SHEX("30239cf1f52e6609"));
+
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a57"),
+		  SHEX("6c9f3ee4923f6be2"));
+
+
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e51"),
+		  SHEX("99429bd0bf7904e5"));
 }
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190702123858</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 12:38:58-0400</timestampReceived><subject>[PATCH 4/4] Expand documentation to cover CMAC-64</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 nettle.texinfo | 38 ++++++++++++++++++++++++++++++++++----
 1 file changed, 34 insertions(+), 4 deletions(-)

diff --git a/nettle.texinfo b/nettle.texinfo
index b8579a6ed59b..57e6345f78df 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -3718,14 +3718,21 @@ as described above, the new value is used unless you call the
 @node CMAC,, UMAC, Keyed hash functions
 @subsection @acronym{CMAC}
 @cindex CMAC
+@cindex CMAC-128
+@cindex CMAC-64
 
 @acronym{CMAC} is a message authentication code based on CBC encryption
 mode. It is suitable for systems where block ciphers are preferrable
-and perform better than hash functions. @acronym{CMAC} is specified in
+and perform better than hash functions. @acronym{CMAC-128} is specified in
 @cite{RFC4493}. The block size is always 128 bits (16 octets).
+@acronym{CMAC-64} is specified by
+@uref{https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38B.pdf,
+NIST Special Publication 800-38B}. The block size is always 64 bits
+(8 octets).
 
-Nettle provides helper functions for @acronym{CMAC } with
-the @acronym{AES} block cipher.
+Nettle provides helper functions for @acronym{CMAC-128} with
+the @acronym{AES} block cipher and for @acronym{CMAC-64} with
+the @acronym{Tripple-DES} block cipher.
 
 Nettle defines @acronym{CMAC} in @file{&lt;nettle/cmac.h&gt;}.
 
@@ -3734,7 +3741,7 @@ Nettle defines @acronym{CMAC} in @file{&lt;nettle/cmac.h&gt;}.
 @end deftp
 
 @defvr Constant CMAC128_DIGEST_SIZE
-The size of an CMAC digest, 16.
+The size of an CMAC-128 digest, 16.
 @end defvr
 
 @deftypefun void cmac_aes128_set_key (struct cmac_aes128_ctx *@var{ctx}, const \
uint8_t *@var{key}) @@ -3769,6 +3776,29 @@ provide a smaller value, only the first \
@var{length} octets of the  processing of a new message with the same key.
 @end deftypefun
 
+@deftp {Context struct} {struct cmac_des3_ctx}
+@end deftp
+
+@defvr Constant CMAC64_DIGEST_SIZE
+The size of an CMAC-64 digest, 8.
+@end defvr
+
+@deftypefun void cmac_des3_set_key (struct cmac_des3_ctx *@var{ctx}, const uint8_t \
*@var{key}) +This function initializes the @acronym{CMAC} context struct for \
@acronym{Tripple-DES}. +@end deftypefun
+
+@deftypefun void cmac_des3_update (struct cmac_des3_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +This function is called zero or more times \
to process the message. +@end deftypefun
+
+@deftypefun void cmac_des3_digest (struct cmac_des3_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Extracts the @acronym{MAC} of the message, \
writing it to @var{digest}. +@var{length} is usually equal to the specified output \
size, but if you +provide a smaller value, only the first @var{length} octets of the
+@acronym{MAC} are written. This function resets the context for
+processing of a new message with the same key.
+@end deftypefun
+
 @node Poly1305,, CMAC, Keyed hash functions
 @comment  node-name,  next,  previous,  up
 @subsection Poly1305
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190702131854</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:18:54-0400</timestampReceived><subject>[PATCH 2/6] Add GOST R 34.11 to nettle_hashes</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 nettle-meta-hashes.c       | 1 +
 testsuite/meta-hash-test.c | 1 +
 2 files changed, 2 insertions(+)

diff --git a/nettle-meta-hashes.c b/nettle-meta-hashes.c
index 37552edec5ca..f0ef026d359f 100644
--- a/nettle-meta-hashes.c
+++ b/nettle-meta-hashes.c
@@ -41,6 +41,7 @@ const struct nettle_hash * const _nettle_hashes[] = {
   &amp;nettle_md2,
   &amp;nettle_md4,
   &amp;nettle_md5,
+  &amp;nettle_gosthash94,
   &amp;nettle_ripemd160,
   &amp;nettle_sha1,
   &amp;nettle_sha224,
diff --git a/testsuite/meta-hash-test.c b/testsuite/meta-hash-test.c
index 4754f66596ee..5b6258889e5d 100644
--- a/testsuite/meta-hash-test.c
+++ b/testsuite/meta-hash-test.c
@@ -8,6 +8,7 @@ const char* hashes[] = {
   "md2",
   "md4",
   "md5",
+  "gosthash94",
   "ripemd160",
   "sha1",
   "sha224",
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702131855</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:18:55-0400</timestampReceived><subject>[PATCH 3/6] Add support for GOSTHASH94CP: GOST R 34.11-94 hash with CryptoPro S-box</subject><body>

Hash gosthash94 implements GOST R 34.11-94 standard using S-Box defined
in the standard 'for testing purposes only'. RFC 4357 defines S-Box
(CryptoPro one) for GOST R 34.11-94 hash function that is widely used in
applications. Add separate hash function algorithm (gosthash94cp)
implementing GOST R 34.11-94 hashing using that S-Box.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 examples/nettle-benchmark.c |   1 +
 gost28147.c                 | 266 ++++++++++++++++++++++++++++++++++++
 gost28147.h                 |   2 +
 gosthash94-meta.c           |   3 +
 gosthash94.c                |  83 +++++++++--
 gosthash94.h                |  13 ++
 nettle-meta-hashes.c        |   1 +
 nettle-meta.h               |   1 +
 nettle.texinfo              |  41 +++++-
 testsuite/gosthash94-test.c |  12 ++
 testsuite/meta-hash-test.c  |   1 +
 11 files changed, 406 insertions(+), 18 deletions(-)

diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index 6e0f560b6bdc..5d0e649ea726 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -918,6 +918,7 @@ main(int argc, char **argv)
       &amp;nettle_sha3_224, &amp;nettle_sha3_256,
       &amp;nettle_sha3_384, &amp;nettle_sha3_512,
       &amp;nettle_ripemd160, &amp;nettle_gosthash94,
+      &amp;nettle_gosthash94cp,
       NULL
     };
 
diff --git a/gost28147.c b/gost28147.c
index c734c4365fa7..cbe6b0d9b3df 100644
--- a/gost28147.c
+++ b/gost28147.c
@@ -302,6 +302,272 @@ const struct gost28147_param gost28147_param_test_3411 =
   }
 };
 
+const struct gost28147_param gost28147_param_CryptoPro_3411 =
+{
+  {
+    /* 0 */
+    0x0002d000, 0x0002a000, 0x0002a800, 0x0002b000,
+    0x0002c000, 0x00028800, 0x00029800, 0x0002b800,
+    0x0002e800, 0x0002e000, 0x0002f000, 0x00028000,
+    0x0002c800, 0x00029000, 0x0002d800, 0x0002f800,
+    0x0007d000, 0x0007a000, 0x0007a800, 0x0007b000,
+    0x0007c000, 0x00078800, 0x00079800, 0x0007b800,
+    0x0007e800, 0x0007e000, 0x0007f000, 0x00078000,
+    0x0007c800, 0x00079000, 0x0007d800, 0x0007f800,
+    0x00025000, 0x00022000, 0x00022800, 0x00023000,
+    0x00024000, 0x00020800, 0x00021800, 0x00023800,
+    0x00026800, 0x00026000, 0x00027000, 0x00020000,
+    0x00024800, 0x00021000, 0x00025800, 0x00027800,
+    0x00005000, 0x00002000, 0x00002800, 0x00003000,
+    0x00004000, 0x00000800, 0x00001800, 0x00003800,
+    0x00006800, 0x00006000, 0x00007000, 0x00000000,
+    0x00004800, 0x00001000, 0x00005800, 0x00007800,
+    0x00015000, 0x00012000, 0x00012800, 0x00013000,
+    0x00014000, 0x00010800, 0x00011800, 0x00013800,
+    0x00016800, 0x00016000, 0x00017000, 0x00010000,
+    0x00014800, 0x00011000, 0x00015800, 0x00017800,
+    0x0006d000, 0x0006a000, 0x0006a800, 0x0006b000,
+    0x0006c000, 0x00068800, 0x00069800, 0x0006b800,
+    0x0006e800, 0x0006e000, 0x0006f000, 0x00068000,
+    0x0006c800, 0x00069000, 0x0006d800, 0x0006f800,
+    0x0005d000, 0x0005a000, 0x0005a800, 0x0005b000,
+    0x0005c000, 0x00058800, 0x00059800, 0x0005b800,
+    0x0005e800, 0x0005e000, 0x0005f000, 0x00058000,
+    0x0005c800, 0x00059000, 0x0005d800, 0x0005f800,
+    0x0004d000, 0x0004a000, 0x0004a800, 0x0004b000,
+    0x0004c000, 0x00048800, 0x00049800, 0x0004b800,
+    0x0004e800, 0x0004e000, 0x0004f000, 0x00048000,
+    0x0004c800, 0x00049000, 0x0004d800, 0x0004f800,
+    0x0000d000, 0x0000a000, 0x0000a800, 0x0000b000,
+    0x0000c000, 0x00008800, 0x00009800, 0x0000b800,
+    0x0000e800, 0x0000e000, 0x0000f000, 0x00008000,
+    0x0000c800, 0x00009000, 0x0000d800, 0x0000f800,
+    0x0003d000, 0x0003a000, 0x0003a800, 0x0003b000,
+    0x0003c000, 0x00038800, 0x00039800, 0x0003b800,
+    0x0003e800, 0x0003e000, 0x0003f000, 0x00038000,
+    0x0003c800, 0x00039000, 0x0003d800, 0x0003f800,
+    0x00035000, 0x00032000, 0x00032800, 0x00033000,
+    0x00034000, 0x00030800, 0x00031800, 0x00033800,
+    0x00036800, 0x00036000, 0x00037000, 0x00030000,
+    0x00034800, 0x00031000, 0x00035800, 0x00037800,
+    0x0001d000, 0x0001a000, 0x0001a800, 0x0001b000,
+    0x0001c000, 0x00018800, 0x00019800, 0x0001b800,
+    0x0001e800, 0x0001e000, 0x0001f000, 0x00018000,
+    0x0001c800, 0x00019000, 0x0001d800, 0x0001f800,
+    0x00065000, 0x00062000, 0x00062800, 0x00063000,
+    0x00064000, 0x00060800, 0x00061800, 0x00063800,
+    0x00066800, 0x00066000, 0x00067000, 0x00060000,
+    0x00064800, 0x00061000, 0x00065800, 0x00067800,
+    0x00075000, 0x00072000, 0x00072800, 0x00073000,
+    0x00074000, 0x00070800, 0x00071800, 0x00073800,
+    0x00076800, 0x00076000, 0x00077000, 0x00070000,
+    0x00074800, 0x00071000, 0x00075800, 0x00077800,
+    0x00055000, 0x00052000, 0x00052800, 0x00053000,
+    0x00054000, 0x00050800, 0x00051800, 0x00053800,
+    0x00056800, 0x00056000, 0x00057000, 0x00050000,
+    0x00054800, 0x00051000, 0x00055800, 0x00057800,
+    0x00045000, 0x00042000, 0x00042800, 0x00043000,
+    0x00044000, 0x00040800, 0x00041800, 0x00043800,
+    0x00046800, 0x00046000, 0x00047000, 0x00040000,
+    0x00044800, 0x00041000, 0x00045800, 0x00047800,
+    /* 1 */
+    0x02380000, 0x02780000, 0x02600000, 0x02700000,
+    0x02480000, 0x02200000, 0x02080000, 0x02000000,
+    0x02180000, 0x02580000, 0x02280000, 0x02100000,
+    0x02300000, 0x02500000, 0x02400000, 0x02680000,
+    0x05380000, 0x05780000, 0x05600000, 0x05700000,
+    0x05480000, 0x05200000, 0x05080000, 0x05000000,
+    0x05180000, 0x05580000, 0x05280000, 0x05100000,
+    0x05300000, 0x05500000, 0x05400000, 0x05680000,
+    0x03b80000, 0x03f80000, 0x03e00000, 0x03f00000,
+    0x03c80000, 0x03a00000, 0x03880000, 0x03800000,
+    0x03980000, 0x03d80000, 0x03a80000, 0x03900000,
+    0x03b00000, 0x03d00000, 0x03c00000, 0x03e80000,
+    0x06380000, 0x06780000, 0x06600000, 0x06700000,
+    0x06480000, 0x06200000, 0x06080000, 0x06000000,
+    0x06180000, 0x06580000, 0x06280000, 0x06100000,
+    0x06300000, 0x06500000, 0x06400000, 0x06680000,
+    0x00380000, 0x00780000, 0x00600000, 0x00700000,
+    0x00480000, 0x00200000, 0x00080000, 0x00000000,
+    0x00180000, 0x00580000, 0x00280000, 0x00100000,
+    0x00300000, 0x00500000, 0x00400000, 0x00680000,
+    0x07b80000, 0x07f80000, 0x07e00000, 0x07f00000,
+    0x07c80000, 0x07a00000, 0x07880000, 0x07800000,
+    0x07980000, 0x07d80000, 0x07a80000, 0x07900000,
+    0x07b00000, 0x07d00000, 0x07c00000, 0x07e80000,
+    0x01380000, 0x01780000, 0x01600000, 0x01700000,
+    0x01480000, 0x01200000, 0x01080000, 0x01000000,
+    0x01180000, 0x01580000, 0x01280000, 0x01100000,
+    0x01300000, 0x01500000, 0x01400000, 0x01680000,
+    0x04380000, 0x04780000, 0x04600000, 0x04700000,
+    0x04480000, 0x04200000, 0x04080000, 0x04000000,
+    0x04180000, 0x04580000, 0x04280000, 0x04100000,
+    0x04300000, 0x04500000, 0x04400000, 0x04680000,
+    0x07380000, 0x07780000, 0x07600000, 0x07700000,
+    0x07480000, 0x07200000, 0x07080000, 0x07000000,
+    0x07180000, 0x07580000, 0x07280000, 0x07100000,
+    0x07300000, 0x07500000, 0x07400000, 0x07680000,
+    0x00b80000, 0x00f80000, 0x00e00000, 0x00f00000,
+    0x00c80000, 0x00a00000, 0x00880000, 0x00800000,
+    0x00980000, 0x00d80000, 0x00a80000, 0x00900000,
+    0x00b00000, 0x00d00000, 0x00c00000, 0x00e80000,
+    0x03380000, 0x03780000, 0x03600000, 0x03700000,
+    0x03480000, 0x03200000, 0x03080000, 0x03000000,
+    0x03180000, 0x03580000, 0x03280000, 0x03100000,
+    0x03300000, 0x03500000, 0x03400000, 0x03680000,
+    0x02b80000, 0x02f80000, 0x02e00000, 0x02f00000,
+    0x02c80000, 0x02a00000, 0x02880000, 0x02800000,
+    0x02980000, 0x02d80000, 0x02a80000, 0x02900000,
+    0x02b00000, 0x02d00000, 0x02c00000, 0x02e80000,
+    0x06b80000, 0x06f80000, 0x06e00000, 0x06f00000,
+    0x06c80000, 0x06a00000, 0x06880000, 0x06800000,
+    0x06980000, 0x06d80000, 0x06a80000, 0x06900000,
+    0x06b00000, 0x06d00000, 0x06c00000, 0x06e80000,
+    0x05b80000, 0x05f80000, 0x05e00000, 0x05f00000,
+    0x05c80000, 0x05a00000, 0x05880000, 0x05800000,
+    0x05980000, 0x05d80000, 0x05a80000, 0x05900000,
+    0x05b00000, 0x05d00000, 0x05c00000, 0x05e80000,
+    0x04b80000, 0x04f80000, 0x04e00000, 0x04f00000,
+    0x04c80000, 0x04a00000, 0x04880000, 0x04800000,
+    0x04980000, 0x04d80000, 0x04a80000, 0x04900000,
+    0x04b00000, 0x04d00000, 0x04c00000, 0x04e80000,
+    0x01b80000, 0x01f80000, 0x01e00000, 0x01f00000,
+    0x01c80000, 0x01a00000, 0x01880000, 0x01800000,
+    0x01980000, 0x01d80000, 0x01a80000, 0x01900000,
+    0x01b00000, 0x01d00000, 0x01c00000, 0x01e80000,
+    /* 2 */
+    0xb8000003, 0xb0000003, 0xa0000003, 0xd8000003,
+    0xc8000003, 0xe0000003, 0x90000003, 0xd0000003,
+    0x88000003, 0xc0000003, 0x80000003, 0xf0000003,
+    0xf8000003, 0xe8000003, 0x98000003, 0xa8000003,
+    0x38000003, 0x30000003, 0x20000003, 0x58000003,
+    0x48000003, 0x60000003, 0x10000003, 0x50000003,
+    0x08000003, 0x40000003, 0x00000003, 0x70000003,
+    0x78000003, 0x68000003, 0x18000003, 0x28000003,
+    0x38000001, 0x30000001, 0x20000001, 0x58000001,
+    0x48000001, 0x60000001, 0x10000001, 0x50000001,
+    0x08000001, 0x40000001, 0x00000001, 0x70000001,
+    0x78000001, 0x68000001, 0x18000001, 0x28000001,
+    0x38000002, 0x30000002, 0x20000002, 0x58000002,
+    0x48000002, 0x60000002, 0x10000002, 0x50000002,
+    0x08000002, 0x40000002, 0x00000002, 0x70000002,
+    0x78000002, 0x68000002, 0x18000002, 0x28000002,
+    0xb8000006, 0xb0000006, 0xa0000006, 0xd8000006,
+    0xc8000006, 0xe0000006, 0x90000006, 0xd0000006,
+    0x88000006, 0xc0000006, 0x80000006, 0xf0000006,
+    0xf8000006, 0xe8000006, 0x98000006, 0xa8000006,
+    0xb8000004, 0xb0000004, 0xa0000004, 0xd8000004,
+    0xc8000004, 0xe0000004, 0x90000004, 0xd0000004,
+    0x88000004, 0xc0000004, 0x80000004, 0xf0000004,
+    0xf8000004, 0xe8000004, 0x98000004, 0xa8000004,
+    0xb8000007, 0xb0000007, 0xa0000007, 0xd8000007,
+    0xc8000007, 0xe0000007, 0x90000007, 0xd0000007,
+    0x88000007, 0xc0000007, 0x80000007, 0xf0000007,
+    0xf8000007, 0xe8000007, 0x98000007, 0xa8000007,
+    0x38000000, 0x30000000, 0x20000000, 0x58000000,
+    0x48000000, 0x60000000, 0x10000000, 0x50000000,
+    0x08000000, 0x40000000, 0x00000000, 0x70000000,
+    0x78000000, 0x68000000, 0x18000000, 0x28000000,
+    0x38000005, 0x30000005, 0x20000005, 0x58000005,
+    0x48000005, 0x60000005, 0x10000005, 0x50000005,
+    0x08000005, 0x40000005, 0x00000005, 0x70000005,
+    0x78000005, 0x68000005, 0x18000005, 0x28000005,
+    0xb8000000, 0xb0000000, 0xa0000000, 0xd8000000,
+    0xc8000000, 0xe0000000, 0x90000000, 0xd0000000,
+    0x88000000, 0xc0000000, 0x80000000, 0xf0000000,
+    0xf8000000, 0xe8000000, 0x98000000, 0xa8000000,
+    0xb8000002, 0xb0000002, 0xa0000002, 0xd8000002,
+    0xc8000002, 0xe0000002, 0x90000002, 0xd0000002,
+    0x88000002, 0xc0000002, 0x80000002, 0xf0000002,
+    0xf8000002, 0xe8000002, 0x98000002, 0xa8000002,
+    0xb8000005, 0xb0000005, 0xa0000005, 0xd8000005,
+    0xc8000005, 0xe0000005, 0x90000005, 0xd0000005,
+    0x88000005, 0xc0000005, 0x80000005, 0xf0000005,
+    0xf8000005, 0xe8000005, 0x98000005, 0xa8000005,
+    0x38000004, 0x30000004, 0x20000004, 0x58000004,
+    0x48000004, 0x60000004, 0x10000004, 0x50000004,
+    0x08000004, 0x40000004, 0x00000004, 0x70000004,
+    0x78000004, 0x68000004, 0x18000004, 0x28000004,
+    0x38000007, 0x30000007, 0x20000007, 0x58000007,
+    0x48000007, 0x60000007, 0x10000007, 0x50000007,
+    0x08000007, 0x40000007, 0x00000007, 0x70000007,
+    0x78000007, 0x68000007, 0x18000007, 0x28000007,
+    0x38000006, 0x30000006, 0x20000006, 0x58000006,
+    0x48000006, 0x60000006, 0x10000006, 0x50000006,
+    0x08000006, 0x40000006, 0x00000006, 0x70000006,
+    0x78000006, 0x68000006, 0x18000006, 0x28000006,
+    0xb8000001, 0xb0000001, 0xa0000001, 0xd8000001,
+    0xc8000001, 0xe0000001, 0x90000001, 0xd0000001,
+    0x88000001, 0xc0000001, 0x80000001, 0xf0000001,
+    0xf8000001, 0xe8000001, 0x98000001, 0xa8000001,
+    /* 3 */
+    0x000000e8, 0x000000f0, 0x000000a0, 0x00000088,
+    0x000000b8, 0x00000080, 0x000000a8, 0x000000d0,
+    0x00000098, 0x000000e0, 0x000000c0, 0x000000f8,
+    0x000000b0, 0x00000090, 0x000000c8, 0x000000d8,
+    0x000001e8, 0x000001f0, 0x000001a0, 0x00000188,
+    0x000001b8, 0x00000180, 0x000001a8, 0x000001d0,
+    0x00000198, 0x000001e0, 0x000001c0, 0x000001f8,
+    0x000001b0, 0x00000190, 0x000001c8, 0x000001d8,
+    0x00000568, 0x00000570, 0x00000520, 0x00000508,
+    0x00000538, 0x00000500, 0x00000528, 0x00000550,
+    0x00000518, 0x00000560, 0x00000540, 0x00000578,
+    0x00000530, 0x00000510, 0x00000548, 0x00000558,
+    0x000004e8, 0x000004f0, 0x000004a0, 0x00000488,
+    0x000004b8, 0x00000480, 0x000004a8, 0x000004d0,
+    0x00000498, 0x000004e0, 0x000004c0, 0x000004f8,
+    0x000004b0, 0x00000490, 0x000004c8, 0x000004d8,
+    0x000002e8, 0x000002f0, 0x000002a0, 0x00000288,
+    0x000002b8, 0x00000280, 0x000002a8, 0x000002d0,
+    0x00000298, 0x000002e0, 0x000002c0, 0x000002f8,
+    0x000002b0, 0x00000290, 0x000002c8, 0x000002d8,
+    0x000005e8, 0x000005f0, 0x000005a0, 0x00000588,
+    0x000005b8, 0x00000580, 0x000005a8, 0x000005d0,
+    0x00000598, 0x000005e0, 0x000005c0, 0x000005f8,
+    0x000005b0, 0x00000590, 0x000005c8, 0x000005d8,
+    0x00000268, 0x00000270, 0x00000220, 0x00000208,
+    0x00000238, 0x00000200, 0x00000228, 0x00000250,
+    0x00000218, 0x00000260, 0x00000240, 0x00000278,
+    0x00000230, 0x00000210, 0x00000248, 0x00000258,
+    0x000007e8, 0x000007f0, 0x000007a0, 0x00000788,
+    0x000007b8, 0x00000780, 0x000007a8, 0x000007d0,
+    0x00000798, 0x000007e0, 0x000007c0, 0x000007f8,
+    0x000007b0, 0x00000790, 0x000007c8, 0x000007d8,
+    0x00000468, 0x00000470, 0x00000420, 0x00000408,
+    0x00000438, 0x00000400, 0x00000428, 0x00000450,
+    0x00000418, 0x00000460, 0x00000440, 0x00000478,
+    0x00000430, 0x00000410, 0x00000448, 0x00000458,
+    0x00000368, 0x00000370, 0x00000320, 0x00000308,
+    0x00000338, 0x00000300, 0x00000328, 0x00000350,
+    0x00000318, 0x00000360, 0x00000340, 0x00000378,
+    0x00000330, 0x00000310, 0x00000348, 0x00000358,
+    0x000003e8, 0x000003f0, 0x000003a0, 0x00000388,
+    0x000003b8, 0x00000380, 0x000003a8, 0x000003d0,
+    0x00000398, 0x000003e0, 0x000003c0, 0x000003f8,
+    0x000003b0, 0x00000390, 0x000003c8, 0x000003d8,
+    0x00000768, 0x00000770, 0x00000720, 0x00000708,
+    0x00000738, 0x00000700, 0x00000728, 0x00000750,
+    0x00000718, 0x00000760, 0x00000740, 0x00000778,
+    0x00000730, 0x00000710, 0x00000748, 0x00000758,
+    0x000006e8, 0x000006f0, 0x000006a0, 0x00000688,
+    0x000006b8, 0x00000680, 0x000006a8, 0x000006d0,
+    0x00000698, 0x000006e0, 0x000006c0, 0x000006f8,
+    0x000006b0, 0x00000690, 0x000006c8, 0x000006d8,
+    0x00000068, 0x00000070, 0x00000020, 0x00000008,
+    0x00000038, 0x00000000, 0x00000028, 0x00000050,
+    0x00000018, 0x00000060, 0x00000040, 0x00000078,
+    0x00000030, 0x00000010, 0x00000048, 0x00000058,
+    0x00000168, 0x00000170, 0x00000120, 0x00000108,
+    0x00000138, 0x00000100, 0x00000128, 0x00000150,
+    0x00000118, 0x00000160, 0x00000140, 0x00000178,
+    0x00000130, 0x00000110, 0x00000148, 0x00000158,
+    0x00000668, 0x00000670, 0x00000620, 0x00000608,
+    0x00000638, 0x00000600, 0x00000628, 0x00000650,
+    0x00000618, 0x00000660, 0x00000640, 0x00000678,
+    0x00000630, 0x00000610, 0x00000648, 0x00000658,
+  }
+};
+
 /*
  *  A macro that performs a full encryption round of GOST 28147-89.
  *  Temporary variables tmp assumed and variables r and l for left and right
diff --git a/gost28147.h b/gost28147.h
index 83d8915b9d38..8f6414ec8577 100644
--- a/gost28147.h
+++ b/gost28147.h
@@ -41,6 +41,7 @@ extern "C" {
 #endif
 
 #define gost28147_param_test_3411 nettle_gost28147_param_test_3411
+#define gost28147_param_CryptoPro_3411 nettle_gost28147_param_CryptoPro_3411
 
 /* Private */
 #define gost28147_encrypt_simple nettle_gost28147_encrypt_simple
@@ -51,6 +52,7 @@ struct gost28147_param
 };
 
 extern const struct gost28147_param gost28147_param_test_3411;
+extern const struct gost28147_param gost28147_param_CryptoPro_3411;
 
 /* Internal interface for use by GOST R 34.11-94 */
 void gost28147_encrypt_simple (const uint32_t *key, const uint32_t *sbox,
diff --git a/gosthash94-meta.c b/gosthash94-meta.c
index 42b05562b7f8..ad203bfd6c18 100644
--- a/gosthash94-meta.c
+++ b/gosthash94-meta.c
@@ -39,3 +39,6 @@
 
 const struct nettle_hash nettle_gosthash94
 = _NETTLE_HASH(gosthash94, GOSTHASH94);
+
+const struct nettle_hash nettle_gosthash94cp
+= _NETTLE_HASH(gosthash94cp, GOSTHASH94CP);
diff --git a/gosthash94.c b/gosthash94.c
index 870235eefa34..0e84553f9a03 100644
--- a/gosthash94.c
+++ b/gosthash94.c
@@ -5,6 +5,7 @@
  * See also RFC 4357.
  *
  * Copyright: 2009-2012 Aleksey Kravchenko &lt;rhash.admin@gmail.com&gt;
+ * Copyright: 2019 Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
@@ -61,7 +62,8 @@ gosthash94_init (struct gosthash94_ctx *ctx)
  * @param block the message block to process
  */
 static void
-gost_block_compress (struct gosthash94_ctx *ctx, const uint32_t *block)
+gost_block_compress (struct gosthash94_ctx *ctx, const uint32_t *block,
+		     const uint32_t *sbox)
 {
     unsigned i;
     uint32_t key[8], u[8], v[8], w[8], s[8];
@@ -106,7 +108,7 @@ gost_block_compress (struct gosthash94_ctx *ctx, const uint32_t \
*block)  ((w[5] &amp; 0xff000000) &gt;&gt; 8) | (w[7] &amp; 0xff000000);
 
           /* encryption: s_i := E_{key_i} (h_i) */
-          gost28147_encrypt_simple (key, gost28147_param_test_3411.sbox, \
&amp;ctx-&gt;hash[i], &amp;s[i]); +          gost28147_encrypt_simple (key, sbox, &amp;ctx-&gt;hash[i], \
&amp;s[i]);  
           if (i == 0)
             {
@@ -261,7 +263,8 @@ gost_block_compress (struct gosthash94_ctx *ctx, const uint32_t \
                *block)
  * @param block the 256-bit message block to process
  */
 static void
-gost_compute_sum_and_hash (struct gosthash94_ctx *ctx, const uint8_t *block)
+gost_compute_sum_and_hash (struct gosthash94_ctx *ctx, const uint8_t *block,
+			   const uint32_t *sbox)
 {
     uint32_t block_le[8];
     unsigned i, carry;
@@ -277,7 +280,7 @@ gost_compute_sum_and_hash (struct gosthash94_ctx *ctx, const \
uint8_t *block)  }
 
     /* update message hash */
-    gost_block_compress (ctx, block_le);
+    gost_block_compress (ctx, block_le, sbox);
 }
 
 /**
@@ -288,9 +291,10 @@ gost_compute_sum_and_hash (struct gosthash94_ctx *ctx, const \
                uint8_t *block)
  * @param msg message chunk
  * @param size length of the message chunk
  */
-void
-gosthash94_update (struct gosthash94_ctx *ctx,
-		   size_t length, const uint8_t *msg)
+static void
+gosthash94_update_int (struct gosthash94_ctx *ctx,
+		       size_t length, const uint8_t *msg,
+		       const uint32_t *sbox)
 {
     unsigned index = (unsigned) ctx-&gt;length &amp; 31;
     ctx-&gt;length += length;
@@ -304,13 +308,13 @@ gosthash94_update (struct gosthash94_ctx *ctx,
               return;
 
           /* process partial block */
-          gost_compute_sum_and_hash (ctx, ctx-&gt;message);
+          gost_compute_sum_and_hash (ctx, ctx-&gt;message, sbox);
           msg += left;
           length -= left;
       }
     while (length &gt;= GOSTHASH94_BLOCK_SIZE)
       {
-          gost_compute_sum_and_hash (ctx, msg);
+          gost_compute_sum_and_hash (ctx, msg, sbox);
           msg += GOSTHASH94_BLOCK_SIZE;
           length -= GOSTHASH94_BLOCK_SIZE;
       }
@@ -321,15 +325,48 @@ gosthash94_update (struct gosthash94_ctx *ctx,
       }
 }
 
+/**
+ * Calculate message hash.
+ * Can be called repeatedly with chunks of the message to be hashed.
+ *
+ * @param ctx the algorithm context containing current hashing state
+ * @param msg message chunk
+ * @param size length of the message chunk
+ */
+void
+gosthash94_update (struct gosthash94_ctx *ctx,
+		   size_t length, const uint8_t *msg)
+{
+  gosthash94_update_int (ctx, length, msg,
+			 gost28147_param_test_3411.sbox);
+}
+
+/**
+ * Calculate message hash.
+ * Can be called repeatedly with chunks of the message to be hashed.
+ *
+ * @param ctx the algorithm context containing current hashing state
+ * @param msg message chunk
+ * @param size length of the message chunk
+ */
+void
+gosthash94cp_update (struct gosthash94_ctx *ctx,
+		     size_t length, const uint8_t *msg)
+{
+  gosthash94_update_int (ctx, length, msg,
+			 gost28147_param_CryptoPro_3411.sbox);
+}
+
 /**
  * Finish hashing and store message digest into given array.
  *
  * @param ctx the algorithm context containing current hashing state
  * @param result calculated hash in binary form
  */
-void
-gosthash94_digest (struct gosthash94_ctx *ctx,
-		   size_t length, uint8_t *result)
+static void
+gosthash94_write_digest (struct gosthash94_ctx *ctx,
+			 size_t length, uint8_t *result,
+                         const uint32_t *sbox)
 {
     unsigned index = ctx-&gt;length &amp; 31;
     uint32_t msg32[8];
@@ -340,7 +377,7 @@ gosthash94_digest (struct gosthash94_ctx *ctx,
     if (index &gt; 0)
       {
           memset (ctx-&gt;message + index, 0, 32 - index);
-          gost_compute_sum_and_hash (ctx, ctx-&gt;message);
+          gost_compute_sum_and_hash (ctx, ctx-&gt;message, sbox);
       }
 
     /* hash the message length and the sum */
@@ -348,10 +385,26 @@ gosthash94_digest (struct gosthash94_ctx *ctx,
     msg32[1] = ctx-&gt;length &gt;&gt; 29;
     memset (msg32 + 2, 0, sizeof (uint32_t) * 6);
 
-    gost_block_compress (ctx, msg32);
-    gost_block_compress (ctx, ctx-&gt;sum);
+    gost_block_compress (ctx, msg32, sbox);
+    gost_block_compress (ctx, ctx-&gt;sum, sbox);
 
     /* convert hash state to result bytes */
     _nettle_write_le32(length, result, ctx-&gt;hash);
     gosthash94_init (ctx);
 }
+
+void
+gosthash94_digest (struct gosthash94_ctx *ctx,
+		   size_t length, uint8_t *result)
+{
+  gosthash94_write_digest (ctx, length, result,
+			   gost28147_param_test_3411.sbox);
+}
+
+void
+gosthash94cp_digest (struct gosthash94_ctx *ctx,
+		     size_t length, uint8_t *result)
+{
+  gosthash94_write_digest (ctx, length, result,
+			   gost28147_param_CryptoPro_3411.sbox);
+}
diff --git a/gosthash94.h b/gosthash94.h
index 60b2bef2837f..dfa97f61de6e 100644
--- a/gosthash94.h
+++ b/gosthash94.h
@@ -72,11 +72,17 @@ extern "C" {
 #define gosthash94_update nettle_gosthash94_update
 #define gosthash94_digest nettle_gosthash94_digest
 
+#define gosthash94cp_update nettle_gosthash94cp_update
+#define gosthash94cp_digest nettle_gosthash94cp_digest
+
 #define GOSTHASH94_BLOCK_SIZE 32
 #define GOSTHASH94_DIGEST_SIZE 32
 /* For backwards compatibility */
 #define GOSTHASH94_DATA_SIZE GOSTHASH94_BLOCK_SIZE
 
+#define GOSTHASH94CP_BLOCK_SIZE GOSTHASH94_BLOCK_SIZE
+#define GOSTHASH94CP_DIGEST_SIZE GOSTHASH94_DIGEST_SIZE
+
 struct gosthash94_ctx
 {
   uint32_t hash[8]; /* algorithm 256-bit state */
@@ -84,6 +90,7 @@ struct gosthash94_ctx
   uint64_t length;  /* number of processed bytes */
   uint8_t message[GOSTHASH94_BLOCK_SIZE]; /* 256-bit buffer for leftovers */
 };
+#define gosthash94cp_ctx gosthash94_ctx
 
 void gosthash94_init(struct gosthash94_ctx *ctx);
 void gosthash94_update(struct gosthash94_ctx *ctx,
@@ -91,6 +98,12 @@ void gosthash94_update(struct gosthash94_ctx *ctx,
 void gosthash94_digest(struct gosthash94_ctx *ctx,
 		       size_t length, uint8_t *result);
 
+#define gosthash94cp_init gosthash94_init
+void gosthash94cp_update(struct gosthash94_ctx *ctx,
+			 size_t length, const uint8_t *msg);
+void gosthash94cp_digest(struct gosthash94_ctx *ctx,
+			 size_t length, uint8_t *result);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/nettle-meta-hashes.c b/nettle-meta-hashes.c
index f0ef026d359f..0ea892c14714 100644
--- a/nettle-meta-hashes.c
+++ b/nettle-meta-hashes.c
@@ -42,6 +42,7 @@ const struct nettle_hash * const _nettle_hashes[] = {
   &amp;nettle_md4,
   &amp;nettle_md5,
   &amp;nettle_gosthash94,
+  &amp;nettle_gosthash94cp,
   &amp;nettle_ripemd160,
   &amp;nettle_sha1,
   &amp;nettle_sha224,
diff --git a/nettle-meta.h b/nettle-meta.h
index 74e50e59cd2e..b4cdb8f3e378 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -130,6 +130,7 @@ extern const struct nettle_hash nettle_md2;
 extern const struct nettle_hash nettle_md4;
 extern const struct nettle_hash nettle_md5;
 extern const struct nettle_hash nettle_gosthash94;
+extern const struct nettle_hash nettle_gosthash94cp;
 extern const struct nettle_hash nettle_ripemd160;
 extern const struct nettle_hash nettle_sha1;
 extern const struct nettle_hash nettle_sha224;
diff --git a/nettle.texinfo b/nettle.texinfo
index b8579a6ed59b..fbba7d81d6ec 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -1038,12 +1038,17 @@ This function also resets the context in the same way as
 @end deftypefun
 
 
-@subsubsection @acronym{GOSTHASH94}
+@subsubsection @acronym{GOSTHASH94 and GOSTHASH94CP}
 
 The GOST94 or GOST R 34.11-94 hash algorithm is a Soviet-era algorithm 
 used in Russian government standards (see @cite{RFC 4357}).
-It outputs message digests of 256 bits, or 32 octets.
-Nettle defines GOSTHASH94 in @file{&lt;nettle/gosthash94.h&gt;}.
+It outputs message digests of 256 bits, or 32 octets. The standard itself
+does not fix the S-box used by the hash algorith, so there are two popular
+variants (the testing S-box from the standard itself and the S-box defined
+by CryptoPro company, see RFC 4357). Nettle provides support for the former
+S-box in the form of GOSTHASH94 hash algorithm and for the latter in the
+form of GOSTHASH94CP hash algorithm.
+Nettle defines GOSTHASH94 and GOSTHASH94CP in @file{&lt;nettle/gosthash94.h&gt;}.
 
 @deftp {Context struct} {struct gosthash94_ctx}
 @end deftp
@@ -1074,6 +1079,35 @@ This function also resets the context in the same way as
 @code{gosthash94_init}.
 @end deftypefun
 
+@deftp {Context struct} {struct gosthash94cp_ctx}
+@end deftp
+
+@defvr Constant GOSTHASH94CP_DIGEST_SIZE
+The size of a GOSTHASH94CP digest, i.e. 32.
+@end defvr
+
+@defvr Constant GOSTHASH94CP_BLOCK_SIZE
+The internal block size of GOSTHASH94CP, i.e., 32.
+@end defvr
+
+@deftypefun void gosthash94cp_init (struct gosthash94cp_ctx *@var{ctx})
+Initialize the GOSTHASH94CP state.
+@end deftypefun
+
+@deftypefun void gosthash94cp_update (struct gosthash94cp_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +Hash some more data.
+@end deftypefun
+
+@deftypefun void gosthash94cp_digest (struct gosthash94cp_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Performs final processing and extracts the \
message digest, writing it +to @var{digest}. @var{length} may be smaller than
+@code{GOSTHASH94CP_DIGEST_SIZE}, in which case only the first @var{length}
+octets of the digest are written.
+
+This function also resets the context in the same way as
+@code{gosthash94cp_init}.
+@end deftypefun
+
 @node nettle_hash abstraction,, Legacy hash functions, Hash functions
 @comment  node-name,  next,  previous,  up
 @subsection The @code{struct nettle_hash} abstraction
@@ -1103,6 +1137,7 @@ The last three attributes are function pointers, of types
 @deftypevrx {Constant Struct} {struct nettle_hash} nettle_sha512
 @deftypevrx {Constant Struct} {struct nettle_hash} nettle_sha3_256
 @deftypevrx {Constant Struct} {struct nettle_hash} nettle_gosthash94
+@deftypevrx {Constant Struct} {struct nettle_hash} nettle_gosthash94cp
 These are all the hash functions that Nettle implements.
 @end deftypevr
 
diff --git a/testsuite/gosthash94-test.c b/testsuite/gosthash94-test.c
index 77fb8befa9d8..d4e5015843d9 100644
--- a/testsuite/gosthash94-test.c
+++ b/testsuite/gosthash94-test.c
@@ -17,4 +17,16 @@ test_main(void)
 
   test_hash(&amp;nettle_gosthash94, SDATA(""),
 	    SHEX("ce85b99cc46752fffee35cab9a7b0278abb4c2d2055cff685af4912c49490f8d"));
+
+  test_hash(&amp;nettle_gosthash94cp, SDATA("The quick brown fox jumps over the lazy \
dog"), +	    SHEX("9004294a361a508c586fe53d1f1b02746765e71b765472786e4770d565830a76"));
 +
+  test_hash(&amp;nettle_gosthash94cp, SDATA("message digest"),
+	    SHEX("bc6041dd2aa401ebfa6e9886734174febdb4729aa972d60f549ac39b29721ba0"));
+
+  test_hash(&amp;nettle_gosthash94cp, SDATA("a"),
+	    SHEX("e74c52dd282183bf37af0079c9f78055715a103f17e3133ceff1aacf2f403011"));
+
+  test_hash(&amp;nettle_gosthash94cp, SDATA(""),
+	    SHEX("981e5f3ca30c841487830f84fb433e13ac1101569b9c13584ac483234cd656c0"));
 }
diff --git a/testsuite/meta-hash-test.c b/testsuite/meta-hash-test.c
index 5b6258889e5d..42debe994c0a 100644
--- a/testsuite/meta-hash-test.c
+++ b/testsuite/meta-hash-test.c
@@ -9,6 +9,7 @@ const char* hashes[] = {
   "md4",
   "md5",
   "gosthash94",
+  "gosthash94cp",
   "ripemd160",
   "sha1",
   "sha224",
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190702131856</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:18:56-0400</timestampReceived><subject>[PATCH 4/6] Add HMAC functions for GOSTHASH94 and GOSTHASH94CP</subject><body>

GOST hash functions can be used to generate MAC using HMAC algorithm.
Add functions implementing HMAC with GOSTHASH94/GOSTHASH94CP.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in           |  6 ++--
 hmac-gosthash94.c     | 79 +++++++++++++++++++++++++++++++++++++++++++
 hmac.h                | 37 ++++++++++++++++++++
 testsuite/hmac-test.c | 14 ++++++++
 4 files changed, 133 insertions(+), 3 deletions(-)
 create mode 100644 hmac-gosthash94.c

diff --git a/Makefile.in b/Makefile.in
index 795d66edb2c8..7d82d0d2c1aa 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -103,9 +103,9 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
 		 cmac.c cmac-aes128.c cmac-aes256.c \
 		 gost28147.c gosthash94.c gosthash94-meta.c \
-		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
-		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
-		 knuth-lfib.c hkdf.c \
+		 hmac.c hmac-gosthash94.c hmac-md5.c hmac-ripemd160.c \
+		 hmac-sha1.c hmac-sha224.c hmac-sha256.c hmac-sha384.c \
+		 hmac-sha512.c knuth-lfib.c hkdf.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
 		 memeql-sec.c memxor.c memxor3.c \
diff --git a/hmac-gosthash94.c b/hmac-gosthash94.c
new file mode 100644
index 000000000000..66b62854d25e
--- /dev/null
+++ b/hmac-gosthash94.c
@@ -0,0 +1,79 @@
+/* hmac-gosthash94.c
+
+   HMAC-GOSTHASH94 message authentication code.
+
+   Copyright (C) 2016 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "hmac.h"
+
+void
+hmac_gosthash94_set_key(struct hmac_gosthash94_ctx *ctx,
+		    size_t key_length, const uint8_t *key)
+{
+  HMAC_SET_KEY(ctx, &amp;nettle_gosthash94, key_length, key);
+}
+
+void
+hmac_gosthash94_update(struct hmac_gosthash94_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  gosthash94_update(&amp;ctx-&gt;state, length, data);
+}
+
+void
+hmac_gosthash94_digest(struct hmac_gosthash94_ctx *ctx,
+		   size_t length, uint8_t *digest)
+{
+  HMAC_DIGEST(ctx, &amp;nettle_gosthash94, length, digest);
+}
+
+void
+hmac_gosthash94cp_set_key(struct hmac_gosthash94cp_ctx *ctx,
+		    size_t key_length, const uint8_t *key)
+{
+  HMAC_SET_KEY(ctx, &amp;nettle_gosthash94cp, key_length, key);
+}
+
+void
+hmac_gosthash94cp_update(struct hmac_gosthash94cp_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  gosthash94cp_update(&amp;ctx-&gt;state, length, data);
+}
+void
+hmac_gosthash94cp_digest(struct hmac_gosthash94cp_ctx *ctx,
+		   size_t length, uint8_t *digest)
+{
+  HMAC_DIGEST(ctx, &amp;nettle_gosthash94cp, length, digest);
+}
diff --git a/hmac.h b/hmac.h
index 40a8e77aab6d..d9ee3400108d 100644
--- a/hmac.h
+++ b/hmac.h
@@ -36,6 +36,7 @@
 
 #include "nettle-meta.h"
 
+#include "gosthash94.h"
 #include "md5.h"
 #include "ripemd160.h"
 #include "sha1.h"
@@ -68,6 +69,12 @@ extern "C" {
 #define hmac_sha512_set_key nettle_hmac_sha512_set_key
 #define hmac_sha512_update nettle_hmac_sha512_update
 #define hmac_sha512_digest nettle_hmac_sha512_digest
+#define hmac_gosthash94_set_key nettle_hmac_gosthash94_set_key
+#define hmac_gosthash94_update nettle_hmac_gosthash94_update
+#define hmac_gosthash94_digest nettle_hmac_gosthash94_digest
+#define hmac_gosthash94cp_set_key nettle_hmac_gosthash94cp_set_key
+#define hmac_gosthash94cp_update nettle_hmac_gosthash94cp_update
+#define hmac_gosthash94cp_digest nettle_hmac_gosthash94cp_digest
 
 void
 hmac_set_key(void *outer, void *inner, void *state,
@@ -203,6 +210,36 @@ void
 hmac_sha384_digest(struct hmac_sha512_ctx *ctx,
 		   size_t length, uint8_t *digest);
 
+/* hmac-gosthash94 */
+struct hmac_gosthash94_ctx HMAC_CTX(struct gosthash94_ctx);
+
+void
+hmac_gosthash94_set_key(struct hmac_gosthash94_ctx *ctx,
+			size_t key_length, const uint8_t *key);
+
+void
+hmac_gosthash94_update(struct hmac_gosthash94_ctx *ctx,
+		       size_t length, const uint8_t *data);
+
+  void
+hmac_gosthash94_digest(struct hmac_gosthash94_ctx *ctx,
+		       size_t length, uint8_t *digest);
+
+struct hmac_gosthash94cp_ctx HMAC_CTX(struct gosthash94cp_ctx);
+
+void
+hmac_gosthash94cp_set_key(struct hmac_gosthash94cp_ctx *ctx,
+			  size_t key_length, const uint8_t *key);
+
+void
+hmac_gosthash94cp_update(struct hmac_gosthash94cp_ctx *ctx,
+			 size_t length, const uint8_t *data);
+
+void
+hmac_gosthash94cp_digest(struct hmac_gosthash94cp_ctx *ctx,
+			 size_t length, uint8_t *digest);
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/hmac-test.c b/testsuite/hmac-test.c
index 9156cc406d2c..f009c8003d34 100644
--- a/testsuite/hmac-test.c
+++ b/testsuite/hmac-test.c
@@ -894,4 +894,18 @@ test_main(void)
 		 "b1ff68a1de45509fbe4da9a433922655"));
 
   /* Test case AUTH512-3 from same document seems broken. */
+
+  HMAC_TEST(gosthash94,
+	    SHEX("000102030405060708090a0b0c0d0e0f"
+		 "101112131415161718191a1b1c1d1e1f"),
+	    SHEX("0126bdb87800af214341456563780100"),
+	    SHEX("bfebe25f051bfef6ac858babb0abc409"
+		 "bfd2e334ab847bc0b0d056517c7d94c5"));
+
+  HMAC_TEST(gosthash94cp,
+	    SHEX("000102030405060708090a0b0c0d0e0f"
+		 "101112131415161718191a1b1c1d1e1f"),
+	    SHEX("0126bdb87800af214341456563780100"),
+	    SHEX("bad70b61c41095bc47e1141cfaed4272"
+		 "6a5ceebd62ce75dbbb9ad76cda9f72f7"));
 }
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702131857</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:18:57-0400</timestampReceived><subject>[PATCH 5/6] Add PBKDF2 support for gosthash94cp</subject><body>

Russian technical comitee working on standartization of cryptography
algorithms has published the document describing usage of GOST R
34.11-94 hash function with PBKDF2 algorithm
(http://tc26.ru/methods/containers_v1/Addition_to_PKCS5_v1_0.pdf).
Add test vectors from that document and a special function implementing
Nettle interface for PBKDF2 using gosthash94cp.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in              |  3 ++-
 pbkdf2-hmac-gosthash94.c | 53 ++++++++++++++++++++++++++++++++++++++++
 pbkdf2.h                 |  7 ++++++
 testsuite/pbkdf2-test.c  | 24 ++++++++++++++++++
 4 files changed, 86 insertions(+), 1 deletion(-)
 create mode 100644 pbkdf2-hmac-gosthash94.c

diff --git a/Makefile.in b/Makefile.in
index 7d82d0d2c1aa..0674b96907b2 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -112,7 +112,8 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 nettle-lookup-hash.c \
 		 nettle-meta-aeads.c nettle-meta-armors.c \
 		 nettle-meta-ciphers.c nettle-meta-hashes.c \
-		 pbkdf2.c pbkdf2-hmac-sha1.c pbkdf2-hmac-sha256.c \
+		 pbkdf2.c pbkdf2-hmac-gosthash94.c pbkdf2-hmac-sha1.c \
+		 pbkdf2-hmac-sha256.c \
 		 poly1305-aes.c poly1305-internal.c \
 		 realloc.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
diff --git a/pbkdf2-hmac-gosthash94.c b/pbkdf2-hmac-gosthash94.c
new file mode 100644
index 000000000000..bf61659433c3
--- /dev/null
+++ b/pbkdf2-hmac-gosthash94.c
@@ -0,0 +1,53 @@
+/* pbkdf2-hmac-gosthash94.c
+
+   PKCS #5 PBKDF2 used with HMAC-GOSTHASH94CP.
+
+   Copyright (C) 2016 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "pbkdf2.h"
+
+#include "hmac.h"
+
+void
+pbkdf2_hmac_gosthash94cp (size_t key_length, const uint8_t *key,
+		  unsigned iterations,
+		  size_t salt_length, const uint8_t *salt,
+		  size_t length, uint8_t *dst)
+{
+  struct hmac_gosthash94cp_ctx gosthash94cpctx;
+
+  hmac_gosthash94cp_set_key (&amp;gosthash94cpctx, key_length, key);
+  PBKDF2 (&amp;gosthash94cpctx, hmac_gosthash94cp_update, hmac_gosthash94cp_digest,
+	  GOSTHASH94CP_DIGEST_SIZE, iterations, salt_length, salt, length, dst);
+}
diff --git a/pbkdf2.h b/pbkdf2.h
index 7b1c4c9c1881..a36dfdbaa437 100644
--- a/pbkdf2.h
+++ b/pbkdf2.h
@@ -45,6 +45,7 @@ extern "C"
 #define pbkdf2 nettle_pbkdf2
 #define pbkdf2_hmac_sha1 nettle_pbkdf2_hmac_sha1
 #define pbkdf2_hmac_sha256 nettle_pbkdf2_hmac_sha256
+#define pbkdf2_hmac_gosthash94cp nettle_pbkdf2_hmac_gosthash94cp
 
 void
 pbkdf2 (void *mac_ctx,
@@ -78,6 +79,12 @@ pbkdf2_hmac_sha256 (size_t key_length, const uint8_t *key,
 		    size_t salt_length, const uint8_t *salt,
 		    size_t length, uint8_t *dst);
 
+void
+pbkdf2_hmac_gosthash94cp (size_t key_length, const uint8_t *key,
+			  unsigned iterations,
+			  size_t salt_length, const uint8_t *salt,
+			  size_t length, uint8_t *dst);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/pbkdf2-test.c b/testsuite/pbkdf2-test.c
index bb8da57fbb73..fe68ca6527c8 100644
--- a/testsuite/pbkdf2-test.c
+++ b/testsuite/pbkdf2-test.c
@@ -28,6 +28,7 @@ test_main (void)
   struct hmac_sha1_ctx sha1ctx;
   struct hmac_sha256_ctx sha256ctx;
   struct hmac_sha512_ctx sha512ctx;
+  struct hmac_gosthash94cp_ctx gosthash94cpctx;
 
   /* Test vectors for PBKDF2 from RFC 6070. */
 
@@ -110,4 +111,27 @@ test_main (void)
   PBKDF2_HMAC_TEST(pbkdf2_hmac_sha256, LDATA("passwd"), 1, LDATA("salt"),
 		   SHEX("55ac046e56e3089fec1691c22544b605"));
 
+  /* From TC26 document, http://tc26.ru/methods/containers_v1/Addition_to_PKCS5_v1_0.pdf */
+
+  hmac_gosthash94cp_set_key (&amp;gosthash94cpctx, LDATA("password"));
+  PBKDF2_TEST (&amp;gosthash94cpctx, hmac_gosthash94cp_update, hmac_gosthash94cp_digest,
+	       GOSTHASH94CP_DIGEST_SIZE, 1, LDATA("salt"),
+	       SHEX("7314e7c04fb2e662c543674253f68bd0b73445d07f241bed872882da21662d58"));
+
+  PBKDF2_TEST (&amp;gosthash94cpctx, hmac_gosthash94cp_update, hmac_gosthash94cp_digest,
+	       GOSTHASH94CP_DIGEST_SIZE, 4096, LDATA("salt"),
+	       SHEX("1f1829a94bdff5be10d0aeb36af498e7a97467f3b31116a5a7c1afff9deadafe"));
+
+  hmac_gosthash94cp_set_key (&amp;gosthash94cpctx, LDATA("passwordPASSWORDpassword"));
+  PBKDF2_TEST (&amp;gosthash94cpctx, hmac_gosthash94cp_update, hmac_gosthash94cp_digest,
+	       GOSTHASH94CP_DIGEST_SIZE, 4096, LDATA("saltSALTsaltSALTsaltSALTsaltSALTsalt"),
+	       SHEX("788358c69cb2dbe251a7bb17d5f4241f265a792a35becde8d56f326b49c85047b7638acb4764b1fd"));
+
+  hmac_gosthash94cp_set_key (&amp;gosthash94cpctx, LDATA("pass\0word"));
+  PBKDF2_TEST (&amp;gosthash94cpctx, hmac_gosthash94cp_update, hmac_gosthash94cp_digest,
+	       GOSTHASH94CP_DIGEST_SIZE, 4096, LDATA("sa\0lt"),
+	       SHEX("43e06c5590b08c0225242373127edf9c8e9c3291"));
+
+  PBKDF2_HMAC_TEST (pbkdf2_hmac_gosthash94cp, LDATA("password"), 1, LDATA("salt"),
+	       SHEX("7314e7c04fb2e662c543674253f68bd0b73445d07f241bed872882da21662d58"));
 }
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702131858</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:18:58-0400</timestampReceived><subject>[PATCH 6/6] gosthash94: switch to using MD_UPDATE() macro</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 gosthash94.c | 43 +++++++++----------------------------------
 gosthash94.h |  5 +++--
 2 files changed, 12 insertions(+), 36 deletions(-)

diff --git a/gosthash94.c b/gosthash94.c
index 0e84553f9a03..8105530516ee 100644
--- a/gosthash94.c
+++ b/gosthash94.c
@@ -283,6 +283,8 @@ gost_compute_sum_and_hash (struct gosthash94_ctx *ctx, const uint8_t *block,
     gost_block_compress (ctx, block_le, sbox);
 }
 
+#define COMPRESS(ctx, block) gost_compute_sum_and_hash((ctx), (block), sbox);
+
 /**
  * Calculate message hash.
  * Can be called repeatedly with chunks of the message to be hashed.
@@ -296,33 +298,7 @@ gosthash94_update_int (struct gosthash94_ctx *ctx,
 		       size_t length, const uint8_t *msg,
 		       const uint32_t *sbox)
 {
-    unsigned index = (unsigned) ctx-&gt;length &amp; 31;
-    ctx-&gt;length += length;
-
-    /* fill partial block */
-    if (index)
-      {
-          unsigned left = GOSTHASH94_BLOCK_SIZE - index;
-          memcpy (ctx-&gt;message + index, msg, (length &lt; left ? length : left));
-          if (length &lt; left)
-              return;
-
-          /* process partial block */
-          gost_compute_sum_and_hash (ctx, ctx-&gt;message, sbox);
-          msg += left;
-          length -= left;
-      }
-    while (length &gt;= GOSTHASH94_BLOCK_SIZE)
-      {
-          gost_compute_sum_and_hash (ctx, msg, sbox);
-          msg += GOSTHASH94_BLOCK_SIZE;
-          length -= GOSTHASH94_BLOCK_SIZE;
-      }
-    if (length)
-      {
-          /* save leftovers */
-          memcpy (ctx-&gt;message, msg, length);
-      }
+    MD_UPDATE(ctx, length, msg, COMPRESS, ctx-&gt;count++);
 }
 
 /**
@@ -368,21 +344,20 @@ gosthash94_write_digest (struct gosthash94_ctx *ctx,
 			 size_t length, uint8_t *result,
                          const uint32_t *sbox)
 {
-    unsigned index = ctx-&gt;length &amp; 31;
-    uint32_t msg32[8];
+    uint32_t msg32[GOSTHASH94_BLOCK_SIZE / 4];
 
     assert(length &lt;= GOSTHASH94_DIGEST_SIZE);
 
     /* pad the last block with zeroes and hash it */
-    if (index &gt; 0)
+    if (ctx-&gt;index &gt; 0)
       {
-          memset (ctx-&gt;message + index, 0, 32 - index);
-          gost_compute_sum_and_hash (ctx, ctx-&gt;message, sbox);
+          memset (ctx-&gt;block + ctx-&gt;index, 0, GOSTHASH94_BLOCK_SIZE - ctx-&gt;index);
+          gost_compute_sum_and_hash (ctx, ctx-&gt;block, sbox);
       }
 
     /* hash the message length and the sum */
-    msg32[0] = ctx-&gt;length &lt;&lt; 3;
-    msg32[1] = ctx-&gt;length &gt;&gt; 29;
+    msg32[0] = (ctx-&gt;count &lt;&lt; 8) | (ctx-&gt;index &lt;&lt; 3);
+    msg32[1] = ctx-&gt;count &gt;&gt; 24;
     memset (msg32 + 2, 0, sizeof (uint32_t) * 6);
 
     gost_block_compress (ctx, msg32, sbox);
diff --git a/gosthash94.h b/gosthash94.h
index dfa97f61de6e..0efd6412e6a9 100644
--- a/gosthash94.h
+++ b/gosthash94.h
@@ -87,8 +87,9 @@ struct gosthash94_ctx
 {
   uint32_t hash[8]; /* algorithm 256-bit state */
   uint32_t sum[8];  /* sum of processed message blocks */
-  uint64_t length;  /* number of processed bytes */
-  uint8_t message[GOSTHASH94_BLOCK_SIZE]; /* 256-bit buffer for leftovers */
+  uint64_t count;               /* Block count */
+  unsigned index;               /* Into buffer */
+  uint8_t block[GOSTHASH94_BLOCK_SIZE]; /* 256-bit buffer for leftovers */
 };
 #define gosthash94cp_ctx gosthash94_ctx
 
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190410050242</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-04-10 05:02:42-0400</timestampReceived><subject>Re: nettle-pbkdf2 Segmentation fault</subject><body>

"Yu, Mingli" &lt;mingli.yu@windriver.com&gt; writes:

&gt; # echo -n passwd| nettle-pbkdf2 -i 1 -l 16
&gt; [65534.886509] nettle-pbkdf2[708]: segfault at 1f594260 ip
&gt; 00007f3332256998 sp 00007fff60d44410 error 4 in
&gt; libnettle.so.6.5[7f3332244000+1d00]
&gt; [65534.887525] Code: e8 6d db fe ff 44 01 6d 68 48 83 c4 08 5b 5d 41
&gt; 5c 41 5d 41 5e 41 5f c3 66 2e 0f 1f 84 00 00 00 00 00 49 89 dc e9 68
&gt; ff f
&gt; Segmentation fault

I can't reproduce this crash. Gives me a usage message, and if I add a
salt argument, I get a hex digest out, as expected. Which version and
platform are you using?

Can you get a backtrace? (start "gdb nettle-pbkdf2", at the gdb prompt
type "run -i 1 -l 16", if it crashes, type "bt" for backtrace).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190410053037</emailId><senderName>"Yu, Mingli"</senderName><senderEmail>mingli.yu@windriver.com</senderEmail><timestampReceived>2019-04-10 05:30:37-0400</timestampReceived><subject>Re: nettle-pbkdf2 Segmentation fault</subject><body>



On 2019年04月10日 12:31, Alon Bar-Lev wrote:
&gt; Which version do you use?

The version is 3.4.1.

&gt; I am getting usage in 3.6.1 as SALT parameter is missing.
&gt;
&gt; On Wed, Apr 10, 2019 at 6:19 AM Yu, Mingli &lt;mingli.yu@windriver.com
&gt; &lt;mailto:mingli.yu@windriver.com&gt;&gt; wrote:
&gt;
&gt;
&gt;
&gt;     # echo -n passwd| nettle-pbkdf2 -i 1 -l 16
&gt;     [65534.886509] nettle-pbkdf2[708]: segfault at 1f594260 ip
&gt;     00007f3332256998 sp 00007fff60d44410 error 4 in
&gt;     libnettle.so.6.5[7f3332244000+1d00]
&gt;     [65534.887525] Code: e8 6d db fe ff 44 01 6d 68 48 83 c4 08 5b 5d 41 5c
&gt;     41 5d 41 5e 41 5f c3 66 2e 0f 1f 84 00 00 00 00 00 49 89 dc e9 68 ff f
&gt;     Segmentation fault
&gt;     _______________________________________________
&gt;     nettle-bugs mailing list
&gt;     nettle-bugs@lists.lysator.liu.se
&gt;     &lt;mailto:nettle-bugs@lists.lysator.liu.se&gt;
&gt;     http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs
&gt;
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190410053524</emailId><senderName>"Yu, Mingli"</senderName><senderEmail>mingli.yu@windriver.com</senderEmail><timestampReceived>2019-04-10 05:35:24-0400</timestampReceived><subject>Re: nettle-pbkdf2 Segmentation fault</subject><body>



On 2019年04月10日 13:02, Niels Möller wrote:
&gt; "Yu, Mingli" &lt;mingli.yu@windriver.com&gt; writes:
&gt;
&gt;&gt; # echo -n passwd| nettle-pbkdf2 -i 1 -l 16
&gt;&gt; [65534.886509] nettle-pbkdf2[708]: segfault at 1f594260 ip
&gt;&gt; 00007f3332256998 sp 00007fff60d44410 error 4 in
&gt;&gt; libnettle.so.6.5[7f3332244000+1d00]
&gt;&gt; [65534.887525] Code: e8 6d db fe ff 44 01 6d 68 48 83 c4 08 5b 5d 41
&gt;&gt; 5c 41 5d 41 5e 41 5f c3 66 2e 0f 1f 84 00 00 00 00 00 49 89 dc e9 68
&gt;&gt; ff f
&gt;&gt; Segmentation fault
&gt;
&gt; I can't reproduce this crash. Gives me a usage message, and if I add a
&gt; salt argument, I get a hex digest out, as expected. Which version and
&gt; platform are you using?

It's 3.4.1 and I did use it as below:
# echo -n passwd| nettle-pbkdf2 -i 1 -l 16 salt

&gt;
&gt; Can you get a backtrace? (start "gdb nettle-pbkdf2", at the gdb prompt

I don't know how to use nettle-pbkdf2 actually and it didn't return when 
I run as below:
# nettle-pbkdf2 -i 1 -l 16 salt

But instead, it can return at once as below with Segmentation fault, but 
not succeeded to use gdb to run with below command:
# echo -n passwd| nettle-pbkdf2 -i 1 -l 16 salt

&gt; type "run -i 1 -l 16", if it crashes, type "bt" for backtrace).
&gt;
&gt; Regards,
&gt; /Niels
&gt;
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190410055048</emailId><senderName>"Yu, Mingli"</senderName><senderEmail>mingli.yu@windriver.com</senderEmail><timestampReceived>2019-04-10 05:50:48-0400</timestampReceived><subject>Re: nettle-pbkdf2 Segmentation fault</subject><body>



On 2019年04月10日 12:31, Alon Bar-Lev wrote:
&gt; Which version do you use?
&gt; I am getting usage in 3.6.1 as SALT parameter is missing.

BTW, I noticed the latest nettle is 3.4.1 at 
http://ftp.gnu.org/gnu/nettle/, where do you get the version 3.6.1?

Thanks,

&gt;
&gt; On Wed, Apr 10, 2019 at 6:19 AM Yu, Mingli &lt;mingli.yu@windriver.com
&gt; &lt;mailto:mingli.yu@windriver.com&gt;&gt; wrote:
&gt;
&gt;
&gt;
&gt;     # echo -n passwd| nettle-pbkdf2 -i 1 -l 16
&gt;     [65534.886509] nettle-pbkdf2[708]: segfault at 1f594260 ip
&gt;     00007f3332256998 sp 00007fff60d44410 error 4 in
&gt;     libnettle.so.6.5[7f3332244000+1d00]
&gt;     [65534.887525] Code: e8 6d db fe ff 44 01 6d 68 48 83 c4 08 5b 5d 41 5c
&gt;     41 5d 41 5e 41 5f c3 66 2e 0f 1f 84 00 00 00 00 00 49 89 dc e9 68 ff f
&gt;     Segmentation fault
&gt;     _______________________________________________
&gt;     nettle-bugs mailing list
&gt;     nettle-bugs@lists.lysator.liu.se
&gt;     &lt;mailto:nettle-bugs@lists.lysator.liu.se&gt;
&gt;     http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs
&gt;
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190410060453</emailId><senderName>"Yu, Mingli"</senderName><senderEmail>mingli.yu@windriver.com</senderEmail><timestampReceived>2019-04-10 06:04:53-0400</timestampReceived><subject>Re: nettle-pbkdf2 Segmentation fault</subject><body>



On 2019年04月10日 13:02, Niels Möller wrote:
&gt; "Yu, Mingli" &lt;mingli.yu@windriver.com&gt; writes:
&gt;
&gt;&gt; # echo -n passwd| nettle-pbkdf2 -i 1 -l 16
&gt;&gt; [65534.886509] nettle-pbkdf2[708]: segfault at 1f594260 ip
&gt;&gt; 00007f3332256998 sp 00007fff60d44410 error 4 in
&gt;&gt; libnettle.so.6.5[7f3332244000+1d00]
&gt;&gt; [65534.887525] Code: e8 6d db fe ff 44 01 6d 68 48 83 c4 08 5b 5d 41
&gt;&gt; 5c 41 5d 41 5e 41 5f c3 66 2e 0f 1f 84 00 00 00 00 00 49 89 dc e9 68
&gt;&gt; ff f
&gt;&gt; Segmentation fault
&gt;
&gt; I can't reproduce this crash. Gives me a usage message, and if I add a

Or you can run below directly:
# testsuite/nettle-pbkdf2-test

&gt; salt argument, I get a hex digest out, as expected. Which version and
&gt; platform are you using?
&gt;
&gt; Can you get a backtrace? (start "gdb nettle-pbkdf2", at the gdb prompt
&gt; type "run -i 1 -l 16", if it crashes, type "bt" for backtrace).
&gt;
&gt; Regards,
&gt; /Niels
&gt;
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190410062513</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-04-10 06:25:13-0400</timestampReceived><subject>Re: nettle-pbkdf2 Segmentation fault</subject><body>

"Yu, Mingli" &lt;mingli.yu@windriver.com&gt; writes:

&gt; It's 3.4.1 and I did use it as below:
&gt; # echo -n passwd| nettle-pbkdf2 -i 1 -l 16 salt

That's the latest version.

&gt;&gt; Can you get a backtrace? (start "gdb nettle-pbkdf2", at the gdb prompt
&gt;
&gt; I don't know how to use nettle-pbkdf2 actually and it didn't return
&gt; when I run as below:
&gt; # nettle-pbkdf2 -i 1 -l 16 salt

Sorry, it wants to read the input password on stdin. Try echo foo &gt;
/tmp/foo, and then start it in gdb as

  run nettle-pbkdf2 -i 1 -l 16 salt &lt; /tmp/foo

What kind of machine, operating system, and compiler are you using?
Since the testsuite passes on the test systems (including x86_64 and
cross-compile setup for arm and mips), I imagine it's something somewhat
unusual.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190410063735</emailId><senderName>"Yu, Mingli"</senderName><senderEmail>mingli.yu@windriver.com</senderEmail><timestampReceived>2019-04-10 06:37:35-0400</timestampReceived><subject>Re: nettle-pbkdf2 Segmentation fault</subject><body>



On 2019年04月10日 14:25, Niels Möller wrote:
&gt; "Yu, Mingli" &lt;mingli.yu@windriver.com&gt; writes:
&gt;
&gt;&gt; It's 3.4.1 and I did use it as below:
&gt;&gt; # echo -n passwd| nettle-pbkdf2 -i 1 -l 16 salt
&gt;
&gt; That's the latest version.
&gt;
&gt;&gt;&gt; Can you get a backtrace? (start "gdb nettle-pbkdf2", at the gdb prompt
&gt;&gt;
&gt;&gt; I don't know how to use nettle-pbkdf2 actually and it didn't return
&gt;&gt; when I run as below:
&gt;&gt; # nettle-pbkdf2 -i 1 -l 16 salt
&gt;
&gt; Sorry, it wants to read the input password on stdin. Try echo foo &gt;
&gt; /tmp/foo, and then start it in gdb as
&gt;
&gt;    run nettle-pbkdf2 -i 1 -l 16 salt &lt; /tmp/foo

# echo -n passwd|nettle-pbkdf2 -i 1 -l 16 salt
[77641.250170] nettle-pbkdf2[806]: segfault at ffffffffcb811260 ip 
00007f4c115fd998 sp 00007ffc5a7f38d0 error 5 in libnettle.so.6.5[7f4c115eb]
[77641.250574] Code: e8 6d db fe ff 44 01 6d 68 48 83 c4 08 5b 5d 41 5c 
41 5d 41 5e 41 5f c3 66 2e 0f 1f 84 00 00 00 00 00 49 89 dc e9 68 ff f
Segmentation fault

# echo -n passwd &gt; /tmp/passwd
# gdb nettle-pbkdf2
GNU gdb (GDB) 8.2.1
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later 
&lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-wrs-linux".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
     &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from nettle-pbkdf2...(no debugging symbols found)...done.
(gdb) run nettle-pbkdf2 -i 1 -l 16 salt &lt; /tmp/passwd
Starting program: /usr/bin/nettle-pbkdf2 nettle-pbkdf2 -i 1 -l 16 salt &lt; 
/tmp/passwd
Usage: nettle-pbkdf2 [OPTIONS] SALT
Options:
   --help                 Show this help.
   -V, --version          Show version information.
   -i, --iterations=COUNT Desired iteration count (default 10000).
   -l, --length=LENGTH    Desired output length (octets, default 16)
   --raw                  Raw binary output.
   --hex-salt             Use hex encoding for the salt.
[Inferior 1 (process 793) exited with code 01]
(gdb) quit

# cat /tmp/passwd
passwd


&gt;
&gt; What kind of machine, operating system, and compiler are you using?
&gt; Since the testsuite passes on the test systems (including x86_64 and

I work on x86_64 and use gcc for compiler.

&gt; cross-compile setup for arm and mips), I imagine it's something somewhat
&gt; unusual.
&gt;
&gt; Regards,
&gt; /Niels
&gt;
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190410065353</emailId><senderName>"Yu, Mingli"</senderName><senderEmail>mingli.yu@windriver.com</senderEmail><timestampReceived>2019-04-10 06:53:53-0400</timestampReceived><subject>Re: nettle-pbkdf2 Segmentation fault</subject><body>



On 2019年04月10日 14:37, Yu, Mingli wrote:
&gt;
&gt;
&gt; On 2019年04月10日 14:25, Niels Möller wrote:
&gt;&gt; "Yu, Mingli" &lt;mingli.yu@windriver.com&gt; writes:
&gt;&gt;
&gt;&gt;&gt; It's 3.4.1 and I did use it as below:
&gt;&gt;&gt; # echo -n passwd| nettle-pbkdf2 -i 1 -l 16 salt
&gt;&gt;
&gt;&gt; That's the latest version.
&gt;&gt;
&gt;&gt;&gt;&gt; Can you get a backtrace? (start "gdb nettle-pbkdf2", at the gdb prompt
&gt;&gt;&gt;
&gt;&gt;&gt; I don't know how to use nettle-pbkdf2 actually and it didn't return
&gt;&gt;&gt; when I run as below:
&gt;&gt;&gt; # nettle-pbkdf2 -i 1 -l 16 salt
&gt;&gt;
&gt;&gt; Sorry, it wants to read the input password on stdin. Try echo foo &gt;
&gt;&gt; /tmp/foo, and then start it in gdb as
&gt;&gt;
&gt;&gt;    run nettle-pbkdf2 -i 1 -l 16 salt &lt; /tmp/foo
&gt;
&gt; # echo -n passwd|nettle-pbkdf2 -i 1 -l 16 salt
&gt; [77641.250170] nettle-pbkdf2[806]: segfault at ffffffffcb811260 ip
&gt; 00007f4c115fd998 sp 00007ffc5a7f38d0 error 5 in libnettle.so.6.5[7f4c115eb]
&gt; [77641.250574] Code: e8 6d db fe ff 44 01 6d 68 48 83 c4 08 5b 5d 41 5c
&gt; 41 5d 41 5e 41 5f c3 66 2e 0f 1f 84 00 00 00 00 00 49 89 dc e9 68 ff f
&gt; Segmentation fault
&gt;
&gt; # echo -n passwd &gt; /tmp/passwd
&gt; # gdb nettle-pbkdf2
&gt; GNU gdb (GDB) 8.2.1
&gt; Copyright (C) 2018 Free Software Foundation, Inc.
&gt; License GPLv3+: GNU GPL version 3 or later
&gt; &lt;http://gnu.org/licenses/gpl.html&gt;
&gt; This is free software: you are free to change and redistribute it.
&gt; There is NO WARRANTY, to the extent permitted by law.
&gt; Type "show copying" and "show warranty" for details.
&gt; This GDB was configured as "x86_64-wrs-linux".
&gt; Type "show configuration" for configuration details.
&gt; For bug reporting instructions, please see:
&gt; &lt;http://www.gnu.org/software/gdb/bugs/&gt;.
&gt; Find the GDB manual and other documentation resources online at:
&gt;      &lt;http://www.gnu.org/software/gdb/documentation/&gt;.
&gt;
&gt; For help, type "help".
&gt; Type "apropos word" to search for commands related to "word"...
&gt; Reading symbols from nettle-pbkdf2...(no debugging symbols found)...done.
&gt; (gdb) run nettle-pbkdf2 -i 1 -l 16 salt &lt; /tmp/passwd
&gt; Starting program: /usr/bin/nettle-pbkdf2 nettle-pbkdf2 -i 1 -l 16 salt &lt;
&gt; /tmp/passwd
&gt; Usage: nettle-pbkdf2 [OPTIONS] SALT
&gt; Options:
&gt;    --help                 Show this help.
&gt;    -V, --version          Show version information.
&gt;    -i, --iterations=COUNT Desired iteration count (default 10000).
&gt;    -l, --length=LENGTH    Desired output length (octets, default 16)
&gt;    --raw                  Raw binary output.
&gt;    --hex-salt             Use hex encoding for the salt.
&gt; [Inferior 1 (process 793) exited with code 01]
&gt; (gdb) quit

It's weird, this time I get the backstace with gdb as below:

(gdb) run -i 1 -l 16 salt &lt; /tmp/passwd
Starting program: /usr/bin/nettle-pbkdf2 -i 1 -l 16 salt &lt; /tmp/passwd

Program received signal SIGSEGV, Segmentation fault.
0x00007ffff7fad998 in nettle_sha256_update () from /usr/lib64/libnettle.so.6
(gdb) bt
#0  0x00007ffff7fad998 in nettle_sha256_update ()
    from /usr/lib64/libnettle.so.6
#1  0x00007ffff7fa9bb6 in nettle_pbkdf2 () from /usr/lib64/libnettle.so.6
#2  0x00007ffff7fa9dd3 in nettle_pbkdf2_hmac_sha256 ()
    from /usr/lib64/libnettle.so.6
#3  0x000055555555544c in ?? ()
#4  0x00007ffff7dfdb6b in __libc_start_main (main=0x5555555551a0, argc=6,
     argv=0x7fffffffebc8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;,
     rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffebb8)
     at ../csu/libc-start.c:308
#5  0x00005555555555ba in ?? ()

&gt;
&gt; # cat /tmp/passwd
&gt; passwd
&gt;
&gt;
&gt;&gt;
&gt;&gt; What kind of machine, operating system, and compiler are you using?
&gt;&gt; Since the testsuite passes on the test systems (including x86_64 and
&gt;
&gt; I work on x86_64 and use gcc for compiler.
&gt;
&gt;&gt; cross-compile setup for arm and mips), I imagine it's something somewhat
&gt;&gt; unusual.
&gt;&gt;
&gt;&gt; Regards,
&gt;&gt; /Niels
&gt;&gt;
&gt; _______________________________________________
&gt; nettle-bugs mailing list
&gt; nettle-bugs@lists.lysator.liu.se
&gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190410070849</emailId><senderName>"Yu, Mingli"</senderName><senderEmail>mingli.yu@windriver.com</senderEmail><timestampReceived>2019-04-10 07:08:49-0400</timestampReceived><subject>Re: nettle-pbkdf2 Segmentation fault</subject><body>



On 2019年04月10日 14:37, Yu, Mingli wrote:
&gt;
&gt;
&gt; On 2019年04月10日 14:25, Niels Möller wrote:
&gt;&gt; "Yu, Mingli" &lt;mingli.yu@windriver.com&gt; writes:
&gt;&gt;
&gt;&gt;&gt; It's 3.4.1 and I did use it as below:
&gt;&gt;&gt; # echo -n passwd| nettle-pbkdf2 -i 1 -l 16 salt
&gt;&gt;
&gt;&gt; That's the latest version.
&gt;&gt;
&gt;&gt;&gt;&gt; Can you get a backtrace? (start "gdb nettle-pbkdf2", at the gdb prompt
&gt;&gt;&gt;
&gt;&gt;&gt; I don't know how to use nettle-pbkdf2 actually and it didn't return
&gt;&gt;&gt; when I run as below:
&gt;&gt;&gt; # nettle-pbkdf2 -i 1 -l 16 salt
&gt;&gt;
&gt;&gt; Sorry, it wants to read the input password on stdin. Try echo foo &gt;
&gt;&gt; /tmp/foo, and then start it in gdb as
&gt;&gt;
&gt;&gt;    run nettle-pbkdf2 -i 1 -l 16 salt &lt; /tmp/foo
&gt;
&gt; # echo -n passwd|nettle-pbkdf2 -i 1 -l 16 salt
&gt; [77641.250170] nettle-pbkdf2[806]: segfault at ffffffffcb811260 ip
&gt; 00007f4c115fd998 sp 00007ffc5a7f38d0 error 5 in libnettle.so.6.5[7f4c115eb]
&gt; [77641.250574] Code: e8 6d db fe ff 44 01 6d 68 48 83 c4 08 5b 5d 41 5c
&gt; 41 5d 41 5e 41 5f c3 66 2e 0f 1f 84 00 00 00 00 00 49 89 dc e9 68 ff f
&gt; Segmentation fault
&gt;
&gt; # echo -n passwd &gt; /tmp/passwd
&gt; # gdb nettle-pbkdf2
&gt; GNU gdb (GDB) 8.2.1
&gt; Copyright (C) 2018 Free Software Foundation, Inc.
&gt; License GPLv3+: GNU GPL version 3 or later
&gt; &lt;http://gnu.org/licenses/gpl.html&gt;
&gt; This is free software: you are free to change and redistribute it.
&gt; There is NO WARRANTY, to the extent permitted by law.
&gt; Type "show copying" and "show warranty" for details.
&gt; This GDB was configured as "x86_64-wrs-linux".
&gt; Type "show configuration" for configuration details.
&gt; For bug reporting instructions, please see:
&gt; &lt;http://www.gnu.org/software/gdb/bugs/&gt;.
&gt; Find the GDB manual and other documentation resources online at:
&gt;      &lt;http://www.gnu.org/software/gdb/documentation/&gt;.
&gt;
&gt; For help, type "help".
&gt; Type "apropos word" to search for commands related to "word"...
&gt; Reading symbols from nettle-pbkdf2...(no debugging symbols found)...done.
&gt; (gdb) run nettle-pbkdf2 -i 1 -l 16 salt &lt; /tmp/passwd
&gt; Starting program: /usr/bin/nettle-pbkdf2 nettle-pbkdf2 -i 1 -l 16 salt &lt;
&gt; /tmp/passwd
&gt; Usage: nettle-pbkdf2 [OPTIONS] SALT
&gt; Options:
&gt;    --help                 Show this help.
&gt;    -V, --version          Show version information.
&gt;    -i, --iterations=COUNT Desired iteration count (default 10000).
&gt;    -l, --length=LENGTH    Desired output length (octets, default 16)
&gt;    --raw                  Raw binary output.
&gt;    --hex-salt             Use hex encoding for the salt.
&gt; [Inferior 1 (process 793) exited with code 01]
&gt; (gdb) quit

Please ignore this, @_@, I made a typo here.

&gt;
&gt; # cat /tmp/passwd
&gt; passwd
&gt;
&gt;
&gt;&gt;
&gt;&gt; What kind of machine, operating system, and compiler are you using?
&gt;&gt; Since the testsuite passes on the test systems (including x86_64 and
&gt;
&gt; I work on x86_64 and use gcc for compiler.
&gt;
&gt;&gt; cross-compile setup for arm and mips), I imagine it's something somewhat
&gt;&gt; unusual.
&gt;&gt;
&gt;&gt; Regards,
&gt;&gt; /Niels
&gt;&gt;
&gt; _______________________________________________
&gt; nettle-bugs mailing list
&gt; nettle-bugs@lists.lysator.liu.se
&gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190410071323</emailId><senderName>"Yu, Mingli"</senderName><senderEmail>mingli.yu@windriver.com</senderEmail><timestampReceived>2019-04-10 07:13:23-0400</timestampReceived><subject>Re: nettle-pbkdf2 Segmentation fault</subject><body>



On 2019年04月10日 14:53, Yu, Mingli wrote:
&gt;
&gt;
&gt; On 2019年04月10日 14:37, Yu, Mingli wrote:
&gt;&gt;
&gt;&gt;
&gt;&gt; On 2019年04月10日 14:25, Niels Möller wrote:
&gt;&gt;&gt; "Yu, Mingli" &lt;mingli.yu@windriver.com&gt; writes:
&gt;&gt;&gt;
&gt;&gt;&gt;&gt; It's 3.4.1 and I did use it as below:
&gt;&gt;&gt;&gt; # echo -n passwd| nettle-pbkdf2 -i 1 -l 16 salt
&gt;&gt;&gt;
&gt;&gt;&gt; That's the latest version.
&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; Can you get a backtrace? (start "gdb nettle-pbkdf2", at the gdb prompt
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; I don't know how to use nettle-pbkdf2 actually and it didn't return
&gt;&gt;&gt;&gt; when I run as below:
&gt;&gt;&gt;&gt; # nettle-pbkdf2 -i 1 -l 16 salt
&gt;&gt;&gt;
&gt;&gt;&gt; Sorry, it wants to read the input password on stdin. Try echo foo &gt;
&gt;&gt;&gt; /tmp/foo, and then start it in gdb as
&gt;&gt;&gt;
&gt;&gt;&gt;    run nettle-pbkdf2 -i 1 -l 16 salt &lt; /tmp/foo
&gt;&gt;
&gt;&gt; # echo -n passwd|nettle-pbkdf2 -i 1 -l 16 salt
&gt;&gt; [77641.250170] nettle-pbkdf2[806]: segfault at ffffffffcb811260 ip
&gt;&gt; 00007f4c115fd998 sp 00007ffc5a7f38d0 error 5 in
&gt;&gt; libnettle.so.6.5[7f4c115eb]
&gt;&gt; [77641.250574] Code: e8 6d db fe ff 44 01 6d 68 48 83 c4 08 5b 5d 41 5c
&gt;&gt; 41 5d 41 5e 41 5f c3 66 2e 0f 1f 84 00 00 00 00 00 49 89 dc e9 68 ff f
&gt;&gt; Segmentation fault
&gt;&gt;
&gt;&gt; # echo -n passwd &gt; /tmp/passwd
&gt;&gt; # gdb nettle-pbkdf2
&gt;&gt; GNU gdb (GDB) 8.2.1
&gt;&gt; Copyright (C) 2018 Free Software Foundation, Inc.
&gt;&gt; License GPLv3+: GNU GPL version 3 or later
&gt;&gt; &lt;http://gnu.org/licenses/gpl.html&gt;
&gt;&gt; This is free software: you are free to change and redistribute it.
&gt;&gt; There is NO WARRANTY, to the extent permitted by law.
&gt;&gt; Type "show copying" and "show warranty" for details.
&gt;&gt; This GDB was configured as "x86_64-wrs-linux".
&gt;&gt; Type "show configuration" for configuration details.
&gt;&gt; For bug reporting instructions, please see:
&gt;&gt; &lt;http://www.gnu.org/software/gdb/bugs/&gt;.
&gt;&gt; Find the GDB manual and other documentation resources online at:
&gt;&gt;      &lt;http://www.gnu.org/software/gdb/documentation/&gt;.
&gt;&gt;
&gt;&gt; For help, type "help".
&gt;&gt; Type "apropos word" to search for commands related to "word"...
&gt;&gt; Reading symbols from nettle-pbkdf2...(no debugging symbols found)...done.
&gt;&gt; (gdb) run nettle-pbkdf2 -i 1 -l 16 salt &lt; /tmp/passwd
&gt;&gt; Starting program: /usr/bin/nettle-pbkdf2 nettle-pbkdf2 -i 1 -l 16 salt &lt;
&gt;&gt; /tmp/passwd
&gt;&gt; Usage: nettle-pbkdf2 [OPTIONS] SALT
&gt;&gt; Options:
&gt;&gt;    --help                 Show this help.
&gt;&gt;    -V, --version          Show version information.
&gt;&gt;    -i, --iterations=COUNT Desired iteration count (default 10000).
&gt;&gt;    -l, --length=LENGTH    Desired output length (octets, default 16)
&gt;&gt;    --raw                  Raw binary output.
&gt;&gt;    --hex-salt             Use hex encoding for the salt.
&gt;&gt; [Inferior 1 (process 793) exited with code 01]
&gt;&gt; (gdb) quit
&gt;
&gt; It's weird, this time I get the backstace with gdb as below:
&gt;
&gt; (gdb) run -i 1 -l 16 salt &lt; /tmp/passwd
&gt; Starting program: /usr/bin/nettle-pbkdf2 -i 1 -l 16 salt &lt; /tmp/passwd
&gt;
&gt; Program received signal SIGSEGV, Segmentation fault.
&gt; 0x00007ffff7fad998 in nettle_sha256_update () from
&gt; /usr/lib64/libnettle.so.6
&gt; (gdb) bt
&gt; #0  0x00007ffff7fad998 in nettle_sha256_update ()
&gt;     from /usr/lib64/libnettle.so.6
&gt; #1  0x00007ffff7fa9bb6 in nettle_pbkdf2 () from /usr/lib64/libnettle.so.6
&gt; #2  0x00007ffff7fa9dd3 in nettle_pbkdf2_hmac_sha256 ()
&gt;     from /usr/lib64/libnettle.so.6
&gt; #3  0x000055555555544c in ?? ()
&gt; #4  0x00007ffff7dfdb6b in __libc_start_main (main=0x5555555551a0, argc=6,
&gt;      argv=0x7fffffffebc8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;,
&gt;      rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffebb8)
&gt;      at ../csu/libc-start.c:308
&gt; #5  0x00005555555555ba in ?? ()


(gdb) r -i 1 -l 16 salt &lt; /tmp/passwd
Starting program: /usr/bin/nettle-pbkdf2 -i 1 -l 16 salt &lt; /tmp/passwd

Program received signal SIGSEGV, Segmentation fault.
nettle_sha256_update (ctx=0x7fffffffe5c0, length=&lt;optimized out&gt;,
     data=0x55559260 &lt;error: Cannot access memory at address 0x55559260&gt;)
     at ../nettle-3.4.1/sha256.c:99
99	../nettle-3.4.1/sha256.c: No such file or directory.
(gdb) bt
#0  nettle_sha256_update (ctx=0x7fffffffe5c0, length=&lt;optimized out&gt;,
     data=0x55559260 &lt;error: Cannot access memory at address 0x55559260&gt;)
     at ../nettle-3.4.1/sha256.c:99
#1  0x00007ffff7fa9bb6 in nettle_pbkdf2 
(mac_ctx=mac_ctx@entry=0x7fffffffe4e0,
     update=0x7ffff7fa7cb0 &lt;nettle_hmac_sha256_update&gt;,
     digest=0x7ffff7fa7cc0 &lt;nettle_hmac_sha256_digest&gt;,
     digest_size=digest_size@entry=32, iterations=iterations@entry=1,
     salt_length=salt_length@entry=4,
     salt=0x55559260 &lt;error: Cannot access memory at address 0x55559260&gt;,
     length=16, dst=0x55555555a290 "") at ../nettle-3.4.1/pbkdf2.c:78
#2  0x00007ffff7fa9dd3 in nettle_pbkdf2_hmac_sha256 (
     key_length=&lt;optimized out&gt;, key=&lt;optimized out&gt;, iterations=1,
     salt_length=4,
     salt=0x55559260 &lt;error: Cannot access memory at address 0x55559260&gt;,
     length=16, dst=0x55555555a290 "")
     at ../nettle-3.4.1/pbkdf2-hmac-sha256.c:51
#3  0x000055555555544c in main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;)
     at ../../nettle-3.4.1/tools/nettle-pbkdf2.c:167



Seems it breaks here in sha256_update function of sha256.c
MD_UPDATE (ctx, length, data, COMPRESS, ctx-&gt;count++);

&gt;
&gt;&gt;
&gt;&gt; # cat /tmp/passwd
&gt;&gt; passwd
&gt;&gt;
&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; What kind of machine, operating system, and compiler are you using?
&gt;&gt;&gt; Since the testsuite passes on the test systems (including x86_64 and
&gt;&gt;
&gt;&gt; I work on x86_64 and use gcc for compiler.
&gt;&gt;
&gt;&gt;&gt; cross-compile setup for arm and mips), I imagine it's something somewhat
&gt;&gt;&gt; unusual.
&gt;&gt;&gt;
&gt;&gt;&gt; Regards,
&gt;&gt;&gt; /Niels
&gt;&gt;&gt;
&gt;&gt; _______________________________________________
&gt;&gt; nettle-bugs mailing list
&gt;&gt; nettle-bugs@lists.lysator.liu.se
&gt;&gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs
&gt; _______________________________________________
&gt; nettle-bugs mailing list
&gt; nettle-bugs@lists.lysator.liu.se
&gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190410194926</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-04-10 19:49:26-0400</timestampReceived><subject>Re: nettle-pbkdf2 Segmentation fault</subject><body>

"Yu, Mingli" &lt;mingli.yu@windriver.com&gt; writes:

&gt; Program received signal SIGSEGV, Segmentation fault.
&gt; nettle_sha256_update (ctx=0x7fffffffe5c0, length=&lt;optimized out&gt;,
&gt;     data=0x55559260 &lt;error: Cannot access memory at address 0x55559260&gt;)
&gt;     at ../nettle-3.4.1/sha256.c:99
&gt; 99	../nettle-3.4.1/sha256.c: No such file or directory.
&gt; (gdb) bt
&gt; #0  nettle_sha256_update (ctx=0x7fffffffe5c0, length=&lt;optimized out&gt;,
&gt;     data=0x55559260 &lt;error: Cannot access memory at address 0x55559260&gt;)
&gt;     at ../nettle-3.4.1/sha256.c:99
&gt; #1  0x00007ffff7fa9bb6 in nettle_pbkdf2
&gt; (mac_ctx=mac_ctx@entry=0x7fffffffe4e0,
&gt;     update=0x7ffff7fa7cb0 &lt;nettle_hmac_sha256_update&gt;,
&gt;     digest=0x7ffff7fa7cc0 &lt;nettle_hmac_sha256_digest&gt;,
&gt;     digest_size=digest_size@entry=32, iterations=iterations@entry=1,
&gt;     salt_length=salt_length@entry=4,
&gt;     salt=0x55559260 &lt;error: Cannot access memory at address 0x55559260&gt;,
&gt;     length=16, dst=0x55555555a290 "") at ../nettle-3.4.1/pbkdf2.c:78
&gt; #2  0x00007ffff7fa9dd3 in nettle_pbkdf2_hmac_sha256 (
&gt;     key_length=&lt;optimized out&gt;, key=&lt;optimized out&gt;, iterations=1,
&gt;     salt_length=4,
&gt;     salt=0x55559260 &lt;error: Cannot access memory at address 0x55559260&gt;,
&gt;     length=16, dst=0x55555555a290 "")
&gt;     at ../nettle-3.4.1/pbkdf2-hmac-sha256.c:51
&gt; #3  0x000055555555544c in main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;)
&gt;     at ../../nettle-3.4.1/tools/nettle-pbkdf2.c:167

Not sure if everything here can be trusted, but the 

  salt=0x55559260 &lt;error: Cannot access memory at address 0x55559260&gt;,

in the backtrace indicates some problem with the salt passed down fron
the nettle-pbkdf2 tool to the nettle library functions.

It's allocated as

  salt = strdup (argv[0]);

at line 146 in tools/nettle-pbkdf2.c (after an argv += optind). I note
that there's no check of the return value, but if strdup fails it should
return NULL, which would be a different invalid address.

You may want to examine the values of those variables in the debugger or
with debug printouts. E.g, try this patch.

--- a/tools/nettle-pbkdf2.c
+++ b/tools/nettle-pbkdf2.c
@@ -144,6 +144,11 @@ main (int argc, char **argv)
     }
 
   salt = strdup (argv[0]);
+  if (!salt)
+    die ("strdup failed: Virtual memory exhausted.\n");
+  fprintf(stderr, "argv[0]: '%s'\n", argv[0]);
+  fprintf(stderr, "copy (salt): '%s'\n", salt);
+
   salt_length = strlen(argv[0]);
   
   if (hex_salt)

&gt;&gt;&gt;&gt; What kind of machine, operating system, and compiler are you using?
&gt;&gt;&gt;&gt; Since the testsuite passes on the test systems (including x86_64 and
&gt;&gt;&gt;
&gt;&gt;&gt; I work on x86_64 and use gcc for compiler.

And operating system, please?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190119151736</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-01-19 15:17:36-0400</timestampReceived><subject>Re: [repost] [PATCH] Add --enable-fat support for arm neon chacha20</subject><body>

"Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt; writes:

&gt; +DECLARE_FAT_FUNC(_nettle_chacha_core, chacha_core_func)
&gt; +DECLARE_FAT_FUNC_VAR(_chacha_core, chacha_core_func, c);
&gt; +DECLARE_FAT_FUNC_VAR(_chacha_core, chacha_core_func, neon);
                        ^

The above underscores shouldn't be there. If I delete them, this works
fine using debian's cross compilers and qemu.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702120356</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-02 12:03:56-0400</timestampReceived><subject>Re: Changes after 3.5.1</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; I have several patch series that were sitting in my local gost tree.
&gt; Most of them were posted to this mailing list for review with little
&gt; to no feedback.

&gt;  - CMAC-64 support (together with CMAC-TDES for testing).
&gt;  - Changes to GOST R 34.11-94 (gosthash94) code
&gt;  - GOST 28147-89/Magma 64-bit cipher (depend on gosthash94 changes)
&gt;  - Additional cipher modes required for full GOST 28147-89 support
&gt;  - Streebog hash algorithm (GOST R 34.11-2012)
&gt;  - Several GOST curves (2 for now, other require changes to ecc backend)
&gt;  - GOST ECC-based digital signature scheme
&gt;  - GOST ECC-based key agreement
&gt;  - small chunks of additional support code

Except for the last one (not sure what those changes are), this looks
like a reasonable order. For the ecc things, I think I'd give the ed448
changes higher priority.

Can you resend links for the first two or thee changes, or resend latest
patches?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190102102255</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2019-01-02 10:22:55-0400</timestampReceived><subject>Re: Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

On Sat, 2018-12-29 at 10:40 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt; 
&gt; &gt; I am not at home to check but most likely a newer openssl is
&gt; &gt; needed. You can use fedora:29 or fedora:latest
&gt; 
&gt; Ok, I'm trying 

I attach a patch which moves everything to the latest images used by
gnutls (i.e., in addition to your patch, it also moves the x86 builds
to debian).

The gnutls build now passes but the static analyzers fail as you also
saw. A quick fix would be to leave the static analyzers to use f28
though that would need to be solved eventually.

regards,
Nikos


["0001-.gitlab-ci.yml-updated-to-new-images-by-gnutls.patch" (0001-.gitlab-ci.yml-updated-to-new-images-by-gnutls.patch)]

From 76ef226e8c309a3aacb1cfa52edf7d90e1f3d070 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 2 Jan 2019 10:31:08 +0100
Subject: [PATCH] .gitlab-ci.yml: updated to new images by gnutls

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 .gitlab-ci.yml | 30 ++++++++++++++++++------------
 1 file changed, 18 insertions(+), 12 deletions(-)

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 166de71b..96a007e7 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -1,8 +1,8 @@
 variables:
   BUILD_IMAGES_PROJECT: gnutls/build-images
   DEBIAN_CROSS_BUILD: buildenv-debian-cross
-  FEDORA_BUILD: buildenv-f28
-  FEDORA_X86_BUILD: buildenv-f28-x86
+  FEDORA_BUILD: buildenv-f29
+  DEBIAN_X86_CROSS_BUILD: buildenv-debian-x86-cross
   GET_SOURCES_ATTEMPTS: "3"
 
 # remove any pre-installed headers from nettle
@@ -20,16 +20,6 @@ build/x86-64:
   - shared
   except:
   - tags
-build/x86:
-  image: $CI_REGISTRY/$BUILD_IMAGES_PROJECT:$FEDORA_X86_BUILD
-  script:
-  - ./.bootstrap &amp;&amp;
-    PKG_CONFIG_PATH="/usr/lib/pkgconfig/" CFLAGS="-O2 -g -m32" LDFLAGS="-m32" \
./configure --build=i686-redhat-linux --enable-fat --disable-documentation &amp;&amp; make \
                -j4 &amp;&amp;
-    make check -j4
-  tags:
-  - shared
-  except:
-  - tags
 build/mini-gmp:
   image: $CI_REGISTRY/$BUILD_IMAGES_PROJECT:$FEDORA_BUILD
   script:
@@ -98,6 +88,22 @@ build/gnutls:
       - gnutls-git/*.log
       - gnutls-git/tests/*/*.log
       - gnutls-git/tests/suite/*/*.log
+Debian.cross.x86:
+  image: $CI_REGISTRY/$BUILD_IMAGES_PROJECT:$DEBIAN_X86_CROSS_BUILD
+  before_script:
+  - apt-get remove -y nettle-dev:i386
+  script:
+  - build=$(dpkg-architecture -qDEB_HOST_GNU_TYPE)
+  - host=i686-linux-gnu
+  - export CC_FOR_BUILD="gcc"
+  - export CC="$host-gcc"
+  - ./.bootstrap &amp;&amp;
+    CFLAGS="-O2 -g" ./configure --build=$build --host=$host --enable-fat \
--disable-documentation &amp;&amp; make -j4 &amp;&amp; +    make check -j4
+  tags:
+  - shared
+  except:
+  - tags
 .Debian.cross.template: &amp;Debian_cross_template
   image: $CI_REGISTRY/$BUILD_IMAGES_PROJECT:$DEBIAN_CROSS_BUILD
   before_script:
-- 
2.19.2


[Attachment #4 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190112164746</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-01-12 16:47:46-0400</timestampReceived><subject>Re: Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; I attach a patch which moves everything to the latest images used by
&gt; gnutls (i.e., in addition to your patch, it also moves the x86 builds
&gt; to debian).

Merged now. And I've deleted eratosthens.c. We'll see how to deal with
the static analalyzer's remaining complaints on eccdata.c.

I'm also considering adding a few more configurations to the ci,
including "CC=gcc -std=c89", CPPFLAGS=-DNODEBUG and --disable-assembler.
Anything I have to keep in mind (e.g., limits on builder resources?)

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190112181206</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2019-01-12 18:12:06-0400</timestampReceived><subject>Re: Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

On Sat, Jan 12, 2019 at 11:47 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; ...
&gt; I'm also considering adding a few more configurations to the ci,
&gt; including "CC=gcc -std=c89", CPPFLAGS=-DNODEBUG and --disable-assembler.
&gt; Anything I have to keep in mind (e.g., limits on builder resources?)

I recommend making folks explicitly ask for a debug build with
-DNETTLE_DEBUG or similar. Don't define it in terms of "not Posix
NDEBUG " or "not Nettle NODEBUG".

The typical use case is folks untar, config, and make. Eventually they
want to install locally, perhaps as part of a collection of packages.
Those who perform a straight release build should not have to do
something special. Also, it depends on each person reading the manual
and things just don't work that way in real life.

Folks who want a debug build should do something special. They will
notice right away they have an optimized build missing symbols under
the debugger. They will know to investigate more, like running
'./configure --help'.

The debug build use case also means `--with-debug` or similar that
adds -DNETTLE_DEBUG or similar is probably a good idea.

If you chose to make the debug builds the default case then be sure to
tell folks about it after configure runs. Also tell them the options
needed to perform a release build since many folks will want a release
build.

(This is the part of security engineering that offends almost
everyone. You have to identify use cases and then acknowledge one as
the dominant case. Then, others have to do something special and you
have to tell them how to ensure they can shoot themselves in the foot,
if desired).

Jeff
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190112230103</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-01-12 23:01:03-0400</timestampReceived><subject>Re: Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

Jeffrey Walton &lt;noloader@gmail.com&gt; writes:

&gt; I recommend making folks explicitly ask for a debug build with
&gt; -DNETTLE_DEBUG or similar.

"Debug build" vs "release build" is a bit alien to the way GNU packages
are usually built, and I suspect it partly dates to times where
optimization and useful debugging info were mutually exclusive.
Default builds include both optimization and debugging symbols (and I
think that's still what GNU coding standards recommend, perhaps with the
option to strip debug symbols at install time).

Regarding asserts, I generally recommend to build with asserts enabled.
I know you disagree about that, but I really do *not* want any of us to
repeast arguments on that topic on this list. Don't go that way.

I'm happy to support builds with asserts turned off (that's the only
reason I'm considering adding a ci builds for that configuration), but
it's not going to be the default config.

Not sure a --disable-asserts configura option is that useful, if it's
only an alias for -DNDEBUG. What other effects do you suggest
--disable-debug or --disable-assert should have?

&gt; Don't define it in terms of "not Posix NDEBUG " or "not Nettle
&gt; NODEBUG".

I'm not following. As far as I understand, assert.h and NDEBUG are part
of the C language, not Posix.

(To go out on a tangent, there may be some projects where it's useful to
include a *lot* of extra sanity code, and then have a way to exclude it
for a "release" build. I think that's a bit rare, though, and I don't
think Nettle is that type of project. I seem to recall one of the
openbsd developers advocating always deleting the extra sanity check
code and debug printfs after the code is in working state, before
checking it in, to not distract from the actual code. In contrast to the
fairly common practice to leave it in in under some #ifdef under the
theory that it might be nice to have in some future debugging session.
If it's really motivated to have that sanity check code in at all,
because bugs are expected to have particularly subtle and hard-to-debug
effects, one may well want that extra correctness assurance also when
using the installed program in a "release" build).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190113005231</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2019-01-13 00:52:31-0400</timestampReceived><subject>Re: Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

On Sat, Jan 12, 2019 at 6:01 PM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; Jeffrey Walton &lt;noloader@gmail.com&gt; writes:
&gt;
&gt; &gt; I recommend making folks explicitly ask for a debug build with
&gt; &gt; -DNETTLE_DEBUG or similar.
&gt;
&gt; "Debug build" vs "release build" is a bit alien to the way GNU packages
&gt; are usually built, and I suspect it partly dates to times where
&gt; optimization and useful debugging info were mutually exclusive.
&gt; Default builds include both optimization and debugging symbols (and I
&gt; think that's still what GNU coding standards recommend, perhaps with the
&gt; option to strip debug symbols at install time).
&gt;
&gt; Regarding asserts, I generally recommend to build with asserts enabled.
&gt; I know you disagree about that, but I really do *not* want any of us to
&gt; repeast arguments on that topic on this list. Don't go that way.
&gt;
&gt; I'm happy to support builds with asserts turned off (that's the only
&gt; reason I'm considering adding a ci builds for that configuration), but
&gt; it's not going to be the default config.
&gt;
&gt; Not sure a --disable-asserts configura option is that useful, if it's
&gt; only an alias for -DNDEBUG. What other effects do you suggest
&gt; --disable-debug or --disable-assert should have?
&gt;
&gt; &gt; Don't define it in terms of "not Posix NDEBUG " or "not Nettle
&gt; &gt; NODEBUG".
&gt;
&gt; I'm not following. As far as I understand, assert.h and NDEBUG are part
&gt; of the C language, not Posix.
&gt;
&gt; (To go out on a tangent, there may be some projects where it's useful to
&gt; include a *lot* of extra sanity code, and then have a way to exclude it
&gt; for a "release" build. I think that's a bit rare, though, and I don't
&gt; think Nettle is that type of project. I seem to recall one of the
&gt; openbsd developers advocating always deleting the extra sanity check
&gt; code and debug printfs after the code is in working state, before
&gt; checking it in, to not distract from the actual code. In contrast to the
&gt; fairly common practice to leave it in in under some #ifdef under the
&gt; theory that it might be nice to have in some future debugging session.
&gt; If it's really motivated to have that sanity check code in at all,
&gt; because bugs are expected to have particularly subtle and hard-to-debug
&gt; effects, one may well want that extra correctness assurance also when
&gt; using the installed program in a "release" build).

My bad, I was speaking to the proposed -DNODEBUG macro presented earlier:

&gt; I'm also considering adding a few more configurations to the ci,
&gt; including "CC=gcc -std=c89", CPPFLAGS=-DNODEBUG and --disable-assembler.
&gt; Anything I have to keep in mind (e.g., limits on builder resources?)

Jeff
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190113091021</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-01-13 09:10:21-0400</timestampReceived><subject>Re: Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

Jeffrey Walton &lt;noloader@gmail.com&gt; writes:

&gt; My bad, I was speaking to the proposed -DNODEBUG macro presented earlier:

Sorry for that typo; I intended to use the standard assert.h facility,
i.e., -DNDEBUG.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190114092536</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2019-01-14 09:25:36-0400</timestampReceived><subject>Re: Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

On Sat, 2019-01-12 at 17:47 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; 
&gt; &gt; I attach a patch which moves everything to the latest images used
&gt; &gt; by
&gt; &gt; gnutls (i.e., in addition to your patch, it also moves the x86
&gt; &gt; builds
&gt; &gt; to debian).
&gt; 
&gt; Merged now. And I've deleted eratosthens.c. We'll see how to deal
&gt; with
&gt; the static analalyzer's remaining complaints on eccdata.c.
&gt; 
&gt; I'm also considering adding a few more configurations to the ci,
&gt; including "CC=gcc -std=c89", CPPFLAGS=-DNODEBUG and --disable-
&gt; assembler.
&gt; Anything I have to keep in mind (e.g., limits on builder resources?)

As an open source project in gitlab there are no limits. The only limit
is your running time expectations.

regards,
Nikos


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702132658</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:26:58-0400</timestampReceived><subject>[PATCH 00/14] HMAC implementation rework</subject><body>

This is my current attempt to rework hash/HMAC internal API to use
separate block buffer from main hash state and thus decrease HMAC
context data size by removing byte buffer duplication. Unfortunately
this breaks GnuTLS accelerated implementations. Patch for GnuTLS will be
provided, if this approach is going to be accepted to Nettle.

The following changes since commit ee5d62898cf070f08beedc410a8d7c418588bd95:

  Fixes for Nettle 3.5.1 (2019-06-26 21:51:36 +0200)

are available in the Git repository at:

  https://gitlab.com/GostCrypt/nettle.git gitlab/hmac-3

for you to fetch changes up to dda00a07d26dbdb6647186c778febe870c30cafc:

  hmac-sha512/hmac-sha384: use new hmac and hash split state/buffer interface (2019-07-02 16:21:48 +0300)

----------------------------------------------------------------
Dmitry Eremin-Solenikov (14):
      sha512-224,-256: use _NETTLE_HASH_US instead of hand-coding structure definitions
      hash: start separating state and block contexts
      macros: add interface for working with separate hash state and buffer
      md5: split context into hash state and byte buffer
      hmac: add interface for working with separate hash state and buffer
      hmac-md5: use new hmac and hash split state/buffer interface
      ripemd160: split context into hash state and byte buffer
      hmac-ripemd160: use new hmac and hash split state/buffer interface
      sha1: split context into hash state and byte buffer
      hmac-sha1: use new hmac and hash split state/buffer interface
      sha256/sha224: split context into hash state and byte buffer
      hmac-sha256/hmac-sha224: use new hmac and hash split state/buffer interface
      sha512/sha384: split context into hash state and byte buffer
      hmac-sha512/hmac-sha384: use new hmac and hash split state/buffer interface

 hmac-md5.c        |   6 +--
 hmac-ripemd160.c  |   6 +--
 hmac-sha1.c       |   6 +--
 hmac-sha224.c     |   4 +-
 hmac-sha256.c     |   6 +--
 hmac-sha384.c     |   4 +-
 hmac-sha512.c     |   6 +--
 hmac.c            |  62 ++++++++++++++++++++++++++
 hmac.h            |  37 +++++++++++++---
 macros.h          |  66 ++++++++++++++++++++++++++++
 md5-meta.c        |   3 ++
 md5.c             |  52 ++++++++++++++++------
 md5.h             |  29 ++++++++++--
 nettle-meta.h     |  56 ++++++++++++++++++++++++
 nettle-types.h    |  15 +++++++
 ripemd160-meta.c  |   3 ++
 ripemd160.c       |  50 ++++++++++++++++-----
 ripemd160.h       |  29 ++++++++++--
 sha1-meta.c       |   3 ++
 sha1.c            |  56 +++++++++++++++++-------
 sha1.h            |  29 ++++++++++--
 sha2.h            |  87 +++++++++++++++++++++++++++++++++---
 sha224-meta.c     |   3 ++
 sha256-meta.c     |   3 ++
 sha256.c          |  76 +++++++++++++++++++++++++-------
 sha384-meta.c     |   3 ++
 sha512-224-meta.c |  12 +----
 sha512-256-meta.c |  12 +----
 sha512-meta.c     |   3 ++
 sha512.c          | 129 +++++++++++++++++++++++++++++++++++++++---------------
 30 files changed, 701 insertions(+), 155 deletions(-)


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702132659</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:26:59-0400</timestampReceived><subject>[PATCH 01/14] sha512-224, -256: use _NETTLE_HASH_US instead of hand-coding structure definitions</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 nettle-meta.h     | 10 ++++++++++
 sha512-224-meta.c | 12 ++----------
 sha512-256-meta.c | 12 ++----------
 3 files changed, 14 insertions(+), 20 deletions(-)

diff --git a/nettle-meta.h b/nettle-meta.h
index 74e50e59cd2e..e3db0e9d63aa 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -117,6 +117,16 @@ struct nettle_hash
  (nettle_hash_digest_func *) name##_digest	\
 } 
 
+#define _NETTLE_HASH_US(name, name_us, NAME) {	\
+ #name,						\
+ sizeof(struct name_us##_ctx),			\
+ NAME##_DIGEST_SIZE,				\
+ NAME##_BLOCK_SIZE,				\
+ (nettle_hash_init_func *) name_us##_init,	\
+ (nettle_hash_update_func *) name_us##_update,	\
+ (nettle_hash_digest_func *) name_us##_digest	\
+}
+
 /* null-terminated list of digests implemented by this version of nettle */
 const struct nettle_hash * const * _NETTLE_ATTRIBUTE_PURE
 nettle_get_hashes (void);
diff --git a/sha512-224-meta.c b/sha512-224-meta.c
index 24c42bfc23d9..ce07362f3ad0 100644
--- a/sha512-224-meta.c
+++ b/sha512-224-meta.c
@@ -37,13 +37,5 @@
 
 #include "sha2.h"
 
-const struct nettle_hash nettle_sha512_224 =
-  {
-    "sha512-224", sizeof(struct sha512_ctx),
-    SHA512_224_DIGEST_SIZE,
-    SHA512_224_BLOCK_SIZE,
-    (nettle_hash_init_func *) sha512_224_init,
-    (nettle_hash_update_func *) sha512_224_update,
-    (nettle_hash_digest_func *) sha512_224_digest
-  };
-
+const struct nettle_hash nettle_sha512_224
+= _NETTLE_HASH_US(sha512-224, sha512_224, SHA512_224);
diff --git a/sha512-256-meta.c b/sha512-256-meta.c
index 37d17c351878..fbaece84b998 100644
--- a/sha512-256-meta.c
+++ b/sha512-256-meta.c
@@ -37,13 +37,5 @@
 
 #include "sha2.h"
 
-const struct nettle_hash nettle_sha512_256 =
-  {
-    "sha512-256", sizeof(struct sha512_ctx),
-    SHA512_256_DIGEST_SIZE,
-    SHA512_256_BLOCK_SIZE,
-    (nettle_hash_init_func *) sha512_256_init,
-    (nettle_hash_update_func *) sha512_256_update,
-    (nettle_hash_digest_func *) sha512_256_digest
-  };
-
+const struct nettle_hash nettle_sha512_256
+= _NETTLE_HASH_US(sha512-256, sha512_256, SHA512_256);
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702132700</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:27:00-0400</timestampReceived><subject>[PATCH 02/14] hash: start separating state and block contexts</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 nettle-meta.h  | 28 ++++++++++++++++++++++++++++
 nettle-types.h | 15 +++++++++++++++
 2 files changed, 43 insertions(+)

diff --git a/nettle-meta.h b/nettle-meta.h
index e3db0e9d63aa..f21dcd9b344d 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -107,6 +107,24 @@ struct nettle_hash
   nettle_hash_digest_func *digest;
 };
 
+struct nettle_bctx_hash
+{
+  const char *name;
+
+  /* Size of the context state struct */
+  unsigned state_size;
+
+  /* Size of digests */
+  unsigned digest_size;
+
+  /* Internal block size */
+  unsigned block_size;
+
+  nettle_hash_block_init_func *block_init;
+  nettle_hash_block_update_func *block_update;
+  nettle_hash_block_digest_func *block_digest;
+};
+
 #define _NETTLE_HASH(name, NAME) {		\
  #name,						\
  sizeof(struct name##_ctx),			\
@@ -127,6 +145,16 @@ struct nettle_hash
  (nettle_hash_digest_func *) name_us##_digest	\
 }
 
+#define _NETTLE_BLOCK_HASH(name, NAME) {	\
+ #name,						\
+ sizeof(struct name##_state),			\
+ NAME##_DIGEST_SIZE,				\
+ NAME##_BLOCK_SIZE,				\
+ (nettle_hash_block_init_func *) name##_block_init,	\
+ (nettle_hash_block_update_func *) name##_block_update,	\
+ (nettle_hash_block_digest_func *) name##_block_digest	\
+}
+
 /* null-terminated list of digests implemented by this version of nettle */
 const struct nettle_hash * const * _NETTLE_ATTRIBUTE_PURE
 nettle_get_hashes (void);
diff --git a/nettle-types.h b/nettle-types.h
index 87292ac69730..ecb56cbba39c 100644
--- a/nettle-types.h
+++ b/nettle-types.h
@@ -65,6 +65,14 @@ union nettle_block16
   uint64_t u64[2];
 };
 
+#define BLOCK_CTX(size) struct { unsigned index; uint8_t buffer[size]; } block
+
+/* Simple block context without actual buffer length */
+struct block_ctx {
+	unsigned index;
+	uint8_t buffer[0];
+};
+
 /* Randomness. Used by key generation and dsa signature creation. */
 typedef void nettle_random_func(void *ctx,
 				size_t length, uint8_t *dst);
@@ -97,6 +105,13 @@ typedef void nettle_hash_update_func(void *ctx,
 				     const uint8_t *src);
 typedef void nettle_hash_digest_func(void *ctx,
 				     size_t length, uint8_t *dst);
+typedef void nettle_hash_block_init_func(void *ctx, struct block_ctx *bctx);
+typedef void nettle_hash_block_update_func(void *ctx,
+					   struct block_ctx *bctx,
+					   size_t length,
+					   const uint8_t *src);
+typedef void nettle_hash_block_digest_func(void *ctx, struct block_ctx *bctx,
+					   size_t length, uint8_t *dst);
 
 /* ASCII armor codecs. NOTE: Experimental and subject to change. */
 
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702132701</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:27:01-0400</timestampReceived><subject>[PATCH 03/14] macros: add interface for working with separate hash state and buffer</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 macros.h | 66 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 66 insertions(+)

diff --git a/macros.h b/macros.h
index 990d32ee3b36..615f06c4c7de 100644
--- a/macros.h
+++ b/macros.h
@@ -215,6 +215,45 @@ do {						\
     ;									\
   } while (0)
 
+/* Takes the compression function f as argument. NOTE: also clobbers
+   length and data. */
+#define MD_BLOCK_UPDATE(state, bctx, bsize, length, data, f, incr)	\
+  do {									\
+    if ((bctx)-&gt;index)							\
+      {									\
+	/* Try to fill partial block */					\
+	unsigned __md_left = bsize - (bctx)-&gt;index;	\
+	if ((length) &lt; __md_left)					\
+	  {								\
+	    memcpy((bctx)-&gt;buffer + (bctx)-&gt;index, (data), (length));	\
+	    (bctx)-&gt;index += (length);					\
+	    goto __md_done; /* Finished */				\
+	  }								\
+	else								\
+	  {								\
+	    memcpy((bctx)-&gt;buffer + (bctx)-&gt;index, (data), __md_left);	\
+									\
+	    f((state), (bctx)-&gt;buffer);					\
+	    (incr);							\
+									\
+	    (data) += __md_left;					\
+	    (length) -= __md_left;					\
+	  }								\
+      }									\
+    while ((length) &gt;= bsize)				\
+      {									\
+	f((state), (data));						\
+	(incr);								\
+									\
+	(data) += bsize;				\
+	(length) -= bsize;				\
+      }									\
+    memcpy ((bctx)-&gt;buffer, (data), (length));				\
+    (bctx)-&gt;index = (length);						\
+  __md_done:								\
+    ;									\
+  } while (0)
+
 /* Pads the block to a block boundary with the bit pattern 1 0*,
    leaving size octets for the length field at the end. If needed,
    compresses the block and starts a new one. */
@@ -242,4 +281,31 @@ do {						\
 									\
   } while (0)
 
+/* Pads the block to a block boundary with the bit pattern 1 0*,
+   leaving size octets for the length field at the end. If needed,
+   compresses the block and starts a new one. */
+#define MD_BLOCK_PAD(sctx, bctx, bsize, size, f)			\
+  do {									\
+    unsigned __md_i;							\
+    __md_i = (bctx)-&gt;index;						\
+									\
+    /* Set the first char of padding to 0x80. This is safe since there	\
+       is always at least one byte free */				\
+									\
+    assert(__md_i &lt; bsize);				\
+    (bctx)-&gt;buffer[__md_i++] = 0x80;					\
+									\
+    if (__md_i &gt; (bsize - (size)))			\
+      { /* No room for length in this block. Process it and		\
+	   pad with another one */					\
+	memset((bctx)-&gt;buffer + __md_i, 0, bsize - __md_i); \
+									\
+	f((sctx), (bctx)-&gt;buffer);						\
+	__md_i = 0;							\
+      }									\
+    memset((bctx)-&gt;buffer + __md_i, 0,					\
+	   bsize - (size) - __md_i);			\
+									\
+  } while (0)
+
 #endif /* NETTLE_MACROS_H_INCLUDED */
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702132702</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:27:02-0400</timestampReceived><subject>[PATCH 04/14] md5: split context into hash state and byte buffer</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 md5-meta.c    |  3 +++
 md5.c         | 52 +++++++++++++++++++++++++++++++++++++--------------
 md5.h         | 29 +++++++++++++++++++++++++---
 nettle-meta.h |  2 ++
 4 files changed, 69 insertions(+), 17 deletions(-)

diff --git a/md5-meta.c b/md5-meta.c
index e4013edfd233..63b4a7438774 100644
--- a/md5-meta.c
+++ b/md5-meta.c
@@ -39,3 +39,6 @@
 
 const struct nettle_hash nettle_md5
 = _NETTLE_HASH(md5, MD5);
+
+const struct nettle_bctx_hash nettle_bctx_md5
+= _NETTLE_BLOCK_HASH(md5, MD5);
diff --git a/md5.c b/md5.c
index cc009b4a8dc8..2876a3105108 100644
--- a/md5.c
+++ b/md5.c
@@ -47,7 +47,7 @@
 #include "nettle-write.h"
 
 void
-md5_init(struct md5_ctx *ctx)
+md5_block_init(struct md5_state *state, struct block_ctx *bctx)
 {
   const uint32_t iv[_MD5_DIGEST_LENGTH] =
     {
@@ -56,9 +56,15 @@ md5_init(struct md5_ctx *ctx)
       0x98badcfe,
       0x10325476,
     };
-  memcpy(ctx-&gt;state, iv, sizeof(ctx-&gt;state));
-  ctx-&gt;count = 0;
-  ctx-&gt;index = 0;
+  memcpy(state-&gt;state, iv, sizeof(state-&gt;state));
+  state-&gt;count = 0;
+  bctx-&gt;index = 0;
+}
+
+void
+md5_init(struct md5_ctx *ctx)
+{
+  return md5_block_init(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block);
 }
 
 #define COMPRESS(ctx, data) (nettle_md5_compress((ctx)-&gt;state, (data)))
@@ -68,26 +74,44 @@ md5_update(struct md5_ctx *ctx,
 	   size_t length,
 	   const uint8_t *data)
 {
-  MD_UPDATE(ctx, length, data, COMPRESS, ctx-&gt;count++);
+  MD_BLOCK_UPDATE(&amp;ctx-&gt;state, &amp;ctx-&gt;block, MD5_BLOCK_SIZE, length, data, COMPRESS, ctx-&gt;state.count++);
 }
 
 void
-md5_digest(struct md5_ctx *ctx,
-	   size_t length,
-	   uint8_t *digest)
+md5_block_update(struct md5_state *state,
+		 struct block_ctx *bctx,
+		 size_t length,
+		 const uint8_t *data)
+{
+  MD_BLOCK_UPDATE(state, bctx, MD5_BLOCK_SIZE, length, data, COMPRESS, state-&gt;count++);
+}
+
+void
+md5_block_digest(struct md5_state *state,
+		 struct block_ctx *bctx,
+		 size_t length,
+		 uint8_t *digest)
 {
   uint64_t bit_count;
   
   assert(length &lt;= MD5_DIGEST_SIZE);
 
-  MD_PAD(ctx, 8, COMPRESS);
+  MD_BLOCK_PAD(state, bctx, MD5_BLOCK_SIZE, 8, COMPRESS);
 
   /* There are 512 = 2^9 bits in one block */
-  bit_count = (ctx-&gt;count &lt;&lt; 9) | (ctx-&gt;index &lt;&lt; 3);
+  bit_count = (state-&gt;count &lt;&lt; 9) | (bctx-&gt;index &lt;&lt; 3);
 
-  LE_WRITE_UINT64(ctx-&gt;block + (MD5_BLOCK_SIZE - 8), bit_count);
-  nettle_md5_compress(ctx-&gt;state, ctx-&gt;block);
+  LE_WRITE_UINT64(bctx-&gt;buffer + (MD5_BLOCK_SIZE - 8), bit_count);
+  nettle_md5_compress(state-&gt;state, bctx-&gt;buffer);
+
+  _nettle_write_le32(length, digest, state-&gt;state);
+  md5_block_init(state, bctx);
+}
 
-  _nettle_write_le32(length, digest, ctx-&gt;state);
-  md5_init(ctx);
+void
+md5_digest(struct md5_ctx *ctx,
+	   size_t length,
+	   uint8_t *digest)
+{
+  return md5_block_digest(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block, length, digest);
 }
diff --git a/md5.h b/md5.h
index e5ae228e8217..23738a8532c5 100644
--- a/md5.h
+++ b/md5.h
@@ -44,6 +44,9 @@ extern "C" {
 #define md5_init nettle_md5_init
 #define md5_update nettle_md5_update
 #define md5_digest nettle_md5_digest
+#define md5_block_init nettle_md5_block_init
+#define md5_block_update nettle_md5_block_update
+#define md5_block_digest nettle_md5_block_digest
 
 #define MD5_DIGEST_SIZE 16
 #define MD5_BLOCK_SIZE 64
@@ -53,12 +56,16 @@ extern "C" {
 /* Digest is kept internally as 4 32-bit words. */
 #define _MD5_DIGEST_LENGTH 4
 
-struct md5_ctx
+struct md5_state
 {
   uint32_t state[_MD5_DIGEST_LENGTH];
   uint64_t count;               /* Block count */
-  unsigned index;               /* Into buffer */
-  uint8_t block[MD5_BLOCK_SIZE]; /* Block buffer */
+};
+
+struct md5_ctx
+{
+  struct md5_state state;
+  BLOCK_CTX(MD5_BLOCK_SIZE);
 };
 
 void
@@ -74,6 +81,22 @@ md5_digest(struct md5_ctx *ctx,
 	   size_t length,
 	   uint8_t *digest);
 
+void
+md5_block_init(struct md5_state *state,
+	       struct block_ctx *bctx);
+
+void
+md5_block_update(struct md5_state *state,
+		 struct block_ctx *bctx,
+		 size_t length,
+		 const uint8_t *data);
+
+void
+md5_block_digest(struct md5_state *state,
+		 struct block_ctx *bctx,
+		 size_t length,
+		 uint8_t *digest);
+
 /* Internal compression function. STATE points to 4 uint32_t words,
    and DATA points to 64 bytes of input data, possibly unaligned. */
 void
diff --git a/nettle-meta.h b/nettle-meta.h
index f21dcd9b344d..770b1953ca5d 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -181,6 +181,8 @@ extern const struct nettle_hash nettle_sha3_256;
 extern const struct nettle_hash nettle_sha3_384;
 extern const struct nettle_hash nettle_sha3_512;
 
+extern const struct nettle_bctx_hash nettle_bctx_md5;
+
 struct nettle_aead
 {
   const char *name;
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702132703</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:27:03-0400</timestampReceived><subject>[PATCH 05/14] hmac: add interface for working with separate hash state and buffer</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 hmac.c | 62 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 hmac.h | 27 +++++++++++++++++++++++++
 2 files changed, 89 insertions(+)

diff --git a/hmac.c b/hmac.c
index 6ac5e11a0686..6b925ce6e147 100644
--- a/hmac.c
+++ b/hmac.c
@@ -115,3 +115,65 @@ hmac_digest(const void *outer, const void *inner, void *state,
 
   memcpy(state, inner, hash-&gt;context_size);
 }
+
+void
+hmac_block_set_key(void *outer, void *inner, void *state,
+		   struct block_ctx *bctx,
+		   const struct nettle_bctx_hash *hash,
+		   size_t key_length, const uint8_t *key)
+{
+  TMP_DECL(pad, uint8_t, NETTLE_MAX_HASH_BLOCK_SIZE);
+  TMP_ALLOC(pad, hash-&gt;block_size);
+
+  hash-&gt;block_init(outer, bctx);
+  hash-&gt;block_init(inner, bctx);
+
+  if (key_length &gt; hash-&gt;block_size)
+    {
+      /* Reduce key to the algorithm's hash size. Use the area pointed
+       * to by state for the temporary state. */
+
+      TMP_DECL(digest, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);
+      TMP_ALLOC(digest, hash-&gt;digest_size);
+
+      hash-&gt;block_init(state, bctx);
+      hash-&gt;block_update(state, bctx, key_length, key);
+      hash-&gt;block_digest(state, bctx, hash-&gt;digest_size, digest);
+
+      key = digest;
+      key_length = hash-&gt;digest_size;
+    }
+
+  assert(key_length &lt;= hash-&gt;block_size);
+
+  memset(pad, OPAD, hash-&gt;block_size);
+  memxor(pad, key, key_length);
+
+  hash-&gt;block_update(outer, bctx, hash-&gt;block_size, pad);
+
+  memset(pad, IPAD, hash-&gt;block_size);
+  memxor(pad, key, key_length);
+
+  hash-&gt;block_update(inner, bctx, hash-&gt;block_size, pad);
+
+  memcpy(state, inner, hash-&gt;state_size);
+}
+
+void
+hmac_block_digest(const void *outer, const void *inner, void *state,
+		  struct block_ctx *bctx,
+		  const struct nettle_bctx_hash *hash,
+		  size_t length, uint8_t *dst)
+{
+  TMP_DECL(digest, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);
+  TMP_ALLOC(digest, hash-&gt;digest_size);
+
+  hash-&gt;block_digest(state, bctx, hash-&gt;digest_size, digest);
+
+  memcpy(state, outer, hash-&gt;state_size);
+
+  hash-&gt;block_update(state, bctx, hash-&gt;digest_size, digest);
+  hash-&gt;block_digest(state, bctx, length, dst);
+
+  memcpy(state, inner, hash-&gt;state_size);
+}
diff --git a/hmac.h b/hmac.h
index 40a8e77aab6d..84ff4a56d93b 100644
--- a/hmac.h
+++ b/hmac.h
@@ -49,6 +49,8 @@ extern "C" {
 #define hmac_set_key nettle_hmac_set_key
 #define hmac_update nettle_hmac_update
 #define hmac_digest nettle_hmac_digest
+#define hmac_block_set_key nettle_hmac_block_set_key
+#define hmac_block_digest nettle_hmac_block_digest
 #define hmac_md5_set_key nettle_hmac_md5_set_key
 #define hmac_md5_update nettle_hmac_md5_update
 #define hmac_md5_digest nettle_hmac_md5_digest
@@ -86,6 +88,18 @@ hmac_digest(const void *outer, const void *inner, void *state,
 	    const struct nettle_hash *hash,
 	    size_t length, uint8_t *digest);
 
+void
+hmac_block_set_key(void *outer, void *inner, void *state,
+		   struct block_ctx *bctx,
+		   const struct nettle_bctx_hash *hash,
+		   size_t key_length, const uint8_t *key);
+
+void
+hmac_block_digest(const void *outer, const void *inner, void *state,
+		  struct block_ctx *bctx,
+		  const struct nettle_bctx_hash *hash,
+		  size_t length, uint8_t *digest);
+
 
 #define HMAC_CTX(type) \
 { type outer; type inner; type state; }
@@ -98,6 +112,19 @@ hmac_digest(const void *outer, const void *inner, void *state,
   hmac_digest( &amp;(ctx)-&gt;outer, &amp;(ctx)-&gt;inner, &amp;(ctx)-&gt;state,	\
                (hash), (length), (digest) )
 
+#define HMAC_BLOCK_CTX(type, block_size) \
+{ type outer; type inner; type state; BLOCK_CTX(block_size); }
+
+#define HMAC_BLOCK_SET_KEY(ctx, hash, length, key)		\
+  hmac_block_set_key( &amp;(ctx)-&gt;outer, &amp;(ctx)-&gt;inner, &amp;(ctx)-&gt;state, \
+		     (struct block_ctx *)&amp;(ctx)-&gt;block, \
+		     (hash), (length), (key) )
+
+#define HMAC_BLOCK_DIGEST(ctx, hash, length, digest)		\
+  hmac_block_digest( &amp;(ctx)-&gt;outer, &amp;(ctx)-&gt;inner, &amp;(ctx)-&gt;state, \
+		    (struct block_ctx *)&amp;(ctx)-&gt;block, \
+		    (hash), (length), (digest) )
+
 /* HMAC using specific hash functions */
 
 /* hmac-md5 */
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702132704</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:27:04-0400</timestampReceived><subject>[PATCH 06/14] hmac-md5: use new hmac and hash split state/buffer interface</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 hmac-md5.c | 6 +++---
 hmac.h     | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/hmac-md5.c b/hmac-md5.c
index a27e64f6f61b..910d8a508a11 100644
--- a/hmac-md5.c
+++ b/hmac-md5.c
@@ -41,19 +41,19 @@ void
 hmac_md5_set_key(struct hmac_md5_ctx *ctx,
 		 size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_md5, key_length, key);
+  HMAC_BLOCK_SET_KEY(ctx, &amp;nettle_bctx_md5, key_length, key);
 }
 
 void
 hmac_md5_update(struct hmac_md5_ctx *ctx,
 		size_t length, const uint8_t *data)
 {
-  md5_update(&amp;ctx-&gt;state, length, data);
+  md5_block_update(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block, length, data);
 }
 
 void
 hmac_md5_digest(struct hmac_md5_ctx *ctx,
 		size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_md5, length, digest);
+  HMAC_BLOCK_DIGEST(ctx, &amp;nettle_bctx_md5, length, digest);
 }
diff --git a/hmac.h b/hmac.h
index 84ff4a56d93b..20b9d8483b80 100644
--- a/hmac.h
+++ b/hmac.h
@@ -128,7 +128,7 @@ hmac_block_digest(const void *outer, const void *inner, void *state,
 /* HMAC using specific hash functions */
 
 /* hmac-md5 */
-struct hmac_md5_ctx HMAC_CTX(struct md5_ctx);
+struct hmac_md5_ctx HMAC_BLOCK_CTX(struct md5_state, MD5_BLOCK_SIZE);
 
 void
 hmac_md5_set_key(struct hmac_md5_ctx *ctx,
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702132705</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:27:05-0400</timestampReceived><subject>[PATCH 07/14] ripemd160: split context into hash state and byte buffer</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 nettle-meta.h    |  1 +
 ripemd160-meta.c |  3 +++
 ripemd160.c      | 50 ++++++++++++++++++++++++++++++++++++------------
 ripemd160.h      | 29 +++++++++++++++++++++++++---
 4 files changed, 68 insertions(+), 15 deletions(-)

diff --git a/nettle-meta.h b/nettle-meta.h
index 770b1953ca5d..79a9900cbdfa 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -182,6 +182,7 @@ extern const struct nettle_hash nettle_sha3_384;
 extern const struct nettle_hash nettle_sha3_512;
 
 extern const struct nettle_bctx_hash nettle_bctx_md5;
+extern const struct nettle_bctx_hash nettle_bctx_ripemd160;
 
 struct nettle_aead
 {
diff --git a/ripemd160-meta.c b/ripemd160-meta.c
index c1860b728599..bfa0b080767e 100644
--- a/ripemd160-meta.c
+++ b/ripemd160-meta.c
@@ -39,3 +39,6 @@
 
 const struct nettle_hash nettle_ripemd160
 = _NETTLE_HASH(ripemd160, RIPEMD160);
+
+const struct nettle_bctx_hash nettle_bctx_ripemd160
+= _NETTLE_BLOCK_HASH(ripemd160, RIPEMD160);
diff --git a/ripemd160.c b/ripemd160.c
index 56ffee33cd6d..ee59684bd834 100644
--- a/ripemd160.c
+++ b/ripemd160.c
@@ -156,7 +156,7 @@
  */
 
 void
-ripemd160_init(struct ripemd160_ctx *ctx)
+ripemd160_block_init(struct ripemd160_state *state, struct block_ctx *bctx)
 {
   static const uint32_t iv[_RIPEMD160_DIGEST_LENGTH] =
     {
@@ -166,9 +166,15 @@ ripemd160_init(struct ripemd160_ctx *ctx)
       0x10325476,
       0xC3D2E1F0,
     };
-  memcpy(ctx-&gt;state, iv, sizeof(ctx-&gt;state));
-  ctx-&gt;count = 0;
-  ctx-&gt;index = 0;
+  memcpy(state-&gt;state, iv, sizeof(state-&gt;state));
+  state-&gt;count = 0;
+  bctx-&gt;index = 0;
+}
+
+void
+ripemd160_init(struct ripemd160_ctx *ctx)
+{
+  return ripemd160_block_init(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block);
 }
 
 #define COMPRESS(ctx, data) (_nettle_ripemd160_compress((ctx)-&gt;state, (data)))
@@ -179,25 +185,45 @@ ripemd160_init(struct ripemd160_ctx *ctx)
 void
 ripemd160_update(struct ripemd160_ctx *ctx, size_t length, const uint8_t *data)
 {
-  MD_UPDATE(ctx, length, data, COMPRESS, ctx-&gt;count++);
+  MD_BLOCK_UPDATE(&amp;ctx-&gt;state, &amp;ctx-&gt;block, RIPEMD160_BLOCK_SIZE, length, data, \
COMPRESS, ctx-&gt;state.count++); +}
+
+void
+ripemd160_block_update(struct ripemd160_state *state,
+		       struct block_ctx *bctx,
+		       size_t length,
+		       const uint8_t *data)
+{
+  MD_BLOCK_UPDATE(state, bctx, RIPEMD160_BLOCK_SIZE, length, data, COMPRESS, \
state-&gt;count++);  }
 
 void
-ripemd160_digest(struct ripemd160_ctx *ctx, size_t length, uint8_t *digest)
+ripemd160_block_digest(struct ripemd160_state *state,
+		       struct block_ctx *bctx,
+		       size_t length,
+		       uint8_t *digest)
 {
   uint64_t bit_count;
 
   assert(length &lt;= RIPEMD160_DIGEST_SIZE);
 
-  MD_PAD(ctx, 8, COMPRESS);
+  MD_BLOCK_PAD(state, bctx, RIPEMD160_BLOCK_SIZE, 8, COMPRESS);
 
   /* There are 2^9 bits in one block */
-  bit_count = (ctx-&gt;count &lt;&lt; 9) | (ctx-&gt;index &lt;&lt; 3);
+  bit_count = (state-&gt;count &lt;&lt; 9) | (bctx-&gt;index &lt;&lt; 3);
 									\
   /* append the 64 bit count */
-  LE_WRITE_UINT64(ctx-&gt;block + 56, bit_count);
-  _nettle_ripemd160_compress(ctx-&gt;state, ctx-&gt;block);
+  LE_WRITE_UINT64(bctx-&gt;buffer + 56, bit_count);
+  _nettle_ripemd160_compress(state-&gt;state, bctx-&gt;buffer);
 
-  _nettle_write_le32(length, digest, ctx-&gt;state);
-  ripemd160_init(ctx);
+  _nettle_write_le32(length, digest, state-&gt;state);
+  ripemd160_block_init(state, bctx);
+}
+
+void
+ripemd160_digest(struct ripemd160_ctx *ctx,
+	   size_t length,
+	   uint8_t *digest)
+{
+  return ripemd160_block_digest(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block, \
length, digest);  }
diff --git a/ripemd160.h b/ripemd160.h
index 238c5ee7a44c..40671a29a5a6 100644
--- a/ripemd160.h
+++ b/ripemd160.h
@@ -44,6 +44,9 @@ extern "C" {
 #define ripemd160_init nettle_ripemd160_init
 #define ripemd160_update nettle_ripemd160_update
 #define ripemd160_digest nettle_ripemd160_digest
+#define ripemd160_block_init nettle_ripemd160_block_init
+#define ripemd160_block_update nettle_ripemd160_block_update
+#define ripemd160_block_digest nettle_ripemd160_block_digest
 
 /* RIPEMD160 */
 
@@ -55,12 +58,16 @@ extern "C" {
 /* Digest is kept internally as 5 32-bit words. */
 #define _RIPEMD160_DIGEST_LENGTH 5
 
-struct ripemd160_ctx
+struct ripemd160_state
 {
   uint32_t state[_RIPEMD160_DIGEST_LENGTH];
   uint64_t count;         /* 64-bit block count */
-  unsigned int index;
-  uint8_t block[RIPEMD160_BLOCK_SIZE];
+};
+
+struct ripemd160_ctx
+{
+  struct ripemd160_state state;
+  BLOCK_CTX(RIPEMD160_BLOCK_SIZE);
 };
 
 void
@@ -76,6 +83,22 @@ ripemd160_digest(struct ripemd160_ctx *ctx,
 		 size_t length,
 		 uint8_t *digest);
 
+void
+ripemd160_block_init(struct ripemd160_state *state,
+		     struct block_ctx *bctx);
+
+void
+ripemd160_block_update(struct ripemd160_state *state,
+		       struct block_ctx *bctx,
+		       size_t length,
+		       const uint8_t *data);
+
+void
+ripemd160_block_digest(struct ripemd160_state *state,
+		       struct block_ctx *bctx,
+		       size_t length,
+		       uint8_t *digest);
+
 #ifdef __cplusplus
 }
 #endif
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190702132706</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:27:06-0400</timestampReceived><subject>[PATCH 08/14] hmac-ripemd160: use new hmac and hash split state/buffer interface</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 hmac-ripemd160.c | 6 +++---
 hmac.h           | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/hmac-ripemd160.c b/hmac-ripemd160.c
index 24e2cbe7a578..fa4e6a09075c 100644
--- a/hmac-ripemd160.c
+++ b/hmac-ripemd160.c
@@ -41,19 +41,19 @@ void
 hmac_ripemd160_set_key(struct hmac_ripemd160_ctx *ctx,
 		       size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_ripemd160, key_length, key);
+  HMAC_BLOCK_SET_KEY(ctx, &amp;nettle_bctx_ripemd160, key_length, key);
 }
 
 void
 hmac_ripemd160_update(struct hmac_ripemd160_ctx *ctx,
 		      size_t length, const uint8_t *data)
 {
-  ripemd160_update(&amp;ctx-&gt;state, length, data);
+  ripemd160_block_update(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block, length, data);
 }
 
 void
 hmac_ripemd160_digest(struct hmac_ripemd160_ctx *ctx,
 		      size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_ripemd160, length, digest);
+  HMAC_BLOCK_DIGEST(ctx, &amp;nettle_bctx_ripemd160, length, digest);
 }
diff --git a/hmac.h b/hmac.h
index 20b9d8483b80..cf083cfb0c3c 100644
--- a/hmac.h
+++ b/hmac.h
@@ -144,7 +144,7 @@ hmac_md5_digest(struct hmac_md5_ctx *ctx,
 
 
 /* hmac-ripemd160 */
-struct hmac_ripemd160_ctx HMAC_CTX(struct ripemd160_ctx);
+struct hmac_ripemd160_ctx HMAC_BLOCK_CTX(struct ripemd160_state, RIPEMD160_BLOCK_SIZE);
 
 void
 hmac_ripemd160_set_key(struct hmac_ripemd160_ctx *ctx,
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702132707</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:27:07-0400</timestampReceived><subject>[PATCH 09/14] sha1: split context into hash state and byte buffer</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 nettle-meta.h |  1 +
 sha1-meta.c   |  3 +++
 sha1.c        | 56 ++++++++++++++++++++++++++++++++++++---------------
 sha1.h        | 29 +++++++++++++++++++++++---
 4 files changed, 70 insertions(+), 19 deletions(-)

diff --git a/nettle-meta.h b/nettle-meta.h
index 79a9900cbdfa..95aaaf0fcc8c 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -183,6 +183,7 @@ extern const struct nettle_hash nettle_sha3_512;
 
 extern const struct nettle_bctx_hash nettle_bctx_md5;
 extern const struct nettle_bctx_hash nettle_bctx_ripemd160;
+extern const struct nettle_bctx_hash nettle_bctx_sha1;
 
 struct nettle_aead
 {
diff --git a/sha1-meta.c b/sha1-meta.c
index dde990360a8f..def2704c40ee 100644
--- a/sha1-meta.c
+++ b/sha1-meta.c
@@ -39,3 +39,6 @@
 
 const struct nettle_hash nettle_sha1
 = _NETTLE_HASH(sha1, SHA1);
+
+const struct nettle_bctx_hash nettle_bctx_sha1
+= _NETTLE_BLOCK_HASH(sha1, SHA1);
diff --git a/sha1.c b/sha1.c
index af73096c9016..7dca34b71ef7 100644
--- a/sha1.c
+++ b/sha1.c
@@ -47,7 +47,7 @@
 
 /* Initialize the SHA values */
 void
-sha1_init(struct sha1_ctx *ctx)
+sha1_block_init(struct sha1_state *state, struct block_ctx *bctx)
 {
   /* FIXME: Put the buffer last in the struct, and arrange so that we
      can initialize with a single memcpy. */
@@ -61,11 +61,17 @@ sha1_init(struct sha1_ctx *ctx)
       0xC3D2E1F0L,
     };
 
-  memcpy(ctx-&gt;state, iv, sizeof(ctx-&gt;state));
-  ctx-&gt;count = 0;
-  
+  memcpy(state-&gt;state, iv, sizeof(state-&gt;state));
+  state-&gt;count = 0;
+
   /* Initialize buffer */
-  ctx-&gt;index = 0;
+  bctx-&gt;index = 0;
+}
+
+void
+sha1_init(struct sha1_ctx *ctx)
+{
+  return sha1_block_init(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block);
 }
 
 #define COMPRESS(ctx, data) (nettle_sha1_compress((ctx)-&gt;state, data))
@@ -74,27 +80,45 @@ void
 sha1_update(struct sha1_ctx *ctx,
 	    size_t length, const uint8_t *data)
 {
-  MD_UPDATE (ctx, length, data, COMPRESS, ctx-&gt;count++);
+  MD_BLOCK_UPDATE(&amp;ctx-&gt;state, &amp;ctx-&gt;block, SHA1_BLOCK_SIZE, length, data, COMPRESS, \
ctx-&gt;state.count++);  }
-	  
+
 void
-sha1_digest(struct sha1_ctx *ctx,
-	    size_t length,
-	    uint8_t *digest)
+sha1_block_update(struct sha1_state *state,
+		  struct block_ctx *bctx,
+		  size_t length,
+		  const uint8_t *data)
+{
+  MD_BLOCK_UPDATE(state, bctx, SHA1_BLOCK_SIZE, length, data, COMPRESS, \
state-&gt;count++); +}
+
+void
+sha1_block_digest(struct sha1_state *state,
+		  struct block_ctx *bctx,
+		  size_t length,
+		  uint8_t *digest)
 {
   uint64_t bit_count;
 
   assert(length &lt;= SHA1_DIGEST_SIZE);
 
-  MD_PAD(ctx, 8, COMPRESS);
+  MD_BLOCK_PAD(state, bctx, SHA1_BLOCK_SIZE, 8, COMPRESS);
 
   /* There are 512 = 2^9 bits in one block */
-  bit_count = (ctx-&gt;count &lt;&lt; 9) | (ctx-&gt;index &lt;&lt; 3);
+  bit_count = (state-&gt;count &lt;&lt; 9) | (bctx-&gt;index &lt;&lt; 3);
 
   /* append the 64 bit count */
-  WRITE_UINT64(ctx-&gt;block + (SHA1_BLOCK_SIZE - 8), bit_count);
-  nettle_sha1_compress(ctx-&gt;state, ctx-&gt;block);
+  WRITE_UINT64(bctx-&gt;buffer + (SHA1_BLOCK_SIZE - 8), bit_count);
+  nettle_sha1_compress(state-&gt;state, bctx-&gt;buffer);
+
+  _nettle_write_be32(length, digest, state-&gt;state);
+  sha1_block_init(state, bctx);
+}
 
-  _nettle_write_be32(length, digest, ctx-&gt;state);
-  sha1_init(ctx);
+void
+sha1_digest(struct sha1_ctx *ctx,
+	    size_t length,
+	    uint8_t *digest)
+{
+  return sha1_block_digest(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block, length, \
digest);  }
diff --git a/sha1.h b/sha1.h
index 0f4964f8f61c..d5f336eaab04 100644
--- a/sha1.h
+++ b/sha1.h
@@ -44,6 +44,9 @@ extern "C" {
 #define sha1_init nettle_sha1_init
 #define sha1_update nettle_sha1_update
 #define sha1_digest nettle_sha1_digest
+#define sha1_block_init nettle_sha1_block_init
+#define sha1_block_update nettle_sha1_block_update
+#define sha1_block_digest nettle_sha1_block_digest
 
 /* SHA1 */
 
@@ -55,12 +58,16 @@ extern "C" {
 /* Digest is kept internally as 5 32-bit words. */
 #define _SHA1_DIGEST_LENGTH 5
 
-struct sha1_ctx
+struct sha1_state
 {
   uint32_t state[_SHA1_DIGEST_LENGTH];    /* State variables */
   uint64_t count;                         /* 64-bit block count */
-  unsigned int index;                     /* index into buffer */
-  uint8_t block[SHA1_BLOCK_SIZE];         /* SHA1 data buffer */
+};
+
+struct sha1_ctx
+{
+  struct sha1_state state;
+  BLOCK_CTX(SHA1_BLOCK_SIZE);
 };
 
 void
@@ -76,6 +83,22 @@ sha1_digest(struct sha1_ctx *ctx,
 	    size_t length,
 	    uint8_t *digest);
 
+void
+sha1_block_init(struct sha1_state *state,
+		struct block_ctx *bctx);
+
+void
+sha1_block_update(struct sha1_state *state,
+		  struct block_ctx *bctx,
+		  size_t length,
+		  const uint8_t *data);
+
+void
+sha1_block_digest(struct sha1_state *state,
+		  struct block_ctx *bctx,
+		  size_t length,
+		  uint8_t *digest);
+
 /* Internal compression function. STATE points to 5 uint32_t words,
    and DATA points to 64 bytes of input data, possibly unaligned. */
 void
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190702132708</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:27:08-0400</timestampReceived><subject>[PATCH 10/14] hmac-sha1: use new hmac and hash split state/buffer interface</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 hmac-sha1.c | 6 +++---
 hmac.h      | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/hmac-sha1.c b/hmac-sha1.c
index 5e7188f92cf2..e968a51cd431 100644
--- a/hmac-sha1.c
+++ b/hmac-sha1.c
@@ -41,19 +41,19 @@ void
 hmac_sha1_set_key(struct hmac_sha1_ctx *ctx,
 		  size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_sha1, key_length, key);
+  HMAC_BLOCK_SET_KEY(ctx, &amp;nettle_bctx_sha1, key_length, key);
 }
 
 void
 hmac_sha1_update(struct hmac_sha1_ctx *ctx,
 		 size_t length, const uint8_t *data)
 {
-  sha1_update(&amp;ctx-&gt;state, length, data);
+  sha1_block_update(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block, length, data);
 }
 
 void
 hmac_sha1_digest(struct hmac_sha1_ctx *ctx,
 		 size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_sha1, length, digest);
+  HMAC_BLOCK_DIGEST(ctx, &amp;nettle_bctx_sha1, length, digest);
 }
diff --git a/hmac.h b/hmac.h
index cf083cfb0c3c..117de3262857 100644
--- a/hmac.h
+++ b/hmac.h
@@ -160,7 +160,7 @@ hmac_ripemd160_digest(struct hmac_ripemd160_ctx *ctx,
 
 
 /* hmac-sha1 */
-struct hmac_sha1_ctx HMAC_CTX(struct sha1_ctx);
+struct hmac_sha1_ctx HMAC_BLOCK_CTX(struct sha1_state, SHA1_BLOCK_SIZE);
 
 void
 hmac_sha1_set_key(struct hmac_sha1_ctx *ctx,
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190506145738</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-05-06 14:57:38-0400</timestampReceived><subject>Add check for ECC at point 0</subject><body>

While reviewing FIPS requirements for public key checks in Ephemeral
Diffie-Hellman key exchanges it came out that FIPS requires checks that
the public key point is not the (0, 0) coordinate and nettle is not
doing it (only checks that neither point is negative.

Add this check as we never want to allow this point in any case.

Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


["0001-Check-ECC-coordinates-are-not-zero.patch" (0001-Check-ECC-coordinates-are-not-zero.patch)]

From e64d88c0144c22148acb9a24a277c587f084240b Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Mon, 6 May 2019 10:47:49 -0400
Subject: [PATCH] Check ECC coordinates are not zero

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 ecc-point.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/ecc-point.c b/ecc-point.c
index 31e3115a..5c4b782a 100644
--- a/ecc-point.c
+++ b/ecc-point.c
@@ -57,12 +57,16 @@ ecc_point_set (struct ecc_point *p, const mpz_t x, const mpz_t y)
   mp_size_t size;  
   mpz_t lhs, rhs;
   mpz_t t;
+  int x_sgn, y_sgn;
   int res;
 
   size = p-&gt;ecc-&gt;p.size;
-  
-  if (mpz_sgn (x) &lt; 0 || mpz_limbs_cmp (x, p-&gt;ecc-&gt;p.m, size) &gt;= 0
-      || mpz_sgn (y) &lt; 0 || mpz_limbs_cmp (y, p-&gt;ecc-&gt;p.m, size) &gt;= 0)
+  x_sgn = mpz_sgn (x);
+  y_sgn = mpz_sgn (y);
+
+  if ((x_sgn == 0 &amp;&amp; y_sgn == 0) ||
+      x_sgn &lt; 0 || mpz_limbs_cmp (x, p-&gt;ecc-&gt;p.m, size) &gt;= 0
+      || y_sgn &lt; 0 || mpz_limbs_cmp (y, p-&gt;ecc-&gt;p.m, size) &gt;= 0)
     return 0;
 
   mpz_init (lhs);
-- 
2.20.1


[Attachment #4 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190511080025</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-05-11 08:00:25-0400</timestampReceived><subject>Re: Add check for ECC at point 0</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; While reviewing FIPS requirements for public key checks in Ephemeral
&gt; Diffie-Hellman key exchanges it came out that FIPS requires checks that
&gt; the public key point is not the (0, 0) coordinate and nettle is not
&gt; doing it (only checks that neither point is negative.

ecc_point_set also checks that the point is on the curve, i.e.,
satisfies the curve equation. That should rule out (0, 0), except if we
have some curve with constant term b == 0, which I don't think makes
sense.

Not sure how FIPS requirements are formulated, but maybe it would be
better to add a test case to check that ecc_point_set rejects (0,0) ?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702123855</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 12:38:55-0400</timestampReceived><subject>[PATCH 1/4] Move MAC testing code to generic place from cmac-test</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 testsuite/cmac-test.c | 100 +++++++++++-------------------------------
 testsuite/testutils.c |  64 +++++++++++++++++++++++++++
 testsuite/testutils.h |   6 +++
 3 files changed, 96 insertions(+), 74 deletions(-)

diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
index 31662d1b6c1b..b1d4aa30dfbe 100644
--- a/testsuite/cmac-test.c
+++ b/testsuite/cmac-test.c
@@ -2,83 +2,35 @@
 #include "nettle-internal.h"
 #include "cmac.h"
 
+const struct nettle_mac nettle_cmac_aes128 =
+{
+  "CMAC-AES128",
+  sizeof(struct cmac_aes128_ctx),
+  CMAC128_DIGEST_SIZE,
+  AES128_KEY_SIZE,
+
+  (nettle_set_key_func*) cmac_aes128_set_key,
+  (nettle_hash_update_func*) cmac_aes128_update,
+  (nettle_hash_digest_func*) cmac_aes128_digest
+};
+
+const struct nettle_mac nettle_cmac_aes256 =
+{
+  "CMAC-AES256",
+  sizeof(struct cmac_aes256_ctx),
+  CMAC128_DIGEST_SIZE,
+  AES256_KEY_SIZE,
+
+  (nettle_set_key_func*) cmac_aes256_set_key,
+  (nettle_hash_update_func*) cmac_aes256_update,
+  (nettle_hash_digest_func*) cmac_aes256_digest
+};
+
 #define test_cmac_aes128(key, msg, ref)					\
-  test_cmac_hash ((nettle_set_key_func*) cmac_aes128_set_key,		\
-		  (nettle_hash_update_func*) cmac_aes128_update,	\
-		  (nettle_hash_digest_func*) cmac_aes128_digest,	\
-		  sizeof(struct cmac_aes128_ctx),			\
-		  key, msg, ref)
+  test_mac(&amp;nettle_cmac_aes128, key, msg, ref)
 
 #define test_cmac_aes256(key, msg, ref)					\
-  test_cmac_hash ((nettle_set_key_func*) cmac_aes256_set_key,		\
-		  (nettle_hash_update_func*) cmac_aes256_update,	\
-		  (nettle_hash_digest_func*) cmac_aes256_digest,	\
-		  sizeof(struct cmac_aes256_ctx),			\
-		  key, msg, ref)
-
-static void
-test_cmac_hash (nettle_set_key_func *set_key,
-		nettle_hash_update_func *update,
-		nettle_hash_digest_func *digest, size_t ctx_size,
-		const struct tstring *key, const struct tstring *msg,
-		const struct tstring *ref)
-{
-  void *ctx;
-  uint8_t hash[16];
-  unsigned i;
-
-  ctx = xalloc(ctx_size);
-
-  ASSERT (ref-&gt;length == sizeof(hash));
-  ASSERT (key-&gt;length == 16 || key-&gt;length == 32);
-  set_key (ctx, key-&gt;data);
-  update (ctx, msg-&gt;length, msg-&gt;data);
-  digest (ctx, sizeof(hash), hash);
-  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
-    {
-      fprintf (stderr, "cmac_hash failed, msg: ");
-      print_hex (msg-&gt;length, msg-&gt;data);
-      fprintf(stderr, "Output:");
-      print_hex (16, hash);
-      fprintf(stderr, "Expected:");
-      tstring_print_hex(ref);
-      fprintf(stderr, "\n");
-      FAIL();
-    }
-
-  /* attempt to re-use the structure */
-  update (ctx, msg-&gt;length, msg-&gt;data);
-  digest (ctx, sizeof(hash), hash);
-  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
-    {
-      fprintf (stderr, "cmac_hash failed on re-use, msg: ");
-      print_hex (msg-&gt;length, msg-&gt;data);
-      fprintf(stderr, "Output:");
-      print_hex (16, hash);
-      fprintf(stderr, "Expected:");
-      tstring_print_hex(ref);
-      fprintf(stderr, "\n");
-      FAIL();
-    }
-
-  /* attempt byte-by-byte hashing */
-  set_key (ctx, key-&gt;data);
-  for (i=0;i&lt;msg-&gt;length;i++)
-    update (ctx, 1, msg-&gt;data+i);
-  digest (ctx, sizeof(hash), hash);
-  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
-    {
-      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
-      print_hex (msg-&gt;length, msg-&gt;data);
-      fprintf(stderr, "Output:");
-      print_hex (16, hash);
-      fprintf(stderr, "Expected:");
-      tstring_print_hex(ref);
-      fprintf(stderr, "\n");
-      FAIL();
-    }
-  free (ctx);
-}
+  test_mac(&amp;nettle_cmac_aes256, key, msg, ref)
 
 void
 test_main(void)
diff --git a/testsuite/testutils.c b/testsuite/testutils.c
index 337e4c4c7cd1..2a19c0ac8205 100644
--- a/testsuite/testutils.c
+++ b/testsuite/testutils.c
@@ -924,6 +924,70 @@ test_hash_large(const struct nettle_hash *hash,
   free(data);
 }
 
+void
+test_mac(const struct nettle_mac *mac,
+	 const struct tstring *key,
+	 const struct tstring *msg,
+	 const struct tstring *digest)
+{
+  void *ctx = xalloc(mac-&gt;context_size);
+  uint8_t *hash = xalloc(mac-&gt;digest_size);
+  unsigned i;
+
+
+  ASSERT (digest-&gt;length == mac-&gt;digest_size);
+  ASSERT (key-&gt;length == mac-&gt;key_size);
+  mac-&gt;set_key (ctx, key-&gt;data);
+  mac-&gt;update (ctx, msg-&gt;length, msg-&gt;data);
+  mac-&gt;digest (ctx, digest-&gt;length, hash);
+
+  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
+    {
+      fprintf (stderr, "test_mac failed, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (mac-&gt;digest_size, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(digest);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt to re-use the structure */
+  mac-&gt;update (ctx, msg-&gt;length, msg-&gt;data);
+  mac-&gt;digest (ctx, digest-&gt;length, hash);
+  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
+    {
+      fprintf (stderr, "test_mac: failed on re-use, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (mac-&gt;digest_size, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(digest);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt byte-by-byte hashing */
+  mac-&gt;set_key (ctx, key-&gt;data);
+  for (i=0;i&lt;msg-&gt;length;i++)
+    mac-&gt;update (ctx, 1, msg-&gt;data+i);
+  mac-&gt;digest (ctx, digest-&gt;length, hash);
+  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
+    {
+      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(digest);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  free (ctx);
+  free (hash);
+}
+
 void
 test_armor(const struct nettle_armor *armor,
            size_t data_length,
diff --git a/testsuite/testutils.h b/testsuite/testutils.h
index ded57db6ab4f..f4ea38da9deb 100644
--- a/testsuite/testutils.h
+++ b/testsuite/testutils.h
@@ -170,6 +170,12 @@ test_hash_large(const struct nettle_hash *hash,
 		uint8_t c,
 		const struct tstring *digest);
 
+void
+test_mac(const struct nettle_mac *mac,
+	 const struct tstring *key,
+	 const struct tstring *msg,
+	 const struct tstring *digest);
+
 void
 test_armor(const struct nettle_armor *armor,
            size_t data_length,
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702123856</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 12:38:56-0400</timestampReceived><subject>[PATCH 2/4] cmac: add 64-bit mode CMAC</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 cmac.c         | 125 ++++++++++++++++++++++++++++++++++++++++++++++++-
 cmac.h         |  69 +++++++++++++++++++++++++++
 nettle-types.h |   7 +++
 3 files changed, 200 insertions(+), 1 deletion(-)

diff --git a/cmac.c b/cmac.c
index c5a59b18e572..e93e26947b19 100644
--- a/cmac.c
+++ b/cmac.c
@@ -1,9 +1,10 @@
 /*
-   AES-CMAC-128 (rfc 4493)
+   AES-CMAC-128 (rfc 4493) / CMAC-64
    Copyright (C) Stefan Metzmacher 2012
    Copyright (C) Jeremy Allison 2012
    Copyright (C) Michael Adam 2012
    Copyright (C) 2017, Red Hat Inc.
+   Copyright (C) 2019, Dmitry Eremin-Solenikov
 
    This file is part of GNU Nettle.
 
@@ -56,6 +57,15 @@ block_mulx(union nettle_block16 *dst,
   dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
   dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) ^ (0x87 &amp; -carry);
 }
+
+static void
+block_mulx8(union nettle_block8 *dst,
+	    const union nettle_block8 *src)
+{
+  uint64_t carry = src-&gt;u64 &gt;&gt; 63;
+
+  dst-&gt;u64 = (src-&gt;u64 &lt;&lt; 1) ^ (0x1b &amp; -carry);
+}
 #else /* !WORDS_BIGENDIAN */
 #define LE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
                      (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
@@ -67,6 +77,15 @@ block_mulx(union nettle_block16 *dst,
   dst-&gt;u64[0] = LE_SHIFT(src-&gt;u64[0]) | ((src-&gt;u64[1] &amp; 0x80) &lt;&lt; 49);
   dst-&gt;u64[1] = LE_SHIFT(src-&gt;u64[1]) ^ (0x8700000000000000 &amp; -carry);
 }
+
+static void
+block_mulx8(union nettle_block8 *dst,
+	   const union nettle_block8 *src)
+{
+  uint64_t carry = (src-&gt;u64 &amp; 0x80) &gt;&gt; 7;
+
+  dst-&gt;u64 = LE_SHIFT(src-&gt;u64) ^ (0x1b00000000000000 &amp; -carry);
+}
 #endif /* !WORDS_BIGENDIAN */
 
 void
@@ -173,3 +192,107 @@ cmac128_digest(struct cmac128_ctx *ctx, const struct cmac128_key *key,
   /* reset state for re-use */
   cmac128_init(ctx);
 }
+
+void
+cmac64_set_key(struct cmac64_key *key, const void *cipher,
+	       nettle_cipher_func *encrypt)
+{
+  static const union nettle_block8 zero_block;
+  union nettle_block8 L;
+
+  /* step 1 - generate subkeys k1 and k2 */
+  encrypt(cipher, 8, L.b, zero_block.b);
+
+  block_mulx8(&amp;key-&gt;K1, &amp;L);
+  block_mulx8(&amp;key-&gt;K2, &amp;key-&gt;K1);
+}
+
+void
+cmac64_init(struct cmac64_ctx *ctx)
+{
+  memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
+  ctx-&gt;index = 0;
+}
+
+void
+cmac64_update(struct cmac64_ctx *ctx, const void *cipher,
+	      nettle_cipher_func *encrypt,
+	      size_t msg_len, const uint8_t *msg)
+{
+  union nettle_block16 Y;
+  /*
+   * check if we expand the block
+   */
+  if (ctx-&gt;index &lt; 8)
+    {
+      size_t len = MIN(8 - ctx-&gt;index, msg_len);
+      memcpy(&amp;ctx-&gt;block.b[ctx-&gt;index], msg, len);
+      msg += len;
+      msg_len -= len;
+      ctx-&gt;index += len;
+    }
+
+  if (msg_len == 0) {
+    /* if it is still the last block, we are done */
+    return;
+  }
+
+  /*
+   * now checksum everything but the last block
+   */
+  memxor3(Y.b, ctx-&gt;X.b, ctx-&gt;block.b, 8);
+  encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
+
+  while (msg_len &gt; 8)
+    {
+      memxor3(Y.b, ctx-&gt;X.b, msg, 8);
+      encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
+      msg += 8;
+      msg_len -= 8;
+    }
+
+  /*
+   * copy the last block, it will be processed in
+   * cmac64_digest().
+   */
+  memcpy(ctx-&gt;block.b, msg, msg_len);
+  ctx-&gt;index = msg_len;
+}
+
+void
+cmac64_digest(struct cmac64_ctx *ctx, const struct cmac64_key *key,
+	      const void *cipher, nettle_cipher_func *encrypt,
+	      unsigned length, uint8_t *dst)
+{
+  union nettle_block8 Y;
+
+  memset(ctx-&gt;block.b+ctx-&gt;index, 0, sizeof(ctx-&gt;block.b)-ctx-&gt;index);
+
+  /* re-use ctx-&gt;block for memxor output */
+  if (ctx-&gt;index &lt; 8)
+    {
+      ctx-&gt;block.b[ctx-&gt;index] = 0x80;
+      memxor(ctx-&gt;block.b, key-&gt;K2.b, 8);
+    }
+  else
+    {
+      memxor(ctx-&gt;block.b, key-&gt;K1.b, 8);
+    }
+
+  memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 8);
+
+  assert(length &lt;= 8);
+  if (length == 8)
+    {
+      encrypt(cipher, 8, dst, Y.b);
+    }
+  else
+    {
+      encrypt(cipher, 8, ctx-&gt;block.b, Y.b);
+      memcpy(dst, ctx-&gt;block.b, length);
+    }
+
+  /* reset state for re-use */
+  memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
+  ctx-&gt;index = 0;
+}
diff --git a/cmac.h b/cmac.h
index 3c5b7bea3e55..0cf9462d2120 100644
--- a/cmac.h
+++ b/cmac.h
@@ -44,6 +44,7 @@ extern "C" {
 #endif
 
 #define CMAC128_DIGEST_SIZE 16
+#define CMAC64_DIGEST_SIZE 8
 
 #define cmac128_set_key nettle_cmac128_set_key
 #define cmac128_init nettle_cmac128_init
@@ -56,6 +57,11 @@ extern "C" {
 #define cmac_aes256_update nettle_cmac_aes256_update
 #define cmac_aes256_digest nettle_cmac_aes256_digest
 
+#define cmac64_set_key nettle_cmac64_set_key
+#define cmac64_init nettle_cmac64_init
+#define cmac64_update nettle_cmac64_update
+#define cmac64_digest nettle_cmac64_digest
+
 struct cmac128_key
 {
   union nettle_block16 K1;
@@ -72,6 +78,22 @@ struct cmac128_ctx
   size_t index;
 };
 
+struct cmac64_key
+{
+  union nettle_block8 K1;
+  union nettle_block8 K2;
+};
+
+struct cmac64_ctx
+{
+  /* MAC state */
+  union nettle_block8 X;
+
+  /* Block buffer */
+  union nettle_block8 block;
+  size_t index;
+};
+
 void
 cmac128_set_key(struct cmac128_key *key, const void *cipher,
 		nettle_cipher_func *encrypt);
@@ -118,6 +140,53 @@ cmac128_digest(struct cmac128_ctx *ctx, const struct cmac128_key *key,
 		      (nettle_cipher_func *) (encrypt),		\
 		      (length), (digest)))
 
+void
+cmac64_set_key(struct cmac64_key *key, const void *cipher,
+		nettle_cipher_func *encrypt);
+
+void
+cmac64_init(struct cmac64_ctx *ctx);
+
+void
+cmac64_update(struct cmac64_ctx *ctx, const void *cipher,
+	       nettle_cipher_func *encrypt,
+	       size_t msg_len, const uint8_t *msg);
+
+void
+cmac64_digest(struct cmac64_ctx *ctx, const struct cmac64_key *key,
+	       const void *cipher, nettle_cipher_func *encrypt,
+	       unsigned length, uint8_t *digest);
+
+
+#define CMAC64_CTX(type) \
+  { struct cmac64_key key; struct cmac64_ctx ctx; type cipher; }
+
+/* NOTE: Avoid using NULL, as we don't include anything defining it. */
+#define CMAC64_SET_KEY(self, set_key, encrypt, cmac_key)	\
+  do {								\
+    (set_key)(&amp;(self)-&gt;cipher, (cmac_key));			\
+    if (0) (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,		\
+		     (uint8_t *) 0, (const uint8_t *) 0);	\
+    cmac64_set_key(&amp;(self)-&gt;key, &amp;(self)-&gt;cipher,		\
+		    (nettle_cipher_func *) (encrypt));		\
+    cmac64_init(&amp;(self)-&gt;ctx);					\
+  } while (0)
+
+#define CMAC64_UPDATE(self, encrypt, length, src)		\
+  (0 ? (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,			\
+		 (uint8_t *) 0, (const uint8_t *) 0)		\
+     : cmac64_update(&amp;(self)-&gt;ctx, &amp;(self)-&gt;cipher,		\
+		      (nettle_cipher_func *)encrypt,		\
+		      (length), (src)))
+
+#define CMAC64_DIGEST(self, encrypt, length, digest)		\
+  (0 ? (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,			\
+		 (uint8_t *) 0, (const uint8_t *) 0)		\
+     : cmac64_digest(&amp;(self)-&gt;ctx, &amp;(self)-&gt;key,		\
+		      &amp;(self)-&gt;cipher,				\
+		      (nettle_cipher_func *) (encrypt),		\
+		      (length), (digest)))
+
 struct cmac_aes128_ctx CMAC128_CTX(struct aes128_ctx);
 
 void
diff --git a/nettle-types.h b/nettle-types.h
index 87292ac69730..e06c85c48f8c 100644
--- a/nettle-types.h
+++ b/nettle-types.h
@@ -65,6 +65,13 @@ union nettle_block16
   uint64_t u64[2];
 };
 
+union nettle_block8
+{
+  uint8_t b[8];
+  unsigned long w[8 / sizeof(unsigned long)];
+  uint64_t u64;
+};
+
 /* Randomness. Used by key generation and dsa signature creation. */
 typedef void nettle_random_func(void *ctx,
 				size_t length, uint8_t *dst);
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702211531</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-02 21:15:31-0400</timestampReceived><subject>Re: [PATCH 2/4] cmac: add 64-bit mode CMAC</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; +union nettle_block8
&gt; +{
&gt; +  uint8_t b[8];
&gt; +  unsigned long w[8 / sizeof(unsigned long)];
&gt; +  uint64_t u64;
&gt; +};

The "unsigned long w" seems unneeded (in nettle_block16, it could
also be retired; it's from a time when Nettle didn't use uint64_t).

Maybe one could do without this union and simply use uint64_t, but then
one would need some casts to (uint8_t *). So a union may be clearer.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190513124438</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-05-13 12:44:38-0400</timestampReceived><subject>Re: Add check for ECC at point 0</subject><body>

On Sat, 2019-05-11 at 10:00 +0200, Niels Möller wrote:
&gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; 
&gt; &gt; While reviewing FIPS requirements for public key checks in Ephemeral
&gt; &gt; Diffie-Hellman key exchanges it came out that FIPS requires checks that
&gt; &gt; the public key point is not the (0, 0) coordinate and nettle is not
&gt; &gt; doing it (only checks that neither point is negative.
&gt; 
&gt; ecc_point_set also checks that the point is on the curve, i.e.,
&gt; satisfies the curve equation. That should rule out (0, 0), except if we
&gt; have some curve with constant term b == 0, which I don't think makes
&gt; sense.

Ah you are right the later check would catch it.
I was just following the checks FIPS explicitly requires in order and
didn't think about that ...

&gt; Not sure how FIPS requirements are formulated, but maybe it would be
&gt; better to add a test case to check that ecc_point_set rejects (0,0) ?

Yes, I will drop my patch and add a test case.

Simo. 

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190403070004</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2019-04-03 07:00:04-0400</timestampReceived><subject>SIV-CMAC</subject><body>

This patch adds the SIV-CMAC algorithm to nettle (an update of the
previous attempt). It is an atypical cipher which fits into the
encrypt_message interface.

regards,
Nikos


["0001-Added-support-for-AES_SIV_CMAC_256-and-AES_SIV_CMAC_.patch" (0001-Added-support-for-AES_SIV_CMAC_256-and-AES_SIV_CMAC_.patch)]

From f83c8ae6fcb40f2e7dd65309050a11d7f1ee991c Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Sat, 20 Jan 2018 10:36:05 +0100
Subject: [PATCH] Added support for AES_SIV_CMAC_256 and AES_SIV_CMAC_512

This AEAD algorithm provides a way to make nonce-reuse a not critical
issue. That is particular useful to stateless servers that cannot ensure
that the nonce will not repeat. This cipher is used by
draft-ietf-ntp-using-nts-for-ntp-17.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 Makefile.in                |   4 +-
 cmac-internal.h            |  54 ++++++
 cmac.c                     |  15 +-
 nettle-internal.h          |   2 +
 nettle-types.h             |  15 ++
 nettle.texinfo             |  82 ++++++++-
 siv-aes128-cmac.c          |  79 +++++++++
 siv-aes256-cmac.c          |  79 +++++++++
 siv-cmac.c                 | 194 ++++++++++++++++++++++
 siv-cmac.h                 | 139 ++++++++++++++++
 testsuite/.gitignore       |   2 +
 testsuite/.test-rules.make |   3 +
 testsuite/Makefile.in      |   2 +-
 testsuite/siv-test.c       | 332 +++++++++++++++++++++++++++++++++++++
 14 files changed, 991 insertions(+), 11 deletions(-)
 create mode 100644 cmac-internal.h
 create mode 100644 siv-aes128-cmac.c
 create mode 100644 siv-aes256-cmac.c
 create mode 100644 siv-cmac.c
 create mode 100644 siv-cmac.h
 create mode 100644 testsuite/siv-test.c

diff --git a/Makefile.in b/Makefile.in
index 440de9f7..90ee61d7 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -89,6 +89,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 camellia256-meta.c \
 		 cast128.c cast128-meta.c cbc.c \
 		 ccm.c ccm-aes128.c ccm-aes192.c ccm-aes256.c cfb.c \
+		 siv-cmac.c siv-aes128-cmac.c siv-aes256-cmac.c \
 		 cnd-memcpy.c \
 		 chacha-crypt.c chacha-core-internal.c \
 		 chacha-poly1305.c chacha-poly1305-meta.c \
@@ -198,7 +199,8 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  gcm.h gosthash94.h hmac.h \
 	  knuth-lfib.h hkdf.h \
 	  macros.h \
-	  cmac.h \
+	  cmac.h cmac-internal.h \
+	  siv-cmac.h siv-cmac-internal.h \
 	  md2.h md4.h \
 	  md5.h md5-compat.h \
 	  memops.h memxor.h \
diff --git a/cmac-internal.h b/cmac-internal.h
new file mode 100644
index 00000000..789588e6
--- /dev/null
+++ b/cmac-internal.h
@@ -0,0 +1,54 @@
+/* cmac.h
+
+   CMAC mode internal functions
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   Contributed by Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_CMAC_INTERNAL_H_INCLUDED
+#define NETTLE_CMAC_INTERNAL_H_INCLUDED
+
+#include "cmac.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define _cmac128_block_mulx _nettle_cmac128_block_mulx
+
+void _cmac128_block_mulx(union nettle_block16 *out,
+			 const union nettle_block16 *in);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CMAC_INTERNAL_H_INCLUDED */
diff --git a/cmac.c b/cmac.c
index ed3b5eb8..7ee8324c 100644
--- a/cmac.c
+++ b/cmac.c
@@ -44,13 +44,13 @@
 
 #include "memxor.h"
 #include "nettle-internal.h"
+#include "cmac-internal.h"
 #include "macros.h"
 
 /* shift one and XOR with 0x87. */
 #if WORDS_BIGENDIAN
-static void
-block_mulx(union nettle_block16 *dst,
-	   const union nettle_block16 *src)
+void _cmac128_block_mulx(union nettle_block16 *dst,
+			 const union nettle_block16 *src)
 {
   uint64_t carry = src-&gt;u64[0] &gt;&gt; 63;
   dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
@@ -59,9 +59,8 @@ block_mulx(union nettle_block16 *dst,
 #else /* !WORDS_BIGENDIAN */
 #define LE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
                      (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
-static void
-block_mulx(union nettle_block16 *dst,
-	   const union nettle_block16 *src)
+void _cmac128_block_mulx(union nettle_block16 *dst,
+			 const union nettle_block16 *src)
 {
   uint64_t carry = (src-&gt;u64[0] &amp; 0x80) &gt;&gt; 7;
   dst-&gt;u64[0] = LE_SHIFT(src-&gt;u64[0]) | ((src-&gt;u64[1] &amp; 0x80) &lt;&lt; 49);
@@ -83,8 +82,8 @@ cmac128_set_key(struct cmac128_ctx *ctx, const void *cipher,
   /* step 1 - generate subkeys k1 and k2 */
   encrypt(cipher, 16, L-&gt;b, const_zero);
 
-  block_mulx(&amp;ctx-&gt;K1, L);
-  block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
+  _cmac128_block_mulx(&amp;ctx-&gt;K1, L);
+  _cmac128_block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
 }
 
 #define MIN(x,y) ((x)&lt;(y)?(x):(y))
diff --git a/nettle-internal.h b/nettle-internal.h
index dc379f1f..2937a710 100644
--- a/nettle-internal.h
+++ b/nettle-internal.h
@@ -78,6 +78,8 @@
 #define NETTLE_MAX_HASH_CONTEXT_SIZE (sizeof(struct sha3_224_ctx))
 #define NETTLE_MAX_SEXP_ASSOC 17
 #define NETTLE_MAX_CIPHER_BLOCK_SIZE 32
+/* maximum context size of 128-bit block ciphers */
+#define NETTLE_MAX_CIPHER16_CONTEXT_SIZE (sizeof(struct aes256_ctx))
 
 /* Doesn't quite fit with the other algorithms, because of the weak
  * keys. Weak keys are not reported, the functions will simply crash
diff --git a/nettle-types.h b/nettle-types.h
index 87292ac6..8f5a69af 100644
--- a/nettle-types.h
+++ b/nettle-types.h
@@ -78,6 +78,21 @@ typedef void *nettle_realloc_func(void *ctx, void *p, size_t \
length);  /* Ciphers */
 typedef void nettle_set_key_func(void *ctx, const uint8_t *key);
 
+/* AEAD ciphers */
+typedef void
+nettle_encrypt_message(void *ctx,
+		       size_t nlength, const uint8_t *nonce,
+		       size_t alength, const uint8_t *adata,
+		       size_t tlength,
+		       size_t clength, uint8_t *dst, const uint8_t *src);
+
+typedef int
+nettle_decrypt_message(void *ctx,
+		       size_t nlength, const uint8_t *nonce,
+		       size_t alength, const uint8_t *adata,
+		       size_t tlength,
+		       size_t mlength, uint8_t *dst, const uint8_t *src);
+
 /* For block ciphers, const context. */
 typedef void nettle_cipher_func(const void *ctx,
 				size_t length, uint8_t *dst,
diff --git a/nettle.texinfo b/nettle.texinfo
index 596c7098..db3e8cfe 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -97,6 +97,7 @@ Cipher modes
 * CFB and CFB8::
 * GCM::                         
 * CCM::                         
+* SIV-CMAC::
 
 Keyed Hash Functions
 
@@ -2565,6 +2566,7 @@ more adventurous alternative, in particular if performance is \
                important.
 * GCM::                         
 * CCM::                         
 * ChaCha-Poly1305::
+* SIV-CMAC::
 * nettle_aead abstraction::
 @end menu
 
@@ -3212,7 +3214,7 @@ These are identical to @code{ccm_encrypt_message} and \
@code{ccm_decrypt_message}  except that @var{cipher} and @var{f} are replaced with a \
context structure.  @end deftypefun
 
-@node ChaCha-Poly1305, nettle_aead abstraction, CCM, Authenticated encryption
+@node ChaCha-Poly1305, SIV-CMAC, CCM, Authenticated encryption
 @comment  node-name,  next,  previous,  up
 @subsection ChaCha-Poly1305
 
@@ -3295,6 +3297,84 @@ smaller than @code{CHACHA_POLY1305_DIGEST_SIZE}, only the \
first  @var{length} octets of the digest are written.
 @end deftypefun
 
+@node SIV-CMAC, nettle_aead abstraction, ChaCha-Poly1305, Authenticated encryption
+@comment  node-name,  next,  previous,  up
+@subsection Counter with CBC-MAC mode
+
+@cindex SIV mode
+@cindex SIV-CMAC mode
+
+@acronym{SIV-CMAC} mode is a combination of counter mode with message
+authentication based on @acronym{CMAC}. Unlike other counter @acronym{AEAD}
+modes, it provides protection against accidental nonce misuse, making it
+a good choice for stateless-servers that cannot ensure nonce uniqueness.
+It is constructed on top of a block cipher which must have a block size of
+128 bits. Nettle's support for @acronym{SIV-CMAC} consists of
+a message encryption and authentication interface,
+for @acronym{SIV-CMAC} using AES as the underlying
+block cipher. These interfaces are defined in @file{&lt;nettle/siv-cmac.h&gt;}.
+
+Unlike other @acronym{AEAD} mode in @acronym{SIV-CMAC} the initialization
+vector serves as the tag. That means that in the generated ciphertext
+the tag precedes the ciphertext.
+
+@subsubsection General interface
+
+@defvr Constant SIV_BLOCK_SIZE
+@acronym{SIV-CMAC}'s block size, 16.
+@end defvr
+
+@defvr Constant SIV_DIGEST_SIZE
+Size of the @acronym{SIV-CMAC} digest or initialization vector, 16.
+@end defvr
+
+@defvr Constant SIV_MIN_NONCE_SIZE
+The the minimumsizes for an @acronym{SIV-CMAC} nonce, 0
+@end defvr
+
+@subsubsection @acronym{SIV-CMAC}-@acronym{AES} interface
+
+The @acronym{AES} @acronym{SIV-CMAC} functions provide an API for using
+@acronym{SIV-CMAC} mode with the @acronym{AES} block ciphers. The parameters
+all have the same meaning as the general and message interfaces, except
+that the @var{cipher}, @var{f}, and @var{ctx} parameters are replaced
+with an @acronym{AES} context structure, and a set-key function must be
+called before using any of the other functions in this interface.
+
+@deftp {Context struct} {struct siv_aes128_cmac_ctx}
+Holds state corresponding to a particular message encrypted using the
+AES-128 block cipher.
+@end deftp
+
+@deftp {Context struct} {struct siv_aes256_cmac_ctx}
+Holds state corresponding to a particular message encrypted using the
+AES-256 block cipher.
+@end deftp
+
+@deftypefun void siv_aes128_cmac_set_key (struct siv_aes128_cmac_ctx *@var{ctx}, \
const uint8_t *@var{key}) +@deftypefunx void siv_aes256_cmac_set_key (struct \
siv_aes256_cmac_ctx *@var{ctx}, const uint8_t *@var{key}) +Initializes the encryption \
key for the AES block cipher. One of these +functions must be called before any of \
the other functions in the +@acronym{AES} @acronym{SIV-CMAC} interface.
+@end deftypefun
+
+@deftypefun void siv_aes128_cmac_encrypt_message (struct siv_aes128_cmac_ctx \
*@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, \
const uint8_t *@var{adata}, size_t @var{tlength}, size_t @var{clength}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +@deftypefunx void \
siv_aes256_cmac_encrypt_message (struct siv_aes256_cmac_ctx *@var{ctx}, size_t \
@var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, const uint8_t \
*@var{adata}, size_t @var{tlength}, size_t @var{clength}, uint8_t *@var{dst}, const \
uint8_t *@var{src}) +Computes the message digest from the @var{adata} and @var{src}
+parameters, encrypts the plaintext from @var{src}, prepends the
+initialization vector to the ciphertext and outputs it to @var{dst}.
+@end deftypefun
+
+@deftypefun int siv_aes128_cmac_decrypt_message (struct siv_aes128_cmac_ctx \
*@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, \
const uint8_t *@var{adata}, size_t @var{tlength}, size_t @var{mlength}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +@deftypefunx int \
siv_aes256_cmac_decrypt_message (struct siv_aes128_cmac_ctx *@var{ctx}, size_t \
@var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, const uint8_t \
*@var{adata}, size_t @var{tlength}, size_t @var{mlength}, uint8_t *@var{dst}, const \
uint8_t *@var{src}) +Decrypts the ciphertext from @var{src}, outputs the plaintext to
+@var{dst}, recalculates the initialization vector from @var{adata} and the
+plaintext, and compares it to the final @var{tlength} bytes of
+@var{src}. If the values of the received and calculated initialization vector
+are equal, this will return 1 indicating a valid and authenticated
+message. Otherwise, this function will return zero.
+@end deftypefun
+
 @node nettle_aead abstraction, , ChaCha-Poly1305, Authenticated encryption
 @comment  node-name,  next,  previous,  up
 @subsection The @code{struct nettle_aead} abstraction
diff --git a/siv-aes128-cmac.c b/siv-aes128-cmac.c
new file mode 100644
index 00000000..2acfc9a5
--- /dev/null
+++ b/siv-aes128-cmac.c
@@ -0,0 +1,79 @@
+/* siv-aes128.c
+
+   AES-SIV, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "aes.h"
+#include "siv-cmac.h"
+#include "cmac.h"
+#include "ctr.h"
+#include "memxor.h"
+#include "memops.h"
+#include "cmac-internal.h"
+
+void
+siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const uint8_t *key)
+{
+  siv_cmac_set_key(&amp;ctx-&gt;siv_cmac, &amp;ctx-&gt;cipher, &amp;nettle_aes128, key);
+}
+
+void
+siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t tlength,
+				size_t slength, uint8_t *dst, const uint8_t *src)
+{
+  assert(tlength == SIV_DIGEST_SIZE);
+  siv_cmac_encrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes128, &amp;ctx-&gt;cipher,
+			   nlength, nonce, alength, adata,
+			   slength, dst, src);
+}
+
+int
+siv_aes128_cmac_decrypt_message(struct siv_aes128_cmac_ctx *ctx,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t tlength,
+			 size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  assert(tlength == SIV_DIGEST_SIZE);
+  return siv_cmac_decrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes128, &amp;ctx-&gt;cipher,
+				  nlength, nonce, alength, adata,
+				  mlength, dst, src);
+}
diff --git a/siv-aes256-cmac.c b/siv-aes256-cmac.c
new file mode 100644
index 00000000..c85feebe
--- /dev/null
+++ b/siv-aes256-cmac.c
@@ -0,0 +1,79 @@
+/* siv-aes128.c
+
+   AES-SIV, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "aes.h"
+#include "siv-cmac.h"
+#include "cmac.h"
+#include "ctr.h"
+#include "memxor.h"
+#include "memops.h"
+#include "cmac-internal.h"
+
+void
+siv_aes256_cmac_set_key(struct siv_aes256_cmac_ctx *ctx, const uint8_t *key)
+{
+  siv_cmac_set_key(&amp;ctx-&gt;siv_cmac, &amp;ctx-&gt;cipher, &amp;nettle_aes256, key);
+}
+
+void
+siv_aes256_cmac_encrypt_message(struct siv_aes256_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t tlength,
+				size_t slength, uint8_t *dst, const uint8_t *src)
+{
+  assert(tlength == SIV_DIGEST_SIZE);
+  siv_cmac_encrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes256, &amp;ctx-&gt;cipher,
+			   nlength, nonce, alength, adata,
+			   slength, dst, src);
+}
+
+int
+siv_aes256_cmac_decrypt_message(struct siv_aes256_cmac_ctx *ctx,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t tlength,
+			 size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  assert(tlength == SIV_DIGEST_SIZE);
+  return siv_cmac_decrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes256, &amp;ctx-&gt;cipher,
+				  nlength, nonce, alength, adata,
+				  mlength, dst, src);
+}
diff --git a/siv-cmac.c b/siv-cmac.c
new file mode 100644
index 00000000..7d2a8916
--- /dev/null
+++ b/siv-cmac.c
@@ -0,0 +1,194 @@
+/* siv-cmac.c
+
+   SIV-CMAC, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "aes.h"
+#include "siv-cmac.h"
+#include "cmac.h"
+#include "ctr.h"
+#include "memxor.h"
+#include "memops.h"
+#include "cmac-internal.h"
+#include "nettle-internal.h"
+
+/* This is a common structure for AES-128 and AES-256 thus
+ * for the cipher part we simply pad to the maximum structure
+ * size plus 16 bytes to account for any alignment difference in
+ * the original structures */
+struct cmac128_syn {
+  struct cmac128_ctx ctx;
+  struct {
+    uint8_t pad[NETTLE_MAX_CIPHER16_CONTEXT_SIZE+16];
+  } cipher;
+};
+
+static
+void _siv_s2v(const struct nettle_cipher *nc,
+	      const uint8_t *s2vk, size_t alength, const uint8_t *adata,
+              size_t nlength, const uint8_t *nonce,
+              size_t plength, const uint8_t *pdata,
+              uint8_t *v)
+{
+  struct cmac128_syn ctx;
+  union nettle_block16 D, S, T;
+  const uint8_t const_one[16] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x01
+  };
+  const uint8_t const_zero[16] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
+  };
+
+  assert(nc-&gt;context_size &lt;= NETTLE_MAX_CIPHER16_CONTEXT_SIZE);
+
+  /* ensure we have enough size of context plus any padding size */
+  CMAC128_SET_KEY(&amp;ctx, nc-&gt;set_encrypt_key, nc-&gt;encrypt, s2vk);
+
+  if (nlength == 0 &amp;&amp; alength == 0) {
+    CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, 16, const_one);
+    CMAC128_DIGEST(&amp;ctx, nc-&gt;encrypt, 16, v);
+    return;
+  }
+
+  CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, 16, const_zero);
+  CMAC128_DIGEST(&amp;ctx, nc-&gt;encrypt, 16, D.b);
+
+  if (alength &gt; 0) {
+    _cmac128_block_mulx(&amp;D, &amp;D);
+    CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, alength, adata);
+    CMAC128_DIGEST(&amp;ctx, nc-&gt;encrypt, 16, S.b);
+
+    memxor(D.b, S.b, 16);
+  }
+
+  if (nlength &gt; 0) {
+    _cmac128_block_mulx(&amp;D, &amp;D);
+    CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, nlength, nonce);
+    CMAC128_DIGEST(&amp;ctx, nc-&gt;encrypt, 16, S.b);
+
+    memxor(D.b, S.b, 16);
+  }
+
+  /* Sn */
+  if (plength &gt; 16) {
+    CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, plength-16, pdata);
+
+    pdata += plength-16;
+
+    memxor3(T.b, pdata, D.b, 16);
+  } else {
+    union nettle_block16 pad;
+
+    _cmac128_block_mulx(&amp;T, &amp;D);
+    memcpy(pad.b, pdata, plength);
+    pad.b[plength] = 0x80;
+    if (plength+1 &lt; 16)
+      memset(&amp;pad.b[plength+1], 0, 16-plength-1);
+
+    memxor(T.b, pad.b, 16);
+  }
+
+  CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, 16, T.b);
+  CMAC128_DIGEST(&amp;ctx, nc-&gt;encrypt, 16, v);
+}
+
+void
+siv_cmac_set_key(struct siv_cmac_ctx *ctx, void *cipher,
+		 const struct nettle_cipher *nc,
+		 const uint8_t *key)
+{
+	unsigned skey_size = nc-&gt;key_size;
+
+	assert(skey_size &lt;= SIV_MAX_KEY_SIZE/2);
+	memcpy(ctx-&gt;s2vk, key, skey_size);
+
+	nc-&gt;set_encrypt_key(cipher, key+skey_size);
+}
+
+void
+siv_cmac_encrypt_message(struct siv_cmac_ctx *ctx,
+			 const struct nettle_cipher *nc,
+			 void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t slength, uint8_t *dst, const uint8_t *src)
+{
+	union nettle_block16 siv;
+
+	/* create CTR nonce */
+	_siv_s2v(nc,
+		 ctx-&gt;s2vk, alength, adata,
+		 nlength, nonce, slength, src, siv.b);
+
+	memcpy(dst, siv.b, SIV_DIGEST_SIZE);
+	siv.b[8] &amp;= ~0x80;
+	siv.b[12] &amp;= ~0x80;
+
+	ctr_crypt(cipher, nc-&gt;encrypt, AES_BLOCK_SIZE, siv.b, slength, dst+SIV_DIGEST_SIZE, \
src); +}
+
+int
+siv_cmac_decrypt_message(struct siv_cmac_ctx *ctx,
+			 const struct nettle_cipher *nc,
+			 void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  union nettle_block16 siv;
+  union nettle_block16 ctr;
+
+  assert(mlength &gt; SIV_DIGEST_SIZE);
+
+  memcpy(ctr.b, src, SIV_DIGEST_SIZE);
+  ctr.b[8] &amp;= ~0x80;
+  ctr.b[12] &amp;= ~0x80;
+
+  ctr_crypt(cipher, nc-&gt;encrypt, AES_BLOCK_SIZE, ctr.b,
+            mlength-SIV_DIGEST_SIZE, dst, src+SIV_DIGEST_SIZE);
+
+  /* create CTR nonce */
+  _siv_s2v(nc,
+	   ctx-&gt;s2vk, alength, adata,
+	   nlength, nonce, mlength-SIV_DIGEST_SIZE, dst, siv.b);
+
+  return memeql_sec(siv.b, src, SIV_DIGEST_SIZE);
+}
+
diff --git a/siv-cmac.h b/siv-cmac.h
new file mode 100644
index 00000000..1a07856d
--- /dev/null
+++ b/siv-cmac.h
@@ -0,0 +1,139 @@
+/* siv.h
+
+   AES-SIV, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_SIV_H_INCLUDED
+#define NETTLE_SIV_H_INCLUDED
+
+#include "nettle-types.h"
+#include "nettle-meta.h"
+#include "aes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define siv_cmac_set_key nettle_siv_cmac_set_key
+#define siv_cmac_encrypt_message nettle_siv_cmac_encrypt_message
+#define siv_cmac_decrypt_message nettle_siv_cmac_decrypt_message
+#define siv_aes128_cmac_set_key nettle_siv_aes128_cmac_set_key
+#define siv_aes128_cmac_encrypt_message nettle_siv_aes128_cmac_encrypt_message
+#define siv_aes128_cmac_decrypt_message nettle_siv_aes128_cmac_decrypt_message
+#define siv_aes256_cmac_set_key nettle_siv_aes256_cmac_set_key
+#define siv_aes256_cmac_encrypt_message nettle_siv_aes256_cmac_encrypt_message
+#define siv_aes256_cmac_decrypt_message nettle_siv_aes256_cmac_decrypt_message
+
+/* For SIV, the block size of the block cipher shall be 128 bits. */
+#define SIV_BLOCK_SIZE  16
+#define SIV_DIGEST_SIZE 16
+#define SIV_MIN_NONCE_SIZE 0
+#define SIV_MAX_KEY_SIZE (AES_MAX_KEY_SIZE*2)
+
+struct siv_cmac_ctx {
+    uint8_t s2vk[SIV_MAX_KEY_SIZE/2];
+};
+
+void
+siv_cmac_set_key(struct siv_cmac_ctx *ctx, void *cipher,
+		 const struct nettle_cipher *nc,
+		 const uint8_t *key);
+
+void
+siv_cmac_encrypt_message(struct siv_cmac_ctx *ctx,
+			 const struct nettle_cipher *nc,
+			 void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t slength, uint8_t *dst, const uint8_t *src);
+
+int
+siv_cmac_decrypt_message(struct siv_cmac_ctx *ctx,
+			 const struct nettle_cipher *nc,
+			 void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src);
+
+/*
+ * SIV mode requires the aad and plaintext when building the IV, which
+ * prevents streaming processing and it incompatible with the AEAD API.
+ */
+
+#define SIV_CMAC_CTX(type) \
+  { struct siv_cmac_ctx siv_cmac; type cipher; }
+
+/* AES_SIV_CMAC_256 */
+struct siv_aes128_cmac_ctx SIV_CMAC_CTX(struct aes128_ctx);
+
+void
+siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const uint8_t *key);
+
+void
+siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t tlength,
+				size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+siv_aes128_cmac_decrypt_message(struct siv_aes128_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t tlength,
+				size_t mlength, uint8_t *dst, const uint8_t *src);
+
+/* AES_SIV_CMAC_512 */
+struct siv_aes256_cmac_ctx SIV_CMAC_CTX(struct aes256_ctx);
+
+void
+siv_aes256_cmac_set_key(struct siv_aes256_cmac_ctx *ctx, const uint8_t *key);
+
+void
+siv_aes256_cmac_encrypt_message(struct siv_aes256_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t tlength,
+				size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+siv_aes256_cmac_decrypt_message(struct siv_aes256_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t tlength,
+				size_t mlength, uint8_t *dst, const uint8_t *src);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_SIV_H_INCLUDED */
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index c3fc5c11..2a0d87ac 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -96,6 +96,8 @@
 /version-test
 /yarrow-test
 /xts-test
+/cmac-test
+/siv-test
 
 /test.in
 /test1.out
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 6eee6e22..f827175e 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -136,6 +136,9 @@ ccm-test$(EXEEXT): ccm-test.$(OBJEXT)
 cmac-test$(EXEEXT): cmac-test.$(OBJEXT)
 	$(LINK) cmac-test.$(OBJEXT) $(TEST_OBJS) -o cmac-test$(EXEEXT)
 
+siv-test$(EXEEXT): siv-test.$(OBJEXT)
+	$(LINK) siv-test.$(OBJEXT) $(TEST_OBJS) -o siv-test$(EXEEXT)
+
 poly1305-test$(EXEEXT): poly1305-test.$(OBJEXT)
 	$(LINK) poly1305-test.$(OBJEXT) $(TEST_OBJS) -o poly1305-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 287c4f75..1bd42ffa 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -27,7 +27,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    serpent-test.c twofish-test.c version-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c cfb-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
-		    cmac-test.c \
+		    cmac-test.c siv-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
diff --git a/testsuite/siv-test.c b/testsuite/siv-test.c
new file mode 100644
index 00000000..dd58e679
--- /dev/null
+++ b/testsuite/siv-test.c
@@ -0,0 +1,332 @@
+/* siv-test.c
+
+   Self-test and vectors for AES-SIV mode ciphers
+
+   Copyright (C) 2018 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+/* The
+ * test vectors have been collected from the following standards:
+ *  RFC5297
+ */
+
+#include "testutils.h"
+#include "aes.h"
+#include "nettle-types.h"
+#include "siv-cmac.h"
+#include "knuth-lfib.h"
+
+static void
+test_compare_results(const char *name,
+        const struct tstring *adata,
+        /* Expected results. */
+        const struct tstring *e_clear,
+	const struct tstring *e_cipher,
+        /* Actual results. */
+        const void *clear,
+        const void *cipher,
+        const void *digest) /* digest optional. */
+{
+  int tlength = (e_cipher-&gt;length - e_clear-&gt;length);
+  if (digest &amp;&amp; tlength &amp;&amp; !MEMEQ(tlength, e_cipher-&gt;data, digest))
+    {
+      fprintf(stderr, "%s digest failed:\nAdata:", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(tlength, digest);
+      fprintf(stderr, "\nExpected:");
+      print_hex(tlength, e_cipher-&gt;data);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  if (!MEMEQ(e_cipher-&gt;length, e_cipher-&gt;data, cipher))
+    {
+      fprintf(stderr, "%s: encryption failed\nAdata: ", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_cipher-&gt;length, cipher);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_cipher);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  if (!MEMEQ(e_clear-&gt;length, e_clear-&gt;data, clear))
+    {
+      fprintf(stderr, "%s decrypt failed:\nAdata:", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_cipher);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_clear-&gt;length, clear);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+} /* test_compare_results */
+
+static void
+test_cipher_siv(const char *name,
+		nettle_set_key_func *siv_set_key,
+		nettle_encrypt_message *siv_encrypt,
+		nettle_decrypt_message *siv_decrypt,
+		unsigned context_size,
+		const struct nettle_cipher *cipher,
+		const struct tstring *key,
+		const struct tstring *nonce,
+		const struct tstring *authdata,
+		const struct tstring *cleartext,
+		const struct tstring *ciphertext)
+{
+  void *ctx = xalloc(context_size);
+  uint8_t *en_data;
+  uint8_t *de_data;
+  size_t tlength;
+  int ret;
+
+  ASSERT (key-&gt;length == cipher-&gt;key_size*2);
+  ASSERT (cleartext-&gt;length &lt;= ciphertext-&gt;length);
+  ASSERT ((cleartext-&gt;length + SIV_BLOCK_SIZE) &gt;= ciphertext-&gt;length);
+  tlength = ciphertext-&gt;length - cleartext-&gt;length;
+
+  de_data = xalloc(cleartext-&gt;length+SIV_DIGEST_SIZE);
+  en_data = xalloc(ciphertext-&gt;length);
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+
+  /* Ensure we get the same answers using the all-in-one API. */
+  memset(de_data, 0, cleartext-&gt;length);
+  memset(en_data, 0, ciphertext-&gt;length);
+
+  siv_set_key(ctx, key-&gt;data);
+  siv_encrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+				  authdata-&gt;length, authdata-&gt;data, tlength,
+				  cleartext-&gt;length, en_data, cleartext-&gt;data);
+
+  ret = siv_decrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+				        authdata-&gt;length, authdata-&gt;data, tlength,
+				        ciphertext-&gt;length, de_data, ciphertext-&gt;data);
+
+  if (ret != 1) fprintf(stderr, "siv_decrypt_message failed to validate message\n");
+    test_compare_results(name, authdata,
+			 cleartext, ciphertext, de_data, en_data, NULL);
+
+  test_compare_results(name, authdata,
+		       cleartext, ciphertext, de_data, en_data, en_data);
+
+
+  /* Ensure that we can detect corrupted message or tag data. */
+  if (tlength) {
+    en_data[0] ^= 1;
+    ret = siv_decrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+				          authdata-&gt;length, authdata-&gt;data, tlength,
+				          ciphertext-&gt;length, de_data, en_data);
+    if (ret != 0) fprintf(stderr, "siv_decrypt_message failed to detect corrupted \
message\n"); +  }
+
+  /* Ensure we can detect corrupted adata. */
+  if (tlength &amp;&amp; authdata-&gt;length) {
+    en_data[0] ^= 1;
+    ret = siv_decrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+				         authdata-&gt;length-1, authdata-&gt;data, tlength,
+				         ciphertext-&gt;length, de_data, en_data);
+    if (ret != 0) fprintf(stderr, "siv_decrypt_message failed to detect corrupted \
message\n"); +  }
+
+
+  free(ctx);
+  free(en_data);
+  free(de_data);
+}
+
+#define test_siv_aes128(name, ctx_size, cipher, key, nonce, authdata, cleartext, \
ciphertext) \ +	test_cipher_siv(name, (nettle_set_key_func*)siv_aes128_cmac_set_key, \
\ +			(nettle_encrypt_message*)siv_aes128_cmac_encrypt_message, \
+			(nettle_decrypt_message*)siv_aes128_cmac_decrypt_message, ctx_size, cipher, \
+			key, nonce, authdata, cleartext, ciphertext)
+
+#define test_siv_aes256(name, ctx_size, cipher, key, nonce, authdata, cleartext, \
ciphertext) \ +	test_cipher_siv(name, (nettle_set_key_func*)siv_aes256_cmac_set_key, \
\ +			(nettle_encrypt_message*)siv_aes256_cmac_encrypt_message, \
+			(nettle_decrypt_message*)siv_aes256_cmac_decrypt_message, ctx_size, cipher, \
+			key, nonce, authdata, cleartext, ciphertext)
+
+void
+test_main(void)
+{
+  /* Create a pattern of 00010203 04050607 08090a00b 0c0d0e0f ... */
+  struct tstring *adata;
+  unsigned int i;
+  adata = tstring_alloc(256);
+  for (i=0; i&lt;adata-&gt;length; i++) adata-&gt;data[i] = (i &amp; 0xff);
+
+  /*
+   * Example without nonce length &lt; 16 (RFC5297)
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"),
+		  SHEX(""),
+		  SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+		       "20212223 24252627"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("85632d07 c6e8f37f 950acd32 0a2ecc93"
+		       "40c02b96 90c4dc04 daef7f6a fe5c"));
+
+  /*
+   * Example without nonce length &gt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX(""),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("c12ccaa7 54e1b3fa 4f416c18 415625ca"
+		       "472fbee de5bc03f 34934819 a9abb20b5"
+		       "8cd019c 470ac832 f6eb9ddf 0656c5dce"
+		       "ffe611a 5a5ca3e1 c3c12da5 6e4bb87"));
+
+  /*
+   * Example with single AAD, length &gt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+	          &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("85825e22 e90cf2dd da2c548d c7c1b631"
+		       "0dcdaca0 cebf9dc6 cb90583f 5bf1506e"
+		       "02cd4883 2b00e4e5 98b2b22a 53e6199d"
+		       "4df0c166 6a35a043 3b250dc1 34d776"));
+
+  /*
+   * Example with single AAD, length &lt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+	          &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("15f83882 14bdc94e 3ec4c7c3 69863746"
+		       "cd72d317 4b20a1e4 a0894fb7 cd78"));
+
+
+  /* AES-SIV-CMAC-512 (AES-256) from dchest/siv repo
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+		  &amp;nettle_aes256,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "6f6e6d6c 6b6a6968 67666564 63626160"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"
+		       "00010203 04050607 08090a0b 0c0d0e0f"),
+		  SHEX(""),
+		  SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+		       "20212223 24252627"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("f125274c 598065cf c26b0e71 57502908"
+		       "8b035217 e380cac8 919ee800 c126"));
+
+
+  /* AES-SIV-CMAC-512 (AES-256)
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+		  &amp;nettle_aes256,
+		  SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+		       "2d568e91 a38e5414 8abdc0b6 e86caf87"
+		       "695c0a8a df4c5f8e b2c6c8b1 36529864"
+		       "f3b84b3a e8e3676c e760c461 f3a13e83"),
+		  SHEX(""),
+		  SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+		       "20212223 24252627"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("ae2b1bd1 ba7fcd6a 4f9f7eb2 4b40f766"
+		       "86053ffd c384cb19 76031f46 3013"));
+
+  /*
+   * Example without nonce length &gt; 16
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+		  &amp;nettle_aes256,
+		  SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+		       "2d568e91 a38e5414 8abdc0b6 e86caf87"
+		       "695c0a8a df4c5f8e b2c6c8b1 36529864"
+		       "f3b84b3a e8e3676c e760c461 f3a13e83"),
+		  SHEX(""),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("79476aaa 388374fe 97d0db51 596cb5ee"
+		       "a933e001 412026c7 956c82dd b753b1af"
+		       "3d7d49ac 474a800a c14b4bab a4542067"
+		       "83647ef9 51315dab b7a2c05b 288ba8"));
+
+  /*
+   * Example with single AAD, length &gt; 16
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+	          &amp;nettle_aes256,
+		  SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+		       "2d568e91 a38e5414 8abdc0b6 e86caf87"
+		       "695c0a8a df4c5f8e b2c6c8b1 36529864"
+		       "f3b84b3a e8e3676c e760c461 f3a13e83"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("5a979b0d a58fde80 51621ae6 bf96feda"
+		       "50933da8 047bc306 fabaf0c3 d9fa8471"
+		       "c70a7def 39a2f91d 68a2021c 99ac7e2a"
+		       "24535a13 4ba23ec1 5787cebe 5c53cc"));
+}
-- 
2.20.1


[Attachment #4 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190702214516</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 21:45:16-0400</timestampReceived><subject>[PATCH] nettle-types: drop w field from nettle_block16</subject><body>

"unsigned long w" comes from the time when Nettle didn't use uint64_t.
It is unused now and thus can be dropped.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 nettle-types.h | 1 -
 1 file changed, 1 deletion(-)

diff --git a/nettle-types.h b/nettle-types.h
index 5addf3600d69..93a68f3b305c 100644
--- a/nettle-types.h
+++ b/nettle-types.h
@@ -61,7 +61,6 @@ extern "C" {
 union nettle_block16
 {
   uint8_t b[16];
-  unsigned long w[16 / sizeof(unsigned long)];
   uint64_t u64[2];
 };
 
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190703121936</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-03 12:19:36-0400</timestampReceived><subject>[PATCH 2/3] gcm: drop w field from nettle_block16</subject><body>

"unsigned long w" comes from the time when Nettle didn't use uint64_t.
It is unused now and thus can be dropped.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 gcm.c | 126 +++++++++++++---------------------------------------------
 1 file changed, 28 insertions(+), 98 deletions(-)

diff --git a/gcm.c b/gcm.c
index 14a6181b032f..e7a0a70bda64 100644
--- a/gcm.c
+++ b/gcm.c
@@ -60,12 +60,8 @@ static void
 gcm_gf_add (union nettle_block16 *r,
 	    const union nettle_block16 *x, const union nettle_block16 *y)
 {
-  r-&gt;w[0] = x-&gt;w[0] ^ y-&gt;w[0];
-  r-&gt;w[1] = x-&gt;w[1] ^ y-&gt;w[1];
-#if SIZEOF_LONG == 4
-  r-&gt;w[2] = x-&gt;w[2] ^ y-&gt;w[2];
-  r-&gt;w[3] = x-&gt;w[3] ^ y-&gt;w[3];
-#endif      
+  r-&gt;u64[0] = x-&gt;u64[0] ^ y-&gt;u64[0];
+  r-&gt;u64[1] = x-&gt;u64[1] ^ y-&gt;u64[1];
 }
 /* Multiplication by 010...0; a big-endian shift right. If the bit
    shifted out is one, the defining polynomial is added to cancel it
@@ -77,39 +73,16 @@ gcm_gf_shift (union nettle_block16 *r, const union nettle_block16 *x)
 
   /* Shift uses big-endian representation. */
 #if WORDS_BIGENDIAN
-# if SIZEOF_LONG == 4
-  mask = - (x-&gt;w[3] &amp; 1);
-  r-&gt;w[3] = (x-&gt;w[3] &gt;&gt; 1) | ((x-&gt;w[2] &amp; 1) &lt;&lt; 31);
-  r-&gt;w[2] = (x-&gt;w[2] &gt;&gt; 1) | ((x-&gt;w[1] &amp; 1) &lt;&lt; 31);
-  r-&gt;w[1] = (x-&gt;w[1] &gt;&gt; 1) | ((x-&gt;w[0] &amp; 1) &lt;&lt; 31);
-  r-&gt;w[0] = (x-&gt;w[0] &gt;&gt; 1) ^ (mask &amp; (GHASH_POLYNOMIAL &lt;&lt; 24)); 
-# elif SIZEOF_LONG == 8
-  mask = - (x-&gt;w[1] &amp; 1);
-  r-&gt;w[1] = (x-&gt;w[1] &gt;&gt; 1) | ((x-&gt;w[0] &amp; 1) &lt;&lt; 63);
-  r-&gt;w[0] = (x-&gt;w[0] &gt;&gt; 1) ^ (mask &amp; (GHASH_POLYNOMIAL &lt;&lt; 56));
-# else
-#  error Unsupported word size. */
-#endif
+  mask = - (x-&gt;u64[1] &amp; 1);
+  r-&gt;u64[1] = (x-&gt;u64[1] &gt;&gt; 1) | ((x-&gt;u64[0] &amp; 1) &lt;&lt; 63);
+  r-&gt;u64[0] = (x-&gt;u64[0] &gt;&gt; 1) ^ (mask &amp; (GHASH_POLYNOMIAL &lt;&lt; 56));
 #else /* ! WORDS_BIGENDIAN */
-# if SIZEOF_LONG == 4
 #define RSHIFT_WORD(x) \
-  ((((x) &amp; 0xfefefefeUL) &gt;&gt; 1) \
-   | (((x) &amp; 0x00010101) &lt;&lt; 15))
-  mask = - ((x-&gt;w[3] &gt;&gt; 24) &amp; 1);
-  r-&gt;w[3] = RSHIFT_WORD(x-&gt;w[3]) | ((x-&gt;w[2] &gt;&gt; 17) &amp; 0x80);
-  r-&gt;w[2] = RSHIFT_WORD(x-&gt;w[2]) | ((x-&gt;w[1] &gt;&gt; 17) &amp; 0x80);
-  r-&gt;w[1] = RSHIFT_WORD(x-&gt;w[1]) | ((x-&gt;w[0] &gt;&gt; 17) &amp; 0x80);
-  r-&gt;w[0] = RSHIFT_WORD(x-&gt;w[0]) ^ (mask &amp; GHASH_POLYNOMIAL);
-# elif SIZEOF_LONG == 8
-#define RSHIFT_WORD(x) \
-  ((((x) &amp; 0xfefefefefefefefeUL) &gt;&gt; 1) \
-   | (((x) &amp; 0x0001010101010101UL) &lt;&lt; 15))
-  mask = - ((x-&gt;w[1] &gt;&gt; 56) &amp; 1);
-  r-&gt;w[1] = RSHIFT_WORD(x-&gt;w[1]) | ((x-&gt;w[0] &gt;&gt; 49) &amp; 0x80);
-  r-&gt;w[0] = RSHIFT_WORD(x-&gt;w[0]) ^ (mask &amp; GHASH_POLYNOMIAL);
-# else
-#  error Unsupported word size. */
-# endif
+  ((((x) &amp; UINT64_C(0xfefefefefefefefe)) &gt;&gt; 1) \
+   | (((x) &amp; UINT64_C(0x0001010101010101)) &lt;&lt; 15))
+  mask = - ((x-&gt;u64[1] &gt;&gt; 56) &amp; 1);
+  r-&gt;u64[1] = RSHIFT_WORD(x-&gt;u64[1]) | ((x-&gt;u64[0] &gt;&gt; 49) &amp; 0x80);
+  r-&gt;u64[0] = RSHIFT_WORD(x-&gt;u64[0]) ^ (mask &amp; GHASH_POLYNOMIAL);
 # undef RSHIFT_WORD
 #endif /* ! WORDS_BIGENDIAN */
 }
@@ -160,44 +133,21 @@ shift_table[0x10] = {
 static void
 gcm_gf_shift_4(union nettle_block16 *x)
 {
-  unsigned long *w = x-&gt;w;
-  unsigned long reduce;
+  uint64_t *u64 = x-&gt;u64;
+  uint64_t reduce;
 
   /* Shift uses big-endian representation. */
 #if WORDS_BIGENDIAN
-# if SIZEOF_LONG == 4
-  reduce = shift_table[w[3] &amp; 0xf];
-  w[3] = (w[3] &gt;&gt; 4) | ((w[2] &amp; 0xf) &lt;&lt; 28);
-  w[2] = (w[2] &gt;&gt; 4) | ((w[1] &amp; 0xf) &lt;&lt; 28);
-  w[1] = (w[1] &gt;&gt; 4) | ((w[0] &amp; 0xf) &lt;&lt; 28);
-  w[0] = (w[0] &gt;&gt; 4) ^ (reduce &lt;&lt; 16);
-# elif SIZEOF_LONG == 8
-  reduce = shift_table[w[1] &amp; 0xf];
-  w[1] = (w[1] &gt;&gt; 4) | ((w[0] &amp; 0xf) &lt;&lt; 60);
-  w[0] = (w[0] &gt;&gt; 4) ^ (reduce &lt;&lt; 48);
-# else
-#  error Unsupported word size. */
-#endif
+  reduce = shift_table[u64[1] &amp; 0xf];
+  u64[1] = (u64[1] &gt;&gt; 4) | ((u64[0] &amp; 0xf) &lt;&lt; 60);
+  u64[0] = (u64[0] &gt;&gt; 4) ^ (reduce &lt;&lt; 48);
 #else /* ! WORDS_BIGENDIAN */
-# if SIZEOF_LONG == 4
 #define RSHIFT_WORD(x) \
-  ((((x) &amp; 0xf0f0f0f0UL) &gt;&gt; 4)			\
-   | (((x) &amp; 0x000f0f0f) &lt;&lt; 12))
-  reduce = shift_table[(w[3] &gt;&gt; 24) &amp; 0xf];
-  w[3] = RSHIFT_WORD(w[3]) | ((w[2] &gt;&gt; 20) &amp; 0xf0);
-  w[2] = RSHIFT_WORD(w[2]) | ((w[1] &gt;&gt; 20) &amp; 0xf0);
-  w[1] = RSHIFT_WORD(w[1]) | ((w[0] &gt;&gt; 20) &amp; 0xf0);
-  w[0] = RSHIFT_WORD(w[0]) ^ reduce;
-# elif SIZEOF_LONG == 8
-#define RSHIFT_WORD(x) \
-  ((((x) &amp; 0xf0f0f0f0f0f0f0f0UL) &gt;&gt; 4) \
-   | (((x) &amp; 0x000f0f0f0f0f0f0fUL) &lt;&lt; 12))
-  reduce = shift_table[(w[1] &gt;&gt; 56) &amp; 0xf];
-  w[1] = RSHIFT_WORD(w[1]) | ((w[0] &gt;&gt; 52) &amp; 0xf0);
-  w[0] = RSHIFT_WORD(w[0]) ^ reduce;
-# else
-#  error Unsupported word size. */
-# endif
+  ((((x) &amp; UINT64_C(0xf0f0f0f0f0f0f0f0)) &gt;&gt; 4) \
+   | (((x) &amp; UINT64_C(0x000f0f0f0f0f0f0f)) &lt;&lt; 12))
+  reduce = shift_table[(u64[1] &gt;&gt; 56) &amp; 0xf];
+  u64[1] = RSHIFT_WORD(u64[1]) | ((u64[0] &gt;&gt; 52) &amp; 0xf0);
+  u64[0] = RSHIFT_WORD(u64[0]) ^ reduce;
 # undef RSHIFT_WORD
 #endif /* ! WORDS_BIGENDIAN */
 }
@@ -268,38 +218,18 @@ shift_table[0x100] = {
 static void
 gcm_gf_shift_8(union nettle_block16 *x)
 {
-  unsigned long *w = x-&gt;w;
-  unsigned long reduce;
+  uint64_t *u64 = x-&gt;u64;
+  uint64_t reduce;
 
   /* Shift uses big-endian representation. */
 #if WORDS_BIGENDIAN
-# if SIZEOF_LONG == 4
-  reduce = shift_table[w[3] &amp; 0xff];
-  w[3] = (w[3] &gt;&gt; 8) | ((w[2] &amp; 0xff) &lt;&lt; 24);
-  w[2] = (w[2] &gt;&gt; 8) | ((w[1] &amp; 0xff) &lt;&lt; 24);
-  w[1] = (w[1] &gt;&gt; 8) | ((w[0] &amp; 0xff) &lt;&lt; 24);
-  w[0] = (w[0] &gt;&gt; 8) ^ (reduce &lt;&lt; 16);
-# elif SIZEOF_LONG == 8
-  reduce = shift_table[w[1] &amp; 0xff];
-  w[1] = (w[1] &gt;&gt; 8) | ((w[0] &amp; 0xff) &lt;&lt; 56);
-  w[0] = (w[0] &gt;&gt; 8) ^ (reduce &lt;&lt; 48);
-# else
-#  error Unsupported word size. */
-#endif
+  reduce = shift_table[u64[1] &amp; 0xff];
+  u64[1] = (u64[1] &gt;&gt; 8) | ((u64[0] &amp; 0xff) &lt;&lt; 56);
+  u64[0] = (u64[0] &gt;&gt; 8) ^ (reduce &lt;&lt; 48);
 #else /* ! WORDS_BIGENDIAN */
-# if SIZEOF_LONG == 4
-  reduce = shift_table[(w[3] &gt;&gt; 24) &amp; 0xff];
-  w[3] = (w[3] &lt;&lt; 8) | (w[2] &gt;&gt; 24);
-  w[2] = (w[2] &lt;&lt; 8) | (w[1] &gt;&gt; 24);
-  w[1] = (w[1] &lt;&lt; 8) | (w[0] &gt;&gt; 24);
-  w[0] = (w[0] &lt;&lt; 8) ^ reduce;
-# elif SIZEOF_LONG == 8
-  reduce = shift_table[(w[1] &gt;&gt; 56) &amp; 0xff];
-  w[1] = (w[1] &lt;&lt; 8) | (w[0] &gt;&gt; 56);
-  w[0] = (w[0] &lt;&lt; 8) ^ reduce;
-# else
-#  error Unsupported word size. */
-# endif
+  reduce = shift_table[(u64[1] &gt;&gt; 56) &amp; 0xff];
+  u64[1] = (u64[1] &lt;&lt; 8) | (u64[0] &gt;&gt; 56);
+  u64[0] = (u64[0] &lt;&lt; 8) ^ reduce;
 #endif /* ! WORDS_BIGENDIAN */
 }
 
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190708214426</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-08 21:44:26-0400</timestampReceived><subject>Re: [PATCH 2/3] gcm: drop w field from nettle_block16</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; "unsigned long w" comes from the time when Nettle didn't use uint64_t.
&gt; It is unused now and thus can be dropped.

I've done something very similar on the block16-refactor branch.

&gt; +  r-&gt;u64[0] = (x-&gt;u64[0] &gt;&gt; 1) ^ (mask &amp; (GHASH_POLYNOMIAL &lt;&lt; 56));

I've found this needs to be (uint64_t) GHASH_POLYNOMIAL &lt;&lt; 56. Otherwise
tests fail when I cross compile for (32-bit) mips and run under qemu.

I'm also trying to move helper functions (most or all should be inline)
to block16-internal.h.

Next, I'm looking into unifying the various shift operations. It seems
we have the following variants:

   Big-endian left shift: cmac, eax, polynomial 0x87
   Little-endian left shift: xts, polynomial 0x87
   Big-endian right shift: gcm, polynomial 0xE1 (bit-reverse of 0x87)

If I understand it correctly after a quick look (long since I looked at
GCM in detail), its represents the polynomials with a peculiar bit-order
where what's otherwise the least significant bit represents the
coefficient of the highest power of x. The multiplication is kind-of
invariant under bit-reversal, but I'm not sure if it's possible to
rearrange it to use a different bit order without explicit bit reversal
of the input. At least, not an easy change.

I'm thinking of some shared macros or inline functions to abstract the
left shift operations, say block16_mulx_be, block16_mulx_le.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190703105927</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-03 10:59:27-0400</timestampReceived><subject>Re: [PATCH] nettle-types: drop w field from nettle_block16</subject><body>

Hmm. This patch has to wait a bit, sent it without actual testing.
nettle_block16.w is used by eax (easy to copy with) and gcm
(might need performance checks on 32-bit architectures).

ср, 3 июл. 2019 г. в 00:45, Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;:
&gt;
&gt; "unsigned long w" comes from the time when Nettle didn't use uint64_t.
&gt; It is unused now and thus can be dropped.
&gt;
&gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt; ---
&gt;  nettle-types.h | 1 -
&gt;  1 file changed, 1 deletion(-)
&gt;
&gt; diff --git a/nettle-types.h b/nettle-types.h
&gt; index 5addf3600d69..93a68f3b305c 100644
&gt; --- a/nettle-types.h
&gt; +++ b/nettle-types.h
&gt; @@ -61,7 +61,6 @@ extern "C" {
&gt;  union nettle_block16
&gt;  {
&gt;    uint8_t b[16];
&gt; -  unsigned long w[16 / sizeof(unsigned long)];
&gt;    uint64_t u64[2];
&gt;  };
&gt;
&gt; --
&gt; 2.20.1
&gt;


-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702131853</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:18:53-0400</timestampReceived><subject>[PATCH 1/6] Start separating GOST 28147-89 from GOST R 34.11-94</subject><body>

Hash function GOST R 34.11-94 (gosthash94) in its compression function
uses Russian block cipher (GOST 28147-89, Magma). Start separating block
cipher code from hash function code. For now there is no public
interface for this cipher, it will be added later.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in  |   4 +-
 gost28147.c  | 342 +++++++++++++++++++++++++++++++++++++++++++++++++++
 gost28147.h  |  63 ++++++++++
 gosthash94.c | 245 +-----------------------------------
 4 files changed, 412 insertions(+), 242 deletions(-)
 create mode 100644 gost28147.c
 create mode 100644 gost28147.h

diff --git a/Makefile.in b/Makefile.in
index 537e97d19bea..795d66edb2c8 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -102,7 +102,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
 		 cmac.c cmac-aes128.c cmac-aes256.c \
-		 gosthash94.c gosthash94-meta.c \
+		 gost28147.c gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
 		 knuth-lfib.c hkdf.c \
@@ -195,7 +195,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  cbc.h ccm.h cfb.h chacha.h chacha-poly1305.h ctr.h \
 	  curve25519.h des.h dsa.h dsa-compat.h eax.h \
 	  ecc-curve.h ecc.h ecdsa.h eddsa.h \
-	  gcm.h gosthash94.h hmac.h \
+	  gcm.h gost28147.h gosthash94.h hmac.h \
 	  knuth-lfib.h hkdf.h \
 	  macros.h \
 	  cmac.h \
diff --git a/gost28147.c b/gost28147.c
new file mode 100644
index 000000000000..c734c4365fa7
--- /dev/null
+++ b/gost28147.c
@@ -0,0 +1,342 @@
+/* gost28147.c - GOST 28147-89 cipher implementation
+ *
+ * based on Russian standard GOST 28147-89
+ * For English description, check RFC 5830.
+ * S-Boxes are expanded from the tables defined in RFC4357:
+ *   https://tools.ietf.org/html/rfc4357
+ *
+ * Copyright: 2019 Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
+ * Copyright: 2009-2012 Aleksey Kravchenko &lt;rhash.admin@gmail.com&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "macros.h"
+#include "gost28147.h"
+
+/* pre-initialized GOST lookup tables based on rotated S-Box */
+const struct gost28147_param gost28147_param_test_3411 =
+{
+  {
+    /* 0 */
+    0x00072000, 0x00075000, 0x00074800, 0x00071000,
+    0x00076800, 0x00074000, 0x00070000, 0x00077000,
+    0x00073000, 0x00075800, 0x00070800, 0x00076000,
+    0x00073800, 0x00077800, 0x00072800, 0x00071800,
+    0x0005a000, 0x0005d000, 0x0005c800, 0x00059000,
+    0x0005e800, 0x0005c000, 0x00058000, 0x0005f000,
+    0x0005b000, 0x0005d800, 0x00058800, 0x0005e000,
+    0x0005b800, 0x0005f800, 0x0005a800, 0x00059800,
+    0x00022000, 0x00025000, 0x00024800, 0x00021000,
+    0x00026800, 0x00024000, 0x00020000, 0x00027000,
+    0x00023000, 0x00025800, 0x00020800, 0x00026000,
+    0x00023800, 0x00027800, 0x00022800, 0x00021800,
+    0x00062000, 0x00065000, 0x00064800, 0x00061000,
+    0x00066800, 0x00064000, 0x00060000, 0x00067000,
+    0x00063000, 0x00065800, 0x00060800, 0x00066000,
+    0x00063800, 0x00067800, 0x00062800, 0x00061800,
+    0x00032000, 0x00035000, 0x00034800, 0x00031000,
+    0x00036800, 0x00034000, 0x00030000, 0x00037000,
+    0x00033000, 0x00035800, 0x00030800, 0x00036000,
+    0x00033800, 0x00037800, 0x00032800, 0x00031800,
+    0x0006a000, 0x0006d000, 0x0006c800, 0x00069000,
+    0x0006e800, 0x0006c000, 0x00068000, 0x0006f000,
+    0x0006b000, 0x0006d800, 0x00068800, 0x0006e000,
+    0x0006b800, 0x0006f800, 0x0006a800, 0x00069800,
+    0x0007a000, 0x0007d000, 0x0007c800, 0x00079000,
+    0x0007e800, 0x0007c000, 0x00078000, 0x0007f000,
+    0x0007b000, 0x0007d800, 0x00078800, 0x0007e000,
+    0x0007b800, 0x0007f800, 0x0007a800, 0x00079800,
+    0x00052000, 0x00055000, 0x00054800, 0x00051000,
+    0x00056800, 0x00054000, 0x00050000, 0x00057000,
+    0x00053000, 0x00055800, 0x00050800, 0x00056000,
+    0x00053800, 0x00057800, 0x00052800, 0x00051800,
+    0x00012000, 0x00015000, 0x00014800, 0x00011000,
+    0x00016800, 0x00014000, 0x00010000, 0x00017000,
+    0x00013000, 0x00015800, 0x00010800, 0x00016000,
+    0x00013800, 0x00017800, 0x00012800, 0x00011800,
+    0x0001a000, 0x0001d000, 0x0001c800, 0x00019000,
+    0x0001e800, 0x0001c000, 0x00018000, 0x0001f000,
+    0x0001b000, 0x0001d800, 0x00018800, 0x0001e000,
+    0x0001b800, 0x0001f800, 0x0001a800, 0x00019800,
+    0x00042000, 0x00045000, 0x00044800, 0x00041000,
+    0x00046800, 0x00044000, 0x00040000, 0x00047000,
+    0x00043000, 0x00045800, 0x00040800, 0x00046000,
+    0x00043800, 0x00047800, 0x00042800, 0x00041800,
+    0x0000a000, 0x0000d000, 0x0000c800, 0x00009000,
+    0x0000e800, 0x0000c000, 0x00008000, 0x0000f000,
+    0x0000b000, 0x0000d800, 0x00008800, 0x0000e000,
+    0x0000b800, 0x0000f800, 0x0000a800, 0x00009800,
+    0x00002000, 0x00005000, 0x00004800, 0x00001000,
+    0x00006800, 0x00004000, 0x00000000, 0x00007000,
+    0x00003000, 0x00005800, 0x00000800, 0x00006000,
+    0x00003800, 0x00007800, 0x00002800, 0x00001800,
+    0x0003a000, 0x0003d000, 0x0003c800, 0x00039000,
+    0x0003e800, 0x0003c000, 0x00038000, 0x0003f000,
+    0x0003b000, 0x0003d800, 0x00038800, 0x0003e000,
+    0x0003b800, 0x0003f800, 0x0003a800, 0x00039800,
+    0x0002a000, 0x0002d000, 0x0002c800, 0x00029000,
+    0x0002e800, 0x0002c000, 0x00028000, 0x0002f000,
+    0x0002b000, 0x0002d800, 0x00028800, 0x0002e000,
+    0x0002b800, 0x0002f800, 0x0002a800, 0x00029800,
+    0x0004a000, 0x0004d000, 0x0004c800, 0x00049000,
+    0x0004e800, 0x0004c000, 0x00048000, 0x0004f000,
+    0x0004b000, 0x0004d800, 0x00048800, 0x0004e000,
+    0x0004b800, 0x0004f800, 0x0004a800, 0x00049800,
+    /* 1 */
+    0x03a80000, 0x03c00000, 0x03880000, 0x03e80000,
+    0x03d00000, 0x03980000, 0x03a00000, 0x03900000,
+    0x03f00000, 0x03f80000, 0x03e00000, 0x03b80000,
+    0x03b00000, 0x03800000, 0x03c80000, 0x03d80000,
+    0x06a80000, 0x06c00000, 0x06880000, 0x06e80000,
+    0x06d00000, 0x06980000, 0x06a00000, 0x06900000,
+    0x06f00000, 0x06f80000, 0x06e00000, 0x06b80000,
+    0x06b00000, 0x06800000, 0x06c80000, 0x06d80000,
+    0x05280000, 0x05400000, 0x05080000, 0x05680000,
+    0x05500000, 0x05180000, 0x05200000, 0x05100000,
+    0x05700000, 0x05780000, 0x05600000, 0x05380000,
+    0x05300000, 0x05000000, 0x05480000, 0x05580000,
+    0x00a80000, 0x00c00000, 0x00880000, 0x00e80000,
+    0x00d00000, 0x00980000, 0x00a00000, 0x00900000,
+    0x00f00000, 0x00f80000, 0x00e00000, 0x00b80000,
+    0x00b00000, 0x00800000, 0x00c80000, 0x00d80000,
+    0x00280000, 0x00400000, 0x00080000, 0x00680000,
+    0x00500000, 0x00180000, 0x00200000, 0x00100000,
+    0x00700000, 0x00780000, 0x00600000, 0x00380000,
+    0x00300000, 0x00000000, 0x00480000, 0x00580000,
+    0x04280000, 0x04400000, 0x04080000, 0x04680000,
+    0x04500000, 0x04180000, 0x04200000, 0x04100000,
+    0x04700000, 0x04780000, 0x04600000, 0x04380000,
+    0x04300000, 0x04000000, 0x04480000, 0x04580000,
+    0x04a80000, 0x04c00000, 0x04880000, 0x04e80000,
+    0x04d00000, 0x04980000, 0x04a00000, 0x04900000,
+    0x04f00000, 0x04f80000, 0x04e00000, 0x04b80000,
+    0x04b00000, 0x04800000, 0x04c80000, 0x04d80000,
+    0x07a80000, 0x07c00000, 0x07880000, 0x07e80000,
+    0x07d00000, 0x07980000, 0x07a00000, 0x07900000,
+    0x07f00000, 0x07f80000, 0x07e00000, 0x07b80000,
+    0x07b00000, 0x07800000, 0x07c80000, 0x07d80000,
+    0x07280000, 0x07400000, 0x07080000, 0x07680000,
+    0x07500000, 0x07180000, 0x07200000, 0x07100000,
+    0x07700000, 0x07780000, 0x07600000, 0x07380000,
+    0x07300000, 0x07000000, 0x07480000, 0x07580000,
+    0x02280000, 0x02400000, 0x02080000, 0x02680000,
+    0x02500000, 0x02180000, 0x02200000, 0x02100000,
+    0x02700000, 0x02780000, 0x02600000, 0x02380000,
+    0x02300000, 0x02000000, 0x02480000, 0x02580000,
+    0x03280000, 0x03400000, 0x03080000, 0x03680000,
+    0x03500000, 0x03180000, 0x03200000, 0x03100000,
+    0x03700000, 0x03780000, 0x03600000, 0x03380000,
+    0x03300000, 0x03000000, 0x03480000, 0x03580000,
+    0x06280000, 0x06400000, 0x06080000, 0x06680000,
+    0x06500000, 0x06180000, 0x06200000, 0x06100000,
+    0x06700000, 0x06780000, 0x06600000, 0x06380000,
+    0x06300000, 0x06000000, 0x06480000, 0x06580000,
+    0x05a80000, 0x05c00000, 0x05880000, 0x05e80000,
+    0x05d00000, 0x05980000, 0x05a00000, 0x05900000,
+    0x05f00000, 0x05f80000, 0x05e00000, 0x05b80000,
+    0x05b00000, 0x05800000, 0x05c80000, 0x05d80000,
+    0x01280000, 0x01400000, 0x01080000, 0x01680000,
+    0x01500000, 0x01180000, 0x01200000, 0x01100000,
+    0x01700000, 0x01780000, 0x01600000, 0x01380000,
+    0x01300000, 0x01000000, 0x01480000, 0x01580000,
+    0x02a80000, 0x02c00000, 0x02880000, 0x02e80000,
+    0x02d00000, 0x02980000, 0x02a00000, 0x02900000,
+    0x02f00000, 0x02f80000, 0x02e00000, 0x02b80000,
+    0x02b00000, 0x02800000, 0x02c80000, 0x02d80000,
+    0x01a80000, 0x01c00000, 0x01880000, 0x01e80000,
+    0x01d00000, 0x01980000, 0x01a00000, 0x01900000,
+    0x01f00000, 0x01f80000, 0x01e00000, 0x01b80000,
+    0x01b00000, 0x01800000, 0x01c80000, 0x01d80000,
+    /* 2 */
+    0x30000002, 0x60000002, 0x38000002, 0x08000002,
+    0x28000002, 0x78000002, 0x68000002, 0x40000002,
+    0x20000002, 0x50000002, 0x48000002, 0x70000002,
+    0x00000002, 0x18000002, 0x58000002, 0x10000002,
+    0xb0000005, 0xe0000005, 0xb8000005, 0x88000005,
+    0xa8000005, 0xf8000005, 0xe8000005, 0xc0000005,
+    0xa0000005, 0xd0000005, 0xc8000005, 0xf0000005,
+    0x80000005, 0x98000005, 0xd8000005, 0x90000005,
+    0x30000005, 0x60000005, 0x38000005, 0x08000005,
+    0x28000005, 0x78000005, 0x68000005, 0x40000005,
+    0x20000005, 0x50000005, 0x48000005, 0x70000005,
+    0x00000005, 0x18000005, 0x58000005, 0x10000005,
+    0x30000000, 0x60000000, 0x38000000, 0x08000000,
+    0x28000000, 0x78000000, 0x68000000, 0x40000000,
+    0x20000000, 0x50000000, 0x48000000, 0x70000000,
+    0x00000000, 0x18000000, 0x58000000, 0x10000000,
+    0xb0000003, 0xe0000003, 0xb8000003, 0x88000003,
+    0xa8000003, 0xf8000003, 0xe8000003, 0xc0000003,
+    0xa0000003, 0xd0000003, 0xc8000003, 0xf0000003,
+    0x80000003, 0x98000003, 0xd8000003, 0x90000003,
+    0x30000001, 0x60000001, 0x38000001, 0x08000001,
+    0x28000001, 0x78000001, 0x68000001, 0x40000001,
+    0x20000001, 0x50000001, 0x48000001, 0x70000001,
+    0x00000001, 0x18000001, 0x58000001, 0x10000001,
+    0xb0000000, 0xe0000000, 0xb8000000, 0x88000000,
+    0xa8000000, 0xf8000000, 0xe8000000, 0xc0000000,
+    0xa0000000, 0xd0000000, 0xc8000000, 0xf0000000,
+    0x80000000, 0x98000000, 0xd8000000, 0x90000000,
+    0xb0000006, 0xe0000006, 0xb8000006, 0x88000006,
+    0xa8000006, 0xf8000006, 0xe8000006, 0xc0000006,
+    0xa0000006, 0xd0000006, 0xc8000006, 0xf0000006,
+    0x80000006, 0x98000006, 0xd8000006, 0x90000006,
+    0xb0000001, 0xe0000001, 0xb8000001, 0x88000001,
+    0xa8000001, 0xf8000001, 0xe8000001, 0xc0000001,
+    0xa0000001, 0xd0000001, 0xc8000001, 0xf0000001,
+    0x80000001, 0x98000001, 0xd8000001, 0x90000001,
+    0x30000003, 0x60000003, 0x38000003, 0x08000003,
+    0x28000003, 0x78000003, 0x68000003, 0x40000003,
+    0x20000003, 0x50000003, 0x48000003, 0x70000003,
+    0x00000003, 0x18000003, 0x58000003, 0x10000003,
+    0x30000004, 0x60000004, 0x38000004, 0x08000004,
+    0x28000004, 0x78000004, 0x68000004, 0x40000004,
+    0x20000004, 0x50000004, 0x48000004, 0x70000004,
+    0x00000004, 0x18000004, 0x58000004, 0x10000004,
+    0xb0000002, 0xe0000002, 0xb8000002, 0x88000002,
+    0xa8000002, 0xf8000002, 0xe8000002, 0xc0000002,
+    0xa0000002, 0xd0000002, 0xc8000002, 0xf0000002,
+    0x80000002, 0x98000002, 0xd8000002, 0x90000002,
+    0xb0000004, 0xe0000004, 0xb8000004, 0x88000004,
+    0xa8000004, 0xf8000004, 0xe8000004, 0xc0000004,
+    0xa0000004, 0xd0000004, 0xc8000004, 0xf0000004,
+    0x80000004, 0x98000004, 0xd8000004, 0x90000004,
+    0x30000006, 0x60000006, 0x38000006, 0x08000006,
+    0x28000006, 0x78000006, 0x68000006, 0x40000006,
+    0x20000006, 0x50000006, 0x48000006, 0x70000006,
+    0x00000006, 0x18000006, 0x58000006, 0x10000006,
+    0xb0000007, 0xe0000007, 0xb8000007, 0x88000007,
+    0xa8000007, 0xf8000007, 0xe8000007, 0xc0000007,
+    0xa0000007, 0xd0000007, 0xc8000007, 0xf0000007,
+    0x80000007, 0x98000007, 0xd8000007, 0x90000007,
+    0x30000007, 0x60000007, 0x38000007, 0x08000007,
+    0x28000007, 0x78000007, 0x68000007, 0x40000007,
+    0x20000007, 0x50000007, 0x48000007, 0x70000007,
+    0x00000007, 0x18000007, 0x58000007, 0x10000007,
+    /* 3 */
+    0x000000e8, 0x000000d8, 0x000000a0, 0x00000088,
+    0x00000098, 0x000000f8, 0x000000a8, 0x000000c8,
+    0x00000080, 0x000000d0, 0x000000f0, 0x000000b8,
+    0x000000b0, 0x000000c0, 0x00000090, 0x000000e0,
+    0x000007e8, 0x000007d8, 0x000007a0, 0x00000788,
+    0x00000798, 0x000007f8, 0x000007a8, 0x000007c8,
+    0x00000780, 0x000007d0, 0x000007f0, 0x000007b8,
+    0x000007b0, 0x000007c0, 0x00000790, 0x000007e0,
+    0x000006e8, 0x000006d8, 0x000006a0, 0x00000688,
+    0x00000698, 0x000006f8, 0x000006a8, 0x000006c8,
+    0x00000680, 0x000006d0, 0x000006f0, 0x000006b8,
+    0x000006b0, 0x000006c0, 0x00000690, 0x000006e0,
+    0x00000068, 0x00000058, 0x00000020, 0x00000008,
+    0x00000018, 0x00000078, 0x00000028, 0x00000048,
+    0x00000000, 0x00000050, 0x00000070, 0x00000038,
+    0x00000030, 0x00000040, 0x00000010, 0x00000060,
+    0x000002e8, 0x000002d8, 0x000002a0, 0x00000288,
+    0x00000298, 0x000002f8, 0x000002a8, 0x000002c8,
+    0x00000280, 0x000002d0, 0x000002f0, 0x000002b8,
+    0x000002b0, 0x000002c0, 0x00000290, 0x000002e0,
+    0x000003e8, 0x000003d8, 0x000003a0, 0x00000388,
+    0x00000398, 0x000003f8, 0x000003a8, 0x000003c8,
+    0x00000380, 0x000003d0, 0x000003f0, 0x000003b8,
+    0x000003b0, 0x000003c0, 0x00000390, 0x000003e0,
+    0x00000568, 0x00000558, 0x00000520, 0x00000508,
+    0x00000518, 0x00000578, 0x00000528, 0x00000548,
+    0x00000500, 0x00000550, 0x00000570, 0x00000538,
+    0x00000530, 0x00000540, 0x00000510, 0x00000560,
+    0x00000268, 0x00000258, 0x00000220, 0x00000208,
+    0x00000218, 0x00000278, 0x00000228, 0x00000248,
+    0x00000200, 0x00000250, 0x00000270, 0x00000238,
+    0x00000230, 0x00000240, 0x00000210, 0x00000260,
+    0x000004e8, 0x000004d8, 0x000004a0, 0x00000488,
+    0x00000498, 0x000004f8, 0x000004a8, 0x000004c8,
+    0x00000480, 0x000004d0, 0x000004f0, 0x000004b8,
+    0x000004b0, 0x000004c0, 0x00000490, 0x000004e0,
+    0x00000168, 0x00000158, 0x00000120, 0x00000108,
+    0x00000118, 0x00000178, 0x00000128, 0x00000148,
+    0x00000100, 0x00000150, 0x00000170, 0x00000138,
+    0x00000130, 0x00000140, 0x00000110, 0x00000160,
+    0x000001e8, 0x000001d8, 0x000001a0, 0x00000188,
+    0x00000198, 0x000001f8, 0x000001a8, 0x000001c8,
+    0x00000180, 0x000001d0, 0x000001f0, 0x000001b8,
+    0x000001b0, 0x000001c0, 0x00000190, 0x000001e0,
+    0x00000768, 0x00000758, 0x00000720, 0x00000708,
+    0x00000718, 0x00000778, 0x00000728, 0x00000748,
+    0x00000700, 0x00000750, 0x00000770, 0x00000738,
+    0x00000730, 0x00000740, 0x00000710, 0x00000760,
+    0x00000368, 0x00000358, 0x00000320, 0x00000308,
+    0x00000318, 0x00000378, 0x00000328, 0x00000348,
+    0x00000300, 0x00000350, 0x00000370, 0x00000338,
+    0x00000330, 0x00000340, 0x00000310, 0x00000360,
+    0x000005e8, 0x000005d8, 0x000005a0, 0x00000588,
+    0x00000598, 0x000005f8, 0x000005a8, 0x000005c8,
+    0x00000580, 0x000005d0, 0x000005f0, 0x000005b8,
+    0x000005b0, 0x000005c0, 0x00000590, 0x000005e0,
+    0x00000468, 0x00000458, 0x00000420, 0x00000408,
+    0x00000418, 0x00000478, 0x00000428, 0x00000448,
+    0x00000400, 0x00000450, 0x00000470, 0x00000438,
+    0x00000430, 0x00000440, 0x00000410, 0x00000460,
+    0x00000668, 0x00000658, 0x00000620, 0x00000608,
+    0x00000618, 0x00000678, 0x00000628, 0x00000648,
+    0x00000600, 0x00000650, 0x00000670, 0x00000638,
+    0x00000630, 0x00000640, 0x00000610, 0x00000660,
+  }
+};
+
+/*
+ *  A macro that performs a full encryption round of GOST 28147-89.
+ *  Temporary variables tmp assumed and variables r and l for left and right
+ *  blocks.
+ */
+#define GOST_ENCRYPT_ROUND(key1, key2, sbox) \
+  tmp = (key1) + r; \
+  l ^= (sbox)[0*256 + (tmp &amp; 0xff)] ^ (sbox)[1*256 + ((tmp &gt;&gt; 8) &amp; 0xff)] ^ \
+    (sbox)[2*256 + ((tmp &gt;&gt; 16) &amp; 0xff)] ^ (sbox)[3*256 + (tmp &gt;&gt; 24)]; \
+  tmp = (key2) + l; \
+  r ^= (sbox)[0*256 + (tmp &amp; 0xff)] ^ (sbox)[1*256 + ((tmp &gt;&gt; 8) &amp; 0xff)] ^ \
+    (sbox)[2*256 + ((tmp &gt;&gt; 16) &amp; 0xff)] ^ (sbox)[3*256 + (tmp &gt;&gt; 24)];
+
+/* encrypt a block with the given key */
+void gost28147_encrypt_simple (const uint32_t *key, const uint32_t *sbox,
+                               const uint32_t *in, uint32_t *out)
+{
+  uint32_t l, r, tmp;
+
+  r = in[0], l = in[1];
+  GOST_ENCRYPT_ROUND(key[0], key[1], sbox)
+  GOST_ENCRYPT_ROUND(key[2], key[3], sbox)
+  GOST_ENCRYPT_ROUND(key[4], key[5], sbox)
+  GOST_ENCRYPT_ROUND(key[6], key[7], sbox)
+  GOST_ENCRYPT_ROUND(key[0], key[1], sbox)
+  GOST_ENCRYPT_ROUND(key[2], key[3], sbox)
+  GOST_ENCRYPT_ROUND(key[4], key[5], sbox)
+  GOST_ENCRYPT_ROUND(key[6], key[7], sbox)
+  GOST_ENCRYPT_ROUND(key[0], key[1], sbox)
+  GOST_ENCRYPT_ROUND(key[2], key[3], sbox)
+  GOST_ENCRYPT_ROUND(key[4], key[5], sbox)
+  GOST_ENCRYPT_ROUND(key[6], key[7], sbox)
+  GOST_ENCRYPT_ROUND(key[7], key[6], sbox)
+  GOST_ENCRYPT_ROUND(key[5], key[4], sbox)
+  GOST_ENCRYPT_ROUND(key[3], key[2], sbox)
+  GOST_ENCRYPT_ROUND(key[1], key[0], sbox)
+  *out = l, *(out + 1) = r;
+}
diff --git a/gost28147.h b/gost28147.h
new file mode 100644
index 000000000000..83d8915b9d38
--- /dev/null
+++ b/gost28147.h
@@ -0,0 +1,63 @@
+/* gost28147.h
+
+   The GOST 28147-89 cipher function, described in RFC 5831.
+
+   Copyright (C) 2019 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_GOST28147_H_INCLUDED
+#define NETTLE_GOST28147_H_INCLUDED
+
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define gost28147_param_test_3411 nettle_gost28147_param_test_3411
+
+/* Private */
+#define gost28147_encrypt_simple nettle_gost28147_encrypt_simple
+
+struct gost28147_param
+{
+  uint32_t sbox[4*256];
+};
+
+extern const struct gost28147_param gost28147_param_test_3411;
+
+/* Internal interface for use by GOST R 34.11-94 */
+void gost28147_encrypt_simple (const uint32_t *key, const uint32_t *sbox,
+                               const uint32_t *in, uint32_t *out);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_GOST28147_H_INCLUDED */
diff --git a/gosthash94.c b/gosthash94.c
index e60c9ae5cddf..870235eefa34 100644
--- a/gosthash94.c
+++ b/gosthash94.c
@@ -1,5 +1,7 @@
-/* gost.c - an implementation of GOST Hash Function
+/* gosthash94.c - an implementation of GOST Hash Function
+ *
  * based on the Russian Standard GOST R 34.11-94.
+ * English description in RFC 5831.
  * See also RFC 4357.
  *
  * Copyright: 2009-2012 Aleksey Kravchenko &lt;rhash.admin@gmail.com&gt;
@@ -38,209 +40,7 @@
 #include "macros.h"
 #include "nettle-write.h"
 #include "gosthash94.h"
-
-/* pre-initialized GOST lookup tables based on rotated S-Box */
-static const uint32_t gosthash94_sbox[4][256] = {
-  {
-    0x72000, 0x75000, 0x74800, 0x71000, 0x76800,
-    0x74000, 0x70000, 0x77000, 0x73000, 0x75800,
-    0x70800, 0x76000, 0x73800, 0x77800, 0x72800,
-    0x71800, 0x5A000, 0x5D000, 0x5C800, 0x59000,
-    0x5E800, 0x5C000, 0x58000, 0x5F000, 0x5B000,
-    0x5D800, 0x58800, 0x5E000, 0x5B800, 0x5F800,
-    0x5A800, 0x59800, 0x22000, 0x25000, 0x24800,
-    0x21000, 0x26800, 0x24000, 0x20000, 0x27000,
-    0x23000, 0x25800, 0x20800, 0x26000, 0x23800,
-    0x27800, 0x22800, 0x21800, 0x62000, 0x65000,
-    0x64800, 0x61000, 0x66800, 0x64000, 0x60000,
-    0x67000, 0x63000, 0x65800, 0x60800, 0x66000,
-    0x63800, 0x67800, 0x62800, 0x61800, 0x32000,
-    0x35000, 0x34800, 0x31000, 0x36800, 0x34000,
-    0x30000, 0x37000, 0x33000, 0x35800, 0x30800,
-    0x36000, 0x33800, 0x37800, 0x32800, 0x31800,
-    0x6A000, 0x6D000, 0x6C800, 0x69000, 0x6E800,
-    0x6C000, 0x68000, 0x6F000, 0x6B000, 0x6D800,
-    0x68800, 0x6E000, 0x6B800, 0x6F800, 0x6A800,
-    0x69800, 0x7A000, 0x7D000, 0x7C800, 0x79000,
-    0x7E800, 0x7C000, 0x78000, 0x7F000, 0x7B000,
-    0x7D800, 0x78800, 0x7E000, 0x7B800, 0x7F800,
-    0x7A800, 0x79800, 0x52000, 0x55000, 0x54800,
-    0x51000, 0x56800, 0x54000, 0x50000, 0x57000,
-    0x53000, 0x55800, 0x50800, 0x56000, 0x53800,
-    0x57800, 0x52800, 0x51800, 0x12000, 0x15000,
-    0x14800, 0x11000, 0x16800, 0x14000, 0x10000,
-    0x17000, 0x13000, 0x15800, 0x10800, 0x16000,
-    0x13800, 0x17800, 0x12800, 0x11800, 0x1A000,
-    0x1D000, 0x1C800, 0x19000, 0x1E800, 0x1C000,
-    0x18000, 0x1F000, 0x1B000, 0x1D800, 0x18800,
-    0x1E000, 0x1B800, 0x1F800, 0x1A800, 0x19800,
-    0x42000, 0x45000, 0x44800, 0x41000, 0x46800,
-    0x44000, 0x40000, 0x47000, 0x43000, 0x45800,
-    0x40800, 0x46000, 0x43800, 0x47800, 0x42800,
-    0x41800, 0xA000,  0xD000,  0xC800,  0x9000,
-    0xE800,  0xC000,  0x8000,  0xF000,  0xB000,
-    0xD800,  0x8800,  0xE000,  0xB800,  0xF800,
-    0xA800,  0x9800,  0x2000,  0x5000,  0x4800,
-    0x1000,  0x6800,  0x4000,  0x0,     0x7000,
-    0x3000,  0x5800,  0x800,   0x6000,  0x3800,
-    0x7800,  0x2800,  0x1800,  0x3A000, 0x3D000,
-    0x3C800, 0x39000, 0x3E800, 0x3C000, 0x38000,
-    0x3F000, 0x3B000, 0x3D800, 0x38800, 0x3E000,
-    0x3B800, 0x3F800, 0x3A800, 0x39800, 0x2A000,
-    0x2D000, 0x2C800, 0x29000, 0x2E800, 0x2C000,
-    0x28000, 0x2F000, 0x2B000, 0x2D800, 0x28800,
-    0x2E000, 0x2B800, 0x2F800, 0x2A800, 0x29800,
-    0x4A000, 0x4D000, 0x4C800, 0x49000, 0x4E800,
-    0x4C000, 0x48000, 0x4F000, 0x4B000, 0x4D800,
-    0x48800, 0x4E000, 0x4B800, 0x4F800, 0x4A800,
-    0x49800
-  }, {
-    0x3A80000, 0x3C00000, 0x3880000, 0x3E80000, 0x3D00000,
-    0x3980000, 0x3A00000, 0x3900000, 0x3F00000, 0x3F80000,
-    0x3E00000, 0x3B80000, 0x3B00000, 0x3800000, 0x3C80000,
-    0x3D80000, 0x6A80000, 0x6C00000, 0x6880000, 0x6E80000,
-    0x6D00000, 0x6980000, 0x6A00000, 0x6900000, 0x6F00000,
-    0x6F80000, 0x6E00000, 0x6B80000, 0x6B00000, 0x6800000,
-    0x6C80000, 0x6D80000, 0x5280000, 0x5400000, 0x5080000,
-    0x5680000, 0x5500000, 0x5180000, 0x5200000, 0x5100000,
-    0x5700000, 0x5780000, 0x5600000, 0x5380000, 0x5300000,
-    0x5000000, 0x5480000, 0x5580000, 0xA80000,  0xC00000,
-    0x880000,  0xE80000,  0xD00000,  0x980000,  0xA00000,
-    0x900000,  0xF00000,  0xF80000,  0xE00000,  0xB80000,
-    0xB00000,  0x800000,  0xC80000,  0xD80000,  0x280000,
-    0x400000,  0x80000,   0x680000,  0x500000,  0x180000,
-    0x200000,  0x100000,  0x700000,  0x780000,  0x600000,
-    0x380000,  0x300000,  0x0,       0x480000,  0x580000,
-    0x4280000, 0x4400000, 0x4080000, 0x4680000, 0x4500000,
-    0x4180000, 0x4200000, 0x4100000, 0x4700000, 0x4780000,
-    0x4600000, 0x4380000, 0x4300000, 0x4000000, 0x4480000,
-    0x4580000, 0x4A80000, 0x4C00000, 0x4880000, 0x4E80000,
-    0x4D00000, 0x4980000, 0x4A00000, 0x4900000, 0x4F00000,
-    0x4F80000, 0x4E00000, 0x4B80000, 0x4B00000, 0x4800000,
-    0x4C80000, 0x4D80000, 0x7A80000, 0x7C00000, 0x7880000,
-    0x7E80000, 0x7D00000, 0x7980000, 0x7A00000, 0x7900000,
-    0x7F00000, 0x7F80000, 0x7E00000, 0x7B80000, 0x7B00000,
-    0x7800000, 0x7C80000, 0x7D80000, 0x7280000, 0x7400000,
-    0x7080000, 0x7680000, 0x7500000, 0x7180000, 0x7200000,
-    0x7100000, 0x7700000, 0x7780000, 0x7600000, 0x7380000,
-    0x7300000, 0x7000000, 0x7480000, 0x7580000, 0x2280000,
-    0x2400000, 0x2080000, 0x2680000, 0x2500000, 0x2180000,
-    0x2200000, 0x2100000, 0x2700000, 0x2780000, 0x2600000,
-    0x2380000, 0x2300000, 0x2000000, 0x2480000, 0x2580000,
-    0x3280000, 0x3400000, 0x3080000, 0x3680000, 0x3500000,
-    0x3180000, 0x3200000, 0x3100000, 0x3700000, 0x3780000,
-    0x3600000, 0x3380000, 0x3300000, 0x3000000, 0x3480000,
-    0x3580000, 0x6280000, 0x6400000, 0x6080000, 0x6680000,
-    0x6500000, 0x6180000, 0x6200000, 0x6100000, 0x6700000,
-    0x6780000, 0x6600000, 0x6380000, 0x6300000, 0x6000000,
-    0x6480000, 0x6580000, 0x5A80000, 0x5C00000, 0x5880000,
-    0x5E80000, 0x5D00000, 0x5980000, 0x5A00000, 0x5900000,
-    0x5F00000, 0x5F80000, 0x5E00000, 0x5B80000, 0x5B00000,
-    0x5800000, 0x5C80000, 0x5D80000, 0x1280000, 0x1400000,
-    0x1080000, 0x1680000, 0x1500000, 0x1180000, 0x1200000,
-    0x1100000, 0x1700000, 0x1780000, 0x1600000, 0x1380000,
-    0x1300000, 0x1000000, 0x1480000, 0x1580000, 0x2A80000,
-    0x2C00000, 0x2880000, 0x2E80000, 0x2D00000, 0x2980000,
-    0x2A00000, 0x2900000, 0x2F00000, 0x2F80000, 0x2E00000,
-    0x2B80000, 0x2B00000, 0x2800000, 0x2C80000, 0x2D80000,
-    0x1A80000, 0x1C00000, 0x1880000, 0x1E80000, 0x1D00000,
-    0x1980000, 0x1A00000, 0x1900000, 0x1F00000, 0x1F80000,
-    0x1E00000, 0x1B80000, 0x1B00000, 0x1800000, 0x1C80000,
-    0x1D80000
-  }, {
-    0x30000002, 0x60000002, 0x38000002, 0x8000002,
-    0x28000002, 0x78000002, 0x68000002, 0x40000002, 
-    0x20000002, 0x50000002, 0x48000002, 0x70000002, 
-    0x2,        0x18000002, 0x58000002, 0x10000002, 
-    0xB0000005, 0xE0000005, 0xB8000005, 0x88000005,
-    0xA8000005, 0xF8000005, 0xE8000005, 0xC0000005,
-    0xA0000005, 0xD0000005, 0xC8000005, 0xF0000005, 
-    0x80000005, 0x98000005, 0xD8000005, 0x90000005, 
-    0x30000005, 0x60000005, 0x38000005, 0x8000005, 
-    0x28000005, 0x78000005, 0x68000005, 0x40000005,
-    0x20000005, 0x50000005, 0x48000005, 0x70000005, 
-    0x5,        0x18000005, 0x58000005, 0x10000005, 
-    0x30000000, 0x60000000, 0x38000000, 0x8000000, 
-    0x28000000, 0x78000000, 0x68000000, 0x40000000, 
-    0x20000000, 0x50000000, 0x48000000, 0x70000000,
-    0x0,        0x18000000, 0x58000000, 0x10000000, 
-    0xB0000003, 0xE0000003, 0xB8000003, 0x88000003, 
-    0xA8000003, 0xF8000003, 0xE8000003, 0xC0000003, 
-    0xA0000003, 0xD0000003, 0xC8000003, 0xF0000003, 
-    0x80000003, 0x98000003, 0xD8000003, 0x90000003,
-    0x30000001, 0x60000001, 0x38000001, 0x8000001,
-    0x28000001, 0x78000001, 0x68000001, 0x40000001, 
-    0x20000001, 0x50000001, 0x48000001, 0x70000001, 
-    0x1,        0x18000001, 0x58000001, 0x10000001, 
-    0xB0000000, 0xE0000000, 0xB8000000, 0x88000000,
-    0xA8000000, 0xF8000000, 0xE8000000, 0xC0000000,
-    0xA0000000, 0xD0000000, 0xC8000000, 0xF0000000, 
-    0x80000000, 0x98000000, 0xD8000000, 0x90000000, 
-    0xB0000006, 0xE0000006, 0xB8000006, 0x88000006, 
-    0xA8000006, 0xF8000006, 0xE8000006, 0xC0000006,
-    0xA0000006, 0xD0000006, 0xC8000006, 0xF0000006,
-    0x80000006, 0x98000006, 0xD8000006, 0x90000006, 
-    0xB0000001, 0xE0000001, 0xB8000001, 0x88000001, 
-    0xA8000001, 0xF8000001, 0xE8000001, 0xC0000001, 
-    0xA0000001, 0xD0000001, 0xC8000001, 0xF0000001,
-    0x80000001, 0x98000001, 0xD8000001, 0x90000001,
-    0x30000003, 0x60000003, 0x38000003, 0x8000003, 
-    0x28000003, 0x78000003, 0x68000003, 0x40000003, 
-    0x20000003, 0x50000003, 0x48000003, 0x70000003, 
-    0x3,        0x18000003, 0x58000003, 0x10000003,
-    0x30000004, 0x60000004, 0x38000004, 0x8000004,
-    0x28000004, 0x78000004, 0x68000004, 0x40000004, 
-    0x20000004, 0x50000004, 0x48000004, 0x70000004, 
-    0x4,        0x18000004, 0x58000004, 0x10000004, 
-    0xB0000002, 0xE0000002, 0xB8000002, 0x88000002,
-    0xA8000002, 0xF8000002, 0xE8000002, 0xC0000002,
-    0xA0000002, 0xD0000002, 0xC8000002, 0xF0000002, 
-    0x80000002, 0x98000002, 0xD8000002, 0x90000002, 
-    0xB0000004, 0xE0000004, 0xB8000004, 0x88000004, 
-    0xA8000004, 0xF8000004, 0xE8000004, 0xC0000004,
-    0xA0000004, 0xD0000004, 0xC8000004, 0xF0000004,
-    0x80000004, 0x98000004, 0xD8000004, 0x90000004, 
-    0x30000006, 0x60000006, 0x38000006, 0x8000006, 
-    0x28000006, 0x78000006, 0x68000006, 0x40000006, 
-    0x20000006, 0x50000006, 0x48000006, 0x70000006,
-    0x6,        0x18000006, 0x58000006, 0x10000006, 
-    0xB0000007, 0xE0000007, 0xB8000007, 0x88000007, 
-    0xA8000007, 0xF8000007, 0xE8000007, 0xC0000007, 
-    0xA0000007, 0xD0000007, 0xC8000007, 0xF0000007, 
-    0x80000007, 0x98000007, 0xD8000007, 0x90000007,
-    0x30000007, 0x60000007, 0x38000007, 0x8000007,
-    0x28000007, 0x78000007, 0x68000007, 0x40000007, 
-    0x20000007, 0x50000007, 0x48000007, 0x70000007, 
-    0x7,        0x18000007, 0x58000007, 0x10000007
-  }, {
-    0xE8,  0xD8,  0xA0,  0x88,  0x98,  0xF8,  0xA8,  0xC8,  0x80,  0xD0,
-    0xF0,  0xB8,  0xB0,  0xC0,  0x90,  0xE0,  0x7E8, 0x7D8, 0x7A0, 0x788,
-    0x798, 0x7F8, 0x7A8, 0x7C8, 0x780, 0x7D0, 0x7F0, 0x7B8, 0x7B0, 0x7C0,
-    0x790, 0x7E0, 0x6E8, 0x6D8, 0x6A0, 0x688, 0x698, 0x6F8, 0x6A8, 0x6C8,
-    0x680, 0x6D0, 0x6F0, 0x6B8, 0x6B0, 0x6C0, 0x690, 0x6E0, 0x68,  0x58,
-    0x20,  0x8,   0x18,  0x78,  0x28,   0x48,  0x0,   0x50,  0x70,  0x38,
-    0x30,  0x40,  0x10,  0x60,  0x2E8, 0x2D8, 0x2A0, 0x288, 0x298, 0x2F8,
-    0x2A8, 0x2C8, 0x280, 0x2D0, 0x2F0, 0x2B8, 0x2B0, 0x2C0, 0x290, 0x2E0,
-    0x3E8, 0x3D8, 0x3A0, 0x388, 0x398, 0x3F8, 0x3A8, 0x3C8, 0x380, 0x3D0,
-    0x3F0, 0x3B8, 0x3B0, 0x3C0, 0x390, 0x3E0, 0x568, 0x558, 0x520, 0x508,
-    0x518, 0x578, 0x528, 0x548, 0x500, 0x550, 0x570, 0x538, 0x530, 0x540,
-    0x510, 0x560, 0x268, 0x258, 0x220, 0x208, 0x218, 0x278, 0x228, 0x248,
-    0x200, 0x250, 0x270, 0x238, 0x230, 0x240, 0x210, 0x260, 0x4E8, 0x4D8,
-    0x4A0, 0x488, 0x498, 0x4F8, 0x4A8, 0x4C8, 0x480, 0x4D0, 0x4F0, 0x4B8,
-    0x4B0, 0x4C0, 0x490, 0x4E0, 0x168, 0x158, 0x120, 0x108, 0x118, 0x178,
-    0x128, 0x148, 0x100, 0x150, 0x170, 0x138, 0x130, 0x140, 0x110, 0x160,
-    0x1E8, 0x1D8, 0x1A0, 0x188, 0x198, 0x1F8, 0x1A8, 0x1C8, 0x180, 0x1D0,
-    0x1F0, 0x1B8, 0x1B0, 0x1C0, 0x190, 0x1E0, 0x768, 0x758, 0x720, 0x708,
-    0x718, 0x778, 0x728, 0x748, 0x700, 0x750, 0x770, 0x738, 0x730, 0x740,
-    0x710, 0x760, 0x368, 0x358, 0x320, 0x308, 0x318, 0x378, 0x328, 0x348,
-    0x300, 0x350, 0x370, 0x338, 0x330, 0x340, 0x310, 0x360, 0x5E8, 0x5D8,
-    0x5A0, 0x588, 0x598, 0x5F8, 0x5A8, 0x5C8, 0x580, 0x5D0, 0x5F0, 0x5B8,
-    0x5B0, 0x5C0, 0x590, 0x5E0, 0x468, 0x458, 0x420, 0x408, 0x418, 0x478,
-    0x428, 0x448, 0x400, 0x450, 0x470, 0x438, 0x430, 0x440, 0x410, 0x460,
-    0x668, 0x658, 0x620, 0x608, 0x618, 0x678, 0x628, 0x648, 0x600, 0x650,
-    0x670, 0x638, 0x630, 0x640, 0x610, 0x660
-  }
-};
+#include "gost28147.h"
 
 /**
  * Initialize algorithm context before calculating hash
@@ -254,40 +54,6 @@ gosthash94_init (struct gosthash94_ctx *ctx)
     memset (ctx, 0, sizeof (struct gosthash94_ctx));
 }
 
-/*
- *  A macro that performs a full encryption round of GOST 28147-89.
- *  Temporary variables tmp assumed and variables r and l for left and right
- *  blocks.
- */
-#define GOST_ENCRYPT_ROUND(key1, key2, sbox) \
-  tmp = (key1) + r; \
-  l ^= (sbox)[0][tmp &amp; 0xff] ^ (sbox)[1][(tmp &gt;&gt; 8) &amp; 0xff] ^ \
-    (sbox)[2][(tmp &gt;&gt; 16) &amp; 0xff] ^ (sbox)[3][tmp &gt;&gt; 24]; \
-  tmp = (key2) + l; \
-  r ^= (sbox)[0][tmp &amp; 0xff] ^ (sbox)[1][(tmp &gt;&gt; 8) &amp; 0xff] ^ \
-    (sbox)[2][(tmp &gt;&gt; 16) &amp; 0xff] ^ (sbox)[3][tmp &gt;&gt; 24];
-
-/* encrypt a block with the given key */
-#define GOST_ENCRYPT(result, i, key, hash, sbox) \
-  r = hash[i], l = hash[i + 1]; \
-  GOST_ENCRYPT_ROUND(key[0], key[1], sbox) \
-  GOST_ENCRYPT_ROUND(key[2], key[3], sbox) \
-  GOST_ENCRYPT_ROUND(key[4], key[5], sbox) \
-  GOST_ENCRYPT_ROUND(key[6], key[7], sbox) \
-  GOST_ENCRYPT_ROUND(key[0], key[1], sbox) \
-  GOST_ENCRYPT_ROUND(key[2], key[3], sbox) \
-  GOST_ENCRYPT_ROUND(key[4], key[5], sbox) \
-  GOST_ENCRYPT_ROUND(key[6], key[7], sbox) \
-  GOST_ENCRYPT_ROUND(key[0], key[1], sbox) \
-  GOST_ENCRYPT_ROUND(key[2], key[3], sbox) \
-  GOST_ENCRYPT_ROUND(key[4], key[5], sbox) \
-  GOST_ENCRYPT_ROUND(key[6], key[7], sbox) \
-  GOST_ENCRYPT_ROUND(key[7], key[6], sbox) \
-  GOST_ENCRYPT_ROUND(key[5], key[4], sbox) \
-  GOST_ENCRYPT_ROUND(key[3], key[2], sbox) \
-  GOST_ENCRYPT_ROUND(key[1], key[0], sbox) \
-  result[i] = l, result[i + 1] = r;
-
 /**
  * The core transformation. Process a 512-bit block.
  *
@@ -299,7 +65,6 @@ gost_block_compress (struct gosthash94_ctx *ctx, const uint32_t *block)
 {
     unsigned i;
     uint32_t key[8], u[8], v[8], w[8], s[8];
-    uint32_t l, r, tmp;
 
     /* u := hash, v := &lt;256-bit message block&gt; */
     memcpy (u, ctx-&gt;hash, sizeof (u));
@@ -341,7 +106,7 @@ gost_block_compress (struct gosthash94_ctx *ctx, const uint32_t *block)
               ((w[5] &amp; 0xff000000) &gt;&gt; 8) | (w[7] &amp; 0xff000000);
 
           /* encryption: s_i := E_{key_i} (h_i) */
-          GOST_ENCRYPT (s, i, key, ctx-&gt;hash, gosthash94_sbox);
+          gost28147_encrypt_simple (key, gost28147_param_test_3411.sbox, &amp;ctx-&gt;hash[i], &amp;s[i]);
 
           if (i == 0)
             {
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190708221720</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-08 22:17:20-0400</timestampReceived><subject>Re: [PATCH 1/6] Start separating GOST 28147-89 from GOST R 34.11-94</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; Hash function GOST R 34.11-94 (gosthash94) in its compression function
&gt; uses Russian block cipher (GOST 28147-89, Magma). Start separating block
&gt; cipher code from hash function code. For now there is no public
&gt; interface for this cipher, it will be added later.

I'm having an initial look at this, with a few comments.

&gt; --- /dev/null
&gt; +++ b/gost28147.c
&gt; +/*
&gt; + *  A macro that performs a full encryption round of GOST 28147-89.
&gt; + *  Temporary variables tmp assumed and variables r and l for left and right
&gt; + *  blocks.
&gt; + */
&gt; +#define GOST_ENCRYPT_ROUND(key1, key2, sbox) \
&gt; +  tmp = (key1) + r; \
&gt; +  l ^= (sbox)[0*256 + (tmp &amp; 0xff)] ^ (sbox)[1*256 + ((tmp &gt;&gt; 8) &amp; 0xff)] ^ \
&gt; +    (sbox)[2*256 + ((tmp &gt;&gt; 16) &amp; 0xff)] ^ (sbox)[3*256 + (tmp &gt;&gt; 24)]; \
&gt; +  tmp = (key2) + l; \
&gt; +  r ^= (sbox)[0*256 + (tmp &amp; 0xff)] ^ (sbox)[1*256 + ((tmp &gt;&gt; 8) &amp; 0xff)] ^ \
&gt; +    (sbox)[2*256 + ((tmp &gt;&gt; 16) &amp; 0xff)] ^ (sbox)[3*256 + (tmp &gt;&gt; 24)];

This code is just moved around in this patch, but I'd like to note that
it's preferable to always wrap function-like macros like this in do { ... }
while (0), and when used terminate with ;. And avoid using surrounding
variables; r and l could be macro arguments, and tmp (with some likely
unique prefix) could be a local in the do { ... } while block.

&gt; --- /dev/null
&gt; +++ b/gost28147.h
&gt; @@ -0,0 +1,63 @@

&gt; +struct gost28147_param
&gt; +{
&gt; +  uint32_t sbox[4*256];
&gt; +};

Why change to a flat array, and not keep it as

  uint32_t sbox[4][256];

?

&gt; +extern const struct gost28147_param gost28147_param_test_3411;

I find "test" in the name a bit odd. Is there a reason for that? And
declaration should probably not be in an installed header file, but in
gost-internal.h or so.

&gt; +/* Internal interface for use by GOST R 34.11-94 */
&gt; +void gost28147_encrypt_simple (const uint32_t *key, const uint32_t *sbox,
&gt; +                               const uint32_t *in, uint32_t *out);

Same here: if internal, shouldn't be in an installed header file. And
"simple" looks a bit odd. 

Should the sbox argument be of type const gost28147_param * ?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190704070646</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-04 07:06:46-0400</timestampReceived><subject>Re: [PATCH] nettle-types: drop w field from nettle_block16</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; Hmm. This patch has to wait a bit, sent it without actual testing.
&gt; nettle_block16.w is used by eax (easy to copy with) and gcm
&gt; (might need performance checks on 32-bit architectures).

I would expect that using the uint64_t field is as efficient (or better,
if compilers do it really well), but I haven't checked the generated
code on 32-bit archs.

Can we delete the w field from the union without considering it an abi
break? I'd expect size and alignment of the union to be unchanged on all
but the most obscure architectures. If not, that part of the change has
to wait.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190414073342</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-04-14 07:33:42-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; This patch adds the SIV-CMAC algorithm to nettle (an update of the
&gt; previous attempt). It is an atypical cipher which fits into the
&gt; encrypt_message interface.

Thanks. Some comments below:

&gt; --- a/nettle-types.h
&gt; +++ b/nettle-types.h
&gt; @@ -78,6 +78,21 @@ typedef void *nettle_realloc_func(void *ctx, void *p, size_t length);
&gt;  /* Ciphers */
&gt;  typedef void nettle_set_key_func(void *ctx, const uint8_t *key);
&gt;  
&gt; +/* AEAD ciphers */
&gt; +typedef void
&gt; +nettle_encrypt_message(void *ctx,
&gt; +		       size_t nlength, const uint8_t *nonce,
&gt; +		       size_t alength, const uint8_t *adata,
&gt; +		       size_t tlength,
&gt; +		       size_t clength, uint8_t *dst, const uint8_t *src);
&gt; +
&gt; +typedef int
&gt; +nettle_decrypt_message(void *ctx,
&gt; +		       size_t nlength, const uint8_t *nonce,
&gt; +		       size_t alength, const uint8_t *adata,
&gt; +		       size_t tlength,
&gt; +		       size_t mlength, uint8_t *dst, const uint8_t *src);
&gt; +

In this patch, these types used in tests only. But I imagine you'd like
something in nettle-meta to represent a message-oriented aead?

&gt; +@acronym{SIV-CMAC} mode is a combination of counter mode with message
&gt; +authentication based on @acronym{CMAC}. Unlike other counter @acronym{AEAD}
&gt; +modes, it provides protection against accidental nonce misuse, making it
&gt; +a good choice for stateless-servers that cannot ensure nonce
&gt; uniqueness.

Some detail on the nonce-reuse would be helpful. As I understood RFC
5297, the nonce used in SIV is only to make the ciphertexts of otherwise
identical messages look different to the attacker.

&gt; --- /dev/null
&gt; +++ b/siv-aes128-cmac.c
&gt; @@ -0,0 +1,79 @@
[...]
&gt; +void
&gt; +siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
&gt; +				size_t nlength, const uint8_t *nonce,
&gt; +				size_t alength, const uint8_t *adata,
&gt; +				size_t tlength,
&gt; +				size_t slength, uint8_t *dst, const uint8_t *src)
&gt; +{
&gt; +  assert(tlength == SIV_DIGEST_SIZE);

The tlength argument doesn't look that useful, do we need it?. Also, I
think we agreed that the message length argument should be the size of
the *destination* area, i.e., ciphertext size for encrypt_message (see
ccm_*_encrypt_message):

&gt; --- /dev/null
&gt; +++ b/siv-cmac.c
&gt; @@ -0,0 +1,194 @@

&gt; +/* This is a common structure for AES-128 and AES-256 thus
&gt; + * for the cipher part we simply pad to the maximum structure
&gt; + * size plus 16 bytes to account for any alignment difference in
&gt; + * the original structures */
&gt; +struct cmac128_syn {
&gt; +  struct cmac128_ctx ctx;
&gt; +  struct {
&gt; +    uint8_t pad[NETTLE_MAX_CIPHER16_CONTEXT_SIZE+16];
&gt; +  } cipher;
&gt; +};

I don't think this guarantees any alignment. You would either need
soemthing like

  struct cipher_storage {
    union {
      uint64_t u64;
      char c[NETTLE_MAX_CIPHER16_CONTEXT_SIZE];
    } storage;
  };
  ...
  CMAC128_CTX(cipher_storage) ctx;

or use TMP_ALLOC_ALIGN (but in the latter case, you can't use the
CMAC128_* macros). Or let caller pass in the cipher context (see last
comment in this mail)

&gt; +static
&gt; +void _siv_s2v(const struct nettle_cipher *nc,
&gt; +	      const uint8_t *s2vk, size_t alength, const uint8_t *adata,
&gt; +              size_t nlength, const uint8_t *nonce,
&gt; +              size_t plength, const uint8_t *pdata,
&gt; +              uint8_t *v)
&gt; +{
&gt; +  struct cmac128_syn ctx;
&gt; +  union nettle_block16 D, S, T;
&gt; +  const uint8_t const_one[16] = {
&gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
&gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x01
&gt; +  };
&gt; +  const uint8_t const_zero[16] = {
&gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
&gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
&gt; +  };

Use static const.

&gt; +  assert(nc-&gt;context_size &lt;= NETTLE_MAX_CIPHER16_CONTEXT_SIZE);
&gt; +
&gt; +  /* ensure we have enough size of context plus any padding size */
&gt; +  CMAC128_SET_KEY(&amp;ctx, nc-&gt;set_encrypt_key, nc-&gt;encrypt, s2vk);
&gt; +
&gt; +  if (nlength == 0 &amp;&amp; alength == 0) {
&gt; +    CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, 16, const_one);
&gt; +    CMAC128_DIGEST(&amp;ctx, nc-&gt;encrypt, 16, v);
&gt; +    return;
&gt; +  }

Shouldn't the plaintext, plength, pdata, still be processed in this
case?

In this function, you treat empty associated data or nonce as those
elements missing in the input vector to S2V. E.g., if both adata and
nonce are empty, the input vector is { plaintext }, one single element.
But it could also be { "", "", plaintext }, with three elements, the
first two being empty strings.

To me, this sounds like a likely source of interop problems. Since RFC
5297 is general and allows the application to decide on the number of
elements and meaning of the input vector, it doesn't give much
guidance on this, as far as I see. The crucial case is when an
application specifies that SIV is used with associated data and/or a
nonce, but allows an empty string for either of those.

Also encoding empty adata, nonce "foo" in the same way as adata "foo",
empty nonce, seems like a subtlety contrary to the spirit of 1.3.3.

&gt; +void
&gt; +siv_cmac_set_key(struct siv_cmac_ctx *ctx, void *cipher,
&gt; +		 const struct nettle_cipher *nc,
&gt; +		 const uint8_t *key)
&gt; +{
&gt; +	unsigned skey_size = nc-&gt;key_size;
&gt; +
&gt; +	assert(skey_size &lt;= SIV_MAX_KEY_SIZE/2);
&gt; +	memcpy(ctx-&gt;s2vk, key, skey_size);

I think this function should do the underlying key setup also for the
cipher instance used for s2v, not just store the key for later. So then
the function would be

  void
  siv_cmac_set_key(void *cmac_cipher, void *ctr_cipher,
  		 const struct nettle_cipher *nc,
  		 const uint8_t *key)

with no struct siv_cmac_ctx.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190414120631</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2019-04-14 12:06:31-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

On Sun, 2019-04-14 at 09:33 +0200, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; 
&gt; &gt; This patch adds the SIV-CMAC algorithm to nettle (an update of the
&gt; &gt; previous attempt). It is an atypical cipher which fits into the
&gt; &gt; encrypt_message interface.
&gt; 
&gt; Thanks. Some comments below:
&gt; 
&gt; &gt; --- a/nettle-types.h
&gt; &gt; +++ b/nettle-types.h
&gt; &gt; @@ -78,6 +78,21 @@ typedef void *nettle_realloc_func(void *ctx,
&gt; &gt; void *p, size_t length);
&gt; &gt;  /* Ciphers */
&gt; &gt;  typedef void nettle_set_key_func(void *ctx, const uint8_t *key);
&gt; &gt;  
&gt; &gt; +/* AEAD ciphers */
&gt; &gt; +typedef void
&gt; &gt; +nettle_encrypt_message(void *ctx,
&gt; &gt; +		       size_t nlength, const uint8_t *nonce,
&gt; &gt; +		       size_t alength, const uint8_t *adata,
&gt; &gt; +		       size_t tlength,
&gt; &gt; +		       size_t clength, uint8_t *dst, const uint8_t
&gt; &gt; *src);
&gt; &gt; +
&gt; &gt; +typedef int
&gt; &gt; +nettle_decrypt_message(void *ctx,
&gt; &gt; +		       size_t nlength, const uint8_t *nonce,
&gt; &gt; +		       size_t alength, const uint8_t *adata,
&gt; &gt; +		       size_t tlength,
&gt; &gt; +		       size_t mlength, uint8_t *dst, const uint8_t
&gt; &gt; *src);
&gt; &gt; +
&gt; 
&gt; In this patch, these types used in tests only. But I imagine you'd
&gt; like something in nettle-meta to represent a message-oriented aead?

I have never used the nettle-meta interface for ciphers, so I'm not
sure about whether that's needed or not. CCM for example is not
represented there. Would it make sense to separate the meta interface
from the addition of the cipher, or should I avoid adding the type
completely?


&gt; 
&gt; &gt; +@acronym{SIV-CMAC} mode is a combination of counter mode with
&gt; &gt; message
&gt; &gt; +authentication based on @acronym{CMAC}. Unlike other counter
&gt; &gt; @acronym{AEAD}
&gt; &gt; +modes, it provides protection against accidental nonce misuse,
&gt; &gt; making it
&gt; &gt; +a good choice for stateless-servers that cannot ensure nonce
&gt; &gt; uniqueness.
&gt; 
&gt; Some detail on the nonce-reuse would be helpful. As I understood RFC
&gt; 5297, the nonce used in SIV is only to make the ciphertexts of
&gt; otherwise identical messages look different to the attacker.

My understanding of this RFC is that a primary goal as in 1.3.2, is to
be resistant to nonce misuse (e.g., if you re-use the nonce). I can add
more information but I am not sure I understand which direction of
detail you mean. What are you missing or think is unclear in the text?

&gt; &gt; --- /dev/null
&gt; &gt; +++ b/siv-aes128-cmac.c
&gt; &gt; @@ -0,0 +1,79 @@
&gt; [...]
&gt; &gt; +void
&gt; &gt; +siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
&gt; &gt; +				size_t nlength, const uint8_t *nonce,
&gt; &gt; +				size_t alength, const uint8_t *adata,
&gt; &gt; +				size_t tlength,
&gt; &gt; +				size_t slength, uint8_t *dst, const
&gt; &gt; uint8_t *src)
&gt; &gt; +{
&gt; &gt; +  assert(tlength == SIV_DIGEST_SIZE);
&gt; 
&gt; The tlength argument doesn't look that useful, do we need it?.

If we remove the tlength then it would not implement the
nettle_encrypt_message_func(). My goal in keeping tlength was to have a
consistent interface across the message oriented ciphers.

&gt; Also, I
&gt; think we agreed that the message length argument should be the size
&gt; of
&gt; the *destination* area, i.e., ciphertext size for encrypt_message
&gt; (see
&gt; ccm_*_encrypt_message):

I can name it clength, but there is the implicit assumption that
clength = slength right? Otherwise if a larger buffer is provided for
destination, I do not see how it figure the source size.

&gt; &gt; --- /dev/null
&gt; &gt; +++ b/siv-cmac.c
&gt; &gt; @@ -0,0 +1,194 @@
&gt; &gt; +/* This is a common structure for AES-128 and AES-256 thus
&gt; &gt; + * for the cipher part we simply pad to the maximum structure
&gt; &gt; + * size plus 16 bytes to account for any alignment difference in
&gt; &gt; + * the original structures */
&gt; &gt; +struct cmac128_syn {
&gt; &gt; +  struct cmac128_ctx ctx;
&gt; &gt; +  struct {
&gt; &gt; +    uint8_t pad[NETTLE_MAX_CIPHER16_CONTEXT_SIZE+16];
&gt; &gt; +  } cipher;
&gt; &gt; +};
&gt; 
&gt; I don't think this guarantees any alignment. You would either need
&gt; soemthing like
&gt; 
&gt;   struct cipher_storage {
&gt;     union {
&gt;       uint64_t u64;
&gt;       char c[NETTLE_MAX_CIPHER16_CONTEXT_SIZE];
&gt;     } storage;
&gt;   };
&gt;   ...
&gt;   CMAC128_CTX(cipher_storage) ctx;

The goal here was not to make c aligned, but to have enough pad so that
when this structure is read as cmac_aes128_ctx, to account for any
alignment in the latter. Maybe actually I should do just that, and add
the real types as union.

&gt; or use TMP_ALLOC_ALIGN (but in the latter case, you can't use the
&gt; CMAC128_* macros). Or let caller pass in the cipher context (see last
&gt; comment in this mail)
&gt; 
&gt; &gt; +static
&gt; &gt; +void _siv_s2v(const struct nettle_cipher *nc,
&gt; &gt; +	      const uint8_t *s2vk, size_t alength, const uint8_t
&gt; &gt; *adata,
&gt; &gt; +              size_t nlength, const uint8_t *nonce,
&gt; &gt; +              size_t plength, const uint8_t *pdata,
&gt; &gt; +              uint8_t *v)
&gt; &gt; +{
&gt; &gt; +  struct cmac128_syn ctx;
&gt; &gt; +  union nettle_block16 D, S, T;
&gt; &gt; +  const uint8_t const_one[16] = {
&gt; &gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
&gt; &gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x01
&gt; &gt; +  };
&gt; &gt; +  const uint8_t const_zero[16] = {
&gt; &gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
&gt; &gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
&gt; &gt; +  };
&gt; 
&gt; Use static const.

Done. Why do you prefer this?

&gt; &gt; +  assert(nc-&gt;context_size &lt;= NETTLE_MAX_CIPHER16_CONTEXT_SIZE);
&gt; &gt; +
&gt; &gt; +  /* ensure we have enough size of context plus any padding size
&gt; &gt; */
&gt; &gt; +  CMAC128_SET_KEY(&amp;ctx, nc-&gt;set_encrypt_key, nc-&gt;encrypt, s2vk);
&gt; &gt; +
&gt; &gt; +  if (nlength == 0 &amp;&amp; alength == 0) {
&gt; &gt; +    CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, 16, const_one);
&gt; &gt; +    CMAC128_DIGEST(&amp;ctx, nc-&gt;encrypt, 16, v);
&gt; &gt; +    return;
&gt; &gt; +  }
&gt; 
&gt; Shouldn't the plaintext, plength, pdata, still be processed in this
&gt; case?
&gt; 
&gt; In this function, you treat empty associated data or nonce as those
&gt; elements missing in the input vector to S2V. E.g., if both adata and
&gt; nonce are empty, the input vector is { plaintext }, one single
&gt; element.
&gt; But it could also be { "", "", plaintext }, with three elements, the
&gt; first two being empty strings.
&gt; 
&gt; To me, this sounds like a likely source of interop problems. Since
&gt; RFC
&gt; 5297 is general and allows the application to decide on the number of
&gt; elements and meaning of the input vector, it doesn't give much
&gt; guidance on this, as far as I see. The crucial case is when an
&gt; application specifies that SIV is used with associated data and/or a
&gt; nonce, but allows an empty string for either of those.
&gt; 
&gt; Also encoding empty adata, nonce "foo" in the same way as adata
&gt; "foo",
&gt; empty nonce, seems like a subtlety contrary to the spirit of 1.3.3.

I am not sure if the message interface can be used for derivation, but
I'll need some time to answer your questions above.

&gt; 
&gt; &gt; +void
&gt; &gt; +siv_cmac_set_key(struct siv_cmac_ctx *ctx, void *cipher,
&gt; &gt; +		 const struct nettle_cipher *nc,
&gt; &gt; +		 const uint8_t *key)
&gt; &gt; +{
&gt; &gt; +	unsigned skey_size = nc-&gt;key_size;
&gt; &gt; +
&gt; &gt; +	assert(skey_size &lt;= SIV_MAX_KEY_SIZE/2);
&gt; &gt; +	memcpy(ctx-&gt;s2vk, key, skey_size);
&gt; 
&gt; I think this function should do the underlying key setup also for the
&gt; cipher instance used for s2v, not just store the key for later. So
&gt; then the function would be
&gt; 
&gt;   void
&gt;   siv_cmac_set_key(void *cmac_cipher, void *ctr_cipher,
&gt;   		 const struct nettle_cipher *nc,
&gt;   		 const uint8_t *key)
&gt; 
&gt; with no struct siv_cmac_ctx.

Why do you think that? Are there any benefits in that way?

regards,
Nikos


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190415061147</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-04-15 06:11:47-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; On Sun, 2019-04-14 at 09:33 +0200, Niels Möller wrote:

&gt;&gt; &gt; +typedef int
&gt;&gt; &gt; +nettle_decrypt_message(void *ctx,
&gt;&gt; &gt; +		       size_t nlength, const uint8_t *nonce,
&gt;&gt; &gt; +		       size_t alength, const uint8_t *adata,
&gt;&gt; &gt; +		       size_t tlength,
&gt;&gt; &gt; +		       size_t mlength, uint8_t *dst, const uint8_t
&gt;&gt; &gt; *src);
&gt;&gt; &gt; +
&gt;&gt; 
&gt;&gt; In this patch, these types used in tests only. But I imagine you'd
&gt;&gt; like something in nettle-meta to represent a message-oriented aead?
&gt;
&gt; I have never used the nettle-meta interface for ciphers, so I'm not
&gt; sure about whether that's needed or not. CCM for example is not
&gt; represented there. Would it make sense to separate the meta interface
&gt; from the addition of the cipher, or should I avoid adding the type
&gt; completely?

Put these typedefs in testutils.h for now, if you find them useful for
the tests.

&gt;&gt; Some detail on the nonce-reuse would be helpful. As I understood RFC
&gt;&gt; 5297, the nonce used in SIV is only to make the ciphertexts of
&gt;&gt; otherwise identical messages look different to the attacker.

&gt; My understanding of this RFC is that a primary goal as in 1.3.2, is to
&gt; be resistant to nonce misuse (e.g., if you re-use the nonce). I can add
&gt; more information but I am not sure I understand which direction of
&gt; detail you mean. What are you missing or think is unclear in the text?

Something brief on what the consequences are if one accidentally or
deliberately uses the same nonce twice. You could even quote the rtc, if
it expresses it well and concisely.

&gt;
&gt;&gt; &gt; --- /dev/null
&gt;&gt; &gt; +++ b/siv-aes128-cmac.c
&gt;&gt; &gt; @@ -0,0 +1,79 @@
&gt;&gt; [...]
&gt;&gt; &gt; +void
&gt;&gt; &gt; +siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
&gt;&gt; &gt; +				size_t nlength, const uint8_t *nonce,
&gt;&gt; &gt; +				size_t alength, const uint8_t *adata,
&gt;&gt; &gt; +				size_t tlength,
&gt;&gt; &gt; +				size_t slength, uint8_t *dst, const
&gt;&gt; &gt; uint8_t *src)
&gt;&gt; &gt; +{
&gt;&gt; &gt; +  assert(tlength == SIV_DIGEST_SIZE);
&gt;&gt; 
&gt;&gt; The tlength argument doesn't look that useful, do we need it?.
&gt;
&gt; If we remove the tlength then it would not implement the
&gt; nettle_encrypt_message_func(). My goal in keeping tlength was to have a
&gt; consistent interface across the message oriented ciphers.

I'd prefer to not have the tlength argument. If we do a
nettle-meta-style interface for messge-oriented aead, we may use a fix
tlength, so that, e.g., CCM with full tag length (16 bytes) nd truncated
tag (say, 4 bytes) would be considered distinct aead algorithms.

&gt;&gt; Also, I
&gt;&gt; think we agreed that the message length argument should be the size
&gt;&gt; of
&gt;&gt; the *destination* area, i.e., ciphertext size for encrypt_message
&gt;&gt; (see
&gt;&gt; ccm_*_encrypt_message):
&gt;
&gt; I can name it clength, but there is the implicit assumption that
&gt; clength = slength right? Otherwise if a larger buffer is provided for
&gt; destination, I do not see how it figure the source size.

clength == tlength + slength. This is what the docs for the
corresponding ccm functions say (which do have tlength argument, since
ccm supports truncated tag) say:

  The CCM message fuctions provides a simple interface that will perform
  authentication and message encryption in a single function call.  The
  length of the cleartext is given by MLENGTH and the length of the
  ciphertext is given by CLENGTH, always exactly TLENGTH bytes longer than
  the corresponding plaintext.  The length argument passed to a function
  is always the size for the result, CLENGTH for the encryption functions,
  and MLENGTH for the decryption functions.

&gt;&gt; &gt; --- /dev/null
&gt;&gt; &gt; +++ b/siv-cmac.c
&gt;&gt; &gt; @@ -0,0 +1,194 @@
&gt;&gt; &gt; +/* This is a common structure for AES-128 and AES-256 thus
&gt;&gt; &gt; + * for the cipher part we simply pad to the maximum structure
&gt;&gt; &gt; + * size plus 16 bytes to account for any alignment difference in
&gt;&gt; &gt; + * the original structures */
&gt;&gt; &gt; +struct cmac128_syn {
&gt;&gt; &gt; +  struct cmac128_ctx ctx;
&gt;&gt; &gt; +  struct {
&gt;&gt; &gt; +    uint8_t pad[NETTLE_MAX_CIPHER16_CONTEXT_SIZE+16];
&gt;&gt; &gt; +  } cipher;
&gt;&gt; &gt; +};
&gt;&gt; 
&gt;&gt; I don't think this guarantees any alignment. You would either need
&gt;&gt; soemthing like
&gt;&gt; 
&gt;&gt;   struct cipher_storage {
&gt;&gt;     union {
&gt;&gt;       uint64_t u64;
&gt;&gt;       char c[NETTLE_MAX_CIPHER16_CONTEXT_SIZE];
&gt;&gt;     } storage;
&gt;&gt;   };
&gt;&gt;   ...
&gt;&gt;   CMAC128_CTX(cipher_storage) ctx;
&gt;
&gt; The goal here was not to make c aligned, but to have enough pad so that
&gt; when this structure is read as cmac_aes128_ctx, to account for any
&gt; alignment in the latter. Maybe actually I should do just that, and add
&gt; the real types as union.

I think it's important that the context struct gets the alignment it
needs. Now, since cmac128_ctx has aligned contents, uint8_t pad will
likely get sufficient alignment anyway, but I think it's a bit brittle
to depend on that; an uint8_t[...] inside a struct usually doesn't get
larger alignment than a single byte.

&gt;&gt; or use TMP_ALLOC_ALIGN (but in the latter case, you can't use the
&gt;&gt; CMAC128_* macros). Or let caller pass in the cipher context (see last
&gt;&gt; comment in this mail)
&gt;&gt; 
&gt;&gt; &gt; +static
&gt;&gt; &gt; +void _siv_s2v(const struct nettle_cipher *nc,
&gt;&gt; &gt; +	      const uint8_t *s2vk, size_t alength, const uint8_t
&gt;&gt; &gt; *adata,
&gt;&gt; &gt; +              size_t nlength, const uint8_t *nonce,
&gt;&gt; &gt; +              size_t plength, const uint8_t *pdata,
&gt;&gt; &gt; +              uint8_t *v)
&gt;&gt; &gt; +{
&gt;&gt; &gt; +  struct cmac128_syn ctx;
&gt;&gt; &gt; +  union nettle_block16 D, S, T;
&gt;&gt; &gt; +  const uint8_t const_one[16] = {
&gt;&gt; &gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
&gt;&gt; &gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x01
&gt;&gt; &gt; +  };
&gt;&gt; &gt; +  const uint8_t const_zero[16] = {
&gt;&gt; &gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
&gt;&gt; &gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
&gt;&gt; &gt; +  };
&gt;&gt; 
&gt;&gt; Use static const.
&gt;
&gt; Done. Why do you prefer this?

Do ensure that the constants are allocated in the rodata segment. With
just const, that's an abbreviation for const auto, and the compiler
typically allocates them on the stack and generates code to initialize
them on each call, like any other auto variables. 

Not entirely sure why the compiler doesn't optimize it better, but using
rodata for variables not explicitly declared static might violate some
subtle requirement of the C standard. (I think const in C++ works
differently, but I don't understand all the subtleties there either).

In addition, it would be good if these could be typed as nettle_block16
rather than char arrays, for alignment. That's easy for the const_zero block
(this is also done in ax.c:eax_set_key), but I'm not sure of the top of my head
how to write a union initializer for a 

  static const union nettle_block16 const_one = {...}

&gt;&gt; &gt; +void
&gt;&gt; &gt; +siv_cmac_set_key(struct siv_cmac_ctx *ctx, void *cipher,
&gt;&gt; &gt; +		 const struct nettle_cipher *nc,
&gt;&gt; &gt; +		 const uint8_t *key)
&gt;&gt; &gt; +{
&gt;&gt; &gt; +	unsigned skey_size = nc-&gt;key_size;
&gt;&gt; &gt; +
&gt;&gt; &gt; +	assert(skey_size &lt;= SIV_MAX_KEY_SIZE/2);
&gt;&gt; &gt; +	memcpy(ctx-&gt;s2vk, key, skey_size);
&gt;&gt; 
&gt;&gt; I think this function should do the underlying key setup also for the
&gt;&gt; cipher instance used for s2v, not just store the key for later. So
&gt;&gt; then the function would be
&gt;&gt; 
&gt;&gt;   void
&gt;&gt;   siv_cmac_set_key(void *cmac_cipher, void *ctr_cipher,
&gt;&gt;   		 const struct nettle_cipher *nc,
&gt;&gt;   		 const uint8_t *key)
&gt;&gt; 
&gt;&gt; with no struct siv_cmac_ctx.
&gt;
&gt; Why do you think that? Are there any benefits in that way?

The idea of the set_key function is to do all preparations that don't
depend on the actual message, so they don't have to be repeated. And I
think it's a bit odd to handle the keying of the two involved cipher
contexts so differently.

Slightly related: I think the cipher context struct(s) should be const
void*, when passed to siv_cmac_encrypt_message and
siv_cmac_decrypt_message. One usecase may be a server calling set_key at
startup, and then spawning worker threads encrypting or decrypting
messages. If all key-related data is const by the time the threads are
spawned, it can be shared without any mutexes or the like.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190417093706</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2019-04-17 09:37:06-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

On Sun, 2019-04-14 at 09:33 +0200, Niels Möller wrote:
&gt; +  assert(nc-&gt;context_size &lt;= NETTLE_MAX_CIPHER16_CONTEXT_SIZE);
&gt; &gt; +
&gt; &gt; +  /* ensure we have enough size of context plus any padding size
&gt; &gt; */
&gt; &gt; +  CMAC128_SET_KEY(&amp;ctx, nc-&gt;set_encrypt_key, nc-&gt;encrypt, s2vk);
&gt; &gt; +
&gt; &gt; +  if (nlength == 0 &amp;&amp; alength == 0) {
&gt; &gt; +    CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, 16, const_one);
&gt; &gt; +    CMAC128_DIGEST(&amp;ctx, nc-&gt;encrypt, 16, v);
&gt; &gt; +    return;
&gt; &gt; +  }
&gt; 
&gt; Shouldn't the plaintext, plength, pdata, still be processed in this
&gt; case?

Right, there should be an and plength == 0 as well. I've added an two
additional test cases to check these cases, and the case where
everything is zero, doesn't seem to interoperate with two libs I tried.

Hopefully it is issue of this code.

https://github.com/miscreant/miscreant/issues/194
https://github.com/dfoxfranke/libaes_siv/issues/14

&gt; In this function, you treat empty associated data or nonce as those
&gt; elements missing in the input vector to S2V. E.g., if both adata and
&gt; nonce are empty, the input vector is { plaintext }, one single
&gt; element.
&gt; But it could also be { "", "", plaintext }, with three elements, the
&gt; first two being empty strings.

While the low level function could handle it, it is not exposed to be
called directly (mainly intentionally as this cipher introduces a very
new paradigm which I do not quite see much of practical uses).

This patch only adds the higher level AEAD API only, so this case
cannot happen as we don't have the notion of empty string
in nettle. We can introduce it of course, though we may be opening a
can of worms as not only empty strings are undefined in terms of AEAD
API [0], but what would these mean in the other implementations?

[0]. https://tools.ietf.org/html/rfc5116#section-2

&gt; To me, this sounds like a likely source of interop problems. Since
&gt; RFC
&gt; 5297 is general and allows the application to decide on the number of
&gt; elements and meaning of the input vector, it doesn't give much
&gt; guidance on this, as far as I see. The crucial case is when an
&gt; application specifies that SIV is used with associated data and/or a
&gt; nonce, but allows an empty string for either of those.

I agree on that. That's one of the reasons I stuck on the higher level
AEAD API (expressed by the message APIs in nettle). I added two
sentences in the documentation about it.

&gt; &gt;&gt; I think this function should do the underlying key setup also for
&gt; the
&gt; &gt;&gt; cipher instance used for s2v, not just store the key for later. So
&gt; &gt;&gt; then the function would be
&gt; &gt;&gt; 
&gt; &gt;&gt;   void
&gt; &gt;&gt;   siv_cmac_set_key(void *cmac_cipher, void *ctr_cipher,
&gt; The idea of the set_key function is to do all preparations that don't
&gt; depend on the actual message, so they don't have to be repeated. And
&gt; I
&gt; think it's a bit odd to handle the keying of the two involved cipher
&gt; contexts so differently.

Done. It needed some reorganization, and cmac128_syn is still needed in
an ugly simulation of the CMAC structure setup to use the macros. I
have kept the union 

The attached version should address the comments so far and also
changes cmac128_set_key to use nettle_block16 as well.

regards,
Nikos


["0001-cmac-use-nettle_block16-for-const-variable.patch" (0001-cmac-use-nettle_block16-for-const-variable.patch)]

From a0ceb52e7bef137226ec5a1013d154e5516d2ba4 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Tue, 16 Apr 2019 20:19:17 +0200
Subject: [PATCH 1/2] cmac: use nettle_block16 for const variable

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
---
 cmac.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/cmac.c b/cmac.c
index ed3b5eb8..01fee79e 100644
--- a/cmac.c
+++ b/cmac.c
@@ -73,15 +73,15 @@ void
 cmac128_set_key(struct cmac128_ctx *ctx, const void *cipher,
 		nettle_cipher_func *encrypt)
 {
-  static const uint8_t const_zero[] = {
-    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
+  static const union nettle_block16 const_zero = { .b = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00 }
   };
   union nettle_block16 *L = &amp;ctx-&gt;block;
   memset(ctx, 0, sizeof(*ctx));
 
   /* step 1 - generate subkeys k1 and k2 */
-  encrypt(cipher, 16, L-&gt;b, const_zero);
+  encrypt(cipher, 16, L-&gt;b, const_zero.b);
 
   block_mulx(&amp;ctx-&gt;K1, L);
   block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
-- 
2.20.1


["0002-Added-support-for-AES_SIV_CMAC_256-and-AES_SIV_CMAC_.patch" (0002-Added-support-for-AES_SIV_CMAC_256-and-AES_SIV_CMAC_.patch)]

From c85011ce5fd60cd4c941319b78cd567d14b2ec85 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Sat, 20 Jan 2018 10:36:05 +0100
Subject: [PATCH 2/2] Added support for AES_SIV_CMAC_256 and AES_SIV_CMAC_512

This AEAD algorithm provides a way to make nonce-reuse a not critical
issue. That is particular useful to stateless servers that cannot ensure
that the nonce will not repeat. This cipher is used by
draft-ietf-ntp-using-nts-for-ntp-17.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 Makefile.in                |   4 +-
 cmac-internal.h            |  54 ++++++
 cmac.c                     |  15 +-
 nettle-internal.h          |   2 +
 nettle.texinfo             |  94 +++++++++-
 siv-aes128-cmac.c          |  75 ++++++++
 siv-aes256-cmac.c          |  75 ++++++++
 siv-cmac.c                 | 196 +++++++++++++++++++++
 siv-cmac.h                 | 131 ++++++++++++++
 testsuite/.gitignore       |   2 +
 testsuite/.test-rules.make |   3 +
 testsuite/Makefile.in      |   2 +-
 testsuite/siv-test.c       | 350 +++++++++++++++++++++++++++++++++++++
 testsuite/testutils.h      |  13 ++
 14 files changed, 1005 insertions(+), 11 deletions(-)
 create mode 100644 cmac-internal.h
 create mode 100644 siv-aes128-cmac.c
 create mode 100644 siv-aes256-cmac.c
 create mode 100644 siv-cmac.c
 create mode 100644 siv-cmac.h
 create mode 100644 testsuite/siv-test.c

diff --git a/Makefile.in b/Makefile.in
index 440de9f7..90ee61d7 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -89,6 +89,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 camellia256-meta.c \
 		 cast128.c cast128-meta.c cbc.c \
 		 ccm.c ccm-aes128.c ccm-aes192.c ccm-aes256.c cfb.c \
+		 siv-cmac.c siv-aes128-cmac.c siv-aes256-cmac.c \
 		 cnd-memcpy.c \
 		 chacha-crypt.c chacha-core-internal.c \
 		 chacha-poly1305.c chacha-poly1305-meta.c \
@@ -198,7 +199,8 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  gcm.h gosthash94.h hmac.h \
 	  knuth-lfib.h hkdf.h \
 	  macros.h \
-	  cmac.h \
+	  cmac.h cmac-internal.h \
+	  siv-cmac.h siv-cmac-internal.h \
 	  md2.h md4.h \
 	  md5.h md5-compat.h \
 	  memops.h memxor.h \
diff --git a/cmac-internal.h b/cmac-internal.h
new file mode 100644
index 00000000..789588e6
--- /dev/null
+++ b/cmac-internal.h
@@ -0,0 +1,54 @@
+/* cmac.h
+
+   CMAC mode internal functions
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   Contributed by Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_CMAC_INTERNAL_H_INCLUDED
+#define NETTLE_CMAC_INTERNAL_H_INCLUDED
+
+#include "cmac.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define _cmac128_block_mulx _nettle_cmac128_block_mulx
+
+void _cmac128_block_mulx(union nettle_block16 *out,
+			 const union nettle_block16 *in);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CMAC_INTERNAL_H_INCLUDED */
diff --git a/cmac.c b/cmac.c
index 01fee79e..8be1cca4 100644
--- a/cmac.c
+++ b/cmac.c
@@ -44,13 +44,13 @@
 
 #include "memxor.h"
 #include "nettle-internal.h"
+#include "cmac-internal.h"
 #include "macros.h"
 
 /* shift one and XOR with 0x87. */
 #if WORDS_BIGENDIAN
-static void
-block_mulx(union nettle_block16 *dst,
-	   const union nettle_block16 *src)
+void _cmac128_block_mulx(union nettle_block16 *dst,
+			 const union nettle_block16 *src)
 {
   uint64_t carry = src-&gt;u64[0] &gt;&gt; 63;
   dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
@@ -59,9 +59,8 @@ block_mulx(union nettle_block16 *dst,
 #else /* !WORDS_BIGENDIAN */
 #define LE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
                      (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
-static void
-block_mulx(union nettle_block16 *dst,
-	   const union nettle_block16 *src)
+void _cmac128_block_mulx(union nettle_block16 *dst,
+			 const union nettle_block16 *src)
 {
   uint64_t carry = (src-&gt;u64[0] &amp; 0x80) &gt;&gt; 7;
   dst-&gt;u64[0] = LE_SHIFT(src-&gt;u64[0]) | ((src-&gt;u64[1] &amp; 0x80) &lt;&lt; 49);
@@ -83,8 +82,8 @@ cmac128_set_key(struct cmac128_ctx *ctx, const void *cipher,
   /* step 1 - generate subkeys k1 and k2 */
   encrypt(cipher, 16, L-&gt;b, const_zero.b);
 
-  block_mulx(&amp;ctx-&gt;K1, L);
-  block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
+  _cmac128_block_mulx(&amp;ctx-&gt;K1, L);
+  _cmac128_block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
 }
 
 #define MIN(x,y) ((x)&lt;(y)?(x):(y))
diff --git a/nettle-internal.h b/nettle-internal.h
index dc379f1f..2937a710 100644
--- a/nettle-internal.h
+++ b/nettle-internal.h
@@ -78,6 +78,8 @@
 #define NETTLE_MAX_HASH_CONTEXT_SIZE (sizeof(struct sha3_224_ctx))
 #define NETTLE_MAX_SEXP_ASSOC 17
 #define NETTLE_MAX_CIPHER_BLOCK_SIZE 32
+/* maximum context size of 128-bit block ciphers */
+#define NETTLE_MAX_CIPHER16_CONTEXT_SIZE (sizeof(struct aes256_ctx))
 
 /* Doesn't quite fit with the other algorithms, because of the weak
  * keys. Weak keys are not reported, the functions will simply crash
diff --git a/nettle.texinfo b/nettle.texinfo
index 596c7098..f853f3e2 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -97,6 +97,7 @@ Cipher modes
 * CFB and CFB8::
 * GCM::                         
 * CCM::                         
+* SIV-CMAC::
 
 Keyed Hash Functions
 
@@ -2565,6 +2566,7 @@ more adventurous alternative, in particular if performance is \
                important.
 * GCM::                         
 * CCM::                         
 * ChaCha-Poly1305::
+* SIV-CMAC::
 * nettle_aead abstraction::
 @end menu
 
@@ -3212,7 +3214,7 @@ These are identical to @code{ccm_encrypt_message} and \
@code{ccm_decrypt_message}  except that @var{cipher} and @var{f} are replaced with a \
context structure.  @end deftypefun
 
-@node ChaCha-Poly1305, nettle_aead abstraction, CCM, Authenticated encryption
+@node ChaCha-Poly1305, SIV-CMAC, CCM, Authenticated encryption
 @comment  node-name,  next,  previous,  up
 @subsection ChaCha-Poly1305
 
@@ -3295,6 +3297,96 @@ smaller than @code{CHACHA_POLY1305_DIGEST_SIZE}, only the \
first  @var{length} octets of the digest are written.
 @end deftypefun
 
+@node SIV-CMAC, nettle_aead abstraction, ChaCha-Poly1305, Authenticated encryption
+@comment  node-name,  next,  previous,  up
+@subsection Counter with CBC-MAC mode
+
+@cindex SIV mode
+@cindex SIV-CMAC mode
+
+@acronym{SIV-CMAC} mode is a combination of counter mode with message
+authentication based on @acronym{CMAC}. Unlike other counter @acronym{AEAD}
+modes, it provides protection against accidental nonce misuse, making it
+a good choice for stateless-servers that cannot ensure nonce uniqueness.
+It is constructed on top of a block cipher which must have a block size of
+128 bits. Nettle's support for @acronym{SIV-CMAC} consists of
+a message encryption and authentication interface, for
+@acronym{SIV-CMAC} using AES as the underlying block cipher.
+When a nonce is re-used with this mode, message authenticity is retained
+however an attacker can determine whether the same plaintext was protected
+with the two messages sharing the nonce.
+These interfaces are defined in @file{&lt;nettle/siv-cmac.h&gt;}.
+
+Unlike other @acronym{AEAD} mode in @acronym{SIV-CMAC} the initialization
+vector serves as the tag. That means that in the generated ciphertext
+the tag precedes the ciphertext.
+
+Note also, that the @acronym{SIV-CMAC} algorithm introduces the notion
+of authenticated data which consist of multiple components. For example
+with @acronym{SIV-CMAC} the authentication tag of data @code{X} followed
+by @code{Y}, is different than the concatenated data @code{X || Y}. The interfaces
+described below follow the @acronym{AEAD} paradigm and do not allow access
+to this feature.
+
+@subsubsection General interface
+
+@defvr Constant SIV_BLOCK_SIZE
+@acronym{SIV-CMAC}'s block size, 16.
+@end defvr
+
+@defvr Constant SIV_DIGEST_SIZE
+Size of the @acronym{SIV-CMAC} digest or initialization vector, 16.
+@end defvr
+
+@defvr Constant SIV_MIN_NONCE_SIZE
+The the minimumsizes for an @acronym{SIV-CMAC} nonce, 0
+@end defvr
+
+@subsubsection @acronym{SIV-CMAC}-@acronym{AES} interface
+
+The @acronym{AES} @acronym{SIV-CMAC} functions provide an API for using
+@acronym{SIV-CMAC} mode with the @acronym{AES} block ciphers. The parameters
+all have the same meaning as the general and message interfaces, except
+that the @var{cipher}, @var{f}, and @var{ctx} parameters are replaced
+with an @acronym{AES} context structure, and a set-key function must be
+called before using any of the other functions in this interface.
+
+@deftp {Context struct} {struct siv_aes128_cmac_ctx}
+Holds state corresponding to a particular message encrypted using the
+AES-128 block cipher.
+@end deftp
+
+@deftp {Context struct} {struct siv_aes256_cmac_ctx}
+Holds state corresponding to a particular message encrypted using the
+AES-256 block cipher.
+@end deftp
+
+@deftypefun void siv_aes128_cmac_set_key (struct siv_aes128_cmac_ctx *@var{ctx}, \
const uint8_t *@var{key}) +@deftypefunx void siv_aes256_cmac_set_key (struct \
siv_aes256_cmac_ctx *@var{ctx}, const uint8_t *@var{key}) +Initializes the encryption \
key for the AES block cipher. One of these +functions must be called before any of \
the other functions in the +@acronym{AES} @acronym{SIV-CMAC} interface.
+@end deftypefun
+
+@deftypefun void siv_aes128_cmac_encrypt_message (struct siv_aes128_cmac_ctx \
*@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, \
const uint8_t *@var{adata}, size_t @var{clength}, uint8_t *@var{dst}, const uint8_t \
*@var{src}) +@deftypefunx void siv_aes256_cmac_encrypt_message (struct \
siv_aes256_cmac_ctx *@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, \
size_t @var{alength}, const uint8_t *@var{adata}, size_t @var{clength}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +Computes the message digest from the \
@var{adata} and @var{src} +parameters, encrypts the plaintext from @var{src}, \
prepends the +initialization vector to the ciphertext and outputs it to @var{dst}.
+The @var{clength} variable must be equal to the length of @var{src}
+plus @code{SIV_DIGEST_SIZE}.
+
+@end deftypefun
+
+@deftypefun int siv_aes128_cmac_decrypt_message (struct siv_aes128_cmac_ctx \
*@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, \
const uint8_t *@var{adata}, size_t @var{mlength}, uint8_t *@var{dst}, const uint8_t \
*@var{src}) +@deftypefunx int siv_aes256_cmac_decrypt_message (struct \
siv_aes128_cmac_ctx *@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, \
size_t @var{alength}, const uint8_t *@var{adata}, size_t @var{mlength}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +Decrypts the ciphertext from @var{src}, \
outputs the plaintext to +@var{dst}, recalculates the initialization vector from \
@var{adata} and the +plaintext. If the values of the received and calculated \
initialization vector +are equal, this will return 1 indicating a valid and \
authenticated +message. Otherwise, this function will return zero.
+@end deftypefun
+
 @node nettle_aead abstraction, , ChaCha-Poly1305, Authenticated encryption
 @comment  node-name,  next,  previous,  up
 @subsection The @code{struct nettle_aead} abstraction
diff --git a/siv-aes128-cmac.c b/siv-aes128-cmac.c
new file mode 100644
index 00000000..793279d1
--- /dev/null
+++ b/siv-aes128-cmac.c
@@ -0,0 +1,75 @@
+/* siv-aes128.c
+
+   AES-SIV, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "aes.h"
+#include "siv-cmac.h"
+#include "cmac.h"
+#include "ctr.h"
+#include "memxor.h"
+#include "memops.h"
+#include "cmac-internal.h"
+
+void
+siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const uint8_t *key)
+{
+  siv_cmac_set_key(&amp;ctx-&gt;siv_cmac, &amp;ctx-&gt;siv_cipher, &amp;nettle_aes128, key);
+}
+
+void
+siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t clength, uint8_t *dst, const uint8_t *src)
+{
+  siv_cmac_encrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes128, &amp;ctx-&gt;siv_cipher,
+			   nlength, nonce, alength, adata,
+			   clength, dst, src);
+}
+
+int
+siv_aes128_cmac_decrypt_message(struct siv_aes128_cmac_ctx *ctx,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  return siv_cmac_decrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes128, &amp;ctx-&gt;siv_cipher,
+				  nlength, nonce, alength, adata,
+				  mlength, dst, src);
+}
diff --git a/siv-aes256-cmac.c b/siv-aes256-cmac.c
new file mode 100644
index 00000000..61cd1163
--- /dev/null
+++ b/siv-aes256-cmac.c
@@ -0,0 +1,75 @@
+/* siv-aes128.c
+
+   AES-SIV, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "aes.h"
+#include "siv-cmac.h"
+#include "cmac.h"
+#include "ctr.h"
+#include "memxor.h"
+#include "memops.h"
+#include "cmac-internal.h"
+
+void
+siv_aes256_cmac_set_key(struct siv_aes256_cmac_ctx *ctx, const uint8_t *key)
+{
+  siv_cmac_set_key(&amp;ctx-&gt;siv_cmac, &amp;ctx-&gt;siv_cipher, &amp;nettle_aes256, key);
+}
+
+void
+siv_aes256_cmac_encrypt_message(struct siv_aes256_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t clength, uint8_t *dst, const uint8_t *src)
+{
+  siv_cmac_encrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes256, &amp;ctx-&gt;siv_cipher,
+			   nlength, nonce, alength, adata,
+			   clength, dst, src);
+}
+
+int
+siv_aes256_cmac_decrypt_message(struct siv_aes256_cmac_ctx *ctx,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  return siv_cmac_decrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes256, &amp;ctx-&gt;siv_cipher,
+				  nlength, nonce, alength, adata,
+				  mlength, dst, src);
+}
diff --git a/siv-cmac.c b/siv-cmac.c
new file mode 100644
index 00000000..94f65b0f
--- /dev/null
+++ b/siv-cmac.c
@@ -0,0 +1,196 @@
+/* siv-cmac.c
+
+   SIV-CMAC, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "aes.h"
+#include "siv-cmac.h"
+#include "cmac.h"
+#include "ctr.h"
+#include "memxor.h"
+#include "memops.h"
+#include "cmac-internal.h"
+#include "nettle-internal.h"
+
+/* This is only to allow the CMAC macros to expand in
+ * _siv_s2v */
+struct cmac128_syn {
+  struct cmac128_ctx ctx;
+  union {
+    uint64_t pad1[2]; /* to force a good alignment */
+    uint8_t pad[NETTLE_MAX_CIPHER16_CONTEXT_SIZE+16];
+  } cipher;
+};
+
+static
+void _siv_s2v(const struct nettle_cipher *nc,
+	      struct cmac128_syn *ctx,
+	      size_t alength, const uint8_t *adata,
+              size_t nlength, const uint8_t *nonce,
+              size_t plength, const uint8_t *pdata,
+              uint8_t *v)
+{
+  union nettle_block16 D, S, T;
+  static const union nettle_block16 const_one = { .b = {
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }
+  };
+  static const union nettle_block16 const_zero = { .b = {
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
+  };
+
+  assert(nc-&gt;context_size &lt;= NETTLE_MAX_CIPHER16_CONTEXT_SIZE);
+
+  if (nlength == 0 &amp;&amp; alength == 0 &amp;&amp; plength == 0) {
+    CMAC128_UPDATE(ctx, nc-&gt;encrypt, 16, const_one.b);
+    CMAC128_DIGEST(ctx, nc-&gt;encrypt, 16, v);
+    return;
+  }
+
+  CMAC128_UPDATE(ctx, nc-&gt;encrypt, 16, const_zero.b);
+  CMAC128_DIGEST(ctx, nc-&gt;encrypt, 16, D.b);
+
+  if (alength &gt; 0) {
+    _cmac128_block_mulx(&amp;D, &amp;D);
+    CMAC128_UPDATE(ctx, nc-&gt;encrypt, alength, adata);
+    CMAC128_DIGEST(ctx, nc-&gt;encrypt, 16, S.b);
+
+    memxor(D.b, S.b, 16);
+  }
+
+  if (nlength &gt; 0) {
+    _cmac128_block_mulx(&amp;D, &amp;D);
+    CMAC128_UPDATE(ctx, nc-&gt;encrypt, nlength, nonce);
+    CMAC128_DIGEST(ctx, nc-&gt;encrypt, 16, S.b);
+
+    memxor(D.b, S.b, 16);
+  }
+
+  /* Sn */
+  if (plength &gt;= 16) {
+    CMAC128_UPDATE(ctx, nc-&gt;encrypt, plength-16, pdata);
+
+    pdata += plength-16;
+
+    memxor3(T.b, pdata, D.b, 16);
+  } else {
+    union nettle_block16 pad;
+
+    _cmac128_block_mulx(&amp;T, &amp;D);
+    memcpy(pad.b, pdata, plength);
+    pad.b[plength] = 0x80;
+    if (plength+1 &lt; 16)
+      memset(&amp;pad.b[plength+1], 0, 16-plength-1);
+
+    memxor(T.b, pad.b, 16);
+  }
+
+  CMAC128_UPDATE(ctx, nc-&gt;encrypt, 16, T.b);
+  CMAC128_DIGEST(ctx, nc-&gt;encrypt, 16, v);
+}
+
+void
+siv_cmac_set_key(void *_ctx, void *cipher,
+		 const struct nettle_cipher *nc,
+		 const uint8_t *key)
+{
+	/* We rely on the fact that the siv_cmac member of the context
+	 * is first in the context provided */
+	struct cmac128_syn *ctx = _ctx;
+
+	assert(nc-&gt;key_size &lt;= SIV_MAX_KEY_SIZE/2);
+
+	CMAC128_SET_KEY(ctx, nc-&gt;set_encrypt_key, nc-&gt;encrypt, key);
+	nc-&gt;set_encrypt_key(cipher, key+nc-&gt;key_size);
+}
+
+void
+siv_cmac_encrypt_message(void *ctx,
+			 const struct nettle_cipher *nc,
+			 const void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t clength, uint8_t *dst, const uint8_t *src)
+{
+	union nettle_block16 siv;
+	size_t slength;
+
+	assert(clength &gt;= SIV_DIGEST_SIZE);
+	slength = clength - SIV_DIGEST_SIZE;
+
+	/* create CTR nonce */
+	_siv_s2v(nc,
+		 ctx, alength, adata,
+		 nlength, nonce, slength, src, siv.b);
+
+	memcpy(dst, siv.b, SIV_DIGEST_SIZE);
+	siv.b[8] &amp;= ~0x80;
+	siv.b[12] &amp;= ~0x80;
+
+	ctr_crypt(cipher, nc-&gt;encrypt, AES_BLOCK_SIZE, siv.b, slength, dst+SIV_DIGEST_SIZE, \
src); +}
+
+int
+siv_cmac_decrypt_message(void *ctx,
+			 const struct nettle_cipher *nc,
+			 const void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  union nettle_block16 siv;
+  union nettle_block16 ctr;
+
+  assert(mlength &gt;= SIV_DIGEST_SIZE);
+
+  memcpy(ctr.b, src, SIV_DIGEST_SIZE);
+  ctr.b[8] &amp;= ~0x80;
+  ctr.b[12] &amp;= ~0x80;
+
+  ctr_crypt(cipher, nc-&gt;encrypt, AES_BLOCK_SIZE, ctr.b,
+            mlength-SIV_DIGEST_SIZE, dst, src+SIV_DIGEST_SIZE);
+
+  /* create CTR nonce */
+  _siv_s2v(nc,
+	   ctx, alength, adata,
+	   nlength, nonce, mlength-SIV_DIGEST_SIZE, dst, siv.b);
+
+  return memeql_sec(siv.b, src, SIV_DIGEST_SIZE);
+}
+
diff --git a/siv-cmac.h b/siv-cmac.h
new file mode 100644
index 00000000..ffbe4623
--- /dev/null
+++ b/siv-cmac.h
@@ -0,0 +1,131 @@
+/* siv.h
+
+   AES-SIV, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_SIV_H_INCLUDED
+#define NETTLE_SIV_H_INCLUDED
+
+#include "nettle-types.h"
+#include "nettle-meta.h"
+#include "cmac.h"
+#include "aes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define siv_cmac_set_key nettle_siv_cmac_set_key
+#define siv_cmac_encrypt_message nettle_siv_cmac_encrypt_message
+#define siv_cmac_decrypt_message nettle_siv_cmac_decrypt_message
+#define siv_aes128_cmac_set_key nettle_siv_aes128_cmac_set_key
+#define siv_aes128_cmac_encrypt_message nettle_siv_aes128_cmac_encrypt_message
+#define siv_aes128_cmac_decrypt_message nettle_siv_aes128_cmac_decrypt_message
+#define siv_aes256_cmac_set_key nettle_siv_aes256_cmac_set_key
+#define siv_aes256_cmac_encrypt_message nettle_siv_aes256_cmac_encrypt_message
+#define siv_aes256_cmac_decrypt_message nettle_siv_aes256_cmac_decrypt_message
+
+/* For SIV, the block size of the block cipher shall be 128 bits. */
+#define SIV_BLOCK_SIZE  16
+#define SIV_DIGEST_SIZE 16
+#define SIV_MIN_NONCE_SIZE 0
+#define SIV_MAX_KEY_SIZE (AES_MAX_KEY_SIZE*2)
+
+void
+siv_cmac_set_key(void *ctx, void *cipher,
+		 const struct nettle_cipher *nc,
+		 const uint8_t *key);
+
+void
+siv_cmac_encrypt_message(void *ctx,
+			 const struct nettle_cipher *nc,
+			 const void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+siv_cmac_decrypt_message(void *ctx,
+			 const struct nettle_cipher *nc,
+			 const void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src);
+
+/*
+ * SIV mode requires the aad and plaintext when building the IV, which
+ * prevents streaming processing and it incompatible with the AEAD API.
+ */
+
+#define SIV_CMAC_CTX(type) { struct CMAC128_CTX(type) siv_cmac; type siv_cipher; }
+
+/* AES_SIV_CMAC_256 */
+struct siv_aes128_cmac_ctx SIV_CMAC_CTX(struct aes128_ctx);
+
+void
+siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const uint8_t *key);
+
+void
+siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+siv_aes128_cmac_decrypt_message(struct siv_aes128_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t mlength, uint8_t *dst, const uint8_t *src);
+
+/* AES_SIV_CMAC_512 */
+struct siv_aes256_cmac_ctx SIV_CMAC_CTX(struct aes256_ctx);
+
+void
+siv_aes256_cmac_set_key(struct siv_aes256_cmac_ctx *ctx, const uint8_t *key);
+
+void
+siv_aes256_cmac_encrypt_message(struct siv_aes256_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+siv_aes256_cmac_decrypt_message(struct siv_aes256_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t mlength, uint8_t *dst, const uint8_t *src);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_SIV_H_INCLUDED */
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index c3fc5c11..2a0d87ac 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -96,6 +96,8 @@
 /version-test
 /yarrow-test
 /xts-test
+/cmac-test
+/siv-test
 
 /test.in
 /test1.out
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 6eee6e22..f827175e 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -136,6 +136,9 @@ ccm-test$(EXEEXT): ccm-test.$(OBJEXT)
 cmac-test$(EXEEXT): cmac-test.$(OBJEXT)
 	$(LINK) cmac-test.$(OBJEXT) $(TEST_OBJS) -o cmac-test$(EXEEXT)
 
+siv-test$(EXEEXT): siv-test.$(OBJEXT)
+	$(LINK) siv-test.$(OBJEXT) $(TEST_OBJS) -o siv-test$(EXEEXT)
+
 poly1305-test$(EXEEXT): poly1305-test.$(OBJEXT)
 	$(LINK) poly1305-test.$(OBJEXT) $(TEST_OBJS) -o poly1305-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 287c4f75..1bd42ffa 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -27,7 +27,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    serpent-test.c twofish-test.c version-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c cfb-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
-		    cmac-test.c \
+		    cmac-test.c siv-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
diff --git a/testsuite/siv-test.c b/testsuite/siv-test.c
new file mode 100644
index 00000000..39e87514
--- /dev/null
+++ b/testsuite/siv-test.c
@@ -0,0 +1,350 @@
+/* siv-test.c
+
+   Self-test and vectors for AES-SIV mode ciphers
+
+   Copyright (C) 2018 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+/* The
+ * test vectors have been collected from the following standards:
+ *  RFC5297
+ */
+
+#include "testutils.h"
+#include "aes.h"
+#include "nettle-types.h"
+#include "siv-cmac.h"
+#include "knuth-lfib.h"
+
+static void
+test_compare_results(const char *name,
+        const struct tstring *adata,
+        /* Expected results. */
+        const struct tstring *e_clear,
+	const struct tstring *e_cipher,
+        /* Actual results. */
+        const void *clear,
+        const void *cipher,
+        const void *digest) /* digest optional. */
+{
+  if (digest &amp;&amp; !MEMEQ(SIV_DIGEST_SIZE, e_cipher-&gt;data, digest))
+    {
+      fprintf(stderr, "%s digest failed:\nAdata:", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(SIV_DIGEST_SIZE, digest);
+      fprintf(stderr, "\nExpected:");
+      print_hex(SIV_DIGEST_SIZE, e_cipher-&gt;data);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  if (!MEMEQ(e_cipher-&gt;length, e_cipher-&gt;data, cipher))
+    {
+      fprintf(stderr, "%s: encryption failed\nAdata: ", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_cipher-&gt;length, cipher);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_cipher);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  if (!MEMEQ(e_clear-&gt;length, e_clear-&gt;data, clear))
+    {
+      fprintf(stderr, "%s decrypt failed:\nAdata:", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_cipher);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_clear-&gt;length, clear);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+} /* test_compare_results */
+
+static void
+test_cipher_siv(const char *name,
+		nettle_set_key_func *siv_set_key,
+		nettle_encrypt_message_func *siv_encrypt,
+		nettle_decrypt_message_func *siv_decrypt,
+		unsigned context_size,
+		const struct nettle_cipher *cipher,
+		const struct tstring *key,
+		const struct tstring *nonce,
+		const struct tstring *authdata,
+		const struct tstring *cleartext,
+		const struct tstring *ciphertext)
+{
+  void *ctx = xalloc(context_size);
+  uint8_t *en_data;
+  uint8_t *de_data;
+  int ret;
+
+  ASSERT (key-&gt;length == cipher-&gt;key_size*2);
+  ASSERT (cleartext-&gt;length &lt;= ciphertext-&gt;length);
+  ASSERT ((cleartext-&gt;length + SIV_BLOCK_SIZE) &gt;= ciphertext-&gt;length);
+  ASSERT (ciphertext-&gt;length - cleartext-&gt;length == SIV_DIGEST_SIZE);
+
+  de_data = xalloc(cleartext-&gt;length+SIV_DIGEST_SIZE);
+  en_data = xalloc(ciphertext-&gt;length);
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+
+  /* Ensure we get the same answers using the all-in-one API. */
+  memset(de_data, 0, cleartext-&gt;length);
+  memset(en_data, 0, ciphertext-&gt;length);
+
+  siv_set_key(ctx, key-&gt;data);
+  siv_encrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+	      authdata-&gt;length, authdata-&gt;data,
+	      cleartext-&gt;length+SIV_DIGEST_SIZE, en_data, cleartext-&gt;data);
+
+  ret = siv_decrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+				        authdata-&gt;length, authdata-&gt;data,
+				        ciphertext-&gt;length, de_data, ciphertext-&gt;data);
+
+  if (ret != 1) fprintf(stderr, "siv_decrypt_message failed to validate message\n");
+    test_compare_results(name, authdata,
+			 cleartext, ciphertext, de_data, en_data, NULL);
+
+  test_compare_results(name, authdata,
+		       cleartext, ciphertext, de_data, en_data, en_data);
+
+
+  /* Ensure that we can detect corrupted message or tag data. */
+  en_data[0] ^= 1;
+  ret = siv_decrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+	            authdata-&gt;length, authdata-&gt;data,
+		    ciphertext-&gt;length, de_data, en_data);
+  if (ret != 0) fprintf(stderr, "siv_decrypt_message failed to detect corrupted \
message\n"); +
+  /* Ensure we can detect corrupted adata. */
+  if (authdata-&gt;length) {
+    en_data[0] ^= 1;
+    ret = siv_decrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+		      authdata-&gt;length-1, authdata-&gt;data,
+		      ciphertext-&gt;length, de_data, en_data);
+    if (ret != 0) fprintf(stderr, "siv_decrypt_message failed to detect corrupted \
message\n"); +  }
+
+
+  free(ctx);
+  free(en_data);
+  free(de_data);
+}
+
+#define test_siv_aes128(name, ctx_size, cipher, key, nonce, authdata, cleartext, \
ciphertext) \ +	test_cipher_siv(name, (nettle_set_key_func*)siv_aes128_cmac_set_key, \
\ +			(nettle_encrypt_message_func*)siv_aes128_cmac_encrypt_message, \
+			(nettle_decrypt_message_func*)siv_aes128_cmac_decrypt_message, ctx_size, cipher, \
\ +			key, nonce, authdata, cleartext, ciphertext)
+
+#define test_siv_aes256(name, ctx_size, cipher, key, nonce, authdata, cleartext, \
ciphertext) \ +	test_cipher_siv(name, (nettle_set_key_func*)siv_aes256_cmac_set_key, \
\ +			(nettle_encrypt_message_func*)siv_aes256_cmac_encrypt_message, \
+			(nettle_decrypt_message_func*)siv_aes256_cmac_decrypt_message, ctx_size, cipher, \
\ +			key, nonce, authdata, cleartext, ciphertext)
+
+void
+test_main(void)
+{
+  /*
+   * Example with no nonce, no AD and no plaintext; taken from
+   * https://github.com/miscreant/miscreant/blob/master/vectors/aes_siv.tjson
+   * however we don't interoperate.
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"),
+		  SHEX(""),
+		  SHEX(""),
+		  SHEX(""),
+		  SHEX("949f99cb cc3eb5da6 d3c45d0 f59aa9c7"));
+
+  /*
+   * Example with no nonce, no AD and plaintext; taken from
+   * https://github.com/miscreant/miscreant/blob/master/vectors/aes_siv.tjson
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"),
+		  SHEX(""),
+		  SHEX(""),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"),
+		  SHEX("f304f912 863e303d 5b540e50 57c7010c"
+		       "942ffaf4 5b0e5ca5 fb9a56a5 263bb065"));
+
+  /*
+   * Example without nonce length &lt; 16 (RFC5297)
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"),
+		  SHEX(""),
+		  SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+		       "20212223 24252627"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("85632d07 c6e8f37f 950acd32 0a2ecc93"
+		       "40c02b96 90c4dc04 daef7f6a fe5c"));
+
+  /*
+   * Example without nonce length &gt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX(""),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("c12ccaa7 54e1b3fa 4f416c18 415625ca"
+		       "472fbee de5bc03f 34934819 a9abb20b5"
+		       "8cd019c 470ac832 f6eb9ddf 0656c5dce"
+		       "ffe611a 5a5ca3e1 c3c12da5 6e4bb87"));
+
+  /*
+   * Example with single AAD, length &gt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+	          &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("85825e22 e90cf2dd da2c548d c7c1b631"
+		       "0dcdaca0 cebf9dc6 cb90583f 5bf1506e"
+		       "02cd4883 2b00e4e5 98b2b22a 53e6199d"
+		       "4df0c166 6a35a043 3b250dc1 34d776"));
+
+  /*
+   * Example with single AAD, length &lt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+	          &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("15f83882 14bdc94e 3ec4c7c3 69863746"
+		       "cd72d317 4b20a1e4 a0894fb7 cd78"));
+
+
+  /* AES-SIV-CMAC-512 (AES-256) from dchest/siv repo
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+		  &amp;nettle_aes256,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "6f6e6d6c 6b6a6968 67666564 63626160"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"
+		       "00010203 04050607 08090a0b 0c0d0e0f"),
+		  SHEX(""),
+		  SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+		       "20212223 24252627"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("f125274c 598065cf c26b0e71 57502908"
+		       "8b035217 e380cac8 919ee800 c126"));
+
+
+  /* AES-SIV-CMAC-512 (AES-256)
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+		  &amp;nettle_aes256,
+		  SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+		       "2d568e91 a38e5414 8abdc0b6 e86caf87"
+		       "695c0a8a df4c5f8e b2c6c8b1 36529864"
+		       "f3b84b3a e8e3676c e760c461 f3a13e83"),
+		  SHEX(""),
+		  SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+		       "20212223 24252627"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("ae2b1bd1 ba7fcd6a 4f9f7eb2 4b40f766"
+		       "86053ffd c384cb19 76031f46 3013"));
+
+  /*
+   * Example without nonce length &gt; 16
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+		  &amp;nettle_aes256,
+		  SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+		       "2d568e91 a38e5414 8abdc0b6 e86caf87"
+		       "695c0a8a df4c5f8e b2c6c8b1 36529864"
+		       "f3b84b3a e8e3676c e760c461 f3a13e83"),
+		  SHEX(""),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("79476aaa 388374fe 97d0db51 596cb5ee"
+		       "a933e001 412026c7 956c82dd b753b1af"
+		       "3d7d49ac 474a800a c14b4bab a4542067"
+		       "83647ef9 51315dab b7a2c05b 288ba8"));
+
+  /*
+   * Example with single AAD, length &gt; 16
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+	          &amp;nettle_aes256,
+		  SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+		       "2d568e91 a38e5414 8abdc0b6 e86caf87"
+		       "695c0a8a df4c5f8e b2c6c8b1 36529864"
+		       "f3b84b3a e8e3676c e760c461 f3a13e83"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("5a979b0d a58fde80 51621ae6 bf96feda"
+		       "50933da8 047bc306 fabaf0c3 d9fa8471"
+		       "c70a7def 39a2f91d 68a2021c 99ac7e2a"
+		       "24535a13 4ba23ec1 5787cebe 5c53cc"));
+}
diff --git a/testsuite/testutils.h b/testsuite/testutils.h
index ded57db6..3a1872f1 100644
--- a/testsuite/testutils.h
+++ b/testsuite/testutils.h
@@ -176,6 +176,19 @@ test_armor(const struct nettle_armor *armor,
            const uint8_t *data,
            const char *ascii);
 
+/* AEAD ciphers */
+typedef void
+nettle_encrypt_message_func(void *ctx,
+			    size_t nlength, const uint8_t *nonce,
+			    size_t alength, const uint8_t *adata,
+			    size_t clength, uint8_t *dst, const uint8_t *src);
+
+typedef int
+nettle_decrypt_message_func(void *ctx,
+			    size_t nlength, const uint8_t *nonce,
+			    size_t alength, const uint8_t *adata,
+			    size_t mlength, uint8_t *dst, const uint8_t *src);
+
 #if WITH_HOGWEED
 
 #if NETTLE_USE_MINI_GMP
-- 
2.20.1


[Attachment #5 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190417182752</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2019-04-17 18:27:52-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

On Wed, 2019-04-17 at 11:37 +0200, Nikos Mavrogiannopoulos wrote:
&gt; On Sun, 2019-04-14 at 09:33 +0200, Niels Möller wrote:
&gt; &gt; +  assert(nc-&gt;context_size &lt;= NETTLE_MAX_CIPHER16_CONTEXT_SIZE);
&gt; &gt; &gt; +
&gt; &gt; &gt; +  /* ensure we have enough size of context plus any padding size
&gt; &gt; &gt; */
&gt; &gt; &gt; +  CMAC128_SET_KEY(&amp;ctx, nc-&gt;set_encrypt_key, nc-&gt;encrypt, s2vk);
&gt; &gt; &gt; +
&gt; &gt; &gt; +  if (nlength == 0 &amp;&amp; alength == 0) {
&gt; &gt; &gt; +    CMAC128_UPDATE(&amp;ctx, nc-&gt;encrypt, 16, const_one);
&gt; &gt; &gt; +    CMAC128_DIGEST(&amp;ctx, nc-&gt;encrypt, 16, v);
&gt; &gt; &gt; +    return;
&gt; &gt; &gt; +  }
&gt; &gt; 
&gt; &gt; Shouldn't the plaintext, plength, pdata, still be processed in this
&gt; &gt; case?
&gt; 
&gt; Right, there should be an and plength == 0 as well. I've added an two
&gt; additional test cases to check these cases, and the case where
&gt; everything is zero, doesn't seem to interoperate with two libs I
&gt; tried.
&gt; 
&gt; Hopefully it is issue of this code.
&gt; 
&gt; https://github.com/miscreant/miscreant/issues/194
&gt; https://github.com/dfoxfranke/libaes_siv/issues/14

Based on the discussions on these bugs, I think it makes sense to
strictly restrict the implementation to the common interoperable
conventions (AEAD). That is, always assume (aad, nonce, plaintext),
even if empty. As such I've updated the test vectors to include non
empty nonce and tested them against libaes_siv.

The attached bugs update this implementation, and an additional patch
adds a "make distcheck" check to CI. That ensures that any missing or
incorrectly added in Makefile files are caught by the CI.

regards,
Nikos


["0003-Added-support-for-AES_SIV_CMAC_256-and-AES_SIV_CMAC_.patch" (0003-Added-support-for-AES_SIV_CMAC_256-and-AES_SIV_CMAC_.patch)]

From 8dfd9653109844dc7253b45af1815a0492b25c2a Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Sat, 20 Jan 2018 10:36:05 +0100
Subject: [PATCH 3/3] Added support for AES_SIV_CMAC_256 and AES_SIV_CMAC_512

This AEAD algorithm provides a way to make nonce-reuse a not critical
issue. That is particular useful to stateless servers that cannot ensure
that the nonce will not repeat. This cipher is used by
draft-ietf-ntp-using-nts-for-ntp-17.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 Makefile.in                |   4 +-
 cmac-internal.h            |  54 ++++++
 cmac.c                     |  15 +-
 nettle-internal.h          |   2 +
 nettle.texinfo             |  94 +++++++++-
 siv-aes128-cmac.c          |  75 ++++++++
 siv-aes256-cmac.c          |  75 ++++++++
 siv-cmac.c                 | 186 ++++++++++++++++++++
 siv-cmac.h                 | 131 ++++++++++++++
 testsuite/.gitignore       |   2 +
 testsuite/.test-rules.make |   3 +
 testsuite/Makefile.in      |   2 +-
 testsuite/siv-test.c       | 347 +++++++++++++++++++++++++++++++++++++
 testsuite/testutils.h      |  13 ++
 14 files changed, 992 insertions(+), 11 deletions(-)
 create mode 100644 cmac-internal.h
 create mode 100644 siv-aes128-cmac.c
 create mode 100644 siv-aes256-cmac.c
 create mode 100644 siv-cmac.c
 create mode 100644 siv-cmac.h
 create mode 100644 testsuite/siv-test.c

diff --git a/Makefile.in b/Makefile.in
index 440de9f7..962a6b73 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -89,6 +89,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 camellia256-meta.c \
 		 cast128.c cast128-meta.c cbc.c \
 		 ccm.c ccm-aes128.c ccm-aes192.c ccm-aes256.c cfb.c \
+		 siv-cmac.c siv-aes128-cmac.c siv-aes256-cmac.c \
 		 cnd-memcpy.c \
 		 chacha-crypt.c chacha-core-internal.c \
 		 chacha-poly1305.c chacha-poly1305-meta.c \
@@ -198,7 +199,8 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  gcm.h gosthash94.h hmac.h \
 	  knuth-lfib.h hkdf.h \
 	  macros.h \
-	  cmac.h \
+	  cmac.h cmac-internal.h \
+	  siv-cmac.h \
 	  md2.h md4.h \
 	  md5.h md5-compat.h \
 	  memops.h memxor.h \
diff --git a/cmac-internal.h b/cmac-internal.h
new file mode 100644
index 00000000..789588e6
--- /dev/null
+++ b/cmac-internal.h
@@ -0,0 +1,54 @@
+/* cmac.h
+
+   CMAC mode internal functions
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   Contributed by Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_CMAC_INTERNAL_H_INCLUDED
+#define NETTLE_CMAC_INTERNAL_H_INCLUDED
+
+#include "cmac.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define _cmac128_block_mulx _nettle_cmac128_block_mulx
+
+void _cmac128_block_mulx(union nettle_block16 *out,
+			 const union nettle_block16 *in);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CMAC_INTERNAL_H_INCLUDED */
diff --git a/cmac.c b/cmac.c
index 01fee79e..8be1cca4 100644
--- a/cmac.c
+++ b/cmac.c
@@ -44,13 +44,13 @@
 
 #include "memxor.h"
 #include "nettle-internal.h"
+#include "cmac-internal.h"
 #include "macros.h"
 
 /* shift one and XOR with 0x87. */
 #if WORDS_BIGENDIAN
-static void
-block_mulx(union nettle_block16 *dst,
-	   const union nettle_block16 *src)
+void _cmac128_block_mulx(union nettle_block16 *dst,
+			 const union nettle_block16 *src)
 {
   uint64_t carry = src-&gt;u64[0] &gt;&gt; 63;
   dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
@@ -59,9 +59,8 @@ block_mulx(union nettle_block16 *dst,
 #else /* !WORDS_BIGENDIAN */
 #define LE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
                      (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
-static void
-block_mulx(union nettle_block16 *dst,
-	   const union nettle_block16 *src)
+void _cmac128_block_mulx(union nettle_block16 *dst,
+			 const union nettle_block16 *src)
 {
   uint64_t carry = (src-&gt;u64[0] &amp; 0x80) &gt;&gt; 7;
   dst-&gt;u64[0] = LE_SHIFT(src-&gt;u64[0]) | ((src-&gt;u64[1] &amp; 0x80) &lt;&lt; 49);
@@ -83,8 +82,8 @@ cmac128_set_key(struct cmac128_ctx *ctx, const void *cipher,
   /* step 1 - generate subkeys k1 and k2 */
   encrypt(cipher, 16, L-&gt;b, const_zero.b);
 
-  block_mulx(&amp;ctx-&gt;K1, L);
-  block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
+  _cmac128_block_mulx(&amp;ctx-&gt;K1, L);
+  _cmac128_block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
 }
 
 #define MIN(x,y) ((x)&lt;(y)?(x):(y))
diff --git a/nettle-internal.h b/nettle-internal.h
index dc379f1f..2937a710 100644
--- a/nettle-internal.h
+++ b/nettle-internal.h
@@ -78,6 +78,8 @@
 #define NETTLE_MAX_HASH_CONTEXT_SIZE (sizeof(struct sha3_224_ctx))
 #define NETTLE_MAX_SEXP_ASSOC 17
 #define NETTLE_MAX_CIPHER_BLOCK_SIZE 32
+/* maximum context size of 128-bit block ciphers */
+#define NETTLE_MAX_CIPHER16_CONTEXT_SIZE (sizeof(struct aes256_ctx))
 
 /* Doesn't quite fit with the other algorithms, because of the weak
  * keys. Weak keys are not reported, the functions will simply crash
diff --git a/nettle.texinfo b/nettle.texinfo
index 596c7098..b83c13d0 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -97,6 +97,7 @@ Cipher modes
 * CFB and CFB8::
 * GCM::                         
 * CCM::                         
+* SIV-CMAC::
 
 Keyed Hash Functions
 
@@ -2565,6 +2566,7 @@ more adventurous alternative, in particular if performance is \
                important.
 * GCM::                         
 * CCM::                         
 * ChaCha-Poly1305::
+* SIV-CMAC::
 * nettle_aead abstraction::
 @end menu
 
@@ -3212,7 +3214,7 @@ These are identical to @code{ccm_encrypt_message} and \
@code{ccm_decrypt_message}  except that @var{cipher} and @var{f} are replaced with a \
context structure.  @end deftypefun
 
-@node ChaCha-Poly1305, nettle_aead abstraction, CCM, Authenticated encryption
+@node ChaCha-Poly1305, SIV-CMAC, CCM, Authenticated encryption
 @comment  node-name,  next,  previous,  up
 @subsection ChaCha-Poly1305
 
@@ -3295,6 +3297,96 @@ smaller than @code{CHACHA_POLY1305_DIGEST_SIZE}, only the \
first  @var{length} octets of the digest are written.
 @end deftypefun
 
+@node SIV-CMAC, nettle_aead abstraction, ChaCha-Poly1305, Authenticated encryption
+@comment  node-name,  next,  previous,  up
+@subsection Counter with CBC-MAC mode
+
+@cindex SIV mode
+@cindex SIV-CMAC mode
+
+@acronym{SIV-CMAC} mode is a combination of counter mode with message
+authentication based on @acronym{CMAC}. Unlike other counter @acronym{AEAD}
+modes, it provides protection against accidental nonce misuse, making it
+a good choice for stateless-servers that cannot ensure nonce uniqueness.
+It is constructed on top of a block cipher which must have a block size of
+128 bits. Nettle's support for @acronym{SIV-CMAC} consists of
+a message encryption and authentication interface, for
+@acronym{SIV-CMAC} using AES as the underlying block cipher.
+When a nonce is re-used with this mode, message authenticity is retained
+however an attacker can determine whether the same plaintext was protected
+with the two messages sharing the nonce.
+These interfaces are defined in @file{&lt;nettle/siv-cmac.h&gt;}.
+
+Unlike other @acronym{AEAD} mode in @acronym{SIV-CMAC} the initialization
+vector serves as the tag. That means that in the generated ciphertext
+the tag precedes the ciphertext.
+
+Note also, that the @acronym{SIV-CMAC} algorithm introduces the notion
+of authenticated data which consist of multiple components. For example
+with @acronym{SIV-CMAC} the authentication tag of data @code{X} followed
+by @code{Y}, is different than the concatenated data @code{X || Y}. The interfaces
+described below follow the @acronym{AEAD} paradigm and do not allow access
+to this feature and also require the use of a non-zero tag.
+
+@subsubsection General interface
+
+@defvr Constant SIV_BLOCK_SIZE
+@acronym{SIV-CMAC}'s block size, 16.
+@end defvr
+
+@defvr Constant SIV_DIGEST_SIZE
+Size of the @acronym{SIV-CMAC} digest or initialization vector, 16.
+@end defvr
+
+@defvr Constant SIV_MIN_NONCE_SIZE
+The the minimumsizes for an @acronym{SIV-CMAC} nonce, 0
+@end defvr
+
+@subsubsection @acronym{SIV-CMAC}-@acronym{AES} interface
+
+The @acronym{AES} @acronym{SIV-CMAC} functions provide an API for using
+@acronym{SIV-CMAC} mode with the @acronym{AES} block ciphers. The parameters
+all have the same meaning as the general and message interfaces, except
+that the @var{cipher}, @var{f}, and @var{ctx} parameters are replaced
+with an @acronym{AES} context structure, and a set-key function must be
+called before using any of the other functions in this interface.
+
+@deftp {Context struct} {struct siv_aes128_cmac_ctx}
+Holds state corresponding to a particular message encrypted using the
+AES-128 block cipher.
+@end deftp
+
+@deftp {Context struct} {struct siv_aes256_cmac_ctx}
+Holds state corresponding to a particular message encrypted using the
+AES-256 block cipher.
+@end deftp
+
+@deftypefun void siv_aes128_cmac_set_key (struct siv_aes128_cmac_ctx *@var{ctx}, \
const uint8_t *@var{key}) +@deftypefunx void siv_aes256_cmac_set_key (struct \
siv_aes256_cmac_ctx *@var{ctx}, const uint8_t *@var{key}) +Initializes the encryption \
key for the AES block cipher. One of these +functions must be called before any of \
the other functions in the +@acronym{AES} @acronym{SIV-CMAC} interface.
+@end deftypefun
+
+@deftypefun void siv_aes128_cmac_encrypt_message (struct siv_aes128_cmac_ctx \
*@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, \
const uint8_t *@var{adata}, size_t @var{clength}, uint8_t *@var{dst}, const uint8_t \
*@var{src}) +@deftypefunx void siv_aes256_cmac_encrypt_message (struct \
siv_aes256_cmac_ctx *@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, \
size_t @var{alength}, const uint8_t *@var{adata}, size_t @var{clength}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +Computes the message digest from the \
@var{adata} and @var{src} +parameters, encrypts the plaintext from @var{src}, \
prepends the +initialization vector to the ciphertext and outputs it to @var{dst}.
+The @var{clength} variable must be equal to the length of @var{src}
+plus @code{SIV_DIGEST_SIZE}.
+
+@end deftypefun
+
+@deftypefun int siv_aes128_cmac_decrypt_message (struct siv_aes128_cmac_ctx \
*@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, \
const uint8_t *@var{adata}, size_t @var{mlength}, uint8_t *@var{dst}, const uint8_t \
*@var{src}) +@deftypefunx int siv_aes256_cmac_decrypt_message (struct \
siv_aes128_cmac_ctx *@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, \
size_t @var{alength}, const uint8_t *@var{adata}, size_t @var{mlength}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +Decrypts the ciphertext from @var{src}, \
outputs the plaintext to +@var{dst}, recalculates the initialization vector from \
@var{adata} and the +plaintext. If the values of the received and calculated \
initialization vector +are equal, this will return 1 indicating a valid and \
authenticated +message. Otherwise, this function will return zero.
+@end deftypefun
+
 @node nettle_aead abstraction, , ChaCha-Poly1305, Authenticated encryption
 @comment  node-name,  next,  previous,  up
 @subsection The @code{struct nettle_aead} abstraction
diff --git a/siv-aes128-cmac.c b/siv-aes128-cmac.c
new file mode 100644
index 00000000..793279d1
--- /dev/null
+++ b/siv-aes128-cmac.c
@@ -0,0 +1,75 @@
+/* siv-aes128.c
+
+   AES-SIV, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "aes.h"
+#include "siv-cmac.h"
+#include "cmac.h"
+#include "ctr.h"
+#include "memxor.h"
+#include "memops.h"
+#include "cmac-internal.h"
+
+void
+siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const uint8_t *key)
+{
+  siv_cmac_set_key(&amp;ctx-&gt;siv_cmac, &amp;ctx-&gt;siv_cipher, &amp;nettle_aes128, key);
+}
+
+void
+siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t clength, uint8_t *dst, const uint8_t *src)
+{
+  siv_cmac_encrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes128, &amp;ctx-&gt;siv_cipher,
+			   nlength, nonce, alength, adata,
+			   clength, dst, src);
+}
+
+int
+siv_aes128_cmac_decrypt_message(struct siv_aes128_cmac_ctx *ctx,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  return siv_cmac_decrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes128, &amp;ctx-&gt;siv_cipher,
+				  nlength, nonce, alength, adata,
+				  mlength, dst, src);
+}
diff --git a/siv-aes256-cmac.c b/siv-aes256-cmac.c
new file mode 100644
index 00000000..61cd1163
--- /dev/null
+++ b/siv-aes256-cmac.c
@@ -0,0 +1,75 @@
+/* siv-aes128.c
+
+   AES-SIV, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "aes.h"
+#include "siv-cmac.h"
+#include "cmac.h"
+#include "ctr.h"
+#include "memxor.h"
+#include "memops.h"
+#include "cmac-internal.h"
+
+void
+siv_aes256_cmac_set_key(struct siv_aes256_cmac_ctx *ctx, const uint8_t *key)
+{
+  siv_cmac_set_key(&amp;ctx-&gt;siv_cmac, &amp;ctx-&gt;siv_cipher, &amp;nettle_aes256, key);
+}
+
+void
+siv_aes256_cmac_encrypt_message(struct siv_aes256_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t clength, uint8_t *dst, const uint8_t *src)
+{
+  siv_cmac_encrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes256, &amp;ctx-&gt;siv_cipher,
+			   nlength, nonce, alength, adata,
+			   clength, dst, src);
+}
+
+int
+siv_aes256_cmac_decrypt_message(struct siv_aes256_cmac_ctx *ctx,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  return siv_cmac_decrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes256, &amp;ctx-&gt;siv_cipher,
+				  nlength, nonce, alength, adata,
+				  mlength, dst, src);
+}
diff --git a/siv-cmac.c b/siv-cmac.c
new file mode 100644
index 00000000..f440769f
--- /dev/null
+++ b/siv-cmac.c
@@ -0,0 +1,186 @@
+/* siv-cmac.c
+
+   SIV-CMAC, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "aes.h"
+#include "siv-cmac.h"
+#include "cmac.h"
+#include "ctr.h"
+#include "memxor.h"
+#include "memops.h"
+#include "cmac-internal.h"
+#include "nettle-internal.h"
+
+/* This is only to allow the CMAC macros to expand in
+ * _siv_s2v */
+struct cmac128_syn {
+  struct cmac128_ctx ctx;
+  union {
+    uint64_t pad1[2]; /* to force a good alignment */
+    uint8_t pad[NETTLE_MAX_CIPHER16_CONTEXT_SIZE+16];
+  } cipher;
+};
+
+/* This is an implementation of S2V for the AEAD case where
+ * vectors if zero, are considered as S empty components */
+static
+void _siv_s2v(const struct nettle_cipher *nc,
+	      struct cmac128_syn *ctx,
+	      size_t alength, const uint8_t *adata,
+              size_t nlength, const uint8_t *nonce,
+              size_t plength, const uint8_t *pdata,
+              uint8_t *v)
+{
+  union nettle_block16 D, S, T;
+  static const union nettle_block16 const_zero = { .b = {
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
+  };
+
+  assert(nc-&gt;context_size &lt;= NETTLE_MAX_CIPHER16_CONTEXT_SIZE);
+
+  /* the only unambiguous mode of this cipher is when a nonce
+   * is provided in AEAD mode.  */
+  assert(nlength != 0);
+
+  CMAC128_UPDATE(ctx, nc-&gt;encrypt, 16, const_zero.b);
+  CMAC128_DIGEST(ctx, nc-&gt;encrypt, 16, D.b);
+
+  _cmac128_block_mulx(&amp;D, &amp;D);
+  CMAC128_UPDATE(ctx, nc-&gt;encrypt, alength, adata);
+  CMAC128_DIGEST(ctx, nc-&gt;encrypt, 16, S.b);
+  memxor(D.b, S.b, 16);
+
+  _cmac128_block_mulx(&amp;D, &amp;D);
+  CMAC128_UPDATE(ctx, nc-&gt;encrypt, nlength, nonce);
+  CMAC128_DIGEST(ctx, nc-&gt;encrypt, 16, S.b);
+  memxor(D.b, S.b, 16);
+
+  /* Sn */
+  if (plength &gt;= 16) {
+    CMAC128_UPDATE(ctx, nc-&gt;encrypt, plength-16, pdata);
+
+    pdata += plength-16;
+
+    memxor3(T.b, pdata, D.b, 16);
+  } else {
+    union nettle_block16 pad;
+
+    _cmac128_block_mulx(&amp;T, &amp;D);
+    memcpy(pad.b, pdata, plength);
+    pad.b[plength] = 0x80;
+    if (plength+1 &lt; 16)
+      memset(&amp;pad.b[plength+1], 0, 16-plength-1);
+
+    memxor(T.b, pad.b, 16);
+  }
+
+  CMAC128_UPDATE(ctx, nc-&gt;encrypt, 16, T.b);
+  CMAC128_DIGEST(ctx, nc-&gt;encrypt, 16, v);
+}
+
+void
+siv_cmac_set_key(void *_ctx, void *cipher,
+		 const struct nettle_cipher *nc,
+		 const uint8_t *key)
+{
+	/* We rely on the fact that the siv_cmac member of the context
+	 * is first in the context provided */
+	struct cmac128_syn *ctx = _ctx;
+
+	assert(nc-&gt;key_size &lt;= SIV_MAX_KEY_SIZE/2);
+
+	CMAC128_SET_KEY(ctx, nc-&gt;set_encrypt_key, nc-&gt;encrypt, key);
+	nc-&gt;set_encrypt_key(cipher, key+nc-&gt;key_size);
+}
+
+void
+siv_cmac_encrypt_message(void *ctx,
+			 const struct nettle_cipher *nc,
+			 const void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t clength, uint8_t *dst, const uint8_t *src)
+{
+	union nettle_block16 siv;
+	size_t slength;
+
+	assert(clength &gt;= SIV_DIGEST_SIZE);
+	slength = clength - SIV_DIGEST_SIZE;
+
+	/* create CTR nonce */
+	_siv_s2v(nc,
+		 ctx, alength, adata,
+		 nlength, nonce, slength, src, siv.b);
+
+	memcpy(dst, siv.b, SIV_DIGEST_SIZE);
+	siv.b[8] &amp;= ~0x80;
+	siv.b[12] &amp;= ~0x80;
+
+	ctr_crypt(cipher, nc-&gt;encrypt, AES_BLOCK_SIZE, siv.b, slength, dst+SIV_DIGEST_SIZE, \
src); +}
+
+int
+siv_cmac_decrypt_message(void *ctx,
+			 const struct nettle_cipher *nc,
+			 const void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  union nettle_block16 siv;
+  union nettle_block16 ctr;
+
+  assert(mlength &gt;= SIV_DIGEST_SIZE);
+
+  memcpy(ctr.b, src, SIV_DIGEST_SIZE);
+  ctr.b[8] &amp;= ~0x80;
+  ctr.b[12] &amp;= ~0x80;
+
+  ctr_crypt(cipher, nc-&gt;encrypt, AES_BLOCK_SIZE, ctr.b,
+            mlength-SIV_DIGEST_SIZE, dst, src+SIV_DIGEST_SIZE);
+
+  /* create CTR nonce */
+  _siv_s2v(nc,
+	   ctx, alength, adata,
+	   nlength, nonce, mlength-SIV_DIGEST_SIZE, dst, siv.b);
+
+  return memeql_sec(siv.b, src, SIV_DIGEST_SIZE);
+}
+
diff --git a/siv-cmac.h b/siv-cmac.h
new file mode 100644
index 00000000..ffbe4623
--- /dev/null
+++ b/siv-cmac.h
@@ -0,0 +1,131 @@
+/* siv.h
+
+   AES-SIV, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_SIV_H_INCLUDED
+#define NETTLE_SIV_H_INCLUDED
+
+#include "nettle-types.h"
+#include "nettle-meta.h"
+#include "cmac.h"
+#include "aes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define siv_cmac_set_key nettle_siv_cmac_set_key
+#define siv_cmac_encrypt_message nettle_siv_cmac_encrypt_message
+#define siv_cmac_decrypt_message nettle_siv_cmac_decrypt_message
+#define siv_aes128_cmac_set_key nettle_siv_aes128_cmac_set_key
+#define siv_aes128_cmac_encrypt_message nettle_siv_aes128_cmac_encrypt_message
+#define siv_aes128_cmac_decrypt_message nettle_siv_aes128_cmac_decrypt_message
+#define siv_aes256_cmac_set_key nettle_siv_aes256_cmac_set_key
+#define siv_aes256_cmac_encrypt_message nettle_siv_aes256_cmac_encrypt_message
+#define siv_aes256_cmac_decrypt_message nettle_siv_aes256_cmac_decrypt_message
+
+/* For SIV, the block size of the block cipher shall be 128 bits. */
+#define SIV_BLOCK_SIZE  16
+#define SIV_DIGEST_SIZE 16
+#define SIV_MIN_NONCE_SIZE 0
+#define SIV_MAX_KEY_SIZE (AES_MAX_KEY_SIZE*2)
+
+void
+siv_cmac_set_key(void *ctx, void *cipher,
+		 const struct nettle_cipher *nc,
+		 const uint8_t *key);
+
+void
+siv_cmac_encrypt_message(void *ctx,
+			 const struct nettle_cipher *nc,
+			 const void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+siv_cmac_decrypt_message(void *ctx,
+			 const struct nettle_cipher *nc,
+			 const void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src);
+
+/*
+ * SIV mode requires the aad and plaintext when building the IV, which
+ * prevents streaming processing and it incompatible with the AEAD API.
+ */
+
+#define SIV_CMAC_CTX(type) { struct CMAC128_CTX(type) siv_cmac; type siv_cipher; }
+
+/* AES_SIV_CMAC_256 */
+struct siv_aes128_cmac_ctx SIV_CMAC_CTX(struct aes128_ctx);
+
+void
+siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const uint8_t *key);
+
+void
+siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+siv_aes128_cmac_decrypt_message(struct siv_aes128_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t mlength, uint8_t *dst, const uint8_t *src);
+
+/* AES_SIV_CMAC_512 */
+struct siv_aes256_cmac_ctx SIV_CMAC_CTX(struct aes256_ctx);
+
+void
+siv_aes256_cmac_set_key(struct siv_aes256_cmac_ctx *ctx, const uint8_t *key);
+
+void
+siv_aes256_cmac_encrypt_message(struct siv_aes256_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+siv_aes256_cmac_decrypt_message(struct siv_aes256_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t mlength, uint8_t *dst, const uint8_t *src);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_SIV_H_INCLUDED */
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index c3fc5c11..2a0d87ac 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -96,6 +96,8 @@
 /version-test
 /yarrow-test
 /xts-test
+/cmac-test
+/siv-test
 
 /test.in
 /test1.out
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 6eee6e22..f827175e 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -136,6 +136,9 @@ ccm-test$(EXEEXT): ccm-test.$(OBJEXT)
 cmac-test$(EXEEXT): cmac-test.$(OBJEXT)
 	$(LINK) cmac-test.$(OBJEXT) $(TEST_OBJS) -o cmac-test$(EXEEXT)
 
+siv-test$(EXEEXT): siv-test.$(OBJEXT)
+	$(LINK) siv-test.$(OBJEXT) $(TEST_OBJS) -o siv-test$(EXEEXT)
+
 poly1305-test$(EXEEXT): poly1305-test.$(OBJEXT)
 	$(LINK) poly1305-test.$(OBJEXT) $(TEST_OBJS) -o poly1305-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 287c4f75..1bd42ffa 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -27,7 +27,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    serpent-test.c twofish-test.c version-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c cfb-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
-		    cmac-test.c \
+		    cmac-test.c siv-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
diff --git a/testsuite/siv-test.c b/testsuite/siv-test.c
new file mode 100644
index 00000000..0f77b4d5
--- /dev/null
+++ b/testsuite/siv-test.c
@@ -0,0 +1,347 @@
+/* siv-test.c
+
+   Self-test and vectors for AES-SIV mode ciphers
+
+   Copyright (C) 2018 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+/* The
+ * test vectors have been collected from the following standards:
+ *  RFC5297
+ */
+
+#include "testutils.h"
+#include "aes.h"
+#include "nettle-types.h"
+#include "siv-cmac.h"
+#include "knuth-lfib.h"
+
+static void
+test_compare_results(const char *name,
+        const struct tstring *adata,
+        /* Expected results. */
+        const struct tstring *e_clear,
+	const struct tstring *e_cipher,
+        /* Actual results. */
+        const void *clear,
+        const void *cipher,
+        const void *digest) /* digest optional. */
+{
+  if (digest &amp;&amp; !MEMEQ(SIV_DIGEST_SIZE, e_cipher-&gt;data, digest))
+    {
+      fprintf(stderr, "%s digest failed:\nAdata:", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(SIV_DIGEST_SIZE, digest);
+      fprintf(stderr, "\nExpected:");
+      print_hex(SIV_DIGEST_SIZE, e_cipher-&gt;data);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  if (!MEMEQ(e_cipher-&gt;length, e_cipher-&gt;data, cipher))
+    {
+      fprintf(stderr, "%s: encryption failed\nAdata: ", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_cipher-&gt;length, cipher);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_cipher);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  if (!MEMEQ(e_clear-&gt;length, e_clear-&gt;data, clear))
+    {
+      fprintf(stderr, "%s decrypt failed:\nAdata:", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_cipher);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_clear-&gt;length, clear);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+} /* test_compare_results */
+
+static void
+test_cipher_siv(const char *name,
+		nettle_set_key_func *siv_set_key,
+		nettle_encrypt_message_func *siv_encrypt,
+		nettle_decrypt_message_func *siv_decrypt,
+		unsigned context_size,
+		const struct nettle_cipher *cipher,
+		const struct tstring *key,
+		const struct tstring *nonce,
+		const struct tstring *authdata,
+		const struct tstring *cleartext,
+		const struct tstring *ciphertext)
+{
+  void *ctx = xalloc(context_size);
+  uint8_t *en_data;
+  uint8_t *de_data;
+  int ret;
+
+  ASSERT (key-&gt;length == cipher-&gt;key_size*2);
+  ASSERT (cleartext-&gt;length &lt;= ciphertext-&gt;length);
+  ASSERT ((cleartext-&gt;length + SIV_BLOCK_SIZE) &gt;= ciphertext-&gt;length);
+  ASSERT (ciphertext-&gt;length - cleartext-&gt;length == SIV_DIGEST_SIZE);
+
+  de_data = xalloc(cleartext-&gt;length+SIV_DIGEST_SIZE);
+  en_data = xalloc(ciphertext-&gt;length);
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+
+  /* Ensure we get the same answers using the all-in-one API. */
+  memset(de_data, 0, cleartext-&gt;length);
+  memset(en_data, 0, ciphertext-&gt;length);
+
+  siv_set_key(ctx, key-&gt;data);
+  siv_encrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+	      authdata-&gt;length, authdata-&gt;data,
+	      cleartext-&gt;length+SIV_DIGEST_SIZE, en_data, cleartext-&gt;data);
+
+  ret = siv_decrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+				        authdata-&gt;length, authdata-&gt;data,
+				        ciphertext-&gt;length, de_data, ciphertext-&gt;data);
+
+  if (ret != 1) fprintf(stderr, "siv_decrypt_message failed to validate message\n");
+    test_compare_results(name, authdata,
+			 cleartext, ciphertext, de_data, en_data, NULL);
+
+  test_compare_results(name, authdata,
+		       cleartext, ciphertext, de_data, en_data, en_data);
+
+
+  /* Ensure that we can detect corrupted message or tag data. */
+  en_data[0] ^= 1;
+  ret = siv_decrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+	            authdata-&gt;length, authdata-&gt;data,
+		    ciphertext-&gt;length, de_data, en_data);
+  if (ret != 0) fprintf(stderr, "siv_decrypt_message failed to detect corrupted \
message\n"); +
+  /* Ensure we can detect corrupted adata. */
+  if (authdata-&gt;length) {
+    en_data[0] ^= 1;
+    ret = siv_decrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+		      authdata-&gt;length-1, authdata-&gt;data,
+		      ciphertext-&gt;length, de_data, en_data);
+    if (ret != 0) fprintf(stderr, "siv_decrypt_message failed to detect corrupted \
message\n"); +  }
+
+
+  free(ctx);
+  free(en_data);
+  free(de_data);
+}
+
+#define test_siv_aes128(name, ctx_size, cipher, key, nonce, authdata, cleartext, \
ciphertext) \ +	test_cipher_siv(name, (nettle_set_key_func*)siv_aes128_cmac_set_key, \
\ +			(nettle_encrypt_message_func*)siv_aes128_cmac_encrypt_message, \
+			(nettle_decrypt_message_func*)siv_aes128_cmac_decrypt_message, ctx_size, cipher, \
\ +			key, nonce, authdata, cleartext, ciphertext)
+
+#define test_siv_aes256(name, ctx_size, cipher, key, nonce, authdata, cleartext, \
ciphertext) \ +	test_cipher_siv(name, (nettle_set_key_func*)siv_aes256_cmac_set_key, \
\ +			(nettle_encrypt_message_func*)siv_aes256_cmac_encrypt_message, \
+			(nettle_decrypt_message_func*)siv_aes256_cmac_decrypt_message, ctx_size, cipher, \
\ +			key, nonce, authdata, cleartext, ciphertext)
+
+void
+test_main(void)
+{
+  /* The following tests were checked for interoperability against libaes_siv */
+
+  /*
+   * Example with small nonce, no AD and no plaintext
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"),
+		  SHEX("01"),
+		  SHEX(""),
+		  SHEX(""),
+		  SHEX("c696f84f df92aba3 c31c23d5 f2087513"));
+  /*
+   * Example with small nonce, no AD and plaintext
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"),
+		  SHEX("02"),
+		  SHEX(""),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"),
+		  SHEX("5027b101 589747b8 865a9790 d3fd51d7"
+		       "1f259d40 5bfa260b 9ba1d60a a287fd0b"));
+
+  /*
+   * Example with length &lt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"),
+		  SHEX("02"),
+		  SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+		       "20212223 24252627"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("7300cd9b 3f514a44 ed660db6 14157f59"
+		       "f0382e23 ae0e6e62 27a03dd3 2619"));
+
+  /*
+   * Example with length &gt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX("020304"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("f1dba33d e5b3369e 883f67b6 fc823cee"
+		       "a4ffb87f dba97c89 44a62325 f133b4e0"
+		       "1ca55276 e2261c1a 1d1d4248 d1da30ba"
+		       "52b9c8d7 955d65c8 d2ce6eb7 e367d0"));
+
+  /*
+   * Example with single AAD, length &gt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+	          &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("85825e22 e90cf2dd da2c548d c7c1b631"
+		       "0dcdaca0 cebf9dc6 cb90583f 5bf1506e"
+		       "02cd4883 2b00e4e5 98b2b22a 53e6199d"
+		       "4df0c166 6a35a043 3b250dc1 34d776"));
+
+  /*
+   * Example with single AAD, length &lt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+	          &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("15f83882 14bdc94e 3ec4c7c3 69863746"
+		       "cd72d317 4b20a1e4 a0894fb7 cd78"));
+
+  /* AES-SIV-CMAC-512 (AES-256) from dchest/siv repo
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+		  &amp;nettle_aes256,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "6f6e6d6c 6b6a6968 67666564 63626160"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"
+		       "00010203 04050607 08090a0b 0c0d0e0f"),
+		  SHEX("02"),
+		  SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+		       "20212223 24252627"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("6f740b42 1e2972d8 5e76189e 99842843"
+		       "ad9e6ff1 4ea97c32 ab315e67 464c"));
+
+
+  /* AES-SIV-CMAC-512 (AES-256)
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+		  &amp;nettle_aes256,
+		  SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+		       "2d568e91 a38e5414 8abdc0b6 e86caf87"
+		       "695c0a8a df4c5f8e b2c6c8b1 36529864"
+		       "f3b84b3a e8e3676c e760c461 f3a13e83"),
+		  SHEX("02"),
+		  SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+		       "20212223 24252627"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("c3366ef8 92911eac 3d17f29a 37d4ebad"
+		       "ddc1219e bbde06d1 ee893e55 a39f"));
+
+  /*
+   * Example with length &gt; 16
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+		  &amp;nettle_aes256,
+		  SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+		       "2d568e91 a38e5414 8abdc0b6 e86caf87"
+		       "695c0a8a df4c5f8e b2c6c8b1 36529864"
+		       "f3b84b3a e8e3676c e760c461 f3a13e83"),
+		  SHEX("02"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("bbe4751a 549d2fce 410c2efd e0df4d13"
+		       "1a6eac0d 030028f8 dc16b6c4 3a557d4e"
+		       "3e846ad7 52c5a030 c75a85ff 8b07ff10"
+		       "71b133f5 edac3c60 8bb6eb13 dd1fd9"));
+
+  /*
+   * Example with single AAD, length &gt; 16
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+	          &amp;nettle_aes256,
+		  SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+		       "2d568e91 a38e5414 8abdc0b6 e86caf87"
+		       "695c0a8a df4c5f8e b2c6c8b1 36529864"
+		       "f3b84b3a e8e3676c e760c461 f3a13e83"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("5a979b0d a58fde80 51621ae6 bf96feda"
+		       "50933da8 047bc306 fabaf0c3 d9fa8471"
+		       "c70a7def 39a2f91d 68a2021c 99ac7e2a"
+		       "24535a13 4ba23ec1 5787cebe 5c53cc"));
+}
diff --git a/testsuite/testutils.h b/testsuite/testutils.h
index ded57db6..3a1872f1 100644
--- a/testsuite/testutils.h
+++ b/testsuite/testutils.h
@@ -176,6 +176,19 @@ test_armor(const struct nettle_armor *armor,
            const uint8_t *data,
            const char *ascii);
 
+/* AEAD ciphers */
+typedef void
+nettle_encrypt_message_func(void *ctx,
+			    size_t nlength, const uint8_t *nonce,
+			    size_t alength, const uint8_t *adata,
+			    size_t clength, uint8_t *dst, const uint8_t *src);
+
+typedef int
+nettle_decrypt_message_func(void *ctx,
+			    size_t nlength, const uint8_t *nonce,
+			    size_t alength, const uint8_t *adata,
+			    size_t mlength, uint8_t *dst, const uint8_t *src);
+
 #if WITH_HOGWEED
 
 #if NETTLE_USE_MINI_GMP
-- 
2.20.1


["0002-.gitlab-ci.yml-added-make-distcheck-target.patch" (0002-.gitlab-ci.yml-added-make-distcheck-target.patch)]

From 1030249c1ac8be816b3d2bf1863d325bc3fe8827 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 17 Apr 2019 15:17:47 +0200
Subject: [PATCH 2/3] .gitlab-ci.yml: added make distcheck target

This checks whether the distributed tarball misses files
and result to a functioning library.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 .gitlab-ci.yml | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index ecd95ad3..e7101c64 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -50,6 +50,15 @@ build/ndebug:
   - shared
   except:
   - tags
+distcheck:
+  image: $CI_REGISTRY/$BUILD_IMAGES_PROJECT:$FEDORA_BUILD
+  script:
+  - ./.bootstrap &amp;&amp;
+    ./configure --disable-static --disable-assembler &amp;&amp; make distcheck
+  tags:
+  - shared
+  except:
+  - tags
 build/ubsan:
   image: $CI_REGISTRY/$BUILD_IMAGES_PROJECT:$FEDORA_BUILD
   script:
-- 
2.20.1


["0001-cmac-use-nettle_block16-for-const-variable.patch" (0001-cmac-use-nettle_block16-for-const-variable.patch)]

From a0ceb52e7bef137226ec5a1013d154e5516d2ba4 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Tue, 16 Apr 2019 20:19:17 +0200
Subject: [PATCH 1/3] cmac: use nettle_block16 for const variable

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
---
 cmac.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/cmac.c b/cmac.c
index ed3b5eb8..01fee79e 100644
--- a/cmac.c
+++ b/cmac.c
@@ -73,15 +73,15 @@ void
 cmac128_set_key(struct cmac128_ctx *ctx, const void *cipher,
 		nettle_cipher_func *encrypt)
 {
-  static const uint8_t const_zero[] = {
-    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
+  static const union nettle_block16 const_zero = { .b = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00 }
   };
   union nettle_block16 *L = &amp;ctx-&gt;block;
   memset(ctx, 0, sizeof(*ctx));
 
   /* step 1 - generate subkeys k1 and k2 */
-  encrypt(cipher, 16, L-&gt;b, const_zero);
+  encrypt(cipher, 16, L-&gt;b, const_zero.b);
 
   block_mulx(&amp;ctx-&gt;K1, L);
   block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
-- 
2.20.1


[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190417183751</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-04-17 18:37:51-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

On Wed, 2019-04-17 at 20:27 +0200, Nikos Mavrogiannopoulos wrote:
&gt; +  static const union nettle_block16 const_zero = { .b = {
&gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
&gt; +	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00 }

You could save some space/eyes by using .b = 0 (assuming we can depend
on modern C99 semantics) or also just via .u64 = { 0, 0 }

Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190417184151</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-04-17 18:41:51-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt;&gt; In this function, you treat empty associated data or nonce as those
&gt;&gt; elements missing in the input vector to S2V. E.g., if both adata and
&gt;&gt; nonce are empty, the input vector is { plaintext }, one single
&gt;&gt; element.
&gt;&gt; But it could also be { "", "", plaintext }, with three elements, the
&gt;&gt; first two being empty strings.
&gt;
&gt; While the low level function could handle it, it is not exposed to be
&gt; called directly (mainly intentionally as this cipher introduces a very
&gt; new paradigm which I do not quite see much of practical uses).
&gt;
&gt; This patch only adds the higher level AEAD API only, so this case
&gt; cannot happen as we don't have the notion of empty string
&gt; in nettle. We can introduce it of course, though we may be opening a
&gt; can of worms as not only empty strings are undefined in terms of AEAD
&gt; API [0], but what would these mean in the other implementations?
&gt;
&gt; [0]. https://tools.ietf.org/html/rfc5116#section-2

By empty string I simply meant a string of length 0. As I read RFC 5116,
it requires that the key is between 1 and 255 octets (inclusive), but
all of nonce, plaintext and associated data may consist of zero octets.

&gt;&gt; To me, this sounds like a likely source of interop problems. Since
&gt;&gt; RFC
&gt;&gt; 5297 is general and allows the application to decide on the number of
&gt;&gt; elements and meaning of the input vector, it doesn't give much
&gt;&gt; guidance on this, as far as I see. The crucial case is when an
&gt;&gt; application specifies that SIV is used with associated data and/or a
&gt;&gt; nonce, but allows an empty string for either of those.
&gt;
&gt; I agree on that. That's one of the reasons I stuck on the higher level
&gt; AEAD API (expressed by the message APIs in nettle). I added two
&gt; sentences in the documentation about it.

The thing is, the AEAD api should allow inputs to be zero-length
strings. Then the question is how to treat zero-length inputs in
_siv_s2v, and I don't find RFC 5297 crystal clear on this point.

To me, it would make most sense for the AEAD construction to always use
the S2V function in the spec with S1 = associated data (possibly zero
length), S2 = nonce (possibly zero length), S3 = plaintext (possibly
zero length). But we need to do what's needed to make it easy to
interoperate with applicatinos and protocols using SIV; if everyone else
does this differently, we should probably follow.

If we do it this way, then the nonce-less "key wrapping" usecase
mentioned in RFC5297, with the example in A1, is *not* a special case of
the AEAD construction, since this mode uses S1 = associated data, S2 =
plaintext.

If we need to support several modes, maybe we should have a context
struct that lets us do S2V incrementally, one element at a time,

  siv_add_adata(struct siv_ctx *ctx, size_t length, const uint8_t *data);

called zero or more times, followed by

  siv_encrypt(struct siv_ctx *ctx, size_t clength, uint8_t *dst, const uint8_t *src);

which does the CMAC of the plaintext (the final S2V element), extracts
V, and does the encryption. (S2V is defined also for n == 0, but that's
not very useful and we don't need to support it).

But I think we should start with the AEAD-style api with both adata and
nonce mandatory (but possibly empty), before worrying too much about
generalizations.

&gt; Done. It needed some reorganization, and cmac128_syn is still needed in
&gt; an ugly simulation of the CMAC structure setup to use the macros. I
&gt; have kept the union 

Maybe it would be easier without using the CMAC macros. They're intended
for convenience, so there's little point in using them where it doesn't
bring any convenience.

&gt; The attached version should address the comments so far and also
&gt; changes cmac128_set_key to use nettle_block16 as well.

Thanks! I hope to read through the new patch during the weekend.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190418070011</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2019-04-18 07:00:11-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

On Wed, 2019-04-17 at 20:41 +0200, Niels Möller wrote:
&gt; 
&gt; &gt; &gt; To me, this sounds like a likely source of interop problems.
&gt; &gt; &gt; Since
&gt; &gt; &gt; RFC
&gt; &gt; &gt; 5297 is general and allows the application to decide on the
&gt; &gt; &gt; number of
&gt; &gt; &gt; elements and meaning of the input vector, it doesn't give much
&gt; &gt; &gt; guidance on this, as far as I see. The crucial case is when an
&gt; &gt; &gt; application specifies that SIV is used with associated data
&gt; &gt; &gt; and/or a
&gt; &gt; &gt; nonce, but allows an empty string for either of those.
&gt; &gt; 
&gt; &gt; I agree on that. That's one of the reasons I stuck on the higher
&gt; &gt; level
&gt; &gt; AEAD API (expressed by the message APIs in nettle). I added two
&gt; &gt; sentences in the documentation about it.
&gt; 
&gt; The thing is, the AEAD api should allow inputs to be zero-length
&gt; strings. Then the question is how to treat zero-length inputs in
&gt; _siv_s2v, and I don't find RFC 5297 crystal clear on this point.
&gt; 
&gt; To me, it would make most sense for the AEAD construction to always
&gt; use
&gt; the S2V function in the spec with S1 = associated data (possibly zero
&gt; length), S2 = nonce (possibly zero length), S3 = plaintext (possibly
&gt; zero length). But we need to do what's needed to make it easy to
&gt; interoperate with applicatinos and protocols using SIV; if everyone
&gt; else
&gt; does this differently, we should probably follow.

I agree. The patch I sent yesterday is towards that. I have verified
that this approach interoperates with two implementations. The
difference from what you write above is that we don't support at all
the case where nonce=empty. That has interop issues (two
interpretations, skip the field, or use it as empty), and I think it
makes sense to leave it out. It has no use for our interface.

Today's patch adds two more vectors from another implementation and
includes Simo's suggestion.

&gt; 
&gt; If we do it this way, then the nonce-less "key wrapping" usecase
&gt; mentioned in RFC5297, with the example in A1, is *not* a special case
&gt; of
&gt; the AEAD construction, since this mode uses S1 = associated data, S2
&gt; =
&gt; plaintext.
&gt; 
&gt; If we need to support several modes, maybe we should have a context
&gt; struct that lets us do S2V incrementally, one element at a time,

Let's see if that is needed. For key wrapping I know no practical
applications. I'd treat it as a separate algorithm, and we can add it
later if needed. 

&gt; &gt; Done. It needed some reorganization, and cmac128_syn is still
&gt; &gt; needed in
&gt; &gt; an ugly simulation of the CMAC structure setup to use the macros. I
&gt; &gt; have kept the union 
&gt; 
&gt; Maybe it would be easier without using the CMAC macros. They're
&gt; intended
&gt; for convenience, so there's little point in using them where it
&gt; doesn't
&gt; bring any convenience.

I do not think that avoiding them would change this part.

regards,
Nikos


["0001-cmac-use-nettle_block16-for-const-variable.patch" (0001-cmac-use-nettle_block16-for-const-variable.patch)]

From a0ceb52e7bef137226ec5a1013d154e5516d2ba4 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Tue, 16 Apr 2019 20:19:17 +0200
Subject: [PATCH 1/3] cmac: use nettle_block16 for const variable

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
---
 cmac.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/cmac.c b/cmac.c
index ed3b5eb8..01fee79e 100644
--- a/cmac.c
+++ b/cmac.c
@@ -73,15 +73,15 @@ void
 cmac128_set_key(struct cmac128_ctx *ctx, const void *cipher,
 		nettle_cipher_func *encrypt)
 {
-  static const uint8_t const_zero[] = {
-    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00
+  static const union nettle_block16 const_zero = { .b = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00 }
   };
   union nettle_block16 *L = &amp;ctx-&gt;block;
   memset(ctx, 0, sizeof(*ctx));
 
   /* step 1 - generate subkeys k1 and k2 */
-  encrypt(cipher, 16, L-&gt;b, const_zero);
+  encrypt(cipher, 16, L-&gt;b, const_zero.b);
 
   block_mulx(&amp;ctx-&gt;K1, L);
   block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
-- 
2.20.1


["0002-.gitlab-ci.yml-added-make-distcheck-target.patch" (0002-.gitlab-ci.yml-added-make-distcheck-target.patch)]

From 1030249c1ac8be816b3d2bf1863d325bc3fe8827 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 17 Apr 2019 15:17:47 +0200
Subject: [PATCH 2/3] .gitlab-ci.yml: added make distcheck target

This checks whether the distributed tarball misses files
and result to a functioning library.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 .gitlab-ci.yml | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index ecd95ad3..e7101c64 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -50,6 +50,15 @@ build/ndebug:
   - shared
   except:
   - tags
+distcheck:
+  image: $CI_REGISTRY/$BUILD_IMAGES_PROJECT:$FEDORA_BUILD
+  script:
+  - ./.bootstrap &amp;&amp;
+    ./configure --disable-static --disable-assembler &amp;&amp; make distcheck
+  tags:
+  - shared
+  except:
+  - tags
 build/ubsan:
   image: $CI_REGISTRY/$BUILD_IMAGES_PROJECT:$FEDORA_BUILD
   script:
-- 
2.20.1


["0003-Added-support-for-AES_SIV_CMAC_256-and-AES_SIV_CMAC_.patch" (0003-Added-support-for-AES_SIV_CMAC_256-and-AES_SIV_CMAC_.patch)]

From efeb8451efa6e68b995830f19005354785aba2ba Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Sat, 20 Jan 2018 10:36:05 +0100
Subject: [PATCH 3/3] Added support for AES_SIV_CMAC_256 and AES_SIV_CMAC_512

This AEAD algorithm provides a way to make nonce-reuse a not critical
issue. That is particular useful to stateless servers that cannot ensure
that the nonce will not repeat. This cipher is used by
draft-ietf-ntp-using-nts-for-ntp-17.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 Makefile.in                |   4 +-
 cmac-internal.h            |  54 ++++++
 cmac.c                     |  15 +-
 nettle-internal.h          |   2 +
 nettle.texinfo             |  94 ++++++++-
 siv-aes128-cmac.c          |  75 ++++++++
 siv-aes256-cmac.c          |  75 ++++++++
 siv-cmac.c                 | 183 ++++++++++++++++++
 siv-cmac.h                 | 131 +++++++++++++
 testsuite/.gitignore       |   2 +
 testsuite/.test-rules.make |   3 +
 testsuite/Makefile.in      |   2 +-
 testsuite/siv-test.c       | 383 +++++++++++++++++++++++++++++++++++++
 testsuite/testutils.h      |  13 ++
 14 files changed, 1025 insertions(+), 11 deletions(-)
 create mode 100644 cmac-internal.h
 create mode 100644 siv-aes128-cmac.c
 create mode 100644 siv-aes256-cmac.c
 create mode 100644 siv-cmac.c
 create mode 100644 siv-cmac.h
 create mode 100644 testsuite/siv-test.c

diff --git a/Makefile.in b/Makefile.in
index 440de9f7..962a6b73 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -89,6 +89,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 camellia256-meta.c \
 		 cast128.c cast128-meta.c cbc.c \
 		 ccm.c ccm-aes128.c ccm-aes192.c ccm-aes256.c cfb.c \
+		 siv-cmac.c siv-aes128-cmac.c siv-aes256-cmac.c \
 		 cnd-memcpy.c \
 		 chacha-crypt.c chacha-core-internal.c \
 		 chacha-poly1305.c chacha-poly1305-meta.c \
@@ -198,7 +199,8 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  gcm.h gosthash94.h hmac.h \
 	  knuth-lfib.h hkdf.h \
 	  macros.h \
-	  cmac.h \
+	  cmac.h cmac-internal.h \
+	  siv-cmac.h \
 	  md2.h md4.h \
 	  md5.h md5-compat.h \
 	  memops.h memxor.h \
diff --git a/cmac-internal.h b/cmac-internal.h
new file mode 100644
index 00000000..789588e6
--- /dev/null
+++ b/cmac-internal.h
@@ -0,0 +1,54 @@
+/* cmac.h
+
+   CMAC mode internal functions
+
+   Copyright (C) 2017 Red Hat, Inc.
+
+   Contributed by Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_CMAC_INTERNAL_H_INCLUDED
+#define NETTLE_CMAC_INTERNAL_H_INCLUDED
+
+#include "cmac.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define _cmac128_block_mulx _nettle_cmac128_block_mulx
+
+void _cmac128_block_mulx(union nettle_block16 *out,
+			 const union nettle_block16 *in);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CMAC_INTERNAL_H_INCLUDED */
diff --git a/cmac.c b/cmac.c
index 01fee79e..8be1cca4 100644
--- a/cmac.c
+++ b/cmac.c
@@ -44,13 +44,13 @@
 
 #include "memxor.h"
 #include "nettle-internal.h"
+#include "cmac-internal.h"
 #include "macros.h"
 
 /* shift one and XOR with 0x87. */
 #if WORDS_BIGENDIAN
-static void
-block_mulx(union nettle_block16 *dst,
-	   const union nettle_block16 *src)
+void _cmac128_block_mulx(union nettle_block16 *dst,
+			 const union nettle_block16 *src)
 {
   uint64_t carry = src-&gt;u64[0] &gt;&gt; 63;
   dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
@@ -59,9 +59,8 @@ block_mulx(union nettle_block16 *dst,
 #else /* !WORDS_BIGENDIAN */
 #define LE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
                      (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
-static void
-block_mulx(union nettle_block16 *dst,
-	   const union nettle_block16 *src)
+void _cmac128_block_mulx(union nettle_block16 *dst,
+			 const union nettle_block16 *src)
 {
   uint64_t carry = (src-&gt;u64[0] &amp; 0x80) &gt;&gt; 7;
   dst-&gt;u64[0] = LE_SHIFT(src-&gt;u64[0]) | ((src-&gt;u64[1] &amp; 0x80) &lt;&lt; 49);
@@ -83,8 +82,8 @@ cmac128_set_key(struct cmac128_ctx *ctx, const void *cipher,
   /* step 1 - generate subkeys k1 and k2 */
   encrypt(cipher, 16, L-&gt;b, const_zero.b);
 
-  block_mulx(&amp;ctx-&gt;K1, L);
-  block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
+  _cmac128_block_mulx(&amp;ctx-&gt;K1, L);
+  _cmac128_block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
 }
 
 #define MIN(x,y) ((x)&lt;(y)?(x):(y))
diff --git a/nettle-internal.h b/nettle-internal.h
index dc379f1f..2937a710 100644
--- a/nettle-internal.h
+++ b/nettle-internal.h
@@ -78,6 +78,8 @@
 #define NETTLE_MAX_HASH_CONTEXT_SIZE (sizeof(struct sha3_224_ctx))
 #define NETTLE_MAX_SEXP_ASSOC 17
 #define NETTLE_MAX_CIPHER_BLOCK_SIZE 32
+/* maximum context size of 128-bit block ciphers */
+#define NETTLE_MAX_CIPHER16_CONTEXT_SIZE (sizeof(struct aes256_ctx))
 
 /* Doesn't quite fit with the other algorithms, because of the weak
  * keys. Weak keys are not reported, the functions will simply crash
diff --git a/nettle.texinfo b/nettle.texinfo
index 596c7098..b83c13d0 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -97,6 +97,7 @@ Cipher modes
 * CFB and CFB8::
 * GCM::                         
 * CCM::                         
+* SIV-CMAC::
 
 Keyed Hash Functions
 
@@ -2565,6 +2566,7 @@ more adventurous alternative, in particular if performance is \
                important.
 * GCM::                         
 * CCM::                         
 * ChaCha-Poly1305::
+* SIV-CMAC::
 * nettle_aead abstraction::
 @end menu
 
@@ -3212,7 +3214,7 @@ These are identical to @code{ccm_encrypt_message} and \
@code{ccm_decrypt_message}  except that @var{cipher} and @var{f} are replaced with a \
context structure.  @end deftypefun
 
-@node ChaCha-Poly1305, nettle_aead abstraction, CCM, Authenticated encryption
+@node ChaCha-Poly1305, SIV-CMAC, CCM, Authenticated encryption
 @comment  node-name,  next,  previous,  up
 @subsection ChaCha-Poly1305
 
@@ -3295,6 +3297,96 @@ smaller than @code{CHACHA_POLY1305_DIGEST_SIZE}, only the \
first  @var{length} octets of the digest are written.
 @end deftypefun
 
+@node SIV-CMAC, nettle_aead abstraction, ChaCha-Poly1305, Authenticated encryption
+@comment  node-name,  next,  previous,  up
+@subsection Counter with CBC-MAC mode
+
+@cindex SIV mode
+@cindex SIV-CMAC mode
+
+@acronym{SIV-CMAC} mode is a combination of counter mode with message
+authentication based on @acronym{CMAC}. Unlike other counter @acronym{AEAD}
+modes, it provides protection against accidental nonce misuse, making it
+a good choice for stateless-servers that cannot ensure nonce uniqueness.
+It is constructed on top of a block cipher which must have a block size of
+128 bits. Nettle's support for @acronym{SIV-CMAC} consists of
+a message encryption and authentication interface, for
+@acronym{SIV-CMAC} using AES as the underlying block cipher.
+When a nonce is re-used with this mode, message authenticity is retained
+however an attacker can determine whether the same plaintext was protected
+with the two messages sharing the nonce.
+These interfaces are defined in @file{&lt;nettle/siv-cmac.h&gt;}.
+
+Unlike other @acronym{AEAD} mode in @acronym{SIV-CMAC} the initialization
+vector serves as the tag. That means that in the generated ciphertext
+the tag precedes the ciphertext.
+
+Note also, that the @acronym{SIV-CMAC} algorithm introduces the notion
+of authenticated data which consist of multiple components. For example
+with @acronym{SIV-CMAC} the authentication tag of data @code{X} followed
+by @code{Y}, is different than the concatenated data @code{X || Y}. The interfaces
+described below follow the @acronym{AEAD} paradigm and do not allow access
+to this feature and also require the use of a non-zero tag.
+
+@subsubsection General interface
+
+@defvr Constant SIV_BLOCK_SIZE
+@acronym{SIV-CMAC}'s block size, 16.
+@end defvr
+
+@defvr Constant SIV_DIGEST_SIZE
+Size of the @acronym{SIV-CMAC} digest or initialization vector, 16.
+@end defvr
+
+@defvr Constant SIV_MIN_NONCE_SIZE
+The the minimumsizes for an @acronym{SIV-CMAC} nonce, 0
+@end defvr
+
+@subsubsection @acronym{SIV-CMAC}-@acronym{AES} interface
+
+The @acronym{AES} @acronym{SIV-CMAC} functions provide an API for using
+@acronym{SIV-CMAC} mode with the @acronym{AES} block ciphers. The parameters
+all have the same meaning as the general and message interfaces, except
+that the @var{cipher}, @var{f}, and @var{ctx} parameters are replaced
+with an @acronym{AES} context structure, and a set-key function must be
+called before using any of the other functions in this interface.
+
+@deftp {Context struct} {struct siv_aes128_cmac_ctx}
+Holds state corresponding to a particular message encrypted using the
+AES-128 block cipher.
+@end deftp
+
+@deftp {Context struct} {struct siv_aes256_cmac_ctx}
+Holds state corresponding to a particular message encrypted using the
+AES-256 block cipher.
+@end deftp
+
+@deftypefun void siv_aes128_cmac_set_key (struct siv_aes128_cmac_ctx *@var{ctx}, \
const uint8_t *@var{key}) +@deftypefunx void siv_aes256_cmac_set_key (struct \
siv_aes256_cmac_ctx *@var{ctx}, const uint8_t *@var{key}) +Initializes the encryption \
key for the AES block cipher. One of these +functions must be called before any of \
the other functions in the +@acronym{AES} @acronym{SIV-CMAC} interface.
+@end deftypefun
+
+@deftypefun void siv_aes128_cmac_encrypt_message (struct siv_aes128_cmac_ctx \
*@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, \
const uint8_t *@var{adata}, size_t @var{clength}, uint8_t *@var{dst}, const uint8_t \
*@var{src}) +@deftypefunx void siv_aes256_cmac_encrypt_message (struct \
siv_aes256_cmac_ctx *@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, \
size_t @var{alength}, const uint8_t *@var{adata}, size_t @var{clength}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +Computes the message digest from the \
@var{adata} and @var{src} +parameters, encrypts the plaintext from @var{src}, \
prepends the +initialization vector to the ciphertext and outputs it to @var{dst}.
+The @var{clength} variable must be equal to the length of @var{src}
+plus @code{SIV_DIGEST_SIZE}.
+
+@end deftypefun
+
+@deftypefun int siv_aes128_cmac_decrypt_message (struct siv_aes128_cmac_ctx \
*@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, \
const uint8_t *@var{adata}, size_t @var{mlength}, uint8_t *@var{dst}, const uint8_t \
*@var{src}) +@deftypefunx int siv_aes256_cmac_decrypt_message (struct \
siv_aes128_cmac_ctx *@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, \
size_t @var{alength}, const uint8_t *@var{adata}, size_t @var{mlength}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +Decrypts the ciphertext from @var{src}, \
outputs the plaintext to +@var{dst}, recalculates the initialization vector from \
@var{adata} and the +plaintext. If the values of the received and calculated \
initialization vector +are equal, this will return 1 indicating a valid and \
authenticated +message. Otherwise, this function will return zero.
+@end deftypefun
+
 @node nettle_aead abstraction, , ChaCha-Poly1305, Authenticated encryption
 @comment  node-name,  next,  previous,  up
 @subsection The @code{struct nettle_aead} abstraction
diff --git a/siv-aes128-cmac.c b/siv-aes128-cmac.c
new file mode 100644
index 00000000..793279d1
--- /dev/null
+++ b/siv-aes128-cmac.c
@@ -0,0 +1,75 @@
+/* siv-aes128.c
+
+   AES-SIV, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "aes.h"
+#include "siv-cmac.h"
+#include "cmac.h"
+#include "ctr.h"
+#include "memxor.h"
+#include "memops.h"
+#include "cmac-internal.h"
+
+void
+siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const uint8_t *key)
+{
+  siv_cmac_set_key(&amp;ctx-&gt;siv_cmac, &amp;ctx-&gt;siv_cipher, &amp;nettle_aes128, key);
+}
+
+void
+siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t clength, uint8_t *dst, const uint8_t *src)
+{
+  siv_cmac_encrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes128, &amp;ctx-&gt;siv_cipher,
+			   nlength, nonce, alength, adata,
+			   clength, dst, src);
+}
+
+int
+siv_aes128_cmac_decrypt_message(struct siv_aes128_cmac_ctx *ctx,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  return siv_cmac_decrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes128, &amp;ctx-&gt;siv_cipher,
+				  nlength, nonce, alength, adata,
+				  mlength, dst, src);
+}
diff --git a/siv-aes256-cmac.c b/siv-aes256-cmac.c
new file mode 100644
index 00000000..61cd1163
--- /dev/null
+++ b/siv-aes256-cmac.c
@@ -0,0 +1,75 @@
+/* siv-aes128.c
+
+   AES-SIV, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "aes.h"
+#include "siv-cmac.h"
+#include "cmac.h"
+#include "ctr.h"
+#include "memxor.h"
+#include "memops.h"
+#include "cmac-internal.h"
+
+void
+siv_aes256_cmac_set_key(struct siv_aes256_cmac_ctx *ctx, const uint8_t *key)
+{
+  siv_cmac_set_key(&amp;ctx-&gt;siv_cmac, &amp;ctx-&gt;siv_cipher, &amp;nettle_aes256, key);
+}
+
+void
+siv_aes256_cmac_encrypt_message(struct siv_aes256_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t clength, uint8_t *dst, const uint8_t *src)
+{
+  siv_cmac_encrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes256, &amp;ctx-&gt;siv_cipher,
+			   nlength, nonce, alength, adata,
+			   clength, dst, src);
+}
+
+int
+siv_aes256_cmac_decrypt_message(struct siv_aes256_cmac_ctx *ctx,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  return siv_cmac_decrypt_message(&amp;ctx-&gt;siv_cmac, &amp;nettle_aes256, &amp;ctx-&gt;siv_cipher,
+				  nlength, nonce, alength, adata,
+				  mlength, dst, src);
+}
diff --git a/siv-cmac.c b/siv-cmac.c
new file mode 100644
index 00000000..2374be50
--- /dev/null
+++ b/siv-cmac.c
@@ -0,0 +1,183 @@
+/* siv-cmac.c
+
+   SIV-CMAC, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "aes.h"
+#include "siv-cmac.h"
+#include "cmac.h"
+#include "ctr.h"
+#include "memxor.h"
+#include "memops.h"
+#include "cmac-internal.h"
+#include "nettle-internal.h"
+
+/* This is only to allow the CMAC macros to expand in
+ * _siv_s2v */
+struct cmac128_syn {
+  struct cmac128_ctx ctx;
+  union {
+    uint64_t pad1[2]; /* to force a good alignment */
+    uint8_t pad[NETTLE_MAX_CIPHER16_CONTEXT_SIZE+16];
+  } cipher;
+};
+
+/* This is an implementation of S2V for the AEAD case where
+ * vectors if zero, are considered as S empty components */
+static
+void _siv_s2v(const struct nettle_cipher *nc,
+	      struct cmac128_syn *ctx,
+	      size_t alength, const uint8_t *adata,
+              size_t nlength, const uint8_t *nonce,
+              size_t plength, const uint8_t *pdata,
+              uint8_t *v)
+{
+  union nettle_block16 D, S, T;
+  static const union nettle_block16 const_zero = { .b = 0 };
+
+  assert(nc-&gt;context_size &lt;= NETTLE_MAX_CIPHER16_CONTEXT_SIZE);
+
+  /* the only unambiguous mode of this cipher is when a nonce
+   * is provided in AEAD mode.  */
+  assert(nlength != 0);
+
+  CMAC128_UPDATE(ctx, nc-&gt;encrypt, 16, const_zero.b);
+  CMAC128_DIGEST(ctx, nc-&gt;encrypt, 16, D.b);
+
+  _cmac128_block_mulx(&amp;D, &amp;D);
+  CMAC128_UPDATE(ctx, nc-&gt;encrypt, alength, adata);
+  CMAC128_DIGEST(ctx, nc-&gt;encrypt, 16, S.b);
+  memxor(D.b, S.b, 16);
+
+  _cmac128_block_mulx(&amp;D, &amp;D);
+  CMAC128_UPDATE(ctx, nc-&gt;encrypt, nlength, nonce);
+  CMAC128_DIGEST(ctx, nc-&gt;encrypt, 16, S.b);
+  memxor(D.b, S.b, 16);
+
+  /* Sn */
+  if (plength &gt;= 16) {
+    CMAC128_UPDATE(ctx, nc-&gt;encrypt, plength-16, pdata);
+
+    pdata += plength-16;
+
+    memxor3(T.b, pdata, D.b, 16);
+  } else {
+    union nettle_block16 pad;
+
+    _cmac128_block_mulx(&amp;T, &amp;D);
+    memcpy(pad.b, pdata, plength);
+    pad.b[plength] = 0x80;
+    if (plength+1 &lt; 16)
+      memset(&amp;pad.b[plength+1], 0, 16-plength-1);
+
+    memxor(T.b, pad.b, 16);
+  }
+
+  CMAC128_UPDATE(ctx, nc-&gt;encrypt, 16, T.b);
+  CMAC128_DIGEST(ctx, nc-&gt;encrypt, 16, v);
+}
+
+void
+siv_cmac_set_key(void *_ctx, void *cipher,
+		 const struct nettle_cipher *nc,
+		 const uint8_t *key)
+{
+	/* We rely on the fact that the siv_cmac member of the context
+	 * is first in the context provided */
+	struct cmac128_syn *ctx = _ctx;
+
+	assert(nc-&gt;key_size &lt;= SIV_MAX_KEY_SIZE/2);
+
+	CMAC128_SET_KEY(ctx, nc-&gt;set_encrypt_key, nc-&gt;encrypt, key);
+	nc-&gt;set_encrypt_key(cipher, key+nc-&gt;key_size);
+}
+
+void
+siv_cmac_encrypt_message(void *ctx,
+			 const struct nettle_cipher *nc,
+			 const void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t clength, uint8_t *dst, const uint8_t *src)
+{
+	union nettle_block16 siv;
+	size_t slength;
+
+	assert(clength &gt;= SIV_DIGEST_SIZE);
+	slength = clength - SIV_DIGEST_SIZE;
+
+	/* create CTR nonce */
+	_siv_s2v(nc,
+		 ctx, alength, adata,
+		 nlength, nonce, slength, src, siv.b);
+
+	memcpy(dst, siv.b, SIV_DIGEST_SIZE);
+	siv.b[8] &amp;= ~0x80;
+	siv.b[12] &amp;= ~0x80;
+
+	ctr_crypt(cipher, nc-&gt;encrypt, AES_BLOCK_SIZE, siv.b, slength, dst+SIV_DIGEST_SIZE, \
src); +}
+
+int
+siv_cmac_decrypt_message(void *ctx,
+			 const struct nettle_cipher *nc,
+			 const void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  union nettle_block16 siv;
+  union nettle_block16 ctr;
+
+  assert(mlength &gt;= SIV_DIGEST_SIZE);
+
+  memcpy(ctr.b, src, SIV_DIGEST_SIZE);
+  ctr.b[8] &amp;= ~0x80;
+  ctr.b[12] &amp;= ~0x80;
+
+  ctr_crypt(cipher, nc-&gt;encrypt, AES_BLOCK_SIZE, ctr.b,
+            mlength-SIV_DIGEST_SIZE, dst, src+SIV_DIGEST_SIZE);
+
+  /* create CTR nonce */
+  _siv_s2v(nc,
+	   ctx, alength, adata,
+	   nlength, nonce, mlength-SIV_DIGEST_SIZE, dst, siv.b);
+
+  return memeql_sec(siv.b, src, SIV_DIGEST_SIZE);
+}
+
diff --git a/siv-cmac.h b/siv-cmac.h
new file mode 100644
index 00000000..ffbe4623
--- /dev/null
+++ b/siv-cmac.h
@@ -0,0 +1,131 @@
+/* siv.h
+
+   AES-SIV, RFC5297
+
+   Copyright (C) 2017 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_SIV_H_INCLUDED
+#define NETTLE_SIV_H_INCLUDED
+
+#include "nettle-types.h"
+#include "nettle-meta.h"
+#include "cmac.h"
+#include "aes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define siv_cmac_set_key nettle_siv_cmac_set_key
+#define siv_cmac_encrypt_message nettle_siv_cmac_encrypt_message
+#define siv_cmac_decrypt_message nettle_siv_cmac_decrypt_message
+#define siv_aes128_cmac_set_key nettle_siv_aes128_cmac_set_key
+#define siv_aes128_cmac_encrypt_message nettle_siv_aes128_cmac_encrypt_message
+#define siv_aes128_cmac_decrypt_message nettle_siv_aes128_cmac_decrypt_message
+#define siv_aes256_cmac_set_key nettle_siv_aes256_cmac_set_key
+#define siv_aes256_cmac_encrypt_message nettle_siv_aes256_cmac_encrypt_message
+#define siv_aes256_cmac_decrypt_message nettle_siv_aes256_cmac_decrypt_message
+
+/* For SIV, the block size of the block cipher shall be 128 bits. */
+#define SIV_BLOCK_SIZE  16
+#define SIV_DIGEST_SIZE 16
+#define SIV_MIN_NONCE_SIZE 0
+#define SIV_MAX_KEY_SIZE (AES_MAX_KEY_SIZE*2)
+
+void
+siv_cmac_set_key(void *ctx, void *cipher,
+		 const struct nettle_cipher *nc,
+		 const uint8_t *key);
+
+void
+siv_cmac_encrypt_message(void *ctx,
+			 const struct nettle_cipher *nc,
+			 const void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+siv_cmac_decrypt_message(void *ctx,
+			 const struct nettle_cipher *nc,
+			 const void *cipher,
+			 size_t nlength, const uint8_t *nonce,
+			 size_t alength, const uint8_t *adata,
+			 size_t mlength, uint8_t *dst, const uint8_t *src);
+
+/*
+ * SIV mode requires the aad and plaintext when building the IV, which
+ * prevents streaming processing and it incompatible with the AEAD API.
+ */
+
+#define SIV_CMAC_CTX(type) { struct CMAC128_CTX(type) siv_cmac; type siv_cipher; }
+
+/* AES_SIV_CMAC_256 */
+struct siv_aes128_cmac_ctx SIV_CMAC_CTX(struct aes128_ctx);
+
+void
+siv_aes128_cmac_set_key(struct siv_aes128_cmac_ctx *ctx, const uint8_t *key);
+
+void
+siv_aes128_cmac_encrypt_message(struct siv_aes128_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+siv_aes128_cmac_decrypt_message(struct siv_aes128_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t mlength, uint8_t *dst, const uint8_t *src);
+
+/* AES_SIV_CMAC_512 */
+struct siv_aes256_cmac_ctx SIV_CMAC_CTX(struct aes256_ctx);
+
+void
+siv_aes256_cmac_set_key(struct siv_aes256_cmac_ctx *ctx, const uint8_t *key);
+
+void
+siv_aes256_cmac_encrypt_message(struct siv_aes256_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+siv_aes256_cmac_decrypt_message(struct siv_aes256_cmac_ctx *ctx,
+				size_t nlength, const uint8_t *nonce,
+				size_t alength, const uint8_t *adata,
+				size_t mlength, uint8_t *dst, const uint8_t *src);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_SIV_H_INCLUDED */
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index c3fc5c11..2a0d87ac 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -96,6 +96,8 @@
 /version-test
 /yarrow-test
 /xts-test
+/cmac-test
+/siv-test
 
 /test.in
 /test1.out
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 6eee6e22..f827175e 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -136,6 +136,9 @@ ccm-test$(EXEEXT): ccm-test.$(OBJEXT)
 cmac-test$(EXEEXT): cmac-test.$(OBJEXT)
 	$(LINK) cmac-test.$(OBJEXT) $(TEST_OBJS) -o cmac-test$(EXEEXT)
 
+siv-test$(EXEEXT): siv-test.$(OBJEXT)
+	$(LINK) siv-test.$(OBJEXT) $(TEST_OBJS) -o siv-test$(EXEEXT)
+
 poly1305-test$(EXEEXT): poly1305-test.$(OBJEXT)
 	$(LINK) poly1305-test.$(OBJEXT) $(TEST_OBJS) -o poly1305-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 287c4f75..1bd42ffa 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -27,7 +27,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    serpent-test.c twofish-test.c version-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c cfb-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
-		    cmac-test.c \
+		    cmac-test.c siv-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
diff --git a/testsuite/siv-test.c b/testsuite/siv-test.c
new file mode 100644
index 00000000..1949de7d
--- /dev/null
+++ b/testsuite/siv-test.c
@@ -0,0 +1,383 @@
+/* siv-test.c
+
+   Self-test and vectors for AES-SIV mode ciphers
+
+   Copyright (C) 2018 Nikos Mavrogiannopoulos
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+/* The
+ * test vectors have been collected from the following standards:
+ *  RFC5297
+ */
+
+#include "testutils.h"
+#include "aes.h"
+#include "nettle-types.h"
+#include "siv-cmac.h"
+#include "knuth-lfib.h"
+
+static void
+test_compare_results(const char *name,
+        const struct tstring *adata,
+        /* Expected results. */
+        const struct tstring *e_clear,
+	const struct tstring *e_cipher,
+        /* Actual results. */
+        const void *clear,
+        const void *cipher,
+        const void *digest) /* digest optional. */
+{
+  if (digest &amp;&amp; !MEMEQ(SIV_DIGEST_SIZE, e_cipher-&gt;data, digest))
+    {
+      fprintf(stderr, "%s digest failed:\nAdata:", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(SIV_DIGEST_SIZE, digest);
+      fprintf(stderr, "\nExpected:");
+      print_hex(SIV_DIGEST_SIZE, e_cipher-&gt;data);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  if (!MEMEQ(e_cipher-&gt;length, e_cipher-&gt;data, cipher))
+    {
+      fprintf(stderr, "%s: encryption failed\nAdata: ", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_cipher-&gt;length, cipher);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_cipher);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  if (!MEMEQ(e_clear-&gt;length, e_clear-&gt;data, clear))
+    {
+      fprintf(stderr, "%s decrypt failed:\nAdata:", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_cipher);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_clear-&gt;length, clear);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+} /* test_compare_results */
+
+static void
+test_cipher_siv(const char *name,
+		nettle_set_key_func *siv_set_key,
+		nettle_encrypt_message_func *siv_encrypt,
+		nettle_decrypt_message_func *siv_decrypt,
+		unsigned context_size,
+		const struct nettle_cipher *cipher,
+		const struct tstring *key,
+		const struct tstring *nonce,
+		const struct tstring *authdata,
+		const struct tstring *cleartext,
+		const struct tstring *ciphertext)
+{
+  void *ctx = xalloc(context_size);
+  uint8_t *en_data;
+  uint8_t *de_data;
+  int ret;
+
+  ASSERT (key-&gt;length == cipher-&gt;key_size*2);
+  ASSERT (cleartext-&gt;length &lt;= ciphertext-&gt;length);
+  ASSERT ((cleartext-&gt;length + SIV_BLOCK_SIZE) &gt;= ciphertext-&gt;length);
+  ASSERT (ciphertext-&gt;length - cleartext-&gt;length == SIV_DIGEST_SIZE);
+
+  de_data = xalloc(cleartext-&gt;length+SIV_DIGEST_SIZE);
+  en_data = xalloc(ciphertext-&gt;length);
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+
+  /* Ensure we get the same answers using the all-in-one API. */
+  memset(de_data, 0, cleartext-&gt;length);
+  memset(en_data, 0, ciphertext-&gt;length);
+
+  siv_set_key(ctx, key-&gt;data);
+  siv_encrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+	      authdata-&gt;length, authdata-&gt;data,
+	      cleartext-&gt;length+SIV_DIGEST_SIZE, en_data, cleartext-&gt;data);
+
+  ret = siv_decrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+				        authdata-&gt;length, authdata-&gt;data,
+				        ciphertext-&gt;length, de_data, ciphertext-&gt;data);
+
+  if (ret != 1) fprintf(stderr, "siv_decrypt_message failed to validate message\n");
+    test_compare_results(name, authdata,
+			 cleartext, ciphertext, de_data, en_data, NULL);
+
+  test_compare_results(name, authdata,
+		       cleartext, ciphertext, de_data, en_data, en_data);
+
+
+  /* Ensure that we can detect corrupted message or tag data. */
+  en_data[0] ^= 1;
+  ret = siv_decrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+	            authdata-&gt;length, authdata-&gt;data,
+		    ciphertext-&gt;length, de_data, en_data);
+  if (ret != 0) fprintf(stderr, "siv_decrypt_message failed to detect corrupted \
message\n"); +
+  /* Ensure we can detect corrupted adata. */
+  if (authdata-&gt;length) {
+    en_data[0] ^= 1;
+    ret = siv_decrypt(ctx, nonce-&gt;length, nonce-&gt;data,
+		      authdata-&gt;length-1, authdata-&gt;data,
+		      ciphertext-&gt;length, de_data, en_data);
+    if (ret != 0) fprintf(stderr, "siv_decrypt_message failed to detect corrupted \
message\n"); +  }
+
+
+  free(ctx);
+  free(en_data);
+  free(de_data);
+}
+
+#define test_siv_aes128(name, ctx_size, cipher, key, nonce, authdata, cleartext, \
ciphertext) \ +	test_cipher_siv(name, (nettle_set_key_func*)siv_aes128_cmac_set_key, \
\ +			(nettle_encrypt_message_func*)siv_aes128_cmac_encrypt_message, \
+			(nettle_decrypt_message_func*)siv_aes128_cmac_decrypt_message, ctx_size, cipher, \
\ +			key, nonce, authdata, cleartext, ciphertext)
+
+#define test_siv_aes256(name, ctx_size, cipher, key, nonce, authdata, cleartext, \
ciphertext) \ +	test_cipher_siv(name, (nettle_set_key_func*)siv_aes256_cmac_set_key, \
\ +			(nettle_encrypt_message_func*)siv_aes256_cmac_encrypt_message, \
+			(nettle_decrypt_message_func*)siv_aes256_cmac_decrypt_message, ctx_size, cipher, \
\ +			key, nonce, authdata, cleartext, ciphertext)
+
+void
+test_main(void)
+{
+  /* The following tests were checked for interoperability against libaes_siv */
+
+  /*
+   * Example with small nonce, no AD and no plaintext
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"),
+		  SHEX("01"),
+		  SHEX(""),
+		  SHEX(""),
+		  SHEX("c696f84f df92aba3 c31c23d5 f2087513"));
+  /*
+   * Example with small nonce, no AD and plaintext
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"),
+		  SHEX("02"),
+		  SHEX(""),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"),
+		  SHEX("5027b101 589747b8 865a9790 d3fd51d7"
+		       "1f259d40 5bfa260b 9ba1d60a a287fd0b"));
+
+  /*
+   * Example with length &lt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"),
+		  SHEX("02"),
+		  SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+		       "20212223 24252627"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("7300cd9b 3f514a44 ed660db6 14157f59"
+		       "f0382e23 ae0e6e62 27a03dd3 2619"));
+
+  /*
+   * Example with length &gt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX("020304"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("f1dba33d e5b3369e 883f67b6 fc823cee"
+		       "a4ffb87f dba97c89 44a62325 f133b4e0"
+		       "1ca55276 e2261c1a 1d1d4248 d1da30ba"
+		       "52b9c8d7 955d65c8 d2ce6eb7 e367d0"));
+
+  /*
+   * Example with single AAD, length &gt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+	          &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("85825e22 e90cf2dd da2c548d c7c1b631"
+		       "0dcdaca0 cebf9dc6 cb90583f 5bf1506e"
+		       "02cd4883 2b00e4e5 98b2b22a 53e6199d"
+		       "4df0c166 6a35a043 3b250dc1 34d776"));
+
+  /*
+   * Example with single AAD, length &lt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+	          &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("15f83882 14bdc94e 3ec4c7c3 69863746"
+		       "cd72d317 4b20a1e4 a0894fb7 cd78"));
+
+  /* AES-SIV-CMAC-512 (AES-256) from dchest/siv repo
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+		  &amp;nettle_aes256,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "6f6e6d6c 6b6a6968 67666564 63626160"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"
+		       "00010203 04050607 08090a0b 0c0d0e0f"),
+		  SHEX("02"),
+		  SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+		       "20212223 24252627"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("6f740b42 1e2972d8 5e76189e 99842843"
+		       "ad9e6ff1 4ea97c32 ab315e67 464c"));
+
+
+  /* AES-SIV-CMAC-512 (AES-256)
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+		  &amp;nettle_aes256,
+		  SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+		       "2d568e91 a38e5414 8abdc0b6 e86caf87"
+		       "695c0a8a df4c5f8e b2c6c8b1 36529864"
+		       "f3b84b3a e8e3676c e760c461 f3a13e83"),
+		  SHEX("02"),
+		  SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+		       "20212223 24252627"),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("c3366ef8 92911eac 3d17f29a 37d4ebad"
+		       "ddc1219e bbde06d1 ee893e55 a39f"));
+
+  /*
+   * Example with length &gt; 16
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+		  &amp;nettle_aes256,
+		  SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+		       "2d568e91 a38e5414 8abdc0b6 e86caf87"
+		       "695c0a8a df4c5f8e b2c6c8b1 36529864"
+		       "f3b84b3a e8e3676c e760c461 f3a13e83"),
+		  SHEX("02"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("bbe4751a 549d2fce 410c2efd e0df4d13"
+		       "1a6eac0d 030028f8 dc16b6c4 3a557d4e"
+		       "3e846ad7 52c5a030 c75a85ff 8b07ff10"
+		       "71b133f5 edac3c60 8bb6eb13 dd1fd9"));
+
+  /*
+   * Example with single AAD, length &gt; 16
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+	          &amp;nettle_aes256,
+		  SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+		       "2d568e91 a38e5414 8abdc0b6 e86caf87"
+		       "695c0a8a df4c5f8e b2c6c8b1 36529864"
+		       "f3b84b3a e8e3676c e760c461 f3a13e83"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("5a979b0d a58fde80 51621ae6 bf96feda"
+		       "50933da8 047bc306 fabaf0c3 d9fa8471"
+		       "c70a7def 39a2f91d 68a2021c 99ac7e2a"
+		       "24535a13 4ba23ec1 5787cebe 5c53cc"));
+
+  /* The following tests were checked for interoperability against miscreant.js */
+
+  /*
+   * Example from miscreant.js with no AD
+   * https://github.com/miscreant/miscreant.js/blob/master/vectors/aes_siv_aead.tjson
 +   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+		       "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"),
+		  SHEX("10111213 1415161718191a1b1 c1d1e1f2"
+		       "02122232 4252627"),
+		  SHEX(""),
+		  SHEX("11223344 55667788 99aabbcc ddee"),
+		  SHEX("4b3d0f15 ae9ffa9e 65b94942 1582ef70"
+		       "e410910d 6446c775 9ebff9b5 385a"));
+
+  /*
+   * Example from miscreant.js with AD
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+		  &amp;nettle_aes128,
+		  SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+		       "40414243 44454647 48494a4b 4c4d4e4f"),
+		  SHEX("09f91102 9d74e35b d84156c5 635688c0"),
+		  SHEX("00112233 44556677 8899aabb ccddeeff"
+		       "deaddada deaddada ffeeddcc bbaa9988"
+		       "77665544 33221100"),
+		  SHEX("74686973 20697320 736f6d65 20706c61"
+		       "696e7465 78742074 6f20656e 63727970"
+		       "74207573 696e6720 5349562d 414553"),
+		  SHEX("85825e22 e90cf2dd da2c548d c7c1b631"
+		       "0dcdaca0 cebf9dc6 cb90583f 5bf1506e"
+		       "02cd4883 2b00e4e5 98b2b22a 53e6199d"
+		       "4df0c166 6a35a043 3b250dc1 34d776"));
+}
diff --git a/testsuite/testutils.h b/testsuite/testutils.h
index ded57db6..3a1872f1 100644
--- a/testsuite/testutils.h
+++ b/testsuite/testutils.h
@@ -176,6 +176,19 @@ test_armor(const struct nettle_armor *armor,
            const uint8_t *data,
            const char *ascii);
 
+/* AEAD ciphers */
+typedef void
+nettle_encrypt_message_func(void *ctx,
+			    size_t nlength, const uint8_t *nonce,
+			    size_t alength, const uint8_t *adata,
+			    size_t clength, uint8_t *dst, const uint8_t *src);
+
+typedef int
+nettle_decrypt_message_func(void *ctx,
+			    size_t nlength, const uint8_t *nonce,
+			    size_t alength, const uint8_t *adata,
+			    size_t mlength, uint8_t *dst, const uint8_t *src);
+
 #if WITH_HOGWEED
 
 #if NETTLE_USE_MINI_GMP
-- 
2.20.1


[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190506174516</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-05-06 17:45:16-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; https://gitlab.com/nmav/nettle/merge_requests/4/

I've integrated this onto a branch siv-mode, with some changes (renamed
functions to all have the siv_cmac prefix, document that empty nonce may
have interop issues and should be considered experimental (but still
allow it), and dropped some macros and unrelated changes (which would
belong on a different branch). Please have a look, and say if I've
messed up something.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190508120607</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2019-05-08 12:06:07-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

Thanks. If you added the zero-nonce method, maybe it would be better
to add test vectors for it as well. I'm copying from my last patch
with it:

+  /*
+   * Example with no nonce, no AD and no plaintext; taken from
+   * https://github.com/miscreant/miscreant/blob/master/vectors/aes_siv.tjson
+   * however we don't interoperate.
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+          &amp;nettle_aes128,
+          SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+               "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"),
+          SHEX(""),
+          SHEX(""),
+          SHEX(""),
+          SHEX("949f99cb cc3eb5da6 d3c45d0 f59aa9c7"));
+
+  /*
+   * Example with no nonce, no AD and plaintext; taken from
+   * https://github.com/miscreant/miscreant/blob/master/vectors/aes_siv.tjson
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+          &amp;nettle_aes128,
+          SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+               "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"),
+          SHEX(""),
+          SHEX(""),
+          SHEX("00112233 44556677 8899aabb ccddeeff"),
+          SHEX("f304f912 863e303d 5b540e50 57c7010c"
+               "942ffaf4 5b0e5ca5 fb9a56a5 263bb065"));
+  /*
+   * Example without nonce length &lt; 16 (RFC5297)
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+          &amp;nettle_aes128,
+          SHEX("fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0"
+               "f0f1f2f3 f4f5f6f7 f8f9fafb fcfdfeff"),
+          SHEX(""),
+          SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+               "20212223 24252627"),
+          SHEX("11223344 55667788 99aabbcc ddee"),
+          SHEX("85632d07 c6e8f37f 950acd32 0a2ecc93"
+               "40c02b96 90c4dc04 daef7f6a fe5c"));
+
+  /*
+   * Example without nonce length &gt; 16
+   */
+  test_siv_aes128("AES_SIV_CMAC256", sizeof(struct siv_aes128_cmac_ctx),
+          &amp;nettle_aes128,
+          SHEX("7f7e7d7c 7b7a7978 77767574 73727170"
+               "40414243 44454647 48494a4b 4c4d4e4f"),
+          SHEX(""),
+          SHEX("00112233 44556677 8899aabb ccddeeff"
+               "deaddada deaddada ffeeddcc bbaa9988"
+               "77665544 33221100"),
+          SHEX("74686973 20697320 736f6d65 20706c61"
+               "696e7465 78742074 6f20656e 63727970"
+               "74207573 696e6720 5349562d 414553"),
+          SHEX("c12ccaa7 54e1b3fa 4f416c18 415625ca"
+               "472fbee de5bc03f 34934819 a9abb20b5"
+               "8cd019c 470ac832 f6eb9ddf 0656c5dce"
+               "ffe611a 5a5ca3e1 c3c12da5 6e4bb87"));
+  /* AES-SIV-CMAC-512 (AES-256)
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+          &amp;nettle_aes256,
+          SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+               "2d568e91 a38e5414 8abdc0b6 e86caf87"
+               "695c0a8a df4c5f8e b2c6c8b1 36529864"
+               "f3b84b3a e8e3676c e760c461 f3a13e83"),
+          SHEX(""),
+          SHEX("10111213 14151617 18191a1b 1c1d1e1f"
+               "20212223 24252627"),
+          SHEX("11223344 55667788 99aabbcc ddee"),
+          SHEX("ae2b1bd1 ba7fcd6a 4f9f7eb2 4b40f766"
+               "86053ffd c384cb19 76031f46 3013"));
+
+  /*
+   * Example without nonce length &gt; 16
+   */
+  test_siv_aes256("AES_SIV_CMAC512", sizeof(struct siv_aes256_cmac_ctx),
+          &amp;nettle_aes256,
+          SHEX("c27df2fd aec35d4a 2a412a50 c3e8c47d"
+               "2d568e91 a38e5414 8abdc0b6 e86caf87"
+               "695c0a8a df4c5f8e b2c6c8b1 36529864"
+               "f3b84b3a e8e3676c e760c461 f3a13e83"),
+          SHEX(""),
+          SHEX("00112233 44556677 8899aabb ccddeeff"
+               "deaddada deaddada ffeeddcc bbaa9988"
+               "77665544 33221100"),
+          SHEX("74686973 20697320 736f6d65 20706c61"
+               "696e7465 78742074 6f20656e 63727970"
+               "74207573 696e6720 5349562d 414553"),
+          SHEX("79476aaa 388374fe 97d0db51 596cb5ee"
+               "a933e001 412026c7 956c82dd b753b1af"
+               "3d7d49ac 474a800a c14b4bab a4542067"
+               "83647ef9 51315dab b7a2c05b 288ba8"));

On Mon, May 6, 2019 at 7:45 PM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt;
&gt; &gt; https://gitlab.com/nmav/nettle/merge_requests/4/
&gt;
&gt; I've integrated this onto a branch siv-mode, with some changes (renamed
&gt; functions to all have the siv_cmac prefix, document that empty nonce may
&gt; have interop issues and should be considered experimental (but still
&gt; allow it), and dropped some macros and unrelated changes (which would
&gt; belong on a different branch). Please have a look, and say if I've
&gt; messed up something.
&gt;
&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
&gt; Internet email is subject to wholesale government surveillance.
&gt; _______________________________________________
&gt; nettle-bugs mailing list
&gt; nettle-bugs@lists.lysator.liu.se
&gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190511074931</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-05-11 07:49:31-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Thanks. If you added the zero-nonce method, maybe it would be better
&gt; to add test vectors for it as well. I'm copying from my last patch
&gt; with it:

I was about to add the miscreant.js examples (and with nettle's output,
which is different), to illustrate interop issue. Unfortunately, the RFC
5297 testvectors appear useless if one wants to test the RFC 5116 mode
of operation.

And on second thought, maybe it makes more sense to change nettle to be
interoperable with miscreant here? I think that's how you did it
originally, and I found it confusing. RFC 5297 (SIV mode) says that for
use according to RFC5116 (AEAD interface), N_MIN = 1.

Another option, which you've also tried, is to to require non-empty
nonce, i.e., add back the assert (nlength &gt; 0), and define
SIV_MIN_NONCE_SIZE as one, not zero. That's perhaps the most
conservative approach: support for empty nonce, however that should
behave, can be added later.

Opinions? 

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702142506</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-02 14:25:06-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; I prefer the second option because I think the zero nonce variant
&gt; requires a disproportionate, to its usefullness and use, discussion to
&gt; define the "right" semantics.

Merged siv-mode to the master branch now. Does it look right to you?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190703042607</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2019-07-03 04:26:07-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

Looks good to me, but I'm adding Mirek in CC who is using SIV-AES-CMAC
for NTS/NTP implementation to verify that the final code is sufficient
for this implementation.

regards,
Nikos

On Tue, Jul 2, 2019 at 4:25 PM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt;
&gt; &gt; I prefer the second option because I think the zero nonce variant
&gt; &gt; requires a disproportionate, to its usefullness and use, discussion to
&gt; &gt; define the "right" semantics.
&gt;
&gt; Merged siv-mode to the master branch now. Does it look right to you?
&gt;
&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
&gt; Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190513212741</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-05-13 21:27:41-0400</timestampReceived><subject>Re: Add check for ECC at point 0</subject><body>

On Mon, 2019-05-13 at 08:44 -0400, Simo Sorce wrote:
&gt; On Sat, 2019-05-11 at 10:00 +0200, Niels Möller wrote:
&gt; &gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; &gt; 
&gt; &gt; &gt; While reviewing FIPS requirements for public key checks in Ephemeral
&gt; &gt; &gt; Diffie-Hellman key exchanges it came out that FIPS requires checks that
&gt; &gt; &gt; the public key point is not the (0, 0) coordinate and nettle is not
&gt; &gt; &gt; doing it (only checks that neither point is negative.
&gt; &gt; 
&gt; &gt; ecc_point_set also checks that the point is on the curve, i.e.,
&gt; &gt; satisfies the curve equation. That should rule out (0, 0), except if we
&gt; &gt; have some curve with constant term b == 0, which I don't think makes
&gt; &gt; sense.
&gt; 
&gt; Ah you are right the later check would catch it.
&gt; I was just following the checks FIPS explicitly requires in order and
&gt; didn't think about that ...
&gt; 
&gt; &gt; Not sure how FIPS requirements are formulated, but maybe it would be
&gt; &gt; better to add a test case to check that ecc_point_set rejects (0,0) ?
&gt; 
&gt; Yes, I will drop my patch and add a test case.

Attached find patch that adds points checks to the ECDH test case.
Let me know if that's ok or if you prefer a whole new test.

Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


["0001-Add-tests-that-exercise-public-key-checks-for-ECDH.patch" (0001-Add-tests-that-exercise-public-key-checks-for-ECDH.patch)]

From a720da816f238e2a51747ab3df22715d8f134453 Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Mon, 13 May 2019 15:24:56 -0400
Subject: [PATCH] Add tests that exercise public key checks for ECDH

When performing ECDH the peer provided public key needs to be checked
for validity. FIPS requires basic tests be performed to insure the
provided points are in fact on the selected curve. Those checks already
exists in the ecc_point_set() function.
Add an explicit test that checks the boundaries so that any regression
in checks will be caught.

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 testsuite/ecdh-test.c | 61 ++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 55 insertions(+), 6 deletions(-)

diff --git a/testsuite/ecdh-test.c b/testsuite/ecdh-test.c
index 2bfffd68..9a029c61 100644
--- a/testsuite/ecdh-test.c
+++ b/testsuite/ecdh-test.c
@@ -31,20 +31,30 @@
 
 #include "testutils.h"
 
-static void
-set_point (struct ecc_point *p,
-	   const char *x, const char *y)
+static int
+ret_set_point (struct ecc_point *p,
+               const char *x, const char *y)
 {
   mpz_t X, Y;
+  int ret;
+
   mpz_init_set_str (X, x, 0);
   mpz_init_set_str (Y, y, 0);
-  if (!ecc_point_set (p, X, Y))
-    die ("Test point not on curve!\n");
+  ret = ecc_point_set (p, X, Y);
 
   mpz_clear (X);
   mpz_clear (Y);
+  return ret;
+}
+
+static void
+set_point (struct ecc_point *p,
+	   const char *x, const char *y)
+{
+  if (!ret_set_point (p, x, y))
+    die ("Test point not on curve!\n");
 }
-  
+
 static void
 set_scalar (struct ecc_scalar *s,
 	    const char *x)
@@ -135,9 +145,48 @@ test_dh (const char *name, const struct ecc_curve *ecc,
   ecc_point_clear (&amp;T);  
 }
 
+static void
+test_public_key (const char *label, const struct ecc_curve *ecc,
+                 const char *x, const char *y, int expect_success)
+{
+  struct ecc_point P;
+  int ret;
+
+  ecc_point_init (&amp;P, ecc);
+  ret = ret_set_point (&amp;P, x, y);
+
+  if (!ret &amp;&amp; expect_success)
+    die ("Test point '%s' not on curve!\n", label);
+
+  if (ret &amp;&amp; !expect_success)
+    die ("Expected failure to set point '%s'!", label);
+
+  ecc_point_clear (&amp;P);
+}
+
 void
 test_main(void)
 {
+  test_public_key ("(0,0) with secp-192r1", &amp;_nettle_secp_192r1, "0", "0", 0);
+  test_public_key (
+    "(P,0) with secp-192r1", &amp;_nettle_secp_192r1,
+    "6277101735386680763835789423207666416083908700390324961279",
+    "0", 0);
+  test_public_key (
+    "(0,P) with secp-192r1", &amp;_nettle_secp_192r1, "0",
+    "6277101735386680763835789423207666416083908700390324961279",
+    0);
+  test_public_key (
+    "(P,P) with secp-192r1", &amp;_nettle_secp_192r1,
+    "6277101735386680763835789423207666416083908700390324961279",
+    "6277101735386680763835789423207666416083908700390324961279",
+    0);
+  test_public_key ("(1,2) with secp-192r1", &amp;_nettle_secp_192r1, "1", "2", 0);
+  test_public_key ("(X,Y) with secp-192r1", &amp;_nettle_secp_192r1,
+    "1050363442265225480786760666329560655512990381040021438562",
+    "5298249600854377235107392014200406283816103564916230704184",
+    1);
+
   test_dh ("secp-192r1", &amp;_nettle_secp_192r1,
 	   "3406157206141798348095184987208239421004566462391397236532",
 	   "1050363442265225480786760666329560655512990381040021438562",
-- 
2.21.0


[Attachment #4 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190515094211</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-05-15 09:42:11-0400</timestampReceived><subject>Re: Add check for ECC at point 0</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; Attached find patch that adds points checks to the ECDH test case.
&gt; Let me know if that's ok or if you prefer a whole new test.

I think it's ok to have it in the same file.

&gt; -static void
&gt; -set_point (struct ecc_point *p,
&gt; -	   const char *x, const char *y)
&gt; +static int
&gt; +ret_set_point (struct ecc_point *p,
&gt; +               const char *x, const char *y)
&gt;  {

I think it's nicer to just change set_point to return int, and wrap
all existing calls in ASSERT, e.g,

-  set_point (&amp;A, ax, ay);
+  ASSERT (set_point (&amp;A, ax, ay));

in test_dh. Or name functions as int set_point(...), void
set_point_or_die (...), but I think ASSERT is still clearer, in this
case.

&gt; +  test_public_key ("(0,0) with secp-192r1", &amp;_nettle_secp_192r1, "0", "0", 0);
&gt; +  test_public_key (
&gt; +    "(P,0) with secp-192r1", &amp;_nettle_secp_192r1,
&gt; +    "6277101735386680763835789423207666416083908700390324961279",
&gt; +    "0", 0);

Any particular reason the tests are all for secp_192r1 ?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190515144848</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-05-15 14:48:48-0400</timestampReceived><subject>Re: Add check for ECC at point 0</subject><body>

On Wed, 2019-05-15 at 11:42 +0200, Niels Möller wrote:
&gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; 
&gt; &gt; Attached find patch that adds points checks to the ECDH test case.
&gt; &gt; Let me know if that's ok or if you prefer a whole new test.
&gt; 
&gt; I think it's ok to have it in the same file.
&gt; 
&gt; &gt; -static void
&gt; &gt; -set_point (struct ecc_point *p,
&gt; &gt; -	   const char *x, const char *y)
&gt; &gt; +static int
&gt; &gt; +ret_set_point (struct ecc_point *p,
&gt; &gt; +               const char *x, const char *y)
&gt; &gt;  {
&gt; 
&gt; I think it's nicer to just change set_point to return int, and wrap
&gt; all existing calls in ASSERT, e.g,
&gt; 
&gt; -  set_point (&amp;A, ax, ay);
&gt; +  ASSERT (set_point (&amp;A, ax, ay));
&gt; 
&gt; in test_dh. Or name functions as int set_point(...), void
&gt; set_point_or_die (...), but I think ASSERT is still clearer, in this
&gt; case.

Ok, will change.

&gt; &gt; +  test_public_key ("(0,0) with secp-192r1", &amp;_nettle_secp_192r1, "0", "0", 0);
&gt; &gt; +  test_public_key (
&gt; &gt; +    "(P,0) with secp-192r1", &amp;_nettle_secp_192r1,
&gt; &gt; +    "6277101735386680763835789423207666416083908700390324961279",
&gt; &gt; +    "0", 0);
&gt; 
&gt; Any particular reason the tests are all for secp_192r1 ?

Less copy-pasting as the numbers are smaller, the curve used really
makes no difference.

Nioks,
is the fact we do not enable 192r1 in some distribution a problem?

Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190516122140</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-05-16 12:21:40-0400</timestampReceived><subject>Re: Add check for ECC at point 0</subject><body>

On Wed, 2019-05-15 at 10:48 -0400, Simo Sorce wrote:
&gt; On Wed, 2019-05-15 at 11:42 +0200, Niels Möller wrote:
&gt; &gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; &gt; 
&gt; &gt; &gt; Attached find patch that adds points checks to the ECDH test case.
&gt; &gt; &gt; Let me know if that's ok or if you prefer a whole new test.
&gt; &gt; 
&gt; &gt; I think it's ok to have it in the same file.
&gt; &gt; 
&gt; &gt; &gt; -static void
&gt; &gt; &gt; -set_point (struct ecc_point *p,
&gt; &gt; &gt; -	   const char *x, const char *y)
&gt; &gt; &gt; +static int
&gt; &gt; &gt; +ret_set_point (struct ecc_point *p,
&gt; &gt; &gt; +               const char *x, const char *y)
&gt; &gt; &gt;  {
&gt; &gt; 
&gt; &gt; I think it's nicer to just change set_point to return int, and wrap
&gt; &gt; all existing calls in ASSERT, e.g,
&gt; &gt; 
&gt; &gt; -  set_point (&amp;A, ax, ay);
&gt; &gt; +  ASSERT (set_point (&amp;A, ax, ay));
&gt; &gt; 
&gt; &gt; in test_dh. Or name functions as int set_point(...), void
&gt; &gt; set_point_or_die (...), but I think ASSERT is still clearer, in this
&gt; &gt; case.
&gt; 
&gt; Ok, will change.

Attached patch that does this.
Nothing else was changed.

&gt; &gt; &gt; +  test_public_key ("(0,0) with secp-192r1", &amp;_nettle_secp_192r1, "0", "0", 0);
&gt; &gt; &gt; +  test_public_key (
&gt; &gt; &gt; +    "(P,0) with secp-192r1", &amp;_nettle_secp_192r1,
&gt; &gt; &gt; +    "6277101735386680763835789423207666416083908700390324961279",
&gt; &gt; &gt; +    "0", 0);
&gt; &gt; 
&gt; &gt; Any particular reason the tests are all for secp_192r1 ?
&gt; 
&gt; Less copy-pasting as the numbers are smaller, the curve used really
&gt; makes no difference.
&gt; 
&gt; Nioks,
&gt; is the fact we do not enable 192r1 in some distribution a problem?
&gt; 
&gt; Simo.
&gt; 

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


["0001-Add-tests-that-exercise-public-key-checks-for-ECDH.patch" (0001-Add-tests-that-exercise-public-key-checks-for-ECDH.patch)]

From 458e69336f89e818580d3b1674a560ea39880c14 Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Mon, 13 May 2019 15:24:56 -0400
Subject: [PATCH] Add tests that exercise public key checks for ECDH

When performing ECDH the peer provided public key needs to be checked
for validity. FIPS requires basic tests be performed to insure the
provided points are in fact on the selected curve. Those checks already
exists in the ecc_point_set() function.
Add an explicit test that checks the boundaries so that any regression
in checks will be caught.

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 testsuite/ecdh-test.c | 58 ++++++++++++++++++++++++++++++++++++-------
 1 file changed, 49 insertions(+), 9 deletions(-)

diff --git a/testsuite/ecdh-test.c b/testsuite/ecdh-test.c
index 2bfffd68..0b39319d 100644
--- a/testsuite/ecdh-test.c
+++ b/testsuite/ecdh-test.c
@@ -31,20 +31,21 @@
 
 #include "testutils.h"
 
-static void
-set_point (struct ecc_point *p,
-	   const char *x, const char *y)
+static int
+set_point (struct ecc_point *p, const char *x, const char *y)
 {
   mpz_t X, Y;
+  int ret;
+
   mpz_init_set_str (X, x, 0);
   mpz_init_set_str (Y, y, 0);
-  if (!ecc_point_set (p, X, Y))
-    die ("Test point not on curve!\n");
+  ret = ecc_point_set (p, X, Y);
 
   mpz_clear (X);
   mpz_clear (Y);
+  return ret;
 }
-  
+
 static void
 set_scalar (struct ecc_scalar *s,
 	    const char *x)
@@ -102,15 +103,15 @@ test_dh (const char *name, const struct ecc_curve *ecc,
   ecc_scalar_init (&amp;A_priv, ecc);
   set_scalar (&amp;A_priv, a_priv);
   ecc_point_init (&amp;A, ecc);
-  set_point (&amp;A, ax, ay);
+  ASSERT (set_point (&amp;A, ax, ay));
 
   ecc_scalar_init (&amp;B_priv, ecc);
   set_scalar (&amp;B_priv, b_priv);
   ecc_point_init (&amp;B, ecc);
-  set_point (&amp;B, bx, by);
+  ASSERT (set_point (&amp;B, bx, by));
 
   ecc_point_init (&amp;S, ecc);
-  set_point (&amp;S, sx, sy);
+  ASSERT (set_point (&amp;S, sx, sy));
 
   ecc_point_init (&amp;T, ecc);
 
@@ -135,9 +136,48 @@ test_dh (const char *name, const struct ecc_curve *ecc,
   ecc_point_clear (&amp;T);  
 }
 
+static void
+test_public_key (const char *label, const struct ecc_curve *ecc,
+                 const char *x, const char *y, int expect_success)
+{
+  struct ecc_point P;
+  int ret;
+
+  ecc_point_init (&amp;P, ecc);
+  ret = set_point (&amp;P, x, y);
+
+  if (!ret &amp;&amp; expect_success)
+    die ("Test point '%s' not on curve!\n", label);
+
+  if (ret &amp;&amp; !expect_success)
+    die ("Expected failure to set point '%s'!", label);
+
+  ecc_point_clear (&amp;P);
+}
+
 void
 test_main(void)
 {
+  test_public_key ("(0,0) with secp-192r1", &amp;_nettle_secp_192r1, "0", "0", 0);
+  test_public_key (
+    "(P,0) with secp-192r1", &amp;_nettle_secp_192r1,
+    "6277101735386680763835789423207666416083908700390324961279",
+    "0", 0);
+  test_public_key (
+    "(0,P) with secp-192r1", &amp;_nettle_secp_192r1, "0",
+    "6277101735386680763835789423207666416083908700390324961279",
+    0);
+  test_public_key (
+    "(P,P) with secp-192r1", &amp;_nettle_secp_192r1,
+    "6277101735386680763835789423207666416083908700390324961279",
+    "6277101735386680763835789423207666416083908700390324961279",
+    0);
+  test_public_key ("(1,2) with secp-192r1", &amp;_nettle_secp_192r1, "1", "2", 0);
+  test_public_key ("(X,Y) with secp-192r1", &amp;_nettle_secp_192r1,
+    "1050363442265225480786760666329560655512990381040021438562",
+    "5298249600854377235107392014200406283816103564916230704184",
+    1);
+
   test_dh ("secp-192r1", &amp;_nettle_secp_192r1,
 	   "3406157206141798348095184987208239421004566462391397236532",
 	   "1050363442265225480786760666329560655512990381040021438562",
-- 
2.21.0


[Attachment #4 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190517064712</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2019-05-17 06:47:12-0400</timestampReceived><subject>Re: Add check for ECC at point 0</subject><body>

On Wed, 2019-05-15 at 10:48 -0400, Simo Sorce wrote:
&gt; On Wed, 2019-05-15 at 11:42 +0200, Niels Möller wrote:
&gt; &gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; &gt; 
&gt; &gt; &gt; Attached find patch that adds points checks to the ECDH test
&gt; &gt; &gt; case.
&gt; &gt; &gt; Let me know if that's ok or if you prefer a whole new test.
&gt; &gt; 
&gt; &gt; I think it's ok to have it in the same file.
&gt; &gt; 
&gt; &gt; &gt; -static void
&gt; &gt; &gt; -set_point (struct ecc_point *p,
&gt; &gt; &gt; -	   const char *x, const char *y)
&gt; &gt; &gt; +static int
&gt; &gt; &gt; +ret_set_point (struct ecc_point *p,
&gt; &gt; &gt; +               const char *x, const char *y)
&gt; &gt; &gt;  {
&gt; &gt; 
&gt; &gt; I think it's nicer to just change set_point to return int, and wrap
&gt; &gt; all existing calls in ASSERT, e.g,
&gt; &gt; 
&gt; &gt; -  set_point (&amp;A, ax, ay);
&gt; &gt; +  ASSERT (set_point (&amp;A, ax, ay));
&gt; &gt; 
&gt; &gt; in test_dh. Or name functions as int set_point(...), void
&gt; &gt; set_point_or_die (...), but I think ASSERT is still clearer, in
&gt; &gt; this
&gt; &gt; case.
&gt; 
&gt; Ok, will change.
&gt; 
&gt; &gt; &gt; +  test_public_key ("(0,0) with secp-192r1", &amp;_nettle_secp_192r1,
&gt; &gt; &gt; "0", "0", 0);
&gt; &gt; &gt; +  test_public_key (
&gt; &gt; &gt; +    "(P,0) with secp-192r1", &amp;_nettle_secp_192r1,
&gt; &gt; &gt; +    "6277101735386680763835789423207666416083908700390324961279"
&gt; &gt; &gt; ,
&gt; &gt; &gt; +    "0", 0);
&gt; &gt; 
&gt; &gt; Any particular reason the tests are all for secp_192r1 ?
&gt; 
&gt; Less copy-pasting as the numbers are smaller, the curve used really
&gt; makes no difference.
&gt; 
&gt; Nioks,
&gt; is the fact we do not enable 192r1 in some distribution a problem?

I replied in private previously, making a point that in fedora we
remove the code and disable everything but secp256r1, 384r1 and 521r1.
So any tests that use 192r1 or 224r1 will not be executed at all in
that platform.

regards,
Nikos


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190517122422</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-05-17 12:24:22-0400</timestampReceived><subject>Re: Add check for ECC at point 0</subject><body>

On Fri, 2019-05-17 at 08:47 +0200, Nikos Mavrogiannopoulos wrote:
&gt; On Wed, 2019-05-15 at 10:48 -0400, Simo Sorce wrote:
&gt; &gt; On Wed, 2019-05-15 at 11:42 +0200, Niels Möller wrote:
&gt; &gt; &gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; &gt; &gt; 
&gt; &gt; &gt; &gt; Attached find patch that adds points checks to the ECDH test
&gt; &gt; &gt; &gt; case.
&gt; &gt; &gt; &gt; Let me know if that's ok or if you prefer a whole new test.
&gt; &gt; &gt; 
&gt; &gt; &gt; I think it's ok to have it in the same file.
&gt; &gt; &gt; 
&gt; &gt; &gt; &gt; -static void
&gt; &gt; &gt; &gt; -set_point (struct ecc_point *p,
&gt; &gt; &gt; &gt; -	   const char *x, const char *y)
&gt; &gt; &gt; &gt; +static int
&gt; &gt; &gt; &gt; +ret_set_point (struct ecc_point *p,
&gt; &gt; &gt; &gt; +               const char *x, const char *y)
&gt; &gt; &gt; &gt;  {
&gt; &gt; &gt; 
&gt; &gt; &gt; I think it's nicer to just change set_point to return int, and wrap
&gt; &gt; &gt; all existing calls in ASSERT, e.g,
&gt; &gt; &gt; 
&gt; &gt; &gt; -  set_point (&amp;A, ax, ay);
&gt; &gt; &gt; +  ASSERT (set_point (&amp;A, ax, ay));
&gt; &gt; &gt; 
&gt; &gt; &gt; in test_dh. Or name functions as int set_point(...), void
&gt; &gt; &gt; set_point_or_die (...), but I think ASSERT is still clearer, in
&gt; &gt; &gt; this
&gt; &gt; &gt; case.
&gt; &gt; 
&gt; &gt; Ok, will change.
&gt; &gt; 
&gt; &gt; &gt; &gt; +  test_public_key ("(0,0) with secp-192r1", &amp;_nettle_secp_192r1,
&gt; &gt; &gt; &gt; "0", "0", 0);
&gt; &gt; &gt; &gt; +  test_public_key (
&gt; &gt; &gt; &gt; +    "(P,0) with secp-192r1", &amp;_nettle_secp_192r1,
&gt; &gt; &gt; &gt; +    "6277101735386680763835789423207666416083908700390324961279"
&gt; &gt; &gt; &gt; ,
&gt; &gt; &gt; &gt; +    "0", 0);
&gt; &gt; &gt; 
&gt; &gt; &gt; Any particular reason the tests are all for secp_192r1 ?
&gt; &gt; 
&gt; &gt; Less copy-pasting as the numbers are smaller, the curve used really
&gt; &gt; makes no difference.
&gt; &gt; 
&gt; &gt; Nioks,
&gt; &gt; is the fact we do not enable 192r1 in some distribution a problem?
&gt; 
&gt; I replied in private previously,

sorry, never received that reply.

&gt;  making a point that in fedora we
&gt; remove the code and disable everything but secp256r1, 384r1 and 521r1.
&gt; So any tests that use 192r1 or 224r1 will not be executed at all in
&gt; that platform.

Understood, are you asking to add some tests with other curves ?

Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702201219</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-02 20:12:19-0400</timestampReceived><subject>Re: Add check for ECC at point 0</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; On Wed, 2019-05-15 at 10:48 -0400, Simo Sorce wrote:
&gt;&gt; On Wed, 2019-05-15 at 11:42 +0200, Niels Möller wrote:
&gt;&gt; &gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt;&gt; &gt; 
&gt;&gt; &gt; &gt; Attached find patch that adds points checks to the ECDH test case.
&gt;&gt; &gt; &gt; Let me know if that's ok or if you prefer a whole new test.

Merged now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702132709</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:27:09-0400</timestampReceived><subject>[PATCH 11/14] sha256/sha224: split context into hash state and byte buffer</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 nettle-meta.h |  2 ++
 sha2.h        | 42 ++++++++++++++++++++++++++--
 sha224-meta.c |  3 ++
 sha256-meta.c |  3 ++
 sha256.c      | 76 +++++++++++++++++++++++++++++++++++++++------------
 5 files changed, 106 insertions(+), 20 deletions(-)

diff --git a/nettle-meta.h b/nettle-meta.h
index 95aaaf0fcc8c..a28cecf5fe62 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -184,6 +184,8 @@ extern const struct nettle_hash nettle_sha3_512;
 extern const struct nettle_bctx_hash nettle_bctx_md5;
 extern const struct nettle_bctx_hash nettle_bctx_ripemd160;
 extern const struct nettle_bctx_hash nettle_bctx_sha1;
+extern const struct nettle_bctx_hash nettle_bctx_sha224;
+extern const struct nettle_bctx_hash nettle_bctx_sha256;
 
 struct nettle_aead
 {
diff --git a/sha2.h b/sha2.h
index ca8222a7ece5..95640b5f4b7f 100644
--- a/sha2.h
+++ b/sha2.h
@@ -43,9 +43,14 @@ extern "C" {
 /* Name mangling */
 #define sha224_init nettle_sha224_init
 #define sha224_digest nettle_sha224_digest
+#define sha224_block_init nettle_sha224_block_init
+#define sha224_block_digest nettle_sha224_block_digest
 #define sha256_init nettle_sha256_init
 #define sha256_update nettle_sha256_update
 #define sha256_digest nettle_sha256_digest
+#define sha256_block_init nettle_sha256_block_init
+#define sha256_block_update nettle_sha256_block_update
+#define sha256_block_digest nettle_sha256_block_digest
 #define sha384_init nettle_sha384_init
 #define sha384_digest nettle_sha384_digest
 #define sha512_init nettle_sha512_init
@@ -70,12 +75,16 @@ extern "C" {
 /* Digest is kept internally as 8 32-bit words. */
 #define _SHA256_DIGEST_LENGTH 8
 
-struct sha256_ctx
+struct sha256_state
 {
   uint32_t state[_SHA256_DIGEST_LENGTH];    /* State variables */
   uint64_t count;                           /* 64-bit block count */
-  unsigned int index;                       /* index into buffer */
-  uint8_t block[SHA256_BLOCK_SIZE];          /* SHA256 data buffer */
+};
+
+struct sha256_ctx
+{
+  struct sha256_state state;
+  BLOCK_CTX(SHA256_BLOCK_SIZE);
 };
 
 void
@@ -91,12 +100,28 @@ sha256_digest(struct sha256_ctx *ctx,
 	      size_t length,
 	      uint8_t *digest);
 
+void
+sha256_block_init(struct sha256_state *state,
+		  struct block_ctx *bctx);
+
+void
+sha256_block_update(struct sha256_state *state,
+		    struct block_ctx *bctx,
+		    size_t length,
+		    const uint8_t *data);
+
+void
+sha256_block_digest(struct sha256_state *state,
+		    struct block_ctx *bctx,
+		    size_t length,
+		    uint8_t *digest);
 
 /* SHA224, a truncated SHA256 with different initial state. */
 
 #define SHA224_DIGEST_SIZE 28
 #define SHA224_BLOCK_SIZE SHA256_BLOCK_SIZE
 #define sha224_ctx sha256_ctx
+#define sha224_state sha256_state
 
 void
 sha224_init(struct sha256_ctx *ctx);
@@ -108,6 +133,17 @@ sha224_digest(struct sha256_ctx *ctx,
 	      size_t length,
 	      uint8_t *digest);
 
+void
+sha224_block_init(struct sha256_state *state,
+		  struct block_ctx *bctx);
+
+#define sha224_block_update sha256_block_update
+
+void
+sha224_block_digest(struct sha256_state *state,
+		    struct block_ctx *bctx,
+		    size_t length,
+		    uint8_t *digest);
 
 /* SHA512 */
 
diff --git a/sha224-meta.c b/sha224-meta.c
index 4b3bcef36eba..639a8edd75bc 100644
--- a/sha224-meta.c
+++ b/sha224-meta.c
@@ -39,3 +39,6 @@
 
 const struct nettle_hash nettle_sha224
 = _NETTLE_HASH(sha224, SHA224);
+
+const struct nettle_bctx_hash nettle_bctx_sha224
+= _NETTLE_BLOCK_HASH(sha224, SHA224);
diff --git a/sha256-meta.c b/sha256-meta.c
index fcdf79322600..1f0a4ee338c2 100644
--- a/sha256-meta.c
+++ b/sha256-meta.c
@@ -39,3 +39,6 @@
 
 const struct nettle_hash nettle_sha256
 = _NETTLE_HASH(sha256, SHA256);
+
+const struct nettle_bctx_hash nettle_bctx_sha256
+= _NETTLE_BLOCK_HASH(sha256, SHA256);
diff --git a/sha256.c b/sha256.c
index 253c13191356..e14a1caf59b0 100644
--- a/sha256.c
+++ b/sha256.c
@@ -75,7 +75,7 @@ K[64] =
 /* Initialize the SHA values */
 
 void
-sha256_init(struct sha256_ctx *ctx)
+sha256_block_init(struct sha256_state *state, struct block_ctx *bctx)
 {
   /* Initial values, also generated by the shadata program. */
   static const uint32_t H0[_SHA256_DIGEST_LENGTH] =
@@ -84,24 +84,40 @@ sha256_init(struct sha256_ctx *ctx)
     0x510e527fUL, 0x9b05688cUL, 0x1f83d9abUL, 0x5be0cd19UL, 
   };
 
-  memcpy(ctx-&gt;state, H0, sizeof(H0));
+  memcpy(state-&gt;state, H0, sizeof(H0));
 
   /* Initialize bit count */
-  ctx-&gt;count = 0;
+  state-&gt;count = 0;
   
   /* Initialize buffer */
-  ctx-&gt;index = 0;
+  bctx-&gt;index = 0;
+}
+
+void
+sha256_init(struct sha256_ctx *ctx)
+{
+  return sha256_block_init(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block);
 }
 
 void
 sha256_update(struct sha256_ctx *ctx,
 	      size_t length, const uint8_t *data)
 {
-  MD_UPDATE (ctx, length, data, COMPRESS, ctx-&gt;count++);
+  MD_BLOCK_UPDATE(&amp;ctx-&gt;state, &amp;ctx-&gt;block, SHA256_BLOCK_SIZE, length, data, \
COMPRESS, ctx-&gt;state.count++); +}
+
+void
+sha256_block_update(struct sha256_state *state,
+		    struct block_ctx *bctx,
+		    size_t length,
+		    const uint8_t *data)
+{
+  MD_BLOCK_UPDATE(state, bctx, SHA256_BLOCK_SIZE, length, data, COMPRESS, \
state-&gt;count++);  }
 
 static void
-sha256_write_digest(struct sha256_ctx *ctx,
+sha256_write_digest(struct sha256_state *state,
+		    struct block_ctx *bctx,
 		    size_t length,
 		    uint8_t *digest)
 {
@@ -109,18 +125,18 @@ sha256_write_digest(struct sha256_ctx *ctx,
 
   assert(length &lt;= SHA256_DIGEST_SIZE);
 
-  MD_PAD(ctx, 8, COMPRESS);
+  MD_BLOCK_PAD(state, bctx, SHA256_BLOCK_SIZE, 8, COMPRESS);
 
   /* There are 512 = 2^9 bits in one block */  
-  bit_count = (ctx-&gt;count &lt;&lt; 9) | (ctx-&gt;index &lt;&lt; 3);
+  bit_count = (state-&gt;count &lt;&lt; 9) | (bctx-&gt;index &lt;&lt; 3);
 
   /* This is slightly inefficient, as the numbers are converted to
      big-endian format, and will be converted back by the compression
      function. It's probably not worth the effort to fix this. */
-  WRITE_UINT64(ctx-&gt;block + (SHA256_BLOCK_SIZE - 8), bit_count);
-  COMPRESS(ctx, ctx-&gt;block);
+  WRITE_UINT64(bctx-&gt;buffer + (SHA256_BLOCK_SIZE - 8), bit_count);
+  COMPRESS(state, bctx-&gt;buffer);
 
-  _nettle_write_be32(length, digest, ctx-&gt;state);
+  _nettle_write_be32(length, digest, state-&gt;state);
 }
 
 void
@@ -128,14 +144,24 @@ sha256_digest(struct sha256_ctx *ctx,
 	      size_t length,
 	      uint8_t *digest)
 {
-  sha256_write_digest(ctx, length, digest);
+  sha256_write_digest(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block, length, digest);
   sha256_init(ctx);
 }
 
+void
+sha256_block_digest(struct sha256_state *state,
+		    struct block_ctx *bctx,
+		    size_t length,
+		    uint8_t *digest)
+{
+  sha256_write_digest(state, bctx, length, digest);
+  sha256_block_init(state, bctx);
+}
+
 /* sha224 variant. */
 
 void
-sha224_init(struct sha256_ctx *ctx)
+sha224_block_init(struct sha256_state *state, struct block_ctx *bctx)
 {
   /* Initial values. Low 32 bits of the initial values for sha384. */
   static const uint32_t H0[_SHA256_DIGEST_LENGTH] =
@@ -144,13 +170,19 @@ sha224_init(struct sha256_ctx *ctx)
     0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,
   };
 
-  memcpy(ctx-&gt;state, H0, sizeof(H0));
+  memcpy(state-&gt;state, H0, sizeof(H0));
 
   /* Initialize bit count */
-  ctx-&gt;count = 0;
+  state-&gt;count = 0;
   
   /* Initialize buffer */
-  ctx-&gt;index = 0;
+  bctx-&gt;index = 0;
+}
+
+void
+sha224_init(struct sha256_ctx *ctx)
+{
+  return sha224_block_init(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block);
 }
 
 void
@@ -158,6 +190,16 @@ sha224_digest(struct sha256_ctx *ctx,
 	      size_t length,
 	      uint8_t *digest)
 {
-  sha256_write_digest(ctx, length, digest);
+  sha256_write_digest(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block, length, digest);
   sha224_init(ctx);
 }
+
+void
+sha224_block_digest(struct sha256_state *state,
+		    struct block_ctx *bctx,
+		    size_t length,
+		    uint8_t *digest)
+{
+  sha256_write_digest(state, bctx, length, digest);
+  sha224_block_init(state, bctx);
+}
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190702132710</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:27:10-0400</timestampReceived><subject>[PATCH 12/14] hmac-sha256/hmac-sha224: use new hmac and hash split state/buffer interface</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 hmac-sha224.c | 4 ++--
 hmac-sha256.c | 6 +++---
 hmac.h        | 2 +-
 3 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/hmac-sha224.c b/hmac-sha224.c
index c5bc8750a054..303337fe257f 100644
--- a/hmac-sha224.c
+++ b/hmac-sha224.c
@@ -41,12 +41,12 @@ void
 hmac_sha224_set_key(struct hmac_sha224_ctx *ctx,
 		    size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_sha224, key_length, key);
+  HMAC_BLOCK_SET_KEY(ctx, &amp;nettle_bctx_sha224, key_length, key);
 }
 
 void
 hmac_sha224_digest(struct hmac_sha224_ctx *ctx,
 		   size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_sha224, length, digest);
+  HMAC_BLOCK_DIGEST(ctx, &amp;nettle_bctx_sha224, length, digest);
 }
diff --git a/hmac-sha256.c b/hmac-sha256.c
index af5cc0f1cbef..25263bdcd36b 100644
--- a/hmac-sha256.c
+++ b/hmac-sha256.c
@@ -41,19 +41,19 @@ void
 hmac_sha256_set_key(struct hmac_sha256_ctx *ctx,
 		    size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_sha256, key_length, key);
+  HMAC_BLOCK_SET_KEY(ctx, &amp;nettle_bctx_sha256, key_length, key);
 }
 
 void
 hmac_sha256_update(struct hmac_sha256_ctx *ctx,
 		   size_t length, const uint8_t *data)
 {
-  sha256_update(&amp;ctx-&gt;state, length, data);
+  sha256_block_update(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block, length, data);
 }
 
 void
 hmac_sha256_digest(struct hmac_sha256_ctx *ctx,
 		   size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_sha256, length, digest);
+  HMAC_BLOCK_DIGEST(ctx, &amp;nettle_bctx_sha256, length, digest);
 }
diff --git a/hmac.h b/hmac.h
index 117de3262857..445d7c95e03f 100644
--- a/hmac.h
+++ b/hmac.h
@@ -175,7 +175,7 @@ hmac_sha1_digest(struct hmac_sha1_ctx *ctx,
 		 size_t length, uint8_t *digest);
 
 /* hmac-sha256 */
-struct hmac_sha256_ctx HMAC_CTX(struct sha256_ctx);
+struct hmac_sha256_ctx HMAC_BLOCK_CTX(struct sha256_state, SHA256_BLOCK_SIZE);
 
 void
 hmac_sha256_set_key(struct hmac_sha256_ctx *ctx,
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702132711</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:27:11-0400</timestampReceived><subject>[PATCH 13/14] sha512/sha384: split context into hash state and byte buffer</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 nettle-meta.h |  12 +++++
 sha2.h        |  45 ++++++++++++++++--
 sha384-meta.c |   3 ++
 sha512-meta.c |   3 ++
 sha512.c      | 129 ++++++++++++++++++++++++++++++++++++--------------
 5 files changed, 152 insertions(+), 40 deletions(-)

diff --git a/nettle-meta.h b/nettle-meta.h
index a28cecf5fe62..da9591287e79 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -155,6 +155,16 @@ struct nettle_bctx_hash
  (nettle_hash_block_digest_func *) name##_block_digest	\
 }
 
+#define _NETTLE_BLOCK_HASH_US(name, name_us, NAME) {	\
+ #name,						\
+ sizeof(struct name_us##_state),			\
+ NAME##_DIGEST_SIZE,				\
+ NAME##_BLOCK_SIZE,				\
+ (nettle_hash_block_init_func *) name_us##_block_init,	\
+ (nettle_hash_block_update_func *) name_us##_block_update,	\
+ (nettle_hash_block_digest_func *) name_us##_block_digest	\
+}
+
 /* null-terminated list of digests implemented by this version of nettle */
 const struct nettle_hash * const * _NETTLE_ATTRIBUTE_PURE
 nettle_get_hashes (void);
@@ -186,6 +196,8 @@ extern const struct nettle_bctx_hash nettle_bctx_ripemd160;
 extern const struct nettle_bctx_hash nettle_bctx_sha1;
 extern const struct nettle_bctx_hash nettle_bctx_sha224;
 extern const struct nettle_bctx_hash nettle_bctx_sha256;
+extern const struct nettle_bctx_hash nettle_bctx_sha384;
+extern const struct nettle_bctx_hash nettle_bctx_sha512;
 
 struct nettle_aead
 {
diff --git a/sha2.h b/sha2.h
index 95640b5f4b7f..4f8f5c300822 100644
--- a/sha2.h
+++ b/sha2.h
@@ -53,9 +53,14 @@ extern "C" {
 #define sha256_block_digest nettle_sha256_block_digest
 #define sha384_init nettle_sha384_init
 #define sha384_digest nettle_sha384_digest
+#define sha384_block_init nettle_sha384_block_init
+#define sha384_block_digest nettle_sha384_block_digest
 #define sha512_init nettle_sha512_init
 #define sha512_update nettle_sha512_update
 #define sha512_digest nettle_sha512_digest
+#define sha512_block_init nettle_sha512_block_init
+#define sha512_block_update nettle_sha512_block_update
+#define sha512_block_digest nettle_sha512_block_digest
 #define sha512_224_init   nettle_sha512_224_init
 #define sha512_224_digest nettle_sha512_224_digest
 #define sha512_256_init   nettle_sha512_256_init
@@ -153,12 +158,16 @@ sha224_block_digest(struct sha256_state *state,
 /* Digest is kept internally as 8 64-bit words. */
 #define _SHA512_DIGEST_LENGTH 8
 
-struct sha512_ctx
+struct sha512_state
 {
   uint64_t state[_SHA512_DIGEST_LENGTH];    /* State variables */
   uint64_t count_low, count_high;           /* 128-bit block count */
-  unsigned int index;                       /* index into buffer */
-  uint8_t block[SHA512_BLOCK_SIZE];          /* SHA512 data buffer */
+};
+
+struct sha512_ctx
+{
+  struct sha512_state state;
+  BLOCK_CTX(SHA512_BLOCK_SIZE);
 };
 
 void
@@ -174,12 +183,28 @@ sha512_digest(struct sha512_ctx *ctx,
 	      size_t length,
 	      uint8_t *digest);
 
+void
+sha512_block_init(struct sha512_state *state,
+		  struct block_ctx *bctx);
+
+void
+sha512_block_update(struct sha512_state *state,
+		    struct block_ctx *bctx,
+		    size_t length,
+		    const uint8_t *data);
+
+void
+sha512_block_digest(struct sha512_state *state,
+		    struct block_ctx *bctx,
+		    size_t length,
+		    uint8_t *digest);
 
 /* SHA384, a truncated SHA512 with different initial state. */
 
 #define SHA384_DIGEST_SIZE 48
 #define SHA384_BLOCK_SIZE SHA512_BLOCK_SIZE
 #define sha384_ctx sha512_ctx
+#define sha384_state sha512_state
 
 void
 sha384_init(struct sha512_ctx *ctx);
@@ -191,6 +216,18 @@ sha384_digest(struct sha512_ctx *ctx,
 	      size_t length,
 	      uint8_t *digest);
 
+void
+sha384_block_init(struct sha512_state *state,
+		  struct block_ctx *bctx);
+
+#define sha384_block_update sha512_block_update
+
+void
+sha384_block_digest(struct sha512_state *state,
+		    struct block_ctx *bctx,
+		    size_t length,
+		    uint8_t *digest);
+
 
 /* SHA512_224 and SHA512_256, two truncated versions of SHA512 
    with different initial states. */
@@ -222,7 +259,7 @@ void
 sha512_256_digest(struct sha512_256_ctx *ctx,
                   size_t length,
                   uint8_t *digest);
-  
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/sha384-meta.c b/sha384-meta.c
index 0eb561054a73..7c842f1b1b44 100644
--- a/sha384-meta.c
+++ b/sha384-meta.c
@@ -39,3 +39,6 @@
 
 const struct nettle_hash nettle_sha384
 = _NETTLE_HASH(sha384, SHA384);
+
+const struct nettle_bctx_hash nettle_bctx_sha384
+= _NETTLE_BLOCK_HASH(sha384, SHA384);
diff --git a/sha512-meta.c b/sha512-meta.c
index d592c4bec6c7..c61812d5a8e1 100644
--- a/sha512-meta.c
+++ b/sha512-meta.c
@@ -39,3 +39,6 @@
 
 const struct nettle_hash nettle_sha512
 = _NETTLE_HASH(sha512, SHA512);
+
+const struct nettle_bctx_hash nettle_bctx_sha512
+= _NETTLE_BLOCK_HASH(sha512, SHA512);
diff --git a/sha512.c b/sha512.c
index 6936cb501142..16d79a989955 100644
--- a/sha512.c
+++ b/sha512.c
@@ -116,7 +116,7 @@ K[80] =
 #define COMPRESS(ctx, data) (_nettle_sha512_compress((ctx)-&gt;state, (data), K))
 
 void
-sha512_init(struct sha512_ctx *ctx)
+sha512_block_init(struct sha512_state *state, struct block_ctx *bctx)
 {
   /* Initial values, generated by the gp script
        {
@@ -135,24 +135,40 @@ sha512_init(struct sha512_ctx *ctx)
     0x1F83D9ABFB41BD6BULL,0x5BE0CD19137E2179ULL,
   };
 
-  memcpy(ctx-&gt;state, H0, sizeof(H0));
+  memcpy(state-&gt;state, H0, sizeof(H0));
 
   /* Initialize bit count */
-  ctx-&gt;count_low = ctx-&gt;count_high = 0;
+  state-&gt;count_low = state-&gt;count_high = 0;
   
   /* Initialize buffer */
-  ctx-&gt;index = 0;
+  bctx-&gt;index = 0;
+}
+
+void
+sha512_init(struct sha512_ctx *ctx)
+{
+  return sha512_block_init(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block);
 }
 
 void
 sha512_update(struct sha512_ctx *ctx,
 	      size_t length, const uint8_t *data)
 {
-  MD_UPDATE (ctx, length, data, COMPRESS, MD_INCR(ctx));
+  MD_BLOCK_UPDATE (&amp;ctx-&gt;state, &amp;ctx-&gt;block, SHA512_BLOCK_SIZE, length, data, \
COMPRESS, MD_INCR(&amp;ctx-&gt;state)); +}
+
+void
+sha512_block_update(struct sha512_state *state,
+		    struct block_ctx *bctx,
+		    size_t length,
+		    const uint8_t *data)
+{
+  MD_BLOCK_UPDATE(state, bctx, SHA512_BLOCK_SIZE, length, data, COMPRESS, \
MD_INCR(state));  }
 
 static void
-sha512_write_digest(struct sha512_ctx *ctx,
+sha512_write_digest(struct sha512_state *state,
+		    struct block_ctx *bctx,
 		    size_t length,
 		    uint8_t *digest)
 {
@@ -164,29 +180,29 @@ sha512_write_digest(struct sha512_ctx *ctx,
 
   assert(length &lt;= SHA512_DIGEST_SIZE);
 
-  MD_PAD(ctx, 16, COMPRESS);
+  MD_BLOCK_PAD(state, bctx, SHA512_BLOCK_SIZE, 16, COMPRESS);
 
   /* There are 1024 = 2^10 bits in one block */  
-  high = (ctx-&gt;count_high &lt;&lt; 10) | (ctx-&gt;count_low &gt;&gt; 54);
-  low = (ctx-&gt;count_low &lt;&lt; 10) | (ctx-&gt;index &lt;&lt; 3);
+  high = (state-&gt;count_high &lt;&lt; 10) | (state-&gt;count_low &gt;&gt; 54);
+  low = (state-&gt;count_low &lt;&lt; 10) | (bctx-&gt;index &lt;&lt; 3);
 
   /* This is slightly inefficient, as the numbers are converted to
      big-endian format, and will be converted back by the compression
      function. It's probably not worth the effort to fix this. */
-  WRITE_UINT64(ctx-&gt;block + (SHA512_BLOCK_SIZE - 16), high);
-  WRITE_UINT64(ctx-&gt;block + (SHA512_BLOCK_SIZE - 8), low);
-  COMPRESS(ctx, ctx-&gt;block);
+  WRITE_UINT64(bctx-&gt;buffer + (SHA512_BLOCK_SIZE - 16), high);
+  WRITE_UINT64(bctx-&gt;buffer + (SHA512_BLOCK_SIZE - 8), low);
+  COMPRESS(state, bctx-&gt;buffer);
 
   words = length / 8;
   leftover = length % 8;
 
   for (i = 0; i &lt; words; i++, digest += 8)
-    WRITE_UINT64(digest, ctx-&gt;state[i]);
+    WRITE_UINT64(digest, state-&gt;state[i]);
 
   if (leftover)
     {
       /* Truncate to the right size */
-      uint64_t word = ctx-&gt;state[i] &gt;&gt; (8*(8 - leftover));
+      uint64_t word = state-&gt;state[i] &gt;&gt; (8*(8 - leftover));
 
       do {
 	digest[--leftover] = word &amp; 0xff;
@@ -202,13 +218,23 @@ sha512_digest(struct sha512_ctx *ctx,
 {
   assert(length &lt;= SHA512_DIGEST_SIZE);
 
-  sha512_write_digest(ctx, length, digest);
+  sha512_write_digest(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block, length, digest);
   sha512_init(ctx);
 }
 
+void
+sha512_block_digest(struct sha512_state *state,
+		    struct block_ctx *bctx,
+		    size_t length,
+		    uint8_t *digest)
+{
+  sha512_write_digest(state, bctx, length, digest);
+  sha512_block_init(state, bctx);
+}
+
 /* sha384 variant. */
 void
-sha384_init(struct sha512_ctx *ctx)
+sha384_block_init(struct sha512_state *state, struct block_ctx *bctx)
 {
   /* Initial values, generated by the gp script
        {
@@ -227,13 +253,19 @@ sha384_init(struct sha512_ctx *ctx)
     0xDB0C2E0D64F98FA7ULL, 0x47B5481DBEFA4FA4ULL,
   };
 
-  memcpy(ctx-&gt;state, H0, sizeof(H0));
+  memcpy(state-&gt;state, H0, sizeof(H0));
 
   /* Initialize bit count */
-  ctx-&gt;count_low = ctx-&gt;count_high = 0;
+  state-&gt;count_low = state-&gt;count_high = 0;
   
   /* Initialize buffer */
-  ctx-&gt;index = 0;
+  bctx-&gt;index = 0;
+}
+
+void
+sha384_init(struct sha512_ctx *ctx)
+{
+  return sha384_block_init(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block);
 }
 
 void
@@ -243,14 +275,26 @@ sha384_digest(struct sha512_ctx *ctx,
 {
   assert(length &lt;= SHA384_DIGEST_SIZE);
 
-  sha512_write_digest(ctx, length, digest);
+  sha512_write_digest(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block, length, digest);
   sha384_init(ctx);
 }
 
 
-/* sha-512/224 variant. */
 void
-sha512_224_init(struct sha512_224_ctx *ctx)
+sha384_block_digest(struct sha512_state *state,
+		    struct block_ctx *bctx,
+		    size_t length,
+		    uint8_t *digest)
+{
+  assert(length &lt;= SHA384_DIGEST_SIZE);
+
+  sha512_write_digest(state, bctx, length, digest);
+  sha384_block_init(state, bctx);
+}
+
+/* sha-512/224 variant. */
+static void
+sha512_224_block_init(struct sha512_state *state, struct block_ctx *bctx)
 {
   static const uint64_t H0[_SHA512_DIGEST_LENGTH] =
   {
@@ -260,30 +304,37 @@ sha512_224_init(struct sha512_224_ctx *ctx)
     0x3f9d85a86a1d36c8ULL, 0x1112e6ad91d692a1ULL,
   };
 
-  memcpy(ctx-&gt;state, H0, sizeof(H0));
+  memcpy(state-&gt;state, H0, sizeof(H0));
 
   /* Initialize bit count */
-  ctx-&gt;count_low = ctx-&gt;count_high = 0;
+  state-&gt;count_low = state-&gt;count_high = 0;
   
   /* Initialize buffer */
-  ctx-&gt;index = 0;
+  bctx-&gt;index = 0;
+}
+
+void
+sha512_224_init(struct sha512_ctx *ctx)
+{
+  return sha512_224_block_init(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block);
 }
 
 void
 sha512_224_digest(struct sha512_224_ctx *ctx,
-	      size_t length,
-	      uint8_t *digest)
+		  size_t length,
+		  uint8_t *digest)
 {
   assert(length &lt;= SHA224_DIGEST_SIZE);
 
-  sha512_write_digest(ctx, length, digest);
+  sha512_write_digest(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block, length, digest);
   sha512_224_init(ctx);
 }
 
 
 /* sha-512/256 variant. */
-void
-sha512_256_init(struct sha512_256_ctx *ctx)
+static void
+sha512_256_block_init(struct sha512_state *state,
+		      struct block_ctx *bctx)
 {
   static const uint64_t H0[_SHA512_DIGEST_LENGTH] =
     {
@@ -293,22 +344,28 @@ sha512_256_init(struct sha512_256_ctx *ctx)
       0x2b0199fc2c85b8aaULL, 0x0eb72ddc81c52ca2ULL,
     };
 
-  memcpy(ctx-&gt;state, H0, sizeof(H0));
+  memcpy(state-&gt;state, H0, sizeof(H0));
 
   /* Initialize bit count */
-  ctx-&gt;count_low = ctx-&gt;count_high = 0;
+  state-&gt;count_low = state-&gt;count_high = 0;
   
   /* Initialize buffer */
-  ctx-&gt;index = 0;
+  bctx-&gt;index = 0;
+}
+
+void
+sha512_256_init(struct sha512_256_ctx *ctx)
+{
+  sha512_256_block_init(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block);
 }
 
 void
 sha512_256_digest(struct sha512_256_ctx *ctx,
-	      size_t length,
-	      uint8_t *digest)
+		  size_t length,
+		  uint8_t *digest)
 {
   assert(length &lt;= SHA256_DIGEST_SIZE);
 
-  sha512_write_digest(ctx, length, digest);
+  sha512_write_digest(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block, length, digest);
   sha512_256_init(ctx);
 }
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190702132712</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 13:27:12-0400</timestampReceived><subject>[PATCH 14/14] hmac-sha512/hmac-sha384: use new hmac and hash split state/buffer interface</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 hmac-sha384.c | 4 ++--
 hmac-sha512.c | 6 +++---
 hmac.h        | 2 +-
 3 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/hmac-sha384.c b/hmac-sha384.c
index 30008b5f85c1..d162c4a0fab8 100644
--- a/hmac-sha384.c
+++ b/hmac-sha384.c
@@ -41,12 +41,12 @@ void
 hmac_sha384_set_key(struct hmac_sha512_ctx *ctx,
 		    size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_sha384, key_length, key);
+  HMAC_BLOCK_SET_KEY(ctx, &amp;nettle_bctx_sha384, key_length, key);
 }
 
 void
 hmac_sha384_digest(struct hmac_sha512_ctx *ctx,
 		   size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_sha384, length, digest);
+  HMAC_BLOCK_DIGEST(ctx, &amp;nettle_bctx_sha384, length, digest);
 }
diff --git a/hmac-sha512.c b/hmac-sha512.c
index de64637a8216..8028fb3f5518 100644
--- a/hmac-sha512.c
+++ b/hmac-sha512.c
@@ -41,19 +41,19 @@ void
 hmac_sha512_set_key(struct hmac_sha512_ctx *ctx,
 		    size_t key_length, const uint8_t *key)
 {
-  HMAC_SET_KEY(ctx, &amp;nettle_sha512, key_length, key);
+  HMAC_BLOCK_SET_KEY(ctx, &amp;nettle_bctx_sha512, key_length, key);
 }
 
 void
 hmac_sha512_update(struct hmac_sha512_ctx *ctx,
 		   size_t length, const uint8_t *data)
 {
-  sha512_update(&amp;ctx-&gt;state, length, data);
+  sha512_block_update(&amp;ctx-&gt;state, (struct block_ctx *)&amp;ctx-&gt;block, length, data);
 }
 
 void
 hmac_sha512_digest(struct hmac_sha512_ctx *ctx,
 		   size_t length, uint8_t *digest)
 {
-  HMAC_DIGEST(ctx, &amp;nettle_sha512, length, digest);
+  HMAC_BLOCK_DIGEST(ctx, &amp;nettle_bctx_sha512, length, digest);
 }
diff --git a/hmac.h b/hmac.h
index 445d7c95e03f..ed0210857ade 100644
--- a/hmac.h
+++ b/hmac.h
@@ -203,7 +203,7 @@ hmac_sha224_digest(struct hmac_sha224_ctx *ctx,
 		   size_t length, uint8_t *digest);
 
 /* hmac-sha512 */
-struct hmac_sha512_ctx HMAC_CTX(struct sha512_ctx);
+struct hmac_sha512_ctx HMAC_BLOCK_CTX(struct sha512_state, SHA512_BLOCK_SIZE);
 
 void
 hmac_sha512_set_key(struct hmac_sha512_ctx *ctx,
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702143026</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2019-07-02 14:30:26-0400</timestampReceived><subject>Re: siv and cmac</subject><body>

On Thu, Jun 6, 2019 at 9:44 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt; &gt; I think the siv code could benefit from a funtion to create a cmac
&gt; &gt; digest in one step, without the update/digest split and the intermediate
&gt; &gt; buffer. That would be something like
&gt; &gt;
&gt; &gt; cmac128_message(const struct cmac128_key *key, const void *cipher,
&gt; &gt;                 nettle_crypt_func *encrypt,
&gt; &gt;                 size_t digest_length, uint8_t *digest,
&gt; &gt;                 size_t message_length, const uint8_t *message);
&gt;
&gt; I haven't added a function like this, but I've now done the changes needed
&gt; for const context to the siv_*_message functions.
&gt;
&gt; For CMAC, the lowest-level functions now take cmac128_key and
&gt; cmac128_ctx as separate arguments, the former const where appropriate.
&gt; These changes pushed to master, and it's similar to how gcm is done.
&gt;
&gt; I then merged these changes into the siv-mode branch, and updated it
&gt; accordingly. The _siv_s2v function now takes a const struct cmac128_key
&gt; argument, and uses a local struct cmac128_ctx with _init, _update,
&gt; _digest to process the strings with cmac. This enables use of const
&gt; further up the call chain.

That seems nice. Let me know if you need anything from me regarding that.

regards,
Nikos
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702202052</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-07-02 20:20:52-0400</timestampReceived><subject>Re: Add check for ECC at point 0</subject><body>

On Tue, 2019-07-02 at 22:12 +0200, Niels Möller wrote:
&gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; 
&gt; &gt; On Wed, 2019-05-15 at 10:48 -0400, Simo Sorce wrote:
&gt; &gt; &gt; On Wed, 2019-05-15 at 11:42 +0200, Niels Möller wrote:
&gt; &gt; &gt; &gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; Attached find patch that adds points checks to the ECDH test case.
&gt; &gt; &gt; &gt; &gt; Let me know if that's ok or if you prefer a whole new test.
&gt; 
&gt; Merged now.

Thank you!

-- 
Simo Sorce
RHEL Crypto Team
Red Hat, Inc




_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702210619</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-02 21:06:19-0400</timestampReceived><subject>Re: [PATCH 1/4] Move MAC testing code to generic place from cmac-test</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt; ---
&gt;  testsuite/cmac-test.c | 100 +++++++++++-------------------------------
&gt;  testsuite/testutils.c |  64 +++++++++++++++++++++++++++
&gt;  testsuite/testutils.h |   6 +++
&gt;  3 files changed, 96 insertions(+), 74 deletions(-)
&gt;
&gt; diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
&gt; index 31662d1b6c1b..b1d4aa30dfbe 100644
&gt; --- a/testsuite/cmac-test.c
&gt; +++ b/testsuite/cmac-test.c
&gt; @@ -2,83 +2,35 @@
&gt;  #include "nettle-internal.h"
&gt;  #include "cmac.h"
&gt;  
&gt; +const struct nettle_mac nettle_cmac_aes128 =
&gt; +{
&gt; +  "CMAC-AES128",

Names are usually lowercase, but doesn't really matter for the tests.

I'm merging this patch now, currently on master-updates for testing by
the gitlab ci.

I've had a look at also updating the hmac and umac tests, but that
wasn't as easy as I hoped. For hmac, the variable key size doesn't fit
the struct nettle_mac. For umac, key size is fixed, but one also has a
nonce and nonce auto-increment.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702213953</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 21:39:53-0400</timestampReceived><subject>Re: [PATCH 2/4] cmac: add 64-bit mode CMAC</subject><body>

ср, 3 июл. 2019 г. в 00:15, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; +union nettle_block8
&gt; &gt; +{
&gt; &gt; +  uint8_t b[8];
&gt; &gt; +  unsigned long w[8 / sizeof(unsigned long)];
&gt; &gt; +  uint64_t u64;
&gt; &gt; +};
&gt;
&gt; The "unsigned long w" seems unneeded (in nettle_block16, it could
&gt; also be retired; it's from a time when Nettle didn't use uint64_t).

Ok, I'll drop both usecases.

&gt; Maybe one could do without this union and simply use uint64_t, but then
&gt; one would need some casts to (uint8_t *). So a union may be clearer.

I preferred union because of symmetry with CMAC-128 code.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190703121935</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-03 12:19:35-0400</timestampReceived><subject>[PATCH 1/3] eax: drop w field from nettle_block16</subject><body>

"unsigned long w" comes from the time when Nettle didn't use uint64_t.
It is unused now and thus can be dropped.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 eax.c | 8 ++------
 1 file changed, 2 insertions(+), 6 deletions(-)

diff --git a/eax.c b/eax.c
index 621020def5ce..4b8b5117746e 100644
--- a/eax.c
+++ b/eax.c
@@ -54,12 +54,8 @@ omac_init (union nettle_block16 *state, unsigned t)
 static void
 block16_xor (union nettle_block16 *dst, const union nettle_block16 *src)
 {
-  dst-&gt;w[0] ^= src-&gt;w[0];
-  dst-&gt;w[1] ^= src-&gt;w[1];
-#if SIZEOF_LONG == 4
-  dst-&gt;w[2] ^= src-&gt;w[2];
-  dst-&gt;w[3] ^= src-&gt;w[3];
-#endif
+  dst-&gt;u64[0] ^= src-&gt;u64[0];
+  dst-&gt;u64[1] ^= src-&gt;u64[1];
 }
 
 static void
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190703121937</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-03 12:19:37-0400</timestampReceived><subject>[PATCH 3/3] nettle-types: drop w field from nettle_block16</subject><body>

"unsigned long w" comes from the time when Nettle didn't use uint64_t.
It is unused now and thus can be dropped.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 nettle-types.h | 1 -
 1 file changed, 1 deletion(-)

diff --git a/nettle-types.h b/nettle-types.h
index 5addf3600d69..93a68f3b305c 100644
--- a/nettle-types.h
+++ b/nettle-types.h
@@ -61,7 +61,6 @@ extern "C" {
 union nettle_block16
 {
   uint8_t b[16];
-  unsigned long w[16 / sizeof(unsigned long)];
   uint64_t u64[2];
 };
 
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190703202453</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-03 20:24:53-0400</timestampReceived><subject>[PATCH v2 0/3] drop w field from nettle_block16</subject><body>

I'm sorry for the noise. This iteration fixes an issue with cross-mips
build, noticed with the help of GitLab CI.

-- 
With best wishes
Dmitry


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190703202454</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-03 20:24:54-0400</timestampReceived><subject>[PATCH v2 1/3] eax: drop w field from nettle_block16</subject><body>

"unsigned long w" comes from the time when Nettle didn't use uint64_t.
It is unused now and thus can be dropped.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 eax.c | 8 ++------
 1 file changed, 2 insertions(+), 6 deletions(-)

diff --git a/eax.c b/eax.c
index 621020def5ce..4b8b5117746e 100644
--- a/eax.c
+++ b/eax.c
@@ -54,12 +54,8 @@ omac_init (union nettle_block16 *state, unsigned t)
 static void
 block16_xor (union nettle_block16 *dst, const union nettle_block16 *src)
 {
-  dst-&gt;w[0] ^= src-&gt;w[0];
-  dst-&gt;w[1] ^= src-&gt;w[1];
-#if SIZEOF_LONG == 4
-  dst-&gt;w[2] ^= src-&gt;w[2];
-  dst-&gt;w[3] ^= src-&gt;w[3];
-#endif
+  dst-&gt;u64[0] ^= src-&gt;u64[0];
+  dst-&gt;u64[1] ^= src-&gt;u64[1];
 }
 
 static void
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190703202455</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-03 20:24:55-0400</timestampReceived><subject>[PATCH v2 2/3] gcm: drop w field from nettle_block16</subject><body>

"unsigned long w" comes from the time when Nettle didn't use uint64_t.
It is unused now and thus can be dropped.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 gcm.c | 128 +++++++++++++---------------------------------------------
 1 file changed, 29 insertions(+), 99 deletions(-)

diff --git a/gcm.c b/gcm.c
index 14a6181b032f..18398ca3f4e3 100644
--- a/gcm.c
+++ b/gcm.c
@@ -54,18 +54,14 @@
 #include "macros.h"
 #include "ctr-internal.h"
 
-#define GHASH_POLYNOMIAL 0xE1UL
+#define GHASH_POLYNOMIAL UINT64_C(0xE1)
 
 static void
 gcm_gf_add (union nettle_block16 *r,
 	    const union nettle_block16 *x, const union nettle_block16 *y)
 {
-  r-&gt;w[0] = x-&gt;w[0] ^ y-&gt;w[0];
-  r-&gt;w[1] = x-&gt;w[1] ^ y-&gt;w[1];
-#if SIZEOF_LONG == 4
-  r-&gt;w[2] = x-&gt;w[2] ^ y-&gt;w[2];
-  r-&gt;w[3] = x-&gt;w[3] ^ y-&gt;w[3];
-#endif      
+  r-&gt;u64[0] = x-&gt;u64[0] ^ y-&gt;u64[0];
+  r-&gt;u64[1] = x-&gt;u64[1] ^ y-&gt;u64[1];
 }
 /* Multiplication by 010...0; a big-endian shift right. If the bit
    shifted out is one, the defining polynomial is added to cancel it
@@ -77,39 +73,16 @@ gcm_gf_shift (union nettle_block16 *r, const union nettle_block16 *x)
 
   /* Shift uses big-endian representation. */
 #if WORDS_BIGENDIAN
-# if SIZEOF_LONG == 4
-  mask = - (x-&gt;w[3] &amp; 1);
-  r-&gt;w[3] = (x-&gt;w[3] &gt;&gt; 1) | ((x-&gt;w[2] &amp; 1) &lt;&lt; 31);
-  r-&gt;w[2] = (x-&gt;w[2] &gt;&gt; 1) | ((x-&gt;w[1] &amp; 1) &lt;&lt; 31);
-  r-&gt;w[1] = (x-&gt;w[1] &gt;&gt; 1) | ((x-&gt;w[0] &amp; 1) &lt;&lt; 31);
-  r-&gt;w[0] = (x-&gt;w[0] &gt;&gt; 1) ^ (mask &amp; (GHASH_POLYNOMIAL &lt;&lt; 24)); 
-# elif SIZEOF_LONG == 8
-  mask = - (x-&gt;w[1] &amp; 1);
-  r-&gt;w[1] = (x-&gt;w[1] &gt;&gt; 1) | ((x-&gt;w[0] &amp; 1) &lt;&lt; 63);
-  r-&gt;w[0] = (x-&gt;w[0] &gt;&gt; 1) ^ (mask &amp; (GHASH_POLYNOMIAL &lt;&lt; 56));
-# else
-#  error Unsupported word size. */
-#endif
+  mask = - (x-&gt;u64[1] &amp; 1);
+  r-&gt;u64[1] = (x-&gt;u64[1] &gt;&gt; 1) | ((x-&gt;u64[0] &amp; 1) &lt;&lt; 63);
+  r-&gt;u64[0] = (x-&gt;u64[0] &gt;&gt; 1) ^ (mask &amp; (GHASH_POLYNOMIAL &lt;&lt; 56));
 #else /* ! WORDS_BIGENDIAN */
-# if SIZEOF_LONG == 4
 #define RSHIFT_WORD(x) \
-  ((((x) &amp; 0xfefefefeUL) &gt;&gt; 1) \
-   | (((x) &amp; 0x00010101) &lt;&lt; 15))
-  mask = - ((x-&gt;w[3] &gt;&gt; 24) &amp; 1);
-  r-&gt;w[3] = RSHIFT_WORD(x-&gt;w[3]) | ((x-&gt;w[2] &gt;&gt; 17) &amp; 0x80);
-  r-&gt;w[2] = RSHIFT_WORD(x-&gt;w[2]) | ((x-&gt;w[1] &gt;&gt; 17) &amp; 0x80);
-  r-&gt;w[1] = RSHIFT_WORD(x-&gt;w[1]) | ((x-&gt;w[0] &gt;&gt; 17) &amp; 0x80);
-  r-&gt;w[0] = RSHIFT_WORD(x-&gt;w[0]) ^ (mask &amp; GHASH_POLYNOMIAL);
-# elif SIZEOF_LONG == 8
-#define RSHIFT_WORD(x) \
-  ((((x) &amp; 0xfefefefefefefefeUL) &gt;&gt; 1) \
-   | (((x) &amp; 0x0001010101010101UL) &lt;&lt; 15))
-  mask = - ((x-&gt;w[1] &gt;&gt; 56) &amp; 1);
-  r-&gt;w[1] = RSHIFT_WORD(x-&gt;w[1]) | ((x-&gt;w[0] &gt;&gt; 49) &amp; 0x80);
-  r-&gt;w[0] = RSHIFT_WORD(x-&gt;w[0]) ^ (mask &amp; GHASH_POLYNOMIAL);
-# else
-#  error Unsupported word size. */
-# endif
+  ((((x) &amp; UINT64_C(0xfefefefefefefefe)) &gt;&gt; 1) \
+   | (((x) &amp; UINT64_C(0x0001010101010101)) &lt;&lt; 15))
+  mask = - ((x-&gt;u64[1] &gt;&gt; 56) &amp; 1);
+  r-&gt;u64[1] = RSHIFT_WORD(x-&gt;u64[1]) | ((x-&gt;u64[0] &gt;&gt; 49) &amp; 0x80);
+  r-&gt;u64[0] = RSHIFT_WORD(x-&gt;u64[0]) ^ (mask &amp; GHASH_POLYNOMIAL);
 # undef RSHIFT_WORD
 #endif /* ! WORDS_BIGENDIAN */
 }
@@ -160,44 +133,21 @@ shift_table[0x10] = {
 static void
 gcm_gf_shift_4(union nettle_block16 *x)
 {
-  unsigned long *w = x-&gt;w;
-  unsigned long reduce;
+  uint64_t *u64 = x-&gt;u64;
+  uint64_t reduce;
 
   /* Shift uses big-endian representation. */
 #if WORDS_BIGENDIAN
-# if SIZEOF_LONG == 4
-  reduce = shift_table[w[3] &amp; 0xf];
-  w[3] = (w[3] &gt;&gt; 4) | ((w[2] &amp; 0xf) &lt;&lt; 28);
-  w[2] = (w[2] &gt;&gt; 4) | ((w[1] &amp; 0xf) &lt;&lt; 28);
-  w[1] = (w[1] &gt;&gt; 4) | ((w[0] &amp; 0xf) &lt;&lt; 28);
-  w[0] = (w[0] &gt;&gt; 4) ^ (reduce &lt;&lt; 16);
-# elif SIZEOF_LONG == 8
-  reduce = shift_table[w[1] &amp; 0xf];
-  w[1] = (w[1] &gt;&gt; 4) | ((w[0] &amp; 0xf) &lt;&lt; 60);
-  w[0] = (w[0] &gt;&gt; 4) ^ (reduce &lt;&lt; 48);
-# else
-#  error Unsupported word size. */
-#endif
+  reduce = shift_table[u64[1] &amp; 0xf];
+  u64[1] = (u64[1] &gt;&gt; 4) | ((u64[0] &amp; 0xf) &lt;&lt; 60);
+  u64[0] = (u64[0] &gt;&gt; 4) ^ (reduce &lt;&lt; 48);
 #else /* ! WORDS_BIGENDIAN */
-# if SIZEOF_LONG == 4
 #define RSHIFT_WORD(x) \
-  ((((x) &amp; 0xf0f0f0f0UL) &gt;&gt; 4)			\
-   | (((x) &amp; 0x000f0f0f) &lt;&lt; 12))
-  reduce = shift_table[(w[3] &gt;&gt; 24) &amp; 0xf];
-  w[3] = RSHIFT_WORD(w[3]) | ((w[2] &gt;&gt; 20) &amp; 0xf0);
-  w[2] = RSHIFT_WORD(w[2]) | ((w[1] &gt;&gt; 20) &amp; 0xf0);
-  w[1] = RSHIFT_WORD(w[1]) | ((w[0] &gt;&gt; 20) &amp; 0xf0);
-  w[0] = RSHIFT_WORD(w[0]) ^ reduce;
-# elif SIZEOF_LONG == 8
-#define RSHIFT_WORD(x) \
-  ((((x) &amp; 0xf0f0f0f0f0f0f0f0UL) &gt;&gt; 4) \
-   | (((x) &amp; 0x000f0f0f0f0f0f0fUL) &lt;&lt; 12))
-  reduce = shift_table[(w[1] &gt;&gt; 56) &amp; 0xf];
-  w[1] = RSHIFT_WORD(w[1]) | ((w[0] &gt;&gt; 52) &amp; 0xf0);
-  w[0] = RSHIFT_WORD(w[0]) ^ reduce;
-# else
-#  error Unsupported word size. */
-# endif
+  ((((x) &amp; UINT64_C(0xf0f0f0f0f0f0f0f0)) &gt;&gt; 4) \
+   | (((x) &amp; UINT64_C(0x000f0f0f0f0f0f0f)) &lt;&lt; 12))
+  reduce = shift_table[(u64[1] &gt;&gt; 56) &amp; 0xf];
+  u64[1] = RSHIFT_WORD(u64[1]) | ((u64[0] &gt;&gt; 52) &amp; 0xf0);
+  u64[0] = RSHIFT_WORD(u64[0]) ^ reduce;
 # undef RSHIFT_WORD
 #endif /* ! WORDS_BIGENDIAN */
 }
@@ -268,38 +218,18 @@ shift_table[0x100] = {
 static void
 gcm_gf_shift_8(union nettle_block16 *x)
 {
-  unsigned long *w = x-&gt;w;
-  unsigned long reduce;
+  uint64_t *u64 = x-&gt;u64;
+  uint64_t reduce;
 
   /* Shift uses big-endian representation. */
 #if WORDS_BIGENDIAN
-# if SIZEOF_LONG == 4
-  reduce = shift_table[w[3] &amp; 0xff];
-  w[3] = (w[3] &gt;&gt; 8) | ((w[2] &amp; 0xff) &lt;&lt; 24);
-  w[2] = (w[2] &gt;&gt; 8) | ((w[1] &amp; 0xff) &lt;&lt; 24);
-  w[1] = (w[1] &gt;&gt; 8) | ((w[0] &amp; 0xff) &lt;&lt; 24);
-  w[0] = (w[0] &gt;&gt; 8) ^ (reduce &lt;&lt; 16);
-# elif SIZEOF_LONG == 8
-  reduce = shift_table[w[1] &amp; 0xff];
-  w[1] = (w[1] &gt;&gt; 8) | ((w[0] &amp; 0xff) &lt;&lt; 56);
-  w[0] = (w[0] &gt;&gt; 8) ^ (reduce &lt;&lt; 48);
-# else
-#  error Unsupported word size. */
-#endif
+  reduce = shift_table[u64[1] &amp; 0xff];
+  u64[1] = (u64[1] &gt;&gt; 8) | ((u64[0] &amp; 0xff) &lt;&lt; 56);
+  u64[0] = (u64[0] &gt;&gt; 8) ^ (reduce &lt;&lt; 48);
 #else /* ! WORDS_BIGENDIAN */
-# if SIZEOF_LONG == 4
-  reduce = shift_table[(w[3] &gt;&gt; 24) &amp; 0xff];
-  w[3] = (w[3] &lt;&lt; 8) | (w[2] &gt;&gt; 24);
-  w[2] = (w[2] &lt;&lt; 8) | (w[1] &gt;&gt; 24);
-  w[1] = (w[1] &lt;&lt; 8) | (w[0] &gt;&gt; 24);
-  w[0] = (w[0] &lt;&lt; 8) ^ reduce;
-# elif SIZEOF_LONG == 8
-  reduce = shift_table[(w[1] &gt;&gt; 56) &amp; 0xff];
-  w[1] = (w[1] &lt;&lt; 8) | (w[0] &gt;&gt; 56);
-  w[0] = (w[0] &lt;&lt; 8) ^ reduce;
-# else
-#  error Unsupported word size. */
-# endif
+  reduce = shift_table[(u64[1] &gt;&gt; 56) &amp; 0xff];
+  u64[1] = (u64[1] &lt;&lt; 8) | (u64[0] &gt;&gt; 56);
+  u64[0] = (u64[0] &lt;&lt; 8) ^ reduce;
 #endif /* ! WORDS_BIGENDIAN */
 }
 
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190703202456</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-03 20:24:56-0400</timestampReceived><subject>[PATCH v2 3/3] nettle-types: drop w field from nettle_block16</subject><body>

"unsigned long w" comes from the time when Nettle didn't use uint64_t.
It is unused now and thus can be dropped.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 nettle-types.h | 1 -
 1 file changed, 1 deletion(-)

diff --git a/nettle-types.h b/nettle-types.h
index 5addf3600d69..93a68f3b305c 100644
--- a/nettle-types.h
+++ b/nettle-types.h
@@ -61,7 +61,6 @@ extern "C" {
 union nettle_block16
 {
   uint8_t b[16];
-  unsigned long w[16 / sizeof(unsigned long)];
   uint64_t u64[2];
 };
 
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190704121853</emailId><senderName>Miroslav Lichvar</senderName><senderEmail>mlichvar@redhat.com</senderEmail><timestampReceived>2019-07-04 12:18:53-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

On Wed, Jul 03, 2019 at 06:26:07AM +0200, Nikos Mavrogiannopoulos wrote:
&gt; Looks good to me, but I'm adding Mirek in CC who is using SIV-AES-CMAC
&gt; for NTS/NTP implementation to verify that the final code is sufficient
&gt; for this implementation.

I've updated my code to use the Nettle's SIV-CMAC and it seems to be
working fine. It interoperates with the previous version of itself
(using Nikos' original SIV-CMAC implementation with slightly different
API) and two other NTS implementations (one based on openssl, not sure
about the other).

Thank you both!

-- 
Miroslav Lichvar
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190704133908</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-04 13:39:08-0400</timestampReceived><subject>Re: [PATCH] nettle-types: drop w field from nettle_block16</subject><body>

Hello,

чт, 4 июл. 2019 г. в 10:06, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; Hmm. This patch has to wait a bit, sent it without actual testing.
&gt; &gt; nettle_block16.w is used by eax (easy to copy with) and gcm
&gt; &gt; (might need performance checks on 32-bit architectures).
&gt;
&gt; I would expect that using the uint64_t field is as efficient (or better,
&gt; if compilers do it really well), but I haven't checked the generated
&gt; code on 32-bit archs.
&gt;
&gt; Can we delete the w field from the union without considering it an abi
&gt; break? I'd expect size and alignment of the union to be unchanged on all
&gt; but the most obscure architectures. If not, that part of the change has
&gt; to wait.

I don't know. Size remains the same. And I'd assume that alignment
is controlled by uint64_t in this case (rather than unsigned long). However
these 3 patches (eax, gcm, nettle-types) are completely undependent
from the rest of CMAC-64, so they can be applied at any order.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190709181413</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-09 18:14:13-0400</timestampReceived><subject>Re: [PATCH 2/3] gcm: drop w field from nettle_block16</subject><body>

Hello,

вт, 9 июл. 2019 г. в 00:44, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; "unsigned long w" comes from the time when Nettle didn't use uint64_t.
&gt; &gt; It is unused now and thus can be dropped.
&gt;
&gt; I've done something very similar on the block16-refactor branch.

No problem.

&gt; &gt; +  r-&gt;u64[0] = (x-&gt;u64[0] &gt;&gt; 1) ^ (mask &amp; (GHASH_POLYNOMIAL &lt;&lt; 56));
&gt;
&gt; I've found this needs to be (uint64_t) GHASH_POLYNOMIAL &lt;&lt; 56. Otherwise
&gt; tests fail when I cross compile for (32-bit) mips and run under qemu.

I've just changed GHASH_POLYNOMIAL to `UINT64_C(0xE1)`. Then
all tests succeed.

&gt; I'm also trying to move helper functions (most or all should be inline)
&gt; to block16-internal.h.
&gt;
&gt; Next, I'm looking into unifying the various shift operations. It seems
&gt; we have the following variants:
&gt;
&gt;    Big-endian left shift: cmac, eax, polynomial 0x87
&gt;    Little-endian left shift: xts, polynomial 0x87
&gt;    Big-endian right shift: gcm, polynomial 0xE1 (bit-reverse of 0x87)

I'm going to need big-endian left shift with polynomial 0x87 for
MGM (Multilinear Galois Mode: draft-smyshlyaev-mgm), so unifying
them will be nice.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190709213248</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-09 21:32:48-0400</timestampReceived><subject>Re: [PATCH 1/6] Start separating GOST 28147-89 from GOST R 34.11-94</subject><body>

Hello,

вт, 9 июл. 2019 г. в 01:17, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; Hash function GOST R 34.11-94 (gosthash94) in its compression function
&gt; &gt; uses Russian block cipher (GOST 28147-89, Magma). Start separating block
&gt; &gt; cipher code from hash function code. For now there is no public
&gt; &gt; interface for this cipher, it will be added later.
&gt;
&gt; I'm having an initial look at this, with a few comments.
&gt;
&gt; &gt; --- /dev/null
&gt; &gt; +++ b/gost28147.c
&gt; &gt; +/*
&gt; &gt; + *  A macro that performs a full encryption round of GOST 28147-89.
&gt; &gt; + *  Temporary variables tmp assumed and variables r and l for left and right
&gt; &gt; + *  blocks.
&gt; &gt; + */
&gt; &gt; +#define GOST_ENCRYPT_ROUND(key1, key2, sbox) \
&gt; &gt; +  tmp = (key1) + r; \
&gt; &gt; +  l ^= (sbox)[0*256 + (tmp &amp; 0xff)] ^ (sbox)[1*256 + ((tmp &gt;&gt; 8) &amp; 0xff)] ^ \
&gt; &gt; +    (sbox)[2*256 + ((tmp &gt;&gt; 16) &amp; 0xff)] ^ (sbox)[3*256 + (tmp &gt;&gt; 24)]; \
&gt; &gt; +  tmp = (key2) + l; \
&gt; &gt; +  r ^= (sbox)[0*256 + (tmp &amp; 0xff)] ^ (sbox)[1*256 + ((tmp &gt;&gt; 8) &amp; 0xff)] ^ \
&gt; &gt; +    (sbox)[2*256 + ((tmp &gt;&gt; 16) &amp; 0xff)] ^ (sbox)[3*256 + (tmp &gt;&gt; 24)];
&gt;
&gt; This code is just moved around in this patch, but I'd like to note that
&gt; it's preferable to always wrap function-like macros like this in do { ... }
&gt; while (0), and when used terminate with ;. And avoid using surrounding
&gt; variables; r and l could be macro arguments, and tmp (with some likely
&gt; unique prefix) could be a local in the do { ... } while block.

Fine, I will check if this doesn't lower the performance and redo the code.

&gt; &gt; --- /dev/null
&gt; &gt; +++ b/gost28147.h
&gt; &gt; @@ -0,0 +1,63 @@
&gt;
&gt; &gt; +struct gost28147_param
&gt; &gt; +{
&gt; &gt; +  uint32_t sbox[4*256];
&gt; &gt; +};
&gt;
&gt; Why change to a flat array, and not keep it as
&gt;
&gt;   uint32_t sbox[4][256];
&gt;
&gt; ?

I don't remember. I did this long ago. I'll try changing this back.

&gt;
&gt; &gt; +extern const struct gost28147_param gost28147_param_test_3411;
&gt;
&gt; I find "test" in the name a bit odd. Is there a reason for that? And
&gt; declaration should probably not be in an installed header file, but in
&gt; gost-internal.h or so.

It is called 'test' because it was declared so in the standard itself
(for testing
purposes only). Also see RFC 4357, Section 11.2 (id-GostR3411-94-TestParamSet).

&gt;
&gt; &gt; +/* Internal interface for use by GOST R 34.11-94 */
&gt; &gt; +void gost28147_encrypt_simple (const uint32_t *key, const uint32_t *sbox,
&gt; &gt; +                               const uint32_t *in, uint32_t *out);
&gt;
&gt; Same here: if internal, shouldn't be in an installed header file. And
&gt; "simple" looks a bit odd.

gost-internal.h sounds like a good idea, thank you.

&gt; Should the sbox argument be of type const gost28147_param * ?

No. gost28147_param is a high-level item, comprising of S-BOX,
requirement to use key meshing. They are exported for external
usage (via pointers). gost28147_encrypt_simple is an internal API
which uses S-BOX directly, as it doesn't use any other 'param'
part.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190711184311</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-11 18:43:11-0400</timestampReceived><subject>[PATCH v2 1/6] Start separating GOST 28147-89 from GOST R 34.11-94</subject><body>

Hash function GOST R 34.11-94 (gosthash94) in its compression function
uses Russian block cipher (GOST 28147-89, Magma). Start separating block
cipher code from hash function code. For now there is no public
interface for this cipher, it will be added later.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in          |   7 +-
 gost28147-internal.h |  42 ++++++
 gost28147.c          | 350 +++++++++++++++++++++++++++++++++++++++++++
 gost28147.h          |  56 +++++++
 gosthash94.c         | 246 +-----------------------------
 5 files changed, 458 insertions(+), 243 deletions(-)
 create mode 100644 gost28147-internal.h
 create mode 100644 gost28147.c
 create mode 100644 gost28147.h

diff --git a/Makefile.in b/Makefile.in
index b54e64b053c3..f583981c4367 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -103,7 +103,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
 		 cmac.c cmac-aes128.c cmac-aes256.c \
-		 gosthash94.c gosthash94-meta.c \
+		 gost28147.c gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
 		 knuth-lfib.c hkdf.c \
@@ -196,7 +196,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  cbc.h ccm.h cfb.h chacha.h chacha-poly1305.h ctr.h \
 	  curve25519.h des.h dsa.h dsa-compat.h eax.h \
 	  ecc-curve.h ecc.h ecdsa.h eddsa.h \
-	  gcm.h gosthash94.h hmac.h \
+	  gcm.h gost28147.h gosthash94.h hmac.h \
 	  knuth-lfib.h hkdf.h \
 	  macros.h \
 	  cmac.h siv-cmac.h \
@@ -230,7 +230,8 @@ DISTFILES = $(SOURCES) $(HEADERS) getopt.h getopt_int.h \
 	INSTALL NEWS ChangeLog \
 	nettle.pc.in hogweed.pc.in \
 	$(des_headers) descore.README desdata.stamp \
-	aes-internal.h camellia-internal.h cmac-internal.h serpent-internal.h \
+	aes-internal.h camellia-internal.h cmac-internal.h \
+	gost28147-internal.h serpent-internal.h \
 	cast128_sboxes.h desinfo.h desCode.h \
 	ripemd160-internal.h sha2-internal.h \
 	memxor-internal.h nettle-internal.h nettle-write.h \
diff --git a/gost28147-internal.h b/gost28147-internal.h
new file mode 100644
index 000000000000..7f5c6f8c63c0
--- /dev/null
+++ b/gost28147-internal.h
@@ -0,0 +1,42 @@
+/* gost28147-internal.h
+
+   The GOST 28147-89 cipher function, described in RFC 5831.
+
+   Copyright (C) 2019 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_GOST28147_INTERNAL_H_INCLUDED
+#define NETTLE_GOST28147_INTERNAL_H_INCLUDED
+
+#define _gost28147_encrypt_block _nettle_gost28147_encrypt_block
+
+void _gost28147_encrypt_block (const uint32_t *key, const uint32_t sbox[4][256],
+			       const uint32_t *in, uint32_t *out);
+
+#endif /* NETTLE_GOST28147_INTERNAL_H_INCLUDED */
diff --git a/gost28147.c b/gost28147.c
new file mode 100644
index 000000000000..419cb943084d
--- /dev/null
+++ b/gost28147.c
@@ -0,0 +1,350 @@
+/* gost28147.c - GOST 28147-89 cipher implementation
+ *
+ * based on Russian standard GOST 28147-89
+ * For English description, check RFC 5830.
+ * S-Boxes are expanded from the tables defined in RFC4357:
+ *   https://tools.ietf.org/html/rfc4357
+ *
+ * Copyright: 2019 Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
+ * Copyright: 2009-2012 Aleksey Kravchenko &lt;rhash.admin@gmail.com&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "macros.h"
+#include "gost28147.h"
+#include "gost28147-internal.h"
+
+/* pre-initialized GOST lookup tables based on rotated S-Box */
+const struct gost28147_param gost28147_param_test_3411 =
+{
+  {
+    { /* 0 */
+      0x00072000, 0x00075000, 0x00074800, 0x00071000,
+      0x00076800, 0x00074000, 0x00070000, 0x00077000,
+      0x00073000, 0x00075800, 0x00070800, 0x00076000,
+      0x00073800, 0x00077800, 0x00072800, 0x00071800,
+      0x0005a000, 0x0005d000, 0x0005c800, 0x00059000,
+      0x0005e800, 0x0005c000, 0x00058000, 0x0005f000,
+      0x0005b000, 0x0005d800, 0x00058800, 0x0005e000,
+      0x0005b800, 0x0005f800, 0x0005a800, 0x00059800,
+      0x00022000, 0x00025000, 0x00024800, 0x00021000,
+      0x00026800, 0x00024000, 0x00020000, 0x00027000,
+      0x00023000, 0x00025800, 0x00020800, 0x00026000,
+      0x00023800, 0x00027800, 0x00022800, 0x00021800,
+      0x00062000, 0x00065000, 0x00064800, 0x00061000,
+      0x00066800, 0x00064000, 0x00060000, 0x00067000,
+      0x00063000, 0x00065800, 0x00060800, 0x00066000,
+      0x00063800, 0x00067800, 0x00062800, 0x00061800,
+      0x00032000, 0x00035000, 0x00034800, 0x00031000,
+      0x00036800, 0x00034000, 0x00030000, 0x00037000,
+      0x00033000, 0x00035800, 0x00030800, 0x00036000,
+      0x00033800, 0x00037800, 0x00032800, 0x00031800,
+      0x0006a000, 0x0006d000, 0x0006c800, 0x00069000,
+      0x0006e800, 0x0006c000, 0x00068000, 0x0006f000,
+      0x0006b000, 0x0006d800, 0x00068800, 0x0006e000,
+      0x0006b800, 0x0006f800, 0x0006a800, 0x00069800,
+      0x0007a000, 0x0007d000, 0x0007c800, 0x00079000,
+      0x0007e800, 0x0007c000, 0x00078000, 0x0007f000,
+      0x0007b000, 0x0007d800, 0x00078800, 0x0007e000,
+      0x0007b800, 0x0007f800, 0x0007a800, 0x00079800,
+      0x00052000, 0x00055000, 0x00054800, 0x00051000,
+      0x00056800, 0x00054000, 0x00050000, 0x00057000,
+      0x00053000, 0x00055800, 0x00050800, 0x00056000,
+      0x00053800, 0x00057800, 0x00052800, 0x00051800,
+      0x00012000, 0x00015000, 0x00014800, 0x00011000,
+      0x00016800, 0x00014000, 0x00010000, 0x00017000,
+      0x00013000, 0x00015800, 0x00010800, 0x00016000,
+      0x00013800, 0x00017800, 0x00012800, 0x00011800,
+      0x0001a000, 0x0001d000, 0x0001c800, 0x00019000,
+      0x0001e800, 0x0001c000, 0x00018000, 0x0001f000,
+      0x0001b000, 0x0001d800, 0x00018800, 0x0001e000,
+      0x0001b800, 0x0001f800, 0x0001a800, 0x00019800,
+      0x00042000, 0x00045000, 0x00044800, 0x00041000,
+      0x00046800, 0x00044000, 0x00040000, 0x00047000,
+      0x00043000, 0x00045800, 0x00040800, 0x00046000,
+      0x00043800, 0x00047800, 0x00042800, 0x00041800,
+      0x0000a000, 0x0000d000, 0x0000c800, 0x00009000,
+      0x0000e800, 0x0000c000, 0x00008000, 0x0000f000,
+      0x0000b000, 0x0000d800, 0x00008800, 0x0000e000,
+      0x0000b800, 0x0000f800, 0x0000a800, 0x00009800,
+      0x00002000, 0x00005000, 0x00004800, 0x00001000,
+      0x00006800, 0x00004000, 0x00000000, 0x00007000,
+      0x00003000, 0x00005800, 0x00000800, 0x00006000,
+      0x00003800, 0x00007800, 0x00002800, 0x00001800,
+      0x0003a000, 0x0003d000, 0x0003c800, 0x00039000,
+      0x0003e800, 0x0003c000, 0x00038000, 0x0003f000,
+      0x0003b000, 0x0003d800, 0x00038800, 0x0003e000,
+      0x0003b800, 0x0003f800, 0x0003a800, 0x00039800,
+      0x0002a000, 0x0002d000, 0x0002c800, 0x00029000,
+      0x0002e800, 0x0002c000, 0x00028000, 0x0002f000,
+      0x0002b000, 0x0002d800, 0x00028800, 0x0002e000,
+      0x0002b800, 0x0002f800, 0x0002a800, 0x00029800,
+      0x0004a000, 0x0004d000, 0x0004c800, 0x00049000,
+      0x0004e800, 0x0004c000, 0x00048000, 0x0004f000,
+      0x0004b000, 0x0004d800, 0x00048800, 0x0004e000,
+      0x0004b800, 0x0004f800, 0x0004a800, 0x00049800,
+    }, { /* 1 */
+      0x03a80000, 0x03c00000, 0x03880000, 0x03e80000,
+      0x03d00000, 0x03980000, 0x03a00000, 0x03900000,
+      0x03f00000, 0x03f80000, 0x03e00000, 0x03b80000,
+      0x03b00000, 0x03800000, 0x03c80000, 0x03d80000,
+      0x06a80000, 0x06c00000, 0x06880000, 0x06e80000,
+      0x06d00000, 0x06980000, 0x06a00000, 0x06900000,
+      0x06f00000, 0x06f80000, 0x06e00000, 0x06b80000,
+      0x06b00000, 0x06800000, 0x06c80000, 0x06d80000,
+      0x05280000, 0x05400000, 0x05080000, 0x05680000,
+      0x05500000, 0x05180000, 0x05200000, 0x05100000,
+      0x05700000, 0x05780000, 0x05600000, 0x05380000,
+      0x05300000, 0x05000000, 0x05480000, 0x05580000,
+      0x00a80000, 0x00c00000, 0x00880000, 0x00e80000,
+      0x00d00000, 0x00980000, 0x00a00000, 0x00900000,
+      0x00f00000, 0x00f80000, 0x00e00000, 0x00b80000,
+      0x00b00000, 0x00800000, 0x00c80000, 0x00d80000,
+      0x00280000, 0x00400000, 0x00080000, 0x00680000,
+      0x00500000, 0x00180000, 0x00200000, 0x00100000,
+      0x00700000, 0x00780000, 0x00600000, 0x00380000,
+      0x00300000, 0x00000000, 0x00480000, 0x00580000,
+      0x04280000, 0x04400000, 0x04080000, 0x04680000,
+      0x04500000, 0x04180000, 0x04200000, 0x04100000,
+      0x04700000, 0x04780000, 0x04600000, 0x04380000,
+      0x04300000, 0x04000000, 0x04480000, 0x04580000,
+      0x04a80000, 0x04c00000, 0x04880000, 0x04e80000,
+      0x04d00000, 0x04980000, 0x04a00000, 0x04900000,
+      0x04f00000, 0x04f80000, 0x04e00000, 0x04b80000,
+      0x04b00000, 0x04800000, 0x04c80000, 0x04d80000,
+      0x07a80000, 0x07c00000, 0x07880000, 0x07e80000,
+      0x07d00000, 0x07980000, 0x07a00000, 0x07900000,
+      0x07f00000, 0x07f80000, 0x07e00000, 0x07b80000,
+      0x07b00000, 0x07800000, 0x07c80000, 0x07d80000,
+      0x07280000, 0x07400000, 0x07080000, 0x07680000,
+      0x07500000, 0x07180000, 0x07200000, 0x07100000,
+      0x07700000, 0x07780000, 0x07600000, 0x07380000,
+      0x07300000, 0x07000000, 0x07480000, 0x07580000,
+      0x02280000, 0x02400000, 0x02080000, 0x02680000,
+      0x02500000, 0x02180000, 0x02200000, 0x02100000,
+      0x02700000, 0x02780000, 0x02600000, 0x02380000,
+      0x02300000, 0x02000000, 0x02480000, 0x02580000,
+      0x03280000, 0x03400000, 0x03080000, 0x03680000,
+      0x03500000, 0x03180000, 0x03200000, 0x03100000,
+      0x03700000, 0x03780000, 0x03600000, 0x03380000,
+      0x03300000, 0x03000000, 0x03480000, 0x03580000,
+      0x06280000, 0x06400000, 0x06080000, 0x06680000,
+      0x06500000, 0x06180000, 0x06200000, 0x06100000,
+      0x06700000, 0x06780000, 0x06600000, 0x06380000,
+      0x06300000, 0x06000000, 0x06480000, 0x06580000,
+      0x05a80000, 0x05c00000, 0x05880000, 0x05e80000,
+      0x05d00000, 0x05980000, 0x05a00000, 0x05900000,
+      0x05f00000, 0x05f80000, 0x05e00000, 0x05b80000,
+      0x05b00000, 0x05800000, 0x05c80000, 0x05d80000,
+      0x01280000, 0x01400000, 0x01080000, 0x01680000,
+      0x01500000, 0x01180000, 0x01200000, 0x01100000,
+      0x01700000, 0x01780000, 0x01600000, 0x01380000,
+      0x01300000, 0x01000000, 0x01480000, 0x01580000,
+      0x02a80000, 0x02c00000, 0x02880000, 0x02e80000,
+      0x02d00000, 0x02980000, 0x02a00000, 0x02900000,
+      0x02f00000, 0x02f80000, 0x02e00000, 0x02b80000,
+      0x02b00000, 0x02800000, 0x02c80000, 0x02d80000,
+      0x01a80000, 0x01c00000, 0x01880000, 0x01e80000,
+      0x01d00000, 0x01980000, 0x01a00000, 0x01900000,
+      0x01f00000, 0x01f80000, 0x01e00000, 0x01b80000,
+      0x01b00000, 0x01800000, 0x01c80000, 0x01d80000,
+    }, { /* 2 */
+      0x30000002, 0x60000002, 0x38000002, 0x08000002,
+      0x28000002, 0x78000002, 0x68000002, 0x40000002,
+      0x20000002, 0x50000002, 0x48000002, 0x70000002,
+      0x00000002, 0x18000002, 0x58000002, 0x10000002,
+      0xb0000005, 0xe0000005, 0xb8000005, 0x88000005,
+      0xa8000005, 0xf8000005, 0xe8000005, 0xc0000005,
+      0xa0000005, 0xd0000005, 0xc8000005, 0xf0000005,
+      0x80000005, 0x98000005, 0xd8000005, 0x90000005,
+      0x30000005, 0x60000005, 0x38000005, 0x08000005,
+      0x28000005, 0x78000005, 0x68000005, 0x40000005,
+      0x20000005, 0x50000005, 0x48000005, 0x70000005,
+      0x00000005, 0x18000005, 0x58000005, 0x10000005,
+      0x30000000, 0x60000000, 0x38000000, 0x08000000,
+      0x28000000, 0x78000000, 0x68000000, 0x40000000,
+      0x20000000, 0x50000000, 0x48000000, 0x70000000,
+      0x00000000, 0x18000000, 0x58000000, 0x10000000,
+      0xb0000003, 0xe0000003, 0xb8000003, 0x88000003,
+      0xa8000003, 0xf8000003, 0xe8000003, 0xc0000003,
+      0xa0000003, 0xd0000003, 0xc8000003, 0xf0000003,
+      0x80000003, 0x98000003, 0xd8000003, 0x90000003,
+      0x30000001, 0x60000001, 0x38000001, 0x08000001,
+      0x28000001, 0x78000001, 0x68000001, 0x40000001,
+      0x20000001, 0x50000001, 0x48000001, 0x70000001,
+      0x00000001, 0x18000001, 0x58000001, 0x10000001,
+      0xb0000000, 0xe0000000, 0xb8000000, 0x88000000,
+      0xa8000000, 0xf8000000, 0xe8000000, 0xc0000000,
+      0xa0000000, 0xd0000000, 0xc8000000, 0xf0000000,
+      0x80000000, 0x98000000, 0xd8000000, 0x90000000,
+      0xb0000006, 0xe0000006, 0xb8000006, 0x88000006,
+      0xa8000006, 0xf8000006, 0xe8000006, 0xc0000006,
+      0xa0000006, 0xd0000006, 0xc8000006, 0xf0000006,
+      0x80000006, 0x98000006, 0xd8000006, 0x90000006,
+      0xb0000001, 0xe0000001, 0xb8000001, 0x88000001,
+      0xa8000001, 0xf8000001, 0xe8000001, 0xc0000001,
+      0xa0000001, 0xd0000001, 0xc8000001, 0xf0000001,
+      0x80000001, 0x98000001, 0xd8000001, 0x90000001,
+      0x30000003, 0x60000003, 0x38000003, 0x08000003,
+      0x28000003, 0x78000003, 0x68000003, 0x40000003,
+      0x20000003, 0x50000003, 0x48000003, 0x70000003,
+      0x00000003, 0x18000003, 0x58000003, 0x10000003,
+      0x30000004, 0x60000004, 0x38000004, 0x08000004,
+      0x28000004, 0x78000004, 0x68000004, 0x40000004,
+      0x20000004, 0x50000004, 0x48000004, 0x70000004,
+      0x00000004, 0x18000004, 0x58000004, 0x10000004,
+      0xb0000002, 0xe0000002, 0xb8000002, 0x88000002,
+      0xa8000002, 0xf8000002, 0xe8000002, 0xc0000002,
+      0xa0000002, 0xd0000002, 0xc8000002, 0xf0000002,
+      0x80000002, 0x98000002, 0xd8000002, 0x90000002,
+      0xb0000004, 0xe0000004, 0xb8000004, 0x88000004,
+      0xa8000004, 0xf8000004, 0xe8000004, 0xc0000004,
+      0xa0000004, 0xd0000004, 0xc8000004, 0xf0000004,
+      0x80000004, 0x98000004, 0xd8000004, 0x90000004,
+      0x30000006, 0x60000006, 0x38000006, 0x08000006,
+      0x28000006, 0x78000006, 0x68000006, 0x40000006,
+      0x20000006, 0x50000006, 0x48000006, 0x70000006,
+      0x00000006, 0x18000006, 0x58000006, 0x10000006,
+      0xb0000007, 0xe0000007, 0xb8000007, 0x88000007,
+      0xa8000007, 0xf8000007, 0xe8000007, 0xc0000007,
+      0xa0000007, 0xd0000007, 0xc8000007, 0xf0000007,
+      0x80000007, 0x98000007, 0xd8000007, 0x90000007,
+      0x30000007, 0x60000007, 0x38000007, 0x08000007,
+      0x28000007, 0x78000007, 0x68000007, 0x40000007,
+      0x20000007, 0x50000007, 0x48000007, 0x70000007,
+      0x00000007, 0x18000007, 0x58000007, 0x10000007,
+    }, { /* 3 */
+      0x000000e8, 0x000000d8, 0x000000a0, 0x00000088,
+      0x00000098, 0x000000f8, 0x000000a8, 0x000000c8,
+      0x00000080, 0x000000d0, 0x000000f0, 0x000000b8,
+      0x000000b0, 0x000000c0, 0x00000090, 0x000000e0,
+      0x000007e8, 0x000007d8, 0x000007a0, 0x00000788,
+      0x00000798, 0x000007f8, 0x000007a8, 0x000007c8,
+      0x00000780, 0x000007d0, 0x000007f0, 0x000007b8,
+      0x000007b0, 0x000007c0, 0x00000790, 0x000007e0,
+      0x000006e8, 0x000006d8, 0x000006a0, 0x00000688,
+      0x00000698, 0x000006f8, 0x000006a8, 0x000006c8,
+      0x00000680, 0x000006d0, 0x000006f0, 0x000006b8,
+      0x000006b0, 0x000006c0, 0x00000690, 0x000006e0,
+      0x00000068, 0x00000058, 0x00000020, 0x00000008,
+      0x00000018, 0x00000078, 0x00000028, 0x00000048,
+      0x00000000, 0x00000050, 0x00000070, 0x00000038,
+      0x00000030, 0x00000040, 0x00000010, 0x00000060,
+      0x000002e8, 0x000002d8, 0x000002a0, 0x00000288,
+      0x00000298, 0x000002f8, 0x000002a8, 0x000002c8,
+      0x00000280, 0x000002d0, 0x000002f0, 0x000002b8,
+      0x000002b0, 0x000002c0, 0x00000290, 0x000002e0,
+      0x000003e8, 0x000003d8, 0x000003a0, 0x00000388,
+      0x00000398, 0x000003f8, 0x000003a8, 0x000003c8,
+      0x00000380, 0x000003d0, 0x000003f0, 0x000003b8,
+      0x000003b0, 0x000003c0, 0x00000390, 0x000003e0,
+      0x00000568, 0x00000558, 0x00000520, 0x00000508,
+      0x00000518, 0x00000578, 0x00000528, 0x00000548,
+      0x00000500, 0x00000550, 0x00000570, 0x00000538,
+      0x00000530, 0x00000540, 0x00000510, 0x00000560,
+      0x00000268, 0x00000258, 0x00000220, 0x00000208,
+      0x00000218, 0x00000278, 0x00000228, 0x00000248,
+      0x00000200, 0x00000250, 0x00000270, 0x00000238,
+      0x00000230, 0x00000240, 0x00000210, 0x00000260,
+      0x000004e8, 0x000004d8, 0x000004a0, 0x00000488,
+      0x00000498, 0x000004f8, 0x000004a8, 0x000004c8,
+      0x00000480, 0x000004d0, 0x000004f0, 0x000004b8,
+      0x000004b0, 0x000004c0, 0x00000490, 0x000004e0,
+      0x00000168, 0x00000158, 0x00000120, 0x00000108,
+      0x00000118, 0x00000178, 0x00000128, 0x00000148,
+      0x00000100, 0x00000150, 0x00000170, 0x00000138,
+      0x00000130, 0x00000140, 0x00000110, 0x00000160,
+      0x000001e8, 0x000001d8, 0x000001a0, 0x00000188,
+      0x00000198, 0x000001f8, 0x000001a8, 0x000001c8,
+      0x00000180, 0x000001d0, 0x000001f0, 0x000001b8,
+      0x000001b0, 0x000001c0, 0x00000190, 0x000001e0,
+      0x00000768, 0x00000758, 0x00000720, 0x00000708,
+      0x00000718, 0x00000778, 0x00000728, 0x00000748,
+      0x00000700, 0x00000750, 0x00000770, 0x00000738,
+      0x00000730, 0x00000740, 0x00000710, 0x00000760,
+      0x00000368, 0x00000358, 0x00000320, 0x00000308,
+      0x00000318, 0x00000378, 0x00000328, 0x00000348,
+      0x00000300, 0x00000350, 0x00000370, 0x00000338,
+      0x00000330, 0x00000340, 0x00000310, 0x00000360,
+      0x000005e8, 0x000005d8, 0x000005a0, 0x00000588,
+      0x00000598, 0x000005f8, 0x000005a8, 0x000005c8,
+      0x00000580, 0x000005d0, 0x000005f0, 0x000005b8,
+      0x000005b0, 0x000005c0, 0x00000590, 0x000005e0,
+      0x00000468, 0x00000458, 0x00000420, 0x00000408,
+      0x00000418, 0x00000478, 0x00000428, 0x00000448,
+      0x00000400, 0x00000450, 0x00000470, 0x00000438,
+      0x00000430, 0x00000440, 0x00000410, 0x00000460,
+      0x00000668, 0x00000658, 0x00000620, 0x00000608,
+      0x00000618, 0x00000678, 0x00000628, 0x00000648,
+      0x00000600, 0x00000650, 0x00000670, 0x00000638,
+      0x00000630, 0x00000640, 0x00000610, 0x00000660,
+    }
+  }
+};
+
+/*
+ *  A macro that performs a full encryption round of GOST 28147-89.
+ */
+#define GOST_ENCRYPT_ROUND(l, r, key1, key2, sbox) \
+  do { \
+    uint32_t round_tmp; \
+      \
+    round_tmp = (key1) + r; \
+    l ^= (sbox)[0][(round_tmp &amp; 0xff)] ^ \
+         (sbox)[1][((round_tmp &gt;&gt; 8) &amp; 0xff)] ^ \
+         (sbox)[2][((round_tmp &gt;&gt; 16) &amp; 0xff)] ^ \
+         (sbox)[3][(round_tmp &gt;&gt; 24)]; \
+    round_tmp = (key2) + l; \
+    r ^= (sbox)[0][(round_tmp &amp; 0xff)] ^ \
+         (sbox)[1][((round_tmp &gt;&gt; 8) &amp; 0xff)] ^ \
+         (sbox)[2][((round_tmp &gt;&gt; 16) &amp; 0xff)] ^ \
+         (sbox)[3][(round_tmp &gt;&gt; 24)]; \
+  } while (0)
+
+/* encrypt a block with the given key */
+void _gost28147_encrypt_block (const uint32_t *key, const uint32_t sbox[4][256],
+			       const uint32_t *in, uint32_t *out)
+{
+  uint32_t l, r;
+
+  r = in[0], l = in[1];
+  GOST_ENCRYPT_ROUND(l, r, key[0], key[1], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[2], key[3], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[4], key[5], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[6], key[7], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[0], key[1], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[2], key[3], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[4], key[5], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[6], key[7], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[0], key[1], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[2], key[3], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[4], key[5], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[6], key[7], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[7], key[6], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[5], key[4], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[3], key[2], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[1], key[0], sbox);
+  *out = l, *(out + 1) = r;
+}
diff --git a/gost28147.h b/gost28147.h
new file mode 100644
index 000000000000..d403c4329f13
--- /dev/null
+++ b/gost28147.h
@@ -0,0 +1,56 @@
+/* gost28147.h
+
+   The GOST 28147-89 cipher function, described in RFC 5831.
+
+   Copyright (C) 2019 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_GOST28147_H_INCLUDED
+#define NETTLE_GOST28147_H_INCLUDED
+
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define gost28147_param_test_3411 nettle_gost28147_param_test_3411
+
+struct gost28147_param
+{
+  uint32_t sbox[4][256];
+};
+
+extern const struct gost28147_param gost28147_param_test_3411;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_GOST28147_H_INCLUDED */
diff --git a/gosthash94.c b/gosthash94.c
index e60c9ae5cddf..53716ca744a2 100644
--- a/gosthash94.c
+++ b/gosthash94.c
@@ -1,5 +1,7 @@
-/* gost.c - an implementation of GOST Hash Function
+/* gosthash94.c - an implementation of GOST Hash Function
+ *
  * based on the Russian Standard GOST R 34.11-94.
+ * English description in RFC 5831.
  * See also RFC 4357.
  *
  * Copyright: 2009-2012 Aleksey Kravchenko &lt;rhash.admin@gmail.com&gt;
@@ -38,209 +40,8 @@
 #include "macros.h"
 #include "nettle-write.h"
 #include "gosthash94.h"
-
-/* pre-initialized GOST lookup tables based on rotated S-Box */
-static const uint32_t gosthash94_sbox[4][256] = {
-  {
-    0x72000, 0x75000, 0x74800, 0x71000, 0x76800,
-    0x74000, 0x70000, 0x77000, 0x73000, 0x75800,
-    0x70800, 0x76000, 0x73800, 0x77800, 0x72800,
-    0x71800, 0x5A000, 0x5D000, 0x5C800, 0x59000,
-    0x5E800, 0x5C000, 0x58000, 0x5F000, 0x5B000,
-    0x5D800, 0x58800, 0x5E000, 0x5B800, 0x5F800,
-    0x5A800, 0x59800, 0x22000, 0x25000, 0x24800,
-    0x21000, 0x26800, 0x24000, 0x20000, 0x27000,
-    0x23000, 0x25800, 0x20800, 0x26000, 0x23800,
-    0x27800, 0x22800, 0x21800, 0x62000, 0x65000,
-    0x64800, 0x61000, 0x66800, 0x64000, 0x60000,
-    0x67000, 0x63000, 0x65800, 0x60800, 0x66000,
-    0x63800, 0x67800, 0x62800, 0x61800, 0x32000,
-    0x35000, 0x34800, 0x31000, 0x36800, 0x34000,
-    0x30000, 0x37000, 0x33000, 0x35800, 0x30800,
-    0x36000, 0x33800, 0x37800, 0x32800, 0x31800,
-    0x6A000, 0x6D000, 0x6C800, 0x69000, 0x6E800,
-    0x6C000, 0x68000, 0x6F000, 0x6B000, 0x6D800,
-    0x68800, 0x6E000, 0x6B800, 0x6F800, 0x6A800,
-    0x69800, 0x7A000, 0x7D000, 0x7C800, 0x79000,
-    0x7E800, 0x7C000, 0x78000, 0x7F000, 0x7B000,
-    0x7D800, 0x78800, 0x7E000, 0x7B800, 0x7F800,
-    0x7A800, 0x79800, 0x52000, 0x55000, 0x54800,
-    0x51000, 0x56800, 0x54000, 0x50000, 0x57000,
-    0x53000, 0x55800, 0x50800, 0x56000, 0x53800,
-    0x57800, 0x52800, 0x51800, 0x12000, 0x15000,
-    0x14800, 0x11000, 0x16800, 0x14000, 0x10000,
-    0x17000, 0x13000, 0x15800, 0x10800, 0x16000,
-    0x13800, 0x17800, 0x12800, 0x11800, 0x1A000,
-    0x1D000, 0x1C800, 0x19000, 0x1E800, 0x1C000,
-    0x18000, 0x1F000, 0x1B000, 0x1D800, 0x18800,
-    0x1E000, 0x1B800, 0x1F800, 0x1A800, 0x19800,
-    0x42000, 0x45000, 0x44800, 0x41000, 0x46800,
-    0x44000, 0x40000, 0x47000, 0x43000, 0x45800,
-    0x40800, 0x46000, 0x43800, 0x47800, 0x42800,
-    0x41800, 0xA000,  0xD000,  0xC800,  0x9000,
-    0xE800,  0xC000,  0x8000,  0xF000,  0xB000,
-    0xD800,  0x8800,  0xE000,  0xB800,  0xF800,
-    0xA800,  0x9800,  0x2000,  0x5000,  0x4800,
-    0x1000,  0x6800,  0x4000,  0x0,     0x7000,
-    0x3000,  0x5800,  0x800,   0x6000,  0x3800,
-    0x7800,  0x2800,  0x1800,  0x3A000, 0x3D000,
-    0x3C800, 0x39000, 0x3E800, 0x3C000, 0x38000,
-    0x3F000, 0x3B000, 0x3D800, 0x38800, 0x3E000,
-    0x3B800, 0x3F800, 0x3A800, 0x39800, 0x2A000,
-    0x2D000, 0x2C800, 0x29000, 0x2E800, 0x2C000,
-    0x28000, 0x2F000, 0x2B000, 0x2D800, 0x28800,
-    0x2E000, 0x2B800, 0x2F800, 0x2A800, 0x29800,
-    0x4A000, 0x4D000, 0x4C800, 0x49000, 0x4E800,
-    0x4C000, 0x48000, 0x4F000, 0x4B000, 0x4D800,
-    0x48800, 0x4E000, 0x4B800, 0x4F800, 0x4A800,
-    0x49800
-  }, {
-    0x3A80000, 0x3C00000, 0x3880000, 0x3E80000, 0x3D00000,
-    0x3980000, 0x3A00000, 0x3900000, 0x3F00000, 0x3F80000,
-    0x3E00000, 0x3B80000, 0x3B00000, 0x3800000, 0x3C80000,
-    0x3D80000, 0x6A80000, 0x6C00000, 0x6880000, 0x6E80000,
-    0x6D00000, 0x6980000, 0x6A00000, 0x6900000, 0x6F00000,
-    0x6F80000, 0x6E00000, 0x6B80000, 0x6B00000, 0x6800000,
-    0x6C80000, 0x6D80000, 0x5280000, 0x5400000, 0x5080000,
-    0x5680000, 0x5500000, 0x5180000, 0x5200000, 0x5100000,
-    0x5700000, 0x5780000, 0x5600000, 0x5380000, 0x5300000,
-    0x5000000, 0x5480000, 0x5580000, 0xA80000,  0xC00000,
-    0x880000,  0xE80000,  0xD00000,  0x980000,  0xA00000,
-    0x900000,  0xF00000,  0xF80000,  0xE00000,  0xB80000,
-    0xB00000,  0x800000,  0xC80000,  0xD80000,  0x280000,
-    0x400000,  0x80000,   0x680000,  0x500000,  0x180000,
-    0x200000,  0x100000,  0x700000,  0x780000,  0x600000,
-    0x380000,  0x300000,  0x0,       0x480000,  0x580000,
-    0x4280000, 0x4400000, 0x4080000, 0x4680000, 0x4500000,
-    0x4180000, 0x4200000, 0x4100000, 0x4700000, 0x4780000,
-    0x4600000, 0x4380000, 0x4300000, 0x4000000, 0x4480000,
-    0x4580000, 0x4A80000, 0x4C00000, 0x4880000, 0x4E80000,
-    0x4D00000, 0x4980000, 0x4A00000, 0x4900000, 0x4F00000,
-    0x4F80000, 0x4E00000, 0x4B80000, 0x4B00000, 0x4800000,
-    0x4C80000, 0x4D80000, 0x7A80000, 0x7C00000, 0x7880000,
-    0x7E80000, 0x7D00000, 0x7980000, 0x7A00000, 0x7900000,
-    0x7F00000, 0x7F80000, 0x7E00000, 0x7B80000, 0x7B00000,
-    0x7800000, 0x7C80000, 0x7D80000, 0x7280000, 0x7400000,
-    0x7080000, 0x7680000, 0x7500000, 0x7180000, 0x7200000,
-    0x7100000, 0x7700000, 0x7780000, 0x7600000, 0x7380000,
-    0x7300000, 0x7000000, 0x7480000, 0x7580000, 0x2280000,
-    0x2400000, 0x2080000, 0x2680000, 0x2500000, 0x2180000,
-    0x2200000, 0x2100000, 0x2700000, 0x2780000, 0x2600000,
-    0x2380000, 0x2300000, 0x2000000, 0x2480000, 0x2580000,
-    0x3280000, 0x3400000, 0x3080000, 0x3680000, 0x3500000,
-    0x3180000, 0x3200000, 0x3100000, 0x3700000, 0x3780000,
-    0x3600000, 0x3380000, 0x3300000, 0x3000000, 0x3480000,
-    0x3580000, 0x6280000, 0x6400000, 0x6080000, 0x6680000,
-    0x6500000, 0x6180000, 0x6200000, 0x6100000, 0x6700000,
-    0x6780000, 0x6600000, 0x6380000, 0x6300000, 0x6000000,
-    0x6480000, 0x6580000, 0x5A80000, 0x5C00000, 0x5880000,
-    0x5E80000, 0x5D00000, 0x5980000, 0x5A00000, 0x5900000,
-    0x5F00000, 0x5F80000, 0x5E00000, 0x5B80000, 0x5B00000,
-    0x5800000, 0x5C80000, 0x5D80000, 0x1280000, 0x1400000,
-    0x1080000, 0x1680000, 0x1500000, 0x1180000, 0x1200000,
-    0x1100000, 0x1700000, 0x1780000, 0x1600000, 0x1380000,
-    0x1300000, 0x1000000, 0x1480000, 0x1580000, 0x2A80000,
-    0x2C00000, 0x2880000, 0x2E80000, 0x2D00000, 0x2980000,
-    0x2A00000, 0x2900000, 0x2F00000, 0x2F80000, 0x2E00000,
-    0x2B80000, 0x2B00000, 0x2800000, 0x2C80000, 0x2D80000,
-    0x1A80000, 0x1C00000, 0x1880000, 0x1E80000, 0x1D00000,
-    0x1980000, 0x1A00000, 0x1900000, 0x1F00000, 0x1F80000,
-    0x1E00000, 0x1B80000, 0x1B00000, 0x1800000, 0x1C80000,
-    0x1D80000
-  }, {
-    0x30000002, 0x60000002, 0x38000002, 0x8000002,
-    0x28000002, 0x78000002, 0x68000002, 0x40000002, 
-    0x20000002, 0x50000002, 0x48000002, 0x70000002, 
-    0x2,        0x18000002, 0x58000002, 0x10000002, 
-    0xB0000005, 0xE0000005, 0xB8000005, 0x88000005,
-    0xA8000005, 0xF8000005, 0xE8000005, 0xC0000005,
-    0xA0000005, 0xD0000005, 0xC8000005, 0xF0000005, 
-    0x80000005, 0x98000005, 0xD8000005, 0x90000005, 
-    0x30000005, 0x60000005, 0x38000005, 0x8000005, 
-    0x28000005, 0x78000005, 0x68000005, 0x40000005,
-    0x20000005, 0x50000005, 0x48000005, 0x70000005, 
-    0x5,        0x18000005, 0x58000005, 0x10000005, 
-    0x30000000, 0x60000000, 0x38000000, 0x8000000, 
-    0x28000000, 0x78000000, 0x68000000, 0x40000000, 
-    0x20000000, 0x50000000, 0x48000000, 0x70000000,
-    0x0,        0x18000000, 0x58000000, 0x10000000, 
-    0xB0000003, 0xE0000003, 0xB8000003, 0x88000003, 
-    0xA8000003, 0xF8000003, 0xE8000003, 0xC0000003, 
-    0xA0000003, 0xD0000003, 0xC8000003, 0xF0000003, 
-    0x80000003, 0x98000003, 0xD8000003, 0x90000003,
-    0x30000001, 0x60000001, 0x38000001, 0x8000001,
-    0x28000001, 0x78000001, 0x68000001, 0x40000001, 
-    0x20000001, 0x50000001, 0x48000001, 0x70000001, 
-    0x1,        0x18000001, 0x58000001, 0x10000001, 
-    0xB0000000, 0xE0000000, 0xB8000000, 0x88000000,
-    0xA8000000, 0xF8000000, 0xE8000000, 0xC0000000,
-    0xA0000000, 0xD0000000, 0xC8000000, 0xF0000000, 
-    0x80000000, 0x98000000, 0xD8000000, 0x90000000, 
-    0xB0000006, 0xE0000006, 0xB8000006, 0x88000006, 
-    0xA8000006, 0xF8000006, 0xE8000006, 0xC0000006,
-    0xA0000006, 0xD0000006, 0xC8000006, 0xF0000006,
-    0x80000006, 0x98000006, 0xD8000006, 0x90000006, 
-    0xB0000001, 0xE0000001, 0xB8000001, 0x88000001, 
-    0xA8000001, 0xF8000001, 0xE8000001, 0xC0000001, 
-    0xA0000001, 0xD0000001, 0xC8000001, 0xF0000001,
-    0x80000001, 0x98000001, 0xD8000001, 0x90000001,
-    0x30000003, 0x60000003, 0x38000003, 0x8000003, 
-    0x28000003, 0x78000003, 0x68000003, 0x40000003, 
-    0x20000003, 0x50000003, 0x48000003, 0x70000003, 
-    0x3,        0x18000003, 0x58000003, 0x10000003,
-    0x30000004, 0x60000004, 0x38000004, 0x8000004,
-    0x28000004, 0x78000004, 0x68000004, 0x40000004, 
-    0x20000004, 0x50000004, 0x48000004, 0x70000004, 
-    0x4,        0x18000004, 0x58000004, 0x10000004, 
-    0xB0000002, 0xE0000002, 0xB8000002, 0x88000002,
-    0xA8000002, 0xF8000002, 0xE8000002, 0xC0000002,
-    0xA0000002, 0xD0000002, 0xC8000002, 0xF0000002, 
-    0x80000002, 0x98000002, 0xD8000002, 0x90000002, 
-    0xB0000004, 0xE0000004, 0xB8000004, 0x88000004, 
-    0xA8000004, 0xF8000004, 0xE8000004, 0xC0000004,
-    0xA0000004, 0xD0000004, 0xC8000004, 0xF0000004,
-    0x80000004, 0x98000004, 0xD8000004, 0x90000004, 
-    0x30000006, 0x60000006, 0x38000006, 0x8000006, 
-    0x28000006, 0x78000006, 0x68000006, 0x40000006, 
-    0x20000006, 0x50000006, 0x48000006, 0x70000006,
-    0x6,        0x18000006, 0x58000006, 0x10000006, 
-    0xB0000007, 0xE0000007, 0xB8000007, 0x88000007, 
-    0xA8000007, 0xF8000007, 0xE8000007, 0xC0000007, 
-    0xA0000007, 0xD0000007, 0xC8000007, 0xF0000007, 
-    0x80000007, 0x98000007, 0xD8000007, 0x90000007,
-    0x30000007, 0x60000007, 0x38000007, 0x8000007,
-    0x28000007, 0x78000007, 0x68000007, 0x40000007, 
-    0x20000007, 0x50000007, 0x48000007, 0x70000007, 
-    0x7,        0x18000007, 0x58000007, 0x10000007
-  }, {
-    0xE8,  0xD8,  0xA0,  0x88,  0x98,  0xF8,  0xA8,  0xC8,  0x80,  0xD0,
-    0xF0,  0xB8,  0xB0,  0xC0,  0x90,  0xE0,  0x7E8, 0x7D8, 0x7A0, 0x788,
-    0x798, 0x7F8, 0x7A8, 0x7C8, 0x780, 0x7D0, 0x7F0, 0x7B8, 0x7B0, 0x7C0,
-    0x790, 0x7E0, 0x6E8, 0x6D8, 0x6A0, 0x688, 0x698, 0x6F8, 0x6A8, 0x6C8,
-    0x680, 0x6D0, 0x6F0, 0x6B8, 0x6B0, 0x6C0, 0x690, 0x6E0, 0x68,  0x58,
-    0x20,  0x8,   0x18,  0x78,  0x28,   0x48,  0x0,   0x50,  0x70,  0x38,
-    0x30,  0x40,  0x10,  0x60,  0x2E8, 0x2D8, 0x2A0, 0x288, 0x298, 0x2F8,
-    0x2A8, 0x2C8, 0x280, 0x2D0, 0x2F0, 0x2B8, 0x2B0, 0x2C0, 0x290, 0x2E0,
-    0x3E8, 0x3D8, 0x3A0, 0x388, 0x398, 0x3F8, 0x3A8, 0x3C8, 0x380, 0x3D0,
-    0x3F0, 0x3B8, 0x3B0, 0x3C0, 0x390, 0x3E0, 0x568, 0x558, 0x520, 0x508,
-    0x518, 0x578, 0x528, 0x548, 0x500, 0x550, 0x570, 0x538, 0x530, 0x540,
-    0x510, 0x560, 0x268, 0x258, 0x220, 0x208, 0x218, 0x278, 0x228, 0x248,
-    0x200, 0x250, 0x270, 0x238, 0x230, 0x240, 0x210, 0x260, 0x4E8, 0x4D8,
-    0x4A0, 0x488, 0x498, 0x4F8, 0x4A8, 0x4C8, 0x480, 0x4D0, 0x4F0, 0x4B8,
-    0x4B0, 0x4C0, 0x490, 0x4E0, 0x168, 0x158, 0x120, 0x108, 0x118, 0x178,
-    0x128, 0x148, 0x100, 0x150, 0x170, 0x138, 0x130, 0x140, 0x110, 0x160,
-    0x1E8, 0x1D8, 0x1A0, 0x188, 0x198, 0x1F8, 0x1A8, 0x1C8, 0x180, 0x1D0,
-    0x1F0, 0x1B8, 0x1B0, 0x1C0, 0x190, 0x1E0, 0x768, 0x758, 0x720, 0x708,
-    0x718, 0x778, 0x728, 0x748, 0x700, 0x750, 0x770, 0x738, 0x730, 0x740,
-    0x710, 0x760, 0x368, 0x358, 0x320, 0x308, 0x318, 0x378, 0x328, 0x348,
-    0x300, 0x350, 0x370, 0x338, 0x330, 0x340, 0x310, 0x360, 0x5E8, 0x5D8,
-    0x5A0, 0x588, 0x598, 0x5F8, 0x5A8, 0x5C8, 0x580, 0x5D0, 0x5F0, 0x5B8,
-    0x5B0, 0x5C0, 0x590, 0x5E0, 0x468, 0x458, 0x420, 0x408, 0x418, 0x478,
-    0x428, 0x448, 0x400, 0x450, 0x470, 0x438, 0x430, 0x440, 0x410, 0x460,
-    0x668, 0x658, 0x620, 0x608, 0x618, 0x678, 0x628, 0x648, 0x600, 0x650,
-    0x670, 0x638, 0x630, 0x640, 0x610, 0x660
-  }
-};
+#include "gost28147.h"
+#include "gost28147-internal.h"
 
 /**
  * Initialize algorithm context before calculating hash
@@ -254,40 +55,6 @@ gosthash94_init (struct gosthash94_ctx *ctx)
     memset (ctx, 0, sizeof (struct gosthash94_ctx));
 }
 
-/*
- *  A macro that performs a full encryption round of GOST 28147-89.
- *  Temporary variables tmp assumed and variables r and l for left and right
- *  blocks.
- */
-#define GOST_ENCRYPT_ROUND(key1, key2, sbox) \
-  tmp = (key1) + r; \
-  l ^= (sbox)[0][tmp &amp; 0xff] ^ (sbox)[1][(tmp &gt;&gt; 8) &amp; 0xff] ^ \
-    (sbox)[2][(tmp &gt;&gt; 16) &amp; 0xff] ^ (sbox)[3][tmp &gt;&gt; 24]; \
-  tmp = (key2) + l; \
-  r ^= (sbox)[0][tmp &amp; 0xff] ^ (sbox)[1][(tmp &gt;&gt; 8) &amp; 0xff] ^ \
-    (sbox)[2][(tmp &gt;&gt; 16) &amp; 0xff] ^ (sbox)[3][tmp &gt;&gt; 24];
-
-/* encrypt a block with the given key */
-#define GOST_ENCRYPT(result, i, key, hash, sbox) \
-  r = hash[i], l = hash[i + 1]; \
-  GOST_ENCRYPT_ROUND(key[0], key[1], sbox) \
-  GOST_ENCRYPT_ROUND(key[2], key[3], sbox) \
-  GOST_ENCRYPT_ROUND(key[4], key[5], sbox) \
-  GOST_ENCRYPT_ROUND(key[6], key[7], sbox) \
-  GOST_ENCRYPT_ROUND(key[0], key[1], sbox) \
-  GOST_ENCRYPT_ROUND(key[2], key[3], sbox) \
-  GOST_ENCRYPT_ROUND(key[4], key[5], sbox) \
-  GOST_ENCRYPT_ROUND(key[6], key[7], sbox) \
-  GOST_ENCRYPT_ROUND(key[0], key[1], sbox) \
-  GOST_ENCRYPT_ROUND(key[2], key[3], sbox) \
-  GOST_ENCRYPT_ROUND(key[4], key[5], sbox) \
-  GOST_ENCRYPT_ROUND(key[6], key[7], sbox) \
-  GOST_ENCRYPT_ROUND(key[7], key[6], sbox) \
-  GOST_ENCRYPT_ROUND(key[5], key[4], sbox) \
-  GOST_ENCRYPT_ROUND(key[3], key[2], sbox) \
-  GOST_ENCRYPT_ROUND(key[1], key[0], sbox) \
-  result[i] = l, result[i + 1] = r;
-
 /**
  * The core transformation. Process a 512-bit block.
  *
@@ -299,7 +66,6 @@ gost_block_compress (struct gosthash94_ctx *ctx, const uint32_t *block)
 {
     unsigned i;
     uint32_t key[8], u[8], v[8], w[8], s[8];
-    uint32_t l, r, tmp;
 
     /* u := hash, v := &lt;256-bit message block&gt; */
     memcpy (u, ctx-&gt;hash, sizeof (u));
@@ -341,7 +107,7 @@ gost_block_compress (struct gosthash94_ctx *ctx, const uint32_t *block)
               ((w[5] &amp; 0xff000000) &gt;&gt; 8) | (w[7] &amp; 0xff000000);
 
           /* encryption: s_i := E_{key_i} (h_i) */
-          GOST_ENCRYPT (s, i, key, ctx-&gt;hash, gosthash94_sbox);
+          _gost28147_encrypt_block (key, gost28147_param_test_3411.sbox, &amp;ctx-&gt;hash[i], &amp;s[i]);
 
           if (i == 0)
             {
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190826182022</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-08-26 18:20:22-0400</timestampReceived><subject>[PATCH 2/5] cmac64: fix nettle_block16 usage</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

CMAC64 uses block8, rather than block16.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 cmac64.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/cmac64.c b/cmac64.c
index 2fbffc9b5ea6..636635ba478b 100644
--- a/cmac64.c
+++ b/cmac64.c
@@ -98,7 +98,7 @@ cmac64_update(struct cmac64_ctx *ctx, const void *cipher,
 	      nettle_cipher_func *encrypt,
 	      size_t msg_len, const uint8_t *msg)
 {
-  union nettle_block16 Y;
+  union nettle_block8 Y;
   /*
    * check if we expand the block
    */
-- 
2.23.0.rc1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190826182023</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-08-26 18:20:23-0400</timestampReceived><subject>[PATCH 3/5] block-internal: add block XORing functions</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Add common implementations for functions doing XOR over
nettle_block16/nettle_block8.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in      |  3 +-
 block-internal.h | 93 ++++++++++++++++++++++++++++++++++++++++++++++++
 cmac.c           | 11 +++---
 cmac64.c         | 12 +++----
 eax.c            |  9 +----
 gcm.c            | 20 ++++-------
 siv-cmac.c       |  9 ++---
 7 files changed, 120 insertions(+), 37 deletions(-)
 create mode 100644 block-internal.h

diff --git a/Makefile.in b/Makefile.in
index af4f6e46ee9b..f6658c86341c 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -230,7 +230,8 @@ DISTFILES = $(SOURCES) $(HEADERS) getopt.h getopt_int.h \
 	INSTALL NEWS ChangeLog \
 	nettle.pc.in hogweed.pc.in \
 	$(des_headers) descore.README desdata.stamp \
-	aes-internal.h camellia-internal.h cmac-internal.h serpent-internal.h \
+	aes-internal.h block-internal.h \
+	camellia-internal.h cmac-internal.h serpent-internal.h \
 	cast128_sboxes.h desinfo.h desCode.h \
 	ripemd160-internal.h sha2-internal.h \
 	memxor-internal.h nettle-internal.h nettle-write.h \
diff --git a/block-internal.h b/block-internal.h
new file mode 100644
index 000000000000..84839c872f63
--- /dev/null
+++ b/block-internal.h
@@ -0,0 +1,93 @@
+/* block-internal.h
+
+   Internal implementations of nettle_blockZ-related functions.
+
+   Copyright (C) 2011 Katholieke Universiteit Leuven
+   Copyright (C) 2011, 2013, 2018 Niels Möller
+   Copyright (C) 2018 Red Hat, Inc.
+   Copyright (C) 2019 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_BLOCK_INTERNAL_H_INCLUDED
+#define NETTLE_BLOCK_INTERNAL_H_INCLUDED
+
+#include &lt;assert.h&gt;
+
+#include "nettle-types.h"
+#include "memxor.h"
+
+static inline void
+block16_xor (union nettle_block16 *r,
+	     const union nettle_block16 *x)
+{
+  r-&gt;u64[0] ^= x-&gt;u64[0];
+  r-&gt;u64[1] ^= x-&gt;u64[1];
+}
+
+static inline void
+block16_xor3 (union nettle_block16 *r,
+	      const union nettle_block16 *x,
+	      const union nettle_block16 *y)
+{
+  r-&gt;u64[0] = x-&gt;u64[0] ^ y-&gt;u64[0];
+  r-&gt;u64[1] = x-&gt;u64[1] ^ y-&gt;u64[1];
+}
+
+static inline void
+block16_xor_bytes (union nettle_block16 *r,
+		   const union nettle_block16 *x,
+		   const uint8_t *bytes)
+{
+  memxor3 (r-&gt;b, x-&gt;b, bytes, 16);
+}
+
+static inline void
+block8_xor (union nettle_block8 *r,
+	     const union nettle_block8 *x)
+{
+  r-&gt;u64 ^= x-&gt;u64;
+}
+
+static inline void
+block8_xor3 (union nettle_block8 *r,
+	      const union nettle_block8 *x,
+	      const union nettle_block8 *y)
+{
+  r-&gt;u64 = x-&gt;u64 ^ y-&gt;u64;
+}
+
+static inline void
+block8_xor_bytes (union nettle_block8 *r,
+		   const union nettle_block8 *x,
+		   const uint8_t *bytes)
+{
+  memxor3 (r-&gt;b, x-&gt;b, bytes, 8);
+}
+
+#endif /* NETTLE_BLOCK_INTERNAL_H_INCLUDED */
diff --git a/cmac.c b/cmac.c
index 70ce8132d9d1..194324421c58 100644
--- a/cmac.c
+++ b/cmac.c
@@ -45,6 +45,7 @@
 #include "memxor.h"
 #include "nettle-internal.h"
 #include "cmac-internal.h"
+#include "block-internal.h"
 #include "macros.h"
 
 /* shift one and XOR with 0x87. */
@@ -119,12 +120,12 @@ cmac128_update(struct cmac128_ctx *ctx, const void *cipher,
   /*
    * now checksum everything but the last block
    */
-  memxor3(Y.b, ctx-&gt;X.b, ctx-&gt;block.b, 16);
+  block16_xor3(&amp;Y, &amp;ctx-&gt;X, &amp;ctx-&gt;block);
   encrypt(cipher, 16, ctx-&gt;X.b, Y.b);
 
   while (msg_len &gt; 16)
     {
-      memxor3(Y.b, ctx-&gt;X.b, msg, 16);
+      block16_xor_bytes (&amp;Y, &amp;ctx-&gt;X, msg);
       encrypt(cipher, 16, ctx-&gt;X.b, Y.b);
       msg += 16;
       msg_len -= 16;
@@ -151,14 +152,14 @@ cmac128_digest(struct cmac128_ctx *ctx, const struct cmac128_key *key,
       ctx-&gt;block.b[ctx-&gt;index] = 0x80;
       memset(ctx-&gt;block.b + ctx-&gt;index + 1, 0, 16 - 1 - ctx-&gt;index);
 
-      memxor(ctx-&gt;block.b, key-&gt;K2.b, 16);
+      block16_xor (&amp;ctx-&gt;block, &amp;key-&gt;K2);
     }
   else
     {
-      memxor(ctx-&gt;block.b, key-&gt;K1.b, 16);
+      block16_xor (&amp;ctx-&gt;block, &amp;key-&gt;K1);
     }
 
-  memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 16);
+  block16_xor3 (&amp;Y, &amp;ctx-&gt;block, &amp;ctx-&gt;X);
 
   assert(length &lt;= 16);
   if (length == 16)
diff --git a/cmac64.c b/cmac64.c
index 636635ba478b..e7bb438580d6 100644
--- a/cmac64.c
+++ b/cmac64.c
@@ -43,8 +43,8 @@
 
 #include "cmac.h"
 
-#include "memxor.h"
 #include "nettle-internal.h"
+#include "block-internal.h"
 #include "macros.h"
 
 /* shift one and XOR with 0x87. */
@@ -119,12 +119,12 @@ cmac64_update(struct cmac64_ctx *ctx, const void *cipher,
   /*
    * now checksum everything but the last block
    */
-  memxor3(Y.b, ctx-&gt;X.b, ctx-&gt;block.b, 8);
+  block8_xor3(&amp;Y, &amp;ctx-&gt;X, &amp;ctx-&gt;block);
   encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
 
   while (msg_len &gt; 8)
     {
-      memxor3(Y.b, ctx-&gt;X.b, msg, 8);
+      block8_xor_bytes(&amp;Y, &amp;ctx-&gt;X, msg);
       encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
       msg += 8;
       msg_len -= 8;
@@ -151,14 +151,14 @@ cmac64_digest(struct cmac64_ctx *ctx, const struct cmac64_key *key,
   if (ctx-&gt;index &lt; 8)
     {
       ctx-&gt;block.b[ctx-&gt;index] = 0x80;
-      memxor(ctx-&gt;block.b, key-&gt;K2.b, 8);
+      block8_xor(&amp;ctx-&gt;block, &amp;key-&gt;K2);
     }
   else
     {
-      memxor(ctx-&gt;block.b, key-&gt;K1.b, 8);
+      block8_xor(&amp;ctx-&gt;block, &amp;key-&gt;K1);
     }
 
-  memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 8);
+  block8_xor3(&amp;Y, &amp;ctx-&gt;block, &amp;ctx-&gt;X);
 
   assert(length &lt;= 8);
   if (length == 8)
diff --git a/eax.c b/eax.c
index 4b8b5117746e..63f3ff82fe65 100644
--- a/eax.c
+++ b/eax.c
@@ -40,6 +40,7 @@
 
 #include "eax.h"
 
+#include "block-internal.h"
 #include "ctr.h"
 #include "memxor.h"
 
@@ -50,14 +51,6 @@ omac_init (union nettle_block16 *state, unsigned t)
   state-&gt;b[EAX_BLOCK_SIZE - 1] = t;
 }
 
-/* Almost the same as gcm_gf_add */
-static void
-block16_xor (union nettle_block16 *dst, const union nettle_block16 *src)
-{
-  dst-&gt;u64[0] ^= src-&gt;u64[0];
-  dst-&gt;u64[1] ^= src-&gt;u64[1];
-}
-
 static void
 omac_update (union nettle_block16 *state, const struct eax_key *key,
 	     const void *cipher, nettle_cipher_func *f,
diff --git a/gcm.c b/gcm.c
index 627097b24218..c550c5d810ef 100644
--- a/gcm.c
+++ b/gcm.c
@@ -53,16 +53,10 @@
 #include "nettle-internal.h"
 #include "macros.h"
 #include "ctr-internal.h"
+#include "block-internal.h"
 
 #define GHASH_POLYNOMIAL 0xE1UL
 
-static void
-gcm_gf_add (union nettle_block16 *r,
-	    const union nettle_block16 *x, const union nettle_block16 *y)
-{
-  r-&gt;u64[0] = x-&gt;u64[0] ^ y-&gt;u64[0];
-  r-&gt;u64[1] = x-&gt;u64[1] ^ y-&gt;u64[1];
-}
 /* Multiplication by 010...0; a big-endian shift right. If the bit
    shifted out is one, the defining polynomial is added to cancel it
    out. r == x is allowed. */
@@ -108,7 +102,7 @@ gcm_gf_mul (union nettle_block16 *x, const union nettle_block16 *y)
       for (j = 0; j &lt; 8; j++, b &lt;&lt;= 1)
 	{
 	  if (b &amp; 0x80)
-	    gcm_gf_add(&amp;Z, &amp;Z, &amp;V);
+	    block16_xor3(&amp;Z, &amp;Z, &amp;V);
 	  
 	  gcm_gf_shift(&amp;V, &amp;V);
 	}
@@ -165,9 +159,9 @@ gcm_gf_mul (union nettle_block16 *x, const union nettle_block16 *table)
       uint8_t b = x-&gt;b[i];
 
       gcm_gf_shift_4(&amp;Z);
-      gcm_gf_add(&amp;Z, &amp;Z, &amp;table[b &amp; 0xf]);
+      block16_xor3(&amp;Z, &amp;Z, &amp;table[b &amp; 0xf]);
       gcm_gf_shift_4(&amp;Z);
-      gcm_gf_add(&amp;Z, &amp;Z, &amp;table[b &gt;&gt; 4]);
+      block16_xor3(&amp;Z, &amp;Z, &amp;table[b &gt;&gt; 4]);
     }
   memcpy (x-&gt;b, Z.b, sizeof(Z));
 }
@@ -243,10 +237,10 @@ gcm_gf_mul (union nettle_block16 *x, const union nettle_block16 *table)
   for (i = GCM_BLOCK_SIZE-2; i &gt; 0; i--)
     {
       gcm_gf_shift_8(&amp;Z);
-      gcm_gf_add(&amp;Z, &amp;Z, &amp;table[x-&gt;b[i]]);
+      block16_xor3(&amp;Z, &amp;Z, &amp;table[x-&gt;b[i]]);
     }
   gcm_gf_shift_8(&amp;Z);
-  gcm_gf_add(x, &amp;Z, &amp;table[x-&gt;b[0]]);
+  block16_xor3(x, &amp;Z, &amp;table[x-&gt;b[0]]);
 }
 #  endif /* ! HAVE_NATIVE_gcm_hash8 */
 # else /* GCM_TABLE_BITS != 8 */
@@ -286,7 +280,7 @@ gcm_set_key(struct gcm_key *key,
     {
       unsigned j;
       for (j = 1; j &lt; i; j++)
-	gcm_gf_add(&amp;key-&gt;h[i+j], &amp;key-&gt;h[i],&amp;key-&gt;h[j]);
+	block16_xor3(&amp;key-&gt;h[i+j], &amp;key-&gt;h[i],&amp;key-&gt;h[j]);
     }
 #endif
 }
diff --git a/siv-cmac.c b/siv-cmac.c
index f498cb863f5a..42f740cddf5d 100644
--- a/siv-cmac.c
+++ b/siv-cmac.c
@@ -46,6 +46,7 @@
 #include "memops.h"
 #include "cmac-internal.h"
 #include "nettle-internal.h"
+#include "block-internal.h"
 
 /* This is an implementation of S2V for the AEAD case where
  * vectors if zero, are considered as S empty components */
@@ -69,12 +70,12 @@ _siv_s2v (const struct nettle_cipher *nc,
   _cmac128_block_mulx (&amp;D, &amp;D);
   cmac128_update (&amp;cmac_ctx, cmac_cipher, nc-&gt;encrypt, alength, adata);
   cmac128_digest (&amp;cmac_ctx, cmac_key, cmac_cipher, nc-&gt;encrypt, 16, S.b);
-  memxor (D.b, S.b, 16);
+  block16_xor (&amp;D, &amp;S);
 
   _cmac128_block_mulx (&amp;D, &amp;D);
   cmac128_update (&amp;cmac_ctx, cmac_cipher, nc-&gt;encrypt, nlength, nonce);
   cmac128_digest (&amp;cmac_ctx, cmac_key, cmac_cipher, nc-&gt;encrypt, 16, S.b);
-  memxor (D.b, S.b, 16);
+  block16_xor (&amp;D, &amp;S);
 
   /* Sn */
   if (plength &gt;= 16)
@@ -83,7 +84,7 @@ _siv_s2v (const struct nettle_cipher *nc,
 
       pdata += plength - 16;
 
-      memxor3 (T.b, pdata, D.b, 16);
+      block16_xor_bytes (&amp;T, &amp;D, pdata);
     }
   else
     {
@@ -95,7 +96,7 @@ _siv_s2v (const struct nettle_cipher *nc,
       if (plength + 1 &lt; 16)
 	memset (&amp;pad.b[plength + 1], 0, 16 - plength - 1);
 
-      memxor (T.b, pad.b, 16);
+      block16_xor (&amp;T, &amp;pad);
     }
 
   cmac128_update (&amp;cmac_ctx, cmac_cipher, nc-&gt;encrypt, 16, T.b);
-- 
2.23.0.rc1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190826182024</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-08-26 18:20:24-0400</timestampReceived><subject>[PATCH 4/5] block modes: move Galois shifts to block-internal.h</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Move Galois polynomial shifts to block-internal.h, simplifying common
code. GCM is left unconverted for now, this will be fixed later.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in       |  2 +-
 block-internal.h  | 76 +++++++++++++++++++++++++++++++++++++++++++++++
 cmac-internal.h   | 54 ---------------------------------
 cmac.c            | 20 ++-----------
 cmac64.c          | 21 ++-----------
 eax.c             | 18 ++---------
 gcm.c             |  4 ---
 siv-cmac-aes128.c |  1 -
 siv-cmac-aes256.c |  1 -
 siv-cmac.c        |  9 +++++-
 xts.c             | 18 ++---------
 11 files changed, 94 insertions(+), 130 deletions(-)
 delete mode 100644 cmac-internal.h

diff --git a/Makefile.in b/Makefile.in
index f6658c86341c..ae9c8a7563f9 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -231,7 +231,7 @@ DISTFILES = $(SOURCES) $(HEADERS) getopt.h getopt_int.h \
 	nettle.pc.in hogweed.pc.in \
 	$(des_headers) descore.README desdata.stamp \
 	aes-internal.h block-internal.h \
-	camellia-internal.h cmac-internal.h serpent-internal.h \
+	camellia-internal.h serpent-internal.h \
 	cast128_sboxes.h desinfo.h desCode.h \
 	ripemd160-internal.h sha2-internal.h \
 	memxor-internal.h nettle-internal.h nettle-write.h \
diff --git a/block-internal.h b/block-internal.h
index 84839c872f63..8cc30f6f5a02 100644
--- a/block-internal.h
+++ b/block-internal.h
@@ -90,4 +90,80 @@ block8_xor_bytes (union nettle_block8 *r,
   memxor3 (r-&gt;b, x-&gt;b, bytes, 8);
 }
 
+#define LSHIFT_WORD(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
+			(((x) &amp; 0x8080808080808080) &gt;&gt; 15))
+#define RSHIFT_WORD(x) ((((x) &amp; 0xfefefefefefefefe) &gt;&gt; 1) | \
+			(((x) &amp; 0x0001010101010101) &lt;&lt; 15))
+
+/* Galois multiplications by 2:
+ * functions differ in shifting right or left, big- or little- endianness
+ * and by defininy polynom.
+ * r == x is allowed. */
+
+#if WORDS_BIGENDIAN
+static inline void
+block16_lshift_be (union nettle_block16 *dst,
+		   const union nettle_block16 *src,
+		   uint64_t poly)
+{
+  uint64_t carry = src-&gt;u64[0] &gt;&gt; 63;
+  dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
+  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) ^ (poly &amp; -carry);
+}
+#else /* !WORDS_BIGENDIAN */
+static inline void
+block16_lshift_be (union nettle_block16 *dst,
+		   const union nettle_block16 *src,
+		   uint64_t poly)
+{
+  uint64_t carry = (src-&gt;u64[0] &amp; 0x80) &gt;&gt; 7;
+  dst-&gt;u64[0] = LSHIFT_WORD(src-&gt;u64[0]) | ((src-&gt;u64[1] &amp; 0x80) &lt;&lt; 49);
+  dst-&gt;u64[1] = LSHIFT_WORD(src-&gt;u64[1]) ^ ((poly &lt;&lt; 56) &amp; -carry);
+}
+#endif /* !WORDS_BIGENDIAN */
+
+#if WORDS_BIGENDIAN
+static inline void
+block16_lshift_le (union nettle_block16 *dst,
+		   const union nettle_block16 *src,
+		   uint64_t poly)
+{
+  uint64_t carry = (src-&gt;u64[1] &amp; 0x80) &gt;&gt; 7;
+  dst-&gt;u64[1] = LSHIFT_WORD(src-&gt;u64[1]) | ((src-&gt;u64[0] &amp; 0x80) &lt;&lt; 49);
+  dst-&gt;u64[0] = LSHIFT_WORD(src-&gt;u64[0]) ^ ((poly &lt;&lt; 56) &amp; -carry);
+}
+#else /* !WORDS_BIGENDIAN */
+static inline void
+block16_lshift_le (union nettle_block16 *dst,
+		   const union nettle_block16 *src,
+		   uint64_t poly)
+{
+  uint64_t carry = src-&gt;u64[1] &gt;&gt; 63;
+  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) | (src-&gt;u64[0] &gt;&gt; 63);
+  dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) ^ (poly &amp; -carry);
+}
+#endif /* !WORDS_BIGNDIAN */
+
+#if WORDS_BIGENDIAN
+static inline void
+block8_lshift_be (union nettle_block8 *dst,
+		  const union nettle_block8 *src,
+		  uint64_t poly)
+{
+  uint64_t carry = src-&gt;u64 &gt;&gt; 63;
+
+  dst-&gt;u64 = (src-&gt;u64 &lt;&lt; 1) ^ (poly &amp; -carry);
+}
+#else /* !WORDS_BIGENDIAN */
+static inline void
+block8_lshift_be (union nettle_block8 *dst,
+		  const union nettle_block8 *src,
+		  uint64_t poly)
+{
+  uint64_t carry = (src-&gt;u64 &amp; 0x80) &gt;&gt; 7;
+
+  dst-&gt;u64 = LSHIFT_WORD(src-&gt;u64) ^ ((poly &lt;&lt; 56) &amp; -carry);
+}
+#endif /* !WORDS_BIGENDIAN */
+
 #endif /* NETTLE_BLOCK_INTERNAL_H_INCLUDED */
diff --git a/cmac-internal.h b/cmac-internal.h
deleted file mode 100644
index 80db7fcc58cd..000000000000
--- a/cmac-internal.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/* cmac-internal.h
-
-   CMAC mode internal functions
-
-   Copyright (C) 2017 Red Hat, Inc.
-
-   Contributed by Nikos Mavrogiannopoulos
-
-   This file is part of GNU Nettle.
-
-   GNU Nettle is free software: you can redistribute it and/or
-   modify it under the terms of either:
-
-     * the GNU Lesser General Public License as published by the Free
-       Software Foundation; either version 3 of the License, or (at your
-       option) any later version.
-
-   or
-
-     * the GNU General Public License as published by the Free
-       Software Foundation; either version 2 of the License, or (at your
-       option) any later version.
-
-   or both in parallel, as here.
-
-   GNU Nettle is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   You should have received copies of the GNU General Public License and
-   the GNU Lesser General Public License along with this program.  If
-   not, see http://www.gnu.org/licenses/.
-*/
-
-#ifndef NETTLE_CMAC_INTERNAL_H_INCLUDED
-#define NETTLE_CMAC_INTERNAL_H_INCLUDED
-
-#include "cmac.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define _cmac128_block_mulx _nettle_cmac128_block_mulx
-
-void _cmac128_block_mulx(union nettle_block16 *out,
-			 const union nettle_block16 *in);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* CMAC_INTERNAL_H_INCLUDED */
diff --git a/cmac.c b/cmac.c
index 194324421c58..9b745daaaf1b 100644
--- a/cmac.c
+++ b/cmac.c
@@ -44,32 +44,16 @@
 
 #include "memxor.h"
 #include "nettle-internal.h"
-#include "cmac-internal.h"
 #include "block-internal.h"
 #include "macros.h"
 
 /* shift one and XOR with 0x87. */
-#if WORDS_BIGENDIAN
-void
-_cmac128_block_mulx(union nettle_block16 *dst,
-		    const union nettle_block16 *src)
-{
-  uint64_t carry = src-&gt;u64[0] &gt;&gt; 63;
-  dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
-  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) ^ (0x87 &amp; -carry);
-}
-#else /* !WORDS_BIGENDIAN */
-#define LE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
-                     (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
-void
+static inline void
 _cmac128_block_mulx(union nettle_block16 *dst,
 		    const union nettle_block16 *src)
 {
-  uint64_t carry = (src-&gt;u64[0] &amp; 0x80) &gt;&gt; 7;
-  dst-&gt;u64[0] = LE_SHIFT(src-&gt;u64[0]) | ((src-&gt;u64[1] &amp; 0x80) &lt;&lt; 49);
-  dst-&gt;u64[1] = LE_SHIFT(src-&gt;u64[1]) ^ (0x8700000000000000 &amp; -carry);
+  block16_lshift_be(dst, src, 0x87);
 }
-#endif /* !WORDS_BIGENDIAN */
 
 void
 cmac128_set_key(struct cmac128_key *key, const void *cipher,
diff --git a/cmac64.c b/cmac64.c
index e7bb438580d6..c423a804145e 100644
--- a/cmac64.c
+++ b/cmac64.c
@@ -47,28 +47,13 @@
 #include "block-internal.h"
 #include "macros.h"
 
-/* shift one and XOR with 0x87. */
-#if WORDS_BIGENDIAN
-static void
+/* shift one and XOR with 0x1b. */
+static inline void
 _cmac64_block_mulx(union nettle_block8 *dst,
 	    const union nettle_block8 *src)
 {
-  uint64_t carry = src-&gt;u64 &gt;&gt; 63;
-
-  dst-&gt;u64 = (src-&gt;u64 &lt;&lt; 1) ^ (0x1b &amp; -carry);
-}
-#else /* !WORDS_BIGENDIAN */
-#define LE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
-                     (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
-static void
-_cmac64_block_mulx(union nettle_block8 *dst,
-	   const union nettle_block8 *src)
-{
-  uint64_t carry = (src-&gt;u64 &amp; 0x80) &gt;&gt; 7;
-
-  dst-&gt;u64 = LE_SHIFT(src-&gt;u64) ^ (0x1b00000000000000 &amp; -carry);
+  block8_lshift_be(dst, src, 0x1b);
 }
-#endif /* !WORDS_BIGENDIAN */
 
 void
 cmac64_set_key(struct cmac64_key *key, const void *cipher,
diff --git a/eax.c b/eax.c
index 63f3ff82fe65..24f5b4f592fe 100644
--- a/eax.c
+++ b/eax.c
@@ -82,27 +82,13 @@ omac_final (union nettle_block16 *state, const struct eax_key *key,
   f (cipher, EAX_BLOCK_SIZE, state-&gt;b, state-&gt;b);
 }
 
-/* Allows r == a */
-static void
-gf2_double (uint8_t *r, const uint8_t *a)
-{
-  unsigned high = - (a[0] &gt;&gt; 7);
-  unsigned i;
-  /* Shift left */
-  for (i = 0; i &lt; EAX_BLOCK_SIZE - 1; i++)
-    r[i] = (a[i] &lt;&lt; 1) + (a[i+1] &gt;&gt; 7);
-
-  /* Wrap around for x^{128} = x^7 + x^2 + x + 1 */
-  r[EAX_BLOCK_SIZE - 1] = (a[EAX_BLOCK_SIZE - 1] &lt;&lt; 1) ^ (high &amp; 0x87);
-}
-
 void
 eax_set_key (struct eax_key *key, const void *cipher, nettle_cipher_func *f)
 {
   static const union nettle_block16 zero_block;
   f (cipher, EAX_BLOCK_SIZE, key-&gt;pad_block.b, zero_block.b);
-  gf2_double (key-&gt;pad_block.b, key-&gt;pad_block.b);
-  gf2_double (key-&gt;pad_partial.b, key-&gt;pad_block.b);
+  block16_lshift_be (&amp;key-&gt;pad_block, &amp;key-&gt;pad_block, 0x87);
+  block16_lshift_be (&amp;key-&gt;pad_partial, &amp;key-&gt;pad_block, 0x87);
   block16_xor (&amp;key-&gt;pad_partial, &amp;key-&gt;pad_block);
 }
 
diff --git a/gcm.c b/gcm.c
index c550c5d810ef..17c889e67553 100644
--- a/gcm.c
+++ b/gcm.c
@@ -71,13 +71,9 @@ gcm_gf_shift (union nettle_block16 *r, const union nettle_block16 *x)
   r-&gt;u64[1] = (x-&gt;u64[1] &gt;&gt; 1) | ((x-&gt;u64[0] &amp; 1) &lt;&lt; 63);
   r-&gt;u64[0] = (x-&gt;u64[0] &gt;&gt; 1) ^ (mask &amp; ((uint64_t) GHASH_POLYNOMIAL &lt;&lt; 56));
 #else /* ! WORDS_BIGENDIAN */
-#define RSHIFT_WORD(x) \
-  ((((x) &amp; 0xfefefefefefefefeUL) &gt;&gt; 1) \
-   | (((x) &amp; 0x0001010101010101UL) &lt;&lt; 15))
   mask = - ((x-&gt;u64[1] &gt;&gt; 56) &amp; 1);
   r-&gt;u64[1] = RSHIFT_WORD(x-&gt;u64[1]) | ((x-&gt;u64[0] &gt;&gt; 49) &amp; 0x80);
   r-&gt;u64[0] = RSHIFT_WORD(x-&gt;u64[0]) ^ (mask &amp; GHASH_POLYNOMIAL);
-# undef RSHIFT_WORD
 #endif /* ! WORDS_BIGENDIAN */
 }
 
diff --git a/siv-cmac-aes128.c b/siv-cmac-aes128.c
index 82ac16e91992..fd2e23a4513e 100644
--- a/siv-cmac-aes128.c
+++ b/siv-cmac-aes128.c
@@ -44,7 +44,6 @@
 #include "ctr.h"
 #include "memxor.h"
 #include "memops.h"
-#include "cmac-internal.h"
 
 void
 siv_cmac_aes128_set_key(struct siv_cmac_aes128_ctx *ctx, const uint8_t *key)
diff --git a/siv-cmac-aes256.c b/siv-cmac-aes256.c
index 9401bbf119c5..eda7f1c27a55 100644
--- a/siv-cmac-aes256.c
+++ b/siv-cmac-aes256.c
@@ -44,7 +44,6 @@
 #include "ctr.h"
 #include "memxor.h"
 #include "memops.h"
-#include "cmac-internal.h"
 
 void
 siv_cmac_aes256_set_key(struct siv_cmac_aes256_ctx *ctx, const uint8_t *key)
diff --git a/siv-cmac.c b/siv-cmac.c
index 42f740cddf5d..c0c8fff900dd 100644
--- a/siv-cmac.c
+++ b/siv-cmac.c
@@ -44,10 +44,17 @@
 #include "ctr.h"
 #include "memxor.h"
 #include "memops.h"
-#include "cmac-internal.h"
 #include "nettle-internal.h"
 #include "block-internal.h"
 
+/* shift one and XOR with 0x87. */
+static inline void
+_cmac128_block_mulx(union nettle_block16 *dst,
+		    const union nettle_block16 *src)
+{
+  block16_lshift_be(dst, src, 0x87);
+}
+
 /* This is an implementation of S2V for the AEAD case where
  * vectors if zero, are considered as S empty components */
 static void
diff --git a/xts.c b/xts.c
index 6730b3ad76ff..8f565751cac1 100644
--- a/xts.c
+++ b/xts.c
@@ -44,31 +44,17 @@
 #include "macros.h"
 #include "memxor.h"
 #include "nettle-internal.h"
+#include "block-internal.h"
 
 /* shift left one and XOR with 0x87 if there is carry. */
 /* the algorithm reads this as a 128bit Little Endian number */
 /* src and dest can point to the same buffer for in-place operations */
-#if WORDS_BIGENDIAN
-#define BE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
-                     (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
 static void
 xts_shift(union nettle_block16 *dst,
           const union nettle_block16 *src)
 {
-  uint64_t carry = (src-&gt;u64[1] &amp; 0x80) &gt;&gt; 7;
-  dst-&gt;u64[1] = BE_SHIFT(src-&gt;u64[1]) | ((src-&gt;u64[0] &amp; 0x80) &lt;&lt; 49);
-  dst-&gt;u64[0] = BE_SHIFT(src-&gt;u64[0]) ^ (0x8700000000000000 &amp; -carry);
+  block16_lshift_le(dst, src, 0x87);
 }
-#else /* !WORDS_BIGENDIAN */
-static void
-xts_shift(union nettle_block16 *dst,
-          const union nettle_block16 *src)
-{
-  uint64_t carry = src-&gt;u64[1] &gt;&gt; 63;
-  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) | (src-&gt;u64[0] &gt;&gt; 63);
-  dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) ^ (0x87 &amp; -carry);
-}
-#endif /* !WORDS_BIGNDIAN */
 
 static void
 check_length(size_t length, uint8_t *dst)
-- 
2.23.0.rc1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190826182025</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-08-26 18:20:25-0400</timestampReceived><subject>[PATCH 5/5] gcm: move block shifting function to block-internal.h</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Move GCM's block shift function to block-internal.h. This concludes
moving of all Galois mul-by-2 to single header.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 block-internal.h | 29 +++++++++++++++++++++++++++++
 gcm.c            | 15 ++-------------
 2 files changed, 31 insertions(+), 13 deletions(-)

diff --git a/block-internal.h b/block-internal.h
index 8cc30f6f5a02..874e4dbe1929 100644
--- a/block-internal.h
+++ b/block-internal.h
@@ -166,4 +166,33 @@ block8_lshift_be (union nettle_block8 *dst,
 }
 #endif /* !WORDS_BIGENDIAN */
 
+#if WORDS_BIGENDIAN
+static inline void
+block16_rshift_be (union nettle_block16 *r,
+		   const union nettle_block16 *x,
+		   uint64_t poly)
+{
+  uint64_t mask;
+
+  /* Shift uses big-endian representation. */
+  mask = - (x-&gt;u64[1] &amp; 1);
+  r-&gt;u64[1] = (x-&gt;u64[1] &gt;&gt; 1) | ((x-&gt;u64[0] &amp; 1) &lt;&lt; 63);
+  r-&gt;u64[0] = (x-&gt;u64[0] &gt;&gt; 1) ^ (mask &amp; (poly &lt;&lt; 56));
+}
+#else /* ! WORDS_BIGENDIAN */
+static inline void
+block16_rshift_be (union nettle_block16 *r,
+		   const union nettle_block16 *x,
+		   uint64_t poly)
+{
+  uint64_t mask;
+
+  /* Shift uses big-endian representation. */
+  mask = - ((x-&gt;u64[1] &gt;&gt; 56) &amp; 1);
+  r-&gt;u64[1] = RSHIFT_WORD(x-&gt;u64[1]) | ((x-&gt;u64[0] &gt;&gt; 49) &amp; 0x80);
+  r-&gt;u64[0] = RSHIFT_WORD(x-&gt;u64[0]) ^ (mask &amp; poly);
+}
+#endif /* ! WORDS_BIGENDIAN */
+
+/* shift one and XOR with 0x87. */
 #endif /* NETTLE_BLOCK_INTERNAL_H_INCLUDED */
diff --git a/gcm.c b/gcm.c
index 17c889e67553..eca6ab6cab25 100644
--- a/gcm.c
+++ b/gcm.c
@@ -60,21 +60,10 @@
 /* Multiplication by 010...0; a big-endian shift right. If the bit
    shifted out is one, the defining polynomial is added to cancel it
    out. r == x is allowed. */
-static void
+static inline void
 gcm_gf_shift (union nettle_block16 *r, const union nettle_block16 *x)
 {
-  uint64_t mask;
-
-  /* Shift uses big-endian representation. */
-#if WORDS_BIGENDIAN
-  mask = - (x-&gt;u64[1] &amp; 1);
-  r-&gt;u64[1] = (x-&gt;u64[1] &gt;&gt; 1) | ((x-&gt;u64[0] &amp; 1) &lt;&lt; 63);
-  r-&gt;u64[0] = (x-&gt;u64[0] &gt;&gt; 1) ^ (mask &amp; ((uint64_t) GHASH_POLYNOMIAL &lt;&lt; 56));
-#else /* ! WORDS_BIGENDIAN */
-  mask = - ((x-&gt;u64[1] &gt;&gt; 56) &amp; 1);
-  r-&gt;u64[1] = RSHIFT_WORD(x-&gt;u64[1]) | ((x-&gt;u64[0] &gt;&gt; 49) &amp; 0x80);
-  r-&gt;u64[0] = RSHIFT_WORD(x-&gt;u64[0]) ^ (mask &amp; GHASH_POLYNOMIAL);
-#endif /* ! WORDS_BIGENDIAN */
+  block16_rshift_be (r, x, GHASH_POLYNOMIAL);
 }
 
 #if GCM_TABLE_BITS == 0
-- 
2.23.0.rc1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190711184312</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-11 18:43:12-0400</timestampReceived><subject>[PATCH v2 2/6] Add support for GOSTHASH94CP: GOST R 34.11-94 hash with CryptoPro S-box</subject><body>

Hash gosthash94 implements GOST R 34.11-94 standard using S-Box defined
in the standard 'for testing purposes only'. RFC 4357 defines S-Box
(CryptoPro one) for GOST R 34.11-94 hash function that is widely used in
applications. Add separate hash function algorithm (gosthash94cp)
implementing GOST R 34.11-94 hashing using that S-Box.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 examples/nettle-benchmark.c |   1 +
 gost28147.c                 | 267 ++++++++++++++++++++++++++++++++++++
 gost28147.h                 |   2 +
 gosthash94-meta.c           |   3 +
 gosthash94.c                |  83 +++++++++--
 gosthash94.h                |  13 ++
 nettle-meta.h               |   1 +
 nettle.texinfo              |  41 +++++-
 testsuite/gosthash94-test.c |  12 ++
 9 files changed, 405 insertions(+), 18 deletions(-)

diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index 6e0f560b6bdc..5d0e649ea726 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -918,6 +918,7 @@ main(int argc, char **argv)
       &amp;nettle_sha3_224, &amp;nettle_sha3_256,
       &amp;nettle_sha3_384, &amp;nettle_sha3_512,
       &amp;nettle_ripemd160, &amp;nettle_gosthash94,
+      &amp;nettle_gosthash94cp,
       NULL
     };
 
diff --git a/gost28147.c b/gost28147.c
index 419cb943084d..15d314c86c17 100644
--- a/gost28147.c
+++ b/gost28147.c
@@ -304,6 +304,273 @@ const struct gost28147_param gost28147_param_test_3411 =
   }
 };
 
+const struct gost28147_param gost28147_param_CryptoPro_3411 =
+{
+  {
+    { /* 0 */
+      0x0002d000, 0x0002a000, 0x0002a800, 0x0002b000,
+      0x0002c000, 0x00028800, 0x00029800, 0x0002b800,
+      0x0002e800, 0x0002e000, 0x0002f000, 0x00028000,
+      0x0002c800, 0x00029000, 0x0002d800, 0x0002f800,
+      0x0007d000, 0x0007a000, 0x0007a800, 0x0007b000,
+      0x0007c000, 0x00078800, 0x00079800, 0x0007b800,
+      0x0007e800, 0x0007e000, 0x0007f000, 0x00078000,
+      0x0007c800, 0x00079000, 0x0007d800, 0x0007f800,
+      0x00025000, 0x00022000, 0x00022800, 0x00023000,
+      0x00024000, 0x00020800, 0x00021800, 0x00023800,
+      0x00026800, 0x00026000, 0x00027000, 0x00020000,
+      0x00024800, 0x00021000, 0x00025800, 0x00027800,
+      0x00005000, 0x00002000, 0x00002800, 0x00003000,
+      0x00004000, 0x00000800, 0x00001800, 0x00003800,
+      0x00006800, 0x00006000, 0x00007000, 0x00000000,
+      0x00004800, 0x00001000, 0x00005800, 0x00007800,
+      0x00015000, 0x00012000, 0x00012800, 0x00013000,
+      0x00014000, 0x00010800, 0x00011800, 0x00013800,
+      0x00016800, 0x00016000, 0x00017000, 0x00010000,
+      0x00014800, 0x00011000, 0x00015800, 0x00017800,
+      0x0006d000, 0x0006a000, 0x0006a800, 0x0006b000,
+      0x0006c000, 0x00068800, 0x00069800, 0x0006b800,
+      0x0006e800, 0x0006e000, 0x0006f000, 0x00068000,
+      0x0006c800, 0x00069000, 0x0006d800, 0x0006f800,
+      0x0005d000, 0x0005a000, 0x0005a800, 0x0005b000,
+      0x0005c000, 0x00058800, 0x00059800, 0x0005b800,
+      0x0005e800, 0x0005e000, 0x0005f000, 0x00058000,
+      0x0005c800, 0x00059000, 0x0005d800, 0x0005f800,
+      0x0004d000, 0x0004a000, 0x0004a800, 0x0004b000,
+      0x0004c000, 0x00048800, 0x00049800, 0x0004b800,
+      0x0004e800, 0x0004e000, 0x0004f000, 0x00048000,
+      0x0004c800, 0x00049000, 0x0004d800, 0x0004f800,
+      0x0000d000, 0x0000a000, 0x0000a800, 0x0000b000,
+      0x0000c000, 0x00008800, 0x00009800, 0x0000b800,
+      0x0000e800, 0x0000e000, 0x0000f000, 0x00008000,
+      0x0000c800, 0x00009000, 0x0000d800, 0x0000f800,
+      0x0003d000, 0x0003a000, 0x0003a800, 0x0003b000,
+      0x0003c000, 0x00038800, 0x00039800, 0x0003b800,
+      0x0003e800, 0x0003e000, 0x0003f000, 0x00038000,
+      0x0003c800, 0x00039000, 0x0003d800, 0x0003f800,
+      0x00035000, 0x00032000, 0x00032800, 0x00033000,
+      0x00034000, 0x00030800, 0x00031800, 0x00033800,
+      0x00036800, 0x00036000, 0x00037000, 0x00030000,
+      0x00034800, 0x00031000, 0x00035800, 0x00037800,
+      0x0001d000, 0x0001a000, 0x0001a800, 0x0001b000,
+      0x0001c000, 0x00018800, 0x00019800, 0x0001b800,
+      0x0001e800, 0x0001e000, 0x0001f000, 0x00018000,
+      0x0001c800, 0x00019000, 0x0001d800, 0x0001f800,
+      0x00065000, 0x00062000, 0x00062800, 0x00063000,
+      0x00064000, 0x00060800, 0x00061800, 0x00063800,
+      0x00066800, 0x00066000, 0x00067000, 0x00060000,
+      0x00064800, 0x00061000, 0x00065800, 0x00067800,
+      0x00075000, 0x00072000, 0x00072800, 0x00073000,
+      0x00074000, 0x00070800, 0x00071800, 0x00073800,
+      0x00076800, 0x00076000, 0x00077000, 0x00070000,
+      0x00074800, 0x00071000, 0x00075800, 0x00077800,
+      0x00055000, 0x00052000, 0x00052800, 0x00053000,
+      0x00054000, 0x00050800, 0x00051800, 0x00053800,
+      0x00056800, 0x00056000, 0x00057000, 0x00050000,
+      0x00054800, 0x00051000, 0x00055800, 0x00057800,
+      0x00045000, 0x00042000, 0x00042800, 0x00043000,
+      0x00044000, 0x00040800, 0x00041800, 0x00043800,
+      0x00046800, 0x00046000, 0x00047000, 0x00040000,
+      0x00044800, 0x00041000, 0x00045800, 0x00047800,
+    }, { /* 1 */
+      0x02380000, 0x02780000, 0x02600000, 0x02700000,
+      0x02480000, 0x02200000, 0x02080000, 0x02000000,
+      0x02180000, 0x02580000, 0x02280000, 0x02100000,
+      0x02300000, 0x02500000, 0x02400000, 0x02680000,
+      0x05380000, 0x05780000, 0x05600000, 0x05700000,
+      0x05480000, 0x05200000, 0x05080000, 0x05000000,
+      0x05180000, 0x05580000, 0x05280000, 0x05100000,
+      0x05300000, 0x05500000, 0x05400000, 0x05680000,
+      0x03b80000, 0x03f80000, 0x03e00000, 0x03f00000,
+      0x03c80000, 0x03a00000, 0x03880000, 0x03800000,
+      0x03980000, 0x03d80000, 0x03a80000, 0x03900000,
+      0x03b00000, 0x03d00000, 0x03c00000, 0x03e80000,
+      0x06380000, 0x06780000, 0x06600000, 0x06700000,
+      0x06480000, 0x06200000, 0x06080000, 0x06000000,
+      0x06180000, 0x06580000, 0x06280000, 0x06100000,
+      0x06300000, 0x06500000, 0x06400000, 0x06680000,
+      0x00380000, 0x00780000, 0x00600000, 0x00700000,
+      0x00480000, 0x00200000, 0x00080000, 0x00000000,
+      0x00180000, 0x00580000, 0x00280000, 0x00100000,
+      0x00300000, 0x00500000, 0x00400000, 0x00680000,
+      0x07b80000, 0x07f80000, 0x07e00000, 0x07f00000,
+      0x07c80000, 0x07a00000, 0x07880000, 0x07800000,
+      0x07980000, 0x07d80000, 0x07a80000, 0x07900000,
+      0x07b00000, 0x07d00000, 0x07c00000, 0x07e80000,
+      0x01380000, 0x01780000, 0x01600000, 0x01700000,
+      0x01480000, 0x01200000, 0x01080000, 0x01000000,
+      0x01180000, 0x01580000, 0x01280000, 0x01100000,
+      0x01300000, 0x01500000, 0x01400000, 0x01680000,
+      0x04380000, 0x04780000, 0x04600000, 0x04700000,
+      0x04480000, 0x04200000, 0x04080000, 0x04000000,
+      0x04180000, 0x04580000, 0x04280000, 0x04100000,
+      0x04300000, 0x04500000, 0x04400000, 0x04680000,
+      0x07380000, 0x07780000, 0x07600000, 0x07700000,
+      0x07480000, 0x07200000, 0x07080000, 0x07000000,
+      0x07180000, 0x07580000, 0x07280000, 0x07100000,
+      0x07300000, 0x07500000, 0x07400000, 0x07680000,
+      0x00b80000, 0x00f80000, 0x00e00000, 0x00f00000,
+      0x00c80000, 0x00a00000, 0x00880000, 0x00800000,
+      0x00980000, 0x00d80000, 0x00a80000, 0x00900000,
+      0x00b00000, 0x00d00000, 0x00c00000, 0x00e80000,
+      0x03380000, 0x03780000, 0x03600000, 0x03700000,
+      0x03480000, 0x03200000, 0x03080000, 0x03000000,
+      0x03180000, 0x03580000, 0x03280000, 0x03100000,
+      0x03300000, 0x03500000, 0x03400000, 0x03680000,
+      0x02b80000, 0x02f80000, 0x02e00000, 0x02f00000,
+      0x02c80000, 0x02a00000, 0x02880000, 0x02800000,
+      0x02980000, 0x02d80000, 0x02a80000, 0x02900000,
+      0x02b00000, 0x02d00000, 0x02c00000, 0x02e80000,
+      0x06b80000, 0x06f80000, 0x06e00000, 0x06f00000,
+      0x06c80000, 0x06a00000, 0x06880000, 0x06800000,
+      0x06980000, 0x06d80000, 0x06a80000, 0x06900000,
+      0x06b00000, 0x06d00000, 0x06c00000, 0x06e80000,
+      0x05b80000, 0x05f80000, 0x05e00000, 0x05f00000,
+      0x05c80000, 0x05a00000, 0x05880000, 0x05800000,
+      0x05980000, 0x05d80000, 0x05a80000, 0x05900000,
+      0x05b00000, 0x05d00000, 0x05c00000, 0x05e80000,
+      0x04b80000, 0x04f80000, 0x04e00000, 0x04f00000,
+      0x04c80000, 0x04a00000, 0x04880000, 0x04800000,
+      0x04980000, 0x04d80000, 0x04a80000, 0x04900000,
+      0x04b00000, 0x04d00000, 0x04c00000, 0x04e80000,
+      0x01b80000, 0x01f80000, 0x01e00000, 0x01f00000,
+      0x01c80000, 0x01a00000, 0x01880000, 0x01800000,
+      0x01980000, 0x01d80000, 0x01a80000, 0x01900000,
+      0x01b00000, 0x01d00000, 0x01c00000, 0x01e80000,
+    }, { /* 2 */
+      0xb8000003, 0xb0000003, 0xa0000003, 0xd8000003,
+      0xc8000003, 0xe0000003, 0x90000003, 0xd0000003,
+      0x88000003, 0xc0000003, 0x80000003, 0xf0000003,
+      0xf8000003, 0xe8000003, 0x98000003, 0xa8000003,
+      0x38000003, 0x30000003, 0x20000003, 0x58000003,
+      0x48000003, 0x60000003, 0x10000003, 0x50000003,
+      0x08000003, 0x40000003, 0x00000003, 0x70000003,
+      0x78000003, 0x68000003, 0x18000003, 0x28000003,
+      0x38000001, 0x30000001, 0x20000001, 0x58000001,
+      0x48000001, 0x60000001, 0x10000001, 0x50000001,
+      0x08000001, 0x40000001, 0x00000001, 0x70000001,
+      0x78000001, 0x68000001, 0x18000001, 0x28000001,
+      0x38000002, 0x30000002, 0x20000002, 0x58000002,
+      0x48000002, 0x60000002, 0x10000002, 0x50000002,
+      0x08000002, 0x40000002, 0x00000002, 0x70000002,
+      0x78000002, 0x68000002, 0x18000002, 0x28000002,
+      0xb8000006, 0xb0000006, 0xa0000006, 0xd8000006,
+      0xc8000006, 0xe0000006, 0x90000006, 0xd0000006,
+      0x88000006, 0xc0000006, 0x80000006, 0xf0000006,
+      0xf8000006, 0xe8000006, 0x98000006, 0xa8000006,
+      0xb8000004, 0xb0000004, 0xa0000004, 0xd8000004,
+      0xc8000004, 0xe0000004, 0x90000004, 0xd0000004,
+      0x88000004, 0xc0000004, 0x80000004, 0xf0000004,
+      0xf8000004, 0xe8000004, 0x98000004, 0xa8000004,
+      0xb8000007, 0xb0000007, 0xa0000007, 0xd8000007,
+      0xc8000007, 0xe0000007, 0x90000007, 0xd0000007,
+      0x88000007, 0xc0000007, 0x80000007, 0xf0000007,
+      0xf8000007, 0xe8000007, 0x98000007, 0xa8000007,
+      0x38000000, 0x30000000, 0x20000000, 0x58000000,
+      0x48000000, 0x60000000, 0x10000000, 0x50000000,
+      0x08000000, 0x40000000, 0x00000000, 0x70000000,
+      0x78000000, 0x68000000, 0x18000000, 0x28000000,
+      0x38000005, 0x30000005, 0x20000005, 0x58000005,
+      0x48000005, 0x60000005, 0x10000005, 0x50000005,
+      0x08000005, 0x40000005, 0x00000005, 0x70000005,
+      0x78000005, 0x68000005, 0x18000005, 0x28000005,
+      0xb8000000, 0xb0000000, 0xa0000000, 0xd8000000,
+      0xc8000000, 0xe0000000, 0x90000000, 0xd0000000,
+      0x88000000, 0xc0000000, 0x80000000, 0xf0000000,
+      0xf8000000, 0xe8000000, 0x98000000, 0xa8000000,
+      0xb8000002, 0xb0000002, 0xa0000002, 0xd8000002,
+      0xc8000002, 0xe0000002, 0x90000002, 0xd0000002,
+      0x88000002, 0xc0000002, 0x80000002, 0xf0000002,
+      0xf8000002, 0xe8000002, 0x98000002, 0xa8000002,
+      0xb8000005, 0xb0000005, 0xa0000005, 0xd8000005,
+      0xc8000005, 0xe0000005, 0x90000005, 0xd0000005,
+      0x88000005, 0xc0000005, 0x80000005, 0xf0000005,
+      0xf8000005, 0xe8000005, 0x98000005, 0xa8000005,
+      0x38000004, 0x30000004, 0x20000004, 0x58000004,
+      0x48000004, 0x60000004, 0x10000004, 0x50000004,
+      0x08000004, 0x40000004, 0x00000004, 0x70000004,
+      0x78000004, 0x68000004, 0x18000004, 0x28000004,
+      0x38000007, 0x30000007, 0x20000007, 0x58000007,
+      0x48000007, 0x60000007, 0x10000007, 0x50000007,
+      0x08000007, 0x40000007, 0x00000007, 0x70000007,
+      0x78000007, 0x68000007, 0x18000007, 0x28000007,
+      0x38000006, 0x30000006, 0x20000006, 0x58000006,
+      0x48000006, 0x60000006, 0x10000006, 0x50000006,
+      0x08000006, 0x40000006, 0x00000006, 0x70000006,
+      0x78000006, 0x68000006, 0x18000006, 0x28000006,
+      0xb8000001, 0xb0000001, 0xa0000001, 0xd8000001,
+      0xc8000001, 0xe0000001, 0x90000001, 0xd0000001,
+      0x88000001, 0xc0000001, 0x80000001, 0xf0000001,
+      0xf8000001, 0xe8000001, 0x98000001, 0xa8000001,
+    }, { /* 3 */
+      0x000000e8, 0x000000f0, 0x000000a0, 0x00000088,
+      0x000000b8, 0x00000080, 0x000000a8, 0x000000d0,
+      0x00000098, 0x000000e0, 0x000000c0, 0x000000f8,
+      0x000000b0, 0x00000090, 0x000000c8, 0x000000d8,
+      0x000001e8, 0x000001f0, 0x000001a0, 0x00000188,
+      0x000001b8, 0x00000180, 0x000001a8, 0x000001d0,
+      0x00000198, 0x000001e0, 0x000001c0, 0x000001f8,
+      0x000001b0, 0x00000190, 0x000001c8, 0x000001d8,
+      0x00000568, 0x00000570, 0x00000520, 0x00000508,
+      0x00000538, 0x00000500, 0x00000528, 0x00000550,
+      0x00000518, 0x00000560, 0x00000540, 0x00000578,
+      0x00000530, 0x00000510, 0x00000548, 0x00000558,
+      0x000004e8, 0x000004f0, 0x000004a0, 0x00000488,
+      0x000004b8, 0x00000480, 0x000004a8, 0x000004d0,
+      0x00000498, 0x000004e0, 0x000004c0, 0x000004f8,
+      0x000004b0, 0x00000490, 0x000004c8, 0x000004d8,
+      0x000002e8, 0x000002f0, 0x000002a0, 0x00000288,
+      0x000002b8, 0x00000280, 0x000002a8, 0x000002d0,
+      0x00000298, 0x000002e0, 0x000002c0, 0x000002f8,
+      0x000002b0, 0x00000290, 0x000002c8, 0x000002d8,
+      0x000005e8, 0x000005f0, 0x000005a0, 0x00000588,
+      0x000005b8, 0x00000580, 0x000005a8, 0x000005d0,
+      0x00000598, 0x000005e0, 0x000005c0, 0x000005f8,
+      0x000005b0, 0x00000590, 0x000005c8, 0x000005d8,
+      0x00000268, 0x00000270, 0x00000220, 0x00000208,
+      0x00000238, 0x00000200, 0x00000228, 0x00000250,
+      0x00000218, 0x00000260, 0x00000240, 0x00000278,
+      0x00000230, 0x00000210, 0x00000248, 0x00000258,
+      0x000007e8, 0x000007f0, 0x000007a0, 0x00000788,
+      0x000007b8, 0x00000780, 0x000007a8, 0x000007d0,
+      0x00000798, 0x000007e0, 0x000007c0, 0x000007f8,
+      0x000007b0, 0x00000790, 0x000007c8, 0x000007d8,
+      0x00000468, 0x00000470, 0x00000420, 0x00000408,
+      0x00000438, 0x00000400, 0x00000428, 0x00000450,
+      0x00000418, 0x00000460, 0x00000440, 0x00000478,
+      0x00000430, 0x00000410, 0x00000448, 0x00000458,
+      0x00000368, 0x00000370, 0x00000320, 0x00000308,
+      0x00000338, 0x00000300, 0x00000328, 0x00000350,
+      0x00000318, 0x00000360, 0x00000340, 0x00000378,
+      0x00000330, 0x00000310, 0x00000348, 0x00000358,
+      0x000003e8, 0x000003f0, 0x000003a0, 0x00000388,
+      0x000003b8, 0x00000380, 0x000003a8, 0x000003d0,
+      0x00000398, 0x000003e0, 0x000003c0, 0x000003f8,
+      0x000003b0, 0x00000390, 0x000003c8, 0x000003d8,
+      0x00000768, 0x00000770, 0x00000720, 0x00000708,
+      0x00000738, 0x00000700, 0x00000728, 0x00000750,
+      0x00000718, 0x00000760, 0x00000740, 0x00000778,
+      0x00000730, 0x00000710, 0x00000748, 0x00000758,
+      0x000006e8, 0x000006f0, 0x000006a0, 0x00000688,
+      0x000006b8, 0x00000680, 0x000006a8, 0x000006d0,
+      0x00000698, 0x000006e0, 0x000006c0, 0x000006f8,
+      0x000006b0, 0x00000690, 0x000006c8, 0x000006d8,
+      0x00000068, 0x00000070, 0x00000020, 0x00000008,
+      0x00000038, 0x00000000, 0x00000028, 0x00000050,
+      0x00000018, 0x00000060, 0x00000040, 0x00000078,
+      0x00000030, 0x00000010, 0x00000048, 0x00000058,
+      0x00000168, 0x00000170, 0x00000120, 0x00000108,
+      0x00000138, 0x00000100, 0x00000128, 0x00000150,
+      0x00000118, 0x00000160, 0x00000140, 0x00000178,
+      0x00000130, 0x00000110, 0x00000148, 0x00000158,
+      0x00000668, 0x00000670, 0x00000620, 0x00000608,
+      0x00000638, 0x00000600, 0x00000628, 0x00000650,
+      0x00000618, 0x00000660, 0x00000640, 0x00000678,
+      0x00000630, 0x00000610, 0x00000648, 0x00000658,
+    }
+  }
+};
+
 /*
  *  A macro that performs a full encryption round of GOST 28147-89.
  */
diff --git a/gost28147.h b/gost28147.h
index d403c4329f13..32e7d5e81eb8 100644
--- a/gost28147.h
+++ b/gost28147.h
@@ -41,6 +41,7 @@ extern "C" {
 #endif
 
 #define gost28147_param_test_3411 nettle_gost28147_param_test_3411
+#define gost28147_param_CryptoPro_3411 nettle_gost28147_param_CryptoPro_3411
 
 struct gost28147_param
 {
@@ -48,6 +49,7 @@ struct gost28147_param
 };
 
 extern const struct gost28147_param gost28147_param_test_3411;
+extern const struct gost28147_param gost28147_param_CryptoPro_3411;
 
 #ifdef __cplusplus
 }
diff --git a/gosthash94-meta.c b/gosthash94-meta.c
index 42b05562b7f8..ad203bfd6c18 100644
--- a/gosthash94-meta.c
+++ b/gosthash94-meta.c
@@ -39,3 +39,6 @@
 
 const struct nettle_hash nettle_gosthash94
 = _NETTLE_HASH(gosthash94, GOSTHASH94);
+
+const struct nettle_hash nettle_gosthash94cp
+= _NETTLE_HASH(gosthash94cp, GOSTHASH94CP);
diff --git a/gosthash94.c b/gosthash94.c
index 53716ca744a2..954130f741e9 100644
--- a/gosthash94.c
+++ b/gosthash94.c
@@ -5,6 +5,7 @@
  * See also RFC 4357.
  *
  * Copyright: 2009-2012 Aleksey Kravchenko &lt;rhash.admin@gmail.com&gt;
+ * Copyright: 2019 Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
@@ -62,7 +63,8 @@ gosthash94_init (struct gosthash94_ctx *ctx)
  * @param block the message block to process
  */
 static void
-gost_block_compress (struct gosthash94_ctx *ctx, const uint32_t *block)
+gost_block_compress (struct gosthash94_ctx *ctx, const uint32_t *block,
+		     const uint32_t sbox[4][256])
 {
     unsigned i;
     uint32_t key[8], u[8], v[8], w[8], s[8];
@@ -107,7 +109,7 @@ gost_block_compress (struct gosthash94_ctx *ctx, const uint32_t \
*block)  ((w[5] &amp; 0xff000000) &gt;&gt; 8) | (w[7] &amp; 0xff000000);
 
           /* encryption: s_i := E_{key_i} (h_i) */
-          _gost28147_encrypt_block (key, gost28147_param_test_3411.sbox, \
&amp;ctx-&gt;hash[i], &amp;s[i]); +          _gost28147_encrypt_block (key, sbox, &amp;ctx-&gt;hash[i], \
&amp;s[i]);  
           if (i == 0)
             {
@@ -262,7 +264,8 @@ gost_block_compress (struct gosthash94_ctx *ctx, const uint32_t \
                *block)
  * @param block the 256-bit message block to process
  */
 static void
-gost_compute_sum_and_hash (struct gosthash94_ctx *ctx, const uint8_t *block)
+gost_compute_sum_and_hash (struct gosthash94_ctx *ctx, const uint8_t *block,
+			   const uint32_t sbox[4][256])
 {
     uint32_t block_le[8];
     unsigned i, carry;
@@ -278,7 +281,7 @@ gost_compute_sum_and_hash (struct gosthash94_ctx *ctx, const \
uint8_t *block)  }
 
     /* update message hash */
-    gost_block_compress (ctx, block_le);
+    gost_block_compress (ctx, block_le, sbox);
 }
 
 /**
@@ -289,9 +292,10 @@ gost_compute_sum_and_hash (struct gosthash94_ctx *ctx, const \
                uint8_t *block)
  * @param msg message chunk
  * @param size length of the message chunk
  */
-void
-gosthash94_update (struct gosthash94_ctx *ctx,
-		   size_t length, const uint8_t *msg)
+static void
+gosthash94_update_int (struct gosthash94_ctx *ctx,
+		       size_t length, const uint8_t *msg,
+		       const uint32_t sbox[4][256])
 {
     unsigned index = (unsigned) ctx-&gt;length &amp; 31;
     ctx-&gt;length += length;
@@ -305,13 +309,13 @@ gosthash94_update (struct gosthash94_ctx *ctx,
               return;
 
           /* process partial block */
-          gost_compute_sum_and_hash (ctx, ctx-&gt;message);
+          gost_compute_sum_and_hash (ctx, ctx-&gt;message, sbox);
           msg += left;
           length -= left;
       }
     while (length &gt;= GOSTHASH94_BLOCK_SIZE)
       {
-          gost_compute_sum_and_hash (ctx, msg);
+          gost_compute_sum_and_hash (ctx, msg, sbox);
           msg += GOSTHASH94_BLOCK_SIZE;
           length -= GOSTHASH94_BLOCK_SIZE;
       }
@@ -322,15 +326,48 @@ gosthash94_update (struct gosthash94_ctx *ctx,
       }
 }
 
+/**
+ * Calculate message hash.
+ * Can be called repeatedly with chunks of the message to be hashed.
+ *
+ * @param ctx the algorithm context containing current hashing state
+ * @param msg message chunk
+ * @param size length of the message chunk
+ */
+void
+gosthash94_update (struct gosthash94_ctx *ctx,
+		   size_t length, const uint8_t *msg)
+{
+  gosthash94_update_int (ctx, length, msg,
+			 gost28147_param_test_3411.sbox);
+}
+
+/**
+ * Calculate message hash.
+ * Can be called repeatedly with chunks of the message to be hashed.
+ *
+ * @param ctx the algorithm context containing current hashing state
+ * @param msg message chunk
+ * @param size length of the message chunk
+ */
+void
+gosthash94cp_update (struct gosthash94_ctx *ctx,
+		     size_t length, const uint8_t *msg)
+{
+  gosthash94_update_int (ctx, length, msg,
+			 gost28147_param_CryptoPro_3411.sbox);
+}
+
 /**
  * Finish hashing and store message digest into given array.
  *
  * @param ctx the algorithm context containing current hashing state
  * @param result calculated hash in binary form
  */
-void
-gosthash94_digest (struct gosthash94_ctx *ctx,
-		   size_t length, uint8_t *result)
+static void
+gosthash94_write_digest (struct gosthash94_ctx *ctx,
+			 size_t length, uint8_t *result,
+			 const uint32_t sbox[4][256])
 {
     unsigned index = ctx-&gt;length &amp; 31;
     uint32_t msg32[8];
@@ -341,7 +378,7 @@ gosthash94_digest (struct gosthash94_ctx *ctx,
     if (index &gt; 0)
       {
           memset (ctx-&gt;message + index, 0, 32 - index);
-          gost_compute_sum_and_hash (ctx, ctx-&gt;message);
+          gost_compute_sum_and_hash (ctx, ctx-&gt;message, sbox);
       }
 
     /* hash the message length and the sum */
@@ -349,10 +386,26 @@ gosthash94_digest (struct gosthash94_ctx *ctx,
     msg32[1] = ctx-&gt;length &gt;&gt; 29;
     memset (msg32 + 2, 0, sizeof (uint32_t) * 6);
 
-    gost_block_compress (ctx, msg32);
-    gost_block_compress (ctx, ctx-&gt;sum);
+    gost_block_compress (ctx, msg32, sbox);
+    gost_block_compress (ctx, ctx-&gt;sum, sbox);
 
     /* convert hash state to result bytes */
     _nettle_write_le32(length, result, ctx-&gt;hash);
     gosthash94_init (ctx);
 }
+
+void
+gosthash94_digest (struct gosthash94_ctx *ctx,
+		   size_t length, uint8_t *result)
+{
+  gosthash94_write_digest (ctx, length, result,
+			   gost28147_param_test_3411.sbox);
+}
+
+void
+gosthash94cp_digest (struct gosthash94_ctx *ctx,
+		     size_t length, uint8_t *result)
+{
+  gosthash94_write_digest (ctx, length, result,
+			   gost28147_param_CryptoPro_3411.sbox);
+}
diff --git a/gosthash94.h b/gosthash94.h
index 60b2bef2837f..dfa97f61de6e 100644
--- a/gosthash94.h
+++ b/gosthash94.h
@@ -72,11 +72,17 @@ extern "C" {
 #define gosthash94_update nettle_gosthash94_update
 #define gosthash94_digest nettle_gosthash94_digest
 
+#define gosthash94cp_update nettle_gosthash94cp_update
+#define gosthash94cp_digest nettle_gosthash94cp_digest
+
 #define GOSTHASH94_BLOCK_SIZE 32
 #define GOSTHASH94_DIGEST_SIZE 32
 /* For backwards compatibility */
 #define GOSTHASH94_DATA_SIZE GOSTHASH94_BLOCK_SIZE
 
+#define GOSTHASH94CP_BLOCK_SIZE GOSTHASH94_BLOCK_SIZE
+#define GOSTHASH94CP_DIGEST_SIZE GOSTHASH94_DIGEST_SIZE
+
 struct gosthash94_ctx
 {
   uint32_t hash[8]; /* algorithm 256-bit state */
@@ -84,6 +90,7 @@ struct gosthash94_ctx
   uint64_t length;  /* number of processed bytes */
   uint8_t message[GOSTHASH94_BLOCK_SIZE]; /* 256-bit buffer for leftovers */
 };
+#define gosthash94cp_ctx gosthash94_ctx
 
 void gosthash94_init(struct gosthash94_ctx *ctx);
 void gosthash94_update(struct gosthash94_ctx *ctx,
@@ -91,6 +98,12 @@ void gosthash94_update(struct gosthash94_ctx *ctx,
 void gosthash94_digest(struct gosthash94_ctx *ctx,
 		       size_t length, uint8_t *result);
 
+#define gosthash94cp_init gosthash94_init
+void gosthash94cp_update(struct gosthash94_ctx *ctx,
+			 size_t length, const uint8_t *msg);
+void gosthash94cp_digest(struct gosthash94_ctx *ctx,
+			 size_t length, uint8_t *result);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/nettle-meta.h b/nettle-meta.h
index 74e50e59cd2e..b4cdb8f3e378 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -130,6 +130,7 @@ extern const struct nettle_hash nettle_md2;
 extern const struct nettle_hash nettle_md4;
 extern const struct nettle_hash nettle_md5;
 extern const struct nettle_hash nettle_gosthash94;
+extern const struct nettle_hash nettle_gosthash94cp;
 extern const struct nettle_hash nettle_ripemd160;
 extern const struct nettle_hash nettle_sha1;
 extern const struct nettle_hash nettle_sha224;
diff --git a/nettle.texinfo b/nettle.texinfo
index 9cdec4806214..422bd7c8ecf0 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -1039,12 +1039,17 @@ This function also resets the context in the same way as
 @end deftypefun
 
 
-@subsubsection @acronym{GOSTHASH94}
+@subsubsection @acronym{GOSTHASH94 and GOSTHASH94CP}
 
 The GOST94 or GOST R 34.11-94 hash algorithm is a Soviet-era algorithm 
 used in Russian government standards (see @cite{RFC 4357}).
-It outputs message digests of 256 bits, or 32 octets.
-Nettle defines GOSTHASH94 in @file{&lt;nettle/gosthash94.h&gt;}.
+It outputs message digests of 256 bits, or 32 octets. The standard itself
+does not fix the S-box used by the hash algorith, so there are two popular
+variants (the testing S-box from the standard itself and the S-box defined
+by CryptoPro company, see RFC 4357). Nettle provides support for the former
+S-box in the form of GOSTHASH94 hash algorithm and for the latter in the
+form of GOSTHASH94CP hash algorithm.
+Nettle defines GOSTHASH94 and GOSTHASH94CP in @file{&lt;nettle/gosthash94.h&gt;}.
 
 @deftp {Context struct} {struct gosthash94_ctx}
 @end deftp
@@ -1075,6 +1080,35 @@ This function also resets the context in the same way as
 @code{gosthash94_init}.
 @end deftypefun
 
+@deftp {Context struct} {struct gosthash94cp_ctx}
+@end deftp
+
+@defvr Constant GOSTHASH94CP_DIGEST_SIZE
+The size of a GOSTHASH94CP digest, i.e. 32.
+@end defvr
+
+@defvr Constant GOSTHASH94CP_BLOCK_SIZE
+The internal block size of GOSTHASH94CP, i.e., 32.
+@end defvr
+
+@deftypefun void gosthash94cp_init (struct gosthash94cp_ctx *@var{ctx})
+Initialize the GOSTHASH94CP state.
+@end deftypefun
+
+@deftypefun void gosthash94cp_update (struct gosthash94cp_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +Hash some more data.
+@end deftypefun
+
+@deftypefun void gosthash94cp_digest (struct gosthash94cp_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Performs final processing and extracts the \
message digest, writing it +to @var{digest}. @var{length} may be smaller than
+@code{GOSTHASH94CP_DIGEST_SIZE}, in which case only the first @var{length}
+octets of the digest are written.
+
+This function also resets the context in the same way as
+@code{gosthash94cp_init}.
+@end deftypefun
+
 @node nettle_hash abstraction,, Legacy hash functions, Hash functions
 @comment  node-name,  next,  previous,  up
 @subsection The @code{struct nettle_hash} abstraction
@@ -1104,6 +1138,7 @@ The last three attributes are function pointers, of types
 @deftypevrx {Constant Struct} {struct nettle_hash} nettle_sha512
 @deftypevrx {Constant Struct} {struct nettle_hash} nettle_sha3_256
 @deftypevrx {Constant Struct} {struct nettle_hash} nettle_gosthash94
+@deftypevrx {Constant Struct} {struct nettle_hash} nettle_gosthash94cp
 These are all the hash functions that Nettle implements.
 @end deftypevr
 
diff --git a/testsuite/gosthash94-test.c b/testsuite/gosthash94-test.c
index 77fb8befa9d8..d4e5015843d9 100644
--- a/testsuite/gosthash94-test.c
+++ b/testsuite/gosthash94-test.c
@@ -17,4 +17,16 @@ test_main(void)
 
   test_hash(&amp;nettle_gosthash94, SDATA(""),
 	    SHEX("ce85b99cc46752fffee35cab9a7b0278abb4c2d2055cff685af4912c49490f8d"));
+
+  test_hash(&amp;nettle_gosthash94cp, SDATA("The quick brown fox jumps over the lazy \
dog"), +	    SHEX("9004294a361a508c586fe53d1f1b02746765e71b765472786e4770d565830a76"));
 +
+  test_hash(&amp;nettle_gosthash94cp, SDATA("message digest"),
+	    SHEX("bc6041dd2aa401ebfa6e9886734174febdb4729aa972d60f549ac39b29721ba0"));
+
+  test_hash(&amp;nettle_gosthash94cp, SDATA("a"),
+	    SHEX("e74c52dd282183bf37af0079c9f78055715a103f17e3133ceff1aacf2f403011"));
+
+  test_hash(&amp;nettle_gosthash94cp, SDATA(""),
+	    SHEX("981e5f3ca30c841487830f84fb433e13ac1101569b9c13584ac483234cd656c0"));
 }
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190711184313</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-11 18:43:13-0400</timestampReceived><subject>[PATCH v2 3/6] gosthash94: switch to using MD_UPDATE() macro</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 gosthash94.c | 43 +++++++++----------------------------------
 gosthash94.h |  5 +++--
 2 files changed, 12 insertions(+), 36 deletions(-)

diff --git a/gosthash94.c b/gosthash94.c
index 954130f741e9..b1ea98736b0d 100644
--- a/gosthash94.c
+++ b/gosthash94.c
@@ -284,6 +284,8 @@ gost_compute_sum_and_hash (struct gosthash94_ctx *ctx, const uint8_t *block,
     gost_block_compress (ctx, block_le, sbox);
 }
 
+#define COMPRESS(ctx, block) gost_compute_sum_and_hash((ctx), (block), sbox);
+
 /**
  * Calculate message hash.
  * Can be called repeatedly with chunks of the message to be hashed.
@@ -297,33 +299,7 @@ gosthash94_update_int (struct gosthash94_ctx *ctx,
 		       size_t length, const uint8_t *msg,
 		       const uint32_t sbox[4][256])
 {
-    unsigned index = (unsigned) ctx-&gt;length &amp; 31;
-    ctx-&gt;length += length;
-
-    /* fill partial block */
-    if (index)
-      {
-          unsigned left = GOSTHASH94_BLOCK_SIZE - index;
-          memcpy (ctx-&gt;message + index, msg, (length &lt; left ? length : left));
-          if (length &lt; left)
-              return;
-
-          /* process partial block */
-          gost_compute_sum_and_hash (ctx, ctx-&gt;message, sbox);
-          msg += left;
-          length -= left;
-      }
-    while (length &gt;= GOSTHASH94_BLOCK_SIZE)
-      {
-          gost_compute_sum_and_hash (ctx, msg, sbox);
-          msg += GOSTHASH94_BLOCK_SIZE;
-          length -= GOSTHASH94_BLOCK_SIZE;
-      }
-    if (length)
-      {
-          /* save leftovers */
-          memcpy (ctx-&gt;message, msg, length);
-      }
+    MD_UPDATE(ctx, length, msg, COMPRESS, ctx-&gt;count++);
 }
 
 /**
@@ -369,21 +345,20 @@ gosthash94_write_digest (struct gosthash94_ctx *ctx,
 			 size_t length, uint8_t *result,
 			 const uint32_t sbox[4][256])
 {
-    unsigned index = ctx-&gt;length &amp; 31;
-    uint32_t msg32[8];
+    uint32_t msg32[GOSTHASH94_BLOCK_SIZE / 4];
 
     assert(length &lt;= GOSTHASH94_DIGEST_SIZE);
 
     /* pad the last block with zeroes and hash it */
-    if (index &gt; 0)
+    if (ctx-&gt;index &gt; 0)
       {
-          memset (ctx-&gt;message + index, 0, 32 - index);
-          gost_compute_sum_and_hash (ctx, ctx-&gt;message, sbox);
+          memset (ctx-&gt;block + ctx-&gt;index, 0, GOSTHASH94_BLOCK_SIZE - ctx-&gt;index);
+          gost_compute_sum_and_hash (ctx, ctx-&gt;block, sbox);
       }
 
     /* hash the message length and the sum */
-    msg32[0] = ctx-&gt;length &lt;&lt; 3;
-    msg32[1] = ctx-&gt;length &gt;&gt; 29;
+    msg32[0] = (ctx-&gt;count &lt;&lt; 8) | (ctx-&gt;index &lt;&lt; 3);
+    msg32[1] = ctx-&gt;count &gt;&gt; 24;
     memset (msg32 + 2, 0, sizeof (uint32_t) * 6);
 
     gost_block_compress (ctx, msg32, sbox);
diff --git a/gosthash94.h b/gosthash94.h
index dfa97f61de6e..0efd6412e6a9 100644
--- a/gosthash94.h
+++ b/gosthash94.h
@@ -87,8 +87,9 @@ struct gosthash94_ctx
 {
   uint32_t hash[8]; /* algorithm 256-bit state */
   uint32_t sum[8];  /* sum of processed message blocks */
-  uint64_t length;  /* number of processed bytes */
-  uint8_t message[GOSTHASH94_BLOCK_SIZE]; /* 256-bit buffer for leftovers */
+  uint64_t count;               /* Block count */
+  unsigned index;               /* Into buffer */
+  uint8_t block[GOSTHASH94_BLOCK_SIZE]; /* 256-bit buffer for leftovers */
 };
 #define gosthash94cp_ctx gosthash94_ctx
 
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190711184314</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-11 18:43:14-0400</timestampReceived><subject>[PATCH v2 4/6] Add GOST R 34.11-94 to nettle_hashes</subject><body>

Add entries for gosthash94 and gosthash94cp in nettle_hashes array.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 nettle-meta-hashes.c       | 2 ++
 testsuite/meta-hash-test.c | 2 ++
 2 files changed, 4 insertions(+)

diff --git a/nettle-meta-hashes.c b/nettle-meta-hashes.c
index 37552edec5ca..27b576cdc58c 100644
--- a/nettle-meta-hashes.c
+++ b/nettle-meta-hashes.c
@@ -38,6 +38,8 @@
 #include "nettle-meta.h"
 
 const struct nettle_hash * const _nettle_hashes[] = {
+  &amp;nettle_gosthash94,
+  &amp;nettle_gosthash94cp,
   &amp;nettle_md2,
   &amp;nettle_md4,
   &amp;nettle_md5,
diff --git a/testsuite/meta-hash-test.c b/testsuite/meta-hash-test.c
index 4754f66596ee..7d863a7c386d 100644
--- a/testsuite/meta-hash-test.c
+++ b/testsuite/meta-hash-test.c
@@ -5,6 +5,8 @@
 #include "sha3.h"
 
 const char* hashes[] = {
+  "gosthash94",
+  "gosthash94cp",
   "md2",
   "md4",
   "md5",
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190711184315</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-11 18:43:15-0400</timestampReceived><subject>[PATCH v2 5/6] Add HMAC functions for GOSTHASH94 and GOSTHASH94CP</subject><body>

GOST hash functions can be used to generate MAC using HMAC algorithm.
Add functions implementing HMAC with GOSTHASH94/GOSTHASH94CP.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in           |  5 +--
 hmac-gosthash94.c     | 79 +++++++++++++++++++++++++++++++++++++++++++
 hmac.h                | 37 ++++++++++++++++++++
 testsuite/hmac-test.c | 14 ++++++++
 4 files changed, 133 insertions(+), 2 deletions(-)
 create mode 100644 hmac-gosthash94.c

diff --git a/Makefile.in b/Makefile.in
index f583981c4367..0a1ca696dbaa 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -104,8 +104,9 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
 		 cmac.c cmac-aes128.c cmac-aes256.c \
 		 gost28147.c gosthash94.c gosthash94-meta.c \
-		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
-		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
+		 hmac.c hmac-gosthash94.c hmac-md5.c hmac-ripemd160.c \
+		 hmac-sha1.c hmac-sha224.c hmac-sha256.c hmac-sha384.c \
+		 hmac-sha512.c \
 		 knuth-lfib.c hkdf.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
diff --git a/hmac-gosthash94.c b/hmac-gosthash94.c
new file mode 100644
index 000000000000..66b62854d25e
--- /dev/null
+++ b/hmac-gosthash94.c
@@ -0,0 +1,79 @@
+/* hmac-gosthash94.c
+
+   HMAC-GOSTHASH94 message authentication code.
+
+   Copyright (C) 2016 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "hmac.h"
+
+void
+hmac_gosthash94_set_key(struct hmac_gosthash94_ctx *ctx,
+		    size_t key_length, const uint8_t *key)
+{
+  HMAC_SET_KEY(ctx, &amp;nettle_gosthash94, key_length, key);
+}
+
+void
+hmac_gosthash94_update(struct hmac_gosthash94_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  gosthash94_update(&amp;ctx-&gt;state, length, data);
+}
+
+void
+hmac_gosthash94_digest(struct hmac_gosthash94_ctx *ctx,
+		   size_t length, uint8_t *digest)
+{
+  HMAC_DIGEST(ctx, &amp;nettle_gosthash94, length, digest);
+}
+
+void
+hmac_gosthash94cp_set_key(struct hmac_gosthash94cp_ctx *ctx,
+		    size_t key_length, const uint8_t *key)
+{
+  HMAC_SET_KEY(ctx, &amp;nettle_gosthash94cp, key_length, key);
+}
+
+void
+hmac_gosthash94cp_update(struct hmac_gosthash94cp_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  gosthash94cp_update(&amp;ctx-&gt;state, length, data);
+}
+void
+hmac_gosthash94cp_digest(struct hmac_gosthash94cp_ctx *ctx,
+		   size_t length, uint8_t *digest)
+{
+  HMAC_DIGEST(ctx, &amp;nettle_gosthash94cp, length, digest);
+}
diff --git a/hmac.h b/hmac.h
index 40a8e77aab6d..d9ee3400108d 100644
--- a/hmac.h
+++ b/hmac.h
@@ -36,6 +36,7 @@
 
 #include "nettle-meta.h"
 
+#include "gosthash94.h"
 #include "md5.h"
 #include "ripemd160.h"
 #include "sha1.h"
@@ -68,6 +69,12 @@ extern "C" {
 #define hmac_sha512_set_key nettle_hmac_sha512_set_key
 #define hmac_sha512_update nettle_hmac_sha512_update
 #define hmac_sha512_digest nettle_hmac_sha512_digest
+#define hmac_gosthash94_set_key nettle_hmac_gosthash94_set_key
+#define hmac_gosthash94_update nettle_hmac_gosthash94_update
+#define hmac_gosthash94_digest nettle_hmac_gosthash94_digest
+#define hmac_gosthash94cp_set_key nettle_hmac_gosthash94cp_set_key
+#define hmac_gosthash94cp_update nettle_hmac_gosthash94cp_update
+#define hmac_gosthash94cp_digest nettle_hmac_gosthash94cp_digest
 
 void
 hmac_set_key(void *outer, void *inner, void *state,
@@ -203,6 +210,36 @@ void
 hmac_sha384_digest(struct hmac_sha512_ctx *ctx,
 		   size_t length, uint8_t *digest);
 
+/* hmac-gosthash94 */
+struct hmac_gosthash94_ctx HMAC_CTX(struct gosthash94_ctx);
+
+void
+hmac_gosthash94_set_key(struct hmac_gosthash94_ctx *ctx,
+			size_t key_length, const uint8_t *key);
+
+void
+hmac_gosthash94_update(struct hmac_gosthash94_ctx *ctx,
+		       size_t length, const uint8_t *data);
+
+  void
+hmac_gosthash94_digest(struct hmac_gosthash94_ctx *ctx,
+		       size_t length, uint8_t *digest);
+
+struct hmac_gosthash94cp_ctx HMAC_CTX(struct gosthash94cp_ctx);
+
+void
+hmac_gosthash94cp_set_key(struct hmac_gosthash94cp_ctx *ctx,
+			  size_t key_length, const uint8_t *key);
+
+void
+hmac_gosthash94cp_update(struct hmac_gosthash94cp_ctx *ctx,
+			 size_t length, const uint8_t *data);
+
+void
+hmac_gosthash94cp_digest(struct hmac_gosthash94cp_ctx *ctx,
+			 size_t length, uint8_t *digest);
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/hmac-test.c b/testsuite/hmac-test.c
index 9156cc406d2c..f009c8003d34 100644
--- a/testsuite/hmac-test.c
+++ b/testsuite/hmac-test.c
@@ -894,4 +894,18 @@ test_main(void)
 		 "b1ff68a1de45509fbe4da9a433922655"));
 
   /* Test case AUTH512-3 from same document seems broken. */
+
+  HMAC_TEST(gosthash94,
+	    SHEX("000102030405060708090a0b0c0d0e0f"
+		 "101112131415161718191a1b1c1d1e1f"),
+	    SHEX("0126bdb87800af214341456563780100"),
+	    SHEX("bfebe25f051bfef6ac858babb0abc409"
+		 "bfd2e334ab847bc0b0d056517c7d94c5"));
+
+  HMAC_TEST(gosthash94cp,
+	    SHEX("000102030405060708090a0b0c0d0e0f"
+		 "101112131415161718191a1b1c1d1e1f"),
+	    SHEX("0126bdb87800af214341456563780100"),
+	    SHEX("bad70b61c41095bc47e1141cfaed4272"
+		 "6a5ceebd62ce75dbbb9ad76cda9f72f7"));
 }
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190711184316</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-11 18:43:16-0400</timestampReceived><subject>[PATCH v2 6/6] Add PBKDF2 support for gosthash94cp</subject><body>

Russian technical comitee working on standartization of cryptography
algorithms has published the document describing usage of GOST R
34.11-94 hash function with PBKDF2 algorithm (MR 26.2.001-2012).
Add test vectors from that document and a special function implementing
Nettle interface for PBKDF2 using gosthash94cp.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in              |  3 ++-
 pbkdf2-hmac-gosthash94.c | 53 ++++++++++++++++++++++++++++++++++++++++
 pbkdf2.h                 |  7 ++++++
 testsuite/pbkdf2-test.c  | 24 ++++++++++++++++++
 4 files changed, 86 insertions(+), 1 deletion(-)
 create mode 100644 pbkdf2-hmac-gosthash94.c

diff --git a/Makefile.in b/Makefile.in
index 0a1ca696dbaa..d247f0988da1 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -114,7 +114,8 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 nettle-lookup-hash.c \
 		 nettle-meta-aeads.c nettle-meta-armors.c \
 		 nettle-meta-ciphers.c nettle-meta-hashes.c \
-		 pbkdf2.c pbkdf2-hmac-sha1.c pbkdf2-hmac-sha256.c \
+		 pbkdf2.c pbkdf2-hmac-gosthash94.c pbkdf2-hmac-sha1.c \
+		 pbkdf2-hmac-sha256.c \
 		 poly1305-aes.c poly1305-internal.c \
 		 realloc.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
diff --git a/pbkdf2-hmac-gosthash94.c b/pbkdf2-hmac-gosthash94.c
new file mode 100644
index 000000000000..bf61659433c3
--- /dev/null
+++ b/pbkdf2-hmac-gosthash94.c
@@ -0,0 +1,53 @@
+/* pbkdf2-hmac-gosthash94.c
+
+   PKCS #5 PBKDF2 used with HMAC-GOSTHASH94CP.
+
+   Copyright (C) 2016 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "pbkdf2.h"
+
+#include "hmac.h"
+
+void
+pbkdf2_hmac_gosthash94cp (size_t key_length, const uint8_t *key,
+		  unsigned iterations,
+		  size_t salt_length, const uint8_t *salt,
+		  size_t length, uint8_t *dst)
+{
+  struct hmac_gosthash94cp_ctx gosthash94cpctx;
+
+  hmac_gosthash94cp_set_key (&amp;gosthash94cpctx, key_length, key);
+  PBKDF2 (&amp;gosthash94cpctx, hmac_gosthash94cp_update, hmac_gosthash94cp_digest,
+	  GOSTHASH94CP_DIGEST_SIZE, iterations, salt_length, salt, length, dst);
+}
diff --git a/pbkdf2.h b/pbkdf2.h
index 7b1c4c9c1881..a36dfdbaa437 100644
--- a/pbkdf2.h
+++ b/pbkdf2.h
@@ -45,6 +45,7 @@ extern "C"
 #define pbkdf2 nettle_pbkdf2
 #define pbkdf2_hmac_sha1 nettle_pbkdf2_hmac_sha1
 #define pbkdf2_hmac_sha256 nettle_pbkdf2_hmac_sha256
+#define pbkdf2_hmac_gosthash94cp nettle_pbkdf2_hmac_gosthash94cp
 
 void
 pbkdf2 (void *mac_ctx,
@@ -78,6 +79,12 @@ pbkdf2_hmac_sha256 (size_t key_length, const uint8_t *key,
 		    size_t salt_length, const uint8_t *salt,
 		    size_t length, uint8_t *dst);
 
+void
+pbkdf2_hmac_gosthash94cp (size_t key_length, const uint8_t *key,
+			  unsigned iterations,
+			  size_t salt_length, const uint8_t *salt,
+			  size_t length, uint8_t *dst);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/pbkdf2-test.c b/testsuite/pbkdf2-test.c
index bb8da57fbb73..e64a20d09dea 100644
--- a/testsuite/pbkdf2-test.c
+++ b/testsuite/pbkdf2-test.c
@@ -28,6 +28,7 @@ test_main (void)
   struct hmac_sha1_ctx sha1ctx;
   struct hmac_sha256_ctx sha256ctx;
   struct hmac_sha512_ctx sha512ctx;
+  struct hmac_gosthash94cp_ctx gosthash94cpctx;
 
   /* Test vectors for PBKDF2 from RFC 6070. */
 
@@ -110,4 +111,27 @@ test_main (void)
   PBKDF2_HMAC_TEST(pbkdf2_hmac_sha256, LDATA("passwd"), 1, LDATA("salt"),
 		   SHEX("55ac046e56e3089fec1691c22544b605"));
 
+  /* From TC26 document, MR 26.2.001-2012 */
+
+  hmac_gosthash94cp_set_key (&amp;gosthash94cpctx, LDATA("password"));
+  PBKDF2_TEST (&amp;gosthash94cpctx, hmac_gosthash94cp_update, hmac_gosthash94cp_digest,
+	       GOSTHASH94CP_DIGEST_SIZE, 1, LDATA("salt"),
+	       SHEX("7314e7c04fb2e662c543674253f68bd0b73445d07f241bed872882da21662d58"));
+
+  PBKDF2_TEST (&amp;gosthash94cpctx, hmac_gosthash94cp_update, hmac_gosthash94cp_digest,
+	       GOSTHASH94CP_DIGEST_SIZE, 4096, LDATA("salt"),
+	       SHEX("1f1829a94bdff5be10d0aeb36af498e7a97467f3b31116a5a7c1afff9deadafe"));
+
+  hmac_gosthash94cp_set_key (&amp;gosthash94cpctx, LDATA("passwordPASSWORDpassword"));
+  PBKDF2_TEST (&amp;gosthash94cpctx, hmac_gosthash94cp_update, hmac_gosthash94cp_digest,
+	       GOSTHASH94CP_DIGEST_SIZE, 4096, LDATA("saltSALTsaltSALTsaltSALTsaltSALTsalt"),
+	       SHEX("788358c69cb2dbe251a7bb17d5f4241f265a792a35becde8d56f326b49c85047b7638acb4764b1fd"));
+
+  hmac_gosthash94cp_set_key (&amp;gosthash94cpctx, LDATA("pass\0word"));
+  PBKDF2_TEST (&amp;gosthash94cpctx, hmac_gosthash94cp_update, hmac_gosthash94cp_digest,
+	       GOSTHASH94CP_DIGEST_SIZE, 4096, LDATA("sa\0lt"),
+	       SHEX("43e06c5590b08c0225242373127edf9c8e9c3291"));
+
+  PBKDF2_HMAC_TEST (pbkdf2_hmac_gosthash94cp, LDATA("password"), 1, LDATA("salt"),
+	       SHEX("7314e7c04fb2e662c543674253f68bd0b73445d07f241bed872882da21662d58"));
 }
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190712161035</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-12 16:10:35-0400</timestampReceived><subject>[PATCH v2 0/3] Add support for deterministic DSA/ECDSA (RFC 6979)</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

It turned out that the initial version of _dsa_compute_k was not
constant time with the input message.  In this version it is checked
with a valgrind-based check.

Also the ecdsa-sign-deterministic test has been reorganized using a
similar abstraction to struct nettle_mac in testutils.h.

Daiki Ueno (3):
  dsa: Add a function to find k deterministically
  ecdsa: Add support for deterministic signature generation
  dsa: Add support for deterministic signature generation

 Makefile.in                               |   6 +-
 dsa-compute-k.c                           | 179 +++++++++++++++++
 dsa-compute-k.h                           |  63 ++++++
 dsa-sign-deterministic.c                  | 107 ++++++++++
 dsa.h                                     |  12 ++
 ecdsa-sign-deterministic.c                |  74 +++++++
 ecdsa.h                                   |  11 ++
 testsuite/.gitignore                      |   2 +
 testsuite/.test-rules.make                |   6 +
 testsuite/Makefile.in                     |   4 +-
 testsuite/dsa-compute-k-test.c            | 127 ++++++++++++
 testsuite/dsa-test.c                      | 148 +++++++++++++-
 testsuite/ecdsa-sign-deterministic-test.c | 230 ++++++++++++++++++++++
 13 files changed, 965 insertions(+), 4 deletions(-)
 create mode 100644 dsa-compute-k.c
 create mode 100644 dsa-compute-k.h
 create mode 100644 dsa-sign-deterministic.c
 create mode 100644 ecdsa-sign-deterministic.c
 create mode 100644 testsuite/dsa-compute-k-test.c
 create mode 100644 testsuite/ecdsa-sign-deterministic-test.c

-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190712161036</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-12 16:10:36-0400</timestampReceived><subject>[PATCH v2 1/3] dsa: Add a function to find k deterministically</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

This adds the _dsa_compute_k function that generates DSA/ECDSA k value
from the private key and the hashed message, according to RFC 6979.

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 Makefile.in                    |   5 +-
 dsa-compute-k.c                | 179 +++++++++++++++++++++++++++++++++
 dsa-compute-k.h                |  63 ++++++++++++
 testsuite/.gitignore           |   1 +
 testsuite/.test-rules.make     |   3 +
 testsuite/Makefile.in          |   3 +-
 testsuite/dsa-compute-k-test.c | 127 +++++++++++++++++++++++
 7 files changed, 378 insertions(+), 3 deletions(-)
 create mode 100644 dsa-compute-k.c
 create mode 100644 dsa-compute-k.h
 create mode 100644 testsuite/dsa-compute-k-test.c

diff --git a/Makefile.in b/Makefile.in
index b54e64b0..36b2a182 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -187,7 +187,8 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  eddsa-compress.c eddsa-decompress.c eddsa-expand.c \
 		  eddsa-hash.c eddsa-pubkey.c eddsa-sign.c eddsa-verify.c \
 		  ed25519-sha512-pubkey.c \
-		  ed25519-sha512-sign.c ed25519-sha512-verify.c
+		  ed25519-sha512-sign.c ed25519-sha512-verify.c \
+		  dsa-compute-k.c
 
 OPT_SOURCES = fat-x86_64.c fat-arm.c mini-gmp.c
 
@@ -237,7 +238,7 @@ DISTFILES = $(SOURCES) $(HEADERS) getopt.h getopt_int.h \
 	ctr-internal.h chacha-internal.h sha3-internal.h \
 	salsa20-internal.h umac-internal.h hogweed-internal.h \
 	rsa-internal.h pkcs1-internal.h dsa-internal.h eddsa-internal.h \
-	gmp-glue.h ecc-internal.h fat-setup.h \
+	gmp-glue.h ecc-internal.h fat-setup.h dsa-compute-k.h \
 	mini-gmp.h asm.m4 \
 	nettle.texinfo nettle.info nettle.html nettle.pdf sha-example.c
 
diff --git a/dsa-compute-k.c b/dsa-compute-k.c
new file mode 100644
index 00000000..105c500b
--- /dev/null
+++ b/dsa-compute-k.c
@@ -0,0 +1,179 @@
+/* dsa-compute-k.c
+
+   Deterministically find k value for ECDSA/DSA (RFC-6979).
+
+   Copyright (C) 2019 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "dsa-compute-k.h"
+
+#include "gmp-glue.h"
+#include "nettle-internal.h"
+#include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
+
+#define MIN(x, y) ((x) &lt; (y) ? (x) : (y))
+#define MAX(x, y) ((x) &gt; (y) ? (x) : (y))
+
+void
+_dsa_compute_k (mp_limb_t *k,
+		mp_size_t qn,
+		const mp_limb_t *q,
+		const mp_limb_t *x,
+		void *mac_ctx,
+		nettle_hash_update_func *set_key,
+		nettle_hash_update_func *update,
+		nettle_hash_digest_func *digest,
+		size_t digest_length,
+		const uint8_t *digest_message)
+{
+  TMP_DECL(V, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);
+  TMP_DECL(K, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);
+  TMP_GMP_DECL(xp, uint8_t);
+  TMP_GMP_DECL(hp, uint8_t);
+  TMP_GMP_DECL(tp, uint8_t);
+  TMP_GMP_DECL(h, mp_limb_t);
+  mp_size_t hn = (digest_length + sizeof(mp_limb_t) - 1) / sizeof(mp_limb_t);
+  mp_bitcnt_t q_bits = mpn_sizeinbase (q, qn, 2);
+  mp_bitcnt_t h_bits = digest_length * 8;
+  size_t nbytes = (q_bits + 7) / 8;
+  const uint8_t c0 = 0x00;
+  const uint8_t c1 = 0x01;
+  mp_limb_t cy;
+
+  TMP_ALLOC(V, digest_length);
+  TMP_ALLOC(K, digest_length);
+  TMP_GMP_ALLOC(xp, nbytes);
+  TMP_GMP_ALLOC(hp, nbytes);
+  TMP_GMP_ALLOC(tp, nbytes);
+  TMP_GMP_ALLOC(h, MAX (qn, hn) * sizeof(mp_limb_t));
+
+  /* int2octets(x) */
+  mpn_get_base256 (xp, nbytes, x, qn);
+
+  /* bits2octets(h) */
+  mpn_set_base256 (h, hn, digest_message, digest_length);
+
+  if (hn &lt; qn)
+    /* qlen &gt; blen: add zero bits to the left */
+    mpn_zero (&amp;h[hn], qn - hn);
+  else if (h_bits &gt; q_bits)
+    {
+      /* qlen &lt; blen: keep the leftmost qlen bits.  We do this in 2
+       * steps because mpn_rshift only accepts shift count in the
+       * range 1 to mp_bits_per_limb-1.
+       */
+      mp_bitcnt_t shift = h_bits - q_bits;
+
+      if (shift / GMP_LIMB_BITS &gt; 0)
+	{
+	  mpn_copyi (h, &amp;h[shift / GMP_LIMB_BITS], qn);
+	  hn -= shift / GMP_LIMB_BITS;
+	}
+
+      if (shift % GMP_LIMB_BITS &gt; 0)
+	mpn_rshift (h, h, hn, shift % GMP_LIMB_BITS);
+  }
+
+  cy = mpn_sub_n (h, h, q, qn);
+  cy = cnd_add_n (cy, h, q, qn);
+  mpn_get_base256 (hp, nbytes, h, qn);
+
+  /* Step b */
+  memset (V, c1, digest_length);
+
+  /* Step c */
+  memset (K, c0, digest_length);
+  set_key (mac_ctx, digest_length, K);
+
+  /* Step d */
+  update (mac_ctx, digest_length, V);
+  update (mac_ctx, 1, &amp;c0);
+  update (mac_ctx, nbytes, xp);
+  update (mac_ctx, nbytes, hp);
+  digest (mac_ctx, digest_length, K);
+  set_key (mac_ctx, digest_length, K);
+
+  /* Step e */
+  update (mac_ctx, digest_length, V);
+  digest (mac_ctx, digest_length, V);
+
+  /* Step f */
+  update (mac_ctx, digest_length, V);
+  update (mac_ctx, 1, &amp;c1);
+  update (mac_ctx, nbytes, xp);
+  update (mac_ctx, nbytes, hp);
+  digest (mac_ctx, digest_length, K);
+  set_key (mac_ctx, digest_length, K);
+
+  /* Step g */
+  update (mac_ctx, digest_length, V);
+  digest (mac_ctx, digest_length, V);
+
+  /* Step h */
+  for (;;)
+    {
+      /* Step 1 */
+      size_t tlen = 0;
+
+      /* Step 2 */
+      while (tlen &lt; nbytes)
+	{
+	  size_t remaining = MIN(nbytes - tlen, digest_length);
+	  update (mac_ctx, digest_length, V);
+	  digest (mac_ctx, digest_length, V);
+	  memcpy (&amp;tp[tlen], V, remaining);
+	  tlen += remaining;
+	}
+
+      /* Step 3 */
+      mpn_set_base256 (k, qn, tp, tlen);
+      if (tlen * 8 &gt; q_bits)
+	mpn_rshift (k, k, qn, tlen * 8 - q_bits);
+      /* Check if k is in [1,q-1] */
+      if (!mpn_zero_p (k, qn) &amp;&amp; mpn_cmp (k, q, qn) &lt; 0)
+	break;
+
+      update (mac_ctx, digest_length, V);
+      update (mac_ctx, 1, &amp;c0);
+      digest (mac_ctx, digest_length, K);
+      set_key (mac_ctx, digest_length, K);
+      update (mac_ctx, digest_length, V);
+      digest (mac_ctx, digest_length, V);
+    }
+
+  TMP_GMP_FREE(xp);
+  TMP_GMP_FREE(hp);
+  TMP_GMP_FREE(tp);
+  TMP_GMP_FREE(h);
+}
diff --git a/dsa-compute-k.h b/dsa-compute-k.h
new file mode 100644
index 00000000..3433e2fb
--- /dev/null
+++ b/dsa-compute-k.h
@@ -0,0 +1,63 @@
+/* dsa-compute-k.h
+
+   Deterministically find k value for ECDSA/DSA (RFC-6979).
+
+   Copyright (C) 2019 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_DSA_COMPUTE_K_H_INCLUDED
+#define NETTLE_DSA_COMPUTE_K_H_INCLUDED
+
+#include "nettle-types.h"
+#include "bignum.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Namespace mangling */
+#define _dsa_compute_k _nettle_dsa_compute_k
+
+void
+_dsa_compute_k (mp_limb_t *k,
+		mp_size_t qn,
+		const mp_limb_t *q,
+		const mp_limb_t *x,
+		void *mac_ctx,
+		nettle_hash_update_func *set_key,
+		nettle_hash_update_func *update,
+		nettle_hash_digest_func *digest,
+		size_t digest_length,
+		const uint8_t *digest_message);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_DSA_COMPUTE_K_H_INCLUDED */
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index 066bcee2..40fbe046 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -22,6 +22,7 @@
 /des-test
 /des3-test
 /dlopen-test
+/dsa-compute-k-test
 /dsa-keygen-test
 /dsa-test
 /eax-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index efb7df3c..61080010 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -280,6 +280,9 @@ eddsa-verify-test$(EXEEXT): eddsa-verify-test.$(OBJEXT)
 ed25519-test$(EXEEXT): ed25519-test.$(OBJEXT)
 	$(LINK) ed25519-test.$(OBJEXT) $(TEST_OBJS) -o ed25519-test$(EXEEXT)
 
+dsa-compute-k-test$(EXEEXT): dsa-compute-k-test.$(OBJEXT)
+	$(LINK) dsa-compute-k-test.$(OBJEXT) $(TEST_OBJS) -o dsa-compute-k-test$(EXEEXT)
+
 sha1-huge-test$(EXEEXT): sha1-huge-test.$(OBJEXT)
 	$(LINK) sha1-huge-test.$(OBJEXT) $(TEST_OBJS) -o sha1-huge-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index f8f85701..e6acd788 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -52,7 +52,8 @@ TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
 		     ecdsa-sign-test.c ecdsa-verify-test.c \
 		     ecdsa-keygen-test.c ecdh-test.c \
 		     eddsa-compress-test.c eddsa-sign-test.c \
-		     eddsa-verify-test.c ed25519-test.c
+		     eddsa-verify-test.c ed25519-test.c \
+		     dsa-compute-k-test.c
 
 TS_SOURCES = $(TS_NETTLE_SOURCES) $(TS_HOGWEED_SOURCES)
 CXX_SOURCES = cxx-test.cxx
diff --git a/testsuite/dsa-compute-k-test.c b/testsuite/dsa-compute-k-test.c
new file mode 100644
index 00000000..3df9b2e8
--- /dev/null
+++ b/testsuite/dsa-compute-k-test.c
@@ -0,0 +1,127 @@
+#include "testutils.h"
+#include "dsa-compute-k.h"
+#include "hmac.h"
+
+#if HAVE_VALGRIND_MEMCHECK_H
+# include &lt;valgrind/memcheck.h&gt;
+
+static nettle_hash_digest_func *digest_func;
+
+static void
+digest_func_for_test(void *ctx,
+		     size_t length, uint8_t *dst)
+{
+  digest_func (ctx, length, dst);
+  VALGRIND_MAKE_MEM_DEFINED (dst, length);
+}
+
+static void
+_dsa_compute_k_for_test (mp_limb_t *k,
+			 mp_size_t qn,
+			 const mp_limb_t *q,
+			 const mp_limb_t *x,
+			 void *mac_ctx,
+			 nettle_hash_update_func *set_key,
+			 nettle_hash_update_func *update,
+			 nettle_hash_digest_func *digest,
+			 size_t digest_length,
+			 const uint8_t *digest_message)
+{
+  /* Makes valgrind trigger on any branches depending on the input
+     data. */
+  VALGRIND_MAKE_MEM_UNDEFINED (x, qn * sizeof(mp_limb_t));
+  VALGRIND_MAKE_MEM_UNDEFINED (digest_message, digest_length);
+
+  digest_func = digest;
+  _dsa_compute_k (k, qn, q, x, mac_ctx, set_key, update, digest_func_for_test,
+		  digest_length, digest_message);
+
+  VALGRIND_MAKE_MEM_DEFINED (x, qn * sizeof(mp_limb_t));
+  VALGRIND_MAKE_MEM_DEFINED (digest_message, digest_length);
+  VALGRIND_MAKE_MEM_DEFINED (k, qn * sizeof(mp_limb_t));
+}
+#else
+#define _dsa_compute_k_test _dsa_compute_k
+#endif
+
+static void
+test_dsa_compute_k(const char *sq,
+		   /* Private key */
+		   const char *sx,
+		   /* HMAC */
+		   void *mac_ctx,
+		   nettle_hash_update_func *set_key,
+		   nettle_hash_update_func *update,
+		   nettle_hash_digest_func *digest,
+		   /* Hash */
+		   const struct tstring *h,
+		   /* Expected k */
+		   const char *sk)
+{
+  mpz_t k;
+  mpz_t q;
+  mpz_t x;
+  mpz_t e;
+
+  mpz_init (k);
+  mpz_init_set_str (q, sq, 16);
+  mpz_init_set_str (x, sx, 16);
+  mpz_init_set_str (e, sk, 16);
+
+  _dsa_compute_k_for_test (mpz_limbs_write (k, mpz_size (q)),
+			   mpz_size (q), mpz_limbs_read (q), mpz_limbs_read (x),
+			   mac_ctx, set_key, update, digest,
+			   h-&gt;length, h-&gt;data);
+
+  mpz_limbs_finish (k, mpz_size (q));
+
+  if (mpz_cmp (e, k) != 0)
+    {
+      fprintf (stderr, "k = ");
+      mpz_out_str (stderr, 16, k);
+      fprintf (stderr, "\n");
+      fprintf (stderr, "e = ");
+      mpz_out_str (stderr, 16, e);
+      fprintf (stderr, "\n");
+      abort ();
+    }
+
+  mpz_clear (q);
+  mpz_clear (x);
+  mpz_clear (k);
+  mpz_clear (e);
+}
+
+void
+test_main (void)
+{
+  struct hmac_sha256_ctx hmac;
+  struct sha256_ctx hash;
+  uint8_t digest[SHA256_DIGEST_SIZE];
+
+  sha256_init (&amp;hash);
+  sha256_update (&amp;hash, 6, (const uint8_t *)"sample");
+  sha256_digest (&amp;hash, sizeof(digest), digest);
+
+  /* Test vectors from RFC 6979 */
+  test_dsa_compute_k ("996f967f6c8e388d9e28d01e205fba957a5698b1",
+		      "411602cb19a6ccc34494d79d98ef1e7ed5af25f7",
+		      &amp;hmac,
+		      (nettle_hash_update_func *)hmac_sha256_set_key,
+		      (nettle_hash_update_func *)hmac_sha256_update,
+		      (nettle_hash_digest_func *)hmac_sha256_digest,
+		      tstring_data (SHA256_DIGEST_SIZE, digest),
+		      "519ba0546d0c39202a7d34d7dfa5e760b318bcfb");
+
+  test_dsa_compute_k ("f2c3119374ce76c9356990b465374a17f23f9ed3"
+		      "5089bd969f61c6dde9998c1f",
+		      "69c7548c21d0dfea6b9a51c9ead4e27c33d3b3f1"
+		      "80316e5bcab92c933f0e4dbc",
+		      &amp;hmac,
+		      (nettle_hash_update_func *)hmac_sha256_set_key,
+		      (nettle_hash_update_func *)hmac_sha256_update,
+		      (nettle_hash_digest_func *)hmac_sha256_digest,
+		      tstring_data (SHA256_DIGEST_SIZE, digest),
+		      "8926a27c40484216f052f4427cfd5647338b7b39"
+		      "39bc6573af4333569d597c52");
+}
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190712161037</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-12 16:10:37-0400</timestampReceived><subject>[PATCH v2 2/3] ecdsa: Add support for deterministic signature generation</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

This adds the ecdsa_sign_deterministic function that calculates
signature without requiring entropy source.  Instead, it uses the
deterministic construction described in RFC 6979, through
_dsa_compute_k.

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 Makefile.in                               |   2 +-
 ecdsa-sign-deterministic.c                |  74 +++++++
 ecdsa.h                                   |  11 ++
 testsuite/.gitignore                      |   1 +
 testsuite/.test-rules.make                |   3 +
 testsuite/Makefile.in                     |   3 +-
 testsuite/ecdsa-sign-deterministic-test.c | 230 ++++++++++++++++++++++
 7 files changed, 322 insertions(+), 2 deletions(-)
 create mode 100644 ecdsa-sign-deterministic.c
 create mode 100644 testsuite/ecdsa-sign-deterministic-test.c

diff --git a/Makefile.in b/Makefile.in
index 36b2a182..27cbf93f 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -188,7 +188,7 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  eddsa-hash.c eddsa-pubkey.c eddsa-sign.c eddsa-verify.c \
 		  ed25519-sha512-pubkey.c \
 		  ed25519-sha512-sign.c ed25519-sha512-verify.c \
-		  dsa-compute-k.c
+		  dsa-compute-k.c ecdsa-sign-deterministic.c
 
 OPT_SOURCES = fat-x86_64.c fat-arm.c mini-gmp.c
 
diff --git a/ecdsa-sign-deterministic.c b/ecdsa-sign-deterministic.c
new file mode 100644
index 00000000..11eef5f6
--- /dev/null
+++ b/ecdsa-sign-deterministic.c
@@ -0,0 +1,74 @@
+/* ecdsa-sign-deterministic.c
+
+   Copyright (C) 2013 Niels Möller
+   Copyright (C) 2019 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+/* Development of Nettle's ECC support was funded by the .SE Internet Fund. */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include "ecdsa.h"
+#include "ecc-internal.h"
+#include "nettle-internal.h"
+#include "dsa-compute-k.h"
+
+void
+ecdsa_sign_deterministic (const struct ecc_scalar *key,
+			  void *mac_ctx,
+			  nettle_hash_update_func *set_key,
+			  nettle_hash_update_func *update,
+			  nettle_hash_digest_func *digest,
+			  size_t digest_length,
+			  const uint8_t *digest_message,
+			  struct dsa_signature *signature)
+{
+  /* At most 936 bytes. */
+  TMP_DECL(k, mp_limb_t, ECC_MAX_SIZE + ECC_ECDSA_SIGN_ITCH (ECC_MAX_SIZE));
+  mp_limb_t size = key-&gt;ecc-&gt;p.size;
+  mp_limb_t *rp = mpz_limbs_write (signature-&gt;r, size);
+  mp_limb_t *sp = mpz_limbs_write (signature-&gt;s, size);
+
+  TMP_ALLOC (k, size + ECC_ECDSA_SIGN_ITCH (size));
+
+  _dsa_compute_k (k, key-&gt;ecc-&gt;q.size, key-&gt;ecc-&gt;q.m, key-&gt;p,
+		  mac_ctx, set_key, update, digest,
+		  digest_length, digest_message);
+  ecc_ecdsa_sign (key-&gt;ecc, key-&gt;p, k, digest_length, digest_message,
+		  rp, sp, k + size);
+  mpz_limbs_finish (signature-&gt;r, size);
+  mpz_limbs_finish (signature-&gt;s, size);
+
+  assert (!(mpz_sgn (signature-&gt;r) == 0 || mpz_sgn (signature-&gt;s) == 0));
+}
diff --git a/ecdsa.h b/ecdsa.h
index 693aca8b..7d590367 100644
--- a/ecdsa.h
+++ b/ecdsa.h
@@ -43,6 +43,7 @@ extern "C" {
 
 /* Name mangling */
 #define ecdsa_sign nettle_ecdsa_sign
+#define ecdsa_sign_deterministic nettle_ecdsa_sign_deterministic
 #define ecdsa_verify nettle_ecdsa_verify
 #define ecdsa_generate_keypair nettle_ecdsa_generate_keypair
 #define ecc_ecdsa_sign nettle_ecc_ecdsa_sign
@@ -61,6 +62,16 @@ ecdsa_sign (const struct ecc_scalar *key,
 	    const uint8_t *digest,
 	    struct dsa_signature *signature);
 
+void
+ecdsa_sign_deterministic (const struct ecc_scalar *key,
+			  void *mac_ctx,
+			  nettle_hash_update_func *set_key,
+			  nettle_hash_update_func *update,
+			  nettle_hash_digest_func *digest,
+			  size_t digest_length,
+			  const uint8_t *digest_message,
+			  struct dsa_signature *signature);
+
 int
 ecdsa_verify (const struct ecc_point *pub,
 	      size_t length, const uint8_t *digest,
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index 40fbe046..fb2800e8 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -36,6 +36,7 @@
 /ecc-sqrt-test
 /ecdh-test
 /ecdsa-keygen-test
+/ecdsa-sign-deterministic-test
 /ecdsa-sign-test
 /ecdsa-verify-test
 /ed25519-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 61080010..8f796efd 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -283,6 +283,9 @@ ed25519-test$(EXEEXT): ed25519-test.$(OBJEXT)
 dsa-compute-k-test$(EXEEXT): dsa-compute-k-test.$(OBJEXT)
 	$(LINK) dsa-compute-k-test.$(OBJEXT) $(TEST_OBJS) -o dsa-compute-k-test$(EXEEXT)
 
+ecdsa-sign-deterministic-test$(EXEEXT): ecdsa-sign-deterministic-test.$(OBJEXT)
+	$(LINK) ecdsa-sign-deterministic-test.$(OBJEXT) $(TEST_OBJS) -o ecdsa-sign-deterministic-test$(EXEEXT)
+
 sha1-huge-test$(EXEEXT): sha1-huge-test.$(OBJEXT)
 	$(LINK) sha1-huge-test.$(OBJEXT) $(TEST_OBJS) -o sha1-huge-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index e6acd788..8bdb8ea6 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -53,7 +53,8 @@ TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
 		     ecdsa-keygen-test.c ecdh-test.c \
 		     eddsa-compress-test.c eddsa-sign-test.c \
 		     eddsa-verify-test.c ed25519-test.c \
-		     dsa-compute-k-test.c
+		     dsa-compute-k-test.c \
+		     ecdsa-sign-deterministic-test.c
 
 TS_SOURCES = $(TS_NETTLE_SOURCES) $(TS_HOGWEED_SOURCES)
 CXX_SOURCES = cxx-test.cxx
diff --git a/testsuite/ecdsa-sign-deterministic-test.c b/testsuite/ecdsa-sign-deterministic-test.c
new file mode 100644
index 00000000..6e5e441e
--- /dev/null
+++ b/testsuite/ecdsa-sign-deterministic-test.c
@@ -0,0 +1,230 @@
+#include "testutils.h"
+#include "hmac.h"
+#include "nettle-internal.h"
+
+/* This is a identical to struct nettle_mac defined in testutils.h,
+ * except that set_key is defined as a different type. */
+struct nettle_hmac
+{
+  const char *name;
+
+  /* Size of the context struct */
+  unsigned context_size;
+
+  /* Size of digests */
+  unsigned digest_size;
+
+  /* Suggested key size; other sizes are sometimes possible. */
+  unsigned key_size;
+
+  /* HMAC require an additional key_length argument to set_key, which
+   * makes the type incompatible with nettle_set_key_func. */
+  nettle_hash_update_func *set_key;
+  nettle_hash_update_func *update;
+  nettle_hash_digest_func *digest;
+};
+
+#undef _NETTLE_HMAC
+#define _NETTLE_HMAC(name, NAME) {			\
+  #name,						\
+  sizeof(struct hmac_##name##_ctx),			\
+  NAME##_DIGEST_SIZE,					\
+  NAME##_DIGEST_SIZE,					\
+  (nettle_hash_update_func *)hmac_##name##_set_key,	\
+  (nettle_hash_update_func *)hmac_##name##_update,	\
+  (nettle_hash_digest_func *)hmac_##name##_digest,	\
+}
+
+static void
+test_ecdsa (const struct ecc_curve *ecc,
+	    /* Private key */
+	    const char *sz,
+	    /* HMAC */
+	    void *hmac_ctx,
+	    const struct nettle_hmac *hmac,
+	    /* Hash */
+	    const struct tstring *h,
+	    /* Expected signature */
+	    const char *r, const char *s)
+{
+  struct ecc_scalar key;
+  struct dsa_signature ref;
+  struct dsa_signature signature;
+  mpz_t z;
+
+  dsa_signature_init (&amp;ref);
+  dsa_signature_init (&amp;signature);
+
+  mpz_init_set_str (z, sz, 16);
+
+  ecc_scalar_init (&amp;key, ecc);
+  ecc_scalar_set (&amp;key, z);
+
+  ecdsa_sign_deterministic (&amp;key,
+			    hmac_ctx,
+			    hmac-&gt;set_key,
+			    hmac-&gt;update,
+			    hmac-&gt;digest,
+			    h-&gt;length, h-&gt;data, &amp;signature);
+
+  mpz_set_str (ref.r, r, 16);
+  mpz_set_str (ref.s, s, 16);
+
+  if (mpz_limbs_cmp (ref.r, mpz_limbs_read (signature.r), ecc-&gt;p.size) != 0
+      || mpz_limbs_cmp (ref.s, mpz_limbs_read (signature.s), ecc-&gt;p.size) != 0)
+    {
+      fprintf (stderr, "_ecdsa_sign failed, bit_size = %u, hmac_%s\n",
+	       ecc-&gt;p.bit_size, hmac-&gt;name);
+      fprintf (stderr, "r     = ");
+      write_mpn (stderr, 16, mpz_limbs_read (signature.r), ecc-&gt;p.size);
+      fprintf (stderr, "\ns     = ");
+      write_mpn (stderr, 16, mpz_limbs_read (signature.s), ecc-&gt;p.size);
+      fprintf (stderr, "\nref.r = ");
+      mpz_out_str (stderr, 16, ref.r);
+      fprintf (stderr, "\nref.s = ");
+      mpz_out_str (stderr, 16, ref.s);
+      fprintf (stderr, "\n");
+      abort();
+    }
+
+  dsa_signature_clear (&amp;ref);
+  dsa_signature_clear (&amp;signature);
+  ecc_scalar_clear (&amp;key);
+  mpz_clear (z);
+}
+
+static const struct nettle_hmac hmac_sha1 = _NETTLE_HMAC(sha1, SHA1);
+static const struct nettle_hmac hmac_sha224 = _NETTLE_HMAC(sha224, SHA224);
+static const struct nettle_hmac hmac_sha256 = _NETTLE_HMAC(sha256, SHA256);
+static const struct nettle_hmac hmac_sha384 = _NETTLE_HMAC(sha384, SHA384);
+static const struct nettle_hmac hmac_sha512 = _NETTLE_HMAC(sha512, SHA512);
+
+static struct
+{
+  const struct ecc_curve *ecc;
+  const struct nettle_hash *hash;
+  const struct nettle_hmac *hmac;
+  const char *m;
+  const char *z;
+  const char *r;
+  const char *s;
+} tests[] = {
+  /* Test vectors from RFC6979 */
+  { &amp;_nettle_secp_192r1, &amp;nettle_sha1, &amp;hmac_sha1,
+    "sample",
+    "6fab034934e4c0fc9ae67f5b5659a9d7d1fefd187ee09fd4",
+    "98C6BD12B23EAF5E2A2045132086BE3EB8EBD62ABF6698FF",
+    "57A22B07DEA9530F8DE9471B1DC6624472E8E2844BC25B64" },
+  { &amp;_nettle_secp_192r1, &amp;nettle_sha224, &amp;hmac_sha224,
+    "sample",
+    "6fab034934e4c0fc9ae67f5b5659a9d7d1fefd187ee09fd4",
+    "a1f00dad97aeec91c95585f36200c65f3c01812aa60378f5",
+    "e07ec1304c7c6c9debbe980b9692668f81d4de7922a0f97a" },
+  { &amp;_nettle_secp_192r1, &amp;nettle_sha256, &amp;hmac_sha256,
+    "sample",
+    "6fab034934e4c0fc9ae67f5b5659a9d7d1fefd187ee09fd4",
+    "4b0b8ce98a92866a2820e20aa6b75b56382e0f9bfd5ecb55",
+    "ccdb006926ea9565cbadc840829d8c384e06de1f1e381b85" },
+  { &amp;_nettle_secp_192r1, &amp;nettle_sha384, &amp;hmac_sha384,
+    "sample",
+    "6fab034934e4c0fc9ae67f5b5659a9d7d1fefd187ee09fd4",
+    "da63bf0b9abcf948fbb1e9167f136145f7a20426dcc287d5",
+    "c3aa2c960972bd7a2003a57e1c4c77f0578f8ae95e31ec5e" },
+  { &amp;_nettle_secp_192r1, &amp;nettle_sha512, &amp;hmac_sha512,
+    "sample",
+    "6fab034934e4c0fc9ae67f5b5659a9d7d1fefd187ee09fd4",
+    "4d60c5ab1996bd848343b31c00850205e2ea6922dac2e4b8",
+    "3f6e837448f027a1bf4b34e796e32a811cbb4050908d8f67" },
+  { &amp;_nettle_secp_224r1, &amp;nettle_sha1, &amp;hmac_sha1,
+    "sample",
+    "f220266e1105bfe3083e03ec7a3a654651f45e37167e88600bf257c1",
+    "22226f9d40a96e19c4a301ce5b74b115303c0f3a4fd30fc257fb57ac",
+    "66d1cdd83e3af75605dd6e2feff196d30aa7ed7a2edf7af475403d69" },
+  { &amp;_nettle_secp_224r1, &amp;nettle_sha224, &amp;hmac_sha224,
+    "sample",
+    "f220266e1105bfe3083e03ec7a3a654651f45e37167e88600bf257c1",
+    "1cdfe6662dde1e4a1ec4cdedf6a1f5a2fb7fbd9145c12113e6abfd3e",
+    "a6694fd7718a21053f225d3f46197ca699d45006c06f871808f43ebc" },
+  { &amp;_nettle_secp_224r1, &amp;nettle_sha256, &amp;hmac_sha256,
+    "sample",
+    "f220266e1105bfe3083e03ec7a3a654651f45e37167e88600bf257c1",
+    "61aa3da010e8e8406c656bc477a7a7189895e7e840cdfe8ff42307ba",
+    "bc814050dab5d23770879494f9e0a680dc1af7161991bde692b10101" },
+  { &amp;_nettle_secp_224r1, &amp;nettle_sha384, &amp;hmac_sha384,
+    "sample",
+    "f220266e1105bfe3083e03ec7a3a654651f45e37167e88600bf257c1",
+    "0b115e5e36f0f9ec81f1325a5952878d745e19d7bb3eabfaba77e953",
+    "830f34ccdfe826ccfdc81eb4129772e20e122348a2bbd889a1b1af1d" },
+  { &amp;_nettle_secp_224r1, &amp;nettle_sha512, &amp;hmac_sha512,
+    "sample",
+    "f220266e1105bfe3083e03ec7a3a654651f45e37167e88600bf257c1",
+    "074bd1d979d5f32bf958ddc61e4fb4872adcafeb2256497cdac30397",
+    "a4ceca196c3d5a1ff31027b33185dc8ee43f288b21ab342e5d8eb084" },
+  { &amp;_nettle_secp_256r1, &amp;nettle_sha1, &amp;hmac_sha1,
+    "sample",
+    "c9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721",
+    "61340c88c3aaebeb4f6d667f672ca9759a6ccaa9fa8811313039ee4a35471d32",
+    "6d7f147dac089441bb2e2fe8f7a3fa264b9c475098fdcf6e00d7c996e1b8b7eb" },
+  { &amp;_nettle_secp_256r1, &amp;nettle_sha224, &amp;hmac_sha224,
+    "sample",
+    "c9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721",
+    "53b2fff5d1752b2c689df257c04c40a587fababb3f6fc2702f1343af7ca9aa3f",
+    "b9afb64fdc03dc1a131c7d2386d11e349f070aa432a4acc918bea988bf75c74c" },
+  { &amp;_nettle_secp_256r1, &amp;nettle_sha256, &amp;hmac_sha256,
+    "sample",
+    "c9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721",
+    "efd48b2aacb6a8fd1140dd9cd45e81d69d2c877b56aaf991c34d0ea84eaf3716",
+    "f7cb1c942d657c41d436c7a1b6e29f65f3e900dbb9aff4064dc4ab2f843acda8" },
+  { &amp;_nettle_secp_256r1, &amp;nettle_sha512, &amp;hmac_sha512,
+    "sample",
+    "c9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721",
+    "8496a60b5e9b47c825488827e0495b0e3fa109ec4568fd3f8d1097678eb97f00",
+    "2362ab1adbe2b8adf9cb9edab740ea6049c028114f2460f96554f61fae3302fe" },
+  { &amp;_nettle_secp_384r1, &amp;nettle_sha256, &amp;hmac_sha256,
+    "sample",
+    "6b9d3dad2e1b8c1c05b19875b6659f4de23c3b667bf297ba9aa47740787137d8"
+    "96d5724e4c70a825f872c9ea60d2edf5",
+    "21b13d1e013c7fa1392d03c5f99af8b30c570c6f98d4ea8e354b63a21d3daa33"
+    "bde1e888e63355d92fa2b3c36d8fb2cd",
+    "f3aa443fb107745bf4bd77cb3891674632068a10ca67e3d45db2266fa7d1feeb"
+    "efdc63eccd1ac42ec0cb8668a4fa0ab0" },
+  { &amp;_nettle_secp_521r1, &amp;nettle_sha256, &amp;hmac_sha256,
+    "sample",
+    "0fad06daa62ba3b25d2fb40133da757205de67f5bb0018fee8c86e1b68c7e75c"
+    "aa896eb32f1f47c70855836a6d16fcc1466f6d8fbec67db89ec0c08b0e996b83"
+    "538",
+    "1511bb4d675114fe266fc4372b87682baecc01d3cc62cf2303c92b3526012659"
+    "d16876e25c7c1e57648f23b73564d67f61c6f14d527d54972810421e7d87589e"
+    "1a7",
+    "04a171143a83163d6df460aaf61522695f207a58b95c0644d87e52aa1a347916"
+    "e4f7a72930b1bc06dbe22ce3f58264afd23704cbb63b29b931f7de6c9d949a7e"
+    "cfc" }
+};
+
+void
+test_main (void)
+{
+  size_t i;
+
+  for (i = 0; i &lt; sizeof(tests) / sizeof(*tests); i++)
+    {
+      void *hash_ctx;
+      uint8_t digest[NETTLE_MAX_HASH_DIGEST_SIZE];
+      void *hmac_ctx;
+
+      hash_ctx = xalloc (tests[i].hash-&gt;context_size);
+      tests[i].hash-&gt;init (hash_ctx);
+      tests[i].hash-&gt;update (hash_ctx, 6, (const uint8_t *)tests[i].m);
+      tests[i].hash-&gt;digest (hash_ctx, tests[i].hash-&gt;digest_size, digest);
+
+      hmac_ctx = xalloc (tests[i].hmac-&gt;context_size);
+      test_ecdsa (tests[i].ecc,
+		  tests[i].z,
+		  hmac_ctx,
+		  tests[i].hmac,
+		  tstring_data (tests[i].hash-&gt;digest_size, digest),
+		  tests[i].r,
+		  tests[i].s);
+      free (hmac_ctx);
+    }
+}
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190712161038</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-12 16:10:38-0400</timestampReceived><subject>[PATCH v2 3/3] dsa: Add support for deterministic signature generation</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

This adds the dsa_sign_deterministic function that calculates
signature without requiring entropy source.  Instead, it uses the
deterministic construction described in RFC 6979, through
_dsa_compute_k.

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 Makefile.in              |   3 +-
 dsa-sign-deterministic.c | 107 ++++++++++++++++++++++++++++
 dsa.h                    |  12 ++++
 testsuite/dsa-test.c     | 148 ++++++++++++++++++++++++++++++++++++++-
 4 files changed, 268 insertions(+), 2 deletions(-)
 create mode 100644 dsa-sign-deterministic.c

diff --git a/Makefile.in b/Makefile.in
index 27cbf93f..38b2a9a6 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -188,7 +188,8 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  eddsa-hash.c eddsa-pubkey.c eddsa-sign.c eddsa-verify.c \
 		  ed25519-sha512-pubkey.c \
 		  ed25519-sha512-sign.c ed25519-sha512-verify.c \
-		  dsa-compute-k.c ecdsa-sign-deterministic.c
+		  dsa-compute-k.c ecdsa-sign-deterministic.c \
+		  dsa-sign-deterministic.c
 
 OPT_SOURCES = fat-x86_64.c fat-arm.c mini-gmp.c
 
diff --git a/dsa-sign-deterministic.c b/dsa-sign-deterministic.c
new file mode 100644
index 00000000..8c75b80f
--- /dev/null
+++ b/dsa-sign-deterministic.c
@@ -0,0 +1,107 @@
+/* dsa-sign-deterministic.c
+
+   Copyright (C) 2002, 2010 Niels Möller
+   Copyright (C) 2019 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include "dsa.h"
+#include "dsa-internal.h"
+#include "dsa-compute-k.h"
+
+#include "bignum.h"
+
+
+int
+dsa_sign_deterministic (const struct dsa_params *params,
+			const mpz_t x,
+			void *mac_ctx,
+			nettle_hash_update_func *set_key,
+			nettle_hash_update_func *update,
+			nettle_hash_digest_func *digest,
+			size_t digest_length,
+			const uint8_t *digest_message,
+			struct dsa_signature *signature)
+{
+  mpz_t k;
+  mpz_t h;
+  mpz_t tmp;
+  int res;
+
+  /* Check that p is odd, so that invalid keys don't result in a crash
+     inside mpz_powm_sec. */
+  if (mpz_even_p (params-&gt;p))
+    return 0;
+
+  /* Select k, 0&lt;k&lt;q, deterministically */
+  mpz_init(k);
+  _dsa_compute_k (mpz_limbs_write (k, mpz_size (params-&gt;q)),
+		  mpz_size (params-&gt;q),
+		  mpz_limbs_read (params-&gt;q),
+		  mpz_limbs_read (x),
+		  mac_ctx, set_key, update, digest,
+		  digest_length, digest_message);
+  mpz_limbs_finish (k, mpz_size (params-&gt;q));
+
+  /* Compute r = (g^k (mod p)) (mod q) */
+  mpz_init (tmp);
+  mpz_powm_sec(tmp, params-&gt;g, k, params-&gt;p);
+  mpz_fdiv_r(signature-&gt;r, tmp, params-&gt;q);
+
+  /* Compute hash */
+  mpz_init(h);
+  _dsa_hash (h, mpz_sizeinbase(params-&gt;q, 2), digest_length, digest_message);
+
+  /* Compute k^-1 (mod q) */
+  if (mpz_invert(k, k, params-&gt;q))
+    {
+      /* Compute signature s = k^-1 (h + xr) (mod q) */
+      mpz_mul(tmp, signature-&gt;r, x);
+      mpz_fdiv_r(tmp, tmp, params-&gt;q);
+      mpz_add(tmp, tmp, h);
+      mpz_mul(tmp, tmp, k);
+      mpz_fdiv_r(signature-&gt;s, tmp, params-&gt;q);
+      res = 1;
+    }
+  else
+    /* What do we do now? The key is invalid. */
+    res = 0;
+
+  mpz_clear(k);
+  mpz_clear(h);
+  mpz_clear(tmp);
+
+  return res;
+}
diff --git a/dsa.h b/dsa.h
index 553ef327..fddaea9d 100644
--- a/dsa.h
+++ b/dsa.h
@@ -47,6 +47,7 @@ extern "C" {
 #define dsa_signature_init nettle_dsa_signature_init
 #define dsa_signature_clear nettle_dsa_signature_clear
 #define dsa_sign nettle_dsa_sign
+#define dsa_sign_deterministic nettle_dsa_sign_deterministic
 #define dsa_verify nettle_dsa_verify
 #define dsa_generate_params nettle_dsa_generate_params
 #define dsa_generate_keypair nettle_dsa_generate_keypair
@@ -109,6 +110,17 @@ dsa_sign(const struct dsa_params *params,
 	 const uint8_t *digest,
 	 struct dsa_signature *signature);
 
+int
+dsa_sign_deterministic (const struct dsa_params *params,
+			const mpz_t x,
+			void *mac_ctx,
+			nettle_hash_update_func *set_key,
+			nettle_hash_update_func *update,
+			nettle_hash_digest_func *digest,
+			size_t digest_length,
+			const uint8_t *digest_message,
+			struct dsa_signature *signature);
+
 int
 dsa_verify(const struct dsa_params *params,
 	   const mpz_t y,
diff --git a/testsuite/dsa-test.c b/testsuite/dsa-test.c
index 9a80c967..dbc8d063 100644
--- a/testsuite/dsa-test.c
+++ b/testsuite/dsa-test.c
@@ -1,4 +1,57 @@
 #include "testutils.h"
+#include "hmac.h"
+#include "nettle-internal.h"
+
+static void
+test_dsa_sign_deterministic(const struct dsa_params *params,
+			    /* Private key */
+			    const char *sz,
+			    /* HMAC */
+			    void *mac_ctx,
+			    nettle_hash_update_func *set_key,
+			    nettle_hash_update_func *update,
+			    nettle_hash_digest_func *digest,
+			    /* Hash */
+			    const struct tstring *h,
+			    /* Expected signature */
+			    const char *r, const char *s)
+{
+  struct dsa_signature ref;
+  struct dsa_signature signature;
+  mpz_t z;
+
+  dsa_signature_init (&amp;ref);
+  dsa_signature_init(&amp;signature);
+
+  mpz_init_set_str (z, sz, 16);
+
+  ASSERT (dsa_sign_deterministic (params, z,
+				  mac_ctx, set_key, update, digest,
+				  h-&gt;length, h-&gt;data, &amp;signature));
+
+  mpz_set_str (ref.r, r, 16);
+  mpz_set_str (ref.s, s, 16);
+
+  if (mpz_cmp (signature.r, ref.r) != 0
+      || mpz_cmp (signature.s, ref.s) != 0)
+    {
+      fprintf (stderr, "_dsa_sign failed\n");
+      fprintf (stderr, "r     = ");
+      mpz_out_str (stderr, 16, signature.r);
+      fprintf (stderr, "\ns     = ");
+      mpz_out_str (stderr, 16, signature.s);
+      fprintf (stderr, "\nref.r = ");
+      mpz_out_str (stderr, 16, ref.r);
+      fprintf (stderr, "\nref.s = ");
+      mpz_out_str (stderr, 16, ref.s);
+      fprintf (stderr, "\n");
+      abort();
+    }
+
+  dsa_signature_clear (&amp;ref);
+  dsa_signature_clear (&amp;signature);
+  mpz_clear (z);
+}
 
 void
 test_main(void)
@@ -7,6 +60,13 @@ test_main(void)
   struct dsa_private_key key;
   struct dsa_signature signature;
   struct dsa_params *params = (struct dsa_params *) 
+  struct hmac_sha256_ctx hmac_sha256;
+  struct sha256_ctx hash_sha256;
+  uint8_t digest[NETTLE_MAX_HASH_DIGEST_SIZE];
+
+  sha256_init (&amp;hash_sha256);
+  sha256_update (&amp;hash_sha256, 6, (const uint8_t *)"sample");
+  sha256_digest (&amp;hash_sha256, SHA256_DIGEST_SIZE, digest);
 
   dsa_public_key_init(&amp;pub);
   dsa_private_key_init(&amp;key);
@@ -877,7 +937,93 @@ test_main(void)
 		       "bb7441c122f1dc2f9d0b0bc07f26ba29a35cdf0da846a9d8"
 		       "eab405cbf8c8e77f"),
 		  &amp;signature);
-  
+
+  /* Test vectors from RFC 6979 */
+  mpz_set_str(pub.p,
+	      "86f5ca03dcfeb225063ff830a0c769b9dd9d6153ad91d7ce"
+	      "27f787c43278b447e6533b86b18bed6e8a48b784a14c252c"
+	      "5be0dbf60b86d6385bd2f12fb763ed8873abfd3f5ba2e0a8"
+	      "c0a59082eac056935e529daf7c610467899c77adedfc846c"
+	      "881870b7b19b2b58f9be0521a17002e3bdd6b86685ee90b3"
+	      "d9a1b02b782b1779", 16);
+  mpz_set_str(pub.q,
+	      "996f967f6c8e388d9e28d01e205fba957a5698b1", 16);
+  mpz_set_str(pub.g,
+	      "07b0f92546150b62514bb771e2a0c0ce387f03bda6c56b50"
+	      "5209ff25fd3c133d89bbcd97e904e09114d9a7defdeadfc9"
+	      "078ea544d2e401aeecc40bb9fbbf78fd87995a10a1c27cb7"
+	      "789b594ba7efb5c4326a9fe59a070e136db77175464adca4"
+	      "17be5dce2f40d10a46a3a3943f26ab7fd9c0398ff8c76ee0"
+	      "a56826a8a88f1dbd", 16);
+  mpz_set_str(pub.y,
+	      "5df5e01ded31d0297e274e1691c192fe5868fef9e19a8477"
+	      "6454b100cf16f65392195a38b90523e2542ee61871c0440c"
+	      "b87c322fc4b4d2ec5e1e7ec766e1be8d4ce935437dc11c3c"
+	      "8fd426338933ebfe739cb3465f4d3668c5e473508253b1e6"
+	      "82f65cbdc4fae93c2ea212390e54905a86e2223170b44eaa"
+	      "7da5dd9ffcfb7f3b", 16);
+  test_dsa_sign_deterministic (params,
+			       "411602cb19a6ccc34494d79d98ef1e7ed5af25f7",
+			       &amp;hmac_sha256,
+			       (nettle_hash_update_func *)hmac_sha256_set_key,
+			       (nettle_hash_update_func *)hmac_sha256_update,
+			       (nettle_hash_digest_func *)hmac_sha256_digest,
+			       tstring_data (SHA256_DIGEST_SIZE, digest), /* h */
+			       "81f2f5850be5bc123c43f71a3033e9384611c545",
+			       "4cdd914b65eb6c66a8aaad27299bee6b035f5e89");
+
+  mpz_set_str(pub.p,
+	      "9db6fb5951b66bb6fe1e140f1d2ce5502374161fd6538df1"
+	      "648218642f0b5c48c8f7a41aadfa187324b87674fa1822b0"
+	      "0f1ecf8136943d7c55757264e5a1a44ffe012e9936e00c1d"
+	      "3e9310b01c7d179805d3058b2a9f4bb6f9716bfe6117c6b5"
+	      "b3cc4d9be341104ad4a80ad6c94e005f4b993e14f091eb51"
+	      "743bf33050c38de235567e1b34c3d6a5c0ceaa1a0f368213"
+	      "c3d19843d0b4b09dcb9fc72d39c8de41f1bf14d4bb4563ca"
+	      "28371621cad3324b6a2d392145bebfac748805236f5ca2fe"
+	      "92b871cd8f9c36d3292b5509ca8caa77a2adfc7bfd77dda6"
+	      "f71125a7456fea153e433256a2261c6a06ed3693797e7995"
+	      "fad5aabbcfbe3eda2741e375404ae25b", 16);
+  mpz_set_str(pub.q,
+	      "f2c3119374ce76c9356990b465374a17f23f9ed35089bd96"
+	      "9f61c6dde9998c1f", 16);
+  mpz_set_str(pub.g,
+	      "5c7ff6b06f8f143fe8288433493e4769c4d988ace5be25a0"
+	      "e24809670716c613d7b0cee6932f8faa7c44d2cb24523da5"
+	      "3fbe4f6ec3595892d1aa58c4328a06c46a15662e7eaa703a"
+	      "1decf8bbb2d05dbe2eb956c142a338661d10461c0d135472"
+	      "085057f3494309ffa73c611f78b32adbb5740c361c9f35be"
+	      "90997db2014e2ef5aa61782f52abeb8bd6432c4dd097bc54"
+	      "23b285dafb60dc364e8161f4a2a35aca3a10b1c4d203cc76"
+	      "a470a33afdcbdd92959859abd8b56e1725252d78eac66e71"
+	      "ba9ae3f1dd2487199874393cd4d832186800654760e1e34c"
+	      "09e4d155179f9ec0dc4473f996bdce6eed1cabed8b6f116f"
+	      "7ad9cf505df0f998e34ab27514b0ffe7", 16);
+  mpz_set_str(pub.y,
+	      "667098c654426c78d7f8201eac6c203ef030d43605032c2f"
+	      "1fa937e5237dbd949f34a0a2564fe126dc8b715c5141802c"
+	      "e0979c8246463c40e6b6bdaa2513fa611728716c2e4fd53b"
+	      "c95b89e69949d96512e873b9c8f8dfd499cc312882561ade"
+	      "cb31f658e934c0c197f2c4d96b05cbad67381e7b768891e4"
+	      "da3843d24d94cdfb5126e9b8bf21e8358ee0e0a30ef13fd6"
+	      "a664c0dce3731f7fb49a4845a4fd8254687972a2d382599c"
+	      "9bac4e0ed7998193078913032558134976410b89d2c171d1"
+	      "23ac35fd977219597aa7d15c1a9a428e59194f75c721ebcb"
+	      "cfae44696a499afa74e04299f132026601638cb87ab79190"
+	      "d4a0986315da8eec6561c938996beadf", 16);
+  test_dsa_sign_deterministic (params,
+			       "69c7548c21d0dfea6b9a51c9ead4e27c33d3b3f1"
+			       "80316e5bcab92c933f0e4dbc",
+			       &amp;hmac_sha256,
+			       (nettle_hash_update_func *)hmac_sha256_set_key,
+			       (nettle_hash_update_func *)hmac_sha256_update,
+			       (nettle_hash_digest_func *)hmac_sha256_digest,
+			       tstring_data (SHA256_DIGEST_SIZE, digest), /* h */
+			       "eace8bdbbe353c432a795d9ec556c6d021f7a03f"
+			       "42c36e9bc87e4ac7932cc809",
+			       "7081e175455f9247b812b74583e9e94f9ea79bd6"
+			       "40dc962533b0680793a38d53");
+
   dsa_public_key_clear(&amp;pub);
   dsa_private_key_clear(&amp;key);
   dsa_signature_clear(&amp;signature);
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190717084013</emailId><senderName>Justus Winter</senderName><senderEmail>justus@sequoia-pgp.org</senderEmail><timestampReceived>2019-07-17 08:40:13-0400</timestampReceived><subject>Re: Rust bindings</subject><body>

[Attachment #2 (multipart/signed)]


nisse@lysator.liu.se (Niels M=C3=B6ller) writes:

&gt; Have you looked at nettle's pgp.h?

No.

&gt; This code is not really in a useful state. It aims to be able to write
&gt; out a public RSA key in openpgp format, and doesn't quite succeed at
&gt; that.

Well, a key packet on its own is not useful, you also need signature
packets and userid packets to form a useful OpenPGP Transferable Public
Key.

&gt; Do you think it would be useful with some level of pgp-support in the
&gt; Nettle library?

I don't know.  That depends on the use case.  The most basic operation
that I can think of would be signature verification, and even that
requires the ability to correctly canonicalize TPKs, which is somewhat
involved.  Encryption and safe decryption requires streaming,
consumption of arbitrary OpenPGP messages requires decompression
support, it just goes on and on...

&gt; Regarding the Rust bindings, what's the best place to point other Rust
&gt; users? https://crates.io/crates/nettle, or
&gt; https://sequoia-pgp.gitlab.io/nettle-rs/nettle/, or somewhere else?

https://crates.io/crates/nettle is the preferred place to point
downstream users to.  Thanks!

&gt; Niels M=C3=B6ller. PGP-encrypted email is preferred. Keyid 368C6677.

Nitpick:  You have a short KeyID in your signature.


Cheers,
Justus

["signature.asc" (application/pgp-signature)]
[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190716145401</emailId><senderName>Justus Winter</senderName><senderEmail>justus@sequoia-pgp.org</senderEmail><timestampReceived>2019-07-16 14:54:01-0400</timestampReceived><subject>Rust bindings</subject><body>

[Attachment #2 (multipart/signed)]


Hello :)

I just wanted to say hi, and announce the availability of bindings for
the Rust programming language.

As it is idiomatic for bindings to foreign code, there are two packages.

First, there is the almost completely autogenerated crate (crate is
Rust-lingo for library) 'nettle-sys', which merely exposes the C API
without any language-specific wrapping.

    https://crates.io/crates/nettle-sys

Second, there is the 'nettle' crate, which adds an idiomatic and safe
interface on top of the former crate.

    https://crates.io/crates/nettle

For some context, we are working on a new OpenPGP implementation in
Rust, called Sequoia-PGP.

    https://sequoia-pgp.org/

When we started the project, we evaluated cryptographic libraries, and
decided that Nettle would be the best fit for us, even if it involved
creating language bindings first.  Looking back after one and a half
years, we're still happy with our choice.  So let me express our
gratitude for everyone who is or has been working on Nettle!


Cheers,
Justus

["signature.asc" (application/pgp-signature)]
[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190717080735</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-17 08:07:35-0400</timestampReceived><subject>Re: Rust bindings</subject><body>

Justus Winter &lt;justus@sequoia-pgp.org&gt; writes:

&gt; When we started the project, we evaluated cryptographic libraries, and
&gt; decided that Nettle would be the best fit for us, even if it involved
&gt; creating language bindings first.  Looking back after one and a half
&gt; years, we're still happy with our choice.  So let me express our
&gt; gratitude for everyone who is or has been working on Nettle!

Thanks!

Have you looked at nettle's pgp.h? This code is not really in a useful
state. It aims to be able to write out a public RSA key in openpgp
format, and doesn't quite succeed at that. Do you think it would be
useful with some level of pgp-support in the Nettle library?

Regarding the Rust bindings, what's the best place to point other Rust
users? https://crates.io/crates/nettle, or
https://sequoia-pgp.gitlab.io/nettle-rs/nettle/, or somewhere else?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190924165244</emailId><senderName>Justus Winter</senderName><senderEmail>justus@sequoia-pgp.org</senderEmail><timestampReceived>2019-09-24 16:52:44-0400</timestampReceived><subject>Re: Rust bindings</subject><body>

[Attachment #2 (multipart/signed)]


Justus Winter &lt;justus@sequoia-pgp.org&gt; writes:

&gt;&gt; Regarding the Rust bindings, what's the best place to point other Rust
&gt;&gt; users? https://crates.io/crates/nettle, or
&gt;&gt; https://sequoia-pgp.gitlab.io/nettle-rs/nettle/, or somewhere else?
&gt;
&gt; https://crates.io/crates/nettle is the preferred place to point
&gt; downstream users to.  Thanks!

Do we need to do anything else to be listed on
https://www.lysator.liu.se/~nisse/nettle/ ?

Thanks,
Justus

["signature.asc" (application/pgp-signature)]
[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190926211302</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-26 21:13:02-0400</timestampReceived><subject>Re: Rust bindings</subject><body>

Justus Winter &lt;justus@sequoia-pgp.org&gt; writes:

&gt; Do we need to do anything else to be listed on
&gt; https://www.lysator.liu.se/~nisse/nettle/ ?

If you want to make it really easy for me, please send a patch, the file
on the web should be a straight copy of
https://git.lysator.liu.se/nettle/nettle/blob/master/index.html

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190717095355</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-17 09:53:55-0400</timestampReceived><subject>Re: nettle-meta interface for MACs</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; It's also not directly usable with umac, which takes a nonce (and auto
&gt; increment in umac*_digest). Should the generic interface try to
&gt; accomodate macs that require a nonce?

In terms of the meta interface, I guess we could add a set_nonce
function to the structure and define it as no-op for other MACs.

&gt; I would consider doing it the other way around, and define nettle_hmac_*
&gt; with fixed key size, for the key sizes used by applications. E.g,
&gt; https://tools.ietf.org/html/rfc4253#section-6.4 defines 4 mac algorithms
&gt; based on hmac, with the main one being hmac-sha1, with a fixed key size
&gt; equal to the digest size of 160 bits.
&gt;
&gt; Is it common to use hmac, without context implying a fix key size ?

Indeed, that would make more sense, given a short key is simply
zero-padded to the hash block size.

&gt; Slightly related: HMAC is defined as allowing very long keys, by hashing
&gt; the key in case it's larger than the block size (e.g., 512 bits for
&gt; hmac-sha1 and hmac-sha256). That seems a bit obscure to me. Are there
&gt; any applications or protocols depending on that feature?

I think this is a requirement of FIPS as the HMAC definition in FIPS
198-1 explicitly mentions this step.

Regards,
-- 
Daiki Ueno
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190718045152</emailId><senderName>Wim Lewis</senderName><senderEmail>wiml@hhhh.org</senderEmail><timestampReceived>2019-07-18 04:51:52-0400</timestampReceived><subject>[PATCH] Curve point decompression</subject><body>

Now that 3.5.1 is out, is there a chance this could be looked at?


On Wed, May 29, 2019 at 01:25:08AM -0700, Wim Lewis wrote:
&gt; I've pushed some work-in-progress to a git repository here:
&gt;   https://git.lysator.liu.se/wiml/nettle


On Thursday, June 6, 2019 11:41:49 PM PDT, Wim Lewis wrote:
&gt; I've pushed a few more changes to that repository; decompression now 
&gt; works for P-192 and P-224 as well.
&gt;
&gt; I think this is done --- Niels, can you consider this a pull/review 
&gt; request, or would you rather I send a patch (or git-bundle) to the list?
&gt;
&gt; The tests have almost but not quite 100% branch coverage. The few 
&gt; uncovered branches are either cases which I think are allowed by other 
&gt; functions' specification but not by their current implementation, or 
&gt; things that I think are mathematically impossible but can't trivially 
&gt; prove.



_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190719133755</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-19 13:37:55-0400</timestampReceived><subject>[PATCH 2/7] nettle-meta: Move struct nettle_mac to nettle-meta.h</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

The struct was defined in testutils.h as the interface was not
stable.  This generalizes the interface to cover all defined MAC
algorithms in nettle.

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 nettle-meta.h         | 22 ++++++++++++++++++++++
 testsuite/testutils.h | 29 -----------------------------
 2 files changed, 22 insertions(+), 29 deletions(-)

diff --git a/nettle-meta.h b/nettle-meta.h
index 74e50e59..b03da208 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -238,6 +238,28 @@ extern const struct nettle_armor nettle_base64;
 extern const struct nettle_armor nettle_base64url;
 extern const struct nettle_armor nettle_base16;
 
+struct nettle_mac
+{
+  const char *name;
+
+  /* Size of the context struct */
+  unsigned context_size;
+
+  /* Size of digests */
+  unsigned digest_size;
+
+  /* Suggested key size; other sizes are sometimes possible */
+  unsigned key_size;
+
+  /* Suggested nonce size; 0 if nonce is not used */
+  unsigned nonce_size;
+
+  nettle_set_key_func *set_key;
+  nettle_set_key_func *set_nonce;
+  nettle_hash_update_func *update;
+  nettle_hash_digest_func *digest;
+};
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/testutils.h b/testsuite/testutils.h
index f4ea38da..78daf62b 100644
--- a/testsuite/testutils.h
+++ b/testsuite/testutils.h
@@ -79,35 +79,6 @@ test_main(void);
 
 extern int verbose;
 
-/* FIXME: When interface stabilizes, move to nettle-meta.h */
-struct nettle_mac
-{
-  const char *name;
-
-  /* Size of the context struct */
-  unsigned context_size;
-
-  /* Size of digests */
-  unsigned digest_size;
-
-  /* Suggested key size; other sizes are sometimes possible. */
-  unsigned key_size;
-  
-  nettle_set_key_func *set_key;
-  nettle_hash_update_func *update;
-  nettle_hash_digest_func *digest;
-};
-
-#define _NETTLE_HMAC(name, NAME, keysize) {	\
-  #name,					\
-  sizeof(struct hmac_##name##_ctx),		\
-  NAME##_DIGEST_SIZE,				\
-  NAME##_DIGEST_SIZE,				\
-  hmac_##name##_set_key,			\
-  hmac_##name##_update,				\
-  hmac_##name##_digest,				\
-}
-
 /* Test functions deallocate their inputs when finished.*/
 void
 test_cipher(const struct nettle_cipher *cipher,
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190719133756</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-19 13:37:56-0400</timestampReceived><subject>[PATCH 3/7] nettle-meta: Add meta interface for CMAC functions</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 Makefile.in           |  1 +
 cmac-aes128-meta.c    | 48 +++++++++++++++++++++++++++++++++++++++++++
 cmac-aes256-meta.c    | 48 +++++++++++++++++++++++++++++++++++++++++++
 nettle-meta.h         | 15 ++++++++++++++
 testsuite/cmac-test.c | 24 ----------------------
 5 files changed, 112 insertions(+), 24 deletions(-)
 create mode 100644 cmac-aes128-meta.c
 create mode 100644 cmac-aes256-meta.c

diff --git a/Makefile.in b/Makefile.in
index b54e64b0..6a425e16 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -103,6 +103,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
 		 cmac.c cmac-aes128.c cmac-aes256.c \
+		 cmac-aes128-meta.c cmac-aes256-meta.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
diff --git a/cmac-aes128-meta.c b/cmac-aes128-meta.c
new file mode 100644
index 00000000..73cf396c
--- /dev/null
+++ b/cmac-aes128-meta.c
@@ -0,0 +1,48 @@
+/* cmac-aes128-meta.c
+
+   Copyright (C) 2013, 2014 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "nettle-meta.h"
+
+#include "cmac.h"
+
+static void
+cmac_aes128_set_nonce_wrapper (void *ctx UNUSED, const uint8_t *key UNUSED)
+{
+}
+
+const struct nettle_mac nettle_cmac_aes128
+= _NETTLE_CMAC(cmac_aes128, AES128);
diff --git a/cmac-aes256-meta.c b/cmac-aes256-meta.c
new file mode 100644
index 00000000..e7bf745c
--- /dev/null
+++ b/cmac-aes256-meta.c
@@ -0,0 +1,48 @@
+/* cmac-aes256-meta.c
+
+   Copyright (C) 2013, 2014 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "nettle-meta.h"
+
+#include "cmac.h"
+
+static void
+cmac_aes256_set_nonce_wrapper (void *ctx UNUSED, const uint8_t *key UNUSED)
+{
+}
+
+const struct nettle_mac nettle_cmac_aes256
+= _NETTLE_CMAC(cmac_aes256, AES256);
diff --git a/nettle-meta.h b/nettle-meta.h
index b03da208..656c30de 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -260,6 +260,21 @@ struct nettle_mac
   nettle_hash_digest_func *digest;
 };
 
+#define _NETTLE_CMAC(name, AES) {		\
+  #name,					\
+  sizeof(struct name##_ctx),			\
+  CMAC128_DIGEST_SIZE,				\
+  AES##_KEY_SIZE,				\
+  0,						\
+  (nettle_set_key_func *) name##_set_key,	\
+  name##_set_nonce_wrapper,			\
+  (nettle_hash_update_func *) name##_update,	\
+  (nettle_hash_digest_func *) name##_digest,	\
+}
+
+extern const struct nettle_mac nettle_cmac_aes128;
+extern const struct nettle_mac nettle_cmac_aes256;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
index b1d4aa30..42188ece 100644
--- a/testsuite/cmac-test.c
+++ b/testsuite/cmac-test.c
@@ -2,30 +2,6 @@
 #include "nettle-internal.h"
 #include "cmac.h"
 
-const struct nettle_mac nettle_cmac_aes128 =
-{
-  "CMAC-AES128",
-  sizeof(struct cmac_aes128_ctx),
-  CMAC128_DIGEST_SIZE,
-  AES128_KEY_SIZE,
-
-  (nettle_set_key_func*) cmac_aes128_set_key,
-  (nettle_hash_update_func*) cmac_aes128_update,
-  (nettle_hash_digest_func*) cmac_aes128_digest
-};
-
-const struct nettle_mac nettle_cmac_aes256 =
-{
-  "CMAC-AES256",
-  sizeof(struct cmac_aes256_ctx),
-  CMAC128_DIGEST_SIZE,
-  AES256_KEY_SIZE,
-
-  (nettle_set_key_func*) cmac_aes256_set_key,
-  (nettle_hash_update_func*) cmac_aes256_update,
-  (nettle_hash_digest_func*) cmac_aes256_digest
-};
-
 #define test_cmac_aes128(key, msg, ref)					\
   test_mac(&amp;nettle_cmac_aes128, key, msg, ref)
 
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190719133757</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-19 13:37:57-0400</timestampReceived><subject>[PATCH 4/7] nettle-meta: Add meta interface for HMAC functions</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 Makefile.in           |  3 +++
 hmac-md5-meta.c       | 46 +++++++++++++++++++++++++++++++++++++++++++
 hmac-ripemd160-meta.c | 46 +++++++++++++++++++++++++++++++++++++++++++
 hmac-sha1-meta.c      | 46 +++++++++++++++++++++++++++++++++++++++++++
 hmac-sha224-meta.c    | 46 +++++++++++++++++++++++++++++++++++++++++++
 hmac-sha256-meta.c    | 46 +++++++++++++++++++++++++++++++++++++++++++
 hmac-sha384-meta.c    | 46 +++++++++++++++++++++++++++++++++++++++++++
 hmac-sha512-meta.c    | 46 +++++++++++++++++++++++++++++++++++++++++++
 nettle-meta.h         | 20 +++++++++++++++++++
 9 files changed, 345 insertions(+)
 create mode 100644 hmac-md5-meta.c
 create mode 100644 hmac-ripemd160-meta.c
 create mode 100644 hmac-sha1-meta.c
 create mode 100644 hmac-sha224-meta.c
 create mode 100644 hmac-sha256-meta.c
 create mode 100644 hmac-sha384-meta.c
 create mode 100644 hmac-sha512-meta.c

diff --git a/Makefile.in b/Makefile.in
index 6a425e16..9031d959 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -107,6 +107,9 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
+		 hmac-md5-meta.c hmac-ripemd160-meta.c hmac-sha1-meta.c \
+		 hmac-sha224-meta.c hmac-sha256-meta.c hmac-sha384-meta.c \
+		 hmac-sha512-meta.c \
 		 knuth-lfib.c hkdf.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
diff --git a/hmac-md5-meta.c b/hmac-md5-meta.c
new file mode 100644
index 00000000..4ed99b5e
--- /dev/null
+++ b/hmac-md5-meta.c
@@ -0,0 +1,46 @@
+/* hmac-md5-meta.c
+
+   Copyright (C) 2002 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "hmac.h"
+
+static void
+hmac_md5_set_nonce_wrapper (void *ctx UNUSED, const uint8_t *key UNUSED)
+{
+}
+
+const struct nettle_mac nettle_hmac_md5
+= _NETTLE_HMAC(hmac_md5, MD5);
diff --git a/hmac-ripemd160-meta.c b/hmac-ripemd160-meta.c
new file mode 100644
index 00000000..6c354ac2
--- /dev/null
+++ b/hmac-ripemd160-meta.c
@@ -0,0 +1,46 @@
+/* hmac-ripemd160-meta.c
+
+   Copyright (C) 2011 Andres Mejia
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "hmac.h"
+
+static void
+hmac_ripemd160_set_nonce_wrapper (void *ctx UNUSED, const uint8_t *key UNUSED)
+{
+}
+
+const struct nettle_mac nettle_hmac_ripemd160
+= _NETTLE_HMAC(hmac_ripemd160, RIPEMD160);
diff --git a/hmac-sha1-meta.c b/hmac-sha1-meta.c
new file mode 100644
index 00000000..d6a70802
--- /dev/null
+++ b/hmac-sha1-meta.c
@@ -0,0 +1,46 @@
+/* hmac-sha1-meta.c
+
+   Copyright (C) 2002 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "hmac.h"
+
+static void
+hmac_sha1_set_nonce_wrapper (void *ctx UNUSED, const uint8_t *key UNUSED)
+{
+}
+
+const struct nettle_mac nettle_hmac_sha1
+= _NETTLE_HMAC(hmac_sha1, SHA1);
diff --git a/hmac-sha224-meta.c b/hmac-sha224-meta.c
new file mode 100644
index 00000000..f715ce64
--- /dev/null
+++ b/hmac-sha224-meta.c
@@ -0,0 +1,46 @@
+/* hmac-sha224-meta.c
+
+   Copyright (C) 2002, 2010 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "hmac.h"
+
+static void
+hmac_sha224_set_nonce_wrapper (void *ctx UNUSED, const uint8_t *key UNUSED)
+{
+}
+
+const struct nettle_mac nettle_hmac_sha224
+= _NETTLE_HMAC(hmac_sha224, SHA224);
diff --git a/hmac-sha256-meta.c b/hmac-sha256-meta.c
new file mode 100644
index 00000000..bc3ae45e
--- /dev/null
+++ b/hmac-sha256-meta.c
@@ -0,0 +1,46 @@
+/* hmac-sha256-meta.c
+
+   Copyright (C) 2002 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "hmac.h"
+
+static void
+hmac_sha256_set_nonce_wrapper (void *ctx UNUSED, const uint8_t *key UNUSED)
+{
+}
+
+const struct nettle_mac nettle_hmac_sha256
+= _NETTLE_HMAC(hmac_sha256, SHA256);
diff --git a/hmac-sha384-meta.c b/hmac-sha384-meta.c
new file mode 100644
index 00000000..a15e48b6
--- /dev/null
+++ b/hmac-sha384-meta.c
@@ -0,0 +1,46 @@
+/* hmac-sha384-meta.c
+
+   Copyright (C) 2002, 2010 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "hmac.h"
+
+static void
+hmac_sha384_set_nonce_wrapper (void *ctx UNUSED, const uint8_t *key UNUSED)
+{
+}
+
+const struct nettle_mac nettle_hmac_sha384
+= _NETTLE_HMAC(hmac_sha384, SHA384);
diff --git a/hmac-sha512-meta.c b/hmac-sha512-meta.c
new file mode 100644
index 00000000..0efcb216
--- /dev/null
+++ b/hmac-sha512-meta.c
@@ -0,0 +1,46 @@
+/* hmac-sha512-meta.c
+
+   Copyright (C) 2002, 2010 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "hmac.h"
+
+static void
+hmac_sha512_set_nonce_wrapper (void *ctx UNUSED, const uint8_t *key UNUSED)
+{
+}
+
+const struct nettle_mac nettle_hmac_sha512
+= _NETTLE_HMAC(hmac_sha512, SHA512);
diff --git a/nettle-meta.h b/nettle-meta.h
index 656c30de..f2a73d9b 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -272,9 +272,29 @@ struct nettle_mac
   (nettle_hash_digest_func *) name##_digest,	\
 }
 
+#define _NETTLE_HMAC(name, HASH) {			\
+  #name,						\
+  sizeof(struct name##_ctx),				\
+  HASH##_DIGEST_SIZE,					\
+  HASH##_BLOCK_SIZE,					\
+  0,							\
+  (nettle_set_key_func *) name##_set_key_expanded,	\
+  name##_set_nonce_wrapper,				\
+  (nettle_hash_update_func *) name##_update,		\
+  (nettle_hash_digest_func *) name##_digest,		\
+}
+
 extern const struct nettle_mac nettle_cmac_aes128;
 extern const struct nettle_mac nettle_cmac_aes256;
 
+extern const struct nettle_mac nettle_hmac_md5;
+extern const struct nettle_mac nettle_hmac_ripemd160;
+extern const struct nettle_mac nettle_hmac_sha1;
+extern const struct nettle_mac nettle_hmac_sha224;
+extern const struct nettle_mac nettle_hmac_sha256;
+extern const struct nettle_mac nettle_hmac_sha384;
+extern const struct nettle_mac nettle_hmac_sha512;
+
 #ifdef __cplusplus
 }
 #endif
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190719133758</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-19 13:37:58-0400</timestampReceived><subject>[PATCH 5/7] nettle-meta: Add meta interface for UMAC functions</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 Makefile.in    |  1 +
 nettle-meta.h  | 17 +++++++++++++++++
 umac128-meta.c | 47 +++++++++++++++++++++++++++++++++++++++++++++++
 umac32-meta.c  | 47 +++++++++++++++++++++++++++++++++++++++++++++++
 umac64-meta.c  | 47 +++++++++++++++++++++++++++++++++++++++++++++++
 umac96-meta.c  | 47 +++++++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 206 insertions(+)
 create mode 100644 umac128-meta.c
 create mode 100644 umac32-meta.c
 create mode 100644 umac64-meta.c
 create mode 100644 umac96-meta.c

diff --git a/Makefile.in b/Makefile.in
index 9031d959..4cfc5005 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -138,6 +138,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 umac-nh.c umac-nh-n.c umac-l2.c umac-l3.c \
 		 umac-poly64.c umac-poly128.c umac-set-key.c \
 		 umac32.c umac64.c umac96.c umac128.c \
+		 umac32-meta.c umac64-meta.c umac96-meta.c umac128-meta.c \
 		 version.c \
 		 write-be32.c write-le32.c write-le64.c \
 		 yarrow256.c yarrow_key_event.c \
diff --git a/nettle-meta.h b/nettle-meta.h
index f2a73d9b..55229501 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -284,6 +284,18 @@ struct nettle_mac
   (nettle_hash_digest_func *) name##_digest,		\
 }
 
+#define _NETTLE_UMAC(name, NAME) {		\
+  #name,					\
+  sizeof(struct name##_ctx),			\
+  NAME##_DIGEST_SIZE,				\
+  UMAC_BLOCK_SIZE,				\
+  AES_BLOCK_SIZE,				\
+  (nettle_set_key_func *) name##_set_key,	\
+  name##_set_nonce_wrapper,			\
+  (nettle_hash_update_func *) name##_update,	\
+  (nettle_hash_digest_func *) name##_digest,	\
+}
+
 extern const struct nettle_mac nettle_cmac_aes128;
 extern const struct nettle_mac nettle_cmac_aes256;
 
@@ -295,6 +307,11 @@ extern const struct nettle_mac nettle_hmac_sha256;
 extern const struct nettle_mac nettle_hmac_sha384;
 extern const struct nettle_mac nettle_hmac_sha512;
 
+extern const struct nettle_mac nettle_umac32;
+extern const struct nettle_mac nettle_umac64;
+extern const struct nettle_mac nettle_umac96;
+extern const struct nettle_mac nettle_umac128;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/umac128-meta.c b/umac128-meta.c
new file mode 100644
index 00000000..9f6a7e34
--- /dev/null
+++ b/umac128-meta.c
@@ -0,0 +1,47 @@
+/* umac128-meta.c
+
+   Copyright (C) 2013 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "umac.h"
+
+static void
+umac128_set_nonce_wrapper (void *ctx, const uint8_t *key)
+{
+  umac128_set_nonce (ctx, AES_BLOCK_SIZE, key);
+}
+
+const struct nettle_mac nettle_umac128
+= _NETTLE_UMAC(umac128, UMAC128);
diff --git a/umac32-meta.c b/umac32-meta.c
new file mode 100644
index 00000000..2b4f9c14
--- /dev/null
+++ b/umac32-meta.c
@@ -0,0 +1,47 @@
+/* umac32-meta.c
+
+   Copyright (C) 2013 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "umac.h"
+
+static void
+umac32_set_nonce_wrapper (void *ctx, const uint8_t *key)
+{
+  umac32_set_nonce (ctx, AES_BLOCK_SIZE, key);
+}
+
+const struct nettle_mac nettle_umac32
+= _NETTLE_UMAC(umac32, UMAC32);
diff --git a/umac64-meta.c b/umac64-meta.c
new file mode 100644
index 00000000..0351aaed
--- /dev/null
+++ b/umac64-meta.c
@@ -0,0 +1,47 @@
+/* umac64-meta.c
+
+   Copyright (C) 2013 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "umac.h"
+
+static void
+umac64_set_nonce_wrapper (void *ctx, const uint8_t *key)
+{
+  umac64_set_nonce (ctx, AES_BLOCK_SIZE, key);
+}
+
+const struct nettle_mac nettle_umac64
+= _NETTLE_UMAC(umac64, UMAC64);
diff --git a/umac96-meta.c b/umac96-meta.c
new file mode 100644
index 00000000..2feba8c8
--- /dev/null
+++ b/umac96-meta.c
@@ -0,0 +1,47 @@
+/* umac96-meta.c
+
+   Copyright (C) 2013 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "umac.h"
+
+static void
+umac96_set_nonce_wrapper (void *ctx, const uint8_t *key)
+{
+  umac96_set_nonce (ctx, AES_BLOCK_SIZE, key);
+}
+
+const struct nettle_mac nettle_umac96
+= _NETTLE_UMAC(umac96, UMAC96);
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190715111338</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-15 11:13:38-0400</timestampReceived><subject>nettle-meta interface for MACs</subject><body>

Hello,

In testutils.h, there is a nettle-meta definition for MACs, similar to
hashes and ciphers:

 /* FIXME: When interface stabilizes, move to nettle-meta.h */
 struct nettle_mac
 {
   const char *name;

   /* Size of the context struct */
   unsigned context_size;

   /* Size of digests */
   unsigned digest_size;

   /* Suggested key size; other sizes are sometimes possible. */
   unsigned key_size;
   
   nettle_set_key_func *set_key;
   nettle_hash_update_func *update;
   nettle_hash_digest_func *digest;
 };

This is, however, not usable for HMAC, because Nettle build uses
-Wcast-function-type and the set_key member has an incompatible type
with hmac_*_set_key, which requires a key length argument as HMAC allows
arbitrary key length up to the hash block size.

Is there any plan to make it more generic and eventually move it to
nettle-meta.h?  That would be particularly useful in applications
passing around HMAC functions (e.g., HKDF, deterministic ECDSA).

For example, I'm thinking to use nettle_hash_update_func for set_key and
provide a wrapper around other MACs which don't take key length,
something like:

 void
 _cmac_aes128_set_key(struct cmac_aes128_ctx *ctx,
                      size_t length, const uint8_t *key)
 {
   assert (length == AES128_KEY_LENGTH);
   cmac_aes128_set_key (ctx, length, key);
 }

Regards,
-- 
Daiki Ueno
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190719133754</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-19 13:37:54-0400</timestampReceived><subject>[PATCH 1/7] hmac: Add set_key_expanded function</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

This adds a set_key_expanded to all HMACs, to provide a compatible
signature with nettle_set_key_func.  This function is similar to
set_key, but assumes the input is already expanded to the hash block
size.

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 hmac-md5.c       |  7 +++++++
 hmac-ripemd160.c |  7 +++++++
 hmac-sha1.c      |  7 +++++++
 hmac-sha224.c    |  7 +++++++
 hmac-sha256.c    |  7 +++++++
 hmac-sha384.c    |  7 +++++++
 hmac-sha512.c    |  7 +++++++
 hmac.c           | 48 ++++++++++++++++++++++++++++++++----------------
 hmac.h           | 45 +++++++++++++++++++++++++++++++++++++++++++++
 9 files changed, 126 insertions(+), 16 deletions(-)

diff --git a/hmac-md5.c b/hmac-md5.c
index a27e64f6..b5a9c4d0 100644
--- a/hmac-md5.c
+++ b/hmac-md5.c
@@ -44,6 +44,13 @@ hmac_md5_set_key(struct hmac_md5_ctx *ctx,
   HMAC_SET_KEY(ctx, &amp;nettle_md5, key_length, key);
 }
 
+void
+hmac_md5_set_key_expanded(struct hmac_md5_ctx *ctx,
+			  const uint8_t *key)
+{
+  HMAC_SET_KEY_EXPANDED(ctx, &amp;nettle_md5, key);
+}
+
 void
 hmac_md5_update(struct hmac_md5_ctx *ctx,
 		size_t length, const uint8_t *data)
diff --git a/hmac-ripemd160.c b/hmac-ripemd160.c
index 24e2cbe7..d4ba5fea 100644
--- a/hmac-ripemd160.c
+++ b/hmac-ripemd160.c
@@ -44,6 +44,13 @@ hmac_ripemd160_set_key(struct hmac_ripemd160_ctx *ctx,
   HMAC_SET_KEY(ctx, &amp;nettle_ripemd160, key_length, key);
 }
 
+void
+hmac_ripemd160_set_key_expanded(struct hmac_ripemd160_ctx *ctx,
+				const uint8_t *key)
+{
+  HMAC_SET_KEY_EXPANDED(ctx, &amp;nettle_ripemd160, key);
+}
+
 void
 hmac_ripemd160_update(struct hmac_ripemd160_ctx *ctx,
 		      size_t length, const uint8_t *data)
diff --git a/hmac-sha1.c b/hmac-sha1.c
index 5e7188f9..3d299b5d 100644
--- a/hmac-sha1.c
+++ b/hmac-sha1.c
@@ -44,6 +44,13 @@ hmac_sha1_set_key(struct hmac_sha1_ctx *ctx,
   HMAC_SET_KEY(ctx, &amp;nettle_sha1, key_length, key);
 }
 
+void
+hmac_sha1_set_key_expanded(struct hmac_sha1_ctx *ctx,
+			   const uint8_t *key)
+{
+  HMAC_SET_KEY_EXPANDED(ctx, &amp;nettle_sha1, key);
+}
+
 void
 hmac_sha1_update(struct hmac_sha1_ctx *ctx,
 		 size_t length, const uint8_t *data)
diff --git a/hmac-sha224.c b/hmac-sha224.c
index c5bc8750..18dc3307 100644
--- a/hmac-sha224.c
+++ b/hmac-sha224.c
@@ -44,6 +44,13 @@ hmac_sha224_set_key(struct hmac_sha224_ctx *ctx,
   HMAC_SET_KEY(ctx, &amp;nettle_sha224, key_length, key);
 }
 
+void
+hmac_sha224_set_key_expanded(struct hmac_sha224_ctx *ctx,
+			     const uint8_t *key)
+{
+  HMAC_SET_KEY_EXPANDED(ctx, &amp;nettle_sha224, key);
+}
+
 void
 hmac_sha224_digest(struct hmac_sha224_ctx *ctx,
 		   size_t length, uint8_t *digest)
diff --git a/hmac-sha256.c b/hmac-sha256.c
index af5cc0f1..a89e0f6b 100644
--- a/hmac-sha256.c
+++ b/hmac-sha256.c
@@ -44,6 +44,13 @@ hmac_sha256_set_key(struct hmac_sha256_ctx *ctx,
   HMAC_SET_KEY(ctx, &amp;nettle_sha256, key_length, key);
 }
 
+void
+hmac_sha256_set_key_expanded(struct hmac_sha256_ctx *ctx,
+			     const uint8_t *key)
+{
+  HMAC_SET_KEY_EXPANDED(ctx, &amp;nettle_sha256, key);
+}
+
 void
 hmac_sha256_update(struct hmac_sha256_ctx *ctx,
 		   size_t length, const uint8_t *data)
diff --git a/hmac-sha384.c b/hmac-sha384.c
index 30008b5f..c3904053 100644
--- a/hmac-sha384.c
+++ b/hmac-sha384.c
@@ -44,6 +44,13 @@ hmac_sha384_set_key(struct hmac_sha512_ctx *ctx,
   HMAC_SET_KEY(ctx, &amp;nettle_sha384, key_length, key);
 }
 
+void
+hmac_sha384_set_key_expanded(struct hmac_sha512_ctx *ctx,
+			     const uint8_t *key)
+{
+  HMAC_SET_KEY_EXPANDED(ctx, &amp;nettle_sha384, key);
+}
+
 void
 hmac_sha384_digest(struct hmac_sha512_ctx *ctx,
 		   size_t length, uint8_t *digest)
diff --git a/hmac-sha512.c b/hmac-sha512.c
index de64637a..4fff1f35 100644
--- a/hmac-sha512.c
+++ b/hmac-sha512.c
@@ -44,6 +44,13 @@ hmac_sha512_set_key(struct hmac_sha512_ctx *ctx,
   HMAC_SET_KEY(ctx, &amp;nettle_sha512, key_length, key);
 }
 
+void
+hmac_sha512_set_key_expanded(struct hmac_sha512_ctx *ctx,
+			     const uint8_t *key)
+{
+  HMAC_SET_KEY_EXPANDED(ctx, &amp;nettle_sha512, key);
+}
+
 void
 hmac_sha512_update(struct hmac_sha512_ctx *ctx,
 		   size_t length, const uint8_t *data)
diff --git a/hmac.c b/hmac.c
index 6ac5e11a..925b9c3b 100644
--- a/hmac.c
+++ b/hmac.c
@@ -48,10 +48,10 @@
 #define IPAD 0x36
 #define OPAD 0x5c
 
-void
-hmac_set_key(void *outer, void *inner, void *state,
-	     const struct nettle_hash *hash,
-	     size_t key_length, const uint8_t *key)
+static void
+_hmac_set_key(void *outer, void *inner, void *state,
+	      const struct nettle_hash *hash,
+	      size_t key_length, const uint8_t *key)
 {
   TMP_DECL(pad, uint8_t, NETTLE_MAX_HASH_BLOCK_SIZE);
   TMP_ALLOC(pad, hash-&gt;block_size);
@@ -59,6 +59,26 @@ hmac_set_key(void *outer, void *inner, void *state,
   hash-&gt;init(outer);
   hash-&gt;init(inner);
 
+  assert(key_length &lt;= hash-&gt;block_size);
+
+  memset(pad, OPAD, hash-&gt;block_size);
+  memxor(pad, key, key_length);
+
+  hash-&gt;update(outer, hash-&gt;block_size, pad);
+
+  memset(pad, IPAD, hash-&gt;block_size);
+  memxor(pad, key, key_length);
+
+  hash-&gt;update(inner, hash-&gt;block_size, pad);
+
+  memcpy(state, inner, hash-&gt;context_size);
+}
+
+void
+hmac_set_key(void *outer, void *inner, void *state,
+	     const struct nettle_hash *hash,
+	     size_t key_length, const uint8_t *key)
+{
   if (key_length &gt; hash-&gt;block_size)
     {
       /* Reduce key to the algorithm's hash size. Use the area pointed
@@ -75,19 +95,15 @@ hmac_set_key(void *outer, void *inner, void *state,
       key_length = hash-&gt;digest_size;
     }
 
-  assert(key_length &lt;= hash-&gt;block_size);
-  
-  memset(pad, OPAD, hash-&gt;block_size);
-  memxor(pad, key, key_length);
-
-  hash-&gt;update(outer, hash-&gt;block_size, pad);
-
-  memset(pad, IPAD, hash-&gt;block_size);
-  memxor(pad, key, key_length);
-
-  hash-&gt;update(inner, hash-&gt;block_size, pad);
+  _hmac_set_key(outer, inner, state, hash, key_length, key);
+}
 
-  memcpy(state, inner, hash-&gt;context_size);
+void
+hmac_set_key_expanded(void *outer, void *inner, void *state,
+		      const struct nettle_hash *hash,
+		      const uint8_t *key)
+{
+  _hmac_set_key(outer, inner, state, hash, hash-&gt;block_size, key);
 }
 
 void
diff --git a/hmac.h b/hmac.h
index 40a8e77a..6ce17aec 100644
--- a/hmac.h
+++ b/hmac.h
@@ -47,25 +47,33 @@ extern "C" {
 
 /* Namespace mangling */
 #define hmac_set_key nettle_hmac_set_key
+#define hmac_set_key_expanded nettle_hmac_set_key_expanded
 #define hmac_update nettle_hmac_update
 #define hmac_digest nettle_hmac_digest
 #define hmac_md5_set_key nettle_hmac_md5_set_key
+#define hmac_md5_set_key_expanded nettle_hmac_md5_set_key_expanded
 #define hmac_md5_update nettle_hmac_md5_update
 #define hmac_md5_digest nettle_hmac_md5_digest
 #define hmac_ripemd160_set_key nettle_hmac_ripemd160_set_key
+#define hmac_ripemd160_set_key_expanded nettle_hmac_ripemd160_set_key_expanded
 #define hmac_ripemd160_update nettle_hmac_ripemd160_update
 #define hmac_ripemd160_digest nettle_hmac_ripemd160_digest
 #define hmac_sha1_set_key nettle_hmac_sha1_set_key
+#define hmac_sha1_set_key_expanded nettle_hmac_sha1_set_key_expanded
 #define hmac_sha1_update nettle_hmac_sha1_update
 #define hmac_sha1_digest nettle_hmac_sha1_digest
 #define hmac_sha224_set_key nettle_hmac_sha224_set_key
+#define hmac_sha224_set_key_expanded nettle_hmac_sha224_set_key_expanded
 #define hmac_sha224_digest nettle_hmac_sha224_digest
 #define hmac_sha256_set_key nettle_hmac_sha256_set_key
+#define hmac_sha256_set_key_expanded nettle_hmac_sha256_set_key_expanded
 #define hmac_sha256_update nettle_hmac_sha256_update
 #define hmac_sha256_digest nettle_hmac_sha256_digest
 #define hmac_sha384_set_key nettle_hmac_sha384_set_key
+#define hmac_sha384_set_key_expanded nettle_hmac_sha384_set_key_expanded
 #define hmac_sha384_digest nettle_hmac_sha384_digest
 #define hmac_sha512_set_key nettle_hmac_sha512_set_key
+#define hmac_sha512_set_key_expanded nettle_hmac_sha512_set_key_expanded
 #define hmac_sha512_update nettle_hmac_sha512_update
 #define hmac_sha512_digest nettle_hmac_sha512_digest
 
@@ -74,6 +82,11 @@ hmac_set_key(void *outer, void *inner, void *state,
 	     const struct nettle_hash *hash,
 	     size_t length, const uint8_t *key);
 
+void
+hmac_set_key_expanded(void *outer, void *inner, void *state,
+		      const struct nettle_hash *hash,
+		      const uint8_t *key);
+
 /* This function is not strictly needed, it's s just the same as the
  * hash update function. */
 void
@@ -94,6 +107,10 @@ hmac_digest(const void *outer, const void *inner, void *state,
   hmac_set_key( &amp;(ctx)-&gt;outer, &amp;(ctx)-&gt;inner, &amp;(ctx)-&gt;state,	\
                 (hash), (length), (key) )
 
+#define HMAC_SET_KEY_EXPANDED(ctx, hash, key)				\
+  hmac_set_key_expanded( &amp;(ctx)-&gt;outer, &amp;(ctx)-&gt;inner, &amp;(ctx)-&gt;state,	\
+                (hash), (key) )
+
 #define HMAC_DIGEST(ctx, hash, length, digest)			\
   hmac_digest( &amp;(ctx)-&gt;outer, &amp;(ctx)-&gt;inner, &amp;(ctx)-&gt;state,	\
                (hash), (length), (digest) )
@@ -107,6 +124,10 @@ void
 hmac_md5_set_key(struct hmac_md5_ctx *ctx,
 		 size_t key_length, const uint8_t *key);
 
+void
+hmac_md5_set_key_expanded(struct hmac_md5_ctx *ctx,
+			  const uint8_t *key);
+
 void
 hmac_md5_update(struct hmac_md5_ctx *ctx,
 		size_t length, const uint8_t *data);
@@ -123,6 +144,10 @@ void
 hmac_ripemd160_set_key(struct hmac_ripemd160_ctx *ctx,
 		       size_t key_length, const uint8_t *key);
 
+void
+hmac_ripemd160_set_key_expanded(struct hmac_ripemd160_ctx *ctx,
+				const uint8_t *key);
+
 void
 hmac_ripemd160_update(struct hmac_ripemd160_ctx *ctx,
 		      size_t length, const uint8_t *data);
@@ -139,6 +164,10 @@ void
 hmac_sha1_set_key(struct hmac_sha1_ctx *ctx,
 		  size_t key_length, const uint8_t *key);
 
+void
+hmac_sha1_set_key_expanded(struct hmac_sha1_ctx *ctx,
+			   const uint8_t *key);
+
 void
 hmac_sha1_update(struct hmac_sha1_ctx *ctx,
 		 size_t length, const uint8_t *data);
@@ -154,6 +183,10 @@ void
 hmac_sha256_set_key(struct hmac_sha256_ctx *ctx,
 		    size_t key_length, const uint8_t *key);
 
+void
+hmac_sha256_set_key_expanded(struct hmac_sha256_ctx *ctx,
+			     const uint8_t *key);
+
 void
 hmac_sha256_update(struct hmac_sha256_ctx *ctx,
 		   size_t length, const uint8_t *data);
@@ -169,6 +202,10 @@ void
 hmac_sha224_set_key(struct hmac_sha224_ctx *ctx,
 		    size_t key_length, const uint8_t *key);
 
+void
+hmac_sha224_set_key_expanded(struct hmac_sha224_ctx *ctx,
+			     const uint8_t *key);
+
 #define hmac_sha224_update nettle_hmac_sha256_update
 
 void
@@ -182,6 +219,10 @@ void
 hmac_sha512_set_key(struct hmac_sha512_ctx *ctx,
 		    size_t key_length, const uint8_t *key);
 
+void
+hmac_sha512_set_key_expanded(struct hmac_sha512_ctx *ctx,
+			     const uint8_t *key);
+
 void
 hmac_sha512_update(struct hmac_sha512_ctx *ctx,
 		   size_t length, const uint8_t *data);
@@ -197,6 +238,10 @@ void
 hmac_sha384_set_key(struct hmac_sha512_ctx *ctx,
 		    size_t key_length, const uint8_t *key);
 
+void
+hmac_sha384_set_key_expanded(struct hmac_sha512_ctx *ctx,
+			     const uint8_t *key);
+
 #define hmac_sha384_update nettle_hmac_sha512_update
 
 void
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190719133753</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-19 13:37:53-0400</timestampReceived><subject>[PATCH 0/7] Add meta interface for MAC algorithms</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

As discussed in:
https://lists.lysator.liu.se/pipermail/nettle-bugs/2019/007662.html

This moves `struct nettle_mac` to nettle-meta.h and provide the meta
interface for all defined MAC algorithms.

Each meta interface shall provide the following 4 functions:

  nettle_set_key_func *set_key;
  nettle_set_key_func *set_nonce;
  nettle_hash_update_func *update;
  nettle_hash_digest_func *digest;

where set_nonce is only used by UMAC, and expects that the nonce has
always the same length as AES_BLOCK_SIZE.  For CMAC and HMAC, a no-op
set_nonce function is defined.

Also the signature of set_key is slightly different from
hmac_*_set_key in that it doesn't take key length as an argument.  A
wrapper function is provided to clamp the length to hash block size.

Daiki Ueno (7):
  hmac: Add set_key_expanded function
  nettle-meta: Move struct nettle_mac to nettle-meta.h
  nettle-meta: Add meta interface for CMAC functions
  nettle-meta: Add meta interface for HMAC functions
  nettle-meta: Add meta interface for UMAC functions
  nettle-meta: Expose all defined MACs through nettle_macs
  tests: Add test for meta interface for MAC algorithms

 Makefile.in                |  7 +++-
 cmac-aes128-meta.c         | 48 ++++++++++++++++++++++
 cmac-aes256-meta.c         | 48 ++++++++++++++++++++++
 hmac-md5-meta.c            | 46 ++++++++++++++++++++++
 hmac-md5.c                 |  7 ++++
 hmac-ripemd160-meta.c      | 46 ++++++++++++++++++++++
 hmac-ripemd160.c           |  7 ++++
 hmac-sha1-meta.c           | 46 ++++++++++++++++++++++
 hmac-sha1.c                |  7 ++++
 hmac-sha224-meta.c         | 46 ++++++++++++++++++++++
 hmac-sha224.c              |  7 ++++
 hmac-sha256-meta.c         | 46 ++++++++++++++++++++++
 hmac-sha256.c              |  7 ++++
 hmac-sha384-meta.c         | 46 ++++++++++++++++++++++
 hmac-sha384.c              |  7 ++++
 hmac-sha512-meta.c         | 46 ++++++++++++++++++++++
 hmac-sha512.c              |  7 ++++
 hmac.c                     | 48 ++++++++++++++--------
 hmac.h                     | 45 +++++++++++++++++++++
 nettle-meta-macs.c         | 61 ++++++++++++++++++++++++++++
 nettle-meta.h              | 81 ++++++++++++++++++++++++++++++++++++++
 testsuite/.gitignore       |  1 +
 testsuite/.test-rules.make |  3 ++
 testsuite/Makefile.in      |  2 +-
 testsuite/cmac-test.c      | 24 -----------
 testsuite/meta-mac-test.c  | 37 +++++++++++++++++
 testsuite/testutils.h      | 29 --------------
 umac128-meta.c             | 47 ++++++++++++++++++++++
 umac32-meta.c              | 47 ++++++++++++++++++++++
 umac64-meta.c              | 47 ++++++++++++++++++++++
 umac96-meta.c              | 47 ++++++++++++++++++++++
 31 files changed, 922 insertions(+), 71 deletions(-)
 create mode 100644 cmac-aes128-meta.c
 create mode 100644 cmac-aes256-meta.c
 create mode 100644 hmac-md5-meta.c
 create mode 100644 hmac-ripemd160-meta.c
 create mode 100644 hmac-sha1-meta.c
 create mode 100644 hmac-sha224-meta.c
 create mode 100644 hmac-sha256-meta.c
 create mode 100644 hmac-sha384-meta.c
 create mode 100644 hmac-sha512-meta.c
 create mode 100644 nettle-meta-macs.c
 create mode 100644 testsuite/meta-mac-test.c
 create mode 100644 umac128-meta.c
 create mode 100644 umac32-meta.c
 create mode 100644 umac64-meta.c
 create mode 100644 umac96-meta.c

-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190702214325</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-02 21:43:25-0400</timestampReceived><subject>[PATCH] cmac: add 64-bit mode CMAC</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 cmac.c         | 125 ++++++++++++++++++++++++++++++++++++++++++++++++-
 cmac.h         |  69 +++++++++++++++++++++++++++
 nettle-types.h |   6 +++
 3 files changed, 199 insertions(+), 1 deletion(-)

diff --git a/cmac.c b/cmac.c
index 70ce8132d9d1..36ad8e58e45e 100644
--- a/cmac.c
+++ b/cmac.c
@@ -1,9 +1,10 @@
 /*
-   AES-CMAC-128 (rfc 4493)
+   AES-CMAC-128 (rfc 4493) / CMAC-64
    Copyright (C) Stefan Metzmacher 2012
    Copyright (C) Jeremy Allison 2012
    Copyright (C) Michael Adam 2012
    Copyright (C) 2017, Red Hat Inc.
+   Copyright (C) 2019, Dmitry Eremin-Solenikov
 
    This file is part of GNU Nettle.
 
@@ -57,6 +58,15 @@ _cmac128_block_mulx(union nettle_block16 *dst,
   dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
   dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) ^ (0x87 &amp; -carry);
 }
+
+static void
+block_mulx8(union nettle_block8 *dst,
+	    const union nettle_block8 *src)
+{
+  uint64_t carry = src-&gt;u64 &gt;&gt; 63;
+
+  dst-&gt;u64 = (src-&gt;u64 &lt;&lt; 1) ^ (0x1b &amp; -carry);
+}
 #else /* !WORDS_BIGENDIAN */
 #define LE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
                      (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
@@ -68,6 +78,15 @@ _cmac128_block_mulx(union nettle_block16 *dst,
   dst-&gt;u64[0] = LE_SHIFT(src-&gt;u64[0]) | ((src-&gt;u64[1] &amp; 0x80) &lt;&lt; 49);
   dst-&gt;u64[1] = LE_SHIFT(src-&gt;u64[1]) ^ (0x8700000000000000 &amp; -carry);
 }
+
+static void
+block_mulx8(union nettle_block8 *dst,
+	   const union nettle_block8 *src)
+{
+  uint64_t carry = (src-&gt;u64 &amp; 0x80) &gt;&gt; 7;
+
+  dst-&gt;u64 = LE_SHIFT(src-&gt;u64) ^ (0x1b00000000000000 &amp; -carry);
+}
 #endif /* !WORDS_BIGENDIAN */
 
 void
@@ -174,3 +193,107 @@ cmac128_digest(struct cmac128_ctx *ctx, const struct cmac128_key *key,
   /* reset state for re-use */
   cmac128_init(ctx);
 }
+
+void
+cmac64_set_key(struct cmac64_key *key, const void *cipher,
+	       nettle_cipher_func *encrypt)
+{
+  static const union nettle_block8 zero_block;
+  union nettle_block8 L;
+
+  /* step 1 - generate subkeys k1 and k2 */
+  encrypt(cipher, 8, L.b, zero_block.b);
+
+  block_mulx8(&amp;key-&gt;K1, &amp;L);
+  block_mulx8(&amp;key-&gt;K2, &amp;key-&gt;K1);
+}
+
+void
+cmac64_init(struct cmac64_ctx *ctx)
+{
+  memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
+  ctx-&gt;index = 0;
+}
+
+void
+cmac64_update(struct cmac64_ctx *ctx, const void *cipher,
+	      nettle_cipher_func *encrypt,
+	      size_t msg_len, const uint8_t *msg)
+{
+  union nettle_block16 Y;
+  /*
+   * check if we expand the block
+   */
+  if (ctx-&gt;index &lt; 8)
+    {
+      size_t len = MIN(8 - ctx-&gt;index, msg_len);
+      memcpy(&amp;ctx-&gt;block.b[ctx-&gt;index], msg, len);
+      msg += len;
+      msg_len -= len;
+      ctx-&gt;index += len;
+    }
+
+  if (msg_len == 0) {
+    /* if it is still the last block, we are done */
+    return;
+  }
+
+  /*
+   * now checksum everything but the last block
+   */
+  memxor3(Y.b, ctx-&gt;X.b, ctx-&gt;block.b, 8);
+  encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
+
+  while (msg_len &gt; 8)
+    {
+      memxor3(Y.b, ctx-&gt;X.b, msg, 8);
+      encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
+      msg += 8;
+      msg_len -= 8;
+    }
+
+  /*
+   * copy the last block, it will be processed in
+   * cmac64_digest().
+   */
+  memcpy(ctx-&gt;block.b, msg, msg_len);
+  ctx-&gt;index = msg_len;
+}
+
+void
+cmac64_digest(struct cmac64_ctx *ctx, const struct cmac64_key *key,
+	      const void *cipher, nettle_cipher_func *encrypt,
+	      unsigned length, uint8_t *dst)
+{
+  union nettle_block8 Y;
+
+  memset(ctx-&gt;block.b+ctx-&gt;index, 0, sizeof(ctx-&gt;block.b)-ctx-&gt;index);
+
+  /* re-use ctx-&gt;block for memxor output */
+  if (ctx-&gt;index &lt; 8)
+    {
+      ctx-&gt;block.b[ctx-&gt;index] = 0x80;
+      memxor(ctx-&gt;block.b, key-&gt;K2.b, 8);
+    }
+  else
+    {
+      memxor(ctx-&gt;block.b, key-&gt;K1.b, 8);
+    }
+
+  memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 8);
+
+  assert(length &lt;= 8);
+  if (length == 8)
+    {
+      encrypt(cipher, 8, dst, Y.b);
+    }
+  else
+    {
+      encrypt(cipher, 8, ctx-&gt;block.b, Y.b);
+      memcpy(dst, ctx-&gt;block.b, length);
+    }
+
+  /* reset state for re-use */
+  memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
+  ctx-&gt;index = 0;
+}
diff --git a/cmac.h b/cmac.h
index 3c5b7bea3e55..0cf9462d2120 100644
--- a/cmac.h
+++ b/cmac.h
@@ -44,6 +44,7 @@ extern "C" {
 #endif
 
 #define CMAC128_DIGEST_SIZE 16
+#define CMAC64_DIGEST_SIZE 8
 
 #define cmac128_set_key nettle_cmac128_set_key
 #define cmac128_init nettle_cmac128_init
@@ -56,6 +57,11 @@ extern "C" {
 #define cmac_aes256_update nettle_cmac_aes256_update
 #define cmac_aes256_digest nettle_cmac_aes256_digest
 
+#define cmac64_set_key nettle_cmac64_set_key
+#define cmac64_init nettle_cmac64_init
+#define cmac64_update nettle_cmac64_update
+#define cmac64_digest nettle_cmac64_digest
+
 struct cmac128_key
 {
   union nettle_block16 K1;
@@ -72,6 +78,22 @@ struct cmac128_ctx
   size_t index;
 };
 
+struct cmac64_key
+{
+  union nettle_block8 K1;
+  union nettle_block8 K2;
+};
+
+struct cmac64_ctx
+{
+  /* MAC state */
+  union nettle_block8 X;
+
+  /* Block buffer */
+  union nettle_block8 block;
+  size_t index;
+};
+
 void
 cmac128_set_key(struct cmac128_key *key, const void *cipher,
 		nettle_cipher_func *encrypt);
@@ -118,6 +140,53 @@ cmac128_digest(struct cmac128_ctx *ctx, const struct cmac128_key *key,
 		      (nettle_cipher_func *) (encrypt),		\
 		      (length), (digest)))
 
+void
+cmac64_set_key(struct cmac64_key *key, const void *cipher,
+		nettle_cipher_func *encrypt);
+
+void
+cmac64_init(struct cmac64_ctx *ctx);
+
+void
+cmac64_update(struct cmac64_ctx *ctx, const void *cipher,
+	       nettle_cipher_func *encrypt,
+	       size_t msg_len, const uint8_t *msg);
+
+void
+cmac64_digest(struct cmac64_ctx *ctx, const struct cmac64_key *key,
+	       const void *cipher, nettle_cipher_func *encrypt,
+	       unsigned length, uint8_t *digest);
+
+
+#define CMAC64_CTX(type) \
+  { struct cmac64_key key; struct cmac64_ctx ctx; type cipher; }
+
+/* NOTE: Avoid using NULL, as we don't include anything defining it. */
+#define CMAC64_SET_KEY(self, set_key, encrypt, cmac_key)	\
+  do {								\
+    (set_key)(&amp;(self)-&gt;cipher, (cmac_key));			\
+    if (0) (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,		\
+		     (uint8_t *) 0, (const uint8_t *) 0);	\
+    cmac64_set_key(&amp;(self)-&gt;key, &amp;(self)-&gt;cipher,		\
+		    (nettle_cipher_func *) (encrypt));		\
+    cmac64_init(&amp;(self)-&gt;ctx);					\
+  } while (0)
+
+#define CMAC64_UPDATE(self, encrypt, length, src)		\
+  (0 ? (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,			\
+		 (uint8_t *) 0, (const uint8_t *) 0)		\
+     : cmac64_update(&amp;(self)-&gt;ctx, &amp;(self)-&gt;cipher,		\
+		      (nettle_cipher_func *)encrypt,		\
+		      (length), (src)))
+
+#define CMAC64_DIGEST(self, encrypt, length, digest)		\
+  (0 ? (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,			\
+		 (uint8_t *) 0, (const uint8_t *) 0)		\
+     : cmac64_digest(&amp;(self)-&gt;ctx, &amp;(self)-&gt;key,		\
+		      &amp;(self)-&gt;cipher,				\
+		      (nettle_cipher_func *) (encrypt),		\
+		      (length), (digest)))
+
 struct cmac_aes128_ctx CMAC128_CTX(struct aes128_ctx);
 
 void
diff --git a/nettle-types.h b/nettle-types.h
index 87292ac69730..5addf3600d69 100644
--- a/nettle-types.h
+++ b/nettle-types.h
@@ -65,6 +65,12 @@ union nettle_block16
   uint64_t u64[2];
 };
 
+union nettle_block8
+{
+  uint8_t b[8];
+  uint64_t u64;
+};
+
 /* Randomness. Used by key generation and dsa signature creation. */
 typedef void nettle_random_func(void *ctx,
 				size_t length, uint8_t *dst);
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190722085309</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-22 08:53:09-0400</timestampReceived><subject>[PATCH v2 0/6] Add meta interface for MAC algorithms</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

The changes from the previous series are:
- remove the global hmac_*_set_key_expanded functions
- leave out set_nonce member if the operation is not supported

For the latter, I was wondering whether it is better to define a no-op
set_nonce, but given the fact that that the caller nevertheless checks
nonce_size, I chose to make the field blank.

Daiki Ueno (6):
  nettle-meta: Move struct nettle_mac to nettle-meta.h
  nettle-meta: Add meta interface for CMAC functions
  nettle-meta: Add meta interface for HMAC functions
  nettle-meta: Add meta interface for UMAC functions
  nettle-meta: Expose all defined MACs through nettle_macs
  tests: Add test for meta interface for MAC algorithms

 Makefile.in                |  7 +++-
 cmac-aes128-meta.c         | 43 ++++++++++++++++++++
 cmac-aes256-meta.c         | 43 ++++++++++++++++++++
 hmac-md5-meta.c            | 47 ++++++++++++++++++++++
 hmac-ripemd160-meta.c      | 47 ++++++++++++++++++++++
 hmac-sha1-meta.c           | 47 ++++++++++++++++++++++
 hmac-sha224-meta.c         | 47 ++++++++++++++++++++++
 hmac-sha256-meta.c         | 47 ++++++++++++++++++++++
 hmac-sha384-meta.c         | 47 ++++++++++++++++++++++
 hmac-sha512-meta.c         | 47 ++++++++++++++++++++++
 nettle-meta-macs.c         | 61 ++++++++++++++++++++++++++++
 nettle-meta.h              | 81 ++++++++++++++++++++++++++++++++++++++
 testsuite/.gitignore       |  1 +
 testsuite/.test-rules.make |  3 ++
 testsuite/Makefile.in      |  2 +-
 testsuite/cmac-test.c      | 24 -----------
 testsuite/meta-mac-test.c  | 43 ++++++++++++++++++++
 testsuite/testutils.h      | 29 --------------
 umac128-meta.c             | 47 ++++++++++++++++++++++
 umac32-meta.c              | 47 ++++++++++++++++++++++
 umac64-meta.c              | 47 ++++++++++++++++++++++
 umac96-meta.c              | 47 ++++++++++++++++++++++
 22 files changed, 799 insertions(+), 55 deletions(-)
 create mode 100644 cmac-aes128-meta.c
 create mode 100644 cmac-aes256-meta.c
 create mode 100644 hmac-md5-meta.c
 create mode 100644 hmac-ripemd160-meta.c
 create mode 100644 hmac-sha1-meta.c
 create mode 100644 hmac-sha224-meta.c
 create mode 100644 hmac-sha256-meta.c
 create mode 100644 hmac-sha384-meta.c
 create mode 100644 hmac-sha512-meta.c
 create mode 100644 nettle-meta-macs.c
 create mode 100644 testsuite/meta-mac-test.c
 create mode 100644 umac128-meta.c
 create mode 100644 umac32-meta.c
 create mode 100644 umac64-meta.c
 create mode 100644 umac96-meta.c

-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190716145801</emailId><senderName>Justus Winter</senderName><senderEmail>justus@sequoia-pgp.org</senderEmail><timestampReceived>2019-07-16 14:58:01-0400</timestampReceived><subject>Some .stamp files slipped into the tarball</subject><body>

[Attachment #2 (multipart/signed)]


Hi :)

just a small bug report, there are some .stamp files that got included
in the release by accident.  I noticed because it caused build problems,
likely only due to the fact that my build process copied the files once,
changing the mtimes in the process.

    % tar tf nettle-3.5.1.tar.gz | grep '\.stamp$'
    nettle-3.5.1/testsuite/test-rules.stamp
    nettle-3.5.1/desdata.stamp


Cheers,
Justus

["signature.asc" (application/pgp-signature)]
[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190717075505</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-17 07:55:05-0400</timestampReceived><subject>Re: Some .stamp files slipped into the tarball</subject><body>

Justus Winter &lt;justus@sequoia-pgp.org&gt; writes:

&gt; just a small bug report, there are some .stamp files that got included
&gt; in the release by accident.  I noticed because it caused build problems,
&gt; likely only due to the fact that my build process copied the files once,
&gt; changing the mtimes in the process.

Some stamp files are included intentionally, to avoid precisely that
type of problems. See the note on stamp-h.in in the autoconf manual for
one well documented example:
https://www.gnu.org/software/autoconf//manual/autoconf-2.64/html_node/Automatic-Remaking.html

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190717083142</emailId><senderName>Justus Winter</senderName><senderEmail>justus@sequoia-pgp.org</senderEmail><timestampReceived>2019-07-17 08:31:42-0400</timestampReceived><subject>Re: Some .stamp files slipped into the tarball</subject><body>

[Attachment #2 (multipart/signed)]


nisse@lysator.liu.se (Niels Möller) writes:

&gt; Justus Winter &lt;justus@sequoia-pgp.org&gt; writes:
&gt;
&gt;&gt; just a small bug report, there are some .stamp files that got included
&gt;&gt; in the release by accident.  I noticed because it caused build problems,
&gt;&gt; likely only due to the fact that my build process copied the files once,
&gt;&gt; changing the mtimes in the process.
&gt;
&gt; Some stamp files are included intentionally, to avoid precisely that
&gt; type of problems. See the note on stamp-h.in in the autoconf manual for
&gt; one well documented example:
&gt; https://www.gnu.org/software/autoconf//manual/autoconf-2.64/html_node/Automatic-Remaking.html

I read the reference, and I don't see how it applies here.  For the
record, this is the build failure that I'm referring to:

% tar xf nettle-3.5.1.tar.gz
% cp -r nettle-3.5.1 nettle
% cd nettle
% ./configure
[...]
% make
[...]
f="./`basename rotors.h`"; \
  ./desdata rotors.h &gt; ${f}T; \
  test -s ${f}T &amp;&amp; mv -f ${f}T $f
/bin/sh: 2: ./desdata: not found
make[1]: *** [Makefile:327: rotors.h] Error 1
make[1]: Leaving directory '/tmp/foo/nettle'
make: *** [Makefile:46: all] Error 2


Cheers,
Justus

["signature.asc" (application/pgp-signature)]
[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190717185629</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-17 18:56:29-0400</timestampReceived><subject>Re: Some .stamp files slipped into the tarball</subject><body>

Justus Winter &lt;justus@sequoia-pgp.org&gt; writes:

&gt; I read the reference, and I don't see how it applies here.

Right, it's a bit different.

&gt; For the
&gt; record, this is the build failure that I'm referring to:
&gt;
&gt; % tar xf nettle-3.5.1.tar.gz
&gt; % cp -r nettle-3.5.1 nettle
&gt; % cd nettle
&gt; % ./configure
&gt; [...]
&gt; % make
&gt; [...]
&gt; f="./`basename rotors.h`"; \
&gt;   ./desdata rotors.h &gt; ${f}T; \
&gt;   test -s ${f}T &amp;&amp; mv -f ${f}T $f
&gt; /bin/sh: 2: ./desdata: not found

This is a bit subtle, and maybe it can be improved. Let me explain how
it's supposed to work.

rotors.h and keymap.h are generated by the desdata program, built from
the desdata.c source file. They're not platform dependent in any way, so
they're distributed with the tarball. When building from the tarball,
there's no need to regenerate them, and the desdata program isn't built.

Now dependencies for this is a bit tricky. One obvious alternative is

  rotors.h: desdata
	./desdata ...

That has the drawback that it will needlessly build desdata and regenerate the
files when building from a tarball, since the desdata executable
obviously shouldn't be in the tarball. Another alternative is

  rotors.h: desdata.c
	$(MAKE) desdata
        ./desdata ...

That breaks make -j, because if rotors.h and keymap.h are regenerated in
parallel, we'll get two processes trying to build and run desdata at the
same time, resulting in spurious errors.

Hence the redirection via desdata.stamp, to ensure that we only have one
process building desdata. And now it seems that results in a failure if
the build directory is in the state that desdata.stamp is newer than
both desdata.c and rotors.h and but ./desdata doesn't exist.

Not sure how to fix that. A workaround is to copy with cp -a, which
ensures that you won't attempt to rebuild *any* of the generated files
in the tarball, including config.h.in and configure. Might also help a
bit to reorder the files in the tarball, but I wouldn't recommend
depending on that.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190718092939</emailId><senderName>Justus Winter</senderName><senderEmail>justus@sequoia-pgp.org</senderEmail><timestampReceived>2019-07-18 09:29:39-0400</timestampReceived><subject>Re: Some .stamp files slipped into the tarball</subject><body>

[Attachment #2 (multipart/signed)]


nisse@lysator.liu.se (Niels Möller) writes:

&gt; Justus Winter &lt;justus@sequoia-pgp.org&gt; writes:
&gt;
&gt;&gt; I read the reference, and I don't see how it applies here.
&gt;
&gt; Right, it's a bit different.
&gt;
&gt;&gt; For the
&gt;&gt; record, this is the build failure that I'm referring to:
&gt;&gt;
&gt;&gt; % tar xf nettle-3.5.1.tar.gz
&gt;&gt; % cp -r nettle-3.5.1 nettle
&gt;&gt; % cd nettle
&gt;&gt; % ./configure
&gt;&gt; [...]
&gt;&gt; % make
&gt;&gt; [...]
&gt;&gt; f="./`basename rotors.h`"; \
&gt;&gt;   ./desdata rotors.h &gt; ${f}T; \
&gt;&gt;   test -s ${f}T &amp;&amp; mv -f ${f}T $f
&gt;&gt; /bin/sh: 2: ./desdata: not found
&gt;
&gt; This is a bit subtle, and maybe it can be improved. Let me explain how
&gt; it's supposed to work.
&gt;
&gt; rotors.h and keymap.h are generated by the desdata program, built from
&gt; the desdata.c source file. They're not platform dependent in any way, so
&gt; they're distributed with the tarball. When building from the tarball,
&gt; there's no need to regenerate them, and the desdata program isn't built.

I understand the part of the files being generated by the helper, and
the role the .stamp file has in this.  What I don't understand is the
desire to generate them at package time, because surely it isn't that
expensive.  Yes, you have to be a bit careful in the case of
cross-compilation, but that should be doable.

&gt; Hence the redirection via desdata.stamp, to ensure that we only have one
&gt; process building desdata. And now it seems that results in a failure if
&gt; the build directory is in the state that desdata.stamp is newer than
&gt; both desdata.c and rotors.h and but ./desdata doesn't exist.
&gt;
&gt; Not sure how to fix that. A workaround is to copy with cp -a, which
&gt; ensures that you won't attempt to rebuild *any* of the generated files
&gt; in the tarball, including config.h.in and configure. Might also help a
&gt; bit to reorder the files in the tarball, but I wouldn't recommend
&gt; depending on that.

I understand how changing the timestamps breaks this mechanism.  And the
build system I adopted doesn't actually use cp, I just demonstrated the
problem using cp.  Therefore, it is not as easy as using -a instead of
-r.

In any case, I'm just going to delete any .stamp files in my build
process.  And I wanted to be a good downstream user and report what I
perceived as a packaging hickup.


Cheers,
Justus

["signature.asc" (application/pgp-signature)]
[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190914104745</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-14 10:47:45-0400</timestampReceived><subject>Re: [PATCH v2 0/6] Add meta interface for MAC algorithms</subject><body>

Daiki Ueno &lt;ueno@gnu.org&gt; writes:

&gt; From: Daiki Ueno &lt;dueno@redhat.com&gt;
&gt;
&gt; The changes from the previous series are:
&gt; - remove the global hmac_*_set_key_expanded functions
&gt; - leave out set_nonce member if the operation is not supported
&gt;
&gt; For the latter, I was wondering whether it is better to define a no-op
&gt; set_nonce, but given the fact that that the caller nevertheless checks
&gt; nonce_size, I chose to make the field blank.

I'm a bit uneasy about the set_nonce pointer. It's used only for umac,
where nonce use is a bit peculiar with the auto-increment optimization.

Would it be ok to leave umac out, and move the definition of nettle_mac
from testutils.h as is (except that the comment "other sizes are
sometimes possible" on the key_size field seems wrong)?

Then nettle_mac is very similar to nettle_hash, one just calls -&gt;set_key
instead of -&gt;init, and one can then hash several messages with the same
key using a sequence of -&gt;update and -&gt;digest calls.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190914192955</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-09-14 19:29:55-0400</timestampReceived><subject>Re: [PATCH v2 0/6] Add meta interface for MAC algorithms</subject><body>

сб, 14 сент. 2019 г. в 13:47, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Daiki Ueno &lt;ueno@gnu.org&gt; writes:
&gt;
&gt; &gt; From: Daiki Ueno &lt;dueno@redhat.com&gt;
&gt; &gt;
&gt; &gt; The changes from the previous series are:
&gt; &gt; - remove the global hmac_*_set_key_expanded functions
&gt; &gt; - leave out set_nonce member if the operation is not supported
&gt; &gt;
&gt; &gt; For the latter, I was wondering whether it is better to define a no-op
&gt; &gt; set_nonce, but given the fact that that the caller nevertheless checks
&gt; &gt; nonce_size, I chose to make the field blank.
&gt;
&gt; I'm a bit uneasy about the set_nonce pointer. It's used only for umac,
&gt; where nonce use is a bit peculiar with the auto-increment optimization.
&gt;
&gt; Would it be ok to leave umac out, and move the definition of nettle_mac
&gt; from testutils.h as is (except that the comment "other sizes are
&gt; sometimes possible" on the key_size field seems wrong)?

There will be a nonce for GMAC.

&gt; Then nettle_mac is very similar to nettle_hash, one just calls -&gt;set_key
&gt; instead of -&gt;init, and one can then hash several messages with the same
&gt; key using a sequence of -&gt;update and -&gt;digest calls.
&gt;
&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
&gt; Internet email is subject to wholesale government surveillance.
&gt; _______________________________________________
&gt; nettle-bugs mailing list
&gt; nettle-bugs@lists.lysator.liu.se
&gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs



-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190915072850</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-15 07:28:50-0400</timestampReceived><subject>Re: [PATCH v2 0/6] Add meta interface for MAC algorithms</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; There will be a nonce for GMAC.

Ok. If we keep set_nonce, we have to clarify what it means. There are a
couple of cases, where the first two are relatively easy.

nonce_size == 0, set_nonce == NULL: 
  Never call set_nonce. This is the HMAC case.

nonce_size == 0, set_nonce != NULL:
  This could mean that nonce is optional. Does that make any sense?

nonce_size &gt; 0, set_nonce != NULL:
  Would then be used for UMAC and GMAC.

For the last case, I have a couple of questions.

1. Comment says "suggested nonce_size", but I take it only that one size
   is possible, since set_nonce is nettle_set_key_func, with no length
   argument. Or do you intend to allow other sizes? 

   I think I'd prefer fix size, to keep things simple. And treat
   variants with different nonce size as separate mac algorithms, for
   this abstraction. Just like with the key size.

2. What should be the behavior for usage like

   -&gt;set_key
   -&gt;set_nonce
   -&gt;update
   -&gt;digest
   -&gt;update
   -&gt;digest

   with second set_nonce missing? 

   Should it just keep the nonce from the first digest? (Sounds a bit
   dangerous). Or autoincrement? (That's what umac does, because it's
   defined in a way to make that more efficient). Or be specified as
   invalid, triggering asserts whenever it is easy to detect?

   I think it has to be specified; it will be too confusing if UMAC
   behaves in one way and GMAC behaves differently.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190916084616</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-09-16 08:46:16-0400</timestampReceived><subject>Re: [PATCH v2 0/6] Add meta interface for MAC algorithms</subject><body>

Hello,

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt;&gt; There will be a nonce for GMAC.
&gt;
&gt; Ok. If we keep set_nonce, we have to clarify what it means. There are a
&gt; couple of cases, where the first two are relatively easy.
&gt;
&gt; nonce_size == 0, set_nonce == NULL: 
&gt;   Never call set_nonce. This is the HMAC case.
&gt;
&gt; nonce_size == 0, set_nonce != NULL:
&gt;   This could mean that nonce is optional. Does that make any sense?
&gt;
&gt; nonce_size &gt; 0, set_nonce != NULL:
&gt;   Would then be used for UMAC and GMAC.
&gt;
&gt; For the last case, I have a couple of questions.
&gt;
&gt; 1. Comment says "suggested nonce_size", but I take it only that one size
&gt;    is possible, since set_nonce is nettle_set_key_func, with no length
&gt;    argument. Or do you intend to allow other sizes? 
&gt;
&gt;    I think I'd prefer fix size, to keep things simple. And treat
&gt;    variants with different nonce size as separate mac algorithms, for
&gt;    this abstraction. Just like with the key size.

I think fixed size would be sufficient (the code was merely copied from
the nettle_aead definition).

&gt; 2. What should be the behavior for usage like
&gt;
&gt;    -&gt;set_key
&gt;    -&gt;set_nonce
&gt;    -&gt;update
&gt;    -&gt;digest
&gt;    -&gt;update
&gt;    -&gt;digest
&gt;
&gt;    with second set_nonce missing? 
&gt;
&gt;    Should it just keep the nonce from the first digest? (Sounds a bit
&gt;    dangerous). Or autoincrement? (That's what umac does, because it's
&gt;    defined in a way to make that more efficient). Or be specified as
&gt;    invalid, triggering asserts whenever it is easy to detect?
&gt;
&gt;    I think it has to be specified; it will be too confusing if UMAC
&gt;    behaves in one way and GMAC behaves differently.

Provided that the two types of MACs (nonces are required or not) are
supposedly not intermixed, another option might be to provide a separate
struct (say, nettle_nmac) for MACs that require nonces (UMAC and GMAC,
not sure if there will be more to come), and mandate set_nonce != NULL:

- nettle_mac (from the testutils.h definition) for HMAC, CMAC
- nettle_nmac (nettle_nmac + set_nonce) for UMAC, GMAC

That would be analogous to the distinction between nettle_cipher and
nettle_aead and serve the documentation.

Regards,
-- 
Daiki Ueno
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190916090114</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-09-16 09:01:14-0400</timestampReceived><subject>Re: [PATCH v2 0/6] Add meta interface for MAC algorithms</subject><body>

вс, 15 сент. 2019 г. в 10:28, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; There will be a nonce for GMAC.
&gt;
&gt; Ok. If we keep set_nonce, we have to clarify what it means. There are a
&gt; couple of cases, where the first two are relatively easy.
&gt;
&gt; nonce_size == 0, set_nonce == NULL:
&gt;   Never call set_nonce. This is the HMAC case.

Fine with me

&gt;
&gt; nonce_size == 0, set_nonce != NULL:
&gt;   This could mean that nonce is optional. Does that make any sense?

I don't think we should allow such constructions. Neither UMAC nor GMAC
make optional use of nonce. And if we think further, 3GPP MAC algorithms,
which make use of nonce, also have non-optional fixed size nonce.

&gt;
&gt; nonce_size &gt; 0, set_nonce != NULL:
&gt;   Would then be used for UMAC and GMAC.

Fine with me


&gt;
&gt; For the last case, I have a couple of questions.
&gt;
&gt; 1. Comment says "suggested nonce_size", but I take it only that one size
&gt;    is possible, since set_nonce is nettle_set_key_func, with no length
&gt;    argument. Or do you intend to allow other sizes?
&gt;
&gt;    I think I'd prefer fix size, to keep things simple. And treat
&gt;    variants with different nonce size as separate mac algorithms, for
&gt;    this abstraction. Just like with the key size.

Fix size. If one needs variable nonce size, he can use full interface.

&gt; 2. What should be the behavior for usage like
&gt;
&gt;    -&gt;set_key
&gt;    -&gt;set_nonce
&gt;    -&gt;update
&gt;    -&gt;digest
&gt;    -&gt;update
&gt;    -&gt;digest
&gt;
&gt;    with second set_nonce missing?
&gt;
&gt;    Should it just keep the nonce from the first digest? (Sounds a bit
&gt;    dangerous). Or autoincrement? (That's what umac does, because it's
&gt;    defined in a way to make that more efficient). Or be specified as
&gt;    invalid, triggering asserts whenever it is easy to detect?
&gt;
&gt;    I think it has to be specified; it will be too confusing if UMAC
&gt;    behaves in one way and GMAC behaves differently.

I'd say that this is an undefined behaviour. So, if one needs fully
predictable result, he should set nonce each time. For GMAC nonce MUST
be set each time to a new value. For UMAC one can skip this call. We
might want to refine this UB later.

Consider other MACs (like Kasumi F8/Snow3G UIA2/ZUC EIA3) which
require nonce, can have nonce autoincrement, but with complex rules.

BTW: I have written a library with 3GPP encryption/integrity
alogorithms. The library follow closely Nettle interface. I can
publish it and/or submit into nettle for inclusion. However I am
completely unsure about patent status and enforcement for those
algorithms. Do you know if somebody can advice me on this topic?

--
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190918044330</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-18 04:43:30-0400</timestampReceived><subject>Re: [PATCH v2 0/6] Add meta interface for MAC algorithms</subject><body>

Daiki Ueno &lt;ueno@gnu.org&gt; writes:

&gt;&gt; 1. Comment says "suggested nonce_size", but I take it only that one size
&gt;&gt;    is possible, since set_nonce is nettle_set_key_func, with no length
&gt;&gt;    argument. Or do you intend to allow other sizes? 
&gt;&gt;
&gt;&gt;    I think I'd prefer fix size, to keep things simple. And treat
&gt;&gt;    variants with different nonce size as separate mac algorithms, for
&gt;&gt;    this abstraction. Just like with the key size.
&gt;
&gt; I think fixed size would be sufficient (the code was merely copied from
&gt; the nettle_aead definition).

Good.

&gt; Provided that the two types of MACs (nonces are required or not) are
&gt; supposedly not intermixed, another option might be to provide a separate
&gt; struct (say, nettle_nmac) for MACs that require nonces (UMAC and GMAC,
&gt; not sure if there will be more to come), and mandate set_nonce != NULL:
&gt;
&gt; - nettle_mac (from the testutils.h definition) for HMAC, CMAC
&gt; - nettle_nmac (nettle_nmac + set_nonce) for UMAC, GMAC

Makes sense. One would then only need a good name. Is there any standard
terminology distinguishing between these two variants? But I'm fine with
a single struct, provided that it's clearly specified how the set_nonce
call is expected to be used.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190918053839</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-18 05:38:39-0400</timestampReceived><subject>Re: [PATCH v2 0/6] Add meta interface for MAC algorithms</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt;&gt; 2. What should be the behavior for usage like
&gt;&gt;
&gt;&gt;    -&gt;set_key
&gt;&gt;    -&gt;set_nonce
&gt;&gt;    -&gt;update
&gt;&gt;    -&gt;digest
&gt;&gt;    -&gt;update
&gt;&gt;    -&gt;digest
&gt;&gt;
&gt;&gt;    with second set_nonce missing?
&gt;&gt;
&gt;&gt;    Should it just keep the nonce from the first digest? (Sounds a bit
&gt;&gt;    dangerous). Or autoincrement? (That's what umac does, because it's
&gt;&gt;    defined in a way to make that more efficient). Or be specified as
&gt;&gt;    invalid, triggering asserts whenever it is easy to detect?
&gt;&gt;
&gt;&gt;    I think it has to be specified; it will be too confusing if UMAC
&gt;&gt;    behaves in one way and GMAC behaves differently.
&gt;
&gt; I'd say that this is an undefined behaviour. So, if one needs fully
&gt; predictable result, he should set nonce each time. For GMAC nonce MUST
&gt; be set each time to a new value. For UMAC one can skip this call. We
&gt; might want to refine this UB later.

I would prefer to have it nailed down. It kind-of defeats the purpose of
a nettle_mac abstraction if code using it is expected to have if (umac)
{ do this } else { do that }.

&gt; Consider other MACs (like Kasumi F8/Snow3G UIA2/ZUC EIA3) which
&gt; require nonce, can have nonce autoincrement, but with complex rules.

Complex how? If it is a common usecase, one could consider to either do
auto-increment always (part of -&gt;digest, like currently done for umac),
or have a separate method increment_nonce or so.

&gt; BTW: I have written a library with 3GPP encryption/integrity
&gt; alogorithms. The library follow closely Nettle interface. I can
&gt; publish it and/or submit into nettle for inclusion. However I am
&gt; completely unsure about patent status and enforcement for those
&gt; algorithms. Do you know if somebody can advice me on this topic?

It's time consuming to research patent status (and usually impossibly to
reach certainty). Maybe you could ask FSF or sfconservancy lawyers, and
say you consider contributing an implementation to GNU Nettle, but I
doubt they have the resources to do a thorough investigation. If you
know the patent holders, you could mail and ask them, or check if
there's any general patent policy for 3GPP members. Reviewing any
licensing terms they offer should be an easier task for FSF lawyers than
a more open-ended patent investigation.

Regards,
/Niels
-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191115083558</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-11-15 08:35:58-0400</timestampReceived><subject>Re: [PATCH v2 0/6] Add meta interface for MAC algorithms</subject><body>

Hello,

ср, 18 сент. 2019 г. в 08:38, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt;&gt; 2. What should be the behavior for usage like
&gt; &gt;&gt;
&gt; &gt;&gt;    -&gt;set_key
&gt; &gt;&gt;    -&gt;set_nonce
&gt; &gt;&gt;    -&gt;update
&gt; &gt;&gt;    -&gt;digest
&gt; &gt;&gt;    -&gt;update
&gt; &gt;&gt;    -&gt;digest
&gt; &gt;&gt;
&gt; &gt;&gt;    with second set_nonce missing?
&gt; &gt;&gt;
&gt; &gt;&gt;    Should it just keep the nonce from the first digest? (Sounds a bit
&gt; &gt;&gt;    dangerous). Or autoincrement? (That's what umac does, because it's
&gt; &gt;&gt;    defined in a way to make that more efficient). Or be specified as
&gt; &gt;&gt;    invalid, triggering asserts whenever it is easy to detect?
&gt; &gt;&gt;
&gt; &gt;&gt;    I think it has to be specified; it will be too confusing if UMAC
&gt; &gt;&gt;    behaves in one way and GMAC behaves differently.
&gt; &gt;
&gt; &gt; I'd say that this is an undefined behaviour. So, if one needs fully
&gt; &gt; predictable result, he should set nonce each time. For GMAC nonce MUST
&gt; &gt; be set each time to a new value. For UMAC one can skip this call. We
&gt; &gt; might want to refine this UB later.
&gt;
&gt; I would prefer to have it nailed down. It kind-of defeats the purpose of
&gt; a nettle_mac abstraction if code using it is expected to have if (umac)
&gt; { do this } else { do that }.

I'd propose then that if one uses generic interface, he MUST set nonce
each time. If one wishes to use auto-increment option of UMAC, he is
already tied to UMAC and thus doesn't have to use generic interface at
all.

&gt; &gt; Consider other MACs (like Kasumi F8/Snow3G UIA2/ZUC EIA3) which
&gt; &gt; require nonce, can have nonce autoincrement, but with complex rules.
&gt;
&gt; Complex how? If it is a common usecase, one could consider to either do
&gt; auto-increment always (part of -&gt;digest, like currently done for umac),
&gt; or have a separate method increment_nonce or so.

Complex as incrementing a value in the middle of nonce by the amount
of bytes processed in the call. Again I think now, that it might be
easier to demand calling set_nonce when using generic interface.

&gt; &gt; BTW: I have written a library with 3GPP encryption/integrity
&gt; &gt; alogorithms. The library follow closely Nettle interface. I can
&gt; &gt; publish it and/or submit into nettle for inclusion. However I am
&gt; &gt; completely unsure about patent status and enforcement for those
&gt; &gt; algorithms. Do you know if somebody can advice me on this topic?
&gt;
&gt; It's time consuming to research patent status (and usually impossibly to
&gt; reach certainty). Maybe you could ask FSF or sfconservancy lawyers, and
&gt; say you consider contributing an implementation to GNU Nettle, but I
&gt; doubt they have the resources to do a thorough investigation. If you
&gt; know the patent holders, you could mail and ask them, or check if
&gt; there's any general patent policy for 3GPP members. Reviewing any
&gt; licensing terms they offer should be an easier task for FSF lawyers than
&gt; a more open-ended patent investigation.

I have received no significant response from FSF, FSFE and
sconservancy (maybe I was asking a wrong question though). Just
typical "patent research is costly and we do not do consulting".
Anyway, patent licenses are explicit about using these algorithms to
only implement actual 3GPP/LTE support. So they should not target
generic library.


-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190708215641</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-08 21:56:41-0400</timestampReceived><subject>Re: [PATCH] cmac: add 64-bit mode CMAC</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt; ---
&gt;  cmac.c         | 125 ++++++++++++++++++++++++++++++++++++++++++++++++-
&gt;  cmac.h         |  69 +++++++++++++++++++++++++++
&gt;  nettle-types.h |   6 +++
&gt;  3 files changed, 199 insertions(+), 1 deletion(-)
&gt;
&gt; diff --git a/cmac.c b/cmac.c
&gt; index 70ce8132d9d1..36ad8e58e45e 100644
&gt; --- a/cmac.c
&gt; +++ b/cmac.c
&gt; @@ -1,9 +1,10 @@
&gt;  /*
&gt; -   AES-CMAC-128 (rfc 4493)
&gt; +   AES-CMAC-128 (rfc 4493) / CMAC-64
&gt;     Copyright (C) Stefan Metzmacher 2012
&gt;     Copyright (C) Jeremy Allison 2012
&gt;     Copyright (C) Michael Adam 2012
&gt;     Copyright (C) 2017, Red Hat Inc.
&gt; +   Copyright (C) 2019, Dmitry Eremin-Solenikov
&gt;  
&gt;     This file is part of GNU Nettle.
&gt;  
&gt; @@ -57,6 +58,15 @@ _cmac128_block_mulx(union nettle_block16 *dst,
&gt;    dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
&gt;    dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) ^ (0x87 &amp; -carry);
&gt;  }
&gt; +
&gt; +static void
&gt; +block_mulx8(union nettle_block8 *dst,
&gt; +	    const union nettle_block8 *src)
&gt; +{
&gt; +  uint64_t carry = src-&gt;u64 &gt;&gt; 63;
&gt; +
&gt; +  dst-&gt;u64 = (src-&gt;u64 &lt;&lt; 1) ^ (0x1b &amp; -carry);
&gt; +}
&gt;  #else /* !WORDS_BIGENDIAN */
&gt;  #define LE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
&gt;                       (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
&gt; @@ -68,6 +78,15 @@ _cmac128_block_mulx(union nettle_block16 *dst,
&gt;    dst-&gt;u64[0] = LE_SHIFT(src-&gt;u64[0]) | ((src-&gt;u64[1] &amp; 0x80) &lt;&lt; 49);
&gt;    dst-&gt;u64[1] = LE_SHIFT(src-&gt;u64[1]) ^ (0x8700000000000000 &amp; -carry);
&gt;  }

Patch looks nice, thanks! Is any of the implementation shared with
cmac128? I think it would be nice to move it to a separate source file
cmac64.c. Sharing the cmac.h header file is fine.

BTW, I'm sorry for the duplicated effort on nettle_block16 w; I'm
traveling and online only sporadically, so I gave it a try without being
up to date with your work.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190709185733</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-09 18:57:33-0400</timestampReceived><subject>Re: [PATCH] cmac: add 64-bit mode CMAC</subject><body>

Hello,

вт, 9 июл. 2019 г. в 00:56, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; Patch looks nice, thanks! Is any of the implementation shared with
&gt; cmac128? I think it would be nice to move it to a separate source file
&gt; cmac64.c. Sharing the cmac.h header file is fine.

It shares LE_SHIFT(). I'll resend this patch as a followup.

&gt; BTW, I'm sorry for the duplicated effort on nettle_block16 w; I'm
&gt; traveling and online only sporadically, so I gave it a try without being
&gt; up to date with your work.

No problem. Now you have two proposals and can compare them ;-)

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190709185842</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-09 18:58:42-0400</timestampReceived><subject>[PATCH] cmac: add 64-bit mode CMAC</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in    |   2 +-
 cmac.h         |  69 +++++++++++++++++++
 cmac64.c       | 177 +++++++++++++++++++++++++++++++++++++++++++++++++
 nettle-types.h |   6 ++
 4 files changed, 253 insertions(+), 1 deletion(-)
 create mode 100644 cmac64.c

diff --git a/Makefile.in b/Makefile.in
index b54e64b053c3..bad2baf3a29e 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -102,7 +102,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-aes256.c gcm-aes256-meta.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
-		 cmac.c cmac-aes128.c cmac-aes256.c \
+		 cmac.c cmac64.c cmac-aes128.c cmac-aes256.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
diff --git a/cmac.h b/cmac.h
index 3c5b7bea3e55..0cf9462d2120 100644
--- a/cmac.h
+++ b/cmac.h
@@ -44,6 +44,7 @@ extern "C" {
 #endif
 
 #define CMAC128_DIGEST_SIZE 16
+#define CMAC64_DIGEST_SIZE 8
 
 #define cmac128_set_key nettle_cmac128_set_key
 #define cmac128_init nettle_cmac128_init
@@ -56,6 +57,11 @@ extern "C" {
 #define cmac_aes256_update nettle_cmac_aes256_update
 #define cmac_aes256_digest nettle_cmac_aes256_digest
 
+#define cmac64_set_key nettle_cmac64_set_key
+#define cmac64_init nettle_cmac64_init
+#define cmac64_update nettle_cmac64_update
+#define cmac64_digest nettle_cmac64_digest
+
 struct cmac128_key
 {
   union nettle_block16 K1;
@@ -72,6 +78,22 @@ struct cmac128_ctx
   size_t index;
 };
 
+struct cmac64_key
+{
+  union nettle_block8 K1;
+  union nettle_block8 K2;
+};
+
+struct cmac64_ctx
+{
+  /* MAC state */
+  union nettle_block8 X;
+
+  /* Block buffer */
+  union nettle_block8 block;
+  size_t index;
+};
+
 void
 cmac128_set_key(struct cmac128_key *key, const void *cipher,
 		nettle_cipher_func *encrypt);
@@ -118,6 +140,53 @@ cmac128_digest(struct cmac128_ctx *ctx, const struct cmac128_key *key,
 		      (nettle_cipher_func *) (encrypt),		\
 		      (length), (digest)))
 
+void
+cmac64_set_key(struct cmac64_key *key, const void *cipher,
+		nettle_cipher_func *encrypt);
+
+void
+cmac64_init(struct cmac64_ctx *ctx);
+
+void
+cmac64_update(struct cmac64_ctx *ctx, const void *cipher,
+	       nettle_cipher_func *encrypt,
+	       size_t msg_len, const uint8_t *msg);
+
+void
+cmac64_digest(struct cmac64_ctx *ctx, const struct cmac64_key *key,
+	       const void *cipher, nettle_cipher_func *encrypt,
+	       unsigned length, uint8_t *digest);
+
+
+#define CMAC64_CTX(type) \
+  { struct cmac64_key key; struct cmac64_ctx ctx; type cipher; }
+
+/* NOTE: Avoid using NULL, as we don't include anything defining it. */
+#define CMAC64_SET_KEY(self, set_key, encrypt, cmac_key)	\
+  do {								\
+    (set_key)(&amp;(self)-&gt;cipher, (cmac_key));			\
+    if (0) (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,		\
+		     (uint8_t *) 0, (const uint8_t *) 0);	\
+    cmac64_set_key(&amp;(self)-&gt;key, &amp;(self)-&gt;cipher,		\
+		    (nettle_cipher_func *) (encrypt));		\
+    cmac64_init(&amp;(self)-&gt;ctx);					\
+  } while (0)
+
+#define CMAC64_UPDATE(self, encrypt, length, src)		\
+  (0 ? (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,			\
+		 (uint8_t *) 0, (const uint8_t *) 0)		\
+     : cmac64_update(&amp;(self)-&gt;ctx, &amp;(self)-&gt;cipher,		\
+		      (nettle_cipher_func *)encrypt,		\
+		      (length), (src)))
+
+#define CMAC64_DIGEST(self, encrypt, length, digest)		\
+  (0 ? (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,			\
+		 (uint8_t *) 0, (const uint8_t *) 0)		\
+     : cmac64_digest(&amp;(self)-&gt;ctx, &amp;(self)-&gt;key,		\
+		      &amp;(self)-&gt;cipher,				\
+		      (nettle_cipher_func *) (encrypt),		\
+		      (length), (digest)))
+
 struct cmac_aes128_ctx CMAC128_CTX(struct aes128_ctx);
 
 void
diff --git a/cmac64.c b/cmac64.c
new file mode 100644
index 000000000000..9b711d6698ab
--- /dev/null
+++ b/cmac64.c
@@ -0,0 +1,177 @@
+/*
+   AES-CMAC-128 (rfc 4493) / CMAC-64
+   Copyright (C) Stefan Metzmacher 2012
+   Copyright (C) Jeremy Allison 2012
+   Copyright (C) Michael Adam 2012
+   Copyright (C) 2017, Red Hat Inc.
+   Copyright (C) 2019, Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "cmac.h"
+
+#include "memxor.h"
+#include "nettle-internal.h"
+#include "macros.h"
+
+/* shift one and XOR with 0x87. */
+#if WORDS_BIGENDIAN
+static void
+_cmac64_block_mulx(union nettle_block8 *dst,
+	    const union nettle_block8 *src)
+{
+  uint64_t carry = src-&gt;u64 &gt;&gt; 63;
+
+  dst-&gt;u64 = (src-&gt;u64 &lt;&lt; 1) ^ (0x1b &amp; -carry);
+}
+#else /* !WORDS_BIGENDIAN */
+#define LE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
+                     (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
+static void
+_cmac64_block_mulx(union nettle_block8 *dst,
+	   const union nettle_block8 *src)
+{
+  uint64_t carry = (src-&gt;u64 &amp; 0x80) &gt;&gt; 7;
+
+  dst-&gt;u64 = LE_SHIFT(src-&gt;u64) ^ (0x1b00000000000000 &amp; -carry);
+}
+#endif /* !WORDS_BIGENDIAN */
+
+void
+cmac64_set_key(struct cmac64_key *key, const void *cipher,
+	       nettle_cipher_func *encrypt)
+{
+  static const union nettle_block8 zero_block;
+  union nettle_block8 L;
+
+  /* step 1 - generate subkeys k1 and k2 */
+  encrypt(cipher, 8, L.b, zero_block.b);
+
+  _cmac64_block_mulx(&amp;key-&gt;K1, &amp;L);
+  _cmac64_block_mulx(&amp;key-&gt;K2, &amp;key-&gt;K1);
+}
+
+void
+cmac64_init(struct cmac64_ctx *ctx)
+{
+  memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
+  ctx-&gt;index = 0;
+}
+
+#define MIN(x,y) ((x)&lt;(y)?(x):(y))
+
+void
+cmac64_update(struct cmac64_ctx *ctx, const void *cipher,
+	      nettle_cipher_func *encrypt,
+	      size_t msg_len, const uint8_t *msg)
+{
+  union nettle_block16 Y;
+  /*
+   * check if we expand the block
+   */
+  if (ctx-&gt;index &lt; 8)
+    {
+      size_t len = MIN(8 - ctx-&gt;index, msg_len);
+      memcpy(&amp;ctx-&gt;block.b[ctx-&gt;index], msg, len);
+      msg += len;
+      msg_len -= len;
+      ctx-&gt;index += len;
+    }
+
+  if (msg_len == 0) {
+    /* if it is still the last block, we are done */
+    return;
+  }
+
+  /*
+   * now checksum everything but the last block
+   */
+  memxor3(Y.b, ctx-&gt;X.b, ctx-&gt;block.b, 8);
+  encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
+
+  while (msg_len &gt; 8)
+    {
+      memxor3(Y.b, ctx-&gt;X.b, msg, 8);
+      encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
+      msg += 8;
+      msg_len -= 8;
+    }
+
+  /*
+   * copy the last block, it will be processed in
+   * cmac64_digest().
+   */
+  memcpy(ctx-&gt;block.b, msg, msg_len);
+  ctx-&gt;index = msg_len;
+}
+
+void
+cmac64_digest(struct cmac64_ctx *ctx, const struct cmac64_key *key,
+	      const void *cipher, nettle_cipher_func *encrypt,
+	      unsigned length, uint8_t *dst)
+{
+  union nettle_block8 Y;
+
+  memset(ctx-&gt;block.b+ctx-&gt;index, 0, sizeof(ctx-&gt;block.b)-ctx-&gt;index);
+
+  /* re-use ctx-&gt;block for memxor output */
+  if (ctx-&gt;index &lt; 8)
+    {
+      ctx-&gt;block.b[ctx-&gt;index] = 0x80;
+      memxor(ctx-&gt;block.b, key-&gt;K2.b, 8);
+    }
+  else
+    {
+      memxor(ctx-&gt;block.b, key-&gt;K1.b, 8);
+    }
+
+  memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 8);
+
+  assert(length &lt;= 8);
+  if (length == 8)
+    {
+      encrypt(cipher, 8, dst, Y.b);
+    }
+  else
+    {
+      encrypt(cipher, 8, ctx-&gt;block.b, Y.b);
+      memcpy(dst, ctx-&gt;block.b, length);
+    }
+
+  /* reset state for re-use */
+  memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
+  ctx-&gt;index = 0;
+}
diff --git a/nettle-types.h b/nettle-types.h
index 87292ac69730..5addf3600d69 100644
--- a/nettle-types.h
+++ b/nettle-types.h
@@ -65,6 +65,12 @@ union nettle_block16
   uint64_t u64[2];
 };
 
+union nettle_block8
+{
+  uint8_t b[8];
+  uint64_t u64;
+};
+
 /* Randomness. Used by key generation and dsa signature creation. */
 typedef void nettle_random_func(void *ctx,
 				size_t length, uint8_t *dst);
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190710210532</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-10 21:05:32-0400</timestampReceived><subject>Re: [PATCH] cmac: add 64-bit mode CMAC</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; --- /dev/null
&gt; +++ b/cmac64.c
&gt; @@ -0,0 +1,177 @@
&gt; +/*
&gt; +   AES-CMAC-128 (rfc 4493) / CMAC-64

I've now merged this and the cmac_des3 patch onto a branch "cmac64".
What's an authoritative reference for cmac64 and cmac using des?
RFC4493 doesn't seem quite right. Is it NIST SP 800-38B, mentioned in a
comment with the tests?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190711001146</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-11 00:11:46-0400</timestampReceived><subject>Re: [PATCH] cmac: add 64-bit mode CMAC</subject><body>

Hello,

чт, 11 июл. 2019 г. в 00:05, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; --- /dev/null
&gt; &gt; +++ b/cmac64.c
&gt; &gt; @@ -0,0 +1,177 @@
&gt; &gt; +/*
&gt; &gt; +   AES-CMAC-128 (rfc 4493) / CMAC-64
&gt;
&gt; I've now merged this and the cmac_des3 patch onto a branch "cmac64".

Thank you!

&gt; What's an authoritative reference for cmac64 and cmac using des?
&gt; RFC4493 doesn't seem quite right. Is it NIST SP 800-38B, mentioned in a
&gt; comment with the tests?

Yes, it is.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190719153224</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-19 15:32:24-0400</timestampReceived><subject>Re: [PATCH 0/7] Add meta interface for MAC algorithms</subject><body>

Hello,

пт, 19 июл. 2019 г. в 16:38, Daiki Ueno &lt;ueno@gnu.org&gt;:
&gt;
&gt; From: Daiki Ueno &lt;dueno@redhat.com&gt;
&gt;
&gt; As discussed in:
&gt; https://lists.lysator.liu.se/pipermail/nettle-bugs/2019/007662.html
&gt;
&gt; This moves `struct nettle_mac` to nettle-meta.h and provide the meta
&gt; interface for all defined MAC algorithms.

Great!

&gt; Each meta interface shall provide the following 4 functions:
&gt;
&gt;   nettle_set_key_func *set_key;
&gt;   nettle_set_key_func *set_nonce;
&gt;   nettle_hash_update_func *update;
&gt;   nettle_hash_digest_func *digest;
&gt;
&gt; where set_nonce is only used by UMAC, and expects that the nonce has
&gt; always the same length as AES_BLOCK_SIZE.  For CMAC and HMAC, a no-op
&gt; set_nonce function is defined.

Will it be usefull to support length + data as arguments of set_nonce function?
Especially if we try to add AES-GMAC a first level citizen.

Also it might look good to define (internal) mac_set_nonce_null() function
and use it from the HMAC/CMAC meta interface.


-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190720090001</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-20 09:00:01-0400</timestampReceived><subject>Re: [PATCH 0/7] Add meta interface for MAC algorithms</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt;&gt; Each meta interface shall provide the following 4 functions:
&gt;&gt;
&gt;&gt;   nettle_set_key_func *set_key;
&gt;&gt;   nettle_set_key_func *set_nonce;
&gt;&gt;   nettle_hash_update_func *update;
&gt;&gt;   nettle_hash_digest_func *digest;
&gt;&gt;
&gt;&gt; where set_nonce is only used by UMAC, and expects that the nonce has
&gt;&gt; always the same length as AES_BLOCK_SIZE.  For CMAC and HMAC, a no-op
&gt;&gt; set_nonce function is defined.
&gt;
&gt; Will it be usefull to support length + data as arguments of set_nonce function?
&gt; Especially if we try to add AES-GMAC a first level citizen.

Maybe I'm missing the context, but wouldn't AES-GMAC better fit in
`struct nettle_aead` as it is a special case of AES-GCM?

The struct also has set_nonce function defined as nettle_set_key_func *.

&gt; Also it might look good to define (internal) mac_set_nonce_null() function
&gt; and use it from the HMAC/CMAC meta interface.

Indeed, it makes sense.  I will update the series with it after making
hmac_*_set_key_expanded internal as suggested.

Thank you for the comments!

Regards,
-- 
Daiki Ueno
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190717074539</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-17 07:45:39-0400</timestampReceived><subject>Re: nettle-meta interface for MACs</subject><body>

Daiki Ueno &lt;ueno@gnu.org&gt; writes:

&gt; This is, however, not usable for HMAC, because Nettle build uses
&gt; -Wcast-function-type and the set_key member has an incompatible type
&gt; with hmac_*_set_key, which requires a key length argument as HMAC allows
&gt; arbitrary key length up to the hash block size.

It's also not directly usable with umac, which takes a nonce (and auto
increment in umac*_digest). Should the generic interface try to
accomodate macs that require a nonce?

&gt; Is there any plan to make it more generic and eventually move it to
&gt; nettle-meta.h?  That would be particularly useful in applications
&gt; passing around HMAC functions (e.g., HKDF, deterministic ECDSA).

If we can find a reasonable "generic" interface, yes.

&gt; For example, I'm thinking to use nettle_hash_update_func for set_key and
&gt; provide a wrapper around other MACs which don't take key length,
&gt; something like:
&gt;
&gt;  void
&gt;  _cmac_aes128_set_key(struct cmac_aes128_ctx *ctx,
&gt;                       size_t length, const uint8_t *key)
&gt;  {
&gt;    assert (length == AES128_KEY_LENGTH);
&gt;    cmac_aes128_set_key (ctx, length, key);
&gt;  }

I would consider doing it the other way around, and define nettle_hmac_*
with fixed key size, for the key sizes used by applications. E.g,
https://tools.ietf.org/html/rfc4253#section-6.4 defines 4 mac algorithms
based on hmac, with the main one being hmac-sha1, with a fixed key size
equal to the digest size of 160 bits.

Is it common to use hmac, without context implying a fix key size ?

Slightly related: HMAC is defined as allowing very long keys, by hashing
the key in case it's larger than the block size (e.g., 512 bits for
hmac-sha1 and hmac-sha256). That seems a bit obscure to me. Are there
any applications or protocols depending on that feature?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190719133759</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-19 13:37:59-0400</timestampReceived><subject>[PATCH 6/7] nettle-meta: Expose all defined MACs through nettle_macs</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 Makefile.in        |  2 +-
 nettle-meta-macs.c | 61 ++++++++++++++++++++++++++++++++++++++++++++++
 nettle-meta.h      |  7 ++++++
 3 files changed, 69 insertions(+), 1 deletion(-)
 create mode 100644 nettle-meta-macs.c

diff --git a/Makefile.in b/Makefile.in
index 4cfc5005..8efe2f88 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -116,7 +116,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 memeql-sec.c memxor.c memxor3.c \
 		 nettle-lookup-hash.c \
 		 nettle-meta-aeads.c nettle-meta-armors.c \
-		 nettle-meta-ciphers.c nettle-meta-hashes.c \
+		 nettle-meta-ciphers.c nettle-meta-hashes.c nettle-meta-macs.c \
 		 pbkdf2.c pbkdf2-hmac-sha1.c pbkdf2-hmac-sha256.c \
 		 poly1305-aes.c poly1305-internal.c \
 		 realloc.c \
diff --git a/nettle-meta-macs.c b/nettle-meta-macs.c
new file mode 100644
index 00000000..6575ed66
--- /dev/null
+++ b/nettle-meta-macs.c
@@ -0,0 +1,61 @@
+/* nettle-meta-macs.c
+
+   Copyright (C) 2011 Daniel Kahn Gillmor
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;stddef.h&gt;
+
+#include "nettle-meta.h"
+
+const struct nettle_mac * const _nettle_macs[] = {
+  &amp;nettle_cmac_aes128,
+  &amp;nettle_cmac_aes256,
+  &amp;nettle_hmac_md5,
+  &amp;nettle_hmac_ripemd160,
+  &amp;nettle_hmac_sha1,
+  &amp;nettle_hmac_sha224,
+  &amp;nettle_hmac_sha256,
+  &amp;nettle_hmac_sha384,
+  &amp;nettle_hmac_sha512,
+  &amp;nettle_umac32,
+  &amp;nettle_umac64,
+  &amp;nettle_umac96,
+  &amp;nettle_umac128,
+  NULL
+};
+
+const struct nettle_mac * const *
+nettle_get_macs (void)
+{
+  return _nettle_macs;
+}
diff --git a/nettle-meta.h b/nettle-meta.h
index 55229501..c7e7ab0f 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -296,6 +296,13 @@ struct nettle_mac
   (nettle_hash_digest_func *) name##_digest,	\
 }
 
+/* null-terminated list of macs implemented by this
+   version of nettle */
+const struct nettle_mac * const * _NETTLE_ATTRIBUTE_PURE
+nettle_get_macs (void);
+
+#define nettle_macs (nettle_get_macs())
+
 extern const struct nettle_mac nettle_cmac_aes128;
 extern const struct nettle_mac nettle_cmac_aes256;
 
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190719133800</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-19 13:38:00-0400</timestampReceived><subject>[PATCH 7/7] tests: Add test for meta interface for MAC algorithms</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 testsuite/.gitignore       |  1 +
 testsuite/.test-rules.make |  3 +++
 testsuite/Makefile.in      |  2 +-
 testsuite/meta-mac-test.c  | 37 +++++++++++++++++++++++++++++++++++++
 4 files changed, 42 insertions(+), 1 deletion(-)
 create mode 100644 testsuite/meta-mac-test.c

diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index 066bcee2..a57feccb 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -56,6 +56,7 @@
 /meta-armor-test
 /meta-cipher-test
 /meta-hash-test
+/meta-mac-test
 /pbkdf2-test
 /pkcs1-test
 /pkcs1-sec-decrypt-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index efb7df3c..87e288c5 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -160,6 +160,9 @@ meta-aead-test$(EXEEXT): meta-aead-test.$(OBJEXT)
 meta-armor-test$(EXEEXT): meta-armor-test.$(OBJEXT)
 	$(LINK) meta-armor-test.$(OBJEXT) $(TEST_OBJS) -o meta-armor-test$(EXEEXT)
 
+meta-mac-test$(EXEEXT): meta-mac-test.$(OBJEXT)
+	$(LINK) meta-mac-test.$(OBJEXT) $(TEST_OBJS) -o meta-mac-test$(EXEEXT)
+
 buffer-test$(EXEEXT): buffer-test.$(OBJEXT)
 	$(LINK) buffer-test.$(OBJEXT) $(TEST_OBJS) -o buffer-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index f8f85701..d688c242 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -31,7 +31,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
-		    meta-aead-test.c meta-armor-test.c \
+		    meta-aead-test.c meta-armor-test.c meta-mac-test.c \
 		    buffer-test.c yarrow-test.c xts-test.c pbkdf2-test.c
 
 TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
diff --git a/testsuite/meta-mac-test.c b/testsuite/meta-mac-test.c
new file mode 100644
index 00000000..dcc9fbca
--- /dev/null
+++ b/testsuite/meta-mac-test.c
@@ -0,0 +1,37 @@
+#include "testutils.h"
+#include "nettle-internal.h"
+#include "nettle-meta.h"
+
+const char* macs[] = {
+  "cmac_aes128",
+  "cmac_aes256",
+  "hmac_md5",
+  "hmac_ripemd160",
+  "hmac_sha1",
+  "hmac_sha224",
+  "hmac_sha256",
+  "hmac_sha384",
+  "hmac_sha512",
+  "umac32",
+  "umac64",
+  "umac96",
+  "umac128",
+};
+
+void
+test_main(void)
+{
+  int i, j;
+  int count = sizeof(macs)/sizeof(*macs);
+  for (i = 0; i &lt; count; i++) {
+    for (j = 0; NULL != nettle_macs[j]; j++) {
+      if (0 == strcmp(macs[i], nettle_macs[j]-&gt;name))
+	break;
+    }
+    ASSERT(NULL != nettle_macs[j]); /* make sure we found a matching aead */
+  }
+  i = 0;
+  while (NULL != nettle_macs[i])
+    i++;
+  ASSERT(i == count); /* we are not missing testing any hashes */
+}
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190719152701</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-19 15:27:01-0400</timestampReceived><subject>Re: [PATCH 1/7] hmac: Add set_key_expanded function</subject><body>

Hello,

пт, 19 июл. 2019 г. в 16:38, Daiki Ueno &lt;ueno@gnu.org&gt;:
&gt;
&gt; From: Daiki Ueno &lt;dueno@redhat.com&gt;
&gt;
&gt; This adds a set_key_expanded to all HMACs, to provide a compatible
&gt; signature with nettle_set_key_func.  This function is similar to
&gt; set_key, but assumes the input is already expanded to the hash block
&gt; size.

I'd suggest not to define a separate hmac_set_key_expanded().
Will the folllowing function work for you?

static nettle_set_key_func hmac_md5_set_key_wrapper
static void
hmac_md5_set_key_wrapper(void *ctx, const uint8_t *key)
{
  hmac_md5_set_key(ctx, MD5_BLOCK_SIZE, key);
}

It will be less intrusive and more in line with other set_key wrappers.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190720162336</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-20 16:23:36-0400</timestampReceived><subject>Re: [PATCH 0/7] Add meta interface for MAC algorithms</subject><body>

Hello,

сб, 20 июл. 2019 г. в 12:00, Daiki Ueno &lt;ueno@gnu.org&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt;&gt; Each meta interface shall provide the following 4 functions:
&gt; &gt;&gt;
&gt; &gt;&gt;   nettle_set_key_func *set_key;
&gt; &gt;&gt;   nettle_set_key_func *set_nonce;
&gt; &gt;&gt;   nettle_hash_update_func *update;
&gt; &gt;&gt;   nettle_hash_digest_func *digest;
&gt; &gt;&gt;
&gt; &gt;&gt; where set_nonce is only used by UMAC, and expects that the nonce has
&gt; &gt;&gt; always the same length as AES_BLOCK_SIZE.  For CMAC and HMAC, a no-op
&gt; &gt;&gt; set_nonce function is defined.
&gt; &gt;
&gt; &gt; Will it be usefull to support length + data as arguments of set_nonce function?
&gt; &gt; Especially if we try to add AES-GMAC a first level citizen.
&gt;
&gt; Maybe I'm missing the context, but wouldn't AES-GMAC better fit in
&gt; `struct nettle_aead` as it is a special case of AES-GCM?

It is, but it is defined as a MAC algorithm.

&gt; The struct also has set_nonce function defined as nettle_set_key_func *.

Hmm, I've missed that point. Then I have no objections.

&gt; &gt; Also it might look good to define (internal) mac_set_nonce_null() function
&gt; &gt; and use it from the HMAC/CMAC meta interface.
&gt;
&gt; Indeed, it makes sense.  I will update the series with it after making
&gt; hmac_*_set_key_expanded internal as suggested.
&gt;
&gt; Thank you for the comments!

Thank you!


-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190722070739</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-22 07:07:39-0400</timestampReceived><subject>Re: [PATCH] cmac: add 64-bit mode CMAC</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I've now merged this and the cmac_des3 patch onto a branch "cmac64".

And now pushed to master, together with the documentation update.

Thanks,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190722085310</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-22 08:53:10-0400</timestampReceived><subject>[PATCH v2 1/6] nettle-meta: Move struct nettle_mac to nettle-meta.h</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

The struct was defined in testutils.h as the interface was not
stable.  This generalizes the interface to cover all defined MAC
algorithms in nettle.

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 nettle-meta.h         | 22 ++++++++++++++++++++++
 testsuite/testutils.h | 29 -----------------------------
 2 files changed, 22 insertions(+), 29 deletions(-)

diff --git a/nettle-meta.h b/nettle-meta.h
index 74e50e59..b03da208 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -238,6 +238,28 @@ extern const struct nettle_armor nettle_base64;
 extern const struct nettle_armor nettle_base64url;
 extern const struct nettle_armor nettle_base16;
 
+struct nettle_mac
+{
+  const char *name;
+
+  /* Size of the context struct */
+  unsigned context_size;
+
+  /* Size of digests */
+  unsigned digest_size;
+
+  /* Suggested key size; other sizes are sometimes possible */
+  unsigned key_size;
+
+  /* Suggested nonce size; 0 if nonce is not used */
+  unsigned nonce_size;
+
+  nettle_set_key_func *set_key;
+  nettle_set_key_func *set_nonce;
+  nettle_hash_update_func *update;
+  nettle_hash_digest_func *digest;
+};
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/testutils.h b/testsuite/testutils.h
index f4ea38da..78daf62b 100644
--- a/testsuite/testutils.h
+++ b/testsuite/testutils.h
@@ -79,35 +79,6 @@ test_main(void);
 
 extern int verbose;
 
-/* FIXME: When interface stabilizes, move to nettle-meta.h */
-struct nettle_mac
-{
-  const char *name;
-
-  /* Size of the context struct */
-  unsigned context_size;
-
-  /* Size of digests */
-  unsigned digest_size;
-
-  /* Suggested key size; other sizes are sometimes possible. */
-  unsigned key_size;
-  
-  nettle_set_key_func *set_key;
-  nettle_hash_update_func *update;
-  nettle_hash_digest_func *digest;
-};
-
-#define _NETTLE_HMAC(name, NAME, keysize) {	\
-  #name,					\
-  sizeof(struct hmac_##name##_ctx),		\
-  NAME##_DIGEST_SIZE,				\
-  NAME##_DIGEST_SIZE,				\
-  hmac_##name##_set_key,			\
-  hmac_##name##_update,				\
-  hmac_##name##_digest,				\
-}
-
 /* Test functions deallocate their inputs when finished.*/
 void
 test_cipher(const struct nettle_cipher *cipher,
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190722085311</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-22 08:53:11-0400</timestampReceived><subject>[PATCH v2 2/6] nettle-meta: Add meta interface for CMAC functions</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 Makefile.in           |  1 +
 cmac-aes128-meta.c    | 43 +++++++++++++++++++++++++++++++++++++++++++
 cmac-aes256-meta.c    | 43 +++++++++++++++++++++++++++++++++++++++++++
 nettle-meta.h         | 15 +++++++++++++++
 testsuite/cmac-test.c | 24 ------------------------
 5 files changed, 102 insertions(+), 24 deletions(-)
 create mode 100644 cmac-aes128-meta.c
 create mode 100644 cmac-aes256-meta.c

diff --git a/Makefile.in b/Makefile.in
index b54e64b0..6a425e16 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -103,6 +103,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
 		 cmac.c cmac-aes128.c cmac-aes256.c \
+		 cmac-aes128-meta.c cmac-aes256-meta.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
diff --git a/cmac-aes128-meta.c b/cmac-aes128-meta.c
new file mode 100644
index 00000000..6239984b
--- /dev/null
+++ b/cmac-aes128-meta.c
@@ -0,0 +1,43 @@
+/* cmac-aes128-meta.c
+
+   Copyright (C) 2013, 2014 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "nettle-meta.h"
+
+#include "cmac.h"
+
+const struct nettle_mac nettle_cmac_aes128
+= _NETTLE_CMAC(cmac_aes128, AES128);
diff --git a/cmac-aes256-meta.c b/cmac-aes256-meta.c
new file mode 100644
index 00000000..8f50f0d8
--- /dev/null
+++ b/cmac-aes256-meta.c
@@ -0,0 +1,43 @@
+/* cmac-aes256-meta.c
+
+   Copyright (C) 2013, 2014 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "nettle-meta.h"
+
+#include "cmac.h"
+
+const struct nettle_mac nettle_cmac_aes256
+= _NETTLE_CMAC(cmac_aes256, AES256);
diff --git a/nettle-meta.h b/nettle-meta.h
index b03da208..783d80ce 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -260,6 +260,21 @@ struct nettle_mac
   nettle_hash_digest_func *digest;
 };
 
+#define _NETTLE_CMAC(name, AES) {		\
+  #name,					\
+  sizeof(struct name##_ctx),			\
+  CMAC128_DIGEST_SIZE,				\
+  AES##_KEY_SIZE,				\
+  0,						\
+  (nettle_set_key_func *) name##_set_key,	\
+  NULL,						\
+  (nettle_hash_update_func *) name##_update,	\
+  (nettle_hash_digest_func *) name##_digest,	\
+}
+
+extern const struct nettle_mac nettle_cmac_aes128;
+extern const struct nettle_mac nettle_cmac_aes256;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
index b1d4aa30..42188ece 100644
--- a/testsuite/cmac-test.c
+++ b/testsuite/cmac-test.c
@@ -2,30 +2,6 @@
 #include "nettle-internal.h"
 #include "cmac.h"
 
-const struct nettle_mac nettle_cmac_aes128 =
-{
-  "CMAC-AES128",
-  sizeof(struct cmac_aes128_ctx),
-  CMAC128_DIGEST_SIZE,
-  AES128_KEY_SIZE,
-
-  (nettle_set_key_func*) cmac_aes128_set_key,
-  (nettle_hash_update_func*) cmac_aes128_update,
-  (nettle_hash_digest_func*) cmac_aes128_digest
-};
-
-const struct nettle_mac nettle_cmac_aes256 =
-{
-  "CMAC-AES256",
-  sizeof(struct cmac_aes256_ctx),
-  CMAC128_DIGEST_SIZE,
-  AES256_KEY_SIZE,
-
-  (nettle_set_key_func*) cmac_aes256_set_key,
-  (nettle_hash_update_func*) cmac_aes256_update,
-  (nettle_hash_digest_func*) cmac_aes256_digest
-};
-
 #define test_cmac_aes128(key, msg, ref)					\
   test_mac(&amp;nettle_cmac_aes128, key, msg, ref)
 
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190722085312</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-22 08:53:12-0400</timestampReceived><subject>[PATCH v2 3/6] nettle-meta: Add meta interface for HMAC functions</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 Makefile.in           |  3 +++
 hmac-md5-meta.c       | 47 +++++++++++++++++++++++++++++++++++++++++++
 hmac-ripemd160-meta.c | 47 +++++++++++++++++++++++++++++++++++++++++++
 hmac-sha1-meta.c      | 47 +++++++++++++++++++++++++++++++++++++++++++
 hmac-sha224-meta.c    | 47 +++++++++++++++++++++++++++++++++++++++++++
 hmac-sha256-meta.c    | 47 +++++++++++++++++++++++++++++++++++++++++++
 hmac-sha384-meta.c    | 47 +++++++++++++++++++++++++++++++++++++++++++
 hmac-sha512-meta.c    | 47 +++++++++++++++++++++++++++++++++++++++++++
 nettle-meta.h         | 20 ++++++++++++++++++
 9 files changed, 352 insertions(+)
 create mode 100644 hmac-md5-meta.c
 create mode 100644 hmac-ripemd160-meta.c
 create mode 100644 hmac-sha1-meta.c
 create mode 100644 hmac-sha224-meta.c
 create mode 100644 hmac-sha256-meta.c
 create mode 100644 hmac-sha384-meta.c
 create mode 100644 hmac-sha512-meta.c

diff --git a/Makefile.in b/Makefile.in
index 6a425e16..9031d959 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -107,6 +107,9 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
+		 hmac-md5-meta.c hmac-ripemd160-meta.c hmac-sha1-meta.c \
+		 hmac-sha224-meta.c hmac-sha256-meta.c hmac-sha384-meta.c \
+		 hmac-sha512-meta.c \
 		 knuth-lfib.c hkdf.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
diff --git a/hmac-md5-meta.c b/hmac-md5-meta.c
new file mode 100644
index 00000000..3933a455
--- /dev/null
+++ b/hmac-md5-meta.c
@@ -0,0 +1,47 @@
+/* hmac-md5-meta.c
+
+   Copyright (C) 2002 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "hmac.h"
+
+static void
+hmac_md5_set_key_wrapper (void *ctx, const uint8_t *key)
+{
+  hmac_md5_set_key (ctx, MD5_BLOCK_SIZE, key);
+}
+
+const struct nettle_mac nettle_hmac_md5
+= _NETTLE_HMAC(hmac_md5, MD5);
diff --git a/hmac-ripemd160-meta.c b/hmac-ripemd160-meta.c
new file mode 100644
index 00000000..86469650
--- /dev/null
+++ b/hmac-ripemd160-meta.c
@@ -0,0 +1,47 @@
+/* hmac-ripemd160-meta.c
+
+   Copyright (C) 2011 Andres Mejia
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "hmac.h"
+
+static void
+hmac_ripemd160_set_key_wrapper (void *ctx, const uint8_t *key)
+{
+  hmac_ripemd160_set_key (ctx, RIPEMD160_BLOCK_SIZE, key);
+}
+
+const struct nettle_mac nettle_hmac_ripemd160
+= _NETTLE_HMAC(hmac_ripemd160, RIPEMD160);
diff --git a/hmac-sha1-meta.c b/hmac-sha1-meta.c
new file mode 100644
index 00000000..14d34d2b
--- /dev/null
+++ b/hmac-sha1-meta.c
@@ -0,0 +1,47 @@
+/* hmac-sha1-meta.c
+
+   Copyright (C) 2002 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "hmac.h"
+
+static void
+hmac_sha1_set_key_wrapper (void *ctx, const uint8_t *key)
+{
+  hmac_sha1_set_key (ctx, SHA1_BLOCK_SIZE, key);
+}
+
+const struct nettle_mac nettle_hmac_sha1
+= _NETTLE_HMAC(hmac_sha1, SHA1);
diff --git a/hmac-sha224-meta.c b/hmac-sha224-meta.c
new file mode 100644
index 00000000..2468a4ce
--- /dev/null
+++ b/hmac-sha224-meta.c
@@ -0,0 +1,47 @@
+/* hmac-sha224-meta.c
+
+   Copyright (C) 2002, 2010 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "hmac.h"
+
+static void
+hmac_sha224_set_key_wrapper (void *ctx, const uint8_t *key)
+{
+  hmac_sha224_set_key (ctx, SHA224_BLOCK_SIZE, key);
+}
+
+const struct nettle_mac nettle_hmac_sha224
+= _NETTLE_HMAC(hmac_sha224, SHA224);
diff --git a/hmac-sha256-meta.c b/hmac-sha256-meta.c
new file mode 100644
index 00000000..df099d05
--- /dev/null
+++ b/hmac-sha256-meta.c
@@ -0,0 +1,47 @@
+/* hmac-sha256-meta.c
+
+   Copyright (C) 2002 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "hmac.h"
+
+static void
+hmac_sha256_set_key_wrapper (void *ctx, const uint8_t *key)
+{
+  hmac_sha256_set_key (ctx, SHA256_BLOCK_SIZE, key);
+}
+
+const struct nettle_mac nettle_hmac_sha256
+= _NETTLE_HMAC(hmac_sha256, SHA256);
diff --git a/hmac-sha384-meta.c b/hmac-sha384-meta.c
new file mode 100644
index 00000000..1cfdd278
--- /dev/null
+++ b/hmac-sha384-meta.c
@@ -0,0 +1,47 @@
+/* hmac-sha384-meta.c
+
+   Copyright (C) 2002, 2010 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "hmac.h"
+
+static void
+hmac_sha384_set_key_wrapper (void *ctx, const uint8_t *key)
+{
+  hmac_sha384_set_key (ctx, SHA384_BLOCK_SIZE, key);
+}
+
+const struct nettle_mac nettle_hmac_sha384
+= _NETTLE_HMAC(hmac_sha384, SHA384);
diff --git a/hmac-sha512-meta.c b/hmac-sha512-meta.c
new file mode 100644
index 00000000..f4140766
--- /dev/null
+++ b/hmac-sha512-meta.c
@@ -0,0 +1,47 @@
+/* hmac-sha512-meta.c
+
+   Copyright (C) 2002, 2010 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "hmac.h"
+
+static void
+hmac_sha512_set_key_wrapper (void *ctx, const uint8_t *key)
+{
+  hmac_sha512_set_key (ctx, SHA512_BLOCK_SIZE, key);
+}
+
+const struct nettle_mac nettle_hmac_sha512
+= _NETTLE_HMAC(hmac_sha512, SHA512);
diff --git a/nettle-meta.h b/nettle-meta.h
index 783d80ce..20f5cd89 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -272,9 +272,29 @@ struct nettle_mac
   (nettle_hash_digest_func *) name##_digest,	\
 }
 
+#define _NETTLE_HMAC(name, HASH) {		\
+  #name,					\
+  sizeof(struct name##_ctx),			\
+  HASH##_DIGEST_SIZE,				\
+  HASH##_BLOCK_SIZE,				\
+  0,						\
+  name##_set_key_wrapper,			\
+  NULL,						\
+  (nettle_hash_update_func *) name##_update,	\
+  (nettle_hash_digest_func *) name##_digest,	\
+}
+
 extern const struct nettle_mac nettle_cmac_aes128;
 extern const struct nettle_mac nettle_cmac_aes256;
 
+extern const struct nettle_mac nettle_hmac_md5;
+extern const struct nettle_mac nettle_hmac_ripemd160;
+extern const struct nettle_mac nettle_hmac_sha1;
+extern const struct nettle_mac nettle_hmac_sha224;
+extern const struct nettle_mac nettle_hmac_sha256;
+extern const struct nettle_mac nettle_hmac_sha384;
+extern const struct nettle_mac nettle_hmac_sha512;
+
 #ifdef __cplusplus
 }
 #endif
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190722085313</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-22 08:53:13-0400</timestampReceived><subject>[PATCH v2 4/6] nettle-meta: Add meta interface for UMAC functions</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 Makefile.in    |  1 +
 nettle-meta.h  | 17 +++++++++++++++++
 umac128-meta.c | 47 +++++++++++++++++++++++++++++++++++++++++++++++
 umac32-meta.c  | 47 +++++++++++++++++++++++++++++++++++++++++++++++
 umac64-meta.c  | 47 +++++++++++++++++++++++++++++++++++++++++++++++
 umac96-meta.c  | 47 +++++++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 206 insertions(+)
 create mode 100644 umac128-meta.c
 create mode 100644 umac32-meta.c
 create mode 100644 umac64-meta.c
 create mode 100644 umac96-meta.c

diff --git a/Makefile.in b/Makefile.in
index 9031d959..4cfc5005 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -138,6 +138,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 umac-nh.c umac-nh-n.c umac-l2.c umac-l3.c \
 		 umac-poly64.c umac-poly128.c umac-set-key.c \
 		 umac32.c umac64.c umac96.c umac128.c \
+		 umac32-meta.c umac64-meta.c umac96-meta.c umac128-meta.c \
 		 version.c \
 		 write-be32.c write-le32.c write-le64.c \
 		 yarrow256.c yarrow_key_event.c \
diff --git a/nettle-meta.h b/nettle-meta.h
index 20f5cd89..b51fb602 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -284,6 +284,18 @@ struct nettle_mac
   (nettle_hash_digest_func *) name##_digest,	\
 }
 
+#define _NETTLE_UMAC(name, NAME) {		\
+  #name,					\
+  sizeof(struct name##_ctx),			\
+  NAME##_DIGEST_SIZE,				\
+  UMAC_BLOCK_SIZE,				\
+  AES_BLOCK_SIZE,				\
+  (nettle_set_key_func *) name##_set_key,	\
+  name##_set_nonce_wrapper,			\
+  (nettle_hash_update_func *) name##_update,	\
+  (nettle_hash_digest_func *) name##_digest,	\
+}
+
 extern const struct nettle_mac nettle_cmac_aes128;
 extern const struct nettle_mac nettle_cmac_aes256;
 
@@ -295,6 +307,11 @@ extern const struct nettle_mac nettle_hmac_sha256;
 extern const struct nettle_mac nettle_hmac_sha384;
 extern const struct nettle_mac nettle_hmac_sha512;
 
+extern const struct nettle_mac nettle_umac32;
+extern const struct nettle_mac nettle_umac64;
+extern const struct nettle_mac nettle_umac96;
+extern const struct nettle_mac nettle_umac128;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/umac128-meta.c b/umac128-meta.c
new file mode 100644
index 00000000..9f6a7e34
--- /dev/null
+++ b/umac128-meta.c
@@ -0,0 +1,47 @@
+/* umac128-meta.c
+
+   Copyright (C) 2013 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "umac.h"
+
+static void
+umac128_set_nonce_wrapper (void *ctx, const uint8_t *key)
+{
+  umac128_set_nonce (ctx, AES_BLOCK_SIZE, key);
+}
+
+const struct nettle_mac nettle_umac128
+= _NETTLE_UMAC(umac128, UMAC128);
diff --git a/umac32-meta.c b/umac32-meta.c
new file mode 100644
index 00000000..2b4f9c14
--- /dev/null
+++ b/umac32-meta.c
@@ -0,0 +1,47 @@
+/* umac32-meta.c
+
+   Copyright (C) 2013 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "umac.h"
+
+static void
+umac32_set_nonce_wrapper (void *ctx, const uint8_t *key)
+{
+  umac32_set_nonce (ctx, AES_BLOCK_SIZE, key);
+}
+
+const struct nettle_mac nettle_umac32
+= _NETTLE_UMAC(umac32, UMAC32);
diff --git a/umac64-meta.c b/umac64-meta.c
new file mode 100644
index 00000000..0351aaed
--- /dev/null
+++ b/umac64-meta.c
@@ -0,0 +1,47 @@
+/* umac64-meta.c
+
+   Copyright (C) 2013 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "umac.h"
+
+static void
+umac64_set_nonce_wrapper (void *ctx, const uint8_t *key)
+{
+  umac64_set_nonce (ctx, AES_BLOCK_SIZE, key);
+}
+
+const struct nettle_mac nettle_umac64
+= _NETTLE_UMAC(umac64, UMAC64);
diff --git a/umac96-meta.c b/umac96-meta.c
new file mode 100644
index 00000000..2feba8c8
--- /dev/null
+++ b/umac96-meta.c
@@ -0,0 +1,47 @@
+/* umac96-meta.c
+
+   Copyright (C) 2013 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "umac.h"
+
+static void
+umac96_set_nonce_wrapper (void *ctx, const uint8_t *key)
+{
+  umac96_set_nonce (ctx, AES_BLOCK_SIZE, key);
+}
+
+const struct nettle_mac nettle_umac96
+= _NETTLE_UMAC(umac96, UMAC96);
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190722085314</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-22 08:53:14-0400</timestampReceived><subject>[PATCH v2 5/6] nettle-meta: Expose all defined MACs through nettle_macs</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 Makefile.in        |  2 +-
 nettle-meta-macs.c | 61 ++++++++++++++++++++++++++++++++++++++++++++++
 nettle-meta.h      |  7 ++++++
 3 files changed, 69 insertions(+), 1 deletion(-)
 create mode 100644 nettle-meta-macs.c

diff --git a/Makefile.in b/Makefile.in
index 4cfc5005..8efe2f88 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -116,7 +116,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 memeql-sec.c memxor.c memxor3.c \
 		 nettle-lookup-hash.c \
 		 nettle-meta-aeads.c nettle-meta-armors.c \
-		 nettle-meta-ciphers.c nettle-meta-hashes.c \
+		 nettle-meta-ciphers.c nettle-meta-hashes.c nettle-meta-macs.c \
 		 pbkdf2.c pbkdf2-hmac-sha1.c pbkdf2-hmac-sha256.c \
 		 poly1305-aes.c poly1305-internal.c \
 		 realloc.c \
diff --git a/nettle-meta-macs.c b/nettle-meta-macs.c
new file mode 100644
index 00000000..6575ed66
--- /dev/null
+++ b/nettle-meta-macs.c
@@ -0,0 +1,61 @@
+/* nettle-meta-macs.c
+
+   Copyright (C) 2011 Daniel Kahn Gillmor
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;stddef.h&gt;
+
+#include "nettle-meta.h"
+
+const struct nettle_mac * const _nettle_macs[] = {
+  &amp;nettle_cmac_aes128,
+  &amp;nettle_cmac_aes256,
+  &amp;nettle_hmac_md5,
+  &amp;nettle_hmac_ripemd160,
+  &amp;nettle_hmac_sha1,
+  &amp;nettle_hmac_sha224,
+  &amp;nettle_hmac_sha256,
+  &amp;nettle_hmac_sha384,
+  &amp;nettle_hmac_sha512,
+  &amp;nettle_umac32,
+  &amp;nettle_umac64,
+  &amp;nettle_umac96,
+  &amp;nettle_umac128,
+  NULL
+};
+
+const struct nettle_mac * const *
+nettle_get_macs (void)
+{
+  return _nettle_macs;
+}
diff --git a/nettle-meta.h b/nettle-meta.h
index b51fb602..4b4d312d 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -296,6 +296,13 @@ struct nettle_mac
   (nettle_hash_digest_func *) name##_digest,	\
 }
 
+/* null-terminated list of macs implemented by this
+   version of nettle */
+const struct nettle_mac * const * _NETTLE_ATTRIBUTE_PURE
+nettle_get_macs (void);
+
+#define nettle_macs (nettle_get_macs())
+
 extern const struct nettle_mac nettle_cmac_aes128;
 extern const struct nettle_mac nettle_cmac_aes256;
 
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190722085315</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-07-22 08:53:15-0400</timestampReceived><subject>[PATCH v2 6/6] tests: Add test for meta interface for MAC algorithms</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 testsuite/.gitignore       |  1 +
 testsuite/.test-rules.make |  3 +++
 testsuite/Makefile.in      |  2 +-
 testsuite/meta-mac-test.c  | 43 ++++++++++++++++++++++++++++++++++++++
 4 files changed, 48 insertions(+), 1 deletion(-)
 create mode 100644 testsuite/meta-mac-test.c

diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index 066bcee2..a57feccb 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -56,6 +56,7 @@
 /meta-armor-test
 /meta-cipher-test
 /meta-hash-test
+/meta-mac-test
 /pbkdf2-test
 /pkcs1-test
 /pkcs1-sec-decrypt-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index efb7df3c..87e288c5 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -160,6 +160,9 @@ meta-aead-test$(EXEEXT): meta-aead-test.$(OBJEXT)
 meta-armor-test$(EXEEXT): meta-armor-test.$(OBJEXT)
 	$(LINK) meta-armor-test.$(OBJEXT) $(TEST_OBJS) -o meta-armor-test$(EXEEXT)
 
+meta-mac-test$(EXEEXT): meta-mac-test.$(OBJEXT)
+	$(LINK) meta-mac-test.$(OBJEXT) $(TEST_OBJS) -o meta-mac-test$(EXEEXT)
+
 buffer-test$(EXEEXT): buffer-test.$(OBJEXT)
 	$(LINK) buffer-test.$(OBJEXT) $(TEST_OBJS) -o buffer-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index f8f85701..d688c242 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -31,7 +31,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
-		    meta-aead-test.c meta-armor-test.c \
+		    meta-aead-test.c meta-armor-test.c meta-mac-test.c \
 		    buffer-test.c yarrow-test.c xts-test.c pbkdf2-test.c
 
 TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
diff --git a/testsuite/meta-mac-test.c b/testsuite/meta-mac-test.c
new file mode 100644
index 00000000..09cb5e9f
--- /dev/null
+++ b/testsuite/meta-mac-test.c
@@ -0,0 +1,43 @@
+#include "testutils.h"
+#include "nettle-internal.h"
+#include "nettle-meta.h"
+
+const char* macs[] = {
+  "cmac_aes128",
+  "cmac_aes256",
+  "hmac_md5",
+  "hmac_ripemd160",
+  "hmac_sha1",
+  "hmac_sha224",
+  "hmac_sha256",
+  "hmac_sha384",
+  "hmac_sha512",
+  "umac32",
+  "umac64",
+  "umac96",
+  "umac128",
+};
+
+void
+test_main(void)
+{
+  int i, j;
+  int count = sizeof(macs)/sizeof(*macs);
+  for (i = 0; i &lt; count; i++) {
+    for (j = 0; NULL != nettle_macs[j]; j++) {
+      if (0 == strcmp(macs[i], nettle_macs[j]-&gt;name))
+	break;
+    }
+    ASSERT(NULL != nettle_macs[j]); /* make sure we found a matching mac */
+  }
+  for (i = 0; NULL != nettle_macs[i]; i++) {
+    if (nettle_macs[i]-&gt;nonce_size &gt; 0)
+      ASSERT(NULL != nettle_macs[i]-&gt;set_nonce);
+    else
+      ASSERT(NULL == nettle_macs[i]-&gt;set_nonce);
+  }
+  i = 0;
+  while (NULL != nettle_macs[i])
+    i++;
+  ASSERT(i == count); /* we are not missing testing any macs */
+}
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190722102805</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-07-22 10:28:05-0400</timestampReceived><subject>Re: [PATCH v2 0/6] Add meta interface for MAC algorithms</subject><body>

пн, 22 июл. 2019 г. в 11:54, Daiki Ueno &lt;ueno@gnu.org&gt;:
&gt;
&gt; From: Daiki Ueno &lt;dueno@redhat.com&gt;
&gt;
&gt; The changes from the previous series are:
&gt; - remove the global hmac_*_set_key_expanded functions
&gt; - leave out set_nonce member if the operation is not supported
&gt;
&gt; For the latter, I was wondering whether it is better to define a no-op
&gt; set_nonce, but given the fact that that the caller nevertheless checks
&gt; nonce_size, I chose to make the field blank.

Looks good to me now, thank you.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190725210204</emailId><senderName>Wim Lewis</senderName><senderEmail>wiml@hhhh.org</senderEmail><timestampReceived>2019-07-25 21:02:04-0400</timestampReceived><subject>Swift language bindings, a work in progress</subject><body>

I have been working on Nettle bindings for Swift (Apple's somewhat new 
language, which is starting to become useful on non-Apple platforms).
The bindings are incomplete and I'm still figuring out what the
most ergonomic API is, but the package can currently be found here:

    https://github.com/wiml/swift-nettle

It should be usable with SwiftPM and Swift 5.0.1 or 5.1.

Feedback and contributions are very welcome. I wrote this to solve a
specific problem, and so the parts of Nettle that I didn't need are
either missing or might not be easy to use. (In particular, I didn't
need symmetric encryption, which is a pretty large missing piece!)

Wim Lewis / wiml@hhhh.org



_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190730204916</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-07-30 20:49:16-0400</timestampReceived><subject>Re: Some .stamp files slipped into the tarball</subject><body>

Justus Winter &lt;justus@sequoia-pgp.org&gt; writes:

&gt; And the build system I adopted doesn't actually use cp, I just
&gt; demonstrated the problem using cp. Therefore, it is not as easy as
&gt; using -a instead of -r.
&gt;
&gt; In any case, I'm just going to delete any .stamp files in my build
&gt; process. 

I would recommend that you either arrange to preserve timestamps, or
delete all generated files that make knows how to recreate. Otherwise,
the steps performed by make during the build will depend on the order in
which the files happened to be copied, which seems brittle.

&gt; And I wanted to be a good downstream user and report what I perceived
&gt; as a packaging hickup.

Thanks. I wasn't aware if this failure mode. I don't see any great
solution. 

It would be nice if one could tell make that there's a dependency chain

  foo.c --&gt; foo --&gt; bar

and that foo (the executable) is unimportant. That should mean that as
long as bar is more recent than foo.c, there's no need to remake bar,
and no need to remake foo, no matter if foo happens to be out-of-date or
non-existent. The stamp file is a workaround, and as you noticed, it's
not perfect. Is there a better way?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190603122723</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2019-06-03 12:27:23-0400</timestampReceived><subject>Re: Does SHA-1 switch to accelerated automatically?</subject><body>

On Mon, Jun 3, 2019 at 8:21 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; Jeffrey Walton &lt;noloader@gmail.com&gt; writes:
&gt;
&gt; &gt; Are there any plans for ARMv8?
&gt;
&gt; I'm not planning to work on that soon, and I don't have any convenient
&gt; access to ARMv8 hardware. Contributions welcome.

Sorry, I have not acquired a taste for the m4 programming.

You cn access Aarch64 hardware on the GCC Compile Farm. GCC117 and
GCC118 are Aarch64 with crypto extensions.

Jeff
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190606074349</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-06 07:43:49-0400</timestampReceived><subject>Re: siv and cmac</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I think the siv code could benefit from a funtion to create a cmac
&gt; digest in one step, without the update/digest split and the intermediate
&gt; buffer. That would be something like
&gt;
&gt; cmac128_message(const struct cmac128_key *key, const void *cipher,
&gt;                 nettle_crypt_func *encrypt,
&gt;                 size_t digest_length, uint8_t *digest,
&gt;                 size_t message_length, const uint8_t *message);

I haven't added a function like this, but I've now done the changes needed
for const context to the siv_*_message functions.

For CMAC, the lowest-level functions now take cmac128_key and
cmac128_ctx as separate arguments, the former const where appropriate.
These changes pushed to master, and it's similar to how gcm is done.

I then merged these changes into the siv-mode branch, and updated it
accordingly. The _siv_s2v function now takes a const struct cmac128_key
argument, and uses a local struct cmac128_ctx with _init, _update,
_digest to process the strings with cmac. This enables use of const
further up the call chain.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190607064149</emailId><senderName>Wim Lewis</senderName><senderEmail>wiml@hhhh.org</senderEmail><timestampReceived>2019-06-07 06:41:49-0400</timestampReceived><subject>Re: Curve point decompression</subject><body>

I've pushed a few more changes to that repository; decompression now 
works for P-192 and P-224 as well.

I think this is done --- Niels, can you consider this a pull/review 
request, or would you rather I send a patch (or git-bundle) to the list?

The tests have almost but not quite 100% branch coverage. The few 
uncovered branches are either cases which I think are allowed by other 
functions' specification but not by their current implementation, or 
things that I think are mathematically impossible but can't trivially 
prove.

On Wed, May 29, 2019 at 01:25:08AM -0700, Wim Lewis wrote:
&gt; I've pushed some work-in-progress to a git repository here:
&gt;   https://git.lysator.liu.se/wiml/nettle
&gt; 
&gt; There's more to be done, but I would appreciate any comments or feedback
&gt; people might have. This is all the time I have available to put into it
&gt; right now, but I hope to return to it before too long.
&gt; 
&gt; The changes add two new public functions:
&gt;    - ecc_point_set_compact() which is like ecc_point_set but accepts a point
&gt; in compact form (X and Y's parity/sign rather than X and Y)
&gt;    - ecc_point_set_from_octets() which interprets a point converted to an
&gt; octet string by the rules set out in X9.62 and SEC.1, including compressed,
&gt; uncompressed, and hybrid points
&gt; 
&gt; I'm not terribly happy with the name ecc_point_set_compact(); does anyone
&gt; have a suggestion for a better name?
&gt; 
&gt; Internals:
&gt; 
&gt; Decompression works for P-256, P-384, and P-521, but it still needs sqrt
&gt; implementations for P-192 and P-224. P-224 will be much more complex than
&gt; the others (the c^((p-3)/4) shortcut doesn't apply), but there's a paper by
&gt; djb on computing square roots in it.
&gt; 
&gt; I added a second slot to the `ecc_modulo` struct to contain a sqrt(u)
&gt; implementation (as opposed to the existing sqrt(u/v) implementation). The
&gt; slot, and the typedef that describes functions in that slot, need better
&gt; names.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190607120630</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-06-07 12:06:30-0400</timestampReceived><subject>[PATCH v2 0/4] CMAC-64 and 3DES-CMAC support</subject><body>

Add support for CMAC-64 and (in particular) for 3DES-CMAC.

CMAC-64 is used for GOST ciphersuites in TLS and 3DES-CMAC is an easy
reference to test generic CMAC-64 code.

Changes since previous version:
 - adapt to follow changed CMAC-128 interface
 - expand documentation to cover CMAC-64


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190607120631</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-06-07 12:06:31-0400</timestampReceived><subject>[PATCH v2 1/4] Move MAC testing code to generic place from cmac-test</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 testsuite/cmac-test.c | 100 +++++++++++-------------------------------
 testsuite/testutils.c |  64 +++++++++++++++++++++++++++
 testsuite/testutils.h |   6 +++
 3 files changed, 96 insertions(+), 74 deletions(-)

diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
index 31662d1b6c1b..b1d4aa30dfbe 100644
--- a/testsuite/cmac-test.c
+++ b/testsuite/cmac-test.c
@@ -2,83 +2,35 @@
 #include "nettle-internal.h"
 #include "cmac.h"
 
+const struct nettle_mac nettle_cmac_aes128 =
+{
+  "CMAC-AES128",
+  sizeof(struct cmac_aes128_ctx),
+  CMAC128_DIGEST_SIZE,
+  AES128_KEY_SIZE,
+
+  (nettle_set_key_func*) cmac_aes128_set_key,
+  (nettle_hash_update_func*) cmac_aes128_update,
+  (nettle_hash_digest_func*) cmac_aes128_digest
+};
+
+const struct nettle_mac nettle_cmac_aes256 =
+{
+  "CMAC-AES256",
+  sizeof(struct cmac_aes256_ctx),
+  CMAC128_DIGEST_SIZE,
+  AES256_KEY_SIZE,
+
+  (nettle_set_key_func*) cmac_aes256_set_key,
+  (nettle_hash_update_func*) cmac_aes256_update,
+  (nettle_hash_digest_func*) cmac_aes256_digest
+};
+
 #define test_cmac_aes128(key, msg, ref)					\
-  test_cmac_hash ((nettle_set_key_func*) cmac_aes128_set_key,		\
-		  (nettle_hash_update_func*) cmac_aes128_update,	\
-		  (nettle_hash_digest_func*) cmac_aes128_digest,	\
-		  sizeof(struct cmac_aes128_ctx),			\
-		  key, msg, ref)
+  test_mac(&amp;nettle_cmac_aes128, key, msg, ref)
 
 #define test_cmac_aes256(key, msg, ref)					\
-  test_cmac_hash ((nettle_set_key_func*) cmac_aes256_set_key,		\
-		  (nettle_hash_update_func*) cmac_aes256_update,	\
-		  (nettle_hash_digest_func*) cmac_aes256_digest,	\
-		  sizeof(struct cmac_aes256_ctx),			\
-		  key, msg, ref)
-
-static void
-test_cmac_hash (nettle_set_key_func *set_key,
-		nettle_hash_update_func *update,
-		nettle_hash_digest_func *digest, size_t ctx_size,
-		const struct tstring *key, const struct tstring *msg,
-		const struct tstring *ref)
-{
-  void *ctx;
-  uint8_t hash[16];
-  unsigned i;
-
-  ctx = xalloc(ctx_size);
-
-  ASSERT (ref-&gt;length == sizeof(hash));
-  ASSERT (key-&gt;length == 16 || key-&gt;length == 32);
-  set_key (ctx, key-&gt;data);
-  update (ctx, msg-&gt;length, msg-&gt;data);
-  digest (ctx, sizeof(hash), hash);
-  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
-    {
-      fprintf (stderr, "cmac_hash failed, msg: ");
-      print_hex (msg-&gt;length, msg-&gt;data);
-      fprintf(stderr, "Output:");
-      print_hex (16, hash);
-      fprintf(stderr, "Expected:");
-      tstring_print_hex(ref);
-      fprintf(stderr, "\n");
-      FAIL();
-    }
-
-  /* attempt to re-use the structure */
-  update (ctx, msg-&gt;length, msg-&gt;data);
-  digest (ctx, sizeof(hash), hash);
-  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
-    {
-      fprintf (stderr, "cmac_hash failed on re-use, msg: ");
-      print_hex (msg-&gt;length, msg-&gt;data);
-      fprintf(stderr, "Output:");
-      print_hex (16, hash);
-      fprintf(stderr, "Expected:");
-      tstring_print_hex(ref);
-      fprintf(stderr, "\n");
-      FAIL();
-    }
-
-  /* attempt byte-by-byte hashing */
-  set_key (ctx, key-&gt;data);
-  for (i=0;i&lt;msg-&gt;length;i++)
-    update (ctx, 1, msg-&gt;data+i);
-  digest (ctx, sizeof(hash), hash);
-  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
-    {
-      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
-      print_hex (msg-&gt;length, msg-&gt;data);
-      fprintf(stderr, "Output:");
-      print_hex (16, hash);
-      fprintf(stderr, "Expected:");
-      tstring_print_hex(ref);
-      fprintf(stderr, "\n");
-      FAIL();
-    }
-  free (ctx);
-}
+  test_mac(&amp;nettle_cmac_aes256, key, msg, ref)
 
 void
 test_main(void)
diff --git a/testsuite/testutils.c b/testsuite/testutils.c
index 337e4c4c7cd1..2a19c0ac8205 100644
--- a/testsuite/testutils.c
+++ b/testsuite/testutils.c
@@ -924,6 +924,70 @@ test_hash_large(const struct nettle_hash *hash,
   free(data);
 }
 
+void
+test_mac(const struct nettle_mac *mac,
+	 const struct tstring *key,
+	 const struct tstring *msg,
+	 const struct tstring *digest)
+{
+  void *ctx = xalloc(mac-&gt;context_size);
+  uint8_t *hash = xalloc(mac-&gt;digest_size);
+  unsigned i;
+
+
+  ASSERT (digest-&gt;length == mac-&gt;digest_size);
+  ASSERT (key-&gt;length == mac-&gt;key_size);
+  mac-&gt;set_key (ctx, key-&gt;data);
+  mac-&gt;update (ctx, msg-&gt;length, msg-&gt;data);
+  mac-&gt;digest (ctx, digest-&gt;length, hash);
+
+  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
+    {
+      fprintf (stderr, "test_mac failed, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (mac-&gt;digest_size, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(digest);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt to re-use the structure */
+  mac-&gt;update (ctx, msg-&gt;length, msg-&gt;data);
+  mac-&gt;digest (ctx, digest-&gt;length, hash);
+  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
+    {
+      fprintf (stderr, "test_mac: failed on re-use, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (mac-&gt;digest_size, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(digest);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  /* attempt byte-by-byte hashing */
+  mac-&gt;set_key (ctx, key-&gt;data);
+  for (i=0;i&lt;msg-&gt;length;i++)
+    mac-&gt;update (ctx, 1, msg-&gt;data+i);
+  mac-&gt;digest (ctx, digest-&gt;length, hash);
+  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
+    {
+      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
+      print_hex (msg-&gt;length, msg-&gt;data);
+      fprintf(stderr, "Output:");
+      print_hex (16, hash);
+      fprintf(stderr, "Expected:");
+      tstring_print_hex(digest);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  free (ctx);
+  free (hash);
+}
+
 void
 test_armor(const struct nettle_armor *armor,
            size_t data_length,
diff --git a/testsuite/testutils.h b/testsuite/testutils.h
index ded57db6ab4f..f4ea38da9deb 100644
--- a/testsuite/testutils.h
+++ b/testsuite/testutils.h
@@ -170,6 +170,12 @@ test_hash_large(const struct nettle_hash *hash,
 		uint8_t c,
 		const struct tstring *digest);
 
+void
+test_mac(const struct nettle_mac *mac,
+	 const struct tstring *key,
+	 const struct tstring *msg,
+	 const struct tstring *digest);
+
 void
 test_armor(const struct nettle_armor *armor,
            size_t data_length,
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190607120632</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-06-07 12:06:32-0400</timestampReceived><subject>[PATCH v2 2/4] cmac: add 64-bit mode CMAC</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 cmac.c         | 125 ++++++++++++++++++++++++++++++++++++++++++++++++-
 cmac.h         |  69 +++++++++++++++++++++++++++
 nettle-types.h |   7 +++
 3 files changed, 200 insertions(+), 1 deletion(-)

diff --git a/cmac.c b/cmac.c
index c5a59b18e572..e93e26947b19 100644
--- a/cmac.c
+++ b/cmac.c
@@ -1,9 +1,10 @@
 /*
-   AES-CMAC-128 (rfc 4493)
+   AES-CMAC-128 (rfc 4493) / CMAC-64
    Copyright (C) Stefan Metzmacher 2012
    Copyright (C) Jeremy Allison 2012
    Copyright (C) Michael Adam 2012
    Copyright (C) 2017, Red Hat Inc.
+   Copyright (C) 2019, Dmitry Eremin-Solenikov
 
    This file is part of GNU Nettle.
 
@@ -56,6 +57,15 @@ block_mulx(union nettle_block16 *dst,
   dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
   dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) ^ (0x87 &amp; -carry);
 }
+
+static void
+block_mulx8(union nettle_block8 *dst,
+	    const union nettle_block8 *src)
+{
+  uint64_t carry = src-&gt;u64 &gt;&gt; 63;
+
+  dst-&gt;u64 = (src-&gt;u64 &lt;&lt; 1) ^ (0x1b &amp; -carry);
+}
 #else /* !WORDS_BIGENDIAN */
 #define LE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
                      (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
@@ -67,6 +77,15 @@ block_mulx(union nettle_block16 *dst,
   dst-&gt;u64[0] = LE_SHIFT(src-&gt;u64[0]) | ((src-&gt;u64[1] &amp; 0x80) &lt;&lt; 49);
   dst-&gt;u64[1] = LE_SHIFT(src-&gt;u64[1]) ^ (0x8700000000000000 &amp; -carry);
 }
+
+static void
+block_mulx8(union nettle_block8 *dst,
+	   const union nettle_block8 *src)
+{
+  uint64_t carry = (src-&gt;u64 &amp; 0x80) &gt;&gt; 7;
+
+  dst-&gt;u64 = LE_SHIFT(src-&gt;u64) ^ (0x1b00000000000000 &amp; -carry);
+}
 #endif /* !WORDS_BIGENDIAN */
 
 void
@@ -173,3 +192,107 @@ cmac128_digest(struct cmac128_ctx *ctx, const struct cmac128_key *key,
   /* reset state for re-use */
   cmac128_init(ctx);
 }
+
+void
+cmac64_set_key(struct cmac64_key *key, const void *cipher,
+	       nettle_cipher_func *encrypt)
+{
+  static const union nettle_block8 zero_block;
+  union nettle_block8 L;
+
+  /* step 1 - generate subkeys k1 and k2 */
+  encrypt(cipher, 8, L.b, zero_block.b);
+
+  block_mulx8(&amp;key-&gt;K1, &amp;L);
+  block_mulx8(&amp;key-&gt;K2, &amp;key-&gt;K1);
+}
+
+void
+cmac64_init(struct cmac64_ctx *ctx)
+{
+  memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
+  ctx-&gt;index = 0;
+}
+
+void
+cmac64_update(struct cmac64_ctx *ctx, const void *cipher,
+	      nettle_cipher_func *encrypt,
+	      size_t msg_len, const uint8_t *msg)
+{
+  union nettle_block16 Y;
+  /*
+   * check if we expand the block
+   */
+  if (ctx-&gt;index &lt; 8)
+    {
+      size_t len = MIN(8 - ctx-&gt;index, msg_len);
+      memcpy(&amp;ctx-&gt;block.b[ctx-&gt;index], msg, len);
+      msg += len;
+      msg_len -= len;
+      ctx-&gt;index += len;
+    }
+
+  if (msg_len == 0) {
+    /* if it is still the last block, we are done */
+    return;
+  }
+
+  /*
+   * now checksum everything but the last block
+   */
+  memxor3(Y.b, ctx-&gt;X.b, ctx-&gt;block.b, 8);
+  encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
+
+  while (msg_len &gt; 8)
+    {
+      memxor3(Y.b, ctx-&gt;X.b, msg, 8);
+      encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
+      msg += 8;
+      msg_len -= 8;
+    }
+
+  /*
+   * copy the last block, it will be processed in
+   * cmac64_digest().
+   */
+  memcpy(ctx-&gt;block.b, msg, msg_len);
+  ctx-&gt;index = msg_len;
+}
+
+void
+cmac64_digest(struct cmac64_ctx *ctx, const struct cmac64_key *key,
+	      const void *cipher, nettle_cipher_func *encrypt,
+	      unsigned length, uint8_t *dst)
+{
+  union nettle_block8 Y;
+
+  memset(ctx-&gt;block.b+ctx-&gt;index, 0, sizeof(ctx-&gt;block.b)-ctx-&gt;index);
+
+  /* re-use ctx-&gt;block for memxor output */
+  if (ctx-&gt;index &lt; 8)
+    {
+      ctx-&gt;block.b[ctx-&gt;index] = 0x80;
+      memxor(ctx-&gt;block.b, key-&gt;K2.b, 8);
+    }
+  else
+    {
+      memxor(ctx-&gt;block.b, key-&gt;K1.b, 8);
+    }
+
+  memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 8);
+
+  assert(length &lt;= 8);
+  if (length == 8)
+    {
+      encrypt(cipher, 8, dst, Y.b);
+    }
+  else
+    {
+      encrypt(cipher, 8, ctx-&gt;block.b, Y.b);
+      memcpy(dst, ctx-&gt;block.b, length);
+    }
+
+  /* reset state for re-use */
+  memset(&amp;ctx-&gt;X, 0, sizeof(ctx-&gt;X));
+  ctx-&gt;index = 0;
+}
diff --git a/cmac.h b/cmac.h
index 3c5b7bea3e55..0cf9462d2120 100644
--- a/cmac.h
+++ b/cmac.h
@@ -44,6 +44,7 @@ extern "C" {
 #endif
 
 #define CMAC128_DIGEST_SIZE 16
+#define CMAC64_DIGEST_SIZE 8
 
 #define cmac128_set_key nettle_cmac128_set_key
 #define cmac128_init nettle_cmac128_init
@@ -56,6 +57,11 @@ extern "C" {
 #define cmac_aes256_update nettle_cmac_aes256_update
 #define cmac_aes256_digest nettle_cmac_aes256_digest
 
+#define cmac64_set_key nettle_cmac64_set_key
+#define cmac64_init nettle_cmac64_init
+#define cmac64_update nettle_cmac64_update
+#define cmac64_digest nettle_cmac64_digest
+
 struct cmac128_key
 {
   union nettle_block16 K1;
@@ -72,6 +78,22 @@ struct cmac128_ctx
   size_t index;
 };
 
+struct cmac64_key
+{
+  union nettle_block8 K1;
+  union nettle_block8 K2;
+};
+
+struct cmac64_ctx
+{
+  /* MAC state */
+  union nettle_block8 X;
+
+  /* Block buffer */
+  union nettle_block8 block;
+  size_t index;
+};
+
 void
 cmac128_set_key(struct cmac128_key *key, const void *cipher,
 		nettle_cipher_func *encrypt);
@@ -118,6 +140,53 @@ cmac128_digest(struct cmac128_ctx *ctx, const struct cmac128_key *key,
 		      (nettle_cipher_func *) (encrypt),		\
 		      (length), (digest)))
 
+void
+cmac64_set_key(struct cmac64_key *key, const void *cipher,
+		nettle_cipher_func *encrypt);
+
+void
+cmac64_init(struct cmac64_ctx *ctx);
+
+void
+cmac64_update(struct cmac64_ctx *ctx, const void *cipher,
+	       nettle_cipher_func *encrypt,
+	       size_t msg_len, const uint8_t *msg);
+
+void
+cmac64_digest(struct cmac64_ctx *ctx, const struct cmac64_key *key,
+	       const void *cipher, nettle_cipher_func *encrypt,
+	       unsigned length, uint8_t *digest);
+
+
+#define CMAC64_CTX(type) \
+  { struct cmac64_key key; struct cmac64_ctx ctx; type cipher; }
+
+/* NOTE: Avoid using NULL, as we don't include anything defining it. */
+#define CMAC64_SET_KEY(self, set_key, encrypt, cmac_key)	\
+  do {								\
+    (set_key)(&amp;(self)-&gt;cipher, (cmac_key));			\
+    if (0) (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,		\
+		     (uint8_t *) 0, (const uint8_t *) 0);	\
+    cmac64_set_key(&amp;(self)-&gt;key, &amp;(self)-&gt;cipher,		\
+		    (nettle_cipher_func *) (encrypt));		\
+    cmac64_init(&amp;(self)-&gt;ctx);					\
+  } while (0)
+
+#define CMAC64_UPDATE(self, encrypt, length, src)		\
+  (0 ? (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,			\
+		 (uint8_t *) 0, (const uint8_t *) 0)		\
+     : cmac64_update(&amp;(self)-&gt;ctx, &amp;(self)-&gt;cipher,		\
+		      (nettle_cipher_func *)encrypt,		\
+		      (length), (src)))
+
+#define CMAC64_DIGEST(self, encrypt, length, digest)		\
+  (0 ? (encrypt)(&amp;(self)-&gt;cipher, ~(size_t) 0,			\
+		 (uint8_t *) 0, (const uint8_t *) 0)		\
+     : cmac64_digest(&amp;(self)-&gt;ctx, &amp;(self)-&gt;key,		\
+		      &amp;(self)-&gt;cipher,				\
+		      (nettle_cipher_func *) (encrypt),		\
+		      (length), (digest)))
+
 struct cmac_aes128_ctx CMAC128_CTX(struct aes128_ctx);
 
 void
diff --git a/nettle-types.h b/nettle-types.h
index 87292ac69730..e06c85c48f8c 100644
--- a/nettle-types.h
+++ b/nettle-types.h
@@ -65,6 +65,13 @@ union nettle_block16
   uint64_t u64[2];
 };
 
+union nettle_block8
+{
+  uint8_t b[8];
+  unsigned long w[8 / sizeof(unsigned long)];
+  uint64_t u64;
+};
+
 /* Randomness. Used by key generation and dsa signature creation. */
 typedef void nettle_random_func(void *ctx,
 				size_t length, uint8_t *dst);
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190607120633</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-06-07 12:06:33-0400</timestampReceived><subject>[PATCH v2 3/4] cmac: add CMAC-DES3 (CMAC-TDES) implementation</subject><body>

Implement CMAC using TrippleDES as underlying cipher.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in           |  2 +-
 cmac-des3.c           | 61 +++++++++++++++++++++++++++++++++++++++++++
 cmac.h                | 17 ++++++++++++
 testsuite/cmac-test.c | 32 +++++++++++++++++++++++
 4 files changed, 111 insertions(+), 1 deletion(-)
 create mode 100644 cmac-des3.c

diff --git a/Makefile.in b/Makefile.in
index a6b8ffd6693e..8ade1834499d 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -101,7 +101,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-aes256.c gcm-aes256-meta.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
-		 cmac.c cmac-aes128.c cmac-aes256.c \
+		 cmac.c cmac-aes128.c cmac-aes256.c cmac-des3.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
diff --git a/cmac-des3.c b/cmac-des3.c
new file mode 100644
index 000000000000..d2d55ca43e75
--- /dev/null
+++ b/cmac-des3.c
@@ -0,0 +1,61 @@
+/* cmac-des3.c
+
+   CMAC using TrippleDES as the underlying cipher.
+
+   Copyright (C) 2019 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "cmac.h"
+
+void
+cmac_des3_set_key (struct cmac_des3_ctx *ctx, const uint8_t *key)
+{
+  CMAC64_SET_KEY (ctx, des3_set_key, des3_encrypt, key);
+}
+
+void
+cmac_des3_update (struct cmac_des3_ctx *ctx,
+		  size_t length, const uint8_t *data)
+{
+  CMAC64_UPDATE (ctx, des3_encrypt, length, data);
+}
+
+void
+cmac_des3_digest (struct cmac_des3_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  CMAC64_DIGEST (ctx, des3_encrypt, length, digest);
+}
+
diff --git a/cmac.h b/cmac.h
index 0cf9462d2120..ecad3778f71e 100644
--- a/cmac.h
+++ b/cmac.h
@@ -37,6 +37,7 @@
 #define NETTLE_CMAC_H_INCLUDED
 
 #include "aes.h"
+#include "des.h"
 #include "nettle-types.h"
 
 #ifdef __cplusplus
@@ -61,6 +62,9 @@ extern "C" {
 #define cmac64_init nettle_cmac64_init
 #define cmac64_update nettle_cmac64_update
 #define cmac64_digest nettle_cmac64_digest
+#define cmac_des3_set_key nettle_cmac_des3_set_key
+#define cmac_des3_update nettle_cmac_des3_update
+#define cmac_des3_digest nettle_cmac_des3_digest
 
 struct cmac128_key
 {
@@ -213,6 +217,19 @@ void
 cmac_aes256_digest(struct cmac_aes256_ctx *ctx,
 		   size_t length, uint8_t *digest);
 
+struct cmac_des3_ctx CMAC64_CTX(struct des3_ctx);
+
+void
+cmac_des3_set_key(struct cmac_des3_ctx *ctx, const uint8_t *key);
+
+void
+cmac_des3_update(struct cmac_des3_ctx *ctx,
+		 size_t length, const uint8_t *data);
+
+void
+cmac_des3_digest(struct cmac_des3_ctx *ctx,
+		 size_t length, uint8_t *digest);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
index b1d4aa30dfbe..9d6682777dcf 100644
--- a/testsuite/cmac-test.c
+++ b/testsuite/cmac-test.c
@@ -26,12 +26,27 @@ const struct nettle_mac nettle_cmac_aes256 =
   (nettle_hash_digest_func*) cmac_aes256_digest
 };
 
+const struct nettle_mac nettle_cmac_des3 =
+{
+  "CMAC-3DES",
+  sizeof(struct cmac_des3_ctx),
+  CMAC64_DIGEST_SIZE,
+  DES3_KEY_SIZE,
+
+  (nettle_set_key_func*) cmac_des3_set_key,
+  (nettle_hash_update_func*) cmac_des3_update,
+  (nettle_hash_digest_func*) cmac_des3_digest
+};
+
 #define test_cmac_aes128(key, msg, ref)					\
   test_mac(&amp;nettle_cmac_aes128, key, msg, ref)
 
 #define test_cmac_aes256(key, msg, ref)					\
   test_mac(&amp;nettle_cmac_aes256, key, msg, ref)
 
+#define test_cmac_des3(key, msg, ref)					\
+  test_mac(&amp;nettle_cmac_des3, key, msg, ref)
+
 void
 test_main(void)
 {
@@ -96,4 +111,21 @@ test_main(void)
 		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710"),
  SHEX("e1992190549f6ed5696a2c056c315410"));
 
+  /* CMAC-3DES vectors from NIST SP800-38B examples */
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SDATA(""),
+		  SHEX("7db0d37df936c550"));
+
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172a"),
+		  SHEX("30239cf1f52e6609"));
+
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a57"),
+		  SHEX("6c9f3ee4923f6be2"));
+
+
+  test_cmac_des3 (SHEX("0123456789abcdef23456789abcdef01456789abcdef0123"),
+		  SHEX("6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e51"),
+		  SHEX("99429bd0bf7904e5"));
 }
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190607120634</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-06-07 12:06:34-0400</timestampReceived><subject>[PATCH v2 4/4] Expand documentation to cover CMAC-64</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 nettle.texinfo | 38 ++++++++++++++++++++++++++++++++++----
 1 file changed, 34 insertions(+), 4 deletions(-)

diff --git a/nettle.texinfo b/nettle.texinfo
index 547e0c2b462c..9670bf119211 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -3718,14 +3718,21 @@ as described above, the new value is used unless you call the
 @node CMAC,, UMAC, Keyed hash functions
 @subsection @acronym{CMAC}
 @cindex CMAC
+@cindex CMAC-128
+@cindex CMAC-64
 
 @acronym{CMAC} is a message authentication code based on CBC encryption
 mode. It is suitable for systems where block ciphers are preferrable
-and perform better than hash functions. @acronym{CMAC} is specified in
+and perform better than hash functions. @acronym{CMAC-128} is specified in
 @cite{RFC4493}. The block size is always 128 bits (16 octets).
+@acronym{CMAC-64} is specified by
+@uref{https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38B.pdf,
+NIST Special Publication 800-38B}. The block size is always 64 bits
+(8 octets).
 
-Nettle provides helper functions for @acronym{CMAC } with
-the @acronym{AES} block cipher.
+Nettle provides helper functions for @acronym{CMAC-128} with
+the @acronym{AES} block cipher and for @acronym{CMAC-64} with
+the @acronym{Tripple-DES} block cipher.
 
 Nettle defines @acronym{CMAC} in @file{&lt;nettle/cmac.h&gt;}.
 
@@ -3734,7 +3741,7 @@ Nettle defines @acronym{CMAC} in @file{&lt;nettle/cmac.h&gt;}.
 @end deftp
 
 @defvr Constant CMAC128_DIGEST_SIZE
-The size of an CMAC digest, 16.
+The size of an CMAC-128 digest, 16.
 @end defvr
 
 @deftypefun void cmac_aes128_set_key (struct cmac_aes128_ctx *@var{ctx}, const \
uint8_t *@var{key}) @@ -3769,6 +3776,29 @@ provide a smaller value, only the first \
@var{length} octets of the  processing of a new message with the same key.
 @end deftypefun
 
+@deftp {Context struct} {struct cmac_des3_ctx}
+@end deftp
+
+@defvr Constant CMAC64_DIGEST_SIZE
+The size of an CMAC-64 digest, 8.
+@end defvr
+
+@deftypefun void cmac_des3_set_key (struct cmac_des3_ctx *@var{ctx}, const uint8_t \
*@var{key}) +This function initializes the @acronym{CMAC} context struct for \
@acronym{Tripple-DES}. +@end deftypefun
+
+@deftypefun void cmac_des3_update (struct cmac_des3_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +This function is called zero or more times \
to process the message. +@end deftypefun
+
+@deftypefun void cmac_des3_digest (struct cmac_des3_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Extracts the @acronym{MAC} of the message, \
writing it to @var{digest}. +@var{length} is usually equal to the specified output \
size, but if you +provide a smaller value, only the first @var{length} octets of the
+@acronym{MAC} are written. This function resets the context for
+processing of a new message with the same key.
+@end deftypefun
+
 @node Poly1305,, CMAC, Keyed hash functions
 @comment  node-name,  next,  previous,  up
 @subsection Poly1305
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190609234708</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-06-09 23:47:08-0400</timestampReceived><subject>Re: curve448 branch</subject><body>

Hi,

вс, 9 июн. 2019 г. в 15:04, Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;:
&gt; пт, 7 июн. 2019 г. в 00:27, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt; &gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt; &gt;
&gt; &gt; &gt; I'm still playing around HMAC/digest refactoring, but I'm not happy with the
&gt; &gt; &gt; way code looks in my tree.
&gt; &gt;
&gt; &gt; Below patch is a faitly simple way to do it. It adds internal functions
&gt; &gt; with a state_size argument, uses that when saving and restoring state,
&gt; &gt; and switches hmac_md5 to a new smaller context struct.
&gt;
&gt; I have pushed my current state to
&gt; https://gitlab.com/GostCrypt/nettle/tree/hmac-2
&gt;
&gt; MD5 and HMAC-MD5 were converted to demonstrate my proposal.
&gt;
&gt; The key change is the split of md5_ctx into md5_state and block_ctx
&gt; and later reusal
&gt; of common block_ctx in all operations. Unfortunately this changes nettle_hash
&gt; interface.

I have pushed https://gitlab.com/GostCrypt/nettle/tree/hmac-3. I have
fixed nettle_hash interface by introducing nettle_bctx_hash structure.
Also I have converted all present HMAC algorithms.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190613151433</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-06-13 15:14:33-0400</timestampReceived><subject>[PATCH 0/3] Add support for deterministic DSA/ECDSA (RFC 6979)</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

This series adds a variant of DSA/ECDSA signing functions that doesn't
require random source to generate signature.  The construction of the
random parameter k is implemented according to RFC 6979, which will be
part of FIPS 186-5:
https://csrc.nist.gov/CSRC/media/Presentations/NIST-Status-Update-on-Elliptic-Curves-and-Post-Qua/images-media/moody-dustin-threshold-crypto-workshop-March-2019.pdf


The motivation behind this is to make it easier to check the DSA/ECDSA
functionality in the circumstances where no proper random sources are
available, e.g., in the libary self-tests at early boot stage.

Daiki Ueno (3):
  dsa: Add a function to find k deterministically
  ecdsa: Add support for deterministic signature generation
  dsa: Add support for deterministic signature generation

 Makefile.in                               |   6 +-
 dsa-compute-k.c                           | 169 ++++++++++++++++++++++
 dsa-compute-k.h                           |  63 ++++++++
 dsa-sign-deterministic.c                  | 107 ++++++++++++++
 dsa.h                                     |  12 ++
 ecdsa-sign-deterministic.c                |  78 ++++++++++
 ecdsa.h                                   |  11 ++
 testsuite/.gitignore                      |   2 +
 testsuite/.test-rules.make                |   6 +
 testsuite/Makefile.in                     |   4 +-
 testsuite/dsa-compute-k-test.c            |  85 +++++++++++
 testsuite/dsa-test.c                      | 148 ++++++++++++++++++-
 testsuite/ecdsa-sign-deterministic-test.c | 164 +++++++++++++++++++++
 13 files changed, 851 insertions(+), 4 deletions(-)
 create mode 100644 dsa-compute-k.c
 create mode 100644 dsa-compute-k.h
 create mode 100644 dsa-sign-deterministic.c
 create mode 100644 ecdsa-sign-deterministic.c
 create mode 100644 testsuite/dsa-compute-k-test.c
 create mode 100644 testsuite/ecdsa-sign-deterministic-test.c

-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190613151434</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-06-13 15:14:34-0400</timestampReceived><subject>[PATCH 1/3] dsa: Add a function to find k deterministically</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

This adds the _dsa_compute_k function that generates DSA/ECDSA k value
from the private key and the hashed message, according to RFC 6979.

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 Makefile.in                    |   5 +-
 dsa-compute-k.c                | 169 +++++++++++++++++++++++++++++++++
 dsa-compute-k.h                |  63 ++++++++++++
 testsuite/.gitignore           |   1 +
 testsuite/.test-rules.make     |   3 +
 testsuite/Makefile.in          |   3 +-
 testsuite/dsa-compute-k-test.c |  85 +++++++++++++++++
 7 files changed, 326 insertions(+), 3 deletions(-)
 create mode 100644 dsa-compute-k.c
 create mode 100644 dsa-compute-k.h
 create mode 100644 testsuite/dsa-compute-k-test.c

diff --git a/Makefile.in b/Makefile.in
index a6b8ffd6..b0adcb3c 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -186,7 +186,8 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  eddsa-compress.c eddsa-decompress.c eddsa-expand.c \
 		  eddsa-hash.c eddsa-pubkey.c eddsa-sign.c eddsa-verify.c \
 		  ed25519-sha512-pubkey.c \
-		  ed25519-sha512-sign.c ed25519-sha512-verify.c
+		  ed25519-sha512-sign.c ed25519-sha512-verify.c \
+		  dsa-compute-k.c
 
 OPT_SOURCES = fat-x86_64.c fat-arm.c mini-gmp.c
 
@@ -236,7 +237,7 @@ DISTFILES = $(SOURCES) $(HEADERS) getopt.h getopt_int.h \
 	ctr-internal.h chacha-internal.h sha3-internal.h \
 	salsa20-internal.h umac-internal.h hogweed-internal.h \
 	rsa-internal.h pkcs1-internal.h dsa-internal.h eddsa-internal.h \
-	gmp-glue.h ecc-internal.h fat-setup.h \
+	gmp-glue.h ecc-internal.h fat-setup.h dsa-compute-k.h \
 	mini-gmp.h asm.m4 \
 	nettle.texinfo nettle.info nettle.html nettle.pdf sha-example.c
 
diff --git a/dsa-compute-k.c b/dsa-compute-k.c
new file mode 100644
index 00000000..ba9b50df
--- /dev/null
+++ b/dsa-compute-k.c
@@ -0,0 +1,169 @@
+/* dsa-compute-k.c
+
+   Deterministically find k value for ECDSA/DSA (RFC-6979).
+
+   Copyright (C) 2019 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "dsa-compute-k.h"
+
+#include "gmp-glue.h"
+#include "nettle-internal.h"
+#include &lt;string.h&gt;
+
+#define MIN(x, y) ((x) &lt; (y) ? (x) : (y))
+#define MAX(x, y) ((x) &lt; (y) ? (y) : (x))
+
+void
+_dsa_compute_k (mp_limb_t *k,
+		mp_size_t qn,
+		const mp_limb_t *q,
+		const mp_limb_t *x,
+		void *mac_ctx,
+		nettle_hash_update_func *set_key,
+		nettle_hash_update_func *update,
+		nettle_hash_digest_func *digest,
+		size_t digest_length,
+		const uint8_t *digest_message)
+{
+  TMP_DECL(V, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);
+  TMP_DECL(K, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);
+  TMP_GMP_DECL(xp, uint8_t);
+  TMP_GMP_DECL(hp, uint8_t);
+  TMP_GMP_DECL(tp, uint8_t);
+  TMP_GMP_DECL(h, mp_limb_t);
+  mp_size_t hn = (digest_length + sizeof(mp_limb_t) - 1) / sizeof(mp_limb_t);
+  mp_bitcnt_t q_bits = mpn_sizeinbase (q, qn, 2);
+  mp_bitcnt_t h_bits;
+  mp_bitcnt_t k_bits;
+  size_t nbytes = (q_bits + 7) / 8;
+  const uint8_t c0 = 0x00;
+  const uint8_t c1 = 0x01;
+
+  TMP_ALLOC(V, digest_length);
+  TMP_ALLOC(K, digest_length);
+  TMP_GMP_ALLOC(xp, nbytes);
+  TMP_GMP_ALLOC(hp, nbytes);
+  TMP_GMP_ALLOC(tp, nbytes);
+  TMP_GMP_ALLOC(h, MAX(hn, qn) * sizeof(mp_limb_t));
+
+  /* int2octets(x) */
+  mpn_get_base256 (xp, nbytes, x, qn);
+
+  /* bits2octets(h) */
+  mpn_set_base256 (h, hn, digest_message, digest_length);
+  if (hn &gt; qn)
+    mpn_copyi (h, &amp;h[hn - qn], qn);
+  else if (hn &lt; qn)
+    mpn_zero (&amp;h[hn], qn - hn);
+  if (h[qn - 1] &gt; 0)
+    {
+      h_bits = ((mpn_sizeinbase (h, qn, 2) + 7) / 8) * 8;
+      if (h_bits &gt; q_bits)
+	mpn_rshift (h, h, qn, h_bits - q_bits);
+    }
+  cnd_sub_n (mpn_cmp (h, q, qn) &gt; 0, h, q, qn);
+  mpn_get_base256 (hp, nbytes, h, qn);
+
+  /* Step b */
+  memset (V, c1, digest_length);
+
+  /* Step c */
+  memset (K, c0, digest_length);
+  set_key (mac_ctx, digest_length, K);
+
+  /* Step d */
+  update (mac_ctx, digest_length, V);
+  update (mac_ctx, 1, &amp;c0);
+  update (mac_ctx, nbytes, xp);
+  update (mac_ctx, nbytes, hp);
+  digest (mac_ctx, digest_length, K);
+  set_key (mac_ctx, digest_length, K);
+
+  /* Step e */
+  update (mac_ctx, digest_length, V);
+  digest (mac_ctx, digest_length, V);
+
+  /* Step f */
+  update (mac_ctx, digest_length, V);
+  update (mac_ctx, 1, &amp;c1);
+  update (mac_ctx, nbytes, xp);
+  update (mac_ctx, nbytes, hp);
+  digest (mac_ctx, digest_length, K);
+  set_key (mac_ctx, digest_length, K);
+
+  /* Step g */
+  update (mac_ctx, digest_length, V);
+  digest (mac_ctx, digest_length, V);
+
+  /* Step h */
+  for (;;)
+    {
+      /* Step 1 */
+      size_t tlen = 0;
+
+      /* Step 2 */
+      while (tlen &lt; nbytes)
+	{
+	  size_t remaining = MIN(nbytes - tlen, digest_length);
+	  update (mac_ctx, digest_length, V);
+	  digest (mac_ctx, digest_length, V);
+	  memcpy (&amp;tp[tlen], V, remaining);
+	  tlen += remaining;
+	}
+
+      /* Step 3 */
+      mpn_set_base256 (k, qn, tp, tlen);
+      if (k[qn - 1] &gt; 0)
+	{
+	  k_bits = ((mpn_sizeinbase (k, qn, 2) + 7) / 8) * 8;
+	  if (k_bits &gt; q_bits)
+	    mpn_rshift (k, k, qn, k_bits - q_bits);
+	}
+      /* Check if k is in [1,q-1] */
+      if (!mpn_zero_p (k, qn) &amp;&amp; mpn_cmp (k, q, qn) &lt; 0)
+	break;
+
+      update (mac_ctx, digest_length, V);
+      update (mac_ctx, 1, &amp;c0);
+      digest (mac_ctx, digest_length, K);
+      set_key (mac_ctx, digest_length, K);
+      update (mac_ctx, digest_length, V);
+      digest (mac_ctx, digest_length, V);
+    }
+
+  TMP_GMP_FREE(xp);
+  TMP_GMP_FREE(hp);
+  TMP_GMP_FREE(tp);
+  TMP_GMP_FREE(h);
+}
diff --git a/dsa-compute-k.h b/dsa-compute-k.h
new file mode 100644
index 00000000..3433e2fb
--- /dev/null
+++ b/dsa-compute-k.h
@@ -0,0 +1,63 @@
+/* dsa-compute-k.h
+
+   Deterministically find k value for ECDSA/DSA (RFC-6979).
+
+   Copyright (C) 2019 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_DSA_COMPUTE_K_H_INCLUDED
+#define NETTLE_DSA_COMPUTE_K_H_INCLUDED
+
+#include "nettle-types.h"
+#include "bignum.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Namespace mangling */
+#define _dsa_compute_k _nettle_dsa_compute_k
+
+void
+_dsa_compute_k (mp_limb_t *k,
+		mp_size_t qn,
+		const mp_limb_t *q,
+		const mp_limb_t *x,
+		void *mac_ctx,
+		nettle_hash_update_func *set_key,
+		nettle_hash_update_func *update,
+		nettle_hash_digest_func *digest,
+		size_t digest_length,
+		const uint8_t *digest_message);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_DSA_COMPUTE_K_H_INCLUDED */
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index 4d680cd1..6adde730 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -22,6 +22,7 @@
 /des-test
 /des3-test
 /dlopen-test
+/dsa-compute-k-test
 /dsa-keygen-test
 /dsa-test
 /eax-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index ab22da23..c3a5bb85 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -277,6 +277,9 @@ eddsa-verify-test$(EXEEXT): eddsa-verify-test.$(OBJEXT)
 ed25519-test$(EXEEXT): ed25519-test.$(OBJEXT)
 	$(LINK) ed25519-test.$(OBJEXT) $(TEST_OBJS) -o ed25519-test$(EXEEXT)
 
+dsa-compute-k-test$(EXEEXT): dsa-compute-k-test.$(OBJEXT)
+	$(LINK) dsa-compute-k-test.$(OBJEXT) $(TEST_OBJS) -o dsa-compute-k-test$(EXEEXT)
+
 sha1-huge-test$(EXEEXT): sha1-huge-test.$(OBJEXT)
 	$(LINK) sha1-huge-test.$(OBJEXT) $(TEST_OBJS) -o sha1-huge-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 9a1fe209..3bc22057 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -52,7 +52,8 @@ TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
 		     ecdsa-sign-test.c ecdsa-verify-test.c \
 		     ecdsa-keygen-test.c ecdh-test.c \
 		     eddsa-compress-test.c eddsa-sign-test.c \
-		     eddsa-verify-test.c ed25519-test.c
+		     eddsa-verify-test.c ed25519-test.c \
+		     dsa-compute-k-test.c
 
 TS_SOURCES = $(TS_NETTLE_SOURCES) $(TS_HOGWEED_SOURCES)
 CXX_SOURCES = cxx-test.cxx
diff --git a/testsuite/dsa-compute-k-test.c b/testsuite/dsa-compute-k-test.c
new file mode 100644
index 00000000..07b0a06e
--- /dev/null
+++ b/testsuite/dsa-compute-k-test.c
@@ -0,0 +1,85 @@
+#include "testutils.h"
+#include "dsa-compute-k.h"
+#include "hmac.h"
+
+static void
+test_dsa_compute_k(const char *sq,
+		   /* Private key */
+		   const char *sx,
+		   /* HMAC */
+		   void *mac_ctx,
+		   nettle_hash_update_func *set_key,
+		   nettle_hash_update_func *update,
+		   nettle_hash_digest_func *digest,
+		   /* Hash */
+		   const struct tstring *h,
+		   /* Expected k */
+		   const char *sk)
+{
+  mpz_t k;
+  mpz_t q;
+  mpz_t x;
+  mpz_t e;
+
+  mpz_init (k);
+  mpz_init_set_str (q, sq, 16);
+  mpz_init_set_str (x, sx, 16);
+  mpz_init_set_str (e, sk, 16);
+
+  _dsa_compute_k (mpz_limbs_write (k, mpz_size (q)),
+		  mpz_size (q), mpz_limbs_read (q), mpz_limbs_read (x),
+		  mac_ctx, set_key, update, digest,
+		  h-&gt;length, h-&gt;data);
+
+  mpz_limbs_finish (k, mpz_size (q));
+
+  if (mpz_cmp (e, k) != 0)
+    {
+      fprintf (stderr, "k = ");
+      mpz_out_str (stderr, 16, k);
+      fprintf (stderr, "\n");
+      fprintf (stderr, "e = ");
+      mpz_out_str (stderr, 16, e);
+      fprintf (stderr, "\n");
+      abort ();
+    }
+
+  mpz_clear (q);
+  mpz_clear (x);
+  mpz_clear (k);
+  mpz_clear (e);
+}
+
+void
+test_main (void)
+{
+  struct hmac_sha256_ctx hmac;
+  struct sha256_ctx hash;
+  uint8_t digest[SHA256_DIGEST_SIZE];
+
+  sha256_init (&amp;hash);
+  sha256_update (&amp;hash, 6, (const uint8_t *)"sample");
+  sha256_digest (&amp;hash, sizeof(digest), digest);
+
+  /* Test vectors from RFC 6979 */
+  test_dsa_compute_k ("996f967f6c8e388d9e28d01e205fba957a5698b1",
+		      "411602cb19a6ccc34494d79d98ef1e7ed5af25f7",
+		      &amp;hmac,
+		      (nettle_hash_update_func *)hmac_sha256_set_key,
+		      (nettle_hash_update_func *)hmac_sha256_update,
+		      (nettle_hash_digest_func *)hmac_sha256_digest,
+		      tstring_data (SHA256_DIGEST_SIZE, digest),
+		      "519ba0546d0c39202a7d34d7dfa5e760b318bcfb");
+
+  test_dsa_compute_k ("f2c3119374ce76c9356990b465374a17f23f9ed3"
+		      "5089bd969f61c6dde9998c1f",
+		      "69c7548c21d0dfea6b9a51c9ead4e27c33d3b3f1"
+		      "80316e5bcab92c933f0e4dbc",
+		      &amp;hmac,
+		      (nettle_hash_update_func *)hmac_sha256_set_key,
+		      (nettle_hash_update_func *)hmac_sha256_update,
+		      (nettle_hash_digest_func *)hmac_sha256_digest,
+		      tstring_data (SHA256_DIGEST_SIZE, digest),
+		      "8926a27c40484216f052f4427cfd5647338b7b39"
+		      "39bc6573af4333569d597c52");
+}
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190613151435</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-06-13 15:14:35-0400</timestampReceived><subject>[PATCH 2/3] ecdsa: Add support for deterministic signature generation</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

This adds the ecdsa_sign_deterministic function that calculates
signature without requiring entropy source.  Instead, it uses the
deterministic construction described in RFC 6979, through
_dsa_compute_k.

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 Makefile.in                               |   2 +-
 ecdsa-sign-deterministic.c                |  78 ++++++++++
 ecdsa.h                                   |  11 ++
 testsuite/.gitignore                      |   1 +
 testsuite/.test-rules.make                |   3 +
 testsuite/Makefile.in                     |   3 +-
 testsuite/ecdsa-sign-deterministic-test.c | 164 ++++++++++++++++++++++
 7 files changed, 260 insertions(+), 2 deletions(-)
 create mode 100644 ecdsa-sign-deterministic.c
 create mode 100644 testsuite/ecdsa-sign-deterministic-test.c

diff --git a/Makefile.in b/Makefile.in
index b0adcb3c..5f77b98d 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -187,7 +187,7 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  eddsa-hash.c eddsa-pubkey.c eddsa-sign.c eddsa-verify.c \
 		  ed25519-sha512-pubkey.c \
 		  ed25519-sha512-sign.c ed25519-sha512-verify.c \
-		  dsa-compute-k.c
+		  dsa-compute-k.c ecdsa-sign-deterministic.c
 
 OPT_SOURCES = fat-x86_64.c fat-arm.c mini-gmp.c
 
diff --git a/ecdsa-sign-deterministic.c b/ecdsa-sign-deterministic.c
new file mode 100644
index 00000000..dd5b88d9
--- /dev/null
+++ b/ecdsa-sign-deterministic.c
@@ -0,0 +1,78 @@
+/* ecdsa-sign-deterministic.c
+
+   Copyright (C) 2013 Niels Möller
+   Copyright (C) 2019 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+/* Development of Nettle's ECC support was funded by the .SE Internet Fund. */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include "ecdsa.h"
+#include "ecc-internal.h"
+#include "nettle-internal.h"
+#include "dsa-compute-k.h"
+
+void
+ecdsa_sign_deterministic (const struct ecc_scalar *key,
+			  void *mac_ctx,
+			  nettle_hash_update_func *set_key,
+			  nettle_hash_update_func *update,
+			  nettle_hash_digest_func *digest,
+			  size_t digest_length,
+			  const uint8_t *digest_message,
+			  struct dsa_signature *signature)
+{
+  /* At most 936 bytes. */
+  TMP_DECL(k, mp_limb_t, ECC_MAX_SIZE + ECC_ECDSA_SIGN_ITCH (ECC_MAX_SIZE));
+  mp_limb_t size = key-&gt;ecc-&gt;p.size;
+  mp_limb_t *rp = mpz_limbs_write (signature-&gt;r, size);
+  mp_limb_t *sp = mpz_limbs_write (signature-&gt;s, size);
+
+  TMP_ALLOC (k, size + ECC_ECDSA_SIGN_ITCH (size));
+
+  /* Timing reveals the number of rounds through this loop, but the
+     timing is still independent of the secret k finally used. */
+  do
+    {
+      _dsa_compute_k (k, key-&gt;ecc-&gt;q.size, key-&gt;ecc-&gt;q.m, key-&gt;p,
+		      mac_ctx, set_key, update, digest,
+		      digest_length, digest_message);
+      ecc_ecdsa_sign (key-&gt;ecc, key-&gt;p, k, digest_length, digest_message,
+		   rp, sp, k + size);
+      mpz_limbs_finish (signature-&gt;r, size);
+      mpz_limbs_finish (signature-&gt;s, size);
+    }
+  while (mpz_sgn (signature-&gt;r) == 0 || mpz_sgn (signature-&gt;s) == 0);
+}
diff --git a/ecdsa.h b/ecdsa.h
index 693aca8b..7d590367 100644
--- a/ecdsa.h
+++ b/ecdsa.h
@@ -43,6 +43,7 @@ extern "C" {
 
 /* Name mangling */
 #define ecdsa_sign nettle_ecdsa_sign
+#define ecdsa_sign_deterministic nettle_ecdsa_sign_deterministic
 #define ecdsa_verify nettle_ecdsa_verify
 #define ecdsa_generate_keypair nettle_ecdsa_generate_keypair
 #define ecc_ecdsa_sign nettle_ecc_ecdsa_sign
@@ -61,6 +62,16 @@ ecdsa_sign (const struct ecc_scalar *key,
 	    const uint8_t *digest,
 	    struct dsa_signature *signature);
 
+void
+ecdsa_sign_deterministic (const struct ecc_scalar *key,
+			  void *mac_ctx,
+			  nettle_hash_update_func *set_key,
+			  nettle_hash_update_func *update,
+			  nettle_hash_digest_func *digest,
+			  size_t digest_length,
+			  const uint8_t *digest_message,
+			  struct dsa_signature *signature);
+
 int
 ecdsa_verify (const struct ecc_point *pub,
 	      size_t length, const uint8_t *digest,
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index 6adde730..10fbbbc0 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -36,6 +36,7 @@
 /ecc-sqrt-test
 /ecdh-test
 /ecdsa-keygen-test
+/ecdsa-sign-deterministic-test
 /ecdsa-sign-test
 /ecdsa-verify-test
 /ed25519-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index c3a5bb85..463c10d0 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -280,6 +280,9 @@ ed25519-test$(EXEEXT): ed25519-test.$(OBJEXT)
 dsa-compute-k-test$(EXEEXT): dsa-compute-k-test.$(OBJEXT)
 	$(LINK) dsa-compute-k-test.$(OBJEXT) $(TEST_OBJS) -o dsa-compute-k-test$(EXEEXT)
 
+ecdsa-sign-deterministic-test$(EXEEXT): ecdsa-sign-deterministic-test.$(OBJEXT)
+	$(LINK) ecdsa-sign-deterministic-test.$(OBJEXT) $(TEST_OBJS) -o ecdsa-sign-deterministic-test$(EXEEXT)
+
 sha1-huge-test$(EXEEXT): sha1-huge-test.$(OBJEXT)
 	$(LINK) sha1-huge-test.$(OBJEXT) $(TEST_OBJS) -o sha1-huge-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 3bc22057..83807d42 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -53,7 +53,8 @@ TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
 		     ecdsa-keygen-test.c ecdh-test.c \
 		     eddsa-compress-test.c eddsa-sign-test.c \
 		     eddsa-verify-test.c ed25519-test.c \
-		     dsa-compute-k-test.c
+		     dsa-compute-k-test.c \
+		     ecdsa-sign-deterministic-test.c
 
 TS_SOURCES = $(TS_NETTLE_SOURCES) $(TS_HOGWEED_SOURCES)
 CXX_SOURCES = cxx-test.cxx
diff --git a/testsuite/ecdsa-sign-deterministic-test.c b/testsuite/ecdsa-sign-deterministic-test.c
new file mode 100644
index 00000000..37b82217
--- /dev/null
+++ b/testsuite/ecdsa-sign-deterministic-test.c
@@ -0,0 +1,164 @@
+#include "testutils.h"
+#include "hmac.h"
+#include "nettle-internal.h"
+
+static void
+test_ecdsa (const struct ecc_curve *ecc,
+	    /* Private key */
+	    const char *sz,
+	    /* HMAC */
+	    void *mac_ctx,
+	    nettle_hash_update_func *set_key,
+	    nettle_hash_update_func *update,
+	    nettle_hash_digest_func *digest,
+	    /* Hash */
+	    const struct tstring *h,
+	    /* Expected signature */
+	    const char *r, const char *s)
+{
+  struct ecc_scalar key;
+  struct dsa_signature ref;
+  struct dsa_signature signature;
+  mpz_t z;
+
+  dsa_signature_init (&amp;ref);
+  dsa_signature_init (&amp;signature);
+
+  mpz_init_set_str (z, sz, 16);
+
+  ecc_scalar_init (&amp;key, ecc);
+  ecc_scalar_set (&amp;key, z);
+
+  ecdsa_sign_deterministic (&amp;key,
+			    mac_ctx, set_key, update, digest,
+			    h-&gt;length, h-&gt;data, &amp;signature);
+
+  mpz_set_str (ref.r, r, 16);
+  mpz_set_str (ref.s, s, 16);
+
+  if (mpz_limbs_cmp (ref.r, mpz_limbs_read (signature.r), ecc-&gt;p.size) != 0
+      || mpz_limbs_cmp (ref.s, mpz_limbs_read (signature.s), ecc-&gt;p.size) != 0)
+    {
+      fprintf (stderr, "_ecdsa_sign failed, bit_size = %u\n", ecc-&gt;p.bit_size);
+      fprintf (stderr, "r     = ");
+      write_mpn (stderr, 16, mpz_limbs_read (signature.r), ecc-&gt;p.size);
+      fprintf (stderr, "\ns     = ");
+      write_mpn (stderr, 16, mpz_limbs_read (signature.s), ecc-&gt;p.size);
+      fprintf (stderr, "\nref.r = ");
+      mpz_out_str (stderr, 16, ref.r);
+      fprintf (stderr, "\nref.s = ");
+      mpz_out_str (stderr, 16, ref.s);
+      fprintf (stderr, "\n");
+      abort();
+    }
+
+  dsa_signature_clear (&amp;ref);
+  dsa_signature_clear (&amp;signature);
+  ecc_scalar_clear (&amp;key);
+  mpz_clear (z);
+}
+
+void
+test_main (void)
+{
+  struct hmac_sha256_ctx hmac_sha256;
+  struct sha256_ctx hash_sha256;
+  uint8_t digest[NETTLE_MAX_HASH_DIGEST_SIZE];
+
+  sha256_init (&amp;hash_sha256);
+  sha256_update (&amp;hash_sha256, 6, (const uint8_t *)"sample");
+  sha256_digest (&amp;hash_sha256, SHA256_DIGEST_SIZE, digest);
+
+  test_ecdsa (&amp;_nettle_secp_192r1,
+	      "6fab034934e4c0fc9ae67f5b5659a9d7"
+	      "d1fefd187ee09fd4", /* z */
+
+	      &amp;hmac_sha256,
+	      (nettle_hash_update_func *)hmac_sha256_set_key,
+	      (nettle_hash_update_func *)hmac_sha256_update,
+	      (nettle_hash_digest_func *)hmac_sha256_digest,
+	      tstring_data (SHA256_DIGEST_SIZE, digest), /* h */
+
+	      "4b0b8ce98a92866a2820e20aa6b75b56"
+	      "382e0f9bfd5ecb55", /* r */
+
+	      "ccdb006926ea9565cbadc840829d8c38"
+	      "4e06de1f1e381b85"); /* s */
+
+  test_ecdsa (&amp;_nettle_secp_224r1,
+	      "f220266e1105bfe3083e03ec7a3a6546"
+	      "51f45e37167e88600bf257c1", /* z */
+
+	      &amp;hmac_sha256,
+	      (nettle_hash_update_func *)hmac_sha256_set_key,
+	      (nettle_hash_update_func *)hmac_sha256_update,
+	      (nettle_hash_digest_func *)hmac_sha256_digest,
+	      tstring_data (SHA256_DIGEST_SIZE, digest), /* h */
+
+	      "61aa3da010e8e8406c656bc477a7a718"
+	      "9895e7e840cdfe8ff42307ba", /* r */
+
+	      "bc814050dab5d23770879494f9e0a680"
+	      "dc1af7161991bde692b10101"); /* s */
+
+  test_ecdsa (&amp;_nettle_secp_256r1,
+	      "c9afa9d845ba75166b5c215767b1d693"
+	      "4e50c3db36e89b127b8a622b120f6721", /* z */
+
+	      &amp;hmac_sha256,
+	      (nettle_hash_update_func *)hmac_sha256_set_key,
+	      (nettle_hash_update_func *)hmac_sha256_update,
+	      (nettle_hash_digest_func *)hmac_sha256_digest,
+	      tstring_data (SHA256_DIGEST_SIZE, digest), /* h */
+
+	      "efd48b2aacb6a8fd1140dd9cd45e81d6"
+	      "9d2c877b56aaf991c34d0ea84eaf3716", /* r */
+
+	      "f7cb1c942d657c41d436c7a1b6e29f65"
+	      "f3e900dbb9aff4064dc4ab2f843acda8"); /* s */
+
+  test_ecdsa (&amp;_nettle_secp_384r1,
+	      "6b9d3dad2e1b8c1c05b19875b6659f4d"
+	      "e23c3b667bf297ba9aa47740787137d8"
+	      "96d5724e4c70a825f872c9ea60d2edf5", /* z */
+
+	      &amp;hmac_sha256,
+	      (nettle_hash_update_func *)hmac_sha256_set_key,
+	      (nettle_hash_update_func *)hmac_sha256_update,
+	      (nettle_hash_digest_func *)hmac_sha256_digest,
+	      tstring_data (SHA256_DIGEST_SIZE, digest), /* h */
+
+	      "21b13d1e013c7fa1392d03c5f99af8b3"
+	      "0c570c6f98d4ea8e354b63a21d3daa33"
+	      "bde1e888e63355d92fa2b3c36d8fb2cd", /* r */
+
+	      "f3aa443fb107745bf4bd77cb38916746"
+	      "32068a10ca67e3d45db2266fa7d1feeb"
+	      "efdc63eccd1ac42ec0cb8668a4fa0ab0"); /* s */
+
+  test_ecdsa (&amp;_nettle_secp_521r1,
+	      "0fad06daa62ba3b25d2fb40133da7572"
+	      "05de67f5bb0018fee8c86e1b68c7e75c"
+	      "aa896eb32f1f47c70855836a6d16fcc1"
+	      "466f6d8fbec67db89ec0c08b0e996b83"
+	      "538", /* z */
+
+	      &amp;hmac_sha256,
+	      (nettle_hash_update_func *)hmac_sha256_set_key,
+	      (nettle_hash_update_func *)hmac_sha256_update,
+	      (nettle_hash_digest_func *)hmac_sha256_digest,
+	      tstring_data (SHA256_DIGEST_SIZE, digest), /* h */
+
+	      "1511bb4d675114fe266fc4372b87682b"
+	      "aecc01d3cc62cf2303c92b3526012659"
+	      "d16876e25c7c1e57648f23b73564d67f"
+	      "61c6f14d527d54972810421e7d87589e"
+	      "1a7", /* r */
+
+	      "04a171143a83163d6df460aaf6152269"
+	      "5f207a58b95c0644d87e52aa1a347916"
+	      "e4f7a72930b1bc06dbe22ce3f58264af"
+	      "d23704cbb63b29b931f7de6c9d949a7e"
+	      "cfc"); /* s */
+
+}
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190613151436</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-06-13 15:14:36-0400</timestampReceived><subject>[PATCH 3/3] dsa: Add support for deterministic signature generation</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

This adds the ecdsa_sign_deterministic function that calculates
signature without requiring entropy source.  Instead, it uses the
deterministic construction described in RFC 6979, through
_dsa_compute_k.

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 Makefile.in              |   3 +-
 dsa-sign-deterministic.c | 107 ++++++++++++++++++++++++++++
 dsa.h                    |  12 ++++
 testsuite/dsa-test.c     | 148 ++++++++++++++++++++++++++++++++++++++-
 4 files changed, 268 insertions(+), 2 deletions(-)
 create mode 100644 dsa-sign-deterministic.c

diff --git a/Makefile.in b/Makefile.in
index 5f77b98d..856f9d9e 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -187,7 +187,8 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  eddsa-hash.c eddsa-pubkey.c eddsa-sign.c eddsa-verify.c \
 		  ed25519-sha512-pubkey.c \
 		  ed25519-sha512-sign.c ed25519-sha512-verify.c \
-		  dsa-compute-k.c ecdsa-sign-deterministic.c
+		  dsa-compute-k.c ecdsa-sign-deterministic.c \
+		  dsa-sign-deterministic.c
 
 OPT_SOURCES = fat-x86_64.c fat-arm.c mini-gmp.c
 
diff --git a/dsa-sign-deterministic.c b/dsa-sign-deterministic.c
new file mode 100644
index 00000000..8c75b80f
--- /dev/null
+++ b/dsa-sign-deterministic.c
@@ -0,0 +1,107 @@
+/* dsa-sign-deterministic.c
+
+   Copyright (C) 2002, 2010 Niels Möller
+   Copyright (C) 2019 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include "dsa.h"
+#include "dsa-internal.h"
+#include "dsa-compute-k.h"
+
+#include "bignum.h"
+
+
+int
+dsa_sign_deterministic (const struct dsa_params *params,
+			const mpz_t x,
+			void *mac_ctx,
+			nettle_hash_update_func *set_key,
+			nettle_hash_update_func *update,
+			nettle_hash_digest_func *digest,
+			size_t digest_length,
+			const uint8_t *digest_message,
+			struct dsa_signature *signature)
+{
+  mpz_t k;
+  mpz_t h;
+  mpz_t tmp;
+  int res;
+
+  /* Check that p is odd, so that invalid keys don't result in a crash
+     inside mpz_powm_sec. */
+  if (mpz_even_p (params-&gt;p))
+    return 0;
+
+  /* Select k, 0&lt;k&lt;q, deterministically */
+  mpz_init(k);
+  _dsa_compute_k (mpz_limbs_write (k, mpz_size (params-&gt;q)),
+		  mpz_size (params-&gt;q),
+		  mpz_limbs_read (params-&gt;q),
+		  mpz_limbs_read (x),
+		  mac_ctx, set_key, update, digest,
+		  digest_length, digest_message);
+  mpz_limbs_finish (k, mpz_size (params-&gt;q));
+
+  /* Compute r = (g^k (mod p)) (mod q) */
+  mpz_init (tmp);
+  mpz_powm_sec(tmp, params-&gt;g, k, params-&gt;p);
+  mpz_fdiv_r(signature-&gt;r, tmp, params-&gt;q);
+
+  /* Compute hash */
+  mpz_init(h);
+  _dsa_hash (h, mpz_sizeinbase(params-&gt;q, 2), digest_length, digest_message);
+
+  /* Compute k^-1 (mod q) */
+  if (mpz_invert(k, k, params-&gt;q))
+    {
+      /* Compute signature s = k^-1 (h + xr) (mod q) */
+      mpz_mul(tmp, signature-&gt;r, x);
+      mpz_fdiv_r(tmp, tmp, params-&gt;q);
+      mpz_add(tmp, tmp, h);
+      mpz_mul(tmp, tmp, k);
+      mpz_fdiv_r(signature-&gt;s, tmp, params-&gt;q);
+      res = 1;
+    }
+  else
+    /* What do we do now? The key is invalid. */
+    res = 0;
+
+  mpz_clear(k);
+  mpz_clear(h);
+  mpz_clear(tmp);
+
+  return res;
+}
diff --git a/dsa.h b/dsa.h
index 553ef327..fddaea9d 100644
--- a/dsa.h
+++ b/dsa.h
@@ -47,6 +47,7 @@ extern "C" {
 #define dsa_signature_init nettle_dsa_signature_init
 #define dsa_signature_clear nettle_dsa_signature_clear
 #define dsa_sign nettle_dsa_sign
+#define dsa_sign_deterministic nettle_dsa_sign_deterministic
 #define dsa_verify nettle_dsa_verify
 #define dsa_generate_params nettle_dsa_generate_params
 #define dsa_generate_keypair nettle_dsa_generate_keypair
@@ -109,6 +110,17 @@ dsa_sign(const struct dsa_params *params,
 	 const uint8_t *digest,
 	 struct dsa_signature *signature);
 
+int
+dsa_sign_deterministic (const struct dsa_params *params,
+			const mpz_t x,
+			void *mac_ctx,
+			nettle_hash_update_func *set_key,
+			nettle_hash_update_func *update,
+			nettle_hash_digest_func *digest,
+			size_t digest_length,
+			const uint8_t *digest_message,
+			struct dsa_signature *signature);
+
 int
 dsa_verify(const struct dsa_params *params,
 	   const mpz_t y,
diff --git a/testsuite/dsa-test.c b/testsuite/dsa-test.c
index 9a80c967..dbc8d063 100644
--- a/testsuite/dsa-test.c
+++ b/testsuite/dsa-test.c
@@ -1,4 +1,57 @@
 #include "testutils.h"
+#include "hmac.h"
+#include "nettle-internal.h"
+
+static void
+test_dsa_sign_deterministic(const struct dsa_params *params,
+			    /* Private key */
+			    const char *sz,
+			    /* HMAC */
+			    void *mac_ctx,
+			    nettle_hash_update_func *set_key,
+			    nettle_hash_update_func *update,
+			    nettle_hash_digest_func *digest,
+			    /* Hash */
+			    const struct tstring *h,
+			    /* Expected signature */
+			    const char *r, const char *s)
+{
+  struct dsa_signature ref;
+  struct dsa_signature signature;
+  mpz_t z;
+
+  dsa_signature_init (&amp;ref);
+  dsa_signature_init(&amp;signature);
+
+  mpz_init_set_str (z, sz, 16);
+
+  ASSERT (dsa_sign_deterministic (params, z,
+				  mac_ctx, set_key, update, digest,
+				  h-&gt;length, h-&gt;data, &amp;signature));
+
+  mpz_set_str (ref.r, r, 16);
+  mpz_set_str (ref.s, s, 16);
+
+  if (mpz_cmp (signature.r, ref.r) != 0
+      || mpz_cmp (signature.s, ref.s) != 0)
+    {
+      fprintf (stderr, "_dsa_sign failed\n");
+      fprintf (stderr, "r     = ");
+      mpz_out_str (stderr, 16, signature.r);
+      fprintf (stderr, "\ns     = ");
+      mpz_out_str (stderr, 16, signature.s);
+      fprintf (stderr, "\nref.r = ");
+      mpz_out_str (stderr, 16, ref.r);
+      fprintf (stderr, "\nref.s = ");
+      mpz_out_str (stderr, 16, ref.s);
+      fprintf (stderr, "\n");
+      abort();
+    }
+
+  dsa_signature_clear (&amp;ref);
+  dsa_signature_clear (&amp;signature);
+  mpz_clear (z);
+}
 
 void
 test_main(void)
@@ -7,6 +60,13 @@ test_main(void)
   struct dsa_private_key key;
   struct dsa_signature signature;
   struct dsa_params *params = (struct dsa_params *) 
+  struct hmac_sha256_ctx hmac_sha256;
+  struct sha256_ctx hash_sha256;
+  uint8_t digest[NETTLE_MAX_HASH_DIGEST_SIZE];
+
+  sha256_init (&amp;hash_sha256);
+  sha256_update (&amp;hash_sha256, 6, (const uint8_t *)"sample");
+  sha256_digest (&amp;hash_sha256, SHA256_DIGEST_SIZE, digest);
 
   dsa_public_key_init(&amp;pub);
   dsa_private_key_init(&amp;key);
@@ -877,7 +937,93 @@ test_main(void)
 		       "bb7441c122f1dc2f9d0b0bc07f26ba29a35cdf0da846a9d8"
 		       "eab405cbf8c8e77f"),
 		  &amp;signature);
-  
+
+  /* Test vectors from RFC 6979 */
+  mpz_set_str(pub.p,
+	      "86f5ca03dcfeb225063ff830a0c769b9dd9d6153ad91d7ce"
+	      "27f787c43278b447e6533b86b18bed6e8a48b784a14c252c"
+	      "5be0dbf60b86d6385bd2f12fb763ed8873abfd3f5ba2e0a8"
+	      "c0a59082eac056935e529daf7c610467899c77adedfc846c"
+	      "881870b7b19b2b58f9be0521a17002e3bdd6b86685ee90b3"
+	      "d9a1b02b782b1779", 16);
+  mpz_set_str(pub.q,
+	      "996f967f6c8e388d9e28d01e205fba957a5698b1", 16);
+  mpz_set_str(pub.g,
+	      "07b0f92546150b62514bb771e2a0c0ce387f03bda6c56b50"
+	      "5209ff25fd3c133d89bbcd97e904e09114d9a7defdeadfc9"
+	      "078ea544d2e401aeecc40bb9fbbf78fd87995a10a1c27cb7"
+	      "789b594ba7efb5c4326a9fe59a070e136db77175464adca4"
+	      "17be5dce2f40d10a46a3a3943f26ab7fd9c0398ff8c76ee0"
+	      "a56826a8a88f1dbd", 16);
+  mpz_set_str(pub.y,
+	      "5df5e01ded31d0297e274e1691c192fe5868fef9e19a8477"
+	      "6454b100cf16f65392195a38b90523e2542ee61871c0440c"
+	      "b87c322fc4b4d2ec5e1e7ec766e1be8d4ce935437dc11c3c"
+	      "8fd426338933ebfe739cb3465f4d3668c5e473508253b1e6"
+	      "82f65cbdc4fae93c2ea212390e54905a86e2223170b44eaa"
+	      "7da5dd9ffcfb7f3b", 16);
+  test_dsa_sign_deterministic (params,
+			       "411602cb19a6ccc34494d79d98ef1e7ed5af25f7",
+			       &amp;hmac_sha256,
+			       (nettle_hash_update_func *)hmac_sha256_set_key,
+			       (nettle_hash_update_func *)hmac_sha256_update,
+			       (nettle_hash_digest_func *)hmac_sha256_digest,
+			       tstring_data (SHA256_DIGEST_SIZE, digest), /* h */
+			       "81f2f5850be5bc123c43f71a3033e9384611c545",
+			       "4cdd914b65eb6c66a8aaad27299bee6b035f5e89");
+
+  mpz_set_str(pub.p,
+	      "9db6fb5951b66bb6fe1e140f1d2ce5502374161fd6538df1"
+	      "648218642f0b5c48c8f7a41aadfa187324b87674fa1822b0"
+	      "0f1ecf8136943d7c55757264e5a1a44ffe012e9936e00c1d"
+	      "3e9310b01c7d179805d3058b2a9f4bb6f9716bfe6117c6b5"
+	      "b3cc4d9be341104ad4a80ad6c94e005f4b993e14f091eb51"
+	      "743bf33050c38de235567e1b34c3d6a5c0ceaa1a0f368213"
+	      "c3d19843d0b4b09dcb9fc72d39c8de41f1bf14d4bb4563ca"
+	      "28371621cad3324b6a2d392145bebfac748805236f5ca2fe"
+	      "92b871cd8f9c36d3292b5509ca8caa77a2adfc7bfd77dda6"
+	      "f71125a7456fea153e433256a2261c6a06ed3693797e7995"
+	      "fad5aabbcfbe3eda2741e375404ae25b", 16);
+  mpz_set_str(pub.q,
+	      "f2c3119374ce76c9356990b465374a17f23f9ed35089bd96"
+	      "9f61c6dde9998c1f", 16);
+  mpz_set_str(pub.g,
+	      "5c7ff6b06f8f143fe8288433493e4769c4d988ace5be25a0"
+	      "e24809670716c613d7b0cee6932f8faa7c44d2cb24523da5"
+	      "3fbe4f6ec3595892d1aa58c4328a06c46a15662e7eaa703a"
+	      "1decf8bbb2d05dbe2eb956c142a338661d10461c0d135472"
+	      "085057f3494309ffa73c611f78b32adbb5740c361c9f35be"
+	      "90997db2014e2ef5aa61782f52abeb8bd6432c4dd097bc54"
+	      "23b285dafb60dc364e8161f4a2a35aca3a10b1c4d203cc76"
+	      "a470a33afdcbdd92959859abd8b56e1725252d78eac66e71"
+	      "ba9ae3f1dd2487199874393cd4d832186800654760e1e34c"
+	      "09e4d155179f9ec0dc4473f996bdce6eed1cabed8b6f116f"
+	      "7ad9cf505df0f998e34ab27514b0ffe7", 16);
+  mpz_set_str(pub.y,
+	      "667098c654426c78d7f8201eac6c203ef030d43605032c2f"
+	      "1fa937e5237dbd949f34a0a2564fe126dc8b715c5141802c"
+	      "e0979c8246463c40e6b6bdaa2513fa611728716c2e4fd53b"
+	      "c95b89e69949d96512e873b9c8f8dfd499cc312882561ade"
+	      "cb31f658e934c0c197f2c4d96b05cbad67381e7b768891e4"
+	      "da3843d24d94cdfb5126e9b8bf21e8358ee0e0a30ef13fd6"
+	      "a664c0dce3731f7fb49a4845a4fd8254687972a2d382599c"
+	      "9bac4e0ed7998193078913032558134976410b89d2c171d1"
+	      "23ac35fd977219597aa7d15c1a9a428e59194f75c721ebcb"
+	      "cfae44696a499afa74e04299f132026601638cb87ab79190"
+	      "d4a0986315da8eec6561c938996beadf", 16);
+  test_dsa_sign_deterministic (params,
+			       "69c7548c21d0dfea6b9a51c9ead4e27c33d3b3f1"
+			       "80316e5bcab92c933f0e4dbc",
+			       &amp;hmac_sha256,
+			       (nettle_hash_update_func *)hmac_sha256_set_key,
+			       (nettle_hash_update_func *)hmac_sha256_update,
+			       (nettle_hash_digest_func *)hmac_sha256_digest,
+			       tstring_data (SHA256_DIGEST_SIZE, digest), /* h */
+			       "eace8bdbbe353c432a795d9ec556c6d021f7a03f"
+			       "42c36e9bc87e4ac7932cc809",
+			       "7081e175455f9247b812b74583e9e94f9ea79bd6"
+			       "40dc962533b0680793a38d53");
+
   dsa_public_key_clear(&amp;pub);
   dsa_private_key_clear(&amp;key);
   dsa_signature_clear(&amp;signature);
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190615083651</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-15 08:36:51-0400</timestampReceived><subject>Re: [PATCH] Fix some typos in the documentation</subject><body>

Wim Lewis &lt;wiml@hhhh.org&gt; writes:

&gt;  nettle.texinfo | 22 +++++++++++-----------
&gt;  1 file changed, 11 insertions(+), 11 deletions(-)

Thanks, applied. 

The patch has some long lines broken, which had to be fixed for it to
apply correctly. For mailers that don't like long lines, sending patches
as text attachments is more robust.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190615160616</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-15 16:06:16-0400</timestampReceived><subject>nettle-3.5rc1</subject><body>

Hi, I've been talking about release for quite some time, without getting
to it. I think the current state is pretty good, and I'd like to get the
release out before summer vacations. I know there are several very
desirable features being worked on, and I'm very happy about that, but
release line has to be drawn somewhere. 

So I've prepared a nettle-3.5rc1 tarball,
https://www.lysator.liu.se/~nisse/archive/nettle-3.5rc1.tar.gz, and
there's a corresponding "nettle_3.5rc1" tag in the repository.

I'll run tests on some of the gmp and gcc test machines. I think I'll
get coverage for x86_64, mips, arm, power, maybe sparc. These machines
mainly free operating systems, gnu/linux or freebsd. Help with testing
on additional systems is highly appreciated, in particular testingon
android and on any proprietary OS:es of interest.

Please also review the NEWS file, if there's anything NEWS-worthy that I
have missed, speak up. Or if there are some additional improvements that
really ought to get into the 3.5 release.

I aim to have the release happen in a week or two. 

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626092658</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2019-06-26 09:26:58-0400</timestampReceived><subject>[PATCH 3/3] build: use libdir substitution in make as make variable</subject><body>

Signed-off-by: Alon Bar-Lev &lt;alon.barlev@gmail.com&gt;
---
 configure.ac | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/configure.ac b/configure.ac
index fb0b3c8c..5f2bf170 100644
--- a/configure.ac
+++ b/configure.ac
@@ -654,13 +654,13 @@ case "$host_os" in
     LIBNETTLE_FORLINK=libnettle.dylib
     LIBNETTLE_SONAME='libnettle.$(LIBNETTLE_MAJOR).dylib'
     LIBNETTLE_FILE='libnettle.$(LIBNETTLE_MAJOR).$(LIBNETTLE_MINOR).dylib'
-    LIBNETTLE_LINK='$(CC) $(CFLAGS) -dynamiclib $(LDFLAGS) -install_name \
${libdir}/$(LIBNETTLE_SONAME) -compatibility_version $(LIBNETTLE_MAJOR) \
-current_version $(LIBNETTLE_MAJOR).$(LIBNETTLE_MINOR)' +    LIBNETTLE_LINK='$(CC) \
$(CFLAGS) -dynamiclib $(LDFLAGS) -install_name $(libdir)/$(LIBNETTLE_SONAME) \
-compatibility_version $(LIBNETTLE_MAJOR) -current_version \
$(LIBNETTLE_MAJOR).$(LIBNETTLE_MINOR)'  LIBNETTLE_LIBS=''
 
     LIBHOGWEED_FORLINK=libhogweed.dylib
     LIBHOGWEED_SONAME='libhogweed.$(LIBHOGWEED_MAJOR).dylib'
     LIBHOGWEED_FILE='libhogweed.$(LIBHOGWEED_MAJOR).$(LIBHOGWEED_MINOR).dylib'
-    LIBHOGWEED_LINK='$(CC) $(CFLAGS) -dynamiclib -L. $(LDFLAGS) -install_name \
${libdir}/$(LIBHOGWEED_SONAME) -compatibility_version $(LIBHOGWEED_MAJOR) \
-current_version $(LIBHOGWEED_MAJOR).$(LIBHOGWEED_MINOR)' +    LIBHOGWEED_LINK='$(CC) \
$(CFLAGS) -dynamiclib -L. $(LDFLAGS) -install_name $(libdir)/$(LIBHOGWEED_SONAME) \
-compatibility_version $(LIBHOGWEED_MAJOR) -current_version \
$(LIBHOGWEED_MAJOR).$(LIBHOGWEED_MINOR)'  LIBHOGWEED_LIBS='-lnettle $(LIBS)'
     ;;
   solaris*)
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190626170010</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2019-06-26 17:00:10-0400</timestampReceived><subject>Re: [PATCH 2/3] build: add --disable-libdir-abi-detection</subject><body>

On Wed, Jun 26, 2019 at 12:43 PM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; Jeffrey Walton &lt;noloader@gmail.com&gt; writes:
&gt;
&gt; &gt;&gt; From which autoconf version? I'd be happy to require a recent autoconf
&gt; &gt;&gt; and drop this code if it's no longer needed. When this hack was added,
&gt; &gt;&gt; it was the case that one or the other of
&gt; &gt;
&gt; &gt; Please NO. Don't require an updated Autotools version.
&gt;
&gt; Huh? The configure script is included in the release tarball. You
&gt; *don't* need to even have autoconf installed to build the library.
&gt; That's half of the point of using autoconf at all.
&gt;
&gt; Requirement on autoconf only matters for those who want to modify
&gt; configure.ac, or build from a git repo.

Yes, we often have to patch and then autoreconf. See, for example,
https://github.com/noloader/Build-Scripts/blob/master/build-nettle.sh
.

Jeff
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626174131</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-26 17:41:31-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.5</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt;
&gt;&gt;  The x86_64/sha_ni directory is not included in the distribution, and
&gt;&gt; thus compilation fails when --enable-fat is provided. I update my
&gt;&gt; previous patch to add `make distcheck` to include enable-fat, so that
&gt;&gt; missing files from distribution are caught earlier.
&gt;
&gt; Ouch. I'll have to make an updated release later today or tomorrow.

Below is the patch I'm considering, as well as the diff to the file list
of the resulting tar file (I've also moved away two unfinished and
uncommitted files from the x86_64 directory, which were unintentionally
picked up by make dist).

I'm not changing the library versions, since any configuration of 3.5
that can be built succesfully will be completely compatible with 3.5.1,
with the only difference being that x86_64 builds with
--enable-x86-sha-ni will be a lot faster with 3.5.1.

Any last minute comments appreciated. I intend to do the updated release
in a few hours, since I'm about to leave for summer vacation.

Regards,
/Niels

diff --git a/ChangeLog b/ChangeLog
index c3d298c7..32a3e3ba 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,5 +1,10 @@
 2019-06-26  Niels Möller  &lt;nisse@lysator.liu.se&gt;
 
+	* configure.ac: Update version number to 3.5.1.
+
+	* Makefile.in (distdir): Add x86_64/sha_ni to list of distributed
+	directories.
+
 	* Released nettle-3.5.
 
 2019-06-25  Niels Möller  &lt;nisse@lysator.liu.se&gt;
diff --git a/Makefile.in b/Makefile.in
index a6b8ffd6..537e97d1 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -586,7 +586,7 @@ distdir: $(DISTFILES)
 	  fi ; \
 	done
 	set -e; for d in sparc32 sparc64 x86 \
-		x86_64 x86_64/aesni x86_64/fat \
+		x86_64 x86_64/aesni x86_64/sha_ni x86_64/fat \
 		arm arm/neon arm/v6 arm/fat ; do \
 	  mkdir "$(distdir)/$$d" ; \
 	  find "$(srcdir)/$$d" -maxdepth 1 '(' -name '*.asm' -o -name '*.m4' ')' \
diff --git a/NEWS b/NEWS
index 622377f3..5e94c893 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,16 @@
+NEWS for the Nettle 3.5.1 release
+
+	The Nettle-3.5.1 corrects a packaging mistake in Nettle-3.5.
+	The new directory x86_64/sha_ni were missing in the tar file,
+	breaking x86_64 builds with --enable-fat, and producing worse
+	performance than promised for builds with --enable-x86-sha-ni.
+	Also a few unused in-progress assembly files were accidentally
+	included in the tar file.
+
+	These problems are corrected in Nettle-3.5.1. There are no
+	other changes, and also the library version numbers are
+	unchanged.
+
 NEWS for the Nettle 3.5 release
 
 	This release adds a couple of new features and optimizations,
diff --git a/configure.ac b/configure.ac
index 00d2bf5d..3547cae4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2,7 +2,7 @@ dnl -*- mode: shell-script; sh-indentation: 2; -*-
 
 dnl Process this file with autoconf to produce a configure script.
 
-AC_INIT([nettle], [3.5], [nettle-bugs@lists.lysator.liu.se])
+AC_INIT([nettle], [3.5.1], [nettle-bugs@lists.lysator.liu.se])
 AC_PREREQ(2.61)
 AC_CONFIG_SRCDIR([arcfour.c])
 # Needed to stop autoconf from looking for files in parent directories.


--- /dev/fd/63	2019-06-26 19:24:14.688527655 +0200
+++ /dev/fd/62	2019-06-26 19:24:14.692527654 +0200
@@ -123,7 +123,6 @@
 x86_64/aes-decrypt-internal.asm
 x86_64/ecc-256-redc.asm
 x86_64/salsa20-crypt.asm
-x86_64/ecc-25519-modp-mul.asm
 x86_64/md5-compress.asm
 x86_64/gcm-hash8.asm
 x86_64/sha256-compress.asm
@@ -157,13 +156,15 @@
 x86_64/sha512-compress.asm
 x86_64/chacha-core-internal.asm
 x86_64/ecc-224-modp.asm
+x86_64/sha_ni/
+x86_64/sha_ni/sha256-compress.asm
+x86_64/sha_ni/sha1-compress.asm
 x86_64/salsa20.m4
 x86_64/poly1305-internal.asm
 x86_64/serpent-decrypt.asm
 x86_64/umac-nh.asm
 x86_64/memxor.asm
 x86_64/ecc-25519-modp.asm
-x86_64/sha1-compress-sse.asm
 x86_64/serpent-encrypt.asm
 x86_64/ecc-521-modp.asm
 camellia-absorb.c


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190601084225</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-01 08:42:25-0400</timestampReceived><subject>siv and cmac</subject><body>

I think the siv code could benefit from a funtion to create a cmac
digest in one step, without the update/digest split and the intermediate
buffer. That would be something like

cmac128_message(const struct cmac128_key *key, const void *cipher,
                nettle_crypt_func *encrypt,
                size_t digest_length, uint8_t *digest,
                size_t message_length, const uint8_t *message);

Then the key need to be taken out from the cmac128_ctx. I'm trying that
out, on the branch cmac-layout. Patch below. What do you think?

Regards,
/Niels

commit 9b41e3b82b567abb68c1b7fc3b1e6b1a4ed87b26
Author: Niels Möller &lt;nisse@lysator.liu.se&gt;
Date:   2019-06-01 10:30:29 +0200

    New struct cmac128_key.

diff --git a/ChangeLog b/ChangeLog
index 53cdc41d..a7a4355f 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,9 @@
+2019-06-01  Niels Möller  &lt;nisse@lysator.liu.se&gt;
+
+	* cmac.h (struct cmac128_key): New struct.
+	* cmac.h (struct cmac128_ctx): Use struct cmac128_key.
+	* cmac.c (cmac128_set_key, cmac128_digest): Update accordingly.
+
 2019-05-12  Niels Möller  &lt;nisse@lysator.liu.se&gt;
 
 	Delete old libdes/openssl compatibility interface.
diff --git a/cmac.c b/cmac.c
index ed3b5eb8..07d805f3 100644
--- a/cmac.c
+++ b/cmac.c
@@ -83,8 +83,8 @@ cmac128_set_key(struct cmac128_ctx *ctx, const void *cipher,
   /* step 1 - generate subkeys k1 and k2 */
   encrypt(cipher, 16, L-&gt;b, const_zero);
 
-  block_mulx(&amp;ctx-&gt;K1, L);
-  block_mulx(&amp;ctx-&gt;K2, &amp;ctx-&gt;K1);
+  block_mulx(&amp;ctx-&gt;key.K1, L);
+  block_mulx(&amp;ctx-&gt;key.K2, &amp;ctx-&gt;key.K1);
 }
 
 #define MIN(x,y) ((x)&lt;(y)?(x):(y))
@@ -148,11 +148,11 @@ cmac128_digest(struct cmac128_ctx *ctx, const void *cipher,
   if (ctx-&gt;index &lt; 16)
     {
       ctx-&gt;block.b[ctx-&gt;index] = 0x80;
-      memxor(ctx-&gt;block.b, ctx-&gt;K2.b, 16);
+      memxor(ctx-&gt;block.b, ctx-&gt;key.K2.b, 16);
     }
   else
     {
-      memxor(ctx-&gt;block.b, ctx-&gt;K1.b, 16);
+      memxor(ctx-&gt;block.b, ctx-&gt;key.K1.b, 16);
     }
 
   memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 16);
diff --git a/cmac.h b/cmac.h
index 6d107982..9d972ea5 100644
--- a/cmac.h
+++ b/cmac.h
@@ -55,18 +55,22 @@ extern "C" {
 #define cmac_aes256_update nettle_cmac_aes256_update
 #define cmac_aes256_digest nettle_cmac_aes256_digest
 
-struct cmac128_ctx
+struct cmac128_key
 {
-  /* Key */
   union nettle_block16 K1;
   union nettle_block16 K2;
+};
+
+struct cmac128_ctx
+{
+  struct cmac128_key key;
 
   /* MAC state */
   union nettle_block16 X;
 
   /* Block buffer */
-  union nettle_block16 block;
   size_t index;
+  union nettle_block16 block;
 };
 
 void


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190613150932</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-06-13 15:09:32-0400</timestampReceived><subject>[PATCH 0/3] Add support for deterministic DSA/ECDSA (RFC 6979)</subject><body>

From: Daiki Ueno &lt;dueno@redhat.com&gt;

This series adds a variant of DSA/ECDSA signing functions that doesn't
require random source to generate signature.  The construction of the
random parameter k is implemented according to RFC 6979, which will be
part of FIPS 186-5:
https://csrc.nist.gov/CSRC/media/Presentations/NIST-Status-Update-on-Elliptic-Curves-and-Post-Qua/images-media/moody-dustin-threshold-crypto-workshop-March-2019.pdf


The motivation behind this is to make it easier to check the DSA/ECDSA
functionality in the circumstances where no proper random sources are
available, e.g., in the libary self-tests at early boot stage.

Daiki Ueno (3):
  dsa: Add a function to find k deterministically
  ecdsa: Add support for deterministic signature generation
  dsa: Add support for deterministic signature generation

 Makefile.in                               |   6 +-
 dsa-compute-k.c                           | 169 ++++++++++++++++++++++
 dsa-compute-k.h                           |  63 ++++++++
 dsa-sign-deterministic.c                  | 107 ++++++++++++++
 dsa.h                                     |  12 ++
 ecdsa-sign-deterministic.c                |  78 ++++++++++
 ecdsa.h                                   |  11 ++
 testsuite/.gitignore                      |   2 +
 testsuite/.test-rules.make                |   6 +
 testsuite/Makefile.in                     |   4 +-
 testsuite/dsa-compute-k-test.c            |  85 +++++++++++
 testsuite/dsa-test.c                      | 148 ++++++++++++++++++-
 testsuite/ecdsa-sign-deterministic-test.c | 164 +++++++++++++++++++++
 13 files changed, 851 insertions(+), 4 deletions(-)
 create mode 100644 dsa-compute-k.c
 create mode 100644 dsa-compute-k.h
 create mode 100644 dsa-sign-deterministic.c
 create mode 100644 ecdsa-sign-deterministic.c
 create mode 100644 testsuite/dsa-compute-k-test.c
 create mode 100644 testsuite/ecdsa-sign-deterministic-test.c

-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190611060323</emailId><senderName>Wim Lewis</senderName><senderEmail>wiml@hhhh.org</senderEmail><timestampReceived>2019-06-11 06:03:23-0400</timestampReceived><subject>[PATCH] Fix some typos in the documentation</subject><body>

---
 nettle.texinfo | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/nettle.texinfo b/nettle.texinfo
index 2a934f6b..52adaa94 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -396,7 +396,7 @@ the later version may define a new library symbol, and let header \
files  redefine an old API name as an alias for the new symbol. If the later
 version ensures that the old symbol is still defined in the library,
 this change is backwards compatible: A program compiled using headers
-from the older version can be successfulyl linked with either version of
+from the older version can be successfully linked with either version of
 the library. But if you compile the same program using headers from the
 later version of the library, and attempt to link with the older
 version, you'll get an undefined reference to the new symbol.
@@ -2320,7 +2320,7 @@ Expands to
 @end example
 @end deffn
 
-@deffn Macro CFB8_SET_IV(@var{ctx}, @var{iv})
+@deffn Macro CFB8_SET_IV (@var{ctx}, @var{iv})
 First argument is a pointer to a context struct as defined by
 @code{CFB8_CTX}, and the second is a pointer to an initialization vector
 that is copied into that context.
@@ -2468,7 +2468,7 @@ Holds state corresponding to the AES-256 block cipher.
 @deftypefunx void xts_aes128_set_decrypt_key (struct xts_aes128_key *@var{ctx}, \
const uint8_t *@var{key})  @deftypefunx void xts_aes256_set_decrypt_key (struct \
xts_aes256_key *@var{ctx}, const uint8_t *@var{key})  Initializes the encryption or \
                decryption key for the AES block cipher. The
-lenght of the key must be double the size of the key for the corresponding
+length of the key must be double the size of the key for the corresponding
 cipher (256 bits for AES-128 and 512 bits for AES-256). One of
 these functions must be called before any of the other functions.
 @end deftypefun
@@ -2572,7 +2572,7 @@ more adventurous alternative, in particular if performance is \
important.  @comment  node-name,  next,  previous,  up
 @subsection EAX
 
-The @acronym{EAX} mode is an @acronym{AEAD} mode whichcombines
+The @acronym{EAX} mode is an @acronym{AEAD} mode which combines
 @acronym{CTR} mode encryption, @xref{CTR}, with a message authentication
 based on @acronym{CBC}, @xref{CBC}. The implementation in Nettle is
 restricted to ciphers with a block size of 128 bits (16 octets).
@@ -2682,7 +2682,7 @@ Process message data for encryption or decryption.
 @end deffn
 
 @deffn Macro EAX_DIGEST (@var{ctx}, @var{encrypt}, @var{length}, @var{digest})
-Extract te authentication tag for the message.
+Extract the authentication tag for the message.
 @end deffn
 
 
@@ -2882,7 +2882,7 @@ Context structs, defined using @code{GCM_CTX}.
 @end deftp
 
 @deftp {Context struct} {struct gcm_aes_ctx}
-Alternative context struct, usign the old @acronym{AES} interface.
+Alternative context struct, using the old @acronym{AES} interface.
 @end deftp
 
 @deftypefun void gcm_aes128_set_key (struct gcm_aes128_ctx *@var{ctx}, const uint8_t \
*@var{key}) @@ -3038,8 +3038,8 @@ initial counter of @code{IC+1}.
 
 @acronym{CCM} mode decryption operates similarly, except that the
 ciphertext and @acronym{MAC} are first decrypted using CTR mode to
-retreive the plaintext and authentication tag. The authentication tag
-can then be recalucated from the authenticated data and plantext, and
+retrieve the plaintext and authentication tag. The authentication tag
+can then be recalculated from the authenticated data and plaintext, and
 compared to the value in the message to check for authenticity.
 
 @subsubsection General @acronym{CCM} interface
@@ -4531,7 +4531,7 @@ Calls @code{mpz_clear} on all numbers in the struct.
 @end deftypefun
 
 @deftypefun int dsa_generate_params (struct dsa_params *@var{params}, void \
*@var{random_ctx}, nettle_random_func *@var{random}, void *@var{progress_ctx}, \
                nettle_progress_func *@var{progress}, unsigned @var{p_bits}, unsigned \
                @var{q_bits})
-Generates paramaters of a new group. The @var{params} struct should be
+Generates parameters of a new group. The @var{params} struct should be
 initialized before you call this function.
 
 @var{random_ctx} and @var{random} is a randomness generator.
@@ -4574,8 +4574,8 @@ signature, and call @code{dsa_signature_clear} when you are \
finished  with it.
 @end deftypefun
 
-Keys are represented as bignums, of type @code{mpz_t}. A public keys
-represent a group element, and is of the same size as @code{p}, while a
+Keys are represented as bignums, of type @code{mpz_t}. A public key
+represents a group element, and is of the same size as @code{p}, while a
 private key is an exponent, of the same size as @code{q}.
 
 @deftypefun int dsa_sign (const struct dsa_params *@var{params}, const mpz_t \
@var{x}, void *@var{random_ctx}, nettle_random_func *@var{random}, size_t \
@var{digest_size}, const uint8_t *@var{digest}, struct dsa_signature \
                *@var{signature})
-- 
2.19.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190626092657</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2019-06-26 09:26:57-0400</timestampReceived><subject>[PATCH 2/3] build: add --disable-libdir-abi-detection</subject><body>

opt out overriding the libdir, in most cases downstream distribution is
providing the correct one

Signed-off-by: Alon Bar-Lev &lt;alon.barlev@gmail.com&gt;
---
 configure.ac | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index 379c021c..fb0b3c8c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -339,7 +339,11 @@ case "$host_cpu" in
     ;;
 esac
 
-if test "x$ABI" != xstandard ; then
+AC_ARG_ENABLE(libdir-abi-detection,
+  AC_HELP_STRING([--disable-libdir-abi-detection], [Disable libdir ABI detection]),,
+  [enable_libdir_abi_detection=yes])
+
+if test "x$ABI" != xstandard -a "x${enable_libdir_abi_detection}" = "yes" ; then
   AC_MSG_NOTICE([Compiler uses $ABI-bit ABI. To change, set CC.])
   if test "$libdir" = '${exec_prefix}/lib' ; then
     # Try setting a better default
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626062151</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-26 06:21:51-0400</timestampReceived><subject>ANNOUNCE: Nettle-3.5</subject><body>

[Attachment #2 (multipart/signed)]


I'm happy to announce a new release of GNU Nettle, a low-level
cryptographics library. This release includes a couple of new features
and improved performance.

The Nettle home page can be found at
https://www.lysator.liu.se/~nisse/nettle/, and the manual at
https://www.lysator.liu.se/~nisse/nettle/nettle.html.

The release can be downloaded from

  https://ftp.gnu.org/gnu/nettle/nettle-3.5.tar.gz
  ftp://ftp.gnu.org/gnu/nettle/nettle-3.5.tar.gz
  https://www.lysator.liu.se/~nisse/archive/nettle-3.5.tar.gz

Regards,
/Niels

NEWS for the Nettle 3.5 release

	This release adds a couple of new features and optimizations,
	and deletes or deprecates a few obsolete features. It is *not*
	binary (ABI) compatible with earlier versions. Except for
	deprecations listed below, it is intended to be fully
	source-level (API) compatible with Nettle-3.4.1.

	The shared library names are libnettle.so.7.0 and
	libhogweed.so.5.0, with sonames libnettle.so.7 and
	libhogweed.so.5.

	Changes in behavior:

	* Nettle's gcm_crypt will now call the underlying block cipher
	  to process more than one block at a time. This is not a
	  change to the documented behavior, but unfortunately breaks
	  assumptions accidentally made in GnuTLS, up to and including
	  version 3.6.1.

	New features:

	* Support for CFB8 (Cipher Feedback Mode, processing a single
	  octet per block cipher operation), contributed by Dmitry
	  Eremin-Solenikov.

	* Support for CMAC (RFC 4493), contributed by Nikos
	  Mavrogiannopoulos.

	* Support for XTS mode, contributed by Simo Sorce.

	Optimizations:

	* Improved performance of the x86_64 AES implementation using
	  the aesni instructions. Gives a large speedup for operations
	  processing multiple blocks at a time (including CTR mode,
	  GCM mode, and CBC decrypt, but *not* CBC encrypt).

	* Improved performance for CTR mode, for the common case of
	  16-byte block size. Pass more data at a time to underlying
	  block cipher, and fill the counter blocks more efficiently.
	  Extension to also handle GCM mode efficiently contributed
	  by Nikos Mavrogiannopoulos.

	* New x86_64 implementation of sha1 and sha256, for processors
	  supporting the sha_ni instructions. Speedup of 3-5 times on
	  affected processors.

	* Improved parameters for the precomputation of tables used
	  for ecc signatures. Roughly 10%-15% speedup of the ecdsa
	  sign operation using the secp_256r1, secp_384r1 and
	  secp_521r1 curves, and 25% speedup of ed25519 sign
	  operation, benchmarked on x86_64. Table sizes unchanged,
	  around 16 KB per curve.

	* In ARM fat builds, automatically select Neon implementation
	  of Chacha, where possible. Contributed by Yuriy M.
	  Kaminskiy.

	Deleted features:

	* The header file des-compat.h and everything declared therein
	  has been deleted, as announced earlier. This file provided a
	  subset of the old libdes/ssleay/openssl interface for DES
	  and triple-DES. DES is still supported, via the functions
	  declared in des.h.

	* Functions using the old struct aes_ctx have been marked as
	  deprecated. Use the fixed key size interface instead, e.g.,
	  struct aes256_ctx, introduced in Nettle-3.0.

	* The header file nettle-stdint.h, and corresponding autoconf
	  tests, have been deleted. Nettle now requires that the
	  compiler/libc provides &lt;stdint.h&gt;.

	Miscellaneous:

	* Support for big-endian ARM systems, contributed by Michael
	  Weiser.

	* The programs aesdata, desdata, twofishdata, shadata and
	  gcmdata are no longer built by default. Makefile
	  improvements contributed by Jay Foad.

	* The "example" program examples/eratosthenes.c has been
	  deleted.

	* The contents of hash context structs, and the deprecated
	  aes_ctx struct, have been reorganized, to enable later
	  optimizations.


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


["signature.asc" (application/pgp-signature)]
[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190626092656</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2019-06-26 09:26:56-0400</timestampReceived><subject>[PATCH 1/3] build: allow overriding the debug flags</subject><body>

In Gentoo and probably other downstream distributions we let package
management to manage the flags

Signed-off-by: Alon Bar-Lev &lt;alon.barlev@gmail.com&gt;
---
 configure.ac | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index 00d2bf5d..379c021c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -949,13 +949,16 @@ LIBS="$old_LIBS"
 
 AC_SUBST(BENCH_LIBS)
 
+AC_ARG_VAR([GCC_DEBUG_FLAGS], [GCC debug flags])
+test -z "${GCC_DEBUG_FLAGS}" &amp;&amp; GCC_DEBUG_FLAGS="-ggdb3"
+
 # Set these flags *last*, or else the test programs won't compile
 if test x$GCC = xyes ; then
   # Using -ggdb3 makes (some versions of) Redhat's gcc-2.96 dump core
   if $CC --version | grep '^2\.96$' 1&gt;/dev/null 2&gt; then
     true
   else
-    CFLAGS="$CFLAGS -ggdb3"
+    CFLAGS="$CFLAGS ${GCC_DEBUG_FLAGS}"
   fi
   # FIXME: It would be better to actually test if this option works and/or is needed.
   # Or perhaps use -funsigned-char.
-- 
2.21.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626113015</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-26 11:30:15-0400</timestampReceived><subject>Re: [PATCH 1/3] build: allow overriding the debug flags</subject><body>

Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:

&gt; In Gentoo and probably other downstream distributions we let package
&gt; management to manage the flags

This is a bit tricky. One can already pass CFLAGS= to configure. But I
think the intention is that should override configure's automatic
selection of flags (I haven't tested that though). But usually, one
wants the package's configure have some say, and e.g., enable warnings
that are expected to be silent.

So I'd rather have something more general like APPEND_CFLAGS added after
CFLAGS to make it possible to override selected flags, and with some
consistency with other packages using autoconf.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626121454</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2019-06-26 12:14:54-0400</timestampReceived><subject>Re: [PATCH 1/3] build: allow overriding the debug flags</subject><body>

On Wed, Jun 26, 2019 at 2:30 PM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:
&gt;
&gt; &gt; In Gentoo and probably other downstream distributions we let package
&gt; &gt; management to manage the flags
&gt;
&gt; This is a bit tricky. One can already pass CFLAGS= to configure. But I
&gt; think the intention is that should override configure's automatic
&gt; selection of flags (I haven't tested that though). But usually, one
&gt; wants the package's configure have some say, and e.g., enable warnings
&gt; that are expected to be silent.
&gt;
&gt; So I'd rather have something more general like APPEND_CFLAGS added after
&gt; CFLAGS to make it possible to override selected flags, and with some
&gt; consistency with other packages using autoconf.

I do not understand... In practice a package should not add by itself
optimization or debug flags without consent (some --enable- argument),
the fact that nettle is doing that is unexpected... the problem is how
to tell build system to avoid adding these flags, not adding
additional or keeping tack of what is added and try to suppress... up
until now we patched the package to meet guidelines, can you please
tell me what solution would you accept? Maybe --disable-custom-flags
argument?

Thanks!
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626132218</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-26 13:22:18-0400</timestampReceived><subject>Re: [PATCH 1/3] build: allow overriding the debug flags</subject><body>

Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:

&gt; I do not understand... In practice a package should not add by itself
&gt; optimization or debug flags without consent (some --enable- argument),
&gt; the fact that nettle is doing that is unexpected...

I'm open to discuss how to deal with CFLAGS. Currently, Nettle sets
-ggdb3, various warning flags (if compiling with gcc), and it kind-of
adds -fPIC, but via different autoconf and make variables.

I think GNU standard is to use something like -g -O by default.

As a developer, I find it convenient to have stricter warning flags and
more debug info by default, but that could be tied to an explicit
configure argument and disabled by default. When suggesting
improvements, please consider recommendations in the GNU coding
standards.

Also keep in mind that ./configure defaults are intended primarily to
make life easy for the user that runs ./configure manually, perhaps to
try out a modification of her own. If you have a packaging framework
that runs configure for you, it's expected that package configuration
needs to add a couple of explicit arguments to override the defaults.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626132957</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2019-06-26 13:29:57-0400</timestampReceived><subject>Re: [PATCH 1/3] build: allow overriding the debug flags</subject><body>

On Wed, Jun 26, 2019 at 4:22 PM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:
&gt;
&gt; &gt; I do not understand... In practice a package should not add by itself
&gt; &gt; optimization or debug flags without consent (some --enable- argument),
&gt; &gt; the fact that nettle is doing that is unexpected...
&gt;
&gt; I'm open to discuss how to deal with CFLAGS. Currently, Nettle sets
&gt; -ggdb3, various warning flags (if compiling with gcc), and it kind-of
&gt; adds -fPIC, but via different autoconf and make variables.
&gt;
&gt; I think GNU standard is to use something like -g -O by default.
&gt;
&gt; As a developer, I find it convenient to have stricter warning flags and
&gt; more debug info by default, but that could be tied to an explicit
&gt; configure argument and disabled by default. When suggesting
&gt; improvements, please consider recommendations in the GNU coding
&gt; standards.
&gt;
&gt; Also keep in mind that ./configure defaults are intended primarily to
&gt; make life easy for the user that runs ./configure manually, perhaps to
&gt; try out a modification of her own. If you have a packaging framework
&gt; that runs configure for you, it's expected that package configuration
&gt; needs to add a couple of explicit arguments to override the defaults.

Hi,
I do not want to take anything from you, just for you to support
disabling this behavior.
I manage vast number of packages, and the well behaved ones are not
manipulate flags.
However, as I wrote, I do not want to take anything from your
environment or default behavior, just to allow formal method (vs
patching) to make this package live correctly within downstream by
disabling these behaviors.
Thanks!
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626133315</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2019-06-26 13:33:15-0400</timestampReceived><subject>Re: [PATCH 1/3] build: allow overriding the debug flags</subject><body>

On Wed, Jun 26, 2019 at 9:22 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:
&gt;
&gt; &gt; I do not understand... In practice a package should not add by itself
&gt; &gt; optimization or debug flags without consent (some --enable- argument),
&gt; &gt; the fact that nettle is doing that is unexpected...
&gt;
&gt; I'm open to discuss how to deal with CFLAGS. Currently, Nettle sets
&gt; -ggdb3, various warning flags (if compiling with gcc), and it kind-of
&gt; adds -fPIC, but via different autoconf and make variables.
&gt;
&gt; I think GNU standard is to use something like -g -O by default.
&gt;
&gt; As a developer, I find it convenient to have stricter warning flags and
&gt; more debug info by default, but that could be tied to an explicit
&gt; configure argument and disabled by default. When suggesting
&gt; improvements, please consider recommendations in the GNU coding
&gt; standards.
&gt;
&gt; Also keep in mind that ./configure defaults are intended primarily to
&gt; make life easy for the user that runs ./configure manually, perhaps to
&gt; try out a modification of her own. If you have a packaging framework
&gt; that runs configure for you, it's expected that package configuration
&gt; needs to add a couple of explicit arguments to override the defaults.

One small nit... The user owns CFLAGS, and they should not be touched.
The place to add library flags is AM_CLFAGS. Later, the Automake
machinery will build a recipe like:

    some_obj.o : ...
        $(CC) $(CPPFLAGS) $(AM_CLFAGS) $(CFLAGS) -c $&lt;

The user's CFLAGS always overrides the library AM_CFLAGS to honor the
user's freedom.

IF you have a flag that must be present to build an object, then it
always gets added to the object. This would show up when building,
say, x86 AES source file because the source file must have flags like
"-msse4.1 -maes".

    AES_FLAGS = -msse4.1 -maes
    aes.o : aes.c
        $(CC) $(CPPFLAGS) $(AM_CLFAGS) $(CFLAGS) $(AES_CFLAGS) -c $&lt;

Some folks get quite upset when the freedom is not respected.

Also see https://www.gnu.org/prep/standards/html_node/Command-Variables.html .

Jeff
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626195036</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2019-06-26 19:50:36-0400</timestampReceived><subject>Re: [PATCH 1/3] build: allow overriding the debug flags</subject><body>

Hi Niels:
Which way do you prefer to avoid adding this flag? having environment
variable or --disable-xxx?
Thanks!

On Wed, Jun 26, 2019 at 4:33 PM Jeffrey Walton &lt;noloader@gmail.com&gt; wrote:
&gt;
&gt; On Wed, Jun 26, 2019 at 9:22 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; &gt;
&gt; &gt; Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:
&gt; &gt;
&gt; &gt; &gt; I do not understand... In practice a package should not add by itself
&gt; &gt; &gt; optimization or debug flags without consent (some --enable- argument),
&gt; &gt; &gt; the fact that nettle is doing that is unexpected...
&gt; &gt;
&gt; &gt; I'm open to discuss how to deal with CFLAGS. Currently, Nettle sets
&gt; &gt; -ggdb3, various warning flags (if compiling with gcc), and it kind-of
&gt; &gt; adds -fPIC, but via different autoconf and make variables.
&gt; &gt;
&gt; &gt; I think GNU standard is to use something like -g -O by default.
&gt; &gt;
&gt; &gt; As a developer, I find it convenient to have stricter warning flags and
&gt; &gt; more debug info by default, but that could be tied to an explicit
&gt; &gt; configure argument and disabled by default. When suggesting
&gt; &gt; improvements, please consider recommendations in the GNU coding
&gt; &gt; standards.
&gt; &gt;
&gt; &gt; Also keep in mind that ./configure defaults are intended primarily to
&gt; &gt; make life easy for the user that runs ./configure manually, perhaps to
&gt; &gt; try out a modification of her own. If you have a packaging framework
&gt; &gt; that runs configure for you, it's expected that package configuration
&gt; &gt; needs to add a couple of explicit arguments to override the defaults.
&gt;
&gt; One small nit... The user owns CFLAGS, and they should not be touched.
&gt; The place to add library flags is AM_CLFAGS. Later, the Automake
&gt; machinery will build a recipe like:
&gt;
&gt;     some_obj.o : ...
&gt;         $(CC) $(CPPFLAGS) $(AM_CLFAGS) $(CFLAGS) -c $&lt;
&gt;
&gt; The user's CFLAGS always overrides the library AM_CFLAGS to honor the
&gt; user's freedom.
&gt;
&gt; IF you have a flag that must be present to build an object, then it
&gt; always gets added to the object. This would show up when building,
&gt; say, x86 AES source file because the source file must have flags like
&gt; "-msse4.1 -maes".
&gt;
&gt;     AES_FLAGS = -msse4.1 -maes
&gt;     aes.o : aes.c
&gt;         $(CC) $(CPPFLAGS) $(AM_CLFAGS) $(CFLAGS) $(AES_CFLAGS) -c $&lt;
&gt;
&gt; Some folks get quite upset when the freedom is not respected.
&gt;
&gt; Also see https://www.gnu.org/prep/standards/html_node/Command-Variables.html .
&gt;
&gt; Jeff
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626204426</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-26 20:44:26-0400</timestampReceived><subject>Re: [PATCH 1/3] build: allow overriding the debug flags</subject><body>

Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:

&gt; Which way do you prefer to avoid adding this flag? having environment
&gt; variable or --disable-xxx?

You've brought up two different issues. For CFLAGS, I agree it could be
improved. Not sure what's the best way is, but the main thing is to let
CFLAGS be a user setting, following the coding standard. There could be
an option to enable or disable the maintainer's (i.e. my) choice of
additional warning flags.

The libdir issue is a different thing. The automatic hack only affects
the *default* libdir, and is already overridable with the standard
option --libdir=... In that case, I see little point in a new special
option to disable the current behavior. What might make sense, if you
convince me that the automatic selection really is an inappropriate
default, is to enable it explicitly by using --libdir=auto.

And I'd still like to know if the there's been any related multiarch
improvements in autoconf's default behavior recently.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626070528</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2019-06-26 07:05:28-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.5</subject><body>

Hi,
 The x86_64/sha_ni directory is not included in the distribution, and
thus compilation fails when --enable-fat is provided. I update my
previous patch to add `make distcheck` to include enable-fat, so that
missing files from distribution are caught earlier.

regards,
Nikos


On Wed, Jun 26, 2019 at 8:22 AM Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; wr=
ote:
&gt;
&gt; I'm happy to announce a new release of GNU Nettle, a low-level
&gt; cryptographics library. This release includes a couple of new features
&gt; and improved performance.
&gt;
&gt; The Nettle home page can be found at
&gt; https://www.lysator.liu.se/~nisse/nettle/, and the manual at
&gt; https://www.lysator.liu.se/~nisse/nettle/nettle.html.
&gt;
&gt; The release can be downloaded from
&gt;
&gt;   https://ftp.gnu.org/gnu/nettle/nettle-3.5.tar.gz
&gt;   ftp://ftp.gnu.org/gnu/nettle/nettle-3.5.tar.gz
&gt;   https://www.lysator.liu.se/~nisse/archive/nettle-3.5.tar.gz
&gt;
&gt; Regards,
&gt; /Niels
&gt;
&gt; NEWS for the Nettle 3.5 release
&gt;
&gt;         This release adds a couple of new features and optimizations,
&gt;         and deletes or deprecates a few obsolete features. It is *not*
&gt;         binary (ABI) compatible with earlier versions. Except for
&gt;         deprecations listed below, it is intended to be fully
&gt;         source-level (API) compatible with Nettle-3.4.1.
&gt;
&gt;         The shared library names are libnettle.so.7.0 and
&gt;         libhogweed.so.5.0, with sonames libnettle.so.7 and
&gt;         libhogweed.so.5.
&gt;
&gt;         Changes in behavior:
&gt;
&gt;         * Nettle's gcm_crypt will now call the underlying block cipher
&gt;           to process more than one block at a time. This is not a
&gt;           change to the documented behavior, but unfortunately breaks
&gt;           assumptions accidentally made in GnuTLS, up to and including
&gt;           version 3.6.1.
&gt;
&gt;         New features:
&gt;
&gt;         * Support for CFB8 (Cipher Feedback Mode, processing a single
&gt;           octet per block cipher operation), contributed by Dmitry
&gt;           Eremin-Solenikov.
&gt;
&gt;         * Support for CMAC (RFC 4493), contributed by Nikos
&gt;           Mavrogiannopoulos.
&gt;
&gt;         * Support for XTS mode, contributed by Simo Sorce.
&gt;
&gt;         Optimizations:
&gt;
&gt;         * Improved performance of the x86_64 AES implementation using
&gt;           the aesni instructions. Gives a large speedup for operations
&gt;           processing multiple blocks at a time (including CTR mode,
&gt;           GCM mode, and CBC decrypt, but *not* CBC encrypt).
&gt;
&gt;         * Improved performance for CTR mode, for the common case of
&gt;           16-byte block size. Pass more data at a time to underlying
&gt;           block cipher, and fill the counter blocks more efficiently.
&gt;           Extension to also handle GCM mode efficiently contributed
&gt;           by Nikos Mavrogiannopoulos.
&gt;
&gt;         * New x86_64 implementation of sha1 and sha256, for processors
&gt;           supporting the sha_ni instructions. Speedup of 3-5 times on
&gt;           affected processors.
&gt;
&gt;         * Improved parameters for the precomputation of tables used
&gt;           for ecc signatures. Roughly 10%-15% speedup of the ecdsa
&gt;           sign operation using the secp_256r1, secp_384r1 and
&gt;           secp_521r1 curves, and 25% speedup of ed25519 sign
&gt;           operation, benchmarked on x86_64. Table sizes unchanged,
&gt;           around 16 KB per curve.
&gt;
&gt;         * In ARM fat builds, automatically select Neon implementation
&gt;           of Chacha, where possible. Contributed by Yuriy M.
&gt;           Kaminskiy.
&gt;
&gt;         Deleted features:
&gt;
&gt;         * The header file des-compat.h and everything declared therein
&gt;           has been deleted, as announced earlier. This file provided a
&gt;           subset of the old libdes/ssleay/openssl interface for DES
&gt;           and triple-DES. DES is still supported, via the functions
&gt;           declared in des.h.
&gt;
&gt;         * Functions using the old struct aes_ctx have been marked as
&gt;           deprecated. Use the fixed key size interface instead, e.g.,
&gt;           struct aes256_ctx, introduced in Nettle-3.0.
&gt;
&gt;         * The header file nettle-stdint.h, and corresponding autoconf
&gt;           tests, have been deleted. Nettle now requires that the
&gt;           compiler/libc provides &lt;stdint.h&gt;.
&gt;
&gt;         Miscellaneous:
&gt;
&gt;         * Support for big-endian ARM systems, contributed by Michael
&gt;           Weiser.
&gt;
&gt;         * The programs aesdata, desdata, twofishdata, shadata and
&gt;           gcmdata are no longer built by default. Makefile
&gt;           improvements contributed by Jay Foad.
&gt;
&gt;         * The "example" program examples/eratosthenes.c has been
&gt;           deleted.
&gt;
&gt;         * The contents of hash context structs, and the deprecated
&gt;           aes_ctx struct, have been reorganized, to enable later
&gt;           optimizations.
&gt;
&gt;
&gt; --
&gt; Niels M=C3=B6ller. PGP-encrypted email is preferred. Keyid 368C6677.
&gt; Internet email is subject to wholesale government surveillance.
&gt;
&gt; _______________________________________________
&gt; nettle-bugs mailing list
&gt; nettle-bugs@lists.lysator.liu.se
&gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

["0001-.gitlab-ci.yml-added-make-distcheck-target.patch" (text/x-patch)]

From 7a138cca23a00c4645937ad2327e1659a57c7c2b Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Wed, 17 Apr 2019 15:17:47 +0200
Subject: [PATCH] .gitlab-ci.yml: added make distcheck target

This checks whether the distributed tarball misses files
and result to a functioning library.

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 .gitlab-ci.yml | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index ecd95ad3..d66ef516 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -50,6 +50,15 @@ build/ndebug:
   - shared
   except:
   - tags
+distcheck:
+  image: $CI_REGISTRY/$BUILD_IMAGES_PROJECT:$FEDORA_BUILD
+  script:
+  - ./.bootstrap &amp;&amp;
+    ./configure --disable-static --enable-fat &amp;&amp; make distcheck
+  tags:
+  - shared
+  except:
+  - tags
 build/ubsan:
   image: $CI_REGISTRY/$BUILD_IMAGES_PROJECT:$FEDORA_BUILD
   script:
-- 
2.21.0


[Attachment #4 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190626071059</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2019-06-26 07:10:59-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.5</subject><body>

I was going to note the same :)
So we delay this feature?

On Wed, Jun 26, 2019 at 10:05 AM Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
wrote:

&gt; Hi,
&gt;  The x86_64/sha_ni directory is not included in the distribution, and
&gt; thus compilation fails when --enable-fat is provided. I update my
&gt; previous patch to add `make distcheck` to include enable-fat, so that
&gt; missing files from distribution are caught earlier.
&gt;
&gt; regards,
&gt; Nikos
&gt;
&gt;
&gt; On Wed, Jun 26, 2019 at 8:22 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; &gt;
&gt; &gt; I'm happy to announce a new release of GNU Nettle, a low-level
&gt; &gt; cryptographics library. This release includes a couple of new features
&gt; &gt; and improved performance.
&gt; &gt;
&gt; &gt; The Nettle home page can be found at
&gt; &gt; https://www.lysator.liu.se/~nisse/nettle/, and the manual at
&gt; &gt; https://www.lysator.liu.se/~nisse/nettle/nettle.html.
&gt; &gt;
&gt; &gt; The release can be downloaded from
&gt; &gt;
&gt; &gt;   https://ftp.gnu.org/gnu/nettle/nettle-3.5.tar.gz
&gt; &gt;   ftp://ftp.gnu.org/gnu/nettle/nettle-3.5.tar.gz
&gt; &gt;   https://www.lysator.liu.se/~nisse/archive/nettle-3.5.tar.gz
&gt; &gt;
&gt; &gt; Regards,
&gt; &gt; /Niels
&gt; &gt;
&gt; &gt; NEWS for the Nettle 3.5 release
&gt; &gt;
&gt; &gt;         This release adds a couple of new features and optimizations,
&gt; &gt;         and deletes or deprecates a few obsolete features. It is *not*
&gt; &gt;         binary (ABI) compatible with earlier versions. Except for
&gt; &gt;         deprecations listed below, it is intended to be fully
&gt; &gt;         source-level (API) compatible with Nettle-3.4.1.
&gt; &gt;
&gt; &gt;         The shared library names are libnettle.so.7.0 and
&gt; &gt;         libhogweed.so.5.0, with sonames libnettle.so.7 and
&gt; &gt;         libhogweed.so.5.
&gt; &gt;
&gt; &gt;         Changes in behavior:
&gt; &gt;
&gt; &gt;         * Nettle's gcm_crypt will now call the underlying block cipher
&gt; &gt;           to process more than one block at a time. This is not a
&gt; &gt;           change to the documented behavior, but unfortunately breaks
&gt; &gt;           assumptions accidentally made in GnuTLS, up to and including
&gt; &gt;           version 3.6.1.
&gt; &gt;
&gt; &gt;         New features:
&gt; &gt;
&gt; &gt;         * Support for CFB8 (Cipher Feedback Mode, processing a single
&gt; &gt;           octet per block cipher operation), contributed by Dmitry
&gt; &gt;           Eremin-Solenikov.
&gt; &gt;
&gt; &gt;         * Support for CMAC (RFC 4493), contributed by Nikos
&gt; &gt;           Mavrogiannopoulos.
&gt; &gt;
&gt; &gt;         * Support for XTS mode, contributed by Simo Sorce.
&gt; &gt;
&gt; &gt;         Optimizations:
&gt; &gt;
&gt; &gt;         * Improved performance of the x86_64 AES implementation using
&gt; &gt;           the aesni instructions. Gives a large speedup for operations
&gt; &gt;           processing multiple blocks at a time (including CTR mode,
&gt; &gt;           GCM mode, and CBC decrypt, but *not* CBC encrypt).
&gt; &gt;
&gt; &gt;         * Improved performance for CTR mode, for the common case of
&gt; &gt;           16-byte block size. Pass more data at a time to underlying
&gt; &gt;           block cipher, and fill the counter blocks more efficiently.
&gt; &gt;           Extension to also handle GCM mode efficiently contributed
&gt; &gt;           by Nikos Mavrogiannopoulos.
&gt; &gt;
&gt; &gt;         * New x86_64 implementation of sha1 and sha256, for processors
&gt; &gt;           supporting the sha_ni instructions. Speedup of 3-5 times on
&gt; &gt;           affected processors.
&gt; &gt;
&gt; &gt;         * Improved parameters for the precomputation of tables used
&gt; &gt;           for ecc signatures. Roughly 10%-15% speedup of the ecdsa
&gt; &gt;           sign operation using the secp_256r1, secp_384r1 and
&gt; &gt;           secp_521r1 curves, and 25% speedup of ed25519 sign
&gt; &gt;           operation, benchmarked on x86_64. Table sizes unchanged,
&gt; &gt;           around 16 KB per curve.
&gt; &gt;
&gt; &gt;         * In ARM fat builds, automatically select Neon implementation
&gt; &gt;           of Chacha, where possible. Contributed by Yuriy M.
&gt; &gt;           Kaminskiy.
&gt; &gt;
&gt; &gt;         Deleted features:
&gt; &gt;
&gt; &gt;         * The header file des-compat.h and everything declared therein
&gt; &gt;           has been deleted, as announced earlier. This file provided a
&gt; &gt;           subset of the old libdes/ssleay/openssl interface for DES
&gt; &gt;           and triple-DES. DES is still supported, via the functions
&gt; &gt;           declared in des.h.
&gt; &gt;
&gt; &gt;         * Functions using the old struct aes_ctx have been marked as
&gt; &gt;           deprecated. Use the fixed key size interface instead, e.g.,
&gt; &gt;           struct aes256_ctx, introduced in Nettle-3.0.
&gt; &gt;
&gt; &gt;         * The header file nettle-stdint.h, and corresponding autoconf
&gt; &gt;           tests, have been deleted. Nettle now requires that the
&gt; &gt;           compiler/libc provides &lt;stdint.h&gt;.
&gt; &gt;
&gt; &gt;         Miscellaneous:
&gt; &gt;
&gt; &gt;         * Support for big-endian ARM systems, contributed by Michael
&gt; &gt;           Weiser.
&gt; &gt;
&gt; &gt;         * The programs aesdata, desdata, twofishdata, shadata and
&gt; &gt;           gcmdata are no longer built by default. Makefile
&gt; &gt;           improvements contributed by Jay Foad.
&gt; &gt;
&gt; &gt;         * The "example" program examples/eratosthenes.c has been
&gt; &gt;           deleted.
&gt; &gt;
&gt; &gt;         * The contents of hash context structs, and the deprecated
&gt; &gt;           aes_ctx struct, have been reorganized, to enable later
&gt; &gt;           optimizations.
&gt; &gt;
&gt; &gt;
&gt; &gt; --
&gt; &gt; Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
&gt; &gt; Internet email is subject to wholesale government surveillance.
&gt; &gt;
&gt; &gt; _______________________________________________
&gt; &gt; nettle-bugs mailing list
&gt; &gt; nettle-bugs@lists.lysator.liu.se
&gt; &gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs
&gt; _______________________________________________
&gt; nettle-bugs mailing list
&gt; nettle-bugs@lists.lysator.liu.se
&gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs
&gt;
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626092348</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-26 09:23:48-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.5</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt;  The x86_64/sha_ni directory is not included in the distribution, and
&gt; thus compilation fails when --enable-fat is provided. I update my
&gt; previous patch to add `make distcheck` to include enable-fat, so that
&gt; missing files from distribution are caught earlier.

Ouch. I'll have to make an updated release later today or tomorrow.

Thanks for finding it quickly. I've run at least a dozen of different
tests on the rc1 tarball, but apparently none with x86_64 --enable-fat
:-(

And problem is of course not limited to fat builds, it's just that
--enable-fat happens to make it visible at compile time.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626093056</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2019-06-26 09:30:56-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.5</subject><body>

On Wed, Jun 26, 2019 at 12:23 PM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; Ouch. I'll have to make an updated release later today or tomorrow.

I sent three patches to cleanup our gentoo downstream patches, can you
please consider them for the release so we have zero patching?

Thanks!
Alon
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626112203</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-26 11:22:03-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.5</subject><body>

Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:

&gt; I sent three patches to cleanup our gentoo downstream patches, can you
&gt; please consider them for the release so we have zero patching?

Not for this release, sorry. I'll send comments on the patches
separately.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626120610</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-06-26 12:06:10-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.5</subject><body>

On Wed, 2019-06-26 at 11:23 +0200, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt; 
&gt; &gt;  The x86_64/sha_ni directory is not included in the distribution, and
&gt; &gt; thus compilation fails when --enable-fat is provided. I update my
&gt; &gt; previous patch to add `make distcheck` to include enable-fat, so that
&gt; &gt; missing files from distribution are caught earlier.
&gt; 
&gt; Ouch. I'll have to make an updated release later today or tomorrow.
&gt; 
&gt; Thanks for finding it quickly. I've run at least a dozen of different
&gt; tests on the rc1 tarball, but apparently none with x86_64 --enable-fat
&gt; :-(
&gt; 
&gt; And problem is of course not limited to fat builds, it's just that
&gt; --enable-fat happens to make it visible at compile time.

Niels, it may be nice to use gitlab and it's CI features to have tests
with all configurations to catch these things.

Simo.

-- 
Simo Sorce
RHEL Crypto Team
Red Hat, Inc




_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190924192227</emailId><senderName>Magnus Holmgren</senderName><senderEmail>holmgren@debian.org</senderEmail><timestampReceived>2019-09-24 19:22:27-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.5</subject><body>

[Attachment #2 (multipart/signed)]


onsdag 26 juni 2019 kl. 08:21:51 CEST skrev  Niels Möller:
&gt; 	* Functions using the old struct aes_ctx have been marked as
&gt; 	  deprecated. Use the fixed key size interface instead, e.g.,
&gt; 	  struct aes256_ctx, introduced in Nettle-3.0.

But surely common structs and functions are more convenient for library users, 
and the different fixed key size functions all call the same functions 
internally, so isn't there a value in keeping the old interface around?

-- 
Magnus Holmgren        holmgren@debian.org
Debian Developer 
["signature.asc" (application/pgp-signature)]
[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190924211944</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-24 21:19:44-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.5</subject><body>

Magnus Holmgren &lt;holmgren@debian.org&gt; writes:

&gt; But surely common structs and functions are more convenient for
&gt; library users, 

Maybe. Incompatible changes are surely highly inconvenient, but I'd
expect separate functions to fit well in most applications. 

There's no urgency in deleting the old functions, but I'd like to
encourage library users to switch.

&gt; and the different fixed key size functions all call the same functions 
&gt; internally, so isn't there a value in keeping the old interface around?

Currently, yes, but I think the implementation in x86_64/aesni could be
sped up by using separate functions for aes128, aes192 and aes256. To
enable that, it's best to have separate functions all the way.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626114046</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-26 11:40:46-0400</timestampReceived><subject>Re: [PATCH 2/3] build: add --disable-libdir-abi-detection</subject><body>

Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:

&gt; opt out overriding the libdir, in most cases downstream distribution is
&gt; providing the correct one
&gt; 
&gt; Signed-off-by: Alon Bar-Lev &lt;alon.barlev@gmail.com&gt;
&gt; ---
&gt; configure.ac | 6 +++++-
&gt; 1 file changed, 5 insertions(+), 1 deletion(-)
&gt; 
&gt; diff --git a/configure.ac b/configure.ac
&gt; index 379c021c..fb0b3c8c 100644
&gt; --- a/configure.ac
&gt; +++ b/configure.ac
&gt; @@ -339,7 +339,11 @@ case "$host_cpu" in
&gt; ;;
&gt; esac
&gt; 
&gt; -if test "x$ABI" != xstandard ; then
&gt; +AC_ARG_ENABLE(libdir-abi-detection,
&gt; +  AC_HELP_STRING([--disable-libdir-abi-detection], [Disable libdir ABI \
&gt; detection]),, +  [enable_libdir_abi_detection=yes])
&gt; +
&gt; +if test "x$ABI" != xstandard -a "x${enable_libdir_abi_detection}" = "yes" ; then
&gt; AC_MSG_NOTICE([Compiler uses $ABI-bit ABI. To change, set CC.])
&gt; if test "$libdir" = '${exec_prefix}/lib' ; then
&gt; # Try setting a better default

Isn't it clearer to use

 ./configure --prefix=/usr --libdir=/usr/lib

rather than

 ./configure --prefix=/usr --disable-libdir-abi-detection

The above if test "$libdir" = '${exec_prefix}/lib' disables the
automatic choice if you use --libdir=foo, with foo different from the
magic string '${exec_prefix}/lib'.
  
Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:

&gt; Signed-off-by: Alon Bar-Lev &lt;alon.barlev@gmail.com&gt;
&gt; ---
&gt; configure.ac | 4 ++--
&gt; 1 file changed, 2 insertions(+), 2 deletions(-)
&gt; 
&gt; diff --git a/configure.ac b/configure.ac
&gt; index fb0b3c8c..5f2bf170 100644
&gt; --- a/configure.ac
&gt; +++ b/configure.ac
&gt; @@ -654,13 +654,13 @@ case "$host_os" in
&gt; LIBNETTLE_FORLINK=libnettle.dylib
&gt; LIBNETTLE_SONAME='libnettle.$(LIBNETTLE_MAJOR).dylib'
&gt; LIBNETTLE_FILE='libnettle.$(LIBNETTLE_MAJOR).$(LIBNETTLE_MINOR).dylib'
&gt; -    LIBNETTLE_LINK='$(CC) $(CFLAGS) -dynamiclib $(LDFLAGS) -install_name \
&gt; ${libdir}/$(LIBNETTLE_SONAME) -compatibility_version $(LIBNETTLE_MAJOR) \
&gt; -current_version $(LIBNETTLE_MAJOR).$(LIBNETTLE_MINOR)' +    LIBNETTLE_LINK='$(CC) \
&gt; $(CFLAGS) -dynamiclib $(LDFLAGS) -install_name $(libdir)/$(LIBNETTLE_SONAME) \
&gt; -compatibility_version $(LIBNETTLE_MAJOR) -current_version \
&gt; $(LIBNETTLE_MAJOR).$(LIBNETTLE_MINOR)' LIBNETTLE_LIBS=''

I don't understand this change. $(foo) and ${foo} have the same meaning
in make (and this is quoted from the shell). A think it's an improvement
to change ${} to $() here, for consistency with other nerby make
references, but I take it you intend to do something more than an
aesthetic change? Am I missing something?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190626121719</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2019-06-26 12:17:19-0400</timestampReceived><subject>Re: [PATCH 2/3] build: add --disable-libdir-abi-detection</subject><body>

On Wed, Jun 26, 2019 at 2:40 PM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:
&gt;
&gt; &gt; opt out overriding the libdir, in most cases downstream distribution is
&gt; &gt; providing the correct one
&gt; &gt;
&gt; &gt; Signed-off-by: Alon Bar-Lev &lt;alon.barlev@gmail.com&gt;
&gt; &gt; ---
&gt; &gt;  configure.ac | 6 +++++-
&gt; &gt;  1 file changed, 5 insertions(+), 1 deletion(-)
&gt; &gt;
&gt; &gt; diff --git a/configure.ac b/configure.ac
&gt; &gt; index 379c021c..fb0b3c8c 100644
&gt; &gt; --- a/configure.ac
&gt; &gt; +++ b/configure.ac
&gt; &gt; @@ -339,7 +339,11 @@ case "$host_cpu" in
&gt; &gt;      ;;
&gt; &gt;  esac
&gt; &gt;
&gt; &gt; -if test "x$ABI" != xstandard ; then
&gt; &gt; +AC_ARG_ENABLE(libdir-abi-detection,
&gt; &gt; +  AC_HELP_STRING([--disable-libdir-abi-detection], [Disable libdir ABI detection]),,
&gt; &gt; +  [enable_libdir_abi_detection=yes])
&gt; &gt; +
&gt; &gt; +if test "x$ABI" != xstandard -a "x${enable_libdir_abi_detection}" = "yes" ; then
&gt; &gt;    AC_MSG_NOTICE([Compiler uses $ABI-bit ABI. To change, set CC.])
&gt; &gt;    if test "$libdir" = '${exec_prefix}/lib' ; then
&gt; &gt;      # Try setting a better default
&gt;
&gt; Isn't it clearer to use
&gt;
&gt;  ./configure --prefix=/usr --libdir=/usr/lib
&gt;
&gt; rather than
&gt;
&gt;  ./configure --prefix=/usr --disable-libdir-abi-detection
&gt;
&gt; The above if test "$libdir" = '${exec_prefix}/lib' disables the
&gt; automatic choice if you use --libdir=foo, with foo different from the
&gt; magic string '${exec_prefix}/lib'.

You should not do this in autoconf, autoconf is already detecting
everything that is required, having this code is highly non-standard
and damage the default detection in many setups. No package should
override any of the default directories.

Having said that, and to avoid backward compatibility, I would like to
add a switch to disable this behavior completely and relay on the
default logic of autoconf as expected.

Thanks!
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626134507</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-26 13:45:07-0400</timestampReceived><subject>Re: [PATCH 2/3] build: add --disable-libdir-abi-detection</subject><body>

Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:

&gt; You should not do this in autoconf, autoconf is already detecting
&gt; everything that is required,

From which autoconf version? I'd be happy to require a recent autoconf
and drop this code if it's no longer needed. When this hack was added,
it was the case that one or the other of

  ./configure CC='gcc -m32' &amp;&amp; make &amp;&amp; make install

or 

  ./configure CC='gcc -m64' &amp;&amp; make &amp;&amp; make install

would install library files in the wrong directory, overwriting and
damaging any correctly installed library previously installed in that
place. On some systems, even

  ./configure &amp;&amp; make &amp;&amp; make install

would cause damage. Systems affected included any x86_64 gnu/linux
system that (i) adhered to the linux hierarchy standard with 32-bit x86
libraries in /usr/local/lib (including gentoo, but not debian), and had
a gcc installation defaulting to generating code for x86_64 (which I'd
guess gentoo did too).

So the libdir detection is intended to help the user to not shot
him/herself in the foot.

I don't know what current gentoo does. Debian's way of doing multiarch
makes a lot of sense to me. You can then configure any autoconfed
library, including nettle, with something like

  --prefix=/usr --libdir='${prefix}/lib/${host}'

and nettle's special libdir default is not used.

Does recent autoconf do anything like that by default?

&gt; Having said that, and to avoid backward compatibility, I would like to
&gt; add a switch to disable this behavior completely and relay on the
&gt; default logic of autoconf as expected.

Would it make sense to have this automatic detection apply only when
also the prefix is the default /usr/local? (Unfortunately, I don't know
how a configure script can find out authoritatively if --prefix or
--libdir were present on the command line, which is why I compare libdir
to the default value instead.

And I really don't understand why you'd prefer a nettle specific
--disable-... argument over the GNU standard --libdir=/usr/lib/whatever.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626135332</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2019-06-26 13:53:32-0400</timestampReceived><subject>Re: [PATCH 2/3] build: add --disable-libdir-abi-detection</subject><body>

On Wed, Jun 26, 2019 at 9:45 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; ...
&gt; From which autoconf version? I'd be happy to require a recent autoconf
&gt; and drop this code if it's no longer needed. When this hack was added,
&gt; it was the case that one or the other of

Please NO. Don't require an updated Autotools version.

It is impossible to update Autotools on existing systems. I've never
been able to do it on Linux, OS X and Solaris. The GCC Compile Farm
maintainers were not able to do it on compile farm machines like AIX.

Stay with the basics. Things already work well. Allow a user to
override libdir using standard options. Don't do fancy things that
break builds.

Also see https://www.gnu.org/prep/standards/html_node/Directory-Variables.html.

Jeff
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626140007</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2019-06-26 14:00:07-0400</timestampReceived><subject>Re: [PATCH 2/3] build: add --disable-libdir-abi-detection</subject><body>

On Wed, Jun 26, 2019 at 4:53 PM Jeffrey Walton &lt;noloader@gmail.com&gt; wrote:
&gt;
&gt; On Wed, Jun 26, 2019 at 9:45 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; &gt;
&gt; &gt; ...
&gt; &gt; From which autoconf version? I'd be happy to require a recent autoconf
&gt; &gt; and drop this code if it's no longer needed. When this hack was added,
&gt; &gt; it was the case that one or the other of
&gt;
&gt; Please NO. Don't require an updated Autotools version.
&gt;
&gt; It is impossible to update Autotools on existing systems. I've never
&gt; been able to do it on Linux, OS X and Solaris. The GCC Compile Farm
&gt; maintainers were not able to do it on compile farm machines like AIX.
&gt;
&gt; Stay with the basics. Things already work well. Allow a user to
&gt; override libdir using standard options. Don't do fancy things that
&gt; break builds.
&gt;
&gt; Also see https://www.gnu.org/prep/standards/html_node/Directory-Variables.html.
&gt;

Since ever, packages should not have modified any of the system
autoconf variables. I believe that nettle is one of the few that
attempt to override the autoconf detection. I do not want to enter
philosophical argument, just to kindly ask to have the option to
disable this proprietary logic.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626150758</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-06-26 15:07:58-0400</timestampReceived><subject>Re: [PATCH 2/3] build: add --disable-libdir-abi-detection</subject><body>

ср, 26 июн. 2019 г. в 17:00, Alon Bar-Lev &lt;alon.barlev@gmail.com&gt;:
&gt;
&gt; On Wed, Jun 26, 2019 at 4:53 PM Jeffrey Walton &lt;noloader@gmail.com&gt; wrote:
&gt; &gt;
&gt; &gt; On Wed, Jun 26, 2019 at 9:45 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; &gt; &gt;
&gt; &gt; &gt; ...
&gt; &gt; &gt; From which autoconf version? I'd be happy to require a recent autoconf
&gt; &gt; &gt; and drop this code if it's no longer needed. When this hack was added,
&gt; &gt; &gt; it was the case that one or the other of
&gt; &gt;
&gt; &gt; Please NO. Don't require an updated Autotools version.
&gt; &gt;
&gt; &gt; It is impossible to update Autotools on existing systems. I've never
&gt; &gt; been able to do it on Linux, OS X and Solaris. The GCC Compile Farm
&gt; &gt; maintainers were not able to do it on compile farm machines like AIX.
&gt; &gt;
&gt; &gt; Stay with the basics. Things already work well. Allow a user to
&gt; &gt; override libdir using standard options. Don't do fancy things that
&gt; &gt; break builds.
&gt; &gt;
&gt; &gt; Also see https://www.gnu.org/prep/standards/html_node/Directory-Variables.html.
&gt; &gt;
&gt;
&gt; Since ever, packages should not have modified any of the system
&gt; autoconf variables. I believe that nettle is one of the few that
&gt; attempt to override the autoconf detection. I do not want to enter
&gt; philosophical argument, just to kindly ask to have the option to
&gt; disable this proprietary logic.

What about just checking if libdir was overwritten via argument and not
touching it if it was the case? Will that work for you?


-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626151327</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2019-06-26 15:13:27-0400</timestampReceived><subject>Re: [PATCH 2/3] build: add --disable-libdir-abi-detection</subject><body>

On Wed, Jun 26, 2019 at 6:08 PM Dmitry Eremin-Solenikov
&lt;dbaryshkov@gmail.com&gt; wrote:
&gt;
&gt; ср, 26 июн. 2019 г. в 17:00, Alon Bar-Lev &lt;alon.barlev@gmail.com&gt;:
&gt; &gt;
&gt; &gt; On Wed, Jun 26, 2019 at 4:53 PM Jeffrey Walton &lt;noloader@gmail.com&gt; wrote:
&gt; &gt; &gt;
&gt; &gt; &gt; On Wed, Jun 26, 2019 at 9:45 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; ...
&gt; &gt; &gt; &gt; From which autoconf version? I'd be happy to require a recent autoconf
&gt; &gt; &gt; &gt; and drop this code if it's no longer needed. When this hack was added,
&gt; &gt; &gt; &gt; it was the case that one or the other of
&gt; &gt; &gt;
&gt; &gt; &gt; Please NO. Don't require an updated Autotools version.
&gt; &gt; &gt;
&gt; &gt; &gt; It is impossible to update Autotools on existing systems. I've never
&gt; &gt; &gt; been able to do it on Linux, OS X and Solaris. The GCC Compile Farm
&gt; &gt; &gt; maintainers were not able to do it on compile farm machines like AIX.
&gt; &gt; &gt;
&gt; &gt; &gt; Stay with the basics. Things already work well. Allow a user to
&gt; &gt; &gt; override libdir using standard options. Don't do fancy things that
&gt; &gt; &gt; break builds.
&gt; &gt; &gt;
&gt; &gt; &gt; Also see https://www.gnu.org/prep/standards/html_node/Directory-Variables.html.
&gt; &gt; &gt;
&gt; &gt;
&gt; &gt; Since ever, packages should not have modified any of the system
&gt; &gt; autoconf variables. I believe that nettle is one of the few that
&gt; &gt; attempt to override the autoconf detection. I do not want to enter
&gt; &gt; philosophical argument, just to kindly ask to have the option to
&gt; &gt; disable this proprietary logic.
&gt;
&gt; What about just checking if libdir was overwritten via argument and not
&gt; touching it if it was the case? Will that work for you?

This patch is very simple... it have explicit --disable-... to disable
the behavior, default leaving the current behavior. All explicit, no
magic.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626164345</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-26 16:43:45-0400</timestampReceived><subject>Re: [PATCH 2/3] build: add --disable-libdir-abi-detection</subject><body>

Jeffrey Walton &lt;noloader@gmail.com&gt; writes:

&gt;&gt; From which autoconf version? I'd be happy to require a recent autoconf
&gt;&gt; and drop this code if it's no longer needed. When this hack was added,
&gt;&gt; it was the case that one or the other of
&gt;
&gt; Please NO. Don't require an updated Autotools version.

Huh? The configure script is included in the release tarball. You
*don't* need to even have autoconf installed to build the library.
That's half of the point of using autoconf at all.

Requirement on autoconf only matters for those who want to modify
configure.ac, or build from a git repo.

(And also, please don't use the term "autotools" if you want to say
anything specific; autotools is a very loose term refering to a couple
of very different tools each with their own particular quirks).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626165002</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-26 16:50:02-0400</timestampReceived><subject>Re: [PATCH 2/3] build: add --disable-libdir-abi-detection</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; What about just checking if libdir was overwritten via argument and not
&gt; touching it if it was the case? Will that work for you?

That's exactly how it has worked ever since this detection was added
back in 2010. Which is why I suggest that packagers who find that the
automatic detection is inappropriate simply use the standard --libdir=
command line option.

With the only caveat that since I didn't find a way to really check if
--libdir was provided or not, I compare $libdir to the default value,
the literal string '${exec_prefix}/lib', which is somewhat unlikely to
be used on the command line.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190602205221</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2019-06-02 20:52:21-0400</timestampReceived><subject>Re: siv and cmac</subject><body>

On Sat, Jun 1, 2019 at 10:42 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; I think the siv code could benefit from a funtion to create a cmac
&gt; digest in one step, without the update/digest split and the intermediate
&gt; buffer. That would be something like
&gt;
&gt; cmac128_message(const struct cmac128_key *key, const void *cipher,
&gt;                 nettle_crypt_func *encrypt,
&gt;                 size_t digest_length, uint8_t *digest,
&gt;                 size_t message_length, const uint8_t *message);
&gt;
&gt; Then the key need to be taken out from the cmac128_ctx. I'm trying that
&gt; out, on the branch cmac-layout. Patch below. What do you think?

Do you see significant performance benefits? Being consistent in
hashing/MAC APIs is also a benefit for the library and I  think the
change should be balanced against that.

regards,
Nikos
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190603182927</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-03 18:29:27-0400</timestampReceived><subject>Re: siv and cmac</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt;&gt; Then the key need to be taken out from the cmac128_ctx. I'm trying that
&gt;&gt; out, on the branch cmac-layout. Patch below. What do you think?
&gt;
&gt; Do you see significant performance benefits?

Main benefit is that it makes it possible to make the context argument
to siv_cmac_aes128_encrypt_message and similar functions const.

With a const context, one can, e.g., create a single siv_cmac_aes128_ctx
instance, call the _set_key method once, and then share it between
multiple threads processing messages independently. 

With the current code (on the siv-mode branch), _siv_s2v uses parts of
the context struct as working storage for cmac128_update, instead of
using local temporaries. This clobbering of the context is a side effect
with no benefit to the caller.

If we can change 

  #define SIV_CMAC_CTX(type) { struct CMAC128_CTX(type) siv_cmac; type siv_cipher; }

to 

  #define SIV_CMAC_CTX(type) { struct cmac128_key siv_cmac; type siv_cipher; }

then only the _set_key method needs to modify this context.

&gt; Being consistent in hashing/MAC APIs is also a benefit for the library
&gt; and I think the change should be balanced against that.

It's not necessarily a change to the advertised cmac api (the new struct
cmac128_key stays inside struct cmac128_ctx, and applications are not
expected to depend on the details of the context struct), but it would
be a small api/abi break, which is why I'd prefer to make the change
before we make the release including the new cmac code.

At least the specific functions, cmac_aes*, should stay unchanged, for
consistency with other macs. 

For the general ones, cmac128_set_key, _update, _digest, maybe they
should take a separate cmac128_key argument, and maybe be demoted to
internal for now? For siv, we would need some variant of cmac_set_key
function that takes only a cmac128_key argument, not a cmac128_ctx, and
the new cmac128_message. These could be internal or public.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190626205222</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2019-06-26 20:52:22-0400</timestampReceived><subject>Re: [PATCH 1/3] build: allow overriding the debug flags</subject><body>

On Wed, Jun 26, 2019 at 11:44 PM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:
&gt;
&gt; &gt; Which way do you prefer to avoid adding this flag? having environment
&gt; &gt; variable or --disable-xxx?
&gt;
&gt; You've brought up two different issues. For CFLAGS, I agree it could be
&gt; improved. Not sure what's the best way is, but the main thing is to let
&gt; CFLAGS be a user setting, following the coding standard. There could be
&gt; an option to enable or disable the maintainer's (i.e. my) choice of
&gt; additional warning flags.

Warnings are ok... I am talking about the -ggdb3 addition which
affects the output.
What do you prefer, this patch that enables me to have
GCC_DEBUG_FLAGS=" " or add --disable-maintainer-flags or something
like this?

&gt;
&gt; The libdir issue is a different thing. The automatic hack only affects

We discuss this libdir at the different thread... I can workaround
this by explicit parameters, however the CFLAGS forces me to patch.

Thanks!
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190627060515</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-06-27 06:05:15-0400</timestampReceived><subject>ANNOUNCE: Nettle-3.5.1</subject><body>

[Attachment #2 (multipart/signed)]


There was a packaging problem with the Nettle-3.5 release of yesterday,
breaking certain x86_64 configurations.

The Nettle home page can be found at
https://www.lysator.liu.se/~nisse/nettle/, and the manual at
https://www.lysator.liu.se/~nisse/nettle/nettle.html.

The corrected release can be downloaded from

  https://ftp.gnu.org/gnu/nettle/nettle-3.5.1.tar.gz
  ftp://ftp.gnu.org/gnu/nettle/nettle-3.5.1.tar.gz
  https://www.lysator.liu.se/~nisse/archive/nettle-3.5.1.tar.gz

Regards,
/Niels

NEWS for the Nettle 3.5.1 release

	The Nettle-3.5.1 corrects a packaging mistake in Nettle-3.5.
	The new directory x86_64/sha_ni were missing in the tar file,
	breaking x86_64 builds with --enable-fat, and producing worse
	performance than promised for builds with --enable-x86-sha-ni.
	Also a few unused in-progress assembly files were accidentally
	included in the tar file.

	These problems are corrected in Nettle-3.5.1. There are no
	other changes, and also the library version numbers are
	unchanged.

NEWS for the Nettle 3.5 release

	This release adds a couple of new features and optimizations,
	and deletes or deprecates a few obsolete features. It is *not*
	binary (ABI) compatible with earlier versions. Except for
	deprecations listed below, it is intended to be fully
	source-level (API) compatible with Nettle-3.4.1.

	The shared library names are libnettle.so.7.0 and
	libhogweed.so.5.0, with sonames libnettle.so.7 and
	libhogweed.so.5.

	Changes in behavior:

	* Nettle's gcm_crypt will now call the underlying block cipher
	  to process more than one block at a time. This is not a
	  change to the documented behavior, but unfortunately breaks
	  assumptions accidentally made in GnuTLS, up to and including
	  version 3.6.1.

	New features:

	* Support for CFB8 (Cipher Feedback Mode, processing a single
	  octet per block cipher operation), contributed by Dmitry
	  Eremin-Solenikov.

	* Support for CMAC (RFC 4493), contributed by Nikos
	  Mavrogiannopoulos.

	* Support for XTS mode, contributed by Simo Sorce.

	Optimizations:

	* Improved performance of the x86_64 AES implementation using
	  the aesni instructions. Gives a large speedup for operations
	  processing multiple blocks at a time (including CTR mode,
	  GCM mode, and CBC decrypt, but *not* CBC encrypt).

	* Improved performance for CTR mode, for the common case of
	  16-byte block size. Pass more data at a time to underlying
	  block cipher, and fill the counter blocks more efficiently.
	  Extension to also handle GCM mode efficiently contributed
	  by Nikos Mavrogiannopoulos.

	* New x86_64 implementation of sha1 and sha256, for processors
	  supporting the sha_ni instructions. Speedup of 3-5 times on
	  affected processors.

	* Improved parameters for the precomputation of tables used
	  for ecc signatures. Roughly 10%-15% speedup of the ecdsa
	  sign operation using the secp_256r1, secp_384r1 and
	  secp_521r1 curves, and 25% speedup of ed25519 sign
	  operation, benchmarked on x86_64. Table sizes unchanged,
	  around 16 KB per curve.

	* In ARM fat builds, automatically select Neon implementation
	  of Chacha, where possible. Contributed by Yuriy M.
	  Kaminskiy.

	Deleted features:

	* The header file des-compat.h and everything declared therein
	  has been deleted, as announced earlier. This file provided a
	  subset of the old libdes/ssleay/openssl interface for DES
	  and triple-DES. DES is still supported, via the functions
	  declared in des.h.

	* Functions using the old struct aes_ctx have been marked as
	  deprecated. Use the fixed key size interface instead, e.g.,
	  struct aes256_ctx, introduced in Nettle-3.0.

	* The header file nettle-stdint.h, and corresponding autoconf
	  tests, have been deleted. Nettle now requires that the
	  compiler/libc provides &lt;stdint.h&gt;.

	Miscellaneous:

	* Support for big-endian ARM systems, contributed by Michael
	  Weiser.

	* The programs aesdata, desdata, twofishdata, shadata and
	  gcmdata are no longer built by default. Makefile
	  improvements contributed by Jay Foad.

	* The "example" program examples/eratosthenes.c has been
	  deleted.

	* The contents of hash context structs, and the deprecated
	  aes_ctx struct, have been reorganized, to enable later
	  optimizations.

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.


["signature.asc" (application/pgp-signature)]
[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190628144255</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-06-28 14:42:55-0400</timestampReceived><subject>Changes after 3.5.1</subject><body>

Hello,

I have several patch series that were sitting in my local gost tree.
Most of them were posted to this mailing list for review with little
to no feedback. For now they
are incorporated into GnuTLS for testing and maturing. I'd like to
understand, how should I proceed if I'd like to get them included into
nettle to spare GnuTLS from having more and more crypto code.

 - CMAC-64 support (together with CMAC-TDES for testing).
 - Changes to GOST R 34.11-94 (gosthash94) code
 - GOST 28147-89/Magma 64-bit cipher (depend on gosthash94 changes)
 - Additional cipher modes required for full GOST 28147-89 support
 - Streebog hash algorithm (GOST R 34.11-2012)
 - Several GOST curves (2 for now, other require changes to ecc backend)
 - GOST ECC-based digital signature scheme
 - GOST ECC-based key agreement
 - small chunks of additional support code

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190508140130</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-08 14:01:30-0400</timestampReceived><subject>[PATCH 0/3] add support for GOST R 34.10 curves</subject><body>

Add support for several GOST curves as defined by RFC 4357 and RFC 7836.
Names for these curves are taken from TLS Supported Groups registry.

--
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190508140131</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-08 14:01:31-0400</timestampReceived><subject>[PATCH 1/3] ecc: rename source files with curves data</subject><body>

In preparation to adding GOST curves support, rename source files and
use curve name as eccdata parameter.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 .gitignore                                    | 12 ++---
 Makefile.in                                   | 45 ++++++++++---------
 ...cc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} |  0
 ...cc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} |  0
 ...cc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} |  0
 ...cc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} |  0
 ...cc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} |  0
 configure.ac                                  |  5 ++-
 ecc-25519.c =&gt; ecc-curve25519.c               |  4 +-
 ecc-192.c =&gt; ecc-secp192r1.c                  |  4 +-
 ecc-224.c =&gt; ecc-secp224r1.c                  |  4 +-
 ecc-256.c =&gt; ecc-secp256r1.c                  |  4 +-
 ecc-384.c =&gt; ecc-secp384r1.c                  |  4 +-
 ecc-521.c =&gt; ecc-secp521r1.c                  |  4 +-
 eccdata.c                                     | 45 ++++++++++---------
 ...25519-modp.asm =&gt; ecc-curve25519-modp.asm} |  0
 ...cc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} |  0
 ...cc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} |  0
 ...cc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} |  0
 ...cc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} |  0
 ...cc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} |  0
 21 files changed, 68 insertions(+), 63 deletions(-)
 rename arm/{ecc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} (100%)
 rename arm/{ecc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} (100%)
 rename arm/{ecc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} (100%)
 rename arm/{ecc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} (100%)
 rename arm/{ecc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} (100%)
 rename ecc-25519.c =&gt; ecc-curve25519.c (99%)
 rename ecc-192.c =&gt; ecc-secp192r1.c (98%)
 rename ecc-224.c =&gt; ecc-secp224r1.c (98%)
 rename ecc-256.c =&gt; ecc-secp256r1.c (99%)
 rename ecc-384.c =&gt; ecc-secp384r1.c (99%)
 rename ecc-521.c =&gt; ecc-secp521r1.c (98%)
 rename x86_64/{ecc-25519-modp.asm =&gt; ecc-curve25519-modp.asm} (100%)
 rename x86_64/{ecc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} (100%)
 rename x86_64/{ecc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} (100%)
 rename x86_64/{ecc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} (100%)
 rename x86_64/{ecc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} (100%)
 rename x86_64/{ecc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} (100%)

diff --git a/.gitignore b/.gitignore
index b79c53f535ff..be10fbe959cc 100644
--- a/.gitignore
+++ b/.gitignore
@@ -43,12 +43,12 @@ core
 /keymap.h
 /parity.h
 /rotors.h
-/ecc-192.h
-/ecc-224.h
-/ecc-256.h
-/ecc-384.h
-/ecc-521.h
-/ecc-25519.h
+/ecc-curve25519.h
+/ecc-secp192r1.h
+/ecc-secp224r1.h
+/ecc-secp256r1.h
+/ecc-secp384r1.h
+/ecc-secp521r1.h
 /version.h
 /nettle.aux
 /nettle.cp
diff --git a/Makefile.in b/Makefile.in
index 440de9f7bb59..8d8da40c1911 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -171,8 +171,8 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  gmp-glue.c cnd-copy.c \
 		  ecc-mod.c ecc-mod-inv.c \
 		  ecc-mod-arith.c ecc-pp1-redc.c ecc-pm1-redc.c \
-		  ecc-192.c ecc-224.c ecc-256.c ecc-384.c ecc-521.c \
-		  ecc-25519.c \
+		  ecc-curve25519.c ecc-secp192r1.c ecc-secp224r1.c \
+		  ecc-secp256r1.c ecc-secp384r1.c ecc-secp521r1.c \
 		  ecc-size.c ecc-j-to-a.c ecc-a-to-j.c \
 		  ecc-dup-jj.c ecc-add-jja.c ecc-add-jjj.c \
 		  ecc-eh-to-a.c \
@@ -341,24 +341,24 @@ des.$(OBJEXT): des.c des.h $(des_headers)
 # k = 14, c =  7, S = 256, T =  42 ( 28 A + 14 D) 12 KB
 # k = 11, c =  6, S = 192, T =  44 ( 33 A + 11 D)  9 KB
 # k = 16, c =  6, S = 128, T =  48 ( 32 A + 16 D)  6 KB
-ecc-192.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 192 8 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp192r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp192r1 8 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 224:
 # k = 16, c =  7, S = 256, T =  48 ( 32 A + 16 D) ~16 KB
 # k = 10, c =  6, S = 256, T =  50 ( 40 A + 10 D) ~16 KB
 # k = 13, c =  6, S = 192, T =  52 ( 39 A + 13 D) ~12 KB
 # k =  9, c =  5, S = 160, T =  54 ( 45 A +  9 D) ~10 KB
-ecc-224.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 224 16 7 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp224r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp224r1 16 7 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 256:
 # k =  9, c =  6, S = 320, T =  54 ( 45 A +  9 D) 20 KB
 # k = 11, c =  6, S = 256, T =  55 ( 44 A + 11 D) 16 KB
 # k = 19, c =  7, S = 256, T =  57 ( 38 A + 19 D) 16 KB
 # k = 15, c =  6, S = 192, T =  60 ( 45 A + 15 D) 12 KB
-ecc-256.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 256 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp256r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp256r1 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 384:
 # k = 16, c =  6, S = 256, T =  80 ( 64 A + 16 D) 24 KB
@@ -368,31 +368,31 @@ ecc-256.h: eccdata.stamp
 # k = 13, c =  5, S = 192, T =  91 ( 78 A + 13 D) 18 KB
 # k = 16, c =  5, S = 160, T =  96 ( 80 A + 16 D) 15 KB
 # k = 32, c =  6, S = 128, T =  96 ( 64 A + 32 D) 12 KB
-ecc-384.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 384 32 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp384r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp384r1 32 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 521:
 # k = 29, c =  6, S = 192, T = 116 ( 87 A + 29 D) ~27 KB
 # k = 21, c =  5, S = 160, T = 126 (105 A + 21 D) ~23 KB
 # k = 44, c =  6, S = 128, T = 132 ( 88 A + 44 D) ~18 KB
 # k = 35, c =  5, S =  96, T = 140 (105 A + 35 D) ~14 KB
-ecc-521.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 521 44 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp521r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp521r1 44 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
-# Parameter choices mostly the same as for ecc-256.h.
-ecc-25519.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 255 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+# Parameter choices mostly the same as for ecc-secp256r1.h.
+ecc-curve25519.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) curve25519 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 eccdata.stamp: eccdata.c
 	$(MAKE) eccdata$(EXEEXT_FOR_BUILD)
 	echo stamp &gt; eccdata.stamp
 
-ecc-192.$(OBJEXT): ecc-192.h
-ecc-224.$(OBJEXT): ecc-224.h
-ecc-256.$(OBJEXT): ecc-256.h
-ecc-384.$(OBJEXT): ecc-384.h
-ecc-521.$(OBJEXT): ecc-521.h
-ecc-25519.$(OBJEXT): ecc-25519.h
+ecc-curve25519.$(OBJEXT): ecc-curve25519.h
+ecc-secp192r1.$(OBJEXT): ecc-secp192r1.h
+ecc-secp224r1.$(OBJEXT): ecc-secp224r1.h
+ecc-secp256r1.$(OBJEXT): ecc-secp256r1.h
+ecc-secp384r1.$(OBJEXT): ecc-secp384r1.h
+ecc-secp521r1.$(OBJEXT): ecc-secp521r1.h
 
 .asm.$(OBJEXT): $(srcdir)/asm.m4 machine.m4 config.m4
 	$(M4) $(srcdir)/asm.m4 machine.m4 config.m4 $&lt; &gt;$*.s
@@ -645,7 +645,8 @@ distcheck: dist
 
 clean-here:
 	-rm -f $(TARGETS) *.$(OBJEXT) *.s *.so *.dll *.a \
-		ecc-192.h ecc-224.h ecc-256.h ecc-384.h ecc-521.h ecc-25519.h \
+		ecc-curve25519.h ecc-secp192r1.h ecc-secp224r1.h ecc-secp256r1.h \
+		ecc-secp384r1.h ecc-secp521r1.h \
 		aesdata$(EXEEXT_FOR_BUILD) \
 		desdata$(EXEEXT_FOR_BUILD) \
 		twofishdata$(EXEEXT_FOR_BUILD) \
diff --git a/arm/ecc-192-modp.asm b/arm/ecc-secp192r1-modp.asm
similarity index 100%
rename from arm/ecc-192-modp.asm
rename to arm/ecc-secp192r1-modp.asm
diff --git a/arm/ecc-224-modp.asm b/arm/ecc-secp224r1-modp.asm
similarity index 100%
rename from arm/ecc-224-modp.asm
rename to arm/ecc-secp224r1-modp.asm
diff --git a/arm/ecc-256-redc.asm b/arm/ecc-secp256r1-redc.asm
similarity index 100%
rename from arm/ecc-256-redc.asm
rename to arm/ecc-secp256r1-redc.asm
diff --git a/arm/ecc-384-modp.asm b/arm/ecc-secp384r1-modp.asm
similarity index 100%
rename from arm/ecc-384-modp.asm
rename to arm/ecc-secp384r1-modp.asm
diff --git a/arm/ecc-521-modp.asm b/arm/ecc-secp521r1-modp.asm
similarity index 100%
rename from arm/ecc-521-modp.asm
rename to arm/ecc-secp521r1-modp.asm
diff --git a/configure.ac b/configure.ac
index 00d2bf5dcd40..ade9c919abcb 100644
--- a/configure.ac
+++ b/configure.ac
@@ -475,8 +475,9 @@ asm_nettle_optional_list="gcm-hash8.asm cpuid.asm \
 
 asm_hogweed_optional_list=""
 if test "x$enable_public_key" = "xyes" ; then
-  asm_hogweed_optional_list="ecc-192-modp.asm ecc-224-modp.asm \
-    ecc-25519-modp.asm ecc-256-redc.asm ecc-384-modp.asm ecc-521-modp.asm"
+  asm_hogweed_optional_list="ecc-curve25519-modp.asm \
+    ecc-secp192r1-modp.asm ecc-secp224r1-modp.asm \
+    ecc-secp256r1-redc.asm ecc-secp384r1-modp.asm ecc-secp521r1-modp.asm"
 fi
 
 OPT_NETTLE_OBJS=""
diff --git a/ecc-25519.c b/ecc-curve25519.c
similarity index 99%
rename from ecc-25519.c
rename to ecc-curve25519.c
index bb71a36b3cd5..9e77a4ca9aef 100644
--- a/ecc-25519.c
+++ b/ecc-curve25519.c
@@ -1,4 +1,4 @@
-/* ecc-25519.c
+/* ecc-curve25519.c
 
    Arithmetic and tables for curve25519,
 
@@ -42,7 +42,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-25519.h"
+#include "ecc-curve25519.h"
 
 #define PHIGH_BITS (GMP_NUMB_BITS * ECC_LIMB_SIZE - 255)
 
diff --git a/ecc-192.c b/ecc-secp192r1.c
similarity index 98%
rename from ecc-192.c
rename to ecc-secp192r1.c
index 4f428113674e..8919f85bcfb5 100644
--- a/ecc-192.c
+++ b/ecc-secp192r1.c
@@ -1,4 +1,4 @@
-/* ecc-192.c
+/* ecc-secp192r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -46,7 +46,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-192.h"
+#include "ecc-secp192r1.h"
 
 #if HAVE_NATIVE_ecc_192_modp
 
diff --git a/ecc-224.c b/ecc-secp224r1.c
similarity index 98%
rename from ecc-224.c
rename to ecc-secp224r1.c
index 5962e1b863bf..cc15a7470e75 100644
--- a/ecc-224.c
+++ b/ecc-secp224r1.c
@@ -1,4 +1,4 @@
-/* ecc-224.c
+/* ecc-secp224r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -52,7 +52,7 @@ ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #define ecc_224_modp ecc_mod
 #endif
 
-#include "ecc-224.h"
+#include "ecc-secp224r1.h"
 
 #if ECC_REDC_SIZE &lt; 0
 # define ecc_224_redc ecc_pm1_redc
diff --git a/ecc-256.c b/ecc-secp256r1.c
similarity index 99%
rename from ecc-256.c
rename to ecc-secp256r1.c
index 7eed2835c08a..611d6d7c7d42 100644
--- a/ecc-256.c
+++ b/ecc-secp256r1.c
@@ -1,4 +1,4 @@
-/* ecc-256.c
+/* ecc-secp256r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -48,7 +48,7 @@
 # define USE_REDC (ECC_REDC_SIZE != 0)
 #endif
 
-#include "ecc-256.h"
+#include "ecc-secp256r1.h"
 
 #if HAVE_NATIVE_ecc_256_redc
 # define ecc_256_redc nettle_ecc_256_redc
diff --git a/ecc-384.c b/ecc-secp384r1.c
similarity index 99%
rename from ecc-384.c
rename to ecc-secp384r1.c
index 94b8af91354e..6ffed8473c36 100644
--- a/ecc-384.c
+++ b/ecc-secp384r1.c
@@ -1,4 +1,4 @@
-/* ecc-384.c
+/* ecc-secp384r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -44,7 +44,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-384.h"
+#include "ecc-secp384r1.h"
 
 #if HAVE_NATIVE_ecc_384_modp
 #define ecc_384_modp nettle_ecc_384_modp
diff --git a/ecc-521.c b/ecc-secp521r1.c
similarity index 98%
rename from ecc-521.c
rename to ecc-secp521r1.c
index 52a018dd7c9c..753208c6b47d 100644
--- a/ecc-521.c
+++ b/ecc-secp521r1.c
@@ -1,4 +1,4 @@
-/* ecc-521.c
+/* ecc-secp521r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -42,7 +42,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-521.h"
+#include "ecc-secp521r1.h"
 
 #if HAVE_NATIVE_ecc_521_modp
 #define ecc_521_modp nettle_ecc_521_modp
diff --git a/eccdata.c b/eccdata.c
index fa7a11c5f0af..12b2455d4058 100644
--- a/eccdata.c
+++ b/eccdata.c
@@ -345,11 +345,10 @@ ecc_curve_init_str (struct ecc_curve *ecc, enum ecc_type type,
 }
 
 static void
-ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
+ecc_curve_init (struct ecc_curve *ecc, const char *curve)
 {
-  switch (bit_size)
+  if (!strcmp (curve, "secp192r1"))
     {
-    case 192:      
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{192} - 2^{64} - 1 */
 			  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE"
@@ -380,8 +379,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "35433907297cc378b0015703374729d7a4fe46647084e4ba",
 		   "a2649984f2135c301ea3acb0776cd4f125389b311db3be32");
 
-      break;
-    case 224:
+    }
+  else if (!strcmp (curve, "secp224r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{224} - 2^{96} + 1 */
 			  "ffffffffffffffffffffffffffffffff"
@@ -413,8 +413,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "ae99feebb5d26945b54892092a8aee02912930fa41cd114e40447301",
 		   "482580a0ec5bc47e88bc8c378632cd196cb3fa058a7114eb03054c9");
 
-      break;
-    case 256:
+    }
+  else if (!strcmp (curve, "secp256r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{256} - 2^{224} + 2^{192} + 2^{96} - 1 */
 			  "FFFFFFFF000000010000000000000000"
@@ -446,8 +447,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "e2534a3532d08fbba02dde659ee62bd0031fe2db785596ef509302446b030852",
 		   "e0f1575a4c633cc719dfee5fda862d764efc96c3f30ee0055c42c23f184ed8c6");
 
-      break;
-    case 384:
+    }
+  else if (!strcmp (curve, "secp384r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{384} - 2^{128} - 2^{96} + 2^{32} - 1 */
 			  "ffffffffffffffffffffffffffffffff"
@@ -484,8 +486,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "138251cd52ac9298c1c8aad977321deb97e709bd0b4ca0aca55dc8ad51dcfc9d1589a1597e3a5120e1efd631c63e1835",
                
 		   "cacae29869a62e1631e8a28181ab56616dc45d918abc09f3ab0e63cf792aa4dced7387be37bba569549f1c02b270ed67");
  
-      break;
-    case 521:
+    }
+  else if (!strcmp (curve, "secp521r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  "1ff" /* p = 2^{521} - 1 */
 			  "ffffffffffffffffffffffffffffffff"
@@ -531,8 +534,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "35b5df64ae2ac204c354b483487c9070cdc61c891c5ff39afc06c5d55541d3ceac8659e24afe3d0750e8b88e9f078af066a1d5025b08e5a5e2fbc87412871902f3",
                
 		   "82096f84261279d2b673e0178eb0b4abb65521aef6e6e32e1b5ae63fe2f19907f279f283e54ba385405224f750a95b85eebb7faef04699d1d9e21f47fc346e4d0d");
  
-      break;
-    case 255:
+    }
+  else if (!strcmp (curve, "curve25519"))
+    {
       /* curve25519, y^2 = x^3 + 486662 x^2 + x (mod p), with p = 2^{255} - 19.
 
 	 According to http://cr.yp.to/papers.html#newelliptic, this
@@ -601,14 +605,13 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "fe1805dfcd5d2a230fee85e4550013ef",
 		   "75af5bf4ebdc75c8fe26873427d275d7"
 		   "3c0fb13da361077a565539f46de1c30");
-
-      break;
-
-    default:
-      fprintf (stderr, "No known curve for size %d\n", bit_size);
-      exit(EXIT_FAILURE);     
     }
-  ecc-&gt;bit_size = bit_size;
+  else
+    {
+      fprintf (stderr, "No known curve with name %s\n", curve);
+      exit(EXIT_FAILURE);
+    }
+  ecc-&gt;bit_size = mpz_sizeinbase (ecc-&gt;p, 2);
 }
 
 static void
@@ -1204,7 +1207,7 @@ main (int argc, char **argv)
       return EXIT_FAILURE;
     }
 
-  ecc_curve_init (&amp;ecc, atoi(argv[1]));
+  ecc_curve_init (&amp;ecc, argv[1]);
 
   ecc_pippenger_precompute (&amp;ecc, atoi(argv[2]), atoi(argv[3]));
 
diff --git a/x86_64/ecc-25519-modp.asm b/x86_64/ecc-curve25519-modp.asm
similarity index 100%
rename from x86_64/ecc-25519-modp.asm
rename to x86_64/ecc-curve25519-modp.asm
diff --git a/x86_64/ecc-192-modp.asm b/x86_64/ecc-secp192r1-modp.asm
similarity index 100%
rename from x86_64/ecc-192-modp.asm
rename to x86_64/ecc-secp192r1-modp.asm
diff --git a/x86_64/ecc-224-modp.asm b/x86_64/ecc-secp224r1-modp.asm
similarity index 100%
rename from x86_64/ecc-224-modp.asm
rename to x86_64/ecc-secp224r1-modp.asm
diff --git a/x86_64/ecc-256-redc.asm b/x86_64/ecc-secp256r1-redc.asm
similarity index 100%
rename from x86_64/ecc-256-redc.asm
rename to x86_64/ecc-secp256r1-redc.asm
diff --git a/x86_64/ecc-384-modp.asm b/x86_64/ecc-secp384r1-modp.asm
similarity index 100%
rename from x86_64/ecc-384-modp.asm
rename to x86_64/ecc-secp384r1-modp.asm
diff --git a/x86_64/ecc-521-modp.asm b/x86_64/ecc-secp521r1-modp.asm
similarity index 100%
rename from x86_64/ecc-521-modp.asm
rename to x86_64/ecc-secp521r1-modp.asm
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190508140132</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-08 14:01:32-0400</timestampReceived><subject>[PATCH 2/3] Add GOST R 34.10 curves defined by RFC4357 and newer standard</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 .gitignore               |   5 ++
 Makefile.in              |  55 +++++++++++++-
 ecc-curve.h              |   5 ++
 ecc-gc256b.c             | 125 ++++++++++++++++++++++++++++++
 ecc-gc256c.c             | 143 +++++++++++++++++++++++++++++++++++
 ecc-gc256d.c             | 137 +++++++++++++++++++++++++++++++++
 ecc-gc512a.c             | 125 ++++++++++++++++++++++++++++++
 ecc-gc512b.c             | 137 +++++++++++++++++++++++++++++++++
 ecc-internal.h           |   7 ++
 eccdata.c                | 159 ++++++++++++++++++++++++++++++++++++++-
 examples/ecc-benchmark.c |   5 ++
 testsuite/testutils.c    |  56 +++++++++++++-
 12 files changed, 954 insertions(+), 5 deletions(-)
 create mode 100644 ecc-gc256b.c
 create mode 100644 ecc-gc256c.c
 create mode 100644 ecc-gc256d.c
 create mode 100644 ecc-gc512a.c
 create mode 100644 ecc-gc512b.c

diff --git a/.gitignore b/.gitignore
index be10fbe959cc..4edcc8726448 100644
--- a/.gitignore
+++ b/.gitignore
@@ -44,6 +44,11 @@ core
 /parity.h
 /rotors.h
 /ecc-curve25519.h
+/ecc-gc256b.h
+/ecc-gc256c.h
+/ecc-gc256d.h
+/ecc-gc512a.h
+/ecc-gc512b.h
 /ecc-secp192r1.h
 /ecc-secp224r1.h
 /ecc-secp256r1.h
diff --git a/Makefile.in b/Makefile.in
index 8d8da40c1911..98bcad33f866 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -171,7 +171,10 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  gmp-glue.c cnd-copy.c \
 		  ecc-mod.c ecc-mod-inv.c \
 		  ecc-mod-arith.c ecc-pp1-redc.c ecc-pm1-redc.c \
-		  ecc-curve25519.c ecc-secp192r1.c ecc-secp224r1.c \
+		  ecc-curve25519.c \
+		  ecc-gc256b.c ecc-gc256c.c ecc-gc256d.c \
+		  ecc-gc512a.c ecc-gc512b.c \
+		  ecc-secp192r1.c ecc-secp224r1.c \
 		  ecc-secp256r1.c ecc-secp384r1.c ecc-secp521r1.c \
 		  ecc-size.c ecc-j-to-a.c ecc-a-to-j.c \
 		  ecc-dup-jj.c ecc-add-jja.c ecc-add-jjj.c \
@@ -382,12 +385,57 @@ ecc-secp521r1.h: eccdata.stamp
 # Parameter choices mostly the same as for ecc-secp256r1.h.
 ecc-curve25519.h: eccdata.stamp
 	./eccdata$(EXEEXT_FOR_BUILD) curve25519 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+	#
+# Some reasonable choices for 256:
+# k =  9, c =  6, S = 320, T =  54 ( 45 A +  9 D) 20 KB
+# k = 11, c =  6, S = 256, T =  55 ( 44 A + 11 D) 16 KB
+# k = 19, c =  7, S = 256, T =  57 ( 38 A + 19 D) 16 KB
+# k = 15, c =  6, S = 192, T =  60 ( 45 A + 15 D) 12 KB
+ecc-gc256b.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) gc256b 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+
+# Some reasonable choices for 256:
+# k =  9, c =  6, S = 320, T =  54 ( 45 A +  9 D) 20 KB
+# k = 11, c =  6, S = 256, T =  55 ( 44 A + 11 D) 16 KB
+# k = 19, c =  7, S = 256, T =  57 ( 38 A + 19 D) 16 KB
+# k = 15, c =  6, S = 192, T =  60 ( 45 A + 15 D) 12 KB
+ecc-gc256c.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) gc256c 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+
+# Some reasonable choices for 256:
+# k =  9, c =  6, S = 320, T =  54 ( 45 A +  9 D) 20 KB
+# k = 11, c =  6, S = 256, T =  55 ( 44 A + 11 D) 16 KB
+# k = 19, c =  7, S = 256, T =  57 ( 38 A + 19 D) 16 KB
+# k = 15, c =  6, S = 192, T =  60 ( 45 A + 15 D) 12 KB
+ecc-gc256d.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) gc256d 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+
+# Some reasonable choices for 512:
+# k = 29, c =  6, S = 192, T = 116 ( 87 A + 29 D)
+# k = 21, c =  5, S = 160, T = 126 (105 A + 21 D)
+# k = 43, c =  6, S = 128, T = 129 ( 86 A + 43 D)
+# k = 35, c =  5, S =  96, T = 140 (105 A + 35 D)
+ecc-gc512a.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) gc512a 43 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+
+# Some reasonable choices for 512:
+# k = 29, c =  6, S = 192, T = 116 ( 87 A + 29 D)
+# k = 21, c =  5, S = 160, T = 126 (105 A + 21 D)
+# k = 43, c =  6, S = 128, T = 129 ( 86 A + 43 D)
+# k = 35, c =  5, S =  96, T = 140 (105 A + 35 D)
+ecc-gc512b.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) gc512b 43 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 eccdata.stamp: eccdata.c
 	$(MAKE) eccdata$(EXEEXT_FOR_BUILD)
 	echo stamp &gt; eccdata.stamp
 
 ecc-curve25519.$(OBJEXT): ecc-curve25519.h
+ecc-gc256b.$(OBJEXT): ecc-gc256b.h
+ecc-gc256c.$(OBJEXT): ecc-gc256c.h
+ecc-gc256d.$(OBJEXT): ecc-gc256d.h
+ecc-gc512a.$(OBJEXT): ecc-gc512a.h
+ecc-gc512b.$(OBJEXT): ecc-gc512b.h
 ecc-secp192r1.$(OBJEXT): ecc-secp192r1.h
 ecc-secp224r1.$(OBJEXT): ecc-secp224r1.h
 ecc-secp256r1.$(OBJEXT): ecc-secp256r1.h
@@ -645,7 +693,10 @@ distcheck: dist
 
 clean-here:
 	-rm -f $(TARGETS) *.$(OBJEXT) *.s *.so *.dll *.a \
-		ecc-curve25519.h ecc-secp192r1.h ecc-secp224r1.h ecc-secp256r1.h \
+		ecc-curve25519.h \
+		ecc-gc256b.h ecc-gc256c.h ecc-gc256d.h \
+		ecc-gc512a.h ecc-gc512b.h \
+		ecc-secp192r1.h ecc-secp224r1.h ecc-secp256r1.h \
 		ecc-secp384r1.h ecc-secp521r1.h \
 		aesdata$(EXEEXT_FOR_BUILD) \
 		desdata$(EXEEXT_FOR_BUILD) \
diff --git a/ecc-curve.h b/ecc-curve.h
index 76024a19d24f..e0aafae4e996 100644
--- a/ecc-curve.h
+++ b/ecc-curve.h
@@ -48,6 +48,11 @@ const struct ecc_curve * _NETTLE_ATTRIBUTE_PURE \
nettle_get_secp_224r1(void);  const struct ecc_curve * _NETTLE_ATTRIBUTE_PURE \
nettle_get_secp_256r1(void);  const struct ecc_curve * _NETTLE_ATTRIBUTE_PURE \
nettle_get_secp_384r1(void);  const struct ecc_curve * _NETTLE_ATTRIBUTE_PURE \
nettle_get_secp_521r1(void); +const struct ecc_curve * _NETTLE_ATTRIBUTE_PURE \
nettle_get_gc_256b(void); +const struct ecc_curve * _NETTLE_ATTRIBUTE_PURE \
nettle_get_gc_256c(void); +const struct ecc_curve * _NETTLE_ATTRIBUTE_PURE \
nettle_get_gc_256d(void); +const struct ecc_curve * _NETTLE_ATTRIBUTE_PURE \
nettle_get_gc_512a(void); +const struct ecc_curve * _NETTLE_ATTRIBUTE_PURE \
nettle_get_gc_512b(void);  
 #ifdef __cplusplus
 }
diff --git a/ecc-gc256b.c b/ecc-gc256b.c
new file mode 100644
index 000000000000..af6dcaa3264d
--- /dev/null
+++ b/ecc-gc256b.c
@@ -0,0 +1,125 @@
+/* ecc-gc256b.c
+
+   Compile time constant (but machine dependent) tables.
+
+   Copyright (C) 2016, 2019 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+/* Development of Nettle's ECC support was funded by the .SE Internet Fund. */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "ecc.h"
+#include "ecc-internal.h"
+
+#define USE_REDC (ECC_REDC_SIZE != 0)
+
+#include "ecc-gc256b.h"
+
+#if ECC_REDC_SIZE &gt; 0
+#  define ecc_256_redc ecc_pp1_redc
+#elif ECC_REDC_SIZE == 0
+#  define ecc_256_redc NULL
+#else
+# error Configuration error
+#endif
+
+#define ecc_256_modp ecc_mod
+#define ecc_256_modq ecc_mod
+
+const struct ecc_curve _nettle_gc_256b =
+{
+  {
+    256,
+    ECC_LIMB_SIZE,
+    ECC_BMODP_SIZE,
+    ECC_REDC_SIZE,
+    ECC_MOD_INV_ITCH (ECC_LIMB_SIZE),
+    0,
+
+    ecc_p,
+    ecc_Bmodp,
+    ecc_Bmodp_shifted,
+    ecc_redc_ppm1,
+
+    ecc_pp1h,
+    ecc_256_modp,
+    USE_REDC ? ecc_256_redc : ecc_256_modp,
+    ecc_mod_inv,
+    NULL,
+  },
+  {
+    256,
+    ECC_LIMB_SIZE,
+    ECC_BMODQ_SIZE,
+    0,
+    ECC_MOD_INV_ITCH (ECC_LIMB_SIZE),
+    0,
+
+    ecc_q,
+    ecc_Bmodq,
+    ecc_Bmodq_shifted,
+    NULL,
+    ecc_qp1h,
+
+    ecc_256_modq,
+    ecc_256_modq,
+    ecc_mod_inv,
+    NULL,
+  },
+
+  USE_REDC,
+  ECC_PIPPENGER_K,
+  ECC_PIPPENGER_C,
+
+  ECC_ADD_JJJ_ITCH (ECC_LIMB_SIZE),
+  ECC_MUL_A_ITCH (ECC_LIMB_SIZE),
+  ECC_MUL_G_ITCH (ECC_LIMB_SIZE),
+  ECC_J_TO_A_ITCH (ECC_LIMB_SIZE),
+
+  ecc_add_jjj,
+  ecc_mul_a,
+  ecc_mul_g,
+  ecc_j_to_a,
+
+  ecc_b,
+  ecc_g,
+  NULL,
+  ecc_unit,
+  ecc_table
+};
+
+const struct ecc_curve *nettle_get_gc_256b(void)
+{
+  return &amp;_nettle_gc_256b;
+}
diff --git a/ecc-gc256c.c b/ecc-gc256c.c
new file mode 100644
index 000000000000..8018d1426150
--- /dev/null
+++ b/ecc-gc256c.c
@@ -0,0 +1,143 @@
+/* ecc-gc256c.c
+
+   Compile time constant (but machine dependent) tables.
+
+   Copyright (C) 2016, 2019 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+/* Development of Nettle's ECC support was funded by the .SE Internet Fund. */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "ecc.h"
+#include "ecc-internal.h"
+
+#define USE_REDC (ECC_REDC_SIZE != 0)
+
+#include "ecc-gc256c.h"
+
+#if HAVE_NATIVE_ecc_256_redc
+# define ecc_256_redc nettle_ecc_256_redc
+void
+ecc_256_redc (const struct ecc_modulo *p, mp_limb_t *rp);
+#else /* !HAVE_NATIVE_ecc_256_redc */
+# if ECC_REDC_SIZE &gt; 0
+#   define ecc_256_redc ecc_pp1_redc
+# elif ECC_REDC_SIZE == 0
+#   define ecc_256_redc NULL
+# else
+#  error Configuration error
+# endif
+#endif /* !HAVE_NATIVE_ecc_256_redc */
+
+static void
+ecc_gost256_mod (const struct ecc_modulo *p, mp_limb_t *rp)
+{
+  mp_size_t mn = p-&gt;size;
+  mpz_t r, a, m;
+  mpz_init (r);
+  mpz_mod (r, mpz_roinit_n (a, rp, 2*mn), mpz_roinit_n (m, p-&gt;m, mn));
+  mpz_limbs_copy (rp, r, mn);
+
+  mpz_clear (r);
+}
+
+#define ecc_256_modp ecc_gost256_mod
+#define ecc_256_modq ecc_gost256_mod
+
+const struct ecc_curve _nettle_gc_256c =
+{
+  {
+    256,
+    ECC_LIMB_SIZE,
+    ECC_BMODP_SIZE,
+    ECC_REDC_SIZE,
+    ECC_MOD_INV_ITCH (ECC_LIMB_SIZE),
+    0,
+
+    ecc_p,
+    ecc_Bmodp,
+    ecc_Bmodp_shifted,
+    ecc_redc_ppm1,
+
+    ecc_pp1h,
+    ecc_256_modp,
+    USE_REDC ? ecc_256_redc : ecc_256_modp,
+    ecc_mod_inv,
+    NULL,
+  },
+  {
+    256,
+    ECC_LIMB_SIZE,
+    ECC_BMODQ_SIZE,
+    0,
+    ECC_MOD_INV_ITCH (ECC_LIMB_SIZE),
+    0,
+
+    ecc_q,
+    ecc_Bmodq,
+    ecc_Bmodq_shifted,
+    NULL,
+    ecc_qp1h,
+
+    ecc_256_modq,
+    ecc_256_modq,
+    ecc_mod_inv,
+    NULL,
+  },
+
+  USE_REDC,
+  ECC_PIPPENGER_K,
+  ECC_PIPPENGER_C,
+
+  ECC_ADD_JJJ_ITCH (ECC_LIMB_SIZE),
+  ECC_MUL_A_ITCH (ECC_LIMB_SIZE),
+  ECC_MUL_G_ITCH (ECC_LIMB_SIZE),
+  ECC_J_TO_A_ITCH (ECC_LIMB_SIZE),
+
+  ecc_add_jjj,
+  ecc_mul_a,
+  ecc_mul_g,
+  ecc_j_to_a,
+
+  ecc_b,
+  ecc_g,
+  NULL,
+  ecc_unit,
+  ecc_table
+};
+
+const struct ecc_curve *nettle_get_gc_256c(void)
+{
+  return &amp;_nettle_gc_256c;
+}
diff --git a/ecc-gc256d.c b/ecc-gc256d.c
new file mode 100644
index 000000000000..bbd0b406cc91
--- /dev/null
+++ b/ecc-gc256d.c
@@ -0,0 +1,137 @@
+/* ecc-gc256d.c
+
+   Compile time constant (but machine dependent) tables.
+
+   Copyright (C) 2016, 2019 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+/* Development of Nettle's ECC support was funded by the .SE Internet Fund. */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "ecc.h"
+#include "ecc-internal.h"
+
+#define USE_REDC (ECC_REDC_SIZE != 0)
+
+#include "ecc-gc256d.h"
+
+#if ECC_REDC_SIZE &gt; 0
+#  define ecc_256_redc ecc_pp1_redc
+#elif ECC_REDC_SIZE == 0
+#  define ecc_256_redc NULL
+#else
+# error Configuration error
+#endif
+
+static void
+ecc_gost256_mod (const struct ecc_modulo *p, mp_limb_t *rp)
+{
+  mp_size_t mn = p-&gt;size;
+  mpz_t r, a, m;
+  mpz_init (r);
+  mpz_mod (r, mpz_roinit_n (a, rp, 2*mn), mpz_roinit_n (m, p-&gt;m, mn));
+  mpz_limbs_copy (rp, r, mn);
+
+  mpz_clear (r);
+}
+
+#define ecc_256_modp ecc_gost256_mod
+#define ecc_256_modq ecc_gost256_mod
+
+const struct ecc_curve _nettle_gc_256d =
+{
+  {
+    256,
+    ECC_LIMB_SIZE,
+    ECC_BMODP_SIZE,
+    ECC_REDC_SIZE,
+    ECC_MOD_INV_ITCH (ECC_LIMB_SIZE),
+    0,
+
+    ecc_p,
+    ecc_Bmodp,
+    ecc_Bmodp_shifted,
+    ecc_redc_ppm1,
+
+    ecc_pp1h,
+    ecc_256_modp,
+    USE_REDC ? ecc_256_redc : ecc_256_modp,
+    ecc_mod_inv,
+    NULL,
+  },
+  {
+    256,
+    ECC_LIMB_SIZE,
+    ECC_BMODQ_SIZE,
+    0,
+    ECC_MOD_INV_ITCH (ECC_LIMB_SIZE),
+    0,
+
+    ecc_q,
+    ecc_Bmodq,
+    ecc_Bmodq_shifted,
+    NULL,
+    ecc_qp1h,
+
+    ecc_256_modq,
+    ecc_256_modq,
+    ecc_mod_inv,
+    NULL,
+  },
+
+  USE_REDC,
+  ECC_PIPPENGER_K,
+  ECC_PIPPENGER_C,
+
+  ECC_ADD_JJJ_ITCH (ECC_LIMB_SIZE),
+  ECC_MUL_A_ITCH (ECC_LIMB_SIZE),
+  ECC_MUL_G_ITCH (ECC_LIMB_SIZE),
+  ECC_J_TO_A_ITCH (ECC_LIMB_SIZE),
+
+  ecc_add_jjj,
+  ecc_mul_a,
+  ecc_mul_g,
+  ecc_j_to_a,
+
+  ecc_b,
+  ecc_g,
+  NULL,
+  ecc_unit,
+  ecc_table
+};
+
+const struct ecc_curve *nettle_get_gc_256d(void)
+{
+  return &amp;_nettle_gc_256d;
+}
diff --git a/ecc-gc512a.c b/ecc-gc512a.c
new file mode 100644
index 000000000000..26ff83451944
--- /dev/null
+++ b/ecc-gc512a.c
@@ -0,0 +1,125 @@
+/* ecc-gc512a.c
+
+   Compile time constant (but machine dependent) tables.
+
+   Copyright (C) 2016, 2019 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+/* Development of Nettle's ECC support was funded by the .SE Internet Fund. */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "ecc.h"
+#include "ecc-internal.h"
+
+#define USE_REDC (ECC_REDC_SIZE != 0)
+
+#include "ecc-gc512a.h"
+
+#if ECC_REDC_SIZE &gt; 0
+#  define ecc_512_redc ecc_pp1_redc
+#elif ECC_REDC_SIZE == 0
+#  define ecc_512_redc NULL
+#else
+# error Configuration error
+#endif
+
+#define ecc_512_modp ecc_mod
+#define ecc_512_modq ecc_mod
+
+const struct ecc_curve _nettle_gc_512a =
+{
+  {
+    512,
+    ECC_LIMB_SIZE,
+    ECC_BMODP_SIZE,
+    ECC_REDC_SIZE,
+    ECC_MOD_INV_ITCH (ECC_LIMB_SIZE),
+    0,
+
+    ecc_p,
+    ecc_Bmodp,
+    ecc_Bmodp_shifted,
+    ecc_redc_ppm1,
+
+    ecc_pp1h,
+    ecc_512_modp,
+    USE_REDC ? ecc_512_redc : ecc_512_modp,
+    ecc_mod_inv,
+    NULL,
+  },
+  {
+    512,
+    ECC_LIMB_SIZE,
+    ECC_BMODQ_SIZE,
+    0,
+    ECC_MOD_INV_ITCH (ECC_LIMB_SIZE),
+    0,
+
+    ecc_q,
+    ecc_Bmodq,
+    ecc_Bmodq_shifted,
+    NULL,
+    ecc_qp1h,
+
+    ecc_512_modq,
+    ecc_512_modq,
+    ecc_mod_inv,
+    NULL,
+  },
+
+  USE_REDC,
+  ECC_PIPPENGER_K,
+  ECC_PIPPENGER_C,
+
+  ECC_ADD_JJJ_ITCH (ECC_LIMB_SIZE),
+  ECC_MUL_A_ITCH (ECC_LIMB_SIZE),
+  ECC_MUL_G_ITCH (ECC_LIMB_SIZE),
+  ECC_J_TO_A_ITCH (ECC_LIMB_SIZE),
+
+  ecc_add_jjj,
+  ecc_mul_a,
+  ecc_mul_g,
+  ecc_j_to_a,
+
+  ecc_b,
+  ecc_g,
+  NULL,
+  ecc_unit,
+  ecc_table
+};
+
+const struct ecc_curve *nettle_get_gc_512a(void)
+{
+  return &amp;_nettle_gc_512a;
+}
diff --git a/ecc-gc512b.c b/ecc-gc512b.c
new file mode 100644
index 000000000000..b36ea83da415
--- /dev/null
+++ b/ecc-gc512b.c
@@ -0,0 +1,137 @@
+/* ecc-gc512b.c
+
+   Compile time constant (but machine dependent) tables.
+
+   Copyright (C) 2016, 2019 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+/* Development of Nettle's ECC support was funded by the .SE Internet Fund. */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "ecc.h"
+#include "ecc-internal.h"
+
+#define USE_REDC (ECC_REDC_SIZE != 0)
+
+#include "ecc-gc512b.h"
+
+#if ECC_REDC_SIZE &gt; 0
+#  define ecc_512_redc ecc_pp1_redc
+#elif ECC_REDC_SIZE == 0
+#  define ecc_512_redc NULL
+#else
+# error Configuration error
+#endif
+
+static void
+ecc_gc512_mod (const struct ecc_modulo *p, mp_limb_t *rp)
+{
+  mp_size_t mn = p-&gt;size;
+  mpz_t r, a, m;
+  mpz_init (r);
+  mpz_mod (r, mpz_roinit_n (a, rp, 2*mn), mpz_roinit_n (m, p-&gt;m, mn));
+  mpz_limbs_copy (rp, r, mn);
+
+  mpz_clear (r);
+}
+
+#define ecc_512_modp ecc_gc512_mod
+#define ecc_512_modq ecc_gc512_mod
+
+const struct ecc_curve _nettle_gc_512b =
+{
+  {
+    512,
+    ECC_LIMB_SIZE,
+    ECC_BMODP_SIZE,
+    ECC_REDC_SIZE,
+    ECC_MOD_INV_ITCH (ECC_LIMB_SIZE),
+    0,
+
+    ecc_p,
+    ecc_Bmodp,
+    ecc_Bmodp_shifted,
+    ecc_redc_ppm1,
+
+    ecc_pp1h,
+    ecc_512_modp,
+    USE_REDC ? ecc_512_redc : ecc_512_modp,
+    ecc_mod_inv,
+    NULL,
+  },
+  {
+    512,
+    ECC_LIMB_SIZE,
+    ECC_BMODQ_SIZE,
+    0,
+    ECC_MOD_INV_ITCH (ECC_LIMB_SIZE),
+    0,
+
+    ecc_q,
+    ecc_Bmodq,
+    ecc_Bmodq_shifted,
+    NULL,
+    ecc_qp1h,
+
+    ecc_512_modq,
+    ecc_512_modq,
+    ecc_mod_inv,
+    NULL,
+  },
+
+  USE_REDC,
+  ECC_PIPPENGER_K,
+  ECC_PIPPENGER_C,
+
+  ECC_ADD_JJJ_ITCH (ECC_LIMB_SIZE),
+  ECC_MUL_A_ITCH (ECC_LIMB_SIZE),
+  ECC_MUL_G_ITCH (ECC_LIMB_SIZE),
+  ECC_J_TO_A_ITCH (ECC_LIMB_SIZE),
+
+  ecc_add_jjj,
+  ecc_mul_a,
+  ecc_mul_g,
+  ecc_j_to_a,
+
+  ecc_b,
+  ecc_g,
+  NULL,
+  ecc_unit,
+  ecc_table
+};
+
+const struct ecc_curve *nettle_get_gc_512b(void)
+{
+  return &amp;_nettle_gc_512b;
+}
diff --git a/ecc-internal.h b/ecc-internal.h
index 94fc218b1809..8509c717ad3a 100644
--- a/ecc-internal.h
+++ b/ecc-internal.h
@@ -85,6 +85,13 @@ extern const struct ecc_curve _nettle_secp_521r1;
    general ecc operations over an arbitrary type of curve. */
 extern const struct ecc_curve _nettle_curve25519;
 
+/* GOST curves, visible with underscore prefix for now */
+extern const struct ecc_curve _nettle_gc_256b;
+extern const struct ecc_curve _nettle_gc_256c;
+extern const struct ecc_curve _nettle_gc_256d;
+extern const struct ecc_curve _nettle_gc_512a;
+extern const struct ecc_curve _nettle_gc_512b;
+
 #define ECC_MAX_SIZE ((521 + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS)
 
 /* Window size for ecc_mul_a. Using 4 bits seems like a good choice,
diff --git a/eccdata.c b/eccdata.c
index 12b2455d4058..cbb187d1a2fa 100644
--- a/eccdata.c
+++ b/eccdata.c
@@ -605,6 +605,163 @@ ecc_curve_init (struct ecc_curve *ecc, const char *curve)
 		   "fe1805dfcd5d2a230fee85e4550013ef",
 		   "75af5bf4ebdc75c8fe26873427d275d7"
 		   "3c0fb13da361077a565539f46de1c30");
+
+    }
+  else if (!strcmp (curve, "gc256b"))
+    {
+      ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
+					"ffffffffffffffffffffffffffffffff"
+					"fffffffffffffffffffffffffffffd97",
+
+					"00000000000000000000000000000000"
+					"000000000000000000000000000000a6",
+
+					"ffffffffffffffffffffffffffffffff"
+					"6c611070995ad10045841b09b761b893",
+
+					"00000000000000000000000000000000"
+					"00000000000000000000000000000001",
+
+					"8d91e471e0989cda27df505a453f2b76"
+					"35294f2ddf23e3b122acc99c9e9f1e14",
+					NULL, NULL);
+
+      ecc-&gt;ref = ecc_alloc (3);
+      ecc_set_str (&amp;ecc-&gt;ref[0], /* 2 g */
+		   "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd95",
+		   "726e1b8e1f676325d820afa5bac0d489cad6b0d220dc1c4edd5336636160df83");
+
+      ecc_set_str (&amp;ecc-&gt;ref[1], /* 3 g */
+		   "8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38d2c",
+		   "76bcd1ca9a23b041d4d9baf507a6cd821267a94c838768e8486117796b788a51");
+
+      ecc_set_str (&amp;ecc-&gt;ref[2], /* 4 g */
+		   "f7063e7063e7063e7063e7063e7063e7063e7063e7063e7063e7063e7063e4b7",
+		   "83ccf17ba6706d73625cc3534c7a2b9d6ec1ee6a9a7e07c10d84b388de59f741");
+
+    }
+  else if (!strcmp (curve, "gc256c"))
+    {
+      ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
+					"80000000000000000000000000000000"
+					"00000000000000000000000000000c99",
+
+					"3e1af419a269a5f866a7d3c25c3df80a"
+					"e979259373ff2b182f49d4ce7e1bbc8b",
+
+					"80000000000000000000000000000001"
+					"5f700cfff1a624e5e497161bcc8a198f",
+
+					"00000000000000000000000000000000"
+					"00000000000000000000000000000001",
+
+					"3fa8124359f96680b83d1c3eb2c070e5"
+					"c545c9858d03ecfb744bf8d717717efc",
+					NULL, NULL);
+
+      ecc-&gt;ref = ecc_alloc (3);
+      ecc_set_str (&amp;ecc-&gt;ref[0], /* 2 g */
+		   "8000000000000000000000000000000000000000000000000000000000000c97",
+		   "4057edbca606997f47c2e3c14d3f8f1a3aba367a72fc13048bb40728e88e8d9d");
+
+      ecc_set_str (&amp;ecc-&gt;ref[1], /* 3 g */
+		   "1b9a33999d8449c3bbd8cfe49ac6355a2ee0827a6c71687c86cb7b0670efe205",
+		   "1876d998a19da37a120e76cb42f4f5225197279b612f712171a4648fe4a3ff12");
+
+      ecc_set_str (&amp;ecc-&gt;ref[2], /* 4 g */
+		   "5fa13ecfadd7ae00c2e65d0ac6cac1deda6d60e577afe90915671b08bbb9065e",
+		   "1b3c2859166129ac6dafee570ab9d40d33fdc25c7253c72f4e3fa77223ab016a");
+
+    }
+  else if (!strcmp (curve, "gc256d"))
+    {
+      ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
+					"9b9f605f5a858107ab1ec85e6b41c8aa"
+					"cf846e86789051d37998f7b9022d759b",
+
+					"00000000000000000000000000000000"
+					"0000000000000000000000000000805a",
+
+					"9b9f605f5a858107ab1ec85e6b41c8aa"
+					"582ca3511eddfb74f02f3a6598980bb9",
+
+					"00000000000000000000000000000000"
+					"00000000000000000000000000000000",
+
+					"41ece55743711a8c3cbf3783cd08c0ee"
+					"4d4dc440d4641a8f366e550dfdb3bb67",
+					NULL, NULL);
+      ecc-&gt;ref = ecc_alloc (3);
+      ecc_set_str (&amp;ecc-&gt;ref[0], /* 2 g */
+		   "74ab1ac14e9ed5cda1af70308c897ebf3d91d913a7bf377833c436bf0f8aa40e",
+		   "7d223beab738ba52a65ffbfe585d2807bfaed5ea9cd651a63a775b4182f562e3");
+
+      ecc_set_str (&amp;ecc-&gt;ref[1], /* 3 g */
+		   "771e56689775fda0bbdeac54e9cd379f30391edf06f335269c48f06446cd037a",
+		   "8430215fbee8a09c5e38bda64b50bbef41392d6afa5ced73652c83cb5221d02b");
+
+      ecc_set_str (&amp;ecc-&gt;ref[2], /* 4 g */
+		   "4fe44356aded59b4b661e9da15fe79dbcb1d7346770919c5c99090e5ae4db8a6",
+		   "24f0222027a3d2577cca5aefb5411c88f92f5f4b8febddebc71c12180640ebfd");
+
+    }
+  else if (!strcmp (curve, "gc512a"))
+    {
+      ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
+					"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
+					"fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc7",
+					"e8c2505dedfc86ddc1bd0b2b6667f1da34b82574761cb0e879bd081cfd0b6265"
+					"ee3cb090f30d27614cb4574010da90dd862ef9d4ebee4761503190785a71c760",
+					"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
+					"27e69532f48d89116ff22b8d4e0560609b4b38abfad2b85dcacdb1411f10b275",
+					"0000000000000000000000000000000000000000000000000000000000000000"
+					"0000000000000000000000000000000000000000000000000000000000000003",
+					"7503cfe87a836ae3a61b8816e25450e6ce5e1c93acf1abc1778064fdcbefa921"
+					"df1626be4fd036e93d75e6a50e3a41e98028fe5fc235f5b889a589cb5215f2a4",
+					NULL, NULL);
+
+      ecc-&gt;ref = ecc_alloc (3);
+      ecc_set_str (&amp;ecc-&gt;ref[0], /* 2 g */
+		   "3b89dcfc622996ab97a5869dbff15cf51db00954f43a58a5e5f6b0470a132b2f4434bbcd405d2a9516151d2a6a04f2e4375bf48de1fdb21fb982afd9d2ea137c",
 +		   "c813c4e2e2e0a8a391774c7903da7a6f14686e98e183e670ee6fb784809a3e92ca209dc631d85b1c7534ed3b37fddf64d854d7e01f91f18bb3fd307591afc051");
 +
+      ecc_set_str (&amp;ecc-&gt;ref[1], /* 3 g */
+		   "a1ff1ab2712a267eb53935ddb5a567f84db156cc096168a1174291d5f488fba543d2840b4d2dd35d764b2f57b308907aec55cfba10544e8416e134687ccb87c3",
 +		   "3cb5c4417ec4637f30374f189bb5b984c41e3a48d7f84fbfa3819e3f333f7eb311d3af7e67c4c16eeacfac2fe94c6dd4c6366f711a4fb6c7125cd7ec518d90d6");
 +
+      ecc_set_str (&amp;ecc-&gt;ref[2], /* 4 g */
+		   "b7bfb80956c8670031ba191929f64e301d681634236d47a60e571a4bedc0ef257452ef78b5b98dbb3d9f3129d9349433ce2a3a35cb519c91e2d633d7b373ae16",
 +		   "3bee95e29eecc5d5ad2beba941abcbf9f1cad478df0fecf614f63aeebef77850da7efdb93de8f3df80bc25eac09239c14175f5c29704ce9a3e383f1b3ec0e929");
 +
+    }
+  else if (!strcmp (curve, "gc512b"))
+    {
+      ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
+					"8000000000000000000000000000000000000000000000000000000000000000"
+					"000000000000000000000000000000000000000000000000000000000000006f",
+					"687d1b459dc841457e3e06cf6f5e2517b97c7d614af138bcbf85dc806c4b289f"
+					"3e965d2db1416d217f8b276fad1ab69c50f78bee1fa3106efb8ccbc7c5140116",
+					"8000000000000000000000000000000000000000000000000000000000000001"
+					"49a1ec142565a545acfdb77bd9d40cfa8b996712101bea0ec6346c54374f25bd",
+					"0000000000000000000000000000000000000000000000000000000000000000"
+					"0000000000000000000000000000000000000000000000000000000000000002",
+					"1a8f7eda389b094c2c071e3647a8940f3c123b697578c213be6dd9e6c8ec7335"
+					"dcb228fd1edf4a39152cbcaaf8c0398828041055f94ceeec7e21340780fe41bd",
+					NULL, NULL);
+
+      ecc-&gt;ref = ecc_alloc (3);
+      ecc_set_str (&amp;ecc-&gt;ref[0], /* 2 g */
+		   "73729fb3c0d629ae5dc9bf88ca05d518bce91e502150f5e5822fa0293bc0e3ca31145f3b0e1831d8bb1f20b28780011473339e581a403c676b47c1f9ab764602",
 +		   "35d62c90549f2c17e16c6ea99d3c3dbe610f2c543fc1d0ca5bd48a5ea1d3ec11c3cec5e7fcd74b5306e73b6a8e40c818714f02b25997ee2b54f65432d3f0741e");
 +
+      ecc_set_str (&amp;ecc-&gt;ref[1], /* 3 g */
+		   "1826b56c8dc1d5779b76354070e744f2c9c82755a921142b528f2fe04f5fd0dbdc178314c4546270b423d9fe819ba4c82625b02004bfdf90a08317dceb9309b7",
 +		   "4f6882f8f6422d693f8313bb7b121117ad9ee6b8874135f3e4bff91b01141fdb35d29bc3cf15ab8a3b751050e58392a8eeae790ea5d198eab642dc520fd1713f");
 +
+      ecc_set_str (&amp;ecc-&gt;ref[2], /* 4 g */
+		   "5af069b1624dba4513c303b66b90543d97dbec20b5ba013e4f43ed9e2b88bdc5ac69701b626a8a546d03d52f8510d50df944978b0d33565ab75599b0d0a18563",
 +		   "19eb28c4ee08a66894ca5cb76e160478a4f94c061b1115357557dacd5370bfc22bd1d0faa2e9d72af11ae65cb2335c53f617052331eb56050a972da4efe55eb7");
 +
     }
   else
     {
@@ -1203,7 +1360,7 @@ main (int argc, char **argv)
 
   if (argc &lt; 4)
     {
-      fprintf (stderr, "Usage: %s CURVE-BITS K C [BITS-PER-LIMB]\n", argv[0]);
+      fprintf (stderr, "Usage: %s CURVE K C [BITS-PER-LIMB]\n", argv[0]);
       return EXIT_FAILURE;
     }
 
diff --git a/examples/ecc-benchmark.c b/examples/ecc-benchmark.c
index ea0be17368fb..8d49c1a6f1d8 100644
--- a/examples/ecc-benchmark.c
+++ b/examples/ecc-benchmark.c
@@ -336,6 +336,11 @@ const struct ecc_curve * const curves[] = {
   &amp;_nettle_secp_256r1,
   &amp;_nettle_secp_384r1,
   &amp;_nettle_secp_521r1,
+  &amp;_nettle_gc_256b,
+  &amp;_nettle_gc_256c,
+  &amp;_nettle_gc_256d,
+  &amp;_nettle_gc_512a,
+  &amp;_nettle_gc_512b,
 };
 
 #define numberof(x)  (sizeof (x) / sizeof ((x)[0]))
diff --git a/testsuite/testutils.c b/testsuite/testutils.c
index 337e4c4c7cd1..dea864ac3417 100644
--- a/testsuite/testutils.c
+++ b/testsuite/testutils.c
@@ -1583,6 +1583,11 @@ const struct ecc_curve * const ecc_curves[] = {
   &amp;_nettle_secp_384r1,
   &amp;_nettle_secp_521r1,
   &amp;_nettle_curve25519,
+  &amp;_nettle_gc_256b,
+  &amp;_nettle_gc_256c,
+  &amp;_nettle_gc_256d,
+  &amp;_nettle_gc_512a,
+  &amp;_nettle_gc_512b,
   NULL
 };
 
@@ -1634,7 +1639,7 @@ void
 test_ecc_mul_a (unsigned curve, unsigned n, const mp_limb_t *p)
 {
   /* For each curve, the points 2 g, 3 g and 4 g */
-  static const struct ecc_ref_point ref[6][3] = {
+  static const struct ecc_ref_point ref[11][3] = {
     { { "dafebf5828783f2ad35534631588a3f629a70fb16982a888",
 	"dd6bda0d993da0fa46b27bbc141b868f59331afa5c7e93ab" },
       { "76e32a2557599e6edcd283201fb2b9aadfd0d359cbb263da",
@@ -1695,9 +1700,56 @@ test_ecc_mul_a (unsigned curve, unsigned n, const mp_limb_t \
*p)  "1267b1d177ee69aba126a18e60269ef79f16ec176724030402c3684878f5b4d4" },
       { "203da8db56cff1468325d4b87a3520f91a739ec193ce1547493aa657c4c9f870",
 	"47d0e827cb1595e1470eb88580d5716c4cf22832ea2f0ff0df38ab61ca32112f" },
+    },
+    { { "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd95",
+	"726e1b8e1f676325d820afa5bac0d489cad6b0d220dc1c4edd5336636160df83" },
+      { "8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38d2c",
+	"76bcd1ca9a23b041d4d9baf507a6cd821267a94c838768e8486117796b788a51" },
+      { "f7063e7063e7063e7063e7063e7063e7063e7063e7063e7063e7063e7063e4b7",
+	"83ccf17ba6706d73625cc3534c7a2b9d6ec1ee6a9a7e07c10d84b388de59f741" },
+    },
+    { { "8000000000000000000000000000000000000000000000000000000000000c97",
+	"4057edbca606997f47c2e3c14d3f8f1a3aba367a72fc13048bb40728e88e8d9d" },
+      { "1b9a33999d8449c3bbd8cfe49ac6355a2ee0827a6c71687c86cb7b0670efe205",
+	"1876d998a19da37a120e76cb42f4f5225197279b612f712171a4648fe4a3ff12" },
+      { "5fa13ecfadd7ae00c2e65d0ac6cac1deda6d60e577afe90915671b08bbb9065e",
+	"1b3c2859166129ac6dafee570ab9d40d33fdc25c7253c72f4e3fa77223ab016a" },
+    },
+    { { "74ab1ac14e9ed5cda1af70308c897ebf3d91d913a7bf377833c436bf0f8aa40e",
+	"7d223beab738ba52a65ffbfe585d2807bfaed5ea9cd651a63a775b4182f562e3" },
+      { "771e56689775fda0bbdeac54e9cd379f30391edf06f335269c48f06446cd037a",
+	"8430215fbee8a09c5e38bda64b50bbef41392d6afa5ced73652c83cb5221d02b" },
+      { "4fe44356aded59b4b661e9da15fe79dbcb1d7346770919c5c99090e5ae4db8a6",
+	"24f0222027a3d2577cca5aefb5411c88f92f5f4b8febddebc71c12180640ebfd" },
+    },
+    { { "3b89dcfc622996ab97a5869dbff15cf51db00954f43a58a5e5f6b0470a132b2f"
+	"4434bbcd405d2a9516151d2a6a04f2e4375bf48de1fdb21fb982afd9d2ea137c",
+	"c813c4e2e2e0a8a391774c7903da7a6f14686e98e183e670ee6fb784809a3e92"
+	"ca209dc631d85b1c7534ed3b37fddf64d854d7e01f91f18bb3fd307591afc051" },
+      { "a1ff1ab2712a267eb53935ddb5a567f84db156cc096168a1174291d5f488fba5"
+	"43d2840b4d2dd35d764b2f57b308907aec55cfba10544e8416e134687ccb87c3",
+	"3cb5c4417ec4637f30374f189bb5b984c41e3a48d7f84fbfa3819e3f333f7eb3"
+	"11d3af7e67c4c16eeacfac2fe94c6dd4c6366f711a4fb6c7125cd7ec518d90d6" },
+      { "b7bfb80956c8670031ba191929f64e301d681634236d47a60e571a4bedc0ef25"
+	"7452ef78b5b98dbb3d9f3129d9349433ce2a3a35cb519c91e2d633d7b373ae16",
+	"3bee95e29eecc5d5ad2beba941abcbf9f1cad478df0fecf614f63aeebef77850"
+	"da7efdb93de8f3df80bc25eac09239c14175f5c29704ce9a3e383f1b3ec0e929" },
+    },
+    { { "73729fb3c0d629ae5dc9bf88ca05d518bce91e502150f5e5822fa0293bc0e3ca"
+	"31145f3b0e1831d8bb1f20b28780011473339e581a403c676b47c1f9ab764602",
+	"35d62c90549f2c17e16c6ea99d3c3dbe610f2c543fc1d0ca5bd48a5ea1d3ec11"
+	"c3cec5e7fcd74b5306e73b6a8e40c818714f02b25997ee2b54f65432d3f0741e" },
+      { "1826b56c8dc1d5779b76354070e744f2c9c82755a921142b528f2fe04f5fd0db"
+	"dc178314c4546270b423d9fe819ba4c82625b02004bfdf90a08317dceb9309b7",
+	"4f6882f8f6422d693f8313bb7b121117ad9ee6b8874135f3e4bff91b01141fdb"
+	"35d29bc3cf15ab8a3b751050e58392a8eeae790ea5d198eab642dc520fd1713f" },
+      { "5af069b1624dba4513c303b66b90543d97dbec20b5ba013e4f43ed9e2b88bdc5"
+	"ac69701b626a8a546d03d52f8510d50df944978b0d33565ab75599b0d0a18563",
+	"19eb28c4ee08a66894ca5cb76e160478a4f94c061b1115357557dacd5370bfc2"
+	"2bd1d0faa2e9d72af11ae65cb2335c53f617052331eb56050a972da4efe55eb7" },
     }
   };
-  assert (curve &lt; 6);
+  assert (curve &lt; 11);
   assert (n &lt;= 4);
   if (n == 0)
     {
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190511135701</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-11 13:57:01-0400</timestampReceived><subject>Re: curve448 branch</subject><body>

Hello,

сб, 11 мая 2019 г. в 11:09, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; Niels, Daiki, do you have plans to update/merge curve448 branch?
&gt; &gt; I'd benefit from generalized Edwards curves support, which is part of
&gt; &gt; that branch.
&gt;
&gt; My plan was to merge it after the 3.5 release, in order to (i) to be able to do it
&gt; without another abi breakage (in 3.4.x, the ecc curve symbols are exposed
&gt; directly, and then changing the size of those structs breaks linking in
&gt; some cases, due to copy relocations), and (ii) not delay 3.5 further.

I see.

&gt; And now 3.5 is severely delayed compared to what I had hoped for. Not
&gt; sure if re-plan is needed, or if I ought to focus on getting 3.5 out
&gt; asap.

Is there anything that we can do to help with 3.5?
I'm still playing around HMAC/digest refactoring, but I'm not happy with the
way code looks in my tree.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190511182742</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2019-05-11 18:27:42-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

I prefer the second option because I think the zero nonce variant requires a disproportionate, to its usefullness and use, discussion to define the "right" semantics.


On May 11, 2019 7:49:31 AM UTC, nisse@lysator.liu.se wrote:
&gt;Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt;
&gt;&gt; Thanks. If you added the zero-nonce method, maybe it would be better
&gt;&gt; to add test vectors for it as well. I'm copying from my last patch
&gt;&gt; with it:
&gt;
&gt;I was about to add the miscreant.js examples (and with nettle's output,
&gt;which is different), to illustrate interop issue. Unfortunately, the
&gt;RFC
&gt;5297 testvectors appear useless if one wants to test the RFC 5116 mode
&gt;of operation.
&gt;
&gt;And on second thought, maybe it makes more sense to change nettle to be
&gt;interoperable with miscreant here? I think that's how you did it
&gt;originally, and I found it confusing. RFC 5297 (SIV mode) says that for
&gt;use according to RFC5116 (AEAD interface), N_MIN = 1.
&gt;
&gt;Another option, which you've also tried, is to to require non-empty
&gt;nonce, i.e., add back the assert (nlength &gt; 0), and define
&gt;SIV_MIN_NONCE_SIZE as one, not zero. That's perhaps the most
&gt;conservative approach: support for empty nonce, however that should
&gt;behave, can be added later.
&gt;
&gt;Opinions? 
&gt;
&gt;Regards,
&gt;/Niels

-- 
Sent from my mobile. Please excuse my brevity.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190512040523</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2019-05-12 04:05:23-0400</timestampReceived><subject>Re: Release? (was: Re: curve448 branch)</subject><body>

I know of one or two applications that moved to nettle once the des functionality was removed from libcrypt. Not sure if that's a good reason to keep it, they are deprecated, but removing it may make it slower to move to that version.

On May 11, 2019 7:40:34 PM UTC, nisse@lysator.liu.se wrote:
&gt;Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt;&gt; Is there anything that we can do to help with 3.5?
&gt;
&gt;I've just updated the NEWS file, please review. Since it's an ABI
&gt;break,
&gt;maybe a few more things could be deleted. 
&gt;
&gt;* Can we delete _rsa_blind/_rsa_unblind (currently demoted from rsa.h
&gt;to
&gt;  rsa-internal.h, and with internal symbol names).
&gt;
&gt;* dsa-compat.h (compatibility with Nettle older than 3.0)?
&gt;
&gt;* des-compat.h (compatibility with old libdes/openssl)? Also mentioned
&gt;  as a candidate for deletion when Nettle-3.0 was released.
&gt;
&gt;&gt; I'm still playing around HMAC/digest refactoring, but I'm not happy
&gt;with the
&gt;&gt; way code looks in my tree.
&gt;
&gt;I've committed changes to move buffers last in the hash context
&gt;structs.
&gt;That should make it a bit easier, but probably still not so pretty.
&gt;
&gt;Regards,
&gt;/Niels
&gt;
&gt;-- 
&gt;Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
&gt;Internet email is subject to wholesale government surveillance.
&gt;_______________________________________________
&gt;nettle-bugs mailing list
&gt;nettle-bugs@lists.lysator.liu.se
&gt;http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

-- 
Sent from my mobile. Please excuse my brevity.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190512112856</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-12 11:28:56-0400</timestampReceived><subject>Re: [PATCH 1/3] Move MAC testing code to generic place from cmac-test</subject><body>

ср, 8 мая 2019 г. в 15:33, Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;:
&gt; Any chances to get these 3 patches in?

Just as a word of justification: one of GOST-defined modes is CFB, which is used
with 64-bit cipher (Magma, GOST 28147-89). Having this code in allows us to use
it directly from Nettle instead of having a private copy (e.g. in
GnuTLS). And while
3DES is obviously close to full deprecation, 3DES-CFB8 is a good way to define
and test CFB8 support in Nettle library.

&gt;
&gt; чт, 1 нояб. 2018 г. в 13:28, Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;:
&gt; &gt;
&gt; &gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt; &gt; ---
&gt; &gt;  testsuite/cmac-test.c | 100 +++++++++++-------------------------------
&gt; &gt;  testsuite/testutils.c |  64 +++++++++++++++++++++++++++
&gt; &gt;  testsuite/testutils.h |   6 +++
&gt; &gt;  3 files changed, 96 insertions(+), 74 deletions(-)
&gt; &gt;
&gt; &gt; diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
&gt; &gt; index 31662d1b6c1b..b1d4aa30dfbe 100644
&gt; &gt; --- a/testsuite/cmac-test.c
&gt; &gt; +++ b/testsuite/cmac-test.c
&gt; &gt; @@ -2,83 +2,35 @@
&gt; &gt;  #include "nettle-internal.h"
&gt; &gt;  #include "cmac.h"
&gt; &gt;
&gt; &gt; +const struct nettle_mac nettle_cmac_aes128 =
&gt; &gt; +{
&gt; &gt; +  "CMAC-AES128",
&gt; &gt; +  sizeof(struct cmac_aes128_ctx),
&gt; &gt; +  CMAC128_DIGEST_SIZE,
&gt; &gt; +  AES128_KEY_SIZE,
&gt; &gt; +
&gt; &gt; +  (nettle_set_key_func*) cmac_aes128_set_key,
&gt; &gt; +  (nettle_hash_update_func*) cmac_aes128_update,
&gt; &gt; +  (nettle_hash_digest_func*) cmac_aes128_digest
&gt; &gt; +};
&gt; &gt; +
&gt; &gt; +const struct nettle_mac nettle_cmac_aes256 =
&gt; &gt; +{
&gt; &gt; +  "CMAC-AES256",
&gt; &gt; +  sizeof(struct cmac_aes256_ctx),
&gt; &gt; +  CMAC128_DIGEST_SIZE,
&gt; &gt; +  AES256_KEY_SIZE,
&gt; &gt; +
&gt; &gt; +  (nettle_set_key_func*) cmac_aes256_set_key,
&gt; &gt; +  (nettle_hash_update_func*) cmac_aes256_update,
&gt; &gt; +  (nettle_hash_digest_func*) cmac_aes256_digest
&gt; &gt; +};
&gt; &gt; +
&gt; &gt;  #define test_cmac_aes128(key, msg, ref)                                        \
&gt; &gt; -  test_cmac_hash ((nettle_set_key_func*) cmac_aes128_set_key,          \
&gt; &gt; -                 (nettle_hash_update_func*) cmac_aes128_update,        \
&gt; &gt; -                 (nettle_hash_digest_func*) cmac_aes128_digest,        \
&gt; &gt; -                 sizeof(struct cmac_aes128_ctx),                       \
&gt; &gt; -                 key, msg, ref)
&gt; &gt; +  test_mac(&amp;nettle_cmac_aes128, key, msg, ref)
&gt; &gt;
&gt; &gt;  #define test_cmac_aes256(key, msg, ref)                                        \
&gt; &gt; -  test_cmac_hash ((nettle_set_key_func*) cmac_aes256_set_key,          \
&gt; &gt; -                 (nettle_hash_update_func*) cmac_aes256_update,        \
&gt; &gt; -                 (nettle_hash_digest_func*) cmac_aes256_digest,        \
&gt; &gt; -                 sizeof(struct cmac_aes256_ctx),                       \
&gt; &gt; -                 key, msg, ref)
&gt; &gt; -
&gt; &gt; -static void
&gt; &gt; -test_cmac_hash (nettle_set_key_func *set_key,
&gt; &gt; -               nettle_hash_update_func *update,
&gt; &gt; -               nettle_hash_digest_func *digest, size_t ctx_size,
&gt; &gt; -               const struct tstring *key, const struct tstring *msg,
&gt; &gt; -               const struct tstring *ref)
&gt; &gt; -{
&gt; &gt; -  void *ctx;
&gt; &gt; -  uint8_t hash[16];
&gt; &gt; -  unsigned i;
&gt; &gt; -
&gt; &gt; -  ctx = xalloc(ctx_size);
&gt; &gt; -
&gt; &gt; -  ASSERT (ref-&gt;length == sizeof(hash));
&gt; &gt; -  ASSERT (key-&gt;length == 16 || key-&gt;length == 32);
&gt; &gt; -  set_key (ctx, key-&gt;data);
&gt; &gt; -  update (ctx, msg-&gt;length, msg-&gt;data);
&gt; &gt; -  digest (ctx, sizeof(hash), hash);
&gt; &gt; -  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
&gt; &gt; -    {
&gt; &gt; -      fprintf (stderr, "cmac_hash failed, msg: ");
&gt; &gt; -      print_hex (msg-&gt;length, msg-&gt;data);
&gt; &gt; -      fprintf(stderr, "Output:");
&gt; &gt; -      print_hex (16, hash);
&gt; &gt; -      fprintf(stderr, "Expected:");
&gt; &gt; -      tstring_print_hex(ref);
&gt; &gt; -      fprintf(stderr, "\n");
&gt; &gt; -      FAIL();
&gt; &gt; -    }
&gt; &gt; -
&gt; &gt; -  /* attempt to re-use the structure */
&gt; &gt; -  update (ctx, msg-&gt;length, msg-&gt;data);
&gt; &gt; -  digest (ctx, sizeof(hash), hash);
&gt; &gt; -  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
&gt; &gt; -    {
&gt; &gt; -      fprintf (stderr, "cmac_hash failed on re-use, msg: ");
&gt; &gt; -      print_hex (msg-&gt;length, msg-&gt;data);
&gt; &gt; -      fprintf(stderr, "Output:");
&gt; &gt; -      print_hex (16, hash);
&gt; &gt; -      fprintf(stderr, "Expected:");
&gt; &gt; -      tstring_print_hex(ref);
&gt; &gt; -      fprintf(stderr, "\n");
&gt; &gt; -      FAIL();
&gt; &gt; -    }
&gt; &gt; -
&gt; &gt; -  /* attempt byte-by-byte hashing */
&gt; &gt; -  set_key (ctx, key-&gt;data);
&gt; &gt; -  for (i=0;i&lt;msg-&gt;length;i++)
&gt; &gt; -    update (ctx, 1, msg-&gt;data+i);
&gt; &gt; -  digest (ctx, sizeof(hash), hash);
&gt; &gt; -  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
&gt; &gt; -    {
&gt; &gt; -      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
&gt; &gt; -      print_hex (msg-&gt;length, msg-&gt;data);
&gt; &gt; -      fprintf(stderr, "Output:");
&gt; &gt; -      print_hex (16, hash);
&gt; &gt; -      fprintf(stderr, "Expected:");
&gt; &gt; -      tstring_print_hex(ref);
&gt; &gt; -      fprintf(stderr, "\n");
&gt; &gt; -      FAIL();
&gt; &gt; -    }
&gt; &gt; -  free (ctx);
&gt; &gt; -}
&gt; &gt; +  test_mac(&amp;nettle_cmac_aes256, key, msg, ref)
&gt; &gt;
&gt; &gt;  void
&gt; &gt;  test_main(void)
&gt; &gt; diff --git a/testsuite/testutils.c b/testsuite/testutils.c
&gt; &gt; index 1812ff4f52b0..ba0b41131925 100644
&gt; &gt; --- a/testsuite/testutils.c
&gt; &gt; +++ b/testsuite/testutils.c
&gt; &gt; @@ -924,6 +924,70 @@ test_hash_large(const struct nettle_hash *hash,
&gt; &gt;    free(data);
&gt; &gt;  }
&gt; &gt;
&gt; &gt; +void
&gt; &gt; +test_mac(const struct nettle_mac *mac,
&gt; &gt; +        const struct tstring *key,
&gt; &gt; +        const struct tstring *msg,
&gt; &gt; +        const struct tstring *digest)
&gt; &gt; +{
&gt; &gt; +  void *ctx = xalloc(mac-&gt;context_size);
&gt; &gt; +  uint8_t *hash = xalloc(mac-&gt;digest_size);
&gt; &gt; +  unsigned i;
&gt; &gt; +
&gt; &gt; +
&gt; &gt; +  ASSERT (digest-&gt;length == mac-&gt;digest_size);
&gt; &gt; +  ASSERT (key-&gt;length == mac-&gt;key_size);
&gt; &gt; +  mac-&gt;set_key (ctx, key-&gt;data);
&gt; &gt; +  mac-&gt;update (ctx, msg-&gt;length, msg-&gt;data);
&gt; &gt; +  mac-&gt;digest (ctx, digest-&gt;length, hash);
&gt; &gt; +
&gt; &gt; +  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
&gt; &gt; +    {
&gt; &gt; +      fprintf (stderr, "test_mac failed, msg: ");
&gt; &gt; +      print_hex (msg-&gt;length, msg-&gt;data);
&gt; &gt; +      fprintf(stderr, "Output:");
&gt; &gt; +      print_hex (mac-&gt;digest_size, hash);
&gt; &gt; +      fprintf(stderr, "Expected:");
&gt; &gt; +      tstring_print_hex(digest);
&gt; &gt; +      fprintf(stderr, "\n");
&gt; &gt; +      FAIL();
&gt; &gt; +    }
&gt; &gt; +
&gt; &gt; +  /* attempt to re-use the structure */
&gt; &gt; +  mac-&gt;update (ctx, msg-&gt;length, msg-&gt;data);
&gt; &gt; +  mac-&gt;digest (ctx, digest-&gt;length, hash);
&gt; &gt; +  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
&gt; &gt; +    {
&gt; &gt; +      fprintf (stderr, "test_mac: failed on re-use, msg: ");
&gt; &gt; +      print_hex (msg-&gt;length, msg-&gt;data);
&gt; &gt; +      fprintf(stderr, "Output:");
&gt; &gt; +      print_hex (mac-&gt;digest_size, hash);
&gt; &gt; +      fprintf(stderr, "Expected:");
&gt; &gt; +      tstring_print_hex(digest);
&gt; &gt; +      fprintf(stderr, "\n");
&gt; &gt; +      FAIL();
&gt; &gt; +    }
&gt; &gt; +
&gt; &gt; +  /* attempt byte-by-byte hashing */
&gt; &gt; +  mac-&gt;set_key (ctx, key-&gt;data);
&gt; &gt; +  for (i=0;i&lt;msg-&gt;length;i++)
&gt; &gt; +    mac-&gt;update (ctx, 1, msg-&gt;data+i);
&gt; &gt; +  mac-&gt;digest (ctx, digest-&gt;length, hash);
&gt; &gt; +  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
&gt; &gt; +    {
&gt; &gt; +      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
&gt; &gt; +      print_hex (msg-&gt;length, msg-&gt;data);
&gt; &gt; +      fprintf(stderr, "Output:");
&gt; &gt; +      print_hex (16, hash);
&gt; &gt; +      fprintf(stderr, "Expected:");
&gt; &gt; +      tstring_print_hex(digest);
&gt; &gt; +      fprintf(stderr, "\n");
&gt; &gt; +      FAIL();
&gt; &gt; +    }
&gt; &gt; +  free (ctx);
&gt; &gt; +  free (hash);
&gt; &gt; +}
&gt; &gt; +
&gt; &gt;  void
&gt; &gt;  test_armor(const struct nettle_armor *armor,
&gt; &gt;             size_t data_length,
&gt; &gt; diff --git a/testsuite/testutils.h b/testsuite/testutils.h
&gt; &gt; index ded57db6ab4f..f4ea38da9deb 100644
&gt; &gt; --- a/testsuite/testutils.h
&gt; &gt; +++ b/testsuite/testutils.h
&gt; &gt; @@ -170,6 +170,12 @@ test_hash_large(const struct nettle_hash *hash,
&gt; &gt;                 uint8_t c,
&gt; &gt;                 const struct tstring *digest);
&gt; &gt;
&gt; &gt; +void
&gt; &gt; +test_mac(const struct nettle_mac *mac,
&gt; &gt; +        const struct tstring *key,
&gt; &gt; +        const struct tstring *msg,
&gt; &gt; +        const struct tstring *digest);
&gt; &gt; +
&gt; &gt;  void
&gt; &gt;  test_armor(const struct nettle_armor *armor,
&gt; &gt;             size_t data_length,
&gt; &gt; --
&gt; &gt; 2.19.1
&gt; &gt;
&gt;
&gt;
&gt; --
&gt; With best wishes
&gt; Dmitry



-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190512121547</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-12 12:15:47-0400</timestampReceived><subject>[PATCH 0/2] Provide GOST R 34.11-2012 (Streebog) hash function</subject><body>

These two patches add support for Russian standard-defined Streebog
(GOST R 34.11-2012) hash functions (256 and 512 bit outputs).

-- 
With best wishes
Dmitry


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190512121548</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-12 12:15:48-0400</timestampReceived><subject>[PATCH 1/2] Implement GOST R 34.11-2012 (Streebog) hash function</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in                 |    5 +-
 examples/nettle-benchmark.c |    1 +
 hmac-streebog.c             |   73 ++
 hmac.h                      |   33 +
 nettle-meta-hashes.c        |    2 +
 nettle-meta.h               |    2 +
 nettle.texinfo              |   72 ++
 streebog-meta.c             |   44 ++
 streebog.c                  | 1334 +++++++++++++++++++++++++++++++++++
 streebog.h                  |   99 +++
 testsuite/.gitignore        |    1 +
 testsuite/.test-rules.make  |    3 +
 testsuite/Makefile.in       |    1 +
 testsuite/hmac-test.c       |   17 +
 testsuite/meta-hash-test.c  |    2 +
 testsuite/pbkdf2-test.c     |   31 +-
 testsuite/streebog-test.c   |   81 +++
 17 files changed, 1798 insertions(+), 3 deletions(-)
 create mode 100644 hmac-streebog.c
 create mode 100644 streebog-meta.c
 create mode 100644 streebog.c
 create mode 100644 streebog.h
 create mode 100644 testsuite/streebog-test.c

diff --git a/Makefile.in b/Makefile.in
index 440de9f7bb59..ad777659f5c8 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -105,7 +105,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
-		 knuth-lfib.c hkdf.c \
+		 hmac-streebog.c knuth-lfib.c hkdf.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
 		 memeql-sec.c memxor.c memxor3.c \
@@ -129,6 +129,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 sha3-384.c sha3-384-meta.c sha3-512.c sha3-512-meta.c\
 		 serpent-set-key.c serpent-encrypt.c serpent-decrypt.c \
 		 serpent-meta.c \
+		 streebog.c streebog-meta.c \
 		 twofish.c twofish-meta.c \
 		 umac-nh.c umac-nh-n.c umac-l2.c umac-l3.c \
 		 umac-poly64.c umac-poly128.c umac-set-key.c \
@@ -206,7 +207,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  pbkdf2.h \
 	  pgp.h pkcs1.h pss.h pss-mgf1.h realloc.h ripemd160.h rsa.h \
 	  salsa20.h sexp.h \
-	  serpent.h sha.h sha1.h sha2.h sha3.h twofish.h \
+	  serpent.h sha.h sha1.h sha2.h sha3.h streebog.h twofish.h \
 	  umac.h yarrow.h xts.h poly1305.h
 
 INSTALL_HEADERS = $(HEADERS) version.h @IF_MINI_GMP@ mini-gmp.h
diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index 6e0f560b6bdc..53b4cdc015f2 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -918,6 +918,7 @@ main(int argc, char **argv)
       &amp;nettle_sha3_224, &amp;nettle_sha3_256,
       &amp;nettle_sha3_384, &amp;nettle_sha3_512,
       &amp;nettle_ripemd160, &amp;nettle_gosthash94,
+      &amp;nettle_streebog256, &amp;nettle_streebog512,
       NULL
     };
 
diff --git a/hmac-streebog.c b/hmac-streebog.c
new file mode 100644
index 000000000000..8298364bfca9
--- /dev/null
+++ b/hmac-streebog.c
@@ -0,0 +1,73 @@
+/* hmac-streebog.c
+
+   HMAC-Streebog message authentication code.
+
+   Copyright (C) 2016 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "hmac.h"
+
+void
+hmac_streebog512_set_key(struct hmac_streebog512_ctx *ctx,
+		    size_t key_length, const uint8_t *key)
+{
+  HMAC_SET_KEY(ctx, &amp;nettle_streebog512, key_length, key);
+}
+
+void
+hmac_streebog512_update(struct hmac_streebog512_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  streebog512_update(&amp;ctx-&gt;state, length, data);
+}
+
+void
+hmac_streebog512_digest(struct hmac_streebog512_ctx *ctx,
+		   size_t length, uint8_t *digest)
+{
+  HMAC_DIGEST(ctx, &amp;nettle_streebog512, length, digest);
+}
+
+void
+hmac_streebog256_set_key(struct hmac_streebog256_ctx *ctx,
+		    size_t key_length, const uint8_t *key)
+{
+  HMAC_SET_KEY(ctx, &amp;nettle_streebog256, key_length, key);
+}
+
+void
+hmac_streebog256_digest(struct hmac_streebog256_ctx *ctx,
+		   size_t length, uint8_t *digest)
+{
+  HMAC_DIGEST(ctx, &amp;nettle_streebog256, length, digest);
+}
diff --git a/hmac.h b/hmac.h
index 40a8e77aab6d..7a379796b23b 100644
--- a/hmac.h
+++ b/hmac.h
@@ -40,6 +40,7 @@
 #include "ripemd160.h"
 #include "sha1.h"
 #include "sha2.h"
+#include "streebog.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -68,6 +69,11 @@ extern "C" {
 #define hmac_sha512_set_key nettle_hmac_sha512_set_key
 #define hmac_sha512_update nettle_hmac_sha512_update
 #define hmac_sha512_digest nettle_hmac_sha512_digest
+#define hmac_streebog256_set_key nettle_hmac_streebog256_set_key
+#define hmac_streebog256_digest nettle_hmac_streebog256_digest
+#define hmac_streebog512_set_key nettle_hmac_streebog512_set_key
+#define hmac_streebog512_update nettle_hmac_streebog512_update
+#define hmac_streebog512_digest nettle_hmac_streebog512_digest
 
 void
 hmac_set_key(void *outer, void *inner, void *state,
@@ -203,6 +209,33 @@ void
 hmac_sha384_digest(struct hmac_sha512_ctx *ctx,
 		   size_t length, uint8_t *digest);
 
+/* hmac-streebog */
+struct hmac_streebog512_ctx HMAC_CTX(struct streebog512_ctx);
+
+void
+hmac_streebog512_set_key(struct hmac_streebog512_ctx *ctx,
+		    size_t key_length, const uint8_t *key);
+
+void
+hmac_streebog512_update(struct hmac_streebog512_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+hmac_streebog512_digest(struct hmac_streebog512_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
+#define hmac_streebog256_ctx hmac_streebog512_ctx
+
+void
+hmac_streebog256_set_key(struct hmac_streebog256_ctx *ctx,
+		    size_t key_length, const uint8_t *key);
+
+#define hmac_streebog256_update hmac_streebog512_update
+
+void
+hmac_streebog256_digest(struct hmac_streebog256_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/nettle-meta-hashes.c b/nettle-meta-hashes.c
index 37552edec5ca..f627f4861183 100644
--- a/nettle-meta-hashes.c
+++ b/nettle-meta-hashes.c
@@ -51,6 +51,8 @@ const struct nettle_hash * const _nettle_hashes[] = {
   &amp;nettle_sha3_256,
   &amp;nettle_sha3_384,
   &amp;nettle_sha3_512,
+  &amp;nettle_streebog256,
+  &amp;nettle_streebog512,
   NULL
 };
 
diff --git a/nettle-meta.h b/nettle-meta.h
index 74e50e59cd2e..f10f6d936580 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -142,6 +142,8 @@ extern const struct nettle_hash nettle_sha3_224;
 extern const struct nettle_hash nettle_sha3_256;
 extern const struct nettle_hash nettle_sha3_384;
 extern const struct nettle_hash nettle_sha3_512;
+extern const struct nettle_hash nettle_streebog256;
+extern const struct nettle_hash nettle_streebog512;
 
 struct nettle_aead
 {
diff --git a/nettle.texinfo b/nettle.texinfo
index 596c7098a810..66474ef65582 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -833,6 +833,78 @@ octets of the digest are written.
 This function also resets the context.
 @end deftypefun
 
+@subsubsection @acronym{STREEBOG512}
+
+STREEBOG512 is a member of the Streebog (GOST R 34.11-2012) family.  It outputs
+hash values of 512 bits, or 64 octets. Nettle defines STREEBOG512 in
+@file{&lt;nettle/streebog.h&gt;}.
+
+@deftp {Context struct} {struct streebog512_ctx}
+@end deftp
+
+@defvr Constant STREEBOG512_DIGEST_SIZE
+The size of a STREEBOG512 digest, i.e. 64.
+@end defvr
+
+@defvr Constant STREEBOG512_BLOCK_SIZE
+The internal block size of STREEBOG512. Useful for some special constructions,
+in particular HMAC-STREEBOG512.
+@end defvr
+
+@deftypefun void streebog512_init (struct streebog512_ctx *@var{ctx})
+Initialize the STREEBOG512 state.
+@end deftypefun
+
+@deftypefun void streebog512_update (struct streebog512_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +Hash some more data.
+@end deftypefun
+
+@deftypefun void streebog512_digest (struct streebog512_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Performs final processing and extracts the \
message digest, writing it +to @var{digest}. @var{length} may be smaller than
+@code{STREEBOG512_DIGEST_SIZE}, in which case only the first @var{length}
+octets of the digest are written.
+
+This function also resets the context in the same way as
+@code{streebog512_init}.
+@end deftypefun
+
+@subsubsection @acronym{STREEBOG256}
+
+STREEBOG256 is a variant of STREEBOG512, with a different initial state, and with
+the output truncated to 256 bits, or 32 octets. Nettle defines STREEBOG256 in
+@file{&lt;nettle/streebog.h&gt;}.
+
+@deftp {Context struct} {struct streebog256_ctx}
+@end deftp
+
+@defvr Constant STREEBOG256_DIGEST_SIZE
+The size of a STREEBOG256 digest, i.e. 32.
+@end defvr
+
+@defvr Constant STREEBOG256_BLOCK_SIZE
+The internal block size of STREEBOG256. Useful for some special constructions,
+in particular HMAC-STREEBOG256.
+@end defvr
+
+@deftypefun void streebog256_init (struct streebog256_ctx *@var{ctx})
+Initialize the STREEBOG256 state.
+@end deftypefun
+
+@deftypefun void streebog256_update (struct streebog256_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +Hash some more data.
+@end deftypefun
+
+@deftypefun void streebog256_digest (struct streebog256_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Performs final processing and extracts the \
message digest, writing it +to @var{digest}. @var{length} may be smaller than
+@code{STREEBOG256_DIGEST_SIZE}, in which case only the first @var{length}
+octets of the digest are written.
+
+This function also resets the context in the same way as
+@code{streebog256_init}.
+@end deftypefun
+
 @node Legacy hash functions, nettle_hash abstraction, Recommended hash functions, \
Hash functions  @comment  node-name,  next,  previous,  up
 @subsection Legacy hash functions
diff --git a/streebog-meta.c b/streebog-meta.c
new file mode 100644
index 000000000000..b8284d5c2b0d
--- /dev/null
+++ b/streebog-meta.c
@@ -0,0 +1,44 @@
+/* streebog-meta.c
+
+   Copyright (C) 2012 Nikos Mavrogiannopoulos, Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "streebog.h"
+
+const struct nettle_hash nettle_streebog512
+= _NETTLE_HASH(streebog512, STREEBOG512);
+
+const struct nettle_hash nettle_streebog256
+= _NETTLE_HASH(streebog256, STREEBOG256);
diff --git a/streebog.c b/streebog.c
new file mode 100644
index 000000000000..fe8f9359d238
--- /dev/null
+++ b/streebog.c
@@ -0,0 +1,1334 @@
+/* streebog.c - GOST R 34.11-2012 (Streebog) hash function
+
+   Copyright (C) 2013-2015 Dmitry Eremin-Solenikov
+
+   Based on my code in libgcrypt.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "streebog.h"
+
+#include "macros.h"
+#include "nettle-write.h"
+
+
+/* Pre-computed results of multiplication of bytes on A and reordered with
+   Pi[]. */
+static const uint64_t streebog_table[8][256] =
+{
+  /* 0 */
+  { 0xd01f715b5c7ef8e6ULL, 0x16fa240980778325ULL,
+    0xa8a42e857ee049c8ULL, 0x6ac1068fa186465bULL,
+    0x6e417bd7a2e9320bULL, 0x665c8167a437daabULL,
+    0x7666681aa89617f6ULL, 0x4b959163700bdcf5ULL,
+    0xf14be6b78df36248ULL, 0xc585bd689a625cffULL,
+    0x9557d7fca67d82cbULL, 0x89f0b969af6dd366ULL,
+    0xb0833d48749f6c35ULL, 0xa1998c23b1ecbc7cULL,
+    0x8d70c431ac02a736ULL, 0xd6dfbc2fd0a8b69eULL,
+    0x37aeb3e551fa198bULL, 0x0b7d128a40b5cf9cULL,
+    0x5a8f2008b5780cbcULL, 0xedec882284e333e5ULL,
+    0xd25fc177d3c7c2ceULL, 0x5e0f5d50b61778ecULL,
+    0x1d873683c0c24cb9ULL, 0xad040bcbb45d208cULL,
+    0x2f89a0285b853c76ULL, 0x5732fff6791b8d58ULL,
+    0x3e9311439ef6ec3fULL, 0xc9183a809fd3c00fULL,
+    0x83adf3f5260a01eeULL, 0xa6791941f4e8ef10ULL,
+    0x103ae97d0ca1cd5dULL, 0x2ce948121dee1b4aULL,
+    0x39738421dbf2bf53ULL, 0x093da2a6cf0cf5b4ULL,
+    0xcd9847d89cbcb45fULL, 0xf9561c078b2d8ae8ULL,
+    0x9c6a755a6971777fULL, 0xbc1ebaa0712ef0c5ULL,
+    0x72e61542abf963a6ULL, 0x78bb5fde229eb12eULL,
+    0x14ba94250fceb90dULL, 0x844d6697630e5282ULL,
+    0x98ea08026a1e032fULL, 0xf06bbea144217f5cULL,
+    0xdb6263d11ccb377aULL, 0x641c314b2b8ee083ULL,
+    0x320e96ab9b4770cfULL, 0x1ee7deb986a96b85ULL,
+    0xe96cf57a878c47b5ULL, 0xfdd6615f8842feb8ULL,
+    0xc83862965601dd1bULL, 0x2ea9f83e92572162ULL,
+    0xf876441142ff97fcULL, 0xeb2c455608357d9dULL,
+    0x5612a7e0b0c9904cULL, 0x6c01cbfb2d500823ULL,
+    0x4548a6a7fa037a2dULL, 0xabc4c6bf388b6ef4ULL,
+    0xbade77d4fdf8bebdULL, 0x799b07c8eb4cac3aULL,
+    0x0c9d87e805b19cf0ULL, 0xcb588aac106afa27ULL,
+    0xea0c1d40c1e76089ULL, 0x2869354a1e816f1aULL,
+    0xff96d17307fbc490ULL, 0x9f0a9d602f1a5043ULL,
+    0x96373fc6e016a5f7ULL, 0x5292dab8b3a6e41cULL,
+    0x9b8ae0382c752413ULL, 0x4f15ec3b7364a8a5ULL,
+    0x3fb349555724f12bULL, 0xc7c50d4415db66d7ULL,
+    0x92b7429ee379d1a7ULL, 0xd37f99611a15dfdaULL,
+    0x231427c05e34a086ULL, 0xa439a96d7b51d538ULL,
+    0xb403401077f01865ULL, 0xdda2aea5901d7902ULL,
+    0x0a5d4a9c8967d288ULL, 0xc265280adf660f93ULL,
+    0x8bb0094520d4e94eULL, 0x2a29856691385532ULL,
+    0x42a833c5bf072941ULL, 0x73c64d54622b7eb2ULL,
+    0x07e095624504536cULL, 0x8a905153e906f45aULL,
+    0x6f6123c16b3b2f1fULL, 0xc6e55552dc097bc3ULL,
+    0x4468feb133d16739ULL, 0xe211e7f0c7398829ULL,
+    0xa2f96419f7879b40ULL, 0x19074bdbc3ad38e9ULL,
+    0xf4ebc3f9474e0b0cULL, 0x43886bd376d53455ULL,
+    0xd8028beb5aa01046ULL, 0x51f23282f5cdc320ULL,
+    0xe7b1c2be0d84e16dULL, 0x081dfab006dee8a0ULL,
+    0x3b33340d544b857bULL, 0x7f5bcabc679ae242ULL,
+    0x0edd37c48a08a6d8ULL, 0x81ed43d9a9b33bc6ULL,
+    0xb1a3655ebd4d7121ULL, 0x69a1eeb5e7ed6167ULL,
+    0xf6ab73d5c8f73124ULL, 0x1a67a3e185c61fd5ULL,
+    0x2dc91004d43c065eULL, 0x0240b02c8fb93a28ULL,
+    0x90f7f2b26cc0eb8fULL, 0x3cd3a16f114fd617ULL,
+    0xaae49ea9f15973e0ULL, 0x06c0cd748cd64e78ULL,
+    0xda423bc7d5192a6eULL, 0xc345701c16b41287ULL,
+    0x6d2193ede4821537ULL, 0xfcf639494190e3acULL,
+    0x7c3b228621f1c57eULL, 0xfb16ac2b0494b0c0ULL,
+    0xbf7e529a3745d7f9ULL, 0x6881b6a32e3f7c73ULL,
+    0xca78d2bad9b8e733ULL, 0xbbfe2fc2342aa3a9ULL,
+    0x0dbddffecc6381e4ULL, 0x70a6a56e2440598eULL,
+    0xe4d12a844befc651ULL, 0x8c509c2765d0ba22ULL,
+    0xee8c6018c28814d9ULL, 0x17da7c1f49a59e31ULL,
+    0x609c4c1328e194d3ULL, 0xb3e3d57232f44b09ULL,
+    0x91d7aaa4a512f69bULL, 0x0ffd6fd243dabbccULL,
+    0x50d26a943c1fde34ULL, 0x6be15e9968545b4fULL,
+    0x94778fea6faf9fdfULL, 0x2b09dd7058ea4826ULL,
+    0x677cd9716de5c7bfULL, 0x49d5214fffb2e6ddULL,
+    0x0360e83a466b273cULL, 0x1fc786af4f7b7691ULL,
+    0xa0b9d435783ea168ULL, 0xd49f0c035f118cb6ULL,
+    0x01205816c9d21d14ULL, 0xac2453dd7d8f3d98ULL,
+    0x545217cc3f70aa64ULL, 0x26b4028e9489c9c2ULL,
+    0xdec2469fd6765e3eULL, 0x04807d58036f7450ULL,
+    0xe5f17292823ddb45ULL, 0xf30b569b024a5860ULL,
+    0x62dcfc3fa758aefbULL, 0xe84cad6c4e5e5aa1ULL,
+    0xccb81fce556ea94bULL, 0x53b282ae7a74f908ULL,
+    0x1b47fbf74c1402c1ULL, 0x368eebf39828049fULL,
+    0x7afbeff2ad278b06ULL, 0xbe5e0a8cfe97caedULL,
+    0xcfd8f7f413058e77ULL, 0xf78b2bc301252c30ULL,
+    0x4d555c17fcdd928dULL, 0x5f2f05467fc565f8ULL,
+    0x24f4b2a21b30f3eaULL, 0x860dd6bbecb768aaULL,
+    0x4c750401350f8f99ULL, 0x0000000000000000ULL,
+    0xecccd0344d312ef1ULL, 0xb5231806be220571ULL,
+    0xc105c030990d28afULL, 0x653c695de25cfd97ULL,
+    0x159acc33c61ca419ULL, 0xb89ec7f872418495ULL,
+    0xa9847693b73254dcULL, 0x58cf90243ac13694ULL,
+    0x59efc832f3132b80ULL, 0x5c4fed7c39ae42c4ULL,
+    0x828dabe3efd81cfaULL, 0xd13f294d95ace5f2ULL,
+    0x7d1b7a90e823d86aULL, 0xb643f03cf849224dULL,
+    0x3df3f979d89dcb03ULL, 0x7426d836272f2ddeULL,
+    0xdfe21e891fa4432aULL, 0x3a136c1b9d99986fULL,
+    0xfa36f43dcd46add4ULL, 0xc025982650df35bbULL,
+    0x856d3e81aadc4f96ULL, 0xc4a5e57e53b041ebULL,
+    0x4708168b75ba4005ULL, 0xaf44bbe73be41aa4ULL,
+    0x971767d029c4b8e3ULL, 0xb9be9feebb939981ULL,
+    0x215497ecd18d9aaeULL, 0x316e7e91dd2c57f3ULL,
+    0xcef8afe2dad79363ULL, 0x3853dc371220a247ULL,
+    0x35ee03c9de4323a3ULL, 0xe6919aa8c456fc79ULL,
+    0xe05157dc4880b201ULL, 0x7bdbb7e464f59612ULL,
+    0x127a59518318f775ULL, 0x332ecebd52956ddbULL,
+    0x8f30741d23bb9d1eULL, 0xd922d3fd93720d52ULL,
+    0x7746300c61440ae2ULL, 0x25d4eab4d2e2eefeULL,
+    0x75068020eefd30caULL, 0x135a01474acaea61ULL,
+    0x304e268714fe4ae7ULL, 0xa519f17bb283c82cULL,
+    0xdc82f6b359cf6416ULL, 0x5baf781e7caa11a8ULL,
+    0xb2c38d64fb26561dULL, 0x34ce5bdf17913eb7ULL,
+    0x5d6fb56af07c5fd0ULL, 0x182713cd0a7f25fdULL,
+    0x9e2ac576e6c84d57ULL, 0x9aaab82ee5a73907ULL,
+    0xa3d93c0f3e558654ULL, 0x7e7b92aaae48ff56ULL,
+    0x872d8ead256575beULL, 0x41c8dbfff96c0e7dULL,
+    0x99ca5014a3cc1e3bULL, 0x40e883e930be1369ULL,
+    0x1ca76e95091051adULL, 0x4e35b42dbab6b5b1ULL,
+    0x05a0254ecabd6944ULL, 0xe1710fca8152af15ULL,
+    0xf22b0e8dcb984574ULL, 0xb763a82a319b3f59ULL,
+    0x63fca4296e8ab3efULL, 0x9d4a2d4ca0a36a6bULL,
+    0xe331bfe60eeb953dULL, 0xd5bf541596c391a2ULL,
+    0xf5cb9bef8e9c1618ULL, 0x46284e9dbc685d11ULL,
+    0x2074cffa185f87baULL, 0xbd3ee2b6b8fcedd1ULL,
+    0xae64e3f1f23607b0ULL, 0xfeb68965ce29d984ULL,
+    0x55724fdaf6a2b770ULL, 0x29496d5cd753720eULL,
+    0xa75941573d3af204ULL, 0x8e102c0bea69800aULL,
+    0x111ab16bc573d049ULL, 0xd7ffe439197aab8aULL,
+    0xefac380e0b5a09cdULL, 0x48f579593660fbc9ULL,
+    0x22347fd697e6bd92ULL, 0x61bc1405e13389c7ULL,
+    0x4ab5c975b9d9c1e1ULL, 0x80cd1bcf606126d2ULL,
+    0x7186fd78ed92449aULL, 0x93971a882aabccb3ULL,
+    0x88d0e17f66bfce72ULL, 0x27945a985d5bd4d6ULL },
+  /* 1 */
+  { 0xde553f8c05a811c8ULL, 0x1906b59631b4f565ULL,
+    0x436e70d6b1964ff7ULL, 0x36d343cb8b1e9d85ULL,
+    0x843dfacc858aab5aULL, 0xfdfc95c299bfc7f9ULL,
+    0x0f634bdea1d51fa2ULL, 0x6d458b3b76efb3cdULL,
+    0x85c3f77cf8593f80ULL, 0x3c91315fbe737cb2ULL,
+    0x2148b03366ace398ULL, 0x18f8b8264c6761bfULL,
+    0xc830c1c495c9fb0fULL, 0x981a76102086a0aaULL,
+    0xaa16012142f35760ULL, 0x35cc54060c763cf6ULL,
+    0x42907d66cc45db2dULL, 0x8203d44b965af4bcULL,
+    0x3d6f3cefc3a0e868ULL, 0xbc73ff69d292bda7ULL,
+    0x8722ed0102e20a29ULL, 0x8f8185e8cd34deb7ULL,
+    0x9b0561dda7ee01d9ULL, 0x5335a0193227fad6ULL,
+    0xc9cecc74e81a6fd5ULL, 0x54f5832e5c2431eaULL,
+    0x99e47ba05d553470ULL, 0xf7bee756acd226ceULL,
+    0x384e05a5571816fdULL, 0xd1367452a47d0e6aULL,
+    0xf29fde1c386ad85bULL, 0x320c77316275f7caULL,
+    0xd0c879e2d9ae9ab0ULL, 0xdb7406c69110ef5dULL,
+    0x45505e51a2461011ULL, 0xfc029872e46c5323ULL,
+    0xfa3cb6f5f7bc0cc5ULL, 0x031f17cd8768a173ULL,
+    0xbd8df2d9af41297dULL, 0x9d3b4f5ab43e5e3fULL,
+    0x4071671b36feee84ULL, 0x716207e7d3e3b83dULL,
+    0x48d20ff2f9283a1aULL, 0x27769eb4757cbc7eULL,
+    0x5c56ebc793f2e574ULL, 0xa48b474f9ef5dc18ULL,
+    0x52cbada94ff46e0cULL, 0x60c7da982d8199c6ULL,
+    0x0e9d466edc068b78ULL, 0x4eec2175eaf865fcULL,
+    0x550b8e9e21f7a530ULL, 0x6b7ba5bc653fec2bULL,
+    0x5eb7f1ba6949d0ddULL, 0x57ea94e3db4c9099ULL,
+    0xf640eae6d101b214ULL, 0xdd4a284182c0b0bbULL,
+    0xff1d8fbf6304f250ULL, 0xb8accb933bf9d7e8ULL,
+    0xe8867c478eb68c4dULL, 0x3f8e2692391bddc1ULL,
+    0xcb2fd60912a15a7cULL, 0xaec935dbab983d2fULL,
+    0xf55ffd2b56691367ULL, 0x80e2ce366ce1c115ULL,
+    0x179bf3f8edb27e1dULL, 0x01fe0db07dd394daULL,
+    0xda8a0b76ecc37b87ULL, 0x44ae53e1df9584cbULL,
+    0xb310b4b77347a205ULL, 0xdfab323c787b8512ULL,
+    0x3b511268d070b78eULL, 0x65e6e3d2b9396753ULL,
+    0x6864b271e2574d58ULL, 0x259784c98fc789d7ULL,
+    0x02e11a7dfabb35a9ULL, 0x8841a6dfa337158bULL,
+    0x7ade78c39b5dcdd0ULL, 0xb7cf804d9a2cc84aULL,
+    0x20b6bd831b7f7742ULL, 0x75bd331d3a88d272ULL,
+    0x418f6aab4b2d7a5eULL, 0xd9951cbb6babdaf4ULL,
+    0xb6318dfde7ff5c90ULL, 0x1f389b112264aa83ULL,
+    0x492c024284fbaec0ULL, 0xe33a0363c608f9a0ULL,
+    0x2688930408af28a4ULL, 0xc7538a1a341ce4adULL,
+    0x5da8e677ee2171aeULL, 0x8c9e92254a5c7fc4ULL,
+    0x63d8cd55aae938b5ULL, 0x29ebd8daa97a3706ULL,
+    0x959827b37be88aa1ULL, 0x1484e4356adadf6eULL,
+    0xa7945082199d7d6bULL, 0xbf6ce8a455fa1cd4ULL,
+    0x9cc542eac9edcae5ULL, 0x79c16f0e1c356ca3ULL,
+    0x89bfab6fdee48151ULL, 0xd4174d1830c5f0ffULL,
+    0x9258048415eb419dULL, 0x6139d72850520d1cULL,
+    0x6a85a80c18ec78f1ULL, 0xcd11f88e0171059aULL,
+    0xcceff53e7ca29140ULL, 0xd229639f2315af19ULL,
+    0x90b91ef9ef507434ULL, 0x5977d28d074a1be1ULL,
+    0x311360fce51d56b9ULL, 0xc093a92d5a1f2f91ULL,
+    0x1a19a25bb6dc5416ULL, 0xeb996b8a09de2d3eULL,
+    0xfee3820f1ed7668aULL, 0xd7085ad5b7ad518cULL,
+    0x7fff41890fe53345ULL, 0xec5948bd67dde602ULL,
+    0x2fd5f65dbaaa68e0ULL, 0xa5754affe32648c2ULL,
+    0xf8ddac880d07396cULL, 0x6fa491468c548664ULL,
+    0x0c7c5c1326bdbed1ULL, 0x4a33158f03930fb3ULL,
+    0x699abfc19f84d982ULL, 0xe4fa2054a80b329cULL,
+    0x6707f9af438252faULL, 0x08a368e9cfd6d49eULL,
+    0x47b1442c58fd25b8ULL, 0xbbb3dc5ebc91769bULL,
+    0x1665fe489061eac7ULL, 0x33f27a811fa66310ULL,
+    0x93a609346838d547ULL, 0x30ed6d4c98cec263ULL,
+    0x1dd9816cd8df9f2aULL, 0x94662a03063b1e7bULL,
+    0x83fdd9fbeb896066ULL, 0x7b207573e68e590aULL,
+    0x5f49fc0a149a4407ULL, 0x343259b671a5a82cULL,
+    0xfbc2bb458a6f981fULL, 0xc272b350a0a41a38ULL,
+    0x3aaf1fd8ada32354ULL, 0x6cbb868b0b3c2717ULL,
+    0xa2b569c88d2583feULL, 0xf180c9d1bf027928ULL,
+    0xaf37386bd64ba9f5ULL, 0x12bacab2790a8088ULL,
+    0x4c0d3b0810435055ULL, 0xb2eeb9070e9436dfULL,
+    0xc5b29067cea7d104ULL, 0xdcb425f1ff132461ULL,
+    0x4f122cc5972bf126ULL, 0xac282fa651230886ULL,
+    0xe7e537992f6393efULL, 0xe61b3a2952b00735ULL,
+    0x709c0a57ae302ce7ULL, 0xe02514ae416058d3ULL,
+    0xc44c9dd7b37445deULL, 0x5a68c5408022ba92ULL,
+    0x1c278cdca50c0bf0ULL, 0x6e5a9cf6f18712beULL,
+    0x86dce0b17f319ef3ULL, 0x2d34ec2040115d49ULL,
+    0x4bcd183f7e409b69ULL, 0x2815d56ad4a9a3dcULL,
+    0x24698979f2141d0dULL, 0x0000000000000000ULL,
+    0x1ec696a15fb73e59ULL, 0xd86b110b16784e2eULL,
+    0x8e7f8858b0e74a6dULL, 0x063e2e8713d05fe6ULL,
+    0xe2c40ed3bbdb6d7aULL, 0xb1f1aeca89fc97acULL,
+    0xe1db191e3cb3cc09ULL, 0x6418ee62c4eaf389ULL,
+    0xc6ad87aa49cf7077ULL, 0xd6f65765ca7ec556ULL,
+    0x9afb6c6dda3d9503ULL, 0x7ce05644888d9236ULL,
+    0x8d609f95378feb1eULL, 0x23a9aa4e9c17d631ULL,
+    0x6226c0e5d73aac6fULL, 0x56149953a69f0443ULL,
+    0xeeb852c09d66d3abULL, 0x2b0ac2a753c102afULL,
+    0x07c023376e03cb3cULL, 0x2ccae1903dc2c993ULL,
+    0xd3d76e2f5ec63bc3ULL, 0x9e2458973356ff4cULL,
+    0xa66a5d32644ee9b1ULL, 0x0a427294356de137ULL,
+    0x783f62be61e6f879ULL, 0x1344c70204d91452ULL,
+    0x5b96c8f0fdf12e48ULL, 0xa90916ecc59bf613ULL,
+    0xbe92e5142829880eULL, 0x727d102a548b194eULL,
+    0x1be7afebcb0fc0ccULL, 0x3e702b2244c8491bULL,
+    0xd5e940a84d166425ULL, 0x66f9f41f3e51c620ULL,
+    0xabe80c913f20c3baULL, 0xf07ec461c2d1edf2ULL,
+    0xf361d3ac45b94c81ULL, 0x0521394a94b8fe95ULL,
+    0xadd622162cf09c5cULL, 0xe97871f7f3651897ULL,
+    0xf4a1f09b2bba87bdULL, 0x095d6559b2054044ULL,
+    0x0bbc7f2448be75edULL, 0x2af4cf172e129675ULL,
+    0x157ae98517094bb4ULL, 0x9fda55274e856b96ULL,
+    0x914713499283e0eeULL, 0xb952c623462a4332ULL,
+    0x74433ead475b46a8ULL, 0x8b5eb112245fb4f8ULL,
+    0xa34b6478f0f61724ULL, 0x11a5dd7ffe6221fbULL,
+    0xc16da49d27ccbb4bULL, 0x76a224d0bde07301ULL,
+    0x8aa0bca2598c2022ULL, 0x4df336b86d90c48fULL,
+    0xea67663a740db9e4ULL, 0xef465f70e0b54771ULL,
+    0x39b008152acb8227ULL, 0x7d1e5bf4f55e06ecULL,
+    0x105bd0cf83b1b521ULL, 0x775c2960c033e7dbULL,
+    0x7e014c397236a79fULL, 0x811cc386113255cfULL,
+    0xeda7450d1a0e72d8ULL, 0x5889df3d7a998f3bULL,
+    0x2e2bfbedc779fc3aULL, 0xce0eef438619a4e9ULL,
+    0x372d4e7bf6cd095fULL, 0x04df34fae96b6a4fULL,
+    0xf923a13870d4adb6ULL, 0xa1aa7e050a4d228dULL,
+    0xa8f71b5cb84862c9ULL, 0xb52e9a306097fde3ULL,
+    0x0d8251a35b6e2a0bULL, 0x2257a7fee1c442ebULL,
+    0x73831d9a29588d94ULL, 0x51d4ba64c89ccf7fULL,
+    0x502ab7d4b54f5ba5ULL, 0x97793dce8153bf08ULL,
+    0xe5042de4d5d8a646ULL, 0x9687307efc802bd2ULL,
+    0xa05473b5779eb657ULL, 0xb4d097801d446939ULL,
+    0xcff0e2f3fbca3033ULL, 0xc38cbee0dd778ee2ULL,
+    0x464f499c252eb162ULL, 0xcad1dbb96f72cea6ULL,
+    0xba4dd1eec142e241ULL, 0xb00fa37af42f0376ULL },
+  /* 2 */
+  { 0xcce4cd3aa968b245ULL, 0x089d5484e80b7fafULL,
+    0x638246c1b3548304ULL, 0xd2fe0ec8c2355492ULL,
+    0xa7fbdf7ff2374eeeULL, 0x4df1600c92337a16ULL,
+    0x84e503ea523b12fbULL, 0x0790bbfd53ab0c4aULL,
+    0x198a780f38f6ea9dULL, 0x2ab30c8f55ec48cbULL,
+    0xe0f7fed6b2c49db5ULL, 0xb6ecf3f422cadbdcULL,
+    0x409c9a541358df11ULL, 0xd3ce8a56dfde3fe3ULL,
+    0xc3e9224312c8c1a0ULL, 0x0d6dfa58816ba507ULL,
+    0xddf3e1b179952777ULL, 0x04c02a42748bb1d9ULL,
+    0x94c2abff9f2decb8ULL, 0x4f91752da8f8acf4ULL,
+    0x78682befb169bf7bULL, 0xe1c77a48af2ff6c4ULL,
+    0x0c5d7ec69c80ce76ULL, 0x4cc1e4928fd81167ULL,
+    0xfeed3d24d9997b62ULL, 0x518bb6dfc3a54a23ULL,
+    0x6dbf2d26151f9b90ULL, 0xb5bc624b05ea664fULL,
+    0xe86aaa525acfe21aULL, 0x4801ced0fb53a0beULL,
+    0xc91463e6c00868edULL, 0x1027a815cd16fe43ULL,
+    0xf67069a0319204cdULL, 0xb04ccc976c8abce7ULL,
+    0xc0b9b3fc35e87c33ULL, 0xf380c77c58f2de65ULL,
+    0x50bb3241de4e2152ULL, 0xdf93f490435ef195ULL,
+    0xf1e0d25d62390887ULL, 0xaf668bfb1a3c3141ULL,
+    0xbc11b251f00a7291ULL, 0x73a5eed47e427d47ULL,
+    0x25bee3f6ee4c3b2eULL, 0x43cc0beb34786282ULL,
+    0xc824e778dde3039cULL, 0xf97d86d98a327728ULL,
+    0xf2b043e24519b514ULL, 0xe297ebf7880f4b57ULL,
+    0x3a94a49a98fab688ULL, 0x868516cb68f0c419ULL,
+    0xeffa11af0964ee50ULL, 0xa4ab4ec0d517f37dULL,
+    0xa9c6b498547c567aULL, 0x8e18424f80fbbbb6ULL,
+    0x0bcdc53bcf2bc23cULL, 0x137739aaea3643d0ULL,
+    0x2c1333ec1bac2ff0ULL, 0x8d48d3f0a7db0625ULL,
+    0x1e1ac3f26b5de6d7ULL, 0xf520f81f16b2b95eULL,
+    0x9f0f6ec450062e84ULL, 0x0130849e1deb6b71ULL,
+    0xd45e31ab8c7533a9ULL, 0x652279a2fd14e43fULL,
+    0x3209f01e70f1c927ULL, 0xbe71a770cac1a473ULL,
+    0x0e3d6be7a64b1894ULL, 0x7ec8148cff29d840ULL,
+    0xcb7476c7fac3be0fULL, 0x72956a4a63a91636ULL,
+    0x37f95ec21991138fULL, 0x9e3fea5a4ded45f5ULL,
+    0x7b38ba50964902e8ULL, 0x222e580bbde73764ULL,
+    0x61e253e0899f55e6ULL, 0xfc8d2805e352ad80ULL,
+    0x35994be3235ac56dULL, 0x09add01af5e014deULL,
+    0x5e8659a6780539c6ULL, 0xb17c48097161d796ULL,
+    0x026015213acbd6e2ULL, 0xd1ae9f77e515e901ULL,
+    0xb7dc776a3f21b0adULL, 0xaba6a1b96eb78098ULL,
+    0x9bcf4486248d9f5dULL, 0x582666c536455efdULL,
+    0xfdbdac9bfeb9c6f1ULL, 0xc47999be4163cdeaULL,
+    0x765540081722a7efULL, 0x3e548ed8ec710751ULL,
+    0x3d041f67cb51bac2ULL, 0x7958af71ac82d40aULL,
+    0x36c9da5c047a78feULL, 0xed9a048e33af38b2ULL,
+    0x26ee7249c96c86bdULL, 0x900281bdeba65d61ULL,
+    0x11172c8bd0fd9532ULL, 0xea0abf73600434f8ULL,
+    0x42fc8f75299309f3ULL, 0x34a9cf7d3eb1ae1cULL,
+    0x2b838811480723baULL, 0x5ce64c8742ceef24ULL,
+    0x1adae9b01fd6570eULL, 0x3c349bf9d6bad1b3ULL,
+    0x82453c891c7b75c0ULL, 0x97923a40b80d512bULL,
+    0x4a61dbf1c198765cULL, 0xb48ce6d518010d3eULL,
+    0xcfb45c858e480fd6ULL, 0xd933cbf30d1e96aeULL,
+    0xd70ea014ab558e3aULL, 0xc189376228031742ULL,
+    0x9262949cd16d8b83ULL, 0xeb3a3bed7def5f89ULL,
+    0x49314a4ee6b8cbcfULL, 0xdcc3652f647e4c06ULL,
+    0xda635a4c2a3e2b3dULL, 0x470c21a940f3d35bULL,
+    0x315961a157d174b4ULL, 0x6672e81dda3459acULL,
+    0x5b76f77a1165e36eULL, 0x445cb01667d36ec8ULL,
+    0xc5491d205c88a69bULL, 0x456c34887a3805b9ULL,
+    0xffddb9bac4721013ULL, 0x99af51a71e4649bfULL,
+    0xa15be01cbc7729d5ULL, 0x52db2760e485f7b0ULL,
+    0x8c78576eba306d54ULL, 0xae560f6507d75a30ULL,
+    0x95f22f6182c687c9ULL, 0x71c5fbf54489aba5ULL,
+    0xca44f259e728d57eULL, 0x88b87d2ccebbdc8dULL,
+    0xbab18d32be4a15aaULL, 0x8be8ec93e99b611eULL,
+    0x17b713e89ebdf209ULL, 0xb31c5d284baa0174ULL,
+    0xeeca9531148f8521ULL, 0xb8d198138481c348ULL,
+    0x8988f9b2d350b7fcULL, 0xb9e11c8d996aa839ULL,
+    0x5a4673e40c8e881fULL, 0x1687977683569978ULL,
+    0xbf4123eed72acf02ULL, 0x4ea1f1b3b513c785ULL,
+    0xe767452be16f91ffULL, 0x7505d1b730021a7cULL,
+    0xa59bca5ec8fc980cULL, 0xad069eda20f7e7a3ULL,
+    0x38f4b1bba231606aULL, 0x60d2d77e94743e97ULL,
+    0x9affc0183966f42cULL, 0x248e6768f3a7505fULL,
+    0xcdd449a4b483d934ULL, 0x87b59255751baf68ULL,
+    0x1bea6d2e023d3c7fULL, 0x6b1f12455b5ffcabULL,
+    0x743555292de9710dULL, 0xd8034f6d10f5fddfULL,
+    0xc6198c9f7ba81b08ULL, 0xbb8109aca3a17edbULL,
+    0xfa2d1766ad12cabbULL, 0xc729080166437079ULL,
+    0x9c5fff7b77269317ULL, 0x0000000000000000ULL,
+    0x15d706c9a47624ebULL, 0x6fdf38072fd44d72ULL,
+    0x5fb6dd3865ee52b7ULL, 0xa33bf53d86bcff37ULL,
+    0xe657c1b5fc84fa8eULL, 0xaa962527735cebe9ULL,
+    0x39c43525bfda0b1bULL, 0x204e4d2a872ce186ULL,
+    0x7a083ece8ba26999ULL, 0x554b9c9db72efbfaULL,
+    0xb22cd9b656416a05ULL, 0x96a2bedea5e63a5aULL,
+    0x802529a826b0a322ULL, 0x8115ad363b5bc853ULL,
+    0x8375b81701901eb1ULL, 0x3069e53f4a3a1fc5ULL,
+    0xbd2136cfede119e0ULL, 0x18bafc91251d81ecULL,
+    0x1d4a524d4c7d5b44ULL, 0x05f0aedc6960daa8ULL,
+    0x29e39d3072ccf558ULL, 0x70f57f6b5962c0d4ULL,
+    0x989fd53903ad22ceULL, 0xf84d024797d91c59ULL,
+    0x547b1803aac5908bULL, 0xf0d056c37fd263f6ULL,
+    0xd56eb535919e58d8ULL, 0x1c7ad6d351963035ULL,
+    0x2e7326cd2167f912ULL, 0xac361a443d1c8cd2ULL,
+    0x697f076461942a49ULL, 0x4b515f6fdc731d2dULL,
+    0x8ad8680df4700a6fULL, 0x41ac1eca0eb3b460ULL,
+    0x7d988533d80965d3ULL, 0xa8f6300649973d0bULL,
+    0x7765c4960ac9cc9eULL, 0x7ca801adc5e20ea2ULL,
+    0xdea3700e5eb59ae4ULL, 0xa06b6482a19c42a4ULL,
+    0x6a2f96db46b497daULL, 0x27def6d7d487edccULL,
+    0x463ca5375d18b82aULL, 0xa6cb5be1efdc259fULL,
+    0x53eba3fef96e9cc1ULL, 0xce84d81b93a364a7ULL,
+    0xf4107c810b59d22fULL, 0x333974806d1aa256ULL,
+    0x0f0def79bba073e5ULL, 0x231edc95a00c5c15ULL,
+    0xe437d494c64f2c6cULL, 0x91320523f64d3610ULL,
+    0x67426c83c7df32ddULL, 0x6eefbc99323f2603ULL,
+    0x9d6f7be56acdf866ULL, 0x5916e25b2bae358cULL,
+    0x7ff89012e2c2b331ULL, 0x035091bf2720bd93ULL,
+    0x561b0d22900e4669ULL, 0x28d319ae6f279e29ULL,
+    0x2f43a2533c8c9263ULL, 0xd09e1be9f8fe8270ULL,
+    0xf740ed3e2c796fbcULL, 0xdb53ded237d5404cULL,
+    0x62b2c25faebfe875ULL, 0x0afd41a5d2c0a94dULL,
+    0x6412fd3ce0ff8f4eULL, 0xe3a76f6995e42026ULL,
+    0x6c8fa9b808f4f0e1ULL, 0xc2d9a6dd0f23aad1ULL,
+    0x8f28c6d19d10d0c7ULL, 0x85d587744fd0798aULL,
+    0xa20b71a39b579446ULL, 0x684f83fa7c7f4138ULL,
+    0xe507500adba4471dULL, 0x3f640a46f19a6c20ULL,
+    0x1247bd34f7dd28a1ULL, 0x2d23b77206474481ULL,
+    0x93521002cc86e0f2ULL, 0x572b89bc8de52d18ULL,
+    0xfb1d93f8b0f9a1caULL, 0xe95a2ecc4724896bULL,
+    0x3ba420048511ddf9ULL, 0xd63e248ab6bee54bULL,
+    0x5dd6c8195f258455ULL, 0x06a03f634e40673bULL,
+    0x1f2a476c76b68da6ULL, 0x217ec9b49ac78af7ULL,
+    0xecaa80102e4453c3ULL, 0x14e78257b99d4f9aULL },
+  /* 3 */
+  { 0x20329b2cc87bba05ULL, 0x4f5eb6f86546a531ULL,
+    0xd4f44775f751b6b1ULL, 0x8266a47b850dfa8bULL,
+    0xbb986aa15a6ca985ULL, 0xc979eb08f9ae0f99ULL,
+    0x2da6f447a2375ea1ULL, 0x1e74275dcd7d8576ULL,
+    0xbc20180a800bc5f8ULL, 0xb4a2f701b2dc65beULL,
+    0xe726946f981b6d66ULL, 0x48e6c453bf21c94cULL,
+    0x42cad9930f0a4195ULL, 0xefa47b64aacccd20ULL,
+    0x71180a8960409a42ULL, 0x8bb3329bf6a44e0cULL,
+    0xd34c35de2d36daccULL, 0xa92f5b7cbc23dc96ULL,
+    0xb31a85aa68bb09c3ULL, 0x13e04836a73161d2ULL,
+    0xb24dfc4129c51d02ULL, 0x8ae44b70b7da5acdULL,
+    0xe671ed84d96579a7ULL, 0xa4bb3417d66f3832ULL,
+    0x4572ab38d56d2de8ULL, 0xb1b47761ea47215cULL,
+    0xe81c09cf70aba15dULL, 0xffbdb872ce7f90acULL,
+    0xa8782297fd5dc857ULL, 0x0d946f6b6a4ce4a4ULL,
+    0xe4df1f4f5b995138ULL, 0x9ebc71edca8c5762ULL,
+    0x0a2c1dc0b02b88d9ULL, 0x3b503c115d9d7b91ULL,
+    0xc64376a8111ec3a2ULL, 0xcec199a323c963e4ULL,
+    0xdc76a87ec58616f7ULL, 0x09d596e073a9b487ULL,
+    0x14583a9d7d560dafULL, 0xf4c6dc593f2a0cb4ULL,
+    0xdd21d19584f80236ULL, 0x4a4836983ddde1d3ULL,
+    0xe58866a41ae745f9ULL, 0xf591a5b27e541875ULL,
+    0x891dc05074586693ULL, 0x5b068c651810a89eULL,
+    0xa30346bc0c08544fULL, 0x3dbf3751c684032dULL,
+    0x2a1e86ec785032dcULL, 0xf73f5779fca830eaULL,
+    0xb60c05ca30204d21ULL, 0x0cc316802b32f065ULL,
+    0x8770241bdd96be69ULL, 0xb861e18199ee95dbULL,
+    0xf805cad91418fcd1ULL, 0x29e70dccbbd20e82ULL,
+    0xc7140f435060d763ULL, 0x0f3a9da0e8b0cc3bULL,
+    0xa2543f574d76408eULL, 0xbd7761e1c175d139ULL,
+    0x4b1f4f737ca3f512ULL, 0x6dc2df1f2fc137abULL,
+    0xf1d05c3967b14856ULL, 0xa742bf3715ed046cULL,
+    0x654030141d1697edULL, 0x07b872abda676c7dULL,
+    0x3ce84eba87fa17ecULL, 0xc1fb0403cb79afdfULL,
+    0x3e46bc7105063f73ULL, 0x278ae987121cd678ULL,
+    0xa1adb4778ef47cd0ULL, 0x26dd906c5362c2b9ULL,
+    0x05168060589b44e2ULL, 0xfbfc41f9d79ac08fULL,
+    0x0e6de44ba9ced8faULL, 0x9feb08068bf243a3ULL,
+    0x7b341749d06b129bULL, 0x229c69e74a87929aULL,
+    0xe09ee6c4427c011bULL, 0x5692e30e725c4c3aULL,
+    0xda99a33e5e9f6e4bULL, 0x353dd85af453a36bULL,
+    0x25241b4c90e0fee7ULL, 0x5de987258309d022ULL,
+    0xe230140fc0802984ULL, 0x93281e86a0c0b3c6ULL,
+    0xf229d719a4337408ULL, 0x6f6c2dd4ad3d1f34ULL,
+    0x8ea5b2fbae3f0aeeULL, 0x8331dd90c473ee4aULL,
+    0x346aa1b1b52db7aaULL, 0xdf8f235e06042aa9ULL,
+    0xcc6f6b68a1354b7bULL, 0x6c95a6f46ebf236aULL,
+    0x52d31a856bb91c19ULL, 0x1a35ded6d498d555ULL,
+    0xf37eaef2e54d60c9ULL, 0x72e181a9a3c2a61cULL,
+    0x98537aad51952fdeULL, 0x16f6c856ffaa2530ULL,
+    0xd960281e9d1d5215ULL, 0x3a0745fa1ce36f50ULL,
+    0x0b7b642bf1559c18ULL, 0x59a87eae9aec8001ULL,
+    0x5e100c05408bec7cULL, 0x0441f98b19e55023ULL,
+    0xd70dcc5534d38aefULL, 0x927f676de1bea707ULL,
+    0x9769e70db925e3e5ULL, 0x7a636ea29115065aULL,
+    0x468b201816ef11b6ULL, 0xab81a9b73edff409ULL,
+    0xc0ac7de88a07bb1eULL, 0x1f235eb68c0391b7ULL,
+    0x6056b074458dd30fULL, 0xbe8eeac102f7ed67ULL,
+    0xcd381283e04b5fbaULL, 0x5cbefecec277c4e3ULL,
+    0xd21b4c356c48ce0dULL, 0x1019c31664b35d8cULL,
+    0x247362a7d19eea26ULL, 0xebe582efb3299d03ULL,
+    0x02aef2cb82fc289fULL, 0x86275df09ce8aaa8ULL,
+    0x28b07427faac1a43ULL, 0x38a9b7319e1f47cfULL,
+    0xc82e92e3b8d01b58ULL, 0x06ef0b409b1978bcULL,
+    0x62f842bfc771fb90ULL, 0x9904034610eb3b1fULL,
+    0xded85ab5477a3e68ULL, 0x90d195a663428f98ULL,
+    0x5384636e2ac708d8ULL, 0xcbd719c37b522706ULL,
+    0xae9729d76644b0ebULL, 0x7c8c65e20a0c7ee6ULL,
+    0x80c856b007f1d214ULL, 0x8c0b40302cc32271ULL,
+    0xdbcedad51fe17a8aULL, 0x740e8ae938dbdea0ULL,
+    0xa615c6dc549310adULL, 0x19cc55f6171ae90bULL,
+    0x49b1bdb8fe5fdd8dULL, 0xed0a89af2830e5bfULL,
+    0x6a7aadb4f5a65bd6ULL, 0x7e22972988f05679ULL,
+    0xf952b3325566e810ULL, 0x39fecedadf61530eULL,
+    0x6101c99f04f3c7ceULL, 0x2e5f7f6761b562ffULL,
+    0xf08725d226cf5c97ULL, 0x63af3b54860fef51ULL,
+    0x8ff2cb10ef411e2fULL, 0x884ab9bb35267252ULL,
+    0x4df04433e7ba8daeULL, 0x9afd8866d3690741ULL,
+    0x66b9bb34de94abb3ULL, 0x9baaf18d92171380ULL,
+    0x543c11c5f0a064a5ULL, 0x17a1b1bdbed431f1ULL,
+    0xb5f58eeaf3a2717fULL, 0xc355f6c849858740ULL,
+    0xec5df044694ef17eULL, 0xd83751f5dc6346d4ULL,
+    0xfc4433520dfdacf2ULL, 0x0000000000000000ULL,
+    0x5a51f58e596ebc5fULL, 0x3285aaf12e34cf16ULL,
+    0x8d5c39db6dbd36b0ULL, 0x12b731dde64f7513ULL,
+    0x94906c2d7aa7dfbbULL, 0x302b583aacc8e789ULL,
+    0x9d45facd090e6b3cULL, 0x2165e2c78905aec4ULL,
+    0x68d45f7f775a7349ULL, 0x189b2c1d5664fdcaULL,
+    0xe1c99f2f030215daULL, 0x6983269436246788ULL,
+    0x8489af3b1e148237ULL, 0xe94b702431d5b59cULL,
+    0x33d2d31a6f4adbd7ULL, 0xbfd9932a4389f9a6ULL,
+    0xb0e30e8aab39359dULL, 0xd1e2c715afcaf253ULL,
+    0x150f43763c28196eULL, 0xc4ed846393e2eb3dULL,
+    0x03f98b20c3823c5eULL, 0xfd134ab94c83b833ULL,
+    0x556b682eb1de7064ULL, 0x36c4537a37d19f35ULL,
+    0x7559f30279a5ca61ULL, 0x799ae58252973a04ULL,
+    0x9c12832648707ffdULL, 0x78cd9c6913e92ec5ULL,
+    0x1d8dac7d0effb928ULL, 0x439da0784e745554ULL,
+    0x413352b3cc887dcbULL, 0xbacf134a1b12bd44ULL,
+    0x114ebafd25cd494dULL, 0x2f08068c20cb763eULL,
+    0x76a07822ba27f63fULL, 0xeab2fb04f25789c2ULL,
+    0xe3676de481fe3d45ULL, 0x1b62a73d95e6c194ULL,
+    0x641749ff5c68832cULL, 0xa5ec4dfc97112cf3ULL,
+    0xf6682e92bdd6242bULL, 0x3f11c59a44782bb2ULL,
+    0x317c21d1edb6f348ULL, 0xd65ab5be75ad9e2eULL,
+    0x6b2dd45fb4d84f17ULL, 0xfaab381296e4d44eULL,
+    0xd0b5befeeeb4e692ULL, 0x0882ef0b32d7a046ULL,
+    0x512a91a5a83b2047ULL, 0x963e9ee6f85bf724ULL,
+    0x4e09cf132438b1f0ULL, 0x77f701c9fb59e2feULL,
+    0x7ddb1c094b726a27ULL, 0x5f4775ee01f5f8bdULL,
+    0x9186ec4d223c9b59ULL, 0xfeeac1998f01846dULL,
+    0xac39db1ce4b89874ULL, 0xb75b7c21715e59e0ULL,
+    0xafc0503c273aa42aULL, 0x6e3b543fec430bf5ULL,
+    0x704f7362213e8e83ULL, 0x58ff0745db9294c0ULL,
+    0x67eec2df9feabf72ULL, 0xa0facd9ccf8a6811ULL,
+    0xb936986ad890811aULL, 0x95c715c63bd9cb7aULL,
+    0xca8060283a2c33c7ULL, 0x507de84ee9453486ULL,
+    0x85ded6d05f6a96f6ULL, 0x1cdad5964f81ade9ULL,
+    0xd5a33e9eb62fa270ULL, 0x40642b588df6690aULL,
+    0x7f75eec2c98e42b8ULL, 0x2cf18dace3494a60ULL,
+    0x23cb100c0bf9865bULL, 0xeef3028febb2d9e1ULL,
+    0x4425d2d394133929ULL, 0xaad6d05c7fa1e0c8ULL,
+    0xad6ea2f7a5c68cb5ULL, 0xc2028f2308fb9381ULL,
+    0x819f2f5b468fc6d5ULL, 0xc5bafd88d29cfffcULL,
+    0x47dc59f357910577ULL, 0x2b49ff07392e261dULL,
+    0x57c59ae5332258fbULL, 0x73b6f842e2bcb2ddULL,
+    0xcf96e04862b77725ULL, 0x4ca73dd8a6c4996fULL,
+    0x015779eb417e14c1ULL, 0x37932a9176af8bf4ULL },
+  /* 4 */
+  { 0x190a2c9b249df23eULL, 0x2f62f8b62263e1e9ULL,
+    0x7a7f754740993655ULL, 0x330b7ba4d5564d9fULL,
+    0x4c17a16a46672582ULL, 0xb22f08eb7d05f5b8ULL,
+    0x535f47f40bc148ccULL, 0x3aec5d27d4883037ULL,
+    0x10ed0a1825438f96ULL, 0x516101f72c233d17ULL,
+    0x13cc6f949fd04eaeULL, 0x739853c441474bfdULL,
+    0x653793d90d3f5b1bULL, 0x5240647b96b0fc2fULL,
+    0x0c84890ad27623e0ULL, 0xd7189b32703aaea3ULL,
+    0x2685de3523bd9c41ULL, 0x99317c5b11bffefaULL,
+    0x0d9baa854f079703ULL, 0x70b93648fbd48ac5ULL,
+    0xa80441fce30bc6beULL, 0x7287704bdc36ff1eULL,
+    0xb65384ed33dc1f13ULL, 0xd36417343ee34408ULL,
+    0x39cd38ab6e1bf10fULL, 0x5ab861770a1f3564ULL,
+    0x0ebacf09f594563bULL, 0xd04572b884708530ULL,
+    0x3cae9722bdb3af47ULL, 0x4a556b6f2f5cbaf2ULL,
+    0xe1704f1f76c4bd74ULL, 0x5ec4ed7144c6dfcfULL,
+    0x16afc01d4c7810e6ULL, 0x283f113cd629ca7aULL,
+    0xaf59a8761741ed2dULL, 0xeed5a3991e215facULL,
+    0x3bf37ea849f984d4ULL, 0xe413e096a56ce33cULL,
+    0x2c439d3a98f020d1ULL, 0x637559dc6404c46bULL,
+    0x9e6c95d1e5f5d569ULL, 0x24bb9836045fe99aULL,
+    0x44efa466dac8ecc9ULL, 0xc6eab2a5c80895d6ULL,
+    0x803b50c035220cc4ULL, 0x0321658cba93c138ULL,
+    0x8f9ebc465dc7ee1cULL, 0xd15a5137190131d3ULL,
+    0x0fa5ec8668e5e2d8ULL, 0x91c979578d1037b1ULL,
+    0x0642ca05693b9f70ULL, 0xefca80168350eb4fULL,
+    0x38d21b24f36a45ecULL, 0xbeab81e1af73d658ULL,
+    0x8cbfd9cae7542f24ULL, 0xfd19cc0d81f11102ULL,
+    0x0ac6430fbb4dbc90ULL, 0x1d76a09d6a441895ULL,
+    0x2a01573ff1cbbfa1ULL, 0xb572e161894fde2bULL,
+    0x8124734fa853b827ULL, 0x614b1fdf43e6b1b0ULL,
+    0x68ac395c4238cc18ULL, 0x21d837bfd7f7b7d2ULL,
+    0x20c714304a860331ULL, 0x5cfaab726324aa14ULL,
+    0x74c5ba4eb50d606eULL, 0xf3a3030474654739ULL,
+    0x23e671bcf015c209ULL, 0x45f087e947b9582aULL,
+    0xd8bd77b418df4c7bULL, 0xe06f6c90ebb50997ULL,
+    0x0bd96080263c0873ULL, 0x7e03f9410e40dcfeULL,
+    0xb8e94be4c6484928ULL, 0xfb5b0608e8ca8e72ULL,
+    0x1a2b49179e0e3306ULL, 0x4e29e76961855059ULL,
+    0x4f36c4e6fcf4e4baULL, 0x49740ee395cf7bcaULL,
+    0xc2963ea386d17f7dULL, 0x90d65ad810618352ULL,
+    0x12d34c1b02a1fa4dULL, 0xfa44258775bb3a91ULL,
+    0x18150f14b9ec46ddULL, 0x1491861e6b9a653dULL,
+    0x9a1019d7ab2c3fc2ULL, 0x3668d42d06fe13d7ULL,
+    0xdcc1fbb25606a6d0ULL, 0x969490dd795a1c22ULL,
+    0x3549b1a1bc6dd2efULL, 0xc94f5e23a0ed770eULL,
+    0xb9f6686b5b39fdcbULL, 0xc4d4f4a6efeae00dULL,
+    0xe732851a1fff2204ULL, 0x94aad6de5eb869f9ULL,
+    0x3f8ff2ae07206e7fULL, 0xfe38a9813b62d03aULL,
+    0xa7a1ad7a8bee2466ULL, 0x7b6056c8dde882b6ULL,
+    0x302a1e286fc58ca7ULL, 0x8da0fa457a259bc7ULL,
+    0xb3302b64e074415bULL, 0x5402ae7eff8b635fULL,
+    0x08f8050c9cafc94bULL, 0xae468bf98a3059ceULL,
+    0x88c355cca98dc58fULL, 0xb10e6d67c7963480ULL,
+    0xbad70de7e1aa3cf3ULL, 0xbfb4a26e320262bbULL,
+    0xcb711820870f02d5ULL, 0xce12b7a954a75c9dULL,
+    0x563ce87dd8691684ULL, 0x9f73b65e7884618aULL,
+    0x2b1e74b06cba0b42ULL, 0x47cec1ea605b2df1ULL,
+    0x1c698312f735ac76ULL, 0x5fdbcefed9b76b2cULL,
+    0x831a354c8fb1cdfcULL, 0x820516c312c0791fULL,
+    0xb74ca762aeadabf0ULL, 0xfc06ef821c80a5e1ULL,
+    0x5723cbf24518a267ULL, 0x9d4df05d5f661451ULL,
+    0x588627742dfd40bfULL, 0xda8331b73f3d39a0ULL,
+    0x17b0e392d109a405ULL, 0xf965400bcf28fba9ULL,
+    0x7c3dbf4229a2a925ULL, 0x023e460327e275dbULL,
+    0x6cd0b55a0ce126b3ULL, 0xe62da695828e96e7ULL,
+    0x42ad6e63b3f373b9ULL, 0xe50cc319381d57dfULL,
+    0xc5cbd729729b54eeULL, 0x46d1e265fd2a9912ULL,
+    0x6428b056904eeff8ULL, 0x8be23040131e04b7ULL,
+    0x6709d5da2add2ec0ULL, 0x075de98af44a2b93ULL,
+    0x8447dcc67bfbe66fULL, 0x6616f655b7ac9a23ULL,
+    0xd607b8bded4b1a40ULL, 0x0563af89d3a85e48ULL,
+    0x3db1b4ad20c21ba4ULL, 0x11f22997b8323b75ULL,
+    0x292032b34b587e99ULL, 0x7f1cdace9331681dULL,
+    0x8e819fc9c0b65affULL, 0xa1e3677fe2d5bb16ULL,
+    0xcd33d225ee349da5ULL, 0xd9a2543b85aef898ULL,
+    0x795e10cbfa0af76dULL, 0x25a4bbb9992e5d79ULL,
+    0x78413344677b438eULL, 0xf0826688cef68601ULL,
+    0xd27b34bba392f0ebULL, 0x551d8df162fad7bcULL,
+    0x1e57c511d0d7d9adULL, 0xdeffbdb171e4d30bULL,
+    0xf4feea8e802f6caaULL, 0xa480c8f6317de55eULL,
+    0xa0fc44f07fa40ff5ULL, 0x95b5f551c3c9dd1aULL,
+    0x22f952336d6476eaULL, 0x0000000000000000ULL,
+    0xa6be8ef5169f9085ULL, 0xcc2cf1aa73452946ULL,
+    0x2e7ddb39bf12550aULL, 0xd526dd3157d8db78ULL,
+    0x486b2d6c08becf29ULL, 0x9b0f3a58365d8b21ULL,
+    0xac78cdfaadd22c15ULL, 0xbc95c7e28891a383ULL,
+    0x6a927f5f65dab9c3ULL, 0xc3891d2c1ba0cb9eULL,
+    0xeaa92f9f50f8b507ULL, 0xcf0d9426c9d6e87eULL,
+    0xca6e3baf1a7eb636ULL, 0xab25247059980786ULL,
+    0x69b31ad3df4978fbULL, 0xe2512a93cc577c4cULL,
+    0xff278a0ea61364d9ULL, 0x71a615c766a53e26ULL,
+    0x89dc764334fc716cULL, 0xf87a638452594f4aULL,
+    0xf2bc208be914f3daULL, 0x8766b94ac1682757ULL,
+    0xbbc82e687cdb8810ULL, 0x626a7a53f9757088ULL,
+    0xa2c202f358467a2eULL, 0x4d0882e5db169161ULL,
+    0x09e7268301de7da8ULL, 0xe897699c771ac0dcULL,
+    0xc8507dac3d9cc3edULL, 0xc0a878a0a1330aa6ULL,
+    0x978bb352e42ba8c1ULL, 0xe9884a13ea6b743fULL,
+    0x279afdbabecc28a2ULL, 0x047c8c064ed9eaabULL,
+    0x507e2278b15289f4ULL, 0x599904fbb08cf45cULL,
+    0xbd8ae46d15e01760ULL, 0x31353da7f2b43844ULL,
+    0x8558ff49e68a528cULL, 0x76fbfc4d92ef15b5ULL,
+    0x3456922e211c660cULL, 0x86799ac55c1993b4ULL,
+    0x3e90d1219a51da9cULL, 0x2d5cbeb505819432ULL,
+    0x982e5fd48cce4a19ULL, 0xdb9c1238a24c8d43ULL,
+    0xd439febecaa96f9bULL, 0x418c0bef0960b281ULL,
+    0x158ea591f6ebd1deULL, 0x1f48e69e4da66d4eULL,
+    0x8afd13cf8e6fb054ULL, 0xf5e1c9011d5ed849ULL,
+    0xe34e091c5126c8afULL, 0xad67ee7530a398f6ULL,
+    0x43b24dec2e82c75aULL, 0x75da99c1287cd48dULL,
+    0x92e81cdb3783f689ULL, 0xa3dd217cc537cecdULL,
+    0x60543c50de970553ULL, 0x93f73f54aaf2426aULL,
+    0xa91b62737e7a725dULL, 0xf19d4507538732e2ULL,
+    0x77e4dfc20f9ea156ULL, 0x7d229ccdb4d31dc6ULL,
+    0x1b346a98037f87e5ULL, 0xedf4c615a4b29e94ULL,
+    0x4093286094110662ULL, 0xb0114ee85ae78063ULL,
+    0x6ff1d0d6b672e78bULL, 0x6dcf96d591909250ULL,
+    0xdfe09e3eec9567e8ULL, 0x3214582b4827f97cULL,
+    0xb46dc2ee143e6ac8ULL, 0xf6c0ac8da7cd1971ULL,
+    0xebb60c10cd8901e4ULL, 0xf7df8f023abcad92ULL,
+    0x9c52d3d2c217a0b2ULL, 0x6b8d5cd0f8ab0d20ULL,
+    0x3777f7a29b8fa734ULL, 0x011f238f9d71b4e3ULL,
+    0xc1b75b2f3c42be45ULL, 0x5de588fdfe551ef7ULL,
+    0x6eeef3592b035368ULL, 0xaa3a07ffc4e9b365ULL,
+    0xecebe59a39c32a77ULL, 0x5ba742f8976e8187ULL,
+    0x4b4a48e0b22d0e11ULL, 0xddded83dcb771233ULL,
+    0xa59feb79ac0c51bdULL, 0xc7f5912a55792135ULL },
+  /* 5 */
+  { 0x6d6ae04668a9b08aULL, 0x3ab3f04b0be8c743ULL,
+    0xe51e166b54b3c908ULL, 0xbe90a9eb35c2f139ULL,
+    0xb2c7066637f2bec1ULL, 0xaa6945613392202cULL,
+    0x9a28c36f3b5201ebULL, 0xddce5a93ab536994ULL,
+    0x0e34133ef6382827ULL, 0x52a02ba1ec55048bULL,
+    0xa2f88f97c4b2a177ULL, 0x8640e513ca2251a5ULL,
+    0xcdf1d36258137622ULL, 0xfe6cb708dedf8ddbULL,
+    0x8a174a9ec8121e5dULL, 0x679896036b81560eULL,
+    0x59ed033395795feeULL, 0x1dd778ab8b74edafULL,
+    0xee533ef92d9f926dULL, 0x2a8c79baf8a8d8f5ULL,
+    0x6bcf398e69b119f6ULL, 0xe20491742fafdd95ULL,
+    0x276488e0809c2aecULL, 0xea955b82d88f5cceULL,
+    0x7102c63a99d9e0c4ULL, 0xf9763017a5c39946ULL,
+    0x429fa2501f151b3dULL, 0x4659c72bea05d59eULL,
+    0x984b7fdccf5a6634ULL, 0xf742232953fbb161ULL,
+    0x3041860e08c021c7ULL, 0x747bfd9616cd9386ULL,
+    0x4bb1367192312787ULL, 0x1b72a1638a6c44d3ULL,
+    0x4a0e68a6e8359a66ULL, 0x169a5039f258b6caULL,
+    0xb98a2ef44edee5a4ULL, 0xd9083fe85e43a737ULL,
+    0x967f6ce239624e13ULL, 0x8874f62d3c1a7982ULL,
+    0x3c1629830af06e3fULL, 0x9165ebfd427e5a8eULL,
+    0xb5dd81794ceeaa5cULL, 0x0de8f15a7834f219ULL,
+    0x70bd98ede3dd5d25ULL, 0xaccc9ca9328a8950ULL,
+    0x56664eda1945ca28ULL, 0x221db34c0f8859aeULL,
+    0x26dbd637fa98970dULL, 0x1acdffb4f068f932ULL,
+    0x4585254f64090fa0ULL, 0x72de245e17d53afaULL,
+    0x1546b25d7c546cf4ULL, 0x207e0ffffb803e71ULL,
+    0xfaaad2732bcf4378ULL, 0xb462dfae36ea17bdULL,
+    0xcf926fd1ac1b11fdULL, 0xe0672dc7dba7ba4aULL,
+    0xd3fa49ad5d6b41b3ULL, 0x8ba81449b216a3bcULL,
+    0x14f9ec8a0650d115ULL, 0x40fc1ee3eb1d7ce2ULL,
+    0x23a2ed9b758ce44fULL, 0x782c521b14fddc7eULL,
+    0x1c68267cf170504eULL, 0xbcf31558c1ca96e6ULL,
+    0xa781b43b4ba6d235ULL, 0xf6fd7dfe29ff0c80ULL,
+    0xb0a4bad5c3fad91eULL, 0xd199f51ea963266cULL,
+    0x414340349119c103ULL, 0x5405f269ed4dadf7ULL,
+    0xabd61bb649969dcdULL, 0x6813dbeae7bdc3c8ULL,
+    0x65fb2ab09f8931d1ULL, 0xf1e7fae152e3181dULL,
+    0xc1a67cef5a2339daULL, 0x7a4feea8e0f5bba1ULL,
+    0x1e0b9acf05783791ULL, 0x5b8ebf8061713831ULL,
+    0x80e53cdbcb3af8d9ULL, 0x7e898bd315e57502ULL,
+    0xc6bcfbf0213f2d47ULL, 0x95a38e86b76e942dULL,
+    0x092e94218d243cbaULL, 0x8339debf453622e7ULL,
+    0xb11be402b9fe64ffULL, 0x57d9100d634177c9ULL,
+    0xcc4e8db52217cbc3ULL, 0x3b0cae9c71ec7aa2ULL,
+    0xfb158ca451cbfe99ULL, 0x2b33276d82ac6514ULL,
+    0x01bf5ed77a04bde1ULL, 0xc5601994af33f779ULL,
+    0x75c4a3416cc92e67ULL, 0xf3844652a6eb7fc2ULL,
+    0x3487e375fdd0ef64ULL, 0x18ae430704609eedULL,
+    0x4d14efb993298efbULL, 0x815a620cb13e4538ULL,
+    0x125c354207487869ULL, 0x9eeea614ce42cf48ULL,
+    0xce2d3106d61fac1cULL, 0xbbe99247bad6827bULL,
+    0x071a871f7b1c149dULL, 0x2e4a1cc10db81656ULL,
+    0x77a71ff298c149b8ULL, 0x06a5d9c80118a97cULL,
+    0xad73c27e488e34b1ULL, 0x443a7b981e0db241ULL,
+    0xe3bbcfa355ab6074ULL, 0x0af276450328e684ULL,
+    0x73617a896dd1871bULL, 0x58525de4ef7de20fULL,
+    0xb7be3dcab8e6cd83ULL, 0x19111dd07e64230cULL,
+    0x842359a03e2a367aULL, 0x103f89f1f3401fb6ULL,
+    0xdc710444d157d475ULL, 0xb835702334da5845ULL,
+    0x4320fc876511a6dcULL, 0xd026abc9d3679b8dULL,
+    0x17250eee885c0b2bULL, 0x90dab52a387ae76fULL,
+    0x31fed8d972c49c26ULL, 0x89cba8fa461ec463ULL,
+    0x2ff5421677bcabb7ULL, 0x396f122f85e41d7dULL,
+    0xa09b332430bac6a8ULL, 0xc888e8ced7070560ULL,
+    0xaeaf201ac682ee8fULL, 0x1180d7268944a257ULL,
+    0xf058a43628e7a5fcULL, 0xbd4c4b8fbbce2b07ULL,
+    0xa1246df34abe7b49ULL, 0x7d5569b79be9af3cULL,
+    0xa9b5a705bd9efa12ULL, 0xdb6b835baa4bc0e8ULL,
+    0x05793bac8f147342ULL, 0x21c1512881848390ULL,
+    0xfdb0556c50d357e5ULL, 0x613d4fcb6a99ff72ULL,
+    0x03dce2648e0cda3eULL, 0xe949b9e6568386f0ULL,
+    0xfc0f0bbb2ad7ea04ULL, 0x6a70675913b5a417ULL,
+    0x7f36d5046fe1c8e3ULL, 0x0c57af8d02304ff8ULL,
+    0x32223abdfcc84618ULL, 0x0891caf6f720815bULL,
+    0xa63eeaec31a26fd4ULL, 0x2507345374944d33ULL,
+    0x49d28ac266394058ULL, 0xf5219f9aa7f3d6beULL,
+    0x2d96fea583b4cc68ULL, 0x5a31e1571b7585d0ULL,
+    0x8ed12fe53d02d0feULL, 0xdfade6205f5b0e4bULL,
+    0x4cabb16ee92d331aULL, 0x04c6657bf510cea3ULL,
+    0xd73c2cd6a87b8f10ULL, 0xe1d87310a1a307abULL,
+    0x6cd5be9112ad0d6bULL, 0x97c032354366f3f2ULL,
+    0xd4e0ceb22677552eULL, 0x0000000000000000ULL,
+    0x29509bde76a402cbULL, 0xc27a9e8bd42fe3e4ULL,
+    0x5ef7842cee654b73ULL, 0xaf107ecdbc86536eULL,
+    0x3fcacbe784fcb401ULL, 0xd55f90655c73e8cfULL,
+    0xe6c2f40fdabf1336ULL, 0xe8f6e7312c873b11ULL,
+    0xeb2a0555a28be12fULL, 0xe4a148bc2eb774e9ULL,
+    0x9b979db84156bc0aULL, 0x6eb60222e6a56ab4ULL,
+    0x87ffbbc4b026ec44ULL, 0xc703a5275b3b90a6ULL,
+    0x47e699fc9001687fULL, 0x9c8d1aa73a4aa897ULL,
+    0x7cea3760e1ed12ddULL, 0x4ec80ddd1d2554c5ULL,
+    0x13e36b957d4cc588ULL, 0x5d2b66486069914dULL,
+    0x92b90999cc7280b0ULL, 0x517cc9c56259deb5ULL,
+    0xc937b619ad03b881ULL, 0xec30824ad997f5b2ULL,
+    0xa45d565fc5aa080bULL, 0xd6837201d27f32f1ULL,
+    0x635ef3789e9198adULL, 0x531f75769651b96aULL,
+    0x4f77530a6721e924ULL, 0x486dd4151c3dfdb9ULL,
+    0x5f48dafb9461f692ULL, 0x375b011173dc355aULL,
+    0x3da9775470f4d3deULL, 0x8d0dcd81b30e0ac0ULL,
+    0x36e45fc609d888bbULL, 0x55baacbe97491016ULL,
+    0x8cb29356c90ab721ULL, 0x76184125e2c5f459ULL,
+    0x99f4210bb55edbd5ULL, 0x6f095cf59ca1d755ULL,
+    0x9f51f8c3b44672a9ULL, 0x3538bda287d45285ULL,
+    0x50c39712185d6354ULL, 0xf23b1885dcefc223ULL,
+    0x79930ccc6ef9619fULL, 0xed8fdc9da3934853ULL,
+    0xcb540aaa590bdf5eULL, 0x5c94389f1a6d2cacULL,
+    0xe77daad8a0bbaed7ULL, 0x28efc5090ca0bf2aULL,
+    0xbf2ff73c4fc64cd8ULL, 0xb37858b14df60320ULL,
+    0xf8c96ec0dfc724a7ULL, 0x828680683f329f06ULL,
+    0x941cd051cd6a29ccULL, 0xc3c5c05cae2b5e05ULL,
+    0xb601631dc2e27062ULL, 0xc01922382027843bULL,
+    0x24b86a840e90f0d2ULL, 0xd245177a276ffc52ULL,
+    0x0f8b4de98c3c95c6ULL, 0x3e759530fef809e0ULL,
+    0x0b4d2892792c5b65ULL, 0xc4df4743d5374a98ULL,
+    0xa5e20888bfaeb5eaULL, 0xba56cc90c0d23f9aULL,
+    0x38d04cf8ffe0a09cULL, 0x62e1adafe495254cULL,
+    0x0263bcb3f40867dfULL, 0xcaeb547d230f62bfULL,
+    0x6082111c109d4293ULL, 0xdad4dd8cd04f7d09ULL,
+    0xefec602e579b2f8cULL, 0x1fb4c4187f7c8a70ULL,
+    0xffd3e9dfa4db303aULL, 0x7bf0b07f9af10640ULL,
+    0xf49ec14dddf76b5fULL, 0x8f6e713247066d1fULL,
+    0x339d646a86ccfbf9ULL, 0x64447467e58d8c30ULL,
+    0x2c29a072f9b07189ULL, 0xd8b7613f24471ad6ULL,
+    0x6627c8d41185ebefULL, 0xa347d140beb61c96ULL,
+    0xde12b8f7255fb3aaULL, 0x9d324470404e1576ULL,
+    0x9306574eb6763d51ULL, 0xa80af9d2c79a47f3ULL,
+    0x859c0777442e8b9bULL, 0x69ac853d9db97e29ULL },
+  /* 6 */
+  { 0xc3407dfc2de6377eULL, 0x5b9e93eea4256f77ULL,
+    0xadb58fdd50c845e0ULL, 0x5219ff11a75bed86ULL,
+    0x356b61cfd90b1de9ULL, 0xfb8f406e25abe037ULL,
+    0x7a5a0231c0f60796ULL, 0x9d3cd216e1f5020bULL,
+    0x0c6550fb6b48d8f3ULL, 0xf57508c427ff1c62ULL,
+    0x4ad35ffa71cb407dULL, 0x6290a2da1666aa6dULL,
+    0xe284ec2349355f9fULL, 0xb3c307c53d7c84ecULL,
+    0x05e23c0468365a02ULL, 0x190bac4d6c9ebfa8ULL,
+    0x94bbbee9e28b80faULL, 0xa34fc777529cb9b5ULL,
+    0xcc7b39f095bcd978ULL, 0x2426addb0ce532e3ULL,
+    0x7e79329312ce4fc7ULL, 0xab09a72eebec2917ULL,
+    0xf8d15499f6b9d6c2ULL, 0x1a55b8babf8c895dULL,
+    0xdb8add17fb769a85ULL, 0xb57f2f368658e81bULL,
+    0x8acd36f18f3f41f6ULL, 0x5ce3b7bba50f11d3ULL,
+    0x114dcc14d5ee2f0aULL, 0xb91a7fcded1030e8ULL,
+    0x81d5425fe55de7a1ULL, 0xb6213bc1554adeeeULL,
+    0x80144ef95f53f5f2ULL, 0x1e7688186db4c10cULL,
+    0x3b912965db5fe1bcULL, 0xc281715a97e8252dULL,
+    0x54a5d7e21c7f8171ULL, 0x4b12535ccbc5522eULL,
+    0x1d289cefbea6f7f9ULL, 0x6ef5f2217d2e729eULL,
+    0xe6a7dc819b0d17ceULL, 0x1b94b41c05829b0eULL,
+    0x33d7493c622f711eULL, 0xdcf7f942fa5ce421ULL,
+    0x600fba8b7f7a8ecbULL, 0x46b60f011a83988eULL,
+    0x235b898e0dcf4c47ULL, 0x957ab24f588592a9ULL,
+    0x4354330572b5c28cULL, 0xa5f3ef84e9b8d542ULL,
+    0x8c711e02341b2d01ULL, 0x0b1874ae6a62a657ULL,
+    0x1213d8e306fc19ffULL, 0xfe6d7c6a4d9dba35ULL,
+    0x65ed868f174cd4c9ULL, 0x88522ea0e6236550ULL,
+    0x899322065c2d7703ULL, 0xc01e690bfef4018bULL,
+    0x915982ed8abddaf8ULL, 0xbe675b98ec3a4e4cULL,
+    0xa996bf7f82f00db1ULL, 0xe1daf8d49a27696aULL,
+    0x2effd5d3dc8986e7ULL, 0xd153a51f2b1a2e81ULL,
+    0x18caa0ebd690adfbULL, 0x390e3134b243c51aULL,
+    0x2778b92cdff70416ULL, 0x029f1851691c24a6ULL,
+    0x5e7cafeacc133575ULL, 0xfa4e4cc89fa5f264ULL,
+    0x5a5f9f481e2b7d24ULL, 0x484c47ab18d764dbULL,
+    0x400a27f2a1a7f479ULL, 0xaeeb9b2a83da7315ULL,
+    0x721c626879869734ULL, 0x042330a2d2384851ULL,
+    0x85f672fd3765aff0ULL, 0xba446b3a3e02061dULL,
+    0x73dd6ecec3888567ULL, 0xffac70ccf793a866ULL,
+    0xdfa9edb5294ed2d4ULL, 0x6c6aea7014325638ULL,
+    0x834a5a0e8c41c307ULL, 0xcdba35562fb2cb2bULL,
+    0x0ad97808d06cb404ULL, 0x0f3b440cb85aee06ULL,
+    0xe5f9c876481f213bULL, 0x98deee1289c35809ULL,
+    0x59018bbfcd394bd1ULL, 0xe01bf47220297b39ULL,
+    0xde68e1139340c087ULL, 0x9fa3ca4788e926adULL,
+    0xbb85679c840c144eULL, 0x53d8f3b71d55ffd5ULL,
+    0x0da45c5dd146caa0ULL, 0x6f34fe87c72060cdULL,
+    0x57fbc315cf6db784ULL, 0xcee421a1fca0fddeULL,
+    0x3d2d0196607b8d4bULL, 0x642c8a29ad42c69aULL,
+    0x14aff010bdd87508ULL, 0xac74837beac657b3ULL,
+    0x3216459ad821634dULL, 0x3fb219c70967a9edULL,
+    0x06bc28f3bb246cf7ULL, 0xf2082c9126d562c6ULL,
+    0x66b39278c45ee23cULL, 0xbd394f6f3f2878b9ULL,
+    0xfd33689d9e8f8cc0ULL, 0x37f4799eb017394fULL,
+    0x108cc0b26fe03d59ULL, 0xda4bd1b1417888d6ULL,
+    0xb09d1332ee6eb219ULL, 0x2f3ed975668794b4ULL,
+    0x58c0871977375982ULL, 0x7561463d78ace990ULL,
+    0x09876cff037e82f1ULL, 0x7fb83e35a8c05d94ULL,
+    0x26b9b58a65f91645ULL, 0xef20b07e9873953fULL,
+    0x3148516d0b3355b8ULL, 0x41cb2b541ba9e62aULL,
+    0x790416c613e43163ULL, 0xa011d380818e8f40ULL,
+    0x3a5025c36151f3efULL, 0xd57095bdf92266d0ULL,
+    0x498d4b0da2d97688ULL, 0x8b0c3a57353153a5ULL,
+    0x21c491df64d368e1ULL, 0x8f2f0af5e7091bf4ULL,
+    0x2da1c1240f9bb012ULL, 0xc43d59a92ccc49daULL,
+    0xbfa6573e56345c1fULL, 0x828b56a8364fd154ULL,
+    0x9a41f643e0df7cafULL, 0xbcf843c985266aeaULL,
+    0x2b1de9d7b4bfdce5ULL, 0x20059d79dedd7ab2ULL,
+    0x6dabe6d6ae3c446bULL, 0x45e81bf6c991ae7bULL,
+    0x6351ae7cac68b83eULL, 0xa432e32253b6c711ULL,
+    0xd092a9b991143cd2ULL, 0xcac711032e98b58fULL,
+    0xd8d4c9e02864ac70ULL, 0xc5fc550f96c25b89ULL,
+    0xd7ef8dec903e4276ULL, 0x67729ede7e50f06fULL,
+    0xeac28c7af045cf3dULL, 0xb15c1f945460a04aULL,
+    0x9cfddeb05bfb1058ULL, 0x93c69abce3a1fe5eULL,
+    0xeb0380dc4a4bdd6eULL, 0xd20db1e8f8081874ULL,
+    0x229a8528b7c15e14ULL, 0x44291750739fbc28ULL,
+    0xd3ccbd4e42060a27ULL, 0xf62b1c33f4ed2a97ULL,
+    0x86a8660ae4779905ULL, 0xd62e814a2a305025ULL,
+    0x477703a7a08d8addULL, 0x7b9b0e977af815c5ULL,
+    0x78c51a60a9ea2330ULL, 0xa6adfb733aaae3b7ULL,
+    0x97e5aa1e3199b60fULL, 0x0000000000000000ULL,
+    0xf4b404629df10e31ULL, 0x5564db44a6719322ULL,
+    0x9207961a59afec0dULL, 0x9624a6b88b97a45cULL,
+    0x363575380a192b1cULL, 0x2c60cd82b595a241ULL,
+    0x7d272664c1dc7932ULL, 0x7142769faa94a1c1ULL,
+    0xa1d0df263b809d13ULL, 0x1630e841d4c451aeULL,
+    0xc1df65ad44fa13d8ULL, 0x13d2d445bcf20bacULL,
+    0xd915c546926abe23ULL, 0x38cf3d92084dd749ULL,
+    0xe766d0272103059dULL, 0xc7634d5effde7f2fULL,
+    0x077d2455012a7ea4ULL, 0xedbfa82ff16fb199ULL,
+    0xaf2a978c39d46146ULL, 0x42953fa3c8bbd0dfULL,
+    0xcb061da59496a7dcULL, 0x25e7a17db6eb20b0ULL,
+    0x34aa6d6963050fbaULL, 0xa76cf7d580a4f1e4ULL,
+    0xf7ea10954ee338c4ULL, 0xfcf2643b24819e93ULL,
+    0xcf252d0746aeef8dULL, 0x4ef06f58a3f3082cULL,
+    0x563acfb37563a5d7ULL, 0x5086e740ce47c920ULL,
+    0x2982f186dda3f843ULL, 0x87696aac5e798b56ULL,
+    0x5d22bb1d1f010380ULL, 0x035e14f7d31236f5ULL,
+    0x3cec0d30da759f18ULL, 0xf3c920379cdb7095ULL,
+    0xb8db736b571e22bbULL, 0xdd36f5e44052f672ULL,
+    0xaac8ab8851e23b44ULL, 0xa857b3d938fe1fe2ULL,
+    0x17f1e4e76eca43fdULL, 0xec7ea4894b61a3caULL,
+    0x9e62c6e132e734feULL, 0xd4b1991b432c7483ULL,
+    0x6ad6c283af163acfULL, 0x1ce9904904a8e5aaULL,
+    0x5fbda34c761d2726ULL, 0xf910583f4cb7c491ULL,
+    0xc6a241f845d06d7cULL, 0x4f3163fe19fd1a7fULL,
+    0xe99c988d2357f9c8ULL, 0x8eee06535d0709a7ULL,
+    0x0efa48aa0254fc55ULL, 0xb4be23903c56fa48ULL,
+    0x763f52caabbedf65ULL, 0xeee1bcd8227d876cULL,
+    0xe345e085f33b4dccULL, 0x3e731561b369bbbeULL,
+    0x2843fd2067adea10ULL, 0x2adce5710eb1ceb6ULL,
+    0xb7e03767ef44ccbdULL, 0x8db012a48e153f52ULL,
+    0x61ceb62dc5749c98ULL, 0xe85d942b9959eb9bULL,
+    0x4c6f7709caef2c8aULL, 0x84377e5b8d6bbda3ULL,
+    0x30895dcbb13d47ebULL, 0x74a04a9bc2a2fbc3ULL,
+    0x6b17ce251518289cULL, 0xe438c4d0f2113368ULL,
+    0x1fb784bed7bad35fULL, 0x9b80fae55ad16efcULL,
+    0x77fe5e6c11b0cd36ULL, 0xc858095247849129ULL,
+    0x08466059b97090a2ULL, 0x01c10ca6ba0e1253ULL,
+    0x6988d6747c040c3aULL, 0x6849dad2c60a1e69ULL,
+    0x5147ebe67449db73ULL, 0xc99905f4fd8a837aULL,
+    0x991fe2b433cd4a5aULL, 0xf09734c04fc94660ULL,
+    0xa28ecbd1e892abe6ULL, 0xf1563866f5c75433ULL,
+    0x4dae7baf70e13ed9ULL, 0x7ce62ac27bd26b61ULL,
+    0x70837a39109ab392ULL, 0x90988e4b30b3c8abULL,
+    0xb2020b63877296bfULL, 0x156efcb607d6675bULL },
+  /* 7 */
+  { 0xe63f55ce97c331d0ULL, 0x25b506b0015bba16ULL,
+    0xc8706e29e6ad9ba8ULL, 0x5b43d3775d521f6aULL,
+    0x0bfa3d577035106eULL, 0xab95fc172afb0e66ULL,
+    0xf64b63979e7a3276ULL, 0xf58b4562649dad4bULL,
+    0x48f7c3dbae0c83f1ULL, 0xff31916642f5c8c5ULL,
+    0xcbb048dc1c4a0495ULL, 0x66b8f83cdf622989ULL,
+    0x35c130e908e2b9b0ULL, 0x7c761a61f0b34fa1ULL,
+    0x3601161cf205268dULL, 0x9e54ccfe2219b7d6ULL,
+    0x8b7d90a538940837ULL, 0x9cd403588ea35d0bULL,
+    0xbc3c6fea9ccc5b5aULL, 0xe5ff733b6d24aeedULL,
+    0xceed22de0f7eb8d2ULL, 0xec8581cab1ab545eULL,
+    0xb96105e88ff8e71dULL, 0x8ca03501871a5eadULL,
+    0x76ccce65d6db2a2fULL, 0x5883f582a7b58057ULL,
+    0x3f7be4ed2e8adc3eULL, 0x0fe7be06355cd9c9ULL,
+    0xee054e6c1d11be83ULL, 0x1074365909b903a6ULL,
+    0x5dde9f80b4813c10ULL, 0x4a770c7d02b6692cULL,
+    0x5379c8d5d7809039ULL, 0xb4067448161ed409ULL,
+    0x5f5e5026183bd6cdULL, 0xe898029bf4c29df9ULL,
+    0x7fb63c940a54d09cULL, 0xc5171f897f4ba8bcULL,
+    0xa6f28db7b31d3d72ULL, 0x2e4f3be7716eaa78ULL,
+    0x0d6771a099e63314ULL, 0x82076254e41bf284ULL,
+    0x2f0fd2b42733df98ULL, 0x5c9e76d3e2dc49f0ULL,
+    0x7aeb569619606cdbULL, 0x83478b07b2468764ULL,
+    0xcfadcb8d5923cd32ULL, 0x85dac7f05b95a41eULL,
+    0xb5469d1b4043a1e9ULL, 0xb821ecbbd9a592fdULL,
+    0x1b8e0b0e798c13c8ULL, 0x62a57b6d9a0be02eULL,
+    0xfcf1b793b81257f8ULL, 0x9d94ea0bd8fe28ebULL,
+    0x4cea408aeb654a56ULL, 0x23284a47e888996cULL,
+    0x2d8f1d128b893545ULL, 0xf4cbac3132c0d8abULL,
+    0xbd7c86b9ca912ebaULL, 0x3a268eef3dbe6079ULL,
+    0xf0d62f6077a9110cULL, 0x2735c916ade150cbULL,
+    0x89fd5f03942ee2eaULL, 0x1acee25d2fd16628ULL,
+    0x90f39bab41181bffULL, 0x430dfe8cde39939fULL,
+    0xf70b8ac4c8274796ULL, 0x1c53aeaac6024552ULL,
+    0x13b410acf35e9c9bULL, 0xa532ab4249faa24fULL,
+    0x2b1251e5625a163fULL, 0xd7e3e676da4841c7ULL,
+    0xa7b264e4e5404892ULL, 0xda8497d643ae72d3ULL,
+    0x861ae105a1723b23ULL, 0x38a6414991048aa4ULL,
+    0x6578dec92585b6b4ULL, 0x0280cfa6acbaeaddULL,
+    0x88bdb650c273970aULL, 0x9333bd5ebbff84c2ULL,
+    0x4e6a8f2c47dfa08bULL, 0x321c954db76cef2aULL,
+    0x418d312a72837942ULL, 0xb29b38bfffcdf773ULL,
+    0x6c022c38f90a4c07ULL, 0x5a033a240b0f6a8aULL,
+    0x1f93885f3ce5da6fULL, 0xc38a537e96988bc6ULL,
+    0x39e6a81ac759ff44ULL, 0x29929e43cee0fce2ULL,
+    0x40cdd87924de0ca2ULL, 0xe9d8ebc8a29fe819ULL,
+    0x0c2798f3cfbb46f4ULL, 0x55e484223e53b343ULL,
+    0x4650948ecd0d2fd8ULL, 0x20e86cb2126f0651ULL,
+    0x6d42c56baf5739e7ULL, 0xa06fc1405ace1e08ULL,
+    0x7babbfc54f3d193bULL, 0x424d17df8864e67fULL,
+    0xd8045870ef14980eULL, 0xc6d7397c85ac3781ULL,
+    0x21a885e1443273b1ULL, 0x67f8116f893f5c69ULL,
+    0x24f5efe35706cff6ULL, 0xd56329d076f2ab1aULL,
+    0x5e1eb9754e66a32dULL, 0x28d2771098bd8902ULL,
+    0x8f6013f47dfdc190ULL, 0x17a993fdb637553cULL,
+    0xe0a219397e1012aaULL, 0x786b9930b5da8606ULL,
+    0x6e82e39e55b0a6daULL, 0x875a0856f72f4ec3ULL,
+    0x3741ff4fa458536dULL, 0xac4859b3957558fcULL,
+    0x7ef6d5c75c09a57cULL, 0xc04a758b6c7f14fbULL,
+    0xf9acdd91ab26ebbfULL, 0x7391a467c5ef9668ULL,
+    0x335c7c1ee1319acaULL, 0xa91533b18641e4bbULL,
+    0xe4bf9a683b79db0dULL, 0x8e20faa72ba0b470ULL,
+    0x51f907737b3a7ae4ULL, 0x2268a314bed5ec8cULL,
+    0xd944b123b949edeeULL, 0x31dcb3b84d8b7017ULL,
+    0xd3fe65279f218860ULL, 0x097af2f1dc8ffab3ULL,
+    0x9b09a6fc312d0b91ULL, 0xcc6ded78a3c4520fULL,
+    0x3481d9ba5ebfcc50ULL, 0x4f2a667f1182d56bULL,
+    0xdfd9fdd4509ace94ULL, 0x26752045fbbc252bULL,
+    0xbffc491f662bc467ULL, 0xdd593272fc202449ULL,
+    0x3cbbc218d46d4303ULL, 0x91b372f817456e1fULL,
+    0x681faf69bc6385a0ULL, 0xb686bbeebaa43ed4ULL,
+    0x1469b5084cd0ca01ULL, 0x98c98009cbca94acULL,
+    0x6438379a73d8c354ULL, 0xc2caba2dc0c5fe26ULL,
+    0x3e3b0dbe78d7a9deULL, 0x50b9ee202d670f04ULL,
+    0x4590b27b37eab0e5ULL, 0x6025b4cb36b10af3ULL,
+    0xfb2c1237079c0162ULL, 0xa12f28130c936be8ULL,
+    0x4b37e52e54eb1cccULL, 0x083a1ba28ad28f53ULL,
+    0xc10a9cd83a22611bULL, 0x9f1425ad7444c236ULL,
+    0x069d4cf7e9d3237aULL, 0xedc56899e7f621beULL,
+    0x778c273680865fcfULL, 0x309c5aeb1bd605f7ULL,
+    0x8de0dc52d1472b4dULL, 0xf8ec34c2fd7b9e5fULL,
+    0xea18cd3d58787724ULL, 0xaad515447ca67b86ULL,
+    0x9989695a9d97e14cULL, 0x0000000000000000ULL,
+    0xf196c63321f464ecULL, 0x71116bc169557cb5ULL,
+    0xaf887f466f92c7c1ULL, 0x972e3e0ffe964d65ULL,
+    0x190ec4a8d536f915ULL, 0x95aef1a9522ca7b8ULL,
+    0xdc19db21aa7d51a9ULL, 0x94ee18fa0471d258ULL,
+    0x8087adf248a11859ULL, 0xc457f6da2916dd5cULL,
+    0xfa6cfb6451c17482ULL, 0xf256e0c6db13fbd1ULL,
+    0x6a9f60cf10d96f7dULL, 0x4daaa9d9bd383fb6ULL,
+    0x03c026f5fae79f3dULL, 0xde99148706c7bb74ULL,
+    0x2a52b8b6340763dfULL, 0x6fc20acd03edd33aULL,
+    0xd423c08320afdefaULL, 0xbbe1ca4e23420dc0ULL,
+    0x966ed75ca8cb3885ULL, 0xeb58246e0e2502c4ULL,
+    0x055d6a021334bc47ULL, 0xa47242111fa7d7afULL,
+    0xe3623fcc84f78d97ULL, 0x81c744a11efc6db9ULL,
+    0xaec8961539cfb221ULL, 0xf31609958d4e8e31ULL,
+    0x63e5923ecc5695ceULL, 0x47107ddd9b505a38ULL,
+    0xa3afe7b5a0298135ULL, 0x792b7063e387f3e6ULL,
+    0x0140e953565d75e0ULL, 0x12f4f9ffa503e97bULL,
+    0x750ce8902c3cb512ULL, 0xdbc47e8515f30733ULL,
+    0x1ed3610c6ab8af8fULL, 0x5239218681dde5d9ULL,
+    0xe222d69fd2aaf877ULL, 0xfe71783514a8bd25ULL,
+    0xcaf0a18f4a177175ULL, 0x61655d9860ec7f13ULL,
+    0xe77fbc9dc19e4430ULL, 0x2ccff441ddd440a5ULL,
+    0x16e97aaee06a20dcULL, 0xa855dae2d01c915bULL,
+    0x1d1347f9905f30b2ULL, 0xb7c652bdecf94b34ULL,
+    0xd03e43d265c6175dULL, 0xfdb15ec0ee4f2218ULL,
+    0x57644b8492e9599eULL, 0x07dda5a4bf8e569aULL,
+    0x54a46d71680ec6a3ULL, 0x5624a2d7c4b42c7eULL,
+    0xbebca04c3076b187ULL, 0x7d36f332a6ee3a41ULL,
+    0x3b6667bc6be31599ULL, 0x695f463aea3ef040ULL,
+    0xad08b0e0c3282d1cULL, 0xb15b1e4a052a684eULL,
+    0x44d05b2861b7c505ULL, 0x15295c5b1a8dbfe1ULL,
+    0x744c01c37a61c0f2ULL, 0x59c31cd1f1e8f5b7ULL,
+    0xef45a73f4b4ccb63ULL, 0x6bdf899c46841a9dULL,
+    0x3dfb2b4b823036e3ULL, 0xa2ef0ee6f674f4d5ULL,
+    0x184e2dfb836b8cf5ULL, 0x1134df0a5fe47646ULL,
+    0xbaa1231d751f7820ULL, 0xd17eaa81339b62bdULL,
+    0xb01bf71953771daeULL, 0x849a2ea30dc8d1feULL,
+    0x705182923f080955ULL, 0x0ea757556301ac29ULL,
+    0x041d83514569c9a7ULL, 0x0abad4042668658eULL,
+    0x49b72a88f851f611ULL, 0x8a3d79f66ec97dd7ULL,
+    0xcd2d042bf59927efULL, 0xc930877ab0f0ee48ULL,
+    0x9273540deda2f122ULL, 0xc797d02fd3f14261ULL,
+    0xe1e2f06a284d674aULL, 0xd2be8c74c97cfd80ULL,
+    0x9a494faf67707e71ULL, 0xb3dbd1eca9908293ULL,
+    0x72d14d3493b2e388ULL, 0xd6a30f258c153427ULL },
+};
+
+static const uint64_t C16[12][8] =
+{
+  { 0xdd806559f2a64507ULL, 0x05767436cc744d23ULL,
+    0xa2422a08a460d315ULL, 0x4b7ce09192676901ULL,
+    0x714eb88d7585c4fcULL, 0x2f6a76432e45d016ULL,
+    0xebcb2f81c0657c1fULL, 0xb1085bda1ecadae9ULL },
+  { 0xe679047021b19bb7ULL, 0x55dda21bd7cbcd56ULL,
+    0x5cb561c2db0aa7caULL, 0x9ab5176b12d69958ULL,
+    0x61d55e0f16b50131ULL, 0xf3feea720a232b98ULL,
+    0x4fe39d460f70b5d7ULL, 0x6fa3b58aa99d2f1aULL },
+  { 0x991e96f50aba0ab2ULL, 0xc2b6f443867adb31ULL,
+    0xc1c93a376062db09ULL, 0xd3e20fe490359eb1ULL,
+    0xf2ea7514b1297b7bULL, 0x06f15e5f529c1f8bULL,
+    0x0a39fc286a3d8435ULL, 0xf574dcac2bce2fc7ULL },
+  { 0x220cbebc84e3d12eULL, 0x3453eaa193e837f1ULL,
+    0xd8b71333935203beULL, 0xa9d72c82ed03d675ULL,
+    0x9d721cad685e353fULL, 0x488e857e335c3c7dULL,
+    0xf948e1a05d71e4ddULL, 0xef1fdfb3e81566d2ULL },
+  { 0x601758fd7c6cfe57ULL, 0x7a56a27ea9ea63f5ULL,
+    0xdfff00b723271a16ULL, 0xbfcd1747253af5a3ULL,
+    0x359e35d7800fffbdULL, 0x7f151c1f1686104aULL,
+    0x9a3f410c6ca92363ULL, 0x4bea6bacad474799ULL },
+  { 0xfa68407a46647d6eULL, 0xbf71c57236904f35ULL,
+    0x0af21f66c2bec6b6ULL, 0xcffaa6b71c9ab7b4ULL,
+    0x187f9ab49af08ec6ULL, 0x2d66c4f95142a46cULL,
+    0x6fa4c33b7a3039c0ULL, 0xae4faeae1d3ad3d9ULL },
+  { 0x8886564d3a14d493ULL, 0x3517454ca23c4af3ULL,
+    0x06476983284a0504ULL, 0x0992abc52d822c37ULL,
+    0xd3473e33197a93c9ULL, 0x399ec6c7e6bf87c9ULL,
+    0x51ac86febf240954ULL, 0xf4c70e16eeaac5ecULL },
+  { 0xa47f0dd4bf02e71eULL, 0x36acc2355951a8d9ULL,
+    0x69d18d2bd1a5c42fULL, 0xf4892bcb929b0690ULL,
+    0x89b4443b4ddbc49aULL, 0x4eb7f8719c36de1eULL,
+    0x03e7aa020c6e4141ULL, 0x9b1f5b424d93c9a7ULL },
+  { 0x7261445183235adbULL, 0x0e38dc92cb1f2a60ULL,
+    0x7b2b8a9aa6079c54ULL, 0x800a440bdbb2ceb1ULL,
+    0x3cd955b7e00d0984ULL, 0x3a7d3a1b25894224ULL,
+    0x944c9ad8ec165fdeULL, 0x378f5a541631229bULL },
+  { 0x74b4c7fb98459cedULL, 0x3698fad1153bb6c3ULL,
+    0x7a1e6c303b7652f4ULL, 0x9fe76702af69334bULL,
+    0x1fffe18a1b336103ULL, 0x8941e71cff8a78dbULL,
+    0x382ae548b2e4f3f3ULL, 0xabbedea680056f52ULL },
+  { 0x6bcaa4cd81f32d1bULL, 0xdea2594ac06fd85dULL,
+    0xefbacd1d7d476e98ULL, 0x8a1d71efea48b9caULL,
+    0x2001802114846679ULL, 0xd8fa6bbbebab0761ULL,
+    0x3002c6cd635afe94ULL, 0x7bcd9ed0efc889fbULL },
+  { 0x48bc924af11bd720ULL, 0xfaf417d5d9b21b99ULL,
+    0xe71da4aa88e12852ULL, 0x5d80ef9d1891cc86ULL,
+    0xf82012d430219f9bULL, 0xcda43c32bcdf1d77ULL,
+    0xd21380b00449b17aULL, 0x378ee767f11631baULL },
+};
+
+#define strido(out, temp, i) do { \
+	uint64_t t; \
+	t  = streebog_table[0][(temp[0] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	t ^= streebog_table[1][(temp[1] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	t ^= streebog_table[2][(temp[2] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	t ^= streebog_table[3][(temp[3] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	t ^= streebog_table[4][(temp[4] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	t ^= streebog_table[5][(temp[5] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	t ^= streebog_table[6][(temp[6] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	t ^= streebog_table[7][(temp[7] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	out[i] = t; } while(0)
+
+static void LPSX (uint64_t *out, const uint64_t *a, const uint64_t *b)
+{
+  uint64_t temp[8];
+  temp[0] = a[0] ^ b[0];
+  temp[1] = a[1] ^ b[1];
+  temp[2] = a[2] ^ b[2];
+  temp[3] = a[3] ^ b[3];
+  temp[4] = a[4] ^ b[4];
+  temp[5] = a[5] ^ b[5];
+  temp[6] = a[6] ^ b[6];
+  temp[7] = a[7] ^ b[7];
+  strido (out, temp, 0);
+  strido (out, temp, 1);
+  strido (out, temp, 2);
+  strido (out, temp, 3);
+  strido (out, temp, 4);
+  strido (out, temp, 5);
+  strido (out, temp, 6);
+  strido (out, temp, 7);
+}
+
+static inline void g (uint64_t *h, uint64_t *m, uint64_t *N)
+{
+  uint64_t K[8];
+  uint64_t T[8];
+  int i;
+
+  LPSX (K, h, N);
+
+  LPSX (T, K, m);
+  LPSX (K, K, C16[0]);
+  for (i = 1; i &lt; 12; i++)
+    {
+      LPSX (T, K, T);
+      LPSX (K, K, C16[i]);
+    }
+
+  h[0] ^= T[0] ^ K[0] ^ m[0];
+  h[1] ^= T[1] ^ K[1] ^ m[1];
+  h[2] ^= T[2] ^ K[2] ^ m[2];
+  h[3] ^= T[3] ^ K[3] ^ m[3];
+  h[4] ^= T[4] ^ K[4] ^ m[4];
+  h[5] ^= T[5] ^ K[5] ^ m[5];
+  h[6] ^= T[6] ^ K[6] ^ m[6];
+  h[7] ^= T[7] ^ K[7] ^ m[7];
+}
+
+
+static void
+streebog512_compress (struct streebog512_ctx *ctx, const uint8_t *input, size_t \
count) +{
+  uint64_t M[8];
+  uint64_t l, cf;
+  int i;
+
+  for (i = 0; i &lt; 8; i++, input += 8)
+    M[i] = LE_READ_UINT64(input);
+
+  g (ctx-&gt;state, M, ctx-&gt;count);
+  l = ctx-&gt;count[0];
+  ctx-&gt;count[0] += count;
+  if (ctx-&gt;count[0] &lt; l)
+    { /* overflow */
+      for (i = 1; i &lt; 8; i++)
+        {
+          ctx-&gt;count[i]++;
+          if (ctx-&gt;count[i] != 0)
+            break;
+        }
+    }
+
+  cf = 0;
+  ctx-&gt;sigma[0] += M[0];
+  for (i = 1; i &lt; 8; i++)
+    {
+      if (ctx-&gt;sigma[i-1] != M[i-1])
+	cf = (ctx-&gt;sigma[i-1] &lt; M[i-1]);
+      ctx-&gt;sigma[i] += M[i] + cf;
+    }
+}
+
+static void
+streebog_final (struct streebog512_ctx *ctx)
+{
+  uint64_t Z[8] = {};
+  unsigned int i;
+
+  /* PAD. It does not count towards message length */
+  i = ctx-&gt;index;
+  /* We have at least one byte free) */
+  ctx-&gt;block[i++] = 1;
+  while (i &lt; 64)
+    ctx-&gt;block[i++] = 0;
+  streebog512_compress (ctx, ctx-&gt;block, ctx-&gt;index * 8);
+
+  g (ctx-&gt;state, ctx-&gt;count, Z);
+  g (ctx-&gt;state, ctx-&gt;sigma, Z);
+}
+
+#define COMPRESS(ctx, data) (streebog512_compress((ctx), (data), 64 * 8))
+
+void
+streebog512_init(struct streebog512_ctx *ctx)
+{
+  memset(ctx-&gt;state, 0, sizeof(ctx-&gt;state));
+  memset(ctx-&gt;count, 0, sizeof(ctx-&gt;count));
+  memset(ctx-&gt;sigma, 0, sizeof(ctx-&gt;sigma));
+
+  /* Initialize buffer */
+  ctx-&gt;index = 0;
+}
+
+void
+streebog512_update(struct streebog512_ctx *ctx,
+                   size_t length, const uint8_t *data)
+{
+  MD_UPDATE (ctx, length, data, COMPRESS, (void)0);
+}
+
+static void
+streebog512_write_digest(struct streebog512_ctx *ctx,
+                         size_t offset, size_t length,
+                         uint8_t *digest)
+{
+  unsigned i;
+  unsigned words;
+  unsigned leftover;
+
+  assert(offset + length &lt;= STREEBOG512_DIGEST_SIZE);
+
+  streebog_final(ctx);
+
+  words = length / 8;
+  leftover = length % 8;
+
+  for (i = 0; i &lt; words; i++, digest += 8)
+    LE_WRITE_UINT64(digest, ctx-&gt;state[offset + i]);
+
+  if (leftover)
+    {
+      /* Truncate to the right size */
+      uint64_t word = ctx-&gt;state[offset + i] &lt;&lt; (8*(8 - leftover));
+
+      do {
+	digest[--leftover] = (word &gt;&gt; 56) &amp; 0xff;
+	word &lt;&lt;= 8;
+      } while (leftover);
+    }
+}
+
+void
+streebog512_digest(struct streebog512_ctx *ctx,
+	      size_t length,
+	      uint8_t *digest)
+{
+  assert(length &lt;= STREEBOG512_DIGEST_SIZE);
+
+  streebog512_write_digest(ctx, 0, length, digest);
+  streebog512_init(ctx);
+}
+
+void
+streebog256_init(struct streebog256_ctx *ctx)
+{
+  memset(ctx-&gt;state, 1, sizeof(ctx-&gt;state));
+  memset(ctx-&gt;count, 0, sizeof(ctx-&gt;count));
+  memset(ctx-&gt;sigma, 0, sizeof(ctx-&gt;sigma));
+
+  /* Initialize buffer */
+  ctx-&gt;index = 0;
+}
+
+void
+streebog256_digest(struct streebog256_ctx *ctx,
+                   size_t length,
+                   uint8_t *digest)
+{
+  assert(length &lt;= STREEBOG256_DIGEST_SIZE);
+
+  streebog512_write_digest(ctx,
+      4,
+      length,
+      digest);
+  streebog256_init(ctx);
+}
diff --git a/streebog.h b/streebog.h
new file mode 100644
index 000000000000..3408224e0240
--- /dev/null
+++ b/streebog.h
@@ -0,0 +1,99 @@
+/* streebog.h
+
+   The Streebog family of hash functions.
+
+   Copyright (C) 2015 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+ 
+#ifndef NETTLE_STREEBOG_H_INCLUDED
+#define NETTLE_STREEBOG_H_INCLUDED
+
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define streebog256_init nettle_streebog256_init
+#define streebog256_digest nettle_streebog256_digest
+#define streebog512_init nettle_streebog512_init
+#define streebog512_update nettle_streebog512_update
+#define streebog512_digest nettle_streebog512_digest
+
+/* STREEBOG512 */
+
+#define STREEBOG512_DIGEST_SIZE 64
+#define STREEBOG512_BLOCK_SIZE 64
+
+/* Digest is kept internally as 8 64-bit words. */
+#define _STREEBOG512_DIGEST_LENGTH 8
+
+struct streebog512_ctx
+{
+  uint64_t state[_STREEBOG512_DIGEST_LENGTH];    /* State variables */
+  uint64_t count[_STREEBOG512_DIGEST_LENGTH];
+  uint64_t sigma[_STREEBOG512_DIGEST_LENGTH];
+  unsigned int index;                       /* index into buffer */
+  uint8_t block[STREEBOG512_BLOCK_SIZE];          /* STREEBOG512 data buffer */
+};
+
+void
+streebog512_init(struct streebog512_ctx *ctx);
+
+void
+streebog512_update(struct streebog512_ctx *ctx,
+	      size_t length,
+	      const uint8_t *data);
+
+void
+streebog512_digest(struct streebog512_ctx *ctx,
+	      size_t length,
+	      uint8_t *digest);
+
+
+#define STREEBOG256_DIGEST_SIZE 32
+#define STREEBOG256_BLOCK_SIZE STREEBOG512_BLOCK_SIZE
+#define streebog256_ctx streebog512_ctx
+
+void
+streebog256_init(struct streebog256_ctx *ctx);
+
+#define streebog256_update nettle_streebog512_update
+
+void
+streebog256_digest(struct streebog256_ctx *ctx,
+		  size_t length,
+		  uint8_t *digest);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_STREEBOG_H_INCLUDED */
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index c3fc5c116da8..fb77e7e1602e 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -91,6 +91,7 @@
 /sha512-224-test
 /sha512-256-test
 /sha512-test
+/streebog-test
 /twofish-test
 /umac-test
 /version-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 6eee6e22a041..7e38a70c2a18 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -103,6 +103,9 @@ sha3-384-test$(EXEEXT): sha3-384-test.$(OBJEXT)
 sha3-512-test$(EXEEXT): sha3-512-test.$(OBJEXT)
 	$(LINK) sha3-512-test.$(OBJEXT) $(TEST_OBJS) -o sha3-512-test$(EXEEXT)
 
+streebog-test$(EXEEXT): streebog-test.$(OBJEXT)
+	$(LINK) streebog-test.$(OBJEXT) $(TEST_OBJS) -o streebog-test$(EXEEXT)
+
 serpent-test$(EXEEXT): serpent-test.$(OBJEXT)
 	$(LINK) serpent-test.$(OBJEXT) $(TEST_OBJS) -o serpent-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 287c4f75b74e..eaea759ef0c8 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -24,6 +24,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    sha384-test.c sha512-test.c sha512-224-test.c sha512-256-test.c \
 		    sha3-permute-test.c sha3-224-test.c sha3-256-test.c \
 		    sha3-384-test.c sha3-512-test.c \
+		    streebog-test.c \
 		    serpent-test.c twofish-test.c version-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c cfb-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
diff --git a/testsuite/hmac-test.c b/testsuite/hmac-test.c
index 9156cc406d2c..2a18ef9c46a8 100644
--- a/testsuite/hmac-test.c
+++ b/testsuite/hmac-test.c
@@ -894,4 +894,21 @@ test_main(void)
 		 "b1ff68a1de45509fbe4da9a433922655"));
 
   /* Test case AUTH512-3 from same document seems broken. */
+
+  /* RFC 7836 */
+  HMAC_TEST(streebog512,
+	    SHEX("000102030405060708090a0b0c0d0e0f"
+		 "101112131415161718191a1b1c1d1e1f"),
+	    SHEX("0126bdb87800af214341456563780100"),
+	    SHEX("a59bab22ecae19c65fbde6e5f4e9f5d8"
+	         "549d31f037f9df9b905500e171923a77"
+		 "3d5f1530f2ed7e964cb2eedc29e9ad2f"
+		 "3afe93b2814f79f5000ffc0366c251e6"));
+
+  HMAC_TEST(streebog256,
+	    SHEX("000102030405060708090a0b0c0d0e0f"
+		 "101112131415161718191a1b1c1d1e1f"),
+	    SHEX("0126bdb87800af214341456563780100"),
+	    SHEX("a1aa5f7de402d7b3d323f2991c8d4534"
+	         "013137010a83754fd0af6d7cd4922ed9"));
 }
diff --git a/testsuite/meta-hash-test.c b/testsuite/meta-hash-test.c
index 4754f66596ee..dc89222b49df 100644
--- a/testsuite/meta-hash-test.c
+++ b/testsuite/meta-hash-test.c
@@ -18,6 +18,8 @@ const char* hashes[] = {
   "sha3_256",
   "sha3_384",
   "sha3_512",
+  "streebog256",
+  "streebog512"
 };
 
 void
diff --git a/testsuite/pbkdf2-test.c b/testsuite/pbkdf2-test.c
index bb8da57fbb73..594d94d9291a 100644
--- a/testsuite/pbkdf2-test.c
+++ b/testsuite/pbkdf2-test.c
@@ -19,7 +19,8 @@
     ASSERT(dk[expect-&gt;length] == 17);					\
   } while (0)
 
-#define MAX_DKLEN SHA512_DIGEST_SIZE
+/* Streebog test has particularly long testcase */
+#define MAX_DKLEN 100
 
 void
 test_main (void)
@@ -28,6 +29,8 @@ test_main (void)
   struct hmac_sha1_ctx sha1ctx;
   struct hmac_sha256_ctx sha256ctx;
   struct hmac_sha512_ctx sha512ctx;
+  struct hmac_streebog512_ctx streebog512ctx;
+  struct hmac_streebog256_ctx streebog256ctx;
 
   /* Test vectors for PBKDF2 from RFC 6070. */
 
@@ -110,4 +113,30 @@ test_main (void)
   PBKDF2_HMAC_TEST(pbkdf2_hmac_sha256, LDATA("passwd"), 1, LDATA("salt"),
 		   SHEX("55ac046e56e3089fec1691c22544b605"));
 
+  /* from R 50.1.111-2016: https://meganorm.ru/Data2/1/4293748/4293748845.pdf */
+  hmac_streebog512_set_key (&amp;streebog512ctx, LDATA("password"));
+  PBKDF2_TEST (&amp;streebog512ctx, hmac_streebog512_update, hmac_streebog512_digest,
+	       STREEBOG512_DIGEST_SIZE, 1, LDATA("salt"),
+	       SHEX("64770af7f748c3b1c9ac831dbcfd85c26111b30a8a657ddc3056b80ca73e040d2854fd36811f6d825cc4ab66ec0a68a490a9e5cf5156b3a2b7eecddbf9a16b47"));
 +  PBKDF2_TEST (&amp;streebog512ctx, hmac_streebog512_update, hmac_streebog512_digest,
+	       STREEBOG512_DIGEST_SIZE, 4096, LDATA("salt"),
+	       SHEX("e52deb9a2d2aaff4e2ac9d47a41f34c20376591c67807f0477e32549dc341bc7867c09841b6d58e29d0347c996301d55df0d34e47cf68f4e3c2cdaf1d9ab86c3"));
 +
+  hmac_streebog512_set_key (&amp;streebog512ctx, LDATA("passwordPASSWORDpassword"));
+  PBKDF2_TEST (&amp;streebog512ctx, hmac_streebog512_update, hmac_streebog512_digest,
+	       STREEBOG512_DIGEST_SIZE, 4096, \
LDATA("saltSALTsaltSALTsaltSALTsaltSALTsalt"), +	       \
SHEX("b2d8f1245fc4d29274802057e4b54e0a0753aa22fc53760b301cf008679e58fe4bee9addcae99ba2b0b20f431a9c5e50f395"
 +		    "c89387d0945aedeca6eb4015dfc2bd2421ee9bb71183ba882ceebfef259f33f9e27dc6178cb89dc37428cf9cc52a2baa2d3a"));
 +
+  hmac_streebog512_set_key (&amp;streebog512ctx, LDATA("pass\0word"));
+  PBKDF2_TEST (&amp;streebog512ctx, hmac_streebog512_update, hmac_streebog512_digest,
+	       STREEBOG512_DIGEST_SIZE, 4096, LDATA("sa\0lt"),
+	       SHEX("50df062885b69801a3c10248eb0a27ab6e522ffeb20c991c660f001475d73a4e167f782c18e97e92976d9c1d970831ea78ccb879f67068cdac1910740844e830"));
 +
+  /* Generated manually */
+  hmac_streebog256_set_key (&amp;streebog256ctx, LDATA("password"));
+  PBKDF2_TEST (&amp;streebog256ctx, hmac_streebog256_update, hmac_streebog256_digest,
+	       STREEBOG256_DIGEST_SIZE, 1, LDATA("salt"),
+	       SHEX("d789458d143b9abebc4ef63ca8e576c72b13c7d4289db23fc1e946f84cd605bc"));
+
 }
diff --git a/testsuite/streebog-test.c b/testsuite/streebog-test.c
new file mode 100644
index 000000000000..f3532e73a7ee
--- /dev/null
+++ b/testsuite/streebog-test.c
@@ -0,0 +1,81 @@
+#include "testutils.h"
+#include "streebog.h"
+
+/* Using test vectors from the standard itself */
+
+void
+test_main(void)
+{
+  test_hash(&amp;nettle_streebog512,
+            SDATA("012345678901234567890123456789012345678901234567890123456789012"),
 +            SHEX("1b54d01a4af5b9d5 cc3d86d68d285462"
+                 "b19abc2475222f35 c085122be4ba1ffa"
+                 "00ad30f8767b3a82 384c6574f024c311"
+                 "e2a481332b08ef7f 41797891c1646f48"));
+
+  test_hash(&amp;nettle_streebog256,
+            SDATA("012345678901234567890123456789012345678901234567890123456789012"),
 +            SHEX("9d151eefd8590b89 daa6ba6cb74af927"
+                 "5dd051026bb149a4 52fd84e5e57b5500"));
+
+  test_hash(&amp;nettle_streebog512,
+            SHEX("d1e520e2e5f2f0e82c20d1f2f0e8e1ee"
+                 "e6e820e2edf3f6e82c20e2e5fef2fa20"
+                 "f120eceef0ff20f1f2f0e5ebe0ece820"
+                 "ede020f5f0e0e1f0fbff20efebfaeafb"
+                 "20c8e3eef0e5e2fb"),
+            SHEX("1e88e62226bfca6f 9994f1f2d51569e0"
+                 "daf8475a3b0fe61a 5300eee46d961376"
+                 "035fe83549ada2b8 620fcd7c496ce5b3"
+                 "3f0cb9dddc2b6460 143b03dabac9fb28"));
+
+  test_hash(&amp;nettle_streebog256,
+            SHEX("d1e520e2e5f2f0e82c20d1f2f0e8e1ee"
+                 "e6e820e2edf3f6e82c20e2e5fef2fa20"
+                 "f120eceef0ff20f1f2f0e5ebe0ece820"
+                 "ede020f5f0e0e1f0fbff20efebfaeafb"
+                 "20c8e3eef0e5e2fb"),
+            SHEX("9dd2fe4e90409e5d a87f53976d7405b0"
+                 "c0cac628fc669a74 1d50063c557e8f50"));
+
+  test_hash(&amp;nettle_streebog512,
+	    SHEX("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "16111111111111111111111111111111"
+		 "11111111111111111111111111111111"
+		 "11111111111111111111111111111111"
+		 "11111111111111111111111111111116"),
+	    SHEX("8b06f41e59907d9636e892caf5942fcd"
+		 "fb71fa31169a5e70f0edb873664df41c"
+		 "2cce6e06dc6755d15a61cdeb92bd607c"
+		 "c4aaca6732bf3568a23a210dd520fd41"));
+
+  test_hash(&amp;nettle_streebog256,
+	    SHEX("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "16111111111111111111111111111111"
+		 "11111111111111111111111111111111"
+		 "11111111111111111111111111111111"
+		 "11111111111111111111111111111116"),
+	    SHEX("81bb632fa31fcc38b4c379a662dbc58b"
+		 "9bed83f50d3a1b2ce7271ab02d25babb"));
+
+  test_hash(&amp;nettle_streebog512,
+	    SHEX("ffffffffffffffffffffffffffffffff"
+		 "ffffffffffffffffffffffffffffffff"
+		 "ffffffffffffffffffffffffffffffff"
+		 "ffffffffffffffffffffffffffffffff"
+		 "ffffffffffffffffffffffffffffffff"
+		 "ffffffffffffffffffffffffffffffff"
+		 "ffffffffffffffffffffffffffffffff"
+		 "ffffffffffffffffffffffffffffffff"),
+	    SHEX("90a161d12ad309498d3fe5d48202d8a4"
+		 "e9c406d6a264aeab258ac5ecc37a7962"
+		 "aaf9587a5abb09b6bb81ec4b3752a3ff"
+		 "5a838ef175be5772056bc5fe54fcfc7e"));
+
+}
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190512121549</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-12 12:15:49-0400</timestampReceived><subject>[PATCH 2/2] Implement PBKDF2 shortcut function for Streebog256/512</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in             |  1 +
 pbkdf2-hmac-streebog.c  | 67 +++++++++++++++++++++++++++++++++++++++++
 pbkdf2.h                | 14 +++++++++
 testsuite/pbkdf2-test.c |  6 ++++
 4 files changed, 88 insertions(+)
 create mode 100644 pbkdf2-hmac-streebog.c

diff --git a/Makefile.in b/Makefile.in
index ad777659f5c8..e49ae5af2f3d 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -113,6 +113,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 nettle-meta-aeads.c nettle-meta-armors.c \
 		 nettle-meta-ciphers.c nettle-meta-hashes.c \
 		 pbkdf2.c pbkdf2-hmac-sha1.c pbkdf2-hmac-sha256.c \
+		 pbkdf2-hmac-streebog.c \
 		 poly1305-aes.c poly1305-internal.c \
 		 realloc.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
diff --git a/pbkdf2-hmac-streebog.c b/pbkdf2-hmac-streebog.c
new file mode 100644
index 000000000000..cc286f8940ac
--- /dev/null
+++ b/pbkdf2-hmac-streebog.c
@@ -0,0 +1,67 @@
+/* pbkdf2-hmac-streebog.c
+
+   PKCS #5 PBKDF2 used with HMAC-STREEBOG.
+
+   Copyright (C) 2016 Dmitry Eremin-Solenikov
+   Copyright (C) 2012 Simon Josefsson
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "pbkdf2.h"
+
+#include "hmac.h"
+
+void
+pbkdf2_hmac_streebog256 (size_t key_length, const uint8_t *key,
+		    unsigned iterations,
+		    size_t salt_length, const uint8_t *salt,
+		    size_t length, uint8_t *dst)
+{
+  struct hmac_streebog256_ctx streebog256ctx;
+
+  hmac_streebog256_set_key (&amp;streebog256ctx, key_length, key);
+  PBKDF2 (&amp;streebog256ctx, hmac_streebog256_update, hmac_streebog256_digest,
+	  STREEBOG256_DIGEST_SIZE, iterations, salt_length, salt, length, dst);
+}
+
+void
+pbkdf2_hmac_streebog512 (size_t key_length, const uint8_t *key,
+		    unsigned iterations,
+		    size_t salt_length, const uint8_t *salt,
+		    size_t length, uint8_t *dst)
+{
+  struct hmac_streebog512_ctx streebog512ctx;
+
+  hmac_streebog512_set_key (&amp;streebog512ctx, key_length, key);
+  PBKDF2 (&amp;streebog512ctx, hmac_streebog512_update, hmac_streebog512_digest,
+	  STREEBOG512_DIGEST_SIZE, iterations, salt_length, salt, length, dst);
+}
diff --git a/pbkdf2.h b/pbkdf2.h
index 7b1c4c9c1881..0ebcd107ee2a 100644
--- a/pbkdf2.h
+++ b/pbkdf2.h
@@ -45,6 +45,8 @@ extern "C"
 #define pbkdf2 nettle_pbkdf2
 #define pbkdf2_hmac_sha1 nettle_pbkdf2_hmac_sha1
 #define pbkdf2_hmac_sha256 nettle_pbkdf2_hmac_sha256
+#define pbkdf2_hmac_streebog256 nettle_pbkdf2_hmac_streebog256
+#define pbkdf2_hmac_streebog512 nettle_pbkdf2_hmac_streebog512
 
 void
 pbkdf2 (void *mac_ctx,
@@ -78,6 +80,18 @@ pbkdf2_hmac_sha256 (size_t key_length, const uint8_t *key,
 		    size_t salt_length, const uint8_t *salt,
 		    size_t length, uint8_t *dst);
 
+void
+pbkdf2_hmac_streebog256 (size_t key_length, const uint8_t *key,
+			 unsigned iterations,
+			 size_t salt_length, const uint8_t *salt,
+			 size_t length, uint8_t *dst);
+
+void
+pbkdf2_hmac_streebog512 (size_t key_length, const uint8_t *key,
+			 unsigned iterations,
+			 size_t salt_length, const uint8_t *salt,
+			 size_t length, uint8_t *dst);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/pbkdf2-test.c b/testsuite/pbkdf2-test.c
index 594d94d9291a..83163be23e48 100644
--- a/testsuite/pbkdf2-test.c
+++ b/testsuite/pbkdf2-test.c
@@ -133,10 +133,16 @@ test_main (void)
 	       STREEBOG512_DIGEST_SIZE, 4096, LDATA("sa\0lt"),
 	       SHEX("50df062885b69801a3c10248eb0a27ab6e522ffeb20c991c660f001475d73a4e167f782c18e97e92976d9c1d970831ea78ccb879f67068cdac1910740844e830"));
  
+  PBKDF2_HMAC_TEST (pbkdf2_hmac_streebog512, LDATA("password"), 1, LDATA("salt"),
+	       SHEX("64770af7f748c3b1c9ac831dbcfd85c26111b30a8a657ddc3056b80ca73e040d2854fd36811f6d825cc4ab66ec0a68a490a9e5cf5156b3a2b7eecddbf9a16b47"));
 +
   /* Generated manually */
   hmac_streebog256_set_key (&amp;streebog256ctx, LDATA("password"));
   PBKDF2_TEST (&amp;streebog256ctx, hmac_streebog256_update, hmac_streebog256_digest,
 	       STREEBOG256_DIGEST_SIZE, 1, LDATA("salt"),
 	       SHEX("d789458d143b9abebc4ef63ca8e576c72b13c7d4289db23fc1e946f84cd605bc"));
 
+  PBKDF2_HMAC_TEST (pbkdf2_hmac_streebog256, LDATA("password"), 1, LDATA("salt"),
+	       SHEX("d789458d143b9abebc4ef63ca8e576c72b13c7d4289db23fc1e946f84cd605bc"));
+
 }
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190512144225</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2019-05-12 14:42:25-0400</timestampReceived><subject>Re: Release?</subject><body>

On Sun, May 12, 2019 at 9:45 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt;
&gt; &gt; I know of one or two applications that moved to nettle once the des
&gt; &gt; functionality was removed from libcrypt. Not sure if that's a good
&gt; &gt; reason to keep it, they are deprecated, but removing it may make it
&gt; &gt; slower to move to that version.
&gt;
&gt; But I'm not considering deleting des support (the things declared in
&gt; des.h), only the libdes/openssl compatibility glue in des-compat.h.

Thanks, indeed, there is none of the compat API used:
https://src.fedoraproject.org/rpms/claws-mail/blob/f28/f/claws-mail-3.16.0-encrypt-nettle.patch

regards,
Nikos
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190511194034</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-05-11 19:40:34-0400</timestampReceived><subject>Release? (was: Re: curve448 branch)</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; Is there anything that we can do to help with 3.5?

I've just updated the NEWS file, please review. Since it's an ABI break,
maybe a few more things could be deleted. 

* Can we delete _rsa_blind/_rsa_unblind (currently demoted from rsa.h to
  rsa-internal.h, and with internal symbol names).

* dsa-compat.h (compatibility with Nettle older than 3.0)?

* des-compat.h (compatibility with old libdes/openssl)? Also mentioned
  as a candidate for deletion when Nettle-3.0 was released.

&gt; I'm still playing around HMAC/digest refactoring, but I'm not happy with the
&gt; way code looks in my tree.

I've committed changes to move buffers last in the hash context structs.
That should make it a bit easier, but probably still not so pretty.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190511194938</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-11 19:49:38-0400</timestampReceived><subject>Re: Release? (was: Re: curve448 branch)</subject><body>

Hello,

сб, 11 мая 2019 г. в 22:40, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; Is there anything that we can do to help with 3.5?
&gt;
&gt; I've just updated the NEWS file, please review. Since it's an ABI break,
&gt; maybe a few more things could be deleted.
&gt;
&gt; * Can we delete _rsa_blind/_rsa_unblind (currently demoted from rsa.h to
&gt;   rsa-internal.h, and with internal symbol names).

Seems to be unused according to sources.debian.org

&gt; * dsa-compat.h (compatibility with Nettle older than 3.0)?

Seems to be used by unbound, lsh-utils and getdns.

&gt; * des-compat.h (compatibility with old libdes/openssl)? Also mentioned
&gt;   as a candidate for deletion when Nettle-3.0 was released.

Seems unused at the first glance.

&gt;
&gt; &gt; I'm still playing around HMAC/digest refactoring, but I'm not happy with the
&gt; &gt; way code looks in my tree.
&gt;
&gt; I've committed changes to move buffers last in the hash context structs.
&gt; That should make it a bit easier, but probably still not so pretty.

yes, I saw that.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190508123328</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-08 12:33:28-0400</timestampReceived><subject>Re: [PATCH 1/3] Move MAC testing code to generic place from cmac-test</subject><body>

Hello,

Any chances to get these 3 patches in?

чт, 1 нояб. 2018 г. в 13:28, Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;:
&gt;
&gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt; ---
&gt;  testsuite/cmac-test.c | 100 +++++++++++-------------------------------
&gt;  testsuite/testutils.c |  64 +++++++++++++++++++++++++++
&gt;  testsuite/testutils.h |   6 +++
&gt;  3 files changed, 96 insertions(+), 74 deletions(-)
&gt;
&gt; diff --git a/testsuite/cmac-test.c b/testsuite/cmac-test.c
&gt; index 31662d1b6c1b..b1d4aa30dfbe 100644
&gt; --- a/testsuite/cmac-test.c
&gt; +++ b/testsuite/cmac-test.c
&gt; @@ -2,83 +2,35 @@
&gt;  #include "nettle-internal.h"
&gt;  #include "cmac.h"
&gt;
&gt; +const struct nettle_mac nettle_cmac_aes128 =
&gt; +{
&gt; +  "CMAC-AES128",
&gt; +  sizeof(struct cmac_aes128_ctx),
&gt; +  CMAC128_DIGEST_SIZE,
&gt; +  AES128_KEY_SIZE,
&gt; +
&gt; +  (nettle_set_key_func*) cmac_aes128_set_key,
&gt; +  (nettle_hash_update_func*) cmac_aes128_update,
&gt; +  (nettle_hash_digest_func*) cmac_aes128_digest
&gt; +};
&gt; +
&gt; +const struct nettle_mac nettle_cmac_aes256 =
&gt; +{
&gt; +  "CMAC-AES256",
&gt; +  sizeof(struct cmac_aes256_ctx),
&gt; +  CMAC128_DIGEST_SIZE,
&gt; +  AES256_KEY_SIZE,
&gt; +
&gt; +  (nettle_set_key_func*) cmac_aes256_set_key,
&gt; +  (nettle_hash_update_func*) cmac_aes256_update,
&gt; +  (nettle_hash_digest_func*) cmac_aes256_digest
&gt; +};
&gt; +
&gt;  #define test_cmac_aes128(key, msg, ref)                                        \
&gt; -  test_cmac_hash ((nettle_set_key_func*) cmac_aes128_set_key,          \
&gt; -                 (nettle_hash_update_func*) cmac_aes128_update,        \
&gt; -                 (nettle_hash_digest_func*) cmac_aes128_digest,        \
&gt; -                 sizeof(struct cmac_aes128_ctx),                       \
&gt; -                 key, msg, ref)
&gt; +  test_mac(&amp;nettle_cmac_aes128, key, msg, ref)
&gt;
&gt;  #define test_cmac_aes256(key, msg, ref)                                        \
&gt; -  test_cmac_hash ((nettle_set_key_func*) cmac_aes256_set_key,          \
&gt; -                 (nettle_hash_update_func*) cmac_aes256_update,        \
&gt; -                 (nettle_hash_digest_func*) cmac_aes256_digest,        \
&gt; -                 sizeof(struct cmac_aes256_ctx),                       \
&gt; -                 key, msg, ref)
&gt; -
&gt; -static void
&gt; -test_cmac_hash (nettle_set_key_func *set_key,
&gt; -               nettle_hash_update_func *update,
&gt; -               nettle_hash_digest_func *digest, size_t ctx_size,
&gt; -               const struct tstring *key, const struct tstring *msg,
&gt; -               const struct tstring *ref)
&gt; -{
&gt; -  void *ctx;
&gt; -  uint8_t hash[16];
&gt; -  unsigned i;
&gt; -
&gt; -  ctx = xalloc(ctx_size);
&gt; -
&gt; -  ASSERT (ref-&gt;length == sizeof(hash));
&gt; -  ASSERT (key-&gt;length == 16 || key-&gt;length == 32);
&gt; -  set_key (ctx, key-&gt;data);
&gt; -  update (ctx, msg-&gt;length, msg-&gt;data);
&gt; -  digest (ctx, sizeof(hash), hash);
&gt; -  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
&gt; -    {
&gt; -      fprintf (stderr, "cmac_hash failed, msg: ");
&gt; -      print_hex (msg-&gt;length, msg-&gt;data);
&gt; -      fprintf(stderr, "Output:");
&gt; -      print_hex (16, hash);
&gt; -      fprintf(stderr, "Expected:");
&gt; -      tstring_print_hex(ref);
&gt; -      fprintf(stderr, "\n");
&gt; -      FAIL();
&gt; -    }
&gt; -
&gt; -  /* attempt to re-use the structure */
&gt; -  update (ctx, msg-&gt;length, msg-&gt;data);
&gt; -  digest (ctx, sizeof(hash), hash);
&gt; -  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
&gt; -    {
&gt; -      fprintf (stderr, "cmac_hash failed on re-use, msg: ");
&gt; -      print_hex (msg-&gt;length, msg-&gt;data);
&gt; -      fprintf(stderr, "Output:");
&gt; -      print_hex (16, hash);
&gt; -      fprintf(stderr, "Expected:");
&gt; -      tstring_print_hex(ref);
&gt; -      fprintf(stderr, "\n");
&gt; -      FAIL();
&gt; -    }
&gt; -
&gt; -  /* attempt byte-by-byte hashing */
&gt; -  set_key (ctx, key-&gt;data);
&gt; -  for (i=0;i&lt;msg-&gt;length;i++)
&gt; -    update (ctx, 1, msg-&gt;data+i);
&gt; -  digest (ctx, sizeof(hash), hash);
&gt; -  if (!MEMEQ (ref-&gt;length, ref-&gt;data, hash))
&gt; -    {
&gt; -      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
&gt; -      print_hex (msg-&gt;length, msg-&gt;data);
&gt; -      fprintf(stderr, "Output:");
&gt; -      print_hex (16, hash);
&gt; -      fprintf(stderr, "Expected:");
&gt; -      tstring_print_hex(ref);
&gt; -      fprintf(stderr, "\n");
&gt; -      FAIL();
&gt; -    }
&gt; -  free (ctx);
&gt; -}
&gt; +  test_mac(&amp;nettle_cmac_aes256, key, msg, ref)
&gt;
&gt;  void
&gt;  test_main(void)
&gt; diff --git a/testsuite/testutils.c b/testsuite/testutils.c
&gt; index 1812ff4f52b0..ba0b41131925 100644
&gt; --- a/testsuite/testutils.c
&gt; +++ b/testsuite/testutils.c
&gt; @@ -924,6 +924,70 @@ test_hash_large(const struct nettle_hash *hash,
&gt;    free(data);
&gt;  }
&gt;
&gt; +void
&gt; +test_mac(const struct nettle_mac *mac,
&gt; +        const struct tstring *key,
&gt; +        const struct tstring *msg,
&gt; +        const struct tstring *digest)
&gt; +{
&gt; +  void *ctx = xalloc(mac-&gt;context_size);
&gt; +  uint8_t *hash = xalloc(mac-&gt;digest_size);
&gt; +  unsigned i;
&gt; +
&gt; +
&gt; +  ASSERT (digest-&gt;length == mac-&gt;digest_size);
&gt; +  ASSERT (key-&gt;length == mac-&gt;key_size);
&gt; +  mac-&gt;set_key (ctx, key-&gt;data);
&gt; +  mac-&gt;update (ctx, msg-&gt;length, msg-&gt;data);
&gt; +  mac-&gt;digest (ctx, digest-&gt;length, hash);
&gt; +
&gt; +  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
&gt; +    {
&gt; +      fprintf (stderr, "test_mac failed, msg: ");
&gt; +      print_hex (msg-&gt;length, msg-&gt;data);
&gt; +      fprintf(stderr, "Output:");
&gt; +      print_hex (mac-&gt;digest_size, hash);
&gt; +      fprintf(stderr, "Expected:");
&gt; +      tstring_print_hex(digest);
&gt; +      fprintf(stderr, "\n");
&gt; +      FAIL();
&gt; +    }
&gt; +
&gt; +  /* attempt to re-use the structure */
&gt; +  mac-&gt;update (ctx, msg-&gt;length, msg-&gt;data);
&gt; +  mac-&gt;digest (ctx, digest-&gt;length, hash);
&gt; +  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
&gt; +    {
&gt; +      fprintf (stderr, "test_mac: failed on re-use, msg: ");
&gt; +      print_hex (msg-&gt;length, msg-&gt;data);
&gt; +      fprintf(stderr, "Output:");
&gt; +      print_hex (mac-&gt;digest_size, hash);
&gt; +      fprintf(stderr, "Expected:");
&gt; +      tstring_print_hex(digest);
&gt; +      fprintf(stderr, "\n");
&gt; +      FAIL();
&gt; +    }
&gt; +
&gt; +  /* attempt byte-by-byte hashing */
&gt; +  mac-&gt;set_key (ctx, key-&gt;data);
&gt; +  for (i=0;i&lt;msg-&gt;length;i++)
&gt; +    mac-&gt;update (ctx, 1, msg-&gt;data+i);
&gt; +  mac-&gt;digest (ctx, digest-&gt;length, hash);
&gt; +  if (!MEMEQ (digest-&gt;length, digest-&gt;data, hash))
&gt; +    {
&gt; +      fprintf (stderr, "cmac_hash failed on byte-by-byte, msg: ");
&gt; +      print_hex (msg-&gt;length, msg-&gt;data);
&gt; +      fprintf(stderr, "Output:");
&gt; +      print_hex (16, hash);
&gt; +      fprintf(stderr, "Expected:");
&gt; +      tstring_print_hex(digest);
&gt; +      fprintf(stderr, "\n");
&gt; +      FAIL();
&gt; +    }
&gt; +  free (ctx);
&gt; +  free (hash);
&gt; +}
&gt; +
&gt;  void
&gt;  test_armor(const struct nettle_armor *armor,
&gt;             size_t data_length,
&gt; diff --git a/testsuite/testutils.h b/testsuite/testutils.h
&gt; index ded57db6ab4f..f4ea38da9deb 100644
&gt; --- a/testsuite/testutils.h
&gt; +++ b/testsuite/testutils.h
&gt; @@ -170,6 +170,12 @@ test_hash_large(const struct nettle_hash *hash,
&gt;                 uint8_t c,
&gt;                 const struct tstring *digest);
&gt;
&gt; +void
&gt; +test_mac(const struct nettle_mac *mac,
&gt; +        const struct tstring *key,
&gt; +        const struct tstring *msg,
&gt; +        const struct tstring *digest);
&gt; +
&gt;  void
&gt;  test_armor(const struct nettle_armor *armor,
&gt;             size_t data_length,
&gt; --
&gt; 2.19.1
&gt;


-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190512204619</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-12 20:46:19-0400</timestampReceived><subject>Re: [PATCH 3/3] GOST curves generate larger overflows in mod arithmetics</subject><body>

Hi,

&gt; &gt; For now I'm running ecc-mul-a-test and ecc-mul-g-test in a loop without any errors.
&gt;
&gt; To make running in a loop useful, you need to add random seeding, see
&gt; ecc-mod-test.c for an example to how to do it, enabled by the
&gt; NETTLE_TEST_SEED environment variable. Used like
&gt;
&gt;   while NETTLE_TEST_SEED=0 ./testsuite/ecc-mod-test ; do : ; done

I see that NETTLE_TEST_SEED is used only in ecc-mod-test (and
rsa-compute-root-test).
Other tests do gmp_rrandomb/urandomb unconditionally.

&gt;
&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
&gt; Internet email is subject to wholesale government surveillance.



-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190517190257</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2019-05-17 19:02:57-0400</timestampReceived><subject>Re: Add check for ECC at point 0</subject><body>

On Fri, May 17, 2019 at 2:24 PM Simo Sorce &lt;simo@redhat.com&gt; wrote:

&gt; &gt; &gt; Less copy-pasting as the numbers are smaller, the curve used really
&gt; &gt; &gt; makes no difference.
&gt; &gt; &gt;
&gt; &gt; &gt; Nioks,
&gt; &gt; &gt; is the fact we do not enable 192r1 in some distribution a problem?
&gt; &gt;
&gt; &gt; I replied in private previously,
&gt;
&gt; sorry, never received that reply.
&gt;
&gt; &gt;  making a point that in fedora we
&gt; &gt; remove the code and disable everything but secp256r1, 384r1 and 521r1.
&gt; &gt; So any tests that use 192r1 or 224r1 will not be executed at all in
&gt; &gt; that platform.
&gt;
&gt; Understood, are you asking to add some tests with other curves ?

I was merely stating the fact :)
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190524022355</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2019-05-24 02:23:55-0400</timestampReceived><subject>SEC.1 (was: Curve point decompression)</subject><body>

On Thu, May 23, 2019 at 6:54 PM Wim Lewis &lt;wiml@hhhh.org&gt; wrote:
&gt;
&gt; On Thursday, May 23, 2019 1:41:47 PM PDT, Niels Möller wrote:
&gt; &gt; ...
&gt;
&gt; &gt; For the details, it's good to have a specific reference to follow.
&gt; &gt; There'a also been a feature request to convert points to and from ANSI
&gt; &gt; x9.62, possibly related? Maybe converting to and from octest strings
&gt; &gt; according to some specification is more useful as an advertised
&gt; &gt; interface, than x coordinate + sign (not ruling out having both).

Related, one sharp edge with SEC.1 is, the the private key has the
same length as order of the curve. That means, for example, a secp160
private key is 21 bytes instead of 20 bytes.

I've seen bug reports because of the difference.

The private key length was supposed to change to order of base point
in a future version of SEC, but I did not see the change in SEC-2.

Also, I have a copy of x9.62 if you need something copied. I don't
have a copy of P1363, though.

Jeff
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190526205852</emailId><senderName>Wim Lewis</senderName><senderEmail>wiml@hhhh.org</senderEmail><timestampReceived>2019-05-26 20:58:52-0400</timestampReceived><subject>Re: =?iso-8859-1?Q?ecc=5Fmodulo.reduce_(was_Re:_Curve_point_decompression)?=</subject><body>

(Background: I'd been confused by not getting the results I expected from 
ecc_mod_sqr(), etc., and wrote to Niels Möller to ask about it)

On Saturday, May 25, 2019 1:15:27 AM PDT, Niels Möller wrote:
&gt; The thing is, -&gt;reduce will be either a mod operation or a montgomery
&gt; redc operation, depending on what seemed most efficient for the
&gt; particular curve. So here you get a result equal to c^2 2^{-256} (mod
&gt; p).

Ahh! That makes more sense. (I had glossed over the references to 
Montgomery multiplication, probably because I had it confused with 
Karatsuba multiplication.)

Now that I look for it, I see the conditional conversion to Montgomery 
representation in routines like ecc_a_to_j() and ecc_j_to_a().

Thanks,

Wim.

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190529082508</emailId><senderName>Wim Lewis</senderName><senderEmail>wiml@hhhh.org</senderEmail><timestampReceived>2019-05-29 08:25:08-0400</timestampReceived><subject>Re: Curve point decompression</subject><body>

I've pushed some work-in-progress to a git repository here:
   https://git.lysator.liu.se/wiml/nettle

There's more to be done, but I would appreciate any comments or feedback 
people might have. This is all the time I have available to put into it 
right now, but I hope to return to it before too long.

The changes add two new public functions:
    - ecc_point_set_compact() which is like ecc_point_set but accepts a 
point in compact form (X and Y's parity/sign rather than X and Y)
    - ecc_point_set_from_octets() which interprets a point converted to an 
octet string by the rules set out in X9.62 and SEC.1, including compressed, 
uncompressed, and hybrid points

I'm not terribly happy with the name ecc_point_set_compact(); does anyone 
have a suggestion for a better name?

Internals:

Decompression works for P-256, P-384, and P-521, but it still needs sqrt 
implementations for P-192 and P-224. P-224 will be much more complex than 
the others (the c^((p-3)/4) shortcut doesn't apply), but there's a paper by 
djb on computing square roots in it.

I added a second slot to the `ecc_modulo` struct to contain a sqrt(u) 
implementation (as opposed to the existing sqrt(u/v) implementation). The 
slot, and the typedef that describes functions in that slot, need better 
names.

-- 
Wim Lewis / wiml@hhhh.org
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190512074551</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-05-12 07:45:51-0400</timestampReceived><subject>Re: Release?</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; I know of one or two applications that moved to nettle once the des
&gt; functionality was removed from libcrypt. Not sure if that's a good
&gt; reason to keep it, they are deprecated, but removing it may make it
&gt; slower to move to that version.

But I'm not considering deleting des support (the things declared in
des.h), only the libdes/openssl compatibility glue in des-compat.h.

Ah, and there's also md5-compat.*, for api-compatibility with the
RFC1321 reference implementation. This seems to be used by a few debian
packages (radcli, chiark-utils, viking), see
https://codesearch.debian.net/search?q=md5-compat.h, so I think we
should keep it around; it's very simple and testing is better than for
des-compat.h.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190508140133</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-08 14:01:33-0400</timestampReceived><subject>[PATCH 3/3] GOST curves generate larger overflows in mod arithmetics</subject><body>

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 ecc-mod-arith.c | 30 ++++++++++++++++++------------
 1 file changed, 18 insertions(+), 12 deletions(-)

diff --git a/ecc-mod-arith.c b/ecc-mod-arith.c
index f2e47f6747c1..571680a98dc3 100644
--- a/ecc-mod-arith.c
+++ b/ecc-mod-arith.c
@@ -73,10 +73,12 @@ ecc_mod_mul_1 (const struct ecc_modulo *m, mp_limb_t *rp,
   assert (b &lt;= 0xffffffff);
   hi = mpn_mul_1 (rp, ap, m-&gt;size, b);
   hi = mpn_addmul_1 (rp, m-&gt;B, m-&gt;size, hi);
-  assert (hi &lt;= 1);
-  hi = cnd_add_n (hi, rp, m-&gt;B, m-&gt;size);
-  /* Sufficient if b &lt; B^size / p */
-  assert (hi == 0);
+  do {
+    if (hi &gt; 1) /* This is necessary for some of GOST curves */
+      hi = mpn_addmul_1 (rp, m-&gt;B, m-&gt;size, hi);
+    else
+      hi = cnd_add_n (hi, rp, m-&gt;B, m-&gt;size);
+  } while (hi != 0);
 }
 
 void
@@ -88,10 +90,12 @@ ecc_mod_addmul_1 (const struct ecc_modulo *m, mp_limb_t *rp,
   assert (b &lt;= 0xffffffff);
   hi = mpn_addmul_1 (rp, ap, m-&gt;size, b);
   hi = mpn_addmul_1 (rp, m-&gt;B, m-&gt;size, hi);
-  assert (hi &lt;= 1);
-  hi = cnd_add_n (hi, rp, m-&gt;B, m-&gt;size);
-  /* Sufficient roughly if b &lt; B^size / p */
-  assert (hi == 0);
+  do {
+    if (hi &gt; 1) /* This is necessary for some of GOST curves */
+      hi = mpn_addmul_1 (rp, m-&gt;B, m-&gt;size, hi);
+    else
+      hi = cnd_add_n (hi, rp, m-&gt;B, m-&gt;size);
+  } while (hi != 0);
 }
   
 void
@@ -103,10 +107,12 @@ ecc_mod_submul_1 (const struct ecc_modulo *m, mp_limb_t *rp,
   assert (b &lt;= 0xffffffff);
   hi = mpn_submul_1 (rp, ap, m-&gt;size, b);
   hi = mpn_submul_1 (rp, m-&gt;B, m-&gt;size, hi);
-  assert (hi &lt;= 1);
-  hi = cnd_sub_n (hi, rp, m-&gt;B, m-&gt;size);
-  /* Sufficient roughly if b &lt; B^size / p */
-  assert (hi == 0);
+  do {
+    if (hi &gt; 1) /* This is necessary for some of GOST curves */
+      hi = mpn_submul_1 (rp, m-&gt;B, m-&gt;size, hi);
+    else
+      hi = cnd_sub_n (hi, rp, m-&gt;B, m-&gt;size);
+  } while (hi != 0);
 }
 
 /* NOTE: mul and sqr needs 2*m-&gt;size limbs at rp */
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190511082650</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-05-11 08:26:50-0400</timestampReceived><subject>Re: [PATCH 3/3] GOST curves generate larger overflows in mod arithmetics</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt; ---
&gt;  ecc-mod-arith.c | 30 ++++++++++++++++++------------
&gt;  1 file changed, 18 insertions(+), 12 deletions(-)
&gt;
&gt; diff --git a/ecc-mod-arith.c b/ecc-mod-arith.c
&gt; index f2e47f6747c1..571680a98dc3 100644
&gt; --- a/ecc-mod-arith.c
&gt; +++ b/ecc-mod-arith.c
&gt; @@ -73,10 +73,12 @@ ecc_mod_mul_1 (const struct ecc_modulo *m, mp_limb_t *rp,
&gt;    assert (b &lt;= 0xffffffff);
&gt;    hi = mpn_mul_1 (rp, ap, m-&gt;size, b);
&gt;    hi = mpn_addmul_1 (rp, m-&gt;B, m-&gt;size, hi);
&gt; -  assert (hi &lt;= 1);
&gt; -  hi = cnd_add_n (hi, rp, m-&gt;B, m-&gt;size);
&gt; -  /* Sufficient if b &lt; B^size / p */
&gt; -  assert (hi == 0);
&gt; +  do {
&gt; +    if (hi &gt; 1) /* This is necessary for some of GOST curves */
&gt; +      hi = mpn_addmul_1 (rp, m-&gt;B, m-&gt;size, hi);
&gt; +    else
&gt; +      hi = cnd_add_n (hi, rp, m-&gt;B, m-&gt;size);
&gt; +  } while (hi != 0);
&gt;  }

Is it the condition b &lt; B^size / p that is not valid for the GOST
curves? What are the problematic values of b and p?

To keep the ecc code side-channel silent, there must be no conditional
jumps depending on hi (except for asserts, since they always branch the
same way in a non-crashing program). The adjustmenst can only do
unconditional calls to functions like mpn_add_mul_1 and cnd_add_1.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190511085747</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-11 08:57:47-0400</timestampReceived><subject>Re: [PATCH 3/3] GOST curves generate larger overflows in mod arithmetics</subject><body>

Hello,

сб, 11 мая 2019 г. в 11:26, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt; &gt; ---
&gt; &gt;  ecc-mod-arith.c | 30 ++++++++++++++++++------------
&gt; &gt;  1 file changed, 18 insertions(+), 12 deletions(-)
&gt; &gt;
&gt; &gt; diff --git a/ecc-mod-arith.c b/ecc-mod-arith.c
&gt; &gt; index f2e47f6747c1..571680a98dc3 100644
&gt; &gt; --- a/ecc-mod-arith.c
&gt; &gt; +++ b/ecc-mod-arith.c
&gt; &gt; @@ -73,10 +73,12 @@ ecc_mod_mul_1 (const struct ecc_modulo *m, mp_limb_t *rp,
&gt; &gt;    assert (b &lt;= 0xffffffff);
&gt; &gt;    hi = mpn_mul_1 (rp, ap, m-&gt;size, b);
&gt; &gt;    hi = mpn_addmul_1 (rp, m-&gt;B, m-&gt;size, hi);
&gt; &gt; -  assert (hi &lt;= 1);
&gt; &gt; -  hi = cnd_add_n (hi, rp, m-&gt;B, m-&gt;size);
&gt; &gt; -  /* Sufficient if b &lt; B^size / p */
&gt; &gt; -  assert (hi == 0);
&gt; &gt; +  do {
&gt; &gt; +    if (hi &gt; 1) /* This is necessary for some of GOST curves */
&gt; &gt; +      hi = mpn_addmul_1 (rp, m-&gt;B, m-&gt;size, hi);
&gt; &gt; +    else
&gt; &gt; +      hi = cnd_add_n (hi, rp, m-&gt;B, m-&gt;size);
&gt; &gt; +  } while (hi != 0);
&gt; &gt;  }
&gt;
&gt; Is it the condition b &lt; B^size / p that is not valid for the GOST
&gt; curves? What are the problematic values of b and p?

I did not try debugging maths part of this issue.
Basically you can apply first two patches and then observe asserts failing
when running ecc-benchmark example. Problematic module looks like
80000.......something. Bmodp then looks like 7fffffff.....something.

Any help at this point is appreciated.

&gt; To keep the ecc code side-channel silent, there must be no conditional
&gt; jumps depending on hi (except for asserts, since they always branch the
&gt; same way in a non-crashing program). The adjustmenst can only do
&gt; unconditional calls to functions like mpn_add_mul_1 and cnd_add_1.

Yes, thus I've tried adding a loop which should nearly always terminate with
just single compare after cnd_add_1.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190511095353</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-05-11 09:53:53-0400</timestampReceived><subject>Re: [PATCH 3/3] GOST curves generate larger overflows in mod arithmetics</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt;&gt; Is it the condition b &lt; B^size / p that is not valid for the GOST
&gt;&gt; curves? What are the problematic values of b and p?
&gt;
&gt; I did not try debugging maths part of this issue.
&gt; Basically you can apply first two patches and then observe asserts failing
&gt; when running ecc-benchmark example. Problematic module looks like
&gt; 80000.......something. Bmodp then looks like 7fffffff.....something.
&gt;
&gt; Any help at this point is appreciated.

If p is close to B^size / 2, then I think a reduction like

 r  &lt;--  r - 2 * hi * p

will get you close. I.e., 

 hi -= mpn_submul_1(..., 2*hi)

should almost cancel the most significant limb. After this, the common
case is hi == 0, with possible error case being hi == -1 if p starts
with 8000..., or hi == +1 if p starts with 7ffff...
 
It might be useful to precompute |2p - B^size|.

For the larger reductions, does p have form suitable for redc, ending
with ...00001 of ...fffff? Current non-redc reduction code probably
won't support p close to B^size / 2.

&gt;&gt; To keep the ecc code side-channel silent, there must be no conditional
&gt;&gt; jumps depending on hi (except for asserts, since they always branch the
&gt;&gt; same way in a non-crashing program). The adjustmenst can only do
&gt;&gt; unconditional calls to functions like mpn_add_mul_1 and cnd_add_1.
&gt;
&gt; Yes, thus I've tried adding a loop which should nearly always terminate with
&gt; just single compare after cnd_add_1.

Unfortunately, "nearly always" isn't enough; it means that some inputs
will result in a value of hi making the code branch differently, and
that information then leaks through cache and/or timing. If it's likely
to be exploitable, I can't say, but current ecc code is written to
avoid that risk.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190511115056</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-11 11:50:56-0400</timestampReceived><subject>Re: [PATCH 3/3] GOST curves generate larger overflows in mod arithmetics</subject><body>

сб, 11 мая 2019 г. в 12:53, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt;&gt; Is it the condition b &lt; B^size / p that is not valid for the GOST
&gt; &gt;&gt; curves? What are the problematic values of b and p?
&gt; &gt;
&gt; &gt; I did not try debugging maths part of this issue.
&gt; &gt; Basically you can apply first two patches and then observe asserts failing
&gt; &gt; when running ecc-benchmark example. Problematic module looks like
&gt; &gt; 80000.......something. Bmodp then looks like 7fffffff.....something.
&gt; &gt;
&gt; &gt; Any help at this point is appreciated.
&gt;
&gt; If p is close to B^size / 2, then I think a reduction like

Yes, it is.

As an overflow happens in low level code, do you suggest
duplicating ecc-dup-jj/ecc-add-jja/ecc-add-jjj for GOST curves?

&gt;  r  &lt;--  r - 2 * hi * p
&gt;
&gt; will get you close. I.e.,
&gt;
&gt;  hi -= mpn_submul_1(..., 2*hi)
&gt;
&gt; should almost cancel the most significant limb. After this, the common
&gt; case is hi == 0, with possible error case being hi == -1 if p starts
&gt; with 8000..., or hi == +1 if p starts with 7ffff...
&gt;
&gt; It might be useful to precompute |2p - B^size|.
&gt;
&gt; For the larger reductions, does p have form suitable for redc, ending
&gt; with ...00001 of ...fffff?

No, it does not. p is 80.....0c99 for 256-bit curve and 800...06f for 512-bit
curve. Another problem might be another 256-bit curve, where p is semi-random
(9b9f605f5a858107ab1ec85e6b41c8aacf846e86789051d37998f7b9022d759b).

&gt; Current non-redc reduction code probably
&gt; won't support p close to B^size / 2.
&gt;
&gt; &gt;&gt; To keep the ecc code side-channel silent, there must be no conditional
&gt; &gt;&gt; jumps depending on hi (except for asserts, since they always branch the
&gt; &gt;&gt; same way in a non-crashing program). The adjustmenst can only do
&gt; &gt;&gt; unconditional calls to functions like mpn_add_mul_1 and cnd_add_1.
&gt; &gt;
&gt; &gt; Yes, thus I've tried adding a loop which should nearly always terminate with
&gt; &gt; just single compare after cnd_add_1.
&gt;
&gt; Unfortunately, "nearly always" isn't enough; it means that some inputs
&gt; will result in a value of hi making the code branch differently, and
&gt; that information then leaks through cache and/or timing. If it's likely
&gt; to be exploitable, I can't say, but current ecc code is written to
&gt; avoid that risk.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190511185510</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-05-11 18:55:10-0400</timestampReceived><subject>Re: [PATCH 3/3] GOST curves generate larger overflows in mod arithmetics</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt;&gt; If p is close to B^size / 2, then I think a reduction like
&gt;
&gt; Yes, it is.
&gt;
&gt; As an overflow happens in low level code, do you suggest
&gt; duplicating ecc-dup-jj/ecc-add-jja/ecc-add-jjj for GOST curves?

I'd prefer not to duplicate the point functions. Could consider doing
these operations (or part of them) using indirection via some new
function pointer in struct ecc_modulo.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190523190145</emailId><senderName>Wim Lewis</senderName><senderEmail>wiml@hhhh.org</senderEmail><timestampReceived>2019-05-23 19:01:45-0400</timestampReceived><subject>Curve point decompression</subject><body>

I'm looking at implementing elliptic curve point compression a la SEC1 
(admittedly, mostly to reduce the number of "feature not supported" code 
paths in a library, but it seems like a somewhat useful ability). 
Nettle/Hogweed already implements it internally for curve25519, but I want 
to implement it for the "secp" curves as well.

Point compression is easy enough, but point decompression requires some 
curve math, potentially dependent on the specific curve, and some of it is 
redundant with what's already done in ecc_point_set(). So I was thinking 
about moving this functionality into Hogweed as a function along the lines 
of ecc_point_set_compressed(), which would take, instead of a y-coordinate, 
an int containing the sign/parity of the y-coordinate.

So my question for the list and for the maintainers is, is this a 
reasonable API to add to Hogweed? Is there interest in including it in 
Hogweed if I were to take the time to turn it into a tidy patch?


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190523204147</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-05-23 20:41:47-0400</timestampReceived><subject>Re: Curve point decompression</subject><body>

Wim Lewis &lt;wiml@hhhh.org&gt; writes:

&gt; Point compression is easy enough, but point decompression requires
&gt; some curve math, potentially dependent on the specific curve, and some
&gt; of it is redundant with what's already done in ecc_point_set().

I think what's needed is basically a mod p square root. See RFC 6090 for
one way to do it. (Btw, it might make sense to adopt the name "compact
representation" from that document; the name "point compression" was
probably invented to make the good old math sound more technical and
impressive in patent filings).

&gt; So I
&gt; was thinking about moving this functionality into Hogweed as a
&gt; function along the lines of ecc_point_set_compressed(), which would
&gt; take, instead of a y-coordinate, an int containing the sign/parity of
&gt; the y-coordinate.

For the details, it's good to have a specific reference to follow.
There'a also been a feature request to convert points to and from ANSI
x9.62, possibly related? Maybe converting to and from octest strings
according to some specification is more useful as an advertised
interface, than x coordinate + sign (not ruling out having both).

&gt; So my question for the list and for the maintainers is, is this a
&gt; reasonable API to add to Hogweed? Is there interest in including it in
&gt; Hogweed if I were to take the time to turn it into a tidy patch?

It could make sense. Do you have any concrete use cases?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190523225408</emailId><senderName>Wim Lewis</senderName><senderEmail>wiml@hhhh.org</senderEmail><timestampReceived>2019-05-23 22:54:08-0400</timestampReceived><subject>Re: Curve point decompression</subject><body>

On Thursday, May 23, 2019 1:41:47 PM PDT, Niels Möller wrote:
&gt; Wim Lewis &lt;wiml@hhhh.org&gt; writes:
&gt;&gt; Point compression is easy enough, but point decompression requires
&gt;&gt; some curve math, potentially dependent on the specific curve, and some
&gt;&gt; of it is redundant with what's already done in ecc_point_set().
&gt;
&gt; I think what's needed is basically a mod p square root. See RFC 6090 for
&gt; one way to do it. 

One motivation for putting this code into Hogweed is that the common curves 
(P-256, -384, -512) all have primes which allow using a simple shortcut for 
computing square roots instead of using a general algorithm. If this is 
true for P-192 and P-224 as well (I haven't checked) then I can safely 
avoid writing the general algorithm at all. :)

There's already a slot in the curve structure for computing sqrt(u/v), 
although it's NULL for the non-Edwards curves. My thought was to just fill 
in this slot for the other curves as well, perhaps with an implementation 
that's optimized for v==1. Then ecc_point_set_compact() becomes a fairly 
simple function.

&gt; (Btw, it might make sense to adopt the name "compact
&gt; representation" from that document;

Good thought.

&gt; For the details, it's good to have a specific reference to follow.
&gt; There'a also been a feature request to convert points to and from ANSI
&gt; x9.62, possibly related? Maybe converting to and from octest strings
&gt; according to some specification is more useful as an advertised
&gt; interface, than x coordinate + sign (not ruling out having both).

Indeed, that's my motivation --- I want to be able to work with protocols 
that use the SEC.1 / X9.62 "ECPoint" format, which can imply the ability to 
use "compressed" points; converting to and from octet-strings is easy 
enough by using functions like nettle_mpz_get_str_256(), and only the 
reconstruction of the y-coordinate requires any non-trivial code.

I'd be happy to contribute the point &lt;--&gt; octet-string functions I'm 
writing to Hogweed as well. I think that exposing a ecc_point_set_compact() 
function would be nice to have, even so. But I understand if you'd like to 
keep the API a little smaller.


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190523230720</emailId><senderName>Wim Lewis</senderName><senderEmail>wiml@hhhh.org</senderEmail><timestampReceived>2019-05-23 23:07:20-0400</timestampReceived><subject>Re: Curve point decompression</subject><body>

On Thursday, May 23, 2019 3:54:08 PM PDT, Wim Lewis wrote:
&gt; One motivation for putting this code into Hogweed is that the 
&gt; common curves (P-256, -384, -512) all have primes which allow 
&gt; using a simple shortcut for computing square roots instead of 
&gt; using a general algorithm. If this is true for P-192 and P-224 
&gt; as well (I haven't checked) then I can safely avoid writing the 
&gt; general algorithm at all. :)

Ah, sadly P-224 is an exception.

This document does have optimized square root algorithms for each of the 
curves, including P-224:
   
https://apps.nsa.gov/iaarchive/library/ia-guidance/ia-solutions-for-classified/algorithm-guidance/mathematical-routines-for-the-nist-prime-elliptic-curves.cfm


and also references a paper by djb on efficiently computing square roots in 
"annoying" prime fields such as P-224's.


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190512114456</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-05-12 11:44:56-0400</timestampReceived><subject>Re: [PATCH 3/3] GOST curves generate larger overflows in mod arithmetics</subject><body>

сб, 11 мая 2019 г. в 21:55, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt;&gt; If p is close to B^size / 2, then I think a reduction like
&gt; &gt;
&gt; &gt; Yes, it is.
&gt; &gt;
&gt; &gt; As an overflow happens in low level code, do you suggest
&gt; &gt; duplicating ecc-dup-jj/ecc-add-jja/ecc-add-jjj for GOST curves?
&gt;
&gt; I'd prefer not to duplicate the point functions. Could consider doing
&gt; these operations (or part of them) using indirection via some new
&gt; function pointer in struct ecc_modulo.

This patch makes things work for me. Does it stand a chance to be applied?
I'll run GnuTLS tests against it later. For now I'm running ecc-mul-a-test and
ecc-mul-g-test in a loop without any errors.

diff --git a/ecc-mod-arith.c b/ecc-mod-arith.c
index f2e47f6747c1..a70ee1228c78 100644
--- a/ecc-mod-arith.c
+++ b/ecc-mod-arith.c
@@ -103,8 +103,10 @@ ecc_mod_submul_1 (const struct ecc_modulo *m,
mp_limb_t *rp,
   assert (b &lt;= 0xffffffff);
   hi = mpn_submul_1 (rp, ap, m-&gt;size, b);
   hi = mpn_submul_1 (rp, m-&gt;B, m-&gt;size, hi);
+  hi = mpn_submul_1 (rp, m-&gt;B, m-&gt;size, hi);
   assert (hi &lt;= 1);
   hi = cnd_sub_n (hi, rp, m-&gt;B, m-&gt;size);
+  hi = cnd_sub_n (hi, rp, m-&gt;B, m-&gt;size);
   /* Sufficient roughly if b &lt; B^size / p */
   assert (hi == 0);
 }



&gt;
&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
&gt; Internet email is subject to wholesale government surveillance.



-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190512173131</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-05-12 17:31:31-0400</timestampReceived><subject>Re: [PATCH 3/3] GOST curves generate larger overflows in mod arithmetics</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; This patch makes things work for me. 

Is it only ecc_mod_submul_1 that you need to change? It's used via the
ecc_modp_submul_1 macro.

&gt; Does it stand a chance to be applied?

To accept the patch, I'd like to understand the mathematics and document
what's required of the modulo to make it correct. And I'd also like to
know if there's any measurable slowdown in examples/hogweed-benchmark or
ecc-benchmark for the other curves.

&gt; For now I'm running ecc-mul-a-test and ecc-mul-g-test in a loop without any errors.

To make running in a loop useful, you need to add random seeding, see
ecc-mod-test.c for an example to how to do it, enabled by the
NETTLE_TEST_SEED environment variable. Used like

  while NETTLE_TEST_SEED=0 ./testsuite/ecc-mod-test ; do : ; done

Regards, 
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190412025821</emailId><senderName>"Yu, Mingli"</senderName><senderEmail>mingli.yu@windriver.com</senderEmail><timestampReceived>2019-04-12 02:58:21-0400</timestampReceived><subject>Re: nettle-pbkdf2 Segmentation fault</subject><body>



On 2019年04月11日 03:49, Niels Möller wrote:
&gt; "Yu, Mingli" &lt;mingli.yu@windriver.com&gt; writes:
&gt;
&gt;&gt; Program received signal SIGSEGV, Segmentation fault.
&gt;&gt; nettle_sha256_update (ctx=0x7fffffffe5c0, length=&lt;optimized out&gt;,
&gt;&gt;      data=0x55559260 &lt;error: Cannot access memory at address 0x55559260&gt;)
&gt;&gt;      at ../nettle-3.4.1/sha256.c:99
&gt;&gt; 99	../nettle-3.4.1/sha256.c: No such file or directory.
&gt;&gt; (gdb) bt
&gt;&gt; #0  nettle_sha256_update (ctx=0x7fffffffe5c0, length=&lt;optimized out&gt;,
&gt;&gt;      data=0x55559260 &lt;error: Cannot access memory at address 0x55559260&gt;)
&gt;&gt;      at ../nettle-3.4.1/sha256.c:99
&gt;&gt; #1  0x00007ffff7fa9bb6 in nettle_pbkdf2
&gt;&gt; (mac_ctx=mac_ctx@entry=0x7fffffffe4e0,
&gt;&gt;      update=0x7ffff7fa7cb0 &lt;nettle_hmac_sha256_update&gt;,
&gt;&gt;      digest=0x7ffff7fa7cc0 &lt;nettle_hmac_sha256_digest&gt;,
&gt;&gt;      digest_size=digest_size@entry=32, iterations=iterations@entry=1,
&gt;&gt;      salt_length=salt_length@entry=4,
&gt;&gt;      salt=0x55559260 &lt;error: Cannot access memory at address 0x55559260&gt;,
&gt;&gt;      length=16, dst=0x55555555a290 "") at ../nettle-3.4.1/pbkdf2.c:78
&gt;&gt; #2  0x00007ffff7fa9dd3 in nettle_pbkdf2_hmac_sha256 (
&gt;&gt;      key_length=&lt;optimized out&gt;, key=&lt;optimized out&gt;, iterations=1,
&gt;&gt;      salt_length=4,
&gt;&gt;      salt=0x55559260 &lt;error: Cannot access memory at address 0x55559260&gt;,
&gt;&gt;      length=16, dst=0x55555555a290 "")
&gt;&gt;      at ../nettle-3.4.1/pbkdf2-hmac-sha256.c:51
&gt;&gt; #3  0x000055555555544c in main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;)
&gt;&gt;      at ../../nettle-3.4.1/tools/nettle-pbkdf2.c:167
&gt;
&gt; Not sure if everything here can be trusted, but the
&gt;
&gt;    salt=0x55559260 &lt;error: Cannot access memory at address 0x55559260&gt;,
&gt;
&gt; in the backtrace indicates some problem with the salt passed down fron
&gt; the nettle-pbkdf2 tool to the nettle library functions.
&gt;
&gt; It's allocated as
&gt;
&gt;    salt = strdup (argv[0]);
&gt;
&gt; at line 146 in tools/nettle-pbkdf2.c (after an argv += optind). I note
&gt; that there's no check of the return value, but if strdup fails it should
&gt; return NULL, which would be a different invalid address.
&gt;
&gt; You may want to examine the values of those variables in the debugger or
&gt; with debug printouts. E.g, try this patch.
&gt;
&gt; --- a/tools/nettle-pbkdf2.c
&gt; +++ b/tools/nettle-pbkdf2.c
&gt; @@ -144,6 +144,11 @@ main (int argc, char **argv)
&gt;       }
&gt;
&gt;     salt = strdup (argv[0]);

Thanks Niels very much for your detailed info!
Yes, I also found that it breaks at "salt = strdup (argv[0]);"
and generate a patch to fix it, will send out the patch.

&gt; +  if (!salt)
&gt; +    die ("strdup failed: Virtual memory exhausted.\n");
&gt; +  fprintf(stderr, "argv[0]: '%s'\n", argv[0]);
&gt; +  fprintf(stderr, "copy (salt): '%s'\n", salt);
&gt; +
&gt;     salt_length = strlen(argv[0]);
&gt;
&gt;     if (hex_salt)
&gt;
&gt;&gt;&gt;&gt;&gt; What kind of machine, operating system, and compiler are you using?
&gt;&gt;&gt;&gt;&gt; Since the testsuite passes on the test systems (including x86_64 and
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; I work on x86_64 and use gcc for compiler.
&gt;
&gt; And operating system, please?

The issue found at the customized OS which based on yocto as
https://www.yoctoproject.org/docs/2.6.1/dev-manual/dev-manual.html

&gt;
&gt; Regards,
&gt; /Niels
&gt;
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190414075030</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-04-14 07:50:30-0400</timestampReceived><subject>Re: [PATCH][v2] fat-arm.c: prefer getauxval() over /proc/cpuinfo parsing</subject><body>

"Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt; writes:

&gt; On 14.03.2019 08:41, Niels Möller wrote:
&gt;&gt; "Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt; writes:
&gt;&gt; 
&gt;&gt;&gt; When compiled for armv6+ and getauxval() is present (glibc 2.16+),
&gt;&gt;&gt; avoid slow and unreliable /proc/cpuinfo parsing.
&gt;&gt;&gt;  
&gt;&gt;&gt; E.g. /proc/cpuinfo contains junk with qemu-user and can be unavailable
&gt;&gt;&gt; in some chroot environment.
&gt;&gt; 
&gt;&gt; Do you know what's the preferred way to do this on android? Do we still
&gt;&gt; need /proc/cpuinfo, or are there any library facilities?
&gt;
&gt; Google suggests https://developer.android.com/ndk/guides/cpu-features
&gt; I have no experience with it.

That page says that getauxval is available on later versions ("API level
18" and later, whatever that means). So should hopefully work, with the
same configure check.

Not sure if there's any easy way to test on android, without downloading
either the ndk (with whatever license agreements required) or just the
cross-compiler binaries. Is http://android-rebuilds.beuc.net/ the way to
go? I also tried native compile under termux a while ago, but configure
failed because there was no /bin/sh.

&gt; There are (const char *)getauxval(AT_PLATFORM); it is expected to be "v[45678][lb]";
&gt; probably, I should use it.
&gt;
&gt; Things that should be checked: arm (32bit) userland with aarch64/arm64 kernel.

Any progress on this? I'd really like to have the arch version check
also done via getauxval, if that's possible.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190415071436</emailId><senderName>"Yu, Mingli"</senderName><senderEmail>mingli.yu@windriver.com</senderEmail><timestampReceived>2019-04-15 07:14:36-0400</timestampReceived><subject>Re: [PATCH] nettle-pbkdf2.c: change the initialization for salt</subject><body>

Thanks very much for Niels and Alon's information!

After double check, I found the strdup triggers Segmentation fault when 
-std=c99 included in compiler flags while compile nettle.

On 2019年04月12日 15:10, Alon Bar-Lev wrote:
&gt; On Fri, Apr 12, 2019 at 10:07 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;&gt;&gt; However, looking at the code, I believe the allocation of memory is
&gt;&gt;&gt; not required... it can be:
&gt;&gt;
&gt;&gt; The if (hex_salt) {...} block overwrites the salt storage, for in-place
&gt;&gt; hex decoding. I don't quite like overwriting the strings passed in via
&gt;&gt; argv, even if it might be possible. So when I wrote this tool, always
&gt;&gt; allocating a writable copy, and calling free unconditionally, seemed
&gt;&gt; nice and easy,
&gt;
&gt; Fair enough :)
&gt;
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190418134334</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2019-04-18 13:43:34-0400</timestampReceived><subject>Re: SIV-CMAC</subject><body>

Simo informed me that I didn't update the CMAC file with the new
initializer. Instead of spamming the list with numerous patches, my
latest version is at:

https://gitlab.com/nmav/nettle/merge_requests/4/

Can be downloaded as patches at:
https://gitlab.com/nmav/nettle/merge_requests/4.patch

On Thu, Apr 18, 2019 at 9:00 AM Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; wrote:
&gt;
&gt; On Wed, 2019-04-17 at 20:41 +0200, Niels Möller wrote:
&gt; &gt;
&gt; &gt; &gt; &gt; To me, this sounds like a likely source of interop problems.
&gt; &gt; &gt; &gt; Since
&gt; &gt; &gt; &gt; RFC
&gt; &gt; &gt; &gt; 5297 is general and allows the application to decide on the
&gt; &gt; &gt; &gt; number of
&gt; &gt; &gt; &gt; elements and meaning of the input vector, it doesn't give much
&gt; &gt; &gt; &gt; guidance on this, as far as I see. The crucial case is when an
&gt; &gt; &gt; &gt; application specifies that SIV is used with associated data
&gt; &gt; &gt; &gt; and/or a
&gt; &gt; &gt; &gt; nonce, but allows an empty string for either of those.
&gt; &gt; &gt;
&gt; &gt; &gt; I agree on that. That's one of the reasons I stuck on the higher
&gt; &gt; &gt; level
&gt; &gt; &gt; AEAD API (expressed by the message APIs in nettle). I added two
&gt; &gt; &gt; sentences in the documentation about it.
&gt; &gt;
&gt; &gt; The thing is, the AEAD api should allow inputs to be zero-length
&gt; &gt; strings. Then the question is how to treat zero-length inputs in
&gt; &gt; _siv_s2v, and I don't find RFC 5297 crystal clear on this point.
&gt; &gt;
&gt; &gt; To me, it would make most sense for the AEAD construction to always
&gt; &gt; use
&gt; &gt; the S2V function in the spec with S1 = associated data (possibly zero
&gt; &gt; length), S2 = nonce (possibly zero length), S3 = plaintext (possibly
&gt; &gt; zero length). But we need to do what's needed to make it easy to
&gt; &gt; interoperate with applicatinos and protocols using SIV; if everyone
&gt; &gt; else
&gt; &gt; does this differently, we should probably follow.
&gt;
&gt; I agree. The patch I sent yesterday is towards that. I have verified
&gt; that this approach interoperates with two implementations. The
&gt; difference from what you write above is that we don't support at all
&gt; the case where nonce=empty. That has interop issues (two
&gt; interpretations, skip the field, or use it as empty), and I think it
&gt; makes sense to leave it out. It has no use for our interface.
&gt;
&gt; Today's patch adds two more vectors from another implementation and
&gt; includes Simo's suggestion.
&gt;
&gt; &gt;
&gt; &gt; If we do it this way, then the nonce-less "key wrapping" usecase
&gt; &gt; mentioned in RFC5297, with the example in A1, is *not* a special case
&gt; &gt; of
&gt; &gt; the AEAD construction, since this mode uses S1 = associated data, S2
&gt; &gt; =
&gt; &gt; plaintext.
&gt; &gt;
&gt; &gt; If we need to support several modes, maybe we should have a context
&gt; &gt; struct that lets us do S2V incrementally, one element at a time,
&gt;
&gt; Let's see if that is needed. For key wrapping I know no practical
&gt; applications. I'd treat it as a separate algorithm, and we can add it
&gt; later if needed.
&gt;
&gt; &gt; &gt; Done. It needed some reorganization, and cmac128_syn is still
&gt; &gt; &gt; needed in
&gt; &gt; &gt; an ugly simulation of the CMAC structure setup to use the macros. I
&gt; &gt; &gt; have kept the union
&gt; &gt;
&gt; &gt; Maybe it would be easier without using the CMAC macros. They're
&gt; &gt; intended
&gt; &gt; for convenience, so there's little point in using them where it
&gt; &gt; doesn't
&gt; &gt; bring any convenience.
&gt;
&gt; I do not think that avoiding them would change this part.
&gt;
&gt; regards,
&gt; Nikos
&gt;
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190427152541</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-04-27 15:25:41-0400</timestampReceived><subject>Re: Intel CET protection</subject><body>

Oh sorry I did not see this email and the previous before sending my
new patches.

About git, generally git am wants to be applied in order, but I think
there may be a fuzz option to git too, never really investigated as I
usually apply all patches to a branch (or pull that branch directly
from PR branches) and then git cherry-pick if I want a specific patch
on master.

On Sat, 2019-04-27 at 09:29 +0200, Niels Möller wrote:
&gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; 
&gt; &gt; Ok attached find new patches,
&gt; &gt; they address all concerns except for adding the CET_SECTION macro
&gt; &gt; automagically to all asm files.
&gt; 
&gt; Ah, one more thing:
&gt; 
&gt; &gt; +define(&lt;GNU_CET_SECTION&gt;,
&gt; &gt; +&lt;ifelse(CET_PROTECTION,yes,
&gt; &gt; +&lt;.pushsection .note.gnu.property,"a"
&gt; 
&gt; How portable is .pushsection? If we ensure that notes are last, plain
&gt; .section should be enough, I think.

No it needs to be .pushsection, when I was using just .section the
alignment of the property was incorrect (16 instead of 8) and glibc
gurus told me to use .pushsection to properly deal with that.
If you have/want CET you also have a modern enough GCC and Assembler
that support -fcf-protection and .pushsection so I do not think it is a
problem, if you are not using NGU As, you won't be using --enable-cet-
protection either

&gt; &gt; --- a/x86_64/sha3-permute.asm
&gt; &gt; +++ b/x86_64/sha3-permute.asm
&gt; &gt; @@ -107,6 +107,7 @@ define(&lt;ROTL64&gt;, &lt;
&gt; &gt;  	
&gt; &gt;  	C sha3_permute(struct sha3_state *ctx)
&gt; &gt;  	.text
&gt; &gt; +GNU_CET_SECTION()
&gt; &gt;  	ALIGN(16)
&gt; &gt;  PROLOGUE(nettle_sha3_permute)
&gt; &gt;  	W64_ENTRY(1, 16)
&gt; 
&gt; This placement between .text and the prologue depends on .pushsection /
&gt; .popsection. I think it should be moved last, just like in the other
&gt; files, either explicitly or by means of a divert in some of the included
&gt; m4 files.

Yes I had already caught this mistake, it is fixed in the patch series
I sent a few minutes ago.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190311122508</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2019-03-11 12:25:08-0400</timestampReceived><subject>Re: FYI: fast gcm/ghash for arm neon</subject><body>

On Sun, 2019-03-10 at 11:38 +0300, Yuriy M. Kaminskiy wrote:
&gt; Currently ghash/gcm performance on arm in both gcrypt and nettle is a
&gt; bit abysmal:
&gt; === bench-slopes-nettle ===
&gt;        GCM auth |     28.43 ns/B     33.54 MiB/s     39.81
&gt; c/B    1400.2
&gt; === bench-slopes-gcrypt ===
&gt;        GCM auth |     21.86 ns/B     43.62 MiB/s     30.52
&gt; c/B    1396.0
&gt; === bench-slopes-openssl [1.1.1a] ===
&gt;        GCM auth |      5.99 ns/B     159.3 MiB/s      8.38
&gt; c/B    1399.6
&gt; === cut ===
&gt; Current openssl/cryptograms code is based on ideas from
&gt; https://hal.inria.fr/hal-01506572 (licensed CC BY 4.0)
&gt; and there are linked implementation
&gt; https://conradoplg.cryptoland.net/software/ecc-and-ae-for-arm-neon/
&gt; (licensed LGPL 2.1+), which I guess should be acceptable to borrow.
&gt; 
&gt; Very preliminary patch for nettle will be posted as reply (passes
&gt; nettle
&gt; regression test, but needs more extensive testing);
&gt; === bench-slopes-nettle [w/ patched nettle 3.3] ===
&gt;  aes128         |  nanosecs/byte   mebibytes/sec   cycles/byte
&gt;        GCM auth |      7.07 ns/B     134.9 MiB/s      9.90 c/B
&gt; === cut ===
&gt; (And not only it is notably faster, it should be completely free of
&gt; all cache/timing leaks).

Thank you for that!

regards,
Nikos


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190312120229</emailId><senderName>"Yuriy M. Kaminskiy"</senderName><senderEmail>yumkam@gmail.com</senderEmail><timestampReceived>2019-03-12 12:02:29-0400</timestampReceived><subject>[WIP][RFC][PATCH 1-3/x] chacha: add asm optimizations from Andrew Moon</subject><body>

Taken from https://github.com/floodyberry/chacha-opt (released by author
as public-domain-or-MIT, so I guess ok to borrow).

On x86/sse2 and x86_64: 80 to 100% faster.

Passes regression test on linux/debian/stretch x86 and x86_64,
benchmarks ran with patched nettle-3.4.1 (due to abi break in 3.5).
*Not* tested on win{32,64} (important: win64 ABI difference).

chacha-opt also contains x86{,_64}-{ssse3,avx{,2},xop} optimized
code, but I don't have hardware to test (and there are difference
in structure/argument layout that need to be corrected and tested).

WIP, will add armv6 and arm/neon a bit later.

P.S.
Then I will probably take a look at poly1305 and likely try to borrow
license-compatible arm asm somewhere (current nettle code is painfully
slow); gcrypt is somewhat faster than nettle and LGPLv2.1+; cryptograms
has definitely fastest crypto, but it is BSD-3-clause-or-GPLv2+;
while it is, AFAIK, compatible with LGPL, but not sure if that's
acceptable for nettle inclusion.

P.S. previously posted arm neon gcm patch breaks x86_64 compilation,
will post trivial fix later.

["0001-chacha-prepare-for-multiblock-asm-implementation.patch" (text/x-patch)]

From 7b7d54558fe4fbd20d722ee01d63b13961217416 Mon Sep 17 00:00:00 2001
From: "Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt;
Date: Mon, 11 Mar 2019 20:51:57 +0300
Subject: [PATCH 1/3] chacha: prepare for multiblock asm implementation

---
 chacha-crypt.c    | 89 +++++++++++++++++++++++++++++++++++++++++++------------
 chacha-internal.h |  4 +++
 configure.ac      |  3 ++
 3 files changed, 77 insertions(+), 19 deletions(-)

diff --git a/chacha-crypt.c b/chacha-crypt.c
index 63d799ce..03e50d97 100644
--- a/chacha-crypt.c
+++ b/chacha-crypt.c
@@ -54,34 +54,85 @@
 
 #define CHACHA_ROUNDS 20
 
+/* is the pointer aligned on a word boundary? */
+static int
+chacha_is_aligned(const void *p) {
+	return ((size_t)p &amp; (sizeof(size_t) - 1)) == 0;
+}
+
+#ifdef HAVE_NATIVE_chacha_blocks
 void
-chacha_crypt(struct chacha_ctx *ctx,
-	      size_t length,
-	      uint8_t *c,
-	      const uint8_t *m)
+_nettle_chacha_blocks_c
+#else
+#undef _chacha_blocks
+static void
+_chacha_blocks
+#endif
+	(struct chacha_ctx *ctx, const uint8_t *m, uint8_t *c, size_t length, size_t rounds)
 {
-  if (!length)
-    return;
-  
-  for (;;)
+  while(length &gt;= CHACHA_BLOCK_SIZE)
     {
       uint32_t x[_CHACHA_STATE_LENGTH];
+      uint32_t *dst = m ? x : (uint32_t *)c;
+      _chacha_core (dst, ctx-&gt;state, rounds);
+      ctx-&gt;state[13] += (++ctx-&gt;state[12] == 0);
+      /* stopping at 2^70 length per nonce is user's responsibility */
 
-      _chacha_core (x, ctx-&gt;state, CHACHA_ROUNDS);
+      if (m)
+        {
+	  memxor3 (c, m, x, CHACHA_BLOCK_SIZE);
+	  m += CHACHA_BLOCK_SIZE;
+	}
 
+      c += CHACHA_BLOCK_SIZE;
+      length -= CHACHA_BLOCK_SIZE;
+    }
+  if (length)
+    {
+      uint32_t x[_CHACHA_STATE_LENGTH];
+      _chacha_core (x, ctx-&gt;state, rounds);
       ctx-&gt;state[13] += (++ctx-&gt;state[12] == 0);
-
       /* stopping at 2^70 length per nonce is user's responsibility */
-      
-      if (length &lt;= CHACHA_BLOCK_SIZE)
-	{
+
+      if (m)
+        {
 	  memxor3 (c, m, x, length);
-	  return;
+	  m += length;
 	}
-      memxor3 (c, m, x, CHACHA_BLOCK_SIZE);
+      else
+	memcpy (c, x, length);
+    }
+}
 
-      length -= CHACHA_BLOCK_SIZE;
-      c += CHACHA_BLOCK_SIZE;
-      m += CHACHA_BLOCK_SIZE;
-  }
+void
+chacha_crypt(struct chacha_ctx *ctx,
+	      size_t length,
+	      uint8_t *c,
+	      const uint8_t *m)
+{
+  unsigned char buffer[16 * CHACHA_BLOCK_SIZE];
+  int in_aligned, out_aligned;
+  in_aligned = chacha_is_aligned(m);
+  out_aligned = chacha_is_aligned(c);
+  if (in_aligned &amp;&amp; out_aligned)
+    {
+      return _chacha_blocks(ctx, m, c, length, CHACHA_ROUNDS);
+    }
+  while (length)
+    {
+      const size_t bytes = (length &gt; sizeof(buffer)) ? sizeof(buffer) : length;
+      const unsigned char *src = m;
+      unsigned char *dst = (out_aligned) ? c : buffer;
+      if (!in_aligned)
+	{
+	  memcpy(buffer, m, bytes);
+	  src = buffer;
+	}
+      _chacha_blocks(ctx, src, dst, bytes, CHACHA_ROUNDS);
+      if (!out_aligned)
+	memcpy(c, buffer, bytes);
+      if (m) m += bytes;
+      c += bytes;
+      length -= bytes;
+    }
 }
diff --git a/chacha-internal.h b/chacha-internal.h
index 1bca8e74..2e2baea0 100644
--- a/chacha-internal.h
+++ b/chacha-internal.h
@@ -39,8 +39,12 @@
 #include "nettle-types.h"
 
 #define _chacha_core _nettle_chacha_core
+#define _chacha_blocks _nettle_chacha_blocks
 
 void
 _chacha_core(uint32_t *dst, const uint32_t *src, unsigned rounds);
 
+void
+_chacha_blocks(struct chacha_ctx *ctx, const uint8_t *src, uint8_t *dst, size_t length, size_t rounds);
+
 #endif /* NETTLE_CHACHA_INTERNAL_H_INCLUDED */
diff --git a/configure.ac b/configure.ac
index 4a482bdd..21c932a5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -468,6 +468,7 @@ asm_replace_list="aes-encrypt-internal.asm aes-decrypt-internal.asm \
 # Assembler files which generate additional object files if they are used.
 asm_nettle_optional_list="gcm-hash8.asm cpuid.asm \
   aes-encrypt-internal-2.asm aes-decrypt-internal-2.asm memxor-2.asm \
+  chacha-blocks.asm chacha-blocks-2.asm \
   chacha-core-internal-2.asm \
   gcm-hash.asm gcm-hash-2.asm \
   salsa20-core-internal-2.asm sha1-compress-2.asm sha256-compress-2.asm \
@@ -572,6 +573,8 @@ AH_VERBATIM([HAVE_NATIVE],
 [/* Define to 1 each of the following for which a native (ie. CPU specific)
     implementation of the corresponding routine exists.  */
 #undef HAVE_NATIVE_chacha_core
+#undef HAVE_NATIVE_chacha_blocks
+#undef HAVE_NATIVE_hchacha
 #undef HAVE_NATIVE_ecc_192_modp
 #undef HAVE_NATIVE_ecc_192_redc
 #undef HAVE_NATIVE_ecc_224_modp
-- 
2.11.0


["0002-chacha-blocks-add-x86_64-sse2-implementation.patch" (text/x-patch)]

From 87ad780f609971c64644bc1271fb24483c1cee75 Mon Sep 17 00:00:00 2001
From: "Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt;
Date: Tue, 12 Mar 2019 12:22:53 +0300
Subject: [PATCH 2/3] chacha-blocks: add x86_64 sse2 implementation

Adopted from public domain implementation by Andrew Moon &lt;liquidsun@gmail.com&gt;
https://github.com/floodyberry/chacha-opt
Before (AMD K8 @ 2.5GHz):
     STREAM enc |      6.27 ns/B     152.1 MiB/s     15.67 c/B
After:
     STREAM enc |      3.02 ns/B     316.3 MiB/s      7.54 c/B
---
 x86_64/chacha-blocks.asm | 826 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 826 insertions(+)
 create mode 100644 x86_64/chacha-blocks.asm

diff --git a/x86_64/chacha-blocks.asm b/x86_64/chacha-blocks.asm
new file mode 100644
index 00000000..d8ade58a
--- /dev/null
+++ b/x86_64/chacha-blocks.asm
@@ -0,0 +1,826 @@
+C x86/chacha-blocks.asm
+
+ifelse(&lt;
+   Copyright (C) 2014 Andrew Moon &lt;liquidsun@gmail.com&gt;
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+&gt;)
+
+C This file was released as Public-Domain-or-MIT at
+C https://github.com/floodyberry/chacha-opt
+
+	.file "chacha-blocks.asm"
+
+	C chacha_blocks(struct chacha_ctx *ctx,
+	C               const uint8_t *src, uint8_t *dst, size_t length,
+	C		size_t rounds)
+
+	.text
+chacha_blocks_sse2_local:
+PROLOGUE(_nettle_chacha_blocks)
+.cfi_startproc
+W64_ENTRY(5, 16)
+pushq %rbx
+.cfi_adjust_cfa_offset 8
+.cfi_rel_offset %rbx, 0
+pushq %rbp
+.cfi_adjust_cfa_offset 8
+.cfi_rel_offset %rbp, 0
+movq %rsp, %rbp
+.cfi_def_cfa_register %rbp
+andq $~63, %rsp
+subq $512, %rsp
+C movq $0x3320646e61707865, %rax
+C movq $0x6b20657479622d32, %r8
+C movd %rax, %xmm8
+C movd %r8, %xmm14
+C punpcklqdq %xmm14, %xmm8
+C movdqu 0(%rdi), %xmm9
+C movdqu 16(%rdi), %xmm10
+C movdqu 32(%rdi), %xmm11
+	movdqu 0(%rdi), %xmm8
+	movdqu 16(%rdi), %xmm9
+	movdqu 32(%rdi), %xmm10
+	movdqu 48(%rdi), %xmm11
+C movq 48(%rdi), %rax
+	movq %r8, %rax
+movq $1, %r9
+movdqa %xmm8, 0(%rsp)
+movdqa %xmm9, 16(%rsp)
+movdqa %xmm10, 32(%rsp)
+movdqa %xmm11, 48(%rsp)
+movq %rax, 64(%rsp)
+cmpq $256, %rcx
+jb .Lchacha_blocks_sse2_below256
+pshufd $0x00, %xmm8, %xmm0
+pshufd $0x55, %xmm8, %xmm1
+pshufd $0xaa, %xmm8, %xmm2
+pshufd $0xff, %xmm8, %xmm3
+movdqa %xmm0, 128(%rsp)
+movdqa %xmm1, 144(%rsp)
+movdqa %xmm2, 160(%rsp)
+movdqa %xmm3, 176(%rsp)
+pshufd $0x00, %xmm9, %xmm0
+pshufd $0x55, %xmm9, %xmm1
+pshufd $0xaa, %xmm9, %xmm2
+pshufd $0xff, %xmm9, %xmm3
+movdqa %xmm0, 192(%rsp)
+movdqa %xmm1, 208(%rsp)
+movdqa %xmm2, 224(%rsp)
+movdqa %xmm3, 240(%rsp)
+pshufd $0x00, %xmm10, %xmm0
+pshufd $0x55, %xmm10, %xmm1
+pshufd $0xaa, %xmm10, %xmm2
+pshufd $0xff, %xmm10, %xmm3
+movdqa %xmm0, 256(%rsp)
+movdqa %xmm1, 272(%rsp)
+movdqa %xmm2, 288(%rsp)
+movdqa %xmm3, 304(%rsp)
+pshufd $0xaa, %xmm11, %xmm0
+pshufd $0xff, %xmm11, %xmm1
+movdqa %xmm0, 352(%rsp)
+movdqa %xmm1, 368(%rsp)
+jmp .Lchacha_blocks_sse2_atleast256
+.p2align 6,,63
+.Lchacha_blocks_sse2_atleast256:
+movq 48(%rsp), %rax
+leaq 1(%rax), %r8
+leaq 2(%rax), %r9
+leaq 3(%rax), %r10
+leaq 4(%rax), %rbx
+movl %eax, 320(%rsp)
+movl %r8d, 4+320(%rsp)
+movl %r9d, 8+320(%rsp)
+movl %r10d, 12+320(%rsp)
+shrq $32, %rax
+shrq $32, %r8
+shrq $32, %r9
+shrq $32, %r10
+movl %eax, 336(%rsp)
+movl %r8d, 4+336(%rsp)
+movl %r9d, 8+336(%rsp)
+movl %r10d, 12+336(%rsp)
+movq %rbx, 48(%rsp)
+movq 64(%rsp), %rax
+movdqa 128(%rsp), %xmm0
+movdqa 144(%rsp), %xmm1
+movdqa 160(%rsp), %xmm2
+movdqa 176(%rsp), %xmm3
+movdqa 192(%rsp), %xmm4
+movdqa 208(%rsp), %xmm5
+movdqa 224(%rsp), %xmm6
+movdqa 240(%rsp), %xmm7
+movdqa 256(%rsp), %xmm8
+movdqa 272(%rsp), %xmm9
+movdqa 288(%rsp), %xmm10
+movdqa 304(%rsp), %xmm11
+movdqa 320(%rsp), %xmm12
+movdqa 336(%rsp), %xmm13
+movdqa 352(%rsp), %xmm14
+movdqa 368(%rsp), %xmm15
+.Lchacha_blocks_sse2_mainloop1:
+paddd %xmm4, %xmm0
+paddd %xmm5, %xmm1
+pxor %xmm0, %xmm12
+pxor %xmm1, %xmm13
+paddd %xmm6, %xmm2
+paddd %xmm7, %xmm3
+movdqa %xmm6, 96(%rsp)
+pxor %xmm2, %xmm14
+pxor %xmm3, %xmm15
+pshuflw $0xb1,%xmm12,%xmm12
+pshufhw $0xb1,%xmm12,%xmm12
+pshuflw $0xb1,%xmm13,%xmm13
+pshufhw $0xb1,%xmm13,%xmm13
+pshuflw $0xb1,%xmm14,%xmm14
+pshufhw $0xb1,%xmm14,%xmm14
+pshuflw $0xb1,%xmm15,%xmm15
+pshufhw $0xb1,%xmm15,%xmm15
+paddd %xmm12, %xmm8
+paddd %xmm13, %xmm9
+paddd %xmm14, %xmm10
+paddd %xmm15, %xmm11
+movdqa %xmm12, 112(%rsp)
+pxor %xmm8, %xmm4
+pxor %xmm9, %xmm5
+movdqa 96(%rsp), %xmm6
+movdqa %xmm4, %xmm12
+pslld $ 12, %xmm4
+psrld $20, %xmm12
+pxor %xmm12, %xmm4
+movdqa %xmm5, %xmm12
+pslld $ 12, %xmm5
+psrld $20, %xmm12
+pxor %xmm12, %xmm5
+pxor %xmm10, %xmm6
+pxor %xmm11, %xmm7
+movdqa %xmm6, %xmm12
+pslld $ 12, %xmm6
+psrld $20, %xmm12
+pxor %xmm12, %xmm6
+movdqa %xmm7, %xmm12
+pslld $ 12, %xmm7
+psrld $20, %xmm12
+pxor %xmm12, %xmm7
+movdqa 112(%rsp), %xmm12
+paddd %xmm4, %xmm0
+paddd %xmm5, %xmm1
+pxor %xmm0, %xmm12
+pxor %xmm1, %xmm13
+paddd %xmm6, %xmm2
+paddd %xmm7, %xmm3
+movdqa %xmm6, 96(%rsp)
+pxor %xmm2, %xmm14
+pxor %xmm3, %xmm15
+movdqa %xmm12, %xmm6
+pslld $ 8, %xmm12
+psrld $24, %xmm6
+pxor %xmm6, %xmm12
+movdqa %xmm13, %xmm6
+pslld $ 8, %xmm13
+psrld $24, %xmm6
+pxor %xmm6, %xmm13
+paddd %xmm12, %xmm8
+paddd %xmm13, %xmm9
+movdqa %xmm14, %xmm6
+pslld $ 8, %xmm14
+psrld $24, %xmm6
+pxor %xmm6, %xmm14
+movdqa %xmm15, %xmm6
+pslld $ 8, %xmm15
+psrld $24, %xmm6
+pxor %xmm6, %xmm15
+paddd %xmm14, %xmm10
+paddd %xmm15, %xmm11
+movdqa %xmm12, 112(%rsp)
+pxor %xmm8, %xmm4
+pxor %xmm9, %xmm5
+movdqa 96(%rsp), %xmm6
+movdqa %xmm4, %xmm12
+pslld $ 7, %xmm4
+psrld $25, %xmm12
+pxor %xmm12, %xmm4
+movdqa %xmm5, %xmm12
+pslld $ 7, %xmm5
+psrld $25, %xmm12
+pxor %xmm12, %xmm5
+pxor %xmm10, %xmm6
+pxor %xmm11, %xmm7
+movdqa %xmm6, %xmm12
+pslld $ 7, %xmm6
+psrld $25, %xmm12
+pxor %xmm12, %xmm6
+movdqa %xmm7, %xmm12
+pslld $ 7, %xmm7
+psrld $25, %xmm12
+pxor %xmm12, %xmm7
+movdqa 112(%rsp), %xmm12
+paddd %xmm5, %xmm0
+paddd %xmm6, %xmm1
+pxor %xmm0, %xmm15
+pxor %xmm1, %xmm12
+paddd %xmm7, %xmm2
+paddd %xmm4, %xmm3
+movdqa %xmm7, 96(%rsp)
+pxor %xmm2, %xmm13
+pxor %xmm3, %xmm14
+pshuflw $0xb1,%xmm15,%xmm15
+pshufhw $0xb1,%xmm15,%xmm15
+pshuflw $0xb1,%xmm12,%xmm12
+pshufhw $0xb1,%xmm12,%xmm12
+pshuflw $0xb1,%xmm13,%xmm13
+pshufhw $0xb1,%xmm13,%xmm13
+pshuflw $0xb1,%xmm14,%xmm14
+pshufhw $0xb1,%xmm14,%xmm14
+paddd %xmm15, %xmm10
+paddd %xmm12, %xmm11
+paddd %xmm13, %xmm8
+paddd %xmm14, %xmm9
+movdqa %xmm15, 112(%rsp)
+pxor %xmm10, %xmm5
+pxor %xmm11, %xmm6
+movdqa 96(%rsp), %xmm7
+movdqa %xmm5, %xmm15
+pslld $ 12, %xmm5
+psrld $20, %xmm15
+pxor %xmm15, %xmm5
+movdqa %xmm6, %xmm15
+pslld $ 12, %xmm6
+psrld $20, %xmm15
+pxor %xmm15, %xmm6
+pxor %xmm8, %xmm7
+pxor %xmm9, %xmm4
+movdqa %xmm7, %xmm15
+pslld $ 12, %xmm7
+psrld $20, %xmm15
+pxor %xmm15, %xmm7
+movdqa %xmm4, %xmm15
+pslld $ 12, %xmm4
+psrld $20, %xmm15
+pxor %xmm15, %xmm4
+movdqa 112(%rsp), %xmm15
+paddd %xmm5, %xmm0
+paddd %xmm6, %xmm1
+pxor %xmm0, %xmm15
+pxor %xmm1, %xmm12
+paddd %xmm7, %xmm2
+paddd %xmm4, %xmm3
+movdqa %xmm7, 96(%rsp)
+pxor %xmm2, %xmm13
+pxor %xmm3, %xmm14
+movdqa %xmm15, %xmm7
+pslld $ 8, %xmm15
+psrld $24, %xmm7
+pxor %xmm7, %xmm15
+movdqa %xmm12, %xmm7
+pslld $ 8, %xmm12
+psrld $24, %xmm7
+pxor %xmm7, %xmm12
+paddd %xmm15, %xmm10
+paddd %xmm12, %xmm11
+movdqa %xmm13, %xmm7
+pslld $ 8, %xmm13
+psrld $24, %xmm7
+pxor %xmm7, %xmm13
+movdqa %xmm14, %xmm7
+pslld $ 8, %xmm14
+psrld $24, %xmm7
+pxor %xmm7, %xmm14
+paddd %xmm13, %xmm8
+paddd %xmm14, %xmm9
+movdqa %xmm15, 112(%rsp)
+pxor %xmm10, %xmm5
+pxor %xmm11, %xmm6
+movdqa 96(%rsp), %xmm7
+movdqa %xmm5, %xmm15
+pslld $ 7, %xmm5
+psrld $25, %xmm15
+pxor %xmm15, %xmm5
+movdqa %xmm6, %xmm15
+pslld $ 7, %xmm6
+psrld $25, %xmm15
+pxor %xmm15, %xmm6
+pxor %xmm8, %xmm7
+pxor %xmm9, %xmm4
+movdqa %xmm7, %xmm15
+pslld $ 7, %xmm7
+psrld $25, %xmm15
+pxor %xmm15, %xmm7
+movdqa %xmm4, %xmm15
+pslld $ 7, %xmm4
+psrld $25, %xmm15
+pxor %xmm15, %xmm4
+movdqa 112(%rsp), %xmm15
+subq $2, %rax
+jnz .Lchacha_blocks_sse2_mainloop1
+paddd 128(%rsp), %xmm0
+paddd 144(%rsp), %xmm1
+paddd 160(%rsp), %xmm2
+paddd 176(%rsp), %xmm3
+paddd 192(%rsp), %xmm4
+paddd 208(%rsp), %xmm5
+paddd 224(%rsp), %xmm6
+paddd 240(%rsp), %xmm7
+paddd 256(%rsp), %xmm8
+paddd 272(%rsp), %xmm9
+paddd 288(%rsp), %xmm10
+paddd 304(%rsp), %xmm11
+paddd 320(%rsp), %xmm12
+paddd 336(%rsp), %xmm13
+paddd 352(%rsp), %xmm14
+paddd 368(%rsp), %xmm15
+movdqa %xmm8, 384(%rsp)
+movdqa %xmm9, 400(%rsp)
+movdqa %xmm10, 416(%rsp)
+movdqa %xmm11, 432(%rsp)
+movdqa %xmm12, 448(%rsp)
+movdqa %xmm13, 464(%rsp)
+movdqa %xmm14, 480(%rsp)
+movdqa %xmm15, 496(%rsp)
+movdqa %xmm0, %xmm8
+movdqa %xmm2, %xmm9
+movdqa %xmm4, %xmm10
+movdqa %xmm6, %xmm11
+punpckhdq %xmm1, %xmm0
+punpckhdq %xmm3, %xmm2
+punpckhdq %xmm5, %xmm4
+punpckhdq %xmm7, %xmm6
+punpckldq %xmm1, %xmm8
+punpckldq %xmm3, %xmm9
+punpckldq %xmm5, %xmm10
+punpckldq %xmm7, %xmm11
+movdqa %xmm0, %xmm1
+movdqa %xmm4, %xmm3
+movdqa %xmm8, %xmm5
+movdqa %xmm10, %xmm7
+punpckhqdq %xmm2, %xmm0
+punpckhqdq %xmm6, %xmm4
+punpckhqdq %xmm9, %xmm8
+punpckhqdq %xmm11, %xmm10
+punpcklqdq %xmm2, %xmm1
+punpcklqdq %xmm6, %xmm3
+punpcklqdq %xmm9, %xmm5
+punpcklqdq %xmm11, %xmm7
+andq %rsi, %rsi
+jz .Lchacha_blocks_sse2_noinput1
+movdqu 0(%rsi), %xmm2
+movdqu 16(%rsi), %xmm6
+movdqu 64(%rsi), %xmm9
+movdqu 80(%rsi), %xmm11
+movdqu 128(%rsi), %xmm12
+movdqu 144(%rsi), %xmm13
+movdqu 192(%rsi), %xmm14
+movdqu 208(%rsi), %xmm15
+pxor %xmm2, %xmm5
+pxor %xmm6, %xmm7
+pxor %xmm9, %xmm8
+pxor %xmm11, %xmm10
+pxor %xmm12, %xmm1
+pxor %xmm13, %xmm3
+pxor %xmm14, %xmm0
+pxor %xmm15, %xmm4
+movdqu %xmm5, 0(%rdx)
+movdqu %xmm7, 16(%rdx)
+movdqu %xmm8, 64(%rdx)
+movdqu %xmm10, 80(%rdx)
+movdqu %xmm1, 128(%rdx)
+movdqu %xmm3, 144(%rdx)
+movdqu %xmm0, 192(%rdx)
+movdqu %xmm4, 208(%rdx)
+movdqa 384(%rsp), %xmm0
+movdqa 400(%rsp), %xmm1
+movdqa 416(%rsp), %xmm2
+movdqa 432(%rsp), %xmm3
+movdqa 448(%rsp), %xmm4
+movdqa 464(%rsp), %xmm5
+movdqa 480(%rsp), %xmm6
+movdqa 496(%rsp), %xmm7
+movdqa %xmm0, %xmm8
+movdqa %xmm2, %xmm9
+movdqa %xmm4, %xmm10
+movdqa %xmm6, %xmm11
+punpckldq %xmm1, %xmm8
+punpckldq %xmm3, %xmm9
+punpckhdq %xmm1, %xmm0
+punpckhdq %xmm3, %xmm2
+punpckldq %xmm5, %xmm10
+punpckldq %xmm7, %xmm11
+punpckhdq %xmm5, %xmm4
+punpckhdq %xmm7, %xmm6
+movdqa %xmm8, %xmm1
+movdqa %xmm0, %xmm3
+movdqa %xmm10, %xmm5
+movdqa %xmm4, %xmm7
+punpcklqdq %xmm9, %xmm1
+punpcklqdq %xmm11, %xmm5
+punpckhqdq %xmm9, %xmm8
+punpckhqdq %xmm11, %xmm10
+punpcklqdq %xmm2, %xmm3
+punpcklqdq %xmm6, %xmm7
+punpckhqdq %xmm2, %xmm0
+punpckhqdq %xmm6, %xmm4
+movdqu 32(%rsi), %xmm2
+movdqu 48(%rsi), %xmm6
+movdqu 96(%rsi), %xmm9
+movdqu 112(%rsi), %xmm11
+movdqu 160(%rsi), %xmm12
+movdqu 176(%rsi), %xmm13
+movdqu 224(%rsi), %xmm14
+movdqu 240(%rsi), %xmm15
+pxor %xmm2, %xmm1
+pxor %xmm6, %xmm5
+pxor %xmm9, %xmm8
+pxor %xmm11, %xmm10
+pxor %xmm12, %xmm3
+pxor %xmm13, %xmm7
+pxor %xmm14, %xmm0
+pxor %xmm15, %xmm4
+movdqu %xmm1, 32(%rdx)
+movdqu %xmm5, 48(%rdx)
+movdqu %xmm8, 96(%rdx)
+movdqu %xmm10, 112(%rdx)
+movdqu %xmm3, 160(%rdx)
+movdqu %xmm7, 176(%rdx)
+movdqu %xmm0, 224(%rdx)
+movdqu %xmm4, 240(%rdx)
+addq $256, %rsi
+jmp .Lchacha_blocks_sse2_mainloop_cont
+.Lchacha_blocks_sse2_noinput1:
+movdqu %xmm5, 0(%rdx)
+movdqu %xmm7, 16(%rdx)
+movdqu %xmm8, 64(%rdx)
+movdqu %xmm10, 80(%rdx)
+movdqu %xmm1, 128(%rdx)
+movdqu %xmm3, 144(%rdx)
+movdqu %xmm0, 192(%rdx)
+movdqu %xmm4, 208(%rdx)
+movdqa 384(%rsp), %xmm0
+movdqa 400(%rsp), %xmm1
+movdqa 416(%rsp), %xmm2
+movdqa 432(%rsp), %xmm3
+movdqa 448(%rsp), %xmm4
+movdqa 464(%rsp), %xmm5
+movdqa 480(%rsp), %xmm6
+movdqa 496(%rsp), %xmm7
+movdqa %xmm0, %xmm8
+movdqa %xmm2, %xmm9
+movdqa %xmm4, %xmm10
+movdqa %xmm6, %xmm11
+punpckldq %xmm1, %xmm8
+punpckldq %xmm3, %xmm9
+punpckhdq %xmm1, %xmm0
+punpckhdq %xmm3, %xmm2
+punpckldq %xmm5, %xmm10
+punpckldq %xmm7, %xmm11
+punpckhdq %xmm5, %xmm4
+punpckhdq %xmm7, %xmm6
+movdqa %xmm8, %xmm1
+movdqa %xmm0, %xmm3
+movdqa %xmm10, %xmm5
+movdqa %xmm4, %xmm7
+punpcklqdq %xmm9, %xmm1
+punpcklqdq %xmm11, %xmm5
+punpckhqdq %xmm9, %xmm8
+punpckhqdq %xmm11, %xmm10
+punpcklqdq %xmm2, %xmm3
+punpcklqdq %xmm6, %xmm7
+punpckhqdq %xmm2, %xmm0
+punpckhqdq %xmm6, %xmm4
+movdqu %xmm1, 32(%rdx)
+movdqu %xmm5, 48(%rdx)
+movdqu %xmm8, 96(%rdx)
+movdqu %xmm10, 112(%rdx)
+movdqu %xmm3, 160(%rdx)
+movdqu %xmm7, 176(%rdx)
+movdqu %xmm0, 224(%rdx)
+movdqu %xmm4, 240(%rdx)
+.Lchacha_blocks_sse2_mainloop_cont:
+addq $256, %rdx
+subq $256, %rcx
+cmp $256, %rcx
+jae .Lchacha_blocks_sse2_atleast256
+movdqa 0(%rsp), %xmm8
+movdqa 16(%rsp), %xmm9
+movdqa 32(%rsp), %xmm10
+movdqa 48(%rsp), %xmm11
+movq $1, %r9
+.Lchacha_blocks_sse2_below256:
+movq %r9, %xmm5
+andq %rcx, %rcx
+jz .Lchacha_blocks_sse2_done
+cmpq $64, %rcx
+jae .Lchacha_blocks_sse2_above63
+movq %rdx, %r9
+andq %rsi, %rsi
+jz .Lchacha_blocks_sse2_noinput2
+movq %rcx, %r10
+movq %rsp, %rdx
+addq %r10, %rsi
+addq %r10, %rdx
+negq %r10
+.Lchacha_blocks_sse2_copyinput:
+movb (%rsi, %r10), %al
+movb %al, (%rdx, %r10)
+incq %r10
+jnz .Lchacha_blocks_sse2_copyinput
+movq %rsp, %rsi
+.Lchacha_blocks_sse2_noinput2:
+movq %rsp, %rdx
+.Lchacha_blocks_sse2_above63:
+movdqa %xmm8, %xmm0
+movdqa %xmm9, %xmm1
+movdqa %xmm10, %xmm2
+movdqa %xmm11, %xmm3
+movq 64(%rsp), %rax
+.Lchacha_blocks_sse2_mainloop2:
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+pshuflw $0xb1,%xmm3,%xmm3
+pshufhw $0xb1,%xmm3,%xmm3
+paddd %xmm3, %xmm2
+pxor %xmm2, %xmm1
+movdqa %xmm1,%xmm4
+pslld $12, %xmm1
+psrld $20, %xmm4
+pxor %xmm4, %xmm1
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+movdqa %xmm3,%xmm4
+pslld $8, %xmm3
+psrld $24, %xmm4
+pshufd $0x93,%xmm0,%xmm0
+pxor %xmm4, %xmm3
+paddd %xmm3, %xmm2
+pshufd $0x4e,%xmm3,%xmm3
+pxor %xmm2, %xmm1
+pshufd $0x39,%xmm2,%xmm2
+movdqa %xmm1,%xmm4
+pslld $7, %xmm1
+psrld $25, %xmm4
+pxor %xmm4, %xmm1
+subq $2, %rax
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+pshuflw $0xb1,%xmm3,%xmm3
+pshufhw $0xb1,%xmm3,%xmm3
+paddd %xmm3, %xmm2
+pxor %xmm2, %xmm1
+movdqa %xmm1,%xmm4
+pslld $12, %xmm1
+psrld $20, %xmm4
+pxor %xmm4, %xmm1
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+movdqa %xmm3,%xmm4
+pslld $8, %xmm3
+psrld $24, %xmm4
+pshufd $0x39,%xmm0,%xmm0
+pxor %xmm4, %xmm3
+paddd %xmm3, %xmm2
+pshufd $0x4e,%xmm3,%xmm3
+pxor %xmm2, %xmm1
+pshufd $0x93,%xmm2,%xmm2
+movdqa %xmm1,%xmm4
+pslld $7, %xmm1
+psrld $25, %xmm4
+pxor %xmm4, %xmm1
+jnz .Lchacha_blocks_sse2_mainloop2
+paddd %xmm8, %xmm0
+paddd %xmm9, %xmm1
+paddd %xmm10, %xmm2
+paddd %xmm11, %xmm3
+andq %rsi, %rsi
+jz .Lchacha_blocks_sse2_noinput3
+movdqu 0(%rsi), %xmm12
+movdqu 16(%rsi), %xmm13
+movdqu 32(%rsi), %xmm14
+movdqu 48(%rsi), %xmm15
+pxor %xmm12, %xmm0
+pxor %xmm13, %xmm1
+pxor %xmm14, %xmm2
+pxor %xmm15, %xmm3
+addq $64, %rsi
+.Lchacha_blocks_sse2_noinput3:
+movdqu %xmm0, 0(%rdx)
+movdqu %xmm1, 16(%rdx)
+movdqu %xmm2, 32(%rdx)
+movdqu %xmm3, 48(%rdx)
+paddq %xmm5, %xmm11
+cmpq $64, %rcx
+jbe .Lchacha_blocks_sse2_mainloop2_finishup
+addq $64, %rdx
+subq $64, %rcx
+jmp .Lchacha_blocks_sse2_below256
+.Lchacha_blocks_sse2_mainloop2_finishup:
+cmpq $64, %rcx
+je .Lchacha_blocks_sse2_done
+addq %rcx, %r9
+addq %rcx, %rdx
+negq %rcx
+.Lchacha_blocks_sse2_copyoutput:
+movb (%rdx, %rcx), %al
+movb %al, (%r9, %rcx)
+incq %rcx
+jnz .Lchacha_blocks_sse2_copyoutput
+.Lchacha_blocks_sse2_done:
+C movdqu %xmm11, 32(%rdi)
+	movdqu %xmm11, 48(%rdi)
+movq %rbp, %rsp
+.cfi_def_cfa_register %rsp
+popq %rbp
+.cfi_adjust_cfa_offset -8
+.cfi_restore %rbp
+popq %rbx
+.cfi_adjust_cfa_offset -8
+.cfi_restore %rbx
+W64_EXIT(5, 16)
+ret
+.cfi_endproc
+EPILOGUE(_nettle_chacha_blocks)
+
+hchacha_sse2_local:
+PROLOGUE(_nettle_hchacha)
+.cfi_startproc
+W64_ENTRY(4, 5)
+movq $0x3320646e61707865, %rax
+movq $0x6b20657479622d32, %r8
+movd %rax, %xmm0
+movd %r8, %xmm4
+punpcklqdq %xmm4, %xmm0
+movdqu 0(%rdi), %xmm1
+movdqu 16(%rdi), %xmm2
+movdqu 0(%rsi), %xmm3
+.Lhchacha_sse2_mainloop:
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+pshuflw $0xb1,%xmm3,%xmm3
+pshufhw $0xb1,%xmm3,%xmm3
+paddd %xmm3, %xmm2
+pxor %xmm2, %xmm1
+movdqa %xmm1,%xmm4
+pslld $12, %xmm1
+psrld $20, %xmm4
+pxor %xmm4, %xmm1
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+movdqa %xmm3,%xmm4
+pslld $8, %xmm3
+psrld $24, %xmm4
+pshufd $0x93,%xmm0,%xmm0
+pxor %xmm4, %xmm3
+paddd %xmm3, %xmm2
+pshufd $0x4e,%xmm3,%xmm3
+pxor %xmm2, %xmm1
+pshufd $0x39,%xmm2,%xmm2
+movdqa %xmm1,%xmm4
+pslld $7, %xmm1
+psrld $25, %xmm4
+pxor %xmm4, %xmm1
+subq $2, %rcx
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+pshuflw $0xb1,%xmm3,%xmm3
+pshufhw $0xb1,%xmm3,%xmm3
+paddd %xmm3, %xmm2
+pxor %xmm2, %xmm1
+movdqa %xmm1,%xmm4
+pslld $12, %xmm1
+psrld $20, %xmm4
+pxor %xmm4, %xmm1
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+movdqa %xmm3,%xmm4
+pslld $8, %xmm3
+psrld $24, %xmm4
+pshufd $0x39,%xmm0,%xmm0
+pxor %xmm4, %xmm3
+paddd %xmm3, %xmm2
+pshufd $0x4e,%xmm3,%xmm3
+pxor %xmm2, %xmm1
+pshufd $0x93,%xmm2,%xmm2
+movdqa %xmm1,%xmm4
+pslld $7, %xmm1
+psrld $25, %xmm4
+pxor %xmm4, %xmm1
+ja .Lhchacha_sse2_mainloop
+movdqu %xmm0, 0(%rdx)
+movdqu %xmm3, 16(%rdx)
+W64_EXIT(4, 5)
+ret
+.cfi_endproc
+EPILOGUE(_nettle_hchacha)
+
+ifelse(W64_ABI,yes,,&lt;
+C Not used in nettle, broken with W64 ABI
+PROLOGUE(_nettle_chacha)
+.cfi_startproc
+C W64_ENTRY(6, 2)
+pushq %rbp
+.cfi_adjust_cfa_offset 8
+.cfi_rel_offset %rbp, 0
+movq %rsp, %rbp
+.cfi_def_cfa_register %rbp
+subq $64, %rsp
+andq $~63, %rsp
+movdqu 0(%rdi), %xmm0
+movdqu 16(%rdi), %xmm1
+movdqa %xmm0, 0(%rsp)
+movdqa %xmm1, 16(%rsp)
+xorq %rdi, %rdi
+movq %rdi, 32(%rsp)
+movq 0(%rsi), %rsi
+movq %rsi, 40(%rsp)
+C movq %r9, 48(%rsp)
+movq %rsp, %rdi
+movq %rdx, %rsi
+movq %rcx, %rdx
+movq %r8, %rcx
+	movq %r9, %r8
+call chacha_blocks_sse2_local
+pxor %xmm0, %xmm0
+movdqa %xmm0, 0(%rsp)
+movdqa %xmm0, 16(%rsp)
+movdqa %xmm0, 32(%rsp)
+movq %rbp, %rsp
+.cfi_def_cfa_register %rsp
+popq %rbp
+.cfi_adjust_cfa_offset -8
+.cfi_restore %rbp
+C W64_EXIT(6, 2)
+ret
+.cfi_endproc
+EPILOGUE(_nettle_chacha)
+
+PROLOGUE(_nettle_xchacha)
+.cfi_startproc
+W64_ENTRY(6, 1)
+pushq %rbp
+.cfi_adjust_cfa_offset 8
+.cfi_rel_offset %rbp, 0
+pushq %rbx
+.cfi_adjust_cfa_offset 8
+.cfi_rel_offset %rbx, 0
+movq %rsp, %rbp
+.cfi_def_cfa_register %rbp
+subq $64, %rsp
+andq $~63, %rsp
+movq %rsp, %rbx
+xorq %rax, %rax
+movq %rax, 32(%rbx)
+movq 16(%rsi), %rax
+movq %rax, 40(%rbx)
+C movq %r9, 48(%rbx)
+	pushq %r9
+pushq %rdx
+pushq %rcx
+pushq %r8
+movq %rbx, %rdx
+movq %r9, %rcx
+call hchacha_sse2_local
+movq %rbx, %rdi
+popq %rcx
+popq %rdx
+popq %rsi
+	popq %r8
+call chacha_blocks_sse2_local
+pxor %xmm0, %xmm0
+movdqa %xmm0, 0(%rbx)
+movdqa %xmm0, 16(%rbx)
+movdqa %xmm0, 32(%rbx)
+movq %rbp, %rsp
+.cfi_def_cfa_register %rsp
+popq %rbx
+.cfi_adjust_cfa_offset -8
+.cfi_restore %rbx
+popq %rbp
+.cfi_adjust_cfa_offset -8
+.cfi_restore %rbp
+W64_EXIT(6, 1)
+ret
+.cfi_endproc
+EPILOGUE(_nettle_xchacha)
+&gt;)
-- 
2.11.0


["0003-chacha-blocks-add-fat-x86-sse2-implementation.patch" (text/x-patch)]

From 21b21748be8218a0a481174bf6a80cbbd749555b Mon Sep 17 00:00:00 2001
From: "Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt;
Date: Mon, 11 Mar 2019 21:20:56 +0300
Subject: [PATCH 3/3] chacha-blocks: add (fat) x86/sse2 implementation

Adopted from public domain implementation by Andrew Moon
&lt;liquidsun@gmail.com&gt;
    https://github.com/floodyberry/chacha-opt

Before (AMD K8 @ 2.5GHz):
     STREAM enc |      5.54 ns/B     172.0 MiB/s     13.86 c/B
After:
     STREAM enc |      3.11 ns/B     306.6 MiB/s      7.78 c/B
---
 Makefile.in                  |   3 +-
 configure.ac                 |  11 +
 fat-setup.h                  |   3 +
 fat-x86.c                    | 232 +++++++++++
 x86/chacha_constants_x86.inc |   7 +
 x86/fat/chacha-blocks.asm    |  37 ++
 x86/sse2/chacha-blocks.asm   | 949 +++++++++++++++++++++++++++++++++++++++++++
 7 files changed, 1241 insertions(+), 1 deletion(-)
 create mode 100644 fat-x86.c
 create mode 100644 x86/chacha_constants_x86.inc
 create mode 100644 x86/fat/chacha-blocks.asm
 create mode 100644 x86/sse2/chacha-blocks.asm

diff --git a/Makefile.in b/Makefile.in
index 83250cf3..d1cfc461 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -187,7 +187,7 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  ed25519-sha512-pubkey.c \
 		  ed25519-sha512-sign.c ed25519-sha512-verify.c
 
-OPT_SOURCES = fat-x86_64.c fat-arm.c mini-gmp.c
+OPT_SOURCES = fat-x86.c fat-x86_64.c fat-arm.c mini-gmp.c
 
 HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  base16.h base64.h bignum.h buffer.h camellia.h cast128.h \
@@ -585,6 +585,7 @@ distdir: $(DISTFILES)
 	  fi ; \
 	done
 	set -e; for d in sparc32 sparc64 x86 \
+		x86/fat x86/sse2 \
 		x86_64 x86_64/aesni x86_64/fat \
 		arm arm/neon arm/v6 arm/fat ; do \
 	  mkdir "$(distdir)/$$d" ; \
diff --git a/configure.ac b/configure.ac
index 21c932a5..fd6abbed 100644
--- a/configure.ac
+++ b/configure.ac
@@ -419,6 +419,17 @@ if test "x$enable_assembler" = xyes ; then
 	fi
       else
 	asm_path=x86
+	if test "x$enable_fat" = xyes ; then
+	  asm_path="x86/fat $asm_path"
+	  OPT_NETTLE_SOURCES="fat-x86.c $OPT_NETTLE_SOURCES"
+	else
+	  if test "x$enable_x86_aesni" = xyes ; then
+	    asm_path="x86/aesni $asm_path"
+	  fi
+	  if test "x$enable_x86_sse2" = xyes ; then
+	    asm_path="x86/aesni $asm_path"
+	  fi
+	fi
       fi
       ;;
     *sparc*)
diff --git a/fat-setup.h b/fat-setup.h
index b623ebf9..73c8e7a7 100644
--- a/fat-setup.h
+++ b/fat-setup.h
@@ -176,3 +176,6 @@ typedef void umac_nh_n_func (uint64_t *out, unsigned n, const \
uint32_t *key,  unsigned length, const uint8_t *msg);
 
 typedef void chacha_core_func(uint32_t *dst, const uint32_t *src, unsigned rounds);
+
+struct chacha_ctx;
+typedef void chacha_blocks_func(struct chacha_ctx *ctx, const uint8_t *src, uint8_t \
                *dst, size_t length, size_t rounds);
diff --git a/fat-x86.c b/fat-x86.c
new file mode 100644
index 00000000..9d4e6bda
--- /dev/null
+++ b/fat-x86.c
@@ -0,0 +1,232 @@
+/* fat-x86_64.c
+
+   Copyright (C) 2015 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#define _GNU_SOURCE
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "nettle-types.h"
+
+#include "aes-internal.h"
+#include "memxor.h"
+#include "fat-setup.h"
+
+#if 0
+void _nettle_cpuid (uint32_t input, uint32_t regs[4]);
+#endif
+
+struct x86_features
+{
+#if 0
+  enum x86_vendor { X86_OTHER, X86_INTEL, X86_AMD } vendor;
+  int have_aesni;
+#endif
+  int have_sse2;
+};
+
+#define SKIP(s, slen, literal, llen)				\
+  (((slen) &gt;= (llen) &amp;&amp; memcmp ((s), (literal), llen) == 0)	\
+   ? ((slen) -= (llen), (s) += (llen), 1) : 0)
+#define MATCH(s, slen, literal, llen)				\
+  ((slen) == (llen) &amp;&amp; memcmp ((s), (literal), llen) == 0)
+
+static void
+get_x86_features (struct x86_features *features)
+{
+  const char *s;
+#if 0
+  features-&gt;vendor = X86_OTHER;
+  features-&gt;have_aesni = 0;
+#endif
+  features-&gt;have_sse2 = 0;
+
+  s = secure_getenv (ENV_OVERRIDE);
+  if (s)
+    for (;;)
+      {
+	const char *sep = strchr (s, ',');
+	size_t length = sep ? (size_t) (sep - s) : strlen(s);
+
+#if 0
+	if (SKIP (s, length, "vendor:", 7))
+	  {
+	    if (MATCH(s, length, "intel", 5))
+	      features-&gt;vendor = X86_INTEL;
+	    else if (MATCH(s, length, "amd", 3))
+	      features-&gt;vendor = X86_AMD;
+	    
+	  }
+	else
+	if (MATCH (s, length, "aesni", 5))
+	  features-&gt;have_aesni = 1;
+	else
+#endif
+	if (MATCH (s, length, "sse2", 4))
+	  features-&gt;have_sse2 = 1;
+	if (!sep)
+	  break;
+	s = sep + 1;	
+      }
+  else
+    {
+#if 0
+      uint32_t cpuid_data[4];
+      _nettle_cpuid (0, cpuid_data);
+      if (memcmp (cpuid_data + 1, "Genu" "ntel" "ineI", 12) == 0)
+	features-&gt;vendor = X86_INTEL;
+      else if (memcmp (cpuid_data + 1, "Auth" "cAMD" "enti", 12) == 0)
+	features-&gt;vendor = X86_AMD;
+
+      _nettle_cpuid (1, cpuid_data);
+      if (cpuid_data[2] &amp; 0x02000000)
+	features-&gt;have_aesni = 1;      
+#endif
+#if __GNUC__ &amp;&amp; __GNUC__ &gt;= 6 /* arbitrary */
+      if (__builtin_cpu_supports("sse2"))
+	features-&gt;have_sse2 = 1;
+#endif
+    }
+}
+
+#if 0
+DECLARE_FAT_FUNC(_nettle_aes_encrypt, aes_crypt_internal_func)
+DECLARE_FAT_FUNC_VAR(aes_encrypt, aes_crypt_internal_func, x86_64)
+DECLARE_FAT_FUNC_VAR(aes_encrypt, aes_crypt_internal_func, aesni)
+
+DECLARE_FAT_FUNC(_nettle_aes_decrypt, aes_crypt_internal_func)
+DECLARE_FAT_FUNC_VAR(aes_decrypt, aes_crypt_internal_func, x86_64)
+DECLARE_FAT_FUNC_VAR(aes_decrypt, aes_crypt_internal_func, aesni)
+
+DECLARE_FAT_FUNC(nettle_memxor, memxor_func)
+DECLARE_FAT_FUNC_VAR(memxor, memxor_func, x86_64)
+DECLARE_FAT_FUNC_VAR(memxor, memxor_func, sse2)
+#endif
+DECLARE_FAT_FUNC(_nettle_chacha_blocks, chacha_blocks_func)
+DECLARE_FAT_FUNC_VAR(chacha_blocks, chacha_blocks_func, c)
+DECLARE_FAT_FUNC_VAR(chacha_blocks, chacha_blocks_func, sse2)
+
+/* This function should usually be called only once, at startup. But
+   it is idempotent, and on x86, pointer updates are atomic, so
+   there's no danger if it is called simultaneously from multiple
+   threads. */
+static void CONSTRUCTOR
+fat_init (void)
+{
+  struct x86_features features;
+  int verbose;
+
+  /* FIXME: Replace all getenv calls by getenv_secure? */
+  verbose = getenv (ENV_VERBOSE) != NULL;
+  if (verbose)
+    fprintf (stderr, "libnettle: fat library initialization.\n");
+
+  get_x86_features (&amp;features);
+#if 0
+  if (verbose)
+    {
+      const char * const vendor_names[3] =
+	{ "other", "intel", "amd" };
+      fprintf (stderr, "libnettle: cpu features: vendor:%s%s\n",
+	       vendor_names[features.vendor],
+	       features.have_aesni ? ",aesni" : "");
+    }
+  if (features.have_aesni)
+    {
+      if (verbose)
+	fprintf (stderr, "libnettle: using aes instructions.\n");
+      _nettle_aes_encrypt_vec = _nettle_aes_encrypt_aesni;
+      _nettle_aes_decrypt_vec = _nettle_aes_decrypt_aesni;
+    }
+  else
+    {
+      if (verbose)
+	fprintf (stderr, "libnettle: not using aes instructions.\n");
+      _nettle_aes_encrypt_vec = _nettle_aes_encrypt_x86_64;
+      _nettle_aes_decrypt_vec = _nettle_aes_decrypt_x86_64;
+    }
+
+  if (features.vendor == X86_INTEL)
+    {
+      if (verbose)
+	fprintf (stderr, "libnettle: intel SSE2 will be used for memxor.\n");
+      nettle_memxor_vec = _nettle_memxor_sse2;
+    }
+  else
+    {
+      if (verbose)
+	fprintf (stderr, "libnettle: intel SSE2 will not be used for memxor.\n");
+      nettle_memxor_vec = _nettle_memxor_x86_64;
+    }
+#endif
+  if (features.have_sse2)
+    {
+      if (verbose)
+	fprintf (stderr, "libnettle: using sse2 instructions.\n");
+      _nettle_chacha_blocks_vec = _nettle_chacha_blocks_sse2;
+    }
+  else
+    {
+      if (verbose)
+	fprintf (stderr, "libnettle: not using sse2 instructions.\n");
+      _nettle_chacha_blocks_vec = _nettle_chacha_blocks_c;
+    }
+}
+
+#if 0
+DEFINE_FAT_FUNC(_nettle_aes_encrypt, void,
+		(unsigned rounds, const uint32_t *keys,
+		 const struct aes_table *T,
+		 size_t length, uint8_t *dst,
+		 const uint8_t *src),
+		(rounds, keys, T, length, dst, src))
+
+DEFINE_FAT_FUNC(_nettle_aes_decrypt, void,
+		(unsigned rounds, const uint32_t *keys,
+		 const struct aes_table *T,
+		 size_t length, uint8_t *dst,
+		 const uint8_t *src),
+		(rounds, keys, T, length, dst, src))
+
+DEFINE_FAT_FUNC(nettle_memxor, void *,
+		(void *dst, const void *src, size_t n),
+		(dst, src, n))
+#endif
+
+DEFINE_FAT_FUNC(_nettle_chacha_blocks, void,
+		(struct chacha_ctx *ctx, const uint8_t *src, uint8_t *dst, size_t length, size_t \
rounds), +		(ctx, src, dst, length, rounds))
diff --git a/x86/chacha_constants_x86.inc b/x86/chacha_constants_x86.inc
new file mode 100644
index 00000000..79b9881b
--- /dev/null
+++ b/x86/chacha_constants_x86.inc
@@ -0,0 +1,7 @@
+.section .rodata
+.p2align 4,,15
+chacha_constants:
+.long 0x61707865,0x3320646e,0x79622d32,0x6b206574 /* "expand 32-byte k" */
+.byte 2,3,0,1,6,7,4,5,10,11,8,9,14,15,12,13       /* pshufb rotate by 16 */
+.byte 3,0,1,2,7,4,5,6,11,8,9,10,15,12,13,14       /* pshufb rotate by 8 */
+
diff --git a/x86/fat/chacha-blocks.asm b/x86/fat/chacha-blocks.asm
new file mode 100644
index 00000000..98d5c8a6
--- /dev/null
+++ b/x86/fat/chacha-blocks.asm
@@ -0,0 +1,37 @@
+C x86/fat/chacha-blocks.asm
+
+ifelse(&lt;
+   Copyright (C) 2015 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+&gt;)
+
+dnl PROLOGUE(_nettle_chacha_blocks) picked up by configure
+dnl PROLOGUE(_nettle_hchacha) picked up by configure
+
+define(&lt;fat_transform&gt;, &lt;$1_sse2&gt;)
+include_src(&lt;x86/sse2/chacha-blocks.asm&gt;)
diff --git a/x86/sse2/chacha-blocks.asm b/x86/sse2/chacha-blocks.asm
new file mode 100644
index 00000000..786db7b7
--- /dev/null
+++ b/x86/sse2/chacha-blocks.asm
@@ -0,0 +1,949 @@
+C x86/chacha-blocks.asm
+
+ifelse(&lt;
+   Copyright (C) 2014 Andrew Moon &lt;liquidsun@gmail.com&gt;
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+&gt;)
+
+C This file was released as Public-Domain-or-MIT at
+C https://github.com/floodyberry/chacha-opt
+
+	.file "chacha-blocks.asm"
+
+	C chacha_blocks(struct chacha_ctx *ctx,
+	C               const uint8_t *src, uint8_t *dst, size_t length,
+	C		unsigned rounds)
+	.text
+.macro LOAD_VAR_PIC var, reg
+	call 1f
+	1:
+	popl \reg
+	leal \var - 1b(\reg), \reg
+.endm
+	ALIGN(16)
+chacha_blocks_sse2_local:
+PROLOGUE(_nettle_chacha_blocks)
+.cfi_startproc
+pushl %ebp
+.cfi_adjust_cfa_offset 4
+.cfi_rel_offset %ebp, 0
+.cfi_def_cfa_register %ebp
+	pushl %ebx
+.cfi_adjust_cfa_offset 4
+.cfi_rel_offset %ebx, 0
+	pushl %esi
+.cfi_adjust_cfa_offset 4
+.cfi_rel_offset %esi, 0
+	pushl %edi
+.cfi_adjust_cfa_offset 4
+.cfi_rel_offset %edi, 0
+movl %esp, %ebp
+andl $~63, %esp
+sub $704, %esp
+C movl %ebx,68(%esp)
+C movl %esi,72(%esp
+C movl %edi,76(%esp)
+C movl 8(%ebp),%ecx
+	movl 8+12(%ebp),%ecx
+movl %ecx,84(%esp)
+C movl 12(%ebp),%esi
+	movl 12+12(%ebp),%esi
+C movl 16(%ebp),%edx
+	movl 16+12(%ebp),%edx
+C movl 20(%ebp),%eax
+	movl 20+12(%ebp),%eax
+C LOAD_VAR_PIC chacha_constants, %ebx
+C movdqa 0(%ebx), %xmm0
+C movdqu 0(%ecx),%xmm1
+C movdqu 16(%ecx),%xmm2
+C movdqu 32(%ecx),%xmm3
+	movdqu 0(%ecx), %xmm0
+	movdqu 16(%ecx), %xmm1
+	movdqu 32(%ecx), %xmm2
+	movdqu 48(%ecx), %xmm3
+movdqa %xmm0,0(%esp)
+movdqa %xmm1,16(%esp)
+movdqa %xmm2,32(%esp)
+movdqa %xmm3,48(%esp)
+C movl 48(%ecx),%ecx
+	movl 24+12(%ebp),%ecx
+movl %ecx,88(%esp)
+cmpl $0,%eax
+jbe .Lchacha_blocks_sse2_done
+cmpl $256,%eax
+jb .Lchacha_blocks_sse2_bytesbetween1and255
+pshufd $0x00, %xmm0, %xmm4
+pshufd $0x55, %xmm0, %xmm5
+pshufd $0xaa, %xmm0, %xmm6
+pshufd $0xff, %xmm0, %xmm0
+movdqa %xmm4,128(%esp)
+movdqa %xmm5,144(%esp)
+movdqa %xmm6,160(%esp)
+movdqa %xmm0,176(%esp)
+pshufd $0x00, %xmm1, %xmm0
+pshufd $0x55, %xmm1, %xmm4
+pshufd $0xaa, %xmm1, %xmm5
+pshufd $0xff, %xmm1, %xmm1
+movdqa %xmm0,192(%esp)
+movdqa %xmm4,208(%esp)
+movdqa %xmm5,224(%esp)
+movdqa %xmm1,240(%esp)
+pshufd $0x00, %xmm2, %xmm0
+pshufd $0x55, %xmm2, %xmm1
+pshufd $0xaa, %xmm2, %xmm4
+pshufd $0xff, %xmm2, %xmm2
+movdqa %xmm0,256(%esp)
+movdqa %xmm1,272(%esp)
+movdqa %xmm4,288(%esp)
+movdqa %xmm2,304(%esp)
+pshufd $0xaa, %xmm3, %xmm0
+pshufd $0xff, %xmm3, %xmm1
+movdqa %xmm0,352(%esp)
+movdqa %xmm1,368(%esp)
+.Lchacha_blocks_sse2_bytesatleast256:
+movl 48(%esp),%ecx
+movl 4+48(%esp),%ebx
+movl %ecx,320(%esp)
+movl %ebx,336(%esp)
+addl $1,%ecx
+adcl $0,%ebx
+movl %ecx,4+320(%esp)
+movl %ebx,4+336(%esp)
+addl $1,%ecx
+adcl $0,%ebx
+movl %ecx,8+320(%esp)
+movl %ebx,8+336(%esp)
+addl $1,%ecx
+adcl $0,%ebx
+movl %ecx,12+320(%esp)
+movl %ebx,12+336(%esp)
+addl $1,%ecx
+adcl $0,%ebx
+movl %ecx,48(%esp)
+movl %ebx,4+48(%esp)
+movl %eax,92(%esp)
+movl 88(%esp),%eax
+movdqa 160(%esp),%xmm0
+movdqa 224(%esp),%xmm1
+movdqa 288(%esp),%xmm2
+movdqa 352(%esp),%xmm3
+movdqa 176(%esp),%xmm4
+movdqa 240(%esp),%xmm5
+movdqa 304(%esp),%xmm6
+movdqa 368(%esp),%xmm7
+movdqa %xmm0,480(%esp)
+movdqa %xmm1,544(%esp)
+movdqa %xmm2,608(%esp)
+movdqa %xmm3,672(%esp)
+movdqa %xmm4,496(%esp)
+movdqa %xmm5,560(%esp)
+movdqa %xmm6,624(%esp)
+movdqa %xmm7,688(%esp)
+movdqa 128(%esp),%xmm0
+movdqa 192(%esp),%xmm1
+movdqa 256(%esp),%xmm2
+movdqa 320(%esp),%xmm3
+movdqa 144(%esp),%xmm4
+movdqa 208(%esp),%xmm5
+movdqa 272(%esp),%xmm6
+movdqa 336(%esp),%xmm7
+jmp .Lchacha_blocks_sse2_mainloop1
+.p2align 6
+.Lchacha_blocks_sse2_mainloop1:
+paddd %xmm1, %xmm0
+paddd %xmm5, %xmm4
+pxor %xmm0, %xmm3
+pxor %xmm4, %xmm7
+pshuflw $0xb1,%xmm3,%xmm3
+pshuflw $0xb1,%xmm7,%xmm7
+pshufhw $0xb1,%xmm3,%xmm3
+pshufhw $0xb1,%xmm7,%xmm7
+movdqa %xmm4, 464(%esp)
+paddd %xmm3, %xmm2
+paddd %xmm7, %xmm6
+pxor %xmm2, %xmm1
+pxor %xmm6, %xmm5
+movdqa %xmm1, %xmm4
+pslld $12, %xmm1
+psrld $20, %xmm4
+por %xmm4, %xmm1
+movdqa %xmm5, %xmm4
+pslld $12, %xmm5
+psrld $20, %xmm4
+por %xmm4, %xmm5
+movdqa 464(%esp), %xmm4
+paddd %xmm1, %xmm0
+paddd %xmm5, %xmm4
+pxor %xmm0, %xmm3
+pxor %xmm4, %xmm7
+movdqa %xmm0, 448(%esp)
+movdqa %xmm4, 464(%esp)
+movdqa %xmm3, %xmm4
+pslld $8, %xmm3
+psrld $24, %xmm4
+por %xmm4, %xmm3
+movdqa %xmm7, %xmm4
+pslld $8, %xmm7
+psrld $24, %xmm4
+por %xmm4, %xmm7
+paddd %xmm3, %xmm2
+paddd %xmm7, %xmm6
+movdqa %xmm3, 640(%esp)
+movdqa %xmm7, 656(%esp)
+pxor %xmm2, %xmm1
+pxor %xmm6, %xmm5
+movdqa %xmm2, 576(%esp)
+movdqa %xmm6, 592(%esp)
+movdqa %xmm1,%xmm4
+pslld $7, %xmm1
+movdqa 672(%esp), %xmm3
+psrld $25, %xmm4
+movdqa 688(%esp), %xmm7
+por %xmm4, %xmm1
+movdqa %xmm1, 512(%esp)
+movdqa %xmm5, %xmm0
+pslld $7, %xmm5
+movdqa 608(%esp), %xmm2
+psrld $25, %xmm0
+movdqa 624(%esp), %xmm6
+por %xmm0, %xmm5
+movdqa %xmm5, 528(%esp)
+movdqa 480(%esp), %xmm0
+movdqa 496(%esp), %xmm4
+movdqa 544(%esp), %xmm1
+movdqa 560(%esp), %xmm5
+paddd %xmm1, %xmm0
+paddd %xmm5, %xmm4
+pxor %xmm0, %xmm3
+pxor %xmm4, %xmm7
+pshuflw $0xb1,%xmm3,%xmm3
+pshuflw $0xb1,%xmm7,%xmm7
+pshufhw $0xb1,%xmm3,%xmm3
+pshufhw $0xb1,%xmm7,%xmm7
+movdqa %xmm4, 496(%esp)
+paddd %xmm3, %xmm2
+paddd %xmm7, %xmm6
+pxor %xmm2, %xmm1
+pxor %xmm6, %xmm5
+movdqa %xmm1, %xmm4
+pslld $12, %xmm1
+psrld $20, %xmm4
+por %xmm4, %xmm1
+movdqa %xmm5, %xmm4
+pslld $12, %xmm5
+psrld $20, %xmm4
+por %xmm4, %xmm5
+movdqa 496(%esp), %xmm4
+paddd %xmm1, %xmm0
+paddd %xmm5, %xmm4
+pxor %xmm0, %xmm3
+pxor %xmm4, %xmm7
+movdqa %xmm0, 480(%esp)
+movdqa %xmm4, 496(%esp)
+movdqa %xmm3, %xmm4
+pslld $8, %xmm3
+psrld $24, %xmm4
+por %xmm4, %xmm3
+movdqa %xmm7, %xmm4
+pslld $8, %xmm7
+psrld $24, %xmm4
+por %xmm4, %xmm7
+paddd %xmm3, %xmm2
+paddd %xmm7, %xmm6
+movdqa %xmm3, 672(%esp)
+pxor %xmm2, %xmm1
+pxor %xmm6, %xmm5
+movdqa %xmm1,%xmm4
+pslld $7, %xmm1
+psrld $25, %xmm4
+movdqa 640(%esp), %xmm3
+por %xmm4, %xmm1
+movdqa %xmm5, %xmm0
+pslld $7, %xmm5
+psrld $25, %xmm0
+por %xmm0, %xmm5
+movdqa %xmm5, 560(%esp)
+movdqa 448(%esp), %xmm0
+movdqa 528(%esp), %xmm5
+movdqa 464(%esp), %xmm4
+paddd %xmm5, %xmm0
+paddd %xmm1, %xmm4
+pxor %xmm0, %xmm7
+pxor %xmm4, %xmm3
+pshuflw $0xb1,%xmm7,%xmm7
+pshuflw $0xb1,%xmm3,%xmm3
+pshufhw $0xb1,%xmm7,%xmm7
+pshufhw $0xb1,%xmm3,%xmm3
+movdqa %xmm4, 464(%esp)
+paddd %xmm7, %xmm2
+paddd %xmm3, %xmm6
+pxor %xmm2, %xmm5
+pxor %xmm6, %xmm1
+movdqa %xmm5, %xmm4
+pslld $12, %xmm5
+psrld $20, %xmm4
+por %xmm4, %xmm5
+movdqa %xmm1, %xmm4
+pslld $12, %xmm1
+psrld $20, %xmm4
+por %xmm4, %xmm1
+movdqa 464(%esp), %xmm4
+paddd %xmm5, %xmm0
+paddd %xmm1, %xmm4
+pxor %xmm0, %xmm7
+pxor %xmm4, %xmm3
+movdqa %xmm0, 448(%esp)
+movdqa %xmm4, 464(%esp)
+movdqa %xmm7, %xmm4
+pslld $8, %xmm7
+psrld $24, %xmm4
+por %xmm4, %xmm7
+movdqa %xmm3, %xmm4
+pslld $8, %xmm3
+psrld $24, %xmm4
+por %xmm4, %xmm3
+paddd %xmm7, %xmm2
+paddd %xmm3, %xmm6
+movdqa %xmm7, 688(%esp)
+movdqa %xmm3, 640(%esp)
+pxor %xmm2, %xmm5
+pxor %xmm6, %xmm1
+movdqa %xmm2, 608(%esp)
+movdqa %xmm6, 624(%esp)
+movdqa %xmm5,%xmm4
+pslld $7, %xmm5
+movdqa 656(%esp), %xmm7
+psrld $25, %xmm4
+movdqa 672(%esp), %xmm3
+por %xmm4, %xmm5
+movdqa %xmm5, 528(%esp)
+movdqa %xmm1, %xmm0
+pslld $7, %xmm1
+movdqa 576(%esp), %xmm2
+psrld $25, %xmm0
+movdqa 592(%esp), %xmm6
+por %xmm0, %xmm1
+movdqa %xmm1, 544(%esp)
+movdqa 480(%esp), %xmm0
+movdqa 496(%esp), %xmm4
+movdqa 560(%esp), %xmm5
+movdqa 512(%esp), %xmm1
+paddd %xmm5, %xmm0
+paddd %xmm1, %xmm4
+pxor %xmm0, %xmm7
+pxor %xmm4, %xmm3
+pshuflw $0xb1,%xmm7,%xmm7
+pshuflw $0xb1,%xmm3,%xmm3
+pshufhw $0xb1,%xmm7,%xmm7
+pshufhw $0xb1,%xmm3,%xmm3
+movdqa %xmm4, 496(%esp)
+paddd %xmm7, %xmm2
+paddd %xmm3, %xmm6
+pxor %xmm2, %xmm5
+pxor %xmm6, %xmm1
+movdqa %xmm5, %xmm4
+pslld $12, %xmm5
+psrld $20, %xmm4
+por %xmm4, %xmm5
+movdqa %xmm1, %xmm4
+pslld $12, %xmm1
+psrld $20, %xmm4
+por %xmm4, %xmm1
+movdqa 496(%esp), %xmm4
+paddd %xmm5, %xmm0
+paddd %xmm1, %xmm4
+pxor %xmm0, %xmm7
+pxor %xmm4, %xmm3
+movdqa %xmm0, 480(%esp)
+movdqa %xmm4, 496(%esp)
+movdqa %xmm7, %xmm4
+pslld $8, %xmm7
+psrld $24, %xmm4
+por %xmm4, %xmm7
+movdqa %xmm3, %xmm4
+pslld $8, %xmm3
+psrld $24, %xmm4
+por %xmm4, %xmm3
+paddd %xmm7, %xmm2
+paddd %xmm3, %xmm6
+movdqa %xmm3, 672(%esp)
+pxor %xmm2, %xmm5
+pxor %xmm6, %xmm1
+movdqa %xmm5,%xmm4
+pslld $7, %xmm5
+psrld $25, %xmm4
+movdqa 640(%esp), %xmm3
+por %xmm4, %xmm5
+movdqa %xmm5, 560(%esp)
+movdqa %xmm1, %xmm0
+pslld $7, %xmm1
+psrld $25, %xmm0
+por %xmm0, %xmm1
+movdqa 448(%esp), %xmm0
+movdqa 464(%esp), %xmm4
+movdqa 528(%esp), %xmm5
+subl $2,%eax
+ja .Lchacha_blocks_sse2_mainloop1
+movdqa %xmm0, 448(%esp)
+movdqa %xmm1, 512(%esp)
+movdqa %xmm2, 576(%esp)
+movdqa %xmm3, 640(%esp)
+movdqa %xmm4, 464(%esp)
+movdqa %xmm5, 528(%esp)
+movdqa %xmm6, 592(%esp)
+movdqa %xmm7, 656(%esp)
+cmpl $0,%esi
+movdqa 448(%esp),%xmm0
+movdqa 464(%esp),%xmm1
+movdqa 480(%esp),%xmm2
+movdqa 496(%esp),%xmm3
+paddd 128(%esp), %xmm0
+paddd 144(%esp), %xmm1
+paddd 160(%esp), %xmm2
+paddd 176(%esp), %xmm3
+movdqa %xmm0, %xmm4
+movdqa %xmm2, %xmm5
+punpckldq %xmm1, %xmm4
+punpckldq %xmm3, %xmm5
+punpckhdq %xmm1, %xmm0
+punpckhdq %xmm3, %xmm2
+movdqa %xmm4, %xmm1
+movdqa %xmm0, %xmm3
+punpcklqdq %xmm5, %xmm4
+punpckhqdq %xmm5, %xmm1
+punpcklqdq %xmm2, %xmm0
+punpckhqdq %xmm2, %xmm3
+jbe .Lchacha_blocks_sse2_noinput1
+movdqu 0(%esi), %xmm2
+movdqu 64(%esi), %xmm5
+movdqu 128(%esi), %xmm6
+movdqu 192(%esi), %xmm7
+pxor %xmm2, %xmm4
+pxor %xmm5, %xmm1
+pxor %xmm6, %xmm0
+pxor %xmm7, %xmm3
+movdqu %xmm4, 0(%edx)
+movdqu %xmm1, 64(%edx)
+movdqu %xmm0, 128(%edx)
+movdqu %xmm3, 192(%edx)
+movdqa 512(%esp),%xmm0
+movdqa 528(%esp),%xmm1
+movdqa 544(%esp),%xmm2
+movdqa 560(%esp),%xmm3
+paddd 192(%esp), %xmm0
+paddd 208(%esp), %xmm1
+paddd 224(%esp), %xmm2
+paddd 240(%esp), %xmm3
+movdqa %xmm0, %xmm4
+movdqa %xmm2, %xmm5
+punpckldq %xmm1, %xmm4
+punpckldq %xmm3, %xmm5
+punpckhdq %xmm1, %xmm0
+punpckhdq %xmm3, %xmm2
+movdqa %xmm4, %xmm1
+movdqa %xmm0, %xmm3
+punpcklqdq %xmm5, %xmm4
+punpckhqdq %xmm5, %xmm1
+punpcklqdq %xmm2, %xmm0
+punpckhqdq %xmm2, %xmm3
+movdqu 16+0(%esi), %xmm2
+movdqu 16+64(%esi), %xmm5
+movdqu 16+128(%esi), %xmm6
+movdqu 16+192(%esi), %xmm7
+pxor %xmm2, %xmm4
+pxor %xmm5, %xmm1
+pxor %xmm6, %xmm0
+pxor %xmm7, %xmm3
+movdqu %xmm4, 16+0(%edx)
+movdqu %xmm1, 16+64(%edx)
+movdqu %xmm0, 16+128(%edx)
+movdqu %xmm3, 16+192(%edx)
+movdqa 576(%esp),%xmm0
+movdqa 592(%esp),%xmm1
+movdqa 608(%esp),%xmm2
+movdqa 624(%esp),%xmm3
+paddd 256(%esp), %xmm0
+paddd 272(%esp), %xmm1
+paddd 288(%esp), %xmm2
+paddd 304(%esp), %xmm3
+movdqa %xmm0, %xmm4
+movdqa %xmm2, %xmm5
+punpckldq %xmm1, %xmm4
+punpckldq %xmm3, %xmm5
+punpckhdq %xmm1, %xmm0
+punpckhdq %xmm3, %xmm2
+movdqa %xmm4, %xmm1
+movdqa %xmm0, %xmm3
+punpcklqdq %xmm5, %xmm4
+punpckhqdq %xmm5, %xmm1
+punpcklqdq %xmm2, %xmm0
+punpckhqdq %xmm2, %xmm3
+movdqu 32+0(%esi), %xmm2
+movdqu 32+64(%esi), %xmm5
+movdqu 32+128(%esi), %xmm6
+movdqu 32+192(%esi), %xmm7
+pxor %xmm2, %xmm4
+pxor %xmm5, %xmm1
+pxor %xmm6, %xmm0
+pxor %xmm7, %xmm3
+movdqu %xmm4, 32+0(%edx)
+movdqu %xmm1, 32+64(%edx)
+movdqu %xmm0, 32+128(%edx)
+movdqu %xmm3, 32+192(%edx)
+movdqa 640(%esp),%xmm0
+movdqa 656(%esp),%xmm1
+movdqa 672(%esp),%xmm2
+movdqa 688(%esp),%xmm3
+paddd 320(%esp), %xmm0
+paddd 336(%esp), %xmm1
+paddd 352(%esp), %xmm2
+paddd 368(%esp), %xmm3
+movdqa %xmm0, %xmm4
+movdqa %xmm2, %xmm5
+punpckldq %xmm1, %xmm4
+punpckldq %xmm3, %xmm5
+punpckhdq %xmm1, %xmm0
+punpckhdq %xmm3, %xmm2
+movdqa %xmm4, %xmm1
+movdqa %xmm0, %xmm3
+punpcklqdq %xmm5, %xmm4
+punpckhqdq %xmm5, %xmm1
+punpcklqdq %xmm2, %xmm0
+punpckhqdq %xmm2, %xmm3
+movdqu 48+0(%esi), %xmm2
+movdqu 48+64(%esi), %xmm5
+movdqu 48+128(%esi), %xmm6
+movdqu 48+192(%esi), %xmm7
+pxor %xmm2, %xmm4
+pxor %xmm5, %xmm1
+pxor %xmm6, %xmm0
+pxor %xmm7, %xmm3
+movdqu %xmm4, 48+0(%edx)
+movdqu %xmm1, 48+64(%edx)
+movdqu %xmm0, 48+128(%edx)
+movdqu %xmm3, 48+192(%edx)
+addl $256,%esi
+jmp .Lchacha_blocks_sse2_mainloop1_cont
+.Lchacha_blocks_sse2_noinput1:
+movdqu %xmm4, 0(%edx)
+movdqu %xmm1, 64(%edx)
+movdqu %xmm0, 128(%edx)
+movdqu %xmm3, 192(%edx)
+movdqa 512(%esp),%xmm0
+movdqa 528(%esp),%xmm1
+movdqa 544(%esp),%xmm2
+movdqa 560(%esp),%xmm3
+paddd 192(%esp), %xmm0
+paddd 208(%esp), %xmm1
+paddd 224(%esp), %xmm2
+paddd 240(%esp), %xmm3
+movdqa %xmm0, %xmm4
+movdqa %xmm2, %xmm5
+punpckldq %xmm1, %xmm4
+punpckldq %xmm3, %xmm5
+punpckhdq %xmm1, %xmm0
+punpckhdq %xmm3, %xmm2
+movdqa %xmm4, %xmm1
+movdqa %xmm0, %xmm3
+punpcklqdq %xmm5, %xmm4
+punpckhqdq %xmm5, %xmm1
+punpcklqdq %xmm2, %xmm0
+punpckhqdq %xmm2, %xmm3
+movdqu %xmm4, 16+0(%edx)
+movdqu %xmm1, 16+64(%edx)
+movdqu %xmm0, 16+128(%edx)
+movdqu %xmm3, 16+192(%edx)
+movdqa 576(%esp),%xmm0
+movdqa 592(%esp),%xmm1
+movdqa 608(%esp),%xmm2
+movdqa 624(%esp),%xmm3
+paddd 256(%esp), %xmm0
+paddd 272(%esp), %xmm1
+paddd 288(%esp), %xmm2
+paddd 304(%esp), %xmm3
+movdqa %xmm0, %xmm4
+movdqa %xmm2, %xmm5
+punpckldq %xmm1, %xmm4
+punpckldq %xmm3, %xmm5
+punpckhdq %xmm1, %xmm0
+punpckhdq %xmm3, %xmm2
+movdqa %xmm4, %xmm1
+movdqa %xmm0, %xmm3
+punpcklqdq %xmm5, %xmm4
+punpckhqdq %xmm5, %xmm1
+punpcklqdq %xmm2, %xmm0
+punpckhqdq %xmm2, %xmm3
+movdqu %xmm4, 32+0(%edx)
+movdqu %xmm1, 32+64(%edx)
+movdqu %xmm0, 32+128(%edx)
+movdqu %xmm3, 32+192(%edx)
+movdqa 640(%esp),%xmm0
+movdqa 656(%esp),%xmm1
+movdqa 672(%esp),%xmm2
+movdqa 688(%esp),%xmm3
+paddd 320(%esp), %xmm0
+paddd 336(%esp), %xmm1
+paddd 352(%esp), %xmm2
+paddd 368(%esp), %xmm3
+movdqa %xmm0, %xmm4
+movdqa %xmm2, %xmm5
+punpckldq %xmm1, %xmm4
+punpckldq %xmm3, %xmm5
+punpckhdq %xmm1, %xmm0
+punpckhdq %xmm3, %xmm2
+movdqa %xmm4, %xmm1
+movdqa %xmm0, %xmm3
+punpcklqdq %xmm5, %xmm4
+punpckhqdq %xmm5, %xmm1
+punpcklqdq %xmm2, %xmm0
+punpckhqdq %xmm2, %xmm3
+movdqu %xmm4, 48+0(%edx)
+movdqu %xmm1, 48+64(%edx)
+movdqu %xmm0, 48+128(%edx)
+movdqu %xmm3, 48+192(%edx)
+.Lchacha_blocks_sse2_mainloop1_cont:
+movl 92(%esp),%eax
+subl $256,%eax
+addl $256,%edx
+cmpl $256,%eax
+jae .Lchacha_blocks_sse2_bytesatleast256
+cmpl $0,%eax
+jbe .Lchacha_blocks_sse2_done
+.Lchacha_blocks_sse2_bytesbetween1and255:
+cmpl $64,%eax
+jae .Lchacha_blocks_sse2_nocopy
+movl %edx,92(%esp)
+cmpl $0,%esi
+jbe .Lchacha_blocks_sse2_noinput2
+leal 128(%esp),%edi
+movl %eax,%ecx
+rep movsb
+leal 128(%esp),%esi
+.Lchacha_blocks_sse2_noinput2:
+leal 128(%esp),%edx
+.Lchacha_blocks_sse2_nocopy:
+movl %eax,80(%esp)
+movdqa 0(%esp),%xmm0
+movdqa 16(%esp),%xmm1
+movdqa 32(%esp),%xmm2
+movdqa 48(%esp),%xmm3
+movl 88(%esp),%eax
+.Lchacha_blocks_sse2_mainloop2:
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+pshuflw $0xb1,%xmm3,%xmm3
+pshufhw $0xb1,%xmm3,%xmm3
+paddd %xmm3, %xmm2
+pxor %xmm2, %xmm1
+movdqa %xmm1,%xmm4
+pslld $12, %xmm1
+psrld $20, %xmm4
+pxor %xmm4, %xmm1
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+movdqa %xmm3,%xmm4
+pslld $8, %xmm3
+psrld $24, %xmm4
+pshufd $0x93,%xmm0,%xmm0
+pxor %xmm4, %xmm3
+paddd %xmm3, %xmm2
+pshufd $0x4e,%xmm3,%xmm3
+pxor %xmm2, %xmm1
+pshufd $0x39,%xmm2,%xmm2
+movdqa %xmm1,%xmm4
+pslld $7, %xmm1
+psrld $25, %xmm4
+pxor %xmm4, %xmm1
+subl $2, %eax
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+pshuflw $0xb1,%xmm3,%xmm3
+pshufhw $0xb1,%xmm3,%xmm3
+paddd %xmm3, %xmm2
+pxor %xmm2, %xmm1
+movdqa %xmm1,%xmm4
+pslld $12, %xmm1
+psrld $20, %xmm4
+pxor %xmm4, %xmm1
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+movdqa %xmm3,%xmm4
+pslld $8, %xmm3
+psrld $24, %xmm4
+pshufd $0x39,%xmm0,%xmm0
+pxor %xmm4, %xmm3
+paddd %xmm3, %xmm2
+pshufd $0x4e,%xmm3,%xmm3
+pxor %xmm2, %xmm1
+pshufd $0x93,%xmm2,%xmm2
+movdqa %xmm1,%xmm4
+pslld $7, %xmm1
+psrld $25, %xmm4
+pxor %xmm4, %xmm1
+ja .Lchacha_blocks_sse2_mainloop2
+paddd 0(%esp), %xmm0
+paddd 16(%esp), %xmm1
+paddd 32(%esp), %xmm2
+paddd 48(%esp), %xmm3
+cmpl $0,%esi
+jbe .Lchacha_blocks_sse2_noinput3
+movdqu 0(%esi),%xmm4
+movdqu 16(%esi),%xmm5
+movdqu 32(%esi),%xmm6
+movdqu 48(%esi),%xmm7
+pxor %xmm4, %xmm0
+pxor %xmm5, %xmm1
+pxor %xmm6, %xmm2
+pxor %xmm7, %xmm3
+addl $64,%esi
+.Lchacha_blocks_sse2_noinput3:
+movdqu %xmm0,0(%edx)
+movdqu %xmm1,16(%edx)
+movdqu %xmm2,32(%edx)
+movdqu %xmm3,48(%edx)
+movl 80(%esp),%eax
+movl 48(%esp),%ecx
+movl 4+48(%esp),%ebx
+addl $1,%ecx
+adcl $0,%ebx
+movl %ecx,48(%esp)
+movl %ebx,4+48(%esp)
+cmpl $64,%eax
+ja .Lchacha_blocks_sse2_bytesatleast65
+jae .Lchacha_blocks_sse2_bytesatleast64
+movl %edx,%esi
+movl 92(%esp),%edi
+movl %eax,%ecx
+rep movsb
+.Lchacha_blocks_sse2_bytesatleast64:
+.Lchacha_blocks_sse2_done:
+movl 84(%esp),%eax
+movdqa 48(%esp),%xmm0
+C movdqu %xmm0,32(%eax)
+	movdqu %xmm0,48(%eax)
+movl 64(%esp),%eax
+C movl 68(%esp),%ebx
+C movl 72(%esp),%esi
+C movl 76(%esp),%edi
+.cfi_remember_state
+movl %ebp, %esp
+.cfi_def_cfa_register %esp
+	popl %edi
+.cfi_adjust_cfa_offset -4
+.cfi_restore %edi
+	popl %esi
+.cfi_adjust_cfa_offset -4
+.cfi_restore %esi
+	popl %ebx
+.cfi_adjust_cfa_offset -4
+.cfi_restore %ebx
+popl %ebp
+.cfi_adjust_cfa_offset -4
+.cfi_restore %ebp
+ret
+.cfi_restore_state
+.Lchacha_blocks_sse2_bytesatleast65:
+subl $64,%eax
+addl $64,%edx
+jmp .Lchacha_blocks_sse2_bytesbetween1and255
+.cfi_endproc
+EPILOGUE(_nettle_chacha_blocks)
+
+
+hchacha_sse2_local:
+PROLOGUE(_nettle_hchacha)
+.cfi_startproc
+LOAD_VAR_PIC chacha_constants, %eax
+movdqa 0(%eax), %xmm0
+movl 4(%esp), %eax
+movl 8(%esp), %edx
+movdqu 0(%eax), %xmm1
+movdqu 16(%eax), %xmm2
+movdqu 0(%edx), %xmm3
+movl 12(%esp), %edx
+movl 16(%esp), %ecx
+.Lhchacha_sse2_mainloop: 
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+pshuflw $0xb1,%xmm3,%xmm3
+pshufhw $0xb1,%xmm3,%xmm3
+paddd %xmm3, %xmm2
+pxor %xmm2, %xmm1
+movdqa %xmm1,%xmm4
+pslld $12, %xmm1
+psrld $20, %xmm4
+pxor %xmm4, %xmm1
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+movdqa %xmm3,%xmm4
+pslld $8, %xmm3
+psrld $24, %xmm4
+pshufd $0x93,%xmm0,%xmm0
+pxor %xmm4, %xmm3
+paddd %xmm3, %xmm2
+pshufd $0x4e,%xmm3,%xmm3
+pxor %xmm2, %xmm1
+pshufd $0x39,%xmm2,%xmm2
+movdqa %xmm1,%xmm4
+pslld $7, %xmm1
+psrld $25, %xmm4
+pxor %xmm4, %xmm1
+subl $2, %ecx
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+pshuflw $0xb1,%xmm3,%xmm3
+pshufhw $0xb1,%xmm3,%xmm3
+paddd %xmm3, %xmm2
+pxor %xmm2, %xmm1
+movdqa %xmm1,%xmm4
+pslld $12, %xmm1
+psrld $20, %xmm4
+pxor %xmm4, %xmm1
+paddd %xmm1, %xmm0
+pxor %xmm0, %xmm3
+movdqa %xmm3,%xmm4
+pslld $8, %xmm3
+psrld $24, %xmm4
+pshufd $0x39,%xmm0,%xmm0
+pxor %xmm4, %xmm3
+paddd %xmm3, %xmm2
+pshufd $0x4e,%xmm3,%xmm3
+pxor %xmm2, %xmm1
+pshufd $0x93,%xmm2,%xmm2
+movdqa %xmm1,%xmm4
+pslld $7, %xmm1
+psrld $25, %xmm4
+pxor %xmm4, %xmm1
+ja .Lhchacha_sse2_mainloop
+movdqu %xmm0, 0(%edx)
+movdqu %xmm3, 16(%edx)
+ret
+.cfi_endproc
+EPILOGUE(_nettle_hchacha)
+
+PROLOGUE(_nettle_chacha)
+.cfi_startproc
+pushl %ebp
+.cfi_adjust_cfa_offset 4
+.cfi_rel_offset %ebp, 0
+pushl %ebx
+.cfi_adjust_cfa_offset 4
+.cfi_rel_offset %ebx, 0
+movl %esp, %ebp
+.cfi_def_cfa_register %ebp
+subl $64, %esp
+andl $~63, %esp
+movl %esp, %ebx
+movl 12(%ebp), %ecx
+xorl %edx, %edx
+movdqu 0(%ecx), %xmm0
+movdqu 16(%ecx), %xmm1
+movdqa %xmm0, 0(%ebx)
+movdqa %xmm1, 16(%ebx)
+movl 16(%ebp), %ecx
+movl %edx, 32(%ebx)
+movl %edx, 36(%ebx)
+movl 0(%ecx), %eax
+movl 4(%ecx), %edx
+movl %eax, 40(%ebx)
+movl %edx, 44(%ebx)
+movl 32(%ebp), %eax
+movl %eax, 48(%ebx)
+pushl 28(%ebp)
+pushl 24(%ebp)
+pushl 20(%ebp)
+pushl %ebx
+call chacha_blocks_sse2_local
+pxor %xmm0, %xmm0
+movdqa %xmm0, 0(%ebx)
+movdqa %xmm0, 16(%ebx)
+movdqa %xmm0, 32(%ebx)
+movl %ebp, %esp
+.cfi_def_cfa_register %esp
+popl %ebx
+.cfi_adjust_cfa_offset -4
+.cfi_restore %ebx
+popl %ebp
+.cfi_adjust_cfa_offset -4
+.cfi_restore %ebp
+ret
+.cfi_endproc
+EPILOGUE(_nettle_chacha)
+
+PROLOGUE(_nettle_xchacha)
+.cfi_startproc
+pushl %ebp
+.cfi_adjust_cfa_offset 4
+.cfi_rel_offset %ebp, 0
+pushl %ebx
+.cfi_adjust_cfa_offset 4
+.cfi_rel_offset %ebx, 0
+movl %esp, %ebp
+.cfi_def_cfa_register %ebp
+subl $64, %esp
+andl $~63, %esp
+movl %esp, %ebx
+pushl 32(%ebp)
+pushl %ebx
+pushl 16(%ebp)
+pushl 12(%ebp)
+call hchacha_sse2_local
+xorl %edx, %edx
+movl 16(%ebp), %ecx
+movl 32(%ebx), %edx
+movl 36(%ebx), %edx
+movl 16(%ecx), %eax
+movl %eax, 40(%ebx)
+movl 20(%ecx), %eax
+movl %eax, 44(%ebx)
+C movl 32(%ebp), %eax
+C movl %eax, 48(%ebx)
+	pushl 32(%ebp)
+pushl 28(%ebp)
+pushl 24(%ebp)
+pushl 20(%ebp)
+pushl %ebx
+call chacha_blocks_sse2_local
+pxor %xmm0, %xmm0
+movdqa %xmm0, 0(%ebx)
+movdqa %xmm0, 16(%ebx)
+movdqa %xmm0, 32(%ebx)
+movl %ebp, %esp
+.cfi_def_cfa_register %esp
+popl %ebx
+.cfi_adjust_cfa_offset -4
+.cfi_restore %ebx
+popl %ebp
+.cfi_adjust_cfa_offset -4
+.cfi_restore %ebp
+ret
+.cfi_endproc
+EPILOGUE(_nettle_xchacha)
+
+include_src(&lt;x86/chacha_constants_x86.inc&gt;)
+
-- 
2.11.0


[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190314054104</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-03-14 05:41:04-0400</timestampReceived><subject>Re: [PATCH] fat-arm.c: prefer getauxval() over /proc/cpuinfo parsing</subject><body>

"Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt; writes:

&gt; When compiled for armv6+ and getauxval() is present (glibc 2.16+),
&gt; avoid slow and unreliable /proc/cpuinfo parsing.
&gt;  
&gt; E.g. /proc/cpuinfo contains junk with qemu-user and can be unavailable
&gt; in some chroot environment.

Do you know what's the preferred way to do this on android? Do we still
need /proc/cpuinfo, or are there any library facilities?

&gt; +#if __GLIBC__ &gt; 2 || (__GLIBC__ == 2 &amp;&amp; __GLIBC_MINOR__ &gt;= 16)
&gt; +#include &lt;sys/auxv.h&gt;

This part could be an AC_CHECK_HEADERS([sys/auxv.h]) in configure.ac.

&gt; +#if defined(AT_HWCAP) &amp;&amp; defined(HWCAP_ARM_NEON)
&gt; +#define HAVE_GETAUXVAL 1
&gt; +#endif
&gt; +#endif
&gt; +
&gt;  #include "nettle-types.h"
&gt;  
&gt;  #include "aes-internal.h"
&gt; @@ -87,6 +94,18 @@ get_arm_features (struct arm_features *features)
&gt;        }
&gt;    else
&gt;      {
&gt; +#if defined(HAVE_GETAUXVAL) &amp;&amp; __ARM_ARCH &gt;= 6

Why the condition __ARM_ARCH &gt;= 6? Is it because getauxval doesn't let us
make the distinction between arch_version 5 and 6?

&gt; +      unsigned long hwcap = getauxval(AT_HWCAP);
&gt; +      features-&gt;arch_version = __ARM_ARCH;

Is it important to take the compile-time arch into account? The effect
(when it makes a difference at all) will be to force use of certain
features, even if runtime checks say we're running on an older arch.

Is the getauxval method missing a way to get cpu arch at runtime? In the
docs
(https://github.com/torvalds/linux/blob/master/arch/arm/include/uapi/asm/hwcap.h)
I don't see anything corresponding to the "CPU arcitecture" line in
/proc/cpuinfo.

I'd be happier about getauxval if we could find a way to also get the
arch version without reading /proc/cpuinfo. But I don't think it's a
blocker for this change.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190314055150</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-03-14 05:51:50-0400</timestampReceived><subject>Re: [WIP][PATCH][v2] Add fast constant-time ARM NEON ghash/gcm</subject><body>

"Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt; writes:

&gt; From fa19a36985b7554517e9122b4cd193cd1a9c4f0e Mon Sep 17 00:00:00 2001
&gt; From: "Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt;
&gt; Date: Sun, 10 Mar 2019 11:08:46 +0300
&gt; Subject: [PATCH] Add fast constant-time ARM NEON ghash/gcm
&gt;
&gt; Based on code from
&gt; https://conradoplg.cryptoland.net/software/ecc-and-ae-for-arm-neon/
&gt; and
&gt; https://hal.inria.fr/hal-01506572
&gt; Note: arm-&gt;neon is fast, neon-&gt;arm slow, so we delay bitreverse
&gt; (performed in arm) as much as possible and keep ctx-&gt;x and ctx-&gt;key
&gt; bitreversed.

Thanks! I think I looked at the paper at some point, and it's clever.
Some initial comments.

Regarding bit-reversal, I think carryless multiplication is symmetric
under bitreversal (reversing the two 8-bit inputs corresponds to
bit-reversal of the 15-bit product), so unless input and output for some
reason uses different bitorder, I hope it should be possible to do any
needed bit reversal at key-setup only.

&gt; +.macro MUL64k3t4 rq rl rh ad bd k16 k32 k48 t0q t0l t0h t1q t1l t1h t2q t2l t2h t3q t3l t3h

Could you do these as m4 macros, like in the rest of the Nettle asm
code?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190317100853</emailId><senderName>"Yuriy M. Kaminskiy"</senderName><senderEmail>yumkam@gmail.com</senderEmail><timestampReceived>2019-03-17 10:08:53-0400</timestampReceived><subject>[PATCH][v2] fat-arm.c: prefer getauxval() over /proc/cpuinfo parsing</subject><body>

On 14.03.2019 08:41, Niels Möller wrote:
&gt; "Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt; writes:
&gt; 
&gt;&gt; When compiled for armv6+ and getauxval() is present (glibc 2.16+),
&gt;&gt; avoid slow and unreliable /proc/cpuinfo parsing.
&gt;&gt;  
&gt;&gt; E.g. /proc/cpuinfo contains junk with qemu-user and can be unavailable
&gt;&gt; in some chroot environment.
&gt; 
&gt; Do you know what's the preferred way to do this on android? Do we still
&gt; need /proc/cpuinfo, or are there any library facilities?

Google suggests https://developer.android.com/ndk/guides/cpu-features
I have no experience with it.

&gt;&gt; +#if __GLIBC__ &gt; 2 || (__GLIBC__ == 2 &amp;&amp; __GLIBC_MINOR__ &gt;= 16)
&gt;&gt; +#include &lt;sys/auxv.h&gt;
&gt; 
&gt; This part could be an AC_CHECK_HEADERS([sys/auxv.h]) in configure.ac.

Hmm... musl also provides it, I'll move detection to configure; then again,
musl does not define HWCAP_*, and I'm reluctant to fallback to &lt;asm/hwcap.h&gt; or
define HWCAP_* myself, so practically it still works on glibc only.

&gt;&gt;    else
&gt;&gt;      {
&gt;&gt; +#if defined(HAVE_GETAUXVAL) &amp;&amp; __ARM_ARCH &gt;= 6
&gt; 
&gt; Why the condition __ARM_ARCH &gt;= 6? Is it because getauxval doesn't let us
&gt; make the distinction between arch_version 5 and 6?

There are (const char *)getauxval(AT_PLATFORM); it is expected to be "v[45678][lb]";
probably, I should use it.

Things that should be checked: arm (32bit) userland with aarch64/arm64 kernel.

&gt;&gt; +      unsigned long hwcap = getauxval(AT_HWCAP);
&gt;&gt; +      features-&gt;arch_version = __ARM_ARCH;
&gt; 
&gt; Is it important to take the compile-time arch into account? The effect
&gt; (when it makes a difference at all) will be to force use of certain
&gt; features, even if runtime checks say we're running on an older arch.

I wanted to limit change to cases I'm sure will work (e.g. on debian/armhf
__ARM_ARCH is 7, on raspbian - 6; both are sufficient for nettle to use most
optimized code); and don't touch anything "unusual".

&gt; Is the getauxval method missing a way to get cpu arch at runtime? In the
&gt; docs
&gt; (https://github.com/torvalds/linux/blob/master/arch/arm/include/uapi/asm/hwcap.h)
&gt; I don't see anything corresponding to the "CPU arcitecture" line in
&gt; /proc/cpuinfo.
&gt; 
&gt; I'd be happier about getauxval if we could find a way to also get the
&gt; arch version without reading /proc/cpuinfo. But I don't think it's a
&gt; blocker for this change.


["0001-fat-arm.c-prefer-getauxval-over-proc-cpuinfo-parsing.patch" (text/x-patch)]

From 184cc27c1592eea98f3bcb7e48a32bf97e126709 Mon Sep 17 00:00:00 2001
From: "Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt;
Date: Sun, 10 Mar 2019 12:25:21 +0300
Subject: [PATCH] fat-arm.c: prefer getauxval() over /proc/cpuinfo parsing

When getauxval() is present (glibc 2.16+), avoid slow and unreliable
/proc/cpuinfo parsing.

Use compile-time ARM archeticture as a fallback.

Use VFPv3 as fallback to ARMv7 detection when AT_PLATFORM is not
recognized (NEON implies VFPv3 with VFPD32; VFPv4 implies VFPv3;
when NEON present, VFPv4 implies NEONv2; VFPv3 implies armv7)
---
 configure.ac |  4 ++++
 fat-arm.c    | 32 ++++++++++++++++++++++++++++++++
 2 files changed, 36 insertions(+)

diff --git a/configure.ac b/configure.ac
index 4a482bdd..76fabfef 100644
--- a/configure.ac
+++ b/configure.ac
@@ -193,6 +193,10 @@ AC_CHECK_HEADERS([openssl/evp.h openssl/ecdsa.h],,
 [enable_openssl=no
  break])
 
+# For --enable-fat on arm
+AC_CHECK_HEADERS([sys/auxv.h])
+AC_CHECK_FUNCS(getauxval)
+
 # For use by the testsuite
 AC_CHECK_HEADERS([valgrind/memcheck.h])
 AC_CHECK_HEADERS([dlfcn.h])
diff --git a/fat-arm.c b/fat-arm.c
index 6e4c8622..cdc137a2 100644
--- a/fat-arm.c
+++ b/fat-arm.c
@@ -40,6 +40,15 @@
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 
+#ifdef HAVE_SYS_AUXV_H
+#include &lt;sys/auxv.h&gt;
+#if !defined(AT_HWCAP) || !defined(HWCAP_ARM_NEON) || !defined(AT_PLATFORM)
+#undef HAVE_GETAUXVAL
+#endif
+#else
+#undef HAVE_GETAUXVAL
+#endif
+
 #include "nettle-types.h"
 
 #include "aes-internal.h"
@@ -64,7 +73,11 @@ static void
 get_arm_features (struct arm_features *features)
 {
   const char *s;
+#if __ARM_ARCH &gt; 5 /* use compile-time arch as fallback */
+  features-&gt;arch_version = __ARM_ARCH;
+#else
   features-&gt;arch_version = 5;
+#endif
   features-&gt;have_neon = 0;
 
   s = secure_getenv (ENV_OVERRIDE);
@@ -87,6 +100,24 @@ get_arm_features (struct arm_features *features)
       }
   else
     {
+#if defined(HAVE_GETAUXVAL)
+      unsigned long hwcap = getauxval(AT_HWCAP);
+      const char *platform = (const char *)getauxval(AT_PLATFORM);
+
+      if (platform != NULL &amp;&amp; platform[0] == 'v' &amp;&amp;
+	  (platform[1] &gt;= '0' &amp;&amp; platform[1] &lt;= '9') &amp;&amp;
+	  (platform[2] == 'l' || platform[2] == 'b'))
+	features-&gt;arch_version = platform[1] - '0';
+      else
+        {
+	  /* fallback to VFPv3 as a proxy for armv7 detection */
+	  if (features-&gt;arch_version &lt; 7 &amp;&amp; (hwcap &amp; HWCAP_ARM_VFPv3))
+	    features-&gt;arch_version = 7;
+	}
+
+      if ((hwcap &amp; HWCAP_ARM_NEON))
+	features-&gt;have_neon = 1;
+#else
       FILE *f;
       char line[200];
       int seen_arch = 0;
@@ -132,6 +163,7 @@ get_arm_features (struct arm_features *features)
 	  features-&gt;have_neon = 1;
 	}
       fclose (f);
+#endif
     }
 }
 
-- 
2.11.0


[Attachment #4 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190317181449</emailId><senderName>"Yuriy M. Kaminskiy"</senderName><senderEmail>yumkam@gmail.com</senderEmail><timestampReceived>2019-03-17 18:14:49-0400</timestampReceived><subject>Re: [RFC] optimized poly1305 and ABI</subject><body>

On 17.03.2019 17:22, Simo Sorce wrote:
&gt; On Sun, 2019-03-17 at 12:56 +0300, Yuriy M. Kaminskiy wrote:
&gt;&gt; On 14.03.2019 00:31, Simo Sorce wrote:
&gt;&gt;&gt; On Thu, 2019-03-14 at 00:25 +0300, Yuriy M. Kaminskiy wrote:
&gt;&gt;&gt;&gt; On 12.03.2019 15:02, Yuriy M. Kaminskiy wrote:
&gt;&gt;&gt;&gt; And it is embedded in struct chacha_poly1305_ctx and poly1305_aes_ctx, which looks like
&gt;&gt;&gt;&gt; part of public (and used) low-level ABI.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; (nettle-meta.h interface would be safe wrt struct size changes, but so far everything I've looked
&gt;&gt;&gt;&gt; at - including gnutls - was not using it :-()
&gt;&gt;&gt;
&gt;&gt;&gt; FWIW, I wouldn't feel blocked by an ABI break in Nettle.
&gt;&gt;
&gt;&gt; Breaking ABI in the library that is used in another libraries is always problematic.
&gt;&gt;
&gt;&gt; Scenario: $app links to libgnutls.so.1 and libnettle.so.1 (and libgnutls.so.1 linked
&gt;&gt; against libnettle.so.1; then libnettle.so.2 installed and libgnutls.so.1 rebuilt
&gt;&gt; against new nettle; what will happen with $app?
&gt;&gt;
&gt;&gt; (Especially since nettle does not use versioned symbols)

(I was wrong here, nettle uses versioned symbols, so nothing terminally
bad happens in this scenario: both libraries loaded, but $app uses @VER1 symbols,
while libgnutls @VER2 symbols).

&gt;&gt; So, you either bump libgnutls soname too (and you must rebuild all apps to take advantage of it)
&gt;&gt; [also it triggers same problem with libraries that uses libgnutls],
&gt;&gt; or you add Conflict/Breaks in libnettle2 (and you must rebuild all libraries and apps
&gt;&gt; to be able to even install libnettle2).
&gt; 
&gt; No, if app is built against nettle all you need to do is bump nettle's
&gt; so name and rebuild gnutls, the app will have to be rebuilt against the
&gt; new nettle only as gnutls completely masks nettle behind it's apis and
&gt; offers a stable ABI even when nettle ABI changes.

&gt;&gt; (And both renders new libnettle unusable for stable-backports.)
&gt; 
&gt; Yes, backports may be an issue, but nettle broke the ABI previously,
&gt; and it offers no ABI guarntee.
&gt; 
&gt;&gt; When you are forced to break ABI, it is good point to think: can it be avoided,
&gt;&gt; and how can this be prevented in the future?
&gt; 
&gt; This is not possible with Nettle as it uses explicit structures
&gt; exported to the caller, to have a stable ABI nettle would need to
&gt; change how it deals with context structures by allocating them on the
&gt; heap and making them opaque. I do not see this happening.

Actually, nettle provides (almost) everything needed already (except for umac):
in nettle-meta.h.

User can obtain correct context structure size, allocate it with malloc
or alloca, and use it safely with matching set of functions.

It's just that nettle *also* provides another, fragile, interface, and don't
encourage or force library users to use the safe one.

(What's annoying, "fragile" interface is not even much more efficient; it
is just a tiny bit more easy to use -
  `struct chacha_poly1305 ctx;` vs 
  `void *pctx = alloca(nettle_chacha_poly1305.context_size);`).

&gt;&gt; (poly1305 is not only algo that may require altering context structure for optimized
&gt;&gt; implementation [e.g. bitsliced or vectorized aes]).
&gt;&gt;
&gt;&gt; E.g. openssl made all structures opaque, and I believe it is correct long-term solution.
&gt; 
&gt; Openssl is a higher level library. We can discuss a wrapper library
&gt; around nettle that offers a stable API/ABI and could be used by GnuTLS
&gt; perhaps.

Openssl provides both higher-level (libssl) and low-level (libcrypto) primitives.
It is even easier for low-level primitives (you don't need accessors for e.g.
internals of md5 context struct; it is much more complex for tls session struct).

&gt;&gt; (Well, I've thought about a way, although not very nice: keep old version internally,
&gt;&gt; add separate {chacha,aes}_poly1305_encrypt_v2, #define $foo $foo_v2 in headers; you'll need
&gt;&gt; to rebuild all directly dependent libraries and apps to take advantage of new implementation,
&gt;&gt; but not necessarily whole system; also it is not 146% safe [lib$a built against old version,
&gt;&gt; lib$b built against new version, lib$a allocates struct chacha20_poly13_ctx and passes pointer
&gt;&gt; to lib$b; libb calls $foo_v2, BOOM], but I doubt anyone uses libnettle this way in practice).
&gt; 
&gt; Yes, as you described this method is broken, you would have to have
&gt; explicit different APIs or introduce symbol versioning.

Symbol versioning won't help in this breakage scenario. At all.

lib$a allocate structure for use foo@VER1, passes it to lib$b, lib$b calls foo@VER2,
BOOM.

Only way around this issue - use nettle-meta.h interface and pass matching
struct nettle_{cipher,aead,...}. Then lib$b can call matching function set,
regardless of which version of libnettle it was linked to.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190324205828</emailId><senderName>"Yuriy M. Kaminskiy"</senderName><senderEmail>yumkam@gmail.com</senderEmail><timestampReceived>2019-03-24 20:58:28-0400</timestampReceived><subject>Re: [WIP] aes arm asm from libgcrypt</subject><body>

On Sun, Mar 24, 2019 at 08:45:28PM +0100, Niels Möller wrote:
&gt; "Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt; writes:
&gt; 
&gt; I've had another look, trying to understand how it differs. 
&gt; 
&gt; &gt; Does not use pre-rotated tables (as in AES_SMALL), so reduces d-cache
&gt; &gt; footprint from 4.25K to 1K (enc)/1.25K (dec);
&gt; &gt; completely unrolled, so increases i-cache footprint
&gt; &gt; from 948b to 4416b (enc)/4032b (dec)
&gt; 
&gt; Not sure unrolling is that beneficial; Nettle's implementation does two
&gt; rounds at a time (since just like in your patch, src and destination
&gt; registers alternate when doing a round), and that's so many instructions
&gt; that lop iverhead should be pretty small.

As gcrypt implementation uses all registers, nothing left for keeping
round counter, so there are no much choice (I'll probably try
spill it on stack and auto{inc,dec}rement key pointer later).
 
&gt; &gt; As it completely replaces current implementation, I just attached new
&gt; &gt; files (will post final version as a patch).
&gt; 
&gt; As you say, it doesn't use prerotated tables, but instead adds a , ror
&gt; #x to the relevant eor instructions.
&gt; 
&gt; Load and store of the cleartext and ciphertext bytes is different (and I
&gt; have some difficulty following it).
&gt; 
&gt; Masking to get table indices is the same as in nettle's
&gt; arm/aes-encrypt-internal.asm, while nettle's v6 code uses the uxtb
&gt; instruction, which saves one register (which the code doesn't take much
&gt; advantage of, though).
&gt; 
&gt; The code in your patch has more careful instruction scheduling, e.g.,
&gt; interleaving addition of roundkeys with the sbox table lookups. Nettle's
&gt; code is written with only a single temporary register used for
&gt; everything, which makes it impossible to interleave independent parts of
&gt; the mangling. While your patch seems to alternate between three
&gt; different temporaries.

P.S.
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.

btw, short pgp keyids considered harmful.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190325124902</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-03-25 12:49:02-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

On Sun, 2019-03-24 at 19:57 +0100, Niels Möller wrote:
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt; &gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; &gt; 
&gt; &gt; &gt; I am attaching all 3 patches anew as I also fixed the other issues you
&gt; &gt; &gt; mentioned in a previous email.
&gt; &gt; 
&gt; &gt; Thanks. I'm about to merge. I've run cross-compile+qemu tests also on
&gt; &gt; big-endian mips, and it seems to work fine.
&gt; 
&gt; Merged to master branch now. Thanks!

Thanks a lot!
I see you also fixed the _ctx -&gt; _key suffix in the docs, sorry for not
catching it myself, and thank you for dealing with it!

Cheers,
Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190412030355</emailId><senderName></senderName><senderEmail>mingli.yu@windriver.com</senderEmail><timestampReceived>2019-04-12 03:03:55-0400</timestampReceived><subject>[PATCH] nettle-pbkdf2.c: change the initialization for salt</subject><body>

From: Mingli Yu &lt;Mingli.Yu@windriver.com&gt;

use malloc and strncpy altogether to replace
strdup for salt initialization to fix below
Segmentation fault:
 # echo -n passwd| nettle-pbkdf2 -i 1 -l 16 salt
 [65534.886509] nettle-pbkdf2[708]: segfault at 1f594260 ip 00007f3332256998 sp \
00007fff60d44410 error 4 in libnettle.so.6.5[7f3332244000+1d00]  [65534.887525] Code: \
e8 6d db fe ff 44 01 6d 68 48 83 c4 08 5b 5d 41 5c 41 5d 41 5e 41 5f c3 66 2e 0f 1f \
84 00 00 00 00 00 49 89 dc e9 68 ff f  Segmentation fault

Signed-off-by: Mingli Yu &lt;Mingli.Yu@windriver.com&gt;
---
 tools/nettle-pbkdf2.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/tools/nettle-pbkdf2.c b/tools/nettle-pbkdf2.c
index fe6528d..6ecb206 100644
--- a/tools/nettle-pbkdf2.c
+++ b/tools/nettle-pbkdf2.c
@@ -143,7 +143,10 @@ main (int argc, char **argv)
       return EXIT_FAILURE;
     }
 
-  salt = strdup (argv[0]);
+  salt = malloc (strlen(argv[0]) + 1);
+  if (! salt)
+     die ("Failed to allocate memory for salt\n");
+  strncpy(salt, argv[0], sizeof(salt) - 1);
   salt_length = strlen(argv[0]);
   
   if (hex_salt)
-- 
2.7.4

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190425164529</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-04-25 16:45:29-0400</timestampReceived><subject>Intel CET protection</subject><body>

Hello,
the attached patches have been used to successfully enable and test
Intel CET support in an Intel emulator on SDV hardware.

The patches are minimally intrusive and enable to use a future
countermeasure that is very useful as it makes ROP attacks very hard to
carry out.

GCC already has all the needed support to create CET hardened code,
however the hand-coded assembly needs to be changed to conform.
Without these changes all the binaries that load nettle will otherwise
have CET disabled, as it is an all-or-nothing at the binary level and
missing ENDBRANCH instruction cause the program to terminate on
indirect jump/call instructions.

The second patch is used to make the system happy when hardening flags
are enabled in gcc, as it generates the appropriate section information
that tells the linker all is good.

Unfortunately I do not have actual tests for this feature (one of the
reasons why it is behind a configure flag even though it is safe to add
the code on any x86 hardware) because the only real way to test this is
to run on hardware or emulators that cause the segfaults on errors. But
we can add a simple test later once hardware becomes available.

Finally while looking at the assembly I noticed that some functions
have a PROLOGUE() defined but not an EPILOGUE() macro defined in their
.asm files. It is unclear to me if this is an error or intentional so
didn't touch those, it doesn't affect functionality for this patch
anyway.

HTH,
Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


["0001-Add-Intel-CET-protection-support.patch" (0001-Add-Intel-CET-protection-support.patch)]

From de1b9bfeb4f8ad9a6bf8608c4b8c727dba315982 Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Tue, 23 Apr 2019 18:03:35 -0400
Subject: [PATCH 1/2] Add Intel CET protection support

In upcoming processors Intel will make available Control-Flow
Enforcement Technology, which is comprised of two hardware
countermeasures against ROP based attacks.

The first is called Shadow Stack and checks that return from function
calls are not tampered with by keeping a shadow stack that cannot be
modified by aplications. This measure requires no code changes (except
for code that intentionally modifes the return pointer on the stack).

The second is called Indirect Branch Tracking and is used to insure only
targets of indirect jumps are actually jumped to. This requires
modification of code to insert a special instruction that identifies a
valid indirect jump target. When enforcement is turned on, if an indirect
jump does not end on this special instruction the cpu raises an exception.
These instructions are noops on older CPU models so it is safe to use
them in all x86(_64) code.

To enable these protections gcc also inroduces a new GNU property note
section that marks a piece of code as CET ready.
If the note is in place the dynamic linker will be able to confirm that
all loaded libraries support CET and will turn on CET protection for the
binary.

The changes here consist mostly in adding the GNU property note section
to all x86(_64) assembly files and the proper ENDBRANCH instruction for
the function entrypoints which is where other code calls into via
indirect call.

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 asm.m4                                | 25 ++++++++++++++++++++++++-
 config.m4.in                          |  2 ++
 configure.ac                          | 17 +++++++++++++++++
 x86/aes-decrypt-internal.asm          |  1 +
 x86/aes-encrypt-internal.asm          |  1 +
 x86/arcfour-crypt.asm                 |  1 +
 x86/camellia-crypt-internal.asm       |  1 +
 x86/md5-compress.asm                  |  1 +
 x86/sha1-compress.asm                 |  1 +
 x86_64/aes-decrypt-internal.asm       |  4 +++-
 x86_64/aes-encrypt-internal.asm       |  3 ++-
 x86_64/aesni/aes-decrypt-internal.asm |  1 +
 x86_64/aesni/aes-encrypt-internal.asm |  1 +
 x86_64/camellia-crypt-internal.asm    |  1 +
 x86_64/chacha-core-internal.asm       |  3 ++-
 x86_64/fat/cpuid.asm                  |  2 +-
 x86_64/gcm-hash8.asm                  |  1 +
 x86_64/md5-compress.asm               |  1 +
 x86_64/memxor.asm                     |  1 +
 x86_64/memxor3.asm                    |  1 +
 x86_64/poly1305-internal.asm          |  1 +
 x86_64/salsa20-core-internal.asm      |  1 +
 x86_64/salsa20-crypt.asm              |  1 +
 x86_64/serpent-decrypt.asm            |  2 ++
 x86_64/serpent-encrypt.asm            |  2 ++
 x86_64/sha1-compress.asm              |  1 +
 x86_64/sha256-compress.asm            |  1 +
 x86_64/sha3-permute.asm               |  1 +
 x86_64/sha512-compress.asm            |  1 +
 x86_64/sha_ni/sha1-compress.asm       |  1 +
 x86_64/sha_ni/sha256-compress.asm     |  1 +
 x86_64/umac-nh-n.asm                  |  1 +
 x86_64/umac-nh.asm                    |  1 +
 33 files changed, 79 insertions(+), 5 deletions(-)

diff --git a/asm.m4 b/asm.m4
index 8da47201..c6db52e5 100644
--- a/asm.m4
+++ b/asm.m4
@@ -32,7 +32,8 @@ define(&lt;GMP_NUMB_BITS&gt;,&lt;&gt;)dnl
 define(&lt;PROLOGUE&gt;,
 &lt;.globl C_NAME($1)
 DECLARE_FUNC(C_NAME($1))
-C_NAME($1):&gt;)
+C_NAME($1):
+CET_ENDBR&gt;)
 
 define(&lt;EPILOGUE&gt;,
 &lt;ifelse(ELF_STYLE,yes,
@@ -59,6 +60,28 @@ WORDS_BIGENDIAN,no,&lt;$2&gt;,
   m4exit(1)&gt;)&gt;)
 define(&lt;IF_LE&gt;, &lt;IF_BE(&lt;$2&gt;, &lt;$1&gt;)&gt;)
 
+dnl GNU properties section to enable CET protections
+define(&lt;GNU_CET_SECTION&gt;,
+&lt;ifelse(CET_PROTECTION,yes,
+&lt;.pushsection .note.gnu.property,"a"
+ALIGN(8)
+.long 1f - 0f
+.long 4f - 1f
+.long 5
+0:
+.string "GNU"
+1:
+ALIGN(8)
+.long 0xc0000002
+.long 3f - 2f
+2:
+.long 0x03
+3:
+ALIGN(8)
+4:
+.popsection
+&gt;,&lt;&gt;)&gt;)
+
 dnl Struct defining macros
 
 dnl STRUCTURE(prefix) 
diff --git a/config.m4.in b/config.m4.in
index 11f90a40..c3ebad60 100644
--- a/config.m4.in
+++ b/config.m4.in
@@ -8,6 +8,8 @@ define(&lt;ALIGN_LOG&gt;, &lt;@ASM_ALIGN_LOG@&gt;)dnl
 define(&lt;W64_ABI&gt;, &lt;@W64_ABI@&gt;)dnl
 define(&lt;RODATA&gt;, &lt;@ASM_RODATA@&gt;)dnl
 define(&lt;WORDS_BIGENDIAN&gt;, &lt;@ASM_WORDS_BIGENDIAN@&gt;)dnl
+define(&lt;CET_PROTECTION&gt;, &lt;@ASM_CET_PROTECTION@&gt;)dnl
+define(&lt;CET_ENDBR&gt;, &lt;@ASM_CET_ENDBR@&gt;)dnl
 divert(1)
 @ASM_MARK_NOEXEC_STACK@
 divert
diff --git a/configure.ac b/configure.ac
index 00d2bf5d..6e12bb1f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -93,6 +93,10 @@ AC_ARG_ENABLE(mini-gmp,
   AC_HELP_STRING([--enable-mini-gmp], [Enable mini-gmp, used instead of libgmp.]),,
   [enable_mini_gmp=no])
 
+AC_ARG_ENABLE(cet-protection,
+  AC_HELP_STRING([--enable-cet-protection], [Enable intel CET protection instructions. (default=no)]),,
+  [enable_cet_protection=no])
+
 if test "x$enable_mini_gmp" = xyes ; then
   NETTLE_USE_MINI_GMP=1
   HOGWEED_EXTRA_SYMBOLS="mpz_*;gmp_*;mpn_*;mp_*;"
@@ -701,6 +705,8 @@ ASM_COFF_STYLE='no'
 ASM_TYPE_FUNCTION='@function'
 ASM_TYPE_PROGBITS='@progbits'
 ASM_MARK_NOEXEC_STACK=''
+ASM_CET_PROTECTION='no'
+ASM_CET_ENDBR=''
 ASM_ALIGN_LOG=''
 
 if test x$enable_assembler = xyes ; then
@@ -812,6 +818,15 @@ EOF
        [nettle_cv_asm_align_log=yes],
        [nettle_cv_asm_align_log=no])])
   ASM_ALIGN_LOG="$nettle_cv_asm_align_log"
+
+  if test "x$enable_cet_protection" = xyes ; then
+    ASM_CET_PROTECTION=yes
+    if test "$ABI" = 64 ; then
+      ASM_CET_ENDBR=endbr64
+    else
+      ASM_CET_ENDBR=endbr32
+    fi
+  fi
 fi
 
 AC_SUBST(ASM_SYMBOL_PREFIX)
@@ -823,6 +838,8 @@ AC_SUBST(ASM_MARK_NOEXEC_STACK)
 AC_SUBST(ASM_ALIGN_LOG)
 AC_SUBST(W64_ABI)
 AC_SUBST(ASM_WORDS_BIGENDIAN)
+AC_SUBST(ASM_CET_PROTECTION)
+AC_SUBST(ASM_CET_ENDBR)
 AC_SUBST(EMULATOR)
 
 AC_SUBST(LIBNETTLE_MAJOR)
diff --git a/x86/aes-decrypt-internal.asm b/x86/aes-decrypt-internal.asm
index ff535b6a..1d16f6db 100644
--- a/x86/aes-decrypt-internal.asm
+++ b/x86/aes-decrypt-internal.asm
@@ -175,3 +175,4 @@ PROLOGUE(_nettle_aes_decrypt)
 	popl	%ebx
 	ret
 EPILOGUE(_nettle_aes_decrypt)
+GNU_CET_SECTION()
diff --git a/x86/aes-encrypt-internal.asm b/x86/aes-encrypt-internal.asm
index 934158f7..d9579e04 100644
--- a/x86/aes-encrypt-internal.asm
+++ b/x86/aes-encrypt-internal.asm
@@ -175,3 +175,4 @@ PROLOGUE(_nettle_aes_encrypt)
 	popl	%ebx
 	ret
 EPILOGUE(_nettle_aes_encrypt)
+GNU_CET_SECTION()
diff --git a/x86/arcfour-crypt.asm b/x86/arcfour-crypt.asm
index df3fe869..11f592e7 100644
--- a/x86/arcfour-crypt.asm
+++ b/x86/arcfour-crypt.asm
@@ -123,3 +123,4 @@ C .Lloop_done:
 	popl	%ebx
 	ret
 EPILOGUE(nettle_arcfour_crypt)
+GNU_CET_SECTION()
diff --git a/x86/camellia-crypt-internal.asm b/x86/camellia-crypt-internal.asm
index ce8c57f0..afac1fcc 100644
--- a/x86/camellia-crypt-internal.asm
+++ b/x86/camellia-crypt-internal.asm
@@ -223,3 +223,4 @@ PROLOGUE(_nettle_camellia_crypt)
 	popl	%ebx
 	ret
 EPILOGUE(_nettle_camellia_crypt)
+GNU_CET_SECTION()
diff --git a/x86/md5-compress.asm b/x86/md5-compress.asm
index c849c082..6293f052 100644
--- a/x86/md5-compress.asm
+++ b/x86/md5-compress.asm
@@ -185,3 +185,4 @@ PROLOGUE(nettle_md5_compress)
 	popl	%ebx
 	ret
 EPILOGUE(nettle_md5_compress)
+GNU_CET_SECTION()
diff --git a/x86/sha1-compress.asm b/x86/sha1-compress.asm
index 03bdcdc9..4e1f121c 100644
--- a/x86/sha1-compress.asm
+++ b/x86/sha1-compress.asm
@@ -1541,6 +1541,7 @@ C 	ROUND_F2(SB, SC, SD, SE, SA, 79, K4VALUE)
 	popl	%ebx
 	ret
 EPILOGUE(nettle_sha1_compress)
+GNU_CET_SECTION()
 
 C TODO:
 
diff --git a/x86_64/aes-decrypt-internal.asm b/x86_64/aes-decrypt-internal.asm
index 43f2f394..5db39868 100644
--- a/x86_64/aes-decrypt-internal.asm
+++ b/x86_64/aes-decrypt-internal.asm
@@ -62,7 +62,7 @@ C work.
 define(&lt;TMP&gt;,&lt;%rbp&gt;)
 
 	.file "aes-decrypt-internal.asm"
-	
+
 	C _aes_decrypt(unsigned rounds, const uint32_t *keys,
 	C	       const struct aes_table *T,
 	C	       size_t length, uint8_t *dst,
@@ -70,6 +70,7 @@ define(&lt;TMP&gt;,&lt;%rbp&gt;)
 	.text
 	ALIGN(16)
 PROLOGUE(_nettle_aes_decrypt)
+
 	W64_ENTRY(6, 0)
 	test	PARAM_LENGTH, PARAM_LENGTH
 	jz	.Lend
@@ -150,3 +151,4 @@ PROLOGUE(_nettle_aes_decrypt)
 	W64_EXIT(6, 0)
 	ret
 EPILOGUE(_nettle_aes_decrypt)
+GNU_CET_SECTION()
diff --git a/x86_64/aes-encrypt-internal.asm b/x86_64/aes-encrypt-internal.asm
index dfb498f5..93c0774a 100644
--- a/x86_64/aes-encrypt-internal.asm
+++ b/x86_64/aes-encrypt-internal.asm
@@ -63,7 +63,7 @@ C work.
 define(&lt;TMP&gt;,&lt;%rbp&gt;)
 
 	.file "aes-encrypt-internal.asm"
-	
+
 	C _aes_encrypt(unsigned rounds, const uint32_t *keys,
 	C	       const struct aes_table *T,
 	C	       size_t length, uint8_t *dst,
@@ -151,3 +151,4 @@ PROLOGUE(_nettle_aes_encrypt)
 	W64_EXIT(6, 0)
 	ret
 EPILOGUE(_nettle_aes_encrypt)
+GNU_CET_SECTION()
diff --git a/x86_64/aesni/aes-decrypt-internal.asm b/x86_64/aesni/aes-decrypt-internal.asm
index 3d6d6e30..1b1a1a4d 100644
--- a/x86_64/aesni/aes-decrypt-internal.asm
+++ b/x86_64/aesni/aes-decrypt-internal.asm
@@ -132,3 +132,4 @@ PROLOGUE(_nettle_aes_decrypt)
 	W64_EXIT(6, 16)
 	ret
 EPILOGUE(_nettle_aes_decrypt)
+GNU_CET_SECTION()
diff --git a/x86_64/aesni/aes-encrypt-internal.asm b/x86_64/aesni/aes-encrypt-internal.asm
index 99caf1f8..f7338ef6 100644
--- a/x86_64/aesni/aes-encrypt-internal.asm
+++ b/x86_64/aesni/aes-encrypt-internal.asm
@@ -132,3 +132,4 @@ PROLOGUE(_nettle_aes_encrypt)
 	W64_EXIT(6, 16)
 	ret
 EPILOGUE(_nettle_aes_encrypt)
+GNU_CET_SECTION()
diff --git a/x86_64/camellia-crypt-internal.asm b/x86_64/camellia-crypt-internal.asm
index 040e030f..71750172 100644
--- a/x86_64/camellia-crypt-internal.asm
+++ b/x86_64/camellia-crypt-internal.asm
@@ -200,3 +200,4 @@ PROLOGUE(_nettle_camellia_crypt)
 	W64_EXIT(6, 0)
 	ret
 EPILOGUE(_nettle_camellia_crypt)
+GNU_CET_SECTION()
diff --git a/x86_64/chacha-core-internal.asm b/x86_64/chacha-core-internal.asm
index 9e5dc394..125adfe8 100644
--- a/x86_64/chacha-core-internal.asm
+++ b/x86_64/chacha-core-internal.asm
@@ -82,7 +82,7 @@ define(&lt;QROUND&gt;, &lt;
 	psrld	&lt;$&gt;25, T0
 	por	T0, X1
 &gt;)
-	
+
 	C _chacha_core(uint32_t *dst, const uint32_t *src, unsigned rounds)
 	.text
 	ALIGN(16)
@@ -126,3 +126,4 @@ PROLOGUE(_nettle_chacha_core)
 	W64_EXIT(3, 6)
 	ret
 EPILOGUE(_nettle_chacha_core)
+GNU_CET_SECTION()
diff --git a/x86_64/fat/cpuid.asm b/x86_64/fat/cpuid.asm
index f317d56e..c4a5b538 100644
--- a/x86_64/fat/cpuid.asm
+++ b/x86_64/fat/cpuid.asm
@@ -56,4 +56,4 @@ PROLOGUE(_nettle_cpuid)
 	W64_EXIT(2)
 	ret
 EPILOGUE(_nettle_cpuid)
-
+GNU_CET_SECTION()
diff --git a/x86_64/gcm-hash8.asm b/x86_64/gcm-hash8.asm
index bfaa6ef8..54608ae8 100644
--- a/x86_64/gcm-hash8.asm
+++ b/x86_64/gcm-hash8.asm
@@ -199,6 +199,7 @@ ALIGN(16)
 	jnz	.Lread_loop
 	ret
 EPILOGUE(_nettle_gcm_hash8)
+GNU_CET_SECTION()
 
 define(&lt;W&gt;, &lt;0x$2$1&gt;)
 	RODATA
diff --git a/x86_64/md5-compress.asm b/x86_64/md5-compress.asm
index 182b8f18..ef1fcb89 100644
--- a/x86_64/md5-compress.asm
+++ b/x86_64/md5-compress.asm
@@ -174,3 +174,4 @@ PROLOGUE(nettle_md5_compress)
 
 	ret
 EPILOGUE(nettle_md5_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/memxor.asm b/x86_64/memxor.asm
index f07f0017..a0ea94b4 100644
--- a/x86_64/memxor.asm
+++ b/x86_64/memxor.asm
@@ -171,3 +171,4 @@ ifdef(&lt;USE_SSE2&gt;, &lt;
 &gt;)	
 
 EPILOGUE(nettle_memxor)
+GNU_CET_SECTION()
diff --git a/x86_64/memxor3.asm b/x86_64/memxor3.asm
index 8ff3e79c..b0c0e35c 100644
--- a/x86_64/memxor3.asm
+++ b/x86_64/memxor3.asm
@@ -261,3 +261,4 @@ ifelse(USE_SSE2, yes, &lt;
 	
 
 EPILOGUE(nettle_memxor3)
+GNU_CET_SECTION()
diff --git a/x86_64/poly1305-internal.asm b/x86_64/poly1305-internal.asm
index c780d122..d7edc4f9 100644
--- a/x86_64/poly1305-internal.asm
+++ b/x86_64/poly1305-internal.asm
@@ -183,3 +183,4 @@ define(&lt;T1&gt;, &lt;%rax&gt;)
 	W64_EXIT(2, 0)
 	ret
 
+GNU_CET_SECTION()
diff --git a/x86_64/salsa20-core-internal.asm b/x86_64/salsa20-core-internal.asm
index 4ef07be0..c1690880 100644
--- a/x86_64/salsa20-core-internal.asm
+++ b/x86_64/salsa20-core-internal.asm
@@ -109,3 +109,4 @@ PROLOGUE(_nettle_salsa20_core)
 	W64_EXIT(3, 9)
 	ret
 EPILOGUE(_nettle_salsa20_core)
+GNU_CET_SECTION()
diff --git a/x86_64/salsa20-crypt.asm b/x86_64/salsa20-crypt.asm
index cc1d58ca..e0348956 100644
--- a/x86_64/salsa20-crypt.asm
+++ b/x86_64/salsa20-crypt.asm
@@ -245,3 +245,4 @@ PROLOGUE(nettle_salsa20_crypt)
 	ret
 
 EPILOGUE(nettle_salsa20_crypt)
+GNU_CET_SECTION()
diff --git a/x86_64/serpent-decrypt.asm b/x86_64/serpent-decrypt.asm
index ee4bf9ad..9a93dfc7 100644
--- a/x86_64/serpent-decrypt.asm
+++ b/x86_64/serpent-decrypt.asm
@@ -713,3 +713,5 @@ PROLOGUE(nettle_serpent_decrypt)
 	pop	%rbx
 	W64_EXIT(4, 13)
 	ret
+
+GNU_CET_SECTION()
diff --git a/x86_64/serpent-encrypt.asm b/x86_64/serpent-encrypt.asm
index d6636537..a29358ca 100644
--- a/x86_64/serpent-encrypt.asm
+++ b/x86_64/serpent-encrypt.asm
@@ -748,3 +748,5 @@ C parallell.
 	pop	%rbx
 	W64_EXIT(4, 13)
 	ret
+
+GNU_CET_SECTION()
diff --git a/x86_64/sha1-compress.asm b/x86_64/sha1-compress.asm
index dd48de0e..54dfa313 100644
--- a/x86_64/sha1-compress.asm
+++ b/x86_64/sha1-compress.asm
@@ -305,3 +305,4 @@ PROLOGUE(nettle_sha1_compress)
 	W64_EXIT(2, 0)
 	ret
 EPILOGUE(nettle_sha1_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/sha256-compress.asm b/x86_64/sha256-compress.asm
index 5b7d0dcd..8dbccc5b 100644
--- a/x86_64/sha256-compress.asm
+++ b/x86_64/sha256-compress.asm
@@ -208,3 +208,4 @@ PROLOGUE(_nettle_sha256_compress)
 	W64_EXIT(3, 0)
 	ret
 EPILOGUE(_nettle_sha256_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/sha3-permute.asm b/x86_64/sha3-permute.asm
index 805b59af..a4d0cf0b 100644
--- a/x86_64/sha3-permute.asm
+++ b/x86_64/sha3-permute.asm
@@ -107,6 +107,7 @@ define(&lt;ROTL64&gt;, &lt;
 	
 	C sha3_permute(struct sha3_state *ctx)
 	.text
+GNU_CET_SECTION()
 	ALIGN(16)
 PROLOGUE(nettle_sha3_permute)
 	W64_ENTRY(1, 16)
diff --git a/x86_64/sha512-compress.asm b/x86_64/sha512-compress.asm
index 4ff1f32a..37563e93 100644
--- a/x86_64/sha512-compress.asm
+++ b/x86_64/sha512-compress.asm
@@ -208,3 +208,4 @@ PROLOGUE(_nettle_sha512_compress)
 	W64_EXIT(3, 0)
 	ret
 EPILOGUE(_nettle_sha512_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/sha_ni/sha1-compress.asm b/x86_64/sha_ni/sha1-compress.asm
index ab848fdd..3cbca5e2 100644
--- a/x86_64/sha_ni/sha1-compress.asm
+++ b/x86_64/sha_ni/sha1-compress.asm
@@ -146,3 +146,4 @@ PROLOGUE(nettle_sha1_compress)
 	W64_EXIT(2, 10)
 	ret
 EPILOGUE(nettle_sha1_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/sha_ni/sha256-compress.asm b/x86_64/sha_ni/sha256-compress.asm
index f2a4bd32..f9fe3757 100644
--- a/x86_64/sha_ni/sha256-compress.asm
+++ b/x86_64/sha_ni/sha256-compress.asm
@@ -173,3 +173,4 @@ PROLOGUE(_nettle_sha256_compress)
 	W64_EXIT(3, 10)
 	ret
 EPILOGUE(_nettle_sha256_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/umac-nh-n.asm b/x86_64/umac-nh-n.asm
index ecb6396a..195d5886 100644
--- a/x86_64/umac-nh-n.asm
+++ b/x86_64/umac-nh-n.asm
@@ -273,3 +273,4 @@ PROLOGUE(_nettle_umac_nh_n)
 	W64_EXIT(5, 14)
 	ret
 EPILOGUE(_nettle_umac_nh_n)
+GNU_CET_SECTION()
diff --git a/x86_64/umac-nh.asm b/x86_64/umac-nh.asm
index a6938e02..7bfc87ba 100644
--- a/x86_64/umac-nh.asm
+++ b/x86_64/umac-nh.asm
@@ -79,3 +79,4 @@ PROLOGUE(_nettle_umac_nh)
 	W64_EXIT(3, 7)
 	ret
 EPILOGUE(_nettle_umac_nh)
+GNU_CET_SECTION()
-- 
2.20.1


["0002-Fix-generation-of-build-notes-if-supported.patch" (0002-Fix-generation-of-build-notes-if-supported.patch)]

From f93675c080f5244216b77664d7ce27daab89ec39 Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Wed, 24 Apr 2019 16:13:59 -0400
Subject: [PATCH 2/2] Fix generation of build notes if supported

This is needed to build correctly on platfroms that use
hardening flags and build notes on .c files.

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 Makefile.in  |  4 +++-
 configure.ac | 23 +++++++++++++++++++++++
 2 files changed, 26 insertions(+), 1 deletion(-)

diff --git a/Makefile.in b/Makefile.in
index 440de9f7..4e603047 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -17,6 +17,8 @@ OPT_HOGWEED_OBJS = @OPT_HOGWEED_OBJS@
 
 OPT_NETTLE_SOURCES = @OPT_NETTLE_SOURCES@
 
+ASM_GEN_BUILD_NOTES = @ASM_GEN_BUILD_NOTES@
+
 SUBDIRS = tools testsuite examples
 
 include config.make
@@ -396,7 +398,7 @@ ecc-25519.$(OBJEXT): ecc-25519.h
 
 .asm.$(OBJEXT): $(srcdir)/asm.m4 machine.m4 config.m4
 	$(M4) $(srcdir)/asm.m4 machine.m4 config.m4 $&lt; &gt;$*.s
-	$(COMPILE) -c $*.s
+	$(COMPILE) -c $*.s $(ASM_GEN_BUILD_NOTES)
 	@echo "$@ : $&lt; $(srcdir)/asm.m4 machine.m4 config.m4" &gt;$@.d 
 
 # Texinfo rules
diff --git a/configure.ac b/configure.ac
index 6e12bb1f..87a97468 100644
--- a/configure.ac
+++ b/configure.ac
@@ -708,6 +708,7 @@ ASM_MARK_NOEXEC_STACK=''
 ASM_CET_PROTECTION='no'
 ASM_CET_ENDBR=''
 ASM_ALIGN_LOG=''
+ASM_GEN_BUILD_NOTES=''
 
 if test x$enable_assembler = xyes ; then
   AC_CACHE_CHECK([if globals are prefixed by underscore],
@@ -827,6 +828,27 @@ EOF
       ASM_CET_ENDBR=endbr32
     fi
   fi
+
+  AC_CACHE_CHECK([if --generate-missing-build-notes is supported],
+    nettle_cv_asm_build_notes,
+    [ # Default
+      nettle_cv_asm_build_notes=no
+
+      cat &gt;conftest.s &lt;&lt; EOF
+.text
+EOF
+      FLAG="-Wa,--generate-missing-build-notes=yes"
+      nettle_assemble="$CC $CFLAGS $CPPFLAGS -c conftest.s $FLAG &gt;conftest.out 2&gt;&amp;1"
+      if AC_TRY_EVAL(nettle_assemble); then
+        nettle_cv_asm_build_notes=yes
+      else
+       nettle_cv_asm_build_notes=no
+      fi
+    rm -f conftest.*])
+  if test x$nettle_cv_asm_build_notes = xyes ; then
+    ASM_GEN_BUILD_NOTES='-Wa,--generate-missing-build-notes=yes'
+  fi
+
 fi
 
 AC_SUBST(ASM_SYMBOL_PREFIX)
@@ -840,6 +862,7 @@ AC_SUBST(W64_ABI)
 AC_SUBST(ASM_WORDS_BIGENDIAN)
 AC_SUBST(ASM_CET_PROTECTION)
 AC_SUBST(ASM_CET_ENDBR)
+AC_SUBST(ASM_GEN_BUILD_NOTES)
 AC_SUBST(EMULATOR)
 
 AC_SUBST(LIBNETTLE_MAJOR)
-- 
2.20.1


[Attachment #5 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190310174401</emailId><senderName>"Yuriy M. Kaminskiy"</senderName><senderEmail>yumkam@gmail.com</senderEmail><timestampReceived>2019-03-10 17:44:01-0400</timestampReceived><subject>[PATCH] fat-arm.c: prefer getauxval() over /proc/cpuinfo parsing</subject><body>

When compiled for armv6+ and getauxval() is present (glibc 2.16+),
avoid slow and unreliable /proc/cpuinfo parsing.
 
E.g. /proc/cpuinfo contains junk with qemu-user and can be unavailable
in some chroot environment.

["0001-fat-arm.c-prefer-getauxval-over-proc-cpuinfo-parsing.patch" (text/x-patch)]

From ae3be6a1cf3fc3f02d7fb8a25db1b89284d455e3 Mon Sep 17 00:00:00 2001
From: "Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt;
Date: Sun, 10 Mar 2019 12:25:21 +0300
Subject: [PATCH] fat-arm.c: prefer getauxval() over /proc/cpuinfo parsing

When compiled for armv6+ and getauxval() is present (glibc 2.16+),
avoid slow and unreliable /proc/cpuinfo parsing.
---
 fat-arm.c | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/fat-arm.c b/fat-arm.c
index 6e4c8622..aaffbf23 100644
--- a/fat-arm.c
+++ b/fat-arm.c
@@ -40,6 +40,13 @@
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 
+#if __GLIBC__ &gt; 2 || (__GLIBC__ == 2 &amp;&amp; __GLIBC_MINOR__ &gt;= 16)
+#include &lt;sys/auxv.h&gt;
+#if defined(AT_HWCAP) &amp;&amp; defined(HWCAP_ARM_NEON)
+#define HAVE_GETAUXVAL 1
+#endif
+#endif
+
 #include "nettle-types.h"
 
 #include "aes-internal.h"
@@ -87,6 +94,18 @@ get_arm_features (struct arm_features *features)
       }
   else
     {
+#if defined(HAVE_GETAUXVAL) &amp;&amp; __ARM_ARCH &gt;= 6
+      unsigned long hwcap = getauxval(AT_HWCAP);
+      features-&gt;arch_version = __ARM_ARCH;
+      /* NEON implies VFPv3 with VFPD32 */
+      /* VFPv4 implies VFPv3 */
+      /* when NEON present, VFPv4 implies NEONv2 */
+      /* VFPv3 implies armv7 */
+      if (features-&gt;arch_version &lt; 7 &amp;&amp; (hwcap &amp; HWCAP_ARM_VFPv3))
+	features-&gt;arch_version = 7;
+      if ((hwcap &amp; HWCAP_ARM_NEON))
+	features-&gt;have_neon = 1;
+#else
       FILE *f;
       char line[200];
       int seen_arch = 0;
@@ -132,6 +151,7 @@ get_arm_features (struct arm_features *features)
 	  features-&gt;have_neon = 1;
 	}
       fclose (f);
+#endif
     }
 }
 
-- 
2.11.0


[Attachment #4 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190310171553</emailId><senderName>"Yuriy M. Kaminskiy"</senderName><senderEmail>yumkam@gmail.com</senderEmail><timestampReceived>2019-03-10 17:15:53-0400</timestampReceived><subject>[WIP][PATCH][v2] Add fast constant-time ARM NEON ghash/gcm</subject><body>

v2: avoid expensive trap on unaligned LDM, reshuffled some insns

["0001-Add-fast-constant-time-ARM-NEON-ghash-gcm.patch" (text/x-patch)]

From fa19a36985b7554517e9122b4cd193cd1a9c4f0e Mon Sep 17 00:00:00 2001
From: "Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt;
Date: Sun, 10 Mar 2019 11:08:46 +0300
Subject: [PATCH] Add fast constant-time ARM NEON ghash/gcm

Based on code from
https://conradoplg.cryptoland.net/software/ecc-and-ae-for-arm-neon/
and
https://hal.inria.fr/hal-01506572
Note: arm-&gt;neon is fast, neon-&gt;arm slow, so we delay bitreverse
(performed in arm) as much as possible and keep ctx-&gt;x and ctx-&gt;key
bitreversed.

Only for little-endian.

On Raspberry PI 3B+ (armv8-a/Cortex-A53 @1.4GHz):
=== bench-slopes-nettle ===
 aes128         |  nanosecs/byte   mebibytes/sec   cycles/byte
Before:
       GCM auth |     28.43 ns/B     33.54 MiB/s     39.81 c/B
After: (300% faster)
       GCM auth |      7.05 ns/B     135.3 MiB/s      9.87 c/B
---
 arm/fat/gcm-hash-2.asm |  37 ++++++++
 arm/neon/gcm-hash.asm  | 238 +++++++++++++++++++++++++++++++++++++++++++++++++
 configure.ac           |   3 +
 fat-arm.c              |  12 +++
 gcm.c                  |  40 ++++++++-
 5 files changed, 328 insertions(+), 2 deletions(-)
 create mode 100644 arm/fat/gcm-hash-2.asm
 create mode 100644 arm/neon/gcm-hash.asm

diff --git a/arm/fat/gcm-hash-2.asm b/arm/fat/gcm-hash-2.asm
new file mode 100644
index 00000000..4c9729f1
--- /dev/null
+++ b/arm/fat/gcm-hash-2.asm
@@ -0,0 +1,37 @@
+C arm/fat/gcm-hash-2.asm
+
+
+ifelse(&lt;
+   Copyright (C) 2015 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+&gt;)
+
+dnl PROLOGUE(_nettle_gcm_hash) picked up by configure
+dnl PROLOGUE(_nettle_gcm_hash_convert) picked up by configure
+define(&lt;fat_transform&gt;, &lt;$1_neon&gt;)
+include_src(&lt;arm/neon/gcm-hash.asm&gt;)
diff --git a/arm/neon/gcm-hash.asm b/arm/neon/gcm-hash.asm
new file mode 100644
index 00000000..acdf2941
--- /dev/null
+++ b/arm/neon/gcm-hash.asm
@@ -0,0 +1,238 @@
+C arm/neon/gcm-hash.asm
+
+ifelse(&lt;
+   Copyright (C) Danilo Câmara &lt;dfcamara@ic.unicamp.br&gt;
+   Copyright (C) Conrado Porto Lopes Gouvêa &lt;conradoplg@gmail.com&gt;
+   (gf(2**128) multiplication core)
+   Copyright (C) 2019 Yuriy Kaminskiy &lt;yumkam@gmail.com&gt;
+   (nettle integration)
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+&gt;)
+	.file "gcm-hash.asm"
+	.arch	armv7-a
+	.fpu	neon
+	.arm
+
+.macro MUL64k3t4 rq rl rh ad bd k16 k32 k48 t0q t0l t0h t1q t1l t1h t2q t2l t2h t3q \
t3l t3h +
+    # a[76543210] * b[07654321]             # a[76543210] * b[10765432]             \
# a[76543210] * b[21076543] +    # a[07654321] * b[76543210]             # \
a[10765432] * b[76543210]             # a[21076543] * b[76543210]             # \
a[76543210] * b[32107654]             # a[76543210] * b[76543210] +    @A1
+    vext.8  \t0l, \ad, \ad, $1
+    @F = A1*B
+    vmull.p8 \t0q, \t0l, \bd
+    @B1
+    vext.8  \rl, \bd, \bd, $1
+    @E = A*B1 (7)
+    vmull.p8 \rq, \ad, \rl
+                                            @A2
+                                            vext.8  \t1l, \ad, \ad, $2
+                                            @H = A2*B
+                                            vmull.p8 \t1q, \t1l, \bd
+                                            @B2
+                                            vext.8  \t3l, \bd, \bd, $2
+                                            @G = A*B2
+                                            vmull.p8 \t3q, \ad, \t3l
+                                                                                    \
@A3 +                                                                                 \
vext.8  \t2l, \ad, \ad, $3 +                                                          \
@J = A3*B +                                                                           \
vmull.p8 \t2q, \t2l, \bd +    @L = E + F
+    veor    \t0q, \t0q, \rq
+                                                                                    \
@B3 +                                                                                 \
vext.8  \rl, \bd, \bd, $3 +                                                           \
@I = A*B3 +                                                                           \
vmull.p8 \rq, \ad, \rl +                                            @M = G + H
+                                            veor    \t1q, \t1q, \t3q
+                                                                                     \
@B4 +                                                                                 \
vext.8  \t3l, \bd, \bd, $4 +                                                          \
@K = A*B4 +                                                                           \
vmull.p8 \t3q, \ad, \t3l +    @t0 = (L) (P0 + P1) shl 8
+    veor    \t0l, \t0l, \t0h
+    vand    \t0h, \t0h, \k48
+                                            @t1 = (M) (P2 + P3) shl 16
+                                            veor    \t1l, \t1l, \t1h
+                                            vand    \t1h, \t1h, \k32
+                                                                                    \
@N = I + J +                                                                          \
veor    \t2q, \t2q, \rq +    veor    \t0l, \t0l, \t0h
+                                            veor    \t1l, \t1l, \t1h
+                                                                                    \
@t2 = (N) (P4 + P5) shl 24 +                                                          \
veor    \t2l, \t2l, \t2h +                                                            \
vand    \t2h, \t2h, \k16 +                                                            \
@t3 = (K) (P6 + P7) shl 32 +                                                          \
veor    \t3l, \t3l, \t3h +                                                            \
vmov.i64 \t3h, $0 +    vext.8  \t0q, \t0q, \t0q, $15
+                                                                                    \
veor    \t2l, \t2l, \t2h +                                            vext.8  \t1q, \
\t1q, \t1q, $14 +                                                                     \
vmull.p8 \rq, \ad, \bd +                                                              \
vext.8  \t2q, \t2q, \t2q, $13 +                                                       \
vext.8  \t3q, \t3q, \t3q, $12 +    veor    \t0q, \t0q, \t1q
+    veor    \t2q, \t2q, \t3q
+    veor    \rq, \rq, \t0q
+    veor    \rq, \rq, \t2q
+
+.endm
+
+C r0 key (pre-bitreversed)
+C r1 x (pre-bitreversed)
+C r2 count
+C r3 data
+PROLOGUE(_nettle_gcm_hash)
+	.fnstart
+	push {r4,r5,r6,r7}
+	.save {r4,r5,r6,r7}
+	vpush.64 {d8,d9,d10,d11,d12,d13,d14,d15}
+	.vsave {d8,d9,d10,d11,d12,d13,d14,d15}
+C q4 (d8 d9) = key
+	vld1.32 {d8,d9}, [r0:64]
+C q0 (d0 d1) = x
+	vld1.32 {d0,d1}, [r1:64]
+
+    vmov.i64 d14, #0x0000FFFFFFFFFFFF
+    vmov.i64 d13, #0x00000000FFFFFFFF
+    vmov.i64 d12, #0x000000000000FFFF
+	cmp	r2, #15
+	bls	.Lleftover
+.Lloop:
+	ldr r4, [r3] @ unaligned
+	ldr r5, [r3, #+4] @ unaligned
+	ldr r6, [r3, #+8] @ unaligned
+	ldr r7, [r3, #+12] @ unaligned
+	sub	r2, #16
+	add	r3, #16
+.Lentry:
+	rbit	r4, r4
+	rbit	r5, r5
+	 rbit	r6, r6
+	 rbit	r7, r7
+	vmov	d6, r4, r5
+	 vmov	d7, r6, r7
+	vrev32.i8 d6, d6
+	 vrev32.i8 d7, d7
+	vmov	q2, q4
+	 veor	q3, q0
+
+    @vld1.32 {d4,d5}, [r1:64]
+    @vld1.32 {d6,d7}, [r2:64]
+
+    MUL64k3t4 q0, d0, d1, d4, d6, d12, d13, d14, q12, d24, d25, q13, d26, d27, q14, \
d28, d29, q15, d30, d31 +    MUL64k3t4 q1, d2, d3, d5, d7, d12, d13, d14, q12, d24, \
d25, q13, d26, d27, q14, d28, d29, q15, d30, d31 +    veor d6, d7
+    veor d7, d4, d5
+    MUL64k3t4 q2, d4, d5, d6, d7, d12, d13, d14, q12, d24, d25, q13, d26, d27, q14, \
d28, d29, q15, d30, d31 +    veor q2, q0
+    veor q2, q1
+    veor d1, d4
+    veor d2, d5
+
+    @vst1.32 {d0-d3}, [r0:64]
+    @bx lr
+
+    vmov.i8 d30, #135
+    //[d3:d2|d1:d0]
+    //[d3:d2] * r(z)
+    //[d5:d4] = d2 * r(z)
+    //[d7:d6] = d3 * r(z)
+    vmull.p8 q2, d2, d30
+    vmull.p8 q3, d3, d30
+    vuzp.8 d4, d5
+    vuzp.8 d6, d7
+
+    vswp d5, d6
+
+    veor q0, q2
+    vshl.i64 q8, q3, #8
+    vsri.64 d17, d6, #(64-8)
+    vshr.U64 d18, d7, #(64-8)
+    veor q0, q8
+
+    vmull.p8 q2, d18, d30
+    veor d0, d4
+
+    @vst1.32 {d0,d1}, [r0:64]
+    @bx lr
+
+	cmp	r2, #15
+	bhi	.Lloop
+
+.Lleftover:
+	add	r3, r2
+	 mov	r4, #0
+	rsb	r2, r2, #15
+	 mov	r5, #0
+	 mov	r6, #0
+	cmp	r2, #14
+	 mov	r7, #0
+	addls	pc, pc, r2, asl #3
+1:
+	b .Lexit
+	.rept 3
+	ldrb	ip, [r3, #-1]!
+	orr	r7, ip, r7, lsl #8
+	.endr
+	.irpc r,654
+	.rept 4
+	ldrb	ip, [r3, #-1]!
+	orr	r\r, ip, r\r, lsl #8
+	.endr
+	.endr
+2:
+	.ifne 1b-2b+(4+8*15)
+	.error "incorrect switch table size"
+	.endif
+	mov	r2,#0
+	b .Lentry
+.Lexit:
+	vpop.64	{d8,d9,d10,d11,d12,d13,d14,d15}
+	vst1.32	{d0,d1}, [r1:64]
+	pop	{r4,r5,r6,r7}
+	bx lr
+	.fnend
+
+EPILOGUE(_nettle_gcm_hash)
+
+PROLOGUE(_nettle_gcm_hash_convert)
+	.fnstart
+    ldm r1, {r1, r2, r3, ip}
+    rbit r1, r1
+    rbit r2, r2
+    rbit r3, r3
+    rbit ip, ip
+    rev r1, r1
+    rev r2, r2
+    rev r3, r3
+    rev ip, ip
+    stm r0, {r1, r2, r3, ip}
+    bx lr
+	.fnend
+EPILOGUE(_nettle_gcm_hash_convert)
diff --git a/configure.ac b/configure.ac
index 3f409fa4..f12dbf34 100644
--- a/configure.ac
+++ b/configure.ac
@@ -473,6 +473,7 @@ asm_replace_list="aes-encrypt-internal.asm \
aes-decrypt-internal.asm \  asm_nettle_optional_list="gcm-hash8.asm cpuid.asm \
   aes-encrypt-internal-2.asm aes-decrypt-internal-2.asm memxor-2.asm \
   chacha-core-internal-2.asm \
+  gcm-hash.asm gcm-hash-2.asm \
   salsa20-core-internal-2.asm sha1-compress-2.asm sha256-compress-2.asm \
   sha3-permute-2.asm sha512-compress-2.asm \
   umac-nh-n-2.asm umac-nh-2.asm"
@@ -587,6 +588,8 @@ AH_VERBATIM([HAVE_NATIVE],
 #undef HAVE_NATIVE_ecc_521_modp
 #undef HAVE_NATIVE_ecc_521_redc
 #undef HAVE_NATIVE_gcm_hash8
+#undef HAVE_NATIVE_gcm_hash
+#undef HAVE_NATIVE_gcm_hash_convert
 #undef HAVE_NATIVE_salsa20_core
 #undef HAVE_NATIVE_sha1_compress
 #undef HAVE_NATIVE_sha256_compress
diff --git a/fat-arm.c b/fat-arm.c
index 48feb5d4..6e4c8622 100644
--- a/fat-arm.c
+++ b/fat-arm.c
@@ -175,6 +175,14 @@ DECLARE_FAT_FUNC(_nettle_chacha_core, chacha_core_func)
 DECLARE_FAT_FUNC_VAR(chacha_core, chacha_core_func, c);
 DECLARE_FAT_FUNC_VAR(chacha_core, chacha_core_func, neon);
 
+typedef void gcm_hash_func(const struct gcm_key *key, union nettle_block16 *x,
+	 size_t length, const uint8_t *data);
+typedef void gcm_hash_convert_func (union nettle_block16 *dst, const void *);
+extern gcm_hash_func _nettle_gcm_hash_c, _nettle_gcm_hash_neon;
+extern gcm_hash_convert_func _nettle_gcm_hash_convert_c, \
_nettle_gcm_hash_convert_neon; +extern gcm_hash_func *_nettle_gcm_hash_vec;
+extern gcm_hash_convert_func *_nettle_gcm_hash_convert_vec;
+
 static void CONSTRUCTOR
 fat_init (void)
 {
@@ -217,6 +225,10 @@ fat_init (void)
       _nettle_umac_nh_vec = _nettle_umac_nh_neon;
       _nettle_umac_nh_n_vec = _nettle_umac_nh_n_neon;
       _nettle_chacha_core_vec = _nettle_chacha_core_neon;
+#if !WORDS_BIGENDIAN &amp;&amp; defined(HAVE_NATIVE_gcm_hash) &amp;&amp; \
defined(HAVE_NATIVE_gcm_hash_convert) +      _nettle_gcm_hash_vec = \
_nettle_gcm_hash_neon; +      _nettle_gcm_hash_convert_vec = \
_nettle_gcm_hash_convert_neon; +#endif
     }
   else
     {
diff --git a/gcm.c b/gcm.c
index 14a6181b..a2467e39 100644
--- a/gcm.c
+++ b/gcm.c
@@ -331,6 +331,18 @@ gcm_gf_mul (union nettle_block16 *x, const union nettle_block16 \
*table)  /* Increment the rightmost 32 bits. */
 #define INC32(block) INCREMENT(4, (block.b) + GCM_BLOCK_SIZE - 4)
 
+#if !WORDS_BIGENDIAN &amp;&amp; defined(HAVE_NATIVE_gcm_hash) &amp;&amp; \
defined(HAVE_NATIVE_gcm_hash_convert) +typedef void gcm_hash_func(const struct \
gcm_key *key, union nettle_block16 *x, +	 size_t length, const uint8_t *data);
+gcm_hash_func _nettle_gcm_hash_c, _nettle_gcm_hash;
+gcm_hash_func *_nettle_gcm_hash_vec = _nettle_gcm_hash_c;
+typedef void gcm_hash_convert_func (union nettle_block16 *dst, const union \
nettle_block16*); +#define gcm_hash (*_nettle_gcm_hash_vec)
+gcm_hash_convert_func _nettle_gcm_hash_convert_c, _nettle_gcm_hash_convert;
+gcm_hash_convert_func *_nettle_gcm_hash_convert_vec = _nettle_gcm_hash_convert_c;
+#define gcm_hash_convert (*_nettle_gcm_hash_convert_vec)
+#endif
+
 /* Initialization of GCM.
  * @ctx: The context of GCM
  * @cipher: The context of the underlying block cipher
@@ -347,7 +359,14 @@ gcm_set_key(struct gcm_key *key,
   /* H */  
   memset(key-&gt;h[0].b, 0, GCM_BLOCK_SIZE);
   f (cipher, GCM_BLOCK_SIZE, key-&gt;h[i].b, key-&gt;h[0].b);
-  
+
+#if !WORDS_BIGENDIAN &amp;&amp; defined(HAVE_NATIVE_gcm_hash) &amp;&amp; \
defined(HAVE_NATIVE_gcm_hash_convert) + if (gcm_hash_convert != \
_nettle_gcm_hash_convert_c) { +   key-&gt;h[0] = key-&gt;h[i];
+   return;
+ }
+#endif
+
 #if GCM_TABLE_BITS
   /* Algorithm 3 from the gcm paper. First do powers of two, then do
      the rest by adding. */
@@ -362,10 +381,26 @@ gcm_set_key(struct gcm_key *key,
 #endif
 }
 
+#ifndef gcm_hash_convert
+static void
+gcm_hash_convert(union nettle_block16 *x, const union nettle_block16 *y)
+#else
+void
+_nettle_gcm_hash_convert_c(union nettle_block16 *x, const union nettle_block16 *y)
+#endif
+{
+  if (x != y) memcpy(x, y, sizeof(*x));
+}
+
 #ifndef gcm_hash
 static void
 gcm_hash(const struct gcm_key *key, union nettle_block16 *x,
 	 size_t length, const uint8_t *data)
+#else
+void
+_nettle_gcm_hash_c(const struct gcm_key *key, union nettle_block16 *x,
+	 size_t length, const uint8_t *data)
+#endif
 {
   for (; length &gt;= GCM_BLOCK_SIZE;
        length -= GCM_BLOCK_SIZE, data += GCM_BLOCK_SIZE)
@@ -379,7 +414,6 @@ gcm_hash(const struct gcm_key *key, union nettle_block16 *x,
       gcm_gf_mul (x, key-&gt;h);
     }
 }
-#endif /* !gcm_hash */
 
 static void
 gcm_hash_sizes(const struct gcm_key *key, union nettle_block16 *x,
@@ -414,6 +448,7 @@ gcm_set_iv(struct gcm_ctx *ctx, const struct gcm_key *key,
       memset(ctx-&gt;iv.b, 0, GCM_BLOCK_SIZE);
       gcm_hash(key, &amp;ctx-&gt;iv, length, iv);
       gcm_hash_sizes(key, &amp;ctx-&gt;iv, 0, length);
+      gcm_hash_convert(&amp;ctx-&gt;iv, &amp;ctx-&gt;iv);
     }
 
   memcpy (ctx-&gt;ctr.b, ctx-&gt;iv.b, GCM_BLOCK_SIZE);
@@ -491,6 +526,7 @@ gcm_digest(struct gcm_ctx *ctx, const struct gcm_key *key,
   gcm_hash_sizes(key, &amp;ctx-&gt;x, ctx-&gt;auth_size, ctx-&gt;data_size);
 
   f (cipher, GCM_BLOCK_SIZE, buffer, ctx-&gt;iv.b);
+  gcm_hash_convert (&amp;ctx-&gt;x, &amp;ctx-&gt;x);
   memxor3 (digest, ctx-&gt;x.b, buffer, length);
 
   return;
-- 
2.11.0


[Attachment #4 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190426084546</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-04-26 08:45:46-0400</timestampReceived><subject>Re: Intel CET protection</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; the attached patches have been used to successfully enable and test
&gt; Intel CET support in an Intel emulator on SDV hardware.

Thanks.

&gt; GCC already has all the needed support to create CET hardened code,
&gt; however the hand-coded assembly needs to be changed to conform.
&gt; Without these changes all the binaries that load nettle will otherwise
&gt; have CET disabled, as it is an all-or-nothing at the binary level and
&gt; missing ENDBRANCH instruction cause the program to terminate on
&gt; indirect jump/call instructions.

For the .note.gnu.property thing (which is per object file, right?), I
think it's better to do it in the same place as ASM_MARK_NOEXEC_STACK.
That's substituted in config.m4.in, and added at the end of each asm file
using m4 divert.

The endbr instructions in the prologue are in the right place, as far as
I can tell. And I'd be very tempted to rename the macro CET_ENDBR to
COME_FROM, see https://en.wikipedia.org/wiki/COMEFROM ;-)

&gt; The second patch is used to make the system happy when hardening flags
&gt; are enabled in gcc, as it generates the appropriate section information
&gt; that tells the linker all is good.

I'd like to understand what's missing. Maybe we can fix it more
explicitly? 

&gt; Finally while looking at the assembly I noticed that some functions
&gt; have a PROLOGUE() defined but not an EPILOGUE() macro defined in their
&gt; .asm files. It is unclear to me if this is an error or intentional so
&gt; didn't touch those, it doesn't affect functionality for this patch
&gt; anyway.

I think it's an error. Except in the files in arm/fat with lines like

  dnl PROLOGUE(_nettle_chacha_core) picked up by configure

I find three offending files, using

  $ diff &lt;(git grep -c '^ *EPILOGUE') &lt;(git grep -c '^ *PROLOGUE')
  49c49
  &lt; x86_64/poly1305-internal.asm:2
  ---
  &gt; x86_64/poly1305-internal.asm:3
  51a52,53
  &gt; x86_64/serpent-decrypt.asm:1
  &gt; x86_64/serpent-encrypt.asm:1

have you seen any others?

Some minor comments below.

&gt; From de1b9bfeb4f8ad9a6bf8608c4b8c727dba315982 Mon Sep 17 00:00:00 2001
&gt; From: Simo Sorce &lt;simo@redhat.com&gt;
&gt; Date: Tue, 23 Apr 2019 18:03:35 -0400
&gt; Subject: [PATCH 1/2] Add Intel CET protection support
&gt;
&gt; In upcoming processors Intel will make available Control-Flow
&gt; Enforcement Technology, which is comprised of two hardware
&gt; countermeasures against ROP based attacks.

Please spell out ROP. It would be good with a link to further
information in some reasonable place in the code.

&gt; The first is called Shadow Stack and checks that return from function
&gt; calls are not tampered with by keeping a shadow stack that cannot be
&gt; modified by aplications. This measure requires no code changes (except
&gt; for code that intentionally modifes the return pointer on the stack).

Fix spelling of "aplication", "modifes"

&gt; The second is called Indirect Branch Tracking and is used to insure only
&gt; targets of indirect jumps are actually jumped to. This requires
&gt; modification of code to insert a special instruction that identifies a
&gt; valid indirect jump target. When enforcement is turned on, if an indirect
&gt; jump does not end on this special instruction the cpu raises an exception.
&gt; These instructions are noops on older CPU models so it is safe to use
&gt; them in all x86(_64) code.
&gt;
&gt; To enable these protections gcc also inroduces a new GNU property note

and "inroduces"

&gt; +dnl GNU properties section to enable CET protections
&gt; +define(&lt;GNU_CET_SECTION&gt;,
&gt; +&lt;ifelse(CET_PROTECTION,yes,
&gt; +&lt;.pushsection .note.gnu.property,"a"

As I said, prefer to dot his globally with an m4 divert in config.m4.in.

&gt; +ALIGN(8)
&gt; +.long 1f - 0f
&gt; +.long 4f - 1f
&gt; +.long 5
&gt; +0:
&gt; +.string "GNU"
&gt; +1:
&gt; +ALIGN(8)
&gt; +.long 0xc0000002
&gt; +.long 3f - 2f
&gt; +2:
&gt; +.long 0x03
&gt; +3:
&gt; +ALIGN(8)
&gt; +4:

Are there no symbolic names for this note? Since we require assembler to
suport endbr instructions, can we require that it know about these notes
as well? What does it look like in gcc output?

&gt; diff --git a/x86_64/aes-decrypt-internal.asm b/x86_64/aes-decrypt-internal.asm
&gt; index 43f2f394..5db39868 100644
&gt; --- a/x86_64/aes-decrypt-internal.asm
&gt; +++ b/x86_64/aes-decrypt-internal.asm
&gt; @@ -62,7 +62,7 @@ C work.
&gt;  define(&lt;TMP&gt;,&lt;%rbp&gt;)
&gt;  
&gt;  	.file "aes-decrypt-internal.asm"
&gt; -	
&gt; +
&gt;  	C _aes_decrypt(unsigned rounds, const uint32_t *keys,
&gt;  	C	       const struct aes_table *T,
&gt;  	C	       size_t length, uint8_t *dst,
&gt; @@ -70,6 +70,7 @@ define(&lt;TMP&gt;,&lt;%rbp&gt;)
&gt;  	.text
&gt;  	ALIGN(16)
&gt;  PROLOGUE(_nettle_aes_decrypt)
&gt; +

Please trim unrelated whitespace changes from the patch (I known it's
not 100% consistent, but if we ever want to do something like M-x
whitespace-cleanup on all files, that should be in a separate commit. On
new changes, I usually run git diff --check to catch odd whitespace
use).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190426163204</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-04-26 16:32:04-0400</timestampReceived><subject>Re: Intel CET protection</subject><body>

On Fri, 2019-04-26 at 10:45 +0200, Niels Möller wrote:
&gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; 
&gt; &gt; the attached patches have been used to successfully enable and test
&gt; &gt; Intel CET support in an Intel emulator on SDV hardware.
&gt; 
&gt; Thanks.
&gt; 
&gt; &gt; GCC already has all the needed support to create CET hardened code,
&gt; &gt; however the hand-coded assembly needs to be changed to conform.
&gt; &gt; Without these changes all the binaries that load nettle will otherwise
&gt; &gt; have CET disabled, as it is an all-or-nothing at the binary level and
&gt; &gt; missing ENDBRANCH instruction cause the program to terminate on
&gt; &gt; indirect jump/call instructions.
&gt; 
&gt; For the .note.gnu.property thing (which is per object file, right?), I
&gt; think it's better to do it in the same place as ASM_MARK_NOEXEC_STACK.
&gt; That's substituted in config.m4.in, and added at the end of each asm file
&gt; using m4 divert.

So the reason I did not do that an instead explicitly added a statement
in the individual .asm files is that you cannot just add the note on
any random file.
The note states that the file uses CET instructions for all indirect
jump targets.
So, it just so happens now that no indirect jumps (except for the
target of the initial call into the functions) are used in our
handcrafted assembly, but that is not a given in the future.

So want I mean to say is that I took an explicit macro to mean the file
was actually analyzed and made CET compliant.

If we embed the macro magically instead this "inspection" part will be
missing and we may end up marking assembly files that do nbot in fact
comply with CET and will make the program segfault (that's how the
exception is surfaced) when run.

I understand this is not a high bar, and I will fold the segment note
in if you think that is what we should do, but I wanted to make you
aware of why I did not do the same as what we do with the stack note.

&gt; The endbr instructions in the prologue are in the right place, as far as
&gt; I can tell. And I'd be very tempted to rename the macro CET_ENDBR to
&gt; COME_FROM, see https://en.wikipedia.org/wiki/COMEFROM ;-)

That is funny, I actually used CET_ENDBR to make it easier to find for
others grepping as binutils also uses a _CET_ENDBR macro, it sounded
more consistent to use something with both "CET" and ENDBR in it,
easier to find for someone looking and figuring out hwat it is about.

&gt; &gt; The second patch is used to make the system happy when hardening flags
&gt; &gt; are enabled in gcc, as it generates the appropriate section information
&gt; &gt; that tells the linker all is good.
&gt; 
&gt; I'd like to understand what's missing. Maybe we can fix it more
&gt; explicitly? 

I do not think we can easily fix it manually, it is mostly other
section notes that the gcc compiler adds when it fortifies C code. But
those notes do not really apply to handcrafted assembly. So this flag
is basically just saying to the compiler that it should add whatever is
appropriate (which may change depending on compiler flags) because our
code is good as is.
It silence some checking tools mostly, so I do not think it is worth
wasting too much time trying to figure out what notes should be added,
the compiler is happy to do it for us.

&gt; &gt; Finally while looking at the assembly I noticed that some functions
&gt; &gt; have a PROLOGUE() defined but not an EPILOGUE() macro defined in their
&gt; &gt; .asm files. It is unclear to me if this is an error or intentional so
&gt; &gt; didn't touch those, it doesn't affect functionality for this patch
&gt; &gt; anyway.
&gt; 
&gt; I think it's an error. Except in the files in arm/fat with lines like
&gt; 
&gt; dnl PROLOGUE(_nettle_chacha_core) picked up by configure
&gt; 
&gt; I find three offending files, using
&gt; 
&gt; $ diff &lt;(git grep -c '^ *EPILOGUE') &lt;(git grep -c '^ *PROLOGUE')
&gt; 49c49
&gt; &lt; x86_64/poly1305-internal.asm:2
&gt; ---
&gt; &gt; x86_64/poly1305-internal.asm:3
&gt; 51a52,53
&gt; &gt; x86_64/serpent-decrypt.asm:1
&gt; &gt; x86_64/serpent-encrypt.asm:1
&gt; 
&gt; have you seen any others?

No, those are pretty much the places where I noticed it.
Would you want an additional patch that adds those EPILOGUES ?

&gt; Some minor comments below.
&gt; 
&gt; &gt; From de1b9bfeb4f8ad9a6bf8608c4b8c727dba315982 Mon Sep 17 00:00:00 2001
&gt; &gt; From: Simo Sorce &lt;simo@redhat.com&gt;
&gt; &gt; Date: Tue, 23 Apr 2019 18:03:35 -0400
&gt; &gt; Subject: [PATCH 1/2] Add Intel CET protection support
&gt; &gt; 
&gt; &gt; In upcoming processors Intel will make available Control-Flow
&gt; &gt; Enforcement Technology, which is comprised of two hardware
&gt; &gt; countermeasures against ROP based attacks.
&gt; 
&gt; Please spell out ROP. It would be good with a link to further
&gt; information in some reasonable place in the code.

Should I add a link in asm.m4 to this ?

https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf
 (I do no have a better link)

&gt; &gt; The first is called Shadow Stack and checks that return from function
&gt; &gt; calls are not tampered with by keeping a shadow stack that cannot be
&gt; &gt; modified by aplications. This measure requires no code changes (except
&gt; &gt; for code that intentionally modifes the return pointer on the stack).
&gt; 
&gt; Fix spelling of "aplication", "modifes"
&gt; 
&gt; &gt; The second is called Indirect Branch Tracking and is used to insure only
&gt; &gt; targets of indirect jumps are actually jumped to. This requires
&gt; &gt; modification of code to insert a special instruction that identifies a
&gt; &gt; valid indirect jump target. When enforcement is turned on, if an indirect
&gt; &gt; jump does not end on this special instruction the cpu raises an exception.
&gt; &gt; These instructions are noops on older CPU models so it is safe to use
&gt; &gt; them in all x86(_64) code.
&gt; &gt; 
&gt; &gt; To enable these protections gcc also inroduces a new GNU property note
&gt; 
&gt; and "inroduces"
&gt; 
&gt; &gt; +dnl GNU properties section to enable CET protections
&gt; &gt; +define(&lt;GNU_CET_SECTION&gt;,
&gt; &gt; +&lt;ifelse(CET_PROTECTION,yes,
&gt; &gt; +&lt;.pushsection .note.gnu.property,"a"
&gt; 
&gt; As I said, prefer to dot his globally with an m4 divert in config.m4.in.

See above explanation and let me know if that changes your opinion,
otherwise I will do this.

&gt; &gt; +ALIGN(8)
&gt; &gt; +.long 1f - 0f
&gt; &gt; +.long 4f - 1f
&gt; &gt; +.long 5
&gt; &gt; +0:
&gt; &gt; +.string "GNU"
&gt; &gt; +1:
&gt; &gt; +ALIGN(8)
&gt; &gt; +.long 0xc0000002
&gt; &gt; +.long 3f - 2f
&gt; &gt; +2:
&gt; &gt; +.long 0x03
&gt; &gt; +3:
&gt; &gt; +ALIGN(8)
&gt; &gt; +4:
&gt; 
&gt; Are there no symbolic names for this note? Since we require assembler to
&gt; suport endbr instructions, can we require that it know about these notes
&gt; as well? What does it look like in gcc output?

There are symbolic names to compose the 0x03 value and for the
0xc0000002 values, the rest are just label arithmetic.

I will change in next submission.

&gt; &gt; diff --git a/x86_64/aes-decrypt-internal.asm b/x86_64/aes-decrypt-internal.asm
&gt; &gt; index 43f2f394..5db39868 100644
&gt; &gt; --- a/x86_64/aes-decrypt-internal.asm
&gt; &gt; +++ b/x86_64/aes-decrypt-internal.asm
&gt; &gt; @@ -62,7 +62,7 @@ C work.
&gt; &gt; define(&lt;TMP&gt;,&lt;%rbp&gt;)
&gt; &gt; 
&gt; &gt; 	.file "aes-decrypt-internal.asm"
&gt; &gt; -	
&gt; &gt; +
&gt; &gt; 	C _aes_decrypt(unsigned rounds, const uint32_t *keys,
&gt; &gt; 	C	       const struct aes_table *T,
&gt; &gt; 	C	       size_t length, uint8_t *dst,
&gt; &gt; @@ -70,6 +70,7 @@ define(&lt;TMP&gt;,&lt;%rbp&gt;)
&gt; &gt; 	.text
&gt; &gt; 	ALIGN(16)
&gt; &gt; PROLOGUE(_nettle_aes_decrypt)
&gt; &gt; +
&gt; 
&gt; Please trim unrelated whitespace changes from the patch (I known it's
&gt; not 100% consistent, but if we ever want to do something like M-x
&gt; whitespace-cleanup on all files, that should be in a separate commit. On
&gt; new changes, I usually run git diff --check to catch odd whitespace
&gt; use).

Ok, this was not intentional, I will remove undesired changes.

Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190426171621</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-04-26 17:16:21-0400</timestampReceived><subject>Re: Intel CET protection</subject><body>

Ok attached find new patches,
they address all concerns except for adding the CET_SECTION macro
automagically to all asm files.
I also added a patch to deal with the missing epilogues.

Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


["0001-Add-Intel-CET-protection-support.patch" (0001-Add-Intel-CET-protection-support.patch)]

From 8c41a89ed3ef913bc8a12f8e6d21edf3627007ee Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Tue, 23 Apr 2019 18:03:35 -0400
Subject: [PATCH 1/3] Add Intel CET protection support

In upcoming processors Intel will make available Control-Flow
Enforcement Technology, which is comprised of two hardware
countermeasures against Return-Oriented Programming attacks.

The first is called Shadow Stack and checks that return from function
calls are not tampered with by keeping a shadow stack that cannot be
modified by applications. This measure requires no code changes (except
for code that intentionally modifies the return pointer on the stack).

The second is called Indirect Branch Tracking and is used to insure only
targets of indirect jumps are actually jumped to. This requires
modification of code to insert a special instruction that identifies a
valid indirect jump target. When enforcement is turned on, if an indirect
jump does not end on this special instruction the cpu raises an exception.
These instructions are noops on older CPU models so it is safe to use
them in all x86(_64) code.

To enable these protections GCC also introduces a new GNU property note
section that marks a piece of code as CET ready.
If the note is in place the dynamic linker will be able to confirm that
all loaded libraries support CET and will turn on CET protection for the
binary.

The changes here consist mostly in adding the GNU property note section
to all x86(_64) assembly files and the proper ENDBRANCH instruction for
the function entrypoints which is where other code calls into via
indirect call.

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 asm.m4                                | 36 ++++++++++++++++++++++++++-
 config.m4.in                          |  2 ++
 configure.ac                          | 17 +++++++++++++
 x86/aes-decrypt-internal.asm          |  1 +
 x86/aes-encrypt-internal.asm          |  1 +
 x86/arcfour-crypt.asm                 |  1 +
 x86/camellia-crypt-internal.asm       |  1 +
 x86/md5-compress.asm                  |  1 +
 x86/sha1-compress.asm                 |  1 +
 x86_64/aes-decrypt-internal.asm       |  1 +
 x86_64/aes-encrypt-internal.asm       |  1 +
 x86_64/aesni/aes-decrypt-internal.asm |  1 +
 x86_64/aesni/aes-encrypt-internal.asm |  1 +
 x86_64/camellia-crypt-internal.asm    |  1 +
 x86_64/chacha-core-internal.asm       |  1 +
 x86_64/fat/cpuid.asm                  |  2 +-
 x86_64/gcm-hash8.asm                  |  1 +
 x86_64/md5-compress.asm               |  1 +
 x86_64/memxor.asm                     |  1 +
 x86_64/memxor3.asm                    |  1 +
 x86_64/poly1305-internal.asm          |  1 +
 x86_64/salsa20-core-internal.asm      |  1 +
 x86_64/salsa20-crypt.asm              |  1 +
 x86_64/serpent-decrypt.asm            |  2 ++
 x86_64/serpent-encrypt.asm            |  2 ++
 x86_64/sha1-compress.asm              |  1 +
 x86_64/sha256-compress.asm            |  1 +
 x86_64/sha3-permute.asm               |  1 +
 x86_64/sha512-compress.asm            |  1 +
 x86_64/sha_ni/sha1-compress.asm       |  1 +
 x86_64/sha_ni/sha256-compress.asm     |  1 +
 x86_64/umac-nh-n.asm                  |  1 +
 x86_64/umac-nh.asm                    |  1 +
 33 files changed, 86 insertions(+), 2 deletions(-)

diff --git a/asm.m4 b/asm.m4
index 8da47201..9622906e 100644
--- a/asm.m4
+++ b/asm.m4
@@ -32,7 +32,8 @@ define(&lt;GMP_NUMB_BITS&gt;,&lt;&gt;)dnl
 define(&lt;PROLOGUE&gt;,
 &lt;.globl C_NAME($1)
 DECLARE_FUNC(C_NAME($1))
-C_NAME($1):&gt;)
+C_NAME($1):
+CET_ENDBR&gt;)
 
 define(&lt;EPILOGUE&gt;,
 &lt;ifelse(ELF_STYLE,yes,
@@ -59,6 +60,39 @@ WORDS_BIGENDIAN,no,&lt;$2&gt;,
   m4exit(1)&gt;)&gt;)
 define(&lt;IF_LE&gt;, &lt;IF_BE(&lt;$2&gt;, &lt;$1&gt;)&gt;)
 
+dnl GNU properties section to enable CET protections macros
+
+dnl GNU Poperty type
+define(&lt;NT_GNU_PROPERTY_TYPE_0&gt;, &lt;5&gt;)
+dnl GNU Program Property Type range
+define(GNU_PROPERTY_X86_UINT32_AND_LO, &lt;0xc0000002&gt;)
+dnl Indirect Branch Tracking
+define(&lt;GNU_PROPERTY_X86_FEATURE_1_IBT&gt;, &lt;0x01&gt;)
+dnl Shadow Stack
+define(&lt;GNU_PROPERTY_X86_FEATURE_1_SHSTK&gt;, &lt;0x02&gt;)
+
+dnl NOTE: GNU Property sections MUST have alignment of 8
+define(&lt;GNU_CET_SECTION&gt;,
+&lt;ifelse(CET_PROTECTION,yes,
+&lt;.pushsection .note.gnu.property,"a"
+ALIGN(8)
+.long 1f - 0f
+.long 4f - 1f
+.long NT_GNU_PROPERTY_TYPE_0()
+0:
+.string "GNU"
+1:
+ALIGN(8)
+.long GNU_PROPERTY_X86_UINT32_AND_LO()
+.long 3f - 2f
+2:
+.long eval(GNU_PROPERTY_X86_FEATURE_1_IBT() | GNU_PROPERTY_X86_FEATURE_1_SHSTK())
+3:
+ALIGN(8)
+4:
+.popsection
+&gt;,&lt;&gt;)&gt;)
+
 dnl Struct defining macros
 
 dnl STRUCTURE(prefix) 
diff --git a/config.m4.in b/config.m4.in
index 11f90a40..c3ebad60 100644
--- a/config.m4.in
+++ b/config.m4.in
@@ -8,6 +8,8 @@ define(&lt;ALIGN_LOG&gt;, &lt;@ASM_ALIGN_LOG@&gt;)dnl
 define(&lt;W64_ABI&gt;, &lt;@W64_ABI@&gt;)dnl
 define(&lt;RODATA&gt;, &lt;@ASM_RODATA@&gt;)dnl
 define(&lt;WORDS_BIGENDIAN&gt;, &lt;@ASM_WORDS_BIGENDIAN@&gt;)dnl
+define(&lt;CET_PROTECTION&gt;, &lt;@ASM_CET_PROTECTION@&gt;)dnl
+define(&lt;CET_ENDBR&gt;, &lt;@ASM_CET_ENDBR@&gt;)dnl
 divert(1)
 @ASM_MARK_NOEXEC_STACK@
 divert
diff --git a/configure.ac b/configure.ac
index 00d2bf5d..6e12bb1f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -93,6 +93,10 @@ AC_ARG_ENABLE(mini-gmp,
   AC_HELP_STRING([--enable-mini-gmp], [Enable mini-gmp, used instead of libgmp.]),,
   [enable_mini_gmp=no])
 
+AC_ARG_ENABLE(cet-protection,
+  AC_HELP_STRING([--enable-cet-protection], [Enable intel CET protection instructions. (default=no)]),,
+  [enable_cet_protection=no])
+
 if test "x$enable_mini_gmp" = xyes ; then
   NETTLE_USE_MINI_GMP=1
   HOGWEED_EXTRA_SYMBOLS="mpz_*;gmp_*;mpn_*;mp_*;"
@@ -701,6 +705,8 @@ ASM_COFF_STYLE='no'
 ASM_TYPE_FUNCTION='@function'
 ASM_TYPE_PROGBITS='@progbits'
 ASM_MARK_NOEXEC_STACK=''
+ASM_CET_PROTECTION='no'
+ASM_CET_ENDBR=''
 ASM_ALIGN_LOG=''
 
 if test x$enable_assembler = xyes ; then
@@ -812,6 +818,15 @@ EOF
        [nettle_cv_asm_align_log=yes],
        [nettle_cv_asm_align_log=no])])
   ASM_ALIGN_LOG="$nettle_cv_asm_align_log"
+
+  if test "x$enable_cet_protection" = xyes ; then
+    ASM_CET_PROTECTION=yes
+    if test "$ABI" = 64 ; then
+      ASM_CET_ENDBR=endbr64
+    else
+      ASM_CET_ENDBR=endbr32
+    fi
+  fi
 fi
 
 AC_SUBST(ASM_SYMBOL_PREFIX)
@@ -823,6 +838,8 @@ AC_SUBST(ASM_MARK_NOEXEC_STACK)
 AC_SUBST(ASM_ALIGN_LOG)
 AC_SUBST(W64_ABI)
 AC_SUBST(ASM_WORDS_BIGENDIAN)
+AC_SUBST(ASM_CET_PROTECTION)
+AC_SUBST(ASM_CET_ENDBR)
 AC_SUBST(EMULATOR)
 
 AC_SUBST(LIBNETTLE_MAJOR)
diff --git a/x86/aes-decrypt-internal.asm b/x86/aes-decrypt-internal.asm
index ff535b6a..1d16f6db 100644
--- a/x86/aes-decrypt-internal.asm
+++ b/x86/aes-decrypt-internal.asm
@@ -175,3 +175,4 @@ PROLOGUE(_nettle_aes_decrypt)
 	popl	%ebx
 	ret
 EPILOGUE(_nettle_aes_decrypt)
+GNU_CET_SECTION()
diff --git a/x86/aes-encrypt-internal.asm b/x86/aes-encrypt-internal.asm
index 934158f7..d9579e04 100644
--- a/x86/aes-encrypt-internal.asm
+++ b/x86/aes-encrypt-internal.asm
@@ -175,3 +175,4 @@ PROLOGUE(_nettle_aes_encrypt)
 	popl	%ebx
 	ret
 EPILOGUE(_nettle_aes_encrypt)
+GNU_CET_SECTION()
diff --git a/x86/arcfour-crypt.asm b/x86/arcfour-crypt.asm
index df3fe869..11f592e7 100644
--- a/x86/arcfour-crypt.asm
+++ b/x86/arcfour-crypt.asm
@@ -123,3 +123,4 @@ C .Lloop_done:
 	popl	%ebx
 	ret
 EPILOGUE(nettle_arcfour_crypt)
+GNU_CET_SECTION()
diff --git a/x86/camellia-crypt-internal.asm b/x86/camellia-crypt-internal.asm
index ce8c57f0..afac1fcc 100644
--- a/x86/camellia-crypt-internal.asm
+++ b/x86/camellia-crypt-internal.asm
@@ -223,3 +223,4 @@ PROLOGUE(_nettle_camellia_crypt)
 	popl	%ebx
 	ret
 EPILOGUE(_nettle_camellia_crypt)
+GNU_CET_SECTION()
diff --git a/x86/md5-compress.asm b/x86/md5-compress.asm
index c849c082..6293f052 100644
--- a/x86/md5-compress.asm
+++ b/x86/md5-compress.asm
@@ -185,3 +185,4 @@ PROLOGUE(nettle_md5_compress)
 	popl	%ebx
 	ret
 EPILOGUE(nettle_md5_compress)
+GNU_CET_SECTION()
diff --git a/x86/sha1-compress.asm b/x86/sha1-compress.asm
index 03bdcdc9..4e1f121c 100644
--- a/x86/sha1-compress.asm
+++ b/x86/sha1-compress.asm
@@ -1541,6 +1541,7 @@ C 	ROUND_F2(SB, SC, SD, SE, SA, 79, K4VALUE)
 	popl	%ebx
 	ret
 EPILOGUE(nettle_sha1_compress)
+GNU_CET_SECTION()
 
 C TODO:
 
diff --git a/x86_64/aes-decrypt-internal.asm b/x86_64/aes-decrypt-internal.asm
index 43f2f394..eedfaaf0 100644
--- a/x86_64/aes-decrypt-internal.asm
+++ b/x86_64/aes-decrypt-internal.asm
@@ -150,3 +150,4 @@ PROLOGUE(_nettle_aes_decrypt)
 	W64_EXIT(6, 0)
 	ret
 EPILOGUE(_nettle_aes_decrypt)
+GNU_CET_SECTION()
diff --git a/x86_64/aes-encrypt-internal.asm b/x86_64/aes-encrypt-internal.asm
index dfb498f5..3a5a1e86 100644
--- a/x86_64/aes-encrypt-internal.asm
+++ b/x86_64/aes-encrypt-internal.asm
@@ -151,3 +151,4 @@ PROLOGUE(_nettle_aes_encrypt)
 	W64_EXIT(6, 0)
 	ret
 EPILOGUE(_nettle_aes_encrypt)
+GNU_CET_SECTION()
diff --git a/x86_64/aesni/aes-decrypt-internal.asm b/x86_64/aesni/aes-decrypt-internal.asm
index 3d6d6e30..1b1a1a4d 100644
--- a/x86_64/aesni/aes-decrypt-internal.asm
+++ b/x86_64/aesni/aes-decrypt-internal.asm
@@ -132,3 +132,4 @@ PROLOGUE(_nettle_aes_decrypt)
 	W64_EXIT(6, 16)
 	ret
 EPILOGUE(_nettle_aes_decrypt)
+GNU_CET_SECTION()
diff --git a/x86_64/aesni/aes-encrypt-internal.asm b/x86_64/aesni/aes-encrypt-internal.asm
index 99caf1f8..f7338ef6 100644
--- a/x86_64/aesni/aes-encrypt-internal.asm
+++ b/x86_64/aesni/aes-encrypt-internal.asm
@@ -132,3 +132,4 @@ PROLOGUE(_nettle_aes_encrypt)
 	W64_EXIT(6, 16)
 	ret
 EPILOGUE(_nettle_aes_encrypt)
+GNU_CET_SECTION()
diff --git a/x86_64/camellia-crypt-internal.asm b/x86_64/camellia-crypt-internal.asm
index 040e030f..71750172 100644
--- a/x86_64/camellia-crypt-internal.asm
+++ b/x86_64/camellia-crypt-internal.asm
@@ -200,3 +200,4 @@ PROLOGUE(_nettle_camellia_crypt)
 	W64_EXIT(6, 0)
 	ret
 EPILOGUE(_nettle_camellia_crypt)
+GNU_CET_SECTION()
diff --git a/x86_64/chacha-core-internal.asm b/x86_64/chacha-core-internal.asm
index 9e5dc394..3125dee7 100644
--- a/x86_64/chacha-core-internal.asm
+++ b/x86_64/chacha-core-internal.asm
@@ -126,3 +126,4 @@ PROLOGUE(_nettle_chacha_core)
 	W64_EXIT(3, 6)
 	ret
 EPILOGUE(_nettle_chacha_core)
+GNU_CET_SECTION()
diff --git a/x86_64/fat/cpuid.asm b/x86_64/fat/cpuid.asm
index f317d56e..c4a5b538 100644
--- a/x86_64/fat/cpuid.asm
+++ b/x86_64/fat/cpuid.asm
@@ -56,4 +56,4 @@ PROLOGUE(_nettle_cpuid)
 	W64_EXIT(2)
 	ret
 EPILOGUE(_nettle_cpuid)
-
+GNU_CET_SECTION()
diff --git a/x86_64/gcm-hash8.asm b/x86_64/gcm-hash8.asm
index bfaa6ef8..54608ae8 100644
--- a/x86_64/gcm-hash8.asm
+++ b/x86_64/gcm-hash8.asm
@@ -199,6 +199,7 @@ ALIGN(16)
 	jnz	.Lread_loop
 	ret
 EPILOGUE(_nettle_gcm_hash8)
+GNU_CET_SECTION()
 
 define(&lt;W&gt;, &lt;0x$2$1&gt;)
 	RODATA
diff --git a/x86_64/md5-compress.asm b/x86_64/md5-compress.asm
index 182b8f18..ef1fcb89 100644
--- a/x86_64/md5-compress.asm
+++ b/x86_64/md5-compress.asm
@@ -174,3 +174,4 @@ PROLOGUE(nettle_md5_compress)
 
 	ret
 EPILOGUE(nettle_md5_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/memxor.asm b/x86_64/memxor.asm
index f07f0017..a0ea94b4 100644
--- a/x86_64/memxor.asm
+++ b/x86_64/memxor.asm
@@ -171,3 +171,4 @@ ifdef(&lt;USE_SSE2&gt;, &lt;
 &gt;)	
 
 EPILOGUE(nettle_memxor)
+GNU_CET_SECTION()
diff --git a/x86_64/memxor3.asm b/x86_64/memxor3.asm
index 8ff3e79c..b0c0e35c 100644
--- a/x86_64/memxor3.asm
+++ b/x86_64/memxor3.asm
@@ -261,3 +261,4 @@ ifelse(USE_SSE2, yes, &lt;
 	
 
 EPILOGUE(nettle_memxor3)
+GNU_CET_SECTION()
diff --git a/x86_64/poly1305-internal.asm b/x86_64/poly1305-internal.asm
index c780d122..d7edc4f9 100644
--- a/x86_64/poly1305-internal.asm
+++ b/x86_64/poly1305-internal.asm
@@ -183,3 +183,4 @@ define(&lt;T1&gt;, &lt;%rax&gt;)
 	W64_EXIT(2, 0)
 	ret
 
+GNU_CET_SECTION()
diff --git a/x86_64/salsa20-core-internal.asm b/x86_64/salsa20-core-internal.asm
index 4ef07be0..c1690880 100644
--- a/x86_64/salsa20-core-internal.asm
+++ b/x86_64/salsa20-core-internal.asm
@@ -109,3 +109,4 @@ PROLOGUE(_nettle_salsa20_core)
 	W64_EXIT(3, 9)
 	ret
 EPILOGUE(_nettle_salsa20_core)
+GNU_CET_SECTION()
diff --git a/x86_64/salsa20-crypt.asm b/x86_64/salsa20-crypt.asm
index cc1d58ca..e0348956 100644
--- a/x86_64/salsa20-crypt.asm
+++ b/x86_64/salsa20-crypt.asm
@@ -245,3 +245,4 @@ PROLOGUE(nettle_salsa20_crypt)
 	ret
 
 EPILOGUE(nettle_salsa20_crypt)
+GNU_CET_SECTION()
diff --git a/x86_64/serpent-decrypt.asm b/x86_64/serpent-decrypt.asm
index ee4bf9ad..9a93dfc7 100644
--- a/x86_64/serpent-decrypt.asm
+++ b/x86_64/serpent-decrypt.asm
@@ -713,3 +713,5 @@ PROLOGUE(nettle_serpent_decrypt)
 	pop	%rbx
 	W64_EXIT(4, 13)
 	ret
+
+GNU_CET_SECTION()
diff --git a/x86_64/serpent-encrypt.asm b/x86_64/serpent-encrypt.asm
index d6636537..a29358ca 100644
--- a/x86_64/serpent-encrypt.asm
+++ b/x86_64/serpent-encrypt.asm
@@ -748,3 +748,5 @@ C parallell.
 	pop	%rbx
 	W64_EXIT(4, 13)
 	ret
+
+GNU_CET_SECTION()
diff --git a/x86_64/sha1-compress.asm b/x86_64/sha1-compress.asm
index dd48de0e..54dfa313 100644
--- a/x86_64/sha1-compress.asm
+++ b/x86_64/sha1-compress.asm
@@ -305,3 +305,4 @@ PROLOGUE(nettle_sha1_compress)
 	W64_EXIT(2, 0)
 	ret
 EPILOGUE(nettle_sha1_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/sha256-compress.asm b/x86_64/sha256-compress.asm
index 5b7d0dcd..8dbccc5b 100644
--- a/x86_64/sha256-compress.asm
+++ b/x86_64/sha256-compress.asm
@@ -208,3 +208,4 @@ PROLOGUE(_nettle_sha256_compress)
 	W64_EXIT(3, 0)
 	ret
 EPILOGUE(_nettle_sha256_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/sha3-permute.asm b/x86_64/sha3-permute.asm
index 805b59af..a4d0cf0b 100644
--- a/x86_64/sha3-permute.asm
+++ b/x86_64/sha3-permute.asm
@@ -107,6 +107,7 @@ define(&lt;ROTL64&gt;, &lt;
 	
 	C sha3_permute(struct sha3_state *ctx)
 	.text
+GNU_CET_SECTION()
 	ALIGN(16)
 PROLOGUE(nettle_sha3_permute)
 	W64_ENTRY(1, 16)
diff --git a/x86_64/sha512-compress.asm b/x86_64/sha512-compress.asm
index 4ff1f32a..37563e93 100644
--- a/x86_64/sha512-compress.asm
+++ b/x86_64/sha512-compress.asm
@@ -208,3 +208,4 @@ PROLOGUE(_nettle_sha512_compress)
 	W64_EXIT(3, 0)
 	ret
 EPILOGUE(_nettle_sha512_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/sha_ni/sha1-compress.asm b/x86_64/sha_ni/sha1-compress.asm
index ab848fdd..3cbca5e2 100644
--- a/x86_64/sha_ni/sha1-compress.asm
+++ b/x86_64/sha_ni/sha1-compress.asm
@@ -146,3 +146,4 @@ PROLOGUE(nettle_sha1_compress)
 	W64_EXIT(2, 10)
 	ret
 EPILOGUE(nettle_sha1_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/sha_ni/sha256-compress.asm b/x86_64/sha_ni/sha256-compress.asm
index f2a4bd32..f9fe3757 100644
--- a/x86_64/sha_ni/sha256-compress.asm
+++ b/x86_64/sha_ni/sha256-compress.asm
@@ -173,3 +173,4 @@ PROLOGUE(_nettle_sha256_compress)
 	W64_EXIT(3, 10)
 	ret
 EPILOGUE(_nettle_sha256_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/umac-nh-n.asm b/x86_64/umac-nh-n.asm
index ecb6396a..195d5886 100644
--- a/x86_64/umac-nh-n.asm
+++ b/x86_64/umac-nh-n.asm
@@ -273,3 +273,4 @@ PROLOGUE(_nettle_umac_nh_n)
 	W64_EXIT(5, 14)
 	ret
 EPILOGUE(_nettle_umac_nh_n)
+GNU_CET_SECTION()
diff --git a/x86_64/umac-nh.asm b/x86_64/umac-nh.asm
index a6938e02..7bfc87ba 100644
--- a/x86_64/umac-nh.asm
+++ b/x86_64/umac-nh.asm
@@ -79,3 +79,4 @@ PROLOGUE(_nettle_umac_nh)
 	W64_EXIT(3, 7)
 	ret
 EPILOGUE(_nettle_umac_nh)
+GNU_CET_SECTION()
-- 
2.20.1


["0002-Fix-generation-of-build-notes-if-supported.patch" (0002-Fix-generation-of-build-notes-if-supported.patch)]

From f9c6191d393d4eb32c78bb2d2743bd72079a7635 Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Wed, 24 Apr 2019 16:13:59 -0400
Subject: [PATCH 2/3] Fix generation of build notes if supported

This is needed to build correctly on platfroms that use
hardening flags and build notes on .c files.

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 Makefile.in  |  4 +++-
 configure.ac | 23 +++++++++++++++++++++++
 2 files changed, 26 insertions(+), 1 deletion(-)

diff --git a/Makefile.in b/Makefile.in
index 440de9f7..4e603047 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -17,6 +17,8 @@ OPT_HOGWEED_OBJS = @OPT_HOGWEED_OBJS@
 
 OPT_NETTLE_SOURCES = @OPT_NETTLE_SOURCES@
 
+ASM_GEN_BUILD_NOTES = @ASM_GEN_BUILD_NOTES@
+
 SUBDIRS = tools testsuite examples
 
 include config.make
@@ -396,7 +398,7 @@ ecc-25519.$(OBJEXT): ecc-25519.h
 
 .asm.$(OBJEXT): $(srcdir)/asm.m4 machine.m4 config.m4
 	$(M4) $(srcdir)/asm.m4 machine.m4 config.m4 $&lt; &gt;$*.s
-	$(COMPILE) -c $*.s
+	$(COMPILE) -c $*.s $(ASM_GEN_BUILD_NOTES)
 	@echo "$@ : $&lt; $(srcdir)/asm.m4 machine.m4 config.m4" &gt;$@.d 
 
 # Texinfo rules
diff --git a/configure.ac b/configure.ac
index 6e12bb1f..87a97468 100644
--- a/configure.ac
+++ b/configure.ac
@@ -708,6 +708,7 @@ ASM_MARK_NOEXEC_STACK=''
 ASM_CET_PROTECTION='no'
 ASM_CET_ENDBR=''
 ASM_ALIGN_LOG=''
+ASM_GEN_BUILD_NOTES=''
 
 if test x$enable_assembler = xyes ; then
   AC_CACHE_CHECK([if globals are prefixed by underscore],
@@ -827,6 +828,27 @@ EOF
       ASM_CET_ENDBR=endbr32
     fi
   fi
+
+  AC_CACHE_CHECK([if --generate-missing-build-notes is supported],
+    nettle_cv_asm_build_notes,
+    [ # Default
+      nettle_cv_asm_build_notes=no
+
+      cat &gt;conftest.s &lt;&lt; EOF
+.text
+EOF
+      FLAG="-Wa,--generate-missing-build-notes=yes"
+      nettle_assemble="$CC $CFLAGS $CPPFLAGS -c conftest.s $FLAG &gt;conftest.out 2&gt;&amp;1"
+      if AC_TRY_EVAL(nettle_assemble); then
+        nettle_cv_asm_build_notes=yes
+      else
+       nettle_cv_asm_build_notes=no
+      fi
+    rm -f conftest.*])
+  if test x$nettle_cv_asm_build_notes = xyes ; then
+    ASM_GEN_BUILD_NOTES='-Wa,--generate-missing-build-notes=yes'
+  fi
+
 fi
 
 AC_SUBST(ASM_SYMBOL_PREFIX)
@@ -840,6 +862,7 @@ AC_SUBST(W64_ABI)
 AC_SUBST(ASM_WORDS_BIGENDIAN)
 AC_SUBST(ASM_CET_PROTECTION)
 AC_SUBST(ASM_CET_ENDBR)
+AC_SUBST(ASM_GEN_BUILD_NOTES)
 AC_SUBST(EMULATOR)
 
 AC_SUBST(LIBNETTLE_MAJOR)
-- 
2.20.1


["0003-Add-missing-EPILOGUEs-in-assembly-files.patch" (0003-Add-missing-EPILOGUEs-in-assembly-files.patch)]

From f4fd8f8f418da3800bb92e31b21e114f502400e2 Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Fri, 26 Apr 2019 13:12:53 -0400
Subject: [PATCH 3/3] Add missing EPILOGUEs in assembly files

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 x86_64/poly1305-internal.asm | 1 +
 x86_64/serpent-decrypt.asm   | 1 +
 x86_64/serpent-encrypt.asm   | 1 +
 3 files changed, 3 insertions(+)

diff --git a/x86_64/poly1305-internal.asm b/x86_64/poly1305-internal.asm
index d7edc4f9..3737450f 100644
--- a/x86_64/poly1305-internal.asm
+++ b/x86_64/poly1305-internal.asm
@@ -182,5 +182,6 @@ define(&lt;T1&gt;, &lt;%rax&gt;)
 	mov	XREG(%rax), P1305_H2 (CTX)
 	W64_EXIT(2, 0)
 	ret
+EPILOGUE(nettle_poly1305_digest)
 
 GNU_CET_SECTION()
diff --git a/x86_64/serpent-decrypt.asm b/x86_64/serpent-decrypt.asm
index 9a93dfc7..d715d85f 100644
--- a/x86_64/serpent-decrypt.asm
+++ b/x86_64/serpent-decrypt.asm
@@ -713,5 +713,6 @@ PROLOGUE(nettle_serpent_decrypt)
 	pop	%rbx
 	W64_EXIT(4, 13)
 	ret
+EPILOGUE(nettle_serpent_decrypt)
 
 GNU_CET_SECTION()
diff --git a/x86_64/serpent-encrypt.asm b/x86_64/serpent-encrypt.asm
index a29358ca..ef1cc3cc 100644
--- a/x86_64/serpent-encrypt.asm
+++ b/x86_64/serpent-encrypt.asm
@@ -748,5 +748,6 @@ C parallell.
 	pop	%rbx
 	W64_EXIT(4, 13)
 	ret
+EPILOGUE(nettle_serpent_encrypt)
 
 GNU_CET_SECTION()
-- 
2.20.1


[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190426203123</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-04-26 20:31:23-0400</timestampReceived><subject>Re: Intel CET protection</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; I understand this is not a high bar, and I will fold the segment note
&gt; in if you think that is what we should do, but I wanted to make you
&gt; aware of why I did not do the same as what we do with the stack note.

I think we should aim to make all files "cet-compliant" if we do it att
all. After all, the common case is to have a libnettle.so, and then any
single object file missing the annotation will make the linker disable
the feature, if I've understood it correctly. I agree it should be
disabled by default until we're more confident in test coverage.

BTW, do you know how that works with late loading using dlopen? One
could have a process running in CET-mode, which dynamically loads an
so-file with code lacking endbr instructions and corresponding
annotation.

If we think about it as an arch-specific thing, which I guess we should,
then maybe the m4 divert should be in x86_64/machine.m4 and
x86/machine.m4, not asm.m4.

&gt; That is funny, I actually used CET_ENDBR to make it easier to find for
&gt; others grepping as binutils also uses a _CET_ENDBR macro, it sounded
&gt; more consistent

I agree your name is better for readability, even if less amusing.

&gt; &gt; I'd like to understand what's missing. Maybe we can fix it more
&gt; &gt; explicitly? 
&gt; 
&gt; I do not think we can easily fix it manually, it is mostly other
&gt; section notes that the gcc compiler adds when it fortifies C code. But
&gt; those notes do not really apply to handcrafted assembly.
[...]
&gt; So this flag
&gt; is basically just saying to the compiler that it should add whatever is
&gt; appropriate (which may change depending on compiler flags) because our
&gt; code is good as is.

Since the command line flag is passed with -Wa, it tells the *assembler*
to add notes. Which ones? Is it based only on the command line, say,
$(CFLAGS) contains -fharden-foo makes the assembler produces a "foo"
note. Or is it based on what's actually in the assembly input file?

Is there a risk that it automatically generates a note promising
something about the assembly code which we don't actually fulfill?

Is there any documentation? I see that it is mentioned in the binutils-2.31
release announcement, but I've not found it mentioned in the Gas manual.

&gt; https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf
&gt;  (I do no have a better link)

Looks like reasonable doc. (Closest on wikpedia seems to be
https://en.wikipedia.org/wiki/Control-flow_integrity).

&gt; See above explanation and let me know if that changes your opinion,
&gt; otherwise I will do this.
&gt; 
&gt; &gt; &gt; +ALIGN(8)
&gt; &gt; &gt; +.long 1f - 0f
&gt; &gt; &gt; +.long 4f - 1f
&gt; &gt; &gt; +.long 5
&gt; &gt; &gt; +0:
&gt; &gt; &gt; +.string "GNU"
&gt; &gt; &gt; +1:
&gt; &gt; &gt; +ALIGN(8)
&gt; &gt; &gt; +.long 0xc0000002
&gt; &gt; &gt; +.long 3f - 2f
&gt; &gt; &gt; +2:
&gt; &gt; &gt; +.long 0x03
&gt; &gt; &gt; +3:
&gt; &gt; &gt; +ALIGN(8)
&gt; &gt; &gt; +4:
&gt; &gt; 
&gt; &gt; Are there no symbolic names for this note? Since we require assembler to
&gt; &gt; suport endbr instructions, can we require that it know about these notes
&gt; &gt; as well? What does it look like in gcc output?
&gt; 
&gt; There are symbolic names to compose the 0x03 value and for the
&gt; 0xc0000002 values, the rest are just label arithmetic.
&gt; 
&gt; I will change in next submission.

I see, I was hoping for something more similar to

  .section .note.GNU-stack,"",TYPE_PROGBITS

I'm still curious as to what it looks like in gcc output.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190427072150</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-04-27 07:21:50-0400</timestampReceived><subject>Re: Intel CET protection</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; they address all concerns except for adding the CET_SECTION macro
&gt; automagically to all asm files.

Thanks. I commented on that issue in my other mail.

&gt; I also added a patch to deal with the missing epilogues.

Applied now.

BTW are there any git experts here? I often apply complete patches by
running cd hack/nettle/ &amp;&amp; git am directly on the text/x-patch
attachment (the | command on the attachment in Gnus' *Article* buffer).
But all of git am, git apply, git am -3, git apply -3 failed on this
Patch #3, most likely because line numbers depended on the earlier
patches in the series, which I didn't want to apply right away.
Old-fashioned patch -p1 could apply the patch, with "fuzz 2".

So are there any other options to make the git patching tools a bit more
tolerant or fuzzy?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190427072927</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-04-27 07:29:27-0400</timestampReceived><subject>Re: Intel CET protection</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; Ok attached find new patches,
&gt; they address all concerns except for adding the CET_SECTION macro
&gt; automagically to all asm files.

Ah, one more thing:

&gt; +define(&lt;GNU_CET_SECTION&gt;,
&gt; +&lt;ifelse(CET_PROTECTION,yes,
&gt; +&lt;.pushsection .note.gnu.property,"a"

How portable is .pushsection? If we ensure that notes are last, plain
.section should be enough, I think.

&gt; --- a/x86_64/sha3-permute.asm
&gt; +++ b/x86_64/sha3-permute.asm
&gt; @@ -107,6 +107,7 @@ define(&lt;ROTL64&gt;, &lt;
&gt;  	
&gt;  	C sha3_permute(struct sha3_state *ctx)
&gt;  	.text
&gt; +GNU_CET_SECTION()
&gt;  	ALIGN(16)
&gt;  PROLOGUE(nettle_sha3_permute)
&gt;  	W64_ENTRY(1, 16)

This placement between .text and the prologue depends on .pushsection /
.popsection. I think it should be moved last, just like in the other
files, either explicitly or by means of a divert in some of the included
m4 files.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190427151728</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-04-27 15:17:28-0400</timestampReceived><subject>Re: Intel CET protection</subject><body>

On Fri, 2019-04-26 at 22:31 +0200, Niels Möller wrote:
&gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; 
&gt; &gt; I understand this is not a high bar, and I will fold the segment note
&gt; &gt; in if you think that is what we should do, but I wanted to make you
&gt; &gt; aware of why I did not do the same as what we do with the stack note.
&gt; 
&gt; I think we should aim to make all files "cet-compliant" if we do it att
&gt; all. After all, the common case is to have a libnettle.so, and then any
&gt; single object file missing the annotation will make the linker disable
&gt; the feature, if I've understood it correctly. I agree it should be
&gt; disabled by default until we're more confident in test coverage.

Yes we should have all files CET compliant, the idea of having a
distinct macro was to make it easy to catch submissions of new files
that lack it.

&gt; BTW, do you know how that works with late loading using dlopen? One
&gt; could have a process running in CET-mode, which dynamically loads an
&gt; so-file with code lacking endbr instructions and corresponding
&gt; annotation.

Yes I had the same question so I asked to our glibc gurus. The only
protection that is problematic is IBT as it requires insertion of new
instructions, so there is a mode where you can mark specific pages so
that the CPU will ignore missing endbr instruction exclusively for
executable code on those pages. So you can load an entire library via
dlopen() on specially marked pages and code running on those will have
no protection while the rest of the code will do. It is an all-or
nothing at the library level at that point.
It is not clear to me if this is fully supported today in glibc yet.

I guess in theory this could be done for individual libraries brought
in at execution time by the dynamic linker, but I think that is not
done and instead the whole binary is either enabled or disabled
currently.

&gt; If we think about it as an arch-specific thing, which I guess we should,
&gt; then maybe the m4 divert should be in x86_64/machine.m4 and
&gt; x86/machine.m4, not asm.m4.

Makes sense, I can move it, do you still want it to be automagically
added to all assembly files?

&gt; &gt; That is funny, I actually used CET_ENDBR to make it easier to find for
&gt; &gt; others grepping as binutils also uses a _CET_ENDBR macro, it sounded
&gt; &gt; more consistent
&gt; 
&gt; I agree your name is better for readability, even if less amusing.
&gt; 
&gt; &gt; &gt; I'd like to understand what's missing. Maybe we can fix it more
&gt; &gt; &gt; explicitly? 
&gt; &gt; 
&gt; &gt; I do not think we can easily fix it manually, it is mostly other
&gt; &gt; section notes that the gcc compiler adds when it fortifies C code. But
&gt; &gt; those notes do not really apply to handcrafted assembly.
&gt; 
&gt; [...]
&gt; &gt; So this flag
&gt; &gt; is basically just saying to the compiler that it should add whatever is
&gt; &gt; appropriate (which may change depending on compiler flags) because our
&gt; &gt; code is good as is.
&gt; 
&gt; Since the command line flag is passed with -Wa, it tells the *assembler*
&gt; to add notes.

True.

&gt; Which ones? Is it based only on the command line, say,
&gt; $(CFLAGS) contains -fharden-foo makes the assembler produces a "foo"
&gt; note. Or is it based on what's actually in the assembly input file?

It is not based on what is in the assembly input file afaik.
It generates "GNU Build Attribute" notes.

readelf show a single additional Owner attribute named GA$&lt;version&gt;3a1
with Data size always set to 0x10 and applied to each section of the
library corresponding to assembly files that cover the memory range
occupied by said library.

I have no more information than that at the moment, but I can ask if
you want me to dig through it.

&gt; Is there a risk that it automatically generates a note promising
&gt; something about the assembly code which we don't actually fulfill?

I was told that's not the case, I think it just sets bare notes that
basically do not assert anything specific, it just makes the tools that
check for those notes happy.

&gt; Is there any documentation? I see that it is mentioned in the binutils-2.31
&gt; release announcement, but I've not found it mentioned in the Gas manual.

Couldn't find anything either. Only some fedora wiki change proposal
page that mentions them.

&gt; &gt; https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf
&gt; &gt;  (I do no have a better link)
&gt; 
&gt; Looks like reasonable doc. (Closest on wikpedia seems to be
&gt; https://en.wikipedia.org/wiki/Control-flow_integrity).

Yeah I found this page too on wikipedia but is is it too generic (it
also referenced the link above)

&gt; &gt; See above explanation and let me know if that changes your opinion,
&gt; &gt; otherwise I will do this.
&gt; &gt; 
&gt; &gt; &gt; &gt; +ALIGN(8)
&gt; &gt; &gt; &gt; +.long 1f - 0f
&gt; &gt; &gt; &gt; +.long 4f - 1f
&gt; &gt; &gt; &gt; +.long 5
&gt; &gt; &gt; &gt; +0:
&gt; &gt; &gt; &gt; +.string "GNU"
&gt; &gt; &gt; &gt; +1:
&gt; &gt; &gt; &gt; +ALIGN(8)
&gt; &gt; &gt; &gt; +.long 0xc0000002
&gt; &gt; &gt; &gt; +.long 3f - 2f
&gt; &gt; &gt; &gt; +2:
&gt; &gt; &gt; &gt; +.long 0x03
&gt; &gt; &gt; &gt; +3:
&gt; &gt; &gt; &gt; +ALIGN(8)
&gt; &gt; &gt; &gt; +4:
&gt; &gt; &gt; 
&gt; &gt; &gt; Are there no symbolic names for this note? Since we require assembler to
&gt; &gt; &gt; suport endbr instructions, can we require that it know about these notes
&gt; &gt; &gt; as well? What does it look like in gcc output?
&gt; &gt; 
&gt; &gt; There are symbolic names to compose the 0x03 value and for the
&gt; &gt; 0xc0000002 values, the rest are just label arithmetic.
&gt; &gt; 
&gt; &gt; I will change in next submission.
&gt; 
&gt; I see, I was hoping for something more similar to
&gt; 
&gt; .section .note.GNU-stack,"",TYPE_PROGBITS

Nope, no such thing.

&gt; I'm still curious as to what it looks like in gcc output.

Exactly like the above.

You can see it appended in any .s file generated by gcc when you
compile with CFLAGS including -fcf-protection 

Attached find a new patch that replaces the first one and moves the
section definition to be machine specific

The second is a WIP, to also move the new instructions and make the
section atumagic. It makes the configure.ac clearer but requires to add
macros to each machine.m4 file.
Given it is a amchine specific technology I did not think it made sense
to add CET_ENDBR name in non intel architectures, and allows us to use
CODEFROM :-)

The other patches are unchanged, but I changed the order to put them
first so they can be applied right away if you want.



-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


["0001-Add-missing-EPILOGUEs-in-assembly-files.patch" (0001-Add-missing-EPILOGUEs-in-assembly-files.patch)]

From dcf9de29114bb4137b12787685cebfcfd962ad5f Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Fri, 26 Apr 2019 13:12:53 -0400
Subject: [PATCH 1/4] Add missing EPILOGUEs in assembly files

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 x86_64/poly1305-internal.asm | 1 +
 x86_64/serpent-decrypt.asm   | 1 +
 x86_64/serpent-encrypt.asm   | 1 +
 3 files changed, 3 insertions(+)

diff --git a/x86_64/poly1305-internal.asm b/x86_64/poly1305-internal.asm
index c780d122..98159ad3 100644
--- a/x86_64/poly1305-internal.asm
+++ b/x86_64/poly1305-internal.asm
@@ -182,4 +182,5 @@ define(&lt;T1&gt;, &lt;%rax&gt;)
 	mov	XREG(%rax), P1305_H2 (CTX)
 	W64_EXIT(2, 0)
 	ret
+EPILOGUE(nettle_poly1305_digest)
 
diff --git a/x86_64/serpent-decrypt.asm b/x86_64/serpent-decrypt.asm
index ee4bf9ad..031c41c8 100644
--- a/x86_64/serpent-decrypt.asm
+++ b/x86_64/serpent-decrypt.asm
@@ -713,3 +713,4 @@ PROLOGUE(nettle_serpent_decrypt)
 	pop	%rbx
 	W64_EXIT(4, 13)
 	ret
+EPILOGUE(nettle_serpent_decrypt)
diff --git a/x86_64/serpent-encrypt.asm b/x86_64/serpent-encrypt.asm
index d6636537..99cba00c 100644
--- a/x86_64/serpent-encrypt.asm
+++ b/x86_64/serpent-encrypt.asm
@@ -748,3 +748,4 @@ C parallell.
 	pop	%rbx
 	W64_EXIT(4, 13)
 	ret
+EPILOGUE(nettle_serpent_encrypt)
-- 
2.20.1


["0002-Fix-generation-of-build-notes-if-supported.patch" (0002-Fix-generation-of-build-notes-if-supported.patch)]

From af9b9379fdad760589acddb186620dcc7d994e8e Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Wed, 24 Apr 2019 16:13:59 -0400
Subject: [PATCH 2/4] Fix generation of build notes if supported

This is needed to build correctly on platfroms that use
hardening flags and build notes on .c files.

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 Makefile.in  |  4 +++-
 configure.ac | 22 ++++++++++++++++++++++
 2 files changed, 25 insertions(+), 1 deletion(-)

diff --git a/Makefile.in b/Makefile.in
index 440de9f7..4e603047 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -17,6 +17,8 @@ OPT_HOGWEED_OBJS = @OPT_HOGWEED_OBJS@
 
 OPT_NETTLE_SOURCES = @OPT_NETTLE_SOURCES@
 
+ASM_GEN_BUILD_NOTES = @ASM_GEN_BUILD_NOTES@
+
 SUBDIRS = tools testsuite examples
 
 include config.make
@@ -396,7 +398,7 @@ ecc-25519.$(OBJEXT): ecc-25519.h
 
 .asm.$(OBJEXT): $(srcdir)/asm.m4 machine.m4 config.m4
 	$(M4) $(srcdir)/asm.m4 machine.m4 config.m4 $&lt; &gt;$*.s
-	$(COMPILE) -c $*.s
+	$(COMPILE) -c $*.s $(ASM_GEN_BUILD_NOTES)
 	@echo "$@ : $&lt; $(srcdir)/asm.m4 machine.m4 config.m4" &gt;$@.d 
 
 # Texinfo rules
diff --git a/configure.ac b/configure.ac
index 00d2bf5d..ac921df0 100644
--- a/configure.ac
+++ b/configure.ac
@@ -702,6 +702,7 @@ ASM_TYPE_FUNCTION='@function'
 ASM_TYPE_PROGBITS='@progbits'
 ASM_MARK_NOEXEC_STACK=''
 ASM_ALIGN_LOG=''
+ASM_GEN_BUILD_NOTES=''
 
 if test x$enable_assembler = xyes ; then
   AC_CACHE_CHECK([if globals are prefixed by underscore],
@@ -812,6 +813,26 @@ EOF
        [nettle_cv_asm_align_log=yes],
        [nettle_cv_asm_align_log=no])])
   ASM_ALIGN_LOG="$nettle_cv_asm_align_log"
+
+  AC_CACHE_CHECK([if --generate-missing-build-notes is supported],
+    nettle_cv_asm_build_notes,
+    [ # Default
+      nettle_cv_asm_build_notes=no
+
+      cat &gt;conftest.s &lt;&lt; EOF
+.text
+EOF
+      FLAG="-Wa,--generate-missing-build-notes=yes"
+      nettle_assemble="$CC $CFLAGS $CPPFLAGS -c conftest.s $FLAG &gt;conftest.out 2&gt;&amp;1"
+      if AC_TRY_EVAL(nettle_assemble); then
+        nettle_cv_asm_build_notes=yes
+      else
+       nettle_cv_asm_build_notes=no
+      fi
+    rm -f conftest.*])
+  if test x$nettle_cv_asm_build_notes = xyes ; then
+    ASM_GEN_BUILD_NOTES='-Wa,--generate-missing-build-notes=yes'
+  fi
 fi
 
 AC_SUBST(ASM_SYMBOL_PREFIX)
@@ -823,6 +844,7 @@ AC_SUBST(ASM_MARK_NOEXEC_STACK)
 AC_SUBST(ASM_ALIGN_LOG)
 AC_SUBST(W64_ABI)
 AC_SUBST(ASM_WORDS_BIGENDIAN)
+AC_SUBST(ASM_GEN_BUILD_NOTES)
 AC_SUBST(EMULATOR)
 
 AC_SUBST(LIBNETTLE_MAJOR)
-- 
2.20.1


["0003-Add-Intel-CET-protection-support.patch" (0003-Add-Intel-CET-protection-support.patch)]

From a11dd90fc89767609be7729973bf9be0f8809d20 Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Tue, 23 Apr 2019 18:03:35 -0400
Subject: [PATCH 3/4] Add Intel CET protection support

In upcoming processors Intel will make available Control-Flow
Enforcement Technology, which is comprised of two hardware
countermeasures against Return-Oriented Programming attacks.

The first is called Shadow Stack and checks that return from function
calls are not tampered with by keeping a shadow stack that cannot be
modified by applications. This measure requires no code changes (except
for code that intentionally modifies the return pointer on the stack).

The second is called Indirect Branch Tracking and is used to insure only
targets of indirect jumps are actually jumped to. This requires
modification of code to insert a special instruction that identifies a
valid indirect jump target. When enforcement is turned on, if an indirect
jump does not end on this special instruction the cpu raises an exception.
These instructions are noops on older CPU models so it is safe to use
them in all x86(_64) code.

To enable these protections GCC also introduces a new GNU property note
section that marks a piece of code as CET ready.
If the note is in place the dynamic linker will be able to confirm that
all loaded libraries support CET and will turn on CET protection for the
binary.

The changes here consist mostly in adding the GNU property note section
to all x86(_64) assembly files and the proper ENDBRANCH instruction for
the function entrypoints which is where other code calls into via
indirect call.

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 asm.m4                                |  3 ++-
 config.m4.in                          |  2 ++
 configure.ac                          | 17 +++++++++++++
 x86/aes-decrypt-internal.asm          |  1 +
 x86/aes-encrypt-internal.asm          |  1 +
 x86/arcfour-crypt.asm                 |  1 +
 x86/camellia-crypt-internal.asm       |  1 +
 x86/machine.m4                        | 35 +++++++++++++++++++++++++++
 x86/md5-compress.asm                  |  1 +
 x86/sha1-compress.asm                 |  1 +
 x86_64/aes-decrypt-internal.asm       |  1 +
 x86_64/aes-encrypt-internal.asm       |  1 +
 x86_64/aesni/aes-decrypt-internal.asm |  1 +
 x86_64/aesni/aes-encrypt-internal.asm |  1 +
 x86_64/camellia-crypt-internal.asm    |  1 +
 x86_64/chacha-core-internal.asm       |  1 +
 x86_64/fat/cpuid.asm                  |  2 +-
 x86_64/gcm-hash8.asm                  |  1 +
 x86_64/machine.m4                     | 35 +++++++++++++++++++++++++++
 x86_64/md5-compress.asm               |  1 +
 x86_64/memxor.asm                     |  1 +
 x86_64/memxor3.asm                    |  1 +
 x86_64/poly1305-internal.asm          |  1 +
 x86_64/salsa20-core-internal.asm      |  1 +
 x86_64/salsa20-crypt.asm              |  1 +
 x86_64/serpent-decrypt.asm            |  1 +
 x86_64/serpent-encrypt.asm            |  1 +
 x86_64/sha1-compress.asm              |  1 +
 x86_64/sha256-compress.asm            |  1 +
 x86_64/sha3-permute.asm               |  1 +
 x86_64/sha512-compress.asm            |  1 +
 x86_64/sha_ni/sha1-compress.asm       |  1 +
 x86_64/sha_ni/sha256-compress.asm     |  1 +
 x86_64/umac-nh-n.asm                  |  1 +
 x86_64/umac-nh.asm                    |  1 +
 35 files changed, 121 insertions(+), 2 deletions(-)

diff --git a/asm.m4 b/asm.m4
index 8da47201..5a5d4ac2 100644
--- a/asm.m4
+++ b/asm.m4
@@ -32,7 +32,8 @@ define(&lt;GMP_NUMB_BITS&gt;,&lt;&gt;)dnl
 define(&lt;PROLOGUE&gt;,
 &lt;.globl C_NAME($1)
 DECLARE_FUNC(C_NAME($1))
-C_NAME($1):&gt;)
+C_NAME($1):
+CET_ENDBR&gt;)
 
 define(&lt;EPILOGUE&gt;,
 &lt;ifelse(ELF_STYLE,yes,
diff --git a/config.m4.in b/config.m4.in
index 11f90a40..c3ebad60 100644
--- a/config.m4.in
+++ b/config.m4.in
@@ -8,6 +8,8 @@ define(&lt;ALIGN_LOG&gt;, &lt;@ASM_ALIGN_LOG@&gt;)dnl
 define(&lt;W64_ABI&gt;, &lt;@W64_ABI@&gt;)dnl
 define(&lt;RODATA&gt;, &lt;@ASM_RODATA@&gt;)dnl
 define(&lt;WORDS_BIGENDIAN&gt;, &lt;@ASM_WORDS_BIGENDIAN@&gt;)dnl
+define(&lt;CET_PROTECTION&gt;, &lt;@ASM_CET_PROTECTION@&gt;)dnl
+define(&lt;CET_ENDBR&gt;, &lt;@ASM_CET_ENDBR@&gt;)dnl
 divert(1)
 @ASM_MARK_NOEXEC_STACK@
 divert
diff --git a/configure.ac b/configure.ac
index ac921df0..7beb35d9 100644
--- a/configure.ac
+++ b/configure.ac
@@ -93,6 +93,10 @@ AC_ARG_ENABLE(mini-gmp,
   AC_HELP_STRING([--enable-mini-gmp], [Enable mini-gmp, used instead of libgmp.]),,
   [enable_mini_gmp=no])
 
+AC_ARG_ENABLE(cet-protection,
+  AC_HELP_STRING([--enable-cet-protection], [Enable intel CET protection \
instructions. (default=no)]),, +  [enable_cet_protection=no])
+
 if test "x$enable_mini_gmp" = xyes ; then
   NETTLE_USE_MINI_GMP=1
   HOGWEED_EXTRA_SYMBOLS="mpz_*;gmp_*;mpn_*;mp_*;"
@@ -701,6 +705,8 @@ ASM_COFF_STYLE='no'
 ASM_TYPE_FUNCTION='@function'
 ASM_TYPE_PROGBITS='@progbits'
 ASM_MARK_NOEXEC_STACK=''
+ASM_CET_PROTECTION='no'
+ASM_CET_ENDBR=''
 ASM_ALIGN_LOG=''
 ASM_GEN_BUILD_NOTES=''
 
@@ -833,6 +839,15 @@ EOF
   if test x$nettle_cv_asm_build_notes = xyes ; then
     ASM_GEN_BUILD_NOTES='-Wa,--generate-missing-build-notes=yes'
   fi
+
+  if test "x$enable_cet_protection" = xyes ; then
+    ASM_CET_PROTECTION=yes
+    if test "$ABI" = 64 ; then
+      ASM_CET_ENDBR=endbr64
+    else
+      ASM_CET_ENDBR=endbr32
+    fi
+  fi
 fi
 
 AC_SUBST(ASM_SYMBOL_PREFIX)
@@ -845,6 +860,8 @@ AC_SUBST(ASM_ALIGN_LOG)
 AC_SUBST(W64_ABI)
 AC_SUBST(ASM_WORDS_BIGENDIAN)
 AC_SUBST(ASM_GEN_BUILD_NOTES)
+AC_SUBST(ASM_CET_PROTECTION)
+AC_SUBST(ASM_CET_ENDBR)
 AC_SUBST(EMULATOR)
 
 AC_SUBST(LIBNETTLE_MAJOR)
diff --git a/x86/aes-decrypt-internal.asm b/x86/aes-decrypt-internal.asm
index ff535b6a..1d16f6db 100644
--- a/x86/aes-decrypt-internal.asm
+++ b/x86/aes-decrypt-internal.asm
@@ -175,3 +175,4 @@ PROLOGUE(_nettle_aes_decrypt)
 	popl	%ebx
 	ret
 EPILOGUE(_nettle_aes_decrypt)
+GNU_CET_SECTION()
diff --git a/x86/aes-encrypt-internal.asm b/x86/aes-encrypt-internal.asm
index 934158f7..d9579e04 100644
--- a/x86/aes-encrypt-internal.asm
+++ b/x86/aes-encrypt-internal.asm
@@ -175,3 +175,4 @@ PROLOGUE(_nettle_aes_encrypt)
 	popl	%ebx
 	ret
 EPILOGUE(_nettle_aes_encrypt)
+GNU_CET_SECTION()
diff --git a/x86/arcfour-crypt.asm b/x86/arcfour-crypt.asm
index df3fe869..11f592e7 100644
--- a/x86/arcfour-crypt.asm
+++ b/x86/arcfour-crypt.asm
@@ -123,3 +123,4 @@ C .Lloop_done:
 	popl	%ebx
 	ret
 EPILOGUE(nettle_arcfour_crypt)
+GNU_CET_SECTION()
diff --git a/x86/camellia-crypt-internal.asm b/x86/camellia-crypt-internal.asm
index ce8c57f0..afac1fcc 100644
--- a/x86/camellia-crypt-internal.asm
+++ b/x86/camellia-crypt-internal.asm
@@ -223,3 +223,4 @@ PROLOGUE(_nettle_camellia_crypt)
 	popl	%ebx
 	ret
 EPILOGUE(_nettle_camellia_crypt)
+GNU_CET_SECTION()
diff --git a/x86/machine.m4 b/x86/machine.m4
index 38bee366..1153c757 100644
--- a/x86/machine.m4
+++ b/x86/machine.m4
@@ -14,3 +14,38 @@ define(&lt;HREG&gt;,&lt;ifelse(
 	$1, %ebx, %bh,
 	$1, %ecx, %ch,
 	$1, %edx, %dh)&gt;)dnl
+
+dnl GNU properties section to enable CET protections macros
+dnl For more info on the technology:
+dnl https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf
 +
+dnl GNU Poperty type
+define(&lt;NT_GNU_PROPERTY_TYPE_0&gt;, &lt;5&gt;)
+dnl GNU Program Property Type range
+define(GNU_PROPERTY_X86_UINT32_AND_LO, &lt;0xc0000002&gt;)
+dnl Indirect Branch Tracking
+define(&lt;GNU_PROPERTY_X86_FEATURE_1_IBT&gt;, &lt;0x01&gt;)
+dnl Shadow Stack
+define(&lt;GNU_PROPERTY_X86_FEATURE_1_SHSTK&gt;, &lt;0x02&gt;)
+
+dnl NOTE: GNU Property sections MUST have alignment of 8
+define(&lt;GNU_CET_SECTION&gt;,
+&lt;ifelse(CET_PROTECTION,yes,
+&lt;.pushsection .note.gnu.property,"a"
+ALIGN(8)
+.long 1f - 0f
+.long 4f - 1f
+.long NT_GNU_PROPERTY_TYPE_0()
+0:
+.string "GNU"
+1:
+ALIGN(8)
+.long GNU_PROPERTY_X86_UINT32_AND_LO()
+.long 3f - 2f
+2:
+.long eval(GNU_PROPERTY_X86_FEATURE_1_IBT() | GNU_PROPERTY_X86_FEATURE_1_SHSTK())
+3:
+ALIGN(8)
+4:
+.popsection
+&gt;,&lt;&gt;)&gt;)
diff --git a/x86/md5-compress.asm b/x86/md5-compress.asm
index c849c082..6293f052 100644
--- a/x86/md5-compress.asm
+++ b/x86/md5-compress.asm
@@ -185,3 +185,4 @@ PROLOGUE(nettle_md5_compress)
 	popl	%ebx
 	ret
 EPILOGUE(nettle_md5_compress)
+GNU_CET_SECTION()
diff --git a/x86/sha1-compress.asm b/x86/sha1-compress.asm
index 03bdcdc9..4e1f121c 100644
--- a/x86/sha1-compress.asm
+++ b/x86/sha1-compress.asm
@@ -1541,6 +1541,7 @@ C 	ROUND_F2(SB, SC, SD, SE, SA, 79, K4VALUE)
 	popl	%ebx
 	ret
 EPILOGUE(nettle_sha1_compress)
+GNU_CET_SECTION()
 
 C TODO:
 
diff --git a/x86_64/aes-decrypt-internal.asm b/x86_64/aes-decrypt-internal.asm
index 43f2f394..eedfaaf0 100644
--- a/x86_64/aes-decrypt-internal.asm
+++ b/x86_64/aes-decrypt-internal.asm
@@ -150,3 +150,4 @@ PROLOGUE(_nettle_aes_decrypt)
 	W64_EXIT(6, 0)
 	ret
 EPILOGUE(_nettle_aes_decrypt)
+GNU_CET_SECTION()
diff --git a/x86_64/aes-encrypt-internal.asm b/x86_64/aes-encrypt-internal.asm
index dfb498f5..3a5a1e86 100644
--- a/x86_64/aes-encrypt-internal.asm
+++ b/x86_64/aes-encrypt-internal.asm
@@ -151,3 +151,4 @@ PROLOGUE(_nettle_aes_encrypt)
 	W64_EXIT(6, 0)
 	ret
 EPILOGUE(_nettle_aes_encrypt)
+GNU_CET_SECTION()
diff --git a/x86_64/aesni/aes-decrypt-internal.asm \
b/x86_64/aesni/aes-decrypt-internal.asm index 3d6d6e30..1b1a1a4d 100644
--- a/x86_64/aesni/aes-decrypt-internal.asm
+++ b/x86_64/aesni/aes-decrypt-internal.asm
@@ -132,3 +132,4 @@ PROLOGUE(_nettle_aes_decrypt)
 	W64_EXIT(6, 16)
 	ret
 EPILOGUE(_nettle_aes_decrypt)
+GNU_CET_SECTION()
diff --git a/x86_64/aesni/aes-encrypt-internal.asm \
b/x86_64/aesni/aes-encrypt-internal.asm index 99caf1f8..f7338ef6 100644
--- a/x86_64/aesni/aes-encrypt-internal.asm
+++ b/x86_64/aesni/aes-encrypt-internal.asm
@@ -132,3 +132,4 @@ PROLOGUE(_nettle_aes_encrypt)
 	W64_EXIT(6, 16)
 	ret
 EPILOGUE(_nettle_aes_encrypt)
+GNU_CET_SECTION()
diff --git a/x86_64/camellia-crypt-internal.asm b/x86_64/camellia-crypt-internal.asm
index 040e030f..71750172 100644
--- a/x86_64/camellia-crypt-internal.asm
+++ b/x86_64/camellia-crypt-internal.asm
@@ -200,3 +200,4 @@ PROLOGUE(_nettle_camellia_crypt)
 	W64_EXIT(6, 0)
 	ret
 EPILOGUE(_nettle_camellia_crypt)
+GNU_CET_SECTION()
diff --git a/x86_64/chacha-core-internal.asm b/x86_64/chacha-core-internal.asm
index 9e5dc394..3125dee7 100644
--- a/x86_64/chacha-core-internal.asm
+++ b/x86_64/chacha-core-internal.asm
@@ -126,3 +126,4 @@ PROLOGUE(_nettle_chacha_core)
 	W64_EXIT(3, 6)
 	ret
 EPILOGUE(_nettle_chacha_core)
+GNU_CET_SECTION()
diff --git a/x86_64/fat/cpuid.asm b/x86_64/fat/cpuid.asm
index f317d56e..c4a5b538 100644
--- a/x86_64/fat/cpuid.asm
+++ b/x86_64/fat/cpuid.asm
@@ -56,4 +56,4 @@ PROLOGUE(_nettle_cpuid)
 	W64_EXIT(2)
 	ret
 EPILOGUE(_nettle_cpuid)
-
+GNU_CET_SECTION()
diff --git a/x86_64/gcm-hash8.asm b/x86_64/gcm-hash8.asm
index bfaa6ef8..54608ae8 100644
--- a/x86_64/gcm-hash8.asm
+++ b/x86_64/gcm-hash8.asm
@@ -199,6 +199,7 @@ ALIGN(16)
 	jnz	.Lread_loop
 	ret
 EPILOGUE(_nettle_gcm_hash8)
+GNU_CET_SECTION()
 
 define(&lt;W&gt;, &lt;0x$2$1&gt;)
 	RODATA
diff --git a/x86_64/machine.m4 b/x86_64/machine.m4
index 397e9b25..a64241ce 100644
--- a/x86_64/machine.m4
+++ b/x86_64/machine.m4
@@ -171,3 +171,38 @@ define(&lt;W64_EXIT&gt;, &lt;
   ])
   changequote(&lt;,&gt;)dnl
 &gt;)
+
+dnl GNU properties section to enable CET protections macros
+dnl For more info on the technology:
+dnl https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf
 +
+dnl GNU Poperty type
+define(&lt;NT_GNU_PROPERTY_TYPE_0&gt;, &lt;5&gt;)
+dnl GNU Program Property Type range
+define(GNU_PROPERTY_X86_UINT32_AND_LO, &lt;0xc0000002&gt;)
+dnl Indirect Branch Tracking
+define(&lt;GNU_PROPERTY_X86_FEATURE_1_IBT&gt;, &lt;0x01&gt;)
+dnl Shadow Stack
+define(&lt;GNU_PROPERTY_X86_FEATURE_1_SHSTK&gt;, &lt;0x02&gt;)
+
+dnl NOTE: GNU Property sections MUST have alignment of 8
+define(&lt;GNU_CET_SECTION&gt;,
+&lt;ifelse(CET_PROTECTION,yes,
+&lt;.pushsection .note.gnu.property,"a"
+ALIGN(8)
+.long 1f - 0f
+.long 4f - 1f
+.long NT_GNU_PROPERTY_TYPE_0()
+0:
+.string "GNU"
+1:
+ALIGN(8)
+.long GNU_PROPERTY_X86_UINT32_AND_LO()
+.long 3f - 2f
+2:
+.long eval(GNU_PROPERTY_X86_FEATURE_1_IBT() | GNU_PROPERTY_X86_FEATURE_1_SHSTK())
+3:
+ALIGN(8)
+4:
+.popsection
+&gt;,&lt;&gt;)&gt;)
diff --git a/x86_64/md5-compress.asm b/x86_64/md5-compress.asm
index 182b8f18..ef1fcb89 100644
--- a/x86_64/md5-compress.asm
+++ b/x86_64/md5-compress.asm
@@ -174,3 +174,4 @@ PROLOGUE(nettle_md5_compress)
 
 	ret
 EPILOGUE(nettle_md5_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/memxor.asm b/x86_64/memxor.asm
index f07f0017..a0ea94b4 100644
--- a/x86_64/memxor.asm
+++ b/x86_64/memxor.asm
@@ -171,3 +171,4 @@ ifdef(&lt;USE_SSE2&gt;, &lt;
 &gt;)	
 
 EPILOGUE(nettle_memxor)
+GNU_CET_SECTION()
diff --git a/x86_64/memxor3.asm b/x86_64/memxor3.asm
index 8ff3e79c..b0c0e35c 100644
--- a/x86_64/memxor3.asm
+++ b/x86_64/memxor3.asm
@@ -261,3 +261,4 @@ ifelse(USE_SSE2, yes, &lt;
 	
 
 EPILOGUE(nettle_memxor3)
+GNU_CET_SECTION()
diff --git a/x86_64/poly1305-internal.asm b/x86_64/poly1305-internal.asm
index 98159ad3..3737450f 100644
--- a/x86_64/poly1305-internal.asm
+++ b/x86_64/poly1305-internal.asm
@@ -184,3 +184,4 @@ define(&lt;T1&gt;, &lt;%rax&gt;)
 	ret
 EPILOGUE(nettle_poly1305_digest)
 
+GNU_CET_SECTION()
diff --git a/x86_64/salsa20-core-internal.asm b/x86_64/salsa20-core-internal.asm
index 4ef07be0..c1690880 100644
--- a/x86_64/salsa20-core-internal.asm
+++ b/x86_64/salsa20-core-internal.asm
@@ -109,3 +109,4 @@ PROLOGUE(_nettle_salsa20_core)
 	W64_EXIT(3, 9)
 	ret
 EPILOGUE(_nettle_salsa20_core)
+GNU_CET_SECTION()
diff --git a/x86_64/salsa20-crypt.asm b/x86_64/salsa20-crypt.asm
index cc1d58ca..e0348956 100644
--- a/x86_64/salsa20-crypt.asm
+++ b/x86_64/salsa20-crypt.asm
@@ -245,3 +245,4 @@ PROLOGUE(nettle_salsa20_crypt)
 	ret
 
 EPILOGUE(nettle_salsa20_crypt)
+GNU_CET_SECTION()
diff --git a/x86_64/serpent-decrypt.asm b/x86_64/serpent-decrypt.asm
index 031c41c8..5f03fa4b 100644
--- a/x86_64/serpent-decrypt.asm
+++ b/x86_64/serpent-decrypt.asm
@@ -714,3 +714,4 @@ PROLOGUE(nettle_serpent_decrypt)
 	W64_EXIT(4, 13)
 	ret
 EPILOGUE(nettle_serpent_decrypt)
+GNU_CET_SECTION()
diff --git a/x86_64/serpent-encrypt.asm b/x86_64/serpent-encrypt.asm
index 99cba00c..6bee5d18 100644
--- a/x86_64/serpent-encrypt.asm
+++ b/x86_64/serpent-encrypt.asm
@@ -749,3 +749,4 @@ C parallell.
 	W64_EXIT(4, 13)
 	ret
 EPILOGUE(nettle_serpent_encrypt)
+GNU_CET_SECTION()
diff --git a/x86_64/sha1-compress.asm b/x86_64/sha1-compress.asm
index dd48de0e..54dfa313 100644
--- a/x86_64/sha1-compress.asm
+++ b/x86_64/sha1-compress.asm
@@ -305,3 +305,4 @@ PROLOGUE(nettle_sha1_compress)
 	W64_EXIT(2, 0)
 	ret
 EPILOGUE(nettle_sha1_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/sha256-compress.asm b/x86_64/sha256-compress.asm
index 5b7d0dcd..8dbccc5b 100644
--- a/x86_64/sha256-compress.asm
+++ b/x86_64/sha256-compress.asm
@@ -208,3 +208,4 @@ PROLOGUE(_nettle_sha256_compress)
 	W64_EXIT(3, 0)
 	ret
 EPILOGUE(_nettle_sha256_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/sha3-permute.asm b/x86_64/sha3-permute.asm
index 805b59af..a4d0cf0b 100644
--- a/x86_64/sha3-permute.asm
+++ b/x86_64/sha3-permute.asm
@@ -107,6 +107,7 @@ define(&lt;ROTL64&gt;, &lt;
 	
 	C sha3_permute(struct sha3_state *ctx)
 	.text
+GNU_CET_SECTION()
 	ALIGN(16)
 PROLOGUE(nettle_sha3_permute)
 	W64_ENTRY(1, 16)
diff --git a/x86_64/sha512-compress.asm b/x86_64/sha512-compress.asm
index 4ff1f32a..37563e93 100644
--- a/x86_64/sha512-compress.asm
+++ b/x86_64/sha512-compress.asm
@@ -208,3 +208,4 @@ PROLOGUE(_nettle_sha512_compress)
 	W64_EXIT(3, 0)
 	ret
 EPILOGUE(_nettle_sha512_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/sha_ni/sha1-compress.asm b/x86_64/sha_ni/sha1-compress.asm
index ab848fdd..3cbca5e2 100644
--- a/x86_64/sha_ni/sha1-compress.asm
+++ b/x86_64/sha_ni/sha1-compress.asm
@@ -146,3 +146,4 @@ PROLOGUE(nettle_sha1_compress)
 	W64_EXIT(2, 10)
 	ret
 EPILOGUE(nettle_sha1_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/sha_ni/sha256-compress.asm b/x86_64/sha_ni/sha256-compress.asm
index f2a4bd32..f9fe3757 100644
--- a/x86_64/sha_ni/sha256-compress.asm
+++ b/x86_64/sha_ni/sha256-compress.asm
@@ -173,3 +173,4 @@ PROLOGUE(_nettle_sha256_compress)
 	W64_EXIT(3, 10)
 	ret
 EPILOGUE(_nettle_sha256_compress)
+GNU_CET_SECTION()
diff --git a/x86_64/umac-nh-n.asm b/x86_64/umac-nh-n.asm
index ecb6396a..195d5886 100644
--- a/x86_64/umac-nh-n.asm
+++ b/x86_64/umac-nh-n.asm
@@ -273,3 +273,4 @@ PROLOGUE(_nettle_umac_nh_n)
 	W64_EXIT(5, 14)
 	ret
 EPILOGUE(_nettle_umac_nh_n)
+GNU_CET_SECTION()
diff --git a/x86_64/umac-nh.asm b/x86_64/umac-nh.asm
index a6938e02..7bfc87ba 100644
--- a/x86_64/umac-nh.asm
+++ b/x86_64/umac-nh.asm
@@ -79,3 +79,4 @@ PROLOGUE(_nettle_umac_nh)
 	W64_EXIT(3, 7)
 	ret
 EPILOGUE(_nettle_umac_nh)
+GNU_CET_SECTION()
-- 
2.20.1


["0004-WIP.patch" (0004-WIP.patch)]

From aab5f9215cb23da631c3c988c7765b1790079f41 Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Sat, 27 Apr 2019 10:44:27 -0400
Subject: [PATCH 4/4] WIP

---
 arm/machine.m4                        | 3 +++
 asm.m4                                | 2 +-
 config.m4.in                          | 2 +-
 configure.ac                          | 7 -------
 sparc32/machine.m4                    | 2 ++
 sparc64/machine.m4                    | 3 +++
 x86/aes-decrypt-internal.asm          | 1 -
 x86/aes-encrypt-internal.asm          | 1 -
 x86/arcfour-crypt.asm                 | 1 -
 x86/camellia-crypt-internal.asm       | 1 -
 x86/machine.m4                        | 4 +++-
 x86/md5-compress.asm                  | 1 -
 x86/sha1-compress.asm                 | 1 -
 x86_64/aes-decrypt-internal.asm       | 1 -
 x86_64/aes-encrypt-internal.asm       | 1 -
 x86_64/aesni/aes-decrypt-internal.asm | 1 -
 x86_64/aesni/aes-encrypt-internal.asm | 1 -
 x86_64/camellia-crypt-internal.asm    | 1 -
 x86_64/chacha-core-internal.asm       | 1 -
 x86_64/fat/cpuid.asm                  | 2 +-
 x86_64/gcm-hash8.asm                  | 1 -
 x86_64/machine.m4                     | 4 +++-
 x86_64/md5-compress.asm               | 1 -
 x86_64/memxor.asm                     | 1 -
 x86_64/memxor3.asm                    | 1 -
 x86_64/poly1305-internal.asm          | 1 -
 x86_64/salsa20-core-internal.asm      | 1 -
 x86_64/salsa20-crypt.asm              | 1 -
 x86_64/serpent-decrypt.asm            | 1 -
 x86_64/serpent-encrypt.asm            | 1 -
 x86_64/sha1-compress.asm              | 1 -
 x86_64/sha256-compress.asm            | 1 -
 x86_64/sha3-permute.asm               | 1 -
 x86_64/sha512-compress.asm            | 1 -
 x86_64/sha_ni/sha1-compress.asm       | 1 -
 x86_64/sha_ni/sha256-compress.asm     | 1 -
 x86_64/umac-nh-n.asm                  | 1 -
 x86_64/umac-nh.asm                    | 1 -
 38 files changed, 17 insertions(+), 41 deletions(-)

diff --git a/arm/machine.m4 b/arm/machine.m4
index f982a66a..6c4801ef 100644
--- a/arm/machine.m4
+++ b/arm/machine.m4
@@ -54,3 +54,6 @@ define(&lt;D1REG&gt;, &lt;ifelse(
 	$1, q14, d29,
 	$1, q15, d31,
 	&lt;NO REGISTER&gt;)&gt;)dnl
+
+define(&lt;GNU_PROPERTY_NOTES&gt;, &lt;&gt;)
+define(&lt;CODEFROM&gt;, &lt;&gt;)
diff --git a/asm.m4 b/asm.m4
index 5a5d4ac2..cc31d97c 100644
--- a/asm.m4
+++ b/asm.m4
@@ -33,7 +33,7 @@ define(&lt;PROLOGUE&gt;,
 &lt;.globl C_NAME($1)
 DECLARE_FUNC(C_NAME($1))
 C_NAME($1):
-CET_ENDBR&gt;)
+CODEFROM()&gt;)
 
 define(&lt;EPILOGUE&gt;,
 &lt;ifelse(ELF_STYLE,yes,
diff --git a/config.m4.in b/config.m4.in
index c3ebad60..90796f26 100644
--- a/config.m4.in
+++ b/config.m4.in
@@ -9,7 +9,7 @@ define(&lt;W64_ABI&gt;, &lt;@W64_ABI@&gt;)dnl
 define(&lt;RODATA&gt;, &lt;@ASM_RODATA@&gt;)dnl
 define(&lt;WORDS_BIGENDIAN&gt;, &lt;@ASM_WORDS_BIGENDIAN@&gt;)dnl
 define(&lt;CET_PROTECTION&gt;, &lt;@ASM_CET_PROTECTION@&gt;)dnl
-define(&lt;CET_ENDBR&gt;, &lt;@ASM_CET_ENDBR@&gt;)dnl
 divert(1)
 @ASM_MARK_NOEXEC_STACK@
+GNU_PROPERTY_NOTES()
 divert
diff --git a/configure.ac b/configure.ac
index 7beb35d9..aba942ce 100644
--- a/configure.ac
+++ b/configure.ac
@@ -706,7 +706,6 @@ ASM_TYPE_FUNCTION='@function'
 ASM_TYPE_PROGBITS='@progbits'
 ASM_MARK_NOEXEC_STACK=''
 ASM_CET_PROTECTION='no'
-ASM_CET_ENDBR=''
 ASM_ALIGN_LOG=''
 ASM_GEN_BUILD_NOTES=''
 
@@ -842,11 +841,6 @@ EOF
 
   if test "x$enable_cet_protection" = xyes ; then
     ASM_CET_PROTECTION=yes
-    if test "$ABI" = 64 ; then
-      ASM_CET_ENDBR=endbr64
-    else
-      ASM_CET_ENDBR=endbr32
-    fi
   fi
 fi
 
@@ -861,7 +855,6 @@ AC_SUBST(W64_ABI)
 AC_SUBST(ASM_WORDS_BIGENDIAN)
 AC_SUBST(ASM_GEN_BUILD_NOTES)
 AC_SUBST(ASM_CET_PROTECTION)
-AC_SUBST(ASM_CET_ENDBR)
 AC_SUBST(EMULATOR)
 
 AC_SUBST(LIBNETTLE_MAJOR)
diff --git a/sparc32/machine.m4 b/sparc32/machine.m4
index e69de29b..59b43f8a 100644
--- a/sparc32/machine.m4
+++ b/sparc32/machine.m4
@@ -0,0 +1,2 @@
+define(&lt;GNU_PROPERTY_NOTES&gt;, &lt;&gt;)
+define(&lt;CODEFROM&gt;, &lt;&gt;)
diff --git a/sparc64/machine.m4 b/sparc64/machine.m4
index 4c1c0e5a..fe5cf5ef 100644
--- a/sparc64/machine.m4
+++ b/sparc64/machine.m4
@@ -2,3 +2,6 @@ define(&lt;BIAS&gt;, 2047) C Magic stack bias for the Sparc64 ABI
 
 .register %g2,#scratch
 .register %g3,#scratch
+
+define(&lt;GNU_PROPERTY_NOTES&gt;, &lt;&gt;)
+define(&lt;CODEFROM&gt;, &lt;&gt;)
diff --git a/x86/aes-decrypt-internal.asm b/x86/aes-decrypt-internal.asm
index 1d16f6db..ff535b6a 100644
--- a/x86/aes-decrypt-internal.asm
+++ b/x86/aes-decrypt-internal.asm
@@ -175,4 +175,3 @@ PROLOGUE(_nettle_aes_decrypt)
 	popl	%ebx
 	ret
 EPILOGUE(_nettle_aes_decrypt)
-GNU_CET_SECTION()
diff --git a/x86/aes-encrypt-internal.asm b/x86/aes-encrypt-internal.asm
index d9579e04..934158f7 100644
--- a/x86/aes-encrypt-internal.asm
+++ b/x86/aes-encrypt-internal.asm
@@ -175,4 +175,3 @@ PROLOGUE(_nettle_aes_encrypt)
 	popl	%ebx
 	ret
 EPILOGUE(_nettle_aes_encrypt)
-GNU_CET_SECTION()
diff --git a/x86/arcfour-crypt.asm b/x86/arcfour-crypt.asm
index 11f592e7..df3fe869 100644
--- a/x86/arcfour-crypt.asm
+++ b/x86/arcfour-crypt.asm
@@ -123,4 +123,3 @@ C .Lloop_done:
 	popl	%ebx
 	ret
 EPILOGUE(nettle_arcfour_crypt)
-GNU_CET_SECTION()
diff --git a/x86/camellia-crypt-internal.asm b/x86/camellia-crypt-internal.asm
index afac1fcc..ce8c57f0 100644
--- a/x86/camellia-crypt-internal.asm
+++ b/x86/camellia-crypt-internal.asm
@@ -223,4 +223,3 @@ PROLOGUE(_nettle_camellia_crypt)
 	popl	%ebx
 	ret
 EPILOGUE(_nettle_camellia_crypt)
-GNU_CET_SECTION()
diff --git a/x86/machine.m4 b/x86/machine.m4
index 1153c757..9341d837 100644
--- a/x86/machine.m4
+++ b/x86/machine.m4
@@ -29,7 +29,7 @@ dnl Shadow Stack
 define(&lt;GNU_PROPERTY_X86_FEATURE_1_SHSTK&gt;, &lt;0x02&gt;)
 
 dnl NOTE: GNU Property sections MUST have alignment of 8
-define(&lt;GNU_CET_SECTION&gt;,
+define(&lt;GNU_PROPERTY_NOTES&gt;,
 &lt;ifelse(CET_PROTECTION,yes,
 &lt;.pushsection .note.gnu.property,"a"
 ALIGN(8)
@@ -49,3 +49,5 @@ ALIGN(8)
 4:
 .popsection
 &gt;,&lt;&gt;)&gt;)
+
+define(&lt;CODEFROM&gt;, &lt;ifelse(CET_PROTECTION,yes,&lt;endbr32&gt;,&lt;&gt;)&gt;)
diff --git a/x86/md5-compress.asm b/x86/md5-compress.asm
index 6293f052..c849c082 100644
--- a/x86/md5-compress.asm
+++ b/x86/md5-compress.asm
@@ -185,4 +185,3 @@ PROLOGUE(nettle_md5_compress)
 	popl	%ebx
 	ret
 EPILOGUE(nettle_md5_compress)
-GNU_CET_SECTION()
diff --git a/x86/sha1-compress.asm b/x86/sha1-compress.asm
index 4e1f121c..03bdcdc9 100644
--- a/x86/sha1-compress.asm
+++ b/x86/sha1-compress.asm
@@ -1541,7 +1541,6 @@ C 	ROUND_F2(SB, SC, SD, SE, SA, 79, K4VALUE)
 	popl	%ebx
 	ret
 EPILOGUE(nettle_sha1_compress)
-GNU_CET_SECTION()
 
 C TODO:
 
diff --git a/x86_64/aes-decrypt-internal.asm b/x86_64/aes-decrypt-internal.asm
index eedfaaf0..43f2f394 100644
--- a/x86_64/aes-decrypt-internal.asm
+++ b/x86_64/aes-decrypt-internal.asm
@@ -150,4 +150,3 @@ PROLOGUE(_nettle_aes_decrypt)
 	W64_EXIT(6, 0)
 	ret
 EPILOGUE(_nettle_aes_decrypt)
-GNU_CET_SECTION()
diff --git a/x86_64/aes-encrypt-internal.asm b/x86_64/aes-encrypt-internal.asm
index 3a5a1e86..dfb498f5 100644
--- a/x86_64/aes-encrypt-internal.asm
+++ b/x86_64/aes-encrypt-internal.asm
@@ -151,4 +151,3 @@ PROLOGUE(_nettle_aes_encrypt)
 	W64_EXIT(6, 0)
 	ret
 EPILOGUE(_nettle_aes_encrypt)
-GNU_CET_SECTION()
diff --git a/x86_64/aesni/aes-decrypt-internal.asm b/x86_64/aesni/aes-decrypt-internal.asm
index 1b1a1a4d..3d6d6e30 100644
--- a/x86_64/aesni/aes-decrypt-internal.asm
+++ b/x86_64/aesni/aes-decrypt-internal.asm
@@ -132,4 +132,3 @@ PROLOGUE(_nettle_aes_decrypt)
 	W64_EXIT(6, 16)
 	ret
 EPILOGUE(_nettle_aes_decrypt)
-GNU_CET_SECTION()
diff --git a/x86_64/aesni/aes-encrypt-internal.asm b/x86_64/aesni/aes-encrypt-internal.asm
index f7338ef6..99caf1f8 100644
--- a/x86_64/aesni/aes-encrypt-internal.asm
+++ b/x86_64/aesni/aes-encrypt-internal.asm
@@ -132,4 +132,3 @@ PROLOGUE(_nettle_aes_encrypt)
 	W64_EXIT(6, 16)
 	ret
 EPILOGUE(_nettle_aes_encrypt)
-GNU_CET_SECTION()
diff --git a/x86_64/camellia-crypt-internal.asm b/x86_64/camellia-crypt-internal.asm
index 71750172..040e030f 100644
--- a/x86_64/camellia-crypt-internal.asm
+++ b/x86_64/camellia-crypt-internal.asm
@@ -200,4 +200,3 @@ PROLOGUE(_nettle_camellia_crypt)
 	W64_EXIT(6, 0)
 	ret
 EPILOGUE(_nettle_camellia_crypt)
-GNU_CET_SECTION()
diff --git a/x86_64/chacha-core-internal.asm b/x86_64/chacha-core-internal.asm
index 3125dee7..9e5dc394 100644
--- a/x86_64/chacha-core-internal.asm
+++ b/x86_64/chacha-core-internal.asm
@@ -126,4 +126,3 @@ PROLOGUE(_nettle_chacha_core)
 	W64_EXIT(3, 6)
 	ret
 EPILOGUE(_nettle_chacha_core)
-GNU_CET_SECTION()
diff --git a/x86_64/fat/cpuid.asm b/x86_64/fat/cpuid.asm
index c4a5b538..f317d56e 100644
--- a/x86_64/fat/cpuid.asm
+++ b/x86_64/fat/cpuid.asm
@@ -56,4 +56,4 @@ PROLOGUE(_nettle_cpuid)
 	W64_EXIT(2)
 	ret
 EPILOGUE(_nettle_cpuid)
-GNU_CET_SECTION()
+
diff --git a/x86_64/gcm-hash8.asm b/x86_64/gcm-hash8.asm
index 54608ae8..bfaa6ef8 100644
--- a/x86_64/gcm-hash8.asm
+++ b/x86_64/gcm-hash8.asm
@@ -199,7 +199,6 @@ ALIGN(16)
 	jnz	.Lread_loop
 	ret
 EPILOGUE(_nettle_gcm_hash8)
-GNU_CET_SECTION()
 
 define(&lt;W&gt;, &lt;0x$2$1&gt;)
 	RODATA
diff --git a/x86_64/machine.m4 b/x86_64/machine.m4
index a64241ce..1c07665d 100644
--- a/x86_64/machine.m4
+++ b/x86_64/machine.m4
@@ -186,7 +186,7 @@ dnl Shadow Stack
 define(&lt;GNU_PROPERTY_X86_FEATURE_1_SHSTK&gt;, &lt;0x02&gt;)
 
 dnl NOTE: GNU Property sections MUST have alignment of 8
-define(&lt;GNU_CET_SECTION&gt;,
+define(&lt;GNU_PROPERTY_NOTES&gt;,
 &lt;ifelse(CET_PROTECTION,yes,
 &lt;.pushsection .note.gnu.property,"a"
 ALIGN(8)
@@ -206,3 +206,5 @@ ALIGN(8)
 4:
 .popsection
 &gt;,&lt;&gt;)&gt;)
+
+define(&lt;CODEFROM&gt;, &lt;ifelse(CET_PROTECTION,yes,&lt;endbr64&gt;,&lt;&gt;)&gt;)
diff --git a/x86_64/md5-compress.asm b/x86_64/md5-compress.asm
index ef1fcb89..182b8f18 100644
--- a/x86_64/md5-compress.asm
+++ b/x86_64/md5-compress.asm
@@ -174,4 +174,3 @@ PROLOGUE(nettle_md5_compress)
 
 	ret
 EPILOGUE(nettle_md5_compress)
-GNU_CET_SECTION()
diff --git a/x86_64/memxor.asm b/x86_64/memxor.asm
index a0ea94b4..f07f0017 100644
--- a/x86_64/memxor.asm
+++ b/x86_64/memxor.asm
@@ -171,4 +171,3 @@ ifdef(&lt;USE_SSE2&gt;, &lt;
 &gt;)	
 
 EPILOGUE(nettle_memxor)
-GNU_CET_SECTION()
diff --git a/x86_64/memxor3.asm b/x86_64/memxor3.asm
index b0c0e35c..8ff3e79c 100644
--- a/x86_64/memxor3.asm
+++ b/x86_64/memxor3.asm
@@ -261,4 +261,3 @@ ifelse(USE_SSE2, yes, &lt;
 	
 
 EPILOGUE(nettle_memxor3)
-GNU_CET_SECTION()
diff --git a/x86_64/poly1305-internal.asm b/x86_64/poly1305-internal.asm
index 3737450f..98159ad3 100644
--- a/x86_64/poly1305-internal.asm
+++ b/x86_64/poly1305-internal.asm
@@ -184,4 +184,3 @@ define(&lt;T1&gt;, &lt;%rax&gt;)
 	ret
 EPILOGUE(nettle_poly1305_digest)
 
-GNU_CET_SECTION()
diff --git a/x86_64/salsa20-core-internal.asm b/x86_64/salsa20-core-internal.asm
index c1690880..4ef07be0 100644
--- a/x86_64/salsa20-core-internal.asm
+++ b/x86_64/salsa20-core-internal.asm
@@ -109,4 +109,3 @@ PROLOGUE(_nettle_salsa20_core)
 	W64_EXIT(3, 9)
 	ret
 EPILOGUE(_nettle_salsa20_core)
-GNU_CET_SECTION()
diff --git a/x86_64/salsa20-crypt.asm b/x86_64/salsa20-crypt.asm
index e0348956..cc1d58ca 100644
--- a/x86_64/salsa20-crypt.asm
+++ b/x86_64/salsa20-crypt.asm
@@ -245,4 +245,3 @@ PROLOGUE(nettle_salsa20_crypt)
 	ret
 
 EPILOGUE(nettle_salsa20_crypt)
-GNU_CET_SECTION()
diff --git a/x86_64/serpent-decrypt.asm b/x86_64/serpent-decrypt.asm
index 5f03fa4b..031c41c8 100644
--- a/x86_64/serpent-decrypt.asm
+++ b/x86_64/serpent-decrypt.asm
@@ -714,4 +714,3 @@ PROLOGUE(nettle_serpent_decrypt)
 	W64_EXIT(4, 13)
 	ret
 EPILOGUE(nettle_serpent_decrypt)
-GNU_CET_SECTION()
diff --git a/x86_64/serpent-encrypt.asm b/x86_64/serpent-encrypt.asm
index 6bee5d18..99cba00c 100644
--- a/x86_64/serpent-encrypt.asm
+++ b/x86_64/serpent-encrypt.asm
@@ -749,4 +749,3 @@ C parallell.
 	W64_EXIT(4, 13)
 	ret
 EPILOGUE(nettle_serpent_encrypt)
-GNU_CET_SECTION()
diff --git a/x86_64/sha1-compress.asm b/x86_64/sha1-compress.asm
index 54dfa313..dd48de0e 100644
--- a/x86_64/sha1-compress.asm
+++ b/x86_64/sha1-compress.asm
@@ -305,4 +305,3 @@ PROLOGUE(nettle_sha1_compress)
 	W64_EXIT(2, 0)
 	ret
 EPILOGUE(nettle_sha1_compress)
-GNU_CET_SECTION()
diff --git a/x86_64/sha256-compress.asm b/x86_64/sha256-compress.asm
index 8dbccc5b..5b7d0dcd 100644
--- a/x86_64/sha256-compress.asm
+++ b/x86_64/sha256-compress.asm
@@ -208,4 +208,3 @@ PROLOGUE(_nettle_sha256_compress)
 	W64_EXIT(3, 0)
 	ret
 EPILOGUE(_nettle_sha256_compress)
-GNU_CET_SECTION()
diff --git a/x86_64/sha3-permute.asm b/x86_64/sha3-permute.asm
index a4d0cf0b..805b59af 100644
--- a/x86_64/sha3-permute.asm
+++ b/x86_64/sha3-permute.asm
@@ -107,7 +107,6 @@ define(&lt;ROTL64&gt;, &lt;
 	
 	C sha3_permute(struct sha3_state *ctx)
 	.text
-GNU_CET_SECTION()
 	ALIGN(16)
 PROLOGUE(nettle_sha3_permute)
 	W64_ENTRY(1, 16)
diff --git a/x86_64/sha512-compress.asm b/x86_64/sha512-compress.asm
index 37563e93..4ff1f32a 100644
--- a/x86_64/sha512-compress.asm
+++ b/x86_64/sha512-compress.asm
@@ -208,4 +208,3 @@ PROLOGUE(_nettle_sha512_compress)
 	W64_EXIT(3, 0)
 	ret
 EPILOGUE(_nettle_sha512_compress)
-GNU_CET_SECTION()
diff --git a/x86_64/sha_ni/sha1-compress.asm b/x86_64/sha_ni/sha1-compress.asm
index 3cbca5e2..ab848fdd 100644
--- a/x86_64/sha_ni/sha1-compress.asm
+++ b/x86_64/sha_ni/sha1-compress.asm
@@ -146,4 +146,3 @@ PROLOGUE(nettle_sha1_compress)
 	W64_EXIT(2, 10)
 	ret
 EPILOGUE(nettle_sha1_compress)
-GNU_CET_SECTION()
diff --git a/x86_64/sha_ni/sha256-compress.asm b/x86_64/sha_ni/sha256-compress.asm
index f9fe3757..f2a4bd32 100644
--- a/x86_64/sha_ni/sha256-compress.asm
+++ b/x86_64/sha_ni/sha256-compress.asm
@@ -173,4 +173,3 @@ PROLOGUE(_nettle_sha256_compress)
 	W64_EXIT(3, 10)
 	ret
 EPILOGUE(_nettle_sha256_compress)
-GNU_CET_SECTION()
diff --git a/x86_64/umac-nh-n.asm b/x86_64/umac-nh-n.asm
index 195d5886..ecb6396a 100644
--- a/x86_64/umac-nh-n.asm
+++ b/x86_64/umac-nh-n.asm
@@ -273,4 +273,3 @@ PROLOGUE(_nettle_umac_nh_n)
 	W64_EXIT(5, 14)
 	ret
 EPILOGUE(_nettle_umac_nh_n)
-GNU_CET_SECTION()
diff --git a/x86_64/umac-nh.asm b/x86_64/umac-nh.asm
index 7bfc87ba..a6938e02 100644
--- a/x86_64/umac-nh.asm
+++ b/x86_64/umac-nh.asm
@@ -79,4 +79,3 @@ PROLOGUE(_nettle_umac_nh)
 	W64_EXIT(3, 7)
 	ret
 EPILOGUE(_nettle_umac_nh)
-GNU_CET_SECTION()
-- 
2.20.1


[Attachment #7 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190412041605</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2019-04-12 04:16:05-0400</timestampReceived><subject>Re: [PATCH] nettle-pbkdf2.c: change the initialization for salt</subject><body>

On Fri, Apr 12, 2019 at 6:04 AM &lt;mingli.yu@windriver.com&gt; wrote:
&gt; 
&gt; From: Mingli Yu &lt;Mingli.Yu@windriver.com&gt;
&gt; 
&gt; use malloc and strncpy altogether to replace
&gt; strdup for salt initialization to fix below
&gt; Segmentation fault:
&gt; # echo -n passwd| nettle-pbkdf2 -i 1 -l 16 salt
&gt; [65534.886509] nettle-pbkdf2[708]: segfault at 1f594260 ip 00007f3332256998 sp \
&gt; 00007fff60d44410 error 4 in libnettle.so.6.5[7f3332244000+1d00] [65534.887525] \
&gt; Code: e8 6d db fe ff 44 01 6d 68 48 83 c4 08 5b 5d 41 5c 41 5d 41 5e 41 5f c3 66 2e \
&gt; 0f 1f 84 00 00 00 00 00 49 89 dc e9 68 ff f Segmentation fault
&gt; 
&gt; Signed-off-by: Mingli Yu &lt;Mingli.Yu@windriver.com&gt;
&gt; ---
&gt; tools/nettle-pbkdf2.c | 5 ++++-
&gt; 1 file changed, 4 insertions(+), 1 deletion(-)
&gt; 
&gt; diff --git a/tools/nettle-pbkdf2.c b/tools/nettle-pbkdf2.c
&gt; index fe6528d..6ecb206 100644
&gt; --- a/tools/nettle-pbkdf2.c
&gt; +++ b/tools/nettle-pbkdf2.c
&gt; @@ -143,7 +143,10 @@ main (int argc, char **argv)
&gt; return EXIT_FAILURE;
&gt; }
&gt; 
&gt; -  salt = strdup (argv[0]);
&gt; +  salt = malloc (strlen(argv[0]) + 1);
&gt; +  if (! salt)
&gt; +     die ("Failed to allocate memory for salt\n");
&gt; +  strncpy(salt, argv[0], sizeof(salt) - 1);


Hi,

Isn't this a bug in libc/strdup and not in nettle? This implementation
is the same as what expected from strdup.

As a workaround I would have added CPPFLAGS="-Dstrdup(x) ...." instead
of introducing workarounds for libc bugs, and send a patch to the
libc, as this may affect more than this single strdup.

Even if such workaround is to be added, it should be added using
autoconf detection and a stub of _strdup(x) and a #define strdup
_strdup if a known issue is detected, again, this should affect al
strdup usages.

I would add the die statement, but not replace the strdup.

  salt = strdup(argv[0]);
+if (!salt)
+    die(...)

However, looking at the code, I believe the allocation of memory is
not required... it can be:

-  salt = strdup (argv[0]);
-  salt_length = strlen(argv[0]);
+  salt = argv[0];
+  salt_length = strlen(salt);
...
- free (salt);

As argv is kept during execution.

Regards,
Alon
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190412070737</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-04-12 07:07:37-0400</timestampReceived><subject>Re: [PATCH] nettle-pbkdf2.c: change the initialization for salt</subject><body>

Alon Bar-Lev &lt;alon.barlev@gmail.com&gt; writes:

&gt; Isn't this a bug in libc/strdup and not in nettle? This implementation
&gt; is the same as what expected from strdup.

I agree. Please file a bug report for the C library you're using. strdup
is a standard posix function (if not part of the C language standard),
and widely used, see
https://codesearch.debian.net/search?q=strdup&amp;perpkg=1

&gt; As a workaround I would have added CPPFLAGS="-Dstrdup(x) ...." instead
&gt; of introducing workarounds for libc bugs,

-D'strdup(x)=strcpy(malloc(strlen(x)+1, x))'

might work (since strcpy returns the pointer to the destination string).

&gt; However, looking at the code, I believe the allocation of memory is
&gt; not required... it can be:

The if (hex_salt) {...} block overwrites the salt storage, for in-place
hex decoding. I don't quite like overwriting the strings passed in via
argv, even if it might be possible. So when I wrote this tool, always
allocating a writable copy, and calling free unconditionally, seemed
nice and easy,

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190313212550</emailId><senderName>"Yuriy M. Kaminskiy"</senderName><senderEmail>yumkam@gmail.com</senderEmail><timestampReceived>2019-03-13 21:25:50-0400</timestampReceived><subject>[RFC] optimized poly1305 and ABI</subject><body>

On 12.03.2019 15:02, Yuriy M. Kaminskiy wrote:
&gt; Then I will probably take a look at poly1305

... and it looks problematic; porting poly1305/armv6 is possible, but there won't
be much improvement over generic C code:

$ poly1305-opt/bin/poly1305-util bench
8192 byte(s):
          neon, 15114.40 ns per call,   1.8 ns/byte
         armv6, 31944.33 ns per call,   3.9 ns/byte
    generic/32, 39088.50 ns per call,   4.8 ns/byte

neon (and other simd implementations) is much faster, but requires larger state; current nettle's
struct poly1305_ctx is 56 bytes, optimized versions requires up to 192 bytes.

And it is embedded in struct chacha_poly1305_ctx and poly1305_aes_ctx, which looks like
part of public (and used) low-level ABI.

(nettle-meta.h interface would be safe wrt struct size changes, but so far everything I've looked
at - including gnutls - was not using it :-()
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190316122356</emailId><senderName>"Yuriy M. Kaminskiy"</senderName><senderEmail>yumkam@gmail.com</senderEmail><timestampReceived>2019-03-16 12:23:56-0400</timestampReceived><subject>[WIP] aes arm asm from libgcrypt</subject><body>

On raspberry pi 3b+ (cortex-a53 @ 1.4GHz):
Before:
 aes128         |  nanosecs/byte   mebibytes/sec   cycles/byte
        ECB enc |     39.58 ns/B     24.10 MiB/s         - c/B
        ECB dec |     39.57 ns/B     24.10 MiB/s         - c/B
After:
        ECB enc |     15.24 ns/B     62.57 MiB/s         - c/B
        ECB dec |     15.68 ns/B     60.80 MiB/s         - c/B

Passes nettle regression test (only little-endian though)

Does not use pre-rotated tables (as in AES_SMALL), so reduces d-cache
footprint from 4.25K to 1K (enc)/1.25K (dec);
completely unrolled, so increases i-cache footprint
from 948b to 4416b (enc)/4032b (dec)

As it completely replaces current implementation, I just attached new
files (will post final version as a patch).

P.S. Yes, I tried convert macros to m4: complete failure (no named
parameters, problems with more than 9 arguments, weird expansion rules);
so I fallen back to good ol' gas. Sorry.

P.P.S. with this change, gcm/neon and (to-be-publushed) chacha_blocks/neon,
gnutls-cli --benchmark-ciphers:
Before:
Checking cipher-MAC combinations, payload size: 16384
             AES-128-GCM 13.56 MB/sec
       CHACHA20-POLY1305 68.26 MB/sec
        AES-128-CBC-SHA1 16.72 MB/sec
        AES-128-CBC-SHA256 15.07 MB/sec
After:
             AES-128-GCM 35.32 MB/sec
       CHACHA20-POLY1305 94.94 MB/sec
        AES-128-CBC-SHA1 27.53 MB/sec
        AES-128-CBC-SHA256 23.30 MB/sec

["aes-decrypt-internal.asm" (text/plain)]

C arm/v6/aes-decrypt-internal.asm

ifelse(&lt;
rijndael-arm.S  -  ARM assembly implementation of AES cipher

Copyright (C) 2013 Jussi Kivilinna jussi.kivilinna@iki.fi

This file is part of Libgcrypt.

Libgcrypt is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of
the License, or (at your option) any later version.

Libgcrypt is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this program; if not, see http://www.gnu.org/licenses/.
&gt;)

.text
	.file "aes-decrypt-internal.asm"
	.arch armv6
	.syntax unified
	.arm

define(&lt;KEYSCHEDULE_REVERSED&gt;,&lt;yes&gt;)
define(&lt;IF_KEYSCHEDULE_REVERSED&gt;,&lt;ifelse(
KEYSCHEDULE_REVERSED,yes,&lt;$1&gt;,
KEYSCHEDULE_REVERSED,no,&lt;$2&gt;)&gt;)

C register macros
define(&lt;PARAM_ROUNDS&gt;, &lt;r0&gt;)
define(&lt;PARAM_LENGTH&gt;, &lt;r3&gt;)

define(&lt;FRAME_ROUNDS&gt;,&lt;[sp, #0]&gt;)
define(&lt;FRAME_LENGTH&gt;,&lt;[sp, #4]&gt;)
define(&lt;FRAME_DST&gt;,&lt;[sp, #(48+0)]&gt;)
define(&lt;FRAME_SRC&gt;,&lt;[sp, #(48+4)]&gt;)

define(&lt;CTX&gt;, &lt;%r1&gt;)
define(&lt;RTAB&gt;, &lt;%r2&gt;)
define(&lt;RMASK&gt;, &lt;%ip&gt;)

define(&lt;RA&gt;, &lt;%r4&gt;)
define(&lt;RB&gt;, &lt;%r5&gt;)
define(&lt;RC&gt;, &lt;%r6&gt;)
define(&lt;RD&gt;, &lt;%r7&gt;)

define(&lt;RNA&gt;, &lt;%r8&gt;)
define(&lt;RNB&gt;, &lt;%r9&gt;)
define(&lt;RNC&gt;, &lt;%r10&gt;)
define(&lt;RND&gt;, &lt;%r11&gt;)

define(&lt;RT0&gt;, &lt;%r0&gt;)
define(&lt;RT1&gt;, &lt;%r3&gt;)
define(&lt;RT2&gt;, &lt;%lr&gt;)

C helper macros
.macro ldr_unaligned_le rout rsrc offs rtmp
	ldrb \rout, [\rsrc, #((\offs) + 0)]
	ldrb \rtmp, [\rsrc, #((\offs) + 1)]
	orr \rout, \rout, \rtmp, lsl #8
	ldrb \rtmp, [\rsrc, #((\offs) + 2)]
	orr \rout, \rout, \rtmp, lsl #16
	ldrb \rtmp, [\rsrc, #((\offs) + 3)]
	orr \rout, \rout, \rtmp, lsl #24
.endm

.macro str_unaligned_le rin rdst offs rtmp0 rtmp1
	mov \rtmp0, \rin, lsr #8
	strb \rin, [\rdst, #((\offs) + 0)]
	mov \rtmp1, \rin, lsr #16
	strb \rtmp0, [\rdst, #((\offs) + 1)]
	mov \rtmp0, \rin, lsr #24
	strb \rtmp1, [\rdst, #((\offs) + 2)]
	strb \rtmp0, [\rdst, #((\offs) + 3)]
.endm

C ***********************************************************************
C ARM assembly implementation of the AES cipher
C ***********************************************************************

.macro preload_first_key round ra
IF_KEYSCHEDULE_REVERSED(&lt;
	ldr \ra, [CTX], #+4
&gt;,&lt;
	ldr \ra, [CTX, #(((\round) * 16) + 0 * 4)]
&gt;)
.endm
.macro dummy round ra
.endm
.macro addroundkey ra rb rc rd rna rnb rnc rnd preload_key
IF_KEYSCHEDULE_REVERSED(&lt;
	ldm CTX!, {\rna, \rnb, \rnc, \rnd}
&gt;,&lt;
	ldm CTX, {\rna, \rnb, \rnc, \rnd}
&gt;)
	eor \ra, \rna
	eor \rb, \rnb
	eor \rc, \rnc
	\preload_key 1, \rna
	eor \rd, \rnd
.endm

.macro addroundkey_dec round ra rb rc rd rna rnb rnc rnd
IF_KEYSCHEDULE_REVERSED(&lt;
	addroundkey \ra,\rb,\rc,\rd,\rna,\rnb,\rnc,\rnd,preload_first_key
&gt;,&lt;
	ldr \rna, [CTX, #(((\round) * 16) + 0 * 4)]
	ldr \rnb, [CTX, #(((\round) * 16) + 1 * 4)]
	eor \ra, \rna
	ldr \rnc, [CTX, #(((\round) * 16) + 2 * 4)]
	eor \rb, \rnb
	ldr \rnd, [CTX, #(((\round) * 16) + 3 * 4)]
	eor \rc, \rnc
	preload_first_key (\round) - 1, \rna
	eor \rd, \rnd
&gt;)
.endm

.macro do_decround next_r ra rb rc rd rna rnb rnc rnd preload_key
IF_KEYSCHEDULE_REVERSED(&lt;
	ldr \rnb, [CTX], #+4
&gt;,&lt;
	ldr \rnb, [CTX, #(((\next_r) * 16) + 1 * 4)]
&gt;)

	and RT0, RMASK, \ra, lsl#2
IF_KEYSCHEDULE_REVERSED(&lt;
	ldr \rnc, [CTX], #+4
&gt;,&lt;
	ldr \rnc, [CTX, #(((\next_r) * 16) + 2 * 4)]
&gt;)
	and RT1, RMASK, \ra, lsr#(8 - 2)
IF_KEYSCHEDULE_REVERSED(&lt;
	ldr \rnd, [CTX], #+4
&gt;,&lt;
	ldr \rnd, [CTX, #(((\next_r) * 16) + 3 * 4)]
&gt;)
	and RT2, RMASK, \ra, lsr#(16 - 2)
	ldr RT0, [RTAB, RT0]
	and \ra,  RMASK, \ra, lsr#(24 - 2)

	ldr RT1, [RTAB, RT1]
	eor \rna, \rna, RT0
	ldr RT2, [RTAB, RT2]
	and RT0, RMASK, \rb, lsl#2
	ldr \ra,  [RTAB, \ra]

	eor \rnb, \rnb, RT1, ror #24
	and RT1, RMASK, \rb, lsr#(8 - 2)
	eor \rnc, \rnc, RT2, ror #16
	and RT2, RMASK, \rb, lsr#(16 - 2)
	eor \rnd, \rnd, \ra, ror #8
	ldr RT0, [RTAB, RT0]
	and \rb,  RMASK, \rb, lsr#(24 - 2)

	ldr RT1, [RTAB, RT1]
	eor \rnb, \rnb, RT0
	ldr RT2, [RTAB, RT2]
	and RT0, RMASK, \rc, lsl#2
	ldr \rb,  [RTAB, \rb]

	eor \rnc, \rnc, RT1, ror #24
	and RT1, RMASK, \rc, lsr#(8 - 2)
	eor \rnd, \rnd, RT2, ror #16
	and RT2, RMASK, \rc, lsr#(16 - 2)
	eor \rna, \rna, \rb, ror #8
	ldr RT0, [RTAB, RT0]
	and \rc,  RMASK, \rc, lsr#(24 - 2)

	ldr RT1, [RTAB, RT1]
	eor \rnc, \rnc, RT0
	ldr RT2, [RTAB, RT2]
	and RT0, RMASK, \rd, lsl#2
	ldr \rc,  [RTAB, \rc]

	eor \rnd, \rnd, RT1, ror #24
	and RT1, RMASK, \rd, lsr#(8 - 2)
	eor \rna, \rna, RT2, ror #16
	and RT2, RMASK, \rd, lsr#(16 - 2)
	eor \rnb, \rnb, \rc, ror #8
	ldr RT0, [RTAB, RT0]
	and \rd,  RMASK, \rd, lsr#(24 - 2)

	ldr RT1, [RTAB, RT1]
	eor \rnd, \rnd, RT0
	ldr RT2, [RTAB, RT2]
	eor \rna, \rna, RT1, ror #24
	ldr \rd,  [RTAB, \rd]

	eor \rnb, \rnb, RT2, ror #16
	\preload_key (\next_r) - 1, \ra
	eor \rnc, \rnc, \rd, ror #8
.endm

.macro do_lastdecround ra rb rc rd rna rnb rnc rnd
	and RT0, RMASK, \ra
	and RT1, RMASK, \ra, lsr#8
	and RT2, RMASK, \ra, lsr#16
	ldrb \rna, [RTAB, RT0]
	mov \ra,  \ra, lsr#24
	ldrb \rnb, [RTAB, RT1]
	and RT0, RMASK, \rb
	ldrb \rnc, [RTAB, RT2]
	mov \rnb, \rnb, ror #24
	ldrb \rnd, [RTAB, \ra]
	and RT1, RMASK, \rb, lsr#8
	mov \rnc, \rnc, ror #16
	and RT2, RMASK, \rb, lsr#16
	mov \rnd, \rnd, ror #8
	ldrb RT0, [RTAB, RT0]
	mov \rb,  \rb, lsr#24
	ldrb RT1, [RTAB, RT1]

	orr \rnb, \rnb, RT0
	ldrb RT2, [RTAB, RT2]
	and RT0, RMASK, \rc
	ldrb \rb,  [RTAB, \rb]
	orr \rnc, \rnc, RT1, ror #24
	and RT1, RMASK, \rc, lsr#8
	orr \rnd, \rnd, RT2, ror #16
	and RT2, RMASK, \rc, lsr#16
	orr \rna, \rna, \rb, ror #8
	ldrb RT0, [RTAB, RT0]
	mov \rc,  \rc, lsr#24
	ldrb RT1, [RTAB, RT1]

	orr \rnc, \rnc, RT0
	ldrb RT2, [RTAB, RT2]
	and RT0, RMASK, \rd
	ldrb \rc,  [RTAB, \rc]
	orr \rnd, \rnd, RT1, ror #24
	and RT1, RMASK, \rd, lsr#8
	orr \rna, \rna, RT2, ror #16
	ldrb RT0, [RTAB, RT0]
	and RT2, RMASK, \rd, lsr#16
	ldrb RT1, [RTAB, RT1]
	orr \rnb, \rnb, \rc, ror #8
	ldrb RT2, [RTAB, RT2]
	mov \rd,  \rd, lsr#24
	ldrb \rd,  [RTAB, \rd]

	orr \rnd, \rnd, RT0
	orr \rna, \rna, RT1, ror #24
	orr \rnb, \rnb, RT2, ror #16
	orr \rnc, \rnc, \rd, ror #8
.endm

.macro firstdecround round ra rb rc rd rna rnb rnc rnd
	addroundkey_dec ((\round) + 1), \ra, \rb, \rc, \rd, \rna, \rnb, \rnc, \rnd
	do_decround \round, \ra, \rb, \rc, \rd, \rna, \rnb, \rnc, \rnd, preload_first_key
.endm

.macro decround round ra rb rc rd rna rnb rnc rnd preload_key
	do_decround \round, \ra, \rb, \rc, \rd, \rna, \rnb, \rnc, \rnd, \preload_key
.endm

.macro set_last_round_rmask _ __
	mov RMASK, #0xff
.endm

.macro lastdecround round ra rb rc rd rna rnb rnc rnd
	sub RTAB, #AES_TABLE0
	do_lastdecround \ra, \rb, \rc, \rd, \rna, \rnb, \rnc, \rnd
	addroundkey \rna, \rnb, \rnc, \rnd, \ra, \rb, \rc, \rd, dummy
	add RTAB, #AES_TABLE0
.endm

	C _aes_decrypt(unsigned rounds, const uint32_t *keys,
	C	       const struct aes_table *T,
	C	       size_t length, uint8_t *dst,
	C	       uint8_t *src)
	C r0 rounds
	C r1 ctx
	C r2 table
	C r3 length
	C [sp, #0] dst
	C [sp, #4] src

PROLOGUE(_nettle_aes_decrypt)
	.cfi_startproc
	teq	PARAM_LENGTH, #0
	bxeq	lr

	push {r0,r3,%r4-%r11, %ip, %lr}
	.cfi_adjust_cfa_offset 48
	.cfi_rel_offset r0, 0	C PARAM_LENGTH
	.cfi_rel_offset r3, 4	C PARAM_ROUNDS
	.cfi_rel_offset r4, 8
	.cfi_rel_offset r5, 12
	.cfi_rel_offset r6, 16
	.cfi_rel_offset r7, 20
	.cfi_rel_offset r8, 24
	.cfi_rel_offset r9, 28
	.cfi_rel_offset r10, 32
	.cfi_rel_offset r11, 36
	.cfi_rel_offset ip, 40
	.cfi_rel_offset lr, 44
	add	RTAB, RTAB, #AES_TABLE0
	C read input block
.Lblock_loop:
	ldr	RT0, FRAME_SRC

ifelse(V6,V6,&lt;
	ldr	RA, [RT0]
	ldr	RB, [RT0, #4]
	ldr	RC, [RT0, #8]
	ldr	RD, [RT0, #12]
  IF_BE(&lt;
	rev	RA, RA
	rev	RB, RB
	rev	RC, RC
	rev	RD, RD
  &gt;)
&gt;,&lt;
  IF_LE(&lt;
	C test if src is unaligned
	tst	RT0, #3
	beq	1f
  &gt;)

	C unaligned load
	ldr_unaligned_le RA, RT0, 0, RNA
	ldr_unaligned_le RB, RT0, 4, RNB
	ldr_unaligned_le RC, RT0, 8, RNA
	ldr_unaligned_le RD, RT0, 12, RNB
  IF_LE(&lt;
	b	2f
.ltorg
1:
	C aligned load
	ldm	RT0, {RA, RB, RC, RD}
2:
  &gt;)
&gt;)
	add	RT0, RT0, #16
	mov	RMASK, #0xff
	str	RT0, FRAME_SRC
	ldr	RT1, FRAME_ROUNDS
	mov	RMASK, RMASK, lsl#2;	C byte mask

	cmp	RT1, #12
	bge	.Ldec_256

	firstdecround 9, RA, RB, RC, RD, RNA, RNB, RNC, RND
.Ldec_tail:
	decround 8, RNA, RNB, RNC, RND, RA, RB, RC, RD, preload_first_key
	decround 7, RA, RB, RC, RD, RNA, RNB, RNC, RND, preload_first_key
	decround 6, RNA, RNB, RNC, RND, RA, RB, RC, RD, preload_first_key
	decround 5, RA, RB, RC, RD, RNA, RNB, RNC, RND, preload_first_key
	decround 4, RNA, RNB, RNC, RND, RA, RB, RC, RD, preload_first_key
	decround 3, RA, RB, RC, RD, RNA, RNB, RNC, RND, preload_first_key
	decround 2, RNA, RNB, RNC, RND, RA, RB, RC, RD, preload_first_key
	decround 1, RA, RB, RC, RD, RNA, RNB, RNC, RND, set_last_round_rmask
	lastdecround 0, RNA, RNB, RNC, RND, RA, RB, RC, RD

IF_KEYSCHEDULE_REVERSED(&lt;
	ldr	RT1, FRAME_ROUNDS
&gt;)
	ldr	RT0, FRAME_DST
IF_KEYSCHEDULE_REVERSED(&lt;
	add	RT1, 1
&gt;)
	ldr	RT2, FRAME_LENGTH
IF_KEYSCHEDULE_REVERSED(&lt;
	sub	CTX, CTX, RT1, lsl#4
&gt;)

	C store output block

ifelse(V6,V6,&lt;
  IF_BE(&lt;
	rev	RA, RA
	rev	RB, RB
	rev	RC, RC
	rev	RD, RD
  &gt;)
	str RA, [RT0]
	str RB, [RT0, #4]
	str RC, [RT0, #8]
	str RD, [RT0, #12]
&gt;,&lt;
  IF_LE(&lt;
	C test if dst is unaligned
	tst	RT0, #3
	beq	1f
  &gt;)

	C unaligned store
	str_unaligned_le RA, RT0, 0, RNA, RNB
	str_unaligned_le RB, RT0, 4, RNA, RNB
	str_unaligned_le RC, RT0, 8, RNA, RNB
	str_unaligned_le RD, RT0, 12, RNA, RNB
  IF_LE(&lt;
	b	2f
.ltorg
1:
	C aligned store
	C write output block
	stm	RT0, {RA, RB, RC, RD}
2:
  &gt;)
&gt;)
	add	RT0, RT0, #16
	subs	RT2, RT2, #16
	str	RT0, FRAME_DST
	str	RT2, FRAME_LENGTH
	bhi	.Lblock_loop
	.cfi_remember_state
	pop {%r0,%r3, %r4-%r11,%ip,%pc}
	.cfi_restore_state

.ltorg
.Ldec_256:
	beq .Ldec_192

	firstdecround 13, RA, RB, RC, RD, RNA, RNB, RNC, RND
	decround 12, RNA, RNB, RNC, RND, RA, RB, RC, RD, preload_first_key
	decround 11, RA, RB, RC, RD, RNA, RNB, RNC, RND, preload_first_key
	decround 10, RNA, RNB, RNC, RND, RA, RB, RC, RD, preload_first_key
	decround 9, RA, RB, RC, RD, RNA, RNB, RNC, RND, preload_first_key

	b .Ldec_tail

.ltorg
.Ldec_192:
	firstdecround 11, RA, RB, RC, RD, RNA, RNB, RNC, RND
	decround 10, RNA, RNB, RNC, RND, RA, RB, RC, RD, preload_first_key
	decround 9, RA, RB, RC, RD, RNA, RNB, RNC, RND, preload_first_key

	b .Ldec_tail
	.cfi_endproc
EPILOGUE(_nettle_aes_decrypt)

["aes-encrypt-internal.asm" (text/plain)]

C arm/v6/aes-encrypt-internal.asm

ifelse(&lt;
rijndael-arm.S  -  ARM assembly implementation of AES cipher

Copyright (C) 2013 Jussi Kivilinna &lt;jussi.kivilinna@iki.fi&gt;

This file is part of Libgcrypt.

Libgcrypt is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of
the License, or (at your option) any later version.

Libgcrypt is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.
&gt;)

.text
.arch armv6
.syntax unified
.arm

C register macros
define(&lt;PARAM_ROUNDS&gt;, &lt;r0&gt;)
define(&lt;PARAM_LENGTH&gt;, &lt;r3&gt;)

define(&lt;FRAME_ROUNDS&gt;,&lt;[sp, #0]&gt;)
define(&lt;FRAME_LENGTH&gt;,&lt;[sp, #4]&gt;)
define(&lt;FRAME_DST&gt;,&lt;[sp, #(48+0)]&gt;)
define(&lt;FRAME_SRC&gt;,&lt;[sp, #(48+4)]&gt;)

define(&lt;CTX&gt;, &lt;%r1&gt;)
define(&lt;RTAB&gt;, &lt;%r2&gt;)
define(&lt;RMASK&gt;, &lt;%ip&gt;)

define(&lt;RA&gt;, &lt;%r4&gt;)
define(&lt;RB&gt;, &lt;%r5&gt;)
define(&lt;RC&gt;, &lt;%r6&gt;)
define(&lt;RD&gt;, &lt;%r7&gt;)

define(&lt;RNA&gt;, &lt;%r8&gt;)
define(&lt;RNB&gt;, &lt;%r9&gt;)
define(&lt;RNC&gt;, &lt;%r10&gt;)
define(&lt;RND&gt;, &lt;%r11&gt;)

define(&lt;RT0&gt;, &lt;%r0&gt;)
define(&lt;RT1&gt;, &lt;%r3&gt;)
define(&lt;RT2&gt;, &lt;%lr&gt;)

C helper macros
.macro ldr_unaligned_le rout rsrc offs rtmp
	ldrb \rout, [\rsrc, #((\offs) + 0)]
	ldrb \rtmp, [\rsrc, #((\offs) + 1)]
	orr \rout, \rout, \rtmp, lsl #8
	ldrb \rtmp, [\rsrc, #((\offs) + 2)]
	orr \rout, \rout, \rtmp, lsl #16
	ldrb \rtmp, [\rsrc, #((\offs) + 3)]
	orr \rout, \rout, \rtmp, lsl #24
.endm

.macro str_unaligned_le rin rdst offs rtmp0 rtmp1
	mov \rtmp0, \rin, lsr #8
	strb \rin, [\rdst, #((\offs) + 0)]
	mov \rtmp1, \rin, lsr #16
	strb \rtmp0, [\rdst, #((\offs) + 1)]
	mov \rtmp0, \rin, lsr #24
	strb \rtmp1, [\rdst, #((\offs) + 2)]
	strb \rtmp0, [\rdst, #((\offs) + 3)]
.endm

C ***********************************************************************
C ARM assembly implementation of the AES cipher
C ***********************************************************************

.macro preload_first_key round ra
	ldr \ra, [CTX, #(((\round) * 16) + 0 * 4)]
.endm
.macro dummy round ra
.endm
.macro addroundkey ra rb rc rd rna rnb rnc rnd preload_key
	ldm CTX, {\rna, \rnb, \rnc, \rnd}
	eor \ra, \rna
	eor \rb, \rnb
	eor \rc, \rnc
	\preload_key 1, \rna
	eor \rd, \rnd
.endm

.macro do_encround next_r ra rb rc rd rna rnb rnc rnd preload_key
	ldr \rnb, [CTX, #(((\next_r) * 16) + 1 * 4)]

	and RT0, RMASK, \ra, lsl#2
	ldr \rnc, [CTX, #(((\next_r) * 16) + 2 * 4)]
	and RT1, RMASK, \ra, lsr#(8 - 2)
	ldr \rnd, [CTX, #(((\next_r) * 16) + 3 * 4)]
	and RT2, RMASK, \ra, lsr#(16 - 2)
	ldr RT0, [RTAB, RT0]
	and \ra,  RMASK, \ra, lsr#(24 - 2)

	ldr RT1, [RTAB, RT1]
	eor \rna, \rna, RT0
	ldr RT2, [RTAB, RT2]
	and RT0, RMASK, \rd, lsl#2
	ldr \ra,  [RTAB, \ra]

	eor \rnd, \rnd, RT1, ror #24
	and RT1, RMASK, \rd, lsr#(8 - 2)
	eor \rnc, \rnc, RT2, ror #16
	and RT2, RMASK, \rd, lsr#(16 - 2)
	eor \rnb, \rnb, \ra, ror #8
	ldr RT0, [RTAB, RT0]
	and \rd,  RMASK, \rd, lsr#(24 - 2)

	ldr RT1, [RTAB, RT1]
	eor \rnd, \rnd, RT0
	ldr RT2, [RTAB, RT2]
	and RT0, RMASK, \rc, lsl#2
	ldr \rd,  [RTAB, \rd]

	eor \rnc, \rnc, RT1, ror #24
	and RT1, RMASK, \rc, lsr#(8 - 2)
	eor \rnb, \rnb, RT2, ror #16
	and RT2, RMASK, \rc, lsr#(16 - 2)
	eor \rna, \rna, \rd, ror #8
	ldr RT0, [RTAB, RT0]
	and \rc,  RMASK, \rc, lsr#(24 - 2)

	ldr RT1, [RTAB, RT1]
	eor \rnc, \rnc, RT0
	ldr RT2, [RTAB, RT2]
	and RT0, RMASK, \rb, lsl#2
	ldr \rc,  [RTAB, \rc]

	eor \rnb, \rnb, RT1, ror #24
	and RT1, RMASK, \rb, lsr#(8 - 2)
	eor \rna, \rna, RT2, ror #16
	and RT2, RMASK, \rb, lsr#(16 - 2)
	eor \rnd, \rnd, \rc, ror #8
	ldr RT0, [RTAB, RT0]
	and \rb,  RMASK, \rb, lsr#(24 - 2)

	ldr RT1, [RTAB, RT1]
	eor \rnb, \rnb, RT0
	ldr RT2, [RTAB, RT2]
	eor \rna, \rna, RT1, ror #24
	ldr \rb,  [RTAB, \rb]

	eor \rnd, \rnd, RT2, ror #16
	\preload_key (\next_r) + 1, \ra
	eor \rnc, \rnc, \rb, ror #8
.endm

.macro do_lastencround ra rb rc rd rna rnb rnc rnd
	and RT0, RMASK, \ra, lsl#2
	and RT1, RMASK, \ra, lsr#(8 - 2)
	and RT2, RMASK, \ra, lsr#(16 - 2)
	ldrb \rna, [RTAB, RT0]
	and \ra,  RMASK, \ra, lsr#(24 - 2)
	ldrb \rnd, [RTAB, RT1]
	and RT0, RMASK, \rd, lsl#2
	ldrb \rnc, [RTAB, RT2]
	mov \rnd, \rnd, ror #24
	ldrb \rnb, [RTAB, \ra]
	and RT1, RMASK, \rd, lsr#(8 - 2)
	mov \rnc, \rnc, ror #16
	and RT2, RMASK, \rd, lsr#(16 - 2)
	mov \rnb, \rnb, ror #8
	ldrb RT0, [RTAB, RT0]
	and \rd,  RMASK, \rd, lsr#(24 - 2)
	ldrb RT1, [RTAB, RT1]

	orr \rnd, \rnd, RT0
	ldrb RT2, [RTAB, RT2]
	and RT0, RMASK, \rc, lsl#2
	ldrb \rd,  [RTAB, \rd]
	orr \rnc, \rnc, RT1, ror #24
	and RT1, RMASK, \rc, lsr#(8 - 2)
	orr \rnb, \rnb, RT2, ror #16
	and RT2, RMASK, \rc, lsr#(16 - 2)
	orr \rna, \rna, \rd, ror #8
	ldrb RT0, [RTAB, RT0]
	and \rc,  RMASK, \rc, lsr#(24 - 2)
	ldrb RT1, [RTAB, RT1]

	orr \rnc, \rnc, RT0
	ldrb RT2, [RTAB, RT2]
	and RT0, RMASK, \rb, lsl#2
	ldrb \rc,  [RTAB, \rc]
	orr \rnb, \rnb, RT1, ror #24
	and RT1, RMASK, \rb, lsr#(8 - 2)
	orr \rna, \rna, RT2, ror #16
	ldrb RT0, [RTAB, RT0]
	and RT2, RMASK, \rb, lsr#(16 - 2)
	ldrb RT1, [RTAB, RT1]
	orr \rnd, \rnd, \rc, ror #8
	ldrb RT2, [RTAB, RT2]
	and \rb,  RMASK, \rb, lsr#(24 - 2)
	ldrb \rb,  [RTAB, \rb]

	orr \rnb, \rnb, RT0
	orr \rna, \rna, RT1, ror #24
	orr \rnd, \rnd, RT2, ror #16
	orr \rnc, \rnc, \rb, ror #8
.endm

.macro firstencround round ra rb rc rd rna rnb rnc rnd
	addroundkey \ra,\rb,\rc,\rd,\rna,\rnb,\rnc,\rnd,preload_first_key
	do_encround (\round) + 1,\ra,\rb,\rc,\rd,\rna,\rnb,\rnc,\rnd,preload_first_key
.endm

.macro encround round ra rb rc rd rna rnb rnc rnd preload_key
	do_encround (\round) + 1,\ra,\rb,\rc,\rd,\rna,\rnb,\rnc,\rnd,\preload_key
.endm

.macro lastencround round ra rb rc rd rna rnb rnc rnd
	add CTX, #(((\round) + 1) * 16)
	add RTAB, #1
	do_lastencround \ra,\rb,\rc,\rd,\rna,\rnb,\rnc,\rnd
	addroundkey \rna,\rnb,\rnc,\rnd,\ra,\rb,\rc,\rd,dummy
	sub CTX, #(((\round) + 1) * 16)
	sub RTAB, #1
.endm

	C _aes_encrypt(unsigned rounds, const uint32_t *keys,
	C	       const struct aes_table *T,
	C	       size_t length, uint8_t *dst,
	C	       uint8_t *src)
	C r0 rounds
	C r1 ctx
	C r2 table
	C r3 length
	C [sp, #0] dst
	C [sp, #4] src

PROLOGUE(_nettle_aes_encrypt)
	.cfi_startproc
	teq	PARAM_LENGTH, #0
	bxeq	lr

	push {r0,r3,%r4-%r11, %ip, %lr}
	.cfi_adjust_cfa_offset 48
	.cfi_rel_offset r0, 0	C PARAM_LENGTH
	.cfi_rel_offset r3, 4	C PARAM_ROUNDS
	.cfi_rel_offset r4, 8
	.cfi_rel_offset r5, 12
	.cfi_rel_offset r6, 16
	.cfi_rel_offset r7, 20
	.cfi_rel_offset r8, 24
	.cfi_rel_offset r9, 28
	.cfi_rel_offset r10, 32
	.cfi_rel_offset r11, 36
	.cfi_rel_offset ip, 40
	.cfi_rel_offset lr, 44
	add	RTAB, RTAB, #AES_TABLE0
	C read input block
.Lblock_loop:
	ldr	RT0, FRAME_SRC

ifelse(V6,V6,&lt;
  IF_BE(&lt;
	rev	RA, RA
	rev	RB, RB
	rev	RC, RC
	rev	RD, RD
  &gt;)
	str RA, [RT0]
	str RB, [RT0, #4]
	str RC, [RT0, #8]
	str RD, [RT0, #12]
&gt;,&lt;
  IF_LE(&lt;
	C test if src is unaligned
	tst	RT0, #3
	beq	1f
  &gt;)
	C unaligned load
	ldr_unaligned_le RA, RT0, 0, RNA
	ldr_unaligned_le RB, RT0, 4, RNB
	ldr_unaligned_le RC, RT0, 8, RNA
	ldr_unaligned_le RD, RT0, 12, RNB
  IF_LE(&lt;
	b	2f
.ltorg
1:
	C aligned load
	ldm	RT0, {RA, RB, RC, RD}
2:
  &gt;)
&gt;)
	add	RT0, RT0, #16

	mov	RMASK, #0xff
	str	RT0, FRAME_SRC
	mov	RMASK, RMASK, lsl#2;	C byte mask

	firstencround 0, RA, RB, RC, RD, RNA, RNB, RNC, RND
	encround 1, RNA, RNB, RNC, RND, RA, RB, RC, RD, preload_first_key
	encround 2, RA, RB, RC, RD, RNA, RNB, RNC, RND, preload_first_key
	encround 3, RNA, RNB, RNC, RND, RA, RB, RC, RD, preload_first_key
	encround 4, RA, RB, RC, RD, RNA, RNB, RNC, RND, preload_first_key
	encround 5, RNA, RNB, RNC, RND, RA, RB, RC, RD, preload_first_key
	encround 6, RA, RB, RC, RD, RNA, RNB, RNC, RND, preload_first_key
	encround 7, RNA, RNB, RNC, RND, RA, RB, RC, RD, preload_first_key

	ldr	RT0, FRAME_ROUNDS
	cmp	RT0, #12
	bge	.Lenc_not_128

	encround 8, RA, RB, RC, RD, RNA, RNB, RNC, RND, dummy
	lastencround 9, RNA, RNB, RNC, RND, RA, RB, RC, RD

.Lenc_done:
	ldr	RT0, FRAME_DST
	ldr	RT1, FRAME_LENGTH

	C store output block
ifelse(V6,V6,&lt;
  IF_BE(&lt;
	rev	RA, RA
	rev	RB, RB
	rev	RC, RC
	rev	RD, RD
  &gt;)
	str RA, [RT0]
	str RB, [RT0, #4]
	str RC, [RT0, #8]
	str RD, [RT0, #12]
&gt;,&lt;
  IF_LE(&lt;
	C test if dst is unaligned
	tst	RT0, #3
	beq	1f
  &gt;)

	C unaligned store
	str_unaligned_le RA, RT0,  0, RNA, RNB
	str_unaligned_le RB, RT0,  4, RNA, RNB
	str_unaligned_le RC, RT0,  8, RNA, RNB
	str_unaligned_le RD, RT0, 12, RNA, RNB
  IF_LE(&lt;
	b	2f
.ltorg
1:
	C aligned store
	C write output block
	stm	RT0, {RA, RB, RC, RD}
2:
  &gt;)
&gt;)
	add	RT0, RT0, #16
	subs	RT1, RT1, #16
	str	RT0, FRAME_DST
	str	RT1, FRAME_LENGTH
	bhi	.Lblock_loop
	.cfi_remember_state
	pop {%r0,%r3, %r4-%r11,%ip,%pc}
	.cfi_restore_state

.ltorg
.Lenc_not_128:
	beq .Lenc_192

	encround 8, RA, RB, RC, RD, RNA, RNB, RNC, RND, preload_first_key
	encround 9, RNA, RNB, RNC, RND, RA, RB, RC, RD, preload_first_key
	encround 10, RA, RB, RC, RD, RNA, RNB, RNC, RND, preload_first_key
	encround 11, RNA, RNB, RNC, RND, RA, RB, RC, RD, preload_first_key
	encround 12, RA, RB, RC, RD, RNA, RNB, RNC, RND, dummy
	lastencround 13, RNA, RNB, RNC, RND, RA, RB, RC, RD

	b .Lenc_done

.ltorg
.Lenc_192:
	encround 8, RA, RB, RC, RD, RNA, RNB, RNC, RND, preload_first_key
	encround 9, RNA, RNB, RNC, RND, RA, RB, RC, RD, preload_first_key
	encround 10, RA, RB, RC, RD, RNA, RNB, RNC, RND, dummy
	lastencround 11, RNA, RNB, RNC, RND, RA, RB, RC, RD

	b .Lenc_done
	.cfi_endproc
EPILOGUE(_nettle_aes_encrypt)

[Attachment #5 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190315121459</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-03-15 12:14:59-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; The attached patch implements the XTS block cipher mode, as specified
&gt; in IEEE P1619. The interface is split into a generic pair of functions
&gt; for encryption and decryption and additional AES-128/AES-256 variants.

Thanks. Sorry for the late response.

&gt; The function signatures follows the same pattern used by other block-
&gt; cipher modes like ctr, cfb, ccm, etc...

But it looks like one has to pass the complete message to one call?
Other modes support incremental encryption (with the requirement that
all calls but the last must be an integral number of blocks). I.e.,
calling sequence like

xts_aes128_set_key
xts_aes128_set_iv
xts_aes128_encrypt ... // 1 or more times
xts_aes128_set_iv   // Start new message
xts_aes128_encrypt ... // 1 or more times


&gt; +The @code{n} plaintext blocks are transformed into @code{n} ciphertext blocks
&gt; +@code{C_1},@dots{} @code{C_n} as follows.
&gt; +
&gt; +For a plaintext length that is a perfect multiple of the XTS block size:
&gt; +@example
&gt; +T_1 = E_k2(IV) MUL a^0
&gt; +C_1 = E_k1(P_1 XOR T_1) XOR T_1
&gt; +
&gt; +@dots{}
&gt; +
&gt; +T_n = E_k2(IV) MUL a^(n-1)
&gt; +C_n = E_k1(P_n XOR T_n) XOR T_n
&gt; +@end example
&gt; +
&gt; +For any other plaintext lengths:
&gt; +@example
&gt; +T_1 = E_k2(IV) MUL a^0
&gt; +C_1 = E_k1(P_1 XOR T_1) XOR T_1
&gt; +
&gt; +@dots{}
&gt; +
&gt; +T_(n-2) = E_k2(IV) MUL a^(n-3)
&gt; +C_(n-2) = E_k1(P_(n-2) XOR T_(n-2)) XOR T_(n-2)
&gt; +
&gt; +T_(n-1) = E_k2(IV) MUL a^(n-2)
&gt; +CC_(n-1) = E_k1(P_(n-1) XOR T_(n-1)) XOR T_(n-1)
&gt; +
&gt; +T_n = E_k2(IV) MUL a^(n-1)
&gt; +PP = [1..m]Pn | [m+1..128]CC_(n-1)
&gt; +C_(n-1) = E_k1(PP XOR T_n) XOR T_n
&gt; +
&gt; +C_n = [1..m]CC_(n-1)
&gt; +@end example

So the second key, with E_k2, is only ever used to encrypt the IV? If
you add a set_iv function, that could do this encryption and only store
E_k2(IV).

&gt; --- /dev/null
&gt; +++ b/xts.c
&gt; @@ -0,0 +1,219 @@
[...]
&gt; +static void
&gt; +xts_shift(uint8_t *T)
&gt; +{
&gt; +  uint8_t carry;
&gt; +  uint8_t i;
&gt; +
&gt; +  for (i = 0, carry = 0; i &lt; XTS_BLOCK_SIZE; i++)
&gt; +    {
&gt; +      uint8_t msb = T[i] &amp; 0x80;
&gt; +      T[i] = T[i] &lt;&lt; 1;
&gt; +      T[i] |= carry;
&gt; +      carry = msb &gt;&gt; 7;
&gt; +    }
&gt; +  if (carry)
&gt; +    T[0] ^= 0x87;
&gt; +}

I think this is the same as block_mulx, in cmac.c. (Also same byte
order, right?)

Since the block size is fixed to 128 bits, I think it makes sense to use
the nettle_block16 type for all blocks but the application's src and
destination areas. Then we get proper alignment, and can easily use
operations on larger units.

BTW, for side-channel silence, we should change 

  if (carry)
    T[0] ^= 0x87;

to something like

  T[0] ^= 0x87 &amp; - carry;

(and similarly for the cmac version).

&gt; +  fblen = length - (length % XTS_BLOCK_SIZE);
&gt; +  XTSENC(twk_ctx, T, tweak);
&gt; +
&gt; +  /* the zeroth power of alpha is the initial ciphertext value itself, so we
&gt; +   * skip shifting and do it at the end of each block operation instead */
&gt; +  for (i = 0; i &lt; fblen; i += XTS_BLOCK_SIZE)
&gt; +    {

In other places, loops like this are often written as

  for (; length &gt;= BLOCK_SIZE; 
       length -= BLOCK_SIZE, src += BLOCK_SIZE, dst += BLOCK_SIZE) 

Then there's no need for the up-front division length &amp; BLOCK_SIZE.
Doesn't matter much in this case, since the block size is a constant
power of two, but in general, division is quite expensive.

&gt; +      C = &amp;dst[i];
&gt; +      XTSCPY(P, &amp;src[i]);
&gt; +      XTSXOR(P, T);		/* P -&gt; PP */
&gt; +      XTSENC(enc_ctx, C, P);	/* CC */
&gt; +      XTSXOR(C, T);		/* CC -&gt; C */

I think it would be clearer with encf being an explicit argument to the
macros that need it (or maybe do it without the macros, if they expand
to only a single call each).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190315132710</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-03-15 13:27:10-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

On Fri, 2019-03-15 at 13:14 +0100, Niels Möller wrote:
&gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; 
&gt; &gt; The attached patch implements the XTS block cipher mode, as specified
&gt; &gt; in IEEE P1619. The interface is split into a generic pair of functions
&gt; &gt; for encryption and decryption and additional AES-128/AES-256 variants.
&gt; 
&gt; Thanks. Sorry for the late response.
&gt; 
&gt; &gt; The function signatures follows the same pattern used by other block-
&gt; &gt; cipher modes like ctr, cfb, ccm, etc...
&gt; 
&gt; But it looks like one has to pass the complete message to one call?

Yes, due to ciphertext stealing, XTS needs to know what are the last
two blocks, or at the very least needs to withhold the last processed
block in order to be able to change it if a final partial block is
provided. This means inputs and outputs would not be symmetrical and I
felt it would make it somewhat hard to deal with as an API.
In general XTS is used for block storage and the input is always fully
available (and relatively small, either around 512 bytes, or 4k).

&gt; Other modes support incremental encryption (with the requirement that
&gt; all calls but the last must be an integral number of blocks). I.e.,
&gt; calling sequence like
&gt; 
&gt; xts_aes128_set_key
&gt; xts_aes128_set_iv
&gt; xts_aes128_encrypt ... // 1 or more times
&gt; xts_aes128_set_iv   // Start new message
&gt; xts_aes128_encrypt ... // 1 or more times
&gt; 
&gt; 
&gt; &gt; +The @code{n} plaintext blocks are transformed into @code{n} ciphertext blocks
&gt; &gt; +@code{C_1},@dots{} @code{C_n} as follows.
&gt; &gt; +
&gt; &gt; +For a plaintext length that is a perfect multiple of the XTS block size:
&gt; &gt; +@example
&gt; &gt; +T_1 = E_k2(IV) MUL a^0
&gt; &gt; +C_1 = E_k1(P_1 XOR T_1) XOR T_1
&gt; &gt; +
&gt; &gt; +@dots{}
&gt; &gt; +
&gt; &gt; +T_n = E_k2(IV) MUL a^(n-1)
&gt; &gt; +C_n = E_k1(P_n XOR T_n) XOR T_n
&gt; &gt; +@end example
&gt; &gt; +
&gt; &gt; +For any other plaintext lengths:
&gt; &gt; +@example
&gt; &gt; +T_1 = E_k2(IV) MUL a^0
&gt; &gt; +C_1 = E_k1(P_1 XOR T_1) XOR T_1
&gt; &gt; +
&gt; &gt; +@dots{}
&gt; &gt; +
&gt; &gt; +T_(n-2) = E_k2(IV) MUL a^(n-3)
&gt; &gt; +C_(n-2) = E_k1(P_(n-2) XOR T_(n-2)) XOR T_(n-2)
&gt; &gt; +
&gt; &gt; +T_(n-1) = E_k2(IV) MUL a^(n-2)
&gt; &gt; +CC_(n-1) = E_k1(P_(n-1) XOR T_(n-1)) XOR T_(n-1)
&gt; &gt; +
&gt; &gt; +T_n = E_k2(IV) MUL a^(n-1)
&gt; &gt; +PP = [1..m]Pn | [m+1..128]CC_(n-1)
&gt; &gt; +C_(n-1) = E_k1(PP XOR T_n) XOR T_n
&gt; &gt; +
&gt; &gt; +C_n = [1..m]CC_(n-1)
&gt; &gt; +@end example
&gt; 
&gt; So the second key, with E_k2, is only ever used to encrypt the IV? If
&gt; you add a set_iv function, that could do this encryption and only store
&gt; E_k2(IV).

What would be the advantage ? I guess it may make sense if we were to
allow to call the encryption function multiple times, but as explained
above I am not sure this is necessarily desirable.
It may also risk misuse where people set the same IV for all encryption
operations, that would be catastrophic, but probably can be handled by
clearing the stored IV when the encryption is finalized.

&gt; &gt; --- /dev/null
&gt; &gt; +++ b/xts.c
&gt; &gt; @@ -0,0 +1,219 @@
&gt; 
&gt; [...]
&gt; &gt; +static void
&gt; &gt; +xts_shift(uint8_t *T)
&gt; &gt; +{
&gt; &gt; +  uint8_t carry;
&gt; &gt; +  uint8_t i;
&gt; &gt; +
&gt; &gt; +  for (i = 0, carry = 0; i &lt; XTS_BLOCK_SIZE; i++)
&gt; &gt; +    {
&gt; &gt; +      uint8_t msb = T[i] &amp; 0x80;
&gt; &gt; +      T[i] = T[i] &lt;&lt; 1;
&gt; &gt; +      T[i] |= carry;
&gt; &gt; +      carry = msb &gt;&gt; 7;
&gt; &gt; +    }
&gt; &gt; +  if (carry)
&gt; &gt; +    T[0] ^= 0x87;
&gt; &gt; +}
&gt; 
&gt; I think this is the same as block_mulx, in cmac.c. (Also same byte
&gt; order, right?)

Looks the same indeed, should I share it? Just copy it from cmac?
Something else?

&gt; Since the block size is fixed to 128 bits, I think it makes sense to use
&gt; the nettle_block16 type for all blocks but the application's src and
&gt; destination areas. Then we get proper alignment, and can easily use
&gt; operations on larger units.

Ok.

&gt; BTW, for side-channel silence, we should change 
&gt; 
&gt;   if (carry)
&gt;     T[0] ^= 0x87;
&gt; 
&gt; to something like
&gt; 
&gt;   T[0] ^= 0x87 &amp; - carry;
&gt; 
&gt; (and similarly for the cmac version).

I can do it for xts.c, and provide a separate patch for cmac.c too, or
use a common function for both and handle it there.

&gt; &gt; +  fblen = length - (length % XTS_BLOCK_SIZE);
&gt; &gt; +  XTSENC(twk_ctx, T, tweak);
&gt; &gt; +
&gt; &gt; +  /* the zeroth power of alpha is the initial ciphertext value itself, so we
&gt; &gt; +   * skip shifting and do it at the end of each block operation instead */
&gt; &gt; +  for (i = 0; i &lt; fblen; i += XTS_BLOCK_SIZE)
&gt; &gt; +    {
&gt; 
&gt; In other places, loops like this are often written as
&gt; 
&gt;   for (; length &gt;= BLOCK_SIZE; 
&gt;        length -= BLOCK_SIZE, src += BLOCK_SIZE, dst += BLOCK_SIZE) 
&gt; 
&gt; Then there's no need for the up-front division length &amp; BLOCK_SIZE.
&gt; Doesn't matter much in this case, since the block size is a constant
&gt; power of two, but in general, division is quite expensive.

Ok, I can change that.

&gt; &gt; +      C = &amp;dst[i];
&gt; &gt; +      XTSCPY(P, &amp;src[i]);
&gt; &gt; +      XTSXOR(P, T);		/* P -&gt; PP */
&gt; &gt; +      XTSENC(enc_ctx, C, P);	/* CC */
&gt; &gt; +      XTSXOR(C, T);		/* CC -&gt; C */
&gt; 
&gt; I think it would be clearer with encf being an explicit argument to the
&gt; macros that need it (or maybe do it without the macros, if they expand
&gt; to only a single call each).

Ok, will drop the macros, they seemed clearer, but now that I am
rereding the code I found myself looking at their implementation more
often than I thought necessary.

Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190315163033</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-03-15 16:30:33-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt;&gt; But it looks like one has to pass the complete message to one call?
&gt;
&gt; Yes, due to ciphertext stealing, XTS needs to know what are the last
&gt; two blocks, or at the very least needs to withhold the last processed
&gt; block in order to be able to change it if a final partial block is
&gt; provided. This means inputs and outputs would not be symmetrical and I
&gt; felt it would make it somewhat hard to deal with as an API.
&gt; In general XTS is used for block storage and the input is always fully
&gt; available (and relatively small, either around 512 bytes, or 4k).

I see. Can you mention this (and the fact that messages must be at least
one full block) in the manual?

Would it make sense to rename functions to xts_encrypt_message,
xts_decrypt_message, to emphasize that they operate on complete
messages? That would be analogous with the ccm message functions.

&gt;&gt; So the second key, with E_k2, is only ever used to encrypt the IV? If
&gt;&gt; you add a set_iv function, that could do this encryption and only store
&gt;&gt; E_k2(IV).
&gt;
&gt; What would be the advantage ? 

With an api for complete messages only, my suggestion makes little
sense.

&gt; Looks the same indeed, should I share it? Just copy it from cmac?
&gt; Something else?

Would be nice to share it, but since it's so short, duplication is no
big deal.

Also re-reading the cmac version, block_mulx, I think it's unfortunate
to use READ_UINT64 and WRITE_UINT64, since arguments are aligned. It
would be preferable to load 64-bit values and use __builtin_bswap64 when
needed and available (see ctr.c for a similar hack). But that's an
independent improvement.

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190315163513</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-03-15 16:35:13-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

On Fri, 2019-03-15 at 17:30 +0100, Niels Möller wrote:
&gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; 
&gt; &gt; &gt; But it looks like one has to pass the complete message to one call?
&gt; &gt; 
&gt; &gt; Yes, due to ciphertext stealing, XTS needs to know what are the last
&gt; &gt; two blocks, or at the very least needs to withhold the last processed
&gt; &gt; block in order to be able to change it if a final partial block is
&gt; &gt; provided. This means inputs and outputs would not be symmetrical and I
&gt; &gt; felt it would make it somewhat hard to deal with as an API.
&gt; &gt; In general XTS is used for block storage and the input is always fully
&gt; &gt; available (and relatively small, either around 512 bytes, or 4k).
&gt; 
&gt; I see. Can you mention this (and the fact that messages must be at least
&gt; one full block) in the manual?

I will.

&gt; Would it make sense to rename functions to xts_encrypt_message,
&gt; xts_decrypt_message, to emphasize that they operate on complete
&gt; messages? That would be analogous with the ccm message functions.

Good idea.

&gt; &gt; &gt; So the second key, with E_k2, is only ever used to encrypt the IV? If
&gt; &gt; &gt; you add a set_iv function, that could do this encryption and only store
&gt; &gt; &gt; E_k2(IV).
&gt; &gt; 
&gt; &gt; What would be the advantage ? 
&gt; 
&gt; With an api for complete messages only, my suggestion makes little
&gt; sense.
&gt; 
&gt; &gt; Looks the same indeed, should I share it? Just copy it from cmac?
&gt; &gt; Something else?
&gt; 
&gt; Would be nice to share it, but since it's so short, duplication is no
&gt; big deal.
&gt; 
&gt; Also re-reading the cmac version, block_mulx, I think it's unfortunate
&gt; to use READ_UINT64 and WRITE_UINT64, since arguments are aligned. It
&gt; would be preferable to load 64-bit values and use __builtin_bswap64 when
&gt; needed and available (see ctr.c for a similar hack). But that's an
&gt; independent improvement.

I can make a new function and attempt to make these improvements there,
then it can either be shared or copied back to cmac at a later time.

Simo.
 
-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190315203314</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-03-15 20:33:14-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

On Fri, 2019-03-15 at 09:27 -0400, Simo Sorce wrote:
&gt; &gt; I think this is the same as block_mulx, in cmac.c. (Also same byte
&gt; &gt; order, right?)
&gt; 
&gt; Looks the same indeed, should I share it? Just copy it from cmac?
&gt; Something else?

Turns out the algorithm is not equivalent, as the shift is applied to
the array as if it were a big 128bit little endian value, the endianess
of the two is different.

I changed the implementation to a much simpler form that show the
difference:

/* shift one and XOR with 0x87. */
/* src and dest can point to the same buffer for in-place operations */
static void
xts_shift(union nettle_block16 *dst,
          const union nettle_block16 *src)
{
  uint8_t carry = src-&gt;b[15] &gt;&gt; 7;
  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) | (src-&gt;u64[0] &gt;&gt; 63);
  dst-&gt;u64[0] = src-&gt;u64[0] &lt;&lt; 1;
  dst-&gt;b[0] ^= 0x87 &amp; -carry;
}

Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190315211740</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-03-15 21:17:40-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

On Fri, 2019-03-15 at 16:33 -0400, Simo Sorce wrote:
&gt; On Fri, 2019-03-15 at 09:27 -0400, Simo Sorce wrote:
&gt; &gt; &gt; I think this is the same as block_mulx, in cmac.c. (Also same byte
&gt; &gt; &gt; order, right?)
&gt; &gt; 
&gt; &gt; Looks the same indeed, should I share it? Just copy it from cmac?
&gt; &gt; Something else?
&gt; 
&gt; Turns out the algorithm is not equivalent, as the shift is applied to
&gt; the array as if it were a big 128bit little endian value, the endianess
&gt; of the two is different.
&gt; 
&gt; I changed the implementation to a much simpler form that show the
&gt; difference:
&gt; 
&gt; /* shift one and XOR with 0x87. */
&gt; /* src and dest can point to the same buffer for in-place operations */
&gt; static void
&gt; xts_shift(union nettle_block16 *dst,
&gt;           const union nettle_block16 *src)
&gt; {
&gt;   uint8_t carry = src-&gt;b[15] &gt;&gt; 7;
&gt;   dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) | (src-&gt;u64[0] &gt;&gt; 63);
&gt;   dst-&gt;u64[0] = src-&gt;u64[0] &lt;&lt; 1;
&gt;   dst-&gt;b[0] ^= 0x87 &amp; -carry;
&gt; }
&gt; 
&gt; Simo.

Attached find patch with all the changes I understood we agreed on in
the thread.

For easier review I also have a tree with the original patch and
discrete steps in form of separate commits that I rebased and merged
together:
https://gitlab.com/simo5/nettle/tree/xts_exploded

Note the documentation already warns that at least a block of data is
required and less than 16 bytes of input is illegal, so no change has
been applied in that regard.

HTH,
Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


["0001-Add-support-for-XTS-encryption-mode.patch.patch" (0001-Add-support-for-XTS-encryption-mode.patch.patch)]

From 3484f9085fcdfd72df0e54eae7fd0e23fa4c5446 Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Thu, 4 Oct 2018 14:38:50 -0400
Subject: [PATCH] Add support for XTS encryption mode

XEX encryption mode with tweak and ciphertext stealing (XTS) is
standardized in IEEE 1619 and generally used for storage devices.

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 Makefile.in                |   5 +-
 nettle.texinfo             | 147 ++++++++++++++++++++++++++-
 testsuite/.gitignore       |   1 +
 testsuite/.test-rules.make |   3 +
 testsuite/Makefile.in      |   2 +-
 testsuite/xts-test.c       | 173 +++++++++++++++++++++++++++++++
 xts-aes128.c               |  75 ++++++++++++++
 xts-aes256.c               |  75 ++++++++++++++
 xts.c                      | 201 +++++++++++++++++++++++++++++++++++++
 xts.h                      | 117 +++++++++++++++++++++
 10 files changed, 794 insertions(+), 5 deletions(-)
 create mode 100644 testsuite/xts-test.c
 create mode 100644 xts-aes128.c
 create mode 100644 xts-aes256.c
 create mode 100644 xts.c
 create mode 100644 xts.h

diff --git a/Makefile.in b/Makefile.in
index 83250cf3..440de9f7 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -135,7 +135,8 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 umac32.c umac64.c umac96.c umac128.c \
 		 version.c \
 		 write-be32.c write-le32.c write-le64.c \
-		 yarrow256.c yarrow_key_event.c
+		 yarrow256.c yarrow_key_event.c \
+		 xts.c xts-aes128.c xts-aes256.c
 
 hogweed_SOURCES = sexp.c sexp-format.c \
 		  sexp-transport.c sexp-transport-format.c \
@@ -206,7 +207,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  pgp.h pkcs1.h pss.h pss-mgf1.h realloc.h ripemd160.h rsa.h \
 	  salsa20.h sexp.h \
 	  serpent.h sha.h sha1.h sha2.h sha3.h twofish.h \
-	  umac.h yarrow.h poly1305.h
+	  umac.h yarrow.h xts.h poly1305.h
 
 INSTALL_HEADERS = $(HEADERS) version.h @IF_MINI_GMP@ mini-gmp.h
 
diff --git a/nettle.texinfo b/nettle.texinfo
index 9806bdc1..c44302bc 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -2001,7 +2001,8 @@ Book mode, @acronym{ECB}), leaks information.
 
 Besides @acronym{ECB}, Nettle provides several other modes of operation:
 Cipher Block Chaining (@acronym{CBC}), Counter mode (@acronym{CTR}), Cipher
-Feedback (@acronym{CFB} and @acronym{CFB8}) and a couple of @acronym{AEAD}
+Feedback (@acronym{CFB} and @acronym{CFB8}), XEX-based tweaked-codebook mode
+with ciphertext stealing (@acronym{XTS}) and a couple of @acronym{AEAD}
 modes (@pxref{Authenticated encryption}).  @acronym{CBC} is widely used, but
 there are a few subtle issues of information leakage, see, e.g.,
 @uref{http://www.kb.cert.org/vuls/id/958563, @acronym{SSH} @acronym{CBC}
@@ -2016,6 +2017,7 @@ authenticate the message.
 * CBC::                         
 * CTR::                         
 * CFB and CFB8::
+* XTS::
 @end menu
 
 @node CBC, CTR, Cipher modes, Cipher modes
@@ -2187,7 +2189,7 @@ last three arguments define the source and destination area for \
the  operation.
 @end deffn
 
-@node CFB and CFB8, , CTR, Cipher modes
+@node CFB and CFB8, XTS, CTR, Cipher modes
 @comment  node-name,  next,  previous,  up
 @subsection Cipher Feedback mode
 
@@ -2340,6 +2342,147 @@ conventions. The last three arguments define the source and \
destination  area for the operation.
 @end deffn
 
+@node XTS, , CFB and CFB8, Cipher modes
+@comment  node-name,  next,  previous,  up
+@subsection XEX-based tweaked-codebook mode with ciphertext stealing
+
+@cindex XEX-based tweaked-codebook mode with ciphertext stealing
+@cindex XTS Mode
+
+
+XEX-based tweaked-codebook mode with ciphertext stealing (@acronym{XTS}) is
+a block mode like (@acronym{CBC}) but tweaked to be able to encrypt partial
+blocks via a technique called ciphertext stealing, where the last complete
+block of ciphertext is split and part returned as the last block and part
+used as plaintext for the second to last block.
+This mode is principally used to encrypt data at rest where it is not possible
+to store additional metadata or blocks larger than the plain text. The most
+common usage is for disk encryption. Due to the fact that ciphertext expansion
+is not possible, data is not authenticated. This mode should not be used where
+authentication is critical.
+
+The message is divided into @code{n} blocks @code{M_1},@dots{} @code{M_n},
+where @code{M_n} is of size @code{m} which may be smaller than the block size.
+XTS always uses a fixed blocksize of 128 bit (16 bytes) length.
+
+Unlike other modes, the key is double the size of that for the used cipher mode
+(for example 256bit for AES-128 and 512bit for AES-256).
+
+@acronym{XTS} encryption mode operates given:
+@itemize
+@item A multiplication by a primitive element alpha.
+@code{MUL a^j} here represents the multiplication, where @code{j} is the power
+of alpha, and the input value is converted into a 16 bytes array
+@code{a_0[k], k = 0,1,..,15}. The multiplication is calculated as
+@code{a_(j+1)[0] = (2(a_j[0] mod 128)) XOR (135 * floor(a_j[15]/128)}
+@code{a_(j+1)[k] = (2(a_j[k] mod 128)) XOR (floor(a_j[k-1]/128), k = 1,2,..15}
+Note that this operation is practically a 1 bit left shift operation with carry
+propagating from one byte to the next, and if the last bit shift results in a
+carry the decimal value 135 is XORed into the first byte.
+
+@item The encryption key is provided as the @code{Key = K1 | K2}, where @code{|}
+denotes string concatenation.
+@code{E_k1} is the encryption function of the block cipher using @code{K1} as
+the key, and @code{E_k2} is the same encryption function using @code{K2}
+
+@item A 128 bit tweak value is provided as input and is denoted as @code{IV}
+@end itemize
+
+The @code{n} plaintext blocks are transformed into @code{n} ciphertext blocks
+@code{C_1},@dots{} @code{C_n} as follows.
+
+For a plaintext length that is a perfect multiple of the XTS block size:
+@example
+T_1 = E_k2(IV) MUL a^0
+C_1 = E_k1(P_1 XOR T_1) XOR T_1
+
+@dots{}
+
+T_n = E_k2(IV) MUL a^(n-1)
+C_n = E_k1(P_n XOR T_n) XOR T_n
+@end example
+
+For any other plaintext lengths:
+@example
+T_1 = E_k2(IV) MUL a^0
+C_1 = E_k1(P_1 XOR T_1) XOR T_1
+
+@dots{}
+
+T_(n-2) = E_k2(IV) MUL a^(n-3)
+C_(n-2) = E_k1(P_(n-2) XOR T_(n-2)) XOR T_(n-2)
+
+T_(n-1) = E_k2(IV) MUL a^(n-2)
+CC_(n-1) = E_k1(P_(n-1) XOR T_(n-1)) XOR T_(n-1)
+
+T_n = E_k2(IV) MUL a^(n-1)
+PP = [1..m]Pn | [m+1..128]CC_(n-1)
+C_(n-1) = E_k1(PP XOR T_n) XOR T_n
+
+C_n = [1..m]CC_(n-1)
+@end example
+
+@subsubsection General (@acronym{XTS}) interface.
+
+The two general functions to encrypt and decrypt using the @acronym{XTS} block
+cipher mode are the following:
+
+@deftypefun void xts_encrypt_message (const void *@var{enc_ctx}, const void \
*@var{twk_ctx}, nettle_cipher_func *@var{encf}, const uint8_t *@var{tweak}, size_t \
@var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +@deftypefunx void \
xts_decrypt_message (const void *@var{dec_ctx}, const void *@var{twk_ctx}, \
nettle_cipher_func *@var{decf}, nettle_cipher_func *@var{encf}, const uint8_t \
*@var{tweak}, size_t @var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +
+Applies the encryption function @var{encf} or the decryption function
+@var{decf} in @acronym{XTS} mode. At least one block (16 bytes) worth
+of data must be available therefore specifying a length less than 16
+bytes is illegal.
+
+The functions @var{encf} @var{decf} are of type
+
+@code{void f (void *@var{ctx}, size_t @var{length}, uint8_t *@var{dst},
+const uint8_t *@var{src})},
+
+@noindent and the @code{xts_encrypt_message} and @code{xts_decrypt_message}
+functions pass their arguments @var{enc_ctx}, @var{twk_ctx} and @var{dec_ctx}
+to the functions @var{encf}, @var{decf} as @var{ctx}.
+@end deftypefun
+
+@subsubsection @acronym{XTS}-@acronym{AES} interface
+
+The @acronym{AES} @acronym{XTS} functions provide an API for using the
+@acronym{XTS} mode with the @acronym{AES} block ciphers. The parameters
+all have the same meaning as the general interface, except that the
+@var{enc_ctx}, @var{dec_ctx}, @var{twk_ctx}, @var{encf} and @var{decf} are
+replaced with an @acronym{AES} context structure called @var{ctx}, and a
+appropriate set-key function must be called before using any of the encryption
+or decryption functions in this interface.
+
+@deftp {Context struct} {struct xts_aes128_ctx}
+Holds state corresponding to the AES-128 block cipher.
+@end deftp
+
+@deftp {Context struct} {struct xts_aes256_ctx}
+Holds state corresponding to the AES-256 block cipher.
+@end deftp
+
+@deftypefun void xts_aes128_set_encrypt_key (struct xts_aes128_ctx *@var{ctx}, const \
uint8_t *@var{key}) +@deftypefunx void xts_aes256_set_encrypt_key (struct \
xts_aes256_ctx *@var{ctx}, const uint8_t *@var{key}) +@deftypefunx void \
xts_aes128_set_decrypt_key (struct xts_aes128_ctx *@var{ctx}, const uint8_t \
*@var{key}) +@deftypefunx void xts_aes256_set_decrypt_key (struct xts_aes256_ctx \
*@var{ctx}, const uint8_t *@var{key}) +Initializes the encryption or decryption key \
for the AES block cipher. The +lenght of the key must be double the size of the key \
for the corresponding +cipher (256 bits for AES-128 and 512 bits for AES-256). One of
+these functions must be called before any of the other functions.
+@end deftypefun
+
+@deftypefun void xts_aes128_encrypt_message(struct xts_aes128_ctx *@var{ctx}, \
uint8_t *@var{tweak}, size_t @var{length}, uint8_t *@var{dst}, const uint8_t \
*@var{src}) +@deftypefunx void xts_aes256_encrypt_message(struct xts_aes256_ctx \
*@var{ctx}, uint8_t *@var{tweak}, size_t @var{length}, uint8_t *@var{dst}, const \
uint8_t *@var{src}) +@deftypefunx void xts_aes128_decrypt_message(struct \
xts_aes128_ctx *@var{ctx}, uint8_t *@var{tweak}, size_t @var{length}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +@deftypefunx void \
xts_aes256_decrypt_message(struct xts_aes256_ctx *@var{ctx}, uint8_t *@var{tweak}, \
size_t @var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +These are \
identical to @code{xts_encrypt_message} and +@code{xts_decrypt_message}, except that \
@var{enc_ctx}, @var{dec_ctx}, +@var{twk_ctx}, @var{encf} and @var{decf} are replaced \
by the @var{ctx} context +structure.
+@end deftypefun
+
 @node Authenticated encryption, Keyed hash functions, Cipher modes, Reference
 @comment  node-name,  next,  previous,  up
 
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index f98a949a..c3fc5c11 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -95,6 +95,7 @@
 /umac-test
 /version-test
 /yarrow-test
+/xts-test
 
 /test.in
 /test1.out
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index f36a1f7f..6eee6e22 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -166,6 +166,9 @@ buffer-test$(EXEEXT): buffer-test.$(OBJEXT)
 yarrow-test$(EXEEXT): yarrow-test.$(OBJEXT)
 	$(LINK) yarrow-test.$(OBJEXT) $(TEST_OBJS) -o yarrow-test$(EXEEXT)
 
+xts-test$(EXEEXT): xts-test.$(OBJEXT)
+	$(LINK) xts-test.$(OBJEXT) $(TEST_OBJS) -o xts-test$(EXEEXT)
+
 pbkdf2-test$(EXEEXT): pbkdf2-test.$(OBJEXT)
 	$(LINK) pbkdf2-test.$(OBJEXT) $(TEST_OBJS) -o pbkdf2-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index e2982b66..287c4f75 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -32,7 +32,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
 		    meta-aead-test.c meta-armor-test.c \
-		    buffer-test.c yarrow-test.c pbkdf2-test.c
+		    buffer-test.c yarrow-test.c xts-test.c pbkdf2-test.c
 
 TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
 		     rsa2sexp-test.c sexp2rsa-test.c \
diff --git a/testsuite/xts-test.c b/testsuite/xts-test.c
new file mode 100644
index 00000000..b61c1c99
--- /dev/null
+++ b/testsuite/xts-test.c
@@ -0,0 +1,173 @@
+#include "testutils.h"
+#include "aes.h"
+#include "xts.h"
+#include "nettle-internal.h"
+
+static void
+test_check_data(const char *operation,
+                const uint8_t *input, const uint8_t *output,
+                const uint8_t *expected, size_t length)
+{
+  if (!MEMEQ(length, output, expected))
+    {
+      fprintf(stderr, "XTS %s failed:\nInput:", operation);
+      print_hex(length, input);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, output);
+      fprintf(stderr, "\nExpected:");
+      print_hex(length, expected);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+}
+
+static void
+test_cipher_xts(const struct nettle_cipher *cipher,
+		const struct tstring *key,
+		const struct tstring *tweak,
+		const struct tstring *cleartext,
+		const struct tstring *ciphertext)
+{
+  void *twk_ctx = xalloc(cipher-&gt;context_size);
+  void *ctx = xalloc(cipher-&gt;context_size);
+  uint8_t *data, *data2;
+  size_t length = cleartext-&gt;length;
+
+  ASSERT (cleartext-&gt;length == ciphertext-&gt;length);
+  ASSERT (key-&gt;length == cipher-&gt;key_size * 2);
+  ASSERT (tweak-&gt;length == XTS_BLOCK_SIZE);
+
+  data = xalloc(length);
+  data2 = xalloc(length);
+
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_encrypt_message(ctx, twk_ctx, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data, cleartext-&gt;data);
+  test_check_data("encrypt", cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+  cipher-&gt;set_decrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_decrypt_message(ctx, twk_ctx, cipher-&gt;decrypt, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data2, data);
+  test_check_data("decrypt", data, data2, cleartext-&gt;data, length);
+
+  memcpy(data, cleartext-&gt;data, length);
+
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_encrypt_message(ctx, twk_ctx, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data, data);
+  test_check_data("inplace encrypt",
+                  cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+  cipher-&gt;set_decrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_decrypt_message(ctx, twk_ctx, cipher-&gt;decrypt, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data, data);
+  test_check_data("inplace decrypt", data, data, cleartext-&gt;data, length);
+
+  /* make sure AES128 specific functions also works the same */
+  if (cipher == &amp;nettle_aes128) {
+    struct xts_aes128_ctx ctx;
+
+    xts_aes128_set_encrypt_key(&amp;ctx, key-&gt;data);
+    xts_aes128_encrypt_message(&amp;ctx, tweak-&gt;data, length, data,
+                               cleartext-&gt;data);
+    test_check_data("encrypt",
+                    cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+    xts_aes128_set_decrypt_key(&amp;ctx, key-&gt;data);
+    xts_aes128_decrypt_message(&amp;ctx, tweak-&gt;data, length, data,
+                               ciphertext-&gt;data);
+    test_check_data("decrypt",
+                    ciphertext-&gt;data, data, cleartext-&gt;data, length);
+  }
+
+  /* make sure AES256 specific functions also works the same */
+  if (cipher == &amp;nettle_aes256) {
+    struct xts_aes256_ctx ctx;
+
+    xts_aes256_set_encrypt_key(&amp;ctx, key-&gt;data);
+    xts_aes256_encrypt_message(&amp;ctx, tweak-&gt;data, length, data,
+                               cleartext-&gt;data);
+    test_check_data("encrypt",
+                    cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+    xts_aes256_set_decrypt_key(&amp;ctx, key-&gt;data);
+    xts_aes256_decrypt_message(&amp;ctx, tweak-&gt;data, length, data,
+                               ciphertext-&gt;data);
+    test_check_data("decrypt",
+                    ciphertext-&gt;data, data, cleartext-&gt;data, length);
+  }
+
+  free(twk_ctx);
+  free(ctx);
+  free(data);
+  free(data2);
+}
+
+void
+test_main(void)
+{
+  /* From NIST CAVS 11.0,
+   *
+   * https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Algorithm-Validation-Program/documents/aes/XTSTestVectors.zip
 +   *
+   * Selection of testing vectors from the above CAVS set
+   */
+
+  /* AES-128 single block - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes128,
+		  SHEX("a1b90cba3f06ac353b2c343876081762"
+                       "090923026e91771815f29dab01932f2f"),
+		  SHEX("4faef7117cda59c66e4b92013e768ad5"),
+		  SHEX("ebabce95b14d3c8d6fb350390790311c"),
+		  SHEX("778ae8b43cb98d5a825081d5be471c63"));
+
+  /* AES-128 two blocks - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes128,
+		  SHEX("750372c3d82f63382867be6662acfa4a"
+                       "259be3fa9bc662a1154ffaaed8b448a5"),
+		  SHEX("93a29254c47e4260669621307d4f5cd3"),
+		  SHEX("d8e3a56559a436ce0d8b212c80a88b23"
+                       "af62b0e598f208e03c1f2e9fa563a54b"),
+		  SHEX("495f7855535efd133464dc9a9abf8a0f"
+                       "28facbce21bd3c22178ec489b799e491"));
+
+  /* AES-128 partial second block */
+  test_cipher_xts(&amp;nettle_aes128,
+                  SHEX("394c97881abd989d29c703e48a72b397"
+                       "a7acf51b59649eeea9b33274d8541df4"),
+                  SHEX("4b15c684a152d485fe9937d39b168c29"),
+                  SHEX("2f3b9dcfbae729583b1d1ffdd16bb6fe"
+                       "2757329435662a78f0"),
+                  SHEX("f3473802e38a3ffef4d4fb8e6aa266eb"
+                       "de553a64528a06463e"));
+
+  /* AES-256 two blocks - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes256,
+		  SHEX("1ea661c58d943a0e4801e42f4b094714"
+                       "9e7f9f8e3e68d0c7505210bd311a0e7c"
+                       "d6e13ffdf2418d8d1911c004cda58da3"
+                       "d619b7e2b9141e58318eea392cf41b08"),
+		  SHEX("adf8d92627464ad2f0428e84a9f87564"),
+		  SHEX("2eedea52cd8215e1acc647e810bbc364"
+                       "2e87287f8d2e57e36c0a24fbc12a202e"),
+		  SHEX("cbaad0e2f6cea3f50b37f934d46a9b13"
+                       "0b9d54f07e34f36af793e86f73c6d7db"));
+
+  /* AES-256 three blocks - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes256,
+		  SHEX("266c336b3b01489f3267f52835fd92f6"
+                       "74374b88b4e1ebd2d36a5f457581d9d0"
+                       "42c3eef7b0b7e5137b086496b4d9e6ac"
+                       "658d7196a23f23f036172fdb8faee527"),
+		  SHEX("06b209a7a22f486ecbfadb0f3137ba42"),
+		  SHEX("ca7d65ef8d3dfad345b61ccddca1ad81"
+                       "de830b9e86c7b426d76cb7db766852d9"
+                       "81c6b21409399d78f42cc0b33a7bbb06"),
+		  SHEX("c73256870cc2f4dd57acc74b5456dbd7"
+                       "76912a128bc1f77d72cdebbf270044b7"
+                       "a43ceed29025e1e8be211fa3c3ed002d"));
+}
diff --git a/xts-aes128.c b/xts-aes128.c
new file mode 100644
index 00000000..7c083191
--- /dev/null
+++ b/xts-aes128.c
@@ -0,0 +1,75 @@
+/* xts-aes128.c
+
+   XTS Mode using AES128 as the underlying cipher.
+
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "aes.h"
+#include "xts.h"
+
+
+void
+xts_aes128_set_encrypt_key(struct xts_aes128_ctx *ctx, const uint8_t *key)
+{
+    aes128_set_encrypt_key(&amp;ctx-&gt;cipher, key);
+    aes128_set_encrypt_key(&amp;ctx-&gt;tweak_cipher, &amp;key[AES128_KEY_SIZE]);
+}
+
+void
+xts_aes128_set_decrypt_key(struct xts_aes128_ctx *ctx, const uint8_t *key)
+{
+    aes128_set_decrypt_key(&amp;ctx-&gt;cipher, key);
+    aes128_set_encrypt_key(&amp;ctx-&gt;tweak_cipher, &amp;key[AES128_KEY_SIZE]);
+}
+
+void
+xts_aes128_encrypt_message(struct xts_aes128_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src)
+{
+    xts_encrypt_message(&amp;ctx-&gt;cipher, &amp;ctx-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes128_encrypt,
+                        tweak, length, dst, src);
+}
+
+void
+xts_aes128_decrypt_message(struct xts_aes128_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src)
+{
+    xts_decrypt_message(&amp;ctx-&gt;cipher, &amp;ctx-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes128_decrypt,
+                        (nettle_cipher_func *) aes128_encrypt,
+                        tweak, length, dst, src);
+}
diff --git a/xts-aes256.c b/xts-aes256.c
new file mode 100644
index 00000000..1eb8cc9e
--- /dev/null
+++ b/xts-aes256.c
@@ -0,0 +1,75 @@
+/* xts-aes256.c
+
+   XTS Mode using AES256 as the underlying cipher.
+
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "aes.h"
+#include "xts.h"
+
+
+void
+xts_aes256_set_encrypt_key(struct xts_aes256_ctx *ctx, const uint8_t *key)
+{
+    aes256_set_encrypt_key(&amp;ctx-&gt;cipher, key);
+    aes256_set_encrypt_key(&amp;ctx-&gt;tweak_cipher, &amp;key[AES256_KEY_SIZE]);
+}
+
+void
+xts_aes256_set_decrypt_key(struct xts_aes256_ctx *ctx, const uint8_t *key)
+{
+    aes256_set_decrypt_key(&amp;ctx-&gt;cipher, key);
+    aes256_set_encrypt_key(&amp;ctx-&gt;tweak_cipher, &amp;key[AES256_KEY_SIZE]);
+}
+
+void
+xts_aes256_encrypt_message(struct xts_aes256_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src)
+{
+    xts_encrypt_message(&amp;ctx-&gt;cipher, &amp;ctx-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes256_encrypt,
+                        tweak, length, dst, src);
+}
+
+void
+xts_aes256_decrypt_message(struct xts_aes256_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src)
+{
+    xts_decrypt_message(&amp;ctx-&gt;cipher, &amp;ctx-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes256_decrypt,
+                        (nettle_cipher_func *) aes256_encrypt,
+                        tweak, length, dst, src);
+}
diff --git a/xts.c b/xts.c
new file mode 100644
index 00000000..3ce65975
--- /dev/null
+++ b/xts.c
@@ -0,0 +1,201 @@
+/* xts.c
+
+   XEX-based tweaked-codebook mode with ciphertext stealing (XTS)
+
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "xts.h"
+
+#include "macros.h"
+#include "memxor.h"
+#include "nettle-internal.h"
+
+/* shift one and XOR with 0x87. */
+/* src and dest can point to the same buffer for in-place operations */
+static void
+xts_shift(union nettle_block16 *dst,
+          const union nettle_block16 *src)
+{
+  uint8_t carry = src-&gt;b[15] &gt;&gt; 7;
+  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) | (src-&gt;u64[0] &gt;&gt; 63);
+  dst-&gt;u64[0] = src-&gt;u64[0] &lt;&lt; 1;
+  dst-&gt;b[0] ^= 0x87 &amp; -carry;
+}
+
+/*
+ * prev is the block to steal from
+ * curr is the input block to the last step
+ * length is the partial block length
+ * dst is the destination partial block
+ * src is the source partial block
+ *
+ * In the Encryption case:
+ *   prev -&gt; the output of the N-1 encryption step
+ *   curr -&gt; the input to the Nth step (will be encrypted as Cn-1)
+ *   dst  -&gt; the final Cn partial block
+ *   src  -&gt; the final Pn partial block
+ *
+ * In the decryption case:
+ *   prev -&gt; the output of the N-1 decryption step
+ *   curr -&gt; the input to the Nth step (will be decrypted as Pn-1)
+ *   dst  -&gt; the final Pn partial block
+ *   src  -&gt; the final Cn partial block
+ */
+static void
+xts_steal(uint8_t *prev, uint8_t *curr,
+	  size_t length, uint8_t *dst, const uint8_t *src)
+{
+  /* copy the remaining in the current input block */
+  memcpy(curr, src, length);
+  /* fill the current block with the last blocksize - length
+   * bytes of the previous block */
+  memcpy(&amp;curr[length], &amp;prev[length], XTS_BLOCK_SIZE - length);
+
+  /* This must be last or inplace operations will break
+   * copy 'length' bytes of the previous block in the
+   * destination block, which is the final partial block
+   * returned to the caller */
+  memcpy(dst, prev, length);
+}
+
+static void
+check_length(size_t length, uint8_t *dst)
+{
+  assert(length &gt;= XTS_BLOCK_SIZE);
+  /* asserts may be compiled out, try to save the user by zeroing the dst in
+   * case the buffer contains sensitive data (like the clear text for inplace
+   * encryption) */
+  if (length &lt; XTS_BLOCK_SIZE)
+    memxor(dst, dst, length);
+}
+
+/* works also for inplace encryption/decryption */
+
+void
+xts_encrypt_message(const void *enc_ctx, const void *twk_ctx,
+	            nettle_cipher_func *encf,
+	            const uint8_t *tweak, size_t length,
+	            uint8_t *dst, const uint8_t *src)
+{
+  union nettle_block16 T;
+  union nettle_block16 P;
+
+  check_length(length, dst);
+
+  encf(twk_ctx, XTS_BLOCK_SIZE, T.b, tweak);
+
+  /* the zeroth power of alpha is the initial ciphertext value itself, so we
+   * skip shifting and do it at the end of each block operation instead */
+  for (;length &gt;= XTS_BLOCK_SIZE;
+       length -= XTS_BLOCK_SIZE, src += XTS_BLOCK_SIZE, dst += XTS_BLOCK_SIZE)
+    {
+      memcpy(P.b, src, XTS_BLOCK_SIZE);
+      memxor(P.b, T.b, XTS_BLOCK_SIZE);	        /* P -&gt; PP */
+      encf(enc_ctx, XTS_BLOCK_SIZE, dst, P.b);  /* CC */
+      memxor(dst, T.b, XTS_BLOCK_SIZE);	        /* CC -&gt; C */
+
+      /* shift T for next block */
+      xts_shift(&amp;T, &amp;T);
+    }
+
+  /* if the last block is partial, handle via stealing */
+  if (length)
+    {
+      uint8_t *C = dst - XTS_BLOCK_SIZE;
+      /* C points to C(n-1) */
+      xts_steal(C, P.b, length, dst, src);
+      memxor(P.b, T.b, XTS_BLOCK_SIZE);	        /* P -&gt; PP */
+      encf(enc_ctx, XTS_BLOCK_SIZE, C, P.b);    /* CC */
+      memxor(C, T.b, XTS_BLOCK_SIZE);
+    }
+}
+
+void
+xts_decrypt_message(const void *dec_ctx, const void *twk_ctx,
+	            nettle_cipher_func *decf, nettle_cipher_func *encf,
+	            const uint8_t *tweak, size_t length,
+	            uint8_t *dst, const uint8_t *src)
+{
+  union nettle_block16 T;
+  union nettle_block16 C;
+
+  check_length(length, dst);
+
+  encf(twk_ctx, XTS_BLOCK_SIZE, T.b, tweak);
+
+  for (;length &gt;= XTS_BLOCK_SIZE;
+       length -= XTS_BLOCK_SIZE, src += XTS_BLOCK_SIZE, dst += XTS_BLOCK_SIZE)
+    {
+      if (length &gt; XTS_BLOCK_SIZE &amp;&amp; length &lt; 2 * XTS_BLOCK_SIZE)
+        break;                  /* must ciphersteal on last two blocks */
+
+      memcpy(C.b, src, XTS_BLOCK_SIZE);
+      memxor(C.b, T.b, XTS_BLOCK_SIZE);	        /* c -&gt; CC */
+      decf(dec_ctx, XTS_BLOCK_SIZE, dst, C.b);  /* PP */
+      memxor(dst, T.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+
+      xts_shift(&amp;T, &amp;T);
+    }
+
+  /* if the last block is partial, handle via stealing */
+  if (length)
+    {
+      union nettle_block16 T1;
+      uint8_t *P;
+
+      /* we need the last T(n) and save the T(n-1) for later */
+      xts_shift(&amp;T1, &amp;T);
+
+      P = dst;      /* use P(n-1) as temp storage for partial P(n) */
+      memcpy(C.b, src, XTS_BLOCK_SIZE);
+      memxor(C.b, T1.b, XTS_BLOCK_SIZE);	/* C -&gt; CC */
+      decf(dec_ctx, XTS_BLOCK_SIZE, P, C.b);    /* PP */
+      memxor(P, T1.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+
+      /* process next block (Pn-1) */
+      length -= XTS_BLOCK_SIZE;
+      src += XTS_BLOCK_SIZE;
+      dst += XTS_BLOCK_SIZE;
+
+      /* Fill P(n) and prepare C, P still pointing to P(n-1) */
+      xts_steal(P, C.b, length, dst, src);
+      memxor(C.b, T.b, XTS_BLOCK_SIZE);	        /* C -&gt; CC */
+      decf(dec_ctx, XTS_BLOCK_SIZE, P, C.b);    /* PP */
+      memxor(P, T.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+    }
+}
diff --git a/xts.h b/xts.h
new file mode 100644
index 00000000..fe494647
--- /dev/null
+++ b/xts.h
@@ -0,0 +1,117 @@
+/* xts.h
+
+   XEX-based tweaked-codebook mode with ciphertext stealing (XTS)
+
+   Copyright (C) 2005 Niels Möller
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+
+#ifndef NETTLE_XTS_H_INCLUDED
+#define NETTLE_XTS_H_INCLUDED
+
+#include "nettle-types.h"
+#include "aes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define xts_encrypt_message nettle_xts_encrypt_message
+#define xts_decrypt_message nettle_xts_decrypt_message
+#define xts_aes128_set_encrypt_key nettle_xts_aes128_set_encrypt_key
+#define xts_aes128_set_decrypt_key nettle_xts_aes128_set_decrypt_key
+#define xts_aes128_encrypt_message nettle_xts_aes128_encrypt_message
+#define xts_aes128_decrypt_message nettle_xts_aes128_decrypt_message
+#define xts_aes256_set_encrypt_key nettle_xts_aes256_set_encrypt_key
+#define xts_aes256_set_decrypt_key nettle_xts_aes256_set_decrypt_key
+#define xts_aes256_encrypt_message nettle_xts_aes256_encrypt_message
+#define xts_aes256_decrypt_message nettle_xts_aes256_decrypt_message
+
+#define XTS_BLOCK_SIZE 16
+
+void
+xts_encrypt_message(const void *enc_ctx, const void *twk_ctx,
+                nettle_cipher_func *encf,
+                const uint8_t *tweak, size_t length,
+                uint8_t *dst, const uint8_t *src);
+void
+xts_decrypt_message(const void *dec_ctx, const void *twk_ctx,
+                    nettle_cipher_func *decf, nettle_cipher_func *encf,
+                    const uint8_t *tweak, size_t length,
+                    uint8_t *dst, const uint8_t *src);
+
+/* XTS Mode with AES-128 */
+struct xts_aes128_ctx {
+    struct aes128_ctx cipher;
+    struct aes128_ctx tweak_cipher;
+};
+
+void
+xts_aes128_set_encrypt_key(struct xts_aes128_ctx *ctx, const uint8_t *key);
+
+void
+xts_aes128_set_decrypt_key(struct xts_aes128_ctx *ctx, const uint8_t *key);
+
+void
+xts_aes128_encrypt_message(struct xts_aes128_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+xts_aes128_decrypt_message(struct xts_aes128_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src);
+
+/* XTS Mode with AES-256 */
+struct xts_aes256_ctx {
+    struct aes256_ctx cipher;
+    struct aes256_ctx tweak_cipher;
+};
+
+void
+xts_aes256_set_encrypt_key(struct xts_aes256_ctx *ctx, const uint8_t *key);
+
+void
+xts_aes256_set_decrypt_key(struct xts_aes256_ctx *ctx, const uint8_t *key);
+
+void
+xts_aes256_encrypt_message(struct xts_aes256_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+xts_aes256_decrypt_message(struct xts_aes256_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_XTS_H_INCLUDED */
+
-- 
2.18.1


[Attachment #4 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190315213306</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-03-15 21:33:06-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; Turns out the algorithm is not equivalent, as the shift is applied to
&gt; the array as if it were a big 128bit little endian value, the endianess
&gt; of the two is different.

Ah, I see. 

&gt; /* shift one and XOR with 0x87. */
&gt; /* src and dest can point to the same buffer for in-place operations */
&gt; static void
&gt; xts_shift(union nettle_block16 *dst,
&gt;           const union nettle_block16 *src)
&gt; {
&gt;   uint8_t carry = src-&gt;b[15] &gt;&gt; 7;
&gt;   dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) | (src-&gt;u64[0] &gt;&gt; 63);
&gt;   dst-&gt;u64[0] = src-&gt;u64[0] &lt;&lt; 1;
&gt;   dst-&gt;b[0] ^= 0x87 &amp; -carry;
&gt; }

This will then work only on little-endian systems?

I think it would be nice with a structure like

  b0 = src-&gt;u64[0]; b1 = src-&gt;u64[1];  /* Load inputs */
  ... swap if big-endian ...
  uint64_t carry = (b1 &gt;&gt; 63);
  b1 = (b1 &lt;&lt; 1) | (b0 &gt;&gt; 63)
  b0 = (b0 &lt;&lt; 1) ^ (0x87 &amp; -carry);
  ... swap if big-endian ...
  dst-&gt;u64[0] = b0; dst-&gt;u64[1] = b1;  /* Store output */

I.e., no memory accesses smaller than 64-bits.

Possibly with load + swap and swap + store done with some
system-dependent macros.

But it's not essential for a first version of xts; copying block_mulx
and just replacing READ_UINT64 with LE_READ_UINT64 and similarly for
WRITE would be ok for now. There are more places with potential for
micro-optimizations related to endianness. While I think the
READ/WRITE_UINT macros are adequate in most places where unaligned
application data is read and written by C code.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190106102555</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-01-06 10:25:55-0400</timestampReceived><subject>Re: sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize</subject><body>

Jeffrey Walton &lt;noloader@gmail.com&gt; writes:

&gt; I'm trying to build Nettle 3.4.1 on Fedora 29, x64 (fully patched).
&gt; Self tests are failing at:
&gt;
&gt;     PASS: rsa-sec-decrypt
&gt;     sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize
&gt;     ../run-tests: line 57: 22997 Aborted (core dumped) "$1" $testflags
&gt;     FAIL: rsa-compute-root
&gt;     PASS: dsa
&gt;     PASS: dsa-keygen

(This was a test with -DNDEBUG, a configuration not covered by the
gitlab ci testers). Turned out to be a bug in the test code,

  assert (mpz_invert(key-&gt;d, pub-&gt;e, phi));

Fixed (on the release-3.4-fixes branch) with commit
https://git.lysator.liu.se/nettle/nettle/commit/73d3c6d5586cc0fd81eab081078144d621de07b4

There was another -DNDEBUG breakage in examples/nettle-openssl.c, which
was fixed on master long ago, but which I overlooked when cherry-picking
bugfixes for nettle-3.4.1. Also fixed now.

Question for the list: I'm now aware of two bugs in nettle-3.4.1:

1. Accidental use of c99 loops, breaking builds with c89 compilers.

2. Incorrect asserts, affecting tests and benchmark code when compield
   with -DNDEBUG, but not the libraries themselves.

Should I make a 3.4.2 release fixing these problems?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190107182459</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-01-07 18:24:59-0400</timestampReceived><subject>Re: sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize</subject><body>

They seem minor enough not to really need a new release IMO, people can
get them from master as needed. Or maybe you can commit patches on the
3.4 branch so people can find them more easily if they really care.

I have a question though, why C89 support ?
C99 is already almost 20y old already ...

Regards,
Simo.

On Sun, 2019-01-06 at 11:25 +0100, Niels Möller wrote:
&gt; Jeffrey Walton &lt;noloader@gmail.com&gt; writes:
&gt; 
&gt; &gt; I'm trying to build Nettle 3.4.1 on Fedora 29, x64 (fully patched).
&gt; &gt; Self tests are failing at:
&gt; &gt; 
&gt; &gt;     PASS: rsa-sec-decrypt
&gt; &gt;     sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize
&gt; &gt;     ../run-tests: line 57: 22997 Aborted (core dumped) "$1" $testflags
&gt; &gt;     FAIL: rsa-compute-root
&gt; &gt;     PASS: dsa
&gt; &gt;     PASS: dsa-keygen
&gt; 
&gt; (This was a test with -DNDEBUG, a configuration not covered by the
&gt; gitlab ci testers). Turned out to be a bug in the test code,
&gt; 
&gt;   assert (mpz_invert(key-&gt;d, pub-&gt;e, phi));
&gt; 
&gt; Fixed (on the release-3.4-fixes branch) with commit
&gt; https://git.lysator.liu.se/nettle/nettle/commit/73d3c6d5586cc0fd81eab081078144d621de07b4
&gt; 
&gt; There was another -DNDEBUG breakage in examples/nettle-openssl.c, which
&gt; was fixed on master long ago, but which I overlooked when cherry-picking
&gt; bugfixes for nettle-3.4.1. Also fixed now.
&gt; 
&gt; Question for the list: I'm now aware of two bugs in nettle-3.4.1:
&gt; 
&gt; 1. Accidental use of c99 loops, breaking builds with c89 compilers.
&gt; 
&gt; 2. Incorrect asserts, affecting tests and benchmark code when compield
&gt;    with -DNDEBUG, but not the libraries themselves.
&gt; 
&gt; Should I make a 3.4.2 release fixing these problems?
&gt; 
&gt; Regards,
&gt; /Niels
&gt; 

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190107191512</emailId><senderName>Tim_Rühsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2019-01-07 19:15:12-0400</timestampReceived><subject>Re: sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize</subject><body>

[Attachment #2 (multipart/signed)]

[Attachment #4 (multipart/mixed)]


On 07.01.19 19:24, Simo Sorce wrote:
&gt; They seem minor enough not to really need a new release IMO, people can
&gt; get them from master as needed. Or maybe you can commit patches on the
&gt; 3.4 branch so people can find them more easily if they really care.
&gt; 
&gt; I have a question though, why C89 support ?
&gt; C99 is already almost 20y old already ...

There are still modern compilers that lack full C99 support.
I am not sure about embedded systems with special C compilers...

Regards, Tim

&gt; On Sun, 2019-01-06 at 11:25 +0100, Niels Möller wrote:
&gt;&gt; Jeffrey Walton &lt;noloader@gmail.com&gt; writes:
&gt;&gt;
&gt;&gt;&gt; I'm trying to build Nettle 3.4.1 on Fedora 29, x64 (fully patched).
&gt;&gt;&gt; Self tests are failing at:
&gt;&gt;&gt;
&gt;&gt;&gt;     PASS: rsa-sec-decrypt
&gt;&gt;&gt;     sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize
&gt;&gt;&gt;     ../run-tests: line 57: 22997 Aborted (core dumped) "$1" $testflags
&gt;&gt;&gt;     FAIL: rsa-compute-root
&gt;&gt;&gt;     PASS: dsa
&gt;&gt;&gt;     PASS: dsa-keygen
&gt;&gt;
&gt;&gt; (This was a test with -DNDEBUG, a configuration not covered by the
&gt;&gt; gitlab ci testers). Turned out to be a bug in the test code,
&gt;&gt;
&gt;&gt;   assert (mpz_invert(key-&gt;d, pub-&gt;e, phi));
&gt;&gt;
&gt;&gt; Fixed (on the release-3.4-fixes branch) with commit
&gt;&gt; https://git.lysator.liu.se/nettle/nettle/commit/73d3c6d5586cc0fd81eab081078144d621de07b4
&gt;&gt;
&gt;&gt; There was another -DNDEBUG breakage in examples/nettle-openssl.c, which
&gt;&gt; was fixed on master long ago, but which I overlooked when cherry-picking
&gt;&gt; bugfixes for nettle-3.4.1. Also fixed now.
&gt;&gt;
&gt;&gt; Question for the list: I'm now aware of two bugs in nettle-3.4.1:
&gt;&gt;
&gt;&gt; 1. Accidental use of c99 loops, breaking builds with c89 compilers.
&gt;&gt;
&gt;&gt; 2. Incorrect asserts, affecting tests and benchmark code when compield
&gt;&gt;    with -DNDEBUG, but not the libraries themselves.
&gt;&gt;
&gt;&gt; Should I make a 3.4.2 release fixing these problems?
&gt;&gt;
&gt;&gt; Regards,
&gt;&gt; /Niels
&gt;&gt;
&gt; 


["signature.asc" (application/pgp-signature)]
[Attachment #8 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190107211419</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-01-07 21:14:19-0400</timestampReceived><subject>Re: sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; I have a question though, why C89 support ?

Code was written for c89 aka ansi-c. So it's not difficult to keep
supporting it, and it might help for some (embedded mainly, I imagine)
compilers.

That said, I'm about to delete nettle-stdint.h, and require that the
compiler supplies a &lt;stdint.h&gt; (as was discussed quite a while ago).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190122214530</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-01-22 21:45:30-0400</timestampReceived><subject>Re: sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; That said, I'm about to delete nettle-stdint.h, and require that the
&gt; compiler supplies a &lt;stdint.h&gt; (as was discussed quite a while ago).

I've now merged changes to do that to the master-updates branch. It
breaks the gnutls build, see
https://gitlab.com/gnutls/nettle/-/jobs/149522724,

  In file included from gost/gost28147.c:40:
  gost/nettle-write.h:40:10: fatal error: nettle/nettle-stdint.h: No such
  file or directory
   #include &lt;nettle/nettle-stdint.h&gt;
            ^~~~~~~~~~~~~~~~~~~~~~~~

Is this easy to fix (e.g., include nettle-types.h instead?), or should I
add an installed header nettle/nettle-stdint.h containing only

#include &lt;stdint.h&gt;

?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190315214654</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-03-15 21:46:54-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

On Fri, 2019-03-15 at 22:33 +0100, Niels Möller wrote:
&gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; 
&gt; &gt; Turns out the algorithm is not equivalent, as the shift is applied to
&gt; &gt; the array as if it were a big 128bit little endian value, the endianess
&gt; &gt; of the two is different.
&gt; 
&gt; Ah, I see. 
&gt; 
&gt; &gt; /* shift one and XOR with 0x87. */
&gt; &gt; /* src and dest can point to the same buffer for in-place operations */
&gt; &gt; static void
&gt; &gt; xts_shift(union nettle_block16 *dst,
&gt; &gt;           const union nettle_block16 *src)
&gt; &gt; {
&gt; &gt;   uint8_t carry = src-&gt;b[15] &gt;&gt; 7;
&gt; &gt;   dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) | (src-&gt;u64[0] &gt;&gt; 63);
&gt; &gt;   dst-&gt;u64[0] = src-&gt;u64[0] &lt;&lt; 1;
&gt; &gt;   dst-&gt;b[0] ^= 0x87 &amp; -carry;
&gt; &gt; }
&gt; 
&gt; This will then work only on little-endian systems?
&gt; 
&gt; I think it would be nice with a structure like
&gt; 
&gt;   b0 = src-&gt;u64[0]; b1 = src-&gt;u64[1];  /* Load inputs */
&gt;   ... swap if big-endian ...
&gt;   uint64_t carry = (b1 &gt;&gt; 63);
&gt;   b1 = (b1 &lt;&lt; 1) | (b0 &gt;&gt; 63)
&gt;   b0 = (b0 &lt;&lt; 1) ^ (0x87 &amp; -carry);
&gt;   ... swap if big-endian ...
&gt;   dst-&gt;u64[0] = b0; dst-&gt;u64[1] = b1;  /* Store output */
&gt; 
&gt; I.e., no memory accesses smaller than 64-bits.
&gt; 
&gt; Possibly with load + swap and swap + store done with some
&gt; system-dependent macros.
&gt; 
&gt; But it's not essential for a first version of xts; copying block_mulx
&gt; and just replacing READ_UINT64 with LE_READ_UINT64 and similarly for
&gt; WRITE would be ok for now. There are more places with potential for
&gt; micro-optimizations related to endianness. While I think the
&gt; READ/WRITE_UINT macros are adequate in most places where unaligned
&gt; application data is read and written by C code.

I will add the macros to swap endianess, and resend a new version.

Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190315220204</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-03-15 22:02:04-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

On Fri, 2019-03-15 at 17:46 -0400, Simo Sorce wrote:
&gt; On Fri, 2019-03-15 at 22:33 +0100, Niels Möller wrote:
&gt; &gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; &gt; 
&gt; &gt; &gt; Turns out the algorithm is not equivalent, as the shift is applied to
&gt; &gt; &gt; the array as if it were a big 128bit little endian value, the endianess
&gt; &gt; &gt; of the two is different.
&gt; &gt; 
&gt; &gt; Ah, I see. 
&gt; &gt; 
&gt; &gt; &gt; /* shift one and XOR with 0x87. */
&gt; &gt; &gt; /* src and dest can point to the same buffer for in-place operations */
&gt; &gt; &gt; static void
&gt; &gt; &gt; xts_shift(union nettle_block16 *dst,
&gt; &gt; &gt; const union nettle_block16 *src)
&gt; &gt; &gt; {
&gt; &gt; &gt; uint8_t carry = src-&gt;b[15] &gt;&gt; 7;
&gt; &gt; &gt; dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) | (src-&gt;u64[0] &gt;&gt; 63);
&gt; &gt; &gt; dst-&gt;u64[0] = src-&gt;u64[0] &lt;&lt; 1;
&gt; &gt; &gt; dst-&gt;b[0] ^= 0x87 &amp; -carry;
&gt; &gt; &gt; }
&gt; &gt; 
&gt; &gt; This will then work only on little-endian systems?
&gt; &gt; 
&gt; &gt; I think it would be nice with a structure like
&gt; &gt; 
&gt; &gt; b0 = src-&gt;u64[0]; b1 = src-&gt;u64[1];  /* Load inputs */
&gt; &gt; ... swap if big-endian ...
&gt; &gt; uint64_t carry = (b1 &gt;&gt; 63);
&gt; &gt; b1 = (b1 &lt;&lt; 1) | (b0 &gt;&gt; 63)
&gt; &gt; b0 = (b0 &lt;&lt; 1) ^ (0x87 &amp; -carry);
&gt; &gt; ... swap if big-endian ...
&gt; &gt; dst-&gt;u64[0] = b0; dst-&gt;u64[1] = b1;  /* Store output */
&gt; &gt; 
&gt; &gt; I.e., no memory accesses smaller than 64-bits.
&gt; &gt; 
&gt; &gt; Possibly with load + swap and swap + store done with some
&gt; &gt; system-dependent macros.
&gt; &gt; 
&gt; &gt; But it's not essential for a first version of xts; copying block_mulx
&gt; &gt; and just replacing READ_UINT64 with LE_READ_UINT64 and similarly for
&gt; &gt; WRITE would be ok for now. There are more places with potential for
&gt; &gt; micro-optimizations related to endianness. While I think the
&gt; &gt; READ/WRITE_UINT macros are adequate in most places where unaligned
&gt; &gt; application data is read and written by C code.
&gt; 
&gt; I will add the macros to swap endianess, and resend a new version.

New patch attached, the diff has also been applied as an additional commit to my \
xts_exploded tree in gitlab.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


["0001-Add-support-for-XTS-encryption-mode.patch" (0001-Add-support-for-XTS-encryption-mode.patch)]

From a17e0ce7aeebe0d3db46d03ef857a622831fff4a Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Thu, 4 Oct 2018 14:38:50 -0400
Subject: [PATCH] Add support for XTS encryption mode

XEX encryption mode with tweak and ciphertext stealing (XTS) is
standardized in IEEE 1619 and generally used for storage devices.

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 Makefile.in                |   5 +-
 nettle.texinfo             | 147 +++++++++++++++++++++++++-
 testsuite/.gitignore       |   1 +
 testsuite/.test-rules.make |   3 +
 testsuite/Makefile.in      |   2 +-
 testsuite/xts-test.c       | 173 +++++++++++++++++++++++++++++++
 xts-aes128.c               |  75 ++++++++++++++
 xts-aes256.c               |  75 ++++++++++++++
 xts.c                      | 205 +++++++++++++++++++++++++++++++++++++
 xts.h                      | 117 +++++++++++++++++++++
 10 files changed, 798 insertions(+), 5 deletions(-)
 create mode 100644 testsuite/xts-test.c
 create mode 100644 xts-aes128.c
 create mode 100644 xts-aes256.c
 create mode 100644 xts.c
 create mode 100644 xts.h

diff --git a/Makefile.in b/Makefile.in
index 83250cf3..440de9f7 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -135,7 +135,8 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 umac32.c umac64.c umac96.c umac128.c \
 		 version.c \
 		 write-be32.c write-le32.c write-le64.c \
-		 yarrow256.c yarrow_key_event.c
+		 yarrow256.c yarrow_key_event.c \
+		 xts.c xts-aes128.c xts-aes256.c
 
 hogweed_SOURCES = sexp.c sexp-format.c \
 		  sexp-transport.c sexp-transport-format.c \
@@ -206,7 +207,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  pgp.h pkcs1.h pss.h pss-mgf1.h realloc.h ripemd160.h rsa.h \
 	  salsa20.h sexp.h \
 	  serpent.h sha.h sha1.h sha2.h sha3.h twofish.h \
-	  umac.h yarrow.h poly1305.h
+	  umac.h yarrow.h xts.h poly1305.h
 
 INSTALL_HEADERS = $(HEADERS) version.h @IF_MINI_GMP@ mini-gmp.h
 
diff --git a/nettle.texinfo b/nettle.texinfo
index 9806bdc1..c44302bc 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -2001,7 +2001,8 @@ Book mode, @acronym{ECB}), leaks information.
 
 Besides @acronym{ECB}, Nettle provides several other modes of operation:
 Cipher Block Chaining (@acronym{CBC}), Counter mode (@acronym{CTR}), Cipher
-Feedback (@acronym{CFB} and @acronym{CFB8}) and a couple of @acronym{AEAD}
+Feedback (@acronym{CFB} and @acronym{CFB8}), XEX-based tweaked-codebook mode
+with ciphertext stealing (@acronym{XTS}) and a couple of @acronym{AEAD}
 modes (@pxref{Authenticated encryption}).  @acronym{CBC} is widely used, but
 there are a few subtle issues of information leakage, see, e.g.,
 @uref{http://www.kb.cert.org/vuls/id/958563, @acronym{SSH} @acronym{CBC}
@@ -2016,6 +2017,7 @@ authenticate the message.
 * CBC::                         
 * CTR::                         
 * CFB and CFB8::
+* XTS::
 @end menu
 
 @node CBC, CTR, Cipher modes, Cipher modes
@@ -2187,7 +2189,7 @@ last three arguments define the source and destination area for \
the  operation.
 @end deffn
 
-@node CFB and CFB8, , CTR, Cipher modes
+@node CFB and CFB8, XTS, CTR, Cipher modes
 @comment  node-name,  next,  previous,  up
 @subsection Cipher Feedback mode
 
@@ -2340,6 +2342,147 @@ conventions. The last three arguments define the source and \
destination  area for the operation.
 @end deffn
 
+@node XTS, , CFB and CFB8, Cipher modes
+@comment  node-name,  next,  previous,  up
+@subsection XEX-based tweaked-codebook mode with ciphertext stealing
+
+@cindex XEX-based tweaked-codebook mode with ciphertext stealing
+@cindex XTS Mode
+
+
+XEX-based tweaked-codebook mode with ciphertext stealing (@acronym{XTS}) is
+a block mode like (@acronym{CBC}) but tweaked to be able to encrypt partial
+blocks via a technique called ciphertext stealing, where the last complete
+block of ciphertext is split and part returned as the last block and part
+used as plaintext for the second to last block.
+This mode is principally used to encrypt data at rest where it is not possible
+to store additional metadata or blocks larger than the plain text. The most
+common usage is for disk encryption. Due to the fact that ciphertext expansion
+is not possible, data is not authenticated. This mode should not be used where
+authentication is critical.
+
+The message is divided into @code{n} blocks @code{M_1},@dots{} @code{M_n},
+where @code{M_n} is of size @code{m} which may be smaller than the block size.
+XTS always uses a fixed blocksize of 128 bit (16 bytes) length.
+
+Unlike other modes, the key is double the size of that for the used cipher mode
+(for example 256bit for AES-128 and 512bit for AES-256).
+
+@acronym{XTS} encryption mode operates given:
+@itemize
+@item A multiplication by a primitive element alpha.
+@code{MUL a^j} here represents the multiplication, where @code{j} is the power
+of alpha, and the input value is converted into a 16 bytes array
+@code{a_0[k], k = 0,1,..,15}. The multiplication is calculated as
+@code{a_(j+1)[0] = (2(a_j[0] mod 128)) XOR (135 * floor(a_j[15]/128)}
+@code{a_(j+1)[k] = (2(a_j[k] mod 128)) XOR (floor(a_j[k-1]/128), k = 1,2,..15}
+Note that this operation is practically a 1 bit left shift operation with carry
+propagating from one byte to the next, and if the last bit shift results in a
+carry the decimal value 135 is XORed into the first byte.
+
+@item The encryption key is provided as the @code{Key = K1 | K2}, where @code{|}
+denotes string concatenation.
+@code{E_k1} is the encryption function of the block cipher using @code{K1} as
+the key, and @code{E_k2} is the same encryption function using @code{K2}
+
+@item A 128 bit tweak value is provided as input and is denoted as @code{IV}
+@end itemize
+
+The @code{n} plaintext blocks are transformed into @code{n} ciphertext blocks
+@code{C_1},@dots{} @code{C_n} as follows.
+
+For a plaintext length that is a perfect multiple of the XTS block size:
+@example
+T_1 = E_k2(IV) MUL a^0
+C_1 = E_k1(P_1 XOR T_1) XOR T_1
+
+@dots{}
+
+T_n = E_k2(IV) MUL a^(n-1)
+C_n = E_k1(P_n XOR T_n) XOR T_n
+@end example
+
+For any other plaintext lengths:
+@example
+T_1 = E_k2(IV) MUL a^0
+C_1 = E_k1(P_1 XOR T_1) XOR T_1
+
+@dots{}
+
+T_(n-2) = E_k2(IV) MUL a^(n-3)
+C_(n-2) = E_k1(P_(n-2) XOR T_(n-2)) XOR T_(n-2)
+
+T_(n-1) = E_k2(IV) MUL a^(n-2)
+CC_(n-1) = E_k1(P_(n-1) XOR T_(n-1)) XOR T_(n-1)
+
+T_n = E_k2(IV) MUL a^(n-1)
+PP = [1..m]Pn | [m+1..128]CC_(n-1)
+C_(n-1) = E_k1(PP XOR T_n) XOR T_n
+
+C_n = [1..m]CC_(n-1)
+@end example
+
+@subsubsection General (@acronym{XTS}) interface.
+
+The two general functions to encrypt and decrypt using the @acronym{XTS} block
+cipher mode are the following:
+
+@deftypefun void xts_encrypt_message (const void *@var{enc_ctx}, const void \
*@var{twk_ctx}, nettle_cipher_func *@var{encf}, const uint8_t *@var{tweak}, size_t \
@var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +@deftypefunx void \
xts_decrypt_message (const void *@var{dec_ctx}, const void *@var{twk_ctx}, \
nettle_cipher_func *@var{decf}, nettle_cipher_func *@var{encf}, const uint8_t \
*@var{tweak}, size_t @var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +
+Applies the encryption function @var{encf} or the decryption function
+@var{decf} in @acronym{XTS} mode. At least one block (16 bytes) worth
+of data must be available therefore specifying a length less than 16
+bytes is illegal.
+
+The functions @var{encf} @var{decf} are of type
+
+@code{void f (void *@var{ctx}, size_t @var{length}, uint8_t *@var{dst},
+const uint8_t *@var{src})},
+
+@noindent and the @code{xts_encrypt_message} and @code{xts_decrypt_message}
+functions pass their arguments @var{enc_ctx}, @var{twk_ctx} and @var{dec_ctx}
+to the functions @var{encf}, @var{decf} as @var{ctx}.
+@end deftypefun
+
+@subsubsection @acronym{XTS}-@acronym{AES} interface
+
+The @acronym{AES} @acronym{XTS} functions provide an API for using the
+@acronym{XTS} mode with the @acronym{AES} block ciphers. The parameters
+all have the same meaning as the general interface, except that the
+@var{enc_ctx}, @var{dec_ctx}, @var{twk_ctx}, @var{encf} and @var{decf} are
+replaced with an @acronym{AES} context structure called @var{ctx}, and a
+appropriate set-key function must be called before using any of the encryption
+or decryption functions in this interface.
+
+@deftp {Context struct} {struct xts_aes128_ctx}
+Holds state corresponding to the AES-128 block cipher.
+@end deftp
+
+@deftp {Context struct} {struct xts_aes256_ctx}
+Holds state corresponding to the AES-256 block cipher.
+@end deftp
+
+@deftypefun void xts_aes128_set_encrypt_key (struct xts_aes128_ctx *@var{ctx}, const \
uint8_t *@var{key}) +@deftypefunx void xts_aes256_set_encrypt_key (struct \
xts_aes256_ctx *@var{ctx}, const uint8_t *@var{key}) +@deftypefunx void \
xts_aes128_set_decrypt_key (struct xts_aes128_ctx *@var{ctx}, const uint8_t \
*@var{key}) +@deftypefunx void xts_aes256_set_decrypt_key (struct xts_aes256_ctx \
*@var{ctx}, const uint8_t *@var{key}) +Initializes the encryption or decryption key \
for the AES block cipher. The +lenght of the key must be double the size of the key \
for the corresponding +cipher (256 bits for AES-128 and 512 bits for AES-256). One of
+these functions must be called before any of the other functions.
+@end deftypefun
+
+@deftypefun void xts_aes128_encrypt_message(struct xts_aes128_ctx *@var{ctx}, \
uint8_t *@var{tweak}, size_t @var{length}, uint8_t *@var{dst}, const uint8_t \
*@var{src}) +@deftypefunx void xts_aes256_encrypt_message(struct xts_aes256_ctx \
*@var{ctx}, uint8_t *@var{tweak}, size_t @var{length}, uint8_t *@var{dst}, const \
uint8_t *@var{src}) +@deftypefunx void xts_aes128_decrypt_message(struct \
xts_aes128_ctx *@var{ctx}, uint8_t *@var{tweak}, size_t @var{length}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +@deftypefunx void \
xts_aes256_decrypt_message(struct xts_aes256_ctx *@var{ctx}, uint8_t *@var{tweak}, \
size_t @var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +These are \
identical to @code{xts_encrypt_message} and +@code{xts_decrypt_message}, except that \
@var{enc_ctx}, @var{dec_ctx}, +@var{twk_ctx}, @var{encf} and @var{decf} are replaced \
by the @var{ctx} context +structure.
+@end deftypefun
+
 @node Authenticated encryption, Keyed hash functions, Cipher modes, Reference
 @comment  node-name,  next,  previous,  up
 
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index f98a949a..c3fc5c11 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -95,6 +95,7 @@
 /umac-test
 /version-test
 /yarrow-test
+/xts-test
 
 /test.in
 /test1.out
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index f36a1f7f..6eee6e22 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -166,6 +166,9 @@ buffer-test$(EXEEXT): buffer-test.$(OBJEXT)
 yarrow-test$(EXEEXT): yarrow-test.$(OBJEXT)
 	$(LINK) yarrow-test.$(OBJEXT) $(TEST_OBJS) -o yarrow-test$(EXEEXT)
 
+xts-test$(EXEEXT): xts-test.$(OBJEXT)
+	$(LINK) xts-test.$(OBJEXT) $(TEST_OBJS) -o xts-test$(EXEEXT)
+
 pbkdf2-test$(EXEEXT): pbkdf2-test.$(OBJEXT)
 	$(LINK) pbkdf2-test.$(OBJEXT) $(TEST_OBJS) -o pbkdf2-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index e2982b66..287c4f75 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -32,7 +32,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
 		    meta-aead-test.c meta-armor-test.c \
-		    buffer-test.c yarrow-test.c pbkdf2-test.c
+		    buffer-test.c yarrow-test.c xts-test.c pbkdf2-test.c
 
 TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
 		     rsa2sexp-test.c sexp2rsa-test.c \
diff --git a/testsuite/xts-test.c b/testsuite/xts-test.c
new file mode 100644
index 00000000..b61c1c99
--- /dev/null
+++ b/testsuite/xts-test.c
@@ -0,0 +1,173 @@
+#include "testutils.h"
+#include "aes.h"
+#include "xts.h"
+#include "nettle-internal.h"
+
+static void
+test_check_data(const char *operation,
+                const uint8_t *input, const uint8_t *output,
+                const uint8_t *expected, size_t length)
+{
+  if (!MEMEQ(length, output, expected))
+    {
+      fprintf(stderr, "XTS %s failed:\nInput:", operation);
+      print_hex(length, input);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, output);
+      fprintf(stderr, "\nExpected:");
+      print_hex(length, expected);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+}
+
+static void
+test_cipher_xts(const struct nettle_cipher *cipher,
+		const struct tstring *key,
+		const struct tstring *tweak,
+		const struct tstring *cleartext,
+		const struct tstring *ciphertext)
+{
+  void *twk_ctx = xalloc(cipher-&gt;context_size);
+  void *ctx = xalloc(cipher-&gt;context_size);
+  uint8_t *data, *data2;
+  size_t length = cleartext-&gt;length;
+
+  ASSERT (cleartext-&gt;length == ciphertext-&gt;length);
+  ASSERT (key-&gt;length == cipher-&gt;key_size * 2);
+  ASSERT (tweak-&gt;length == XTS_BLOCK_SIZE);
+
+  data = xalloc(length);
+  data2 = xalloc(length);
+
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_encrypt_message(ctx, twk_ctx, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data, cleartext-&gt;data);
+  test_check_data("encrypt", cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+  cipher-&gt;set_decrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_decrypt_message(ctx, twk_ctx, cipher-&gt;decrypt, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data2, data);
+  test_check_data("decrypt", data, data2, cleartext-&gt;data, length);
+
+  memcpy(data, cleartext-&gt;data, length);
+
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_encrypt_message(ctx, twk_ctx, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data, data);
+  test_check_data("inplace encrypt",
+                  cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+  cipher-&gt;set_decrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_decrypt_message(ctx, twk_ctx, cipher-&gt;decrypt, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data, data);
+  test_check_data("inplace decrypt", data, data, cleartext-&gt;data, length);
+
+  /* make sure AES128 specific functions also works the same */
+  if (cipher == &amp;nettle_aes128) {
+    struct xts_aes128_ctx ctx;
+
+    xts_aes128_set_encrypt_key(&amp;ctx, key-&gt;data);
+    xts_aes128_encrypt_message(&amp;ctx, tweak-&gt;data, length, data,
+                               cleartext-&gt;data);
+    test_check_data("encrypt",
+                    cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+    xts_aes128_set_decrypt_key(&amp;ctx, key-&gt;data);
+    xts_aes128_decrypt_message(&amp;ctx, tweak-&gt;data, length, data,
+                               ciphertext-&gt;data);
+    test_check_data("decrypt",
+                    ciphertext-&gt;data, data, cleartext-&gt;data, length);
+  }
+
+  /* make sure AES256 specific functions also works the same */
+  if (cipher == &amp;nettle_aes256) {
+    struct xts_aes256_ctx ctx;
+
+    xts_aes256_set_encrypt_key(&amp;ctx, key-&gt;data);
+    xts_aes256_encrypt_message(&amp;ctx, tweak-&gt;data, length, data,
+                               cleartext-&gt;data);
+    test_check_data("encrypt",
+                    cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+    xts_aes256_set_decrypt_key(&amp;ctx, key-&gt;data);
+    xts_aes256_decrypt_message(&amp;ctx, tweak-&gt;data, length, data,
+                               ciphertext-&gt;data);
+    test_check_data("decrypt",
+                    ciphertext-&gt;data, data, cleartext-&gt;data, length);
+  }
+
+  free(twk_ctx);
+  free(ctx);
+  free(data);
+  free(data2);
+}
+
+void
+test_main(void)
+{
+  /* From NIST CAVS 11.0,
+   *
+   * https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Algorithm-Validation-Program/documents/aes/XTSTestVectors.zip
 +   *
+   * Selection of testing vectors from the above CAVS set
+   */
+
+  /* AES-128 single block - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes128,
+		  SHEX("a1b90cba3f06ac353b2c343876081762"
+                       "090923026e91771815f29dab01932f2f"),
+		  SHEX("4faef7117cda59c66e4b92013e768ad5"),
+		  SHEX("ebabce95b14d3c8d6fb350390790311c"),
+		  SHEX("778ae8b43cb98d5a825081d5be471c63"));
+
+  /* AES-128 two blocks - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes128,
+		  SHEX("750372c3d82f63382867be6662acfa4a"
+                       "259be3fa9bc662a1154ffaaed8b448a5"),
+		  SHEX("93a29254c47e4260669621307d4f5cd3"),
+		  SHEX("d8e3a56559a436ce0d8b212c80a88b23"
+                       "af62b0e598f208e03c1f2e9fa563a54b"),
+		  SHEX("495f7855535efd133464dc9a9abf8a0f"
+                       "28facbce21bd3c22178ec489b799e491"));
+
+  /* AES-128 partial second block */
+  test_cipher_xts(&amp;nettle_aes128,
+                  SHEX("394c97881abd989d29c703e48a72b397"
+                       "a7acf51b59649eeea9b33274d8541df4"),
+                  SHEX("4b15c684a152d485fe9937d39b168c29"),
+                  SHEX("2f3b9dcfbae729583b1d1ffdd16bb6fe"
+                       "2757329435662a78f0"),
+                  SHEX("f3473802e38a3ffef4d4fb8e6aa266eb"
+                       "de553a64528a06463e"));
+
+  /* AES-256 two blocks - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes256,
+		  SHEX("1ea661c58d943a0e4801e42f4b094714"
+                       "9e7f9f8e3e68d0c7505210bd311a0e7c"
+                       "d6e13ffdf2418d8d1911c004cda58da3"
+                       "d619b7e2b9141e58318eea392cf41b08"),
+		  SHEX("adf8d92627464ad2f0428e84a9f87564"),
+		  SHEX("2eedea52cd8215e1acc647e810bbc364"
+                       "2e87287f8d2e57e36c0a24fbc12a202e"),
+		  SHEX("cbaad0e2f6cea3f50b37f934d46a9b13"
+                       "0b9d54f07e34f36af793e86f73c6d7db"));
+
+  /* AES-256 three blocks - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes256,
+		  SHEX("266c336b3b01489f3267f52835fd92f6"
+                       "74374b88b4e1ebd2d36a5f457581d9d0"
+                       "42c3eef7b0b7e5137b086496b4d9e6ac"
+                       "658d7196a23f23f036172fdb8faee527"),
+		  SHEX("06b209a7a22f486ecbfadb0f3137ba42"),
+		  SHEX("ca7d65ef8d3dfad345b61ccddca1ad81"
+                       "de830b9e86c7b426d76cb7db766852d9"
+                       "81c6b21409399d78f42cc0b33a7bbb06"),
+		  SHEX("c73256870cc2f4dd57acc74b5456dbd7"
+                       "76912a128bc1f77d72cdebbf270044b7"
+                       "a43ceed29025e1e8be211fa3c3ed002d"));
+}
diff --git a/xts-aes128.c b/xts-aes128.c
new file mode 100644
index 00000000..7c083191
--- /dev/null
+++ b/xts-aes128.c
@@ -0,0 +1,75 @@
+/* xts-aes128.c
+
+   XTS Mode using AES128 as the underlying cipher.
+
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "aes.h"
+#include "xts.h"
+
+
+void
+xts_aes128_set_encrypt_key(struct xts_aes128_ctx *ctx, const uint8_t *key)
+{
+    aes128_set_encrypt_key(&amp;ctx-&gt;cipher, key);
+    aes128_set_encrypt_key(&amp;ctx-&gt;tweak_cipher, &amp;key[AES128_KEY_SIZE]);
+}
+
+void
+xts_aes128_set_decrypt_key(struct xts_aes128_ctx *ctx, const uint8_t *key)
+{
+    aes128_set_decrypt_key(&amp;ctx-&gt;cipher, key);
+    aes128_set_encrypt_key(&amp;ctx-&gt;tweak_cipher, &amp;key[AES128_KEY_SIZE]);
+}
+
+void
+xts_aes128_encrypt_message(struct xts_aes128_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src)
+{
+    xts_encrypt_message(&amp;ctx-&gt;cipher, &amp;ctx-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes128_encrypt,
+                        tweak, length, dst, src);
+}
+
+void
+xts_aes128_decrypt_message(struct xts_aes128_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src)
+{
+    xts_decrypt_message(&amp;ctx-&gt;cipher, &amp;ctx-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes128_decrypt,
+                        (nettle_cipher_func *) aes128_encrypt,
+                        tweak, length, dst, src);
+}
diff --git a/xts-aes256.c b/xts-aes256.c
new file mode 100644
index 00000000..1eb8cc9e
--- /dev/null
+++ b/xts-aes256.c
@@ -0,0 +1,75 @@
+/* xts-aes256.c
+
+   XTS Mode using AES256 as the underlying cipher.
+
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "aes.h"
+#include "xts.h"
+
+
+void
+xts_aes256_set_encrypt_key(struct xts_aes256_ctx *ctx, const uint8_t *key)
+{
+    aes256_set_encrypt_key(&amp;ctx-&gt;cipher, key);
+    aes256_set_encrypt_key(&amp;ctx-&gt;tweak_cipher, &amp;key[AES256_KEY_SIZE]);
+}
+
+void
+xts_aes256_set_decrypt_key(struct xts_aes256_ctx *ctx, const uint8_t *key)
+{
+    aes256_set_decrypt_key(&amp;ctx-&gt;cipher, key);
+    aes256_set_encrypt_key(&amp;ctx-&gt;tweak_cipher, &amp;key[AES256_KEY_SIZE]);
+}
+
+void
+xts_aes256_encrypt_message(struct xts_aes256_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src)
+{
+    xts_encrypt_message(&amp;ctx-&gt;cipher, &amp;ctx-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes256_encrypt,
+                        tweak, length, dst, src);
+}
+
+void
+xts_aes256_decrypt_message(struct xts_aes256_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src)
+{
+    xts_decrypt_message(&amp;ctx-&gt;cipher, &amp;ctx-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes256_decrypt,
+                        (nettle_cipher_func *) aes256_encrypt,
+                        tweak, length, dst, src);
+}
diff --git a/xts.c b/xts.c
new file mode 100644
index 00000000..19e4cfc1
--- /dev/null
+++ b/xts.c
@@ -0,0 +1,205 @@
+/* xts.c
+
+   XEX-based tweaked-codebook mode with ciphertext stealing (XTS)
+
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "xts.h"
+
+#include "macros.h"
+#include "memxor.h"
+#include "nettle-internal.h"
+
+/* shift one and XOR with 0x87. */
+/* src and dest can point to the same buffer for in-place operations */
+static void
+xts_shift(union nettle_block16 *dst,
+          const union nettle_block16 *src)
+{
+  uint8_t carry = src-&gt;b[15] &gt;&gt; 7;
+  uint64_t b0 = LE_READ_UINT64(src-&gt;b);
+  uint64_t b1 = LE_READ_UINT64(src-&gt;b+8);
+  b1 = (b1 &lt;&lt; 1) | (b0 &gt;&gt; 63);
+  b0 = b0 &lt;&lt; 1;
+  LE_WRITE_UINT64(dst-&gt;b, b0);
+  LE_WRITE_UINT64(dst-&gt;b+8, b1);
+  dst-&gt;b[0] ^= 0x87 &amp; -carry;
+}
+
+/*
+ * prev is the block to steal from
+ * curr is the input block to the last step
+ * length is the partial block length
+ * dst is the destination partial block
+ * src is the source partial block
+ *
+ * In the Encryption case:
+ *   prev -&gt; the output of the N-1 encryption step
+ *   curr -&gt; the input to the Nth step (will be encrypted as Cn-1)
+ *   dst  -&gt; the final Cn partial block
+ *   src  -&gt; the final Pn partial block
+ *
+ * In the decryption case:
+ *   prev -&gt; the output of the N-1 decryption step
+ *   curr -&gt; the input to the Nth step (will be decrypted as Pn-1)
+ *   dst  -&gt; the final Pn partial block
+ *   src  -&gt; the final Cn partial block
+ */
+static void
+xts_steal(uint8_t *prev, uint8_t *curr,
+	  size_t length, uint8_t *dst, const uint8_t *src)
+{
+  /* copy the remaining in the current input block */
+  memcpy(curr, src, length);
+  /* fill the current block with the last blocksize - length
+   * bytes of the previous block */
+  memcpy(&amp;curr[length], &amp;prev[length], XTS_BLOCK_SIZE - length);
+
+  /* This must be last or inplace operations will break
+   * copy 'length' bytes of the previous block in the
+   * destination block, which is the final partial block
+   * returned to the caller */
+  memcpy(dst, prev, length);
+}
+
+static void
+check_length(size_t length, uint8_t *dst)
+{
+  assert(length &gt;= XTS_BLOCK_SIZE);
+  /* asserts may be compiled out, try to save the user by zeroing the dst in
+   * case the buffer contains sensitive data (like the clear text for inplace
+   * encryption) */
+  if (length &lt; XTS_BLOCK_SIZE)
+    memxor(dst, dst, length);
+}
+
+/* works also for inplace encryption/decryption */
+
+void
+xts_encrypt_message(const void *enc_ctx, const void *twk_ctx,
+	            nettle_cipher_func *encf,
+	            const uint8_t *tweak, size_t length,
+	            uint8_t *dst, const uint8_t *src)
+{
+  union nettle_block16 T;
+  union nettle_block16 P;
+
+  check_length(length, dst);
+
+  encf(twk_ctx, XTS_BLOCK_SIZE, T.b, tweak);
+
+  /* the zeroth power of alpha is the initial ciphertext value itself, so we
+   * skip shifting and do it at the end of each block operation instead */
+  for (;length &gt;= XTS_BLOCK_SIZE;
+       length -= XTS_BLOCK_SIZE, src += XTS_BLOCK_SIZE, dst += XTS_BLOCK_SIZE)
+    {
+      memcpy(P.b, src, XTS_BLOCK_SIZE);
+      memxor(P.b, T.b, XTS_BLOCK_SIZE);	        /* P -&gt; PP */
+      encf(enc_ctx, XTS_BLOCK_SIZE, dst, P.b);  /* CC */
+      memxor(dst, T.b, XTS_BLOCK_SIZE);	        /* CC -&gt; C */
+
+      /* shift T for next block */
+      xts_shift(&amp;T, &amp;T);
+    }
+
+  /* if the last block is partial, handle via stealing */
+  if (length)
+    {
+      uint8_t *C = dst - XTS_BLOCK_SIZE;
+      /* C points to C(n-1) */
+      xts_steal(C, P.b, length, dst, src);
+      memxor(P.b, T.b, XTS_BLOCK_SIZE);	        /* P -&gt; PP */
+      encf(enc_ctx, XTS_BLOCK_SIZE, C, P.b);    /* CC */
+      memxor(C, T.b, XTS_BLOCK_SIZE);
+    }
+}
+
+void
+xts_decrypt_message(const void *dec_ctx, const void *twk_ctx,
+	            nettle_cipher_func *decf, nettle_cipher_func *encf,
+	            const uint8_t *tweak, size_t length,
+	            uint8_t *dst, const uint8_t *src)
+{
+  union nettle_block16 T;
+  union nettle_block16 C;
+
+  check_length(length, dst);
+
+  encf(twk_ctx, XTS_BLOCK_SIZE, T.b, tweak);
+
+  for (;length &gt;= XTS_BLOCK_SIZE;
+       length -= XTS_BLOCK_SIZE, src += XTS_BLOCK_SIZE, dst += XTS_BLOCK_SIZE)
+    {
+      if (length &gt; XTS_BLOCK_SIZE &amp;&amp; length &lt; 2 * XTS_BLOCK_SIZE)
+        break;                  /* must ciphersteal on last two blocks */
+
+      memcpy(C.b, src, XTS_BLOCK_SIZE);
+      memxor(C.b, T.b, XTS_BLOCK_SIZE);	        /* c -&gt; CC */
+      decf(dec_ctx, XTS_BLOCK_SIZE, dst, C.b);  /* PP */
+      memxor(dst, T.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+
+      xts_shift(&amp;T, &amp;T);
+    }
+
+  /* if the last block is partial, handle via stealing */
+  if (length)
+    {
+      union nettle_block16 T1;
+      uint8_t *P;
+
+      /* we need the last T(n) and save the T(n-1) for later */
+      xts_shift(&amp;T1, &amp;T);
+
+      P = dst;      /* use P(n-1) as temp storage for partial P(n) */
+      memcpy(C.b, src, XTS_BLOCK_SIZE);
+      memxor(C.b, T1.b, XTS_BLOCK_SIZE);	/* C -&gt; CC */
+      decf(dec_ctx, XTS_BLOCK_SIZE, P, C.b);    /* PP */
+      memxor(P, T1.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+
+      /* process next block (Pn-1) */
+      length -= XTS_BLOCK_SIZE;
+      src += XTS_BLOCK_SIZE;
+      dst += XTS_BLOCK_SIZE;
+
+      /* Fill P(n) and prepare C, P still pointing to P(n-1) */
+      xts_steal(P, C.b, length, dst, src);
+      memxor(C.b, T.b, XTS_BLOCK_SIZE);	        /* C -&gt; CC */
+      decf(dec_ctx, XTS_BLOCK_SIZE, P, C.b);    /* PP */
+      memxor(P, T.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+    }
+}
diff --git a/xts.h b/xts.h
new file mode 100644
index 00000000..fe494647
--- /dev/null
+++ b/xts.h
@@ -0,0 +1,117 @@
+/* xts.h
+
+   XEX-based tweaked-codebook mode with ciphertext stealing (XTS)
+
+   Copyright (C) 2005 Niels Möller
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+
+#ifndef NETTLE_XTS_H_INCLUDED
+#define NETTLE_XTS_H_INCLUDED
+
+#include "nettle-types.h"
+#include "aes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define xts_encrypt_message nettle_xts_encrypt_message
+#define xts_decrypt_message nettle_xts_decrypt_message
+#define xts_aes128_set_encrypt_key nettle_xts_aes128_set_encrypt_key
+#define xts_aes128_set_decrypt_key nettle_xts_aes128_set_decrypt_key
+#define xts_aes128_encrypt_message nettle_xts_aes128_encrypt_message
+#define xts_aes128_decrypt_message nettle_xts_aes128_decrypt_message
+#define xts_aes256_set_encrypt_key nettle_xts_aes256_set_encrypt_key
+#define xts_aes256_set_decrypt_key nettle_xts_aes256_set_decrypt_key
+#define xts_aes256_encrypt_message nettle_xts_aes256_encrypt_message
+#define xts_aes256_decrypt_message nettle_xts_aes256_decrypt_message
+
+#define XTS_BLOCK_SIZE 16
+
+void
+xts_encrypt_message(const void *enc_ctx, const void *twk_ctx,
+                nettle_cipher_func *encf,
+                const uint8_t *tweak, size_t length,
+                uint8_t *dst, const uint8_t *src);
+void
+xts_decrypt_message(const void *dec_ctx, const void *twk_ctx,
+                    nettle_cipher_func *decf, nettle_cipher_func *encf,
+                    const uint8_t *tweak, size_t length,
+                    uint8_t *dst, const uint8_t *src);
+
+/* XTS Mode with AES-128 */
+struct xts_aes128_ctx {
+    struct aes128_ctx cipher;
+    struct aes128_ctx tweak_cipher;
+};
+
+void
+xts_aes128_set_encrypt_key(struct xts_aes128_ctx *ctx, const uint8_t *key);
+
+void
+xts_aes128_set_decrypt_key(struct xts_aes128_ctx *ctx, const uint8_t *key);
+
+void
+xts_aes128_encrypt_message(struct xts_aes128_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+xts_aes128_decrypt_message(struct xts_aes128_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src);
+
+/* XTS Mode with AES-256 */
+struct xts_aes256_ctx {
+    struct aes256_ctx cipher;
+    struct aes256_ctx tweak_cipher;
+};
+
+void
+xts_aes256_set_encrypt_key(struct xts_aes256_ctx *ctx, const uint8_t *key);
+
+void
+xts_aes256_set_decrypt_key(struct xts_aes256_ctx *ctx, const uint8_t *key);
+
+void
+xts_aes256_encrypt_message(struct xts_aes256_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+xts_aes256_decrypt_message(struct xts_aes256_ctx *ctx, const uint8_t *tweak,
+                           size_t length, uint8_t *dst, const uint8_t *src);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_XTS_H_INCLUDED */
+
-- 
2.18.1


[Attachment #4 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190316132634</emailId><senderName>"Yuriy M. Kaminskiy"</senderName><senderEmail>yumkam@gmail.com</senderEmail><timestampReceived>2019-03-16 13:26:34-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

On 03/15/19 16:33 , Simo Sorce wrote:
&gt; On Fri, 2019-03-15 at 09:27 -0400, Simo Sorce wrote:
&gt;&gt; &gt; I think this is the same as block_mulx, in cmac.c. (Also same byte
&gt;&gt; &gt; order, right?)
&gt;&gt; 
&gt;&gt; Looks the same indeed, should I share it? Just copy it from cmac?
&gt;&gt; Something else?
&gt;
&gt; Turns out the algorithm is not equivalent, as the shift is applied to
&gt; the array as if it were a big 128bit little endian value, the endianess
&gt; of the two is different.
&gt;
&gt; I changed the implementation to a much simpler form that show the
&gt; difference:
&gt;
&gt; /* shift one and XOR with 0x87. */
&gt; /* src and dest can point to the same buffer for in-place operations */
&gt; static void
&gt; xts_shift(union nettle_block16 *dst,
&gt;           const union nettle_block16 *src)
&gt; {
&gt;   uint8_t carry = src-&gt;b[15] &gt;&gt; 7;
&gt;   dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) | (src-&gt;u64[0] &gt;&gt; 63);
&gt;   dst-&gt;u64[0] = src-&gt;u64[0] &lt;&lt; 1;
&gt;   dst-&gt;b[0] ^= 0x87 &amp; -carry;

Nitpick: mixing different-sized access (esp. writes) to same memory is
problematic for modern cpus (it confuses speculative engine):
  uint64_t carry = src-&gt;u64[1] &gt;&gt; 63;
  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) | (src-&gt;u64[0] &gt;&gt; 63);
  dst-&gt;u64[0] = src-&gt;u64[0] &lt;&lt; 1;
  dst-&gt;u64[0] ^= 0x87 &amp; -carry;

&gt; }
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190316150727</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-03-16 15:07:27-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

On Sat, 2019-03-16 at 16:26 +0300, Yuriy M. Kaminskiy wrote:
&gt; On 03/15/19 16:33 , Simo Sorce wrote:
&gt; &gt; On Fri, 2019-03-15 at 09:27 -0400, Simo Sorce wrote:
&gt; &gt; &gt; &gt; I think this is the same as block_mulx, in cmac.c. (Also same byte
&gt; &gt; &gt; &gt; order, right?)
&gt; &gt; &gt; 
&gt; &gt; &gt; Looks the same indeed, should I share it? Just copy it from cmac?
&gt; &gt; &gt; Something else?
&gt; &gt; 
&gt; &gt; Turns out the algorithm is not equivalent, as the shift is applied to
&gt; &gt; the array as if it were a big 128bit little endian value, the endianess
&gt; &gt; of the two is different.
&gt; &gt; 
&gt; &gt; I changed the implementation to a much simpler form that show the
&gt; &gt; difference:
&gt; &gt; 
&gt; &gt; /* shift one and XOR with 0x87. */
&gt; &gt; /* src and dest can point to the same buffer for in-place operations */
&gt; &gt; static void
&gt; &gt; xts_shift(union nettle_block16 *dst,
&gt; &gt;           const union nettle_block16 *src)
&gt; &gt; {
&gt; &gt;   uint8_t carry = src-&gt;b[15] &gt;&gt; 7;
&gt; &gt;   dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) | (src-&gt;u64[0] &gt;&gt; 63);
&gt; &gt;   dst-&gt;u64[0] = src-&gt;u64[0] &lt;&lt; 1;
&gt; &gt;   dst-&gt;b[0] ^= 0x87 &amp; -carry;
&gt; 
&gt; Nitpick: mixing different-sized access (esp. writes) to same memory is
&gt; problematic for modern cpus (it confuses speculative engine):

In what way does it confuses speculation ?

&gt;   uint64_t carry = src-&gt;u64[1] &gt;&gt; 63;
&gt;   dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) | (src-&gt;u64[0] &gt;&gt; 63);
&gt;   dst-&gt;u64[0] = src-&gt;u64[0] &lt;&lt; 1;
&gt;   dst-&gt;u64[0] ^= 0x87 &amp; -carry;

This is equivalent, but I would like to know what is the exact problem
before changing. Confusing speculation may actually be a feature in
this day and age :-)

Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190319063119</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-03-19 06:31:19-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; New patch attached, the diff has also been applied as an additional commit to my \
&gt; xts_exploded tree in gitlab.

Thanks. Looks pretty good, a few more comments below.

Id din't look so closely at the tests, but it would be good with to test
inplace opertion also with the aes-specific functions.

For performance (which we don't need to focus that much on for the
initial version), one thing to do would be to fill a buffer with
consecutive T_k values, and do the encrypt/decrypt and memxor operations
on several blocks at a time.

&gt; +For a plaintext length that is a perfect multiple of the XTS block size:
&gt; +@example
&gt; +T_1 = E_k2(IV) MUL a^0
&gt; +C_1 = E_k1(P_1 XOR T_1) XOR T_1
&gt; +
&gt; +@dots{}
&gt; +
&gt; +T_n = E_k2(IV) MUL a^(n-1)
&gt; +C_n = E_k1(P_n XOR T_n) XOR T_n
&gt; +@end example

Nit: I'd write the T updates as

 T_1 = E_k2(IV)
 T_k = T_(k-1) MUL a

since this is how to implement it, and no powering operation is needed.

&gt; +The functions @var{encf} @var{decf} are of type
&gt; +
&gt; +@code{void f (void *@var{ctx}, size_t @var{length}, uint8_t *@var{dst},
&gt; +const uint8_t *@var{src})},

It seems the manual doesn't really have an entry for the
nettle_cipher_func type. Maybe it should. Anyway, the type for the first
argument is _const_ void *.

&gt; +/* shift one and XOR with 0x87. */
&gt; +/* src and dest can point to the same buffer for in-place operations */
&gt; +static void
&gt; +xts_shift(union nettle_block16 *dst,
&gt; +          const union nettle_block16 *src)
&gt; +{
&gt; +  uint8_t carry = src-&gt;b[15] &gt;&gt; 7;
&gt; +  uint64_t b0 = LE_READ_UINT64(src-&gt;b);
&gt; +  uint64_t b1 = LE_READ_UINT64(src-&gt;b+8);
&gt; +  b1 = (b1 &lt;&lt; 1) | (b0 &gt;&gt; 63);
&gt; +  b0 = b0 &lt;&lt; 1;
&gt; +  LE_WRITE_UINT64(dst-&gt;b, b0);
&gt; +  LE_WRITE_UINT64(dst-&gt;b+8, b1);
&gt; +  dst-&gt;b[0] ^= 0x87 &amp; -carry;
&gt; +}

Looks right. It can be optimized later on.

&gt; +/*
&gt; + * prev is the block to steal from
&gt; + * curr is the input block to the last step
&gt; + * length is the partial block length
&gt; + * dst is the destination partial block
&gt; + * src is the source partial block
&gt; + *
&gt; + * In the Encryption case:
&gt; + *   prev -&gt; the output of the N-1 encryption step
&gt; + *   curr -&gt; the input to the Nth step (will be encrypted as Cn-1)
&gt; + *   dst  -&gt; the final Cn partial block
&gt; + *   src  -&gt; the final Pn partial block
&gt; + *
&gt; + * In the decryption case:
&gt; + *   prev -&gt; the output of the N-1 decryption step
&gt; + *   curr -&gt; the input to the Nth step (will be decrypted as Pn-1)
&gt; + *   dst  -&gt; the final Pn partial block
&gt; + *   src  -&gt; the final Cn partial block
&gt; + */
&gt; +static void
&gt; +xts_steal(uint8_t *prev, uint8_t *curr,
&gt; +	  size_t length, uint8_t *dst, const uint8_t *src)
&gt; +{
&gt; +  /* copy the remaining in the current input block */
&gt; +  memcpy(curr, src, length);
&gt; +  /* fill the current block with the last blocksize - length
&gt; +   * bytes of the previous block */
&gt; +  memcpy(&amp;curr[length], &amp;prev[length], XTS_BLOCK_SIZE - length);
&gt; +
&gt; +  /* This must be last or inplace operations will break
&gt; +   * copy 'length' bytes of the previous block in the
&gt; +   * destination block, which is the final partial block
&gt; +   * returned to the caller */
&gt; +  memcpy(dst, prev, length);
&gt; +}

This is a bit confusing; first we write to the curr block, using data
from src and prev. And next we copy from prev to dst; is that the
swapping of the last two blocks? Maybe this could be made simpler, and a
copy eliminatedif the main loops were

  for (;length &gt;= 2*XTS_BLOCK_SIZE;

For the arguments, it looks like prev could be const, and curr could be
nettle_block16 (but changing the latter is perhaps a bit pointless,
since we only treat it as a byte array with no obvious benefits from the
alignment).

&gt; +static void
&gt; +check_length(size_t length, uint8_t *dst)
&gt; +{
&gt; +  assert(length &gt;= XTS_BLOCK_SIZE);
&gt; +  /* asserts may be compiled out, try to save the user by zeroing the dst in
&gt; +   * case the buffer contains sensitive data (like the clear text for inplace
&gt; +   * encryption) */
&gt; +  if (length &lt; XTS_BLOCK_SIZE)
&gt; +    memxor(dst, dst, length);
&gt; +}
&gt; +
&gt; +/* works also for inplace encryption/decryption */
&gt; +
&gt; +void
&gt; +xts_encrypt_message(const void *enc_ctx, const void *twk_ctx,
&gt; +	            nettle_cipher_func *encf,
&gt; +	            const uint8_t *tweak, size_t length,
&gt; +	            uint8_t *dst, const uint8_t *src)
&gt; +{
&gt; +  union nettle_block16 T;
&gt; +  union nettle_block16 P;
&gt; +
&gt; +  check_length(length, dst);
&gt; +
&gt; +  encf(twk_ctx, XTS_BLOCK_SIZE, T.b, tweak);
&gt; +
&gt; +  /* the zeroth power of alpha is the initial ciphertext value itself, so we
&gt; +   * skip shifting and do it at the end of each block operation instead */
&gt; +  for (;length &gt;= XTS_BLOCK_SIZE;
&gt; +       length -= XTS_BLOCK_SIZE, src += XTS_BLOCK_SIZE, dst += XTS_BLOCK_SIZE)
&gt; +    {
&gt; +      memcpy(P.b, src, XTS_BLOCK_SIZE);
&gt; +      memxor(P.b, T.b, XTS_BLOCK_SIZE);	        /* P -&gt; PP */

This is what memxor3 is for. (If it's more efficient in this case is not entirely
obvious, though).

&gt; +/* XTS Mode with AES-128 */
&gt; +struct xts_aes128_ctx {
&gt; +    struct aes128_ctx cipher;
&gt; +    struct aes128_ctx tweak_cipher;
&gt; +};

Could consider renaming it to xts_aes128_key, somewhat analogous to
struct eax_key and struct gcm_key. This represents message-independent
data, and then the name xts_aes128_ctx could be used in case we add an
interface with a buffer and incremental encryption and decryption. Not
clear to me if that's likely or not to ever be useful, though.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190319204256</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-03-19 20:42:56-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

Hi Niels,
attached find two patches, comments inline.

On Tue, 2019-03-19 at 07:31 +0100, Niels Möller wrote:
&gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; 
&gt; &gt; New patch attached, the diff has also been applied as an additional commit to my \
&gt; &gt; xts_exploded tree in gitlab.
&gt; 
&gt; Thanks. Looks pretty good, a few more comments below.
&gt; 
&gt; Id din't look so closely at the tests, but it would be good with to test
&gt; inplace opertion also with the aes-specific functions.
&gt; 
&gt; For performance (which we don't need to focus that much on for the
&gt; initial version), one thing to do would be to fill a buffer with
&gt; consecutive T_k values, and do the encrypt/decrypt and memxor operations
&gt; on several blocks at a time.
&gt; 
&gt; &gt; +For a plaintext length that is a perfect multiple of the XTS block size:
&gt; &gt; +@example
&gt; &gt; +T_1 = E_k2(IV) MUL a^0
&gt; &gt; +C_1 = E_k1(P_1 XOR T_1) XOR T_1
&gt; &gt; +
&gt; &gt; +@dots{}
&gt; &gt; +
&gt; &gt; +T_n = E_k2(IV) MUL a^(n-1)
&gt; &gt; +C_n = E_k1(P_n XOR T_n) XOR T_n
&gt; &gt; +@end example
&gt; 
&gt; Nit: I'd write the T updates as
&gt; 
&gt; T_1 = E_k2(IV)
&gt; T_k = T_(k-1) MUL a
&gt; 
&gt; since this is how to implement it, and no powering operation is needed.

Ok changed it.

&gt; &gt; +The functions @var{encf} @var{decf} are of type
&gt; &gt; +
&gt; &gt; +@code{void f (void *@var{ctx}, size_t @var{length}, uint8_t *@var{dst},
&gt; &gt; +const uint8_t *@var{src})},
&gt; 
&gt; It seems the manual doesn't really have an entry for the
&gt; nettle_cipher_func type. Maybe it should. Anyway, the type for the first
&gt; argument is _const_ void *.

Fixed.

&gt; &gt; +/* shift one and XOR with 0x87. */
&gt; &gt; +/* src and dest can point to the same buffer for in-place operations */
&gt; &gt; +static void
&gt; &gt; +xts_shift(union nettle_block16 *dst,
&gt; &gt; +          const union nettle_block16 *src)
&gt; &gt; +{
&gt; &gt; +  uint8_t carry = src-&gt;b[15] &gt;&gt; 7;
&gt; &gt; +  uint64_t b0 = LE_READ_UINT64(src-&gt;b);
&gt; &gt; +  uint64_t b1 = LE_READ_UINT64(src-&gt;b+8);
&gt; &gt; +  b1 = (b1 &lt;&lt; 1) | (b0 &gt;&gt; 63);
&gt; &gt; +  b0 = b0 &lt;&lt; 1;
&gt; &gt; +  LE_WRITE_UINT64(dst-&gt;b, b0);
&gt; &gt; +  LE_WRITE_UINT64(dst-&gt;b+8, b1);
&gt; &gt; +  dst-&gt;b[0] ^= 0x87 &amp; -carry;
&gt; &gt; +}
&gt; 
&gt; Looks right. It can be optimized later on.

Just for curiosity, would it be ok change,
LE_READ_UINT64/LE_WRITE_UINT64 to use uint64_t and have the macro use
__bswap64 if available or fall back to the original unoptimized code ?

(__bswap64 already knows how to use __builtin_bswap64 or falls back to
similar code as in LE_READ_UINT64)

Or do we need a new macro that expects aligned input/output and leave
the existing macro alone, to be used for unaligned input/output ? 

&gt; &gt; +/*
&gt; &gt; + * prev is the block to steal from
&gt; &gt; + * curr is the input block to the last step
&gt; &gt; + * length is the partial block length
&gt; &gt; + * dst is the destination partial block
&gt; &gt; + * src is the source partial block
&gt; &gt; + *
&gt; &gt; + * In the Encryption case:
&gt; &gt; + *   prev -&gt; the output of the N-1 encryption step
&gt; &gt; + *   curr -&gt; the input to the Nth step (will be encrypted as Cn-1)
&gt; &gt; + *   dst  -&gt; the final Cn partial block
&gt; &gt; + *   src  -&gt; the final Pn partial block
&gt; &gt; + *
&gt; &gt; + * In the decryption case:
&gt; &gt; + *   prev -&gt; the output of the N-1 decryption step
&gt; &gt; + *   curr -&gt; the input to the Nth step (will be decrypted as Pn-1)
&gt; &gt; + *   dst  -&gt; the final Pn partial block
&gt; &gt; + *   src  -&gt; the final Cn partial block
&gt; &gt; + */
&gt; &gt; +static void
&gt; &gt; +xts_steal(uint8_t *prev, uint8_t *curr,
&gt; &gt; +	  size_t length, uint8_t *dst, const uint8_t *src)
&gt; &gt; +{
&gt; &gt; +  /* copy the remaining in the current input block */
&gt; &gt; +  memcpy(curr, src, length);
&gt; &gt; +  /* fill the current block with the last blocksize - length
&gt; &gt; +   * bytes of the previous block */
&gt; &gt; +  memcpy(&amp;curr[length], &amp;prev[length], XTS_BLOCK_SIZE - length);
&gt; &gt; +
&gt; &gt; +  /* This must be last or inplace operations will break
&gt; &gt; +   * copy 'length' bytes of the previous block in the
&gt; &gt; +   * destination block, which is the final partial block
&gt; &gt; +   * returned to the caller */
&gt; &gt; +  memcpy(dst, prev, length);
&gt; &gt; +}
&gt; 
&gt; This is a bit confusing; first we write to the curr block, using data
&gt; from src and prev. And next we copy from prev to dst; is that the
&gt; swapping of the last two blocks? Maybe this could be made simpler, and a
&gt; copy eliminatedif the main loops were
&gt; 
&gt; for (;length &gt;= 2*XTS_BLOCK_SIZE;
&gt; 
&gt; For the arguments, it looks like prev could be const, and curr could be
&gt; nettle_block16 (but changing the latter is perhaps a bit pointless,
&gt; since we only treat it as a byte array with no obvious benefits from the
&gt; alignment).

Ok, I took a stab at removing xts_steal completely in the second patch,
let me know what you think, I think I may like it better than my
original code and uses nettle_block16 for temporary storage to avoid a
copy.

&gt; &gt; +static void
&gt; &gt; +check_length(size_t length, uint8_t *dst)
&gt; &gt; +{
&gt; &gt; +  assert(length &gt;= XTS_BLOCK_SIZE);
&gt; &gt; +  /* asserts may be compiled out, try to save the user by zeroing the dst in
&gt; &gt; +   * case the buffer contains sensitive data (like the clear text for inplace
&gt; &gt; +   * encryption) */
&gt; &gt; +  if (length &lt; XTS_BLOCK_SIZE)
&gt; &gt; +    memxor(dst, dst, length);
&gt; &gt; +}
&gt; &gt; +
&gt; &gt; +/* works also for inplace encryption/decryption */
&gt; &gt; +
&gt; &gt; +void
&gt; &gt; +xts_encrypt_message(const void *enc_ctx, const void *twk_ctx,
&gt; &gt; +	            nettle_cipher_func *encf,
&gt; &gt; +	            const uint8_t *tweak, size_t length,
&gt; &gt; +	            uint8_t *dst, const uint8_t *src)
&gt; &gt; +{
&gt; &gt; +  union nettle_block16 T;
&gt; &gt; +  union nettle_block16 P;
&gt; &gt; +
&gt; &gt; +  check_length(length, dst);
&gt; &gt; +
&gt; &gt; +  encf(twk_ctx, XTS_BLOCK_SIZE, T.b, tweak);
&gt; &gt; +
&gt; &gt; +  /* the zeroth power of alpha is the initial ciphertext value itself, so we
&gt; &gt; +   * skip shifting and do it at the end of each block operation instead */
&gt; &gt; +  for (;length &gt;= XTS_BLOCK_SIZE;
&gt; &gt; +       length -= XTS_BLOCK_SIZE, src += XTS_BLOCK_SIZE, dst += XTS_BLOCK_SIZE)
&gt; &gt; +    {
&gt; &gt; +      memcpy(P.b, src, XTS_BLOCK_SIZE);
&gt; &gt; +      memxor(P.b, T.b, XTS_BLOCK_SIZE);	        /* P -&gt; PP */
&gt; 
&gt; This is what memxor3 is for. (If it's more efficient in this case is not entirely
&gt; obvious, though).

I did not know about memxor3, it makes the code better, esp in the
second patch, I think.

&gt; &gt; +/* XTS Mode with AES-128 */
&gt; &gt; +struct xts_aes128_ctx {
&gt; &gt; +    struct aes128_ctx cipher;
&gt; &gt; +    struct aes128_ctx tweak_cipher;
&gt; &gt; +};
&gt; 
&gt; Could consider renaming it to xts_aes128_key, somewhat analogous to
&gt; struct eax_key and struct gcm_key. This represents message-independent
&gt; data, and then the name xts_aes128_ctx could be used in case we add an
&gt; interface with a buffer and incremental encryption and decryption. Not
&gt; clear to me if that's likely or not to ever be useful, though.

I did this, the reasoning makes sense to me.

HTH,
Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


["0001-Add-support-for-XTS-encryption-mode.patch" (0001-Add-support-for-XTS-encryption-mode.patch)]

From b8dfe527eb6f061baa202982c3bc495511a1535e Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Thu, 4 Oct 2018 14:38:50 -0400
Subject: [PATCH 1/2] Add support for XTS encryption mode

XEX encryption mode with tweak and ciphertext stealing (XTS) is
standardized in IEEE 1619 and generally used for storage devices.

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 Makefile.in                |   5 +-
 nettle.texinfo             | 147 ++++++++++++++++++++++++++-
 testsuite/.gitignore       |   1 +
 testsuite/.test-rules.make |   3 +
 testsuite/Makefile.in      |   2 +-
 testsuite/xts-test.c       | 173 +++++++++++++++++++++++++++++++
 xts-aes128.c               |  77 ++++++++++++++
 xts-aes256.c               |  77 ++++++++++++++
 xts.c                      | 202 +++++++++++++++++++++++++++++++++++++
 xts.h                      | 124 +++++++++++++++++++++++
 10 files changed, 806 insertions(+), 5 deletions(-)
 create mode 100644 testsuite/xts-test.c
 create mode 100644 xts-aes128.c
 create mode 100644 xts-aes256.c
 create mode 100644 xts.c
 create mode 100644 xts.h

diff --git a/Makefile.in b/Makefile.in
index 83250cf3..440de9f7 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -135,7 +135,8 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 umac32.c umac64.c umac96.c umac128.c \
 		 version.c \
 		 write-be32.c write-le32.c write-le64.c \
-		 yarrow256.c yarrow_key_event.c
+		 yarrow256.c yarrow_key_event.c \
+		 xts.c xts-aes128.c xts-aes256.c
 
 hogweed_SOURCES = sexp.c sexp-format.c \
 		  sexp-transport.c sexp-transport-format.c \
@@ -206,7 +207,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  pgp.h pkcs1.h pss.h pss-mgf1.h realloc.h ripemd160.h rsa.h \
 	  salsa20.h sexp.h \
 	  serpent.h sha.h sha1.h sha2.h sha3.h twofish.h \
-	  umac.h yarrow.h poly1305.h
+	  umac.h yarrow.h xts.h poly1305.h
 
 INSTALL_HEADERS = $(HEADERS) version.h @IF_MINI_GMP@ mini-gmp.h
 
diff --git a/nettle.texinfo b/nettle.texinfo
index 9806bdc1..e79cb08c 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -2001,7 +2001,8 @@ Book mode, @acronym{ECB}), leaks information.
 
 Besides @acronym{ECB}, Nettle provides several other modes of operation:
 Cipher Block Chaining (@acronym{CBC}), Counter mode (@acronym{CTR}), Cipher
-Feedback (@acronym{CFB} and @acronym{CFB8}) and a couple of @acronym{AEAD}
+Feedback (@acronym{CFB} and @acronym{CFB8}), XEX-based tweaked-codebook mode
+with ciphertext stealing (@acronym{XTS}) and a couple of @acronym{AEAD}
 modes (@pxref{Authenticated encryption}).  @acronym{CBC} is widely used, but
 there are a few subtle issues of information leakage, see, e.g.,
 @uref{http://www.kb.cert.org/vuls/id/958563, @acronym{SSH} @acronym{CBC}
@@ -2016,6 +2017,7 @@ authenticate the message.
 * CBC::                         
 * CTR::                         
 * CFB and CFB8::
+* XTS::
 @end menu
 
 @node CBC, CTR, Cipher modes, Cipher modes
@@ -2187,7 +2189,7 @@ last three arguments define the source and destination area for \
the  operation.
 @end deffn
 
-@node CFB and CFB8, , CTR, Cipher modes
+@node CFB and CFB8, XTS, CTR, Cipher modes
 @comment  node-name,  next,  previous,  up
 @subsection Cipher Feedback mode
 
@@ -2340,6 +2342,147 @@ conventions. The last three arguments define the source and \
destination  area for the operation.
 @end deffn
 
+@node XTS, , CFB and CFB8, Cipher modes
+@comment  node-name,  next,  previous,  up
+@subsection XEX-based tweaked-codebook mode with ciphertext stealing
+
+@cindex XEX-based tweaked-codebook mode with ciphertext stealing
+@cindex XTS Mode
+
+
+XEX-based tweaked-codebook mode with ciphertext stealing (@acronym{XTS}) is
+a block mode like (@acronym{CBC}) but tweaked to be able to encrypt partial
+blocks via a technique called ciphertext stealing, where the last complete
+block of ciphertext is split and part returned as the last block and part
+used as plaintext for the second to last block.
+This mode is principally used to encrypt data at rest where it is not possible
+to store additional metadata or blocks larger than the plain text. The most
+common usage is for disk encryption. Due to the fact that ciphertext expansion
+is not possible, data is not authenticated. This mode should not be used where
+authentication is critical.
+
+The message is divided into @code{n} blocks @code{M_1},@dots{} @code{M_n},
+where @code{M_n} is of size @code{m} which may be smaller than the block size.
+XTS always uses a fixed blocksize of 128 bit (16 bytes) length.
+
+Unlike other modes, the key is double the size of that for the used cipher mode
+(for example 256bit for AES-128 and 512bit for AES-256).
+
+@acronym{XTS} encryption mode operates given:
+@itemize
+@item A multiplication by a primitive element alpha.
+@code{MUL a^j} here represents the multiplication, where @code{j} is the power
+of alpha, and the input value is converted into a 16 bytes array
+@code{a_0[k], k = 0,1,..,15}. The multiplication is calculated as
+@code{a_(j+1)[0] = (2(a_j[0] mod 128)) XOR (135 * floor(a_j[15]/128)}
+@code{a_(j+1)[k] = (2(a_j[k] mod 128)) XOR (floor(a_j[k-1]/128), k = 1,2,..15}
+Note that this operation is practically a 1 bit left shift operation with carry
+propagating from one byte to the next, and if the last bit shift results in a
+carry the decimal value 135 is XORed into the first byte.
+
+@item The encryption key is provided as the @code{Key = K1 | K2}, where @code{|}
+denotes string concatenation.
+@code{E_k1} is the encryption function of the block cipher using @code{K1} as
+the key, and @code{E_k2} is the same encryption function using @code{K2}
+
+@item A 128 bit tweak value is provided as input and is denoted as @code{IV}
+@end itemize
+
+The @code{n} plaintext blocks are transformed into @code{n} ciphertext blocks
+@code{C_1},@dots{} @code{C_n} as follows.
+
+For a plaintext length that is a perfect multiple of the XTS block size:
+@example
+T_1 = E_k2(IV)
+C_1 = E_k1(P_1 XOR T_1) XOR T_1
+
+@dots{}
+
+T_n = T_(n-1) MUL a
+C_n = E_k1(P_n XOR T_n) XOR T_n
+@end example
+
+For any other plaintext lengths:
+@example
+T_1 = E_k2(IV)
+C_1 = E_k1(P_1 XOR T_1) XOR T_1
+
+@dots{}
+
+T_(n-2) = T_(n-3) MUL a
+C_(n-2) = E_k1(P_(n-2) XOR T_(n-2)) XOR T_(n-2)
+
+T_(n-1) = T_(n-2) MUL a
+CC_(n-1) = E_k1(P_(n-1) XOR T_(n-1)) XOR T_(n-1)
+
+T_n = T_(n-1) MUL a
+PP = [1..m]Pn | [m+1..128]CC_(n-1)
+C_(n-1) = E_k1(PP XOR T_n) XOR T_n
+
+C_n = [1..m]CC_(n-1)
+@end example
+
+@subsubsection General (@acronym{XTS}) interface.
+
+The two general functions to encrypt and decrypt using the @acronym{XTS} block
+cipher mode are the following:
+
+@deftypefun void xts_encrypt_message (const void *@var{enc_ctx}, const void \
*@var{twk_ctx}, nettle_cipher_func *@var{encf}, const uint8_t *@var{tweak}, size_t \
@var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +@deftypefunx void \
xts_decrypt_message (const void *@var{dec_ctx}, const void *@var{twk_ctx}, \
nettle_cipher_func *@var{decf}, nettle_cipher_func *@var{encf}, const uint8_t \
*@var{tweak}, size_t @var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +
+Applies the encryption function @var{encf} or the decryption function
+@var{decf} in @acronym{XTS} mode. At least one block (16 bytes) worth
+of data must be available therefore specifying a length less than 16
+bytes is illegal.
+
+The functions @var{encf} @var{decf} are of type
+
+@code{void f (const void *@var{ctx}, size_t @var{length}, uint8_t *@var{dst},
+const uint8_t *@var{src})},
+
+@noindent and the @code{xts_encrypt_message} and @code{xts_decrypt_message}
+functions pass their arguments @var{enc_ctx}, @var{twk_ctx} and @var{dec_ctx}
+to the functions @var{encf}, @var{decf} as @var{ctx}.
+@end deftypefun
+
+@subsubsection @acronym{XTS}-@acronym{AES} interface
+
+The @acronym{AES} @acronym{XTS} functions provide an API for using the
+@acronym{XTS} mode with the @acronym{AES} block ciphers. The parameters
+all have the same meaning as the general interface, except that the
+@var{enc_ctx}, @var{dec_ctx}, @var{twk_ctx}, @var{encf} and @var{decf} are
+replaced with an @acronym{AES} context structure called @var{ctx}, and a
+appropriate set-key function must be called before using any of the encryption
+or decryption functions in this interface.
+
+@deftp {Context struct} {struct xts_aes128_ctx}
+Holds state corresponding to the AES-128 block cipher.
+@end deftp
+
+@deftp {Context struct} {struct xts_aes256_ctx}
+Holds state corresponding to the AES-256 block cipher.
+@end deftp
+
+@deftypefun void xts_aes128_set_encrypt_key (struct xts_aes128_ctx *@var{ctx}, const \
uint8_t *@var{key}) +@deftypefunx void xts_aes256_set_encrypt_key (struct \
xts_aes256_ctx *@var{ctx}, const uint8_t *@var{key}) +@deftypefunx void \
xts_aes128_set_decrypt_key (struct xts_aes128_ctx *@var{ctx}, const uint8_t \
*@var{key}) +@deftypefunx void xts_aes256_set_decrypt_key (struct xts_aes256_ctx \
*@var{ctx}, const uint8_t *@var{key}) +Initializes the encryption or decryption key \
for the AES block cipher. The +lenght of the key must be double the size of the key \
for the corresponding +cipher (256 bits for AES-128 and 512 bits for AES-256). One of
+these functions must be called before any of the other functions.
+@end deftypefun
+
+@deftypefun void xts_aes128_encrypt_message(struct xts_aes128_ctx *@var{ctx}, \
uint8_t *@var{tweak}, size_t @var{length}, uint8_t *@var{dst}, const uint8_t \
*@var{src}) +@deftypefunx void xts_aes256_encrypt_message(struct xts_aes256_ctx \
*@var{ctx}, uint8_t *@var{tweak}, size_t @var{length}, uint8_t *@var{dst}, const \
uint8_t *@var{src}) +@deftypefunx void xts_aes128_decrypt_message(struct \
xts_aes128_ctx *@var{ctx}, uint8_t *@var{tweak}, size_t @var{length}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +@deftypefunx void \
xts_aes256_decrypt_message(struct xts_aes256_ctx *@var{ctx}, uint8_t *@var{tweak}, \
size_t @var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +These are \
identical to @code{xts_encrypt_message} and +@code{xts_decrypt_message}, except that \
@var{enc_ctx}, @var{dec_ctx}, +@var{twk_ctx}, @var{encf} and @var{decf} are replaced \
by the @var{ctx} context +structure.
+@end deftypefun
+
 @node Authenticated encryption, Keyed hash functions, Cipher modes, Reference
 @comment  node-name,  next,  previous,  up
 
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index f98a949a..c3fc5c11 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -95,6 +95,7 @@
 /umac-test
 /version-test
 /yarrow-test
+/xts-test
 
 /test.in
 /test1.out
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index f36a1f7f..6eee6e22 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -166,6 +166,9 @@ buffer-test$(EXEEXT): buffer-test.$(OBJEXT)
 yarrow-test$(EXEEXT): yarrow-test.$(OBJEXT)
 	$(LINK) yarrow-test.$(OBJEXT) $(TEST_OBJS) -o yarrow-test$(EXEEXT)
 
+xts-test$(EXEEXT): xts-test.$(OBJEXT)
+	$(LINK) xts-test.$(OBJEXT) $(TEST_OBJS) -o xts-test$(EXEEXT)
+
 pbkdf2-test$(EXEEXT): pbkdf2-test.$(OBJEXT)
 	$(LINK) pbkdf2-test.$(OBJEXT) $(TEST_OBJS) -o pbkdf2-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index e2982b66..287c4f75 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -32,7 +32,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
 		    meta-aead-test.c meta-armor-test.c \
-		    buffer-test.c yarrow-test.c pbkdf2-test.c
+		    buffer-test.c yarrow-test.c xts-test.c pbkdf2-test.c
 
 TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
 		     rsa2sexp-test.c sexp2rsa-test.c \
diff --git a/testsuite/xts-test.c b/testsuite/xts-test.c
new file mode 100644
index 00000000..723a5a12
--- /dev/null
+++ b/testsuite/xts-test.c
@@ -0,0 +1,173 @@
+#include "testutils.h"
+#include "aes.h"
+#include "xts.h"
+#include "nettle-internal.h"
+
+static void
+test_check_data(const char *operation,
+                const uint8_t *input, const uint8_t *output,
+                const uint8_t *expected, size_t length)
+{
+  if (!MEMEQ(length, output, expected))
+    {
+      fprintf(stderr, "XTS %s failed:\nInput:", operation);
+      print_hex(length, input);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, output);
+      fprintf(stderr, "\nExpected:");
+      print_hex(length, expected);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+}
+
+static void
+test_cipher_xts(const struct nettle_cipher *cipher,
+		const struct tstring *key,
+		const struct tstring *tweak,
+		const struct tstring *cleartext,
+		const struct tstring *ciphertext)
+{
+  void *twk_ctx = xalloc(cipher-&gt;context_size);
+  void *ctx = xalloc(cipher-&gt;context_size);
+  uint8_t *data, *data2;
+  size_t length = cleartext-&gt;length;
+
+  ASSERT (cleartext-&gt;length == ciphertext-&gt;length);
+  ASSERT (key-&gt;length == cipher-&gt;key_size * 2);
+  ASSERT (tweak-&gt;length == XTS_BLOCK_SIZE);
+
+  data = xalloc(length);
+  data2 = xalloc(length);
+
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_encrypt_message(ctx, twk_ctx, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data, cleartext-&gt;data);
+  test_check_data("encrypt", cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+  cipher-&gt;set_decrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_decrypt_message(ctx, twk_ctx, cipher-&gt;decrypt, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data2, data);
+  test_check_data("decrypt", data, data2, cleartext-&gt;data, length);
+
+  memcpy(data, cleartext-&gt;data, length);
+
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_encrypt_message(ctx, twk_ctx, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data, data);
+  test_check_data("inplace encrypt",
+                  cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+  cipher-&gt;set_decrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_decrypt_message(ctx, twk_ctx, cipher-&gt;decrypt, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data, data);
+  test_check_data("inplace decrypt", data, data, cleartext-&gt;data, length);
+
+  /* make sure AES128 specific functions also works the same */
+  if (cipher == &amp;nettle_aes128) {
+    struct xts_aes128_key xts_key;
+
+    xts_aes128_set_encrypt_key(&amp;xts_key, key-&gt;data);
+    xts_aes128_encrypt_message(&amp;xts_key, tweak-&gt;data, length, data,
+                               cleartext-&gt;data);
+    test_check_data("encrypt",
+                    cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+    xts_aes128_set_decrypt_key(&amp;xts_key, key-&gt;data);
+    xts_aes128_decrypt_message(&amp;xts_key, tweak-&gt;data, length, data,
+                               ciphertext-&gt;data);
+    test_check_data("decrypt",
+                    ciphertext-&gt;data, data, cleartext-&gt;data, length);
+  }
+
+  /* make sure AES256 specific functions also works the same */
+  if (cipher == &amp;nettle_aes256) {
+    struct xts_aes256_key xts_key;
+
+    xts_aes256_set_encrypt_key(&amp;xts_key, key-&gt;data);
+    xts_aes256_encrypt_message(&amp;xts_key, tweak-&gt;data, length, data,
+                               cleartext-&gt;data);
+    test_check_data("encrypt",
+                    cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+    xts_aes256_set_decrypt_key(&amp;xts_key, key-&gt;data);
+    xts_aes256_decrypt_message(&amp;xts_key, tweak-&gt;data, length, data,
+                               ciphertext-&gt;data);
+    test_check_data("decrypt",
+                    ciphertext-&gt;data, data, cleartext-&gt;data, length);
+  }
+
+  free(twk_ctx);
+  free(ctx);
+  free(data);
+  free(data2);
+}
+
+void
+test_main(void)
+{
+  /* From NIST CAVS 11.0,
+   *
+   * https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Algorithm-Validation-Program/documents/aes/XTSTestVectors.zip
 +   *
+   * Selection of testing vectors from the above CAVS set
+   */
+
+  /* AES-128 single block - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes128,
+		  SHEX("a1b90cba3f06ac353b2c343876081762"
+                       "090923026e91771815f29dab01932f2f"),
+		  SHEX("4faef7117cda59c66e4b92013e768ad5"),
+		  SHEX("ebabce95b14d3c8d6fb350390790311c"),
+		  SHEX("778ae8b43cb98d5a825081d5be471c63"));
+
+  /* AES-128 two blocks - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes128,
+		  SHEX("750372c3d82f63382867be6662acfa4a"
+                       "259be3fa9bc662a1154ffaaed8b448a5"),
+		  SHEX("93a29254c47e4260669621307d4f5cd3"),
+		  SHEX("d8e3a56559a436ce0d8b212c80a88b23"
+                       "af62b0e598f208e03c1f2e9fa563a54b"),
+		  SHEX("495f7855535efd133464dc9a9abf8a0f"
+                       "28facbce21bd3c22178ec489b799e491"));
+
+  /* AES-128 partial second block */
+  test_cipher_xts(&amp;nettle_aes128,
+                  SHEX("394c97881abd989d29c703e48a72b397"
+                       "a7acf51b59649eeea9b33274d8541df4"),
+                  SHEX("4b15c684a152d485fe9937d39b168c29"),
+                  SHEX("2f3b9dcfbae729583b1d1ffdd16bb6fe"
+                       "2757329435662a78f0"),
+                  SHEX("f3473802e38a3ffef4d4fb8e6aa266eb"
+                       "de553a64528a06463e"));
+
+  /* AES-256 two blocks - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes256,
+		  SHEX("1ea661c58d943a0e4801e42f4b094714"
+                       "9e7f9f8e3e68d0c7505210bd311a0e7c"
+                       "d6e13ffdf2418d8d1911c004cda58da3"
+                       "d619b7e2b9141e58318eea392cf41b08"),
+		  SHEX("adf8d92627464ad2f0428e84a9f87564"),
+		  SHEX("2eedea52cd8215e1acc647e810bbc364"
+                       "2e87287f8d2e57e36c0a24fbc12a202e"),
+		  SHEX("cbaad0e2f6cea3f50b37f934d46a9b13"
+                       "0b9d54f07e34f36af793e86f73c6d7db"));
+
+  /* AES-256 three blocks - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes256,
+		  SHEX("266c336b3b01489f3267f52835fd92f6"
+                       "74374b88b4e1ebd2d36a5f457581d9d0"
+                       "42c3eef7b0b7e5137b086496b4d9e6ac"
+                       "658d7196a23f23f036172fdb8faee527"),
+		  SHEX("06b209a7a22f486ecbfadb0f3137ba42"),
+		  SHEX("ca7d65ef8d3dfad345b61ccddca1ad81"
+                       "de830b9e86c7b426d76cb7db766852d9"
+                       "81c6b21409399d78f42cc0b33a7bbb06"),
+		  SHEX("c73256870cc2f4dd57acc74b5456dbd7"
+                       "76912a128bc1f77d72cdebbf270044b7"
+                       "a43ceed29025e1e8be211fa3c3ed002d"));
+}
diff --git a/xts-aes128.c b/xts-aes128.c
new file mode 100644
index 00000000..5b447bb9
--- /dev/null
+++ b/xts-aes128.c
@@ -0,0 +1,77 @@
+/* xts-aes128.c
+
+   XTS Mode using AES128 as the underlying cipher.
+
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "aes.h"
+#include "xts.h"
+
+
+void
+xts_aes128_set_encrypt_key(struct xts_aes128_key *xts_key, const uint8_t *key)
+{
+    aes128_set_encrypt_key(&amp;xts_key-&gt;cipher, key);
+    aes128_set_encrypt_key(&amp;xts_key-&gt;tweak_cipher, &amp;key[AES128_KEY_SIZE]);
+}
+
+void
+xts_aes128_set_decrypt_key(struct xts_aes128_key *xts_key, const uint8_t *key)
+{
+    aes128_set_decrypt_key(&amp;xts_key-&gt;cipher, key);
+    aes128_set_encrypt_key(&amp;xts_key-&gt;tweak_cipher, &amp;key[AES128_KEY_SIZE]);
+}
+
+void
+xts_aes128_encrypt_message(struct xts_aes128_key *xts_key,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src)
+{
+    xts_encrypt_message(&amp;xts_key-&gt;cipher, &amp;xts_key-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes128_encrypt,
+                        tweak, length, dst, src);
+}
+
+void
+xts_aes128_decrypt_message(struct xts_aes128_key *xts_key,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src)
+{
+    xts_decrypt_message(&amp;xts_key-&gt;cipher, &amp;xts_key-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes128_decrypt,
+                        (nettle_cipher_func *) aes128_encrypt,
+                        tweak, length, dst, src);
+}
diff --git a/xts-aes256.c b/xts-aes256.c
new file mode 100644
index 00000000..2285b8c8
--- /dev/null
+++ b/xts-aes256.c
@@ -0,0 +1,77 @@
+/* xts-aes256.c
+
+   XTS Mode using AES256 as the underlying cipher.
+
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "aes.h"
+#include "xts.h"
+
+
+void
+xts_aes256_set_encrypt_key(struct xts_aes256_key *xts_key, const uint8_t *key)
+{
+    aes256_set_encrypt_key(&amp;xts_key-&gt;cipher, key);
+    aes256_set_encrypt_key(&amp;xts_key-&gt;tweak_cipher, &amp;key[AES256_KEY_SIZE]);
+}
+
+void
+xts_aes256_set_decrypt_key(struct xts_aes256_key *xts_key, const uint8_t *key)
+{
+    aes256_set_decrypt_key(&amp;xts_key-&gt;cipher, key);
+    aes256_set_encrypt_key(&amp;xts_key-&gt;tweak_cipher, &amp;key[AES256_KEY_SIZE]);
+}
+
+void
+xts_aes256_encrypt_message(struct xts_aes256_key *xts_key,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src)
+{
+    xts_encrypt_message(&amp;xts_key-&gt;cipher, &amp;xts_key-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes256_encrypt,
+                        tweak, length, dst, src);
+}
+
+void
+xts_aes256_decrypt_message(struct xts_aes256_key *xts_key,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src)
+{
+    xts_decrypt_message(&amp;xts_key-&gt;cipher, &amp;xts_key-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes256_decrypt,
+                        (nettle_cipher_func *) aes256_encrypt,
+                        tweak, length, dst, src);
+}
diff --git a/xts.c b/xts.c
new file mode 100644
index 00000000..4eeb9d9b
--- /dev/null
+++ b/xts.c
@@ -0,0 +1,202 @@
+/* xts.c
+
+   XEX-based tweaked-codebook mode with ciphertext stealing (XTS)
+
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "xts.h"
+
+#include "macros.h"
+#include "memxor.h"
+#include "nettle-internal.h"
+
+/* shift one and XOR with 0x87. */
+/* src and dest can point to the same buffer for in-place operations */
+static void
+xts_shift(union nettle_block16 *dst,
+          const union nettle_block16 *src)
+{
+  uint8_t carry = src-&gt;b[15] &gt;&gt; 7;
+  uint64_t b0 = LE_READ_UINT64(src-&gt;b);
+  uint64_t b1 = LE_READ_UINT64(src-&gt;b+8);
+  b1 = (b1 &lt;&lt; 1) | (b0 &gt;&gt; 63);
+  b0 = b0 &lt;&lt; 1;
+  LE_WRITE_UINT64(dst-&gt;b, b0);
+  LE_WRITE_UINT64(dst-&gt;b+8, b1);
+  dst-&gt;b[0] ^= 0x87 &amp; -carry;
+}
+
+/*
+ * prev is the block to steal from
+ * curr is the input block to the last step
+ * length is the partial block length
+ * dst is the destination partial block
+ * src is the source partial block
+ *
+ * In the Encryption case:
+ *   prev -&gt; the output of the N-1 encryption step
+ *   curr -&gt; the input to the Nth step (will be encrypted as Cn-1)
+ *   dst  -&gt; the final Cn partial block
+ *   src  -&gt; the final Pn partial block
+ *
+ * In the decryption case:
+ *   prev -&gt; the output of the N-1 decryption step
+ *   curr -&gt; the input to the Nth step (will be decrypted as Pn-1)
+ *   dst  -&gt; the final Pn partial block
+ *   src  -&gt; the final Cn partial block
+ */
+static void
+xts_steal(uint8_t *prev, uint8_t *curr,
+	  size_t length, uint8_t *dst, const uint8_t *src)
+{
+  /* copy the remaining in the current input block */
+  memcpy(curr, src, length);
+  /* fill the current block with the last blocksize - length
+   * bytes of the previous block */
+  memcpy(&amp;curr[length], &amp;prev[length], XTS_BLOCK_SIZE - length);
+
+  /* This must be last or inplace operations will break
+   * copy 'length' bytes of the previous block in the
+   * destination block, which is the final partial block
+   * returned to the caller */
+  memcpy(dst, prev, length);
+}
+
+static void
+check_length(size_t length, uint8_t *dst)
+{
+  assert(length &gt;= XTS_BLOCK_SIZE);
+  /* asserts may be compiled out, try to save the user by zeroing the dst in
+   * case the buffer contains sensitive data (like the clear text for inplace
+   * encryption) */
+  if (length &lt; XTS_BLOCK_SIZE)
+    memxor(dst, dst, length);
+}
+
+/* works also for inplace encryption/decryption */
+
+void
+xts_encrypt_message(const void *enc_ctx, const void *twk_ctx,
+	            nettle_cipher_func *encf,
+	            const uint8_t *tweak, size_t length,
+	            uint8_t *dst, const uint8_t *src)
+{
+  union nettle_block16 T;
+  union nettle_block16 P;
+
+  check_length(length, dst);
+
+  encf(twk_ctx, XTS_BLOCK_SIZE, T.b, tweak);
+
+  /* the zeroth power of alpha is the initial ciphertext value itself, so we
+   * skip shifting and do it at the end of each block operation instead */
+  for (;length &gt;= XTS_BLOCK_SIZE;
+       length -= XTS_BLOCK_SIZE, src += XTS_BLOCK_SIZE, dst += XTS_BLOCK_SIZE)
+    {
+      memxor3(P.b, src, T.b, XTS_BLOCK_SIZE);	/* P -&gt; PP */
+      encf(enc_ctx, XTS_BLOCK_SIZE, dst, P.b);  /* CC */
+      memxor(dst, T.b, XTS_BLOCK_SIZE);	        /* CC -&gt; C */
+
+      /* shift T for next block */
+      xts_shift(&amp;T, &amp;T);
+    }
+
+  /* if the last block is partial, handle via stealing */
+  if (length)
+    {
+      uint8_t *C = dst - XTS_BLOCK_SIZE;
+      /* C points to C(n-1) */
+      xts_steal(C, P.b, length, dst, src);
+      memxor(P.b, T.b, XTS_BLOCK_SIZE);	        /* P -&gt; PP */
+      encf(enc_ctx, XTS_BLOCK_SIZE, C, P.b);    /* CC */
+      memxor(C, T.b, XTS_BLOCK_SIZE);
+    }
+}
+
+void
+xts_decrypt_message(const void *dec_ctx, const void *twk_ctx,
+	            nettle_cipher_func *decf, nettle_cipher_func *encf,
+	            const uint8_t *tweak, size_t length,
+	            uint8_t *dst, const uint8_t *src)
+{
+  union nettle_block16 T;
+  union nettle_block16 C;
+
+  check_length(length, dst);
+
+  encf(twk_ctx, XTS_BLOCK_SIZE, T.b, tweak);
+
+  for (;length &gt;= XTS_BLOCK_SIZE;
+       length -= XTS_BLOCK_SIZE, src += XTS_BLOCK_SIZE, dst += XTS_BLOCK_SIZE)
+    {
+      if (length &gt; XTS_BLOCK_SIZE &amp;&amp; length &lt; 2 * XTS_BLOCK_SIZE)
+        break;                  /* must ciphersteal on last two blocks */
+
+      memxor3(C.b, src, T.b, XTS_BLOCK_SIZE);	/* c -&gt; CC */
+      decf(dec_ctx, XTS_BLOCK_SIZE, dst, C.b);  /* PP */
+      memxor(dst, T.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+
+      xts_shift(&amp;T, &amp;T);
+    }
+
+  /* if the last block is partial, handle via stealing */
+  if (length)
+    {
+      union nettle_block16 T1;
+      uint8_t *P;
+
+      /* we need the last T(n) and save the T(n-1) for later */
+      xts_shift(&amp;T1, &amp;T);
+
+      P = dst;      /* use P(n-1) as temp storage for partial P(n) */
+      memxor3(C.b, src, T1.b, XTS_BLOCK_SIZE);	/* C -&gt; CC */
+      decf(dec_ctx, XTS_BLOCK_SIZE, P, C.b);    /* PP */
+      memxor(P, T1.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+
+      /* process next block (Pn-1) */
+      length -= XTS_BLOCK_SIZE;
+      src += XTS_BLOCK_SIZE;
+      dst += XTS_BLOCK_SIZE;
+
+      /* Fill P(n) and prepare C, P still pointing to P(n-1) */
+      xts_steal(P, C.b, length, dst, src);
+      memxor(C.b, T.b, XTS_BLOCK_SIZE);	        /* C -&gt; CC */
+      decf(dec_ctx, XTS_BLOCK_SIZE, P, C.b);    /* PP */
+      memxor(P, T.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+    }
+}
diff --git a/xts.h b/xts.h
new file mode 100644
index 00000000..a9ea970d
--- /dev/null
+++ b/xts.h
@@ -0,0 +1,124 @@
+/* xts.h
+
+   XEX-based tweaked-codebook mode with ciphertext stealing (XTS)
+
+   Copyright (C) 2005 Niels Möller
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+
+#ifndef NETTLE_XTS_H_INCLUDED
+#define NETTLE_XTS_H_INCLUDED
+
+#include "nettle-types.h"
+#include "aes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define xts_encrypt_message nettle_xts_encrypt_message
+#define xts_decrypt_message nettle_xts_decrypt_message
+#define xts_aes128_set_encrypt_key nettle_xts_aes128_set_encrypt_key
+#define xts_aes128_set_decrypt_key nettle_xts_aes128_set_decrypt_key
+#define xts_aes128_encrypt_message nettle_xts_aes128_encrypt_message
+#define xts_aes128_decrypt_message nettle_xts_aes128_decrypt_message
+#define xts_aes256_set_encrypt_key nettle_xts_aes256_set_encrypt_key
+#define xts_aes256_set_decrypt_key nettle_xts_aes256_set_decrypt_key
+#define xts_aes256_encrypt_message nettle_xts_aes256_encrypt_message
+#define xts_aes256_decrypt_message nettle_xts_aes256_decrypt_message
+
+#define XTS_BLOCK_SIZE 16
+
+void
+xts_encrypt_message(const void *enc_ctx, const void *twk_ctx,
+                nettle_cipher_func *encf,
+                const uint8_t *tweak, size_t length,
+                uint8_t *dst, const uint8_t *src);
+void
+xts_decrypt_message(const void *dec_ctx, const void *twk_ctx,
+                    nettle_cipher_func *decf, nettle_cipher_func *encf,
+                    const uint8_t *tweak, size_t length,
+                    uint8_t *dst, const uint8_t *src);
+
+/* XTS Mode with AES-128 */
+struct xts_aes128_key {
+    struct aes128_ctx cipher;
+    struct aes128_ctx tweak_cipher;
+};
+
+void
+xts_aes128_set_encrypt_key(struct xts_aes128_key *xts_key,
+                           const uint8_t *key);
+
+void
+xts_aes128_set_decrypt_key(struct xts_aes128_key *xts_key,
+                           const uint8_t *key);
+
+void
+xts_aes128_encrypt_message(struct xts_aes128_key *xtskey,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src);
+
+void
+xts_aes128_decrypt_message(struct xts_aes128_key *xts_key,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src);
+
+/* XTS Mode with AES-256 */
+struct xts_aes256_key {
+    struct aes256_ctx cipher;
+    struct aes256_ctx tweak_cipher;
+};
+
+void
+xts_aes256_set_encrypt_key(struct xts_aes256_key *xts_key,
+                           const uint8_t *key);
+
+void
+xts_aes256_set_decrypt_key(struct xts_aes256_key *xts_key,
+                           const uint8_t *key);
+
+void
+xts_aes256_encrypt_message(struct xts_aes256_key *xts_key,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src);
+
+void
+xts_aes256_decrypt_message(struct xts_aes256_key *xts_key,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_XTS_H_INCLUDED */
+
-- 
2.20.1


["0002-Inline-ciphertext-stealing.patch" (0002-Inline-ciphertext-stealing.patch)]

From 1aa0cd00ccc9ede866cb382d43240e054d238d73 Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Tue, 19 Mar 2019 16:30:53 -0400
Subject: [PATCH 2/2] Inline ciphertext stealing

This avoids copying and may be somewhat more readable without the need
for so much explanation.

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 xts.c | 113 ++++++++++++++++++++++++++++------------------------------
 1 file changed, 54 insertions(+), 59 deletions(-)

diff --git a/xts.c b/xts.c
index 4eeb9d9b..7e97ebe2 100644
--- a/xts.c
+++ b/xts.c
@@ -61,42 +61,6 @@ xts_shift(union nettle_block16 *dst,
   dst-&gt;b[0] ^= 0x87 &amp; -carry;
 }
 
-/*
- * prev is the block to steal from
- * curr is the input block to the last step
- * length is the partial block length
- * dst is the destination partial block
- * src is the source partial block
- *
- * In the Encryption case:
- *   prev -&gt; the output of the N-1 encryption step
- *   curr -&gt; the input to the Nth step (will be encrypted as Cn-1)
- *   dst  -&gt; the final Cn partial block
- *   src  -&gt; the final Pn partial block
- *
- * In the decryption case:
- *   prev -&gt; the output of the N-1 decryption step
- *   curr -&gt; the input to the Nth step (will be decrypted as Pn-1)
- *   dst  -&gt; the final Pn partial block
- *   src  -&gt; the final Cn partial block
- */
-static void
-xts_steal(uint8_t *prev, uint8_t *curr,
-	  size_t length, uint8_t *dst, const uint8_t *src)
-{
-  /* copy the remaining in the current input block */
-  memcpy(curr, src, length);
-  /* fill the current block with the last blocksize - length
-   * bytes of the previous block */
-  memcpy(&amp;curr[length], &amp;prev[length], XTS_BLOCK_SIZE - length);
-
-  /* This must be last or inplace operations will break
-   * copy 'length' bytes of the previous block in the
-   * destination block, which is the final partial block
-   * returned to the caller */
-  memcpy(dst, prev, length);
-}
-
 static void
 check_length(size_t length, uint8_t *dst)
 {
@@ -125,7 +89,7 @@ xts_encrypt_message(const void *enc_ctx, const void *twk_ctx,
 
   /* the zeroth power of alpha is the initial ciphertext value itself, so we
    * skip shifting and do it at the end of each block operation instead */
-  for (;length &gt;= XTS_BLOCK_SIZE;
+  for (;length &gt;= 2 * XTS_BLOCK_SIZE;
        length -= XTS_BLOCK_SIZE, src += XTS_BLOCK_SIZE, dst += XTS_BLOCK_SIZE)
     {
       memxor3(P.b, src, T.b, XTS_BLOCK_SIZE);	/* P -&gt; PP */
@@ -137,14 +101,38 @@ xts_encrypt_message(const void *enc_ctx, const void *twk_ctx,
     }
 
   /* if the last block is partial, handle via stealing */
-  if (length)
+  if (length == XTS_BLOCK_SIZE)
+    {
+      memxor3(P.b, src, T.b, XTS_BLOCK_SIZE);	/* P -&gt; PP */
+      encf(enc_ctx, XTS_BLOCK_SIZE, dst, P.b);  /* CC */
+      memxor(dst, T.b, XTS_BLOCK_SIZE);	        /* CC -&gt; C */
+    }
+  else
     {
-      uint8_t *C = dst - XTS_BLOCK_SIZE;
-      /* C points to C(n-1) */
-      xts_steal(C, P.b, length, dst, src);
-      memxor(P.b, T.b, XTS_BLOCK_SIZE);	        /* P -&gt; PP */
-      encf(enc_ctx, XTS_BLOCK_SIZE, C, P.b);    /* CC */
-      memxor(C, T.b, XTS_BLOCK_SIZE);
+      /* S Holds the real C(n-1) (Whole last block to steal from) */
+      union nettle_block16 S;
+
+      memxor3(P.b, src, T.b, XTS_BLOCK_SIZE);	/* P -&gt; PP */
+      encf(enc_ctx, XTS_BLOCK_SIZE, S.b, P.b);  /* CC */
+      memxor(S.b, T.b, XTS_BLOCK_SIZE);	        /* CC -&gt; S */
+
+      /* shift T for next block */
+      xts_shift(&amp;T, &amp;T);
+
+      length -= XTS_BLOCK_SIZE;
+      src += XTS_BLOCK_SIZE;
+
+      memxor3(P.b, src, T.b, length);           /* P |.. */
+      /* steal ciphertext to complete block */
+      memxor3(P.b + length, S.b + length, T.b + length,
+              XTS_BLOCK_SIZE - length);         /* ..| S_2 -&gt; PP */
+
+      encf(enc_ctx, XTS_BLOCK_SIZE, dst, P.b);  /* CC */
+      memxor(dst, T.b, XTS_BLOCK_SIZE);         /* CC -&gt; C(n-1) */
+
+      /* Do this after we read src so inplace operations do not break */
+      dst += XTS_BLOCK_SIZE;
+      memcpy(dst, S.b, length);                 /* S_1 -&gt; C(n) */
     }
 }
 
@@ -161,12 +149,9 @@ xts_decrypt_message(const void *dec_ctx, const void *twk_ctx,
 
   encf(twk_ctx, XTS_BLOCK_SIZE, T.b, tweak);
 
-  for (;length &gt;= XTS_BLOCK_SIZE;
+  for (;length &gt;= 2 * XTS_BLOCK_SIZE;
        length -= XTS_BLOCK_SIZE, src += XTS_BLOCK_SIZE, dst += XTS_BLOCK_SIZE)
     {
-      if (length &gt; XTS_BLOCK_SIZE &amp;&amp; length &lt; 2 * XTS_BLOCK_SIZE)
-        break;                  /* must ciphersteal on last two blocks */
-
       memxor3(C.b, src, T.b, XTS_BLOCK_SIZE);	/* c -&gt; CC */
       decf(dec_ctx, XTS_BLOCK_SIZE, dst, C.b);  /* PP */
       memxor(dst, T.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
@@ -175,28 +160,38 @@ xts_decrypt_message(const void *dec_ctx, const void *twk_ctx,
     }
 
   /* if the last block is partial, handle via stealing */
-  if (length)
+  if (length == XTS_BLOCK_SIZE)
+    {
+      memxor3(C.b, src, T.b, XTS_BLOCK_SIZE);	/* c -&gt; CC */
+      decf(dec_ctx, XTS_BLOCK_SIZE, dst, C.b);  /* PP */
+      memxor(dst, T.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+    }
+  else
     {
       union nettle_block16 T1;
-      uint8_t *P;
+      /* S Holds the real P(n) (with part of stolen ciphertext) */
+      union nettle_block16 S;
 
       /* we need the last T(n) and save the T(n-1) for later */
       xts_shift(&amp;T1, &amp;T);
 
-      P = dst;      /* use P(n-1) as temp storage for partial P(n) */
       memxor3(C.b, src, T1.b, XTS_BLOCK_SIZE);	/* C -&gt; CC */
-      decf(dec_ctx, XTS_BLOCK_SIZE, P, C.b);    /* PP */
-      memxor(P, T1.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+      decf(dec_ctx, XTS_BLOCK_SIZE, S.b, C.b);  /* PP */
+      memxor(S.b, T1.b, XTS_BLOCK_SIZE);	/* PP -&gt; S */
 
       /* process next block (Pn-1) */
       length -= XTS_BLOCK_SIZE;
       src += XTS_BLOCK_SIZE;
-      dst += XTS_BLOCK_SIZE;
 
-      /* Fill P(n) and prepare C, P still pointing to P(n-1) */
-      xts_steal(P, C.b, length, dst, src);
-      memxor(C.b, T.b, XTS_BLOCK_SIZE);	        /* C -&gt; CC */
-      decf(dec_ctx, XTS_BLOCK_SIZE, P, C.b);    /* PP */
-      memxor(P, T.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+      /* Prepare C, P holds the real P(n) */
+      memxor3(C.b, src, T.b, length);	        /* C_1 |.. */
+      memxor3(C.b + length, S.b + length, T.b + length,
+              XTS_BLOCK_SIZE - length);         /* ..| S_2 -&gt; CC */
+      decf(dec_ctx, XTS_BLOCK_SIZE, dst, C.b);  /* PP */
+      memxor(dst, T.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P(n-1) */
+
+      /* Do this after we read src so inplace operations do not break */
+      dst += XTS_BLOCK_SIZE;
+      memcpy(dst, S.b, length);                 /* S_1 -&gt; P(n) */
     }
 }
-- 
2.20.1


[Attachment #5 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190319213632</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-03-19 21:36:32-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; Just for curiosity, would it be ok change,
&gt; LE_READ_UINT64/LE_WRITE_UINT64 to use uint64_t and have the macro use
&gt; __bswap64 if available or fall back to the original unoptimized code ?

I think LE_READ_UINT64 and related macros should be left as is,
and used for unaligned reads and writes.

For xts_shift, there are three cases, and I think they could be handled
like this:

1. Little-endian system:
   Use 64-bit reads and writes, no swaps needed.

2. Big-endian system, __builtin_bswap64 detected (HAVE_BUILTIN_BSWAP64):
   Use 64-bit reads and writes + __builtin_bswap64.

3. Big-endian system, no __builtin_bswap64. Here we can either use the
   current code, with byte accesses only. Or attempt to define byteswap
   without builtins and follow 2. I'd lean towards using the current
   code, unless there's some system where something more complicated is
   known to improve performance.

In case (1) or (2), use 64-bit operations exclusively, also for the
carry logic. And then the macros and #ifdefs should be arranged to make
it not too ugly. E.g., cases (1) and (2) could perhaps be combined, with
a BSWAP64_IF_BE macro or the like. Or a macro like
LE_READ_ALIGNED_UINT64 (with an uint64_t * argument)

Only current use of __builtin_bswap64 is in ctr.c, the ctr_fill16
function.

An older example is in salsa20-core-internal.c, with a LE_SWAP32 macro.
That one could take advantage of __builtin_bswap32, if available. I
don't know if the compiler can recognize the current expression as a
byte swap.

And it probably is more important to optimize xts_shift if/when one also
arranges the code to produces multiple blocks of T_k values at a time
(say, 32 blocks, 512 bytes of stack-allocated temporary storage),
without reading the intermediate values back from memory to registers.
That has been a significant optimization for both ctr mode and cbc
decrypt.

I haven't reviewed the new version of the patch yet, I hope to get to
that in a day or two.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190320051439</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-03-20 05:14:39-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; 3. Big-endian system, no __builtin_bswap64. Here we can either use the
&gt;    current code, with byte accesses only. Or attempt to define byteswap
&gt;    without builtins and follow 2. I'd lean towards using the current
&gt;    code, unless there's some system where something more complicated is
&gt;    known to improve performance.

And another possible trick for big-endian is to do an "opposite-endian"
left shift as

  ((x &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | ((x &amp; 0x8080808080808080) &gt;&gt; 15)
                          where this bit is the carry out ^

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190320055226</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-03-20 05:52:26-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; Ok, I took a stab at removing xts_steal completely in the second patch,
&gt; let me know what you think, I think I may like it better than my
&gt; original code and uses nettle_block16 for temporary storage to avoid a
&gt; copy.

I like the version without xts_steal.

It's slightly annoying to repeat duplicate code for a final complete
block, but no big deal. Alternative ways to do the final block of the
non-stealing case (including the case of exactly one block) are

  for (; length &gt;= 2 * XTS_BLOCK_SIZE || length == XTS_BLOCK_SIZE; ...)
    {
      ...
    }
  if (length &gt; 0) 
    {
       ... steal ...
    }

or (since we require at least one block)

  do {
    ...
    length -= XTS_BLOCK_SIZE;
    if (!length)
      return;
  } while (length &gt;= 2*XTS_BLOCK_SIZE);

Do what you think makes it clearest.

For the tests, have you checked that there's coverage for the special
wraparound? I.e., that tests fail if the line 

  dst-&gt;b[0] ^= 0x87 &amp; -carry;

is changed. Since there are a very small number of test vectors with
more than one block, we could be unlucky and have carry == 0 all the
time when xts_shift is called from the tests...
 
&gt;&gt; &gt; +static void
&gt;&gt; &gt; +check_length(size_t length, uint8_t *dst)
&gt;&gt; &gt; +{
&gt;&gt; &gt; +  assert(length &gt;= XTS_BLOCK_SIZE);
&gt;&gt; &gt; +  /* asserts may be compiled out, try to save the user by zeroing the dst in
&gt;&gt; &gt; +   * case the buffer contains sensitive data (like the clear text for inplace
&gt;&gt; &gt; +   * encryption) */
&gt;&gt; &gt; +  if (length &lt; XTS_BLOCK_SIZE)
&gt;&gt; &gt; +    memxor(dst, dst, length);
&gt;&gt; &gt; +}

Why memxor rather than memset?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190320115637</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-03-20 11:56:37-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

On Tue, 2019-03-19 at 22:36 +0100, Niels Möller wrote:
&gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; 
&gt; &gt; Just for curiosity, would it be ok change,
&gt; &gt; LE_READ_UINT64/LE_WRITE_UINT64 to use uint64_t and have the macro use
&gt; &gt; __bswap64 if available or fall back to the original unoptimized code ?
&gt; 
&gt; I think LE_READ_UINT64 and related macros should be left as is,
&gt; and used for unaligned reads and writes.
&gt; 
&gt; For xts_shift, there are three cases, and I think they could be handled
&gt; like this:
&gt; 
&gt; 1. Little-endian system:
&gt;    Use 64-bit reads and writes, no swaps needed.
&gt; 
&gt; 2. Big-endian system, __builtin_bswap64 detected (HAVE_BUILTIN_BSWAP64):
&gt;    Use 64-bit reads and writes + __builtin_bswap64.
&gt; 
&gt; 3. Big-endian system, no __builtin_bswap64. Here we can either use the
&gt;    current code, with byte accesses only. Or attempt to define byteswap
&gt;    without builtins and follow 2. I'd lean towards using the current
&gt;    code, unless there's some system where something more complicated is
&gt;    known to improve performance.
&gt; 
&gt; In case (1) or (2), use 64-bit operations exclusively, also for the
&gt; carry logic. And then the macros and #ifdefs should be arranged to make
&gt; it not too ugly. E.g., cases (1) and (2) could perhaps be combined, with
&gt; a BSWAP64_IF_BE macro or the like. Or a macro like
&gt; LE_READ_ALIGNED_UINT64 (with an uint64_t * argument)
&gt; 
&gt; Only current use of __builtin_bswap64 is in ctr.c, the ctr_fill16
&gt; function.
&gt; 
&gt; An older example is in salsa20-core-internal.c, with a LE_SWAP32 macro.
&gt; That one could take advantage of __builtin_bswap32, if available. I
&gt; don't know if the compiler can recognize the current expression as a
&gt; byte swap.
&gt; 
&gt; And it probably is more important to optimize xts_shift if/when one also
&gt; arranges the code to produces multiple blocks of T_k values at a time
&gt; (say, 32 blocks, 512 bytes of stack-allocated temporary storage),
&gt; without reading the intermediate values back from memory to registers.
&gt; That has been a significant optimization for both ctr mode and cbc
&gt; decrypt.

So the way I would do this is by using the glibc macros le64toh() and
htole64(), they already handle to do the right thing depending on which
architecture we are on.

If it is ok to make configure if those macros are available
(/usr/include/endian.h) I would use them or provide replacements that
just call into the existing macros. 

&gt; I haven't reviewed the new version of the patch yet, I hope to get to
&gt; that in a day or two.
&gt; 
&gt; Regards,
&gt; /Niels
&gt; 

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190320115959</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-03-20 11:59:59-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

On Wed, 2019-03-20 at 06:14 +0100, Niels Möller wrote:
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt; &gt; 3. Big-endian system, no __builtin_bswap64. Here we can either use the
&gt; &gt;    current code, with byte accesses only. Or attempt to define byteswap
&gt; &gt;    without builtins and follow 2. I'd lean towards using the current
&gt; &gt;    code, unless there's some system where something more complicated is
&gt; &gt;    known to improve performance.
&gt; 
&gt; And another possible trick for big-endian is to do an "opposite-endian"
&gt; left shift as
&gt; 
&gt;   ((x &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | ((x &amp; 0x8080808080808080) &gt;&gt; 15)
&gt;                           where this bit is the carry out ^

This would allow us to avoid copies at the cost of more complicated code.

Which do you prefer? using endian.h where available? Or having two
separate codepaths depending on the endianess of the machine ?

Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190320120231</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-03-20 12:02:31-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

On Wed, 2019-03-20 at 06:52 +0100, Niels Möller wrote:
&gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; 
&gt; &gt; Ok, I took a stab at removing xts_steal completely in the second patch,
&gt; &gt; let me know what you think, I think I may like it better than my
&gt; &gt; original code and uses nettle_block16 for temporary storage to avoid a
&gt; &gt; copy.
&gt; 
&gt; I like the version without xts_steal.
&gt; 
&gt; It's slightly annoying to repeat duplicate code for a final complete
&gt; block, but no big deal. Alternative ways to do the final block of the
&gt; non-stealing case (including the case of exactly one block) are
&gt; 
&gt;   for (; length &gt;= 2 * XTS_BLOCK_SIZE || length == XTS_BLOCK_SIZE; ...)
&gt;     {
&gt;       ...
&gt;     }
&gt;   if (length &gt; 0) 
&gt;     {
&gt;        ... steal ...
&gt;     }
&gt; 
&gt; or (since we require at least one block)
&gt; 
&gt;   do {
&gt;     ...
&gt;     length -= XTS_BLOCK_SIZE;
&gt;     if (!length)
&gt;       return;
&gt;   } while (length &gt;= 2*XTS_BLOCK_SIZE);
&gt; 
&gt; Do what you think makes it clearest.

Makes sense, I'll pick one.

&gt; For the tests, have you checked that there's coverage for the special
&gt; wraparound? I.e., that tests fail if the line 
&gt; 
&gt;   dst-&gt;b[0] ^= 0x87 &amp; -carry;
&gt; 
&gt; is changed. Since there are a very small number of test vectors with
&gt; more than one block, we could be unlucky and have carry == 0 all the
&gt; time when xts_shift is called from the tests...

When I botched my change to xts_shift() I always got errors in tests, I
will double check this is covered once again by simply removing the
instruction.

&gt; 
&gt; &gt; &gt; &gt; +static void
&gt; &gt; &gt; &gt; +check_length(size_t length, uint8_t *dst)
&gt; &gt; &gt; &gt; +{
&gt; &gt; &gt; &gt; +  assert(length &gt;= XTS_BLOCK_SIZE);
&gt; &gt; &gt; &gt; +  /* asserts may be compiled out, try to save the user by zeroing the dst in
&gt; &gt; &gt; &gt; +   * case the buffer contains sensitive data (like the clear text for inplace
&gt; &gt; &gt; &gt; +   * encryption) */
&gt; &gt; &gt; &gt; +  if (length &lt; XTS_BLOCK_SIZE)
&gt; &gt; &gt; &gt; +    memxor(dst, dst, length);
&gt; &gt; &gt; &gt; +}
&gt; 
&gt; Why memxor rather than memset?

Ah, no good reason, I'll switch it.

Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190320133539</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-03-20 13:35:39-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; If it is ok to make configure if those macros are available
&gt; (/usr/include/endian.h) I would use them or provide replacements that
&gt; just call into the existing macros. 

Sure, provided there's a reasonable portable fallback. On non-glibc
systems, I think we should use __builtin_bswap64 when provided by gcc or
its look-alikes.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190320134603</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-03-20 13:46:03-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; On Wed, 2019-03-20 at 06:14 +0100, Niels Möller wrote:
&gt;&gt; And another possible trick for big-endian is to do an "opposite-endian"
&gt;&gt; left shift as
&gt;&gt; 
&gt;&gt;   ((x &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | ((x &amp; 0x8080808080808080) &gt;&gt; 15)
&gt;&gt;                           where this bit is the carry out ^
&gt;
&gt; This would allow us to avoid copies at the cost of more complicated code.
&gt;
&gt; Which do you prefer? using endian.h where available? Or having two
&gt; separate codepaths depending on the endianess of the machine ?

If it matters for performance, use the fastest variant. Using separate
implementations of xts_shift, with #if:s depending on endianness and
compiler support, is fine.

I'd expect the opposite-endian shift to be more efficient when bswap is
particularly slow, and implemented in terms of shifting and masking.

A bit difficult to determine, though. Neither existence of endian.h
macros or __builtin_bswap64 implies that the byte swapping is cheap. Are
there any interesting platforms these days that lack an efficient bswap
instruction? And are big-endian? Does mips have a bswap instruction?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190320162949</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-03-20 16:29:49-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

On Wed, 2019-03-20 at 14:46 +0100, Niels Möller wrote:
&gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt; 
&gt; &gt; On Wed, 2019-03-20 at 06:14 +0100, Niels Möller wrote:
&gt; &gt; &gt; And another possible trick for big-endian is to do an "opposite-endian"
&gt; &gt; &gt; left shift as
&gt; &gt; &gt; 
&gt; &gt; &gt;   ((x &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | ((x &amp; 0x8080808080808080) &gt;&gt; 15)
&gt; &gt; &gt;                           where this bit is the carry out ^
&gt; &gt; 
&gt; &gt; This would allow us to avoid copies at the cost of more complicated code.
&gt; &gt; 
&gt; &gt; Which do you prefer? using endian.h where available? Or having two
&gt; &gt; separate codepaths depending on the endianess of the machine ?
&gt; 
&gt; If it matters for performance, use the fastest variant. Using separate
&gt; implementations of xts_shift, with #if:s depending on endianness and
&gt; compiler support, is fine.
&gt; 
&gt; I'd expect the opposite-endian shift to be more efficient when bswap is
&gt; particularly slow, and implemented in terms of shifting and masking.
&gt; 
&gt; A bit difficult to determine, though. Neither existence of endian.h
&gt; macros or __builtin_bswap64 implies that the byte swapping is cheap. Are
&gt; there any interesting platforms these days that lack an efficient bswap
&gt; instruction? And are big-endian? Does mips have a bswap instruction?

In the end I went with the opposit-endian swapping solution and two
separate implementations for LE and BE.
My reasoning is that the compiler can definitely better optimize the LE
version and the BE version done this way is probably not slower than
using byteswapping even when optimized bswap is available.
The secondary reason is that I feel this version is more readable.

I am attaching all 3 patches anew as I also fixed the other issues you
mentioned in a previous email.
Namely improved the non-stealing case for encryption/decryption by
removing the duplicate last block handling, and changed the memclearing
memxor with a memset.

HTH,
Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


["0001-Add-support-for-XTS-encryption-mode.patch" (0001-Add-support-for-XTS-encryption-mode.patch)]

From cd6960b2bc8f380ad2784d0f45969382aa178298 Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Thu, 4 Oct 2018 14:38:50 -0400
Subject: [PATCH 1/3] Add support for XTS encryption mode

XEX encryption mode with tweak and ciphertext stealing (XTS) is
standardized in IEEE 1619 and generally used for storage devices.

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 Makefile.in                |   5 +-
 nettle.texinfo             | 147 ++++++++++++++++++++++++++-
 testsuite/.gitignore       |   1 +
 testsuite/.test-rules.make |   3 +
 testsuite/Makefile.in      |   2 +-
 testsuite/xts-test.c       | 173 +++++++++++++++++++++++++++++++
 xts-aes128.c               |  77 ++++++++++++++
 xts-aes256.c               |  77 ++++++++++++++
 xts.c                      | 202 +++++++++++++++++++++++++++++++++++++
 xts.h                      | 124 +++++++++++++++++++++++
 10 files changed, 806 insertions(+), 5 deletions(-)
 create mode 100644 testsuite/xts-test.c
 create mode 100644 xts-aes128.c
 create mode 100644 xts-aes256.c
 create mode 100644 xts.c
 create mode 100644 xts.h

diff --git a/Makefile.in b/Makefile.in
index 83250cf3..440de9f7 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -135,7 +135,8 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 umac32.c umac64.c umac96.c umac128.c \
 		 version.c \
 		 write-be32.c write-le32.c write-le64.c \
-		 yarrow256.c yarrow_key_event.c
+		 yarrow256.c yarrow_key_event.c \
+		 xts.c xts-aes128.c xts-aes256.c
 
 hogweed_SOURCES = sexp.c sexp-format.c \
 		  sexp-transport.c sexp-transport-format.c \
@@ -206,7 +207,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  pgp.h pkcs1.h pss.h pss-mgf1.h realloc.h ripemd160.h rsa.h \
 	  salsa20.h sexp.h \
 	  serpent.h sha.h sha1.h sha2.h sha3.h twofish.h \
-	  umac.h yarrow.h poly1305.h
+	  umac.h yarrow.h xts.h poly1305.h
 
 INSTALL_HEADERS = $(HEADERS) version.h @IF_MINI_GMP@ mini-gmp.h
 
diff --git a/nettle.texinfo b/nettle.texinfo
index 9806bdc1..e79cb08c 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -2001,7 +2001,8 @@ Book mode, @acronym{ECB}), leaks information.
 
 Besides @acronym{ECB}, Nettle provides several other modes of operation:
 Cipher Block Chaining (@acronym{CBC}), Counter mode (@acronym{CTR}), Cipher
-Feedback (@acronym{CFB} and @acronym{CFB8}) and a couple of @acronym{AEAD}
+Feedback (@acronym{CFB} and @acronym{CFB8}), XEX-based tweaked-codebook mode
+with ciphertext stealing (@acronym{XTS}) and a couple of @acronym{AEAD}
 modes (@pxref{Authenticated encryption}).  @acronym{CBC} is widely used, but
 there are a few subtle issues of information leakage, see, e.g.,
 @uref{http://www.kb.cert.org/vuls/id/958563, @acronym{SSH} @acronym{CBC}
@@ -2016,6 +2017,7 @@ authenticate the message.
 * CBC::                         
 * CTR::                         
 * CFB and CFB8::
+* XTS::
 @end menu
 
 @node CBC, CTR, Cipher modes, Cipher modes
@@ -2187,7 +2189,7 @@ last three arguments define the source and destination area for \
the  operation.
 @end deffn
 
-@node CFB and CFB8, , CTR, Cipher modes
+@node CFB and CFB8, XTS, CTR, Cipher modes
 @comment  node-name,  next,  previous,  up
 @subsection Cipher Feedback mode
 
@@ -2340,6 +2342,147 @@ conventions. The last three arguments define the source and \
destination  area for the operation.
 @end deffn
 
+@node XTS, , CFB and CFB8, Cipher modes
+@comment  node-name,  next,  previous,  up
+@subsection XEX-based tweaked-codebook mode with ciphertext stealing
+
+@cindex XEX-based tweaked-codebook mode with ciphertext stealing
+@cindex XTS Mode
+
+
+XEX-based tweaked-codebook mode with ciphertext stealing (@acronym{XTS}) is
+a block mode like (@acronym{CBC}) but tweaked to be able to encrypt partial
+blocks via a technique called ciphertext stealing, where the last complete
+block of ciphertext is split and part returned as the last block and part
+used as plaintext for the second to last block.
+This mode is principally used to encrypt data at rest where it is not possible
+to store additional metadata or blocks larger than the plain text. The most
+common usage is for disk encryption. Due to the fact that ciphertext expansion
+is not possible, data is not authenticated. This mode should not be used where
+authentication is critical.
+
+The message is divided into @code{n} blocks @code{M_1},@dots{} @code{M_n},
+where @code{M_n} is of size @code{m} which may be smaller than the block size.
+XTS always uses a fixed blocksize of 128 bit (16 bytes) length.
+
+Unlike other modes, the key is double the size of that for the used cipher mode
+(for example 256bit for AES-128 and 512bit for AES-256).
+
+@acronym{XTS} encryption mode operates given:
+@itemize
+@item A multiplication by a primitive element alpha.
+@code{MUL a^j} here represents the multiplication, where @code{j} is the power
+of alpha, and the input value is converted into a 16 bytes array
+@code{a_0[k], k = 0,1,..,15}. The multiplication is calculated as
+@code{a_(j+1)[0] = (2(a_j[0] mod 128)) XOR (135 * floor(a_j[15]/128)}
+@code{a_(j+1)[k] = (2(a_j[k] mod 128)) XOR (floor(a_j[k-1]/128), k = 1,2,..15}
+Note that this operation is practically a 1 bit left shift operation with carry
+propagating from one byte to the next, and if the last bit shift results in a
+carry the decimal value 135 is XORed into the first byte.
+
+@item The encryption key is provided as the @code{Key = K1 | K2}, where @code{|}
+denotes string concatenation.
+@code{E_k1} is the encryption function of the block cipher using @code{K1} as
+the key, and @code{E_k2} is the same encryption function using @code{K2}
+
+@item A 128 bit tweak value is provided as input and is denoted as @code{IV}
+@end itemize
+
+The @code{n} plaintext blocks are transformed into @code{n} ciphertext blocks
+@code{C_1},@dots{} @code{C_n} as follows.
+
+For a plaintext length that is a perfect multiple of the XTS block size:
+@example
+T_1 = E_k2(IV)
+C_1 = E_k1(P_1 XOR T_1) XOR T_1
+
+@dots{}
+
+T_n = T_(n-1) MUL a
+C_n = E_k1(P_n XOR T_n) XOR T_n
+@end example
+
+For any other plaintext lengths:
+@example
+T_1 = E_k2(IV)
+C_1 = E_k1(P_1 XOR T_1) XOR T_1
+
+@dots{}
+
+T_(n-2) = T_(n-3) MUL a
+C_(n-2) = E_k1(P_(n-2) XOR T_(n-2)) XOR T_(n-2)
+
+T_(n-1) = T_(n-2) MUL a
+CC_(n-1) = E_k1(P_(n-1) XOR T_(n-1)) XOR T_(n-1)
+
+T_n = T_(n-1) MUL a
+PP = [1..m]Pn | [m+1..128]CC_(n-1)
+C_(n-1) = E_k1(PP XOR T_n) XOR T_n
+
+C_n = [1..m]CC_(n-1)
+@end example
+
+@subsubsection General (@acronym{XTS}) interface.
+
+The two general functions to encrypt and decrypt using the @acronym{XTS} block
+cipher mode are the following:
+
+@deftypefun void xts_encrypt_message (const void *@var{enc_ctx}, const void \
*@var{twk_ctx}, nettle_cipher_func *@var{encf}, const uint8_t *@var{tweak}, size_t \
@var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +@deftypefunx void \
xts_decrypt_message (const void *@var{dec_ctx}, const void *@var{twk_ctx}, \
nettle_cipher_func *@var{decf}, nettle_cipher_func *@var{encf}, const uint8_t \
*@var{tweak}, size_t @var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +
+Applies the encryption function @var{encf} or the decryption function
+@var{decf} in @acronym{XTS} mode. At least one block (16 bytes) worth
+of data must be available therefore specifying a length less than 16
+bytes is illegal.
+
+The functions @var{encf} @var{decf} are of type
+
+@code{void f (const void *@var{ctx}, size_t @var{length}, uint8_t *@var{dst},
+const uint8_t *@var{src})},
+
+@noindent and the @code{xts_encrypt_message} and @code{xts_decrypt_message}
+functions pass their arguments @var{enc_ctx}, @var{twk_ctx} and @var{dec_ctx}
+to the functions @var{encf}, @var{decf} as @var{ctx}.
+@end deftypefun
+
+@subsubsection @acronym{XTS}-@acronym{AES} interface
+
+The @acronym{AES} @acronym{XTS} functions provide an API for using the
+@acronym{XTS} mode with the @acronym{AES} block ciphers. The parameters
+all have the same meaning as the general interface, except that the
+@var{enc_ctx}, @var{dec_ctx}, @var{twk_ctx}, @var{encf} and @var{decf} are
+replaced with an @acronym{AES} context structure called @var{ctx}, and a
+appropriate set-key function must be called before using any of the encryption
+or decryption functions in this interface.
+
+@deftp {Context struct} {struct xts_aes128_ctx}
+Holds state corresponding to the AES-128 block cipher.
+@end deftp
+
+@deftp {Context struct} {struct xts_aes256_ctx}
+Holds state corresponding to the AES-256 block cipher.
+@end deftp
+
+@deftypefun void xts_aes128_set_encrypt_key (struct xts_aes128_ctx *@var{ctx}, const \
uint8_t *@var{key}) +@deftypefunx void xts_aes256_set_encrypt_key (struct \
xts_aes256_ctx *@var{ctx}, const uint8_t *@var{key}) +@deftypefunx void \
xts_aes128_set_decrypt_key (struct xts_aes128_ctx *@var{ctx}, const uint8_t \
*@var{key}) +@deftypefunx void xts_aes256_set_decrypt_key (struct xts_aes256_ctx \
*@var{ctx}, const uint8_t *@var{key}) +Initializes the encryption or decryption key \
for the AES block cipher. The +lenght of the key must be double the size of the key \
for the corresponding +cipher (256 bits for AES-128 and 512 bits for AES-256). One of
+these functions must be called before any of the other functions.
+@end deftypefun
+
+@deftypefun void xts_aes128_encrypt_message(struct xts_aes128_ctx *@var{ctx}, \
uint8_t *@var{tweak}, size_t @var{length}, uint8_t *@var{dst}, const uint8_t \
*@var{src}) +@deftypefunx void xts_aes256_encrypt_message(struct xts_aes256_ctx \
*@var{ctx}, uint8_t *@var{tweak}, size_t @var{length}, uint8_t *@var{dst}, const \
uint8_t *@var{src}) +@deftypefunx void xts_aes128_decrypt_message(struct \
xts_aes128_ctx *@var{ctx}, uint8_t *@var{tweak}, size_t @var{length}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +@deftypefunx void \
xts_aes256_decrypt_message(struct xts_aes256_ctx *@var{ctx}, uint8_t *@var{tweak}, \
size_t @var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +These are \
identical to @code{xts_encrypt_message} and +@code{xts_decrypt_message}, except that \
@var{enc_ctx}, @var{dec_ctx}, +@var{twk_ctx}, @var{encf} and @var{decf} are replaced \
by the @var{ctx} context +structure.
+@end deftypefun
+
 @node Authenticated encryption, Keyed hash functions, Cipher modes, Reference
 @comment  node-name,  next,  previous,  up
 
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index f98a949a..c3fc5c11 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -95,6 +95,7 @@
 /umac-test
 /version-test
 /yarrow-test
+/xts-test
 
 /test.in
 /test1.out
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index f36a1f7f..6eee6e22 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -166,6 +166,9 @@ buffer-test$(EXEEXT): buffer-test.$(OBJEXT)
 yarrow-test$(EXEEXT): yarrow-test.$(OBJEXT)
 	$(LINK) yarrow-test.$(OBJEXT) $(TEST_OBJS) -o yarrow-test$(EXEEXT)
 
+xts-test$(EXEEXT): xts-test.$(OBJEXT)
+	$(LINK) xts-test.$(OBJEXT) $(TEST_OBJS) -o xts-test$(EXEEXT)
+
 pbkdf2-test$(EXEEXT): pbkdf2-test.$(OBJEXT)
 	$(LINK) pbkdf2-test.$(OBJEXT) $(TEST_OBJS) -o pbkdf2-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index e2982b66..287c4f75 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -32,7 +32,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c\
 		    meta-aead-test.c meta-armor-test.c \
-		    buffer-test.c yarrow-test.c pbkdf2-test.c
+		    buffer-test.c yarrow-test.c xts-test.c pbkdf2-test.c
 
 TS_HOGWEED_SOURCES = sexp-test.c sexp-format-test.c \
 		     rsa2sexp-test.c sexp2rsa-test.c \
diff --git a/testsuite/xts-test.c b/testsuite/xts-test.c
new file mode 100644
index 00000000..723a5a12
--- /dev/null
+++ b/testsuite/xts-test.c
@@ -0,0 +1,173 @@
+#include "testutils.h"
+#include "aes.h"
+#include "xts.h"
+#include "nettle-internal.h"
+
+static void
+test_check_data(const char *operation,
+                const uint8_t *input, const uint8_t *output,
+                const uint8_t *expected, size_t length)
+{
+  if (!MEMEQ(length, output, expected))
+    {
+      fprintf(stderr, "XTS %s failed:\nInput:", operation);
+      print_hex(length, input);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, output);
+      fprintf(stderr, "\nExpected:");
+      print_hex(length, expected);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+}
+
+static void
+test_cipher_xts(const struct nettle_cipher *cipher,
+		const struct tstring *key,
+		const struct tstring *tweak,
+		const struct tstring *cleartext,
+		const struct tstring *ciphertext)
+{
+  void *twk_ctx = xalloc(cipher-&gt;context_size);
+  void *ctx = xalloc(cipher-&gt;context_size);
+  uint8_t *data, *data2;
+  size_t length = cleartext-&gt;length;
+
+  ASSERT (cleartext-&gt;length == ciphertext-&gt;length);
+  ASSERT (key-&gt;length == cipher-&gt;key_size * 2);
+  ASSERT (tweak-&gt;length == XTS_BLOCK_SIZE);
+
+  data = xalloc(length);
+  data2 = xalloc(length);
+
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_encrypt_message(ctx, twk_ctx, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data, cleartext-&gt;data);
+  test_check_data("encrypt", cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+  cipher-&gt;set_decrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_decrypt_message(ctx, twk_ctx, cipher-&gt;decrypt, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data2, data);
+  test_check_data("decrypt", data, data2, cleartext-&gt;data, length);
+
+  memcpy(data, cleartext-&gt;data, length);
+
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_encrypt_message(ctx, twk_ctx, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data, data);
+  test_check_data("inplace encrypt",
+                  cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+  cipher-&gt;set_decrypt_key(ctx, key-&gt;data);
+  cipher-&gt;set_encrypt_key(twk_ctx, &amp;key-&gt;data[key-&gt;length / 2]);
+  xts_decrypt_message(ctx, twk_ctx, cipher-&gt;decrypt, cipher-&gt;encrypt,
+                      tweak-&gt;data, length, data, data);
+  test_check_data("inplace decrypt", data, data, cleartext-&gt;data, length);
+
+  /* make sure AES128 specific functions also works the same */
+  if (cipher == &amp;nettle_aes128) {
+    struct xts_aes128_key xts_key;
+
+    xts_aes128_set_encrypt_key(&amp;xts_key, key-&gt;data);
+    xts_aes128_encrypt_message(&amp;xts_key, tweak-&gt;data, length, data,
+                               cleartext-&gt;data);
+    test_check_data("encrypt",
+                    cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+    xts_aes128_set_decrypt_key(&amp;xts_key, key-&gt;data);
+    xts_aes128_decrypt_message(&amp;xts_key, tweak-&gt;data, length, data,
+                               ciphertext-&gt;data);
+    test_check_data("decrypt",
+                    ciphertext-&gt;data, data, cleartext-&gt;data, length);
+  }
+
+  /* make sure AES256 specific functions also works the same */
+  if (cipher == &amp;nettle_aes256) {
+    struct xts_aes256_key xts_key;
+
+    xts_aes256_set_encrypt_key(&amp;xts_key, key-&gt;data);
+    xts_aes256_encrypt_message(&amp;xts_key, tweak-&gt;data, length, data,
+                               cleartext-&gt;data);
+    test_check_data("encrypt",
+                    cleartext-&gt;data, data, ciphertext-&gt;data, length);
+
+    xts_aes256_set_decrypt_key(&amp;xts_key, key-&gt;data);
+    xts_aes256_decrypt_message(&amp;xts_key, tweak-&gt;data, length, data,
+                               ciphertext-&gt;data);
+    test_check_data("decrypt",
+                    ciphertext-&gt;data, data, cleartext-&gt;data, length);
+  }
+
+  free(twk_ctx);
+  free(ctx);
+  free(data);
+  free(data2);
+}
+
+void
+test_main(void)
+{
+  /* From NIST CAVS 11.0,
+   *
+   * https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Algorithm-Validation-Program/documents/aes/XTSTestVectors.zip
 +   *
+   * Selection of testing vectors from the above CAVS set
+   */
+
+  /* AES-128 single block - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes128,
+		  SHEX("a1b90cba3f06ac353b2c343876081762"
+                       "090923026e91771815f29dab01932f2f"),
+		  SHEX("4faef7117cda59c66e4b92013e768ad5"),
+		  SHEX("ebabce95b14d3c8d6fb350390790311c"),
+		  SHEX("778ae8b43cb98d5a825081d5be471c63"));
+
+  /* AES-128 two blocks - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes128,
+		  SHEX("750372c3d82f63382867be6662acfa4a"
+                       "259be3fa9bc662a1154ffaaed8b448a5"),
+		  SHEX("93a29254c47e4260669621307d4f5cd3"),
+		  SHEX("d8e3a56559a436ce0d8b212c80a88b23"
+                       "af62b0e598f208e03c1f2e9fa563a54b"),
+		  SHEX("495f7855535efd133464dc9a9abf8a0f"
+                       "28facbce21bd3c22178ec489b799e491"));
+
+  /* AES-128 partial second block */
+  test_cipher_xts(&amp;nettle_aes128,
+                  SHEX("394c97881abd989d29c703e48a72b397"
+                       "a7acf51b59649eeea9b33274d8541df4"),
+                  SHEX("4b15c684a152d485fe9937d39b168c29"),
+                  SHEX("2f3b9dcfbae729583b1d1ffdd16bb6fe"
+                       "2757329435662a78f0"),
+                  SHEX("f3473802e38a3ffef4d4fb8e6aa266eb"
+                       "de553a64528a06463e"));
+
+  /* AES-256 two blocks - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes256,
+		  SHEX("1ea661c58d943a0e4801e42f4b094714"
+                       "9e7f9f8e3e68d0c7505210bd311a0e7c"
+                       "d6e13ffdf2418d8d1911c004cda58da3"
+                       "d619b7e2b9141e58318eea392cf41b08"),
+		  SHEX("adf8d92627464ad2f0428e84a9f87564"),
+		  SHEX("2eedea52cd8215e1acc647e810bbc364"
+                       "2e87287f8d2e57e36c0a24fbc12a202e"),
+		  SHEX("cbaad0e2f6cea3f50b37f934d46a9b13"
+                       "0b9d54f07e34f36af793e86f73c6d7db"));
+
+  /* AES-256 three blocks - exact block size multiple */
+  test_cipher_xts(&amp;nettle_aes256,
+		  SHEX("266c336b3b01489f3267f52835fd92f6"
+                       "74374b88b4e1ebd2d36a5f457581d9d0"
+                       "42c3eef7b0b7e5137b086496b4d9e6ac"
+                       "658d7196a23f23f036172fdb8faee527"),
+		  SHEX("06b209a7a22f486ecbfadb0f3137ba42"),
+		  SHEX("ca7d65ef8d3dfad345b61ccddca1ad81"
+                       "de830b9e86c7b426d76cb7db766852d9"
+                       "81c6b21409399d78f42cc0b33a7bbb06"),
+		  SHEX("c73256870cc2f4dd57acc74b5456dbd7"
+                       "76912a128bc1f77d72cdebbf270044b7"
+                       "a43ceed29025e1e8be211fa3c3ed002d"));
+}
diff --git a/xts-aes128.c b/xts-aes128.c
new file mode 100644
index 00000000..5b447bb9
--- /dev/null
+++ b/xts-aes128.c
@@ -0,0 +1,77 @@
+/* xts-aes128.c
+
+   XTS Mode using AES128 as the underlying cipher.
+
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "aes.h"
+#include "xts.h"
+
+
+void
+xts_aes128_set_encrypt_key(struct xts_aes128_key *xts_key, const uint8_t *key)
+{
+    aes128_set_encrypt_key(&amp;xts_key-&gt;cipher, key);
+    aes128_set_encrypt_key(&amp;xts_key-&gt;tweak_cipher, &amp;key[AES128_KEY_SIZE]);
+}
+
+void
+xts_aes128_set_decrypt_key(struct xts_aes128_key *xts_key, const uint8_t *key)
+{
+    aes128_set_decrypt_key(&amp;xts_key-&gt;cipher, key);
+    aes128_set_encrypt_key(&amp;xts_key-&gt;tweak_cipher, &amp;key[AES128_KEY_SIZE]);
+}
+
+void
+xts_aes128_encrypt_message(struct xts_aes128_key *xts_key,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src)
+{
+    xts_encrypt_message(&amp;xts_key-&gt;cipher, &amp;xts_key-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes128_encrypt,
+                        tweak, length, dst, src);
+}
+
+void
+xts_aes128_decrypt_message(struct xts_aes128_key *xts_key,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src)
+{
+    xts_decrypt_message(&amp;xts_key-&gt;cipher, &amp;xts_key-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes128_decrypt,
+                        (nettle_cipher_func *) aes128_encrypt,
+                        tweak, length, dst, src);
+}
diff --git a/xts-aes256.c b/xts-aes256.c
new file mode 100644
index 00000000..2285b8c8
--- /dev/null
+++ b/xts-aes256.c
@@ -0,0 +1,77 @@
+/* xts-aes256.c
+
+   XTS Mode using AES256 as the underlying cipher.
+
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "aes.h"
+#include "xts.h"
+
+
+void
+xts_aes256_set_encrypt_key(struct xts_aes256_key *xts_key, const uint8_t *key)
+{
+    aes256_set_encrypt_key(&amp;xts_key-&gt;cipher, key);
+    aes256_set_encrypt_key(&amp;xts_key-&gt;tweak_cipher, &amp;key[AES256_KEY_SIZE]);
+}
+
+void
+xts_aes256_set_decrypt_key(struct xts_aes256_key *xts_key, const uint8_t *key)
+{
+    aes256_set_decrypt_key(&amp;xts_key-&gt;cipher, key);
+    aes256_set_encrypt_key(&amp;xts_key-&gt;tweak_cipher, &amp;key[AES256_KEY_SIZE]);
+}
+
+void
+xts_aes256_encrypt_message(struct xts_aes256_key *xts_key,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src)
+{
+    xts_encrypt_message(&amp;xts_key-&gt;cipher, &amp;xts_key-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes256_encrypt,
+                        tweak, length, dst, src);
+}
+
+void
+xts_aes256_decrypt_message(struct xts_aes256_key *xts_key,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src)
+{
+    xts_decrypt_message(&amp;xts_key-&gt;cipher, &amp;xts_key-&gt;tweak_cipher,
+                        (nettle_cipher_func *) aes256_decrypt,
+                        (nettle_cipher_func *) aes256_encrypt,
+                        tweak, length, dst, src);
+}
diff --git a/xts.c b/xts.c
new file mode 100644
index 00000000..f4d2da4b
--- /dev/null
+++ b/xts.c
@@ -0,0 +1,202 @@
+/* xts.c
+
+   XEX-based tweaked-codebook mode with ciphertext stealing (XTS)
+
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "xts.h"
+
+#include "macros.h"
+#include "memxor.h"
+#include "nettle-internal.h"
+
+/* shift one and XOR with 0x87. */
+/* src and dest can point to the same buffer for in-place operations */
+static void
+xts_shift(union nettle_block16 *dst,
+          const union nettle_block16 *src)
+{
+  uint8_t carry = src-&gt;b[15] &gt;&gt; 7;
+  uint64_t b0 = LE_READ_UINT64(src-&gt;b);
+  uint64_t b1 = LE_READ_UINT64(src-&gt;b+8);
+  b1 = (b1 &lt;&lt; 1) | (b0 &gt;&gt; 63);
+  b0 = b0 &lt;&lt; 1;
+  LE_WRITE_UINT64(dst-&gt;b, b0);
+  LE_WRITE_UINT64(dst-&gt;b+8, b1);
+  dst-&gt;b[0] ^= 0x87 &amp; -carry;
+}
+
+/*
+ * prev is the block to steal from
+ * curr is the input block to the last step
+ * length is the partial block length
+ * dst is the destination partial block
+ * src is the source partial block
+ *
+ * In the Encryption case:
+ *   prev -&gt; the output of the N-1 encryption step
+ *   curr -&gt; the input to the Nth step (will be encrypted as Cn-1)
+ *   dst  -&gt; the final Cn partial block
+ *   src  -&gt; the final Pn partial block
+ *
+ * In the decryption case:
+ *   prev -&gt; the output of the N-1 decryption step
+ *   curr -&gt; the input to the Nth step (will be decrypted as Pn-1)
+ *   dst  -&gt; the final Pn partial block
+ *   src  -&gt; the final Cn partial block
+ */
+static void
+xts_steal(uint8_t *prev, uint8_t *curr,
+	  size_t length, uint8_t *dst, const uint8_t *src)
+{
+  /* copy the remaining in the current input block */
+  memcpy(curr, src, length);
+  /* fill the current block with the last blocksize - length
+   * bytes of the previous block */
+  memcpy(&amp;curr[length], &amp;prev[length], XTS_BLOCK_SIZE - length);
+
+  /* This must be last or inplace operations will break
+   * copy 'length' bytes of the previous block in the
+   * destination block, which is the final partial block
+   * returned to the caller */
+  memcpy(dst, prev, length);
+}
+
+static void
+check_length(size_t length, uint8_t *dst)
+{
+  assert(length &gt;= XTS_BLOCK_SIZE);
+  /* asserts may be compiled out, try to save the user by zeroing the dst in
+   * case the buffer contains sensitive data (like the clear text for inplace
+   * encryption) */
+  if (length &lt; XTS_BLOCK_SIZE)
+    memset(dst, '\0', length);
+}
+
+/* works also for inplace encryption/decryption */
+
+void
+xts_encrypt_message(const void *enc_ctx, const void *twk_ctx,
+	            nettle_cipher_func *encf,
+	            const uint8_t *tweak, size_t length,
+	            uint8_t *dst, const uint8_t *src)
+{
+  union nettle_block16 T;
+  union nettle_block16 P;
+
+  check_length(length, dst);
+
+  encf(twk_ctx, XTS_BLOCK_SIZE, T.b, tweak);
+
+  /* the zeroth power of alpha is the initial ciphertext value itself, so we
+   * skip shifting and do it at the end of each block operation instead */
+  for (;length &gt;= XTS_BLOCK_SIZE;
+       length -= XTS_BLOCK_SIZE, src += XTS_BLOCK_SIZE, dst += XTS_BLOCK_SIZE)
+    {
+      memxor3(P.b, src, T.b, XTS_BLOCK_SIZE);	/* P -&gt; PP */
+      encf(enc_ctx, XTS_BLOCK_SIZE, dst, P.b);  /* CC */
+      memxor(dst, T.b, XTS_BLOCK_SIZE);	        /* CC -&gt; C */
+
+      /* shift T for next block */
+      xts_shift(&amp;T, &amp;T);
+    }
+
+  /* if the last block is partial, handle via stealing */
+  if (length)
+    {
+      uint8_t *C = dst - XTS_BLOCK_SIZE;
+      /* C points to C(n-1) */
+      xts_steal(C, P.b, length, dst, src);
+      memxor(P.b, T.b, XTS_BLOCK_SIZE);	        /* P -&gt; PP */
+      encf(enc_ctx, XTS_BLOCK_SIZE, C, P.b);    /* CC */
+      memxor(C, T.b, XTS_BLOCK_SIZE);
+    }
+}
+
+void
+xts_decrypt_message(const void *dec_ctx, const void *twk_ctx,
+	            nettle_cipher_func *decf, nettle_cipher_func *encf,
+	            const uint8_t *tweak, size_t length,
+	            uint8_t *dst, const uint8_t *src)
+{
+  union nettle_block16 T;
+  union nettle_block16 C;
+
+  check_length(length, dst);
+
+  encf(twk_ctx, XTS_BLOCK_SIZE, T.b, tweak);
+
+  for (;length &gt;= XTS_BLOCK_SIZE;
+       length -= XTS_BLOCK_SIZE, src += XTS_BLOCK_SIZE, dst += XTS_BLOCK_SIZE)
+    {
+      if (length &gt; XTS_BLOCK_SIZE &amp;&amp; length &lt; 2 * XTS_BLOCK_SIZE)
+        break;                  /* must ciphersteal on last two blocks */
+
+      memxor3(C.b, src, T.b, XTS_BLOCK_SIZE);	/* c -&gt; CC */
+      decf(dec_ctx, XTS_BLOCK_SIZE, dst, C.b);  /* PP */
+      memxor(dst, T.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+
+      xts_shift(&amp;T, &amp;T);
+    }
+
+  /* if the last block is partial, handle via stealing */
+  if (length)
+    {
+      union nettle_block16 T1;
+      uint8_t *P;
+
+      /* we need the last T(n) and save the T(n-1) for later */
+      xts_shift(&amp;T1, &amp;T);
+
+      P = dst;      /* use P(n-1) as temp storage for partial P(n) */
+      memxor3(C.b, src, T1.b, XTS_BLOCK_SIZE);	/* C -&gt; CC */
+      decf(dec_ctx, XTS_BLOCK_SIZE, P, C.b);    /* PP */
+      memxor(P, T1.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+
+      /* process next block (Pn-1) */
+      length -= XTS_BLOCK_SIZE;
+      src += XTS_BLOCK_SIZE;
+      dst += XTS_BLOCK_SIZE;
+
+      /* Fill P(n) and prepare C, P still pointing to P(n-1) */
+      xts_steal(P, C.b, length, dst, src);
+      memxor(C.b, T.b, XTS_BLOCK_SIZE);	        /* C -&gt; CC */
+      decf(dec_ctx, XTS_BLOCK_SIZE, P, C.b);    /* PP */
+      memxor(P, T.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+    }
+}
diff --git a/xts.h b/xts.h
new file mode 100644
index 00000000..a9ea970d
--- /dev/null
+++ b/xts.h
@@ -0,0 +1,124 @@
+/* xts.h
+
+   XEX-based tweaked-codebook mode with ciphertext stealing (XTS)
+
+   Copyright (C) 2005 Niels Möller
+   Copyright (C) 2018 Red Hat, Inc.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+
+#ifndef NETTLE_XTS_H_INCLUDED
+#define NETTLE_XTS_H_INCLUDED
+
+#include "nettle-types.h"
+#include "aes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define xts_encrypt_message nettle_xts_encrypt_message
+#define xts_decrypt_message nettle_xts_decrypt_message
+#define xts_aes128_set_encrypt_key nettle_xts_aes128_set_encrypt_key
+#define xts_aes128_set_decrypt_key nettle_xts_aes128_set_decrypt_key
+#define xts_aes128_encrypt_message nettle_xts_aes128_encrypt_message
+#define xts_aes128_decrypt_message nettle_xts_aes128_decrypt_message
+#define xts_aes256_set_encrypt_key nettle_xts_aes256_set_encrypt_key
+#define xts_aes256_set_decrypt_key nettle_xts_aes256_set_decrypt_key
+#define xts_aes256_encrypt_message nettle_xts_aes256_encrypt_message
+#define xts_aes256_decrypt_message nettle_xts_aes256_decrypt_message
+
+#define XTS_BLOCK_SIZE 16
+
+void
+xts_encrypt_message(const void *enc_ctx, const void *twk_ctx,
+                nettle_cipher_func *encf,
+                const uint8_t *tweak, size_t length,
+                uint8_t *dst, const uint8_t *src);
+void
+xts_decrypt_message(const void *dec_ctx, const void *twk_ctx,
+                    nettle_cipher_func *decf, nettle_cipher_func *encf,
+                    const uint8_t *tweak, size_t length,
+                    uint8_t *dst, const uint8_t *src);
+
+/* XTS Mode with AES-128 */
+struct xts_aes128_key {
+    struct aes128_ctx cipher;
+    struct aes128_ctx tweak_cipher;
+};
+
+void
+xts_aes128_set_encrypt_key(struct xts_aes128_key *xts_key,
+                           const uint8_t *key);
+
+void
+xts_aes128_set_decrypt_key(struct xts_aes128_key *xts_key,
+                           const uint8_t *key);
+
+void
+xts_aes128_encrypt_message(struct xts_aes128_key *xtskey,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src);
+
+void
+xts_aes128_decrypt_message(struct xts_aes128_key *xts_key,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src);
+
+/* XTS Mode with AES-256 */
+struct xts_aes256_key {
+    struct aes256_ctx cipher;
+    struct aes256_ctx tweak_cipher;
+};
+
+void
+xts_aes256_set_encrypt_key(struct xts_aes256_key *xts_key,
+                           const uint8_t *key);
+
+void
+xts_aes256_set_decrypt_key(struct xts_aes256_key *xts_key,
+                           const uint8_t *key);
+
+void
+xts_aes256_encrypt_message(struct xts_aes256_key *xts_key,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src);
+
+void
+xts_aes256_decrypt_message(struct xts_aes256_key *xts_key,
+                           const uint8_t *tweak, size_t length,
+                           uint8_t *dst, const uint8_t *src);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_XTS_H_INCLUDED */
+
-- 
2.20.1


["0002-Inline-ciphertext-stealing.patch" (0002-Inline-ciphertext-stealing.patch)]

From f6249917be1a991af1724ce4e9d7d8761a7a191d Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Tue, 19 Mar 2019 16:30:53 -0400
Subject: [PATCH 2/3] Inline ciphertext stealing

This avoids copying and may be somewhat more readable without the need
for so much explanation.

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 xts.c | 106 +++++++++++++++++++++++++---------------------------------
 1 file changed, 46 insertions(+), 60 deletions(-)

diff --git a/xts.c b/xts.c
index f4d2da4b..5c37655d 100644
--- a/xts.c
+++ b/xts.c
@@ -61,42 +61,6 @@ xts_shift(union nettle_block16 *dst,
   dst-&gt;b[0] ^= 0x87 &amp; -carry;
 }
 
-/*
- * prev is the block to steal from
- * curr is the input block to the last step
- * length is the partial block length
- * dst is the destination partial block
- * src is the source partial block
- *
- * In the Encryption case:
- *   prev -&gt; the output of the N-1 encryption step
- *   curr -&gt; the input to the Nth step (will be encrypted as Cn-1)
- *   dst  -&gt; the final Cn partial block
- *   src  -&gt; the final Pn partial block
- *
- * In the decryption case:
- *   prev -&gt; the output of the N-1 decryption step
- *   curr -&gt; the input to the Nth step (will be decrypted as Pn-1)
- *   dst  -&gt; the final Pn partial block
- *   src  -&gt; the final Cn partial block
- */
-static void
-xts_steal(uint8_t *prev, uint8_t *curr,
-	  size_t length, uint8_t *dst, const uint8_t *src)
-{
-  /* copy the remaining in the current input block */
-  memcpy(curr, src, length);
-  /* fill the current block with the last blocksize - length
-   * bytes of the previous block */
-  memcpy(&amp;curr[length], &amp;prev[length], XTS_BLOCK_SIZE - length);
-
-  /* This must be last or inplace operations will break
-   * copy 'length' bytes of the previous block in the
-   * destination block, which is the final partial block
-   * returned to the caller */
-  memcpy(dst, prev, length);
-}
-
 static void
 check_length(size_t length, uint8_t *dst)
 {
@@ -125,26 +89,45 @@ xts_encrypt_message(const void *enc_ctx, const void *twk_ctx,
 
   /* the zeroth power of alpha is the initial ciphertext value itself, so we
    * skip shifting and do it at the end of each block operation instead */
-  for (;length &gt;= XTS_BLOCK_SIZE;
+  for (;length &gt;= 2 * XTS_BLOCK_SIZE || length == XTS_BLOCK_SIZE;
        length -= XTS_BLOCK_SIZE, src += XTS_BLOCK_SIZE, dst += XTS_BLOCK_SIZE)
     {
       memxor3(P.b, src, T.b, XTS_BLOCK_SIZE);	/* P -&gt; PP */
       encf(enc_ctx, XTS_BLOCK_SIZE, dst, P.b);  /* CC */
       memxor(dst, T.b, XTS_BLOCK_SIZE);	        /* CC -&gt; C */
 
-      /* shift T for next block */
-      xts_shift(&amp;T, &amp;T);
+      /* shift T for next block if any */
+      if (length &gt; XTS_BLOCK_SIZE)
+          xts_shift(&amp;T, &amp;T);
     }
 
   /* if the last block is partial, handle via stealing */
   if (length)
     {
-      uint8_t *C = dst - XTS_BLOCK_SIZE;
-      /* C points to C(n-1) */
-      xts_steal(C, P.b, length, dst, src);
-      memxor(P.b, T.b, XTS_BLOCK_SIZE);	        /* P -&gt; PP */
-      encf(enc_ctx, XTS_BLOCK_SIZE, C, P.b);    /* CC */
-      memxor(C, T.b, XTS_BLOCK_SIZE);
+      /* S Holds the real C(n-1) (Whole last block to steal from) */
+      union nettle_block16 S;
+
+      memxor3(P.b, src, T.b, XTS_BLOCK_SIZE);	/* P -&gt; PP */
+      encf(enc_ctx, XTS_BLOCK_SIZE, S.b, P.b);  /* CC */
+      memxor(S.b, T.b, XTS_BLOCK_SIZE);	        /* CC -&gt; S */
+
+      /* shift T for next block */
+      xts_shift(&amp;T, &amp;T);
+
+      length -= XTS_BLOCK_SIZE;
+      src += XTS_BLOCK_SIZE;
+
+      memxor3(P.b, src, T.b, length);           /* P |.. */
+      /* steal ciphertext to complete block */
+      memxor3(P.b + length, S.b + length, T.b + length,
+              XTS_BLOCK_SIZE - length);         /* ..| S_2 -&gt; PP */
+
+      encf(enc_ctx, XTS_BLOCK_SIZE, dst, P.b);  /* CC */
+      memxor(dst, T.b, XTS_BLOCK_SIZE);         /* CC -&gt; C(n-1) */
+
+      /* Do this after we read src so inplace operations do not break */
+      dst += XTS_BLOCK_SIZE;
+      memcpy(dst, S.b, length);                 /* S_1 -&gt; C(n) */
     }
 }
 
@@ -161,42 +144,45 @@ xts_decrypt_message(const void *dec_ctx, const void *twk_ctx,
 
   encf(twk_ctx, XTS_BLOCK_SIZE, T.b, tweak);
 
-  for (;length &gt;= XTS_BLOCK_SIZE;
+  for (;length &gt;= 2 * XTS_BLOCK_SIZE || length == XTS_BLOCK_SIZE;
        length -= XTS_BLOCK_SIZE, src += XTS_BLOCK_SIZE, dst += XTS_BLOCK_SIZE)
     {
-      if (length &gt; XTS_BLOCK_SIZE &amp;&amp; length &lt; 2 * XTS_BLOCK_SIZE)
-        break;                  /* must ciphersteal on last two blocks */
-
       memxor3(C.b, src, T.b, XTS_BLOCK_SIZE);	/* c -&gt; CC */
       decf(dec_ctx, XTS_BLOCK_SIZE, dst, C.b);  /* PP */
       memxor(dst, T.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
 
-      xts_shift(&amp;T, &amp;T);
+      /* shift T for next block if any */
+      if (length &gt; XTS_BLOCK_SIZE)
+          xts_shift(&amp;T, &amp;T);
     }
 
   /* if the last block is partial, handle via stealing */
   if (length)
     {
       union nettle_block16 T1;
-      uint8_t *P;
+      /* S Holds the real P(n) (with part of stolen ciphertext) */
+      union nettle_block16 S;
 
       /* we need the last T(n) and save the T(n-1) for later */
       xts_shift(&amp;T1, &amp;T);
 
-      P = dst;      /* use P(n-1) as temp storage for partial P(n) */
       memxor3(C.b, src, T1.b, XTS_BLOCK_SIZE);	/* C -&gt; CC */
-      decf(dec_ctx, XTS_BLOCK_SIZE, P, C.b);    /* PP */
-      memxor(P, T1.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+      decf(dec_ctx, XTS_BLOCK_SIZE, S.b, C.b);  /* PP */
+      memxor(S.b, T1.b, XTS_BLOCK_SIZE);	/* PP -&gt; S */
 
       /* process next block (Pn-1) */
       length -= XTS_BLOCK_SIZE;
       src += XTS_BLOCK_SIZE;
-      dst += XTS_BLOCK_SIZE;
 
-      /* Fill P(n) and prepare C, P still pointing to P(n-1) */
-      xts_steal(P, C.b, length, dst, src);
-      memxor(C.b, T.b, XTS_BLOCK_SIZE);	        /* C -&gt; CC */
-      decf(dec_ctx, XTS_BLOCK_SIZE, P, C.b);    /* PP */
-      memxor(P, T.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P */
+      /* Prepare C, P holds the real P(n) */
+      memxor3(C.b, src, T.b, length);	        /* C_1 |.. */
+      memxor3(C.b + length, S.b + length, T.b + length,
+              XTS_BLOCK_SIZE - length);         /* ..| S_2 -&gt; CC */
+      decf(dec_ctx, XTS_BLOCK_SIZE, dst, C.b);  /* PP */
+      memxor(dst, T.b, XTS_BLOCK_SIZE);	        /* PP -&gt; P(n-1) */
+
+      /* Do this after we read src so inplace operations do not break */
+      dst += XTS_BLOCK_SIZE;
+      memcpy(dst, S.b, length);                 /* S_1 -&gt; P(n) */
     }
 }
-- 
2.20.1


["0003-Recode-xts_shift-based-on-endianess.patch" (0003-Recode-xts_shift-based-on-endianess.patch)]

From 1219d4e1cd0f29869862cc6c13bf04b9d51e623a Mon Sep 17 00:00:00 2001
From: Simo Sorce &lt;simo@redhat.com&gt;
Date: Wed, 20 Mar 2019 11:46:22 -0400
Subject: [PATCH 3/3] Recode xts_shift based on endianess

This creates two implementations of xts_shift, one for little endian and
one for big endian. This way we avoid copies to additional variables and
inefficient byteswapping on platforms that do not have dedicated
instructions.

Signed-off-by: Simo Sorce &lt;simo@redhat.com&gt;
---
 xts.c | 29 ++++++++++++++++++++---------
 1 file changed, 20 insertions(+), 9 deletions(-)

diff --git a/xts.c b/xts.c
index 5c37655d..ea2ceea9 100644
--- a/xts.c
+++ b/xts.c
@@ -45,21 +45,32 @@
 #include "memxor.h"
 #include "nettle-internal.h"
 
-/* shift one and XOR with 0x87. */
+/* shift left one and XOR with 0x87 if there is carry. */
+/* the algorithm reads this as a 128bit Little Endian number */
 /* src and dest can point to the same buffer for in-place operations */
+#if WORDS_BIGENDIAN
+#define BE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
+                     (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
 static void
 xts_shift(union nettle_block16 *dst,
           const union nettle_block16 *src)
 {
-  uint8_t carry = src-&gt;b[15] &gt;&gt; 7;
-  uint64_t b0 = LE_READ_UINT64(src-&gt;b);
-  uint64_t b1 = LE_READ_UINT64(src-&gt;b+8);
-  b1 = (b1 &lt;&lt; 1) | (b0 &gt;&gt; 63);
-  b0 = b0 &lt;&lt; 1;
-  LE_WRITE_UINT64(dst-&gt;b, b0);
-  LE_WRITE_UINT64(dst-&gt;b+8, b1);
-  dst-&gt;b[0] ^= 0x87 &amp; -carry;
+  uint64_t carry = (src-&gt;u64[1] &amp; 0x80) &gt;&gt; 7;
+  dst-&gt;u64[1] = BE_SHIFT(src-&gt;u64[1]) | ((src-&gt;u64[0] &amp; 0x80) &lt;&lt; 49);
+  dst-&gt;u64[0] = BE_SHIFT(src-&gt;u64[0]);
+  dst-&gt;u64[0] ^= 0x8700000000000000 &amp; -carry;
 }
+#else /* !WORDS_BIGENDIAN */
+static void
+xts_shift(union nettle_block16 *dst,
+          const union nettle_block16 *src)
+{
+  uint64_t carry = src-&gt;u64[1] &gt;&gt; 63;
+  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) | (src-&gt;u64[0] &gt;&gt; 63);
+  dst-&gt;u64[0] = src-&gt;u64[0] &lt;&lt; 1;
+  dst-&gt;u64[0] ^= 0x87 &amp; -carry;
+}
+#endif /* !WORDS_BIGNDIAN */
 
 static void
 check_length(size_t length, uint8_t *dst)
-- 
2.20.1


[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190324122054</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-03-24 12:20:54-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

Simo Sorce &lt;simo@redhat.com&gt; writes:

&gt; I am attaching all 3 patches anew as I also fixed the other issues you
&gt; mentioned in a previous email.

Thanks. I'm about to merge. I've run cross-compile+qemu tests also on
big-endian mips, and it seems to work fine.

&gt; +@subsubsection @acronym{XTS}-@acronym{AES} interface
&gt; +
&gt; +The @acronym{AES} @acronym{XTS} functions provide an API for using the
&gt; +@acronym{XTS} mode with the @acronym{AES} block ciphers. The parameters
&gt; +all have the same meaning as the general interface, except that the
&gt; +@var{enc_ctx}, @var{dec_ctx}, @var{twk_ctx}, @var{encf} and @var{decf} are
&gt; +replaced with an @acronym{AES} context structure called @var{ctx}, and a
&gt; +appropriate set-key function must be called before using any of the encryption
&gt; +or decryption functions in this interface.
&gt; +
&gt; +@deftp {Context struct} {struct xts_aes128_ctx}
&gt; +Holds state corresponding to the AES-128 block cipher.
&gt; +@end deftp
&gt; +
&gt; +@deftp {Context struct} {struct xts_aes256_ctx}
&gt; +Holds state corresponding to the AES-256 block cipher.
&gt; +@end deftp

These structs were renamed from _ctx to _key, right?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190324185708</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-03-24 18:57:08-0400</timestampReceived><subject>Re: Implement XTS block cipher mode</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Simo Sorce &lt;simo@redhat.com&gt; writes:
&gt;
&gt;&gt; I am attaching all 3 patches anew as I also fixed the other issues you
&gt;&gt; mentioned in a previous email.
&gt;
&gt; Thanks. I'm about to merge. I've run cross-compile+qemu tests also on
&gt; big-endian mips, and it seems to work fine.

Merged to master branch now. Thanks!

/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190317080818</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-03-17 08:08:18-0400</timestampReceived><subject>Re: [WIP] aes arm asm from libgcrypt</subject><body>

"Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt; writes:

&gt; On raspberry pi 3b+ (cortex-a53 @ 1.4GHz):
&gt; Before:
&gt;  aes128         |  nanosecs/byte   mebibytes/sec   cycles/byte
&gt;         ECB enc |     39.58 ns/B     24.10 MiB/s         - c/B
&gt;         ECB dec |     39.57 ns/B     24.10 MiB/s         - c/B
&gt; After:
&gt;         ECB enc |     15.24 ns/B     62.57 MiB/s         - c/B
&gt;         ECB dec |     15.68 ns/B     60.80 MiB/s         - c/B
&gt;
&gt; Passes nettle regression test (only little-endian though)

Cool!

&gt; Does not use pre-rotated tables (as in AES_SMALL), so reduces d-cache
&gt; footprint from 4.25K to 1K (enc)/1.25K (dec);

We could ficgure out a way to exclude unneeded tables in builds that
unconditionally uses this code.

I think I tried this years ago, and found it slower, recorded in this
comment:

  C It's tempting to use eor with rotation, but that's slower.

But things may have changed, or you're doing it in a different way than
I tried. Have you benchmarked with small and large tables?

&gt; completely unrolled, so increases i-cache footprint
&gt; from 948b to 4416b (enc)/4032b (dec)

Do you have any numbers for the performance gain from unrolling?

With complete unrolling, it may be good with separate entry points (and
possibly separate files) for aes128, aes192, aes256. I've been
considering doing that for the x86_64/aesni (and then the old-style
aes_encrypt needs to be changed to not use the _aes_encrypt function
with a rounds argument; I have a branch doing that lying around
somewhere).

&gt; P.S. Yes, I tried convert macros to m4: complete failure (no named
&gt; parameters, problems with more than 9 arguments, weird expansion rules);
&gt; so I fallen back to good ol' gas. Sorry.

No named arguments may be a bit annoying. At least for the AES code, I
see no macros with more than 9 arguments.

&gt; define(&lt;KEYSCHEDULE_REVERSED&gt;,&lt;yes&gt;)
&gt; define(&lt;IF_KEYSCHEDULE_REVERSED&gt;,&lt;ifelse(
&gt; KEYSCHEDULE_REVERSED,yes,&lt;$1&gt;,
&gt; KEYSCHEDULE_REVERSED,no,&lt;$2&gt;)&gt;)

What is this for?

&gt; C helper macros
&gt; .macro ldr_unaligned_le rout rsrc offs rtmp
&gt; 	ldrb \rout, [\rsrc, #((\offs) + 0)]
&gt; 	ldrb \rtmp, [\rsrc, #((\offs) + 1)]
&gt; 	orr \rout, \rout, \rtmp, lsl #8
&gt; 	ldrb \rtmp, [\rsrc, #((\offs) + 2)]
&gt; 	orr \rout, \rout, \rtmp, lsl #16
&gt; 	ldrb \rtmp, [\rsrc, #((\offs) + 3)]
&gt; 	orr \rout, \rout, \rtmp, lsl #24
&gt; .endm

A different way to read unaligned data is to read aligned words, and
rotate and shift on the fly. There's an example of this in
arm/v6/sha256-compress.asm, using ldm, sel and ror, + some setup code
and one extra register for keeping left-over bytes.

&gt; PROLOGUE(_nettle_aes_decrypt)
&gt; 	.cfi_startproc
&gt; 	teq	PARAM_LENGTH, #0
&gt; 	bxeq	lr
&gt;
&gt; 	push {r0,r3,%r4-%r11, %ip, %lr}
&gt; 	.cfi_adjust_cfa_offset 48
&gt; 	.cfi_rel_offset r0, 0	C PARAM_LENGTH
&gt; 	.cfi_rel_offset r3, 4	C PARAM_ROUNDS
&gt; 	.cfi_rel_offset r4, 8
&gt; 	.cfi_rel_offset r5, 12
&gt; 	.cfi_rel_offset r6, 16
&gt; 	.cfi_rel_offset r7, 20
&gt; 	.cfi_rel_offset r8, 24
&gt; 	.cfi_rel_offset r9, 28
&gt; 	.cfi_rel_offset r10, 32
&gt; 	.cfi_rel_offset r11, 36
&gt; 	.cfi_rel_offset ip, 40
&gt; 	.cfi_rel_offset lr, 44

Are these .cfi_* pseudoops essential? I'm afraid I'm ignorant of the
fine details here; I just see from the gas manual that they appear to be
related to stack unwinding.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190317094243</emailId><senderName>"Yuriy M. Kaminskiy"</senderName><senderEmail>yumkam@gmail.com</senderEmail><timestampReceived>2019-03-17 09:42:43-0400</timestampReceived><subject>Re: [WIP] aes arm asm from libgcrypt</subject><body>

On 17.03.2019 11:08, Niels Möller wrote:
&gt; "Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt; writes:
&gt; 
&gt;&gt; On raspberry pi 3b+ (cortex-a53 @ 1.4GHz):
&gt;&gt; Before:
&gt;&gt;  aes128         |  nanosecs/byte   mebibytes/sec   cycles/byte
&gt;&gt;         ECB enc |     39.58 ns/B     24.10 MiB/s         - c/B
&gt;&gt;         ECB dec |     39.57 ns/B     24.10 MiB/s         - c/B
&gt;&gt; After:
&gt;&gt;         ECB enc |     15.24 ns/B     62.57 MiB/s         - c/B
&gt;&gt;         ECB dec |     15.68 ns/B     60.80 MiB/s         - c/B
&gt;&gt;
&gt;&gt; Passes nettle regression test (only little-endian though)
&gt; 
&gt; Cool!
&gt; 
&gt;&gt; Does not use pre-rotated tables (as in AES_SMALL), so reduces d-cache
&gt;&gt; footprint from 4.25K to 1K (enc)/1.25K (dec);
&gt; 
&gt; We could ficgure out a way to exclude unneeded tables in builds that
&gt; unconditionally uses this code.
&gt; 
&gt; I think I tried this years ago, and found it slower, recorded in this
&gt; comment:
&gt; 
&gt;   C It's tempting to use eor with rotation, but that's slower.
&gt; 
&gt; But things may have changed, or you're doing it in a different way than
&gt; I tried. Have you benchmarked with small and large tables?

Well, it is not my code. I just taken it from libgcrypt, and adopted to
nettle (reordered arguments, added loop over blocks, changed decrypt
keyschedule to nettle's), without any major changes.

&gt;&gt; completely unrolled, so increases i-cache footprint
&gt;&gt; from 948b to 4416b (enc)/4032b (dec)
&gt; 
&gt; Do you have any numbers for the performance gain from unrolling?
&gt; 
&gt; With complete unrolling, it may be good with separate entry points (and
&gt; possibly separate files) for aes128, aes192, aes256.

Now at least it reuses some code. If application calls both aes128 and aes256,
some i-cache is saved.

&gt; I've been
&gt; considering doing that for the x86_64/aesni (and then the old-style
&gt; aes_encrypt needs to be changed to not use the _aes_encrypt function
&gt; with a rounds argument; I have a branch doing that lying around
&gt; somewhere).
&gt; 
&gt;&gt; P.S. Yes, I tried convert macros to m4: complete failure (no named
&gt;&gt; parameters, problems with more than 9 arguments, weird expansion rules);
&gt;&gt; so I fallen back to good ol' gas. Sorry.
&gt; 
&gt; No named arguments may be a bit annoying. At least for the AES code, I
&gt; see no macros with more than 9 arguments.

Some with 10:
.macro do_encround next_r ra rb rc rd rna rnb rnc rnd preload_key
.macro encround round ra rb rc rd rna rnb rnc rnd preload_key

(And I failed with groking m4 way of making indirect macro call)

&gt;&gt; define(&lt;KEYSCHEDULE_REVERSED&gt;,&lt;yes&gt;)
&gt;&gt; define(&lt;IF_KEYSCHEDULE_REVERSED&gt;,&lt;ifelse(
&gt;&gt; KEYSCHEDULE_REVERSED,yes,&lt;$1&gt;,
&gt;&gt; KEYSCHEDULE_REVERSED,no,&lt;$2&gt;)&gt;)
&gt; 
&gt; What is this for?

See FIXME comment in aes-invert-internal.c; original gcrypt code used unswapped
key schedule and walk backwards in aes_decrypt; for nettle port, I had to
change it, but left original code as an option (if nettle sometime decide to
follow FIXME and switch it).

BTW, mtable in aes-invert-internal is exactly same as _aes_decrypt_table.table[0],
it would be good to merge them.

(Another trick used in the last round of gcrypt's aes-encrypt:
   _aes_encrypt_table.sbox[i] == (_aes_encrypt_table.table[0][i]&gt;&gt; 8) &amp; 0xff
   _aes_encrypt_table.sbox[i] == (_aes_encrypt_table.table[0][i]&gt;&gt;16) &amp; 0xff
It does not use sbox and saves 256 bytes of d-cache footprint [but no same thing
with aes-decrypt])

&gt;&gt; C helper macros
&gt;&gt; .macro ldr_unaligned_le rout rsrc offs rtmp
&gt;&gt; 	ldrb \rout, [\rsrc, #((\offs) + 0)]
&gt;&gt; 	ldrb \rtmp, [\rsrc, #((\offs) + 1)]
&gt;&gt; 	orr \rout, \rout, \rtmp, lsl #8
&gt;&gt; 	ldrb \rtmp, [\rsrc, #((\offs) + 2)]
&gt;&gt; 	orr \rout, \rout, \rtmp, lsl #16
&gt;&gt; 	ldrb \rtmp, [\rsrc, #((\offs) + 3)]
&gt;&gt; 	orr \rout, \rout, \rtmp, lsl #24
&gt;&gt; .endm
&gt; 
&gt; A different way to read unaligned data is to read aligned words, and
&gt; rotate and shift on the fly. There's an example of this in
&gt; arm/v6/sha256-compress.asm, using ldm, sel and ror, + some setup code
&gt; and one extra register for keeping left-over bytes.

Actually, this is unused in the last version of code: armv6 supports
unaligned ldr, so I replaced
   if(aligned){ldm;IF_BE(rev); ) } else { ldr_unaligned_le }
with simple unconditional
    ldr; IF_BE(rev);
It was a bit faster with misaligned buffers, and almost same speed with
aligned buffers.
I've left it if someone will want to use this on armv5 (or it will turn out slower
on some other cpu).

&gt;&gt; PROLOGUE(_nettle_aes_decrypt)
&gt;&gt; 	.cfi_startproc
&gt;&gt; 	teq	PARAM_LENGTH, #0
&gt;&gt; 	bxeq	lr
&gt;&gt;
&gt;&gt; 	push {r0,r3,%r4-%r11, %ip, %lr}
&gt;&gt; 	.cfi_adjust_cfa_offset 48
&gt;&gt; 	.cfi_rel_offset r0, 0	C PARAM_LENGTH
&gt;&gt; 	.cfi_rel_offset r3, 4	C PARAM_ROUNDS
&gt;&gt; 	.cfi_rel_offset r4, 8
...
&gt; 
&gt; Are these .cfi_* pseudoops essential? I'm afraid I'm ignorant of the
&gt; fine details here; I just see from the gas manual that they appear to be
&gt; related to stack unwinding.

They are useful for gdb, valgrind, etc to produce sensible backtrace,
to be able to move up/down callchain (without losing values from callee-saved
registers, etc), and AFAIK they don't add any runtime overhead, so I add them
when possible (FWIW, they were not present in original gcrypt code).

P.S. There were stupid last-minute error in posted aes-encrypt, patch attached.

["aes-encrypt-internal.diff" (text/x-patch)]

--- /home/yukam/Desktop/aes-encrypt-internal.asm	2019-03-16 13:13:58.000000000 +0300
+++ aes-encrypt-internal.asm	2019-03-17 11:45:04.110701283 +0300
@@ -263,16 +263,16 @@
 	ldr	RT0, FRAME_SRC
 
 ifelse(V6,V6,&lt;
+	ldr RA, [RT0]
+	ldr RB, [RT0, #4]
+	ldr RC, [RT0, #8]
+	ldr RD, [RT0, #12]
   IF_BE(&lt;
 	rev	RA, RA
 	rev	RB, RB
 	rev	RC, RC
 	rev	RD, RD
   &gt;)
-	str RA, [RT0]
-	str RB, [RT0, #4]
-	str RC, [RT0, #8]
-	str RD, [RT0, #12]
 &gt;,&lt;
   IF_LE(&lt;
 	C test if src is unaligned

[Attachment #4 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190324194528</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-03-24 19:45:28-0400</timestampReceived><subject>Re: [WIP] aes arm asm from libgcrypt</subject><body>

"Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt; writes:

I've had another look, trying to understand how it differs. 

&gt; Does not use pre-rotated tables (as in AES_SMALL), so reduces d-cache
&gt; footprint from 4.25K to 1K (enc)/1.25K (dec);
&gt; completely unrolled, so increases i-cache footprint
&gt; from 948b to 4416b (enc)/4032b (dec)

Not sure unrolling is that beneficial; Nettle's implementation does two
rounds at a time (since just like in your patch, src and destination
registers alternate when doing a round), and that's so many instructions
that lop iverhead should be pretty small.

&gt; As it completely replaces current implementation, I just attached new
&gt; files (will post final version as a patch).

As you say, it doesn't use prerotated tables, but instead adds a , ror
#x to the relevant eor instructions.

Load and store of the cleartext and ciphertext bytes is different (and I
have some difficulty following it).

Masking to get table indices is the same as in nettle's
arm/aes-encrypt-internal.asm, while nettle's v6 code uses the uxtb
instruction, which saves one register (which the code doesn't take much
advantage of, though).

The code in your patch has more careful instruction scheduling, e.g.,
interleaving addition of roundkeys with the sbox table lookups. Nettle's
code is written with only a single temporary register used for
everything, which makes it impossible to interleave independent parts of
the mangling. While your patch seems to alternate between three
different temporaries.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190313213115</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-03-13 21:31:15-0400</timestampReceived><subject>Re: [RFC] optimized poly1305 and ABI</subject><body>

On Thu, 2019-03-14 at 00:25 +0300, Yuriy M. Kaminskiy wrote:
&gt; On 12.03.2019 15:02, Yuriy M. Kaminskiy wrote:
&gt; &gt; Then I will probably take a look at poly1305
&gt; 
&gt; ... and it looks problematic; porting poly1305/armv6 is possible, but there won't
&gt; be much improvement over generic C code:
&gt; 
&gt; $ poly1305-opt/bin/poly1305-util bench
&gt; 8192 byte(s):
&gt;           neon, 15114.40 ns per call,   1.8 ns/byte
&gt;          armv6, 31944.33 ns per call,   3.9 ns/byte
&gt;     generic/32, 39088.50 ns per call,   4.8 ns/byte
&gt; 
&gt; neon (and other simd implementations) is much faster, but requires larger state; current nettle's
&gt; struct poly1305_ctx is 56 bytes, optimized versions requires up to 192 bytes.
&gt; 
&gt; And it is embedded in struct chacha_poly1305_ctx and poly1305_aes_ctx, which looks like
&gt; part of public (and used) low-level ABI.
&gt; 
&gt; (nettle-meta.h interface would be safe wrt struct size changes, but so far everything I've looked
&gt; at - including gnutls - was not using it :-()

FWIW, I wouldn't feel blocked by an ABI break in Nettle.
Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190317095617</emailId><senderName>"Yuriy M. Kaminskiy"</senderName><senderEmail>yumkam@gmail.com</senderEmail><timestampReceived>2019-03-17 09:56:17-0400</timestampReceived><subject>Re: [RFC] optimized poly1305 and ABI</subject><body>

On 14.03.2019 00:31, Simo Sorce wrote:
&gt; On Thu, 2019-03-14 at 00:25 +0300, Yuriy M. Kaminskiy wrote:
&gt;&gt; On 12.03.2019 15:02, Yuriy M. Kaminskiy wrote:
&gt;&gt; And it is embedded in struct chacha_poly1305_ctx and poly1305_aes_ctx, which looks like
&gt;&gt; part of public (and used) low-level ABI.
&gt;&gt;
&gt;&gt; (nettle-meta.h interface would be safe wrt struct size changes, but so far everything I've looked
&gt;&gt; at - including gnutls - was not using it :-()
&gt; 
&gt; FWIW, I wouldn't feel blocked by an ABI break in Nettle.

Breaking ABI in the library that is used in another libraries is always problematic.

Scenario: $app links to libgnutls.so.1 and libnettle.so.1 (and libgnutls.so.1 linked
against libnettle.so.1; then libnettle.so.2 installed and libgnutls.so.1 rebuilt
against new nettle; what will happen with $app?

(Especially since nettle does not use versioned symbols)

So, you either bump libgnutls soname too (and you must rebuild all apps to take advantage of it)
[also it triggers same problem with libraries that uses libgnutls],
or you add Conflict/Breaks in libnettle2 (and you must rebuild all libraries and apps
to be able to even install libnettle2).

(And both renders new libnettle unusable for stable-backports.)

When you are forced to break ABI, it is good point to think: can it be avoided,
and how can this be prevented in the future?

(poly1305 is not only algo that may require altering context structure for optimized
implementation [e.g. bitsliced or vectorized aes]).

E.g. openssl made all structures opaque, and I believe it is correct long-term solution.

(Well, I've thought about a way, although not very nice: keep old version internally,
add separate {chacha,aes}_poly1305_encrypt_v2, #define $foo $foo_v2 in headers; you'll need
to rebuild all directly dependent libraries and apps to take advantage of new implementation,
but not necessarily whole system; also it is not 146% safe [lib$a built against old version,
lib$b built against new version, lib$a allocates struct chacha20_poly13_ctx and passes pointer
to lib$b; libb calls $foo_v2, BOOM], but I doubt anyone uses libnettle this way in practice).
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190317120711</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2019-03-17 12:07:11-0400</timestampReceived><subject>Re: [RFC] optimized poly1305 and ABI</subject><body>

On Sun, 2019-03-17 at 12:56 +0300, Yuriy M. Kaminskiy wrote:
&gt; On 14.03.2019 00:31, Simo Sorce wrote:
&gt; &gt; On Thu, 2019-03-14 at 00:25 +0300, Yuriy M. Kaminskiy wrote:
&gt; &gt; &gt; On 12.03.2019 15:02, Yuriy M. Kaminskiy wrote:
&gt; &gt; &gt; And it is embedded in struct chacha_poly1305_ctx and
&gt; &gt; &gt; poly1305_aes_ctx, which looks like
&gt; &gt; &gt; part of public (and used) low-level ABI.
&gt; &gt; &gt; 
&gt; &gt; &gt; (nettle-meta.h interface would be safe wrt struct size changes,
&gt; &gt; &gt; but so far everything I've looked
&gt; &gt; &gt; at - including gnutls - was not using it :-()
&gt; &gt; 
&gt; &gt; FWIW, I wouldn't feel blocked by an ABI break in Nettle.
&gt; 
&gt; Breaking ABI in the library that is used in another libraries is
&gt; always problematic.
&gt; 
&gt; Scenario: $app links to libgnutls.so.1 and libnettle.so.1 (and
&gt; libgnutls.so.1 linked
&gt; against libnettle.so.1; then libnettle.so.2 installed and
&gt; libgnutls.so.1 rebuilt
&gt; against new nettle; what will happen with $app?
&gt; 
&gt; (Especially since nettle does not use versioned symbols)

Hi,
 Actually it does (see libnettle.map.in and libhogweed.map.in), and
they were added (recently) mainly for the scenario you describe above.
That is, the versioned symbols name contain to soname and thus any
previous or newer version of the library don't conflict.


&gt; (And both renders new libnettle unusable for stable-backports.)
&gt; 
&gt; When you are forced to break ABI, it is good point to think: can it
&gt; be avoided, and how can this be prevented in the future?

The nature of nettle (very low-level with structures exposed) brings
often the need for abi breakage. The approach gnutls follows is to keep
the gnutls abi stable and expose crypto algorithms in a more high level
and stable ABI for applications to use. On certain cases it also
overrides nettle code with Andy Polyakov's assembly implementation
(e.g., aes-gcm on aarch64 and x86-64) for performance.

Having all crypto in nettle and optimized would be the ideal scenario
for gnutls.

regards,
Nikos


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190317142230</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-03-17 14:22:30-0400</timestampReceived><subject>Re: [RFC] optimized poly1305 and ABI</subject><body>

On Sun, 2019-03-17 at 12:56 +0300, Yuriy M. Kaminskiy wrote:
&gt; On 14.03.2019 00:31, Simo Sorce wrote:
&gt; &gt; On Thu, 2019-03-14 at 00:25 +0300, Yuriy M. Kaminskiy wrote:
&gt; &gt; &gt; On 12.03.2019 15:02, Yuriy M. Kaminskiy wrote:
&gt; &gt; &gt; And it is embedded in struct chacha_poly1305_ctx and poly1305_aes_ctx, which looks like
&gt; &gt; &gt; part of public (and used) low-level ABI.
&gt; &gt; &gt; 
&gt; &gt; &gt; (nettle-meta.h interface would be safe wrt struct size changes, but so far everything I've looked
&gt; &gt; &gt; at - including gnutls - was not using it :-()
&gt; &gt; 
&gt; &gt; FWIW, I wouldn't feel blocked by an ABI break in Nettle.
&gt; 
&gt; Breaking ABI in the library that is used in another libraries is always problematic.
&gt; 
&gt; Scenario: $app links to libgnutls.so.1 and libnettle.so.1 (and libgnutls.so.1 linked
&gt; against libnettle.so.1; then libnettle.so.2 installed and libgnutls.so.1 rebuilt
&gt; against new nettle; what will happen with $app?
&gt; 
&gt; (Especially since nettle does not use versioned symbols)
&gt; 
&gt; So, you either bump libgnutls soname too (and you must rebuild all apps to take advantage of it)
&gt; [also it triggers same problem with libraries that uses libgnutls],
&gt; or you add Conflict/Breaks in libnettle2 (and you must rebuild all libraries and apps
&gt; to be able to even install libnettle2).

No, if app is built against nettle all you need to do is bump nettle's
so name and rebuild gnutls, the app will have to be rebuilt against the
new nettle only as gnutls completely masks nettle behind it's apis and
offers a stable ABI even when nettle ABI changes.

&gt; (And both renders new libnettle unusable for stable-backports.)

Yes, backports may be an issue, but nettle broke the ABI previously,
and it offers no ABI guarntee.

&gt; When you are forced to break ABI, it is good point to think: can it be avoided,
&gt; and how can this be prevented in the future?

This is not possible with Nettle as it uses explicit structures
exported to the caller, to have a stable ABI nettle would need to
change how it deals with context structures by allocating them on the
heap and making them opaque. I do not see this happening.

&gt; (poly1305 is not only algo that may require altering context structure for optimized
&gt; implementation [e.g. bitsliced or vectorized aes]).
&gt; 
&gt; E.g. openssl made all structures opaque, and I believe it is correct long-term solution.

Openssl is a higher level library. We can discuss a wrapper library
around nettle that offers a stable API/ABI and could be used by GnuTLS
perhaps.

&gt; (Well, I've thought about a way, although not very nice: keep old version internally,
&gt; add separate {chacha,aes}_poly1305_encrypt_v2, #define $foo $foo_v2 in headers; you'll need
&gt; to rebuild all directly dependent libraries and apps to take advantage of new implementation,
&gt; but not necessarily whole system; also it is not 146% safe [lib$a built against old version,
&gt; lib$b built against new version, lib$a allocates struct chacha20_poly13_ctx and passes pointer
&gt; to lib$b; libb calls $foo_v2, BOOM], but I doubt anyone uses libnettle this way in practice).

Yes, as you described this method is broken, you would have to have
explicit different APIs or introduce symbol versioning.

Simo.

-- 
Simo Sorce
Sr. Principal Software Engineer
Red Hat, Inc


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190412071046</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2019-04-12 07:10:46-0400</timestampReceived><subject>Re: [PATCH] nettle-pbkdf2.c: change the initialization for salt</subject><body>

On Fri, Apr 12, 2019 at 10:07 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; &gt; However, looking at the code, I believe the allocation of memory is
&gt; &gt; not required... it can be:
&gt;
&gt; The if (hex_salt) {...} block overwrites the salt storage, for in-place
&gt; hex decoding. I don't quite like overwriting the strings passed in via
&gt; argv, even if it might be possible. So when I wrote this tool, always
&gt; allocating a writable copy, and calling free unconditionally, seemed
&gt; nice and easy,

Fair enough :)
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190119153010</emailId><senderName>"Yuriy M. Kaminskiy"</senderName><senderEmail>yumkam@gmail.com</senderEmail><timestampReceived>2019-01-19 15:30:10-0400</timestampReceived><subject>Re: [repost] [PATCH] Add --enable-fat support for arm neon chacha20</subject><body>

On 19.01.2019 18:17, Niels Möller wrote:
&gt; "Yuriy M. Kaminskiy" &lt;yumkam@gmail.com&gt; writes:
&gt; 
&gt;&gt; +DECLARE_FAT_FUNC(_nettle_chacha_core, chacha_core_func)
&gt;&gt; +DECLARE_FAT_FUNC_VAR(_chacha_core, chacha_core_func, c);
&gt;&gt; +DECLARE_FAT_FUNC_VAR(_chacha_core, chacha_core_func, neon);
&gt;                          ^
&gt; 
&gt; The above underscores shouldn't be there. If I delete them, this works
&gt; fine using debian's cross compilers and qemu.

Yes, sorry (I changed/fixed that in when testing, but different patch 
was "top" in quilt at the time, so it missed in version I sent :-|)
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190120211804</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2019-01-20 21:18:04-0400</timestampReceived><subject>Re: Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks</subject><body>

On Sat, Jan 12, 2019 at 11:47 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:
&gt;
&gt; &gt; I attach a patch which moves everything to the latest images used by
&gt; &gt; gnutls (i.e., in addition to your patch, it also moves the x86 builds
&gt; &gt; to debian).
&gt;
&gt; Merged now. And I've deleted eratosthens.c. We'll see how to deal with
&gt; the static analalyzer's remaining complaints on eccdata.c.
&gt;
&gt; I'm also considering adding a few more configurations to the ci,
&gt; including "CC=gcc -std=c89", CPPFLAGS=-DNODEBUG and --disable-assembler.
&gt; Anything I have to keep in mind (e.g., limits on builder resources?)

One more to consider... -march=native.

I don't use it often, but I use it frequently on AMD cpu's and ARM
devices when GCC supports it.

AMD benefits because of the XOP rotates. On my Bulldozer test machine
ChaCha8 goes from 1.7 GB/s to 2.5 GB/s.

ARM devices always need help, so I try to build for the specific board
I am testing. Old GCC does not respond to -march=native on ARM so I
end up doing things like exporting CFLAGS and CXXFLAGS with
"-march=armv7-a -mtune=cortex-a8 -mfpu=neon -mfloat-abi=hard".
Otherwise the compilers don't use NEON which is available on the dev
boards.

Jeff
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190122215225</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-01-22 21:52:25-0400</timestampReceived><subject>Re: sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize</subject><body>

Hello,

ср, 23 янв. 2019 г. в 00:45, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt; &gt; That said, I'm about to delete nettle-stdint.h, and require that the
&gt; &gt; compiler supplies a &lt;stdint.h&gt; (as was discussed quite a while ago).
&gt;
&gt; I've now merged changes to do that to the master-updates branch. It
&gt; breaks the gnutls build, see
&gt; https://gitlab.com/gnutls/nettle/-/jobs/149522724,
&gt;
&gt;   In file included from gost/gost28147.c:40:
&gt;   gost/nettle-write.h:40:10: fatal error: nettle/nettle-stdint.h: No such
&gt;   file or directory
&gt;    #include &lt;nettle/nettle-stdint.h&gt;
&gt;             ^~~~~~~~~~~~~~~~~~~~~~~~

This file needs just uint8_t/uint64_t, so it might be easier to fix gnutls
to just include &lt;stdint.h&gt; there. I'll open a MR.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190122215635</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-01-22 21:56:35-0400</timestampReceived><subject>gitlab-ci builds (was: Re: Nettle-3.4.1rc1, addressing PKCS#1 side-channel leaks)</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I'm also considering adding a few more configurations to the ci,
&gt; including "CC=gcc -std=c89", CPPFLAGS=-DNODEBUG and --disable-assembler.

Done (but with -DNDEBUG, not -DNODEBUG). Seems to pass.

For the fat builds, it would make some sense to run make check with some
different settings for the NETTLE_FAT_OVERRIDE environment variable.
What's available on the gitlab build machines? Fat builds are of
interest for:

x86_64 (native), where recognized keywords are vendor:intel/amd (used to
select sse-based memxor), aesni and sha_ni, and 

arm, (32-bit, user-level qemu), where recognized keywords are arch:
(distinction between armv6 and earlier) and neon. When I run qemu
locally, all variants seem to be supported.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190130190110</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-01-30 19:01:10-0400</timestampReceived><subject>Re: nettle-stdint.h (was: Re: sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize)</subject><body>

Hello,

ср, 23 янв. 2019 г. в 01:01, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; This file needs just uint8_t/uint64_t, so it might be easier to fix gnutls
&gt; &gt; to just include &lt;stdint.h&gt; there. I'll open a MR.

I'm sorry for the delay. I've opened
https://gitlab.com/gnutls/gnutls/merge_requests/901 .

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190122220153</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-01-22 22:01:53-0400</timestampReceived><subject>nettle-stdint.h (was: Re: sec_powm.c:293: GNU MP assertion failed: enb &gt;= windowsize)</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; This file needs just uint8_t/uint64_t, so it might be easier to fix gnutls
&gt; to just include &lt;stdint.h&gt; there. I'll open a MR.

Sounds good, thanks! 

nettle-stdint.h is not advertised, or mentioned in the documentation, so
I hope it's very rare for applications to include it directly. According
to https://codesearch.debian.net/search?q=nettle-stdint.h, nettle and
gnutls are the only debian packages doing that.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190903170556</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-03 17:05:56-0400</timestampReceived><subject>Re: [PATCH 3/5] block-internal: add block XORing functions</subject><body>

dbaryshkov@gmail.com writes:

&gt; From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt;
&gt; Add common implementations for functions doing XOR over
&gt; nettle_block16/nettle_block8.

I've merged the first two patches. Thanks! Do you know if anyone is using
GCM_TABLE_BITS 4? I've tested that it still works, both before and after
your change, but I don't test it regularly.

&gt; +static inline void
&gt; +block16_xor_bytes (union nettle_block16 *r,
&gt; +		   const union nettle_block16 *x,
&gt; +		   const uint8_t *bytes)
&gt; +{
&gt; +  memxor3 (r-&gt;b, x-&gt;b, bytes, 16);
&gt; +}

[...]

&gt; +static inline void
&gt; +block8_xor_bytes (union nettle_block8 *r,
&gt; +		   const union nettle_block8 *x,
&gt; +		   const uint8_t *bytes)
&gt; +{
&gt; +  memxor3 (r-&gt;b, x-&gt;b, bytes, 8);
&gt; +}

Not sure these two wrappers are that helpful. Do you have a good
reason to add them?

The rest of the patch looks like a nice consolidation.

&gt; --- a/gcm.c
&gt; +++ b/gcm.c
&gt; @@ -53,16 +53,10 @@
&gt;  #include "nettle-internal.h"
&gt;  #include "macros.h"
&gt;  #include "ctr-internal.h"
&gt; +#include "block-internal.h"
&gt;  
&gt;  #define GHASH_POLYNOMIAL 0xE1UL
&gt;  
&gt; -static void
&gt; -gcm_gf_add (union nettle_block16 *r,
&gt; -	    const union nettle_block16 *x, const union nettle_block16 *y)
&gt; -{
&gt; -  r-&gt;u64[0] = x-&gt;u64[0] ^ y-&gt;u64[0];
&gt; -  r-&gt;u64[1] = x-&gt;u64[1] ^ y-&gt;u64[1];
&gt; -}
&gt;  /* Multiplication by 010...0; a big-endian shift right. If the bit
&gt;     shifted out is one, the defining polynomial is added to cancel it
&gt;     out. r == x is allowed. */
&gt; @@ -108,7 +102,7 @@ gcm_gf_mul (union nettle_block16 *x, const union nettle_block16 *y)
&gt;        for (j = 0; j &lt; 8; j++, b &lt;&lt;= 1)
&gt;  	{
&gt;  	  if (b &amp; 0x80)
&gt; -	    gcm_gf_add(&amp;Z, &amp;Z, &amp;V);
&gt; +	    block16_xor3(&amp;Z, &amp;Z, &amp;V);

This and few other calls below can be block16_xor rather than block16_xor3.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191002121432</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-10-02 12:14:32-0400</timestampReceived><subject>[PATCH 1/2] Implement GOST R 34.11-2012 (Streebog) hash function</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in                 |    5 +-
 examples/nettle-benchmark.c |    3 +-
 hmac-streebog.c             |   73 ++
 hmac.h                      |   33 +
 nettle-meta-hashes.c        |    2 +
 nettle-meta.h               |    2 +
 nettle.texinfo              |   72 ++
 streebog-meta.c             |   44 ++
 streebog.c                  | 1334 +++++++++++++++++++++++++++++++++++
 streebog.h                  |   99 +++
 testsuite/.gitignore        |    1 +
 testsuite/.test-rules.make  |    3 +
 testsuite/Makefile.in       |    1 +
 testsuite/hmac-test.c       |   17 +
 testsuite/meta-hash-test.c  |    2 +
 testsuite/pbkdf2-test.c     |   30 +-
 testsuite/streebog-test.c   |   81 +++
 17 files changed, 1798 insertions(+), 4 deletions(-)
 create mode 100644 hmac-streebog.c
 create mode 100644 streebog-meta.c
 create mode 100644 streebog.c
 create mode 100644 streebog.h
 create mode 100644 testsuite/streebog-test.c

diff --git a/Makefile.in b/Makefile.in
index 9f5b065a706a..c578e2901aa7 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -106,7 +106,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gost28147.c gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-gosthash94.c hmac-md5.c hmac-ripemd160.c \
 		 hmac-sha1.c hmac-sha224.c hmac-sha256.c hmac-sha384.c \
-		 hmac-sha512.c \
+		 hmac-sha512.c hmac-streebog.c \
 		 knuth-lfib.c hkdf.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
@@ -132,6 +132,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 sha3-384.c sha3-384-meta.c sha3-512.c sha3-512-meta.c\
 		 serpent-set-key.c serpent-encrypt.c serpent-decrypt.c \
 		 serpent-meta.c \
+		 streebog.c streebog-meta.c \
 		 twofish.c twofish-meta.c \
 		 umac-nh.c umac-nh-n.c umac-l2.c umac-l3.c \
 		 umac-poly64.c umac-poly128.c umac-set-key.c \
@@ -209,7 +210,7 @@ HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
 	  pbkdf2.h \
 	  pgp.h pkcs1.h pss.h pss-mgf1.h realloc.h ripemd160.h rsa.h \
 	  salsa20.h sexp.h \
-	  serpent.h sha.h sha1.h sha2.h sha3.h twofish.h \
+	  serpent.h sha.h sha1.h sha2.h sha3.h streebog.h twofish.h \
 	  umac.h yarrow.h xts.h poly1305.h
 
 INSTALL_HEADERS = $(HEADERS) version.h @IF_MINI_GMP@ mini-gmp.h
diff --git a/examples/nettle-benchmark.c b/examples/nettle-benchmark.c
index 5d0e649ea726..ea52cb44becf 100644
--- a/examples/nettle-benchmark.c
+++ b/examples/nettle-benchmark.c
@@ -918,7 +918,8 @@ main(int argc, char **argv)
       &amp;nettle_sha3_224, &amp;nettle_sha3_256,
       &amp;nettle_sha3_384, &amp;nettle_sha3_512,
       &amp;nettle_ripemd160, &amp;nettle_gosthash94,
-      &amp;nettle_gosthash94cp,
+      &amp;nettle_gosthash94cp, &amp;nettle_streebog256,
+      &amp;nettle_streebog512,
       NULL
     };
 
diff --git a/hmac-streebog.c b/hmac-streebog.c
new file mode 100644
index 000000000000..8298364bfca9
--- /dev/null
+++ b/hmac-streebog.c
@@ -0,0 +1,73 @@
+/* hmac-streebog.c
+
+   HMAC-Streebog message authentication code.
+
+   Copyright (C) 2016 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "hmac.h"
+
+void
+hmac_streebog512_set_key(struct hmac_streebog512_ctx *ctx,
+		    size_t key_length, const uint8_t *key)
+{
+  HMAC_SET_KEY(ctx, &amp;nettle_streebog512, key_length, key);
+}
+
+void
+hmac_streebog512_update(struct hmac_streebog512_ctx *ctx,
+		   size_t length, const uint8_t *data)
+{
+  streebog512_update(&amp;ctx-&gt;state, length, data);
+}
+
+void
+hmac_streebog512_digest(struct hmac_streebog512_ctx *ctx,
+		   size_t length, uint8_t *digest)
+{
+  HMAC_DIGEST(ctx, &amp;nettle_streebog512, length, digest);
+}
+
+void
+hmac_streebog256_set_key(struct hmac_streebog256_ctx *ctx,
+		    size_t key_length, const uint8_t *key)
+{
+  HMAC_SET_KEY(ctx, &amp;nettle_streebog256, key_length, key);
+}
+
+void
+hmac_streebog256_digest(struct hmac_streebog256_ctx *ctx,
+		   size_t length, uint8_t *digest)
+{
+  HMAC_DIGEST(ctx, &amp;nettle_streebog256, length, digest);
+}
diff --git a/hmac.h b/hmac.h
index d9ee3400108d..72c8fd5768c4 100644
--- a/hmac.h
+++ b/hmac.h
@@ -41,6 +41,7 @@
 #include "ripemd160.h"
 #include "sha1.h"
 #include "sha2.h"
+#include "streebog.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -75,6 +76,11 @@ extern "C" {
 #define hmac_gosthash94cp_set_key nettle_hmac_gosthash94cp_set_key
 #define hmac_gosthash94cp_update nettle_hmac_gosthash94cp_update
 #define hmac_gosthash94cp_digest nettle_hmac_gosthash94cp_digest
+#define hmac_streebog256_set_key nettle_hmac_streebog256_set_key
+#define hmac_streebog256_digest nettle_hmac_streebog256_digest
+#define hmac_streebog512_set_key nettle_hmac_streebog512_set_key
+#define hmac_streebog512_update nettle_hmac_streebog512_update
+#define hmac_streebog512_digest nettle_hmac_streebog512_digest
 
 void
 hmac_set_key(void *outer, void *inner, void *state,
@@ -240,6 +246,33 @@ hmac_gosthash94cp_digest(struct hmac_gosthash94cp_ctx *ctx,
 			 size_t length, uint8_t *digest);
 
 
+/* hmac-streebog */
+struct hmac_streebog512_ctx HMAC_CTX(struct streebog512_ctx);
+
+void
+hmac_streebog512_set_key(struct hmac_streebog512_ctx *ctx,
+		    size_t key_length, const uint8_t *key);
+
+void
+hmac_streebog512_update(struct hmac_streebog512_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+hmac_streebog512_digest(struct hmac_streebog512_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
+#define hmac_streebog256_ctx hmac_streebog512_ctx
+
+void
+hmac_streebog256_set_key(struct hmac_streebog256_ctx *ctx,
+		    size_t key_length, const uint8_t *key);
+
+#define hmac_streebog256_update hmac_streebog512_update
+
+void
+hmac_streebog256_digest(struct hmac_streebog256_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/nettle-meta-hashes.c b/nettle-meta-hashes.c
index 27b576cdc58c..8e96dd414d23 100644
--- a/nettle-meta-hashes.c
+++ b/nettle-meta-hashes.c
@@ -53,6 +53,8 @@ const struct nettle_hash * const _nettle_hashes[] = {
   &amp;nettle_sha3_256,
   &amp;nettle_sha3_384,
   &amp;nettle_sha3_512,
+  &amp;nettle_streebog256,
+  &amp;nettle_streebog512,
   NULL
 };
 
diff --git a/nettle-meta.h b/nettle-meta.h
index b4cdb8f3e378..fff59eb23400 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -143,6 +143,8 @@ extern const struct nettle_hash nettle_sha3_224;
 extern const struct nettle_hash nettle_sha3_256;
 extern const struct nettle_hash nettle_sha3_384;
 extern const struct nettle_hash nettle_sha3_512;
+extern const struct nettle_hash nettle_streebog256;
+extern const struct nettle_hash nettle_streebog512;
 
 struct nettle_aead
 {
diff --git a/nettle.texinfo b/nettle.texinfo
index 9a3ca04e0a7f..fc2a846662d2 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -834,6 +834,78 @@ octets of the digest are written.
 This function also resets the context.
 @end deftypefun
 
+@subsubsection @acronym{STREEBOG512}
+
+STREEBOG512 is a member of the Streebog (GOST R 34.11-2012) family.  It outputs
+hash values of 512 bits, or 64 octets. Nettle defines STREEBOG512 in
+@file{&lt;nettle/streebog.h&gt;}.
+
+@deftp {Context struct} {struct streebog512_ctx}
+@end deftp
+
+@defvr Constant STREEBOG512_DIGEST_SIZE
+The size of a STREEBOG512 digest, i.e. 64.
+@end defvr
+
+@defvr Constant STREEBOG512_BLOCK_SIZE
+The internal block size of STREEBOG512. Useful for some special constructions,
+in particular HMAC-STREEBOG512.
+@end defvr
+
+@deftypefun void streebog512_init (struct streebog512_ctx *@var{ctx})
+Initialize the STREEBOG512 state.
+@end deftypefun
+
+@deftypefun void streebog512_update (struct streebog512_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +Hash some more data.
+@end deftypefun
+
+@deftypefun void streebog512_digest (struct streebog512_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Performs final processing and extracts the \
message digest, writing it +to @var{digest}. @var{length} may be smaller than
+@code{STREEBOG512_DIGEST_SIZE}, in which case only the first @var{length}
+octets of the digest are written.
+
+This function also resets the context in the same way as
+@code{streebog512_init}.
+@end deftypefun
+
+@subsubsection @acronym{STREEBOG256}
+
+STREEBOG256 is a variant of STREEBOG512, with a different initial state, and with
+the output truncated to 256 bits, or 32 octets. Nettle defines STREEBOG256 in
+@file{&lt;nettle/streebog.h&gt;}.
+
+@deftp {Context struct} {struct streebog256_ctx}
+@end deftp
+
+@defvr Constant STREEBOG256_DIGEST_SIZE
+The size of a STREEBOG256 digest, i.e. 32.
+@end defvr
+
+@defvr Constant STREEBOG256_BLOCK_SIZE
+The internal block size of STREEBOG256. Useful for some special constructions,
+in particular HMAC-STREEBOG256.
+@end defvr
+
+@deftypefun void streebog256_init (struct streebog256_ctx *@var{ctx})
+Initialize the STREEBOG256 state.
+@end deftypefun
+
+@deftypefun void streebog256_update (struct streebog256_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +Hash some more data.
+@end deftypefun
+
+@deftypefun void streebog256_digest (struct streebog256_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +Performs final processing and extracts the \
message digest, writing it +to @var{digest}. @var{length} may be smaller than
+@code{STREEBOG256_DIGEST_SIZE}, in which case only the first @var{length}
+octets of the digest are written.
+
+This function also resets the context in the same way as
+@code{streebog256_init}.
+@end deftypefun
+
 @node Legacy hash functions, nettle_hash abstraction, Recommended hash functions, \
Hash functions  @comment  node-name,  next,  previous,  up
 @subsection Legacy hash functions
diff --git a/streebog-meta.c b/streebog-meta.c
new file mode 100644
index 000000000000..b8284d5c2b0d
--- /dev/null
+++ b/streebog-meta.c
@@ -0,0 +1,44 @@
+/* streebog-meta.c
+
+   Copyright (C) 2012 Nikos Mavrogiannopoulos, Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "nettle-meta.h"
+
+#include "streebog.h"
+
+const struct nettle_hash nettle_streebog512
+= _NETTLE_HASH(streebog512, STREEBOG512);
+
+const struct nettle_hash nettle_streebog256
+= _NETTLE_HASH(streebog256, STREEBOG256);
diff --git a/streebog.c b/streebog.c
new file mode 100644
index 000000000000..fe8f9359d238
--- /dev/null
+++ b/streebog.c
@@ -0,0 +1,1334 @@
+/* streebog.c - GOST R 34.11-2012 (Streebog) hash function
+
+   Copyright (C) 2013-2015 Dmitry Eremin-Solenikov
+
+   Based on my code in libgcrypt.
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "streebog.h"
+
+#include "macros.h"
+#include "nettle-write.h"
+
+
+/* Pre-computed results of multiplication of bytes on A and reordered with
+   Pi[]. */
+static const uint64_t streebog_table[8][256] =
+{
+  /* 0 */
+  { 0xd01f715b5c7ef8e6ULL, 0x16fa240980778325ULL,
+    0xa8a42e857ee049c8ULL, 0x6ac1068fa186465bULL,
+    0x6e417bd7a2e9320bULL, 0x665c8167a437daabULL,
+    0x7666681aa89617f6ULL, 0x4b959163700bdcf5ULL,
+    0xf14be6b78df36248ULL, 0xc585bd689a625cffULL,
+    0x9557d7fca67d82cbULL, 0x89f0b969af6dd366ULL,
+    0xb0833d48749f6c35ULL, 0xa1998c23b1ecbc7cULL,
+    0x8d70c431ac02a736ULL, 0xd6dfbc2fd0a8b69eULL,
+    0x37aeb3e551fa198bULL, 0x0b7d128a40b5cf9cULL,
+    0x5a8f2008b5780cbcULL, 0xedec882284e333e5ULL,
+    0xd25fc177d3c7c2ceULL, 0x5e0f5d50b61778ecULL,
+    0x1d873683c0c24cb9ULL, 0xad040bcbb45d208cULL,
+    0x2f89a0285b853c76ULL, 0x5732fff6791b8d58ULL,
+    0x3e9311439ef6ec3fULL, 0xc9183a809fd3c00fULL,
+    0x83adf3f5260a01eeULL, 0xa6791941f4e8ef10ULL,
+    0x103ae97d0ca1cd5dULL, 0x2ce948121dee1b4aULL,
+    0x39738421dbf2bf53ULL, 0x093da2a6cf0cf5b4ULL,
+    0xcd9847d89cbcb45fULL, 0xf9561c078b2d8ae8ULL,
+    0x9c6a755a6971777fULL, 0xbc1ebaa0712ef0c5ULL,
+    0x72e61542abf963a6ULL, 0x78bb5fde229eb12eULL,
+    0x14ba94250fceb90dULL, 0x844d6697630e5282ULL,
+    0x98ea08026a1e032fULL, 0xf06bbea144217f5cULL,
+    0xdb6263d11ccb377aULL, 0x641c314b2b8ee083ULL,
+    0x320e96ab9b4770cfULL, 0x1ee7deb986a96b85ULL,
+    0xe96cf57a878c47b5ULL, 0xfdd6615f8842feb8ULL,
+    0xc83862965601dd1bULL, 0x2ea9f83e92572162ULL,
+    0xf876441142ff97fcULL, 0xeb2c455608357d9dULL,
+    0x5612a7e0b0c9904cULL, 0x6c01cbfb2d500823ULL,
+    0x4548a6a7fa037a2dULL, 0xabc4c6bf388b6ef4ULL,
+    0xbade77d4fdf8bebdULL, 0x799b07c8eb4cac3aULL,
+    0x0c9d87e805b19cf0ULL, 0xcb588aac106afa27ULL,
+    0xea0c1d40c1e76089ULL, 0x2869354a1e816f1aULL,
+    0xff96d17307fbc490ULL, 0x9f0a9d602f1a5043ULL,
+    0x96373fc6e016a5f7ULL, 0x5292dab8b3a6e41cULL,
+    0x9b8ae0382c752413ULL, 0x4f15ec3b7364a8a5ULL,
+    0x3fb349555724f12bULL, 0xc7c50d4415db66d7ULL,
+    0x92b7429ee379d1a7ULL, 0xd37f99611a15dfdaULL,
+    0x231427c05e34a086ULL, 0xa439a96d7b51d538ULL,
+    0xb403401077f01865ULL, 0xdda2aea5901d7902ULL,
+    0x0a5d4a9c8967d288ULL, 0xc265280adf660f93ULL,
+    0x8bb0094520d4e94eULL, 0x2a29856691385532ULL,
+    0x42a833c5bf072941ULL, 0x73c64d54622b7eb2ULL,
+    0x07e095624504536cULL, 0x8a905153e906f45aULL,
+    0x6f6123c16b3b2f1fULL, 0xc6e55552dc097bc3ULL,
+    0x4468feb133d16739ULL, 0xe211e7f0c7398829ULL,
+    0xa2f96419f7879b40ULL, 0x19074bdbc3ad38e9ULL,
+    0xf4ebc3f9474e0b0cULL, 0x43886bd376d53455ULL,
+    0xd8028beb5aa01046ULL, 0x51f23282f5cdc320ULL,
+    0xe7b1c2be0d84e16dULL, 0x081dfab006dee8a0ULL,
+    0x3b33340d544b857bULL, 0x7f5bcabc679ae242ULL,
+    0x0edd37c48a08a6d8ULL, 0x81ed43d9a9b33bc6ULL,
+    0xb1a3655ebd4d7121ULL, 0x69a1eeb5e7ed6167ULL,
+    0xf6ab73d5c8f73124ULL, 0x1a67a3e185c61fd5ULL,
+    0x2dc91004d43c065eULL, 0x0240b02c8fb93a28ULL,
+    0x90f7f2b26cc0eb8fULL, 0x3cd3a16f114fd617ULL,
+    0xaae49ea9f15973e0ULL, 0x06c0cd748cd64e78ULL,
+    0xda423bc7d5192a6eULL, 0xc345701c16b41287ULL,
+    0x6d2193ede4821537ULL, 0xfcf639494190e3acULL,
+    0x7c3b228621f1c57eULL, 0xfb16ac2b0494b0c0ULL,
+    0xbf7e529a3745d7f9ULL, 0x6881b6a32e3f7c73ULL,
+    0xca78d2bad9b8e733ULL, 0xbbfe2fc2342aa3a9ULL,
+    0x0dbddffecc6381e4ULL, 0x70a6a56e2440598eULL,
+    0xe4d12a844befc651ULL, 0x8c509c2765d0ba22ULL,
+    0xee8c6018c28814d9ULL, 0x17da7c1f49a59e31ULL,
+    0x609c4c1328e194d3ULL, 0xb3e3d57232f44b09ULL,
+    0x91d7aaa4a512f69bULL, 0x0ffd6fd243dabbccULL,
+    0x50d26a943c1fde34ULL, 0x6be15e9968545b4fULL,
+    0x94778fea6faf9fdfULL, 0x2b09dd7058ea4826ULL,
+    0x677cd9716de5c7bfULL, 0x49d5214fffb2e6ddULL,
+    0x0360e83a466b273cULL, 0x1fc786af4f7b7691ULL,
+    0xa0b9d435783ea168ULL, 0xd49f0c035f118cb6ULL,
+    0x01205816c9d21d14ULL, 0xac2453dd7d8f3d98ULL,
+    0x545217cc3f70aa64ULL, 0x26b4028e9489c9c2ULL,
+    0xdec2469fd6765e3eULL, 0x04807d58036f7450ULL,
+    0xe5f17292823ddb45ULL, 0xf30b569b024a5860ULL,
+    0x62dcfc3fa758aefbULL, 0xe84cad6c4e5e5aa1ULL,
+    0xccb81fce556ea94bULL, 0x53b282ae7a74f908ULL,
+    0x1b47fbf74c1402c1ULL, 0x368eebf39828049fULL,
+    0x7afbeff2ad278b06ULL, 0xbe5e0a8cfe97caedULL,
+    0xcfd8f7f413058e77ULL, 0xf78b2bc301252c30ULL,
+    0x4d555c17fcdd928dULL, 0x5f2f05467fc565f8ULL,
+    0x24f4b2a21b30f3eaULL, 0x860dd6bbecb768aaULL,
+    0x4c750401350f8f99ULL, 0x0000000000000000ULL,
+    0xecccd0344d312ef1ULL, 0xb5231806be220571ULL,
+    0xc105c030990d28afULL, 0x653c695de25cfd97ULL,
+    0x159acc33c61ca419ULL, 0xb89ec7f872418495ULL,
+    0xa9847693b73254dcULL, 0x58cf90243ac13694ULL,
+    0x59efc832f3132b80ULL, 0x5c4fed7c39ae42c4ULL,
+    0x828dabe3efd81cfaULL, 0xd13f294d95ace5f2ULL,
+    0x7d1b7a90e823d86aULL, 0xb643f03cf849224dULL,
+    0x3df3f979d89dcb03ULL, 0x7426d836272f2ddeULL,
+    0xdfe21e891fa4432aULL, 0x3a136c1b9d99986fULL,
+    0xfa36f43dcd46add4ULL, 0xc025982650df35bbULL,
+    0x856d3e81aadc4f96ULL, 0xc4a5e57e53b041ebULL,
+    0x4708168b75ba4005ULL, 0xaf44bbe73be41aa4ULL,
+    0x971767d029c4b8e3ULL, 0xb9be9feebb939981ULL,
+    0x215497ecd18d9aaeULL, 0x316e7e91dd2c57f3ULL,
+    0xcef8afe2dad79363ULL, 0x3853dc371220a247ULL,
+    0x35ee03c9de4323a3ULL, 0xe6919aa8c456fc79ULL,
+    0xe05157dc4880b201ULL, 0x7bdbb7e464f59612ULL,
+    0x127a59518318f775ULL, 0x332ecebd52956ddbULL,
+    0x8f30741d23bb9d1eULL, 0xd922d3fd93720d52ULL,
+    0x7746300c61440ae2ULL, 0x25d4eab4d2e2eefeULL,
+    0x75068020eefd30caULL, 0x135a01474acaea61ULL,
+    0x304e268714fe4ae7ULL, 0xa519f17bb283c82cULL,
+    0xdc82f6b359cf6416ULL, 0x5baf781e7caa11a8ULL,
+    0xb2c38d64fb26561dULL, 0x34ce5bdf17913eb7ULL,
+    0x5d6fb56af07c5fd0ULL, 0x182713cd0a7f25fdULL,
+    0x9e2ac576e6c84d57ULL, 0x9aaab82ee5a73907ULL,
+    0xa3d93c0f3e558654ULL, 0x7e7b92aaae48ff56ULL,
+    0x872d8ead256575beULL, 0x41c8dbfff96c0e7dULL,
+    0x99ca5014a3cc1e3bULL, 0x40e883e930be1369ULL,
+    0x1ca76e95091051adULL, 0x4e35b42dbab6b5b1ULL,
+    0x05a0254ecabd6944ULL, 0xe1710fca8152af15ULL,
+    0xf22b0e8dcb984574ULL, 0xb763a82a319b3f59ULL,
+    0x63fca4296e8ab3efULL, 0x9d4a2d4ca0a36a6bULL,
+    0xe331bfe60eeb953dULL, 0xd5bf541596c391a2ULL,
+    0xf5cb9bef8e9c1618ULL, 0x46284e9dbc685d11ULL,
+    0x2074cffa185f87baULL, 0xbd3ee2b6b8fcedd1ULL,
+    0xae64e3f1f23607b0ULL, 0xfeb68965ce29d984ULL,
+    0x55724fdaf6a2b770ULL, 0x29496d5cd753720eULL,
+    0xa75941573d3af204ULL, 0x8e102c0bea69800aULL,
+    0x111ab16bc573d049ULL, 0xd7ffe439197aab8aULL,
+    0xefac380e0b5a09cdULL, 0x48f579593660fbc9ULL,
+    0x22347fd697e6bd92ULL, 0x61bc1405e13389c7ULL,
+    0x4ab5c975b9d9c1e1ULL, 0x80cd1bcf606126d2ULL,
+    0x7186fd78ed92449aULL, 0x93971a882aabccb3ULL,
+    0x88d0e17f66bfce72ULL, 0x27945a985d5bd4d6ULL },
+  /* 1 */
+  { 0xde553f8c05a811c8ULL, 0x1906b59631b4f565ULL,
+    0x436e70d6b1964ff7ULL, 0x36d343cb8b1e9d85ULL,
+    0x843dfacc858aab5aULL, 0xfdfc95c299bfc7f9ULL,
+    0x0f634bdea1d51fa2ULL, 0x6d458b3b76efb3cdULL,
+    0x85c3f77cf8593f80ULL, 0x3c91315fbe737cb2ULL,
+    0x2148b03366ace398ULL, 0x18f8b8264c6761bfULL,
+    0xc830c1c495c9fb0fULL, 0x981a76102086a0aaULL,
+    0xaa16012142f35760ULL, 0x35cc54060c763cf6ULL,
+    0x42907d66cc45db2dULL, 0x8203d44b965af4bcULL,
+    0x3d6f3cefc3a0e868ULL, 0xbc73ff69d292bda7ULL,
+    0x8722ed0102e20a29ULL, 0x8f8185e8cd34deb7ULL,
+    0x9b0561dda7ee01d9ULL, 0x5335a0193227fad6ULL,
+    0xc9cecc74e81a6fd5ULL, 0x54f5832e5c2431eaULL,
+    0x99e47ba05d553470ULL, 0xf7bee756acd226ceULL,
+    0x384e05a5571816fdULL, 0xd1367452a47d0e6aULL,
+    0xf29fde1c386ad85bULL, 0x320c77316275f7caULL,
+    0xd0c879e2d9ae9ab0ULL, 0xdb7406c69110ef5dULL,
+    0x45505e51a2461011ULL, 0xfc029872e46c5323ULL,
+    0xfa3cb6f5f7bc0cc5ULL, 0x031f17cd8768a173ULL,
+    0xbd8df2d9af41297dULL, 0x9d3b4f5ab43e5e3fULL,
+    0x4071671b36feee84ULL, 0x716207e7d3e3b83dULL,
+    0x48d20ff2f9283a1aULL, 0x27769eb4757cbc7eULL,
+    0x5c56ebc793f2e574ULL, 0xa48b474f9ef5dc18ULL,
+    0x52cbada94ff46e0cULL, 0x60c7da982d8199c6ULL,
+    0x0e9d466edc068b78ULL, 0x4eec2175eaf865fcULL,
+    0x550b8e9e21f7a530ULL, 0x6b7ba5bc653fec2bULL,
+    0x5eb7f1ba6949d0ddULL, 0x57ea94e3db4c9099ULL,
+    0xf640eae6d101b214ULL, 0xdd4a284182c0b0bbULL,
+    0xff1d8fbf6304f250ULL, 0xb8accb933bf9d7e8ULL,
+    0xe8867c478eb68c4dULL, 0x3f8e2692391bddc1ULL,
+    0xcb2fd60912a15a7cULL, 0xaec935dbab983d2fULL,
+    0xf55ffd2b56691367ULL, 0x80e2ce366ce1c115ULL,
+    0x179bf3f8edb27e1dULL, 0x01fe0db07dd394daULL,
+    0xda8a0b76ecc37b87ULL, 0x44ae53e1df9584cbULL,
+    0xb310b4b77347a205ULL, 0xdfab323c787b8512ULL,
+    0x3b511268d070b78eULL, 0x65e6e3d2b9396753ULL,
+    0x6864b271e2574d58ULL, 0x259784c98fc789d7ULL,
+    0x02e11a7dfabb35a9ULL, 0x8841a6dfa337158bULL,
+    0x7ade78c39b5dcdd0ULL, 0xb7cf804d9a2cc84aULL,
+    0x20b6bd831b7f7742ULL, 0x75bd331d3a88d272ULL,
+    0x418f6aab4b2d7a5eULL, 0xd9951cbb6babdaf4ULL,
+    0xb6318dfde7ff5c90ULL, 0x1f389b112264aa83ULL,
+    0x492c024284fbaec0ULL, 0xe33a0363c608f9a0ULL,
+    0x2688930408af28a4ULL, 0xc7538a1a341ce4adULL,
+    0x5da8e677ee2171aeULL, 0x8c9e92254a5c7fc4ULL,
+    0x63d8cd55aae938b5ULL, 0x29ebd8daa97a3706ULL,
+    0x959827b37be88aa1ULL, 0x1484e4356adadf6eULL,
+    0xa7945082199d7d6bULL, 0xbf6ce8a455fa1cd4ULL,
+    0x9cc542eac9edcae5ULL, 0x79c16f0e1c356ca3ULL,
+    0x89bfab6fdee48151ULL, 0xd4174d1830c5f0ffULL,
+    0x9258048415eb419dULL, 0x6139d72850520d1cULL,
+    0x6a85a80c18ec78f1ULL, 0xcd11f88e0171059aULL,
+    0xcceff53e7ca29140ULL, 0xd229639f2315af19ULL,
+    0x90b91ef9ef507434ULL, 0x5977d28d074a1be1ULL,
+    0x311360fce51d56b9ULL, 0xc093a92d5a1f2f91ULL,
+    0x1a19a25bb6dc5416ULL, 0xeb996b8a09de2d3eULL,
+    0xfee3820f1ed7668aULL, 0xd7085ad5b7ad518cULL,
+    0x7fff41890fe53345ULL, 0xec5948bd67dde602ULL,
+    0x2fd5f65dbaaa68e0ULL, 0xa5754affe32648c2ULL,
+    0xf8ddac880d07396cULL, 0x6fa491468c548664ULL,
+    0x0c7c5c1326bdbed1ULL, 0x4a33158f03930fb3ULL,
+    0x699abfc19f84d982ULL, 0xe4fa2054a80b329cULL,
+    0x6707f9af438252faULL, 0x08a368e9cfd6d49eULL,
+    0x47b1442c58fd25b8ULL, 0xbbb3dc5ebc91769bULL,
+    0x1665fe489061eac7ULL, 0x33f27a811fa66310ULL,
+    0x93a609346838d547ULL, 0x30ed6d4c98cec263ULL,
+    0x1dd9816cd8df9f2aULL, 0x94662a03063b1e7bULL,
+    0x83fdd9fbeb896066ULL, 0x7b207573e68e590aULL,
+    0x5f49fc0a149a4407ULL, 0x343259b671a5a82cULL,
+    0xfbc2bb458a6f981fULL, 0xc272b350a0a41a38ULL,
+    0x3aaf1fd8ada32354ULL, 0x6cbb868b0b3c2717ULL,
+    0xa2b569c88d2583feULL, 0xf180c9d1bf027928ULL,
+    0xaf37386bd64ba9f5ULL, 0x12bacab2790a8088ULL,
+    0x4c0d3b0810435055ULL, 0xb2eeb9070e9436dfULL,
+    0xc5b29067cea7d104ULL, 0xdcb425f1ff132461ULL,
+    0x4f122cc5972bf126ULL, 0xac282fa651230886ULL,
+    0xe7e537992f6393efULL, 0xe61b3a2952b00735ULL,
+    0x709c0a57ae302ce7ULL, 0xe02514ae416058d3ULL,
+    0xc44c9dd7b37445deULL, 0x5a68c5408022ba92ULL,
+    0x1c278cdca50c0bf0ULL, 0x6e5a9cf6f18712beULL,
+    0x86dce0b17f319ef3ULL, 0x2d34ec2040115d49ULL,
+    0x4bcd183f7e409b69ULL, 0x2815d56ad4a9a3dcULL,
+    0x24698979f2141d0dULL, 0x0000000000000000ULL,
+    0x1ec696a15fb73e59ULL, 0xd86b110b16784e2eULL,
+    0x8e7f8858b0e74a6dULL, 0x063e2e8713d05fe6ULL,
+    0xe2c40ed3bbdb6d7aULL, 0xb1f1aeca89fc97acULL,
+    0xe1db191e3cb3cc09ULL, 0x6418ee62c4eaf389ULL,
+    0xc6ad87aa49cf7077ULL, 0xd6f65765ca7ec556ULL,
+    0x9afb6c6dda3d9503ULL, 0x7ce05644888d9236ULL,
+    0x8d609f95378feb1eULL, 0x23a9aa4e9c17d631ULL,
+    0x6226c0e5d73aac6fULL, 0x56149953a69f0443ULL,
+    0xeeb852c09d66d3abULL, 0x2b0ac2a753c102afULL,
+    0x07c023376e03cb3cULL, 0x2ccae1903dc2c993ULL,
+    0xd3d76e2f5ec63bc3ULL, 0x9e2458973356ff4cULL,
+    0xa66a5d32644ee9b1ULL, 0x0a427294356de137ULL,
+    0x783f62be61e6f879ULL, 0x1344c70204d91452ULL,
+    0x5b96c8f0fdf12e48ULL, 0xa90916ecc59bf613ULL,
+    0xbe92e5142829880eULL, 0x727d102a548b194eULL,
+    0x1be7afebcb0fc0ccULL, 0x3e702b2244c8491bULL,
+    0xd5e940a84d166425ULL, 0x66f9f41f3e51c620ULL,
+    0xabe80c913f20c3baULL, 0xf07ec461c2d1edf2ULL,
+    0xf361d3ac45b94c81ULL, 0x0521394a94b8fe95ULL,
+    0xadd622162cf09c5cULL, 0xe97871f7f3651897ULL,
+    0xf4a1f09b2bba87bdULL, 0x095d6559b2054044ULL,
+    0x0bbc7f2448be75edULL, 0x2af4cf172e129675ULL,
+    0x157ae98517094bb4ULL, 0x9fda55274e856b96ULL,
+    0x914713499283e0eeULL, 0xb952c623462a4332ULL,
+    0x74433ead475b46a8ULL, 0x8b5eb112245fb4f8ULL,
+    0xa34b6478f0f61724ULL, 0x11a5dd7ffe6221fbULL,
+    0xc16da49d27ccbb4bULL, 0x76a224d0bde07301ULL,
+    0x8aa0bca2598c2022ULL, 0x4df336b86d90c48fULL,
+    0xea67663a740db9e4ULL, 0xef465f70e0b54771ULL,
+    0x39b008152acb8227ULL, 0x7d1e5bf4f55e06ecULL,
+    0x105bd0cf83b1b521ULL, 0x775c2960c033e7dbULL,
+    0x7e014c397236a79fULL, 0x811cc386113255cfULL,
+    0xeda7450d1a0e72d8ULL, 0x5889df3d7a998f3bULL,
+    0x2e2bfbedc779fc3aULL, 0xce0eef438619a4e9ULL,
+    0x372d4e7bf6cd095fULL, 0x04df34fae96b6a4fULL,
+    0xf923a13870d4adb6ULL, 0xa1aa7e050a4d228dULL,
+    0xa8f71b5cb84862c9ULL, 0xb52e9a306097fde3ULL,
+    0x0d8251a35b6e2a0bULL, 0x2257a7fee1c442ebULL,
+    0x73831d9a29588d94ULL, 0x51d4ba64c89ccf7fULL,
+    0x502ab7d4b54f5ba5ULL, 0x97793dce8153bf08ULL,
+    0xe5042de4d5d8a646ULL, 0x9687307efc802bd2ULL,
+    0xa05473b5779eb657ULL, 0xb4d097801d446939ULL,
+    0xcff0e2f3fbca3033ULL, 0xc38cbee0dd778ee2ULL,
+    0x464f499c252eb162ULL, 0xcad1dbb96f72cea6ULL,
+    0xba4dd1eec142e241ULL, 0xb00fa37af42f0376ULL },
+  /* 2 */
+  { 0xcce4cd3aa968b245ULL, 0x089d5484e80b7fafULL,
+    0x638246c1b3548304ULL, 0xd2fe0ec8c2355492ULL,
+    0xa7fbdf7ff2374eeeULL, 0x4df1600c92337a16ULL,
+    0x84e503ea523b12fbULL, 0x0790bbfd53ab0c4aULL,
+    0x198a780f38f6ea9dULL, 0x2ab30c8f55ec48cbULL,
+    0xe0f7fed6b2c49db5ULL, 0xb6ecf3f422cadbdcULL,
+    0x409c9a541358df11ULL, 0xd3ce8a56dfde3fe3ULL,
+    0xc3e9224312c8c1a0ULL, 0x0d6dfa58816ba507ULL,
+    0xddf3e1b179952777ULL, 0x04c02a42748bb1d9ULL,
+    0x94c2abff9f2decb8ULL, 0x4f91752da8f8acf4ULL,
+    0x78682befb169bf7bULL, 0xe1c77a48af2ff6c4ULL,
+    0x0c5d7ec69c80ce76ULL, 0x4cc1e4928fd81167ULL,
+    0xfeed3d24d9997b62ULL, 0x518bb6dfc3a54a23ULL,
+    0x6dbf2d26151f9b90ULL, 0xb5bc624b05ea664fULL,
+    0xe86aaa525acfe21aULL, 0x4801ced0fb53a0beULL,
+    0xc91463e6c00868edULL, 0x1027a815cd16fe43ULL,
+    0xf67069a0319204cdULL, 0xb04ccc976c8abce7ULL,
+    0xc0b9b3fc35e87c33ULL, 0xf380c77c58f2de65ULL,
+    0x50bb3241de4e2152ULL, 0xdf93f490435ef195ULL,
+    0xf1e0d25d62390887ULL, 0xaf668bfb1a3c3141ULL,
+    0xbc11b251f00a7291ULL, 0x73a5eed47e427d47ULL,
+    0x25bee3f6ee4c3b2eULL, 0x43cc0beb34786282ULL,
+    0xc824e778dde3039cULL, 0xf97d86d98a327728ULL,
+    0xf2b043e24519b514ULL, 0xe297ebf7880f4b57ULL,
+    0x3a94a49a98fab688ULL, 0x868516cb68f0c419ULL,
+    0xeffa11af0964ee50ULL, 0xa4ab4ec0d517f37dULL,
+    0xa9c6b498547c567aULL, 0x8e18424f80fbbbb6ULL,
+    0x0bcdc53bcf2bc23cULL, 0x137739aaea3643d0ULL,
+    0x2c1333ec1bac2ff0ULL, 0x8d48d3f0a7db0625ULL,
+    0x1e1ac3f26b5de6d7ULL, 0xf520f81f16b2b95eULL,
+    0x9f0f6ec450062e84ULL, 0x0130849e1deb6b71ULL,
+    0xd45e31ab8c7533a9ULL, 0x652279a2fd14e43fULL,
+    0x3209f01e70f1c927ULL, 0xbe71a770cac1a473ULL,
+    0x0e3d6be7a64b1894ULL, 0x7ec8148cff29d840ULL,
+    0xcb7476c7fac3be0fULL, 0x72956a4a63a91636ULL,
+    0x37f95ec21991138fULL, 0x9e3fea5a4ded45f5ULL,
+    0x7b38ba50964902e8ULL, 0x222e580bbde73764ULL,
+    0x61e253e0899f55e6ULL, 0xfc8d2805e352ad80ULL,
+    0x35994be3235ac56dULL, 0x09add01af5e014deULL,
+    0x5e8659a6780539c6ULL, 0xb17c48097161d796ULL,
+    0x026015213acbd6e2ULL, 0xd1ae9f77e515e901ULL,
+    0xb7dc776a3f21b0adULL, 0xaba6a1b96eb78098ULL,
+    0x9bcf4486248d9f5dULL, 0x582666c536455efdULL,
+    0xfdbdac9bfeb9c6f1ULL, 0xc47999be4163cdeaULL,
+    0x765540081722a7efULL, 0x3e548ed8ec710751ULL,
+    0x3d041f67cb51bac2ULL, 0x7958af71ac82d40aULL,
+    0x36c9da5c047a78feULL, 0xed9a048e33af38b2ULL,
+    0x26ee7249c96c86bdULL, 0x900281bdeba65d61ULL,
+    0x11172c8bd0fd9532ULL, 0xea0abf73600434f8ULL,
+    0x42fc8f75299309f3ULL, 0x34a9cf7d3eb1ae1cULL,
+    0x2b838811480723baULL, 0x5ce64c8742ceef24ULL,
+    0x1adae9b01fd6570eULL, 0x3c349bf9d6bad1b3ULL,
+    0x82453c891c7b75c0ULL, 0x97923a40b80d512bULL,
+    0x4a61dbf1c198765cULL, 0xb48ce6d518010d3eULL,
+    0xcfb45c858e480fd6ULL, 0xd933cbf30d1e96aeULL,
+    0xd70ea014ab558e3aULL, 0xc189376228031742ULL,
+    0x9262949cd16d8b83ULL, 0xeb3a3bed7def5f89ULL,
+    0x49314a4ee6b8cbcfULL, 0xdcc3652f647e4c06ULL,
+    0xda635a4c2a3e2b3dULL, 0x470c21a940f3d35bULL,
+    0x315961a157d174b4ULL, 0x6672e81dda3459acULL,
+    0x5b76f77a1165e36eULL, 0x445cb01667d36ec8ULL,
+    0xc5491d205c88a69bULL, 0x456c34887a3805b9ULL,
+    0xffddb9bac4721013ULL, 0x99af51a71e4649bfULL,
+    0xa15be01cbc7729d5ULL, 0x52db2760e485f7b0ULL,
+    0x8c78576eba306d54ULL, 0xae560f6507d75a30ULL,
+    0x95f22f6182c687c9ULL, 0x71c5fbf54489aba5ULL,
+    0xca44f259e728d57eULL, 0x88b87d2ccebbdc8dULL,
+    0xbab18d32be4a15aaULL, 0x8be8ec93e99b611eULL,
+    0x17b713e89ebdf209ULL, 0xb31c5d284baa0174ULL,
+    0xeeca9531148f8521ULL, 0xb8d198138481c348ULL,
+    0x8988f9b2d350b7fcULL, 0xb9e11c8d996aa839ULL,
+    0x5a4673e40c8e881fULL, 0x1687977683569978ULL,
+    0xbf4123eed72acf02ULL, 0x4ea1f1b3b513c785ULL,
+    0xe767452be16f91ffULL, 0x7505d1b730021a7cULL,
+    0xa59bca5ec8fc980cULL, 0xad069eda20f7e7a3ULL,
+    0x38f4b1bba231606aULL, 0x60d2d77e94743e97ULL,
+    0x9affc0183966f42cULL, 0x248e6768f3a7505fULL,
+    0xcdd449a4b483d934ULL, 0x87b59255751baf68ULL,
+    0x1bea6d2e023d3c7fULL, 0x6b1f12455b5ffcabULL,
+    0x743555292de9710dULL, 0xd8034f6d10f5fddfULL,
+    0xc6198c9f7ba81b08ULL, 0xbb8109aca3a17edbULL,
+    0xfa2d1766ad12cabbULL, 0xc729080166437079ULL,
+    0x9c5fff7b77269317ULL, 0x0000000000000000ULL,
+    0x15d706c9a47624ebULL, 0x6fdf38072fd44d72ULL,
+    0x5fb6dd3865ee52b7ULL, 0xa33bf53d86bcff37ULL,
+    0xe657c1b5fc84fa8eULL, 0xaa962527735cebe9ULL,
+    0x39c43525bfda0b1bULL, 0x204e4d2a872ce186ULL,
+    0x7a083ece8ba26999ULL, 0x554b9c9db72efbfaULL,
+    0xb22cd9b656416a05ULL, 0x96a2bedea5e63a5aULL,
+    0x802529a826b0a322ULL, 0x8115ad363b5bc853ULL,
+    0x8375b81701901eb1ULL, 0x3069e53f4a3a1fc5ULL,
+    0xbd2136cfede119e0ULL, 0x18bafc91251d81ecULL,
+    0x1d4a524d4c7d5b44ULL, 0x05f0aedc6960daa8ULL,
+    0x29e39d3072ccf558ULL, 0x70f57f6b5962c0d4ULL,
+    0x989fd53903ad22ceULL, 0xf84d024797d91c59ULL,
+    0x547b1803aac5908bULL, 0xf0d056c37fd263f6ULL,
+    0xd56eb535919e58d8ULL, 0x1c7ad6d351963035ULL,
+    0x2e7326cd2167f912ULL, 0xac361a443d1c8cd2ULL,
+    0x697f076461942a49ULL, 0x4b515f6fdc731d2dULL,
+    0x8ad8680df4700a6fULL, 0x41ac1eca0eb3b460ULL,
+    0x7d988533d80965d3ULL, 0xa8f6300649973d0bULL,
+    0x7765c4960ac9cc9eULL, 0x7ca801adc5e20ea2ULL,
+    0xdea3700e5eb59ae4ULL, 0xa06b6482a19c42a4ULL,
+    0x6a2f96db46b497daULL, 0x27def6d7d487edccULL,
+    0x463ca5375d18b82aULL, 0xa6cb5be1efdc259fULL,
+    0x53eba3fef96e9cc1ULL, 0xce84d81b93a364a7ULL,
+    0xf4107c810b59d22fULL, 0x333974806d1aa256ULL,
+    0x0f0def79bba073e5ULL, 0x231edc95a00c5c15ULL,
+    0xe437d494c64f2c6cULL, 0x91320523f64d3610ULL,
+    0x67426c83c7df32ddULL, 0x6eefbc99323f2603ULL,
+    0x9d6f7be56acdf866ULL, 0x5916e25b2bae358cULL,
+    0x7ff89012e2c2b331ULL, 0x035091bf2720bd93ULL,
+    0x561b0d22900e4669ULL, 0x28d319ae6f279e29ULL,
+    0x2f43a2533c8c9263ULL, 0xd09e1be9f8fe8270ULL,
+    0xf740ed3e2c796fbcULL, 0xdb53ded237d5404cULL,
+    0x62b2c25faebfe875ULL, 0x0afd41a5d2c0a94dULL,
+    0x6412fd3ce0ff8f4eULL, 0xe3a76f6995e42026ULL,
+    0x6c8fa9b808f4f0e1ULL, 0xc2d9a6dd0f23aad1ULL,
+    0x8f28c6d19d10d0c7ULL, 0x85d587744fd0798aULL,
+    0xa20b71a39b579446ULL, 0x684f83fa7c7f4138ULL,
+    0xe507500adba4471dULL, 0x3f640a46f19a6c20ULL,
+    0x1247bd34f7dd28a1ULL, 0x2d23b77206474481ULL,
+    0x93521002cc86e0f2ULL, 0x572b89bc8de52d18ULL,
+    0xfb1d93f8b0f9a1caULL, 0xe95a2ecc4724896bULL,
+    0x3ba420048511ddf9ULL, 0xd63e248ab6bee54bULL,
+    0x5dd6c8195f258455ULL, 0x06a03f634e40673bULL,
+    0x1f2a476c76b68da6ULL, 0x217ec9b49ac78af7ULL,
+    0xecaa80102e4453c3ULL, 0x14e78257b99d4f9aULL },
+  /* 3 */
+  { 0x20329b2cc87bba05ULL, 0x4f5eb6f86546a531ULL,
+    0xd4f44775f751b6b1ULL, 0x8266a47b850dfa8bULL,
+    0xbb986aa15a6ca985ULL, 0xc979eb08f9ae0f99ULL,
+    0x2da6f447a2375ea1ULL, 0x1e74275dcd7d8576ULL,
+    0xbc20180a800bc5f8ULL, 0xb4a2f701b2dc65beULL,
+    0xe726946f981b6d66ULL, 0x48e6c453bf21c94cULL,
+    0x42cad9930f0a4195ULL, 0xefa47b64aacccd20ULL,
+    0x71180a8960409a42ULL, 0x8bb3329bf6a44e0cULL,
+    0xd34c35de2d36daccULL, 0xa92f5b7cbc23dc96ULL,
+    0xb31a85aa68bb09c3ULL, 0x13e04836a73161d2ULL,
+    0xb24dfc4129c51d02ULL, 0x8ae44b70b7da5acdULL,
+    0xe671ed84d96579a7ULL, 0xa4bb3417d66f3832ULL,
+    0x4572ab38d56d2de8ULL, 0xb1b47761ea47215cULL,
+    0xe81c09cf70aba15dULL, 0xffbdb872ce7f90acULL,
+    0xa8782297fd5dc857ULL, 0x0d946f6b6a4ce4a4ULL,
+    0xe4df1f4f5b995138ULL, 0x9ebc71edca8c5762ULL,
+    0x0a2c1dc0b02b88d9ULL, 0x3b503c115d9d7b91ULL,
+    0xc64376a8111ec3a2ULL, 0xcec199a323c963e4ULL,
+    0xdc76a87ec58616f7ULL, 0x09d596e073a9b487ULL,
+    0x14583a9d7d560dafULL, 0xf4c6dc593f2a0cb4ULL,
+    0xdd21d19584f80236ULL, 0x4a4836983ddde1d3ULL,
+    0xe58866a41ae745f9ULL, 0xf591a5b27e541875ULL,
+    0x891dc05074586693ULL, 0x5b068c651810a89eULL,
+    0xa30346bc0c08544fULL, 0x3dbf3751c684032dULL,
+    0x2a1e86ec785032dcULL, 0xf73f5779fca830eaULL,
+    0xb60c05ca30204d21ULL, 0x0cc316802b32f065ULL,
+    0x8770241bdd96be69ULL, 0xb861e18199ee95dbULL,
+    0xf805cad91418fcd1ULL, 0x29e70dccbbd20e82ULL,
+    0xc7140f435060d763ULL, 0x0f3a9da0e8b0cc3bULL,
+    0xa2543f574d76408eULL, 0xbd7761e1c175d139ULL,
+    0x4b1f4f737ca3f512ULL, 0x6dc2df1f2fc137abULL,
+    0xf1d05c3967b14856ULL, 0xa742bf3715ed046cULL,
+    0x654030141d1697edULL, 0x07b872abda676c7dULL,
+    0x3ce84eba87fa17ecULL, 0xc1fb0403cb79afdfULL,
+    0x3e46bc7105063f73ULL, 0x278ae987121cd678ULL,
+    0xa1adb4778ef47cd0ULL, 0x26dd906c5362c2b9ULL,
+    0x05168060589b44e2ULL, 0xfbfc41f9d79ac08fULL,
+    0x0e6de44ba9ced8faULL, 0x9feb08068bf243a3ULL,
+    0x7b341749d06b129bULL, 0x229c69e74a87929aULL,
+    0xe09ee6c4427c011bULL, 0x5692e30e725c4c3aULL,
+    0xda99a33e5e9f6e4bULL, 0x353dd85af453a36bULL,
+    0x25241b4c90e0fee7ULL, 0x5de987258309d022ULL,
+    0xe230140fc0802984ULL, 0x93281e86a0c0b3c6ULL,
+    0xf229d719a4337408ULL, 0x6f6c2dd4ad3d1f34ULL,
+    0x8ea5b2fbae3f0aeeULL, 0x8331dd90c473ee4aULL,
+    0x346aa1b1b52db7aaULL, 0xdf8f235e06042aa9ULL,
+    0xcc6f6b68a1354b7bULL, 0x6c95a6f46ebf236aULL,
+    0x52d31a856bb91c19ULL, 0x1a35ded6d498d555ULL,
+    0xf37eaef2e54d60c9ULL, 0x72e181a9a3c2a61cULL,
+    0x98537aad51952fdeULL, 0x16f6c856ffaa2530ULL,
+    0xd960281e9d1d5215ULL, 0x3a0745fa1ce36f50ULL,
+    0x0b7b642bf1559c18ULL, 0x59a87eae9aec8001ULL,
+    0x5e100c05408bec7cULL, 0x0441f98b19e55023ULL,
+    0xd70dcc5534d38aefULL, 0x927f676de1bea707ULL,
+    0x9769e70db925e3e5ULL, 0x7a636ea29115065aULL,
+    0x468b201816ef11b6ULL, 0xab81a9b73edff409ULL,
+    0xc0ac7de88a07bb1eULL, 0x1f235eb68c0391b7ULL,
+    0x6056b074458dd30fULL, 0xbe8eeac102f7ed67ULL,
+    0xcd381283e04b5fbaULL, 0x5cbefecec277c4e3ULL,
+    0xd21b4c356c48ce0dULL, 0x1019c31664b35d8cULL,
+    0x247362a7d19eea26ULL, 0xebe582efb3299d03ULL,
+    0x02aef2cb82fc289fULL, 0x86275df09ce8aaa8ULL,
+    0x28b07427faac1a43ULL, 0x38a9b7319e1f47cfULL,
+    0xc82e92e3b8d01b58ULL, 0x06ef0b409b1978bcULL,
+    0x62f842bfc771fb90ULL, 0x9904034610eb3b1fULL,
+    0xded85ab5477a3e68ULL, 0x90d195a663428f98ULL,
+    0x5384636e2ac708d8ULL, 0xcbd719c37b522706ULL,
+    0xae9729d76644b0ebULL, 0x7c8c65e20a0c7ee6ULL,
+    0x80c856b007f1d214ULL, 0x8c0b40302cc32271ULL,
+    0xdbcedad51fe17a8aULL, 0x740e8ae938dbdea0ULL,
+    0xa615c6dc549310adULL, 0x19cc55f6171ae90bULL,
+    0x49b1bdb8fe5fdd8dULL, 0xed0a89af2830e5bfULL,
+    0x6a7aadb4f5a65bd6ULL, 0x7e22972988f05679ULL,
+    0xf952b3325566e810ULL, 0x39fecedadf61530eULL,
+    0x6101c99f04f3c7ceULL, 0x2e5f7f6761b562ffULL,
+    0xf08725d226cf5c97ULL, 0x63af3b54860fef51ULL,
+    0x8ff2cb10ef411e2fULL, 0x884ab9bb35267252ULL,
+    0x4df04433e7ba8daeULL, 0x9afd8866d3690741ULL,
+    0x66b9bb34de94abb3ULL, 0x9baaf18d92171380ULL,
+    0x543c11c5f0a064a5ULL, 0x17a1b1bdbed431f1ULL,
+    0xb5f58eeaf3a2717fULL, 0xc355f6c849858740ULL,
+    0xec5df044694ef17eULL, 0xd83751f5dc6346d4ULL,
+    0xfc4433520dfdacf2ULL, 0x0000000000000000ULL,
+    0x5a51f58e596ebc5fULL, 0x3285aaf12e34cf16ULL,
+    0x8d5c39db6dbd36b0ULL, 0x12b731dde64f7513ULL,
+    0x94906c2d7aa7dfbbULL, 0x302b583aacc8e789ULL,
+    0x9d45facd090e6b3cULL, 0x2165e2c78905aec4ULL,
+    0x68d45f7f775a7349ULL, 0x189b2c1d5664fdcaULL,
+    0xe1c99f2f030215daULL, 0x6983269436246788ULL,
+    0x8489af3b1e148237ULL, 0xe94b702431d5b59cULL,
+    0x33d2d31a6f4adbd7ULL, 0xbfd9932a4389f9a6ULL,
+    0xb0e30e8aab39359dULL, 0xd1e2c715afcaf253ULL,
+    0x150f43763c28196eULL, 0xc4ed846393e2eb3dULL,
+    0x03f98b20c3823c5eULL, 0xfd134ab94c83b833ULL,
+    0x556b682eb1de7064ULL, 0x36c4537a37d19f35ULL,
+    0x7559f30279a5ca61ULL, 0x799ae58252973a04ULL,
+    0x9c12832648707ffdULL, 0x78cd9c6913e92ec5ULL,
+    0x1d8dac7d0effb928ULL, 0x439da0784e745554ULL,
+    0x413352b3cc887dcbULL, 0xbacf134a1b12bd44ULL,
+    0x114ebafd25cd494dULL, 0x2f08068c20cb763eULL,
+    0x76a07822ba27f63fULL, 0xeab2fb04f25789c2ULL,
+    0xe3676de481fe3d45ULL, 0x1b62a73d95e6c194ULL,
+    0x641749ff5c68832cULL, 0xa5ec4dfc97112cf3ULL,
+    0xf6682e92bdd6242bULL, 0x3f11c59a44782bb2ULL,
+    0x317c21d1edb6f348ULL, 0xd65ab5be75ad9e2eULL,
+    0x6b2dd45fb4d84f17ULL, 0xfaab381296e4d44eULL,
+    0xd0b5befeeeb4e692ULL, 0x0882ef0b32d7a046ULL,
+    0x512a91a5a83b2047ULL, 0x963e9ee6f85bf724ULL,
+    0x4e09cf132438b1f0ULL, 0x77f701c9fb59e2feULL,
+    0x7ddb1c094b726a27ULL, 0x5f4775ee01f5f8bdULL,
+    0x9186ec4d223c9b59ULL, 0xfeeac1998f01846dULL,
+    0xac39db1ce4b89874ULL, 0xb75b7c21715e59e0ULL,
+    0xafc0503c273aa42aULL, 0x6e3b543fec430bf5ULL,
+    0x704f7362213e8e83ULL, 0x58ff0745db9294c0ULL,
+    0x67eec2df9feabf72ULL, 0xa0facd9ccf8a6811ULL,
+    0xb936986ad890811aULL, 0x95c715c63bd9cb7aULL,
+    0xca8060283a2c33c7ULL, 0x507de84ee9453486ULL,
+    0x85ded6d05f6a96f6ULL, 0x1cdad5964f81ade9ULL,
+    0xd5a33e9eb62fa270ULL, 0x40642b588df6690aULL,
+    0x7f75eec2c98e42b8ULL, 0x2cf18dace3494a60ULL,
+    0x23cb100c0bf9865bULL, 0xeef3028febb2d9e1ULL,
+    0x4425d2d394133929ULL, 0xaad6d05c7fa1e0c8ULL,
+    0xad6ea2f7a5c68cb5ULL, 0xc2028f2308fb9381ULL,
+    0x819f2f5b468fc6d5ULL, 0xc5bafd88d29cfffcULL,
+    0x47dc59f357910577ULL, 0x2b49ff07392e261dULL,
+    0x57c59ae5332258fbULL, 0x73b6f842e2bcb2ddULL,
+    0xcf96e04862b77725ULL, 0x4ca73dd8a6c4996fULL,
+    0x015779eb417e14c1ULL, 0x37932a9176af8bf4ULL },
+  /* 4 */
+  { 0x190a2c9b249df23eULL, 0x2f62f8b62263e1e9ULL,
+    0x7a7f754740993655ULL, 0x330b7ba4d5564d9fULL,
+    0x4c17a16a46672582ULL, 0xb22f08eb7d05f5b8ULL,
+    0x535f47f40bc148ccULL, 0x3aec5d27d4883037ULL,
+    0x10ed0a1825438f96ULL, 0x516101f72c233d17ULL,
+    0x13cc6f949fd04eaeULL, 0x739853c441474bfdULL,
+    0x653793d90d3f5b1bULL, 0x5240647b96b0fc2fULL,
+    0x0c84890ad27623e0ULL, 0xd7189b32703aaea3ULL,
+    0x2685de3523bd9c41ULL, 0x99317c5b11bffefaULL,
+    0x0d9baa854f079703ULL, 0x70b93648fbd48ac5ULL,
+    0xa80441fce30bc6beULL, 0x7287704bdc36ff1eULL,
+    0xb65384ed33dc1f13ULL, 0xd36417343ee34408ULL,
+    0x39cd38ab6e1bf10fULL, 0x5ab861770a1f3564ULL,
+    0x0ebacf09f594563bULL, 0xd04572b884708530ULL,
+    0x3cae9722bdb3af47ULL, 0x4a556b6f2f5cbaf2ULL,
+    0xe1704f1f76c4bd74ULL, 0x5ec4ed7144c6dfcfULL,
+    0x16afc01d4c7810e6ULL, 0x283f113cd629ca7aULL,
+    0xaf59a8761741ed2dULL, 0xeed5a3991e215facULL,
+    0x3bf37ea849f984d4ULL, 0xe413e096a56ce33cULL,
+    0x2c439d3a98f020d1ULL, 0x637559dc6404c46bULL,
+    0x9e6c95d1e5f5d569ULL, 0x24bb9836045fe99aULL,
+    0x44efa466dac8ecc9ULL, 0xc6eab2a5c80895d6ULL,
+    0x803b50c035220cc4ULL, 0x0321658cba93c138ULL,
+    0x8f9ebc465dc7ee1cULL, 0xd15a5137190131d3ULL,
+    0x0fa5ec8668e5e2d8ULL, 0x91c979578d1037b1ULL,
+    0x0642ca05693b9f70ULL, 0xefca80168350eb4fULL,
+    0x38d21b24f36a45ecULL, 0xbeab81e1af73d658ULL,
+    0x8cbfd9cae7542f24ULL, 0xfd19cc0d81f11102ULL,
+    0x0ac6430fbb4dbc90ULL, 0x1d76a09d6a441895ULL,
+    0x2a01573ff1cbbfa1ULL, 0xb572e161894fde2bULL,
+    0x8124734fa853b827ULL, 0x614b1fdf43e6b1b0ULL,
+    0x68ac395c4238cc18ULL, 0x21d837bfd7f7b7d2ULL,
+    0x20c714304a860331ULL, 0x5cfaab726324aa14ULL,
+    0x74c5ba4eb50d606eULL, 0xf3a3030474654739ULL,
+    0x23e671bcf015c209ULL, 0x45f087e947b9582aULL,
+    0xd8bd77b418df4c7bULL, 0xe06f6c90ebb50997ULL,
+    0x0bd96080263c0873ULL, 0x7e03f9410e40dcfeULL,
+    0xb8e94be4c6484928ULL, 0xfb5b0608e8ca8e72ULL,
+    0x1a2b49179e0e3306ULL, 0x4e29e76961855059ULL,
+    0x4f36c4e6fcf4e4baULL, 0x49740ee395cf7bcaULL,
+    0xc2963ea386d17f7dULL, 0x90d65ad810618352ULL,
+    0x12d34c1b02a1fa4dULL, 0xfa44258775bb3a91ULL,
+    0x18150f14b9ec46ddULL, 0x1491861e6b9a653dULL,
+    0x9a1019d7ab2c3fc2ULL, 0x3668d42d06fe13d7ULL,
+    0xdcc1fbb25606a6d0ULL, 0x969490dd795a1c22ULL,
+    0x3549b1a1bc6dd2efULL, 0xc94f5e23a0ed770eULL,
+    0xb9f6686b5b39fdcbULL, 0xc4d4f4a6efeae00dULL,
+    0xe732851a1fff2204ULL, 0x94aad6de5eb869f9ULL,
+    0x3f8ff2ae07206e7fULL, 0xfe38a9813b62d03aULL,
+    0xa7a1ad7a8bee2466ULL, 0x7b6056c8dde882b6ULL,
+    0x302a1e286fc58ca7ULL, 0x8da0fa457a259bc7ULL,
+    0xb3302b64e074415bULL, 0x5402ae7eff8b635fULL,
+    0x08f8050c9cafc94bULL, 0xae468bf98a3059ceULL,
+    0x88c355cca98dc58fULL, 0xb10e6d67c7963480ULL,
+    0xbad70de7e1aa3cf3ULL, 0xbfb4a26e320262bbULL,
+    0xcb711820870f02d5ULL, 0xce12b7a954a75c9dULL,
+    0x563ce87dd8691684ULL, 0x9f73b65e7884618aULL,
+    0x2b1e74b06cba0b42ULL, 0x47cec1ea605b2df1ULL,
+    0x1c698312f735ac76ULL, 0x5fdbcefed9b76b2cULL,
+    0x831a354c8fb1cdfcULL, 0x820516c312c0791fULL,
+    0xb74ca762aeadabf0ULL, 0xfc06ef821c80a5e1ULL,
+    0x5723cbf24518a267ULL, 0x9d4df05d5f661451ULL,
+    0x588627742dfd40bfULL, 0xda8331b73f3d39a0ULL,
+    0x17b0e392d109a405ULL, 0xf965400bcf28fba9ULL,
+    0x7c3dbf4229a2a925ULL, 0x023e460327e275dbULL,
+    0x6cd0b55a0ce126b3ULL, 0xe62da695828e96e7ULL,
+    0x42ad6e63b3f373b9ULL, 0xe50cc319381d57dfULL,
+    0xc5cbd729729b54eeULL, 0x46d1e265fd2a9912ULL,
+    0x6428b056904eeff8ULL, 0x8be23040131e04b7ULL,
+    0x6709d5da2add2ec0ULL, 0x075de98af44a2b93ULL,
+    0x8447dcc67bfbe66fULL, 0x6616f655b7ac9a23ULL,
+    0xd607b8bded4b1a40ULL, 0x0563af89d3a85e48ULL,
+    0x3db1b4ad20c21ba4ULL, 0x11f22997b8323b75ULL,
+    0x292032b34b587e99ULL, 0x7f1cdace9331681dULL,
+    0x8e819fc9c0b65affULL, 0xa1e3677fe2d5bb16ULL,
+    0xcd33d225ee349da5ULL, 0xd9a2543b85aef898ULL,
+    0x795e10cbfa0af76dULL, 0x25a4bbb9992e5d79ULL,
+    0x78413344677b438eULL, 0xf0826688cef68601ULL,
+    0xd27b34bba392f0ebULL, 0x551d8df162fad7bcULL,
+    0x1e57c511d0d7d9adULL, 0xdeffbdb171e4d30bULL,
+    0xf4feea8e802f6caaULL, 0xa480c8f6317de55eULL,
+    0xa0fc44f07fa40ff5ULL, 0x95b5f551c3c9dd1aULL,
+    0x22f952336d6476eaULL, 0x0000000000000000ULL,
+    0xa6be8ef5169f9085ULL, 0xcc2cf1aa73452946ULL,
+    0x2e7ddb39bf12550aULL, 0xd526dd3157d8db78ULL,
+    0x486b2d6c08becf29ULL, 0x9b0f3a58365d8b21ULL,
+    0xac78cdfaadd22c15ULL, 0xbc95c7e28891a383ULL,
+    0x6a927f5f65dab9c3ULL, 0xc3891d2c1ba0cb9eULL,
+    0xeaa92f9f50f8b507ULL, 0xcf0d9426c9d6e87eULL,
+    0xca6e3baf1a7eb636ULL, 0xab25247059980786ULL,
+    0x69b31ad3df4978fbULL, 0xe2512a93cc577c4cULL,
+    0xff278a0ea61364d9ULL, 0x71a615c766a53e26ULL,
+    0x89dc764334fc716cULL, 0xf87a638452594f4aULL,
+    0xf2bc208be914f3daULL, 0x8766b94ac1682757ULL,
+    0xbbc82e687cdb8810ULL, 0x626a7a53f9757088ULL,
+    0xa2c202f358467a2eULL, 0x4d0882e5db169161ULL,
+    0x09e7268301de7da8ULL, 0xe897699c771ac0dcULL,
+    0xc8507dac3d9cc3edULL, 0xc0a878a0a1330aa6ULL,
+    0x978bb352e42ba8c1ULL, 0xe9884a13ea6b743fULL,
+    0x279afdbabecc28a2ULL, 0x047c8c064ed9eaabULL,
+    0x507e2278b15289f4ULL, 0x599904fbb08cf45cULL,
+    0xbd8ae46d15e01760ULL, 0x31353da7f2b43844ULL,
+    0x8558ff49e68a528cULL, 0x76fbfc4d92ef15b5ULL,
+    0x3456922e211c660cULL, 0x86799ac55c1993b4ULL,
+    0x3e90d1219a51da9cULL, 0x2d5cbeb505819432ULL,
+    0x982e5fd48cce4a19ULL, 0xdb9c1238a24c8d43ULL,
+    0xd439febecaa96f9bULL, 0x418c0bef0960b281ULL,
+    0x158ea591f6ebd1deULL, 0x1f48e69e4da66d4eULL,
+    0x8afd13cf8e6fb054ULL, 0xf5e1c9011d5ed849ULL,
+    0xe34e091c5126c8afULL, 0xad67ee7530a398f6ULL,
+    0x43b24dec2e82c75aULL, 0x75da99c1287cd48dULL,
+    0x92e81cdb3783f689ULL, 0xa3dd217cc537cecdULL,
+    0x60543c50de970553ULL, 0x93f73f54aaf2426aULL,
+    0xa91b62737e7a725dULL, 0xf19d4507538732e2ULL,
+    0x77e4dfc20f9ea156ULL, 0x7d229ccdb4d31dc6ULL,
+    0x1b346a98037f87e5ULL, 0xedf4c615a4b29e94ULL,
+    0x4093286094110662ULL, 0xb0114ee85ae78063ULL,
+    0x6ff1d0d6b672e78bULL, 0x6dcf96d591909250ULL,
+    0xdfe09e3eec9567e8ULL, 0x3214582b4827f97cULL,
+    0xb46dc2ee143e6ac8ULL, 0xf6c0ac8da7cd1971ULL,
+    0xebb60c10cd8901e4ULL, 0xf7df8f023abcad92ULL,
+    0x9c52d3d2c217a0b2ULL, 0x6b8d5cd0f8ab0d20ULL,
+    0x3777f7a29b8fa734ULL, 0x011f238f9d71b4e3ULL,
+    0xc1b75b2f3c42be45ULL, 0x5de588fdfe551ef7ULL,
+    0x6eeef3592b035368ULL, 0xaa3a07ffc4e9b365ULL,
+    0xecebe59a39c32a77ULL, 0x5ba742f8976e8187ULL,
+    0x4b4a48e0b22d0e11ULL, 0xddded83dcb771233ULL,
+    0xa59feb79ac0c51bdULL, 0xc7f5912a55792135ULL },
+  /* 5 */
+  { 0x6d6ae04668a9b08aULL, 0x3ab3f04b0be8c743ULL,
+    0xe51e166b54b3c908ULL, 0xbe90a9eb35c2f139ULL,
+    0xb2c7066637f2bec1ULL, 0xaa6945613392202cULL,
+    0x9a28c36f3b5201ebULL, 0xddce5a93ab536994ULL,
+    0x0e34133ef6382827ULL, 0x52a02ba1ec55048bULL,
+    0xa2f88f97c4b2a177ULL, 0x8640e513ca2251a5ULL,
+    0xcdf1d36258137622ULL, 0xfe6cb708dedf8ddbULL,
+    0x8a174a9ec8121e5dULL, 0x679896036b81560eULL,
+    0x59ed033395795feeULL, 0x1dd778ab8b74edafULL,
+    0xee533ef92d9f926dULL, 0x2a8c79baf8a8d8f5ULL,
+    0x6bcf398e69b119f6ULL, 0xe20491742fafdd95ULL,
+    0x276488e0809c2aecULL, 0xea955b82d88f5cceULL,
+    0x7102c63a99d9e0c4ULL, 0xf9763017a5c39946ULL,
+    0x429fa2501f151b3dULL, 0x4659c72bea05d59eULL,
+    0x984b7fdccf5a6634ULL, 0xf742232953fbb161ULL,
+    0x3041860e08c021c7ULL, 0x747bfd9616cd9386ULL,
+    0x4bb1367192312787ULL, 0x1b72a1638a6c44d3ULL,
+    0x4a0e68a6e8359a66ULL, 0x169a5039f258b6caULL,
+    0xb98a2ef44edee5a4ULL, 0xd9083fe85e43a737ULL,
+    0x967f6ce239624e13ULL, 0x8874f62d3c1a7982ULL,
+    0x3c1629830af06e3fULL, 0x9165ebfd427e5a8eULL,
+    0xb5dd81794ceeaa5cULL, 0x0de8f15a7834f219ULL,
+    0x70bd98ede3dd5d25ULL, 0xaccc9ca9328a8950ULL,
+    0x56664eda1945ca28ULL, 0x221db34c0f8859aeULL,
+    0x26dbd637fa98970dULL, 0x1acdffb4f068f932ULL,
+    0x4585254f64090fa0ULL, 0x72de245e17d53afaULL,
+    0x1546b25d7c546cf4ULL, 0x207e0ffffb803e71ULL,
+    0xfaaad2732bcf4378ULL, 0xb462dfae36ea17bdULL,
+    0xcf926fd1ac1b11fdULL, 0xe0672dc7dba7ba4aULL,
+    0xd3fa49ad5d6b41b3ULL, 0x8ba81449b216a3bcULL,
+    0x14f9ec8a0650d115ULL, 0x40fc1ee3eb1d7ce2ULL,
+    0x23a2ed9b758ce44fULL, 0x782c521b14fddc7eULL,
+    0x1c68267cf170504eULL, 0xbcf31558c1ca96e6ULL,
+    0xa781b43b4ba6d235ULL, 0xf6fd7dfe29ff0c80ULL,
+    0xb0a4bad5c3fad91eULL, 0xd199f51ea963266cULL,
+    0x414340349119c103ULL, 0x5405f269ed4dadf7ULL,
+    0xabd61bb649969dcdULL, 0x6813dbeae7bdc3c8ULL,
+    0x65fb2ab09f8931d1ULL, 0xf1e7fae152e3181dULL,
+    0xc1a67cef5a2339daULL, 0x7a4feea8e0f5bba1ULL,
+    0x1e0b9acf05783791ULL, 0x5b8ebf8061713831ULL,
+    0x80e53cdbcb3af8d9ULL, 0x7e898bd315e57502ULL,
+    0xc6bcfbf0213f2d47ULL, 0x95a38e86b76e942dULL,
+    0x092e94218d243cbaULL, 0x8339debf453622e7ULL,
+    0xb11be402b9fe64ffULL, 0x57d9100d634177c9ULL,
+    0xcc4e8db52217cbc3ULL, 0x3b0cae9c71ec7aa2ULL,
+    0xfb158ca451cbfe99ULL, 0x2b33276d82ac6514ULL,
+    0x01bf5ed77a04bde1ULL, 0xc5601994af33f779ULL,
+    0x75c4a3416cc92e67ULL, 0xf3844652a6eb7fc2ULL,
+    0x3487e375fdd0ef64ULL, 0x18ae430704609eedULL,
+    0x4d14efb993298efbULL, 0x815a620cb13e4538ULL,
+    0x125c354207487869ULL, 0x9eeea614ce42cf48ULL,
+    0xce2d3106d61fac1cULL, 0xbbe99247bad6827bULL,
+    0x071a871f7b1c149dULL, 0x2e4a1cc10db81656ULL,
+    0x77a71ff298c149b8ULL, 0x06a5d9c80118a97cULL,
+    0xad73c27e488e34b1ULL, 0x443a7b981e0db241ULL,
+    0xe3bbcfa355ab6074ULL, 0x0af276450328e684ULL,
+    0x73617a896dd1871bULL, 0x58525de4ef7de20fULL,
+    0xb7be3dcab8e6cd83ULL, 0x19111dd07e64230cULL,
+    0x842359a03e2a367aULL, 0x103f89f1f3401fb6ULL,
+    0xdc710444d157d475ULL, 0xb835702334da5845ULL,
+    0x4320fc876511a6dcULL, 0xd026abc9d3679b8dULL,
+    0x17250eee885c0b2bULL, 0x90dab52a387ae76fULL,
+    0x31fed8d972c49c26ULL, 0x89cba8fa461ec463ULL,
+    0x2ff5421677bcabb7ULL, 0x396f122f85e41d7dULL,
+    0xa09b332430bac6a8ULL, 0xc888e8ced7070560ULL,
+    0xaeaf201ac682ee8fULL, 0x1180d7268944a257ULL,
+    0xf058a43628e7a5fcULL, 0xbd4c4b8fbbce2b07ULL,
+    0xa1246df34abe7b49ULL, 0x7d5569b79be9af3cULL,
+    0xa9b5a705bd9efa12ULL, 0xdb6b835baa4bc0e8ULL,
+    0x05793bac8f147342ULL, 0x21c1512881848390ULL,
+    0xfdb0556c50d357e5ULL, 0x613d4fcb6a99ff72ULL,
+    0x03dce2648e0cda3eULL, 0xe949b9e6568386f0ULL,
+    0xfc0f0bbb2ad7ea04ULL, 0x6a70675913b5a417ULL,
+    0x7f36d5046fe1c8e3ULL, 0x0c57af8d02304ff8ULL,
+    0x32223abdfcc84618ULL, 0x0891caf6f720815bULL,
+    0xa63eeaec31a26fd4ULL, 0x2507345374944d33ULL,
+    0x49d28ac266394058ULL, 0xf5219f9aa7f3d6beULL,
+    0x2d96fea583b4cc68ULL, 0x5a31e1571b7585d0ULL,
+    0x8ed12fe53d02d0feULL, 0xdfade6205f5b0e4bULL,
+    0x4cabb16ee92d331aULL, 0x04c6657bf510cea3ULL,
+    0xd73c2cd6a87b8f10ULL, 0xe1d87310a1a307abULL,
+    0x6cd5be9112ad0d6bULL, 0x97c032354366f3f2ULL,
+    0xd4e0ceb22677552eULL, 0x0000000000000000ULL,
+    0x29509bde76a402cbULL, 0xc27a9e8bd42fe3e4ULL,
+    0x5ef7842cee654b73ULL, 0xaf107ecdbc86536eULL,
+    0x3fcacbe784fcb401ULL, 0xd55f90655c73e8cfULL,
+    0xe6c2f40fdabf1336ULL, 0xe8f6e7312c873b11ULL,
+    0xeb2a0555a28be12fULL, 0xe4a148bc2eb774e9ULL,
+    0x9b979db84156bc0aULL, 0x6eb60222e6a56ab4ULL,
+    0x87ffbbc4b026ec44ULL, 0xc703a5275b3b90a6ULL,
+    0x47e699fc9001687fULL, 0x9c8d1aa73a4aa897ULL,
+    0x7cea3760e1ed12ddULL, 0x4ec80ddd1d2554c5ULL,
+    0x13e36b957d4cc588ULL, 0x5d2b66486069914dULL,
+    0x92b90999cc7280b0ULL, 0x517cc9c56259deb5ULL,
+    0xc937b619ad03b881ULL, 0xec30824ad997f5b2ULL,
+    0xa45d565fc5aa080bULL, 0xd6837201d27f32f1ULL,
+    0x635ef3789e9198adULL, 0x531f75769651b96aULL,
+    0x4f77530a6721e924ULL, 0x486dd4151c3dfdb9ULL,
+    0x5f48dafb9461f692ULL, 0x375b011173dc355aULL,
+    0x3da9775470f4d3deULL, 0x8d0dcd81b30e0ac0ULL,
+    0x36e45fc609d888bbULL, 0x55baacbe97491016ULL,
+    0x8cb29356c90ab721ULL, 0x76184125e2c5f459ULL,
+    0x99f4210bb55edbd5ULL, 0x6f095cf59ca1d755ULL,
+    0x9f51f8c3b44672a9ULL, 0x3538bda287d45285ULL,
+    0x50c39712185d6354ULL, 0xf23b1885dcefc223ULL,
+    0x79930ccc6ef9619fULL, 0xed8fdc9da3934853ULL,
+    0xcb540aaa590bdf5eULL, 0x5c94389f1a6d2cacULL,
+    0xe77daad8a0bbaed7ULL, 0x28efc5090ca0bf2aULL,
+    0xbf2ff73c4fc64cd8ULL, 0xb37858b14df60320ULL,
+    0xf8c96ec0dfc724a7ULL, 0x828680683f329f06ULL,
+    0x941cd051cd6a29ccULL, 0xc3c5c05cae2b5e05ULL,
+    0xb601631dc2e27062ULL, 0xc01922382027843bULL,
+    0x24b86a840e90f0d2ULL, 0xd245177a276ffc52ULL,
+    0x0f8b4de98c3c95c6ULL, 0x3e759530fef809e0ULL,
+    0x0b4d2892792c5b65ULL, 0xc4df4743d5374a98ULL,
+    0xa5e20888bfaeb5eaULL, 0xba56cc90c0d23f9aULL,
+    0x38d04cf8ffe0a09cULL, 0x62e1adafe495254cULL,
+    0x0263bcb3f40867dfULL, 0xcaeb547d230f62bfULL,
+    0x6082111c109d4293ULL, 0xdad4dd8cd04f7d09ULL,
+    0xefec602e579b2f8cULL, 0x1fb4c4187f7c8a70ULL,
+    0xffd3e9dfa4db303aULL, 0x7bf0b07f9af10640ULL,
+    0xf49ec14dddf76b5fULL, 0x8f6e713247066d1fULL,
+    0x339d646a86ccfbf9ULL, 0x64447467e58d8c30ULL,
+    0x2c29a072f9b07189ULL, 0xd8b7613f24471ad6ULL,
+    0x6627c8d41185ebefULL, 0xa347d140beb61c96ULL,
+    0xde12b8f7255fb3aaULL, 0x9d324470404e1576ULL,
+    0x9306574eb6763d51ULL, 0xa80af9d2c79a47f3ULL,
+    0x859c0777442e8b9bULL, 0x69ac853d9db97e29ULL },
+  /* 6 */
+  { 0xc3407dfc2de6377eULL, 0x5b9e93eea4256f77ULL,
+    0xadb58fdd50c845e0ULL, 0x5219ff11a75bed86ULL,
+    0x356b61cfd90b1de9ULL, 0xfb8f406e25abe037ULL,
+    0x7a5a0231c0f60796ULL, 0x9d3cd216e1f5020bULL,
+    0x0c6550fb6b48d8f3ULL, 0xf57508c427ff1c62ULL,
+    0x4ad35ffa71cb407dULL, 0x6290a2da1666aa6dULL,
+    0xe284ec2349355f9fULL, 0xb3c307c53d7c84ecULL,
+    0x05e23c0468365a02ULL, 0x190bac4d6c9ebfa8ULL,
+    0x94bbbee9e28b80faULL, 0xa34fc777529cb9b5ULL,
+    0xcc7b39f095bcd978ULL, 0x2426addb0ce532e3ULL,
+    0x7e79329312ce4fc7ULL, 0xab09a72eebec2917ULL,
+    0xf8d15499f6b9d6c2ULL, 0x1a55b8babf8c895dULL,
+    0xdb8add17fb769a85ULL, 0xb57f2f368658e81bULL,
+    0x8acd36f18f3f41f6ULL, 0x5ce3b7bba50f11d3ULL,
+    0x114dcc14d5ee2f0aULL, 0xb91a7fcded1030e8ULL,
+    0x81d5425fe55de7a1ULL, 0xb6213bc1554adeeeULL,
+    0x80144ef95f53f5f2ULL, 0x1e7688186db4c10cULL,
+    0x3b912965db5fe1bcULL, 0xc281715a97e8252dULL,
+    0x54a5d7e21c7f8171ULL, 0x4b12535ccbc5522eULL,
+    0x1d289cefbea6f7f9ULL, 0x6ef5f2217d2e729eULL,
+    0xe6a7dc819b0d17ceULL, 0x1b94b41c05829b0eULL,
+    0x33d7493c622f711eULL, 0xdcf7f942fa5ce421ULL,
+    0x600fba8b7f7a8ecbULL, 0x46b60f011a83988eULL,
+    0x235b898e0dcf4c47ULL, 0x957ab24f588592a9ULL,
+    0x4354330572b5c28cULL, 0xa5f3ef84e9b8d542ULL,
+    0x8c711e02341b2d01ULL, 0x0b1874ae6a62a657ULL,
+    0x1213d8e306fc19ffULL, 0xfe6d7c6a4d9dba35ULL,
+    0x65ed868f174cd4c9ULL, 0x88522ea0e6236550ULL,
+    0x899322065c2d7703ULL, 0xc01e690bfef4018bULL,
+    0x915982ed8abddaf8ULL, 0xbe675b98ec3a4e4cULL,
+    0xa996bf7f82f00db1ULL, 0xe1daf8d49a27696aULL,
+    0x2effd5d3dc8986e7ULL, 0xd153a51f2b1a2e81ULL,
+    0x18caa0ebd690adfbULL, 0x390e3134b243c51aULL,
+    0x2778b92cdff70416ULL, 0x029f1851691c24a6ULL,
+    0x5e7cafeacc133575ULL, 0xfa4e4cc89fa5f264ULL,
+    0x5a5f9f481e2b7d24ULL, 0x484c47ab18d764dbULL,
+    0x400a27f2a1a7f479ULL, 0xaeeb9b2a83da7315ULL,
+    0x721c626879869734ULL, 0x042330a2d2384851ULL,
+    0x85f672fd3765aff0ULL, 0xba446b3a3e02061dULL,
+    0x73dd6ecec3888567ULL, 0xffac70ccf793a866ULL,
+    0xdfa9edb5294ed2d4ULL, 0x6c6aea7014325638ULL,
+    0x834a5a0e8c41c307ULL, 0xcdba35562fb2cb2bULL,
+    0x0ad97808d06cb404ULL, 0x0f3b440cb85aee06ULL,
+    0xe5f9c876481f213bULL, 0x98deee1289c35809ULL,
+    0x59018bbfcd394bd1ULL, 0xe01bf47220297b39ULL,
+    0xde68e1139340c087ULL, 0x9fa3ca4788e926adULL,
+    0xbb85679c840c144eULL, 0x53d8f3b71d55ffd5ULL,
+    0x0da45c5dd146caa0ULL, 0x6f34fe87c72060cdULL,
+    0x57fbc315cf6db784ULL, 0xcee421a1fca0fddeULL,
+    0x3d2d0196607b8d4bULL, 0x642c8a29ad42c69aULL,
+    0x14aff010bdd87508ULL, 0xac74837beac657b3ULL,
+    0x3216459ad821634dULL, 0x3fb219c70967a9edULL,
+    0x06bc28f3bb246cf7ULL, 0xf2082c9126d562c6ULL,
+    0x66b39278c45ee23cULL, 0xbd394f6f3f2878b9ULL,
+    0xfd33689d9e8f8cc0ULL, 0x37f4799eb017394fULL,
+    0x108cc0b26fe03d59ULL, 0xda4bd1b1417888d6ULL,
+    0xb09d1332ee6eb219ULL, 0x2f3ed975668794b4ULL,
+    0x58c0871977375982ULL, 0x7561463d78ace990ULL,
+    0x09876cff037e82f1ULL, 0x7fb83e35a8c05d94ULL,
+    0x26b9b58a65f91645ULL, 0xef20b07e9873953fULL,
+    0x3148516d0b3355b8ULL, 0x41cb2b541ba9e62aULL,
+    0x790416c613e43163ULL, 0xa011d380818e8f40ULL,
+    0x3a5025c36151f3efULL, 0xd57095bdf92266d0ULL,
+    0x498d4b0da2d97688ULL, 0x8b0c3a57353153a5ULL,
+    0x21c491df64d368e1ULL, 0x8f2f0af5e7091bf4ULL,
+    0x2da1c1240f9bb012ULL, 0xc43d59a92ccc49daULL,
+    0xbfa6573e56345c1fULL, 0x828b56a8364fd154ULL,
+    0x9a41f643e0df7cafULL, 0xbcf843c985266aeaULL,
+    0x2b1de9d7b4bfdce5ULL, 0x20059d79dedd7ab2ULL,
+    0x6dabe6d6ae3c446bULL, 0x45e81bf6c991ae7bULL,
+    0x6351ae7cac68b83eULL, 0xa432e32253b6c711ULL,
+    0xd092a9b991143cd2ULL, 0xcac711032e98b58fULL,
+    0xd8d4c9e02864ac70ULL, 0xc5fc550f96c25b89ULL,
+    0xd7ef8dec903e4276ULL, 0x67729ede7e50f06fULL,
+    0xeac28c7af045cf3dULL, 0xb15c1f945460a04aULL,
+    0x9cfddeb05bfb1058ULL, 0x93c69abce3a1fe5eULL,
+    0xeb0380dc4a4bdd6eULL, 0xd20db1e8f8081874ULL,
+    0x229a8528b7c15e14ULL, 0x44291750739fbc28ULL,
+    0xd3ccbd4e42060a27ULL, 0xf62b1c33f4ed2a97ULL,
+    0x86a8660ae4779905ULL, 0xd62e814a2a305025ULL,
+    0x477703a7a08d8addULL, 0x7b9b0e977af815c5ULL,
+    0x78c51a60a9ea2330ULL, 0xa6adfb733aaae3b7ULL,
+    0x97e5aa1e3199b60fULL, 0x0000000000000000ULL,
+    0xf4b404629df10e31ULL, 0x5564db44a6719322ULL,
+    0x9207961a59afec0dULL, 0x9624a6b88b97a45cULL,
+    0x363575380a192b1cULL, 0x2c60cd82b595a241ULL,
+    0x7d272664c1dc7932ULL, 0x7142769faa94a1c1ULL,
+    0xa1d0df263b809d13ULL, 0x1630e841d4c451aeULL,
+    0xc1df65ad44fa13d8ULL, 0x13d2d445bcf20bacULL,
+    0xd915c546926abe23ULL, 0x38cf3d92084dd749ULL,
+    0xe766d0272103059dULL, 0xc7634d5effde7f2fULL,
+    0x077d2455012a7ea4ULL, 0xedbfa82ff16fb199ULL,
+    0xaf2a978c39d46146ULL, 0x42953fa3c8bbd0dfULL,
+    0xcb061da59496a7dcULL, 0x25e7a17db6eb20b0ULL,
+    0x34aa6d6963050fbaULL, 0xa76cf7d580a4f1e4ULL,
+    0xf7ea10954ee338c4ULL, 0xfcf2643b24819e93ULL,
+    0xcf252d0746aeef8dULL, 0x4ef06f58a3f3082cULL,
+    0x563acfb37563a5d7ULL, 0x5086e740ce47c920ULL,
+    0x2982f186dda3f843ULL, 0x87696aac5e798b56ULL,
+    0x5d22bb1d1f010380ULL, 0x035e14f7d31236f5ULL,
+    0x3cec0d30da759f18ULL, 0xf3c920379cdb7095ULL,
+    0xb8db736b571e22bbULL, 0xdd36f5e44052f672ULL,
+    0xaac8ab8851e23b44ULL, 0xa857b3d938fe1fe2ULL,
+    0x17f1e4e76eca43fdULL, 0xec7ea4894b61a3caULL,
+    0x9e62c6e132e734feULL, 0xd4b1991b432c7483ULL,
+    0x6ad6c283af163acfULL, 0x1ce9904904a8e5aaULL,
+    0x5fbda34c761d2726ULL, 0xf910583f4cb7c491ULL,
+    0xc6a241f845d06d7cULL, 0x4f3163fe19fd1a7fULL,
+    0xe99c988d2357f9c8ULL, 0x8eee06535d0709a7ULL,
+    0x0efa48aa0254fc55ULL, 0xb4be23903c56fa48ULL,
+    0x763f52caabbedf65ULL, 0xeee1bcd8227d876cULL,
+    0xe345e085f33b4dccULL, 0x3e731561b369bbbeULL,
+    0x2843fd2067adea10ULL, 0x2adce5710eb1ceb6ULL,
+    0xb7e03767ef44ccbdULL, 0x8db012a48e153f52ULL,
+    0x61ceb62dc5749c98ULL, 0xe85d942b9959eb9bULL,
+    0x4c6f7709caef2c8aULL, 0x84377e5b8d6bbda3ULL,
+    0x30895dcbb13d47ebULL, 0x74a04a9bc2a2fbc3ULL,
+    0x6b17ce251518289cULL, 0xe438c4d0f2113368ULL,
+    0x1fb784bed7bad35fULL, 0x9b80fae55ad16efcULL,
+    0x77fe5e6c11b0cd36ULL, 0xc858095247849129ULL,
+    0x08466059b97090a2ULL, 0x01c10ca6ba0e1253ULL,
+    0x6988d6747c040c3aULL, 0x6849dad2c60a1e69ULL,
+    0x5147ebe67449db73ULL, 0xc99905f4fd8a837aULL,
+    0x991fe2b433cd4a5aULL, 0xf09734c04fc94660ULL,
+    0xa28ecbd1e892abe6ULL, 0xf1563866f5c75433ULL,
+    0x4dae7baf70e13ed9ULL, 0x7ce62ac27bd26b61ULL,
+    0x70837a39109ab392ULL, 0x90988e4b30b3c8abULL,
+    0xb2020b63877296bfULL, 0x156efcb607d6675bULL },
+  /* 7 */
+  { 0xe63f55ce97c331d0ULL, 0x25b506b0015bba16ULL,
+    0xc8706e29e6ad9ba8ULL, 0x5b43d3775d521f6aULL,
+    0x0bfa3d577035106eULL, 0xab95fc172afb0e66ULL,
+    0xf64b63979e7a3276ULL, 0xf58b4562649dad4bULL,
+    0x48f7c3dbae0c83f1ULL, 0xff31916642f5c8c5ULL,
+    0xcbb048dc1c4a0495ULL, 0x66b8f83cdf622989ULL,
+    0x35c130e908e2b9b0ULL, 0x7c761a61f0b34fa1ULL,
+    0x3601161cf205268dULL, 0x9e54ccfe2219b7d6ULL,
+    0x8b7d90a538940837ULL, 0x9cd403588ea35d0bULL,
+    0xbc3c6fea9ccc5b5aULL, 0xe5ff733b6d24aeedULL,
+    0xceed22de0f7eb8d2ULL, 0xec8581cab1ab545eULL,
+    0xb96105e88ff8e71dULL, 0x8ca03501871a5eadULL,
+    0x76ccce65d6db2a2fULL, 0x5883f582a7b58057ULL,
+    0x3f7be4ed2e8adc3eULL, 0x0fe7be06355cd9c9ULL,
+    0xee054e6c1d11be83ULL, 0x1074365909b903a6ULL,
+    0x5dde9f80b4813c10ULL, 0x4a770c7d02b6692cULL,
+    0x5379c8d5d7809039ULL, 0xb4067448161ed409ULL,
+    0x5f5e5026183bd6cdULL, 0xe898029bf4c29df9ULL,
+    0x7fb63c940a54d09cULL, 0xc5171f897f4ba8bcULL,
+    0xa6f28db7b31d3d72ULL, 0x2e4f3be7716eaa78ULL,
+    0x0d6771a099e63314ULL, 0x82076254e41bf284ULL,
+    0x2f0fd2b42733df98ULL, 0x5c9e76d3e2dc49f0ULL,
+    0x7aeb569619606cdbULL, 0x83478b07b2468764ULL,
+    0xcfadcb8d5923cd32ULL, 0x85dac7f05b95a41eULL,
+    0xb5469d1b4043a1e9ULL, 0xb821ecbbd9a592fdULL,
+    0x1b8e0b0e798c13c8ULL, 0x62a57b6d9a0be02eULL,
+    0xfcf1b793b81257f8ULL, 0x9d94ea0bd8fe28ebULL,
+    0x4cea408aeb654a56ULL, 0x23284a47e888996cULL,
+    0x2d8f1d128b893545ULL, 0xf4cbac3132c0d8abULL,
+    0xbd7c86b9ca912ebaULL, 0x3a268eef3dbe6079ULL,
+    0xf0d62f6077a9110cULL, 0x2735c916ade150cbULL,
+    0x89fd5f03942ee2eaULL, 0x1acee25d2fd16628ULL,
+    0x90f39bab41181bffULL, 0x430dfe8cde39939fULL,
+    0xf70b8ac4c8274796ULL, 0x1c53aeaac6024552ULL,
+    0x13b410acf35e9c9bULL, 0xa532ab4249faa24fULL,
+    0x2b1251e5625a163fULL, 0xd7e3e676da4841c7ULL,
+    0xa7b264e4e5404892ULL, 0xda8497d643ae72d3ULL,
+    0x861ae105a1723b23ULL, 0x38a6414991048aa4ULL,
+    0x6578dec92585b6b4ULL, 0x0280cfa6acbaeaddULL,
+    0x88bdb650c273970aULL, 0x9333bd5ebbff84c2ULL,
+    0x4e6a8f2c47dfa08bULL, 0x321c954db76cef2aULL,
+    0x418d312a72837942ULL, 0xb29b38bfffcdf773ULL,
+    0x6c022c38f90a4c07ULL, 0x5a033a240b0f6a8aULL,
+    0x1f93885f3ce5da6fULL, 0xc38a537e96988bc6ULL,
+    0x39e6a81ac759ff44ULL, 0x29929e43cee0fce2ULL,
+    0x40cdd87924de0ca2ULL, 0xe9d8ebc8a29fe819ULL,
+    0x0c2798f3cfbb46f4ULL, 0x55e484223e53b343ULL,
+    0x4650948ecd0d2fd8ULL, 0x20e86cb2126f0651ULL,
+    0x6d42c56baf5739e7ULL, 0xa06fc1405ace1e08ULL,
+    0x7babbfc54f3d193bULL, 0x424d17df8864e67fULL,
+    0xd8045870ef14980eULL, 0xc6d7397c85ac3781ULL,
+    0x21a885e1443273b1ULL, 0x67f8116f893f5c69ULL,
+    0x24f5efe35706cff6ULL, 0xd56329d076f2ab1aULL,
+    0x5e1eb9754e66a32dULL, 0x28d2771098bd8902ULL,
+    0x8f6013f47dfdc190ULL, 0x17a993fdb637553cULL,
+    0xe0a219397e1012aaULL, 0x786b9930b5da8606ULL,
+    0x6e82e39e55b0a6daULL, 0x875a0856f72f4ec3ULL,
+    0x3741ff4fa458536dULL, 0xac4859b3957558fcULL,
+    0x7ef6d5c75c09a57cULL, 0xc04a758b6c7f14fbULL,
+    0xf9acdd91ab26ebbfULL, 0x7391a467c5ef9668ULL,
+    0x335c7c1ee1319acaULL, 0xa91533b18641e4bbULL,
+    0xe4bf9a683b79db0dULL, 0x8e20faa72ba0b470ULL,
+    0x51f907737b3a7ae4ULL, 0x2268a314bed5ec8cULL,
+    0xd944b123b949edeeULL, 0x31dcb3b84d8b7017ULL,
+    0xd3fe65279f218860ULL, 0x097af2f1dc8ffab3ULL,
+    0x9b09a6fc312d0b91ULL, 0xcc6ded78a3c4520fULL,
+    0x3481d9ba5ebfcc50ULL, 0x4f2a667f1182d56bULL,
+    0xdfd9fdd4509ace94ULL, 0x26752045fbbc252bULL,
+    0xbffc491f662bc467ULL, 0xdd593272fc202449ULL,
+    0x3cbbc218d46d4303ULL, 0x91b372f817456e1fULL,
+    0x681faf69bc6385a0ULL, 0xb686bbeebaa43ed4ULL,
+    0x1469b5084cd0ca01ULL, 0x98c98009cbca94acULL,
+    0x6438379a73d8c354ULL, 0xc2caba2dc0c5fe26ULL,
+    0x3e3b0dbe78d7a9deULL, 0x50b9ee202d670f04ULL,
+    0x4590b27b37eab0e5ULL, 0x6025b4cb36b10af3ULL,
+    0xfb2c1237079c0162ULL, 0xa12f28130c936be8ULL,
+    0x4b37e52e54eb1cccULL, 0x083a1ba28ad28f53ULL,
+    0xc10a9cd83a22611bULL, 0x9f1425ad7444c236ULL,
+    0x069d4cf7e9d3237aULL, 0xedc56899e7f621beULL,
+    0x778c273680865fcfULL, 0x309c5aeb1bd605f7ULL,
+    0x8de0dc52d1472b4dULL, 0xf8ec34c2fd7b9e5fULL,
+    0xea18cd3d58787724ULL, 0xaad515447ca67b86ULL,
+    0x9989695a9d97e14cULL, 0x0000000000000000ULL,
+    0xf196c63321f464ecULL, 0x71116bc169557cb5ULL,
+    0xaf887f466f92c7c1ULL, 0x972e3e0ffe964d65ULL,
+    0x190ec4a8d536f915ULL, 0x95aef1a9522ca7b8ULL,
+    0xdc19db21aa7d51a9ULL, 0x94ee18fa0471d258ULL,
+    0x8087adf248a11859ULL, 0xc457f6da2916dd5cULL,
+    0xfa6cfb6451c17482ULL, 0xf256e0c6db13fbd1ULL,
+    0x6a9f60cf10d96f7dULL, 0x4daaa9d9bd383fb6ULL,
+    0x03c026f5fae79f3dULL, 0xde99148706c7bb74ULL,
+    0x2a52b8b6340763dfULL, 0x6fc20acd03edd33aULL,
+    0xd423c08320afdefaULL, 0xbbe1ca4e23420dc0ULL,
+    0x966ed75ca8cb3885ULL, 0xeb58246e0e2502c4ULL,
+    0x055d6a021334bc47ULL, 0xa47242111fa7d7afULL,
+    0xe3623fcc84f78d97ULL, 0x81c744a11efc6db9ULL,
+    0xaec8961539cfb221ULL, 0xf31609958d4e8e31ULL,
+    0x63e5923ecc5695ceULL, 0x47107ddd9b505a38ULL,
+    0xa3afe7b5a0298135ULL, 0x792b7063e387f3e6ULL,
+    0x0140e953565d75e0ULL, 0x12f4f9ffa503e97bULL,
+    0x750ce8902c3cb512ULL, 0xdbc47e8515f30733ULL,
+    0x1ed3610c6ab8af8fULL, 0x5239218681dde5d9ULL,
+    0xe222d69fd2aaf877ULL, 0xfe71783514a8bd25ULL,
+    0xcaf0a18f4a177175ULL, 0x61655d9860ec7f13ULL,
+    0xe77fbc9dc19e4430ULL, 0x2ccff441ddd440a5ULL,
+    0x16e97aaee06a20dcULL, 0xa855dae2d01c915bULL,
+    0x1d1347f9905f30b2ULL, 0xb7c652bdecf94b34ULL,
+    0xd03e43d265c6175dULL, 0xfdb15ec0ee4f2218ULL,
+    0x57644b8492e9599eULL, 0x07dda5a4bf8e569aULL,
+    0x54a46d71680ec6a3ULL, 0x5624a2d7c4b42c7eULL,
+    0xbebca04c3076b187ULL, 0x7d36f332a6ee3a41ULL,
+    0x3b6667bc6be31599ULL, 0x695f463aea3ef040ULL,
+    0xad08b0e0c3282d1cULL, 0xb15b1e4a052a684eULL,
+    0x44d05b2861b7c505ULL, 0x15295c5b1a8dbfe1ULL,
+    0x744c01c37a61c0f2ULL, 0x59c31cd1f1e8f5b7ULL,
+    0xef45a73f4b4ccb63ULL, 0x6bdf899c46841a9dULL,
+    0x3dfb2b4b823036e3ULL, 0xa2ef0ee6f674f4d5ULL,
+    0x184e2dfb836b8cf5ULL, 0x1134df0a5fe47646ULL,
+    0xbaa1231d751f7820ULL, 0xd17eaa81339b62bdULL,
+    0xb01bf71953771daeULL, 0x849a2ea30dc8d1feULL,
+    0x705182923f080955ULL, 0x0ea757556301ac29ULL,
+    0x041d83514569c9a7ULL, 0x0abad4042668658eULL,
+    0x49b72a88f851f611ULL, 0x8a3d79f66ec97dd7ULL,
+    0xcd2d042bf59927efULL, 0xc930877ab0f0ee48ULL,
+    0x9273540deda2f122ULL, 0xc797d02fd3f14261ULL,
+    0xe1e2f06a284d674aULL, 0xd2be8c74c97cfd80ULL,
+    0x9a494faf67707e71ULL, 0xb3dbd1eca9908293ULL,
+    0x72d14d3493b2e388ULL, 0xd6a30f258c153427ULL },
+};
+
+static const uint64_t C16[12][8] =
+{
+  { 0xdd806559f2a64507ULL, 0x05767436cc744d23ULL,
+    0xa2422a08a460d315ULL, 0x4b7ce09192676901ULL,
+    0x714eb88d7585c4fcULL, 0x2f6a76432e45d016ULL,
+    0xebcb2f81c0657c1fULL, 0xb1085bda1ecadae9ULL },
+  { 0xe679047021b19bb7ULL, 0x55dda21bd7cbcd56ULL,
+    0x5cb561c2db0aa7caULL, 0x9ab5176b12d69958ULL,
+    0x61d55e0f16b50131ULL, 0xf3feea720a232b98ULL,
+    0x4fe39d460f70b5d7ULL, 0x6fa3b58aa99d2f1aULL },
+  { 0x991e96f50aba0ab2ULL, 0xc2b6f443867adb31ULL,
+    0xc1c93a376062db09ULL, 0xd3e20fe490359eb1ULL,
+    0xf2ea7514b1297b7bULL, 0x06f15e5f529c1f8bULL,
+    0x0a39fc286a3d8435ULL, 0xf574dcac2bce2fc7ULL },
+  { 0x220cbebc84e3d12eULL, 0x3453eaa193e837f1ULL,
+    0xd8b71333935203beULL, 0xa9d72c82ed03d675ULL,
+    0x9d721cad685e353fULL, 0x488e857e335c3c7dULL,
+    0xf948e1a05d71e4ddULL, 0xef1fdfb3e81566d2ULL },
+  { 0x601758fd7c6cfe57ULL, 0x7a56a27ea9ea63f5ULL,
+    0xdfff00b723271a16ULL, 0xbfcd1747253af5a3ULL,
+    0x359e35d7800fffbdULL, 0x7f151c1f1686104aULL,
+    0x9a3f410c6ca92363ULL, 0x4bea6bacad474799ULL },
+  { 0xfa68407a46647d6eULL, 0xbf71c57236904f35ULL,
+    0x0af21f66c2bec6b6ULL, 0xcffaa6b71c9ab7b4ULL,
+    0x187f9ab49af08ec6ULL, 0x2d66c4f95142a46cULL,
+    0x6fa4c33b7a3039c0ULL, 0xae4faeae1d3ad3d9ULL },
+  { 0x8886564d3a14d493ULL, 0x3517454ca23c4af3ULL,
+    0x06476983284a0504ULL, 0x0992abc52d822c37ULL,
+    0xd3473e33197a93c9ULL, 0x399ec6c7e6bf87c9ULL,
+    0x51ac86febf240954ULL, 0xf4c70e16eeaac5ecULL },
+  { 0xa47f0dd4bf02e71eULL, 0x36acc2355951a8d9ULL,
+    0x69d18d2bd1a5c42fULL, 0xf4892bcb929b0690ULL,
+    0x89b4443b4ddbc49aULL, 0x4eb7f8719c36de1eULL,
+    0x03e7aa020c6e4141ULL, 0x9b1f5b424d93c9a7ULL },
+  { 0x7261445183235adbULL, 0x0e38dc92cb1f2a60ULL,
+    0x7b2b8a9aa6079c54ULL, 0x800a440bdbb2ceb1ULL,
+    0x3cd955b7e00d0984ULL, 0x3a7d3a1b25894224ULL,
+    0x944c9ad8ec165fdeULL, 0x378f5a541631229bULL },
+  { 0x74b4c7fb98459cedULL, 0x3698fad1153bb6c3ULL,
+    0x7a1e6c303b7652f4ULL, 0x9fe76702af69334bULL,
+    0x1fffe18a1b336103ULL, 0x8941e71cff8a78dbULL,
+    0x382ae548b2e4f3f3ULL, 0xabbedea680056f52ULL },
+  { 0x6bcaa4cd81f32d1bULL, 0xdea2594ac06fd85dULL,
+    0xefbacd1d7d476e98ULL, 0x8a1d71efea48b9caULL,
+    0x2001802114846679ULL, 0xd8fa6bbbebab0761ULL,
+    0x3002c6cd635afe94ULL, 0x7bcd9ed0efc889fbULL },
+  { 0x48bc924af11bd720ULL, 0xfaf417d5d9b21b99ULL,
+    0xe71da4aa88e12852ULL, 0x5d80ef9d1891cc86ULL,
+    0xf82012d430219f9bULL, 0xcda43c32bcdf1d77ULL,
+    0xd21380b00449b17aULL, 0x378ee767f11631baULL },
+};
+
+#define strido(out, temp, i) do { \
+	uint64_t t; \
+	t  = streebog_table[0][(temp[0] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	t ^= streebog_table[1][(temp[1] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	t ^= streebog_table[2][(temp[2] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	t ^= streebog_table[3][(temp[3] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	t ^= streebog_table[4][(temp[4] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	t ^= streebog_table[5][(temp[5] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	t ^= streebog_table[6][(temp[6] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	t ^= streebog_table[7][(temp[7] &gt;&gt; (i * 8)) &amp; 0xff]; \
+	out[i] = t; } while(0)
+
+static void LPSX (uint64_t *out, const uint64_t *a, const uint64_t *b)
+{
+  uint64_t temp[8];
+  temp[0] = a[0] ^ b[0];
+  temp[1] = a[1] ^ b[1];
+  temp[2] = a[2] ^ b[2];
+  temp[3] = a[3] ^ b[3];
+  temp[4] = a[4] ^ b[4];
+  temp[5] = a[5] ^ b[5];
+  temp[6] = a[6] ^ b[6];
+  temp[7] = a[7] ^ b[7];
+  strido (out, temp, 0);
+  strido (out, temp, 1);
+  strido (out, temp, 2);
+  strido (out, temp, 3);
+  strido (out, temp, 4);
+  strido (out, temp, 5);
+  strido (out, temp, 6);
+  strido (out, temp, 7);
+}
+
+static inline void g (uint64_t *h, uint64_t *m, uint64_t *N)
+{
+  uint64_t K[8];
+  uint64_t T[8];
+  int i;
+
+  LPSX (K, h, N);
+
+  LPSX (T, K, m);
+  LPSX (K, K, C16[0]);
+  for (i = 1; i &lt; 12; i++)
+    {
+      LPSX (T, K, T);
+      LPSX (K, K, C16[i]);
+    }
+
+  h[0] ^= T[0] ^ K[0] ^ m[0];
+  h[1] ^= T[1] ^ K[1] ^ m[1];
+  h[2] ^= T[2] ^ K[2] ^ m[2];
+  h[3] ^= T[3] ^ K[3] ^ m[3];
+  h[4] ^= T[4] ^ K[4] ^ m[4];
+  h[5] ^= T[5] ^ K[5] ^ m[5];
+  h[6] ^= T[6] ^ K[6] ^ m[6];
+  h[7] ^= T[7] ^ K[7] ^ m[7];
+}
+
+
+static void
+streebog512_compress (struct streebog512_ctx *ctx, const uint8_t *input, size_t \
count) +{
+  uint64_t M[8];
+  uint64_t l, cf;
+  int i;
+
+  for (i = 0; i &lt; 8; i++, input += 8)
+    M[i] = LE_READ_UINT64(input);
+
+  g (ctx-&gt;state, M, ctx-&gt;count);
+  l = ctx-&gt;count[0];
+  ctx-&gt;count[0] += count;
+  if (ctx-&gt;count[0] &lt; l)
+    { /* overflow */
+      for (i = 1; i &lt; 8; i++)
+        {
+          ctx-&gt;count[i]++;
+          if (ctx-&gt;count[i] != 0)
+            break;
+        }
+    }
+
+  cf = 0;
+  ctx-&gt;sigma[0] += M[0];
+  for (i = 1; i &lt; 8; i++)
+    {
+      if (ctx-&gt;sigma[i-1] != M[i-1])
+	cf = (ctx-&gt;sigma[i-1] &lt; M[i-1]);
+      ctx-&gt;sigma[i] += M[i] + cf;
+    }
+}
+
+static void
+streebog_final (struct streebog512_ctx *ctx)
+{
+  uint64_t Z[8] = {};
+  unsigned int i;
+
+  /* PAD. It does not count towards message length */
+  i = ctx-&gt;index;
+  /* We have at least one byte free) */
+  ctx-&gt;block[i++] = 1;
+  while (i &lt; 64)
+    ctx-&gt;block[i++] = 0;
+  streebog512_compress (ctx, ctx-&gt;block, ctx-&gt;index * 8);
+
+  g (ctx-&gt;state, ctx-&gt;count, Z);
+  g (ctx-&gt;state, ctx-&gt;sigma, Z);
+}
+
+#define COMPRESS(ctx, data) (streebog512_compress((ctx), (data), 64 * 8))
+
+void
+streebog512_init(struct streebog512_ctx *ctx)
+{
+  memset(ctx-&gt;state, 0, sizeof(ctx-&gt;state));
+  memset(ctx-&gt;count, 0, sizeof(ctx-&gt;count));
+  memset(ctx-&gt;sigma, 0, sizeof(ctx-&gt;sigma));
+
+  /* Initialize buffer */
+  ctx-&gt;index = 0;
+}
+
+void
+streebog512_update(struct streebog512_ctx *ctx,
+                   size_t length, const uint8_t *data)
+{
+  MD_UPDATE (ctx, length, data, COMPRESS, (void)0);
+}
+
+static void
+streebog512_write_digest(struct streebog512_ctx *ctx,
+                         size_t offset, size_t length,
+                         uint8_t *digest)
+{
+  unsigned i;
+  unsigned words;
+  unsigned leftover;
+
+  assert(offset + length &lt;= STREEBOG512_DIGEST_SIZE);
+
+  streebog_final(ctx);
+
+  words = length / 8;
+  leftover = length % 8;
+
+  for (i = 0; i &lt; words; i++, digest += 8)
+    LE_WRITE_UINT64(digest, ctx-&gt;state[offset + i]);
+
+  if (leftover)
+    {
+      /* Truncate to the right size */
+      uint64_t word = ctx-&gt;state[offset + i] &lt;&lt; (8*(8 - leftover));
+
+      do {
+	digest[--leftover] = (word &gt;&gt; 56) &amp; 0xff;
+	word &lt;&lt;= 8;
+      } while (leftover);
+    }
+}
+
+void
+streebog512_digest(struct streebog512_ctx *ctx,
+	      size_t length,
+	      uint8_t *digest)
+{
+  assert(length &lt;= STREEBOG512_DIGEST_SIZE);
+
+  streebog512_write_digest(ctx, 0, length, digest);
+  streebog512_init(ctx);
+}
+
+void
+streebog256_init(struct streebog256_ctx *ctx)
+{
+  memset(ctx-&gt;state, 1, sizeof(ctx-&gt;state));
+  memset(ctx-&gt;count, 0, sizeof(ctx-&gt;count));
+  memset(ctx-&gt;sigma, 0, sizeof(ctx-&gt;sigma));
+
+  /* Initialize buffer */
+  ctx-&gt;index = 0;
+}
+
+void
+streebog256_digest(struct streebog256_ctx *ctx,
+                   size_t length,
+                   uint8_t *digest)
+{
+  assert(length &lt;= STREEBOG256_DIGEST_SIZE);
+
+  streebog512_write_digest(ctx,
+      4,
+      length,
+      digest);
+  streebog256_init(ctx);
+}
diff --git a/streebog.h b/streebog.h
new file mode 100644
index 000000000000..3408224e0240
--- /dev/null
+++ b/streebog.h
@@ -0,0 +1,99 @@
+/* streebog.h
+
+   The Streebog family of hash functions.
+
+   Copyright (C) 2015 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+ 
+#ifndef NETTLE_STREEBOG_H_INCLUDED
+#define NETTLE_STREEBOG_H_INCLUDED
+
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define streebog256_init nettle_streebog256_init
+#define streebog256_digest nettle_streebog256_digest
+#define streebog512_init nettle_streebog512_init
+#define streebog512_update nettle_streebog512_update
+#define streebog512_digest nettle_streebog512_digest
+
+/* STREEBOG512 */
+
+#define STREEBOG512_DIGEST_SIZE 64
+#define STREEBOG512_BLOCK_SIZE 64
+
+/* Digest is kept internally as 8 64-bit words. */
+#define _STREEBOG512_DIGEST_LENGTH 8
+
+struct streebog512_ctx
+{
+  uint64_t state[_STREEBOG512_DIGEST_LENGTH];    /* State variables */
+  uint64_t count[_STREEBOG512_DIGEST_LENGTH];
+  uint64_t sigma[_STREEBOG512_DIGEST_LENGTH];
+  unsigned int index;                       /* index into buffer */
+  uint8_t block[STREEBOG512_BLOCK_SIZE];          /* STREEBOG512 data buffer */
+};
+
+void
+streebog512_init(struct streebog512_ctx *ctx);
+
+void
+streebog512_update(struct streebog512_ctx *ctx,
+	      size_t length,
+	      const uint8_t *data);
+
+void
+streebog512_digest(struct streebog512_ctx *ctx,
+	      size_t length,
+	      uint8_t *digest);
+
+
+#define STREEBOG256_DIGEST_SIZE 32
+#define STREEBOG256_BLOCK_SIZE STREEBOG512_BLOCK_SIZE
+#define streebog256_ctx streebog512_ctx
+
+void
+streebog256_init(struct streebog256_ctx *ctx);
+
+#define streebog256_update nettle_streebog512_update
+
+void
+streebog256_digest(struct streebog256_ctx *ctx,
+		  size_t length,
+		  uint8_t *digest);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_STREEBOG_H_INCLUDED */
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index 066bcee2fb23..b4b41af308ea 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -90,6 +90,7 @@
 /sha512-224-test
 /sha512-256-test
 /sha512-test
+/streebog-test
 /twofish-test
 /umac-test
 /version-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index efb7df3cbf7a..2c567f64e7be 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -100,6 +100,9 @@ sha3-384-test$(EXEEXT): sha3-384-test.$(OBJEXT)
 sha3-512-test$(EXEEXT): sha3-512-test.$(OBJEXT)
 	$(LINK) sha3-512-test.$(OBJEXT) $(TEST_OBJS) -o sha3-512-test$(EXEEXT)
 
+streebog-test$(EXEEXT): streebog-test.$(OBJEXT)
+	$(LINK) streebog-test.$(OBJEXT) $(TEST_OBJS) -o streebog-test$(EXEEXT)
+
 serpent-test$(EXEEXT): serpent-test.$(OBJEXT)
 	$(LINK) serpent-test.$(OBJEXT) $(TEST_OBJS) -o serpent-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index f8f85701ef35..3a073d673ce6 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -24,6 +24,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    sha384-test.c sha512-test.c sha512-224-test.c sha512-256-test.c \
 		    sha3-permute-test.c sha3-224-test.c sha3-256-test.c \
 		    sha3-384-test.c sha3-512-test.c \
+		    streebog-test.c \
 		    serpent-test.c twofish-test.c version-test.c \
 		    knuth-lfib-test.c \
 		    cbc-test.c cfb-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
diff --git a/testsuite/hmac-test.c b/testsuite/hmac-test.c
index f009c8003d34..618de75d431b 100644
--- a/testsuite/hmac-test.c
+++ b/testsuite/hmac-test.c
@@ -908,4 +908,21 @@ test_main(void)
 	    SHEX("0126bdb87800af214341456563780100"),
 	    SHEX("bad70b61c41095bc47e1141cfaed4272"
 		 "6a5ceebd62ce75dbbb9ad76cda9f72f7"));
+
+  /* RFC 7836 */
+  HMAC_TEST(streebog512,
+	    SHEX("000102030405060708090a0b0c0d0e0f"
+		 "101112131415161718191a1b1c1d1e1f"),
+	    SHEX("0126bdb87800af214341456563780100"),
+	    SHEX("a59bab22ecae19c65fbde6e5f4e9f5d8"
+	         "549d31f037f9df9b905500e171923a77"
+		 "3d5f1530f2ed7e964cb2eedc29e9ad2f"
+		 "3afe93b2814f79f5000ffc0366c251e6"));
+
+  HMAC_TEST(streebog256,
+	    SHEX("000102030405060708090a0b0c0d0e0f"
+		 "101112131415161718191a1b1c1d1e1f"),
+	    SHEX("0126bdb87800af214341456563780100"),
+	    SHEX("a1aa5f7de402d7b3d323f2991c8d4534"
+	         "013137010a83754fd0af6d7cd4922ed9"));
 }
diff --git a/testsuite/meta-hash-test.c b/testsuite/meta-hash-test.c
index 7d863a7c386d..eb9f3698e353 100644
--- a/testsuite/meta-hash-test.c
+++ b/testsuite/meta-hash-test.c
@@ -20,6 +20,8 @@ const char* hashes[] = {
   "sha3_256",
   "sha3_384",
   "sha3_512",
+  "streebog256",
+  "streebog512"
 };
 
 void
diff --git a/testsuite/pbkdf2-test.c b/testsuite/pbkdf2-test.c
index e64a20d09dea..9e024e57b7f5 100644
--- a/testsuite/pbkdf2-test.c
+++ b/testsuite/pbkdf2-test.c
@@ -19,7 +19,8 @@
     ASSERT(dk[expect-&gt;length] == 17);					\
   } while (0)
 
-#define MAX_DKLEN SHA512_DIGEST_SIZE
+/* Streebog test has particularly long testcase */
+#define MAX_DKLEN 100
 
 void
 test_main (void)
@@ -29,6 +30,8 @@ test_main (void)
   struct hmac_sha256_ctx sha256ctx;
   struct hmac_sha512_ctx sha512ctx;
   struct hmac_gosthash94cp_ctx gosthash94cpctx;
+  struct hmac_streebog512_ctx streebog512ctx;
+  struct hmac_streebog256_ctx streebog256ctx;
 
   /* Test vectors for PBKDF2 from RFC 6070. */
 
@@ -134,4 +137,29 @@ test_main (void)
 
   PBKDF2_HMAC_TEST (pbkdf2_hmac_gosthash94cp, LDATA("password"), 1, LDATA("salt"),
 	       SHEX("7314e7c04fb2e662c543674253f68bd0b73445d07f241bed872882da21662d58"));
+
+  hmac_streebog512_set_key (&amp;streebog512ctx, LDATA("password"));
+  PBKDF2_TEST (&amp;streebog512ctx, hmac_streebog512_update, hmac_streebog512_digest,
+	       STREEBOG512_DIGEST_SIZE, 1, LDATA("salt"),
+	       SHEX("64770af7f748c3b1c9ac831dbcfd85c26111b30a8a657ddc3056b80ca73e040d2854fd36811f6d825cc4ab66ec0a68a490a9e5cf5156b3a2b7eecddbf9a16b47"));
 +  PBKDF2_TEST (&amp;streebog512ctx, hmac_streebog512_update, hmac_streebog512_digest,
+	       STREEBOG512_DIGEST_SIZE, 4096, LDATA("salt"),
+	       SHEX("e52deb9a2d2aaff4e2ac9d47a41f34c20376591c67807f0477e32549dc341bc7867c09841b6d58e29d0347c996301d55df0d34e47cf68f4e3c2cdaf1d9ab86c3"));
 +
+  hmac_streebog512_set_key (&amp;streebog512ctx, LDATA("passwordPASSWORDpassword"));
+  PBKDF2_TEST (&amp;streebog512ctx, hmac_streebog512_update, hmac_streebog512_digest,
+	       STREEBOG512_DIGEST_SIZE, 4096, \
LDATA("saltSALTsaltSALTsaltSALTsaltSALTsalt"), +	       \
SHEX("b2d8f1245fc4d29274802057e4b54e0a0753aa22fc53760b301cf008679e58fe4bee9addcae99ba2b0b20f431a9c5e50f395"
 +		    "c89387d0945aedeca6eb4015dfc2bd2421ee9bb71183ba882ceebfef259f33f9e27dc6178cb89dc37428cf9cc52a2baa2d3a"));
 +
+  hmac_streebog512_set_key (&amp;streebog512ctx, LDATA("pass\0word"));
+  PBKDF2_TEST (&amp;streebog512ctx, hmac_streebog512_update, hmac_streebog512_digest,
+	       STREEBOG512_DIGEST_SIZE, 4096, LDATA("sa\0lt"),
+	       SHEX("50df062885b69801a3c10248eb0a27ab6e522ffeb20c991c660f001475d73a4e167f782c18e97e92976d9c1d970831ea78ccb879f67068cdac1910740844e830"));
 +
+  /* Generated */
+  hmac_streebog256_set_key (&amp;streebog256ctx, LDATA("password"));
+  PBKDF2_TEST (&amp;streebog256ctx, hmac_streebog256_update, hmac_streebog256_digest,
+	       STREEBOG256_DIGEST_SIZE, 1, LDATA("salt"),
+	       SHEX("d789458d143b9abebc4ef63ca8e576c72b13c7d4289db23fc1e946f84cd605bc"));
 }
diff --git a/testsuite/streebog-test.c b/testsuite/streebog-test.c
new file mode 100644
index 000000000000..f3532e73a7ee
--- /dev/null
+++ b/testsuite/streebog-test.c
@@ -0,0 +1,81 @@
+#include "testutils.h"
+#include "streebog.h"
+
+/* Using test vectors from the standard itself */
+
+void
+test_main(void)
+{
+  test_hash(&amp;nettle_streebog512,
+            SDATA("012345678901234567890123456789012345678901234567890123456789012"),
 +            SHEX("1b54d01a4af5b9d5 cc3d86d68d285462"
+                 "b19abc2475222f35 c085122be4ba1ffa"
+                 "00ad30f8767b3a82 384c6574f024c311"
+                 "e2a481332b08ef7f 41797891c1646f48"));
+
+  test_hash(&amp;nettle_streebog256,
+            SDATA("012345678901234567890123456789012345678901234567890123456789012"),
 +            SHEX("9d151eefd8590b89 daa6ba6cb74af927"
+                 "5dd051026bb149a4 52fd84e5e57b5500"));
+
+  test_hash(&amp;nettle_streebog512,
+            SHEX("d1e520e2e5f2f0e82c20d1f2f0e8e1ee"
+                 "e6e820e2edf3f6e82c20e2e5fef2fa20"
+                 "f120eceef0ff20f1f2f0e5ebe0ece820"
+                 "ede020f5f0e0e1f0fbff20efebfaeafb"
+                 "20c8e3eef0e5e2fb"),
+            SHEX("1e88e62226bfca6f 9994f1f2d51569e0"
+                 "daf8475a3b0fe61a 5300eee46d961376"
+                 "035fe83549ada2b8 620fcd7c496ce5b3"
+                 "3f0cb9dddc2b6460 143b03dabac9fb28"));
+
+  test_hash(&amp;nettle_streebog256,
+            SHEX("d1e520e2e5f2f0e82c20d1f2f0e8e1ee"
+                 "e6e820e2edf3f6e82c20e2e5fef2fa20"
+                 "f120eceef0ff20f1f2f0e5ebe0ece820"
+                 "ede020f5f0e0e1f0fbff20efebfaeafb"
+                 "20c8e3eef0e5e2fb"),
+            SHEX("9dd2fe4e90409e5d a87f53976d7405b0"
+                 "c0cac628fc669a74 1d50063c557e8f50"));
+
+  test_hash(&amp;nettle_streebog512,
+	    SHEX("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "16111111111111111111111111111111"
+		 "11111111111111111111111111111111"
+		 "11111111111111111111111111111111"
+		 "11111111111111111111111111111116"),
+	    SHEX("8b06f41e59907d9636e892caf5942fcd"
+		 "fb71fa31169a5e70f0edb873664df41c"
+		 "2cce6e06dc6755d15a61cdeb92bd607c"
+		 "c4aaca6732bf3568a23a210dd520fd41"));
+
+  test_hash(&amp;nettle_streebog256,
+	    SHEX("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
+		 "16111111111111111111111111111111"
+		 "11111111111111111111111111111111"
+		 "11111111111111111111111111111111"
+		 "11111111111111111111111111111116"),
+	    SHEX("81bb632fa31fcc38b4c379a662dbc58b"
+		 "9bed83f50d3a1b2ce7271ab02d25babb"));
+
+  test_hash(&amp;nettle_streebog512,
+	    SHEX("ffffffffffffffffffffffffffffffff"
+		 "ffffffffffffffffffffffffffffffff"
+		 "ffffffffffffffffffffffffffffffff"
+		 "ffffffffffffffffffffffffffffffff"
+		 "ffffffffffffffffffffffffffffffff"
+		 "ffffffffffffffffffffffffffffffff"
+		 "ffffffffffffffffffffffffffffffff"
+		 "ffffffffffffffffffffffffffffffff"),
+	    SHEX("90a161d12ad309498d3fe5d48202d8a4"
+		 "e9c406d6a264aeab258ac5ecc37a7962"
+		 "aaf9587a5abb09b6bb81ec4b3752a3ff"
+		 "5a838ef175be5772056bc5fe54fcfc7e"));
+
+}
-- 
2.23.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20191101125754</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-11-01 12:57:54-0400</timestampReceived><subject>ECC code rework</subject><body>

Hello colleagues,

I have been working on support for two particularly strange GOST
curves, which are defined in Weierstrass form, but there exists a
birationally equivalent Untwisted Edwards form (so all sign/verify
calculations should be done in Edwards form).
Major issues came from the fact that I have tried defining generator
point in Edwards form (which is more logical).

During this rework I thought about switching ecc_point from bearing
just x and y coordinates to have per-curve defined coordinates (like
projectile or inverted).

WDYT?

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191202122420</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2019-12-02 12:24:20-0400</timestampReceived><subject>rsa too slow?</subject><body>

Hi,
 I got pinged by someone testing the performance of TLS handshakes and
it seems that gnutls/nettle with RSA is significantly slower than
openssl. On the other hand, secp256r1 and ed25519 are faster. (btw.
both openssl and gnutls/nettle are slower than rusttls). Nevertheless
the RSA caught my attention because I had the impression that nettle
was at some point equivalent if not faster. I see that the hogweed
benchmark values in nettle show a 3x difference in signing for the TR
version and ~2x for the unprotected. Going back to 3.1 did not affect
that. Was that always the case? If not any ideas what could have
caused that? Did we miss some optimizations? (from a quick review of
openssl' RSA code, I see that smooth CRT RSA was added relatively
recently, but could that get such a big performance benefit?)

            name size   sign/ms verify/ms
             rsa 2048    0.8881   27.1422
   rsa (openssl) 2048    1.4249   45.2295

          rsa-tr 2048    0.4257   29.1152
rsa-tr (openssl) 2048    1.3735   46.1692

regards,
Nikos
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191202134015</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-12-02 13:40:15-0400</timestampReceived><subject>Re: rsa too slow?</subject><body>

On Mon, 2019-12-02 at 13:24 +0100, Nikos Mavrogiannopoulos wrote:
&gt; Hi,
&gt;  I got pinged by someone testing the performance of TLS handshakes and
&gt; it seems that gnutls/nettle with RSA is significantly slower than
&gt; openssl. On the other hand, secp256r1 and ed25519 are faster. (btw.
&gt; both openssl and gnutls/nettle are slower than rusttls).

FYI last time I checked rusttls it does not employ any countermeasure,
not even blinding, easy to be fast that way.

&gt;  Nevertheless
&gt; the RSA caught my attention because I had the impression that nettle
&gt; was at some point equivalent if not faster. I see that the hogweed
&gt; benchmark values in nettle show a 3x difference in signing for the TR
&gt; version and ~2x for the unprotected. Going back to 3.1 did not affect
&gt; that. Was that always the case? If not any ideas what could have
&gt; caused that? Did we miss some optimizations? (from a quick review of
&gt; openssl' RSA code, I see that smooth CRT RSA was added relatively
&gt; recently, but could that get such a big performance benefit?)

Would you be able to measure OpenSSL's RSA from a release before the
smooth CRt was added ?

&gt;             name size   sign/ms verify/ms
&gt;              rsa 2048    0.8881   27.1422
&gt;    rsa (openssl) 2048    1.4249   45.2295
&gt; 
&gt;           rsa-tr 2048    0.4257   29.1152
&gt; rsa-tr (openssl) 2048    1.3735   46.1692
&gt; 
&gt; regards,
&gt; Nikos
&gt; _______________________________________________
&gt; nettle-bugs mailing list
&gt; nettle-bugs@lists.lysator.liu.se
&gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

-- 
Simo Sorce
RHEL Crypto Team
Red Hat, Inc




_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191202204031</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-02 20:40:31-0400</timestampReceived><subject>Re: rsa too slow?</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt;  I got pinged by someone testing the performance of TLS handshakes and
&gt; it seems that gnutls/nettle with RSA is significantly slower than
&gt; openssl. 

To quote the NEWS file for Nettle-3.4.1:

 Performance regression:

 * All RSA private key operations employing RSA blinding, i.e.,
   rsa_decrypt_tr, rsa_*_sign_tr, the new rsa_sec_decrypt, and
   rsa_compute_root_tr, are significantly slower. This is
   because (i) RSA blinding now use side-channel silent
   operations, (ii) blinding includes a modular inversion, and
   (iii) side-channel silent modular inversion, implemented as
   mpn_sec_invert, is very expensive. A 60% slowdown for
   2048-bit RSA keys have been measured.

&gt;             name size   sign/ms verify/ms
&gt;              rsa 2048    0.8881   27.1422
&gt;    rsa (openssl) 2048    1.4249   45.2295
&gt;
&gt;           rsa-tr 2048    0.4257   29.1152
&gt; rsa-tr (openssl) 2048    1.3735   46.1692

The above explains why Nettle's rsa-tr is much slower than the non-tr
version. But it's disappointing that there also looks like a pretty
large general slowdown.

I think most of the running time for RSA operations, except for modular
inversion, are in wel-tuned GMP functions. For best speed, make sure GMP
is either compiled with --enable-fat, or configured for the machine it's
running on, and use a recent version. To track down any problems, it's
important to know more precisely what processor it's running on and how
gmp was configured.

For what it's worth, this is what I get on the laptop (quite old, "U4100
@ 1.30GHz" according to /proc/cpuinfo, should probably be "SU4100",
detected as core2-pc-linux-gnu by gmp) I'm sitting in front of right
now:

$ ../examples/hogweed-benchmark rsa
            name size   sign/ms verify/ms
             rsa 2048    0.2106    7.2703
          rsa-tr 2048    0.1158    6.8202
   rsa (openssl) 2048    0.2024    6.4992
rsa-tr (openssl) 2048    0.1959    6.4983

So here, Nettle is slightly faster except for side-channel silent
signing. It's a bit odd that *verify* for rsa-tr appears slower than the
non-tr, since no secrets are involved, and the same function is called.
May be a problem in the benchmark program.

Is "Smooth CRT" something that I should look up?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191203075916</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2019-12-03 07:59:16-0400</timestampReceived><subject>Re: rsa too slow?</subject><body>

On Mon, Dec 2, 2019 at 9:47 PM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; &gt;             name size   sign/ms verify/ms
&gt; &gt;              rsa 2048    0.8881   27.1422
&gt; &gt;    rsa (openssl) 2048    1.4249   45.2295
&gt; &gt;
&gt; &gt;           rsa-tr 2048    0.4257   29.1152
&gt; &gt; rsa-tr (openssl) 2048    1.3735   46.1692
&gt;
&gt; The above explains why Nettle's rsa-tr is much slower than the non-tr
&gt; version. But it's disappointing that there also looks like a pretty
&gt; large general slowdown.
&gt;
&gt; I think most of the running time for RSA operations, except for modular
&gt; inversion, are in wel-tuned GMP functions. For best speed, make sure GMP
&gt; is either compiled with --enable-fat, or configured for the machine it's
&gt; running on, and use a recent version. To track down any problems, it's
&gt; important to know more precisely what processor it's running on and how
&gt; gmp was configured.

That seemed trivial before I wrote this email, but that was actually
the case. The fedora maintainer had removed the --enable-fat option in
a seemingly unrelated commit. I've reported it at:
https://bugzilla.redhat.com/show_bug.cgi?id=1779060

&gt; Is "Smooth CRT" something that I should look up?

I do not know more about it. I only saw that in the openssl commit
claims a speed up but without any numbers.

regards,
Nikos

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191203105618</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2019-12-03 10:56:18-0400</timestampReceived><subject>Re: rsa too slow?</subject><body>

On Tue, 2019-12-03 at 08:59 +0100, Nikos Mavrogiannopoulos wrote:
&gt; On Mon, Dec 2, 2019 at 9:47 PM Niels Möller &lt;nisse@lysator.liu.se&gt;
&gt; wrote:
&gt; &gt; &gt;             name size   sign/ms verify/ms
&gt; &gt; &gt;              rsa 2048    0.8881   27.1422
&gt; &gt; &gt;    rsa (openssl) 2048    1.4249   45.2295
&gt; &gt; &gt; 
&gt; &gt; &gt;           rsa-tr 2048    0.4257   29.1152
&gt; &gt; &gt; rsa-tr (openssl) 2048    1.3735   46.1692
&gt; &gt; 
&gt; &gt; The above explains why Nettle's rsa-tr is much slower than the non-
&gt; &gt; tr
&gt; &gt; version. But it's disappointing that there also looks like a pretty
&gt; &gt; large general slowdown.
&gt; &gt; 
&gt; &gt; I think most of the running time for RSA operations, except for
&gt; &gt; modular
&gt; &gt; inversion, are in wel-tuned GMP functions. For best speed, make
&gt; &gt; sure GMP
&gt; &gt; is either compiled with --enable-fat, or configured for the machine
&gt; &gt; it's
&gt; &gt; running on, and use a recent version. To track down any problems,
&gt; &gt; it's
&gt; &gt; important to know more precisely what processor it's running on and
&gt; &gt; how
&gt; &gt; gmp was configured.
&gt; 
&gt; That seemed trivial before I wrote this email, but that was actually
&gt; the case. The fedora maintainer had removed the --enable-fat option
&gt; in
&gt; a seemingly unrelated commit. I've reported it at:
&gt; https://bugzilla.redhat.com/show_bug.cgi?id=1779060

Hmm even after --enable-fat was given to gmp not much has changed.

My CPU is Intel(R) Core(TM) i7-8650U CPU @ 1.90GHz and that's what I
see:

1. gmp without --enable-fat
             rsa 2048    0.8881   27.1422

2. gmp with --enable-fat
             rsa 2048    1.0973   40.4561

3. gmp with --enable-fat compiled outside distribution (as ./configure
--enable-fat)
             rsa 2048    1.5127   53.6693

The corresponding value on that cpu for openssl's RSA is:
             rsa (openssl) 2048    1.9212   61.4107

So it may be that it is quite hard to get good values out of gmp
without having a custom compilation. In particular I see that locally I
have:
-mtune=skylake  -march=broadwell -fomit-frame-pointer

while fedora sets: -mtune=generic and the --enable-fat is not
sufficient to overcome this.

regards,
Nikos


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191121192202</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-11-21 19:22:02-0400</timestampReceived><subject>Re: ECC code rework</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; I have been working on support for two particularly strange GOST
&gt; curves, which are defined in Weierstrass form, but there exists a
&gt; birationally equivalent Untwisted Edwards form (so all sign/verify
&gt; calculations should be done in Edwards form).

I've merged some of Daiki's preparations for curve448 (also equivalent
to an untwisted edwards curve) to master-updates, to be merged to master
as soon as ci looks ok. I'm sorry this has been stalled. Initially it
had to wait for a release (since before nettle-3.5, the changes to
struct ecc_curve would be a subtle abi break, and nettle-3.4 was part of
that transition), but then it has dragged on.

&gt; During this rework I thought about switching ecc_point from bearing
&gt; just x and y coordinates to have per-curve defined coordinates (like
&gt; projectile or inverted).

Struct ecc_point is intended to be a public api, which should be
independent of the implementation's preferred representation. So just
two numbers x, y.

That doesn't specify choice of coordinates precisely, though. For the
nist curves, it's coordinates for Weierstrass form, since that's how the
curves are specified. For curve25519 (and curve448, when completed), the
main api uses octet strings for input and output, so struct ecc_point is
not that important. For the GOST curves, I don't know, but I think we should
use the coordinates that are most useful for applications.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191121220935</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-11-21 22:09:35-0400</timestampReceived><subject>Re: ECC code rework</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I've merged some of Daiki's preparations for curve448 (also equivalent
&gt; to an untwisted edwards curve) to master-updates, to be merged to master
&gt; as soon as ci looks ok.

The gnutls tests failed, see
https://gitlab.com/gnutls/nettle/-/jobs/357863630.

Unclear to me if it's the nettle change or some unrelated problem.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191122062839</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-11-22 06:28:39-0400</timestampReceived><subject>Re: ECC code rework</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; The gnutls tests failed, see
&gt; https://gitlab.com/gnutls/nettle/-/jobs/357863630.

These are the failing gnutls tests:

FAIL: chainverify
FAIL: key-import-export
FAIL: privkey-keygen
FAIL: x509sign-verify-gost
FAIL: key-export-pkcs8
FAIL: pkcs11/pkcs11-chainverify

&gt; Unclear to me if it's the nettle change or some unrelated problem.

Some look related to gost curves, and the privkey-keygen failure is for
a variant of ed25519.

  Generated key with EdDSA (Ed25519)-160
  FAIL privkey-keygen (exit status: 139)

There are similar failures on the ecc-sqrt branch,

https://gitlab.com/gnutls/nettle/-/jobs/321736090

from a few weeks ago.

Both branches included changes to the internal struct ecc_curve. So
either gnutls is exercising some nettle features with poor test coverage
in nettle's own tests, or gnutls is somehow depending on internals.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191122095335</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-11-22 09:53:35-0400</timestampReceived><subject>Re: ECC code rework</subject><body>

Hello,

пт, 22 нояб. 2019 г. в 09:28, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt; &gt; The gnutls tests failed, see
&gt; &gt; https://gitlab.com/gnutls/nettle/-/jobs/357863630.
&gt;
&gt; These are the failing gnutls tests:
&gt;
&gt; FAIL: chainverify
&gt; FAIL: key-import-export
&gt; FAIL: privkey-keygen
&gt; FAIL: x509sign-verify-gost
&gt; FAIL: key-export-pkcs8
&gt; FAIL: pkcs11/pkcs11-chainverify
&gt;
&gt; &gt; Unclear to me if it's the nettle change or some unrelated problem.
&gt;
&gt; Some look related to gost curves, and the privkey-keygen failure is for
&gt; a variant of ed25519.

GOST curves support in GnuTLS depends on exact Nettle ABI. I'd propose
to add --disable-gost to Nettle's GnuTLS execution for now, till ECC
ABI gets stable again.

An alternative approach would be to define a symbol like
NETTLE_ECC_ABI_2 which can be used to detect ECC ABI compatibility.

ed25519 should not be directly tied to ABI compat. I'll take a look.

&gt;   Generated key with EdDSA (Ed25519)-160
&gt;   FAIL privkey-keygen (exit status: 139)
&gt;
&gt; There are similar failures on the ecc-sqrt branch,
&gt;
&gt; https://gitlab.com/gnutls/nettle/-/jobs/321736090
&gt;
&gt; from a few weeks ago.
&gt;
&gt; Both branches included changes to the internal struct ecc_curve. So
&gt; either gnutls is exercising some nettle features with poor test coverage
&gt; in nettle's own tests, or gnutls is somehow depending on internals.



-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191122141558</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-11-22 14:15:58-0400</timestampReceived><subject>Re: ECC code rework</subject><body>

чт, 21 нояб. 2019 г. в 22:22, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt; &gt; During this rework I thought about switching ecc_point from bearing
&gt; &gt; just x and y coordinates to have per-curve defined coordinates (like
&gt; &gt; projectile or inverted).
&gt;
&gt; Struct ecc_point is intended to be a public api, which should be
&gt; independent of the implementation's preferred representation. So just
&gt; two numbers x, y.

ecc_point_set/_get() are fine from my point of view. I was working on
internal ecc_point representation (w/o size changes).

Basically I have two strange curves which are defined in Weierstrass
form, but have equivalent Untwisted Edwards form. I planned to make
ecc_point_set/get convert between x,y and u,v,w (and to store these
coordinates in ecc_point). To make things easier I also changed secp
curves to store x,y,z in ecc_point.


-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191122151654</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-11-22 15:16:54-0400</timestampReceived><subject>Re: ECC code rework</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; Basically I have two strange curves which are defined in Weierstrass
&gt; form, but have equivalent Untwisted Edwards form. I planned to make
&gt; ecc_point_set/get convert between x,y and u,v,w (and to store these
&gt; coordinates in ecc_point).

Then the internal representation would be plain limb arrays holding u,
v, w in order. With individual coordinates in ordinary or montgomery
representation, depending on what makes the reduce operation most
efficient.

Now I'm getting unsure about what should go in the struct ecc_point limb
array. But I think curve implementation has some room to choose it's
preferred representation.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191122153601</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-11-22 15:36:01-0400</timestampReceived><subject>Re: ECC code rework</subject><body>

пт, 22 нояб. 2019 г., 18:16 Niels Möller &lt;nisse@lysator.liu.se&gt;:

&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; Basically I have two strange curves which are defined in Weierstrass
&gt; &gt; form, but have equivalent Untwisted Edwards form. I planned to make
&gt; &gt; ecc_point_set/get convert between x,y and u,v,w (and to store these
&gt; &gt; coordinates in ecc_point).
&gt;
&gt; Then the internal representation would be plain limb arrays holding u,
&gt; v, w in order. With individual coordinates in ordinary or montgomery
&gt; representation, depending on what makes the reduce operation most
&gt; efficient.
&gt;

Yes, I've implemented it exactly in this way.



&gt; Now I'm getting unsure about what should go in the struct ecc_point limb
&gt; array. But I think curve implementation has some room to choose it's
&gt; preferred representation.
&gt;


Currently I have xyz for secp curves and uvw for edwards curves.



&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
&gt; Internet email is subject to wholesale government surveillance.
&gt;
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191124084545</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-11-24 08:45:45-0400</timestampReceived><subject>Re: ECC code rework</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; GOST curves support in GnuTLS depends on exact Nettle ABI. I'd propose
&gt; to add --disable-gost to Nettle's GnuTLS execution for now, till ECC
&gt; ABI gets stable again.

I've just pushed a change to the .gitlab-ci file, so I hope the next
build looks better.

&gt; An alternative approach would be to define a symbol like
&gt; NETTLE_ECC_ABI_2 which can be used to detect ECC ABI compatibility.

For code depending on nettle internals, maybe you can use facilities in
nettle/version.h (both compile time and runtime check would be
appropriate, since changes to struct ecc_curve is no longer considered a
change to the public abi, and will not imply an soname change or
anything like that).

&gt; ed25519 should not be directly tied to ABI compat. I'll take a look.

Thanks.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191124103510</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-11-24 10:35:10-0400</timestampReceived><subject>Re: ECC code rework</subject><body>

Hello,

вс, 24 нояб. 2019 г. в 11:45, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; GOST curves support in GnuTLS depends on exact Nettle ABI. I'd propose
&gt; &gt; to add --disable-gost to Nettle's GnuTLS execution for now, till ECC
&gt; &gt; ABI gets stable again.
&gt;
&gt; I've just pushed a change to the .gitlab-ci file, so I hope the next
&gt; build looks better.

GnuTLS also received a MR to fix tests in minimal build, so next
master-updates build should succeed.

&gt; &gt; An alternative approach would be to define a symbol like
&gt; &gt; NETTLE_ECC_ABI_2 which can be used to detect ECC ABI compatibility.
&gt;
&gt; For code depending on nettle internals, maybe you can use facilities in
&gt; nettle/version.h (both compile time and runtime check would be
&gt; appropriate, since changes to struct ecc_curve is no longer considered a
&gt; change to the public abi, and will not imply an soname change or
&gt; anything like that).

The problem is that both 3.5(.1) and master have same version. I just
hope that we can get all ECC changes in single release.

&gt; &gt; ed25519 should not be directly tied to ABI compat. I'll take a look.

Should work now. The test message was misleading. It also was a GOST issue.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191225110111</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-25 11:01:11-0400</timestampReceived><subject>Current ECC work</subject><body>

I've now merged Daiki's implementation of curve448, and I've done some
followup cleanups: Moving and renaming edwards/twisted edwards
functions, and using a shared ecc_mul_m function for both curve25519_mul
and curve448_mul.

Pending work:

1. Eddsa signatures with curve448. Needs SHAKE support first (Daiki
   posted patches for this long ago).

2. Renaming of stuff using curve names consistently (recent patches by
   Dmitry). Preparation for new gost curves.

3. I'm considering changing the struct ecc_point representation to use
   montgomery representation of the for the individual coordinates, for
   primes where we use that. Then ecc_a_to_* will (almost?) be
   redundant. This is inline with also adding other coordinate changes
   here, if that will be needed for new curves. For the inverse
   functions, ecc_*_to_a, they're currently repsonsible both for
   inverting and eliminating the redundant z coordinate, and converting
   individual coordinates back from montgomery representation, when
   needed.

4. Adding support for compact representation (patches from Wim Lewis). I
   have some of the preparations merged on a branch, but I think it will
   be simpler if (3) is done first.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191203185015</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-03 18:50:15-0400</timestampReceived><subject>Re: rsa too slow?</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt; writes:

&gt; Hmm even after --enable-fat was given to gmp not much has changed.
&gt;
&gt; My CPU is Intel(R) Core(TM) i7-8650U CPU @ 1.90GHz and that's what I
&gt; see:
&gt;
&gt; 1. gmp without --enable-fat
&gt;              rsa 2048    0.8881   27.1422
&gt;
&gt; 2. gmp with --enable-fat
&gt;              rsa 2048    1.0973   40.4561
&gt;
&gt; 3. gmp with --enable-fat compiled outside distribution (as ./configure
&gt; --enable-fat)
&gt;              rsa 2048    1.5127   53.6693

That's quite a big difference. 

&gt; The corresponding value on that cpu for openssl's RSA is:
&gt;              rsa (openssl) 2048    1.9212   61.4107
&gt;
&gt; So it may be that it is quite hard to get good values out of gmp
&gt; without having a custom compilation. In particular I see that locally I
&gt; have:
&gt; -mtune=skylake  -march=broadwell -fomit-frame-pointer
&gt;
&gt; while fedora sets: -mtune=generic and the --enable-fat is not
&gt; sufficient to overcome this.

Those flags should only affect the code generated by the C compiler, and
I'd expect all critical loops to be in assembly on your machine.

But --enable-fat is more than just selecting the right assembly code at
runtime, also various thresholds should be set depending on the cpu
type. What performance do you get from a default (non-fat) build on your
machine? The default will select code and thresholds based on (the
gmp-specific) config.guess.

Maybe send a mail to the gmp-discuss or gmp-bugs list and ask for advice
(see https://gmplib.org/#MAILINGLISTS)? Don't forget to say precisely
which GMP version you're using.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191205081604</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-05 08:16:04-0400</timestampReceived><subject>Re: [RFC] ecc: switch away from affine points representation</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; Would it be ok to change ecc_point size to become a per curve option?

If needed, yes.

(I've also been considering switching to using extended X,Y,Z,T
coordinates as internal representation for twisted edwards curves, but
unclear if it's worth the effort. See the section on cooordinate choice
on https://www.lysator.liu.se/~nisse/misc/ed25519-msp430.html for some
details).

&gt; A close rival to ecdsa sign/verify (see rfc 7091 and 5832).

Ok, I'll have to look that up (but not at the moment).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191205160924</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-12-05 16:09:24-0400</timestampReceived><subject>[PATCH v2] ecc: rename source files with curves data</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

In preparation to adding GOST curves support, rename source files and
use curve name as eccdata parameter.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 .gitignore                                    | 14 ++---
 Makefile.in                                   | 54 ++++++++---------
 ...cc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} |  0
 ...cc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} |  0
 ...cc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} |  0
 ...cc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} |  0
 ...cc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} |  0
 configure.ac                                  |  5 +-
 ecc-25519.c =&gt; ecc-curve25519.c               |  4 +-
 ecc-448.c =&gt; ecc-curve448.c                   |  4 +-
 ecc-192.c =&gt; ecc-secp192r1.c                  |  4 +-
 ecc-224.c =&gt; ecc-secp224r1.c                  |  4 +-
 ecc-256.c =&gt; ecc-secp256r1.c                  |  4 +-
 ecc-384.c =&gt; ecc-secp384r1.c                  |  4 +-
 ecc-521.c =&gt; ecc-secp521r1.c                  |  4 +-
 eccdata.c                                     | 58 +++++++++++--------
 ...25519-modp.asm =&gt; ecc-curve25519-modp.asm} |  0
 ...cc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} |  0
 ...cc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} |  0
 ...cc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} |  0
 ...cc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} |  0
 ...cc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} |  0
 22 files changed, 85 insertions(+), 74 deletions(-)
 rename arm/{ecc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} (100%)
 rename arm/{ecc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} (100%)
 rename arm/{ecc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} (100%)
 rename arm/{ecc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} (100%)
 rename arm/{ecc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} (100%)
 rename ecc-25519.c =&gt; ecc-curve25519.c (99%)
 rename ecc-448.c =&gt; ecc-curve448.c (99%)
 rename ecc-192.c =&gt; ecc-secp192r1.c (98%)
 rename ecc-224.c =&gt; ecc-secp224r1.c (98%)
 rename ecc-256.c =&gt; ecc-secp256r1.c (99%)
 rename ecc-384.c =&gt; ecc-secp384r1.c (99%)
 rename ecc-521.c =&gt; ecc-secp521r1.c (98%)
 rename x86_64/{ecc-25519-modp.asm =&gt; ecc-curve25519-modp.asm} (100%)
 rename x86_64/{ecc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} (100%)
 rename x86_64/{ecc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} (100%)
 rename x86_64/{ecc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} (100%)
 rename x86_64/{ecc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} (100%)
 rename x86_64/{ecc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} (100%)

diff --git a/.gitignore b/.gitignore
index 0afe61de3826..ea264107fa40 100644
--- a/.gitignore
+++ b/.gitignore
@@ -43,13 +43,13 @@ core
 /keymap.h
 /parity.h
 /rotors.h
-/ecc-192.h
-/ecc-224.h
-/ecc-256.h
-/ecc-384.h
-/ecc-521.h
-/ecc-25519.h
-/ecc-448.h
+/ecc-curve25519.h
+/ecc-curve448.h
+/ecc-secp192r1.h
+/ecc-secp224r1.h
+/ecc-secp256r1.h
+/ecc-secp384r1.h
+/ecc-secp521r1.h
 /version.h
 /nettle.aux
 /nettle.cp
diff --git a/Makefile.in b/Makefile.in
index 036a3a1d7f8b..333044a19705 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -174,8 +174,9 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  gmp-glue.c cnd-copy.c \
 		  ecc-mod.c ecc-mod-inv.c \
 		  ecc-mod-arith.c ecc-pp1-redc.c ecc-pm1-redc.c \
-		  ecc-192.c ecc-224.c ecc-256.c ecc-384.c ecc-521.c \
-		  ecc-25519.c ecc-448.c \
+		  ecc-curve25519.c ecc-curve448.c \
+		  ecc-secp192r1.c ecc-secp224r1.c ecc-secp256r1.c \
+		  ecc-secp384r1.c ecc-secp521r1.c \
 		  ecc-size.c ecc-j-to-a.c ecc-a-to-j.c \
 		  ecc-dup-jj.c ecc-add-jja.c ecc-add-jjj.c \
 		  ecc-eh-to-a.c \
@@ -346,24 +347,24 @@ des.$(OBJEXT): des.c des.h $(des_headers)
 # k = 14, c =  7, S = 256, T =  42 ( 28 A + 14 D) 12 KB
 # k = 11, c =  6, S = 192, T =  44 ( 33 A + 11 D)  9 KB
 # k = 16, c =  6, S = 128, T =  48 ( 32 A + 16 D)  6 KB
-ecc-192.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 192 8 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp192r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp192r1 8 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 224:
 # k = 16, c =  7, S = 256, T =  48 ( 32 A + 16 D) ~16 KB
 # k = 10, c =  6, S = 256, T =  50 ( 40 A + 10 D) ~16 KB
 # k = 13, c =  6, S = 192, T =  52 ( 39 A + 13 D) ~12 KB
 # k =  9, c =  5, S = 160, T =  54 ( 45 A +  9 D) ~10 KB
-ecc-224.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 224 16 7 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp224r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp224r1 16 7 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 256:
 # k =  9, c =  6, S = 320, T =  54 ( 45 A +  9 D) 20 KB
 # k = 11, c =  6, S = 256, T =  55 ( 44 A + 11 D) 16 KB
 # k = 19, c =  7, S = 256, T =  57 ( 38 A + 19 D) 16 KB
 # k = 15, c =  6, S = 192, T =  60 ( 45 A + 15 D) 12 KB
-ecc-256.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 256 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp256r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp256r1 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 384:
 # k = 16, c =  6, S = 256, T =  80 ( 64 A + 16 D) 24 KB
@@ -373,35 +374,35 @@ ecc-256.h: eccdata.stamp
 # k = 13, c =  5, S = 192, T =  91 ( 78 A + 13 D) 18 KB
 # k = 16, c =  5, S = 160, T =  96 ( 80 A + 16 D) 15 KB
 # k = 32, c =  6, S = 128, T =  96 ( 64 A + 32 D) 12 KB
-ecc-384.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 384 32 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp384r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp384r1 32 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 521:
 # k = 29, c =  6, S = 192, T = 116 ( 87 A + 29 D) ~27 KB
 # k = 21, c =  5, S = 160, T = 126 (105 A + 21 D) ~23 KB
 # k = 44, c =  6, S = 128, T = 132 ( 88 A + 44 D) ~18 KB
 # k = 35, c =  5, S =  96, T = 140 (105 A + 35 D) ~14 KB
-ecc-521.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 521 44 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp521r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp521r1 44 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
-# Parameter choices mostly the same as for ecc-256.h.
-ecc-25519.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 255 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+# Parameter choices mostly the same as for ecc-secp256r1.h.
+ecc-curve25519.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) curve25519 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
-ecc-448.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 448 38 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-curve448.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) curve448 38 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 eccdata.stamp: eccdata.c
 	$(MAKE) eccdata$(EXEEXT_FOR_BUILD)
 	echo stamp &gt; eccdata.stamp
 
-ecc-192.$(OBJEXT): ecc-192.h
-ecc-224.$(OBJEXT): ecc-224.h
-ecc-256.$(OBJEXT): ecc-256.h
-ecc-384.$(OBJEXT): ecc-384.h
-ecc-521.$(OBJEXT): ecc-521.h
-ecc-25519.$(OBJEXT): ecc-25519.h
-ecc-448.$(OBJEXT): ecc-448.h
+ecc-curve25519.$(OBJEXT): ecc-curve25519.h
+ecc-curve448.$(OBJEXT): ecc-curve448.h
+ecc-secp192r1.$(OBJEXT): ecc-secp192r1.h
+ecc-secp224r1.$(OBJEXT): ecc-secp224r1.h
+ecc-secp256r1.$(OBJEXT): ecc-secp256r1.h
+ecc-secp384r1.$(OBJEXT): ecc-secp384r1.h
+ecc-secp521r1.$(OBJEXT): ecc-secp521r1.h
 
 .asm.$(OBJEXT): $(srcdir)/asm.m4 machine.m4 config.m4
 	$(M4) $(srcdir)/asm.m4 machine.m4 config.m4 $&lt; &gt;$*.s
@@ -654,8 +655,9 @@ distcheck: dist
 
 clean-here:
 	-rm -f $(TARGETS) *.$(OBJEXT) *.s *.so *.dll *.a \
-		ecc-192.h ecc-224.h ecc-256.h ecc-384.h ecc-521.h ecc-25519.h \
-		ecc-448.h \
+		ecc-curve25519.h ecc-curve448.h \
+		ecc-secp192r1.h ecc-secp224r1.h ecc-secp256r1.h \
+		ecc-secp384r1.h ecc-secp521r1.h \
 		aesdata$(EXEEXT_FOR_BUILD) \
 		desdata$(EXEEXT_FOR_BUILD) \
 		twofishdata$(EXEEXT_FOR_BUILD) \
diff --git a/arm/ecc-192-modp.asm b/arm/ecc-secp192r1-modp.asm
similarity index 100%
rename from arm/ecc-192-modp.asm
rename to arm/ecc-secp192r1-modp.asm
diff --git a/arm/ecc-224-modp.asm b/arm/ecc-secp224r1-modp.asm
similarity index 100%
rename from arm/ecc-224-modp.asm
rename to arm/ecc-secp224r1-modp.asm
diff --git a/arm/ecc-256-redc.asm b/arm/ecc-secp256r1-redc.asm
similarity index 100%
rename from arm/ecc-256-redc.asm
rename to arm/ecc-secp256r1-redc.asm
diff --git a/arm/ecc-384-modp.asm b/arm/ecc-secp384r1-modp.asm
similarity index 100%
rename from arm/ecc-384-modp.asm
rename to arm/ecc-secp384r1-modp.asm
diff --git a/arm/ecc-521-modp.asm b/arm/ecc-secp521r1-modp.asm
similarity index 100%
rename from arm/ecc-521-modp.asm
rename to arm/ecc-secp521r1-modp.asm
diff --git a/configure.ac b/configure.ac
index 3547cae4ee15..cbc914dbf14b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -475,8 +475,9 @@ asm_nettle_optional_list="gcm-hash8.asm cpuid.asm \
 
 asm_hogweed_optional_list=""
 if test "x$enable_public_key" = "xyes" ; then
-  asm_hogweed_optional_list="ecc-192-modp.asm ecc-224-modp.asm \
-    ecc-25519-modp.asm ecc-256-redc.asm ecc-384-modp.asm ecc-521-modp.asm"
+  asm_hogweed_optional_list="ecc-curve25519-modp.asm \
+    ecc-secp192r1-modp.asm ecc-secp224r1-modp.asm \
+    ecc-secp256r1-redc.asm ecc-secp384r1-modp.asm ecc-secp521r1-modp.asm"
 fi
 
 OPT_NETTLE_OBJS=""
diff --git a/ecc-25519.c b/ecc-curve25519.c
similarity index 99%
rename from ecc-25519.c
rename to ecc-curve25519.c
index 105ce0f4fbc1..e6a1b325be66 100644
--- a/ecc-25519.c
+++ b/ecc-curve25519.c
@@ -1,4 +1,4 @@
-/* ecc-25519.c
+/* ecc-curve25519.c
 
    Arithmetic and tables for curve25519,
 
@@ -42,7 +42,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-25519.h"
+#include "ecc-curve25519.h"
 
 #define PHIGH_BITS (GMP_NUMB_BITS * ECC_LIMB_SIZE - 255)
 
diff --git a/ecc-448.c b/ecc-curve448.c
similarity index 99%
rename from ecc-448.c
rename to ecc-curve448.c
index 7d68e1c8e743..04b51bdf88fd 100644
--- a/ecc-448.c
+++ b/ecc-curve448.c
@@ -1,4 +1,4 @@
-/* ecc-448.c
+/* ecc-curve448.c
 
    Arithmetic and tables for curve448,
 
@@ -43,7 +43,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-448.h"
+#include "ecc-curve448.h"
 
 #if GMP_NUMB_BITS == 64
 static void
diff --git a/ecc-192.c b/ecc-secp192r1.c
similarity index 98%
rename from ecc-192.c
rename to ecc-secp192r1.c
index 4b756ffd7e8f..858a1b7554ce 100644
--- a/ecc-192.c
+++ b/ecc-secp192r1.c
@@ -1,4 +1,4 @@
-/* ecc-192.c
+/* ecc-secp192r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -46,7 +46,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-192.h"
+#include "ecc-secp192r1.h"
 
 #if HAVE_NATIVE_ecc_192_modp
 
diff --git a/ecc-224.c b/ecc-secp224r1.c
similarity index 98%
rename from ecc-224.c
rename to ecc-secp224r1.c
index bf90f848c1b2..4d82f54b57fd 100644
--- a/ecc-224.c
+++ b/ecc-secp224r1.c
@@ -1,4 +1,4 @@
-/* ecc-224.c
+/* ecc-secp224r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -52,7 +52,7 @@ ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #define ecc_224_modp ecc_mod
 #endif
 
-#include "ecc-224.h"
+#include "ecc-secp224r1.h"
 
 #if ECC_REDC_SIZE &lt; 0
 # define ecc_224_redc ecc_pm1_redc
diff --git a/ecc-256.c b/ecc-secp256r1.c
similarity index 99%
rename from ecc-256.c
rename to ecc-secp256r1.c
index 3e6ae4e2a8b6..7b873b5f7724 100644
--- a/ecc-256.c
+++ b/ecc-secp256r1.c
@@ -1,4 +1,4 @@
-/* ecc-256.c
+/* ecc-secp256r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -48,7 +48,7 @@
 # define USE_REDC (ECC_REDC_SIZE != 0)
 #endif
 
-#include "ecc-256.h"
+#include "ecc-secp256r1.h"
 
 #if HAVE_NATIVE_ecc_256_redc
 # define ecc_256_redc nettle_ecc_256_redc
diff --git a/ecc-384.c b/ecc-secp384r1.c
similarity index 99%
rename from ecc-384.c
rename to ecc-secp384r1.c
index 5bb2a2476eec..248b1cf3ef2b 100644
--- a/ecc-384.c
+++ b/ecc-secp384r1.c
@@ -1,4 +1,4 @@
-/* ecc-384.c
+/* ecc-secp384r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -44,7 +44,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-384.h"
+#include "ecc-secp384r1.h"
 
 #if HAVE_NATIVE_ecc_384_modp
 #define ecc_384_modp nettle_ecc_384_modp
diff --git a/ecc-521.c b/ecc-secp521r1.c
similarity index 98%
rename from ecc-521.c
rename to ecc-secp521r1.c
index 8ca0e6d2dd64..cc7473035cff 100644
--- a/ecc-521.c
+++ b/ecc-secp521r1.c
@@ -1,4 +1,4 @@
-/* ecc-521.c
+/* ecc-secp521r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -42,7 +42,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-521.h"
+#include "ecc-secp521r1.h"
 
 #if HAVE_NATIVE_ecc_521_modp
 #define ecc_521_modp nettle_ecc_521_modp
diff --git a/eccdata.c b/eccdata.c
index 74002c1f305e..d76a42bcde6f 100644
--- a/eccdata.c
+++ b/eccdata.c
@@ -432,11 +432,10 @@ ecc_curve_init_str (struct ecc_curve *ecc, enum ecc_type type,
 }
 
 static void
-ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
+ecc_curve_init (struct ecc_curve *ecc, const char *curve)
 {
-  switch (bit_size)
+  if (!strcmp (curve, "secp192r1"))
     {
-    case 192:      
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{192} - 2^{64} - 1 */
 			  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE"
@@ -466,8 +465,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "35433907297cc378b0015703374729d7a4fe46647084e4ba",
 		   "a2649984f2135c301ea3acb0776cd4f125389b311db3be32");
 
-      break;
-    case 224:
+    }
+  else if (!strcmp (curve, "secp224r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{224} - 2^{96} + 1 */
 			  "ffffffffffffffffffffffffffffffff"
@@ -498,8 +498,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "ae99feebb5d26945b54892092a8aee02912930fa41cd114e40447301",
 		   "482580a0ec5bc47e88bc8c378632cd196cb3fa058a7114eb03054c9");
 
-      break;
-    case 256:
+    }
+  else if (!strcmp (curve, "secp256r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{256} - 2^{224} + 2^{192} + 2^{96} - 1 */
 			  "FFFFFFFF000000010000000000000000"
@@ -530,8 +531,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "e2534a3532d08fbba02dde659ee62bd0031fe2db785596ef509302446b030852",
 		   "e0f1575a4c633cc719dfee5fda862d764efc96c3f30ee0055c42c23f184ed8c6");
 
-      break;
-    case 384:
+    }
+  else if (!strcmp (curve, "secp384r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{384} - 2^{128} - 2^{96} + 2^{32} - 1 */
 			  "ffffffffffffffffffffffffffffffff"
@@ -567,8 +569,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "138251cd52ac9298c1c8aad977321deb97e709bd0b4ca0aca55dc8ad51dcfc9d1589a1597e3a5120e1efd631c63e1835",
                
 		   "cacae29869a62e1631e8a28181ab56616dc45d918abc09f3ab0e63cf792aa4dced7387be37bba569549f1c02b270ed67");
  
-      break;
-    case 521:
+    }
+  else if (!strcmp (curve, "secp521r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  "1ff" /* p = 2^{521} - 1 */
 			  "ffffffffffffffffffffffffffffffff"
@@ -613,9 +616,15 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "35b5df64ae2ac204c354b483487c9070cdc61c891c5ff39afc06c5d55541d3ceac8659e24afe3d0750e8b88e9f078af066a1d5025b08e5a5e2fbc87412871902f3",
                
 		   "82096f84261279d2b673e0178eb0b4abb65521aef6e6e32e1b5ae63fe2f19907f279f283e54ba385405224f750a95b85eebb7faef04699d1d9e21f47fc346e4d0d");
  
-      break;
-    case 255:
-      /* Edwards curve used for eddsa25519 and curve25519,
+    }
+  else if (!strcmp (curve, "curve25519"))
+    {
+      /* curve25519, y^2 = x^3 + 486662 x^2 + x (mod p), with p = 2^{255} - 19.
+
+	 According to http://cr.yp.to/papers.html#newelliptic, this
+	 is birationally equivalent to the Edwards curve
+
+	   x^2 + y^2 = 1 + (121665/121666) x^2 y^2 (mod p).
 
 	   -x^2 + y^2 = 1 - (121665/121666) x^2 y^2, with p = 2^{255} - 19.
 
@@ -664,9 +673,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "1a739ec193ce1547493aa657c4c9f870",
 		   "47d0e827cb1595e1470eb88580d5716c"
 		   "4cf22832ea2f0ff0df38ab61ca32112f");
-      break;
-
-    case 448:
+    }
+  else if (!strcmp (curve, "curve448"))
+    {
       /* curve448, y^2 = x^3 + 156326 x^2 + x (mod p), with p = 2^{448} - 2^{224} - \
1.  
 	 According to RFC 7748, this is 4-isogenious to the Edwards
@@ -745,14 +754,13 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "9cb7c02f0457d845c90dc3227b8a5bc1"
 		   "c0d8f97ea1ca9472b5d444285d0d4f5b"
 		   "32e236f86de51839");
-
-      break;
-
-    default:
-      fprintf (stderr, "No known curve for size %d\n", bit_size);
-      exit(EXIT_FAILURE);     
     }
-  ecc-&gt;bit_size = bit_size;
+  else
+    {
+      fprintf (stderr, "No known curve with name %s\n", curve);
+      exit(EXIT_FAILURE);
+    }
+  ecc-&gt;bit_size = mpz_sizeinbase (ecc-&gt;p, 2);
 }
 
 static void
@@ -1312,7 +1320,7 @@ main (int argc, char **argv)
       return EXIT_FAILURE;
     }
 
-  ecc_curve_init (&amp;ecc, atoi(argv[1]));
+  ecc_curve_init (&amp;ecc, argv[1]);
 
   ecc_pippenger_precompute (&amp;ecc, atoi(argv[2]), atoi(argv[3]));
 
diff --git a/x86_64/ecc-25519-modp.asm b/x86_64/ecc-curve25519-modp.asm
similarity index 100%
rename from x86_64/ecc-25519-modp.asm
rename to x86_64/ecc-curve25519-modp.asm
diff --git a/x86_64/ecc-192-modp.asm b/x86_64/ecc-secp192r1-modp.asm
similarity index 100%
rename from x86_64/ecc-192-modp.asm
rename to x86_64/ecc-secp192r1-modp.asm
diff --git a/x86_64/ecc-224-modp.asm b/x86_64/ecc-secp224r1-modp.asm
similarity index 100%
rename from x86_64/ecc-224-modp.asm
rename to x86_64/ecc-secp224r1-modp.asm
diff --git a/x86_64/ecc-256-redc.asm b/x86_64/ecc-secp256r1-redc.asm
similarity index 100%
rename from x86_64/ecc-256-redc.asm
rename to x86_64/ecc-secp256r1-redc.asm
diff --git a/x86_64/ecc-384-modp.asm b/x86_64/ecc-secp384r1-modp.asm
similarity index 100%
rename from x86_64/ecc-384-modp.asm
rename to x86_64/ecc-secp384r1-modp.asm
diff --git a/x86_64/ecc-521-modp.asm b/x86_64/ecc-secp521r1-modp.asm
similarity index 100%
rename from x86_64/ecc-521-modp.asm
rename to x86_64/ecc-secp521r1-modp.asm
-- 
2.24.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20191207071754</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-07 07:17:54-0400</timestampReceived><subject>Re: [PATCH] ecc: rename source files with curves data</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; Any feedback on this change?

I think the renaming makes sense, but perhaps best to mere the curve448
changes first.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191208233928</emailId><senderName>George Koehler</senderName><senderEmail>kernigh@gmail.com</senderEmail><timestampReceived>2019-12-08 23:39:28-0400</timestampReceived><subject>Re: patch: fix check for __builtin_bswap64</subject><body>

On Thu, 5 Dec 2019 03:20:19 -0500
Jeffrey Walton &lt;noloader@gmail.com&gt; wrote:

&gt; On Thu, Dec 5, 2019 at 3:08 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; &gt; ...
&gt; &gt;
&gt; &gt; Does OpenBSBs runtime linker look in /usr/local/lib by default? The
&gt; &gt; configure script also supports --with-lib-path=/usr/local/lib, which
&gt; &gt; will add a -L flag and in addition attempt to guess the proper
&gt; &gt; -R/-Wl,-rpath flags.
&gt; 
&gt; The runtime linker is configured to use /usr/local/lib. However,
&gt; compile and link requires explicit -I /usr/local/include and -L
&gt; /usr/local/lib to find things.
&gt; 
&gt; (Based on my testing of DragonFly, FreeBSD, OpenBSD and NetBSD. I
&gt; don't recall what Debian's kFreeBSD does).
&gt; 
&gt; Jeff

Each BSD has its own runtime linker.  I believe that OpenBSD ld.so(1)
looks in /usr/local/lib by default, but NetBSD ld.elf_so(1) doesn't
look there.

For OpenBSD, ldconfig(8) sets the runtime path.  It always looks in
/usr/lib, but /etc/rc tells ldconfig to also look in /usr/X11R6/lib
and /usr/local/lib.  I can get the path from ldconfig:

# OpenBSD
$ ldconfig -r | grep directories
        search directories: /usr/lib:/usr/X11R6/lib:/usr/local/lib

NetBSD allows /etc/ld.so.conf to add directories to the runtime path,
but my NetBSD install has no ld.so.conf, so the default path has only
/usr/lib.  Some executables have RPATH to look in /usr/X11R7/lib or
/usr/pkg/lib.  (My install has no /usr/local.)

For example, OpenBSD's xterm(1) doesn't need RPATH, but NetBSD's
xterm(1) needs RPATH with /usr/X11R7/lib.

# OpenBSD
$ readelf -d /usr/X11R6/bin/xterm | grep -E 'NEED|PATH'            
 0x00000001 (NEEDED)                     Shared library: [libXaw.so.15.0]
 0x00000001 (NEEDED)                     Shared library: [libXpm.so.9.0]
 0x00000001 (NEEDED)                     Shared library: [libXt.so.11.0]
 ...
 0x00000001 (NEEDED)                     Shared library: [libc.so.96.0]

# NetBSD
$ readelf -d /usr/X11R7/bin/xterm | grep -E 'NEED|PATH'
 0x00000001 (NEEDED)                     Shared library: [libXft.so.3]
 0x00000001 (NEEDED)                     Shared library: [libfontconfig.so.2]
 0x00000001 (NEEDED)                     Shared library: [libfreetype.so.18]
 ...
 0x00000001 (NEEDED)                     Shared library: [libc.so.12]
 0x0000000f (RPATH)                      Library rpath: [/usr/X11R7/lib]

If I don't set RPATH, I can't use /usr/X11R7/lib in NetBSD:

# OpenBSD
$ gcc -o code code.c -L/usr/X11R6/lib -lX11
...
$ ./code
It works!

# NetBSD
$ gcc -o code code.c -L/usr/X11R7/lib -lX11
$ ./code
Shared object "libX11.so.7" not found
$ gcc -o code code.c -L/usr/X11R7/lib -lX11 -R/usr/X11R7/lib
$ ./code
It works!

The NEEDED values on OpenBSD have an extra number: [libc.so.96.0]
instead of just [libc.so.96].  This is because OpenBSD has its different
version rule.

Other systems require M == X in
  SONAME libwhat.so.M    for  NEEDED libwhat.so.X
OpenBSD requires M == X &amp;&amp; N &gt;= Y in
  SONAME libwhat.so.M.N  for  NEEDED libwhat.so.X.Y
  https://www.openbsd.org/faq/ports/specialtopics.html#SharedLibs

Other systems have symbolic links:

# NetBSD
$ cd /usr/X11R7/lib
$ ls -l libX11.so*
lrwxr-xr-x  1 root  wheel       13 Jul 17  2018 libX11.so -&gt; libX11.so.7.0
lrwxr-xr-x  1 root  wheel       13 Jul 17  2018 libX11.so.7 -&gt; libX11.so.7.0
-r--r--r--  1 root  wheel  1273908 Jul 17  2018 libX11.so.7.0

OpenBSD doesn't have these links.  The compile-time ld(1) and run-time
ld.so(1) look for libraries named [libwhat.so.X.Y].

Nettle doesn't know OpenBSD's version rule.  My git checkout of Nettle,
configured for OpenBSD, wants to install [libnettle.so.7.0] with
symlinks from [libnettle.so] and [libnettle.so.7], where the SONAME is
[libnettle.so.7].  To obey the version rule, it should install
[libnettle.so.7.0] without symlinks, and the SONAME should also be
[libnettle.so.7.0].  I didn't fix my git checkout to obey the version
rule, because I didn't need to.

I know one other quirk: some build tools (but not Nettle's) use
$ORIGIN in the runtime path.  DragonFly and OpenBSD need a compiler
flag "cc -Wl,-z,origin" to enable $ORIGIN, but other systems don't
need this flag.
  https://github.com/mesonbuild/meson/pull/3530/files

This mail is too long; I stop now.  --George
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191211090118</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2019-12-11 09:01:18-0400</timestampReceived><subject>Re: post-quantum crypto algorithms implementation</subject><body>

On Wed, Dec 11, 2019 at 2:46 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; johnjmar &lt;johnjmar@linux.vnet.ibm.com&gt; writes:
&gt;
&gt; &gt; Are there any plans for post-quantum algorithms implementation in the
&gt; &gt; library?
&gt;
&gt; No concrete plans, I'm afraid. Nettle is not close to the research
&gt; frontier; a new algorithm is usually added when there's some consensus
&gt; that it is are secure (after a few rounds of public cryptanalysis) and
&gt; it starts to appear in standards. Most crypto algorithms have weaknesses
&gt; when first proposed.
&gt;
&gt; ...
&gt; If you (or anyone else on the list) are following research, I'd be happy
&gt; to hear what algorithms or approaches you think are promising.

I believe Jack Lloyd is doing a good job with Botan. He's been
following research and keeping an eye on NIST workshops to determine
which algorithms that may be standardized.

Jeff
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191218121006</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-12-18 12:10:06-0400</timestampReceived><subject>[PATCH 1/3] ecc: rename source files with curves data</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

In preparation to adding GOST curves support, rename source files and
use curve name as eccdata parameter.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 .gitignore                                    | 14 ++---
 Makefile.in                                   | 54 ++++++++---------
 ...cc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} |  4 +-
 ...cc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} |  4 +-
 ...cc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} |  4 +-
 ...cc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} |  4 +-
 ...cc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} |  4 +-
 configure.ac                                  |  6 +-
 ecc-25519.c =&gt; ecc-curve25519.c               |  4 +-
 ecc-448.c =&gt; ecc-curve448.c                   |  4 +-
 ecc-192.c =&gt; ecc-secp192r1.c                  |  4 +-
 ecc-224.c =&gt; ecc-secp224r1.c                  |  4 +-
 ecc-256.c =&gt; ecc-secp256r1.c                  |  4 +-
 ecc-384.c =&gt; ecc-secp384r1.c                  |  4 +-
 ecc-521.c =&gt; ecc-secp521r1.c                  |  4 +-
 eccdata.c                                     | 58 +++++++++++--------
 ...25519-modp.asm =&gt; ecc-curve25519-modp.asm} |  0
 ...cc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} |  4 +-
 ...cc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} |  4 +-
 ...cc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} |  4 +-
 ...cc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} |  4 +-
 ...cc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} |  4 +-
 22 files changed, 105 insertions(+), 95 deletions(-)
 rename arm/{ecc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} (97%)
 rename arm/{ecc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} (97%)
 rename arm/{ecc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} (98%)
 rename arm/{ecc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} (98%)
 rename arm/{ecc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} (97%)
 rename ecc-25519.c =&gt; ecc-curve25519.c (99%)
 rename ecc-448.c =&gt; ecc-curve448.c (99%)
 rename ecc-192.c =&gt; ecc-secp192r1.c (98%)
 rename ecc-224.c =&gt; ecc-secp224r1.c (98%)
 rename ecc-256.c =&gt; ecc-secp256r1.c (99%)
 rename ecc-384.c =&gt; ecc-secp384r1.c (99%)
 rename ecc-521.c =&gt; ecc-secp521r1.c (98%)
 rename x86_64/{ecc-25519-modp.asm =&gt; ecc-curve25519-modp.asm} (100%)
 rename x86_64/{ecc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} (96%)
 rename x86_64/{ecc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} (97%)
 rename x86_64/{ecc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} (97%)
 rename x86_64/{ecc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} (98%)
 rename x86_64/{ecc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} (97%)

diff --git a/.gitignore b/.gitignore
index 0afe61de3826..ea264107fa40 100644
--- a/.gitignore
+++ b/.gitignore
@@ -43,13 +43,13 @@ core
 /keymap.h
 /parity.h
 /rotors.h
-/ecc-192.h
-/ecc-224.h
-/ecc-256.h
-/ecc-384.h
-/ecc-521.h
-/ecc-25519.h
-/ecc-448.h
+/ecc-curve25519.h
+/ecc-curve448.h
+/ecc-secp192r1.h
+/ecc-secp224r1.h
+/ecc-secp256r1.h
+/ecc-secp384r1.h
+/ecc-secp521r1.h
 /version.h
 /nettle.aux
 /nettle.cp
diff --git a/Makefile.in b/Makefile.in
index 8d06149ff5fb..28b7cfcebcdb 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -174,8 +174,9 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  gmp-glue.c cnd-copy.c \
 		  ecc-mod.c ecc-mod-inv.c \
 		  ecc-mod-arith.c ecc-pp1-redc.c ecc-pm1-redc.c \
-		  ecc-192.c ecc-224.c ecc-256.c ecc-384.c ecc-521.c \
-		  ecc-25519.c ecc-448.c \
+		  ecc-curve25519.c ecc-curve448.c \
+		  ecc-secp192r1.c ecc-secp224r1.c ecc-secp256r1.c \
+		  ecc-secp384r1.c ecc-secp521r1.c \
 		  ecc-size.c ecc-j-to-a.c ecc-a-to-j.c \
 		  ecc-dup-jj.c ecc-add-jja.c ecc-add-jjj.c \
 		  ecc-eh-to-a.c \
@@ -346,24 +347,24 @@ des.$(OBJEXT): des.c des.h $(des_headers)
 # k = 14, c =  7, S = 256, T =  42 ( 28 A + 14 D) 12 KB
 # k = 11, c =  6, S = 192, T =  44 ( 33 A + 11 D)  9 KB
 # k = 16, c =  6, S = 128, T =  48 ( 32 A + 16 D)  6 KB
-ecc-192.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 192 8 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp192r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp192r1 8 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 224:
 # k = 16, c =  7, S = 256, T =  48 ( 32 A + 16 D) ~16 KB
 # k = 10, c =  6, S = 256, T =  50 ( 40 A + 10 D) ~16 KB
 # k = 13, c =  6, S = 192, T =  52 ( 39 A + 13 D) ~12 KB
 # k =  9, c =  5, S = 160, T =  54 ( 45 A +  9 D) ~10 KB
-ecc-224.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 224 16 7 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp224r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp224r1 16 7 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 256:
 # k =  9, c =  6, S = 320, T =  54 ( 45 A +  9 D) 20 KB
 # k = 11, c =  6, S = 256, T =  55 ( 44 A + 11 D) 16 KB
 # k = 19, c =  7, S = 256, T =  57 ( 38 A + 19 D) 16 KB
 # k = 15, c =  6, S = 192, T =  60 ( 45 A + 15 D) 12 KB
-ecc-256.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 256 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp256r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp256r1 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 384:
 # k = 16, c =  6, S = 256, T =  80 ( 64 A + 16 D) 24 KB
@@ -373,35 +374,35 @@ ecc-256.h: eccdata.stamp
 # k = 13, c =  5, S = 192, T =  91 ( 78 A + 13 D) 18 KB
 # k = 16, c =  5, S = 160, T =  96 ( 80 A + 16 D) 15 KB
 # k = 32, c =  6, S = 128, T =  96 ( 64 A + 32 D) 12 KB
-ecc-384.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 384 32 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp384r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp384r1 32 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 521:
 # k = 29, c =  6, S = 192, T = 116 ( 87 A + 29 D) ~27 KB
 # k = 21, c =  5, S = 160, T = 126 (105 A + 21 D) ~23 KB
 # k = 44, c =  6, S = 128, T = 132 ( 88 A + 44 D) ~18 KB
 # k = 35, c =  5, S =  96, T = 140 (105 A + 35 D) ~14 KB
-ecc-521.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 521 44 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp521r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp521r1 44 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
-# Parameter choices mostly the same as for ecc-256.h.
-ecc-25519.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 255 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+# Parameter choices mostly the same as for ecc-secp256r1.h.
+ecc-curve25519.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) curve25519 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
-ecc-448.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 448 38 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-curve448.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) curve448 38 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 eccdata.stamp: eccdata.c
 	$(MAKE) eccdata$(EXEEXT_FOR_BUILD)
 	echo stamp &gt; eccdata.stamp
 
-ecc-192.$(OBJEXT): ecc-192.h
-ecc-224.$(OBJEXT): ecc-224.h
-ecc-256.$(OBJEXT): ecc-256.h
-ecc-384.$(OBJEXT): ecc-384.h
-ecc-521.$(OBJEXT): ecc-521.h
-ecc-25519.$(OBJEXT): ecc-25519.h
-ecc-448.$(OBJEXT): ecc-448.h
+ecc-curve25519.$(OBJEXT): ecc-curve25519.h
+ecc-curve448.$(OBJEXT): ecc-curve448.h
+ecc-secp192r1.$(OBJEXT): ecc-secp192r1.h
+ecc-secp224r1.$(OBJEXT): ecc-secp224r1.h
+ecc-secp256r1.$(OBJEXT): ecc-secp256r1.h
+ecc-secp384r1.$(OBJEXT): ecc-secp384r1.h
+ecc-secp521r1.$(OBJEXT): ecc-secp521r1.h
 
 .asm.$(OBJEXT): $(srcdir)/asm.m4 machine.m4 config.m4
 	$(M4) $(srcdir)/asm.m4 machine.m4 config.m4 $&lt; &gt;$*.s
@@ -654,8 +655,9 @@ distcheck: dist
 
 clean-here:
 	-rm -f $(TARGETS) *.$(OBJEXT) *.s *.so *.dll *.a \
-		ecc-192.h ecc-224.h ecc-256.h ecc-384.h ecc-521.h ecc-25519.h \
-		ecc-448.h \
+		ecc-curve25519.h ecc-curve448.h \
+		ecc-secp192r1.h ecc-secp224r1.h ecc-secp256r1.h \
+		ecc-secp384r1.h ecc-secp521r1.h \
 		aesdata$(EXEEXT_FOR_BUILD) \
 		desdata$(EXEEXT_FOR_BUILD) \
 		twofishdata$(EXEEXT_FOR_BUILD) \
diff --git a/arm/ecc-192-modp.asm b/arm/ecc-secp192r1-modp.asm
similarity index 97%
rename from arm/ecc-192-modp.asm
rename to arm/ecc-secp192r1-modp.asm
index b6074a2e05e9..dbaae2e38922 100644
--- a/arm/ecc-192-modp.asm
+++ b/arm/ecc-secp192r1-modp.asm
@@ -1,4 +1,4 @@
-C arm/ecc-192-modp.asm
+C arm/ecc-secp192r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;) 
 
-	.file "ecc-192-modp.asm"
+	.file "ecc-secp192r1-modp.asm"
 	.arm
 
 define(&lt;HP&gt;, &lt;r0&gt;) C Overlaps unused modulo argument
diff --git a/arm/ecc-224-modp.asm b/arm/ecc-secp224r1-modp.asm
similarity index 97%
rename from arm/ecc-224-modp.asm
rename to arm/ecc-secp224r1-modp.asm
index 15cc0c1b0f26..2c86755a7c9a 100644
--- a/arm/ecc-224-modp.asm
+++ b/arm/ecc-secp224r1-modp.asm
@@ -1,4 +1,4 @@
-C arm/ecc-224-modp.asm
+C arm/ecc-secp224r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;) 
 
-	.file "ecc-224-modp.asm"
+	.file "ecc-secp224r1-modp.asm"
 	.arm
 
 define(&lt;RP&gt;, &lt;r1&gt;)
diff --git a/arm/ecc-256-redc.asm b/arm/ecc-secp256r1-redc.asm
similarity index 98%
rename from arm/ecc-256-redc.asm
rename to arm/ecc-secp256r1-redc.asm
index 0c5e846d5890..9c20062a44e4 100644
--- a/arm/ecc-256-redc.asm
+++ b/arm/ecc-secp256r1-redc.asm
@@ -1,4 +1,4 @@
-C arm/ecc-256-redc.asm
+C arm/ecc-secp256r1-redc.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;) 
 
-	.file "ecc-256-redc.asm"
+	.file "ecc-secp256r1-redc.asm"
 	.arm
 
 define(&lt;RP&gt;, &lt;r1&gt;)
diff --git a/arm/ecc-384-modp.asm b/arm/ecc-secp384r1-modp.asm
similarity index 98%
rename from arm/ecc-384-modp.asm
rename to arm/ecc-secp384r1-modp.asm
index 1d36319d584d..dbedbdf8d32e 100644
--- a/arm/ecc-384-modp.asm
+++ b/arm/ecc-secp384r1-modp.asm
@@ -1,4 +1,4 @@
-C arm/ecc-384-modp.asm
+C arm/ecc-secp384r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;) 
 
-	.file "ecc-384-modp.asm"
+	.file "ecc-secp384r1-modp.asm"
 	.arm
 
 define(&lt;RP&gt;, &lt;r1&gt;)
diff --git a/arm/ecc-521-modp.asm b/arm/ecc-secp521r1-modp.asm
similarity index 97%
rename from arm/ecc-521-modp.asm
rename to arm/ecc-secp521r1-modp.asm
index 3fba23963d2c..2b4f79192a2e 100644
--- a/arm/ecc-521-modp.asm
+++ b/arm/ecc-secp521r1-modp.asm
@@ -1,4 +1,4 @@
-C arm/ecc-521-modp.asm
+C arm/ecc-secp521r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;) 
 
-	.file "ecc-521-modp.asm"
+	.file "ecc-secp521r1-modp.asm"
 	.arm
 
 define(&lt;HP&gt;, &lt;r0&gt;)
diff --git a/configure.ac b/configure.ac
index ef0c819fb979..745cc2c5c20e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -475,9 +475,9 @@ asm_nettle_optional_list="gcm-hash8.asm cpuid.asm \
 
 asm_hogweed_optional_list=""
 if test "x$enable_public_key" = "xyes" ; then
-  asm_hogweed_optional_list="ecc-192-modp.asm ecc-224-modp.asm \
-    ecc-256-redc.asm ecc-384-modp.asm ecc-521-modp.asm \
-    ecc-25519-modp.asm ecc-curve448-modp.asm"
+  asm_hogweed_optional_list="ecc-secp192r1-modp.asm ecc-secp224r1-modp.asm \
+    ecc-secp256r1-redc.asm ecc-secp384r1-modp.asm ecc-secp521r1-modp.asm \
+    ecc-curve25519-modp.asm ecc-curve448-modp.asm"
 fi
 
 OPT_NETTLE_OBJS=""
diff --git a/ecc-25519.c b/ecc-curve25519.c
similarity index 99%
rename from ecc-25519.c
rename to ecc-curve25519.c
index 105ce0f4fbc1..e6a1b325be66 100644
--- a/ecc-25519.c
+++ b/ecc-curve25519.c
@@ -1,4 +1,4 @@
-/* ecc-25519.c
+/* ecc-curve25519.c
 
    Arithmetic and tables for curve25519,
 
@@ -42,7 +42,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-25519.h"
+#include "ecc-curve25519.h"
 
 #define PHIGH_BITS (GMP_NUMB_BITS * ECC_LIMB_SIZE - 255)
 
diff --git a/ecc-448.c b/ecc-curve448.c
similarity index 99%
rename from ecc-448.c
rename to ecc-curve448.c
index 429bb8ffd722..fce8b1ac0382 100644
--- a/ecc-448.c
+++ b/ecc-curve448.c
@@ -1,4 +1,4 @@
-/* ecc-448.c
+/* ecc-curve448.c
 
    Arithmetic and tables for curve448,
 
@@ -43,7 +43,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-448.h"
+#include "ecc-curve448.h"
 
 #if HAVE_NATIVE_ecc_curve448_modp
 #define ecc_448_modp nettle_ecc_curve448_modp
diff --git a/ecc-192.c b/ecc-secp192r1.c
similarity index 98%
rename from ecc-192.c
rename to ecc-secp192r1.c
index 4b756ffd7e8f..858a1b7554ce 100644
--- a/ecc-192.c
+++ b/ecc-secp192r1.c
@@ -1,4 +1,4 @@
-/* ecc-192.c
+/* ecc-secp192r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -46,7 +46,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-192.h"
+#include "ecc-secp192r1.h"
 
 #if HAVE_NATIVE_ecc_192_modp
 
diff --git a/ecc-224.c b/ecc-secp224r1.c
similarity index 98%
rename from ecc-224.c
rename to ecc-secp224r1.c
index bf90f848c1b2..4d82f54b57fd 100644
--- a/ecc-224.c
+++ b/ecc-secp224r1.c
@@ -1,4 +1,4 @@
-/* ecc-224.c
+/* ecc-secp224r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -52,7 +52,7 @@ ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #define ecc_224_modp ecc_mod
 #endif
 
-#include "ecc-224.h"
+#include "ecc-secp224r1.h"
 
 #if ECC_REDC_SIZE &lt; 0
 # define ecc_224_redc ecc_pm1_redc
diff --git a/ecc-256.c b/ecc-secp256r1.c
similarity index 99%
rename from ecc-256.c
rename to ecc-secp256r1.c
index 3e6ae4e2a8b6..7b873b5f7724 100644
--- a/ecc-256.c
+++ b/ecc-secp256r1.c
@@ -1,4 +1,4 @@
-/* ecc-256.c
+/* ecc-secp256r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -48,7 +48,7 @@
 # define USE_REDC (ECC_REDC_SIZE != 0)
 #endif
 
-#include "ecc-256.h"
+#include "ecc-secp256r1.h"
 
 #if HAVE_NATIVE_ecc_256_redc
 # define ecc_256_redc nettle_ecc_256_redc
diff --git a/ecc-384.c b/ecc-secp384r1.c
similarity index 99%
rename from ecc-384.c
rename to ecc-secp384r1.c
index 5bb2a2476eec..248b1cf3ef2b 100644
--- a/ecc-384.c
+++ b/ecc-secp384r1.c
@@ -1,4 +1,4 @@
-/* ecc-384.c
+/* ecc-secp384r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -44,7 +44,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-384.h"
+#include "ecc-secp384r1.h"
 
 #if HAVE_NATIVE_ecc_384_modp
 #define ecc_384_modp nettle_ecc_384_modp
diff --git a/ecc-521.c b/ecc-secp521r1.c
similarity index 98%
rename from ecc-521.c
rename to ecc-secp521r1.c
index 8ca0e6d2dd64..cc7473035cff 100644
--- a/ecc-521.c
+++ b/ecc-secp521r1.c
@@ -1,4 +1,4 @@
-/* ecc-521.c
+/* ecc-secp521r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -42,7 +42,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-521.h"
+#include "ecc-secp521r1.h"
 
 #if HAVE_NATIVE_ecc_521_modp
 #define ecc_521_modp nettle_ecc_521_modp
diff --git a/eccdata.c b/eccdata.c
index 74002c1f305e..d76a42bcde6f 100644
--- a/eccdata.c
+++ b/eccdata.c
@@ -432,11 +432,10 @@ ecc_curve_init_str (struct ecc_curve *ecc, enum ecc_type type,
 }
 
 static void
-ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
+ecc_curve_init (struct ecc_curve *ecc, const char *curve)
 {
-  switch (bit_size)
+  if (!strcmp (curve, "secp192r1"))
     {
-    case 192:      
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{192} - 2^{64} - 1 */
 			  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE"
@@ -466,8 +465,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "35433907297cc378b0015703374729d7a4fe46647084e4ba",
 		   "a2649984f2135c301ea3acb0776cd4f125389b311db3be32");
 
-      break;
-    case 224:
+    }
+  else if (!strcmp (curve, "secp224r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{224} - 2^{96} + 1 */
 			  "ffffffffffffffffffffffffffffffff"
@@ -498,8 +498,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "ae99feebb5d26945b54892092a8aee02912930fa41cd114e40447301",
 		   "482580a0ec5bc47e88bc8c378632cd196cb3fa058a7114eb03054c9");
 
-      break;
-    case 256:
+    }
+  else if (!strcmp (curve, "secp256r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{256} - 2^{224} + 2^{192} + 2^{96} - 1 */
 			  "FFFFFFFF000000010000000000000000"
@@ -530,8 +531,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "e2534a3532d08fbba02dde659ee62bd0031fe2db785596ef509302446b030852",
 		   "e0f1575a4c633cc719dfee5fda862d764efc96c3f30ee0055c42c23f184ed8c6");
 
-      break;
-    case 384:
+    }
+  else if (!strcmp (curve, "secp384r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{384} - 2^{128} - 2^{96} + 2^{32} - 1 */
 			  "ffffffffffffffffffffffffffffffff"
@@ -567,8 +569,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "138251cd52ac9298c1c8aad977321deb97e709bd0b4ca0aca55dc8ad51dcfc9d1589a1597e3a5120e1efd631c63e1835",
                
 		   "cacae29869a62e1631e8a28181ab56616dc45d918abc09f3ab0e63cf792aa4dced7387be37bba569549f1c02b270ed67");
  
-      break;
-    case 521:
+    }
+  else if (!strcmp (curve, "secp521r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  "1ff" /* p = 2^{521} - 1 */
 			  "ffffffffffffffffffffffffffffffff"
@@ -613,9 +616,15 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "35b5df64ae2ac204c354b483487c9070cdc61c891c5ff39afc06c5d55541d3ceac8659e24afe3d0750e8b88e9f078af066a1d5025b08e5a5e2fbc87412871902f3",
                
 		   "82096f84261279d2b673e0178eb0b4abb65521aef6e6e32e1b5ae63fe2f19907f279f283e54ba385405224f750a95b85eebb7faef04699d1d9e21f47fc346e4d0d");
  
-      break;
-    case 255:
-      /* Edwards curve used for eddsa25519 and curve25519,
+    }
+  else if (!strcmp (curve, "curve25519"))
+    {
+      /* curve25519, y^2 = x^3 + 486662 x^2 + x (mod p), with p = 2^{255} - 19.
+
+	 According to http://cr.yp.to/papers.html#newelliptic, this
+	 is birationally equivalent to the Edwards curve
+
+	   x^2 + y^2 = 1 + (121665/121666) x^2 y^2 (mod p).
 
 	   -x^2 + y^2 = 1 - (121665/121666) x^2 y^2, with p = 2^{255} - 19.
 
@@ -664,9 +673,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "1a739ec193ce1547493aa657c4c9f870",
 		   "47d0e827cb1595e1470eb88580d5716c"
 		   "4cf22832ea2f0ff0df38ab61ca32112f");
-      break;
-
-    case 448:
+    }
+  else if (!strcmp (curve, "curve448"))
+    {
       /* curve448, y^2 = x^3 + 156326 x^2 + x (mod p), with p = 2^{448} - 2^{224} - \
1.  
 	 According to RFC 7748, this is 4-isogenious to the Edwards
@@ -745,14 +754,13 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "9cb7c02f0457d845c90dc3227b8a5bc1"
 		   "c0d8f97ea1ca9472b5d444285d0d4f5b"
 		   "32e236f86de51839");
-
-      break;
-
-    default:
-      fprintf (stderr, "No known curve for size %d\n", bit_size);
-      exit(EXIT_FAILURE);     
     }
-  ecc-&gt;bit_size = bit_size;
+  else
+    {
+      fprintf (stderr, "No known curve with name %s\n", curve);
+      exit(EXIT_FAILURE);
+    }
+  ecc-&gt;bit_size = mpz_sizeinbase (ecc-&gt;p, 2);
 }
 
 static void
@@ -1312,7 +1320,7 @@ main (int argc, char **argv)
       return EXIT_FAILURE;
     }
 
-  ecc_curve_init (&amp;ecc, atoi(argv[1]));
+  ecc_curve_init (&amp;ecc, argv[1]);
 
   ecc_pippenger_precompute (&amp;ecc, atoi(argv[2]), atoi(argv[3]));
 
diff --git a/x86_64/ecc-25519-modp.asm b/x86_64/ecc-curve25519-modp.asm
similarity index 100%
rename from x86_64/ecc-25519-modp.asm
rename to x86_64/ecc-curve25519-modp.asm
diff --git a/x86_64/ecc-192-modp.asm b/x86_64/ecc-secp192r1-modp.asm
similarity index 96%
rename from x86_64/ecc-192-modp.asm
rename to x86_64/ecc-secp192r1-modp.asm
index f0660525e0e1..644ed60c6fab 100644
--- a/x86_64/ecc-192-modp.asm
+++ b/x86_64/ecc-secp192r1-modp.asm
@@ -1,4 +1,4 @@
-C x86_64/ecc-192-modp.asm
+C x86_64/ecc-secp192r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;)
 
-	.file "ecc-192-modp.asm"
+	.file "ecc-secp192r1-modp.asm"
 
 define(&lt;RP&gt;, &lt;%rsi&gt;)
 define(&lt;T0&gt;, &lt;%rdi&gt;) C Overlaps unused modulo input
diff --git a/x86_64/ecc-224-modp.asm b/x86_64/ecc-secp224r1-modp.asm
similarity index 97%
rename from x86_64/ecc-224-modp.asm
rename to x86_64/ecc-secp224r1-modp.asm
index 07bd40036705..ca164ac7d637 100644
--- a/x86_64/ecc-224-modp.asm
+++ b/x86_64/ecc-secp224r1-modp.asm
@@ -1,4 +1,4 @@
-C x86_64/ecc-224-modp.asm
+C x86_64/ecc-secp224r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;)
 
-	.file "ecc-224-modp.asm"
+	.file "ecc-secp224r1-modp.asm"
 
 GMP_NUMB_BITS(64)
 
diff --git a/x86_64/ecc-256-redc.asm b/x86_64/ecc-secp256r1-redc.asm
similarity index 97%
rename from x86_64/ecc-256-redc.asm
rename to x86_64/ecc-secp256r1-redc.asm
index fb1633541218..ee689cd6d192 100644
--- a/x86_64/ecc-256-redc.asm
+++ b/x86_64/ecc-secp256r1-redc.asm
@@ -1,4 +1,4 @@
-C x86_64/ecc-256-redc.asm
+C x86_64/ecc-secp256r1-redc.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;)
 
-	.file "ecc-256-redc.asm"
+	.file "ecc-secp256r1-redc.asm"
 
 define(&lt;RP&gt;, &lt;%rsi&gt;)
 define(&lt;U0&gt;, &lt;%rdi&gt;) C Overlaps unused modulo input
diff --git a/x86_64/ecc-384-modp.asm b/x86_64/ecc-secp384r1-modp.asm
similarity index 98%
rename from x86_64/ecc-384-modp.asm
rename to x86_64/ecc-secp384r1-modp.asm
index 8e55393f802f..3c8ec3f446c0 100644
--- a/x86_64/ecc-384-modp.asm
+++ b/x86_64/ecc-secp384r1-modp.asm
@@ -1,4 +1,4 @@
-C x86_64/ecc-384-modp.asm
+C x86_64/ecc-secp384r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013, 2015 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;)
 
-	.file "ecc-384-modp.asm"
+	.file "ecc-secp384r1-modp.asm"
 
 define(&lt;RP&gt;, &lt;%rsi&gt;)
 define(&lt;D5&gt;, &lt;%rax&gt;)
diff --git a/x86_64/ecc-521-modp.asm b/x86_64/ecc-secp521r1-modp.asm
similarity index 97%
rename from x86_64/ecc-521-modp.asm
rename to x86_64/ecc-secp521r1-modp.asm
index 6e818ad81d41..43a8cb8c9cfe 100644
--- a/x86_64/ecc-521-modp.asm
+++ b/x86_64/ecc-secp521r1-modp.asm
@@ -1,4 +1,4 @@
-C x86_64/ecc-521-modp.asm
+C x86_64/ecc-secp521r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;)
 
-	.file "ecc-521-modp.asm"
+	.file "ecc-secp521r1-modp.asm"
 
 GMP_NUMB_BITS(64)
 
-- 
2.24.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20191218121007</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-12-18 12:10:07-0400</timestampReceived><subject>[PATCH 2/3] ecc: prefix optimized ECC function names with underscore</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

There is no need to keep optimized ECC functions in public namespace
(nettle_*), move them to internal namespace (_nettle_*).

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 arm/ecc-secp192r1-modp.asm     | 4 ++--
 arm/ecc-secp224r1-modp.asm     | 4 ++--
 arm/ecc-secp256r1-redc.asm     | 4 ++--
 arm/ecc-secp384r1-modp.asm     | 4 ++--
 arm/ecc-secp521r1-modp.asm     | 4 ++--
 ecc-curve25519.c               | 2 +-
 ecc-curve448.c                 | 2 +-
 ecc-secp192r1.c                | 2 +-
 ecc-secp224r1.c                | 2 +-
 ecc-secp256r1.c                | 2 +-
 ecc-secp384r1.c                | 2 +-
 ecc-secp521r1.c                | 2 +-
 x86_64/ecc-curve25519-modp.asm | 4 ++--
 x86_64/ecc-curve448-modp.asm   | 4 ++--
 x86_64/ecc-secp192r1-modp.asm  | 4 ++--
 x86_64/ecc-secp224r1-modp.asm  | 4 ++--
 x86_64/ecc-secp256r1-redc.asm  | 4 ++--
 x86_64/ecc-secp384r1-modp.asm  | 4 ++--
 x86_64/ecc-secp521r1-modp.asm  | 4 ++--
 19 files changed, 31 insertions(+), 31 deletions(-)

diff --git a/arm/ecc-secp192r1-modp.asm b/arm/ecc-secp192r1-modp.asm
index dbaae2e38922..4680336f1bc7 100644
--- a/arm/ecc-secp192r1-modp.asm
+++ b/arm/ecc-secp192r1-modp.asm
@@ -53,7 +53,7 @@ define(&lt;C4&gt;, &lt;r12&gt;)
 	.text
 	.align 2
 
-PROLOGUE(nettle_ecc_192_modp)
+PROLOGUE(_nettle_ecc_192_modp)
 	push	{r4,r5,r6,r7,r8,r10}
 	C Reduce two words at a time
 	add	HP, RP, #48
@@ -103,4 +103,4 @@ PROLOGUE(nettle_ecc_192_modp)
 
 	pop	{r4,r5,r6,r7,r8,r10}
 	bx	lr
-EPILOGUE(nettle_ecc_192_modp)
+EPILOGUE(_nettle_ecc_192_modp)
diff --git a/arm/ecc-secp224r1-modp.asm b/arm/ecc-secp224r1-modp.asm
index 2c86755a7c9a..400b7a815c2c 100644
--- a/arm/ecc-secp224r1-modp.asm
+++ b/arm/ecc-secp224r1-modp.asm
@@ -52,7 +52,7 @@ define(&lt;L2&gt;, &lt;lr&gt;)
 	.text
 	.align 2
 
-PROLOGUE(nettle_ecc_224_modp)
+PROLOGUE(_nettle_ecc_224_modp)
 	push	{r4,r5,r6,r7,r8,r10,r11,lr}
 
 	add	L2, RP, #28
@@ -121,4 +121,4 @@ PROLOGUE(nettle_ecc_224_modp)
 	stmdb	RP, {T0,T1,T2,T3,T4,T5,T6}
 
 	pop	{r4,r5,r6,r7,r8,r10,r11,pc}
-EPILOGUE(nettle_ecc_224_modp)
+EPILOGUE(_nettle_ecc_224_modp)
diff --git a/arm/ecc-secp256r1-redc.asm b/arm/ecc-secp256r1-redc.asm
index 9c20062a44e4..7b117de43fbc 100644
--- a/arm/ecc-secp256r1-redc.asm
+++ b/arm/ecc-secp256r1-redc.asm
@@ -52,7 +52,7 @@ define(&lt;F3&gt;, &lt;lr&gt;)
 	.text
 	.align 2
 
-PROLOGUE(nettle_ecc_256_redc)
+PROLOGUE(_nettle_ecc_256_redc)
 	push	{r4,r5,r6,r7,r8,r10,r11,lr}
 
 	ldm	RP!, {T0,T1,T2,T3,T4,T5,T6,T7}
@@ -170,4 +170,4 @@ PROLOGUE(nettle_ecc_256_redc)
 	stm	RP, {T0,T1,T2,T3,T4,T5,T6,T7}
 
 	pop	{r4,r5,r6,r7,r8,r10,r11,pc}
-EPILOGUE(nettle_ecc_256_redc)
+EPILOGUE(_nettle_ecc_256_redc)
diff --git a/arm/ecc-secp384r1-modp.asm b/arm/ecc-secp384r1-modp.asm
index dbedbdf8d32e..dd9a325b09de 100644
--- a/arm/ecc-secp384r1-modp.asm
+++ b/arm/ecc-secp384r1-modp.asm
@@ -50,7 +50,7 @@ define(&lt;H&gt;, &lt;lr&gt;)
 	.text
 	.align 2
 
-PROLOGUE(nettle_ecc_384_modp)
+PROLOGUE(_nettle_ecc_384_modp)
 	push	{r4,r5,r6,r7,r8,r10,lr}
 
 	add	RP, RP, #80
@@ -267,4 +267,4 @@ PROLOGUE(nettle_ecc_384_modp)
 	adcs	T3, T3, H
 	stm	RP!, {T0,T1,T2,T3}	C 8-11
 	pop	{r4,r5,r6,r7,r8,r10,pc}
-EPILOGUE(nettle_ecc_384_modp)
+EPILOGUE(_nettle_ecc_384_modp)
diff --git a/arm/ecc-secp521r1-modp.asm b/arm/ecc-secp521r1-modp.asm
index 2b4f79192a2e..f11967634689 100644
--- a/arm/ecc-secp521r1-modp.asm
+++ b/arm/ecc-secp521r1-modp.asm
@@ -52,7 +52,7 @@ define(&lt;N&gt;, &lt;lr&gt;)
 
 	.align 2
 
-PROLOGUE(nettle_ecc_521_modp)
+PROLOGUE(_nettle_ecc_521_modp)
 	push	{r4,r5,r6,r7,r8,lr}
 
 	C Use that B^17 = 2^23 (mod p)
@@ -124,4 +124,4 @@ PROLOGUE(nettle_ecc_521_modp)
 	stm	RP, {T0,T1,T2,F0,F1,F2,F3,H}	C 9-16
 
 	pop	{r4,r5,r6,r7,r8,pc}
-EPILOGUE(nettle_ecc_521_modp)
+EPILOGUE(_nettle_ecc_521_modp)
diff --git a/ecc-curve25519.c b/ecc-curve25519.c
index e6a1b325be66..1045db7092ae 100644
--- a/ecc-curve25519.c
+++ b/ecc-curve25519.c
@@ -48,7 +48,7 @@
 
 #if HAVE_NATIVE_ecc_25519_modp
 
-#define ecc_25519_modp nettle_ecc_25519_modp
+#define ecc_25519_modp _nettle_ecc_25519_modp
 void
 ecc_25519_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #else
diff --git a/ecc-curve448.c b/ecc-curve448.c
index fce8b1ac0382..e1318ca4f01d 100644
--- a/ecc-curve448.c
+++ b/ecc-curve448.c
@@ -46,7 +46,7 @@
 #include "ecc-curve448.h"
 
 #if HAVE_NATIVE_ecc_curve448_modp
-#define ecc_448_modp nettle_ecc_curve448_modp
+#define ecc_448_modp _nettle_ecc_curve448_modp
 void
 ecc_448_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #elif GMP_NUMB_BITS == 64
diff --git a/ecc-secp192r1.c b/ecc-secp192r1.c
index 858a1b7554ce..15f5f1fa4c04 100644
--- a/ecc-secp192r1.c
+++ b/ecc-secp192r1.c
@@ -50,7 +50,7 @@
 
 #if HAVE_NATIVE_ecc_192_modp
 
-#define ecc_192_modp nettle_ecc_192_modp
+#define ecc_192_modp _nettle_ecc_192_modp
 void
 ecc_192_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 
diff --git a/ecc-secp224r1.c b/ecc-secp224r1.c
index 4d82f54b57fd..28b938fa3282 100644
--- a/ecc-secp224r1.c
+++ b/ecc-secp224r1.c
@@ -43,7 +43,7 @@
 #if HAVE_NATIVE_ecc_224_modp
 
 #define USE_REDC 0
-#define ecc_224_modp nettle_ecc_224_modp
+#define ecc_224_modp _nettle_ecc_224_modp
 void
 ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 
diff --git a/ecc-secp256r1.c b/ecc-secp256r1.c
index 7b873b5f7724..ed463edf7729 100644
--- a/ecc-secp256r1.c
+++ b/ecc-secp256r1.c
@@ -51,7 +51,7 @@
 #include "ecc-secp256r1.h"
 
 #if HAVE_NATIVE_ecc_256_redc
-# define ecc_256_redc nettle_ecc_256_redc
+# define ecc_256_redc _nettle_ecc_256_redc
 void
 ecc_256_redc (const struct ecc_modulo *p, mp_limb_t *rp);
 #else /* !HAVE_NATIVE_ecc_256_redc */
diff --git a/ecc-secp384r1.c b/ecc-secp384r1.c
index 248b1cf3ef2b..32f75fb618ba 100644
--- a/ecc-secp384r1.c
+++ b/ecc-secp384r1.c
@@ -47,7 +47,7 @@
 #include "ecc-secp384r1.h"
 
 #if HAVE_NATIVE_ecc_384_modp
-#define ecc_384_modp nettle_ecc_384_modp
+#define ecc_384_modp _nettle_ecc_384_modp
 void
 ecc_384_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #elif GMP_NUMB_BITS == 32
diff --git a/ecc-secp521r1.c b/ecc-secp521r1.c
index cc7473035cff..d952d77e444e 100644
--- a/ecc-secp521r1.c
+++ b/ecc-secp521r1.c
@@ -45,7 +45,7 @@
 #include "ecc-secp521r1.h"
 
 #if HAVE_NATIVE_ecc_521_modp
-#define ecc_521_modp nettle_ecc_521_modp
+#define ecc_521_modp _nettle_ecc_521_modp
 void
 ecc_521_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 
diff --git a/x86_64/ecc-curve25519-modp.asm b/x86_64/ecc-curve25519-modp.asm
index 58c14fe0958e..0374db12ab44 100644
--- a/x86_64/ecc-curve25519-modp.asm
+++ b/x86_64/ecc-curve25519-modp.asm
@@ -41,7 +41,7 @@ define(&lt;T0&gt;, &lt;%r10&gt;)
 define(&lt;T1&gt;, &lt;%r11&gt;)
 define(&lt;M&gt;, &lt;%rbx&gt;)
 
-PROLOGUE(nettle_ecc_25519_modp)
+PROLOGUE(_nettle_ecc_25519_modp)
 	W64_ENTRY(2, 0)
 	push	%rbx
 
@@ -91,4 +91,4 @@ PROLOGUE(nettle_ecc_25519_modp)
 	pop	%rbx
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(nettle_ecc_25519_modp)
+EPILOGUE(_nettle_ecc_25519_modp)
diff --git a/x86_64/ecc-curve448-modp.asm b/x86_64/ecc-curve448-modp.asm
index 1ca05a190e1a..ea2e78861bc5 100644
--- a/x86_64/ecc-curve448-modp.asm
+++ b/x86_64/ecc-curve448-modp.asm
@@ -45,7 +45,7 @@ define(&lt;T0&gt;, &lt;%r10&gt;)
 define(&lt;T1&gt;, &lt;%r11&gt;)
 define(&lt;T2&gt;, &lt;%r12&gt;)
 
-PROLOGUE(nettle_ecc_curve448_modp)
+PROLOGUE(_nettle_ecc_curve448_modp)
 	W64_ENTRY(2, 0)
 
 	push	%rbx
@@ -141,4 +141,4 @@ PROLOGUE(nettle_ecc_curve448_modp)
 
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(nettle_ecc_curve448_modp)
+EPILOGUE(_nettle_ecc_curve448_modp)
diff --git a/x86_64/ecc-secp192r1-modp.asm b/x86_64/ecc-secp192r1-modp.asm
index 644ed60c6fab..ad8dca7186e4 100644
--- a/x86_64/ecc-secp192r1-modp.asm
+++ b/x86_64/ecc-secp192r1-modp.asm
@@ -44,7 +44,7 @@ define(&lt;C2&gt;, &lt;%r11&gt;)
 	C ecc_192_modp (const struct ecc_modulo *m, mp_limb_t *rp)
 	.text
 	ALIGN(16)
-PROLOGUE(nettle_ecc_192_modp)
+PROLOGUE(_nettle_ecc_192_modp)
 	W64_ENTRY(2, 0)
 	mov	16(RP), T2
 	mov	24(RP), T3
@@ -85,4 +85,4 @@ PROLOGUE(nettle_ecc_192_modp)
 
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(nettle_ecc_192_modp)
+EPILOGUE(_nettle_ecc_192_modp)
diff --git a/x86_64/ecc-secp224r1-modp.asm b/x86_64/ecc-secp224r1-modp.asm
index ca164ac7d637..e44b5418e5dd 100644
--- a/x86_64/ecc-secp224r1-modp.asm
+++ b/x86_64/ecc-secp224r1-modp.asm
@@ -45,7 +45,7 @@ define(&lt;F1&gt;, &lt;%r10&gt;)
 define(&lt;F2&gt;, &lt;%r11&gt;)
 
 	C ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp)
-PROLOGUE(nettle_ecc_224_modp)
+PROLOGUE(_nettle_ecc_224_modp)
 	W64_ENTRY(2, 0)
 	mov	48(RP), H0
 	mov	56(RP), H1
@@ -128,4 +128,4 @@ PROLOGUE(nettle_ecc_224_modp)
 
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(nettle_ecc_224_modp)
+EPILOGUE(_nettle_ecc_224_modp)
diff --git a/x86_64/ecc-secp256r1-redc.asm b/x86_64/ecc-secp256r1-redc.asm
index ee689cd6d192..533a1766d4bc 100644
--- a/x86_64/ecc-secp256r1-redc.asm
+++ b/x86_64/ecc-secp256r1-redc.asm
@@ -58,7 +58,7 @@ define(&lt;FOLD&gt;, &lt;
 	sbb	$1, F2
 	sbb	&lt;$&gt;0, F3
 &gt;)
-PROLOGUE(nettle_ecc_256_redc)
+PROLOGUE(_nettle_ecc_256_redc)
 	W64_ENTRY(2, 0)
 	C save all registers that need to be saved
 	push	%rbx
@@ -126,4 +126,4 @@ PROLOGUE(nettle_ecc_256_redc)
 	pop	%rbx
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(nettle_ecc_256_redc)
+EPILOGUE(_nettle_ecc_256_redc)
diff --git a/x86_64/ecc-secp384r1-modp.asm b/x86_64/ecc-secp384r1-modp.asm
index 3c8ec3f446c0..13f469b164e4 100644
--- a/x86_64/ecc-secp384r1-modp.asm
+++ b/x86_64/ecc-secp384r1-modp.asm
@@ -51,7 +51,7 @@ define(&lt;C0&gt;, H5)	C Overlap
 define(&lt;TMP&gt;, RP)	C Overlap
 
 
-PROLOGUE(nettle_ecc_384_modp)
+PROLOGUE(_nettle_ecc_384_modp)
 	W64_ENTRY(2, 0)
 
 	push	%rbx
@@ -231,4 +231,4 @@ PROLOGUE(nettle_ecc_384_modp)
 
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(nettle_ecc_384_modp)
+EPILOGUE(_nettle_ecc_384_modp)
diff --git a/x86_64/ecc-secp521r1-modp.asm b/x86_64/ecc-secp521r1-modp.asm
index 43a8cb8c9cfe..6f4f7d90714d 100644
--- a/x86_64/ecc-secp521r1-modp.asm
+++ b/x86_64/ecc-secp521r1-modp.asm
@@ -48,7 +48,7 @@ define(&lt;U9&gt;, &lt;%r11&gt;)
 define(&lt;T0&gt;, &lt;%r12&gt;)
 define(&lt;T1&gt;, &lt;%r13&gt;)
 
-PROLOGUE(nettle_ecc_521_modp)
+PROLOGUE(_nettle_ecc_521_modp)
 	W64_ENTRY(2, 0)
 	push	%rbx
 	push	%rbp
@@ -155,4 +155,4 @@ PROLOGUE(nettle_ecc_521_modp)
 	pop	%rbx
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(nettle_ecc_521_modp)
+EPILOGUE(_nettle_ecc_521_modp)
-- 
2.24.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191218121008</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-12-18 12:10:08-0400</timestampReceived><subject>[PATCH 3/3] ecc: rename functions to contain curve names instead of bits</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Rename curve functions to use curve names instead of just bits.
Otherwise function names can easily become confusing after adding other
curves.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 arm/ecc-secp192r1-modp.asm     |  6 +++---
 arm/ecc-secp224r1-modp.asm     |  6 +++---
 arm/ecc-secp256r1-redc.asm     |  6 +++---
 arm/ecc-secp384r1-modp.asm     |  6 +++---
 arm/ecc-secp521r1-modp.asm     |  6 +++---
 configure.ac                   | 22 +++++++++++-----------
 ecc-curve25519.c               | 34 +++++++++++++++++-----------------
 ecc-curve448.c                 | 24 ++++++++++++------------
 ecc-secp192r1.c                | 16 ++++++++--------
 ecc-secp224r1.c                | 16 ++++++++--------
 ecc-secp256r1.c                | 32 ++++++++++++++++----------------
 ecc-secp384r1.c                | 16 ++++++++--------
 ecc-secp521r1.c                | 12 ++++++------
 eddsa-sign.c                   |  2 +-
 x86_64/ecc-curve25519-modp.asm |  4 ++--
 x86_64/ecc-secp192r1-modp.asm  |  6 +++---
 x86_64/ecc-secp224r1-modp.asm  |  6 +++---
 x86_64/ecc-secp256r1-redc.asm  |  4 ++--
 x86_64/ecc-secp384r1-modp.asm  |  4 ++--
 x86_64/ecc-secp521r1-modp.asm  |  4 ++--
 20 files changed, 116 insertions(+), 116 deletions(-)

diff --git a/arm/ecc-secp192r1-modp.asm b/arm/ecc-secp192r1-modp.asm
index 4680336f1bc7..4c596a168b3d 100644
--- a/arm/ecc-secp192r1-modp.asm
+++ b/arm/ecc-secp192r1-modp.asm
@@ -49,11 +49,11 @@ define(&lt;H1&gt;, &lt;T1&gt;)
 define(&lt;C2&gt;, &lt;HP&gt;)
 define(&lt;C4&gt;, &lt;r12&gt;)
 
-	C ecc_192_modp (const struct ecc_modulo *m, mp_limb_t *rp)
+	C ecc_secp192r1_modp (const struct ecc_modulo *m, mp_limb_t *rp)
 	.text
 	.align 2
 
-PROLOGUE(_nettle_ecc_192_modp)
+PROLOGUE(_nettle_ecc_secp192r1_modp)
 	push	{r4,r5,r6,r7,r8,r10}
 	C Reduce two words at a time
 	add	HP, RP, #48
@@ -103,4 +103,4 @@ PROLOGUE(_nettle_ecc_192_modp)
 
 	pop	{r4,r5,r6,r7,r8,r10}
 	bx	lr
-EPILOGUE(_nettle_ecc_192_modp)
+EPILOGUE(_nettle_ecc_secp192r1_modp)
diff --git a/arm/ecc-secp224r1-modp.asm b/arm/ecc-secp224r1-modp.asm
index 400b7a815c2c..67089a0c2981 100644
--- a/arm/ecc-secp224r1-modp.asm
+++ b/arm/ecc-secp224r1-modp.asm
@@ -48,11 +48,11 @@ define(&lt;L0&gt;, &lt;r11&gt;)
 define(&lt;L1&gt;, &lt;r12&gt;)
 define(&lt;L2&gt;, &lt;lr&gt;)
 
-	C ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp)
+	C ecc_secp224r1_modp (const struct ecc_modulo *m, mp_limb_t *rp)
 	.text
 	.align 2
 
-PROLOGUE(_nettle_ecc_224_modp)
+PROLOGUE(_nettle_ecc_secp224r1_modp)
 	push	{r4,r5,r6,r7,r8,r10,r11,lr}
 
 	add	L2, RP, #28
@@ -121,4 +121,4 @@ PROLOGUE(_nettle_ecc_224_modp)
 	stmdb	RP, {T0,T1,T2,T3,T4,T5,T6}
 
 	pop	{r4,r5,r6,r7,r8,r10,r11,pc}
-EPILOGUE(_nettle_ecc_224_modp)
+EPILOGUE(_nettle_ecc_secp224r1_modp)
diff --git a/arm/ecc-secp256r1-redc.asm b/arm/ecc-secp256r1-redc.asm
index 7b117de43fbc..f8386c39c9a6 100644
--- a/arm/ecc-secp256r1-redc.asm
+++ b/arm/ecc-secp256r1-redc.asm
@@ -48,11 +48,11 @@ define(&lt;F1&gt;, &lt;r11&gt;)
 define(&lt;F2&gt;, &lt;r12&gt;)
 define(&lt;F3&gt;, &lt;lr&gt;)
 
-	C ecc_256_redc (const struct ecc_modulo *m, mp_limb_t *rp)
+	C ecc_secp256r1_redc (const struct ecc_modulo *m, mp_limb_t *rp)
 	.text
 	.align 2
 
-PROLOGUE(_nettle_ecc_256_redc)
+PROLOGUE(_nettle_ecc_secp256r1_redc)
 	push	{r4,r5,r6,r7,r8,r10,r11,lr}
 
 	ldm	RP!, {T0,T1,T2,T3,T4,T5,T6,T7}
@@ -170,4 +170,4 @@ PROLOGUE(_nettle_ecc_256_redc)
 	stm	RP, {T0,T1,T2,T3,T4,T5,T6,T7}
 
 	pop	{r4,r5,r6,r7,r8,r10,r11,pc}
-EPILOGUE(_nettle_ecc_256_redc)
+EPILOGUE(_nettle_ecc_secp256r1_redc)
diff --git a/arm/ecc-secp384r1-modp.asm b/arm/ecc-secp384r1-modp.asm
index dd9a325b09de..1983ee68cdd4 100644
--- a/arm/ecc-secp384r1-modp.asm
+++ b/arm/ecc-secp384r1-modp.asm
@@ -46,11 +46,11 @@ define(&lt;F4&gt;, &lt;r10&gt;)
 define(&lt;N&gt;, &lt;r12&gt;)
 define(&lt;H&gt;, &lt;lr&gt;)
 	
-	C ecc_384_modp (const struct ecc_modulo *m, mp_limb_t *rp)
+	C ecc_secp384r1_modp (const struct ecc_modulo *m, mp_limb_t *rp)
 	.text
 	.align 2
 
-PROLOGUE(_nettle_ecc_384_modp)
+PROLOGUE(_nettle_ecc_secp384r1_modp)
 	push	{r4,r5,r6,r7,r8,r10,lr}
 
 	add	RP, RP, #80
@@ -267,4 +267,4 @@ PROLOGUE(_nettle_ecc_384_modp)
 	adcs	T3, T3, H
 	stm	RP!, {T0,T1,T2,T3}	C 8-11
 	pop	{r4,r5,r6,r7,r8,r10,pc}
-EPILOGUE(_nettle_ecc_384_modp)
+EPILOGUE(_nettle_ecc_secp384r1_modp)
diff --git a/arm/ecc-secp521r1-modp.asm b/arm/ecc-secp521r1-modp.asm
index f11967634689..6d1759ec8a2a 100644
--- a/arm/ecc-secp521r1-modp.asm
+++ b/arm/ecc-secp521r1-modp.asm
@@ -45,14 +45,14 @@ define(&lt;F3&gt;, &lt;r8&gt;)
 define(&lt;H&gt;, &lt;r12&gt;)
 define(&lt;N&gt;, &lt;lr&gt;)
 
-	C ecc_521_modp (const struct ecc_modulo *m, mp_limb_t *rp)
+	C ecc_secp521r1_modp (const struct ecc_modulo *m, mp_limb_t *rp)
 	.text
 .Lc511:
 	.int 511
 
 	.align 2
 
-PROLOGUE(_nettle_ecc_521_modp)
+PROLOGUE(_nettle_ecc_secp521r1_modp)
 	push	{r4,r5,r6,r7,r8,lr}
 
 	C Use that B^17 = 2^23 (mod p)
@@ -124,4 +124,4 @@ PROLOGUE(_nettle_ecc_521_modp)
 	stm	RP, {T0,T1,T2,F0,F1,F2,F3,H}	C 9-16
 
 	pop	{r4,r5,r6,r7,r8,pc}
-EPILOGUE(_nettle_ecc_521_modp)
+EPILOGUE(_nettle_ecc_secp521r1_modp)
diff --git a/configure.ac b/configure.ac
index 745cc2c5c20e..35eba69871ac 100644
--- a/configure.ac
+++ b/configure.ac
@@ -572,18 +572,18 @@ AH_VERBATIM([HAVE_NATIVE],
 [/* Define to 1 each of the following for which a native (ie. CPU specific)
     implementation of the corresponding routine exists.  */
 #undef HAVE_NATIVE_chacha_core
-#undef HAVE_NATIVE_ecc_192_modp
-#undef HAVE_NATIVE_ecc_192_redc
-#undef HAVE_NATIVE_ecc_224_modp
-#undef HAVE_NATIVE_ecc_224_redc
-#undef HAVE_NATIVE_ecc_25519_modp
-#undef HAVE_NATIVE_ecc_256_modp
-#undef HAVE_NATIVE_ecc_256_redc
-#undef HAVE_NATIVE_ecc_384_modp
-#undef HAVE_NATIVE_ecc_384_redc
+#undef HAVE_NATIVE_ecc_secp192r1_modp
+#undef HAVE_NATIVE_ecc_secp192r1_redc
+#undef HAVE_NATIVE_ecc_secp224r1_modp
+#undef HAVE_NATIVE_ecc_secp224r1_redc
+#undef HAVE_NATIVE_ecc_secp25519r1_modp
+#undef HAVE_NATIVE_ecc_secp256r1_modp
+#undef HAVE_NATIVE_ecc_secp256r1_redc
+#undef HAVE_NATIVE_ecc_secp384r1_modp
+#undef HAVE_NATIVE_ecc_secp384r1_redc
 #undef HAVE_NATIVE_ecc_curve448_modp
-#undef HAVE_NATIVE_ecc_521_modp
-#undef HAVE_NATIVE_ecc_521_redc
+#undef HAVE_NATIVE_ecc_secp521r1_modp
+#undef HAVE_NATIVE_ecc_secp521r1_redc
 #undef HAVE_NATIVE_gcm_hash8
 #undef HAVE_NATIVE_salsa20_core
 #undef HAVE_NATIVE_sha1_compress
diff --git a/ecc-curve25519.c b/ecc-curve25519.c
index 1045db7092ae..34d8fd6330b6 100644
--- a/ecc-curve25519.c
+++ b/ecc-curve25519.c
@@ -46,11 +46,11 @@
 
 #define PHIGH_BITS (GMP_NUMB_BITS * ECC_LIMB_SIZE - 255)
 
-#if HAVE_NATIVE_ecc_25519_modp
+#if HAVE_NATIVE_ecc_secp25519r1_modp
 
-#define ecc_25519_modp _nettle_ecc_25519_modp
+#define ecc_secp25519r1_modp _nettle_ecc_secp25519r1_modp
 void
-ecc_25519_modp (const struct ecc_modulo *m, mp_limb_t *rp);
+ecc_secp25519r1_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #else
 
 #if PHIGH_BITS == 0
@@ -58,7 +58,7 @@ ecc_25519_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #endif
 
 static void
-ecc_25519_modp(const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
+ecc_secp25519r1_modp(const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
 {
   mp_limb_t hi, cy;
 
@@ -69,7 +69,7 @@ ecc_25519_modp(const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
   rp[ECC_LIMB_SIZE-1] = (hi &amp; (GMP_NUMB_MASK &gt;&gt; PHIGH_BITS))
     + sec_add_1 (rp, rp, ECC_LIMB_SIZE - 1, 19 * cy);
 }
-#endif /* HAVE_NATIVE_ecc_25519_modp */
+#endif /* HAVE_NATIVE_ecc_secp25519r1_modp */
 
 #define QHIGH_BITS (GMP_NUMB_BITS * ECC_LIMB_SIZE - 252)
 
@@ -78,7 +78,7 @@ ecc_25519_modp(const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
 #endif
 
 static void
-ecc_25519_modq (const struct ecc_modulo *q, mp_limb_t *rp)
+ecc_secp25519r1_modq (const struct ecc_modulo *q, mp_limb_t *rp)
 {
   mp_size_t n;
   mp_limb_t cy;
@@ -180,7 +180,7 @@ ecc_mod_pow_252m3 (const struct ecc_modulo *m,
 /* Needs 5*ECC_LIMB_SIZE scratch space. */
 #define ECC_25519_INV_ITCH (5*ECC_LIMB_SIZE)
 
-static void ecc_25519_inv (const struct ecc_modulo *p,
+static void ecc_secp25519r1_inv (const struct ecc_modulo *p,
 			   mp_limb_t *rp, const mp_limb_t *ap,
 			   mp_limb_t *scratch)
 {
@@ -203,7 +203,7 @@ static void ecc_25519_inv (const struct ecc_modulo *p,
 
 /* First, do a canonical reduction, then check if zero */
 static int
-ecc_25519_zero_p (const struct ecc_modulo *p, mp_limb_t *xp)
+ecc_secp25519r1_zero_p (const struct ecc_modulo *p, mp_limb_t *xp)
 {
   mp_limb_t cy;
   mp_limb_t w;
@@ -239,7 +239,7 @@ ecc_25519_zero_p (const struct ecc_modulo *p, mp_limb_t *xp)
 #define ECC_25519_SQRT_ITCH (9*ECC_LIMB_SIZE)
 
 static int
-ecc_25519_sqrt(const struct ecc_modulo *p, mp_limb_t *rp,
+ecc_secp25519r1_sqrt(const struct ecc_modulo *p, mp_limb_t *rp,
 	       const mp_limb_t *up, const mp_limb_t *vp,
 	       mp_limb_t *scratch)
 {
@@ -271,9 +271,9 @@ ecc_25519_sqrt(const struct ecc_modulo *p, mp_limb_t *rp,
   ecc_mod_sqr (p, x2, rp);
   ecc_mod_mul (p, vx2, x2, vp);
   ecc_mod_add (p, t0, vx2, up);
-  neg = ecc_25519_zero_p (p, t0);
+  neg = ecc_secp25519r1_zero_p (p, t0);
   ecc_mod_sub (p, t0, up, vx2);
-  pos = ecc_25519_zero_p (p, t0);
+  pos = ecc_secp25519r1_zero_p (p, t0);
 
   ecc_mod_mul (p, t0, rp, ecc_sqrt_z);
   cnd_copy (neg, rp, t0, ECC_LIMB_SIZE);
@@ -306,10 +306,10 @@ const struct ecc_curve _nettle_curve25519 =
     NULL,
     ecc_pp1h,
 
-    ecc_25519_modp,
-    ecc_25519_modp,
-    ecc_25519_inv,
-    ecc_25519_sqrt,
+    ecc_secp25519r1_modp,
+    ecc_secp25519r1_modp,
+    ecc_secp25519r1_inv,
+    ecc_secp25519r1_sqrt,
   },
   {
     253,
@@ -325,8 +325,8 @@ const struct ecc_curve _nettle_curve25519 =
     NULL,
     ecc_qp1h,
 
-    ecc_25519_modq,
-    ecc_25519_modq,
+    ecc_secp25519r1_modq,
+    ecc_secp25519r1_modq,
     ecc_mod_inv,
     NULL,
   },
diff --git a/ecc-curve448.c b/ecc-curve448.c
index e1318ca4f01d..61cd6dbc3b2c 100644
--- a/ecc-curve448.c
+++ b/ecc-curve448.c
@@ -46,12 +46,12 @@
 #include "ecc-curve448.h"
 
 #if HAVE_NATIVE_ecc_curve448_modp
-#define ecc_448_modp _nettle_ecc_curve448_modp
+#define ecc_secp448r1_modp _nettle_ecc_curve448_modp
 void
-ecc_448_modp (const struct ecc_modulo *m, mp_limb_t *rp);
+ecc_secp448r1_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #elif GMP_NUMB_BITS == 64
 static void
-ecc_448_modp(const struct ecc_modulo *m, mp_limb_t *rp)
+ecc_secp448r1_modp(const struct ecc_modulo *m, mp_limb_t *rp)
 {
   /* Let B = 2^64, b = 2^32 = sqrt(B).
      p = B^7 - b B^3 - 1 ==&gt; B^7 = b B^3 + 1
@@ -95,7 +95,7 @@ ecc_448_modp(const struct ecc_modulo *m, mp_limb_t *rp)
   assert (c7 == 0);
 }
 #else
-#define ecc_448_modp ecc_mod
+#define ecc_secp448r1_modp ecc_mod
 #endif
 
 /* Needs 2*ecc-&gt;size limbs at rp, and 2*ecc-&gt;size additional limbs of
@@ -167,7 +167,7 @@ ecc_mod_pow_446m224m1 (const struct ecc_modulo *p,
 /* Needs 6*ECC_LIMB_SIZE scratch space. */
 #define ECC_448_INV_ITCH (6*ECC_LIMB_SIZE)
 
-static void ecc_448_inv (const struct ecc_modulo *p,
+static void ecc_secp448r1_inv (const struct ecc_modulo *p,
 			 mp_limb_t *rp, const mp_limb_t *ap,
 			 mp_limb_t *scratch)
 {
@@ -184,7 +184,7 @@ static void ecc_448_inv (const struct ecc_modulo *p,
 
 /* First, do a canonical reduction, then check if zero */
 static int
-ecc_448_zero_p (const struct ecc_modulo *p, mp_limb_t *xp)
+ecc_secp448r1_zero_p (const struct ecc_modulo *p, mp_limb_t *xp)
 {
   mp_limb_t cy;
   mp_limb_t w;
@@ -210,7 +210,7 @@ ecc_448_zero_p (const struct ecc_modulo *p, mp_limb_t *xp)
 #define ECC_448_SQRT_ITCH (10*ECC_LIMB_SIZE)
 
 static int
-ecc_448_sqrt(const struct ecc_modulo *p, mp_limb_t *rp,
+ecc_secp448r1_sqrt(const struct ecc_modulo *p, mp_limb_t *rp,
 	     const mp_limb_t *up, const mp_limb_t *vp,
 	     mp_limb_t *scratch)
 {
@@ -243,7 +243,7 @@ ecc_448_sqrt(const struct ecc_modulo *p, mp_limb_t *rp,
   ecc_mod_mul (p, vx2, x2, vp);
   ecc_mod_sub (p, t0, vx2, up);
 
-  return ecc_448_zero_p (p, t0);
+  return ecc_secp448r1_zero_p (p, t0);
 
 #undef u3v
 #undef u5v3
@@ -274,10 +274,10 @@ const struct ecc_curve _nettle_curve448 =
     NULL,
     ecc_pp1h,
 
-    ecc_448_modp,
-    ecc_448_modp,
-    ecc_448_inv,
-    ecc_448_sqrt,
+    ecc_secp448r1_modp,
+    ecc_secp448r1_modp,
+    ecc_secp448r1_inv,
+    ecc_secp448r1_sqrt,
   },
   {
     446,
diff --git a/ecc-secp192r1.c b/ecc-secp192r1.c
index 15f5f1fa4c04..094074d73ed7 100644
--- a/ecc-secp192r1.c
+++ b/ecc-secp192r1.c
@@ -48,18 +48,18 @@
 
 #include "ecc-secp192r1.h"
 
-#if HAVE_NATIVE_ecc_192_modp
+#if HAVE_NATIVE_ecc_secp192r1_modp
 
-#define ecc_192_modp _nettle_ecc_192_modp
+#define ecc_secp192r1_modp _nettle_ecc_secp192r1_modp
 void
-ecc_192_modp (const struct ecc_modulo *m, mp_limb_t *rp);
+ecc_secp192r1_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 
 /* Use that p = 2^{192} - 2^64 - 1, to eliminate 128 bits at a time. */
 
 #elif GMP_NUMB_BITS == 32
 /* p is 6 limbs, p = B^6 - B^2 - 1 */
 static void
-ecc_192_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
+ecc_secp192r1_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
 {
   mp_limb_t cy;
 
@@ -84,7 +84,7 @@ ecc_192_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
 #elif GMP_NUMB_BITS == 64
 /* p is 3 limbs, p = B^3 - B - 1 */
 static void
-ecc_192_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
+ecc_secp192r1_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
 {
   mp_limb_t cy;
 
@@ -107,7 +107,7 @@ ecc_192_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
 }
   
 #else
-#define ecc_192_modp ecc_mod
+#define ecc_secp192r1_modp ecc_mod
 #endif
 
 const struct ecc_curve _nettle_secp_192r1 =
@@ -126,8 +126,8 @@ const struct ecc_curve _nettle_secp_192r1 =
     ecc_redc_ppm1,
     ecc_pp1h,
 
-    ecc_192_modp,
-    ecc_192_modp,
+    ecc_secp192r1_modp,
+    ecc_secp192r1_modp,
     ecc_mod_inv,
     NULL,
   },
diff --git a/ecc-secp224r1.c b/ecc-secp224r1.c
index 28b938fa3282..e6b43fa61f42 100644
--- a/ecc-secp224r1.c
+++ b/ecc-secp224r1.c
@@ -40,24 +40,24 @@
 #include "ecc.h"
 #include "ecc-internal.h"
 
-#if HAVE_NATIVE_ecc_224_modp
+#if HAVE_NATIVE_ecc_secp224r1_modp
 
 #define USE_REDC 0
-#define ecc_224_modp _nettle_ecc_224_modp
+#define ecc_secp224r1_modp _nettle_ecc_secp224r1_modp
 void
-ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp);
+ecc_secp224r1_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 
 #else
 #define USE_REDC (ECC_REDC_SIZE != 0)
-#define ecc_224_modp ecc_mod
+#define ecc_secp224r1_modp ecc_mod
 #endif
 
 #include "ecc-secp224r1.h"
 
 #if ECC_REDC_SIZE &lt; 0
-# define ecc_224_redc ecc_pm1_redc
+# define ecc_secp224r1_redc ecc_pm1_redc
 #elif ECC_REDC_SIZE == 0
-# define ecc_224_redc NULL
+# define ecc_secp224r1_redc NULL
 #else
 # error Configuration error
 #endif
@@ -78,8 +78,8 @@ const struct ecc_curve _nettle_secp_224r1 =
     ecc_redc_ppm1,
     ecc_pp1h,
 
-    ecc_224_modp,
-    USE_REDC ? ecc_224_redc : ecc_224_modp,
+    ecc_secp224r1_modp,
+    USE_REDC ? ecc_secp224r1_redc : ecc_secp224r1_modp,
     ecc_mod_inv,
     NULL,
   },
diff --git a/ecc-secp256r1.c b/ecc-secp256r1.c
index ed463edf7729..72b337db4560 100644
--- a/ecc-secp256r1.c
+++ b/ecc-secp256r1.c
@@ -42,7 +42,7 @@
 #include "ecc.h"
 #include "ecc-internal.h"
 
-#if HAVE_NATIVE_ecc_256_redc
+#if HAVE_NATIVE_ecc_secp256r1_redc
 # define USE_REDC 1
 #else
 # define USE_REDC (ECC_REDC_SIZE != 0)
@@ -50,27 +50,27 @@
 
 #include "ecc-secp256r1.h"
 
-#if HAVE_NATIVE_ecc_256_redc
-# define ecc_256_redc _nettle_ecc_256_redc
+#if HAVE_NATIVE_ecc_secp256r1_redc
+# define ecc_secp256r1_redc _nettle_ecc_secp256r1_redc
 void
-ecc_256_redc (const struct ecc_modulo *p, mp_limb_t *rp);
-#else /* !HAVE_NATIVE_ecc_256_redc */
+ecc_secp256r1_redc (const struct ecc_modulo *p, mp_limb_t *rp);
+#else /* !HAVE_NATIVE_ecc_secp256r1_redc */
 # if ECC_REDC_SIZE &gt; 0 
-#   define ecc_256_redc ecc_pp1_redc
+#   define ecc_secp256r1_redc ecc_pp1_redc
 # elif ECC_REDC_SIZE == 0
-#   define ecc_256_redc NULL
+#   define ecc_secp256r1_redc NULL
 # else
 #  error Configuration error
 # endif
-#endif /* !HAVE_NATIVE_ecc_256_redc */
+#endif /* !HAVE_NATIVE_ecc_secp256r1_redc */
 
 #if ECC_BMODP_SIZE &lt; ECC_LIMB_SIZE
-#define ecc_256_modp ecc_mod
-#define ecc_256_modq ecc_mod
+#define ecc_secp256r1_modp ecc_mod
+#define ecc_secp256r1_modq ecc_mod
 #elif GMP_NUMB_BITS == 64
 
 static void
-ecc_256_modp (const struct ecc_modulo *p, mp_limb_t *rp)
+ecc_secp256r1_modp (const struct ecc_modulo *p, mp_limb_t *rp)
 {
   mp_limb_t u1, u0;
   mp_size_t n;
@@ -146,7 +146,7 @@ ecc_256_modp (const struct ecc_modulo *p, mp_limb_t *rp)
 }
 
 static void
-ecc_256_modq (const struct ecc_modulo *q, mp_limb_t *rp)
+ecc_secp256r1_modq (const struct ecc_modulo *q, mp_limb_t *rp)
 {
   mp_limb_t u2, u1, u0;
   mp_size_t n;
@@ -255,8 +255,8 @@ const struct ecc_curve _nettle_secp_256r1 =
     ecc_redc_ppm1,
 
     ecc_pp1h,
-    ecc_256_modp,
-    USE_REDC ? ecc_256_redc : ecc_256_modp,
+    ecc_secp256r1_modp,
+    USE_REDC ? ecc_secp256r1_redc : ecc_secp256r1_modp,
     ecc_mod_inv,
     NULL,
   },
@@ -274,8 +274,8 @@ const struct ecc_curve _nettle_secp_256r1 =
     NULL,
     ecc_qp1h,
 
-    ecc_256_modq,
-    ecc_256_modq,
+    ecc_secp256r1_modq,
+    ecc_secp256r1_modq,
     ecc_mod_inv,
     NULL,
   },
diff --git a/ecc-secp384r1.c b/ecc-secp384r1.c
index 32f75fb618ba..c4a75564bf58 100644
--- a/ecc-secp384r1.c
+++ b/ecc-secp384r1.c
@@ -46,10 +46,10 @@
 
 #include "ecc-secp384r1.h"
 
-#if HAVE_NATIVE_ecc_384_modp
-#define ecc_384_modp _nettle_ecc_384_modp
+#if HAVE_NATIVE_ecc_secp384r1_modp
+#define ecc_secp384r1_modp _nettle_ecc_secp384r1_modp
 void
-ecc_384_modp (const struct ecc_modulo *m, mp_limb_t *rp);
+ecc_secp384r1_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #elif GMP_NUMB_BITS == 32
 
 /* Use that 2^{384} = 2^{128} + 2^{96} - 2^{32} + 1, and eliminate 256
@@ -62,7 +62,7 @@ ecc_384_modp (const struct ecc_modulo *m, mp_limb_t *rp);
    almost 8 at a time. Do only 7, to avoid additional carry
    propagation, followed by 5. */
 static void
-ecc_384_modp (const struct ecc_modulo *p, mp_limb_t *rp)
+ecc_secp384r1_modp (const struct ecc_modulo *p, mp_limb_t *rp)
 {
   mp_limb_t cy, bw;
 
@@ -106,7 +106,7 @@ ecc_384_modp (const struct ecc_modulo *p, mp_limb_t *rp)
 /* p is 6 limbs, and B^6 - p = B^2 + 2^32 (B - 1) + 1. Eliminate 3
    (almost 4) limbs at a time. */
 static void
-ecc_384_modp (const struct ecc_modulo *p, mp_limb_t *rp)
+ecc_secp384r1_modp (const struct ecc_modulo *p, mp_limb_t *rp)
 {
   mp_limb_t tp[6];
   mp_limb_t cy;
@@ -144,7 +144,7 @@ ecc_384_modp (const struct ecc_modulo *p, mp_limb_t *rp)
   assert (cy == 0);  
 }
 #else
-#define ecc_384_modp ecc_mod
+#define ecc_secp384r1_modp ecc_mod
 #endif
   
 const struct ecc_curve _nettle_secp_384r1 =
@@ -163,8 +163,8 @@ const struct ecc_curve _nettle_secp_384r1 =
     ecc_redc_ppm1,
     ecc_pp1h,
 
-    ecc_384_modp,
-    ecc_384_modp,
+    ecc_secp384r1_modp,
+    ecc_secp384r1_modp,
     ecc_mod_inv,
     NULL,
   },
diff --git a/ecc-secp521r1.c b/ecc-secp521r1.c
index d952d77e444e..74688008959b 100644
--- a/ecc-secp521r1.c
+++ b/ecc-secp521r1.c
@@ -44,10 +44,10 @@
 
 #include "ecc-secp521r1.h"
 
-#if HAVE_NATIVE_ecc_521_modp
-#define ecc_521_modp _nettle_ecc_521_modp
+#if HAVE_NATIVE_ecc_secp521r1_modp
+#define ecc_secp521r1_modp _nettle_ecc_secp521r1_modp
 void
-ecc_521_modp (const struct ecc_modulo *m, mp_limb_t *rp);
+ecc_secp521r1_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 
 #else
 
@@ -57,7 +57,7 @@ ecc_521_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 
 /* Result may be *slightly* larger than 2^521 */
 static void
-ecc_521_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
+ecc_secp521r1_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
 {
   /* FIXME: Should use mpn_addlsh_n_ip1 */
   mp_limb_t hi;
@@ -91,8 +91,8 @@ const struct ecc_curve _nettle_secp_521r1 =
     ecc_redc_ppm1,
     ecc_pp1h,
 
-    ecc_521_modp,
-    ecc_521_modp,
+    ecc_secp521r1_modp,
+    ecc_secp521r1_modp,
     ecc_mod_inv,
     NULL,
   },
diff --git a/eddsa-sign.c b/eddsa-sign.c
index 13ae47995e74..7f4e3e8f427b 100644
--- a/eddsa-sign.c
+++ b/eddsa-sign.c
@@ -87,7 +87,7 @@ _eddsa_sign (const struct ecc_curve *ecc,
 
   ecc_modq_mul (ecc, sp, hp, k2);
   ecc_modq_add (ecc, sp, sp, rp); /* FIXME: Can be plain add */
-  /* FIXME: Special code duplicated in ecc_25519_modq and ecc_eh_to_a.
+  /* FIXME: Special code duplicated in ecc_secp25519r1_modq and ecc_eh_to_a.
      Define a suitable method? */
   {
     unsigned shift;
diff --git a/x86_64/ecc-curve25519-modp.asm b/x86_64/ecc-curve25519-modp.asm
index 0374db12ab44..5a17b4ce16a0 100644
--- a/x86_64/ecc-curve25519-modp.asm
+++ b/x86_64/ecc-curve25519-modp.asm
@@ -41,7 +41,7 @@ define(&lt;T0&gt;, &lt;%r10&gt;)
 define(&lt;T1&gt;, &lt;%r11&gt;)
 define(&lt;M&gt;, &lt;%rbx&gt;)
 
-PROLOGUE(_nettle_ecc_25519_modp)
+PROLOGUE(_nettle_ecc_secp25519r1_modp)
 	W64_ENTRY(2, 0)
 	push	%rbx
 
@@ -91,4 +91,4 @@ PROLOGUE(_nettle_ecc_25519_modp)
 	pop	%rbx
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(_nettle_ecc_25519_modp)
+EPILOGUE(_nettle_ecc_secp25519r1_modp)
diff --git a/x86_64/ecc-secp192r1-modp.asm b/x86_64/ecc-secp192r1-modp.asm
index ad8dca7186e4..3a008130c1bb 100644
--- a/x86_64/ecc-secp192r1-modp.asm
+++ b/x86_64/ecc-secp192r1-modp.asm
@@ -41,10 +41,10 @@ define(&lt;H&gt;, &lt;%r9&gt;)
 define(&lt;C1&gt;, &lt;%r10&gt;)
 define(&lt;C2&gt;, &lt;%r11&gt;)
 
-	C ecc_192_modp (const struct ecc_modulo *m, mp_limb_t *rp)
+	C ecc_secp192r1_modp (const struct ecc_modulo *m, mp_limb_t *rp)
 	.text
 	ALIGN(16)
-PROLOGUE(_nettle_ecc_192_modp)
+PROLOGUE(_nettle_ecc_secp192r1_modp)
 	W64_ENTRY(2, 0)
 	mov	16(RP), T2
 	mov	24(RP), T3
@@ -85,4 +85,4 @@ PROLOGUE(_nettle_ecc_192_modp)
 
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(_nettle_ecc_192_modp)
+EPILOGUE(_nettle_ecc_secp192r1_modp)
diff --git a/x86_64/ecc-secp224r1-modp.asm b/x86_64/ecc-secp224r1-modp.asm
index e44b5418e5dd..dfa85a8d6f3f 100644
--- a/x86_64/ecc-secp224r1-modp.asm
+++ b/x86_64/ecc-secp224r1-modp.asm
@@ -44,8 +44,8 @@ define(&lt;F0&gt;, &lt;%r9&gt;)
 define(&lt;F1&gt;, &lt;%r10&gt;)
 define(&lt;F2&gt;, &lt;%r11&gt;)
 
-	C ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp)
-PROLOGUE(_nettle_ecc_224_modp)
+	C ecc_secp224r1_modp (const struct ecc_modulo *m, mp_limb_t *rp)
+PROLOGUE(_nettle_ecc_secp224r1_modp)
 	W64_ENTRY(2, 0)
 	mov	48(RP), H0
 	mov	56(RP), H1
@@ -128,4 +128,4 @@ PROLOGUE(_nettle_ecc_224_modp)
 
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(_nettle_ecc_224_modp)
+EPILOGUE(_nettle_ecc_secp224r1_modp)
diff --git a/x86_64/ecc-secp256r1-redc.asm b/x86_64/ecc-secp256r1-redc.asm
index 533a1766d4bc..67da065b27f4 100644
--- a/x86_64/ecc-secp256r1-redc.asm
+++ b/x86_64/ecc-secp256r1-redc.asm
@@ -58,7 +58,7 @@ define(&lt;FOLD&gt;, &lt;
 	sbb	$1, F2
 	sbb	&lt;$&gt;0, F3
 &gt;)
-PROLOGUE(_nettle_ecc_256_redc)
+PROLOGUE(_nettle_ecc_secp256r1_redc)
 	W64_ENTRY(2, 0)
 	C save all registers that need to be saved
 	push	%rbx
@@ -126,4 +126,4 @@ PROLOGUE(_nettle_ecc_256_redc)
 	pop	%rbx
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(_nettle_ecc_256_redc)
+EPILOGUE(_nettle_ecc_secp256r1_redc)
diff --git a/x86_64/ecc-secp384r1-modp.asm b/x86_64/ecc-secp384r1-modp.asm
index 13f469b164e4..9bfa0618d33e 100644
--- a/x86_64/ecc-secp384r1-modp.asm
+++ b/x86_64/ecc-secp384r1-modp.asm
@@ -51,7 +51,7 @@ define(&lt;C0&gt;, H5)	C Overlap
 define(&lt;TMP&gt;, RP)	C Overlap
 
 
-PROLOGUE(_nettle_ecc_384_modp)
+PROLOGUE(_nettle_ecc_secp384r1_modp)
 	W64_ENTRY(2, 0)
 
 	push	%rbx
@@ -231,4 +231,4 @@ PROLOGUE(_nettle_ecc_384_modp)
 
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(_nettle_ecc_384_modp)
+EPILOGUE(_nettle_ecc_secp384r1_modp)
diff --git a/x86_64/ecc-secp521r1-modp.asm b/x86_64/ecc-secp521r1-modp.asm
index 6f4f7d90714d..a6840a60faec 100644
--- a/x86_64/ecc-secp521r1-modp.asm
+++ b/x86_64/ecc-secp521r1-modp.asm
@@ -48,7 +48,7 @@ define(&lt;U9&gt;, &lt;%r11&gt;)
 define(&lt;T0&gt;, &lt;%r12&gt;)
 define(&lt;T1&gt;, &lt;%r13&gt;)
 
-PROLOGUE(_nettle_ecc_521_modp)
+PROLOGUE(_nettle_ecc_secp521r1_modp)
 	W64_ENTRY(2, 0)
 	push	%rbx
 	push	%rbp
@@ -155,4 +155,4 @@ PROLOGUE(_nettle_ecc_521_modp)
 	pop	%rbx
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(_nettle_ecc_521_modp)
+EPILOGUE(_nettle_ecc_secp521r1_modp)
-- 
2.24.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191218121651</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-12-18 12:16:51-0400</timestampReceived><subject>[PATCH v2 1/3] ecc: rename source files with curves data</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

In preparation to adding GOST curves support, rename source files and
use curve name as eccdata parameter.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 .gitignore                                    | 14 ++---
 Makefile.in                                   | 54 ++++++++---------
 ...cc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} |  4 +-
 ...cc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} |  4 +-
 ...cc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} |  4 +-
 ...cc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} |  4 +-
 ...cc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} |  4 +-
 configure.ac                                  |  6 +-
 ecc-25519.c =&gt; ecc-curve25519.c               |  4 +-
 ecc-448.c =&gt; ecc-curve448.c                   |  4 +-
 ecc-192.c =&gt; ecc-secp192r1.c                  |  4 +-
 ecc-224.c =&gt; ecc-secp224r1.c                  |  4 +-
 ecc-256.c =&gt; ecc-secp256r1.c                  |  4 +-
 ecc-384.c =&gt; ecc-secp384r1.c                  |  4 +-
 ecc-521.c =&gt; ecc-secp521r1.c                  |  4 +-
 eccdata.c                                     | 58 +++++++++++--------
 ...25519-modp.asm =&gt; ecc-curve25519-modp.asm} |  0
 ...cc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} |  4 +-
 ...cc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} |  4 +-
 ...cc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} |  4 +-
 ...cc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} |  4 +-
 ...cc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} |  4 +-
 22 files changed, 105 insertions(+), 95 deletions(-)
 rename arm/{ecc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} (97%)
 rename arm/{ecc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} (97%)
 rename arm/{ecc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} (98%)
 rename arm/{ecc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} (98%)
 rename arm/{ecc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} (97%)
 rename ecc-25519.c =&gt; ecc-curve25519.c (99%)
 rename ecc-448.c =&gt; ecc-curve448.c (99%)
 rename ecc-192.c =&gt; ecc-secp192r1.c (98%)
 rename ecc-224.c =&gt; ecc-secp224r1.c (98%)
 rename ecc-256.c =&gt; ecc-secp256r1.c (99%)
 rename ecc-384.c =&gt; ecc-secp384r1.c (99%)
 rename ecc-521.c =&gt; ecc-secp521r1.c (98%)
 rename x86_64/{ecc-25519-modp.asm =&gt; ecc-curve25519-modp.asm} (100%)
 rename x86_64/{ecc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} (96%)
 rename x86_64/{ecc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} (97%)
 rename x86_64/{ecc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} (97%)
 rename x86_64/{ecc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} (98%)
 rename x86_64/{ecc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} (97%)

diff --git a/.gitignore b/.gitignore
index 0afe61de3826..ea264107fa40 100644
--- a/.gitignore
+++ b/.gitignore
@@ -43,13 +43,13 @@ core
 /keymap.h
 /parity.h
 /rotors.h
-/ecc-192.h
-/ecc-224.h
-/ecc-256.h
-/ecc-384.h
-/ecc-521.h
-/ecc-25519.h
-/ecc-448.h
+/ecc-curve25519.h
+/ecc-curve448.h
+/ecc-secp192r1.h
+/ecc-secp224r1.h
+/ecc-secp256r1.h
+/ecc-secp384r1.h
+/ecc-secp521r1.h
 /version.h
 /nettle.aux
 /nettle.cp
diff --git a/Makefile.in b/Makefile.in
index 8d06149ff5fb..28b7cfcebcdb 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -174,8 +174,9 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  gmp-glue.c cnd-copy.c \
 		  ecc-mod.c ecc-mod-inv.c \
 		  ecc-mod-arith.c ecc-pp1-redc.c ecc-pm1-redc.c \
-		  ecc-192.c ecc-224.c ecc-256.c ecc-384.c ecc-521.c \
-		  ecc-25519.c ecc-448.c \
+		  ecc-curve25519.c ecc-curve448.c \
+		  ecc-secp192r1.c ecc-secp224r1.c ecc-secp256r1.c \
+		  ecc-secp384r1.c ecc-secp521r1.c \
 		  ecc-size.c ecc-j-to-a.c ecc-a-to-j.c \
 		  ecc-dup-jj.c ecc-add-jja.c ecc-add-jjj.c \
 		  ecc-eh-to-a.c \
@@ -346,24 +347,24 @@ des.$(OBJEXT): des.c des.h $(des_headers)
 # k = 14, c =  7, S = 256, T =  42 ( 28 A + 14 D) 12 KB
 # k = 11, c =  6, S = 192, T =  44 ( 33 A + 11 D)  9 KB
 # k = 16, c =  6, S = 128, T =  48 ( 32 A + 16 D)  6 KB
-ecc-192.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 192 8 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp192r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp192r1 8 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 224:
 # k = 16, c =  7, S = 256, T =  48 ( 32 A + 16 D) ~16 KB
 # k = 10, c =  6, S = 256, T =  50 ( 40 A + 10 D) ~16 KB
 # k = 13, c =  6, S = 192, T =  52 ( 39 A + 13 D) ~12 KB
 # k =  9, c =  5, S = 160, T =  54 ( 45 A +  9 D) ~10 KB
-ecc-224.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 224 16 7 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp224r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp224r1 16 7 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 256:
 # k =  9, c =  6, S = 320, T =  54 ( 45 A +  9 D) 20 KB
 # k = 11, c =  6, S = 256, T =  55 ( 44 A + 11 D) 16 KB
 # k = 19, c =  7, S = 256, T =  57 ( 38 A + 19 D) 16 KB
 # k = 15, c =  6, S = 192, T =  60 ( 45 A + 15 D) 12 KB
-ecc-256.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 256 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp256r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp256r1 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 384:
 # k = 16, c =  6, S = 256, T =  80 ( 64 A + 16 D) 24 KB
@@ -373,35 +374,35 @@ ecc-256.h: eccdata.stamp
 # k = 13, c =  5, S = 192, T =  91 ( 78 A + 13 D) 18 KB
 # k = 16, c =  5, S = 160, T =  96 ( 80 A + 16 D) 15 KB
 # k = 32, c =  6, S = 128, T =  96 ( 64 A + 32 D) 12 KB
-ecc-384.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 384 32 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp384r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp384r1 32 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 521:
 # k = 29, c =  6, S = 192, T = 116 ( 87 A + 29 D) ~27 KB
 # k = 21, c =  5, S = 160, T = 126 (105 A + 21 D) ~23 KB
 # k = 44, c =  6, S = 128, T = 132 ( 88 A + 44 D) ~18 KB
 # k = 35, c =  5, S =  96, T = 140 (105 A + 35 D) ~14 KB
-ecc-521.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 521 44 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp521r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp521r1 44 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
-# Parameter choices mostly the same as for ecc-256.h.
-ecc-25519.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 255 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+# Parameter choices mostly the same as for ecc-secp256r1.h.
+ecc-curve25519.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) curve25519 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
-ecc-448.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 448 38 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-curve448.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) curve448 38 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 eccdata.stamp: eccdata.c
 	$(MAKE) eccdata$(EXEEXT_FOR_BUILD)
 	echo stamp &gt; eccdata.stamp
 
-ecc-192.$(OBJEXT): ecc-192.h
-ecc-224.$(OBJEXT): ecc-224.h
-ecc-256.$(OBJEXT): ecc-256.h
-ecc-384.$(OBJEXT): ecc-384.h
-ecc-521.$(OBJEXT): ecc-521.h
-ecc-25519.$(OBJEXT): ecc-25519.h
-ecc-448.$(OBJEXT): ecc-448.h
+ecc-curve25519.$(OBJEXT): ecc-curve25519.h
+ecc-curve448.$(OBJEXT): ecc-curve448.h
+ecc-secp192r1.$(OBJEXT): ecc-secp192r1.h
+ecc-secp224r1.$(OBJEXT): ecc-secp224r1.h
+ecc-secp256r1.$(OBJEXT): ecc-secp256r1.h
+ecc-secp384r1.$(OBJEXT): ecc-secp384r1.h
+ecc-secp521r1.$(OBJEXT): ecc-secp521r1.h
 
 .asm.$(OBJEXT): $(srcdir)/asm.m4 machine.m4 config.m4
 	$(M4) $(srcdir)/asm.m4 machine.m4 config.m4 $&lt; &gt;$*.s
@@ -654,8 +655,9 @@ distcheck: dist
 
 clean-here:
 	-rm -f $(TARGETS) *.$(OBJEXT) *.s *.so *.dll *.a \
-		ecc-192.h ecc-224.h ecc-256.h ecc-384.h ecc-521.h ecc-25519.h \
-		ecc-448.h \
+		ecc-curve25519.h ecc-curve448.h \
+		ecc-secp192r1.h ecc-secp224r1.h ecc-secp256r1.h \
+		ecc-secp384r1.h ecc-secp521r1.h \
 		aesdata$(EXEEXT_FOR_BUILD) \
 		desdata$(EXEEXT_FOR_BUILD) \
 		twofishdata$(EXEEXT_FOR_BUILD) \
diff --git a/arm/ecc-192-modp.asm b/arm/ecc-secp192r1-modp.asm
similarity index 97%
rename from arm/ecc-192-modp.asm
rename to arm/ecc-secp192r1-modp.asm
index b6074a2e05e9..dbaae2e38922 100644
--- a/arm/ecc-192-modp.asm
+++ b/arm/ecc-secp192r1-modp.asm
@@ -1,4 +1,4 @@
-C arm/ecc-192-modp.asm
+C arm/ecc-secp192r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;) 
 
-	.file "ecc-192-modp.asm"
+	.file "ecc-secp192r1-modp.asm"
 	.arm
 
 define(&lt;HP&gt;, &lt;r0&gt;) C Overlaps unused modulo argument
diff --git a/arm/ecc-224-modp.asm b/arm/ecc-secp224r1-modp.asm
similarity index 97%
rename from arm/ecc-224-modp.asm
rename to arm/ecc-secp224r1-modp.asm
index 15cc0c1b0f26..2c86755a7c9a 100644
--- a/arm/ecc-224-modp.asm
+++ b/arm/ecc-secp224r1-modp.asm
@@ -1,4 +1,4 @@
-C arm/ecc-224-modp.asm
+C arm/ecc-secp224r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;) 
 
-	.file "ecc-224-modp.asm"
+	.file "ecc-secp224r1-modp.asm"
 	.arm
 
 define(&lt;RP&gt;, &lt;r1&gt;)
diff --git a/arm/ecc-256-redc.asm b/arm/ecc-secp256r1-redc.asm
similarity index 98%
rename from arm/ecc-256-redc.asm
rename to arm/ecc-secp256r1-redc.asm
index 0c5e846d5890..9c20062a44e4 100644
--- a/arm/ecc-256-redc.asm
+++ b/arm/ecc-secp256r1-redc.asm
@@ -1,4 +1,4 @@
-C arm/ecc-256-redc.asm
+C arm/ecc-secp256r1-redc.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;) 
 
-	.file "ecc-256-redc.asm"
+	.file "ecc-secp256r1-redc.asm"
 	.arm
 
 define(&lt;RP&gt;, &lt;r1&gt;)
diff --git a/arm/ecc-384-modp.asm b/arm/ecc-secp384r1-modp.asm
similarity index 98%
rename from arm/ecc-384-modp.asm
rename to arm/ecc-secp384r1-modp.asm
index 1d36319d584d..dbedbdf8d32e 100644
--- a/arm/ecc-384-modp.asm
+++ b/arm/ecc-secp384r1-modp.asm
@@ -1,4 +1,4 @@
-C arm/ecc-384-modp.asm
+C arm/ecc-secp384r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;) 
 
-	.file "ecc-384-modp.asm"
+	.file "ecc-secp384r1-modp.asm"
 	.arm
 
 define(&lt;RP&gt;, &lt;r1&gt;)
diff --git a/arm/ecc-521-modp.asm b/arm/ecc-secp521r1-modp.asm
similarity index 97%
rename from arm/ecc-521-modp.asm
rename to arm/ecc-secp521r1-modp.asm
index 3fba23963d2c..2b4f79192a2e 100644
--- a/arm/ecc-521-modp.asm
+++ b/arm/ecc-secp521r1-modp.asm
@@ -1,4 +1,4 @@
-C arm/ecc-521-modp.asm
+C arm/ecc-secp521r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;) 
 
-	.file "ecc-521-modp.asm"
+	.file "ecc-secp521r1-modp.asm"
 	.arm
 
 define(&lt;HP&gt;, &lt;r0&gt;)
diff --git a/configure.ac b/configure.ac
index ef0c819fb979..745cc2c5c20e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -475,9 +475,9 @@ asm_nettle_optional_list="gcm-hash8.asm cpuid.asm \
 
 asm_hogweed_optional_list=""
 if test "x$enable_public_key" = "xyes" ; then
-  asm_hogweed_optional_list="ecc-192-modp.asm ecc-224-modp.asm \
-    ecc-256-redc.asm ecc-384-modp.asm ecc-521-modp.asm \
-    ecc-25519-modp.asm ecc-curve448-modp.asm"
+  asm_hogweed_optional_list="ecc-secp192r1-modp.asm ecc-secp224r1-modp.asm \
+    ecc-secp256r1-redc.asm ecc-secp384r1-modp.asm ecc-secp521r1-modp.asm \
+    ecc-curve25519-modp.asm ecc-curve448-modp.asm"
 fi
 
 OPT_NETTLE_OBJS=""
diff --git a/ecc-25519.c b/ecc-curve25519.c
similarity index 99%
rename from ecc-25519.c
rename to ecc-curve25519.c
index 105ce0f4fbc1..e6a1b325be66 100644
--- a/ecc-25519.c
+++ b/ecc-curve25519.c
@@ -1,4 +1,4 @@
-/* ecc-25519.c
+/* ecc-curve25519.c
 
    Arithmetic and tables for curve25519,
 
@@ -42,7 +42,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-25519.h"
+#include "ecc-curve25519.h"
 
 #define PHIGH_BITS (GMP_NUMB_BITS * ECC_LIMB_SIZE - 255)
 
diff --git a/ecc-448.c b/ecc-curve448.c
similarity index 99%
rename from ecc-448.c
rename to ecc-curve448.c
index 429bb8ffd722..fce8b1ac0382 100644
--- a/ecc-448.c
+++ b/ecc-curve448.c
@@ -1,4 +1,4 @@
-/* ecc-448.c
+/* ecc-curve448.c
 
    Arithmetic and tables for curve448,
 
@@ -43,7 +43,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-448.h"
+#include "ecc-curve448.h"
 
 #if HAVE_NATIVE_ecc_curve448_modp
 #define ecc_448_modp nettle_ecc_curve448_modp
diff --git a/ecc-192.c b/ecc-secp192r1.c
similarity index 98%
rename from ecc-192.c
rename to ecc-secp192r1.c
index 4b756ffd7e8f..858a1b7554ce 100644
--- a/ecc-192.c
+++ b/ecc-secp192r1.c
@@ -1,4 +1,4 @@
-/* ecc-192.c
+/* ecc-secp192r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -46,7 +46,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-192.h"
+#include "ecc-secp192r1.h"
 
 #if HAVE_NATIVE_ecc_192_modp
 
diff --git a/ecc-224.c b/ecc-secp224r1.c
similarity index 98%
rename from ecc-224.c
rename to ecc-secp224r1.c
index bf90f848c1b2..4d82f54b57fd 100644
--- a/ecc-224.c
+++ b/ecc-secp224r1.c
@@ -1,4 +1,4 @@
-/* ecc-224.c
+/* ecc-secp224r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -52,7 +52,7 @@ ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #define ecc_224_modp ecc_mod
 #endif
 
-#include "ecc-224.h"
+#include "ecc-secp224r1.h"
 
 #if ECC_REDC_SIZE &lt; 0
 # define ecc_224_redc ecc_pm1_redc
diff --git a/ecc-256.c b/ecc-secp256r1.c
similarity index 99%
rename from ecc-256.c
rename to ecc-secp256r1.c
index 3e6ae4e2a8b6..7b873b5f7724 100644
--- a/ecc-256.c
+++ b/ecc-secp256r1.c
@@ -1,4 +1,4 @@
-/* ecc-256.c
+/* ecc-secp256r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -48,7 +48,7 @@
 # define USE_REDC (ECC_REDC_SIZE != 0)
 #endif
 
-#include "ecc-256.h"
+#include "ecc-secp256r1.h"
 
 #if HAVE_NATIVE_ecc_256_redc
 # define ecc_256_redc nettle_ecc_256_redc
diff --git a/ecc-384.c b/ecc-secp384r1.c
similarity index 99%
rename from ecc-384.c
rename to ecc-secp384r1.c
index 5bb2a2476eec..248b1cf3ef2b 100644
--- a/ecc-384.c
+++ b/ecc-secp384r1.c
@@ -1,4 +1,4 @@
-/* ecc-384.c
+/* ecc-secp384r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -44,7 +44,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-384.h"
+#include "ecc-secp384r1.h"
 
 #if HAVE_NATIVE_ecc_384_modp
 #define ecc_384_modp nettle_ecc_384_modp
diff --git a/ecc-521.c b/ecc-secp521r1.c
similarity index 98%
rename from ecc-521.c
rename to ecc-secp521r1.c
index 8ca0e6d2dd64..cc7473035cff 100644
--- a/ecc-521.c
+++ b/ecc-secp521r1.c
@@ -1,4 +1,4 @@
-/* ecc-521.c
+/* ecc-secp521r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -42,7 +42,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-521.h"
+#include "ecc-secp521r1.h"
 
 #if HAVE_NATIVE_ecc_521_modp
 #define ecc_521_modp nettle_ecc_521_modp
diff --git a/eccdata.c b/eccdata.c
index 74002c1f305e..d76a42bcde6f 100644
--- a/eccdata.c
+++ b/eccdata.c
@@ -432,11 +432,10 @@ ecc_curve_init_str (struct ecc_curve *ecc, enum ecc_type type,
 }
 
 static void
-ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
+ecc_curve_init (struct ecc_curve *ecc, const char *curve)
 {
-  switch (bit_size)
+  if (!strcmp (curve, "secp192r1"))
     {
-    case 192:      
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{192} - 2^{64} - 1 */
 			  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE"
@@ -466,8 +465,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "35433907297cc378b0015703374729d7a4fe46647084e4ba",
 		   "a2649984f2135c301ea3acb0776cd4f125389b311db3be32");
 
-      break;
-    case 224:
+    }
+  else if (!strcmp (curve, "secp224r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{224} - 2^{96} + 1 */
 			  "ffffffffffffffffffffffffffffffff"
@@ -498,8 +498,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "ae99feebb5d26945b54892092a8aee02912930fa41cd114e40447301",
 		   "482580a0ec5bc47e88bc8c378632cd196cb3fa058a7114eb03054c9");
 
-      break;
-    case 256:
+    }
+  else if (!strcmp (curve, "secp256r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{256} - 2^{224} + 2^{192} + 2^{96} - 1 */
 			  "FFFFFFFF000000010000000000000000"
@@ -530,8 +531,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "e2534a3532d08fbba02dde659ee62bd0031fe2db785596ef509302446b030852",
 		   "e0f1575a4c633cc719dfee5fda862d764efc96c3f30ee0055c42c23f184ed8c6");
 
-      break;
-    case 384:
+    }
+  else if (!strcmp (curve, "secp384r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{384} - 2^{128} - 2^{96} + 2^{32} - 1 */
 			  "ffffffffffffffffffffffffffffffff"
@@ -567,8 +569,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "138251cd52ac9298c1c8aad977321deb97e709bd0b4ca0aca55dc8ad51dcfc9d1589a1597e3a5120e1efd631c63e1835",
                
 		   "cacae29869a62e1631e8a28181ab56616dc45d918abc09f3ab0e63cf792aa4dced7387be37bba569549f1c02b270ed67");
  
-      break;
-    case 521:
+    }
+  else if (!strcmp (curve, "secp521r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  "1ff" /* p = 2^{521} - 1 */
 			  "ffffffffffffffffffffffffffffffff"
@@ -613,9 +616,15 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "35b5df64ae2ac204c354b483487c9070cdc61c891c5ff39afc06c5d55541d3ceac8659e24afe3d0750e8b88e9f078af066a1d5025b08e5a5e2fbc87412871902f3",
                
 		   "82096f84261279d2b673e0178eb0b4abb65521aef6e6e32e1b5ae63fe2f19907f279f283e54ba385405224f750a95b85eebb7faef04699d1d9e21f47fc346e4d0d");
  
-      break;
-    case 255:
-      /* Edwards curve used for eddsa25519 and curve25519,
+    }
+  else if (!strcmp (curve, "curve25519"))
+    {
+      /* curve25519, y^2 = x^3 + 486662 x^2 + x (mod p), with p = 2^{255} - 19.
+
+	 According to http://cr.yp.to/papers.html#newelliptic, this
+	 is birationally equivalent to the Edwards curve
+
+	   x^2 + y^2 = 1 + (121665/121666) x^2 y^2 (mod p).
 
 	   -x^2 + y^2 = 1 - (121665/121666) x^2 y^2, with p = 2^{255} - 19.
 
@@ -664,9 +673,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "1a739ec193ce1547493aa657c4c9f870",
 		   "47d0e827cb1595e1470eb88580d5716c"
 		   "4cf22832ea2f0ff0df38ab61ca32112f");
-      break;
-
-    case 448:
+    }
+  else if (!strcmp (curve, "curve448"))
+    {
       /* curve448, y^2 = x^3 + 156326 x^2 + x (mod p), with p = 2^{448} - 2^{224} - \
1.  
 	 According to RFC 7748, this is 4-isogenious to the Edwards
@@ -745,14 +754,13 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "9cb7c02f0457d845c90dc3227b8a5bc1"
 		   "c0d8f97ea1ca9472b5d444285d0d4f5b"
 		   "32e236f86de51839");
-
-      break;
-
-    default:
-      fprintf (stderr, "No known curve for size %d\n", bit_size);
-      exit(EXIT_FAILURE);     
     }
-  ecc-&gt;bit_size = bit_size;
+  else
+    {
+      fprintf (stderr, "No known curve with name %s\n", curve);
+      exit(EXIT_FAILURE);
+    }
+  ecc-&gt;bit_size = mpz_sizeinbase (ecc-&gt;p, 2);
 }
 
 static void
@@ -1312,7 +1320,7 @@ main (int argc, char **argv)
       return EXIT_FAILURE;
     }
 
-  ecc_curve_init (&amp;ecc, atoi(argv[1]));
+  ecc_curve_init (&amp;ecc, argv[1]);
 
   ecc_pippenger_precompute (&amp;ecc, atoi(argv[2]), atoi(argv[3]));
 
diff --git a/x86_64/ecc-25519-modp.asm b/x86_64/ecc-curve25519-modp.asm
similarity index 100%
rename from x86_64/ecc-25519-modp.asm
rename to x86_64/ecc-curve25519-modp.asm
diff --git a/x86_64/ecc-192-modp.asm b/x86_64/ecc-secp192r1-modp.asm
similarity index 96%
rename from x86_64/ecc-192-modp.asm
rename to x86_64/ecc-secp192r1-modp.asm
index f0660525e0e1..644ed60c6fab 100644
--- a/x86_64/ecc-192-modp.asm
+++ b/x86_64/ecc-secp192r1-modp.asm
@@ -1,4 +1,4 @@
-C x86_64/ecc-192-modp.asm
+C x86_64/ecc-secp192r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;)
 
-	.file "ecc-192-modp.asm"
+	.file "ecc-secp192r1-modp.asm"
 
 define(&lt;RP&gt;, &lt;%rsi&gt;)
 define(&lt;T0&gt;, &lt;%rdi&gt;) C Overlaps unused modulo input
diff --git a/x86_64/ecc-224-modp.asm b/x86_64/ecc-secp224r1-modp.asm
similarity index 97%
rename from x86_64/ecc-224-modp.asm
rename to x86_64/ecc-secp224r1-modp.asm
index 07bd40036705..ca164ac7d637 100644
--- a/x86_64/ecc-224-modp.asm
+++ b/x86_64/ecc-secp224r1-modp.asm
@@ -1,4 +1,4 @@
-C x86_64/ecc-224-modp.asm
+C x86_64/ecc-secp224r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;)
 
-	.file "ecc-224-modp.asm"
+	.file "ecc-secp224r1-modp.asm"
 
 GMP_NUMB_BITS(64)
 
diff --git a/x86_64/ecc-256-redc.asm b/x86_64/ecc-secp256r1-redc.asm
similarity index 97%
rename from x86_64/ecc-256-redc.asm
rename to x86_64/ecc-secp256r1-redc.asm
index fb1633541218..ee689cd6d192 100644
--- a/x86_64/ecc-256-redc.asm
+++ b/x86_64/ecc-secp256r1-redc.asm
@@ -1,4 +1,4 @@
-C x86_64/ecc-256-redc.asm
+C x86_64/ecc-secp256r1-redc.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;)
 
-	.file "ecc-256-redc.asm"
+	.file "ecc-secp256r1-redc.asm"
 
 define(&lt;RP&gt;, &lt;%rsi&gt;)
 define(&lt;U0&gt;, &lt;%rdi&gt;) C Overlaps unused modulo input
diff --git a/x86_64/ecc-384-modp.asm b/x86_64/ecc-secp384r1-modp.asm
similarity index 98%
rename from x86_64/ecc-384-modp.asm
rename to x86_64/ecc-secp384r1-modp.asm
index 8e55393f802f..3c8ec3f446c0 100644
--- a/x86_64/ecc-384-modp.asm
+++ b/x86_64/ecc-secp384r1-modp.asm
@@ -1,4 +1,4 @@
-C x86_64/ecc-384-modp.asm
+C x86_64/ecc-secp384r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013, 2015 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;)
 
-	.file "ecc-384-modp.asm"
+	.file "ecc-secp384r1-modp.asm"
 
 define(&lt;RP&gt;, &lt;%rsi&gt;)
 define(&lt;D5&gt;, &lt;%rax&gt;)
diff --git a/x86_64/ecc-521-modp.asm b/x86_64/ecc-secp521r1-modp.asm
similarity index 97%
rename from x86_64/ecc-521-modp.asm
rename to x86_64/ecc-secp521r1-modp.asm
index 6e818ad81d41..43a8cb8c9cfe 100644
--- a/x86_64/ecc-521-modp.asm
+++ b/x86_64/ecc-secp521r1-modp.asm
@@ -1,4 +1,4 @@
-C x86_64/ecc-521-modp.asm
+C x86_64/ecc-secp521r1-modp.asm
 
 ifelse(&lt;
    Copyright (C) 2013 Niels Möller
@@ -30,7 +30,7 @@ ifelse(&lt;
    not, see http://www.gnu.org/licenses/.
 &gt;)
 
-	.file "ecc-521-modp.asm"
+	.file "ecc-secp521r1-modp.asm"
 
 GMP_NUMB_BITS(64)
 
-- 
2.24.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20191218121652</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-12-18 12:16:52-0400</timestampReceived><subject>[PATCH v2 2/3] ecc: prefix optimized ECC function names with underscore</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

There is no need to keep optimized ECC functions in public namespace
(nettle_*), move them to internal namespace (_nettle_*).

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 arm/ecc-secp192r1-modp.asm     | 4 ++--
 arm/ecc-secp224r1-modp.asm     | 4 ++--
 arm/ecc-secp256r1-redc.asm     | 4 ++--
 arm/ecc-secp384r1-modp.asm     | 4 ++--
 arm/ecc-secp521r1-modp.asm     | 4 ++--
 ecc-curve25519.c               | 2 +-
 ecc-curve448.c                 | 2 +-
 ecc-secp192r1.c                | 2 +-
 ecc-secp224r1.c                | 2 +-
 ecc-secp256r1.c                | 2 +-
 ecc-secp384r1.c                | 2 +-
 ecc-secp521r1.c                | 2 +-
 x86_64/ecc-curve25519-modp.asm | 4 ++--
 x86_64/ecc-curve448-modp.asm   | 4 ++--
 x86_64/ecc-secp192r1-modp.asm  | 4 ++--
 x86_64/ecc-secp224r1-modp.asm  | 4 ++--
 x86_64/ecc-secp256r1-redc.asm  | 4 ++--
 x86_64/ecc-secp384r1-modp.asm  | 4 ++--
 x86_64/ecc-secp521r1-modp.asm  | 4 ++--
 19 files changed, 31 insertions(+), 31 deletions(-)

diff --git a/arm/ecc-secp192r1-modp.asm b/arm/ecc-secp192r1-modp.asm
index dbaae2e38922..4680336f1bc7 100644
--- a/arm/ecc-secp192r1-modp.asm
+++ b/arm/ecc-secp192r1-modp.asm
@@ -53,7 +53,7 @@ define(&lt;C4&gt;, &lt;r12&gt;)
 	.text
 	.align 2
 
-PROLOGUE(nettle_ecc_192_modp)
+PROLOGUE(_nettle_ecc_192_modp)
 	push	{r4,r5,r6,r7,r8,r10}
 	C Reduce two words at a time
 	add	HP, RP, #48
@@ -103,4 +103,4 @@ PROLOGUE(nettle_ecc_192_modp)
 
 	pop	{r4,r5,r6,r7,r8,r10}
 	bx	lr
-EPILOGUE(nettle_ecc_192_modp)
+EPILOGUE(_nettle_ecc_192_modp)
diff --git a/arm/ecc-secp224r1-modp.asm b/arm/ecc-secp224r1-modp.asm
index 2c86755a7c9a..400b7a815c2c 100644
--- a/arm/ecc-secp224r1-modp.asm
+++ b/arm/ecc-secp224r1-modp.asm
@@ -52,7 +52,7 @@ define(&lt;L2&gt;, &lt;lr&gt;)
 	.text
 	.align 2
 
-PROLOGUE(nettle_ecc_224_modp)
+PROLOGUE(_nettle_ecc_224_modp)
 	push	{r4,r5,r6,r7,r8,r10,r11,lr}
 
 	add	L2, RP, #28
@@ -121,4 +121,4 @@ PROLOGUE(nettle_ecc_224_modp)
 	stmdb	RP, {T0,T1,T2,T3,T4,T5,T6}
 
 	pop	{r4,r5,r6,r7,r8,r10,r11,pc}
-EPILOGUE(nettle_ecc_224_modp)
+EPILOGUE(_nettle_ecc_224_modp)
diff --git a/arm/ecc-secp256r1-redc.asm b/arm/ecc-secp256r1-redc.asm
index 9c20062a44e4..7b117de43fbc 100644
--- a/arm/ecc-secp256r1-redc.asm
+++ b/arm/ecc-secp256r1-redc.asm
@@ -52,7 +52,7 @@ define(&lt;F3&gt;, &lt;lr&gt;)
 	.text
 	.align 2
 
-PROLOGUE(nettle_ecc_256_redc)
+PROLOGUE(_nettle_ecc_256_redc)
 	push	{r4,r5,r6,r7,r8,r10,r11,lr}
 
 	ldm	RP!, {T0,T1,T2,T3,T4,T5,T6,T7}
@@ -170,4 +170,4 @@ PROLOGUE(nettle_ecc_256_redc)
 	stm	RP, {T0,T1,T2,T3,T4,T5,T6,T7}
 
 	pop	{r4,r5,r6,r7,r8,r10,r11,pc}
-EPILOGUE(nettle_ecc_256_redc)
+EPILOGUE(_nettle_ecc_256_redc)
diff --git a/arm/ecc-secp384r1-modp.asm b/arm/ecc-secp384r1-modp.asm
index dbedbdf8d32e..dd9a325b09de 100644
--- a/arm/ecc-secp384r1-modp.asm
+++ b/arm/ecc-secp384r1-modp.asm
@@ -50,7 +50,7 @@ define(&lt;H&gt;, &lt;lr&gt;)
 	.text
 	.align 2
 
-PROLOGUE(nettle_ecc_384_modp)
+PROLOGUE(_nettle_ecc_384_modp)
 	push	{r4,r5,r6,r7,r8,r10,lr}
 
 	add	RP, RP, #80
@@ -267,4 +267,4 @@ PROLOGUE(nettle_ecc_384_modp)
 	adcs	T3, T3, H
 	stm	RP!, {T0,T1,T2,T3}	C 8-11
 	pop	{r4,r5,r6,r7,r8,r10,pc}
-EPILOGUE(nettle_ecc_384_modp)
+EPILOGUE(_nettle_ecc_384_modp)
diff --git a/arm/ecc-secp521r1-modp.asm b/arm/ecc-secp521r1-modp.asm
index 2b4f79192a2e..f11967634689 100644
--- a/arm/ecc-secp521r1-modp.asm
+++ b/arm/ecc-secp521r1-modp.asm
@@ -52,7 +52,7 @@ define(&lt;N&gt;, &lt;lr&gt;)
 
 	.align 2
 
-PROLOGUE(nettle_ecc_521_modp)
+PROLOGUE(_nettle_ecc_521_modp)
 	push	{r4,r5,r6,r7,r8,lr}
 
 	C Use that B^17 = 2^23 (mod p)
@@ -124,4 +124,4 @@ PROLOGUE(nettle_ecc_521_modp)
 	stm	RP, {T0,T1,T2,F0,F1,F2,F3,H}	C 9-16
 
 	pop	{r4,r5,r6,r7,r8,pc}
-EPILOGUE(nettle_ecc_521_modp)
+EPILOGUE(_nettle_ecc_521_modp)
diff --git a/ecc-curve25519.c b/ecc-curve25519.c
index e6a1b325be66..1045db7092ae 100644
--- a/ecc-curve25519.c
+++ b/ecc-curve25519.c
@@ -48,7 +48,7 @@
 
 #if HAVE_NATIVE_ecc_25519_modp
 
-#define ecc_25519_modp nettle_ecc_25519_modp
+#define ecc_25519_modp _nettle_ecc_25519_modp
 void
 ecc_25519_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #else
diff --git a/ecc-curve448.c b/ecc-curve448.c
index fce8b1ac0382..e1318ca4f01d 100644
--- a/ecc-curve448.c
+++ b/ecc-curve448.c
@@ -46,7 +46,7 @@
 #include "ecc-curve448.h"
 
 #if HAVE_NATIVE_ecc_curve448_modp
-#define ecc_448_modp nettle_ecc_curve448_modp
+#define ecc_448_modp _nettle_ecc_curve448_modp
 void
 ecc_448_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #elif GMP_NUMB_BITS == 64
diff --git a/ecc-secp192r1.c b/ecc-secp192r1.c
index 858a1b7554ce..15f5f1fa4c04 100644
--- a/ecc-secp192r1.c
+++ b/ecc-secp192r1.c
@@ -50,7 +50,7 @@
 
 #if HAVE_NATIVE_ecc_192_modp
 
-#define ecc_192_modp nettle_ecc_192_modp
+#define ecc_192_modp _nettle_ecc_192_modp
 void
 ecc_192_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 
diff --git a/ecc-secp224r1.c b/ecc-secp224r1.c
index 4d82f54b57fd..28b938fa3282 100644
--- a/ecc-secp224r1.c
+++ b/ecc-secp224r1.c
@@ -43,7 +43,7 @@
 #if HAVE_NATIVE_ecc_224_modp
 
 #define USE_REDC 0
-#define ecc_224_modp nettle_ecc_224_modp
+#define ecc_224_modp _nettle_ecc_224_modp
 void
 ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 
diff --git a/ecc-secp256r1.c b/ecc-secp256r1.c
index 7b873b5f7724..ed463edf7729 100644
--- a/ecc-secp256r1.c
+++ b/ecc-secp256r1.c
@@ -51,7 +51,7 @@
 #include "ecc-secp256r1.h"
 
 #if HAVE_NATIVE_ecc_256_redc
-# define ecc_256_redc nettle_ecc_256_redc
+# define ecc_256_redc _nettle_ecc_256_redc
 void
 ecc_256_redc (const struct ecc_modulo *p, mp_limb_t *rp);
 #else /* !HAVE_NATIVE_ecc_256_redc */
diff --git a/ecc-secp384r1.c b/ecc-secp384r1.c
index 248b1cf3ef2b..32f75fb618ba 100644
--- a/ecc-secp384r1.c
+++ b/ecc-secp384r1.c
@@ -47,7 +47,7 @@
 #include "ecc-secp384r1.h"
 
 #if HAVE_NATIVE_ecc_384_modp
-#define ecc_384_modp nettle_ecc_384_modp
+#define ecc_384_modp _nettle_ecc_384_modp
 void
 ecc_384_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #elif GMP_NUMB_BITS == 32
diff --git a/ecc-secp521r1.c b/ecc-secp521r1.c
index cc7473035cff..d952d77e444e 100644
--- a/ecc-secp521r1.c
+++ b/ecc-secp521r1.c
@@ -45,7 +45,7 @@
 #include "ecc-secp521r1.h"
 
 #if HAVE_NATIVE_ecc_521_modp
-#define ecc_521_modp nettle_ecc_521_modp
+#define ecc_521_modp _nettle_ecc_521_modp
 void
 ecc_521_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 
diff --git a/x86_64/ecc-curve25519-modp.asm b/x86_64/ecc-curve25519-modp.asm
index 58c14fe0958e..0374db12ab44 100644
--- a/x86_64/ecc-curve25519-modp.asm
+++ b/x86_64/ecc-curve25519-modp.asm
@@ -41,7 +41,7 @@ define(&lt;T0&gt;, &lt;%r10&gt;)
 define(&lt;T1&gt;, &lt;%r11&gt;)
 define(&lt;M&gt;, &lt;%rbx&gt;)
 
-PROLOGUE(nettle_ecc_25519_modp)
+PROLOGUE(_nettle_ecc_25519_modp)
 	W64_ENTRY(2, 0)
 	push	%rbx
 
@@ -91,4 +91,4 @@ PROLOGUE(nettle_ecc_25519_modp)
 	pop	%rbx
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(nettle_ecc_25519_modp)
+EPILOGUE(_nettle_ecc_25519_modp)
diff --git a/x86_64/ecc-curve448-modp.asm b/x86_64/ecc-curve448-modp.asm
index 1ca05a190e1a..ea2e78861bc5 100644
--- a/x86_64/ecc-curve448-modp.asm
+++ b/x86_64/ecc-curve448-modp.asm
@@ -45,7 +45,7 @@ define(&lt;T0&gt;, &lt;%r10&gt;)
 define(&lt;T1&gt;, &lt;%r11&gt;)
 define(&lt;T2&gt;, &lt;%r12&gt;)
 
-PROLOGUE(nettle_ecc_curve448_modp)
+PROLOGUE(_nettle_ecc_curve448_modp)
 	W64_ENTRY(2, 0)
 
 	push	%rbx
@@ -141,4 +141,4 @@ PROLOGUE(nettle_ecc_curve448_modp)
 
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(nettle_ecc_curve448_modp)
+EPILOGUE(_nettle_ecc_curve448_modp)
diff --git a/x86_64/ecc-secp192r1-modp.asm b/x86_64/ecc-secp192r1-modp.asm
index 644ed60c6fab..ad8dca7186e4 100644
--- a/x86_64/ecc-secp192r1-modp.asm
+++ b/x86_64/ecc-secp192r1-modp.asm
@@ -44,7 +44,7 @@ define(&lt;C2&gt;, &lt;%r11&gt;)
 	C ecc_192_modp (const struct ecc_modulo *m, mp_limb_t *rp)
 	.text
 	ALIGN(16)
-PROLOGUE(nettle_ecc_192_modp)
+PROLOGUE(_nettle_ecc_192_modp)
 	W64_ENTRY(2, 0)
 	mov	16(RP), T2
 	mov	24(RP), T3
@@ -85,4 +85,4 @@ PROLOGUE(nettle_ecc_192_modp)
 
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(nettle_ecc_192_modp)
+EPILOGUE(_nettle_ecc_192_modp)
diff --git a/x86_64/ecc-secp224r1-modp.asm b/x86_64/ecc-secp224r1-modp.asm
index ca164ac7d637..e44b5418e5dd 100644
--- a/x86_64/ecc-secp224r1-modp.asm
+++ b/x86_64/ecc-secp224r1-modp.asm
@@ -45,7 +45,7 @@ define(&lt;F1&gt;, &lt;%r10&gt;)
 define(&lt;F2&gt;, &lt;%r11&gt;)
 
 	C ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp)
-PROLOGUE(nettle_ecc_224_modp)
+PROLOGUE(_nettle_ecc_224_modp)
 	W64_ENTRY(2, 0)
 	mov	48(RP), H0
 	mov	56(RP), H1
@@ -128,4 +128,4 @@ PROLOGUE(nettle_ecc_224_modp)
 
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(nettle_ecc_224_modp)
+EPILOGUE(_nettle_ecc_224_modp)
diff --git a/x86_64/ecc-secp256r1-redc.asm b/x86_64/ecc-secp256r1-redc.asm
index ee689cd6d192..533a1766d4bc 100644
--- a/x86_64/ecc-secp256r1-redc.asm
+++ b/x86_64/ecc-secp256r1-redc.asm
@@ -58,7 +58,7 @@ define(&lt;FOLD&gt;, &lt;
 	sbb	$1, F2
 	sbb	&lt;$&gt;0, F3
 &gt;)
-PROLOGUE(nettle_ecc_256_redc)
+PROLOGUE(_nettle_ecc_256_redc)
 	W64_ENTRY(2, 0)
 	C save all registers that need to be saved
 	push	%rbx
@@ -126,4 +126,4 @@ PROLOGUE(nettle_ecc_256_redc)
 	pop	%rbx
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(nettle_ecc_256_redc)
+EPILOGUE(_nettle_ecc_256_redc)
diff --git a/x86_64/ecc-secp384r1-modp.asm b/x86_64/ecc-secp384r1-modp.asm
index 3c8ec3f446c0..13f469b164e4 100644
--- a/x86_64/ecc-secp384r1-modp.asm
+++ b/x86_64/ecc-secp384r1-modp.asm
@@ -51,7 +51,7 @@ define(&lt;C0&gt;, H5)	C Overlap
 define(&lt;TMP&gt;, RP)	C Overlap
 
 
-PROLOGUE(nettle_ecc_384_modp)
+PROLOGUE(_nettle_ecc_384_modp)
 	W64_ENTRY(2, 0)
 
 	push	%rbx
@@ -231,4 +231,4 @@ PROLOGUE(nettle_ecc_384_modp)
 
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(nettle_ecc_384_modp)
+EPILOGUE(_nettle_ecc_384_modp)
diff --git a/x86_64/ecc-secp521r1-modp.asm b/x86_64/ecc-secp521r1-modp.asm
index 43a8cb8c9cfe..6f4f7d90714d 100644
--- a/x86_64/ecc-secp521r1-modp.asm
+++ b/x86_64/ecc-secp521r1-modp.asm
@@ -48,7 +48,7 @@ define(&lt;U9&gt;, &lt;%r11&gt;)
 define(&lt;T0&gt;, &lt;%r12&gt;)
 define(&lt;T1&gt;, &lt;%r13&gt;)
 
-PROLOGUE(nettle_ecc_521_modp)
+PROLOGUE(_nettle_ecc_521_modp)
 	W64_ENTRY(2, 0)
 	push	%rbx
 	push	%rbp
@@ -155,4 +155,4 @@ PROLOGUE(nettle_ecc_521_modp)
 	pop	%rbx
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(nettle_ecc_521_modp)
+EPILOGUE(_nettle_ecc_521_modp)
-- 
2.24.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191218121653</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-12-18 12:16:53-0400</timestampReceived><subject>[PATCH v2 3/3] ecc: rename functions to contain curve names instead of bits</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Rename curve functions to use curve names instead of just bits.
Otherwise function names can easily become confusing after adding other
curves.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 arm/ecc-secp192r1-modp.asm     |  6 +++---
 arm/ecc-secp224r1-modp.asm     |  6 +++---
 arm/ecc-secp256r1-redc.asm     |  6 +++---
 arm/ecc-secp384r1-modp.asm     |  6 +++---
 arm/ecc-secp521r1-modp.asm     |  6 +++---
 configure.ac                   | 22 +++++++++++-----------
 ecc-curve25519.c               | 34 +++++++++++++++++-----------------
 ecc-curve448.c                 | 24 ++++++++++++------------
 ecc-secp192r1.c                | 16 ++++++++--------
 ecc-secp224r1.c                | 16 ++++++++--------
 ecc-secp256r1.c                | 32 ++++++++++++++++----------------
 ecc-secp384r1.c                | 16 ++++++++--------
 ecc-secp521r1.c                | 12 ++++++------
 eddsa-sign.c                   |  2 +-
 x86_64/ecc-curve25519-modp.asm |  4 ++--
 x86_64/ecc-secp192r1-modp.asm  |  6 +++---
 x86_64/ecc-secp224r1-modp.asm  |  6 +++---
 x86_64/ecc-secp256r1-redc.asm  |  4 ++--
 x86_64/ecc-secp384r1-modp.asm  |  4 ++--
 x86_64/ecc-secp521r1-modp.asm  |  4 ++--
 20 files changed, 116 insertions(+), 116 deletions(-)

diff --git a/arm/ecc-secp192r1-modp.asm b/arm/ecc-secp192r1-modp.asm
index 4680336f1bc7..4c596a168b3d 100644
--- a/arm/ecc-secp192r1-modp.asm
+++ b/arm/ecc-secp192r1-modp.asm
@@ -49,11 +49,11 @@ define(&lt;H1&gt;, &lt;T1&gt;)
 define(&lt;C2&gt;, &lt;HP&gt;)
 define(&lt;C4&gt;, &lt;r12&gt;)
 
-	C ecc_192_modp (const struct ecc_modulo *m, mp_limb_t *rp)
+	C ecc_secp192r1_modp (const struct ecc_modulo *m, mp_limb_t *rp)
 	.text
 	.align 2
 
-PROLOGUE(_nettle_ecc_192_modp)
+PROLOGUE(_nettle_ecc_secp192r1_modp)
 	push	{r4,r5,r6,r7,r8,r10}
 	C Reduce two words at a time
 	add	HP, RP, #48
@@ -103,4 +103,4 @@ PROLOGUE(_nettle_ecc_192_modp)
 
 	pop	{r4,r5,r6,r7,r8,r10}
 	bx	lr
-EPILOGUE(_nettle_ecc_192_modp)
+EPILOGUE(_nettle_ecc_secp192r1_modp)
diff --git a/arm/ecc-secp224r1-modp.asm b/arm/ecc-secp224r1-modp.asm
index 400b7a815c2c..67089a0c2981 100644
--- a/arm/ecc-secp224r1-modp.asm
+++ b/arm/ecc-secp224r1-modp.asm
@@ -48,11 +48,11 @@ define(&lt;L0&gt;, &lt;r11&gt;)
 define(&lt;L1&gt;, &lt;r12&gt;)
 define(&lt;L2&gt;, &lt;lr&gt;)
 
-	C ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp)
+	C ecc_secp224r1_modp (const struct ecc_modulo *m, mp_limb_t *rp)
 	.text
 	.align 2
 
-PROLOGUE(_nettle_ecc_224_modp)
+PROLOGUE(_nettle_ecc_secp224r1_modp)
 	push	{r4,r5,r6,r7,r8,r10,r11,lr}
 
 	add	L2, RP, #28
@@ -121,4 +121,4 @@ PROLOGUE(_nettle_ecc_224_modp)
 	stmdb	RP, {T0,T1,T2,T3,T4,T5,T6}
 
 	pop	{r4,r5,r6,r7,r8,r10,r11,pc}
-EPILOGUE(_nettle_ecc_224_modp)
+EPILOGUE(_nettle_ecc_secp224r1_modp)
diff --git a/arm/ecc-secp256r1-redc.asm b/arm/ecc-secp256r1-redc.asm
index 7b117de43fbc..f8386c39c9a6 100644
--- a/arm/ecc-secp256r1-redc.asm
+++ b/arm/ecc-secp256r1-redc.asm
@@ -48,11 +48,11 @@ define(&lt;F1&gt;, &lt;r11&gt;)
 define(&lt;F2&gt;, &lt;r12&gt;)
 define(&lt;F3&gt;, &lt;lr&gt;)
 
-	C ecc_256_redc (const struct ecc_modulo *m, mp_limb_t *rp)
+	C ecc_secp256r1_redc (const struct ecc_modulo *m, mp_limb_t *rp)
 	.text
 	.align 2
 
-PROLOGUE(_nettle_ecc_256_redc)
+PROLOGUE(_nettle_ecc_secp256r1_redc)
 	push	{r4,r5,r6,r7,r8,r10,r11,lr}
 
 	ldm	RP!, {T0,T1,T2,T3,T4,T5,T6,T7}
@@ -170,4 +170,4 @@ PROLOGUE(_nettle_ecc_256_redc)
 	stm	RP, {T0,T1,T2,T3,T4,T5,T6,T7}
 
 	pop	{r4,r5,r6,r7,r8,r10,r11,pc}
-EPILOGUE(_nettle_ecc_256_redc)
+EPILOGUE(_nettle_ecc_secp256r1_redc)
diff --git a/arm/ecc-secp384r1-modp.asm b/arm/ecc-secp384r1-modp.asm
index dd9a325b09de..1983ee68cdd4 100644
--- a/arm/ecc-secp384r1-modp.asm
+++ b/arm/ecc-secp384r1-modp.asm
@@ -46,11 +46,11 @@ define(&lt;F4&gt;, &lt;r10&gt;)
 define(&lt;N&gt;, &lt;r12&gt;)
 define(&lt;H&gt;, &lt;lr&gt;)
 	
-	C ecc_384_modp (const struct ecc_modulo *m, mp_limb_t *rp)
+	C ecc_secp384r1_modp (const struct ecc_modulo *m, mp_limb_t *rp)
 	.text
 	.align 2
 
-PROLOGUE(_nettle_ecc_384_modp)
+PROLOGUE(_nettle_ecc_secp384r1_modp)
 	push	{r4,r5,r6,r7,r8,r10,lr}
 
 	add	RP, RP, #80
@@ -267,4 +267,4 @@ PROLOGUE(_nettle_ecc_384_modp)
 	adcs	T3, T3, H
 	stm	RP!, {T0,T1,T2,T3}	C 8-11
 	pop	{r4,r5,r6,r7,r8,r10,pc}
-EPILOGUE(_nettle_ecc_384_modp)
+EPILOGUE(_nettle_ecc_secp384r1_modp)
diff --git a/arm/ecc-secp521r1-modp.asm b/arm/ecc-secp521r1-modp.asm
index f11967634689..6d1759ec8a2a 100644
--- a/arm/ecc-secp521r1-modp.asm
+++ b/arm/ecc-secp521r1-modp.asm
@@ -45,14 +45,14 @@ define(&lt;F3&gt;, &lt;r8&gt;)
 define(&lt;H&gt;, &lt;r12&gt;)
 define(&lt;N&gt;, &lt;lr&gt;)
 
-	C ecc_521_modp (const struct ecc_modulo *m, mp_limb_t *rp)
+	C ecc_secp521r1_modp (const struct ecc_modulo *m, mp_limb_t *rp)
 	.text
 .Lc511:
 	.int 511
 
 	.align 2
 
-PROLOGUE(_nettle_ecc_521_modp)
+PROLOGUE(_nettle_ecc_secp521r1_modp)
 	push	{r4,r5,r6,r7,r8,lr}
 
 	C Use that B^17 = 2^23 (mod p)
@@ -124,4 +124,4 @@ PROLOGUE(_nettle_ecc_521_modp)
 	stm	RP, {T0,T1,T2,F0,F1,F2,F3,H}	C 9-16
 
 	pop	{r4,r5,r6,r7,r8,pc}
-EPILOGUE(_nettle_ecc_521_modp)
+EPILOGUE(_nettle_ecc_secp521r1_modp)
diff --git a/configure.ac b/configure.ac
index 745cc2c5c20e..5e340d7abbd4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -572,18 +572,18 @@ AH_VERBATIM([HAVE_NATIVE],
 [/* Define to 1 each of the following for which a native (ie. CPU specific)
     implementation of the corresponding routine exists.  */
 #undef HAVE_NATIVE_chacha_core
-#undef HAVE_NATIVE_ecc_192_modp
-#undef HAVE_NATIVE_ecc_192_redc
-#undef HAVE_NATIVE_ecc_224_modp
-#undef HAVE_NATIVE_ecc_224_redc
-#undef HAVE_NATIVE_ecc_25519_modp
-#undef HAVE_NATIVE_ecc_256_modp
-#undef HAVE_NATIVE_ecc_256_redc
-#undef HAVE_NATIVE_ecc_384_modp
-#undef HAVE_NATIVE_ecc_384_redc
+#undef HAVE_NATIVE_ecc_curve25519_modp
 #undef HAVE_NATIVE_ecc_curve448_modp
-#undef HAVE_NATIVE_ecc_521_modp
-#undef HAVE_NATIVE_ecc_521_redc
+#undef HAVE_NATIVE_ecc_secp192r1_modp
+#undef HAVE_NATIVE_ecc_secp192r1_redc
+#undef HAVE_NATIVE_ecc_secp224r1_modp
+#undef HAVE_NATIVE_ecc_secp224r1_redc
+#undef HAVE_NATIVE_ecc_secp256r1_modp
+#undef HAVE_NATIVE_ecc_secp256r1_redc
+#undef HAVE_NATIVE_ecc_secp384r1_modp
+#undef HAVE_NATIVE_ecc_secp384r1_redc
+#undef HAVE_NATIVE_ecc_secp521r1_modp
+#undef HAVE_NATIVE_ecc_secp521r1_redc
 #undef HAVE_NATIVE_gcm_hash8
 #undef HAVE_NATIVE_salsa20_core
 #undef HAVE_NATIVE_sha1_compress
diff --git a/ecc-curve25519.c b/ecc-curve25519.c
index 1045db7092ae..2d3cd498ccab 100644
--- a/ecc-curve25519.c
+++ b/ecc-curve25519.c
@@ -46,11 +46,11 @@
 
 #define PHIGH_BITS (GMP_NUMB_BITS * ECC_LIMB_SIZE - 255)
 
-#if HAVE_NATIVE_ecc_25519_modp
+#if HAVE_NATIVE_ecc_curve25519_modp
 
-#define ecc_25519_modp _nettle_ecc_25519_modp
+#define ecc_curve25519_modp _nettle_ecc_curve25519_modp
 void
-ecc_25519_modp (const struct ecc_modulo *m, mp_limb_t *rp);
+ecc_curve25519_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #else
 
 #if PHIGH_BITS == 0
@@ -58,7 +58,7 @@ ecc_25519_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #endif
 
 static void
-ecc_25519_modp(const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
+ecc_curve25519_modp(const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
 {
   mp_limb_t hi, cy;
 
@@ -69,7 +69,7 @@ ecc_25519_modp(const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
   rp[ECC_LIMB_SIZE-1] = (hi &amp; (GMP_NUMB_MASK &gt;&gt; PHIGH_BITS))
     + sec_add_1 (rp, rp, ECC_LIMB_SIZE - 1, 19 * cy);
 }
-#endif /* HAVE_NATIVE_ecc_25519_modp */
+#endif /* HAVE_NATIVE_ecc_curve25519_modp */
 
 #define QHIGH_BITS (GMP_NUMB_BITS * ECC_LIMB_SIZE - 252)
 
@@ -78,7 +78,7 @@ ecc_25519_modp(const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
 #endif
 
 static void
-ecc_25519_modq (const struct ecc_modulo *q, mp_limb_t *rp)
+ecc_curve25519_modq (const struct ecc_modulo *q, mp_limb_t *rp)
 {
   mp_size_t n;
   mp_limb_t cy;
@@ -180,7 +180,7 @@ ecc_mod_pow_252m3 (const struct ecc_modulo *m,
 /* Needs 5*ECC_LIMB_SIZE scratch space. */
 #define ECC_25519_INV_ITCH (5*ECC_LIMB_SIZE)
 
-static void ecc_25519_inv (const struct ecc_modulo *p,
+static void ecc_curve25519_inv (const struct ecc_modulo *p,
 			   mp_limb_t *rp, const mp_limb_t *ap,
 			   mp_limb_t *scratch)
 {
@@ -203,7 +203,7 @@ static void ecc_25519_inv (const struct ecc_modulo *p,
 
 /* First, do a canonical reduction, then check if zero */
 static int
-ecc_25519_zero_p (const struct ecc_modulo *p, mp_limb_t *xp)
+ecc_curve25519_zero_p (const struct ecc_modulo *p, mp_limb_t *xp)
 {
   mp_limb_t cy;
   mp_limb_t w;
@@ -239,7 +239,7 @@ ecc_25519_zero_p (const struct ecc_modulo *p, mp_limb_t *xp)
 #define ECC_25519_SQRT_ITCH (9*ECC_LIMB_SIZE)
 
 static int
-ecc_25519_sqrt(const struct ecc_modulo *p, mp_limb_t *rp,
+ecc_curve25519_sqrt(const struct ecc_modulo *p, mp_limb_t *rp,
 	       const mp_limb_t *up, const mp_limb_t *vp,
 	       mp_limb_t *scratch)
 {
@@ -271,9 +271,9 @@ ecc_25519_sqrt(const struct ecc_modulo *p, mp_limb_t *rp,
   ecc_mod_sqr (p, x2, rp);
   ecc_mod_mul (p, vx2, x2, vp);
   ecc_mod_add (p, t0, vx2, up);
-  neg = ecc_25519_zero_p (p, t0);
+  neg = ecc_curve25519_zero_p (p, t0);
   ecc_mod_sub (p, t0, up, vx2);
-  pos = ecc_25519_zero_p (p, t0);
+  pos = ecc_curve25519_zero_p (p, t0);
 
   ecc_mod_mul (p, t0, rp, ecc_sqrt_z);
   cnd_copy (neg, rp, t0, ECC_LIMB_SIZE);
@@ -306,10 +306,10 @@ const struct ecc_curve _nettle_curve25519 =
     NULL,
     ecc_pp1h,
 
-    ecc_25519_modp,
-    ecc_25519_modp,
-    ecc_25519_inv,
-    ecc_25519_sqrt,
+    ecc_curve25519_modp,
+    ecc_curve25519_modp,
+    ecc_curve25519_inv,
+    ecc_curve25519_sqrt,
   },
   {
     253,
@@ -325,8 +325,8 @@ const struct ecc_curve _nettle_curve25519 =
     NULL,
     ecc_qp1h,
 
-    ecc_25519_modq,
-    ecc_25519_modq,
+    ecc_curve25519_modq,
+    ecc_curve25519_modq,
     ecc_mod_inv,
     NULL,
   },
diff --git a/ecc-curve448.c b/ecc-curve448.c
index e1318ca4f01d..4a534689546d 100644
--- a/ecc-curve448.c
+++ b/ecc-curve448.c
@@ -46,12 +46,12 @@
 #include "ecc-curve448.h"
 
 #if HAVE_NATIVE_ecc_curve448_modp
-#define ecc_448_modp _nettle_ecc_curve448_modp
+#define ecc_curve448_modp _nettle_ecc_curve448_modp
 void
-ecc_448_modp (const struct ecc_modulo *m, mp_limb_t *rp);
+ecc_curve448_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #elif GMP_NUMB_BITS == 64
 static void
-ecc_448_modp(const struct ecc_modulo *m, mp_limb_t *rp)
+ecc_curve448_modp(const struct ecc_modulo *m, mp_limb_t *rp)
 {
   /* Let B = 2^64, b = 2^32 = sqrt(B).
      p = B^7 - b B^3 - 1 ==&gt; B^7 = b B^3 + 1
@@ -95,7 +95,7 @@ ecc_448_modp(const struct ecc_modulo *m, mp_limb_t *rp)
   assert (c7 == 0);
 }
 #else
-#define ecc_448_modp ecc_mod
+#define ecc_curve448_modp ecc_mod
 #endif
 
 /* Needs 2*ecc-&gt;size limbs at rp, and 2*ecc-&gt;size additional limbs of
@@ -167,7 +167,7 @@ ecc_mod_pow_446m224m1 (const struct ecc_modulo *p,
 /* Needs 6*ECC_LIMB_SIZE scratch space. */
 #define ECC_448_INV_ITCH (6*ECC_LIMB_SIZE)
 
-static void ecc_448_inv (const struct ecc_modulo *p,
+static void ecc_curve448_inv (const struct ecc_modulo *p,
 			 mp_limb_t *rp, const mp_limb_t *ap,
 			 mp_limb_t *scratch)
 {
@@ -184,7 +184,7 @@ static void ecc_448_inv (const struct ecc_modulo *p,
 
 /* First, do a canonical reduction, then check if zero */
 static int
-ecc_448_zero_p (const struct ecc_modulo *p, mp_limb_t *xp)
+ecc_curve448_zero_p (const struct ecc_modulo *p, mp_limb_t *xp)
 {
   mp_limb_t cy;
   mp_limb_t w;
@@ -210,7 +210,7 @@ ecc_448_zero_p (const struct ecc_modulo *p, mp_limb_t *xp)
 #define ECC_448_SQRT_ITCH (10*ECC_LIMB_SIZE)
 
 static int
-ecc_448_sqrt(const struct ecc_modulo *p, mp_limb_t *rp,
+ecc_curve448_sqrt(const struct ecc_modulo *p, mp_limb_t *rp,
 	     const mp_limb_t *up, const mp_limb_t *vp,
 	     mp_limb_t *scratch)
 {
@@ -243,7 +243,7 @@ ecc_448_sqrt(const struct ecc_modulo *p, mp_limb_t *rp,
   ecc_mod_mul (p, vx2, x2, vp);
   ecc_mod_sub (p, t0, vx2, up);
 
-  return ecc_448_zero_p (p, t0);
+  return ecc_curve448_zero_p (p, t0);
 
 #undef u3v
 #undef u5v3
@@ -274,10 +274,10 @@ const struct ecc_curve _nettle_curve448 =
     NULL,
     ecc_pp1h,
 
-    ecc_448_modp,
-    ecc_448_modp,
-    ecc_448_inv,
-    ecc_448_sqrt,
+    ecc_curve448_modp,
+    ecc_curve448_modp,
+    ecc_curve448_inv,
+    ecc_curve448_sqrt,
   },
   {
     446,
diff --git a/ecc-secp192r1.c b/ecc-secp192r1.c
index 15f5f1fa4c04..094074d73ed7 100644
--- a/ecc-secp192r1.c
+++ b/ecc-secp192r1.c
@@ -48,18 +48,18 @@
 
 #include "ecc-secp192r1.h"
 
-#if HAVE_NATIVE_ecc_192_modp
+#if HAVE_NATIVE_ecc_secp192r1_modp
 
-#define ecc_192_modp _nettle_ecc_192_modp
+#define ecc_secp192r1_modp _nettle_ecc_secp192r1_modp
 void
-ecc_192_modp (const struct ecc_modulo *m, mp_limb_t *rp);
+ecc_secp192r1_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 
 /* Use that p = 2^{192} - 2^64 - 1, to eliminate 128 bits at a time. */
 
 #elif GMP_NUMB_BITS == 32
 /* p is 6 limbs, p = B^6 - B^2 - 1 */
 static void
-ecc_192_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
+ecc_secp192r1_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
 {
   mp_limb_t cy;
 
@@ -84,7 +84,7 @@ ecc_192_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
 #elif GMP_NUMB_BITS == 64
 /* p is 3 limbs, p = B^3 - B - 1 */
 static void
-ecc_192_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
+ecc_secp192r1_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
 {
   mp_limb_t cy;
 
@@ -107,7 +107,7 @@ ecc_192_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
 }
   
 #else
-#define ecc_192_modp ecc_mod
+#define ecc_secp192r1_modp ecc_mod
 #endif
 
 const struct ecc_curve _nettle_secp_192r1 =
@@ -126,8 +126,8 @@ const struct ecc_curve _nettle_secp_192r1 =
     ecc_redc_ppm1,
     ecc_pp1h,
 
-    ecc_192_modp,
-    ecc_192_modp,
+    ecc_secp192r1_modp,
+    ecc_secp192r1_modp,
     ecc_mod_inv,
     NULL,
   },
diff --git a/ecc-secp224r1.c b/ecc-secp224r1.c
index 28b938fa3282..e6b43fa61f42 100644
--- a/ecc-secp224r1.c
+++ b/ecc-secp224r1.c
@@ -40,24 +40,24 @@
 #include "ecc.h"
 #include "ecc-internal.h"
 
-#if HAVE_NATIVE_ecc_224_modp
+#if HAVE_NATIVE_ecc_secp224r1_modp
 
 #define USE_REDC 0
-#define ecc_224_modp _nettle_ecc_224_modp
+#define ecc_secp224r1_modp _nettle_ecc_secp224r1_modp
 void
-ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp);
+ecc_secp224r1_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 
 #else
 #define USE_REDC (ECC_REDC_SIZE != 0)
-#define ecc_224_modp ecc_mod
+#define ecc_secp224r1_modp ecc_mod
 #endif
 
 #include "ecc-secp224r1.h"
 
 #if ECC_REDC_SIZE &lt; 0
-# define ecc_224_redc ecc_pm1_redc
+# define ecc_secp224r1_redc ecc_pm1_redc
 #elif ECC_REDC_SIZE == 0
-# define ecc_224_redc NULL
+# define ecc_secp224r1_redc NULL
 #else
 # error Configuration error
 #endif
@@ -78,8 +78,8 @@ const struct ecc_curve _nettle_secp_224r1 =
     ecc_redc_ppm1,
     ecc_pp1h,
 
-    ecc_224_modp,
-    USE_REDC ? ecc_224_redc : ecc_224_modp,
+    ecc_secp224r1_modp,
+    USE_REDC ? ecc_secp224r1_redc : ecc_secp224r1_modp,
     ecc_mod_inv,
     NULL,
   },
diff --git a/ecc-secp256r1.c b/ecc-secp256r1.c
index ed463edf7729..72b337db4560 100644
--- a/ecc-secp256r1.c
+++ b/ecc-secp256r1.c
@@ -42,7 +42,7 @@
 #include "ecc.h"
 #include "ecc-internal.h"
 
-#if HAVE_NATIVE_ecc_256_redc
+#if HAVE_NATIVE_ecc_secp256r1_redc
 # define USE_REDC 1
 #else
 # define USE_REDC (ECC_REDC_SIZE != 0)
@@ -50,27 +50,27 @@
 
 #include "ecc-secp256r1.h"
 
-#if HAVE_NATIVE_ecc_256_redc
-# define ecc_256_redc _nettle_ecc_256_redc
+#if HAVE_NATIVE_ecc_secp256r1_redc
+# define ecc_secp256r1_redc _nettle_ecc_secp256r1_redc
 void
-ecc_256_redc (const struct ecc_modulo *p, mp_limb_t *rp);
-#else /* !HAVE_NATIVE_ecc_256_redc */
+ecc_secp256r1_redc (const struct ecc_modulo *p, mp_limb_t *rp);
+#else /* !HAVE_NATIVE_ecc_secp256r1_redc */
 # if ECC_REDC_SIZE &gt; 0 
-#   define ecc_256_redc ecc_pp1_redc
+#   define ecc_secp256r1_redc ecc_pp1_redc
 # elif ECC_REDC_SIZE == 0
-#   define ecc_256_redc NULL
+#   define ecc_secp256r1_redc NULL
 # else
 #  error Configuration error
 # endif
-#endif /* !HAVE_NATIVE_ecc_256_redc */
+#endif /* !HAVE_NATIVE_ecc_secp256r1_redc */
 
 #if ECC_BMODP_SIZE &lt; ECC_LIMB_SIZE
-#define ecc_256_modp ecc_mod
-#define ecc_256_modq ecc_mod
+#define ecc_secp256r1_modp ecc_mod
+#define ecc_secp256r1_modq ecc_mod
 #elif GMP_NUMB_BITS == 64
 
 static void
-ecc_256_modp (const struct ecc_modulo *p, mp_limb_t *rp)
+ecc_secp256r1_modp (const struct ecc_modulo *p, mp_limb_t *rp)
 {
   mp_limb_t u1, u0;
   mp_size_t n;
@@ -146,7 +146,7 @@ ecc_256_modp (const struct ecc_modulo *p, mp_limb_t *rp)
 }
 
 static void
-ecc_256_modq (const struct ecc_modulo *q, mp_limb_t *rp)
+ecc_secp256r1_modq (const struct ecc_modulo *q, mp_limb_t *rp)
 {
   mp_limb_t u2, u1, u0;
   mp_size_t n;
@@ -255,8 +255,8 @@ const struct ecc_curve _nettle_secp_256r1 =
     ecc_redc_ppm1,
 
     ecc_pp1h,
-    ecc_256_modp,
-    USE_REDC ? ecc_256_redc : ecc_256_modp,
+    ecc_secp256r1_modp,
+    USE_REDC ? ecc_secp256r1_redc : ecc_secp256r1_modp,
     ecc_mod_inv,
     NULL,
   },
@@ -274,8 +274,8 @@ const struct ecc_curve _nettle_secp_256r1 =
     NULL,
     ecc_qp1h,
 
-    ecc_256_modq,
-    ecc_256_modq,
+    ecc_secp256r1_modq,
+    ecc_secp256r1_modq,
     ecc_mod_inv,
     NULL,
   },
diff --git a/ecc-secp384r1.c b/ecc-secp384r1.c
index 32f75fb618ba..c4a75564bf58 100644
--- a/ecc-secp384r1.c
+++ b/ecc-secp384r1.c
@@ -46,10 +46,10 @@
 
 #include "ecc-secp384r1.h"
 
-#if HAVE_NATIVE_ecc_384_modp
-#define ecc_384_modp _nettle_ecc_384_modp
+#if HAVE_NATIVE_ecc_secp384r1_modp
+#define ecc_secp384r1_modp _nettle_ecc_secp384r1_modp
 void
-ecc_384_modp (const struct ecc_modulo *m, mp_limb_t *rp);
+ecc_secp384r1_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #elif GMP_NUMB_BITS == 32
 
 /* Use that 2^{384} = 2^{128} + 2^{96} - 2^{32} + 1, and eliminate 256
@@ -62,7 +62,7 @@ ecc_384_modp (const struct ecc_modulo *m, mp_limb_t *rp);
    almost 8 at a time. Do only 7, to avoid additional carry
    propagation, followed by 5. */
 static void
-ecc_384_modp (const struct ecc_modulo *p, mp_limb_t *rp)
+ecc_secp384r1_modp (const struct ecc_modulo *p, mp_limb_t *rp)
 {
   mp_limb_t cy, bw;
 
@@ -106,7 +106,7 @@ ecc_384_modp (const struct ecc_modulo *p, mp_limb_t *rp)
 /* p is 6 limbs, and B^6 - p = B^2 + 2^32 (B - 1) + 1. Eliminate 3
    (almost 4) limbs at a time. */
 static void
-ecc_384_modp (const struct ecc_modulo *p, mp_limb_t *rp)
+ecc_secp384r1_modp (const struct ecc_modulo *p, mp_limb_t *rp)
 {
   mp_limb_t tp[6];
   mp_limb_t cy;
@@ -144,7 +144,7 @@ ecc_384_modp (const struct ecc_modulo *p, mp_limb_t *rp)
   assert (cy == 0);  
 }
 #else
-#define ecc_384_modp ecc_mod
+#define ecc_secp384r1_modp ecc_mod
 #endif
   
 const struct ecc_curve _nettle_secp_384r1 =
@@ -163,8 +163,8 @@ const struct ecc_curve _nettle_secp_384r1 =
     ecc_redc_ppm1,
     ecc_pp1h,
 
-    ecc_384_modp,
-    ecc_384_modp,
+    ecc_secp384r1_modp,
+    ecc_secp384r1_modp,
     ecc_mod_inv,
     NULL,
   },
diff --git a/ecc-secp521r1.c b/ecc-secp521r1.c
index d952d77e444e..74688008959b 100644
--- a/ecc-secp521r1.c
+++ b/ecc-secp521r1.c
@@ -44,10 +44,10 @@
 
 #include "ecc-secp521r1.h"
 
-#if HAVE_NATIVE_ecc_521_modp
-#define ecc_521_modp _nettle_ecc_521_modp
+#if HAVE_NATIVE_ecc_secp521r1_modp
+#define ecc_secp521r1_modp _nettle_ecc_secp521r1_modp
 void
-ecc_521_modp (const struct ecc_modulo *m, mp_limb_t *rp);
+ecc_secp521r1_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 
 #else
 
@@ -57,7 +57,7 @@ ecc_521_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 
 /* Result may be *slightly* larger than 2^521 */
 static void
-ecc_521_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
+ecc_secp521r1_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)
 {
   /* FIXME: Should use mpn_addlsh_n_ip1 */
   mp_limb_t hi;
@@ -91,8 +91,8 @@ const struct ecc_curve _nettle_secp_521r1 =
     ecc_redc_ppm1,
     ecc_pp1h,
 
-    ecc_521_modp,
-    ecc_521_modp,
+    ecc_secp521r1_modp,
+    ecc_secp521r1_modp,
     ecc_mod_inv,
     NULL,
   },
diff --git a/eddsa-sign.c b/eddsa-sign.c
index 13ae47995e74..2754d20eb932 100644
--- a/eddsa-sign.c
+++ b/eddsa-sign.c
@@ -87,7 +87,7 @@ _eddsa_sign (const struct ecc_curve *ecc,
 
   ecc_modq_mul (ecc, sp, hp, k2);
   ecc_modq_add (ecc, sp, sp, rp); /* FIXME: Can be plain add */
-  /* FIXME: Special code duplicated in ecc_25519_modq and ecc_eh_to_a.
+  /* FIXME: Special code duplicated in ecc_curve25519_modq and ecc_eh_to_a.
      Define a suitable method? */
   {
     unsigned shift;
diff --git a/x86_64/ecc-curve25519-modp.asm b/x86_64/ecc-curve25519-modp.asm
index 0374db12ab44..44dce6df8789 100644
--- a/x86_64/ecc-curve25519-modp.asm
+++ b/x86_64/ecc-curve25519-modp.asm
@@ -41,7 +41,7 @@ define(&lt;T0&gt;, &lt;%r10&gt;)
 define(&lt;T1&gt;, &lt;%r11&gt;)
 define(&lt;M&gt;, &lt;%rbx&gt;)
 
-PROLOGUE(_nettle_ecc_25519_modp)
+PROLOGUE(_nettle_ecc_curve25519_modp)
 	W64_ENTRY(2, 0)
 	push	%rbx
 
@@ -91,4 +91,4 @@ PROLOGUE(_nettle_ecc_25519_modp)
 	pop	%rbx
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(_nettle_ecc_25519_modp)
+EPILOGUE(_nettle_ecc_curve25519_modp)
diff --git a/x86_64/ecc-secp192r1-modp.asm b/x86_64/ecc-secp192r1-modp.asm
index ad8dca7186e4..3a008130c1bb 100644
--- a/x86_64/ecc-secp192r1-modp.asm
+++ b/x86_64/ecc-secp192r1-modp.asm
@@ -41,10 +41,10 @@ define(&lt;H&gt;, &lt;%r9&gt;)
 define(&lt;C1&gt;, &lt;%r10&gt;)
 define(&lt;C2&gt;, &lt;%r11&gt;)
 
-	C ecc_192_modp (const struct ecc_modulo *m, mp_limb_t *rp)
+	C ecc_secp192r1_modp (const struct ecc_modulo *m, mp_limb_t *rp)
 	.text
 	ALIGN(16)
-PROLOGUE(_nettle_ecc_192_modp)
+PROLOGUE(_nettle_ecc_secp192r1_modp)
 	W64_ENTRY(2, 0)
 	mov	16(RP), T2
 	mov	24(RP), T3
@@ -85,4 +85,4 @@ PROLOGUE(_nettle_ecc_192_modp)
 
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(_nettle_ecc_192_modp)
+EPILOGUE(_nettle_ecc_secp192r1_modp)
diff --git a/x86_64/ecc-secp224r1-modp.asm b/x86_64/ecc-secp224r1-modp.asm
index e44b5418e5dd..dfa85a8d6f3f 100644
--- a/x86_64/ecc-secp224r1-modp.asm
+++ b/x86_64/ecc-secp224r1-modp.asm
@@ -44,8 +44,8 @@ define(&lt;F0&gt;, &lt;%r9&gt;)
 define(&lt;F1&gt;, &lt;%r10&gt;)
 define(&lt;F2&gt;, &lt;%r11&gt;)
 
-	C ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp)
-PROLOGUE(_nettle_ecc_224_modp)
+	C ecc_secp224r1_modp (const struct ecc_modulo *m, mp_limb_t *rp)
+PROLOGUE(_nettle_ecc_secp224r1_modp)
 	W64_ENTRY(2, 0)
 	mov	48(RP), H0
 	mov	56(RP), H1
@@ -128,4 +128,4 @@ PROLOGUE(_nettle_ecc_224_modp)
 
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(_nettle_ecc_224_modp)
+EPILOGUE(_nettle_ecc_secp224r1_modp)
diff --git a/x86_64/ecc-secp256r1-redc.asm b/x86_64/ecc-secp256r1-redc.asm
index 533a1766d4bc..67da065b27f4 100644
--- a/x86_64/ecc-secp256r1-redc.asm
+++ b/x86_64/ecc-secp256r1-redc.asm
@@ -58,7 +58,7 @@ define(&lt;FOLD&gt;, &lt;
 	sbb	$1, F2
 	sbb	&lt;$&gt;0, F3
 &gt;)
-PROLOGUE(_nettle_ecc_256_redc)
+PROLOGUE(_nettle_ecc_secp256r1_redc)
 	W64_ENTRY(2, 0)
 	C save all registers that need to be saved
 	push	%rbx
@@ -126,4 +126,4 @@ PROLOGUE(_nettle_ecc_256_redc)
 	pop	%rbx
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(_nettle_ecc_256_redc)
+EPILOGUE(_nettle_ecc_secp256r1_redc)
diff --git a/x86_64/ecc-secp384r1-modp.asm b/x86_64/ecc-secp384r1-modp.asm
index 13f469b164e4..9bfa0618d33e 100644
--- a/x86_64/ecc-secp384r1-modp.asm
+++ b/x86_64/ecc-secp384r1-modp.asm
@@ -51,7 +51,7 @@ define(&lt;C0&gt;, H5)	C Overlap
 define(&lt;TMP&gt;, RP)	C Overlap
 
 
-PROLOGUE(_nettle_ecc_384_modp)
+PROLOGUE(_nettle_ecc_secp384r1_modp)
 	W64_ENTRY(2, 0)
 
 	push	%rbx
@@ -231,4 +231,4 @@ PROLOGUE(_nettle_ecc_384_modp)
 
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(_nettle_ecc_384_modp)
+EPILOGUE(_nettle_ecc_secp384r1_modp)
diff --git a/x86_64/ecc-secp521r1-modp.asm b/x86_64/ecc-secp521r1-modp.asm
index 6f4f7d90714d..a6840a60faec 100644
--- a/x86_64/ecc-secp521r1-modp.asm
+++ b/x86_64/ecc-secp521r1-modp.asm
@@ -48,7 +48,7 @@ define(&lt;U9&gt;, &lt;%r11&gt;)
 define(&lt;T0&gt;, &lt;%r12&gt;)
 define(&lt;T1&gt;, &lt;%r13&gt;)
 
-PROLOGUE(_nettle_ecc_521_modp)
+PROLOGUE(_nettle_ecc_secp521r1_modp)
 	W64_ENTRY(2, 0)
 	push	%rbx
 	push	%rbp
@@ -155,4 +155,4 @@ PROLOGUE(_nettle_ecc_521_modp)
 	pop	%rbx
 	W64_EXIT(2, 0)
 	ret
-EPILOGUE(_nettle_ecc_521_modp)
+EPILOGUE(_nettle_ecc_secp521r1_modp)
-- 
2.24.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191225121610</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-12-25 12:16:10-0400</timestampReceived><subject>Re: Current ECC work</subject><body>

ср, 25 дек. 2019 г. в 14:01, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; I've now merged Daiki's implementation of curve448, and I've done some
&gt; followup cleanups: Moving and renaming edwards/twisted edwards
&gt; functions, and using a shared ecc_mul_m function for both curve25519_mul
&gt; and curve448_mul.

Great, thank you!

&gt; Pending work:
&gt; 3. I'm considering changing the struct ecc_point representation to use
&gt;    montgomery representation of the for the individual coordinates, for
&gt;    primes where we use that. Then ecc_a_to_* will (almost?) be
&gt;    redundant. This is inline with also adding other coordinate changes
&gt;    here, if that will be needed for new curves. For the inverse
&gt;    functions, ecc_*_to_a, they're currently repsonsible both for
&gt;    inverting and eliminating the redundant z coordinate, and converting
&gt;    individual coordinates back from montgomery representation, when
&gt;    needed.

Great! This can also be a base for Weierstrass-with-Edwards-form curves.

&gt; 4. Adding support for compact representation (patches from Wim Lewis). I
&gt;    have some of the preparations merged on a branch, but I think it will
&gt;    be simpler if (3) is done first.

5. GOST DSA (RFC 5832, RFC 7091)

Code was tested in GnuTLS tree. Patches for Nettle are ready to be
posted after patchset 2 (renames) is merged.

6. secp256k1

Code requires support for properly handling of a coefficient in
eccdata.c. I have an implementation handling small values fitting into
`int` variables.
Also this will allow us to merge twisted and untwisted cases in
eccdata.c removing code duplication.
I have old patches ready which have to be rebased on top of master.


&gt;
&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
&gt; Internet email is subject to wholesale government surveillance.
&gt;
&gt; _______________________________________________
&gt; nettle-bugs mailing list
&gt; nettle-bugs@lists.lysator.liu.se
&gt; http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs



--
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191225122639</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-12-25 12:26:39-0400</timestampReceived><subject>Re: [PATCH v2 3/6] nettle-meta: Add meta interface for HMAC functions</subject><body>

Hello,

ср, 25 дек. 2019 г. в 14:31, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Daiki Ueno &lt;ueno@gnu.org&gt; writes:
&gt;
&gt; &gt; +static void
&gt; &gt; +hmac_md5_set_key_wrapper (void *ctx, const uint8_t *key)
&gt; &gt; +{
&gt; &gt; +  hmac_md5_set_key (ctx, MD5_BLOCK_SIZE, key);
&gt; &gt; +}
&gt;
&gt; [...]
&gt;
&gt; &gt; +extern const struct nettle_mac nettle_hmac_md5;
&gt; &gt; +extern const struct nettle_mac nettle_hmac_ripemd160;
&gt; &gt; +extern const struct nettle_mac nettle_hmac_sha1;
&gt; &gt; +extern const struct nettle_mac nettle_hmac_sha224;
&gt; &gt; +extern const struct nettle_mac nettle_hmac_sha256;
&gt; &gt; +extern const struct nettle_mac nettle_hmac_sha384;
&gt; &gt; +extern const struct nettle_mac nettle_hmac_sha512;
&gt;
&gt; If we define a single nettle_mac for each supported (no-nonce) mac
&gt; algorithm, what should the key size be for each algorithm? Using the
&gt; underlying block size for the hmac algorithms seems to be a bit
&gt; overkill. What key sizes are used in practice? Does it make sense to
&gt; use key size equal to digest size (at least, that's what used for hmac
&gt; in the ssh protocol)?

Same goes for TLS. Key size = digest size for HMAC.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191124134900</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-11-24 13:49:00-0400</timestampReceived><subject>Re: ECC code rework</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt;&gt; I've just pushed a change to the .gitlab-ci file, so I hope the next
&gt;&gt; build looks better.
&gt;
&gt; GnuTLS also received a MR to fix tests in minimal build, so next
&gt; master-updates build should succeed.

It looks green now. Just merged those changes over to master. Please
remind to remove --disable-gost when things have stabilized.

&gt; The problem is that both 3.5(.1) and master have same version. I just
&gt; hope that we can get all ECC changes in single release.

Version checks on master will unfortunately never be quite reliable.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191204211837</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-04 21:18:37-0400</timestampReceived><subject>Re: [RFC] ecc: switch away from affine points representation</subject><body>

dbaryshkov@gmail.com writes:

&gt; From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt;
&gt; Use jacobian/harmonized representation in ecc_point structure.

Can you explain what benefit you see from this?

E.g., ecc_point_mul takes a const struct ecc_point as input, and calls
ecc-&gt;mul, which for the standard weierstrass curves is ecc_mul_a. This
one is a loop including a call to ecc_add_jja, which assumes that the z
coordinate is one. 

(ecc_mul_a also calls ecc_a_to_j, which appears to write a z = 1
coordinate, in montgomery representation if appropriate. Even though the
z coordinate is not used in this case. Maybe no callers of ecc_a_to_j
needs the z coordiante? Needs some investigation. Reading the code a few
years after it was written I wish I had been more thorough with
documenting details input and output assumptions).

Doing ecc_point_mul starting with a point represented as (X, Y, Z) where
Z is arbitrary will be slower, since it needs to take one more
coordinate into account in the point addition.

It could be useful to work exclusively with jacobian or homogeneous
coordinates if you want to make a series of operations on points, and
only convert back to affine at the very end. But I'd like to see a clear
use case before trying to optimize for that.

&gt; diff --git a/ecc-a-to-j.c b/ecc-a-to-j.c
&gt; index 9fb0d2b80c41..895502e0fe20 100644
&gt; --- a/ecc-a-to-j.c
&gt; +++ b/ecc-a-to-j.c
&gt; @@ -40,11 +40,12 @@
&gt;  
&gt;  void
&gt;  ecc_a_to_j (const struct ecc_curve *ecc,
&gt; -	    mp_limb_t *r, const mp_limb_t *p)
&gt; +	    mp_limb_t *r, const mpz_t x, const mpz_t y)
&gt;  {
&gt;    if (ecc-&gt;use_redc)
&gt;      {
&gt; -      mpn_copyd (r + ecc-&gt;p.size, p, 2*ecc-&gt;p.size);
&gt; +      mpz_limbs_copy (r + ecc-&gt;p.size, x, ecc-&gt;p.size);
&gt; +      mpz_limbs_copy (r + 2 * ecc-&gt;p.size, y, ecc-&gt;p.size);

I don't think we should use the mpz_t type in internal ecc functions.
mpz_limbs_copy is not side-channnel silent, since organization of
storage inside mpz_t is different depending on the leading bits.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191205154526</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-12-05 15:45:26-0400</timestampReceived><subject>Re: [PATCH] ecc: rename source files with curves data</subject><body>

Any feedback on this change?

I'm going to send patches adding 3 256-bit curves and 2 512-bit curves
with another 256-bit and 512-bit curves waiting some restructuring of
the code.
It would be too easy to mix curves w/o this patch.

вс, 24 нояб. 2019 г. в 17:22, &lt;dbaryshkov@gmail.com&gt;:
&gt; 
&gt; From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt; 
&gt; In preparation to adding GOST curves support, rename source files and
&gt; use curve name as eccdata parameter.
&gt; 
&gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt; ---
&gt; .gitignore                                    | 12 ++---
&gt; Makefile.in                                   | 45 ++++++++--------
&gt; ...cc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} |  0
&gt; ...cc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} |  0
&gt; ...cc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} |  0
&gt; ...cc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} |  0
&gt; ...cc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} |  0
&gt; configure.ac                                  |  5 +-
&gt; ecc-25519.c =&gt; ecc-curve25519.c               |  4 +-
&gt; ecc-192.c =&gt; ecc-secp192r1.c                  |  4 +-
&gt; ecc-224.c =&gt; ecc-secp224r1.c                  |  4 +-
&gt; ecc-256.c =&gt; ecc-secp256r1.c                  |  4 +-
&gt; ecc-384.c =&gt; ecc-secp384r1.c                  |  4 +-
&gt; ecc-521.c =&gt; ecc-secp521r1.c                  |  4 +-
&gt; eccdata.c                                     | 51 +++++++++++--------
&gt; ...25519-modp.asm =&gt; ecc-curve25519-modp.asm} |  0
&gt; ...cc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} |  0
&gt; ...cc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} |  0
&gt; ...cc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} |  0
&gt; ...cc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} |  0
&gt; ...cc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} |  0
&gt; 21 files changed, 74 insertions(+), 63 deletions(-)
&gt; rename arm/{ecc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} (100%)
&gt; rename arm/{ecc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} (100%)
&gt; rename arm/{ecc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} (100%)
&gt; rename arm/{ecc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} (100%)
&gt; rename arm/{ecc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} (100%)
&gt; rename ecc-25519.c =&gt; ecc-curve25519.c (99%)
&gt; rename ecc-192.c =&gt; ecc-secp192r1.c (98%)
&gt; rename ecc-224.c =&gt; ecc-secp224r1.c (98%)
&gt; rename ecc-256.c =&gt; ecc-secp256r1.c (99%)
&gt; rename ecc-384.c =&gt; ecc-secp384r1.c (99%)
&gt; rename ecc-521.c =&gt; ecc-secp521r1.c (98%)
&gt; rename x86_64/{ecc-25519-modp.asm =&gt; ecc-curve25519-modp.asm} (100%)
&gt; rename x86_64/{ecc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} (100%)
&gt; rename x86_64/{ecc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} (100%)
&gt; rename x86_64/{ecc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} (100%)
&gt; rename x86_64/{ecc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} (100%)
&gt; rename x86_64/{ecc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} (100%)
&gt; 
&gt; diff --git a/.gitignore b/.gitignore
&gt; index b79c53f535ff..be10fbe959cc 100644
&gt; --- a/.gitignore
&gt; +++ b/.gitignore
&gt; @@ -43,12 +43,12 @@ core
&gt; /keymap.h
&gt; /parity.h
&gt; /rotors.h
&gt; -/ecc-192.h
&gt; -/ecc-224.h
&gt; -/ecc-256.h
&gt; -/ecc-384.h
&gt; -/ecc-521.h
&gt; -/ecc-25519.h
&gt; +/ecc-curve25519.h
&gt; +/ecc-secp192r1.h
&gt; +/ecc-secp224r1.h
&gt; +/ecc-secp256r1.h
&gt; +/ecc-secp384r1.h
&gt; +/ecc-secp521r1.h
&gt; /version.h
&gt; /nettle.aux
&gt; /nettle.cp
&gt; diff --git a/Makefile.in b/Makefile.in
&gt; index 9f5b065a706a..89066ec6c3c2 100644
&gt; --- a/Makefile.in
&gt; +++ b/Makefile.in
&gt; @@ -174,8 +174,8 @@ hogweed_SOURCES = sexp.c sexp-format.c \
&gt; gmp-glue.c cnd-copy.c \
&gt; ecc-mod.c ecc-mod-inv.c \
&gt; ecc-mod-arith.c ecc-pp1-redc.c ecc-pm1-redc.c \
&gt; -                 ecc-192.c ecc-224.c ecc-256.c ecc-384.c ecc-521.c \
&gt; -                 ecc-25519.c \
&gt; +                 ecc-curve25519.c ecc-secp192r1.c ecc-secp224r1.c \
&gt; +                 ecc-secp256r1.c ecc-secp384r1.c ecc-secp521r1.c \
&gt; ecc-size.c ecc-j-to-a.c ecc-a-to-j.c \
&gt; ecc-dup-jj.c ecc-add-jja.c ecc-add-jjj.c \
&gt; ecc-eh-to-a.c \
&gt; @@ -345,24 +345,24 @@ des.$(OBJEXT): des.c des.h $(des_headers)
&gt; # k = 14, c =  7, S = 256, T =  42 ( 28 A + 14 D) 12 KB
&gt; # k = 11, c =  6, S = 192, T =  44 ( 33 A + 11 D)  9 KB
&gt; # k = 16, c =  6, S = 128, T =  48 ( 32 A + 16 D)  6 KB
&gt; -ecc-192.h: eccdata.stamp
&gt; -       ./eccdata$(EXEEXT_FOR_BUILD) 192 8 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
&gt; +ecc-secp192r1.h: eccdata.stamp
&gt; +       ./eccdata$(EXEEXT_FOR_BUILD) secp192r1 8 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
&gt; 
&gt; # Some reasonable choices for 224:
&gt; # k = 16, c =  7, S = 256, T =  48 ( 32 A + 16 D) ~16 KB
&gt; # k = 10, c =  6, S = 256, T =  50 ( 40 A + 10 D) ~16 KB
&gt; # k = 13, c =  6, S = 192, T =  52 ( 39 A + 13 D) ~12 KB
&gt; # k =  9, c =  5, S = 160, T =  54 ( 45 A +  9 D) ~10 KB
&gt; -ecc-224.h: eccdata.stamp
&gt; -       ./eccdata$(EXEEXT_FOR_BUILD) 224 16 7 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
&gt; +ecc-secp224r1.h: eccdata.stamp
&gt; +       ./eccdata$(EXEEXT_FOR_BUILD) secp224r1 16 7 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
&gt; 
&gt; # Some reasonable choices for 256:
&gt; # k =  9, c =  6, S = 320, T =  54 ( 45 A +  9 D) 20 KB
&gt; # k = 11, c =  6, S = 256, T =  55 ( 44 A + 11 D) 16 KB
&gt; # k = 19, c =  7, S = 256, T =  57 ( 38 A + 19 D) 16 KB
&gt; # k = 15, c =  6, S = 192, T =  60 ( 45 A + 15 D) 12 KB
&gt; -ecc-256.h: eccdata.stamp
&gt; -       ./eccdata$(EXEEXT_FOR_BUILD) 256 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
&gt; +ecc-secp256r1.h: eccdata.stamp
&gt; +       ./eccdata$(EXEEXT_FOR_BUILD) secp256r1 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
&gt; 
&gt; # Some reasonable choices for 384:
&gt; # k = 16, c =  6, S = 256, T =  80 ( 64 A + 16 D) 24 KB
&gt; @@ -372,31 +372,31 @@ ecc-256.h: eccdata.stamp
&gt; # k = 13, c =  5, S = 192, T =  91 ( 78 A + 13 D) 18 KB
&gt; # k = 16, c =  5, S = 160, T =  96 ( 80 A + 16 D) 15 KB
&gt; # k = 32, c =  6, S = 128, T =  96 ( 64 A + 32 D) 12 KB
&gt; -ecc-384.h: eccdata.stamp
&gt; -       ./eccdata$(EXEEXT_FOR_BUILD) 384 32 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
&gt; +ecc-secp384r1.h: eccdata.stamp
&gt; +       ./eccdata$(EXEEXT_FOR_BUILD) secp384r1 32 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
&gt; 
&gt; # Some reasonable choices for 521:
&gt; # k = 29, c =  6, S = 192, T = 116 ( 87 A + 29 D) ~27 KB
&gt; # k = 21, c =  5, S = 160, T = 126 (105 A + 21 D) ~23 KB
&gt; # k = 44, c =  6, S = 128, T = 132 ( 88 A + 44 D) ~18 KB
&gt; # k = 35, c =  5, S =  96, T = 140 (105 A + 35 D) ~14 KB
&gt; -ecc-521.h: eccdata.stamp
&gt; -       ./eccdata$(EXEEXT_FOR_BUILD) 521 44 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
&gt; +ecc-secp521r1.h: eccdata.stamp
&gt; +       ./eccdata$(EXEEXT_FOR_BUILD) secp521r1 44 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
&gt; 
&gt; -# Parameter choices mostly the same as for ecc-256.h.
&gt; -ecc-25519.h: eccdata.stamp
&gt; -       ./eccdata$(EXEEXT_FOR_BUILD) 255 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
&gt; +# Parameter choices mostly the same as for ecc-secp256r1.h.
&gt; +ecc-curve25519.h: eccdata.stamp
&gt; +       ./eccdata$(EXEEXT_FOR_BUILD) curve25519 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T \
&gt; $@ 
&gt; eccdata.stamp: eccdata.c
&gt; $(MAKE) eccdata$(EXEEXT_FOR_BUILD)
&gt; echo stamp &gt; eccdata.stamp
&gt; 
&gt; -ecc-192.$(OBJEXT): ecc-192.h
&gt; -ecc-224.$(OBJEXT): ecc-224.h
&gt; -ecc-256.$(OBJEXT): ecc-256.h
&gt; -ecc-384.$(OBJEXT): ecc-384.h
&gt; -ecc-521.$(OBJEXT): ecc-521.h
&gt; -ecc-25519.$(OBJEXT): ecc-25519.h
&gt; +ecc-curve25519.$(OBJEXT): ecc-curve25519.h
&gt; +ecc-secp192r1.$(OBJEXT): ecc-secp192r1.h
&gt; +ecc-secp224r1.$(OBJEXT): ecc-secp224r1.h
&gt; +ecc-secp256r1.$(OBJEXT): ecc-secp256r1.h
&gt; +ecc-secp384r1.$(OBJEXT): ecc-secp384r1.h
&gt; +ecc-secp521r1.$(OBJEXT): ecc-secp521r1.h
&gt; 
&gt; .asm.$(OBJEXT): $(srcdir)/asm.m4 machine.m4 config.m4
&gt; $(M4) $(srcdir)/asm.m4 machine.m4 config.m4 $&lt; &gt;$*.s
&gt; @@ -649,7 +649,8 @@ distcheck: dist
&gt; 
&gt; clean-here:
&gt; -rm -f $(TARGETS) *.$(OBJEXT) *.s *.so *.dll *.a \
&gt; -               ecc-192.h ecc-224.h ecc-256.h ecc-384.h ecc-521.h ecc-25519.h \
&gt; +               ecc-curve25519.h ecc-secp192r1.h ecc-secp224r1.h ecc-secp256r1.h \
&gt; +               ecc-secp384r1.h ecc-secp521r1.h \
&gt; aesdata$(EXEEXT_FOR_BUILD) \
&gt; desdata$(EXEEXT_FOR_BUILD) \
&gt; twofishdata$(EXEEXT_FOR_BUILD) \
&gt; diff --git a/arm/ecc-192-modp.asm b/arm/ecc-secp192r1-modp.asm
&gt; similarity index 100%
&gt; rename from arm/ecc-192-modp.asm
&gt; rename to arm/ecc-secp192r1-modp.asm
&gt; diff --git a/arm/ecc-224-modp.asm b/arm/ecc-secp224r1-modp.asm
&gt; similarity index 100%
&gt; rename from arm/ecc-224-modp.asm
&gt; rename to arm/ecc-secp224r1-modp.asm
&gt; diff --git a/arm/ecc-256-redc.asm b/arm/ecc-secp256r1-redc.asm
&gt; similarity index 100%
&gt; rename from arm/ecc-256-redc.asm
&gt; rename to arm/ecc-secp256r1-redc.asm
&gt; diff --git a/arm/ecc-384-modp.asm b/arm/ecc-secp384r1-modp.asm
&gt; similarity index 100%
&gt; rename from arm/ecc-384-modp.asm
&gt; rename to arm/ecc-secp384r1-modp.asm
&gt; diff --git a/arm/ecc-521-modp.asm b/arm/ecc-secp521r1-modp.asm
&gt; similarity index 100%
&gt; rename from arm/ecc-521-modp.asm
&gt; rename to arm/ecc-secp521r1-modp.asm
&gt; diff --git a/configure.ac b/configure.ac
&gt; index 3547cae4ee15..cbc914dbf14b 100644
&gt; --- a/configure.ac
&gt; +++ b/configure.ac
&gt; @@ -475,8 +475,9 @@ asm_nettle_optional_list="gcm-hash8.asm cpuid.asm \
&gt; 
&gt; asm_hogweed_optional_list=""
&gt; if test "x$enable_public_key" = "xyes" ; then
&gt; -  asm_hogweed_optional_list="ecc-192-modp.asm ecc-224-modp.asm \
&gt; -    ecc-25519-modp.asm ecc-256-redc.asm ecc-384-modp.asm ecc-521-modp.asm"
&gt; +  asm_hogweed_optional_list="ecc-curve25519-modp.asm \
&gt; +    ecc-secp192r1-modp.asm ecc-secp224r1-modp.asm \
&gt; +    ecc-secp256r1-redc.asm ecc-secp384r1-modp.asm ecc-secp521r1-modp.asm"
&gt; fi
&gt; 
&gt; OPT_NETTLE_OBJS=""
&gt; diff --git a/ecc-25519.c b/ecc-curve25519.c
&gt; similarity index 99%
&gt; rename from ecc-25519.c
&gt; rename to ecc-curve25519.c
&gt; index 105ce0f4fbc1..e6a1b325be66 100644
&gt; --- a/ecc-25519.c
&gt; +++ b/ecc-curve25519.c
&gt; @@ -1,4 +1,4 @@
&gt; -/* ecc-25519.c
&gt; +/* ecc-curve25519.c
&gt; 
&gt; Arithmetic and tables for curve25519,
&gt; 
&gt; @@ -42,7 +42,7 @@
&gt; 
&gt; #define USE_REDC 0
&gt; 
&gt; -#include "ecc-25519.h"
&gt; +#include "ecc-curve25519.h"
&gt; 
&gt; #define PHIGH_BITS (GMP_NUMB_BITS * ECC_LIMB_SIZE - 255)
&gt; 
&gt; diff --git a/ecc-192.c b/ecc-secp192r1.c
&gt; similarity index 98%
&gt; rename from ecc-192.c
&gt; rename to ecc-secp192r1.c
&gt; index 4b756ffd7e8f..858a1b7554ce 100644
&gt; --- a/ecc-192.c
&gt; +++ b/ecc-secp192r1.c
&gt; @@ -1,4 +1,4 @@
&gt; -/* ecc-192.c
&gt; +/* ecc-secp192r1.c
&gt; 
&gt; Compile time constant (but machine dependent) tables.
&gt; 
&gt; @@ -46,7 +46,7 @@
&gt; 
&gt; #define USE_REDC 0
&gt; 
&gt; -#include "ecc-192.h"
&gt; +#include "ecc-secp192r1.h"
&gt; 
&gt; #if HAVE_NATIVE_ecc_192_modp
&gt; 
&gt; diff --git a/ecc-224.c b/ecc-secp224r1.c
&gt; similarity index 98%
&gt; rename from ecc-224.c
&gt; rename to ecc-secp224r1.c
&gt; index bf90f848c1b2..4d82f54b57fd 100644
&gt; --- a/ecc-224.c
&gt; +++ b/ecc-secp224r1.c
&gt; @@ -1,4 +1,4 @@
&gt; -/* ecc-224.c
&gt; +/* ecc-secp224r1.c
&gt; 
&gt; Compile time constant (but machine dependent) tables.
&gt; 
&gt; @@ -52,7 +52,7 @@ ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp);
&gt; #define ecc_224_modp ecc_mod
&gt; #endif
&gt; 
&gt; -#include "ecc-224.h"
&gt; +#include "ecc-secp224r1.h"
&gt; 
&gt; #if ECC_REDC_SIZE &lt; 0
&gt; # define ecc_224_redc ecc_pm1_redc
&gt; diff --git a/ecc-256.c b/ecc-secp256r1.c
&gt; similarity index 99%
&gt; rename from ecc-256.c
&gt; rename to ecc-secp256r1.c
&gt; index 3e6ae4e2a8b6..7b873b5f7724 100644
&gt; --- a/ecc-256.c
&gt; +++ b/ecc-secp256r1.c
&gt; @@ -1,4 +1,4 @@
&gt; -/* ecc-256.c
&gt; +/* ecc-secp256r1.c
&gt; 
&gt; Compile time constant (but machine dependent) tables.
&gt; 
&gt; @@ -48,7 +48,7 @@
&gt; # define USE_REDC (ECC_REDC_SIZE != 0)
&gt; #endif
&gt; 
&gt; -#include "ecc-256.h"
&gt; +#include "ecc-secp256r1.h"
&gt; 
&gt; #if HAVE_NATIVE_ecc_256_redc
&gt; # define ecc_256_redc nettle_ecc_256_redc
&gt; diff --git a/ecc-384.c b/ecc-secp384r1.c
&gt; similarity index 99%
&gt; rename from ecc-384.c
&gt; rename to ecc-secp384r1.c
&gt; index 5bb2a2476eec..248b1cf3ef2b 100644
&gt; --- a/ecc-384.c
&gt; +++ b/ecc-secp384r1.c
&gt; @@ -1,4 +1,4 @@
&gt; -/* ecc-384.c
&gt; +/* ecc-secp384r1.c
&gt; 
&gt; Compile time constant (but machine dependent) tables.
&gt; 
&gt; @@ -44,7 +44,7 @@
&gt; 
&gt; #define USE_REDC 0
&gt; 
&gt; -#include "ecc-384.h"
&gt; +#include "ecc-secp384r1.h"
&gt; 
&gt; #if HAVE_NATIVE_ecc_384_modp
&gt; #define ecc_384_modp nettle_ecc_384_modp
&gt; diff --git a/ecc-521.c b/ecc-secp521r1.c
&gt; similarity index 98%
&gt; rename from ecc-521.c
&gt; rename to ecc-secp521r1.c
&gt; index 8ca0e6d2dd64..cc7473035cff 100644
&gt; --- a/ecc-521.c
&gt; +++ b/ecc-secp521r1.c
&gt; @@ -1,4 +1,4 @@
&gt; -/* ecc-521.c
&gt; +/* ecc-secp521r1.c
&gt; 
&gt; Compile time constant (but machine dependent) tables.
&gt; 
&gt; @@ -42,7 +42,7 @@
&gt; 
&gt; #define USE_REDC 0
&gt; 
&gt; -#include "ecc-521.h"
&gt; +#include "ecc-secp521r1.h"
&gt; 
&gt; #if HAVE_NATIVE_ecc_521_modp
&gt; #define ecc_521_modp nettle_ecc_521_modp
&gt; diff --git a/eccdata.c b/eccdata.c
&gt; index 7cfc33cabc14..243c161a8cb8 100644
&gt; --- a/eccdata.c
&gt; +++ b/eccdata.c
&gt; @@ -386,11 +386,10 @@ ecc_curve_init_str (struct ecc_curve *ecc, enum ecc_type \
&gt; type, }
&gt; 
&gt; static void
&gt; -ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
&gt; +ecc_curve_init (struct ecc_curve *ecc, const char *curve)
&gt; {
&gt; -  switch (bit_size)
&gt; +  if (!strcmp (curve, "secp192r1"))
&gt; {
&gt; -    case 192:
&gt; ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
&gt; /* p = 2^{192} - 2^{64} - 1 */
&gt; "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE"
&gt; @@ -420,8 +419,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
&gt; "35433907297cc378b0015703374729d7a4fe46647084e4ba",
&gt; "a2649984f2135c301ea3acb0776cd4f125389b311db3be32");
&gt; 
&gt; -      break;
&gt; -    case 224:
&gt; +    }
&gt; +  else if (!strcmp (curve, "secp224r1"))
&gt; +    {
&gt; ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
&gt; /* p = 2^{224} - 2^{96} + 1 */
&gt; "ffffffffffffffffffffffffffffffff"
&gt; @@ -452,8 +452,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
&gt; "ae99feebb5d26945b54892092a8aee02912930fa41cd114e40447301",
&gt; "482580a0ec5bc47e88bc8c378632cd196cb3fa058a7114eb03054c9");
&gt; 
&gt; -      break;
&gt; -    case 256:
&gt; +    }
&gt; +  else if (!strcmp (curve, "secp256r1"))
&gt; +    {
&gt; ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
&gt; /* p = 2^{256} - 2^{224} + 2^{192} + 2^{96} - 1 */
&gt; "FFFFFFFF000000010000000000000000"
&gt; @@ -484,8 +485,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
&gt; "e2534a3532d08fbba02dde659ee62bd0031fe2db785596ef509302446b030852",
&gt; "e0f1575a4c633cc719dfee5fda862d764efc96c3f30ee0055c42c23f184ed8c6");
&gt; 
&gt; -      break;
&gt; -    case 384:
&gt; +    }
&gt; +  else if (!strcmp (curve, "secp384r1"))
&gt; +    {
&gt; ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
&gt; /* p = 2^{384} - 2^{128} - 2^{96} + 2^{32} - 1 */
&gt; "ffffffffffffffffffffffffffffffff"
&gt; @@ -521,8 +523,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
&gt; "138251cd52ac9298c1c8aad977321deb97e709bd0b4ca0aca55dc8ad51dcfc9d1589a1597e3a5120e1efd631c63e1835",
&gt;  "cacae29869a62e1631e8a28181ab56616dc45d918abc09f3ab0e63cf792aa4dced7387be37bba569549f1c02b270ed67");
&gt;  
&gt; -      break;
&gt; -    case 521:
&gt; +    }
&gt; +  else if (!strcmp (curve, "secp521r1"))
&gt; +    {
&gt; ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
&gt; "1ff" /* p = 2^{521} - 1 */
&gt; "ffffffffffffffffffffffffffffffff"
&gt; @@ -567,9 +570,15 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
&gt; "35b5df64ae2ac204c354b483487c9070cdc61c891c5ff39afc06c5d55541d3ceac8659e24afe3d0750e8b88e9f078af066a1d5025b08e5a5e2fbc87412871902f3",
&gt;  "82096f84261279d2b673e0178eb0b4abb65521aef6e6e32e1b5ae63fe2f19907f279f283e54ba385405224f750a95b85eebb7faef04699d1d9e21f47fc346e4d0d");
&gt;  
&gt; -      break;
&gt; -    case 255:
&gt; -      /* Edwards curve used for eddsa25519 and curve25519,
&gt; +    }
&gt; +  else if (!strcmp (curve, "curve25519"))
&gt; +    {
&gt; +      /* curve25519, y^2 = x^3 + 486662 x^2 + x (mod p), with p = 2^{255} - 19.
&gt; +
&gt; +        According to http://cr.yp.to/papers.html#newelliptic, this
&gt; +        is birationally equivalent to the Edwards curve
&gt; +
&gt; +          x^2 + y^2 = 1 + (121665/121666) x^2 y^2 (mod p).
&gt; 
&gt; -x^2 + y^2 = 1 - (121665/121666) x^2 y^2, with p = 2^{255} - 19.
&gt; 
&gt; @@ -618,13 +627,13 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
&gt; "1a739ec193ce1547493aa657c4c9f870",
&gt; "47d0e827cb1595e1470eb88580d5716c"
&gt; "4cf22832ea2f0ff0df38ab61ca32112f");
&gt; -      break;
&gt; -
&gt; -    default:
&gt; -      fprintf (stderr, "No known curve for size %d\n", bit_size);
&gt; -      exit(EXIT_FAILURE);
&gt; }
&gt; -  ecc-&gt;bit_size = bit_size;
&gt; +  else
&gt; +    {
&gt; +      fprintf (stderr, "No known curve with name %s\n", curve);
&gt; +      exit(EXIT_FAILURE);
&gt; +    }
&gt; +  ecc-&gt;bit_size = mpz_sizeinbase (ecc-&gt;p, 2);
&gt; }
&gt; 
&gt; static void
&gt; @@ -1184,7 +1193,7 @@ main (int argc, char **argv)
&gt; return EXIT_FAILURE;
&gt; }
&gt; 
&gt; -  ecc_curve_init (&amp;ecc, atoi(argv[1]));
&gt; +  ecc_curve_init (&amp;ecc, argv[1]);
&gt; 
&gt; ecc_pippenger_precompute (&amp;ecc, atoi(argv[2]), atoi(argv[3]));
&gt; 
&gt; diff --git a/x86_64/ecc-25519-modp.asm b/x86_64/ecc-curve25519-modp.asm
&gt; similarity index 100%
&gt; rename from x86_64/ecc-25519-modp.asm
&gt; rename to x86_64/ecc-curve25519-modp.asm
&gt; diff --git a/x86_64/ecc-192-modp.asm b/x86_64/ecc-secp192r1-modp.asm
&gt; similarity index 100%
&gt; rename from x86_64/ecc-192-modp.asm
&gt; rename to x86_64/ecc-secp192r1-modp.asm
&gt; diff --git a/x86_64/ecc-224-modp.asm b/x86_64/ecc-secp224r1-modp.asm
&gt; similarity index 100%
&gt; rename from x86_64/ecc-224-modp.asm
&gt; rename to x86_64/ecc-secp224r1-modp.asm
&gt; diff --git a/x86_64/ecc-256-redc.asm b/x86_64/ecc-secp256r1-redc.asm
&gt; similarity index 100%
&gt; rename from x86_64/ecc-256-redc.asm
&gt; rename to x86_64/ecc-secp256r1-redc.asm
&gt; diff --git a/x86_64/ecc-384-modp.asm b/x86_64/ecc-secp384r1-modp.asm
&gt; similarity index 100%
&gt; rename from x86_64/ecc-384-modp.asm
&gt; rename to x86_64/ecc-secp384r1-modp.asm
&gt; diff --git a/x86_64/ecc-521-modp.asm b/x86_64/ecc-secp521r1-modp.asm
&gt; similarity index 100%
&gt; rename from x86_64/ecc-521-modp.asm
&gt; rename to x86_64/ecc-secp521r1-modp.asm
&gt; --
&gt; 2.24.0
&gt; 


-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20191204221143</emailId><senderName>George Koehler</senderName><senderEmail>kernigh@gmail.com</senderEmail><timestampReceived>2019-12-04 22:11:43-0400</timestampReceived><subject>patch: fix check for __builtin_bswap64</subject><body>

(Sending this a 2nd time, after I joined the list.)

For the Nettle crypto library:

If the C compiler lacks __builtin_bswap64, then Nettle may call a
function named __builtin_bswap64 and get a link error.  The problem is
that ./configure doesn't check for link errors.  I append a small diff
to switch from AC_TRY_COMPILE to AC_TRY_LINK.

OpenBSD, on some unusual hardware platforms, still uses GCC 4.2.1, which
doesn't have __builtin_bswap64.  Manphiz reported to OpenBSD that the
build of Nettle 3.5.1 failed on mips64el/longsoon hardware:
https://marc.info/?l=openbsd-ports&amp;m=157510504817444&amp;w=2

The error was "undefined reference to `__builtin_bswap64'".

Nettle only uses __builtin_bswap64 (in ctr.c) on little-endian hardware.
The error didn't happen when OpenBSD built Nettle with GCC 4.2.1 on
big-endian platforms, like powerpc/macppc.

In traditional C, you never needed to declare functions if their return
type was int.  C code like `whatever(11, "a string")` would implicitly
declare `int whatever();`.  Likewise, if __builtin_bswap64 isn't a
built-in, then `__builtin_bswap64(x)` in ./configure does implicitly
declare `int __builtin_bswap64();` as a function.  AC_TRY_COMPILE can
compile this function call, but AC_TRY_LINK can't link it.

OpenBSD decided to patch ./configure to do a link test:
https://cvsweb.openbsd.org/cgi-bin/cvsweb/ports/security/libnettle/patches/patch-configure?rev=1.9&amp;content-type=text/x-cvsweb-markup


The below diff is for configure.ac in Nettle git master cdbbe64.  After
I made this change, I ran ./.bootstrap and checked the build on my
OpenBSD powerpc/macppc machine with GCC 4.2.1:

$ ../configure --disable-documentation \
&gt; CPPFLAGS=-I/usr/local/include LDFLAGS=-L/usr/local/lib
$ gmake
$ gmake check

(The --disable-documentation prevents an error from makeinfo 4.8, which
seems too old.  The FLAGS find gmp in /usr/local, because OpenBSD's
compilers don't look there by default.  gmake is GNU make.)

The build got "All 99 tests passed", then "All 3 tests passed".
config.log shows that "checking for __builtin_bswap64" failed with the
"undefined reference" error.  --George

diff --git a/configure.ac b/configure.ac
index 3547cae4..7ac84f2e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -213,7 +213,7 @@ AC_C_BIGENDIAN([AC_DEFINE([WORDS_BIGENDIAN], 1)
 
 AC_CACHE_CHECK([for __builtin_bswap64],
 		nettle_cv_c_builtin_bswap64,
-[AC_TRY_COMPILE([
+[AC_TRY_LINK([
 #include &lt;stdint.h&gt;
 ],[
 uint64_t x = 17;
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20191210205223</emailId><senderName>johnjmar</senderName><senderEmail>johnjmar@linux.vnet.ibm.com</senderEmail><timestampReceived>2019-12-10 20:52:23-0400</timestampReceived><subject>post-quantum crypto algorithms implementation</subject><body>

Hello,
Are there any plans for post-quantum algorithms implementation in the 
library?
Given the current state of quantum computing development, and (please 
correct me if I'm wrong) the vulnerability of public key exchange (RSA, 
ECDSA) given the former, I'm curious to see if anyone can share their 
plans. I was also looking at the following, for reference: 
https://pq-crystals.org/.

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191225113121</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-25 11:31:21-0400</timestampReceived><subject>Re: [PATCH v2 3/6] nettle-meta: Add meta interface for HMAC functions</subject><body>

Daiki Ueno &lt;ueno@gnu.org&gt; writes:

&gt; +static void
&gt; +hmac_md5_set_key_wrapper (void *ctx, const uint8_t *key)
&gt; +{
&gt; +  hmac_md5_set_key (ctx, MD5_BLOCK_SIZE, key);
&gt; +}

[...]

&gt; +extern const struct nettle_mac nettle_hmac_md5;
&gt; +extern const struct nettle_mac nettle_hmac_ripemd160;
&gt; +extern const struct nettle_mac nettle_hmac_sha1;
&gt; +extern const struct nettle_mac nettle_hmac_sha224;
&gt; +extern const struct nettle_mac nettle_hmac_sha256;
&gt; +extern const struct nettle_mac nettle_hmac_sha384;
&gt; +extern const struct nettle_mac nettle_hmac_sha512;

If we define a single nettle_mac for each supported (no-nonce) mac
algorithm, what should the key size be for each algorithm? Using the
underlying block size for the hmac algorithms seems to be a bit
overkill. What key sizes are used in practice? Does it make sense to
use key size equal to digest size (at least, that's what used for hmac
in the ssh protocol)? 

My current plan is to first add struct nettle_mac as an interface for no-nonce
macs. And then add a different struct for macs requiring a per-message nonce.
struct nettle_nmac was suggested, any better name for this?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191211074650</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-11 07:46:50-0400</timestampReceived><subject>Re: post-quantum crypto algorithms implementation</subject><body>

johnjmar &lt;johnjmar@linux.vnet.ibm.com&gt; writes:

&gt; Are there any plans for post-quantum algorithms implementation in the
&gt; library?

No concrete plans, I'm afraid. Nettle is not close to the research
frontier; a new algorithm is usually added when there's some consensus
that it is are secure (after a few rounds of public cryptanalysis) and
it starts to appear in standards. Most crypto algorithms have weaknesses
when first proposed.

I think more or less the same will apply to new post-quantum algorithms.

If you (or anyone else on the list) are following research, I'd be happy
to hear what algorithms or approaches you think are promising.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191205080757</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-05 08:07:57-0400</timestampReceived><subject>Re: patch: fix check for __builtin_bswap64</subject><body>

George Koehler &lt;kernigh@gmail.com&gt; writes:

&gt; If the C compiler lacks __builtin_bswap64, then Nettle may call a
&gt; function named __builtin_bswap64 and get a link error.  The problem is
&gt; that ./configure doesn't check for link errors.  I append a small diff
&gt; to switch from AC_TRY_COMPILE to AC_TRY_LINK.

Thanks, applied!

&gt; $ ../configure --disable-documentation \
&gt;&gt; CPPFLAGS=-I/usr/local/include LDFLAGS=-L/usr/local/lib
&gt; $ gmake
&gt; $ gmake check
&gt;
&gt; (The --disable-documentation prevents an error from makeinfo 4.8, which
&gt; seems too old.  The FLAGS find gmp in /usr/local, because OpenBSD's
&gt; compilers don't look there by default.  gmake is GNU make.)

Does OpenBSBs runtime linker look in /usr/local/lib by default? The
configure script also supports --with-lib-path=/usr/local/lib, which
will add a -L flag and in addition attempt to guess the proper
-R/-Wl,-rpath flags.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191205082019</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2019-12-05 08:20:19-0400</timestampReceived><subject>Re: patch: fix check for __builtin_bswap64</subject><body>

On Thu, Dec 5, 2019 at 3:08 AM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; ...
&gt;
&gt; Does OpenBSBs runtime linker look in /usr/local/lib by default? The
&gt; configure script also supports --with-lib-path=/usr/local/lib, which
&gt; will add a -L flag and in addition attempt to guess the proper
&gt; -R/-Wl,-rpath flags.

The runtime linker is configured to use /usr/local/lib. However,
compile and link requires explicit -I /usr/local/include and -L
/usr/local/lib to find things.

(Based on my testing of DragonFly, FreeBSD, OpenBSD and NetBSD. I
don't recall what Debian's kFreeBSD does).

Jeff
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191205160047</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-12-05 16:00:47-0400</timestampReceived><subject>Re: [PATCH] ecc: rename source files with curves data</subject><body>

Hello,

чт, 5 дек. 2019 г. в 18:45, Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;:
&gt;
&gt; Any feedback on this change?
&gt;
&gt; I'm going to send patches adding 3 256-bit curves and 2 512-bit curves
&gt; with another 256-bit and 512-bit curves waiting some restructuring of
&gt; the code.
&gt; It would be too easy to mix curves w/o this patch.

I'll send v2 rebased on top of curve448 branch.

&gt;
&gt; вс, 24 нояб. 2019 г. в 17:22, &lt;dbaryshkov@gmail.com&gt;:
&gt; &gt;
&gt; &gt; From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt; &gt;
&gt; &gt; In preparation to adding GOST curves support, rename source files and
&gt; &gt; use curve name as eccdata parameter.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191204220446</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-04 22:04:46-0400</timestampReceived><subject>Re: [RFC] ecc: switch away from affine points representation</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; E.g., ecc_point_mul takes a const struct ecc_point as input, and calls
&gt; ecc-&gt;mul, which for the standard weierstrass curves is ecc_mul_a. This
&gt; one is a loop including a call to ecc_add_jja, which assumes that the z
&gt; coordinate is one. 

Sorry, looked at the wrong implementation of ecc_mul_a. ecc_add_jja is
used in the *main loop* only if

  ECC_MUL_A_WBITS == 0

However, when ECC_MUL_A_WBITS &gt; 0 (currently set to 4), ecc_add_jja is
still used in the table_init function.

So being able to require that z == 1 is still beneficial.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191205000435</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-12-05 00:04:35-0400</timestampReceived><subject>Re: [RFC] ecc: switch away from affine points representation</subject><body>

Hello,

чт, 5 дек. 2019 г. в 00:18, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; dbaryshkov@gmail.com writes:
&gt;
&gt; &gt; From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt; &gt;
&gt; &gt; Use jacobian/harmonized representation in ecc_point structure.
&gt;
&gt; Can you explain what benefit you see from this?

Well, I've had two particular GOST curves in mind. They are defined in
Weierstrass form, but have birationally equal Edwards curves that can
be used for point addition. Converting to/from Edwards form during
each operation doesn't look like a good solution.

&gt; E.g., ecc_point_mul takes a const struct ecc_point as input, and calls
&gt; ecc-&gt;mul, which for the standard weierstrass curves is ecc_mul_a. This
&gt; one is a loop including a call to ecc_add_jja, which assumes that the z
&gt; coordinate is one.
&gt;
&gt; (ecc_mul_a also calls ecc_a_to_j, which appears to write a z = 1
&gt; coordinate, in montgomery representation if appropriate. Even though the
&gt; z coordinate is not used in this case. Maybe no callers of ecc_a_to_j
&gt; needs the z coordiante? Needs some investigation. Reading the code a few
&gt; years after it was written I wish I had been more thorough with
&gt; documenting details input and output assumptions).
&gt;
&gt; Doing ecc_point_mul starting with a point represented as (X, Y, Z) where
&gt; Z is arbitrary will be slower, since it needs to take one more
&gt; coordinate into account in the point addition.
&gt;
&gt; It could be useful to work exclusively with jacobian or homogeneous
&gt; coordinates if you want to make a series of operations on points, and
&gt; only convert back to affine at the very end. But I'd like to see a clear
&gt; use case before trying to optimize for that.


&gt;
&gt; &gt; diff --git a/ecc-a-to-j.c b/ecc-a-to-j.c
&gt; &gt; index 9fb0d2b80c41..895502e0fe20 100644
&gt; &gt; --- a/ecc-a-to-j.c
&gt; &gt; +++ b/ecc-a-to-j.c
&gt; &gt; @@ -40,11 +40,12 @@
&gt; &gt;
&gt; &gt;  void
&gt; &gt;  ecc_a_to_j (const struct ecc_curve *ecc,
&gt; &gt; -         mp_limb_t *r, const mp_limb_t *p)
&gt; &gt; +         mp_limb_t *r, const mpz_t x, const mpz_t y)
&gt; &gt;  {
&gt; &gt;    if (ecc-&gt;use_redc)
&gt; &gt;      {
&gt; &gt; -      mpn_copyd (r + ecc-&gt;p.size, p, 2*ecc-&gt;p.size);
&gt; &gt; +      mpz_limbs_copy (r + ecc-&gt;p.size, x, ecc-&gt;p.size);
&gt; &gt; +      mpz_limbs_copy (r + 2 * ecc-&gt;p.size, y, ecc-&gt;p.size);
&gt;
&gt; I don't think we should use the mpz_t type in internal ecc functions.
&gt; mpz_limbs_copy is not side-channnel silent, since organization of
&gt; storage inside mpz_t is different depending on the leading bits.

Hmm, I don't see how mpz_t internal representation can be a threat.
Also this function becomes less internal now, as it is called only
from ecc_point_set().

If you wish, I can change a_to_j to copy available limbs and zero-fill
rest of limbs instead of using mpz_t/mpz_limbs_copy().

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191205071504</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-12-05 07:15:04-0400</timestampReceived><subject>Re: [RFC] ecc: switch away from affine points representation</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; Well, I've had two particular GOST curves in mind. They are defined in
&gt; Weierstrass form, but have birationally equal Edwards curves that can
&gt; be used for point addition.

And to do that conversion without an expensive modular inversion, you
get a Z != 1?

It might make sense to to more work in ecc_point_set, but I'd prefer to
not introduce a Z cooordinate for the current weierstrass curves.

&gt; Converting to/from Edwards form during each operation doesn't look
&gt; like a good solution.

And what are those operations? ecdsa_verify? I agree it's not ideal to
have that function do the coordinate conversion every time. On the other
hand, conversion may be very cheap compared to the two scalar
multiplications done by ecdsa_verify. I think I'd prefer to postpone
that optimization.

(For your curves, you may need a slightly different ecc_mul function to
support Z != 1, same loop but different table_init).

&gt; Hmm, I don't see how mpz_t internal representation can be a threat.

In this case, maybe not (in particular if it's for ecdsa_verify, with no
secret inputs). But in general, practically any mpz_t operation on a
number of nominally n bits will leak information on whether or not most
significant bits are all zero.

That's why I prefer to use mpz_t only in the public api (and even there,
it might be preferable to use octet strings of predetermined length,
just like for the curve25519 operations). Depending on applications'
needs.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191205074927</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-12-05 07:49:27-0400</timestampReceived><subject>Re: [RFC] ecc: switch away from affine points representation</subject><body>

Hello,

чт, 5 дек. 2019 г., 8:15 Niels Möller &lt;nisse@lysator.liu.se&gt;:

&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; Well, I've had two particular GOST curves in mind. They are defined in
&gt; &gt; Weierstrass form, but have birationally equal Edwards curves that can
&gt; &gt; be used for point addition.
&gt;
&gt; And to do that conversion without an expensive modular inversion, you
&gt; get a Z != 1?
&gt;


This conversion will take place at each a_to_h call. More importantly the
conversion at h_to_a will include modular inversion. So I wanted to lower
the amount of such conversions.


&gt; It might make sense to to more work in ecc_point_set, but I'd prefer to
&gt; not introduce a Z cooordinate for the current weierstrass curves.
&gt;

Would it be ok to change ecc_point size to become a per curve option?

&gt;
&gt;
&gt; &gt; Converting to/from Edwards form during each operation doesn't look
&gt; &gt; like a good solution.
&gt;
&gt; And what are those operations? ecdsa_verify? I agree it's not ideal to
&gt;


A close rival to ecdsa sign/verify (see rfc 7091 and 5832).

have that function do the coordinate conversion every time. On the other
&gt; hand, conversion may be very cheap compared to the two scalar
&gt; multiplications done by ecdsa_verify. I think I'd prefer to postpone
&gt; that optimization.
&gt;

No problem, I'll submit then the next round of patches without this one.


&gt; (For your curves, you may need a slightly different ecc_mul function to
&gt; support Z != 1, same loop but different table_init).
&gt;

And ecc point memory size. And adjusting tests that use low-level
representation.


&gt; &gt; Hmm, I don't see how mpz_t internal representation can be a threat.
&gt;
&gt; In this case, maybe not (in particular if it's for ecdsa_verify, with no
&gt; secret inputs). But in general, practically any mpz_t operation on a
&gt; number of nominally n bits will leak information on whether or not most
&gt; significant bits are all zero.
&gt;


Again, in this case it concerns only public key being converted to an
internal representation.


&gt; That's why I prefer to use mpz_t only in the public api (and even there,
&gt; it might be preferable to use octet strings of predetermined length,
&gt; just like for the curve25519 operations). Depending on applications'
&gt; needs.
&gt;
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191124142156</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-11-24 14:21:56-0400</timestampReceived><subject>[PATCH] ecc: rename source files with curves data</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

In preparation to adding GOST curves support, rename source files and
use curve name as eccdata parameter.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 .gitignore                                    | 12 ++---
 Makefile.in                                   | 45 ++++++++--------
 ...cc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} |  0
 ...cc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} |  0
 ...cc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} |  0
 ...cc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} |  0
 ...cc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} |  0
 configure.ac                                  |  5 +-
 ecc-25519.c =&gt; ecc-curve25519.c               |  4 +-
 ecc-192.c =&gt; ecc-secp192r1.c                  |  4 +-
 ecc-224.c =&gt; ecc-secp224r1.c                  |  4 +-
 ecc-256.c =&gt; ecc-secp256r1.c                  |  4 +-
 ecc-384.c =&gt; ecc-secp384r1.c                  |  4 +-
 ecc-521.c =&gt; ecc-secp521r1.c                  |  4 +-
 eccdata.c                                     | 51 +++++++++++--------
 ...25519-modp.asm =&gt; ecc-curve25519-modp.asm} |  0
 ...cc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} |  0
 ...cc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} |  0
 ...cc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} |  0
 ...cc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} |  0
 ...cc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} |  0
 21 files changed, 74 insertions(+), 63 deletions(-)
 rename arm/{ecc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} (100%)
 rename arm/{ecc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} (100%)
 rename arm/{ecc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} (100%)
 rename arm/{ecc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} (100%)
 rename arm/{ecc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} (100%)
 rename ecc-25519.c =&gt; ecc-curve25519.c (99%)
 rename ecc-192.c =&gt; ecc-secp192r1.c (98%)
 rename ecc-224.c =&gt; ecc-secp224r1.c (98%)
 rename ecc-256.c =&gt; ecc-secp256r1.c (99%)
 rename ecc-384.c =&gt; ecc-secp384r1.c (99%)
 rename ecc-521.c =&gt; ecc-secp521r1.c (98%)
 rename x86_64/{ecc-25519-modp.asm =&gt; ecc-curve25519-modp.asm} (100%)
 rename x86_64/{ecc-192-modp.asm =&gt; ecc-secp192r1-modp.asm} (100%)
 rename x86_64/{ecc-224-modp.asm =&gt; ecc-secp224r1-modp.asm} (100%)
 rename x86_64/{ecc-256-redc.asm =&gt; ecc-secp256r1-redc.asm} (100%)
 rename x86_64/{ecc-384-modp.asm =&gt; ecc-secp384r1-modp.asm} (100%)
 rename x86_64/{ecc-521-modp.asm =&gt; ecc-secp521r1-modp.asm} (100%)

diff --git a/.gitignore b/.gitignore
index b79c53f535ff..be10fbe959cc 100644
--- a/.gitignore
+++ b/.gitignore
@@ -43,12 +43,12 @@ core
 /keymap.h
 /parity.h
 /rotors.h
-/ecc-192.h
-/ecc-224.h
-/ecc-256.h
-/ecc-384.h
-/ecc-521.h
-/ecc-25519.h
+/ecc-curve25519.h
+/ecc-secp192r1.h
+/ecc-secp224r1.h
+/ecc-secp256r1.h
+/ecc-secp384r1.h
+/ecc-secp521r1.h
 /version.h
 /nettle.aux
 /nettle.cp
diff --git a/Makefile.in b/Makefile.in
index 9f5b065a706a..89066ec6c3c2 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -174,8 +174,8 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  gmp-glue.c cnd-copy.c \
 		  ecc-mod.c ecc-mod-inv.c \
 		  ecc-mod-arith.c ecc-pp1-redc.c ecc-pm1-redc.c \
-		  ecc-192.c ecc-224.c ecc-256.c ecc-384.c ecc-521.c \
-		  ecc-25519.c \
+		  ecc-curve25519.c ecc-secp192r1.c ecc-secp224r1.c \
+		  ecc-secp256r1.c ecc-secp384r1.c ecc-secp521r1.c \
 		  ecc-size.c ecc-j-to-a.c ecc-a-to-j.c \
 		  ecc-dup-jj.c ecc-add-jja.c ecc-add-jjj.c \
 		  ecc-eh-to-a.c \
@@ -345,24 +345,24 @@ des.$(OBJEXT): des.c des.h $(des_headers)
 # k = 14, c =  7, S = 256, T =  42 ( 28 A + 14 D) 12 KB
 # k = 11, c =  6, S = 192, T =  44 ( 33 A + 11 D)  9 KB
 # k = 16, c =  6, S = 128, T =  48 ( 32 A + 16 D)  6 KB
-ecc-192.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 192 8 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp192r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp192r1 8 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 224:
 # k = 16, c =  7, S = 256, T =  48 ( 32 A + 16 D) ~16 KB
 # k = 10, c =  6, S = 256, T =  50 ( 40 A + 10 D) ~16 KB
 # k = 13, c =  6, S = 192, T =  52 ( 39 A + 13 D) ~12 KB
 # k =  9, c =  5, S = 160, T =  54 ( 45 A +  9 D) ~10 KB
-ecc-224.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 224 16 7 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp224r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp224r1 16 7 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 256:
 # k =  9, c =  6, S = 320, T =  54 ( 45 A +  9 D) 20 KB
 # k = 11, c =  6, S = 256, T =  55 ( 44 A + 11 D) 16 KB
 # k = 19, c =  7, S = 256, T =  57 ( 38 A + 19 D) 16 KB
 # k = 15, c =  6, S = 192, T =  60 ( 45 A + 15 D) 12 KB
-ecc-256.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 256 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp256r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp256r1 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 384:
 # k = 16, c =  6, S = 256, T =  80 ( 64 A + 16 D) 24 KB
@@ -372,31 +372,31 @@ ecc-256.h: eccdata.stamp
 # k = 13, c =  5, S = 192, T =  91 ( 78 A + 13 D) 18 KB
 # k = 16, c =  5, S = 160, T =  96 ( 80 A + 16 D) 15 KB
 # k = 32, c =  6, S = 128, T =  96 ( 64 A + 32 D) 12 KB
-ecc-384.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 384 32 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp384r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp384r1 32 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 # Some reasonable choices for 521:
 # k = 29, c =  6, S = 192, T = 116 ( 87 A + 29 D) ~27 KB
 # k = 21, c =  5, S = 160, T = 126 (105 A + 21 D) ~23 KB
 # k = 44, c =  6, S = 128, T = 132 ( 88 A + 44 D) ~18 KB
 # k = 35, c =  5, S =  96, T = 140 (105 A + 35 D) ~14 KB
-ecc-521.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 521 44 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+ecc-secp521r1.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) secp521r1 44 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
-# Parameter choices mostly the same as for ecc-256.h.
-ecc-25519.h: eccdata.stamp
-	./eccdata$(EXEEXT_FOR_BUILD) 255 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
+# Parameter choices mostly the same as for ecc-secp256r1.h.
+ecc-curve25519.h: eccdata.stamp
+	./eccdata$(EXEEXT_FOR_BUILD) curve25519 11 6 $(NUMB_BITS) &gt; $@T &amp;&amp; mv $@T $@
 
 eccdata.stamp: eccdata.c
 	$(MAKE) eccdata$(EXEEXT_FOR_BUILD)
 	echo stamp &gt; eccdata.stamp
 
-ecc-192.$(OBJEXT): ecc-192.h
-ecc-224.$(OBJEXT): ecc-224.h
-ecc-256.$(OBJEXT): ecc-256.h
-ecc-384.$(OBJEXT): ecc-384.h
-ecc-521.$(OBJEXT): ecc-521.h
-ecc-25519.$(OBJEXT): ecc-25519.h
+ecc-curve25519.$(OBJEXT): ecc-curve25519.h
+ecc-secp192r1.$(OBJEXT): ecc-secp192r1.h
+ecc-secp224r1.$(OBJEXT): ecc-secp224r1.h
+ecc-secp256r1.$(OBJEXT): ecc-secp256r1.h
+ecc-secp384r1.$(OBJEXT): ecc-secp384r1.h
+ecc-secp521r1.$(OBJEXT): ecc-secp521r1.h
 
 .asm.$(OBJEXT): $(srcdir)/asm.m4 machine.m4 config.m4
 	$(M4) $(srcdir)/asm.m4 machine.m4 config.m4 $&lt; &gt;$*.s
@@ -649,7 +649,8 @@ distcheck: dist
 
 clean-here:
 	-rm -f $(TARGETS) *.$(OBJEXT) *.s *.so *.dll *.a \
-		ecc-192.h ecc-224.h ecc-256.h ecc-384.h ecc-521.h ecc-25519.h \
+		ecc-curve25519.h ecc-secp192r1.h ecc-secp224r1.h ecc-secp256r1.h \
+		ecc-secp384r1.h ecc-secp521r1.h \
 		aesdata$(EXEEXT_FOR_BUILD) \
 		desdata$(EXEEXT_FOR_BUILD) \
 		twofishdata$(EXEEXT_FOR_BUILD) \
diff --git a/arm/ecc-192-modp.asm b/arm/ecc-secp192r1-modp.asm
similarity index 100%
rename from arm/ecc-192-modp.asm
rename to arm/ecc-secp192r1-modp.asm
diff --git a/arm/ecc-224-modp.asm b/arm/ecc-secp224r1-modp.asm
similarity index 100%
rename from arm/ecc-224-modp.asm
rename to arm/ecc-secp224r1-modp.asm
diff --git a/arm/ecc-256-redc.asm b/arm/ecc-secp256r1-redc.asm
similarity index 100%
rename from arm/ecc-256-redc.asm
rename to arm/ecc-secp256r1-redc.asm
diff --git a/arm/ecc-384-modp.asm b/arm/ecc-secp384r1-modp.asm
similarity index 100%
rename from arm/ecc-384-modp.asm
rename to arm/ecc-secp384r1-modp.asm
diff --git a/arm/ecc-521-modp.asm b/arm/ecc-secp521r1-modp.asm
similarity index 100%
rename from arm/ecc-521-modp.asm
rename to arm/ecc-secp521r1-modp.asm
diff --git a/configure.ac b/configure.ac
index 3547cae4ee15..cbc914dbf14b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -475,8 +475,9 @@ asm_nettle_optional_list="gcm-hash8.asm cpuid.asm \
 
 asm_hogweed_optional_list=""
 if test "x$enable_public_key" = "xyes" ; then
-  asm_hogweed_optional_list="ecc-192-modp.asm ecc-224-modp.asm \
-    ecc-25519-modp.asm ecc-256-redc.asm ecc-384-modp.asm ecc-521-modp.asm"
+  asm_hogweed_optional_list="ecc-curve25519-modp.asm \
+    ecc-secp192r1-modp.asm ecc-secp224r1-modp.asm \
+    ecc-secp256r1-redc.asm ecc-secp384r1-modp.asm ecc-secp521r1-modp.asm"
 fi
 
 OPT_NETTLE_OBJS=""
diff --git a/ecc-25519.c b/ecc-curve25519.c
similarity index 99%
rename from ecc-25519.c
rename to ecc-curve25519.c
index 105ce0f4fbc1..e6a1b325be66 100644
--- a/ecc-25519.c
+++ b/ecc-curve25519.c
@@ -1,4 +1,4 @@
-/* ecc-25519.c
+/* ecc-curve25519.c
 
    Arithmetic and tables for curve25519,
 
@@ -42,7 +42,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-25519.h"
+#include "ecc-curve25519.h"
 
 #define PHIGH_BITS (GMP_NUMB_BITS * ECC_LIMB_SIZE - 255)
 
diff --git a/ecc-192.c b/ecc-secp192r1.c
similarity index 98%
rename from ecc-192.c
rename to ecc-secp192r1.c
index 4b756ffd7e8f..858a1b7554ce 100644
--- a/ecc-192.c
+++ b/ecc-secp192r1.c
@@ -1,4 +1,4 @@
-/* ecc-192.c
+/* ecc-secp192r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -46,7 +46,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-192.h"
+#include "ecc-secp192r1.h"
 
 #if HAVE_NATIVE_ecc_192_modp
 
diff --git a/ecc-224.c b/ecc-secp224r1.c
similarity index 98%
rename from ecc-224.c
rename to ecc-secp224r1.c
index bf90f848c1b2..4d82f54b57fd 100644
--- a/ecc-224.c
+++ b/ecc-secp224r1.c
@@ -1,4 +1,4 @@
-/* ecc-224.c
+/* ecc-secp224r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -52,7 +52,7 @@ ecc_224_modp (const struct ecc_modulo *m, mp_limb_t *rp);
 #define ecc_224_modp ecc_mod
 #endif
 
-#include "ecc-224.h"
+#include "ecc-secp224r1.h"
 
 #if ECC_REDC_SIZE &lt; 0
 # define ecc_224_redc ecc_pm1_redc
diff --git a/ecc-256.c b/ecc-secp256r1.c
similarity index 99%
rename from ecc-256.c
rename to ecc-secp256r1.c
index 3e6ae4e2a8b6..7b873b5f7724 100644
--- a/ecc-256.c
+++ b/ecc-secp256r1.c
@@ -1,4 +1,4 @@
-/* ecc-256.c
+/* ecc-secp256r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -48,7 +48,7 @@
 # define USE_REDC (ECC_REDC_SIZE != 0)
 #endif
 
-#include "ecc-256.h"
+#include "ecc-secp256r1.h"
 
 #if HAVE_NATIVE_ecc_256_redc
 # define ecc_256_redc nettle_ecc_256_redc
diff --git a/ecc-384.c b/ecc-secp384r1.c
similarity index 99%
rename from ecc-384.c
rename to ecc-secp384r1.c
index 5bb2a2476eec..248b1cf3ef2b 100644
--- a/ecc-384.c
+++ b/ecc-secp384r1.c
@@ -1,4 +1,4 @@
-/* ecc-384.c
+/* ecc-secp384r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -44,7 +44,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-384.h"
+#include "ecc-secp384r1.h"
 
 #if HAVE_NATIVE_ecc_384_modp
 #define ecc_384_modp nettle_ecc_384_modp
diff --git a/ecc-521.c b/ecc-secp521r1.c
similarity index 98%
rename from ecc-521.c
rename to ecc-secp521r1.c
index 8ca0e6d2dd64..cc7473035cff 100644
--- a/ecc-521.c
+++ b/ecc-secp521r1.c
@@ -1,4 +1,4 @@
-/* ecc-521.c
+/* ecc-secp521r1.c
 
    Compile time constant (but machine dependent) tables.
 
@@ -42,7 +42,7 @@
 
 #define USE_REDC 0
 
-#include "ecc-521.h"
+#include "ecc-secp521r1.h"
 
 #if HAVE_NATIVE_ecc_521_modp
 #define ecc_521_modp nettle_ecc_521_modp
diff --git a/eccdata.c b/eccdata.c
index 7cfc33cabc14..243c161a8cb8 100644
--- a/eccdata.c
+++ b/eccdata.c
@@ -386,11 +386,10 @@ ecc_curve_init_str (struct ecc_curve *ecc, enum ecc_type type,
 }
 
 static void
-ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
+ecc_curve_init (struct ecc_curve *ecc, const char *curve)
 {
-  switch (bit_size)
+  if (!strcmp (curve, "secp192r1"))
     {
-    case 192:      
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{192} - 2^{64} - 1 */
 			  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE"
@@ -420,8 +419,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "35433907297cc378b0015703374729d7a4fe46647084e4ba",
 		   "a2649984f2135c301ea3acb0776cd4f125389b311db3be32");
 
-      break;
-    case 224:
+    }
+  else if (!strcmp (curve, "secp224r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{224} - 2^{96} + 1 */
 			  "ffffffffffffffffffffffffffffffff"
@@ -452,8 +452,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "ae99feebb5d26945b54892092a8aee02912930fa41cd114e40447301",
 		   "482580a0ec5bc47e88bc8c378632cd196cb3fa058a7114eb03054c9");
 
-      break;
-    case 256:
+    }
+  else if (!strcmp (curve, "secp256r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{256} - 2^{224} + 2^{192} + 2^{96} - 1 */
 			  "FFFFFFFF000000010000000000000000"
@@ -484,8 +485,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "e2534a3532d08fbba02dde659ee62bd0031fe2db785596ef509302446b030852",
 		   "e0f1575a4c633cc719dfee5fda862d764efc96c3f30ee0055c42c23f184ed8c6");
 
-      break;
-    case 384:
+    }
+  else if (!strcmp (curve, "secp384r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  /* p = 2^{384} - 2^{128} - 2^{96} + 2^{32} - 1 */
 			  "ffffffffffffffffffffffffffffffff"
@@ -521,8 +523,9 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "138251cd52ac9298c1c8aad977321deb97e709bd0b4ca0aca55dc8ad51dcfc9d1589a1597e3a5120e1efd631c63e1835",
                
 		   "cacae29869a62e1631e8a28181ab56616dc45d918abc09f3ab0e63cf792aa4dced7387be37bba569549f1c02b270ed67");
  
-      break;
-    case 521:
+    }
+  else if (!strcmp (curve, "secp521r1"))
+    {
       ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,
 			  "1ff" /* p = 2^{521} - 1 */
 			  "ffffffffffffffffffffffffffffffff"
@@ -567,9 +570,15 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "35b5df64ae2ac204c354b483487c9070cdc61c891c5ff39afc06c5d55541d3ceac8659e24afe3d0750e8b88e9f078af066a1d5025b08e5a5e2fbc87412871902f3",
                
 		   "82096f84261279d2b673e0178eb0b4abb65521aef6e6e32e1b5ae63fe2f19907f279f283e54ba385405224f750a95b85eebb7faef04699d1d9e21f47fc346e4d0d");
  
-      break;
-    case 255:
-      /* Edwards curve used for eddsa25519 and curve25519,
+    }
+  else if (!strcmp (curve, "curve25519"))
+    {
+      /* curve25519, y^2 = x^3 + 486662 x^2 + x (mod p), with p = 2^{255} - 19.
+
+	 According to http://cr.yp.to/papers.html#newelliptic, this
+	 is birationally equivalent to the Edwards curve
+
+	   x^2 + y^2 = 1 + (121665/121666) x^2 y^2 (mod p).
 
 	   -x^2 + y^2 = 1 - (121665/121666) x^2 y^2, with p = 2^{255} - 19.
 
@@ -618,13 +627,13 @@ ecc_curve_init (struct ecc_curve *ecc, unsigned bit_size)
 		   "1a739ec193ce1547493aa657c4c9f870",
 		   "47d0e827cb1595e1470eb88580d5716c"
 		   "4cf22832ea2f0ff0df38ab61ca32112f");
-      break;
-
-    default:
-      fprintf (stderr, "No known curve for size %d\n", bit_size);
-      exit(EXIT_FAILURE);     
     }
-  ecc-&gt;bit_size = bit_size;
+  else
+    {
+      fprintf (stderr, "No known curve with name %s\n", curve);
+      exit(EXIT_FAILURE);
+    }
+  ecc-&gt;bit_size = mpz_sizeinbase (ecc-&gt;p, 2);
 }
 
 static void
@@ -1184,7 +1193,7 @@ main (int argc, char **argv)
       return EXIT_FAILURE;
     }
 
-  ecc_curve_init (&amp;ecc, atoi(argv[1]));
+  ecc_curve_init (&amp;ecc, argv[1]);
 
   ecc_pippenger_precompute (&amp;ecc, atoi(argv[2]), atoi(argv[3]));
 
diff --git a/x86_64/ecc-25519-modp.asm b/x86_64/ecc-curve25519-modp.asm
similarity index 100%
rename from x86_64/ecc-25519-modp.asm
rename to x86_64/ecc-curve25519-modp.asm
diff --git a/x86_64/ecc-192-modp.asm b/x86_64/ecc-secp192r1-modp.asm
similarity index 100%
rename from x86_64/ecc-192-modp.asm
rename to x86_64/ecc-secp192r1-modp.asm
diff --git a/x86_64/ecc-224-modp.asm b/x86_64/ecc-secp224r1-modp.asm
similarity index 100%
rename from x86_64/ecc-224-modp.asm
rename to x86_64/ecc-secp224r1-modp.asm
diff --git a/x86_64/ecc-256-redc.asm b/x86_64/ecc-secp256r1-redc.asm
similarity index 100%
rename from x86_64/ecc-256-redc.asm
rename to x86_64/ecc-secp256r1-redc.asm
diff --git a/x86_64/ecc-384-modp.asm b/x86_64/ecc-secp384r1-modp.asm
similarity index 100%
rename from x86_64/ecc-384-modp.asm
rename to x86_64/ecc-secp384r1-modp.asm
diff --git a/x86_64/ecc-521-modp.asm b/x86_64/ecc-secp521r1-modp.asm
similarity index 100%
rename from x86_64/ecc-521-modp.asm
rename to x86_64/ecc-secp521r1-modp.asm
-- 
2.24.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20191124143330</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-11-24 14:33:30-0400</timestampReceived><subject>[RFC] ecc: switch away from affine points representation</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Use jacobian/harmonized representation in ecc_point structure.

This is an RFC patch for now, j_to_a/eh_to_a are not modified to produce
y coordinate only, more tests are necessary most probably.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 ecc-a-to-j.c                    | 12 +++++++----
 ecc-ecdsa-sign.c                |  2 +-
 ecc-ecdsa-verify.c              |  4 ++--
 ecc-eh-to-a.c                   | 17 ++++++++-------
 ecc-internal.h                  | 20 ++++++++++-------
 ecc-j-to-a.c                    | 15 +++++++------
 ecc-mul-a-eh.c                  | 13 +++++------
 ecc-mul-a.c                     | 18 +++++++---------
 ecc-point-mul-g.c               |  8 +++----
 ecc-point-mul.c                 |  2 +-
 ecc-point.c                     | 36 +++++++++++++++++++++++++------
 ecdsa-keygen.c                  |  7 +++---
 eddsa-compress.c                |  2 +-
 eddsa-decompress.c              |  1 +
 eddsa-verify.c                  |  2 +-
 testsuite/ecc-add-test.c        |  5 ++++-
 testsuite/ecc-dup-test.c        | 10 ++++-----
 testsuite/ecc-mul-a-test.c      | 22 ++++++++++++-------
 testsuite/ecc-mul-g-test.c      |  4 ++--
 testsuite/ecdsa-keygen-test.c   | 38 ++++++++++++++++++++++-----------
 testsuite/eddsa-compress-test.c |  8 +++++--
 testsuite/eddsa-verify-test.c   |  2 +-
 testsuite/testutils.c           |  2 +-
 23 files changed, 152 insertions(+), 98 deletions(-)

diff --git a/ecc-a-to-j.c b/ecc-a-to-j.c
index 9fb0d2b80c41..895502e0fe20 100644
--- a/ecc-a-to-j.c
+++ b/ecc-a-to-j.c
@@ -40,11 +40,12 @@
 
 void
 ecc_a_to_j (const struct ecc_curve *ecc,
-	    mp_limb_t *r, const mp_limb_t *p)
+	    mp_limb_t *r, const mpz_t x, const mpz_t y)
 {
   if (ecc-&gt;use_redc)
     {
-      mpn_copyd (r + ecc-&gt;p.size, p, 2*ecc-&gt;p.size);
+      mpz_limbs_copy (r + ecc-&gt;p.size, x, ecc-&gt;p.size);
+      mpz_limbs_copy (r + 2 * ecc-&gt;p.size, y, ecc-&gt;p.size);
 
       mpn_zero (r, ecc-&gt;p.size);
       ecc-&gt;p.mod (&amp;ecc-&gt;p, r);
@@ -52,8 +53,11 @@ ecc_a_to_j (const struct ecc_curve *ecc,
       mpn_zero (r + ecc-&gt;p.size, ecc-&gt;p.size);
       ecc-&gt;p.mod (&amp;ecc-&gt;p, r + ecc-&gt;p.size);
     }
-  else if (r != p)
-    mpn_copyi (r, p, 2*ecc-&gt;p.size);
+  else
+    {
+      mpz_limbs_copy (r, x, ecc-&gt;p.size);
+      mpz_limbs_copy (r + ecc-&gt;p.size, y, ecc-&gt;p.size);
+    }
 
   mpn_copyi (r + 2*ecc-&gt;p.size, ecc-&gt;unit, ecc-&gt;p.size);
 }
diff --git a/ecc-ecdsa-sign.c b/ecc-ecdsa-sign.c
index 3b9e9cc1a35d..87239b7cccb6 100644
--- a/ecc-ecdsa-sign.c
+++ b/ecc-ecdsa-sign.c
@@ -80,7 +80,7 @@ ecc_ecdsa_sign (const struct ecc_curve *ecc,
 
   ecc-&gt;mul_g (ecc, P, kp, P + 3*ecc-&gt;p.size);
   /* x coordinate only, modulo q */
-  ecc-&gt;h_to_a (ecc, 2, rp, P, P + 3*ecc-&gt;p.size);
+  ecc-&gt;h_to_a (ecc, 2, rp, NULL, P, P + 3*ecc-&gt;p.size);
 
   /* Invert k, uses 4 * ecc-&gt;p.size including scratch */
   ecc-&gt;q.invert (&amp;ecc-&gt;q, kinv, kp, tp); /* NOTE: Also clobbers hp */
diff --git a/ecc-ecdsa-verify.c b/ecc-ecdsa-verify.c
index d7f5b684841a..120b12965fd5 100644
--- a/ecc-ecdsa-verify.c
+++ b/ecc-ecdsa-verify.c
@@ -64,7 +64,7 @@ mp_size_t
 ecc_ecdsa_verify_itch (const struct ecc_curve *ecc)
 {
   /* Largest storage need is for the ecc-&gt;mul call. */
-  return 5*ecc-&gt;p.size + ecc-&gt;mul_itch;
+  return 6*ecc-&gt;p.size + ecc-&gt;mul_itch;
 }
 
 /* FIXME: Use faster primitives, not requiring side-channel silence. */
@@ -145,7 +145,7 @@ ecc_ecdsa_verify (const struct ecc_curve *ecc,
       ecc-&gt;add_hhh (ecc, P1, P1, P2, P1 + 3*ecc-&gt;p.size);
     }
   /* x coordinate only, modulo q */
-  ecc-&gt;h_to_a (ecc, 2, P2, P1, P1 + 3*ecc-&gt;p.size);
+  ecc-&gt;h_to_a (ecc, 2, P2, NULL, P1, P1 + 3*ecc-&gt;p.size);
 
   return (mpn_cmp (rp, P2, ecc-&gt;p.size) == 0);
 #undef P2
diff --git a/ecc-eh-to-a.c b/ecc-eh-to-a.c
index 8173b887d59d..851dcb8d592a 100644
--- a/ecc-eh-to-a.c
+++ b/ecc-eh-to-a.c
@@ -43,7 +43,8 @@
 void
 ecc_eh_to_a (const struct ecc_curve *ecc,
 	     int op,
-	     mp_limb_t *r, const mp_limb_t *p,
+	     mp_limb_t *x, mp_limb_t *y,
+	     const mp_limb_t *p,
 	     mp_limb_t *scratch)
 {
 #define izp scratch
@@ -60,8 +61,8 @@ ecc_eh_to_a (const struct ecc_curve *ecc,
   ecc-&gt;p.invert (&amp;ecc-&gt;p, izp, zp, tp + ecc-&gt;p.size);
 
   ecc_modp_mul (ecc, tp, xp, izp);
-  cy = mpn_sub_n (r, tp, ecc-&gt;p.m, ecc-&gt;p.size);
-  cnd_copy (cy, r, tp, ecc-&gt;p.size);
+  cy = mpn_sub_n (x, tp, ecc-&gt;p.m, ecc-&gt;p.size);
+  cnd_copy (cy, x, tp, ecc-&gt;p.size);
 
   if (op)
     {
@@ -75,14 +76,14 @@ ecc_eh_to_a (const struct ecc_curve *ecc,
 	  unsigned shift;
 	  assert (ecc-&gt;p.bit_size == 255);
 	  shift = ecc-&gt;q.bit_size - 1 - GMP_NUMB_BITS * (ecc-&gt;p.size - 1);
-	  cy = mpn_submul_1 (r, ecc-&gt;q.m, ecc-&gt;p.size,
-			     r[ecc-&gt;p.size-1] &gt;&gt; shift);
+	  cy = mpn_submul_1 (x, ecc-&gt;q.m, ecc-&gt;p.size,
+			     x[ecc-&gt;p.size-1] &gt;&gt; shift);
 	  assert (cy &lt; 2);
-	  cnd_add_n (cy, r, ecc-&gt;q.m, ecc-&gt;p.size);
+	  cnd_add_n (cy, x, ecc-&gt;q.m, ecc-&gt;p.size);
 	}
       return;
     }
   ecc_modp_mul (ecc, tp, yp, izp);
-  cy = mpn_sub_n (r + ecc-&gt;p.size, tp, ecc-&gt;p.m, ecc-&gt;p.size);
-  cnd_copy (cy, r + ecc-&gt;p.size, tp, ecc-&gt;p.size);
+  cy = mpn_sub_n (y, tp, ecc-&gt;p.m, ecc-&gt;p.size);
+  cnd_copy (cy, y, tp, ecc-&gt;p.size);
 }
diff --git a/ecc-internal.h b/ecc-internal.h
index 18c1bf7d8cee..5854a3247306 100644
--- a/ecc-internal.h
+++ b/ecc-internal.h
@@ -132,7 +132,8 @@ typedef void ecc_mul_func (const struct ecc_curve *ecc,
 
 typedef void ecc_h_to_a_func (const struct ecc_curve *ecc,
 			      int flags,
-			      mp_limb_t *r, const mp_limb_t *p,
+			      mp_limb_t *x, mp_limb_t *y,
+			      const mp_limb_t *p,
 			      mp_limb_t *scratch);
 
 struct ecc_modulo
@@ -278,19 +279,21 @@ ecc_hash (const struct ecc_modulo *m,
 	  mp_limb_t *hp,
 	  size_t length, const uint8_t *digest);
 
-/* Converts a point P in affine coordinates into a point R in jacobian
+/* Converts a point x,y in affine coordinates into a point R in jacobian
    coordinates. */
 void
 ecc_a_to_j (const struct ecc_curve *ecc,
-	    mp_limb_t *r, const mp_limb_t *p);
+	    mp_limb_t *r, const mpz_t x, const mpz_t y);
 
 /* Converts a point P in jacobian coordinates into a point R in affine
    coordinates. If op == 1, produce x coordinate only. If op == 2,
-   produce the x coordinate only, and also reduce it modulo q. */
+   produce the x coordinate only, and also reduce it modulo q. If op == 3
+   produce the y coordinate only. */
 void
 ecc_j_to_a (const struct ecc_curve *ecc,
 	    int op,
-	    mp_limb_t *r, const mp_limb_t *p,
+	    mp_limb_t *x, mp_limb_t *y,
+	    const mp_limb_t *p,
 	    mp_limb_t *scratch);
 
 /* Converts a point P in homogeneous coordinates on an Edwards curve
@@ -299,7 +302,8 @@ ecc_j_to_a (const struct ecc_curve *ecc,
 void
 ecc_eh_to_a (const struct ecc_curve *ecc,
 	     int op,
-	     mp_limb_t *r, const mp_limb_t *p,
+	     mp_limb_t *x, mp_limb_t *y,
+	     const mp_limb_t *p,
 	     mp_limb_t *scratch);
 
 /* Group operations */
@@ -404,13 +408,13 @@ curve25519_eh_to_x (mp_limb_t *xp, const mp_limb_t *p,
 #define ECC_MUL_G_ITCH(size) (9*(size))
 #define ECC_MUL_G_EH_ITCH(size) (9*(size))
 #if ECC_MUL_A_WBITS == 0
-#define ECC_MUL_A_ITCH(size) (12*(size))
+#define ECC_MUL_A_ITCH(size) (3*(size) + ECC_ADD_JJJ_ITCH(size))
 #else
 #define ECC_MUL_A_ITCH(size) \
   (((3 &lt;&lt; ECC_MUL_A_WBITS) + 11) * (size))
 #endif
 #if ECC_MUL_A_EH_WBITS == 0
-#define ECC_MUL_A_EH_ITCH(size) (13*(size))
+#define ECC_MUL_A_EH_ITCH(size) (3*(size) + ECC_ADD_EHH_ITCH(size))
 #else
 #define ECC_MUL_A_EH_ITCH(size) \
   (((3 &lt;&lt; ECC_MUL_A_EH_WBITS) + 10) * (size))
diff --git a/ecc-j-to-a.c b/ecc-j-to-a.c
index eca10f0fac9e..1ce2e43a5b31 100644
--- a/ecc-j-to-a.c
+++ b/ecc-j-to-a.c
@@ -41,7 +41,8 @@
 void
 ecc_j_to_a (const struct ecc_curve *ecc,
 	    int op,
-	    mp_limb_t *r, const mp_limb_t *p,
+	    mp_limb_t *x, mp_limb_t *y,
+	    const mp_limb_t *p,
 	    mp_limb_t *scratch)
 {
 #define izp   scratch
@@ -89,8 +90,8 @@ ecc_j_to_a (const struct ecc_curve *ecc,
   ecc_modp_mul (ecc, iz3p, iz2p, p);
   /* ecc_modp (and ecc_modp_mul) may return a value up to 2p - 1, so
      do a conditional subtraction. */
-  cy = mpn_sub_n (r, iz3p, ecc-&gt;p.m, ecc-&gt;p.size);
-  cnd_copy (cy, r, iz3p, ecc-&gt;p.size);
+  cy = mpn_sub_n (x, iz3p, ecc-&gt;p.m, ecc-&gt;p.size);
+  cnd_copy (cy, x, iz3p, ecc-&gt;p.size);
 
   if (op)
     {
@@ -100,16 +101,16 @@ ecc_j_to_a (const struct ecc_curve *ecc,
 	  /* Also reduce the x coordinate mod ecc-&gt;q. It should
 	     already be &lt; 2*ecc-&gt;q, so one subtraction should
 	     suffice. */
-	  cy = mpn_sub_n (scratch, r, ecc-&gt;q.m, ecc-&gt;p.size);
-	  cnd_copy (cy == 0, r, scratch, ecc-&gt;p.size);
+	  cy = mpn_sub_n (scratch, x, ecc-&gt;q.m, ecc-&gt;p.size);
+	  cnd_copy (cy == 0, x, scratch, ecc-&gt;p.size);
 	}
       return;
     }
   ecc_modp_mul (ecc, iz3p, iz2p, izp);
   ecc_modp_mul (ecc, tp, iz3p, p + ecc-&gt;p.size);
   /* And a similar subtraction. */
-  cy = mpn_sub_n (r + ecc-&gt;p.size, tp, ecc-&gt;p.m, ecc-&gt;p.size);
-  cnd_copy (cy, r + ecc-&gt;p.size, tp, ecc-&gt;p.size);
+  cy = mpn_sub_n (y, tp, ecc-&gt;p.m, ecc-&gt;p.size);
+  cnd_copy (cy, y, tp, ecc-&gt;p.size);
 
 #undef izp
 #undef up
diff --git a/ecc-mul-a-eh.c b/ecc-mul-a-eh.c
index e9b22cd4c1e7..73657c87d58e 100644
--- a/ecc-mul-a-eh.c
+++ b/ecc-mul-a-eh.c
@@ -38,7 +38,7 @@
 #include "ecc.h"
 #include "ecc-internal.h"
 
-/* Binary algorithm needs 6*ecc-&gt;p.size + scratch for ecc_add_ehh,
+/* Binary algorithm needs 3*ecc-&gt;p.size + scratch for ecc_add_ehh,
    total 13 ecc-&gt;p.size
 
    Window algorithm needs (3&lt;&lt;w) * ecc-&gt;p.size for the table,
@@ -52,14 +52,11 @@ ecc_mul_a_eh (const struct ecc_curve *ecc,
 	      const mp_limb_t *np, const mp_limb_t *p,
 	      mp_limb_t *scratch)
 {
-#define pe scratch
-#define tp (scratch + 3*ecc-&gt;p.size)
-#define scratch_out (scratch + 6*ecc-&gt;p.size)
+#define tp (scratch)
+#define scratch_out (scratch + 3*ecc-&gt;p.size)
 
   unsigned i;
 
-  ecc_a_to_j (ecc, pe, p);
-
   /* x = 0, y = 1, z = 1 */
   mpn_zero (r, 3*ecc-&gt;p.size);
   r[ecc-&gt;p.size] = r[2*ecc-&gt;p.size] = 1;
@@ -76,7 +73,7 @@ ecc_mul_a_eh (const struct ecc_curve *ecc,
 	  int digit;
 
 	  ecc-&gt;dup (ecc, r, r, scratch_out);
-	  ecc-&gt;add_hhh (ecc, tp, r, pe, scratch_out);
+	  ecc-&gt;add_hhh (ecc, tp, r, p, scratch_out);
 
 	  digit = (w &amp; bit) &gt; 0;
 	  /* If we had a one-bit, use the sum. */
@@ -103,7 +100,7 @@ table_init (const struct ecc_curve *ecc,
   mpn_zero (TABLE(0), 3*ecc-&gt;p.size);
   TABLE(0)[ecc-&gt;p.size] = TABLE(0)[2*ecc-&gt;p.size] = 1;
 
-  ecc_a_to_j (ecc, TABLE(1), p);
+  mpn_copyi (TABLE(1), p, 3*ecc-&gt;p.size);
 
   for (j = 2; j &lt; size; j += 2)
     {
diff --git a/ecc-mul-a.c b/ecc-mul-a.c
index cb9c7d418633..6f0c19bcd004 100644
--- a/ecc-mul-a.c
+++ b/ecc-mul-a.c
@@ -40,8 +40,8 @@
 #include "ecc.h"
 #include "ecc-internal.h"
 
-/* Binary algorithm needs 6*ecc-&gt;p.size + scratch for ecc_add_jja.
-   Current total is 12 ecc-&gt;p.size, at most 864 bytes.
+/* Binary algorithm needs 3*ecc-&gt;p.size + scratch for ecc_add_jjj.
+   Current total is 11 ecc-&gt;p.size, at most 792 bytes.
 
    Window algorithm needs (3&lt;&lt;w) * ecc-&gt;p.size for the table,
    3*ecc-&gt;p.size for a temporary point, and scratch for
@@ -55,14 +55,12 @@ ecc_mul_a (const struct ecc_curve *ecc,
 	   mp_limb_t *scratch)
 {
 #define tp scratch
-#define pj (scratch + 3*ecc-&gt;p.size)
-#define scratch_out (scratch + 6*ecc-&gt;p.size)
+#define scratch_out (scratch + 3*ecc-&gt;p.size)
 
   int is_zero;
 
   unsigned i;
 
-  ecc_a_to_j (ecc, pj, p);
   mpn_zero (r, 3*ecc-&gt;p.size);
   
   for (i = ecc-&gt;p.size, is_zero = 1; i-- &gt; 0; )
@@ -77,12 +75,12 @@ ecc_mul_a (const struct ecc_curve *ecc,
 	  int digit;
 
 	  ecc_dup_jj (ecc, r, r, scratch_out);
-	  ecc_add_jja (ecc, tp, r, pj, scratch_out);
+	  ecc_add_jjj (ecc, tp, r, p, scratch_out);
 
 	  digit = (w &amp; bit) &gt; 0;
 	  /* If is_zero is set, r is the zero point,
-	     and ecc_add_jja produced garbage. */
-	  cnd_copy (is_zero, tp, pj, 3*ecc-&gt;p.size);
+	     and ecc_add_jjj produced garbage. */
+	  cnd_copy (is_zero, tp, p, 3*ecc-&gt;p.size);
 	  is_zero &amp;= ~digit;
 	  /* If we had a one-bit, use the sum. */
 	  cnd_copy (digit, r, tp, 3*ecc-&gt;p.size);
@@ -106,12 +104,12 @@ table_init (const struct ecc_curve *ecc,
   unsigned j;
 
   mpn_zero (TABLE(0), 3*ecc-&gt;p.size);
-  ecc_a_to_j (ecc, TABLE(1), p);
+  mpn_copyi (TABLE(1), p, 3*ecc-&gt;p.size);
 
   for (j = 2; j &lt; size; j += 2)
     {
       ecc_dup_jj (ecc, TABLE(j), TABLE(j/2), scratch);
-      ecc_add_jja (ecc, TABLE(j+1), TABLE(j), TABLE(1), scratch);
+      ecc_add_jjj (ecc, TABLE(j+1), TABLE(j), TABLE(1), scratch);
     }  
 }
 
diff --git a/ecc-point-mul-g.c b/ecc-point-mul-g.c
index 46fceb81ea45..e38f161bcdff 100644
--- a/ecc-point-mul-g.c
+++ b/ecc-point-mul-g.c
@@ -44,15 +44,13 @@
 void
 ecc_point_mul_g (struct ecc_point *r, const struct ecc_scalar *n)
 {
-  TMP_DECL(scratch, mp_limb_t, 3*ECC_MAX_SIZE + ECC_MUL_G_ITCH (ECC_MAX_SIZE));
+  TMP_DECL(scratch, mp_limb_t, ECC_MUL_G_ITCH (ECC_MAX_SIZE));
   const struct ecc_curve *ecc = r-&gt;ecc;
-  mp_limb_t size = ecc-&gt;p.size;
-  mp_size_t itch = 3*size + ecc-&gt;mul_g_itch;
+  mp_size_t itch = ecc-&gt;mul_g_itch;
 
   assert (n-&gt;ecc == ecc);
 
   TMP_ALLOC (scratch, itch);
 
-  ecc-&gt;mul_g (ecc, scratch, n-&gt;p, scratch + 3*size);
-  ecc-&gt;h_to_a (ecc, 0, r-&gt;p, scratch, scratch + 3*size);
+  ecc-&gt;mul_g (ecc, r-&gt;p, n-&gt;p, scratch);
 }
diff --git a/ecc-point-mul.c b/ecc-point-mul.c
index 2be1c5c41d3d..97755ea9b8ec 100644
--- a/ecc-point-mul.c
+++ b/ecc-point-mul.c
@@ -53,6 +53,6 @@ ecc_point_mul (struct ecc_point *r, const struct ecc_scalar *n,
   assert (p-&gt;ecc == ecc);
 
   ecc-&gt;mul (ecc, scratch, n-&gt;p, p-&gt;p, scratch + 3*size);
-  ecc-&gt;h_to_a (ecc, 0, r-&gt;p, scratch, scratch + 3*size);
+  mpn_copyi (r-&gt;p, scratch, 3*size);
   gmp_free_limbs (scratch, itch);
 }
diff --git a/ecc-point.c b/ecc-point.c
index 31e3115abbbc..e4feb129927b 100644
--- a/ecc-point.c
+++ b/ecc-point.c
@@ -42,13 +42,13 @@ void
 ecc_point_init (struct ecc_point *p, const struct ecc_curve *ecc)
 {
   p-&gt;ecc = ecc;
-  p-&gt;p = gmp_alloc_limbs (2*ecc-&gt;p.size);
+  p-&gt;p = gmp_alloc_limbs (3*ecc-&gt;p.size);
 }
 
 void
 ecc_point_clear (struct ecc_point *p)
 {
-  gmp_free_limbs (p-&gt;p, 2*p-&gt;ecc-&gt;p.size);
+  gmp_free_limbs (p-&gt;p, 3*p-&gt;ecc-&gt;p.size);
 }
 
 int
@@ -102,8 +102,7 @@ ecc_point_set (struct ecc_point *p, const mpz_t x, const mpz_t y)
   if (!res)
     return 0;
 
-  mpz_limbs_copy (p-&gt;p, x, size);
-  mpz_limbs_copy (p-&gt;p + size, y, size);
+  ecc_a_to_j (p-&gt;ecc, p-&gt;p, x, y);
 
   return 1;
 }
@@ -112,8 +111,33 @@ void
 ecc_point_get (const struct ecc_point *p, mpz_t x, mpz_t y)
 {
   mp_size_t size = p-&gt;ecc-&gt;p.size;
+  mp_limb_t *xp = NULL, *yp = NULL;
+  mp_limb_t *scratch = gmp_alloc_limbs(p-&gt;ecc-&gt;h_to_a_itch);
+  int op;
+
+  if (x)
+    {
+      if (y)
+	op = 0;
+      else
+	op = 1;
+    }
+  else
+    {
+      if (y)
+	op = 3;
+      else
+	return;
+    }
+  if (x)
+    xp = mpz_limbs_write (x, size);
+  if (y)
+    yp = mpz_limbs_write (y, size);
+  p-&gt;ecc-&gt;h_to_a (p-&gt;ecc, op, xp, yp, p-&gt;p, scratch);
+  gmp_free_limbs (scratch, p-&gt;ecc-&gt;h_to_a_itch);
+
   if (x)
-    mpz_set_n (x, p-&gt;p, size);
+    mpz_limbs_finish (x, size);
   if (y)
-    mpz_set_n (y, p-&gt;p + size, size);
+    mpz_limbs_finish (y, size);
 }
diff --git a/ecdsa-keygen.c b/ecdsa-keygen.c
index fa559a9e3b43..3cf0bd3c485a 100644
--- a/ecdsa-keygen.c
+++ b/ecdsa-keygen.c
@@ -47,15 +47,14 @@ ecdsa_generate_keypair (struct ecc_point *pub,
 			struct ecc_scalar *key,
 			void *random_ctx, nettle_random_func *random)
 {
-  TMP_DECL(p, mp_limb_t, 3*ECC_MAX_SIZE + ECC_MUL_G_ITCH (ECC_MAX_SIZE));
+  TMP_DECL(p, mp_limb_t, ECC_MUL_G_ITCH (ECC_MAX_SIZE));
   const struct ecc_curve *ecc = pub-&gt;ecc;
-  mp_size_t itch = 3*ecc-&gt;p.size + ecc-&gt;mul_g_itch;
+  mp_size_t itch = ecc-&gt;mul_g_itch;
 
   assert (key-&gt;ecc == ecc);
 
   TMP_ALLOC (p, itch);
 
   ecc_mod_random (&amp;ecc-&gt;q, key-&gt;p, random_ctx, random, p);
-  ecc-&gt;mul_g (ecc, p, key-&gt;p, p + 3*ecc-&gt;p.size);
-  ecc-&gt;h_to_a (ecc, 0, pub-&gt;p, p, p + 3*ecc-&gt;p.size);
+  ecc-&gt;mul_g (ecc, pub-&gt;p, key-&gt;p, p);
 }
diff --git a/eddsa-compress.c b/eddsa-compress.c
index 547ba736dc7b..3fe2a9bdbc34 100644
--- a/eddsa-compress.c
+++ b/eddsa-compress.c
@@ -53,7 +53,7 @@ _eddsa_compress (const struct ecc_curve *ecc, uint8_t *r, mp_limb_t *p,
 #define yp (scratch + ecc-&gt;p.size)
 #define scratch_out (scratch + 2*ecc-&gt;p.size)
 
-  ecc-&gt;h_to_a (ecc, 0, xp, p, scratch_out);
+  ecc-&gt;h_to_a (ecc, 0, xp, yp, p, scratch_out);
   /* Encoding is the y coordinate and an appended "sign" bit, which is
      the low bit of x. Bit order is not specified explicitly, but for
      little-endian encoding, it makes most sense to append the bit
diff --git a/eddsa-decompress.c b/eddsa-decompress.c
index f114b576fffe..0b3119acc890 100644
--- a/eddsa-decompress.c
+++ b/eddsa-decompress.c
@@ -80,5 +80,6 @@ _eddsa_decompress (const struct ecc_curve *ecc, mp_limb_t *p,
   sign ^= xp[0] &amp; 1;
   mpn_sub_n (tp, ecc-&gt;p.m, xp, ecc-&gt;p.size);
   cnd_copy (sign, xp, tp, ecc-&gt;p.size);
+  mpn_copyi (p + 2*ecc-&gt;p.size, ecc-&gt;unit, ecc-&gt;p.size);
   return res;
 }
diff --git a/eddsa-verify.c b/eddsa-verify.c
index 7718a1260463..9b596c517fb9 100644
--- a/eddsa-verify.c
+++ b/eddsa-verify.c
@@ -97,7 +97,7 @@ _eddsa_verify (const struct ecc_curve *ecc,
 
   /* Could maybe save some storage by delaying the R and S operations,
      but it makes sense to check them for validity up front. */
-  if (!_eddsa_decompress (ecc, R, signature, R+2*ecc-&gt;p.size))
+  if (!_eddsa_decompress (ecc, R, signature, R+3*ecc-&gt;p.size))
     return 0;
 
   mpn_set_base256_le (sp, ecc-&gt;q.size, signature + nbytes, nbytes);
diff --git a/testsuite/ecc-add-test.c b/testsuite/ecc-add-test.c
index ad2bd29230ee..144111695a27 100644
--- a/testsuite/ecc-add-test.c
+++ b/testsuite/ecc-add-test.c
@@ -5,6 +5,7 @@ void
 test_main (void)
 {
   unsigned i;
+  mpz_t x, y;
 
   for (i = 0; ecc_curves[i]; i++)
     {
@@ -17,7 +18,9 @@ test_main (void)
 
       ASSERT (ecc-&gt;dup_itch &lt;= ecc-&gt;add_hhh_itch);
 
-      ecc_a_to_j (ecc, g, ecc-&gt;g);
+      ecc_a_to_j (ecc, g,
+		  mpz_roinit_n (x, ecc-&gt;g, ecc-&gt;p.size),
+		  mpz_roinit_n (y, ecc-&gt;g + ecc-&gt;p.size, ecc-&gt;p.size));
 
       if (ecc-&gt;p.bit_size == 255)
 	{
diff --git a/testsuite/ecc-dup-test.c b/testsuite/ecc-dup-test.c
index 0ae4444a7cb0..eede76f24487 100644
--- a/testsuite/ecc-dup-test.c
+++ b/testsuite/ecc-dup-test.c
@@ -3,17 +3,15 @@
 void
 test_main (void)
 {
+  mpz_t x, y;
   unsigned i;
 
   for (i = 0; ecc_curves[i]; i++)
     {
       const struct ecc_curve *ecc = ecc_curves[i];
-      mp_limb_t *g = xalloc_limbs (ecc_size_j (ecc));
       mp_limb_t *p = xalloc_limbs (ecc_size_j (ecc));
       mp_limb_t *scratch = xalloc_limbs (ecc-&gt;dup_itch);
 
-      ecc_a_to_j (ecc, g, ecc-&gt;g);
-
       if (ecc-&gt;p.bit_size == 255)
 	{
 	  mp_limb_t *z = xalloc_limbs (ecc_size_j (ecc));
@@ -32,14 +30,16 @@ test_main (void)
       else
 	ASSERT (ecc-&gt;dup == ecc_dup_jj);
 
-      ecc-&gt;dup (ecc, p, g, scratch);
+      ecc_a_to_j (ecc, p,
+		  mpz_roinit_n (x, ecc-&gt;g, ecc-&gt;p.size),
+		  mpz_roinit_n (y, ecc-&gt;g + ecc-&gt;p.size, ecc-&gt;p.size));
+      ecc-&gt;dup (ecc, p, p, scratch);
       test_ecc_mul_h (i, 2, p);
 
       ecc-&gt;dup (ecc, p, p, scratch);
       test_ecc_mul_h (i, 4, p);
 
       free (p);
-      free (g);
       free (scratch);
     }
 }
diff --git a/testsuite/ecc-mul-a-test.c b/testsuite/ecc-mul-a-test.c
index 245016aafc78..af62e7d5c498 100644
--- a/testsuite/ecc-mul-a-test.c
+++ b/testsuite/ecc-mul-a-test.c
@@ -14,6 +14,8 @@ test_main (void)
     {
       const struct ecc_curve *ecc = ecc_curves[i];
       mp_size_t size = ecc_size (ecc);
+      mpz_t x, y;
+      mp_limb_t *g = xalloc_limbs (ecc_size_j (ecc));
       mp_limb_t *p = xalloc_limbs (ecc_size_j (ecc));
       mp_limb_t *q = xalloc_limbs (ecc_size_j (ecc));
       mp_limb_t *n = xalloc_limbs (size);
@@ -22,23 +24,26 @@ test_main (void)
       
       mpn_zero (n, size);
 
+      ecc_a_to_j (ecc, g,
+		  mpz_roinit_n (x, ecc-&gt;g, size),
+		  mpz_roinit_n (y, ecc-&gt;g + size, size));
       n[0] = 1;
-      ecc-&gt;mul (ecc, p, n, ecc-&gt;g, scratch);
-      ecc-&gt;h_to_a (ecc, 0, p, p, scratch);
+      ecc-&gt;mul (ecc, p, n, g, scratch);
+      ecc-&gt;h_to_a (ecc, 0, p, p + size, p, scratch);
 
       if (mpn_cmp (p, ecc-&gt;g, 2*size) != 0)
 	die ("curve %d: ecc-&gt;mul with n = 1 failed.\n", ecc-&gt;p.bit_size);
 
       for (n[0] = 2; n[0] &lt;= 4; n[0]++)
 	{
-	  ecc-&gt;mul (ecc, p, n, ecc-&gt;g, scratch);
+	  ecc-&gt;mul (ecc, p, n, g, scratch);
 	  test_ecc_mul_h (i, n[0], p);
 	}
 
       /* (order - 1) * g = - g */
       mpn_sub_1 (n, ecc-&gt;q.m, size, 1);
-      ecc-&gt;mul (ecc, p, n, ecc-&gt;g, scratch);
-      ecc-&gt;h_to_a (ecc, 0, p, p, scratch);
+      ecc-&gt;mul (ecc, p, n, g, scratch);
+      ecc-&gt;h_to_a (ecc, 0, p, p + size, p, scratch);
       if (ecc-&gt;p.bit_size == 255)
 	/* For edwards curves, - (x,y ) == (-x, y). FIXME: Swap x and
 	   y, to get identical negation? */
@@ -64,11 +69,11 @@ test_main (void)
 	  mpz_limbs_copy (n, r, size);
 	  n[size - 1] %= ecc-&gt;q.m[size - 1];
 
-	  ecc-&gt;mul (ecc, p, n, ecc-&gt;g, scratch);
-	  ecc-&gt;h_to_a (ecc, 0, p, p, scratch);
+	  ecc-&gt;mul (ecc, p, n, g, scratch);
+	  ecc-&gt;h_to_a (ecc, 0, p, p + size, p, scratch);
 
 	  ecc-&gt;mul_g (ecc, q, n, scratch);
-	  ecc-&gt;h_to_a (ecc, 0, q, q, scratch);
+	  ecc-&gt;h_to_a (ecc, 0, q, q + size, q, scratch);
 
 	  if (mpn_cmp (p, q, 2*size))
 	    {
@@ -92,6 +97,7 @@ test_main (void)
 	      abort ();
 	    }
 	}
+      free (g);
       free (n);
       free (p);
       free (q);
diff --git a/testsuite/ecc-mul-g-test.c b/testsuite/ecc-mul-g-test.c
index 272394847f3a..c6b7374e82d8 100644
--- a/testsuite/ecc-mul-g-test.c
+++ b/testsuite/ecc-mul-g-test.c
@@ -23,7 +23,7 @@ test_main (void)
 
       n[0] = 1;
       ecc-&gt;mul_g (ecc, p, n, scratch);
-      ecc-&gt;h_to_a (ecc, 0, p, p, scratch);
+      ecc-&gt;h_to_a (ecc, 0, p, p + size, p, scratch);
 
       if (mpn_cmp (p, ecc-&gt;g, 2*size) != 0)
 	{
@@ -40,7 +40,7 @@ test_main (void)
       /* (order - 1) * g = - g */
       mpn_sub_1 (n, ecc-&gt;q.m, size, 1);
       ecc-&gt;mul_g (ecc, p, n, scratch);
-      ecc-&gt;h_to_a (ecc, 0, p, p, scratch);
+      ecc-&gt;h_to_a (ecc, 0, p, p + size, p, scratch);
       if (ecc-&gt;p.bit_size == 255)
 	/* For edwards curves, - (x,y ) == (-x, y). FIXME: Swap x and
 	   y, to get identical negation? */
diff --git a/testsuite/ecdsa-keygen-test.c b/testsuite/ecdsa-keygen-test.c
index a96c09effeef..21b43623a8a2 100644
--- a/testsuite/ecdsa-keygen-test.c
+++ b/testsuite/ecdsa-keygen-test.c
@@ -12,17 +12,32 @@ ecc_valid_p (struct ecc_point *pub)
 
   size = pub-&gt;ecc-&gt;p.size;
 
-  /* First check range */
-  if (mpn_cmp (pub-&gt;p, pub-&gt;ecc-&gt;p.m, size) &gt;= 0
-      || mpn_cmp (pub-&gt;p + size, pub-&gt;ecc-&gt;p.m, size) &gt;= 0)
-    return 0;
+  mpz_init (x);
+  mpz_init (y);
+
+  ecc_point_get (pub, x, y);
+
+  if (verbose)
+    {
+      fprintf (stderr, "Public key:\nx = ");
+      mpz_out_str (stderr, 16, x);
+      fprintf (stderr, "\ny = ");
+      mpz_out_str (stderr, 16, y);
+      fprintf (stderr, "\n");
+    }
+
+  if (mpz_sgn (x) &lt; 0 || mpz_limbs_cmp (x, pub-&gt;ecc-&gt;p.m, size) &gt;= 0
+      || mpz_sgn (y) &lt; 0 || mpz_limbs_cmp (y, pub-&gt;ecc-&gt;p.m, size) &gt;= 0)
+    {
+      mpz_clear (x);
+      mpz_clear (y);
+
+      return 0;
+    }
 
   mpz_init (lhs);
   mpz_init (rhs);
 
-  mpz_roinit_n (x, pub-&gt;p, size);
-  mpz_roinit_n (y, pub-&gt;p + size, size);
-
   mpz_mul (lhs, y, y);
   
   if (pub-&gt;ecc-&gt;p.bit_size == 255)
@@ -53,6 +68,9 @@ ecc_valid_p (struct ecc_point *pub)
   mpz_clear (lhs);
   mpz_clear (rhs);
 
+  mpz_clear (x);
+  mpz_clear (y);
+
   return res;
 }
 
@@ -90,11 +108,7 @@ test_main (void)
 
       if (verbose)
 	{
-	  fprintf (stderr, "Public key:\nx = ");
-	  write_mpn (stderr, 16, pub.p, ecc-&gt;p.size);
-	  fprintf (stderr, "\ny = ");
-	  write_mpn (stderr, 16, pub.p + ecc-&gt;p.size, ecc-&gt;p.size);
-	  fprintf (stderr, "\nPrivate key: ");
+	  fprintf (stderr, "Private key: ");
 	  write_mpn (stderr, 16, key.p, ecc-&gt;p.size);
 	  fprintf (stderr, "\n");
 	}
diff --git a/testsuite/eddsa-compress-test.c b/testsuite/eddsa-compress-test.c
index f95da870967e..812a085c9040 100644
--- a/testsuite/eddsa-compress-test.c
+++ b/testsuite/eddsa-compress-test.c
@@ -44,6 +44,7 @@ void test_main (void)
   mpz_t zp, t;
   mp_limb_t *s;
   mp_limb_t *p;
+  mp_limb_t *p2;
   mp_limb_t *pa1;
   mp_limb_t *pa2;
   mp_limb_t *scratch;
@@ -61,6 +62,7 @@ void test_main (void)
   mpz_init (t);
   s = xalloc_limbs (size);
   p = xalloc_limbs (ecc_size_j (ecc));
+  p2 = xalloc_limbs (ecc_size_j (ecc));
   pa1 = xalloc_limbs (ecc_size_a (ecc));
   pa2 = xalloc_limbs (ecc_size_a (ecc));
   c = xalloc (clen);
@@ -79,8 +81,9 @@ void test_main (void)
       mpz_limbs_copy (s, t, ecc-&gt;q.size);
       ecc-&gt;mul_g (ecc, p, s, scratch);
       _eddsa_compress (ecc, c, p, scratch);
-      ecc-&gt;h_to_a (ecc, 0, pa1, p, scratch);
-      _eddsa_decompress (ecc, pa2, c, scratch);
+      ecc-&gt;h_to_a (ecc, 0, pa1, pa1 + size, p, scratch);
+      _eddsa_decompress (ecc, p2, c, scratch);
+      ecc-&gt;h_to_a (ecc, 0, pa2, pa2 + size, p2, scratch);
       mpz_roinit_n (x1, pa1, size);
       mpz_roinit_n (y1, pa1 + size, size);
       mpz_roinit_n (x2, pa2, size);
@@ -105,6 +108,7 @@ void test_main (void)
   mpz_clear (t);
   free (s);
   free (p);
+  free (p2);
   free (c);
   free (pa1);
   free (pa2);
diff --git a/testsuite/eddsa-verify-test.c b/testsuite/eddsa-verify-test.c
index 770080591b13..d58095b900ed 100644
--- a/testsuite/eddsa-verify-test.c
+++ b/testsuite/eddsa-verify-test.c
@@ -41,7 +41,7 @@ test_eddsa (const struct ecc_curve *ecc,
 	    const struct tstring *msg,
 	    const uint8_t *signature)
 {
-  mp_limb_t *A = xalloc_limbs (ecc_size_a (ecc));
+  mp_limb_t *A = xalloc_limbs (ecc_size_j (ecc));
   mp_limb_t *scratch = xalloc_limbs (_eddsa_verify_itch (ecc));
   size_t nbytes = 1 + ecc-&gt;p.bit_size / 8;
   uint8_t *cmsg = xalloc (msg-&gt;length);
diff --git a/testsuite/testutils.c b/testsuite/testutils.c
index c9f21bab2346..e999044614a2 100644
--- a/testsuite/testutils.c
+++ b/testsuite/testutils.c
@@ -1838,7 +1838,7 @@ test_ecc_mul_h (unsigned curve, unsigned n, const mp_limb_t *p)
   const struct ecc_curve *ecc = ecc_curves[curve];
   mp_limb_t *np = xalloc_limbs (ecc_size_a (ecc));
   mp_limb_t *scratch = xalloc_limbs (ecc-&gt;h_to_a_itch);
-  ecc-&gt;h_to_a (ecc, 0, np, p, scratch);
+  ecc-&gt;h_to_a (ecc, 0, np, np + ecc-&gt;p.size, p, scratch);
 
   test_ecc_mul_a (curve, n, np);
 
-- 
2.24.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191127105534</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-11-27 10:55:34-0400</timestampReceived><subject>Re: git clone is unreliable for nettle</subject><body>

Tim Rühsen &lt;tim.ruehsen@gmx.de&gt; writes:

&gt; But I wanted Niels to know that something is not quite right with his
&gt; server (and/or hosting).

Thanks. These machines are run by the computer club, with networking
privided by swedish university network. We've had some recent outages
(freebsd nfs brekage, kerberos breakage, a major web server upgrade,
repeated power outages every summer connected to thunder in the area).
But I wasn't ware of anything affecting the git server in particular.

If you need a mirror as backup or primary source, I'd also suggest the
gnutls mirror at gitlab.com. It's updated every hour or something like
that.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191001175850</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-10-01 17:58:50-0400</timestampReceived><subject>Re: [PATCH] cfb8: don't truncate output IV if input is shorter than block size</subject><body>

Daiki Ueno &lt;ueno@gnu.org&gt; writes:

&gt;&gt; For testing, I think it would be good to take the testvectors for cfb8,
&gt;&gt; and split into multiple calls to cfb8_*crypt, in several ways. And check
&gt;&gt; they all give the same result. A bit like it's done in arcfour-test.c,
&gt;&gt; or the test_cipher_stream (#if:ed out, not sure if it's worth reviving).
&gt;
&gt; Indeed, thank you for the suggestion.  I'm attaching updated patches.

Pushed now, with a few additional fixes for the test.

Thanks!
/Niels Möller

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191002121026</emailId><senderName></senderName><senderEmail>justus</senderEmail><timestampReceived>2019-10-02 12:10:26-0400</timestampReceived><subject>[PATCH 1/2] Sort bindings alphabetically.</subject><body>

From: Justus Winter &lt;justus@sequoia-pgp.org&gt;

---
 index.html | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/index.html b/index.html
index 3ac9d7eb..df174bbd 100644
--- a/index.html
+++ b/index.html
@@ -50,18 +50,18 @@ uid                  Niels Möller &lt;nisse@lysator.liu.se&gt;
 &lt;p&gt; I'm aware of nettle-bindings for the following higher-level
   languages.&lt;/p&gt;
 &lt;dl&gt;
+  &lt;dt&gt; &lt;a href='http://hackage.haskell.org/package/bindings-nettle'&gt;Haskell&lt;/a&gt; &lt;/dt&gt;
+  &lt;dd&gt; Haskell bindings by Clint Adams. &lt;/dd&gt;
+  &lt;dt&gt; &lt;a href='http://search.cpan.org/~dkg/Crypt-Nettle-0.3/lib/Crypt/Nettle.pm'&gt;Perl&lt;/a&gt;&lt;/dt&gt;
+  &lt;dd&gt; Crypt::Nettle module, by Daniel Kahn Gillmor.&lt;/dd&gt;
   &lt;dt&gt; &lt;a href="http://pike.ida.liu.se"&gt;Pike&lt;/a&gt;&lt;/dt&gt;
   &lt;dd&gt; An object-oriented interpreted language with C-like syntax.
     Nettle bindings are included with the official distribution.&lt;/dd&gt;
-  &lt;dt&gt; &lt;a href='http://search.cpan.org/~dkg/Crypt-Nettle-0.3/lib/Crypt/Nettle.pm'&gt;Perl&lt;/a&gt;&lt;/dt&gt;
-  &lt;dd&gt; Crypt::Nettle module, by Daniel Kahn Gillmor.&lt;/dd&gt;
   &lt;dt&gt; &lt;a href='http://www.yellowbank.com/code/PostgreSQL/y_crypto/'&gt;PostgreSQL&lt;/a&gt;&lt;/dt&gt;
   &lt;dd&gt; Bindings for the Postgres database, by Ron Peterson. &lt;/dd&gt;
   &lt;dt&gt; &lt;a href='http://marcomaggi.github.com/nausicaa.html'&gt;R6RS
 	Scheme&lt;/a&gt;&lt;/dt&gt;
   &lt;dd&gt; Scheme bindings by Marco Maggi, supporting multiple R6RS implementations.&lt;/dd&gt;
-  &lt;dt&gt; &lt;a href='http://hackage.haskell.org/package/bindings-nettle'&gt;Haskell&lt;/a&gt; &lt;/dt&gt;
-  &lt;dd&gt; Haskell bindings by Clint Adams. &lt;/dd&gt;
   &lt;dt&gt; TCL &lt;/dt&gt;
   &lt;dd&gt; Included in the chiark-tcl debian package by Ian Jackson (not
     sure if/how it's distributed outside of debian). &lt;/dd&gt;
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191124154258</emailId><senderName>Tim_Rühsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2019-11-24 15:42:58-0400</timestampReceived><subject>git clone is unreliable for nettle</subject><body>

[Attachment #2 (multipart/signed)]

[Attachment #4 (multipart/mixed)]


Hi Niels,

since a while (max a few weeks), I see sporadic failures when cloning
nettle.

E.g. when building nettle on the OSS-Fuzz platform:

Step #1: [0m[91mfatal: unable to access
'https://git.lysator.liu.se/nettle/nettle.git/': Couldn't connect to server
Step #1: The command '/bin/sh -c git clone --depth=1
https://git.lysator.liu.se/nettle/nettle.git' returned a non-zero code: 128

Is there an access limit for IP address or something like that ?
And if yes, do you recommend to set up a mirror ?

Regards, Tim


["signature.asc" (application/pgp-signature)]
[Attachment #8 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20191125115837</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@redhat.com</senderEmail><timestampReceived>2019-11-25 11:58:37-0400</timestampReceived><subject>Re: git clone is unreliable for nettle</subject><body>

On Sun, Nov 24, 2019 at 4:43 PM Tim Rühsen &lt;tim.ruehsen@gmx.de&gt; wrote:
&gt;
&gt; Hi Niels,
&gt;
&gt; since a while (max a few weeks), I see sporadic failures when cloning
&gt; nettle.
&gt;
&gt; E.g. when building nettle on the OSS-Fuzz platform:
&gt;
&gt; Step #1:  [0m [91mfatal: unable to access
&gt; 'https://git.lysator.liu.se/nettle/nettle.git/': Couldn't connect to server
&gt; Step #1: The command '/bin/sh -c git clone --depth=1
&gt; https://git.lysator.liu.se/nettle/nettle.git' returned a non-zero code: 128

There is a mirror which is automatically updated on:
https://gitlab.com/gnutls/nettle

Would that be a more reliable source for oss-fuzz?

regards,
Nikos

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191127100955</emailId><senderName>Tim_Rühsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2019-11-27 10:09:55-0400</timestampReceived><subject>Re: git clone is unreliable for nettle</subject><body>

[Attachment #2 (multipart/signed)]

[Attachment #4 (multipart/mixed)]


On 11/25/19 12:58 PM, Nikos Mavrogiannopoulos wrote:
&gt; On Sun, Nov 24, 2019 at 4:43 PM Tim Rühsen &lt;tim.ruehsen@gmx.de&gt; wrote:
&gt;&gt;
&gt;&gt; Hi Niels,
&gt;&gt;
&gt;&gt; since a while (max a few weeks), I see sporadic failures when cloning
&gt;&gt; nettle.
&gt;&gt;
&gt;&gt; E.g. when building nettle on the OSS-Fuzz platform:
&gt;&gt;
&gt;&gt; Step #1:  [0m [91mfatal: unable to access
&gt;&gt; 'https://git.lysator.liu.se/nettle/nettle.git/': Couldn't connect to server
&gt;&gt; Step #1: The command '/bin/sh -c git clone --depth=1
&gt;&gt; https://git.lysator.liu.se/nettle/nettle.git' returned a non-zero code: 128
&gt; 
&gt; There is a mirror which is automatically updated on:
&gt; https://gitlab.com/gnutls/nettle
&gt; 
&gt; Would that be a more reliable source for oss-fuzz?

Thanks, I know we have it and if the issues persist I'll change to there.

But I wanted Niels to know that something is not quite right with his
server (and/or hosting). Maybe I am just bit paranoid after going
through a DDOS recently at one of my customers sites. It started with
everything being unreliable, flaky, performance drops...

Regards, Tim


["signature.asc" (application/pgp-signature)]
[Attachment #8 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20191002121027</emailId><senderName></senderName><senderEmail>justus</senderEmail><timestampReceived>2019-10-02 12:10:27-0400</timestampReceived><subject>[PATCH 2/2] Link to Rust bindings.</subject><body>

From: Justus Winter &lt;justus@sequoia-pgp.org&gt;

---
 index.html | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/index.html b/index.html
index df174bbd..c90db93e 100644
--- a/index.html
+++ b/index.html
@@ -62,6 +62,8 @@ uid                  Niels Möller &lt;nisse@lysator.liu.se&gt;
   &lt;dt&gt; &lt;a href='http://marcomaggi.github.com/nausicaa.html'&gt;R6RS
 	Scheme&lt;/a&gt;&lt;/dt&gt;
   &lt;dd&gt; Scheme bindings by Marco Maggi, supporting multiple R6RS implementations.&lt;/dd&gt;
+  &lt;dt&gt; &lt;a href='https://crates.io/crates/nettle'&gt;Rust&lt;/a&gt; &lt;/dt&gt;
+  &lt;dd&gt; Rust bindings by Kai Michaelis. &lt;/dd&gt;
   &lt;dt&gt; TCL &lt;/dt&gt;
   &lt;dd&gt; Included in the chiark-tcl debian package by Ian Jackson (not
     sure if/how it's distributed outside of debian). &lt;/dd&gt;
-- 
2.20.1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191002121433</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-10-02 12:14:33-0400</timestampReceived><subject>[PATCH 2/2] Implement PBKDF2 shortcut function for Streebog256/512</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in             |  2 +-
 pbkdf2-hmac-streebog.c  | 67 +++++++++++++++++++++++++++++++++++++++++
 pbkdf2.h                | 14 +++++++++
 testsuite/pbkdf2-test.c |  7 +++++
 4 files changed, 89 insertions(+), 1 deletion(-)
 create mode 100644 pbkdf2-hmac-streebog.c

diff --git a/Makefile.in b/Makefile.in
index c578e2901aa7..bcf97fcd5c8c 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -115,7 +115,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 nettle-meta-aeads.c nettle-meta-armors.c \
 		 nettle-meta-ciphers.c nettle-meta-hashes.c \
 		 pbkdf2.c pbkdf2-hmac-gosthash94.c pbkdf2-hmac-sha1.c \
-		 pbkdf2-hmac-sha256.c \
+		 pbkdf2-hmac-sha256.c pbkdf2-hmac-streebog.c \
 		 poly1305-aes.c poly1305-internal.c \
 		 realloc.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
diff --git a/pbkdf2-hmac-streebog.c b/pbkdf2-hmac-streebog.c
new file mode 100644
index 000000000000..cc286f8940ac
--- /dev/null
+++ b/pbkdf2-hmac-streebog.c
@@ -0,0 +1,67 @@
+/* pbkdf2-hmac-streebog.c
+
+   PKCS #5 PBKDF2 used with HMAC-STREEBOG.
+
+   Copyright (C) 2016 Dmitry Eremin-Solenikov
+   Copyright (C) 2012 Simon Josefsson
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "pbkdf2.h"
+
+#include "hmac.h"
+
+void
+pbkdf2_hmac_streebog256 (size_t key_length, const uint8_t *key,
+		    unsigned iterations,
+		    size_t salt_length, const uint8_t *salt,
+		    size_t length, uint8_t *dst)
+{
+  struct hmac_streebog256_ctx streebog256ctx;
+
+  hmac_streebog256_set_key (&amp;streebog256ctx, key_length, key);
+  PBKDF2 (&amp;streebog256ctx, hmac_streebog256_update, hmac_streebog256_digest,
+	  STREEBOG256_DIGEST_SIZE, iterations, salt_length, salt, length, dst);
+}
+
+void
+pbkdf2_hmac_streebog512 (size_t key_length, const uint8_t *key,
+		    unsigned iterations,
+		    size_t salt_length, const uint8_t *salt,
+		    size_t length, uint8_t *dst)
+{
+  struct hmac_streebog512_ctx streebog512ctx;
+
+  hmac_streebog512_set_key (&amp;streebog512ctx, key_length, key);
+  PBKDF2 (&amp;streebog512ctx, hmac_streebog512_update, hmac_streebog512_digest,
+	  STREEBOG512_DIGEST_SIZE, iterations, salt_length, salt, length, dst);
+}
diff --git a/pbkdf2.h b/pbkdf2.h
index a36dfdbaa437..67583bce615a 100644
--- a/pbkdf2.h
+++ b/pbkdf2.h
@@ -46,6 +46,8 @@ extern "C"
 #define pbkdf2_hmac_sha1 nettle_pbkdf2_hmac_sha1
 #define pbkdf2_hmac_sha256 nettle_pbkdf2_hmac_sha256
 #define pbkdf2_hmac_gosthash94cp nettle_pbkdf2_hmac_gosthash94cp
+#define pbkdf2_hmac_streebog256 nettle_pbkdf2_hmac_streebog256
+#define pbkdf2_hmac_streebog512 nettle_pbkdf2_hmac_streebog512
 
 void
 pbkdf2 (void *mac_ctx,
@@ -85,6 +87,18 @@ pbkdf2_hmac_gosthash94cp (size_t key_length, const uint8_t *key,
 			  size_t salt_length, const uint8_t *salt,
 			  size_t length, uint8_t *dst);
 
+void
+pbkdf2_hmac_streebog256 (size_t key_length, const uint8_t *key,
+			 unsigned iterations,
+			 size_t salt_length, const uint8_t *salt,
+			 size_t length, uint8_t *dst);
+
+void
+pbkdf2_hmac_streebog512 (size_t key_length, const uint8_t *key,
+			 unsigned iterations,
+			 size_t salt_length, const uint8_t *salt,
+			 size_t length, uint8_t *dst);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/pbkdf2-test.c b/testsuite/pbkdf2-test.c
index 9e024e57b7f5..e76c82dc2b7e 100644
--- a/testsuite/pbkdf2-test.c
+++ b/testsuite/pbkdf2-test.c
@@ -157,9 +157,16 @@ test_main (void)
 	       STREEBOG512_DIGEST_SIZE, 4096, LDATA("sa\0lt"),
 	       SHEX("50df062885b69801a3c10248eb0a27ab6e522ffeb20c991c660f001475d73a4e167f782c18e97e92976d9c1d970831ea78ccb879f67068cdac1910740844e830"));
  
+  PBKDF2_HMAC_TEST (pbkdf2_hmac_streebog512, LDATA("password"), 1, LDATA("salt"),
+	       SHEX("64770af7f748c3b1c9ac831dbcfd85c26111b30a8a657ddc3056b80ca73e040d2854fd36811f6d825cc4ab66ec0a68a490a9e5cf5156b3a2b7eecddbf9a16b47"));
 +
   /* Generated */
   hmac_streebog256_set_key (&amp;streebog256ctx, LDATA("password"));
   PBKDF2_TEST (&amp;streebog256ctx, hmac_streebog256_update, hmac_streebog256_digest,
 	       STREEBOG256_DIGEST_SIZE, 1, LDATA("salt"),
 	       SHEX("d789458d143b9abebc4ef63ca8e576c72b13c7d4289db23fc1e946f84cd605bc"));
+
+
+  PBKDF2_HMAC_TEST (pbkdf2_hmac_streebog256, LDATA("password"), 1, LDATA("salt"),
+	       SHEX("d789458d143b9abebc4ef63ca8e576c72b13c7d4289db23fc1e946f84cd605bc"));
 }
-- 
2.23.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20191002121442</emailId><senderName>Justus Winter</senderName><senderEmail>justus@sequoia-pgp.org</senderEmail><timestampReceived>2019-10-02 12:14:42-0400</timestampReceived><subject>Dead links to bindings (was: Rust bindings)</subject><body>

[Attachment #2 (multipart/signed)]


nisse@lysator.liu.se (Niels M=C3=B6ller) writes:

&gt; Justus Winter &lt;justus@sequoia-pgp.org&gt; writes:
&gt;
&gt;&gt; Do we need to do anything else to be listed on
&gt;&gt; https://www.lysator.liu.se/~nisse/nettle/ ?
&gt;
&gt; If you want to make it really easy for me, please send a patch, the file
&gt; on the web should be a straight copy of
&gt; https://git.lysator.liu.se/nettle/nettle/blob/master/index.html

I didn't know that, thanks.

Btw, I just noticed that the links to the Pike, PostgreSQL, and R6RS
Scheme bindings are dead.


Justus

["signature.asc" (application/pgp-signature)]
[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20191005073920</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-10-05 07:39:20-0400</timestampReceived><subject>Re: Dead links to bindings</subject><body>

Justus Winter &lt;justus@sequoia-pgp.org&gt; writes:

&gt;&gt; If you want to make it really easy for me, please send a patch, the file
&gt;&gt; on the web should be a straight copy of
&gt;&gt; https://git.lysator.liu.se/nettle/nettle/blob/master/index.html
&gt;
&gt; I didn't know that, thanks.

Patches applied, thanks!

&gt; Btw, I just noticed that the links to the Pike, PostgreSQL, and R6RS
&gt; Scheme bindings are dead.

Pike is alive, I've updated the link. The Postgres and scheme bindings,
I don't know, anyone else?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191023214049</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-10-23 21:40:49-0400</timestampReceived><subject>Re: [PATCH 1/2] Implement GOST R 34.11-2012 (Streebog) hash function</subject><body>

ср, 2 окт. 2019 г. в 15:14, &lt;dbaryshkov@gmail.com&gt;:
&gt;
&gt; From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt;
&gt; Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Any feedback on these patches? (And on gost28147?)


-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191024101051</emailId><senderName>Tim_Rühsen</senderName><senderEmail>tim.ruehsen@gmx.de</senderEmail><timestampReceived>2019-10-24 10:10:51-0400</timestampReceived><subject>Re: charset parameter for https://www.lysator.liu.se/~nisse/nettle/nettle.html causing mojibake</subject><body>

[Attachment #2 (multipart/signed)]

[Attachment #4 (multipart/mixed)]


On 10/24/19 11:47 AM, Wim Lewis wrote:
&gt; On Wed, Oct 23, 2019 at 08:14:15PM +0200, Niels Möller wrote:
&gt;&gt; inside &lt;head&gt;...&lt;/head&gt;, which is supposed to override whatever the
&gt;&gt; actual http headers say. And that seems to work.
&gt; 
&gt; That was my understanding as well but I had almost this problem a week 
&gt; or so ago and found that (in modern browsers at least) the HTTP header 
&gt; takes precedence. Web documentation currently[1] says that the meta tag 
&gt; only overrides the charset if the header does not have a charset 
&gt; parameter at all.
&gt; 
&gt; [1] The HTML Living Standard is an utter mess of broken behavior, and I 
&gt;     feel bad using it as a reference, but it seems unambiguous that the 
&gt;     presence of a charset parameter in the HTTP header prevents 
&gt;     re-scanning the document if a meta tag specifies a different 
&gt;     charset:
&gt;        https://html.spec.whatwg.org/multipage/parsing.html#determining-the-character-encoding      

Thanks, Wim.

Niels, considering this, you could perhaps save the HTML document as
iso-8859-1 and change the meta tag to contain "charset=iso-8859-1".

That works as long as you don't use characters outside that charset.

Best solution would be to contact the server admin to remove that
charset info from the Content-Type header. It's a (legacy) bug anyways.

Regards, Tim


["signature.asc" (application/pgp-signature)]
[Attachment #8 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20191029205439</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2019-10-29 20:54:39-0400</timestampReceived><subject>Re: PowerMac G5 results</subject><body>

On Tue, Oct 29, 2019 at 3:01 PM Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; Jeffrey Walton &lt;noloader@gmail.com&gt; writes:
&gt;
&gt; &gt; Hi Everyone,
&gt; &gt;
&gt; &gt; I'm building Nettle 3.5.1 on an old PowerMac G5.
&gt; &gt;
&gt; &gt; gcc -I. -I/usr/local/include -DNDEBUG -DHAVE_CONFIG_H -g2 -O2 -fPIC
&gt; &gt; -pthread -ggdb3 -Wno-pointer-sign -Wall -W   -Wmissing-prototypes
&gt; &gt; -Wmissing-declarations -Wstrict-prototypes   -Wpointer-arith
&gt; &gt; -Wbad-function-cast -Wnested-externs -fPIC -MT xts-aes128.o -MD -MP
&gt; &gt; -MF xts-aes128.o.d -c xts-aes128.c \
&gt; &gt;         &amp;&amp; true
&gt; &gt; xts.c: In function 'xts_shift':
&gt; &gt; xts.c:59: warning: integer constant is too large for 'long' type
&gt; &gt; xts.c:59: warning: integer constant is too large for 'long' type
&gt; &gt; xts.c:60: warning: integer constant is too large for 'long' type
&gt; &gt; xts.c:60: warning: integer constant is too large for 'long' type
&gt; &gt; xts.c:60: warning: integer constant is too large for 'long' type
&gt;
&gt; This looks like it may be a real problem on big-endian 32-bit machines.
&gt; A bit surprised that tests don't fail, the ci runs tests on (emulated)
&gt; mips, and I also did pre-release tests on m68k.
&gt;
&gt; In the code on master, this code is moved to block-internal.h, and use
&gt; UINT64_C for the constants.

Yeah, I think you need this on the old Apple machines with the
modified GCC 4.2.1:

    0x8700000000000000ull

Wrapping it in a macro that adds the ULL may be a good idea. Something like:

#if (_LP64 || __LP64__)
  #define UINT64_C (x) x
#else
  #define UINT64_C (x) xull
#endif

Or you could switch to 32-bit data types for the GF Double function.
32-bit does not materially affect the double. You lose something like
0.002 cpb in the 32-bit version.

Jeff
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191031210158</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-10-31 21:01:58-0400</timestampReceived><subject>Re: Nettle ECC code question</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; Ok, thanks for the clarification. Is it only the case for 521-bit curve
&gt; and for redc-based reduce? Because for all other cases 2 * p &gt; B, so
&gt; mul (and sqr) can not return value greater or equal to 2*m (= 2 * p).

Not sure I understand the question. For a reduced value t (output of
ecc-&gt;mod or ecc-&gt;reduce), we always have both r &lt; B (fits in ecc-&gt;size
limbs) and r &lt; 2 m.

Now, it's true that for many of the ecc-related moduli, we have 2 m &gt; B,
so that r &lt; B ==&gt; r &lt; 2 m, but that makes little difference in this
context. In either case, to reduce r to the canonical range 0 &lt;= r &lt; m,
one conditional subtraction is needed.

One complication is that ecc_mod_add and ecc_mod_sub do *not* ensure r &lt;
2 m, only r &lt; B. So for moduli where 2 m &lt; B, it's possible to get
outputs t &gt;= 2m.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191023173749</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2019-10-23 17:37:49-0400</timestampReceived><subject>charset parameter for https://www.lysator.liu.se/~nisse/nettle/nettle.html causing mojibake</subject><body>

[Attachment #2 (multipart/signed)]


Hi Niels--

i notice that https://www.lysator.liu.se/~nisse/nettle/nettle.html is
served with the HTTP header:

  Content-Type: text/html; charset=iso-8859-1

but it contains non-ASCII text -- your name "Niels MÃ¶ller", but it is
rendered as Niels MÃƒ ¶ller due to the charset parameter.


You can update your nginx config by using the charset directive:

    charset UTF-8;

see https://nginx.org/en/docs/http/ngx_http_charset_module.html#charset
for more detail.

Regards,

        --dkg

["signature.asc" (application/pgp-signature)]
[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20191029175407</emailId><senderName>Jeffrey Walton</senderName><senderEmail>noloader@gmail.com</senderEmail><timestampReceived>2019-10-29 17:54:07-0400</timestampReceived><subject>PowerMac G5 results</subject><body>

Hi Everyone,

I'm building Nettle 3.5.1 on an old PowerMac G5.

gcc -I. -I/usr/local/include -DNDEBUG -DHAVE_CONFIG_H -g2 -O2 -fPIC
-pthread -ggdb3 -Wno-pointer-sign -Wall -W   -Wmissing-prototypes
-Wmissing-declarations -Wstrict-prototypes   -Wpointer-arith
-Wbad-function-cast -Wnested-externs -fPIC -MT xts-aes128.o -MD -MP
-MF xts-aes128.o.d -c xts-aes128.c \
        &amp;&amp; true
xts.c: In function 'xts_shift':
xts.c:59: warning: integer constant is too large for 'long' type
xts.c:59: warning: integer constant is too large for 'long' type
xts.c:60: warning: integer constant is too large for 'long' type
xts.c:60: warning: integer constant is too large for 'long' type
xts.c:60: warning: integer constant is too large for 'long' type

One self test failure, unrelated to XTS mode:

PASS: symbols
dlopen failed: dlopen(../libnettle.so, 2): image not found
../run-tests: line 57: 86075 Abort trap              "$1" $testflags
FAIL: dlopen
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191029190125</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-10-29 19:01:25-0400</timestampReceived><subject>Re: PowerMac G5 results</subject><body>

Jeffrey Walton &lt;noloader@gmail.com&gt; writes:

&gt; Hi Everyone,
&gt;
&gt; I'm building Nettle 3.5.1 on an old PowerMac G5.
&gt;
&gt; gcc -I. -I/usr/local/include -DNDEBUG -DHAVE_CONFIG_H -g2 -O2 -fPIC
&gt; -pthread -ggdb3 -Wno-pointer-sign -Wall -W   -Wmissing-prototypes
&gt; -Wmissing-declarations -Wstrict-prototypes   -Wpointer-arith
&gt; -Wbad-function-cast -Wnested-externs -fPIC -MT xts-aes128.o -MD -MP
&gt; -MF xts-aes128.o.d -c xts-aes128.c \
&gt;         &amp;&amp; true
&gt; xts.c: In function 'xts_shift':
&gt; xts.c:59: warning: integer constant is too large for 'long' type
&gt; xts.c:59: warning: integer constant is too large for 'long' type
&gt; xts.c:60: warning: integer constant is too large for 'long' type
&gt; xts.c:60: warning: integer constant is too large for 'long' type
&gt; xts.c:60: warning: integer constant is too large for 'long' type

This looks like it may be a real problem on big-endian 32-bit machines.
A bit surprised that tests don't fail, the ci runs tests on (emulated)
mips, and I also did pre-release tests on m68k.

In the code on master, this code is moved to block-internal.h, and use
UINT64_C for the constants.

&gt; One self test failure, unrelated to XTS mode:
&gt;
&gt; PASS: symbols
&gt; dlopen failed: dlopen(../libnettle.so, 2): image not found
&gt; ../run-tests: line 57: 86075 Abort trap              "$1" $testflags
&gt; FAIL: dlopen

Old problem, fixed recently, see
https://git.lysator.liu.se/nettle/nettle/commit/c00f4b17f7f38c180ece4c92c50c05feb2e28c2d

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191031120743</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-10-31 12:07:43-0400</timestampReceived><subject>Nettle ECC code question</subject><body>

Hello,

I've noticed the following typical code sequence:

ecc_modp_mul(ecc, t, x, y);
cy = mpn_sub_n(dest, t, ecc-&gt;p.m, ecc-&gt;p.size);
cnd_copy(cy, dest, t, ecc-&gt;p.size);

What is the benefit of this piece of code over the following one?

ecc_modp_mul(ecc, t, x, y);
memcpy(dest, t, ecc-&gt;p.size * sizeof(mp_limb_t));

Does mpn_sun_n/cnd_copy add any form of side channel attach protection?

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191031140028</emailId><senderName>Simo Sorce</senderName><senderEmail>simo@redhat.com</senderEmail><timestampReceived>2019-10-31 14:00:28-0400</timestampReceived><subject>Re: Nettle ECC code question</subject><body>

On Thu, 2019-10-31 at 15:07 +0300, Dmitry Eremin-Solenikov wrote:
&gt; Hello,
&gt; 
&gt; I've noticed the following typical code sequence:
&gt; 
&gt; ecc_modp_mul(ecc, t, x, y);
&gt; cy = mpn_sub_n(dest, t, ecc-&gt;p.m, ecc-&gt;p.size);
&gt; cnd_copy(cy, dest, t, ecc-&gt;p.size);
&gt; 
&gt; What is the benefit of this piece of code over the following one?
&gt; 
&gt; ecc_modp_mul(ecc, t, x, y);
&gt; memcpy(dest, t, ecc-&gt;p.size * sizeof(mp_limb_t));
&gt; 
&gt; Does mpn_sun_n/cnd_copy add any form of side channel attach protection?

cnd_copy provides side-channel protection when you want to make the
copy conditional.

In this case the copy is conditional to the carry being returned from
the subtraction, your code does not look equivalent.

Simo.

-- 
Simo Sorce
RHEL Crypto Team
Red Hat, Inc




_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191031143117</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-10-31 14:31:17-0400</timestampReceived><subject>Re: Nettle ECC code question</subject><body>

чт, 31 окт. 2019 г. в 17:00, Simo Sorce &lt;simo@redhat.com&gt;:
&gt;
&gt; On Thu, 2019-10-31 at 15:07 +0300, Dmitry Eremin-Solenikov wrote:
&gt; &gt; Hello,
&gt; &gt;
&gt; &gt; I've noticed the following typical code sequence:
&gt; &gt;
&gt; &gt; ecc_modp_mul(ecc, t, x, y);
&gt; &gt; cy = mpn_sub_n(dest, t, ecc-&gt;p.m, ecc-&gt;p.size);
&gt; &gt; cnd_copy(cy, dest, t, ecc-&gt;p.size);
&gt; &gt;
&gt; &gt; What is the benefit of this piece of code over the following one?
&gt; &gt;
&gt; &gt; ecc_modp_mul(ecc, t, x, y);
&gt; &gt; memcpy(dest, t, ecc-&gt;p.size * sizeof(mp_limb_t));
&gt; &gt;
&gt; &gt; Does mpn_sun_n/cnd_copy add any form of side channel attach protection?
&gt;
&gt; cnd_copy provides side-channel protection when you want to make the
&gt; copy conditional.
&gt;
&gt; In this case the copy is conditional to the carry being returned from
&gt; the subtraction, your code does not look equivalent.

After ecc_modp_mul() call value of `t` should be already lower than
`ecc-&gt;p.m`. So subtract will always return a carry.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191031145529</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-10-31 14:55:29-0400</timestampReceived><subject>Re: Nettle ECC code question</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; After ecc_modp_mul() call value of `t` should be already lower than
&gt; `ecc-&gt;p.m`. So subtract will always return a carry.

No, the reduction after mul and sqr doesn't produce canonical results.
They only ensure that than t &lt; 2*m. The pattern you see is needed in
places where a canonical representation, t &lt; m, is required.

Result is the same as with if (mpn_cmp(...)) mpn_sub_n(...), but an
unconditional subtraction + cnd_cpy makes that logic side-channel
silent.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191031154227</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-10-31 15:42:27-0400</timestampReceived><subject>Re: Nettle ECC code question</subject><body>

Hello,

чт, 31 окт. 2019 г. в 17:55, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; After ecc_modp_mul() call value of `t` should be already lower than
&gt; &gt; `ecc-&gt;p.m`. So subtract will always return a carry.
&gt;
&gt; No, the reduction after mul and sqr doesn't produce canonical results.
&gt; They only ensure that than t &lt; 2*m. The pattern you see is needed in
&gt; places where a canonical representation, t &lt; m, is required.

Ok, thanks for the clarification. Is it only the case for 521-bit curve
and for redc-based reduce? Because for all other cases 2 * p &gt; B, so
mul (and sqr) can not return value greater or equal to 2*m (= 2 * p).

&gt; Result is the same as with if (mpn_cmp(...)) mpn_sub_n(...), but an
&gt; unconditional subtraction + cnd_cpy makes that logic side-channel
&gt; silent.

Yes, this part is understandable. I was concerned about not copying
the result straight ahead.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191023181415</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-10-23 18:14:15-0400</timestampReceived><subject>Re: charset parameter for https://www.lysator.liu.se/~nisse/nettle/nettle.html causing mojibake</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; i notice that https://www.lysator.liu.se/~nisse/nettle/nettle.html is
&gt; served with the HTTP header:
&gt;
&gt;   Content-Type: text/html; charset=iso-8859-1
&gt;
&gt; but it contains non-ASCII text -- your name "Niels MÃ¶ller", but it is
&gt; rendered as Niels MÃƒ ¶ller due to the charset parameter.

It looks equally bad for me (in firefox).

&gt; You can update your nginx config by using the charset directive:
&gt;
&gt;     charset UTF-8;

I can ask the people maintaining this webserver. I think the nginx only
acts as a reverse-proxy for an apache or possibly roxen server behind
it.

Other html files under https://www.lysator.liu.se/~nisse carries both a 

  &lt;?xml version="1.0" encoding="utf-8"?&gt;

and a

  &lt;meta http-equiv="Content-Type"
        content="text/html; charset=utf-8"/&gt;

inside &lt;head&gt;...&lt;/head&gt;, which is supposed to override whatever the
actual http headers say. And that seems to work.

But nettle.html is generated with makeinfo and looks slightly different.
The nettle.texinfo file includes

  @documentencoding UTF-8

and the generated nettle.html carries a 

  &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;

but it seems that isn't enough. Any clues appreciated.

Regards,
/Niels

-- 
Niels MÃ¶ller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191024003601</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2019-10-24 00:36:01-0400</timestampReceived><subject>Re: charset parameter for https://www.lysator.liu.se/~nisse/nettle/nettle.html causing mojibake</subject><body>

[Attachment #2 (multipart/signed)]


On Wed 2019-10-23 20:14:15 +0200, Niels Möller wrote:
&gt; But nettle.html is generated with makeinfo and looks slightly different.
&gt; The nettle.texinfo file includes
&gt;
&gt;   @documentencoding UTF-8
&gt;
&gt; and the generated nettle.html carries a 
&gt;
&gt;   &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
&gt;
&gt; but it seems that isn't enough. Any clues appreciated.

Alas, i'm out of my depth here :(

fwiw, the one thing that seems to be wrong is the nginx config (or the
backing webserver, if nginx is just proxying, though you can also use
override_charset [0] if you can't fix the backing webserver)

Typically i'd try to fix the thing that's broken rather than trying
override it in some lower level if possible.

I think asking the webserver operator is the right thing to do.

Sorry to not have any better suggestions,

         --dkg

[0] https://nginx.org/en/docs/http/ngx_http_charset_module.html#override_charset

["signature.asc" (application/pgp-signature)]
[Attachment #6 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20191024092125</emailId><senderName>Daniel =?utf-8?B?UC4gQmVycmFuZ8Op?=</senderName><senderEmail>berrange@redhat.com</senderEmail><timestampReceived>2019-10-24 09:21:25-0400</timestampReceived><subject>Re: charset parameter for https://www.lysator.liu.se/~nisse/nettle/nettle.html causing mojibake</subject><body>

On Wed, Oct 23, 2019 at 08:14:15PM +0200, Niels MÃ¶ller wrote:
&gt; Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:
&gt; 
&gt; &gt; i notice that https://www.lysator.liu.se/~nisse/nettle/nettle.html is
&gt; &gt; served with the HTTP header:
&gt; &gt;
&gt; &gt;   Content-Type: text/html; charset=iso-8859-1
&gt; &gt;
&gt; &gt; but it contains non-ASCII text -- your name "Niels MÃ¶ller", but it is
&gt; &gt; rendered as Niels MÃƒ ¶ller due to the charset parameter.
&gt; 
&gt; It looks equally bad for me (in firefox).
&gt; 
&gt; &gt; You can update your nginx config by using the charset directive:
&gt; &gt;
&gt; &gt;     charset UTF-8;
&gt; 
&gt; I can ask the people maintaining this webserver. I think the nginx only
&gt; acts as a reverse-proxy for an apache or possibly roxen server behind
&gt; it.
&gt; 
&gt; Other html files under https://www.lysator.liu.se/~nisse carries both a 
&gt; 
&gt;   &lt;?xml version="1.0" encoding="utf-8"?&gt;
&gt; 
&gt; and a
&gt; 
&gt;   &lt;meta http-equiv="Content-Type"
&gt;         content="text/html; charset=utf-8"/&gt;
&gt; 
&gt; inside &lt;head&gt;...&lt;/head&gt;, which is supposed to override whatever the
&gt; actual http headers say. And that seems to work.
&gt; 
&gt; But nettle.html is generated with makeinfo and looks slightly different.
&gt; The nettle.texinfo file includes
&gt; 
&gt;   @documentencoding UTF-8
&gt; 
&gt; and the generated nettle.html carries a 
&gt; 
&gt;   &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
&gt; 
&gt; but it seems that isn't enough. Any clues appreciated.

The HTTP headers have priority over HTML http-equiv &lt;meta&gt; tag.

Based on the other pages, the &lt;xml&gt; encodings seems to have priority
over both.

Regards,
Daniel
-- 
|: https://berrange.com      -o-    https://www.flickr.com/photos/dberrange :|
|: https://libvirt.org         -o-            https://fstop138.berrange.com :|
|: https://entangle-photo.org    -o-    https://www.instagram.com/dberrange :|

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20191024094747</emailId><senderName>Wim Lewis</senderName><senderEmail>wiml@hhhh.org</senderEmail><timestampReceived>2019-10-24 09:47:47-0400</timestampReceived><subject>Re: charset parameter for https://www.lysator.liu.se/~nisse/nettle/nettle.html causing mojibake</subject><body>

On Wed, Oct 23, 2019 at 08:14:15PM +0200, Niels Möller wrote:
&gt; inside &lt;head&gt;...&lt;/head&gt;, which is supposed to override whatever the
&gt; actual http headers say. And that seems to work.

That was my understanding as well but I had almost this problem a week 
or so ago and found that (in modern browsers at least) the HTTP header 
takes precedence. Web documentation currently[1] says that the meta tag 
only overrides the charset if the header does not have a charset 
parameter at all.

[1] The HTML Living Standard is an utter mess of broken behavior, and I 
    feel bad using it as a reference, but it seems unambiguous that the 
    presence of a charset parameter in the HTTP header prevents 
    re-scanning the document if a meta tag specifies a different 
    charset:
       https://html.spec.whatwg.org/multipage/parsing.html#determining-the-character-encoding      

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190903193116</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-09-03 19:31:16-0400</timestampReceived><subject>Re: [PATCH 3/5] block-internal: add block XORing functions</subject><body>

Hello,

вт, 3 сент. 2019 г. в 20:05, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; dbaryshkov@gmail.com writes:
&gt;
&gt; &gt; From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt; &gt;
&gt; &gt; Add common implementations for functions doing XOR over
&gt; &gt; nettle_block16/nettle_block8.
&gt;
&gt; I've merged the first two patches. Thanks! Do you know if anyone is using
&gt; GCM_TABLE_BITS 4? I've tested that it still works, both before and after
&gt; your change, but I don't test it regularly.

I don't know. As the size difference between GCM_TABLE_BITS being 4 and 8
is not that big, maybe we can drop it alltogether. I can send a patch ;-)

&gt; &gt; +static inline void
&gt; &gt; +block16_xor_bytes (union nettle_block16 *r,
&gt; &gt; +                const union nettle_block16 *x,
&gt; &gt; +                const uint8_t *bytes)
&gt; &gt; +{
&gt; &gt; +  memxor3 (r-&gt;b, x-&gt;b, bytes, 16);
&gt; &gt; +}
&gt;
&gt; [...]
&gt;
&gt; &gt; +static inline void
&gt; &gt; +block8_xor_bytes (union nettle_block8 *r,
&gt; &gt; +                const union nettle_block8 *x,
&gt; &gt; +                const uint8_t *bytes)
&gt; &gt; +{
&gt; &gt; +  memxor3 (r-&gt;b, x-&gt;b, bytes, 8);
&gt; &gt; +}
&gt;
&gt; Not sure these two wrappers are that helpful. Do you have a good
&gt; reason to add them?

They fit into cmac128/cmac64/siv-cmac code, as they simplify code
there a bit. Using them you just say that Block1 = Block2  ^
bytestring, rather than XORing Block.b fields.

If you'd like, I can drop them, but from my point of view they look
like good encapsulation.

&gt;
&gt; The rest of the patch looks like a nice consolidation.
&gt;
&gt; &gt; --- a/gcm.c
&gt; &gt; +++ b/gcm.c
&gt; &gt; @@ -53,16 +53,10 @@
&gt; &gt;  #include "nettle-internal.h"
&gt; &gt;  #include "macros.h"
&gt; &gt;  #include "ctr-internal.h"
&gt; &gt; +#include "block-internal.h"
&gt; &gt;
&gt; &gt;  #define GHASH_POLYNOMIAL 0xE1UL
&gt; &gt;
&gt; &gt; -static void
&gt; &gt; -gcm_gf_add (union nettle_block16 *r,
&gt; &gt; -         const union nettle_block16 *x, const union nettle_block16 *y)
&gt; &gt; -{
&gt; &gt; -  r-&gt;u64[0] = x-&gt;u64[0] ^ y-&gt;u64[0];
&gt; &gt; -  r-&gt;u64[1] = x-&gt;u64[1] ^ y-&gt;u64[1];
&gt; &gt; -}
&gt; &gt;  /* Multiplication by 010...0; a big-endian shift right. If the bit
&gt; &gt;     shifted out is one, the defining polynomial is added to cancel it
&gt; &gt;     out. r == x is allowed. */
&gt; &gt; @@ -108,7 +102,7 @@ gcm_gf_mul (union nettle_block16 *x, const union nettle_block16 *y)
&gt; &gt;        for (j = 0; j &lt; 8; j++, b &lt;&lt;= 1)
&gt; &gt;       {
&gt; &gt;         if (b &amp; 0x80)
&gt; &gt; -         gcm_gf_add(&amp;Z, &amp;Z, &amp;V);
&gt; &gt; +         block16_xor3(&amp;Z, &amp;Z, &amp;V);
&gt;
&gt; This and few other calls below can be block16_xor rather than block16_xor3.

Will fix in next iteration.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190903231825</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-09-03 23:18:25-0400</timestampReceived><subject>Re: [PATCH 4/5] block modes: move Galois shifts to block-internal.h</subject><body>

вт, 3 сент. 2019 г. в 20:26, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; dbaryshkov@gmail.com writes:
&gt;
&gt; &gt; From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt; &gt;
&gt; &gt; Move Galois polynomial shifts to block-internal.h, simplifying common
&gt; &gt; code. GCM is left unconverted for now, this will be fixed later.
&gt;
&gt; Thanks for cleaning this up! Some comments below.
&gt;
&gt; &gt; --- a/block-internal.h
&gt; &gt; +++ b/block-internal.h
&gt; &gt; @@ -90,4 +90,80 @@ block8_xor_bytes (union nettle_block8 *r,
&gt; &gt;    memxor3 (r-&gt;b, x-&gt;b, bytes, 8);
&gt; &gt;  }
&gt; &gt;
&gt; &gt; +#define LSHIFT_WORD(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
&gt; &gt; +                     (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
&gt; &gt; +#define RSHIFT_WORD(x) ((((x) &amp; 0xfefefefefefefefe) &gt;&gt; 1) | \
&gt; &gt; +                     (((x) &amp; 0x0001010101010101) &lt;&lt; 15))
&gt;
&gt; Names of these macros should say U64 or UINT64 rather than WORD. And
&gt; something to suggest that they're for alien endianness. Maybe
&gt; "LSHIFT_ALIEN_UINT64.

Ack

&gt; And UINT64_C for the constants.

Ack

&gt; &gt; +/* Galois multiplications by 2:
&gt; &gt; + * functions differ in shifting right or left, big- or little- endianness
&gt; &gt; + * and by defininy polynom.
&gt; &gt; + * r == x is allowed. */
&gt;
&gt; This is a bit complex, perhaps it can be clarified a bit. We have both
&gt; the issue of big or little byte order within words. And bit order used
&gt; for representating of the polynomial: usually a less significant bit
&gt; within a byte represents a coefficient for a smaller power of the
&gt; polynomial variable x, but one of the algorithms (I can't recall which
&gt; one) uses opposite bit order.

For GCM. This is why I left it unconverted in this step.

&gt; And if I remember correctly, they all use the same polynomial, but due
&gt; to bit-order differences, there are two different ways to represent it.
&gt; Which of the functions are called with more than one constant for the
&gt; poly argument?

They take 0x87 for block16 functions and 0x1b for block8. Except GCM,
which uses 0xE1. I will probably inline these values.


&gt; And "defining" is misspelled.

Ack

&gt; &gt; +#if WORDS_BIGENDIAN
&gt; &gt; +static inline void
&gt; &gt; +block16_lshift_be (union nettle_block16 *dst,
&gt; &gt; +                const union nettle_block16 *src,
&gt; &gt; +                uint64_t poly)
&gt; &gt; +{
&gt; &gt; +  uint64_t carry = src-&gt;u64[0] &gt;&gt; 63;
&gt; &gt; +  dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
&gt; &gt; +  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) ^ (poly &amp; -carry);
&gt; &gt; +}
&gt; &gt; +#else /* !WORDS_BIGENDIAN */
&gt;
&gt; There will be less clutter if all code for #if WORDS_BIGENDIAN is
&gt; grouped together. And I think I prefer "mulx" rather than "shift"
&gt; somewhere in the name, to indicate that it's not a plain shift.

Ack

&gt;
&gt; &gt; --- a/cmac.c
&gt; &gt; +++ b/cmac.c
&gt; &gt; @@ -44,32 +44,16 @@
&gt; &gt;
&gt; &gt;  #include "memxor.h"
&gt; &gt;  #include "nettle-internal.h"
&gt; &gt; -#include "cmac-internal.h"
&gt; &gt;  #include "block-internal.h"
&gt; &gt;  #include "macros.h"
&gt; &gt;
&gt; &gt;  /* shift one and XOR with 0x87. */
&gt; &gt; -#if WORDS_BIGENDIAN
&gt; &gt; -void
&gt; &gt; -_cmac128_block_mulx(union nettle_block16 *dst,
&gt; &gt; -                 const union nettle_block16 *src)
&gt; &gt; -{
&gt; &gt; -  uint64_t carry = src-&gt;u64[0] &gt;&gt; 63;
&gt; &gt; -  dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
&gt; &gt; -  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) ^ (0x87 &amp; -carry);
&gt; &gt; -}
&gt; &gt; -#else /* !WORDS_BIGENDIAN */
&gt; &gt; -#define LE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
&gt; &gt; -                     (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
&gt; &gt; -void
&gt; &gt; +static inline void
&gt; &gt;  _cmac128_block_mulx(union nettle_block16 *dst,
&gt; &gt;                   const union nettle_block16 *src)
&gt; &gt;  {
&gt; &gt; -  uint64_t carry = (src-&gt;u64[0] &amp; 0x80) &gt;&gt; 7;
&gt; &gt; -  dst-&gt;u64[0] = LE_SHIFT(src-&gt;u64[0]) | ((src-&gt;u64[1] &amp; 0x80) &lt;&lt; 49);
&gt; &gt; -  dst-&gt;u64[1] = LE_SHIFT(src-&gt;u64[1]) ^ (0x8700000000000000 &amp; -carry);
&gt; &gt; +  block16_lshift_be(dst, src, 0x87);
&gt; &gt;  }
&gt; &gt; -#endif /* !WORDS_BIGENDIAN */
&gt;
&gt; I think it's clearer to delete this and similar wrappers.

Ack

--
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190904061029</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-09-04 06:10:29-0400</timestampReceived><subject>[PATCH v2 1/4] block-internal: add block XORing functions</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Add common implementations for functions doing XOR over
nettle_block16/nettle_block8.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in      |  3 +-
 block-internal.h | 93 ++++++++++++++++++++++++++++++++++++++++++++++++
 cmac.c           | 11 +++---
 cmac64.c         | 12 +++----
 eax.c            |  9 +----
 gcm.c            | 20 ++++-------
 siv-cmac.c       |  9 ++---
 7 files changed, 120 insertions(+), 37 deletions(-)
 create mode 100644 block-internal.h

diff --git a/Makefile.in b/Makefile.in
index af4f6e46ee9b..f6658c86341c 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -230,7 +230,8 @@ DISTFILES = $(SOURCES) $(HEADERS) getopt.h getopt_int.h \
 	INSTALL NEWS ChangeLog \
 	nettle.pc.in hogweed.pc.in \
 	$(des_headers) descore.README desdata.stamp \
-	aes-internal.h camellia-internal.h cmac-internal.h serpent-internal.h \
+	aes-internal.h block-internal.h \
+	camellia-internal.h cmac-internal.h serpent-internal.h \
 	cast128_sboxes.h desinfo.h desCode.h \
 	ripemd160-internal.h sha2-internal.h \
 	memxor-internal.h nettle-internal.h nettle-write.h \
diff --git a/block-internal.h b/block-internal.h
new file mode 100644
index 000000000000..ab3a6a79b8cb
--- /dev/null
+++ b/block-internal.h
@@ -0,0 +1,93 @@
+/* block-internal.h
+
+   Internal implementations of nettle_blockZ-related functions.
+
+   Copyright (C) 2011 Katholieke Universiteit Leuven
+   Copyright (C) 2011, 2013, 2018 Niels Möller
+   Copyright (C) 2018 Red Hat, Inc.
+   Copyright (C) 2019 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_BLOCK_INTERNAL_H_INCLUDED
+#define NETTLE_BLOCK_INTERNAL_H_INCLUDED
+
+#include &lt;assert.h&gt;
+
+#include "nettle-types.h"
+#include "memxor.h"
+
+static inline void
+block16_xor (union nettle_block16 *r,
+	     const union nettle_block16 *x)
+{
+  r-&gt;u64[0] ^= x-&gt;u64[0];
+  r-&gt;u64[1] ^= x-&gt;u64[1];
+}
+
+static inline void
+block16_xor3 (union nettle_block16 *r,
+	      const union nettle_block16 *x,
+	      const union nettle_block16 *y)
+{
+  r-&gt;u64[0] = x-&gt;u64[0] ^ y-&gt;u64[0];
+  r-&gt;u64[1] = x-&gt;u64[1] ^ y-&gt;u64[1];
+}
+
+static inline void
+block16_xor_bytes (union nettle_block16 *r,
+		   const union nettle_block16 *x,
+		   const uint8_t *bytes)
+{
+  memxor3 (r-&gt;b, x-&gt;b, bytes, 16);
+}
+
+static inline void
+block8_xor (union nettle_block8 *r,
+	    const union nettle_block8 *x)
+{
+  r-&gt;u64 ^= x-&gt;u64;
+}
+
+static inline void
+block8_xor3 (union nettle_block8 *r,
+	     const union nettle_block8 *x,
+	     const union nettle_block8 *y)
+{
+  r-&gt;u64 = x-&gt;u64 ^ y-&gt;u64;
+}
+
+static inline void
+block8_xor_bytes (union nettle_block8 *r,
+		  const union nettle_block8 *x,
+		  const uint8_t *bytes)
+{
+  memxor3 (r-&gt;b, x-&gt;b, bytes, 8);
+}
+
+#endif /* NETTLE_BLOCK_INTERNAL_H_INCLUDED */
diff --git a/cmac.c b/cmac.c
index 70ce8132d9d1..194324421c58 100644
--- a/cmac.c
+++ b/cmac.c
@@ -45,6 +45,7 @@
 #include "memxor.h"
 #include "nettle-internal.h"
 #include "cmac-internal.h"
+#include "block-internal.h"
 #include "macros.h"
 
 /* shift one and XOR with 0x87. */
@@ -119,12 +120,12 @@ cmac128_update(struct cmac128_ctx *ctx, const void *cipher,
   /*
    * now checksum everything but the last block
    */
-  memxor3(Y.b, ctx-&gt;X.b, ctx-&gt;block.b, 16);
+  block16_xor3(&amp;Y, &amp;ctx-&gt;X, &amp;ctx-&gt;block);
   encrypt(cipher, 16, ctx-&gt;X.b, Y.b);
 
   while (msg_len &gt; 16)
     {
-      memxor3(Y.b, ctx-&gt;X.b, msg, 16);
+      block16_xor_bytes (&amp;Y, &amp;ctx-&gt;X, msg);
       encrypt(cipher, 16, ctx-&gt;X.b, Y.b);
       msg += 16;
       msg_len -= 16;
@@ -151,14 +152,14 @@ cmac128_digest(struct cmac128_ctx *ctx, const struct cmac128_key *key,
       ctx-&gt;block.b[ctx-&gt;index] = 0x80;
       memset(ctx-&gt;block.b + ctx-&gt;index + 1, 0, 16 - 1 - ctx-&gt;index);
 
-      memxor(ctx-&gt;block.b, key-&gt;K2.b, 16);
+      block16_xor (&amp;ctx-&gt;block, &amp;key-&gt;K2);
     }
   else
     {
-      memxor(ctx-&gt;block.b, key-&gt;K1.b, 16);
+      block16_xor (&amp;ctx-&gt;block, &amp;key-&gt;K1);
     }
 
-  memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 16);
+  block16_xor3 (&amp;Y, &amp;ctx-&gt;block, &amp;ctx-&gt;X);
 
   assert(length &lt;= 16);
   if (length == 16)
diff --git a/cmac64.c b/cmac64.c
index 636635ba478b..e7bb438580d6 100644
--- a/cmac64.c
+++ b/cmac64.c
@@ -43,8 +43,8 @@
 
 #include "cmac.h"
 
-#include "memxor.h"
 #include "nettle-internal.h"
+#include "block-internal.h"
 #include "macros.h"
 
 /* shift one and XOR with 0x87. */
@@ -119,12 +119,12 @@ cmac64_update(struct cmac64_ctx *ctx, const void *cipher,
   /*
    * now checksum everything but the last block
    */
-  memxor3(Y.b, ctx-&gt;X.b, ctx-&gt;block.b, 8);
+  block8_xor3(&amp;Y, &amp;ctx-&gt;X, &amp;ctx-&gt;block);
   encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
 
   while (msg_len &gt; 8)
     {
-      memxor3(Y.b, ctx-&gt;X.b, msg, 8);
+      block8_xor_bytes(&amp;Y, &amp;ctx-&gt;X, msg);
       encrypt(cipher, 8, ctx-&gt;X.b, Y.b);
       msg += 8;
       msg_len -= 8;
@@ -151,14 +151,14 @@ cmac64_digest(struct cmac64_ctx *ctx, const struct cmac64_key *key,
   if (ctx-&gt;index &lt; 8)
     {
       ctx-&gt;block.b[ctx-&gt;index] = 0x80;
-      memxor(ctx-&gt;block.b, key-&gt;K2.b, 8);
+      block8_xor(&amp;ctx-&gt;block, &amp;key-&gt;K2);
     }
   else
     {
-      memxor(ctx-&gt;block.b, key-&gt;K1.b, 8);
+      block8_xor(&amp;ctx-&gt;block, &amp;key-&gt;K1);
     }
 
-  memxor3(Y.b, ctx-&gt;block.b, ctx-&gt;X.b, 8);
+  block8_xor3(&amp;Y, &amp;ctx-&gt;block, &amp;ctx-&gt;X);
 
   assert(length &lt;= 8);
   if (length == 8)
diff --git a/eax.c b/eax.c
index 4b8b5117746e..63f3ff82fe65 100644
--- a/eax.c
+++ b/eax.c
@@ -40,6 +40,7 @@
 
 #include "eax.h"
 
+#include "block-internal.h"
 #include "ctr.h"
 #include "memxor.h"
 
@@ -50,14 +51,6 @@ omac_init (union nettle_block16 *state, unsigned t)
   state-&gt;b[EAX_BLOCK_SIZE - 1] = t;
 }
 
-/* Almost the same as gcm_gf_add */
-static void
-block16_xor (union nettle_block16 *dst, const union nettle_block16 *src)
-{
-  dst-&gt;u64[0] ^= src-&gt;u64[0];
-  dst-&gt;u64[1] ^= src-&gt;u64[1];
-}
-
 static void
 omac_update (union nettle_block16 *state, const struct eax_key *key,
 	     const void *cipher, nettle_cipher_func *f,
diff --git a/gcm.c b/gcm.c
index 627097b24218..4a04a0a10842 100644
--- a/gcm.c
+++ b/gcm.c
@@ -53,16 +53,10 @@
 #include "nettle-internal.h"
 #include "macros.h"
 #include "ctr-internal.h"
+#include "block-internal.h"
 
 #define GHASH_POLYNOMIAL 0xE1UL
 
-static void
-gcm_gf_add (union nettle_block16 *r,
-	    const union nettle_block16 *x, const union nettle_block16 *y)
-{
-  r-&gt;u64[0] = x-&gt;u64[0] ^ y-&gt;u64[0];
-  r-&gt;u64[1] = x-&gt;u64[1] ^ y-&gt;u64[1];
-}
 /* Multiplication by 010...0; a big-endian shift right. If the bit
    shifted out is one, the defining polynomial is added to cancel it
    out. r == x is allowed. */
@@ -108,7 +102,7 @@ gcm_gf_mul (union nettle_block16 *x, const union nettle_block16 *y)
       for (j = 0; j &lt; 8; j++, b &lt;&lt;= 1)
 	{
 	  if (b &amp; 0x80)
-	    gcm_gf_add(&amp;Z, &amp;Z, &amp;V);
+	    block16_xor(&amp;Z, &amp;V);
 	  
 	  gcm_gf_shift(&amp;V, &amp;V);
 	}
@@ -165,9 +159,9 @@ gcm_gf_mul (union nettle_block16 *x, const union nettle_block16 *table)
       uint8_t b = x-&gt;b[i];
 
       gcm_gf_shift_4(&amp;Z);
-      gcm_gf_add(&amp;Z, &amp;Z, &amp;table[b &amp; 0xf]);
+      block16_xor(&amp;Z, &amp;table[b &amp; 0xf]);
       gcm_gf_shift_4(&amp;Z);
-      gcm_gf_add(&amp;Z, &amp;Z, &amp;table[b &gt;&gt; 4]);
+      block16_xor(&amp;Z, &amp;table[b &gt;&gt; 4]);
     }
   memcpy (x-&gt;b, Z.b, sizeof(Z));
 }
@@ -243,10 +237,10 @@ gcm_gf_mul (union nettle_block16 *x, const union nettle_block16 *table)
   for (i = GCM_BLOCK_SIZE-2; i &gt; 0; i--)
     {
       gcm_gf_shift_8(&amp;Z);
-      gcm_gf_add(&amp;Z, &amp;Z, &amp;table[x-&gt;b[i]]);
+      block16_xor(&amp;Z, &amp;table[x-&gt;b[i]]);
     }
   gcm_gf_shift_8(&amp;Z);
-  gcm_gf_add(x, &amp;Z, &amp;table[x-&gt;b[0]]);
+  block16_xor3(x, &amp;Z, &amp;table[x-&gt;b[0]]);
 }
 #  endif /* ! HAVE_NATIVE_gcm_hash8 */
 # else /* GCM_TABLE_BITS != 8 */
@@ -286,7 +280,7 @@ gcm_set_key(struct gcm_key *key,
     {
       unsigned j;
       for (j = 1; j &lt; i; j++)
-	gcm_gf_add(&amp;key-&gt;h[i+j], &amp;key-&gt;h[i],&amp;key-&gt;h[j]);
+	block16_xor3(&amp;key-&gt;h[i+j], &amp;key-&gt;h[i],&amp;key-&gt;h[j]);
     }
 #endif
 }
diff --git a/siv-cmac.c b/siv-cmac.c
index f498cb863f5a..42f740cddf5d 100644
--- a/siv-cmac.c
+++ b/siv-cmac.c
@@ -46,6 +46,7 @@
 #include "memops.h"
 #include "cmac-internal.h"
 #include "nettle-internal.h"
+#include "block-internal.h"
 
 /* This is an implementation of S2V for the AEAD case where
  * vectors if zero, are considered as S empty components */
@@ -69,12 +70,12 @@ _siv_s2v (const struct nettle_cipher *nc,
   _cmac128_block_mulx (&amp;D, &amp;D);
   cmac128_update (&amp;cmac_ctx, cmac_cipher, nc-&gt;encrypt, alength, adata);
   cmac128_digest (&amp;cmac_ctx, cmac_key, cmac_cipher, nc-&gt;encrypt, 16, S.b);
-  memxor (D.b, S.b, 16);
+  block16_xor (&amp;D, &amp;S);
 
   _cmac128_block_mulx (&amp;D, &amp;D);
   cmac128_update (&amp;cmac_ctx, cmac_cipher, nc-&gt;encrypt, nlength, nonce);
   cmac128_digest (&amp;cmac_ctx, cmac_key, cmac_cipher, nc-&gt;encrypt, 16, S.b);
-  memxor (D.b, S.b, 16);
+  block16_xor (&amp;D, &amp;S);
 
   /* Sn */
   if (plength &gt;= 16)
@@ -83,7 +84,7 @@ _siv_s2v (const struct nettle_cipher *nc,
 
       pdata += plength - 16;
 
-      memxor3 (T.b, pdata, D.b, 16);
+      block16_xor_bytes (&amp;T, &amp;D, pdata);
     }
   else
     {
@@ -95,7 +96,7 @@ _siv_s2v (const struct nettle_cipher *nc,
       if (plength + 1 &lt; 16)
 	memset (&amp;pad.b[plength + 1], 0, 16 - plength - 1);
 
-      memxor (T.b, pad.b, 16);
+      block16_xor (&amp;T, &amp;pad);
     }
 
   cmac128_update (&amp;cmac_ctx, cmac_cipher, nc-&gt;encrypt, 16, T.b);
-- 
2.23.0.rc1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190904061030</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-09-04 06:10:30-0400</timestampReceived><subject>[PATCH v2 2/4] block modes: move Galois shifts to block-internal.h</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Move Galois polynomial shifts to block-internal.h, simplifying common
code. GCM is left unconverted for now, this will be fixed later.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in       |  2 +-
 block-internal.h  | 72 +++++++++++++++++++++++++++++++++++++++++++++++
 cmac-internal.h   | 54 -----------------------------------
 cmac.c            | 28 ++----------------
 cmac64.c          | 27 ++----------------
 eax.c             | 18 ++----------
 siv-cmac-aes128.c |  1 -
 siv-cmac-aes256.c |  1 -
 siv-cmac.c        |  7 ++---
 xts.c             | 34 ++++------------------
 10 files changed, 87 insertions(+), 157 deletions(-)
 delete mode 100644 cmac-internal.h

diff --git a/Makefile.in b/Makefile.in
index f6658c86341c..ae9c8a7563f9 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -231,7 +231,7 @@ DISTFILES = $(SOURCES) $(HEADERS) getopt.h getopt_int.h \
 	nettle.pc.in hogweed.pc.in \
 	$(des_headers) descore.README desdata.stamp \
 	aes-internal.h block-internal.h \
-	camellia-internal.h cmac-internal.h serpent-internal.h \
+	camellia-internal.h serpent-internal.h \
 	cast128_sboxes.h desinfo.h desCode.h \
 	ripemd160-internal.h sha2-internal.h \
 	memxor-internal.h nettle-internal.h nettle-write.h \
diff --git a/block-internal.h b/block-internal.h
index ab3a6a79b8cb..8972d0ac2b5b 100644
--- a/block-internal.h
+++ b/block-internal.h
@@ -90,4 +90,76 @@ block8_xor_bytes (union nettle_block8 *r,
   memxor3 (r-&gt;b, x-&gt;b, bytes, 8);
 }
 
+/* Do a foreign-endianness shift of data */
+
+#define LSHIFT_ALIEN_UINT64(x) \
+	((((x) &amp; UINT64_C(0x7f7f7f7f7f7f7f7f)) &lt;&lt; 1) | \
+	 (((x) &amp; UINT64_C(0x8080808080808080)) &gt;&gt; 15))
+
+/* Two typical defining polynoms */
+
+#define BLOCK16_POLY (UINT64_C(0x87))
+#define BLOCK8_POLY (UINT64_C(0x1b))
+
+/* Galois multiplications by 2:
+ * functions differ in shifting right or left, big- or little- endianness
+ * and by defining polynom.
+ * r == x is allowed. */
+
+#if WORDS_BIGENDIAN
+static inline void
+block16_mulx_be (union nettle_block16 *dst,
+		 const union nettle_block16 *src)
+{
+  uint64_t carry = src-&gt;u64[0] &gt;&gt; 63;
+  dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
+  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) ^ (BLOCK16_POLY &amp; -carry);
+}
+
+static inline void
+block16_mulx_le (union nettle_block16 *dst,
+		 const union nettle_block16 *src)
+{
+  uint64_t carry = (src-&gt;u64[1] &amp; 0x80) &gt;&gt; 7;
+  dst-&gt;u64[1] = LSHIFT_ALIEN_UINT64(src-&gt;u64[1]) | ((src-&gt;u64[0] &amp; 0x80) &lt;&lt; 49);
+  dst-&gt;u64[0] = LSHIFT_ALIEN_UINT64(src-&gt;u64[0]) ^ ((BLOCK16_POLY &lt;&lt; 56) &amp; -carry);
+}
+
+static inline void
+block8_mulx_be (union nettle_block8 *dst,
+		const union nettle_block8 *src)
+{
+  uint64_t carry = src-&gt;u64 &gt;&gt; 63;
+
+  dst-&gt;u64 = (src-&gt;u64 &lt;&lt; 1) ^ (BLOCK8_POLY &amp; -carry);
+}
+#else /* !WORDS_BIGENDIAN */
+static inline void
+block16_mulx_be (union nettle_block16 *dst,
+		 const union nettle_block16 *src)
+{
+  uint64_t carry = (src-&gt;u64[0] &amp; 0x80) &gt;&gt; 7;
+  dst-&gt;u64[0] = LSHIFT_ALIEN_UINT64(src-&gt;u64[0]) | ((src-&gt;u64[1] &amp; 0x80) &lt;&lt; 49);
+  dst-&gt;u64[1] = LSHIFT_ALIEN_UINT64(src-&gt;u64[1]) ^ ((BLOCK16_POLY &lt;&lt; 56) &amp; -carry);
+}
+
+static inline void
+block16_mulx_le (union nettle_block16 *dst,
+		 const union nettle_block16 *src)
+{
+  uint64_t carry = src-&gt;u64[1] &gt;&gt; 63;
+  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) | (src-&gt;u64[0] &gt;&gt; 63);
+  dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) ^ (BLOCK16_POLY &amp; -carry);
+}
+
+static inline void
+block8_mulx_be (union nettle_block8 *dst,
+		const union nettle_block8 *src)
+{
+  uint64_t carry = (src-&gt;u64 &amp; 0x80) &gt;&gt; 7;
+
+  dst-&gt;u64 = LSHIFT_ALIEN_UINT64(src-&gt;u64) ^ ((BLOCK8_POLY &lt;&lt; 56) &amp; -carry);
+}
+#endif /* !WORDS_BIGENDIAN */
+
 #endif /* NETTLE_BLOCK_INTERNAL_H_INCLUDED */
diff --git a/cmac-internal.h b/cmac-internal.h
deleted file mode 100644
index 80db7fcc58cd..000000000000
--- a/cmac-internal.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/* cmac-internal.h
-
-   CMAC mode internal functions
-
-   Copyright (C) 2017 Red Hat, Inc.
-
-   Contributed by Nikos Mavrogiannopoulos
-
-   This file is part of GNU Nettle.
-
-   GNU Nettle is free software: you can redistribute it and/or
-   modify it under the terms of either:
-
-     * the GNU Lesser General Public License as published by the Free
-       Software Foundation; either version 3 of the License, or (at your
-       option) any later version.
-
-   or
-
-     * the GNU General Public License as published by the Free
-       Software Foundation; either version 2 of the License, or (at your
-       option) any later version.
-
-   or both in parallel, as here.
-
-   GNU Nettle is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   You should have received copies of the GNU General Public License and
-   the GNU Lesser General Public License along with this program.  If
-   not, see http://www.gnu.org/licenses/.
-*/
-
-#ifndef NETTLE_CMAC_INTERNAL_H_INCLUDED
-#define NETTLE_CMAC_INTERNAL_H_INCLUDED
-
-#include "cmac.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define _cmac128_block_mulx _nettle_cmac128_block_mulx
-
-void _cmac128_block_mulx(union nettle_block16 *out,
-			 const union nettle_block16 *in);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* CMAC_INTERNAL_H_INCLUDED */
diff --git a/cmac.c b/cmac.c
index 194324421c58..af9b3c2c0cf4 100644
--- a/cmac.c
+++ b/cmac.c
@@ -44,33 +44,9 @@
 
 #include "memxor.h"
 #include "nettle-internal.h"
-#include "cmac-internal.h"
 #include "block-internal.h"
 #include "macros.h"
 
-/* shift one and XOR with 0x87. */
-#if WORDS_BIGENDIAN
-void
-_cmac128_block_mulx(union nettle_block16 *dst,
-		    const union nettle_block16 *src)
-{
-  uint64_t carry = src-&gt;u64[0] &gt;&gt; 63;
-  dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
-  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) ^ (0x87 &amp; -carry);
-}
-#else /* !WORDS_BIGENDIAN */
-#define LE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
-                     (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
-void
-_cmac128_block_mulx(union nettle_block16 *dst,
-		    const union nettle_block16 *src)
-{
-  uint64_t carry = (src-&gt;u64[0] &amp; 0x80) &gt;&gt; 7;
-  dst-&gt;u64[0] = LE_SHIFT(src-&gt;u64[0]) | ((src-&gt;u64[1] &amp; 0x80) &lt;&lt; 49);
-  dst-&gt;u64[1] = LE_SHIFT(src-&gt;u64[1]) ^ (0x8700000000000000 &amp; -carry);
-}
-#endif /* !WORDS_BIGENDIAN */
-
 void
 cmac128_set_key(struct cmac128_key *key, const void *cipher,
 		nettle_cipher_func *encrypt)
@@ -81,8 +57,8 @@ cmac128_set_key(struct cmac128_key *key, const void *cipher,
   /* step 1 - generate subkeys k1 and k2 */
   encrypt(cipher, 16, L.b, zero_block.b);
 
-  _cmac128_block_mulx(&amp;key-&gt;K1, &amp;L);
-  _cmac128_block_mulx(&amp;key-&gt;K2, &amp;key-&gt;K1);
+  block16_mulx_be(&amp;key-&gt;K1, &amp;L);
+  block16_mulx_be(&amp;key-&gt;K2, &amp;key-&gt;K1);
 }
 
 void
diff --git a/cmac64.c b/cmac64.c
index e7bb438580d6..e4be1b547c50 100644
--- a/cmac64.c
+++ b/cmac64.c
@@ -47,29 +47,6 @@
 #include "block-internal.h"
 #include "macros.h"
 
-/* shift one and XOR with 0x87. */
-#if WORDS_BIGENDIAN
-static void
-_cmac64_block_mulx(union nettle_block8 *dst,
-	    const union nettle_block8 *src)
-{
-  uint64_t carry = src-&gt;u64 &gt;&gt; 63;
-
-  dst-&gt;u64 = (src-&gt;u64 &lt;&lt; 1) ^ (0x1b &amp; -carry);
-}
-#else /* !WORDS_BIGENDIAN */
-#define LE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
-                     (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
-static void
-_cmac64_block_mulx(union nettle_block8 *dst,
-	   const union nettle_block8 *src)
-{
-  uint64_t carry = (src-&gt;u64 &amp; 0x80) &gt;&gt; 7;
-
-  dst-&gt;u64 = LE_SHIFT(src-&gt;u64) ^ (0x1b00000000000000 &amp; -carry);
-}
-#endif /* !WORDS_BIGENDIAN */
-
 void
 cmac64_set_key(struct cmac64_key *key, const void *cipher,
 	       nettle_cipher_func *encrypt)
@@ -80,8 +57,8 @@ cmac64_set_key(struct cmac64_key *key, const void *cipher,
   /* step 1 - generate subkeys k1 and k2 */
   encrypt(cipher, 8, L.b, zero_block.b);
 
-  _cmac64_block_mulx(&amp;key-&gt;K1, &amp;L);
-  _cmac64_block_mulx(&amp;key-&gt;K2, &amp;key-&gt;K1);
+  block8_mulx_be(&amp;key-&gt;K1, &amp;L);
+  block8_mulx_be(&amp;key-&gt;K2, &amp;key-&gt;K1);
 }
 
 void
diff --git a/eax.c b/eax.c
index 63f3ff82fe65..f0b6fac5c5b1 100644
--- a/eax.c
+++ b/eax.c
@@ -82,27 +82,13 @@ omac_final (union nettle_block16 *state, const struct eax_key *key,
   f (cipher, EAX_BLOCK_SIZE, state-&gt;b, state-&gt;b);
 }
 
-/* Allows r == a */
-static void
-gf2_double (uint8_t *r, const uint8_t *a)
-{
-  unsigned high = - (a[0] &gt;&gt; 7);
-  unsigned i;
-  /* Shift left */
-  for (i = 0; i &lt; EAX_BLOCK_SIZE - 1; i++)
-    r[i] = (a[i] &lt;&lt; 1) + (a[i+1] &gt;&gt; 7);
-
-  /* Wrap around for x^{128} = x^7 + x^2 + x + 1 */
-  r[EAX_BLOCK_SIZE - 1] = (a[EAX_BLOCK_SIZE - 1] &lt;&lt; 1) ^ (high &amp; 0x87);
-}
-
 void
 eax_set_key (struct eax_key *key, const void *cipher, nettle_cipher_func *f)
 {
   static const union nettle_block16 zero_block;
   f (cipher, EAX_BLOCK_SIZE, key-&gt;pad_block.b, zero_block.b);
-  gf2_double (key-&gt;pad_block.b, key-&gt;pad_block.b);
-  gf2_double (key-&gt;pad_partial.b, key-&gt;pad_block.b);
+  block16_mulx_be (&amp;key-&gt;pad_block, &amp;key-&gt;pad_block);
+  block16_mulx_be (&amp;key-&gt;pad_partial, &amp;key-&gt;pad_block);
   block16_xor (&amp;key-&gt;pad_partial, &amp;key-&gt;pad_block);
 }
 
diff --git a/siv-cmac-aes128.c b/siv-cmac-aes128.c
index 82ac16e91992..fd2e23a4513e 100644
--- a/siv-cmac-aes128.c
+++ b/siv-cmac-aes128.c
@@ -44,7 +44,6 @@
 #include "ctr.h"
 #include "memxor.h"
 #include "memops.h"
-#include "cmac-internal.h"
 
 void
 siv_cmac_aes128_set_key(struct siv_cmac_aes128_ctx *ctx, const uint8_t *key)
diff --git a/siv-cmac-aes256.c b/siv-cmac-aes256.c
index 9401bbf119c5..eda7f1c27a55 100644
--- a/siv-cmac-aes256.c
+++ b/siv-cmac-aes256.c
@@ -44,7 +44,6 @@
 #include "ctr.h"
 #include "memxor.h"
 #include "memops.h"
-#include "cmac-internal.h"
 
 void
 siv_cmac_aes256_set_key(struct siv_cmac_aes256_ctx *ctx, const uint8_t *key)
diff --git a/siv-cmac.c b/siv-cmac.c
index 42f740cddf5d..8205c320f544 100644
--- a/siv-cmac.c
+++ b/siv-cmac.c
@@ -44,7 +44,6 @@
 #include "ctr.h"
 #include "memxor.h"
 #include "memops.h"
-#include "cmac-internal.h"
 #include "nettle-internal.h"
 #include "block-internal.h"
 
@@ -67,12 +66,12 @@ _siv_s2v (const struct nettle_cipher *nc,
   cmac128_update (&amp;cmac_ctx, cmac_cipher, nc-&gt;encrypt, 16, const_zero.b);
   cmac128_digest (&amp;cmac_ctx, cmac_key, cmac_cipher, nc-&gt;encrypt, 16, D.b);
 
-  _cmac128_block_mulx (&amp;D, &amp;D);
+  block16_mulx_be (&amp;D, &amp;D);
   cmac128_update (&amp;cmac_ctx, cmac_cipher, nc-&gt;encrypt, alength, adata);
   cmac128_digest (&amp;cmac_ctx, cmac_key, cmac_cipher, nc-&gt;encrypt, 16, S.b);
   block16_xor (&amp;D, &amp;S);
 
-  _cmac128_block_mulx (&amp;D, &amp;D);
+  block16_mulx_be (&amp;D, &amp;D);
   cmac128_update (&amp;cmac_ctx, cmac_cipher, nc-&gt;encrypt, nlength, nonce);
   cmac128_digest (&amp;cmac_ctx, cmac_key, cmac_cipher, nc-&gt;encrypt, 16, S.b);
   block16_xor (&amp;D, &amp;S);
@@ -90,7 +89,7 @@ _siv_s2v (const struct nettle_cipher *nc,
     {
       union nettle_block16 pad;
 
-      _cmac128_block_mulx (&amp;T, &amp;D);
+      block16_mulx_be (&amp;T, &amp;D);
       memcpy (pad.b, pdata, plength);
       pad.b[plength] = 0x80;
       if (plength + 1 &lt; 16)
diff --git a/xts.c b/xts.c
index 6730b3ad76ff..7b023748ddd4 100644
--- a/xts.c
+++ b/xts.c
@@ -44,31 +44,7 @@
 #include "macros.h"
 #include "memxor.h"
 #include "nettle-internal.h"
-
-/* shift left one and XOR with 0x87 if there is carry. */
-/* the algorithm reads this as a 128bit Little Endian number */
-/* src and dest can point to the same buffer for in-place operations */
-#if WORDS_BIGENDIAN
-#define BE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
-                     (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
-static void
-xts_shift(union nettle_block16 *dst,
-          const union nettle_block16 *src)
-{
-  uint64_t carry = (src-&gt;u64[1] &amp; 0x80) &gt;&gt; 7;
-  dst-&gt;u64[1] = BE_SHIFT(src-&gt;u64[1]) | ((src-&gt;u64[0] &amp; 0x80) &lt;&lt; 49);
-  dst-&gt;u64[0] = BE_SHIFT(src-&gt;u64[0]) ^ (0x8700000000000000 &amp; -carry);
-}
-#else /* !WORDS_BIGENDIAN */
-static void
-xts_shift(union nettle_block16 *dst,
-          const union nettle_block16 *src)
-{
-  uint64_t carry = src-&gt;u64[1] &gt;&gt; 63;
-  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) | (src-&gt;u64[0] &gt;&gt; 63);
-  dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) ^ (0x87 &amp; -carry);
-}
-#endif /* !WORDS_BIGNDIAN */
+#include "block-internal.h"
 
 static void
 check_length(size_t length, uint8_t *dst)
@@ -107,7 +83,7 @@ xts_encrypt_message(const void *enc_ctx, const void *twk_ctx,
 
       /* shift T for next block if any */
       if (length &gt; XTS_BLOCK_SIZE)
-          xts_shift(&amp;T, &amp;T);
+          block16_mulx_le(&amp;T, &amp;T);
     }
 
   /* if the last block is partial, handle via stealing */
@@ -121,7 +97,7 @@ xts_encrypt_message(const void *enc_ctx, const void *twk_ctx,
       memxor(S.b, T.b, XTS_BLOCK_SIZE);	        /* CC -&gt; S */
 
       /* shift T for next block */
-      xts_shift(&amp;T, &amp;T);
+      block16_mulx_le(&amp;T, &amp;T);
 
       length -= XTS_BLOCK_SIZE;
       src += XTS_BLOCK_SIZE;
@@ -162,7 +138,7 @@ xts_decrypt_message(const void *dec_ctx, const void *twk_ctx,
 
       /* shift T for next block if any */
       if (length &gt; XTS_BLOCK_SIZE)
-          xts_shift(&amp;T, &amp;T);
+          block16_mulx_le(&amp;T, &amp;T);
     }
 
   /* if the last block is partial, handle via stealing */
@@ -173,7 +149,7 @@ xts_decrypt_message(const void *dec_ctx, const void *twk_ctx,
       union nettle_block16 S;
 
       /* we need the last T(n) and save the T(n-1) for later */
-      xts_shift(&amp;T1, &amp;T);
+      block16_mulx_le(&amp;T1, &amp;T);
 
       memxor3(C.b, src, T1.b, XTS_BLOCK_SIZE);	/* C -&gt; CC */
       decf(dec_ctx, XTS_BLOCK_SIZE, S.b, C.b);  /* PP */
-- 
2.23.0.rc1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190904202049</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-04 20:20:49-0400</timestampReceived><subject>Re: [PATCH v2 4/4] gcm: drop intermediate GCM_TABLE_BITS == 4 case</subject><body>

dbaryshkov@gmail.com writes:

&gt; It makes little sense to have intermediate solution with GCM_TABLE_BITS
&gt; == 4. One either will use unoptimized case of GCM_TABLE_BITS == 0, or
&gt; will switch to fully optimized case (8) as memory usage difference is
&gt; quite low between 4 and 8. So drop GCM_TABLE_BITS == 4 support

For the const shift_table, the size difference is 32 bytes vs 512 bytes,
which may not be a big deal.

I'm more concerned with the size of struct gcm_key, 256 bytes vs 4096
bytes. GCM_TABLE_BITS == 4 seems like a reasonable tradeoff if you have an
embedded system with little RAM.

It's unfortunate that it is poorly tested. It would make some sense with
an (abi-breaking) configure flag --enable-small-size to reduce size of
various tables, which could then be tested more regularly. Besides gcm,
AES and DES use large constant tables of somewhat configurable size, and
for ecc there are both constant tables, for ecc_mul_g, and run-time
tables for ecc_mul_a.

Is there any interest in improving support for low-end embedded devices?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190903172638</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-03 17:26:38-0400</timestampReceived><subject>Re: [PATCH 4/5] block modes: move Galois shifts to block-internal.h</subject><body>

dbaryshkov@gmail.com writes:

&gt; From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt;
&gt; Move Galois polynomial shifts to block-internal.h, simplifying common
&gt; code. GCM is left unconverted for now, this will be fixed later.

Thanks for cleaning this up! Some comments below.

&gt; --- a/block-internal.h
&gt; +++ b/block-internal.h
&gt; @@ -90,4 +90,80 @@ block8_xor_bytes (union nettle_block8 *r,
&gt;    memxor3 (r-&gt;b, x-&gt;b, bytes, 8);
&gt;  }
&gt;  
&gt; +#define LSHIFT_WORD(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
&gt; +			(((x) &amp; 0x8080808080808080) &gt;&gt; 15))
&gt; +#define RSHIFT_WORD(x) ((((x) &amp; 0xfefefefefefefefe) &gt;&gt; 1) | \
&gt; +			(((x) &amp; 0x0001010101010101) &lt;&lt; 15))

Names of these macros should say U64 or UINT64 rather than WORD. And
something to suggest that they're for alien endianness. Maybe
"LSHIFT_ALIEN_UINT64.

And UINT64_C for the constants.

&gt; +/* Galois multiplications by 2:
&gt; + * functions differ in shifting right or left, big- or little- endianness
&gt; + * and by defininy polynom.
&gt; + * r == x is allowed. */

This is a bit complex, perhaps it can be clarified a bit. We have both
the issue of big or little byte order within words. And bit order used
for representating of the polynomial: usually a less significant bit
within a byte represents a coefficient for a smaller power of the
polynomial variable x, but one of the algorithms (I can't recall which
one) uses opposite bit order. 

And if I remember correctly, they all use the same polynomial, but due
to bit-order differences, there are two different ways to represent it.
Which of the functions are called with more than one constant for the
poly argument?

And "defining" is misspelled.

&gt; +#if WORDS_BIGENDIAN
&gt; +static inline void
&gt; +block16_lshift_be (union nettle_block16 *dst,
&gt; +		   const union nettle_block16 *src,
&gt; +		   uint64_t poly)
&gt; +{
&gt; +  uint64_t carry = src-&gt;u64[0] &gt;&gt; 63;
&gt; +  dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
&gt; +  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) ^ (poly &amp; -carry);
&gt; +}
&gt; +#else /* !WORDS_BIGENDIAN */

There will be less clutter if all code for #if WORDS_BIGENDIAN is
grouped together. And I think I prefer "mulx" rather than "shift"
somewhere in the name, to indicate that it's not a plain shift.

&gt; --- a/cmac.c
&gt; +++ b/cmac.c
&gt; @@ -44,32 +44,16 @@
&gt;  
&gt;  #include "memxor.h"
&gt;  #include "nettle-internal.h"
&gt; -#include "cmac-internal.h"
&gt;  #include "block-internal.h"
&gt;  #include "macros.h"
&gt;  
&gt;  /* shift one and XOR with 0x87. */
&gt; -#if WORDS_BIGENDIAN
&gt; -void
&gt; -_cmac128_block_mulx(union nettle_block16 *dst,
&gt; -		    const union nettle_block16 *src)
&gt; -{
&gt; -  uint64_t carry = src-&gt;u64[0] &gt;&gt; 63;
&gt; -  dst-&gt;u64[0] = (src-&gt;u64[0] &lt;&lt; 1) | (src-&gt;u64[1] &gt;&gt; 63);
&gt; -  dst-&gt;u64[1] = (src-&gt;u64[1] &lt;&lt; 1) ^ (0x87 &amp; -carry);
&gt; -}
&gt; -#else /* !WORDS_BIGENDIAN */
&gt; -#define LE_SHIFT(x) ((((x) &amp; 0x7f7f7f7f7f7f7f7f) &lt;&lt; 1) | \
&gt; -                     (((x) &amp; 0x8080808080808080) &gt;&gt; 15))
&gt; -void
&gt; +static inline void
&gt;  _cmac128_block_mulx(union nettle_block16 *dst,
&gt;  		    const union nettle_block16 *src)
&gt;  {
&gt; -  uint64_t carry = (src-&gt;u64[0] &amp; 0x80) &gt;&gt; 7;
&gt; -  dst-&gt;u64[0] = LE_SHIFT(src-&gt;u64[0]) | ((src-&gt;u64[1] &amp; 0x80) &lt;&lt; 49);
&gt; -  dst-&gt;u64[1] = LE_SHIFT(src-&gt;u64[1]) ^ (0x8700000000000000 &amp; -carry);
&gt; +  block16_lshift_be(dst, src, 0x87);
&gt;  }
&gt; -#endif /* !WORDS_BIGENDIAN */

I think it's clearer to delete this and similar wrappers.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190904061032</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-09-04 06:10:32-0400</timestampReceived><subject>[PATCH v2 4/4] gcm: drop intermediate GCM_TABLE_BITS == 4 case</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

It makes little sense to have intermediate solution with GCM_TABLE_BITS
== 4. One either will use unoptimized case of GCM_TABLE_BITS == 0, or
will switch to fully optimized case (8) as memory usage difference is
quite low between 4 and 8. So drop GCM_TABLE_BITS == 4 support

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 gcm.c | 67 +++++++----------------------------------------------------
 1 file changed, 8 insertions(+), 59 deletions(-)

diff --git a/gcm.c b/gcm.c
index cf615daf18bd..3a6f04a7671b 100644
--- a/gcm.c
+++ b/gcm.c
@@ -83,62 +83,7 @@ gcm_gf_mul (union nettle_block16 *x, const union nettle_block16 *y)
     }
   memcpy (x-&gt;b, Z.b, sizeof(Z));
 }
-#else /* GCM_TABLE_BITS != 0 */
 
-# if WORDS_BIGENDIAN
-#  define W(left,right) (0x##left##right)
-# else
-#  define W(left,right) (0x##right##left)
-# endif
-
-# if GCM_TABLE_BITS == 4
-static const uint16_t
-shift_table[0x10] = {
-  W(00,00),W(1c,20),W(38,40),W(24,60),W(70,80),W(6c,a0),W(48,c0),W(54,e0),
-  W(e1,00),W(fd,20),W(d9,40),W(c5,60),W(91,80),W(8d,a0),W(a9,c0),W(b5,e0),
-};
-
-static void
-gcm_gf_shift_4(union nettle_block16 *x)
-{
-  uint64_t *u64 = x-&gt;u64;
-  uint64_t reduce;
-
-  /* Shift uses big-endian representation. */
-#if WORDS_BIGENDIAN
-  reduce = shift_table[u64[1] &amp; 0xf];
-  u64[1] = (u64[1] &gt;&gt; 4) | ((u64[0] &amp; 0xf) &lt;&lt; 60);
-  u64[0] = (u64[0] &gt;&gt; 4) ^ (reduce &lt;&lt; 48);
-#else /* ! WORDS_BIGENDIAN */
-#define RSHIFT_WORD_4(x) \
-  ((((x) &amp; UINT64_C(0xf0f0f0f0f0f0f0f0)) &gt;&gt; 4) \
-   | (((x) &amp; UINT64_C(0x000f0f0f0f0f0f0f)) &lt;&lt; 12))
-  reduce = shift_table[(u64[1] &gt;&gt; 56) &amp; 0xf];
-  u64[1] = RSHIFT_WORD_4(u64[1]) | ((u64[0] &gt;&gt; 52) &amp; 0xf0);
-  u64[0] = RSHIFT_WORD_4(u64[0]) ^ reduce;
-# undef RSHIFT_WORD_4
-#endif /* ! WORDS_BIGENDIAN */
-}
-
-static void
-gcm_gf_mul (union nettle_block16 *x, const union nettle_block16 *table)
-{
-  union nettle_block16 Z;
-  unsigned i;
-
-  memset(Z.b, 0, sizeof(Z));
-
-  for (i = GCM_BLOCK_SIZE; i-- &gt; 0;)
-    {
-      uint8_t b = x-&gt;b[i];
-
-      gcm_gf_shift_4(&amp;Z);
-      block16_xor(&amp;Z, &amp;table[b &amp; 0xf]);
-      gcm_gf_shift_4(&amp;Z);
-      block16_xor(&amp;Z, &amp;table[b &gt;&gt; 4]);
-    }
-  memcpy (x-&gt;b, Z.b, sizeof(Z));
-}
 # elif GCM_TABLE_BITS == 8
 #  if HAVE_NATIVE_gcm_hash8
 
@@ -147,6 +92,13 @@ void
 _nettle_gcm_hash8 (const struct gcm_key *key, union nettle_block16 *x,
 		   size_t length, const uint8_t *data);
 #  else /* !HAVE_NATIVE_gcm_hash8 */
+
+# if WORDS_BIGENDIAN
+#  define W(left,right) (0x##left##right)
+# else
+#  define W(left,right) (0x##right##left)
+# endif
+
 static const uint16_t
 shift_table[0x100] = {
   W(00,00),W(01,c2),W(03,84),W(02,46),W(07,08),W(06,ca),W(04,8c),W(05,4e),
@@ -182,6 +134,7 @@ shift_table[0x100] = {
   W(b5,e0),W(b4,22),W(b6,64),W(b7,a6),W(b2,e8),W(b3,2a),W(b1,6c),W(b0,ae),
   W(bb,f0),W(ba,32),W(b8,74),W(b9,b6),W(bc,f8),W(bd,3a),W(bf,7c),W(be,be),
 };
+#undef W
 
 static void
 gcm_gf_shift_8(union nettle_block16 *x)
@@ -221,10 +174,6 @@ gcm_gf_mul (union nettle_block16 *x, const union nettle_block16 *table)
 #  error Unsupported table size. 
 # endif /* GCM_TABLE_BITS != 8 */
 
-#undef W
-
-#endif /* GCM_TABLE_BITS */
-
 /* Increment the rightmost 32 bits. */
 #define INC32(block) INCREMENT(4, (block.b) + GCM_BLOCK_SIZE - 4)
 
-- 
2.23.0.rc1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190904061031</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-09-04 06:10:31-0400</timestampReceived><subject>[PATCH v2 3/4] gcm: move block shifting function to block-internal.h</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Move GCM's block shift function to block-internal.h. This concludes
moving of all Galois mul-by-2 to single header.

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 block-internal.h | 30 +++++++++++++++++++++++++++++-
 gcm.c            | 30 ++----------------------------
 2 files changed, 31 insertions(+), 29 deletions(-)

diff --git a/block-internal.h b/block-internal.h
index 8972d0ac2b5b..88e19be333c8 100644
--- a/block-internal.h
+++ b/block-internal.h
@@ -95,11 +95,15 @@ block8_xor_bytes (union nettle_block8 *r,
 #define LSHIFT_ALIEN_UINT64(x) \
 	((((x) &amp; UINT64_C(0x7f7f7f7f7f7f7f7f)) &lt;&lt; 1) | \
 	 (((x) &amp; UINT64_C(0x8080808080808080)) &gt;&gt; 15))
+#define RSHIFT_ALIEN_UINT64(x) \
+	((((x) &amp; UINT64_C(0xfefefefefefefefe)) &gt;&gt; 1) | \
+	 (((x) &amp; UINT64_C(0x0001010101010101)) &lt;&lt; 15))
 
 /* Two typical defining polynoms */
 
 #define BLOCK16_POLY (UINT64_C(0x87))
 #define BLOCK8_POLY (UINT64_C(0x1b))
+#define GHASH_POLY (UINT64_C(0xE1))
 
 /* Galois multiplications by 2:
  * functions differ in shifting right or left, big- or little- endianness
@@ -133,6 +137,18 @@ block8_mulx_be (union nettle_block8 *dst,
 
   dst-&gt;u64 = (src-&gt;u64 &lt;&lt; 1) ^ (BLOCK8_POLY &amp; -carry);
 }
+
+static inline void
+block16_mulx_ghash (union nettle_block16 *r,
+		    const union nettle_block16 *x)
+{
+  uint64_t mask;
+
+  /* Shift uses big-endian representation. */
+  mask = - (x-&gt;u64[1] &amp; 1);
+  r-&gt;u64[1] = (x-&gt;u64[1] &gt;&gt; 1) | ((x-&gt;u64[0] &amp; 1) &lt;&lt; 63);
+  r-&gt;u64[0] = (x-&gt;u64[0] &gt;&gt; 1) ^ (mask &amp; (GHASH_POLY &lt;&lt; 56));
+}
 #else /* !WORDS_BIGENDIAN */
 static inline void
 block16_mulx_be (union nettle_block16 *dst,
@@ -160,6 +176,18 @@ block8_mulx_be (union nettle_block8 *dst,
 
   dst-&gt;u64 = LSHIFT_ALIEN_UINT64(src-&gt;u64) ^ ((BLOCK8_POLY &lt;&lt; 56) &amp; -carry);
 }
-#endif /* !WORDS_BIGENDIAN */
+
+static inline void
+block16_mulx_ghash (union nettle_block16 *r,
+		    const union nettle_block16 *x)
+{
+  uint64_t mask;
+
+  /* Shift uses big-endian representation. */
+  mask = - ((x-&gt;u64[1] &gt;&gt; 56) &amp; 1);
+  r-&gt;u64[1] = RSHIFT_ALIEN_UINT64(x-&gt;u64[1]) | ((x-&gt;u64[0] &gt;&gt; 49) &amp; 0x80);
+  r-&gt;u64[0] = RSHIFT_ALIEN_UINT64(x-&gt;u64[0]) ^ (mask &amp; GHASH_POLY);
+}
+#endif /* ! WORDS_BIGENDIAN */
 
 #endif /* NETTLE_BLOCK_INTERNAL_H_INCLUDED */
diff --git a/gcm.c b/gcm.c
index 4a04a0a10842..cf615daf18bd 100644
--- a/gcm.c
+++ b/gcm.c
@@ -55,32 +55,6 @@
 #include "ctr-internal.h"
 #include "block-internal.h"
 
-#define GHASH_POLYNOMIAL 0xE1UL
-
-/* Multiplication by 010...0; a big-endian shift right. If the bit
-   shifted out is one, the defining polynomial is added to cancel it
-   out. r == x is allowed. */
-static void
-gcm_gf_shift (union nettle_block16 *r, const union nettle_block16 *x)
-{
-  uint64_t mask;
-
-  /* Shift uses big-endian representation. */
-#if WORDS_BIGENDIAN
-  mask = - (x-&gt;u64[1] &amp; 1);
-  r-&gt;u64[1] = (x-&gt;u64[1] &gt;&gt; 1) | ((x-&gt;u64[0] &amp; 1) &lt;&lt; 63);
-  r-&gt;u64[0] = (x-&gt;u64[0] &gt;&gt; 1) ^ (mask &amp; ((uint64_t) GHASH_POLYNOMIAL &lt;&lt; 56));
-#else /* ! WORDS_BIGENDIAN */
-#define RSHIFT_WORD(x) \
-  ((((x) &amp; 0xfefefefefefefefeUL) &gt;&gt; 1) \
-   | (((x) &amp; 0x0001010101010101UL) &lt;&lt; 15))
-  mask = - ((x-&gt;u64[1] &gt;&gt; 56) &amp; 1);
-  r-&gt;u64[1] = RSHIFT_WORD(x-&gt;u64[1]) | ((x-&gt;u64[0] &gt;&gt; 49) &amp; 0x80);
-  r-&gt;u64[0] = RSHIFT_WORD(x-&gt;u64[0]) ^ (mask &amp; GHASH_POLYNOMIAL);
-# undef RSHIFT_WORD
-#endif /* ! WORDS_BIGENDIAN */
-}
-
 #if GCM_TABLE_BITS == 0
 /* Sets x &lt;- x * y mod r, using the plain bitwise algorithm from the
    specification. y may be shorter than a full block, missing bytes
@@ -104,7 +78,7 @@ gcm_gf_mul (union nettle_block16 *x, const union nettle_block16 *y)
 	  if (b &amp; 0x80)
 	    block16_xor(&amp;Z, &amp;V);
 	  
-	  gcm_gf_shift(&amp;V, &amp;V);
+	  block16_mulx_ghash(&amp;V, &amp;V);
 	}
     }
   memcpy (x-&gt;b, Z.b, sizeof(Z));
@@ -275,7 +249,7 @@ gcm_set_key(struct gcm_key *key,
   /* Algorithm 3 from the gcm paper. First do powers of two, then do
      the rest by adding. */
   while (i /= 2)
-    gcm_gf_shift(&amp;key-&gt;h[i], &amp;key-&gt;h[2*i]);
+    block16_mulx_ghash(&amp;key-&gt;h[i], &amp;key-&gt;h[2*i]);
   for (i = 2; i &lt; 1&lt;&lt;GCM_TABLE_BITS; i *= 2)
     {
       unsigned j;
-- 
2.23.0.rc1

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190914103314</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-14 10:33:14-0400</timestampReceived><subject>Re: [PATCH v2 1/6] Start separating GOST 28147-89 from GOST R 34.11-94</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; Any feedback on v2 of patchset?

Looks good, merged onto a branch godthash94cp. Not sure what to do about
the MD_UPDATE cleanup, though, maybe we need to revert that one out to
not change the abi (unless we decide to do an abi change for other
reasons).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190914192751</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-09-14 19:27:51-0400</timestampReceived><subject>Re: [PATCH v2 1/6] Start separating GOST 28147-89 from GOST R 34.11-94</subject><body>

сб, 14 сент. 2019 г. в 13:33, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; Any feedback on v2 of patchset?
&gt;
&gt; Looks good, merged onto a branch godthash94cp. Not sure what to do about
&gt; the MD_UPDATE cleanup, though, maybe we need to revert that one out to
&gt; not change the abi (unless we decide to do an abi change for other
&gt; reasons).

I can live with the patch in question

&gt;
&gt; Regards,
&gt; /Niels
&gt;
&gt; --
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
&gt; Internet email is subject to wholesale government surveillance.



-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190914193240</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-09-14 19:32:40-0400</timestampReceived><subject>Re: [PATCH v2 1/6] Start separating GOST 28147-89 from GOST R 34.11-94</subject><body>

сб, 14 сент. 2019 г. в 13:33, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; Any feedback on v2 of patchset?
&gt;
&gt; Looks good, merged onto a branch godthash94cp. Not sure what to do about
&gt; the MD_UPDATE cleanup, though, maybe we need to revert that one out to
&gt; not change the abi (unless we decide to do an abi change for other
&gt; reasons).

I'm sorry, hit enter too soon.

I can live with the patch in question being left out for now. We can
merge it later.

--
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190924162404</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-24 16:24:04-0400</timestampReceived><subject>Re: [PATCH] Curve point decompression</subject><body>

Wim Lewis &lt;wiml@hhhh.org&gt; writes:

&gt; Now that 3.5.1 is out, is there a chance this could be looked at?

I'd like to have a closer look soon.

&gt; On Wed, May 29, 2019 at 01:25:08AM -0700, Wim Lewis wrote:
&gt;&gt; I've pushed some work-in-progress to a git repository here:
&gt;&gt;   https://git.lysator.liu.se/wiml/nettle

Is this still the place for the latest version?

Not sure in which order to do things. Maybe it will be best to first add
the square root routines, with tests, and then add functions for
converting between points and octet strings (and related utilities, if
needed).

One general questions on the setting: Do you expect any of the new
functions will be used for secret data (in contrast to public keys or
signatures)? If so, we need to be particularly careful with side-channel
leaks.

&gt;&gt; things that I think are mathematically impossible
&gt;&gt; but can't trivially prove.

I would consider adding asserts for such conditions, to ensure that the
library fails promptly and in a controlled fashion in case assumptions
turn out to be wrong.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190915084007</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-15 08:40:07-0400</timestampReceived><subject>Re: [PATCH v2 1/6] Start separating GOST 28147-89 from GOST R 34.11-94</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; I can live with the patch in question being left out for now. We can
&gt; merge it later.

Merged to master now. 

One more question: The gost28147.h header, do you intend to add any
documented functions there soon? Otherwise, might be better to delete
that file and move the declarations of gost28147_param_* over to
gost28147-internal.h.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190904202548</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-04 20:25:48-0400</timestampReceived><subject>Re: [PATCH v2 3/4] gcm: move block shifting function to block-internal.h</subject><body>

dbaryshkov@gmail.com writes:

&gt; From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt;
&gt; Move GCM's block shift function to block-internal.h. This concludes
&gt; moving of all Galois mul-by-2 to single header.

I've merged patch 1-3 to the master-updates branch. Thanks!

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190904210023</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-09-04 21:00:23-0400</timestampReceived><subject>Re: [PATCH v2 3/4] gcm: move block shifting function to block-internal.h</subject><body>

ср, 4 сент. 2019 г. в 23:25, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; dbaryshkov@gmail.com writes:
&gt;
&gt; &gt; From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
&gt; &gt;
&gt; &gt; Move GCM's block shift function to block-internal.h. This concludes
&gt; &gt; moving of all Galois mul-by-2 to single header.
&gt;
&gt; I've merged patch 1-3 to the master-updates branch. Thanks!

Thank you! What about gosthash v2 patches I've sent in July?


-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190914102815</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-14 10:28:15-0400</timestampReceived><subject>Re: [PATCH v2 3/6] gosthash94: switch to using MD_UPDATE() macro</subject><body>

Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:

&gt; --- a/gosthash94.h
&gt; +++ b/gosthash94.h
&gt; @@ -87,8 +87,9 @@ struct gosthash94_ctx
&gt;  {
&gt;    uint32_t hash[8]; /* algorithm 256-bit state */
&gt;    uint32_t sum[8];  /* sum of processed message blocks */
&gt; -  uint64_t length;  /* number of processed bytes */
&gt; -  uint8_t message[GOSTHASH94_BLOCK_SIZE]; /* 256-bit buffer for leftovers */
&gt; +  uint64_t count;               /* Block count */
&gt; +  unsigned index;               /* Into buffer */
&gt; +  uint8_t block[GOSTHASH94_BLOCK_SIZE]; /* 256-bit buffer for leftovers */
&gt;  };
&gt;  #define gosthash94cp_ctx gosthash94_ctx

This is a nice cleanup, but it's also both an ABI break, right? Since
the size of this struct is changed.

Unfortunate I missed this one when I moved around fields in other hash
contexts prior to the 3.5 release (which was an abi break), probably
because I was guided by the findings of "git grep block".

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190915105031</emailId><senderName>Dmitry Eremin-Solenikov</senderName><senderEmail>dbaryshkov@gmail.com</senderEmail><timestampReceived>2019-09-15 10:50:31-0400</timestampReceived><subject>Re: [PATCH v2 1/6] Start separating GOST 28147-89 from GOST R 34.11-94</subject><body>

вс, 15 сент. 2019 г. в 11:40, Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt;
&gt; Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt; writes:
&gt;
&gt; &gt; I can live with the patch in question being left out for now. We can
&gt; &gt; merge it later.
&gt;
&gt; Merged to master now.

Thank you!

&gt; One more question: The gost28147.h header, do you intend to add any
&gt; documented functions there soon? Otherwise, might be better to delete
&gt; that file and move the declarations of gost28147_param_* over to
&gt; gost28147-internal.h.

Yes, I will provide next patchset in few days, which will make use of
this header.

-- 
With best wishes
Dmitry
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190916091428</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-09-16 09:14:28-0400</timestampReceived><subject>[PATCH 0/5] GOST 28147-89 support</subject><body>

GOST 28147-89 is the data encryption standard for Russia (old, but still
used). English translation is provided in RFC 5830. It defines a 64-bit
cipher, ECB, CFB and counter (CNT) modes on top of it and a special mode
of basic transformation that is used for MAC construction called
"Imitovstavka" (IMIT).

For GOST 28147-89 several S-boxes are defined (standard itself has
defined "test" S-box, another "test" S-box is defined in GOST R 34.11-94
(RFC 5831), RFC 4357 defines several CryptoPro S-Boxes and finally TC26
has defined TC26-Z S-Box (RFC 7836)).

Before finalizing documentation I'd like to hear your opinion on the
GOST 28147-89 cipher and MAC interface.

-- 
With best wishes
Dmitry


_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190916091429</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-09-16 09:14:29-0400</timestampReceived><subject>[PATCH 1/5] Add GOST 28147-89 ECB encryption and decryption support</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 Makefile.in                  |   3 +-
 gost28147-internal.h         |   3 +
 gost28147-meta.c             |  49 +++++++++++++++
 gost28147.c                  |  85 +++++++++++++++++++++++++
 gost28147.h                  |  30 +++++++++
 nettle-meta-ciphers.c        |   1 +
 nettle-meta.h                |   2 +
 nettle.texinfo               |  38 +++++++++++
 testsuite/.gitignore         |   1 +
 testsuite/.test-rules.make   |   3 +
 testsuite/Makefile.in        |   1 +
 testsuite/gost28147-test.c   | 119 +++++++++++++++++++++++++++++++++++
 testsuite/meta-cipher-test.c |   1 +
 13 files changed, 335 insertions(+), 1 deletion(-)
 create mode 100644 gost28147-meta.c
 create mode 100644 testsuite/gost28147-test.c

diff --git a/Makefile.in b/Makefile.in
index 9f5b065a706a..c6e40a74ad4f 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -103,7 +103,8 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 gcm-camellia128.c gcm-camellia128-meta.c \
 		 gcm-camellia256.c gcm-camellia256-meta.c \
 		 cmac.c cmac64.c cmac-aes128.c cmac-aes256.c cmac-des3.c \
-		 gost28147.c gosthash94.c gosthash94-meta.c \
+		 gost28147.c gost28147-meta.c \
+		 gosthash94.c gosthash94-meta.c \
 		 hmac.c hmac-gosthash94.c hmac-md5.c hmac-ripemd160.c \
 		 hmac-sha1.c hmac-sha224.c hmac-sha256.c hmac-sha384.c \
 		 hmac-sha512.c \
diff --git a/gost28147-internal.h b/gost28147-internal.h
index 7f5c6f8c63c0..2c3f5857a8d4 100644
--- a/gost28147-internal.h
+++ b/gost28147-internal.h
@@ -35,8 +35,11 @@
 #define NETTLE_GOST28147_INTERNAL_H_INCLUDED
 
 #define _gost28147_encrypt_block _nettle_gost28147_encrypt_block
+#define _gost28147_decrypt_block _nettle_gost28147_decrypt_block
 
 void _gost28147_encrypt_block (const uint32_t *key, const uint32_t sbox[4][256],
 			       const uint32_t *in, uint32_t *out);
+void _gost28147_decrypt_block (const uint32_t *key, const uint32_t sbox[4][256],
+			       const uint32_t *in, uint32_t *out);
 
 #endif /* NETTLE_GOST28147_INTERNAL_H_INCLUDED */
diff --git a/gost28147-meta.c b/gost28147-meta.c
new file mode 100644
index 000000000000..69e4d265e453
--- /dev/null
+++ b/gost28147-meta.c
@@ -0,0 +1,49 @@
+/* gost28147-meta.c
+
+   Copyright (C) 2016 Dmitry Eremin-Solenikov
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "nettle-meta.h"
+
+#include "gost28147.h"
+
+const struct nettle_cipher nettle_gost28147 =
+  { "gost28147", sizeof(struct gost28147_ctx),
+    GOST28147_BLOCK_SIZE, GOST28147_KEY_SIZE,
+    (nettle_set_key_func *) gost28147_set_key,
+    (nettle_set_key_func *) gost28147_set_key,
+    (nettle_cipher_func *) gost28147_encrypt,
+    (nettle_cipher_func *) gost28147_decrypt
+  };
diff --git a/gost28147.c b/gost28147.c
index 15d314c86c17..6ccdcb6a353c 100644
--- a/gost28147.c
+++ b/gost28147.c
@@ -32,6 +32,8 @@
 #include "config.h"
 #endif
 
+#include &lt;assert.h&gt;
+
 #include "macros.h"
 #include "gost28147.h"
 #include "gost28147-internal.h"
@@ -615,3 +617,86 @@ void _gost28147_encrypt_block (const uint32_t *key, const \
uint32_t sbox[4][256],  GOST_ENCRYPT_ROUND(l, r, key[1], key[0], sbox);
   *out = l, *(out + 1) = r;
 }
+
+void _gost28147_decrypt_block (const uint32_t *key, const uint32_t sbox[4][256],
+			       const uint32_t *in, uint32_t *out)
+{
+  uint32_t l, r;
+
+  r = in[0], l = in[1];
+  GOST_ENCRYPT_ROUND(l, r, key[0], key[1], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[2], key[3], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[4], key[5], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[6], key[7], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[7], key[6], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[5], key[4], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[3], key[2], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[1], key[0], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[7], key[6], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[5], key[4], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[3], key[2], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[1], key[0], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[7], key[6], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[5], key[4], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[3], key[2], sbox);
+  GOST_ENCRYPT_ROUND(l, r, key[1], key[0], sbox);
+  *out = l, *(out + 1) = r;
+}
+
+void
+gost28147_set_key(struct gost28147_ctx *ctx, const uint8_t *key)
+{
+  unsigned i;
+
+  assert(key);
+  for (i = 0; i &lt; 8; i++, key += 4)
+    ctx-&gt;key[i] = LE_READ_UINT32(key);
+  gost28147_set_param(ctx, &amp;gost28147_param_TC26_Z);
+}
+
+void
+gost28147_set_param(struct gost28147_ctx *ctx, const struct gost28147_param *param)
+{
+  assert(param);
+  ctx-&gt;sbox = param-&gt;sbox;
+}
+
+void
+gost28147_encrypt(const struct gost28147_ctx *ctx,
+		  size_t length, uint8_t *dst,
+		  const uint8_t *src)
+{
+  uint32_t block[2];
+
+  assert(!(length % GOST28147_BLOCK_SIZE));
+
+  while (length)
+    {
+      block[0] = LE_READ_UINT32(src); src += 4;
+      block[1] = LE_READ_UINT32(src); src += 4;
+      _gost28147_encrypt_block(ctx-&gt;key, ctx-&gt;sbox, block, block);
+      LE_WRITE_UINT32(dst, block[0]); dst += 4;
+      LE_WRITE_UINT32(dst, block[1]); dst += 4;
+      length -= GOST28147_BLOCK_SIZE;
+    }
+}
+
+void
+gost28147_decrypt(const struct gost28147_ctx *ctx,
+		  size_t length, uint8_t *dst,
+		  const uint8_t *src)
+{
+  uint32_t block[2];
+
+  assert(!(length % GOST28147_BLOCK_SIZE));
+
+  while (length)
+    {
+      block[0] = LE_READ_UINT32(src); src += 4;
+      block[1] = LE_READ_UINT32(src); src += 4;
+      _gost28147_decrypt_block(ctx-&gt;key, ctx-&gt;sbox, block, block);
+      LE_WRITE_UINT32(dst, block[0]); dst += 4;
+      LE_WRITE_UINT32(dst, block[1]); dst += 4;
+      length -= GOST28147_BLOCK_SIZE;
+    }
+}
diff --git a/gost28147.h b/gost28147.h
index 32e7d5e81eb8..5fff34e859d2 100644
--- a/gost28147.h
+++ b/gost28147.h
@@ -43,6 +43,20 @@ extern "C" {
 #define gost28147_param_test_3411 nettle_gost28147_param_test_3411
 #define gost28147_param_CryptoPro_3411 nettle_gost28147_param_CryptoPro_3411
 
+#define gost28147_set_key nettle_gost28147_set_key
+#define gost28147_set_param nettle_gost28147_set_param
+#define gost28147_encrypt nettle_gost28147_encrypt
+#define gost28147_decrypt nettle_gost28147_decrypt
+
+#define GOST28147_KEY_SIZE 32
+#define GOST28147_BLOCK_SIZE 8
+
+struct gost28147_ctx
+{
+  uint32_t key[GOST28147_KEY_SIZE/4];
+  const uint32_t (*sbox)[256];
+};
+
 struct gost28147_param
 {
   uint32_t sbox[4][256];
@@ -51,6 +65,22 @@ struct gost28147_param
 extern const struct gost28147_param gost28147_param_test_3411;
 extern const struct gost28147_param gost28147_param_CryptoPro_3411;
 
+void
+gost28147_set_key(struct gost28147_ctx *ctx, const uint8_t *key);
+
+void
+gost28147_set_param(struct gost28147_ctx *ctx,
+		    const struct gost28147_param *param);
+
+void
+gost28147_encrypt(const struct gost28147_ctx *ctx,
+		  size_t length, uint8_t *dst,
+		  const uint8_t *src);
+void
+gost28147_decrypt(const struct gost28147_ctx *ctx,
+		  size_t length, uint8_t *dst,
+		  const uint8_t *src);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/nettle-meta-ciphers.c b/nettle-meta-ciphers.c
index 49cb47a70243..3a48f2f4b2c8 100644
--- a/nettle-meta-ciphers.c
+++ b/nettle-meta-ciphers.c
@@ -54,6 +54,7 @@ const struct nettle_cipher * const _nettle_ciphers[] = {
   &amp;nettle_arctwo64,
   &amp;nettle_arctwo128,
   &amp;nettle_arctwo_gutmann128,
+  &amp;nettle_gost28147,
   NULL
 };
 
diff --git a/nettle-meta.h b/nettle-meta.h
index b4cdb8f3e378..9075224a57f4 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -89,6 +89,8 @@ extern const struct nettle_cipher nettle_arctwo64;
 extern const struct nettle_cipher nettle_arctwo128;
 extern const struct nettle_cipher nettle_arctwo_gutmann128;
 
+extern const struct nettle_cipher nettle_gost28147;
+
 struct nettle_hash
 {
   const char *name;
diff --git a/nettle.texinfo b/nettle.texinfo
index 9a3ca04e0a7f..b77e28506a52 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -1793,6 +1793,44 @@ in any other way.
 Analogous to @code{des_encrypt}
 @end deftypefun
 
+@subsection GOST 28147-89 (Magma)
+GOST 28147-89 (also called Magma) is the Russian standard cipher. It uses a
+block size of 64 bits (8 octets), and a key size of 256 bits. Nettle defines
+GOST28147 in @file{&lt;nettle/gost28147.h&gt;}.
+
+@deftp {Context struct} {struct gost28147_ctx}
+@end deftp
+
+@defvr Constant GOST28147_BLOCK_SIZE
+The GOST28147 block-size, 8.
+@end defvr
+
+@defvr Constant GOST28147_KEY_SIZE
+GOST28147 key size, 32.
+@end defvr
+
+@deftypefun void gost28147_set_key (struct gost28147_ctx *@var{ctx}, const uint8_t \
*@var{key}) +Initialize the cipher. The same function is used for both encryption and
+decryption.
+@end deftypefun
+
+@deftypefun void gost28147_set_sbox (struct gost28147_ctx *@var{ctx}, const uint32_t \
*@var{sbox}) +Initialize the cipher S-BOX. The same function is used for both \
encryption and +decryption.
+@end deftypefun
+
+@deftypefun void gost28147_encrypt (struct gost28147_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +Encryption function. \
@var{length} must be an integral multiple of the +block size. If it is more than one \
block, the data is processed in ECB +mode. @code{src} and @code{dst} may be equal, \
but they must not overlap +in any other way.
+@end deftypefun
+
+@deftypefun void gost28147_decrypt (struct gost28147_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +Analogous to \
@code{gost28147_encrypt} +@end deftypefun
+
+
 @subsection Salsa20
 @cindex Salsa20
 Salsa20 is a fairly recent stream cipher designed by D. J. Bernstein. It
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index 066bcee2fb23..ef234e34e1ac 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -42,6 +42,7 @@
 /eddsa-sign-test
 /eddsa-verify-test
 /gcm-test
+/gost28147-test
 /gosthash94-test
 /hkdf-test
 /hmac-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index efb7df3cbf7a..3e9bfd185e33 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -34,6 +34,9 @@ des-test$(EXEEXT): des-test.$(OBJEXT)
 des3-test$(EXEEXT): des3-test.$(OBJEXT)
 	$(LINK) des3-test.$(OBJEXT) $(TEST_OBJS) -o des3-test$(EXEEXT)
 
+gost28147-test$(EXEEXT): gost28147-test.$(OBJEXT)
+	$(LINK) gost28147-test.$(OBJEXT) $(TEST_OBJS) -o gost28147-test$(EXEEXT)
+
 md2-test$(EXEEXT): md2-test.$(OBJEXT)
 	$(LINK) md2-test.$(OBJEXT) $(TEST_OBJS) -o md2-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index f8f85701ef35..043b778a9ed4 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -16,6 +16,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    camellia-test.c chacha-test.c \
 		    cnd-memcpy-test.c \
 		    des-test.c des3-test.c \
+		    gost28147-test.c \
 		    md2-test.c md4-test.c md5-test.c md5-compat-test.c \
 		    memeql-test.c memxor-test.c gosthash94-test.c \
 		    ripemd160-test.c hkdf-test.c \
diff --git a/testsuite/gost28147-test.c b/testsuite/gost28147-test.c
new file mode 100644
index 000000000000..3f8046e19e3f
--- /dev/null
+++ b/testsuite/gost28147-test.c
@@ -0,0 +1,119 @@
+#include "testutils.h"
+#include "gost28147.h"
+
+static void
+test_gost28147(const struct gost28147_param *param,
+	       const struct tstring *key,
+	       const struct tstring *cleartext,
+	       const struct tstring *ciphertext)
+{
+  struct gost28147_ctx ctx;
+  uint8_t *data = xalloc(cleartext-&gt;length);
+  size_t length;
+
+  ASSERT (cleartext-&gt;length == ciphertext-&gt;length);
+  length = cleartext-&gt;length;
+
+  gost28147_set_key(&amp;ctx, key-&gt;data);
+  gost28147_set_param(&amp;ctx, param);
+  gost28147_encrypt(&amp;ctx, length, data, cleartext-&gt;data);
+
+  if (!MEMEQ(length, data, ciphertext-&gt;data))
+    {
+      fprintf(stderr, "Encrypt failed:\nInput:");
+      tstring_print_hex(cleartext);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(ciphertext);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  gost28147_set_key(&amp;ctx, key-&gt;data);
+  gost28147_set_param(&amp;ctx, param);
+  gost28147_decrypt(&amp;ctx, length, data, data);
+
+  if (!MEMEQ(length, data, cleartext-&gt;data))
+    {
+      fprintf(stderr, "Decrypt failed:\nInput:");
+      tstring_print_hex(ciphertext);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(cleartext);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  free(data);
+}
+
+void test_main(void)
+{
+  /* Examples from GOST R 34.11-94 standard */
+  test_gost28147(&amp;gost28147_param_test_3411,
+      SHEX("546D2033 68656C32 69736520 73736E62 20616779 69677474 73656865 \
202C3D73"), +      SHEX("00000000 00000000"),
+      SHEX("1B0BBC32 CEBCAB42"));
+
+  test_gost28147(&amp;gost28147_param_test_3411,
+      SHEX("2033394D 6C320D09 65201A16 6E62001D 67794106 74740E13 6865160D \
3D730C11"), +      SHEX("00000000 00000000"),
+      SHEX("FDCF9B5D C8EB0352"));
+
+  test_gost28147(&amp;gost28147_param_test_3411,
+      SHEX("39B213F5 F209A13F 1AE9BA3A FF1D0C62 41F9E1C7 F1130085 16F20D73 \
F311B180"), +      SHEX("00000000 00000000"),
+      SHEX("280EFF00 9958348D"));
+
+  test_gost28147(&amp;gost28147_param_test_3411,
+      SHEX("EC0A8BA1 5EC004A8 BAC50CAC 0C621DEE E1C7B8E7 007AE2EC F2731BFF 4E80E2A0 \
"), +      SHEX("00000000 00000000"),
+      SHEX("2D562A0D 190486E7 "));
+
+  test_gost28147(&amp;gost28147_param_test_3411,
+      SHEX("8182838485868788 898a8b8c8d8e8f80 d1d2d3d4d5d6d7d8 d9dadbdcdddedfd0"),
+      SHEX("0102030405060708 f1f2f3f4f5f6f7f8"),
+      SHEX("ced52a7ff7f260d5 bc81a80bb5e65976"));
+
+  test_gost28147(&amp;gost28147_param_CryptoPro_3411,
+      SHEX("8182838485868788 898a8b8c8d8e8f80 d1d2d3d4d5d6d7d8 d9dadbdcdddedfd0"),
+      SHEX("0102030405060708 f1f2f3f4f5f6f7f8"),
+      SHEX("e42175e16922d0a8 48e59157d7106518"));
+
+  test_gost28147(&amp;gost28147_param_Test_89,
+      SHEX("8182838485868788 898a8b8c8d8e8f80 d1d2d3d4d5d6d7d8 d9dadbdcdddedfd0"),
+      SHEX("0102030405060708 f1f2f3f4f5f6f7f8"),
+      SHEX("9856cf8bfcc282f4 3f465801c6539a5c"));
+
+  test_gost28147(&amp;gost28147_param_CryptoPro_A,
+      SHEX("8182838485868788 898a8b8c8d8e8f80 d1d2d3d4d5d6d7d8 d9dadbdcdddedfd0"),
+      SHEX("0102030405060708 f1f2f3f4f5f6f7f8"),
+      SHEX("668184aedc48c917 4164347058845cac"));
+
+  test_gost28147(&amp;gost28147_param_CryptoPro_B,
+      SHEX("8182838485868788 898a8b8c8d8e8f80 d1d2d3d4d5d6d7d8 d9dadbdcdddedfd0"),
+      SHEX("0102030405060708 f1f2f3f4f5f6f7f8"),
+      SHEX("dbee81147b74b0f2 db5ef00eff4bd528"));
+
+  test_gost28147(&amp;gost28147_param_CryptoPro_C,
+      SHEX("8182838485868788 898a8b8c8d8e8f80 d1d2d3d4d5d6d7d8 d9dadbdcdddedfd0"),
+      SHEX("0102030405060708 f1f2f3f4f5f6f7f8"),
+      SHEX("31a3859d0aeeb80e 4afbd6ce7798ffa9"));
+
+  test_gost28147(&amp;gost28147_param_CryptoPro_D,
+      SHEX("8182838485868788 898a8b8c8d8e8f80 d1d2d3d4d5d6d7d8 d9dadbdcdddedfd0"),
+      SHEX("0102030405060708 f1f2f3f4f5f6f7f8"),
+      SHEX("b1323e0b2173cbd1 c5282f2461e97aa8"));
+
+  test_gost28147(&amp;gost28147_param_TC26_Z,
+      SHEX("8182838485868788 898a8b8c8d8e8f80 d1d2d3d4d5d6d7d8 d9dadbdcdddedfd0"),
+      SHEX("0102030405060708 f1f2f3f4f5f6f7f8"),
+      SHEX("ce5a5ed7e0577a5f d0cc85ce31635b8b"));
+
+  test_gost28147(&amp;gost28147_param_TC26_Z,
+      SHEX("ccddeeff8899aabb4455667700112233f3f2f1f0f7f6f5f4fbfaf9f8fffefdfc"),
+      SHEX("1032547698badcfe"),
+      SHEX("3dcad8c2e501e94e"));
+}
diff --git a/testsuite/meta-cipher-test.c b/testsuite/meta-cipher-test.c
index f949fd76aabb..8c435cb5d3a9 100644
--- a/testsuite/meta-cipher-test.c
+++ b/testsuite/meta-cipher-test.c
@@ -13,6 +13,7 @@ const char* ciphers[] = {
   "camellia192",
   "camellia256",
   "cast128",
+  "gost28147",
   "serpent128",
   "serpent192",
   "serpent256",
-- 
2.23.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20190916091430</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-09-16 09:14:30-0400</timestampReceived><subject>[PATCH 2/5] Add the rest of sboxes for GOST 28147</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 gost28147.c | 1602 +++++++++++++++++++++++++++++++++++++++++++++++++++
 gost28147.h |   13 +
 2 files changed, 1615 insertions(+)

diff --git a/gost28147.c b/gost28147.c
index 6ccdcb6a353c..9fe31043a3ff 100644
--- a/gost28147.c
+++ b/gost28147.c
@@ -573,6 +573,1608 @@ const struct gost28147_param gost28147_param_CryptoPro_3411 =
   }
 };
 
+const struct gost28147_param gost28147_param_Test_89 =
+{
+  {
+    { /* 0 */
+      0x00062000, 0x00061000, 0x00067800, 0x00062800,
+      0x00064800, 0x00060800, 0x00060000, 0x00064000,
+      0x00067000, 0x00061800, 0x00065800, 0x00066000,
+      0x00066800, 0x00063800, 0x00065000, 0x00063000,
+      0x0004a000, 0x00049000, 0x0004f800, 0x0004a800,
+      0x0004c800, 0x00048800, 0x00048000, 0x0004c000,
+      0x0004f000, 0x00049800, 0x0004d800, 0x0004e000,
+      0x0004e800, 0x0004b800, 0x0004d000, 0x0004b000,
+      0x0007a000, 0x00079000, 0x0007f800, 0x0007a800,
+      0x0007c800, 0x00078800, 0x00078000, 0x0007c000,
+      0x0007f000, 0x00079800, 0x0007d800, 0x0007e000,
+      0x0007e800, 0x0007b800, 0x0007d000, 0x0007b000,
+      0x00072000, 0x00071000, 0x00077800, 0x00072800,
+      0x00074800, 0x00070800, 0x00070000, 0x00074000,
+      0x00077000, 0x00071800, 0x00075800, 0x00076000,
+      0x00076800, 0x00073800, 0x00075000, 0x00073000,
+      0x00042000, 0x00041000, 0x00047800, 0x00042800,
+      0x00044800, 0x00040800, 0x00040000, 0x00044000,
+      0x00047000, 0x00041800, 0x00045800, 0x00046000,
+      0x00046800, 0x00043800, 0x00045000, 0x00043000,
+      0x0000a000, 0x00009000, 0x0000f800, 0x0000a800,
+      0x0000c800, 0x00008800, 0x00008000, 0x0000c000,
+      0x0000f000, 0x00009800, 0x0000d800, 0x0000e000,
+      0x0000e800, 0x0000b800, 0x0000d000, 0x0000b000,
+      0x0001a000, 0x00019000, 0x0001f800, 0x0001a800,
+      0x0001c800, 0x00018800, 0x00018000, 0x0001c000,
+      0x0001f000, 0x00019800, 0x0001d800, 0x0001e000,
+      0x0001e800, 0x0001b800, 0x0001d000, 0x0001b000,
+      0x00052000, 0x00051000, 0x00057800, 0x00052800,
+      0x00054800, 0x00050800, 0x00050000, 0x00054000,
+      0x00057000, 0x00051800, 0x00055800, 0x00056000,
+      0x00056800, 0x00053800, 0x00055000, 0x00053000,
+      0x00012000, 0x00011000, 0x00017800, 0x00012800,
+      0x00014800, 0x00010800, 0x00010000, 0x00014000,
+      0x00017000, 0x00011800, 0x00015800, 0x00016000,
+      0x00016800, 0x00013800, 0x00015000, 0x00013000,
+      0x0003a000, 0x00039000, 0x0003f800, 0x0003a800,
+      0x0003c800, 0x00038800, 0x00038000, 0x0003c000,
+      0x0003f000, 0x00039800, 0x0003d800, 0x0003e000,
+      0x0003e800, 0x0003b800, 0x0003d000, 0x0003b000,
+      0x00022000, 0x00021000, 0x00027800, 0x00022800,
+      0x00024800, 0x00020800, 0x00020000, 0x00024000,
+      0x00027000, 0x00021800, 0x00025800, 0x00026000,
+      0x00026800, 0x00023800, 0x00025000, 0x00023000,
+      0x0006a000, 0x00069000, 0x0006f800, 0x0006a800,
+      0x0006c800, 0x00068800, 0x00068000, 0x0006c000,
+      0x0006f000, 0x00069800, 0x0006d800, 0x0006e000,
+      0x0006e800, 0x0006b800, 0x0006d000, 0x0006b000,
+      0x00032000, 0x00031000, 0x00037800, 0x00032800,
+      0x00034800, 0x00030800, 0x00030000, 0x00034000,
+      0x00037000, 0x00031800, 0x00035800, 0x00036000,
+      0x00036800, 0x00033800, 0x00035000, 0x00033000,
+      0x00002000, 0x00001000, 0x00007800, 0x00002800,
+      0x00004800, 0x00000800, 0x00000000, 0x00004000,
+      0x00007000, 0x00001800, 0x00005800, 0x00006000,
+      0x00006800, 0x00003800, 0x00005000, 0x00003000,
+      0x0005a000, 0x00059000, 0x0005f800, 0x0005a800,
+      0x0005c800, 0x00058800, 0x00058000, 0x0005c000,
+      0x0005f000, 0x00059800, 0x0005d800, 0x0005e000,
+      0x0005e800, 0x0005b800, 0x0005d000, 0x0005b000,
+      0x0002a000, 0x00029000, 0x0002f800, 0x0002a800,
+      0x0002c800, 0x00028800, 0x00028000, 0x0002c000,
+      0x0002f000, 0x00029800, 0x0002d800, 0x0002e000,
+      0x0002e800, 0x0002b800, 0x0002d000, 0x0002b000,
+    }, { /* 1 */
+      0x07680000, 0x07400000, 0x07700000, 0x07600000,
+      0x07380000, 0x07180000, 0x07480000, 0x07500000,
+      0x07080000, 0x07280000, 0x07100000, 0x07200000,
+      0x07300000, 0x07780000, 0x07000000, 0x07580000,
+      0x04e80000, 0x04c00000, 0x04f00000, 0x04e00000,
+      0x04b80000, 0x04980000, 0x04c80000, 0x04d00000,
+      0x04880000, 0x04a80000, 0x04900000, 0x04a00000,
+      0x04b00000, 0x04f80000, 0x04800000, 0x04d80000,
+      0x05e80000, 0x05c00000, 0x05f00000, 0x05e00000,
+      0x05b80000, 0x05980000, 0x05c80000, 0x05d00000,
+      0x05880000, 0x05a80000, 0x05900000, 0x05a00000,
+      0x05b00000, 0x05f80000, 0x05800000, 0x05d80000,
+      0x01680000, 0x01400000, 0x01700000, 0x01600000,
+      0x01380000, 0x01180000, 0x01480000, 0x01500000,
+      0x01080000, 0x01280000, 0x01100000, 0x01200000,
+      0x01300000, 0x01780000, 0x01000000, 0x01580000,
+      0x02e80000, 0x02c00000, 0x02f00000, 0x02e00000,
+      0x02b80000, 0x02980000, 0x02c80000, 0x02d00000,
+      0x02880000, 0x02a80000, 0x02900000, 0x02a00000,
+      0x02b00000, 0x02f80000, 0x02800000, 0x02d80000,
+      0x07e80000, 0x07c00000, 0x07f00000, 0x07e00000,
+      0x07b80000, 0x07980000, 0x07c80000, 0x07d00000,
+      0x07880000, 0x07a80000, 0x07900000, 0x07a00000,
+      0x07b00000, 0x07f80000, 0x07800000, 0x07d80000,
+      0x03e80000, 0x03c00000, 0x03f00000, 0x03e00000,
+      0x03b80000, 0x03980000, 0x03c80000, 0x03d00000,
+      0x03880000, 0x03a80000, 0x03900000, 0x03a00000,
+      0x03b00000, 0x03f80000, 0x03800000, 0x03d80000,
+      0x00e80000, 0x00c00000, 0x00f00000, 0x00e00000,
+      0x00b80000, 0x00980000, 0x00c80000, 0x00d00000,
+      0x00880000, 0x00a80000, 0x00900000, 0x00a00000,
+      0x00b00000, 0x00f80000, 0x00800000, 0x00d80000,
+      0x00680000, 0x00400000, 0x00700000, 0x00600000,
+      0x00380000, 0x00180000, 0x00480000, 0x00500000,
+      0x00080000, 0x00280000, 0x00100000, 0x00200000,
+      0x00300000, 0x00780000, 0x00000000, 0x00580000,
+      0x06e80000, 0x06c00000, 0x06f00000, 0x06e00000,
+      0x06b80000, 0x06980000, 0x06c80000, 0x06d00000,
+      0x06880000, 0x06a80000, 0x06900000, 0x06a00000,
+      0x06b00000, 0x06f80000, 0x06800000, 0x06d80000,
+      0x06680000, 0x06400000, 0x06700000, 0x06600000,
+      0x06380000, 0x06180000, 0x06480000, 0x06500000,
+      0x06080000, 0x06280000, 0x06100000, 0x06200000,
+      0x06300000, 0x06780000, 0x06000000, 0x06580000,
+      0x03680000, 0x03400000, 0x03700000, 0x03600000,
+      0x03380000, 0x03180000, 0x03480000, 0x03500000,
+      0x03080000, 0x03280000, 0x03100000, 0x03200000,
+      0x03300000, 0x03780000, 0x03000000, 0x03580000,
+      0x05680000, 0x05400000, 0x05700000, 0x05600000,
+      0x05380000, 0x05180000, 0x05480000, 0x05500000,
+      0x05080000, 0x05280000, 0x05100000, 0x05200000,
+      0x05300000, 0x05780000, 0x05000000, 0x05580000,
+      0x02680000, 0x02400000, 0x02700000, 0x02600000,
+      0x02380000, 0x02180000, 0x02480000, 0x02500000,
+      0x02080000, 0x02280000, 0x02100000, 0x02200000,
+      0x02300000, 0x02780000, 0x02000000, 0x02580000,
+      0x01e80000, 0x01c00000, 0x01f00000, 0x01e00000,
+      0x01b80000, 0x01980000, 0x01c80000, 0x01d00000,
+      0x01880000, 0x01a80000, 0x01900000, 0x01a00000,
+      0x01b00000, 0x01f80000, 0x01800000, 0x01d80000,
+      0x04680000, 0x04400000, 0x04700000, 0x04600000,
+      0x04380000, 0x04180000, 0x04480000, 0x04500000,
+      0x04080000, 0x04280000, 0x04100000, 0x04200000,
+      0x04300000, 0x04780000, 0x04000000, 0x04580000,
+    }, { /* 2 */
+      0x18000004, 0x70000004, 0x28000004, 0x48000004,
+      0x30000004, 0x40000004, 0x00000004, 0x68000004,
+      0x50000004, 0x58000004, 0x38000004, 0x60000004,
+      0x10000004, 0x08000004, 0x78000004, 0x20000004,
+      0x98000007, 0xf0000007, 0xa8000007, 0xc8000007,
+      0xb0000007, 0xc0000007, 0x80000007, 0xe8000007,
+      0xd0000007, 0xd8000007, 0xb8000007, 0xe0000007,
+      0x90000007, 0x88000007, 0xf8000007, 0xa0000007,
+      0x18000003, 0x70000003, 0x28000003, 0x48000003,
+      0x30000003, 0x40000003, 0x00000003, 0x68000003,
+      0x50000003, 0x58000003, 0x38000003, 0x60000003,
+      0x10000003, 0x08000003, 0x78000003, 0x20000003,
+      0x98000005, 0xf0000005, 0xa8000005, 0xc8000005,
+      0xb0000005, 0xc0000005, 0x80000005, 0xe8000005,
+      0xd0000005, 0xd8000005, 0xb8000005, 0xe0000005,
+      0x90000005, 0x88000005, 0xf8000005, 0xa0000005,
+      0x98000000, 0xf0000000, 0xa8000000, 0xc8000000,
+      0xb0000000, 0xc0000000, 0x80000000, 0xe8000000,
+      0xd0000000, 0xd8000000, 0xb8000000, 0xe0000000,
+      0x90000000, 0x88000000, 0xf8000000, 0xa0000000,
+      0x98000004, 0xf0000004, 0xa8000004, 0xc8000004,
+      0xb0000004, 0xc0000004, 0x80000004, 0xe8000004,
+      0xd0000004, 0xd8000004, 0xb8000004, 0xe0000004,
+      0x90000004, 0x88000004, 0xf8000004, 0xa0000004,
+      0x18000006, 0x70000006, 0x28000006, 0x48000006,
+      0x30000006, 0x40000006, 0x00000006, 0x68000006,
+      0x50000006, 0x58000006, 0x38000006, 0x60000006,
+      0x10000006, 0x08000006, 0x78000006, 0x20000006,
+      0x98000002, 0xf0000002, 0xa8000002, 0xc8000002,
+      0xb0000002, 0xc0000002, 0x80000002, 0xe8000002,
+      0xd0000002, 0xd8000002, 0xb8000002, 0xe0000002,
+      0x90000002, 0x88000002, 0xf8000002, 0xa0000002,
+      0x98000006, 0xf0000006, 0xa8000006, 0xc8000006,
+      0xb0000006, 0xc0000006, 0x80000006, 0xe8000006,
+      0xd0000006, 0xd8000006, 0xb8000006, 0xe0000006,
+      0x90000006, 0x88000006, 0xf8000006, 0xa0000006,
+      0x98000001, 0xf0000001, 0xa8000001, 0xc8000001,
+      0xb0000001, 0xc0000001, 0x80000001, 0xe8000001,
+      0xd0000001, 0xd8000001, 0xb8000001, 0xe0000001,
+      0x90000001, 0x88000001, 0xf8000001, 0xa0000001,
+      0x98000003, 0xf0000003, 0xa8000003, 0xc8000003,
+      0xb0000003, 0xc0000003, 0x80000003, 0xe8000003,
+      0xd0000003, 0xd8000003, 0xb8000003, 0xe0000003,
+      0x90000003, 0x88000003, 0xf8000003, 0xa0000003,
+      0x18000005, 0x70000005, 0x28000005, 0x48000005,
+      0x30000005, 0x40000005, 0x00000005, 0x68000005,
+      0x50000005, 0x58000005, 0x38000005, 0x60000005,
+      0x10000005, 0x08000005, 0x78000005, 0x20000005,
+      0x18000000, 0x70000000, 0x28000000, 0x48000000,
+      0x30000000, 0x40000000, 0x00000000, 0x68000000,
+      0x50000000, 0x58000000, 0x38000000, 0x60000000,
+      0x10000000, 0x08000000, 0x78000000, 0x20000000,
+      0x18000007, 0x70000007, 0x28000007, 0x48000007,
+      0x30000007, 0x40000007, 0x00000007, 0x68000007,
+      0x50000007, 0x58000007, 0x38000007, 0x60000007,
+      0x10000007, 0x08000007, 0x78000007, 0x20000007,
+      0x18000001, 0x70000001, 0x28000001, 0x48000001,
+      0x30000001, 0x40000001, 0x00000001, 0x68000001,
+      0x50000001, 0x58000001, 0x38000001, 0x60000001,
+      0x10000001, 0x08000001, 0x78000001, 0x20000001,
+      0x18000002, 0x70000002, 0x28000002, 0x48000002,
+      0x30000002, 0x40000002, 0x00000002, 0x68000002,
+      0x50000002, 0x58000002, 0x38000002, 0x60000002,
+      0x10000002, 0x08000002, 0x78000002, 0x20000002,
+    }, { /* 3 */
+      0x00000648, 0x00000658, 0x00000660, 0x00000600,
+      0x00000618, 0x00000630, 0x00000638, 0x00000628,
+      0x00000620, 0x00000640, 0x00000670, 0x00000678,
+      0x00000608, 0x00000650, 0x00000610, 0x00000668,
+      0x00000348, 0x00000358, 0x00000360, 0x00000300,
+      0x00000318, 0x00000330, 0x00000338, 0x00000328,
+      0x00000320, 0x00000340, 0x00000370, 0x00000378,
+      0x00000308, 0x00000350, 0x00000310, 0x00000368,
+      0x000002c8, 0x000002d8, 0x000002e0, 0x00000280,
+      0x00000298, 0x000002b0, 0x000002b8, 0x000002a8,
+      0x000002a0, 0x000002c0, 0x000002f0, 0x000002f8,
+      0x00000288, 0x000002d0, 0x00000290, 0x000002e8,
+      0x00000148, 0x00000158, 0x00000160, 0x00000100,
+      0x00000118, 0x00000130, 0x00000138, 0x00000128,
+      0x00000120, 0x00000140, 0x00000170, 0x00000178,
+      0x00000108, 0x00000150, 0x00000110, 0x00000168,
+      0x000005c8, 0x000005d8, 0x000005e0, 0x00000580,
+      0x00000598, 0x000005b0, 0x000005b8, 0x000005a8,
+      0x000005a0, 0x000005c0, 0x000005f0, 0x000005f8,
+      0x00000588, 0x000005d0, 0x00000590, 0x000005e8,
+      0x00000048, 0x00000058, 0x00000060, 0x00000000,
+      0x00000018, 0x00000030, 0x00000038, 0x00000028,
+      0x00000020, 0x00000040, 0x00000070, 0x00000078,
+      0x00000008, 0x00000050, 0x00000010, 0x00000068,
+      0x000004c8, 0x000004d8, 0x000004e0, 0x00000480,
+      0x00000498, 0x000004b0, 0x000004b8, 0x000004a8,
+      0x000004a0, 0x000004c0, 0x000004f0, 0x000004f8,
+      0x00000488, 0x000004d0, 0x00000490, 0x000004e8,
+      0x000006c8, 0x000006d8, 0x000006e0, 0x00000680,
+      0x00000698, 0x000006b0, 0x000006b8, 0x000006a8,
+      0x000006a0, 0x000006c0, 0x000006f0, 0x000006f8,
+      0x00000688, 0x000006d0, 0x00000690, 0x000006e8,
+      0x000001c8, 0x000001d8, 0x000001e0, 0x00000180,
+      0x00000198, 0x000001b0, 0x000001b8, 0x000001a8,
+      0x000001a0, 0x000001c0, 0x000001f0, 0x000001f8,
+      0x00000188, 0x000001d0, 0x00000190, 0x000001e8,
+      0x00000748, 0x00000758, 0x00000760, 0x00000700,
+      0x00000718, 0x00000730, 0x00000738, 0x00000728,
+      0x00000720, 0x00000740, 0x00000770, 0x00000778,
+      0x00000708, 0x00000750, 0x00000710, 0x00000768,
+      0x000003c8, 0x000003d8, 0x000003e0, 0x00000380,
+      0x00000398, 0x000003b0, 0x000003b8, 0x000003a8,
+      0x000003a0, 0x000003c0, 0x000003f0, 0x000003f8,
+      0x00000388, 0x000003d0, 0x00000390, 0x000003e8,
+      0x00000548, 0x00000558, 0x00000560, 0x00000500,
+      0x00000518, 0x00000530, 0x00000538, 0x00000528,
+      0x00000520, 0x00000540, 0x00000570, 0x00000578,
+      0x00000508, 0x00000550, 0x00000510, 0x00000568,
+      0x000007c8, 0x000007d8, 0x000007e0, 0x00000780,
+      0x00000798, 0x000007b0, 0x000007b8, 0x000007a8,
+      0x000007a0, 0x000007c0, 0x000007f0, 0x000007f8,
+      0x00000788, 0x000007d0, 0x00000790, 0x000007e8,
+      0x00000248, 0x00000258, 0x00000260, 0x00000200,
+      0x00000218, 0x00000230, 0x00000238, 0x00000228,
+      0x00000220, 0x00000240, 0x00000270, 0x00000278,
+      0x00000208, 0x00000250, 0x00000210, 0x00000268,
+      0x000000c8, 0x000000d8, 0x000000e0, 0x00000080,
+      0x00000098, 0x000000b0, 0x000000b8, 0x000000a8,
+      0x000000a0, 0x000000c0, 0x000000f0, 0x000000f8,
+      0x00000088, 0x000000d0, 0x00000090, 0x000000e8,
+      0x00000448, 0x00000458, 0x00000460, 0x00000400,
+      0x00000418, 0x00000430, 0x00000438, 0x00000428,
+      0x00000420, 0x00000440, 0x00000470, 0x00000478,
+      0x00000408, 0x00000450, 0x00000410, 0x00000468,
+    }
+  }
+};
+
+const struct gost28147_param gost28147_param_CryptoPro_A =
+{
+  {
+    { /* 0 */
+      0x0001c800, 0x0001b000, 0x00019800, 0x00019000,
+      0x0001c000, 0x0001d800, 0x00018800, 0x0001b800,
+      0x0001d000, 0x0001a000, 0x0001f000, 0x0001f800,
+      0x0001e000, 0x00018000, 0x0001e800, 0x0001a800,
+      0x0003c800, 0x0003b000, 0x00039800, 0x00039000,
+      0x0003c000, 0x0003d800, 0x00038800, 0x0003b800,
+      0x0003d000, 0x0003a000, 0x0003f000, 0x0003f800,
+      0x0003e000, 0x00038000, 0x0003e800, 0x0003a800,
+      0x00074800, 0x00073000, 0x00071800, 0x00071000,
+      0x00074000, 0x00075800, 0x00070800, 0x00073800,
+      0x00075000, 0x00072000, 0x00077000, 0x00077800,
+      0x00076000, 0x00070000, 0x00076800, 0x00072800,
+      0x0004c800, 0x0004b000, 0x00049800, 0x00049000,
+      0x0004c000, 0x0004d800, 0x00048800, 0x0004b800,
+      0x0004d000, 0x0004a000, 0x0004f000, 0x0004f800,
+      0x0004e000, 0x00048000, 0x0004e800, 0x0004a800,
+      0x00044800, 0x00043000, 0x00041800, 0x00041000,
+      0x00044000, 0x00045800, 0x00040800, 0x00043800,
+      0x00045000, 0x00042000, 0x00047000, 0x00047800,
+      0x00046000, 0x00040000, 0x00046800, 0x00042800,
+      0x00054800, 0x00053000, 0x00051800, 0x00051000,
+      0x00054000, 0x00055800, 0x00050800, 0x00053800,
+      0x00055000, 0x00052000, 0x00057000, 0x00057800,
+      0x00056000, 0x00050000, 0x00056800, 0x00052800,
+      0x0007c800, 0x0007b000, 0x00079800, 0x00079000,
+      0x0007c000, 0x0007d800, 0x00078800, 0x0007b800,
+      0x0007d000, 0x0007a000, 0x0007f000, 0x0007f800,
+      0x0007e000, 0x00078000, 0x0007e800, 0x0007a800,
+      0x00004800, 0x00003000, 0x00001800, 0x00001000,
+      0x00004000, 0x00005800, 0x00000800, 0x00003800,
+      0x00005000, 0x00002000, 0x00007000, 0x00007800,
+      0x00006000, 0x00000000, 0x00006800, 0x00002800,
+      0x0002c800, 0x0002b000, 0x00029800, 0x00029000,
+      0x0002c000, 0x0002d800, 0x00028800, 0x0002b800,
+      0x0002d000, 0x0002a000, 0x0002f000, 0x0002f800,
+      0x0002e000, 0x00028000, 0x0002e800, 0x0002a800,
+      0x00014800, 0x00013000, 0x00011800, 0x00011000,
+      0x00014000, 0x00015800, 0x00010800, 0x00013800,
+      0x00015000, 0x00012000, 0x00017000, 0x00017800,
+      0x00016000, 0x00010000, 0x00016800, 0x00012800,
+      0x00034800, 0x00033000, 0x00031800, 0x00031000,
+      0x00034000, 0x00035800, 0x00030800, 0x00033800,
+      0x00035000, 0x00032000, 0x00037000, 0x00037800,
+      0x00036000, 0x00030000, 0x00036800, 0x00032800,
+      0x00064800, 0x00063000, 0x00061800, 0x00061000,
+      0x00064000, 0x00065800, 0x00060800, 0x00063800,
+      0x00065000, 0x00062000, 0x00067000, 0x00067800,
+      0x00066000, 0x00060000, 0x00066800, 0x00062800,
+      0x0005c800, 0x0005b000, 0x00059800, 0x00059000,
+      0x0005c000, 0x0005d800, 0x00058800, 0x0005b800,
+      0x0005d000, 0x0005a000, 0x0005f000, 0x0005f800,
+      0x0005e000, 0x00058000, 0x0005e800, 0x0005a800,
+      0x00024800, 0x00023000, 0x00021800, 0x00021000,
+      0x00024000, 0x00025800, 0x00020800, 0x00023800,
+      0x00025000, 0x00022000, 0x00027000, 0x00027800,
+      0x00026000, 0x00020000, 0x00026800, 0x00022800,
+      0x0006c800, 0x0006b000, 0x00069800, 0x00069000,
+      0x0006c000, 0x0006d800, 0x00068800, 0x0006b800,
+      0x0006d000, 0x0006a000, 0x0006f000, 0x0006f800,
+      0x0006e000, 0x00068000, 0x0006e800, 0x0006a800,
+      0x0000c800, 0x0000b000, 0x00009800, 0x00009000,
+      0x0000c000, 0x0000d800, 0x00008800, 0x0000b800,
+      0x0000d000, 0x0000a000, 0x0000f000, 0x0000f800,
+      0x0000e000, 0x00008000, 0x0000e800, 0x0000a800,
+    }, { /* 1 */
+      0x07700000, 0x07200000, 0x07300000, 0x07100000,
+      0x07580000, 0x07180000, 0x07680000, 0x07400000,
+      0x07600000, 0x07780000, 0x07280000, 0x07500000,
+      0x07000000, 0x07380000, 0x07080000, 0x07480000,
+      0x03f00000, 0x03a00000, 0x03b00000, 0x03900000,
+      0x03d80000, 0x03980000, 0x03e80000, 0x03c00000,
+      0x03e00000, 0x03f80000, 0x03a80000, 0x03d00000,
+      0x03800000, 0x03b80000, 0x03880000, 0x03c80000,
+      0x05700000, 0x05200000, 0x05300000, 0x05100000,
+      0x05580000, 0x05180000, 0x05680000, 0x05400000,
+      0x05600000, 0x05780000, 0x05280000, 0x05500000,
+      0x05000000, 0x05380000, 0x05080000, 0x05480000,
+      0x06700000, 0x06200000, 0x06300000, 0x06100000,
+      0x06580000, 0x06180000, 0x06680000, 0x06400000,
+      0x06600000, 0x06780000, 0x06280000, 0x06500000,
+      0x06000000, 0x06380000, 0x06080000, 0x06480000,
+      0x06f00000, 0x06a00000, 0x06b00000, 0x06900000,
+      0x06d80000, 0x06980000, 0x06e80000, 0x06c00000,
+      0x06e00000, 0x06f80000, 0x06a80000, 0x06d00000,
+      0x06800000, 0x06b80000, 0x06880000, 0x06c80000,
+      0x00f00000, 0x00a00000, 0x00b00000, 0x00900000,
+      0x00d80000, 0x00980000, 0x00e80000, 0x00c00000,
+      0x00e00000, 0x00f80000, 0x00a80000, 0x00d00000,
+      0x00800000, 0x00b80000, 0x00880000, 0x00c80000,
+      0x01f00000, 0x01a00000, 0x01b00000, 0x01900000,
+      0x01d80000, 0x01980000, 0x01e80000, 0x01c00000,
+      0x01e00000, 0x01f80000, 0x01a80000, 0x01d00000,
+      0x01800000, 0x01b80000, 0x01880000, 0x01c80000,
+      0x04f00000, 0x04a00000, 0x04b00000, 0x04900000,
+      0x04d80000, 0x04980000, 0x04e80000, 0x04c00000,
+      0x04e00000, 0x04f80000, 0x04a80000, 0x04d00000,
+      0x04800000, 0x04b80000, 0x04880000, 0x04c80000,
+      0x00700000, 0x00200000, 0x00300000, 0x00100000,
+      0x00580000, 0x00180000, 0x00680000, 0x00400000,
+      0x00600000, 0x00780000, 0x00280000, 0x00500000,
+      0x00000000, 0x00380000, 0x00080000, 0x00480000,
+      0x01700000, 0x01200000, 0x01300000, 0x01100000,
+      0x01580000, 0x01180000, 0x01680000, 0x01400000,
+      0x01600000, 0x01780000, 0x01280000, 0x01500000,
+      0x01000000, 0x01380000, 0x01080000, 0x01480000,
+      0x05f00000, 0x05a00000, 0x05b00000, 0x05900000,
+      0x05d80000, 0x05980000, 0x05e80000, 0x05c00000,
+      0x05e00000, 0x05f80000, 0x05a80000, 0x05d00000,
+      0x05800000, 0x05b80000, 0x05880000, 0x05c80000,
+      0x02700000, 0x02200000, 0x02300000, 0x02100000,
+      0x02580000, 0x02180000, 0x02680000, 0x02400000,
+      0x02600000, 0x02780000, 0x02280000, 0x02500000,
+      0x02000000, 0x02380000, 0x02080000, 0x02480000,
+      0x07f00000, 0x07a00000, 0x07b00000, 0x07900000,
+      0x07d80000, 0x07980000, 0x07e80000, 0x07c00000,
+      0x07e00000, 0x07f80000, 0x07a80000, 0x07d00000,
+      0x07800000, 0x07b80000, 0x07880000, 0x07c80000,
+      0x04700000, 0x04200000, 0x04300000, 0x04100000,
+      0x04580000, 0x04180000, 0x04680000, 0x04400000,
+      0x04600000, 0x04780000, 0x04280000, 0x04500000,
+      0x04000000, 0x04380000, 0x04080000, 0x04480000,
+      0x02f00000, 0x02a00000, 0x02b00000, 0x02900000,
+      0x02d80000, 0x02980000, 0x02e80000, 0x02c00000,
+      0x02e00000, 0x02f80000, 0x02a80000, 0x02d00000,
+      0x02800000, 0x02b80000, 0x02880000, 0x02c80000,
+      0x03700000, 0x03200000, 0x03300000, 0x03100000,
+      0x03580000, 0x03180000, 0x03680000, 0x03400000,
+      0x03600000, 0x03780000, 0x03280000, 0x03500000,
+      0x03000000, 0x03380000, 0x03080000, 0x03480000,
+    }, { /* 2 */
+      0xd8000001, 0xa8000001, 0x88000001, 0xc8000001,
+      0xc0000001, 0xe8000001, 0xf8000001, 0x80000001,
+      0xf0000001, 0xa0000001, 0x90000001, 0x98000001,
+      0xe0000001, 0xb8000001, 0xd0000001, 0xb0000001,
+      0x58000005, 0x28000005, 0x08000005, 0x48000005,
+      0x40000005, 0x68000005, 0x78000005, 0x00000005,
+      0x70000005, 0x20000005, 0x10000005, 0x18000005,
+      0x60000005, 0x38000005, 0x50000005, 0x30000005,
+      0xd8000006, 0xa8000006, 0x88000006, 0xc8000006,
+      0xc0000006, 0xe8000006, 0xf8000006, 0x80000006,
+      0xf0000006, 0xa0000006, 0x90000006, 0x98000006,
+      0xe0000006, 0xb8000006, 0xd0000006, 0xb0000006,
+      0x58000006, 0x28000006, 0x08000006, 0x48000006,
+      0x40000006, 0x68000006, 0x78000006, 0x00000006,
+      0x70000006, 0x20000006, 0x10000006, 0x18000006,
+      0x60000006, 0x38000006, 0x50000006, 0x30000006,
+      0xd8000000, 0xa8000000, 0x88000000, 0xc8000000,
+      0xc0000000, 0xe8000000, 0xf8000000, 0x80000000,
+      0xf0000000, 0xa0000000, 0x90000000, 0x98000000,
+      0xe0000000, 0xb8000000, 0xd0000000, 0xb0000000,
+      0x58000001, 0x28000001, 0x08000001, 0x48000001,
+      0x40000001, 0x68000001, 0x78000001, 0x00000001,
+      0x70000001, 0x20000001, 0x10000001, 0x18000001,
+      0x60000001, 0x38000001, 0x50000001, 0x30000001,
+      0x58000000, 0x28000000, 0x08000000, 0x48000000,
+      0x40000000, 0x68000000, 0x78000000, 0x00000000,
+      0x70000000, 0x20000000, 0x10000000, 0x18000000,
+      0x60000000, 0x38000000, 0x50000000, 0x30000000,
+      0xd8000005, 0xa8000005, 0x88000005, 0xc8000005,
+      0xc0000005, 0xe8000005, 0xf8000005, 0x80000005,
+      0xf0000005, 0xa0000005, 0x90000005, 0x98000005,
+      0xe0000005, 0xb8000005, 0xd0000005, 0xb0000005,
+      0xd8000003, 0xa8000003, 0x88000003, 0xc8000003,
+      0xc0000003, 0xe8000003, 0xf8000003, 0x80000003,
+      0xf0000003, 0xa0000003, 0x90000003, 0x98000003,
+      0xe0000003, 0xb8000003, 0xd0000003, 0xb0000003,
+      0xd8000002, 0xa8000002, 0x88000002, 0xc8000002,
+      0xc0000002, 0xe8000002, 0xf8000002, 0x80000002,
+      0xf0000002, 0xa0000002, 0x90000002, 0x98000002,
+      0xe0000002, 0xb8000002, 0xd0000002, 0xb0000002,
+      0xd8000004, 0xa8000004, 0x88000004, 0xc8000004,
+      0xc0000004, 0xe8000004, 0xf8000004, 0x80000004,
+      0xf0000004, 0xa0000004, 0x90000004, 0x98000004,
+      0xe0000004, 0xb8000004, 0xd0000004, 0xb0000004,
+      0x58000002, 0x28000002, 0x08000002, 0x48000002,
+      0x40000002, 0x68000002, 0x78000002, 0x00000002,
+      0x70000002, 0x20000002, 0x10000002, 0x18000002,
+      0x60000002, 0x38000002, 0x50000002, 0x30000002,
+      0x58000004, 0x28000004, 0x08000004, 0x48000004,
+      0x40000004, 0x68000004, 0x78000004, 0x00000004,
+      0x70000004, 0x20000004, 0x10000004, 0x18000004,
+      0x60000004, 0x38000004, 0x50000004, 0x30000004,
+      0xd8000007, 0xa8000007, 0x88000007, 0xc8000007,
+      0xc0000007, 0xe8000007, 0xf8000007, 0x80000007,
+      0xf0000007, 0xa0000007, 0x90000007, 0x98000007,
+      0xe0000007, 0xb8000007, 0xd0000007, 0xb0000007,
+      0x58000007, 0x28000007, 0x08000007, 0x48000007,
+      0x40000007, 0x68000007, 0x78000007, 0x00000007,
+      0x70000007, 0x20000007, 0x10000007, 0x18000007,
+      0x60000007, 0x38000007, 0x50000007, 0x30000007,
+      0x58000003, 0x28000003, 0x08000003, 0x48000003,
+      0x40000003, 0x68000003, 0x78000003, 0x00000003,
+      0x70000003, 0x20000003, 0x10000003, 0x18000003,
+      0x60000003, 0x38000003, 0x50000003, 0x30000003,
+    }, { /* 3 */
+      0x00000588, 0x000005e8, 0x00000590, 0x000005c8,
+      0x000005b8, 0x000005d0, 0x000005b0, 0x00000580,
+      0x000005c0, 0x000005e0, 0x000005a0, 0x000005a8,
+      0x000005f8, 0x00000598, 0x000005d8, 0x000005f0,
+      0x00000508, 0x00000568, 0x00000510, 0x00000548,
+      0x00000538, 0x00000550, 0x00000530, 0x00000500,
+      0x00000540, 0x00000560, 0x00000520, 0x00000528,
+      0x00000578, 0x00000518, 0x00000558, 0x00000570,
+      0x00000788, 0x000007e8, 0x00000790, 0x000007c8,
+      0x000007b8, 0x000007d0, 0x000007b0, 0x00000780,
+      0x000007c0, 0x000007e0, 0x000007a0, 0x000007a8,
+      0x000007f8, 0x00000798, 0x000007d8, 0x000007f0,
+      0x00000288, 0x000002e8, 0x00000290, 0x000002c8,
+      0x000002b8, 0x000002d0, 0x000002b0, 0x00000280,
+      0x000002c0, 0x000002e0, 0x000002a0, 0x000002a8,
+      0x000002f8, 0x00000298, 0x000002d8, 0x000002f0,
+      0x00000008, 0x00000068, 0x00000010, 0x00000048,
+      0x00000038, 0x00000050, 0x00000030, 0x00000000,
+      0x00000040, 0x00000060, 0x00000020, 0x00000028,
+      0x00000078, 0x00000018, 0x00000058, 0x00000070,
+      0x00000608, 0x00000668, 0x00000610, 0x00000648,
+      0x00000638, 0x00000650, 0x00000630, 0x00000600,
+      0x00000640, 0x00000660, 0x00000620, 0x00000628,
+      0x00000678, 0x00000618, 0x00000658, 0x00000670,
+      0x00000708, 0x00000768, 0x00000710, 0x00000748,
+      0x00000738, 0x00000750, 0x00000730, 0x00000700,
+      0x00000740, 0x00000760, 0x00000720, 0x00000728,
+      0x00000778, 0x00000718, 0x00000758, 0x00000770,
+      0x00000408, 0x00000468, 0x00000410, 0x00000448,
+      0x00000438, 0x00000450, 0x00000430, 0x00000400,
+      0x00000440, 0x00000460, 0x00000420, 0x00000428,
+      0x00000478, 0x00000418, 0x00000458, 0x00000470,
+      0x00000308, 0x00000368, 0x00000310, 0x00000348,
+      0x00000338, 0x00000350, 0x00000330, 0x00000300,
+      0x00000340, 0x00000360, 0x00000320, 0x00000328,
+      0x00000378, 0x00000318, 0x00000358, 0x00000370,
+      0x00000108, 0x00000168, 0x00000110, 0x00000148,
+      0x00000138, 0x00000150, 0x00000130, 0x00000100,
+      0x00000140, 0x00000160, 0x00000120, 0x00000128,
+      0x00000178, 0x00000118, 0x00000158, 0x00000170,
+      0x00000188, 0x000001e8, 0x00000190, 0x000001c8,
+      0x000001b8, 0x000001d0, 0x000001b0, 0x00000180,
+      0x000001c0, 0x000001e0, 0x000001a0, 0x000001a8,
+      0x000001f8, 0x00000198, 0x000001d8, 0x000001f0,
+      0x00000488, 0x000004e8, 0x00000490, 0x000004c8,
+      0x000004b8, 0x000004d0, 0x000004b0, 0x00000480,
+      0x000004c0, 0x000004e0, 0x000004a0, 0x000004a8,
+      0x000004f8, 0x00000498, 0x000004d8, 0x000004f0,
+      0x00000088, 0x000000e8, 0x00000090, 0x000000c8,
+      0x000000b8, 0x000000d0, 0x000000b0, 0x00000080,
+      0x000000c0, 0x000000e0, 0x000000a0, 0x000000a8,
+      0x000000f8, 0x00000098, 0x000000d8, 0x000000f0,
+      0x00000388, 0x000003e8, 0x00000390, 0x000003c8,
+      0x000003b8, 0x000003d0, 0x000003b0, 0x00000380,
+      0x000003c0, 0x000003e0, 0x000003a0, 0x000003a8,
+      0x000003f8, 0x00000398, 0x000003d8, 0x000003f0,
+      0x00000688, 0x000006e8, 0x00000690, 0x000006c8,
+      0x000006b8, 0x000006d0, 0x000006b0, 0x00000680,
+      0x000006c0, 0x000006e0, 0x000006a0, 0x000006a8,
+      0x000006f8, 0x00000698, 0x000006d8, 0x000006f0,
+      0x00000208, 0x00000268, 0x00000210, 0x00000248,
+      0x00000238, 0x00000250, 0x00000230, 0x00000200,
+      0x00000240, 0x00000260, 0x00000220, 0x00000228,
+      0x00000278, 0x00000218, 0x00000258, 0x00000270,
+    }
+  }
+};
+
+const struct gost28147_param gost28147_param_CryptoPro_B =
+{
+  {
+    { /* 0 */
+      0x00004000, 0x00002000, 0x00005800, 0x00000800,
+      0x00001800, 0x00002800, 0x00000000, 0x00004800,
+      0x00001000, 0x00007000, 0x00005000, 0x00006000,
+      0x00006800, 0x00003000, 0x00003800, 0x00007800,
+      0x0000c000, 0x0000a000, 0x0000d800, 0x00008800,
+      0x00009800, 0x0000a800, 0x00008000, 0x0000c800,
+      0x00009000, 0x0000f000, 0x0000d000, 0x0000e000,
+      0x0000e800, 0x0000b000, 0x0000b800, 0x0000f800,
+      0x00014000, 0x00012000, 0x00015800, 0x00010800,
+      0x00011800, 0x00012800, 0x00010000, 0x00014800,
+      0x00011000, 0x00017000, 0x00015000, 0x00016000,
+      0x00016800, 0x00013000, 0x00013800, 0x00017800,
+      0x00054000, 0x00052000, 0x00055800, 0x00050800,
+      0x00051800, 0x00052800, 0x00050000, 0x00054800,
+      0x00051000, 0x00057000, 0x00055000, 0x00056000,
+      0x00056800, 0x00053000, 0x00053800, 0x00057800,
+      0x00024000, 0x00022000, 0x00025800, 0x00020800,
+      0x00021800, 0x00022800, 0x00020000, 0x00024800,
+      0x00021000, 0x00027000, 0x00025000, 0x00026000,
+      0x00026800, 0x00023000, 0x00023800, 0x00027800,
+      0x0006c000, 0x0006a000, 0x0006d800, 0x00068800,
+      0x00069800, 0x0006a800, 0x00068000, 0x0006c800,
+      0x00069000, 0x0006f000, 0x0006d000, 0x0006e000,
+      0x0006e800, 0x0006b000, 0x0006b800, 0x0006f800,
+      0x0002c000, 0x0002a000, 0x0002d800, 0x00028800,
+      0x00029800, 0x0002a800, 0x00028000, 0x0002c800,
+      0x00029000, 0x0002f000, 0x0002d000, 0x0002e000,
+      0x0002e800, 0x0002b000, 0x0002b800, 0x0002f800,
+      0x00064000, 0x00062000, 0x00065800, 0x00060800,
+      0x00061800, 0x00062800, 0x00060000, 0x00064800,
+      0x00061000, 0x00067000, 0x00065000, 0x00066000,
+      0x00066800, 0x00063000, 0x00063800, 0x00067800,
+      0x0004c000, 0x0004a000, 0x0004d800, 0x00048800,
+      0x00049800, 0x0004a800, 0x00048000, 0x0004c800,
+      0x00049000, 0x0004f000, 0x0004d000, 0x0004e000,
+      0x0004e800, 0x0004b000, 0x0004b800, 0x0004f800,
+      0x0003c000, 0x0003a000, 0x0003d800, 0x00038800,
+      0x00039800, 0x0003a800, 0x00038000, 0x0003c800,
+      0x00039000, 0x0003f000, 0x0003d000, 0x0003e000,
+      0x0003e800, 0x0003b000, 0x0003b800, 0x0003f800,
+      0x0001c000, 0x0001a000, 0x0001d800, 0x00018800,
+      0x00019800, 0x0001a800, 0x00018000, 0x0001c800,
+      0x00019000, 0x0001f000, 0x0001d000, 0x0001e000,
+      0x0001e800, 0x0001b000, 0x0001b800, 0x0001f800,
+      0x0007c000, 0x0007a000, 0x0007d800, 0x00078800,
+      0x00079800, 0x0007a800, 0x00078000, 0x0007c800,
+      0x00079000, 0x0007f000, 0x0007d000, 0x0007e000,
+      0x0007e800, 0x0007b000, 0x0007b800, 0x0007f800,
+      0x0005c000, 0x0005a000, 0x0005d800, 0x00058800,
+      0x00059800, 0x0005a800, 0x00058000, 0x0005c800,
+      0x00059000, 0x0005f000, 0x0005d000, 0x0005e000,
+      0x0005e800, 0x0005b000, 0x0005b800, 0x0005f800,
+      0x00044000, 0x00042000, 0x00045800, 0x00040800,
+      0x00041800, 0x00042800, 0x00040000, 0x00044800,
+      0x00041000, 0x00047000, 0x00045000, 0x00046000,
+      0x00046800, 0x00043000, 0x00043800, 0x00047800,
+      0x00034000, 0x00032000, 0x00035800, 0x00030800,
+      0x00031800, 0x00032800, 0x00030000, 0x00034800,
+      0x00031000, 0x00037000, 0x00035000, 0x00036000,
+      0x00036800, 0x00033000, 0x00033800, 0x00037800,
+      0x00074000, 0x00072000, 0x00075800, 0x00070800,
+      0x00071800, 0x00072800, 0x00070000, 0x00074800,
+      0x00071000, 0x00077000, 0x00075000, 0x00076000,
+      0x00076800, 0x00073000, 0x00073800, 0x00077800,
+    }, { /* 1 */
+      0x03f00000, 0x03e00000, 0x03800000, 0x03d00000,
+      0x03c80000, 0x03900000, 0x03e80000, 0x03d80000,
+      0x03b80000, 0x03a80000, 0x03c00000, 0x03f80000,
+      0x03980000, 0x03b00000, 0x03880000, 0x03a00000,
+      0x02f00000, 0x02e00000, 0x02800000, 0x02d00000,
+      0x02c80000, 0x02900000, 0x02e80000, 0x02d80000,
+      0x02b80000, 0x02a80000, 0x02c00000, 0x02f80000,
+      0x02980000, 0x02b00000, 0x02880000, 0x02a00000,
+      0x00700000, 0x00600000, 0x00000000, 0x00500000,
+      0x00480000, 0x00100000, 0x00680000, 0x00580000,
+      0x00380000, 0x00280000, 0x00400000, 0x00780000,
+      0x00180000, 0x00300000, 0x00080000, 0x00200000,
+      0x06f00000, 0x06e00000, 0x06800000, 0x06d00000,
+      0x06c80000, 0x06900000, 0x06e80000, 0x06d80000,
+      0x06b80000, 0x06a80000, 0x06c00000, 0x06f80000,
+      0x06980000, 0x06b00000, 0x06880000, 0x06a00000,
+      0x05f00000, 0x05e00000, 0x05800000, 0x05d00000,
+      0x05c80000, 0x05900000, 0x05e80000, 0x05d80000,
+      0x05b80000, 0x05a80000, 0x05c00000, 0x05f80000,
+      0x05980000, 0x05b00000, 0x05880000, 0x05a00000,
+      0x03700000, 0x03600000, 0x03000000, 0x03500000,
+      0x03480000, 0x03100000, 0x03680000, 0x03580000,
+      0x03380000, 0x03280000, 0x03400000, 0x03780000,
+      0x03180000, 0x03300000, 0x03080000, 0x03200000,
+      0x00f00000, 0x00e00000, 0x00800000, 0x00d00000,
+      0x00c80000, 0x00900000, 0x00e80000, 0x00d80000,
+      0x00b80000, 0x00a80000, 0x00c00000, 0x00f80000,
+      0x00980000, 0x00b00000, 0x00880000, 0x00a00000,
+      0x01700000, 0x01600000, 0x01000000, 0x01500000,
+      0x01480000, 0x01100000, 0x01680000, 0x01580000,
+      0x01380000, 0x01280000, 0x01400000, 0x01780000,
+      0x01180000, 0x01300000, 0x01080000, 0x01200000,
+      0x01f00000, 0x01e00000, 0x01800000, 0x01d00000,
+      0x01c80000, 0x01900000, 0x01e80000, 0x01d80000,
+      0x01b80000, 0x01a80000, 0x01c00000, 0x01f80000,
+      0x01980000, 0x01b00000, 0x01880000, 0x01a00000,
+      0x05700000, 0x05600000, 0x05000000, 0x05500000,
+      0x05480000, 0x05100000, 0x05680000, 0x05580000,
+      0x05380000, 0x05280000, 0x05400000, 0x05780000,
+      0x05180000, 0x05300000, 0x05080000, 0x05200000,
+      0x06700000, 0x06600000, 0x06000000, 0x06500000,
+      0x06480000, 0x06100000, 0x06680000, 0x06580000,
+      0x06380000, 0x06280000, 0x06400000, 0x06780000,
+      0x06180000, 0x06300000, 0x06080000, 0x06200000,
+      0x07f00000, 0x07e00000, 0x07800000, 0x07d00000,
+      0x07c80000, 0x07900000, 0x07e80000, 0x07d80000,
+      0x07b80000, 0x07a80000, 0x07c00000, 0x07f80000,
+      0x07980000, 0x07b00000, 0x07880000, 0x07a00000,
+      0x02700000, 0x02600000, 0x02000000, 0x02500000,
+      0x02480000, 0x02100000, 0x02680000, 0x02580000,
+      0x02380000, 0x02280000, 0x02400000, 0x02780000,
+      0x02180000, 0x02300000, 0x02080000, 0x02200000,
+      0x07700000, 0x07600000, 0x07000000, 0x07500000,
+      0x07480000, 0x07100000, 0x07680000, 0x07580000,
+      0x07380000, 0x07280000, 0x07400000, 0x07780000,
+      0x07180000, 0x07300000, 0x07080000, 0x07200000,
+      0x04f00000, 0x04e00000, 0x04800000, 0x04d00000,
+      0x04c80000, 0x04900000, 0x04e80000, 0x04d80000,
+      0x04b80000, 0x04a80000, 0x04c00000, 0x04f80000,
+      0x04980000, 0x04b00000, 0x04880000, 0x04a00000,
+      0x04700000, 0x04600000, 0x04000000, 0x04500000,
+      0x04480000, 0x04100000, 0x04680000, 0x04580000,
+      0x04380000, 0x04280000, 0x04400000, 0x04780000,
+      0x04180000, 0x04300000, 0x04080000, 0x04200000,
+    }, { /* 2 */
+      0x10000004, 0x38000004, 0x60000004, 0x78000004,
+      0x48000004, 0x28000004, 0x50000004, 0x58000004,
+      0x08000004, 0x20000004, 0x00000004, 0x68000004,
+      0x30000004, 0x40000004, 0x70000004, 0x18000004,
+      0x90000001, 0xb8000001, 0xe0000001, 0xf8000001,
+      0xc8000001, 0xa8000001, 0xd0000001, 0xd8000001,
+      0x88000001, 0xa0000001, 0x80000001, 0xe8000001,
+      0xb0000001, 0xc0000001, 0xf0000001, 0x98000001,
+      0x10000001, 0x38000001, 0x60000001, 0x78000001,
+      0x48000001, 0x28000001, 0x50000001, 0x58000001,
+      0x08000001, 0x20000001, 0x00000001, 0x68000001,
+      0x30000001, 0x40000001, 0x70000001, 0x18000001,
+      0x10000003, 0x38000003, 0x60000003, 0x78000003,
+      0x48000003, 0x28000003, 0x50000003, 0x58000003,
+      0x08000003, 0x20000003, 0x00000003, 0x68000003,
+      0x30000003, 0x40000003, 0x70000003, 0x18000003,
+      0x10000002, 0x38000002, 0x60000002, 0x78000002,
+      0x48000002, 0x28000002, 0x50000002, 0x58000002,
+      0x08000002, 0x20000002, 0x00000002, 0x68000002,
+      0x30000002, 0x40000002, 0x70000002, 0x18000002,
+      0x90000006, 0xb8000006, 0xe0000006, 0xf8000006,
+      0xc8000006, 0xa8000006, 0xd0000006, 0xd8000006,
+      0x88000006, 0xa0000006, 0x80000006, 0xe8000006,
+      0xb0000006, 0xc0000006, 0xf0000006, 0x98000006,
+      0x10000007, 0x38000007, 0x60000007, 0x78000007,
+      0x48000007, 0x28000007, 0x50000007, 0x58000007,
+      0x08000007, 0x20000007, 0x00000007, 0x68000007,
+      0x30000007, 0x40000007, 0x70000007, 0x18000007,
+      0x90000005, 0xb8000005, 0xe0000005, 0xf8000005,
+      0xc8000005, 0xa8000005, 0xd0000005, 0xd8000005,
+      0x88000005, 0xa0000005, 0x80000005, 0xe8000005,
+      0xb0000005, 0xc0000005, 0xf0000005, 0x98000005,
+      0x10000006, 0x38000006, 0x60000006, 0x78000006,
+      0x48000006, 0x28000006, 0x50000006, 0x58000006,
+      0x08000006, 0x20000006, 0x00000006, 0x68000006,
+      0x30000006, 0x40000006, 0x70000006, 0x18000006,
+      0x90000000, 0xb8000000, 0xe0000000, 0xf8000000,
+      0xc8000000, 0xa8000000, 0xd0000000, 0xd8000000,
+      0x88000000, 0xa0000000, 0x80000000, 0xe8000000,
+      0xb0000000, 0xc0000000, 0xf0000000, 0x98000000,
+      0x90000003, 0xb8000003, 0xe0000003, 0xf8000003,
+      0xc8000003, 0xa8000003, 0xd0000003, 0xd8000003,
+      0x88000003, 0xa0000003, 0x80000003, 0xe8000003,
+      0xb0000003, 0xc0000003, 0xf0000003, 0x98000003,
+      0x90000007, 0xb8000007, 0xe0000007, 0xf8000007,
+      0xc8000007, 0xa8000007, 0xd0000007, 0xd8000007,
+      0x88000007, 0xa0000007, 0x80000007, 0xe8000007,
+      0xb0000007, 0xc0000007, 0xf0000007, 0x98000007,
+      0x10000005, 0x38000005, 0x60000005, 0x78000005,
+      0x48000005, 0x28000005, 0x50000005, 0x58000005,
+      0x08000005, 0x20000005, 0x00000005, 0x68000005,
+      0x30000005, 0x40000005, 0x70000005, 0x18000005,
+      0x10000000, 0x38000000, 0x60000000, 0x78000000,
+      0x48000000, 0x28000000, 0x50000000, 0x58000000,
+      0x08000000, 0x20000000, 0x00000000, 0x68000000,
+      0x30000000, 0x40000000, 0x70000000, 0x18000000,
+      0x90000004, 0xb8000004, 0xe0000004, 0xf8000004,
+      0xc8000004, 0xa8000004, 0xd0000004, 0xd8000004,
+      0x88000004, 0xa0000004, 0x80000004, 0xe8000004,
+      0xb0000004, 0xc0000004, 0xf0000004, 0x98000004,
+      0x90000002, 0xb8000002, 0xe0000002, 0xf8000002,
+      0xc8000002, 0xa8000002, 0xd0000002, 0xd8000002,
+      0x88000002, 0xa0000002, 0x80000002, 0xe8000002,
+      0xb0000002, 0xc0000002, 0xf0000002, 0x98000002,
+    }, { /* 3 */
+      0x00000028, 0x00000010, 0x00000050, 0x00000058,
+      0x00000048, 0x00000008, 0x00000060, 0x00000018,
+      0x00000038, 0x00000020, 0x00000068, 0x00000000,
+      0x00000030, 0x00000078, 0x00000040, 0x00000070,
+      0x00000228, 0x00000210, 0x00000250, 0x00000258,
+      0x00000248, 0x00000208, 0x00000260, 0x00000218,
+      0x00000238, 0x00000220, 0x00000268, 0x00000200,
+      0x00000230, 0x00000278, 0x00000240, 0x00000270,
+      0x000005a8, 0x00000590, 0x000005d0, 0x000005d8,
+      0x000005c8, 0x00000588, 0x000005e0, 0x00000598,
+      0x000005b8, 0x000005a0, 0x000005e8, 0x00000580,
+      0x000005b0, 0x000005f8, 0x000005c0, 0x000005f0,
+      0x00000728, 0x00000710, 0x00000750, 0x00000758,
+      0x00000748, 0x00000708, 0x00000760, 0x00000718,
+      0x00000738, 0x00000720, 0x00000768, 0x00000700,
+      0x00000730, 0x00000778, 0x00000740, 0x00000770,
+      0x00000428, 0x00000410, 0x00000450, 0x00000458,
+      0x00000448, 0x00000408, 0x00000460, 0x00000418,
+      0x00000438, 0x00000420, 0x00000468, 0x00000400,
+      0x00000430, 0x00000478, 0x00000440, 0x00000470,
+      0x000001a8, 0x00000190, 0x000001d0, 0x000001d8,
+      0x000001c8, 0x00000188, 0x000001e0, 0x00000198,
+      0x000001b8, 0x000001a0, 0x000001e8, 0x00000180,
+      0x000001b0, 0x000001f8, 0x000001c0, 0x000001f0,
+      0x000003a8, 0x00000390, 0x000003d0, 0x000003d8,
+      0x000003c8, 0x00000388, 0x000003e0, 0x00000398,
+      0x000003b8, 0x000003a0, 0x000003e8, 0x00000380,
+      0x000003b0, 0x000003f8, 0x000003c0, 0x000003f0,
+      0x000000a8, 0x00000090, 0x000000d0, 0x000000d8,
+      0x000000c8, 0x00000088, 0x000000e0, 0x00000098,
+      0x000000b8, 0x000000a0, 0x000000e8, 0x00000080,
+      0x000000b0, 0x000000f8, 0x000000c0, 0x000000f0,
+      0x00000528, 0x00000510, 0x00000550, 0x00000558,
+      0x00000548, 0x00000508, 0x00000560, 0x00000518,
+      0x00000538, 0x00000520, 0x00000568, 0x00000500,
+      0x00000530, 0x00000578, 0x00000540, 0x00000570,
+      0x00000128, 0x00000110, 0x00000150, 0x00000158,
+      0x00000148, 0x00000108, 0x00000160, 0x00000118,
+      0x00000138, 0x00000120, 0x00000168, 0x00000100,
+      0x00000130, 0x00000178, 0x00000140, 0x00000170,
+      0x000004a8, 0x00000490, 0x000004d0, 0x000004d8,
+      0x000004c8, 0x00000488, 0x000004e0, 0x00000498,
+      0x000004b8, 0x000004a0, 0x000004e8, 0x00000480,
+      0x000004b0, 0x000004f8, 0x000004c0, 0x000004f0,
+      0x00000328, 0x00000310, 0x00000350, 0x00000358,
+      0x00000348, 0x00000308, 0x00000360, 0x00000318,
+      0x00000338, 0x00000320, 0x00000368, 0x00000300,
+      0x00000330, 0x00000378, 0x00000340, 0x00000370,
+      0x000007a8, 0x00000790, 0x000007d0, 0x000007d8,
+      0x000007c8, 0x00000788, 0x000007e0, 0x00000798,
+      0x000007b8, 0x000007a0, 0x000007e8, 0x00000780,
+      0x000007b0, 0x000007f8, 0x000007c0, 0x000007f0,
+      0x000006a8, 0x00000690, 0x000006d0, 0x000006d8,
+      0x000006c8, 0x00000688, 0x000006e0, 0x00000698,
+      0x000006b8, 0x000006a0, 0x000006e8, 0x00000680,
+      0x000006b0, 0x000006f8, 0x000006c0, 0x000006f0,
+      0x000002a8, 0x00000290, 0x000002d0, 0x000002d8,
+      0x000002c8, 0x00000288, 0x000002e0, 0x00000298,
+      0x000002b8, 0x000002a0, 0x000002e8, 0x00000280,
+      0x000002b0, 0x000002f8, 0x000002c0, 0x000002f0,
+      0x00000628, 0x00000610, 0x00000650, 0x00000658,
+      0x00000648, 0x00000608, 0x00000660, 0x00000618,
+      0x00000638, 0x00000620, 0x00000668, 0x00000600,
+      0x00000630, 0x00000678, 0x00000640, 0x00000670,
+    }
+  }
+};
+
+const struct gost28147_param gost28147_param_CryptoPro_C =
+{
+  {
+    { /* 0 */
+      0x00000800, 0x00005800, 0x00006000, 0x00001000,
+      0x00004800, 0x00006800, 0x00000000, 0x00007800,
+      0x00002000, 0x00002800, 0x00004000, 0x00007000,
+      0x00005000, 0x00003800, 0x00003000, 0x00001800,
+      0x00008800, 0x0000d800, 0x0000e000, 0x00009000,
+      0x0000c800, 0x0000e800, 0x00008000, 0x0000f800,
+      0x0000a000, 0x0000a800, 0x0000c000, 0x0000f000,
+      0x0000d000, 0x0000b800, 0x0000b000, 0x00009800,
+      0x00038800, 0x0003d800, 0x0003e000, 0x00039000,
+      0x0003c800, 0x0003e800, 0x00038000, 0x0003f800,
+      0x0003a000, 0x0003a800, 0x0003c000, 0x0003f000,
+      0x0003d000, 0x0003b800, 0x0003b000, 0x00039800,
+      0x00068800, 0x0006d800, 0x0006e000, 0x00069000,
+      0x0006c800, 0x0006e800, 0x00068000, 0x0006f800,
+      0x0006a000, 0x0006a800, 0x0006c000, 0x0006f000,
+      0x0006d000, 0x0006b800, 0x0006b000, 0x00069800,
+      0x00058800, 0x0005d800, 0x0005e000, 0x00059000,
+      0x0005c800, 0x0005e800, 0x00058000, 0x0005f800,
+      0x0005a000, 0x0005a800, 0x0005c000, 0x0005f000,
+      0x0005d000, 0x0005b800, 0x0005b000, 0x00059800,
+      0x00020800, 0x00025800, 0x00026000, 0x00021000,
+      0x00024800, 0x00026800, 0x00020000, 0x00027800,
+      0x00022000, 0x00022800, 0x00024000, 0x00027000,
+      0x00025000, 0x00023800, 0x00023000, 0x00021800,
+      0x00028800, 0x0002d800, 0x0002e000, 0x00029000,
+      0x0002c800, 0x0002e800, 0x00028000, 0x0002f800,
+      0x0002a000, 0x0002a800, 0x0002c000, 0x0002f000,
+      0x0002d000, 0x0002b800, 0x0002b000, 0x00029800,
+      0x00010800, 0x00015800, 0x00016000, 0x00011000,
+      0x00014800, 0x00016800, 0x00010000, 0x00017800,
+      0x00012000, 0x00012800, 0x00014000, 0x00017000,
+      0x00015000, 0x00013800, 0x00013000, 0x00011800,
+      0x00040800, 0x00045800, 0x00046000, 0x00041000,
+      0x00044800, 0x00046800, 0x00040000, 0x00047800,
+      0x00042000, 0x00042800, 0x00044000, 0x00047000,
+      0x00045000, 0x00043800, 0x00043000, 0x00041800,
+      0x00070800, 0x00075800, 0x00076000, 0x00071000,
+      0x00074800, 0x00076800, 0x00070000, 0x00077800,
+      0x00072000, 0x00072800, 0x00074000, 0x00077000,
+      0x00075000, 0x00073800, 0x00073000, 0x00071800,
+      0x00078800, 0x0007d800, 0x0007e000, 0x00079000,
+      0x0007c800, 0x0007e800, 0x00078000, 0x0007f800,
+      0x0007a000, 0x0007a800, 0x0007c000, 0x0007f000,
+      0x0007d000, 0x0007b800, 0x0007b000, 0x00079800,
+      0x00060800, 0x00065800, 0x00066000, 0x00061000,
+      0x00064800, 0x00066800, 0x00060000, 0x00067800,
+      0x00062000, 0x00062800, 0x00064000, 0x00067000,
+      0x00065000, 0x00063800, 0x00063000, 0x00061800,
+      0x00048800, 0x0004d800, 0x0004e000, 0x00049000,
+      0x0004c800, 0x0004e800, 0x00048000, 0x0004f800,
+      0x0004a000, 0x0004a800, 0x0004c000, 0x0004f000,
+      0x0004d000, 0x0004b800, 0x0004b000, 0x00049800,
+      0x00050800, 0x00055800, 0x00056000, 0x00051000,
+      0x00054800, 0x00056800, 0x00050000, 0x00057800,
+      0x00052000, 0x00052800, 0x00054000, 0x00057000,
+      0x00055000, 0x00053800, 0x00053000, 0x00051800,
+      0x00030800, 0x00035800, 0x00036000, 0x00031000,
+      0x00034800, 0x00036800, 0x00030000, 0x00037800,
+      0x00032000, 0x00032800, 0x00034000, 0x00037000,
+      0x00035000, 0x00033800, 0x00033000, 0x00031800,
+      0x00018800, 0x0001d800, 0x0001e000, 0x00019000,
+      0x0001c800, 0x0001e800, 0x00018000, 0x0001f800,
+      0x0001a000, 0x0001a800, 0x0001c000, 0x0001f000,
+      0x0001d000, 0x0001b800, 0x0001b000, 0x00019800,
+    }, { /* 1 */
+      0x01c00000, 0x01900000, 0x01a80000, 0x01800000,
+      0x01a00000, 0x01c80000, 0x01f80000, 0x01d00000,
+      0x01980000, 0x01b80000, 0x01e00000, 0x01e80000,
+      0x01b00000, 0x01f00000, 0x01880000, 0x01d80000,
+      0x03400000, 0x03100000, 0x03280000, 0x03000000,
+      0x03200000, 0x03480000, 0x03780000, 0x03500000,
+      0x03180000, 0x03380000, 0x03600000, 0x03680000,
+      0x03300000, 0x03700000, 0x03080000, 0x03580000,
+      0x00400000, 0x00100000, 0x00280000, 0x00000000,
+      0x00200000, 0x00480000, 0x00780000, 0x00500000,
+      0x00180000, 0x00380000, 0x00600000, 0x00680000,
+      0x00300000, 0x00700000, 0x00080000, 0x00580000,
+      0x00c00000, 0x00900000, 0x00a80000, 0x00800000,
+      0x00a00000, 0x00c80000, 0x00f80000, 0x00d00000,
+      0x00980000, 0x00b80000, 0x00e00000, 0x00e80000,
+      0x00b00000, 0x00f00000, 0x00880000, 0x00d80000,
+      0x02c00000, 0x02900000, 0x02a80000, 0x02800000,
+      0x02a00000, 0x02c80000, 0x02f80000, 0x02d00000,
+      0x02980000, 0x02b80000, 0x02e00000, 0x02e80000,
+      0x02b00000, 0x02f00000, 0x02880000, 0x02d80000,
+      0x06c00000, 0x06900000, 0x06a80000, 0x06800000,
+      0x06a00000, 0x06c80000, 0x06f80000, 0x06d00000,
+      0x06980000, 0x06b80000, 0x06e00000, 0x06e80000,
+      0x06b00000, 0x06f00000, 0x06880000, 0x06d80000,
+      0x05400000, 0x05100000, 0x05280000, 0x05000000,
+      0x05200000, 0x05480000, 0x05780000, 0x05500000,
+      0x05180000, 0x05380000, 0x05600000, 0x05680000,
+      0x05300000, 0x05700000, 0x05080000, 0x05580000,
+      0x04400000, 0x04100000, 0x04280000, 0x04000000,
+      0x04200000, 0x04480000, 0x04780000, 0x04500000,
+      0x04180000, 0x04380000, 0x04600000, 0x04680000,
+      0x04300000, 0x04700000, 0x04080000, 0x04580000,
+      0x05c00000, 0x05900000, 0x05a80000, 0x05800000,
+      0x05a00000, 0x05c80000, 0x05f80000, 0x05d00000,
+      0x05980000, 0x05b80000, 0x05e00000, 0x05e80000,
+      0x05b00000, 0x05f00000, 0x05880000, 0x05d80000,
+      0x01400000, 0x01100000, 0x01280000, 0x01000000,
+      0x01200000, 0x01480000, 0x01780000, 0x01500000,
+      0x01180000, 0x01380000, 0x01600000, 0x01680000,
+      0x01300000, 0x01700000, 0x01080000, 0x01580000,
+      0x04c00000, 0x04900000, 0x04a80000, 0x04800000,
+      0x04a00000, 0x04c80000, 0x04f80000, 0x04d00000,
+      0x04980000, 0x04b80000, 0x04e00000, 0x04e80000,
+      0x04b00000, 0x04f00000, 0x04880000, 0x04d80000,
+      0x03c00000, 0x03900000, 0x03a80000, 0x03800000,
+      0x03a00000, 0x03c80000, 0x03f80000, 0x03d00000,
+      0x03980000, 0x03b80000, 0x03e00000, 0x03e80000,
+      0x03b00000, 0x03f00000, 0x03880000, 0x03d80000,
+      0x07400000, 0x07100000, 0x07280000, 0x07000000,
+      0x07200000, 0x07480000, 0x07780000, 0x07500000,
+      0x07180000, 0x07380000, 0x07600000, 0x07680000,
+      0x07300000, 0x07700000, 0x07080000, 0x07580000,
+      0x07c00000, 0x07900000, 0x07a80000, 0x07800000,
+      0x07a00000, 0x07c80000, 0x07f80000, 0x07d00000,
+      0x07980000, 0x07b80000, 0x07e00000, 0x07e80000,
+      0x07b00000, 0x07f00000, 0x07880000, 0x07d80000,
+      0x06400000, 0x06100000, 0x06280000, 0x06000000,
+      0x06200000, 0x06480000, 0x06780000, 0x06500000,
+      0x06180000, 0x06380000, 0x06600000, 0x06680000,
+      0x06300000, 0x06700000, 0x06080000, 0x06580000,
+      0x02400000, 0x02100000, 0x02280000, 0x02000000,
+      0x02200000, 0x02480000, 0x02780000, 0x02500000,
+      0x02180000, 0x02380000, 0x02600000, 0x02680000,
+      0x02300000, 0x02700000, 0x02080000, 0x02580000,
+    }, { /* 2 */
+      0x40000006, 0x68000006, 0x58000006, 0x00000006,
+      0x20000006, 0x28000006, 0x08000006, 0x10000006,
+      0x48000006, 0x18000006, 0x60000006, 0x70000006,
+      0x30000006, 0x78000006, 0x50000006, 0x38000006,
+      0xc0000004, 0xe8000004, 0xd8000004, 0x80000004,
+      0xa0000004, 0xa8000004, 0x88000004, 0x90000004,
+      0xc8000004, 0x98000004, 0xe0000004, 0xf0000004,
+      0xb0000004, 0xf8000004, 0xd0000004, 0xb8000004,
+      0xc0000005, 0xe8000005, 0xd8000005, 0x80000005,
+      0xa0000005, 0xa8000005, 0x88000005, 0x90000005,
+      0xc8000005, 0x98000005, 0xe0000005, 0xf0000005,
+      0xb0000005, 0xf8000005, 0xd0000005, 0xb8000005,
+      0xc0000000, 0xe8000000, 0xd8000000, 0x80000000,
+      0xa0000000, 0xa8000000, 0x88000000, 0x90000000,
+      0xc8000000, 0x98000000, 0xe0000000, 0xf0000000,
+      0xb0000000, 0xf8000000, 0xd0000000, 0xb8000000,
+      0x40000004, 0x68000004, 0x58000004, 0x00000004,
+      0x20000004, 0x28000004, 0x08000004, 0x10000004,
+      0x48000004, 0x18000004, 0x60000004, 0x70000004,
+      0x30000004, 0x78000004, 0x50000004, 0x38000004,
+      0x40000007, 0x68000007, 0x58000007, 0x00000007,
+      0x20000007, 0x28000007, 0x08000007, 0x10000007,
+      0x48000007, 0x18000007, 0x60000007, 0x70000007,
+      0x30000007, 0x78000007, 0x50000007, 0x38000007,
+      0x40000001, 0x68000001, 0x58000001, 0x00000001,
+      0x20000001, 0x28000001, 0x08000001, 0x10000001,
+      0x48000001, 0x18000001, 0x60000001, 0x70000001,
+      0x30000001, 0x78000001, 0x50000001, 0x38000001,
+      0x40000002, 0x68000002, 0x58000002, 0x00000002,
+      0x20000002, 0x28000002, 0x08000002, 0x10000002,
+      0x48000002, 0x18000002, 0x60000002, 0x70000002,
+      0x30000002, 0x78000002, 0x50000002, 0x38000002,
+      0xc0000003, 0xe8000003, 0xd8000003, 0x80000003,
+      0xa0000003, 0xa8000003, 0x88000003, 0x90000003,
+      0xc8000003, 0x98000003, 0xe0000003, 0xf0000003,
+      0xb0000003, 0xf8000003, 0xd0000003, 0xb8000003,
+      0xc0000001, 0xe8000001, 0xd8000001, 0x80000001,
+      0xa0000001, 0xa8000001, 0x88000001, 0x90000001,
+      0xc8000001, 0x98000001, 0xe0000001, 0xf0000001,
+      0xb0000001, 0xf8000001, 0xd0000001, 0xb8000001,
+      0x40000003, 0x68000003, 0x58000003, 0x00000003,
+      0x20000003, 0x28000003, 0x08000003, 0x10000003,
+      0x48000003, 0x18000003, 0x60000003, 0x70000003,
+      0x30000003, 0x78000003, 0x50000003, 0x38000003,
+      0xc0000002, 0xe8000002, 0xd8000002, 0x80000002,
+      0xa0000002, 0xa8000002, 0x88000002, 0x90000002,
+      0xc8000002, 0x98000002, 0xe0000002, 0xf0000002,
+      0xb0000002, 0xf8000002, 0xd0000002, 0xb8000002,
+      0x40000005, 0x68000005, 0x58000005, 0x00000005,
+      0x20000005, 0x28000005, 0x08000005, 0x10000005,
+      0x48000005, 0x18000005, 0x60000005, 0x70000005,
+      0x30000005, 0x78000005, 0x50000005, 0x38000005,
+      0x40000000, 0x68000000, 0x58000000, 0x00000000,
+      0x20000000, 0x28000000, 0x08000000, 0x10000000,
+      0x48000000, 0x18000000, 0x60000000, 0x70000000,
+      0x30000000, 0x78000000, 0x50000000, 0x38000000,
+      0xc0000007, 0xe8000007, 0xd8000007, 0x80000007,
+      0xa0000007, 0xa8000007, 0x88000007, 0x90000007,
+      0xc8000007, 0x98000007, 0xe0000007, 0xf0000007,
+      0xb0000007, 0xf8000007, 0xd0000007, 0xb8000007,
+      0xc0000006, 0xe8000006, 0xd8000006, 0x80000006,
+      0xa0000006, 0xa8000006, 0x88000006, 0x90000006,
+      0xc8000006, 0x98000006, 0xe0000006, 0xf0000006,
+      0xb0000006, 0xf8000006, 0xd0000006, 0xb8000006,
+    }, { /* 3 */
+      0x000003d0, 0x000003c8, 0x000003b0, 0x000003c0,
+      0x000003e8, 0x000003f0, 0x00000390, 0x00000380,
+      0x000003f8, 0x00000398, 0x000003a8, 0x000003d8,
+      0x000003a0, 0x00000388, 0x000003e0, 0x000003b8,
+      0x00000250, 0x00000248, 0x00000230, 0x00000240,
+      0x00000268, 0x00000270, 0x00000210, 0x00000200,
+      0x00000278, 0x00000218, 0x00000228, 0x00000258,
+      0x00000220, 0x00000208, 0x00000260, 0x00000238,
+      0x00000050, 0x00000048, 0x00000030, 0x00000040,
+      0x00000068, 0x00000070, 0x00000010, 0x00000000,
+      0x00000078, 0x00000018, 0x00000028, 0x00000058,
+      0x00000020, 0x00000008, 0x00000060, 0x00000038,
+      0x000002d0, 0x000002c8, 0x000002b0, 0x000002c0,
+      0x000002e8, 0x000002f0, 0x00000290, 0x00000280,
+      0x000002f8, 0x00000298, 0x000002a8, 0x000002d8,
+      0x000002a0, 0x00000288, 0x000002e0, 0x000002b8,
+      0x00000550, 0x00000548, 0x00000530, 0x00000540,
+      0x00000568, 0x00000570, 0x00000510, 0x00000500,
+      0x00000578, 0x00000518, 0x00000528, 0x00000558,
+      0x00000520, 0x00000508, 0x00000560, 0x00000538,
+      0x00000150, 0x00000148, 0x00000130, 0x00000140,
+      0x00000168, 0x00000170, 0x00000110, 0x00000100,
+      0x00000178, 0x00000118, 0x00000128, 0x00000158,
+      0x00000120, 0x00000108, 0x00000160, 0x00000138,
+      0x000007d0, 0x000007c8, 0x000007b0, 0x000007c0,
+      0x000007e8, 0x000007f0, 0x00000790, 0x00000780,
+      0x000007f8, 0x00000798, 0x000007a8, 0x000007d8,
+      0x000007a0, 0x00000788, 0x000007e0, 0x000007b8,
+      0x00000750, 0x00000748, 0x00000730, 0x00000740,
+      0x00000768, 0x00000770, 0x00000710, 0x00000700,
+      0x00000778, 0x00000718, 0x00000728, 0x00000758,
+      0x00000720, 0x00000708, 0x00000760, 0x00000738,
+      0x00000650, 0x00000648, 0x00000630, 0x00000640,
+      0x00000668, 0x00000670, 0x00000610, 0x00000600,
+      0x00000678, 0x00000618, 0x00000628, 0x00000658,
+      0x00000620, 0x00000608, 0x00000660, 0x00000638,
+      0x00000350, 0x00000348, 0x00000330, 0x00000340,
+      0x00000368, 0x00000370, 0x00000310, 0x00000300,
+      0x00000378, 0x00000318, 0x00000328, 0x00000358,
+      0x00000320, 0x00000308, 0x00000360, 0x00000338,
+      0x000000d0, 0x000000c8, 0x000000b0, 0x000000c0,
+      0x000000e8, 0x000000f0, 0x00000090, 0x00000080,
+      0x000000f8, 0x00000098, 0x000000a8, 0x000000d8,
+      0x000000a0, 0x00000088, 0x000000e0, 0x000000b8,
+      0x000005d0, 0x000005c8, 0x000005b0, 0x000005c0,
+      0x000005e8, 0x000005f0, 0x00000590, 0x00000580,
+      0x000005f8, 0x00000598, 0x000005a8, 0x000005d8,
+      0x000005a0, 0x00000588, 0x000005e0, 0x000005b8,
+      0x000006d0, 0x000006c8, 0x000006b0, 0x000006c0,
+      0x000006e8, 0x000006f0, 0x00000690, 0x00000680,
+      0x000006f8, 0x00000698, 0x000006a8, 0x000006d8,
+      0x000006a0, 0x00000688, 0x000006e0, 0x000006b8,
+      0x000004d0, 0x000004c8, 0x000004b0, 0x000004c0,
+      0x000004e8, 0x000004f0, 0x00000490, 0x00000480,
+      0x000004f8, 0x00000498, 0x000004a8, 0x000004d8,
+      0x000004a0, 0x00000488, 0x000004e0, 0x000004b8,
+      0x000001d0, 0x000001c8, 0x000001b0, 0x000001c0,
+      0x000001e8, 0x000001f0, 0x00000190, 0x00000180,
+      0x000001f8, 0x00000198, 0x000001a8, 0x000001d8,
+      0x000001a0, 0x00000188, 0x000001e0, 0x000001b8,
+      0x00000450, 0x00000448, 0x00000430, 0x00000440,
+      0x00000468, 0x00000470, 0x00000410, 0x00000400,
+      0x00000478, 0x00000418, 0x00000428, 0x00000458,
+      0x00000420, 0x00000408, 0x00000460, 0x00000438,
+    }
+  }
+};
+
+const struct gost28147_param gost28147_param_CryptoPro_D =
+{
+  {
+    { /* 0 */
+      0x0005f800, 0x0005e000, 0x00059000, 0x0005d000,
+      0x0005b000, 0x0005a000, 0x0005a800, 0x00058000,
+      0x0005b800, 0x0005c800, 0x0005f000, 0x0005e800,
+      0x00058800, 0x0005d800, 0x0005c000, 0x00059800,
+      0x00037800, 0x00036000, 0x00031000, 0x00035000,
+      0x00033000, 0x00032000, 0x00032800, 0x00030000,
+      0x00033800, 0x00034800, 0x00037000, 0x00036800,
+      0x00030800, 0x00035800, 0x00034000, 0x00031800,
+      0x0001f800, 0x0001e000, 0x00019000, 0x0001d000,
+      0x0001b000, 0x0001a000, 0x0001a800, 0x00018000,
+      0x0001b800, 0x0001c800, 0x0001f000, 0x0001e800,
+      0x00018800, 0x0001d800, 0x0001c000, 0x00019800,
+      0x00027800, 0x00026000, 0x00021000, 0x00025000,
+      0x00023000, 0x00022000, 0x00022800, 0x00020000,
+      0x00023800, 0x00024800, 0x00027000, 0x00026800,
+      0x00020800, 0x00025800, 0x00024000, 0x00021800,
+      0x00067800, 0x00066000, 0x00061000, 0x00065000,
+      0x00063000, 0x00062000, 0x00062800, 0x00060000,
+      0x00063800, 0x00064800, 0x00067000, 0x00066800,
+      0x00060800, 0x00065800, 0x00064000, 0x00061800,
+      0x0007f800, 0x0007e000, 0x00079000, 0x0007d000,
+      0x0007b000, 0x0007a000, 0x0007a800, 0x00078000,
+      0x0007b800, 0x0007c800, 0x0007f000, 0x0007e800,
+      0x00078800, 0x0007d800, 0x0007c000, 0x00079800,
+      0x00077800, 0x00076000, 0x00071000, 0x00075000,
+      0x00073000, 0x00072000, 0x00072800, 0x00070000,
+      0x00073800, 0x00074800, 0x00077000, 0x00076800,
+      0x00070800, 0x00075800, 0x00074000, 0x00071800,
+      0x00017800, 0x00016000, 0x00011000, 0x00015000,
+      0x00013000, 0x00012000, 0x00012800, 0x00010000,
+      0x00013800, 0x00014800, 0x00017000, 0x00016800,
+      0x00010800, 0x00015800, 0x00014000, 0x00011800,
+      0x0003f800, 0x0003e000, 0x00039000, 0x0003d000,
+      0x0003b000, 0x0003a000, 0x0003a800, 0x00038000,
+      0x0003b800, 0x0003c800, 0x0003f000, 0x0003e800,
+      0x00038800, 0x0003d800, 0x0003c000, 0x00039800,
+      0x0006f800, 0x0006e000, 0x00069000, 0x0006d000,
+      0x0006b000, 0x0006a000, 0x0006a800, 0x00068000,
+      0x0006b800, 0x0006c800, 0x0006f000, 0x0006e800,
+      0x00068800, 0x0006d800, 0x0006c000, 0x00069800,
+      0x00047800, 0x00046000, 0x00041000, 0x00045000,
+      0x00043000, 0x00042000, 0x00042800, 0x00040000,
+      0x00043800, 0x00044800, 0x00047000, 0x00046800,
+      0x00040800, 0x00045800, 0x00044000, 0x00041800,
+      0x00007800, 0x00006000, 0x00001000, 0x00005000,
+      0x00003000, 0x00002000, 0x00002800, 0x00000000,
+      0x00003800, 0x00004800, 0x00007000, 0x00006800,
+      0x00000800, 0x00005800, 0x00004000, 0x00001800,
+      0x0002f800, 0x0002e000, 0x00029000, 0x0002d000,
+      0x0002b000, 0x0002a000, 0x0002a800, 0x00028000,
+      0x0002b800, 0x0002c800, 0x0002f000, 0x0002e800,
+      0x00028800, 0x0002d800, 0x0002c000, 0x00029800,
+      0x00057800, 0x00056000, 0x00051000, 0x00055000,
+      0x00053000, 0x00052000, 0x00052800, 0x00050000,
+      0x00053800, 0x00054800, 0x00057000, 0x00056800,
+      0x00050800, 0x00055800, 0x00054000, 0x00051800,
+      0x0004f800, 0x0004e000, 0x00049000, 0x0004d000,
+      0x0004b000, 0x0004a000, 0x0004a800, 0x00048000,
+      0x0004b800, 0x0004c800, 0x0004f000, 0x0004e800,
+      0x00048800, 0x0004d800, 0x0004c000, 0x00049800,
+      0x0000f800, 0x0000e000, 0x00009000, 0x0000d000,
+      0x0000b000, 0x0000a000, 0x0000a800, 0x00008000,
+      0x0000b800, 0x0000c800, 0x0000f000, 0x0000e800,
+      0x00008800, 0x0000d800, 0x0000c000, 0x00009800,
+    }, { /* 1 */
+      0x00880000, 0x00e00000, 0x00d80000, 0x00800000,
+      0x00f80000, 0x00f00000, 0x00b00000, 0x00a80000,
+      0x00d00000, 0x00e80000, 0x00a00000, 0x00c00000,
+      0x00c80000, 0x00980000, 0x00b80000, 0x00900000,
+      0x02880000, 0x02e00000, 0x02d80000, 0x02800000,
+      0x02f80000, 0x02f00000, 0x02b00000, 0x02a80000,
+      0x02d00000, 0x02e80000, 0x02a00000, 0x02c00000,
+      0x02c80000, 0x02980000, 0x02b80000, 0x02900000,
+      0x07080000, 0x07600000, 0x07580000, 0x07000000,
+      0x07780000, 0x07700000, 0x07300000, 0x07280000,
+      0x07500000, 0x07680000, 0x07200000, 0x07400000,
+      0x07480000, 0x07180000, 0x07380000, 0x07100000,
+      0x06080000, 0x06600000, 0x06580000, 0x06000000,
+      0x06780000, 0x06700000, 0x06300000, 0x06280000,
+      0x06500000, 0x06680000, 0x06200000, 0x06400000,
+      0x06480000, 0x06180000, 0x06380000, 0x06100000,
+      0x05080000, 0x05600000, 0x05580000, 0x05000000,
+      0x05780000, 0x05700000, 0x05300000, 0x05280000,
+      0x05500000, 0x05680000, 0x05200000, 0x05400000,
+      0x05480000, 0x05180000, 0x05380000, 0x05100000,
+      0x03880000, 0x03e00000, 0x03d80000, 0x03800000,
+      0x03f80000, 0x03f00000, 0x03b00000, 0x03a80000,
+      0x03d00000, 0x03e80000, 0x03a00000, 0x03c00000,
+      0x03c80000, 0x03980000, 0x03b80000, 0x03900000,
+      0x00080000, 0x00600000, 0x00580000, 0x00000000,
+      0x00780000, 0x00700000, 0x00300000, 0x00280000,
+      0x00500000, 0x00680000, 0x00200000, 0x00400000,
+      0x00480000, 0x00180000, 0x00380000, 0x00100000,
+      0x06880000, 0x06e00000, 0x06d80000, 0x06800000,
+      0x06f80000, 0x06f00000, 0x06b00000, 0x06a80000,
+      0x06d00000, 0x06e80000, 0x06a00000, 0x06c00000,
+      0x06c80000, 0x06980000, 0x06b80000, 0x06900000,
+      0x03080000, 0x03600000, 0x03580000, 0x03000000,
+      0x03780000, 0x03700000, 0x03300000, 0x03280000,
+      0x03500000, 0x03680000, 0x03200000, 0x03400000,
+      0x03480000, 0x03180000, 0x03380000, 0x03100000,
+      0x01080000, 0x01600000, 0x01580000, 0x01000000,
+      0x01780000, 0x01700000, 0x01300000, 0x01280000,
+      0x01500000, 0x01680000, 0x01200000, 0x01400000,
+      0x01480000, 0x01180000, 0x01380000, 0x01100000,
+      0x05880000, 0x05e00000, 0x05d80000, 0x05800000,
+      0x05f80000, 0x05f00000, 0x05b00000, 0x05a80000,
+      0x05d00000, 0x05e80000, 0x05a00000, 0x05c00000,
+      0x05c80000, 0x05980000, 0x05b80000, 0x05900000,
+      0x02080000, 0x02600000, 0x02580000, 0x02000000,
+      0x02780000, 0x02700000, 0x02300000, 0x02280000,
+      0x02500000, 0x02680000, 0x02200000, 0x02400000,
+      0x02480000, 0x02180000, 0x02380000, 0x02100000,
+      0x04880000, 0x04e00000, 0x04d80000, 0x04800000,
+      0x04f80000, 0x04f00000, 0x04b00000, 0x04a80000,
+      0x04d00000, 0x04e80000, 0x04a00000, 0x04c00000,
+      0x04c80000, 0x04980000, 0x04b80000, 0x04900000,
+      0x01880000, 0x01e00000, 0x01d80000, 0x01800000,
+      0x01f80000, 0x01f00000, 0x01b00000, 0x01a80000,
+      0x01d00000, 0x01e80000, 0x01a00000, 0x01c00000,
+      0x01c80000, 0x01980000, 0x01b80000, 0x01900000,
+      0x07880000, 0x07e00000, 0x07d80000, 0x07800000,
+      0x07f80000, 0x07f00000, 0x07b00000, 0x07a80000,
+      0x07d00000, 0x07e80000, 0x07a00000, 0x07c00000,
+      0x07c80000, 0x07980000, 0x07b80000, 0x07900000,
+      0x04080000, 0x04600000, 0x04580000, 0x04000000,
+      0x04780000, 0x04700000, 0x04300000, 0x04280000,
+      0x04500000, 0x04680000, 0x04200000, 0x04400000,
+      0x04480000, 0x04180000, 0x04380000, 0x04100000,
+    }, { /* 2 */
+      0x00000004, 0x60000004, 0x40000004, 0x48000004,
+      0x68000004, 0x10000004, 0x50000004, 0x58000004,
+      0x38000004, 0x18000004, 0x30000004, 0x28000004,
+      0x20000004, 0x70000004, 0x78000004, 0x08000004,
+      0x00000000, 0x60000000, 0x40000000, 0x48000000,
+      0x68000000, 0x10000000, 0x50000000, 0x58000000,
+      0x38000000, 0x18000000, 0x30000000, 0x28000000,
+      0x20000000, 0x70000000, 0x78000000, 0x08000000,
+      0x80000007, 0xe0000007, 0xc0000007, 0xc8000007,
+      0xe8000007, 0x90000007, 0xd0000007, 0xd8000007,
+      0xb8000007, 0x98000007, 0xb0000007, 0xa8000007,
+      0xa0000007, 0xf0000007, 0xf8000007, 0x88000007,
+      0x80000001, 0xe0000001, 0xc0000001, 0xc8000001,
+      0xe8000001, 0x90000001, 0xd0000001, 0xd8000001,
+      0xb8000001, 0x98000001, 0xb0000001, 0xa8000001,
+      0xa0000001, 0xf0000001, 0xf8000001, 0x88000001,
+      0x00000001, 0x60000001, 0x40000001, 0x48000001,
+      0x68000001, 0x10000001, 0x50000001, 0x58000001,
+      0x38000001, 0x18000001, 0x30000001, 0x28000001,
+      0x20000001, 0x70000001, 0x78000001, 0x08000001,
+      0x80000002, 0xe0000002, 0xc0000002, 0xc8000002,
+      0xe8000002, 0x90000002, 0xd0000002, 0xd8000002,
+      0xb8000002, 0x98000002, 0xb0000002, 0xa8000002,
+      0xa0000002, 0xf0000002, 0xf8000002, 0x88000002,
+      0x00000007, 0x60000007, 0x40000007, 0x48000007,
+      0x68000007, 0x10000007, 0x50000007, 0x58000007,
+      0x38000007, 0x18000007, 0x30000007, 0x28000007,
+      0x20000007, 0x70000007, 0x78000007, 0x08000007,
+      0x80000005, 0xe0000005, 0xc0000005, 0xc8000005,
+      0xe8000005, 0x90000005, 0xd0000005, 0xd8000005,
+      0xb8000005, 0x98000005, 0xb0000005, 0xa8000005,
+      0xa0000005, 0xf0000005, 0xf8000005, 0x88000005,
+      0x80000000, 0xe0000000, 0xc0000000, 0xc8000000,
+      0xe8000000, 0x90000000, 0xd0000000, 0xd8000000,
+      0xb8000000, 0x98000000, 0xb0000000, 0xa8000000,
+      0xa0000000, 0xf0000000, 0xf8000000, 0x88000000,
+      0x00000005, 0x60000005, 0x40000005, 0x48000005,
+      0x68000005, 0x10000005, 0x50000005, 0x58000005,
+      0x38000005, 0x18000005, 0x30000005, 0x28000005,
+      0x20000005, 0x70000005, 0x78000005, 0x08000005,
+      0x00000002, 0x60000002, 0x40000002, 0x48000002,
+      0x68000002, 0x10000002, 0x50000002, 0x58000002,
+      0x38000002, 0x18000002, 0x30000002, 0x28000002,
+      0x20000002, 0x70000002, 0x78000002, 0x08000002,
+      0x80000003, 0xe0000003, 0xc0000003, 0xc8000003,
+      0xe8000003, 0x90000003, 0xd0000003, 0xd8000003,
+      0xb8000003, 0x98000003, 0xb0000003, 0xa8000003,
+      0xa0000003, 0xf0000003, 0xf8000003, 0x88000003,
+      0x00000006, 0x60000006, 0x40000006, 0x48000006,
+      0x68000006, 0x10000006, 0x50000006, 0x58000006,
+      0x38000006, 0x18000006, 0x30000006, 0x28000006,
+      0x20000006, 0x70000006, 0x78000006, 0x08000006,
+      0x80000004, 0xe0000004, 0xc0000004, 0xc8000004,
+      0xe8000004, 0x90000004, 0xd0000004, 0xd8000004,
+      0xb8000004, 0x98000004, 0xb0000004, 0xa8000004,
+      0xa0000004, 0xf0000004, 0xf8000004, 0x88000004,
+      0x80000006, 0xe0000006, 0xc0000006, 0xc8000006,
+      0xe8000006, 0x90000006, 0xd0000006, 0xd8000006,
+      0xb8000006, 0x98000006, 0xb0000006, 0xa8000006,
+      0xa0000006, 0xf0000006, 0xf8000006, 0x88000006,
+      0x00000003, 0x60000003, 0x40000003, 0x48000003,
+      0x68000003, 0x10000003, 0x50000003, 0x58000003,
+      0x38000003, 0x18000003, 0x30000003, 0x28000003,
+      0x20000003, 0x70000003, 0x78000003, 0x08000003,
+    }, { /* 3 */
+      0x00000098, 0x00000080, 0x000000b0, 0x000000f8,
+      0x00000088, 0x000000f0, 0x000000c8, 0x00000090,
+      0x000000e8, 0x000000c0, 0x000000e0, 0x000000a0,
+      0x000000d8, 0x000000d0, 0x000000a8, 0x000000b8,
+      0x00000518, 0x00000500, 0x00000530, 0x00000578,
+      0x00000508, 0x00000570, 0x00000548, 0x00000510,
+      0x00000568, 0x00000540, 0x00000560, 0x00000520,
+      0x00000558, 0x00000550, 0x00000528, 0x00000538,
+      0x00000318, 0x00000300, 0x00000330, 0x00000378,
+      0x00000308, 0x00000370, 0x00000348, 0x00000310,
+      0x00000368, 0x00000340, 0x00000360, 0x00000320,
+      0x00000358, 0x00000350, 0x00000328, 0x00000338,
+      0x00000418, 0x00000400, 0x00000430, 0x00000478,
+      0x00000408, 0x00000470, 0x00000448, 0x00000410,
+      0x00000468, 0x00000440, 0x00000460, 0x00000420,
+      0x00000458, 0x00000450, 0x00000428, 0x00000438,
+      0x00000798, 0x00000780, 0x000007b0, 0x000007f8,
+      0x00000788, 0x000007f0, 0x000007c8, 0x00000790,
+      0x000007e8, 0x000007c0, 0x000007e0, 0x000007a0,
+      0x000007d8, 0x000007d0, 0x000007a8, 0x000007b8,
+      0x00000598, 0x00000580, 0x000005b0, 0x000005f8,
+      0x00000588, 0x000005f0, 0x000005c8, 0x00000590,
+      0x000005e8, 0x000005c0, 0x000005e0, 0x000005a0,
+      0x000005d8, 0x000005d0, 0x000005a8, 0x000005b8,
+      0x00000018, 0x00000000, 0x00000030, 0x00000078,
+      0x00000008, 0x00000070, 0x00000048, 0x00000010,
+      0x00000068, 0x00000040, 0x00000060, 0x00000020,
+      0x00000058, 0x00000050, 0x00000028, 0x00000038,
+      0x00000218, 0x00000200, 0x00000230, 0x00000278,
+      0x00000208, 0x00000270, 0x00000248, 0x00000210,
+      0x00000268, 0x00000240, 0x00000260, 0x00000220,
+      0x00000258, 0x00000250, 0x00000228, 0x00000238,
+      0x00000618, 0x00000600, 0x00000630, 0x00000678,
+      0x00000608, 0x00000670, 0x00000648, 0x00000610,
+      0x00000668, 0x00000640, 0x00000660, 0x00000620,
+      0x00000658, 0x00000650, 0x00000628, 0x00000638,
+      0x00000198, 0x00000180, 0x000001b0, 0x000001f8,
+      0x00000188, 0x000001f0, 0x000001c8, 0x00000190,
+      0x000001e8, 0x000001c0, 0x000001e0, 0x000001a0,
+      0x000001d8, 0x000001d0, 0x000001a8, 0x000001b8,
+      0x00000298, 0x00000280, 0x000002b0, 0x000002f8,
+      0x00000288, 0x000002f0, 0x000002c8, 0x00000290,
+      0x000002e8, 0x000002c0, 0x000002e0, 0x000002a0,
+      0x000002d8, 0x000002d0, 0x000002a8, 0x000002b8,
+      0x00000498, 0x00000480, 0x000004b0, 0x000004f8,
+      0x00000488, 0x000004f0, 0x000004c8, 0x00000490,
+      0x000004e8, 0x000004c0, 0x000004e0, 0x000004a0,
+      0x000004d8, 0x000004d0, 0x000004a8, 0x000004b8,
+      0x00000398, 0x00000380, 0x000003b0, 0x000003f8,
+      0x00000388, 0x000003f0, 0x000003c8, 0x00000390,
+      0x000003e8, 0x000003c0, 0x000003e0, 0x000003a0,
+      0x000003d8, 0x000003d0, 0x000003a8, 0x000003b8,
+      0x00000698, 0x00000680, 0x000006b0, 0x000006f8,
+      0x00000688, 0x000006f0, 0x000006c8, 0x00000690,
+      0x000006e8, 0x000006c0, 0x000006e0, 0x000006a0,
+      0x000006d8, 0x000006d0, 0x000006a8, 0x000006b8,
+      0x00000118, 0x00000100, 0x00000130, 0x00000178,
+      0x00000108, 0x00000170, 0x00000148, 0x00000110,
+      0x00000168, 0x00000140, 0x00000160, 0x00000120,
+      0x00000158, 0x00000150, 0x00000128, 0x00000138,
+      0x00000718, 0x00000700, 0x00000730, 0x00000778,
+      0x00000708, 0x00000770, 0x00000748, 0x00000710,
+      0x00000768, 0x00000740, 0x00000760, 0x00000720,
+      0x00000758, 0x00000750, 0x00000728, 0x00000738,
+    }
+  }
+};
+
+const struct gost28147_param gost28147_param_TC26_Z =
+{
+  {
+    { /* 0 */
+      0x00036000, 0x00032000, 0x00033000, 0x00031000,
+      0x00035000, 0x00032800, 0x00035800, 0x00034800,
+      0x00037000, 0x00034000, 0x00036800, 0x00033800,
+      0x00030000, 0x00031800, 0x00037800, 0x00030800,
+      0x00046000, 0x00042000, 0x00043000, 0x00041000,
+      0x00045000, 0x00042800, 0x00045800, 0x00044800,
+      0x00047000, 0x00044000, 0x00046800, 0x00043800,
+      0x00040000, 0x00041800, 0x00047800, 0x00040800,
+      0x00016000, 0x00012000, 0x00013000, 0x00011000,
+      0x00015000, 0x00012800, 0x00015800, 0x00014800,
+      0x00017000, 0x00014000, 0x00016800, 0x00013800,
+      0x00010000, 0x00011800, 0x00017800, 0x00010800,
+      0x0001e000, 0x0001a000, 0x0001b000, 0x00019000,
+      0x0001d000, 0x0001a800, 0x0001d800, 0x0001c800,
+      0x0001f000, 0x0001c000, 0x0001e800, 0x0001b800,
+      0x00018000, 0x00019800, 0x0001f800, 0x00018800,
+      0x0004e000, 0x0004a000, 0x0004b000, 0x00049000,
+      0x0004d000, 0x0004a800, 0x0004d800, 0x0004c800,
+      0x0004f000, 0x0004c000, 0x0004e800, 0x0004b800,
+      0x00048000, 0x00049800, 0x0004f800, 0x00048800,
+      0x00056000, 0x00052000, 0x00053000, 0x00051000,
+      0x00055000, 0x00052800, 0x00055800, 0x00054800,
+      0x00057000, 0x00054000, 0x00056800, 0x00053800,
+      0x00050000, 0x00051800, 0x00057800, 0x00050800,
+      0x0002e000, 0x0002a000, 0x0002b000, 0x00029000,
+      0x0002d000, 0x0002a800, 0x0002d800, 0x0002c800,
+      0x0002f000, 0x0002c000, 0x0002e800, 0x0002b800,
+      0x00028000, 0x00029800, 0x0002f800, 0x00028800,
+      0x00066000, 0x00062000, 0x00063000, 0x00061000,
+      0x00065000, 0x00062800, 0x00065800, 0x00064800,
+      0x00067000, 0x00064000, 0x00066800, 0x00063800,
+      0x00060000, 0x00061800, 0x00067800, 0x00060800,
+      0x0000e000, 0x0000a000, 0x0000b000, 0x00009000,
+      0x0000d000, 0x0000a800, 0x0000d800, 0x0000c800,
+      0x0000f000, 0x0000c000, 0x0000e800, 0x0000b800,
+      0x00008000, 0x00009800, 0x0000f800, 0x00008800,
+      0x00076000, 0x00072000, 0x00073000, 0x00071000,
+      0x00075000, 0x00072800, 0x00075800, 0x00074800,
+      0x00077000, 0x00074000, 0x00076800, 0x00073800,
+      0x00070000, 0x00071800, 0x00077800, 0x00070800,
+      0x00026000, 0x00022000, 0x00023000, 0x00021000,
+      0x00025000, 0x00022800, 0x00025800, 0x00024800,
+      0x00027000, 0x00024000, 0x00026800, 0x00023800,
+      0x00020000, 0x00021800, 0x00027800, 0x00020800,
+      0x0003e000, 0x0003a000, 0x0003b000, 0x00039000,
+      0x0003d000, 0x0003a800, 0x0003d800, 0x0003c800,
+      0x0003f000, 0x0003c000, 0x0003e800, 0x0003b800,
+      0x00038000, 0x00039800, 0x0003f800, 0x00038800,
+      0x0005e000, 0x0005a000, 0x0005b000, 0x00059000,
+      0x0005d000, 0x0005a800, 0x0005d800, 0x0005c800,
+      0x0005f000, 0x0005c000, 0x0005e800, 0x0005b800,
+      0x00058000, 0x00059800, 0x0005f800, 0x00058800,
+      0x0006e000, 0x0006a000, 0x0006b000, 0x00069000,
+      0x0006d000, 0x0006a800, 0x0006d800, 0x0006c800,
+      0x0006f000, 0x0006c000, 0x0006e800, 0x0006b800,
+      0x00068000, 0x00069800, 0x0006f800, 0x00068800,
+      0x00006000, 0x00002000, 0x00003000, 0x00001000,
+      0x00005000, 0x00002800, 0x00005800, 0x00004800,
+      0x00007000, 0x00004000, 0x00006800, 0x00003800,
+      0x00000000, 0x00001800, 0x00007800, 0x00000800,
+      0x0007e000, 0x0007a000, 0x0007b000, 0x00079000,
+      0x0007d000, 0x0007a800, 0x0007d800, 0x0007c800,
+      0x0007f000, 0x0007c000, 0x0007e800, 0x0007b800,
+      0x00078000, 0x00079800, 0x0007f800, 0x00078800,
+    }, { /* 1 */
+      0x06580000, 0x06180000, 0x06280000, 0x06400000,
+      0x06100000, 0x06780000, 0x06500000, 0x06680000,
+      0x06700000, 0x06080000, 0x06380000, 0x06200000,
+      0x06600000, 0x06480000, 0x06300000, 0x06000000,
+      0x04580000, 0x04180000, 0x04280000, 0x04400000,
+      0x04100000, 0x04780000, 0x04500000, 0x04680000,
+      0x04700000, 0x04080000, 0x04380000, 0x04200000,
+      0x04600000, 0x04480000, 0x04300000, 0x04000000,
+      0x01580000, 0x01180000, 0x01280000, 0x01400000,
+      0x01100000, 0x01780000, 0x01500000, 0x01680000,
+      0x01700000, 0x01080000, 0x01380000, 0x01200000,
+      0x01600000, 0x01480000, 0x01300000, 0x01000000,
+      0x00d80000, 0x00980000, 0x00a80000, 0x00c00000,
+      0x00900000, 0x00f80000, 0x00d00000, 0x00e80000,
+      0x00f00000, 0x00880000, 0x00b80000, 0x00a00000,
+      0x00e00000, 0x00c80000, 0x00b00000, 0x00800000,
+      0x06d80000, 0x06980000, 0x06a80000, 0x06c00000,
+      0x06900000, 0x06f80000, 0x06d00000, 0x06e80000,
+      0x06f00000, 0x06880000, 0x06b80000, 0x06a00000,
+      0x06e00000, 0x06c80000, 0x06b00000, 0x06800000,
+      0x02580000, 0x02180000, 0x02280000, 0x02400000,
+      0x02100000, 0x02780000, 0x02500000, 0x02680000,
+      0x02700000, 0x02080000, 0x02380000, 0x02200000,
+      0x02600000, 0x02480000, 0x02300000, 0x02000000,
+      0x07d80000, 0x07980000, 0x07a80000, 0x07c00000,
+      0x07900000, 0x07f80000, 0x07d00000, 0x07e80000,
+      0x07f00000, 0x07880000, 0x07b80000, 0x07a00000,
+      0x07e00000, 0x07c80000, 0x07b00000, 0x07800000,
+      0x03580000, 0x03180000, 0x03280000, 0x03400000,
+      0x03100000, 0x03780000, 0x03500000, 0x03680000,
+      0x03700000, 0x03080000, 0x03380000, 0x03200000,
+      0x03600000, 0x03480000, 0x03300000, 0x03000000,
+      0x03d80000, 0x03980000, 0x03a80000, 0x03c00000,
+      0x03900000, 0x03f80000, 0x03d00000, 0x03e80000,
+      0x03f00000, 0x03880000, 0x03b80000, 0x03a00000,
+      0x03e00000, 0x03c80000, 0x03b00000, 0x03800000,
+      0x00580000, 0x00180000, 0x00280000, 0x00400000,
+      0x00100000, 0x00780000, 0x00500000, 0x00680000,
+      0x00700000, 0x00080000, 0x00380000, 0x00200000,
+      0x00600000, 0x00480000, 0x00300000, 0x00000000,
+      0x05580000, 0x05180000, 0x05280000, 0x05400000,
+      0x05100000, 0x05780000, 0x05500000, 0x05680000,
+      0x05700000, 0x05080000, 0x05380000, 0x05200000,
+      0x05600000, 0x05480000, 0x05300000, 0x05000000,
+      0x02d80000, 0x02980000, 0x02a80000, 0x02c00000,
+      0x02900000, 0x02f80000, 0x02d00000, 0x02e80000,
+      0x02f00000, 0x02880000, 0x02b80000, 0x02a00000,
+      0x02e00000, 0x02c80000, 0x02b00000, 0x02800000,
+      0x01d80000, 0x01980000, 0x01a80000, 0x01c00000,
+      0x01900000, 0x01f80000, 0x01d00000, 0x01e80000,
+      0x01f00000, 0x01880000, 0x01b80000, 0x01a00000,
+      0x01e00000, 0x01c80000, 0x01b00000, 0x01800000,
+      0x07580000, 0x07180000, 0x07280000, 0x07400000,
+      0x07100000, 0x07780000, 0x07500000, 0x07680000,
+      0x07700000, 0x07080000, 0x07380000, 0x07200000,
+      0x07600000, 0x07480000, 0x07300000, 0x07000000,
+      0x04d80000, 0x04980000, 0x04a80000, 0x04c00000,
+      0x04900000, 0x04f80000, 0x04d00000, 0x04e80000,
+      0x04f00000, 0x04880000, 0x04b80000, 0x04a00000,
+      0x04e00000, 0x04c80000, 0x04b00000, 0x04800000,
+      0x05d80000, 0x05980000, 0x05a80000, 0x05c00000,
+      0x05900000, 0x05f80000, 0x05d00000, 0x05e80000,
+      0x05f00000, 0x05880000, 0x05b80000, 0x05a00000,
+      0x05e00000, 0x05c80000, 0x05b00000, 0x05800000,
+    }, { /* 2 */
+      0xb8000002, 0xf8000002, 0xa8000002, 0xd0000002,
+      0xc0000002, 0x88000002, 0xb0000002, 0xe8000002,
+      0x80000002, 0xc8000002, 0x98000002, 0xf0000002,
+      0xd8000002, 0xa0000002, 0x90000002, 0xe0000002,
+      0xb8000006, 0xf8000006, 0xa8000006, 0xd0000006,
+      0xc0000006, 0x88000006, 0xb0000006, 0xe8000006,
+      0x80000006, 0xc8000006, 0x98000006, 0xf0000006,
+      0xd8000006, 0xa0000006, 0x90000006, 0xe0000006,
+      0xb8000007, 0xf8000007, 0xa8000007, 0xd0000007,
+      0xc0000007, 0x88000007, 0xb0000007, 0xe8000007,
+      0x80000007, 0xc8000007, 0x98000007, 0xf0000007,
+      0xd8000007, 0xa0000007, 0x90000007, 0xe0000007,
+      0x38000003, 0x78000003, 0x28000003, 0x50000003,
+      0x40000003, 0x08000003, 0x30000003, 0x68000003,
+      0x00000003, 0x48000003, 0x18000003, 0x70000003,
+      0x58000003, 0x20000003, 0x10000003, 0x60000003,
+      0xb8000004, 0xf8000004, 0xa8000004, 0xd0000004,
+      0xc0000004, 0x88000004, 0xb0000004, 0xe8000004,
+      0x80000004, 0xc8000004, 0x98000004, 0xf0000004,
+      0xd8000004, 0xa0000004, 0x90000004, 0xe0000004,
+      0x38000001, 0x78000001, 0x28000001, 0x50000001,
+      0x40000001, 0x08000001, 0x30000001, 0x68000001,
+      0x00000001, 0x48000001, 0x18000001, 0x70000001,
+      0x58000001, 0x20000001, 0x10000001, 0x60000001,
+      0x38000006, 0x78000006, 0x28000006, 0x50000006,
+      0x40000006, 0x08000006, 0x30000006, 0x68000006,
+      0x00000006, 0x48000006, 0x18000006, 0x70000006,
+      0x58000006, 0x20000006, 0x10000006, 0x60000006,
+      0x38000005, 0x78000005, 0x28000005, 0x50000005,
+      0x40000005, 0x08000005, 0x30000005, 0x68000005,
+      0x00000005, 0x48000005, 0x18000005, 0x70000005,
+      0x58000005, 0x20000005, 0x10000005, 0x60000005,
+      0xb8000005, 0xf8000005, 0xa8000005, 0xd0000005,
+      0xc0000005, 0x88000005, 0xb0000005, 0xe8000005,
+      0x80000005, 0xc8000005, 0x98000005, 0xf0000005,
+      0xd8000005, 0xa0000005, 0x90000005, 0xe0000005,
+      0xb8000003, 0xf8000003, 0xa8000003, 0xd0000003,
+      0xc0000003, 0x88000003, 0xb0000003, 0xe8000003,
+      0x80000003, 0xc8000003, 0x98000003, 0xf0000003,
+      0xd8000003, 0xa0000003, 0x90000003, 0xe0000003,
+      0x38000004, 0x78000004, 0x28000004, 0x50000004,
+      0x40000004, 0x08000004, 0x30000004, 0x68000004,
+      0x00000004, 0x48000004, 0x18000004, 0x70000004,
+      0x58000004, 0x20000004, 0x10000004, 0x60000004,
+      0xb8000000, 0xf8000000, 0xa8000000, 0xd0000000,
+      0xc0000000, 0x88000000, 0xb0000000, 0xe8000000,
+      0x80000000, 0xc8000000, 0x98000000, 0xf0000000,
+      0xd8000000, 0xa0000000, 0x90000000, 0xe0000000,
+      0x38000002, 0x78000002, 0x28000002, 0x50000002,
+      0x40000002, 0x08000002, 0x30000002, 0x68000002,
+      0x00000002, 0x48000002, 0x18000002, 0x70000002,
+      0x58000002, 0x20000002, 0x10000002, 0x60000002,
+      0xb8000001, 0xf8000001, 0xa8000001, 0xd0000001,
+      0xc0000001, 0x88000001, 0xb0000001, 0xe8000001,
+      0x80000001, 0xc8000001, 0x98000001, 0xf0000001,
+      0xd8000001, 0xa0000001, 0x90000001, 0xe0000001,
+      0x38000007, 0x78000007, 0x28000007, 0x50000007,
+      0x40000007, 0x08000007, 0x30000007, 0x68000007,
+      0x00000007, 0x48000007, 0x18000007, 0x70000007,
+      0x58000007, 0x20000007, 0x10000007, 0x60000007,
+      0x38000000, 0x78000000, 0x28000000, 0x50000000,
+      0x40000000, 0x08000000, 0x30000000, 0x68000000,
+      0x00000000, 0x48000000, 0x18000000, 0x70000000,
+      0x58000000, 0x20000000, 0x10000000, 0x60000000,
+    }, { /* 3 */
+      0x000000c0, 0x000000f0, 0x00000090, 0x000000a8,
+      0x000000b0, 0x000000c8, 0x00000088, 0x000000e0,
+      0x000000f8, 0x000000a0, 0x000000d8, 0x00000080,
+      0x000000e8, 0x000000d0, 0x00000098, 0x000000b8,
+      0x000003c0, 0x000003f0, 0x00000390, 0x000003a8,
+      0x000003b0, 0x000003c8, 0x00000388, 0x000003e0,
+      0x000003f8, 0x000003a0, 0x000003d8, 0x00000380,
+      0x000003e8, 0x000003d0, 0x00000398, 0x000003b8,
+      0x00000740, 0x00000770, 0x00000710, 0x00000728,
+      0x00000730, 0x00000748, 0x00000708, 0x00000760,
+      0x00000778, 0x00000720, 0x00000758, 0x00000700,
+      0x00000768, 0x00000750, 0x00000718, 0x00000738,
+      0x000006c0, 0x000006f0, 0x00000690, 0x000006a8,
+      0x000006b0, 0x000006c8, 0x00000688, 0x000006e0,
+      0x000006f8, 0x000006a0, 0x000006d8, 0x00000680,
+      0x000006e8, 0x000006d0, 0x00000698, 0x000006b8,
+      0x00000040, 0x00000070, 0x00000010, 0x00000028,
+      0x00000030, 0x00000048, 0x00000008, 0x00000060,
+      0x00000078, 0x00000020, 0x00000058, 0x00000000,
+      0x00000068, 0x00000050, 0x00000018, 0x00000038,
+      0x000002c0, 0x000002f0, 0x00000290, 0x000002a8,
+      0x000002b0, 0x000002c8, 0x00000288, 0x000002e0,
+      0x000002f8, 0x000002a0, 0x000002d8, 0x00000280,
+      0x000002e8, 0x000002d0, 0x00000298, 0x000002b8,
+      0x00000440, 0x00000470, 0x00000410, 0x00000428,
+      0x00000430, 0x00000448, 0x00000408, 0x00000460,
+      0x00000478, 0x00000420, 0x00000458, 0x00000400,
+      0x00000468, 0x00000450, 0x00000418, 0x00000438,
+      0x000001c0, 0x000001f0, 0x00000190, 0x000001a8,
+      0x000001b0, 0x000001c8, 0x00000188, 0x000001e0,
+      0x000001f8, 0x000001a0, 0x000001d8, 0x00000180,
+      0x000001e8, 0x000001d0, 0x00000198, 0x000001b8,
+      0x00000240, 0x00000270, 0x00000210, 0x00000228,
+      0x00000230, 0x00000248, 0x00000208, 0x00000260,
+      0x00000278, 0x00000220, 0x00000258, 0x00000200,
+      0x00000268, 0x00000250, 0x00000218, 0x00000238,
+      0x000007c0, 0x000007f0, 0x00000790, 0x000007a8,
+      0x000007b0, 0x000007c8, 0x00000788, 0x000007e0,
+      0x000007f8, 0x000007a0, 0x000007d8, 0x00000780,
+      0x000007e8, 0x000007d0, 0x00000798, 0x000007b8,
+      0x00000540, 0x00000570, 0x00000510, 0x00000528,
+      0x00000530, 0x00000548, 0x00000508, 0x00000560,
+      0x00000578, 0x00000520, 0x00000558, 0x00000500,
+      0x00000568, 0x00000550, 0x00000518, 0x00000538,
+      0x00000340, 0x00000370, 0x00000310, 0x00000328,
+      0x00000330, 0x00000348, 0x00000308, 0x00000360,
+      0x00000378, 0x00000320, 0x00000358, 0x00000300,
+      0x00000368, 0x00000350, 0x00000318, 0x00000338,
+      0x000004c0, 0x000004f0, 0x00000490, 0x000004a8,
+      0x000004b0, 0x000004c8, 0x00000488, 0x000004e0,
+      0x000004f8, 0x000004a0, 0x000004d8, 0x00000480,
+      0x000004e8, 0x000004d0, 0x00000498, 0x000004b8,
+      0x00000640, 0x00000670, 0x00000610, 0x00000628,
+      0x00000630, 0x00000648, 0x00000608, 0x00000660,
+      0x00000678, 0x00000620, 0x00000658, 0x00000600,
+      0x00000668, 0x00000650, 0x00000618, 0x00000638,
+      0x000005c0, 0x000005f0, 0x00000590, 0x000005a8,
+      0x000005b0, 0x000005c8, 0x00000588, 0x000005e0,
+      0x000005f8, 0x000005a0, 0x000005d8, 0x00000580,
+      0x000005e8, 0x000005d0, 0x00000598, 0x000005b8,
+      0x00000140, 0x00000170, 0x00000110, 0x00000128,
+      0x00000130, 0x00000148, 0x00000108, 0x00000160,
+      0x00000178, 0x00000120, 0x00000158, 0x00000100,
+      0x00000168, 0x00000150, 0x00000118, 0x00000138,
+    }
+  }
+};
+
 /*
  *  A macro that performs a full encryption round of GOST 28147-89.
  */
diff --git a/gost28147.h b/gost28147.h
index 5fff34e859d2..37633d9fd874 100644
--- a/gost28147.h
+++ b/gost28147.h
@@ -40,8 +40,15 @@
 extern "C" {
 #endif
 
+/* S-Boxes &amp; parameters */
 #define gost28147_param_test_3411 nettle_gost28147_param_test_3411
 #define gost28147_param_CryptoPro_3411 nettle_gost28147_param_CryptoPro_3411
+#define gost28147_param_Test_89 nettle_gost28147_param_Test_89
+#define gost28147_param_CryptoPro_A nettle_gost28147_param_CryptoPro_A
+#define gost28147_param_CryptoPro_B nettle_gost28147_param_CryptoPro_B
+#define gost28147_param_CryptoPro_C nettle_gost28147_param_CryptoPro_C
+#define gost28147_param_CryptoPro_D nettle_gost28147_param_CryptoPro_D
+#define gost28147_param_TC26_Z nettle_gost28147_param_TC26_Z
 
 #define gost28147_set_key nettle_gost28147_set_key
 #define gost28147_set_param nettle_gost28147_set_param
@@ -64,6 +71,12 @@ struct gost28147_param
 
 extern const struct gost28147_param gost28147_param_test_3411;
 extern const struct gost28147_param gost28147_param_CryptoPro_3411;
+extern const struct gost28147_param gost28147_param_Test_89;
+extern const struct gost28147_param gost28147_param_CryptoPro_A;
+extern const struct gost28147_param gost28147_param_CryptoPro_B;
+extern const struct gost28147_param gost28147_param_CryptoPro_C;
+extern const struct gost28147_param gost28147_param_CryptoPro_D;
+extern const struct gost28147_param gost28147_param_TC26_Z;
 
 void
 gost28147_set_key(struct gost28147_ctx *ctx, const uint8_t *key);
-- 
2.23.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190916091431</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-09-16 09:14:31-0400</timestampReceived><subject>[PATCH 3/5] Add CFB mode support for GOST 28147-89</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 gost28147.c                |  85 +++++++++++++++++++---
 gost28147.h                |   8 +++
 testsuite/gost28147-test.c | 143 +++++++++++++++++++++++++++++++++++++
 3 files changed, 228 insertions(+), 8 deletions(-)

diff --git a/gost28147.c b/gost28147.c
index 9fe31043a3ff..ac94dfaa2ed8 100644
--- a/gost28147.c
+++ b/gost28147.c
@@ -33,6 +33,7 @@
 #endif
 
 #include &lt;assert.h&gt;
+#include &lt;string.h&gt;
 
 #include "macros.h"
 #include "gost28147.h"
@@ -303,7 +304,8 @@ const struct gost28147_param gost28147_param_test_3411 =
       0x00000600, 0x00000650, 0x00000670, 0x00000638,
       0x00000630, 0x00000640, 0x00000610, 0x00000660,
     }
-  }
+  },
+  0
 };
 
 const struct gost28147_param gost28147_param_CryptoPro_3411 =
@@ -570,7 +572,8 @@ const struct gost28147_param gost28147_param_CryptoPro_3411 =
       0x00000618, 0x00000660, 0x00000640, 0x00000678,
       0x00000630, 0x00000610, 0x00000648, 0x00000658,
     }
-  }
+  },
+  0
 };
 
 const struct gost28147_param gost28147_param_Test_89 =
@@ -837,7 +840,8 @@ const struct gost28147_param gost28147_param_Test_89 =
       0x00000420, 0x00000440, 0x00000470, 0x00000478,
       0x00000408, 0x00000450, 0x00000410, 0x00000468,
     }
-  }
+  },
+  1
 };
 
 const struct gost28147_param gost28147_param_CryptoPro_A =
@@ -1104,7 +1108,8 @@ const struct gost28147_param gost28147_param_CryptoPro_A =
       0x00000240, 0x00000260, 0x00000220, 0x00000228,
       0x00000278, 0x00000218, 0x00000258, 0x00000270,
     }
-  }
+  },
+  1
 };
 
 const struct gost28147_param gost28147_param_CryptoPro_B =
@@ -1371,7 +1376,8 @@ const struct gost28147_param gost28147_param_CryptoPro_B =
       0x00000638, 0x00000620, 0x00000668, 0x00000600,
       0x00000630, 0x00000678, 0x00000640, 0x00000670,
     }
-  }
+  },
+  1
 };
 
 const struct gost28147_param gost28147_param_CryptoPro_C =
@@ -1638,7 +1644,8 @@ const struct gost28147_param gost28147_param_CryptoPro_C =
       0x00000478, 0x00000418, 0x00000428, 0x00000458,
       0x00000420, 0x00000408, 0x00000460, 0x00000438,
     }
-  }
+  },
+  1
 };
 
 const struct gost28147_param gost28147_param_CryptoPro_D =
@@ -1905,7 +1912,8 @@ const struct gost28147_param gost28147_param_CryptoPro_D =
       0x00000768, 0x00000740, 0x00000760, 0x00000720,
       0x00000758, 0x00000750, 0x00000728, 0x00000738,
     }
-  }
+  },
+  1
 };
 
 const struct gost28147_param gost28147_param_TC26_Z =
@@ -2172,7 +2180,8 @@ const struct gost28147_param gost28147_param_TC26_Z =
       0x00000178, 0x00000120, 0x00000158, 0x00000100,
       0x00000168, 0x00000150, 0x00000118, 0x00000138,
     }
-  }
+  },
+  1
 };
 
 /*
@@ -2245,6 +2254,37 @@ void _gost28147_decrypt_block (const uint32_t *key, const uint32_t sbox[4][256],
   *out = l, *(out + 1) = r;
 }
 
+static const uint32_t gost28147_key_mesh_cryptopro_data[GOST28147_KEY_SIZE / 4] = {
+  0x22720069, 0x2304c964,
+  0x96db3a8d, 0xc42ae946,
+  0x94acfe18, 0x1207ed00,
+  0xc2dc86c0, 0x2ba94cef,
+};
+
+static void gost28147_key_mesh_cryptopro(struct gost28147_ctx *ctx)
+{
+  uint32_t newkey[GOST28147_KEY_SIZE/4];
+
+  _gost28147_decrypt_block(ctx-&gt;key, ctx-&gt;sbox,
+			   &amp;gost28147_key_mesh_cryptopro_data[0],
+			   &amp;newkey[0]);
+
+  _gost28147_decrypt_block(ctx-&gt;key, ctx-&gt;sbox,
+			   &amp;gost28147_key_mesh_cryptopro_data[2],
+			   &amp;newkey[2]);
+
+  _gost28147_decrypt_block(ctx-&gt;key, ctx-&gt;sbox,
+			   &amp;gost28147_key_mesh_cryptopro_data[4],
+			   &amp;newkey[4]);
+
+  _gost28147_decrypt_block(ctx-&gt;key, ctx-&gt;sbox,
+			   &amp;gost28147_key_mesh_cryptopro_data[6],
+			   &amp;newkey[6]);
+
+  memcpy(ctx-&gt;key, newkey, sizeof(newkey));
+  ctx-&gt;key_count = 0;
+}
+
 void
 gost28147_set_key(struct gost28147_ctx *ctx, const uint8_t *key)
 {
@@ -2253,6 +2293,7 @@ gost28147_set_key(struct gost28147_ctx *ctx, const uint8_t *key)
   assert(key);
   for (i = 0; i &lt; 8; i++, key += 4)
     ctx-&gt;key[i] = LE_READ_UINT32(key);
+  ctx-&gt;key_count = 0;
   gost28147_set_param(ctx, &amp;gost28147_param_TC26_Z);
 }
 
@@ -2261,6 +2302,7 @@ gost28147_set_param(struct gost28147_ctx *ctx, const struct gost28147_param *par
 {
   assert(param);
   ctx-&gt;sbox = param-&gt;sbox;
+  ctx-&gt;key_meshing = param-&gt;key_meshing;
 }
 
 void
@@ -2302,3 +2344,30 @@ gost28147_decrypt(const struct gost28147_ctx *ctx,
       length -= GOST28147_BLOCK_SIZE;
     }
 }
+
+void
+gost28147_encrypt_for_cfb(struct gost28147_ctx *ctx,
+			  size_t length, uint8_t *dst,
+			  const uint8_t *src)
+{
+  uint32_t block[2];
+
+  assert(!(length % GOST28147_BLOCK_SIZE));
+
+  while (length)
+    {
+      block[0] = LE_READ_UINT32(src); src += 4;
+      block[1] = LE_READ_UINT32(src); src += 4;
+      if (ctx-&gt;key_meshing &amp;&amp; ctx-&gt;key_count == 1024)
+	{
+	  gost28147_key_mesh_cryptopro(ctx);
+	  _gost28147_encrypt_block(ctx-&gt;key, ctx-&gt;sbox, block, block);
+	  ctx-&gt;key_count = 0;
+	}
+      _gost28147_encrypt_block(ctx-&gt;key, ctx-&gt;sbox, block, block);
+      LE_WRITE_UINT32(dst, block[0]); dst += 4;
+      LE_WRITE_UINT32(dst, block[1]); dst += 4;
+      length -= GOST28147_BLOCK_SIZE;
+      ctx-&gt;key_count += GOST28147_BLOCK_SIZE;
+    }
+}
diff --git a/gost28147.h b/gost28147.h
index 37633d9fd874..241c1e136fbc 100644
--- a/gost28147.h
+++ b/gost28147.h
@@ -53,6 +53,7 @@ extern "C" {
 #define gost28147_set_key nettle_gost28147_set_key
 #define gost28147_set_param nettle_gost28147_set_param
 #define gost28147_encrypt nettle_gost28147_encrypt
+#define gost28147_encrypt_for_cfb nettle_gost28147_encrypt_for_cfb
 #define gost28147_decrypt nettle_gost28147_decrypt
 
 #define GOST28147_KEY_SIZE 32
@@ -62,11 +63,14 @@ struct gost28147_ctx
 {
   uint32_t key[GOST28147_KEY_SIZE/4];
   const uint32_t (*sbox)[256];
+  int key_meshing;
+  int key_count; /* Used for key meshing */
 };
 
 struct gost28147_param
 {
   uint32_t sbox[4][256];
+  int key_meshing;
 };
 
 extern const struct gost28147_param gost28147_param_test_3411;
@@ -93,6 +97,10 @@ void
 gost28147_decrypt(const struct gost28147_ctx *ctx,
 		  size_t length, uint8_t *dst,
 		  const uint8_t *src);
+void
+gost28147_encrypt_for_cfb(struct gost28147_ctx *ctx,
+			  size_t length, uint8_t *dst,
+			  const uint8_t *src);
 
 #ifdef __cplusplus
 }
diff --git a/testsuite/gost28147-test.c b/testsuite/gost28147-test.c
index 3f8046e19e3f..939bedee9c66 100644
--- a/testsuite/gost28147-test.c
+++ b/testsuite/gost28147-test.c
@@ -1,5 +1,6 @@
 #include "testutils.h"
 #include "gost28147.h"
+#include "cfb.h"
 
 static void
 test_gost28147(const struct gost28147_param *param,
@@ -49,6 +50,60 @@ test_gost28147(const struct gost28147_param *param,
   free(data);
 }
 
+static void
+test_gost28147_cfb(const struct gost28147_param *param,
+		   const struct tstring *key,
+		   const struct tstring *iv,
+		   const struct tstring *cleartext,
+		   const struct tstring *ciphertext)
+{
+  struct ctx CFB_CTX(struct gost28147_ctx, GOST28147_BLOCK_SIZE) ctx;
+  uint8_t *data = xalloc(cleartext-&gt;length);
+  size_t length;
+
+  ASSERT (cleartext-&gt;length == ciphertext-&gt;length);
+  length = cleartext-&gt;length;
+
+  gost28147_set_key(&amp;ctx.ctx, key-&gt;data);
+  gost28147_set_param(&amp;ctx.ctx, param);
+  CFB_SET_IV(&amp;ctx, iv-&gt;data);
+
+  CFB_ENCRYPT(&amp;ctx, gost28147_encrypt_for_cfb, length,
+	      data, cleartext-&gt;data);
+
+  if (!MEMEQ(length, data, ciphertext-&gt;data))
+    {
+      fprintf(stderr, "Encrypt failed:\nInput:");
+      tstring_print_hex(cleartext);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(ciphertext);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  gost28147_set_key(&amp;ctx.ctx, key-&gt;data);
+  gost28147_set_param(&amp;ctx.ctx, param);
+  CFB_SET_IV(&amp;ctx, iv-&gt;data);
+  CFB_DECRYPT(&amp;ctx, gost28147_encrypt_for_cfb, length,
+	      data, data);
+
+  if (!MEMEQ(length, data, cleartext-&gt;data))
+    {
+      fprintf(stderr, "Decrypt failed:\nInput:");
+      tstring_print_hex(ciphertext);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(cleartext);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  free(data);
+}
+
 void test_main(void)
 {
   /* Examples from GOST R 34.11-94 standard */
@@ -116,4 +171,92 @@ void test_main(void)
       SHEX("ccddeeff8899aabb4455667700112233f3f2f1f0f7f6f5f4fbfaf9f8fffefdfc"),
       SHEX("1032547698badcfe"),
       SHEX("3dcad8c2e501e94e"));
+
+  test_gost28147_cfb(&amp;gost28147_param_CryptoPro_A,
+      SHEX("8d5a2c83a7c70a61 d61b34b51fdf4268 6671a35d874cfd84 993663b61ed60dad"),
+      SHEX("46606f0d8834235a"),
+      SHEX("d2fdf83ac1b43923 2eaacc980a02da33"),
+      SHEX("88b7751674a5ee2d 14fe9167d05ccc40"));
+
+  test_gost28147_cfb(&amp;gost28147_param_CryptoPro_C,
+      SHEX("77c3458ef642e704 8efc08e47096d605 9359026d6f97cae9 cf89444bde6c221d"),
+      SHEX("437c3e8e2f2a0098"),
+      SHEX("079c91be"),
+      SHEX("19358134"));
+
+  test_gost28147_cfb(&amp;gost28147_param_CryptoPro_D,
+      SHEX("389fe837ff9c5d29 fc4855a087eae840 20875bb2011555a7 e32dcb3dd6590473"),
+      SHEX("c5a2d21f2fdfb8eb"),
+      SHEX("2f31d883b420e86e da"),
+      SHEX("6da4ed40088871ad 16"));
+
+  test_gost28147_cfb(&amp;gost28147_param_CryptoPro_B,
+      SHEX("480c741b026b55d5 b66dd71d4048056b 6deb3c290f848023 ee0d4777e3fe61c9"),
+      SHEX("1f3f821e0dd81e22"),
+      SHEX("8c9c4435fbe9a5a3 a0ae285691108e1e d2bb185381270da6 685936c581629a8e"
+	   "7d50f16f976229ec 8051e37d6cc40795 2863dcb4b92db813 b105b5f9eb75374e"
+	   "f7bf51f1988643c4 e43d3ea762ec4159 e0bdfbb6fdece077 13d25990a1b8976b"
+	   "3d8b7dfc9dca8273 32700a7403c60c26 7f56f09db2eb7140 d7c3b1a7c51e2017"
+	   "b3501d8a6e19cbbe 20862bd61cfdb4b7 5d9ab3e37d157a35 019f5d65894b34c6"
+	   "f4813f7830cfe915 909af9deba63d019 14663cb9a4b28494 02cfce20cf76e7c5"
+	   "48f7693a5decaf41 a7126483f5991e9e b2ab861600238ee6 d9800b6dc593e25c"
+	   "8cd85e5aae4a85fd 7601ea30f3783410 7251bc9f76ce1fd4 8f335034c74d7bcf"
+	   "91637d829ea12345 f545ac987a48ff64 d55947de2b3ffaec 50e081608bc3fc80"
+	   "9817c7a3c2573dab 9167f5c4ab92c8d6 3b6b3fff156bcf53 6502f174caa9be24"
+	   "d2f0b726a8d76ded 90367b3e41a97fa3 1bf443c551be2859 e94526493832f8f3"
+	   "926e30ccb0a0f901 14c8bad9f02a29e2 529a76953a1632ec f410ecee47007019"
+	   "e472356644532da2 f3aa7e8a3313cdc8 bf0e409000e442c3 0984e16617a2af03"
+	   "ab6ba1ecfb177281 fe9a9ff4b2331fae 0cd16aae19b8afec e3ea00f8ac87075f"
+	   "6db0ac6b224836bf 2218b0039f6c7045 36f06bc6c2a5722c d8e0273dec560705"
+	   "7d83a1657d415bcd 7724e5aa7647d050 f6e7b559753127ef d8a64e7fb840b1df"
+	   "5314edf1685ffc3f 02db05eb31e42c7f 32b5708e7585a45c 162337f21079cbdc"
+	   "f81c25c2a13d9c33 6cedc3e7f3028782 4efbacb32dfcf80d 1d4a39d4b309bbe9"
+	   "25c7ec6a877284ed 12601964eb162a5b 107627ff7be4aee5 a404027fbb0ab5f4"
+	   "05a5561c53317a93 ba1615ab6260fcde 72366e28af980de6 f4de60a77e060786"
+	   "f394b66d0d93a6bc 607033ac3fa1a84a 2061b6b543a3155a 00be76985772ab7a"
+	   "0e1893823a18786e 717b784f7e8cde7a 62b50a7c451d16d5 c38c9b25b45090cd"
+	   "9693ad0fd443cb49 0ffc5a31f419b7d4 eb4d4058d03bc8e0 4a542fdb22c3297b"
+	   "40906143d37ee230 2b483cce9093b18b 3196656d578b9d4d 53f0831ce5a19d55"
+	   "e3bf7eca1a746614 cc4743d9bbef977d b76efff122f8102d 3fcd4996d90911b8"
+	   "33d0239afa16cb50 2657245c0ebaf03f 372fa3f718574848 95cfef87672ae9b6"
+	   "8a21367fff486c46 3557f2bc48678f63 2378112bc208de51 e88b9229f99a9ead"
+	   "ed0feba2d24092d4 de629576fd6e3cbf c0d70de51ba4c718 e158a456ef2e171b"
+	   "75cbbcf92a9571a7 1d7fe77363056b19 4cf42214c4598866 9286615c6aaeec58"
+	   "ffc9f244d4a2f598 eb5f09bc8abf3cb4 3eb120054496790a 40927f9dd1afbc90"
+	   "950a81d4a7c6b8e0 e439301d79c0e5fa b4e963b409723b3e d9f6d91021187ee5"
+	   "ad81d7d582d08c3b 3895f89201a99200 70d1a788771f3aeb b5e4f59dc73786b2"
+	   "12463419728cf58c f67898e07cd3f4"),
+      SHEX("23c67f20a12358bc 7b05db2115cf9641 c788ef765c49db42 bff3c0f5bd5dd98e"
+	   "af3df4e4da88bdbc 475d7607c95f541d 1d6aa12e18d66084 021837929215ab21"
+	   "ee21cc716e51d92b cc81973feb4599b8 1bdaff90d341069c 3ffbe4b2dcc9030d"
+	   "a7aed77d02b832ab f365a3656c4ee4a2 5e9eeecdde79366b 1be13cdf10ad4f02"
+	   "e114aa09b40b76eb 69382002cb8ec0df ca4874c331ad422c 519bd06ac136d721"
+	   "dfb045baca7f3520 28bbc176fd435d23 7d31841a974d83aa 7ef1c4e683ac0def"
+	   "ef3ca47c48e4c8ca 0d7dea7c45d77350 251d01c4021acde0 385ba85a169a1059"
+	   "74d719c6f3b517f6 598d62af44e8dce9 c176f1d0bd29d7ec 1dac57db1a3fd8f6"
+	   "6eb6e6df36e789ce 5635431c7d57790e d8f4d7a70dc68f91 6667820f49c9c565"
+	   "81a1395a539f02a5 d53622a8a81c370e 7646dfbd6adbfc1b bd10b8b1bc724c58"
+	   "4ada6d6600da7a66 a0e73b39a3f70507 fa214bc794c0d37b 19025d4a10f1c20f"
+	   "196827c77dbf5503 577daf77ae802f7a e61f4bdc1518c062 a1e8d91c9e8c9639"
+	   "c1c488f70ce10484 6851cef190da7f76 c8c088ef8e15253e 7be479b5662d9cd1"
+	   "13dad0d546d58d46 1807eed8c964e3be 0e6827099626f6e2 19613ff458270aeb"
+	   "ce7cb66892e7123b 31d448df358df486 422a154be8191f26 659ba8da4b791f8e"
+	   "e6137e498fc1cedc 5e6474ce0278e0cf a0ed5e3174d1d0b4 ee7019143c8f16a6"
+	   "cf12931588eb9165 7698fda19430ba43 62654004779ed6ab 8b0d9380505fa276"
+	   "20a7d69c271527bc a55abfe9928205a8 41e9b560d5c0d74b ad38b2e9d1e5515f"
+	   "2478249a23d2c248 bd0ef137729187b0 4ebd996b2c01b679 69ec0cede53f5064"
+	   "7cb9dde19281b5d0 cb1783868bea4f93 08bc220cefe80df5 9e23e1f9b76b450b"
+	   "cba9b64d2825ba3e 86f275475d9d6bf6 8a0558733d00defd 69b16116f52eb09f"
+	   "316a00b9ef716347 a3cae040a87e0204 fee5ce4873e394cf e2ff297ef632bbb7"
+	   "5512217a9c75040c b47cb03d40b3119a 7a9a13fb77a75168 f705473b0f525ce6"
+	   "c2993a37545c4f2b a7010874bc91e3e2 fe6594fd3d18e0f0 62edc210829c587f"
+	   "b2a3878a74d9c1fb 842817c72bcb531f 4e8a82fcb43fc147 25f321dc4c2d08fa"
+	   "e70f03a968de6b41 a0f9416c574d3a0e ea51ca9f97117df6 8e886367c96513ca"
+	   "38ed35bef427a9fc a9e6c34086083972 37eeb2870996b740 873692c15d6a2c43"
+	   "ca25c835372db5a9 274450f26d227541 772adbb18c6d05e8 c999c708f9148f78"
+	   "a98fc25a7a65c5d8 86bb72696b6b4583 5bb1f7cd1673eee9 8085fe8ee1ae538f"
+	   "debe488b59eff67e d8b5a847c04e1558 cad32ff86ca63d78 4d7a54d610e5cc05"
+	   "e229b58607397d78 8e5a8f834ce73d68 3ee502e6644f5eb4 4977f0c0fa6fc8fb"
+	   "9f846f55fb305e89 93a9f3a6a3d726bb d8a8d9951dfefcd7 a893662f04530664"
+	   "7f3129aeb79fbac4 6d68d12432f411"));
 }
-- 
2.23.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190916091432</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-09-16 09:14:32-0400</timestampReceived><subject>[PATCH 4/5] Add special CNT mode for GOST 28147-89 cipher</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 gost28147.c                |  86 ++++++++++++++++++++
 gost28147.h                |  24 ++++++
 testsuite/gost28147-test.c | 161 +++++++++++++++++++++++++++++++++++++
 3 files changed, 271 insertions(+)

diff --git a/gost28147.c b/gost28147.c
index ac94dfaa2ed8..f718a202a56b 100644
--- a/gost28147.c
+++ b/gost28147.c
@@ -38,6 +38,7 @@
 #include "macros.h"
 #include "gost28147.h"
 #include "gost28147-internal.h"
+#include "memxor.h"
 
 /* pre-initialized GOST lookup tables based on rotated S-Box */
 const struct gost28147_param gost28147_param_test_3411 =
@@ -2371,3 +2372,88 @@ gost28147_encrypt_for_cfb(struct gost28147_ctx *ctx,
       ctx-&gt;key_count += GOST28147_BLOCK_SIZE;
     }
 }
+
+static void
+gost28147_cnt_next_iv(struct gost28147_cnt_ctx *ctx,
+		      uint8_t *out)
+{
+  uint32_t block[2];
+  uint32_t temp;
+
+  if (ctx-&gt;ctx.key_meshing &amp;&amp; ctx-&gt;ctx.key_count == 1024)
+    {
+      gost28147_key_mesh_cryptopro(&amp;ctx-&gt;ctx);
+      _gost28147_encrypt_block(ctx-&gt;ctx.key, ctx-&gt;ctx.sbox, ctx-&gt;iv, ctx-&gt;iv);
+      ctx-&gt;ctx.key_count = 0;
+    }
+
+  ctx-&gt;iv[0] += 0x01010101;
+  temp = ctx-&gt;iv[1] + 0x01010104;
+  if (temp &lt; ctx-&gt;iv[1])
+    ctx-&gt;iv[1] = temp + 1; /* Overflow */
+  else
+    ctx-&gt;iv[1] = temp;
+
+  _gost28147_encrypt_block(ctx-&gt;ctx.key, ctx-&gt;ctx.sbox, ctx-&gt;iv, block);
+
+  LE_WRITE_UINT32(out + 0, block[0]);
+  LE_WRITE_UINT32(out + 4, block[1]);
+
+  ctx-&gt;ctx.key_count += GOST28147_BLOCK_SIZE;
+}
+
+void
+gost28147_cnt_init(struct gost28147_cnt_ctx *ctx,
+		   const uint8_t *key,
+		   const struct gost28147_param *param)
+{
+  gost28147_set_key(&amp;ctx-&gt;ctx, key);
+  gost28147_set_param(&amp;ctx-&gt;ctx, param);
+  ctx-&gt;bytes = 0;
+}
+
+void
+gost28147_cnt_set_iv(struct gost28147_cnt_ctx *ctx,
+		     const uint8_t *iv)
+{
+  uint32_t block[2];
+
+  block[0] = LE_READ_UINT32(iv + 0);
+  block[1] = LE_READ_UINT32(iv + 4);
+
+  _gost28147_encrypt_block(ctx-&gt;ctx.key, ctx-&gt;ctx.sbox, block, ctx-&gt;iv);
+}
+
+void
+gost28147_cnt_crypt(struct gost28147_cnt_ctx *ctx,
+		    size_t length, uint8_t *dst,
+		    const uint8_t *src)
+{
+  size_t block_size = GOST28147_BLOCK_SIZE;
+
+  if (ctx-&gt;bytes)
+    {
+      size_t part = ctx-&gt;bytes &lt; length ? ctx-&gt;bytes : length;
+      memxor3(dst, src, ctx-&gt;buffer + block_size - ctx-&gt;bytes, part);
+      dst += part;
+      src += part;
+      length -= part;
+      ctx-&gt;bytes -= part;
+      ctx-&gt;bytes %= block_size;
+    }
+  while (length &gt;= block_size)
+    {
+      gost28147_cnt_next_iv(ctx, ctx-&gt;buffer);
+      memxor3(dst, src, ctx-&gt;buffer, block_size);
+      length -= block_size;
+      src += block_size;
+      dst += block_size;
+    }
+
+  if (length != 0)
+    {
+      gost28147_cnt_next_iv(ctx, ctx-&gt;buffer);
+      memxor3(dst, src, ctx-&gt;buffer, length);
+      ctx-&gt;bytes = block_size - length;
+    }
+}
diff --git a/gost28147.h b/gost28147.h
index 241c1e136fbc..08189067983c 100644
--- a/gost28147.h
+++ b/gost28147.h
@@ -56,6 +56,10 @@ extern "C" {
 #define gost28147_encrypt_for_cfb nettle_gost28147_encrypt_for_cfb
 #define gost28147_decrypt nettle_gost28147_decrypt
 
+#define gost28147_cnt_init nettle_gost28147_cnt_init
+#define gost28147_cnt_set_iv nettle_gost28147_cnt_set_iv
+#define gost28147_cnt_crypt nettle_gost28147_cnt_crypt
+
 #define GOST28147_KEY_SIZE 32
 #define GOST28147_BLOCK_SIZE 8
 
@@ -102,6 +106,26 @@ gost28147_encrypt_for_cfb(struct gost28147_ctx *ctx,
 			  size_t length, uint8_t *dst,
 			  const uint8_t *src);
 
+struct gost28147_cnt_ctx {
+  struct gost28147_ctx ctx;
+  size_t bytes;
+  uint32_t iv[2];
+  uint8_t buffer[GOST28147_BLOCK_SIZE];
+};
+
+void
+gost28147_cnt_init(struct gost28147_cnt_ctx *ctx,
+		   const uint8_t *key,
+		   const struct gost28147_param *param);
+
+void
+gost28147_cnt_set_iv(struct gost28147_cnt_ctx *ctx,
+		     const uint8_t *iv);
+
+void
+gost28147_cnt_crypt(struct gost28147_cnt_ctx *ctx,
+		    size_t length, uint8_t *dst,
+		    const uint8_t *src);
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/gost28147-test.c b/testsuite/gost28147-test.c
index 939bedee9c66..42441969a467 100644
--- a/testsuite/gost28147-test.c
+++ b/testsuite/gost28147-test.c
@@ -1,6 +1,7 @@
 #include "testutils.h"
 #include "gost28147.h"
 #include "cfb.h"
+#include "macros.h"
 
 static void
 test_gost28147(const struct gost28147_param *param,
@@ -104,6 +105,82 @@ test_gost28147_cfb(const struct gost28147_param *param,
   free(data);
 }
 
+static void
+test_gost28147_cnt(const struct gost28147_param *param,
+		   const struct tstring *key,
+		   const struct tstring *start_iv,
+		   const struct tstring *end_iv,
+		   const struct tstring *cleartext,
+		   const struct tstring *ciphertext)
+{
+  struct gost28147_cnt_ctx ctx;
+  uint8_t *data = xalloc(cleartext-&gt;length);
+  uint8_t iv[GOST28147_BLOCK_SIZE];
+  size_t length;
+
+  ASSERT (cleartext-&gt;length == ciphertext-&gt;length);
+  length = cleartext-&gt;length;
+
+  gost28147_cnt_init(&amp;ctx, key-&gt;data, param);
+  gost28147_cnt_set_iv(&amp;ctx, start_iv-&gt;data);
+  gost28147_cnt_crypt(&amp;ctx, length, data, cleartext-&gt;data);
+
+  if (!MEMEQ(length, data, ciphertext-&gt;data))
+    {
+      fprintf(stderr, "Encrypt failed:\nInput:");
+      tstring_print_hex(cleartext);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(ciphertext);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  LE_WRITE_UINT32(iv + 0, ctx.iv[0]);
+  LE_WRITE_UINT32(iv + 4, ctx.iv[1]);
+
+  if (!MEMEQ(GOST28147_BLOCK_SIZE, iv, end_iv-&gt;data))
+    {
+      fprintf(stderr, "Encrypt failed IV check:\nOutput:");
+      print_hex(GOST28147_BLOCK_SIZE, iv);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(end_iv);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  gost28147_cnt_init(&amp;ctx, key-&gt;data, param);
+  gost28147_cnt_set_iv(&amp;ctx, start_iv-&gt;data);
+  gost28147_cnt_crypt(&amp;ctx, length, data, data);
+
+  if (!MEMEQ(length, data, cleartext-&gt;data))
+    {
+      fprintf(stderr, "Decrypt failed:\nOutput:");
+      print_hex(length, data);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(cleartext);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  LE_WRITE_UINT32(iv + 0, ctx.iv[0]);
+  LE_WRITE_UINT32(iv + 4, ctx.iv[1]);
+
+  if (!MEMEQ(GOST28147_BLOCK_SIZE, iv, end_iv-&gt;data))
+    {
+      fprintf(stderr, "Decrypt failed IV check:\nInput:");
+      fprintf(stderr, "\nOutput: ");
+      print_hex(GOST28147_BLOCK_SIZE, iv);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(end_iv);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+
+  free(data);
+}
+
 void test_main(void)
 {
   /* Examples from GOST R 34.11-94 standard */
@@ -259,4 +336,88 @@ void test_main(void)
 	   "e229b58607397d78 8e5a8f834ce73d68 3ee502e6644f5eb4 4977f0c0fa6fc8fb"
 	   "9f846f55fb305e89 93a9f3a6a3d726bb d8a8d9951dfefcd7 a893662f04530664"
 	   "7f3129aeb79fbac4 6d68d12432f411"));
+
+  test_gost28147_cnt(&amp;gost28147_param_CryptoPro_A,
+      SHEX("599f84bac3f3d2f1 60e1e3f26a961af9 9c48b24ebcbbbf7c d8f3accd968d286a"),
+      SHEX("8dafa8d158ed058d"),
+      SHEX("f1a0e3294f65be75"),
+      SHEX("90a23966ae01b9a3 524ec8ed6cdd8830"),
+      SHEX("6e7262cce3593690 833afea91bc9bece"));
+  test_gost28147_cnt(&amp;gost28147_param_CryptoPro_A,
+      SHEX("1b5ddb77cff9ec95 5ecc679f5d28ad4a 27f432c6b2cbb145 6a88140c9b9b5f48"),
+      SHEX("71588ce155f4f6b3"),
+      SHEX("6aeaa0a59e10e0ce"),
+      SHEX("3d0b69f7a8e4fc99 222eeed16312fea8 9dcb6c4d488ce8bd 8b60f1bf7be379d5"
+           "2b259713ef35daf4 bc77ceeae93fa4b6 01d5732958dad767 17ace4752f5723ac"
+           "9621c7622df732b5 445f72b15fba1b1e db4a098c9261a2b0 4968e5b3a28f134b"
+           "f54d84daaba0b6d1 5a6319e8a209f676 6f9b480a155db720 219a2eb96dfa1ec2"
+           "0eef15ab5901fe43 90f262ca4a9a4838 ab6f9d21b3ada760 46e3efd0e31dc5e1"
+           "b8a1e29920c576cc aa8aa94555a07800 64decf5bdf2648cd ba8ab5fbfd4ad5c4"
+           "e043a67190a48bca 2e887bacb2dcf201 cbda6e9127284488 9ad212f1a6f5b761"
+           "ce7962523ce61473 d1419250bddc3bd0 a7118c3ae42df252 d32f7c8e54904e23"
+           "aeb3a0f3257e66aa 0f6f817277bbd347 e805ffe15bc93750 334917afab1de115"
+           "f2e5985e2d051f0d 5597edff5ee00fc3 9cbd82c206be4566 ae33be2848e92d1a"
+           "e6658edf7603734b c08071f9acbaa0b0 191a0ad435128876 05758f7cb5f01975"
+           "6d05cb0dbc8de9f0 d4db3c3c298e2c32 1df7b649cfdb63ee 3cfa33736fe4974e"
+           "2fc94c5c65feeafb c6ddc11c473ff450 2fde1b5b0b16cab6 4644f2c10da11da6"
+           "dbf03db16c053185 8e74aef23926f7c1 e74cdd9d40b8f3c5 c216646baadb4b82"
+           "5cd302d38f26798d b0787019580cb431 88441c916ff45239 a8f5c01bfef20e4b"
+           "ac0ac27e9c9beb5d 4e4f42d8710a9727 031496a63d04ea9f 1414274cd9a2895f"
+           "654ae19d2cb8f8d4 8f2a5736cc069c2c c51316dffcae2216 a82b716f1db34754"
+           "3f2d0a689f2ef690 d8a12109d497b97b 7f9b6aedd1f0e3b6 28c7628200c938a1"
+           "8278ce87c853ac4f 2e31b9507f36004a 32e6d8bb59450e91 1b38a9bcb95e6c6a"
+           "9c03011cdee81f1e e3de25a25679e1bd 58c493e6d08a4d08 abf7aac37dc1ee68"
+           "37bc780b19682b2b 2e6dc46faa3bc619 cbf158b9608545ae 5297ba2432137216"
+           "6e7bc198acb1edb4 cc6ccf45fc508980 8e7aa4d364506337 c96cf1c43dfbde5a"
+           "5ca82135e62e8c2a 3c1217799a0d2e79 eb671f2bf86ecac1 fa45189edf6ae6cb"
+           "e95cc309af935813 bf90848775d68228 8de72fa3fb97742a 730482067669b10b"
+           "19fcaeb3dd2ae5c1 05d88095229071fc c29242fdf170b468 88a49e0a244013c8"
+           "a2564f39e606f1dc f5130ead9c8bafe9 e38872ffa06dda08 70b92e83c5bb32a5"
+           "74c7fb7b76af02bb 2bb85e6502fe0ea0 99ce013b35e1b022 e594bddd8ebbf675"
+           "bfbfee7ab158b481 b8393eb61ededa1b d5f7dd7d659caa56 93b8af4853c722e4"
+           "1cdfe979b42089cc 2a792c09be78cfcc f290d665c529fcda 69fcc0d67099613f"
+           "6002d81222c834c6 3bb3c233a15c8f4c d15272f242058e18 1f16dab853a15f01"
+           "321b90b3539bd085 612d17ed0aa4a527 09757cbc30f75e59 9a07968428864ba7"
+           "223528c7ed0dc3ce 98cc2decd498098e 525f2b9a13be9916 73d11f81e5a20878"
+           "cb0c20d4a5ea4b5b 955a929a52"),
+      SHEX("8ecd8fc8ace11548 2dae248ac7fbba0f 1d8a95a243efcbdc 5957a7c70ee3e2b9"
+           "0d862962cb834d07 0c40d47b2ecababf 4a603b3198c88847 d982abfc8f48e246"
+           "abd3a1ab8a05228c f4ec9a1e76ab1a60 d9256bb856e5b2ea 10f36204325eaa3b"
+           "7b57bc3b8b4347f2 d5037e5101ff7728 ca90a3fe7e2e7016 751844f01b8505ea"
+           "e321f72686763c67 9dfcbc107f77e4ed d312f883001f4b92 95925cf35af3b7d0"
+           "a95ff218c46662c1 840e66e8807d1ff0 ba019b71ae93cc27 54349abdcaee5209"
+           "929db0d5d9ba2fb9 96dcfabdceea1a7b 9a1d13a711e29a64 f6d3eec633b76eef"
+           "259e1e7ce31f2c6e a9c0f8c1bf3bf834 039ba1405b0c3c09 669d63e2e2048f06"
+           "847468b25c3b4cad 0b3f03b3078a64a7 3656263966dae96d 1bd588e85caf5a4c"
+           "49f7f5b778f0deec cd16239e8c13be6b 6f9b07e5bbcc3a1b 6f43dfff462aae47"
+           "19189a2509c92440 0c4ba7da5e0deefa 62458ecc2f23081d 92f0fe820fd71160"
+           "7e0b0b75f4f53bc0 a4e872a5b6fa5aad 5a4f39b5a212960a 3284b2a106685657"
+           "97a37b2261765d30 1a31ab9906c51a96 cfcf14ffb2c4cc2b bf0c9d918f795bbc"
+           "a96b916ab4935c7b 5dc28a75c0c108fa 99f94d5e0c066460 a9014a340f338495"
+           "6930c11c36f8fc30 23b271e5524d121a c9beeec9cb0185f3 db30f941a940b006"
+           "2977cdc5ec580248 8353446ad2ca05d8 5a08eba9f4e6c79d d57b740b31b7a557"
+           "7c7afd1a0ed79741 bfddc6196c778c18 525783ba7125ee39 bbe243a014dc0e84"
+           "b42bde3ee536b7a2 929805b896e5d08c 089335c281e0fc59 71e244495ddafb9c"
+           "aa709f43a8a5d967 d98fa31ebe0eecdf 122b6ae71c1217e7 c46d50c9527ad5e8"
+           "7fbc0715acdb9366 b1f0a77b2fe9ecd0 47695987f14c3e4b 9b117913e496f656"
+           "046e0b33fc40f6c7 c143b1bf0eb387fd 0b1c63463ad3a017 5925946c9c3d0c81"
+           "ce82724228f9376a 6de412f421aaf7fe 2755401a14c3395b bf63c25f101f1425"
+           "d0cef3144813a50b 4d38cf0d34c00a11 b4b572c84bc26fe7 9d93f7dfb843727e"
+           "da3e201fbc212ace 00fa969f3de58896 ef2984df6c1c96d8 5847aa92f307e5fb"
+           "afea957e0b71cd81 0fb70a598f314dd1 c3f32f705c591897 af77955eaf400612"
+           "816186084ebc8946 072e5b10aa12f0a7 84e29a08f1de59e3 0e474bffc3c918af"
+           "959c672ade8a7a99 04c4b8974c042971 05dab3d6db6c71e6 e803bf947dde3dc8"
+           "44fa7d62b43603ee 365264b4856dd578 f06f672d0ee02c88 9b55192940f68c12"
+           "bb2c839640c036f5 77ff708c75920bad 059b7ea2fca9d164 768213ba225e330e"
+           "2670a9be7428f5e2 c496ee3abc97a62c 2ae0648d35c61aca f492fac3f11f98e4"
+           "4388693a09bf63e5 96290b9b6223148a 95e41c5c0aa9c5b9 6f4f2b256f741e18"
+           "d5fe277d3f6e552c 67e6deb5ccc02dff c4e40621a5c8d3d6 6ca1c3fb8892b11d"
+           "90e135059b296dba f1f41e232e"));
+
+  test_gost28147_cnt(&amp;gost28147_param_TC26_Z,
+      SHEX("599f84bac3f3d2f1 60e1e3f26a961af9 9c48b24ebcbbbf7c d8f3accd968d286a"),
+      SHEX("8dafa8d158ed058d"),
+      SHEX("626804b2e7ba1be2"),
+      SHEX("90a23966ae01b9a3 524ec8ed6cdd8830"),
+      SHEX("e8b14fc730dc25bb 36ba643c17dbff99"));
 }
-- 
2.23.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190916091433</emailId><senderName></senderName><senderEmail>dbaryshkov</senderEmail><timestampReceived>2019-09-16 09:14:33-0400</timestampReceived><subject>[PATCH 5/5] Add GOST 28147-89 IMIT support</subject><body>

From: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;

Signed-off-by: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
---
 gost28147.c                | 107 +++++++++++++++++++++++++++++++++++--
 gost28147.h                |  47 ++++++++++++++++
 testsuite/gost28147-test.c | 102 +++++++++++++++++++++++++++++++++++
 3 files changed, 253 insertions(+), 3 deletions(-)

diff --git a/gost28147.c b/gost28147.c
index f718a202a56b..c7f5f1413695 100644
--- a/gost28147.c
+++ b/gost28147.c
@@ -36,6 +36,7 @@
 #include &lt;string.h&gt;
 
 #include "macros.h"
+#include "nettle-write.h"
 #include "gost28147.h"
 #include "gost28147-internal.h"
 #include "memxor.h"
@@ -2286,15 +2287,21 @@ static void gost28147_key_mesh_cryptopro(struct gost28147_ctx *ctx)
   ctx-&gt;key_count = 0;
 }
 
-void
-gost28147_set_key(struct gost28147_ctx *ctx, const uint8_t *key)
+static void
+_gost28147_set_key(struct gost28147_ctx *ctx, const uint8_t *key)
 {
   unsigned i;
 
-  assert(key);
   for (i = 0; i &lt; 8; i++, key += 4)
     ctx-&gt;key[i] = LE_READ_UINT32(key);
   ctx-&gt;key_count = 0;
+}
+
+void
+gost28147_set_key(struct gost28147_ctx *ctx, const uint8_t *key)
+{
+  assert(key);
+  _gost28147_set_key(ctx, key);
   gost28147_set_param(ctx, &amp;gost28147_param_TC26_Z);
 }
 
@@ -2457,3 +2464,97 @@ gost28147_cnt_crypt(struct gost28147_cnt_ctx *ctx,
       ctx-&gt;bytes = block_size - length;
     }
 }
+
+void
+gost28147_imit_init(struct gost28147_imit_ctx *ctx)
+{
+  memset(ctx-&gt;state, 0, GOST28147_BLOCK_SIZE);
+  ctx-&gt;index = 0;
+  ctx-&gt;count = 0;
+  gost28147_set_param(&amp;ctx-&gt;cctx, &amp;gost28147_param_TC26_Z); /* Default */
+}
+
+void
+gost28147_imit_set_key(struct gost28147_imit_ctx *ctx,
+		       size_t length,
+		       const uint8_t *key)
+{
+  assert(length == GOST28147_IMIT_KEY_SIZE);
+  assert(key);
+
+  _gost28147_set_key(&amp;ctx-&gt;cctx, key);
+  /* Do not reset param here */
+}
+
+void
+gost28147_imit_set_nonce(struct gost28147_imit_ctx *ctx, const uint8_t *nonce)
+{
+	ctx-&gt;state[0] = LE_READ_UINT32(nonce + 0);
+	ctx-&gt;state[1] = LE_READ_UINT32(nonce + 4);
+}
+
+void
+gost28147_imit_set_param(struct gost28147_imit_ctx *ctx,
+			 const struct gost28147_param *param)
+{
+  assert(param);
+  gost28147_set_param(&amp;ctx-&gt;cctx, param);
+}
+
+static void
+gost28147_imit_compress(struct gost28147_imit_ctx *ctx,
+			const uint8_t *data)
+{
+  uint32_t l, r;
+
+  if (ctx-&gt;cctx.key_meshing &amp;&amp; ctx-&gt;cctx.key_count == 1024)
+    gost28147_key_mesh_cryptopro(&amp;ctx-&gt;cctx);
+
+  r = LE_READ_UINT32(data + 0) ^ ctx-&gt;state[0];
+  l = LE_READ_UINT32(data + 4) ^ ctx-&gt;state[1];
+
+  GOST_ENCRYPT_ROUND(l, r, ctx-&gt;cctx.key[0], ctx-&gt;cctx.key[1], ctx-&gt;cctx.sbox);
+  GOST_ENCRYPT_ROUND(l, r, ctx-&gt;cctx.key[2], ctx-&gt;cctx.key[3], ctx-&gt;cctx.sbox);
+  GOST_ENCRYPT_ROUND(l, r, ctx-&gt;cctx.key[4], ctx-&gt;cctx.key[5], ctx-&gt;cctx.sbox);
+  GOST_ENCRYPT_ROUND(l, r, ctx-&gt;cctx.key[6], ctx-&gt;cctx.key[7], ctx-&gt;cctx.sbox);
+  GOST_ENCRYPT_ROUND(l, r, ctx-&gt;cctx.key[0], ctx-&gt;cctx.key[1], ctx-&gt;cctx.sbox);
+  GOST_ENCRYPT_ROUND(l, r, ctx-&gt;cctx.key[2], ctx-&gt;cctx.key[3], ctx-&gt;cctx.sbox);
+  GOST_ENCRYPT_ROUND(l, r, ctx-&gt;cctx.key[4], ctx-&gt;cctx.key[5], ctx-&gt;cctx.sbox);
+  GOST_ENCRYPT_ROUND(l, r, ctx-&gt;cctx.key[6], ctx-&gt;cctx.key[7], ctx-&gt;cctx.sbox);
+
+  ctx-&gt;state[0] = r;
+  ctx-&gt;state[1] = l;
+
+  ctx-&gt;cctx.key_count += 8;
+}
+
+void
+gost28147_imit_update(struct gost28147_imit_ctx *ctx,
+		      size_t length,
+		      const uint8_t *data)
+{
+  MD_UPDATE(ctx, length, data, gost28147_imit_compress, ctx-&gt;count++);
+}
+
+void
+gost28147_imit_digest(struct gost28147_imit_ctx *ctx,
+		      size_t length,
+		      uint8_t *digest)
+{
+  assert(length &lt;= GOST28147_IMIT_DIGEST_SIZE);
+  const uint8_t zero[GOST28147_IMIT_BLOCK_SIZE] = { 0 };
+
+  if (ctx-&gt;index)
+    {
+      assert(ctx-&gt;index &lt; GOST28147_IMIT_BLOCK_SIZE);
+      gost28147_imit_update(ctx, GOST28147_IMIT_BLOCK_SIZE - ctx-&gt;index, zero);
+    }
+
+  if (ctx-&gt;count == 1)
+    {
+      gost28147_imit_update(ctx, GOST28147_IMIT_BLOCK_SIZE, zero);
+    }
+
+  _nettle_write_le32(length, digest, ctx-&gt;state);
+  gost28147_imit_init(ctx);
+}
diff --git a/gost28147.h b/gost28147.h
index 08189067983c..6d380dff190e 100644
--- a/gost28147.h
+++ b/gost28147.h
@@ -60,6 +60,13 @@ extern "C" {
 #define gost28147_cnt_set_iv nettle_gost28147_cnt_set_iv
 #define gost28147_cnt_crypt nettle_gost28147_cnt_crypt
 
+#define gost28147_imit_init nettle_gost28147_imit_init
+#define gost28147_imit_set_key nettle_gost28147_imit_set_key
+#define gost28147_imit_set_nonce nettle_gost28147_imit_set_nonce
+#define gost28147_imit_set_param nettle_gost28147_imit_set_param
+#define gost28147_imit_update nettle_gost28147_imit_update
+#define gost28147_imit_digest nettle_gost28147_imit_digest
+
 #define GOST28147_KEY_SIZE 32
 #define GOST28147_BLOCK_SIZE 8
 
@@ -126,6 +133,46 @@ void
 gost28147_cnt_crypt(struct gost28147_cnt_ctx *ctx,
 		    size_t length, uint8_t *dst,
 		    const uint8_t *src);
+
+#define GOST28147_IMIT_DIGEST_SIZE 4
+#define GOST28147_IMIT_BLOCK_SIZE GOST28147_BLOCK_SIZE
+#define GOST28147_IMIT_KEY_SIZE GOST28147_KEY_SIZE
+
+struct gost28147_imit_ctx
+{
+  struct gost28147_ctx cctx;
+  uint64_t count;		/* Block count */
+  uint8_t block[GOST28147_IMIT_BLOCK_SIZE]; /* Block buffer */
+  unsigned index;               /* Into buffer */
+  uint32_t state[GOST28147_IMIT_BLOCK_SIZE/4];
+};
+
+void
+gost28147_imit_init(struct gost28147_imit_ctx *ctx);
+
+void
+gost28147_imit_set_key(struct gost28147_imit_ctx *ctx,
+		       size_t length,
+		       const uint8_t *key);
+
+void
+gost28147_imit_set_nonce(struct gost28147_imit_ctx *ctx,
+		         const uint8_t *nonce);
+
+void
+gost28147_imit_set_param(struct gost28147_imit_ctx *ctx,
+			 const struct gost28147_param *param);
+
+void
+gost28147_imit_update(struct gost28147_imit_ctx *ctx,
+		      size_t length,
+		      const uint8_t *data);
+
+void
+gost28147_imit_digest(struct gost28147_imit_ctx *ctx,
+		      size_t length,
+		      uint8_t *digest);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/testsuite/gost28147-test.c b/testsuite/gost28147-test.c
index 42441969a467..5682cf937e25 100644
--- a/testsuite/gost28147-test.c
+++ b/testsuite/gost28147-test.c
@@ -181,6 +181,34 @@ test_gost28147_cnt(const struct gost28147_param *param,
   free(data);
 }
 
+static void
+test_gost28147_imit(const struct gost28147_param *param,
+		    const struct tstring *key,
+		    const struct tstring *cleartext,
+		    const struct tstring *imit)
+{
+  struct gost28147_imit_ctx ctx;
+  uint8_t data[GOST28147_IMIT_DIGEST_SIZE];
+
+  gost28147_imit_init(&amp;ctx);
+  gost28147_imit_set_key(&amp;ctx, key-&gt;length, key-&gt;data);
+  gost28147_imit_set_param(&amp;ctx, param);
+  gost28147_imit_update(&amp;ctx, cleartext-&gt;length, cleartext-&gt;data);
+  gost28147_imit_digest(&amp;ctx, imit-&gt;length, data);
+
+  if (!MEMEQ(imit-&gt;length, data, imit-&gt;data))
+    {
+      fprintf(stderr, "IMIT failed:\nInput:");
+      tstring_print_hex(cleartext);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(imit-&gt;length, data);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(imit);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+}
+
 void test_main(void)
 {
   /* Examples from GOST R 34.11-94 standard */
@@ -420,4 +448,78 @@ void test_main(void)
       SHEX("626804b2e7ba1be2"),
       SHEX("90a23966ae01b9a3 524ec8ed6cdd8830"),
       SHEX("e8b14fc730dc25bb 36ba643c17dbff99"));
+
+  /* From Open/LibreSSL testsuite */
+  test_gost28147_imit(&amp;gost28147_param_CryptoPro_A,
+      SHEX("9d05b79e90cad00a 2cdad22ef4e86f5c f5dc37681985b3bf aa18c1c3050a91a2"),
+      SHEX("b5a1f0e3 ce2f021d 67619434 5c41e36e"),
+      SHEX("f81f08a3"));
+
+  test_gost28147_imit(&amp;gost28147_param_CryptoPro_A,
+      SHEX("80d9a0dc21f93040 75fe491b9e719091 7888216039e7c92b fb551df4dd2b0a01"),
+      SHEX("d6cf31969ca1fbd6 8da3dd01d988c02f bc46c73ae4218696 8de2cab637a2e1a8"
+	   "7ea7792ea456757f 3e558b43ae65dfaa 42b600a661030dd3 4102272395799b34"
+	   "81a986b5a790e2ae c42fc38e325613fa 4d4e9f15757e74dc 322dee4d67709f62"
+	   "b9c4db2484cc167b da22f7c5f3933573 c6031c77a5f27656 b495d47e0d20c66e"
+	   "ee8f2548ff7e013a b41faa35c033589c b5ba654bd35114ec 61cee4ba49ba3932"
+	   "abce8172ceabedd4 d219878592fa6434 d886f48a083cdeee 97929269ba9b5f7a"
+	   "03c15d43028cbed2 467281407d689845 0b54271caf8042e4 d5d4e4a298078f03"
+	   "f52c8c88ca5adee4 9fb15f82ff206752 85844fc8fea79eae 1cfab875d3f79f0d"
+	   "da2de6cc866ba414 65c3f915bc87f5ae 8c10d4ce5b9ce2dd 4203098747ed5dd0"
+	   "7a694cfa437dbf07 856aee68e67a57b2 208d80f2916f5c07 8ce46a4990858b77"
+	   "29561c5ea93fab8b 79a36f6b34cb61f6 e692d1489e11a282 c04e23d2150d8dff"
+	   "fa179d81b8bcd75b 08812040c03c068b 1a880b4b7b31f5d4 4e09d14d0d7f45d1"
+	   "0935bace65ddf2b8 fb7abcc44bc875da 6bce3de894cc236f b03b4f7d07b90f62"
+	   "927eda7050ced328 121100eb8d637078 a87b76abc640c04e 80ddf0fe8372564c"
+	   "094cf17272862631 c3c2dc8ec7f435ec 17066347498847af b3384f7e4495b5bb"
+	   "1dbd5a915bd01adf 0d0b50d8e20ec500 2d5b2919aa2b64c5 40314811bc04d1cf"
+	   "6df9a52f4ac982fa 59e1fcab1c33260a 5feff206d8d37e16 58167873aebaebe5"
+	   "3db20ab3322d14a4 fa3f1f43f97ba943 9818940707e51934 a8165f7167aa29e5"
+	   "faf083061d9dfcfe fe8cb5b2a9e7a040 60b6719eab5b83b9 0c2b582380099e5d"
+	   "947d4076a916969e 83e00deca0ec762a b7a0ffb8504c5bc6 8b0a652efeb4409a"
+	   "01d8c6a3ab99a2c5 0c08c4b7ee4d1dc4 0815d0dbaa634f31 eb149743bdc19408"
+	   "e6de439f950b967e 7f3c68ba6fc4c935 2bc40eda1f916864 633473be5775b9ed"
+	   "f72d3b0521932848 969597a0d27d78bb 6a498f76557463b9 c5361225bf03828f"
+	   "f0f680bb33b4f417 271cf34c10a3e4d1 55d968214e5a8367 bff83c7d4e62d328"
+	   "a7266fe9eec20b2d 0384b1ffd6681fb6 f2e40fda2dee5f6e 21c8e1fcad6b0e04"
+	   "7dafc23ba5689b0c f356f3da8dc87d39 dcd599c60110ce42 1bac48dc97780aec"
+	   "b38f4735a36a64b2 8e63692266ae2ee0 88f9403cc9a25761 f6adf0dc90563f06"
+	   "9b7dbdc28102abb8 1509884aff2f31bf 5efa6a7ef6c5a7f7 d5ab55acae0d8c8d"
+	   "7f4b25bb32ff1133 2e373769961517b1 1749e09a9cd95b8d 58a31d9287f880b9"
+	   "bd5aec40e1003360 e486166d6181f228 6aa7ce3f95ae43ca e13f81747e1c4717"
+	   "95c660da7477d99f fa92b4bee1239818 956303134c1a2d41 cde484f7e638efff"
+	   "95b2e87c8f58b5b5 ed277f3c18abbe7f 4fe2351571b76f85 389b88f69c8d43b5"
+	   "589ef2d196beb7ad 1aa098"),
+      SHEX("90f2119a"));
+
+  test_gost28147_imit(&amp;gost28147_param_CryptoPro_A,
+      SHEX("a9b637cc6d9b2f25 b0df47045068b027 4127586abd0a6e50 2fc6fcc03e2942a5"),
+      SHEX("1debe6790a5900e6 8e5c"),
+      SHEX("317c16e4"));
+
+  test_gost28147_imit(&amp;gost28147_param_CryptoPro_A,
+      SHEX("b06c48230a6ef4ec 27980123a7d8bf60 89efade88f79148c 185c9adaef0bdda0"),
+      SHEX("ef068f14c904"),
+      SHEX("e972aebf"));
+
+  test_gost28147_imit(&amp;gost28147_param_CryptoPro_B,
+      SHEX("33d3ef0119950e15 a16975ae56271779 6347ab629d4af034 d31e6974ec3148fc"),
+      SHEX("02f8ec2b4d1fbc7c 6e47e387227541a7"),
+      SHEX("f5551f28"));
+
+  test_gost28147_imit(&amp;gost28147_param_CryptoPro_A,
+      SHEX("423581910ba999ff d943f8c619551f2f 2d4540201e1d327a b1076b4f4590d980"),
+      SHEX("f3b229d27a370312"),
+      SHEX("6e15fae8"));
+
+  test_gost28147_imit(&amp;gost28147_param_CryptoPro_A,
+      SHEX("26cbb9f00c629faa 4a1db63009015689 66d4e40efef6106b 6ce8043ae3614b19"),
+      SHEX(""),
+      SHEX("00000000"));
+
+  test_gost28147_imit(&amp;gost28147_param_TC26_Z,
+      SHEX("9d05b79e90cad00a 2cdad22ef4e86f5c f5dc37681985b3bf aa18c1c3050a91a2"),
+      SHEX("b5a1f0e3 ce2f021d 67619434 5c41e36e"),
+      SHEX("03e56766"));
+
 }
-- 
2.23.0

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190926210931</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-26 21:09:31-0400</timestampReceived><subject>Re: [PATCH] Curve point decompression</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Not sure in which order to do things. Maybe it will be best to first add
&gt; the square root routines, with tests, and then add functions for
&gt; converting between points and octet strings (and related utilities, if
&gt; needed).

I've now pushed some preparatory changes to the branch ecc-sqrt.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190930193447</emailId><senderName>Niels =?utf-8?Q?M=C3=B6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2019-09-30 19:34:47-0400</timestampReceived><subject>Re: [PATCH] cfb8: don't truncate output IV if input is shorter than block size</subject><body>

Daiki Ueno &lt;ueno@gnu.org&gt; writes:

&gt; We realized that cfb8_decrypt doesn't update the IV correctly when the
&gt; input is shorter than AES block size.  The attached patches should fix
&gt; it.

For testing, I think it would be good to take the testvectors for cfb8,
and split into multiple calls to cfb8_*crypt, in several ways. And check
they all give the same result. A bit like it's done in arcfour-test.c,
or the test_cipher_stream (#if:ed out, not sure if it's worth reviving).

What do you think?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid 368C6677.
Internet email is subject to wholesale government surveillance.
_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs

</body></email><email><emailId>20190930095425</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-09-30 09:54:25-0400</timestampReceived><subject>[PATCH] cfb8: don't truncate output IV if input is shorter than block size</subject><body>

Hello,

We realized that cfb8_decrypt doesn't update the IV correctly when the
input is shorter than AES block size.  The attached patches should fix
it.

Samba is also affected by this and there are similar fixes:
https://git.samba.org/?p=gd/nettle;a=commit;h=c9926d319a44858d9bde5c28e37f37ed4e3ad39a
https://git.samba.org/?p=gd/nettle;a=commit;h=a2aa783012ab874eebe79d6150027118fc823f52

Regards,
-- 
Daiki Ueno

[Attachment #3 (text/x-patch)]

From 69fffd761a08e7915a0b544ccb3d5e680571fc18 Mon Sep 17 00:00:00 2001
From: Daiki Ueno &lt;dueno@redhat.com&gt;
Date: Mon, 30 Sep 2019 11:21:09 +0200
Subject: [PATCH 1/2] testsuite/cfb-test: check output IV

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 testsuite/cfb-test.c  | 18 ++++++++++++------
 testsuite/testutils.c | 42 ++++++++++++++++++++++++++++++++++++++++--
 testsuite/testutils.h |  6 ++++--
 3 files changed, 56 insertions(+), 10 deletions(-)

diff --git a/testsuite/cfb-test.c b/testsuite/cfb-test.c
index dbb24e8a..7c42bec5 100644
--- a/testsuite/cfb-test.c
+++ b/testsuite/cfb-test.c
@@ -137,7 +137,8 @@ test_main(void)
 		        "ae2d"),
 		   SHEX("3b79424c9c0dd436bace9e0ed4586a4f"
 		        "32b9"),
-		   SHEX("000102030405060708090a0b0c0d0e0f"));
+		   SHEX("000102030405060708090a0b0c0d0e0f"),
+		   SHEX("424c9c0dd436bace9e0ed4586a4f32b9"));
 
   /* From NIST spec 800-38a on AES modes.
    *
@@ -152,7 +153,8 @@ test_main(void)
 		        "ae2d"),
 		   SHEX("cda2521ef0a905ca44cd057cbf0d47a0"
 			"678a"),
-		   SHEX("000102030405060708090a0b0c0d0e0f"));
+		   SHEX("000102030405060708090a0b0c0d0e0f"),
+		   SHEX("521ef0a905ca44cd057cbf0d47a0678a"));
 
   /* From NIST spec 800-38a on AES modes.
    *
@@ -167,7 +169,8 @@ test_main(void)
 		        "ae2d"),
 		   SHEX("dc1f1a8520a64db55fcc8ac554844e88"
 			"9700"),
-		   SHEX("000102030405060708090a0b0c0d0e0f"));
+		   SHEX("000102030405060708090a0b0c0d0e0f"),
+		   SHEX("1a8520a64db55fcc8ac554844e889700"));
 
   /* From NIST spec 800-38a on AES modes.
    *
@@ -192,7 +195,8 @@ test_main(void)
 		       "c8a64537a0b3a93fcde3cdad9f1ce58b"
 		       "26751f67a3cbb140b1808cf187a4f4df"
 		       "c04b05357c5d1c0eeac4c66f9ff7f2e6"),
-		  SHEX("000102030405060708090a0b0c0d0e0f"));
+		  SHEX("000102030405060708090a0b0c0d0e0f"),
+		  SHEX("c04b05357c5d1c0eeac4c66f9ff7f2e6"));
 
   /* F.3.15 CFB128-AES192.Encrypt */
 
@@ -215,7 +219,8 @@ test_main(void)
 		       "67ce7f7f81173621961a2b70171d3d7a"
 		       "2e1e8a1dd59b88b1c8e60fed1efac4c9"
 		       "c05f9f9ca9834fa042ae8fba584b09ff"),
-		  SHEX("000102030405060708090a0b0c0d0e0f"));
+		  SHEX("000102030405060708090a0b0c0d0e0f"),
+		  SHEX("c05f9f9ca9834fa042ae8fba584b09ff"));
 
   /* F.3.17 CFB128-AES256.Encrypt */
 
@@ -238,7 +243,8 @@ test_main(void)
 		       "39ffed143b28b1c832113c6331e5407b"
 		       "df10132415e54b92a13ed0a8267ae2f9"
 		       "75a385741ab9cef82031623d55b1e471"),
-		  SHEX("000102030405060708090a0b0c0d0e0f"));
+		  SHEX("000102030405060708090a0b0c0d0e0f"),
+		  SHEX("75a385741ab9cef82031623d55b1e471"));
 
   test_cfb_bulk();
   test_cfb8_bulk();
diff --git a/testsuite/testutils.c b/testsuite/testutils.c
index 2a19c0ac..6f6974f9 100644
--- a/testsuite/testutils.c
+++ b/testsuite/testutils.c
@@ -250,7 +250,8 @@ test_cipher_cfb(const struct nettle_cipher *cipher,
 		const struct tstring *key,
 		const struct tstring *cleartext,
 		const struct tstring *ciphertext,
-		const struct tstring *iiv)
+		const struct tstring *iiv,
+		const struct tstring *oiv)
 {
   void *ctx = xalloc(cipher-&gt;context_size);
   uint8_t *data, *data2;
@@ -284,6 +285,15 @@ test_cipher_cfb(const struct nettle_cipher *cipher,
       fprintf(stderr, "\n");
       FAIL();
     }
+  if (!MEMEQ(cipher-&gt;block_size, iv, oiv-&gt;data))
+    {
+      fprintf(stderr, "CFB encrypt returned wrong IV:\nOutput:");
+      print_hex(cipher-&gt;block_size, iv);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(oiv);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
   cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
   memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
 
@@ -302,6 +312,15 @@ test_cipher_cfb(const struct nettle_cipher *cipher,
       fprintf(stderr, "\n");
       FAIL();
     }
+  if (!MEMEQ(cipher-&gt;block_size, iv, oiv-&gt;data))
+    {
+      fprintf(stderr, "CFB decrypt returned wrong IV:\nOutput:");
+      print_hex(cipher-&gt;block_size, iv);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(oiv);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
   cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
   memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
   memcpy(data, cleartext-&gt;data, length);
@@ -428,7 +447,8 @@ test_cipher_cfb8(const struct nettle_cipher *cipher,
 		 const struct tstring *key,
 		 const struct tstring *cleartext,
 		 const struct tstring *ciphertext,
-		 const struct tstring *iiv)
+		 const struct tstring *iiv,
+		 const struct tstring *oiv)
 {
   void *ctx = xalloc(cipher-&gt;context_size);
   uint8_t *data, *data2;
@@ -462,6 +482,15 @@ test_cipher_cfb8(const struct nettle_cipher *cipher,
       fprintf(stderr, "\n");
       FAIL();
     }
+  if (!MEMEQ(cipher-&gt;block_size, iv, oiv-&gt;data))
+    {
+      fprintf(stderr, "CFB8 encrypt returned wrong IV:\nOutput:");
+      print_hex(cipher-&gt;block_size, iv);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(oiv);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
   cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
   memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
 
@@ -480,6 +509,15 @@ test_cipher_cfb8(const struct nettle_cipher *cipher,
       fprintf(stderr, "\n");
       FAIL();
     }
+  if (!MEMEQ(cipher-&gt;block_size, iv, oiv-&gt;data))
+    {
+      fprintf(stderr, "CFB8 decrypt returned wrong IV:\nOutput:");
+      print_hex(cipher-&gt;block_size, iv);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(oiv);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
   cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
   memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
   memcpy(data, cleartext-&gt;data, length);
diff --git a/testsuite/testutils.h b/testsuite/testutils.h
index f4ea38da..93db801b 100644
--- a/testsuite/testutils.h
+++ b/testsuite/testutils.h
@@ -127,14 +127,16 @@ test_cipher_cfb(const struct nettle_cipher *cipher,
 		const struct tstring *key,
 		const struct tstring *cleartext,
 		const struct tstring *ciphertext,
-		const struct tstring *iv);
+		const struct tstring *iiv,
+		const struct tstring *oiv);
 
 void
 test_cipher_cfb8(const struct nettle_cipher *cipher,
 		 const struct tstring *key,
 		 const struct tstring *cleartext,
 		 const struct tstring *ciphertext,
-		 const struct tstring *iv);
+		 const struct tstring *iiv,
+		 const struct tstring *oiv);
 
 void
 test_cipher_ctr(const struct nettle_cipher *cipher,
-- 
2.21.0


[Attachment #4 (text/x-patch)]

From 1820f8524c0476069c53c893a08cc1e432092a5e Mon Sep 17 00:00:00 2001
From: Daiki Ueno &lt;dueno@redhat.com&gt;
Date: Fri, 27 Sep 2019 16:12:00 +0200
Subject: [PATCH 2/2] cfb8: don't truncate output IV if input is shorter than
 block size

Previously cfb8_decrypt didn't update the IV if the input is shorter
than the AES block size.  Reported by Stephan Mueller.

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 cfb.c                | 10 ++++++----
 testsuite/cfb-test.c |  9 +++++++++
 2 files changed, 15 insertions(+), 4 deletions(-)

diff --git a/cfb.c b/cfb.c
index 5429fc9c..b9da3159 100644
--- a/cfb.c
+++ b/cfb.c
@@ -226,10 +226,12 @@ cfb8_decrypt(const void *ctx, nettle_cipher_func *f,
       src += i;
       dst += i;
 
-      memcpy(buffer, buffer + block_size, block_size);
-      memcpy(buffer + block_size, src,
-	     length &lt; block_size ? length : block_size);
-
+      if (i == block_size)
+	{
+	  memcpy(buffer, buffer + block_size, block_size);
+	  memcpy(buffer + block_size, src,
+		 length &lt; block_size ? length : block_size);
+	}
     }
 
   memcpy(iv, buffer + i, block_size);
diff --git a/testsuite/cfb-test.c b/testsuite/cfb-test.c
index 7c42bec5..02bc63cc 100644
--- a/testsuite/cfb-test.c
+++ b/testsuite/cfb-test.c
@@ -140,6 +140,15 @@ test_main(void)
 		   SHEX("000102030405060708090a0b0c0d0e0f"),
 		   SHEX("424c9c0dd436bace9e0ed4586a4f32b9"));
 
+  /* Check if the intermediate IV is updated correctly with input
+   * shorter than AES block size. */
+  test_cipher_cfb8(&amp;nettle_aes128,
+		   SHEX("2b7e151628aed2a6abf7158809cf4f3c"),
+		   SHEX("6bc1"),
+		   SHEX("3b79"),
+		   SHEX("000102030405060708090a0b0c0d0e0f"),
+		   SHEX("02030405060708090a0b0c0d0e0f3b79"));
+
   /* From NIST spec 800-38a on AES modes.
    *
    * F.3  CFB Example Vectors
-- 
2.21.0


[Attachment #5 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email><email><emailId>20191001085140</emailId><senderName>Daiki Ueno</senderName><senderEmail>ueno@gnu.org</senderEmail><timestampReceived>2019-10-01 08:51:40-0400</timestampReceived><subject>Re: [PATCH] cfb8: don't truncate output IV if input is shorter than block size</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Daiki Ueno &lt;ueno@gnu.org&gt; writes:
&gt;
&gt;&gt; We realized that cfb8_decrypt doesn't update the IV correctly when the
&gt;&gt; input is shorter than AES block size.  The attached patches should fix
&gt;&gt; it.
&gt;
&gt; For testing, I think it would be good to take the testvectors for cfb8,
&gt; and split into multiple calls to cfb8_*crypt, in several ways. And check
&gt; they all give the same result. A bit like it's done in arcfour-test.c,
&gt; or the test_cipher_stream (#if:ed out, not sure if it's worth reviving).

Indeed, thank you for the suggestion.  I'm attaching updated patches.

Regards,
-- 
Daiki Ueno

[Attachment #3 (text/x-patch)]

From 2f6c2be5ec9668dc7691e5bf9e54f8ef1dde1d87 Mon Sep 17 00:00:00 2001
From: Daiki Ueno &lt;dueno@redhat.com&gt;
Date: Fri, 27 Sep 2019 16:12:00 +0200
Subject: [PATCH 1/2] cfb8: don't truncate output IV if input is shorter than
 block size

Previously cfb8_decrypt didn't update the IV if the input is shorter
than the AES block size.  Reported by Stephan Mueller.

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 cfb.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/cfb.c b/cfb.c
index 5429fc9c..b9da3159 100644
--- a/cfb.c
+++ b/cfb.c
@@ -226,10 +226,12 @@ cfb8_decrypt(const void *ctx, nettle_cipher_func *f,
       src += i;
       dst += i;
 
-      memcpy(buffer, buffer + block_size, block_size);
-      memcpy(buffer + block_size, src,
-	     length &lt; block_size ? length : block_size);
-
+      if (i == block_size)
+	{
+	  memcpy(buffer, buffer + block_size, block_size);
+	  memcpy(buffer + block_size, src,
+		 length &lt; block_size ? length : block_size);
+	}
     }
 
   memcpy(iv, buffer + i, block_size);
-- 
2.21.0


[Attachment #4 (text/x-patch)]

From e96bb66747ffd1dff9bded6cdb69ba866dc20f01 Mon Sep 17 00:00:00 2001
From: Daiki Ueno &lt;dueno@redhat.com&gt;
Date: Tue, 1 Oct 2019 10:47:40 +0200
Subject: [PATCH 2/2] test: check all possible block sizes in test_cipher_cfb8

Signed-off-by: Daiki Ueno &lt;dueno@redhat.com&gt;
---
 testsuite/testutils.c | 77 ++++++++++++++++++++++++++-----------------
 1 file changed, 46 insertions(+), 31 deletions(-)

diff --git a/testsuite/testutils.c b/testsuite/testutils.c
index 2a19c0ac..b24b498a 100644
--- a/testsuite/testutils.c
+++ b/testsuite/testutils.c
@@ -434,6 +434,7 @@ test_cipher_cfb8(const struct nettle_cipher *cipher,
   uint8_t *data, *data2;
   uint8_t *iv = xalloc(cipher-&gt;block_size);
   size_t length;
+  size_t block;
 
   ASSERT (cleartext-&gt;length == ciphertext-&gt;length);
   length = cleartext-&gt;length;
@@ -444,42 +445,56 @@ test_cipher_cfb8(const struct nettle_cipher *cipher,
   data = xalloc(length);
   data2 = xalloc(length);
 
-  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
-  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+  for (block = 1; block &lt;= length; block++)
+    {
+      size_t i;
 
-  cfb8_encrypt(ctx, cipher-&gt;encrypt,
-	      cipher-&gt;block_size, iv,
-	      length, data, cleartext-&gt;data);
+      cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+      memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
 
-  if (!MEMEQ(length, data, ciphertext-&gt;data))
-    {
-      fprintf(stderr, "CFB8 encrypt failed:\nInput:");
-      tstring_print_hex(cleartext);
-      fprintf(stderr, "\nOutput: ");
-      print_hex(length, data);
-      fprintf(stderr, "\nExpected:");
-      tstring_print_hex(ciphertext);
-      fprintf(stderr, "\n");
-      FAIL();
-    }
-  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
-  memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
+      for (i = 0; i + block &lt;= length; i += block)
+	{
+	  cfb8_encrypt(ctx, cipher-&gt;encrypt,
+		       cipher-&gt;block_size, iv,
+		       block, data + i, cleartext-&gt;data + i);
+	}
 
-  cfb8_decrypt(ctx, cipher-&gt;encrypt,
-	      cipher-&gt;block_size, iv,
-	      length, data2, data);
+      if (!MEMEQ(length, data, ciphertext-&gt;data))
+	{
+	  fprintf(stderr, "CFB8 encrypt failed, block size %lu:\nInput:",
+		  block);
+	  tstring_print_hex(cleartext);
+	  fprintf(stderr, "\nOutput: ");
+	  print_hex(length, data);
+	  fprintf(stderr, "\nExpected:");
+	  tstring_print_hex(ciphertext);
+	  fprintf(stderr, "\n");
+	  FAIL();
+	}
+      cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+      memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
 
-  if (!MEMEQ(length, data2, cleartext-&gt;data))
-    {
-      fprintf(stderr, "CFB8 decrypt failed:\nInput:");
-      tstring_print_hex(ciphertext);
-      fprintf(stderr, "\nOutput: ");
-      print_hex(length, data2);
-      fprintf(stderr, "\nExpected:");
-      tstring_print_hex(cleartext);
-      fprintf(stderr, "\n");
-      FAIL();
+      for (i = 0; i + block &lt;= length; i += block)
+	{
+	  cfb8_decrypt(ctx, cipher-&gt;encrypt,
+		       cipher-&gt;block_size, iv,
+		       block, data2 + i, data + i);
+	}
+
+      if (!MEMEQ(length, data2, cleartext-&gt;data))
+	{
+	  fprintf(stderr, "CFB8 decrypt failed, block size %lu:\nInput:",
+		  block);
+	  tstring_print_hex(ciphertext);
+	  fprintf(stderr, "\nOutput: ");
+	  print_hex(length, data2);
+	  fprintf(stderr, "\nExpected:");
+	  tstring_print_hex(cleartext);
+	  fprintf(stderr, "\n");
+	  FAIL();
+	}
     }
+
   cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
   memcpy(iv, iiv-&gt;data, cipher-&gt;block_size);
   memcpy(data, cleartext-&gt;data, length);
-- 
2.21.0


[Attachment #5 (text/plain)]

_______________________________________________
nettle-bugs mailing list
nettle-bugs@lists.lysator.liu.se
http://lists.lysator.liu.se/mailman/listinfo/nettle-bugs


</body></email></emails>