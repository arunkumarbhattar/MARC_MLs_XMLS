<?xml version="1.0" encoding="utf-8"?>
<emails><email><emailId>20140313174722</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-13 17:47:22-0400</timestampReceived><subject>Release plans</subject><body>

There are now a couple of points left on the todo list for the next
release (see http://www.lysator.liu.se/~nisse/nettle/plan.html).
Basically:

* Complete the dsa reorg (I'd appreciate all comments on that).

* Make the nettle_cipher abstraction use a const context argument for
  encrypt and decrypt.

* Documentation updates.

This is going to be quite a large number of incompatible changes. I
think it makes sense to name the new release 3.0, and announce it as a
"typical" dot-zero release, which can be expected to have some serious.

To fix reported issues, we may need a 3.1 releqase reasonably soon after
3.0, and if required, 3.1 may include additional API or ABI fixes,
together with new features. After 3.1, we should get back into a more
normal development, and maintain backwards compatibility.

I think this will also be a good time to upgrade the license (currently
LGPLv2 or later) to a dual license, LGPLv3 or later, or GPLv2 or later.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140318210631</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-18 21:06:31-0400</timestampReceived><subject>Re: Release plans</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; * Complete the dsa reorg (I'd appreciate all comments on that).

Not much comments on these issues. I'm now leaning towards a split into
dsa.h with the new interface (and unchanged pieces, like struct
dsa_signature), and a dsa-compat.h, with the old, deprecated, interface.
Both could be included, except that the meaning of the
dsa_generate_keypair symbol will change with dsa-compat.h.

&gt; * Make the nettle_cipher abstraction use a const context argument for
&gt;   encrypt and decrypt.

In the mean time, I've done this. There are two typedefs,
nettle_cipher_func (new, const ctx, used for the block ciphers), and
nettle_crypt_func (unchanged, used for aead algorithms).

For the benchmark, I represent the stream ciphers (arcfour, salsa20,
chacha) as nettle_aead structs, where the update and digest methods are
NULL (and also set_nonce NULL, in the case of arcfour). Maybe that
representation would make sense also for a public api, but I'll not add
that now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140824073020</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-08-24 07:30:20-0400</timestampReceived><subject>Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; * I added the ecc_point_mul and ecc_point_mul_g functions (but testcases
&gt;   missing).

These functions still lack testing. Does anyone here have suitable ecdh
test vectors (a bit like draft-turner-thecurve25519function-00, but for
the more traditional curves? Wikipedia points to
http://www.secg.org/download/aid-390/gec2.pdf, but that site appears to
be down at the moment.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140102205729</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-02 20:57:29-0400</timestampReceived><subject>Using side-channel silent GMP functions</subject><body>

For the next release of GMP, there will be some new public functions for
side-channel silent computations, as part of the low-level "mpn"
interface.

I think it would make sense to rewrite the RSA and DSA private key
operations to use side-channel silent functions. This might require
further interface changes; I haven't really looked into it yet, so I
don't know to which degree backwards compatibility can be kept.

I also don't yet know if it's practical to make use of the new functions
optional, or if it will make the latest GMP a strict requirement (unless
Nettle's public key support is completely disabled).

What do you think?

Relatedly, I've updated the release plan on
http://www.lysator.liu.se/~nisse/nettle/plan.html.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140131071645</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-31 07:16:45-0400</timestampReceived><subject>Re: Curve25519</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; It seems it is being pushed forward and openssh even uses it by default
&gt; now.  There are implementations like [0] that nettle could take
&gt; advantage to use that curve, but what I'm worried about is that the
&gt; current interfaces to use this curve provide no agility.

I think you're more familier with its uses than I am. I'm thinking that it
would be nice to have a 

  struct ecc_curve nettle_curve25519;

with the same operations (ecc_point_mul, etc), but maybe a very
different implementation underneath.

Is that enough? It's not clear to me how people do signatures with
curve25519, if that's plain ecdsa over a new curve, or something more or
less different?

Will people also want djb's curve25519 function, defined with octet
strings as input and output?

Are there any authoritative testvectors?

And about the "safe" curves listed at http://safecurves.cr.yp.to/,
anything beyond curve25519 which is being deployed? M-383, Curve41417,
M-511 or E-521?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140213160433</emailId><senderName>Stefan =?UTF-8?B?QsO8aGxlcg==?=</senderName><senderEmail>nettle-bugs@stbuehler.de</senderEmail><timestampReceived>2014-02-13 16:04:33-0400</timestampReceived><subject>chacha set-key naming</subject><body>

Hi,

I probably won't convince you anymore, so feel free to ignore this :)
Anyway, I just wanted to say that

#define CHACHA128_KEY_SIZE 16
#define CHACHA256_KEY_SIZE 32
[...]
void
chacha128_set_key(struct chacha_ctx *ctx, const uint8_t *key);
void
chacha256_set_key(struct chacha_ctx *ctx, const uint8_t *key);

looks horribly wrong to me. There is no "Chacha128" nor "Chacha256"; 
given that the standard naming scheme interprets a number after 
"Chacha" as number of rounds... well, this is just wrong.
Forcing the AES naming onto other stuff is just not a good idea 
imho.

My preference, if you want to have a fixed length in the name, is 
still "chacha_set_key128" and similar. Not sure about 
"chacha_128_set_key", "chacha20_128_set_key", ...


As a side note: the paper for Chacha only mentions the 256-bit key 
variant, although the reference implementation also provides 
the 128-bit variant...
So I'm not sure whether the 128-bit variant was actually intended 
being used at all.

regards,
Stefan

</body></email><email><emailId>20140402131950</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-04-02 13:19:50-0400</timestampReceived><subject>Re: nettle-mini</subject><body>

On Mon, Mar 10, 2014 at 9:28 AM, Nikos Mavrogiannopoulos
&lt;n.mavrogiannopoulos@gmail.com&gt; wrote:
&gt; Hello,
&gt;  I have put in
&gt; https://github.com/nmav/nettle-mini/tree/gmp-mini
&gt; a version of nettle that has an additional configure option. The
&gt; --enable-mini-gmp. This will compile libghoweed using mini-gmp thus
&gt; allowing nettle to be used in space constrained systems. Note that
&gt; using nettle with mini-gmp instead of gmp imposes a penalty of around
&gt; 10x, and may leak more information due to side-channels (this should
&gt; not be the case for RSA as blinding is performed in hogweed, but I
&gt; haven't checked the other algorithms).

I've now have nettle-mini for both master and 2.7. The patches
required for master are gmp-mini branch and for 2.7 in
nettle-2.7-mini-gmp. What I haven't tried is combining nettle and
hogweed in a single library when in mini mode. I believe the savings
should be negligible in modern embedded systems, and will cause
practical issues as it will be harder to determine which library to
link with.

I'd appreciate if these go upstream as I've failed to add nettle to
openwrt (and don't have to time to pursue that further), so I no
longer plan to maintain these patches separately (and they will be
easily break on makefile changes).

regards,
Nikos

</body></email><email><emailId>20140505212702</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-05 21:27:02-0400</timestampReceived><subject>Documentation update</subject><body>

I've spent some time the last few days updating the manual. Feedback
appreciated, in particular on the new sections on the new DSA interface,
AEAD algorithms, chacha and poly1305. Also some smaller documentation
updates on Salsa20, GCM and CCM.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140601205935</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-01 20:59:35-0400</timestampReceived><subject>Re: Problem with assembly functions on w64</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; It fails make check; several assembly functions crash on w64, also in
&gt; the --disable-shared case. I haven't yet looked closer, but I suspect
&gt; that's some simple bug in the register shuffling done to support the w64
&gt; calling convention.

Fixed now. Passes make check for me (in my mingw + wine cross
environment), for both shared and static libraries. It would be nice if
someone with a real 64-bit windows box could confirm that it works.

I've updated the release status at
http://www.lysator.liu.se/~nisse/nettle/plan.html, and it's getting
closer. It would be nice if someone could give it a try also on macos
(as well as on any other systems that I don't test on myself).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140711172703</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2014-07-11 17:27:03-0400</timestampReceived><subject>[PATCH] fix typo in ecc-mod.c</subject><body>

---
 ecc-mod.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ecc-mod.c b/ecc-mod.c
index 7876d02..3301506 100644
--- a/ecc-mod.c
+++ b/ecc-mod.c
@@ -40,7 +40,7 @@
 #include "ecc-internal.h"
 
 /* Computes r mod m, where m is of size mn. bp holds B^mn mod m, as mn
-   limbs, but the upper mn - bn libms are zero. */
+   limbs, but the upper mn - bn limbs are zero. */
 void
 ecc_mod (mp_limb_t *rp, mp_size_t rn, mp_size_t mn,
 	 const mp_limb_t *bp, mp_size_t bn,
-- 
2.0.0


</body></email><email><emailId>20140602082922</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2014-06-02 08:29:22-0400</timestampReceived><subject>Re: Problem with assembly functions on w64</subject><body>


On Sun, 1 Jun 2014, Niels Möller wrote:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt; It fails make check; several assembly functions crash on w64, also in
&gt;&gt; the --disable-shared case. I haven't yet looked closer, but I suspect
&gt;&gt; that's some simple bug in the register shuffling done to support the w64
&gt;&gt; calling convention.
&gt;
&gt; Fixed now. Passes make check for me (in my mingw + wine cross
&gt; environment), for both shared and static libraries. It would be nice if
&gt; someone with a real 64-bit windows box could confirm that it works.
&gt;
&gt; I've updated the release status at
&gt; http://www.lysator.liu.se/~nisse/nettle/plan.html, and it's getting
&gt; closer. It would be nice if someone could give it a try also on macos
&gt; (as well as on any other systems that I don't test on myself).

I've tested the latest git version on real windows (both 32 and 64 bit), 
OS X (both 32 and 64 bit), and on linux on arm (both armv6 and armv7 
devices), and didn't run into any issues.

// Martin

</body></email><email><emailId>20140602084553</emailId><senderName>Martin_Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2014-06-02 08:45:53-0400</timestampReceived><subject>Re: Problem with assembly functions on w64</subject><body>


On Mon, 2 Jun 2014, Martin Storsjö wrote:

&gt; On Sun, 1 Jun 2014, Niels Möller wrote:
&gt;
&gt;&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;&gt; 
&gt;&gt;&gt; It fails make check; several assembly functions crash on w64, also in
&gt;&gt;&gt; the --disable-shared case. I haven't yet looked closer, but I suspect
&gt;&gt;&gt; that's some simple bug in the register shuffling done to support the w64
&gt;&gt;&gt; calling convention.
&gt;&gt; 
&gt;&gt; Fixed now. Passes make check for me (in my mingw + wine cross
&gt;&gt; environment), for both shared and static libraries. It would be nice if
&gt;&gt; someone with a real 64-bit windows box could confirm that it works.
&gt;&gt; 
&gt;&gt; I've updated the release status at
&gt;&gt; http://www.lysator.liu.se/~nisse/nettle/plan.html, and it's getting
&gt;&gt; closer. It would be nice if someone could give it a try also on macos
&gt;&gt; (as well as on any other systems that I don't test on myself).
&gt;
&gt; I've tested the latest git version on real windows (both 32 and 64 bit), OS X 
&gt; (both 32 and 64 bit), and on linux on arm (both armv6 and armv7 devices), and 
&gt; didn't run into any issues.

To clarify - I ran "make check" and all tests passed, and these were 
shared builds (including GMP), not static.

// Martin

</body></email><email><emailId>20140729145133</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-07-29 14:51:33-0400</timestampReceived><subject>curve25519 progress</subject><body>

I've now pushed some crude code (on the curve25519 branch) which agrees
with the test vectors in draft-josefsson-tls-curve25519-05.

It uses the equivalent Edwards curve for the internal operations. For
scalar multiplication of the fix generator, it uses Pippenger's
algorithm and tables very similar to the other curves, just with
different point operations and no special caes (since the Edwards
operations are "complete"). At the end, the x-coordinate of the
corresponding point on the Montgomery-form curve25519 is computed.

For scalar multiplication of an arbitrary point (with only x coordinate
provided), I first have to compute the y-coordinate using
Shanks-Tonelli (this could be used to implement "point compression") also
for other curves). Then transform to a point on the Edwards curve, using
homogeneneous/projective coordinates. Then the actual scalar multiply is
currently done with the binary algorithm; I have code for window-based
scalar multiply, but it needs a bit more debugging. All this is very
similar to the other corves, but without special cases.

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140729201339</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2014-07-29 20:13:39-0400</timestampReceived><subject>Re: curve25519 progress</subject><body>

You wrote:

&gt; I've now pushed some crude code (on the curve25519 branch) which
&gt; agrees with the test vectors in draft-josefsson-tls-curve25519-05.

Wonderful.   There is another document coming out (describing the
Curve25519 algo only) which contains test vectors from the NaCl library
as well, including them would be good.

/Simon

</body></email><email><emailId>20140729212755</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-07-29 21:27:55-0400</timestampReceived><subject>Re: curve25519 progress</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Wonderful.   There is another document coming out (describing the
&gt; Curve25519 algo only) which contains test vectors from the NaCl library
&gt; as well, including them would be good.

URL?

I have a couple of questions ragarding curve25519.

1. The input of the curve255519 function is the x coordiante only. I
   compute the y cordinate, via a square root. This might fail... I
   don't really understand Theorem 2.1 in the curve25519 paper, but it
   seems to indicate that for curve25519 to be defined for arbitrary x,
   one needs to consider coordinates in the extended field

     x = x_0 + x_1 sqrt(2)
     y = y_0 + y_1 sqrt(2)

   Obviously I don't want to do this. I think one can get away with
   treating x inputs where the square root fails as invalid. That
   shouldn't happen for public keys computed according to the spec.

   Are there any testcases for such questionable inputs?

2. API for the curve25519 function. I think I sent a mail about this
   previously. Should it be a single function (with some magic
   optimization for the input x == 9), or two functions? What do the
   NaCl and Sodium libraries do, and do they get it right?

3. I haven't yet figured out how to do the user-api using struct
   ecc_curve. I think I'll have to make functions like ecc_mul_g and
   ecc_mul_a go via function pointers in this struct, and also some
   abstract functions for converting points to and from an unspecified
   internal coordinate representation, which will be jacobian or
   edwards, with or without redc.

   Internal functions like ecc_add_jja have to move from ecc.h to
   ecc-internal.h, and there maybe some new more abstract functions for
   operating on points, regardless of internal coordinate
   representation.

4. Also, things need to be organized so that curve2519 and EdDSA can
   share the internals in a clean way. Maybe there could be two struct
   ecc_curve for the two equivalent curves, which differ only in
   conversions done on input and output.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140829122748</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-08-29 12:27:48-0400</timestampReceived><subject>eddsa progress (was: Re: curve25519 progress)</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Things I'd like to do, besides optimizations:
&gt;
&gt; * Switch from the plain Edwards curve to the twist used for Ed25519.
&gt;   Should be pretty a small change.

Done (but not yet pushed to the public repo). With only minor changes to
the addition formulas, not yet using the new optimizations which become
possible with this curve.

&gt; * Implement Ed25519 signatures.

This is the next thing to do, I think, before turning to optimizations.
If anyone knows some eddsa25519 test vectors, that would be great. The
paper doesn't include any.

&gt; * Make the ecdsa code work over curve25519. Not that I'd expect anyone
&gt;   to use ecdsa over that curve, but I think it's useful for validating
&gt;   the generality of the ecc interface, and maybe for benchmarking.

Works now, and with little impact on the normal use of ecdsa (for a
while I feared it would add useless overhead for operatinos using the
other curves, which I find inappropriate).

&gt; * Review the public interface, moving functions which depend on the type
&gt;   of curve out of ecc.h into ecc-internal.h.

Not started, but I'm getting a better idea of how it should look like.

Also, I think I'll replace

  struct ecc_curve nettle_curve25519;

by

  struct ecc_curve nettle_ed25519; /* or whatever name is appropriate */

since this curve is what's really implemented, and it's better defined.
The spec for curve25519 doesn't define the sign of the generator (which
is the sign of the y coordinate) so to provide ecc operations that
involve the y coordiante as input or output, I have to choose a sign,
and that can't be expected to interoperate with anything else anyway.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140729220938</emailId><senderName>James Cloos</senderName><senderEmail>cloos@jhcloos.com</senderEmail><timestampReceived>2014-07-29 22:09:38-0400</timestampReceived><subject>Re: curve25519 progress</subject><body>

&gt;&gt;&gt;&gt;&gt; "NM" == Niels Möller &lt;nisse@lysator.liu.se&gt; writes:

SJ&gt;&gt; Wonderful.  There is another document coming out (describing the
SJ&gt;&gt; Curve25519 algo only) which contains test vectors from the NaCl
SJ&gt;&gt; library as well, including them would be good.

NM&gt; URL?

Presumably Sean Turner's draft-turner-thecurve25519function-00.txt

He has a copy at https://seanturner/draft-turner-thecurve25519function

Based on that, it does not look like sqrt is ever required?

-JimC
-- 
James Cloos &lt;cloos@jhcloos.com&gt;         OpenPGP: 0x997A9F17ED7DAEA6

</body></email><email><emailId>20140729225838</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2014-07-29 22:58:38-0400</timestampReceived><subject>Re: curve25519 progress</subject><body>

The URL is:
http://tools.ietf.org/html/draft-turner-thecurve25519function-00

/Simon

You wrote:

&gt; &gt;&gt;&gt;&gt;&gt; "NM" == Niels Möller &lt;nisse@lysator.liu.se&gt; writes:
&gt; 
&gt; SJ&gt;&gt; Wonderful.  There is another document coming out (describing the
&gt; SJ&gt;&gt; Curve25519 algo only) which contains test vectors from the NaCl
&gt; SJ&gt;&gt; library as well, including them would be good.
&gt; 
&gt; NM&gt; URL?
&gt; 
&gt; Presumably Sean Turner's draft-turner-thecurve25519function-00.txt
&gt; 
&gt; He has a copy at https://seanturner/draft-turner-thecurve25519function
&gt; 
&gt; Based on that, it does not look like sqrt is ever required?
&gt; 
&gt; -JimC


</body></email><email><emailId>20140729230330</emailId><senderName>James Cloos</senderName><senderEmail>cloos@jhcloos.com</senderEmail><timestampReceived>2014-07-29 23:03:30-0400</timestampReceived><subject>Re: curve25519 progress</subject><body>

&gt;&gt;&gt;&gt;&gt; "JC" == James Cloos &lt;cloos@jhcloos.com&gt; writes:

JC&gt; Based on that, it does not look like sqrt is ever required?

Sorry, I wrote that w/o considering mont-&gt;ed conversion.  ☹

Does using edwards rather than the pocedure in the draft improve things?

-JimC
-- 
James Cloos &lt;cloos@jhcloos.com&gt;         OpenPGP: 0x997A9F17ED7DAEA6

</body></email><email><emailId>20140730060338</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-07-30 06:03:38-0400</timestampReceived><subject>Re: curve25519 progress</subject><body>

James Cloos &lt;cloos@jhcloos.com&gt; writes:

&gt; Does using edwards rather than the pocedure in the draft improve things?

I'm not sure, but at least it makes it easier to use precomputed tables.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140803151018</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-08-03 15:10:18-0400</timestampReceived><subject>Re: curve25519 progress</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I have a couple of questions regarding curve25519.

I can answer a few of them myself now.

&gt; 1. The input of the curve255519 function is the x coordiante only. I
&gt;    compute the y cordinate, via a square root. This might fail... I
&gt;    don't really understand Theorem 2.1 in the curve25519 paper, but it
&gt;    seems to indicate that for curve25519 to be defined for arbitrary x,
&gt;    one needs to consider coordinates in the extended field
&gt;
&gt;      x = x_0 + x_1 sqrt(2)
&gt;      y = y_0 + y_1 sqrt(2)

Doing these coordinates in the extended field just tacks on the factor
sqrt(2) on the y coordinates (and similarly to one of the cooordinates
of the corresponding Edwards curve), and in this special case, that's
equivalent to working on a "twist" curve over the base field F_p.

Probably not too painful to implement, but unclear if it's worth the effort.

&gt;    Are there any testcases for such questionable inputs?

This question remains, as well as the question of interesting usecases.

&gt; 2. API for the curve25519 function. I think I sent a mail about this
&gt;    previously. Should it be a single function (with some magic
&gt;    optimization for the input x == 9), or two functions? What do the
&gt;    NaCl and Sodium libraries do, and do they get it right?

See http://nacl.cr.yp.to/scalarmult.html. It's two functions,

  crypto_scalarmult(q,n,p);

and

  crypto_scalarmult_base(q,n);

I think nettle should use some different names (unless, maybe, some
curve25519-compat.h file is included). But I think we can use the same
arguments. If we don't implement points with y coordinates outside of the
base field, the crypto_scalarmult function needs a return value, to
indicate success or failure.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140818204806</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-08-18 20:48:06-0400</timestampReceived><subject>Re: curve25519 progress</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; See http://nacl.cr.yp.to/scalarmult.html. It's two functions,
&gt;
&gt;   crypto_scalarmult(q,n,p);
&gt;
&gt; and
&gt;
&gt;   crypto_scalarmult_base(q,n);
&gt;
&gt; I think nettle should use some different names (unless, maybe, some
&gt; curve25519-compat.h file is included). But I think we can use the same
&gt; arguments. If we don't implement points with y coordinates outside of the
&gt; base field, the crypto_scalarmult function needs a return value, to
&gt; indicate success or failure.

Implemented now. The two functions are called curve25519_mul and
curve25519_mul_g. The former has a return value, returning failure if
the y-coordinate of the given point doesn't belong to the base field
(i.e., sqrt fails). Passes the test vectors in
http://tools.ietf.org/html/draft-turner-thecurve25519function-00.

The square-root computation done by curve25519_mul is *not* side-channel
silent. That could be fixed, but it's not clear to me if that's needed.
At least in the DH usecase, the input to the square root is a *public*
key, so there's no reason to make efforts to hide it.

Still on the curve25519 branch, but maybe it can be merged soon. Testing
and feedback highly appreciated.

Next steps are:

1. Extending struct ecc_curve with more function pointers to support
   other curves. Review the set of public ecc functions.

2. Benchmarking code.

3. EdDSA (where can I find test vectors for that?).

4. curve25519-specific assembly optimizations. One candidate is an
   modp_sqr which does the squaring and the reduction all in registers.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140506084054</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-05-06 08:40:54-0400</timestampReceived><subject>Re: Documentation update</subject><body>

On Mon, May 5, 2014 at 11:27 PM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wrot=
e:
&gt; I've spent some time the last few days updating the manual. Feedback
&gt; appreciated, in particular on the new sections on the new DSA interface,
&gt; AEAD algorithms, chacha and poly1305. Also some smaller documentation
&gt; updates on Salsa20, GCM and CCM.

Hello Niels,
 Very nice work. Some comments bellow.


SHA3-224 section: I'd provide a reference to
http://csrc.nist.gov/publications/drafts/fips-202/fips_202_draft.pdf,
since it is now published.

I don't see any test vectors to verify but note that the document
says: "The four SHA-3 hash functions differ slightly from the
instances of KECCAK that were proposed for the SHA-3 competition [3].
In particular, two additional bits are appended to the messages, in
order to distinguish the SHA-3 hash functions from the SHA-3 XOFs, and
to facilitate the development of new variants of the SHA-3 functions
that can be dedicated to individual application domains. The mechanism
for achieving these goals is called domain separation".


Camellia: I'd add "Camellia is one of the selected algorithms in the
New European Schemes for Signatures, Integrity and Encryption (NESSIE)
project". https://www.cosic.esat.kuleuven.be/nessie/deliverables/press_rele=
ase_feb27.pdf


Galois counter mode: (see Keyed hash functions... parenthesis doesn't close=
.


ChaCha-Poly1305: If you plan a release soon, I'd suggest not to
include that yet. There is no document you can refer to and the latest
draft document we have already differs from the implementation.
(see http://tools.ietf.org/html/draft-nir-cfrg-chacha20-poly1305-02 )


Traditional Nettle Soup: I never knew there was such a thing :)

regards,
Nikos

</body></email><email><emailId>20140625205931</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-25 20:59:31-0400</timestampReceived><subject>Re: nettle-mini</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt;  I have put in
&gt; https://github.com/nmav/nettle-mini/tree/gmp-mini
&gt; a version of nettle that has an additional configure option. The
&gt; --enable-mini-gmp. This will compile libghoweed using mini-gmp thus
&gt; allowing nettle to be used in space constrained systems.

I've done this a bit differently, but I've now pushed an
--enable-mini-gmp option on the master branch. Testing appreciated.

Happy hacking,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140626145917</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-06-26 14:59:17-0400</timestampReceived><subject>Re: nettle-mini</subject><body>

On Wed, Jun 25, 2014 at 10:59 PM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wro=
te:
&gt; I've done this a bit differently, but I've now pushed an
&gt; --enable-mini-gmp option on the master branch. Testing appreciated.

I haven't tested with gnutls, as I still need to convert it to use the
new API, but a small patch is attached which makes hogweed-benchmark
to run on Fedora and RHEL (that don't include the SECP-224 and 192
curves).


regards,
Nikos

["0001-hogweed-benchmark-do-not-abort-if-an-openssl-algorit.patch" (text/x-patch)]

From 8e7cc18058a7525ed2d9310455d5576ffa780138 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Thu, 26 Jun 2014 16:56:08 +0200
Subject: [PATCH] hogweed-benchmark: do not abort() if an openssl algorithm
 isn't available

---
 examples/hogweed-benchmark.c | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/examples/hogweed-benchmark.c b/examples/hogweed-benchmark.c
index 311fa2d..b9dca3d 100644
--- a/examples/hogweed-benchmark.c
+++ b/examples/hogweed-benchmark.c
@@ -146,6 +146,11 @@ bench_alg (const struct alg *alg)
   void *ctx;
 
   ctx = alg-&gt;init(alg-&gt;size);
+  if (ctx == NULL)
+    {
+      printf("%15s %4d N/A\n", alg-&gt;name, alg-&gt;size);
+      return;
+    }
 
   sign = time_function (alg-&gt;sign, ctx);
   verify = time_function (alg-&gt;verify, ctx);
@@ -604,7 +609,10 @@ bench_openssl_ecdsa_init (unsigned size)
     default:
       die ("Internal error.\n");
     }
-  assert (ctx-&gt;key);
+
+  /* This curve isn't supported in this build of openssl */
+  if (ctx-&gt;key == NULL)
+    return NULL;
 
   if (!EC_KEY_generate_key( ctx-&gt;key))
     die ("Openssl EC_KEY_generate_key failed.\n");
-- 
1.9.3



</body></email><email><emailId>20140213205344</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-13 20:53:44-0400</timestampReceived><subject>Re: chacha set-key naming</subject><body>

Stefan Bühler &lt;nettle-bugs@stbuehler.de&gt; writes:

&gt; My preference, if you want to have a fixed length in the name, is 
&gt; still "chacha_set_key128" and similar. Not sure about 
&gt; "chacha_128_set_key", "chacha20_128_set_key", ...

Thanks for the feedback.

&gt; As a side note: the paper for Chacha only mentions the 256-bit key 
&gt; variant, 

Interesting, I hadn't noticed that. 

&gt; although the reference implementation also provides the 128-bit
&gt; variant... 

But the reference code really is very close to salsa20, it even uses
"salsa20" in the name of one if the internal functions.

&gt; So I'm not sure whether the 128-bit variant was actually
&gt; intended being used at all.

Does anyone else know of use or interest in 128-bit chacha keys? It
would definitely make things a bit simpler if we can omit support for
128-bit keys. (And if we skip it now, we could of course reintroduce it
later if it turns out to be needed).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140304134043</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-04 13:40:43-0400</timestampReceived><subject>Re: chacha set-key naming</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Does anyone else know of use or interest in 128-bit chacha keys? It
&gt; would definitely make things a bit simpler if we can omit support for
&gt; 128-bit keys. (And if we skip it now, we could of course reintroduce it
&gt; later if it turns out to be needed).

For now, I've deleted the support for 128-bit chacha keys. And replaced
the "chacha256_" prefixes by "chacha_".

Not sure what to do about 96-bit nonces. I think I'll leave that for
now, and maybe introduce a chacha_set_xnonce later in case both
nonce-sizes needs to be supported.

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140304140703</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-03-04 14:07:03-0400</timestampReceived><subject>Re: chacha set-key naming</subject><body>

On Tue, Mar 4, 2014 at 2:40 PM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wrote=
:

&gt;&gt; Does anyone else know of use or interest in 128-bit chacha keys? It
&gt;&gt; would definitely make things a bit simpler if we can omit support for
&gt;&gt; 128-bit keys. (And if we skip it now, we could of course reintroduce it
&gt;&gt; later if it turns out to be needed).
&gt; For now, I've deleted the support for 128-bit chacha keys. And replaced
&gt; the "chacha256_" prefixes by "chacha_".
&gt; Not sure what to do about 96-bit nonces. I think I'll leave that for
&gt; now, and maybe introduce a chacha_set_xnonce later in case both
&gt; nonce-sizes needs to be supported.

It has not been approved yet, but the latest TLS proposal for chacha
is with 96-bit nonces and there is no plan to change. So at least for
gnutls only the 96-bit nonce version is relevant.

regards,
Nikos

</body></email><email><emailId>20140304142337</emailId><senderName>Stefan =?UTF-8?B?QsO8aGxlcg==?=</senderName><senderEmail>nettle-bugs@stbuehler.de</senderEmail><timestampReceived>2014-03-04 14:23:37-0400</timestampReceived><subject>Re: chacha set-key naming</subject><body>

Hi,

On Tue, 4 Mar 2014 15:07:03 +0100
Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; wrote:

&gt; It has not been approved yet, but the latest TLS proposal for chacha
&gt; is with 96-bit nonces and there is no plan to change. So at least for
&gt; gnutls only the 96-bit nonce version is relevant.

I did propose using XChaCha (similar to XSalsa20) to support larger
nonces (especially the AEAD recommended 96-bit length), and sticking
with plain ChaCha for 64-bit nonces (and allowing them):

http://www.ietf.org/mail-archive/web/cfrg/current/msg04310.html

There should have been a CFRG meeting yesterday, and perhaps it was
discussed, but I didn't get any feedback on it yet.
If anyone (Nikos?) can report on that I'd be glad to hear about it :)

regards,
Stefan

</body></email><email><emailId>20140131090355</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-01-31 09:03:55-0400</timestampReceived><subject>Re: Curve25519</subject><body>

On Fri, Jan 31, 2014 at 8:16 AM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wrot=
e:

&gt; I think you're more familier with its uses than I am. I'm thinking that i=
t
&gt; would be nice to have a
&gt;   struct ecc_curve nettle_curve25519;
&gt; with the same operations (ecc_point_mul, etc), but maybe a very
&gt; different implementation underneath.

That sounds very good.

&gt; Is that enough? It's not clear to me how people do signatures with
&gt; curve25519, if that's plain ecdsa over a new curve, or something more or
&gt; less different?

No signatures. It is only used for ECDH.

&gt; Will people also want djb's curve25519 function, defined with octet
&gt; strings as input and output?

I don't know. I am mostly interested for:
https://tools.ietf.org/html/draft-josefsson-tls-curve25519-04

which includes a test vector.

&gt; And about the "safe" curves listed at http://safecurves.cr.yp.to/,
&gt; anything beyond curve25519 which is being deployed? M-383, Curve41417,
&gt; M-511 or E-521?

There is some discussion in CFRG which will probably end-up in a draft
but I don't really follow up.

regards,
Nikos

</body></email><email><emailId>20140201090439</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2014-02-01 09:04:39-0400</timestampReceived><subject>Re: Curve25519</subject><body>

You wrote:

&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt; &gt; It seems it is being pushed forward and openssh even uses it by
&gt; &gt; default now.  There are implementations like [0] that nettle could
&gt; &gt; take advantage to use that curve, but what I'm worried about is
&gt; &gt; that the current interfaces to use this curve provide no agility.
&gt; 
&gt; I think you're more familier with its uses than I am. I'm thinking
&gt; that it would be nice to have a 
&gt; 
&gt;   struct ecc_curve nettle_curve25519;
&gt; 
&gt; with the same operations (ecc_point_mul, etc), but maybe a very
&gt; different implementation underneath.

If that is implementable, and sufficient to do ECDH, I think this would
be nice.  Is there any generic (EC)DH interface in nettle?  Maybe
having one would be useful, although maybe the EC math operations in
different curves is sufficient.

&gt; Is that enough? It's not clear to me how people do signatures with
&gt; curve25519, if that's plain ecdsa over a new curve, or something more
&gt; or less different?

There are multiple options, see Ed25519 for a new signing system
EdDSA.  It has some nicer properties than ECDSA but it is also a bit
hardcoded to that curve.  http://ed25519.cr.yp.to/

I don't think it makes sense to add anything about signing in nettle for
new curves until there are practical use cases.  Things are changing
quickly in this space.

/Simon

</body></email><email><emailId>20140702082455</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-07-02 08:24:55-0400</timestampReceived><subject>curve25519</subject><body>

I'v started to look closer at curve25519, and I've added support for it
in the eccdata program.

For the ecc operations, my current thinking is that one should use the
Edwards curve equivalence outlined in
http://cr.yp.to/papers.html#newelliptic, rather than the Montgomery
x-coordinate method suggested in the curve25519 paper. The x-coordinate
method needs an addition chain with additional values, which is a bit
alien to all other scalar ecc multiplication in Nettle. The equivalent
Edwards curve is

   x^2 + y^2 = 1 + (121665/121666) x^2 y^2 (mod p).
           
Computations should be about as fast (according to the paper), and since
the constant (121665/121666) is a non-square, the formulas are
"complete", with no need to handle any special cases.

One needs conversion of the coordinates, and one also needs a square
root to get the y coordinate, but I hope that shouldn't be too
difficult.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140309073805</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-09 07:38:05-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt;
&gt;&gt; In the master branch you break the ABI anyway, so it may be a good time
&gt;&gt; to introduce that. Otherwise you may simply introduce new functions for
&gt;&gt; the new structures and leave the old API intact.
&gt;
&gt; I think I can do that *almost* without breaking source-level
&gt; compatibility. API draft:
&gt;
&gt; New structs:
&gt;
&gt;   struct dsa_params
&gt;   {  
&gt;     /* Modulo */
&gt;     mpz_t p;
&gt;   
&gt;     /* Group order */
&gt;     mpz_t q;
&gt;   
&gt;     /* Generator */
&gt;     mpz_t g;
&gt;   };
&gt;
&gt;   struct dsa_value
&gt;   {
&gt;     const struct dsa_params *params;
&gt;     /* For private keys, represents an exponent (0 &lt; x &lt; q). For public
&gt;        keys, represents a group element, 0 &lt; x &lt; p) */
&gt;     mpz_t x;
&gt;   };           

I have now implemented this and pushed it to the dsa-reorg branch in the
repo. Comments appreciated.

It remains to convert the function that convert dsa keys to and from
strings using sexp or asn.1 der formatting. I'm not sure if we need to
maintain any source-level backwards compatibility there. And to add
tests using the new interface.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140311202723</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-11 20:27:23-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt;
&gt;&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt;&gt;
&gt;&gt;&gt; In the master branch you break the ABI anyway, so it may be a good time
&gt;&gt;&gt; to introduce that. Otherwise you may simply introduce new functions for
&gt;&gt;&gt; the new structures and leave the old API intact.
&gt;&gt;
&gt;&gt; I think I can do that *almost* without breaking source-level
&gt;&gt; compatibility. API draft:
&gt;&gt;
&gt;&gt; New structs:
&gt;&gt;
&gt;&gt;   struct dsa_params
&gt;&gt;   {  
&gt;&gt;     /* Modulo */
&gt;&gt;     mpz_t p;
&gt;&gt;   
&gt;&gt;     /* Group order */
&gt;&gt;     mpz_t q;
&gt;&gt;   
&gt;&gt;     /* Generator */
&gt;&gt;     mpz_t g;
&gt;&gt;   };
&gt;&gt;
&gt;&gt;   struct dsa_value
&gt;&gt;   {
&gt;&gt;     const struct dsa_params *params;
&gt;&gt;     /* For private keys, represents an exponent (0 &lt; x &lt; q). For public
&gt;&gt;        keys, represents a group element, 0 &lt; x &lt; p) */
&gt;&gt;     mpz_t x;
&gt;&gt;   };           
&gt;
&gt; I have now implemented this and pushed it to the dsa-reorg branch in the
&gt; repo. Comments appreciated.
&gt;
&gt; It remains to convert the function that convert dsa keys to and from
&gt; strings using sexp or asn.1 der formatting.

I've converted thse to the new api now (with no backwards
compatibility). Looking at
http://www.lysator.liu.se/~nisse/nettle/plan.html, the DSA interface is
one of the last API changes I'd like to complete before the release.

The current code (on the dsa-reorg branch) uses a struct dsa_params to
represent the group parameters p, q, and g. And a struct dsa_value
which holds a pointer to the parameters (a bit like the ecc functions)
and a single number, which can represent either a group element or an
exponent, depending on the context.

This makes it a bit unwieldy to read a key pair, since one needs to
initialize three different structs, for parameters, public key, and
private key. I think the old interface which puts the parameters and the
public key in the same struct is a bit easier in some common usecases.

Typical code, from pkcs1-conv.c

  static int
  convert_dsa_private_key(struct nettle_buffer *buffer, size_t length, const uint8_t *data)
  {
    struct dsa_params params;
    struct dsa_value pub;
    struct dsa_value priv;
    int res;
  
    dsa_params_init (&amp;params);
    dsa_value_init (&amp;pub, &amp;params);
    dsa_value_init (&amp;priv, &amp;params);
  
    if (dsa_openssl_private_key_from_der(&amp;params, &amp;pub, &amp;priv, 0,
  				       length, data))
      {
        /* Reuses the buffer */
        nettle_buffer_reset(buffer);
        res = dsa_keypair_to_sexp(buffer, NULL, &amp;pub, &amp;priv);
      }
    else
      {
        werror("Invalid OpenSSL private key.\n");
        res = 0;
      }
    dsa_value_clear (&amp;pub);
    dsa_value_clear (&amp;priv);
    dsa_params_clear (&amp;params);
    return res;
  }

What do you think? 

Is it possible to somehow provide a "all-in-one" interface for both
parameters and a public or private key, and have a separate parameter
struct (for the benefit of diffie-hellman use, or for keys using some
fixed predefined group), without lots of duplication?

It differs a bit from the ecc case, in that a common case is that the
dsa parameters are defined more or less dynamically at runtime, while
ecc curves are compile time constants.

One possibility might be to have all dsa functions take the dsa group
parameters and the actual key as separate function arguments. Then the
application is free to choose if it wants an all-in-one key struct like

struct dsa_public_key 
{ 
   struct dsa_params params;
   mpz_t y;
};

or something like the above dsa_value, or keep the params separately in
some other way. It would call the same nettle functions in either case.
Ant struct combining key and parameters would always be taken apart when
calling nettle functions; it would not appear in any nettle function
prototypes. At the moment, I think that is an attractive alternative.

A somewhat related question is that of backwards compatibility. The
current code maintains struct dsa_public_key and struct dsa_private_key
unchanged, and the sign and verify functions that use these types, for
some source level compatibility with existing code. Is that important or
not?

&gt; And to add tests using the new interface.

This still remains. In particular, the new key generation function.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140312201431</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-12 20:14:31-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; On Fri 2013-12-06 15:12:57 -0500, Niels Möller wrote:
&gt;
&gt;&gt; For DH, I don't think there's any particular reason to prefer to work in
&gt;&gt; a small subgroup. But I may be missing something, of course.
&gt;
&gt; I can think of a few, but i'm not sure how legitimate they are:

[...]

&gt; another might be efficiency of modular exponentiation: if you use
&gt; exponentiation by squaring, then the cost of calculating A' = g^A mod p
&gt; where A &lt; q should be O(log_2(q)) instead of O(log_2(p)) where A &lt; p.
&gt; So if q has half the bits of p, you'd halve the amount of computation.

And on the other hand, you just pointed out a potential problem on the
ietf-ssh mailing list:

  The selection of a discrete log group with a subgroup of targeted size q
  (instead of using a group with a safe prime modulus, which only allows
  subgroups of at worst (p-1)/2 if you exclude (p-1) as a valid public
  key) makes it costly to check whether the peer is forcing your shared
  secret into one of the other smaller subgroups.
  
If the subgroup is of prime size q, then you can check if an element x
belongs to that subgroup by checking that x^q = 1 (mod p). Right? Is
that too expensive? And that subgroup in turn has no proper subgroups.

Even with this additional check, it could be significantly faster than
using the large group, in particular if one uses tricks to compute x^q
and x^e (where e is your local and secret dh exponent) together.

  This could still be 
  Note that this kind of subgroup-forcing attack was used in the DHE
  variant of Bhargavan et al's recent attack against client certification
  in TLS (other mistakes in the TLS protocol played a role in these
  attacks too, of course)

I haven't read up on this. 

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140313102253</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-13 10:22:53-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; One possibility might be to have all dsa functions take the dsa group
&gt; parameters and the actual key as separate function arguments.

I've tried this now. I think it looks reasonably good. Excerpts from the
new dsa.h:

  struct dsa_params
  {  
    /* Modulo */
    mpz_t p;
  
    /* Group order */
    mpz_t q;
  
    /* Generator */
    mpz_t g;
  };

So this is the new parameter struct. Is this a good name, or should it
be struct dsa_group?

  int
  dsa_sign(const struct dsa_params *params,
  	 const mpz_t x,
  	 void *random_ctx, nettle_random_func *random,
  	 size_t digest_size,
  	 const uint8_t *digest,
  	 struct dsa_signature *signature);
  
  int
  dsa_verify(const struct dsa_params *params,
  	   const mpz_t y,
  	   size_t digest_size,
  	   const uint8_t *digest,
  	   const struct dsa_signature *signature);

These functions now take the parameters separately. One could get
something more in style with the the old interface by defining

  #define dsa_sign(pub, key, [...]) dsa_sign(&amp;pub-&gt;params, key-&gt;x, [...])
  #define dsa_verify(pub, [...]) dsa_verify(&amp;pub-&gt;params, pub-&gt;y, [...])

Almost makes one wish for C++ style overloading...
 
  int
  dsa_generate_params (struct dsa_params *params,
  		     void *random_ctx, nettle_random_func *random,
  		     void *progress_ctx, nettle_progress_func *progress,
  		     unsigned p_bits, unsigned q_bits);
  
  void
  dsa_generate_keypair (const struct dsa_params *params,
  		      mpz_t pub,
  		      mpz_t key,
  
  		      void *random_ctx, nettle_random_func *random);

It seems reasonable to provide one key generation function which also
generates parameters, and one key generation function which takes fixed
parameters as argument. Any suggestion for naming? For compatibility, it
would be preferable to keep dsa_generate_keypair unchanged, and invent a
new name for the function above.

  /* Convenience structs, close to the interface used in nettle-2.7.x
     and earlier. */
  struct dsa_public_key
  {
    struct dsa_params params;
    /* Public value */
    mpz_t y;
  };
  
This is essentially the same struct as in earlier versions, but it wraps
the parameters in a struct, so it's an API change. I think this is the
sane way to do it, if this is viewed as an interface to be supported in
future versions, and not just something retained for backwards
compatibility.

In this version of the interface, struct dsa_public_key is not
deprecated, but it is made *optional*: all dsa features should be
available even if you don't bundle parameters and public key value in
this way.

And I think bundling the parameters with the public key do make sense
for many common use cases, in particular applications only wanting to
verify signatures and certificates.

  int
  dsa_sha1_sign(const struct dsa_public_key *pub,
  	      const struct dsa_private_key *key,
  	      void *random_ctx, nettle_random_func *random,
  	      struct sha1_ctx *hash,
  	      struct dsa_signature *signature);
  
  int
  dsa_sha1_verify(const struct dsa_public_key *key,
  		struct sha1_ctx *hash,
  		const struct dsa_signature *signature);

These and related functions retained, with no change to the prototypes.
I think most applications can use these functions, rather than the more
general dsa_sign and dsa_verify above. Maybe the _sign functions
should be changed to take a struct dsa_params * rather than a struct
dsa_public_key *; that would be more logical and consistent, but less
compatible with existing code.

  int
  dsa_generate_keypair_old(struct dsa_public_key *pub,
  			 struct dsa_private_key *key,
  
  			 void *random_ctx, nettle_random_func *random,
  			 void *progress_ctx, nettle_progress_func *progress,
  			 unsigned p_bits, unsigned q_bits);

As said above, there's a naming issue here. I think it would be nice to
keep this function with name and prototype unchanged.
  
  /* Generates a public-key expression if PRIV is NULL .*/
  int
  dsa_keypair_to_sexp(struct nettle_buffer *buffer,
  		    const char *algorithm_name, /* NULL means "dsa" */
  		    const struct dsa_params *params,
  		    const mpz_t pub,
  		    const mpz_t priv);
  
  /* If PRIV is NULL, expect a public-key expression. If PUB is NULL,
   * expect a private key expression and ignore the parts not needed for
   * the public key. */
  /* Keys must be initialized before calling this function, as usual. */
  int
  dsa_sha1_keypair_from_sexp(struct dsa_params *params,
  			   mpz_t pub,
  			   mpz_t priv,
  			   unsigned p_max_bits,
  			   size_t length, const uint8_t *expr);
  
  int
  dsa_params_from_der_iterator(struct dsa_params *params,
  			     unsigned max_bits, unsigned q_bits,
  			     struct asn1_der_iterator *i);
  int
  dsa_public_key_from_der_iterator(const struct dsa_params *params,
  				 mpz_t pub,
  				 struct asn1_der_iterator *i);
  
  int
  dsa_openssl_private_key_from_der_iterator(struct dsa_params *params,
  					  mpz_t pub,
  					  mpz_t priv,
  					  unsigned p_max_bits,
  					  struct asn1_der_iterator *i);
  
  int
  dsa_openssl_private_key_from_der(struct dsa_params *params,
  				 mpz_t pub,
  				 mpz_t priv,
  				 unsigned p_max_bits,
  				 size_t length, const uint8_t *data);
  

These conversion functions all take a separate dsa_params argument, and
don't use struct dsa_public_key and dsa_private_key.  

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140824202405</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-08-24 20:24:05-0400</timestampReceived><subject>ECDH test vectors (was: Re: [PATCH 5/5] Add fallback functions for mpn_copyd, mpn_copyi and mpn_zero</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Does anyone here have suitable ecdh
&gt; test vectors (a bit like draft-turner-thecurve25519function-00, but for
&gt; the more traditional curves? Wikipedia points to
&gt; http://www.secg.org/download/aid-390/gec2.pdf, but that site appears to
&gt; be down at the moment.

For the time being, I wrote a pari/gp script to generate some DH test
data. See
https://git.lysator.liu.se/nettle/nettle/blob/curve25519/misc/ecc-ref.gp

Luckily, ecc_point_mul and ecc_point_mul_g seem to pass the new tests.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140827124501</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-08-27 12:45:01-0400</timestampReceived><subject>Re: curve25519 progress</subject><body>

I've now merged the curve25519 branch to master. Seems to work fine, but
I would expect that it's slower than other implementations; there are
*lots* of optimizations left to do. I've done only a little
benchmarking, mainly for x86/ecc-25519-modp.asm.

I've also read the ecdsa paper now
(http://ed25519.cr.yp.to/ed25519-20110926.pdf), and it suggests several
important optimizations, most of which apply to all uses of curve25519.

Things I'd like to do, besides optimizations:

* Switch from the plain Edwards curve to the twist used for Ed25519.
  Should be pretty a small change.

* Implement Ed25519 signatures.

* Make the ecdsa code work over curve25519. Not that I'd expect anyone
  to use ecdsa over that curve, but I think it's useful for validating
  the generality of the ecc interface, and maybe for benchmarking.

* Review the public interface, moving functions which depend on the type
  of curve out of ecc.h into ecc-internal.h.

As far as optimizations go, I think the most important ones to try are

* Use the faster ecc addition formulas specific to the twist curve.

* Try radix 51 for the mod p operations (outlined in the paper), and
  write assembly functions for doing squaring and multiplication in
  registers, without storing intermediate results to memory. This should
  be quite similar to the arithmetic for poly1305.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140829135723</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-08-29 13:57:23-0400</timestampReceived><subject>Re: eddsa progress (was: Re: curve25519 progress)</subject><body>

On Fri, Aug 29, 2014 at 2:27 PM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wrot=
e:
&gt;&gt; Things I'd like to do, besides optimizations:
&gt;&gt; * Switch from the plain Edwards curve to the twist used for Ed25519.
&gt;&gt;   Should be pretty a small change.
&gt; Done (but not yet pushed to the public repo). With only minor changes to
&gt; the addition formulas, not yet using the new optimizations which become
&gt; possible with this curve.
&gt;&gt; * Implement Ed25519 signatures.
&gt; This is the next thing to do, I think, before turning to optimizations.
&gt; If anyone knows some eddsa25519 test vectors, that would be great. The
&gt; paper doesn't include any.

I know that ligcrypt added eddsa support recently and they use the vectors =
from
http://ed25519.cr.yp.to/python/sign.input

regards,
Nikos

</body></email><email><emailId>20140829193746</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-08-29 19:37:46-0400</timestampReceived><subject>Re: eddsa progress</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; I know that ligcrypt added eddsa support recently and they use the vectors from
&gt; http://ed25519.cr.yp.to/python/sign.input

Thanks, I'll have a look at that. And I've found the python program to
process that file as well.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140831202751</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-08-31 20:27:51-0400</timestampReceived><subject>Re: Hashing with EdDSA</subject><body>

On Sun, 2014-08-31 at 21:41 +0200, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt; &gt; That is indeed quite different from any other signature scheme. I don't
&gt; &gt; know whether eddsa is going to be standardized or not, but it is
&gt; &gt; certainly being discussed in irtf. Maybe raising that issue there would
&gt; &gt; make more sense.
&gt; 
&gt; Where, more precisely, do you suggest I ask about this? cfrg@irtf.org ?

Yes, this is the e-mail of the CFRG.

regards,
Nikos



</body></email><email><emailId>20140711211322</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-07-11 21:13:22-0400</timestampReceived><subject>Re: [PATCH] fix typo in ecc-mod.c</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; --- a/ecc-mod.c
&gt; +++ b/ecc-mod.c
&gt; @@ -40,7 +40,7 @@
&gt;  #include "ecc-internal.h"
&gt;  
&gt;  /* Computes r mod m, where m is of size mn. bp holds B^mn mod m, as mn
&gt; -   limbs, but the upper mn - bn libms are zero. */
&gt; +   limbs, but the upper mn - bn limbs are zero. */
&gt;  void
&gt;  ecc_mod (mp_limb_t *rp, mp_size_t rn, mp_size_t mn,
&gt;  	 const mp_limb_t *bp, mp_size_t bn,

Thanks, applied,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140711214722</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-07-11 21:47:22-0400</timestampReceived><subject>Re: curve25519</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I'v started to look closer at curve25519, and I've added support for it
&gt; in the eccdata program.

I'm working slowly on this, on a new branch "curve25519". I now have an
ecc_dup_eh function, which duplicates a point on an Edwards curve, using
homogeneous coordinates, and a function ecc_eh_to_a to convert the
coordinates back to affine coordinates on the equivalent Montgomery
curve (typically, curve25519). And a basic test case for that.

To get a uniform interface for different types of curves, I'm
considering moving some functions from the public header ecc.h to
ecc-internal.h. In particular, the ecc_j_to_a, ecc_dup_jj, ecc_add_jja,
ecc_add_jjj. And instead have functions for converting to some unspecied
internal coordinates, based on some additional function pointer in
the internal struct ecc_curve. The documented ecc functions would be
left unchanged. Would that cause any problems?

I haven't yet looked very closely at the API other curve25519 are using,
or at the definition of ed25519 signatures.

It would make sense to me to have the curve25519 function operating on
byte strings (as specified by djb), looking something like

  void curve25519 (uint8_t *r, const uint8_t *point, const uint8_t *scalar);

where POINT is the x coordinate of the base point, or NULL for the
generator (x == 9), SCALAR is the secret number to multpily the point
with, and R gets the x coordinate of the resulting point. Or two
separate functions. The thing is that the case x == 9 is an important
special case, and it can be sped up a lot with a few KB of precomputed
tables, just like for the other curves, or fix-base exponentiation in
general.

So suggestions on what the API should look like are apppreciated. And
what's a good source for test cases for the curve25519 function?

For ECC in general, I think it would be good to have another look at
modular inversion. The current side-channel silent code works but is
fairly slow. It sometimes beats GMPs mpn_sec_powm (for a prime p, a^{-1}
= a^{p-2}), but often it doesn't, in particular for the smaller primes.
I'd like to try doing a fix-exponent powm, using the optimized mod or
redc functions for the prime in question, and some well-chosen addition
chain for each needed exponent.

And if anyone wants a bit of summer reading, I can recommend the square
root overview http://www.math.vt.edu/people/brown/doc/sqrts.pdf, which I
stumbled upon when searching for a description of the Shanks-Tonnelli
algorithm for square root modulo p.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140731073835</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-07-31 07:38:35-0400</timestampReceived><subject>Re: curve25519 progress</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; The URL is:
&gt; http://tools.ietf.org/html/draft-turner-thecurve25519function-00

Hmm. I've had a look. I think the test vector there is identical to the
one in your draft, except that the secret keys are random 256-bit values
(little endian), *before* the specified masking to force bits 0, 1, 2,
255 = 0 and bit 254 = 1. Which had me confused for a while.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140601180257</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-01 18:02:57-0400</timestampReceived><subject>Problem with assembly functions on w64 (was: Re: Problem with w32 shared libraries)</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; (I'll check status of 64-bit wine in debian, last time I looked
&gt; it didn't work out of the box).

Seems to work now, after

  apt-get -t testing install wine wine32 wine64

Only problem is that it seems one can't use the same ~/.wine for 32-bit
and 64-bit wine, so I have to set WINEPREFIX=~/.wine64 when running
64-bit executables.

It fails make check; several assembly functions crash on w64, also in
the --disable-shared case. I haven't yet looked closer, but I suspect
that's some simple bug in the register shuffling done to support the w64
calling convention. If it used to work (iirc, Martin tested the previous
nettle release on w64), that probably means that it's correct for up to
5 arguments, but broken for newer functions with 6 arguments.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140602085841</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-02 08:58:41-0400</timestampReceived><subject>Re: Problem with assembly functions on w64</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; I've tested the latest git version on real windows (both 32 and 64
&gt; bit), OS X (both 32 and 64 bit), and on linux on arm (both armv6 and
&gt; armv7 devices), and didn't run into any issues.

Great! Thanks for testing,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140608174044</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2014-06-08 17:40:44-0400</timestampReceived><subject>Re: git server changes</subject><body>


On 06/08/2014 12:43 PM, Niels Möller wrote:
&gt; For public access, "git:" in the URLs must be replaced by "https:", like
&gt; 
&gt;   https://git.lysator.liu.se/nettle/nettle.git

tested, and this works fine for me.  I did:

 git config remote.origin.url \
    https://git.lysator.liu.se/nettle/nettle.git

thanks for doing this maintenance work, Niels.

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20140610100622</emailId><senderName>Aapo Talvensaari</senderName><senderEmail>aapo.talvensaari@gmail.com</senderEmail><timestampReceived>2014-06-10 10:06:22-0400</timestampReceived><subject>Re: pbkdf2 functions return longer values than requested</subject><body>

On Tue, Jun 10, 2014 at 11:38 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:

&gt; Aapo Talvensaari &lt;aapo.talvensaari@gmail.com&gt; writes:
&gt;
&gt; &gt; sometimes return longer dst than what was requested. See:
&gt; &gt;
&gt; &gt;
&gt; https://github.com/bungle/lua-resty-nettle/blob/master/lib/resty/nettle/pbkdf2.lua#L21
&gt; &gt;
&gt; &gt; I had to put ":sub(1, len)" to overcome that.
&gt;
&gt; How does ffi_str work? You're aware that the output is binary data, with
&gt; no NUL-termination?
&gt;

:-). It was a bug in my code. I have fixed it now (I had used this function
in many places correctly but here I happened to get it wrong).

ffi.string (ffi_str) is defined as follows:
str = ffi.string(ptr [,len])

If the optional argument len is missing, ptr is converted to a "char *" and
the data is assumed to be zero-terminated. The length of the string is
computed with strlen().

Thanks for getting me back on a right track.


Regards
Aapo

</body></email><email><emailId>20140616172946</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-06-16 17:29:46-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.0</subject><body>

On Mon, 2014-06-16 at 19:08 +0200, Niels Möller wrote:

&gt; Maybe as a build option, but not for a normal installation.

That would be worse as there will be multiple ABIs and would require
tweaking all the applications that use nettle in order to build one way
or another. I'd prefer to have things as is if the only alternative is
that.

&gt; But I think those applications should use nettle... Adding a gmp
&gt; dependency makes that less attractive.
&gt; 
&gt; &gt; In any embedded system using nettle+hogweed
&gt; &gt; would require more memory and overhead than having a single library.
&gt; 
&gt; Could you put some numbers to that overhead? I can't say if it's worth
&gt; trying to avoid.

No, but is there a reason for having it in the first place? Are there
really applications that need only symmetric crypto support and can
afford linking to a shared library but really don't want to have the
public key in that shared library? OpenSSL's libcrypto is used in
embedded systems without any complain of the kind (and it includes all
kind of crypto).

regards,
Nikos



</body></email><email><emailId>20140620165915</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2014-06-20 16:59:15-0400</timestampReceived><subject>Re: OCB mode</subject><body>


On 06/20/2014 08:50 AM, Nikos Mavrogiannopoulos wrote:

&gt;  What do you think of having OCB mode in nettle? I particularly like
&gt; OCB due to it's simplicity and performance comparing to GCM/CCM,=20

I'd love to see OCB made available in nettle for these exact reasons.

&gt; What do you think? Should the FSF be consulted on that?

&gt; [0]. http://www.cs.ucdavis.edu/~rogaway/ocb/license.htm

It seems reasonable to ask the FSF about it for a bigger-picture
analysis, but it looks clear to me that nettle itself won't get into any
trouble with Rogaway's patents over OCB.

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20140831191236</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-08-31 19:12:36-0400</timestampReceived><subject>Hashing with EdDSA</subject><body>

I'm looking into EdDSA. According to the paper, signing of a message M,
using private key (a, k), corresponding to public key A, is essentially

  r = H(k | M),    with k the second half of the private key
  R = rB,          with B the specified generator of the curve,
  S = ((r + H(R | A | M) a) mod l, l is the curve order

with some rules to encode R, A, S as strings. H is typically sha-512.

If M is the original, arbitrarily long, message to be signed, this
breaks the common structure that you can first compute a message digest,
and then apply the secret key to produce a signature. But this doesn't
work above, because the complete message has to be hashed twice, first
with the secret prefix k, next with the prefix R | A, and any hashing
without the private key available is useless. And even worse, one has to
buffer the complete message because the prefix of the second hash
depends on the output of the first hash.

Or should M itself be a digest of the message to be signed? That will
enable a more main-stream signature interface, where the inputs to the
signature function are the private key and the short message digest.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140602204556</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-02 20:45:56-0400</timestampReceived><subject>Re: git server changes</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Nettle and LSH repos (as well as other repos I have there) will move,
&gt; but they may be temporarily unavailable in the weekend or next week.

Now all repos exist at the new server, available under the temporary
name gluten.lysator.liu.se. Testing is appreciated.

The repositories at git.lysator.liu.se and gluten.lysator.liu.se may be
slightly out of sync. My intention is that the repository on the machine
named "git.lysator.liu.se" should be the main repo, and that name will
most likely be assigned to the new server in a few days.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140609232234</emailId><senderName>Aapo Talvensaari</senderName><senderEmail>aapo.talvensaari@gmail.com</senderEmail><timestampReceived>2014-06-09 23:22:34-0400</timestampReceived><subject>pbkdf2 functions return longer values than requested</subject><body>

I started implementing LuaJIT FFI bindings to Nettle, and I found that

nettle_pbkdf2_hmac_sha1
and
nettle_pbkdf2_hmac_sha256

sometimes return longer dst than what was requested. See:

https://github.com/bungle/lua-resty-nettle/blob/master/lib/resty/nettle/pbkdf2.lua#L21

I had to put ":sub(1, len)" to overcome that.

Is it by a design or is it a bug (maybe in my code?).


Regards
Aapo

</body></email><email><emailId>20140610083845</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-10 08:38:45-0400</timestampReceived><subject>Re: pbkdf2 functions return longer values than requested</subject><body>

Aapo Talvensaari &lt;aapo.talvensaari@gmail.com&gt; writes:

&gt; sometimes return longer dst than what was requested. See:
&gt;
&gt; https://github.com/bungle/lua-resty-nettle/blob/master/lib/resty/nettle/pbkdf2.lua#L21
&gt;
&gt; I had to put ":sub(1, len)" to overcome that.

How does ffi_str work? You're aware that the output is binary data, with
no NUL-termination?

If it is a bug in nettle, it would help if you could provide a minimal C
program that let's me reproduce the problem.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140608164324</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-08 16:43:24-0400</timestampReceived><subject>Re: git server changes</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I'll send another mail once everything is ready at the new
&gt; server. Intention is that git urls will be unchanged.

The move is completed now, and git.lysator.liu.se points to the new
server. Apparently, the gitlab software doesn't support the git protocol
(or if anyone knows how to fix that, I'd be happy to relay the info to
the root team).

For public access, "git:" in the URLs must be replaced by "https:", like

  https://git.lysator.liu.se/nettle/nettle.git
  https://git.lysator.liu.se/lsh/lsh.git

Sorry for the inconvenience.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140831193034</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-08-31 19:30:34-0400</timestampReceived><subject>Re: Hashing with EdDSA</subject><body>

On Sun, 2014-08-31 at 21:12 +0200, Niels Möller wrote:
&gt; I'm looking into EdDSA. According to the paper, signing of a message M,
&gt; using private key (a, k), corresponding to public key A, is essentially
&gt; 
&gt;   r = H(k | M),    with k the second half of the private key
&gt;   R = rB,          with B the specified generator of the curve,
&gt;   S = ((r + H(R | A | M) a) mod l, l is the curve order
&gt; with some rules to encode R, A, S as strings. H is typically sha-512.
&gt; If M is the original, arbitrarily long, message to be signed, this
&gt; breaks the common structure that you can first compute a message digest,
&gt; and then apply the secret key to produce a signature.

That is indeed quite different from any other signature scheme. I don't
know whether eddsa is going to be standardized or not, but it is
certainly being discussed in irtf. Maybe raising that issue there would
make more sense.

&gt; Or should M itself be a digest of the message to be signed? That will
&gt; enable a more main-stream signature interface, where the inputs to the
&gt; signature function are the private key and the short message digest.

M would most probably be protocol related and at least for TLS it is
often something short, but other protocols may differ.

regards,
Nikos



</body></email><email><emailId>20140831194137</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-08-31 19:41:37-0400</timestampReceived><subject>Re: Hashing with EdDSA</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; That is indeed quite different from any other signature scheme. I don't
&gt; know whether eddsa is going to be standardized or not, but it is
&gt; certainly being discussed in irtf. Maybe raising that issue there would
&gt; make more sense.

Where, more precisely, do you suggest I ask about this? cfrg@irtf.org ?

&gt; M would most probably be protocol related and at least for TLS it is
&gt; often something short, but other protocols may differ.

For a start, I think it makes sense to have sign and verify functions
that take the complete arbitrary-length message as an argument, and no
attempt at any _update function. With the expecation that short messages
are what people will be using (and then a flexible input size is nice),
and that applications for signing large messages with eddsa will likely
do their own message digest before invoking the eddsa functions.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140909195622</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-09-09 19:56:22-0400</timestampReceived><subject>Re: Hashing with EdDSA</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; On Sun, 2014-08-31 at 21:12 +0200, Niels Möller wrote:
&gt;&gt; I'm looking into EdDSA. According to the paper, signing of a message M,
&gt;&gt; using private key (a, k), corresponding to public key A, is essentially
&gt;&gt; 
&gt;&gt;   r = H(k | M),    with k the second half of the private key
&gt;&gt;   R = rB,          with B the specified generator of the curve,
&gt;&gt;   S = ((r + H(R | A | M) a) mod l, l is the curve order
&gt;&gt; with some rules to encode R, A, S as strings. H is typically sha-512.
&gt;&gt; If M is the original, arbitrarily long, message to be signed, this
&gt;&gt; breaks the common structure that you can first compute a message digest,
&gt;&gt; and then apply the secret key to produce a signature.
&gt;
&gt; That is indeed quite different from any other signature scheme. I don't
&gt; know whether eddsa is going to be standardized or not, but it is
&gt; certainly being discussed in irtf. Maybe raising that issue there would
&gt; make more sense.

I asked djb, who pointed to the "Maximum security" paragraph close to
the end of http://blog.cr.yp.to/20140323-ecdsa.html. As I understand it,
the point is resilience to hash collisions: Collisions in the hash
function doesn't automatically make signature forgeries possible.
Quoting that post. "Using Ed25519 to sign H(m), rather than m, would
mean hashing m only once (at the expense of collision resilience), but
again the safest option is the default."

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140607083510</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-07 08:35:10-0400</timestampReceived><subject>ANNOUNCE: Nettle-3.0</subject><body>


I'm happy to announce a new version of GNU Nettle, a low-level
cryptographics library. The Nettle home page can be found at
http://www.lysator.liu.se/~nisse/nettle/.

This release is dual licensed as LGPLv3 or later, or GPLv2 or later. See
the manual for details.

NEWS for the Nettle 3.0 release

	This is a major release, including several interface changes,
	and new features, some of which are a bit experimental.
	Feedback is highly appreciated.

	It is *not* binary (ABI) compatible with earlier versions. It
	is mostly source-level (API) compatible, with a couple of
	incompatibilities noted below. The shared library names are
	libnettle.so.5.0 and libhogweed.so.3.0, with sonames
	libnettle.so.5 and libhogweed.so.3.
	
	There may be some problems in the new interfaces and new
	features which really need incompatible fixes. It is likely
	that there will be an update in the form of a 3.1 release in
	the not too distant future, with small but incompatible
	changes, and if that happens, bugfix-only releases 3.0.x are
	unlikely. Users and applications which desire better API and
	ABI stability are advised to stay with nettle-2.7.x (latest
	version is now 2.7.1) until the dust settles.

	Interface changes:

	* For the many _set_key functions, it is now consider the
	  normal case to have a fixed key size, with no key_size
	  arguments. _set_key functions with a length parameter are
	  provided only for algorithms with a truly variable keysize,
	  and where it makes sense for backwards compatibility.

	  INCOMPATIBLE CHANGE: cast128_set_key no longer accepts a key
	  size argument. The old function is available under a new
	  name, cast5_set_key.

	  INCOMPATIBLE CHANGE: The function typedef
	  nettle_set_key_func no longer accepts a key size argument.
	  In particular, this affects users of struct nettle_cipher.

	* The nettle_cipher abstraction (in nettle-meta.h) is
	  restricted to block ciphers only. The encrypt and decrypt
	  functions now take a const argument for the context.

	  INCOMPATIBLE CHANGE: nettle_arcfour, i.e., the nettle_cipher
	  abstraction for the arcfour stream cipher, is deleted.

	  INCOMPATIBLE CHANGE: New type, nettle_cipher_func, for the
	  encrypt and decrypt fields of struct nettle_cipher.

	* New DSA interface, with a separate struct dsa_param to
	  represent the underlying group, and generalized dsa_sign and
	  dsa_verify functions which don't care about the hash
	  function used. Limited backwards compatibility provided in
	  dsa-compat.h.

	  INCOMPATIBLE CHANGE: Declarations of the old interface,
	  e.g., struct dsa_public_key, dsa_sha1_sign, etc, is moved to
	  dsa-compat.h.

	  INCOMPATIBLE CHANGE: The various key conversion functions,
	  e.g., dsa_keypair_to_sexp, all use the new DSA interface, with
	  no backwards compatible functions.

	  INCOMPATIBLE CHANGE: dsa_generate_keypair also uses the new
	  interface. dsa-compat.h declares a function
	  dsa_compat_generate_keypair, implementing the old
	  interface, and #defines dsa_generate_keypair to refer to
	  this backwards compatible function.

	* New AES and Camellia interfaces. There are now separate
	  context structs for each key size, e.g., aes128_ctx and
	  camellia256_ctx, and corresponding new functions. The old
	  interface, with struct aes_ctx and struct camellia_ctx, is
	  kept for backwards compatibility, but might be removed in
	  later versions.

	* The type of most length arguments is changed from unsigned
	  to size_t. The memxor functions have their pointer arguments
	  changed from uint8_t * to void *, for consistency with
	  related libc functions.

	* For hash functions, the constants *_DATA_SIZE have been
	  renamed to *_BLOCK_SIZE. Old names kept for backwards
	  compatibility.

	Removed features:

	* The nettle_next_prime function has been deleted.
	  Applications should use GMP's mpz_nextprime instead.

	* Deleted the RSAREF compatibility, including the header file
	  rsa-compat.h and everything declared therein.

	* Also under consideration for removal is des-compat.h and
	  everything declared therein. This implements a subset of the
	  old libdes/ssleay/openssl interface for DES and triple-DES,
	  and it is poorly tested. If anyone uses this interface,
	  please speak up! Otherwise, it will likely be removed in the
	  next release.
	
	Bug fixes:

	* Building with ./configure --disable-static now works.

	* Use GMP's allocation functions for temporary storage related
	  to bignums, to avoid potentially large stack allocations.

	* Fixes for shared libraries on M$ Windows.

	New features:

	* Support for Poly1305-AES MAC.

	* Support for the ChaCha stream cipher and EXPERIMENTAL
	  support for the ChaCha-Poly1305 AEAD mode. Specifications
	  are still in flux, and future releases may do incompatible
	  changes to track standardization. Currently uses 256-bit key
	  and 64-bit nonce.

	* Support for EAX mode.

	* Support for CCM mode. Contributed by Owen Kirby.

	* Additional variants of SHA512 with output size of 224 and
	  256 bits. Contributed by Joachim Strömbergson.

	* New interface, struct nettle_aead, for mechanisms providing
	  authenticated encryption with associated data (AEAD).

	* DSA: Support a wider range for the size of q and a wider
	  range for the digest size.

	Optimizations:

	* New x86_64 assembly for GCM and MD5. Modest speedups on the
	  order of 10%-20%.

	Miscellaneous:

	* SHA3 is now documented as EXPERIMENTAL. Nettle currently
	  implements SHA3 as specified at the time Keccak won the SHA3
	  competition. However, the final standard specified by NIST
	  is likely to be incompatible, in which case future releases
	  may do incompatible changes to track standardization.

	* The portability fix for the rotation macros, mentioned in
	  NEWS for 2.7.1, actually didn't make it into that release.
	  It is included now.

	* cast128_set_key rewritten for clarity, also eliminating a
	  couple of compiler warnings.

	* New command line tool nettle-pbkdf2.

Available at:

  https://ftp.gnu.org/gnu/nettle/nettle-3.0.tar.gz
  ftp://ftp.gnu.org/gnu/nettle/nettle-3.0.tar.gz
  http://www.lysator.liu.se/~nisse/archive/nettle-3.0.tar.gz
  ftp://ftp.lysator.liu.se/pub/security/lsh/nettle-3.0.tar.gz (soon)

Happy hacking,
/Niels Möller

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20140620125011</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-06-20 12:50:11-0400</timestampReceived><subject>OCB mode</subject><body>

Hello,
 What do you think of having OCB mode in nettle? I particularly like
OCB due to it's simplicity and performance comparing to GCM/CCM, but
was always patented. However in [0] there is license1 which states:
"Under this license, you are authorized to make, use, and distribute
open-source software implementations of OCB. This license terminates
for you if you sue someone over their open-source software
implementation of OCB claiming that you have a patent covering their
implementation."

What do you think? Should the FSF be consulted on that?

regards,
Nikos


[0]. http://www.cs.ucdavis.edu/~rogaway/ocb/license.htm

</body></email><email><emailId>20140610080833</emailId><senderName>Dagobert Michelsen</senderName><senderEmail>dam@opencsw.org</senderEmail><timestampReceived>2014-06-10 08:08:33-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.0</subject><body>


Hi,

Am 07.06.2014 um 10:35 schrieb Niels Möller &lt;nisse@lysator.liu.se&gt;:

&gt; I'm happy to announce a new version of GNU Nettle, a low-level
&gt; cryptographics library. The Nettle home page can be found at
&gt; http://www.lysator.liu.se/~nisse/nettle/.
&gt; 
&gt; This release is dual licensed as LGPLv3 or later, or GPLv2 or later. See
&gt; the manual for details.
&gt; 
&gt; NEWS for the Nettle 3.0 release

I have two failing tests on 64 bit Sparc:

Encrypt failed:
Input:
0123456789abcdef fedcba9876543210

Output: 
df51fc645013f77c 25c472e2871f742a

Expected:
6767313854966973 0857065648eabe43

Abort - core dumped
FAIL: camellia
...
Assert failed: testutils.c:513: MEMEQ(digest-&gt;length, buffer, digest-&gt;data)
Abort - core dumped
FAIL: gcm


Sparc 32 bit, i386 32 bit and amd64 64 bit work fine. Byte ordering?


Best regards

  — Dago


-- 
"You don't become great by trying to be great, you become great by wanting to do something,
and then doing it so hard that you become great in the process." - xkcd #896



</body></email><email><emailId>20140620123807</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-06-20 12:38:07-0400</timestampReceived><subject>turn RSA blinding off in openssl</subject><body>

["0001-Turn-RSA-blinding-off-in-openssl-RSA-benchmark.patch" (text/plain-diff)]

From 7566e6f82f86b96580ac72939ebfd809f506df42 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Fri, 20 Jun 2014 14:37:13 +0200
Subject: [PATCH] Turn RSA blinding off in openssl RSA benchmark.

That allows direct comparison with hogweed's RSA results.
---
 examples/hogweed-benchmark.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/examples/hogweed-benchmark.c b/examples/hogweed-benchmark.c
index 05372ab..311fa2d 100644
--- a/examples/hogweed-benchmark.c
+++ b/examples/hogweed-benchmark.c
@@ -521,6 +521,7 @@ bench_openssl_rsa_init (unsigned size)
   ctx-&gt;ref = xalloc (RSA_size (ctx-&gt;key));
   ctx-&gt;signature = xalloc (RSA_size (ctx-&gt;key));
   ctx-&gt;digest = hash_string (&amp;nettle_sha1, 3, "foo");
+  RSA_blinding_off(ctx-&gt;key);
 
   if (! RSA_sign (NID_sha1, ctx-&gt;digest, SHA1_DIGEST_SIZE,
 		  ctx-&gt;ref, &amp;ctx-&gt;siglen, ctx-&gt;key))
-- 
1.9.3



</body></email><email><emailId>20140610084723</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-10 08:47:23-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.0</subject><body>

Dagobert Michelsen &lt;dam@opencsw.org&gt; writes:

&gt; I have two failing tests on 64 bit Sparc:

And it's camellia and gcm, which is plain C code on that platform. The
testsuite passes on the machine where I test it:

  $ uname -a
  SunOS bacon 5.10 Generic_147147-26 sun4u sparc SUNW,Sun-Fire-15000
  
  $ ./config.status --version
  nettle config.status 3.0
  configured by /home/nisse/hack/nettle/configure, generated by GNU Autoconf 2.69,
    with options "'CC=gcc -m64' 'CXX=g++ -m64'"
  
  $ gcc --version
  gcc (GCC) 3.4.5

Which compiler are you using?

&gt; Sparc 32 bit, i386 32 bit and amd64 64 bit work fine. Byte ordering?

Does your config.h define WORDS_BIGENDIAN correctly?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140624193243</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-24 19:32:43-0400</timestampReceived><subject>Simplifying pic vs non-pic object files</subject><body>

Currently, the nettle Makefile creates two object files for each source
file, .o for inclusion in the static library, and .po ("pure object")
for the shared library. By default, both are compiled as pic code, but
--disable-pic drops the pic flags when compiling the .o files, to get
non-pic code into the static library.

I'm considering dropping this complication. Just build a single .o file,
which is pic by default, and non-pic if --disable-pic is given.

To build a non-pic static library, one would configure with
"--disable-pic --disable-shared" (since just --disable-pic would produce
a shared library with non-pic code, which is highly undesirable). And to
produce a static non-pic library and a shared pic library, one would
need to use separate build trees.

Does that make sense? It would make things simpler, shorten build time,
and eliminate the problem of naming two types of object files.

One might also have --disable-pic imply --disable-shared 
(unless explicitly overridden by the user).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140626073042</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2014-06-26 07:30:42-0400</timestampReceived><subject>[PATCH 3/3] Include private dependencies automatically in pkg-config for non-shared builds</subject><body>

When a user invokes pkg-config to get the necessary linker flags
for linking to libhogweed, the user can add --static to get the
private dependencies included, which are necessary for static
linking. If the hogweed build contains both static and shared
libraries, this works as intended - if the user explicitly passes
-static to the linker to have it favor static libs over shared
ones, the same user also needs to tell pkg-config about this intention.

If the hogweed build happens to be static-only, the user of the
library might not be aware of this, and might not realize needing
to pass --static to pkg-config. (This is even more an issue in
setups with a large number of libraries, where only a few of them
are built static-only.)

For these cases, where a library is built as only a static library,
one fairly common convention (not used everywhere, but at least in
some libraries I regularly use) is to include the private dependencies
in the non-private section. This makes sure a user of the library
doesn't need to be concerned about which way this library was built
(unless the user intentionally overrides defaults by passing
flags such as -static to the linker).
---
 configure.ac  | 3 +++
 hogweed.pc.in | 7 ++++---
 2 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/configure.ac b/configure.ac
index 2ea5866..6923d3a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -757,8 +757,10 @@ fi
 
 if test "x$enable_shared" = xyes ; then
   IF_SHARED=''
+  IF_NOT_SHARED='#'
 else
   IF_SHARED='#'
+  IF_NOT_SHARED=''
 fi
 
 # Documentation tools
@@ -792,6 +794,7 @@ fi
 AC_SUBST(IF_HOGWEED)
 AC_SUBST(IF_STATIC)
 AC_SUBST(IF_SHARED)
+AC_SUBST(IF_NOT_SHARED)
 AC_SUBST(IF_DOCUMENTATION)
 AC_SUBST(IF_DLL)
 AC_SUBST(IF_MINI_GMP)
diff --git a/hogweed.pc.in b/hogweed.pc.in
index 839f7d0..97fb9d4 100644
--- a/hogweed.pc.in
+++ b/hogweed.pc.in
@@ -11,8 +11,9 @@ Name: Hogweed
 Description: Nettle low-level cryptographic library (public-key algorithms)
 URL: http://www.lysator.liu.se/~nisse/nettle
 Version: @PACKAGE_VERSION@
-Requires.private: nettle
-Libs: -L${libdir} -lhogweed
-Libs.private: @LIBS@
+Requires: @IF_NOT_SHARED@ nettle
+Requires.private: @IF_SHARED@ nettle
+Libs: -L${libdir} -lhogweed @IF_NOT_SHARED@ @LIBS@
+Libs.private: @IF_SHARED@ @LIBS@
 Cflags: -I${includedir}
 
-- 
1.8.5.2 (Apple Git-48)


</body></email><email><emailId>20140626073040</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2014-06-26 07:30:40-0400</timestampReceived><subject>[PATCH 1/3] Don't hardcode the -lgmp linker flag in the hogweed pkg-config file</subject><body>

---
 hogweed.pc.in | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/hogweed.pc.in b/hogweed.pc.in
index 457f5f2..839f7d0 100644
--- a/hogweed.pc.in
+++ b/hogweed.pc.in
@@ -13,6 +13,6 @@ URL: http://www.lysator.liu.se/~nisse/nettle
 Version: @PACKAGE_VERSION@
 Requires.private: nettle
 Libs: -L${libdir} -lhogweed
-Libs.private: -lgmp
+Libs.private: @LIBS@
 Cflags: -I${includedir}
 
-- 
1.8.5.2 (Apple Git-48)


</body></email><email><emailId>20140903212355</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-09-03 21:23:55-0400</timestampReceived><subject>Re: Simplifying pic vs non-pic object files</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Currently, the nettle Makefile creates two object files for each source
&gt; file, .o for inclusion in the static library, and .po ("pure object")
&gt; for the shared library. By default, both are compiled as pic code, but
&gt; --disable-pic drops the pic flags when compiling the .o files, to get
&gt; non-pic code into the static library.
&gt;
&gt; I'm considering dropping this complication. Just build a single .o file,
&gt; which is pic by default, and non-pic if --disable-pic is given.

Done now. No more .po object files.

I also reverted some .asm-related changes (which were done one early
2013, to fix problems with parallel make when each .asm file was
transformed first to a preprocessed .s file and then to two separate .o
and .po object files). This makes the rules simpler, and it also happens
to work better with Solaris' make.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140610100155</emailId><senderName>Dagobert Michelsen</senderName><senderEmail>dam@opencsw.org</senderEmail><timestampReceived>2014-06-10 10:01:55-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.0</subject><body>


Hi Niels,

Am 10.06.2014 um 10:47 schrieb Niels Möller &lt;nisse@lysator.liu.se&gt;:
&gt; Dagobert Michelsen &lt;dam@opencsw.org&gt; writes:
&gt; 
&gt;&gt; I have two failing tests on 64 bit Sparc:
&gt; 
&gt; And it's camellia and gcm, which is plain C code on that platform. The
&gt; testsuite passes on the machine where I test it:
&gt; 
&gt;  $ uname -a
&gt;  SunOS bacon 5.10 Generic_147147-26 sun4u sparc SUNW,Sun-Fire-15000
&gt; 
&gt;  $ ./config.status --version
&gt;  nettle config.status 3.0
&gt;  configured by /home/nisse/hack/nettle/configure, generated by GNU Autoconf 2.69,
&gt;    with options "'CC=gcc -m64' 'CXX=g++ -m64'"
&gt; 
&gt;  $ gcc --version
&gt;  gcc (GCC) 3.4.5
&gt; 
&gt; Which compiler are you using?

This is Sun Studio 12.  Sun Studio 12.3 fails also.
Optflags are -xO3. Removing optflags leads to the same error.
I just tested with GCC 4.9.0 and the testsuite passes.
Looks like a compiler-interop issue. Would you think giving
Sun Studio a try would be worth it? Maybe different alignment
and differing pragmas?

&gt; Sparc 32 bit, i386 32 bit and amd64 64 bit work fine. Byte ordering?
&gt; 
&gt; Does your config.h define WORDS_BIGENDIAN correctly?

Good question:

/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
   significant byte first (like Motorola and SPARC, unlike Intel). */
#if defined AC_APPLE_UNIVERSAL_BUILD
# if defined __BIG_ENDIAN__
#  define WORDS_BIGENDIAN 1
# endif
#else
# ifndef WORDS_BIGENDIAN
#  define WORDS_BIGENDIAN 1
# endif
#endif

I guess that is ok.


Best regards

  — Dago

-- 
"You don't become great by trying to be great, you become great by wanting to do something,
and then doing it so hard that you become great in the process." - xkcd #896



</body></email><email><emailId>20140610102519</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-10 10:25:19-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.0</subject><body>

Dagobert Michelsen &lt;dam@opencsw.org&gt; writes:

&gt; This is Sun Studio 12.  Sun Studio 12.3 fails also.
&gt; Optflags are -xO3. Removing optflags leads to the same error.
&gt; I just tested with GCC 4.9.0 and the testsuite passes.

So then it's either a configuration error, some portability problem in
the C code, or a compiler bug. Let's start with the camellia failure.
Some things you can try to track it down:

1. Enable all warning options.

2. Check that you get the same settings for HAVE_NATIVE_64_BIT with both
   compilers. And check for any other differences in config.h between
   builds.

3. Try compiling camellia-crypt-internal.c using gcc, and copy the
   object file into your Sun Studio build, to try to isolate the failure
   to a single source file. (This file seems like the most likely
   culprit, but it could be elsewhere).

4. Add debug output after key expansion, and between rounds, to see
   where results start to differ between the working and the non-working
   build.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140616083659</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-06-16 08:36:59-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.0</subject><body>

On Sat, Jun 7, 2014 at 10:35 AM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wrot=
e:
&gt; I'm happy to announce a new version of GNU Nettle, a low-level
&gt; cryptographics library. The Nettle home page can be found at
&gt; http://www.lysator.liu.se/~nisse/nettle/.

Hello,
 As the ABI broke anyway in 3.0, would it make sense to merge the
nettle and hogweed libraries? Hogweed cannot be used without linking
to libnettle, thus the advantage of the current split is only to
applications that only use libnettle. Nevertheless, I don't think
there are such applications. My guess is that the ones that simply
need sha1, would avoid linking to nettle and just copy the algorithms
they need internally. In any embedded system using nettle+hogweed
would require more memory and overhead than having a single library.
That is of course not a very significant overhead, but it harms the
actual programs it targets to help.

regards,
Nikos

</body></email><email><emailId>20140616084843</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-06-16 08:48:43-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.0</subject><body>

On Mon, Jun 16, 2014 at 10:36 AM, Nikos Mavrogiannopoulos
&lt;n.mavrogiannopoulos@gmail.com&gt; wrote:

&gt;  As the ABI broke anyway in 3.0, would it make sense to merge the
&gt; nettle and hogweed libraries? Hogweed cannot be used without linking
&gt; to libnettle, thus the advantage of the current split is only to
&gt; applications that only use libnettle. Nevertheless, I don't think
&gt; there are such applications. My guess is that the ones that simply
&gt; need sha1, would avoid linking to nettle and just copy the algorithms
&gt; they need internally. In any embedded system using nettle+hogweed
&gt; would require more memory and overhead than having a single library.
&gt; That is of course not a very significant overhead, but it harms the
&gt; actual programs it targets to help.

Also maybe it is time to introduce symbol versioning. As nettle 2.7
will be present for quite some time in desktops it would be good to
avoid conflicts between libraries that are linked with nettle-2.7 and
programs that are linked with nettle-3.0 (or vice-versa).

regards,
Nikos

</body></email><email><emailId>20140616145727</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2014-06-16 14:57:27-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.0</subject><body>

&gt; Date: Mon, 16 Jun 2014 10:36:59 +0200
&gt; From: Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt;
&gt; Cc: info-gnu@gnu.org, Nettle Crypto Library &lt;nettle-bugs@lists.lysator.liu.se&gt;
&gt; 
&gt;  As the ABI broke anyway in 3.0, would it make sense to merge the
&gt; nettle and hogweed libraries? Hogweed cannot be used without linking
&gt; to libnettle, thus the advantage of the current split is only to
&gt; applications that only use libnettle. Nevertheless, I don't think
&gt; there are such applications.

Hogweed needs GMP, so if someone doesn't want to depend on it, they
cannot build hogweed.  Of course, if the merged library will build
even when GMP is not present, just without some APIs, that's fine too.

</body></email><email><emailId>20140616163424</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-06-16 16:34:24-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.0</subject><body>

On Mon, 2014-06-16 at 17:57 +0300, Eli Zaretskii wrote:
&gt; &gt;  As the ABI broke anyway in 3.0, would it make sense to merge the
&gt; &gt; nettle and hogweed libraries? Hogweed cannot be used without linking
&gt; &gt; to libnettle, thus the advantage of the current split is only to
&gt; &gt; applications that only use libnettle. Nevertheless, I don't think
&gt; &gt; there are such applications.
&gt; 
&gt; Hogweed needs GMP, so if someone doesn't want to depend on it, they
&gt; cannot build hogweed.  Of course, if the merged library will build
&gt; even when GMP is not present, just without some APIs, that's fine too.

There is a patch to use hogweed even without gmp, and is currently part
of the openwrt nettle (2.7.1) package, thus one could avoid that
dependency altogether and still have (slow) public key support. 

regards,
Nikos



</body></email><email><emailId>20140616170818</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-16 17:08:18-0400</timestampReceived><subject>Re: ANNOUNCE: Nettle-3.0</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt;  As the ABI broke anyway in 3.0, would it make sense to merge the
&gt; nettle and hogweed libraries?

Maybe as a build option, but not for a normal installation.

&gt; the advantage of the current split is only to
&gt; applications that only use libnettle. Nevertheless, I don't think
&gt; there are such applications. My guess is that the ones that simply
&gt; need sha1, would avoid linking to nettle and just copy the algorithms
&gt; they need internally.

But I think those applications should use nettle... Adding a gmp
dependency makes that less attractive.

&gt; In any embedded system using nettle+hogweed
&gt; would require more memory and overhead than having a single library.

Could you put some numbers to that overhead? I can't say if it's worth
trying to avoid.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140624185535</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-24 18:55:35-0400</timestampReceived><subject>Re: turn RSA blinding off in openssl</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; diff --git a/examples/hogweed-benchmark.c b/examples/hogweed-benchmark.c
&gt; index 05372ab..311fa2d 100644
&gt; --- a/examples/hogweed-benchmark.c
&gt; +++ b/examples/hogweed-benchmark.c
&gt; @@ -521,6 +521,7 @@ bench_openssl_rsa_init (unsigned size)
&gt;    ctx-&gt;ref = xalloc (RSA_size (ctx-&gt;key));
&gt;    ctx-&gt;signature = xalloc (RSA_size (ctx-&gt;key));
&gt;    ctx-&gt;digest = hash_string (&amp;nettle_sha1, 3, "foo");
&gt; +  RSA_blinding_off(ctx-&gt;key);
&gt;  
&gt;    if (! RSA_sign (NID_sha1, ctx-&gt;digest, SHA1_DIGEST_SIZE,
&gt;  		  ctx-&gt;ref, &amp;ctx-&gt;siglen, ctx-&gt;key))

Thanks, applied.

/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140624200655</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-06-24 20:06:55-0400</timestampReceived><subject>Re: Simplifying pic vs non-pic object files</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

Niels Möller wrote:
&gt; Does that make sense? It would make things simpler, shorten build
&gt; time, and eliminate the problem of naming two types of object files.

Yes, makes sense. One type by default. Good idea.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIcBAEBCAAGBQJTqdpeAAoJEF3cfFQkIuyNXAYQAI5Bg9HcW0dfS0v+R75qTtW1
ydAyDGz8fl6fk7qvgWRUndbYHbwwcCtR+HkVm8zG7eOjtiuYm/QdUgGgCFkOjkY8
XkLP4/mCeoDJ2evwjVlKtla2qJjwgGHHKz9ydZOSfHK6MkD+Mf7e0vh3PyeB7X/T
X5FLcY8EAVC6QciHg5KqZsCfzaLCA21n5tRGtu+cGCyO41zmt6yTf9+3YJwQ86y7
618sum6HohY0WnNvXgx61LLVgF+5Pe6OWvP5R7lFxaYDm4dmFOVFJOEOe2JZEWTT
PoR1GcGQoP3YBpzlFS/vKd8xLZSFcAvIWGKJ9SShYq6AqtV8j7uDrkzfCcHeEL5W
P8pVbo/3/mSnn/fRNbpn7UeKdpqD3yWYGdF0p+SD8hJlFhBmE2CZlQw/yVUyQ3UA
pfU+hOJeE6O0PNPlG2oi/uwjCgcFcza8qBX+uJzQAX3i3afce2SAn3zZEK4iJYTW
iVWwBiPZvA7CoXQldIYlI6KB8SS481MMTrh/hfy76UnCDgT7Ek4DHlHAOs/VPSrP
61f4Qs8azYVPsR75waJNbcFfUSSlIiRh/WgOPU8WeXpoR7IDz5NylVDx2osnkI+N
5tH1KrvruQdFuAia9JOm/o2sKizIcUy3pkgz8RG7ocV9gvvTLUMD3VpWSak+elAc
maWi+H5XBOshBtsLSgD/
=Sr9h
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140626073041</emailId><senderName>Martin Storsjö</senderName><senderEmail>martin@martin.st</senderEmail><timestampReceived>2014-06-26 07:30:41-0400</timestampReceived><subject>[PATCH 2/3] Add missing entries to .gitignore</subject><body>

Ignore the newly generated bignum.h, also ignore OS X dylibs
and lib{nettle,hogweed}.stamp.
---
 .gitignore | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/.gitignore b/.gitignore
index 9fb025e..2af4d2d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -11,6 +11,7 @@ TAGS
 *.so
 *.exe
 *.dll
+*.dylib
 core
 /*.d
 /*.po
@@ -20,6 +21,7 @@ core
 /.lib
 /*.asm
 /Makefile
+/bignum.h
 /config.cache
 /config.h
 /config.h.in
@@ -37,7 +39,7 @@ core
 /aesdata
 /desdata
 /eccdata
-/eccdata.stamp
+/*.stamp
 /gcmdata
 /shadata
 /twofishdata
-- 
1.8.5.2 (Apple Git-48)


</body></email><email><emailId>20140626151853</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-26 15:18:53-0400</timestampReceived><subject>Re: [PATCH 3/3] Include private dependencies automatically in pkg-config for non-shared builds</subject><body>

Martin Storsjö &lt;martin@martin.st&gt; writes:

&gt; For these cases, where a library is built as only a static library,
&gt; one fairly common convention (not used everywhere, but at least in
&gt; some libraries I regularly use) is to include the private dependencies
&gt; in the non-private section. This makes sure a user of the library
&gt; doesn't need to be concerned about which way this library was built
&gt; (unless the user intentionally overrides defaults by passing
&gt; flags such as -static to the linker).

Makes some sense to me. Is there any reasonable way to test these
things? If not part of the ordinary make check, perhaps part of make
distcheck or some other separate target.

If you feel like it, it would be nice with a short description of how
it's intended to work, in the node "Linking" in the manual.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140626205057</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-26 20:50:57-0400</timestampReceived><subject>Re: nettle-mini</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; I haven't tested with gnutls, as I still need to convert it to use the
&gt; new API, but a small patch is attached which makes hogweed-benchmark
&gt; to run on Fedora and RHEL (that don't include the SECP-224 and 192
&gt; curves).

Pushed on the master branch. Thanks.

/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140626205203</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-06-26 20:52:03-0400</timestampReceived><subject>Re: [PATCH 1/3] Don't hardcode the -lgmp linker flag in the hogweed pkg-config file</subject><body>

All three patches pushed on the master branch. Thanks.

/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140503075328</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-03 07:53:28-0400</timestampReceived><subject>Re: [PATCH v3] CCM Cipher Modes</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I get a couple of warnings, when compiling for 32-bit platforms, e.g.,
&gt; ARM.
&gt;
&gt; /home/nisse/hack/nettle/ccm.c: In function `nettle_ccm_set_nonce':
&gt; /home/nisse/hack/nettle/ccm.c:134:3: warning: comparison is always
&gt; false due to limited range of data type [-Wtype-limits]
&gt; /home/nisse/hack/nettle/ccm.c:138:5: warning: right shift count &gt;=
&gt; width of type [enabled by default]
&gt; /home/nisse/hack/nettle/ccm.c:139:5: warning: right shift count &gt;=
&gt; width of type [enabled by default]
&gt; /home/nisse/hack/nettle/ccm.c:140:5: warning: right shift count &gt;=
&gt; width of type [enabled by default]
&gt; /home/nisse/hack/nettle/ccm.c:141:5: warning: right shift count &gt;=
&gt; width of type [enabled by default]

Fixed now. Added a configure test for sizeof(size_t).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140503075533</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-03 07:55:33-0400</timestampReceived><subject>Re: [PATCH] Some CCM mode documentation</subject><body>

Owen Kirby &lt;osk@exegin.com&gt; writes:

&gt; Yep, that looks good.

I've now added CCM_MAX_MSG_SIZE() and constants CCM_MIN_NONCE_SIZE,
CC_MAX_NONCE_SIZE, CCM_DIGEST_SIZE, and updated the docs a bit.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140506091309</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-06 09:13:09-0400</timestampReceived><subject>Re: Documentation update</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; SHA3-224 section: I'd provide a reference to
&gt; http://csrc.nist.gov/publications/drafts/fips-202/fips_202_draft.pdf,
&gt; since it is now published.
&gt;
&gt; I don't see any test vectors to verify but note that the document
&gt; says: "The four SHA-3 hash functions differ slightly from the
&gt; instances of KECCAK that were proposed for the SHA-3 competition [3].
&gt; In particular, two additional bits are appended to the messages, in
&gt; order to distinguish the SHA-3 hash functions from the SHA-3 XOFs, and
&gt; to facilitate the development of new variants of the SHA-3 functions
&gt; that can be dedicated to individual application domains. The mechanism
&gt; for achieving these goals is called domain separation".

This is going to get a bit messy. I think you mentioned changes earlier,
but I haven't seen any details until now. If I understand this
correctly, they append two bits 01 to the messages (see page 20). Not
sure if there are any other changes, but that's sufficient to make it
incompatible with the current implementation.

Some (not yet official) test vectors seem to be available at
http://csrc.nist.gov/groups/ST/toolkit/examples.html#aHashing

Nettle changes should wait until the specification is final.

&gt; Camellia: I'd add "Camellia is one of the selected algorithms in the
&gt; New European Schemes for Signatures, Integrity and Encryption (NESSIE)
&gt; project".
&gt; https://www.cosic.esat.kuleuven.be/nessie/deliverables/press_release_feb27.pdf
&gt;
&gt; Galois counter mode: (see Keyed hash functions... parenthesis doesn't close.

Thanks, I'll address that.

&gt; ChaCha-Poly1305: If you plan a release soon, I'd suggest not to
&gt; include that yet. There is no document you can refer to and the latest
&gt; draft document we have already differs from the implementation.
&gt; (see http://tools.ietf.org/html/draft-nir-cfrg-chacha20-poly1305-02 )

I'd expect that the variant implemented in openssh is going to see some
use. But maybe it's better to either leave chacha-poly1305 undocumented
for now, or mark it clearly as experimental and not expected to stay
compatible.

&gt; Traditional Nettle Soup: I never knew there was such a thing :)

This is the right time of the year to prepare that soup. It's pretty good.

On the other hand, I'm fairly sure there's *no* way to prepare anything
edible from hogweed.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140529065418</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-29 06:54:18-0400</timestampReceived><subject>git server changes</subject><body>

Lysator's git server, git.lysator.liu.se, is about to be replaced. New
server will run gitlab software instead of the current gitorious.

Nettle and LSH repos (as well as other repos I have there) will move,
but they may be temporarily unavailable in the weekend or next week.
Don't panic. I'll send another mail once everything is ready at the new
server. Intention is that git urls will be unchanged.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140531200725</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-31 20:07:25-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt;&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt;&gt; When you configure nettle with --disable-public-key, do both 32-bit and
&gt;&gt; 64-bit windows builds work?
&gt;
&gt; Only 32-bit.  I don't have a 64-bit development environment here.

Noted. Thanks for testing,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140402135601</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-04-02 13:56:01-0400</timestampReceived><subject>Re: nettle-mini</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I've now have nettle-mini for both master and 2.7. The patches
&gt; required for master are gmp-mini branch and for 2.7 in
&gt; nettle-2.7-mini-gmp.

Nice!

&gt; I'd appreciate if these go upstream as I've failed to add nettle to
&gt; openwrt (and don't have to time to pursue that further), so I no
&gt; longer plan to maintain these patches separately (and they will be
&gt; easily break on makefile changes).

I'd really like to add mini-gmp support on the master branch, but I
think it has to wait until after the release. I see one issue which your
code, which I'd like to fix before integration, and that is that I think
it is a bit too brittle to link the test programs with the real gmp.
Problem is that mpz_t defined by gmp and mini-gmp is not really
compatible.

It's possible to use mini-gmp and gmp in the same executable, since the
symbol names seen by the linker are different, but then each compilation
unit should use either gmp or mini-gmp, and no mpz_t variables can be
passed across this boundary. The mini-gmp testsuite does this,
converting numbers to hex strings when they need to be passed between
gmp and mini-gmp functions.

For the nettle testsuite, I hope one can get by with something simpler.
Do as many of the tests as possible using mini-gmp only, and disable
tests which depend on functions only available in the real gmp library,
e.g., mpz_urandomb.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140410192213</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-04-10 19:22:13-0400</timestampReceived><subject>Re: [PATCH] Enabled tests for openssl curves secp256r1 and secp192r1.</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; This patch allows comparing the performance differences in secp256r1
&gt; (the curve mostly used in the web), between nettle and openssl.

Thanks, pushed now.

/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140411174021</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-04-11 17:40:21-0400</timestampReceived><subject>Re: [PATCH v3] CCM Cipher Modes</subject><body>

Owen Kirby &lt;osk@exegin.com&gt; writes:

&gt; Actually, that's not entirely correct. I have seen some architectures
&gt; that will turn a shift into a nop when the shift width is greater than
&gt; the word size.

Shifts greater than the word size can give different types of undefined
behaviour. Ignoring higher bits of the shift count is also common, I
think, depending on compiler and instruction set.

But in this case, I think it can't cause any real harm, because these
shifts are inside an

  if (authlen &gt;= (0x01ULL &lt;&lt; 32)) {
  
which should be always false if authlen (of type size_t) is 32-bits.

&gt; I have some ARM boards that I can cross compile for, so
&gt; I'll take a look at cleaning up the warnings when I get some time this
&gt; weekend.

I think you get the same warnings if you configure with CC='gcc -m32'
CXX='g++ -m32' on a plain x86_64 gnu/linux box or similar.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140411194954</emailId><senderName>James Cloos</senderName><senderEmail>cloos@jhcloos.com</senderEmail><timestampReceived>2014-04-11 19:49:54-0400</timestampReceived><subject>Re: Feature removals</subject><body>

&gt;&gt;&gt;&gt;&gt; "DKG" == Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

DKG&gt; it looks like there are lots of programs that are either embedding
DKG&gt; libdes or relying on other packages like krb5 for something that
DKG&gt; looks roughly like a linked libdes.

DKG&gt; emacs is just one of these.

Emacs supports kerberos auth for some stuff; it looks like it wants des
support just for that.

-JimC
--
James Cloos &lt;cloos@jhcloos.com&gt;         OpenPGP: 1024D/ED7DAEA6

</body></email><email><emailId>20140425201346</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-04-25 20:13:46-0400</timestampReceived><subject>Re: Rename, MD5_DATA_SIZE -&gt; MD5_BLOCK_SIZE, etc ?</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; In another forum, it was suggested that UMAC_DATA_SIZE be renamed to
&gt; UMAC_BLOCK_SIZE, and for consistency one could do the same with, e.g.,
&gt; MD5_DATA_SIZE. For the time being, the old names should be kept for
&gt; backwards compatibility.

Renaming done now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140428094322</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-04-28 09:43:22-0400</timestampReceived><subject>Re: Side-channel silet memcmp</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

Niels Möller wrote:
&gt; There are lots of authentication functions which end by comparing
&gt; two digests. The recent ccm_decrypt_message is typical, ending with
&gt; 
&gt; return (memcmp(tag, src + mlength, tlength) == 0);

&gt; int mem_equal (const void *ap, const void *bp, size_t n) { volatile
&gt; const unsigned char *a = ap; volatile const unsigned char *b = bp

Missing semicolon for bp.


&gt; volatile unsigned char d; size_t i; for (i = d = 0; i &lt; n; i++) d |=
&gt; a[i] ^ b[i]; return d == 0;

You should return d here if you want the behaviour to match memcmp.

FWIW I implemented the function above (minus changes to stdint types) in
my umactests. And for 100M messages, each 1024 Bytes I see something
like a few second total increase in performance in comparison to using
the memcmp provided in OSX. I can live with that.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIcBAEBCAAGBQJTXiK6AAoJEF3cfFQkIuyNT34QAIq0XjYCKo8pNTNWXKTrS3mA
UVLuOiQR5ar4nEAm4vsaNBE014/mGo2Gp9xP1wEGK65T0KGIDVlrg/1A4fiilAcg
ORSBnHUI386+volf6Nld7qaVfbTtldXg7OTZKEyBZ7yrViZ0jyB6NPLOsb8li1D2
CDZz9EstEkPCtJ9zYWIjTQRNDJ7N/SfIBFVSFIElzCaa+jo1gY1jI79OHRGP3Vj/
2PcmzocMP/UHTHpWWRTmd+me059yiWZ2En6ZUWmaWvQegOWrLZyTF/3iX8rimjRB
tvL1mC0iSYRBHLb61J3SPVbxXujYcFQbICC8C7QXNDbtp+7h0q40xy9zaMFJkBMI
aBh93wpCAigAdwole7OA8z+OKBTnsH6YegAA6nelAuip83kq9AIKz0ETSHXfnwKr
IWai9nISq79qTkGUsL14etFrtGRGu985jcv+PMO2cHIbpHnU9D9hgo005eAJIhll
P1h9rATWrbJM5cyipvaZhDrVCClNUfKY20c3tCuY6lyieAnwYGND2rI5ARWMCBoD
3jrouwG27FSWeKthEd5LPvGDkBLrdc4fcD5oOATKTOrPc8GeASU+IpqITpYFD9Ak
VBDGltQoV90L/D1yFAEnj6pklz8OE3F+JQO7OEQ1NtyMtcH3aqA3JnR63odMTLyL
Bk3M7ZoBe7Dhh7YhoHSz
=ssYB
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140429172313</emailId><senderName>Owen Kirby</senderName><senderEmail>osk@exegin.com</senderEmail><timestampReceived>2014-04-29 17:23:13-0400</timestampReceived><subject>Re: [PATCH] Some CCM mode documentation</subject><body>

Niels,

Yep, that looks good.

Thanks,
Owen

On 14-04-29 10:16 AM, Niels Möller wrote:
&gt; Owen Kirby &lt;osk@exegin.com&gt; writes:
&gt;
&gt;&gt; It also occurs to me that the my formula for calculating the maximum
&gt;&gt; message size from L is completely wrong. L basically specifies the size
&gt;&gt; of the counter field (in bytes), so it should really be maxlength = (1
&gt;&gt; &lt;&lt; (L*8)) - 1.
&gt; Is the following correct? Intended for ccm.h:
&gt;
&gt; /* Maximum cleartext message size, as a function of the nonce size N.
&gt;    The length field is L octets, with L = 15 - N, and then the maximum
&gt;    size M = 2^{8L} - 1. */
&gt; #define CCM_MAX_MSG_SIZE(N)			\
&gt;   ((sizeof(size_t) + (N) &lt;= 15)			\
&gt;    ? ~(size_t) 0				\
&gt;    : ((size_t) 1 &lt;&lt; (8*(15 - N))) - 1)
&gt;
&gt;
&gt; Regards,
&gt; /Niels
&gt;


</body></email><email><emailId>20140530100208</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-30 10:02:08-0400</timestampReceived><subject>Problem with w32 shared libraries</subject><body>

I just tested w32 support,

  ./configure --host=i586-mingw32msvc

which produces shared libraries (and I'm not sure I've tested this
eariler, I may have used --disable-shared on earlier builds for w32).

When I run the testsuite with make check EMULATOR=wine, the arcfour
testcase fails. wine reports the error like

Unhandled exception: page fault on read access to 0x70dc344d in 32-bit code \
(0x70dc344d). Register dump:
 CS:0023 SS:002b DS:002b ES:002b FS:0063 GS:006b
 EIP:70dc344d ESP:0061fc5c EBP:0061fdc8 EFLAGS:00010202(  R- --  I   - - - )
 EAX:0061fcba EBX:00000001 ECX:00000001 EDX:00000001
 ESI:001139ef EDI:001139b0
Stack dump:
0x0061fc5c:  004014bd 0061fcba 00000001 001139f0
0x0061fc6c:  001139b0 0061fcd0 7bc4abf6 00000001
0x0061fc7c:  00113990 001139f8 001139b0 001139d0
0x0061fc8c:  00000000 00000000 00113988 001139a8
0x0061fc9c:  001139c8 00000008 00000009 001139f0
0x0061fcac:  7bc3812f 00000020 0061fcc8 df019956
Backtrace:
=&gt;0 0x70dc344d (0x0061fdc8)
  1 0x00401767 test_main+0x36() [/home/nisse/hack/nettle/testsuite/arcfour-test.c:73] \
in arcfour-test (0x0061fde8)  2 0x00401767 test_main+0x36() \
[/home/nisse/hack/nettle/testsuite/arcfour-test.c:73] in arcfour-test (0x0061fe08)

I'm not entirely sure how to interpret this, but it looks like the
instruction pointer gets a bogus value. It looks like there's a problem
with arcfoure-crypt.asm, because configuring with --disable-assembler
seems to work fine. Also compiling with --disable-shared works fine.

Questions:

1. Can the problem be reproduced on a M$ windows machine?

2. Are there any calling convention subtleties in dll calls? I just push
   and pop the callee-save registers %ebx, %ebp, %esi, %edi, and read
   the arguments from the stack.

I have no dllimport/dllexport stuff in the header files, instead relying
on mingw tools doing the right thing automatically. I get lots of
messages like

     Info: resolving _nettle_arcfour_crypt by linking to __imp__nettle_arcfour_crypt \
(auto-import)  /usr/lib/gcc/i586-mingw32msvc/4.2.1-sjlj/../../../../i586-mingw32msvc/bin/ld: \
warning: auto-importing has been activated without --enable-auto-import specified on \
                the command line.
     This should work unless it involves constant data structures referencing symbols \
from auto-imported DLLs.

This probably needs fixing at some point, but as far as I see,
arcfour-test doesn't use any references from constant data, and it
should be independent of the choice between C or assembly for
arcfour-crypt.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140530104558</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2014-05-30 10:45:58-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Date: Fri, 30 May 2014 12:02:08 +0200
&gt; 
&gt; I just tested w32 support,
&gt; 
&gt; ./configure --host=i586-mingw32msvc

Why the "msvc" suffix?  I think it shouldn't be there.  (Not that I
think this necessarily has any relevance to your problem.)

&gt; which produces shared libraries (and I'm not sure I've tested this
&gt; eariler, I may have used --disable-shared on earlier builds for w32).
&gt; 
&gt; When I run the testsuite with make check EMULATOR=wine, the arcfour
&gt; testcase fails. wine reports the error like
&gt; 
&gt; Unhandled exception: page fault on read access to 0x70dc344d in 32-bit code \
&gt; (0x70dc344d). Register dump:
&gt; CS:0023 SS:002b DS:002b ES:002b FS:0063 GS:006b
&gt; EIP:70dc344d ESP:0061fc5c EBP:0061fdc8 EFLAGS:00010202(  R- --  I   - - - )
&gt; EAX:0061fcba EBX:00000001 ECX:00000001 EDX:00000001
&gt; ESI:001139ef EDI:001139b0
&gt; Stack dump:
&gt; 0x0061fc5c:  004014bd 0061fcba 00000001 001139f0
&gt; 0x0061fc6c:  001139b0 0061fcd0 7bc4abf6 00000001
&gt; 0x0061fc7c:  00113990 001139f8 001139b0 001139d0
&gt; 0x0061fc8c:  00000000 00000000 00113988 001139a8
&gt; 0x0061fc9c:  001139c8 00000008 00000009 001139f0
&gt; 0x0061fcac:  7bc3812f 00000020 0061fcc8 df019956
&gt; Backtrace:
&gt; =&gt;0 0x70dc344d (0x0061fdc8)
&gt; 1 0x00401767 test_main+0x36() [/home/nisse/hack/nettle/testsuite/arcfour-test.c:73] \
&gt; in arcfour-test (0x0061fde8) 2 0x00401767 test_main+0x36() \
&gt; [/home/nisse/hack/nettle/testsuite/arcfour-test.c:73] in arcfour-test (0x0061fe08) 
&gt; I'm not entirely sure how to interpret this

It's the equivalent of a SIGSEGV, but I'm sure you know that.

&gt; 1. Can the problem be reproduced on a M$ windows machine?

If you tell which tarball to download and how to configure and build
it, I can try reproducing this in a native build.

&gt; 2. Are there any calling convention subtleties in dll calls?

What do you mean by "dll calls"?  Do you mean calling functions that
are in a DLL?  If so, they go through an indirect call in the import
library, but other than that, they use the normal "cdecl" calling
convention.

&gt; I just push
&gt; and pop the callee-save registers %ebx, %ebp, %esi, %edi, and read
&gt; the arguments from the stack.

Was the code compiled with or without optimizations?  If the former,
some arguments might be in registers, not on the stack.

&gt; I have no dllimport/dllexport stuff in the header files, instead relying
&gt; on mingw tools doing the right thing automatically. I get lots of
&gt; messages like
&gt; 
&gt; Info: resolving _nettle_arcfour_crypt by linking to __imp__nettle_arcfour_crypt \
&gt;                 (auto-import)
&gt; /usr/lib/gcc/i586-mingw32msvc/4.2.1-sjlj/../../../../i586-mingw32msvc/bin/ld: \
&gt; warning: auto-importing has been activated without --enable-auto-import specified \
&gt; on the command line. This should work unless it involves constant data structures \
&gt; referencing symbols from auto-imported DLLs.

This is normal, and shouldn't cause problems, as long as it is
limited to functions (as opposed to data).

&gt; This probably needs fixing at some point

To fix that, just use the --enable-auto-import linker switch, as the
message says.  (Also, I think newer versions of GCC and Binutils do
that automatically.)


</body></email><email><emailId>20140530135740</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-30 13:57:40-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt; Why the "msvc" suffix?  I think it shouldn't be there.  (Not that I
&gt; think this necessarily has any relevance to your problem.)

Only because the debian mingw32 package uses names like
"i586-mingw32msvc-gcc" for cross-compiler and related tools.

&gt; &gt; Unhandled exception: page fault on read access to 0x70dc344d in 32-bit code \
&gt; &gt; (0x70dc344d). Register dump:
&gt; &gt; CS:0023 SS:002b DS:002b ES:002b FS:0063 GS:006b
&gt; &gt; EIP:70dc344d ESP:0061fc5c EBP:0061fdc8 EFLAGS:00010202(  R- --  I   - - - )
&gt; &gt; EAX:0061fcba EBX:00000001 ECX:00000001 EDX:00000001
&gt; &gt; ESI:001139ef EDI:001139b0
&gt; &gt; Stack dump:
&gt; &gt; 0x0061fc5c:  004014bd 0061fcba 00000001 001139f0
&gt; &gt; 0x0061fc6c:  001139b0 0061fcd0 7bc4abf6 00000001
&gt; &gt; 0x0061fc7c:  00113990 001139f8 001139b0 001139d0
&gt; &gt; 0x0061fc8c:  00000000 00000000 00113988 001139a8
&gt; &gt; 0x0061fc9c:  001139c8 00000008 00000009 001139f0
&gt; &gt; 0x0061fcac:  7bc3812f 00000020 0061fcc8 df019956
&gt; &gt; Backtrace:
&gt; &gt; =&gt;0 0x70dc344d (0x0061fdc8)
&gt; &gt; 1 0x00401767 test_main+0x36() \
&gt; &gt; [/home/nisse/hack/nettle/testsuite/arcfour-test.c:73] in arcfour-test \
&gt; &gt; (0x0061fde8) 2 0x00401767 test_main+0x36() \
&gt; &gt; [/home/nisse/hack/nettle/testsuite/arcfour-test.c:73] in arcfour-test \
&gt; &gt; (0x0061fe08) 
&gt; &gt; I'm not entirely sure how to interpret this
&gt; 
&gt; It's the equivalent of a SIGSEGV, but I'm sure you know that.

Right, I understand it's an access at an invalid address. Some things
that are unclear to me: The meaning of the second address in "=&gt;0
0x70dc344d (0x0061fdc8)". And why "test_main+0x36()
[/home/nisse/hack/nettle/testsuite/arcfour-test.c:73]" occurs a large
number of times in the backtrace. I quoted just the first two above, but
it's 200 such lines, with only the value in the last parentheses
differing between lines (and 0x00000000 in all but the first 10 lines) .

&gt; &gt; 1. Can the problem be reproduced on a M$ windows machine?
&gt; 
&gt; If you tell which tarball to download and how to configure and build
&gt; it, I can try reproducing this in a native build.

I think it would be interesting both to test native compilation, and to
test the cross compiled arcfour-test.exe and libnettle.dll on a w32
machine.

Is it possible for you to do a git checkout?

For the cross-compile case, it would be

  git clone git://git.lysator.liu.se/nettle/nettle.git
  cd nettle
  ./.bootstrap
  ./configure --host=i586-mingw32msvc
  make
  make -C testsuite arcfour-test.exe

and then copy .lib/libnettle-5-0.dll and testsuite/arcfour-test.exe to
the windows test machine.

For native compile, instead ./configure &amp;&amp; make dist to produce a
tarball.

&gt; &gt; 2. Are there any calling convention subtleties in dll calls?
&gt; 
&gt; What do you mean by "dll calls"?  Do you mean calling functions that
&gt; are in a DLL?  If so, they go through an indirect call in the import
&gt; library, but other than that, they use the normal "cdecl" calling
&gt; convention.

Ok, the assembly code is intended to use the plain cdecl convention.

I'm really puzzled. If I use i586-mingw32msvc-objdump to disassemble
arcfour-test.exe, the call to nettle_arcfour_crypt looks like

  4014e7:       53                      push   %ebx
  4014e8:       50                      push   %eax
  4014e9:       e8 b2 6c 00 00          call   4081a0 &lt;__imp__nettle_arcfour_crypt&gt;

004014ea &lt;__fu0__nettle_arcfour_crypt&gt;:
  4014ea:       b2 6c                   mov    $0x6c,%dl
  4014ec:       00 00                   add    %al,(%eax)
  4014ee:       8b 95 d8 fe ff ff       mov    -0x128(%ebp),%edx

Looks sane to me.

However, when I run it in gdb (I inserted an asm volatile("int $3") in
the C code, and then I run native gdb on the wine.bin ELF-binary, and
give wine the arcfour-test.exe file as argument), and disassemble the
code, the address is different,

Dump of assembler code from 0x4014e9 to 0x4014fd:
=&gt; 0x004014e9:  call   0x70dc347e
   0x004014ee:  mov    -0x128(%ebp),%edx
   0x004014f4:  add    $0x20,%esp
   0x004014f7:  cmpb   $0x17,(%esi,%edx,1)
   0x004014fb:  jne    0x401655

If I also dump the machine code for the call instruction it's

   e8 90 1f 9c 70

So this has somehow been relocated when the .exe file was loaded by
wine, and relocated incorrectly to point into nowhere. I'm not really
sure what the instruction format is, but isn't it pc-relative
addressing? Or is relocation expected here?

And it's fetching the next instruction, at address 0x70dc347e, that
results in an invalid memory access. So it's before it gets to the
implementation of nettle_arcfour_crypt, which makes it even more
puzzling that the implementation language seem to matter. Maybe I need
some special pseudo-ops in the assembly file to get it to be linked
correctly as part of a dll?

So this could be some bug in my assembly code, or problem with the cross
tools or the way I invoke them, or a bug in wine.

&gt; Was the code compiled with or without optimizations?  If the former,
&gt; some arguments might be in registers, not on the stack.

arcfour_crypt is in it's own source file, either .c or .asm. So it ought
to always use the same "cdecl" convention. And it breaks only when the
assembly file is used.

&gt; To fix that, just use the --enable-auto-import linker switch, as the
&gt; message says.  (Also, I think newer versions of GCC and Binutils do
&gt; that automatically.)

I have some structures (but not in the arcfour-test program with
function pointers). Both in the library, e.g, const struct nettle_hash
nettle_md5, and in the application, e.g, const struct nettle_aead
nettle_arcfour128 (defined in nettle-internal.c, and linked into the
nettle-benchmark executable). Both structs include function pointers to
functions defined in the shared library.

The message seemed to say that the latter case won't work with auto
import, but maybe I misunderstood it.

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140530154737</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2014-05-30 15:47:37-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Cc: nettle-bugs@lists.lysator.liu.se
&gt; Date: Fri, 30 May 2014 15:57:40 +0200
&gt; 
&gt; &gt; &gt; =&gt;0 0x70dc344d (0x0061fdc8)
&gt; &gt; &gt; 1 0x00401767 test_main+0x36() \
&gt; &gt; &gt; [/home/nisse/hack/nettle/testsuite/arcfour-test.c:73] in arcfour-test \
&gt; &gt; &gt; (0x0061fde8) 2 0x00401767 test_main+0x36() \
&gt; &gt; &gt; [/home/nisse/hack/nettle/testsuite/arcfour-test.c:73] in arcfour-test \
&gt; &gt; &gt; (0x0061fe08) 
&gt; &gt; &gt; I'm not entirely sure how to interpret this
&gt; &gt; 
&gt; &gt; It's the equivalent of a SIGSEGV, but I'm sure you know that.
&gt; 
&gt; Right, I understand it's an access at an invalid address. Some things
&gt; that are unclear to me: The meaning of the second address in "=&gt;0
&gt; 0x70dc344d (0x0061fdc8)". And why "test_main+0x36()

I don't use wine, so I don't know what that means.

&gt; [/home/nisse/hack/nettle/testsuite/arcfour-test.c:73]" occurs a large
&gt; number of times in the backtrace. I quoted just the first two above, but
&gt; it's 200 such lines, with only the value in the last parentheses
&gt; differing between lines (and 0x00000000 in all but the first 10 lines) .

Sounds like infinite recursion?

&gt; Is it possible for you to do a git checkout?

Yes.

&gt; For the cross-compile case, it would be
&gt; 
&gt; git clone git://git.lysator.liu.se/nettle/nettle.git
&gt; cd nettle
&gt; ./.bootstrap
&gt; ./configure --host=i586-mingw32msvc
&gt; make
&gt; make -C testsuite arcfour-test.exe
&gt; 
&gt; and then copy .lib/libnettle-5-0.dll and testsuite/arcfour-test.exe to
&gt; the windows test machine.
&gt; 
&gt; For native compile, instead ./configure &amp;&amp; make dist to produce a
&gt; tarball.

OK, I'll see what I can find out.

&gt; I'm really puzzled. If I use i586-mingw32msvc-objdump to disassemble
&gt; arcfour-test.exe, the call to nettle_arcfour_crypt looks like
&gt; 
&gt; 4014e7:       53                      push   %ebx
&gt; 4014e8:       50                      push   %eax
&gt; 4014e9:       e8 b2 6c 00 00          call   4081a0 &lt;__imp__nettle_arcfour_crypt&gt;
&gt; 
&gt; 004014ea &lt;__fu0__nettle_arcfour_crypt&gt;:
&gt; 4014ea:       b2 6c                   mov    $0x6c,%dl
&gt; 4014ec:       00 00                   add    %al,(%eax)
&gt; 4014ee:       8b 95 d8 fe ff ff       mov    -0x128(%ebp),%edx
&gt; 
&gt; Looks sane to me.
&gt; 
&gt; However, when I run it in gdb (I inserted an asm volatile("int $3") in
&gt; the C code, and then I run native gdb on the wine.bin ELF-binary, and
&gt; give wine the arcfour-test.exe file as argument), and disassemble the
&gt; code, the address is different,
&gt; 
&gt; Dump of assembler code from 0x4014e9 to 0x4014fd:
&gt; =&gt; 0x004014e9:  call   0x70dc347e
&gt; 0x004014ee:  mov    -0x128(%ebp),%edx
&gt; 0x004014f4:  add    $0x20,%esp
&gt; 0x004014f7:  cmpb   $0x17,(%esi,%edx,1)
&gt; 0x004014fb:  jne    0x401655

Hard to say what's going on here, as too many non-native tools are
involved.

&gt; So this has somehow been relocated when the .exe file was loaded by
&gt; wine, and relocated incorrectly to point into nowhere. I'm not really
&gt; sure what the instruction format is, but isn't it pc-relative
&gt; addressing? Or is relocation expected here?

The only thing I'd expect is a call through an indirect address, since
you are linking to a DLL.  But the above doesn't look like that.

&gt; The message seemed to say that the latter case won't work with auto
&gt; import, but maybe I misunderstood it.

I'll look into it.


</body></email><email><emailId>20140410171520</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-04-10 17:15:20-0400</timestampReceived><subject>[PATCH] Enabled tests for openssl curves secp256r1 and secp192r1.</subject><body>

This patch allows comparing the performance differences in secp256r1
(the curve mostly used in the web), between nettle and openssl.

regards,
Nikos


["0001-Enabled-tests-for-openssl-curves-secp256r1-and-secp1.patch" (0001-Enabled-tests-for-openssl-curves-secp256r1-and-secp1.patch)]

&gt; From 20ce12e20ce8306a62d7142718c9ed790cc74ded Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Thu, 10 Apr 2014 19:13:00 +0200
Subject: [PATCH] Enabled tests for openssl curves secp256r1 and secp192r1.

---
 examples/hogweed-benchmark.c | 10 ++++------
 1 file changed, 4 insertions(+), 6 deletions(-)

diff --git a/examples/hogweed-benchmark.c b/examples/hogweed-benchmark.c
index 3b189c4..2b81c7e 100644
--- a/examples/hogweed-benchmark.c
+++ b/examples/hogweed-benchmark.c
@@ -567,25 +567,21 @@ bench_openssl_ecdsa_init (unsigned size)
   /* Apparently, secp192r1 and secp256r1 are missing */
   switch (size)
     {
-#if 0
     case 192:
-      ctx-&gt;key = EC_KEY_new_by_curve_name (NID_secp192r1);
+      ctx-&gt;key = EC_KEY_new_by_curve_name (NID_X9_62_prime192v1);
       ctx-&gt;digest_length = 24; /* truncated */
       ctx-&gt;digest = hash_string (&amp;nettle_sha224, 3, "abc");
       break;
-#endif
     case 224:
       ctx-&gt;key = EC_KEY_new_by_curve_name (NID_secp224r1);
       ctx-&gt;digest_length = SHA224_DIGEST_SIZE;
       ctx-&gt;digest = hash_string (&amp;nettle_sha224, 3, "abc");
       break;
-#if 0
     case 256:
-      ctx-&gt;key = EC_KEY_new_by_curve_name (NID_secp256r1);
+      ctx-&gt;key = EC_KEY_new_by_curve_name (NID_X9_62_prime256v1);
       ctx-&gt;digest_length = SHA256_DIGEST_SIZE;
       ctx-&gt;digest = hash_string (&amp;nettle_sha256, 3, "abc");
       break;
-#endif
     case 384:
       ctx-&gt;key = EC_KEY_new_by_curve_name (NID_secp384r1);
       ctx-&gt;digest_length = SHA384_DIGEST_SIZE;
@@ -653,7 +649,9 @@ struct alg alg_list[] = {
   { "ecdsa",  384, bench_ecdsa_init, bench_ecdsa_sign, bench_ecdsa_verify, \
bench_ecdsa_clear },  { "ecdsa",  521, bench_ecdsa_init, bench_ecdsa_sign, \
bench_ecdsa_verify, bench_ecdsa_clear },  #if WITH_OPENSSL
+  { "ecdsa (openssl)",  192, bench_openssl_ecdsa_init, bench_openssl_ecdsa_sign, \
bench_openssl_ecdsa_verify, bench_openssl_ecdsa_clear },  { "ecdsa (openssl)",  224, \
bench_openssl_ecdsa_init, bench_openssl_ecdsa_sign, bench_openssl_ecdsa_verify, \
bench_openssl_ecdsa_clear }, +  { "ecdsa (openssl)",  256, bench_openssl_ecdsa_init, \
bench_openssl_ecdsa_sign, bench_openssl_ecdsa_verify, bench_openssl_ecdsa_clear },  { \
"ecdsa (openssl)",  384, bench_openssl_ecdsa_init, bench_openssl_ecdsa_sign, \
bench_openssl_ecdsa_verify, bench_openssl_ecdsa_clear },  { "ecdsa (openssl)",  521, \
bench_openssl_ecdsa_init, bench_openssl_ecdsa_sign, bench_openssl_ecdsa_verify, \
bench_openssl_ecdsa_clear },  #endif
-- 
1.9.1



</body></email><email><emailId>20140411174954</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-04-11 17:49:54-0400</timestampReceived><subject>Feature removals</subject><body>

I'm considering removing the following features:

* des-compat.h and all its functions. This provides some level of
  compatiblity with libdes (and possibly also old versions of
  openssl/ssleay). I've not heard of anyone actually using this.

* rsa-compat.h and all its functions. Compatibility with RSAREF. I've
  never heard of anyone actually using this either.

* The nettle_next_prime function. No longer used internally in Nettle's
  key generation functions, and applications should use the
  corresponding GMP function instead.

Any objections? If you know of any use of these features, please speak
up.

(In case a feature is removed and it later turns out to be a mistake,
I'm open to reintroduce features in an update, but I believe there's
little need to keep these around).

And any other cruft which should be removed while we're at it?

Regards,
/Niels



-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140422194209</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-04-22 19:42:09-0400</timestampReceived><subject>Rename, MD5_DATA_SIZE -&gt; MD5_BLOCK_SIZE, etc ?</subject><body>

In another forum, it was suggested that UMAC_DATA_SIZE be renamed to
UMAC_BLOCK_SIZE, and for consistency one could do the same with, e.g.,
MD5_DATA_SIZE. For the time being, the old names should be kept for
backwards compatibility.

Unlike block sizes for ciphers, these *_DATA_SIZE constants are rarely
needed by applications; they are in the public headers mainly because
they determine the buffer sizes in the context structs, and they are
also needed for the HMAC construction. So the naming is not totally
illogical, but I think using *_BLOCK_SIZE would be more consistent.

What do you think?

Regards,
/Niels

--
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140427203916</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-04-27 20:39:16-0400</timestampReceived><subject>Side-channel silet memcmp</subject><body>

There are lots of authentication functions which end by comparing two
digests. The recent ccm_decrypt_message is typical, ending with

  return (memcmp(tag, src + mlength, tlength) == 0);

This can leak information (via cache or timing) on the position of the
first difference, which might cause problems in some situations. Would
it be a good idea to add a side-channel silent memory comparison
function? The hardest question is, as often, how it should be named. But
it should be pretty easy to implement, I think

  int
  mem_equal (const void *ap, const void *bp, size_t n)
  {
    volatile const unsigned char *a = ap;
    volatile const unsigned char *b = bp
    volatile unsigned char d;
    size_t i;
    for (i = d = 0; i &lt; n; i++)
      d |= a[i] ^ b[i];
    return d == 0;
  }

should do (even if maybe volatile const is an unusual combination of
qualifiers). Is this a good name?

The nacl library (by djb et al) includes similar functions, see
http://nacl.cr.yp.to/verify.html.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140413044938</emailId><senderName>Owen Kirby</senderName><senderEmail>osk@exegin.com</senderEmail><timestampReceived>2014-04-13 04:49:38-0400</timestampReceived><subject>[PATCH] Some CCM mode documentation</subject><body>

Here's a first stab at assembling some documentation about CCM mode and its API. 
It's probably still in need some some good proofreading for grammar and consistency.

Some minor nits that I noticed about the API while writing it:
  - ccm_decrypt_message uses const void * for the cipher context, but all the
    other interfaces use void * for this. 
  - passing the clength rather mlength to ccm_decrypt_message could be a little
    confusing when compared to the rest of the API. In retrospect, I think Neils's
    initial suggestion on this API was probably the better way to go.

Cheers,
Owen

&gt; From 0b0651a6e754652d9ce1aa7c2f6f7cbc3fc498bc Mon Sep 17 00:00:00 2001
From: Owen Kirby &lt;osk@exegin.com&gt;
Date: Sat, 12 Apr 2014 21:31:39 -0700
Subject: [PATCH]   Added CCM mode to the documentation.

---
 nettle.texinfo |  225 +++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 224 insertions(+), 1 deletion(-)

diff --git a/nettle.texinfo b/nettle.texinfo
index 68883a5..c988eb6 100644
--- a/nettle.texinfo
+++ b/nettle.texinfo
@@ -88,6 +88,7 @@ Cipher modes
 * CBC::                         
 * CTR::                         
 * GCM::                         
+* CCM::
 
 Public-key algorithms
 
@@ -1788,6 +1789,7 @@ signature to authenticate the message.
 * CBC::                         
 * CTR::                         
 * GCM::                         
+* CCM::                         
 @end menu
 
 
@@ -1960,7 +1962,7 @@ last three arguments define the source and destination area for \
the  operation.
 @end deffn
 
-@node GCM,  , CTR, Cipher modes
+@node GCM, CCM, CTR, Cipher modes
 @comment  node-name,  next,  previous,  up
 @subsection Galois counter mode
 
@@ -2153,7 +2155,228 @@ equal to @code{GCM_BLOCK_SIZE}, but if you provide a smaller \
value,  only the first @var{length} octets of the digest are written.
 @end deftypefun
 
+@node CCM,  , GCM, Cipher modes
+@comment  node-name,  next,  previous,  up
+@subsection Counter with CBC-MAC mode
+
+@cindex Counter with CBC-MAC Mode
+@cindex CCM Mode
+
+CCM mode is the combination of counter mode with message authentication based on
+cipher block chaining. It is constructed on top of a block cipher which must
+have a block size of 128 bits. @acronym{CCM} mode is recommended by NIST in
+@uref{http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf,
 +NIST Special Publication 800-38C}. Nettle's support for CCM consists of a
+low-level general interface, a message encryption and authentication interface,
+and specific functions for CCM using AES as the underlying block cipher. These
+interfaces are defined in @file{&lt;nettle/ccm.h&gt;}
+
+The inputs to @acronym{CCM} are:
+@itemize
+@item 
+A key, which can be used for many messages.
+@item
+A parameter @var{L} which determines the size of the nonce and the maximum
+length of message data which can be processed by @acronym{CCM}.
+@item
+A tag length, which must be a multiple of 4 bytes up to a maximum of one block.
+@item 
+A nonce which @emph{must} be unique for each message.
+@item
+Optional authenticated data, which is to be included in the message
+authentication, but not encrypted.
+@item
+The plaintext. May be empty.
+@end itemize
+
+The outputs from @acronym{CCM} are:
+@itemize
+@item
+The ciphertext of the same length as the plaintext.
+@item
+An encrypted authentication tag, up to one block on length.
+@end itemize
+
+The parameter @var{L} determines the size of the counter that is used for the
+message length, such that the maximum message length in bytes is given by
+@code{maxlength = (1 &lt;&lt; L) - 1}. However increasing @var{L} also restricts the
+size of the nonce such that @code{noncelength = CCM_BLOCK_SIZE - 1 - L}, and
+throughout this interface the parameter @var{L} is provided implicitly by the 
+nonce length.
+
+@acronym{CCM} mode encryption operates as follows:
+@itemize
+@item The nonce and message length are concatenated to create
+    @code{B_0 = flags | nonce | mlength}
+@item The authenticated data and plaintext is formatted into the string
+    @code{B = L(adata) | adata | padding | plaintext | padding} with @code{padding}
+    being the shortest string of zero bytes such that the length of the string is
+    a multiple of the block size, and @code{L(adata)} is an encoding of the
+    length of @code{adata}.
+@item The string @code{B} is separated into blocks @code{B_1} ... @code{B_n}
+@item The authentication tag @code{T} is calculated as
+    @code{T=0, for i=0 to n, do T = E_k(B_i XOR T)}
+
+@item An initial counter is then initialized from the nonce to create
+    @code{IC = flags | nonce | padding}, where @code{padding} is the shortest
+    string of zero bytes such that @code{IC} is exactly one block in length.
+@item The authentication tag is encrypted using using @acronym{CTR} mode:
+    @code{MAC = E_k(IC) XOR T}
+@item The plaintext is then encrypted using @acronym{CTR} mode with an initial
+    counter of @code{IC+1}.
+@end itemize
+
+@acronym{CCM} mode decryption operates similarly, except that the ciphertext
+and @acronym{MAC} are first decrypted using CTR mode to retreive the plaintext
+and authentication tag. The authentication tag can then be recalucated from the
+authenticated data and plantext, and compared to the value in the message to
+check for authenticity.
+
+@subsubsection General @acronym{CCM} interface
+
+For all of the functions in the @acronym{CCM} interface, @var{cipher} is the
+context struct for the underlying cipher and @var{f} is the encryption function.
+The cipher's encryption key must be set before calling any of the @acronym{CCM}
+functions. The cipher's decryption function and key are never used.
+
+@deftp {Context struct} {struct ccm_ctx}
+Holds state corresponding to a particular message.
+@end deftp
+
+@defvr Constant CCM_BLOCK_SIZE
+@acronym{CCM}'s block size, 16.
+@end defvr
+
+@deftypefun void ccm_set_nonce (struct ccm_ctx *@var{ctx}, void *@var{cipher}, \
nettle_crypt_func *@var{f}, size_t @var{noncelen}, const uint8_t *@var{nonce}, size_t \
@var{authlen}, size_t @var{msglen}, size_t @var{taglen}) +Initializes @var{ctx} using \
the given nonce and the sizes of the authenticated +data, message, and @acronym{MAC} \
to be processed. +@end deftypefun
+
+@deftypefun void ccm_update (struct ccm_ctx *@var{ctx}, void *@var{cipher}, \
nettle_crypt_func *@var{f}, size_t @var{length}, const uint8_t *@var{data}) +Provides \
associated data to be authenticated. Must be called after +@code{ccm_set_nonce}, and \
before @code{ccm_encrypt}, @code{ccm_decrypt}, or +@code{ccm_digest}.
+@end deftypefun
+
+@deftypefun void ccm_encrypt (struct ccm_ctx *@var{ctx}, void *@var{cipher}, \
nettle_crypt_func *@var{f}, size_t @var{length}, uint8_t *@var{dst}, const uint8_t \
*@var{src}) +@deftypefunx void ccm_decrypt (struct ccm_ctx *@var{ctx}, void \
*@var{cipher}, nettle_crypt_func *@var{f}, size_t @var{length}, uint8_t *@var{dst}, \
const uint8_t *@var{src}) +Encrypts or decrypts the message data. Must be called \
after @code{ccm_set_nonce} +and before @code{ccm_digest}. All but the last call for \
each message @emph{must} +use a length that is a multiple of the block size.
+@end deftypefun
+
+@deftypefun void ccm_digest (struct ccm_ctx *@var{ctx}, void *@var{cipher}, \
nettle_crypt_func *@var{f}, size_t @var{length}, uint8_t *@var{digest}) +Extracts the \
message digest (also known ``authentication tag''). This is +the final operation when \
processing a message. @var{length} is usually +equal to the @var{taglen} parameter \
supplied to @code{ccm_set_nonce}, but if you +provide a smaller value, only the first \
@var{length} octets of the digest are +written.
+@end deftypefun
+
+To encrypt a message using the general @acronym{CCM} interface, set the message
+nonce and length using @code{ccm_set_nonce} and then call @code{ccm_update} to
+generate the digest of any authenticated data. After all of the authenticated
+data has been digested use @code{ccm_encrypt} to encrypt the plaintext. Finally,
+use @code{ccm_digest} to return the encrypted @acronym{MAC}.
+
+To decrypt a message, use @code{ccm_set_nonce} and @code{ccm_update} the same as
+you would for encryption, and then call @code{ccm_decrypt} to decrypt the
+ciphertext. After decrypting the ciphertext @code{ccm_digest} will return the
+encrypted @acronym{MAC} which should be identical to the @acronym{MAC} in the
+received message.
+
+@subsubsection @acronym{CCM} message interface
+
+The @acronym{CCM} message fuctions provides a simple interface that will
+perform authentication and message encryption in a single function call. The
+length of the ciphertext is given by @var{clength}, and it is always exactly
+@var{tlength} bytes longer than the corresponding plaintext. The length of the
+plaintext is not provided explicitly in this interface, as it would always have
+a value of @var{mlength} = @var{clength} - @var{tlength}.
+
+@deftypefun void ccm_encrypt_message (void *@var{cipher}, nettle_crypt_func \
*@var{f}, size_t @var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, \
const uint8_t *@var{adata}, size_t @var{tlength}, size_t @var{clength}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +Computes the message digest from the \
@var{adata} and @var{src} parameters, +encrypts the plaintext from @var{src}, appends \
the encrypted @acronym{MAC} to +ciphertext and outputs it to @var{dst}.
+@end deftypefun
+
+@deftypefun int ccm_decrypt_message (void *@var{cipher}, nettle_crypt_func *@var{f}, \
size_t @var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, const uint8_t \
*@var{adata}, size_t @var{tlength}, size_t @var{clength}, uint8_t *@var{dst}, const \
uint8_t *@var{src}) +Decrypts the ciphertext from @var{src}, outputs the plaintext to \
@var{dst}, +recalculates the @acronym{MAC} from @var{adata} and the plaintext, and \
compares +it to the final @var{tlength} bytes of @var{src}. If the values of the \
received +and calculated @acronym{MAC}s are equal, this will return 1 indicating a \
valid +and authenticated message. Otherwise, this function will return zero.
+@end deftypefun
+
+@subsubsection @acronym{CCM}-@acronym{AES} interface
+
+The @acronym{AES} @acronym{CCM} functions provide an API for using @acronym{CCM}
+mode with the @acronym{AES} block ciphers. The parameters all have the same
+meaning as the general and message interfaces, except that the @var{cipher},
+@var{f}, and @var{ctx} parameters are replaced with an @acronym{AES} context
+structure, and a set-key function must be called before using any of the other
+functions in this interface.
 
+@deftp {Context struct} {struct ccm_aes128_ctx}
+Holds state corresponding to a particular message encrypted using the AES-128 block \
cipher. +@end deftp
+
+@deftp {Context struct} {struct ccm_aes192_ctx}
+Holds state corresponding to a particular message encrypted using the AES-192 block \
cipher. +@end deftp
+
+@deftp {Context struct} {struct ccm_aes256_ctx}
+Holds state corresponding to a particular message encrypted using the AES-256 block \
cipher. +@end deftp
+
+@deftypefun void ccm_aes128_set_key (struct ccm_aes128_ctx *@var{ctx}, const void \
*@var{key}) +@deftypefunx void ccm_aes192_set_key (struct ccm_aes192_ctx *@var{ctx}, \
const void *@var{key}) +@deftypefunx void ccm_aes256_set_key (struct ccm_aes256_ctx \
*@var{ctx}, const void *@var{key}) +Initializes the encryption key for the AES block \
cipher. One of these functions +must be called before any of the other functions in \
the @acronym{AES} +@acronym{CCM} interface.
+@end deftypefun
+
+@deftypefun void ccm_aes128_set_nonce (struct ccm_aes128_ctx *@var{ctx}, size_t \
@var{noncelen}, const uint8_t *@var{nonce}, size_t @var{authlen}, size_t \
@var{msglen}, size_t @var{taglen}) +@deftypefunx void ccm_aes192_set_nonce (struct \
ccm_aes192_ctx *@var{ctx}, size_t @var{noncelen}, const uint8_t *@var{nonce}, size_t \
@var{authlen}, size_t @var{msglen}, size_t @var{taglen}) +@deftypefunx void \
ccm_aes256_set_nonce (struct ccm_aes256_ctx *@var{ctx}, size_t @var{noncelen}, const \
uint8_t *@var{nonce}, size_t @var{authlen}, size_t @var{msglen}, size_t @var{taglen}) \
+These are identical to @code{ccm_set_nonce}, except that @var{cipher}, +@var{f}, and \
@var{ctx} are replaced with a context structure. +@end deftypefun
+
+@deftypefun void ccm_aes128_update (struct ccm_aes128_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +@deftypefunx void ccm_aes192_update (struct \
ccm_aes192_ctx *@var{ctx}, size_t @var{length}, const uint8_t *@var{data}) \
+@deftypefunx void ccm_aes256_update (struct ccm_aes256_ctx *@var{ctx}, size_t \
@var{length}, const uint8_t *@var{data}) +These are identical to \
@code{ccm_set_update}, except that @var{cipher}, +@var{f}, and @var{ctx} are replaced \
with a context structure. +@end deftypefun
+
+@deftypefun void ccm_aes128_encrypt (struct ccm_aes128_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +@deftypefunx void \
ccm_aes192_encrypt (struct ccm_aes192_ctx *@var{ctx}, size_t @var{length}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +@deftypefunx void ccm_aes256_encrypt (struct \
ccm_aes256_ctx *@var{ctx}, size_t @var{length}, uint8_t *@var{dst}, const uint8_t \
*@var{src}) +@deftypefunx void ccm_aes128_decrypt (struct ccm_aes128_ctx *@var{ctx}, \
size_t @var{length}, uint8_t *@var{dst}, const uint8_t *@var{src}) +@deftypefunx void \
ccm_aes192_decrypt (struct ccm_aes192_ctx *@var{ctx}, size_t @var{length}, uint8_t \
*@var{dst}, const uint8_t *@var{src}) +@deftypefunx void ccm_aes256_decrypt (struct \
ccm_aes256_ctx *@var{ctx}, size_t @var{length}, uint8_t *@var{dst}, const uint8_t \
*@var{src}) +These are identical to @code{ccm_set_encrypt} and \
@code{ccm_set_decrypt}, except +that @var{cipher}, @var{f}, and @var{ctx} are \
replaced with a context structure. +@end deftypefun
+
+@deftypefun void ccm_aes128_digest (struct ccm_aes128_ctx *@var{ctx}, size_t \
@var{length}, uint8_t *@var{digest}) +@deftypefunx void ccm_aes192_digest (struct \
ccm_aes192_ctx *@var{ctx}, size_t @var{length}, uint8_t *@var{digest}) +@deftypefunx \
void ccm_aes256_digest (struct ccm_aes256_ctx *@var{ctx}, size_t @var{length}, \
uint8_t *@var{digest}) +These are identical to @code{ccm_set_digest}, except that \
@var{cipher}, +@var{f}, and @var{ctx} are replaced with a context structure.
+@end deftypefun
+
+@deftypefun void ccm_aes128_encrypt_message (struct ccm_aes128_ctx *@var{ctx}, \
size_t @var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, const uint8_t \
*@var{adata}, size_t @var{tlength}, size_t @var{clength}, uint8_t *@var{dst}, const \
uint8_t *@var{src}) +@deftypefunx void ccm_aes192_encrypt_message (struct \
ccm_aes192_ctx *@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, size_t \
@var{alength}, const uint8_t *@var{adata}, size_t @var{tlength}, size_t \
@var{clength}, uint8_t *@var{dst}, const uint8_t *@var{src}) +@deftypefunx void \
ccm_aes256_encrypt_message (struct ccm_aes256_ctx *@var{ctx}, size_t @var{nlength}, \
const uint8_t *@var{nonce}, size_t @var{alength}, const uint8_t *@var{adata}, size_t \
@var{tlength}, size_t @var{clength}, uint8_t *@var{dst}, const uint8_t *@var{src}) \
+@deftypefunx int ccm_aes128_decrypt_message (struct ccm_aes128_ctx *@var{ctx}, \
size_t @var{nlength}, const uint8_t *@var{nonce}, size_t @var{alength}, const uint8_t \
*@var{adata}, size_t @var{tlength}, size_t @var{clength}, uint8_t *@var{dst}, const \
uint8_t *@var{src}) +@deftypefunx int ccm_aes192_decrypt_message (struct \
ccm_aes192_ctx *@var{ctx}, size_t @var{nlength}, const uint8_t *@var{nonce}, size_t \
@var{alength}, const uint8_t *@var{adata}, size_t @var{tlength}, size_t \
@var{clength}, uint8_t *@var{dst}, const uint8_t *@var{src}) +@deftypefunx int \
ccm_aes192_decrypt_message (struct ccm_aes256_ctx *@var{ctx}, size_t @var{nlength}, \
const uint8_t *@var{nonce}, size_t @var{alength}, const uint8_t *@var{adata}, size_t \
@var{tlength}, size_t @var{clength}, uint8_t *@var{dst}, const uint8_t *@var{src}) \
+These are identical to @code{ccm_encrypt_message} and @code{ccm_decrypt_message} \
+except that @var{cipher} and @var{f} are replaced with a context structure. +@end \
deftypefun  
 @node Keyed hash functions, Key derivation functions, Cipher modes, Reference
 @comment  node-name,  next,  previous,  up
-- 
1.7.9.5


</body></email><email><emailId>20140413075150</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-04-13 07:51:50-0400</timestampReceived><subject>Re: [PATCH] Some CCM mode documentation</subject><body>

Owen Kirby &lt;osk@exegin.com&gt; writes:

&gt; Here's a first stab at assembling some documentation about CCM mode and its API. 

Thanks! You are aware that the manual is licensed as public domain, is
that ok with you?

&gt; Some minor nits that I noticed about the API while writing it:
&gt;   - ccm_decrypt_message uses const void * for the cipher context, but all the
&gt;     other interfaces use void * for this. 

Can you be more specific? I think it should be const void * everywhere,
and I see no void * in the version of ccm.h which is in the repo. That's
one of the things I changed when integrating it.

&gt;   - passing the clength rather mlength to ccm_decrypt_message could be a little
&gt;     confusing when compared to the rest of the API. In retrospect, I think Neils's
&gt;     initial suggestion on this API was probably the better way to go.

If I remember correctly, we agreed that when we pass the triple (length,
dst, src), and the src and destination areas are of diferent sizes, then
it's best to adopt the convention that length always is the size of the
destination area?

Which then means that ccm_encrypt_message should take clength (length of
ciphertext) and ccm_decrypt_message should be changed to take mlength
(length of cleartext).

&gt; +The inputs to @acronym{CCM} are:
&gt; +@itemize
&gt; +@item 
&gt; +A key, which can be used for many messages.
&gt; +@item
&gt; +A parameter @var{L} which determines the size of the nonce and the maximum
&gt; +length of message data which can be processed by @acronym{CCM}.
&gt; +@item
&gt; +A tag length, which must be a multiple of 4 bytes up to a maximum of one block.
&gt; +@item 
&gt; +A nonce which @emph{must} be unique for each message.
&gt; +@item
&gt; +Optional authenticated data, which is to be included in the message
&gt; +authentication, but not encrypted.
&gt; +@item
&gt; +The plaintext. May be empty.
&gt; +@end itemize
&gt; +
&gt; +The outputs from @acronym{CCM} are:
&gt; +@itemize
&gt; +@item
&gt; +The ciphertext of the same length as the plaintext.
&gt; +@item
&gt; +An encrypted authentication tag, up to one block on length.
&gt; +@end itemize
&gt; +
&gt; +The parameter @var{L} determines the size of the counter that is used for the
&gt; +message length, such that the maximum message length in bytes is given by
&gt; +@code{maxlength = (1 &lt;&lt; L) - 1}. However increasing @var{L} also restricts the
&gt; +size of the nonce such that @code{noncelength = CCM_BLOCK_SIZE - 1 - L}, and
&gt; +throughout this interface the parameter @var{L} is provided implicitly by the 
&gt; +nonce length.

I think it would be good with a bit more focus on how the caller should
select the nonce size. I'd expect that 12 bytes nonce (and the corresponding limit on
message size) is the most widely used, following RFC 5116.

What happens if the caller specifies an invalid combination of nonce
size and message size? Will it trigger some assert, or will the counter
wrap around silently?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140413082555</emailId><senderName>Owen Kirby</senderName><senderEmail>osk@exegin.com</senderEmail><timestampReceived>2014-04-13 08:25:55-0400</timestampReceived><subject>Re: [PATCH] Some CCM mode documentation</subject><body>

On 14-04-13 12:51 AM, Niels Möller wrote:
&gt; Owen Kirby &lt;osk@exegin.com&gt; writes:
&gt;
&gt;&gt; Here's a first stab at assembling some documentation about CCM mode and its API. 
&gt; Thanks! You are aware that the manual is licensed as public domain, is
&gt; that ok with you?
That is ok with me.
&gt;
&gt;&gt; Some minor nits that I noticed about the API while writing it:
&gt;&gt;   - ccm_decrypt_message uses const void * for the cipher context, but all the
&gt;&gt;     other interfaces use void * for this. 
&gt; Can you be more specific? I think it should be const void * everywhere,
&gt; and I see no void * in the version of ccm.h which is in the repo. That's
&gt; one of the things I changed when integrating it.
Ah, you are right. The I must have copy-pasted the non-const versions
from the GCM section of the docs, which hasn't been updated yet to agree
with the const void* used in the source. I'll make sure to change them
back to const void*
&gt;&gt;   - passing the clength rather mlength to ccm_decrypt_message could be a little
&gt;&gt;     confusing when compared to the rest of the API. In retrospect, I think Neils's
&gt;&gt;     initial suggestion on this API was probably the better way to go.
&gt; If I remember correctly, we agreed that when we pass the triple (length,
&gt; dst, src), and the src and destination areas are of diferent sizes, then
&gt; it's best to adopt the convention that length always is the size of the
&gt; destination area?
&gt;
&gt; Which then means that ccm_encrypt_message should take clength (length of
&gt; ciphertext) and ccm_decrypt_message should be changed to take mlength
&gt; (length of cleartext).
Noted, I'll make an update accordingly.
&gt;
&gt;&gt; +The inputs to @acronym{CCM} are:
&gt;&gt; +@itemize
&gt;&gt; +@item 
&gt;&gt; +A key, which can be used for many messages.
&gt;&gt; +@item
&gt;&gt; +A parameter @var{L} which determines the size of the nonce and the maximum
&gt;&gt; +length of message data which can be processed by @acronym{CCM}.
&gt;&gt; +@item
&gt;&gt; +A tag length, which must be a multiple of 4 bytes up to a maximum of one block.
&gt;&gt; +@item 
&gt;&gt; +A nonce which @emph{must} be unique for each message.
&gt;&gt; +@item
&gt;&gt; +Optional authenticated data, which is to be included in the message
&gt;&gt; +authentication, but not encrypted.
&gt;&gt; +@item
&gt;&gt; +The plaintext. May be empty.
&gt;&gt; +@end itemize
&gt;&gt; +
&gt;&gt; +The outputs from @acronym{CCM} are:
&gt;&gt; +@itemize
&gt;&gt; +@item
&gt;&gt; +The ciphertext of the same length as the plaintext.
&gt;&gt; +@item
&gt;&gt; +An encrypted authentication tag, up to one block on length.
&gt;&gt; +@end itemize
&gt;&gt; +
&gt;&gt; +The parameter @var{L} determines the size of the counter that is used for the
&gt;&gt; +message length, such that the maximum message length in bytes is given by
&gt;&gt; +@code{maxlength = (1 &lt;&lt; L) - 1}. However increasing @var{L} also restricts the
&gt;&gt; +size of the nonce such that @code{noncelength = CCM_BLOCK_SIZE - 1 - L}, and
&gt;&gt; +throughout this interface the parameter @var{L} is provided implicitly by the 
&gt;&gt; +nonce length.
&gt; I think it would be good with a bit more focus on how the caller should
&gt; select the nonce size. I'd expect that 12 bytes nonce (and the corresponding limit on
&gt; message size) is the most widely used, following RFC 5116.
&gt;
&gt; What happens if the caller specifies an invalid combination of nonce
&gt; size and message size? Will it trigger some assert, or will the counter
&gt; wrap around silently?
The last line in ccm_build_iv will assert if the counter rolls over when
forming the IV. There are no checks for rollovers when incrementing the
CTR, but to do that one would have to encrypt more than (1 &lt;&lt; (L*8))
blocks of data, and at least 16 times the amount of data that was
specified in the callto ccm_set_nonce

It also occurs to me that the my formula for calculating the maximum
message size from L is completely wrong. L basically specifies the size
of the counter field (in bytes), so it should really be maxlength = (1
&lt;&lt; (L*8)) - 1.

Most protocols focus on maximizing the length of the nonce, since
messages seldomly exceed a few kilobytes and you want to get as much
entropy into the IV as possible. Off the top of my head, I think most
IETF protocols use a nonce of 12 bytes while the IEEE 802.15.4 and
ZigBee use a nonce of 13 bytes. I'll try to put together a few
official-sounding words on the topic.

Cheers,
Owen

</body></email><email><emailId>20140413173813</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-04-13 17:38:13-0400</timestampReceived><subject>Re: [PATCH] Some CCM mode documentation</subject><body>

Owen Kirby &lt;osk@exegin.com&gt; writes:

&gt; It also occurs to me that the my formula for calculating the maximum
&gt; message size from L is completely wrong. L basically specifies the size
&gt; of the counter field (in bytes), so it should really be maxlength = (1
&gt; &lt;&lt; (L*8)) - 1.

I think it would be nice with some public macro in ccm.h which gives the
maximum message size for a given nonce size, together with constants
CCM_MIN_NONCE_SIZE and CCM_MAX_NONCE_SIZE. There should be some
reasonably easy way for an application to check if potential ccm
parameters are valid.

If I read ccm.c correctly, nonce size is in the range 7...14 bytes,
inclusive.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140425193837</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-04-25 19:38:37-0400</timestampReceived><subject>Re: [PATCH] Some CCM mode documentation</subject><body>

Owen Kirby &lt;osk@exegin.com&gt; writes:

&gt; Here's a first stab at assembling some documentation about CCM mode and its API. 
&gt; It's probably still in need some some good proofreading for grammar and consistency.

I've checked in these docs now, with fixes as below. Thanks!

&gt; Some minor nits that I noticed about the API while writing it:
&gt;   - ccm_decrypt_message uses const void * for the cipher context, but all the
&gt;     other interfaces use void * for this.

Fixed to document const void *.

&gt;   - passing the clength rather mlength to ccm_decrypt_message could be a little
&gt;     confusing when compared to the rest of the API. In retrospect, I think Neils's
&gt;     initial suggestion on this API was probably the better way to go.

Fixed, both in the docs and the code.

Not yet done: Fixing the logic for deriving the maxumum mesage size from
the nocne size. Public macros for computing maximum message size for a
given nonce, and documentation of these and general nonce size issues.

Do you think you can have a look at that soon?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140429171615</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-04-29 17:16:15-0400</timestampReceived><subject>Re: [PATCH] Some CCM mode documentation</subject><body>

Owen Kirby &lt;osk@exegin.com&gt; writes:

&gt; It also occurs to me that the my formula for calculating the maximum
&gt; message size from L is completely wrong. L basically specifies the size
&gt; of the counter field (in bytes), so it should really be maxlength = (1
&gt; &lt;&lt; (L*8)) - 1.

Is the following correct? Intended for ccm.h:

/* Maximum cleartext message size, as a function of the nonce size N.
   The length field is L octets, with L = 15 - N, and then the maximum
   size M = 2^{8L} - 1. */
#define CCM_MAX_MSG_SIZE(N)			\
  ((sizeof(size_t) + (N) &lt;= 15)			\
   ? ~(size_t) 0				\
   : ((size_t) 1 &lt;&lt; (8*(15 - N))) - 1)


Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140428064722</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-04-28 06:47:22-0400</timestampReceived><subject>Re: Side-channel silet memcmp</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

Niels Möller wrote:
&gt; int mem_equal (const void *ap, const void *bp, size_t n) { volatile
&gt; const unsigned char *a = ap; volatile const unsigned char *b = bp 
&gt; volatile unsigned char d; size_t i; for (i = d = 0; i &lt; n; i++) d |=
&gt; a[i] ^ b[i]; return d == 0; }
&gt; 
&gt; should do (even if maybe volatile const is an unusual combination of 
&gt; qualifiers). Is this a good name?

Yes, and a good function to add. One could think/hope that the OS
provided side channel silent memory functions. But since that is not
always (rarely) the case, providing one in nettle is a good thing.

AFAIK (browsing the docs) there aren't any specific functions for
comparing digests. Instead the user has to implement thing themselves.
Would it be an advantage to have mappings to either create a generic
digest compare or specific for the different digests and MACs?

uint8_t compare_digests(uint8_t *digest0, uint8_t *digest1, uint8_t
*DIGEST_SIZE);

or

uint8_t compare_md5_digests(uint8_t *digest0, uint8_t *digest1);

Or something like that. for MD5, SHA-digests, UMAC etc.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIcBAEBCAAGBQJTXfl6AAoJEF3cfFQkIuyNoTkP/0giwtCGAKprnqHeRpxDR3ey
dvaoMhA87SFUyeoSrIASmBWxNVmvf025EoJ/t330ZUA4MWeT6Uv+C6s4BGSM/cV1
EXdnYfizFcOSLMs4u/nhLIFiR3nLatmawuaYtrPOZCChWOzNMjWOIUkK8AtWENoX
ygGo0iJKrBSGHnO5AHFRWwPv6QmrMPj8B1wQ4UoZ3lXoJFga99yk/jrhv+hmT1/9
yq959TCWrKfS5ly1QCyIpFFMgHr1ybX1YhiKe7BKkwp+NW8MSi0SoGNO1z/Aovgr
Nr5YMzybzo2AjpOtSLBsXeWjDnddV+BO3U9fRYkAsd5uqqKSaKQOrKIy1GARe6tC
wR9aYmJlHJkfF/TK1/M7xGeeJX/0QN9lm9Tc0t/qH4uHmo/bPA/0klGw7JAvdtwx
8PTUGuqMDc2Ts9/IOJLk0jlx22d50/Czibm07MbDyxFwLtwes8eeBn7jyEscmJwN
3Nlu7Wcpyu9w/zyQN0Tr4XYr1A+R1ocyxGDvUwwpR7W4hKKTA6KG45z2pz3tOkIj
570PIs5DaUeHMdmNFKaoTLHGJfaZ7UrfFXUy+rmlXgIB2HbJt8nEp5xFgwzeeHO/
J0IVOydNWB6q5mBh24JOKQDJE7wgDQq5aepvk1zNZl05KWn/uqwJJMSmZdD2B0qX
1W23wLJL4iRi3Ff/f1Sj
=yVqu
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140428070233</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-04-28 07:02:33-0400</timestampReceived><subject>Re: Side-channel silet memcmp</subject><body>

On Sun, Apr 27, 2014 at 10:39 PM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wro=
te:

&gt; should do (even if maybe volatile const is an unusual combination of
&gt; qualifiers). Is this a good name?

Why not nettle memcmp? It would be good to export those functions as
there are not typically available and each program re-invents them and
it is not always easy to avoid compiler optimizations.

regards,
Nikos

</body></email><email><emailId>20140308155401</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-08 15:54:01-0400</timestampReceived><subject>Re: [PATCH] CCM Cipher Modes</subject><body>

Owen Kirby is working on an implementation of the CCM mode. I'm
forwarding my comments here (with permission).

Regards,
/Niels



-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.



</body></email><email><emailId>20140315000632</emailId><senderName>Owen Kirby</senderName><senderEmail>osk@exegin.com</senderEmail><timestampReceived>2014-03-15 00:06:32-0400</timestampReceived><subject>[PATCH v2] CCM Cipher Modes</subject><body>

I've incorporated a few of your suggestions and updated my patch for the CCM cipher
modes. This improves the API coverage in the CCM test suite, adds the all-at-once
API for message processing, and fixes the copyright of the CCM mode source code.

Thanks,
Owen

ChangeLog from V1 of the patch:

2014-03-14	Owen Kirby	&lt;osk@exegin.com&gt;
* ccm-aes.c: Removed legacy AES API.
* ccm.c (ccm_encrypt_message): Added all-at-once API for CCM mode ciphers.
* ccm.c (ccm_digest): Added assert to ensure CCM digest length &lt;= block size.
* ccm.h: Updated copyright for CCM modes to Owen Kirby and Exegin Technologies.
* ccm.c: Minor changes to CCM IV and nonce building functions.
* ccm-aesXXX.c: Added all-at-once API, and removed the CCM helper macros.
* testsuite/ccm-test.c: Added tests for the cipher-specific CCM functions.
* testsuite/.test-rules.make: Fixed the building of the CCM self-test.

&gt; From 0e40ade7f0f3e41783973e53c50b10ba497e52e7 Mon Sep 17 00:00:00 2001
From: Owen Kirby &lt;osk@exegin.com&gt;
Date: Wed, 5 Mar 2014 19:40:56 -0800
Subject: [PATCH]   Support for CCM mode ciphers.

---
 Makefile.in                |    1 +
 ccm-aes128.c               |  101 +++++++
 ccm-aes192.c               |  102 +++++++
 ccm-aes256.c               |  103 +++++++
 ccm.c                      |  253 ++++++++++++++++
 ccm.h                      |  267 +++++++++++++++++
 testsuite/.gitignore       |    1 +
 testsuite/.test-rules.make |    3 +
 testsuite/Makefile.in      |    2 +-
 testsuite/ccm-test.c       |  709 ++++++++++++++++++++++++++++++++++++++++++++
 10 files changed, 1541 insertions(+), 1 deletion(-)
 create mode 100644 ccm-aes128.c
 create mode 100644 ccm-aes192.c
 create mode 100644 ccm-aes256.c
 create mode 100644 ccm.c
 create mode 100644 ccm.h
 create mode 100644 testsuite/ccm-test.c

diff --git a/Makefile.in b/Makefile.in
index 24349c3..c05d891 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -87,6 +87,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 camellia256-set-decrypt-key.c \
 		 camellia256-meta.c \
 		 cast128.c cast128-meta.c cbc.c \
+		 ccm.c ccm-aes.c ccm-aes128.c ccm-aes192.c ccm-aes256.c \
 		 chacha-crypt.c chacha-core-internal.c \
 		 chacha-poly1305.c chacha-poly1305-meta.c \
 		 chacha-set-key.c chacha-set-nonce.c \
diff --git a/ccm-aes128.c b/ccm-aes128.c
new file mode 100644
index 0000000..cb87897
--- /dev/null
+++ b/ccm-aes128.c
@@ -0,0 +1,101 @@
+/* ccm-aes128.c
+ *
+ * Counter with CBC-MAC mode using AES128 as the underlying cipher.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2014 Exegin Technologies Limited
+ * Copyright (C) 2014 Owen Kirby
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "aes.h"
+#include "ccm.h"
+
+void
+ccm_aes128_set_key(struct ccm_aes128_ctx *ctx, const uint8_t *key)
+{
+  aes128_set_encrypt_key(&amp;ctx-&gt;cipher, key);
+}
+
+void
+ccm_aes128_set_nonce(struct ccm_aes128_ctx *ctx, size_t length, const uint8_t \
*nonce, +        size_t authlen, size_t msglen, size_t taglen)
+{
+  ccm_set_nonce(&amp;ctx-&gt;ccm, length, nonce, authlen, msglen, taglen);
+}
+
+void
+ccm_aes128_update(struct ccm_aes128_ctx *ctx,
+        size_t length, const uint8_t *data)
+{
+  ccm_update(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes128_encrypt, length, data);
+}
+
+void
+ccm_aes128_encrypt(struct ccm_aes128_ctx *ctx,
+		size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ccm_encrypt(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes128_encrypt, length, dst, src);
+}
+
+void
+ccm_aes128_decrypt(struct ccm_aes128_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ccm_decrypt(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes128_encrypt, length, dst, src);
+}
+
+void
+ccm_aes128_digest(struct ccm_aes128_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  ccm_digest(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes128_encrypt, length, digest);
+}
+
+void
+ccm_aes128_encrypt_message(struct ccm_aes128_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  ccm_encrypt_message(&amp;ctx-&gt;cipher, (nettle_crypt_func *)aes128_encrypt,
+            nlength, nonce, alength, adata, tlength, tag, mlength, dst, src);
+}
+
+void
+ccm_aes128_decrypt_message(struct ccm_aes128_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  ccm_decrypt_message(&amp;ctx-&gt;cipher, (nettle_crypt_func *)aes128_encrypt,
+            nlength, nonce, alength, adata, tlength, tag, mlength, dst, src);
+}
\ No newline at end of file
diff --git a/ccm-aes192.c b/ccm-aes192.c
new file mode 100644
index 0000000..6073f4a
--- /dev/null
+++ b/ccm-aes192.c
@@ -0,0 +1,102 @@
+/* ccm-aes192.c
+ *
+ * Counter with CBC-MAC mode using AES192 as the underlying cipher.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2014 Exegin Technologies Limited
+ * Copyright (C) 2014 Owen Kirby
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "aes.h"
+#include "ccm.h"
+
+
+void
+ccm_aes192_set_key(struct ccm_aes192_ctx *ctx, const uint8_t *key)
+{
+  aes192_set_encrypt_key(&amp;ctx-&gt;cipher, key);
+}
+
+void
+ccm_aes192_set_nonce(struct ccm_aes192_ctx *ctx, size_t length, const uint8_t \
*nonce, +        size_t authlen, size_t msglen, size_t taglen)
+{
+  ccm_set_nonce(&amp;ctx-&gt;ccm, length, nonce, authlen, msglen, taglen);
+}
+
+void
+ccm_aes192_update(struct ccm_aes192_ctx *ctx,
+        size_t length, const uint8_t *data)
+{
+  ccm_update(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes192_encrypt, length, data);
+}
+
+void
+ccm_aes192_encrypt(struct ccm_aes192_ctx *ctx,
+		size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ccm_encrypt(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes192_encrypt, length, dst, src);
+}
+
+void
+ccm_aes192_decrypt(struct ccm_aes192_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ccm_decrypt(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes192_encrypt, length, dst, src);
+}
+
+void
+ccm_aes192_digest(struct ccm_aes192_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  ccm_digest(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes192_encrypt, length, digest);
+}
+
+void
+ccm_aes192_encrypt_message(struct ccm_aes192_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  ccm_encrypt_message(&amp;ctx-&gt;cipher, (nettle_crypt_func *)aes192_encrypt,
+            nlength, nonce, alength, adata, tlength, tag, mlength, dst, src);
+}
+
+void
+ccm_aes192_decrypt_message(struct ccm_aes192_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  ccm_decrypt_message(&amp;ctx-&gt;cipher, (nettle_crypt_func *)aes192_encrypt,
+            nlength, nonce, alength, adata, tlength, tag, mlength, dst, src);
+}
diff --git a/ccm-aes256.c b/ccm-aes256.c
new file mode 100644
index 0000000..78906f4
--- /dev/null
+++ b/ccm-aes256.c
@@ -0,0 +1,103 @@
+/* ccm-aes256.c
+ *
+ * Counter with CBC-MAC mode using AES256 as the underlying cipher.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2014 Exegin Technologies Limited
+ * Copyright (C) 2014 Owen Kirby
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "aes.h"
+#include "ccm.h"
+
+
+void
+ccm_aes256_set_key(struct ccm_aes256_ctx *ctx, const uint8_t *key)
+{
+  aes256_set_encrypt_key(&amp;ctx-&gt;cipher, key);
+}
+
+void
+ccm_aes256_set_nonce(struct ccm_aes256_ctx *ctx, size_t length, const uint8_t \
*nonce, +        size_t authlen, size_t msglen, size_t taglen)
+{
+  ccm_set_nonce(&amp;ctx-&gt;ccm, length, nonce, authlen, msglen, taglen);
+}
+
+void
+ccm_aes256_update(struct ccm_aes256_ctx *ctx,
+        size_t length, const uint8_t *data)
+{
+  ccm_update(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes256_encrypt, length, data);
+}
+
+void
+ccm_aes256_encrypt(struct ccm_aes256_ctx *ctx,
+		size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ccm_encrypt(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes256_encrypt, length, dst, src);
+}
+
+void
+ccm_aes256_decrypt(struct ccm_aes256_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ccm_decrypt(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes256_encrypt, length, dst, src);
+}
+
+void
+ccm_aes256_digest(struct ccm_aes256_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  ccm_digest(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes256_encrypt, length, digest);
+}
+
+void
+ccm_aes256_encrypt_message(struct ccm_aes256_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  ccm_encrypt_message(&amp;ctx-&gt;cipher, (nettle_crypt_func *)aes256_encrypt,
+            nlength, nonce, alength, adata, tlength, tag, mlength, dst, src);
+}
+
+void
+ccm_aes256_decrypt_message(struct ccm_aes256_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  ccm_decrypt_message(&amp;ctx-&gt;cipher, (nettle_crypt_func *)aes256_encrypt,
+            nlength, nonce, alength, adata, tlength, tag, mlength, dst, src);
+}
+
diff --git a/ccm.c b/ccm.c
new file mode 100644
index 0000000..44771f0
--- /dev/null
+++ b/ccm.c
@@ -0,0 +1,253 @@
+/* ccm.c
+ *
+ * Counter with CBC-MAC mode, specified by NIST,
+ * http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf
 + *
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2014 Exegin Technologies Limited
+ * Copyright (C) 2014 Owen Kirby
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "ccm.h"
+#include "ctr.h"
+
+#include "memxor.h"
+#include "nettle-internal.h"
+#include "macros.h"
+
+/*
+ * The format of the CCM IV (for both CTR and CBC-MAC) is: flags | nonce | count
+ *  flags = 1 octet
+ *  nonce = N octets
+ *  count &gt;= 1 octet
+ *
+ * such that:
+ *  sizeof(flags) + sizeof(nonce) + sizeof(count) == 1 block
+ */
+#define CCM_FLAG_L          0x07
+#define CCM_FLAG_M          0x38
+#define CCM_FLAG_ADATA      0x40
+#define CCM_FLAG_RESERVED   0x80
+#define CCM_FLAG_GET_L(_x_) (((_x_) &amp; CCM_FLAG_L) + 1)
+#define CCM_FLAG_SET_L(_x_) (((_x_) - 1) &amp; CCM_FLAG_L)
+#define CCM_FLAG_SET_M(_x_) ((((_x_) - 2) &lt;&lt; 2) &amp; CCM_FLAG_M)
+
+#define CCM_OFFSET_FLAGS    0
+#define CCM_OFFSET_NONCE    1
+#define CCM_L_SIZE(_nlen_)  (CCM_BLOCK_SIZE - CCM_OFFSET_NONCE - (_nlen_))
+#define CCM_L_MAX_SIZE      (CCM_FLAG_L+1)
+#define CCM_IV_MAX_SIZE     (CCM_BLOCK_SIZE - CCM_OFFSET_NONCE - 1)
+#define CCM_IV_MIN_SIZE     (CCM_BLOCK_SIZE - CCM_OFFSET_NONCE - CCM_L_MAX_SIZE)
+
+/* Pad an unaligned CBC-MAC digest with zero, or initialize B0 if no adata. */
+static void
+ccm_pad(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f)
+{
+    if (ctx-&gt;blen) f(cipher, CCM_BLOCK_SIZE, ctx-&gt;tag.b, ctx-&gt;tag.b);
+    ctx-&gt;blen = 0;
+}
+
+/*
+ * Future work: We might be able to support the nettle_aead API by making the
+ * caller generate the entire IV rather than providing only the nonce. For now,
+ * this function is only used internally by the CCM mode.
+ */
+static void
+ccm_build_iv(size_t noncelen, const uint8_t *nonce, size_t msglen,
+        size_t taglen, uint8_t *iv)
+{
+  unsigned int i;
+
+  /* Sanity check the nonce length. */
+  assert(noncelen &gt;= CCM_IV_MIN_SIZE);
+  assert(noncelen &lt;= CCM_IV_MAX_SIZE);
+  
+  /* Generate the IV */
+  iv[CCM_OFFSET_FLAGS] = CCM_FLAG_SET_M(taglen) | \
CCM_FLAG_SET_L(CCM_L_SIZE(noncelen)); +  memcpy(&amp;iv[CCM_OFFSET_NONCE], nonce, \
noncelen); +  for (i=(CCM_BLOCK_SIZE - 1); i &gt;= (CCM_OFFSET_NONCE + noncelen); i--) {
+    iv[i] = msglen &amp; 0xff;
+    msglen &gt;&gt;= 8;
+  }
+  
+  /* Ensure the message length was not truncated. */
+  assert(!msglen);
+}
+
+/* Sets the IVs used by CCM, for now this is only used internally. */
+static void
+ccm_set_iv(struct ccm_ctx *ctx, const uint8_t *iv)
+{
+  int i = CCM_BLOCK_SIZE - CCM_FLAG_GET_L(iv[CCM_OFFSET_FLAGS]);
+  memcpy(ctx-&gt;tag.b, iv, CCM_BLOCK_SIZE);
+  memcpy(ctx-&gt;ctr.b, iv, CCM_BLOCK_SIZE);
+  ctx-&gt;ctr.b[CCM_OFFSET_FLAGS] &amp;= ~(CCM_FLAG_ADATA | CCM_FLAG_M);
+  ctx-&gt;ctr.b[CCM_BLOCK_SIZE-1] = 1;
+  while (i &lt; (CCM_BLOCK_SIZE-1)) ctx-&gt;ctr.b[i++] = 0;
+  ctx-&gt;alen = 0;    /* Adata length unknown, streaming not possible. */
+  ctx-&gt;blen = -1;   /* IV is set, but unencrypted. */
+}
+
+void
+ccm_set_nonce(struct ccm_ctx *ctx, size_t length, const uint8_t *nonce,
+        size_t authlen, size_t msglen, size_t taglen)
+{
+  uint8_t iv[CCM_BLOCK_SIZE];
+  ccm_build_iv(length, nonce, msglen, taglen, iv);
+  ccm_set_iv(ctx, iv);
+  ctx-&gt;alen = authlen;
+}
+
+void
+ccm_update(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	   size_t length, const uint8_t *data)
+{
+  const uint8_t *end = data + length;
+
+  /* nop */
+  if (!length) return;
+
+  /* On the first call, encrypt B0 and encode L(a) */
+  if (ctx-&gt;blen &lt; 0) {
+    if (!ctx-&gt;alen) ctx-&gt;alen = length; /* If alen unknown, set it now. */
+    ctx-&gt;tag.b[CCM_OFFSET_FLAGS] |= CCM_FLAG_ADATA;
+    f(cipher, CCM_BLOCK_SIZE, ctx-&gt;tag.b, ctx-&gt;tag.b);
+    ctx-&gt;blen = 0;
+    if (ctx-&gt;alen &gt;= (0x01ULL &lt;&lt; 32)) {
+      /* Encode L(a) as 0xff || 0xff || &lt;64-bit integer&gt; */
+      ctx-&gt;tag.b[ctx-&gt;blen++] ^= 0xff;
+      ctx-&gt;tag.b[ctx-&gt;blen++] ^= 0xff;
+      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 56) &amp; 0xff;
+      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 48) &amp; 0xff;
+      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 40) &amp; 0xff;
+      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 32) &amp; 0xff;
+      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 24) &amp; 0xff;
+      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 16) &amp; 0xff;
+    }
+    else if (ctx-&gt;alen &gt;= ((0x1ULL &lt;&lt; 16) - (0x1ULL &lt;&lt; 8))) {
+      /* Encode L(a) as 0xff || 0xfe || &lt;32-bit integer&gt; */
+      ctx-&gt;tag.b[ctx-&gt;blen++] ^= 0xff;
+      ctx-&gt;tag.b[ctx-&gt;blen++] ^= 0xfe;
+      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 24) &amp; 0xff;
+      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 16) &amp; 0xff;
+    }
+    ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 8) &amp; 0xff;
+    ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 0) &amp; 0xff;
+  }
+  
+  /* Process unaligned blocks. */
+  if (ctx-&gt;blen) {
+    if ((ctx-&gt;blen + length) &lt; CCM_BLOCK_SIZE) {
+      memxor(&amp;ctx-&gt;tag.b[ctx-&gt;blen], data, length);
+      ctx-&gt;blen += length;
+      return;
+    }
+    memxor(&amp;ctx-&gt;tag.b[ctx-&gt;blen], data, CCM_BLOCK_SIZE - ctx-&gt;blen);
+    data += (CCM_BLOCK_SIZE - ctx-&gt;blen);
+    f(cipher, CCM_BLOCK_SIZE, ctx-&gt;tag.b, ctx-&gt;tag.b);
+  }
+  
+  /* Process aligned blocks. */
+  while ((data + CCM_BLOCK_SIZE) &lt; end) {
+    memxor(ctx-&gt;tag.b, data, CCM_BLOCK_SIZE);
+    f(cipher, CCM_BLOCK_SIZE, ctx-&gt;tag.b, ctx-&gt;tag.b);
+    data += CCM_BLOCK_SIZE;
+  } /* while */
+  
+  /* Save leftovers for later. */
+  ctx-&gt;blen = (end - data);
+  if (ctx-&gt;blen) memxor(&amp;ctx-&gt;tag.b, data, ctx-&gt;blen);
+}
+
+/*
+ * Because of the underlying CTR mode encryption, when called multiple times
+ * the data in intermediate calls must be provided in multiples of the block
+ * size.
+ */
+void
+ccm_encrypt(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	    size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ccm_pad(ctx, cipher, f);
+  ccm_update(ctx, cipher, f, length, src);
+  ctr_crypt(cipher, f, CCM_BLOCK_SIZE, ctx-&gt;ctr.b, length, dst, src);
+}
+
+/*
+ * Because of the underlying CTR mode decryption, when called multiple times
+ * the data in intermediate calls must be provided in multiples of the block
+ * size.
+ */
+void
+ccm_decrypt(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	    size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ctr_crypt(cipher, f, CCM_BLOCK_SIZE, ctx-&gt;ctr.b, length, dst, src);
+  ccm_pad(ctx, cipher, f);
+  ccm_update(ctx, cipher, f, length, dst);
+}
+
+void
+ccm_digest(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	   size_t length, uint8_t *digest)
+{
+  int i = CCM_BLOCK_SIZE - CCM_FLAG_GET_L(ctx-&gt;ctr.b[CCM_OFFSET_FLAGS]);
+  assert(length &lt;= CCM_BLOCK_SIZE);
+  while (i &lt; CCM_BLOCK_SIZE)  ctx-&gt;ctr.b[i++] = 0;
+  ccm_pad(ctx, cipher, f);
+  ctr_crypt(cipher, f, CCM_BLOCK_SIZE, ctx-&gt;ctr.b, length, digest, ctx-&gt;tag.b);
+}
+
+void
+ccm_encrypt_message(void *cipher, nettle_crypt_func *f,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  struct ccm_ctx ctx;
+  ccm_set_nonce(&amp;ctx, nlength, nonce, alength, mlength, tlength);
+  ccm_update(&amp;ctx, cipher, f, alength, adata);
+  ccm_encrypt(&amp;ctx, cipher, f, mlength, dst, src);
+  ccm_digest(&amp;ctx, cipher, f, tlength, tag);
+}
+
+void
+ccm_decrypt_message(void *cipher, nettle_crypt_func *f,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src)
+{
+  struct ccm_ctx ctx;
+  ccm_set_nonce(&amp;ctx, nlength, nonce, alength, mlength, tlength);
+  ccm_update(&amp;ctx, cipher, f, alength, adata);
+  ccm_decrypt(&amp;ctx, cipher, f, mlength, dst, src);
+  ccm_digest(&amp;ctx, cipher, f, tlength, tag);
+}
diff --git a/ccm.h b/ccm.h
new file mode 100644
index 0000000..76b4cc4
--- /dev/null
+++ b/ccm.h
@@ -0,0 +1,267 @@
+/* ccm.h
+ *
+ * Counter with CBC-MAC mode, specified by NIST,
+ * http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf
 + *
+ * NIST SP800-38C doesn't specify the particular formatting and counter generation
+ * algorithm for CCM, but it does include an example algorithm. This example
+ * has become the de-factor standard, and has been adopted by both the IETF and
+ * IEEE across a wide variety of protocols.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2014 Exegin Technologies Limited
+ * Copyright (C) 2014 Owen Kirby
+ * 
+ * Contributed by Owen Kirby
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#ifndef NETTLE_CCM_H_INCLUDED
+#define NETTLE_CCM_H_INCLUDED
+
+#include "aes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define ccm_set_nonce nettle_ccm_set_nonce
+#define ccm_update nettle_ccm_update
+#define ccm_encrypt nettle_ccm_encrypt
+#define ccm_decrypt nettle_ccm_decrypt
+#define ccm_digest nettle_ccm_digest
+#define ccm_encrypt_message nettle_ccm_encrypt_message
+#define ccm_decrypt_message nettle_ccm_decrypt_message
+
+#define ccm_aes128_set_key nettle_ccm_aes128_set_key
+#define ccm_aes128_set_nonce nettle_ccm_aes128_set_nonce
+#define ccm_aes128_update nettle_ccm_aes128_update
+#define ccm_aes128_encrypt nettle_ccm_aes128_encrypt
+#define ccm_aes128_decrypt nettle_ccm_aes128_decrypt
+#define ccm_aes128_digest nettle_ccm_aes128_digest
+#define ccm_aes128_encrypt_message nettle_ccm_aes128_encrypt_message
+#define ccm_aes128_decrypt_message nettle_ccm_aes128_decrypt_message
+
+#define ccm_aes192_set_key nettle_ccm_aes192_set_key
+#define ccm_aes192_set_nonce nettle_ccm_aes192_set_nonce
+#define ccm_aes192_update nettle_ccm_aes192_update
+#define ccm_aes192_encrypt nettle_ccm_aes192_encrypt
+#define ccm_aes192_decrypt nettle_ccm_aes192_decrypt
+#define ccm_aes192_digest nettle_ccm_aes192_digest
+#define ccm_aes192_encrypt_message nettle_ccm_aes192_encrypt_message
+#define ccm_aes192_decrypt_message nettle_ccm_aes192_decrypt_message
+
+#define ccm_aes256_set_key nettle_ccm_aes256_set_key
+#define ccm_aes256_set_nonce nettle_ccm_aes256_set_nonce
+#define ccm_aes256_update nettle_ccm_aes256_update
+#define ccm_aes256_encrypt nettle_ccm_aes256_encrypt
+#define ccm_aes256_decrypt nettle_ccm_aes256_decrypt
+#define ccm_aes256_digest nettle_ccm_aes256_digest
+#define ccm_aes256_encrypt_message nettle_ccm_aes256_encrypt_message
+#define ccm_aes256_decrypt_message nettle_ccm_aes256_decrypt_message
+
+/* For CCM, the block size of the block cipher shall be 128 bits. */
+#define CCM_BLOCK_SIZE  16
+
+/* Per-message state */
+struct ccm_ctx {
+  union nettle_block16 ctr;     /* Counter for CTR encryption. */
+  union nettle_block16 tag;     /* CBC-MAC message tag. */
+  uint64_t  alen; /* Length of adata set during the nonce generation. */
+  int       blen; /* &lt;0 on init or # of bytes since the last aligned block */
+};
+
+/*
+ * Obnoxiously, CCM mode requires the adata and message lengths when building
+ * the IV, which prevents any streaming API to the cipher. As such, this makes
+ * the set_nonce() function incompatible with the nettle AEAD API.
+ */
+void
+ccm_set_nonce(struct ccm_ctx *ctx, size_t noncelen, const uint8_t *nonce,
+        size_t authlen, size_t msglen, size_t taglen);
+
+void
+ccm_update(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	    size_t length, const uint8_t *data);
+
+void
+ccm_encrypt(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	    size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_decrypt(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	    size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_digest(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	   size_t length, uint8_t *digest);
+
+/* All-in-one encryption and decryption API. */
+void
+ccm_encrypt_message(void *cipher, nettle_crypt_func *f,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_decrypt_message(void *cipher, nettle_crypt_func *f,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src);
+
+/* CCM Mode with AES-128 */
+struct ccm_aes128_ctx {
+    struct ccm_ctx      ccm;
+    struct aes128_ctx   cipher;
+};
+
+void
+ccm_aes128_set_key(struct ccm_aes128_ctx *ctx, const uint8_t *key);
+
+void
+ccm_aes128_set_nonce(struct ccm_aes128_ctx *ctx,
+        size_t length, const uint8_t *nonce,
+        size_t authlen, size_t msglen, size_t taglen);
+        
+void
+ccm_aes128_update (struct ccm_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+ccm_aes128_encrypt(struct ccm_aes128_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_aes128_decrypt(struct ccm_aes128_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_aes128_digest(struct ccm_aes128_ctx *ctx,
+		  size_t length, uint8_t *digest);
+
+void
+ccm_aes128_encrypt_message(struct ccm_aes128_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_aes128_decrypt_message(struct ccm_aes128_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src);
+
+struct ccm_aes192_ctx {
+    struct ccm_ctx      ccm;
+    struct aes192_ctx   cipher;
+};
+
+/* CCM Mode with AES-192 */
+void
+ccm_aes192_set_key(struct ccm_aes192_ctx *ctx, const uint8_t *key);
+
+void
+ccm_aes192_set_nonce(struct ccm_aes192_ctx *ctx,
+        size_t length, const uint8_t *nonce,
+        size_t authlen, size_t msglen, size_t taglen);
+
+void
+ccm_aes192_update(struct ccm_aes192_ctx *ctx,
+        size_t length, const uint8_t *data);
+
+void
+ccm_aes192_encrypt(struct ccm_aes192_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_aes192_decrypt(struct ccm_aes192_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_aes192_digest(struct ccm_aes192_ctx *ctx,
+		  size_t length, uint8_t *digest);
+
+void
+ccm_aes192_encrypt_message(struct ccm_aes192_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_aes192_decrypt_message(struct ccm_aes192_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src);
+
+/* CCM Mode with AES-256 */
+struct ccm_aes256_ctx {
+    struct ccm_ctx      ccm;
+    struct aes256_ctx   cipher;
+};
+
+void
+ccm_aes256_set_key(struct ccm_aes256_ctx *ctx, const uint8_t *key);
+
+void
+ccm_aes256_set_nonce(struct ccm_aes256_ctx *ctx,
+        size_t length, const uint8_t *nonce,
+        size_t authlen, size_t msglen, size_t taglen);
+
+void
+ccm_aes256_update(struct ccm_aes256_ctx *ctx,
+        size_t length, const uint8_t *data);
+
+void
+ccm_aes256_encrypt(struct ccm_aes256_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_aes256_decrypt(struct ccm_aes256_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_aes256_digest(struct ccm_aes256_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
+void
+ccm_aes256_encrypt_message(struct ccm_aes256_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_aes256_decrypt_message(struct ccm_aes256_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata,
+        size_t tlength, uint8_t *tag,
+	    size_t mlength, uint8_t *dst, const uint8_t *src);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_CCM_H_INCLUDED */
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index 3b836af..8e5521b 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -11,6 +11,7 @@
 /camellia-test
 /cast128-test
 /cbc-test
+/ccm-test
 /ctr-test
 /cxx-test
 /des-compat-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 43079ec..16d107c 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -100,6 +100,9 @@ knuth-lfib-test$(EXEEXT): knuth-lfib-test.$(OBJEXT)
 cbc-test$(EXEEXT): cbc-test.$(OBJEXT)
 	$(LINK) cbc-test.$(OBJEXT) $(TEST_OBJS) -o cbc-test$(EXEEXT)
 
+ccm-test$(EXEEXT): ccm-test.$(OBJEXT)
+	$(LINK) ccm-test.$(OBJEXT) $(TEST_OBJS) -o ccm-test$(EXEEXT)
+
 ctr-test$(EXEEXT): ctr-test.$(OBJEXT)
 	$(LINK) ctr-test.$(OBJEXT) $(TEST_OBJS) -o ctr-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index d59a2cb..30611c7 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -25,7 +25,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    sha3-384-test.c sha3-512-test.c \
 		    serpent-test.c twofish-test.c \
 		    knuth-lfib-test.c \
-		    cbc-test.c ctr-test.c gcm-test.c eax-test.c \
+		    cbc-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c meta-armor-test.c \
diff --git a/testsuite/ccm-test.c b/testsuite/ccm-test.c
new file mode 100644
index 0000000..cd74db7
--- /dev/null
+++ b/testsuite/ccm-test.c
@@ -0,0 +1,709 @@
+/* ccm-test.c
+ *
+ * Self-test and vectors for CCM mode ciphers using AES-128 and AES-256. The
+ * test vectors have been collected from the following standards:
+ *  NIST SP800-38C
+ *  RFC 3610
+ *  IEEE 802.15.4-2011
+ *  IEEE P1619.1/D22 July 2007 (draft version)
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2014 Exegin Technologies Limited
+ * Copyright (C) 2014 Owen Kirby
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+#include "testutils.h"
+#include "aes.h"
+#include "ccm.h"
+#include "knuth-lfib.h"
+
+static void
+test_compare_results(const char *name,
+        const struct tstring *adata,
+        /* Expected results. */
+        const struct tstring *e_clear,
+		const struct tstring *e_cipher,
+        const struct tstring *e_tag,
+        /* Actual results. */
+        const void *clear,
+        const void *cipher,
+        const void *de_tag,
+        const void *en_tag)
+{
+  if (!MEMEQ(e_cipher-&gt;length, e_cipher-&gt;data, cipher))
+    {
+      fprintf(stderr, "%s: encrypt failed\nInput:", name);
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_cipher-&gt;length, cipher);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_cipher);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  if (!MEMEQ(e_clear-&gt;length, e_clear-&gt;data, clear))
+    {
+      fprintf(stderr, "%s decrypt failed:\nInput:", name);
+      tstring_print_hex(e_cipher);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_clear-&gt;length, clear);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  if (!MEMEQ(e_tag-&gt;length, e_tag-&gt;data, en_tag))
+    {
+      fprintf(stderr, "%s digest failed during encryption:\nAdata:", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_tag-&gt;length, en_tag);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_tag);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  if (!MEMEQ(e_tag-&gt;length, e_tag-&gt;data, de_tag))
+    {
+      fprintf(stderr, "%s digest failed during decryption:\nAdata:", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_tag-&gt;length, de_tag);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_tag);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+} /* test_compare_results */
+
+static void
+test_cipher_ccm(const struct nettle_cipher *cipher,
+		const struct tstring *key,
+		const struct tstring *nonce,
+        const struct tstring *authdata,
+        int repeat,
+        const struct tstring *cleartext,
+		const struct tstring *ciphertext,
+        const struct tstring *tag)
+{
+  void *ctx = xalloc(cipher-&gt;context_size);
+  uint8_t *en_data;
+  uint8_t *de_data;
+  uint8_t en_digest[CCM_BLOCK_SIZE];
+  uint8_t de_digest[CCM_BLOCK_SIZE];
+  size_t len;
+  size_t tlen;
+  struct ccm_ctx ccm;
+  int    i;
+
+  ASSERT (key-&gt;length == cipher-&gt;key_size);
+  ASSERT (cleartext-&gt;length == ciphertext-&gt;length);
+  len = cleartext-&gt;length;
+  tlen = tag-&gt;length;
+  if (!authdata) repeat = 0;
+  
+  en_data = xalloc(len);
+  de_data = xalloc(len);
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  
+  /* Encrypt using the incremental API. */
+  ccm_set_nonce(&amp;ccm, nonce-&gt;length, nonce-&gt;data, authdata-&gt;length * repeat, len, \
tlen); +  for (i = 0; i &lt; repeat; i++) {
+    ccm_update(&amp;ccm, ctx, cipher-&gt;encrypt, authdata-&gt;length, authdata-&gt;data);
+  }
+  ccm_encrypt(&amp;ccm, ctx, cipher-&gt;encrypt, len, en_data, cleartext-&gt;data);
+  ccm_digest(&amp;ccm, ctx, cipher-&gt;encrypt, tag-&gt;length, en_digest);
+  
+  /* Decrypt using the incremental API. */
+  ccm_set_nonce(&amp;ccm, nonce-&gt;length, nonce-&gt;data, authdata-&gt;length * repeat, len, \
tlen); +  for (i = 0; i &lt; repeat; i++) {
+    ccm_update(&amp;ccm, ctx, cipher-&gt;encrypt, authdata-&gt;length, authdata-&gt;data);
+  }
+  ccm_decrypt(&amp;ccm, ctx, cipher-&gt;encrypt, len, de_data, ciphertext-&gt;data);
+  ccm_digest(&amp;ccm, ctx, cipher-&gt;encrypt, tag-&gt;length, de_digest);
+  
+  /* Compare results using the generic API. */
+  test_compare_results("CCM", authdata,
+        cleartext, ciphertext, tag,
+        de_data, en_data, de_digest, en_digest);
+  
+  /* Ensure we get the same answers using the all-in-one API. */
+  if (repeat &lt;= 1) {
+    memset(en_data, 0, len); memset(de_data, 0, len);
+    memset(en_digest, 0, tlen); memset(de_digest, 0, tlen);
+    
+    ccm_encrypt_message(ctx, cipher-&gt;encrypt, nonce-&gt;length, nonce-&gt;data,
+        authdata-&gt;length, authdata-&gt;data, tlen, en_digest, len, en_data, \
cleartext-&gt;data); +    
+    ccm_decrypt_message(ctx, cipher-&gt;encrypt, nonce-&gt;length, nonce-&gt;data,
+        authdata-&gt;length, authdata-&gt;data, tlen, de_digest, len, de_data, \
ciphertext-&gt;data); +    
+    test_compare_results("CCM_MSG", authdata,
+        cleartext, ciphertext, tag,
+        de_data, en_data, de_digest, en_digest);
+  }
+  
+  /* Ensure we get the same answers using the per-cipher API. */
+  if (cipher == &amp;nettle_aes128) {
+    struct ccm_aes128_ctx aes;
+    memset(en_data, 0, len); memset(de_data, 0, len);
+    memset(en_digest, 0, tlen); memset(de_digest, 0, tlen);
+    
+    /* AES-128 encrypt. */
+    ccm_aes128_set_key(&amp;aes, key-&gt;data);
+    ccm_aes128_set_nonce(&amp;aes, nonce-&gt;length, nonce-&gt;data, authdata-&gt;length * \
repeat, len, tlen); +    for (i = 0; i &lt; repeat; i++) {
+      ccm_aes128_update(&amp;aes, authdata-&gt;length, authdata-&gt;data);
+    }
+    ccm_aes128_encrypt(&amp;aes,len, en_data, cleartext-&gt;data);
+    ccm_aes128_digest(&amp;aes, tag-&gt;length, en_digest);
+    
+    /* AES-128 decrypt. */
+    ccm_aes128_set_nonce(&amp;aes, nonce-&gt;length, nonce-&gt;data, authdata-&gt;length * \
repeat, len, tlen); +    for (i = 0; i &lt; repeat; i++) {
+      ccm_aes128_update(&amp;aes, authdata-&gt;length, authdata-&gt;data);
+    }
+    ccm_aes128_decrypt(&amp;aes, len, de_data, ciphertext-&gt;data);
+    ccm_aes128_digest(&amp;aes, tag-&gt;length, de_digest);
+    
+    test_compare_results("CCM_AES_128", authdata,
+        cleartext, ciphertext, tag,
+        de_data, en_data, de_digest, en_digest);
+  }
+  /* TODO: I couldn't find any test cases for CCM-AES-192 */
+  if (cipher == &amp;nettle_aes256) {
+    struct ccm_aes256_ctx aes;
+    memset(en_data, 0, len); memset(de_data, 0, len);
+    memset(en_digest, 0, tlen); memset(de_digest, 0, tlen);
+    
+    /* AES-256 encrypt. */
+    ccm_aes256_set_key(&amp;aes, key-&gt;data);
+    ccm_aes256_set_nonce(&amp;aes, nonce-&gt;length, nonce-&gt;data, authdata-&gt;length * \
repeat, len, tlen); +    for (i = 0; i &lt; repeat; i++) {
+      ccm_aes256_update(&amp;aes, authdata-&gt;length, authdata-&gt;data);
+    }
+    ccm_aes256_encrypt(&amp;aes,len, en_data, cleartext-&gt;data);
+    ccm_aes256_digest(&amp;aes, tag-&gt;length, en_digest);
+    
+    /* AES-256 decrypt. */
+    ccm_aes256_set_nonce(&amp;aes, nonce-&gt;length, nonce-&gt;data, authdata-&gt;length * \
repeat, len, tlen); +    for (i = 0; i &lt; repeat; i++) {
+      ccm_aes256_update(&amp;aes, authdata-&gt;length, authdata-&gt;data);
+    }
+    ccm_aes256_decrypt(&amp;aes,len, de_data, ciphertext-&gt;data);
+    ccm_aes256_digest(&amp;aes, tag-&gt;length, de_digest);
+    
+    test_compare_results("CCM_AES_256", authdata,
+        cleartext, ciphertext, tag,
+        de_data, en_data, de_digest, en_digest);
+  }
+  
+  free(ctx);
+  free(en_data);
+  free(de_data);
+}
+
+void
+test_main(void)
+{
+  /* Create a pattern of 00010203 04050607 08090a00b 0c0d0e0f ... */
+  struct tstring *adata;
+  unsigned int i;
+  adata = tstring_alloc(256);
+  for (i=0; i&lt;adata-&gt;length; i++) adata-&gt;data[i] = (i &amp; 0xff);
+    
+  /* From NIST spec 800-38C on AES modes.
+   *
+   * Appendix C: Example Vectors 
+   */
+  /*
+   * C.1 Example 1
+   * Klen = 128, Tlen = 32, Nlen = 56, Alen = 64, Plen = 32
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("404142434445464748494a4b4c4d4e4f"),
+        SHEX("10111213141516"),
+        SHEX("0001020304050607"), 1,
+        SHEX("20212223"),
+        SHEX("7162015b"),
+        SHEX("4dac255d"));
+
+  /*
+   * C.2 Example 2
+   * Klen = 128, Tlen = 48, Nlen = 64, Alen = 128, Plen = 128
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("404142434445464748494a4b4c4d4e4f"),
+        SHEX("1011121314151617"),
+        SHEX("000102030405060708090a0b0c0d0e0f"), 1,
+        SHEX("202122232425262728292a2b2c2d2e2f"),
+        SHEX("d2a1f0e051ea5f62081a7792073d593d"),
+        SHEX("1fc64fbfaccd"));
+
+  /*
+   * C.3 Example 3
+   * Klen = 128, Tlen = 64, Nlen = 96, Alen = 160, Plen = 192
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("404142434445464748494a4b4c4d4e4f"),
+        SHEX("101112131415161718191a1b"),
+        SHEX("000102030405060708090a0b0c0d0e0f"
+             "10111213"), 1,
+        SHEX("202122232425262728292a2b2c2d2e2f"
+             "3031323334353637"),
+        SHEX("e3b201a9f5b71a7a9b1ceaeccd97e70b"
+             "6176aad9a4428aa5"),
+        SHEX("484392fbc1b09951"));
+
+  /*
+   * C.4 Example 4
+   * Klen = 128, Tlen = 112, Nlen = 104, Alen = 524288, Plen = 256
+   * A = 00010203 04050607 08090a0b 0c0d0e0f
+   *     10111213 ...
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("404142434445464748494a4b4c4d4e4f"),
+        SHEX("101112131415161718191a1b1c"),
+        adata, 256,
+        SHEX("202122232425262728292a2b2c2d2e2f"
+             "303132333435363738393a3b3c3d3e3f"),
+        SHEX("69915dad1e84c6376a68c2967e4dab61"
+             "5ae0fd1faec44cc484828529463ccf72"),
+        SHEX("b4ac6bec93e8598e7f0dadbcea5b"));
+
+  /* From RFC 3610
+   *
+   * Section 8: Test Vectors
+   * Packet Vector #1
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 03  02 01 00 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07"), 1,
+        SHEX("08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D \
1E"), +        SHEX("58 8C 97 9A  61 C6 63 D2  F0 66 D0 C2  C0 F9 89 80  6D 5F 6B 61  \
DA C3 84"), +        SHEX("17 E8 D1 2C  FD F9 26 E0"));
+
+  /*
+   * Packet Vector #2
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 04  03 02 01 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07"), 1,
+        SHEX("08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D \
1E 1F"), +        SHEX("72 C9 1A 36  E1 35 F8 CF  29 1C A8 94  08 5C 87 E3  CC 15 C4 \
39  C9 E4 3A 3B"), +        SHEX("A0 91 D5 6E  10 40 09 16"));
+
+  /*
+   * Packet Vector #3
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 05  04 03 02 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07"), 1,
+        SHEX("08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D \
1E 1F  20"), +        SHEX("51 B1 E5 F4  4A 19 7D 1D  A4 6B 0F 8E  2D 28 2A E8  71 E8 \
38 BB  64 DA 85 96  57"), +        SHEX("4A DA A7 6F  BD 9F B0 C5"));
+
+  /*
+   * Packet Vector #4
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 06  05 04 03 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07  08 09 0A 0B"), 1,
+        SHEX("0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E"),
+        SHEX("A2 8C 68 65  93 9A 9A 79  FA AA 5C 4C  2A 9D 4A 91  CD AC 8C"),
+        SHEX("96 C8 61 B9  C9 E6 1E F1"));
+
+  /*
+   * Packet Vector #5
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 07  06 05 04 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07  08 09 0A 0B"), 1,
+        SHEX("0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F"),
+        SHEX("DC F1 FB 7B  5D 9E 23 FB  9D 4E 13 12  53 65 8A D8  6E BD CA 3E"),
+        SHEX("51 E8 3F 07  7D 9C 2D 93"));
+        
+  /*
+   * Packet Vector #6
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 08  07 06 05 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07  08 09 0A 0B"), 1,
+        SHEX("0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F  20"),
+        SHEX("6F C1 B0 11  F0 06 56 8B  51 71 A4 2D  95 3D 46 9B  25 70 A4 BD  87"),
+        SHEX("40 5A 04 43  AC 91 CB 94"));
+
+  /*
+   * Packet Vector #7
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 09  08 07 06 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07"), 1,
+        SHEX("08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D \
1E"), +        SHEX("01 35 D1 B2  C9 5F 41 D5  D1 D4 FE C1  85 D1 66 B8  09 4E 99 9D  \
FE D9 6C"), +        SHEX("04 8C 56 60  2C 97 AC BB  74 90"));
+
+  /*
+   * Packet Vector #8
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 0A  09 08 07 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07"), 1,
+        SHEX("08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D \
1E 1F"), +        SHEX("7B 75 39 9A  C0 83 1D D2  F0 BB D7 58  79 A2 FD 8F  6C AE 6B \
6C  D9 B7 DB 24"), +        SHEX("C1 7B 44 33  F4 34 96 3F  34 B4"));
+
+  /*
+   * Packet Vector #9
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 0B  0A 09 08 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07"), 1,
+        SHEX("08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D \
1E 1F  20"), +        SHEX("82 53 1A 60  CC 24 94 5A  4B 82 79 18  1A B5 C8 4D  F2 1C \
E7 F9  B7 3F 42 E1  97"), +        SHEX("EA 9C 07 E5  6B 5E B1 7E  5F 4E"));
+
+  /*
+   * Packet Vector #10
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 0C  0B 0A 09 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07  08 09 0A 0B"), 1,
+        SHEX("0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E"),
+        SHEX("07 34 25 94  15 77 85 15  2B 07 40 98  33 0A BB 14  1B 94 7B"),
+        SHEX("56 6A A9 40  6B 4D 99 99  88 DD"));
+
+  /*
+   * Packet Vector #11
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 0D  0C 0B 0A A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07  08 09 0A 0B"), 1,
+        SHEX("0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F"),
+        SHEX("67 6B B2 03  80 B0 E3 01  E8 AB 79 59  0A 39 6D A7  8B 83 49 34"),
+        SHEX("F5 3A A2 E9  10 7A 8B 6C  02 2C"));
+
+  /*
+   * Packet Vector #12
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 0E  0D 0C 0B A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07  08 09 0A 0B"), 1,
+        SHEX("0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F  20"),
+        SHEX("C0 FF A0 D6  F0 5B DB 67  F2 4D 43 A4  33 8D 2A A4  BE D7 B2 0E  43"),
+        SHEX("CD 1A A3 16  62 E7 AD 65  D6 DB"));
+
+  /*
+   * Packet Vector #13
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 41 2B 4E  A9 CD BE 3C  96 96 76 6C  FA"),
+        SHEX("0B E1 A8 8B  AC E0 18 B1"), 1,
+        SHEX("08 E8 CF 97  D8 20 EA 25  84 60 E9 6A  D9 CF 52 89  05 4D 89 5C  EA C4 \
7C"), +        SHEX("4C B9 7F 86  A2 A4 68 9A  87 79 47 AB  80 91 EF 53  86 A6 FF BD  \
D0 80 F8"), +        SHEX("E7 8C F7 CB  0C DD D7 B3"));
+
+  /*
+   * Packet Vector #14
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 33 56 8E  F7 B2 63 3C  96 96 76 6C  FA"),
+        SHEX("63 01 8F 76  DC 8A 1B CB"), 1,
+        SHEX("90 20 EA 6F  91 BD D8 5A  FA 00 39 BA  4B AF F9 BF  B7 9C 70 28  94 9C \
D0 EC"), +        SHEX("4C CB 1E 7C  A9 81 BE FA  A0 72 6C 55  D3 78 06 12  98 C8 5C \
92  81 4A BC 33"), +        SHEX("C5 2E E8 1D  7D 77 C0 8A"));
+
+  /*
+   * Packet Vector #15
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 10 3F E4  13 36 71 3C  96 96 76 6C  FA"),
+        SHEX("AA 6C FA 36  CA E8 6B 40"), 1,
+        SHEX("B9 16 E0 EA  CC 1C 00 D7  DC EC 68 EC  0B 3B BB 1A  02 DE 8A 2D  1A A3 \
46 13  2E"), +        SHEX("B1 D2 3A 22  20 DD C0 AC  90 0D 9A A0  3C 61 FC F4  A5 59 \
A4 41  77 67 08 97  08"), +        SHEX("A7 76 79 6E  DB 72 35 06"));
+
+  /*
+   * Packet Vector #16
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 76 4C 63  B8 05 8E 3C  96 96 76 6C  FA"),
+        SHEX("D0 D0 73 5C  53 1E 1B EC  F0 49 C2 44"), 1,
+        SHEX("12 DA AC 56  30 EF A5 39  6F 77 0C E1  A6 6B 21 F7  B2 10 1C"),
+        SHEX("14 D2 53 C3  96 7B 70 60  9B 7C BB 7C  49 91 60 28  32 45 26"),
+        SHEX("9A 6F 49 97  5B CA DE AF"));
+
+  /*
+   * Packet Vector #17
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 F8 B6 78  09 4E 3B 3C  96 96 76 6C  FA"),
+        SHEX("77 B6 0F 01  1C 03 E1 52  58 99 BC AE"), 1,
+        SHEX("E8 8B 6A 46  C7 8D 63 E5  2E B8 C5 46  EF B5 DE 6F  75 E9 CC 0D"),
+        SHEX("55 45 FF 1A  08 5E E2 EF  BF 52 B2 E0  4B EE 1E 23  36 C7 3E 3F"),
+        SHEX("76 2C 0C 77  44 FE 7E 3C"));
+
+  /*
+   * Packet Vector #18
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 D5 60 91  2D 3F 70 3C  96 96 76 6C  FA"),
+        SHEX("CD 90 44 D2  B7 1F DB 81  20 EA 60 C0"), 1,
+        SHEX("64 35 AC BA  FB 11 A8 2E  2F 07 1D 7C  A4 A5 EB D9  3A 80 3B A8  7F"),
+        SHEX("00 97 69 EC  AB DF 48 62  55 94 C5 92  51 E6 03 57  22 67 5E 04  C8"),
+        SHEX("47 09 9E 5A  E0 70 45 51"));
+
+  /*
+   * Packet Vector #19
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 42 FF F8  F1 95 1C 3C  96 96 76 6C  FA"),
+        SHEX("D8 5B C7 E6  9F 94 4F B8"), 1,
+        SHEX("8A 19 B9 50  BC F7 1A 01  8E 5E 67 01  C9 17 87 65  98 09 D6 7D  BE DD \
18"), +        SHEX("BC 21 8D AA  94 74 27 B6  DB 38 6A 99  AC 1A EF 23  AD E0 B5 29  \
39 CB 6A"), +        SHEX("63 7C F9 BE  C2 40 88 97  C6 BA"));
+
+  /*
+   * Packet Vector #20
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 92 0F 40  E5 6C DC 3C  96 96 76 6C  FA"),
+        SHEX("74 A0 EB C9  06 9F 5B 37"), 1,
+        SHEX("17 61 43 3C  37 C5 A3 5F  C1 F3 9F 40  63 02 EB 90  7C 61 63 BE  38 C9 \
84 37"), +        SHEX("58 10 E6 FD  25 87 40 22  E8 03 61 A4  78 E3 E9 CF  48 4A B0 \
4F  44 7E FF F6"), +        SHEX("F0 A4 77 CC  2F C9 BF 54  89 44"));
+
+  /*
+   * Packet Vector #21
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 27 CA 0C  71 20 BC 3C  96 96 76 6C  FA"),
+        SHEX("44 A3 AA 3A  AE 64 75 CA"), 1,
+        SHEX("A4 34 A8 E5  85 00 C6 E4  15 30 53 88  62 D6 86 EA  9E 81 30 1B  5A E4 \
22 6B  FA"), +        SHEX("F2 BE ED 7B  C5 09 8E 83  FE B5 B3 16  08 F8 E2 9C  38 81 \
9A 89  C8 E7 76 F1  54"), +        SHEX("4D 41 51 A4  ED 3A 8B 87  B9 CE"));
+
+  /*
+   * Packet Vector #22
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 5B 8C CB  CD 9A F8 3C  96 96 76 6C  FA"),
+        SHEX("EC 46 BB 63  B0 25 20 C3  3C 49 FD 70"), 1,
+        SHEX("B9 6B 49 E2  1D 62 17 41  63 28 75 DB  7F 6C 92 43  D2 D7 C2"),
+        SHEX("31 D7 50 A0  9D A3 ED 7F  DD D4 9A 20  32 AA BF 17  EC 8E BF"),
+        SHEX("7D 22 C8 08  8C 66 6B E5  C1 97"));
+
+  /*
+   * Packet Vector #23
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 3E BE 94  04 4B 9A 3C  96 96 76 6C  FA"),
+        SHEX("47 A6 5A C7  8B 3D 59 42  27 E8 5E 71"), 1,
+        SHEX("E2 FC FB B8 80 44 2C 73  1B F9 51 67  C8 FF D7 89  5E 33 70 76"),
+        SHEX("E8 82 F1 DB D3 8C E3 ED  A7 C2 3F 04  DD 65 07 1E  B4 13 42 AC"),
+        SHEX("DF 7E 00 DC  CE C7 AE 52  98 7D"));
+
+  /*
+   * Packet Vector #24
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 8D 49 3B  30 AE 8B 3C  96 96 76 6C  FA"),
+        SHEX("6E 37 A6 EF  54 6D 95 5D  34 AB 60 59"), 1,
+        SHEX("AB F2 1C 0B  02 FE B8 8F  85 6D F4 A3  73 81 BC E3  CC 12 85 17  D4"),
+        SHEX("F3 29 05 B8  8A 64 1B 04  B9 C9 FF B5  8C C3 90 90  0F 3D A1 2A  B1"),
+        SHEX("6D CE 9E 82  EF A1 6D A6  20 59"));
+
+  /* From IEEE 802.15.4-2011
+   *
+   * Annex C: Test vectors for cryptographic building blocks
+   * C.2.1  MAC beacon frame
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF"),
+        SHEX("AC DE 48 00 00 00 00 01 00 00 00 05 02"),
+        SHEX("08 D0 84 21 43 01 00 00 00 00 48 DE AC 02 05 00 00 00 55 CF 00 00 51 \
52 53 54"), 1, +        SHEX(""),
+        SHEX(""),
+        SHEX("22 3B C1 EC 84 1A B5 53"));
+
+  /*
+   * C.2.2 MAC data frame
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF"),
+        SHEX("AC DE 48 00 00 00 00 01 00 00 00 05 04"),
+        SHEX("69 DC 84 21 43 02 00 00 00 00 48 DE AC 01 00 00 00 00 48 DE AC 04 05 \
00 00 00"), 1, +        SHEX("61 62 63 64"),
+        SHEX("D4 3E 02 2B"),
+        SHEX(""));
+
+  /*
+   * C.2.3 MAC command frame
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF"),
+        SHEX("AC DE 48 00 00 00 00 01 00 00 00 05 06"),
+        SHEX("2B DC 84 21 43 02 00 0000 00 48 DE AC FF FF 01 00 00 00 00 48 DE AC 06 \
05 00 00 00 01"), 1, +        SHEX("CE"),
+        SHEX("D8"),
+        SHEX("4F DE 52 90 61 F9 C6 F1"));
+
+  /* From IEEE P1619.1/D22 July 2007 (draft version)
+   *
+   * Annex D: Test Vectors
+   * D.2.1 CCM-128-AES-256 test vector 1
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("0000000000000000000000000000000000000000000000000000000000000000"),
+        SHEX("000000000000000000000000"),
+        SHEX(""), 0,
+        SHEX("00000000000000000000000000000000"),
+        SHEX("c1944044c8e7aa95d2de9513c7f3dd8c"),
+        SHEX("4b0a3e5e51f151eb0ffae7c43d010fdb"));
+
+  /*
+   * D.2.2 CCM-128-AES-256 test vector 2
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("0000000000000000000000000000000000000000000000000000000000000000"),
+        SHEX("000000000000000000000000"),
+        SHEX("00000000000000000000000000000000"), 1,
+        SHEX(""),
+        SHEX(""),
+        SHEX("904704e89fb216443cb9d584911fc3c2"));
+
+  /*
+   * D.2.3 CCM-128-AES-256 test vector 3
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("0000000000000000000000000000000000000000000000000000000000000000"),
+        SHEX("000000000000000000000000"),
+        SHEX("00000000000000000000000000000000"), 1,
+        SHEX("00000000000000000000000000000000"),
+        SHEX("c1944044c8e7aa95d2de9513c7f3dd8c"),
+        SHEX("87314e9c1fa01abe6a6415943dc38521"));
+
+  /*
+   * D.2.4 CCM-128-AES-256 test vector 4
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("fb7615b23d80891dd470980bc79584c8b2fb64ce60978f4d17fce45a49e830b7"),
+        SHEX("dbd1a3636024b7b402da7d6f"),
+        SHEX(""), 0,
+        SHEX("a845348ec8c5b5f126f50e76fefd1b1e"),
+        SHEX("cc881261c6a7fa72b96a1739176b277f"),
+        SHEX("3472e1145f2c0cbe146349062cf0e423"));
+
+  /*
+   * D.2.5 CCM-128-AES-256 test vector 5
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f"),
+        SHEX("101112131415161718191a1b"),
+        SHEX("000102030405060708090a0b0c0d0e0f10111213"), 1,
+        SHEX("202122232425262728292a2b2c2d2e2f3031323334353637"),
+        SHEX("04f883aeb3bd0730eaf50bb6de4fa2212034e4e41b0e75e5"),
+        SHEX("9bba3f3a107f3239bd63902923f80371"));
+
+  /*
+   * D.2.6 CCM-128-AES-256 test vector 6
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f"),
+        SHEX("101112131415161718191a1b"),
+        adata, 256,
+        SHEX("202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f"),
+        SHEX("04f883aeb3bd0730eaf50bb6de4fa2212034e4e41b0e75e577f6bf2422c0f6d2"),
+        SHEX("3376d2cf256ef613c56454cbb5265834"));
+
+  /*
+   * D.2.7 CCM-128-AES-256 test vector 7
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f"),
+        SHEX("101112131415161718191a1b"),
+        SHEX("202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f"), 1,
+        SHEX("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
+             "202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f"
+             "404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f"
+             "606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f"
+             "808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f"
+             "a0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
+             "c0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedf"
+             "e0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"),
+        SHEX("24d8a38e939d2710cad52b96fe6f82010014c4c43b2e55c557d69f0402e0d6f2"
+             "06c53d6cbd3f1c3c6de5dcdcad9fb74f25741dea741149fe4278a0cc24741e86"
+             "58cc0523b8d7838c60fb1de4b7c3941f5b26dea9322aa29656ec37ac18a9b108"
+             "a6f38b7917f5a9c398838b22afbd17252e96694a9e6237964a0eae21c0a6e152"
+             "15a0e82022926be97268249599e456e05029c3ebc07d78fc5b4a0862e04e68c2"
+             "9514c7bdafc4b52e04833bf30622e4eb42504a44a9dcbc774752de7bb82891ad"
+             "1eba9dc3281422a8aba8654268d3d9c81705f4c5a531ef856df5609a159af738"
+             "eb753423ed2001b8f20c23725f2bef18c409f7e52132341f27cb8f0e79894dd9"),
+        SHEX("ebb1fa9d28ccfe21bdfea7e6d91e0bab"));
+
+  /*
+   * D.2.8 CCM-128-AES-256 test vector 8
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("fb7615b23d80891dd470980bc79584c8b2fb64ce6097878d17fce45a49e830b7"),
+        SHEX("dbd1a3636024b7b402da7d6f"),
+        SHEX("36"), 1,
+        SHEX("a9"),
+        SHEX("9d"),
+        SHEX("3261b1cf931431e99a32806738ecbd2a"));
+
+  /*
+   * D.2.9 CCM-128-AES-256 test vector 9
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("f8d476cfd646ea6c2384cb1c27d6195dfef1a9f37b9c8d21a79c21f8cb90d289"),
+        SHEX("dbd1a3636024b7b402da7d6f"),
+        SHEX("7bd859a247961a21823b380e9fe8b65082ba61d3"), 1,
+        SHEX("90ae61cf7baebd4cade494c54a29ae70269aec71"),
+        SHEX("6c05313e45dc8ec10bea6c670bd94f31569386a6"),
+        SHEX("8f3829e8e76ee23c04f566189e63c686"));
+}
-- 
1.7.9.5


</body></email><email><emailId>20140315070740</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-15 07:07:40-0400</timestampReceived><subject>Re: [PATCH v2] CCM Cipher Modes</subject><body>

Owen Kirby &lt;osk@exegin.com&gt; writes:

&gt; I've incorporated a few of your suggestions and updated my patch for the CCM cipher
&gt; modes. This improves the API coverage in the CCM test suite, adds the all-at-once
&gt; API for message processing, and fixes the copyright of the CCM mode source code.

Thanks!

&gt; --- /dev/null
&gt; +++ b/ccm.c
&gt; +/* Pad an unaligned CBC-MAC digest with zero, or initialize B0 if no adata. */
&gt; +static void
&gt; +ccm_pad(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f)
&gt; +{
&gt; +    if (ctx-&gt;blen) f(cipher, CCM_BLOCK_SIZE, ctx-&gt;tag.b, ctx-&gt;tag.b);
&gt; +    ctx-&gt;blen = 0;
&gt; +}

Can you explain what this is intended for? It's called unconditionally
by ccm_encrypt and ccm_decrypt, and I imagine it's a nop for all calls
but the first (otherwise, ccm_encrypt (..., 16, msg...); ccm_encrypt
(..., 16, msg+16...); would seem to give different output than
ccm_encrypt(...32, msg))?

It is intended that _update and encrypt_/_decrypt can be called multiple
times, as long as the total length equals the corresponding value passed
to _set_nonce, right?

&gt; +void
&gt; +ccm_update(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
&gt; +	   size_t length, const uint8_t *data)
&gt; +{
&gt; +  const uint8_t *end = data + length;
&gt; +
&gt; +  /* nop */
&gt; +  if (!length) return;
&gt; +
&gt; +  /* On the first call, encrypt B0 and encode L(a) */
&gt; +  if (ctx-&gt;blen &lt; 0) {
&gt; +    if (!ctx-&gt;alen) ctx-&gt;alen = length; /* If alen unknown, set it now. */
&gt; +    ctx-&gt;tag.b[CCM_OFFSET_FLAGS] |= CCM_FLAG_ADATA;

Why the special handling of zero ctx-&gt;alen here? As far as I can see,
this can happen only if ccm_set_nonce is called with alength = 0, and
then nevertheless calls ccm_update with length &gt; 0, which seems like an
invalid use of the api.

&gt; +    f(cipher, CCM_BLOCK_SIZE, ctx-&gt;tag.b, ctx-&gt;tag.b);
&gt; +    ctx-&gt;blen = 0;
&gt; +    if (ctx-&gt;alen &gt;= (0x01ULL &lt;&lt; 32)) {
&gt; +      /* Encode L(a) as 0xff || 0xff || &lt;64-bit integer&gt; */
&gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= 0xff;
&gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= 0xff;
&gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 56) &amp; 0xff;
&gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 48) &amp; 0xff;
&gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 40) &amp; 0xff;
&gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 32) &amp; 0xff;
&gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 24) &amp; 0xff;
&gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 16) &amp; 0xff;
&gt; +    }
&gt; +    else if (ctx-&gt;alen &gt;= ((0x1ULL &lt;&lt; 16) - (0x1ULL &lt;&lt; 8))) {
&gt; +      /* Encode L(a) as 0xff || 0xfe || &lt;32-bit integer&gt; */
&gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= 0xff;
&gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= 0xfe;
&gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 24) &amp; 0xff;
&gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 16) &amp; 0xff;
&gt; +    }
&gt; +    ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 8) &amp; 0xff;
&gt; +    ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 0) &amp; 0xff;
&gt; +  }

Is it possible to move this initial processing to ccm_set_nonce? The
alength *is* known there, and that would let you eliminate the ctx-&gt;blen
&lt; 0 cases, and maybe you could eliminate the alen state variable too (or
keep it for sanity checking only).

&gt; +void
&gt; +ccm_digest(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
&gt; +	   size_t length, uint8_t *digest)
&gt; +{
&gt; +  int i = CCM_BLOCK_SIZE - CCM_FLAG_GET_L(ctx-&gt;ctr.b[CCM_OFFSET_FLAGS]);

Maybe it would be nicer to stick to a one-way encoding of the ctr block
(done by ccm_build_iv, if I understand correctly), and never decode that
format? One would need to store the needed information in some simpler
"uncoded" way in the ctx. That's a judgment call, adding redundant info
to the context is also a bit ugly.

&gt; +void
&gt; +ccm_encrypt_message(void *cipher, nettle_crypt_func *f,
&gt; +        size_t nlength, const uint8_t *nonce, 
&gt; +        size_t alength, const uint8_t *adata,
&gt; +        size_t tlength, uint8_t *tag,
&gt; +	    size_t mlength, uint8_t *dst, const uint8_t *src)
&gt; +{
&gt; +  struct ccm_ctx ctx;
&gt; +  ccm_set_nonce(&amp;ctx, nlength, nonce, alength, mlength, tlength);
&gt; +  ccm_update(&amp;ctx, cipher, f, alength, adata);
&gt; +  ccm_encrypt(&amp;ctx, cipher, f, mlength, dst, src);
&gt; +  ccm_digest(&amp;ctx, cipher, f, tlength, tag);
&gt; +}

I think this function should append the tag to the ciphertext (assuming
ccm is specified as an aead with a single output string?).

&gt; +void
&gt; +ccm_decrypt_message(void *cipher, nettle_crypt_func *f,
&gt; +        size_t nlength, const uint8_t *nonce, 
&gt; +        size_t alength, const uint8_t *adata,
&gt; +        size_t tlength, uint8_t *tag,
&gt; +	    size_t mlength, uint8_t *dst, const uint8_t *src)
&gt; +{
&gt; +  struct ccm_ctx ctx;
&gt; +  ccm_set_nonce(&amp;ctx, nlength, nonce, alength, mlength, tlength);
&gt; +  ccm_update(&amp;ctx, cipher, f, alength, adata);
&gt; +  ccm_decrypt(&amp;ctx, cipher, f, mlength, dst, src);
&gt; +  ccm_digest(&amp;ctx, cipher, f, tlength, tag);
&gt; +}

I think this function should have a tag *input* (possibly reading it at
te end of the cryptotext), compare it to the tag it computes, and return
1 on success, 0 for failure. 

If the tag is appended to the cryptotext, I'm not sure if the mlength
should be the message length with or without the tag (i.e., the length
of the clear text message, or of the encrypted and authenticated
message).

Maybe it's best to let it be the length of the clear text message, same
as passed to ccm_encrypt_message. In any case, the caller must be aware
of both lengths.

One *could* pass both message length, and derive the tag length as the
difference. But I'm afraid that style won't generalize nicely to other
aead algorithms.

&gt; diff --git a/ccm.h b/ccm.h
&gt; new file mode 100644
&gt; index 0000000..76b4cc4
&gt; +/* Per-message state */
&gt; +struct ccm_ctx {
&gt; +  union nettle_block16 ctr;     /* Counter for CTR encryption. */
&gt; +  union nettle_block16 tag;     /* CBC-MAC message tag. */
&gt; +  uint64_t  alen; /* Length of adata set during the nonce generation. */
&gt; +  int       blen; /* &lt;0 on init or # of bytes since the last aligned block */
&gt; +};

In nettle, length is usually not abbreviated to "len". If negative blen
values can be eliminated, it should be changed to unsigned.

&gt; --- /dev/null
&gt; +++ b/testsuite/ccm-test.c
&gt; +  /* Ensure we get the same answers using the all-in-one API. */
&gt; +  if (repeat &lt;= 1) {
&gt; +    memset(en_data, 0, len); memset(de_data, 0, len);
&gt; +    memset(en_digest, 0, tlen); memset(de_digest, 0, tlen);
&gt; +    
&gt; +    ccm_encrypt_message(ctx, cipher-&gt;encrypt, nonce-&gt;length, nonce-&gt;data,
&gt; +        authdata-&gt;length, authdata-&gt;data, tlen, en_digest, len, en_data, cleartext-&gt;data);
&gt; +    
&gt; +    ccm_decrypt_message(ctx, cipher-&gt;encrypt, nonce-&gt;length, nonce-&gt;data,
&gt; +        authdata-&gt;length, authdata-&gt;data, tlen, de_digest, len, de_data, ciphertext-&gt;data);

If the all-in-one interface is changed as suggested above, adding a
return value for ccm_decrypt_message, one should also check that
ccm_decrypt_message returns 1 for the correct data, and 0 if any of
message, adata or or tag is corrupted.

Regards,
/Niels
-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140317014953</emailId><senderName>Owen Kirby</senderName><senderEmail>osk@exegin.com</senderEmail><timestampReceived>2014-03-17 01:49:53-0400</timestampReceived><subject>Re: [PATCH v2] CCM Cipher Modes</subject><body>

On Sat, Mar 15, 2014 at 12:07 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt; &gt; --- /dev/null
&gt; &gt; +++ b/ccm.c
&gt; &gt; +/* Pad an unaligned CBC-MAC digest with zero, or initialize B0 if no adata. */
&gt; &gt; +static void
&gt; &gt; +ccm_pad(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f)
&gt; &gt; +{
&gt; &gt; +    if (ctx-&gt;blen) f(cipher, CCM_BLOCK_SIZE, ctx-&gt;tag.b, ctx-&gt;tag.b);
&gt; &gt; +    ctx-&gt;blen = 0;
&gt; &gt; +}
&gt;
&gt; Can you explain what this is intended for? It's called unconditionally
&gt; by ccm_encrypt and ccm_decrypt, and I imagine it's a nop for all calls
&gt; but the first (otherwise, ccm_encrypt (..., 16, msg...); ccm_encrypt
&gt; (..., 16, msg+16...); would seem to give different output than
&gt; ccm_encrypt(...32, msg))?
&gt;
&gt; It is intended that _update and encrypt_/_decrypt can be called multiple
&gt; times, as long as the total length equals the corresponding value passed
&gt; to _set_nonce, right?

The Input to the CBC-MAC used in CCM mode takes the form:
L(adata) | adata | padding | plaintext | padding

Where L(adata) is a variable length transformation that encodes the length
of adata, and padding is the minimum number of 0-bits necessary to align
the input to a multiple of the block size (note that input to the CBC-MAC is
just an XOR with the previous block, so padding becomes a NOP)

Because ccm_update() might be called multiple times, with data that doesn't
necessarily leave the input aligned to the block size, blen is used to count
the number of bytes that were already added to block, but haven't been
processed by another iteration of the CBC-MAC. If the last call to left the
input data aligned to the block size, then blen will be zero. In other words,
blen is the length of data input to the CBC-MAC modulus the block size.

Once we find the end of the adata (this is currently done on the first call to
ccm_encrypt() or ccm_decrypt()), we need to insert the padding before the
plaintext, which is what ccm_pad() does. Then, because the CTR functions
must always in a multiple of the block size, blen should always be zero
except for the last block of the message.

&gt;
&gt; &gt; +void
&gt; &gt; +ccm_update(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
&gt; &gt; +        size_t length, const uint8_t *data)
&gt; &gt; +{
&gt; &gt; +  const uint8_t *end = data + length;
&gt; &gt; +
&gt; &gt; +  /* nop */
&gt; &gt; +  if (!length) return;
&gt; &gt; +
&gt; &gt; +  /* On the first call, encrypt B0 and encode L(a) */
&gt; &gt; +  if (ctx-&gt;blen &lt; 0) {
&gt; &gt; +    if (!ctx-&gt;alen) ctx-&gt;alen = length; /* If alen unknown, set it now. */
&gt; &gt; +    ctx-&gt;tag.b[CCM_OFFSET_FLAGS] |= CCM_FLAG_ADATA;
&gt;
&gt; Why the special handling of zero ctx-&gt;alen here? As far as I can see,
&gt; this can happen only if ccm_set_nonce is called with alength = 0, and
&gt; then nevertheless calls ccm_update with length &gt; 0, which seems like an
&gt; invalid use of the api.

Since the IV only contains a single bit that indicates whether adata exists
at all, in theory the alength parameter could be omitted from set_nonce()
entirely and then handled in ccm_update(), which is what this check is doing.

This is more or less an artifact of an attempt to support the AEAD API. Note
that if you call ccm_set_nonce() with alength==0, and then pass the entire
adata to ccm_update(), you would still get the correct authentication tag and
ciphertext because of this special check on alen.

&gt;
&gt; &gt; +    f(cipher, CCM_BLOCK_SIZE, ctx-&gt;tag.b, ctx-&gt;tag.b);
&gt; &gt; +    ctx-&gt;blen = 0;
&gt; &gt; +    if (ctx-&gt;alen &gt;= (0x01ULL &lt;&lt; 32)) {
&gt; &gt; +      /* Encode L(a) as 0xff || 0xff || &lt;64-bit integer&gt; */
&gt; &gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= 0xff;
&gt; &gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= 0xff;
&gt; &gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 56) &amp; 0xff;
&gt; &gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 48) &amp; 0xff;
&gt; &gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 40) &amp; 0xff;
&gt; &gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 32) &amp; 0xff;
&gt; &gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 24) &amp; 0xff;
&gt; &gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 16) &amp; 0xff;
&gt; &gt; +    }
&gt; &gt; +    else if (ctx-&gt;alen &gt;= ((0x1ULL &lt;&lt; 16) - (0x1ULL &lt;&lt; 8))) {
&gt; &gt; +      /* Encode L(a) as 0xff || 0xfe || &lt;32-bit integer&gt; */
&gt; &gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= 0xff;
&gt; &gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= 0xfe;
&gt; &gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 24) &amp; 0xff;
&gt; &gt; +      ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 16) &amp; 0xff;
&gt; &gt; +    }
&gt; &gt; +    ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 8) &amp; 0xff;
&gt; &gt; +    ctx-&gt;tag.b[ctx-&gt;blen++] ^= (ctx-&gt;alen &gt;&gt; 0) &amp; 0xff;
&gt; &gt; +  }
&gt;
&gt; Is it possible to move this initial processing to ccm_set_nonce? The
&gt; alength *is* known there, and that would let you eliminate the ctx-&gt;blen
&gt; &lt; 0 cases, and maybe you could eliminate the alen state variable too (or
&gt; keep it for sanity checking only).

Yes, that could be done, but this operation requires the use of the cipher
encrypt function, which would need to be added to the set_nonce() API.

&gt;
&gt; &gt; +void
&gt; &gt; +ccm_digest(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
&gt; &gt; +        size_t length, uint8_t *digest)
&gt; &gt; +{
&gt; &gt; +  int i = CCM_BLOCK_SIZE - CCM_FLAG_GET_L(ctx-&gt;ctr.b[CCM_OFFSET_FLAGS]);
&gt;
&gt; Maybe it would be nicer to stick to a one-way encoding of the ctr block
&gt; (done by ccm_build_iv, if I understand correctly), and never decode that
&gt; format? One would need to store the needed information in some simpler
&gt; "uncoded" way in the ctx. That's a judgment call, adding redundant info
&gt; to the context is also a bit ugly.

Yes, this was a bit of a judgement call, whether it was uglier to store the
nonce length in the ctx, or to parse it out of the flags byte of the counter.
There are other possible ways to do this, but they all require extra storage
in the ctx, which I was hoping to avoid.

&gt;
&gt; &gt; +void
&gt; &gt; +ccm_encrypt_message(void *cipher, nettle_crypt_func *f,
&gt; &gt; +        size_t nlength, const uint8_t *nonce,
&gt; &gt; +        size_t alength, const uint8_t *adata,
&gt; &gt; +        size_t tlength, uint8_t *tag,
&gt; &gt; +         size_t mlength, uint8_t *dst, const uint8_t *src)
&gt; &gt; +{
&gt; &gt; +  struct ccm_ctx ctx;
&gt; &gt; +  ccm_set_nonce(&amp;ctx, nlength, nonce, alength, mlength, tlength);
&gt; &gt; +  ccm_update(&amp;ctx, cipher, f, alength, adata);
&gt; &gt; +  ccm_encrypt(&amp;ctx, cipher, f, mlength, dst, src);
&gt; &gt; +  ccm_digest(&amp;ctx, cipher, f, tlength, tag);
&gt; &gt; +}
&gt;
&gt; I think this function should append the tag to the ciphertext (assuming
&gt; ccm is specified as an aead with a single output string?).

CCM is indeed specified as an AEAD function with a single output string,
for example, RFC 5166 specifies that the ciphertext is always exactly 16
bytes longer than the plaintext, so this might be a good way to simplify
the function call API.

&gt;
&gt; &gt; +void
&gt; &gt; +ccm_decrypt_message(void *cipher, nettle_crypt_func *f,
&gt; &gt; +        size_t nlength, const uint8_t *nonce,
&gt; &gt; +        size_t alength, const uint8_t *adata,
&gt; &gt; +        size_t tlength, uint8_t *tag,
&gt; &gt; +         size_t mlength, uint8_t *dst, const uint8_t *src)
&gt; &gt; +{
&gt; &gt; +  struct ccm_ctx ctx;
&gt; &gt; +  ccm_set_nonce(&amp;ctx, nlength, nonce, alength, mlength, tlength);
&gt; &gt; +  ccm_update(&amp;ctx, cipher, f, alength, adata);
&gt; &gt; +  ccm_decrypt(&amp;ctx, cipher, f, mlength, dst, src);
&gt; &gt; +  ccm_digest(&amp;ctx, cipher, f, tlength, tag);
&gt; &gt; +}
&gt;
&gt; I think this function should have a tag *input* (possibly reading it at
&gt; te end of the cryptotext), compare it to the tag it computes, and return
&gt; 1 on success, 0 for failure.
&gt;
&gt; If the tag is appended to the cryptotext, I'm not sure if the mlength
&gt; should be the message length with or without the tag (i.e., the length
&gt; of the clear text message, or of the encrypted and authenticated
&gt; message).

In the language of the CCM publications, mlen is always the length of
the plaintext message. clen would be the length of the ciphertext, and
can always be determined by: clen = mlen + tlen

&gt;
&gt; Maybe it's best to let it be the length of the clear text message, same
&gt; as passed to ccm_encrypt_message. In any case, the caller must be aware
&gt; of both lengths.

Generally, I would prefer that the length provided should be the length of
data that actually gets written (ie: ciphertext in this case). If a naive
programmer using this API just passes buffer size as a sizeof() they
might miss that the encrypt function would write passed the end of the
buffer and cause an overflow.

&gt;
&gt; One *could* pass both message length, and derive the tag length as the
&gt; difference. But I'm afraid that style won't generalize nicely to other
&gt; aead algorithms.

I didn't see any similar functions for the EAX or CGM modes, so I'm not sure
that we really need to be concerned with breaking a precedent here.

&gt;
&gt; &gt; diff --git a/ccm.h b/ccm.h
&gt; &gt; new file mode 100644
&gt; &gt; index 0000000..76b4cc4
&gt; &gt; +/* Per-message state */
&gt; &gt; +struct ccm_ctx {
&gt; &gt; +  union nettle_block16 ctr;     /* Counter for CTR encryption. */
&gt; &gt; +  union nettle_block16 tag;     /* CBC-MAC message tag. */
&gt; &gt; +  uint64_t  alen; /* Length of adata set during the nonce generation. */
&gt; &gt; +  int       blen; /* &lt;0 on init or # of bytes since the last aligned block */
&gt; &gt; +};
&gt;
&gt; In nettle, length is usually not abbreviated to "len". If negative blen
&gt; values can be eliminated, it should be changed to unsigned.

I'll change the names accordingly with the next patch.

The negative value of blen is currently only used as a special value to
flag the first time that ccm_update() gets called so that we can
encrypt the IV to the CBC-MAC (B0) and generate the L(a). These
operations could be moved into ccm_set_nonce(), provided that
ccm_set_nonce() is also provided with the cipher encrypt function.

&gt;
&gt; &gt; --- /dev/null
&gt; &gt; +++ b/testsuite/ccm-test.c
&gt; &gt; +  /* Ensure we get the same answers using the all-in-one API. */
&gt; &gt; +  if (repeat &lt;= 1) {
&gt; &gt; +    memset(en_data, 0, len); memset(de_data, 0, len);
&gt; &gt; +    memset(en_digest, 0, tlen); memset(de_digest, 0, tlen);
&gt; &gt; +
&gt; &gt; +    ccm_encrypt_message(ctx, cipher-&gt;encrypt, nonce-&gt;length, nonce-&gt;data,
&gt; &gt; +        authdata-&gt;length, authdata-&gt;data, tlen, en_digest, len, en_data, cleartext-&gt;data);
&gt; &gt; +
&gt; &gt; +    ccm_decrypt_message(ctx, cipher-&gt;encrypt, nonce-&gt;length, nonce-&gt;data,
&gt; &gt; +        authdata-&gt;length, authdata-&gt;data, tlen, de_digest, len, de_data, ciphertext-&gt;data);
&gt;
&gt; If the all-in-one interface is changed as suggested above, adding a
&gt; return value for ccm_decrypt_message, one should also check that
&gt; ccm_decrypt_message returns 1 for the correct data, and 0 if any of
&gt; message, adata or or tag is corrupted.

Of course, I'll make sure that any changes to the API will be tested in the
ccm-test program.

Cheers,
Owen

</body></email><email><emailId>20140308172817</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-08 17:28:17-0400</timestampReceived><subject>Re: [PATCH] CCM Cipher Modes</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Owen Kirby is working on an implementation of the CCM mode. I'm
&gt; forwarding my comments here (with permission).

Ooops, I got bitten by the bad mailman configuration regarding
attachments. New attempt below. /Niels

Owen Kirby &lt;osk@exegin.com&gt; writes:

&gt; I've been looking at trying to add some of the AES-CCM mode cipher suites to GnuTLS.
&gt; It seemed like the best way to start would be to add support for them to nettle, and
&gt; this is what I've come up with so far.

Makes sense to me.

&gt; These cipher modes are a combination of a CTR encryption with a CBC-MAC, they are
&gt; technically an AEAD cipher mode, but there are some weird parameters that need to be
&gt; passed to the nonce function that make it unlikely to work well with the nettle_aead 
&gt; API.

I haven't looked carefully at CCM, I've only read the critique in the
eax paper (eax is also CTR-mode + CBC-mac, but in a better way,
according to the eax authors).

&gt; Let me know if you think these might be suitable for inclusion to nettle, or if there
&gt; is anything that you think needs to be changed.

I think it looks pretty good. Thanks!

Some initial comments below. I think it would make sense to discuss it
on the public nettle mailing list, in particular any interface issues.
Feel free to reply on-list. And if you don't object, I'd like to forward
this reply to the list.

If you make another revision of these patches, GNU-style ChangeLog
entries are also appreciated. And documentation, but it's probably good
to wait with that until any interface issues are sorted out.

&gt; --- /dev/null
&gt; +++ b/ccm-aes.c
&gt; @@ -0,0 +1,65 @@
&gt; +/* ccm-aes.c
&gt; + *
&gt; + * Counter with CBC-MAC mode, specified by NIST,
&gt; + */
&gt; +
&gt; +/* nettle, low-level cryptographics library
&gt; + *
&gt; + * Copyright (C) 2011 Niels Möller
&gt; + *
&gt; + * The nettle library is free software; you can redistribute it and/or modify
&gt; + * it under the terms of the GNU Lesser General Public License as published by
&gt; + * the Free Software Foundation; either version 2.1 of the License, or (at your
&gt; + * option) any later version.
&gt; + * 
&gt; + * The nettle library is distributed in the hope that it will be useful, but
&gt; + * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&gt; + * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
&gt; + * License for more details.
&gt; + * 
&gt; + * You should have received a copy of the GNU Lesser General Public License
&gt; + * along with the nettle library; see the file COPYING.LIB.  If not, write to
&gt; + * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
&gt; + * MA 02111-1301, USA.
&gt; + */
&gt; +
&gt; +#if HAVE_CONFIG_H
&gt; +# include "config.h"
&gt; +#endif
&gt; +
&gt; +#include "ccm.h"
&gt; +
&gt; +void
&gt; +ccm_aes_set_nonce(struct ccm_aes_ctx *ctx,
&gt; +        size_t length, const uint8_t *nonce,
&gt; +        size_t authlen, size_t msglen, size_t taglen)
&gt; +{
&gt; +  CCM_SET_NONCE(ctx, length, nonce, authlen, msglen, taglen);
&gt; +}

I don't think the ccm_aes family of functions are needed. ccm_aes128 etc
should be sufficient, and since it's a new feature, there's nothing to
be backwards compatible with.

&gt; --- /dev/null
&gt; +++ b/ccm.c
&gt; @@ -0,0 +1,210 @@
&gt; +/* ccm.h
&gt; + *
&gt; + * Counter with CBC-MAC mode, specified by NIST,
&gt; + * http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf
&gt; + *
&gt; + */
&gt; +
&gt; +/* nettle, low-level cryptographics library
&gt; + *
&gt; + * Copyright (C) 2011 Niels Möller
&gt; + * Copyright (C) 2011 Katholieke Universiteit Leuven
&gt; + * 
&gt; + * Contributed by Owen Kirby

I think we need to be a bit clearer about the copyright. We currently
don't do any copyright assignments for Nettle. I take it you wrote the
ccm implementation, so you own the copyright. Unless it's owned by your
employer or client? 

(BTW, I've been very sloppy with copyright headers in the test programs,
but it would be good with an accurate header also for ccm-test.c).

&gt; +/*
&gt; + * Because of the encoding of L(a), we have to handle input data that might
&gt; + * not be a multiple of the block size anyways, as such, we don't have the
&gt; + * input constraint of most AEAD modes that the intermediate calls to update()
&gt; + * must be in multiples of the block size.
&gt; + */
&gt; +void
&gt; +ccm_update(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
&gt; +	   size_t length, const uint8_t *data)

In nettle, the update functions usually accept arbitrary size, just like
you do. Complete blocks are only required for crypt functions.

&gt; +/*
&gt; + * Because of the underlying CTR mode encryption, when called multiple times
&gt; + * the data in intermediate calls must be provided in multiples of the block
&gt; + * size.
&gt; + */
&gt; +void
&gt; +ccm_encrypt(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
&gt; +	    size_t length, uint8_t *dst, const uint8_t *src)
&gt; +{
&gt; +  ccm_pad(ctx, cipher, f);
&gt; +  ccm_update(ctx, cipher, f, length, src);
&gt; +  ctr_crypt(cipher, f, CCM_BLOCK_SIZE, ctx-&gt;ctr.b, length, dst, src);
&gt; +}
&gt; +
&gt; +/*
&gt; + * Because of the underlying CTR mode decryption, when called multiple times
&gt; + * the data in intermediate calls must be provided in multiples of the block
&gt; + * size.
&gt; + */
&gt; +void
&gt; +ccm_decrypt(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
&gt; +	    size_t length, uint8_t *dst, const uint8_t *src)
&gt; +{
&gt; +  ctr_crypt(cipher, f, CCM_BLOCK_SIZE, ctx-&gt;ctr.b, length, dst, src);
&gt; +  ccm_pad(ctx, cipher, f);
&gt; +  ccm_update(ctx, cipher, f, length, dst);
&gt; +}
&gt; +void
&gt; +ccm_digest(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
&gt; +	   size_t length, uint8_t *digest)
&gt; +{
&gt; +  int i = CCM_BLOCK_SIZE - CCM_FLAG_GET_L(ctx-&gt;ctr.b[CCM_OFFSET_FLAGS]);
&gt; +  while (i &lt; CCM_BLOCK_SIZE)  ctx-&gt;ctr.b[i++] = 0;
&gt; +  ccm_pad(ctx, cipher, f);
&gt; +  ctr_crypt(cipher, f, CCM_BLOCK_SIZE, ctx-&gt;ctr.b, length, digest, ctx-&gt;tag.b);
&gt; +}

Are there any sanity checks that the lengths match the ones specified
with set_nonce?

&gt; --- /dev/null
&gt; +++ b/ccm.h
&gt; +/* Obnoxiously, CCM mode requires the adata and message lengths when
&gt; + * building the IV. This prevents any sort of streaming type API to
&gt; + * the cipher mode. We chose to put all of that cruft in the set_nonce()
&gt; + * function, so that the update/encrypt/decrypt and digest functions will
&gt; + * remain compatible with the nettle AEAD API.
&gt; + */
&gt; +void
&gt; +ccm_set_nonce(struct ccm_ctx *ctx, size_t noncelen, const uint8_t *nonce,
&gt; +        size_t authlen, size_t msglen, size_t taglen);

Are there any alternative ways to design this interface? E.g., one could
specify that for ccm, the update and encrypt/decrypt functions may be
called at most once for each message, with no possibility for streaming
or incremental processing. But that won't help if one needs *both*
lengths before processing either the message data or the associated
data.

The general aead interface should include some easy-to-use functions for
"all-in-one" processing of messages. It would be nice if ccm could be
made to fit into that framework sufficiently well to make such functions
work.

&gt; --- /dev/null
&gt; +++ b/testsuite/ccm-test.c

Thanks for including thorough tests. 

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140428074234</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-04-28 07:42:34-0400</timestampReceived><subject>Re: Side-channel silet memcmp</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; Yes, and a good function to add. One could think/hope that the OS
&gt; provided side channel silent memory functions.

Plain memcmp should be optimized for speed, I guess.

&gt; AFAIK (browsing the docs) there aren't any specific functions for
&gt; comparing digests. Instead the user has to implement thing themselves.

I also did a search for memcmp, and it's used in very few places inside
nettle (there are also bignum-comparisons, which may have similar
issues).

But applications are expected to compare digests, produced by some of
the mac or aead constructions, and they'd typically use plain memcmp. So
a side-channel silent variant should definitely be documented and
recom,ended for users.

I'm now thinking aloud, but maybe it would make sense to also change the
various digest functions to return the pointer to the digest? So one
could do, e.g.,

  if (mem_equal (hmac_sha256_digest(...), expected, SHA1_DIGEST_SIZE))
    ...;

or even

  #define DIGEST_EQUAL(ctx, f, size, buf, expected) \
    mem_equal(f(ctx, size, buf), expected, size)

(I'm not saying that macro is a good idea, but returning the pointer
makes such things simpler).

Or one could add a corresponding _verify function for each _digest
function, which takes the expected digest as input. Not sure that's a
good idea. That would be a pretty large number of functions, but if it
makes applications simpler, it could be worth the effort.

&gt; uint8_t compare_digests(uint8_t *digest0, uint8_t *digest1, uint8_t
&gt; *DIGEST_SIZE);

That looks similar to the mem_equal I sketched, except that the third
argument looks strange. Was that intentional?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140428074721</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-04-28 07:47:21-0400</timestampReceived><subject>Re: Side-channel silet memcmp</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Why not nettle memcmp?

I think "memcmp" should be avoided in the name, because (1) the memcmp
return value distinguishes between &gt; and &lt;, while the side-channel
silent comparison function should check only for equality, and (2) even
if the link symbol should be nettle_something, it would be nice if the
corresponding header file providea a name without any nettle prefix, and
then it's not good to collide with the standard memcmp.

&gt; It would be good to export those functions as
&gt; there are not typically available and each program re-invents them

Definitely.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140320172142</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-03-20 17:21:42-0400</timestampReceived><subject>[PATCH] Add support for SHA-512-224 and SHA-512-256 in sha2.h</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIcBAEBCAAGBQJTKyOmAAoJEF3cfFQkIuyN5vUQALrR22ghkKs0KW4+oqD1z8iQ
+VHXY/wyKpgXXVHvklcfRakmmMC/TcTF4NVbhCZhd/htvISOuCo/UAohUjA9p3Q7
m2nX9Xs9Wo1h0Ysj9LSZNYjEAx74+zqauMPZ9btZcIiAh4jdjKYb0TZJq47Tuots
DY6am6rQF+yATk+SwxDSxxXdfB64wG5w+MSC/Hbb5snpa4T1mZheJ7AIt14icOBx
U5E60k3GrTmw7zpBN0MUg68Ex9gxtyePxFlsTasy7C/bzFXPXbkcZaaLndvaznCe
lUy0w7NNXQZJdzEdzmF6eVzZB7stTVffK8eC7mbEbmTBJYg9tHvelmPJeRw1+oeT
WNYAOxkX6I61B+OF7WvLwT0x0QgD6Y6QpYoyRzuYyKKsHTSo+qH0C0LaMdX0YJfB
ynxc7mrdPHXFS/OrEPRNzKrbwcGYchXDctH0bb8NuQ56w9ZyP6/MxfublSbAIlXU
jj6FUtTIQvTinI/P8FCS0pzGGuNfyjZOF4Ur73DMll5nATqMeQ0Oot1FXq56sz4a
GkAgdNp+Ehq13ezaWbUz8aBs/kYIMT7tyuK6hMuqbkYPw9FuG4cBCyVne47GOjGC
pTJp2HWKLYiKgpUNd0Vb2NFXDIZb+Psy0YcuuWFchWWm9PxvGoYba3qDvZDtkuOU
X+Y5NpECTZQ8iePlhq+u
=E9gN
-----END PGP SIGNATURE-----

["patch_fips180-4_sha2.h" (text/plain)]

46a47,52
&gt; #define sha512_224_init   nettle_sha512_224_init
&gt; #define sha512_224_digest nettle_sha512_224_digest
&gt; #define sha512_256_init   nettle_sha512_256_init
&gt; #define sha512_256_digest nettle_sha512_256_digest
&gt; 
&gt;   
128c134,135
&lt; 
---
&gt;   
&gt;   
151a159,177
&gt; 
&gt; /* SHA512_224 and SHA512_256, two truncated versions of SHA512 
&gt; with different initial states. */
&gt; void
&gt; sha512_224_init(struct sha512_ctx *ctx);
&gt; 
&gt; void
&gt; sha512_224_digest(struct sha512_ctx *ctx,
&gt;                   size_t length,
&gt;                   uint8_t *digest);
&gt; 
&gt; void
&gt; sha512_256_init(struct sha512_ctx *ctx);
&gt; 
&gt; void
&gt; sha512_256_digest(struct sha512_ctx *ctx,
&gt;                   size_t length,
&gt;                   uint8_t *digest);
&gt;   


</body></email><email><emailId>20140428075656</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-04-28 07:56:56-0400</timestampReceived><subject>Re: Side-channel silet memcmp</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

Niels Möller wrote:
&gt; That looks similar to the mem_equal I sketched, except that the
&gt; third argument looks strange. Was that intentional?

Very much not so. ;-)
A plain, unsigned integer was the atention. But my copy/paste fingers
were a wee bit faster than the brain.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIcBAEBCAAGBQJTXgnIAAoJEF3cfFQkIuyNHjQQAMSzsmWc+algXEsW+S3RpgGo
NBqQWSD65OCdsxiZcGCjL4QrhT2xi8ZulaSw/CJflXep2AUzSDCqrvkDMv9h4vzK
X2S9Wa9QA3TVU2cXoJoBZTnDdYw4oVmaQ3KRwa0cBLE2HwrAHIuK8n3IExL4wb7/
x1WCL24eZ5xsHmzuRS3CMyHDZszyeetycnUfIXrE18QICXTNDnw2/ZkZPmTsRW94
5vUl+fu58ha0+i13IHkf2GecBlrZA5Dnhfcxmh8ukp11TlIgtBvb9QMvays0hp+P
7L8VREHtlnGUWXcN+QfqjUuqEI/QcDqSRggUwG+14TFP67VYkrjnpVroP5UEpVxW
s2mR5lUKLWKzTSA5sPlFWFqiO6EFsrHma8ub8+TNHLY+ziwWzcAX8qKTpkFCW9Xq
z8q5xaCfdqv6l08IQDsc6Z6wFIZh4UQaZsbiGP5rWwHUTsZlhrjN2IVL94mUxJq2
LHDWFrQpuXQFgKmD1prAj4thWOKE6LLWO/MROvDXKb+1vca6HrZc9r7uzDK/c9Ok
w3FoxtbcfWR4f0C8JvkB1+h7x8u9oaufSMxLVG1MOMp1cE9psPLaE33QQNmL64IR
Z9ipNRpKxC+5wx0Zrep0HM/ZpD5d1R28KKUyg9VlLxZ6pxJ43bCVY+FllYc1dCOC
oUGV1buV1Ozcz4ydj+NT
=712C
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140428080046</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-04-28 08:00:46-0400</timestampReceived><subject>Re: Side-channel silet memcmp</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

Niels Möller wrote:
&gt; Plain memcmp should be optimized for speed, I guess.

Maybe. I wouldn't be surprised if the OpenBSD folks would think it would
be an acceptable performance cost to make it more side channel silent.
Or at least provide a silent version om memcmp.

I'm actually gonna check - their fork of OpenSSL should probably be
using something like that.

Nikos - What do you do in GnuTLS?

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIcBAEBCAAGBQJTXgquAAoJEF3cfFQkIuyN0c8QAKfj+EdVSEOBbUfiGv5xfDV7
ZLc4ND7brq8nxVsULXw9p39wONdvWJWEis/xBHo/k8MzqvUfGF6rmbE0ITKKfy+k
hD/QJaWnWUg0lXfAZ9XZ+UDk8VqoM+uYst04kHwYsXVlK/wN43QIMzyXQa/OojIx
3safvtxMPQUjbrI7JwKhXWdwitmI/kR/aqB2ACZPvnxK1zkaqwzYtUd7+2+ocGqJ
IcWy7nOJRgel7LoKPdf+AYkZuIV9/MYoIDZDEJNK2PU1kYf3f+6NNsjXvkijIxEk
47AaZ6mPA86ezRHg2bMFqUiglVP5e6ikufRTMREMbXxNIv8RGQfGFS3dQivIc2n7
x5GijjDToooI7xYfH2DaqkTIRZlK4Tg0UX/usxLT7lmNDLnw8RWWwuVxVygXF2Rp
WP4TqPEsw74Mcwlt+dyekmeaHg6e0LcB0Trx/bHkJmT10UXoVTLTpbAL61e3cES7
EwVygspIQpd58oQgsmwKO84DSpkdCZrJOeja+jsg+iCp4IrLZ6UbEXpz6xBNKvdJ
Z6uVWO4uM13hqxh+m7PEY4t4vELByXc8U+Cm+a/jcxrGgIxCKq40eCP9V0NfGj4h
266pO5hA5CXaDef6UG5P8ucTpHT2LIwSn51E9J4JTOrbApK66REdlNN60NT+7Jdl
IUDgYKwbfUTCyVHS7v2A
=eZer
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140411182944</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2014-04-11 18:29:44-0400</timestampReceived><subject>Re: Feature removals</subject><body>


On 04/11/2014 01:49 PM, Niels Möller wrote:
&gt; I'm considering removing the following features:
&gt; 
&gt; * des-compat.h and all its functions. This provides some level of
&gt;   compatiblity with libdes (and possibly also old versions of
&gt;   openssl/ssleay). I've not heard of anyone actually using this.


i don't know who is actually using this from nettle, but it looks like
there are lots of programs that are either embedding libdes or relying
on other packages like krb5 for something that looks roughly like a
linked libdes.

emacs is just one of these.  lsh-utils also appears to want something to
do with libdes.  Niels, maybe you can say what that's doing?

I'm not a big fan of des, and i'm certainly no emacs developer;   But if
we could let emacs use nettle's version easily without needing to rely
on non-GNU code for anything it needs DES for that would be nice.

that said, i haven't found anyone who *is* using this compatibility
layer in nettle, so i think if you want to drop it and be willing to add
it back if someone complains that'd be fine.

&gt; * rsa-compat.h and all its functions. Compatibility with RSAREF. I've
&gt;   never heard of anyone actually using this either.
&gt; 
&gt; * The nettle_next_prime function. No longer used internally in Nettle's
&gt;   key generation functions, and applications should use the
&gt;   corresponding GMP function instead.

i just scanned everything in debian for these two and they seem unused
to me:

http://codesearch.debian.net/search?q=R_SignInit
http://codesearch.debian.net/search?q=R_VerifyInit
http://codesearch.debian.net/search?q=nettle_next_prime

i say drop of these last two.

thanks for doing the maintenance work here.

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20140411192801</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-04-11 19:28:01-0400</timestampReceived><subject>Re: Feature removals</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; On 04/11/2014 01:49 PM, Niels Möller wrote:
&gt;&gt; I'm considering removing the following features:
&gt;&gt; 
&gt;&gt; * des-compat.h and all its functions. This provides some level of
&gt;&gt;   compatiblity with libdes (and possibly also old versions of
&gt;&gt;   openssl/ssleay). I've not heard of anyone actually using this.
&gt;
&gt;
&gt; i don't know who is actually using this from nettle, but it looks like
&gt; there are lots of programs that are either embedding libdes or relying
&gt; on other packages like krb5 for something that looks roughly like a
&gt; linked libdes.

Might make some sense to keep it, then. But it would be nice with some
confirmation that it really is a working substitute for some of those
programs.

&gt; emacs is just one of these.  lsh-utils also appears to want something to
&gt; do with libdes.  Niels, maybe you can say what that's doing?

Don't know about emacs, but lsh definitely shouldn't be using libdes. It
uses triple-des via an object defined in
https://git.lysator.liu.se/lsh/lsh/blobs/master/src/crypto.c, on top of
Nettle. Or possibly the krb password hack
(https://git.lysator.liu.se/lsh/lsh/blobs/master/src/lsh-krb-checkpw.c)
uses libdes indirectly?

&gt; i just scanned everything in debian for these two and they seem unused
&gt; to me:
&gt;
&gt; http://codesearch.debian.net/search?q=R_SignInit
&gt; http://codesearch.debian.net/search?q=R_VerifyInit
&gt; http://codesearch.debian.net/search?q=nettle_next_prime
&gt;
&gt; i say drop of these last two.

Nice tool. I just tried

http://codesearch.debian.net/search?q=des_ede2_cbc_encrypt
http://codesearch.debian.net/search?q=des_ede3_cbc_encrypt

(the functions in des-compat.h that seems most likely to be useful).
Gives a dozen or two of matches. Besides openssl itself, most are in
cyrus-sasl2. It's not clear to me if the matches indicates actual use.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140530193739</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-30 19:37:39-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt; The only thing I'd expect is a call through an indirect address, since
&gt; you are linking to a DLL.  But the above doesn't look like that.

There's some magic going on. Or lack thereof. The calling function does

&gt;&gt;   4014e9:       e8 b2 6c 00 00          call   4081a0 &lt;__imp__nettle_arcfour_crypt&gt;&gt;

(this is from disssembling the .exe file).

And then at address 4081a0, there's

004081a0 &lt;__imp__nettle_arcfour_crypt&gt;:
  4081a0:       98                      cwtl
  4081a1:       82                      (bad)
	...

This is not in the .text section, but in the .idata section. And in the
.idata, there's

The Import Tables (interpreted .idata section contents)
 vma:            Hint    Time      Forward  DLL       First
                 Table   Stamp     Chain    Name      Thunk
 00008000       000080b4 00000000 00000000 00008698 0000819c

        DLL Name: libnettle-5-0.dll
        vma:  Hint/Ord Member-Name Bound-To
        827c       59  nettle_arcfour128_set_key
        8298       60  nettle_arcfour_crypt

So it looks like the data at __imp__nettle_arcfour_crypt is not code,
but the dll index 8292.

If I compare with the code I get if I configure nettle with
--disable-assembler, I get a

  4014b8:       e8 2b 1a 00 00          call   402ee8 &lt;_nettle_arcfour_crypt&gt;

00402ee8 &lt;_nettle_arcfour_crypt&gt;:
  402ee8:       ff 25 34 81 40 00       jmp    *0x408134
  402eee:       90                      nop
  402eef:       90                      nop

So it seems the linker does something very different (and more correct)
in this case.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140530195840</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2014-05-30 19:58:40-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Cc: nettle-bugs@lists.lysator.liu.se
&gt; Date: Fri, 30 May 2014 21:37:39 +0200
&gt; 
&gt; Eli Zaretskii &lt;eliz@gnu.org&gt; writes:
&gt; 
&gt; &gt; The only thing I'd expect is a call through an indirect address, since
&gt; &gt; you are linking to a DLL.  But the above doesn't look like that.
&gt; [...]
&gt; If I compare with the code I get if I configure nettle with
&gt; --disable-assembler, I get a
&gt; 
&gt;   4014b8:       e8 2b 1a 00 00          call   402ee8 &lt;_nettle_arcfour_crypt&gt;
&gt; 
&gt; 00402ee8 &lt;_nettle_arcfour_crypt&gt;:
&gt;   402ee8:       ff 25 34 81 40 00       jmp    *0x408134
&gt;   402eee:       90                      nop
&gt;   402eef:       90                      nop

That jmp instruction is the indirect call I was talking about.  This
is how the Windows loader resolves calls into a DLL.  If you "stepi"
into that instruction with GDB, you will find yourself inside the
function in the DLL.

</body></email><email><emailId>20140531061802</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-31 06:18:02-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt; That jmp instruction is the indirect call I was talking about.  This
&gt; is how the Windows loader resolves calls into a DLL.  If you "stepi"
&gt; into that instruction with GDB, you will find yourself inside the
&gt; function in the DLL.

This all makes sense. The problem is, why this doesn't happen when using
the assembly version in x86/arcfour-crypt.asm. I guess I will have to
compare pseudoops and symbol table attributes between working and
non-working case to find out. Unless someone here already knows the
answer.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140531064043</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2014-05-31 06:40:43-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Cc: nettle-bugs@lists.lysator.liu.se
&gt; Date: Sat, 31 May 2014 08:18:02 +0200
&gt; 
&gt; Eli Zaretskii &lt;eliz@gnu.org&gt; writes:
&gt; 
&gt; &gt; That jmp instruction is the indirect call I was talking about.  This
&gt; &gt; is how the Windows loader resolves calls into a DLL.  If you "stepi"
&gt; &gt; into that instruction with GDB, you will find yourself inside the
&gt; &gt; function in the DLL.
&gt; 
&gt; This all makes sense. The problem is, why this doesn't happen when using
&gt; the assembly version in x86/arcfour-crypt.asm.

Did you try declaring the prototype of that function with
'__attribute__((dllexport))' when compiling the DLL, and with
'__attribute__((dllimport)' when linking against the DLL?

</body></email><email><emailId>20140531071807</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-31 07:18:07-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt; Did you try declaring the prototype of that function with
&gt; '__attribute__((dllexport))' when compiling the DLL, and with
&gt; '__attribute__((dllimport)' when linking against the DLL?

No. But I think I've found a solution. I need to do like gcc and add

        .def    _nettle_arcfour_crypt;  .scl    2;      .type   32; .endef

in the assembly file. 32 is DT_FCN (see
http://www.delorie.com/djgpp/doc/coff/symtab.html). Without this, I get
T_NULL instead, and that somehow works with thatic linking but not wth
dynamic linking. Now I only have to get configure to set this up
correctly.

Some questions remain. Why didn't the other tests of functions with
assembly implementation, in particular md5-test and sha1-test, fail in
the same way?

Regards,
/Niels
        
-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140531072246</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-31 07:22:46-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Some questions remain. Why didn't the other tests of functions with
&gt; assembly implementation, in particular md5-test and sha1-test, fail in
&gt; the same way?

Hmm. That's most likely because the involved assembly function,
_nettle_md5_compress, is called from within the dll, and not directly
from md5-test.exe.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140531074044</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2014-05-31 07:40:44-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

&gt; Date: Fri, 30 May 2014 18:47:37 +0300
&gt; From: Eli Zaretskii &lt;eliz@gnu.org&gt;
&gt; Cc: nettle-bugs@lists.lysator.liu.se
&gt; 
&gt; &gt; Is it possible for you to do a git checkout?
&gt; 
&gt; Yes.
&gt; 
&gt; &gt; For the cross-compile case, it would be
&gt; &gt; 
&gt; &gt;   git clone git://git.lysator.liu.se/nettle/nettle.git
&gt; &gt;   cd nettle
&gt; &gt;   ./.bootstrap
&gt; &gt;   ./configure --host=i586-mingw32msvc
&gt; &gt;   make
&gt; &gt;   make -C testsuite arcfour-test.exe
&gt; &gt; 
&gt; &gt; and then copy .lib/libnettle-5-0.dll and testsuite/arcfour-test.exe to
&gt; &gt; the windows test machine.
&gt; &gt; 
&gt; &gt; For native compile, instead ./configure &amp;&amp; make dist to produce a
&gt; &gt; tarball.
&gt; 
&gt; OK, I'll see what I can find out.

I can confirm that the shared-library version crashes on Windows.
More accurately, Windows refuses to run the test program, it pops up
an error dialog saying "The application failed to initialize properly
(0xc0000005). Click on OK to terminate the application."  From what I
gather by googling, this is indeed a sign of some kind of snafu with
DLLs.  I did verify that the arcfour-test.exe executable is linked
against the correct libnettle-5.dll (I have a prior version installed
on PATH).

If I configure with --disable-shared, the test program runs
successfully.

Let me know if I can help you further.

</body></email><email><emailId>20140531075818</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-31 07:58:18-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt; I can confirm that the shared-library version crashes on Windows.

Thanks for testing. Just so I know, was that a native build or did you
cross compile?

&gt; Let me know if I can help you further.

Hopefully, there should be a new version later today.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140531082732</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2014-05-31 08:27:32-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Cc: nettle-bugs@lists.lysator.liu.se
&gt; Date: Sat, 31 May 2014 09:58:18 +0200
&gt; 
&gt; Eli Zaretskii &lt;eliz@gnu.org&gt; writes:
&gt; 
&gt; &gt; I can confirm that the shared-library version crashes on Windows.
&gt; 
&gt; Thanks for testing. Just so I know, was that a native build or did you
&gt; cross compile?

Native.  Except that I didn't "make dist", but instead ran these
commands directly in the git repo on Windows, after cloning it
("d:/usr" is where I keep my root of a Posix-like directory tree):

  $ ./.bootstrap
  $ ./configure --prefix=d:/usr
  $ make
  $ make -C testsuite arcfour-test.exe
  $ cd testsuite &amp;&amp; make check TS_ALL=arcfour-test.exe

&gt; &gt; Let me know if I can help you further.
&gt; 
&gt; Hopefully, there should be a new version later today.

OK, I will try that when it's available.

</body></email><email><emailId>20140531115455</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-31 11:54:55-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt;&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt;&gt; Hopefully, there should be a new version later today.
&gt;
&gt; OK, I will try that when it's available.

I just pushed a fix to the git repo. 32-bit windows builds, with shared
libraries, now work for me, using the mingw cross compiler and wine for
testing. (I'll check status of 64-bit wine in debian, last time I looked
it didn't work out of the box).

It would be great if you could test it, both for 32-bit and 64-bit
windows.

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140531165932</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2014-05-31 16:59:32-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Cc: nettle-bugs@lists.lysator.liu.se
&gt; Date: Sat, 31 May 2014 13:54:55 +0200
&gt; 
&gt; Eli Zaretskii &lt;eliz@gnu.org&gt; writes:
&gt; 
&gt; &gt;&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; &gt;&gt; Hopefully, there should be a new version later today.
&gt; &gt;
&gt; &gt; OK, I will try that when it's available.
&gt; 
&gt; I just pushed a fix to the git repo. 32-bit windows builds, with shared
&gt; libraries, now work for me, using the mingw cross compiler and wine for
&gt; testing. (I'll check status of 64-bit wine in debian, last time I looked
&gt; it didn't work out of the box).
&gt; 
&gt; It would be great if you could test it, both for 32-bit and 64-bit
&gt; windows.

Sorry, it still crashes for me in the same way.

I will try with another (newer) GCC version tomorrow.

Is it possible that some other dependency is screwing this up?  E.g.,
I see that libgmp is required -- which version of GMP is needed for
this version of nettle?  I have v5.0.2 here.

</body></email><email><emailId>20140531190155</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-31 19:01:55-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt; Sorry, it still crashes for me in the same way.

That's disappointing... Does the new configure test work right for you?
You should get

  define(&lt;ELF_STYLE&gt;, &lt;no&gt;)dnl
  define(&lt;COFF_STYLE&gt;, &lt;yes&gt;)dnl

in config.m4, and a prologue like

  .globl _nettle_arcfour_crypt
  .def _nettle_arcfour_crypt
  .scl 2
  .type 32
  .endef
  _nettle_arcfour_crypt:

in the preprocessed assembler files, e.g, arcfour-crypt.s.

For me, objdump -t arcfour-crypt.o now says

  [  2](sec  1)(fl 0x00)(ty  20)(scl   2) (nx 1) 0x00000000 _nettle_arcfour_crypt

where the value for "ty" is important.

&gt; Is it possible that some other dependency is screwing this up?  E.g.,
&gt; I see that libgmp is required -- which version of GMP is needed for
&gt; this version of nettle?  I have v5.0.2 here.

I think 5.0.2 should work fine. If you want to exclude this potential
source of error, you can reconfigure with --disable-public-key.

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140531192057</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2014-05-31 19:20:57-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Cc: nettle-bugs@lists.lysator.liu.se
&gt; Date: Sat, 31 May 2014 21:01:55 +0200
&gt; 
&gt; Eli Zaretskii &lt;eliz@gnu.org&gt; writes:
&gt; 
&gt; &gt; Sorry, it still crashes for me in the same way.
&gt; 
&gt; That's disappointing... Does the new configure test work right for you?
&gt; You should get
&gt; 
&gt;   define(&lt;ELF_STYLE&gt;, &lt;no&gt;)dnl
&gt;   define(&lt;COFF_STYLE&gt;, &lt;yes&gt;)dnl
&gt; 
&gt; in config.m4

That's what I get, yes.

&gt; and a prologue like
&gt; 
&gt;   .globl _nettle_arcfour_crypt
&gt;   .def _nettle_arcfour_crypt
&gt;   .scl 2
&gt;   .type 32
&gt;   .endef
&gt;   _nettle_arcfour_crypt:
&gt; 
&gt; in the preprocessed assembler files, e.g, arcfour-crypt.s.

I don't have this file; how do I create it?

&gt; For me, objdump -t arcfour-crypt.o now says
&gt; 
&gt;   [  2](sec  1)(fl 0x00)(ty  20)(scl   2) (nx 1) 0x00000000 _nettle_arcfour_crypt
&gt; 
&gt; where the value for "ty" is important.

I have this line in objdump's output, but it says

  [ 24](sec  0)(fl 0x00)(ty  20)(scl   2) (nx 0) 0x00000000 _nettle_arcfour_crypt

Are the differences between these two lines significant?

&gt; &gt; Is it possible that some other dependency is screwing this up?  E.g.,
&gt; &gt; I see that libgmp is required -- which version of GMP is needed for
&gt; &gt; this version of nettle?  I have v5.0.2 here.
&gt; 
&gt; I think 5.0.2 should work fine. If you want to exclude this potential
&gt; source of error, you can reconfigure with --disable-public-key.

That fixed the problem, so it must have been unrelated to the one you
needed to (and did) solve.  Not sure why libgmp I have caused trouble,
I will look into that later.

Thanks.

</body></email><email><emailId>20140531194815</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-05-31 19:48:15-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt;&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt;&gt; You should get
&gt;&gt; 
&gt;&gt;   define(&lt;ELF_STYLE&gt;, &lt;no&gt;)dnl
&gt;&gt;   define(&lt;COFF_STYLE&gt;, &lt;yes&gt;)dnl
&gt;&gt; 
&gt;&gt; in config.m4
&gt;
&gt; That's what I get, yes.

Good.

&gt;&gt; in the preprocessed assembler files, e.g, arcfour-crypt.s.
&gt;
&gt; I don't have this file; how do I create it?

It should be created in the build dir, as an intermediate step between
.asm and .o. And appropriate .asm files are linked into the build dir by
configure.

&gt;&gt; For me, objdump -t arcfour-crypt.o now says
&gt;&gt; 
&gt;&gt;   [  2](sec  1)(fl 0x00)(ty  20)(scl   2) (nx 1) 0x00000000 _nettle_arcfour_crypt
&gt;&gt; 
&gt;&gt; where the value for "ty" is important.
&gt;
&gt; I have this line in objdump's output, but it says
&gt;
&gt;   [ 24](sec  0)(fl 0x00)(ty  20)(scl   2) (nx 0) 0x00000000 _nettle_arcfour_crypt
&gt;
&gt; Are the differences between these two lines significant?

I guess not, but I don't know for sure.

Actually, "(sec 1)" in my build looks a bit suspicious, because
according to objdump -x, section 1 is .data, and .text is section 0.

&gt;&gt; I think 5.0.2 should work fine. If you want to exclude this potential
&gt;&gt; source of error, you can reconfigure with --disable-public-key.
&gt;
&gt; That fixed the problem, so it must have been unrelated to the one you
&gt; needed to (and did) solve.  Not sure why libgmp I have caused trouble,
&gt; I will look into that later.

In my windows cross-build, I don't have gmp available. I could try to
cross build gmp too, to try to reproduce the problem, but probably not
soon. If you wan't to track it down, it might be a good idea to first
upgrade to gmp-6.

When you configure nettle with --disable-public-key, do both 32-bit and
64-bit windows builds work?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140531195420</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2014-05-31 19:54:20-0400</timestampReceived><subject>Re: Problem with w32 shared libraries</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Cc: nettle-bugs@lists.lysator.liu.se
&gt; Date: Sat, 31 May 2014 21:48:15 +0200
&gt; 
&gt; In my windows cross-build, I don't have gmp available. I could try to
&gt; cross build gmp too, to try to reproduce the problem, but probably not
&gt; soon. If you wan't to track it down, it might be a good idea to first
&gt; upgrade to gmp-6.

I will try.

&gt; When you configure nettle with --disable-public-key, do both 32-bit and
&gt; 64-bit windows builds work?

Only 32-bit.  I don't have a 64-bit development environment here.

</body></email><email><emailId>20140304172224</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-03-04 17:22:24-0400</timestampReceived><subject>Re: chacha set-key naming</subject><body>

On Tue, Mar 4, 2014 at 3:23 PM, Stefan B=FChler &lt;nettle-bugs@stbuehler.de&gt; =
wrote:

&gt;&gt; It has not been approved yet, but the latest TLS proposal for chacha
&gt;&gt; is with 96-bit nonces and there is no plan to change. So at least for
&gt;&gt; gnutls only the 96-bit nonce version is relevant.
&gt; I did propose using XChaCha (similar to XSalsa20) to support larger
&gt; nonces (especially the AEAD recommended 96-bit length), and sticking
&gt; with plain ChaCha for 64-bit nonces (and allowing them):
&gt; http://www.ietf.org/mail-archive/web/cfrg/current/msg04310.html
&gt; There should have been a CFRG meeting yesterday, and perhaps it was
&gt; discussed, but I didn't get any feedback on it yet.
&gt; If anyone (Nikos?) can report on that I'd be glad to hear about it :)

Unfortunately I was not there and did not follow the CFRG meeting. I,
however, followed (online) the summary of the meeting by David Mcgrew
in the TLS WG and the naming wasn't mentioned. The situation on the
naming and the exact algorithm details will most probably clear up
next month when CFRG provides input to the TLS WG on the chacha
cipher.

regards,
Nikos

</body></email><email><emailId>20140308174407</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-08 17:44:07-0400</timestampReceived><subject>Re: [PATCH] CCM Cipher Modes</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Owen Kirby &lt;osk@exegin.com&gt; writes:

&gt;&gt; --- /dev/null
&gt;&gt; +++ b/ccm.h
&gt;&gt; +/* Obnoxiously, CCM mode requires the adata and message lengths when
&gt;&gt; + * building the IV. This prevents any sort of streaming type API to
&gt;&gt; + * the cipher mode. We chose to put all of that cruft in the set_nonce()
&gt;&gt; + * function, so that the update/encrypt/decrypt and digest functions will
&gt;&gt; + * remain compatible with the nettle AEAD API.
&gt;&gt; + */
&gt;&gt; +void
&gt;&gt; +ccm_set_nonce(struct ccm_ctx *ctx, size_t noncelen, const uint8_t *nonce,
&gt;&gt; +        size_t authlen, size_t msglen, size_t taglen);
&gt;
&gt; Are there any alternative ways to design this interface? E.g., one could
&gt; specify that for ccm, the update and encrypt/decrypt functions may be
&gt; called at most once for each message, with no possibility for streaming
&gt; or incremental processing. But that won't help if one needs *both*
&gt; lengths before processing either the message data or the associated
&gt; data.

It looks like that isn't possible. Reading the code (I haven't read the
spec yet), it seems like the message length must be known before
processing of the associated data.

However we decide to do the incremental interface for CCM, I think it
would be good to also provide an all-in-one function, something like

void
ccm_encrypt_message (void *cipher_ctx, nettle_crypt_func *f,
                     size_t nonce_length, const uint8_t *nonce,
                     size_t adata_length, const uint8_t *adata,
		     size_t tag_length,
		     size_t msg_length, uint8_t *dst, const uint8_t *src);

/* Return 1 on success, 0 on authentication failure */
int
ccm_decrypt_message (void *cipher_ctx, nettle_crypt_func *f,
                     size_t nonce_length, const uint8_t *nonce,
                     size_t adata_length, const uint8_t *adata,
		     size_t tag_length,
		     size_t msg_length, uint8_t *dst, const uint8_t *src);

(since CCM doesn't quite fit in Nettle's aead framework, it can't easily
use any general construction on top of that framework). But there are
usecases where incremental processing is desired. E.g, processing a
large file (size limited to 16 MB - 1 byte with RFC 5116 parameters for
CCM, so maybe not *extremely* large), where you could know the size in
advance, e.g., from stat(2), but still might want to do the processing
with an i/o buffer in memory limited to, say, 64 KB.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140310082851</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-03-10 08:28:51-0400</timestampReceived><subject>nettle-mini</subject><body>

Hello,
 I have put in
https://github.com/nmav/nettle-mini/tree/gmp-mini
a version of nettle that has an additional configure option. The
--enable-mini-gmp. This will compile libghoweed using mini-gmp thus
allowing nettle to be used in space constrained systems. Note that
using nettle with mini-gmp instead of gmp imposes a penalty of around
10x, and may leak more information due to side-channels (this should
not be the case for RSA as blinding is performed in hogweed, but I
haven't checked the other algorithms).

regards,
Nikos

</body></email><email><emailId>20140314074554</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-03-14 07:45:54-0400</timestampReceived><subject>Re: dsa_generate_keypair</subject><body>

On Thu, Mar 13, 2014 at 11:22 AM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wro=
te:
&gt; These functions now take the parameters separately. One could get
&gt; something more in style with the the old interface by defining
&gt;   #define dsa_sign(pub, key, [...]) dsa_sign(&amp;pub-&gt;params, key-&gt;x, [...])
&gt;   #define dsa_verify(pub, [...]) dsa_verify(&amp;pub-&gt;params, pub-&gt;y, [...])

Hello,
 It would be nice if the new interface is api compatible with the old
one; especially if that would be possible with macros such as the one
you show, so that compatibility bloat doesn't need to be included in
the library.

&gt; It seems reasonable to provide one key generation function which also
&gt; generates parameters, and one key generation function which takes fixed
&gt; parameters as argument. Any suggestion for naming? For compatibility, it
&gt; would be preferable to keep dsa_generate_keypair unchanged, and invent a
&gt; new name for the function above.
&gt;   /* Convenience structs, close to the interface used in nettle-2.7.x
&gt;      and earlier. */
&gt;   struct dsa_public_key
&gt;   {
&gt;     struct dsa_params params;
&gt;     /* Public value */
&gt;     mpz_t y;
&gt;   };
&gt; This is essentially the same struct as in earlier versions, but it wraps
&gt; the parameters in a struct, so it's an API change. I think this is the
&gt; sane way to do it, if this is viewed as an interface to be supported in
&gt; future versions, and not just something retained for backwards
&gt; compatibility.

I thought that this was used to keep API compatibility. I don't think
it makes sense to introduce new APIs that are close to old APIs. There
is already a new API.

&gt;   int
&gt;   dsa_generate_keypair_old(struct dsa_public_key *pub,
&gt;                          struct dsa_private_key *key,
&gt;
&gt;                          void *random_ctx, nettle_random_func *random,
&gt;                          void *progress_ctx, nettle_progress_func *progre=
ss,
&gt;                          unsigned p_bits, unsigned q_bits);
&gt; As said above, there's a naming issue here. I think it would be nice to
&gt; keep this function with name and prototype unchanged.

If old sources can be compiled with no changes, I agree it should keep
the same name. If not, I don't see many advantages of keeping an API
that looks like the old but is not compatible with it. It will take up
space, and require maintaining more code.

regards,
Nikos

</body></email><email><emailId>20140317085005</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-17 08:50:05-0400</timestampReceived><subject>Re: [PATCH v2] CCM Cipher Modes</subject><body>

Owen Kirby &lt;osk@exegin.com&gt; writes:

&gt; The Input to the CBC-MAC used in CCM mode takes the form:
&gt; L(adata) | adata | padding | plaintext | padding

[...]

&gt; In other words,
&gt; blen is the length of data input to the CBC-MAC modulus the block size.

[...]

&gt; Once we find the end of the adata (this is currently done on the first call to
&gt; ccm_encrypt() or ccm_decrypt()), we need to insert the padding before the
&gt; plaintext, which is what ccm_pad() does.

Thanks for the explanations. Might make sense to add a comment saying
that when ccm_pad is called from _encrypt/_decrypt, all but the first
calls are always nops.

If the context kept track of the amount of message data processed, it
would be clearer to do something like if (ctx-&gt;processed_msg_data == 0)
ccm_pad(), but it's not worth adding an additional counter to the
context only for this purpose.

And implicit signalling end of adata by the first call to
_encrypt/_decrypt (or directly to _digest, in case of an empty message)
is the convention used for other aead algorithms in nettle.

&gt; Since the IV only contains a single bit that indicates whether adata exists
&gt; at all, in theory the alength parameter could be omitted from set_nonce()
&gt; entirely and then handled in ccm_update(), which is what this check is doing.
&gt;
&gt; This is more or less an artifact of an attempt to support the AEAD API. Note
&gt; that if you call ccm_set_nonce() with alength==0, and then pass the entire
&gt; adata to ccm_update(), you would still get the correct authentication tag and
&gt; ciphertext because of this special check on alen.

I think one should choose to either require alength to be passed to
set_nonce, and drop support for the usage above. Or restrict the api to
allow only a single call to ccm_update, and then drop the alength
argument from set_nonce. And I think allowing multiple calls to
ccm_update seems desirable, so I'd prefer the first option. Do you
agree?

&gt; On Sat, Mar 15, 2014 at 12:07 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:

&gt;&gt; Is it possible to move this initial processing to ccm_set_nonce? The
&gt;&gt; alength *is* known there, and that would let you eliminate the ctx-&gt;blen
&gt;&gt; &lt; 0 cases, and maybe you could eliminate the alen state variable too (or
&gt;&gt; keep it for sanity checking only).
&gt;
&gt; Yes, that could be done, but this operation requires the use of the cipher
&gt; encrypt function, which would need to be added to the set_nonce() API.

I think it's fine to have set_nonce call the encrypt function.
chacha_poly1305_set_nonce does something a bit similar (but with fixed
algorithms so no function pointers passed around).

And in general, nettle applications are expected to call the appropriate
_set_key function *before* calling _set_nonce, so there is little point
in allowing _set_nonce first for ccm.

&gt; Yes, this was a bit of a judgement call, whether it was uglier to store the
&gt; nonce length in the ctx, or to parse it out of the flags byte of the counter.
&gt; There are other possible ways to do this, but they all require extra storage
&gt; in the ctx, which I was hoping to avoid.

I see. Your choice makes sense to me.

&gt; CCM is indeed specified as an AEAD function with a single output string,
&gt; for example, RFC 5166 specifies that the ciphertext is always exactly 16
&gt; bytes longer than the plaintext, so this might be a good way to simplify
&gt; the function call API.

Then the all-in-one encrypt function should have a single output,
formatted accordingly. And the decrypt function should accept the same
format as input.

About the tag length, do other protocols or applications use shorter tag
length with ccm? The all-in-one-functions should aim to be easy to use,
and they don't need to be fully general (since applications with special
needs can always call the more general and lower-level functions). *If*
almost all potential users of the all-in-one-functions use tag length
16, we might consider restricting the all-in-one functions to always use
this size, and then drop the taglength argument.

&gt; Generally, I would prefer that the length provided should be the length of
&gt; data that actually gets written (ie: ciphertext in this case).

I think that's a reasonable guideline. Then, the length arguments should
be clen for ccm_encrypt_message, and mlen for ccm_decrypt_message.

&gt; I didn't see any similar functions for the EAX or CGM modes, so I'm not sure
&gt; that we really need to be concerned with breaking a precedent here.

Similar all-in-one functions for other aead algorithms are on the
roadmap, but not yet implemented. So when designing the interface for
ccm, we should try to avoid that coming interface design for other aead
algorithms have to choose between, on one hand, beauty, and on the other
hand, consistency with ccm.

&gt; The negative value of blen is currently only used as a special value to
&gt; flag the first time that ccm_update() gets called so that we can
&gt; encrypt the IV to the CBC-MAC (B0) and generate the L(a). These
&gt; operations could be moved into ccm_set_nonce(), provided that
&gt; ccm_set_nonce() is also provided with the cipher encrypt function.

I think moving these operations will be an improvement.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140320172358</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-03-20 17:23:58-0400</timestampReceived><subject>[PATCH] Add support for SHA-512-224 and SHA-512-256 in sha512.c</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

Note that this patch also adds zero extension to a few of the constants
in the K constant table to fix the layout. Does not affect the
functionality per se.


- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIcBAEBCAAGBQJTKyQuAAoJEF3cfFQkIuyNpeQQAIeF2/kDteUTwIEcqzwPWhUu
1oC/2vMHG12jqE+mTZ40wNB9/u62u29s4e3X7qpVbrYhtERKgtXAzze3WlOI72Rf
oS5X1Vnaik8z3/qHkzfFAqxh2jkanRIlUhhayriw5kb3I2jd05P69VJ0cbgZ+sKO
AQMQFaxIUhzTr9EuEKhyaGYpJnU10VcFB8X0JIvMW/QA/YzAvhNAuU1OlZxtuQB/
irdikcQ6qc0Rb4ynqLbZ+4NTXwQ3384TPni6sDpCsXqUi5HX3WV54HCyis8jBROe
1ZlrhkziECZBRUklXPpzDl36rYibUvyo5L2Smx4SMAg7/ScDTyo/vLbbfT3X6p16
hjwknhvgvpStcbMmDnumshgQ1Z5h2hhN4E+R2Mx9DNpScFpDC5PxMAqwPFP8LLow
fUwSoq+0oUZOdH/3+frMuEDyQQTpQ/EWRbEtZ5X7P6AFV/8ylP+TJ5zSPBXv7GNR
n9crvdsxdSAEkmhJoU+8O7uSX2okYXHvIDliQkXxi2ABk98YZycopJURWUTx7iKp
O7LsWwiYfmArf/JR+eqxfbv9TP+qYod8h9LVt+IDSqX4IW6bAGaggnZEGK6yLDpP
1BLdDzdUYEIgluv2KS6+tB0Gv8S8TSv0Zu+GfmUsTmLEj5jKNTUR1WgzEGkNBD7t
W/nWBSwClSeNzUEHBqeH
=z0eH
-----END PGP SIGNATURE-----

["patch_fips180-4_sha512.c" (text/plain)]

74c74
&lt;   0xFC19DC68B8CD5B5ULL,0x240CA1CC77AC9C65ULL,
---
&gt;   0x0FC19DC68B8CD5B5ULL,0x240CA1CC77AC9C65ULL,
80c80
&lt;   0x6CA6351E003826FULL,0x142929670A0E6E70ULL,
---
&gt;   0x06CA6351E003826FULL,0x142929670A0E6E70ULL,
99c99
&lt;   0x6F067AA72176FBAULL,0xA637DC5A2C898A6ULL,
---
&gt;   0x06F067AA72176FBAULL,0x0A637DC5A2C898A6ULL,
239a240,305
&gt; 
&gt; 
&gt; /* sha-512/224 variant. */
&gt; void
&gt; sha512_224_init(struct sha512_ctx *ctx)
&gt; {
&gt;   static const uint64_t H0[_SHA512_DIGEST_LENGTH] =
&gt;   {
&gt;     0x8c3d37c819544da2ULL, 0x73e1996689dcd4d6ULL,
&gt;     0x1dfab7ae32ff9c82ULL, 0x679dd514582f9fcfULL,
&gt;     0x0f6d2b697bd44da8ULL, 0x77e36f7304c48942ULL,
&gt;     0x3f9d85a86a1d36c8ULL, 0x1112e6ad91d692a1ULL,
&gt;   };
&gt; 
&gt;   memcpy(ctx-&gt;state, H0, sizeof(H0));
&gt; 
&gt;   /* Initialize bit count */
&gt;   ctx-&gt;count_low = ctx-&gt;count_high = 0;
&gt;   
&gt;   /* Initialize buffer */
&gt;   ctx-&gt;index = 0;
&gt; }
&gt; 
&gt; void
&gt; sha512_224_digest(struct sha512_ctx *ctx,
&gt; 	      size_t length,
&gt; 	      uint8_t *digest)
&gt; {
&gt;   assert(length &lt;= SHA224_DIGEST_SIZE);
&gt; 
&gt;   sha512_write_digest(ctx, length, digest);
&gt;   sha512_224_init(ctx);
&gt; }
&gt; 
&gt; 
&gt; /* sha-512/256 variant. */
&gt; void
&gt; sha512_256_init(struct sha512_ctx *ctx)
&gt; {
&gt;   static const uint64_t H0[_SHA512_DIGEST_LENGTH] =
&gt;     {
&gt;       0x22312194fc2bf72cULL, 0x9f555fa3c84c64c2ULL, 
&gt;       0x2393b86b6f53b151ULL, 0x963877195940eabdULL, 
&gt;       0x96283ee2a88effe3ULL, 0xbe5e1e2553863992ULL, 
&gt;       0x2b0199fc2c85b8aaULL, 0x0eb72ddc81c52ca2ULL,
&gt;     };
&gt; 
&gt;   memcpy(ctx-&gt;state, H0, sizeof(H0));
&gt; 
&gt;   /* Initialize bit count */
&gt;   ctx-&gt;count_low = ctx-&gt;count_high = 0;
&gt;   
&gt;   /* Initialize buffer */
&gt;   ctx-&gt;index = 0;
&gt; }
&gt; 
&gt; void
&gt; sha512_256_digest(struct sha512_ctx *ctx,
&gt; 	      size_t length,
&gt; 	      uint8_t *digest)
&gt; {
&gt;   assert(length &lt;= SHA256_DIGEST_SIZE);
&gt; 
&gt;   sha512_write_digest(ctx, length, digest);
&gt;   sha512_224_init(ctx);
&gt; }


</body></email><email><emailId>20140320183202</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-20 18:32:02-0400</timestampReceived><subject>Re: Support for FIPS 180-4 SHA-512/256?</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; It wasn't really that hard. Patches will follow in two mails.

Nice. If this is to go in the upcoming release, I'd appreciate help with
the documentation too.

&gt; I have not updated the H0 generation scripts used to verify the values
&gt; (which you have done for SHA-384 and SHA-512).

Ideally, shadata.c should be extended to generate all tables needed for
sha2. It can now use mini-gmp to get as much precision as it needs. But
that's not urgent.

&gt; I think it looks a bit ugly to have separat init and digest functions
&gt; but reuse the update function from sha512. I would prefer to add
&gt; sha512_224_update() and sha512_256 too but still reuse the context. But
&gt; since you don't do that for sha384

For sha384, there's a

  #define sha384_update nettle_sha512_update

in sha2.h. We could add two more aliases for that function, if that makes
application code prettier.

Minor nit: I prefer patches in unified format.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140320190232</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-03-20 19:02:32-0400</timestampReceived><subject>[REVISED PATCH] Update of sha512.c to add support for sha512_224 and sha512_256.</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

And here is the patch for sha512.c in unified diff format. Hopfully the
attachment will also be signed now. ;-)


- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIcBAEBCAAGBQJTKztHAAoJEF3cfFQkIuyNJSkQAM3IkVjah8lotb7aSZ/ubv+C
jgLuPwCF1GM0IVZc2HV3fT6IPt2fhUe9rsh5AwX0tEW1zVnMHA2HH6mpgbyrGNds
Xnvu8jyJN3XLN+f1OOPp1ulFkbgaK/Nkby7Rg+UHcMOZZ3FKUs/d0r/rEKAunkRL
7OhazSKV/PGxFl7wXUupHv1wOLlZxCyF+FpGr/bG3cM4bf+ep2dgwdMZYcb361H+
DxjbYQBW2Ch5v3dsXrhpz+n0YxjPa8+/9iMyEYeN/+iFU17zAchjCzJOF3RMp2fM
+1WHzbikOu5pHZOpei/wBos0tXBhDVfK8wWKf5ziRUV9hnbZKfUM91yqT2CH92qc
h8HsjPZrZ13oU73mKA0Hhejt586eBR8eNs3cTIuzAA2puh4m3lnzLNkHgdBPsIo1
wXJtacCGwUwrtum+U1gZASYF/ZKEKP2C/P/4idU+gBC23xBqOhjhrIHzvmkCxOqY
9zSJCvSd1+y2q1k8EL6Xa1TcJFrOOGRiUJPDbQN/sCfRp4i5hzUz7F+q1Fh6dOEi
zbL0QarLxkBldr62AUI7y7O784NCGe8WeRN6rM9enHgr63fnqwfjOeIOop/3i4kY
NbKG2dp8IokbTaAwjd8G23+ZGs3pPbd7X1z0hoCTwziMyWyIQYQggjrDboy6zAgJ
FMnSkNPfKMbK5jR02nvg
=Ic5b
-----END PGP SIGNATURE-----

["patch_fips180-4_sha512.c" (text/plain)]

--- /Users/js/Sandbox/external/nettle/sha512.c	2014-01-03 19:29:24.000000000 +0100
+++ sha512.c	2014-03-20 18:03:50.000000000 +0100
@@ -71,13 +71,13 @@
   0x72BE5D74F27B896FULL,0x80DEB1FE3B1696B1ULL,
   0x9BDC06A725C71235ULL,0xC19BF174CF692694ULL,
   0xE49B69C19EF14AD2ULL,0xEFBE4786384F25E3ULL,
-  0xFC19DC68B8CD5B5ULL,0x240CA1CC77AC9C65ULL,
+  0x0FC19DC68B8CD5B5ULL,0x240CA1CC77AC9C65ULL,
   0x2DE92C6F592B0275ULL,0x4A7484AA6EA6E483ULL,
   0x5CB0A9DCBD41FBD4ULL,0x76F988DA831153B5ULL,
   0x983E5152EE66DFABULL,0xA831C66D2DB43210ULL,
   0xB00327C898FB213FULL,0xBF597FC7BEEF0EE4ULL,
   0xC6E00BF33DA88FC2ULL,0xD5A79147930AA725ULL,
-  0x6CA6351E003826FULL,0x142929670A0E6E70ULL,
+  0x06CA6351E003826FULL,0x142929670A0E6E70ULL,
   0x27B70A8546D22FFCULL,0x2E1B21385C26C926ULL,
   0x4D2C6DFC5AC42AEDULL,0x53380D139D95B3DFULL,
   0x650A73548BAF63DEULL,0x766A0ABB3C77B2A8ULL,
@@ -96,7 +96,7 @@
   0xBEF9A3F7B2C67915ULL,0xC67178F2E372532BULL,
   0xCA273ECEEA26619CULL,0xD186B8C721C0C207ULL,
   0xEADA7DD6CDE0EB1EULL,0xF57D4F7FEE6ED178ULL,
-  0x6F067AA72176FBAULL,0xA637DC5A2C898A6ULL,
+  0x06F067AA72176FBAULL,0x0A637DC5A2C898A6ULL,
   0x113F9804BEF90DAEULL,0x1B710B35131C471BULL,
   0x28DB77F523047D84ULL,0x32CAAB7B40C72493ULL,
   0x3C9EBE0A15C9BEBCULL,0x431D67C49C100D4CULL,
@@ -237,3 +237,69 @@
   sha512_write_digest(ctx, length, digest);
   sha384_init(ctx);
 }
+
+
+/* sha-512/224 variant. */
+void
+sha512_224_init(struct sha512_ctx *ctx)
+{
+  static const uint64_t H0[_SHA512_DIGEST_LENGTH] =
+  {
+    0x8c3d37c819544da2ULL, 0x73e1996689dcd4d6ULL,
+    0x1dfab7ae32ff9c82ULL, 0x679dd514582f9fcfULL,
+    0x0f6d2b697bd44da8ULL, 0x77e36f7304c48942ULL,
+    0x3f9d85a86a1d36c8ULL, 0x1112e6ad91d692a1ULL,
+  };
+
+  memcpy(ctx-&gt;state, H0, sizeof(H0));
+
+  /* Initialize bit count */
+  ctx-&gt;count_low = ctx-&gt;count_high = 0;
+  
+  /* Initialize buffer */
+  ctx-&gt;index = 0;
+}
+
+void
+sha512_224_digest(struct sha512_ctx *ctx,
+	      size_t length,
+	      uint8_t *digest)
+{
+  assert(length &lt;= SHA224_DIGEST_SIZE);
+
+  sha512_write_digest(ctx, length, digest);
+  sha512_224_init(ctx);
+}
+
+
+/* sha-512/256 variant. */
+void
+sha512_256_init(struct sha512_ctx *ctx)
+{
+  static const uint64_t H0[_SHA512_DIGEST_LENGTH] =
+    {
+      0x22312194fc2bf72cULL, 0x9f555fa3c84c64c2ULL, 
+      0x2393b86b6f53b151ULL, 0x963877195940eabdULL, 
+      0x96283ee2a88effe3ULL, 0xbe5e1e2553863992ULL, 
+      0x2b0199fc2c85b8aaULL, 0x0eb72ddc81c52ca2ULL,
+    };
+
+  memcpy(ctx-&gt;state, H0, sizeof(H0));
+
+  /* Initialize bit count */
+  ctx-&gt;count_low = ctx-&gt;count_high = 0;
+  
+  /* Initialize buffer */
+  ctx-&gt;index = 0;
+}
+
+void
+sha512_256_digest(struct sha512_ctx *ctx,
+	      size_t length,
+	      uint8_t *digest)
+{
+  assert(length &lt;= SHA256_DIGEST_SIZE);
+
+  sha512_write_digest(ctx, length, digest);
+  sha512_224_init(ctx);
+}


</body></email><email><emailId>20140323064947</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-23 06:49:47-0400</timestampReceived><subject>Re: [REVISED PATCH] Update of sha2.h to add sha512_224 and sha512_256.</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; Good point. I'll add those and file new patches. Probably today.

I've pushed the first set of patches (to the master branch) now.

&gt;&gt; const struct nettle_hash nettle_sha512_224; const struct nettle_hash
&gt;&gt; nettle_sha512_256;
&gt;&gt;
&gt;&gt; Or, since all variants are implemented in the same sha512.c source
&gt;&gt; file anyway, maybe these objects could be placed together in
&gt;&gt; sha384-meta.c.
&gt;
&gt; A little bit confusing having them in SHA-384. But something one should
&gt; be able to live with.

Feel free to put them in separate files.

&gt; I'll do some hacking on this and the docs.

I look forward to that. Of the missing things, test cases are most
important, I think.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140324181639</emailId><senderName>Owen Kirby</senderName><senderEmail>osk@exegin.com</senderEmail><timestampReceived>2014-03-24 18:16:39-0400</timestampReceived><subject>Re: [PATCH v3] CCM Cipher Modes</subject><body>

Awesome, thank you. I will take a look at assembling documentation
regarding the CCM modes when I get some spare time this week.

Cheers,
Owen

On 14-03-23 11:06 AM, Niels Möller wrote:
&gt; Owen Kirby &lt;osk@exegin.com&gt; writes:
&gt;
&gt;&gt; Latest round of changes to the CCM modes, this moves the processing of L(a) into
&gt;&gt; ccm_set_nonce() and updates the all-at-once API to concatenate the ciphertext and
&gt;&gt; digest together.
&gt; Pushed now, with some smaller changes. All uses of nettle_crypt_func are
&gt; replaced by nettle_cipher_func (introduced last week), and the cipher
&gt; context arguments accordingly changed to const. And some tweaks of
&gt; indentation and line breaks.
&gt;
&gt; Documentation remains to do.
&gt;
&gt; Thanks,
&gt; /Niels
&gt;


</body></email><email><emailId>20140328175946</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-28 17:59:46-0400</timestampReceived><subject>Re: Backwards compatibility (was Re: dsa_generate_keypair)</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Unless there are objections, I think I'm going to merge this to the
&gt; master branch as soon as I get the time. (Most likely a manual merge, to
&gt; avoid checking in dead ends). We really need to get this over with.

Pushed now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140202214441</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-02 21:44:41-0400</timestampReceived><subject>Re: Curve25519</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; Is there any generic (EC)DH interface in nettle?

I think the three functions ecc_scalar_random, ecc_point_mul_g and
ecc_point_mul are what's needed. And I added ecc_bit_size a few days
ago.

This doesn't do encoding and decoding of points for ANSI x9.62 (or any
other related standard), though.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140319140025</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-03-19 14:00:25-0400</timestampReceived><subject>Support for FIPS 180-4 SHA-512/256?</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

Looking at sha2.h it seems that Nettle does not support the truncated
SHA-512 versions SHA-512/224 and SHA-512/256 as defined in FIPS 180-4,
correct?

If not is that something that would be interesting to add? It is not a
very big addition - basically add more variants of the H0-constants and
then truncate. The benefit for users would be better performance on 64
bit CPUs compared to SHA-256 and SHA-224.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIcBAEBCAAGBQJTKaL5AAoJEF3cfFQkIuyNZLwP/0W/OFf/wm/ZrWVV33lne8QO
gevT3G7sOVEUm7oev4KJdRwtwMIx1NGStkPvAjcWmT6xOk9NluTJvvmJSM9tlP+6
PVDOBwHNruCASygy1aJRya4VrLwWz+PYtzTn4LkgIY1invkVGPs6Lc1KZe/yql7k
FL0wygjYGIBK+tjNR0ZVTjoEJwu8qLItL4N4cUVG9tdBQDBRInLpQZDlabDegIwZ
rziCFNz3BOo+6dGaF5gwPmyuaPLojneLox4SkWq4FliojMIeDN+qQxy8sD1reRbz
a9DuIlo2w1+/9QudtuTRUgIJ+kSfo0RjMTb5Ea2dcfgNgeYf8oty8bUBfgBqEWZe
gjGappJd/auE3ScQ8X7Sz/hDp2cT/IBNOSmYmwIl16z7sHRChqXiBYYjw+KDm75a
SPdDYkeR9D8gVBDYR+h76IW+rsdEebnqTvOGHsMUYZOL08djhbw1TbVGkCw261dE
4NQjXkJBVXg/t1RPXl5hktOs1fbWHzcEP5DWrdX2yotjLoMZeaJzFP1DECG8Bzpw
Cq4TvwPmaamQJlrOc43Le/VERWwZD/mCnQRPGE52kXwDQf2wcfk9m/B6sd6r0EO9
RXeNKJsfd8iLBpKFb9vte0Hi8++zJcXX5WpnmtEYAEylmJhpcErehNS/T3b1eFhi
9k3r19RvKcpJ3EoW2JXA
=pUsr
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140319141838</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-19 14:18:38-0400</timestampReceived><subject>Re: Support for FIPS 180-4 SHA-512/256?</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; Looking at sha2.h it seems that Nettle does not support the truncated
&gt; SHA-512 versions SHA-512/224 and SHA-512/256 as defined in FIPS 180-4,
&gt; correct?

That's correct. I wasn't aware of them... Are there any applications or
protocols using them?

&gt; If not is that something that would be interesting to add? It is not a
&gt; very big addition - basically add more variants of the H0-constants and
&gt; then truncate.

If they are needed, I'd suggest adding

sha512_224_init
sha512_224_digest
sha512_256_init
sha512_256_digest

(and not bother with any additional aliases for context struct and
_update function). Is that ok?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140320185555</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-03-20 18:55:55-0400</timestampReceived><subject>[REVISED PATCH] Update of sha2.h to add sha512_224 and sha512_256.</subject><body>

[Attachment #2 (multipart/mixed)]


Aloha!

Ok here is a revised patch with defines of update functions like for
sha384. This patch is in unified format.

-- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================

["patch_fips180-4_sha2.h" (text/plain)]

--- /Users/js/Sandbox/external/nettle/sha2.h	2014-01-03 19:29:24.000000000 +0100
+++ sha2.h	2014-03-20 19:52:06.000000000 +0100
@@ -44,6 +44,12 @@
 #define sha512_update nettle_sha512_update
 #define sha512_digest nettle_sha512_digest
 
+#define sha512_224_init   nettle_sha512_224_init
+#define sha512_224_digest nettle_sha512_224_digest
+#define sha512_256_init   nettle_sha512_256_init
+#define sha512_256_digest nettle_sha512_256_digest
+
+  
 /* SHA256 */
 
 #define SHA256_DIGEST_SIZE 32
@@ -125,7 +131,8 @@
 sha512_digest(struct sha512_ctx *ctx,
 	      size_t length,
 	      uint8_t *digest);
-
+  
+  
 /* Internal compression function. STATE points to 8 uint64_t words,
    DATA points to 128 bytes of input data, possibly unaligned, and K
    points to the table of constants. */
@@ -149,6 +156,29 @@
 	      size_t length,
 	      uint8_t *digest);
 
+
+/* SHA512_224 and SHA512_256, two truncated versions of SHA512 
+with different initial states. */
+void
+sha512_224_init(struct sha512_ctx *ctx);
+
+#define sha512_224_update nettle_sha512_update
+
+void
+sha512_224_digest(struct sha512_ctx *ctx,
+                  size_t length,
+                  uint8_t *digest);
+
+void
+sha512_256_init(struct sha512_ctx *ctx);
+
+#define sha512_256_update nettle_sha512_update
+
+void
+sha512_256_digest(struct sha512_ctx *ctx,
+                  size_t length,
+                  uint8_t *digest);
+  
 #ifdef __cplusplus
 }
 #endif

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20140320221527</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-20 22:15:27-0400</timestampReceived><subject>Re: [REVISED PATCH] Update of sha2.h to add sha512_224 and sha512_256.</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; Ok here is a revised patch with defines of update functions like for
&gt; sha384. This patch is in unified format.

Thanks. Seems almost ready to to apply (and I already pushed the trivial
indent fix). Some additional comments:

1. For the sha512.c copyright header, should it be "Copyright (C) 2014
   Joachim Strömbergson", or Secworks AB, or something else?

2. Test cases are needed. Benchmark support would also be nice, but less
   important than tests and documentation.

3. I think there should be _DIGEST_SIZE and _DATA_SIZE defines for the
   new algorithms. In particular, SHA512_256_DATA_SIZE is different from
   SHA256_DATA_SIZE.

4. Add corresponding -meta.c files? Defining

   const struct nettle_hash nettle_sha512_224;
   const struct nettle_hash nettle_sha512_256;

   Or, since all variants are implemented in the same sha512.c source
   file anyway, maybe these objects could be placed together in
   sha384-meta.c. With this in place, adding them to
   examples/nettle-benchmark.c is trivial.

   Should also update nettle-meta-hashes.c and correspnding test case.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140321084159</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-03-21 08:41:59-0400</timestampReceived><subject>Re: [REVISED PATCH] Update of sha2.h to add sha512_224 and sha512_256.</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

Niels Möller wrote:
&gt; 1. For the sha512.c copyright header, should it be "Copyright (C)
&gt; 2014 Joachim Strömbergson", or Secworks AB, or something else?

Just add me (Joachim) as coauthor if that is ok with you. It is mainly
your code.

&gt; 2. Test cases are needed. Benchmark support would also be nice, but
&gt; less important than tests and documentation.

Yes. To both. I was thinking of doing benchmarking anyway since the
point of these versions is to get better performance than for normal
SHA-224 and SHA-256.


&gt; 3. I think there should be _DIGEST_SIZE and _DATA_SIZE defines for
&gt; the new algorithms. In particular, SHA512_256_DATA_SIZE is different
&gt; from SHA256_DATA_SIZE.

Good point. I'll add those and file new patches. Probably today.


&gt; 4. Add corresponding -meta.c files? Defining
&gt; 
&gt; const struct nettle_hash nettle_sha512_224; const struct nettle_hash
&gt; nettle_sha512_256;
&gt; 
&gt; Or, since all variants are implemented in the same sha512.c source 
&gt; file anyway, maybe these objects could be placed together in 
&gt; sha384-meta.c. With this in place, adding them to 
&gt; examples/nettle-benchmark.c is trivial.

A little bit confusing having them in SHA-384. But something one should
be able to live with.

I'll do some hacking on this and the docs.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIcBAEBCAAGBQJTK/tXAAoJEF3cfFQkIuyNn+QQAIpnRdl+bT+d5o7DAzmakH8c
yVlycrkrD7kfvxDNBsJcFRdhN6+Y9X57D0gaHJST+H7ppDYWwKa4G5zmHt4FmJRI
Lgq1I6gDzmY+9DJY4it2Cjm3kNQhFqTD+kvoE2q9sSYVovrER0SlPVjrr8D2YP6J
0mq66+S79IIS1mcYOZ/K0l8VlBEW2plT+VYGw/x3MdoLGzn0lVCFXelLtHIrtZcv
KVF9/JPvK7B2pioZwu6majISjI3vM8XK+q5PxaRRy+QE6Xe9vft0DFw9/vJ9euvW
DR9b9BY/6P97UssUqNPBy6Ur9MJFhOAeaJ1w+c+YRAozZnEIlBBxkiWBFZpZaIKU
hpMpz53BvqjJti/W/VGydIReyGkmVVAfxRspGCkhYxWFrzueNxy/LRCrmo7AvnBY
EY+aMux0gtfXlFdVjBUPELjyPc3ZYeNKaAeUlcyzDHnRJnGzhmb/8cf0EckEQ0xZ
bF3D7FPmlPfiJ6TtQVzHzCcJ7JnzE1ZZ0OJlAJW3I3/JgNcV9XE4TZBoKHb0mrS6
kVy1JDn/8wDD5MDcmfgBPhp0l6L1JxKOOdY+/uLTxtEoEH6jTAIEFUVTbcYmj/3U
LnOoLkIkDlD/LeOUlR3UY3fCIhu7PqkEQXEjVky0aFkLZPmzGzYI2CQfFRLkD1Xk
P9ckLOOBMkBrxcejeG7f
=/mvv
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140320213121</emailId><senderName>Owen Kirby</senderName><senderEmail>osk@exegin.com</senderEmail><timestampReceived>2014-03-20 21:31:21-0400</timestampReceived><subject>[PATCH v3] CCM Cipher Modes</subject><body>

Latest round of changes to the CCM modes, this moves the processing of L(a) into
ccm_set_nonce() and updates the all-at-once API to concatenate the ciphertext and
digest together.

Cheers,
Owen

2014-03-20	Owen Kirby	&lt;osk@exegin.com&gt;
* ccm.c (ccm_digest, ccm_set_nonce): Moved L(a) generation into ccm_set_nonce()
* ccm.c (ccm_encrypt_message): Modified API to append the tag to the ciphertext.
* ccm.c (ccm_decrypt_message): Modified API to parse the tag from the ciphertext.
* ccm.h (struct ccm_ctx): Removed alen parameter, and made blength unsigned.
* testsuite/ccm-test.c: Updated the test vectors for the all-at-once API.

2014-03-14	Owen Kirby	&lt;osk@exegin.com&gt;
* ccm-aes.c: Removed legacy AES API.
* ccm.c (ccm_encrypt_message): Added all-at-once API for CCM mode ciphers.
* ccm.c (ccm_digest): Added assert to ensure CCM digest length &lt;= block size.
* ccm.h: Updated copyright for CCM modes to Owen Kirby and Exegin Technologies.
* ccm.c: Minor changes to CCM IV and nonce building functions.
* ccm-aesXXX.c: Added all-at-once API, and removed the CCM helper macros.
* testsuite/ccm-test.c: Added tests for the cipher-specific CCM functions.
* testsuite/.test-rules.make: Fixed the building of the CCM self-test.

&gt; From 7643b88984cc71deb16ae2f3e91a6e7a0e2b8023 Mon Sep 17 00:00:00 2001
From: Owen Kirby &lt;osk@exegin.com&gt;
Date: Wed, 20 Mar 2014 14:28:56 -0800
Subject: [PATCH]   Support for CCM mode ciphers.

---
 Makefile.in                |    1 +
 ccm-aes128.c               |  100 +++++++
 ccm-aes192.c               |  101 +++++++
 ccm-aes256.c               |  102 +++++++
 ccm.c                      |  255 ++++++++++++++++
 ccm.h                      |  273 +++++++++++++++++
 testsuite/.gitignore       |    1 +
 testsuite/.test-rules.make |    3 +
 testsuite/Makefile.in      |    2 +-
 testsuite/ccm-test.c       |  713 ++++++++++++++++++++++++++++++++++++++++++++
 10 files changed, 1550 insertions(+), 1 deletion(-)
 create mode 100644 ccm-aes128.c
 create mode 100644 ccm-aes192.c
 create mode 100644 ccm-aes256.c
 create mode 100644 ccm.c
 create mode 100644 ccm.h
 create mode 100644 testsuite/ccm-test.c

diff --git a/Makefile.in b/Makefile.in
index 24349c3..c05d891 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -87,6 +87,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 camellia256-set-decrypt-key.c \
 		 camellia256-meta.c \
 		 cast128.c cast128-meta.c cbc.c \
+		 ccm.c ccm-aes.c ccm-aes128.c ccm-aes192.c ccm-aes256.c \
 		 chacha-crypt.c chacha-core-internal.c \
 		 chacha-poly1305.c chacha-poly1305-meta.c \
 		 chacha-set-key.c chacha-set-nonce.c \
diff --git a/ccm-aes128.c b/ccm-aes128.c
new file mode 100644
index 0000000..94554e5
--- /dev/null
+++ b/ccm-aes128.c
@@ -0,0 +1,100 @@
+/* ccm-aes128.c
+ *
+ * Counter with CBC-MAC mode using AES128 as the underlying cipher.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2014 Exegin Technologies Limited
+ * Copyright (C) 2014 Owen Kirby
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "aes.h"
+#include "ccm.h"
+
+void
+ccm_aes128_set_key(struct ccm_aes128_ctx *ctx, const uint8_t *key)
+{
+  aes128_set_encrypt_key(&amp;ctx-&gt;cipher, key);
+}
+
+void
+ccm_aes128_set_nonce(struct ccm_aes128_ctx *ctx, size_t length, const uint8_t \
*nonce, +        size_t authlen, size_t msglen, size_t taglen)
+{
+  ccm_set_nonce(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher, (nettle_crypt_func *)aes128_encrypt,
+        length, nonce, authlen, msglen, taglen);
+}
+
+void
+ccm_aes128_update(struct ccm_aes128_ctx *ctx,
+        size_t length, const uint8_t *data)
+{
+  ccm_update(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes128_encrypt, length, data);
+}
+
+void
+ccm_aes128_encrypt(struct ccm_aes128_ctx *ctx,
+		size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ccm_encrypt(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes128_encrypt, length, dst, src);
+}
+
+void
+ccm_aes128_decrypt(struct ccm_aes128_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ccm_decrypt(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes128_encrypt, length, dst, src);
+}
+
+void
+ccm_aes128_digest(struct ccm_aes128_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  ccm_digest(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes128_encrypt, length, digest);
+}
+
+void
+ccm_aes128_encrypt_message(struct ccm_aes128_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength,
+	    size_t clength, uint8_t *dst, const uint8_t *src)
+{
+  ccm_encrypt_message(&amp;ctx-&gt;cipher, (nettle_crypt_func *)aes128_encrypt,
+            nlength, nonce, alength, adata, tlength, clength, dst, src);
+}
+
+int
+ccm_aes128_decrypt_message(struct ccm_aes128_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength,
+	    size_t clength, uint8_t *dst, const uint8_t *src)
+{
+  return ccm_decrypt_message(&amp;ctx-&gt;cipher, (nettle_crypt_func *)aes128_encrypt,
+            nlength, nonce, alength, adata, tlength, clength, dst, src);
+}
\ No newline at end of file
diff --git a/ccm-aes192.c b/ccm-aes192.c
new file mode 100644
index 0000000..a2618a5
--- /dev/null
+++ b/ccm-aes192.c
@@ -0,0 +1,101 @@
+/* ccm-aes192.c
+ *
+ * Counter with CBC-MAC mode using AES192 as the underlying cipher.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2014 Exegin Technologies Limited
+ * Copyright (C) 2014 Owen Kirby
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "aes.h"
+#include "ccm.h"
+
+
+void
+ccm_aes192_set_key(struct ccm_aes192_ctx *ctx, const uint8_t *key)
+{
+  aes192_set_encrypt_key(&amp;ctx-&gt;cipher, key);
+}
+
+void
+ccm_aes192_set_nonce(struct ccm_aes192_ctx *ctx, size_t length, const uint8_t \
*nonce, +        size_t authlen, size_t msglen, size_t taglen)
+{
+  ccm_set_nonce(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher, (nettle_crypt_func *)aes192_encrypt,
+        length, nonce, authlen, msglen, taglen);
+}
+
+void
+ccm_aes192_update(struct ccm_aes192_ctx *ctx,
+        size_t length, const uint8_t *data)
+{
+  ccm_update(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes192_encrypt, length, data);
+}
+
+void
+ccm_aes192_encrypt(struct ccm_aes192_ctx *ctx,
+		size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ccm_encrypt(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes192_encrypt, length, dst, src);
+}
+
+void
+ccm_aes192_decrypt(struct ccm_aes192_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ccm_decrypt(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes192_encrypt, length, dst, src);
+}
+
+void
+ccm_aes192_digest(struct ccm_aes192_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  ccm_digest(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes192_encrypt, length, digest);
+}
+
+void
+ccm_aes192_encrypt_message(struct ccm_aes192_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength,
+	    size_t clength, uint8_t *dst, const uint8_t *src)
+{
+  ccm_encrypt_message(&amp;ctx-&gt;cipher, (nettle_crypt_func *)aes192_encrypt,
+            nlength, nonce, alength, adata, tlength, clength, dst, src);
+}
+
+int
+ccm_aes192_decrypt_message(struct ccm_aes192_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength,
+	    size_t clength, uint8_t *dst, const uint8_t *src)
+{
+  return ccm_decrypt_message(&amp;ctx-&gt;cipher, (nettle_crypt_func *)aes192_encrypt,
+            nlength, nonce, alength, adata, tlength, clength, dst, src);
+}
diff --git a/ccm-aes256.c b/ccm-aes256.c
new file mode 100644
index 0000000..0779a2d
--- /dev/null
+++ b/ccm-aes256.c
@@ -0,0 +1,102 @@
+/* ccm-aes256.c
+ *
+ * Counter with CBC-MAC mode using AES256 as the underlying cipher.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2014 Exegin Technologies Limited
+ * Copyright (C) 2014 Owen Kirby
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "aes.h"
+#include "ccm.h"
+
+
+void
+ccm_aes256_set_key(struct ccm_aes256_ctx *ctx, const uint8_t *key)
+{
+  aes256_set_encrypt_key(&amp;ctx-&gt;cipher, key);
+}
+
+void
+ccm_aes256_set_nonce(struct ccm_aes256_ctx *ctx, size_t length, const uint8_t \
*nonce, +        size_t authlen, size_t msglen, size_t taglen)
+{
+  ccm_set_nonce(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher, (nettle_crypt_func *)aes256_encrypt,
+        length, nonce, authlen, msglen, taglen);
+}
+
+void
+ccm_aes256_update(struct ccm_aes256_ctx *ctx,
+        size_t length, const uint8_t *data)
+{
+  ccm_update(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes256_encrypt, length, data);
+}
+
+void
+ccm_aes256_encrypt(struct ccm_aes256_ctx *ctx,
+		size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ccm_encrypt(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes256_encrypt, length, dst, src);
+}
+
+void
+ccm_aes256_decrypt(struct ccm_aes256_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ccm_decrypt(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes256_encrypt, length, dst, src);
+}
+
+void
+ccm_aes256_digest(struct ccm_aes256_ctx *ctx,
+		  size_t length, uint8_t *digest)
+{
+  ccm_digest(&amp;ctx-&gt;ccm, &amp;ctx-&gt;cipher,
+    (nettle_crypt_func *)aes256_encrypt, length, digest);
+}
+
+void
+ccm_aes256_encrypt_message(struct ccm_aes256_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength,
+	    size_t clength, uint8_t *dst, const uint8_t *src)
+{
+  ccm_encrypt_message(&amp;ctx-&gt;cipher, (nettle_crypt_func *)aes256_encrypt,
+            nlength, nonce, alength, adata, tlength, clength, dst, src);
+}
+
+int
+ccm_aes256_decrypt_message(struct ccm_aes256_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength,
+	    size_t clength, uint8_t *dst, const uint8_t *src)
+{
+  return ccm_decrypt_message(&amp;ctx-&gt;cipher, (nettle_crypt_func *)aes256_encrypt,
+            nlength, nonce, alength, adata, tlength, clength, dst, src);
+}
+
diff --git a/ccm.c b/ccm.c
new file mode 100644
index 0000000..82c2612
--- /dev/null
+++ b/ccm.c
@@ -0,0 +1,255 @@
+/* ccm.c
+ *
+ * Counter with CBC-MAC mode, specified by NIST,
+ * http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf
 + *
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2014 Exegin Technologies Limited
+ * Copyright (C) 2014 Owen Kirby
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include "ccm.h"
+#include "ctr.h"
+
+#include "memxor.h"
+#include "nettle-internal.h"
+#include "macros.h"
+
+/*
+ * The format of the CCM IV (for both CTR and CBC-MAC) is: flags | nonce | count
+ *  flags = 1 octet
+ *  nonce = N octets
+ *  count &gt;= 1 octet
+ *
+ * such that:
+ *  sizeof(flags) + sizeof(nonce) + sizeof(count) == 1 block
+ */
+#define CCM_FLAG_L          0x07
+#define CCM_FLAG_M          0x38
+#define CCM_FLAG_ADATA      0x40
+#define CCM_FLAG_RESERVED   0x80
+#define CCM_FLAG_GET_L(_x_) (((_x_) &amp; CCM_FLAG_L) + 1)
+#define CCM_FLAG_SET_L(_x_) (((_x_) - 1) &amp; CCM_FLAG_L)
+#define CCM_FLAG_SET_M(_x_) ((((_x_) - 2) &lt;&lt; 2) &amp; CCM_FLAG_M)
+
+#define CCM_OFFSET_FLAGS    0
+#define CCM_OFFSET_NONCE    1
+#define CCM_L_SIZE(_nlen_)  (CCM_BLOCK_SIZE - CCM_OFFSET_NONCE - (_nlen_))
+#define CCM_L_MAX_SIZE      (CCM_FLAG_L+1)
+#define CCM_IV_MAX_SIZE     (CCM_BLOCK_SIZE - CCM_OFFSET_NONCE - 1)
+#define CCM_IV_MIN_SIZE     (CCM_BLOCK_SIZE - CCM_OFFSET_NONCE - CCM_L_MAX_SIZE)
+
+/*
+ * The data input to the CBC-MAC: L(a) | adata | padding | plaintext | padding
+ *
+ * blength is the length of data that has been added to the CBC-MAC modulus the
+ * cipher block size. If the value of blength is non-zero then some data has
+ * been XOR'ed into the CBC-MAC, and we will need to pad the block (XOR with 0),
+ * and iterate the cipher one more time.
+ *
+ * The end of adata is detected implicitly by the first call to the encrypt()
+ * and decrypt() functions, and will call ccm_pad() to insert the padding if
+ * necessary. Because of the underlying CTR encryption, the encrypt() and
+ * decrypt() functions must be called with a multiple of the block size and
+ * therefore blength should be zero on all but the first call.
+ *
+ * Likewise, the end of the plaintext is implicitly determined by the first call
+ * to the digest() function, which will pad if the final CTR encryption was not
+ * a multiple of the block size.
+ */
+static void
+ccm_pad(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f)
+{
+    if (ctx-&gt;blength) f(cipher, CCM_BLOCK_SIZE, ctx-&gt;tag.b, ctx-&gt;tag.b);
+    ctx-&gt;blength = 0;
+}
+
+static void
+ccm_build_iv(uint8_t *iv, size_t noncelen, const uint8_t *nonce, uint8_t flags, \
size_t count) +{
+  unsigned int i;
+
+  /* Sanity check the nonce length. */
+  assert(noncelen &gt;= CCM_IV_MIN_SIZE);
+  assert(noncelen &lt;= CCM_IV_MAX_SIZE);
+    
+  /* Generate the IV */
+  iv[CCM_OFFSET_FLAGS] = flags | CCM_FLAG_SET_L(CCM_L_SIZE(noncelen));
+  memcpy(&amp;iv[CCM_OFFSET_NONCE], nonce, noncelen);
+  for (i=(CCM_BLOCK_SIZE - 1); i &gt;= (CCM_OFFSET_NONCE + noncelen); i--) {
+    iv[i] = count &amp; 0xff;
+    count &gt;&gt;= 8;
+  }
+  
+  /* Ensure the count was not truncated. */
+  assert(!count);
+}
+
+void
+ccm_set_nonce(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+        size_t length, const uint8_t *nonce,
+        size_t authlen, size_t msglen, size_t taglen)
+{   
+  /* Generate the IV for the CTR and CBC-MAC */
+  ctx-&gt;blength = 0;
+  ccm_build_iv(ctx-&gt;tag.b, length, nonce, CCM_FLAG_SET_M(taglen), msglen);
+  ccm_build_iv(ctx-&gt;ctr.b, length, nonce, 0, 1);
+
+  /* If no auth data, encrypt B0 and skip L(a) */
+  if (!authlen) {
+    f(cipher, CCM_BLOCK_SIZE, ctx-&gt;tag.b, ctx-&gt;tag.b);
+    return;
+  }
+  
+  /* Encrypt B0 (with the adata flag), and input L(a) to the CBC-MAC. */
+  ctx-&gt;tag.b[CCM_OFFSET_FLAGS] |= CCM_FLAG_ADATA;
+  f(cipher, CCM_BLOCK_SIZE, ctx-&gt;tag.b, ctx-&gt;tag.b);
+  if (authlen &gt;= (0x01ULL &lt;&lt; 32)) {
+    /* Encode L(a) as 0xff || 0xff || &lt;64-bit integer&gt; */
+    ctx-&gt;tag.b[ctx-&gt;blength++] ^= 0xff;
+    ctx-&gt;tag.b[ctx-&gt;blength++] ^= 0xff;
+    ctx-&gt;tag.b[ctx-&gt;blength++] ^= (authlen &gt;&gt; 56) &amp; 0xff;
+    ctx-&gt;tag.b[ctx-&gt;blength++] ^= (authlen &gt;&gt; 48) &amp; 0xff;
+    ctx-&gt;tag.b[ctx-&gt;blength++] ^= (authlen &gt;&gt; 40) &amp; 0xff;
+    ctx-&gt;tag.b[ctx-&gt;blength++] ^= (authlen &gt;&gt; 32) &amp; 0xff;
+    ctx-&gt;tag.b[ctx-&gt;blength++] ^= (authlen &gt;&gt; 24) &amp; 0xff;
+    ctx-&gt;tag.b[ctx-&gt;blength++] ^= (authlen &gt;&gt; 16) &amp; 0xff;
+  }
+  else if (authlen &gt;= ((0x1ULL &lt;&lt; 16) - (0x1ULL &lt;&lt; 8))) {
+    /* Encode L(a) as 0xff || 0xfe || &lt;32-bit integer&gt; */
+    ctx-&gt;tag.b[ctx-&gt;blength++] ^= 0xff;
+    ctx-&gt;tag.b[ctx-&gt;blength++] ^= 0xfe;
+    ctx-&gt;tag.b[ctx-&gt;blength++] ^= (authlen &gt;&gt; 24) &amp; 0xff;
+    ctx-&gt;tag.b[ctx-&gt;blength++] ^= (authlen &gt;&gt; 16) &amp; 0xff;
+  }
+  ctx-&gt;tag.b[ctx-&gt;blength++] ^= (authlen &gt;&gt; 8) &amp; 0xff;
+  ctx-&gt;tag.b[ctx-&gt;blength++] ^= (authlen &gt;&gt; 0) &amp; 0xff;
+}
+
+void
+ccm_update(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	   size_t length, const uint8_t *data)
+{
+  const uint8_t *end = data + length;
+
+  /* If we don't have enough to fill a block, save the data for later. */
+  if ((ctx-&gt;blength + length) &lt; CCM_BLOCK_SIZE) {
+    memxor(&amp;ctx-&gt;tag.b[ctx-&gt;blength], data, length);
+    ctx-&gt;blength += length;
+    return;
+  }
+  
+  /* Process a partially filled block. */
+  if (ctx-&gt;blength) {
+    memxor(&amp;ctx-&gt;tag.b[ctx-&gt;blength], data, CCM_BLOCK_SIZE - ctx-&gt;blength);
+    data += (CCM_BLOCK_SIZE - ctx-&gt;blength);
+    f(cipher, CCM_BLOCK_SIZE, ctx-&gt;tag.b, ctx-&gt;tag.b);
+  }
+  
+  /* Process full blocks. */
+  while ((data + CCM_BLOCK_SIZE) &lt; end) {
+    memxor(ctx-&gt;tag.b, data, CCM_BLOCK_SIZE);
+    f(cipher, CCM_BLOCK_SIZE, ctx-&gt;tag.b, ctx-&gt;tag.b);
+    data += CCM_BLOCK_SIZE;
+  } /* while */
+  
+  /* Save leftovers for later. */
+  ctx-&gt;blength = (end - data);
+  if (ctx-&gt;blength) memxor(&amp;ctx-&gt;tag.b, data, ctx-&gt;blength);
+}
+
+/*
+ * Because of the underlying CTR mode encryption, when called multiple times
+ * the data in intermediate calls must be provided in multiples of the block
+ * size.
+ */
+void
+ccm_encrypt(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	    size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ccm_pad(ctx, cipher, f);
+  ccm_update(ctx, cipher, f, length, src);
+  ctr_crypt(cipher, f, CCM_BLOCK_SIZE, ctx-&gt;ctr.b, length, dst, src);
+}
+
+/*
+ * Because of the underlying CTR mode decryption, when called multiple times
+ * the data in intermediate calls must be provided in multiples of the block
+ * size.
+ */
+void
+ccm_decrypt(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	    size_t length, uint8_t *dst, const uint8_t *src)
+{
+  ctr_crypt(cipher, f, CCM_BLOCK_SIZE, ctx-&gt;ctr.b, length, dst, src);
+  ccm_pad(ctx, cipher, f);
+  ccm_update(ctx, cipher, f, length, dst);
+}
+
+void
+ccm_digest(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	   size_t length, uint8_t *digest)
+{
+  int i = CCM_BLOCK_SIZE - CCM_FLAG_GET_L(ctx-&gt;ctr.b[CCM_OFFSET_FLAGS]);
+  assert(length &lt;= CCM_BLOCK_SIZE);
+  while (i &lt; CCM_BLOCK_SIZE)  ctx-&gt;ctr.b[i++] = 0;
+  ccm_pad(ctx, cipher, f);
+  ctr_crypt(cipher, f, CCM_BLOCK_SIZE, ctx-&gt;ctr.b, length, digest, ctx-&gt;tag.b);
+}
+
+void
+ccm_encrypt_message(void *cipher, nettle_crypt_func *f,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength,
+	    size_t clength, uint8_t *dst, const uint8_t *src)
+{
+  struct ccm_ctx ctx;
+  uint8_t *tag = dst + (clength-tlength);
+  assert(clength &gt;= tlength);
+  ccm_set_nonce(&amp;ctx, cipher, f, nlength, nonce, alength, clength-tlength, tlength);
+  ccm_update(&amp;ctx, cipher, f, alength, adata);
+  ccm_encrypt(&amp;ctx, cipher, f, clength-tlength, dst, src);
+  ccm_digest(&amp;ctx, cipher, f, tlength, tag);
+}
+
+int
+ccm_decrypt_message(void *cipher, nettle_crypt_func *f,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength,
+	    size_t clength, uint8_t *dst, const uint8_t *src)
+{
+  struct ccm_ctx ctx;
+  uint8_t tag[CCM_BLOCK_SIZE];
+  assert(clength &gt;= tlength);
+  ccm_set_nonce(&amp;ctx, cipher, f, nlength, nonce, alength, clength-tlength, tlength);
+  ccm_update(&amp;ctx, cipher, f, alength, adata);
+  ccm_decrypt(&amp;ctx, cipher, f, clength-tlength, dst, src);
+  ccm_digest(&amp;ctx, cipher, f, tlength, tag);
+  return (memcmp(tag, src + (clength-tlength), tlength) == 0);
+}
diff --git a/ccm.h b/ccm.h
new file mode 100644
index 0000000..da10cf9
--- /dev/null
+++ b/ccm.h
@@ -0,0 +1,273 @@
+/* ccm.h
+ *
+ * Counter with CBC-MAC mode, specified by NIST,
+ * http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf
 + *
+ * NIST SP800-38C doesn't specify the particular formatting and counter generation
+ * algorithm for CCM, but it does include an example algorithm. This example
+ * has become the de-factor standard, and has been adopted by both the IETF and
+ * IEEE across a wide variety of protocols.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2014 Exegin Technologies Limited
+ * Copyright (C) 2014 Owen Kirby
+ * 
+ * Contributed by Owen Kirby
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#ifndef NETTLE_CCM_H_INCLUDED
+#define NETTLE_CCM_H_INCLUDED
+
+#include "aes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define ccm_set_nonce nettle_ccm_set_nonce
+#define ccm_update nettle_ccm_update
+#define ccm_encrypt nettle_ccm_encrypt
+#define ccm_decrypt nettle_ccm_decrypt
+#define ccm_digest nettle_ccm_digest
+#define ccm_encrypt_message nettle_ccm_encrypt_message
+#define ccm_decrypt_message nettle_ccm_decrypt_message
+
+#define ccm_aes128_set_key nettle_ccm_aes128_set_key
+#define ccm_aes128_set_nonce nettle_ccm_aes128_set_nonce
+#define ccm_aes128_update nettle_ccm_aes128_update
+#define ccm_aes128_encrypt nettle_ccm_aes128_encrypt
+#define ccm_aes128_decrypt nettle_ccm_aes128_decrypt
+#define ccm_aes128_digest nettle_ccm_aes128_digest
+#define ccm_aes128_encrypt_message nettle_ccm_aes128_encrypt_message
+#define ccm_aes128_decrypt_message nettle_ccm_aes128_decrypt_message
+
+#define ccm_aes192_set_key nettle_ccm_aes192_set_key
+#define ccm_aes192_set_nonce nettle_ccm_aes192_set_nonce
+#define ccm_aes192_update nettle_ccm_aes192_update
+#define ccm_aes192_encrypt nettle_ccm_aes192_encrypt
+#define ccm_aes192_decrypt nettle_ccm_aes192_decrypt
+#define ccm_aes192_digest nettle_ccm_aes192_digest
+#define ccm_aes192_encrypt_message nettle_ccm_aes192_encrypt_message
+#define ccm_aes192_decrypt_message nettle_ccm_aes192_decrypt_message
+
+#define ccm_aes256_set_key nettle_ccm_aes256_set_key
+#define ccm_aes256_set_nonce nettle_ccm_aes256_set_nonce
+#define ccm_aes256_update nettle_ccm_aes256_update
+#define ccm_aes256_encrypt nettle_ccm_aes256_encrypt
+#define ccm_aes256_decrypt nettle_ccm_aes256_decrypt
+#define ccm_aes256_digest nettle_ccm_aes256_digest
+#define ccm_aes256_encrypt_message nettle_ccm_aes256_encrypt_message
+#define ccm_aes256_decrypt_message nettle_ccm_aes256_decrypt_message
+
+/* For CCM, the block size of the block cipher shall be 128 bits. */
+#define CCM_BLOCK_SIZE  16
+
+/* Per-message state */
+struct ccm_ctx {
+  union nettle_block16 ctr;     /* Counter for CTR encryption. */
+  union nettle_block16 tag;     /* CBC-MAC message tag. */
+  /* Length of data processed by the CBC-MAC modulus the block size */
+  unsigned int blength;
+};
+
+/*
+ * CCM mode requires the adata and message lengths when building the IV, which
+ * prevents streaming processing and it incompatible with the AEAD API.
+ */
+void
+ccm_set_nonce(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+        size_t noncelen, const uint8_t *nonce,
+        size_t authlen, size_t msglen, size_t taglen);
+
+void
+ccm_update(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	    size_t length, const uint8_t *data);
+
+void
+ccm_encrypt(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	    size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_decrypt(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	    size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_digest(struct ccm_ctx *ctx, void *cipher, nettle_crypt_func *f,
+	   size_t length, uint8_t *digest);
+
+/*
+ * All-in-one encryption and decryption API:
+ *  tlength = sizeof(digest)
+ *  mlength = sizeof(cleartext)
+ *  clength = sizeof(ciphertext) = mlength + tlength
+ *
+ * The ciphertext will contain the encrypted payload with the message digest
+ * appended to the end.
+ */
+void
+ccm_encrypt_message(void *cipher, nettle_crypt_func *f,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength, 
+        size_t clength, uint8_t *dst, const uint8_t *src);
+
+/*
+ * The decryption function will write the plaintext to dst and parse the digest
+ * from the final tlength bytes of the ciphertext. If the digest matched the
+ * value computed during decryption then this will return 1, or it will return
+ * 0 if the digest was invalid.
+ */
+int
+ccm_decrypt_message(void *cipher, nettle_crypt_func *f,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength,
+	    size_t clength, uint8_t *dst, const uint8_t *src);
+
+/* CCM Mode with AES-128 */
+struct ccm_aes128_ctx {
+    struct ccm_ctx      ccm;
+    struct aes128_ctx   cipher;
+};
+
+void
+ccm_aes128_set_key(struct ccm_aes128_ctx *ctx, const uint8_t *key);
+
+void
+ccm_aes128_set_nonce(struct ccm_aes128_ctx *ctx,
+        size_t length, const uint8_t *nonce,
+        size_t authlen, size_t msglen, size_t taglen);
+        
+void
+ccm_aes128_update (struct ccm_aes128_ctx *ctx,
+		   size_t length, const uint8_t *data);
+
+void
+ccm_aes128_encrypt(struct ccm_aes128_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_aes128_decrypt(struct ccm_aes128_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_aes128_digest(struct ccm_aes128_ctx *ctx,
+		  size_t length, uint8_t *digest);
+
+void
+ccm_aes128_encrypt_message(struct ccm_aes128_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength,
+	    size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+ccm_aes128_decrypt_message(struct ccm_aes128_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength,
+	    size_t clength, uint8_t *dst, const uint8_t *src);
+
+struct ccm_aes192_ctx {
+    struct ccm_ctx      ccm;
+    struct aes192_ctx   cipher;
+};
+
+/* CCM Mode with AES-192 */
+void
+ccm_aes192_set_key(struct ccm_aes192_ctx *ctx, const uint8_t *key);
+
+void
+ccm_aes192_set_nonce(struct ccm_aes192_ctx *ctx,
+        size_t length, const uint8_t *nonce,
+        size_t authlen, size_t msglen, size_t taglen);
+
+void
+ccm_aes192_update(struct ccm_aes192_ctx *ctx,
+        size_t length, const uint8_t *data);
+
+void
+ccm_aes192_encrypt(struct ccm_aes192_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_aes192_decrypt(struct ccm_aes192_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_aes192_digest(struct ccm_aes192_ctx *ctx,
+		  size_t length, uint8_t *digest);
+
+void
+ccm_aes192_encrypt_message(struct ccm_aes192_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength,
+	    size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+ccm_aes192_decrypt_message(struct ccm_aes192_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength,
+        size_t clength, uint8_t *dst, const uint8_t *src);
+
+/* CCM Mode with AES-256 */
+struct ccm_aes256_ctx {
+    struct ccm_ctx      ccm;
+    struct aes256_ctx   cipher;
+};
+
+void
+ccm_aes256_set_key(struct ccm_aes256_ctx *ctx, const uint8_t *key);
+
+void
+ccm_aes256_set_nonce(struct ccm_aes256_ctx *ctx,
+        size_t length, const uint8_t *nonce,
+        size_t authlen, size_t msglen, size_t taglen);
+
+void
+ccm_aes256_update(struct ccm_aes256_ctx *ctx,
+        size_t length, const uint8_t *data);
+
+void
+ccm_aes256_encrypt(struct ccm_aes256_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_aes256_decrypt(struct ccm_aes256_ctx *ctx,
+		   size_t length, uint8_t *dst, const uint8_t *src);
+
+void
+ccm_aes256_digest(struct ccm_aes256_ctx *ctx,
+		   size_t length, uint8_t *digest);
+
+void
+ccm_aes256_encrypt_message(struct ccm_aes256_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength,
+	    size_t clength, uint8_t *dst, const uint8_t *src);
+
+int
+ccm_aes256_decrypt_message(struct ccm_aes256_ctx *ctx,
+        size_t nlength, const uint8_t *nonce, 
+        size_t alength, const uint8_t *adata, size_t tlength,
+	    size_t clength, uint8_t *dst, const uint8_t *src);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_CCM_H_INCLUDED */
diff --git a/testsuite/.gitignore b/testsuite/.gitignore
index 3b836af..8e5521b 100644
--- a/testsuite/.gitignore
+++ b/testsuite/.gitignore
@@ -11,6 +11,7 @@
 /camellia-test
 /cast128-test
 /cbc-test
+/ccm-test
 /ctr-test
 /cxx-test
 /des-compat-test
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 43079ec..16d107c 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -100,6 +100,9 @@ knuth-lfib-test$(EXEEXT): knuth-lfib-test.$(OBJEXT)
 cbc-test$(EXEEXT): cbc-test.$(OBJEXT)
 	$(LINK) cbc-test.$(OBJEXT) $(TEST_OBJS) -o cbc-test$(EXEEXT)
 
+ccm-test$(EXEEXT): ccm-test.$(OBJEXT)
+	$(LINK) ccm-test.$(OBJEXT) $(TEST_OBJS) -o ccm-test$(EXEEXT)
+
 ctr-test$(EXEEXT): ctr-test.$(OBJEXT)
 	$(LINK) ctr-test.$(OBJEXT) $(TEST_OBJS) -o ctr-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index d59a2cb..30611c7 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -25,7 +25,7 @@ TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    sha3-384-test.c sha3-512-test.c \
 		    serpent-test.c twofish-test.c \
 		    knuth-lfib-test.c \
-		    cbc-test.c ctr-test.c gcm-test.c eax-test.c \
+		    cbc-test.c ctr-test.c gcm-test.c eax-test.c ccm-test.c \
 		    poly1305-test.c chacha-poly1305-test.c \
 		    hmac-test.c umac-test.c \
 		    meta-hash-test.c meta-cipher-test.c meta-armor-test.c \
diff --git a/testsuite/ccm-test.c b/testsuite/ccm-test.c
new file mode 100644
index 0000000..845d27f
--- /dev/null
+++ b/testsuite/ccm-test.c
@@ -0,0 +1,713 @@
+/* ccm-test.c
+ *
+ * Self-test and vectors for CCM mode ciphers using AES-128 and AES-256. The
+ * test vectors have been collected from the following standards:
+ *  NIST SP800-38C
+ *  RFC 3610
+ *  IEEE 802.15.4-2011
+ *  IEEE P1619.1/D22 July 2007 (draft version)
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2014 Exegin Technologies Limited
+ * Copyright (C) 2014 Owen Kirby
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+#include "testutils.h"
+#include "aes.h"
+#include "ccm.h"
+#include "knuth-lfib.h"
+
+static void
+test_compare_results(const char *name,
+        const struct tstring *adata,
+        /* Expected results. */
+        const struct tstring *e_clear,
+		const struct tstring *e_cipher,
+        /* Actual results. */
+        const void *clear,
+        const void *cipher,
+        const void *digest) /* digest optional. */
+{
+  int tlength = (e_cipher-&gt;length - e_clear-&gt;length);
+  if (digest &amp;&amp; tlength &amp;&amp; !MEMEQ(tlength, e_cipher-&gt;data + e_clear-&gt;length, \
digest)) +    {
+      fprintf(stderr, "%s digest failed:\nAdata:", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(tlength, digest);
+      fprintf(stderr, "\nExpected:");
+      print_hex(tlength, e_cipher-&gt;data + e_clear-&gt;length);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  if (!MEMEQ(e_cipher-&gt;length, e_cipher-&gt;data, cipher))
+    {
+      fprintf(stderr, "%s: encryption failed\nAdata: ", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_cipher-&gt;length, cipher);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_cipher);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+  if (!MEMEQ(e_clear-&gt;length, e_clear-&gt;data, clear))
+    {
+      fprintf(stderr, "%s decrypt failed:\nAdata:", name);
+      tstring_print_hex(adata);
+      fprintf(stderr, "\nInput: ");
+      tstring_print_hex(e_cipher);
+      fprintf(stderr, "\nOutput: ");
+      print_hex(e_clear-&gt;length, clear);
+      fprintf(stderr, "\nExpected:");
+      tstring_print_hex(e_clear);
+      fprintf(stderr, "\n");
+      FAIL();
+    }
+} /* test_compare_results */
+
+static void
+test_cipher_ccm(const struct nettle_cipher *cipher,
+		const struct tstring *key,
+		const struct tstring *nonce,
+        const struct tstring *authdata,
+        int repeat,
+        const struct tstring *cleartext,
+		const struct tstring *ciphertext)
+{
+  void *ctx = xalloc(cipher-&gt;context_size);
+  uint8_t *en_data;
+  uint8_t *de_data;
+  uint8_t *en_digest;
+  uint8_t de_digest[CCM_BLOCK_SIZE];
+  size_t tlength;
+  struct ccm_ctx ccm;
+  int    i;
+
+  ASSERT (key-&gt;length == cipher-&gt;key_size);
+  ASSERT (cleartext-&gt;length &lt;= ciphertext-&gt;length);
+  ASSERT ((cleartext-&gt;length + CCM_BLOCK_SIZE) &gt;= ciphertext-&gt;length);
+  tlength = ciphertext-&gt;length - cleartext-&gt;length;
+  if (!authdata) repeat = 0;
+  
+  de_data = xalloc(cleartext-&gt;length);
+  en_data = xalloc(ciphertext-&gt;length);
+  en_digest = en_data + cleartext-&gt;length;
+  cipher-&gt;set_encrypt_key(ctx, key-&gt;data);
+  
+  /* Encrypt using the incremental API. */
+  ccm_set_nonce(&amp;ccm, ctx, cipher-&gt;encrypt, nonce-&gt;length, nonce-&gt;data,
+        authdata-&gt;length * repeat, cleartext-&gt;length, tlength);
+  for (i = 0; i &lt; repeat; i++) {
+    ccm_update(&amp;ccm, ctx, cipher-&gt;encrypt, authdata-&gt;length, authdata-&gt;data);
+  }
+  ccm_encrypt(&amp;ccm, ctx, cipher-&gt;encrypt, cleartext-&gt;length, en_data, \
cleartext-&gt;data); +  ccm_digest(&amp;ccm, ctx, cipher-&gt;encrypt, tlength, en_digest);
+  
+  /* Decrypt using the incremental API. */
+  ccm_set_nonce(&amp;ccm, ctx, cipher-&gt;encrypt, nonce-&gt;length, nonce-&gt;data,
+        authdata-&gt;length * repeat, cleartext-&gt;length, tlength);
+  for (i = 0; i &lt; repeat; i++) {
+    ccm_update(&amp;ccm, ctx, cipher-&gt;encrypt, authdata-&gt;length, authdata-&gt;data);
+  }
+  ccm_decrypt(&amp;ccm, ctx, cipher-&gt;encrypt, cleartext-&gt;length, de_data, \
ciphertext-&gt;data); +  ccm_digest(&amp;ccm, ctx, cipher-&gt;encrypt, tlength, de_digest);
+  
+  /* Compare results using the generic API. */
+  test_compare_results("CCM", authdata,
+        cleartext, ciphertext, de_data, en_data, de_digest);
+  
+  /* Ensure we get the same answers using the all-in-one API. */
+  if (repeat &lt;= 1) {
+    int ret;
+    memset(de_data, 0, cleartext-&gt;length);
+    memset(en_data, 0, ciphertext-&gt;length);
+    memset(de_digest, 0, sizeof(de_digest));
+    
+    ccm_encrypt_message(ctx, cipher-&gt;encrypt, nonce-&gt;length, nonce-&gt;data,
+        authdata-&gt;length, authdata-&gt;data, tlength, ciphertext-&gt;length, en_data, \
cleartext-&gt;data); +    
+    ret = ccm_decrypt_message(ctx, cipher-&gt;encrypt, nonce-&gt;length, nonce-&gt;data,
+        authdata-&gt;length, authdata-&gt;data, tlength, ciphertext-&gt;length, de_data, \
ciphertext-&gt;data); +
+    if (ret != 1) fprintf(stderr, "ccm_decrypt_message failed to validate \
message\n"); +    test_compare_results("CCM_MSG", authdata,
+        cleartext, ciphertext, de_data, en_data, NULL);
+      
+    /* Ensure that we can detect corrupted message or tag data. */
+    if (tlength) {
+      en_data[0] ^= 1;
+      ret = ccm_decrypt_message(ctx, cipher-&gt;encrypt, nonce-&gt;length, nonce-&gt;data,
+          authdata-&gt;length, authdata-&gt;data, tlength, ciphertext-&gt;length, de_data, \
en_data); +      if (ret != 0) fprintf(stderr, "ccm_decrypt_message failed to detect \
corrupted message\n"); +    }
+    /* Ensure we can detect corrupted adata. */
+    if (tlength &amp;&amp; authdata-&gt;length) {
+      ret = ccm_decrypt_message(ctx, cipher-&gt;encrypt, nonce-&gt;length, nonce-&gt;data,
+          authdata-&gt;length-1, authdata-&gt;data, tlength, ciphertext-&gt;length, de_data, \
ciphertext-&gt;data); +      if (ret != 0) fprintf(stderr, "ccm_decrypt_message failed \
to detect corrupted message\n"); +    }
+  }
+  
+  /* Ensure we get the same answers using the per-cipher API. */
+  if (cipher == &amp;nettle_aes128) {
+    struct ccm_aes128_ctx aes;
+    memset(de_data, 0, cleartext-&gt;length);
+    memset(en_data, 0, ciphertext-&gt;length);
+    memset(de_digest, 0, sizeof(de_digest));
+    
+    /* AES-128 encrypt. */
+    ccm_aes128_set_key(&amp;aes, key-&gt;data);
+    ccm_aes128_set_nonce(&amp;aes, nonce-&gt;length, nonce-&gt;data,
+        authdata-&gt;length * repeat, cleartext-&gt;length, tlength);
+    for (i = 0; i &lt; repeat; i++) {
+      ccm_aes128_update(&amp;aes, authdata-&gt;length, authdata-&gt;data);
+    }
+    ccm_aes128_encrypt(&amp;aes, cleartext-&gt;length, en_data, cleartext-&gt;data);
+    ccm_aes128_digest(&amp;aes, tlength, en_digest);
+    
+    /* AES-128 decrypt. */
+    ccm_aes128_set_nonce(&amp;aes, nonce-&gt;length, nonce-&gt;data,
+        authdata-&gt;length * repeat, cleartext-&gt;length, tlength);
+    for (i = 0; i &lt; repeat; i++) {
+      ccm_aes128_update(&amp;aes, authdata-&gt;length, authdata-&gt;data);
+    }
+    ccm_aes128_decrypt(&amp;aes, cleartext-&gt;length, de_data, ciphertext-&gt;data);
+    ccm_aes128_digest(&amp;aes, tlength, de_digest);
+    
+    test_compare_results("CCM_AES_128", authdata,
+        cleartext, ciphertext, de_data, en_data, de_digest);
+  }
+  /* TODO: I couldn't find any test cases for CCM-AES-192 */
+  if (cipher == &amp;nettle_aes256) {
+    struct ccm_aes256_ctx aes;
+    memset(de_data, 0, cleartext-&gt;length);
+    memset(en_data, 0, ciphertext-&gt;length);
+    memset(de_digest, 0, sizeof(de_digest));
+    
+    /* AES-256 encrypt. */
+    ccm_aes256_set_key(&amp;aes, key-&gt;data);
+    ccm_aes256_set_nonce(&amp;aes, nonce-&gt;length, nonce-&gt;data,
+        authdata-&gt;length * repeat, cleartext-&gt;length, tlength);
+    for (i = 0; i &lt; repeat; i++) {
+      ccm_aes256_update(&amp;aes, authdata-&gt;length, authdata-&gt;data);
+    }
+    ccm_aes256_encrypt(&amp;aes, cleartext-&gt;length, en_data, cleartext-&gt;data);
+    ccm_aes256_digest(&amp;aes, tlength, en_digest);
+    
+    /* AES-256 decrypt. */
+    ccm_aes256_set_nonce(&amp;aes, nonce-&gt;length, nonce-&gt;data,
+        authdata-&gt;length * repeat, cleartext-&gt;length, tlength);
+    for (i = 0; i &lt; repeat; i++) {
+      ccm_aes256_update(&amp;aes, authdata-&gt;length, authdata-&gt;data);
+    }
+    ccm_aes256_decrypt(&amp;aes, cleartext-&gt;length, de_data, ciphertext-&gt;data);
+    ccm_aes256_digest(&amp;aes, tlength, de_digest);
+    
+    test_compare_results("CCM_AES_256", authdata,
+        cleartext, ciphertext, de_data, en_data, de_digest);
+  }
+  
+  free(ctx);
+  free(en_data);
+  free(de_data);
+}
+
+void
+test_main(void)
+{
+  /* Create a pattern of 00010203 04050607 08090a00b 0c0d0e0f ... */
+  struct tstring *adata;
+  unsigned int i;
+  adata = tstring_alloc(256);
+  for (i=0; i&lt;adata-&gt;length; i++) adata-&gt;data[i] = (i &amp; 0xff);
+    
+  /* From NIST spec 800-38C on AES modes.
+   *
+   * Appendix C: Example Vectors 
+   */
+  /*
+   * C.1 Example 1
+   * Klen = 128, Tlen = 32, Nlen = 56, Alen = 64, Plen = 32
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("404142434445464748494a4b4c4d4e4f"),
+        SHEX("10111213141516"),
+        SHEX("0001020304050607"), 1,
+        SHEX("20212223"),
+        SHEX("7162015b"
+             "4dac255d"));
+
+  /*
+   * C.2 Example 2
+   * Klen = 128, Tlen = 48, Nlen = 64, Alen = 128, Plen = 128
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("404142434445464748494a4b4c4d4e4f"),
+        SHEX("1011121314151617"),
+        SHEX("000102030405060708090a0b0c0d0e0f"), 1,
+        SHEX("202122232425262728292a2b2c2d2e2f"),
+        SHEX("d2a1f0e051ea5f62081a7792073d593d"
+             "1fc64fbfaccd"));
+
+  /*
+   * C.3 Example 3
+   * Klen = 128, Tlen = 64, Nlen = 96, Alen = 160, Plen = 192
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("404142434445464748494a4b4c4d4e4f"),
+        SHEX("101112131415161718191a1b"),
+        SHEX("000102030405060708090a0b0c0d0e0f"
+             "10111213"), 1,
+        SHEX("202122232425262728292a2b2c2d2e2f"
+             "3031323334353637"),
+        SHEX("e3b201a9f5b71a7a9b1ceaeccd97e70b"
+             "6176aad9a4428aa5 484392fbc1b09951"));
+
+  /*
+   * C.4 Example 4
+   * Klen = 128, Tlen = 112, Nlen = 104, Alen = 524288, Plen = 256
+   * A = 00010203 04050607 08090a0b 0c0d0e0f
+   *     10111213 ...
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("404142434445464748494a4b4c4d4e4f"),
+        SHEX("101112131415161718191a1b1c"),
+        adata, 256,
+        SHEX("202122232425262728292a2b2c2d2e2f"
+             "303132333435363738393a3b3c3d3e3f"),
+        SHEX("69915dad1e84c6376a68c2967e4dab61"
+             "5ae0fd1faec44cc484828529463ccf72"
+             "b4ac6bec93e8598e7f0dadbcea5b"));
+
+  /* From RFC 3610
+   *
+   * Section 8: Test Vectors
+   * Packet Vector #1
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 03  02 01 00 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07"), 1,
+        SHEX("08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D \
1E"), +        SHEX("58 8C 97 9A  61 C6 63 D2  F0 66 D0 C2  C0 F9 89 80  6D 5F 6B 61  \
DA C3 84" +             "17 E8 D1 2C  FD F9 26 E0"));
+
+  /*
+   * Packet Vector #2
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 04  03 02 01 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07"), 1,
+        SHEX("08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D \
1E 1F"), +        SHEX("72 C9 1A 36  E1 35 F8 CF  29 1C A8 94  08 5C 87 E3  CC 15 C4 \
39  C9 E4 3A 3B"  +             "A0 91 D5 6E  10 40 09 16"));
+
+  /*
+   * Packet Vector #3
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 05  04 03 02 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07"), 1,
+        SHEX("08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D \
1E 1F  20"), +        SHEX("51 B1 E5 F4  4A 19 7D 1D  A4 6B 0F 8E  2D 28 2A E8  71 E8 \
38 BB  64 DA 85 96  57" +             "4A DA A7 6F  BD 9F B0 C5"));
+
+  /*
+   * Packet Vector #4
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 06  05 04 03 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07  08 09 0A 0B"), 1,
+        SHEX("0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E"),
+        SHEX("A2 8C 68 65  93 9A 9A 79  FA AA 5C 4C  2A 9D 4A 91  CD AC 8C"
+             "96 C8 61 B9  C9 E6 1E F1"));
+
+  /*
+   * Packet Vector #5
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 07  06 05 04 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07  08 09 0A 0B"), 1,
+        SHEX("0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F"),
+        SHEX("DC F1 FB 7B  5D 9E 23 FB  9D 4E 13 12  53 65 8A D8  6E BD CA 3E"
+             "51 E8 3F 07  7D 9C 2D 93"));
+        
+  /*
+   * Packet Vector #6
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 08  07 06 05 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07  08 09 0A 0B"), 1,
+        SHEX("0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F  20"),
+        SHEX("6F C1 B0 11  F0 06 56 8B  51 71 A4 2D  95 3D 46 9B  25 70 A4 BD  87"
+             "40 5A 04 43  AC 91 CB 94"));
+
+  /*
+   * Packet Vector #7
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 09  08 07 06 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07"), 1,
+        SHEX("08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D \
1E"), +        SHEX("01 35 D1 B2  C9 5F 41 D5  D1 D4 FE C1  85 D1 66 B8  09 4E 99 9D  \
FE D9 6C" +             "04 8C 56 60  2C 97 AC BB  74 90"));
+
+  /*
+   * Packet Vector #8
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 0A  09 08 07 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07"), 1,
+        SHEX("08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D \
1E 1F"), +        SHEX("7B 75 39 9A  C0 83 1D D2  F0 BB D7 58  79 A2 FD 8F  6C AE 6B \
6C  D9 B7 DB 24" +             "C1 7B 44 33  F4 34 96 3F  34 B4"));
+
+  /*
+   * Packet Vector #9
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 0B  0A 09 08 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07"), 1,
+        SHEX("08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D \
1E 1F  20"), +        SHEX("82 53 1A 60  CC 24 94 5A  4B 82 79 18  1A B5 C8 4D  F2 1C \
E7 F9  B7 3F 42 E1  97" +             "EA 9C 07 E5  6B 5E B1 7E  5F 4E"));
+
+  /*
+   * Packet Vector #10
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 0C  0B 0A 09 A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07  08 09 0A 0B"), 1,
+        SHEX("0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E"),
+        SHEX("07 34 25 94  15 77 85 15  2B 07 40 98  33 0A BB 14  1B 94 7B"
+             "56 6A A9 40  6B 4D 99 99  88 DD"));
+
+  /*
+   * Packet Vector #11
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 0D  0C 0B 0A A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07  08 09 0A 0B"), 1,
+        SHEX("0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F"),
+        SHEX("67 6B B2 03  80 B0 E3 01  E8 AB 79 59  0A 39 6D A7  8B 83 49 34"
+             "F5 3A A2 E9  10 7A 8B 6C  02 2C"));
+
+  /*
+   * Packet Vector #12
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF"),
+        SHEX("00 00 00 0E  0D 0C 0B A0  A1 A2 A3 A4  A5"),
+        SHEX("00 01 02 03  04 05 06 07  08 09 0A 0B"), 1,
+        SHEX("0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F  20"),
+        SHEX("C0 FF A0 D6  F0 5B DB 67  F2 4D 43 A4  33 8D 2A A4  BE D7 B2 0E  43"
+             "CD 1A A3 16  62 E7 AD 65  D6 DB"));
+
+  /*
+   * Packet Vector #13
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 41 2B 4E  A9 CD BE 3C  96 96 76 6C  FA"),
+        SHEX("0B E1 A8 8B  AC E0 18 B1"), 1,
+        SHEX("08 E8 CF 97  D8 20 EA 25  84 60 E9 6A  D9 CF 52 89  05 4D 89 5C  EA C4 \
7C"), +        SHEX("4C B9 7F 86  A2 A4 68 9A  87 79 47 AB  80 91 EF 53  86 A6 FF BD  \
D0 80 F8" +             "E7 8C F7 CB  0C DD D7 B3"));
+
+  /*
+   * Packet Vector #14
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 33 56 8E  F7 B2 63 3C  96 96 76 6C  FA"),
+        SHEX("63 01 8F 76  DC 8A 1B CB"), 1,
+        SHEX("90 20 EA 6F  91 BD D8 5A  FA 00 39 BA  4B AF F9 BF  B7 9C 70 28  94 9C \
D0 EC"), +        SHEX("4C CB 1E 7C  A9 81 BE FA  A0 72 6C 55  D3 78 06 12  98 C8 5C \
92  81 4A BC 33" +             "C5 2E E8 1D  7D 77 C0 8A"));
+
+  /*
+   * Packet Vector #15
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 10 3F E4  13 36 71 3C  96 96 76 6C  FA"),
+        SHEX("AA 6C FA 36  CA E8 6B 40"), 1,
+        SHEX("B9 16 E0 EA  CC 1C 00 D7  DC EC 68 EC  0B 3B BB 1A  02 DE 8A 2D  1A A3 \
46 13  2E"), +        SHEX("B1 D2 3A 22  20 DD C0 AC  90 0D 9A A0  3C 61 FC F4  A5 59 \
A4 41  77 67 08 97  08" +             "A7 76 79 6E  DB 72 35 06"));
+
+  /*
+   * Packet Vector #16
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 76 4C 63  B8 05 8E 3C  96 96 76 6C  FA"),
+        SHEX("D0 D0 73 5C  53 1E 1B EC  F0 49 C2 44"), 1,
+        SHEX("12 DA AC 56  30 EF A5 39  6F 77 0C E1  A6 6B 21 F7  B2 10 1C"),
+        SHEX("14 D2 53 C3  96 7B 70 60  9B 7C BB 7C  49 91 60 28  32 45 26"
+             "9A 6F 49 97  5B CA DE AF"));
+
+  /*
+   * Packet Vector #17
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 F8 B6 78  09 4E 3B 3C  96 96 76 6C  FA"),
+        SHEX("77 B6 0F 01  1C 03 E1 52  58 99 BC AE"), 1,
+        SHEX("E8 8B 6A 46  C7 8D 63 E5  2E B8 C5 46  EF B5 DE 6F  75 E9 CC 0D"),
+        SHEX("55 45 FF 1A  08 5E E2 EF  BF 52 B2 E0  4B EE 1E 23  36 C7 3E 3F"
+             "76 2C 0C 77  44 FE 7E 3C"));
+
+  /*
+   * Packet Vector #18
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 D5 60 91  2D 3F 70 3C  96 96 76 6C  FA"),
+        SHEX("CD 90 44 D2  B7 1F DB 81  20 EA 60 C0"), 1,
+        SHEX("64 35 AC BA  FB 11 A8 2E  2F 07 1D 7C  A4 A5 EB D9  3A 80 3B A8  7F"),
+        SHEX("00 97 69 EC  AB DF 48 62  55 94 C5 92  51 E6 03 57  22 67 5E 04  C8"
+             "47 09 9E 5A  E0 70 45 51"));
+
+  /*
+   * Packet Vector #19
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 42 FF F8  F1 95 1C 3C  96 96 76 6C  FA"),
+        SHEX("D8 5B C7 E6  9F 94 4F B8"), 1,
+        SHEX("8A 19 B9 50  BC F7 1A 01  8E 5E 67 01  C9 17 87 65  98 09 D6 7D  BE DD \
18"), +        SHEX("BC 21 8D AA  94 74 27 B6  DB 38 6A 99  AC 1A EF 23  AD E0 B5 29  \
39 CB 6A" +             "63 7C F9 BE  C2 40 88 97  C6 BA"));
+
+  /*
+   * Packet Vector #20
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 92 0F 40  E5 6C DC 3C  96 96 76 6C  FA"),
+        SHEX("74 A0 EB C9  06 9F 5B 37"), 1,
+        SHEX("17 61 43 3C  37 C5 A3 5F  C1 F3 9F 40  63 02 EB 90  7C 61 63 BE  38 C9 \
84 37"), +        SHEX("58 10 E6 FD  25 87 40 22  E8 03 61 A4  78 E3 E9 CF  48 4A B0 \
4F  44 7E FF F6" +             "F0 A4 77 CC  2F C9 BF 54  89 44"));
+
+  /*
+   * Packet Vector #21
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 27 CA 0C  71 20 BC 3C  96 96 76 6C  FA"),
+        SHEX("44 A3 AA 3A  AE 64 75 CA"), 1,
+        SHEX("A4 34 A8 E5  85 00 C6 E4  15 30 53 88  62 D6 86 EA  9E 81 30 1B  5A E4 \
22 6B  FA"), +        SHEX("F2 BE ED 7B  C5 09 8E 83  FE B5 B3 16  08 F8 E2 9C  38 81 \
9A 89  C8 E7 76 F1  54" +             "4D 41 51 A4  ED 3A 8B 87  B9 CE"));
+
+  /*
+   * Packet Vector #22
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 5B 8C CB  CD 9A F8 3C  96 96 76 6C  FA"),
+        SHEX("EC 46 BB 63  B0 25 20 C3  3C 49 FD 70"), 1,
+        SHEX("B9 6B 49 E2  1D 62 17 41  63 28 75 DB  7F 6C 92 43  D2 D7 C2"),
+        SHEX("31 D7 50 A0  9D A3 ED 7F  DD D4 9A 20  32 AA BF 17  EC 8E BF"
+             "7D 22 C8 08  8C 66 6B E5  C1 97"));
+
+  /*
+   * Packet Vector #23
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 3E BE 94  04 4B 9A 3C  96 96 76 6C  FA"),
+        SHEX("47 A6 5A C7  8B 3D 59 42  27 E8 5E 71"), 1,
+        SHEX("E2 FC FB B8 80 44 2C 73  1B F9 51 67  C8 FF D7 89  5E 33 70 76"),
+        SHEX("E8 82 F1 DB D3 8C E3 ED  A7 C2 3F 04  DD 65 07 1E  B4 13 42 AC"
+             "DF 7E 00 DC  CE C7 AE 52  98 7D"));
+
+  /*
+   * Packet Vector #24
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B"),
+        SHEX("00 8D 49 3B  30 AE 8B 3C  96 96 76 6C  FA"),
+        SHEX("6E 37 A6 EF  54 6D 95 5D  34 AB 60 59"), 1,
+        SHEX("AB F2 1C 0B  02 FE B8 8F  85 6D F4 A3  73 81 BC E3  CC 12 85 17  D4"),
+        SHEX("F3 29 05 B8  8A 64 1B 04  B9 C9 FF B5  8C C3 90 90  0F 3D A1 2A  B1"
+             "6D CE 9E 82  EF A1 6D A6  20 59"));
+
+  /* From IEEE 802.15.4-2011
+   *
+   * Annex C: Test vectors for cryptographic building blocks
+   * C.2.1  MAC beacon frame
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF"),
+        SHEX("AC DE 48 00 00 00 00 01 00 00 00 05 02"),
+        SHEX("08 D0 84 21 43 01 00 00 00 00 48 DE AC 02 05 00 00 00 55 CF 00 00 51 \
52 53 54"), 1, +        SHEX(""),
+        SHEX("22 3B C1 EC 84 1A B5 53"));
+
+  /*
+   * C.2.2 MAC data frame
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF"),
+        SHEX("AC DE 48 00 00 00 00 01 00 00 00 05 04"),
+        SHEX("69 DC 84 21 43 02 00 00 00 00 48 DE AC 01 00 00 00 00 48 DE AC 04 05 \
00 00 00"), 1, +        SHEX("61 62 63 64"),
+        SHEX("D4 3E 02 2B"));
+
+  /*
+   * C.2.3 MAC command frame
+   */
+  test_cipher_ccm(&amp;nettle_aes128,
+        SHEX("C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF"),
+        SHEX("AC DE 48 00 00 00 00 01 00 00 00 05 06"),
+        SHEX("2B DC 84 21 43 02 00 0000 00 48 DE AC FF FF 01 00 00 00 00 48 DE AC 06 \
05 00 00 00 01"), 1, +        SHEX("CE"),
+        SHEX("D8 4F DE 52 90 61 F9 C6 F1"));
+
+  /* From IEEE P1619.1/D22 July 2007 (draft version)
+   *
+   * Annex D: Test Vectors
+   * D.2.1 CCM-128-AES-256 test vector 1
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("0000000000000000000000000000000000000000000000000000000000000000"),
+        SHEX("000000000000000000000000"),
+        SHEX(""), 0,
+        SHEX("00000000000000000000000000000000"),
+        SHEX("c1944044c8e7aa95d2de9513c7f3dd8c"
+             "4b0a3e5e51f151eb0ffae7c43d010fdb"));
+
+  /*
+   * D.2.2 CCM-128-AES-256 test vector 2
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("0000000000000000000000000000000000000000000000000000000000000000"),
+        SHEX("000000000000000000000000"),
+        SHEX("00000000000000000000000000000000"), 1,
+        SHEX(""),
+        SHEX("904704e89fb216443cb9d584911fc3c2"));
+
+  /*
+   * D.2.3 CCM-128-AES-256 test vector 3
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("0000000000000000000000000000000000000000000000000000000000000000"),
+        SHEX("000000000000000000000000"),
+        SHEX("00000000000000000000000000000000"), 1,
+        SHEX("00000000000000000000000000000000"),
+        SHEX("c1944044c8e7aa95d2de9513c7f3dd8c"
+             "87314e9c1fa01abe6a6415943dc38521"));
+
+  /*
+   * D.2.4 CCM-128-AES-256 test vector 4
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("fb7615b23d80891dd470980bc79584c8b2fb64ce60978f4d17fce45a49e830b7"),
+        SHEX("dbd1a3636024b7b402da7d6f"),
+        SHEX(""), 0,
+        SHEX("a845348ec8c5b5f126f50e76fefd1b1e"),
+        SHEX("cc881261c6a7fa72b96a1739176b277f"
+             "3472e1145f2c0cbe146349062cf0e423"));
+
+  /*
+   * D.2.5 CCM-128-AES-256 test vector 5
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f"),
+        SHEX("101112131415161718191a1b"),
+        SHEX("000102030405060708090a0b0c0d0e0f10111213"), 1,
+        SHEX("202122232425262728292a2b2c2d2e2f3031323334353637"),
+        SHEX("04f883aeb3bd0730eaf50bb6de4fa2212034e4e41b0e75e5"
+             "9bba3f3a107f3239bd63902923f80371"));
+
+  /*
+   * D.2.6 CCM-128-AES-256 test vector 6
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f"),
+        SHEX("101112131415161718191a1b"),
+        adata, 256,
+        SHEX("202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f"),
+        SHEX("04f883aeb3bd0730eaf50bb6de4fa2212034e4e41b0e75e577f6bf2422c0f6d2"
+             "3376d2cf256ef613c56454cbb5265834"));
+
+  /*
+   * D.2.7 CCM-128-AES-256 test vector 7
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f"),
+        SHEX("101112131415161718191a1b"),
+        SHEX("202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f"), 1,
+        SHEX("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
+             "202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f"
+             "404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f"
+             "606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f"
+             "808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f"
+             "a0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
+             "c0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedf"
+             "e0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"),
+        SHEX("24d8a38e939d2710cad52b96fe6f82010014c4c43b2e55c557d69f0402e0d6f2"
+             "06c53d6cbd3f1c3c6de5dcdcad9fb74f25741dea741149fe4278a0cc24741e86"
+             "58cc0523b8d7838c60fb1de4b7c3941f5b26dea9322aa29656ec37ac18a9b108"
+             "a6f38b7917f5a9c398838b22afbd17252e96694a9e6237964a0eae21c0a6e152"
+             "15a0e82022926be97268249599e456e05029c3ebc07d78fc5b4a0862e04e68c2"
+             "9514c7bdafc4b52e04833bf30622e4eb42504a44a9dcbc774752de7bb82891ad"
+             "1eba9dc3281422a8aba8654268d3d9c81705f4c5a531ef856df5609a159af738"
+             "eb753423ed2001b8f20c23725f2bef18c409f7e52132341f27cb8f0e79894dd9"
+            "ebb1fa9d28ccfe21bdfea7e6d91e0bab"));
+
+  /*
+   * D.2.8 CCM-128-AES-256 test vector 8
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("fb7615b23d80891dd470980bc79584c8b2fb64ce6097878d17fce45a49e830b7"),
+        SHEX("dbd1a3636024b7b402da7d6f"),
+        SHEX("36"), 1,
+        SHEX("a9"),
+        SHEX("9d3261b1cf931431e99a32806738ecbd2a"));
+
+  /*
+   * D.2.9 CCM-128-AES-256 test vector 9
+   */
+  test_cipher_ccm(&amp;nettle_aes256,
+        SHEX("f8d476cfd646ea6c2384cb1c27d6195dfef1a9f37b9c8d21a79c21f8cb90d289"),
+        SHEX("dbd1a3636024b7b402da7d6f"),
+        SHEX("7bd859a247961a21823b380e9fe8b65082ba61d3"), 1,
+        SHEX("90ae61cf7baebd4cade494c54a29ae70269aec71"),
+        SHEX("6c05313e45dc8ec10bea6c670bd94f31569386a6"
+             "8f3829e8e76ee23c04f566189e63c686"));
+}
-- 
1.7.9.5


</body></email><email><emailId>20140323180604</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-23 18:06:04-0400</timestampReceived><subject>Re: [PATCH v3] CCM Cipher Modes</subject><body>

Owen Kirby &lt;osk@exegin.com&gt; writes:

&gt; Latest round of changes to the CCM modes, this moves the processing of L(a) into
&gt; ccm_set_nonce() and updates the all-at-once API to concatenate the ciphertext and
&gt; digest together.

Pushed now, with some smaller changes. All uses of nettle_crypt_func are
replaced by nettle_cipher_func (introduced last week), and the cipher
context arguments accordingly changed to const. And some tweaks of
indentation and line breaks.

Documentation remains to do.

Thanks,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140314210258</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-14 21:02:58-0400</timestampReceived><subject>Backwards compatibility (was Re: dsa_generate_keypair)</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt;  It would be nice if the new interface is api compatible with the old
&gt; one; especially if that would be possible with macros such as the one
&gt; you show, so that compatibility bloat doesn't need to be included in
&gt; the library.

[...]

&gt; I thought that this was used to keep API compatibility. I don't think
&gt; it makes sense to introduce new APIs that are close to old APIs. There
&gt; is already a new API.

You have a good point there.

I really not sure about the best way to go about it. Another option
might be to purge all deprecated stuff from dsa.h, and put it into a new
file dsa-compat.h. Main practical advantage would be that dsa-compat.h
can then also tweak the name mangling of dsa_generate_keypair, so that
if you include this file, it refers to a function compatible with the
previous version.

Then applications that want to stick to the old interface (in order to
support both old and new nettle) could get that reasonably easy, with a

  #include &lt;nettle/dsa.h&gt;
  #if HAVE_NETTLE_DSA_COMPAT_H
  #include &lt;nettle/dsa-compat.h&gt;
  #endif

And speaking of *-compat.h files, does anybody use rsa-compat.h
(RSAREF-compatible interface) or des-compat.h (libdes-compatible
interface)?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140325160052</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-03-25 16:00:52-0400</timestampReceived><subject>Re: Backwards compatibility (was Re: dsa_generate_keypair)</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I really not sure about the best way to go about it. Another option
&gt; might be to purge all deprecated stuff from dsa.h, and put it into a new
&gt; file dsa-compat.h.

I've now done this, and pushed it on the dsa-reorg branch. I also killed
struct dsa_value. The new advertised interface is now like

int
dsa_sign(const struct dsa_params *params,
	 const mpz_t priv,
	 void *random_ctx, nettle_random_func *random,
	 size_t digest_size,
	 const uint8_t *digest,
	 struct dsa_signature *signature);

int
dsa_verify(const struct dsa_params *params,
	   const mpz_t pub,
	   size_t digest_size,
	   const uint8_t *digest,
	   const struct dsa_signature *signature);

Unless there are objections, I think I'm going to merge this to the
master branch as soon as I get the time. (Most likely a manual merge, to
avoid checking in dead ends). We really need to get this over with.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140411133939</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-04-11 13:39:39-0400</timestampReceived><subject>Re: [PATCH v3] CCM Cipher Modes</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Pushed now, with some smaller changes.

I get a couple of warnings, when compiling for 32-bit platforms, e.g.,
ARM.

/home/nisse/hack/nettle/ccm.c: In function `nettle_ccm_set_nonce':
/home/nisse/hack/nettle/ccm.c:134:3: warning: comparison is always false due to \
                limited range of data type [-Wtype-limits]
/home/nisse/hack/nettle/ccm.c:138:5: warning: right shift count &gt;= width of type \
                [enabled by default]
/home/nisse/hack/nettle/ccm.c:139:5: warning: right shift count &gt;= width of type \
                [enabled by default]
/home/nisse/hack/nettle/ccm.c:140:5: warning: right shift count &gt;= width of type \
                [enabled by default]
/home/nisse/hack/nettle/ccm.c:141:5: warning: right shift count &gt;= width of type \
[enabled by default]

As long as it's "always false", the code should be correct, but it would
be nice to get rid of these warnings.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140411172324</emailId><senderName>Owen Kirby</senderName><senderEmail>osk@exegin.com</senderEmail><timestampReceived>2014-04-11 17:23:24-0400</timestampReceived><subject>Re: [PATCH v3] CCM Cipher Modes</subject><body>

Actually, that's not entirely correct. I have seen some architectures
that will turn a shift into a nop when the shift width is greater than
the word size. I have some ARM boards that I can cross compile for, so
I'll take a look at cleaning up the warnings when I get some time this
weekend.

Thanks,
Owen

On 14-04-11 06:39 AM, Niels Möller wrote:
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt; &gt; Pushed now, with some smaller changes.
&gt; I get a couple of warnings, when compiling for 32-bit platforms, e.g.,
&gt; ARM.
&gt; 
&gt; /home/nisse/hack/nettle/ccm.c: In function `nettle_ccm_set_nonce':
&gt; /home/nisse/hack/nettle/ccm.c:134:3: warning: comparison is always false due to \
&gt;                 limited range of data type [-Wtype-limits]
&gt; /home/nisse/hack/nettle/ccm.c:138:5: warning: right shift count &gt;= width of type \
&gt;                 [enabled by default]
&gt; /home/nisse/hack/nettle/ccm.c:139:5: warning: right shift count &gt;= width of type \
&gt;                 [enabled by default]
&gt; /home/nisse/hack/nettle/ccm.c:140:5: warning: right shift count &gt;= width of type \
&gt;                 [enabled by default]
&gt; /home/nisse/hack/nettle/ccm.c:141:5: warning: right shift count &gt;= width of type \
&gt; [enabled by default] 
&gt; As long as it's "always false", the code should be correct, but it would
&gt; be nice to get rid of these warnings.
&gt; 
&gt; Regards,
&gt; /Niels
&gt; 


</body></email><email><emailId>20140319143210</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-03-19 14:32:10-0400</timestampReceived><subject>Re: Support for FIPS 180-4 SHA-512/256?</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

Niels Möller wrote:
&gt; That's correct. I wasn't aware of them... Are there any applications
&gt; or protocols using them?

Don't have any good answer to that. the embedded SSL/TLS stack seems to
use it, but afaik there are no official defined cipher suites in TLS
that uses them.

http://www.oryx-embedded.com/doc/files.html

OSX command shasum supports sha-512/256 (and calls it sha51256, the
horrors!).

There seems to be discussions in OpenSSL about adding support.

So no, right now there doesn't seem to be much application demand for
it. OTOH as long as it is not available in libs, it is harder for
applications to use them. The SHA-512/x are part of the big SHA-2
standard and the prevalence of 64-bit arch even in embedded space is
increasing.

(I do also have a specific application case where SHA-512/256 will be
used which is why I started checking support for it.)


&gt; If they are needed, I'd suggest adding
&gt; 
&gt; sha512_224_init sha512_224_digest sha512_256_init sha512_256_digest

I can take a shot at the code changes and post patches.

&gt; (and not bother with any additional aliases for context struct and 
&gt; _update function). Is that ok?

Very ok. As long as the H0-constants can be changed we shouldn't need to
modify anything else.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIcBAEBCAAGBQJTKapqAAoJEF3cfFQkIuyN6CYP/R6x4okGe12TTUBJ59GWy/jp
iNlHQDUPRVNjIxKtBQ/7fD7cZ96fjPbXNS7Kx6SVsjM6I6L0QF1x8d9bxVD1PNlu
nGYNCraVkg6DQopiqN9KFuP/WFOngq8srO6rQ7/QpWtw0rILwjbdj50BRODjDD2I
L79RkKWkLJsPVK3uVDDSVp6hryttf3xw7GGTYTHkZX16cr8AAJ6F82lX6fQM0P+r
hEnpcI5DVqtJXhts5yUfKrQRvKmWWd1gHNhY6K68A4BXwYeMBbwgZ8veNUVQXogN
hz/Y5QUsCYz64S0yAy/4c6b642P7GLHjfNOSG2VgvIFbo1kTikuvAP81va+kp3xi
xOiCvgzEfgZsKYgDnOflAHYSI5FBFWzbZq1NgDmDOwCJMuJtxu7AQEiFwjWju1St
9CAeojh9A1k8ap7wO1fBHNksuh5NrG+l4xyTLp+VatH2pfYypdaBpVaaNkFfEq0C
IfOwtiFtHrmclrQucU9fyvW1aXSw9XJgs1/yBYlzG/Sq1TZfT7eutbvRo0TG3g+4
xXTYmZem6FcAwN8CuzhcslnLYsb8/nW3c4zxzpYU3pJuOeaIVO58RxpIBJsQaLLA
ruNRmU4+qqe5lQJZw9aNC/LKX4r9JYLgR3L9AKDKLXFiAFtkaa+zj5b5tPIEMj8t
D7poHkOA2XTZkuArvh3k
=pwTI
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140320172003</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-03-20 17:20:03-0400</timestampReceived><subject>Re: Support for FIPS 180-4 SHA-512/256?</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

Joachim Strömbergson wrote:
&gt; I can take a shot at the code changes and post patches.

It wasn't really that hard. Patches will follow in two mails.
I have not updated the H0 generation scripts used to verify the values
(which you have done for SHA-384 and SHA-512). But the test program I've
written generates the correct digest for SHA-512 (as baseline) and for
SHA-512-224 and SHA-512-256.

The test code etc is available on github:
https://github.com/secworks/nettle/tree/master/sha512x

I think it looks a bit ugly to have separat init and digest functions
but reuse the update function from sha512. I would prefer to add
sha512_224_update() and sha512_256 too but still reuse the context. But
since you don't do that for sha384 I guess you prefer it having just
init and digest as specific functions.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIcBAEBCAAGBQJTKyNDAAoJEF3cfFQkIuyNYcwP/3Q2n7mPtEZ0SMPPMdPf4YgD
nJU0hqvkyD1ima5l4XAdjyZIsc+8M9K3SZckUhMze5Mx28jetemfHMojx2nCWssa
tw/6soEKFCrzPHiGl6vBPmKRkGEQ+yw+XtpZh4lFZEhfNtUKpWiBcTLgrw6ih2Z9
OWXj1nfFkx2mj14yzs5GYLeNhGJ4UpyoY+uKS/49kDAhjLxoIxwAFdq3+BRHX831
qs1UBnprQWoc5/RMUobxykMkA3Gy17TI0plZeZCkYi/IL/9FfbtBmQONMYDA+hz7
uCj7+8J3HFtdWOeRTBqI5fOCDiRV7hlA7LbVHjXaCoFdLAGPwIKB9G9stKp+E6g7
3PaEoLK/Q6pKu7Q9A9kMJeKJDMUjHnPf1GQhCMv4gjqZKugS8Lzrm/1m28N3Vfwi
yN/S+UJxUijrjmiDuU49sc21OnPuNS8K3HthvQkRU6sRsREAoWtikDpXFtKJn+si
DRC4EsfFwiP8XV0/mbERtaDhpdpxqdoNOtFuF7povpYD4IddKoHrw6qBUxLzsYVC
hKk0OpFzKb0CkNVInxaSR6r8ivYvigLCSf4KRQWFVO4KfTaPG4sVkQJku1YqMvR9
ptGZOMXBlLh8BCHD0ZNL7a75GQIL6IQpWhEjtWNeD6LoUc3WJWZlhhhhjfRCq2cA
RH2gnRh0UEB/2FLgKBCj
=N9yE
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140206204025</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-06 20:40:25-0400</timestampReceived><subject>Re: Dropping length argument from nettle_set_key_func</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I've done this change. I didn't dare push it to the master branch just
&gt; yet, so it's on a new branch "set_key-changes". The more interesting
&gt; pieces of the ChangeLog below.
&gt;
&gt; Anyone who'd like to comment (or test) before I merge it to the master
&gt; branch?

I haven't seen any feedback on this. Merged into master now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140210100726</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-02-10 10:07:26-0400</timestampReceived><subject>Re: Abstractinos for stream ciphers and authenticated encryption</subject><body>

On Mon, Feb 10, 2014 at 10:45 AM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wro=
te:
&gt; Thanks for the review.
&gt;&gt;&gt; Q: Should it expose the block size?
&gt;&gt; I'd say no because the whole purpose of AEAD (or at least my
&gt;&gt; understanding of rfc5116) is to simplify the process of encryption.
&gt; But that interface says nothing about the case of processing a message
&gt; incrementally, one piece of a time.

Indeed, but its spirit is about simplification of the encryption
process and having to know details such as the block size doesn't
help. Let's say for example that someone wants to encrypt a message
that consists of a header (5) bytes and indefinite data provided by
some other layer. With the API that needs to know the block size, the
code to encrypt would be quite complex, while the blocksize-agnostic
code would be straight forward to use.

I realized this issue when I added support for salsa20 from nettle
that required the knowledge of the salsa20 block size in order to do
partial encryption.

&gt; For ease of use, do you think it's sufficient to have helper functions
&gt; for the common case of processing a complete message? Like the proposed
&gt;   void
&gt;   aead_encrypt (const struct nettle_aead *aead, void *ctx,
&gt;                 const uint8_t *nonce,
&gt;                 size_t adata_size, const uint8_t *adata,
&gt;                 size_t msg_size, uint8_t *gibberish, const uint8_t *msg);
&gt;   int
&gt;   aead_decrypt (const struct nettle_aead *aead, void *ctx,
&gt;                 const uint8_t *nonce,
&gt;                 size_t adata_size, const uint8_t *adata,
&gt;                 size_t msg_size, uint8_t *msg, const uint8_t *gibberish);

That would work if you have the whole message in a buffer, but I've
noticed that this isn't often the case. Of couse one could get a new
buffer, but I'd prefer a clean incremental encryption.

&gt; To do incremental processing with aead, without exposing internal
&gt; structure, what would you prefer? encrypt and decrypt functions which
&gt; take n bytes of input and produce n bytes output (for any n), plus some
&gt; digest function to do the final processing for authentication (on
&gt; decrypt, that implies that the application still has to split off the
&gt; final digest/tag bytes from the rest of the encrypted message) ?

I think the digest/tag function for final processing are unavoidable
when allowing incremental encryption, but I find them quite
reasonable. There will be some issue however, when there will be an
AEAD algorithm that introduced padding.

regards,
Nikos

</body></email><email><emailId>20140210120800</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-10 12:08:00-0400</timestampReceived><subject>Re: chacha</subject><body>

Stefan Bühler &lt;nettle-bugs@stbuehler.de&gt; writes:

&gt; My pull request for sjcl (javascript crypto) chacha includes those test
&gt; vectors in "json" format (right now at
&gt; https://github.com/stbuehler/sjcl/blob/feature-chacha20/test/chacha20_vectors.js,
&gt; but hopefully in upstream sjcl soon, in which case I'll delete my
&gt; feature branch).

It would make sense to att at least a few of those to nettle's
testsuite/chacha-test.c. Thanks for the pointer!

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140207120148</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-07 12:01:48-0400</timestampReceived><subject>Re: Abstractinos for stream ciphers and authenticated encryption</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Next, AEAD (authenticated encryption with associated data).

Some questions on a general abstraction for this, and my tentative answers:

Q: Should it expose the block size?

A: Yes. The caller must pass data in chunks which are an integral number
   of blocks. Motivation: (i) Byte-by-byte processing seems to be an
   obscure usecase, in particular for AEAD where you're not supposed to
   use the decrypted data for anything until the authentication is
   properly checked. (ii) This is how related nettle functions already
   work.


Q: Should we have a separate _digest function, which exposes the
   structure, of authentication tag appended to the crypto text?

A: Yes. Cons: For decryption, it's easier for the caller to pass the
   complete message, and not have to call digest and memcmp. Maybe there
   are some aead construction which doesn't do authentication by
   appending some kind of MAC at the end, so that is is verified by
   computing the same value and comparing it? I'm not aware of any,
   though.

   Pro: By having the caller separate ciphertext and tag, we avoid extra
   buffering in the implementation. And it simplifies the interface if
   the encrypt and decrypt functions have the same size for input and
   output, without having to delay processing until it is known that a
   piece of the data is ciphertext rather than tag.


Q: Should calling set_nonce be mandatory for each message, or should we
   provide automatically incrementing nonces, starting from zero?

A: Mandatory. Motivation: Some aead algorithms hash the nonce, and then
   we would need extra storage to be able to increment it. This includes
   EAX, and GCM with a nonce-size different from 12.


Q: Should the nonce size be fixed?

A: Yes. Motivation: For a given key, fixed nonce size is good enough for
   RFC 5116. It's unclear if there are use-cases for varying the nonce size,
   and if needed one can define separate nettle_aead objects differing
   only in nonce size.


Q: Should we include the rfc 5116 limits P_MAX and A_MAX?

A: No. Motivation: I think it's an obscure use-case to make decisions
   based on those limits at runtime. I'd expect a human to examine those
   limits when deciding which aead algorithms should be supported in a
   protocol or in an application.


Comments highly appreciated. This leads to the following abstraction:

  struct nettle_aead
  {
    const char *name;
    unsigned context_size;
    
    unsigned block_size;
    unsigned key_size;
    unsigned nonce_size;
    unsigned digest_size;
  
    nettle_set_key_func *set_encrypt_key;
    nettle_set_key_func *set_decrypt_key;
    nettle_set_key_func *set_nonce;
  
    nettle_crypt_func *encrypt;
    nettle_crypt_func *decrypt;

    nettle_hash_update_func *update;
    nettle_hash_digest_func *digest;
  };

The sequence of calls would be

  aead-&gt;set_encrypt_key(...);
  for (...)
    {
      aead-&gt;set_nonce(...);
      for (...) 
        aead-&gt;update(...);
      for (...) 
        aead-&gt;encrypt(...);
      aead-&gt;digest(...);
    }

For convenience maybe one could have a verify helper function which does
verify + memcmp. And helper functions for encrypting and decrypting of
complete messages, with no streaming, which I'd expect to be sufficient
for most aplications. Say,

  void
  aead_encrypt (const struct nettle_aead *aead, void *ctx, 
                const uint8_t *nonce, 
                size_t adata_size, const uint8_t *adata,
                size_t msg_size, uint8_t *gibberish, const uint8_t *msg);

  int
  aead_decrypt (const struct nettle_aead *aead, void *ctx, 
                const uint8_t *nonce, 
                size_t adata_size, const uint8_t *adata,
                size_t msg_size, uint8_t *msg, const uint8_t *gibberish);

where gibberish is of size msg_size + aead-&gt;digest_size.

Some possible extensions for things which aren't proper aead
constructions:

  If -&gt;set_nonce is NULL, there's no nonce, and each key can be used for
  only a single message.

  If -&gt;update is NULL, there can be no associated data

  If -&gt;digest is NULL, there's no authentication, it's a stream cipher
  or CTR-mode or the like (but plain CBC doesn't fit, due to its padding
  needs)

  If -&gt;encrypt and -&gt;decrypt is NULL, it's a MAC mechanism

I think it may be a good idea to implement chacha-poly1305 before doing
this abstraction, so there's at least three different aead mechanism to
test it with.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140210085707</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-02-10 08:57:07-0400</timestampReceived><subject>Re: Abstractinos for stream ciphers and authenticated encryption</subject><body>

On Fri, Feb 7, 2014 at 1:01 PM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wrote=
:

&gt;&gt; Next, AEAD (authenticated encryption with associated data).
&gt; Some questions on a general abstraction for this, and my tentative answer=
s:
&gt; Q: Should it expose the block size?
&gt; A: Yes. The caller must pass data in chunks which are an integral number
&gt;    of blocks. Motivation: (i) Byte-by-byte processing seems to be an
&gt;    obscure usecase, in particular for AEAD where you're not supposed to
&gt;    use the decrypted data for anything until the authentication is
&gt;    properly checked. (ii) This is how related nettle functions already
&gt;    work.

I'd say no because the whole purpose of AEAD (or at least my
understanding of rfc5116) is to simplify the process of encryption. If
the details need to be known another interface than AEAD can be used.

I agree with the rest of the points.

regards,
Nikos

</body></email><email><emailId>20140210094530</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-10 09:45:30-0400</timestampReceived><subject>Re: Abstractinos for stream ciphers and authenticated encryption</subject><body>

Thanks for the review.

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt;On Fri, Feb 7, 2014 at 1:01 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:

&gt;&gt; Q: Should it expose the block size?

&gt; I'd say no because the whole purpose of AEAD (or at least my
&gt; understanding of rfc5116) is to simplify the process of encryption.

But that interface says nothing about the case of processing a message
incrementally, one piece of a time.

For ease of use, do you think it's sufficient to have helper functions
for the common case of processing a complete message? Like the proposed

  void
  aead_encrypt (const struct nettle_aead *aead, void *ctx, 
                const uint8_t *nonce, 
                size_t adata_size, const uint8_t *adata,
                size_t msg_size, uint8_t *gibberish, const uint8_t *msg);

  int
  aead_decrypt (const struct nettle_aead *aead, void *ctx, 
                const uint8_t *nonce, 
                size_t adata_size, const uint8_t *adata,
                size_t msg_size, uint8_t *msg, const uint8_t *gibberish);

To do incremental processing with aead, without exposing internal
structure, what would you prefer? encrypt and decrypt functions which
take n bytes of input and produce n bytes output (for any n), plus some
digest function to do the final processing for authentication (on
decrypt, that implies that the application still has to split off the
final digest/tag bytes from the rest of the encrypted message) ?

Or something more in spirit with zlib, where the caller provides input
and output buffers, and the implementation does as much processing as
possible with the given input and available output space?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140213231918</emailId><senderName>James Cloos</senderName><senderEmail>cloos@jhcloos.com</senderEmail><timestampReceived>2014-02-13 23:19:18-0400</timestampReceived><subject>Re: chacha set-key naming</subject><body>

&gt;&gt;&gt;&gt;&gt; "NM" == Niels Möller &lt;nisse@lysator.liu.se&gt; writes:

NM&gt; Does anyone else know of use or interest in 128-bit chacha keys?

Given DJB's paper¹ on parallel hardware cracking, which strongly suggests
against using 128 bit symmetric if one is concerned about well funded
adversaries, I doubt there are any.

1] IINM, I'm thinking of http://cr.yp.to/snuffle/bruteforce-20050425.pdf

-JimC
--
James Cloos &lt;cloos@jhcloos.com&gt;         OpenPGP: 1024D/ED7DAEA6

</body></email><email><emailId>20140208201651</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-08 20:16:51-0400</timestampReceived><subject>Re: chacha</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Testing could be improved, quoting the comments in chacha-test.c:
&gt;
&gt;   /* FIXME: For rounds == 20, use crypt function, support more than
&gt;      one block, and test various short lengths. */

Done now. And I found and fixed one bug in chacha_crypt. When updating
the block counter, it used the salsa20 state layout, not the chacha
state layout.

And one more question on terminology and naming: Should it be
chacha_set_nonce or chacha_set_iv? 

I recently renamed salsa20_set_iv to salsa20_set_nonce, since "nonce"
seemed to be the term most used in salsa20 literature.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140210075918</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-10 07:59:18-0400</timestampReceived><subject>Re: Abstractions for authenticated encryption</subject><body>

I'm continuing to reply to myself... It's the recurring question on
fixed size versus varying size of certain inputs and outputs.

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Q: Should the nonce size be fixed?
&gt;
&gt; A: Yes. Motivation: For a given key, fixed nonce size is good enough for
&gt;    RFC 5116. It's unclear if there are use-cases for varying the nonce size,
&gt;    and if needed one can define separate nettle_aead objects differing
&gt;    only in nonce size.

If it's fixed, then the abstraction can't be used as is in the
testsuite, because there are testcases at least for gcm, which try
varying the nonce size. Could be solved by passing an extra function
pointer for those tests (or define a nettle_aead struct for each tested
size, but that seems a bit awkward).

&gt;     nettle_hash_digest_func *digest;

Using nettle_hash_digest_func implies a size argument, since nettle's
digest functions allow truncation. And, e.g., eax is specified with the
"tag length" tau as a security parameter, so the underlying eax_digest
function ought to have a size parameter. But varying the size is a bit
questionable in the context of an "abstract" aead algorithm; there the
digest size ought to be fixed, toghether with nonce size and key size,
as an "instantiation" of a more general algorithm.

So should we have a separate type,

  typedef void nettle_aead_digest_func(void *ctx, uint8_t *dst);

for this digest function pointer?

&gt; I think it may be a good idea to implement chacha-poly1305 before doing
&gt; this abstraction, so there's at least three different aead mechanism to
&gt; test it with.

I've started on this, and it seems nice and easy. But I stumbled on the
above interface issues.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140211133644</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-11 13:36:44-0400</timestampReceived><subject>Re: Abstractions for stream ciphers and authenticated encryption</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Let's say for example that someone wants to encrypt a message
&gt; that consists of a header (5) bytes and indefinite data provided by
&gt; some other layer. With the API that needs to know the block size, the
&gt; code to encrypt would be quite complex, while the blocksize-agnostic
&gt; code would be straight forward to use.

I'm been thinking a bit more. I'm leaning towards the nettle_aead struct
as an interface to the aead primitives. Then, additional buffering
should be done in the same way (ok, parameterized by the block size)
regardless of the underlying algorithm, hence it's not a primitive at
that level.

For ease of use, I think we could have a family of aead_* functions
which lets the application treat the nettle_aead as opaque objects. I
think one could add functions for incremental processing too, not only
the complete-message functions already sketched.

How should the easy-to-use interface for incremental
encryption/decryption look like? I see two alternatives:

Either provide some macro or function, which, given an aead algorithm
and the input size, returns the largest possible output size. Then the
application should arrange to pass a large enough buffer, call the
encrypt/decrypt function, which returns the amount of output actually
produced.

Or use struct nettle_buffer for the destination operand, possibly in
combination with some macro/function to query the needed space.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140213083830</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-13 08:38:30-0400</timestampReceived><subject>Re: Abstractions for stream ciphers and authenticated encryption</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Q: Should the nonce size be fixed?
&gt;
&gt; A: Yes. Motivation: For a given key, fixed nonce size is good enough for
&gt;    RFC 5116. It's unclear if there are use-cases for varying the nonce size,
&gt;    and if needed one can define separate nettle_aead objects differing
&gt;    only in nonce size.

I'm still having some difficulty figuring out what really is the Right
Thing here. I think there are two usecases, with somewhat different
requirements.

1. General code which is written to work with any aead algorithm. This
   has to use nonces of size aead-&gt;nonce_size, because there's no
   interface to query what other nonce sizes might be valid (we have the
   option of adding some n_min and n_max values, though). So here, a
   length argument for set_nonce is useless.

2. Code which uses a single aead algorithm, say eax-aes128, but uses the
   nettle_aead abstraction in order to use the user-friendly
   to-be-defined aead_* functions, say, a aead_encrypt_message to do all
   work for processing one message. That code may well know that eax
   supports arbitrary nonce sizes. Then it would either need a way to
   pass a length argument to set_nonce, or a supported way to call some
   other algorithm specific function to set the nonce.

For now, I'm leaving it as fixed size, but I might change my mind before
release.

Related question is the length for the digest method. I'm leaning
towards leaving that in, even though I'd expect that to be useless for
almost all applications using aead. The reason is consistency with other
nettle functions; all other hash and mac algorithms support a length
argument, to truncate the digest to any desired smaller size.

I've pushed my aead changes to the repo now. Currently defined instances
are 

  nettle_gcm_aes128
  nettle_gcm_aes192
  nettle_gcm_aes256
  nettle_chacha_poly1305
  nettle_eax_aes128

Comments highly appreciated.

For chacha_poly1305, we really need additional testcases, in particular
for corner cases like empty plaintext or empty authenticated data.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140215072848</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-15 07:28:48-0400</timestampReceived><subject>chacha nonce size changed from 64 to 96 bits?</subject><body>

I was pointed to
https://tools.ietf.org/html/draft-nir-cfrg-chacha20-poly1305-01. This
draft specifies chacha as using a 96-bit nonce and a 32-bit block
counter. When asking about this discrepancy on the tls list, Adam
Langley replied 

: On Fri, Feb 14, 2014 at 1:57 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
: &gt; [...] And a 32-bit counter (256 GB message size, if I manage to get
: &gt; the powers right) ought to be sufficient for almost all applications.
: &gt; But I'm afraid it might to slow adoption of chacha if there are
: &gt; multiple slightly incompatible specifications.
: 
: I intend for the 64/64 bit version to be dead at this point. I think
: everyone can agree on the 96/32 split. I wouldn't want there to be two
: versions if it can be avoided.

Apparently, IPSec wants 96 bits nonces, and this is also in line with
rfc5116, which says that all AEAD algorithms SHOULD support 12-byte
nonces.

But this change is news to me. Do everyone really agree on the change of
96/32 in chacha?

My interpretation is that this move is advocated by people are thinking
of various packetized protocols, where 32-bit block counter clearly will
be sufficient to encrypt each packet. And that's clearly the most
important applications of chacha will be of that type. But maybe there
are other applications where a limit of 256 GB for a single message to
be encrypted with chacha could be a problem?

There is some possibilty to let the two views of these input block
coexist, but I'm afraid that will get a bit messy to support in Nettle
(although I haven't yet thought very much about the details).

Anyway, this makes me feel that support for chacha and chacha-poly1305
must be marked as experimental, until the specifications really settle.

Regards,
/Niels



-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140215140211</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-02-15 14:02:11-0400</timestampReceived><subject>Re: chacha nonce size changed from 64 to 96 bits?</subject><body>

On 02/15/2014 08:28 AM, Niels Möller wrote:
&gt; I was pointed to
&gt; https://tools.ietf.org/html/draft-nir-cfrg-chacha20-poly1305-01. This
&gt; draft specifies chacha as using a 96-bit nonce and a 32-bit block
&gt; counter. When asking about this discrepancy on the tls list, Adam
&gt; Langley replied 
&gt; : On Fri, Feb 14, 2014 at 1:57 PM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt; : &gt; [...] And a 32-bit counter (256 GB message size, if I manage to get
&gt; : &gt; the powers right) ought to be sufficient for almost all applications.
&gt; : &gt; But I'm afraid it might to slow adoption of chacha if there are
&gt; : &gt; multiple slightly incompatible specifications.
&gt; : I intend for the 64/64 bit version to be dead at this point. I think
&gt; : everyone can agree on the 96/32 split. I wouldn't want there to be two
&gt; : versions if it can be avoided.
&gt; Apparently, IPSec wants 96 bits nonces, and this is also in line with
&gt; rfc5116, which says that all AEAD algorithms SHOULD support 12-byte
&gt; nonces.
&gt; But this change is news to me. Do everyone really agree on the change of
&gt; 96/32 in chacha?

In the TLS version of chacha we are going to propose is whather the cfrg
draft says. So that would be 96/32.

regards,
Nikos


</body></email><email><emailId>20140215181436</emailId><senderName>James Cloos</senderName><senderEmail>cloos@jhcloos.com</senderEmail><timestampReceived>2014-02-15 18:14:36-0400</timestampReceived><subject>Re: chacha nonce size changed from 64 to 96 bits?</subject><body>

&gt;&gt;&gt;&gt;&gt; "NM" == Niels Möller &lt;nisse@lysator.liu.se&gt; writes:

NM&gt; But this change is news to me. Do everyone really agree
NM&gt; on the change of 96/32 in chacha?

Openssh's implementation uses DJB's 64/64 split.

If any nettle-using ssh app wants to interact, it will need 64/64.

-JimC
--
James Cloos &lt;cloos@jhcloos.com&gt;         OpenPGP: 1024D/ED7DAEA6

</body></email><email><emailId>20140213133403</emailId><senderName>Stefan =?UTF-8?B?QsO8aGxlcg==?=</senderName><senderEmail>nettle-bugs@stbuehler.de</senderEmail><timestampReceived>2014-02-13 13:34:03-0400</timestampReceived><subject>Re: Abstractions for stream ciphers and authenticated encryption</subject><body>

Hi,

On Thu, 13 Feb 2014 09:38:30 +0100
nisse@lysator.liu.se (Niels Möller) wrote:

&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt; &gt; Q: Should the nonce size be fixed?
&gt; &gt;
&gt; &gt; A: Yes. Motivation: For a given key, fixed nonce size is good
&gt; &gt; enough for RFC 5116. It's unclear if there are use-cases for
&gt; &gt; varying the nonce size, and if needed one can define separate
&gt; &gt; nettle_aead objects differing only in nonce size.
&gt; [...]

The RFC explicitly supports a range of nonce sizes; I think the
overhead of supporting them is so small that I don't see why not to
just add it and be done with it :)

&gt; Related question is the length for the digest method. I'm leaning
&gt; towards leaving that in, even though I'd expect that to be useless for
&gt; almost all applications using aead. The reason is consistency with
&gt; other nettle functions; all other hash and mac algorithms support a
&gt; length argument, to truncate the digest to any desired smaller size.

The RFC says:
&gt; Each AEAD algorithm MUST provide a description relating the length of
&gt; the plaintext to that of the ciphertext.  This relation MUST NOT
&gt; depend on external parameters, such as an authentication strength
&gt; parameter (e.g., authentication tag length).  That sort of dependence
&gt; would complicate the use of the algorithm by creating a situation in
&gt; which the information from the AEAD registry was not sufficient to
&gt; ensure interoperability.

I'm not sure I'm reading this correctly, but to me this means that an
AEDA algorithm could have an "authentication tag length" parameter, but
would have to pad it to the maximum tag length it supports, as
otherwise the length of the ciphertext would depend on that parameter,
making such parameter completely useless.

Also the RFC doesn't specify an interface for such tags ("digests") at
all - they are part of the ciphertext.

So the "RFC way" would be renaming "digest" to "finish" and have some
way to signal a larger output buffer is needed; perhaps similar to the
z_stream interface.
I'm not saying that would be a good idea :)


Also the RFC doesn't specify a "streaming" interface (afaik); for
example an AEAD algorithm could process the plain text data before the
additional data.

To handle such algorithms well it may be necessary to ask for a fixed
AD buffer in the beginning, which has to be valid while the
plain/cipher text is processed.

Also some algorithms may need to know the length of the plain text in
advance (CCM for example).

regards,
Stefan

</body></email><email><emailId>20140213211150</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-13 21:11:50-0400</timestampReceived><subject>Re: Abstractions for stream ciphers and authenticated encryption</subject><body>

Stefan Bühler &lt;nettle-bugs@stbuehler.de&gt; writes:

&gt; The RFC explicitly supports a range of nonce sizes; I think the
&gt; overhead of supporting them is so small that I don't see why not to
&gt; just add it and be done with it :)

Maybe. We'd then need all of a minimun, a maximum, and a
default/recommended value. I don't think we should have what the rfc
calls randomized or stateful algorithms at this level.

What should the minimum value be? Both eax and gcm could have minimum
value 0 and maximum value UINT_MAX, since they both hash the nonce as
needed. Actually using an empty nonce means that one can process only a
single message with each key. 

The gcm spec allows arbitrary nonce size, and with size != 12 the nonce
is hashed. But I don't know if this is a feature anyone is using? RFC
5116 specifies a fix size of 12 bytes for gcm. (Restricting to 12 bytes
would make it natural to support auto-increment of the nonce).

&gt; I'm not sure I'm reading this correctly, but to me this means that an
&gt; AEDA algorithm could have an "authentication tag length" parameter, but
&gt; would have to pad it to the maximum tag length it supports, as
&gt; otherwise the length of the ciphertext would depend on that parameter,
&gt; making such parameter completely useless.

I think that with different tag lengths, you would have a separate aead
algorithms in the rfc definition for each possible tag size. At least,
that's one way to make sense of it.

&gt; Also the RFC doesn't specify a "streaming" interface (afaik); for
&gt; example an AEAD algorithm could process the plain text data before the
&gt; additional data.

Algorithms of interest do support streaming mode, though, and I think
it's viewed as a desirable feature.

&gt; Also some algorithms may need to know the length of the plain text in
&gt; advance (CCM for example).

I'm not really familiar with ccm, I've only read the critique of it in
the eax paper. But that sounds like it's killing streaming operations.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140215172436</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-02-15 17:24:36-0400</timestampReceived><subject>Re: Abstractions for stream ciphers and authenticated encryption</subject><body>

On 02/13/2014 09:38 AM, Niels Möller wrote:

&gt; I've pushed my aead changes to the repo now. Currently defined instances
&gt; are 
&gt;   nettle_gcm_aes128
&gt;   nettle_gcm_aes192
&gt;   nettle_gcm_aes256
&gt;   nettle_chacha_poly1305
&gt;   nettle_eax_aes128

It would be good to have camellia as well (I had sent a patch some time
ago). In gnutls I use it as the backup cipher to AES.

regards,
Nikos


</body></email><email><emailId>20140215182802</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-15 18:28:02-0400</timestampReceived><subject>Re: Abstractions for stream ciphers and authenticated encryption</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; It would be good to have camellia as well (I had sent a patch some time
&gt; ago). In gnutls I use it as the backup cipher to AES.

Hmm, let me see... I find one patch from you in my mailbox (not on
list), including test vectors, dated October 24. Thanks for the
reminder.

Do you need all of gcm-camellia128, gcm-camellia192, gcm-camellia256, or
only some? (Your test program seems to only test the 128-bit variant,
but you also attacked a file with test data for the other sizes).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140215200144</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-02-15 20:01:44-0400</timestampReceived><subject>Re: Abstractions for stream ciphers and authenticated encryption</subject><body>

On 02/15/2014 07:28 PM, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt;&gt; It would be good to have camellia as well (I had sent a patch some time
&gt;&gt; ago). In gnutls I use it as the backup cipher to AES.
&gt; 
&gt; Hmm, let me see... I find one patch from you in my mailbox (not on
&gt; list), including test vectors, dated October 24. Thanks for the
&gt; reminder.
&gt; Do you need all of gcm-camellia128, gcm-camellia192, gcm-camellia256, or
&gt; only some? (Your test program seems to only test the 128-bit variant,
&gt; but you also attacked a file with test data for the other sizes).

In rfc6367 only the 128 and 256 bit variants are defined, so having
those would be enough for me.

regards,
Nikos


</body></email><email><emailId>20140216082349</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-16 08:23:49-0400</timestampReceived><subject>Re: Abstractions for stream ciphers and authenticated encryption</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; In rfc6367 only the 128 and 256 bit variants are defined, so having
&gt; those would be enough for me.

gcm-camellia128 added now. Need to prepare additional testcases (based
on camellia_gcm_tv.txt) before adding the 256-bit variant. I hope I can
get that done soon.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140216085406</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-16 08:54:06-0400</timestampReceived><subject>Re: Abstractions for stream ciphers and authenticated encryption</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Need to prepare additional testcases (based on camellia_gcm_tv.txt)
&gt; before adding the 256-bit variant. I hope I can get that done soon.

Done now. Nikos: From where did you get camellia_gcm_tv.txt? It would be
good to document the source in gcm-test.c.

/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140210084611</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-02-10 08:46:11-0400</timestampReceived><subject>Re: chacha</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

Niels Möller wrote:
&gt; And one more question on terminology and naming: Should it be 
&gt; chacha_set_nonce or chacha_set_iv?
&gt; 
&gt; I recently renamed salsa20_set_iv to salsa20_set_nonce, since
&gt; "nonce" seemed to be the term most used in salsa20 literature.

DJB use the term "nonce" in both the sasa20 and chacha specs so I think
nonce is the proper term to use. Esp since that seems to be the commonly
used term.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIcBAEBCAAGBQJS+JHTAAoJEF3cfFQkIuyNcakQAIrcZ7n3TsxVhOz8gQF9THrM
kGYqx3672Ct9rhF3/Jko/tZsM6OsD285TguIJVaoRC0HGTFIheFMYSQRHNBhXZiu
CIqGkY6NtHRCS13TFcZ05V1qtJ2wuYs01SGhq3rNaRc5xVy6jz8/PWwWrV4w4aJN
vrouZnSxv5n6oF97AljaJUhUa1Ob3MagddRKrsQd0NkERitKaiaXEYGQtpd2+AWb
AaRde+9klG+yWLkvSHK9DzRWiF7uuTynGOq++gj1WBIh+dLtx/iCwcZaEHB8O7Uq
hGEFMIE6NUUQcDO2bfERmLBE1weckyrWBvvv9D7anJMhkHeiJyKzt8uyQrpdkEbq
UZHV6KyQg0he2Dc1MKfzCBTm4vsz3xK6x3bjMz6wlVlZ4Z4VyV3+0JVhuY7M7kiM
OT46G6450MB4M2dJFnpxVvfhlbA3uNVlIx1gvo0vDpVTDfnWZyKh5LfhXk/FAeOm
oEvskpho45WU7qOZseAVWSAntIaQk71kIN2umvbn/yK9JR4lEqA+AzDd0CvuI3kP
/UzE0saj5O25YaKotb4qnb3A1RtvihCwvBr2lcFR1WbRs0HrbtJol7xhquAwM5ot
4WpLx5m1iRPUGsEjA/tfiOrrAWkBvv5mJC0rkurU1VzqN8lszWYKQS7zfrAl+AZa
BU0KamLXBO5Gg5DsmuwZ
=I4tP
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140210085758</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-02-10 08:57:58-0400</timestampReceived><subject>Re: chacha</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Aloha!

Niels Möller wrote:
&gt; Done now. And I found and fixed one bug in chacha_crypt. When
&gt; updating the block counter, it used the salsa20 state layout, not the
&gt; chacha state layout.

Looking through the commits and docs... Holy cr-p! Yes, that was a bad
bug. Good spotted!

I have not the same bug in the generator for test vectors and the
HW-implementation. Really scared med there. ;-)

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQIbBAEBCAAGBQJS+JSVAAoJEF3cfFQkIuyNxpYP92x3Zzw7tOcLF/4DG5+DMxqP
l5jYRRmvbQVYrR3uJ+5WG0MMPqxQhsVrtuspVTsWIBETvGwACT5i0TMuhGd7RCBW
yvFQLmG6L59I4PlzCUxBfTyeHe/GIGn+0q3JA7Y1O9VpW8LDuHb/bhhKK3/hK49N
o39V931KC19PDhmdfpW/zPd7Y0NvLPFGVYe26BdiKK1uWwprSJqIP0zbYLCqnU+H
peDzSUdyPHCBBeh9zewm3wAdANB3tFECPbhVf5zD1hge92WUW5BgLpLcUikskw0r
x88ye8APSs+Rq97LA/XK5DEPOsxlVLxaT2XPG9arWN8XK5DjVglxBSUE0YgTvMzw
rYIiTSCokInuNXwUkLKh27JiZhAjA2/GKwSKac/UdPSreBMzj7vj6DQknA/n6Ja7
gucHJtUV40mr9YGuqSVw7O0ZpT2MhmTpKjKpo1OYBuyIpn/XN8YtA6tmbspKuoY8
LjlGbUi1KiBE8tkoVoSi9xgMsCOYPgD6WatYiRlR0dZsqSJfVGgL5FTMGduVqGBX
4OVv2qCh7GvA7bysY2zSvjQbZNDIhpN6WoxAzbFYUpMges83u9IeZMylt9TZAkPy
dNJSxSidSuKS0jo1EhwHWjlyNbbHISxmBCVM3WlboX4fNcjmxs6b4GQWnNKfnF9n
LqnV+LLC86A5iim4RJY=
=5CEz
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140210091948</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-10 09:19:48-0400</timestampReceived><subject>Re: chacha</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; Niels Möller wrote:
&gt;&gt; Done now. And I found and fixed one bug in chacha_crypt. When
&gt;&gt; updating the block counter, it used the salsa20 state layout, not the
&gt;&gt; chacha state layout.
&gt;
&gt; Looking through the commits and docs... Holy cr-p! Yes, that was a bad
&gt; bug. Good spotted!

I guess this is simply an example of the general observation that
untested code often doesn't work as intended...

&gt; I have not the same bug in the generator for test vectors

That's good (and otherwise, the tests wouldn't have failed...). BTW, do
you know of any other source of testvectors (even if not as extensive as
the ones in your draft)?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140210094802</emailId><senderName>Stefan =?UTF-8?B?QsO8aGxlcg==?=</senderName><senderEmail>nettle-bugs@stbuehler.de</senderEmail><timestampReceived>2014-02-10 09:48:02-0400</timestampReceived><subject>Re: chacha</subject><body>


Hi,

On Mon, 10 Feb 2014 10:19:48 +0100
nisse@lysator.liu.se (Niels M=C3=B6ller) wrote:
&gt; That's good (and otherwise, the tests wouldn't have failed...). BTW,
&gt; do you know of any other source of testvectors (even if not as
&gt; extensive as the ones in your draft)?

You can plug the reference implementation from
http://cr.yp.to/chacha.html into ecrypt:
http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/
(extract the attached archive into the submissions folder for 20, 12
and 8 rounds variants)

My pull request for sjcl (javascript crypto) chacha includes those test
vectors in "json" format (right now at
https://github.com/stbuehler/sjcl/blob/feature-chacha20/test/chacha20_vecto=
rs.js,
but hopefully in upstream sjcl soon, in which case I'll delete my
feature branch).

regards,
Stefan


</body></email><email><emailId>20140210103417</emailId><senderName>Stefan =?UTF-8?B?QsO8aGxlcg==?=</senderName><senderEmail>nettle-bugs@stbuehler.de</senderEmail><timestampReceived>2014-02-10 10:34:17-0400</timestampReceived><subject>Re: chacha</subject><body>

No, I did not forget the attachment.

Stripping attachments on the ml... really?
Well, you're just going to have to do it yourself then.

</body></email><email><emailId>20140210104644</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-10 10:46:44-0400</timestampReceived><subject>Re: chacha</subject><body>

Stefan Bühler &lt;nettle-bugs@stbuehler.de&gt; writes:

&gt; Stripping attachments on the ml... really?

Last time I looked at this in the mailman config, I was too confused to
solve the problem. Maybe I should try again.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140214145111</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-14 14:51:11-0400</timestampReceived><subject>Re: Abstractions for authenticated encryption</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Or use struct nettle_buffer for the destination operand, possibly in
&gt; combination with some macro/function to query the needed space.

I have now tried this approach. For those have haven't used
nettle_buffer, it's struct with a data pointer, allocation size, and
current size. It can be setup to either use a fix buffer provided by the
application, or it can grow as needed, using realloc, xrealloc, or any
custom realloc function provided by the application.

A totally untested implementation in the aead-api branch. There actually
two interfaces, defined in aead.h.

First question is whether or not this is useful. If it is useful, maybe
the interfaces need tweaking. A first test (besides regular test cases)
would be to rewrite examples/rsa-encrypt.c and examples/rsa-decrypt.c to
use some aead mechanism for the bulk encryption, rather than aes-cbc +
hmac-sha1.

First, an interface for processing complete messages. These use the same
context as the lower-level algorithm. More or less the same as I have
sketched on this list previously.

-----8&lt;---------

/* Interface for processing a complete message at a time. Application
   must allocate the context and call the set_key function before
   using this interface. */
size_t
aead_encrypt_msg_size (const struct nettle_aead *aead, size_t size);
void
aead_encrypt_msg (const struct nettle_aead *aead,
		  void *ctx, const uint8_t *nonce,
		  size_t ad_size, const uint8_t *ad,
		  size_t plaintext_size,
		  uint8_t *gibberish, const uint8_t *plaintext);

size_t
aead_decrypt_msg_size (const struct nettle_aead *aead, size_t size);
int
aead_decrypt_msg (const struct nettle_aead *aead,
		  void *ctx, const uint8_t *nonce,
		  size_t ad_size, const uint8_t *ad,
		  size_t gibberish_size,
		  uint8_t *plaintext, const uint8_t *gibberish);

-----8&lt;---------

Second interface is for streaming operation, hiding the block size.
Here, the context is the context of the underlying aead algorithm, but
with a small extra buffer added at the end (aead-&gt;block_size for
encryption, and aead-&gt;block_size + aead-&gt;digest_size for decryption).

-----8&lt;---------

/* Streaming interface, including buffering. Uses a context struct
   corresponding to the aead algorithm, with additional buffers added
   at the end. Hence, the context can be passed to algorithm-specific
   functions. Applications should call set_key and set_nonce before
   using these functions. */

#define aead_update(aead, ctx, size, data) \
  ((aead)-&gt;update((ctx), (size), (data)))

size_t
aead_encrypt_ctx_size (const struct nettle_aead *aead);

void
aead_encrypt_init (const struct nettle_aead *aead,
		   void *ctx, const uint8_t *nonce);

/* Attempts to grow the destination buffer as needed. Returns the
   amount of plaintext that could be processed. */
size_t
aead_encrypt (const struct nettle_aead *aead,
	      void *ctx, struct nettle_buffer *buffer,
	      size_t size, const uint8_t *plaintext);

/* Maximum output size for aead_encrypt_final. */
size_t
aead_encrypt_final_size (const struct nettle_aead *aead);

/* Returns 1 on success, 0 if buffer was too small and growing it
   failed. On failure, some output may still be generated, and the
   function can be called again with more output space. */
int
aead_encrypt_final (const struct nettle_aead *aead,
		    void *ctx, struct nettle_buffer *buffer);

size_t
aead_decrypt_ctx_size (const struct nettle_aead *aead);

void
aead_decrypt_init (const struct nettle_aead *aead,
		   void *ctx, const uint8_t *nonce);

/* Attempts to grow the destination buffer as needed. Returns the
   amount of plaintext that could be processed. */
size_t
aead_decrypt (const struct nettle_aead *aead,
	      void *ctx, struct nettle_buffer *dst,
	      size_t size, const uint8_t *gibberish);

/* Maximum output size for aead_decrypt_final. */
size_t
aead_decrypt_final_size (const struct nettle_aead *aead);

/* Returns 1 on success, 0 if buffer is too small or authentication
   failed. FIXME: Distinguish between failure cases? */
int
aead_decrypt_final (const struct nettle_aead *aead,
		    void *ctx, struct nettle_buffer *dst);

-----8&lt;---------

In particular the decrypt function is quite messy, which makes me think
that it's a good idea to implement this at one place, on a level between
the application and the implementation of each specific aead mechanism.

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140216105218</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-02-16 10:52:18-0400</timestampReceived><subject>Re: Abstractions for stream ciphers and authenticated encryption</subject><body>

On 02/16/2014 09:54 AM, Niels Möller wrote:
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt;&gt; Need to prepare additional testcases (based on camellia_gcm_tv.txt)
&gt;&gt; before adding the 256-bit variant. I hope I can get that done soon.
&gt; 
&gt; Done now. Nikos: From where did you get camellia_gcm_tv.txt? It would be
&gt; good to document the source in gcm-test.c.

It was provided to me by the authors of RFC6367.

regards,
Nikos




</body></email><email><emailId>20140216180643</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-02-16 18:06:43-0400</timestampReceived><subject>Re: chacha nonce size changed from 64 to 96 bits?</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; There is some possibilty to let the two views of these input block
&gt; coexist, but I'm afraid that will get a bit messy to support in Nettle
&gt; (although I haven't yet thought very much about the details).

This is all about initialization and update of words 12-15 (last row) of
the chacha state. Either

  12 13 14 15
  c0 c1 n0 n1  (64-bit counter, 64 bit nonce)

or

  12 13 14 15
   c n0 n1 n2  (32-bit counter, 96 bit nonce)

When using a 64-bit counter, c0 is the least significant half, and c1 is
the most significant half. Say we adopt the second layout (and
notation). Then letting the counter c overflow is an error which should
never happen when using the 32/96 variant. So we can make the compatible
extension to increment the n0 word whenever c wraps around (this will
break if for some reason someone wants to use 32/96 chacha with an
unusually large initial counter, though).

With this tweak, one can get 64/64 chacha by simply prepending 32 zero
bits to the 64-bit nonce, and use the 32/96 chacha.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140103140702</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-01-03 14:07:02-0400</timestampReceived><subject>Re: Using side-channel silent GMP functions</subject><body>

On Thu, Jan 2, 2014 at 9:57 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; wr=
ote:

&gt; For the next release of GMP, there will be some new public functions for
&gt; side-channel silent computations, as part of the low-level "mpn"
&gt; interface.
&gt; I think it would make sense to rewrite the RSA and DSA private key
&gt; operations to use side-channel silent functions. This might require
&gt; further interface changes; I haven't really looked into it yet, so I
&gt; don't know to which degree backwards compatibility can be kept.
&gt;

For RSA it would matter but it is not urgent as blinding currently works.
For DSA it would matter too, but who cares (and who uses DSA anyway?) :)

For gnutls what would be needed in the short term are:
- Add chacha.
- the TMP_GMP_ALLOC change.
- Fix out-of-bounds access in memxor

In medium term:
- Add poly1305 (with chacha-poly1305 if accepted in the TLS WG)

I also don't yet know if it's practical to make use of the new functions
&gt; optional, or if it will make the latest GMP a strict requirement (unless
&gt; Nettle's public key support is completely disabled).
&gt;

I think that would effectively make nettle LGPLv3. Unless the issue with
GPLv2 compatibility is solved somehow, I'd prefer if the LGPLv2 of gmp can
still be used.

regards,
Nikos

</body></email><email><emailId>20140103222539</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-03 22:25:39-0400</timestampReceived><subject>Re: Regarding the nettle release plan page</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; (1) I would suggest not using colors as distinguisher for what is done
&gt; (green), what is critical for the release (red) and what is nice to have
&gt; (grayish).

Feel free to play with the style sheet, it's the files misc/plan.html
and misc/todo.css in the repo. One could use other colors, or both color
and font style changes, or have several alternative stylesheets.

But I like the current organization, where I just switch the class of a
paragraph to change the status, and it's also possible to change the
status of just parts of a point using, e.g., &lt;span class='done'&gt;.

&gt; (2) How about putting up an estimated release schedule at the top of the
&gt; page.

I'm afraid there's no schedule. Currently, this is a spare time project
for me. Funding for full time work (even for just a few weeks) would
help.

And then depending on how the memxor bug Nikos reported plays out (I'm
looking into improving the test using VALGRIND_MAKE_MEM_NOACCESS client
requests), it may be necessary to also do a 2.7.2 bugfix release in
between.

&gt; (3) I'll try and work on the chacha support files the next weeks.

&gt; (4) I'm prepared to do the darwin testing on OSX 10.9.x

Good!

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140103232908</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-01-03 23:29:08-0400</timestampReceived><subject>Re: Minor nits/comments on sha256.c</subject><body>

Aloha!


&gt; 3 jan 2014 kl. 21:27 skrev nisse@lysator.liu.se (Niels Möller):
&gt; &gt; (3) The SHA-224 H0-table refers to the _SHA256_DIGEST_LENGTH. This imho
&gt; &gt; should be a separate define _SHA224_DIGEST_LENGTH. Yes, it is the same
&gt; &gt; length in practice but it looks weird
&gt; 
&gt; Maybe this constant is misnamed. It's the size of the *internal* state,
&gt; which for sha224 (and sha384) is unrelated to the output digest size.
&gt; It's defined in the public sha2.h header only because it's the size of
&gt; the state array in struct sha256_ctx.
Yes, exactly. The name is confusing


&gt; And a separate define for sha224
&gt; makes little sense, because there is no separate struct sha224_ctx, it's
&gt; just a #define alias for sha256_ctx.

Clean code. It makes sense because for the user it is a different algorithm even \
though it shares a lot of the guts with SHA-256. An alias is enough just like a \
define that actually define the same size of the state. Imho.


&gt; Regards,
&gt; /Niel
&gt; 
&gt; -- 
&gt; Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
&gt; Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140104221321</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-04 22:13:21-0400</timestampReceived><subject>Re: Request to release new version of nettle to support new architecture ppc64le</subject><body>

rajesh &lt;rajesh@linux.vnet.ibm.com&gt; writes:

&gt; since currently available config.guess does not
&gt; have support for ppc64le it  fails to guess correct build type.
&gt;
&gt; Latest config.guess with ppc64le support is available at :
&gt; http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD

I have now updated nettle's copies of config.guess and config.sub to the
latest versions (both timestamped 2014-01-01).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140104222008</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-04 22:20:08-0400</timestampReceived><subject>Improved valgrind testing</subject><body>

I've now added a configure test for valgrind/memcheck.h, and I've added
code to testsuite/memxor-test.c to use valgrind client requests to tell
it the start and end of the src and dst areas.

I've also added the flag --partial-loads-ok=yes to the VALGRIND variable
in testsuite/Makefile.in. I usually run valgrind with the invocation

  make check EMULATOR='$(VALGRIND)'

Without that flag, I get tons of warnings for both x86_64/memxor.asm and
memxor.c.

It would make sense to add similar client requests to more testcases.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140105090850</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-01-05 09:08:50-0400</timestampReceived><subject>Nits: Sorted sources in Makefile.in</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

(Don't know if this is anything you want to fix Niels.)

While working on the integration of chacha into Nettle i noticed that
the source files listed in Makefile.in are alphabetically sorted. At
least almost.

Here is a patch that sorts the nettle_SOURCES.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlLJISIACgkQZoPr8HT30QFgTgCgmJ8OlJlK15if2x3eYPABuVHu
fhcAn2wVaUIl60cpD8aTpdEHKbUsClIe
=fyP1
-----END PGP SIGNATURE-----

["Makefile.in.patch" (text/plain)]

diff --git a/Makefile.in b/Makefile.in
index 05e6ade..59193c8 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -75,42 +75,42 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 arcfour.c arcfour-crypt.c arcfour-meta.c \
 		 arctwo.c arctwo-meta.c gosthash94-meta.c \
 		 base16-encode.c base16-decode.c base16-meta.c \
-                 base64-encode.c base64-decode.c base64-meta.c \
+		 base64-encode.c base64-decode.c base64-meta.c \
+		 blowfish.c \
+		 buffer.c buffer-init.c realloc.c \
 		 camellia-crypt.c camellia-crypt-internal.c \
 		 camellia-set-encrypt-key.c camellia-set-decrypt-key.c \
 		 camellia-table.c camellia-meta.c \
 		 cast128.c cast128-meta.c \
-		 blowfish.c \
 		 cbc.c ctr.c gcm.c gcm-aes.c \
 		 des.c des3.c des-compat.c eax.c \
+		 gosthash94.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
 		 hmac-sha224.c hmac-sha256.c hmac-sha384.c hmac-sha512.c \
-		 pbkdf2.c pbkdf2-hmac-sha1.c pbkdf2-hmac-sha256.c \
 		 knuth-lfib.c \
+		 memxor.c \
 		 md2.c md2-meta.c md4.c md4-meta.c \
 		 md5.c md5-compress.c md5-compat.c md5-meta.c \
-		 memxor.c \
-		 gosthash94.c \
+		 nettle-meta-hashes.c nettle-meta-ciphers.c \
+		 nettle-meta-armors.c \
+		 pbkdf2.c pbkdf2-hmac-sha1.c pbkdf2-hmac-sha256.c \
 		 ripemd160.c ripemd160-compress.c ripemd160-meta.c \
 		 salsa20-core-internal.c \
 		 salsa20-crypt.c salsa20r12-crypt.c salsa20-set-key.c \
+		 serpent-set-key.c serpent-encrypt.c serpent-decrypt.c \
+		 serpent-meta.c \
 		 sha1.c sha1-compress.c sha1-meta.c \
 		 sha256.c sha256-compress.c sha224-meta.c sha256-meta.c \
 		 sha512.c sha512-compress.c sha384-meta.c sha512-meta.c \
 		 sha3.c sha3-permute.c \
 		 sha3-224.c sha3-224-meta.c sha3-256.c sha3-256-meta.c \
 		 sha3-384.c sha3-384-meta.c sha3-512.c sha3-512-meta.c\
-		 serpent-set-key.c serpent-encrypt.c serpent-decrypt.c \
-		 serpent-meta.c \
 		 twofish.c twofish-meta.c \
 		 umac-nh.c umac-nh-n.c umac-l2.c umac-l3.c \
 		 umac-poly64.c umac-poly128.c umac-set-key.c \
 		 umac32.c umac64.c umac96.c umac128.c \
-		 yarrow256.c yarrow_key_event.c \
-		 buffer.c buffer-init.c realloc.c \
-		 nettle-meta-hashes.c nettle-meta-ciphers.c \
-		 nettle-meta-armors.c \
-		 write-be32.c write-le32.c write-le64.c
+		 write-be32.c write-le32.c write-le64.c \
+		 yarrow256.c yarrow_key_event.c
 
 hogweed_SOURCES = sexp.c sexp-format.c \
 		  sexp-transport.c sexp-transport-format.c \


</body></email><email><emailId>20140106193722</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-06 19:37:22-0400</timestampReceived><subject>Re: Valgrind for side channel testing</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; Related to Valgrind - Adam Langley has created ctgrind - a way to use
&gt; Valgrind to test for timing based side channels:
&gt;
&gt; https://github.com/agl/ctgrind

Cool. After a quick read of the README, it sounds likt one doesn't even
need a new tool. Just let the test programs use
VALGRIND_MAKE_MEM_UNDEFINED to mark the areas with secret data, which
memory accesses and branches ought to not depend on.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140103152933</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-01-03 15:29:33-0400</timestampReceived><subject>Regarding the nettle release plan page</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Really good with the release plan page for Nettle:
http://www.lysator.liu.se/~nisse/nettle/plan.html

A few (bikeshed) comments etc.

(1) I would suggest not using colors as distinguisher for what is done
(green), what is critical for the release (red) and what is nice to have
(grayish). I would instead suggest having subsections with explicit
headers stating this instead (done, important, nice to have). Colors are
harder to parse and esp red-green is bad when dealing with a lot of male
individuals.

(2) How about putting up an estimated release schedule at the top of the
page. For example such as:

- - 2014-01-xx: Feature freeze for 2.8 (branch date)
- - 2014-02-xx: Testing and bug fix completed.
- - 2014-03-xx: 2.8 RC1
- - 2014-04-xx: 2.8 Released (label date)

(I have no idea what release schedule you in fact have in mind - if it
is 4 days, 4 weeks of 4 months to do the release.)

(3) I'll try and work on the chacha support files the next weeks.

(4) I'm prepared to do the darwin testing on OSX 10.9.x

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlLG110ACgkQZoPr8HT30QGbXACgpU2K0VxrKfQkZUoUVXfdLEed
CVgAn0UF6IpAEf8+waGIocrp50NH/El/
=rwsu
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140103154821</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-01-03 15:48:21-0400</timestampReceived><subject>Minor nits/comments on sha256.c</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

I took a look at the code in sha256.c and have a couple of small comments.

(1) The K table is not zero extended. This just makes the table look weird:

K[64] =
{
  0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL,
  0x3956c25bUL, 0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL,
  0xd807aa98UL, 0x12835b01UL, 0x243185beUL, 0x550c7dc3UL,
  0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL, 0xc19bf174UL,
  0xe49b69c1UL, 0xefbe4786UL, 0xfc19dc6UL, 0x240ca1ccUL,
  0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL,
  0x983e5152UL, 0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL,
  0xc6e00bf3UL, 0xd5a79147UL, 0x6ca6351UL, 0x14292967UL,
  0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL, 0x53380d13UL,
  0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,
  0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL,
  0xd192e819UL, 0xd6990624UL, 0xf40e3585UL, 0x106aa070UL,
  0x19a4c116UL, 0x1e376c08UL, 0x2748774cUL, 0x34b0bcb5UL,
  0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL, 0x682e6ff3UL,
  0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,
  0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL,
};

I would suggest zero extending the table to get the same textual width
of all elements.


(2) Pretty cool that you actually generate the constants from the FIPS
180 specification! Good verification.


(3) The SHA-224 H0-table refers to the _SHA256_DIGEST_LENGTH. This imho
should be a separate define _SHA224_DIGEST_LENGTH. Yes, it is the same
length in practice but it looks weird esp since the generated digest for
SHA-224 is in fact not the same even though the internal diget state
vector H is the same length as SHA-256.


(4) I'll think I'm going to ask on the SHA-3 maillist (hosted by NIST)
if John Kelsey &amp; Co can provide an explanation for the H0-constants used
in SHA-224 and SHA-1 in the same way as for SHA-256, SHA-512 etc. It
really is a bit peculiar that they don't.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlLG28UACgkQZoPr8HT30QFslACgobq4tXi1dzRao/QIu4/tEUPG
ev0An2Mul1IqawWz1mRAQq26i8UNeizX
=NxwW
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140106133948</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-01-06 13:39:48-0400</timestampReceived><subject>Valgrind for side channel testing</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Related to Valgrind - Adam Langley has created ctgrind - a way to use
Valgrind to test for timing based side channels:

https://github.com/agl/ctgrind

Dunno if you have tested it on Nettle Niels or if it is even applicable.
Just wanted to mention it.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlLKsiQACgkQZoPr8HT30QFmDwCgnt4T0T2WTYHSoO9GPSVAycPE
G68An3w4JSe0w1Padn2v6E4TXYhytNXe
=VX0C
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140104022344</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2014-01-04 02:23:44-0400</timestampReceived><subject>nettle haskell bindings</subject><body>


hi nettle folks--

The list of language bindings at:

  http://www.lysator.liu.se/~nisse/nettle/

doesn't mention haskell yet, but Clint Adams' nettle bindings for that
language are available here:

  http://hackage.haskell.org/package/bindings-nettle

They're not exhaustive, but probably worth pointing to.

Thanks for nettle!

        --dkg

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20140121191717</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-21 19:17:17-0400</timestampReceived><subject>Re: Camellia reorg</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt;&gt; Camellia uses fewer subkeys for 128 bit keys than for 192 or 256 bit
&gt;&gt; keys. So this is a bit similar to AES, and I think an analogous reorg
&gt;&gt; would make sense.
&gt;
&gt; I tried this out now. New header file below.

Now merged in the master branch. Unlike the aes reorg there's *no*
backwards compatible camellia_ctx. Is that ok?

My thinking on backwards compatibility is:

1. ABI compatibility (i.e., ability to link applications with the new
   version of the library, without recompilation) is broken anyway, so
   that's not an issue at the moment.

2. When it's trivial to implement a backwards compatible API (i.e., the
   ability to recompile applications with no changes to their source
   code), do it.

3. For features that are widely used, e.g., AES, implement backwards
   compatible interfaces also when that requires a bit more effort.
  
For (3), I think Camellia is borderline. It's been implemented in
Nettle for a couple of releases, but I expect few applications use it.
And I should also add that applications using nettle_camellia* from
nettle-meta.h (and do so in the documented way) are unaffected by this
change.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140127180026</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-27 18:00:26-0400</timestampReceived><subject>chacha assembly</subject><body>

I've now added some basic chacha x86_64 assembly. This gives a modest
speedup over the code generated by gcc-4.7.2, about 8% in this machine.
Apparently, gcc is pretty good at vectorizing this (and there seems to
virtually no difference for salsa20).

I have one question, regarding the different rotation counts in chacha,
including 16 and 8. I think I've read that this is supposed to be
advantageous on x86_64, but after reviewing the various pshuf*
instructions, it's not clear how. I now do these as left shith + right
shift + or. Maybe the rotate by 16 bits can be done with pshufhw +
pshuflw. Or am I missing some other way to do a rotate on an %xmm
register?

Anyway, there are other ways to optimize chacha (and salsa20), by doing
two blocks at a time (and I think we have enough registers for doing
three chacha blocks at a time, if needed).

For simplicity, I'm considering to write an assembly _chacha_crypt
function which supports only an integral number of blocks, and then let
chacha_crypt handle a final partial block using _chacha_core + memxor
instead. (Half of the current x86_64/salsa20-crypt.asm is the logic to
store the final partial block, for questionable benefit). So if this
works out well for chacha, the same could be done for salsa20.

Ah, and chacha seems to be about 15% faster than salsa20
Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140130083135</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-01-30 08:31:35-0400</timestampReceived><subject>Re: chacha assembly</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

(Sorry for slow response to ChaCha stuff.)

Niels Möller wrote:
&gt; I've now added some basic chacha x86_64 assembly. This gives a
&gt; modest speedup over the code generated by gcc-4.7.2, about 8% in this
&gt; machine. Apparently, gcc is pretty good at vectorizing this (and
&gt; there seems to virtually no difference for salsa20).

By vectorizing you mean running quarterrounds in parallel? You should be
able to do at least four in parallel (if there are regs available). 8
requires pipelining. I've implemented ChaCha with four parallel QRs in HW:

https://github.com/secworks/swchacha

(Which is just anecdotal to this discussion.)


&gt; I have one question, regarding the different rotation counts in
&gt; chacha, including 16 and 8. I think I've read that this is supposed
&gt; to be advantageous on x86_64, but after reviewing the various pshuf* 
&gt; instructions, it's not clear how. I now do these as left shith +
&gt; right shift + or. Maybe the rotate by 16 bits can be done with
&gt; pshufhw + pshuflw. Or am I missing some other way to do a rotate on
&gt; an %xmm register?

Have you looked at the asm code by DJB? He does up to four blocks in
parallel and do some tricks with the shifts. xmm-5 should be relevant.

http://cr.yp.to/chacha.html

&gt; Ah, and chacha seems to be about 15% faster than salsa20

Which seems to match what DJB claims in the paper. Good.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlLqDecACgkQZoPr8HT30QEQrwCdHhBAPgIDKpiQWZMxDE6uTIrv
CU8AoOaeSJ/XkT9dNIsiP8Bnl48hFC80
=Nezg
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140105174439</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-01-05 17:44:39-0400</timestampReceived><subject>[PATCH] Integration of chacha in Makefile.in</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Here is the patch to add build chacha in Nettle.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlLJmgcACgkQZoPr8HT30QHYdgCg6PSU2fNILvFIwqKhMpBUBm7w
ymwAn2WKB6xlAeCLTp0hZjQk8OUmsauv
=1UMx
-----END PGP SIGNATURE-----

["Makefile.in.chacha-patch" (text/plain)]

diff --git a/Makefile.in b/Makefile.in
index 05e6ade..32a235b 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -80,6 +80,7 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 camellia-set-encrypt-key.c camellia-set-decrypt-key.c \
 		 camellia-table.c camellia-meta.c \
 		 cast128.c cast128-meta.c \
+		 chacha-core-internal.c chacha-crypt.c chacha-init.c \
 		 blowfish.c \
 		 cbc.c ctr.c gcm.c gcm-aes.c \
 		 des.c des3.c des-compat.c eax.c \
@@ -150,6 +151,7 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 HEADERS = aes.h arcfour.h arctwo.h asn1.h bignum.h blowfish.h \
 	  base16.h base64.h buffer.h camellia.h cast128.h \
 	  cbc.h ctr.h \
+	  chacha.h \
 	  des.h des-compat.h dsa.h eax.h ecc-curve.h ecc.h ecdsa.h \
 	  gcm.h gosthash94.h hmac.h \
 	  knuth-lfib.h \


</body></email><email><emailId>20140107214351</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-07 21:43:51-0400</timestampReceived><subject>Re: [PATCH] Integration of chacha in Makefile.in</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; Here is the patch to add build chacha in Nettle.

Nice. I've tried this, together with your code at
https://github.com/secworks/nettle/tree/master/chacha (is that your
latest code? It was slightly inconsistent, with some function still
expecting nrounds in the context struct).

I edited it a bit, to take out support for rounds != 20 for now (except
for the _chacha_core_internal function), and I split the set key
function into two functions for the two available key sizes, 128 and 256
bits.

Resulting patch below. I think I'll check this in soon. Next steps would
be:

1. Add it to the benchmark (probably easiest to do it the same way as
   salsa20, with a struct in nettle-internal.c).

2. Adapt the test program to nettle conventions. Possibly convert the
   round != 20 test cases to tests of the chacha_core function?

3. Write some assembly.

Regards,
/Niels

diff --git a/Makefile.in b/Makefile.in
index 10715b2..092c217 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -80,8 +80,10 @@ nettle_SOURCES = aes-decrypt-internal.c aes-decrypt.c \
 		 camellia-crypt.c camellia-crypt-internal.c \
 		 camellia-set-encrypt-key.c camellia-set-decrypt-key.c \
 		 camellia-table.c camellia-meta.c \
-		 cast128.c cast128-meta.c \
-		 cbc.c ctr.c \
+		 cast128.c cast128-meta.c cbc.c \
+		 chacha-crypt.c chacha-core-internal.c chacha-set-iv.c \
+		 chacha128-set-key.c chacha256-set-key.c \
+		 ctr.c \
 		 des.c des3.c des-compat.c eax.c \
 		 gcm.c gcm-aes.c gosthash94.c \
 		 hmac.c hmac-md5.c hmac-ripemd160.c hmac-sha1.c \
@@ -149,7 +151,7 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 
 HEADERS = aes.h arcfour.h arctwo.h asn1.h bignum.h blowfish.h \
 	  base16.h base64.h buffer.h camellia.h cast128.h \
-	  cbc.h ctr.h \
+	  cbc.h chacha.h ctr.h \
 	  des.h des-compat.h dsa.h eax.h ecc-curve.h ecc.h ecdsa.h \
 	  gcm.h gosthash94.h hmac.h \
 	  knuth-lfib.h \
diff --git a/chacha-core-internal.c b/chacha-core-internal.c
index e69de29..fb695ff 100644
--- a/chacha-core-internal.c
+++ b/chacha-core-internal.c
@@ -0,0 +1,120 @@
+/* chacha-core-internal.c
+ *
+ * Core functionality of the ChaCha stream cipher.
+ * Heavily based on the Salsa20 implementation in Nettle.
+ *
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Joachim StrÃ¶mbergson
+ * Copyright (C) 2012 Simon Josefsson, Niels MÃ¶ller
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+/* Based on:
+   chacha-ref.c version 2008.01.20.
+   D. J. Bernstein
+   Public domain.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "chacha.h"
+
+#include "macros.h"
+
+#ifndef CHACHA_DEBUG
+# define CHACHA_DEBUG 0
+#endif
+
+#if CHACHA_DEBUG
+# include &lt;stdio.h&gt;
+# define DEBUG(i) do {				\
+    unsigned debug_j;				\
+    for (debug_j = 0; debug_j &lt; 16; debug_j++)	\
+      {						\
+	if (debug_j == 0)			\
+	  fprintf(stderr, "%2d:", (i));		\
+	else if (debug_j % 4 == 0)		\
+	  fprintf(stderr, "\n   ");		\
+	fprintf(stderr, " %8x", x[debug_j]);	\
+      }						\
+    fprintf(stderr, "\n");			\
+  } while (0)
+#else
+# define DEBUG(i)
+#endif
+
+#ifdef WORDS_BIGENDIAN
+#define LE_SWAP32(v)				\
+  ((ROTL32(8,  v) &amp; 0x00FF00FFUL) |		\
+   (ROTL32(24, v) &amp; 0xFF00FF00UL))
+#else
+#define LE_SWAP32(v) (v)
+#endif
+
+#define QROUND(x0, x1, x2, x3) do { \
+  x0 = x0 + x1; x3 = ROTL32(16, (x0 ^ x3)); \
+  x2 = x2 + x3; x1 = ROTL32(12, (x1 ^ x2)); \
+  x0 = x0 + x1; x3 = ROTL32(8,  (x0 ^ x3)); \
+  x2 = x2 + x3; x1 = ROTL32(7,  (x1 ^ x2)); \
+  } while(0)
+
+void
+_chacha_core(uint32_t *dst, const uint32_t *src, unsigned rounds)
+{
+  uint32_t x[_CHACHA_STATE_LENGTH];
+  unsigned i;
+
+  assert ( (rounds &amp; 1) == 0);
+
+  memcpy (x, src, sizeof(x));
+  for (i = 0; i &lt; rounds;i += 2)
+    {
+      DEBUG (i);
+      QROUND(x[0], x[4], x[8],  x[12]);
+      QROUND(x[1], x[5], x[9],  x[13]);
+      QROUND(x[2], x[6], x[10], x[14]);
+      QROUND(x[3], x[7], x[11], x[15]);
+
+      DEBUG (i+1);
+      QROUND(x[0], x[5], x[10], x[15]);
+      QROUND(x[1], x[6], x[11], x[12]);
+      QROUND(x[2], x[7], x[8],  x[13]);
+      QROUND(x[3], x[4], x[9],  x[14]);
+    }
+  DEBUG (i);
+
+  for (i = 0; i &lt; _CHACHA_STATE_LENGTH; i++)
+    {
+      uint32_t t = x[i] + src[i];
+      dst[i] = LE_SWAP32 (t);
+    }
+}
+
+
+
+
+
+
+
diff --git a/chacha-crypt.c b/chacha-crypt.c
index e69de29..1aed643 100644
--- a/chacha-crypt.c
+++ b/chacha-crypt.c
@@ -0,0 +1,77 @@
+/* salsa20-crypt.c
+ *
+ * The crypt function in the ChaCha stream cipher.
+ * Heavily based on the Salsa20 implementation in Nettle.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Joachim StrÃ¶mbergson
+ * Copyright (C) 2012 Simon Josefsson
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+/* Based on:
+   chacha-ref.c version 2008.01.20.
+   D. J. Bernstein
+   Public domain.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;string.h&gt;
+
+#include "chacha.h"
+
+#include "macros.h"
+#include "memxor.h"
+
+#define CHACHA_ROUNDS 20
+
+void
+chacha_crypt(struct chacha_ctx *ctx,
+	      size_t length,
+	      uint8_t *c,
+	      const uint8_t *m)
+{
+  if (!length)
+    return;
+  
+  for (;;)
+    {
+      uint32_t x[_CHACHA_STATE_LENGTH];
+
+      _chacha_core (x, ctx-&gt;state, CHACHA_ROUNDS);
+
+      ctx-&gt;state[9] += (++ctx-&gt;state[8] == 0);
+
+      /* stopping at 2^70 length per nonce is user's responsibility */
+      
+      if (length &lt;= CHACHA_BLOCK_SIZE)
+	{
+	  memxor3 (c, m, x, length);
+	  return;
+	}
+      memxor3 (c, m, x, CHACHA_BLOCK_SIZE);
+
+      length -= CHACHA_BLOCK_SIZE;
+      c += CHACHA_BLOCK_SIZE;
+      m += CHACHA_BLOCK_SIZE;
+  }
+}
diff --git a/chacha-set-iv.c b/chacha-set-iv.c
index e69de29..50d9835 100644
--- a/chacha-set-iv.c
+++ b/chacha-set-iv.c
@@ -0,0 +1,52 @@
+/* chacha-set-iv.c
+ *
+ * Setting the IV the ChaCha stream cipher.
+ * Based on the Salsa20 implementation in Nettle.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Joachim StrÃ¶mbergon
+ * Copyright (C) 2012 Simon Josefsson
+ * Copyright (C) 2012, 2014 Niels MÃ¶ller
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+/* Based on:
+   ChaCha specification (doc id: 4027b5256e17b9796842e6d0f68b0b5e) and reference 
+   implementation dated 2008.01.20
+   D. J. Bernstein
+   Public domain.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+
+#include "chacha.h"
+
+#include "macros.h"
+void
+chacha_set_iv(struct chacha_ctx *ctx, const uint8_t *iv)
+{
+  ctx-&gt;state[12] = 0;
+  ctx-&gt;state[13] = 0;
+  ctx-&gt;state[14] = LE_READ_UINT32(iv + 0);
+  ctx-&gt;state[15] = LE_READ_UINT32(iv + 4);
+}
diff --git a/chacha.h b/chacha.h
index e69de29..e965234 100644
--- a/chacha.h
+++ b/chacha.h
@@ -0,0 +1,91 @@
+/* chacha.h
+ *
+ * The ChaCha stream cipher.
+ * Heavily based on the Salsa20 source code in Nettle.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Joachim StrÃ¶mbergson
+ * Copyright (C) 2012 Simon Josefsson
+ * Copyright (C) 2001 Niels MÃ¶ller
+ *
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#ifndef NETTLE_CHACHA_H_INCLUDED
+#define NETTLE_CHACHA_H_INCLUDED
+
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Name mangling */
+#define chacha128_set_key nettle_chacha128_set_key
+#define chacha256_set_key nettle_chacha256_set_key
+#define chacha_set_iv nettle_chacha_set_iv
+#define chacha_crypt nettle_chacha_crypt
+#define _chacha_core _nettle_chacha_core
+
+/* Minimum and maximum keysizes, and a reasonable default. 
+   In octets. */
+#define CHACHA128_KEY_SIZE 16
+#define CHACHA256_KEY_SIZE 32
+#define CHACHA_BLOCK_SIZE 64
+
+#define CHACHA_IV_SIZE 8
+
+#define _CHACHA_STATE_LENGTH 16
+
+struct chacha_ctx
+{
+  /* Indices 0-3 holds a constant (SIGMA or TAU).
+     Indices 4-11 holds the key.
+     Indices 12-13 holds the block counter.
+     Indices 14-15 holds the IV:
+
+     This creates the state matrix:
+     C C C C
+     K K K K
+     K K K K
+     B B I I
+  */
+  uint32_t state[_CHACHA_STATE_LENGTH];
+};
+
+void
+chacha128_set_key(struct chacha_ctx *ct, const uint8_t *key);
+
+void
+chacha256_set_key(struct chacha_ctx *ct, const uint8_t *key);
+  
+void
+chacha_set_iv(struct chacha_ctx *ctx, const uint8_t *iv);
+
+void
+chacha_crypt(struct chacha_ctx *ctx, size_t length, 
+             uint8_t *dst, const uint8_t *src);
+
+void
+_chacha_core(uint32_t *dst, const uint32_t *src, unsigned rounds);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_CHACHA_H_INCLUDED */
diff --git a/chacha128-set-key.c b/chacha128-set-key.c
index e69de29..569e801 100644
--- a/chacha128-set-key.c
+++ b/chacha128-set-key.c
@@ -0,0 +1,61 @@
+/* chacha128-set-key.c
+ *
+ * ChaCha key setup for 128-bit keys.
+ * Based on the Salsa20 implementation in Nettle.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Joachim StrÃ¶mbergon
+ * Copyright (C) 2012 Simon Josefsson
+ * Copyright (C) 2012, 2014 Niels MÃ¶ller
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+/* Based on:
+   ChaCha specification (doc id: 4027b5256e17b9796842e6d0f68b0b5e) and reference 
+   implementation dated 2008.01.20
+   D. J. Bernstein
+   Public domain.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "chacha.h"
+
+#include "macros.h"
+
+void
+chacha128_set_key(struct chacha_ctx *ctx, const uint8_t *key)
+{
+  static const uint32_t tau[4] = {
+    /* "expand 16-byte k" */
+    0x61707865, 0x3120646e, 0x79622d36, 0x6b206574
+  };
+
+  ctx-&gt;state[8]  = ctx-&gt;state[4] = LE_READ_UINT32(key + 0);
+  ctx-&gt;state[9]  = ctx-&gt;state[5] = LE_READ_UINT32(key + 4);
+  ctx-&gt;state[10] = ctx-&gt;state[6] = LE_READ_UINT32(key + 8);
+  ctx-&gt;state[11] = ctx-&gt;state[7] = LE_READ_UINT32(key + 12);
+
+  memcpy (ctx-&gt;state, tau, sizeof(tau));
+}
diff --git a/chacha256-set-key.c b/chacha256-set-key.c
index e69de29..66e314b 100644
--- a/chacha256-set-key.c
+++ b/chacha256-set-key.c
@@ -0,0 +1,65 @@
+/* chacha256-set-key.c
+ *
+ * ChaCha key setup for 256-bit keys.
+ * Based on the Salsa20 implementation in Nettle.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Joachim StrÃ¶mbergon
+ * Copyright (C) 2012 Simon Josefsson
+ * Copyright (C) 2012, 2014 Niels MÃ¶ller
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+/* Based on:
+   ChaCha specification (doc id: 4027b5256e17b9796842e6d0f68b0b5e) and reference 
+   implementation dated 2008.01.20
+   D. J. Bernstein
+   Public domain.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include "chacha.h"
+
+#include "macros.h"
+
+void
+chacha256_set_key(struct chacha_ctx *ctx, const uint8_t *key)
+{
+  static const uint32_t sigma[4] = {
+    /* "expand 32-byte k" */
+    0x61707865, 0x3320646e, 0x79622d32, 0x6b206574
+  };
+  ctx-&gt;state[4] = LE_READ_UINT32(key + 0);
+  ctx-&gt;state[5] = LE_READ_UINT32(key + 4);
+  ctx-&gt;state[6] = LE_READ_UINT32(key + 8);
+  ctx-&gt;state[7] = LE_READ_UINT32(key + 12);
+
+  ctx-&gt;state[8]  = LE_READ_UINT32(key + 16);
+  ctx-&gt;state[9]  = LE_READ_UINT32(key + 20);
+  ctx-&gt;state[10] = LE_READ_UINT32(key + 24);
+  ctx-&gt;state[11] = LE_READ_UINT32(key + 28);
+
+  memcpy (ctx-&gt;state, sigma, sizeof(sigma));
+}
diff --git a/testsuite/.test-rules.make b/testsuite/.test-rules.make
index 5549fc0..3d6137f 100644
--- a/testsuite/.test-rules.make
+++ b/testsuite/.test-rules.make
@@ -22,6 +22,9 @@ base64-test$(EXEEXT): base64-test.$(OBJEXT)
 camellia-test$(EXEEXT): camellia-test.$(OBJEXT)
 	$(LINK) camellia-test.$(OBJEXT) $(TEST_OBJS) -o camellia-test$(EXEEXT)
 
+chacha-test$(EXEEXT): chacha-test.$(OBJEXT)
+	$(LINK) chacha-test.$(OBJEXT) $(TEST_OBJS) -o chacha-test$(EXEEXT)
+
 des-test$(EXEEXT): des-test.$(OBJEXT)
 	$(LINK) des-test.$(OBJEXT) $(TEST_OBJS) -o des-test$(EXEEXT)
 
diff --git a/testsuite/Makefile.in b/testsuite/Makefile.in
index 0ad950d..8838bef 100644
--- a/testsuite/Makefile.in
+++ b/testsuite/Makefile.in
@@ -13,7 +13,7 @@ PRE_LDFLAGS = -L..
 TS_NETTLE_SOURCES = aes-test.c arcfour-test.c arctwo-test.c \
 		    blowfish-test.c cast128-test.c \
 	            base16-test.c base64-test.c \
-		    camellia-test.c \
+		    camellia-test.c chacha-test.c \
 		    des-test.c des3-test.c des-compat-test.c \
 		    md2-test.c md4-test.c md5-test.c md5-compat-test.c \
 		    memxor-test.c gosthash94-test.c \
diff --git a/testsuite/chacha-test.c b/testsuite/chacha-test.c
index e69de29..f1ed0ea 100644
--- a/testsuite/chacha-test.c
+++ b/testsuite/chacha-test.c
@@ -0,0 +1,251 @@
+/* chacha-test.c
+ *
+ * Test program for the ChaCha stream cipher implementation.
+ */
+
+/* nettle, low-level cryptographics library
+ *
+ * Copyright (C) 2013 Joachim StrÃ¶mbergson
+ * Copyright (C) 2012 Niels MÃ¶ller
+ *  
+ * The nettle library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ * 
+ * The nettle library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the nettle library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02111-1301, USA.
+ */
+
+#include "testutils.h"
+
+#include "chacha.h"
+
+static void
+print_block(uint8_t block[64])
+{
+  uint8_t i;
+
+  for (i = 0 ; i &lt; 64 ; i++) {
+    printf("0x%02x ", block[i]);
+    if (((i + 1) % 8) == 0) {
+      printf("\n");
+    }
+  }
+  printf("\n");
+}
+
+
+static void
+test_chacha(const uint8_t *key, const uint8_t *iv, uint8_t *expected, 
+	    uint8_t keylength)
+{
+    uint8_t cipher_data[64] =  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+    uint8_t cipher_result[64] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+    
+    struct chacha_ctx cipher_ctx;
+
+    unsigned i, errors;
+
+    switch (keylength)
+      {
+      default:
+	abort ();
+      case 16:
+	chacha128_set_key(&amp;cipher_ctx, key);
+	break;
+      case 32:
+	chacha256_set_key(&amp;cipher_ctx, key);
+	break;
+      }
+
+    chacha_set_iv(&amp;cipher_ctx, iv);
+    chacha_crypt(&amp;cipher_ctx, 64, &amp;cipher_result[0], &amp;cipher_data[0]);
+
+    if (verbose)
+      {
+        printf("Result after encryption:\n");
+        print_block(cipher_result);
+      }
+
+    errors = 0;
+    for (i = 0 ; i &lt; 64 ; i++)
+      if (cipher_result[i] != expected[i])
+        errors++;
+    
+    if (errors &gt; 0)
+      {
+	printf("Error, expected:\n");
+	print_block(&amp;expected[0]);
+	printf("Got:\n");
+	print_block(cipher_result);
+      }
+    else
+      printf("Success, result matched expected.\n");
+}
+
+
+void
+test_main(void)
+{
+  printf("Test of chacha nettle implementation\n");
+  printf("------------------------------------\n");
+
+  /* Test vectors from draft-strombergson-chacha-test-vectors */
+
+#if 0
+  // TC1: All zero key and IV. 128 bit key and 8 rounds.
+  uint8_t tc1_key[32] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+  uint8_t tc1_keylength = 16;
+
+  uint8_t tc1_iv[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+  uint8_t tc1_rounds = 8;
+
+  uint8_t tc1_expected[64] = {0xe2, 0x8a, 0x5f, 0xa4, 0xa6, 0x7f, 0x8c, 0x5d,
+                              0xef, 0xed, 0x3e, 0x6f, 0xb7, 0x30, 0x34, 0x86,
+                              0xaa, 0x84, 0x27, 0xd3, 0x14, 0x19, 0xa7, 0x29,
+                              0x57, 0x2d, 0x77, 0x79, 0x53, 0x49, 0x11, 0x20,
+                              0xb6, 0x4a, 0xb8, 0xe7, 0x2b, 0x8d, 0xeb, 0x85,
+                              0xcd, 0x6a, 0xea, 0x7c, 0xb6, 0x08, 0x9a, 0x10,
+                              0x18, 0x24, 0xbe, 0xeb, 0x08, 0x81, 0x4a, 0x42,
+                              0x8a, 0xab, 0x1f, 0xa2, 0xc8, 0x16, 0x08, 0x1b};
+
+  test_chacha(&amp;tc1_key[0], &amp;tc1_iv[0], &amp;tc1_expected[0], tc1_keylength, tc1_rounds); 
+
+  
+  // TC2: All zero key and IV. 128 bit key and 12 rounds.
+  uint8_t tc2_key[32] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+  uint8_t tc2_keylength = 16;
+
+  uint8_t tc2_iv[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+  uint8_t tc2_rounds = 12;
+
+  uint8_t tc2_expected[64] = {0xe1, 0x04, 0x7b, 0xa9, 0x47, 0x6b, 0xf8, 0xff,
+                              0x31, 0x2c, 0x01, 0xb4, 0x34, 0x5a, 0x7d, 0x8c,
+                              0xa5, 0x79, 0x2b, 0x0a, 0xd4, 0x67, 0x31, 0x3f,
+                              0x1d, 0xc4, 0x12, 0xb5, 0xfd, 0xce, 0x32, 0x41,
+                              0x0d, 0xea, 0x8b, 0x68, 0xbd, 0x77, 0x4c, 0x36,
+                              0xa9, 0x20, 0xf0, 0x92, 0xa0, 0x4d, 0x3f, 0x95,
+                              0x27, 0x4f, 0xbe, 0xff, 0x97, 0xbc, 0x84, 0x91,
+                              0xfc, 0xef, 0x37, 0xf8, 0x59, 0x70, 0xb4, 0x50};
+
+  test_chacha(&amp;tc2_key[0], &amp;tc2_iv[0], &amp;tc2_expected[0], tc2_keylength, tc2_rounds); 
+
+#endif
+  // TC3: All zero key and IV. 128 bit key and 20 rounds.
+  uint8_t tc3_key[32] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+  uint8_t tc3_keylength = 16;
+
+  uint8_t tc3_iv[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+  uint8_t tc3_expected[64] = {0x89, 0x67, 0x09, 0x52, 0x60, 0x83, 0x64, 0xfd,
+                              0x00, 0xb2, 0xf9, 0x09, 0x36, 0xf0, 0x31, 0xc8,
+                              0xe7, 0x56, 0xe1, 0x5d, 0xba, 0x04, 0xb8, 0x49,
+                              0x3d, 0x00, 0x42, 0x92, 0x59, 0xb2, 0x0f, 0x46,
+                              0xcc, 0x04, 0xf1, 0x11, 0x24, 0x6b, 0x6c, 0x2c,
+                              0xe0, 0x66, 0xbe, 0x3b, 0xfb, 0x32, 0xd9, 0xaa,
+                              0x0f, 0xdd, 0xfb, 0xc1, 0x21, 0x23, 0xd4, 0xb9,
+                              0xe4, 0x4f, 0x34, 0xdc, 0xa0, 0x5a, 0x10, 0x3f};
+
+  test_chacha(&amp;tc3_key[0], &amp;tc3_iv[0], &amp;tc3_expected[0], tc3_keylength); 
+
+#if 0
+  // TC4: Sequence patterns in key and IV. 256 bit key and 8 rounds.
+  uint8_t tc4_key[32] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
+                         0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
+                         0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
+                         0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00};
+  uint8_t tc4_keylength = 32;
+
+  uint8_t tc4_iv[8] = {0x0f, 0x1e, 0x2d, 0x3c, 0x4b, 0x59, 0x68, 0x77};
+
+  uint8_t tc4_rounds = 8;
+
+  uint8_t tc4_expected[64] = {0x60, 0xfd, 0xed, 0xbd, 0x1a, 0x28, 0x0c, 0xb7,
+                              0x41, 0xd0, 0x59, 0x3b, 0x6e, 0xa0, 0x30, 0x90,
+                              0x10, 0xac, 0xf1, 0x8e, 0x14, 0x71, 0xf6, 0x89,
+                              0x68, 0xf4, 0xc9, 0xe3, 0x11, 0xdc, 0xa1, 0x49,
+                              0xb8, 0xe0, 0x27, 0xb4, 0x7c, 0x81, 0xe0, 0x35,
+                              0x3d, 0xb0, 0x13, 0x89, 0x1a, 0xa5, 0xf6, 0x8e,
+                              0xa3, 0xb1, 0x3d, 0xd2, 0xf3, 0xb8, 0xdd, 0x08,
+                              0x73, 0xbf, 0x37, 0x46, 0xe7, 0xd6, 0xc5, 0x67};
+
+  test_chacha(&amp;tc4_key[0], &amp;tc4_iv[0], &amp;tc4_expected[0], tc4_keylength, tc4_rounds); 
+
+  
+  // TC5: Sequence patterns in key and IV. 256 bit key and 12 rounds.
+  uint8_t tc5_key[32] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
+                         0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
+                         0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
+                         0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00};
+  uint8_t tc5_keylength = 32;
+
+  uint8_t tc5_iv[8] = {0x0f, 0x1e, 0x2d, 0x3c, 0x4b, 0x59, 0x68, 0x77};
+
+  uint8_t tc5_rounds = 12;
+
+  uint8_t tc5_expected[64] = {0x6e, 0x93, 0xf2, 0x58, 0x16, 0xed, 0x81, 0x51,
+                              0xdb, 0xab, 0x6c, 0x9a, 0x50, 0x0d, 0x56, 0x2e,
+                              0xf3, 0xac, 0x3c, 0xfd, 0x18, 0x99, 0x70, 0x8c,
+                              0x15, 0x74, 0xb9, 0x12, 0xf7, 0x1b, 0x13, 0x12,
+                              0x11, 0x49, 0x85, 0x21, 0x70, 0xbd, 0x0f, 0x45,
+                              0x43, 0xf0, 0xb7, 0x3f, 0x9f, 0x27, 0xc3, 0x63,
+                              0x77, 0x36, 0x32, 0xe9, 0xe2, 0xaa, 0x63, 0x24,
+                              0xf6, 0xbe, 0xd8, 0x7a, 0xb0, 0xd0, 0x30, 0x5e};
+  
+  test_chacha(&amp;tc5_key[0], &amp;tc5_iv[0], &amp;tc5_expected[0], tc5_keylength, tc5_rounds); 
+
+#endif
+  // TC6: Sequence patterns in key and IV. 256 bit key and 20 rounds.
+  uint8_t tc6_key[32] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
+                         0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
+                         0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
+                         0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00};
+  uint8_t tc6_keylength = 32;
+
+  uint8_t tc6_iv[8] = {0x0f, 0x1e, 0x2d, 0x3c, 0x4b, 0x59, 0x68, 0x77};
+
+  uint8_t tc6_expected[64] = {0x87, 0xfa, 0x92, 0x06, 0x10, 0x43, 0xca, 0x5e,
+                              0x63, 0x1f, 0xed, 0xd8, 0x8e, 0x8b, 0xfb, 0x84,
+                              0xad, 0x6b, 0x21, 0x3b, 0xde, 0xe4, 0xbc, 0x80,
+                              0x6e, 0x27, 0x64, 0x93, 0x5f, 0xb8, 0x90, 0x97,
+                              0x21, 0x8a, 0x89, 0x7b, 0x7a, 0xea, 0xd1, 0x0e,
+                              0x1b, 0x17, 0xf6, 0x80, 0x2b, 0x2a, 0xbd, 0xd9,
+                              0x55, 0x94, 0x90, 0x30, 0x83, 0x73, 0x56, 0x13,
+                              0xd6, 0xb3, 0x53, 0x1b, 0x9e, 0x0d, 0x1b, 0x67};
+
+  test_chacha(&amp;tc6_key[0], &amp;tc6_iv[0], &amp;tc6_expected[0], tc6_keylength); 
+}

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140129073335</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-29 07:33:35-0400</timestampReceived><subject>arctwo</subject><body>

Currently, arctwo-meta.c defines nettle_cipher structs for three key
sizes,

  nettle_arctwo40
  nettle_arctwo64
  nettle_arctwo128

I'm thinking that 40 bit and 64 bit keys are way too small, and I hope
they aren't mainstream, and then maybe the first two definitions can be
deleted.

(Keeping them for backwards compatibility is no big deal, but I'd prefer
to only have reasonably secure ciphers on the nettle_ciphers list). The
underlying arctwo_set_key function would still support all key sizes
specified for arctwo, for applications which really need that.

The arctwo code, including these definitions, was added back in 2004 (a
decade ago!), and the header says

/* This implementation was written by Nikos Mavroyanopoulos for GNUTLS
 * as a Libgcrypt module (gnutls/lib/x509/rc2.c) and later adapted for
 * direct use by Libgcrypt by Werner Koch and later adapted for direct
 * use by Nettle by Simon Josefsson and Niels Möller.
 *
 * The implementation here is based on Peter Gutmann's RRC.2 paper and
 * RFC 2268.
 */

Does anyone here know what applications or protocols use arctwo, and
with which key sizes?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140130193829</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-30 19:38:29-0400</timestampReceived><subject>Deterministic DSA and ECDSA signatures</subject><body>

I just became aware of RFC 6979 "Deterministic Usage of the Digital
Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm
(ECDSA)" (Informational).

I think determinstic signatures are a good thing, and using the secret
key also as a HMAC key to generate the random input is a natural idea.
But then one could arrange the details in many different ways. Is the
method in RFC 6979 a good way?

After a quick reading, the steps c. and d. (Sec. 3.2) seems
questionable; HMAC with a known constant key just seems more complicated
than a simple hashing operation, and no more secure.

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140129082144</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-01-29 08:21:44-0400</timestampReceived><subject>Re: arctwo</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Niels Möller wrote:
&gt; Does anyone here know what applications or protocols use arctwo, and 
&gt; with which key sizes?

There are cipher suites in both SSLv3 and TLS 1.0 that uses RC2 as
session cipher. These are part of the EXPORT ciphers with 40 bit keys.

I tried to look at the report cards from SSL Labs to see how many
actually includes them in the handshake. Judging by somewhat old stats
from Qyalys quite a few servers support RC2 with 40 bit key as well as
128 bit key.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlLouhgACgkQZoPr8HT30QEOawCgwUCPxW4NLedS+JV+66BMEbY3
/F8AoMAirNlHK1XvfCVFMpb7mrT5XWxd
=NUwl
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140129084500</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-01-29 08:45:00-0400</timestampReceived><subject>Re: arctwo</subject><body>

On Wed, Jan 29, 2014 at 9:21 AM, Joachim Str=F6mbergson
&lt;joachim@secworks.se&gt; wrote:
&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt; Aloha!
&gt; Niels M=F6ller wrote:
&gt;&gt; Does anyone here know what applications or protocols use arctwo, and
&gt;&gt; with which key sizes?
&gt; There are cipher suites in both SSLv3 and TLS 1.0 that uses RC2 as
&gt; session cipher. These are part of the EXPORT ciphers with 40 bit keys.

Indeed. In gnutls, however, we never used RC2-40, we had support for
RC4-40 only. Nowdays the export ciphersuites have been dropped so we
don't have either.

However, RC2-40 is used in gnutls to decrypt PKCS #12 files, so it
would be good for RC2-40 to remain so that decryption of any existing
files will remain possible.

regards,
Nikos

</body></email><email><emailId>20140129084712</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-01-29 08:47:12-0400</timestampReceived><subject>Re: arctwo</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Nikos Mavrogiannopoulos wrote:
&gt; However, RC2-40 is used in gnutls to decrypt PKCS #12 files, so it 
&gt; would be good for RC2-40 to remain so that decryption of any
&gt; existing files will remain possible.

Yes, forgot to write about P12 where RC2 can be used. Don't know how
common it is though.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlLowBAACgkQZoPr8HT30QEIbACePRhZQPx9HKuKRr5xJ1ZGt9H9
ygUAoI3Uqh4PEmVuRA5TVytPWRWfkpVM
=qW81
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140129120439</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-29 12:04:39-0400</timestampReceived><subject>Re: arctwo</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; However, RC2-40 is used in gnutls to decrypt PKCS #12 files, so it
&gt; would be good for RC2-40 to remain so that decryption of any existing
&gt; files will remain possible.

Ok, I leave that in, then.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140115210113</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-15 21:01:13-0400</timestampReceived><subject>Re: [PATCH] Integration of chacha in Makefile.in</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I edited it a bit, to take out support for rounds != 20 for now (except
&gt; for the _chacha_core_internal function), and I split the set key
&gt; function into two functions for the two available key sizes, 128 and 256
&gt; bits.

I have a couple of questinos related to chacha naming.

With salsa20, the convention seems to be that "salsa20" is the name of a
family of ciphers, with the main instantiation having 20 rounds, and
variants with names like "salsa20_r12" or "salsa20/12". Which is a bit
clumsy. And then, each round has two possible key sizes.

In the chacha paper I've read, it seems that "chacha" is the name of the
family, and "chacha20" always refers to the 20-round variant. So a
reduced round chacha would be named "chacha12", not "chacha20_r12".
Right?

Should we follow that naming? If so, the 20-round crypt function should
be "chacha20_crypt" (not "chacha_crypt"), and if we introduce a crypt
function with a variable number of rounds, that could be named
"chacha_crypt".

It might be a bit confusing if we have

  chacha20_crypt (20 rounds)
  chacha12_crypt (12 rounds)
  chacha128_set_key (128 key bits)
  chacha256_set_key (256 key bits)

But since the number of rounds is irrelevant to key setup, and key size
is irrelevant to the crypt function, there's logic and method in that
apparent madness. One could have a different name (or alias)
chacha20_128_set_key, but that's clumsy, and I don't think it would
reduce confusion.

if I split the key setup also for salsa20 into two functions for the two
different keysizes, it would make some sense to me to call then
salsa128_set_key and salsa256_set_key (rather than the clumsier
salsa20_128_set_key and salsa20_256_set_key). But I'm not sure which is
most important, consistency with corresponding chacha functions, or
consistency with salsa20 conventions outside of nettle.

In either case, the current salsa20_set_key (with a key size argument)
should be kept for backwards compatibility.

Opinions?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140115212809</emailId><senderName>Stefan =?UTF-8?B?QsO8aGxlcg==?=</senderName><senderEmail>nettle-bugs@stbuehler.de</senderEmail><timestampReceived>2014-01-15 21:28:09-0400</timestampReceived><subject>Re: [PATCH] Integration of chacha in Makefile.in</subject><body>

Hi,

On Wed, 15 Jan 2014 22:01:13 +0100
nisse@lysator.liu.se (Niels Möller) wrote:

&gt; In the chacha paper I've read, it seems that "chacha" is the name of
&gt; the family, and "chacha20" always refers to the 20-round variant. So a
&gt; reduced round chacha would be named "chacha12", not "chacha20_r12".
&gt; Right?

Yes.

&gt; Should we follow that naming? If so, the 20-round crypt function
&gt; should be "chacha20_crypt" (not "chacha_crypt"), and if we introduce
&gt; a crypt function with a variable number of rounds, that could be named
&gt; "chacha_crypt".
&gt; 
&gt; It might be a bit confusing if we have
&gt; 
&gt;   chacha20_crypt (20 rounds)
&gt;   chacha12_crypt (12 rounds)
&gt;   chacha128_set_key (128 key bits)
&gt;   chacha256_set_key (256 key bits)

What about:

  chacha20_crypt (20 rounds)
  chacha12_crypt (12 rounds)
  chacha_set_key128 (128 key bits)
  chacha_set_key256 (256 key bits)
  salsa20_set_key128 (128 key bits)
  salsa20_set_key256 (256 key bits)

&gt; Opinions?

Imho moving Salsa20/R functions to the ChachaR naming would work too :)

And don't forget XSalsa20/r (using HSalsa20/r and an additional 128-bit
nonce, defined only for 256-bit keys afaik, but theoretically should
work with 128-bit keys too)... xsalsa20r12_set_key256? :D
(The number of rounds does actually matter in this case)

regards,
Stefan

</body></email><email><emailId>20140115214143</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-15 21:41:43-0400</timestampReceived><subject>Re: [PATCH] Integration of chacha in Makefile.in</subject><body>

Stefan Bühler &lt;nettle-bugs@stbuehler.de&gt; writes:

&gt; What about:
&gt;
&gt;   chacha20_crypt (20 rounds)
&gt;   chacha12_crypt (12 rounds)
&gt;   chacha_set_key128 (128 key bits)
&gt;   chacha_set_key256 (256 key bits)
&gt;   salsa20_set_key128 (128 key bits)
&gt;   salsa20_set_key256 (256 key bits)

My gut feeling is that think putting the number of bits last is too
inconsistent with aes128_set_*_key and similar functions.

&gt;&gt; Opinions?
&gt;
&gt; Imho moving Salsa20/R functions to the ChachaR naming would work too :)

That's one option. What do others think? (We could keep aliases for
backwards compatibility, whenever practical).

&gt; And don't forget XSalsa20/r (using HSalsa20/r and an additional 128-bit
&gt; nonce, defined only for 256-bit keys afaik, but theoretically should
&gt; work with 128-bit keys too)... xsalsa20r12_set_key256? :D

I'm not familier with those variants. But I think they should have a
different name space (e.g., xsalsa*), so at least they shouldn't collide
with plain salsa20 functions.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140115220500</emailId><senderName>Stefan =?UTF-8?B?QsO8aGxlcg==?=</senderName><senderEmail>nettle-bugs@stbuehler.de</senderEmail><timestampReceived>2014-01-15 22:05:00-0400</timestampReceived><subject>Re: [PATCH] Integration of chacha in Makefile.in</subject><body>

On Wed, 15 Jan 2014 22:41:43 +0100
nisse@lysator.liu.se (Niels Möller) wrote:

&gt; Stefan Bühler &lt;nettle-bugs@stbuehler.de&gt; writes:
&gt; 
&gt; &gt; What about:
&gt; &gt;
&gt; &gt;   chacha20_crypt (20 rounds)
&gt; &gt;   chacha12_crypt (12 rounds)
&gt; &gt;   chacha_set_key128 (128 key bits)
&gt; &gt;   chacha_set_key256 (256 key bits)
&gt; &gt;   salsa20_set_key128 (128 key bits)
&gt; &gt;   salsa20_set_key256 (256 key bits)
&gt; 
&gt; My gut feeling is that think putting the number of bits last is too
&gt; inconsistent with aes128_set_*_key and similar functions.

Imho that is the point; aes128_* are the functions of the AES128
variant, which "accidentally" uses a 128-bit key; the variant could have
a different name (aes10 for 10 cycles), and would still take a 128-bit
key.
chacha_set_key128 is a function that works for all Chacha variants, and
always takes a 128-bit key.

(I wouldn't split the key set functions for Salsa20 and Chacha in the
first place - you didn't say why you wanted to split them, but you
probably have your reasons)

&gt; &gt;&gt; Opinions?
&gt; &gt;
&gt; &gt; Imho moving Salsa20/R functions to the ChachaR naming would work
&gt; &gt; too :)
&gt; 
&gt; That's one option. What do others think? (We could keep aliases for
&gt; backwards compatibility, whenever practical).
&gt; 
&gt; &gt; And don't forget XSalsa20/r (using HSalsa20/r and an additional
&gt; &gt; 128-bit nonce, defined only for 256-bit keys afaik, but
&gt; &gt; theoretically should work with 128-bit keys too)...
&gt; &gt; xsalsa20r12_set_key256? :D
&gt; 
&gt; I'm not familier with those variants. But I think they should have a
&gt; different name space (e.g., xsalsa*), so at least they shouldn't
&gt; collide with plain salsa20 functions.

I just wanted to point out how riddiculous it looks when too many
numbers are in a function name.

XSalsa basically replaces the Salsa20 key in set_iv with one derived
(with HSalsa, selected output from the doublerounds) from the original
key and additional nonce data as temporary iv and counter.
So you would call "xsalsa20_set_iv" or "xsalsa20r12_set_iv"
instead of "salsa20_set_iv", it wouldn't actually need a different
set_key.


</body></email><email><emailId>20140116040409</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-01-16 04:04:09-0400</timestampReceived><subject>Re: [PATCH] Integration of chacha in Makefile.in</subject><body>

On 01/15/2014 10:01 PM, Niels Möller wrote:

&gt; It might be a bit confusing if we have
&gt; 
&gt;   chacha20_crypt (20 rounds)
&gt;   chacha12_crypt (12 rounds)
&gt;   chacha128_set_key (128 key bits)
&gt;   chacha256_set_key (256 key bits)

I'd say to simplify to:
   chacha_crypt (20 rounds)
   chacha128_set_key (128 key bits)
   chacha256_set_key (256 key bits)

   _chacha_crypt (arbitrary number of rounds)

In any case adding an algorithm which isn't used in any standard way is
going to have the same issues (which options to add, how to name them
etc.) and some arbitrary choices will be made anyway. My prediction is
that only the 20 round variant will be used extensively for encryption
and the arbitrary round variant may be used in constructions like
crypt() and so on.

btw. why splitting the chacha_set_key() to chacha128_set_key() and
chacha256_set_key() when the context is exactly the same?

Even in aes where there can be some minor space improvements, it is
quite an overkill to have 9 set_key functions instead of 3. In the end
memory is allocated in pages and saving 8 bytes from aes192 to aes128
isn't going to make any difference. Are there applications where the
benefits outweigh this additional complexity?

regards,
Nikos


</body></email><email><emailId>20140116084104</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-16 08:41:04-0400</timestampReceived><subject>Re: [PATCH] Integration of chacha in Makefile.in</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I'd say to simplify to:
&gt;    chacha_crypt (20 rounds)
&gt;    chacha128_set_key (128 key bits)
&gt;    chacha256_set_key (256 key bits)
&gt;
&gt;    _chacha_crypt (arbitrary number of rounds)

Also makes sense to me. Do chacha users expect that "chacha" means 20
rounds, and not something more general?

&gt; In any case adding an algorithm which isn't used in any standard way is
&gt; going to have the same issues (which options to add, how to name them
&gt; etc.)

Agreed, we shouldn't spend much effort on non-standard variants. I'd
just like to make sure if they're added, it doesn't make a total mess
out of the nettle naming.

&gt; btw. why splitting the chacha_set_key() to chacha128_set_key() and
&gt; chacha256_set_key() when the context is exactly the same?

Maybe I'm not totally rational about this.

But my thinking is that if the typical application does algorithm
selection, including key size, at a higher level (e.g, using
nettle_cipher or some similar application specific abstraction), it's
useless to have another decision point inside the key setup function.

And in addition, for the algorithms that support a few discrete key
sizes, often they are not simply parameterized by the key size, but they
are different key setups, with different operations, or different magic
constants, etc, and it simplifies the code to separate them.

That's why I'm leaning towards dropping the key size argument from
nettle_set_key_func. It makes more sense to have a few wrapper functions
where needed which assigns a constant value for the key size for those
algorithms which truly are parameterized in key size. Than to have
functions which just assert that the key size is the expected value, and
then does the key setup for a fix key size.

A possible comprimize, for algorithms lika salsa20 and chacha which do
use the same context for all key sizes, is to have all of

chacha128_set_key
chacha256_set_key

and

chacha_set_key(..., size_t key_size)
{
  switch (key_size)
    {
    default: abort ();
    case 16:
      chacha128_set_key(...);
      break;
    case 32:
      chacha256_set_key(...);
      break;
    }
}

Maybe that's clutter, but I think the actual complexity cost is pretty
low, so I don't think we have to be very afraid of it.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140117065852</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-01-17 06:58:52-0400</timestampReceived><subject>Re: [PATCH] Integration of chacha in Makefile.in</subject><body>

On 01/16/2014 09:41 AM, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt;&gt; I'd say to simplify to:
&gt;&gt;    chacha_crypt (20 rounds)
&gt;&gt;    chacha128_set_key (128 key bits)
&gt;&gt;    chacha256_set_key (256 key bits)
&gt;&gt;
&gt;&gt;    _chacha_crypt (arbitrary number of rounds)
&gt; 
&gt; Also makes sense to me. Do chacha users expect that "chacha" means 20
&gt; rounds, and not something more general?

The chacha paper uses the term chacha in place of salsa20 so I think it
makes sense to use that term for the default with 20 rounds. In the end
it makes no much difference as it's a matter of conventions in the library.

&gt;&gt; btw. why splitting the chacha_set_key() to chacha128_set_key() and
&gt;&gt; chacha256_set_key() when the context is exactly the same?
&gt; Maybe I'm not totally rational about this.
&gt; But my thinking is that if the typical application does algorithm
&gt; selection, including key size, at a higher level (e.g, using
&gt; nettle_cipher or some similar application specific abstraction), it's
&gt; useless to have another decision point inside the key setup function.
&gt; 
&gt; And in addition, for the algorithms that support a few discrete key
&gt; sizes, often they are not simply parameterized by the key size, but they
&gt; are different key setups, with different operations, or different magic
&gt; constants, etc, and it simplifies the code to separate them.

It pretty much removes a switch, but I don't think that this is an
important simplification. The important I see is the differences in
memory usage by each variant but I'm not sure that's so significant either.

Nevertheless, you're right that nettle is now more consistent. I
remember arguing before for set_key functions that take size and others
that don't, so they couldn't be abstracted.

&gt; That's why I'm leaning towards dropping the key size argument from
&gt; nettle_set_key_func. It makes more sense to have a few wrapper functions
&gt; where needed which assigns a constant value for the key size for those
&gt; algorithms which truly are parameterized in key size. Than to have
&gt; functions which just assert that the key size is the expected value, and
&gt; then does the key setup for a fix key size.
&gt; A possible comprimize, for algorithms lika salsa20 and chacha which do
&gt; use the same context for all key sizes, is to have all of
&gt; chacha_set_key(..., size_t key_size)

I think that would be convenient especially when the old API was like
that, but in the end it adds even more functions so I don't know if it
is good to have.

&gt; Maybe that's clutter, but I think the actual complexity cost is pretty
&gt; low, so I don't think we have to be very afraid of it.

The complexity as of in difficulty to use is pretty much the same (maybe
an annoyance to the users of the previous API). However, now there are
more functions to maintain.

regards,
Nikos


</body></email><email><emailId>20140120131858</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2014-01-20 13:18:58-0400</timestampReceived><subject>Re: [PATCH] Integration of chacha in Makefile.in</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Stefan Bühler &lt;nettle-bugs@stbuehler.de&gt; writes:
&gt;
&gt;&gt; What about:
&gt;&gt;
&gt;&gt;   chacha20_crypt (20 rounds)
&gt;&gt;   chacha12_crypt (12 rounds)
&gt;&gt;   chacha_set_key128 (128 key bits)
&gt;&gt;   chacha_set_key256 (256 key bits)
&gt;&gt;   salsa20_set_key128 (128 key bits)
&gt;&gt;   salsa20_set_key256 (256 key bits)
&gt;
&gt; My gut feeling is that think putting the number of bits last is too
&gt; inconsistent with aes128_set_*_key and similar functions.
&gt;
&gt;&gt;&gt; Opinions?
&gt;&gt;
&gt;&gt; Imho moving Salsa20/R functions to the ChachaR naming would work too :)
&gt;
&gt; That's one option. What do others think? (We could keep aliases for
&gt; backwards compatibility, whenever practical).

I don't like it -- as far as I recall, DJB calls the ciphers Salsa20 and
ChaCha respectively.  When round-specific counts are introduced, the
naming is Salsa20/R and ChaChaR respectively.  I don't think it is good
to move away from the "upstream" naming scheme for a cipher, even if the
naming scheme isn't consistent between ciphers.

Of course, the function names can be discussed more than generic naming.

Maybe it would have been better to call the Salsa20 functions
'salsatwenty' instead, so you would have 'salsatwenty128_set_key' or
similar, although it is a bit ugly.

Of course, there is nothing preventing use of 'salsa20128_set_key'
except that it is difficult to parse if you aren't familiar with
terminology.  Alternatively, 'salsa20_128_set_key'.  I think I prefer
one of these variants the most.

/Simon

</body></email><email><emailId>20140120140914</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-20 14:09:14-0400</timestampReceived><subject>Re: [PATCH] Integration of chacha in Makefile.in</subject><body>

Simon Josefsson &lt;simon@josefsson.org&gt; writes:

&gt; I don't like it -- as far as I recall, DJB calls the ciphers Salsa20 and
&gt; ChaCha respectively.  When round-specific counts are introduced, the
&gt; naming is Salsa20/R and ChaChaR respectively.

That's my understanding too.

&gt; I don't think it is good to move away from the "upstream" naming
&gt; scheme for a cipher, even if the naming scheme isn't consistent
&gt; between ciphers.

I think I agree.

&gt; Alternatively, 'salsa20_128_set_key'.  I think I prefer
&gt; one of these variants the most.

I think it will be 

void
salsa20_128_set_key(struct salsa20_ctx *ctx, const uint8_t *key);
void
salsa20_256_set_key(struct salsa20_ctx *ctx, const uint8_t *key);

void
salsa20_set_key(struct salsa20_ctx *ctx,
		size_t length, const uint8_t *key);

then.

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140120191249</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-01-20 19:12:49-0400</timestampReceived><subject>Re: [PATCH] Integration of chacha in Makefile.in</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Sorry for being less than involved in the discussions. I agree with
Simon on the naming scheme.

MVH
JoachiMS

Niels Möller wrote:
&gt; Simon Josefsson &lt;simon@josefsson.org&gt; writes:
&gt; 
&gt;&gt; I don't like it -- as far as I recall, DJB calls the ciphers
&gt;&gt; Salsa20 and ChaCha respectively.  When round-specific counts are
&gt;&gt; introduced, the naming is Salsa20/R and ChaChaR respectively.
&gt; 
&gt; That's my understanding too.
&gt; 
&gt;&gt; I don't think it is good to move away from the "upstream" naming 
&gt;&gt; scheme for a cipher, even if the naming scheme isn't consistent 
&gt;&gt; between ciphers.
&gt; 
&gt; I think I agree.
&gt; 
&gt;&gt; Alternatively, 'salsa20_128_set_key'.  I think I prefer one of
&gt;&gt; these variants the most.
&gt; 
&gt; I think it will be
&gt; 
&gt; void salsa20_128_set_key(struct salsa20_ctx *ctx, const uint8_t
&gt; *key); void salsa20_256_set_key(struct salsa20_ctx *ctx, const
&gt; uint8_t *key);
&gt; 
&gt; void salsa20_set_key(struct salsa20_ctx *ctx, size_t length, const
&gt; uint8_t *key);
&gt; 
&gt; then.
&gt; 
&gt; Regards, /Niels
&gt; 
&gt; 


- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlLddTEACgkQZoPr8HT30QHuJQCgjardhNxnNu1nwyE1+jznpHhZ
NuoAoPHtxrVEmv/9V8z61ALr1pLOgHsS
=U9w5
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140127124807</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-27 12:48:07-0400</timestampReceived><subject>Re: [PATCH] Integration of chacha in Makefile.in</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Resulting patch below. I think I'll check this in soon. Next steps would
&gt; be:
&gt; 
&gt; 1. Add it to the benchmark (probably easiest to do it the same way as
&gt; salsa20, with a struct in nettle-internal.c).
&gt; 
&gt; 2. Adapt the test program to nettle conventions. Possibly convert the
&gt; round != 20 test cases to tests of the chacha_core function?
&gt; 
&gt; 3. Write some assembly.

Finally, pushed into the repo now. I have done (2); (1) and (3) remains.
Testing could also be improved a bit more. I used the testcases in
https://raw.github.com/secworks/chacha_testvectors/master/doc/draft-strombergson-chacha-test-vectors-02.txt


Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140130083420</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-01-30 08:34:20-0400</timestampReceived><subject>Re: [PATCH] Integration of chacha in Makefile.in</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Niels Möller wrote:
&gt; nisse@lysator.liu.se (Niels Möller) writes:
&gt; 
&gt; &gt; Resulting patch below. I think I'll check this in soon. Next steps
&gt; &gt; would be:
&gt; &gt; 
&gt; &gt; 1. Add it to the benchmark (probably easiest to do it the same way
&gt; &gt; as salsa20, with a struct in nettle-internal.c).
&gt; &gt; 
&gt; &gt; 2. Adapt the test program to nettle conventions. Possibly convert
&gt; &gt; the round != 20 test cases to tests of the chacha_core function?
&gt; &gt; 
&gt; &gt; 3. Write some assembly.
&gt; 
&gt; Finally, pushed into the repo now. I have done (2); (1) and (3)
&gt; remains. Testing could also be improved a bit more. I used the
&gt; testcases in 
&gt; https://raw.github.com/secworks/chacha_testvectors/master/doc/draft-strombergson-chacha-test-vectors-02.txt
&gt; 

So
&gt; 
the interface has been stabilized?, good. Did you base the test
program on the Salsa20 test program or my stuff?

I can see if I can do (1).

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlLqDowACgkQZoPr8HT30QHR4ACgw2QJ/5NdanHbdGpz7Hfp/Mqe
8DoAnjBd4sQZhgLEfx+siKoHvNQvymta
=ymlJ
-----END PGP SIGNATURE-----


</body></email><email><emailId>20140120211254</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-20 21:12:54-0400</timestampReceived><subject>Re: Status of Poly1305 and use of AES-NI in Poly1305, UMAC?</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:
&gt;
&gt;&gt; What is the status of Poly1305 in Nettle, i.e. is the branch ready to be
&gt;&gt; merged into master
&gt;
&gt; There are a couple of things I'd like to do. Quoting a mail from 21/11:

I've done most of this now, and merged into the master branch.

&gt; * Take out the nonce from struct poly1305_ctx, and let poly1305_aes do
&gt;   all nonce handling. poly1305_digest gets the encrypted nonce as
&gt;   argument.

Done.

&gt; * For poly1305_aes, use aes128_ctx (it's hard coded for 128-bit AES
&gt;   anyway), and perhaps rename it to poly1305_aes128.

Done.

&gt; * Introduce a poly1305_update function, and use preprocessor casting
&gt;   tricks to define poly1305_aes128_update (and any other
&gt;   poly1305_*_update) as an alias.

Done, then undone; I don't think we need this generality now. The code
is now organized so that struct poly1305_ctx and related functions only
hold the state related to polynomial arithmetic (and where
implementation details for an optimized implementation are
machine-specific).

While struct poly1305_aes_ctx holds the block buffer, the nonce, and the
corresponding functions take care of buffering, final padding, and
handling of the nonce.

&gt; * Promote union gcm_block to a more general abstraction, renaming it to
&gt;   nettle_block16 or so, and use it to guarantee nicer alignment for
&gt;   block buffer and nonce in poly1305.

Done, but in poly1305 only used for the encrypted nonce argument for
poly1305_digest. For nonce and block, they'll be aligned anyway, and I
see no C code which can take any advantage of word access (except
possibly incrementing the nonce, but that's very marginal).

If you or anyone else can test this on macosx and windows, that would be
nice. The x86_64 assembly is intended to work there too, but not tested.

Some numbers:

On my lowend home machine (AMD E-350), benchmarking gives 11 cycles/byte
for the C implementation. And 3 cycles/byte with the x86_64 assembly,
slightly faster than umac64.

The current source code is 220 lines of C code and 99 lines assembly
(excluding comments and empty lines).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140121080544</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-01-21 08:05:44-0400</timestampReceived><subject>Re: Status of Poly1305 and use of AES-NI in Poly1305, UMAC?</subject><body>

On Mon, Jan 20, 2014 at 10:12 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:

&gt; nisse@lysator.liu.se (Niels M=C3=B6ller) writes:
&gt;
&gt; &gt; Joachim Str=C3=B6mbergson &lt;joachim@secworks.se&gt; writes:
&gt; &gt;
&gt; &gt;&gt; What is the status of Poly1305 in Nettle, i.e. is the branch ready to =
be
&gt; &gt;&gt; merged into master
&gt; &gt;
&gt; &gt; There are a couple of things I'd like to do. Quoting a mail from 21/11:
&gt;
&gt; I've done most of this now, and merged into the master branch.
&gt;
&gt; &gt; * Take out the nonce from struct poly1305_ctx, and let poly1305_aes do
&gt; &gt;   all nonce handling. poly1305_digest gets the encrypted nonce as
&gt; &gt;   argument.
&gt; Done.
&gt;

Is the AEAD construction of poly1305 with chacha [0] planned to be
included? It is currently intended to be used in TLS so it would be a
really useful to have in nettle.

[0]. http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-04

regards,
Nikos

</body></email><email><emailId>20140121084503</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-21 08:45:03-0400</timestampReceived><subject>Re: Status of Poly1305 and use of AES-NI in Poly1305, UMAC?</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Is the AEAD construction of poly1305 with chacha [0] planned to be
&gt; included? It is currently intended to be used in TLS so it would be a
&gt; really useful to have in nettle.

Would make sense, once the spec is stable. Comment on aead-interfaces in
general is appreciated. Maybe RFC5116 is useful guidance,

&gt; [0]. http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-04

Thanks for the pointer. Are you (or anyone else on this list) involved
in this ietf process? On which ietf list is it discussed?

After a quick reading, the following jumps out at me (in Sec. 5):

   The reason for generating the Poly1305 key like this rather than
   using key material from the handshake is that handshake key material
   is per-session, but for a polynomial MAC, a unique, secret key is
   needed per-record.

As far as I understand, you can use the same poly1305 key for a large
number of records/messages, as long as you have a unique nonce for each
message.

Then it should work fine in tls to use a per-session key for both chacha
and poly135, and then use the same nonce for both chacha and poly1305,
based on the record sequence number.

Am I missing something? I guess Adam Langley usually knows what he's
doing. But otherwise, the paragraph in the draft, and the awkward method
it describes, makes absolutely no sense to me.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140121091931</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-01-21 09:19:31-0400</timestampReceived><subject>Re: Status of Poly1305 and use of AES-NI in Poly1305, UMAC?</subject><body>

On Tue, Jan 21, 2014 at 9:45 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

Would make sense, once the spec is stable. Comment on aead-interfaces in
&gt; general is appreciated. Maybe RFC5116 is useful guidance,
&gt;
&gt; &gt; [0]. http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-04
&gt;
&gt; Thanks for the pointer. Are you (or anyone else on this list) involved
&gt; in this ietf process? On which ietf list is it discussed?
&gt;

The IETF WG chairs plan to forward that. Whether the final version will be
the same is unknown, but I find it highly unlikely to change.

After a quick reading, the following jumps out at me (in Sec. 5):
&gt;    The reason for generating the Poly1305 key like this rather than
&gt;    using key material from the handshake is that handshake key material
&gt;    is per-session, but for a polynomial MAC, a unique, secret key is
&gt;    needed per-record.
&gt; As far as I understand, you can use the same poly1305 key for a large
&gt; number of records/messages, as long as you have a unique nonce for each
&gt; message.
&gt;

Indeed, the reason (I presume) for this construction is to avoid a "flaw"
in polynomial MACs. The "flaw" is that if you use a constant key per
session, once an attacker manages to make few forgeries he can recover the
key. This construction by re-keying poly1305 on each record avoids that
issue.


&gt; Am I missing something? I guess Adam Langley usually knows what he's
&gt; doing. But otherwise, the paragraph in the draft, and the awkward method
&gt; it describes, makes absolutely no sense to me.
&gt;

That construction (or at least a very similar one) is described by
Bernstein in "Cryptography in NaCl".

regards,
Nikos

</body></email><email><emailId>20140121094040</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-21 09:40:40-0400</timestampReceived><subject>Re: Status of Poly1305 and use of AES-NI in Poly1305, UMAC?</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; Indeed, the reason (I presume) for this construction is to avoid a "flaw"
&gt; in polynomial MACs. The "flaw" is that if you use a constant key per
&gt; session, once an attacker manages to make few forgeries he can recover the
&gt; key.

Assuming there's no nonce, right? But on second reading, I think the
draft uses no poly1305 nonce, or at least, doesn't use a nonce in the
same way as with poly1305-aes.

But then, the question is how the 32 byte key is used. For poly1305-aes,
you have 16 bytes specifying the point where the polynomial is
evaluated, and a 16 byte aes key used to encrypt the nonce. Question is
how the other 16 bytes are used. I guess they're also mixed into the
digest output in some way.

&gt; That construction (or at least a very similar one) is described by
&gt; Bernstein in "Cryptography in NaCl".

Ok, I have to look that up, probably that will make everything clear.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140121155615</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-01-21 15:56:15-0400</timestampReceived><subject>Re: Status of Poly1305 and use of AES-NI in Poly1305, UMAC?</subject><body>

On Tue, Jan 21, 2014 at 10:40 AM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; =
wrote:
&gt;
&gt; Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:
&gt;
&gt; &gt; Indeed, the reason (I presume) for this construction is to avoid a
"flaw"
&gt; &gt; in polynomial MACs. The "flaw" is that if you use a constant key per
&gt; &gt; session, once an attacker manages to make few forgeries he can recover
the
&gt; &gt; key.
&gt;
&gt; Assuming there's no nonce, right?
Indeed.

&gt; But on second reading, I think the
&gt; draft uses no poly1305 nonce, or at least, doesn't use a nonce in the
&gt; same way as with poly1305-aes.

They have nothing in common. The nonce and the key used by poly1305 in
poly1305-chacha are the first blocks generated by chacha.

regards,
Nikos

</body></email><email><emailId>20140104205431</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-04 20:54:31-0400</timestampReceived><subject>Re: memxor3 could lead to invalid mem accesses</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;  I was debugging an invalid memory access in gnutls and realized that
&gt; the issue is in memxor3 of nettle (2.7.x branch).

I have now tried your new test case. I can reproduce the valgrind
warning. But after stepping through the memxor3 function, I think it's
harmless. This is what happens:

We get an memxor3 call with size 15. We have

  dst area:  0x7fffffffe91d, ending before 0x7fffffffe92c
  src1 area:       0x6333d0, ending before       0x6333df
  src2 area:       0x6333f0, ending before       0x6333ff

Since the end of the destination area, 0x7fffffffe92c, is unaligned, the
initial byte loop processes the last 4 bytes of the areas, and reduces
the length accordingly, to 11. The remaining work stores to the
destination area ending at the aligned address 0x7fffffffe928.

Next, we enter the special case that the src operands have the same
alignment, but different from the destination. Pointers and shift counts
are set up, and the code then makes aligned reads at

 0x6333d0, 0x6333d8 (src1)
 0x6333f0, 0x6333f8 (src2)

The reads at 0x6333d8 and 0x6333f8 include one byte beyond the end of
the input areas, and one of them triggers a valgrind warning.

The result of these reads are xored together, then shifted and ored
together, so that the last five bytes read are ignored (i.e., the byte
beyond the end of input, as well as the 4 bytes already processed). And
the result is then stored at the aligned address 0x7fffffffe920.

Then the code exits the main loop (actually, it never entered, the above
operations were done by the loop setup for odd word count, since the
main loop uses two-way unrolling).

And then there's a final byte loop, processing the first three bytes of
the areas (doing some unnecessary rereads of the input bytes at
addresses 0x6333d[0-2] and 0x6333f[0-2]).

My conclusions are:

1. There's no bug here.

2. We should use the --partial-loads-ok=yes valgrind option. (The manual
   says "Note that code that behaves in this way is in violation of the
   the ISO C/C++ standards, and should be considered broken.", but those
   standards clearly don't apply to assembly code).

3. memxor.c might also use "partial loads" in a way which violates C
   standards. I don't think that's a problem on any real system, and,
   e.g, glibc memcmp does similar tricks.
   
Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140105202154</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-01-05 20:21:54-0400</timestampReceived><subject>Re: memxor3 could lead to invalid mem accesses</subject><body>

On 01/04/2014 09:54 PM, Niels Möller wrote:

&gt;  0x6333d0, 0x6333d8 (src1)
&gt;  0x6333f0, 0x6333f8 (src2)
&gt; The reads at 0x6333d8 and 0x6333f8 include one byte beyond the end of
&gt; the input areas, and one of them triggers a valgrind warning.
[...]
&gt; 1. There's no bug here.

I couldn't deduce that from your description. Why are these reads legal?

&gt; 2. We should use the --partial-loads-ok=yes valgrind option. (The manual
&gt;    says "Note that code that behaves in this way is in violation of the
&gt;    the ISO C/C++ standards, and should be considered broken.", but those
&gt;    standards clearly don't apply to assembly code).
&gt; 3. memxor.c might also use "partial loads" in a way which violates C
&gt;    standards. I don't think that's a problem on any real system, and,
&gt;    e.g, glibc memcmp does similar tricks.

Irrespective of the C standard, why do you think that accessing this
byte outside the buffer boundary is valid? I guess you rely that pages
will be of an aligned size anyway?

regards,
Nikos


</body></email><email><emailId>20140105221350</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-05 22:13:50-0400</timestampReceived><subject>Re: memxor3 could lead to invalid mem accesses</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I couldn't deduce that from your description. Why are these reads legal?

Because they are read at a word aligned address.

&gt; Irrespective of the C standard, why do you think that accessing this
&gt; byte outside the buffer boundary is valid? I guess you rely that pages
&gt; will be of an aligned size anyway?

I expect that every byte of memory which is accessible at all is
accessible using an aligned read access of a full word. I view
byte-sized loads in the instruction set as mostly syntactic sugar for
word-sized loads and masking.

If you are aware of any problems on real systems (say, using memxor with
some memory mapped i/o register area as a source), I'd like to hear the
details.

I see no problem with the x86_64 assembly code. Maybe it's a problem
with the supposedly portable C implementation. There's also other code
depending on endianness (and WORDS_BIGENDIAN), which strictly speaking
is not valid C. But I don't intend to fix such things unless it breaks
things on some otherwise supported platform.

If needed, we can add a configure test and a simple and 100% kosher
byte-by-byte memxor loop for affected systems.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140106085953</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-01-06 08:59:53-0400</timestampReceived><subject>Re: memxor3 could lead to invalid mem accesses</subject><body>

On Sun, Jan 5, 2014 at 11:13 PM, Niels M=C3=B6ller &lt;nisse@lysator.liu.se&gt; w=
rote:

&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt;
&gt; &gt; I couldn't deduce that from your description. Why are these reads legal=
?
&gt; Because they are read at a word aligned address.
&gt;

&gt; &gt; Irrespective of the C standard, why do you think that accessing this
&gt; &gt; byte outside the buffer boundary is valid? I guess you rely that pages
&gt; &gt; will be of an aligned size anyway?
&gt;
&gt; I expect that every byte of memory which is accessible at all is
&gt; accessible using an aligned read access of a full word. I view
&gt; byte-sized loads in the instruction set as mostly syntactic sugar for
&gt; word-sized loads and masking.
&gt;

I understand your argumentation, but is there some fact on that? Is that
part of the x86 or (e.g. the arm) specification?
Moreover should nettle install a valgrind suppression file? That way
projects that are affected will not fail any valgrind tests.

regards,
Nikos

</body></email><email><emailId>20140106131126</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-01-06 13:11:26-0400</timestampReceived><subject>Re: memxor3 could lead to invalid mem accesses</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Nikos Mavrogiannopoulos wrote:
&gt; Moreover should nettle install a valgrind suppression file? That way 
&gt; projects that are affected will not fail any valgrind tests.

IMHO - No!

One can provide a Valgrind specfile, but not install it if there is any
risk of affecting users running Valgrind on their applications without
their knowledge.

The really important thing is to document that the Valgrind specfile
exist, what it does and why.
- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlLKq34ACgkQZoPr8HT30QGP5QCgvUT5ru6Li3A/anSOVRyF+ltV
CGcAmwaf9ESjuV4+GiZOkGUDy5QIhEVN
=EHYa
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140104152800</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-04 15:28:00-0400</timestampReceived><subject>Re: nettle haskell bindings</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; The list of language bindings at:
&gt;
&gt;   http://www.lysator.liu.se/~nisse/nettle/
&gt;
&gt; doesn't mention haskell yet, but Clint Adams' nettle bindings for that
&gt; language are available here:
&gt;
&gt;   http://hackage.haskell.org/package/bindings-nettle

Cool. Added to the list now.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140107220138</emailId><senderName>Stefan =?UTF-8?B?QsO8aGxlcg==?=</senderName><senderEmail>nettle-bugs@stbuehler.de</senderEmail><timestampReceived>2014-01-07 22:01:38-0400</timestampReceived><subject>Re: nettle haskell bindings</subject><body>

Hi,

just for the record:
http://hackage.haskell.org/package/bindings-nettle is a low level
interface; think of it as the *.h header files in C.

I started http://hackage.haskell.org/package/nettle as a "safe"
binding; it should ensure that you can't screw up memory allocation and
so on, because otherwise I don't see a reason not to use C in the first
place :)

regards,
Stefan

</body></email><email><emailId>20140103181612</emailId><senderName>Joachim Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-01-03 18:16:12-0400</timestampReceived><subject>Re: Minor nits/comments on sha256.c</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

(Answering my own mail, nice. ;-)

Joachim Strömbergson wrote:
&gt; (4) I'll think I'm going to ask on the SHA-3 maillist (hosted by
&gt; NIST) if John Kelsey &amp; Co can provide an explanation for the
&gt; H0-constants used in SHA-224 and SHA-1 in the same way as for
&gt; SHA-256, SHA-512 etc. It really is a bit peculiar that they don't.

I've done this and got a response from Thomas Pornin. The problem with
FIPS 180 (including the latest versio 180-4) is that the H0 values for
SHA-1 and SHA-224 lack a stated explanation. Something that exists in
the document for SHA-256, SHA-384 etc.

For SHA-1 the H0 constants are a simple sequence pattern and according
to Thomas actually comes from MD5. Looking at the pattern it is quite
clear that it is in fact a big endian sequence:

(From sha1.c in Nettle):

      /* SHA initial values */
      0x67452301L,
      0xEFCDAB89L,
      0x98BADCFEL,
      0x10325476L,
      0xC3D2E1F0L,

Reading the bytes backwards and right-left it is 0..F and then an
down-up pattern with high nybble going down and low nybble going up.

The H0-values for SHA-224 is actually the low 32-bits of the H0-values
for SHA-384. An easy comparison between the values in chapter 5.3.4 of
FIPS 180-4 and chapter 5.3.2 makes it obvious. And for SHA-384 NIST in
chapter 5.3.4 states:

"These words were obtained by taking the first sixty-four bits of the
fractional parts of the square roots of the ninth through sixteenth
prime numbers."

We should therefore be able to update the shadata program to generate
the SHA-224 constants.

Suggestion: Change the comments in sha256.c (for sha224) to point to the
origin of the constants. And also add a short comment in sha1.c and
md5.c that the constants are simple patterns.

According to Thomas the sequence pattern in md5 was choosen by Rivest
quite arbitrarily.

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlLG/mwACgkQZoPr8HT30QFiZQCg4NyldWQEKcZOrggBr57DhwIL
u34AniQxeKTJIACLCCyWrRFcFZY87ON3
=pnp8
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140103202725</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-03 20:27:25-0400</timestampReceived><subject>Re: Minor nits/comments on sha256.c</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; (1) The K table is not zero extended. This just makes the table look weird:

I'll add a %08lx format to shadata.c.

&gt; (3) The SHA-224 H0-table refers to the _SHA256_DIGEST_LENGTH. This imho
&gt; should be a separate define _SHA224_DIGEST_LENGTH. Yes, it is the same
&gt; length in practice but it looks weird

Maybe this constant is misnamed. It's the size of the *internal* state,
which for sha224 (and sha384) is unrelated to the output digest size.
It's defined in the public sha2.h header only because it's the size of
the state array in struct sha256_ctx. And a separate define for sha224
makes little sense, because there is no separate struct sha224_ctx, it's
just a #define alias for sha256_ctx.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140103205854</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-03 20:58:54-0400</timestampReceived><subject>Re: Minor nits/comments on sha256.c</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; For SHA-1 the H0 constants are a simple sequence pattern and according
&gt; to Thomas actually comes from MD5.

&gt; (From sha1.c in Nettle):
&gt;
&gt;       /* SHA initial values */
&gt;       0x67452301L,
&gt;       0xEFCDAB89L,
&gt;       0x98BADCFEL,
&gt;       0x10325476L,
&gt;       0xC3D2E1F0L,

The first four values are the same as for md5. The final value is unique
to sha1.

&gt; The H0-values for SHA-224 is actually the low 32-bits of the H0-values
&gt; for SHA-384.

Interesting, I hadn't noticed that.

&gt; We should therefore be able to update the shadata program to generate
&gt; the SHA-224 constants.

The reason sha512 and sha384 aren't generated by shadata.c, is that the
needed precision exceeds what can be expected from a C double. And for
sha224, if it had been the *high* 32 bits, double would have been enough.

Now that we include mini-gmp, I guess one could make use of that to
compute the needed roots to high enough precision.

&gt; Suggestion: Change the comments in sha256.c (for sha224) to point to the
&gt; origin of the constants. And also add a short comment in sha1.c and
&gt; md5.c that the constants are simple patterns.

I've added comments for sha1 and sha224.

&gt; According to Thomas the sequence pattern in md5 was choosen by Rivest
&gt; quite arbitrarily.

Not much to comment there...

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140107224505</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-07 22:45:05-0400</timestampReceived><subject>Re: nettle haskell bindings</subject><body>

Stefan Bühler &lt;nettle-bugs@stbuehler.de&gt; writes:

&gt; http://hackage.haskell.org/package/bindings-nettle is a low level
&gt; interface; think of it as the *.h header files in C.
&gt;
&gt; I started http://hackage.haskell.org/package/nettle as a "safe"
&gt; binding;

Should this be listed on http://www.lysator.liu.se/~nisse/nettle/? If
so, please suggest wording. I'm not familiar with Haskell. 

&gt; it should ensure that you can't screw up memory allocation and
&gt; so on, because otherwise I don't see a reason not to use C in the first
&gt; place :)

Makes a lot of sense to me.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140107224921</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-07 22:49:21-0400</timestampReceived><subject>Scheme bindings (was: Re: nettle haskell bindings)</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Should this be listed on http://www.lysator.liu.se/~nisse/nettle/?

And looking at this list, I just noticed that the link to the scheme
bindings, http://marcomaggi.github.com/nausicaa.html, is dead. Anyone
knows what happened?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140116144725</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-16 14:47:25-0400</timestampReceived><subject>Re: memxor3 could lead to invalid mem accesses</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; I expect that every byte of memory which is accessible at all is
&gt; accessible using an aligned read access of a full word. I view
&gt; byte-sized loads in the instruction set as mostly syntactic sugar for
&gt; word-sized loads and masking.

After a bit more thinking, I still believe this should be safe on the
architectures where we have assembly code. But I think it should be
avoided in the supposedly portable C code. I don't think it's very
urgent to fix, though.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140118135302</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-18 13:53:02-0400</timestampReceived><subject>Proper flags for linking .so files</subject><body>

I got a problem report for Nettle on Solaris x86_64. Apparantly, crt1.o
got included into libnettle.so, which makes no sense.

One suggestion is to add -nostartfiles to the linker command, which
could be done generally, not only for Solaris. Is that a good idea?
Do non-gcc compilers recognise -nostartfiles?

We currently pass -G on solaris, -dynamiclib on darwin/macos, and
-shared everywhere else. I'd expect those flags to imply -nostartfiles,
but I don't really know how that works.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140120144943</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-20 14:49:43-0400</timestampReceived><subject>Abstractinos for stream ciphers and authenticated encryption</subject><body>

Maybe it's time to specify some nettle-meta.h types for stream ciphers
and algorithms for authenticated encryption.

Currently we have nettle_hash, which I don't think needs any changes,
and nettle_cipher, where I'm considering the following changes:

  1. Drop the length argument from nettle_set_key_func.

  2. Make the context argument of nettle_crypt_func const.

  3. Previous point implies that we can no longer have struct
     nettle_cipher nettle_arcfour128. nettle_cipher will then be limited
     to block ciphers only.

Then there are some minor variations. Maybe nettle_crypt_func should be
left unmodified, and we should have a new type, say nettle_cipher_func,
for block ciphers with a const context.

What should the right abstraction look like for stream ciphers?
Currently, arcfour, salsa20, and (soon) chacha. Consider

  struct nettle_stream_cipher
  {
    const char *name;
    
    unsigned context_size;
    unsigned key_size;
    unsigned nonce_size;
  
    nettle_set_key_func *set_key;
    nettle_set_key_func *set_nonce;
  
    nettle_crypt_func *crypt;
  };

Here, nettle_crypt_func should be the current definition without const.
This assumes encryption and decryption are identical, which is the case
for out current stream cipher list (and anything else xoring a stream to
the plaintext). For arcfour, set_nonce would be NULL. Not sure how
useful that really is to applications, ciphers with a nonce might not be
used interchangably with a cipher that has no nonce.

So lacking features in that definition are

* Support for stream ciphers with different processing for encryption
  and decryption.

* Support for the random-access possibilities in salsa20 and chacha.

* Support for algorithms with arbitrary nonce size.

Also, internal block size is not visible. To use salsa20 with this
interface, one would need a one-block buffer, and new logic to handle
partial blocks.

For applications of stream ciphers, as well as ctr mode, is it important
to be able to process a message byte by byte? Or is it sufficient to do
like the current ctr and salsa20 code, to require that if a message is
processed using several calls to the crypt function, all but the last
must be an integral number of blocks? If we keep that requirement, we'd
have to add a block_size field to struct nettle_stream_cipher.

Next, AEAD (authenticated encryption with associated data). Currently
implemented algorithms are GCM and EAX. For internal use,
nettle-internal.h currently defines

  /* Tentative interface for "authenticated encryption with associated
     data" algorithms. Should be moved to nettle-meta.h when stable. */
  struct nettle_aead
  {
    const char *name;
    
    size_t context_size;
    /* Block size of the input, and the size of the output digest */
    size_t block_size;
  
    /* Suggested key size; other sizes are sometimes possible. */
    size_t key_size;
  
    nettle_set_key_func *set_key;
    nettle_set_key_func *set_iv;
    nettle_hash_update_func *update;
    nettle_crypt_func *encrypt;
    nettle_crypt_func *decrypt;
    nettle_hash_digest_func *digest;
  };

Like for stream ciphers, nettle_crypt_func is the variant without const;
the context *is* modified as the message is processed.

Limitations:

* Assumes identical key setup for encrypt and decrypt, which is true for
  GCM and AEX (both based on CTR mode for the encryption). Do we need
  separate set_encrypt_key and set_decrypt_key functions?

* Assumes block size and digest size are identical. They might not be.

* set_iv should be renamed to set_nonce. Can the nonce be restricted to
  fixed size here? Both gcm and eax are specified for arbitrary nonce
  size. We may need two nettle_set_* function typedefs, one without
  length argument (used for set_key in all these abstractions), and one
  with a length argument, used for arbitrary size nonces, as well as any
  interfaces supporting variable key size.

One might use the same abstraction for constructions with no associated
data (say, aes128-ctr-hmac-sha256) by setting update to NULL, or for
schemes with no authentication at all, like aes	128-ctr, by also setting
digest to NULL. Or for methods to provide authentication but no
encryption, like hmac-sha256 or poly1305. But I doubt that's very
useful.

Regards,
/Niels



-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140122090523</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2014-01-22 09:05:23-0400</timestampReceived><subject>Re: Camellia reorg</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; For (3), I think Camellia is borderline. It's been implemented in
&gt; Nettle for a couple of releases, but I expect few applications use it.
&gt; And I should also add that applications using nettle_camellia* from
&gt; nettle-meta.h (and do so in the documented way) are unaffected by this
&gt; change.

One way to confirm theories around which applications uses what is to
establish a list of significant applications that uses Nettle, which can
be recompiled with a proposed nettle release to see if they break.  For
you to do this is a lot of work, but maybe just establishing a list of
applications which deserves to be tested against newer nettle is useful
-- then you can ask for volunteers to actually do the testing, and
summarize results.  If nobody steps up for a particular application,
then that particular project has a weaker rationale to complain about
any problems later on.  If projects not on the list complains about
API/ABI breakage, the project can be added to the list.

The above is just an idea, based on my experience with API/ABI breakage
in libraries.  I started out believing that the best approch to API/ABI
rigidity was to do the right thing from a theoretical point of view --
i.e., if there is ABI breakage, bump ABI -- but I've become more
pragmatic over the years.  It seems to cause less problems for everyone
if you make sure the API/ABI is reasonable and works for the majority of
well-maintained packages, even if that sometimes means violating the
theoretical rules around API/ABI version bumping.  The theoretical rules
around API/ABI bumping causes friction and work for a lot of people
every time they are excercised, and overall sometimes that can be
contra-productive.

/Simon

</body></email><email><emailId>20140122173314</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-22 17:33:14-0400</timestampReceived><subject>Re: Status of Poly1305 and use of AES-NI in Poly1305, UMAC?</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt;&gt; * Introduce a poly1305_update function, and use preprocessor casting
&gt;&gt;   tricks to define poly1305_aes128_update (and any other
&gt;&gt;   poly1305_*_update) as an alias.
&gt;
&gt; Done, then undone;

I tried the same trick for a different function, and it turns out it
actually don't work with gcc. 
See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=59905, it will be
interesting to see if anyone else agrees it is a bug.

And the only fully kosher and portable way is to introduce a large
number of wrapper functions, like

  foo (struct foo_ctx *ctx, ...);
  foo_wrapper (void *p, ...) { return foo(p) ;}

I'd prefer to not do that.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140129142706</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-29 14:27:06-0400</timestampReceived><subject>Dropping length argument from nettle_set_key_func</subject><body>

I've done this change. I didn't dare push it to the master branch just
yet, so it's on a new branch "set_key-changes". The more interesting
pieces of the ChangeLog below.

Anyone who'd like to comment (or test) before I merge it to the master
branch?

One maybe questionable renaming was that for cast128. I'm not sure if
anyone is using cast5/cast128 with keys smaller than 128 bits. But I'd
expect it to be uncommon, and then it makes sense to me to use "cast128"
for the variant with 128 bit keys.

I now let "cast128_set_key" take a key of fixed size 128 bits (16
bytes), and then I named the variable key size function "cast5_set_key".
It just seemed a bit too awkward to name the fix-sized function
cast128_128_set_key. If we ever add a specific set_key function for,
e.g., 80-bit cast5/cast128, I think that could be named
"cast5_80_set_key".

Regards,
/Niels

2014-01-29  Niels Möller  &lt;nisse@lysator.liu.se&gt;

	* nettle-types.h (typedef nettle_set_key_func): Deleted length
	argument.

	* arctwo.c (arctwo40_set_key, arctwo64_set_key)
	(arctwo128_set_key, arctwo128_set_key_gutmann): New functions.
	* arctwo.h: Declare them.
	* arctwo-meta.c (ARCTWO): New macro.
	(nettle_arctwo40, nettle_arctwo64, nettle_arctwo128)
	(nettle_arctwo_gutmann128): Use new _set_key functions.

	* arcfour.h (ARCFOUR128_KEY_SIZE): New constant.
	* arcfour.c (arcfour128_set_key): New function.
	* arcfour-meta.c (nettle_arcfour128): Use arcfour128_set_key and
	ARCFOUR128_KEY_SIZE.

	* cast128.c (cast5_set_key): Renamed, was cast128_set_key.
	(cast128_set_key): New definition, with fixed key size.
	* cast128.h (CAST128_MIN_KEY_SIZE, CAST128_MAX_KEY_SIZE): Renamed
	constants, to...
	(CAST5_MIN_KEY_SIZE, CAST5_MAX_KEY_SIZE): ... new names.

	* eax.h (EAX_SET_KEY): Deleted length argument.

	* aes128-meta.c: Deleted _set_key wrappers.
	* aes192-meta.c: Likewise.
	* aes256-meta.c: Likewise.
	* camellia128-meta.c: Likewise.
	* camellia192-meta.c: Likewise.
	* camellia256-meta.c: Likewise.

	* gcm-aes128.c (gcm_aes128_set_key): Deleted length argument.
	* gcm-aes192.c (gcm_aes192_set_key): Likewise.
	* gcm-aes256.c (gcm_aes256_set_key): Likewise.
	* gcm.h: Updated prototypes.

	* serpent-set-key.c (serpent128_set_key, serpent192_set_key)
	(serpent256_set_key): New functions.
	* serpent.h: Declare new functions.
	(SERPENT128_KEY_SIZE, SERPENT192_KEY_SIZE)
	(SERPENT256_KEY_SIZE): New constants.
	* serpent-meta.c (SERPENT): New macro.
	(nettle_serpent128, nettle_serpent192, nettle_serpent256): Use new
	_set_key functions.

	* twofish-set-key.c (twofish128_set_key, twofish192_set_key)
	(twofish256_set_key): New functions.
	* twofish.h: Declare new functions.
	(TWOFISH128_KEY_SIZE, TWOFISH192_KEY_SIZE)
	(TWOFISH256_KEY_SIZE): New constants.
	* twofish-meta.c (TWOFISH): New macro.
	(nettle_twofish128, nettle_twofish192, nettle_twofish256): Use new
	_set_key functions.

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140130090611</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-30 09:06:11-0400</timestampReceived><subject>Re: chacha assembly</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; By vectorizing you mean running quarterrounds in parallel?

I mean putting several uint32_t values in a simd register, and using
simd instructions.
 
&gt; Have you looked at the asm code by DJB?

Not really, I find the generated assembly pretty hard to read, and I
haven't tried to understand his qhasm tool.

&gt; He does up to four blocks in
&gt; parallel and do some tricks with the shifts. xmm-5 should be relevant.

To me, it looks like all rotates are done with psrld + pslld. But I
might be missing something. On the few machines I have benchmarked the
code (I haven't been very systematic), pshufhw + pshuflw seems to be
slightly faster. It saves one por instruction.

I'm pretty sure doing a couple of blocks at a time in parellel,
interleaving the instructions, will give some speedup.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140130091306</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-01-30 09:13:06-0400</timestampReceived><subject>Re: [PATCH] Integration of chacha in Makefile.in</subject><body>

Joachim Strömbergson &lt;joachim@secworks.se&gt; writes:

&gt; Did you base the test
&gt; program on the Salsa20 test program or my stuff?

I started with the testprogram in your git repo, but I don't think
there's much left of that code now. I then added tests from your
internet draft.

&gt; I can see if I can do (1).

That's already done... Try examples/nettle-benchmark chacha.

Testing could be improved, quoting the comments in chacha-test.c:

  /* FIXME: For rounds == 20, use crypt function, support more than
     one block, and test various short lengths. */

For testing various lengths, one should also have a small redzone around
the destination area, to check for overwrites.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140130110831</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2014-01-30 11:08:31-0400</timestampReceived><subject>Re: arctwo</subject><body>

You wrote:

&gt; Aloha!
&gt; 
&gt; Nikos Mavrogiannopoulos wrote:
&gt; &gt; However, RC2-40 is used in gnutls to decrypt PKCS #12 files, so it 
&gt; &gt; would be good for RC2-40 to remain so that decryption of any
&gt; &gt; existing files will remain possible.
&gt; 
&gt; Yes, forgot to write about P12 where RC2 can be used. Don't know how
&gt; common it is though.

Last time I looked closely (~3-4 years ago) RC2-40 was quite common
when non-FOSS code were involved (e.g., Windows).  I'm hoping
implementations have been changed since then, but files generated back
then must still be quite common, and thus useful to decrypt.

/Simon

</body></email><email><emailId>20140130212911</emailId><senderName>Simon Josefsson</senderName><senderEmail>simon@josefsson.org</senderEmail><timestampReceived>2014-01-30 21:29:11-0400</timestampReceived><subject>Re: Deterministic DSA and ECDSA signatures</subject><body>

You wrote:

&gt; I just became aware of RFC 6979 "Deterministic Usage of the Digital
&gt; Signature Algorithm (DSA) and Elliptic Curve Digital Signature
&gt; Algorithm (ECDSA)" (Informational).
&gt; 
&gt; I think determinstic signatures are a good thing, and using the secret
&gt; key also as a HMAC key to generate the random input is a natural idea.

I agree.

&gt; But then one could arrange the details in many different ways. Is the
&gt; method in RFC 6979 a good way?

I suspect it is "good" in the way that it is used in a couple of
places, and nobody has proven it to be a bad way yet.  Those are weak
arguments.

It seems RFC 6979 uses HMAC_DRBG?  You could use HKDF (RFC 5869) instead
to derive the key, I think, but it is also based on HMAC.
 
&gt; After a quick reading, the steps c. and d. (Sec. 3.2) seems
&gt; questionable; HMAC with a known constant key just seems more
&gt; complicated than a simple hashing operation, and no more secure.

I know it is generally the wrong question to ask, but anyway:
Could it be less secure? HMAC has some properties that goes
beyond the underlying hash functions.  For example, HMAC-MD5 is still
considered secure (I believe) even though MD5 is broken.

However, I also suspect a time will come to find weaknesses in HMAC:
it is so ubiquitiously used (nice target for a crypto paper), there are
modern alternatives with a more scientific design (= suggests
weaknesses in earlier design), and generally the HMAC design is rather
1980ish with hard coded magic numbers, so there is bound to be
weaknesses -- side channel leakage or weak keys or whatever?  I've been
surprised that there has been so little results/studies on HMAC in
recent years. That could also mean HMAC is perfect, of course. :-)

/Simon

</body></email><email><emailId>20140131065040</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-01-31 06:50:40-0400</timestampReceived><subject>Re: Curve25519 [was: Re: brainpool curves]</subject><body>


On 10/16/2013 11:03 PM, Daniel Kahn Gillmor wrote:
&gt; On 09/30/2013 08:46 AM, Nikos Mavrogiannopoulos wrote:
&gt; 
&gt;&gt; There has been lately an attempt to avoid the NIST's curves due to
&gt;&gt; suspicions about their generation. One of them are the brainpool curves
&gt;&gt; at: http://tools.ietf.org/html/rfc5639
&gt;&gt; which seem to be sponsored by the German BSI. Having them in nettle
&gt;&gt; would be a good thing (the same authors are working on standardizing
&gt;&gt; these curves in TLS and PKIX).
&gt; Similarly, an implementation of Curve25519 [0] would probably also be
&gt; useful to have in the library, as it is also under active discussion in
&gt; several contexts.

[reviving old thread]

It seems it is being pushed forward and openssh even uses it by default
now.  There are implementations like [0] that nettle could take
advantage to use that curve, but what I'm worried about is that the
current interfaces to use this curve provide no agility. If any issue is
found replacing it isn't straightforward.

regards,
Nikos

[0]. https://github.com/agl/curve25519-donna



["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20140131095324</emailId><senderName>Joachim_Strömbergson</senderName><senderEmail>joachim@secworks.se</senderEmail><timestampReceived>2014-01-31 09:53:24-0400</timestampReceived><subject>Re: Curve25519</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Aloha!

Nikos Mavrogiannopoulos wrote:
&gt;&gt; And about the "safe" curves listed at http://safecurves.cr.yp.to/, 
&gt;&gt; anything beyond curve25519 which is being deployed? M-383,
&gt;&gt; Curve41417, M-511 or E-521?
&gt; 
&gt; There is some discussion in CFRG which will probably end-up in a
&gt; draft but I don't really follow up.

I would say that "some" is a bit of an understatement. There are tons of
discussions going on at the moment ranging from things like naming
schemes of curves but also a lot of discussions related to
implementations, patents, what curves are to be considered safe and why etc.

Right now it is hard to say what the results will be, but that there
will be new curves used in IETF RFCs and protocols specified by IETF is
probably not a wild guess.

Getting Curve25519 into nettle is a good start though.

BTW: There is a very interesting paper out from MSR that describes a
survey of EC being used in practice.

http://eprint.iacr.org/2013/734

"In this paper, we perform a review of elliptic curve cryptography
(ECC), as it is used in practice today, in order to reveal unique
mistakes and vulnerabilities that arise in implementations of ECC. We
study four popular protocols that make use of this type of public-key
cryptography: Bitcoin, secure shell (SSH), transport layer security
(TLS), and the Austrian e-ID card. We are pleased to observe that about
1 in 10 systems support ECC across the TLS and SSH protocols. However,
we find that despite the high stakes of money, access and resources
protected by ECC, implementations suffer from vulnerabilities similar to
those that plague previous cryptographic systems."

- -- 
Med vänlig hälsning, Yours

Joachim Strömbergson - Alltid i harmonisk svängning.
========================================================================
 Joachim Strömbergson          Secworks AB          joachim@secworks.se
========================================================================
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.22 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAlLrcpQACgkQZoPr8HT30QGtNACdGS3g0b24miFqSoBRVJsxly8t
LnEAoJXsKBGfkW/+xwAAxKdvUHFFaG0p
=2Wx/
-----END PGP SIGNATURE-----

</body></email><email><emailId>20140917195939</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-09-17 19:59:39-0400</timestampReceived><subject>Re: eddsa progress</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Also, I think I'll replace
&gt;
&gt;   struct ecc_curve nettle_curve25519;
&gt;
&gt; by
&gt;
&gt;   struct ecc_curve nettle_ed25519; /* or whatever name is appropriate */
&gt;
&gt; since this curve is what's really implemented, and it's better
&gt; defined.

Done now, except for the renaming. This means, that for input and
output, coordinates represent points on the -1 twisted Edwards curve.
It's only the curve25519_mul* functions which use the Montgomery curve
for inputs and outputs.

For the renaming, I'm no longer sure that's a good idea.
http://www.ietf.org/mail-archive/web/cfrg/current/msg04996.html seems to
recommend "curve25519" as the name of the curve, regardless of which
coordinates are used.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141109084628</emailId><senderName>braga</senderName><senderEmail>vittorio.braga@roma2.infn.it</senderEmail><timestampReceived>2014-11-09 08:46:28-0400</timestampReceived><subject>FAILs in make check</subject><body>

Dear nettle community

I am triyng to install nettle2.7.1 (because I want to install gnutls-cli 
but it doesn't support nettle3.0) on my

Ubuntu 12.04
i686 architecture

but I always get this result on

make check

zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$ make check
make check-here
make[1]: ingresso nella directory 
"/home/zaamus/Dependencies/nettle-2.7.1"
true
make[1]: uscita dalla directory "/home/zaamus/Dependencies/nettle-2.7.1"
set -e; for d in tools testsuite examples; do \
	  echo "Making check in $d" ; (cd $d &amp;&amp; make check); done
Making check in tools
make[1]: ingresso nella directory 
"/home/zaamus/Dependencies/nettle-2.7.1/tools"
true
make[1]: uscita dalla directory 
"/home/zaamus/Dependencies/nettle-2.7.1/tools"
Making check in testsuite
make[1]: ingresso nella directory 
"/home/zaamus/Dependencies/nettle-2.7.1/testsuite"
LD_LIBRARY_PATH=../.lib PATH="../.lib:$PATH" srcdir="." \
	  EMULATOR="" NM="nm" EXEEXT="" \
           ../run-tests aes-test arcfour-test arctwo-test blowfish-test 
cast128-test base16-test base64-test camellia-test des-test des3-test 
des-compat-test md2-test md4-test md5-test md5-compat-test memxor-test 
gosthash94-test ripemd160-test salsa20-test sha1-test sha224-test 
sha256-test sha384-test sha512-test sha3-permute-test sha3-224-test 
sha3-256-test sha3-384-test sha3-512-test serpent-test twofish-test 
knuth-lfib-test cbc-test ctr-test gcm-test hmac-test umac-test 
meta-hash-test meta-cipher-test meta-armor-test buffer-test yarrow-test 
pbkdf2-test  sexp-test sexp-format-test rsa2sexp-test sexp2rsa-test 
bignum-test random-prime-test pkcs1-test rsa-test rsa-encrypt-test 
rsa-keygen-test dsa-test dsa-keygen-test ecc-mod-test ecc-modinv-test 
ecc-redc-test ecc-mul-g-test ecc-mul-a-test ecdsa-sign-test 
ecdsa-verify-test ecdsa-keygen-test cxx-test sexp-conv-test 
pkcs1-conv-test symbols-test
PASS: aes
PASS: arcfour
PASS: arctwo
PASS: blowfish
PASS: cast128
PASS: base16
PASS: base64
PASS: camellia
PASS: des
PASS: des3
PASS: des-compat
PASS: md2
PASS: md4
PASS: md5
PASS: md5-compat
PASS: memxor
PASS: gosthash94
PASS: ripemd160
PASS: salsa20
PASS: sha1
PASS: sha224
PASS: sha256
PASS: sha384
PASS: sha512
PASS: sha3-permute
PASS: sha3-224
PASS: sha3-256
PASS: sha3-384
PASS: sha3-512
PASS: serpent
PASS: twofish
PASS: knuth-lfib
PASS: cbc
PASS: ctr
PASS: gcm
PASS: hmac
PASS: umac
PASS: meta-hash
PASS: meta-cipher
PASS: meta-armor
PASS: buffer
PASS: yarrow
PASS: pbkdf2
PASS: sexp
PASS: sexp-format
PASS: rsa2sexp
PASS: sexp2rsa
PASS: bignum
PASS: random-prime
PASS: pkcs1
PASS: rsa
PASS: rsa-encrypt
PASS: rsa-keygen
PASS: dsa
PASS: dsa-keygen
./ecc-mod-test: symbol lookup error: ../.lib/libhogweed.so.2: undefined 
symbol: __gmpz_limbs_read
FAIL: ecc-mod
./ecc-modinv-test: symbol lookup error: ../.lib/libhogweed.so.2: 
undefined symbol: __gmpz_limbs_read
FAIL: ecc-modinv
./ecc-redc-test: symbol lookup error: ../.lib/libhogweed.so.2: undefined 
symbol: __gmpz_limbs_read
FAIL: ecc-redc
./ecc-mul-g-test: symbol lookup error: ../.lib/libhogweed.so.2: 
undefined symbol: __gmpn_cnd_add_n
FAIL: ecc-mul-g
./ecc-mul-a-test: symbol lookup error: ../.lib/libhogweed.so.2: 
undefined symbol: __gmpn_cnd_add_n
FAIL: ecc-mul-a
./ecdsa-sign-test: symbol lookup error: ../.lib/libhogweed.so.2: 
undefined symbol: __gmpz_limbs_modify
FAIL: ecdsa-sign
./ecdsa-verify-test: symbol lookup error: ../.lib/libhogweed.so.2: 
undefined symbol: __gmpz_limbs_read
FAIL: ecdsa-verify
./ecdsa-keygen-test: symbol lookup error: ../.lib/libhogweed.so.2: 
undefined symbol: __gmpn_cnd_add_n
FAIL: ecdsa-keygen
PASS: cxx
PASS: sexp-conv
PASS: pkcs1-conv
PASS: symbols
====================
8 of 67 tests failed
====================
make[1]: *** [check] Errore 1
make[1]: uscita dalla directory 
"/home/zaamus/Dependencies/nettle-2.7.1/testsuite"
make: *** [check] Errore 2

I have libgcrypt1.6.2, libgpg-error1.17, m4 macro processor and gmp6.0.0 
installed. Library lgmp is correctly found when I compile some random c 
source. Can you help me? Do you need other information?

Thanks, Vittorio

-- 
Vittorio Francesco Braga
PhD student in Tor Vergata University of Rome
Mobile: +393203753307, Office (PhD room): +390672594868

</body></email><email><emailId>20141212160209</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2014-12-12 16:02:09-0400</timestampReceived><subject>Potential bug in nettle-benchmark.c</subject><body>

This was flagged by GCC:

  nettle-benchmark.c: In function 'time_cipher':
  nettle-benchmark.c:504:29: warning: argument to 'sizeof' in 'memset' call is the \
same expression as the destination; did you mean to provide an explicit length? \
[-Wsizeof-pointer-memaccess]  memset(iv, 0, sizeof(iv));
			       ^
  nettle-benchmark.c:520:29: warning: argument to 'sizeof' in 'memset' call is the \
same expression as the destination; did you mean to provide an explicit length? \
[-Wsizeof-pointer-memaccess]  memset(iv, 0, sizeof(iv));
			       ^
  nettle-benchmark.c:537:29: warning: argument to 'sizeof' in 'memset' call is the \
same expression as the destination; did you mean to provide an explicit length? \
[-Wsizeof-pointer-memaccess]  memset(iv, 0, sizeof(iv));
			       ^

Here's a suggested patch:

--- examples/nettle-benchmark.c~0	2013-05-28 17:21:54.000000000 +0300
+++ examples/nettle-benchmark.c	2014-12-12 17:58:10.670625000 +0200
@@ -501,7 +501,7 @@ time_cipher(const struct nettle_cipher *
 	info.block_size = cipher-&gt;block_size;
 	info.iv = iv;
     
-        memset(iv, 0, sizeof(iv));
+        memset(iv, 0, sizeof(*iv));
     
         cipher-&gt;set_encrypt_key(ctx, cipher-&gt;key_size, key);
 
@@ -517,7 +517,7 @@ time_cipher(const struct nettle_cipher *
 	info.block_size = cipher-&gt;block_size;
 	info.iv = iv;
     
-        memset(iv, 0, sizeof(iv));
+        memset(iv, 0, sizeof(*iv));
 
         cipher-&gt;set_decrypt_key(ctx, cipher-&gt;key_size, key);
 
@@ -534,7 +534,7 @@ time_cipher(const struct nettle_cipher *
 	info.block_size = cipher-&gt;block_size;
 	info.iv = iv;
     
-        memset(iv, 0, sizeof(iv));
+        memset(iv, 0, sizeof(*iv));
     
         cipher-&gt;set_encrypt_key(ctx, cipher-&gt;key_size, key);
 


</body></email><email><emailId>20141212174306</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-12-12 17:43:06-0400</timestampReceived><subject>Re: Potential bug in nettle-benchmark.c</subject><body>

Eli Zaretskii &lt;eliz@gnu.org&gt; writes:

&gt; This was flagged by GCC:
&gt; 
&gt; nettle-benchmark.c: In function 'time_cipher':
&gt; nettle-benchmark.c:504:29: warning: argument to 'sizeof' in 'memset' call is the \
&gt; same expression as the destination; did you mean to provide an explicit length? \
&gt; [-Wsizeof-pointer-memaccess]  memset(iv, 0, sizeof(iv));

Right, that memset call is broken. This should be fixed in the
development version (there was a failed attempt to fix it back in
february, which made it into the 3.0 release, and it was fixed properly
a few months ago). Neither sizeof(iv) nor sizeof(*iv) is right, it
should be cipher-&gt;block_size, the same size as was allocated a few lines
up.

You are using nettle-2.7.1, I guess?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20141109112226</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-11-09 11:22:26-0400</timestampReceived><subject>Re: FAILs in make check</subject><body>

braga &lt;Vittorio.Braga@roma2.infn.it&gt; writes:

&gt; I am triyng to install nettle2.7.1 (because I want to install
&gt; gnutls-cli but it doesn't support nettle3.0) on my
&gt;
&gt; Ubuntu 12.04
&gt; i686 architecture

&gt; PASS: dsa-keygen
&gt; ./ecc-mod-test: symbol lookup error: ../.lib/libhogweed.so.2:
&gt; undefined symbol: __gmpz_limbs_read

[...]

&gt; I have libgcrypt1.6.2, libgpg-error1.17, m4 macro processor and
&gt; gmp6.0.0 installed.

Note that libgcrypt and libgpg-error are not used by nettle.

&gt; Library lgmp is correctly found when I compile
&gt; some random c source. Can you help me? Do you need other information?

It looks like you found gmp-6.0 header files, but link with an older
version of gmp at runtime.

Can you try ldd on some of the failing test programs? E.g.,

  LD_LIBRARY_PATH=.lib ldd testsuite/dsa-keygen-test

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141109135340</emailId><senderName>braga</senderName><senderEmail>vittorio.braga@roma2.infn.it</senderEmail><timestampReceived>2014-11-09 13:53:40-0400</timestampReceived><subject>Re: FAILs in make check</subject><body>

Dear Niels, thanks for your immediate answer. Here is what I found on 3 
of the failing tests (dsa-keygen-test does not failing, anyway the 
result is the same)..


zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$ LD_LIBRARY_PATH=.lib ldd 
testsuite/ecc-mul-g-test
	linux-gate.so.1 =&gt;  (0x40022000)
	libhogweed.so.2 =&gt; .lib/libhogweed.so.2 (0x40026000)
	libnettle.so.4 =&gt; .lib/libnettle.so.4 (0x40054000)
	libgmp.so.10 =&gt; /usr/lib/i386-linux-gnu/libgmp.so.10 (0x400a5000)
	libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0x40124000)
	/lib/ld-linux.so.2 (0x40000000)
zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$ LD_LIBRARY_PATH=.lib ldd 
testsuite/ecdsa-sign-test
	linux-gate.so.1 =&gt;  (0x40022000)
	libhogweed.so.2 =&gt; .lib/libhogweed.so.2 (0x40026000)
	libnettle.so.4 =&gt; .lib/libnettle.so.4 (0x40054000)
	libgmp.so.10 =&gt; /usr/lib/i386-linux-gnu/libgmp.so.10 (0x400a5000)
	libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0x40124000)
	/lib/ld-linux.so.2 (0x40000000)
zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$ LD_LIBRARY_PATH=.lib ldd 
testsuite/ecc-mul-a-test
	linux-gate.so.1 =&gt;  (0x40022000)
	libhogweed.so.2 =&gt; .lib/libhogweed.so.2 (0x40026000)
	libnettle.so.4 =&gt; .lib/libnettle.so.4 (0x40054000)
	libgmp.so.10 =&gt; /usr/lib/i386-linux-gnu/libgmp.so.10 (0x400a5000)
	libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0x40124000)
	/lib/ld-linux.so.2 (0x40000000)

Il 2014-11-09 12:22 nisse@lysator.liu.se ha scritto:
&gt; braga &lt;Vittorio.Braga@roma2.infn.it&gt; writes:
&gt; 
&gt;&gt; I am triyng to install nettle2.7.1 (because I want to install
&gt;&gt; gnutls-cli but it doesn't support nettle3.0) on my
&gt;&gt; 
&gt;&gt; Ubuntu 12.04
&gt;&gt; i686 architecture
&gt; 
&gt;&gt; PASS: dsa-keygen
&gt;&gt; ./ecc-mod-test: symbol lookup error: ../.lib/libhogweed.so.2:
&gt;&gt; undefined symbol: __gmpz_limbs_read
&gt; 
&gt; [...]
&gt; 
&gt;&gt; I have libgcrypt1.6.2, libgpg-error1.17, m4 macro processor and
&gt;&gt; gmp6.0.0 installed.
&gt; 
&gt; Note that libgcrypt and libgpg-error are not used by nettle.
&gt; 
&gt;&gt; Library lgmp is correctly found when I compile
&gt;&gt; some random c source. Can you help me? Do you need other information?
&gt; 
&gt; It looks like you found gmp-6.0 header files, but link with an older
&gt; version of gmp at runtime.
&gt; 
&gt; Can you try ldd on some of the failing test programs? E.g.,
&gt; 
&gt;   LD_LIBRARY_PATH=.lib ldd testsuite/dsa-keygen-test
&gt; 
&gt; Regards,
&gt; /Niels

-- 
Vittorio Francesco Braga
PhD student in Tor Vergata University of Rome
Mobile: +393203753307, Office (PhD room): +390672594868

</body></email><email><emailId>20141109191217</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-11-09 19:12:17-0400</timestampReceived><subject>Re: FAILs in make check</subject><body>

braga &lt;Vittorio.Braga@roma2.infn.it&gt; writes:

&gt; Dear Niels, thanks for your immediate answer. Here is what I found on
&gt; 3 of the failing tests

Good.

&gt; zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$ LD_LIBRARY_PATH=.lib ldd
&gt; testsuite/ecc-mul-g-test
&gt; 	linux-gate.so.1 =&gt;  (0x40022000)
&gt; 	libhogweed.so.2 =&gt; .lib/libhogweed.so.2 (0x40026000)
&gt; 	libnettle.so.4 =&gt; .lib/libnettle.so.4 (0x40054000)
&gt; 	libgmp.so.10 =&gt; /usr/lib/i386-linux-gnu/libgmp.so.10 (0x400a5000)
&gt; 	libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0x40124000)
&gt; 	/lib/ld-linux.so.2 (0x40000000)

Is the file /usr/lib/i386-linux-gnu/libgmp.so.10 really gmp-6.0? I
suspect it's an older version. On my system (which is x86_64, not i386
like yours), /usr/lib/x86_64-linux-gnu/libgmp.so.10 is a symlink to
/usr/lib/x86_64-linux-gnu/libgmp.so.10.2.0, and if I examine the symbol
table, I get

  $ objdump -tT /usr/lib/x86_64-linux-gnu/libgmp.so.10 |grep limbs
  0000000000020210 g    DF .text  0000000000000015  Base        __gmpz_limbs_write
  00000000000201a0 g    DF .text  000000000000003c  Base        __gmpz_limbs_finish
  000000000001bd40 g    DF .text  0000000000000253  Base        __gmpz_prodlimbs
  0000000000020200 g    DF .text  0000000000000005  Base        __gmpz_limbs_read
  00000000000201e0 g    DF .text  0000000000000015  Base        __gmpz_limbs_modify

Do you have those symbols?

I think you can double check with

  dpkg -S /usr/lib/i386-linux-gnu/libgmp.so.10

(should give package name libgmp10), and check the version with

  dpkg -l libgmp10

In my (debian) system the package versino is "2:6.0.0+dfsg-6".

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141109201321</emailId><senderName>braga</senderName><senderEmail>vittorio.braga@roma2.infn.it</senderEmail><timestampReceived>2014-11-09 20:13:21-0400</timestampReceived><subject>Re: FAILs in make check</subject><body>

I am sure I have installed gmp6.0.0: I have done it right before trying 
to install nettle.

However, this is what I get with your tests

zaamus@zaamuspc:/usr/local/itt/idl70/lib$   dpkg -S 
/usr/lib/i386-linux-gnu/libgmp.so.10
libgmp10: /usr/lib/i386-linux-gnu/libgmp.so.10
zaamus@zaamuspc:/usr/local/itt/idl70/lib$   dpkg -l libgmp10
Desired=Unknown/Install/Remove/Purge/Hold
&gt; 
Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
&gt; / Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
&gt; &gt; / Nome                  Versione              Descrizione
+++-=====================-=====================-==========================================================
 ii  libgmp10              2:5.0.2+dfsg-2ubuntu1 Multiprecision 
arithmetic library


Il 2014-11-09 20:12 nisse@lysator.liu.se ha scritto:
&gt; braga &lt;Vittorio.Braga@roma2.infn.it&gt; writes:
&gt; 
&gt; &gt; Dear Niels, thanks for your immediate answer. Here is what I found on
&gt; &gt; 3 of the failing tests
&gt; 
&gt; Good.
&gt; 
&gt; &gt; zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$ LD_LIBRARY_PATH=.lib ldd
&gt; &gt; testsuite/ecc-mul-g-test
&gt; &gt; 	linux-gate.so.1 =&gt;  (0x40022000)
&gt; &gt; 	libhogweed.so.2 =&gt; .lib/libhogweed.so.2 (0x40026000)
&gt; &gt; 	libnettle.so.4 =&gt; .lib/libnettle.so.4 (0x40054000)
&gt; &gt; 	libgmp.so.10 =&gt; /usr/lib/i386-linux-gnu/libgmp.so.10 (0x400a5000)
&gt; &gt; 	libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0x40124000)
&gt; &gt; 	/lib/ld-linux.so.2 (0x40000000)
&gt; 
&gt; Is the file /usr/lib/i386-linux-gnu/libgmp.so.10 really gmp-6.0? I
&gt; suspect it's an older version. On my system (which is x86_64, not i386
&gt; like yours), /usr/lib/x86_64-linux-gnu/libgmp.so.10 is a symlink to
&gt; /usr/lib/x86_64-linux-gnu/libgmp.so.10.2.0, and if I examine the symbol
&gt; table, I get
&gt; 
&gt; $ objdump -tT /usr/lib/x86_64-linux-gnu/libgmp.so.10 |grep limbs
&gt; 0000000000020210 g    DF .text  0000000000000015  Base
&gt; __gmpz_limbs_write
&gt; 00000000000201a0 g    DF .text  000000000000003c  Base
&gt; __gmpz_limbs_finish
&gt; 000000000001bd40 g    DF .text  0000000000000253  Base        
&gt; __gmpz_prodlimbs
&gt; 0000000000020200 g    DF .text  0000000000000005  Base
&gt; __gmpz_limbs_read
&gt; 00000000000201e0 g    DF .text  0000000000000015  Base
&gt; __gmpz_limbs_modify
&gt; 
&gt; Do you have those symbols?
&gt; 
&gt; I think you can double check with
&gt; 
&gt; dpkg -S /usr/lib/i386-linux-gnu/libgmp.so.10
&gt; 
&gt; (should give package name libgmp10), and check the version with
&gt; 
&gt; dpkg -l libgmp10
&gt; 
&gt; In my (debian) system the package versino is "2:6.0.0+dfsg-6".
&gt; 
&gt; Regards,
&gt; /Niels

-- 
Vittorio Francesco Braga
PhD student in Tor Vergata University of Rome
Mobile: +393203753307, Office (PhD room): +390672594868


</body></email><email><emailId>20141109212113</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-11-09 21:21:13-0400</timestampReceived><subject>Re: FAILs in make check</subject><body>

braga &lt;Vittorio.Braga@roma2.infn.it&gt; writes:

&gt; I am sure I have installed gmp6.0.0: I have done it right before
&gt; trying to install nettle.

Using apt-get, or compiling from source (and then typically installing
under /usr/local)?

&gt; However, this is what I get with your tests
&gt; 
&gt; zaamus@zaamuspc:/usr/local/itt/idl70/lib$   dpkg -S 
&gt; /usr/lib/i386-linux-gnu/libgmp.so.10
&gt; libgmp10: /usr/lib/i386-linux-gnu/libgmp.so.10
&gt; zaamus@zaamuspc:/usr/local/itt/idl70/lib$   dpkg -l libgmp10
&gt; Desired=Unknown/Install/Remove/Purge/Hold
&gt; &gt; 
&gt; Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
&gt; &gt; / Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
&gt; &gt; &gt; / Nome                  Versione              Descrizione
&gt; +++-=====================-=====================-==========================================================
&gt;  ii  libgmp10              2:5.0.2+dfsg-2ubuntu1 Multiprecision
&gt; arithmetic library

This shows that the version installed under /usr/lib is *not* version
6.0. So if you have installed gmp-6, it's located somewhere else on the
system. I'm going to assume it's under /usr/local.

You need to tweak the invocation of nettle's configure script to pick it
up (or, alternatively, edit /etc/ld.so.conf to include /usr/local/lib by
default, and run ldconfig, but that might have undesirable side
effects).

What probably happened, is that you got header files for gmp-6 in
/usr/local/include, and gcc searches that directory by default. And you
got the corresponding library installed under /usr/local/lib, which
might be searched by default during link time, but *not* during runtime. 

Try rerunning nettle's ./configure as

  ./configure LDFLAGS="-L/usr/local/lib -Wl,rpath,/usr/local/lib"

Or as a quick test to see if this really is the problem, try setting
LD_LIBRARY_PATH, and run

  LD_LIBRARY_PATH=.lib:/usr/local/lib ldd testsuite/ecc-mul-g-test
  LD_LIBRARY_PATH=.lib:/usr/local/lib ./testsuite/ecc-mul-g-test

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20141109213443</emailId><senderName>braga</senderName><senderEmail>vittorio.braga@roma2.infn.it</senderEmail><timestampReceived>2014-11-09 21:34:43-0400</timestampReceived><subject>Re: FAILs in make check</subject><body>

When I do make check on gmp all tests are PASSed and make install does 
not give me any error.. do you suggest me to reinstall something? I have 
tried now to install again GMP but the result is the same. Should I 
remove something before trying reinstalling?

Il 2014-11-09 21:13 braga ha scritto:
&gt; I am sure I have installed gmp6.0.0: I have done it right before
&gt; trying to install nettle.
&gt; 
&gt; However, this is what I get with your tests
&gt; 
&gt; zaamus@zaamuspc:/usr/local/itt/idl70/lib$   dpkg -S
&gt; /usr/lib/i386-linux-gnu/libgmp.so.10
&gt; libgmp10: /usr/lib/i386-linux-gnu/libgmp.so.10
&gt; zaamus@zaamuspc:/usr/local/itt/idl70/lib$   dpkg -l libgmp10
&gt; Desired=Unknown/Install/Remove/Purge/Hold
&gt; &gt; 
&gt; Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
&gt; &gt; / Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
&gt; &gt; &gt; / Nome                  Versione              Descrizione
&gt; +++-=====================-=====================-==========================================================
&gt;  ii  libgmp10              2:5.0.2+dfsg-2ubuntu1 Multiprecision
&gt; arithmetic library
&gt; 
&gt; 
&gt; Il 2014-11-09 20:12 nisse@lysator.liu.se ha scritto:
&gt; &gt; braga &lt;Vittorio.Braga@roma2.infn.it&gt; writes:
&gt; &gt; 
&gt; &gt; &gt; Dear Niels, thanks for your immediate answer. Here is what I found on
&gt; &gt; &gt; 3 of the failing tests
&gt; &gt; 
&gt; &gt; Good.
&gt; &gt; 
&gt; &gt; &gt; zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$ LD_LIBRARY_PATH=.lib ldd
&gt; &gt; &gt; testsuite/ecc-mul-g-test
&gt; &gt; &gt; 	linux-gate.so.1 =&gt;  (0x40022000)
&gt; &gt; &gt; 	libhogweed.so.2 =&gt; .lib/libhogweed.so.2 (0x40026000)
&gt; &gt; &gt; 	libnettle.so.4 =&gt; .lib/libnettle.so.4 (0x40054000)
&gt; &gt; &gt; 	libgmp.so.10 =&gt; /usr/lib/i386-linux-gnu/libgmp.so.10 (0x400a5000)
&gt; &gt; &gt; 	libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0x40124000)
&gt; &gt; &gt; 	/lib/ld-linux.so.2 (0x40000000)
&gt; &gt; 
&gt; &gt; Is the file /usr/lib/i386-linux-gnu/libgmp.so.10 really gmp-6.0? I
&gt; &gt; suspect it's an older version. On my system (which is x86_64, not i386
&gt; &gt; like yours), /usr/lib/x86_64-linux-gnu/libgmp.so.10 is a symlink to
&gt; &gt; /usr/lib/x86_64-linux-gnu/libgmp.so.10.2.0, and if I examine the 
&gt; &gt; symbol
&gt; &gt; table, I get
&gt; &gt; 
&gt; &gt; $ objdump -tT /usr/lib/x86_64-linux-gnu/libgmp.so.10 |grep limbs
&gt; &gt; 0000000000020210 g    DF .text  0000000000000015  Base
&gt; &gt; __gmpz_limbs_write
&gt; &gt; 00000000000201a0 g    DF .text  000000000000003c  Base
&gt; &gt; __gmpz_limbs_finish
&gt; &gt; 000000000001bd40 g    DF .text  0000000000000253  Base        
&gt; &gt; __gmpz_prodlimbs
&gt; &gt; 0000000000020200 g    DF .text  0000000000000005  Base
&gt; &gt; __gmpz_limbs_read
&gt; &gt; 00000000000201e0 g    DF .text  0000000000000015  Base
&gt; &gt; __gmpz_limbs_modify
&gt; &gt; 
&gt; &gt; Do you have those symbols?
&gt; &gt; 
&gt; &gt; I think you can double check with
&gt; &gt; 
&gt; &gt; dpkg -S /usr/lib/i386-linux-gnu/libgmp.so.10
&gt; &gt; 
&gt; &gt; (should give package name libgmp10), and check the version with
&gt; &gt; 
&gt; &gt; dpkg -l libgmp10
&gt; &gt; 
&gt; &gt; In my (debian) system the package versino is "2:6.0.0+dfsg-6".
&gt; &gt; 
&gt; &gt; Regards,
&gt; &gt; /Niels

-- 
Vittorio Francesco Braga
PhD student in Tor Vergata University of Rome
Mobile: +393203753307, Office (PhD room): +390672594868


</body></email><email><emailId>20141109215509</emailId><senderName>braga</senderName><senderEmail>vittorio.braga@roma2.infn.it</senderEmail><timestampReceived>2014-11-09 21:55:09-0400</timestampReceived><subject>Re: FAILs in make check</subject><body>

First of all, thanks for your patience

Il 2014-11-09 22:21 nisse@lysator.liu.se ha scritto:
&gt; braga &lt;Vittorio.Braga@roma2.infn.it&gt; writes:
&gt; 
&gt; &gt; I am sure I have installed gmp6.0.0: I have done it right before
&gt; &gt; trying to install nettle.
&gt; 
&gt; Using apt-get, or compiling from source (and then typically installing
&gt; under /usr/local)?
&gt; 
&gt; &gt; However, this is what I get with your tests
&gt; &gt; 
&gt; &gt; zaamus@zaamuspc:/usr/local/itt/idl70/lib$   dpkg -S
&gt; &gt; /usr/lib/i386-linux-gnu/libgmp.so.10
&gt; &gt; libgmp10: /usr/lib/i386-linux-gnu/libgmp.so.10
&gt; &gt; zaamus@zaamuspc:/usr/local/itt/idl70/lib$   dpkg -l libgmp10
&gt; &gt; Desired=Unknown/Install/Remove/Purge/Hold
&gt; &gt; &gt; 
&gt; &gt; Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
&gt; &gt; &gt; / Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
&gt; &gt; &gt; &gt; / Nome                  Versione              Descrizione
&gt; &gt; +++-=====================-=====================-==========================================================
&gt; &gt;  ii  libgmp10              2:5.0.2+dfsg-2ubuntu1 Multiprecision
&gt; &gt; arithmetic library
&gt; 
&gt; This shows that the version installed under /usr/lib is *not* version
&gt; 6.0. So if you have installed gmp-6, it's located somewhere else on the
&gt; system. I'm going to assume it's under /usr/local.

I will check... for now I will simply send you the results of your check

&gt; You need to tweak the invocation of nettle's configure script to pick 
&gt; it
&gt; up (or, alternatively, edit /etc/ld.so.conf to include /usr/local/lib 
&gt; by
&gt; default, and run ldconfig, but that might have undesirable side
&gt; effects).
&gt; 
&gt; What probably happened, is that you got header files for gmp-6 in
&gt; /usr/local/include, and gcc searches that directory by default. And you
&gt; got the corresponding library installed under /usr/local/lib, which
&gt; might be searched by default during link time, but *not* during 
&gt; runtime.
&gt; 
&gt; Try rerunning nettle's ./configure as
&gt; 
&gt; ./configure LDFLAGS="-L/usr/local/lib -Wl,rpath,/usr/local/lib"
&gt; 

zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$ ./configure 
LDFLAGS="-L/usr/local/lib -Wl,rpath,/usr/local/lib"
checking build system type... i686-pc-linux-gnu
checking host system type... i686-pc-linux-gnu
checking for -R flag... using -Wl,-rpath,
Searching for libraries
checking /usr/local/lib/lib... not found
checking /usr/local/lib... added
checking /sw/local/lib... not found
checking /sw/lib... not found
checking /usr/gnu/lib... not found
checking /opt/gnu/lib... not found
checking /sw/gnu/lib... not found
checking /usr/freeware/lib... not found
checking /usr/pkg/lib... not found
checking for gcc... gcc
checking whether the C compiler works... no
configure: error: in `/home/zaamus/Dependencies/nettle-2.7.1':
configure: error: C compiler cannot create executables
See `config.log' for more details

&gt; Or as a quick test to see if this really is the problem, try setting
&gt; LD_LIBRARY_PATH, and run
&gt; 
&gt; LD_LIBRARY_PATH=.lib:/usr/local/lib ldd testsuite/ecc-mul-g-test
&gt; LD_LIBRARY_PATH=.lib:/usr/local/lib ./testsuite/ecc-mul-g-test
&gt; 

zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$   
LD_LIBRARY_PATH=.lib:/usr/local/lib ldd testsuite/ecc-mul-g-test
	linux-gate.so.1 =&gt;  (0x40022000)
	libhogweed.so.2 =&gt; .lib/libhogweed.so.2 (0x40026000)
	libnettle.so.4 =&gt; .lib/libnettle.so.4 (0x40054000)
	libgmp.so.10 =&gt; /usr/local/lib/libgmp.so.10 (0x40087000)
	libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0x40119000)
	/lib/ld-linux.so.2 (0x40000000)
zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$   
LD_LIBRARY_PATH=.lib:/usr/local/lib ./testsuite/ecc-mul-g-test
zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$

&gt; Regards,
&gt; /Niels

-- 
Vittorio Francesco Braga
PhD student in Tor Vergata University of Rome
Mobile: +393203753307, Office (PhD room): +390672594868


</body></email><email><emailId>20141110075343</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-11-10 07:53:43-0400</timestampReceived><subject>Re: FAILs in make check</subject><body>

braga &lt;Vittorio.Braga@roma2.infn.it&gt; writes:

&gt; When I do make check on gmp all tests are PASSed and make install does
&gt; not give me any error..

I don't think there's any problem with your gmp install, it's just that
the nettle build gets messed up a bit with headerfiles from
/usr/local/include and libgmp.so from /usr/lib. What's needed is to make
sure that nettle picks up the same gmp version at compile time, link time
and runtime. (I'm going to reply to your other mail in a little while).

That said, it would make things a bit simpler if you had only a single
version of gmp installed. So if you don't need gmp-6 for some other
reason, you could try uninstalling the gmp-6 you have in /usr/local (and
make sure you get rid if its header files), and install ubuntu's
libgmp-dev package instead. Then for nettle, do a make distclean and
then start over with configure.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141110080001</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-11-10 08:00:01-0400</timestampReceived><subject>Re: FAILs in make check</subject><body>

braga &lt;Vittorio.Braga@roma2.infn.it&gt; writes:

&gt;&gt; Try rerunning nettle's ./configure as
&gt;&gt;
&gt;&gt;   ./configure LDFLAGS="-L/usr/local/lib -Wl,rpath,/usr/local/lib"
&gt;&gt;
&gt;
&gt; zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$ ./configure
&gt; LDFLAGS="-L/usr/local/lib -Wl,rpath,/usr/local/lib"
&gt; checking build system type... i686-pc-linux-gnu
&gt; checking host system type... i686-pc-linux-gnu
&gt; checking for -R flag... using -Wl,-rpath,
&gt; Searching for libraries
&gt; checking /usr/local/lib/lib... not found
&gt; checking /usr/local/lib... added
&gt; checking /sw/local/lib... not found
&gt; checking /sw/lib... not found
&gt; checking /usr/gnu/lib... not found
&gt; checking /opt/gnu/lib... not found
&gt; checking /sw/gnu/lib... not found
&gt; checking /usr/freeware/lib... not found
&gt; checking /usr/pkg/lib... not found
&gt; checking for gcc... gcc
&gt; checking whether the C compiler works... no
&gt; configure: error: in `/home/zaamus/Dependencies/nettle-2.7.1':
&gt; configure: error: C compiler cannot create executables
&gt; See `config.log' for more details

Ok, then the flags I gave you aren't quite right. You have to follow the
suggestion to look in config.log to see what went wrong. But I think I
made a typo, it should probably be "-rpath", not "rpath".

If this is confusing, you may also want to read up on how the runtime
linker locates libraries.

&gt;&gt; Or as a quick test to see if this really is the problem, try setting
&gt;&gt; LD_LIBRARY_PATH, and run
&gt;&gt;
&gt;&gt;   LD_LIBRARY_PATH=.lib:/usr/local/lib ldd testsuite/ecc-mul-g-test
&gt;&gt;   LD_LIBRARY_PATH=.lib:/usr/local/lib ./testsuite/ecc-mul-g-test
&gt;&gt;
&gt;
&gt; zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$
&gt; LD_LIBRARY_PATH=.lib:/usr/local/lib ldd testsuite/ecc-mul-g-test
&gt; 	linux-gate.so.1 =&gt;  (0x40022000)
&gt; 	libhogweed.so.2 =&gt; .lib/libhogweed.so.2 (0x40026000)
&gt; 	libnettle.so.4 =&gt; .lib/libnettle.so.4 (0x40054000)
&gt; 	libgmp.so.10 =&gt; /usr/local/lib/libgmp.so.10 (0x40087000)
&gt; 	libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0x40119000)
&gt; 	/lib/ld-linux.so.2 (0x40000000)
&gt; zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$
&gt; LD_LIBRARY_PATH=.lib:/usr/local/lib ./testsuite/ecc-mul-g-test
&gt; zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$

This indicates that your nettle build works fine, if you only get it to
link with the right libgmp.so file at runtime
(/usr/local/lib/libgmp.so.10 above).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141004193119</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-10-04 19:31:19-0400</timestampReceived><subject>Re: eddsa progress</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; And a low-level function, possibly like
&gt;
&gt;   void
&gt;   _eddsa_sign (const struct ecc_curve *ecc,
&gt;                const struct nettle_hash *H,
&gt;                const uint8_t *pub,
&gt;                void *k1,
&gt;                const mp_limb_t *k2,
&gt;                size_t length,
&gt;                const uint8_t *msg,
&gt;                uint8_t *signature);

Something very similar to this is now implemented, including a couple of
tests. We also need a helper function to expand a private key,
generating the three arguments pub, k1, and k2 above; currently there's
code to do that in the test program, and it's a bit error prone. And
then corresponding _eddsa_verify, and the higher-level more
user-friendly functions.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141019194706</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-10-19 19:47:06-0400</timestampReceived><subject>Re: eddsa progress</subject><body>

I've pushed some eddsa internal functions to the repo the last few
weeks.

Now I have an initial implementation of some friendlier high-level
functions for ed25519-sha512 signatures. Patch below, comments
appreciated, in particular on the interface.

I have a test program that can process
http://ed25519.cr.yp.to/python/sign.input successfully. But that input
file is a bit large (2.4M, or 670K after lzip --best), so I hesitate
before just including a copy of it in the testsuite directory.

Regards,
/Niels

diff --git a/Makefile.in b/Makefile.in
index 7006211..19269af 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -178,6 +178,7 @@ hogweed_SOURCES = sexp.c sexp-format.c \
 		  curve25519-mul-g.c curve25519-mul.c curve25519-eh-to-x.c \
 		  eddsa-compress.c eddsa-decompress.c eddsa-expand.c \
 		  eddsa-hash.c eddsa-sign.c eddsa-verify.c \
+		  ed25519-sha512-sign.c ed25519-sha512-verify.c \
 		  $(OPT_HOGWEED_SOURCES)
 
 HEADERS = aes.h arcfour.h arctwo.h asn1.h blowfish.h \
diff --git a/ed25519-sha512-sign.c b/ed25519-sha512-sign.c
new file mode 100644
index 0000000..d401621
--- /dev/null
+++ b/ed25519-sha512-sign.c
@@ -0,0 +1,69 @@
+/* ed25519-sha512-sign.c
+
+   Copyright (C) 2014 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "eddsa.h"
+
+#include "ecc-internal.h"
+
+void
+ed25519_sha512_set_private_key (struct ed25519_private_key *priv,
+				const uint8_t *key)
+{
+  mp_size_t itch = _eddsa_expand_key_itch (&amp;nettle_curve25519);
+  mp_limb_t *scratch = gmp_alloc_limbs (itch);
+  struct sha512_ctx ctx;
+
+  _eddsa_expand_key (&amp;nettle_curve25519, &amp;nettle_sha512, &amp;ctx,
+		     key, priv-&gt;pub, priv-&gt;k1, priv-&gt;k2, scratch);
+  gmp_free_limbs (scratch, itch);
+}
+
+void
+ed25519_sha512_sign (const struct ed25519_private_key *priv,
+		     size_t length, const uint8_t *msg,
+		     uint8_t *signature)
+{
+  mp_size_t itch = _eddsa_sign_itch (&amp;nettle_curve25519);
+  mp_limb_t *scratch = gmp_alloc_limbs (itch);
+  struct sha512_ctx ctx;
+
+  sha512_init (&amp;ctx);
+  sha512_update (&amp;ctx, ED25519_KEY_SIZE, priv-&gt;k1);
+  _eddsa_sign (&amp;nettle_curve25519, &amp;nettle_sha512, priv-&gt;pub,
+	       &amp;ctx,
+	       priv-&gt;k2, length, msg, signature, scratch);
+
+  gmp_free_limbs (scratch, itch);
+}
diff --git a/ed25519-sha512-verify.c b/ed25519-sha512-verify.c
new file mode 100644
index 0000000..f8d781a
--- /dev/null
+++ b/ed25519-sha512-verify.c
@@ -0,0 +1,74 @@
+/* ed25519-sha512-sign.c
+
+   Copyright (C) 2014 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include &lt;string.h&gt;
+
+#include "eddsa.h"
+
+#include "ecc-internal.h"
+
+int
+ed25519_sha512_set_public_key (struct ed25519_public_key *pub,
+			       const uint8_t *key)
+{
+  mp_size_t itch = _eddsa_decompress_itch (&amp;nettle_curve25519);
+  mp_limb_t *scratch = gmp_alloc_limbs (itch);
+  int res;
+
+  memcpy (pub-&gt;pub, key, sizeof(pub-&gt;pub));
+  res =_eddsa_decompress (&amp;nettle_curve25519,
+			  pub-&gt;A, key, scratch);
+
+  gmp_free_limbs (scratch, itch);
+  return res;
+}
+
+int
+ed25519_sha512_verify (const struct ed25519_public_key *pub,
+		       size_t length, const uint8_t *msg,
+		       const uint8_t *signature)
+{
+  mp_size_t itch = _eddsa_verify_itch (&amp;nettle_curve25519);
+  mp_limb_t *scratch = gmp_alloc_limbs (itch);
+  struct sha512_ctx ctx;
+  int res;
+
+  res = _eddsa_verify (&amp;nettle_curve25519, &amp;nettle_sha512,
+		       pub-&gt;pub, pub-&gt;A, &amp;ctx,
+		       length, msg, signature,
+		       scratch);
+  gmp_free_limbs (scratch, itch);
+  return res;
+}
diff --git a/eddsa.h b/eddsa.h
index 5021486..68a6b1c 100644
--- a/eddsa.h
+++ b/eddsa.h
@@ -35,12 +35,18 @@
 #include "nettle-types.h"
 
 #include "bignum.h"
+#include "sha2.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 /* Name mangling */
+#define ed25519_sha512_set_private_key nettle_ed25519_sha512_set_private_key
+#define ed25519_sha512_sign nettle_ed25519_sha512_sign
+#define ed25519_sha512_set_public_key nettle_ed25519_sha512_set_public_key
+#define ed25519_sha512_verify nettle_ed25519_sha512_verify
+
 #define _eddsa_compress _nettle_eddsa_compress
 #define _eddsa_compress_itch _nettle_eddsa_compress_itch
 #define _eddsa_decompress _nettle_eddsa_decompress
@@ -54,6 +60,44 @@ extern "C" {
 #define _eddsa_verify_itch _nettle_eddsa_verify_itch
 
 #define ED25519_KEY_SIZE 32
+#define ED25519_SIGNATURE_SIZE 64
+
+/* Number of limbs needed to represent a point koordinate, or a secret
+   exponent (note that exponents are 254 bits, larger than q). */
+#define _ED25519_LIMB_SIZE ((255 + (GMP_NUMB_BITS - 1)) / GMP_NUMB_BITS)
+
+struct ed25519_private_key
+{
+  uint8_t pub[ED25519_KEY_SIZE];
+  uint8_t k1[ED25519_KEY_SIZE];
+  mp_limb_t k2[_ED25519_LIMB_SIZE];
+};
+
+void
+ed25519_sha512_set_private_key (struct ed25519_private_key *priv,
+				const uint8_t *key);
+
+void
+ed25519_sha512_sign (const struct ed25519_private_key *priv,
+		     size_t length, const uint8_t *msg,
+		     uint8_t *signature);
+
+struct ed25519_public_key
+{
+  uint8_t pub[ED25519_KEY_SIZE];
+  mp_limb_t A[2*_ED25519_LIMB_SIZE];
+};
+
+int
+ed25519_sha512_set_public_key (struct ed25519_public_key *pub,
+			       const uint8_t *key);
+
+int
+ed25519_sha512_verify (const struct ed25519_public_key *pub,
+		       size_t length, const uint8_t *msg,
+		       const uint8_t *signature);
+
+/* Low-level internal functions */
 
 struct ecc_curve;
 struct ecc_modulo;

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20141211105333</emailId><senderName>Amos Jeffries</senderName><senderEmail>squid3@treenet.co.nz</senderEmail><timestampReceived>2014-12-11 10:53:33-0400</timestampReceived><subject>Please add base-64 URL-safe alphabet</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

RFC 4648 (https://tools.ietf.org/html/rfc4648) standardizes two
Base-64 alphabets. Nettle currently only supports the traditional
base-64 alphabet from section 4.

There is growing use amongst new protocol definitions and extensions,
particularly in the HTTP area for the URL-safe extension alphabet
instead of the classical Base-64 alphabet.


The attached patch implements a proposed API/ABI extension adding
support for RFC 4648 section 5 "Base 64 Encoding with URL and Filename
Safe Alphabet"

External code simply calls the init() function relevant to the
alphabet it is needing to encode/decode with. The library internally
uses the context to select which lookup table to use for later base64
function calls.

The base64_encode_raw() and base64_encode_group() functions which do
not use contexts are left untouched for now.


Amos Jeffries
Treehouse Networks Ltd.
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (MingW32)

iQEcBAEBAgAGBQJUiXerAAoJELJo5wb/XPRjPxEIAJGMXNF0H84kJntKpe1idimr
+x7/xg55GJ2sWEBAbVIHvKvjFZoBIeqNmPeeK+yrqMdA+dtALA37AuezqhiNBtuj
YfGd/DyRvys2O2bQ4XNRHxj6zGQU6tlRHHZzSnWp9ywwN4xk/zfNc5JM0EKYqiuu
8crNPzQxP91N33gkdi9LrOkAA8v+/bTYJgTrT46D/2Ut+8ECAcpjS5jwsJiljETu
uqO50QlhqGC3ZsHKs1kYnjrbl1Peiqw/b/srEnY3shfS9MKrTYe3qLOsvU5CQpnD
A7e8w/SW716D0s4t0SGf85WvUnS6UvDTfAdm3EXAPKNU8PaYpK9D8izq8kgxCP4=
=NgGG
-----END PGP SIGNATURE-----

["base-64_extended.patch" (text/plain)]

diff --git a/base64-decode.c b/base64-decode.c
index f622baa..fbaf54f 100644
--- a/base64-decode.c
+++ b/base64-decode.c
@@ -43,7 +43,7 @@
 #define TABLE_END -3
 
 static const signed char
-decode_table[0x100] =
+default_decode_table[0x100] =
 {
   /* White space is HT, VT, FF, CR, LF and SPC */
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -2, -2, -2, -2, -1, -1, 
@@ -64,10 +64,40 @@ decode_table[0x100] =
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 };
 
+static const signed char
+urlextended_decode_table[0x100] =
+{
+  /* White space is HT, VT, FF, CR, LF and SPC */
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -2, -2, -2, -2, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
+  52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -3, -1, -1,
+  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
+  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
+  -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+  41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+};
+
 void
 base64_decode_init(struct base64_decode_ctx *ctx)
 {
   ctx-&gt;word = ctx-&gt;bits = ctx-&gt;padding = 0;
+  ctx-&gt;alphabet = BASE64_ALPHABET;
+}
+
+void
+base64url_decode_init(struct base64_decode_ctx *ctx)
+{
+  ctx-&gt;word = ctx-&gt;bits = ctx-&gt;padding = 0;
+  ctx-&gt;alphabet = BASE64URL_ALPHABET;
 }
 
 int
@@ -76,8 +106,11 @@ base64_decode_single(struct base64_decode_ctx *ctx,
 		     uint8_t src)
 {
   int data;
-  
-  data = decode_table[src];
+
+  if (ctx-&gt;alphabet == BASE64URL_ALPHABET)
+    data = urlextended_decode_table[src];
+  else
+    data = default_decode_table[src];
 
   switch(data)
     {
diff --git a/base64-encode.c b/base64-encode.c
index 313c512..fcf8546 100644
--- a/base64-encode.c
+++ b/base64-encode.c
@@ -38,11 +38,16 @@
 
 #include "base64.h"
 
-static const uint8_t encode_table[64] =
+static const uint8_t default_encode_table[64] =
   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
   "abcdefghijklmnopqrstuvwxyz"
   "0123456789+/";
 
+static const uint8_t urlextended_encode_table[64] =
+  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+  "abcdefghijklmnopqrstuvwxyz"
+  "0123456789-_";
+
 #define ENCODE(x) (encode_table[0x3F &amp; (x)])
 
 void
@@ -52,6 +57,7 @@ base64_encode_raw(uint8_t *dst, size_t length, const uint8_t *src)
   uint8_t *out = dst + BASE64_ENCODE_RAW_LENGTH(length);
 
   unsigned left_over = length % 3;
+  const uint8_t *encode_table = default_encode_table;
 
   if (left_over)
     {
@@ -97,6 +103,7 @@ base64_encode(uint8_t *dst,
   unsigned n = src_length / 3;
   unsigned left_over  = src_length % 3;
   unsigned done = 0;
+  const uint8_t *encode_table = default_encode_table;
   
   if (left_over)
     {
@@ -134,6 +141,7 @@ base64_encode(uint8_t *dst,
 void
 base64_encode_group(uint8_t *dst, uint32_t group)
 {
+  const uint8_t *encode_table = default_encode_table;
   *dst++ = ENCODE(group &gt;&gt; 18);
   *dst++ = ENCODE(group &gt;&gt; 12);
   *dst++ = ENCODE(group &gt;&gt; 6);
@@ -144,6 +152,14 @@ void
 base64_encode_init(struct base64_encode_ctx *ctx)
 {
   ctx-&gt;word = ctx-&gt;bits = 0;
+  ctx-&gt;alphabet = BASE64_ALPHABET;
+}
+
+void
+base64url_encode_init(struct base64_encode_ctx *ctx)
+{
+  ctx-&gt;word = ctx-&gt;bits = 0;
+  ctx-&gt;alphabet = BASE64URL_ALPHABET;
 }
 
 /* Encodes a single byte. */
@@ -155,6 +171,7 @@ base64_encode_single(struct base64_encode_ctx *ctx,
   unsigned done = 0;
   unsigned word = ctx-&gt;word &lt;&lt; 8 | src;
   unsigned bits = ctx-&gt;bits + 8;
+  const uint8_t *encode_table = (ctx-&gt;alphabet == BASE64URL_ALPHABET ? \
urlextended_encode_table : default_encode_table);  
   while (bits &gt;= 6)
     {
@@ -182,6 +199,7 @@ base64_encode_update(struct base64_encode_ctx *ctx,
   size_t left = length;
   unsigned left_over;
   size_t bulk;
+  const uint8_t *encode_table = (ctx-&gt;alphabet == BASE64URL_ALPHABET ? \
urlextended_encode_table : default_encode_table);  
   while (ctx-&gt;bits &amp;&amp; left)
     {
@@ -221,6 +239,7 @@ base64_encode_final(struct base64_encode_ctx *ctx,
 {
   unsigned done = 0;
   unsigned bits = ctx-&gt;bits;
+  const uint8_t *encode_table = (ctx-&gt;alphabet == BASE64URL_ALPHABET ? \
urlextended_encode_table : default_encode_table);  
   if (bits)
     {
diff --git a/base64.h b/base64.h
index a6fb823..4f6d5e3 100644
--- a/base64.h
+++ b/base64.h
@@ -42,12 +42,14 @@ extern "C" {
 
 /* Name mangling */
 #define base64_encode_init nettle_base64_encode_init
+#define base64url_encode_init nettle_base64url_encode_init
 #define base64_encode_single nettle_base64_encode_single
 #define base64_encode_update nettle_base64_encode_update
 #define base64_encode_final nettle_base64_encode_final
 #define base64_encode_raw nettle_base64_encode_raw
 #define base64_encode_group nettle_base64_encode_group
 #define base64_decode_init nettle_base64_decode_init
+#define base64url_decode_init nettle_base64url_decode_init
 #define base64_decode_single nettle_base64_decode_single
 #define base64_decode_update nettle_base64_decode_update
 #define base64_decode_final nettle_base64_decode_final
@@ -55,6 +57,10 @@ extern "C" {
 #define BASE64_BINARY_BLOCK_SIZE 3
 #define BASE64_TEXT_BLOCK_SIZE 4
 
+/* which alphabet to use */
+#define BASE64_ALPHABET 0
+#define BASE64URL_ALPHABET 1
+
 /* Base64 encoding */
 
 /* Maximum length of output for base64_encode_update. NOTE: Doesn't
@@ -73,11 +79,17 @@ struct base64_encode_ctx
 {
   unsigned word;   /* Leftover bits */
   unsigned bits;  /* Number of bits, always 0, 2, or 4. */
+  unsigned alphabet; /* which alphabet to use for encoding */
 };
 
+/* initialize encoding context for base-64 */
 void
 base64_encode_init(struct base64_encode_ctx *ctx);
 
+/* initialize encoding context for base-64 with URL safe extended alphabet */
+void
+base64url_encode_init(struct base64_encode_ctx *ctx);
+
 /* Encodes a single byte. Returns amount of output (always 1 or 2). */
 size_t
 base64_encode_single(struct base64_encode_ctx *ctx,
@@ -123,11 +135,17 @@ struct base64_decode_ctx
 
   /* Number of padding characters encountered */
   unsigned padding;
+  unsigned alphabet; /* which alphabet to use for encoding */
 };
 
+/* initialize encoding context for base-64 */
 void
 base64_decode_init(struct base64_decode_ctx *ctx);
 
+/* initialize encoding context for base-64 with URL safe extended alphabet */
+void
+base64url_decode_init(struct base64_decode_ctx *ctx);
+
 /* Decodes a single byte. Returns amount of output (0 or 1), or -1 on
  * errors. */
 int



</body></email><email><emailId>20141212184919</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-12-12 18:49:19-0400</timestampReceived><subject>Re: Please add base-64 URL-safe alphabet</subject><body>

Amos Jeffries &lt;squid3@treenet.co.nz&gt; writes:

&gt; The attached patch implements a proposed API/ABI extension adding
&gt; support for RFC 4648 section 5 "Base 64 Encoding with URL and Filename
&gt; Safe Alphabet"

Thanks. It makes sense to me to add support for this in one way or the
other.

&gt; External code simply calls the init() function relevant to the
&gt; alphabet it is needing to encode/decode with. The library internally
&gt; uses the context to select which lookup table to use for later base64
&gt; function calls.

Passing the alphabet to the init function and recording it in the context
is nice in some ways, but it breaks the ABI (since the size of the
context struct is part of the ABI). Now, maybe we have to break the ABI
for 3.1 anyway, to introduce versioned symbols. I don't yet know for
sure if an soname change is necessary or not.

The alternative to storing this in the context, is to introduce some
general encoding/decoding functions which support arbitrary alphabets and
take the needed table as an additional argument. Then base64_* and
base64url_* would be simple wrapper functions passing the right table.

&gt; The base64_encode_raw() and base64_encode_group() functions which do
&gt; not use contexts are left untouched for now.

Both functions are undocumented, so we can consider changing them if
neeed. As for encode_group, that seems to be used only in the openpgp code
which is not really in a working state. So we can probably ignore that one.

But base64_encode_raw is used by the main encoding function,
base64_encode_update. So to support other alphabets one either needs to
pass some kind of alphabet argument to base64_encode_raw, or introduce a
new function with such an argument.

Does anyone know if applications are using base64_encode_raw, despite
it's status as undocumented?

&gt; +/* which alphabet to use */
&gt; +#define BASE64_ALPHABET 0
&gt; +#define BASE64URL_ALPHABET 1

I think I'd prefer to avoid an enumeration of available alphabets. And
in the API you sketch, applications will never use these constants,
right?

&gt; /* Base64 encoding */
&gt; 
&gt; /* Maximum length of output for base64_encode_update. NOTE: Doesn't
&gt; @@ -73,11 +79,17 @@ struct base64_encode_ctx
&gt; {
&gt; unsigned word;   /* Leftover bits */
&gt; unsigned bits;  /* Number of bits, always 0, 2, or 4. */
&gt; +  unsigned alphabet; /* which alphabet to use for encoding */
&gt; };

Assuming we go with adding stuff to the context struct, I'd prefer to
add a pointer directly to the alphabet (and for decoding, a pointer
directly to the lookup table). So we don't need any switch on an
alphabet enum.

&gt; diff --git a/base64-decode.c b/base64-decode.c
&gt; index f622baa..fbaf54f 100644
&gt; --- a/base64-decode.c
&gt; +++ b/base64-decode.c
&gt; @@ -43,7 +43,7 @@
&gt; #define TABLE_END -3
&gt; 
&gt; static const signed char
&gt; -decode_table[0x100] =
&gt; +default_decode_table[0x100] =
&gt; {
&gt; /* White space is HT, VT, FF, CR, LF and SPC */
&gt; -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -2, -2, -2, -2, -1, -1, 
&gt; @@ -64,10 +64,40 @@ decode_table[0x100] =
&gt; -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
&gt; };
&gt; 
&gt; +static const signed char
&gt; +urlextended_decode_table[0x100] =
&gt; +{
&gt; +  /* White space is HT, VT, FF, CR, LF and SPC */
&gt; +  -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -2, -2, -2, -2, -1, -1,
&gt; +  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
&gt; +  -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
&gt; +  52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -3, -1, -1,
&gt; +  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
&gt; +  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
&gt; +  -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
&gt; +  41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
&gt; +  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
&gt; +  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
&gt; +  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
&gt; +  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
&gt; +  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
&gt; +  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
&gt; +  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
&gt; +  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
&gt; +};
&gt; +

I think the base64url decoding functions, and its table, should be put
in its own object file. Maybe static linking is obscure these days, but
it's desirable that if one uses only the standard base64 alphabet, one
shouldn't get dependencies causing the linker to drag in tables for
other alphabets.

&gt; void
&gt; base64_decode_init(struct base64_decode_ctx *ctx)
&gt; {
&gt; ctx-&gt;word = ctx-&gt;bits = ctx-&gt;padding = 0;
&gt; +  ctx-&gt;alphabet = BASE64_ALPHABET;
&gt; +}
&gt; +
&gt; +void
&gt; +base64url_decode_init(struct base64_decode_ctx *ctx)
&gt; +{
&gt; +  ctx-&gt;word = ctx-&gt;bits = ctx-&gt;padding = 0;
&gt; +  ctx-&gt;alphabet = BASE64URL_ALPHABET;
&gt; }

And then the assignment of ctx-&gt;alphabet would be

  ctx-&gt;table = base64_decode_table;

and

  ctx-&gt;table = base64url_decode_table;

in the respective init functions.

&gt; int
&gt; @@ -76,8 +106,11 @@ base64_decode_single(struct base64_decode_ctx *ctx,
&gt; 		     uint8_t src)
&gt; {
&gt; int data;
&gt; -  
&gt; -  data = decode_table[src];
&gt; +
&gt; +  if (ctx-&gt;alphabet == BASE64URL_ALPHABET)
&gt; +    data = urlextended_decode_table[src];
&gt; +  else
&gt; +    data = default_decode_table[src];

And this piece of code would then simplify to

  data = ctx-&gt;table[src];

&gt; @@ -155,6 +171,7 @@ base64_encode_single(struct base64_encode_ctx *ctx,
&gt; unsigned done = 0;
&gt; unsigned word = ctx-&gt;word &lt;&lt; 8 | src;
&gt; unsigned bits = ctx-&gt;bits + 8;
&gt; +  const uint8_t *encode_table = (ctx-&gt;alphabet == BASE64URL_ALPHABET ? \
&gt; urlextended_encode_table : default_encode_table); 
&gt; while (bits &gt;= 6)
&gt; {

I think this works, but only because the ENCODE macro which refers to
the name "encode_table" now gets a local variable, instead of the global
table in the old code. At a casual look, the local variable appears
unused. I think it's easier to understand if this dependency where made
more explicit.

Finally, are there other alphabets that are in use? You have
mentioned, earlier, the alphabet used for crypt(3) (where is that
documented???), and iirc, SRP files also use some unusual alphabet for
base64.

Maybe we should make it reasonably easy to let applications supply
custom alphabets? This should be almost trivial for encoding, while for
decoding, we would either need to document the format of the lookup
table, or provide a function to generate a decoding table for a given
alphabet.

Best regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20141212191738</emailId><senderName>Daniel Kahn Gillmor</senderName><senderEmail>dkg@fifthhorseman.net</senderEmail><timestampReceived>2014-12-12 19:17:38-0400</timestampReceived><subject>Re: Please add base-64 URL-safe alphabet</subject><body>


On 12/12/2014 01:49 PM, nisse@lysator.liu.se (Niels M=C3=B6ller) wrote:

&gt; Now, maybe we have to break the ABI
&gt; for 3.1 anyway, to introduce versioned symbols. I don't yet know for
&gt; sure if an soname change is necessary or not.

My experience is that tools built against a library with unversioned
symbols can work fine when linked against a library with versioned
symbols, but that it produces warnings from the dynamic linker.  This
came up recently for libgpg-error, which recently added symbol versioning=
:

 https://bugs.debian.org/771100
 https://bugs.debian.org/765430

In short, i don't think an SONAME bump is functionally necessary just
for introduction of versioned symbols, though lack of an SONAME bump may
introduce some cosmetic changes for people who don't rebuild against the
newer version.

&gt; Does anyone know if applications are using base64_encode_raw, despite
&gt; it's status as undocumented?

in the debian project, it looks like there are code examples from aria2
that use base64_encode_raw, and it's also used in rtmpdump's librtmp:

https://codesearch.debian.net/results/base64_encode_raw/page_0

We can probably get the aria2 examples fixed, but librtmp seems more
problematic.

	--dkg


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20141205225708</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-12-05 22:57:08-0400</timestampReceived><subject>patch: define API version number</subject><body>

Hello,
 This patch adds a definition in nettle-meta.h with nettle's version
number. That way applications can be easily modified to support both the
2.7 and the 3.x API. I didn't add for hogweed because it didn't seem to
make sense, the API version is fully determined by nettle only.

regards,
Nikos


["0001-define-NETTLE_VERSION-in-nettle-meta.h.patch" (0001-define-NETTLE_VERSION-in-nettle-meta.h.patch)]

From 6e1001910e299c865bce7b14a47cfb5d728df9ed Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Fri, 5 Dec 2014 23:54:45 +0100
Subject: [PATCH] define NETTLE_VERSION in nettle-meta.h

That allows applications to determine the API version using
the headers only.
---
 configure.ac     |   6 +-
 nettle-meta.h    |   1 +
 nettle-meta.h.in | 230 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 236 insertions(+), 1 deletion(-)
 create mode 100644 nettle-meta.h.in

diff --git a/configure.ac b/configure.ac
index bb33962..4d1d94d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -16,6 +16,10 @@ LIBNETTLE_MINOR=0
 LIBHOGWEED_MAJOR=4
 LIBHOGWEED_MINOR=0
 
+MAJOR_VERSION=`echo $PACKAGE_VERSION | sed 's/\(.*\)\..*/\1/g'`
+MINOR_VERSION=`echo $PACKAGE_VERSION | sed 's/.*\.\(.*\)/\1/g'`
+AC_SUBST(NUMBER_VERSION, `printf "0x%02x%02x" $MAJOR_VERSION $MINOR_VERSION`)
+
 AC_CANONICAL_HOST
 
 # Command line options
@@ -841,7 +845,7 @@ if test x$GCC = xyes ; then
 # inttypes.h.
 fi
 
-AC_CONFIG_FILES([config.make config.m4 Makefile bignum.h])
+AC_CONFIG_FILES([config.make config.m4 Makefile bignum.h nettle-meta.h])
 AC_CONFIG_FILES([tools/Makefile testsuite/Makefile examples/Makefile])
 AC_CONFIG_FILES([nettle.pc hogweed.pc])
 
diff --git a/nettle-meta.h b/nettle-meta.h
index 2d8d5b8..e8ae65b 100644
--- a/nettle-meta.h
+++ b/nettle-meta.h
@@ -40,6 +40,7 @@
 extern "C" {
 #endif
 
+#define NETTLE_VERSION 0x0301
 
 struct nettle_cipher
 {
diff --git a/nettle-meta.h.in b/nettle-meta.h.in
new file mode 100644
index 0000000..1c999f3
--- /dev/null
+++ b/nettle-meta.h.in
@@ -0,0 +1,230 @@
+/* nettle-meta.h
+
+   Information about algorithms.
+
+   Copyright (C) 2002, 2014 Niels Möller
+
+   This file is part of GNU Nettle.
+
+   GNU Nettle is free software: you can redistribute it and/or
+   modify it under the terms of either:
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at your
+       option) any later version.
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at your
+       option) any later version.
+
+   or both in parallel, as here.
+
+   GNU Nettle is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see http://www.gnu.org/licenses/.
+*/
+
+#ifndef NETTLE_META_H_INCLUDED
+#define NETTLE_META_H_INCLUDED
+
+#include "nettle-types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define NETTLE_VERSION @NUMBER_VERSION@
+
+struct nettle_cipher
+{
+  const char *name;
+  
+  unsigned context_size;
+  
+  /* Zero for stream ciphers */
+  unsigned block_size;
+
+  /* Suggested key size; other sizes are sometimes possible. */
+  unsigned key_size;
+
+  nettle_set_key_func *set_encrypt_key;
+  nettle_set_key_func *set_decrypt_key;
+
+  nettle_cipher_func *encrypt;
+  nettle_cipher_func *decrypt;
+};
+
+/* null-terminated list of ciphers implemented by this version of nettle */
+extern const struct nettle_cipher * const nettle_ciphers[];
+
+extern const struct nettle_cipher nettle_aes128;
+extern const struct nettle_cipher nettle_aes192;
+extern const struct nettle_cipher nettle_aes256;
+
+extern const struct nettle_cipher nettle_camellia128;
+extern const struct nettle_cipher nettle_camellia192;
+extern const struct nettle_cipher nettle_camellia256;
+
+extern const struct nettle_cipher nettle_cast128;
+
+extern const struct nettle_cipher nettle_serpent128;
+extern const struct nettle_cipher nettle_serpent192;
+extern const struct nettle_cipher nettle_serpent256;
+
+extern const struct nettle_cipher nettle_twofish128;
+extern const struct nettle_cipher nettle_twofish192;
+extern const struct nettle_cipher nettle_twofish256;
+
+extern const struct nettle_cipher nettle_arctwo40;
+extern const struct nettle_cipher nettle_arctwo64;
+extern const struct nettle_cipher nettle_arctwo128;
+extern const struct nettle_cipher nettle_arctwo_gutmann128;
+
+struct nettle_hash
+{
+  const char *name;
+
+  /* Size of the context struct */
+  unsigned context_size;
+
+  /* Size of digests */
+  unsigned digest_size;
+  
+  /* Internal block size */
+  unsigned block_size;
+
+  nettle_hash_init_func *init;
+  nettle_hash_update_func *update;
+  nettle_hash_digest_func *digest;
+};
+
+#define _NETTLE_HASH(name, NAME) {		\
+ #name,						\
+ sizeof(struct name##_ctx),			\
+ NAME##_DIGEST_SIZE,				\
+ NAME##_BLOCK_SIZE,				\
+ (nettle_hash_init_func *) name##_init,		\
+ (nettle_hash_update_func *) name##_update,	\
+ (nettle_hash_digest_func *) name##_digest	\
+} 
+
+/* null-terminated list of digests implemented by this version of nettle */
+extern const struct nettle_hash * const nettle_hashes[];
+
+extern const struct nettle_hash nettle_md2;
+extern const struct nettle_hash nettle_md4;
+extern const struct nettle_hash nettle_md5;
+extern const struct nettle_hash nettle_gosthash94;
+extern const struct nettle_hash nettle_ripemd160;
+extern const struct nettle_hash nettle_sha1;
+extern const struct nettle_hash nettle_sha224;
+extern const struct nettle_hash nettle_sha256;
+extern const struct nettle_hash nettle_sha384;
+extern const struct nettle_hash nettle_sha512;
+extern const struct nettle_hash nettle_sha512_224;
+extern const struct nettle_hash nettle_sha512_256;
+extern const struct nettle_hash nettle_sha3_224;
+extern const struct nettle_hash nettle_sha3_256;
+extern const struct nettle_hash nettle_sha3_384;
+extern const struct nettle_hash nettle_sha3_512;
+
+struct nettle_aead
+{
+  const char *name;
+  
+  unsigned context_size;
+  /* Block size for encrypt and decrypt. */
+  unsigned block_size;
+  unsigned key_size;
+  unsigned nonce_size;
+  unsigned digest_size;
+
+  nettle_set_key_func *set_encrypt_key;
+  nettle_set_key_func *set_decrypt_key;
+  nettle_set_key_func *set_nonce;
+  nettle_hash_update_func *update;
+  nettle_crypt_func *encrypt;
+  nettle_crypt_func *decrypt;
+  /* FIXME: Drop length argument? */
+  nettle_hash_digest_func *digest;
+};
+
+/* null-terminated list of aead constructions implemented by this
+   version of nettle */
+extern const struct nettle_aead * const nettle_aeads[];
+
+extern const struct nettle_aead nettle_gcm_aes128;
+extern const struct nettle_aead nettle_gcm_aes192;
+extern const struct nettle_aead nettle_gcm_aes256;
+extern const struct nettle_aead nettle_gcm_camellia128;
+extern const struct nettle_aead nettle_gcm_camellia256;
+extern const struct nettle_aead nettle_eax_aes128;
+extern const struct nettle_aead nettle_chacha_poly1305;
+
+struct nettle_armor
+{
+  const char *name;
+  unsigned encode_context_size;
+  unsigned decode_context_size;
+
+  unsigned encode_final_length;
+
+  nettle_armor_init_func *encode_init;
+  nettle_armor_length_func *encode_length;
+  nettle_armor_encode_update_func *encode_update;
+  nettle_armor_encode_final_func *encode_final;
+  
+  nettle_armor_init_func *decode_init;
+  nettle_armor_length_func *decode_length;
+  nettle_armor_decode_update_func *decode_update;
+  nettle_armor_decode_final_func *decode_final;
+};
+
+#define _NETTLE_ARMOR(name, NAME) {				\
+  #name,							\
+  sizeof(struct name##_encode_ctx),				\
+  sizeof(struct name##_decode_ctx),				\
+  NAME##_ENCODE_FINAL_LENGTH,					\
+  (nettle_armor_init_func *) name##_encode_init,		\
+  (nettle_armor_length_func *) name##_encode_length,		\
+  (nettle_armor_encode_update_func *) name##_encode_update,	\
+  (nettle_armor_encode_final_func *) name##_encode_final,	\
+  (nettle_armor_init_func *) name##_decode_init,		\
+  (nettle_armor_length_func *) name##_decode_length,		\
+  (nettle_armor_decode_update_func *) name##_decode_update,	\
+  (nettle_armor_decode_final_func *) name##_decode_final,	\
+}
+
+#define _NETTLE_ARMOR_0(name, NAME) {				\
+  #name,							\
+  0,								\
+  sizeof(struct name##_decode_ctx),				\
+  NAME##_ENCODE_FINAL_LENGTH,					\
+  (nettle_armor_init_func *) name##_encode_init,		\
+  (nettle_armor_length_func *) name##_encode_length,		\
+  (nettle_armor_encode_update_func *) name##_encode_update,	\
+  (nettle_armor_encode_final_func *) name##_encode_final,	\
+  (nettle_armor_init_func *) name##_decode_init,		\
+  (nettle_armor_length_func *) name##_decode_length,		\
+  (nettle_armor_decode_update_func *) name##_decode_update,	\
+  (nettle_armor_decode_final_func *) name##_decode_final,	\
+}
+
+/* null-terminated list of armor schemes implemented by this version of nettle */
+extern const struct nettle_armor * const nettle_armors[];
+
+extern const struct nettle_armor nettle_base64;
+extern const struct nettle_armor nettle_base16;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETTLE_META_H_INCLUDED */
-- 
2.1.3



</body></email><email><emailId>20141208200423</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-12-08 20:04:23-0400</timestampReceived><subject>Versioned symbols (was: Re: issues found while converting from 2.7 to 3.0)</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Attached a patch which separates the .map files.

I've now applied this to a branch named "versioned-symbols". With some
additional updates, removing the $(srcdir) when referring to the linker
scripts which now are in the build directory, adding ChangeLog entries,
and bumping the library version numbers.

Seems to work, but I'm not entirely sure what the symbol table is
expected to look like. E.g.,

$ readelf -s libnettle.so |grep sha512_init
    17: 000000000001d470   114 FUNC    GLOBAL DEFAULT   13 nettle_sha512_init@@NETTLE_6
   447: 000000000001d470   114 FUNC    GLOBAL DEFAULT   13 nettle_sha512_init

So there are two symbols with the same value, one with and one without
the version suffix. Different symbol tables though, the former is in
.dynsym, the latter in .symtab. Is that how it's supposed to be?

Further testing appreciated.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141212191309</emailId><senderName>Eli Zaretskii</senderName><senderEmail>eliz@gnu.org</senderEmail><timestampReceived>2014-12-12 19:13:09-0400</timestampReceived><subject>Re: Potential bug in nettle-benchmark.c</subject><body>

&gt; From: nisse@lysator.liu.se (Niels Möller)
&gt; Cc: nettle-bugs@lists.lysator.liu.se
&gt; Date: Fri, 12 Dec 2014 18:43:06 +0100
&gt; 
&gt; You are using nettle-2.7.1, I guess?

Yes.

</body></email><email><emailId>20141212200128</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-12-12 20:01:28-0400</timestampReceived><subject>Re: Please add base-64 URL-safe alphabet</subject><body>

Daniel Kahn Gillmor &lt;dkg@fifthhorseman.net&gt; writes:

&gt; In short, i don't think an SONAME bump is functionally necessary just
&gt; for introduction of versioned symbols, though lack of an SONAME bump may
&gt; introduce some cosmetic changes for people who don't rebuild against the
&gt; newer version.

And in this case, I think the cosmetic problem is less important, since
I'd expect most users to upgrade from 2.7.1 to 3.1, and never install
3.0. But I guess, for the same reason, another soname change should also
be relatively painless. Do you agree?

Hmm. So if we conclude that it really would make a better interface with
extended base64 contexts, we could do that and bump the soname.

(And API changes are a different matter, I think it is important to not
break existing source code using base64. So the idea is that code using
base64_init and friends should only need a recompile to work with
nettle-3.1).

&gt;&gt; Does anyone know if applications are using base64_encode_raw, despite
&gt;&gt; it's status as undocumented?
&gt;
&gt; in the debian project, it looks like there are code examples from aria2
&gt; that use base64_encode_raw, and it's also used in rtmpdump's librtmp:

Thanks for looking this up. Seems like we should keep (and document?)
base64_encode_raw unchanged. And we then have to come up with a new name
for a base64_encode_raw_with_alphabet function.

And doing a similar search for base64_encode_group luckily gives no
matches at all, outside of nettle.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141213080229</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-12-13 08:02:29-0400</timestampReceived><subject>Re: function casts</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; There is a truncation warning indeed.

Good. Thanks for testing.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141216120235</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-12-16 12:02:35-0400</timestampReceived><subject>[Fwd: [gnutls-help] Generating DH Parameters larger than 3072 bits]</subject><body>

Hello,
 It seems that by switching gnutls to nettle 2.7.x for DSA (and DH) key
generation the forwarded issues occur. Would it be possible to have a
2.7.x release with the attached patch? That would allow gnutls 3.3.x
generate arbitrary DH parameters.

regards,
Nikos


["0001-allow-the-usage-of-arbitrary-q_bits-sizes-in-DSA-key.patch" (0001-allow-the-usage-of-arbitrary-q_bits-sizes-in-DSA-key.patch)]

From c7ef2843dfca566fc67e6c8ffb601a05a60d24d9 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt;
Date: Tue, 16 Dec 2014 12:56:34 +0100
Subject: [PATCH] allow the usage of arbitrary q_bits sizes in DSA key
 generation

---
 dsa-keygen.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dsa-keygen.c b/dsa-keygen.c
index 1b84e49..65ad80f 100644
--- a/dsa-keygen.c
+++ b/dsa-keygen.c
@@ -61,7 +61,8 @@ dsa_generate_keypair(struct dsa_public_key *pub,
 	return 0;
       break;
     default:
-      return 0;
+      if (q_bits &lt; 160)
+        return 0;
     }
 
   mpz_init (p0);
-- 
2.1.0



</body></email><email><emailId>20141110202105</emailId><senderName>braga</senderName><senderEmail>vittorio.braga@roma2.infn.it</senderEmail><timestampReceived>2014-11-10 20:21:05-0400</timestampReceived><subject>Re: FAILs in make check</subject><body>

At the very last I managed to correctly install it thanks to your 
suggestions. I truly don't remember how, but I think I had to run nettle 
installation two times before it worked correctly

Best regards, Vittorio

Il 2014-11-10 09:00 nisse@lysator.liu.se ha scritto:
&gt; braga &lt;Vittorio.Braga@roma2.infn.it&gt; writes:
&gt; 
&gt;&gt;&gt; Try rerunning nettle's ./configure as
&gt;&gt;&gt; 
&gt;&gt;&gt;   ./configure LDFLAGS="-L/usr/local/lib -Wl,rpath,/usr/local/lib"
&gt;&gt;&gt; 
&gt;&gt; 
&gt;&gt; zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$ ./configure
&gt;&gt; LDFLAGS="-L/usr/local/lib -Wl,rpath,/usr/local/lib"
&gt;&gt; checking build system type... i686-pc-linux-gnu
&gt;&gt; checking host system type... i686-pc-linux-gnu
&gt;&gt; checking for -R flag... using -Wl,-rpath,
&gt;&gt; Searching for libraries
&gt;&gt; checking /usr/local/lib/lib... not found
&gt;&gt; checking /usr/local/lib... added
&gt;&gt; checking /sw/local/lib... not found
&gt;&gt; checking /sw/lib... not found
&gt;&gt; checking /usr/gnu/lib... not found
&gt;&gt; checking /opt/gnu/lib... not found
&gt;&gt; checking /sw/gnu/lib... not found
&gt;&gt; checking /usr/freeware/lib... not found
&gt;&gt; checking /usr/pkg/lib... not found
&gt;&gt; checking for gcc... gcc
&gt;&gt; checking whether the C compiler works... no
&gt;&gt; configure: error: in `/home/zaamus/Dependencies/nettle-2.7.1':
&gt;&gt; configure: error: C compiler cannot create executables
&gt;&gt; See `config.log' for more details
&gt; 
&gt; Ok, then the flags I gave you aren't quite right. You have to follow 
&gt; the
&gt; suggestion to look in config.log to see what went wrong. But I think I
&gt; made a typo, it should probably be "-rpath", not "rpath".
&gt; 
&gt; If this is confusing, you may also want to read up on how the runtime
&gt; linker locates libraries.
&gt; 
&gt;&gt;&gt; Or as a quick test to see if this really is the problem, try setting
&gt;&gt;&gt; LD_LIBRARY_PATH, and run
&gt;&gt;&gt; 
&gt;&gt;&gt;   LD_LIBRARY_PATH=.lib:/usr/local/lib ldd testsuite/ecc-mul-g-test
&gt;&gt;&gt;   LD_LIBRARY_PATH=.lib:/usr/local/lib ./testsuite/ecc-mul-g-test
&gt;&gt;&gt; 
&gt;&gt; 
&gt;&gt; zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$
&gt;&gt; LD_LIBRARY_PATH=.lib:/usr/local/lib ldd testsuite/ecc-mul-g-test
&gt;&gt; 	linux-gate.so.1 =&gt;  (0x40022000)
&gt;&gt; 	libhogweed.so.2 =&gt; .lib/libhogweed.so.2 (0x40026000)
&gt;&gt; 	libnettle.so.4 =&gt; .lib/libnettle.so.4 (0x40054000)
&gt;&gt; 	libgmp.so.10 =&gt; /usr/local/lib/libgmp.so.10 (0x40087000)
&gt;&gt; 	libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0x40119000)
&gt;&gt; 	/lib/ld-linux.so.2 (0x40000000)
&gt;&gt; zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$
&gt;&gt; LD_LIBRARY_PATH=.lib:/usr/local/lib ./testsuite/ecc-mul-g-test
&gt;&gt; zaamus@zaamuspc:~/Dependencies/nettle-2.7.1$
&gt; 
&gt; This indicates that your nettle build works fine, if you only get it to
&gt; link with the right libgmp.so file at runtime
&gt; (/usr/local/lib/libgmp.so.10 above).
&gt; 
&gt; Regards,
&gt; /Niels

-- 
Vittorio Francesco Braga
PhD student in Tor Vergata University of Rome
Mobile: +393203753307, Office (PhD room): +390672594868

</body></email><email><emailId>20141124145743</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-11-24 14:57:43-0400</timestampReceived><subject>Re: symbol versioning</subject><body>

On Mon, Nov 24, 2014 at 3:23 PM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wrot=
e:
&gt;&gt; The attached patch will add symbol versioning in nettle. That would
&gt;&gt; mean that software linked against nettle 3.x will be able to
&gt;&gt; interoperate with libraries that are linked on a previous version of
&gt;&gt; nettle (and vice versa).
&gt; Thanks. I take it that solves the soname-related problem you reported
&gt; yesterday? (I hope to be able to respond properly later today).

The yesterday's problem is solved in git where you have bumped the hogweed'=
s
major version number. The problem it is solved by that patch is to software=
 that
due to dependencies is linked to both old and new nettle library versions.

&gt; I think it would be good with some comments in the linker script
&gt; libnettle.map, explaining when and how to update it. E.g., the "3" in
&gt; "NETTLE_3", when should that be updated? Should it always follow the
&gt; soname? If so, maybe we should have a libnettle.map.in and let configure
&gt; substitute the major number.

Done in the current patch. That's the rule I follow.

&gt; How should we handle incompatible changes to internal, undocumented
&gt; functions?

With the version script, nothing that is not prefixed with nettle_ or
_nettle_ is exported.
If you need to export more than that they should be listed in the
version script, possibly
with a different name (e.g, INTERNALS).

&gt; Then I usually bump the minor number only, but not the soname?

In gnutls I change the soname only when API functions are removed, or
API functions are changed.

&gt; Maybe it's impossible or unlikely to get two versions with the
&gt; same soname linked into the same running program, in which case symbol
&gt; versions don't need any finer resolution than the soname?

At least with gnutls in Debian it was actually occurring. There were
libraries linked to gnutls 2.12 and applications to gnutls 3.x.

regards,
Nikos

["0001-Added-symbol-versioning.patch" (text/plain-diff)]

From 3849dcf767b30195089658ee7189ed13f404093b Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Mon, 24 Nov 2014 14:02:25 +0100
Subject: [PATCH] Added symbol versioning

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 .gitignore       |  1 +
 Makefile.in      |  4 ++--
 aclocal.m4       | 57 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 configure.ac     |  4 +++-
 libnettle.map    | 12 ++++++++++++
 libnettle.map.in | 17 +++++++++++++++++
 6 files changed, 92 insertions(+), 3 deletions(-)
 create mode 100644 libnettle.map
 create mode 100644 libnettle.map.in

diff --git a/.gitignore b/.gitignore
index 2b16f4c..d54c65e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -67,3 +67,4 @@ core
 /nettle.tps
 /nettle.vr
 /nettle.vrs
+*.po
diff --git a/Makefile.in b/Makefile.in
index 10a58b0..d23794d 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -244,7 +244,7 @@ libhogweed.a: $(hogweed_OBJS)
 
 # Rules building shared libraries.
 $(LIBNETTLE_FORLINK): $(nettle_OBJS)
-	$(LIBNETTLE_LINK) $(nettle_OBJS) -o $@ $(LIBNETTLE_LIBS)
+	$(LIBNETTLE_LINK) $(nettle_OBJS) @EXTRA_LINKER_FLAGS@ -o $@ $(LIBNETTLE_LIBS)
 	-mkdir .lib 2&gt;/dev/null
 	(cd .lib \
           &amp;&amp; rm -f $(LIBNETTLE_FORLINK) \
@@ -255,7 +255,7 @@ $(LIBNETTLE_FORLINK): $(nettle_OBJS)
 	echo nettle &gt; libnettle.stamp
 
 $(LIBHOGWEED_FORLINK): $(hogweed_OBJS) $(LIBNETTLE_FORLINK)
-	$(LIBHOGWEED_LINK) $(hogweed_OBJS) -o $@ $(LIBHOGWEED_LIBS)
+	$(LIBHOGWEED_LINK) $(hogweed_OBJS) @EXTRA_LINKER_FLAGS@ -o $@ $(LIBHOGWEED_LIBS)
 	-mkdir .lib 2&gt;/dev/null
 	(cd .lib \
           &amp;&amp; rm -f $(LIBHOGWEED_FORLINK) \
diff --git a/aclocal.m4 b/aclocal.m4
index 36daec6..4ac3ba5 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -1211,3 +1211,60 @@ ac_cv_type_int_fast32_t="$ac_cv_type_int_fast32_t"
 ac_cv_type_intmax_t="$ac_cv_type_intmax_t"
 ])
 ])
+
+# ld-version-script.m4 serial 3
+dnl Copyright (C) 2008-2014 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Simon Josefsson
+
+# FIXME: The test below returns a false positive for mingw
+# cross-compiles, 'local:' statements does not reduce number of
+# exported symbols in a DLL.  Use --disable-ld-version-script to work
+# around the problem.
+
+# gl_LD_VERSION_SCRIPT
+# --------------------
+# Check if LD supports linker scripts, and define automake conditional
+# HAVE_LD_VERSION_SCRIPT if so.
+AC_DEFUN([LD_VERSION_SCRIPT],
+[
+  AC_ARG_ENABLE([ld-version-script],
+    AS_HELP_STRING([--enable-ld-version-script],
+      [enable linker version script (default is enabled when possible)]),
+      [have_ld_version_script=$enableval], [])
+  if test -z "$have_ld_version_script"; then
+    AC_MSG_CHECKING([if LD -Wl,--version-script works])
+    save_LDFLAGS="$LDFLAGS"
+    LDFLAGS="$LDFLAGS -Wl,--version-script=conftest.map"
+    cat &gt; conftest.map &lt;&lt;EOF
+foo
+EOF
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
+                   [accepts_syntax_errors=yes], [accepts_syntax_errors=no])
+    if test "$accepts_syntax_errors" = no; then
+      cat &gt; conftest.map &lt;&lt;EOF
+VERS_1 {
+        global: sym;
+};
+
+VERS_2 {
+        global: sym;
+} VERS_1;
+EOF
+      AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
+                     [have_ld_version_script=yes], [have_ld_version_script=no])
+    else
+      have_ld_version_script=no
+    fi
+    rm -f conftest.map
+    LDFLAGS="$save_LDFLAGS"
+    AC_MSG_RESULT($have_ld_version_script)
+  fi
+  if test "$have_ld_version_script" = "yes";then
+	EXTRA_LINKER_FLAGS="-Wl,--version-script=\$(srcdir)/libnettle.map"
+	AC_SUBST(EXTRA_LINKER_FLAGS)
+  fi
+])
diff --git a/configure.ac b/configure.ac
index bb33962..9465c34 100644
--- a/configure.ac
+++ b/configure.ac
@@ -114,6 +114,8 @@ AC_TRY_COMPILE([],[return 0;],[IF_CXX=''], [IF_CXX='#'])
 AC_SUBST([IF_CXX])
 AC_LANG_POP
 
+LD_VERSION_SCRIPT
+
 AC_PROG_MAKE_SET
 AC_PROG_RANLIB
 AC_CHECK_TOOL(NM, nm, strings)
@@ -843,7 +845,7 @@ fi
 
 AC_CONFIG_FILES([config.make config.m4 Makefile bignum.h])
 AC_CONFIG_FILES([tools/Makefile testsuite/Makefile examples/Makefile])
-AC_CONFIG_FILES([nettle.pc hogweed.pc])
+AC_CONFIG_FILES([nettle.pc hogweed.pc libnettle.map])
 
 AC_OUTPUT
 
diff --git a/libnettle.map b/libnettle.map
new file mode 100644
index 0000000..4598e6f
--- /dev/null
+++ b/libnettle.map
@@ -0,0 +1,12 @@
+# libnettle.map -- libnettle linker version script.           -*- ld-script -*-
+
+NETTLE_5
+{
+  global:
+    nettle_*;
+    _nettle_*;
+
+  local:
+    *;
+};
+
diff --git a/libnettle.map.in b/libnettle.map.in
new file mode 100644
index 0000000..02455bc
--- /dev/null
+++ b/libnettle.map.in
@@ -0,0 +1,17 @@
+# libnettle.map -- libnettle linker version script.           -*- ld-script -*-
+
+#
+# The symbol version must be updated on every nettle
+# library major number change. That is taken care by
+# auto-generating the file.
+
+NETTLE_@LIBNETTLE_MAJOR@
+{
+  global:
+    nettle_*;
+    _nettle_*;
+
+  local:
+    *;
+};
+
-- 
1.9.3



</body></email><email><emailId>20141125071036</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-11-25 07:10:36-0400</timestampReceived><subject>Re: gcm + encrypt_message</subject><body>

On Mon, 2014-11-24 at 22:54 +0100, Niels Möller wrote:

&gt; And then one could write trivial wrappers like
&gt; gcm_aes128_encrypt_message just passing in the right aead object.

It looks reasonable.

&gt; That should be almost compatible with the ccm_*_message functions,
&gt; except that ccm allows arbitrary nonce-size, and the nettle_aead
&gt; interface uses a fixed nonce size. Which is an undesirable mismatch, not
&gt; sure how to best deal with that.

GCM-AES also uses an arbitrary IV size so I think that expressing the
nonce with the length in the generic interface makes sense. For modes
that may not allow an arbitrary nonce the interface could still return
an error code.

regards,
Nikos



</body></email><email><emailId>20141128193218</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-11-28 19:32:18-0400</timestampReceived><subject>Re: issues found while converting from 2.7 to 3.0</subject><body>

On Fri, 2014-11-28 at 19:35 +0100, Niels Möller wrote:

&gt; &gt; --- a/.gitignore
&gt; &gt; +++ b/.gitignore
&gt; &gt; @@ -67,3 +67,6 @@ core
&gt; &gt;  /nettle.tps
&gt; &gt;  /nettle.vr
&gt; &gt;  /nettle.vrs
&gt; &gt; +*.po
&gt; &gt; +/libhogweed.map
&gt; &gt; +/libnettle.map
&gt; I take it adding *.po is not really intended? These files were
&gt; eliminated a while ago.

Indeed, they must be leftovers from old builds in my repository.

&gt; It would in some way be cleaner to have this nettle-specific setup in
&gt; configure.ac, rather than in aclocal.m4. Maybe the macro could have an
&gt; optional if-true argument? Or one could just move the test of
&gt; have_ld_version_script.

I didn't make that macro, it was copied from gnulib. Changing the
interface would mean that the one who may need to update it with a newer
version would have to do quite some porting.

regards,
Nikos



</body></email><email><emailId>20141022074432</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-10-22 07:44:32-0400</timestampReceived><subject>Re: eddsa progress</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Now I have an initial implementation of some friendlier high-level
&gt; functions for ed25519-sha512 signatures.

Pushed now. 

&gt; I have a test program that can process
&gt; http://ed25519.cr.yp.to/python/sign.input successfully. But that input
&gt; file is a bit large (2.4M, or 670K after lzip --best), so I hesitate
&gt; before just including a copy of it in the testsuite directory.

Also added, as testsuite/ed25519-test.c. By default, it uses just the
first four lines (copied into the source file). But if
ED25519_SIGN_INPUT is set in the environment, it will open and process
that file instead.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141022103022</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-10-22 10:30:22-0400</timestampReceived><subject>Re: Fat binaries</subject><body>

On Wed, Oct 22, 2014 at 10:03 AM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wro=
te:
&gt; I think I will leave the curve25519 and eddsa code for now, even though
&gt; there are several important optimizations left to do (see the just
&gt; updated http://www.lysator.liu.se/~nisse/nettle/plan.html).
&gt; I think it's getting time to do fat binaries. To make progress, I think
&gt; it's best to start with something simple, relying on
&gt; __attribute__((constructor) and/or __attribute__(ifunc ...)).
&gt; For the case of memxor (where on x86_64, the fat binary mechanism needs
&gt; to select between sse2 and non-sse2 code), I'm also considering some
&gt; reorganization:
&gt;  * Use smaller assembly routines doing one case each, and let the main
&gt;    entry point always be C code which can sort out the different cases
&gt;    and handle bytes at the beginning and end of the buffer.
&gt;  * Fix the cases where the current current code reads a few bytes
&gt;    outside of input buffers (but luckily without crossing word
&gt;    boundaries, iirc).
&gt;  * Add some internal entry points, for cases where alignment is known by
&gt;    the caller.

That would really be great news, and would be a very good incentive to
port gnutls to nettle
3.x. If I could add to that list, I think that simplicity of 3rd party
enhancements to that fat binary
is also significant, as I believe you'd like to rely on others doing
these optimizations for their
CPU types.

regards,
Nikos

</body></email><email><emailId>20141029131709</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-10-29 13:17:09-0400</timestampReceived><subject>Side-channel silence</subject><body>

I've written a simple program to setup valgrind to check for bad uses of
secret data. Maybe you have heard of Adam Langley's ctgrind
(https://github.com/agl/ctgrind), but it seems to work fine to use plain
valgrind and mark the secret data with VALGRIND_MAKE_MEM_UNDEFINED.

Non-silent algorithms include aes, camellia, cast128, twofish, arctwo, des,
blowfish, gcm (the hashing), arcfour. Almost anything using sboxes.

Silent algorithms include serpent (sboxes, but with nice bit-slicing
instead of tables), salsa20, chacha, poly1305.

Not sure if and how this testing could be added to a plain

  make check EMULATOR='$(VALGRIND)'

As for AES, an implementations using the aesni instructions ought to be
side-channel silent. And if one is concerned about side channel attacks
on AES, but too conservative to jump to salsa20 or chacha, serpent might
be a good alternative.

(I'll be doing a short talk on side-channel attacks on Southpole's 15
year anniversary party on November 7, so that's why I'm looking into
this now).

Regards,
/Niels

-----8&lt;---
/* cipher-sidechannel-test.c

   Copyright (C) 2014 Niels MÃ¶ller

   This file is part of GNU Nettle.

   GNU Nettle is free software: you can redistribute it and/or
   modify it under the terms of either:

     * the GNU Lesser General Public License as published by the Free
       Software Foundation; either version 3 of the License, or (at your
       option) any later version.

   or

     * the GNU General Public License as published by the Free
       Software Foundation; either version 2 of the License, or (at your
       option) any later version.

   or both in parallel, as here.

   GNU Nettle is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received copies of the GNU General Public License and
   the GNU Lesser General Public License along with this program.  If
   not, see http://www.gnu.org/licenses/.
*/

#include "testutils.h"
#include "nettle-internal.h"

#if !HAVE_VALGRIND_MEMCHECK_H
void testmain (void)
{
  SKIP ();
}
#else /* HAVE_VALGRIND_MEMCHECK_H */
#include &lt;valgrind/memcheck.h&gt;

static uint8_t *
xalloc_secret (size_t size)
{
  uint8_t *p = xalloc (size);
  memset (p, 0, size);
  VALGRIND_MAKE_MEM_UNDEFINED (p, size);
  return p;
}

static void 
test_sc_cipher (const struct nettle_cipher *cipher)
{
  void *ctx;
  uint8_t *key;
  uint8_t *src;
  uint8_t *dst;
  ctx = xalloc (cipher-&gt;context_size);
  key = xalloc_secret (cipher-&gt;key_size);
  src = xalloc_secret (cipher-&gt;block_size);
  dst = xalloc (cipher-&gt;block_size);

  cipher-&gt;set_encrypt_key (ctx, key);
  cipher-&gt;encrypt (ctx, cipher-&gt;block_size, dst, src);
  
  free (ctx);
  free (key);
  free (src);
  free (dst);
}

#define DATA_SIZE 32
static void
test_sc_aead (const struct nettle_aead *aead)
{
  void *ctx;
  uint8_t *key;
  uint8_t *nonce;
  uint8_t *src;
  uint8_t *data;
  uint8_t *dst;
  uint8_t *digest;

  ctx = xalloc (aead-&gt;context_size);
  key = xalloc_secret (aead-&gt;key_size);
  nonce = xalloc_secret (aead-&gt;nonce_size);
  src = xalloc_secret (aead-&gt;block_size);
  data = xalloc_secret (DATA_SIZE);
  dst = xalloc (aead-&gt;block_size);
  digest = xalloc (aead-&gt;digest_size);

  aead-&gt;set_encrypt_key (ctx, key);
  if (aead-&gt;set_nonce)
    aead-&gt;set_nonce (ctx, nonce);
  if (aead-&gt;update)
    aead-&gt;update (ctx, DATA_SIZE, data);
  aead-&gt;encrypt (ctx, aead-&gt;block_size, dst, src);
  if (aead-&gt;update)
    aead-&gt;digest (ctx, aead-&gt;digest_size, digest);

  free (ctx);
  free (key);
  free (nonce);
  free (src);
  free (data);
  free (dst);
  free (digest);
}

static const struct nettle_cipher *
other_ciphers[] = {
  &amp;nettle_des,
  &amp;nettle_des3,
  &amp;nettle_blowfish128,
  NULL,
};

static const struct nettle_aead *
other_aeads[] = {
  &amp;nettle_arcfour128,
  &amp;nettle_chacha,
  &amp;nettle_salsa20,
  &amp;nettle_salsa20r12,
  NULL,
};


void
test_main (void)
{
  unsigned i;
  const struct nettle_cipher *cipher;
  const struct nettle_aead *aead;
  for (i = 0; ((cipher = nettle_ciphers[i])); i++)
    test_sc_cipher (cipher);

  for (i = 0; ((cipher = other_ciphers[i])); i++)
    test_sc_cipher (cipher);

  for (i = 0; ((aead = nettle_aeads[i])); i++)
    test_sc_aead (aead);

  for (i = 0; ((aead = other_aeads[i])); i++)
    test_sc_aead (aead);
}

#endif /* HAVE_VALGRIND_MEMCHECK_H */

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20141031162547</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-10-31 16:25:47-0400</timestampReceived><subject>Re: chacha-poly1305</subject><body>

James Cloos &lt;cloos@jhcloos.com&gt; writes:

&gt; I expect additional users to ignore that draft and use chacha as it was
&gt; intended.

For plain chacha, I totally agree. Question is about the chacha-poly1305
construction.

But it shouldn't be too painful to support two nonce-sizes, as long as
that's the only difference.

Regards,
/Niels


-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20140924191041</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-09-24 19:10:41-0400</timestampReceived><subject>ecc_curve and ecc_modulo</subject><body>

I just pushed some reorganization of the ecc code. It introduces an
internal struct ecc_modulo, which keeps the data and function pointers
needed for modulo p (or modulo q) arithmetic.

Immediate benefit was that a couple of wrapper functions could be
deleted. E.g, ecc_generic_modp and ecc_generic_modq both called ecc_mod,
but with different constants taken from different fields of struct
ecc_curve). Now, one can instead call ecc_mod (&amp;ecc-&gt;p, ...) and
ecc_mod(&amp;ecc-&gt;q, ...), respectively.

I also added an invert function pointer, and wrote a specialized modp
invert function for curve25519, which gives a nice little speedup. The
code can be shared with sqrt, since the main part of the addition chain
is the same for p-2 = 2^{255} - 21 (for invert) and (p-5)/8 = 2^{252} -
3 (for sqrt). Similar functions for the secp curves also make sense, at
least for the mod p inversion; modq is less structured.

The plan is to expand struct ecc_modulo with add, mul and sqr function
pointers, to make it possible to have a different internal
representation. In particular, using radix-51 for curve25519 modp
arithmetic, on 64-bit machines.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20140924191455</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-09-24 19:14:55-0400</timestampReceived><subject>Re: eddsa progress</subject><body>

I've still looking at eddsa, and how to design the interface. I think we
need some structs ed25519_sha512_private_key and ed25519_sha512_public_key,
which can keep track of "expanded" keys. And a low-level function,
possibly like

  void
  _eddsa_sign (const struct ecc_curve *ecc,
               const struct nettle_hash *H,
               const uint8_t *pub,
               void *k1,
               const mp_limb_t *k2,
               size_t length,
               const uint8_t *msg,
               uint8_t *signature);

where

  ecc is the curve,

  H the hash function,

  pub is the public key as a string (I don't quite like it, but it is
  needed in the hashing, and it seems inefficient to have to recompute
  it from the private key)

  k1 is a context struct for the hashing, updated with the secret
  prefix. And destroyed in the process, so if the caller want's to sing
  several messages, it should keep a copy. 

  k2 is the secret scalar

The output is produced as a string, not a pair of bignums, since that's
how eddsa is specified.

It's possible to also have an all-in-one functions, say,

  ed25519_sha512_sign (const uint8_t *key,
  		       size_t length, const uint8_t *msg,
                       uint8_t *signature);

One thing that's a bit unclear is in which form applications will store
private keys. Will they be *only* the private key (256 bits, according
to the spec), or will they be kept together with the public key? If the
public key is not included, it has to be recomputed (which will be
pretty fast, but I think it's desirable to do it once, when the key is
read, not for each signature created). It could be an optional input
somewhere in the interface.

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20141206083009</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-12-06 08:30:09-0400</timestampReceived><subject>function casts</subject><body>

It seems that in the GCM macros nettle uses casts to functions. That is
pretty dangerous with the changes of parameters in functions in nettle
3. The issue is the compiler will not warn for serious errors such as
different function type. An example macro is GCM_ENCRYPT.

#define GCM_ENCRYPT(ctx, encrypt, length, dst, src)                   \
  (0 ? (encrypt)(&amp;(ctx)-&gt;cipher, 0, (void *)0, (void *)0)             \
     : gcm_encrypt(&amp;(ctx)-&gt;gcm, &amp;(ctx)-&gt;key, &amp;(ctx)-&gt;cipher,          \
                   (nettle_cipher_func *) (encrypt),                  \
                   (length), (dst), (src)))

I don't think that nettle should be casting functions. The issue seems
to be present in ctr, eax and cbc modes as well.

regards,
Nikos



</body></email><email><emailId>20141206085929</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-12-06 08:59:29-0400</timestampReceived><subject>Re: function casts</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; That is
&gt; pretty dangerous with the changes of parameters in functions in nettle
&gt; 3. The issue is the compiler will not warn for serious errors such as
&gt; different function type. An example macro is GCM_ENCRYPT.
&gt;
&gt; #define GCM_ENCRYPT(ctx, encrypt, length, dst, src)                   \
&gt;   (0 ? (encrypt)(&amp;(ctx)-&gt;cipher, 0, (void *)0, (void *)0)             \
&gt;      : gcm_encrypt(&amp;(ctx)-&gt;gcm, &amp;(ctx)-&gt;key, &amp;(ctx)-&gt;cipher,          \
&gt;                    (nettle_cipher_func *) (encrypt),                  \
&gt;                    (length), (dst), (src)))

The idea of this macro is that

1. It should be possible to pass a context with the cipher element typed
   as a struct aes128_ctx, and encrypt as the function aes128_encrypt,
   without errors or warnings. To have the cast in one place, instead of
   sprinkled throughout application code.

2. The expression after the 0 ? should give some additional
   typechecking, so that, e.g, having a ctx-&gt;cipher of type aes128_ctx
   and encrypt as the function camellia128_crypt, you will get a warning
   from the compiler about bad first argument to camellia128_crypt.

If you pass an encrypt function of type nettle_cipher_func (with a const
void *) first argument, you get less type checking, but at least you
should get a check on number of arguments, and integers vs pointers.

Can you give an example usage where you'd want to get a compiler
warning, but you don't get one?

BTW, a minor improvement to type checking would be to change the (void*)
0 expressions above to (uint8_t *) 0 and (const uint8_t *) 0.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141206110700</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-12-06 11:07:00-0400</timestampReceived><subject>Re: function casts</subject><body>

On Sat, 2014-12-06 at 09:59 +0100, Niels Möller wrote:

&gt; The idea of this macro is that
&gt; 
&gt; 1. It should be possible to pass a context with the cipher element typed
&gt;    as a struct aes128_ctx, and encrypt as the function aes128_encrypt,
&gt;    without errors or warnings. To have the cast in one place, instead of
&gt;    sprinkled throughout application code.
&gt; 
&gt; 2. The expression after the 0 ? should give some additional
&gt;    typechecking, so that, e.g, having a ctx-&gt;cipher of type aes128_ctx
&gt;    and encrypt as the function camellia128_crypt, you will get a warning
&gt;    from the compiler about bad first argument to camellia128_crypt.
&gt; 
&gt; If you pass an encrypt function of type nettle_cipher_func (with a const
&gt; void *) first argument, you get less type checking, but at least you
&gt; should get a check on number of arguments, and integers vs pointers.

In modern compilers you cannot rely on that. The constructions if(0){}
and other impossible situations are optimized out early.

&gt; Can you give an example usage where you'd want to get a compiler
&gt; warning, but you don't get one?

The change of the cipher_func to accept a size_t instead of unsigned. 
https://gitorious.org/gnutls/gnutls/commit/488cfe9a57840faeb2e35250757d8d33da32064f

regards,
Nikos





</body></email><email><emailId>20141206210123</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-12-06 21:01:23-0400</timestampReceived><subject>Re: function casts</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; In modern compilers you cannot rely on that. The constructions if(0){}
&gt; and other impossible situations are optimized out early.

Examples? I would expect any serious C compiler to do basic type
checking of dead code (even if I don't expect to get all warnings
generated by optimization passes, i.e., the warnings you normally get
only if you compile with -O). If gcc stopped doing type checking on dead
code, I would likely file a bug report.

&gt;&gt; Can you give an example usage where you'd want to get a compiler
&gt;&gt; warning, but you don't get one?
&gt;
&gt; The change of the cipher_func to accept a size_t instead of unsigned. 
&gt; https://gitorious.org/gnutls/gnutls/commit/488cfe9a57840faeb2e35250757d8d33da32064f

Hmm. In that case, I'd recommend declaring the function as

  static nettle_cipher_func padock_aes_encrypt;

(or with nettle_crypt_func, before the introduction of
nettle_cipher_func). Then you would have gotten a warning for mismatch
between declaration and definition, when that type was changed. But
that's of little help now, I guess.

What do you suggest to do with the nettle macros? They are intended for
use with the various _CTX() macros, and for that purpose, I think the
current definitions with casts and all are adequate, so I'd prefer to
not simply delete the cast.

We could add additional macros, say

   #define GCM_ENCRYPT_NO_CAST(ctx, encrypt, length, dst, src)         \
        gcm_encrypt(&amp;(ctx)-&gt;gcm, &amp;(ctx)-&gt;key, &amp;(ctx)-&gt;cipher,          \
                    (encrypt), (length), (dst), (src))

Question is, does that solve a real problem? My initial feeling is that
when there's nothing "magic" left inside the macro, using it provides
little benefit; code would likely be clearer by calling gcm_encrypt
directly. What do you think?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141207091020</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-12-07 09:10:20-0400</timestampReceived><subject>Re: function casts</subject><body>

On Sat, 2014-12-06 at 22:01 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt; &gt; In modern compilers you cannot rely on that. The constructions if(0){}
&gt; &gt; and other impossible situations are optimized out early.
&gt; 
&gt; Examples? I would expect any serious C compiler to do basic type
&gt; checking of dead code (even if I don't expect to get all warnings
&gt; generated by optimization passes, i.e., the warnings you normally get
&gt; only if you compile with -O). If gcc stopped doing type checking on dead
&gt; code, I would likely file a bug report.

An example that would compile and run perfectly on modern gcc is:
#include &lt;stdio.h&gt;
int main()
{
	if (0) {
		call_this_unknown_function();
	} else {
		printf("hello\n");
	}
}

but indeed, while it skips undefined functions, it still performs type
checking on the known ones.

&gt; What do you suggest to do with the nettle macros? They are intended for
&gt; use with the various _CTX() macros, and for that purpose, I think the
&gt; current definitions with casts and all are adequate, so I'd prefer to
&gt; not simply delete the cast.

What is the purpose of the cast? Isn't the macro supposed to have a
function pointer input? If yes, I don't see the cast purpose, while I
see the issues that it can cause. Yes I could have used the function,
but I did use the macro which was part of the API, and should be treated
as such.

&gt; Question is, does that solve a real problem? 

What do you mean by that? I sent a real issue on the previous mail. A
problem that would have been very hard to notice and debug. When the API
and ABI are changed it is best to let the compiler warn of these changes
and not hide them under casts.

regards,
Nikos



</body></email><email><emailId>20141207125036</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-12-07 12:50:36-0400</timestampReceived><subject>Re: function casts</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; What is the purpose of the cast? Isn't the macro supposed to have a
&gt; function pointer input?

It's supposed to get a function pointer, but not necessarily of exactly
the type nettle_cipher_func. The idea is that applications should be
able to do

  struct GCM_CTX(struct aes128_ctx) ctx;
  ...
  GCM_ENCRYPT(&amp;ctx, aes128_encrypt, ...)

without compiler warnings and without manually casting aes128_encrypt to
(nettle_cipher_func *). The main purpose of these convenience macros is
to do the needed cast to (nettle_cipher_func *), and bundle that cast
together with a little extra typechecking. 

&gt;&gt; Question is, does that solve a real problem? 
&gt;
&gt; What do you mean by that?

If one prefers to not have that cast, one can call always call
gcm_encrypt directly; GCM_ENCRYPT is an optional feature.

So my question is, do you think it would make your code easier to read
and debug, if nettle provided a simple non-magic wrapper macro around
gcm_encrypt (in addition to the current GCM_ENCRYPT macro which you find
questionable), or would it be clearer to call gcm_encrypt directly?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141124130610</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-11-24 13:06:10-0400</timestampReceived><subject>symbol versioning</subject><body>

The attached patch will add symbol versioning in nettle. That would
mean that software linked against nettle 3.x will be able to
interoperate with libraries that are linked on a previous version of
nettle (and vice versa).

You could check the new symbol names with "readelf -Ws libnettle.so"

regards,
Nikos

["0001-Added-symbol-versioning.patch" (text/plain-diff)]

From 45adca1f634b9c3b85784b56411eeecab6113be6 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Mon, 24 Nov 2014 14:02:25 +0100
Subject: [PATCH] Added symbol versioning

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 Makefile.in   |  6 +++---
 aclocal.m4    | 57 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 configure.ac  |  2 ++
 libnettle.map | 12 ++++++++++++
 5 files changed, 75 insertions(+), 3 deletions(-)
 create mode 100644 libnettle.map

diff --git a/Makefile.in b/Makefile.in
index 10a58b0..afd011f 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -218,7 +218,7 @@ DISTFILES = $(SOURCES) $(HEADERS) getopt.h getopt_int.h \
 	cast128_sboxes.h desinfo.h desCode.h \
 	nettle-internal.h nettle-write.h \
 	gmp-glue.h ecc-internal.h \
-	mini-gmp.h mini-gmp.c asm.m4 \
+	mini-gmp.h mini-gmp.c asm.m4 ld-version-script.m4 \
 	nettle.texinfo nettle.info nettle.html nettle.pdf sha-example.c
 
 # Rules building static libraries
@@ -244,7 +244,7 @@ libhogweed.a: $(hogweed_OBJS)
 
 # Rules building shared libraries.
 $(LIBNETTLE_FORLINK): $(nettle_OBJS)
-	$(LIBNETTLE_LINK) $(nettle_OBJS) -o $@ $(LIBNETTLE_LIBS)
+	$(LIBNETTLE_LINK) $(nettle_OBJS) @EXTRA_LINKER_FLAGS@ -o $@ $(LIBNETTLE_LIBS)
 	-mkdir .lib 2&gt;/dev/null
 	(cd .lib \
           &amp;&amp; rm -f $(LIBNETTLE_FORLINK) \
@@ -255,7 +255,7 @@ $(LIBNETTLE_FORLINK): $(nettle_OBJS)
 	echo nettle &gt; libnettle.stamp
 
 $(LIBHOGWEED_FORLINK): $(hogweed_OBJS) $(LIBNETTLE_FORLINK)
-	$(LIBHOGWEED_LINK) $(hogweed_OBJS) -o $@ $(LIBHOGWEED_LIBS)
+	$(LIBHOGWEED_LINK) $(hogweed_OBJS) @EXTRA_LINKER_FLAGS@ -o $@ $(LIBHOGWEED_LIBS)
 	-mkdir .lib 2&gt;/dev/null
 	(cd .lib \
           &amp;&amp; rm -f $(LIBHOGWEED_FORLINK) \
diff --git a/aclocal.m4 b/aclocal.m4
index 36daec6..4ac3ba5 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -1211,3 +1211,60 @@ ac_cv_type_int_fast32_t="$ac_cv_type_int_fast32_t"
 ac_cv_type_intmax_t="$ac_cv_type_intmax_t"
 ])
 ])
+
+# ld-version-script.m4 serial 3
+dnl Copyright (C) 2008-2014 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Simon Josefsson
+
+# FIXME: The test below returns a false positive for mingw
+# cross-compiles, 'local:' statements does not reduce number of
+# exported symbols in a DLL.  Use --disable-ld-version-script to work
+# around the problem.
+
+# gl_LD_VERSION_SCRIPT
+# --------------------
+# Check if LD supports linker scripts, and define automake conditional
+# HAVE_LD_VERSION_SCRIPT if so.
+AC_DEFUN([LD_VERSION_SCRIPT],
+[
+  AC_ARG_ENABLE([ld-version-script],
+    AS_HELP_STRING([--enable-ld-version-script],
+      [enable linker version script (default is enabled when possible)]),
+      [have_ld_version_script=$enableval], [])
+  if test -z "$have_ld_version_script"; then
+    AC_MSG_CHECKING([if LD -Wl,--version-script works])
+    save_LDFLAGS="$LDFLAGS"
+    LDFLAGS="$LDFLAGS -Wl,--version-script=conftest.map"
+    cat &gt; conftest.map &lt;&lt;EOF
+foo
+EOF
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
+                   [accepts_syntax_errors=yes], [accepts_syntax_errors=no])
+    if test "$accepts_syntax_errors" = no; then
+      cat &gt; conftest.map &lt;&lt;EOF
+VERS_1 {
+        global: sym;
+};
+
+VERS_2 {
+        global: sym;
+} VERS_1;
+EOF
+      AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
+                     [have_ld_version_script=yes], [have_ld_version_script=no])
+    else
+      have_ld_version_script=no
+    fi
+    rm -f conftest.map
+    LDFLAGS="$save_LDFLAGS"
+    AC_MSG_RESULT($have_ld_version_script)
+  fi
+  if test "$have_ld_version_script" = "yes";then
+	EXTRA_LINKER_FLAGS="-Wl,--version-script=\$(srcdir)/libnettle.map"
+	AC_SUBST(EXTRA_LINKER_FLAGS)
+  fi
+])
diff --git a/configure.ac b/configure.ac
index bb33962..46fa312 100644
--- a/configure.ac
+++ b/configure.ac
@@ -114,6 +114,8 @@ AC_TRY_COMPILE([],[return 0;],[IF_CXX=''], [IF_CXX='#'])
 AC_SUBST([IF_CXX])
 AC_LANG_POP
 
+LD_VERSION_SCRIPT
+
 AC_PROG_MAKE_SET
 AC_PROG_RANLIB
 AC_CHECK_TOOL(NM, nm, strings)
diff --git a/libnettle.map b/libnettle.map
new file mode 100644
index 0000000..c1c7394
--- /dev/null
+++ b/libnettle.map
@@ -0,0 +1,12 @@
+# libnettle.map -- libnettle linker version script.           -*- ld-script -*-
+
+NETTLE_3
+{
+  global:
+    nettle_*;
+    _nettle_*;
+
+  local:
+    *;
+};
+
-- 
1.9.3



</body></email><email><emailId>20141124142304</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-11-24 14:23:04-0400</timestampReceived><subject>Re: symbol versioning</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; The attached patch will add symbol versioning in nettle. That would
&gt; mean that software linked against nettle 3.x will be able to
&gt; interoperate with libraries that are linked on a previous version of
&gt; nettle (and vice versa).

Thanks. I take it that solves the soname-related problem you reported
yesterday? (I hope to be able to respond properly later today).

I think it would be good with some comments in the linker script
libnettle.map, explaining when and how to update it. E.g., the "3" in
"NETTLE_3", when should that be updated? Should it always follow the
soname? If so, maybe we should have a libnettle.map.in and let configure
substitute the major number.

How should we handle incompatible changes to internal, undocumented
functions? Then I usually bump the minor number only, but not the soname?
Maybe it's impossible or unlikely to get two versions with the
same soname linked into the same running program, in which case symbol
versions don't need any finer resolution than the soname?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141124141429</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>n.mavrogiannopoulos@gmail.com</senderEmail><timestampReceived>2014-11-24 14:14:29-0400</timestampReceived><subject>gcm + encrypt_message</subject><body>

I am trying to figure out how to wrap around CCM and GCM, and it seems
like a hard task. They are totally incompatible. Would it make sense
instead of have an equivalent of ccm_decrypt_message() in gcm as well,
and make that the AEAD API?

regards,
Nikos

</body></email><email><emailId>20141124215429</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-11-24 21:54:29-0400</timestampReceived><subject>Re: gcm + encrypt_message</subject><body>

Nikos Mavrogiannopoulos &lt;n.mavrogiannopoulos@gmail.com&gt; writes:

&gt; I am trying to figure out how to wrap around CCM and GCM, and it seems
&gt; like a hard task. They are totally incompatible.

Right, ccm is a bit alien, in that it doesn't support any incremental
operation.

&gt; Would it make sense
&gt; instead of have an equivalent of ccm_decrypt_message() in gcm as well,
&gt; and make that the AEAD API?

To get _message functions, I'd like to define some functions (or even
macros?) like

void
aead_encrypt_message(const struct nettle_aead *aead,
		     void *ctx,
		     const uint8_t *nonce,
		     size_t alength, const uint8_t *adata,
		     size_t tlength,
		     size_t clength, uint8_t *dst, const uint8_t *src);

int
aead_decrypt_message(const struct nettle_aead *aead,
		     void *ctx,
		     const uint8_t *nonce,
		     size_t alength, const uint8_t *adata,
		     size_t tlength,
		     size_t mlength, uint8_t *dst, const uint8_t *src);

And then one could write trivial wrappers like
gcm_aes128_encrypt_message just passing in the right aead object.

That should be almost compatible with the ccm_*_message functions,
except that ccm allows arbitrary nonce-size, and the nettle_aead
interface uses a fixed nonce size. Which is an undesirable mismatch, not
sure how to best deal with that.

Do you think that's a reasonable approach?

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141123215815</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-11-23 21:58:15-0400</timestampReceived><subject>issues found while converting from 2.7 to 3.0</subject><body>

Hello,

* gcm.h:

The GCM_SET_KEY macro uses key both as input and to access a ctx
element, and thus requires the last parameter to be called "key" as
well.

#define GCM_SET_KEY(ctx, set_key, encrypt, key)                 \
  do {                                                          \
    (set_key)(&amp;(ctx)-&gt;cipher, (key));                           \
    if (0) (encrypt)(&amp;(ctx)-&gt;cipher, 0, (void *)0, (void *)0);  \
    gcm_set_key(&amp;(ctx)-&gt;key, &amp;(ctx)-&gt;cipher,                    \
                (nettle_cipher_func *) (encrypt));              \
  } while (0)


* cbc.h:
cbc_encrypt and decrypt use const void* as first parameter. That is, it
cannot be wrapped over a function that works for cbc_encrypt as well as
gcm_aes_encrypt (the latter doesn't use const). Without casts that is.

Overall, what I didn't like it that the new cipher API required more
code to wrap around it.

* macros.h:
The MD_INCR(ctx) macro is now only applicable for sha512.

* nettle-types.h:
There is still nettle_crypt_func which is identical to
nettle_cipher_func. Is that intentional? I was wondering what was its
use.

* dsa_verify()
Note sure if this is a regression, but this function will now succeed
verifying data signed with a DSA-2048 key and SHA1 as hash.

* libhogweed soname:
libhogweed has the same soname with 2.7.1, so applications crash if they
are linked against nettle 2.7.1 and 3.0 is installed (that is because
hogweed links against libnettle.so.5). It may make sense for both
libraries to share the same so version.

regards,
Nikos



</body></email><email><emailId>20141124203957</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-11-24 20:39:57-0400</timestampReceived><subject>Re: issues found while converting from 2.7 to 3.0</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

Thanks for the comments.

&gt; * gcm.h:
&gt;
&gt; The GCM_SET_KEY macro uses key both as input and to access a ctx
&gt; element, and thus requires the last parameter to be called "key" as
&gt; well.
&gt;
&gt; #define GCM_SET_KEY(ctx, set_key, encrypt, key)                 \
&gt;   do {                                                          \
&gt;     (set_key)(&amp;(ctx)-&gt;cipher, (key));                           \
&gt;     if (0) (encrypt)(&amp;(ctx)-&gt;cipher, 0, (void *)0, (void *)0);  \
&gt;     gcm_set_key(&amp;(ctx)-&gt;key, &amp;(ctx)-&gt;cipher,                    \
&gt;                 (nettle_cipher_func *) (encrypt));              \
&gt;   } while (0)

Fixed, good catch. I renamed the macro argument to gcm_key.

&gt; * cbc.h:
&gt; cbc_encrypt and decrypt use const void* as first parameter. That is, it
&gt; cannot be wrapped over a function that works for cbc_encrypt as well as
&gt; gcm_aes_encrypt (the latter doesn't use const). Without casts that is.
&gt;
&gt; Overall, what I didn't like it that the new cipher API required more
&gt; code to wrap around it.

Can you give some example of what you're doing?

gcm_encrypt uses const void * and nettle_cipher_func, just like
cbc_encrypt.

While the struct gcm_aes_ctx contains both the aes key (constant after
key schedule) and per message state, and hence has to be non-const. And
it's not much different to if you use

  struct cbc_aes_ctx CBC_CTX(struct aes_ctx, AES_BLOCK_SIZE);

&gt; * macros.h:
&gt; The MD_INCR(ctx) macro is now only applicable for sha512.

For hashes where the count is stored in a scalar variable (typically an
uint64_t), you should use "ctx-&gt;count++" instead of MD_INCR (ctx). I
didn't see any need for a macro for that.

&gt; * nettle-types.h:
&gt; There is still nettle_crypt_func which is identical to
&gt; nettle_cipher_func. Is that intentional? I was wondering what was its
&gt; use.

The differ in const-ness... The idea is that nettle_cipher_func is for
block ciphers where encrypt and decrypt doesn't change the cipher state.
nettle_crypt_func is used for stateful operations, such as
stream-ciphers and aead constructions.

&gt; * dsa_verify()
&gt; Note sure if this is a regression, but this function will now succeed
&gt; verifying data signed with a DSA-2048 key and SHA1 as hash.

Right, one can use dsa (and ecdsa) with any hash function, with
arbitrary digest size. I think that's according to spec (even if not all
combinations are recommended or make sense).

&gt; * libhogweed soname:
&gt; libhogweed has the same soname with 2.7.1, so applications crash if they
&gt; are linked against nettle 2.7.1 and 3.0 is installed (that is because
&gt; hogweed links against libnettle.so.5).

He intention was that nettle-2.7.1 uses the sonames "libnettle.so.4" and
"libhogweed.so.2", and that nettle-3.0 bumped both numbers, to
libnettle.s0.5 and libhogweed.so.3. Was that somehow messed up in the
release?

As far as I understand, the versions symbols thing should help. I guess
sonames have to be bumped again when version symbols are introduced?

&gt; It may make sense for both libraries to share the same so version.

I think it is likely that there maybe incompatible changes affecting
only nettle or only hogweed. So I think it's best to keep them
independent.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141124211015</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-11-24 21:10:15-0400</timestampReceived><subject>Re: issues found while converting from 2.7 to 3.0</subject><body>

On Mon, 2014-11-24 at 21:39 +0100, Niels Möller wrote:

&gt; &gt; * cbc.h:
&gt; &gt; cbc_encrypt and decrypt use const void* as first parameter. That is, it
&gt; &gt; cannot be wrapped over a function that works for cbc_encrypt as well as
&gt; &gt; gcm_aes_encrypt (the latter doesn't use const). Without casts that is.
&gt; &gt;
&gt; &gt; Overall, what I didn't like it that the new cipher API required more
&gt; &gt; code to wrap around it.
&gt; Can you give some example of what you're doing?

I provide an API such as:
ctx=cipher_init(cipherno, key)
cipher_encrypt(ctx, data)
cipher_decrypt(ctx, data)
cipher_deinit()

So within the cipher_init I am using a big switch() to the various
algorithms. With the split I need more switch cases for the different
algorithms (camellia128,camellia192,camellia256) rather than one for
camellia.

&gt; gcm_encrypt uses const void * and nettle_cipher_func, just like
&gt;cbc_encrypt.
&gt; While the struct gcm_aes_ctx contains both the aes key (constant after
&gt; key schedule) and per message state, and hence has to be non-const. And
&gt; it's not much different to if you use
&gt;   struct cbc_aes_ctx CBC_CTX(struct aes_ctx, AES_BLOCK_SIZE);

Does it really matter to differentiate? I mean in my code I wrap stream
aead, and block ciphers equally, and having a different function pointer
for each would mean that I will use function casts (which are horribly
dangerous if the API changes and I don't notice).

(said that I think I'll separate the AEAD ciphers after having seen the
horrible CCM mode, and may only allow packet encryption with them).

&gt; &gt; * libhogweed soname:
&gt; &gt; libhogweed has the same soname with 2.7.1, so applications crash if they
&gt; &gt; are linked against nettle 2.7.1 and 3.0 is installed (that is because
&gt; &gt; hogweed links against libnettle.so.5).
&gt; He intention was that nettle-2.7.1 uses the sonames "libnettle.so.4" and
&gt; "libhogweed.so.2", and that nettle-3.0 bumped both numbers, to
&gt; libnettle.s0.5 and libhogweed.so.3. Was that somehow messed up in the
&gt; release?

I was mistaken it seems. It is indeed libhogweed.so.3 that I see in 3.0.
For some reason evolution was linking with it though and wouldn't run
after installing it.

&gt; As far as I understand, the versions symbols thing should help. I guess
&gt; sonames have to be bumped again when version symbols are introduced?

Not needed. But the version with the symbols will be binary incompatible
with the previous one, so it may make sense to bump the soversion again
to make that clear that they are incompatible.

&gt; &gt; It may make sense for both libraries to share the same so version.
&gt; I think it is likely that there maybe incompatible changes affecting
&gt; only nettle or only hogweed. So I think it's best to keep them
&gt; independent.

Would that independence work in practice given that lighoweed is linked
with libnettle? I mean if you only bump only nettle, there will be a
competing libhogweed with the previous version of nettle if both are
installed. Symbol versioning would save the day there too though :)

regards,
Nikos




</body></email><email><emailId>20141125062808</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-11-25 06:28:08-0400</timestampReceived><subject>Re: issues found while converting from 2.7 to 3.0</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;&gt; Can you give some example of what you're doing?
&gt;
&gt; I provide an API such as:
&gt; ctx=cipher_init(cipherno, key)
&gt; cipher_encrypt(ctx, data)
&gt; cipher_decrypt(ctx, data)
&gt; cipher_deinit()

And what does cipherno represent here? Just "AES", or does it imply a
key size and/or a mode of operation too?

&gt; Does it really matter to differentiate? I mean in my code I wrap stream
&gt; aead, and block ciphers equally,

With "block ciphers", I imagine you include ECB mode, not just CBC and
CTR and the like?

In that case I think you need to pass contexts around as always
non-const. It's not entirely clear to me how much casting there will be
of the function pointers, hopefully it can be isolated.

But some casting is needed somwehere, if one is going to assign both
aes128_encrypt and camellia128_crypt to variables of the same type.
Within nettle, that casting is done in the initializers for the various
nettle_cipher structs.

And the way I recommend (but maybe that doesn't work for you?) is to use
an array of constant structs, similar in spirit to struct nettle_cipher
and struct nettle_aead, rather than a big switch.

&gt;&gt; As far as I understand, the versions symbols thing should help. I guess
&gt;&gt; sonames have to be bumped again when version symbols are introduced?
&gt;
&gt; Not needed. But the version with the symbols will be binary incompatible
&gt; with the previous one, so it may make sense to bump the soversion again
&gt; to make that clear that they are incompatible.

Can a program linked with nettle-3.0 use a nettle-3.1 library with
versioned symbols at runtime? If not, we must have another soname bump.

&gt; Would that independence work in practice given that lighoweed is linked
&gt; with libnettle? I mean if you only bump only nettle, there will be a
&gt; competing libhogweed with the previous version of nettle if both are
&gt; installed.

I don't understand all possible cases. But I think it's nice if you
don't have to upgrade a program using only interfaces from one of the
libraries, just because you upgraded to a newer version of the nettle
packages, and the other library had an incompatible change.

&gt; Symbol versioning would save the day there too though :)

If we introduce symbol versioning, it seems good to do it for
both libraries at the same time.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141022080345</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-10-22 08:03:45-0400</timestampReceived><subject>Fat binaries</subject><body>

I think I will leave the curve25519 and eddsa code for now, even though
there are several important optimizations left to do (see the just
updated http://www.lysator.liu.se/~nisse/nettle/plan.html).

I think it's getting time to do fat binaries. To make progress, I think
it's best to start with something simple, relying on
__attribute__((constructor) and/or __attribute__(ifunc ...)).

For the case of memxor (where on x86_64, the fat binary mechanism needs
to select between sse2 and non-sse2 code), I'm also considering some
reorganization:

 * Use smaller assembly routines doing one case each, and let the main
   entry point always be C code which can sort out the different cases
   and handle bytes at the beginning and end of the buffer.

 * Fix the cases where the current current code reads a few bytes
   outside of input buffers (but luckily without crossing word
   boundaries, iirc).

 * Add some internal entry points, for cases where alignment is known by
   the caller.

I think some additional overhead is acceptable for the cases of small
badly aligned buffers, if one can gain cleaner or more efficient
handling of the other cases.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.


</body></email><email><emailId>20141026085948</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-10-26 08:59:48-0400</timestampReceived><subject>chacha-poly1305</subject><body>

Hello,
 I was checking what is required for the chacha-poly1305 implementation
to be kept up to date with the current draft [0], on Last-Call. My
understanding is that the current implementation:
1. Is missing support for 96-bit nonce Chacha (could be solved by adding
a chacha_set_nonce96 function)
2. Misses the optimization which you proposed to CFRG (and was
incorporated).

It seems however, that if nettle is changed for the latter (i.e., to pad
AAD), then using chacha_poly1305_update() becomes tricky. It could only
be called once. Would in that case make sense to rename it to
chacha_poly1305_set_aad() rather than update?

regards,
Nikos

[0]. https://tools.ietf.org/html/draft-irtf-cfrg-chacha20-poly1305-02



</body></email><email><emailId>20141026162040</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-10-26 16:20:40-0400</timestampReceived><subject>Re: chacha-poly1305</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt;  I was checking what is required for the chacha-poly1305 implementation
&gt; to be kept up to date with the current draft [0], on Last-Call. My
&gt; understanding is that the current implementation:

Thanks for keeping track of this.

&gt; 1. Is missing support for 96-bit nonce Chacha (could be solved by adding
&gt; a chacha_set_nonce96 function)

Right. Do we need to keep a 64-bit nonce AEAD option?

&gt; 2. Misses the optimization which you proposed to CFRG (and was
&gt; incorporated).

Should be easy to fix. Ideally, we should also take advantage of the
improved alignment between chacha and poly1305.

&gt; It seems however, that if nettle is changed for the latter (i.e., to pad
&gt; AAD), then using chacha_poly1305_update() becomes tricky.

What difficulties do you see? As far as I understand,
chacha_poly1305_update can just call poly1305_update, and update the
auth_size field.

Then the first call to chacha_poly1305_*crypt (or chacha_poly1305_digest
if cleartext is empty) can add the needed padding.

If this is hard to do, for some reason I'm missing, it ought to be
brought up before the spec is done.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141026175846</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-10-26 17:58:46-0400</timestampReceived><subject>Re: chacha-poly1305</subject><body>

On Sun, 2014-10-26 at 17:20 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt; &gt;  I was checking what is required for the chacha-poly1305 implementation
&gt; &gt; to be kept up to date with the current draft [0], on Last-Call. My
&gt; &gt; understanding is that the current implementation:
&gt; Thanks for keeping track of this.
&gt; &gt; 1. Is missing support for 96-bit nonce Chacha (could be solved by adding
&gt; &gt; a chacha_set_nonce96 function)
&gt; Right. Do we need to keep a 64-bit nonce AEAD option?

No such cipher is defined in the current draft which was published after
the last call, so I doubt there will be other than editorial changes to
that draft.

&gt; &gt; 2. Misses the optimization which you proposed to CFRG (and was
&gt; &gt; incorporated).
&gt; Should be easy to fix. Ideally, we should also take advantage of the
&gt; improved alignment between chacha and poly1305.
&gt; 
&gt; &gt; It seems however, that if nettle is changed for the latter (i.e., to pad
&gt; &gt; AAD), then using chacha_poly1305_update() becomes tricky.
&gt; What difficulties do you see? As far as I understand,
&gt; chacha_poly1305_update can just call poly1305_update, and update the
&gt; auth_size field.
&gt; Then the first call to chacha_poly1305_*crypt (or chacha_poly1305_digest
&gt; if cleartext is empty) can add the needed padding.

That makes sense. I was trying to figure that out without putting a
conditional into encrypt.

regards,
Nikos



</body></email><email><emailId>20141026182729</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-10-26 18:27:29-0400</timestampReceived><subject>Re: chacha-poly1305</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; That makes sense. I was trying to figure that out without putting a
&gt; conditional into encrypt.

I don't think a conditional on entry to chacha_poly1305_encrypt is a big
deal (for high performance, one ought to pass several blocks per call
anyway). And you can most likely take out the current check "if
(!ctx-&gt;data_size)", so it shouldn't really add a conditional.

About alignment, after a quick look, I think chacha_poly1305_*crypt can
call _poly1305_block directly, by-passing the buffering logic in
poly1305_update / MD_UPDATE. Except that I'm not sure how to handle a
final, partial, block.

The poly1305 buffer is then needed only for chacha_poly1305_update,
assuming we're going to stick to the convention that _update functions
don't impose any block size on the caller.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141031134559</emailId><senderName>James Cloos</senderName><senderEmail>cloos@jhcloos.com</senderEmail><timestampReceived>2014-10-31 13:45:59-0400</timestampReceived><subject>Re: chacha-poly1305</subject><body>

&gt;&gt;&gt;&gt;&gt; "NM" == Niels Möller &lt;nisse@lysator.liu.se&gt; writes:

&gt;&gt; 1. Is missing support for 96-bit nonce Chacha (could be solved by adding
&gt;&gt; a chacha_set_nonce96 function)

NM&gt; Right. Do we need to keep a 64-bit nonce AEAD option?

You do i you want it to be usable for secsh.  And probably other
non-(ipsec|tls) protocols.

-JimC
-- 
James Cloos &lt;cloos@jhcloos.com&gt;         OpenPGP: 0x997A9F17ED7DAEA6

</body></email><email><emailId>20141031140338</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-10-31 14:03:38-0400</timestampReceived><subject>Re: chacha-poly1305</subject><body>

On Fri, Oct 31, 2014 at 2:45 PM, James Cloos &lt;cloos@jhcloos.com&gt; wrote:
&gt;&gt;&gt;&gt;&gt;&gt; "NM" == Niels Möller &lt;nisse@lysator.liu.se&gt; writes:
&gt; NM&gt; Right. Do we need to keep a 64-bit nonce AEAD option?
&gt; You do i you want it to be usable for secsh.  And probably other
&gt; non-(ipsec|tls) protocols.

Are you sure that these will not be updated to follow the final
document? It would be sad to have protocols following an early draft
and others the final.

regards,
Nikos

</body></email><email><emailId>20141031141959</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-10-31 14:19:59-0400</timestampReceived><subject>Re: chacha-poly1305</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Are you sure that these will not be updated to follow the final
&gt; document? It would be sad to have protocols following an early draft
&gt; and others the final.

These days, I'm not following ssh as closely as I'd like to. But I think
current use of chacha-poly1305 is specified by openssh, not really
standardized.

I'm considering raising this on the ietf-ssh list (if no one else is
quicker).

Compared to the openssh implementation I'd like to

1. Make the AEAD processing compatible with the upcoming RFC.

2. Use leftover bits from the first chacha block to encrypt the packet
   size, instead of using a separate chacha context for that. 

I think (2) may seem a bit odd, and it means that the chacha-poly1305
implementation needs to expose those bits. But I think it makes sense in
the ssh context. In nettle, it could be supported with a variant of
chacha_poly1305_set_nonce with some additional argument.

And then there's some general issues on how to deal with aead algorithms
in the ssh algorithm negotiation, which was designed for separate
encryption and mac; those have been discussed on the ietf-ssh list but I
don't remember the conclusion, if any.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141031160033</emailId><senderName>James Cloos</senderName><senderEmail>cloos@jhcloos.com</senderEmail><timestampReceived>2014-10-31 16:00:33-0400</timestampReceived><subject>Re: chacha-poly1305</subject><body>

&gt;&gt;&gt;&gt;&gt; "NM" == Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

NM&gt; Are you sure that these will not be updated to follow the final
NM&gt; document? It would be sad to have protocols following an early draft
NM&gt; and others the final.

AFAIK the ssh usage has nothing to do with the cfrg drafts.

It came directly from Dan's paper(s).

I expect additional users to ignore that draft and use chacha as it was
intended.

-JimC
-- 
James Cloos &lt;cloos@jhcloos.com&gt;         OpenPGP: 0x997A9F17ED7DAEA6

</body></email><email><emailId>20141125072436</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-11-25 07:24:36-0400</timestampReceived><subject>Re: issues found while converting from 2.7 to 3.0</subject><body>

On Tue, 2014-11-25 at 07:28 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt; &gt;&gt; Can you give some example of what you're doing?
&gt; &gt;
&gt; &gt; I provide an API such as:
&gt; &gt; ctx=cipher_init(cipherno, key)
&gt; &gt; cipher_encrypt(ctx, data)
&gt; &gt; cipher_decrypt(ctx, data)
&gt; &gt; cipher_deinit()
&gt; 
&gt; And what does cipherno represent here? Just "AES", or does it imply a
&gt; key size and/or a mode of operation too?

Yes, something like AES-128-CBC.

&gt; &gt; Does it really matter to differentiate? I mean in my code I wrap stream
&gt; &gt; aead, and block ciphers equally,
&gt; With "block ciphers", I imagine you include ECB mode, not just CBC and
&gt; CTR and the like?

I don't have ecb mode at all since it is not used by TLS (or any other
protocol). Just cbc, and gcm for now.

&gt; And the way I recommend (but maybe that doesn't work for you?) is to use
&gt; an array of constant structs, similar in spirit to struct nettle_cipher
&gt; and struct nettle_aead, rather than a big switch.

That looks like a nice approach. I may even be able to re-use some of
the structures already in nettle to save some memory.

&gt; &gt;&gt; As far as I understand, the versions symbols thing should help. I guess
&gt; &gt;&gt; sonames have to be bumped again when version symbols are introduced?
&gt; &gt; Not needed. But the version with the symbols will be binary incompatible
&gt; &gt; with the previous one, so it may make sense to bump the soversion again
&gt; &gt; to make that clear that they are incompatible.
&gt; Can a program linked with nettle-3.0 use a nettle-3.1 library with
&gt; versioned symbols at runtime? If not, we must have another soname bump.

No it will not.

&gt; &gt; Symbol versioning would save the day there too though :)
&gt; If we introduce symbol versioning, it seems good to do it for
&gt; both libraries at the same time.

I think my patch addresses that for both. What I now realize is that
that mini-gmp mpz_*, gmp_* and mpn_* symbols are not exported in the
script that I sent. They could be put unconditionally there, or via
a configure variable.

regards,
Nikos



</body></email><email><emailId>20141125093650</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-11-25 09:36:50-0400</timestampReceived><subject>Re: issues found while converting from 2.7 to 3.0</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; On Tue, 2014-11-25 at 07:28 +0100, Niels Möller wrote:
&gt;&gt; And what does cipherno represent here? Just "AES", or does it imply a
&gt;&gt; key size and/or a mode of operation too?
&gt;
&gt; Yes, something like AES-128-CBC.

I see. Makes sense.

&gt; I don't have ecb mode at all since it is not used by TLS (or any other
&gt; protocol). Just cbc, and gcm for now.

Also makes sense. Then you probably should use the nettle_cipher_func
type as little as possible. Rather, something like

  struct aes128_cbc_ctx CBC_CTX(struct aes128);
  nettle_crypt_func aes128_cbc_encrypt;

  /* If you're going to call this function via a generic function
     pointer only, there's no gain to have a precise context type, it
     can just as well take a void * argument and cast internally. */
  void
  aes128_cbc_encrypt (void *p...)
  {
    struct aes128_cbc_ctx *ctx = (struct aes128_cbc_ctx *) p;
    CBC_ENCRYPT (ctx, ...);
  }
  
  const struct gnutls_cipher
  aes128_cbc =
  {
    .name = "aes128-cbc",
    .size = sizeof(aes128_cbc_ctx),
    .encrypt = aes128_cbc_encrypt,
    ...
  };

And to make the contexts structs exposed to library users more
self-contained, they can have as first element an "is_a"-pointer to the
corresponding gnutls_cipher, followed (pointer, or directly in the same
object) by the internal cipher-specific context. I guess you already do
something a bit like that?

&gt;&gt; Can a program linked with nettle-3.0 use a nettle-3.1 library with
&gt;&gt; versioned symbols at runtime? If not, we must have another soname bump.
&gt;
&gt; No it will not.

So nettle-3.1 must have a new soname, if it's going to use versioned
symbols (which I'm leaning towards doing).

&gt; I think my patch addresses that for both.

I think it lacked a linker script for hogweed, with symbol version
tracking libhogweed's major version rather than libnettle's.

&gt; What I now realize is that that mini-gmp mpz_*, gmp_* and mpn_*
&gt; symbols are not exported in the script that I sent. They could be put
&gt; unconditionally there, or via a configure variable.

I think it's generally a bit dangerous to make shared libraries with
mini-gmp (the result is not promised to be binary compatible with
regular builds). Anyone trying that really needs to know what he/she
is doing. So I think a sensible default is to disable hogweed symbol
versioning in that case, and possibly have a configure option to
explicitly specify the linker script to use for each library.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141125103851</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-11-25 10:38:51-0400</timestampReceived><subject>Re: issues found while converting from 2.7 to 3.0</subject><body>

On Tue, Nov 25, 2014 at 10:36 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;&gt; I don't have ecb mode at all since it is not used by TLS (or any other
&gt;&gt; protocol). Just cbc, and gcm for now.
&gt; Also makes sense. Then you probably should use the nettle_cipher_func
&gt; type as little as possible. Rather, something like
&gt;   struct aes128_cbc_ctx CBC_CTX(struct aes128);
&gt;   nettle_crypt_func aes128_cbc_encrypt;
&gt;
&gt;   /* If you're going to call this function via a generic function
&gt;      pointer only, there's no gain to have a precise context type, it
&gt;      can just as well take a void * argument and cast internally. */
&gt;   void
&gt;   aes128_cbc_encrypt (void *p...)
&gt;   {
&gt;     struct aes128_cbc_ctx *ctx = (struct aes128_cbc_ctx *) p;
&gt;     CBC_ENCRYPT (ctx, ...);
&gt;   }
&gt;   const struct gnutls_cipher
&gt;   aes128_cbc =
&gt;   {
&gt;     .name = "aes128-cbc",
&gt;     .size = sizeof(aes128_cbc_ctx),
&gt;     .encrypt = aes128_cbc_encrypt,
&gt;     ...
&gt;   };

The disadvantage here is that I need to define encrypt and decrypt
functions for each possible cipher and mode. That was the reason for
the usage of cbc_encrypt() and decrypt. Anyway I'll look to it.

btw. I realized that nettle-meta.h lacks definitions for 3des, des and salsa20.

regards,
Nikos

</body></email><email><emailId>20141125144954</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-11-25 14:49:54-0400</timestampReceived><subject>Re: issues found while converting from 2.7 to 3.0</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; The disadvantage here is that I need to define encrypt and decrypt
&gt; functions for each possible cipher and mode. That was the reason for
&gt; the usage of cbc_encrypt() and decrypt.

Maybe it's possible with some trickery.

For cbc modes, you could allocate a context which is a pointer to the
nettle_cipher struct followed by a CBC_CTX with cipher context and iv.
Then you could do

nettle_crypt_func gnutls_cbc_encrypt;

struct gnutls_cbc_ctx
{
  const struct nettle_cipher *cipher;

  /* A cipher specific context, followed by iv. Use unsigned long as
     an alignment hack (or use pointers and additional memory blocks).
     Total allocation size:

     offsetof (struct gnutls_cbc_ctx, buf)
       + cipher-&gt;context_size + cipher-&gt;block_size. */
  unsigned long buf[1];
};

void
gnutls_cbc_encrypt (void *p, ...)
{
  struct gnutls_cbc_ctx *ctx = (struct gnutls_cbc_ctx *) p;
  void *cipher_ctx = ctx-&gt;buf;
  uint8_t *iv = (uint8_t *) cipher_ctx + ctx-&gt;cipher-&gt;context_size;
  cbc_encrypt (cipher_ctx, ctx-&gt;cipher-&gt;encrypt,
               ctx-&gt;cipher-&gt;block_size, iv, ...);
}
  
and use the same encrypt function for all ciphers in cbc mode. Not sure
what's best, to go this route, or generate boilerplate code for each
algorithm.

And note that the only casting above is for packing everything into the
same memory block, otherwise the cbc_encrypt call needs no casts at all.
(The essential casts are hidden in the initialization of the various
nettle_cipher instances).

&gt; btw. I realized that nettle-meta.h lacks definitions for 3des, des and salsa20.

des and des3 (and blowfish) are missing, because their set_key functions
have a return value indicating weak keys. Maybe they should be added
anyway? Either relying on casting betwen function pointers being safe
with and without return value, or using a wrapper function to explicitly
remove it.

Unfortunately, I don't think a C compiler can optimize

  int bar (int x);
  void foo(int x)
  {
    (void) bar(x); /* Ignore return value */
  }

to make foo simply an alias of bar (assuming the ABI calling ocnventions
allow that). As far as I understand, the C standard requires that &amp;bar
!= &amp;foo, so at best foo wil be compiled into a single jmp instruction.

And salsa20 is missing because there is no nettle-meta abstraction for
stream ciphers. Internally, I use nettle_aead with NULL -&gt;update and
-&gt;digest methods to represent stream ciphers, but I'm not sure if that's
suitable for a public interface. BTW, it's of course possible to
represent CBC and CTR mode in the same way, as nettle_aead without
authentication.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141126103039</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-11-26 10:30:39-0400</timestampReceived><subject>Re: issues found while converting from 2.7 to 3.0</subject><body>

On Tue, Nov 25, 2014 at 3:49 PM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wrot=
e:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt;
&gt;&gt; The disadvantage here is that I need to define encrypt and decrypt
&gt;&gt; functions for each possible cipher and mode. That was the reason for
&gt;&gt; the usage of cbc_encrypt() and decrypt.
&gt; Maybe it's possible with some trickery.
&gt; For cbc modes, you could allocate a context which is a pointer to the
&gt; nettle_cipher struct followed by a CBC_CTX with cipher context and iv.
&gt; Then you could do

I've done something similar at:
https://gitorious.org/gnutls/gnutls/source/0a1102311e443720fc0eb7a83f7dc1b5=
87e55379:lib/nettle/cipher.c

The plan is to integrate that to gnutls master once there is a
functioning chacha-poly.

&gt;&gt; btw. I realized that nettle-meta.h lacks definitions for 3des, des and s=
alsa20.
&gt; des and des3 (and blowfish) are missing, because their set_key functions
&gt; have a return value indicating weak keys. Maybe they should be added
&gt; anyway? Either relying on casting betwen function pointers being safe
&gt; with and without return value, or using a wrapper function to explicitly
&gt; remove it.

If the purpose of these structures are to allow uniform access to
ciphers, they should apply to all ciphers. In any case I also saw that
rc4 was also missing so I avoided using them.

&gt; And salsa20 is missing because there is no nettle-meta abstraction for
&gt; stream ciphers. Internally, I use nettle_aead with NULL -&gt;update and
&gt; -&gt;digest methods to represent stream ciphers, but I'm not sure if that's
&gt; suitable for a public interface. BTW, it's of course possible to
&gt; represent CBC and CTR mode in the same way, as nettle_aead without
&gt; authentication.

For my purposes I didn't care to differentiate between cbc_encrypt()
and stream_encrypt() so I handled them equally. My impression is that
there are two high level abstractions: AEAD ciphers (cipher+mode+tag),
and non-aead cipher+mode (just encryption). Stream ciphers are simply
ciphers with a fixed mode.

regards,
Nikos

</body></email><email><emailId>20141126104600</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-11-26 10:46:00-0400</timestampReceived><subject>Re: issues found while converting from 2.7 to 3.0</subject><body>

On Tue, Nov 25, 2014 at 10:36 AM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wro=
te:

&gt; I think it lacked a linker script for hogweed, with symbol version
&gt; tracking libhogweed's major version rather than libnettle's.

Attached a patch which separates the .map files.

&gt;&gt; What I now realize is that that mini-gmp mpz_*, gmp_* and mpn_*
&gt;&gt; symbols are not exported in the script that I sent. They could be put
&gt;&gt; unconditionally there, or via a configure variable.
&gt;
&gt; I think it's generally a bit dangerous to make shared libraries with
&gt; mini-gmp (the result is not promised to be binary compatible with
&gt; regular builds). Anyone trying that really needs to know what he/she
&gt; is doing. So I think a sensible default is to disable hogweed symbol
&gt; versioning in that case, and possibly have a configure option to
&gt; explicitly specify the linker script to use for each library.

I'm not sure what is the correct path. Disabling the linker script
would mean that more symbols will be exported than normally (all
internal symbols) and there can be clashes that wouldn't be with the
normal library. In any case this is not really related to the version
script, it is mostly an issue of having a different soname when
nettle-mini is used.

regards,
Nikos

["0001-Added-symbol-versioning-for-nettle-and-hogweed.patch" (text/plain-diff)]

From 6436f99f34e607a25018cb2a8d915bf8a3b268cc Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
Date: Mon, 24 Nov 2014 14:02:25 +0100
Subject: [PATCH] Added symbol versioning for nettle and hogweed

Signed-off-by: Nikos Mavrogiannopoulos &lt;nmav@redhat.com&gt;
---
 .gitignore        |  3 +++
 Makefile.in       |  4 ++--
 aclocal.m4        | 59 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 configure.ac      |  7 ++++++-
 libhogweed.map.in | 18 +++++++++++++++++
 libnettle.map.in  | 17 ++++++++++++++++
 6 files changed, 105 insertions(+), 3 deletions(-)
 create mode 100644 libhogweed.map.in
 create mode 100644 libnettle.map.in

diff --git a/.gitignore b/.gitignore
index 2b16f4c..7c4e04c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -67,3 +67,6 @@ core
 /nettle.tps
 /nettle.vr
 /nettle.vrs
+*.po
+/libhogweed.map
+/libnettle.map
diff --git a/Makefile.in b/Makefile.in
index 10a58b0..ebd2bb1 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -244,7 +244,7 @@ libhogweed.a: $(hogweed_OBJS)
 
 # Rules building shared libraries.
 $(LIBNETTLE_FORLINK): $(nettle_OBJS)
-	$(LIBNETTLE_LINK) $(nettle_OBJS) -o $@ $(LIBNETTLE_LIBS)
+	$(LIBNETTLE_LINK) $(nettle_OBJS) @EXTRA_LINKER_FLAGS@ -o $@ $(LIBNETTLE_LIBS)
 	-mkdir .lib 2&gt;/dev/null
 	(cd .lib \
           &amp;&amp; rm -f $(LIBNETTLE_FORLINK) \
@@ -255,7 +255,7 @@ $(LIBNETTLE_FORLINK): $(nettle_OBJS)
 	echo nettle &gt; libnettle.stamp
 
 $(LIBHOGWEED_FORLINK): $(hogweed_OBJS) $(LIBNETTLE_FORLINK)
-	$(LIBHOGWEED_LINK) $(hogweed_OBJS) -o $@ $(LIBHOGWEED_LIBS)
+	$(LIBHOGWEED_LINK) $(hogweed_OBJS) @EXTRA_HOGWEED_LINKER_FLAGS@ -o $@ $(LIBHOGWEED_LIBS)
 	-mkdir .lib 2&gt;/dev/null
 	(cd .lib \
           &amp;&amp; rm -f $(LIBHOGWEED_FORLINK) \
diff --git a/aclocal.m4 b/aclocal.m4
index 36daec6..4c0bd41 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -1211,3 +1211,62 @@ ac_cv_type_int_fast32_t="$ac_cv_type_int_fast32_t"
 ac_cv_type_intmax_t="$ac_cv_type_intmax_t"
 ])
 ])
+
+# ld-version-script.m4 serial 3
+dnl Copyright (C) 2008-2014 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Simon Josefsson
+
+# FIXME: The test below returns a false positive for mingw
+# cross-compiles, 'local:' statements does not reduce number of
+# exported symbols in a DLL.  Use --disable-ld-version-script to work
+# around the problem.
+
+# gl_LD_VERSION_SCRIPT
+# --------------------
+# Check if LD supports linker scripts, and define automake conditional
+# HAVE_LD_VERSION_SCRIPT if so.
+AC_DEFUN([LD_VERSION_SCRIPT],
+[
+  AC_ARG_ENABLE([ld-version-script],
+    AS_HELP_STRING([--enable-ld-version-script],
+      [enable linker version script (default is enabled when possible)]),
+      [have_ld_version_script=$enableval], [])
+  if test -z "$have_ld_version_script"; then
+    AC_MSG_CHECKING([if LD -Wl,--version-script works])
+    save_LDFLAGS="$LDFLAGS"
+    LDFLAGS="$LDFLAGS -Wl,--version-script=conftest.map"
+    cat &gt; conftest.map &lt;&lt;EOF
+foo
+EOF
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
+                   [accepts_syntax_errors=yes], [accepts_syntax_errors=no])
+    if test "$accepts_syntax_errors" = no; then
+      cat &gt; conftest.map &lt;&lt;EOF
+VERS_1 {
+        global: sym;
+};
+
+VERS_2 {
+        global: sym;
+} VERS_1;
+EOF
+      AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
+                     [have_ld_version_script=yes], [have_ld_version_script=no])
+    else
+      have_ld_version_script=no
+    fi
+    rm -f conftest.map
+    LDFLAGS="$save_LDFLAGS"
+    AC_MSG_RESULT($have_ld_version_script)
+  fi
+  if test "$have_ld_version_script" = "yes";then
+	EXTRA_LINKER_FLAGS="-Wl,--version-script=\$(srcdir)/libnettle.map"
+	AC_SUBST(EXTRA_LINKER_FLAGS)
+	EXTRA_HOGWEED_LINKER_FLAGS="-Wl,--version-script=\$(srcdir)/libhogweed.map"
+	AC_SUBST(EXTRA_HOGWEED_LINKER_FLAGS)
+  fi
+])
diff --git a/configure.ac b/configure.ac
index bb33962..33c16e1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -78,10 +78,13 @@ AC_ARG_ENABLE(mini-gmp,
 
 if test "x$enable_mini_gmp" = xyes ; then
   NETTLE_USE_MINI_GMP=1
+  HOGWEED_EXTRA_SYMBOLS="mpz_*;gmp_*;mpn_*;"
 else
   NETTLE_USE_MINI_GMP=0
+  HOGWEED_EXTRA_SYMBOLS=""
 fi
 AC_SUBST([NETTLE_USE_MINI_GMP])
+AC_SUBST([HOGWEED_EXTRA_SYMBOLS])
 
 LSH_RPATH_INIT([`echo $with_lib_path | sed 's/:/ /g'` \
     `echo $exec_prefix | sed "s@^NONE@$prefix/lib@g" | sed "s@^NONE@$ac_default_prefix/lib@g"` \
@@ -114,6 +117,8 @@ AC_TRY_COMPILE([],[return 0;],[IF_CXX=''], [IF_CXX='#'])
 AC_SUBST([IF_CXX])
 AC_LANG_POP
 
+LD_VERSION_SCRIPT
+
 AC_PROG_MAKE_SET
 AC_PROG_RANLIB
 AC_CHECK_TOOL(NM, nm, strings)
@@ -843,7 +848,7 @@ fi
 
 AC_CONFIG_FILES([config.make config.m4 Makefile bignum.h])
 AC_CONFIG_FILES([tools/Makefile testsuite/Makefile examples/Makefile])
-AC_CONFIG_FILES([nettle.pc hogweed.pc])
+AC_CONFIG_FILES([nettle.pc hogweed.pc libnettle.map libhogweed.map])
 
 AC_OUTPUT
 
diff --git a/libhogweed.map.in b/libhogweed.map.in
new file mode 100644
index 0000000..eea6ed8
--- /dev/null
+++ b/libhogweed.map.in
@@ -0,0 +1,18 @@
+# libhogweed.map -- libhogweed linker version script.           -*- ld-script -*-
+
+#
+# The symbol version must be updated on every hogweed
+# library major number change. That is taken care by
+# auto-generating the file.
+
+HOGWEED_@LIBHOGWEED_MAJOR@
+{
+  global:
+    nettle_*;
+    _nettle_*;
+    @HOGWEED_EXTRA_SYMBOLS@
+
+  local:
+    *;
+};
+
diff --git a/libnettle.map.in b/libnettle.map.in
new file mode 100644
index 0000000..02455bc
--- /dev/null
+++ b/libnettle.map.in
@@ -0,0 +1,17 @@
+# libnettle.map -- libnettle linker version script.           -*- ld-script -*-
+
+#
+# The symbol version must be updated on every nettle
+# library major number change. That is taken care by
+# auto-generating the file.
+
+NETTLE_@LIBNETTLE_MAJOR@
+{
+  global:
+    nettle_*;
+    _nettle_*;
+
+  local:
+    *;
+};
+
-- 
1.9.3



</body></email><email><emailId>20141126123232</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-11-26 12:32:32-0400</timestampReceived><subject>Re: issues found while converting from 2.7 to 3.0</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; I've done something similar at:
&gt; https://gitorious.org/gnutls/gnutls/source/0a1102311e443720fc0eb7a83f7dc1b587e55379:lib/nettle/cipher.c

Looks reasonable. You get a pretty large nettle_cipher_st to support all
variations, I see. Some comments:

_ccm_aes_encrypt looks like it supports ccm with any cipher, right?

If the aead_*crypt_func functions are intended as the primary interface
for aead, I guess you'd want to either retire the auth and tag functions
(and you may want additonal helper functions in nettle to make that
easy?). Or implement the aead_*crypt functions in terms of the auth and
tag functions for everything but ccm.

For the _gcm functions, do you see any obstacles to implementing generic
_gcm functions (like you do with cbc), which passes the encrypt_block
function to nettle's general gcm functions? Note that GCM_CTX
intentionally puts the cipher-specific context last, so the offset
should always be the same.

For function typedefs, in nettle I've chosen to let these types be
non-pointers. This is a question of style, of course. If you did the
same, you would be able do use them to declare functions like

  static encrypt_func _cbc_encrypt;

and then the compiler will check that the definition of _cbc_encrypt
matches the declaration. Which I think is nice.

Your auth_func, tag_func, set_key_func and setiv_func seem to duplicate
nettle_hash_update, nettle_set_key_func and nettle_hash_digest_func. If
they are intended to work with nettle's context structs (which they are,
I think?), maybe it's clearer to use nettle's names for these types, to
differentiate them from the function types which work with your more
abstract nettle_cipher_ctx.

&gt; My impression is that
&gt; there are two high level abstractions: AEAD ciphers (cipher+mode+tag),
&gt; and non-aead cipher+mode (just encryption). Stream ciphers are simply
&gt; ciphers with a fixed mode.

And nettle currently lacks an abstraction (of the nette-meta.h style)
for the second type. nettle_cipher is for "raw" block ciphers, ECB-mode,
no state.

Using struct nettle_aead could work. The update and digest methods would
be NULL. The set_nonce method would be NULL for arcfour and any other
traditional stream cipher, and non-NULL for block cipher modes like cbc
and ctr, as well as for salsa20 and chacha. (Supporting cbc in this way
has padding issues, though, not sure how to deal with that).

But using nettle_aead is not ideal naming. Maybe it should be done
differently.

(And I don't think nettle should include meta objects for all possible
combinations of ciphers and modes, but it could include the most
important ones, and make it easy for an application to define additional
combinations).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141126135800</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-11-26 13:58:00-0400</timestampReceived><subject>Re: issues found while converting from 2.7 to 3.0</subject><body>

On Wed, Nov 26, 2014 at 1:32 PM, Niels M=F6ller &lt;nisse@lysator.liu.se&gt; wrot=
e:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt;&gt; I've done something similar at:
&gt;&gt; https://gitorious.org/gnutls/gnutls/source/0a1102311e443720fc0eb7a83f7dc=
1b587e55379:lib/nettle/cipher.c
&gt; Looks reasonable. You get a pretty large nettle_cipher_st to support all
&gt; variations, I see. Some comments:
&gt; _ccm_aes_encrypt looks like it supports ccm with any cipher, right?

Nice catch. Indeed, it is not restricted to AES.

&gt; If the aead_*crypt_func functions are intended as the primary interface
&gt; for aead, I guess you'd want to either retire the auth and tag functions
&gt; (and you may want additonal helper functions in nettle to make that
&gt; easy?). Or implement the aead_*crypt functions in terms of the auth and
&gt; tag functions for everything but ccm.

My plan is to provide a minimal AEAD API such as:
https://gitorious.org/gnutls/gnutls/source/0a1102311e443720fc0eb7a83f7dc1b5=
87e55379:lib/includes/gnutls/crypto.h#L67

The old auth and tag will be kept for backwards compatibility in
AES-GCM, but will not be offered by all AEAD ciphers.

&gt; For the _gcm functions, do you see any obstacles to implementing generic
&gt; _gcm functions (like you do with cbc), which passes the encrypt_block
&gt; function to nettle's general gcm functions? Note that GCM_CTX
&gt; intentionally puts the cipher-specific context last, so the offset
&gt; should always be the same.

Do you mean something like:
struct gcm_cast_st { struct gcm_key key; struct gcm_ctx gcm; char xx[1]; };
#define GCM_CTX_GET_KEY(ptr) (&amp;((struct gcm_cast_st*)ptr)-&gt;key)
#define GCM_CTX_GET_CTX(ptr) (&amp;((struct gcm_cast_st*)ptr)-&gt;gcm)
#define GCM_CTX_GET_CIPHER(ptr) ((void*)&amp;((struct gcm_cast_st*)ptr)-&gt;xx)

It looks indeed simpler. Not sure how valid is the GCM_CTX_GET_CIPHER
cast though. It would be nice if nettle's gcm.h provided such macros.

&gt; Your auth_func, tag_func, set_key_func and setiv_func seem to duplicate
&gt; nettle_hash_update, nettle_set_key_func and nettle_hash_digest_func.

Thanks, I should use them.

regards,
Nikos

</body></email><email><emailId>20141128182018</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-11-28 18:20:18-0400</timestampReceived><subject>Re: issues found while converting from 2.7 to 3.0</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; Do you mean something like:
&gt; struct gcm_cast_st { struct gcm_key key; struct gcm_ctx gcm; char xx[1]; };
&gt; #define GCM_CTX_GET_KEY(ptr) (&amp;((struct gcm_cast_st*)ptr)-&gt;key)
&gt; #define GCM_CTX_GET_CTX(ptr) (&amp;((struct gcm_cast_st*)ptr)-&gt;gcm)
&gt; #define GCM_CTX_GET_CIPHER(ptr) ((void*)&amp;((struct gcm_cast_st*)ptr)-&gt;xx)
&gt;
&gt; It looks indeed simpler. Not sure how valid is the GCM_CTX_GET_CIPHER
&gt; cast though. It would be nice if nettle's gcm.h provided such macros.

Only potential problem I see is alignment. You could make it an unsigned
long array rather than a char array. And I'd drop the GET_KEY and
GET_CTX macros; they're perfectly normal struct accesses.

You could perhaps use GCM_CTX, from nettle/gcm.h, with a generic cipher
type, say

  struct gcm_st GCM_CTX(unsigned long);

but I'm not sure that's better than making your own. Of the other GCM_*
macros in nettle/gcm.h, I think they might work with the above context,
provided that the passed in encrypt function takes a void * (or const
void *) as the first argument.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141128183520</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-11-28 18:35:20-0400</timestampReceived><subject>Re: issues found while converting from 2.7 to 3.0</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; On Tue, Nov 25, 2014 at 10:36 AM, Niels Möller &lt;nisse@lysator.liu.se&gt; wrote:
&gt;
&gt;&gt; I think it lacked a linker script for hogweed, with symbol version
&gt;&gt; tracking libhogweed's major version rather than libnettle's.
&gt;
&gt; Attached a patch which separates the .map files.

Looks good, thanks. I'll try to do some testing and see if I understand this, and
then merge on the master branch.

&gt; --- a/.gitignore
&gt; +++ b/.gitignore
&gt; @@ -67,3 +67,6 @@ core
&gt;  /nettle.tps
&gt;  /nettle.vr
&gt;  /nettle.vrs
&gt; +*.po
&gt; +/libhogweed.map
&gt; +/libnettle.map

I take it adding *.po is not really intended? These files were
eliminated a while ago.

&gt; +# gl_LD_VERSION_SCRIPT
&gt; +# --------------------
&gt; +# Check if LD supports linker scripts, and define automake conditional
&gt; +# HAVE_LD_VERSION_SCRIPT if so.

I see no automake-things in here. Right?

&gt; +AC_DEFUN([LD_VERSION_SCRIPT],
&gt; +[
&gt; +  AC_ARG_ENABLE([ld-version-script],
&gt; +    AS_HELP_STRING([--enable-ld-version-script],
&gt; +      [enable linker version script (default is enabled when possible)]),
&gt; +      [have_ld_version_script=$enableval], [])
&gt; +  if test -z "$have_ld_version_script"; then
&gt; +    AC_MSG_CHECKING([if LD -Wl,--version-script works])
&gt; +    save_LDFLAGS="$LDFLAGS"
&gt; +    LDFLAGS="$LDFLAGS -Wl,--version-script=conftest.map"
&gt; +    cat &gt; conftest.map &lt;&lt;EOF
&gt; +foo
&gt; +EOF
&gt; +    AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
&gt; +                   [accepts_syntax_errors=yes], [accepts_syntax_errors=no])
&gt; +    if test "$accepts_syntax_errors" = no; then
&gt; +      cat &gt; conftest.map &lt;&lt;EOF
&gt; +VERS_1 {
&gt; +        global: sym;
&gt; +};
&gt; +
&gt; +VERS_2 {
&gt; +        global: sym;
&gt; +} VERS_1;
&gt; +EOF
&gt; +      AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
&gt; +                     [have_ld_version_script=yes], [have_ld_version_script=no])
&gt; +    else
&gt; +      have_ld_version_script=no
&gt; +    fi
&gt; +    rm -f conftest.map
&gt; +    LDFLAGS="$save_LDFLAGS"
&gt; +    AC_MSG_RESULT($have_ld_version_script)
&gt; +  fi
&gt; +  if test "$have_ld_version_script" = "yes";then
&gt; +	EXTRA_LINKER_FLAGS="-Wl,--version-script=\$(srcdir)/libnettle.map"
&gt; +	AC_SUBST(EXTRA_LINKER_FLAGS)
&gt; +	EXTRA_HOGWEED_LINKER_FLAGS="-Wl,--version-script=\$(srcdir)/libhogweed.map"
&gt; +	AC_SUBST(EXTRA_HOGWEED_LINKER_FLAGS)
&gt; +  fi

It would in some way be cleaner to have this nettle-specific setup in
configure.ac, rather than in aclocal.m4. Maybe the macro could have an
optional if-true argument? Or one could just move the test of
have_ld_version_script.

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141128192808</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-11-28 19:28:08-0400</timestampReceived><subject>Re: issues found while converting from 2.7 to 3.0</subject><body>

On Fri, 2014-11-28 at 19:20 +0100, Niels Möller wrote:
&gt; Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:
&gt; 
&gt; &gt; Do you mean something like:
&gt; &gt; struct gcm_cast_st { struct gcm_key key; struct gcm_ctx gcm; char xx[1]; };
&gt; &gt; #define GCM_CTX_GET_KEY(ptr) (&amp;((struct gcm_cast_st*)ptr)-&gt;key)
&gt; &gt; #define GCM_CTX_GET_CTX(ptr) (&amp;((struct gcm_cast_st*)ptr)-&gt;gcm)
&gt; &gt; #define GCM_CTX_GET_CIPHER(ptr) ((void*)&amp;((struct gcm_cast_st*)ptr)-&gt;xx)
&gt; &gt;
&gt; &gt; It looks indeed simpler. Not sure how valid is the GCM_CTX_GET_CIPHER
&gt; &gt; cast though. It would be nice if nettle's gcm.h provided such macros.
&gt; 
&gt; Only potential problem I see is alignment. 

Indeed, and that's why I'd prefer for the library to provide such
macros. Maybe changing the GCM structure to something like 
{ struct gcm_key key; struct gcm_ctx gcm; void *c; type cipher; }

Where c will be set by GCM_SET_KEY to point to cipher?

&gt; You could make it an unsigned
&gt; long array rather than a char array. And I'd drop the GET_KEY and
&gt; GET_CTX macros; they're perfectly normal struct accesses.

They are needed as I cast from void*.

regards,
Nikos



</body></email><email><emailId>20141207171344</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-12-07 17:13:44-0400</timestampReceived><subject>Re: function casts</subject><body>

On Sun, 2014-12-07 at 13:50 +0100, Niels Möller wrote:

&gt; &gt;&gt; Question is, does that solve a real problem? 
&gt; &gt; What do you mean by that?
&gt; If one prefers to not have that cast, one can call always call
&gt; gcm_encrypt directly; GCM_ENCRYPT is an optional feature.
&gt; 
&gt; So my question is, do you think it would make your code easier to read
&gt; and debug, if nettle provided a simple non-magic wrapper macro around
&gt; gcm_encrypt (in addition to the current GCM_ENCRYPT macro which you find
&gt; questionable), or would it be clearer to call gcm_encrypt directly?

No. Putting an other safer macro will not solve that issue. My concern
is on the easiness to have a bug-free transition to 3.0 from 2.7.1.

regards,
Nikos



</body></email><email><emailId>20141207205138</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-12-07 20:51:38-0400</timestampReceived><subject>Re: function casts</subject><body>

Nikos Mavrogiannopoulos &lt;nmav@gnutls.org&gt; writes:

&gt; My concern
&gt; is on the easiness to have a bug-free transition to 3.0 from 2.7.1.

I see. I don't think I'm going to remove the cast for nettle-3.1. I view
it as a feature, not a bug. The intent is to reduce the amount of casts
in application code, and provide something slightly safer.

I wonder if there are any other simple changes (besides documenting
potential problems) which would reduce upgrade problems?

Hmm, maybe, in the

  (0 ? (encrypt)(&amp;(ctx)-&gt;cipher, 0, (void *)0, (void *)0)

part of macro, intended for typechecking, one could change the 0
constant for the size argument to some larger constant which doesn't fit
in a plain int. E.g., consider the following test program:

  #include &lt;stdlib.h&gt;
  
  extern foo (int x);
  
  int main (int argc, char **argv)
  {
    if (0)
      foo (~(size_t)0);
    return 0;
  }
        
When I compile it with gcc, version 4.7.2, no optimization or special
warning flags, on x86_64, it produces a warning,

  size_t-type-checking.c: In function `main':
  size_t-type-checking.c:8:5: warning: overflow in implicit constant conversion [-Woverflow]

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141212190449</emailId><senderName>Niels =?iso-8859-1?Q?M=F6ller?=</senderName><senderEmail>nisse@lysator.liu.se</senderEmail><timestampReceived>2014-12-12 19:04:49-0400</timestampReceived><subject>Re: function casts</subject><body>

nisse@lysator.liu.se (Niels Möller) writes:

&gt; Hmm, maybe, in the
&gt;
&gt;   (0 ? (encrypt)(&amp;(ctx)-&gt;cipher, 0, (void *)0, (void *)0)
&gt;
&gt; part of macro, intended for typechecking, one could change the 0
&gt; constant for the size argument to some larger constant which doesn't fit
&gt; in a plain int.

I've now done this, and I've also changed the type of the pointer
arguments to be more specific.

Nikos, if you have the time, it would be nice if you could build gnutls
without the
https://gitorious.org/gnutls/gnutls/commit/488cfe9a57840faeb2e35250757d8d33da32064f
fix, and with the nettle header files from master, and see if you get
any warnings (on a 64-bit arch, where size_t is larger than unsigned
int).

Regards,
/Niels

-- 
Niels Möller. PGP-encrypted email is preferred. Keyid C0B98E26.
Internet email is subject to wholesale government surveillance.

</body></email><email><emailId>20141212232211</emailId><senderName>Nikos Mavrogiannopoulos</senderName><senderEmail>nmav@gnutls.org</senderEmail><timestampReceived>2014-12-12 23:22:11-0400</timestampReceived><subject>Re: function casts</subject><body>

On Fri, 2014-12-12 at 20:04 +0100, Niels Möller wrote:

&gt; Nikos, if you have the time, it would be nice if you could build gnutls
&gt; without the
&gt; https://gitorious.org/gnutls/gnutls/commit/488cfe9a57840faeb2e35250757d8d33da32064f
&gt; fix, and with the nettle header files from master, and see if you get
&gt; any warnings (on a 64-bit arch, where size_t is larger than unsigned
&gt; int).

There is a truncation warning indeed.

regards,
Nikos



</body></email></emails>