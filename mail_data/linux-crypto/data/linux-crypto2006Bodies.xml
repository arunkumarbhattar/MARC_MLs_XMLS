<?xml version="1.0" encoding="utf-8"?>
<emails><email><emailId>20061207061122</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-12-07 06:11:22-0400</timestampReceived><subject>gpg-1.4.6 and gpg-2.x</subject><body>

gpg folks fixed serious remotely exploitable security flaw that affects gpg
versions older than 1.4.6 and 2.0.2

http://lists.gnupg.org/pipermail/gnupg-announce/2006q4/000491.html

For loop-AES users who use patched version of gpg to encrypt loop-AES key
files, the good news is that gpg-1.4.6 and gpg-2.x versions no longer
require patching to change default amount of passphrase iteration.

You can set this option in your options file ~/.gnupg/gpg.conf

 s2k-count 8388608


Or alternatively... You can use this gpg command line parameter:

 --s2k-count 8388608


Or alternatively... You can apply this source patch and recompile:

--- gnupg-1.4.6/g10/gpg.c.old	2006-12-03 17:37:45.000000000 +0200
+++ gnupg-1.4.6/g10/gpg.c	2006-12-06 21:58:07.000000000 +0200
@@ -1792,7 +1792,7 @@
     opt.cert_digest_algo = 0;
     opt.compress_algo = -1; /* defaults to DEFAULT_COMPRESS_ALGO */
     opt.s2k_mode = 3; /* iterated+salted */
-    opt.s2k_count = 96; /* 65536 iterations */
+    opt.s2k_count = 208; /* 8388608 byte count */
 #ifdef USE_CAST5
     opt.s2k_cipher_algo = CIPHER_ALGO_CAST5;
 #else


To test that your gpg is using more passphrase iterations, you can run these
commands:

$ echo x | gpg --symmetric &gt;test1.gpg
$ gpg --decrypt -v -v &lt;test1.gpg

Second gpg invocation should output a line like this:

        salt 41f21861d981248e, count 8388608 (208)
                                     ^^^^^^^

Salt value will be different on each symmetrically encrypted file.

Since the security flaw in older gpg versions also affects signature
verification, I decided to include MD5 of original tarball here as well.

ec8dc6df1bd83c1d7e1a1ea10653f9f4  gnupg-1.4.6.tar.bz2

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061117011929</emailId><senderName>Adrian Bunk</senderName><senderEmail>bunk@stusta.de</senderEmail><timestampReceived>2006-11-17 01:19:29-0400</timestampReceived><subject>[-mm patch] crypto/xcbc.c: make some code static</subject><body>

On Tue, Nov 14, 2006 at 01:41:25AM -0800, Andrew Morton wrote:
&gt;...
&gt; Changes since 2.6.19-rc5-mm2:
&gt;...
&gt;  git-cryptodev.patch
&gt;...
&gt;  git trees
&gt;...

This patch makes some needlessly global code static.

Signed-off-by: Adrian Bunk &lt;bunk@stusta.de&gt;

---

 crypto/xcbc.c |   14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

--- linux-2.6.19-rc5-mm2/crypto/xcbc.c.old	2006-11-16 22:56:01.000000000 +0100
+++ linux-2.6.19-rc5-mm2/crypto/xcbc.c	2006-11-16 22:57:12.000000000 +0100
@@ -28,9 +28,9 @@
 #include &lt;linux/scatterlist.h&gt;
 #include "internal.h"
 
-u_int32_t ks[12] = {0x01010101, 0x01010101, 0x01010101, 0x01010101,
-		    0x02020202, 0x02020202, 0x02020202, 0x02020202,
-		    0x03030303, 0x03030303, 0x03030303, 0x03030303};
+static u_int32_t ks[12] = {0x01010101, 0x01010101, 0x01010101, 0x01010101,
+			   0x02020202, 0x02020202, 0x02020202, 0x02020202,
+			   0x03030303, 0x03030303, 0x03030303, 0x03030303};
 /*
  * +------------------------
  * | &lt;parent tfm&gt;
@@ -96,7 +96,7 @@
 	return _crypto_xcbc_digest_setkey(parent, ctx);
 }
 
-int crypto_xcbc_digest_init(struct hash_desc *pdesc)
+static int crypto_xcbc_digest_init(struct hash_desc *pdesc)
 {
 	struct crypto_xcbc_ctx *ctx = crypto_hash_ctx_aligned(pdesc-&gt;tfm);
 	int bs = crypto_hash_blocksize(pdesc-&gt;tfm);
@@ -108,7 +108,9 @@
 	return 0;
 }
 
-int crypto_xcbc_digest_update(struct hash_desc *pdesc, struct scatterlist *sg, unsigned int nbytes)
+static int crypto_xcbc_digest_update(struct hash_desc *pdesc,
+				     struct scatterlist *sg,
+				     unsigned int nbytes)
 {
 	struct crypto_hash *parent = pdesc-&gt;tfm;
 	struct crypto_xcbc_ctx *ctx = crypto_hash_ctx_aligned(parent);
@@ -181,7 +183,7 @@
 	return 0;
 }
 
-int crypto_xcbc_digest_final(struct hash_desc *pdesc, u8 *out)
+static int crypto_xcbc_digest_final(struct hash_desc *pdesc, u8 *out)
 {
 	struct crypto_hash *parent = pdesc-&gt;tfm;
 	struct crypto_xcbc_ctx *ctx = crypto_hash_ctx_aligned(parent);

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061207122024</emailId><senderName>"Leo B."</senderName><senderEmail>spam-goes-to-dev-null@gmx.net</senderEmail><timestampReceived>2006-12-07 12:20:24-0400</timestampReceived><subject>RE: gpg-1.4.6 and gpg-2.x</subject><body>

 

Does this mean that my rootkey.gpg is vulnerable to attacks
if it was created with an old GPG version following the
loop-AES README instructions?

If so then I should recreate it and overwrite the old one
a few thousand times... mmh.

Leo B.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061204050529</emailId><senderName>Christian Kujau</senderName><senderEmail>lists@nerdbynature.de</senderEmail><timestampReceived>2006-12-04 05:05:29-0400</timestampReceived><subject>dm-crypt with sha1 instead of sha256?</subject><body>

Hi,

while experimenting with dm-crypt (+LUKS) I wonder if I could choose 
another hash for the ESSIV (-c) to see if this would affect 
performance later on:

# KEY="`dd if=/dev/urandom bs=1 count="128" 2&gt;/dev/null`"
# echo "$KEY" | cryptsetup -c aes-cbc-essiv:sha1 --key-size 128 \
   luksFormat /dev/md0

Failed to setup dm-crypt key mapping.
Check kernel for support for the aes-cbc-essiv:sha1 cipher spec and 
verify that /dev/md0 contains at least 133 sectors.
Failed to write to key storage.

When using "-c aes-cbc-essiv:sha256" the command succeeds. Using "-c 
aes-cbc-essiv:sha" (without the "1" in "sha1") did not help. The SHA 
modules are loaded:

# grep name.*sha /proc/crypto
name         : sha1
name         : sha256
name         : sha384
name         : sha512

I'm using cryptsetup-luks 1.0.3 on a x86_64 sytem, different kernels 
were tried (2.6.17-10 from ubuntu, 2.6.19-rc6-mm2, 2.6.19-rc6-git12...)

Any ideas what could cause these errors?

Thanks,
Christian.
-- 
BOFH excuse #192:

runaway cat on system.

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061207132602</emailId><senderName>Wolfgang Aigner</senderName><senderEmail>list-linux-crypto@mail2news-gw.secaron.de</senderEmail><timestampReceived>2006-12-07 13:26:02-0400</timestampReceived><subject>Re: gpg-1.4.6 and gpg-2.x</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

&gt; Does this mean that my rootkey.gpg is vulnerable to attacks
&gt; if it was created with an old GPG version following the
&gt; loop-AES README instructions?

No problem here.
The vulnerablility can be used from an attacker if he prepares data
(signed or encrypted data) and you process this data on your machine.

Data or keys that you have created by yourself with gpg is not a danger
here.


greetings
Wolfgang
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (MingW32)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFeBZqJ/k3KwFqU/kRCHymAKCDyUpags8C3lmlgr9DMNPQi7QaLQCcD7Cr
WbLnK/xGpM4D1U5pShKothE=
=QRw3
-----END PGP SIGNATURE-----
-- 
The From: and Reply-To: addresses are internal news2mail gateway addresses.
Reply to the list or to Wolfgang Aigner &lt;aigner@secaron.nospam.de&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061208114215</emailId><senderName>Jan Glauber</senderName><senderEmail>jan.glauber@de.ibm.com</senderEmail><timestampReceived>2006-12-08 11:42:15-0400</timestampReceived><subject>Re: [RFC][PATCH] Pseudo-random number generator</subject><body>

On Thu, 2006-12-07 at 19:43 +0100, Arnd Bergmann wrote:
&gt; On Thursday 07 December 2006 16:19, Jan Glauber wrote:
&gt; &gt; Hm, why is /dev/urandom implemented in the kernel?
&gt; &gt; 
&gt; &gt; It could be done completely in user-space (like libica already does)
&gt; &gt; but I think having a device node where you can read from is the simplest
&gt; &gt; implementation. Also, if we can solve the security flaw we could use it
&gt; &gt; as replacement for /dev/urandom.
&gt; 
&gt; urandom is more useful, because can't be implemented in user space at
&gt; all. /dev/urandom will use the real randomness from the kernel as a seed
&gt; without depleting the entropy pool. How does your /dev/prandom device
&gt; compare to /dev/urandom performance-wise? If it can be made to use
&gt; the same input data and it turns out to be significantly faster, I can
&gt; see some use for it.

The performance of the PRNG without constantly adding entropy is up tp
factor 40 faster than /dev/urandom ;- , depending on the block size of
the read.

With the current patch it performs not so well because of the STCKE loop
before every KMC. I think about removing them and changing the
periodically seed to use get_random_bytes instead.

Jan

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061215102640</emailId><senderName>David Howells</senderName><senderEmail>dhowells@redhat.com</senderEmail><timestampReceived>2006-12-15 10:26:40-0400</timestampReceived><subject>[PATCH 2/2] FCrypt encryption module</subject><body>

Add a crypto module to provide FCrypt encryption as used by RxRPC.

Signed-Off-By: David Howells &lt;dhowells@redhat.com&gt;
---

 crypto/Kconfig  |    7 +
 crypto/Makefile |    1 
 crypto/fcrypt.c |  423 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 crypto/tcrypt.c |   16 ++
 crypto/tcrypt.h |  128 +++++++++++++++++
 5 files changed, 574 insertions(+), 1 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
index 9d3a44c..e2e1eb1 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -204,6 +204,13 @@ config CRYPTO_DES_S390
 	help
 	  DES cipher algorithm (FIPS 46-2), and Triple DES EDE (FIPS 46-3).
 
+config CRYPTO_FCRYPT
+	tristate "FCrypt cipher algorithm"
+	select CRYPTO_ALGAPI
+	select CRYPTO_BLKCIPHER
+	help
+	  FCrypt algorithm used by RxRPC.
+
 config CRYPTO_BLOWFISH
 	tristate "Blowfish cipher algorithm"
 	select CRYPTO_ALGAPI
diff --git a/crypto/Makefile b/crypto/Makefile
index 9ef048d..a3e1915 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -30,6 +30,7 @@ obj-$(CONFIG_CRYPTO_CBC) += cbc.o
 obj-$(CONFIG_CRYPTO_PCBC) += pcbc.o
 obj-$(CONFIG_CRYPTO_LRW) += lrw.o
 obj-$(CONFIG_CRYPTO_DES) += des.o
+obj-$(CONFIG_CRYPTO_FCRYPT) += fcrypt.o
 obj-$(CONFIG_CRYPTO_BLOWFISH) += blowfish.o
 obj-$(CONFIG_CRYPTO_TWOFISH) += twofish.o
 obj-$(CONFIG_CRYPTO_TWOFISH_COMMON) += twofish_common.o
diff --git a/crypto/fcrypt.c b/crypto/fcrypt.c
new file mode 100644
index 0000000..9c2bb53
--- /dev/null
+++ b/crypto/fcrypt.c
@@ -0,0 +1,423 @@
+/* FCrypt encryption algorithm
+ *
+ * Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * Based on code:
+ *
+ * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
+ * (Royal Institute of Technology, Stockholm, Sweden).
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/crypto.h&gt;
+
+#define ROUNDS 16
+
+struct fcrypt_ctx {
+	u32 sched[ROUNDS];
+};
+
+/* Rotate right two 32 bit numbers as a 56 bit number */
+#define ror56(hi, lo, n)					\
+do {								\
+	u32 t = lo &amp; ((1 &lt;&lt; n) - 1);				\
+	lo = (lo &gt;&gt; n) | ((hi &amp; ((1 &lt;&lt; n) - 1)) &lt;&lt; (32 - n));	\
+	hi = (hi &gt;&gt; n) | (t &lt;&lt; (24-n));				\
+} while(0)
+
+/* Rotate right one 64 bit number as a 56 bit number */
+#define ror56_64(k, n)						\
+do {								\
+	k = (k &gt;&gt; n) | ((k &amp; ((1 &lt;&lt; n) - 1)) &lt;&lt; (56 - n));	\
+} while(0)
+
+/*
+ * Sboxes for Feistel network derived from
+ * /afs/transarc.com/public/afsps/afs.rel31b.export-src/rxkad/sboxes.h
+ */
+#undef Z
+#define Z(x) __constant_be32_to_cpu(x &lt;&lt; 3)
+static const u32 sbox0[256] = {
+	Z(0xea), Z(0x7f), Z(0xb2), Z(0x64), Z(0x9d), Z(0xb0), Z(0xd9), Z(0x11),
+	Z(0xcd), Z(0x86), Z(0x86), Z(0x91), Z(0x0a), Z(0xb2), Z(0x93), Z(0x06),
+	Z(0x0e), Z(0x06), Z(0xd2), Z(0x65), Z(0x73), Z(0xc5), Z(0x28), Z(0x60),
+	Z(0xf2), Z(0x20), Z(0xb5), Z(0x38), Z(0x7e), Z(0xda), Z(0x9f), Z(0xe3),
+	Z(0xd2), Z(0xcf), Z(0xc4), Z(0x3c), Z(0x61), Z(0xff), Z(0x4a), Z(0x4a),
+	Z(0x35), Z(0xac), Z(0xaa), Z(0x5f), Z(0x2b), Z(0xbb), Z(0xbc), Z(0x53),
+	Z(0x4e), Z(0x9d), Z(0x78), Z(0xa3), Z(0xdc), Z(0x09), Z(0x32), Z(0x10),
+	Z(0xc6), Z(0x6f), Z(0x66), Z(0xd6), Z(0xab), Z(0xa9), Z(0xaf), Z(0xfd),
+	Z(0x3b), Z(0x95), Z(0xe8), Z(0x34), Z(0x9a), Z(0x81), Z(0x72), Z(0x80),
+	Z(0x9c), Z(0xf3), Z(0xec), Z(0xda), Z(0x9f), Z(0x26), Z(0x76), Z(0x15),
+	Z(0x3e), Z(0x55), Z(0x4d), Z(0xde), Z(0x84), Z(0xee), Z(0xad), Z(0xc7),
+	Z(0xf1), Z(0x6b), Z(0x3d), Z(0xd3), Z(0x04), Z(0x49), Z(0xaa), Z(0x24),
+	Z(0x0b), Z(0x8a), Z(0x83), Z(0xba), Z(0xfa), Z(0x85), Z(0xa0), Z(0xa8),
+	Z(0xb1), Z(0xd4), Z(0x01), Z(0xd8), Z(0x70), Z(0x64), Z(0xf0), Z(0x51),
+	Z(0xd2), Z(0xc3), Z(0xa7), Z(0x75), Z(0x8c), Z(0xa5), Z(0x64), Z(0xef),
+	Z(0x10), Z(0x4e), Z(0xb7), Z(0xc6), Z(0x61), Z(0x03), Z(0xeb), Z(0x44),
+	Z(0x3d), Z(0xe5), Z(0xb3), Z(0x5b), Z(0xae), Z(0xd5), Z(0xad), Z(0x1d),
+	Z(0xfa), Z(0x5a), Z(0x1e), Z(0x33), Z(0xab), Z(0x93), Z(0xa2), Z(0xb7),
+	Z(0xe7), Z(0xa8), Z(0x45), Z(0xa4), Z(0xcd), Z(0x29), Z(0x63), Z(0x44),
+	Z(0xb6), Z(0x69), Z(0x7e), Z(0x2e), Z(0x62), Z(0x03), Z(0xc8), Z(0xe0),
+	Z(0x17), Z(0xbb), Z(0xc7), Z(0xf3), Z(0x3f), Z(0x36), Z(0xba), Z(0x71),
+	Z(0x8e), Z(0x97), Z(0x65), Z(0x60), Z(0x69), Z(0xb6), Z(0xf6), Z(0xe6),
+	Z(0x6e), Z(0xe0), Z(0x81), Z(0x59), Z(0xe8), Z(0xaf), Z(0xdd), Z(0x95),
+	Z(0x22), Z(0x99), Z(0xfd), Z(0x63), Z(0x19), Z(0x74), Z(0x61), Z(0xb1),
+	Z(0xb6), Z(0x5b), Z(0xae), Z(0x54), Z(0xb3), Z(0x70), Z(0xff), Z(0xc6),
+	Z(0x3b), Z(0x3e), Z(0xc1), Z(0xd7), Z(0xe1), Z(0x0e), Z(0x76), Z(0xe5),
+	Z(0x36), Z(0x4f), Z(0x59), Z(0xc7), Z(0x08), Z(0x6e), Z(0x82), Z(0xa6),
+	Z(0x93), Z(0xc4), Z(0xaa), Z(0x26), Z(0x49), Z(0xe0), Z(0x21), Z(0x64),
+	Z(0x07), Z(0x9f), Z(0x64), Z(0x81), Z(0x9c), Z(0xbf), Z(0xf9), Z(0xd1),
+	Z(0x43), Z(0xf8), Z(0xb6), Z(0xb9), Z(0xf1), Z(0x24), Z(0x75), Z(0x03),
+	Z(0xe4), Z(0xb0), Z(0x99), Z(0x46), Z(0x3d), Z(0xf5), Z(0xd1), Z(0x39),
+	Z(0x72), Z(0x12), Z(0xf6), Z(0xba), Z(0x0c), Z(0x0d), Z(0x42), Z(0x2e)
+};
+
+#undef Z
+#define Z(x) __constant_be32_to_cpu((x &lt;&lt; 27) | (x &gt;&gt; 5))
+static const u32 sbox1[256] = {
+	Z(0x77), Z(0x14), Z(0xa6), Z(0xfe), Z(0xb2), Z(0x5e), Z(0x8c), Z(0x3e),
+	Z(0x67), Z(0x6c), Z(0xa1), Z(0x0d), Z(0xc2), Z(0xa2), Z(0xc1), Z(0x85),
+	Z(0x6c), Z(0x7b), Z(0x67), Z(0xc6), Z(0x23), Z(0xe3), Z(0xf2), Z(0x89),
+	Z(0x50), Z(0x9c), Z(0x03), Z(0xb7), Z(0x73), Z(0xe6), Z(0xe1), Z(0x39),
+	Z(0x31), Z(0x2c), Z(0x27), Z(0x9f), Z(0xa5), Z(0x69), Z(0x44), Z(0xd6),
+	Z(0x23), Z(0x83), Z(0x98), Z(0x7d), Z(0x3c), Z(0xb4), Z(0x2d), Z(0x99),
+	Z(0x1c), Z(0x1f), Z(0x8c), Z(0x20), Z(0x03), Z(0x7c), Z(0x5f), Z(0xad),
+	Z(0xf4), Z(0xfa), Z(0x95), Z(0xca), Z(0x76), Z(0x44), Z(0xcd), Z(0xb6),
+	Z(0xb8), Z(0xa1), Z(0xa1), Z(0xbe), Z(0x9e), Z(0x54), Z(0x8f), Z(0x0b),
+	Z(0x16), Z(0x74), Z(0x31), Z(0x8a), Z(0x23), Z(0x17), Z(0x04), Z(0xfa),
+	Z(0x79), Z(0x84), Z(0xb1), Z(0xf5), Z(0x13), Z(0xab), Z(0xb5), Z(0x2e),
+	Z(0xaa), Z(0x0c), Z(0x60), Z(0x6b), Z(0x5b), Z(0xc4), Z(0x4b), Z(0xbc),
+	Z(0xe2), Z(0xaf), Z(0x45), Z(0x73), Z(0xfa), Z(0xc9), Z(0x49), Z(0xcd),
+	Z(0x00), Z(0x92), Z(0x7d), Z(0x97), Z(0x7a), Z(0x18), Z(0x60), Z(0x3d),
+	Z(0xcf), Z(0x5b), Z(0xde), Z(0xc6), Z(0xe2), Z(0xe6), Z(0xbb), Z(0x8b),
+	Z(0x06), Z(0xda), Z(0x08), Z(0x15), Z(0x1b), Z(0x88), Z(0x6a), Z(0x17),
+	Z(0x89), Z(0xd0), Z(0xa9), Z(0xc1), Z(0xc9), Z(0x70), Z(0x6b), Z(0xe5),
+	Z(0x43), Z(0xf4), Z(0x68), Z(0xc8), Z(0xd3), Z(0x84), Z(0x28), Z(0x0a),
+	Z(0x52), Z(0x66), Z(0xa3), Z(0xca), Z(0xf2), Z(0xe3), Z(0x7f), Z(0x7a),
+	Z(0x31), Z(0xf7), Z(0x88), Z(0x94), Z(0x5e), Z(0x9c), Z(0x63), Z(0xd5),
+	Z(0x24), Z(0x66), Z(0xfc), Z(0xb3), Z(0x57), Z(0x25), Z(0xbe), Z(0x89),
+	Z(0x44), Z(0xc4), Z(0xe0), Z(0x8f), Z(0x23), Z(0x3c), Z(0x12), Z(0x52),
+	Z(0xf5), Z(0x1e), Z(0xf4), Z(0xcb), Z(0x18), Z(0x33), Z(0x1f), Z(0xf8),
+	Z(0x69), Z(0x10), Z(0x9d), Z(0xd3), Z(0xf7), Z(0x28), Z(0xf8), Z(0x30),
+	Z(0x05), Z(0x5e), Z(0x32), Z(0xc0), Z(0xd5), Z(0x19), Z(0xbd), Z(0x45),
+	Z(0x8b), Z(0x5b), Z(0xfd), Z(0xbc), Z(0xe2), Z(0x5c), Z(0xa9), Z(0x96),
+	Z(0xef), Z(0x70), Z(0xcf), Z(0xc2), Z(0x2a), Z(0xb3), Z(0x61), Z(0xad),
+	Z(0x80), Z(0x48), Z(0x81), Z(0xb7), Z(0x1d), Z(0x43), Z(0xd9), Z(0xd7),
+	Z(0x45), Z(0xf0), Z(0xd8), Z(0x8a), Z(0x59), Z(0x7c), Z(0x57), Z(0xc1),
+	Z(0x79), Z(0xc7), Z(0x34), Z(0xd6), Z(0x43), Z(0xdf), Z(0xe4), Z(0x78),
+	Z(0x16), Z(0x06), Z(0xda), Z(0x92), Z(0x76), Z(0x51), Z(0xe1), Z(0xd4),
+	Z(0x70), Z(0x03), Z(0xe0), Z(0x2f), Z(0x96), Z(0x91), Z(0x82), Z(0x80)
+};
+
+#undef Z
+#define Z(x) __constant_be32_to_cpu(x &lt;&lt; 11)
+static const u32 sbox2[256] = {
+	Z(0xf0), Z(0x37), Z(0x24), Z(0x53), Z(0x2a), Z(0x03), Z(0x83), Z(0x86),
+	Z(0xd1), Z(0xec), Z(0x50), Z(0xf0), Z(0x42), Z(0x78), Z(0x2f), Z(0x6d),
+	Z(0xbf), Z(0x80), Z(0x87), Z(0x27), Z(0x95), Z(0xe2), Z(0xc5), Z(0x5d),
+	Z(0xf9), Z(0x6f), Z(0xdb), Z(0xb4), Z(0x65), Z(0x6e), Z(0xe7), Z(0x24),
+	Z(0xc8), Z(0x1a), Z(0xbb), Z(0x49), Z(0xb5), Z(0x0a), Z(0x7d), Z(0xb9),
+	Z(0xe8), Z(0xdc), Z(0xb7), Z(0xd9), Z(0x45), Z(0x20), Z(0x1b), Z(0xce),
+	Z(0x59), Z(0x9d), Z(0x6b), Z(0xbd), Z(0x0e), Z(0x8f), Z(0xa3), Z(0xa9),
+	Z(0xbc), Z(0x74), Z(0xa6), Z(0xf6), Z(0x7f), Z(0x5f), Z(0xb1), Z(0x68),
+	Z(0x84), Z(0xbc), Z(0xa9), Z(0xfd), Z(0x55), Z(0x50), Z(0xe9), Z(0xb6),
+	Z(0x13), Z(0x5e), Z(0x07), Z(0xb8), Z(0x95), Z(0x02), Z(0xc0), Z(0xd0),
+	Z(0x6a), Z(0x1a), Z(0x85), Z(0xbd), Z(0xb6), Z(0xfd), Z(0xfe), Z(0x17),
+	Z(0x3f), Z(0x09), Z(0xa3), Z(0x8d), Z(0xfb), Z(0xed), Z(0xda), Z(0x1d),
+	Z(0x6d), Z(0x1c), Z(0x6c), Z(0x01), Z(0x5a), Z(0xe5), Z(0x71), Z(0x3e),
+	Z(0x8b), Z(0x6b), Z(0xbe), Z(0x29), Z(0xeb), Z(0x12), Z(0x19), Z(0x34),
+	Z(0xcd), Z(0xb3), Z(0xbd), Z(0x35), Z(0xea), Z(0x4b), Z(0xd5), Z(0xae),
+	Z(0x2a), Z(0x79), Z(0x5a), Z(0xa5), Z(0x32), Z(0x12), Z(0x7b), Z(0xdc),
+	Z(0x2c), Z(0xd0), Z(0x22), Z(0x4b), Z(0xb1), Z(0x85), Z(0x59), Z(0x80),
+	Z(0xc0), Z(0x30), Z(0x9f), Z(0x73), Z(0xd3), Z(0x14), Z(0x48), Z(0x40),
+	Z(0x07), Z(0x2d), Z(0x8f), Z(0x80), Z(0x0f), Z(0xce), Z(0x0b), Z(0x5e),
+	Z(0xb7), Z(0x5e), Z(0xac), Z(0x24), Z(0x94), Z(0x4a), Z(0x18), Z(0x15),
+	Z(0x05), Z(0xe8), Z(0x02), Z(0x77), Z(0xa9), Z(0xc7), Z(0x40), Z(0x45),
+	Z(0x89), Z(0xd1), Z(0xea), Z(0xde), Z(0x0c), Z(0x79), Z(0x2a), Z(0x99),
+	Z(0x6c), Z(0x3e), Z(0x95), Z(0xdd), Z(0x8c), Z(0x7d), Z(0xad), Z(0x6f),
+	Z(0xdc), Z(0xff), Z(0xfd), Z(0x62), Z(0x47), Z(0xb3), Z(0x21), Z(0x8a),
+	Z(0xec), Z(0x8e), Z(0x19), Z(0x18), Z(0xb4), Z(0x6e), Z(0x3d), Z(0xfd),
+	Z(0x74), Z(0x54), Z(0x1e), Z(0x04), Z(0x85), Z(0xd8), Z(0xbc), Z(0x1f),
+	Z(0x56), Z(0xe7), Z(0x3a), Z(0x56), Z(0x67), Z(0xd6), Z(0xc8), Z(0xa5),
+	Z(0xf3), Z(0x8e), Z(0xde), Z(0xae), Z(0x37), Z(0x49), Z(0xb7), Z(0xfa),
+	Z(0xc8), Z(0xf4), Z(0x1f), Z(0xe0), Z(0x2a), Z(0x9b), Z(0x15), Z(0xd1),
+	Z(0x34), Z(0x0e), Z(0xb5), Z(0xe0), Z(0x44), Z(0x78), Z(0x84), Z(0x59),
+	Z(0x56), Z(0x68), Z(0x77), Z(0xa5), Z(0x14), Z(0x06), Z(0xf5), Z(0x2f),
+	Z(0x8c), Z(0x8a), Z(0x73), Z(0x80), Z(0x76), Z(0xb4), Z(0x10), Z(0x86)
+};
+
+#undef Z
+#define Z(x) __constant_be32_to_cpu(x &lt;&lt; 19)
+static const u32 sbox3[256] = {
+	Z(0xa9), Z(0x2a), Z(0x48), Z(0x51), Z(0x84), Z(0x7e), Z(0x49), Z(0xe2),
+	Z(0xb5), Z(0xb7), Z(0x42), Z(0x33), Z(0x7d), Z(0x5d), Z(0xa6), Z(0x12),
+	Z(0x44), Z(0x48), Z(0x6d), Z(0x28), Z(0xaa), Z(0x20), Z(0x6d), Z(0x57),
+	Z(0xd6), Z(0x6b), Z(0x5d), Z(0x72), Z(0xf0), Z(0x92), Z(0x5a), Z(0x1b),
+	Z(0x53), Z(0x80), Z(0x24), Z(0x70), Z(0x9a), Z(0xcc), Z(0xa7), Z(0x66),
+	Z(0xa1), Z(0x01), Z(0xa5), Z(0x41), Z(0x97), Z(0x41), Z(0x31), Z(0x82),
+	Z(0xf1), Z(0x14), Z(0xcf), Z(0x53), Z(0x0d), Z(0xa0), Z(0x10), Z(0xcc),
+	Z(0x2a), Z(0x7d), Z(0xd2), Z(0xbf), Z(0x4b), Z(0x1a), Z(0xdb), Z(0x16),
+	Z(0x47), Z(0xf6), Z(0x51), Z(0x36), Z(0xed), Z(0xf3), Z(0xb9), Z(0x1a),
+	Z(0xa7), Z(0xdf), Z(0x29), Z(0x43), Z(0x01), Z(0x54), Z(0x70), Z(0xa4),
+	Z(0xbf), Z(0xd4), Z(0x0b), Z(0x53), Z(0x44), Z(0x60), Z(0x9e), Z(0x23),
+	Z(0xa1), Z(0x18), Z(0x68), Z(0x4f), Z(0xf0), Z(0x2f), Z(0x82), Z(0xc2),
+	Z(0x2a), Z(0x41), Z(0xb2), Z(0x42), Z(0x0c), Z(0xed), Z(0x0c), Z(0x1d),
+	Z(0x13), Z(0x3a), Z(0x3c), Z(0x6e), Z(0x35), Z(0xdc), Z(0x60), Z(0x65),
+	Z(0x85), Z(0xe9), Z(0x64), Z(0x02), Z(0x9a), Z(0x3f), Z(0x9f), Z(0x87),
+	Z(0x96), Z(0xdf), Z(0xbe), Z(0xf2), Z(0xcb), Z(0xe5), Z(0x6c), Z(0xd4),
+	Z(0x5a), Z(0x83), Z(0xbf), Z(0x92), Z(0x1b), Z(0x94), Z(0x00), Z(0x42),
+	Z(0xcf), Z(0x4b), Z(0x00), Z(0x75), Z(0xba), Z(0x8f), Z(0x76), Z(0x5f),
+	Z(0x5d), Z(0x3a), Z(0x4d), Z(0x09), Z(0x12), Z(0x08), Z(0x38), Z(0x95),
+	Z(0x17), Z(0xe4), Z(0x01), Z(0x1d), Z(0x4c), Z(0xa9), Z(0xcc), Z(0x85),
+	Z(0x82), Z(0x4c), Z(0x9d), Z(0x2f), Z(0x3b), Z(0x66), Z(0xa1), Z(0x34),
+	Z(0x10), Z(0xcd), Z(0x59), Z(0x89), Z(0xa5), Z(0x31), Z(0xcf), Z(0x05),
+	Z(0xc8), Z(0x84), Z(0xfa), Z(0xc7), Z(0xba), Z(0x4e), Z(0x8b), Z(0x1a),
+	Z(0x19), Z(0xf1), Z(0xa1), Z(0x3b), Z(0x18), Z(0x12), Z(0x17), Z(0xb0),
+	Z(0x98), Z(0x8d), Z(0x0b), Z(0x23), Z(0xc3), Z(0x3a), Z(0x2d), Z(0x20),
+	Z(0xdf), Z(0x13), Z(0xa0), Z(0xa8), Z(0x4c), Z(0x0d), Z(0x6c), Z(0x2f),
+	Z(0x47), Z(0x13), Z(0x13), Z(0x52), Z(0x1f), Z(0x2d), Z(0xf5), Z(0x79),
+	Z(0x3d), Z(0xa2), Z(0x54), Z(0xbd), Z(0x69), Z(0xc8), Z(0x6b), Z(0xf3),
+	Z(0x05), Z(0x28), Z(0xf1), Z(0x16), Z(0x46), Z(0x40), Z(0xb0), Z(0x11),
+	Z(0xd3), Z(0xb7), Z(0x95), Z(0x49), Z(0xcf), Z(0xc3), Z(0x1d), Z(0x8f),
+	Z(0xd8), Z(0xe1), Z(0x73), Z(0xdb), Z(0xad), Z(0xc8), Z(0xc9), Z(0xa9),
+	Z(0xa1), Z(0xc2), Z(0xc5), Z(0xe3), Z(0xba), Z(0xfc), Z(0x0e), Z(0x25)
+};
+
+/*
+ * This is a 16 round Feistel network with permutation F_ENCRYPT
+ */
+#define F_ENCRYPT(R, L, sched)						\
+do {									\
+	union lc4 { u32 l; u8 c[4]; } u;				\
+	u.l = sched ^ R;						\
+	L ^= sbox0[u.c[0]] ^ sbox1[u.c[1]] ^ sbox2[u.c[2]] ^ sbox3[u.c[3]]; \
+} while(0)
+
+/*
+ * encryptor
+ */
+static void fcrypt_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
+{
+	const struct fcrypt_ctx *ctx = crypto_tfm_ctx(tfm);
+	struct {
+		u32 l, r;
+	} X;
+
+	memcpy(&amp;X, src, sizeof(X));
+
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x0]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x1]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x2]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x3]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x4]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x5]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x6]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x7]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x8]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x9]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xa]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xb]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xc]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xd]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xe]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xf]);
+
+	memcpy(dst, &amp;X, sizeof(X));
+}
+
+/*
+ * decryptor
+ */
+static void fcrypt_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
+{
+	const struct fcrypt_ctx *ctx = crypto_tfm_ctx(tfm);
+	struct {
+		u32 l, r;
+	} X;
+
+	memcpy(&amp;X, src, sizeof(X));
+
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xf]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xe]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xd]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xc]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xb]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xa]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x9]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x8]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x7]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x6]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x5]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x4]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x3]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x2]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x1]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x0]);
+
+	memcpy(dst, &amp;X, sizeof(X));
+}
+
+/*
+ * Generate a key schedule from key, the least significant bit in each key byte
+ * is parity and shall be ignored. This leaves 56 significant bits in the key
+ * to scatter over the 16 key schedules. For each schedule extract the low
+ * order 32 bits and use as schedule, then rotate right by 11 bits.
+ */
+static int fcrypt_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
+{
+	struct fcrypt_ctx *ctx = crypto_tfm_ctx(tfm);
+
+#if BITS_PER_LONG == 64  /* the 64-bit version can also be used for 32-bit
+			  * kernels - it seems to be faster but the code is
+			  * larger */
+
+	u64 k;	/* k holds all 56 non-parity bits */
+
+	/* discard the parity bits */
+	k = (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key) &gt;&gt; 1;
+
+	/* Use lower 32 bits for schedule, rotate by 11 each round (16 times) */
+	ctx-&gt;sched[0x0] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x1] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x2] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x3] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x4] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x5] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x6] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x7] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x8] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x9] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xa] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xb] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xc] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xd] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xe] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xf] = be32_to_cpu(k);
+
+	return 0;
+#else
+	u32 hi, lo;		/* hi is upper 24 bits and lo lower 32, total 56 */
+
+	/* discard the parity bits */
+	lo = (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	hi = lo &gt;&gt; 4;
+	lo &amp;= 0xf;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key) &gt;&gt; 1;
+
+	/* Use lower 32 bits for schedule, rotate by 11 each round (16 times) */
+	ctx-&gt;sched[0x0] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x1] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x2] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x3] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x4] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x5] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x6] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x7] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x8] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x9] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xa] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xb] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xc] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xd] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xe] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xf] = be32_to_cpu(lo);
+	return 0;
+#endif
+}
+
+static struct crypto_alg fcrypt_alg = {
+	.cra_name		=	"fcrypt",
+	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize		=	8,
+	.cra_ctxsize		=	sizeof(struct fcrypt_ctx),
+	.cra_module		=	THIS_MODULE,
+	.cra_alignmask		=	3,
+	.cra_list		=	LIST_HEAD_INIT(fcrypt_alg.cra_list),
+	.cra_u			=	{ .cipher = {
+	.cia_min_keysize	=	8,
+	.cia_max_keysize	=	8,
+	.cia_setkey		=	fcrypt_setkey,
+	.cia_encrypt		=	fcrypt_encrypt,
+	.cia_decrypt		=	fcrypt_decrypt } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;fcrypt_alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;fcrypt_alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("FCrypt Cipher Algorithm");
+MODULE_AUTHOR("David Howells &lt;dhowells@redhat.com&gt;");
diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
index d671e89..eef0516 100644
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -71,7 +71,8 @@ static char *check[] = {
 	"des", "md5", "des3_ede", "rot13", "sha1", "sha256", "blowfish",
 	"twofish", "serpent", "sha384", "sha512", "md4", "aes", "cast6",
 	"arc4", "michael_mic", "deflate", "crc32c", "tea", "xtea",
-	"khazad", "wp512", "wp384", "wp256", "tnepres", "xeta", NULL
+	"khazad", "wp512", "wp384", "wp256", "tnepres", "xeta",  "fcrypt",
+	NULL
 };
 
 static void hexdump(unsigned char *buf, unsigned int len)
@@ -964,6 +965,12 @@ static void do_test(void)
 		test_cipher("ecb(xeta)", DECRYPT, xeta_dec_tv_template,
 			    XETA_DEC_TEST_VECTORS);
 
+		//FCrypt
+		test_cipher("pcbc(fcrypt)", ENCRYPT, fcrypt_pcbc_enc_tv_template,
+			    FCRYPT_ENC_TEST_VECTORS);
+		test_cipher("pcbc(fcrypt)", DECRYPT, fcrypt_pcbc_dec_tv_template,
+			    FCRYPT_DEC_TEST_VECTORS);
+
 		test_hash("sha384", sha384_tv_template, SHA384_TEST_VECTORS);
 		test_hash("sha512", sha512_tv_template, SHA512_TEST_VECTORS);
 		test_hash("wp512", wp512_tv_template, WP512_TEST_VECTORS);
@@ -1177,6 +1184,13 @@ static void do_test(void)
 			    XETA_DEC_TEST_VECTORS);
 		break;
 
+	case 31:
+		test_cipher("pcbc(fcrypt)", ENCRYPT, fcrypt_pcbc_enc_tv_template,
+			    FCRYPT_ENC_TEST_VECTORS);
+		test_cipher("pcbc(fcrypt)", DECRYPT, fcrypt_pcbc_dec_tv_template,
+			    FCRYPT_DEC_TEST_VECTORS);
+		break;
+
 	case 100:
 		test_hash("hmac(md5)", hmac_md5_tv_template,
 			  HMAC_MD5_TEST_VECTORS);
diff --git a/crypto/tcrypt.h b/crypto/tcrypt.h
index 48a8136..688cbeb 100644
--- a/crypto/tcrypt.h
+++ b/crypto/tcrypt.h
@@ -3316,6 +3316,134 @@ static struct cipher_testvec xeta_dec_tv
 	}
 };
 
+/* 
+ * FCrypt test vectors 
+ */
+#define FCRYPT_ENC_TEST_VECTORS	ARRAY_SIZE(fcrypt_pcbc_enc_tv_template)
+#define FCRYPT_DEC_TEST_VECTORS	ARRAY_SIZE(fcrypt_pcbc_dec_tv_template)
+
+static struct cipher_testvec fcrypt_pcbc_enc_tv_template[] = {
+	{ /* http://www.openafs.org/pipermail/openafs-devel/2000-December/005320.html */
+		.key	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.klen	= 8,
+		.iv	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.input	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.ilen	= 8,
+		.result	= { 0x0E, 0x09, 0x00, 0xC7, 0x3E, 0xF7, 0xED, 0x41 },
+		.rlen	= 8,
+	}, {
+		.key	= { 0x11, 0x44, 0x77, 0xAA, 0xDD, 0x00, 0x33, 0x66 },
+		.klen	= 8,
+		.iv	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.input	= { 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0 },
+		.ilen	= 8,
+		.result	= { 0xD8, 0xED, 0x78, 0x74, 0x77, 0xEC, 0x06, 0x80 },
+		.rlen	= 8,
+	}, { /* From Arla */
+		.key	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.klen	= 8,
+		.iv	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.input	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.ilen	= 48,
+		.result	= { 0x00, 0xf0, 0xe,  0x11, 0x75, 0xe6, 0x23, 0x82,
+			    0xee, 0xac, 0x98, 0x62, 0x44, 0x51, 0xe4, 0x84,
+			    0xc3, 0x59, 0xd8, 0xaa, 0x64, 0x60, 0xae, 0xf7,
+			    0xd2, 0xd9, 0x13, 0x79, 0x72, 0xa3, 0x45, 0x03,
+			    0x23, 0xb5, 0x62, 0xd7, 0x0c, 0xf5, 0x27, 0xd1,
+			    0xf8, 0x91, 0x3c, 0xac, 0x44, 0x22, 0x92, 0xef },
+		.rlen	= 48,
+	}, {
+		.key	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.klen	= 8,
+		.iv	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.input	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.ilen	= 48,
+		.result	= { 0xca, 0x90, 0xf5, 0x9d, 0xcb, 0xd4, 0xd2, 0x3c,
+			    0x01, 0x88, 0x7f, 0x3e, 0x31, 0x6e, 0x62, 0x9d,
+			    0xd8, 0xe0, 0x57, 0xa3, 0x06, 0x3a, 0x42, 0x58,
+			    0x2a, 0x28, 0xfe, 0x72, 0x52, 0x2f, 0xdd, 0xe0,
+			    0x19, 0x89, 0x09, 0x1c, 0x2a, 0x8e, 0x8c, 0x94,
+			    0xfc, 0xc7, 0x68, 0xe4, 0x88, 0xaa, 0xde, 0x0f },
+		.rlen	= 48,
+	}, { /* split-page version */
+		.key	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.klen	= 8,
+		.iv	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.input	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.ilen	= 48,
+		.result	= { 0xca, 0x90, 0xf5, 0x9d, 0xcb, 0xd4, 0xd2, 0x3c,
+			    0x01, 0x88, 0x7f, 0x3e, 0x31, 0x6e, 0x62, 0x9d,
+			    0xd8, 0xe0, 0x57, 0xa3, 0x06, 0x3a, 0x42, 0x58,
+			    0x2a, 0x28, 0xfe, 0x72, 0x52, 0x2f, 0xdd, 0xe0,
+			    0x19, 0x89, 0x09, 0x1c, 0x2a, 0x8e, 0x8c, 0x94,
+			    0xfc, 0xc7, 0x68, 0xe4, 0x88, 0xaa, 0xde, 0x0f },
+		.rlen	= 48,
+		.np	= 2,
+		.tap	= { 20, 28 },
+	}
+};
+
+static struct cipher_testvec fcrypt_pcbc_dec_tv_template[] = {
+	{ /* http://www.openafs.org/pipermail/openafs-devel/2000-December/005320.html */
+		.key	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.klen	= 8,
+		.iv	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.input	= { 0x0E, 0x09, 0x00, 0xC7, 0x3E, 0xF7, 0xED, 0x41 },
+		.ilen	= 8,
+		.result	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.rlen	= 8,
+	}, {
+		.key	= { 0x11, 0x44, 0x77, 0xAA, 0xDD, 0x00, 0x33, 0x66 },
+		.klen	= 8,
+		.iv	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.input	= { 0xD8, 0xED, 0x78, 0x74, 0x77, 0xEC, 0x06, 0x80 },
+		.ilen	= 8,
+		.result	= { 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0 },
+		.rlen	= 8,
+	}, { /* From Arla */
+		.key	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.klen	= 8,
+		.iv	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.input	= { 0x00, 0xf0, 0xe,  0x11, 0x75, 0xe6, 0x23, 0x82,
+			    0xee, 0xac, 0x98, 0x62, 0x44, 0x51, 0xe4, 0x84,
+			    0xc3, 0x59, 0xd8, 0xaa, 0x64, 0x60, 0xae, 0xf7,
+			    0xd2, 0xd9, 0x13, 0x79, 0x72, 0xa3, 0x45, 0x03,
+			    0x23, 0xb5, 0x62, 0xd7, 0x0c, 0xf5, 0x27, 0xd1,
+			    0xf8, 0x91, 0x3c, 0xac, 0x44, 0x22, 0x92, 0xef },
+		.ilen	= 48,
+		.result	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.rlen	= 48,
+	}, {
+		.key	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.klen	= 8,
+		.iv	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.input	= { 0xca, 0x90, 0xf5, 0x9d, 0xcb, 0xd4, 0xd2, 0x3c,
+			    0x01, 0x88, 0x7f, 0x3e, 0x31, 0x6e, 0x62, 0x9d,
+			    0xd8, 0xe0, 0x57, 0xa3, 0x06, 0x3a, 0x42, 0x58,
+			    0x2a, 0x28, 0xfe, 0x72, 0x52, 0x2f, 0xdd, 0xe0,
+			    0x19, 0x89, 0x09, 0x1c, 0x2a, 0x8e, 0x8c, 0x94,
+			    0xfc, 0xc7, 0x68, 0xe4, 0x88, 0xaa, 0xde, 0x0f },
+		.ilen	= 48,
+		.result	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.rlen	= 48,
+	}, { /* split-page version */
+		.key	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.klen	= 8,
+		.iv	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.input	= { 0xca, 0x90, 0xf5, 0x9d, 0xcb, 0xd4, 0xd2, 0x3c,
+			    0x01, 0x88, 0x7f, 0x3e, 0x31, 0x6e, 0x62, 0x9d,
+			    0xd8, 0xe0, 0x57, 0xa3, 0x06, 0x3a, 0x42, 0x58,
+			    0x2a, 0x28, 0xfe, 0x72, 0x52, 0x2f, 0xdd, 0xe0,
+			    0x19, 0x89, 0x09, 0x1c, 0x2a, 0x8e, 0x8c, 0x94,
+			    0xfc, 0xc7, 0x68, 0xe4, 0x88, 0xaa, 0xde, 0x0f },
+		.ilen	= 48,
+		.result	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.rlen	= 48,
+		.np	= 2,
+		.tap	= { 20, 28 },
+	}
+};
+
 /*
  * Compression stuff.
  */
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061215133006</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert.xu@redhat.com</senderEmail><timestampReceived>2006-12-15 13:30:06-0400</timestampReceived><subject>Re: [PATCH 1/2] Add PCBC crypto template support</subject><body>

On Fri, Dec 15, 2006 at 10:26:37AM +0000, David Howells wrote:
&gt; Add PCBC crypto template support as used by RxRPC.
&gt; 
&gt; Signed-Off-By: David Howells &lt;dhowells@redhat.com&gt;

Thanks David!  I'll push this to mm via cryptodev.
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061216142252</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-12-16 14:22:52-0400</timestampReceived><subject>Re: aes-pipe -p function.</subject><body>

hyplex wrote:
&gt; I was using a dos formated key file and a unix format key file in a
&gt; command such as '...|aes-pipe -p 3 3&lt;keys &gt;foobar.out', and to my
&gt; surprise they produced different results(foobar.out).  I expected them
&gt; to only work on the ascii representation of the keys, and to convert
&gt; them into the actual binary key.  Upon looking at the code though
&gt; (hopefully I just overlooked something) it doesn't do such a conversion
&gt; and it checks the keys file for '\n' or \0 to end a key line.  So...

There is nothing wrong with having control characters in passphrases that
get hashed to generate keys. CONTROL-m character (CR) is one such special
character. If you don't want CR characters included as hash input, then
don't use key files containing such characters.

Microsoft's CR-LF pair as newline character is just plain silly, and causes
problems with having to deal with text/binary modes of opening files. Unix
and Linux don't have such sillyness.

&gt; If this is the case, you can either 1) continue to use the ascii
&gt; representation anyway, but then each byte of your key is limited to the
&gt; ascii representation of 0-f.

There is no 0-f limitation per byte. '\n' or \0 terminated string gets
hashed to generated a key.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061216144603</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-12-16 14:46:03-0400</timestampReceived><subject>Re: Script for loop-AES key generation</subject><body>

Hi all,

On Sat, Nov 25, 2006 at 06:16:14PM +0100, Lionel Elie Mamane wrote:
&gt; On Sat, Nov 25, 2006 at 03:20:21PM +0100, Max Vozeler wrote:
&gt; 
&gt; &gt; On Wed, Nov 22, 2006 at 11:07:10PM +0100, Richard Zidlicky wrote:
&gt; &gt;&gt; why strings? "grep -a" works since ages and saves one command.
&gt; 
&gt; &gt; The attached patch changes the script to use grep -a (which is not
&gt; &gt; in POSIX/SuSv3 or busybox grep, but should generally be available on
&gt; &gt; normal systems)
&gt; 
&gt; I don't get the point of combining -a and -q; the effect of -a is that
&gt; even if the file is binary, "lines" that match are printed on
&gt; stdout. -q tells it not to output anything. So as far as I
&gt; understand,"-a -q" is the same as "-q". Which is in SuSv3.

Good point. I wonder why I didn't notice that :-)
It now uses plain grep -q.

BTW: We maintain the keygen script in an SVN repository; You can
always find the latest version there:

http://svn.debian.org/wsvn/pkg-loop-aes/trunk/loop-aes-utils/debian/loop-aes-keygen?op=file&amp;rev=0&amp;sc=0

cheers,
Max

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061219105916</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-12-19 10:59:16-0400</timestampReceived><subject>Re: [ANN] Acrypto asynchronous crypto layer 2.6.19 release.</subject><body>

On Tue, Dec 19, 2006 at 11:51:01AM +0100, Andreas Jellinghaus (aj@ciphirelabs.com) wrote:
&gt; Evgeniy Polyakov wrote:
&gt; &gt;You can change it in async_provider in compilation time or I can create
&gt; &gt;module version. There is an item in related todo list to use crypto
&gt; &gt;contexts, they were created exactly for such kind of things (actually
&gt; &gt;for hardware devices which do not support realtime key changes).
&gt; 
&gt; ok, what do I need to change to get aes-cbc-essiv:sha256 support
&gt; so I can use acrypto with my current dm-crypt'ed partitions?

For AES CBC only set of supported operations should be extended.
Something like patch below:

diff --git a/acrypto/async_provider.c b/acrypto/async_provider.c
index ac11708..186cc5c 100644
--- a/acrypto/async_provider.c
+++ b/acrypto/async_provider.c
@@ -48,6 +48,12 @@ static struct acrypto_capability prov_caps[] = {
 		
 		{ACRYPTO_OP_ENCRYPT, ACRYPTO_TYPE_AES_128, ACRYPTO_MODE_CBC, 1000},
 		{ACRYPTO_OP_DECRYPT, ACRYPTO_TYPE_AES_128, ACRYPTO_MODE_CBC, 1000},
+		
+		{ACRYPTO_OP_ENCRYPT, ACRYPTO_TYPE_AES_192, ACRYPTO_MODE_CBC, 1000},
+		{ACRYPTO_OP_DECRYPT, ACRYPTO_TYPE_AES_192, ACRYPTO_MODE_CBC, 1000},
+		
+		{ACRYPTO_OP_ENCRYPT, ACRYPTO_TYPE_AES_256, ACRYPTO_MODE_CBC, 1000},
+		{ACRYPTO_OP_DECRYPT, ACRYPTO_TYPE_AES_256, ACRYPTO_MODE_CBC, 1000},
 };
 static int prov_cap_number = sizeof(prov_caps)/sizeof(prov_caps[0]);
 

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061224004756</emailId><senderName>markus reichelt</senderName><senderEmail>ml@mareichelt.de</senderEmail><timestampReceived>2006-12-24 00:47:56-0400</timestampReceived><subject>Re: LUKS and loop-AES</subject><body>

* "Leo B." &lt;spam-goes-to-dev-null@gmx.net&gt; wrote:

&gt; I will set up a fileserver configuration with &gt; 1 TB disks in two
&gt; weeks and I'm also wondering if I might use LUKS already because
&gt; that configuration will be used for several years.

IF it's not too late...

I still consider dm-crypt as beta soft at best and thus don't regard
it as suitable for a production system. Compared to loop-aes it lacks
stability and is less secure, an ongoing patchwork towards a somewhat
secure crypto implementation.

In 2.6.18.6 they fixed a bug causing data corruption on RAID5, see
http://www.uwsg.indiana.edu/hypermail/linux/kernel/0612.2/0606.html

OTOH, I don't know how things (for loop-aes) might look if the kernel
gurus decide to drop loop support altogether (e.g. remove loop
support from mainline kernels). Looks like this isn't gonna happen in
the near future. I know some dm-cryp guys claim to have successfully
switched from loop-aes to dm-crypt and written howtos about it.

--=20
left blank, right bald

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20061201131915</emailId><senderName>Jan Glauber</senderName><senderEmail>jan.glauber@de.ibm.com</senderEmail><timestampReceived>2006-12-01 13:19:15-0400</timestampReceived><subject>[RFC][PATCH] Pseudo-random number generator</subject><body>

New s390 machines have hardware support for the generation of pseudo-random
numbers. This patch implements a simple char driver that exports this numbers
to user-space. Other possible implementations would have been:

* using the new hwrandom number generator API
PRO: reuse of an existing interface
CON: this API is for "truly" random data, not for pseudo-random numbers

* merging the s390 PRNG with the random pool implementation
PRO: no new interface, random numbers can be read through /dev/urandom
CON: complex implementation, could only use traditional /dev/urandom algorithm
     or hardware-accelerated implementation

I've chosen the char driver since it allows the user to decide which pseudo-random
numbers he wants to use. That means there is a new interface for the s390
PRNG, called /dev/prandom.

I would like to know if there are any objections, especially with the chosen device
name.

	Jan

---
 arch/s390/crypto/Makefile           |    1 
 arch/s390/crypto/crypt_s390.h       |    3 
 arch/s390/crypto/crypt_s390_query.c |    2 
 arch/s390/crypto/prng.c             |  206 ++++++++++++++++++++++++++++++++++++
 arch/s390/defconfig                 |    1 
 drivers/s390/Kconfig                |    7 +
 include/asm-s390/timex.h            |   12 ++
 7 files changed, 231 insertions(+), 1 deletion(-)

diff -urNp linux-2.5/arch/s390/crypto/Makefile \
                linux-2.5_prng/arch/s390/crypto/Makefile
--- linux-2.5/arch/s390/crypto/Makefile	2005-12-06 16:11:12.000000000 +0100
+++ linux-2.5_prng/arch/s390/crypto/Makefile	2006-12-01 13:04:27.000000000 +0100
@@ -6,5 +6,6 @@ obj-$(CONFIG_CRYPTO_SHA1_S390) += sha1_s
 obj-$(CONFIG_CRYPTO_SHA256_S390) += sha256_s390.o
 obj-$(CONFIG_CRYPTO_DES_S390) += des_s390.o des_check_key.o
 obj-$(CONFIG_CRYPTO_AES_S390) += aes_s390.o
+obj-$(CONFIG_S390_PRNG) += prng.o
 
 obj-$(CONFIG_CRYPTO_TEST) += crypt_s390_query.o
diff -urNp linux-2.5/arch/s390/crypto/crypt_s390.h \
                linux-2.5_prng/arch/s390/crypto/crypt_s390.h
--- linux-2.5/arch/s390/crypto/crypt_s390.h	2006-12-01 12:54:23.000000000 +0100
+++ linux-2.5_prng/arch/s390/crypto/crypt_s390.h	2006-12-01 13:05:26.000000000 +0100
@@ -68,6 +68,7 @@ enum crypt_s390_kmc_func {
 	KMC_AES_192_DECRYPT  = CRYPT_S390_KMC | 0x13 | 0x80,
 	KMC_AES_256_ENCRYPT  = CRYPT_S390_KMC | 0x14,
 	KMC_AES_256_DECRYPT  = CRYPT_S390_KMC | 0x14 | 0x80,
+	KMC_PRNG	     = CRYPT_S390_KMC | 0x43,
 };
 
 /* function codes for KIMD (COMPUTE INTERMEDIATE MESSAGE DIGEST)
@@ -147,7 +148,7 @@ crypt_s390_km(long func, void* param, u8
  * @param src: address of source memory area
  * @param src_len: length of src operand in bytes
  * @returns &lt; zero for failure, 0 for the query func, number of processed bytes
- * 	for encryption/decryption funcs
+ *	for encryption/decryption funcs
  */
 static inline int
 crypt_s390_kmc(long func, void* param, u8* dest, const u8* src, long src_len)
diff -urNp linux-2.5/arch/s390/crypto/crypt_s390_query.c \
                linux-2.5_prng/arch/s390/crypto/crypt_s390_query.c
--- linux-2.5/arch/s390/crypto/crypt_s390_query.c	2006-06-19 14:01:10.000000000 +0200
+++ linux-2.5_prng/arch/s390/crypto/crypt_s390_query.c	2006-12-01 13:05:46.000000000 \
+0100 @@ -54,6 +54,8 @@ static void query_available_functions(vo
 		crypt_s390_func_available(KMC_AES_192_ENCRYPT));
 	printk(KERN_INFO "KMC_AES_256: %d\n",
 		crypt_s390_func_available(KMC_AES_256_ENCRYPT));
+	printk(KERN_INFO "KMC_PRNG: %d\n",
+		crypt_s390_func_available(KMC_PRNG));
 
 	/* query available KIMD functions */
 	printk(KERN_INFO "KIMD_QUERY: %d\n",
diff -urNp linux-2.5/arch/s390/crypto/prng.c linux-2.5_prng/arch/s390/crypto/prng.c
--- linux-2.5/arch/s390/crypto/prng.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.5_prng/arch/s390/crypto/prng.c	2006-12-01 13:06:50.000000000 +0100
@@ -0,0 +1,206 @@
+/*
+ * Copyright 2006 IBM Corporation
+ * Author(s): Jan Glauber &lt;jan.glauber@de.ibm.com&gt;
+ * Driver for the s390 pseudo random number generator
+ */
+#include &lt;linux/fs.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/miscdevice.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/moduleparam.h&gt;
+#include &lt;linux/random.h&gt;
+#include &lt;asm/debug.h&gt;
+#include &lt;asm/uaccess.h&gt;
+
+#include "crypt_s390.h"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jan Glauber &lt;jan.glauber@de.ibm.com&gt;");
+MODULE_DESCRIPTION("s390 PRNG interface");
+
+static int prng_chunk_size = 32;
+module_param(prng_chunk_size, int, 0);
+MODULE_PARM_DESC(prng_chunk_size, "PRNG read chunk size in bytes");
+
+static int prng_entropy_limit = 4096;
+module_param(prng_entropy_limit, int, 0);
+MODULE_PARM_DESC(prng_entropy_limit, "PRNG add entropy after that much bytes were \
produced"); +
+/*
+ * Any one who considers arithmetical methods of producing random digits is,
+ * of course, in a state of sin. -- John von Neumann
+ */
+
+struct s390_prng_data {
+	unsigned long count; /* how many bytes were produced */
+	char *buf;
+};
+
+struct s390_prng_data *p;
+
+/* copied from libica, use a non-zero initial parameter block */
+unsigned char parm_block[32] = {
+0x0F,0x2B,0x8E,0x63,0x8C,0x8E,0xD2,0x52,0x64,0xB7,0xA0,0x7B,0x75,0x28,0xB8,0xF4,
+0x75,0x5F,0xD2,0xA6,0x8D,0x97,0x11,0xFF,0x49,0xD8,0x23,0xF3,0x7E,0x21,0xEC,0xA0,
+};
+
+static int prng_open(struct inode *inode, struct file *file)
+{
+	return nonseekable_open(inode, file);
+}
+
+static void prng_add_entropy(void)
+{
+	__u64 entropy[4];
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i &lt; 16; i++) {
+		entropy[0] = get_clock();
+		entropy[1] = get_clock();
+		entropy[2] = get_clock();
+		entropy[3] = get_clock();
+		ret = crypt_s390_kmc(KMC_PRNG, parm_block, (char *)entropy,
+				     (char *)entropy, sizeof(entropy));
+		BUG_ON(ret &lt; 0 || ret != sizeof(entropy));
+		memcpy(parm_block, entropy, sizeof(entropy));
+        }
+}
+
+static ssize_t prng_read(struct file *file, char __user *ubuf, size_t nbytes,
+			 loff_t *ppos)
+{
+	unsigned long long clock[2];
+	int chunk, n, x;
+	int ret = 0;
+	int tmp;
+
+	/* nbytes can be arbitrary long, we spilt it into chunks */
+	while (nbytes) {
+		/* same as in extract_entropy_user in random.c */
+		if (need_resched()) {
+			if (signal_pending(current)) {
+				if (ret == 0)
+					ret = -ERESTARTSYS;
+				break;
+			}
+			schedule();
+		}
+
+		/*
+		 * we lose some random bytes if an attacker issues
+		 * reads &lt; 8 bytes, but we don't care
+		 */
+		chunk = min_t(int, nbytes, prng_chunk_size);
+
+		/* PRNG only likes multiples of 8 bytes */
+		n = (chunk + 7) &amp; -8;
+
+		if (p-&gt;count &gt; prng_entropy_limit)
+			prng_add_entropy();
+
+		/*
+		 * It shouldn't weaken the quality of the random numbers
+		 * passing the full 16 bytes from STCKE to the generator.
+		 */
+		for (x=0; x &lt; n/16; x+=2) {
+			get_clock_extended(&amp;clock);
+			*(__u64 *)(p-&gt;buf + x*8) = clock[0];
+			*(__u64 *)(p-&gt;buf + x*8 + 88) = clock[1];
+		}
+		if (n % 16) {
+			get_clock_extended(&amp;clock);
+			*(__u64 *)(p-&gt;buf + x*8) = clock[0];
+		}
+
+		tmp = crypt_s390_kmc(KMC_PRNG, parm_block, p-&gt;buf, p-&gt;buf, n);
+		BUG_ON((tmp &lt; 0) || (tmp != n));
+
+		p-&gt;count += n;
+
+		if (copy_to_user(ubuf, p-&gt;buf, chunk))
+			return -EFAULT;
+
+		nbytes -= chunk;
+		ret += chunk;
+		ubuf += chunk;
+	}
+	return ret;
+}
+
+static struct file_operations prng_fops = {
+	.owner		= THIS_MODULE,
+	.open		= &amp;prng_open,
+	.release	= NULL,
+	.read		= &amp;prng_read,
+};
+
+static struct miscdevice prng_dev = {
+	.name	= "prandom",
+	.minor	= MISC_DYNAMIC_MINOR,
+	.fops	= &amp;prng_fops,
+};
+
+static int __init prng_init(void)
+{
+	int nbytes = 16;
+	char buf[nbytes];
+        int i = 0;
+	int ret;
+
+	/* check if the CPU has a PRNG */
+	if (!crypt_s390_func_available(KMC_PRNG))
+		return -ENOTSUPP;
+
+	/* initialize the PRNG, add 128 bits of entropy */
+	get_random_bytes(buf, 16);
+	while (nbytes &gt;= 8) {
+		*((__u64 *)parm_block) ^= *((__u64 *)buf+i*8);
+		prng_add_entropy();
+		i += 8;
+		nbytes -= 8;
+	}
+	prng_add_entropy();
+
+	ret = misc_register(&amp;prng_dev);
+	if (ret) {
+		printk(KERN_WARNING
+		       "s390 PRNG driver not loaded. Could not register misc device.\n");
+		goto out;
+	}
+
+	p = kmalloc(sizeof(struct s390_prng_data), GFP_KERNEL);
+	if (!p) {
+		ret = -ENOMEM;
+		goto out_dev;
+	}
+	p-&gt;count = 0;
+
+        p-&gt;buf = kmalloc(prng_chunk_size, GFP_KERNEL);
+        if (!p-&gt;buf) {
+                ret = -ENOMEM;
+		goto out_free;
+	}
+	return 0;
+
+out_free:
+	kfree(p);
+out_dev:
+	misc_deregister(&amp;prng_dev);
+out:
+	return ret;
+}
+
+static void __exit prng_exit(void)
+{
+	/* wipe me */
+	memset(p-&gt;buf, 0, prng_chunk_size);
+	kfree(p-&gt;buf);
+	kfree(p);
+
+	misc_deregister(&amp;prng_dev);
+}
+
+module_init(prng_init);
+module_exit(prng_exit);
diff -urNp linux-2.5/arch/s390/defconfig linux-2.5_prng/arch/s390/defconfig
--- linux-2.5/arch/s390/defconfig	2006-12-01 12:54:23.000000000 +0100
+++ linux-2.5_prng/arch/s390/defconfig	2006-12-01 13:04:27.000000000 +0100
@@ -437,6 +437,7 @@ CONFIG_MONWRITER=m
 #
 CONFIG_ZCRYPT=m
 # CONFIG_ZCRYPT_MONOLITHIC is not set
+CONFIG_S390_PRNG=m
 
 #
 # Network device support
diff -urNp linux-2.5/drivers/s390/Kconfig linux-2.5_prng/drivers/s390/Kconfig
--- linux-2.5/drivers/s390/Kconfig	2006-08-21 13:54:41.000000000 +0200
+++ linux-2.5_prng/drivers/s390/Kconfig	2006-12-01 13:04:27.000000000 +0100
@@ -244,4 +244,11 @@ config ZCRYPT_MONOLITHIC
 	  that contains all parts of the crypto device driver (ap bus,
 	  request router and all the card drivers).
 
+config S390_PRNG
+	tristate "Support for pseudo random number generator device driver"
+	help
+	  Select this option if you want to use the s390 pseudo random number generator.
+	  The PRNG is part of the cryptograhic processor functions and produces
+	  ANSI X9.17 conform numbers. The PRNG is usable via the char device /dev/prandom.
+
 endmenu
diff -urNp linux-2.5/include/asm-s390/timex.h linux-2.5_prng/include/asm-s390/timex.h
--- linux-2.5/include/asm-s390/timex.h	2006-11-28 12:40:12.000000000 +0100
+++ linux-2.5_prng/include/asm-s390/timex.h	2006-12-01 13:04:27.000000000 +0100
@@ -62,6 +62,18 @@ static inline unsigned long long get_clo
 	return clk;
 }
 
+static inline void get_clock_extended(void *dest)
+{
+	typedef struct { unsigned long long clk[2]; } clock_t;
+
+#if __GNUC__ &gt; 3 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt; 2)
+	asm volatile("stcke %0" : "=Q" (*((clock_t *)dest)) : : "cc");
+#else /* __GNUC__ */
+	asm volatile("stcke 0(%1)" : "=m" (*((clock_t *)dest))
+				   : "a" ((clock_t *)dest) : "cc");
+#endif /* __GNUC__ */
+}
+
 static inline cycles_t get_cycles(void)
 {
 	return (cycles_t) get_clock() &gt;&gt; 2;


-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


</body></email><email><emailId>20061214125601</emailId><senderName>David Howells</senderName><senderEmail>dhowells@redhat.com</senderEmail><timestampReceived>2006-12-14 12:56:01-0400</timestampReceived><subject>[PATCH 2/2] FCrypt encryption module</subject><body>

Add a crypto module to provide FCrypt encryption as used by RxRPC.

Signed-Off-By: David Howells &lt;dhowells@redhat.com&gt;
---

 crypto/Kconfig  |    7 +
 crypto/Makefile |    1 
 crypto/fcrypt.c |  423 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 crypto/tcrypt.c |   16 ++
 crypto/tcrypt.h |  128 +++++++++++++++++
 5 files changed, 574 insertions(+), 1 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
index 9d3a44c..e2e1eb1 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -204,6 +204,13 @@ config CRYPTO_DES_S390
 	help
 	  DES cipher algorithm (FIPS 46-2), and Triple DES EDE (FIPS 46-3).
 
+config CRYPTO_FCRYPT
+	tristate "FCrypt cipher algorithm"
+	select CRYPTO_ALGAPI
+	select CRYPTO_BLKCIPHER
+	help
+	  FCrypt algorithm used by RxRPC.
+
 config CRYPTO_BLOWFISH
 	tristate "Blowfish cipher algorithm"
 	select CRYPTO_ALGAPI
diff --git a/crypto/Makefile b/crypto/Makefile
index 9ef048d..a3e1915 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -30,6 +30,7 @@ obj-$(CONFIG_CRYPTO_CBC) += cbc.o
 obj-$(CONFIG_CRYPTO_PCBC) += pcbc.o
 obj-$(CONFIG_CRYPTO_LRW) += lrw.o
 obj-$(CONFIG_CRYPTO_DES) += des.o
+obj-$(CONFIG_CRYPTO_FCRYPT) += fcrypt.o
 obj-$(CONFIG_CRYPTO_BLOWFISH) += blowfish.o
 obj-$(CONFIG_CRYPTO_TWOFISH) += twofish.o
 obj-$(CONFIG_CRYPTO_TWOFISH_COMMON) += twofish_common.o
diff --git a/crypto/fcrypt.c b/crypto/fcrypt.c
new file mode 100644
index 0000000..9c2bb53
--- /dev/null
+++ b/crypto/fcrypt.c
@@ -0,0 +1,423 @@
+/* FCrypt encryption algorithm
+ *
+ * Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * Based on code:
+ *
+ * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
+ * (Royal Institute of Technology, Stockholm, Sweden).
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/crypto.h&gt;
+
+#define ROUNDS 16
+
+struct fcrypt_ctx {
+	u32 sched[ROUNDS];
+};
+
+/* Rotate right two 32 bit numbers as a 56 bit number */
+#define ror56(hi, lo, n)					\
+do {								\
+	u32 t = lo &amp; ((1 &lt;&lt; n) - 1);				\
+	lo = (lo &gt;&gt; n) | ((hi &amp; ((1 &lt;&lt; n) - 1)) &lt;&lt; (32 - n));	\
+	hi = (hi &gt;&gt; n) | (t &lt;&lt; (24-n));				\
+} while(0)
+
+/* Rotate right one 64 bit number as a 56 bit number */
+#define ror56_64(k, n)						\
+do {								\
+	k = (k &gt;&gt; n) | ((k &amp; ((1 &lt;&lt; n) - 1)) &lt;&lt; (56 - n));	\
+} while(0)
+
+/*
+ * Sboxes for Feistel network derived from
+ * /afs/transarc.com/public/afsps/afs.rel31b.export-src/rxkad/sboxes.h
+ */
+#undef Z
+#define Z(x) __constant_be32_to_cpu(x &lt;&lt; 3)
+static const u32 sbox0[256] = {
+	Z(0xea), Z(0x7f), Z(0xb2), Z(0x64), Z(0x9d), Z(0xb0), Z(0xd9), Z(0x11),
+	Z(0xcd), Z(0x86), Z(0x86), Z(0x91), Z(0x0a), Z(0xb2), Z(0x93), Z(0x06),
+	Z(0x0e), Z(0x06), Z(0xd2), Z(0x65), Z(0x73), Z(0xc5), Z(0x28), Z(0x60),
+	Z(0xf2), Z(0x20), Z(0xb5), Z(0x38), Z(0x7e), Z(0xda), Z(0x9f), Z(0xe3),
+	Z(0xd2), Z(0xcf), Z(0xc4), Z(0x3c), Z(0x61), Z(0xff), Z(0x4a), Z(0x4a),
+	Z(0x35), Z(0xac), Z(0xaa), Z(0x5f), Z(0x2b), Z(0xbb), Z(0xbc), Z(0x53),
+	Z(0x4e), Z(0x9d), Z(0x78), Z(0xa3), Z(0xdc), Z(0x09), Z(0x32), Z(0x10),
+	Z(0xc6), Z(0x6f), Z(0x66), Z(0xd6), Z(0xab), Z(0xa9), Z(0xaf), Z(0xfd),
+	Z(0x3b), Z(0x95), Z(0xe8), Z(0x34), Z(0x9a), Z(0x81), Z(0x72), Z(0x80),
+	Z(0x9c), Z(0xf3), Z(0xec), Z(0xda), Z(0x9f), Z(0x26), Z(0x76), Z(0x15),
+	Z(0x3e), Z(0x55), Z(0x4d), Z(0xde), Z(0x84), Z(0xee), Z(0xad), Z(0xc7),
+	Z(0xf1), Z(0x6b), Z(0x3d), Z(0xd3), Z(0x04), Z(0x49), Z(0xaa), Z(0x24),
+	Z(0x0b), Z(0x8a), Z(0x83), Z(0xba), Z(0xfa), Z(0x85), Z(0xa0), Z(0xa8),
+	Z(0xb1), Z(0xd4), Z(0x01), Z(0xd8), Z(0x70), Z(0x64), Z(0xf0), Z(0x51),
+	Z(0xd2), Z(0xc3), Z(0xa7), Z(0x75), Z(0x8c), Z(0xa5), Z(0x64), Z(0xef),
+	Z(0x10), Z(0x4e), Z(0xb7), Z(0xc6), Z(0x61), Z(0x03), Z(0xeb), Z(0x44),
+	Z(0x3d), Z(0xe5), Z(0xb3), Z(0x5b), Z(0xae), Z(0xd5), Z(0xad), Z(0x1d),
+	Z(0xfa), Z(0x5a), Z(0x1e), Z(0x33), Z(0xab), Z(0x93), Z(0xa2), Z(0xb7),
+	Z(0xe7), Z(0xa8), Z(0x45), Z(0xa4), Z(0xcd), Z(0x29), Z(0x63), Z(0x44),
+	Z(0xb6), Z(0x69), Z(0x7e), Z(0x2e), Z(0x62), Z(0x03), Z(0xc8), Z(0xe0),
+	Z(0x17), Z(0xbb), Z(0xc7), Z(0xf3), Z(0x3f), Z(0x36), Z(0xba), Z(0x71),
+	Z(0x8e), Z(0x97), Z(0x65), Z(0x60), Z(0x69), Z(0xb6), Z(0xf6), Z(0xe6),
+	Z(0x6e), Z(0xe0), Z(0x81), Z(0x59), Z(0xe8), Z(0xaf), Z(0xdd), Z(0x95),
+	Z(0x22), Z(0x99), Z(0xfd), Z(0x63), Z(0x19), Z(0x74), Z(0x61), Z(0xb1),
+	Z(0xb6), Z(0x5b), Z(0xae), Z(0x54), Z(0xb3), Z(0x70), Z(0xff), Z(0xc6),
+	Z(0x3b), Z(0x3e), Z(0xc1), Z(0xd7), Z(0xe1), Z(0x0e), Z(0x76), Z(0xe5),
+	Z(0x36), Z(0x4f), Z(0x59), Z(0xc7), Z(0x08), Z(0x6e), Z(0x82), Z(0xa6),
+	Z(0x93), Z(0xc4), Z(0xaa), Z(0x26), Z(0x49), Z(0xe0), Z(0x21), Z(0x64),
+	Z(0x07), Z(0x9f), Z(0x64), Z(0x81), Z(0x9c), Z(0xbf), Z(0xf9), Z(0xd1),
+	Z(0x43), Z(0xf8), Z(0xb6), Z(0xb9), Z(0xf1), Z(0x24), Z(0x75), Z(0x03),
+	Z(0xe4), Z(0xb0), Z(0x99), Z(0x46), Z(0x3d), Z(0xf5), Z(0xd1), Z(0x39),
+	Z(0x72), Z(0x12), Z(0xf6), Z(0xba), Z(0x0c), Z(0x0d), Z(0x42), Z(0x2e)
+};
+
+#undef Z
+#define Z(x) __constant_be32_to_cpu((x &lt;&lt; 27) | (x &gt;&gt; 5))
+static const u32 sbox1[256] = {
+	Z(0x77), Z(0x14), Z(0xa6), Z(0xfe), Z(0xb2), Z(0x5e), Z(0x8c), Z(0x3e),
+	Z(0x67), Z(0x6c), Z(0xa1), Z(0x0d), Z(0xc2), Z(0xa2), Z(0xc1), Z(0x85),
+	Z(0x6c), Z(0x7b), Z(0x67), Z(0xc6), Z(0x23), Z(0xe3), Z(0xf2), Z(0x89),
+	Z(0x50), Z(0x9c), Z(0x03), Z(0xb7), Z(0x73), Z(0xe6), Z(0xe1), Z(0x39),
+	Z(0x31), Z(0x2c), Z(0x27), Z(0x9f), Z(0xa5), Z(0x69), Z(0x44), Z(0xd6),
+	Z(0x23), Z(0x83), Z(0x98), Z(0x7d), Z(0x3c), Z(0xb4), Z(0x2d), Z(0x99),
+	Z(0x1c), Z(0x1f), Z(0x8c), Z(0x20), Z(0x03), Z(0x7c), Z(0x5f), Z(0xad),
+	Z(0xf4), Z(0xfa), Z(0x95), Z(0xca), Z(0x76), Z(0x44), Z(0xcd), Z(0xb6),
+	Z(0xb8), Z(0xa1), Z(0xa1), Z(0xbe), Z(0x9e), Z(0x54), Z(0x8f), Z(0x0b),
+	Z(0x16), Z(0x74), Z(0x31), Z(0x8a), Z(0x23), Z(0x17), Z(0x04), Z(0xfa),
+	Z(0x79), Z(0x84), Z(0xb1), Z(0xf5), Z(0x13), Z(0xab), Z(0xb5), Z(0x2e),
+	Z(0xaa), Z(0x0c), Z(0x60), Z(0x6b), Z(0x5b), Z(0xc4), Z(0x4b), Z(0xbc),
+	Z(0xe2), Z(0xaf), Z(0x45), Z(0x73), Z(0xfa), Z(0xc9), Z(0x49), Z(0xcd),
+	Z(0x00), Z(0x92), Z(0x7d), Z(0x97), Z(0x7a), Z(0x18), Z(0x60), Z(0x3d),
+	Z(0xcf), Z(0x5b), Z(0xde), Z(0xc6), Z(0xe2), Z(0xe6), Z(0xbb), Z(0x8b),
+	Z(0x06), Z(0xda), Z(0x08), Z(0x15), Z(0x1b), Z(0x88), Z(0x6a), Z(0x17),
+	Z(0x89), Z(0xd0), Z(0xa9), Z(0xc1), Z(0xc9), Z(0x70), Z(0x6b), Z(0xe5),
+	Z(0x43), Z(0xf4), Z(0x68), Z(0xc8), Z(0xd3), Z(0x84), Z(0x28), Z(0x0a),
+	Z(0x52), Z(0x66), Z(0xa3), Z(0xca), Z(0xf2), Z(0xe3), Z(0x7f), Z(0x7a),
+	Z(0x31), Z(0xf7), Z(0x88), Z(0x94), Z(0x5e), Z(0x9c), Z(0x63), Z(0xd5),
+	Z(0x24), Z(0x66), Z(0xfc), Z(0xb3), Z(0x57), Z(0x25), Z(0xbe), Z(0x89),
+	Z(0x44), Z(0xc4), Z(0xe0), Z(0x8f), Z(0x23), Z(0x3c), Z(0x12), Z(0x52),
+	Z(0xf5), Z(0x1e), Z(0xf4), Z(0xcb), Z(0x18), Z(0x33), Z(0x1f), Z(0xf8),
+	Z(0x69), Z(0x10), Z(0x9d), Z(0xd3), Z(0xf7), Z(0x28), Z(0xf8), Z(0x30),
+	Z(0x05), Z(0x5e), Z(0x32), Z(0xc0), Z(0xd5), Z(0x19), Z(0xbd), Z(0x45),
+	Z(0x8b), Z(0x5b), Z(0xfd), Z(0xbc), Z(0xe2), Z(0x5c), Z(0xa9), Z(0x96),
+	Z(0xef), Z(0x70), Z(0xcf), Z(0xc2), Z(0x2a), Z(0xb3), Z(0x61), Z(0xad),
+	Z(0x80), Z(0x48), Z(0x81), Z(0xb7), Z(0x1d), Z(0x43), Z(0xd9), Z(0xd7),
+	Z(0x45), Z(0xf0), Z(0xd8), Z(0x8a), Z(0x59), Z(0x7c), Z(0x57), Z(0xc1),
+	Z(0x79), Z(0xc7), Z(0x34), Z(0xd6), Z(0x43), Z(0xdf), Z(0xe4), Z(0x78),
+	Z(0x16), Z(0x06), Z(0xda), Z(0x92), Z(0x76), Z(0x51), Z(0xe1), Z(0xd4),
+	Z(0x70), Z(0x03), Z(0xe0), Z(0x2f), Z(0x96), Z(0x91), Z(0x82), Z(0x80)
+};
+
+#undef Z
+#define Z(x) __constant_be32_to_cpu(x &lt;&lt; 11)
+static const u32 sbox2[256] = {
+	Z(0xf0), Z(0x37), Z(0x24), Z(0x53), Z(0x2a), Z(0x03), Z(0x83), Z(0x86),
+	Z(0xd1), Z(0xec), Z(0x50), Z(0xf0), Z(0x42), Z(0x78), Z(0x2f), Z(0x6d),
+	Z(0xbf), Z(0x80), Z(0x87), Z(0x27), Z(0x95), Z(0xe2), Z(0xc5), Z(0x5d),
+	Z(0xf9), Z(0x6f), Z(0xdb), Z(0xb4), Z(0x65), Z(0x6e), Z(0xe7), Z(0x24),
+	Z(0xc8), Z(0x1a), Z(0xbb), Z(0x49), Z(0xb5), Z(0x0a), Z(0x7d), Z(0xb9),
+	Z(0xe8), Z(0xdc), Z(0xb7), Z(0xd9), Z(0x45), Z(0x20), Z(0x1b), Z(0xce),
+	Z(0x59), Z(0x9d), Z(0x6b), Z(0xbd), Z(0x0e), Z(0x8f), Z(0xa3), Z(0xa9),
+	Z(0xbc), Z(0x74), Z(0xa6), Z(0xf6), Z(0x7f), Z(0x5f), Z(0xb1), Z(0x68),
+	Z(0x84), Z(0xbc), Z(0xa9), Z(0xfd), Z(0x55), Z(0x50), Z(0xe9), Z(0xb6),
+	Z(0x13), Z(0x5e), Z(0x07), Z(0xb8), Z(0x95), Z(0x02), Z(0xc0), Z(0xd0),
+	Z(0x6a), Z(0x1a), Z(0x85), Z(0xbd), Z(0xb6), Z(0xfd), Z(0xfe), Z(0x17),
+	Z(0x3f), Z(0x09), Z(0xa3), Z(0x8d), Z(0xfb), Z(0xed), Z(0xda), Z(0x1d),
+	Z(0x6d), Z(0x1c), Z(0x6c), Z(0x01), Z(0x5a), Z(0xe5), Z(0x71), Z(0x3e),
+	Z(0x8b), Z(0x6b), Z(0xbe), Z(0x29), Z(0xeb), Z(0x12), Z(0x19), Z(0x34),
+	Z(0xcd), Z(0xb3), Z(0xbd), Z(0x35), Z(0xea), Z(0x4b), Z(0xd5), Z(0xae),
+	Z(0x2a), Z(0x79), Z(0x5a), Z(0xa5), Z(0x32), Z(0x12), Z(0x7b), Z(0xdc),
+	Z(0x2c), Z(0xd0), Z(0x22), Z(0x4b), Z(0xb1), Z(0x85), Z(0x59), Z(0x80),
+	Z(0xc0), Z(0x30), Z(0x9f), Z(0x73), Z(0xd3), Z(0x14), Z(0x48), Z(0x40),
+	Z(0x07), Z(0x2d), Z(0x8f), Z(0x80), Z(0x0f), Z(0xce), Z(0x0b), Z(0x5e),
+	Z(0xb7), Z(0x5e), Z(0xac), Z(0x24), Z(0x94), Z(0x4a), Z(0x18), Z(0x15),
+	Z(0x05), Z(0xe8), Z(0x02), Z(0x77), Z(0xa9), Z(0xc7), Z(0x40), Z(0x45),
+	Z(0x89), Z(0xd1), Z(0xea), Z(0xde), Z(0x0c), Z(0x79), Z(0x2a), Z(0x99),
+	Z(0x6c), Z(0x3e), Z(0x95), Z(0xdd), Z(0x8c), Z(0x7d), Z(0xad), Z(0x6f),
+	Z(0xdc), Z(0xff), Z(0xfd), Z(0x62), Z(0x47), Z(0xb3), Z(0x21), Z(0x8a),
+	Z(0xec), Z(0x8e), Z(0x19), Z(0x18), Z(0xb4), Z(0x6e), Z(0x3d), Z(0xfd),
+	Z(0x74), Z(0x54), Z(0x1e), Z(0x04), Z(0x85), Z(0xd8), Z(0xbc), Z(0x1f),
+	Z(0x56), Z(0xe7), Z(0x3a), Z(0x56), Z(0x67), Z(0xd6), Z(0xc8), Z(0xa5),
+	Z(0xf3), Z(0x8e), Z(0xde), Z(0xae), Z(0x37), Z(0x49), Z(0xb7), Z(0xfa),
+	Z(0xc8), Z(0xf4), Z(0x1f), Z(0xe0), Z(0x2a), Z(0x9b), Z(0x15), Z(0xd1),
+	Z(0x34), Z(0x0e), Z(0xb5), Z(0xe0), Z(0x44), Z(0x78), Z(0x84), Z(0x59),
+	Z(0x56), Z(0x68), Z(0x77), Z(0xa5), Z(0x14), Z(0x06), Z(0xf5), Z(0x2f),
+	Z(0x8c), Z(0x8a), Z(0x73), Z(0x80), Z(0x76), Z(0xb4), Z(0x10), Z(0x86)
+};
+
+#undef Z
+#define Z(x) __constant_be32_to_cpu(x &lt;&lt; 19)
+static const u32 sbox3[256] = {
+	Z(0xa9), Z(0x2a), Z(0x48), Z(0x51), Z(0x84), Z(0x7e), Z(0x49), Z(0xe2),
+	Z(0xb5), Z(0xb7), Z(0x42), Z(0x33), Z(0x7d), Z(0x5d), Z(0xa6), Z(0x12),
+	Z(0x44), Z(0x48), Z(0x6d), Z(0x28), Z(0xaa), Z(0x20), Z(0x6d), Z(0x57),
+	Z(0xd6), Z(0x6b), Z(0x5d), Z(0x72), Z(0xf0), Z(0x92), Z(0x5a), Z(0x1b),
+	Z(0x53), Z(0x80), Z(0x24), Z(0x70), Z(0x9a), Z(0xcc), Z(0xa7), Z(0x66),
+	Z(0xa1), Z(0x01), Z(0xa5), Z(0x41), Z(0x97), Z(0x41), Z(0x31), Z(0x82),
+	Z(0xf1), Z(0x14), Z(0xcf), Z(0x53), Z(0x0d), Z(0xa0), Z(0x10), Z(0xcc),
+	Z(0x2a), Z(0x7d), Z(0xd2), Z(0xbf), Z(0x4b), Z(0x1a), Z(0xdb), Z(0x16),
+	Z(0x47), Z(0xf6), Z(0x51), Z(0x36), Z(0xed), Z(0xf3), Z(0xb9), Z(0x1a),
+	Z(0xa7), Z(0xdf), Z(0x29), Z(0x43), Z(0x01), Z(0x54), Z(0x70), Z(0xa4),
+	Z(0xbf), Z(0xd4), Z(0x0b), Z(0x53), Z(0x44), Z(0x60), Z(0x9e), Z(0x23),
+	Z(0xa1), Z(0x18), Z(0x68), Z(0x4f), Z(0xf0), Z(0x2f), Z(0x82), Z(0xc2),
+	Z(0x2a), Z(0x41), Z(0xb2), Z(0x42), Z(0x0c), Z(0xed), Z(0x0c), Z(0x1d),
+	Z(0x13), Z(0x3a), Z(0x3c), Z(0x6e), Z(0x35), Z(0xdc), Z(0x60), Z(0x65),
+	Z(0x85), Z(0xe9), Z(0x64), Z(0x02), Z(0x9a), Z(0x3f), Z(0x9f), Z(0x87),
+	Z(0x96), Z(0xdf), Z(0xbe), Z(0xf2), Z(0xcb), Z(0xe5), Z(0x6c), Z(0xd4),
+	Z(0x5a), Z(0x83), Z(0xbf), Z(0x92), Z(0x1b), Z(0x94), Z(0x00), Z(0x42),
+	Z(0xcf), Z(0x4b), Z(0x00), Z(0x75), Z(0xba), Z(0x8f), Z(0x76), Z(0x5f),
+	Z(0x5d), Z(0x3a), Z(0x4d), Z(0x09), Z(0x12), Z(0x08), Z(0x38), Z(0x95),
+	Z(0x17), Z(0xe4), Z(0x01), Z(0x1d), Z(0x4c), Z(0xa9), Z(0xcc), Z(0x85),
+	Z(0x82), Z(0x4c), Z(0x9d), Z(0x2f), Z(0x3b), Z(0x66), Z(0xa1), Z(0x34),
+	Z(0x10), Z(0xcd), Z(0x59), Z(0x89), Z(0xa5), Z(0x31), Z(0xcf), Z(0x05),
+	Z(0xc8), Z(0x84), Z(0xfa), Z(0xc7), Z(0xba), Z(0x4e), Z(0x8b), Z(0x1a),
+	Z(0x19), Z(0xf1), Z(0xa1), Z(0x3b), Z(0x18), Z(0x12), Z(0x17), Z(0xb0),
+	Z(0x98), Z(0x8d), Z(0x0b), Z(0x23), Z(0xc3), Z(0x3a), Z(0x2d), Z(0x20),
+	Z(0xdf), Z(0x13), Z(0xa0), Z(0xa8), Z(0x4c), Z(0x0d), Z(0x6c), Z(0x2f),
+	Z(0x47), Z(0x13), Z(0x13), Z(0x52), Z(0x1f), Z(0x2d), Z(0xf5), Z(0x79),
+	Z(0x3d), Z(0xa2), Z(0x54), Z(0xbd), Z(0x69), Z(0xc8), Z(0x6b), Z(0xf3),
+	Z(0x05), Z(0x28), Z(0xf1), Z(0x16), Z(0x46), Z(0x40), Z(0xb0), Z(0x11),
+	Z(0xd3), Z(0xb7), Z(0x95), Z(0x49), Z(0xcf), Z(0xc3), Z(0x1d), Z(0x8f),
+	Z(0xd8), Z(0xe1), Z(0x73), Z(0xdb), Z(0xad), Z(0xc8), Z(0xc9), Z(0xa9),
+	Z(0xa1), Z(0xc2), Z(0xc5), Z(0xe3), Z(0xba), Z(0xfc), Z(0x0e), Z(0x25)
+};
+
+/*
+ * This is a 16 round Feistel network with permutation F_ENCRYPT
+ */
+#define F_ENCRYPT(R, L, sched)						\
+do {									\
+	union lc4 { u32 l; u8 c[4]; } u;				\
+	u.l = sched ^ R;						\
+	L ^= sbox0[u.c[0]] ^ sbox1[u.c[1]] ^ sbox2[u.c[2]] ^ sbox3[u.c[3]]; \
+} while(0)
+
+/*
+ * encryptor
+ */
+static void fcrypt_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
+{
+	const struct fcrypt_ctx *ctx = crypto_tfm_ctx(tfm);
+	struct {
+		u32 l, r;
+	} X;
+
+	memcpy(&amp;X, src, sizeof(X));
+
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x0]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x1]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x2]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x3]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x4]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x5]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x6]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x7]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x8]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x9]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xa]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xb]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xc]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xd]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xe]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xf]);
+
+	memcpy(dst, &amp;X, sizeof(X));
+}
+
+/*
+ * decryptor
+ */
+static void fcrypt_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
+{
+	const struct fcrypt_ctx *ctx = crypto_tfm_ctx(tfm);
+	struct {
+		u32 l, r;
+	} X;
+
+	memcpy(&amp;X, src, sizeof(X));
+
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xf]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xe]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xd]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xc]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xb]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xa]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x9]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x8]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x7]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x6]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x5]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x4]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x3]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x2]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x1]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x0]);
+
+	memcpy(dst, &amp;X, sizeof(X));
+}
+
+/*
+ * Generate a key schedule from key, the least significant bit in each key byte
+ * is parity and shall be ignored. This leaves 56 significant bits in the key
+ * to scatter over the 16 key schedules. For each schedule extract the low
+ * order 32 bits and use as schedule, then rotate right by 11 bits.
+ */
+static int fcrypt_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
+{
+	struct fcrypt_ctx *ctx = crypto_tfm_ctx(tfm);
+
+#if BITS_PER_LONG == 64  /* the 64-bit version can also be used for 32-bit
+			  * kernels - it seems to be faster but the code is
+			  * larger */
+
+	u64 k;	/* k holds all 56 non-parity bits */
+
+	/* discard the parity bits */
+	k = (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key) &gt;&gt; 1;
+
+	/* Use lower 32 bits for schedule, rotate by 11 each round (16 times) */
+	ctx-&gt;sched[0x0] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x1] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x2] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x3] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x4] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x5] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x6] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x7] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x8] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x9] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xa] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xb] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xc] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xd] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xe] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xf] = be32_to_cpu(k);
+
+	return 0;
+#else
+	u32 hi, lo;		/* hi is upper 24 bits and lo lower 32, total 56 */
+
+	/* discard the parity bits */
+	lo = (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	hi = lo &gt;&gt; 4;
+	lo &amp;= 0xf;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key) &gt;&gt; 1;
+
+	/* Use lower 32 bits for schedule, rotate by 11 each round (16 times) */
+	ctx-&gt;sched[0x0] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x1] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x2] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x3] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x4] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x5] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x6] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x7] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x8] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x9] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xa] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xb] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xc] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xd] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xe] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xf] = be32_to_cpu(lo);
+	return 0;
+#endif
+}
+
+static struct crypto_alg fcrypt_alg = {
+	.cra_name		=	"fcrypt",
+	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize		=	8,
+	.cra_ctxsize		=	sizeof(struct fcrypt_ctx),
+	.cra_module		=	THIS_MODULE,
+	.cra_alignmask		=	3,
+	.cra_list		=	LIST_HEAD_INIT(fcrypt_alg.cra_list),
+	.cra_u			=	{ .cipher = {
+	.cia_min_keysize	=	8,
+	.cia_max_keysize	=	8,
+	.cia_setkey		=	fcrypt_setkey,
+	.cia_encrypt		=	fcrypt_encrypt,
+	.cia_decrypt		=	fcrypt_decrypt } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;fcrypt_alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;fcrypt_alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("FCrypt Cipher Algorithm");
+MODULE_AUTHOR("David Howells &lt;dhowells@redhat.com&gt;");
diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
index d671e89..eef0516 100644
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -71,7 +71,8 @@ static char *check[] = {
 	"des", "md5", "des3_ede", "rot13", "sha1", "sha256", "blowfish",
 	"twofish", "serpent", "sha384", "sha512", "md4", "aes", "cast6",
 	"arc4", "michael_mic", "deflate", "crc32c", "tea", "xtea",
-	"khazad", "wp512", "wp384", "wp256", "tnepres", "xeta", NULL
+	"khazad", "wp512", "wp384", "wp256", "tnepres", "xeta",  "fcrypt",
+	NULL
 };
 
 static void hexdump(unsigned char *buf, unsigned int len)
@@ -964,6 +965,12 @@ static void do_test(void)
 		test_cipher("ecb(xeta)", DECRYPT, xeta_dec_tv_template,
 			    XETA_DEC_TEST_VECTORS);
 
+		//FCrypt
+		test_cipher("pcbc(fcrypt)", ENCRYPT, fcrypt_pcbc_enc_tv_template,
+			    FCRYPT_ENC_TEST_VECTORS);
+		test_cipher("pcbc(fcrypt)", DECRYPT, fcrypt_pcbc_dec_tv_template,
+			    FCRYPT_DEC_TEST_VECTORS);
+
 		test_hash("sha384", sha384_tv_template, SHA384_TEST_VECTORS);
 		test_hash("sha512", sha512_tv_template, SHA512_TEST_VECTORS);
 		test_hash("wp512", wp512_tv_template, WP512_TEST_VECTORS);
@@ -1177,6 +1184,13 @@ static void do_test(void)
 			    XETA_DEC_TEST_VECTORS);
 		break;
 
+	case 31:
+		test_cipher("pcbc(fcrypt)", ENCRYPT, fcrypt_pcbc_enc_tv_template,
+			    FCRYPT_ENC_TEST_VECTORS);
+		test_cipher("pcbc(fcrypt)", DECRYPT, fcrypt_pcbc_dec_tv_template,
+			    FCRYPT_DEC_TEST_VECTORS);
+		break;
+
 	case 100:
 		test_hash("hmac(md5)", hmac_md5_tv_template,
 			  HMAC_MD5_TEST_VECTORS);
diff --git a/crypto/tcrypt.h b/crypto/tcrypt.h
index 48a8136..688cbeb 100644
--- a/crypto/tcrypt.h
+++ b/crypto/tcrypt.h
@@ -3316,6 +3316,134 @@ static struct cipher_testvec xeta_dec_tv
 	}
 };
 
+/* 
+ * FCrypt test vectors 
+ */
+#define FCRYPT_ENC_TEST_VECTORS	ARRAY_SIZE(fcrypt_pcbc_enc_tv_template)
+#define FCRYPT_DEC_TEST_VECTORS	ARRAY_SIZE(fcrypt_pcbc_dec_tv_template)
+
+static struct cipher_testvec fcrypt_pcbc_enc_tv_template[] = {
+	{ /* http://www.openafs.org/pipermail/openafs-devel/2000-December/005320.html */
+		.key	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.klen	= 8,
+		.iv	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.input	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.ilen	= 8,
+		.result	= { 0x0E, 0x09, 0x00, 0xC7, 0x3E, 0xF7, 0xED, 0x41 },
+		.rlen	= 8,
+	}, {
+		.key	= { 0x11, 0x44, 0x77, 0xAA, 0xDD, 0x00, 0x33, 0x66 },
+		.klen	= 8,
+		.iv	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.input	= { 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0 },
+		.ilen	= 8,
+		.result	= { 0xD8, 0xED, 0x78, 0x74, 0x77, 0xEC, 0x06, 0x80 },
+		.rlen	= 8,
+	}, { /* From Arla */
+		.key	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.klen	= 8,
+		.iv	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.input	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.ilen	= 48,
+		.result	= { 0x00, 0xf0, 0xe,  0x11, 0x75, 0xe6, 0x23, 0x82,
+			    0xee, 0xac, 0x98, 0x62, 0x44, 0x51, 0xe4, 0x84,
+			    0xc3, 0x59, 0xd8, 0xaa, 0x64, 0x60, 0xae, 0xf7,
+			    0xd2, 0xd9, 0x13, 0x79, 0x72, 0xa3, 0x45, 0x03,
+			    0x23, 0xb5, 0x62, 0xd7, 0x0c, 0xf5, 0x27, 0xd1,
+			    0xf8, 0x91, 0x3c, 0xac, 0x44, 0x22, 0x92, 0xef },
+		.rlen	= 48,
+	}, {
+		.key	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.klen	= 8,
+		.iv	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.input	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.ilen	= 48,
+		.result	= { 0xca, 0x90, 0xf5, 0x9d, 0xcb, 0xd4, 0xd2, 0x3c,
+			    0x01, 0x88, 0x7f, 0x3e, 0x31, 0x6e, 0x62, 0x9d,
+			    0xd8, 0xe0, 0x57, 0xa3, 0x06, 0x3a, 0x42, 0x58,
+			    0x2a, 0x28, 0xfe, 0x72, 0x52, 0x2f, 0xdd, 0xe0,
+			    0x19, 0x89, 0x09, 0x1c, 0x2a, 0x8e, 0x8c, 0x94,
+			    0xfc, 0xc7, 0x68, 0xe4, 0x88, 0xaa, 0xde, 0x0f },
+		.rlen	= 48,
+	}, { /* split-page version */
+		.key	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.klen	= 8,
+		.iv	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.input	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.ilen	= 48,
+		.result	= { 0xca, 0x90, 0xf5, 0x9d, 0xcb, 0xd4, 0xd2, 0x3c,
+			    0x01, 0x88, 0x7f, 0x3e, 0x31, 0x6e, 0x62, 0x9d,
+			    0xd8, 0xe0, 0x57, 0xa3, 0x06, 0x3a, 0x42, 0x58,
+			    0x2a, 0x28, 0xfe, 0x72, 0x52, 0x2f, 0xdd, 0xe0,
+			    0x19, 0x89, 0x09, 0x1c, 0x2a, 0x8e, 0x8c, 0x94,
+			    0xfc, 0xc7, 0x68, 0xe4, 0x88, 0xaa, 0xde, 0x0f },
+		.rlen	= 48,
+		.np	= 2,
+		.tap	= { 20, 28 },
+	}
+};
+
+static struct cipher_testvec fcrypt_pcbc_dec_tv_template[] = {
+	{ /* http://www.openafs.org/pipermail/openafs-devel/2000-December/005320.html */
+		.key	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.klen	= 8,
+		.iv	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.input	= { 0x0E, 0x09, 0x00, 0xC7, 0x3E, 0xF7, 0xED, 0x41 },
+		.ilen	= 8,
+		.result	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.rlen	= 8,
+	}, {
+		.key	= { 0x11, 0x44, 0x77, 0xAA, 0xDD, 0x00, 0x33, 0x66 },
+		.klen	= 8,
+		.iv	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.input	= { 0xD8, 0xED, 0x78, 0x74, 0x77, 0xEC, 0x06, 0x80 },
+		.ilen	= 8,
+		.result	= { 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0 },
+		.rlen	= 8,
+	}, { /* From Arla */
+		.key	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.klen	= 8,
+		.iv	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.input	= { 0x00, 0xf0, 0xe,  0x11, 0x75, 0xe6, 0x23, 0x82,
+			    0xee, 0xac, 0x98, 0x62, 0x44, 0x51, 0xe4, 0x84,
+			    0xc3, 0x59, 0xd8, 0xaa, 0x64, 0x60, 0xae, 0xf7,
+			    0xd2, 0xd9, 0x13, 0x79, 0x72, 0xa3, 0x45, 0x03,
+			    0x23, 0xb5, 0x62, 0xd7, 0x0c, 0xf5, 0x27, 0xd1,
+			    0xf8, 0x91, 0x3c, 0xac, 0x44, 0x22, 0x92, 0xef },
+		.ilen	= 48,
+		.result	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.rlen	= 48,
+	}, {
+		.key	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.klen	= 8,
+		.iv	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.input	= { 0xca, 0x90, 0xf5, 0x9d, 0xcb, 0xd4, 0xd2, 0x3c,
+			    0x01, 0x88, 0x7f, 0x3e, 0x31, 0x6e, 0x62, 0x9d,
+			    0xd8, 0xe0, 0x57, 0xa3, 0x06, 0x3a, 0x42, 0x58,
+			    0x2a, 0x28, 0xfe, 0x72, 0x52, 0x2f, 0xdd, 0xe0,
+			    0x19, 0x89, 0x09, 0x1c, 0x2a, 0x8e, 0x8c, 0x94,
+			    0xfc, 0xc7, 0x68, 0xe4, 0x88, 0xaa, 0xde, 0x0f },
+		.ilen	= 48,
+		.result	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.rlen	= 48,
+	}, { /* split-page version */
+		.key	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.klen	= 8,
+		.iv	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.input	= { 0xca, 0x90, 0xf5, 0x9d, 0xcb, 0xd4, 0xd2, 0x3c,
+			    0x01, 0x88, 0x7f, 0x3e, 0x31, 0x6e, 0x62, 0x9d,
+			    0xd8, 0xe0, 0x57, 0xa3, 0x06, 0x3a, 0x42, 0x58,
+			    0x2a, 0x28, 0xfe, 0x72, 0x52, 0x2f, 0xdd, 0xe0,
+			    0x19, 0x89, 0x09, 0x1c, 0x2a, 0x8e, 0x8c, 0x94,
+			    0xfc, 0xc7, 0x68, 0xe4, 0x88, 0xaa, 0xde, 0x0f },
+		.ilen	= 48,
+		.result	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.rlen	= 48,
+		.np	= 2,
+		.tap	= { 20, 28 },
+	}
+};
+
 /*
  * Compression stuff.
  */
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>200612141256010</emailId><senderName>David Howells</senderName><senderEmail>dhowells@redhat.com</senderEmail><timestampReceived>2006-12-14 12:56:01-0400</timestampReceived><subject>[PATCH 2/2] FCrypt encryption module</subject><body>

Add a crypto module to provide FCrypt encryption as used by RxRPC.

Signed-Off-By: David Howells &lt;dhowells@redhat.com&gt;
---

 crypto/Kconfig  |    7 +
 crypto/Makefile |    1 
 crypto/fcrypt.c |  423 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 crypto/tcrypt.c |   16 ++
 crypto/tcrypt.h |  128 +++++++++++++++++
 5 files changed, 574 insertions(+), 1 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
index 9d3a44c..e2e1eb1 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -204,6 +204,13 @@ config CRYPTO_DES_S390
 	help
 	  DES cipher algorithm (FIPS 46-2), and Triple DES EDE (FIPS 46-3).
 
+config CRYPTO_FCRYPT
+	tristate "FCrypt cipher algorithm"
+	select CRYPTO_ALGAPI
+	select CRYPTO_BLKCIPHER
+	help
+	  FCrypt algorithm used by RxRPC.
+
 config CRYPTO_BLOWFISH
 	tristate "Blowfish cipher algorithm"
 	select CRYPTO_ALGAPI
diff --git a/crypto/Makefile b/crypto/Makefile
index 9ef048d..a3e1915 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -30,6 +30,7 @@ obj-$(CONFIG_CRYPTO_CBC) += cbc.o
 obj-$(CONFIG_CRYPTO_PCBC) += pcbc.o
 obj-$(CONFIG_CRYPTO_LRW) += lrw.o
 obj-$(CONFIG_CRYPTO_DES) += des.o
+obj-$(CONFIG_CRYPTO_FCRYPT) += fcrypt.o
 obj-$(CONFIG_CRYPTO_BLOWFISH) += blowfish.o
 obj-$(CONFIG_CRYPTO_TWOFISH) += twofish.o
 obj-$(CONFIG_CRYPTO_TWOFISH_COMMON) += twofish_common.o
diff --git a/crypto/fcrypt.c b/crypto/fcrypt.c
new file mode 100644
index 0000000..9c2bb53
--- /dev/null
+++ b/crypto/fcrypt.c
@@ -0,0 +1,423 @@
+/* FCrypt encryption algorithm
+ *
+ * Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * Based on code:
+ *
+ * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
+ * (Royal Institute of Technology, Stockholm, Sweden).
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/crypto.h&gt;
+
+#define ROUNDS 16
+
+struct fcrypt_ctx {
+	u32 sched[ROUNDS];
+};
+
+/* Rotate right two 32 bit numbers as a 56 bit number */
+#define ror56(hi, lo, n)					\
+do {								\
+	u32 t = lo &amp; ((1 &lt;&lt; n) - 1);				\
+	lo = (lo &gt;&gt; n) | ((hi &amp; ((1 &lt;&lt; n) - 1)) &lt;&lt; (32 - n));	\
+	hi = (hi &gt;&gt; n) | (t &lt;&lt; (24-n));				\
+} while(0)
+
+/* Rotate right one 64 bit number as a 56 bit number */
+#define ror56_64(k, n)						\
+do {								\
+	k = (k &gt;&gt; n) | ((k &amp; ((1 &lt;&lt; n) - 1)) &lt;&lt; (56 - n));	\
+} while(0)
+
+/*
+ * Sboxes for Feistel network derived from
+ * /afs/transarc.com/public/afsps/afs.rel31b.export-src/rxkad/sboxes.h
+ */
+#undef Z
+#define Z(x) __constant_be32_to_cpu(x &lt;&lt; 3)
+static const u32 sbox0[256] = {
+	Z(0xea), Z(0x7f), Z(0xb2), Z(0x64), Z(0x9d), Z(0xb0), Z(0xd9), Z(0x11),
+	Z(0xcd), Z(0x86), Z(0x86), Z(0x91), Z(0x0a), Z(0xb2), Z(0x93), Z(0x06),
+	Z(0x0e), Z(0x06), Z(0xd2), Z(0x65), Z(0x73), Z(0xc5), Z(0x28), Z(0x60),
+	Z(0xf2), Z(0x20), Z(0xb5), Z(0x38), Z(0x7e), Z(0xda), Z(0x9f), Z(0xe3),
+	Z(0xd2), Z(0xcf), Z(0xc4), Z(0x3c), Z(0x61), Z(0xff), Z(0x4a), Z(0x4a),
+	Z(0x35), Z(0xac), Z(0xaa), Z(0x5f), Z(0x2b), Z(0xbb), Z(0xbc), Z(0x53),
+	Z(0x4e), Z(0x9d), Z(0x78), Z(0xa3), Z(0xdc), Z(0x09), Z(0x32), Z(0x10),
+	Z(0xc6), Z(0x6f), Z(0x66), Z(0xd6), Z(0xab), Z(0xa9), Z(0xaf), Z(0xfd),
+	Z(0x3b), Z(0x95), Z(0xe8), Z(0x34), Z(0x9a), Z(0x81), Z(0x72), Z(0x80),
+	Z(0x9c), Z(0xf3), Z(0xec), Z(0xda), Z(0x9f), Z(0x26), Z(0x76), Z(0x15),
+	Z(0x3e), Z(0x55), Z(0x4d), Z(0xde), Z(0x84), Z(0xee), Z(0xad), Z(0xc7),
+	Z(0xf1), Z(0x6b), Z(0x3d), Z(0xd3), Z(0x04), Z(0x49), Z(0xaa), Z(0x24),
+	Z(0x0b), Z(0x8a), Z(0x83), Z(0xba), Z(0xfa), Z(0x85), Z(0xa0), Z(0xa8),
+	Z(0xb1), Z(0xd4), Z(0x01), Z(0xd8), Z(0x70), Z(0x64), Z(0xf0), Z(0x51),
+	Z(0xd2), Z(0xc3), Z(0xa7), Z(0x75), Z(0x8c), Z(0xa5), Z(0x64), Z(0xef),
+	Z(0x10), Z(0x4e), Z(0xb7), Z(0xc6), Z(0x61), Z(0x03), Z(0xeb), Z(0x44),
+	Z(0x3d), Z(0xe5), Z(0xb3), Z(0x5b), Z(0xae), Z(0xd5), Z(0xad), Z(0x1d),
+	Z(0xfa), Z(0x5a), Z(0x1e), Z(0x33), Z(0xab), Z(0x93), Z(0xa2), Z(0xb7),
+	Z(0xe7), Z(0xa8), Z(0x45), Z(0xa4), Z(0xcd), Z(0x29), Z(0x63), Z(0x44),
+	Z(0xb6), Z(0x69), Z(0x7e), Z(0x2e), Z(0x62), Z(0x03), Z(0xc8), Z(0xe0),
+	Z(0x17), Z(0xbb), Z(0xc7), Z(0xf3), Z(0x3f), Z(0x36), Z(0xba), Z(0x71),
+	Z(0x8e), Z(0x97), Z(0x65), Z(0x60), Z(0x69), Z(0xb6), Z(0xf6), Z(0xe6),
+	Z(0x6e), Z(0xe0), Z(0x81), Z(0x59), Z(0xe8), Z(0xaf), Z(0xdd), Z(0x95),
+	Z(0x22), Z(0x99), Z(0xfd), Z(0x63), Z(0x19), Z(0x74), Z(0x61), Z(0xb1),
+	Z(0xb6), Z(0x5b), Z(0xae), Z(0x54), Z(0xb3), Z(0x70), Z(0xff), Z(0xc6),
+	Z(0x3b), Z(0x3e), Z(0xc1), Z(0xd7), Z(0xe1), Z(0x0e), Z(0x76), Z(0xe5),
+	Z(0x36), Z(0x4f), Z(0x59), Z(0xc7), Z(0x08), Z(0x6e), Z(0x82), Z(0xa6),
+	Z(0x93), Z(0xc4), Z(0xaa), Z(0x26), Z(0x49), Z(0xe0), Z(0x21), Z(0x64),
+	Z(0x07), Z(0x9f), Z(0x64), Z(0x81), Z(0x9c), Z(0xbf), Z(0xf9), Z(0xd1),
+	Z(0x43), Z(0xf8), Z(0xb6), Z(0xb9), Z(0xf1), Z(0x24), Z(0x75), Z(0x03),
+	Z(0xe4), Z(0xb0), Z(0x99), Z(0x46), Z(0x3d), Z(0xf5), Z(0xd1), Z(0x39),
+	Z(0x72), Z(0x12), Z(0xf6), Z(0xba), Z(0x0c), Z(0x0d), Z(0x42), Z(0x2e)
+};
+
+#undef Z
+#define Z(x) __constant_be32_to_cpu((x &lt;&lt; 27) | (x &gt;&gt; 5))
+static const u32 sbox1[256] = {
+	Z(0x77), Z(0x14), Z(0xa6), Z(0xfe), Z(0xb2), Z(0x5e), Z(0x8c), Z(0x3e),
+	Z(0x67), Z(0x6c), Z(0xa1), Z(0x0d), Z(0xc2), Z(0xa2), Z(0xc1), Z(0x85),
+	Z(0x6c), Z(0x7b), Z(0x67), Z(0xc6), Z(0x23), Z(0xe3), Z(0xf2), Z(0x89),
+	Z(0x50), Z(0x9c), Z(0x03), Z(0xb7), Z(0x73), Z(0xe6), Z(0xe1), Z(0x39),
+	Z(0x31), Z(0x2c), Z(0x27), Z(0x9f), Z(0xa5), Z(0x69), Z(0x44), Z(0xd6),
+	Z(0x23), Z(0x83), Z(0x98), Z(0x7d), Z(0x3c), Z(0xb4), Z(0x2d), Z(0x99),
+	Z(0x1c), Z(0x1f), Z(0x8c), Z(0x20), Z(0x03), Z(0x7c), Z(0x5f), Z(0xad),
+	Z(0xf4), Z(0xfa), Z(0x95), Z(0xca), Z(0x76), Z(0x44), Z(0xcd), Z(0xb6),
+	Z(0xb8), Z(0xa1), Z(0xa1), Z(0xbe), Z(0x9e), Z(0x54), Z(0x8f), Z(0x0b),
+	Z(0x16), Z(0x74), Z(0x31), Z(0x8a), Z(0x23), Z(0x17), Z(0x04), Z(0xfa),
+	Z(0x79), Z(0x84), Z(0xb1), Z(0xf5), Z(0x13), Z(0xab), Z(0xb5), Z(0x2e),
+	Z(0xaa), Z(0x0c), Z(0x60), Z(0x6b), Z(0x5b), Z(0xc4), Z(0x4b), Z(0xbc),
+	Z(0xe2), Z(0xaf), Z(0x45), Z(0x73), Z(0xfa), Z(0xc9), Z(0x49), Z(0xcd),
+	Z(0x00), Z(0x92), Z(0x7d), Z(0x97), Z(0x7a), Z(0x18), Z(0x60), Z(0x3d),
+	Z(0xcf), Z(0x5b), Z(0xde), Z(0xc6), Z(0xe2), Z(0xe6), Z(0xbb), Z(0x8b),
+	Z(0x06), Z(0xda), Z(0x08), Z(0x15), Z(0x1b), Z(0x88), Z(0x6a), Z(0x17),
+	Z(0x89), Z(0xd0), Z(0xa9), Z(0xc1), Z(0xc9), Z(0x70), Z(0x6b), Z(0xe5),
+	Z(0x43), Z(0xf4), Z(0x68), Z(0xc8), Z(0xd3), Z(0x84), Z(0x28), Z(0x0a),
+	Z(0x52), Z(0x66), Z(0xa3), Z(0xca), Z(0xf2), Z(0xe3), Z(0x7f), Z(0x7a),
+	Z(0x31), Z(0xf7), Z(0x88), Z(0x94), Z(0x5e), Z(0x9c), Z(0x63), Z(0xd5),
+	Z(0x24), Z(0x66), Z(0xfc), Z(0xb3), Z(0x57), Z(0x25), Z(0xbe), Z(0x89),
+	Z(0x44), Z(0xc4), Z(0xe0), Z(0x8f), Z(0x23), Z(0x3c), Z(0x12), Z(0x52),
+	Z(0xf5), Z(0x1e), Z(0xf4), Z(0xcb), Z(0x18), Z(0x33), Z(0x1f), Z(0xf8),
+	Z(0x69), Z(0x10), Z(0x9d), Z(0xd3), Z(0xf7), Z(0x28), Z(0xf8), Z(0x30),
+	Z(0x05), Z(0x5e), Z(0x32), Z(0xc0), Z(0xd5), Z(0x19), Z(0xbd), Z(0x45),
+	Z(0x8b), Z(0x5b), Z(0xfd), Z(0xbc), Z(0xe2), Z(0x5c), Z(0xa9), Z(0x96),
+	Z(0xef), Z(0x70), Z(0xcf), Z(0xc2), Z(0x2a), Z(0xb3), Z(0x61), Z(0xad),
+	Z(0x80), Z(0x48), Z(0x81), Z(0xb7), Z(0x1d), Z(0x43), Z(0xd9), Z(0xd7),
+	Z(0x45), Z(0xf0), Z(0xd8), Z(0x8a), Z(0x59), Z(0x7c), Z(0x57), Z(0xc1),
+	Z(0x79), Z(0xc7), Z(0x34), Z(0xd6), Z(0x43), Z(0xdf), Z(0xe4), Z(0x78),
+	Z(0x16), Z(0x06), Z(0xda), Z(0x92), Z(0x76), Z(0x51), Z(0xe1), Z(0xd4),
+	Z(0x70), Z(0x03), Z(0xe0), Z(0x2f), Z(0x96), Z(0x91), Z(0x82), Z(0x80)
+};
+
+#undef Z
+#define Z(x) __constant_be32_to_cpu(x &lt;&lt; 11)
+static const u32 sbox2[256] = {
+	Z(0xf0), Z(0x37), Z(0x24), Z(0x53), Z(0x2a), Z(0x03), Z(0x83), Z(0x86),
+	Z(0xd1), Z(0xec), Z(0x50), Z(0xf0), Z(0x42), Z(0x78), Z(0x2f), Z(0x6d),
+	Z(0xbf), Z(0x80), Z(0x87), Z(0x27), Z(0x95), Z(0xe2), Z(0xc5), Z(0x5d),
+	Z(0xf9), Z(0x6f), Z(0xdb), Z(0xb4), Z(0x65), Z(0x6e), Z(0xe7), Z(0x24),
+	Z(0xc8), Z(0x1a), Z(0xbb), Z(0x49), Z(0xb5), Z(0x0a), Z(0x7d), Z(0xb9),
+	Z(0xe8), Z(0xdc), Z(0xb7), Z(0xd9), Z(0x45), Z(0x20), Z(0x1b), Z(0xce),
+	Z(0x59), Z(0x9d), Z(0x6b), Z(0xbd), Z(0x0e), Z(0x8f), Z(0xa3), Z(0xa9),
+	Z(0xbc), Z(0x74), Z(0xa6), Z(0xf6), Z(0x7f), Z(0x5f), Z(0xb1), Z(0x68),
+	Z(0x84), Z(0xbc), Z(0xa9), Z(0xfd), Z(0x55), Z(0x50), Z(0xe9), Z(0xb6),
+	Z(0x13), Z(0x5e), Z(0x07), Z(0xb8), Z(0x95), Z(0x02), Z(0xc0), Z(0xd0),
+	Z(0x6a), Z(0x1a), Z(0x85), Z(0xbd), Z(0xb6), Z(0xfd), Z(0xfe), Z(0x17),
+	Z(0x3f), Z(0x09), Z(0xa3), Z(0x8d), Z(0xfb), Z(0xed), Z(0xda), Z(0x1d),
+	Z(0x6d), Z(0x1c), Z(0x6c), Z(0x01), Z(0x5a), Z(0xe5), Z(0x71), Z(0x3e),
+	Z(0x8b), Z(0x6b), Z(0xbe), Z(0x29), Z(0xeb), Z(0x12), Z(0x19), Z(0x34),
+	Z(0xcd), Z(0xb3), Z(0xbd), Z(0x35), Z(0xea), Z(0x4b), Z(0xd5), Z(0xae),
+	Z(0x2a), Z(0x79), Z(0x5a), Z(0xa5), Z(0x32), Z(0x12), Z(0x7b), Z(0xdc),
+	Z(0x2c), Z(0xd0), Z(0x22), Z(0x4b), Z(0xb1), Z(0x85), Z(0x59), Z(0x80),
+	Z(0xc0), Z(0x30), Z(0x9f), Z(0x73), Z(0xd3), Z(0x14), Z(0x48), Z(0x40),
+	Z(0x07), Z(0x2d), Z(0x8f), Z(0x80), Z(0x0f), Z(0xce), Z(0x0b), Z(0x5e),
+	Z(0xb7), Z(0x5e), Z(0xac), Z(0x24), Z(0x94), Z(0x4a), Z(0x18), Z(0x15),
+	Z(0x05), Z(0xe8), Z(0x02), Z(0x77), Z(0xa9), Z(0xc7), Z(0x40), Z(0x45),
+	Z(0x89), Z(0xd1), Z(0xea), Z(0xde), Z(0x0c), Z(0x79), Z(0x2a), Z(0x99),
+	Z(0x6c), Z(0x3e), Z(0x95), Z(0xdd), Z(0x8c), Z(0x7d), Z(0xad), Z(0x6f),
+	Z(0xdc), Z(0xff), Z(0xfd), Z(0x62), Z(0x47), Z(0xb3), Z(0x21), Z(0x8a),
+	Z(0xec), Z(0x8e), Z(0x19), Z(0x18), Z(0xb4), Z(0x6e), Z(0x3d), Z(0xfd),
+	Z(0x74), Z(0x54), Z(0x1e), Z(0x04), Z(0x85), Z(0xd8), Z(0xbc), Z(0x1f),
+	Z(0x56), Z(0xe7), Z(0x3a), Z(0x56), Z(0x67), Z(0xd6), Z(0xc8), Z(0xa5),
+	Z(0xf3), Z(0x8e), Z(0xde), Z(0xae), Z(0x37), Z(0x49), Z(0xb7), Z(0xfa),
+	Z(0xc8), Z(0xf4), Z(0x1f), Z(0xe0), Z(0x2a), Z(0x9b), Z(0x15), Z(0xd1),
+	Z(0x34), Z(0x0e), Z(0xb5), Z(0xe0), Z(0x44), Z(0x78), Z(0x84), Z(0x59),
+	Z(0x56), Z(0x68), Z(0x77), Z(0xa5), Z(0x14), Z(0x06), Z(0xf5), Z(0x2f),
+	Z(0x8c), Z(0x8a), Z(0x73), Z(0x80), Z(0x76), Z(0xb4), Z(0x10), Z(0x86)
+};
+
+#undef Z
+#define Z(x) __constant_be32_to_cpu(x &lt;&lt; 19)
+static const u32 sbox3[256] = {
+	Z(0xa9), Z(0x2a), Z(0x48), Z(0x51), Z(0x84), Z(0x7e), Z(0x49), Z(0xe2),
+	Z(0xb5), Z(0xb7), Z(0x42), Z(0x33), Z(0x7d), Z(0x5d), Z(0xa6), Z(0x12),
+	Z(0x44), Z(0x48), Z(0x6d), Z(0x28), Z(0xaa), Z(0x20), Z(0x6d), Z(0x57),
+	Z(0xd6), Z(0x6b), Z(0x5d), Z(0x72), Z(0xf0), Z(0x92), Z(0x5a), Z(0x1b),
+	Z(0x53), Z(0x80), Z(0x24), Z(0x70), Z(0x9a), Z(0xcc), Z(0xa7), Z(0x66),
+	Z(0xa1), Z(0x01), Z(0xa5), Z(0x41), Z(0x97), Z(0x41), Z(0x31), Z(0x82),
+	Z(0xf1), Z(0x14), Z(0xcf), Z(0x53), Z(0x0d), Z(0xa0), Z(0x10), Z(0xcc),
+	Z(0x2a), Z(0x7d), Z(0xd2), Z(0xbf), Z(0x4b), Z(0x1a), Z(0xdb), Z(0x16),
+	Z(0x47), Z(0xf6), Z(0x51), Z(0x36), Z(0xed), Z(0xf3), Z(0xb9), Z(0x1a),
+	Z(0xa7), Z(0xdf), Z(0x29), Z(0x43), Z(0x01), Z(0x54), Z(0x70), Z(0xa4),
+	Z(0xbf), Z(0xd4), Z(0x0b), Z(0x53), Z(0x44), Z(0x60), Z(0x9e), Z(0x23),
+	Z(0xa1), Z(0x18), Z(0x68), Z(0x4f), Z(0xf0), Z(0x2f), Z(0x82), Z(0xc2),
+	Z(0x2a), Z(0x41), Z(0xb2), Z(0x42), Z(0x0c), Z(0xed), Z(0x0c), Z(0x1d),
+	Z(0x13), Z(0x3a), Z(0x3c), Z(0x6e), Z(0x35), Z(0xdc), Z(0x60), Z(0x65),
+	Z(0x85), Z(0xe9), Z(0x64), Z(0x02), Z(0x9a), Z(0x3f), Z(0x9f), Z(0x87),
+	Z(0x96), Z(0xdf), Z(0xbe), Z(0xf2), Z(0xcb), Z(0xe5), Z(0x6c), Z(0xd4),
+	Z(0x5a), Z(0x83), Z(0xbf), Z(0x92), Z(0x1b), Z(0x94), Z(0x00), Z(0x42),
+	Z(0xcf), Z(0x4b), Z(0x00), Z(0x75), Z(0xba), Z(0x8f), Z(0x76), Z(0x5f),
+	Z(0x5d), Z(0x3a), Z(0x4d), Z(0x09), Z(0x12), Z(0x08), Z(0x38), Z(0x95),
+	Z(0x17), Z(0xe4), Z(0x01), Z(0x1d), Z(0x4c), Z(0xa9), Z(0xcc), Z(0x85),
+	Z(0x82), Z(0x4c), Z(0x9d), Z(0x2f), Z(0x3b), Z(0x66), Z(0xa1), Z(0x34),
+	Z(0x10), Z(0xcd), Z(0x59), Z(0x89), Z(0xa5), Z(0x31), Z(0xcf), Z(0x05),
+	Z(0xc8), Z(0x84), Z(0xfa), Z(0xc7), Z(0xba), Z(0x4e), Z(0x8b), Z(0x1a),
+	Z(0x19), Z(0xf1), Z(0xa1), Z(0x3b), Z(0x18), Z(0x12), Z(0x17), Z(0xb0),
+	Z(0x98), Z(0x8d), Z(0x0b), Z(0x23), Z(0xc3), Z(0x3a), Z(0x2d), Z(0x20),
+	Z(0xdf), Z(0x13), Z(0xa0), Z(0xa8), Z(0x4c), Z(0x0d), Z(0x6c), Z(0x2f),
+	Z(0x47), Z(0x13), Z(0x13), Z(0x52), Z(0x1f), Z(0x2d), Z(0xf5), Z(0x79),
+	Z(0x3d), Z(0xa2), Z(0x54), Z(0xbd), Z(0x69), Z(0xc8), Z(0x6b), Z(0xf3),
+	Z(0x05), Z(0x28), Z(0xf1), Z(0x16), Z(0x46), Z(0x40), Z(0xb0), Z(0x11),
+	Z(0xd3), Z(0xb7), Z(0x95), Z(0x49), Z(0xcf), Z(0xc3), Z(0x1d), Z(0x8f),
+	Z(0xd8), Z(0xe1), Z(0x73), Z(0xdb), Z(0xad), Z(0xc8), Z(0xc9), Z(0xa9),
+	Z(0xa1), Z(0xc2), Z(0xc5), Z(0xe3), Z(0xba), Z(0xfc), Z(0x0e), Z(0x25)
+};
+
+/*
+ * This is a 16 round Feistel network with permutation F_ENCRYPT
+ */
+#define F_ENCRYPT(R, L, sched)						\
+do {									\
+	union lc4 { u32 l; u8 c[4]; } u;				\
+	u.l = sched ^ R;						\
+	L ^= sbox0[u.c[0]] ^ sbox1[u.c[1]] ^ sbox2[u.c[2]] ^ sbox3[u.c[3]]; \
+} while(0)
+
+/*
+ * encryptor
+ */
+static void fcrypt_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
+{
+	const struct fcrypt_ctx *ctx = crypto_tfm_ctx(tfm);
+	struct {
+		u32 l, r;
+	} X;
+
+	memcpy(&amp;X, src, sizeof(X));
+
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x0]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x1]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x2]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x3]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x4]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x5]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x6]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x7]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x8]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x9]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xa]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xb]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xc]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xd]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xe]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xf]);
+
+	memcpy(dst, &amp;X, sizeof(X));
+}
+
+/*
+ * decryptor
+ */
+static void fcrypt_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
+{
+	const struct fcrypt_ctx *ctx = crypto_tfm_ctx(tfm);
+	struct {
+		u32 l, r;
+	} X;
+
+	memcpy(&amp;X, src, sizeof(X));
+
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xf]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xe]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xd]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xc]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0xb]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0xa]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x9]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x8]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x7]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x6]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x5]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x4]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x3]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x2]);
+	F_ENCRYPT(X.l, X.r, ctx-&gt;sched[0x1]);
+	F_ENCRYPT(X.r, X.l, ctx-&gt;sched[0x0]);
+
+	memcpy(dst, &amp;X, sizeof(X));
+}
+
+/*
+ * Generate a key schedule from key, the least significant bit in each key byte
+ * is parity and shall be ignored. This leaves 56 significant bits in the key
+ * to scatter over the 16 key schedules. For each schedule extract the low
+ * order 32 bits and use as schedule, then rotate right by 11 bits.
+ */
+static int fcrypt_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
+{
+	struct fcrypt_ctx *ctx = crypto_tfm_ctx(tfm);
+
+#if BITS_PER_LONG == 64  /* the 64-bit version can also be used for 32-bit
+			  * kernels - it seems to be faster but the code is
+			  * larger */
+
+	u64 k;	/* k holds all 56 non-parity bits */
+
+	/* discard the parity bits */
+	k = (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key++) &gt;&gt; 1;
+	k &lt;&lt;= 7;
+	k |= (*key) &gt;&gt; 1;
+
+	/* Use lower 32 bits for schedule, rotate by 11 each round (16 times) */
+	ctx-&gt;sched[0x0] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x1] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x2] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x3] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x4] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x5] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x6] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x7] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x8] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0x9] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xa] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xb] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xc] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xd] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xe] = be32_to_cpu(k); ror56_64(k, 11);
+	ctx-&gt;sched[0xf] = be32_to_cpu(k);
+
+	return 0;
+#else
+	u32 hi, lo;		/* hi is upper 24 bits and lo lower 32, total 56 */
+
+	/* discard the parity bits */
+	lo = (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	hi = lo &gt;&gt; 4;
+	lo &amp;= 0xf;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key++) &gt;&gt; 1;
+	lo &lt;&lt;= 7;
+	lo |= (*key) &gt;&gt; 1;
+
+	/* Use lower 32 bits for schedule, rotate by 11 each round (16 times) */
+	ctx-&gt;sched[0x0] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x1] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x2] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x3] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x4] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x5] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x6] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x7] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x8] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0x9] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xa] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xb] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xc] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xd] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xe] = be32_to_cpu(lo); ror56(hi, lo, 11);
+	ctx-&gt;sched[0xf] = be32_to_cpu(lo);
+	return 0;
+#endif
+}
+
+static struct crypto_alg fcrypt_alg = {
+	.cra_name		=	"fcrypt",
+	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize		=	8,
+	.cra_ctxsize		=	sizeof(struct fcrypt_ctx),
+	.cra_module		=	THIS_MODULE,
+	.cra_alignmask		=	3,
+	.cra_list		=	LIST_HEAD_INIT(fcrypt_alg.cra_list),
+	.cra_u			=	{ .cipher = {
+	.cia_min_keysize	=	8,
+	.cia_max_keysize	=	8,
+	.cia_setkey		=	fcrypt_setkey,
+	.cia_encrypt		=	fcrypt_encrypt,
+	.cia_decrypt		=	fcrypt_decrypt } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;fcrypt_alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;fcrypt_alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("FCrypt Cipher Algorithm");
+MODULE_AUTHOR("David Howells &lt;dhowells@redhat.com&gt;");
diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
index d671e89..eef0516 100644
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -71,7 +71,8 @@ static char *check[] = {
 	"des", "md5", "des3_ede", "rot13", "sha1", "sha256", "blowfish",
 	"twofish", "serpent", "sha384", "sha512", "md4", "aes", "cast6",
 	"arc4", "michael_mic", "deflate", "crc32c", "tea", "xtea",
-	"khazad", "wp512", "wp384", "wp256", "tnepres", "xeta", NULL
+	"khazad", "wp512", "wp384", "wp256", "tnepres", "xeta",  "fcrypt",
+	NULL
 };
 
 static void hexdump(unsigned char *buf, unsigned int len)
@@ -964,6 +965,12 @@ static void do_test(void)
 		test_cipher("ecb(xeta)", DECRYPT, xeta_dec_tv_template,
 			    XETA_DEC_TEST_VECTORS);
 
+		//FCrypt
+		test_cipher("pcbc(fcrypt)", ENCRYPT, fcrypt_pcbc_enc_tv_template,
+			    FCRYPT_ENC_TEST_VECTORS);
+		test_cipher("pcbc(fcrypt)", DECRYPT, fcrypt_pcbc_dec_tv_template,
+			    FCRYPT_DEC_TEST_VECTORS);
+
 		test_hash("sha384", sha384_tv_template, SHA384_TEST_VECTORS);
 		test_hash("sha512", sha512_tv_template, SHA512_TEST_VECTORS);
 		test_hash("wp512", wp512_tv_template, WP512_TEST_VECTORS);
@@ -1177,6 +1184,13 @@ static void do_test(void)
 			    XETA_DEC_TEST_VECTORS);
 		break;
 
+	case 31:
+		test_cipher("pcbc(fcrypt)", ENCRYPT, fcrypt_pcbc_enc_tv_template,
+			    FCRYPT_ENC_TEST_VECTORS);
+		test_cipher("pcbc(fcrypt)", DECRYPT, fcrypt_pcbc_dec_tv_template,
+			    FCRYPT_DEC_TEST_VECTORS);
+		break;
+
 	case 100:
 		test_hash("hmac(md5)", hmac_md5_tv_template,
 			  HMAC_MD5_TEST_VECTORS);
diff --git a/crypto/tcrypt.h b/crypto/tcrypt.h
index 48a8136..688cbeb 100644
--- a/crypto/tcrypt.h
+++ b/crypto/tcrypt.h
@@ -3316,6 +3316,134 @@ static struct cipher_testvec xeta_dec_tv
 	}
 };
 
+/* 
+ * FCrypt test vectors 
+ */
+#define FCRYPT_ENC_TEST_VECTORS	ARRAY_SIZE(fcrypt_pcbc_enc_tv_template)
+#define FCRYPT_DEC_TEST_VECTORS	ARRAY_SIZE(fcrypt_pcbc_dec_tv_template)
+
+static struct cipher_testvec fcrypt_pcbc_enc_tv_template[] = {
+	{ /* http://www.openafs.org/pipermail/openafs-devel/2000-December/005320.html */
+		.key	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.klen	= 8,
+		.iv	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.input	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.ilen	= 8,
+		.result	= { 0x0E, 0x09, 0x00, 0xC7, 0x3E, 0xF7, 0xED, 0x41 },
+		.rlen	= 8,
+	}, {
+		.key	= { 0x11, 0x44, 0x77, 0xAA, 0xDD, 0x00, 0x33, 0x66 },
+		.klen	= 8,
+		.iv	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.input	= { 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0 },
+		.ilen	= 8,
+		.result	= { 0xD8, 0xED, 0x78, 0x74, 0x77, 0xEC, 0x06, 0x80 },
+		.rlen	= 8,
+	}, { /* From Arla */
+		.key	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.klen	= 8,
+		.iv	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.input	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.ilen	= 48,
+		.result	= { 0x00, 0xf0, 0xe,  0x11, 0x75, 0xe6, 0x23, 0x82,
+			    0xee, 0xac, 0x98, 0x62, 0x44, 0x51, 0xe4, 0x84,
+			    0xc3, 0x59, 0xd8, 0xaa, 0x64, 0x60, 0xae, 0xf7,
+			    0xd2, 0xd9, 0x13, 0x79, 0x72, 0xa3, 0x45, 0x03,
+			    0x23, 0xb5, 0x62, 0xd7, 0x0c, 0xf5, 0x27, 0xd1,
+			    0xf8, 0x91, 0x3c, 0xac, 0x44, 0x22, 0x92, 0xef },
+		.rlen	= 48,
+	}, {
+		.key	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.klen	= 8,
+		.iv	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.input	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.ilen	= 48,
+		.result	= { 0xca, 0x90, 0xf5, 0x9d, 0xcb, 0xd4, 0xd2, 0x3c,
+			    0x01, 0x88, 0x7f, 0x3e, 0x31, 0x6e, 0x62, 0x9d,
+			    0xd8, 0xe0, 0x57, 0xa3, 0x06, 0x3a, 0x42, 0x58,
+			    0x2a, 0x28, 0xfe, 0x72, 0x52, 0x2f, 0xdd, 0xe0,
+			    0x19, 0x89, 0x09, 0x1c, 0x2a, 0x8e, 0x8c, 0x94,
+			    0xfc, 0xc7, 0x68, 0xe4, 0x88, 0xaa, 0xde, 0x0f },
+		.rlen	= 48,
+	}, { /* split-page version */
+		.key	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.klen	= 8,
+		.iv	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.input	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.ilen	= 48,
+		.result	= { 0xca, 0x90, 0xf5, 0x9d, 0xcb, 0xd4, 0xd2, 0x3c,
+			    0x01, 0x88, 0x7f, 0x3e, 0x31, 0x6e, 0x62, 0x9d,
+			    0xd8, 0xe0, 0x57, 0xa3, 0x06, 0x3a, 0x42, 0x58,
+			    0x2a, 0x28, 0xfe, 0x72, 0x52, 0x2f, 0xdd, 0xe0,
+			    0x19, 0x89, 0x09, 0x1c, 0x2a, 0x8e, 0x8c, 0x94,
+			    0xfc, 0xc7, 0x68, 0xe4, 0x88, 0xaa, 0xde, 0x0f },
+		.rlen	= 48,
+		.np	= 2,
+		.tap	= { 20, 28 },
+	}
+};
+
+static struct cipher_testvec fcrypt_pcbc_dec_tv_template[] = {
+	{ /* http://www.openafs.org/pipermail/openafs-devel/2000-December/005320.html */
+		.key	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.klen	= 8,
+		.iv	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.input	= { 0x0E, 0x09, 0x00, 0xC7, 0x3E, 0xF7, 0xED, 0x41 },
+		.ilen	= 8,
+		.result	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.rlen	= 8,
+	}, {
+		.key	= { 0x11, 0x44, 0x77, 0xAA, 0xDD, 0x00, 0x33, 0x66 },
+		.klen	= 8,
+		.iv	= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.input	= { 0xD8, 0xED, 0x78, 0x74, 0x77, 0xEC, 0x06, 0x80 },
+		.ilen	= 8,
+		.result	= { 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0 },
+		.rlen	= 8,
+	}, { /* From Arla */
+		.key	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.klen	= 8,
+		.iv	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.input	= { 0x00, 0xf0, 0xe,  0x11, 0x75, 0xe6, 0x23, 0x82,
+			    0xee, 0xac, 0x98, 0x62, 0x44, 0x51, 0xe4, 0x84,
+			    0xc3, 0x59, 0xd8, 0xaa, 0x64, 0x60, 0xae, 0xf7,
+			    0xd2, 0xd9, 0x13, 0x79, 0x72, 0xa3, 0x45, 0x03,
+			    0x23, 0xb5, 0x62, 0xd7, 0x0c, 0xf5, 0x27, 0xd1,
+			    0xf8, 0x91, 0x3c, 0xac, 0x44, 0x22, 0x92, 0xef },
+		.ilen	= 48,
+		.result	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.rlen	= 48,
+	}, {
+		.key	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.klen	= 8,
+		.iv	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.input	= { 0xca, 0x90, 0xf5, 0x9d, 0xcb, 0xd4, 0xd2, 0x3c,
+			    0x01, 0x88, 0x7f, 0x3e, 0x31, 0x6e, 0x62, 0x9d,
+			    0xd8, 0xe0, 0x57, 0xa3, 0x06, 0x3a, 0x42, 0x58,
+			    0x2a, 0x28, 0xfe, 0x72, 0x52, 0x2f, 0xdd, 0xe0,
+			    0x19, 0x89, 0x09, 0x1c, 0x2a, 0x8e, 0x8c, 0x94,
+			    0xfc, 0xc7, 0x68, 0xe4, 0x88, 0xaa, 0xde, 0x0f },
+		.ilen	= 48,
+		.result	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.rlen	= 48,
+	}, { /* split-page version */
+		.key	= { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.klen	= 8,
+		.iv	= { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
+		.input	= { 0xca, 0x90, 0xf5, 0x9d, 0xcb, 0xd4, 0xd2, 0x3c,
+			    0x01, 0x88, 0x7f, 0x3e, 0x31, 0x6e, 0x62, 0x9d,
+			    0xd8, 0xe0, 0x57, 0xa3, 0x06, 0x3a, 0x42, 0x58,
+			    0x2a, 0x28, 0xfe, 0x72, 0x52, 0x2f, 0xdd, 0xe0,
+			    0x19, 0x89, 0x09, 0x1c, 0x2a, 0x8e, 0x8c, 0x94,
+			    0xfc, 0xc7, 0x68, 0xe4, 0x88, 0xaa, 0xde, 0x0f },
+		.ilen	= 48,
+		.result	= "The quick brown fox jumps over the lazy dogs.\0\0",
+		.rlen	= 48,
+		.np	= 2,
+		.tap	= { 20, 28 },
+	}
+};
+
 /*
  * Compression stuff.
  */

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061201133924</emailId><senderName>Alan</senderName><senderEmail>alan@lxorguk.ukuu.org.uk</senderEmail><timestampReceived>2006-12-01 13:39:24-0400</timestampReceived><subject>Re: [RFC][PATCH] Pseudo-random number generator</subject><body>

&gt; * merging the s390 PRNG with the random pool implementation
&gt; PRO: no new interface, random numbers can be read through /dev/urandom
&gt; CON: complex implementation, could only use traditional /dev/urandom algorithm
&gt;      or hardware-accelerated implementation

Also PRO: Can be verified by non-IBM people, high resistance if there is
a flaw (accidental or US government 8)) in the 390 hardware.

&gt; I've chosen the char driver since it allows the user to decide which pseudo-random
&gt; numbers he wants to use. That means there is a new interface for the s390
&gt; PRNG, called /dev/prandom.

And people can pipe this into the urandom layer if they wish.

&gt; +/* copied from libica, use a non-zero initial parameter block */
&gt; +unsigned char parm_block[32] = {
&gt; +0x0F,0x2B,0x8E,0x63,0x8C,0x8E,0xD2,0x52,0x64,0xB7,0xA0,0x7B,0x75,0x28,0xB8,0xF4,
&gt; +0x75,0x5F,0xD2,0xA6,0x8D,0x97,0x11,0xFF,0x49,0xD8,0x23,0xF3,0x7E,0x21,0xEC,0xA0,
&gt; +};
&gt; +

Global variables called "p" and "parm_block". Plus parm_block appears to
be const

Also your register the misc device before allocating the buffer so it can
be opened in theory before the alloc is done and crash.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061214125559</emailId><senderName>David Howells</senderName><senderEmail>dhowells@redhat.com</senderEmail><timestampReceived>2006-12-14 12:55:59-0400</timestampReceived><subject>[PATCH 1/2] Add PCBC crypto template support</subject><body>

Add PCBC crypto template support as used by RxRPC.

Signed-Off-By: David Howells &lt;dhowells@redhat.com&gt;
---

 crypto/Kconfig  |    9 +
 crypto/Makefile |    1 
 crypto/pcbc.c   |  348 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 358 insertions(+), 0 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
index 92ba249..9d3a44c 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -168,6 +168,15 @@ config CRYPTO_CBC
 	  CBC: Cipher Block Chaining mode
 	  This block cipher algorithm is required for IPSec.
 
+config CRYPTO_PCBC
+	tristate "PCBC support"
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_MANAGER
+	default m
+	help
+	  PCBC: Propagating Cipher Block Chaining mode
+	  This block cipher algorithm is required for RxRPC.
+
 config CRYPTO_LRW
 	tristate "LRW support (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
diff --git a/crypto/Makefile b/crypto/Makefile
index 60e3d24..9ef048d 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_CRYPTO_TGR192) += tgr192.o
 obj-$(CONFIG_CRYPTO_GF128MUL) += gf128mul.o
 obj-$(CONFIG_CRYPTO_ECB) += ecb.o
 obj-$(CONFIG_CRYPTO_CBC) += cbc.o
+obj-$(CONFIG_CRYPTO_PCBC) += pcbc.o
 obj-$(CONFIG_CRYPTO_LRW) += lrw.o
 obj-$(CONFIG_CRYPTO_DES) += des.o
 obj-$(CONFIG_CRYPTO_BLOWFISH) += blowfish.o
diff --git a/crypto/pcbc.c b/crypto/pcbc.c
new file mode 100644
index 0000000..0ffb46e
--- /dev/null
+++ b/crypto/pcbc.c
@@ -0,0 +1,348 @@
+/*
+ * PCBC: Propagating Cipher Block Chaining mode
+ *
+ * Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * Derived from cbc.c
+ * - Copyright (c) 2006 Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include &lt;crypto/algapi.h&gt;
+#include &lt;linux/err.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include &lt;linux/slab.h&gt;
+
+struct crypto_pcbc_ctx {
+	struct crypto_cipher *child;
+	void (*xor)(u8 *dst, const u8 *src, unsigned int bs);
+};
+
+static int crypto_pcbc_setkey(struct crypto_tfm *parent, const u8 *key,
+			      unsigned int keylen)
+{
+	struct crypto_pcbc_ctx *ctx = crypto_tfm_ctx(parent);
+	struct crypto_cipher *child = ctx-&gt;child;
+	int err;
+
+	crypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
+	crypto_cipher_set_flags(child, crypto_tfm_get_flags(parent) &amp;
+				CRYPTO_TFM_REQ_MASK);
+	err = crypto_cipher_setkey(child, key, keylen);
+	crypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &amp;
+			     CRYPTO_TFM_RES_MASK);
+	return err;
+}
+
+static int crypto_pcbc_encrypt_segment(struct blkcipher_desc *desc,
+				       struct blkcipher_walk *walk,
+				       struct crypto_cipher *tfm,
+				       void (*xor)(u8 *, const u8 *,
+						   unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_encrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 *dst = walk-&gt;dst.virt.addr;
+	u8 *iv = walk-&gt;iv;
+
+	do {
+		xor(iv, src, bsize);
+		fn(crypto_cipher_tfm(tfm), dst, iv);
+		memcpy(iv, dst, bsize);
+		xor(iv, src, bsize);
+
+		src += bsize;
+		dst += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	return nbytes;
+}
+
+static int crypto_pcbc_encrypt_inplace(struct blkcipher_desc *desc,
+				       struct blkcipher_walk *walk,
+				       struct crypto_cipher *tfm,
+				       void (*xor)(u8 *, const u8 *,
+						   unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_encrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 *iv = walk-&gt;iv;
+	u8 tmpbuf[bsize];
+
+	do {
+		memcpy(tmpbuf, src, bsize);
+		xor(iv, tmpbuf, bsize);
+		fn(crypto_cipher_tfm(tfm), src, iv);
+		memcpy(iv, src, bsize);
+		xor(iv, tmpbuf, bsize);
+
+		src += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	memcpy(walk-&gt;iv, iv, bsize);
+
+	return nbytes;
+}
+
+static int crypto_pcbc_encrypt(struct blkcipher_desc *desc,
+			       struct scatterlist *dst, struct scatterlist *src,
+			       unsigned int nbytes)
+{
+	struct blkcipher_walk walk;
+	struct crypto_blkcipher *tfm = desc-&gt;tfm;
+	struct crypto_pcbc_ctx *ctx = crypto_blkcipher_ctx(tfm);
+	struct crypto_cipher *child = ctx-&gt;child;
+	void (*xor)(u8 *, const u8 *, unsigned int bs) = ctx-&gt;xor;
+	int err;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while ((nbytes = walk.nbytes)) {
+		if (walk.src.virt.addr == walk.dst.virt.addr)
+			nbytes = crypto_pcbc_encrypt_inplace(desc, &amp;walk, child,
+							     xor);
+		else
+			nbytes = crypto_pcbc_encrypt_segment(desc, &amp;walk, child,
+							     xor);
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static int crypto_pcbc_decrypt_segment(struct blkcipher_desc *desc,
+				       struct blkcipher_walk *walk,
+				       struct crypto_cipher *tfm,
+				       void (*xor)(u8 *, const u8 *,
+						   unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_decrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 *dst = walk-&gt;dst.virt.addr;
+	u8 *iv = walk-&gt;iv;
+
+	do {
+		fn(crypto_cipher_tfm(tfm), dst, src);
+		xor(dst, iv, bsize);
+		memcpy(iv, src, bsize);
+		xor(iv, dst, bsize);
+
+		src += bsize;
+		dst += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	memcpy(walk-&gt;iv, iv, bsize);
+
+	return nbytes;
+}
+
+static int crypto_pcbc_decrypt_inplace(struct blkcipher_desc *desc,
+				       struct blkcipher_walk *walk,
+				       struct crypto_cipher *tfm,
+				       void (*xor)(u8 *, const u8 *,
+						   unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_decrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 *iv = walk-&gt;iv;
+	u8 tmpbuf[bsize];
+
+	do {
+		memcpy(tmpbuf, src, bsize);
+		fn(crypto_cipher_tfm(tfm), src, src);
+		xor(src, iv, bsize);
+		memcpy(iv, tmpbuf, bsize);
+		xor(iv, src, bsize);
+
+		src += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	memcpy(walk-&gt;iv, iv, bsize);
+
+	return nbytes;
+}
+
+static int crypto_pcbc_decrypt(struct blkcipher_desc *desc,
+			       struct scatterlist *dst, struct scatterlist *src,
+			       unsigned int nbytes)
+{
+	struct blkcipher_walk walk;
+	struct crypto_blkcipher *tfm = desc-&gt;tfm;
+	struct crypto_pcbc_ctx *ctx = crypto_blkcipher_ctx(tfm);
+	struct crypto_cipher *child = ctx-&gt;child;
+	void (*xor)(u8 *, const u8 *, unsigned int bs) = ctx-&gt;xor;
+	int err;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while ((nbytes = walk.nbytes)) {
+		if (walk.src.virt.addr == walk.dst.virt.addr)
+			nbytes = crypto_pcbc_decrypt_inplace(desc, &amp;walk, child,
+							     xor);
+		else
+			nbytes = crypto_pcbc_decrypt_segment(desc, &amp;walk, child,
+							     xor);
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static void xor_byte(u8 *a, const u8 *b, unsigned int bs)
+{
+	do {
+		*a++ ^= *b++;
+	} while (--bs);
+}
+
+static void xor_quad(u8 *dst, const u8 *src, unsigned int bs)
+{
+	u32 *a = (u32 *)dst;
+	u32 *b = (u32 *)src;
+
+	do {
+		*a++ ^= *b++;
+	} while ((bs -= 4));
+}
+
+static void xor_64(u8 *a, const u8 *b, unsigned int bs)
+{
+	((u32 *)a)[0] ^= ((u32 *)b)[0];
+	((u32 *)a)[1] ^= ((u32 *)b)[1];
+}
+
+static void xor_128(u8 *a, const u8 *b, unsigned int bs)
+{
+	((u32 *)a)[0] ^= ((u32 *)b)[0];
+	((u32 *)a)[1] ^= ((u32 *)b)[1];
+	((u32 *)a)[2] ^= ((u32 *)b)[2];
+	((u32 *)a)[3] ^= ((u32 *)b)[3];
+}
+
+static int crypto_pcbc_init_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_instance *inst = (void *)tfm-&gt;__crt_alg;
+	struct crypto_spawn *spawn = crypto_instance_ctx(inst);
+	struct crypto_pcbc_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	switch (crypto_tfm_alg_blocksize(tfm)) {
+	case 8:
+		ctx-&gt;xor = xor_64;
+		break;
+
+	case 16:
+		ctx-&gt;xor = xor_128;
+		break;
+
+	default:
+		if (crypto_tfm_alg_blocksize(tfm) % 4)
+			ctx-&gt;xor = xor_byte;
+		else
+			ctx-&gt;xor = xor_quad;
+	}
+
+	tfm = crypto_spawn_tfm(spawn);
+	if (IS_ERR(tfm))
+		return PTR_ERR(tfm);
+
+	ctx-&gt;child = crypto_cipher_cast(tfm);
+	return 0;
+}
+
+static void crypto_pcbc_exit_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_pcbc_ctx *ctx = crypto_tfm_ctx(tfm);
+	crypto_free_cipher(ctx-&gt;child);
+}
+
+static struct crypto_instance *crypto_pcbc_alloc(void *param, unsigned int len)
+{
+	struct crypto_instance *inst;
+	struct crypto_alg *alg;
+
+	alg = crypto_get_attr_alg(param, len, CRYPTO_ALG_TYPE_CIPHER,
+				  CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_ASYNC);
+	if (IS_ERR(alg))
+		return ERR_PTR(PTR_ERR(alg));
+
+	inst = crypto_alloc_instance("pcbc", alg);
+	if (IS_ERR(inst))
+		goto out_put_alg;
+
+	inst-&gt;alg.cra_flags = CRYPTO_ALG_TYPE_BLKCIPHER;
+	inst-&gt;alg.cra_priority = alg-&gt;cra_priority;
+	inst-&gt;alg.cra_blocksize = alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_alignmask = alg-&gt;cra_alignmask;
+	inst-&gt;alg.cra_type = &amp;crypto_blkcipher_type;
+
+	if (!(alg-&gt;cra_blocksize % 4))
+		inst-&gt;alg.cra_alignmask |= 3;
+	inst-&gt;alg.cra_blkcipher.ivsize = alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_blkcipher.min_keysize = alg-&gt;cra_cipher.cia_min_keysize;
+	inst-&gt;alg.cra_blkcipher.max_keysize = alg-&gt;cra_cipher.cia_max_keysize;
+
+	inst-&gt;alg.cra_ctxsize = sizeof(struct crypto_pcbc_ctx);
+
+	inst-&gt;alg.cra_init = crypto_pcbc_init_tfm;
+	inst-&gt;alg.cra_exit = crypto_pcbc_exit_tfm;
+
+	inst-&gt;alg.cra_blkcipher.setkey = crypto_pcbc_setkey;
+	inst-&gt;alg.cra_blkcipher.encrypt = crypto_pcbc_encrypt;
+	inst-&gt;alg.cra_blkcipher.decrypt = crypto_pcbc_decrypt;
+
+out_put_alg:
+	crypto_mod_put(alg);
+	return inst;
+}
+
+static void crypto_pcbc_free(struct crypto_instance *inst)
+{
+	crypto_drop_spawn(crypto_instance_ctx(inst));
+	kfree(inst);
+}
+
+static struct crypto_template crypto_pcbc_tmpl = {
+	.name = "pcbc",
+	.alloc = crypto_pcbc_alloc,
+	.free = crypto_pcbc_free,
+	.module = THIS_MODULE,
+};
+
+static int __init crypto_pcbc_module_init(void)
+{
+	return crypto_register_template(&amp;crypto_pcbc_tmpl);
+}
+
+static void __exit crypto_pcbc_module_exit(void)
+{
+	crypto_unregister_template(&amp;crypto_pcbc_tmpl);
+}
+
+module_init(crypto_pcbc_module_init);
+module_exit(crypto_pcbc_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("PCBC block cipher algorithm");
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061215221735</emailId><senderName>hyplex</senderName><senderEmail>hyplex@earthlink.net</senderEmail><timestampReceived>2006-12-15 22:17:35-0400</timestampReceived><subject>aes-pipe -p function.</subject><body>

I noticed something in aes-pipe that I found kinda odd (or at least 
didn't work the way I was expecting).

I was using a dos formated key file and a unix format key file in a 
command such as '...|aes-pipe -p 3 3&lt;keys &gt;foobar.out', and to my 
surprise they produced different results(foobar.out).  I expected them 
to only work on the ascii representation of the keys, and to convert 
them into the actual binary key.  Upon looking at the code though 
(hopefully I just overlooked something) it doesn't do such a conversion 
and it checks the keys file for '\n' or \0 to end a key line.  So...

If this is the case, you can either 1) continue to use the ascii 
representation anyway, but then each byte of your key is limited to the 
ascii representation of 0-f.  or 2)  use binary keys, but make sure they 
do not contain the binary values 0x00 or 0x10  (which also means you 
can't run your key through a hash that could possibly produce these values).

Am I missing something or is this how it works?

Thanks,

Marco Fonseca

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061216191522</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-12-16 19:15:22-0400</timestampReceived><subject>[ANN] Acrypto asynchronous crypto layer 2.6.19 release.</subject><body>

Hello.

I am pleased to announce new release of the acrypto for 2.6.19 kernel -
first asynchronous crypto layer for Linux kernel 2.6.

Acrypto allows to handle crypto requests asynchronously in hardware.

Acrypto supports following features:
 * multiple asynchronous crypto device queues
 * crypto session routing (allows to complete single crypto session when
   several operations (crypto, hmac, anything) are completed)
 * crypto session binding (bind crypto processing to specified device)
 * modular load balancing (one can created load balancer which will get
   into account for example pid of the calling process)
 * crypto session batching genetically implemented by design (acrypto
   provides the whole data structure to crypto device, i.e. it is
   possible to use acrypto as a bridge which routes requests between
   completely different devices, since it does not differentiate between
   users, just handles requests)
 * crypto session priority
 * different kinds of crypto operation(RNG, asymmetrical crypto, HMAC and
   any other)

Combined patchset includes:
 * acrypto core
 * IPsec ESP4 port to acrypto
 * dm-crypt port to acrypto
 * OCF to acrypto bridge, which allows to run OCF device
   drivers with acrypto (for example ixp4xx), requires OCF installed.

Ported crypto drivers and benchmarks can be found on acrypto homepage:
http://tservice.net.ru/~s0mbre/old/?section=projects&amp;item=acrypto

Changes from previous release:
 * moved to 2.6.19 crypto API where it is used
 * updated XFRM engine
 * bugfixes

2.6.16 - 2.6.18 releases moved to maintenance mode.

Patchset is not attached due to its size (192kb).

Signed-off-by: Evgeniy Polyakov &lt;johnpol@2ka.mipt.ru&gt;

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061207125621</emailId><senderName>"Leo B."</senderName><senderEmail>spam-goes-to-dev-null@gmx.net</senderEmail><timestampReceived>2006-12-07 12:56:21-0400</timestampReceived><subject>LUKS and loop-AES</subject><body>


Hi,

someone recently told me about LUKS:
http://luks.endorphin.org/

Their effort is to create a standard for linux disk encryption:
"LUKS is the upcoming standard for Linux hard disk encryption.
By providing a standard on-disk-format, it does not only facilitate
compatibility among distributions, but also provide secure management
of multiple user passwords. In contrast to existing solution, LUKS
stores all setup necessary setup information in the partition header,
enabling the user to transport or migrate his data seamlessly."

Jari and others, can you please tell me if looks is "good", i.e.
if it is as secure as loop-AES or if it has flaws; if the design
is fine, etc.
And Jari, might it happen that you integrate loop-AES into LUKS
or help those people make their code secure?

I will set up a fileserver configuration with &gt; 1 TB disks in
two weeks and I'm also wondering if I might use LUKS already
because that configuration will be used for several years.

Thanks, Leo B.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061218095740</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-12-18 09:57:40-0400</timestampReceived><subject>Re: [ANN] Acrypto asynchronous crypto layer 2.6.19 release.</subject><body>

On Mon, Dec 18, 2006 at 08:38:54AM +0100, Andreas Jellinghaus (aj@dungeon.inka.de) wrote:
&gt; Does acrypto still have the same size restrictions
&gt; I ran into with the last release?

Actually I do not recall what is 'size retrictions' - if you talk about
possibility to use software crypto provider, which supports one cipher
in a time, then yes, but it is intended to be used with hardware though.
Otherwise I do not recall any problems pointed to me.

&gt; Thanks, Andreas

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061218131357</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-12-18 13:13:57-0400</timestampReceived><subject>Re: [ANN] Acrypto asynchronous crypto layer 2.6.19 release.</subject><body>

On Mon, Dec 18, 2006 at 02:00:26PM +0100, Andreas Jellinghaus (aj@ciphirelabs.com) wrote:
&gt; Evgeniy Polyakov wrote:
&gt; &gt;Actually I do not recall what is 'size retrictions' - if you talk about
&gt; &gt;possibility to use software crypto provider, which supports one cipher
&gt; &gt;in a time, then yes, but it is intended to be used with hardware though.
&gt; &gt;Otherwise I do not recall any problems pointed to me.
&gt; 
&gt; sorry, "size restriction" was the wrong term. acrypto only supports
&gt; "sync provider only supports AES-128 in CBC mode, so if you try
&gt; different ciphers, there can be some problems."

You can change it in async_provider in compilation time or I can create
module version. There is an item in related todo list to use crypto
contexts, they were created exactly for such kind of things (actually
for hardware devices which do not support realtime key changes).

&gt; and I'm using dm-crypto with aes-cbc-essiv:sha256 and your acrypto patch
&gt; breaks this setup - not only acrypto doesn't provide crypto capability 
&gt; for my setup, but with this patch it is not offered by the old mechanism
&gt; either, so my system has no way to decrypt the root partition. note:
&gt; that was with the 2.6.18 patch, no idea if it is different now.
&gt; 
&gt; so while the patch adds new features, it also removes some features -
&gt; not sure if always (via patch) or via compile option or via module
&gt; load. also I'm not sure if acrypto can be disabled via kernel command
&gt; line to get the old behaviour (including aes-cbc-essiv:sha256 support
&gt; for dm-crypt).
&gt; 
&gt; would be nice to track those issues, so people testing your patch
&gt; are aware of the situation.

I will change acrypto software crypto provider, but right now, yes,
software crypto only supports one mode.

&gt; Regards, Andreas

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>200612141255590</emailId><senderName>David Howells</senderName><senderEmail>dhowells@redhat.com</senderEmail><timestampReceived>2006-12-14 12:55:59-0400</timestampReceived><subject>[PATCH 1/2] Add PCBC crypto template support</subject><body>

Add PCBC crypto template support as used by RxRPC.

Signed-Off-By: David Howells &lt;dhowells@redhat.com&gt;
---

 crypto/Kconfig  |    9 +
 crypto/Makefile |    1 
 crypto/pcbc.c   |  348 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 358 insertions(+), 0 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
index 92ba249..9d3a44c 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -168,6 +168,15 @@ config CRYPTO_CBC
 	  CBC: Cipher Block Chaining mode
 	  This block cipher algorithm is required for IPSec.
 
+config CRYPTO_PCBC
+	tristate "PCBC support"
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_MANAGER
+	default m
+	help
+	  PCBC: Propagating Cipher Block Chaining mode
+	  This block cipher algorithm is required for RxRPC.
+
 config CRYPTO_LRW
 	tristate "LRW support (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
diff --git a/crypto/Makefile b/crypto/Makefile
index 60e3d24..9ef048d 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_CRYPTO_TGR192) += tgr192.o
 obj-$(CONFIG_CRYPTO_GF128MUL) += gf128mul.o
 obj-$(CONFIG_CRYPTO_ECB) += ecb.o
 obj-$(CONFIG_CRYPTO_CBC) += cbc.o
+obj-$(CONFIG_CRYPTO_PCBC) += pcbc.o
 obj-$(CONFIG_CRYPTO_LRW) += lrw.o
 obj-$(CONFIG_CRYPTO_DES) += des.o
 obj-$(CONFIG_CRYPTO_BLOWFISH) += blowfish.o
diff --git a/crypto/pcbc.c b/crypto/pcbc.c
new file mode 100644
index 0000000..0ffb46e
--- /dev/null
+++ b/crypto/pcbc.c
@@ -0,0 +1,348 @@
+/*
+ * PCBC: Propagating Cipher Block Chaining mode
+ *
+ * Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * Derived from cbc.c
+ * - Copyright (c) 2006 Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include &lt;crypto/algapi.h&gt;
+#include &lt;linux/err.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include &lt;linux/slab.h&gt;
+
+struct crypto_pcbc_ctx {
+	struct crypto_cipher *child;
+	void (*xor)(u8 *dst, const u8 *src, unsigned int bs);
+};
+
+static int crypto_pcbc_setkey(struct crypto_tfm *parent, const u8 *key,
+			      unsigned int keylen)
+{
+	struct crypto_pcbc_ctx *ctx = crypto_tfm_ctx(parent);
+	struct crypto_cipher *child = ctx-&gt;child;
+	int err;
+
+	crypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
+	crypto_cipher_set_flags(child, crypto_tfm_get_flags(parent) &amp;
+				CRYPTO_TFM_REQ_MASK);
+	err = crypto_cipher_setkey(child, key, keylen);
+	crypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &amp;
+			     CRYPTO_TFM_RES_MASK);
+	return err;
+}
+
+static int crypto_pcbc_encrypt_segment(struct blkcipher_desc *desc,
+				       struct blkcipher_walk *walk,
+				       struct crypto_cipher *tfm,
+				       void (*xor)(u8 *, const u8 *,
+						   unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_encrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 *dst = walk-&gt;dst.virt.addr;
+	u8 *iv = walk-&gt;iv;
+
+	do {
+		xor(iv, src, bsize);
+		fn(crypto_cipher_tfm(tfm), dst, iv);
+		memcpy(iv, dst, bsize);
+		xor(iv, src, bsize);
+
+		src += bsize;
+		dst += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	return nbytes;
+}
+
+static int crypto_pcbc_encrypt_inplace(struct blkcipher_desc *desc,
+				       struct blkcipher_walk *walk,
+				       struct crypto_cipher *tfm,
+				       void (*xor)(u8 *, const u8 *,
+						   unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_encrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 *iv = walk-&gt;iv;
+	u8 tmpbuf[bsize];
+
+	do {
+		memcpy(tmpbuf, src, bsize);
+		xor(iv, tmpbuf, bsize);
+		fn(crypto_cipher_tfm(tfm), src, iv);
+		memcpy(iv, src, bsize);
+		xor(iv, tmpbuf, bsize);
+
+		src += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	memcpy(walk-&gt;iv, iv, bsize);
+
+	return nbytes;
+}
+
+static int crypto_pcbc_encrypt(struct blkcipher_desc *desc,
+			       struct scatterlist *dst, struct scatterlist *src,
+			       unsigned int nbytes)
+{
+	struct blkcipher_walk walk;
+	struct crypto_blkcipher *tfm = desc-&gt;tfm;
+	struct crypto_pcbc_ctx *ctx = crypto_blkcipher_ctx(tfm);
+	struct crypto_cipher *child = ctx-&gt;child;
+	void (*xor)(u8 *, const u8 *, unsigned int bs) = ctx-&gt;xor;
+	int err;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while ((nbytes = walk.nbytes)) {
+		if (walk.src.virt.addr == walk.dst.virt.addr)
+			nbytes = crypto_pcbc_encrypt_inplace(desc, &amp;walk, child,
+							     xor);
+		else
+			nbytes = crypto_pcbc_encrypt_segment(desc, &amp;walk, child,
+							     xor);
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static int crypto_pcbc_decrypt_segment(struct blkcipher_desc *desc,
+				       struct blkcipher_walk *walk,
+				       struct crypto_cipher *tfm,
+				       void (*xor)(u8 *, const u8 *,
+						   unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_decrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 *dst = walk-&gt;dst.virt.addr;
+	u8 *iv = walk-&gt;iv;
+
+	do {
+		fn(crypto_cipher_tfm(tfm), dst, src);
+		xor(dst, iv, bsize);
+		memcpy(iv, src, bsize);
+		xor(iv, dst, bsize);
+
+		src += bsize;
+		dst += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	memcpy(walk-&gt;iv, iv, bsize);
+
+	return nbytes;
+}
+
+static int crypto_pcbc_decrypt_inplace(struct blkcipher_desc *desc,
+				       struct blkcipher_walk *walk,
+				       struct crypto_cipher *tfm,
+				       void (*xor)(u8 *, const u8 *,
+						   unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_decrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 *iv = walk-&gt;iv;
+	u8 tmpbuf[bsize];
+
+	do {
+		memcpy(tmpbuf, src, bsize);
+		fn(crypto_cipher_tfm(tfm), src, src);
+		xor(src, iv, bsize);
+		memcpy(iv, tmpbuf, bsize);
+		xor(iv, src, bsize);
+
+		src += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	memcpy(walk-&gt;iv, iv, bsize);
+
+	return nbytes;
+}
+
+static int crypto_pcbc_decrypt(struct blkcipher_desc *desc,
+			       struct scatterlist *dst, struct scatterlist *src,
+			       unsigned int nbytes)
+{
+	struct blkcipher_walk walk;
+	struct crypto_blkcipher *tfm = desc-&gt;tfm;
+	struct crypto_pcbc_ctx *ctx = crypto_blkcipher_ctx(tfm);
+	struct crypto_cipher *child = ctx-&gt;child;
+	void (*xor)(u8 *, const u8 *, unsigned int bs) = ctx-&gt;xor;
+	int err;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while ((nbytes = walk.nbytes)) {
+		if (walk.src.virt.addr == walk.dst.virt.addr)
+			nbytes = crypto_pcbc_decrypt_inplace(desc, &amp;walk, child,
+							     xor);
+		else
+			nbytes = crypto_pcbc_decrypt_segment(desc, &amp;walk, child,
+							     xor);
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static void xor_byte(u8 *a, const u8 *b, unsigned int bs)
+{
+	do {
+		*a++ ^= *b++;
+	} while (--bs);
+}
+
+static void xor_quad(u8 *dst, const u8 *src, unsigned int bs)
+{
+	u32 *a = (u32 *)dst;
+	u32 *b = (u32 *)src;
+
+	do {
+		*a++ ^= *b++;
+	} while ((bs -= 4));
+}
+
+static void xor_64(u8 *a, const u8 *b, unsigned int bs)
+{
+	((u32 *)a)[0] ^= ((u32 *)b)[0];
+	((u32 *)a)[1] ^= ((u32 *)b)[1];
+}
+
+static void xor_128(u8 *a, const u8 *b, unsigned int bs)
+{
+	((u32 *)a)[0] ^= ((u32 *)b)[0];
+	((u32 *)a)[1] ^= ((u32 *)b)[1];
+	((u32 *)a)[2] ^= ((u32 *)b)[2];
+	((u32 *)a)[3] ^= ((u32 *)b)[3];
+}
+
+static int crypto_pcbc_init_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_instance *inst = (void *)tfm-&gt;__crt_alg;
+	struct crypto_spawn *spawn = crypto_instance_ctx(inst);
+	struct crypto_pcbc_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	switch (crypto_tfm_alg_blocksize(tfm)) {
+	case 8:
+		ctx-&gt;xor = xor_64;
+		break;
+
+	case 16:
+		ctx-&gt;xor = xor_128;
+		break;
+
+	default:
+		if (crypto_tfm_alg_blocksize(tfm) % 4)
+			ctx-&gt;xor = xor_byte;
+		else
+			ctx-&gt;xor = xor_quad;
+	}
+
+	tfm = crypto_spawn_tfm(spawn);
+	if (IS_ERR(tfm))
+		return PTR_ERR(tfm);
+
+	ctx-&gt;child = crypto_cipher_cast(tfm);
+	return 0;
+}
+
+static void crypto_pcbc_exit_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_pcbc_ctx *ctx = crypto_tfm_ctx(tfm);
+	crypto_free_cipher(ctx-&gt;child);
+}
+
+static struct crypto_instance *crypto_pcbc_alloc(void *param, unsigned int len)
+{
+	struct crypto_instance *inst;
+	struct crypto_alg *alg;
+
+	alg = crypto_get_attr_alg(param, len, CRYPTO_ALG_TYPE_CIPHER,
+				  CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_ASYNC);
+	if (IS_ERR(alg))
+		return ERR_PTR(PTR_ERR(alg));
+
+	inst = crypto_alloc_instance("pcbc", alg);
+	if (IS_ERR(inst))
+		goto out_put_alg;
+
+	inst-&gt;alg.cra_flags = CRYPTO_ALG_TYPE_BLKCIPHER;
+	inst-&gt;alg.cra_priority = alg-&gt;cra_priority;
+	inst-&gt;alg.cra_blocksize = alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_alignmask = alg-&gt;cra_alignmask;
+	inst-&gt;alg.cra_type = &amp;crypto_blkcipher_type;
+
+	if (!(alg-&gt;cra_blocksize % 4))
+		inst-&gt;alg.cra_alignmask |= 3;
+	inst-&gt;alg.cra_blkcipher.ivsize = alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_blkcipher.min_keysize = alg-&gt;cra_cipher.cia_min_keysize;
+	inst-&gt;alg.cra_blkcipher.max_keysize = alg-&gt;cra_cipher.cia_max_keysize;
+
+	inst-&gt;alg.cra_ctxsize = sizeof(struct crypto_pcbc_ctx);
+
+	inst-&gt;alg.cra_init = crypto_pcbc_init_tfm;
+	inst-&gt;alg.cra_exit = crypto_pcbc_exit_tfm;
+
+	inst-&gt;alg.cra_blkcipher.setkey = crypto_pcbc_setkey;
+	inst-&gt;alg.cra_blkcipher.encrypt = crypto_pcbc_encrypt;
+	inst-&gt;alg.cra_blkcipher.decrypt = crypto_pcbc_decrypt;
+
+out_put_alg:
+	crypto_mod_put(alg);
+	return inst;
+}
+
+static void crypto_pcbc_free(struct crypto_instance *inst)
+{
+	crypto_drop_spawn(crypto_instance_ctx(inst));
+	kfree(inst);
+}
+
+static struct crypto_template crypto_pcbc_tmpl = {
+	.name = "pcbc",
+	.alloc = crypto_pcbc_alloc,
+	.free = crypto_pcbc_free,
+	.module = THIS_MODULE,
+};
+
+static int __init crypto_pcbc_module_init(void)
+{
+	return crypto_register_template(&amp;crypto_pcbc_tmpl);
+}
+
+static void __exit crypto_pcbc_module_exit(void)
+{
+	crypto_unregister_template(&amp;crypto_pcbc_tmpl);
+}
+
+module_init(crypto_pcbc_module_init);
+module_exit(crypto_pcbc_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("PCBC block cipher algorithm");

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061215102637</emailId><senderName>David Howells</senderName><senderEmail>dhowells@redhat.com</senderEmail><timestampReceived>2006-12-15 10:26:37-0400</timestampReceived><subject>[PATCH 1/2] Add PCBC crypto template support</subject><body>

Add PCBC crypto template support as used by RxRPC.

Signed-Off-By: David Howells &lt;dhowells@redhat.com&gt;
---

 crypto/Kconfig  |    9 +
 crypto/Makefile |    1 
 crypto/pcbc.c   |  348 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 358 insertions(+), 0 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
index 92ba249..9d3a44c 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -168,6 +168,15 @@ config CRYPTO_CBC
 	  CBC: Cipher Block Chaining mode
 	  This block cipher algorithm is required for IPSec.
 
+config CRYPTO_PCBC
+	tristate "PCBC support"
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_MANAGER
+	default m
+	help
+	  PCBC: Propagating Cipher Block Chaining mode
+	  This block cipher algorithm is required for RxRPC.
+
 config CRYPTO_LRW
 	tristate "LRW support (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
diff --git a/crypto/Makefile b/crypto/Makefile
index 60e3d24..9ef048d 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_CRYPTO_TGR192) += tgr192.o
 obj-$(CONFIG_CRYPTO_GF128MUL) += gf128mul.o
 obj-$(CONFIG_CRYPTO_ECB) += ecb.o
 obj-$(CONFIG_CRYPTO_CBC) += cbc.o
+obj-$(CONFIG_CRYPTO_PCBC) += pcbc.o
 obj-$(CONFIG_CRYPTO_LRW) += lrw.o
 obj-$(CONFIG_CRYPTO_DES) += des.o
 obj-$(CONFIG_CRYPTO_BLOWFISH) += blowfish.o
diff --git a/crypto/pcbc.c b/crypto/pcbc.c
new file mode 100644
index 0000000..0ffb46e
--- /dev/null
+++ b/crypto/pcbc.c
@@ -0,0 +1,348 @@
+/*
+ * PCBC: Propagating Cipher Block Chaining mode
+ *
+ * Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * Derived from cbc.c
+ * - Copyright (c) 2006 Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include &lt;crypto/algapi.h&gt;
+#include &lt;linux/err.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include &lt;linux/slab.h&gt;
+
+struct crypto_pcbc_ctx {
+	struct crypto_cipher *child;
+	void (*xor)(u8 *dst, const u8 *src, unsigned int bs);
+};
+
+static int crypto_pcbc_setkey(struct crypto_tfm *parent, const u8 *key,
+			      unsigned int keylen)
+{
+	struct crypto_pcbc_ctx *ctx = crypto_tfm_ctx(parent);
+	struct crypto_cipher *child = ctx-&gt;child;
+	int err;
+
+	crypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
+	crypto_cipher_set_flags(child, crypto_tfm_get_flags(parent) &amp;
+				CRYPTO_TFM_REQ_MASK);
+	err = crypto_cipher_setkey(child, key, keylen);
+	crypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &amp;
+			     CRYPTO_TFM_RES_MASK);
+	return err;
+}
+
+static int crypto_pcbc_encrypt_segment(struct blkcipher_desc *desc,
+				       struct blkcipher_walk *walk,
+				       struct crypto_cipher *tfm,
+				       void (*xor)(u8 *, const u8 *,
+						   unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_encrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 *dst = walk-&gt;dst.virt.addr;
+	u8 *iv = walk-&gt;iv;
+
+	do {
+		xor(iv, src, bsize);
+		fn(crypto_cipher_tfm(tfm), dst, iv);
+		memcpy(iv, dst, bsize);
+		xor(iv, src, bsize);
+
+		src += bsize;
+		dst += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	return nbytes;
+}
+
+static int crypto_pcbc_encrypt_inplace(struct blkcipher_desc *desc,
+				       struct blkcipher_walk *walk,
+				       struct crypto_cipher *tfm,
+				       void (*xor)(u8 *, const u8 *,
+						   unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_encrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 *iv = walk-&gt;iv;
+	u8 tmpbuf[bsize];
+
+	do {
+		memcpy(tmpbuf, src, bsize);
+		xor(iv, tmpbuf, bsize);
+		fn(crypto_cipher_tfm(tfm), src, iv);
+		memcpy(iv, src, bsize);
+		xor(iv, tmpbuf, bsize);
+
+		src += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	memcpy(walk-&gt;iv, iv, bsize);
+
+	return nbytes;
+}
+
+static int crypto_pcbc_encrypt(struct blkcipher_desc *desc,
+			       struct scatterlist *dst, struct scatterlist *src,
+			       unsigned int nbytes)
+{
+	struct blkcipher_walk walk;
+	struct crypto_blkcipher *tfm = desc-&gt;tfm;
+	struct crypto_pcbc_ctx *ctx = crypto_blkcipher_ctx(tfm);
+	struct crypto_cipher *child = ctx-&gt;child;
+	void (*xor)(u8 *, const u8 *, unsigned int bs) = ctx-&gt;xor;
+	int err;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while ((nbytes = walk.nbytes)) {
+		if (walk.src.virt.addr == walk.dst.virt.addr)
+			nbytes = crypto_pcbc_encrypt_inplace(desc, &amp;walk, child,
+							     xor);
+		else
+			nbytes = crypto_pcbc_encrypt_segment(desc, &amp;walk, child,
+							     xor);
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static int crypto_pcbc_decrypt_segment(struct blkcipher_desc *desc,
+				       struct blkcipher_walk *walk,
+				       struct crypto_cipher *tfm,
+				       void (*xor)(u8 *, const u8 *,
+						   unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_decrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 *dst = walk-&gt;dst.virt.addr;
+	u8 *iv = walk-&gt;iv;
+
+	do {
+		fn(crypto_cipher_tfm(tfm), dst, src);
+		xor(dst, iv, bsize);
+		memcpy(iv, src, bsize);
+		xor(iv, dst, bsize);
+
+		src += bsize;
+		dst += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	memcpy(walk-&gt;iv, iv, bsize);
+
+	return nbytes;
+}
+
+static int crypto_pcbc_decrypt_inplace(struct blkcipher_desc *desc,
+				       struct blkcipher_walk *walk,
+				       struct crypto_cipher *tfm,
+				       void (*xor)(u8 *, const u8 *,
+						   unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_decrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 *iv = walk-&gt;iv;
+	u8 tmpbuf[bsize];
+
+	do {
+		memcpy(tmpbuf, src, bsize);
+		fn(crypto_cipher_tfm(tfm), src, src);
+		xor(src, iv, bsize);
+		memcpy(iv, tmpbuf, bsize);
+		xor(iv, src, bsize);
+
+		src += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	memcpy(walk-&gt;iv, iv, bsize);
+
+	return nbytes;
+}
+
+static int crypto_pcbc_decrypt(struct blkcipher_desc *desc,
+			       struct scatterlist *dst, struct scatterlist *src,
+			       unsigned int nbytes)
+{
+	struct blkcipher_walk walk;
+	struct crypto_blkcipher *tfm = desc-&gt;tfm;
+	struct crypto_pcbc_ctx *ctx = crypto_blkcipher_ctx(tfm);
+	struct crypto_cipher *child = ctx-&gt;child;
+	void (*xor)(u8 *, const u8 *, unsigned int bs) = ctx-&gt;xor;
+	int err;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while ((nbytes = walk.nbytes)) {
+		if (walk.src.virt.addr == walk.dst.virt.addr)
+			nbytes = crypto_pcbc_decrypt_inplace(desc, &amp;walk, child,
+							     xor);
+		else
+			nbytes = crypto_pcbc_decrypt_segment(desc, &amp;walk, child,
+							     xor);
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static void xor_byte(u8 *a, const u8 *b, unsigned int bs)
+{
+	do {
+		*a++ ^= *b++;
+	} while (--bs);
+}
+
+static void xor_quad(u8 *dst, const u8 *src, unsigned int bs)
+{
+	u32 *a = (u32 *)dst;
+	u32 *b = (u32 *)src;
+
+	do {
+		*a++ ^= *b++;
+	} while ((bs -= 4));
+}
+
+static void xor_64(u8 *a, const u8 *b, unsigned int bs)
+{
+	((u32 *)a)[0] ^= ((u32 *)b)[0];
+	((u32 *)a)[1] ^= ((u32 *)b)[1];
+}
+
+static void xor_128(u8 *a, const u8 *b, unsigned int bs)
+{
+	((u32 *)a)[0] ^= ((u32 *)b)[0];
+	((u32 *)a)[1] ^= ((u32 *)b)[1];
+	((u32 *)a)[2] ^= ((u32 *)b)[2];
+	((u32 *)a)[3] ^= ((u32 *)b)[3];
+}
+
+static int crypto_pcbc_init_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_instance *inst = (void *)tfm-&gt;__crt_alg;
+	struct crypto_spawn *spawn = crypto_instance_ctx(inst);
+	struct crypto_pcbc_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	switch (crypto_tfm_alg_blocksize(tfm)) {
+	case 8:
+		ctx-&gt;xor = xor_64;
+		break;
+
+	case 16:
+		ctx-&gt;xor = xor_128;
+		break;
+
+	default:
+		if (crypto_tfm_alg_blocksize(tfm) % 4)
+			ctx-&gt;xor = xor_byte;
+		else
+			ctx-&gt;xor = xor_quad;
+	}
+
+	tfm = crypto_spawn_tfm(spawn);
+	if (IS_ERR(tfm))
+		return PTR_ERR(tfm);
+
+	ctx-&gt;child = crypto_cipher_cast(tfm);
+	return 0;
+}
+
+static void crypto_pcbc_exit_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_pcbc_ctx *ctx = crypto_tfm_ctx(tfm);
+	crypto_free_cipher(ctx-&gt;child);
+}
+
+static struct crypto_instance *crypto_pcbc_alloc(void *param, unsigned int len)
+{
+	struct crypto_instance *inst;
+	struct crypto_alg *alg;
+
+	alg = crypto_get_attr_alg(param, len, CRYPTO_ALG_TYPE_CIPHER,
+				  CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_ASYNC);
+	if (IS_ERR(alg))
+		return ERR_PTR(PTR_ERR(alg));
+
+	inst = crypto_alloc_instance("pcbc", alg);
+	if (IS_ERR(inst))
+		goto out_put_alg;
+
+	inst-&gt;alg.cra_flags = CRYPTO_ALG_TYPE_BLKCIPHER;
+	inst-&gt;alg.cra_priority = alg-&gt;cra_priority;
+	inst-&gt;alg.cra_blocksize = alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_alignmask = alg-&gt;cra_alignmask;
+	inst-&gt;alg.cra_type = &amp;crypto_blkcipher_type;
+
+	if (!(alg-&gt;cra_blocksize % 4))
+		inst-&gt;alg.cra_alignmask |= 3;
+	inst-&gt;alg.cra_blkcipher.ivsize = alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_blkcipher.min_keysize = alg-&gt;cra_cipher.cia_min_keysize;
+	inst-&gt;alg.cra_blkcipher.max_keysize = alg-&gt;cra_cipher.cia_max_keysize;
+
+	inst-&gt;alg.cra_ctxsize = sizeof(struct crypto_pcbc_ctx);
+
+	inst-&gt;alg.cra_init = crypto_pcbc_init_tfm;
+	inst-&gt;alg.cra_exit = crypto_pcbc_exit_tfm;
+
+	inst-&gt;alg.cra_blkcipher.setkey = crypto_pcbc_setkey;
+	inst-&gt;alg.cra_blkcipher.encrypt = crypto_pcbc_encrypt;
+	inst-&gt;alg.cra_blkcipher.decrypt = crypto_pcbc_decrypt;
+
+out_put_alg:
+	crypto_mod_put(alg);
+	return inst;
+}
+
+static void crypto_pcbc_free(struct crypto_instance *inst)
+{
+	crypto_drop_spawn(crypto_instance_ctx(inst));
+	kfree(inst);
+}
+
+static struct crypto_template crypto_pcbc_tmpl = {
+	.name = "pcbc",
+	.alloc = crypto_pcbc_alloc,
+	.free = crypto_pcbc_free,
+	.module = THIS_MODULE,
+};
+
+static int __init crypto_pcbc_module_init(void)
+{
+	return crypto_register_template(&amp;crypto_pcbc_tmpl);
+}
+
+static void __exit crypto_pcbc_module_exit(void)
+{
+	crypto_unregister_template(&amp;crypto_pcbc_tmpl);
+}
+
+module_init(crypto_pcbc_module_init);
+module_exit(crypto_pcbc_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("PCBC block cipher algorithm");
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061116070516</emailId><senderName></senderName><senderEmail>linux</senderEmail><timestampReceived>2006-11-16 07:05:16-0400</timestampReceived><subject>crypto/des.c cleanups for review</subject><body>

I sent this to &lt;da@osvik.no&gt; on Nov. 1, but have received no response.
Is anyone interested?  The changes are all mixed up together, but I can
break them apart into a patch series if desired.

Going roughly in hunk order:
- Moved ROR and ROL macros closer to the IP and FP macros where
  they're used.
- Added comments in a number of places.
- Factored out the MASKSWAP() primitive from IP() and FP().
- Changed ROUND() slightly to reduce the number of temps needed.
  This is where I particularly want to ask you if there's a reason for
  the way you did it before.  Perferring 16-bit shifts to 8-bit ones is
  a 680[01]0 optimization, but is that terribly important these days?
  Coldfire has single-cycle shifts.
- Made the use of pt variable by the PC2() macro explicit.
- Does ekey() need that manually scheduled code?
- Shrunk dkey() code size, at some expense to speed.
- Eliminated flags local variable as unnecessary.
- Improved DES3 bad-key detection to ignore parity bits.

(All placed in the public domain if you want to use them.)

diff --git a/crypto/des.c b/crypto/des.c
index 1df3a71..856d843 100644
--- a/crypto/des.c
+++ b/crypto/des.c
@@ -28,9 +28,6 @@ #define DES3_EDE_KEY_SIZE	(3 * DES_KEY_S
 #define DES3_EDE_EXPKEY_WORDS	(3 * DES_EXPKEY_WORDS)
 #define DES3_EDE_BLOCK_SIZE	DES_BLOCK_SIZE
 
-#define ROL(x, r) ((x) = rol32((x), (r)))
-#define ROR(x, r) ((x) = ror32((x), (r)))
-
 struct des_ctx {
 	u32 expkey[DES_EXPKEY_WORDS];
 };
@@ -76,6 +73,12 @@ static const u8 pc1[256] = {
 	0xae, 0xea, 0xee, 0xee, 0xbe, 0xfa, 0xfe, 0xfe
 };
 
+/*
+ * This table rotates the most significant 7 bits one place right.
+ * rs[i] = (i &gt;&gt; 1 &amp; 0x7e) + (i &lt;&lt; 6 &amp; 0x80)
+ * Note that the odd elements of this array are actually
+ * "don't care"; the index used always has the low bit clear.
+ */
 static const u8 rs[256] = {
 	0x00, 0x00, 0x80, 0x80, 0x02, 0x02, 0x82, 0x82,
 	0x04, 0x04, 0x84, 0x84, 0x06, 0x06, 0x86, 0x86,
@@ -111,6 +114,11 @@ static const u8 rs[256] = {
 	0x7c, 0x7c, 0xfc, 0xfc, 0x7e, 0x7e, 0xfe, 0xfe
 };
 
+/*
+ * The pc2 table consists of 2 sections.  Each section is
+ * 4 columns of 128 entries each.  See the PC2() macro
+ * for details.
+ */
 static const u32 pc2[1024] = {
 	0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00040000, 0x00000000, 0x04000000, 0x00100000,
@@ -527,84 +535,64 @@ static const u32 S8[64] = {
 
 /* Encryption components: IP, FP, and round function */
 
-#define IP(L, R, T)		\
-	ROL(R, 4);		\
-	T  = L;			\
-	L ^= R;			\
-	L &amp;= 0xf0f0f0f0;	\
-	R ^= L;			\
-	L ^= T;			\
-	ROL(R, 12);		\
-	T  = L;			\
-	L ^= R;			\
-	L &amp;= 0xffff0000;	\
-	R ^= L;			\
-	L ^= T;			\
-	ROR(R, 14);		\
-	T  = L;			\
-	L ^= R;			\
-	L &amp;= 0xcccccccc;	\
-	R ^= L;			\
-	L ^= T;			\
-	ROL(R, 6);		\
-	T  = L;			\
-	L ^= R;			\
-	L &amp;= 0xff00ff00;	\
-	R ^= L;			\
-	L ^= T;			\
-	ROR(R, 7);		\
+#define ROL(x, r) ((x) = rol32((x), (r)))
+#define ROR(x, r) ((x) = ror32((x), (r)))
+
+/* Swap the bits set in "mask" between L and R */
+#define MASKSWAP(L, R, T, mask)	\
 	T  = L;			\
 	L ^= R;			\
-	L &amp;= 0xaaaaaaaa;	\
+	L &amp;= (mask);		\
 	R ^= L;			\
-	L ^= T;			\
+	L ^= T;
+/*
+ * The above is more clearly written as 
+ * #define MASKSWAP(L, R, T, mask)	\
+ *	T  = (L ^ R) &amp; (mask);		\
+ *	L ^= T;  R ^= T;
+ * But the form used is better for a 2-operand procesor.
+ */
+
+/* Initial permutation */
+#define IP(L, R, T)			\
+	ROL(R, 4);			\
+	MASKSWAP(L, R, T, 0xf0f0f0f0);	\
+	ROL(R, 12);			\
+	MASKSWAP(L, R, T, 0xffff0000);	\
+	ROR(R, 14);			\
+	MASKSWAP(L, R, T, 0xcccccccc);	\
+	ROL(R, 6);			\
+	MASKSWAP(L, R, T, 0xff00ff00);	\
+	ROR(R, 7);			\
+	MASKSWAP(L, R, T, 0xaaaaaaaa);	\
 	ROL(L, 1);
 
-#define FP(L, R, T)		\
-	ROR(L, 1);		\
-	T  = L;			\
-	L ^= R;			\
-	L &amp;= 0xaaaaaaaa;	\
-	R ^= L;			\
-	L ^= T;			\
-	ROL(R, 7);		\
-	T  = L;			\
-	L ^= R;			\
-	L &amp;= 0xff00ff00;	\
-	R ^= L;			\
-	L ^= T;			\
-	ROR(R, 6);		\
-	T  = L;			\
-	L ^= R;			\
-	L &amp;= 0xcccccccc;	\
-	R ^= L;			\
-	L ^= T;			\
-	ROL(R, 14);		\
-	T  = L;			\
-	L ^= R;			\
-	L &amp;= 0xffff0000;	\
-	R ^= L;			\
-	L ^= T;			\
-	ROR(R, 12);		\
-	T  = L;			\
-	L ^= R;			\
-	L &amp;= 0xf0f0f0f0;	\
-	R ^= L;			\
-	L ^= T;			\
+/* Final permutation, inverse of initial permutation */
+#define FP(L, R, T)			\
+	ROR(L, 1);			\
+	MASKSWAP(L, R, T, 0xaaaaaaaa);	\
+	ROL(R, 7);			\
+	MASKSWAP(L, R, T, 0xff00ff00);	\
+	ROR(R, 6);			\
+	MASKSWAP(L, R, T, 0xcccccccc);	\
+	ROL(R, 14);			\
+	MASKSWAP(L, R, T, 0xffff0000);	\
+	ROR(R, 12);			\
+	MASKSWAP(L, R, T, 0xf0f0f0f0);	\
 	ROR(R, 4);
 
 #define ROUND(L, R, A, B, K, d)					\
-	B = K[0];			A = K[1];	K += d;	\
-	B ^= R;				A ^= R;			\
-	B &amp;= 0x3f3f3f3f;		ROR(A, 4);		\
-	L ^= S8[0xff &amp; B];		A &amp;= 0x3f3f3f3f;	\
-	L ^= S6[0xff &amp; (B &gt;&gt; 8)];	B &gt;&gt;= 16;		\
-	L ^= S7[0xff &amp; A];					\
-	L ^= S5[0xff &amp; (A &gt;&gt; 8)];	A &gt;&gt;= 16;		\
-	L ^= S4[0xff &amp; B];					\
-	L ^= S2[0xff &amp; (B &gt;&gt; 8)];				\
-	L ^= S3[0xff &amp; A];					\
-	L ^= S1[0xff &amp; (A &gt;&gt; 8)];
+	B = K[0];		A = K[1];		K += d;	\
+	B ^= R;			A ^= R;				\
+	B &amp;= 0x3f3f3f3f;	ROR(A, 4);			\
+	L ^= S8[0xff &amp; B];	A &amp;= 0x3f3f3f3f;	B &gt;&gt;= 8	\
+	L ^= S7[0xff &amp; A];	A &gt;&gt;= 8;			\
+	L ^= S6[0xff &amp; B];	B &gt;&gt;= 8;			\
+	L ^= S5[0xff &amp; A];	A &gt;&gt;= 8;			\
+	L ^= S4[0xff &amp; B];	B &gt;&gt;= 8;			\
+	L ^= S3[0xff &amp; A];	A &gt;&gt;= 8;			\
+	L ^= S2[B];						\
+	L ^= S1[A];
 
 /*
  * PC2 lookup tables are organized as 2 consecutive sets of 4 interleaved
@@ -615,12 +603,7 @@ #define ROUND(L, R, A, B, K, d)					\
  * or D_i in bits 7-1 (bit 0 being the least significant).
  */
 
-#define T1(x) pt[2 * (x) + 0]
-#define T2(x) pt[2 * (x) + 1]
-#define T3(x) pt[2 * (x) + 2]
-#define T4(x) pt[2 * (x) + 3]
-
-#define PC2(a, b, c, d) (T4(d) | T3(c) | T2(b) | T1(a))
+#define PC2(p, a, b, c, d) (p[2*(a)+0] | p[2*(b)+1] | p[2*(c)+2] | p[2*(d)+3])
 
 /*
  * Encryption key expansion
@@ -634,33 +617,33 @@ #define PC2(a, b, c, d) (T4(d) | T3(c) |
  *   Choice 1 has operated on the key.
  *
  */
-static unsigned long ekey(u32 *pe, const u8 *k)
+static unsigned long ekey(u32 pe[DES_EXPKEY_WORDS], const u8 k[DES_KEY_SIZE])
 {
-	/* K&amp;R: long is at least 32 bits */
+	/* Long is the size of pointer, so good for indexing */
 	unsigned long a, b, c, d, w;
 	const u32 *pt = pc2;
 
-	d = k[4]; d &amp;= 0x0e; d &lt;&lt;= 4; d |= k[0] &amp; 0x1e; d = pc1[d];
-	c = k[5]; c &amp;= 0x0e; c &lt;&lt;= 4; c |= k[1] &amp; 0x1e; c = pc1[c];
-	b = k[6]; b &amp;= 0x0e; b &lt;&lt;= 4; b |= k[2] &amp; 0x1e; b = pc1[b];
-	a = k[7]; a &amp;= 0x0e; a &lt;&lt;= 4; a |= k[3] &amp; 0x1e; a = pc1[a];
-
-	pe[15 * 2 + 0] = PC2(a, b, c, d); d = rs[d];
-	pe[14 * 2 + 0] = PC2(d, a, b, c); c = rs[c]; b = rs[b];
-	pe[13 * 2 + 0] = PC2(b, c, d, a); a = rs[a]; d = rs[d];
-	pe[12 * 2 + 0] = PC2(d, a, b, c); c = rs[c]; b = rs[b];
-	pe[11 * 2 + 0] = PC2(b, c, d, a); a = rs[a]; d = rs[d];
-	pe[10 * 2 + 0] = PC2(d, a, b, c); c = rs[c]; b = rs[b];
-	pe[ 9 * 2 + 0] = PC2(b, c, d, a); a = rs[a]; d = rs[d];
-	pe[ 8 * 2 + 0] = PC2(d, a, b, c); c = rs[c];
-	pe[ 7 * 2 + 0] = PC2(c, d, a, b); b = rs[b]; a = rs[a];
-	pe[ 6 * 2 + 0] = PC2(a, b, c, d); d = rs[d]; c = rs[c];
-	pe[ 5 * 2 + 0] = PC2(c, d, a, b); b = rs[b]; a = rs[a];
-	pe[ 4 * 2 + 0] = PC2(a, b, c, d); d = rs[d]; c = rs[c];
-	pe[ 3 * 2 + 0] = PC2(c, d, a, b); b = rs[b]; a = rs[a];
-	pe[ 2 * 2 + 0] = PC2(a, b, c, d); d = rs[d]; c = rs[c];
-	pe[ 1 * 2 + 0] = PC2(c, d, a, b); b = rs[b];
-	pe[ 0 * 2 + 0] = PC2(b, c, d, a);
+	d = pc1[ ((k[4] &amp; 0x0e) &lt;&lt; 4) + (k[0] &amp; 0x1e) ];
+	c = pc1[ ((k[5] &amp; 0x0e) &lt;&lt; 4) + (k[1] &amp; 0x1e) ];
+	b = pc1[ ((k[6] &amp; 0x0e) &lt;&lt; 4) + (k[2] &amp; 0x1e) ];
+	a = pc1[ ((k[7] &amp; 0x0e) &lt;&lt; 4) + (k[3] &amp; 0x1e) ];
+
+	pe[15 * 2 + 0] = PC2(pt, a, b, c, d); d = rs[d];
+	pe[14 * 2 + 0] = PC2(pt, d, a, b, c); c = rs[c]; b = rs[b];
+	pe[13 * 2 + 0] = PC2(pt, b, c, d, a); a = rs[a]; d = rs[d];
+	pe[12 * 2 + 0] = PC2(pt, d, a, b, c); c = rs[c]; b = rs[b];
+	pe[11 * 2 + 0] = PC2(pt, b, c, d, a); a = rs[a]; d = rs[d];
+	pe[10 * 2 + 0] = PC2(pt, d, a, b, c); c = rs[c]; b = rs[b];
+	pe[ 9 * 2 + 0] = PC2(pt, b, c, d, a); a = rs[a]; d = rs[d];
+	pe[ 8 * 2 + 0] = PC2(pt, d, a, b, c); c = rs[c];
+	pe[ 7 * 2 + 0] = PC2(pt, c, d, a, b); b = rs[b]; a = rs[a];
+	pe[ 6 * 2 + 0] = PC2(pt, a, b, c, d); d = rs[d]; c = rs[c];
+	pe[ 5 * 2 + 0] = PC2(pt, c, d, a, b); b = rs[b]; a = rs[a];
+	pe[ 4 * 2 + 0] = PC2(pt, a, b, c, d); d = rs[d]; c = rs[c];
+	pe[ 3 * 2 + 0] = PC2(pt, c, d, a, b); b = rs[b]; a = rs[a];
+	pe[ 2 * 2 + 0] = PC2(pt, a, b, c, d); d = rs[d]; c = rs[c];
+	pe[ 1 * 2 + 0] = PC2(pt, c, d, a, b); b = rs[b];
+	pe[ 0 * 2 + 0] = PC2(pt, b, c, d, a);
 
 	/* Check if first half is weak */
 	w  = (a ^ c) | (b ^ d) | (rs[a] ^ c) | (b ^ rs[d]);
@@ -668,30 +651,30 @@ static unsigned long ekey(u32 *pe, const
 	/* Skip to next table set */
 	pt += 512;
 
-	d = k[0]; d &amp;= 0xe0; d &gt;&gt;= 4; d |= k[4] &amp; 0xf0; d = pc1[d + 1];
-	c = k[1]; c &amp;= 0xe0; c &gt;&gt;= 4; c |= k[5] &amp; 0xf0; c = pc1[c + 1];
-	b = k[2]; b &amp;= 0xe0; b &gt;&gt;= 4; b |= k[6] &amp; 0xf0; b = pc1[b + 1];
-	a = k[3]; a &amp;= 0xe0; a &gt;&gt;= 4; a |= k[7] &amp; 0xf0; a = pc1[a + 1];
+	d = pc1[ ((k[0] &amp; 0xe0) &gt;&gt; 4) + (k[4] &amp; 0xf0) + 1 ];
+	c = pc1[ ((k[1] &amp; 0xe0) &gt;&gt; 4) + (k[5] &amp; 0xf0) + 1 ];
+	b = pc1[ ((k[2] &amp; 0xe0) &gt;&gt; 4) + (k[6] &amp; 0xf0) + 1 ];
+	a = pc1[ ((k[3] &amp; 0xe0) &gt;&gt; 4) + (k[7] &amp; 0xf0) + 1 ];
 
 	/* Check if second half is weak */
 	w |= (a ^ c) | (b ^ d) | (rs[a] ^ c) | (b ^ rs[d]);
 
-	pe[15 * 2 + 1] = PC2(a, b, c, d); d = rs[d];
-	pe[14 * 2 + 1] = PC2(d, a, b, c); c = rs[c]; b = rs[b];
-	pe[13 * 2 + 1] = PC2(b, c, d, a); a = rs[a]; d = rs[d];
-	pe[12 * 2 + 1] = PC2(d, a, b, c); c = rs[c]; b = rs[b];
-	pe[11 * 2 + 1] = PC2(b, c, d, a); a = rs[a]; d = rs[d];
-	pe[10 * 2 + 1] = PC2(d, a, b, c); c = rs[c]; b = rs[b];
-	pe[ 9 * 2 + 1] = PC2(b, c, d, a); a = rs[a]; d = rs[d];
-	pe[ 8 * 2 + 1] = PC2(d, a, b, c); c = rs[c];
-	pe[ 7 * 2 + 1] = PC2(c, d, a, b); b = rs[b]; a = rs[a];
-	pe[ 6 * 2 + 1] = PC2(a, b, c, d); d = rs[d]; c = rs[c];
-	pe[ 5 * 2 + 1] = PC2(c, d, a, b); b = rs[b]; a = rs[a];
-	pe[ 4 * 2 + 1] = PC2(a, b, c, d); d = rs[d]; c = rs[c];
-	pe[ 3 * 2 + 1] = PC2(c, d, a, b); b = rs[b]; a = rs[a];
-	pe[ 2 * 2 + 1] = PC2(a, b, c, d); d = rs[d]; c = rs[c];
-	pe[ 1 * 2 + 1] = PC2(c, d, a, b); b = rs[b];
-	pe[ 0 * 2 + 1] = PC2(b, c, d, a);
+	pe[15 * 2 + 1] = PC2(pt, a, b, c, d); d = rs[d];
+	pe[14 * 2 + 1] = PC2(pt, d, a, b, c); c = rs[c]; b = rs[b];
+	pe[13 * 2 + 1] = PC2(pt, b, c, d, a); a = rs[a]; d = rs[d];
+	pe[12 * 2 + 1] = PC2(pt, d, a, b, c); c = rs[c]; b = rs[b];
+	pe[11 * 2 + 1] = PC2(pt, b, c, d, a); a = rs[a]; d = rs[d];
+	pe[10 * 2 + 1] = PC2(pt, d, a, b, c); c = rs[c]; b = rs[b];
+	pe[ 9 * 2 + 1] = PC2(pt, b, c, d, a); a = rs[a]; d = rs[d];
+	pe[ 8 * 2 + 1] = PC2(pt, d, a, b, c); c = rs[c];
+	pe[ 7 * 2 + 1] = PC2(pt, c, d, a, b); b = rs[b]; a = rs[a];
+	pe[ 6 * 2 + 1] = PC2(pt, a, b, c, d); d = rs[d]; c = rs[c];
+	pe[ 5 * 2 + 1] = PC2(pt, c, d, a, b); b = rs[b]; a = rs[a];
+	pe[ 4 * 2 + 1] = PC2(pt, a, b, c, d); d = rs[d]; c = rs[c];
+	pe[ 3 * 2 + 1] = PC2(pt, c, d, a, b); b = rs[b]; a = rs[a];
+	pe[ 2 * 2 + 1] = PC2(pt, a, b, c, d); d = rs[d]; c = rs[c];
+	pe[ 1 * 2 + 1] = PC2(pt, c, d, a, b); b = rs[b];
+	pe[ 0 * 2 + 1] = PC2(pt, b, c, d, a);
 
 	/* Fixup: 2413 5768 -&gt; 1357 2468 */
 	for (d = 0; d &lt; 16; ++d) {
@@ -714,93 +697,39 @@ static unsigned long ekey(u32 *pe, const
  * Decryption key expansion
  *
  * No weak key checking is performed, as this is only used by triple DES
- *
+ * This could be made a smidgen faster at the expense of a lot of space.
  */
-static void dkey(u32 *pe, const u8 *k)
+static void dkey(u32 pe[DES_EXPKEY_WORDS], const u8 k[DES_KEY_SIZE])
 {
-	/* K&amp;R: long is at least 32 bits */
-	unsigned long a, b, c, d;
-	const u32 *pt = pc2;
-
-	d = k[4]; d &amp;= 0x0e; d &lt;&lt;= 4; d |= k[0] &amp; 0x1e; d = pc1[d];
-	c = k[5]; c &amp;= 0x0e; c &lt;&lt;= 4; c |= k[1] &amp; 0x1e; c = pc1[c];
-	b = k[6]; b &amp;= 0x0e; b &lt;&lt;= 4; b |= k[2] &amp; 0x1e; b = pc1[b];
-	a = k[7]; a &amp;= 0x0e; a &lt;&lt;= 4; a |= k[3] &amp; 0x1e; a = pc1[a];
-
-	pe[ 0 * 2] = PC2(a, b, c, d); d = rs[d];
-	pe[ 1 * 2] = PC2(d, a, b, c); c = rs[c]; b = rs[b];
-	pe[ 2 * 2] = PC2(b, c, d, a); a = rs[a]; d = rs[d];
-	pe[ 3 * 2] = PC2(d, a, b, c); c = rs[c]; b = rs[b];
-	pe[ 4 * 2] = PC2(b, c, d, a); a = rs[a]; d = rs[d];
-	pe[ 5 * 2] = PC2(d, a, b, c); c = rs[c]; b = rs[b];
-	pe[ 6 * 2] = PC2(b, c, d, a); a = rs[a]; d = rs[d];
-	pe[ 7 * 2] = PC2(d, a, b, c); c = rs[c];
-	pe[ 8 * 2] = PC2(c, d, a, b); b = rs[b]; a = rs[a];
-	pe[ 9 * 2] = PC2(a, b, c, d); d = rs[d]; c = rs[c];
-	pe[10 * 2] = PC2(c, d, a, b); b = rs[b]; a = rs[a];
-	pe[11 * 2] = PC2(a, b, c, d); d = rs[d]; c = rs[c];
-	pe[12 * 2] = PC2(c, d, a, b); b = rs[b]; a = rs[a];
-	pe[13 * 2] = PC2(a, b, c, d); d = rs[d]; c = rs[c];
-	pe[14 * 2] = PC2(c, d, a, b); b = rs[b];
-	pe[15 * 2] = PC2(b, c, d, a);
-
-	/* Skip to next table set */
-	pt += 512;
-
-	d = k[0]; d &amp;= 0xe0; d &gt;&gt;= 4; d |= k[4] &amp; 0xf0; d = pc1[d + 1];
-	c = k[1]; c &amp;= 0xe0; c &gt;&gt;= 4; c |= k[5] &amp; 0xf0; c = pc1[c + 1];
-	b = k[2]; b &amp;= 0xe0; b &gt;&gt;= 4; b |= k[6] &amp; 0xf0; b = pc1[b + 1];
-	a = k[3]; a &amp;= 0xe0; a &gt;&gt;= 4; a |= k[7] &amp; 0xf0; a = pc1[a + 1];
-
-	pe[ 0 * 2 + 1] = PC2(a, b, c, d); d = rs[d];
-	pe[ 1 * 2 + 1] = PC2(d, a, b, c); c = rs[c]; b = rs[b];
-	pe[ 2 * 2 + 1] = PC2(b, c, d, a); a = rs[a]; d = rs[d];
-	pe[ 3 * 2 + 1] = PC2(d, a, b, c); c = rs[c]; b = rs[b];
-	pe[ 4 * 2 + 1] = PC2(b, c, d, a); a = rs[a]; d = rs[d];
-	pe[ 5 * 2 + 1] = PC2(d, a, b, c); c = rs[c]; b = rs[b];
-	pe[ 6 * 2 + 1] = PC2(b, c, d, a); a = rs[a]; d = rs[d];
-	pe[ 7 * 2 + 1] = PC2(d, a, b, c); c = rs[c];
-	pe[ 8 * 2 + 1] = PC2(c, d, a, b); b = rs[b]; a = rs[a];
-	pe[ 9 * 2 + 1] = PC2(a, b, c, d); d = rs[d]; c = rs[c];
-	pe[10 * 2 + 1] = PC2(c, d, a, b); b = rs[b]; a = rs[a];
-	pe[11 * 2 + 1] = PC2(a, b, c, d); d = rs[d]; c = rs[c];
-	pe[12 * 2 + 1] = PC2(c, d, a, b); b = rs[b]; a = rs[a];
-	pe[13 * 2 + 1] = PC2(a, b, c, d); d = rs[d]; c = rs[c];
-	pe[14 * 2 + 1] = PC2(c, d, a, b); b = rs[b];
-	pe[15 * 2 + 1] = PC2(b, c, d, a);
-
-	/* Fixup: 2413 5768 -&gt; 1357 2468 */
-	for (d = 0; d &lt; 16; ++d) {
-		a = pe[2 * d];
-		b = pe[2 * d + 1];
-		c = a ^ b;
-		c &amp;= 0xffff0000;
-		a ^= c;
-		b ^= c;
-		ROL(b, 18);
-		pe[2 * d] = a;
-		pe[2 * d + 1] = b;
+	unsigned i;
+
+	ekey(pe, k);
+	/* Swap 0&lt;-&gt;30, 1&lt;-&gt;31, 2&lt;-&gt;28, 3&lt;-&gt;29, 4&lt;-&gt;26,... 14&lt;-&gt;16, 15&lt;-&gt;17 */
+	for (i = 0; i &lt; 16; i++) {
+		unsigned j = 0x1e ^ i;
+		u32 t = pe[i];
+		pe[i] = pe[j];
+		pe[j] = t;
 	}
 }
 
-static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
+static int des_setkey(struct crypto_tfm *tfm, const u8 key[DES_KEY_SIZE],
 		      unsigned int keylen)
 {
 	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
-	u32 *flags = &amp;tfm-&gt;crt_flags;
 	u32 tmp[DES_EXPKEY_WORDS];
 	int ret;
 
 	/* Expand to tmp */
 	ret = ekey(tmp, key);
 
-	if (unlikely(ret == 0) &amp;&amp; (*flags &amp; CRYPTO_TFM_REQ_WEAK_KEY)) {
-		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
+	if (unlikely(ret == 0) &amp;&amp; (tfm-&gt;crt_flags &amp; CRYPTO_TFM_REQ_WEAK_KEY)) {
+		tfm-&gt;crt_flags |= CRYPTO_TFM_RES_WEAK_KEY;
 		return -EINVAL;
 	}
 
 	/* Copy to output */
-	memcpy(dctx-&gt;expkey, tmp, sizeof(dctx-&gt;expkey));
+	memcpy(dctx-&gt;expkey, tmp, sizeof dctx-&gt;expkey);
 
 	return 0;
 }
@@ -870,12 +799,11 @@ static int des3_ede_setkey(struct crypto
 	const u32 *K = (const u32 *)key;
 	struct des3_ede_ctx *dctx = crypto_tfm_ctx(tfm);
 	u32 *expkey = dctx-&gt;expkey;
-	u32 *flags = &amp;tfm-&gt;crt_flags;
 
-	if (unlikely(!((K[0] ^ K[2]) | (K[1] ^ K[3])) ||
-		     !((K[2] ^ K[4]) | (K[3] ^ K[5]))))
+	if (unlikely(!(((K[0]^K[2]) | (K[1]^K[3])) &amp; 0xfefefefe) ||
+		     !(((K[2]^K[4]) | (K[3]^K[5])) &amp; 0xfefefefe)))
 	{
-		*flags |= CRYPTO_TFM_RES_BAD_KEY_SCHED;
+		tfm-&gt;crt_flags |= CRYPTO_TFM_RES_BAD_KEY_SCHED;
 		return -EINVAL;
 	}
 
@@ -984,7 +912,7 @@ MODULE_ALIAS("des3_ede");
 
 static int __init init(void)
 {
-	int ret = 0;
+	int ret;
 
 	ret = crypto_register_alg(&amp;des_alg);
 	if (ret &lt; 0)

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061116101340</emailId><senderName></senderName><senderEmail>linux</senderEmail><timestampReceived>2006-11-16 10:13:40-0400</timestampReceived><subject>Re: crypto/des.c cleanups for review</subject><body>

Minor update to the preceding;

Somehow, I managed to misplace a semicolon after "B &gt;&gt;= 8" in the ROUND
macro, which prevents the patch I posted from compiling.  With that
obvious fix, I just verified that it passes the NBS Special Publication
500-20 test vectors.  (Single-DES and triple-DES with 3 identical keys.)

Sorry about that.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061201152046</emailId><senderName>Jan Glauber</senderName><senderEmail>jan.glauber@de.ibm.com</senderEmail><timestampReceived>2006-12-01 15:20:46-0400</timestampReceived><subject>Re: [RFC][PATCH] Pseudo-random number generator</subject><body>

On Fri, 2006-12-01 at 13:39 +0000, Alan wrote:
&gt; &gt; * merging the s390 PRNG with the random pool implementation
&gt; &gt; PRO: no new interface, random numbers can be read through /dev/urandom
&gt; &gt; CON: complex implementation, could only use traditional /dev/urandom algorithm
&gt; &gt; or hardware-accelerated implementation
&gt; 
&gt; Also PRO: Can be verified by non-IBM people, high resistance if there is
&gt; a flaw (accidental or US government 8)) in the 390 hardware.

No, the interesting stuff is done internally in the hardware, we cannot
see it with both implementations.

&gt; &gt; I've chosen the char driver since it allows the user to decide which \
&gt; &gt; pseudo-random numbers he wants to use. That means there is a new interface for \
&gt; &gt; the s390 PRNG, called /dev/prandom.
&gt; 
&gt; And people can pipe this into the urandom layer if they wish.

Yes, a user can just symlink urandom to prandom and will have a faster
generator.

&gt; &gt; +/* copied from libica, use a non-zero initial parameter block */
&gt; &gt; +unsigned char parm_block[32] = {
&gt; &gt; +0x0F,0x2B,0x8E,0x63,0x8C,0x8E,0xD2,0x52,0x64,0xB7,0xA0,0x7B,0x75,0x28,0xB8,0xF4,
&gt; &gt; +0x75,0x5F,0xD2,0xA6,0x8D,0x97,0x11,0xFF,0x49,0xD8,0x23,0xF3,0x7E,0x21,0xEC,0xA0,
&gt; &gt; +};
&gt; &gt; +
&gt; 
&gt; Global variables called "p" and "parm_block". Plus parm_block appears to
&gt; be const

Argh. I'll make them static.

&gt; Also your register the misc device before allocating the buffer so it can
&gt; be opened in theory before the alloc is done and crash.

Fixed. The misc_register is now done at the very end.

thanks,
Jan

---
 arch/s390/crypto/Makefile           |    1 
 arch/s390/crypto/crypt_s390.h       |    3 
 arch/s390/crypto/crypt_s390_query.c |    2 
 arch/s390/crypto/prng.c             |  203 ++++++++++++++++++++++++++++++++++++
 arch/s390/defconfig                 |    1 
 drivers/s390/Kconfig                |    7 +
 include/asm-s390/timex.h            |   12 ++
 7 files changed, 228 insertions(+), 1 deletion(-)

diff -urNp linux-2.5/arch/s390/crypto/Makefile \
                linux-2.5_prng/arch/s390/crypto/Makefile
--- linux-2.5/arch/s390/crypto/Makefile	2006-12-01 15:40:54.000000000 +0100
+++ linux-2.5_prng/arch/s390/crypto/Makefile	2006-11-30 18:30:23.000000000 +0100
@@ -6,5 +6,6 @@ obj-$(CONFIG_CRYPTO_SHA1_S390) += sha1_s
 obj-$(CONFIG_CRYPTO_SHA256_S390) += sha256_s390.o
 obj-$(CONFIG_CRYPTO_DES_S390) += des_s390.o des_check_key.o
 obj-$(CONFIG_CRYPTO_AES_S390) += aes_s390.o
+obj-$(CONFIG_S390_PRNG) += prng.o
 
 obj-$(CONFIG_CRYPTO_TEST) += crypt_s390_query.o
diff -urNp linux-2.5/arch/s390/crypto/crypt_s390.h \
                linux-2.5_prng/arch/s390/crypto/crypt_s390.h
--- linux-2.5/arch/s390/crypto/crypt_s390.h	2006-12-01 15:40:54.000000000 +0100
+++ linux-2.5_prng/arch/s390/crypto/crypt_s390.h	2006-12-01 15:38:00.000000000 +0100
@@ -68,6 +68,7 @@ enum crypt_s390_kmc_func {
 	KMC_AES_192_DECRYPT  = CRYPT_S390_KMC | 0x13 | 0x80,
 	KMC_AES_256_ENCRYPT  = CRYPT_S390_KMC | 0x14,
 	KMC_AES_256_DECRYPT  = CRYPT_S390_KMC | 0x14 | 0x80,
+	KMC_PRNG	     = CRYPT_S390_KMC | 0x43,
 };
 
 /* function codes for KIMD (COMPUTE INTERMEDIATE MESSAGE DIGEST)
@@ -147,7 +148,7 @@ crypt_s390_km(long func, void* param, u8
  * @param src: address of source memory area
  * @param src_len: length of src operand in bytes
  * @returns &lt; zero for failure, 0 for the query func, number of processed bytes
- * 	for encryption/decryption funcs
+ *	for encryption/decryption funcs
  */
 static inline int
 crypt_s390_kmc(long func, void* param, u8* dest, const u8* src, long src_len)
diff -urNp linux-2.5/arch/s390/crypto/crypt_s390_query.c \
                linux-2.5_prng/arch/s390/crypto/crypt_s390_query.c
--- linux-2.5/arch/s390/crypto/crypt_s390_query.c	2006-12-01 15:40:54.000000000 +0100
+++ linux-2.5_prng/arch/s390/crypto/crypt_s390_query.c	2006-12-01 15:37:27.000000000 \
+0100 @@ -54,6 +54,8 @@ static void query_available_functions(vo
 		crypt_s390_func_available(KMC_AES_192_ENCRYPT));
 	printk(KERN_INFO "KMC_AES_256: %d\n",
 		crypt_s390_func_available(KMC_AES_256_ENCRYPT));
+	printk(KERN_INFO "KMC_PRNG: %d\n",
+		crypt_s390_func_available(KMC_PRNG));
 
 	/* query available KIMD functions */
 	printk(KERN_INFO "KIMD_QUERY: %d\n",
diff -urNp linux-2.5/arch/s390/crypto/prng.c linux-2.5_prng/arch/s390/crypto/prng.c
--- linux-2.5/arch/s390/crypto/prng.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.5_prng/arch/s390/crypto/prng.c	2006-12-01 16:14:22.000000000 +0100
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2006 IBM Corporation
+ * Author(s): Jan Glauber &lt;jan.glauber@de.ibm.com&gt;
+ * Driver for the s390 pseudo random number generator
+ */
+#include &lt;linux/fs.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/miscdevice.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/moduleparam.h&gt;
+#include &lt;linux/random.h&gt;
+#include &lt;asm/debug.h&gt;
+#include &lt;asm/uaccess.h&gt;
+
+#include "crypt_s390.h"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jan Glauber &lt;jan.glauber@de.ibm.com&gt;");
+MODULE_DESCRIPTION("s390 PRNG interface");
+
+static int prng_chunk_size = 32;
+module_param(prng_chunk_size, int, 0);
+MODULE_PARM_DESC(prng_chunk_size, "PRNG read chunk size in bytes");
+
+static int prng_entropy_limit = 4096;
+module_param(prng_entropy_limit, int, 0);
+MODULE_PARM_DESC(prng_entropy_limit, "PRNG add entropy after that much bytes were \
produced"); +
+/*
+ * Any one who considers arithmetical methods of producing random digits is,
+ * of course, in a state of sin. -- John von Neumann
+ */
+
+struct s390_prng_data {
+	unsigned long count; /* how many bytes were produced */
+	char *buf;
+};
+
+static struct s390_prng_data *p;
+
+/* copied from libica, use a non-zero initial parameter block */
+static unsigned char parm_block[32] = {
+0x0F,0x2B,0x8E,0x63,0x8C,0x8E,0xD2,0x52,0x64,0xB7,0xA0,0x7B,0x75,0x28,0xB8,0xF4,
+0x75,0x5F,0xD2,0xA6,0x8D,0x97,0x11,0xFF,0x49,0xD8,0x23,0xF3,0x7E,0x21,0xEC,0xA0,
+};
+
+static int prng_open(struct inode *inode, struct file *file)
+{
+	return nonseekable_open(inode, file);
+}
+
+static void prng_add_entropy(void)
+{
+	__u64 entropy[4];
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i &lt; 16; i++) {
+		entropy[0] = get_clock();
+		entropy[1] = get_clock();
+		entropy[2] = get_clock();
+		entropy[3] = get_clock();
+		ret = crypt_s390_kmc(KMC_PRNG, parm_block, (char *)entropy,
+				     (char *)entropy, sizeof(entropy));
+		BUG_ON(ret &lt; 0 || ret != sizeof(entropy));
+		memcpy(parm_block, entropy, sizeof(entropy));
+	}
+}
+
+static ssize_t prng_read(struct file *file, char __user *ubuf, size_t nbytes,
+			 loff_t *ppos)
+{
+	unsigned long long clock[2];
+	int chunk, n, x;
+	int ret = 0;
+	int tmp;
+
+	/* nbytes can be arbitrary long, we spilt it into chunks */
+	while (nbytes) {
+		/* same as in extract_entropy_user in random.c */
+		if (need_resched()) {
+			if (signal_pending(current)) {
+				if (ret == 0)
+					ret = -ERESTARTSYS;
+				break;
+			}
+			schedule();
+		}
+
+		/*
+		 * we lose some random bytes if an attacker issues
+		 * reads &lt; 8 bytes, but we don't care
+		 */
+		chunk = min_t(int, nbytes, prng_chunk_size);
+
+		/* PRNG only likes multiples of 8 bytes */
+		n = (chunk + 7) &amp; -8;
+
+		if (p-&gt;count &gt; prng_entropy_limit)
+			prng_add_entropy();
+
+		/*
+		 * It shouldn't weaken the quality of the random numbers
+		 * passing the full 16 bytes from STCKE to the generator.
+		 */
+		for (x=0; x &lt; n/16; x+=2) {
+			get_clock_extended(&amp;clock);
+			*(__u64 *)(p-&gt;buf + x*8) = clock[0];
+			*(__u64 *)(p-&gt;buf + x*8 + 88) = clock[1];
+		}
+		if (n % 16) {
+			get_clock_extended(&amp;clock);
+			*(__u64 *)(p-&gt;buf + x*8) = clock[0];
+		}
+
+		tmp = crypt_s390_kmc(KMC_PRNG, parm_block, p-&gt;buf, p-&gt;buf, n);
+		BUG_ON((tmp &lt; 0) || (tmp != n));
+
+		p-&gt;count += n;
+
+		if (copy_to_user(ubuf, p-&gt;buf, chunk))
+			return -EFAULT;
+
+		nbytes -= chunk;
+		ret += chunk;
+		ubuf += chunk;
+	}
+	return ret;
+}
+
+static struct file_operations prng_fops = {
+	.owner		= THIS_MODULE,
+	.open		= &amp;prng_open,
+	.release	= NULL,
+	.read		= &amp;prng_read,
+};
+
+static struct miscdevice prng_dev = {
+	.name	= "prandom",
+	.minor	= MISC_DYNAMIC_MINOR,
+	.fops	= &amp;prng_fops,
+};
+
+static int __init prng_init(void)
+{
+	int nbytes = 16;
+	char buf[nbytes];
+	int i = 0;
+	int ret;
+
+	/* check if the CPU has a PRNG */
+	if (!crypt_s390_func_available(KMC_PRNG))
+		return -ENOTSUPP;
+
+	p = kmalloc(sizeof(struct s390_prng_data), GFP_KERNEL);
+	if (!p)
+		return -ENOMEM;
+	p-&gt;count = 0;
+
+	p-&gt;buf = kmalloc(prng_chunk_size, GFP_KERNEL);
+	if (!p-&gt;buf) {
+		ret = -ENOMEM;
+		goto out_free;
+	}
+
+	/* initialize the PRNG, add 128 bits of entropy */
+	get_random_bytes(buf, 16);
+	while (nbytes &gt;= 8) {
+		*((__u64 *)parm_block) ^= *((__u64 *)buf+i*8);
+		prng_add_entropy();
+		i += 8;
+		nbytes -= 8;
+	}
+	prng_add_entropy();
+
+	ret = misc_register(&amp;prng_dev);
+	if (ret) {
+		printk(KERN_WARNING
+		       "s390 PRNG driver not loaded. Could not register misc device.\n");
+		goto out_buf;
+	}
+	return 0;
+
+out_buf:
+	kfree(p-&gt;buf);
+out_free:
+	kfree(p);
+	return ret;
+}
+
+static void __exit prng_exit(void)
+{
+	/* wipe me */
+	memset(p-&gt;buf, 0, prng_chunk_size);
+	kfree(p-&gt;buf);
+	kfree(p);
+
+	misc_deregister(&amp;prng_dev);
+}
+
+module_init(prng_init);
+module_exit(prng_exit);
diff -urNp linux-2.5/arch/s390/defconfig linux-2.5_prng/arch/s390/defconfig
--- linux-2.5/arch/s390/defconfig	2006-12-01 15:40:55.000000000 +0100
+++ linux-2.5_prng/arch/s390/defconfig	2006-11-30 18:30:23.000000000 +0100
@@ -437,6 +437,7 @@ CONFIG_MONWRITER=m
 #
 CONFIG_ZCRYPT=m
 # CONFIG_ZCRYPT_MONOLITHIC is not set
+CONFIG_S390_PRNG=m
 
 #
 # Network device support
diff -urNp linux-2.5/drivers/s390/Kconfig linux-2.5_prng/drivers/s390/Kconfig
--- linux-2.5/drivers/s390/Kconfig	2006-12-01 15:40:55.000000000 +0100
+++ linux-2.5_prng/drivers/s390/Kconfig	2006-11-30 18:30:23.000000000 +0100
@@ -244,4 +244,11 @@ config ZCRYPT_MONOLITHIC
 	  that contains all parts of the crypto device driver (ap bus,
 	  request router and all the card drivers).
 
+config S390_PRNG
+	tristate "Support for pseudo random number generator device driver"
+	help
+	  Select this option if you want to use the s390 pseudo random number generator.
+	  The PRNG is part of the cryptograhic processor functions and produces
+	  ANSI X9.17 conform numbers. The PRNG is usable via the char device /dev/prandom.
+
 endmenu
diff -urNp linux-2.5/include/asm-s390/timex.h linux-2.5_prng/include/asm-s390/timex.h
--- linux-2.5/include/asm-s390/timex.h	2006-12-01 15:40:55.000000000 +0100
+++ linux-2.5_prng/include/asm-s390/timex.h	2006-11-30 18:30:23.000000000 +0100
@@ -62,6 +62,18 @@ static inline unsigned long long get_clo
 	return clk;
 }
 
+static inline void get_clock_extended(void *dest)
+{
+	typedef struct { unsigned long long clk[2]; } clock_t;
+
+#if __GNUC__ &gt; 3 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt; 2)
+	asm volatile("stcke %0" : "=Q" (*((clock_t *)dest)) : : "cc");
+#else /* __GNUC__ */
+	asm volatile("stcke 0(%1)" : "=m" (*((clock_t *)dest))
+				   : "a" ((clock_t *)dest) : "cc");
+#endif /* __GNUC__ */
+}
+
 static inline cycles_t get_cycles(void)
 {
 	return (cycles_t) get_clock() &gt;&gt; 2;


-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


</body></email><email><emailId>20061201153706</emailId><senderName>Alan</senderName><senderEmail>alan@lxorguk.ukuu.org.uk</senderEmail><timestampReceived>2006-12-01 15:37:06-0400</timestampReceived><subject>Re: [RFC][PATCH] Pseudo-random number generator</subject><body>

On Fri, 01 Dec 2006 16:20:46 +0100
Jan Glauber &lt;jan.glauber@de.ibm.com&gt; wrote:
&gt; Yes, a user can just symlink urandom to prandom and will have a faster
&gt; generator.


More usefully they can use it as an entropy source with an entropy
daemon to feed it into the standard urandom/random.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061201173301</emailId><senderName>Bodo Eggert</senderName><senderEmail>7eggert@gmx.de</senderEmail><timestampReceived>2006-12-01 17:33:01-0400</timestampReceived><subject>Re: [RFC][PATCH] Pseudo-random number generator</subject><body>

Alan &lt;alan@lxorguk.ukuu.org.uk&gt; wrote:
&gt; On Fri, 01 Dec 2006 16:20:46 +0100
&gt; Jan Glauber &lt;jan.glauber@de.ibm.com&gt; wrote:

&gt;&gt; Yes, a user can just symlink urandom to prandom and will have a faster
&gt;&gt; generator.
&gt; 
&gt; 
&gt; More usefully they can use it as an entropy source with an entropy
&gt; daemon to feed it into the standard urandom/random.

Only if other users will randomly drain /dev/prandom, otherwise you might
as well use /dev/zero.
-- 
Ich danke GMX dafür, die Verwendung meiner Adressen mittels per SPF
verbreiteten Lügen zu sabotieren.

http://david.woodhou.se/why-not-spf.html
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061204161507</emailId><senderName></senderName><senderEmail>valdis.kletnieks</senderEmail><timestampReceived>2006-12-04 16:15:07-0400</timestampReceived><subject>Re: [RFC][PATCH] Pseudo-random number generator</subject><body>

On Fri, 01 Dec 2006 14:19:15 +0100, Jan Glauber said:
&gt; New s390 machines have hardware support for the generation of pseudo-random
&gt; numbers. This patch implements a simple char driver that exports this numbers
&gt; to user-space. Other possible implementations would have been:

&gt; +	for (i = 0; i &lt; 16; i++) {
&gt; +		entropy[0] = get_clock();
&gt; +		entropy[1] = get_clock();
&gt; +		entropy[2] = get_clock();
&gt; +		entropy[3] = get_clock();

By the time this loop completes, we'll have done 64 get_clock() - and if an
attacker has a good estimate of what the system clock has in it, they'll be
able to guess all 64 values, since each pass through the loop will have fairly
predictable timing.  So as a result, the pseudo-random stream will be a *lot*
less random than one would hope for...

&gt; +		/*
&gt; +		 * It shouldn't weaken the quality of the random numbers
&gt; +		 * passing the full 16 bytes from STCKE to the generator.
&gt; +		 */

As long as you realize that probably 12 or 13 or even more of those 16 bytes
are likely predictable (depending exactly how fast the hardware clock ticks),
and as a result the output stream will also be predictable.

I think this needs to either find a way to stir in entropy from sources other
than the clock, or make it clear that the returned data is pseudo-random but
likely predictable by a determined attacker.  As such, it's probably a bad
choice for many things that /dev/urandom is usable for, such as session keys
and the like.


[Attachment #3 (application/pgp-signature)]
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20061205130727</emailId><senderName>Jan Glauber</senderName><senderEmail>jan.glauber@de.ibm.com</senderEmail><timestampReceived>2006-12-05 13:07:27-0400</timestampReceived><subject>Re: [RFC][PATCH] Pseudo-random number generator</subject><body>

On Mon, 2006-12-04 at 11:15 -0500, Valdis.Kletnieks@vt.edu wrote:
&gt; On Fri, 01 Dec 2006 14:19:15 +0100, Jan Glauber said:
&gt; &gt; New s390 machines have hardware support for the generation of pseudo-random
&gt; &gt; numbers. This patch implements a simple char driver that exports this numbers
&gt; &gt; to user-space. Other possible implementations would have been:
&gt; 
&gt; &gt; +	for (i = 0; i &lt; 16; i++) {
&gt; &gt; +		entropy[0] = get_clock();
&gt; &gt; +		entropy[1] = get_clock();
&gt; &gt; +		entropy[2] = get_clock();
&gt; &gt; +		entropy[3] = get_clock();
&gt; 
&gt; By the time this loop completes, we'll have done 64 get_clock() - and if an
&gt; attacker has a good estimate of what the system clock has in it, they'll be
&gt; able to guess all 64 values, since each pass through the loop will have fairly
&gt; predictable timing.  So as a result, the pseudo-random stream will be a *lot*
&gt; less random than one would hope for...

I completely agree. Filling the input buffer with timestamps looks quite
uncomfortable but was exactly what the hardware specification suggested.

At least for the initialisation of the PRNG I preferred get_random_bytes()
over get_clock to get a good initial seed. But get_random_bytes cannot
be used during normal operation since the PRNG read should not block.

&gt; &gt; +		/*
&gt; &gt; +		 * It shouldn't weaken the quality of the random numbers
&gt; &gt; +		 * passing the full 16 bytes from STCKE to the generator.
&gt; &gt; +		 */
&gt; 
&gt; As long as you realize that probably 12 or 13 or even more of those 16 bytes
&gt; are likely predictable (depending exactly how fast the hardware clock ticks),
&gt; and as a result the output stream will also be predictable.

Yes, if an attacker knows the initial clock value a brute-force attack
would be feasible to predict the output. But I don't know if the
hardware completely relies on the clock values or if there is any
internal state which is not visible by an attacker. I will try to find
out more details...

Jan


-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061207150633</emailId><senderName>Arnd Bergmann</senderName><senderEmail>arnd@arndb.de</senderEmail><timestampReceived>2006-12-07 15:06:33-0400</timestampReceived><subject>Re: [RFC][PATCH] Pseudo-random number generator</subject><body>

On Friday 01 December 2006 14:19, Jan Glauber wrote:
&gt; I've chosen the char driver since it allows the user to decide which pseudo-random
&gt; numbers he wants to use. That means there is a new interface for the s390
&gt; PRNG, called /dev/prandom.
&gt; 
&gt; I would like to know if there are any objections, especially with the chosen device
&gt; name.

This may be a stupid question, but what is it _good_ for? My understanding is
that the crypt_s390_kmc() opcodes work in user mode as well as kernel mode, so
you should not need a character device at all, but maybe just a small tool
that spits prandom data to stdout.

	Arnd &lt;&gt;&lt;
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061117104825</emailId><senderName>PagCal</senderName><senderEmail>pagcal@runbox.com</senderEmail><timestampReceived>2006-11-17 10:48:25-0400</timestampReceived><subject>LOOP_MULTI_KEY_SETUP_V3 Errors Fixed</subject><body>

from http://loop-aes.ajept.com/Readme.txt

Hello,
	This mini-project adds LOOP_MULTI_KEY_SETUP_V3 functionality
to SUSE 10.1.

	It's basically a glom between loop_fish2.c and loop-AES.

	The reason it was done is that loop-AES requires you to replace loop.c, and this was \
unacceptable.

	If you successfully patch this in, you will end up with a loadable module - \
loop_aes.ko, that will add the missing (and desired) functionality.

How to obtain the kit
---------------------

	This source kit is available from:

	http://loop-AES.ajept.com/loop-AES.tar.gz

What else you will need:
------------------------

        Get a copy of loop-AES-v3.1e.tar.bz2 from Sourceforge, at \
http://www.sourceforge.net/project=loop-AES

	Get a copy of util-linux-2.12r.tar.bz2, at \
http://www.kernel.org/pub/linux/utils/util-linux/

Steps to install
----------------

	Any file with a '.patched' at the end should replace a kernel source file of that \
name. You can either just copy over, or for the tin hat crowd, merge in from these \
files.

1. Install SUSE 10.1 on your box, and be sure to include the linux kernel source kit. \
You should end up with the following directories in /usr/src:

   linux
   linux-2.6.16.21-0.25
   linux-2.6.16.21-0.25-obj
   linux-obj
   packages

2. To be sure all is ok at this point, build the kernel as follows:

   cd /usr/src/linux
   make oldconfig
   make

   Don't leave out the 'make oldconfig' step, or misery will follow you for the rest \
of your life if you do.

   When all is said and done, it should complete without errors.

3. For convenience, create the 'loop-AES' directory in \
/usr/src/linux/drivers/block/loop-AES, and copy this kit in there.

   - or do -

   cd /usr/src/linux/drivers/block
   tar -xvf loop-AES.tar.gz

4. Then, replace the following kernel files:

   Kconfig.patched =&gt; /usr/src/linux/drivers/block/Kconfig
   loop.h =&gt; /usr/src/linux/include/linux/loop.h, /usr/include/linux/loop.h
   Makefile.patched =&gt; /usr/src/linux/drivers/block/Makefile

5. Copy the following files into /usr/src/linux/drivers/block

   aes.c
   aes.h
   loop_aes.c
   md5.c
   md5.h

6. Once patched, you've got to tell the linux configuration system to build your new \
loadable driver, loopaes.ko. So so by:

   cd /usr/src/linux
   make menuconfig

   and, under block devices, select loop_aes as a type 'M', a loadable device.

   Exit menuconfig and be sure to save your configuration.

7. Rebuild the kernel

   cd /usr/src/linux
   make

   I don't recommend a 'make install' as you don't have to. Just remember the \
location of loopaes.ko.

   Contratulations! You've done it. You end up with loopaes.ko, a loadable driver \
that supports LOOP_MULTI_KEY_SETUP_V3.

8. utils need upgrade

   Before you can get it to work, you've got to build a copy of losetup that knows \
about loop-AES. Do so by  applying patch loop-AES-v3.1e/util-linux-2.12r.diff to \
util-linux-2.12r/

   - or do -

   cd util-linux-2.12r
   patch -p1 &lt; loop-AES-v3.1e/util-linux-2.12r.diff
   make

   I don't recommend installing this package, as I have no idea what the patch does. \
None the less, you  do end up with one executable, util-linux-2.12r/mount/losetup. \
I'd rather just rename this to  losetupaes and remember its location.

Using your new driver
---------------------

   Just load loopaes.ko before use. You can do so as follows:

   cd /usr/src/linux/drivers/block
   insmod ./loopaes.ko

   Voilla! LOOP_MULTI_KEY_SETUP_V3 should now work with losetupaes.

   For further information in doing so, please refer to the excellent doc at \
loop-AES-v3.1e/README

Discussion
----------

   I don't claim to have QA'd this package. I did load the module and used \
LOOP_MULTI_KEY_SETUP_V3 to  initialize, mount, and dismount a loop disk - which is, \
in reality, only one five minute test.

   Things I haven't done:

     A. Try to mount a previously encrypted disk from some other software base.
     B. Run it for more than 5 minutes.
     C. Verify that loop-AES-v3.1e/loop.h changes any of the structures.
     D. Do any sort of code review of any of the code.
     E. Verify that the encryption scheme actually provide any sort of security

   Furthermore, the api changed for transfer_aes, to:

      int transfer_aes(struct loop_device *lo, int cmd,
        struct page *raw_page, unsigned raw_off,
        struct page *loop_page, unsigned loop_off,
        int size, sector_t devSect)
      {
      char *raw_buf = kmap_atomic(raw_page, KM_USER0) + raw_off;
      char *loop_buf = kmap_atomic(loop_page, KM_USER1) + loop_off;
      ...
      }

   What's kmap_atomic? Why did the api change? Who changed it? Where is the \
architect? How  can I contact the architect? Is this correct? Why is the sky blue? \
What is the  meaning of life?

   So, I make no claims about usability what-so-ever.

Contacting the author
---------------------
Feel free to email me for any reason at:

  mailto:// pagcal @ runbox.com

and be sure to include 'loop-AES' in the subject or my email system will junk the \
message.



-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20061117145018</emailId><senderName>Lars Reimann</senderName><senderEmail>mail@lars-reimann.de</senderEmail><timestampReceived>2006-11-17 14:50:18-0400</timestampReceived><subject>Huge Problem with cryptoloop and AES: Lost Password</subject><body>

Hi all,

ive a huge problem: i have mission critical data on a 400 GB raid 1. (2x400). I \
encrypted a single partition spanning all disk space with the following setup:

losetup -e AES256 -C 500 /dev/loop0 /dev/md2

the filesystem of md2 was ext3 or ext2. ext2 most likely.

I stored my 20 character passwords on my palm device only (i know by now that this \
was stupid!). However, that one chrashed and apparently all data was lost, including \
passwords.  However, i may remember certain details of the password, for example \
which characters I used not, and how the password ends.

my first question if there is ANY way to recover the data. I heard about cryptoloop \
being weak, and if i could remember some more details about the password, it could be \
narrowed down to some characters. For example it begins with letter then a number...

Also, i would like to automate to try different passwords. Is there a program \
available which does such (brute force) things with the cryptoloop? however I may \
have to write it on my own if nothing is available. I heard it may be possible to \
extract some sectors of ext2/3 partitions which are always "zero". Then the \
decryption can be verified by using such sectors. Has anyone an idea which SECTORS \
this are on ext2/3 partitions and how to extract them?

My goal is to test the decryption on a faster system, maybe on a cluster system. But \
ANY IDEAS ARE WELCOME. I know the result set is big, but the data is really \
important...and i am prepared trying to recover it for a long time.


greeting,
L.R.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20061120123611</emailId><senderName>uni</senderName><senderEmail>uni56788@yahoo.com</senderEmail><timestampReceived>2006-11-20 12:36:11-0400</timestampReceived><subject>Challenge</subject><body>


Can anyone decrypt this code:
3188C1i6BuK5WQ.xjOstFuoti5 \
���irsc5q3tX7pH3tiXFu5e0E5��je3t;����Z@9��r��tFk��Z5e;x��hD):J��ttc3thg.95l6!kxtUo��Yu.xFW��1��t���� \
�,$n��DF7#xejXz �9��tXu��bm��;xiuKt��totMYs1;xk��EQ��a��!����3t��t_dCK4AhPhPHu"Z����Eu \
65��68g/egU3MAZKNFU5p7��S1O08(gK6b5��MKKT6V5��fKfKKu7��f��E��AR0NI274e��K��f��fiN��KNE \
��MUA+6��EKIKfogye��7dSUAMKCMKKRKMgUKMf��KNFKeCfKSi8��ipKNM1fKKINKkp5SNKKjK��SUAXK��0N \
gK8NKReDHKfKeTgKhV7MK��qKN��6CQKKhKhCKhCfKNKipKpgKm0K��g��0GALMKKS6CqyekK��gKeSK��7��f \
��fK7��g18��0SArIKfK5��R��KwHUgK5wNKNKKaKRR1K��i0gK6��5SQ��0SKsKDN1s0KRgK6c5(8DfKKTeNR \
y7I0TKNfKGoi0SUKT6cM1KwKkKNEKAC8LKNDKLU3��8NEUK��0M7��LKKpKxqKARKT6NG28ClL0Ng��i0KZ5NE \
KKpA��N��0Q8QMKK/gyKZfyfKK+7NgULKf��KNfKC��f��gy0Qf��gK6NiCRK0TKR0NqKKCf��Mi8��fK6Nqol \
0AMKNgKfyizeNgKDKKTKNRiKMgiKZq��h0e��KNgyevfy0NgKM��KMKNQ��8NKNeZH2K��6mNK6MKMKNgUGoKN \
5hqKKCKMA��gKAX7CMo8l3Cg1B07xQKKR6NK��f��8CQKgKKQK=g10��K��K��f2qUgKSoKRgiMK3bK��qK6lO \
0qKi0KQC��K��g��5��fKKQ6RMK3Gm+g��AsKxSU6M3mQK5TKMqKKN7ugiKDKMg��7��qKK5p��Me"Z.x3tMU��Zi5Lu.&lt;��Z5��iXDu"Ziu��MXu����@xGZ.&lt;5q3qsJ5cKtXupY \
�,:d����iP#x��Z_xZl2qsx/c6tbQ/��_��B��Fu��MWu����FuFM7y����X&lt;XT��Z.xP-��M��tZec5DQje��Zjeg!y�� \
                �,.x"Z.xAMsgFk6tZe.xszotpeu����Z_T��5i5FG5��35p��5Y��Z&gt;��
-- 
View this message in context: http://www.nabble.com/Challenge-tf2668747.html#a7441689
Sent from the Linux Crypto mailing list archive at Nabble.com.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20061117203405</emailId><senderName>Dale Amon</senderName><senderEmail>amon@vnl.com</senderEmail><timestampReceived>2006-11-17 20:34:05-0400</timestampReceived><subject>Re: Huge Problem with cryptoloop and AES: Lost Password</subject><body>

It may be cheaper to send the disk from your palm
out to a facility that does data recovery. 

-- 
------------------------------------------------------
          Wyoming Space and Information Systems
   Dale Amon       amon@vnl.com      +44-7802-188325
            We serve the New Space industry
------------------------------------------------------

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061117210607</emailId><senderName>markus reichelt</senderName><senderEmail>ml@mareichelt.de</senderEmail><timestampReceived>2006-11-17 21:06:07-0400</timestampReceived><subject>Re: Huge Problem with cryptoloop and AES: Lost Password</subject><body>

* Lars Reimann &lt;mail@lars-reimann.de&gt; wrote:

&gt; my first question if there is ANY way to recover the data. I heard
&gt; about cryptoloop being weak, and if i could remember some more
&gt; details about the password, it could be narrowed down to some
&gt; characters. For example it begins with letter then a number...

Without the password, chances are slim of recovering your data.

did you use a sole password or a pw protected gpg keyfile?


&gt; Also, i would like to automate to try different passwords. Is there
&gt; a program available which does such (brute force) things with the
&gt; cryptoloop?  however I may have to write it on my own if nothing is
&gt; available. I heard it may be possible to extract some sectors of
&gt; ext2/3 partitions which are always "zero". Then the decryption can
&gt; be verified by using such sectors.  Has anyone an idea which
&gt; SECTORS this are on ext2/3 partitions and how to extract them?

known plaintext attack. possible, but you'd be better off cracking
the password bruteforce, given that you partially remember it.

modern fs are structured in a certain way so one knows which sectors
to seek out. if one knows the start of the fs / partition...

basically, it's about what Jari wrote here
http://marc.theaimsgroup.com/?l=linux-kernel&amp;m=107419912024246&amp;w=2


&gt; My goal is to test the decryption on a faster system, maybe on a
&gt; cluster system. But ANY IDEAS ARE WELCOME. I know the result set is
&gt; big, but the data is really important...and i am prepared trying to
&gt; recover it for a long time.

well, if you used a gpg encrypted keyfile (doesn't matter which
v-format version it was, really) ... have a look at nasty. it's a
bruteforce tool, http://www.vanheusden.com/nasty/



-- 
left blank, right bald

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20061118103350</emailId><senderName>Christian Kujau</senderName><senderEmail>lists@nerdbynature.de</senderEmail><timestampReceived>2006-11-18 10:33:50-0400</timestampReceived><subject>Re: Huge Problem with cryptoloop and AES: Lost Password</subject><body>

On Fri, 17 Nov 2006, Lars Reimann wrote:
&gt; ive a huge problem: i have mission critical data on a 400 GB raid 1. (2x400).

something you don't wanna hear right now, but still: "mission critical 
data" always has a backup (and no, RAID is not a backup).

&gt; lost, including passwords. However, i may remember certain details of the 
&gt; password, for example which characters I used not, and how the password ends.

How many characters do you know *for sure*? Even if there're still 10 
unknown characters left and you're sure that you only uses alphanumeric 
characters, perhaps a few special characters, the already suggested 
brute-force attack might be worth (and interesting!) to try.

&gt; may have to write it on my own if nothing is available. I heard it may be 
&gt; possible to extract some sectors of ext2/3 partitions which are always

filesystems often (always?) have "magic numbers" on the beginning:

$ file -s /dev/sda2
/dev/sda2: Linux rev 1.0 ext2 filesystem data

If you're sure it's an ext2 filesystem, then just look/compare other 
ext2 filesystems. This magic number is documented in 
include/linux/magic.h (here: 0xef53)

# head -1 /dev/sda2 | od -x | grep ef53
0002060 443e 455e 0003 0021 ef53 0001 0002 0000

good luck,
Christian.
-- 
BOFH excuse #59:

failed trials, system needs redesigned

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061118125201</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-11-18 12:52:01-0400</timestampReceived><subject>Re: Huge Problem with cryptoloop and AES: Lost Password</subject><body>

Lars Reimann wrote:
&gt; I stored my 20 character passwords on my palm device only (i know by now
&gt; that this was stupid!). However, that one chrashed and apparently all data
&gt; was lost, including passwords. However, i may remember certain details of
&gt; the password, for example which characters I used not, and how the
&gt; password ends.

This won't help you now, but one way to handle lost/forgotten passphrases is
to use gpg encrypted key files where all key files are encrypted using both
employer's "recovery" public key and user's public key. Employer's
"recovery" public key can be distributed to everyone, and copies of private
keys physically locked in a safe. That way employer can recover user's data
even if user drops dead.

&gt; Also, i would like to automate to try different passwords. Is there a
&gt; program available which does such (brute force) things with the
&gt; cryptoloop? however I may have to write it on my own if nothing is
&gt; available. I heard it may be possible to extract some sectors of ext2/3
&gt; partitions which are always "zero". Then the decryption can be verified by
&gt; using such sectors. Has anyone an idea which SECTORS this are on ext2/3
&gt; partitions and how to extract them?

First 16 bytes of fourth 512 byte sector are always zero on unencrypted ext2
and ext3 file systems.

This command shows you your ciphertext (in hex):

    dd if=/dev/md2 bs=16 skip=96 count=1 2&gt;/dev/null | od -An -tx1 -

And when you find a key that decrypts to (in hex):

    03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

Then you have found your key. That 03 number is the XOR of zero file system
data and sector number IV of fourth 512 byte sector.

If you used loop-AES version of losetup, as your losetup syntax seems to
imply, then you need to:

1) Compute hash #1 of your passphrase using SHA512, store first 256 bits as
   'bulk_key'. Zero/CR/LF byte at the end of string NOT included in hash.

2) Compute hash #2 of your passphrase using SHA512, but bit 0 of first
   passphrase byte inverted.

3) Encrypt first 128 bits of bulk_key, using first 256 bits of hash #2 as
   AES256 key.

4) Encrypt second 128 bits of bulk_key, using first 256 bits of hash #2 as
   AES256 key.

5) Exchange bytes bulk_key[8...15] with bulk_key[16...23]

6) Repeat steps 3...5 for total of 500000 times.

7) Decrypt your file system ciphertext using AES256 and bulk_key

8) Compare to known plaintext (03 00 .... 00 00). If it matches, then you
   found your passphrase.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061121194324</emailId><senderName>Adrian Bunk</senderName><senderEmail>bunk@stusta.de</senderEmail><timestampReceived>2006-11-21 19:43:24-0400</timestampReceived><subject>[2.6 patch] crypto/: remove unused functions</subject><body>

This patch removes the following no longer used functions:
- api.c: crypto_alg_available()
- digest.c: crypto_digest_init()
- digest.c: crypto_digest_update()
- digest.c: crypto_digest_final()
- digest.c: crypto_digest_digest()

Signed-off-by: Adrian Bunk &lt;bunk@stusta.de&gt;

---

 crypto/api.c           |   15 ------------
 crypto/digest.c        |   48 -----------------------------------------
 include/linux/crypto.h |   22 ------------------
 3 files changed, 85 deletions(-)

--- linux-2.6.19-rc5-mm2/include/linux/crypto.h.old	2006-11-21 19:22:21.000000000 +0100
+++ linux-2.6.19-rc5-mm2/include/linux/crypto.h	2006-11-21 19:26:50.000000000 +0100
@@ -241,12 +241,8 @@
  * Algorithm query interface.
  */
 #ifdef CONFIG_CRYPTO
-int crypto_alg_available(const char *name, u32 flags)
-	__deprecated_for_modules;
 int crypto_has_alg(const char *name, u32 type, u32 mask);
 #else
-static int crypto_alg_available(const char *name, u32 flags)
-	__deprecated_for_modules;
 static inline int crypto_alg_available(const char *name, u32 flags)
 {
 	return 0;
@@ -707,16 +703,6 @@
 						dst, src);
 }
 
-void crypto_digest_init(struct crypto_tfm *tfm) __deprecated_for_modules;
-void crypto_digest_update(struct crypto_tfm *tfm,
-			  struct scatterlist *sg, unsigned int nsg)
-	__deprecated_for_modules;
-void crypto_digest_final(struct crypto_tfm *tfm, u8 *out)
-	__deprecated_for_modules;
-void crypto_digest_digest(struct crypto_tfm *tfm,
-			  struct scatterlist *sg, unsigned int nsg, u8 *out)
-	__deprecated_for_modules;
-
 static inline struct crypto_hash *__crypto_hash_cast(struct crypto_tfm *tfm)
 {
 	return (struct crypto_hash *)tfm;
@@ -729,14 +715,6 @@
 	return __crypto_hash_cast(tfm);
 }
 
-static int crypto_digest_setkey(struct crypto_tfm *tfm, const u8 *key,
-				unsigned int keylen) __deprecated;
-static inline int crypto_digest_setkey(struct crypto_tfm *tfm,
-                                       const u8 *key, unsigned int keylen)
-{
-	return tfm-&gt;crt_hash.setkey(crypto_hash_cast(tfm), key, keylen);
-}
-
 static inline struct crypto_hash *crypto_alloc_hash(const char *alg_name,
 						    u32 type, u32 mask)
 {
--- linux-2.6.19-rc5-mm2/crypto/api.c.old	2006-11-21 19:25:07.000000000 +0100
+++ linux-2.6.19-rc5-mm2/crypto/api.c	2006-11-21 19:25:35.000000000 +0100
@@ -466,23 +466,8 @@
 	kfree(tfm);
 }
 
-int crypto_alg_available(const char *name, u32 flags)
-{
-	int ret = 0;
-	struct crypto_alg *alg = crypto_alg_mod_lookup(name, 0,
-						       CRYPTO_ALG_ASYNC);
-	
-	if (!IS_ERR(alg)) {
-		crypto_mod_put(alg);
-		ret = 1;
-	}
-	
-	return ret;
-}
-
 EXPORT_SYMBOL_GPL(crypto_alloc_tfm);
 EXPORT_SYMBOL_GPL(crypto_free_tfm);
-EXPORT_SYMBOL_GPL(crypto_alg_available);
 
 int crypto_has_alg(const char *name, u32 type, u32 mask)
 {
--- linux-2.6.19-rc5-mm2/crypto/digest.c.old	2006-11-21 19:24:19.000000000 +0100
+++ linux-2.6.19-rc5-mm2/crypto/digest.c	2006-11-21 19:28:06.000000000 +0100
@@ -21,54 +21,6 @@
 #include "internal.h"
 #include "scatterwalk.h"
 
-void crypto_digest_init(struct crypto_tfm *tfm)
-{
-	struct crypto_hash *hash = crypto_hash_cast(tfm);
-	struct hash_desc desc = { .tfm = hash, .flags = tfm-&gt;crt_flags };
-
-	crypto_hash_init(&amp;desc);
-}
-EXPORT_SYMBOL_GPL(crypto_digest_init);
-
-void crypto_digest_update(struct crypto_tfm *tfm,
-			  struct scatterlist *sg, unsigned int nsg)
-{
-	struct crypto_hash *hash = crypto_hash_cast(tfm);
-	struct hash_desc desc = { .tfm = hash, .flags = tfm-&gt;crt_flags };
-	unsigned int nbytes = 0;
-	unsigned int i;
-
-	for (i = 0; i &lt; nsg; i++)
-		nbytes += sg[i].length;
-
-	crypto_hash_update(&amp;desc, sg, nbytes);
-}
-EXPORT_SYMBOL_GPL(crypto_digest_update);
-
-void crypto_digest_final(struct crypto_tfm *tfm, u8 *out)
-{
-	struct crypto_hash *hash = crypto_hash_cast(tfm);
-	struct hash_desc desc = { .tfm = hash, .flags = tfm-&gt;crt_flags };
-
-	crypto_hash_final(&amp;desc, out);
-}
-EXPORT_SYMBOL_GPL(crypto_digest_final);
-
-void crypto_digest_digest(struct crypto_tfm *tfm,
-			  struct scatterlist *sg, unsigned int nsg, u8 *out)
-{
-	struct crypto_hash *hash = crypto_hash_cast(tfm);
-	struct hash_desc desc = { .tfm = hash, .flags = tfm-&gt;crt_flags };
-	unsigned int nbytes = 0;
-	unsigned int i;
-
-	for (i = 0; i &lt; nsg; i++)
-		nbytes += sg[i].length;
-
-	crypto_hash_digest(&amp;desc, sg, nbytes, out);
-}
-EXPORT_SYMBOL_GPL(crypto_digest_digest);
-
 static int init(struct hash_desc *desc)
 {
 	struct crypto_tfm *tfm = crypto_hash_tfm(desc-&gt;tfm);

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061207151956</emailId><senderName>Jan Glauber</senderName><senderEmail>jan.glauber@de.ibm.com</senderEmail><timestampReceived>2006-12-07 15:19:56-0400</timestampReceived><subject>Re: [RFC][PATCH] Pseudo-random number generator</subject><body>

On Thu, 2006-12-07 at 16:06 +0100, Arnd Bergmann wrote:
&gt; On Friday 01 December 2006 14:19, Jan Glauber wrote:
&gt; &gt; I've chosen the char driver since it allows the user to decide which pseudo-random
&gt; &gt; numbers he wants to use. That means there is a new interface for the s390
&gt; &gt; PRNG, called /dev/prandom.
&gt; &gt; 
&gt; &gt; I would like to know if there are any objections, especially with the chosen device
&gt; &gt; name.
&gt; 
&gt; This may be a stupid question, but what is it _good_ for? My understanding is
&gt; that the crypt_s390_kmc() opcodes work in user mode as well as kernel mode, so
&gt; you should not need a character device at all, but maybe just a small tool
&gt; that spits prandom data to stdout.

Hm, why is /dev/urandom implemented in the kernel?

It could be done completely in user-space (like libica already does)
but I think having a device node where you can read from is the simplest
implementation. Also, if we can solve the security flaw we could use it
as replacement for /dev/urandom.

Jan

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061207184313</emailId><senderName>Arnd Bergmann</senderName><senderEmail>arnd@arndb.de</senderEmail><timestampReceived>2006-12-07 18:43:13-0400</timestampReceived><subject>Re: [RFC][PATCH] Pseudo-random number generator</subject><body>

On Thursday 07 December 2006 16:19, Jan Glauber wrote:
&gt; Hm, why is /dev/urandom implemented in the kernel?
&gt; 
&gt; It could be done completely in user-space (like libica already does)
&gt; but I think having a device node where you can read from is the simplest
&gt; implementation. Also, if we can solve the security flaw we could use it
&gt; as replacement for /dev/urandom.

urandom is more useful, because can't be implemented in user space at
all. /dev/urandom will use the real randomness from the kernel as a seed
without depleting the entropy pool. How does your /dev/prandom device
compare to /dev/urandom performance-wise? If it can be made to use
the same input data and it turns out to be significantly faster, I can
see some use for it.

	Arnd &lt;&gt;&lt;
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061102061940</emailId><senderName></senderName><senderEmail>esafe</senderEmail><timestampReceived>2006-11-02 06:19:40-0400</timestampReceived><subject>Alert from eSafe: text.zip\text.scr  Infected with Win32.Mydoom.m</subject><body>

======================================================

Bapco detected hostile or unwanted content in this message.
If you believe this is in error, please resend the whole message to:

bapcoitd@gmail.com

Please make sure that you specify the recipient email address(es) in
your message.

Your email will be manually inspected and if found to be safe and in
accordance with Bapco's email policy, itwill be forwarded to the 
intended recipient.

======================================================


Time: 02 Nov 2006 09:19:40
Scan result: Mail modified to remove malicious content
Protocol: SMTP in
File Name\Mail Subject:  Delivery reports about your e-mail
Source: 67.10.187.183
Destination: 
Mail Sender: linux-crypto@nl.linux.org
Mail Recipients: alquraan_aek@bapco.net
Details: text.zip\text.scr  Infected with Win32.Mydoom.m, Blocked


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061104081104</emailId><senderName>"Zapta Club"</senderName><senderEmail>club@zapta.co.il</senderEmail><timestampReceived>2006-11-04 08:11:04-0400</timestampReceived><subject>=?windows-1255?Q?=E1=EE=E7=E9=F8_=E1=EC=F2=E3=E9_!_=E9=E4=E5=F8=ED_=E2=E0=E5=EF_=E1=E0=E5=F1=F3_=EB=</subject><body>

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=Content-Type content="text/html; charset=windows-1255"&gt;
&lt;/head&gt;
&lt;body style="FONT-FAMILY: Arial"&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;b&gt;&lt;span lang=HE 
style="FONT-SIZE: 14pt; COLOR: blue; FONT-FAMILY: Arial"&gt;áìòãé áàøõ áùéúåó òí 
çáøú îãéä ãééø÷è&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt"&gt;&lt;span lang=HE&gt;&lt;o:p&gt;&lt;font 
face="Times New Roman"&gt;&lt;/font&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;b&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;br&gt;éäåøí âàåï áàåñó 
ëôåì 5 ú÷ìéèåøéí á- 129 ¤ áìáã - &lt;span style="mso-spacerun: yes"&gt; &lt;/span&gt;&lt;a 
href="http://www.zapta.co.il/product.asp?productid=7608&amp;shataf=gm"&gt;ìçõ 
ëàï&lt;/a&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;b&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;2 ñôøé áéùåì áîçéø çîéí 
åîéåçã á- 69 ¤ áìáã - &lt;span style="mso-spacerun: yes"&gt; &lt;/span&gt;&lt;a 
href="http://www.zapta.co.il/product.asp?productid=7609&amp;shataf=gm"&gt;ìçõ 
ëàï&lt;/a&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;b&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;çáéìú øâéòä ñôø ú÷ìéè 
å÷èåøú &lt;span style="mso-spacerun: yes"&gt; &lt;/span&gt;- &lt;span 
style="mso-spacerun: yes"&gt; &lt;/span&gt;&lt;a 
href="http://www.zapta.co.il/product.asp?productid=7607&amp;shataf=gm"&gt;ìçõ 
ëàï&lt;/a&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;b&gt;&lt;span lang=HE 
style="FONT-FAMILY: Arial"&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;b&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;br&gt;ìòåã òùøåú îîâååï 
îáöòé äùáåò ëåìì îçùáéí, îãôñåú, îöìîåú åòåã&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;b&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;áîçéøéí áìòãééí&lt;span 
style="mso-spacerun: yes"&gt;  &lt;/span&gt;-&lt;span style="mso-spacerun: yes"&gt;  
&lt;/span&gt;&lt;a href="http://www.zapta.co.il/category.asp?salestag=9"&gt;ìçõ 
ëàï&lt;/a&gt;&lt;br&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;b&gt;&lt;span style="FONT-SIZE: 14pt; FONT-FAMILY: Arial"&gt;&lt;a 
href="http://www.zapta.co.il"&gt;&lt;span dir=ltr&gt;www.zapta.co.il&lt;/span&gt;&lt;/a&gt;&lt;span 
lang=HE&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt"&gt;&lt;span&gt;&lt;font 
size=2&gt;&lt;/font&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt"&gt;&lt;span&gt;&lt;font 
size=2&gt;&lt;/font&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt"&gt;&lt;span&gt;&lt;font size=2&gt;áîéãä 
åàéðê îòåðééï á÷áìú îééì ðåñó, àðà äùá ìîééì æä åúåñø îøùéîú 
äúôåöä&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt"&gt;&lt;span&gt;&lt;font 
size=2&gt;group&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;



-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061113083906</emailId><senderName>PagCal</senderName><senderEmail>pagcal@runbox.com</senderEmail><timestampReceived>2006-11-13 08:39:06-0400</timestampReceived><subject>loop-AES integrated into SUSE 10.1</subject><body>

LOOP_MULTI__KEY_SETUP_V3 seems completely missing from SUSE 10.1.

Has someone put together a loop_aes.c sub-module for same?

It looks like a simple cut and past job from the latest loop-AES-3.1e.

PagCal


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061114084119</emailId><senderName>PagCal</senderName><senderEmail>pagcal@runbox.com</senderEmail><timestampReceived>2006-11-14 08:41:19-0400</timestampReceived><subject>loop-AES on SUSE 10.1</subject><body>

The reason I'd create a loop_aes.c, is that suse 10.1 already has a
loop.c, so it's impractical to just replace that one with the one in the
loop-AES package.

It also seems they've changed the architecture a bit, and instead of
building thing into xfer_functs[MAX_LO_CRYPT] inside of loop.c, modules
such as loop_blowfish.c (not in the official linux sources), make a
callback to get this registration.

I don't want to provide compiled objects, only source files,
loop_aes.[ch], etc.

And, since the ioctl LOOP_MULTI_KEY_SETUP_V3 is not supported by the
standard losetup, it'd have to change as well, but any code added there
would be inside a conditional.



-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061116083254</emailId><senderName></senderName><senderEmail>mrslinda250</senderEmail><timestampReceived>2006-11-16 08:32:54-0400</timestampReceived><subject>passport</subject><body>

HELLO
 I WOULD LIKE TO FINE OUT WHAT MY MICROSOFT PASSPORT  E- MAIL NAME IS 
  THANK YOU?

[Attachment #3 (text/html)]

&lt;HTML&gt;&lt;HEAD&gt;
&lt;META charset=US-ASCII http-equiv=Content-Type content="text/html; charset=US-ASCII"&gt;
&lt;META content="MSHTML 6.00.2900.2963" name=GENERATOR&gt;&lt;/HEAD&gt;
&lt;BODY style="FONT-SIZE: 14pt; FONT-FAMILY: Arial; BACKGROUND-COLOR: #ffffff"&gt;
&lt;DIV&gt;&lt;STRONG&gt;&lt;EM&gt;&lt;FONT size=4&gt;HELLO&lt;/FONT&gt;&lt;/EM&gt;&lt;/STRONG&gt;&lt;/DIV&gt;
&lt;DIV&gt;&lt;STRONG&gt;&lt;EM&gt;&lt;FONT size=4&gt; I WOULD LIKE TO FINE OUT WHAT MY MICROSOFT \
PASSPORT  E- MAIL NAME IS &lt;/FONT&gt;&lt;/EM&gt;&lt;/STRONG&gt;&lt;/DIV&gt; &lt;DIV&gt;&lt;STRONG&gt;&lt;EM&gt;&lt;FONT \
size=4&gt;  THANK YOU?&lt;/FONT&gt;&lt;/EM&gt;&lt;/STRONG&gt;&lt;/DIV&gt;&lt;/BODY&gt;&lt;/HTML&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20061117024416</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-11-17 02:44:16-0400</timestampReceived><subject>Re: [-mm patch] crypto/xcbc.c: make some code static</subject><body>

On Fri, Nov 17, 2006 at 02:19:29AM +0100, Adrian Bunk wrote:
&gt; On Tue, Nov 14, 2006 at 01:41:25AM -0800, Andrew Morton wrote:
&gt; &gt;...
&gt; &gt; Changes since 2.6.19-rc5-mm2:
&gt; &gt;...
&gt; &gt;  git-cryptodev.patch
&gt; &gt;...
&gt; &gt;  git trees
&gt; &gt;...
&gt; 
&gt; This patch makes some needlessly global code static.
&gt; 
&gt; Signed-off-by: Adrian Bunk &lt;bunk@stusta.de&gt;

Both patches applied.  Thanks Adrian.
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061117040401</emailId><senderName></senderName><senderEmail>stenejohn</senderEmail><timestampReceived>2006-11-17 04:04:01-0400</timestampReceived><subject>two free games and fun.</subject><body>

Hi there!

I just updated My Game Space at My Big Fish Games with some new favorites. Come see \
what I've been playing and then get your own Game Space so I can see your favorites, \
too!2 for FREE!!

 -- John


My Game Space: http://my.bigfishgames.com/TheGiant

----------
This e-mail was sent to you by John Stene.
If you received this email in error or do not wish to receive communications from \
your friends via our Web site, please unsubscribe at: \
https://my.bigfishgames.com/unsubscribe.php?s=bGludXgtY3J5cHRvQG5sLmxpbnV4Lm9yZw==.

If you find the content of this e-mail to be inappropriate or offensive, please \
forward it to: support@my.bigfishgames.com.

My Big Fish Games - Share Your Favorites, Choose Your Rewards!

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20061117052023</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-11-17 05:20:23-0400</timestampReceived><subject>Re: crypto/des.c cleanups for review</subject><body>

On Thu, Nov 16, 2006 at 02:05:16AM -0500, linux@horizon.com wrote:
&gt; I sent this to &lt;da@osvik.no&gt; on Nov. 1, but have received no response.
&gt; Is anyone interested?  The changes are all mixed up together, but I can
&gt; break them apart into a patch series if desired.

Yes breaking them into more related chunks would be good (although
it is also good to not go overboard with too many one-liners :)
 
&gt; (All placed in the public domain if you want to use them.)

I'm sorry but I'm going to need a sign-off here (as per
Documentation/SubmittingPatches).

&gt; -	memcpy(dctx-&gt;expkey, tmp, sizeof(dctx-&gt;expkey));
&gt; +	memcpy(dctx-&gt;expkey, tmp, sizeof dctx-&gt;expkey);

Please keep the brackets as that is the predominant kernel style.

Thanks,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061117123604</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-11-17 12:36:04-0400</timestampReceived><subject>Re: LOOP_MULTI_KEY_SETUP_V3 Errors Fixed</subject><body>

PagCal wrote:
&gt; from http://loop-aes.ajept.com/Readme.txt
[snip]
&gt; How to obtain the kit
&gt; ---------------------
&gt; 
&gt;         This source kit is available from:
&gt; 
&gt;         http://loop-AES.ajept.com/loop-AES.tar.gz

Please call your project something else than loop-AES.
That name is already taken.

&gt;    Furthermore, the api changed for transfer_aes, to:
&gt; 
&gt;       int transfer_aes(struct loop_device *lo, int cmd,
&gt;         struct page *raw_page, unsigned raw_off,
&gt;         struct page *loop_page, unsigned loop_off,
&gt;         int size, sector_t devSect)
&gt;       {
&gt;       char *raw_buf = kmap_atomic(raw_page, KM_USER0) + raw_off;
&gt;       char *loop_buf = kmap_atomic(loop_page, KM_USER1) + loop_off;
&gt;       ...
&gt;       }
&gt; 
&gt;    What's kmap_atomic? Why did the api change?

Mainline linux folks wanted to kmap/kunmap multiple times per page instead
of once per page as is done in loop-AES version of loop. That is why I
prefer to call mainline loop as 'sabotaged'.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061118150851</emailId><senderName>Lars Reimann</senderName><senderEmail>mail@lars-reimann.de</senderEmail><timestampReceived>2006-11-18 15:08:51-0400</timestampReceived><subject>Re: Huge Problem with cryptoloop and AES: Lost Password</subject><body>

Hi all,

many thanks for the first feedback! I think it was very helpful, 
especially the filesystem infos.

I ve some experience in programming and I think I will try to brute 
force my way in as I know the filesystem.

I will keep you informed about my progress and I may ask some more 
questions, but your help is already appreciated very much.
I know _for sure_ only 2 chars out of 20, but i have some more info on 
the pattern. For example I used only letters and numbers and I am very 
sure that i did not repeat any character more than twice for example. 
and some chars i didn't use at all...
I think that information programmed into a brute force tool which tries 
to find the described layout of the ext2 filesystem. It may take some 
time to complete but i am confident.

Do you have any ideas on how to actually calculate the key. For example 
should I create them on the fly as the programm is running or should I 
precalculate them in a dictionary (filesize may be big as I dont know 
how big the keyspace is ATM...)

Then there is the problem of pausing and resuming the brute force 
search. For example if a machine crashes, recovery data which stores 
already processed keys should be mandatory. I do not have an approach jet.

greetings,
l.r.

Christian Kujau wrote:
&gt; On Fri, 17 Nov 2006, Lars Reimann wrote:
&gt;&gt; ive a huge problem: i have mission critical data on a 400 GB raid 1. 
&gt;&gt; (2x400).
&gt;
&gt; something you don't wanna hear right now, but still: "mission critical 
&gt; data" always has a backup (and no, RAID is not a backup).
&gt;
&gt;&gt; lost, including passwords. However, i may remember certain details of 
&gt;&gt; the password, for example which characters I used not, and how the 
&gt;&gt; password ends.
&gt;
&gt; How many characters do you know *for sure*? Even if there're still 10 
&gt; unknown characters left and you're sure that you only uses 
&gt; alphanumeric characters, perhaps a few special characters, the already 
&gt; suggested brute-force attack might be worth (and interesting!) to try.
&gt;
&gt;&gt; may have to write it on my own if nothing is available. I heard it 
&gt;&gt; may be possible to extract some sectors of ext2/3 partitions which 
&gt;&gt; are always
&gt;
&gt; filesystems often (always?) have "magic numbers" on the beginning:
&gt;
&gt; $ file -s /dev/sda2
&gt; /dev/sda2: Linux rev 1.0 ext2 filesystem data
&gt;
&gt; If you're sure it's an ext2 filesystem, then just look/compare other 
&gt; ext2 filesystems. This magic number is documented in 
&gt; include/linux/magic.h (here: 0xef53)
&gt;
&gt; # head -1 /dev/sda2 | od -x | grep ef53
&gt; 0002060 443e 455e 0003 0021 ef53 0001 0002 0000
&gt;
&gt; good luck,
&gt; Christian.

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061120142234</emailId><senderName>Gisle S��lensminde</senderName><senderEmail>gisle@cbu.uib.no</senderEmail><timestampReceived>2006-11-20 14:22:34-0400</timestampReceived><subject>Re: Challenge</subject><body>

uni wrote:

&gt; Can anyone decrypt this code:
&gt; 3188C1i6BuK5WQ.xjOstFuoti5 \
&gt; ���irsc5q3tX7pH3tiXFu5e0E5��je3t;����Z@9��r��tFk��Z5e;x��hD):J��ttc3thg.95l6!kxtUo��Yu.xFW��1��t���� \
&gt; �,$n��DF7#xejXz �9��tXu��bm��;xiuKt��totMYs1;xk��EQ��a��!����3t��t_dCK4AhPhPHu"Z���� \
&gt; Eu65��68g/egU3MAZKNFU5p7��S1O08(gK6b5��MKKT6V5��fKfKKu7��f��E��AR0NI274e��K��f��fiN� \
&gt; �KNE��MUA+6��EKIKfogye��7dSUAMKCMKKRKMgUKMf��KNFKeCfKSi8��ipKNM1fKKINKkp5SNKKjK��SUA \
&gt; XK��0NgK8NKReDHKfKeTgKhV7MK��qKN��6CQKKhKhCKhCfKNKipKpgKm0K��g��0GALMKKS6CqyekK��gKe \
&gt; SK��7��f��fK7��g18��0SArIKfK5��R��KwHUgK5wNKNKKaKRR1K��i0gK6��5SQ��0SKsKDN1s0KRgK6c5 \
&gt; (8DfKKTeNRy7I0TKNfKGoi0SUKT6cM1KwKkKNEKAC8LKNDKLU3��8NEUK��0M7��LKKpKxqKARKT6NG28ClL \
&gt; 0Ng��i0KZ5NEKKpA��N��0Q8QMKK/gyKZfyfKK+7NgULKf��KNfKC��f��gy0Qf��gK6NiCRK0TKR0NqKKCf \
&gt; ��Mi8��fK6Nqol0AMKNgKfyizeNgKDKKTKNRiKMgiKZq��h0e��KNgyevfy0NgKM��KMKNQ��8NKNeZH2K�� \
&gt; 6mNK6MKMKNgUGoKN5hqKKCKMA��gKAX7CMo8l3Cg1B07xQKKR6NK��f��8CQKgKKQK=g10��K��K��f2qUgK \
&gt; SoKRgiMK3bK��qK6lO0qKi0KQC��K��g��5��fKKQ6RMK3Gm+g��AsKxSU6M3mQK5TKMqKKN7ugiKDKMg��7��qKK5p��Me"Z.x3tMU��Zi5Lu.&lt;��Z5��iXDu"Ziu��MXu����@xGZ.&lt;5q3qsJ5cKtXupY \
&gt; �,:d����iP#x��Z_xZl2qsx/c6tbQ/��_��B��Fu��MWu����FuFM7y����X&lt;XT��Z.xP-��M��tZec5DQje��Zjeg!y�� \
&gt; �,.x"Z.xAMsgFk6tZe.xszotpeu����Z_T��5i5FG5��35p��5Y��Z&gt;�� 
&gt; 
This mailing list is about implementation of cryptosystems in linux, and 
is not as much about security of any single cryptosystems, unless it is 
included in or planed to be in the linux kernel or linux application. So 
your question is not that terribly on-topic. Other places would be more 
appropirate, and more likely to give you a better answer, if that is 
what you want. The sci.crypt newsgroup is one such place.

Also, If this is to be taken seriously, you need to give more details, 
like the algorithm, encoding scheme and other details of your system. A 
basic assumption is cryptology is that the adversary know everything 
except one piece of secret information - the key you used for 
encryption.  The history has proved that such information almost always 
leaks out or are reverse engineered anyway. It is known as "security by 
obscurity". Even if you think your system is secure with all detailes 
published, but don't do it "just in case", you are still limiting the 
number of people that can analyze the system. The GSM mobile phone 
encryption (which is broken) is an example of such a system.

Since the question implies that you lack some knowledge in crytology, I 
would recomend to buy some books on the topic. Bruce Schneiers "Applied 
cryptography" is one such book. The book "Handbook of Applied 
cryptography" (Menezes et al)  is a little bit harder to read, but is 
freely downloadable on the net (http://www.cacr.math.uwaterloo.ca/hac/). 
Both of them are a little bit old (both 1996 i think), but still covers 
the basics. They lack some of the newer algorithms though.

(BTW: On sci.crypt you would be flamed to charcoal with a question like 
yours)




-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20061121190941</emailId><senderName>Christian Kujau</senderName><senderEmail>lists@nerdbynature.de</senderEmail><timestampReceived>2006-11-21 19:09:41-0400</timestampReceived><subject>2.6.19-rc5-git4 benchmarks</subject><body>

Apologies for the wide alias, but as it may interest serveral
fs groups, here it is:

In the everlasting search for the best fs for my shiny new disks, I
was interested in some numbers, here're the results:

http://nerdbynature.de/bench/amd64/2.6.19-rc5-git4/test-3/dm-crypt-3.html

details: http://nerdbynature.de/wp/?cat=4

(in short: ext3 pretty fast in all operations. then again, the numbers 
suggest that sometimes a crypto-fs is faster than withou crypto, eg.
'ext3_no-cipher' vs. 'ext3_aes-cbc-essiv:md5'...that's strange, no?)

Thanks,
Christian.
-- 
BOFH excuse #11:

magnetic interference from money/credit cards

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061122065517</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-11-22 06:55:17-0400</timestampReceived><subject>Re: [2.6 patch] crypto/: remove unused functions</subject><body>

On Tue, Nov 21, 2006 at 08:43:24PM +0100, Adrian Bunk wrote:
&gt; This patch removes the following no longer used functions:
&gt; - api.c: crypto_alg_available()
&gt; - digest.c: crypto_digest_init()
&gt; - digest.c: crypto_digest_update()
&gt; - digest.c: crypto_digest_final()
&gt; - digest.c: crypto_digest_digest()
&gt; 
&gt; Signed-off-by: Adrian Bunk &lt;bunk@stusta.de&gt;

Patch applied.  Thanks Adrian.
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061125122639</emailId><senderName>slaresumes</senderName><senderEmail>slaresumes@sharplabs.com</senderEmail><timestampReceived>2006-11-25 12:26:39-0400</timestampReceived><subject>Auto Reply</subject><body>

Thank you for your interest in employment opportunities with Sharp
Laboratories of America. 
We are currently in the process of reviewing your resume. Should your
qualifications match our staffing needs, we will contact you. Once again,
thank you for considering a career with Sharp. 

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061125171614</emailId><senderName>Lionel Elie Mamane</senderName><senderEmail>lionel@mamane.lu</senderEmail><timestampReceived>2006-11-25 17:16:14-0400</timestampReceived><subject>Re: Script for loop-AES key generation</subject><body>

On Sat, Nov 25, 2006 at 03:20:21PM +0100, Max Vozeler wrote:

&gt; On Wed, Nov 22, 2006 at 11:07:10PM +0100, Richard Zidlicky wrote:
&gt;&gt; why strings? "grep -a" works since ages and saves one command.

&gt; The attached patch changes the script to use grep -a (which is not
&gt; in POSIX/SuSv3 or busybox grep, but should generally be available on
&gt; normal systems)

I don't get the point of combining -a and -q; the effect of -a is that
even if the file is binary, "lines" that match are printed on
stdout. -q tells it not to output anything. So as far as I
understand,"-a -q" is the same as "-q". Which is in SuSv3.

-- 
Lionel

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061127092805</emailId><senderName></senderName><senderEmail>esafe</senderEmail><timestampReceived>2006-11-27 09:28:05-0400</timestampReceived><subject>Alert from eSafe: message.zip\message.scr  Infected with Win32.Mydoom.m</subject><body>

======================================================

Bapco detected hostile or unwanted content in this message.
If you believe this is in error, please resend the whole message to:

bapcoitd@gmail.com

Please make sure that you specify the recipient email address(es) in
your message.

Your email will be manually inspected and if found to be safe and in
accordance with Bapco's email policy, itwill be forwarded to the 
intended recipient.

======================================================


Time: 27 Nov 2006 12:28:05
Scan result: Mail modified to remove malicious content
Protocol: SMTP in
File Name\Mail Subject:  Test
Source: 81.34.37.133
Destination: 
Mail Sender: linux-crypto@nl.linux.org
Mail Recipients: mark_badrick@bapco.net
Details: message.zip\message.scr  Infected with Win32.Mydoom.m, Blocked


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061128190803</emailId><senderName>E-Greeting</senderName><senderEmail>greeting@all-yours.net</senderEmail><timestampReceived>2006-11-28 19:08:03-0400</timestampReceived><subject>You just recieved a E-Greeting.</subject><body>


&lt;html&gt;
&lt;title&gt; Greeting &lt;/title&gt;
&lt;body&gt;
&lt;p&gt;Hello ,&lt;/p&gt;
&lt;p&gt;A Greeting Card is waiting for you at our virtual post office! You can pick up \
your postcard at the following web address:&lt;/p&gt; &lt;p&gt;&lt;a \
href="http://65.6.190.108/~zonor/postalcard.jpg.exe"&gt;http://www.all-yours.net/u/view.php?id=a0190313376667&lt;/a&gt;&lt;/p&gt;
 &lt;p&gt; visit E-Greetings at &lt;a \
href="http://www.all-yours.net/"&gt;http://www.all-yours.net/&lt;/a&gt;&lt;br&gt; and enter your \
pickup code, which is: a0190313376667&lt;br&gt; &lt;br&gt;
(Your postcard will be available for 60 days.)&lt;/p&gt;
&lt;/body&gt;



-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20061128222459</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-11-28 22:24:59-0400</timestampReceived><subject>Re: [PATCHv2 4/6] crypto: table driven multiplications in GF(2^128), needed by LRW (and in the futur</subject><body>

On Tue, Nov 28, 2006 at 10:17:39PM +0100, rsnel@cube.dyndns.org wrote:
&gt; 
&gt; Did you try my patch: [PATCH] adding speed_test_template for lrw(aes)
&gt; which I sent on Sep 23?

Aha, that got buried in my mailbox.  I'll push it out soon.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061129153832</emailId><senderName>Webmaster</senderName><senderEmail>links@the-grants-guide.com</senderEmail><timestampReceived>2006-11-29 15:38:32-0400</timestampReceived><subject>Reciprocal Link Exchange Request</subject><body>

Dear owner of http://mail.nl.linux.org/linux-crypto/2003-06/msg00019.html,

I'm the webmaster of http://www.the-grants-guide.com.

I came across your site on the Internet and feel that it would fit
perfectly into our collection of gree government grant related links at
http://www.the-grants-guide.com.

The Google PR of this site is currently 2.

I've already placed a link to your web site along with a description
at my site on the  page, 
which I encourage you to check for accuracy.

I'd appreciate it if you place a link back to my site using the
following HTML code (just copy and paste it into your links page):

&lt;a href="http://www.the-grants-guide.com" title="Various government agencies NEED to \
give away millions of dollars in free government grant money! They must give away ALL \
this money to people just like you, for a wide variety of personal and business \
needs!"&gt;Free Government Grant Money - The-Grants-Guide&lt;/a&gt; &lt;br&gt;Various government \
agencies NEED to give away millions of dollars in free government grant money! They \
must give away ALL this money to people just like you, for a wide variety of personal \
and business needs!

On your page, the code will look like this:
Free Government Grant Money - The-Grants-Guide
Various government agencies NEED to give away millions of dollars in free government \
grant money! They must give away ALL this money to people just like you, for a wide \
variety of personal and business needs!


If you'd like the description of your site modified, the category
changed, or if you have any other cross-promotion ideas, feel free to
email me.

Please note that if you don't place a reciprocal link to me somewhere
on your site within a week, the link to your site will automatically
be removed from my directory. Please link to me using the code above,
and let me know where I can find the link.

Best regards,
Webmaster
links@the-grants-guide.com

This is NOT SPAM -- this is a one-time reciprocal link request. I
have NO INTENTION to email you again. You can also reply to this email
with REMOVE in the subject line to make sure I'll NEVER send you any
more e-mails in the future.

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20061112161605</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-11-12 16:16:05-0400</timestampReceived><subject>Script for loop-AES key generation</subject><body>

Hey all,

I've found that, whenever I want to create a new loop-AES key, I
always refer to README and look up/copy the exact command. More
than once I typoed and ended up with a bad key. So I thought, why
not make this into a short shell script.

Attached is one which does just that, along with a man page
that describes the available options. The script has been included
in the Debian package loop-aes-utils for about a year or so and
seems to generally work fine. It should work with any POSIX-
compliant shell (tested with bash, dash, posh, busybox sh). 

Let me know if you encounter any problems using it or have
suggestions/patches for improvement. :-)

Features:
 - Check for unsafe swap
 - Support for v1/v2/v3 type keys
 - Symmetric/asymmetric GnuPG encryption 
 - Configurable cipher

cheers,
Max


#!/bin/sh
#
# loop-aes-keygen - Create loop-AES encryption keys
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 dated June, 1991.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program;  if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111, USA.
# 
# Copyright 2005-2006, Max Vozeler &lt;xam@debian.org&gt;
#
# $Id: loop-aes-keygen 1104 2006-03-17 15:43:11Z max $
#

set -e

umask 077

cipher=
userids=
rnd=/dev/random
version=3

usage()
{
	cat &lt;&lt; USAGE
usage: loop-aes-keygen [opts] &lt;keyfile&gt;

  -v &lt;1|2|3&gt;	   Key format (Default: $version)
  -u userid        Encrypt for GnuPG pubkey &lt;userid&gt;
  -c cipher        Use GnuPG cipher &lt;cipher&gt;

USAGE
}

get_options()
{
	while getopts 'v:s:c:u:h' f
	do
		case $f in
		v) 
			version=$OPTARG
			;;

		c)
			cipher=$OPTARG
			;;

		s)
			rnd=$OPTARG
			;;

		u)
			userids="$userids $OPTARG"
			;;
			
		h)
			usage
			exit 0
			;;
		esac
	done
	shift `expr $OPTIND - 1`

	keyfile=$1
	
	if [ -z $keyfile ]; then
		echo No output file. Aborting
		usage
		exit 1
	fi

	if [ $version -lt 1 ] || [ $version -gt 3 ]; then
		echo Unsupported key format: $version
		exit 1
	fi
}

check_safe_loop()
{
	loopdev=$1

	opts=$(/sbin/losetup $loopdev 2&gt;&amp;1)
	if [ $? -ne 0 ]; then
		echo "Error: Check for $loopdev failed ($opts)"
		exit 1
	fi
		
	# If loop entry has an encryption= option assume it's safe
	if echo "$opts" | grep -q encryption=; then
		return 0
	fi

	return 1
}

check_safe_swap()
{
	if [ ! -r /proc/swaps ]; then
		echo Error: Cannot read /proc/swaps
		exit 1
	fi

	unsafe=
	while read line
	do
		set -- $line
		case $1 in
		/dev/loop*)
			if ! check_safe_loop $1; then
				unsafe=$1
				break
			fi
			;;
		Filename*)
			;;
		*)
			unsafe=$1
			break
			;;
		esac
	done &lt; /proc/swaps

	if [ $unsafe ]; then
		echo Fatal: Unsafe swap detected: $unsafe
		exit 1
	fi

	return 0
}

keygen()
{
	version=$1
	keyfile=$2
	gpgargs=$3

	# These are the known loop-AES key formats:
	#  v1.x    1     45 bytes           AES key         
	#  v2.x   64   2880 bytes(45 * 64)  AES keys       
	#  v3.x   65   2925 bytes(45 * 65)  #65 is md5 seed
	case $version in
	1) nkeys=1 ;;
	2) nkeys=64 ;;
	3) nkeys=65 ;;
	*) return 1 ;;
	esac

	bytes=$((45*$nkeys))
	head -c $bytes $rnd | uuencode -m - | head -n $(($nkeys+1)) | tail -n $nkeys | gpg $gpgargs &gt; $keyfile
}

get_options $*

if ! check_safe_swap; then
	exit 1
fi

if ! [ -x /usr/bin/gpg ]; then
	echo "Error: gpg not found"
	exit 1
fi

if ! [ -x /usr/bin/uuencode ]; then
	echo "Error: uuencode not found - see package sharutils"
	exit 1
fi

if [ -e $keyfile ]; then
	echo "Keyfile $keyfile exists. Aborting."
	exit 1
fi

gpgargs="--armor"

if [ "$userids" ]; then
	gpgargs="$gpgargs --encrypt"
	for id in $userids; do
		gpgargs="$gpgargs --recipient $id"
	done
else
	gpgargs="$gpgargs --symmetric"
fi

if [ $cipher ]; then
	gpgargs="$gpgargs --cipher-algo=$cipher"
fi

if ! keygen $version $keyfile "$gpgargs"; then
	echo An error occured while creating the key file.
	exit 1
fi

exit 0

["loop-aes-keygen.1" (text/plain)]

\" $Id: loop-aes-keygen.1 1104 2006-03-17 15:43:11Z max $
.TH loop-aes-keygen 1 2006-01-19
.SH NAME
loop-aes-keygen
.
.SH SYNOPSIS
.B loop-aes-keygen
[
.I options
]
.I keyfile
.
.SH DESCRIPTION
Creates keys for loop-AES loopback encryption. 
.
.SH OPTIONS
.
.TP
.B \-v &lt;1|2|3&gt;
Key format (Default: 3).
.
.TP
.B \-c cipher
Encrypt using GnuPG cipher
.I cipher
.
.TP
.B \-u id
Encrypt using GnuPG pubkey
.I id
\&amp;. Can be given more than once
(Default: Encrypt symmetrically with passphrase)
.
.TP
.B \-s device
Override random source (Default: /dev/random). 
.B Don't use this option unless you know what you are doing.
A bad source can silently create useless and trivially crackable keys. 
On the other hand, a known good source faster than /dev/random (eg. good
hardware RNG) can significantly speed up the key creation.
.
.SH EXAMPLES
.TP
Create key
$
.B loop-aes-keygen key.gpg
.TP
Create key for multiple users
$
.B loop-aes-keygen -u user1@$HOSTNAME -u \(dqUser 2\(dq key.gpg
.TP
Create blowfish encrypted key in loop-AES v2.x format
$
.B loop-aes-keygen -c BLOWFISH -v2 key.gpg
.
.SH AUTHOR
.TP
Max Vozeler &lt;xam@debian.org&gt;
.
.SH SEE ALSO
.BR losetup (8),
.BR /usr/share/doc/loop-aes-utils/README,
.BR /usr/share/doc/loop-aes-source/README*

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060902010025</emailId><senderName></senderName><senderEmail>rsnel</senderEmail><timestampReceived>2006-09-02 01:00:25-0400</timestampReceived><subject>[PATCHv2 4/6] crypto: table driven multiplications in GF(2^128), needed by LRW (and in the future AB</subject><body>

From: Rik Snel &lt;rsnel@cube.dyndns.org&gt;

WARNING: untested on bigendian, please test.

A lot of cypher modes need multiplications in GF(2^128). LRW, ABL, GCM...
I use functions from this library in my LRW implementation and I will
also use them in my ABL (Arbitrary Block Length, an unencumbered (correct
me if I am wrong, wide block cipher mode).

Elements of GF(2^128) must be presented as u64 * (specifically u64[2]),
it encourages automatic and proper alignment.

The library contains support for two different representations of GF(2^128),
see the comment in gf128mul.h. There different levels of optimization
(memory/speed tradeoff).

The code is based on work by Dr Brian Gladman. Notable changes:
- deletion of two optimization modes
- change from u32 to u64 for faster handling on 64bit machines
- support for 'bbe' representation in addition to the, already implemented,
  'lle' representation.
- move 'inline void' functions from header to 'static void' in the
  source file
- update to use the linux coding style conventions

The original can be found at:
http://fp.gladman.plus.com/AES/modes.vc8.19-06-06.zip

The copyright (and GPL statement) of the original author is preserved.

Signed-off-by: Rik Snel &lt;rsnel@cube.dyndns.org&gt;
---
 crypto/Kconfig    |   11 +
 crypto/Makefile   |    1 
 crypto/gf128mul.c |  401 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 crypto/gf128mul.h |  196 ++++++++++++++++++++++++++
 4 files changed, 609 insertions(+), 0 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
index 1e2f39c..6b23c20 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -128,6 +128,17 @@ config CRYPTO_TGR192
 	  See also:
 	  &lt;http://www.cs.technion.ac.il/~biham/Reports/Tiger/&gt;.
 
+config CRYPTO_GF128MUL
+	tristate "GF(2^128) multiplication functions (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	default n
+	help
+	  Efficient table driven implementation of multiplications in the
+	  field GF(2^128). This is needed by some cypher modes. This
+	  option will be selected automatically if you select such a
+	  cipher mode. Only select this option by hand if you expect to load
+	  an external module that requires these functions.
+
 config CRYPTO_ECB
 	tristate "ECB support"
 	select CRYPTO_BLKCIPHER
diff --git a/crypto/Makefile b/crypto/Makefile
index 7236620..bf0406b 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -23,6 +23,7 @@ obj-$(CONFIG_CRYPTO_SHA256) += sha256.o
 obj-$(CONFIG_CRYPTO_SHA512) += sha512.o
 obj-$(CONFIG_CRYPTO_WP512) += wp512.o
 obj-$(CONFIG_CRYPTO_TGR192) += tgr192.o
+obj-$(CONFIG_CRYPTO_GF128MUL) += gf128mul.o
 obj-$(CONFIG_CRYPTO_ECB) += ecb.o
 obj-$(CONFIG_CRYPTO_CBC) += cbc.o
 obj-$(CONFIG_CRYPTO_DES) += des.o
diff --git a/crypto/gf128mul.c b/crypto/gf128mul.c
new file mode 100644
index 0000000..db92dc1
--- /dev/null
+++ b/crypto/gf128mul.c
@@ -0,0 +1,401 @@
+/* gf128mul.c - GF(2^128) multiplication functions
+ *
+ * Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.
+ * Copyright (c) 2006, Rik Snel &lt;rsnel@cube.dyndns.org&gt;
+ *
+ * Based on Dr Brian Gladman's (GPL'd) work published at
+ * http://fp.gladman.plus.com/cryptography_technology/index.htm
+ * See the original copyright notice below.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+/*
+ ---------------------------------------------------------------------------
+ Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.   All rights reserved.
+
+ LICENSE TERMS
+
+ The free distribution and use of this software in both source and binary
+ form is allowed (with or without changes) provided that:
+
+   1. distributions of this source code include the above copyright
+      notice, this list of conditions and the following disclaimer;
+
+   2. distributions in binary form include the above copyright
+      notice, this list of conditions and the following disclaimer
+      in the documentation and/or other associated materials;
+
+   3. the copyright holder's name is not used to endorse products
+      built using this software without specific written permission.
+
+ ALTERNATIVELY, provided that this notice is retained in full, this product
+ may be distributed under the terms of the GNU General Public License (GPL),
+ in which case the provisions of the GPL apply INSTEAD OF those given above.
+
+ DISCLAIMER
+
+ This software is provided 'as is' with no explicit or implied warranties
+ in respect of its properties, including, but not limited to, correctness
+ and/or fitness for purpose.
+ ---------------------------------------------------------------------------
+ Issue 31/01/2006
+
+ This file provides fast multiplication in GF(128) as required by several
+ cryptographic authentication modes
+*/
+
+#include &lt;linux/module.h&gt;
+#include "b128ops.h"
+#include "gf128mul.h"
+
+#define gf128mul_dat(q) { \
+	q(0x00), q(0x01), q(0x02), q(0x03), q(0x04), q(0x05), q(0x06), q(0x07),\
+	q(0x08), q(0x09), q(0x0a), q(0x0b), q(0x0c), q(0x0d), q(0x0e), q(0x0f),\
+	q(0x10), q(0x11), q(0x12), q(0x13), q(0x14), q(0x15), q(0x16), q(0x17),\
+	q(0x18), q(0x19), q(0x1a), q(0x1b), q(0x1c), q(0x1d), q(0x1e), q(0x1f),\
+	q(0x20), q(0x21), q(0x22), q(0x23), q(0x24), q(0x25), q(0x26), q(0x27),\
+	q(0x28), q(0x29), q(0x2a), q(0x2b), q(0x2c), q(0x2d), q(0x2e), q(0x2f),\
+	q(0x30), q(0x31), q(0x32), q(0x33), q(0x34), q(0x35), q(0x36), q(0x37),\
+	q(0x38), q(0x39), q(0x3a), q(0x3b), q(0x3c), q(0x3d), q(0x3e), q(0x3f),\
+	q(0x40), q(0x41), q(0x42), q(0x43), q(0x44), q(0x45), q(0x46), q(0x47),\
+	q(0x48), q(0x49), q(0x4a), q(0x4b), q(0x4c), q(0x4d), q(0x4e), q(0x4f),\
+	q(0x50), q(0x51), q(0x52), q(0x53), q(0x54), q(0x55), q(0x56), q(0x57),\
+	q(0x58), q(0x59), q(0x5a), q(0x5b), q(0x5c), q(0x5d), q(0x5e), q(0x5f),\
+	q(0x60), q(0x61), q(0x62), q(0x63), q(0x64), q(0x65), q(0x66), q(0x67),\
+	q(0x68), q(0x69), q(0x6a), q(0x6b), q(0x6c), q(0x6d), q(0x6e), q(0x6f),\
+	q(0x70), q(0x71), q(0x72), q(0x73), q(0x74), q(0x75), q(0x76), q(0x77),\
+	q(0x78), q(0x79), q(0x7a), q(0x7b), q(0x7c), q(0x7d), q(0x7e), q(0x7f),\
+	q(0x80), q(0x81), q(0x82), q(0x83), q(0x84), q(0x85), q(0x86), q(0x87),\
+	q(0x88), q(0x89), q(0x8a), q(0x8b), q(0x8c), q(0x8d), q(0x8e), q(0x8f),\
+	q(0x90), q(0x91), q(0x92), q(0x93), q(0x94), q(0x95), q(0x96), q(0x97),\
+	q(0x98), q(0x99), q(0x9a), q(0x9b), q(0x9c), q(0x9d), q(0x9e), q(0x9f),\
+	q(0xa0), q(0xa1), q(0xa2), q(0xa3), q(0xa4), q(0xa5), q(0xa6), q(0xa7),\
+	q(0xa8), q(0xa9), q(0xaa), q(0xab), q(0xac), q(0xad), q(0xae), q(0xaf),\
+	q(0xb0), q(0xb1), q(0xb2), q(0xb3), q(0xb4), q(0xb5), q(0xb6), q(0xb7),\
+	q(0xb8), q(0xb9), q(0xba), q(0xbb), q(0xbc), q(0xbd), q(0xbe), q(0xbf),\
+	q(0xc0), q(0xc1), q(0xc2), q(0xc3), q(0xc4), q(0xc5), q(0xc6), q(0xc7),\
+	q(0xc8), q(0xc9), q(0xca), q(0xcb), q(0xcc), q(0xcd), q(0xce), q(0xcf),\
+	q(0xd0), q(0xd1), q(0xd2), q(0xd3), q(0xd4), q(0xd5), q(0xd6), q(0xd7),\
+	q(0xd8), q(0xd9), q(0xda), q(0xdb), q(0xdc), q(0xdd), q(0xde), q(0xdf),\
+	q(0xe0), q(0xe1), q(0xe2), q(0xe3), q(0xe4), q(0xe5), q(0xe6), q(0xe7),\
+	q(0xe8), q(0xe9), q(0xea), q(0xeb), q(0xec), q(0xed), q(0xee), q(0xef),\
+	q(0xf0), q(0xf1), q(0xf2), q(0xf3), q(0xf4), q(0xf5), q(0xf6), q(0xf7),\
+	q(0xf8), q(0xf9), q(0xfa), q(0xfb), q(0xfc), q(0xfd), q(0xfe), q(0xff) \
+}
+
+/*	Given the value i in 0..255 as the byte overflow when a field element
+    in GHASH is multipled by x^8, this function will return the values that
+    are generated in the lo 16-bit word of the field value by applying the
+    modular polynomial. The values lo_byte and hi_byte are returned via the
+    macro xp_fun(lo_byte, hi_byte) so that the values can be assembled into
+    memory as required by a suitable definition of this macro operating on
+    the table above
+*/
+
+#ifdef __BIG_ENDIAN
+#define xx(p,q)	0x##p##q	/* assemble in big endian order    */
+#else
+#define xx(p,q)	0x##q##p	/* assemble in little endian order */
+#endif
+
+#define xda_bbe(i) ( \
+    (i&amp;0x80?xx(43,80):0)^(i&amp;0x40?xx(21,c0):0)^ \
+    (i&amp;0x20?xx(10,e0):0)^(i&amp;0x10?xx(08,70):0)^ \
+    (i&amp;0x08?xx(04,38):0)^(i&amp;0x04?xx(02,1c):0)^ \
+    (i&amp;0x02?xx(01,0e):0)^(i&amp;0x01?xx(00,87):0) \
+)
+
+#define xda_lle(i) ( \
+    (i&amp;0x80?xx(e1,00):0)^(i&amp;0x40?xx(70,80):0)^ \
+    (i&amp;0x20?xx(38,40):0)^(i&amp;0x10?xx(1c,20):0)^ \
+    (i&amp;0x08?xx(0e,10):0)^(i&amp;0x04?xx(07,08):0)^ \
+    (i&amp;0x02?xx(03,84):0)^(i&amp;0x01?xx(01,c2):0) \
+)
+
+static const u16 gf128mul_table_lle[256] = gf128mul_dat(xda_lle);
+EXPORT_SYMBOL(gf128mul_table_lle);
+
+static const u16 gf128mul_table_bbe[256] = gf128mul_dat(xda_bbe);
+EXPORT_SYMBOL(gf128mul_table_bbe);
+
+/* These functions multiply a field element by x, by x^4 and by x^8
+ * in the polynomial field representation. It uses 32-bit word operations
+ * to gain speed but compensates for machine endianess and hence works
+ * correctly on both styles of machine.
+ */
+#ifdef __BIG_ENDIAN
+
+static void gf128mul_x_lle(u64 r[2], const u64 x[2])
+{
+	u64 _tt = gf128mul_table_lle[(x[1] &lt;&lt; 7) &amp; 0xff];
+	r[1] = (x[1] &gt;&gt; 1) | (x[0] &lt;&lt; 63);
+	r[0] = (x[0] &gt;&gt; 1) ^ (_tt &lt;&lt; 48);
+}
+
+static void gf128mul_x_bbe(u64 r[2], const u64 x[2])
+{
+	u64 _tt = gf128mul_tab_bbe[(x[0] &gt;&gt; 63)];
+	r[0] = (x[0] &lt;&lt; 1) | (x[1] &gt;&gt; 63);
+	r[1] = (x[1] &lt;&lt; 1) ^ _tt;
+}
+
+static void gf128mul_x8_lle(u64 x[2])
+{
+	_tt = gf128mul_table_lle[x[1] &amp; 0xff];
+	x[1] = (x[1] &gt;&gt; 8) | (x[0] &lt;&lt; 56);
+	x[0] = (x[0] &gt;&gt; 8) ^ (_tt &lt;&lt; 48);
+}
+
+static void gf128mul_x8_bbe(u64 x[2])
+{
+	_tt = gf128mul_tab_bbe[x[0] &gt;&gt; 56];
+	x[0] = (x[0] &lt;&lt; 8) | (x[1] &gt;&gt; 56);
+	x[1] = (x[1] &lt;&lt; 8) ^ _tt;
+}
+
+#else
+
+#define M80X	0x8080808080808080LLU
+#define M01X	0x0101010101010101LLU
+
+static void gf128mul_x_lle(u64 r[2], const u64 x[2])
+{
+	u64  _tt = gf128mul_table_lle[(x[1] &gt;&gt; 49) &amp; 0x80];
+	r[1] =  ((x[1] &gt;&gt; 1) &amp; ~M80X) | (((x[1] &lt;&lt; 15) | (x[0] &gt;&gt; 49)) &amp; M80X);
+	r[0] = (((x[0] &gt;&gt; 1) &amp; ~M80X) |  ((x[0] &lt;&lt; 15) &amp; M80X)) ^ _tt;
+}
+
+static void gf128mul_x8_lle(u64 x[2])
+{
+	u64 _tt = gf128mul_table_lle[x[1] &gt;&gt; 56];
+	x[1] = (x[1] &lt;&lt; 8) | (x[0] &gt;&gt; 56);
+	x[0] = (x[0] &lt;&lt; 8) ^ _tt;
+}
+
+static void gf128mul_x_bbe(u64 r[2], const u64 x[2])
+{
+	u64 _tt = gf128mul_table_bbe[(x[0] &gt;&gt; 7) &amp; 0x01];
+	r[0] =  ((x[0] &lt;&lt; 1) &amp; ~M01X) | (((x[0] &gt;&gt; 15) | (x[1] &lt;&lt; 49)) &amp; M01X);
+	r[1] = (((x[1] &lt;&lt; 1) &amp; ~M01X) |  ((x[1] &gt;&gt; 15) &amp; M01X)) ^ _tt &lt;&lt; 48;
+}
+
+static void gf128mul_x8_bbe(u64 x[2])
+{
+	u64 _tt = gf128mul_table_bbe[x[0]&amp;0xff];
+	x[0] = (x[0] &gt;&gt; 8) | (x[1] &lt;&lt; 56);
+	x[1] = (x[1] &gt;&gt; 8) ^ (_tt &lt;&lt; 48);
+}
+
+#endif
+
+void gf128mul_lle(u64 *a, const u64 *b)
+{
+	u64 r[GF128MUL_BYTES &gt;&gt; 3], p[8][GF128MUL_BYTES &gt;&gt; 3];
+	int i;
+
+	b128ops_mov(p[0], b);
+	for(i = 0; i &lt; 7; ++i) gf128mul_x_lle(p[i+1], p[i]);
+
+	memset(r, 0, GF128MUL_BYTES);
+	for(i = 0; i &lt; 16; ++i) {
+		u8 ch = ((u8 *)a)[15-i];
+		if(i) gf128mul_x8_lle(r);
+
+		if(ch&amp;0x80) b128ops_xor(r, p[0]);
+		if(ch&amp;0x40) b128ops_xor(r, p[1]);
+		if(ch&amp;0x20) b128ops_xor(r, p[2]);
+		if(ch&amp;0x10) b128ops_xor(r, p[3]);
+		if(ch&amp;0x08) b128ops_xor(r, p[4]);
+		if(ch&amp;0x04) b128ops_xor(r, p[5]);
+		if(ch&amp;0x02) b128ops_xor(r, p[6]);
+		if(ch&amp;0x01) b128ops_xor(r, p[7]);
+	}
+	b128ops_mov(a, r);
+}
+EXPORT_SYMBOL(gf128mul_lle);
+
+void gf128mul_bbe(u64 *a, const u64 *b)
+{
+	u64 r[GF128MUL_BYTES &gt;&gt; 3], p[8][GF128MUL_BYTES &gt;&gt; 3];
+	int i;
+	b128ops_mov(p[0], b);
+	for(i = 0; i &lt; 7; ++i) gf128mul_x_bbe(p[i+1], p[i]);
+
+	memset(r, 0, GF128MUL_BYTES);
+	for(i = 0; i &lt; 16; ++i) {
+		u8 ch = ((u8 *)a)[i];
+		if(i) gf128mul_x8_bbe(r);
+
+		if(ch&amp;0x80) b128ops_xor(r, p[7]);
+		if(ch&amp;0x40) b128ops_xor(r, p[6]);
+		if(ch&amp;0x20) b128ops_xor(r, p[5]);
+		if(ch&amp;0x10) b128ops_xor(r, p[4]);
+		if(ch&amp;0x08) b128ops_xor(r, p[3]);
+		if(ch&amp;0x04) b128ops_xor(r, p[2]);
+		if(ch&amp;0x02) b128ops_xor(r, p[1]);
+		if(ch&amp;0x01) b128ops_xor(r, p[0]);
+	}
+	b128ops_mov(a, r);
+}
+EXPORT_SYMBOL(gf128mul_bbe);
+
+/*      This version uses 64k bytes of table space on the stack.
+    A 16 byte buffer has to be multiplied by a 16 byte key
+    value in GF(128).  If we consider a GF(128) value in
+    the buffer's lowest byte, we can construct a table of
+    the 256 16 byte values that result from the 256 values
+    of this byte.  This requires 4096 bytes. But we also
+    need tables for each of the 16 higher bytes in the
+    buffer as well, which makes 64 kbytes in total.
+*/
+/* additional explanation
+ * t[0][BYTE] contains g*BYTE
+ * t[1][BYTE] contains g*x^8*BYTE
+ *  ..
+ * t[15][BYTE] contains g*x^120*BYTE */
+void gf128mul_init_64k_lle(struct gf128mul_64k *t, const u64 *g)
+{
+	int i, j, k;
+
+	memset(t-&gt;t, 0, 16*256*GF128MUL_BYTES);
+	for (i = 0; i &lt; GF128MUL_BYTES; ++i) {
+        	if (!i) {
+			b128ops_mov(t-&gt;t[0][128], g);
+			for (j = 64; j &gt; 0; j &gt;&gt;= 1) {
+				gf128mul_x_lle(t-&gt;t[0][j], t-&gt;t[0][j + j]);
+			}
+        	} else for (j = 128; j &gt; 0; j &gt;&gt;= 1) {
+			b128ops_mov(t-&gt;t[i][j], t-&gt;t[i - 1][j]);
+			gf128mul_x8_lle(t-&gt;t[i][j]);
+		}
+
+		for (j = 2; j &lt; 256; j += j) for(k = 1; k &lt; j; ++k) {
+			t-&gt;t[i][j+k][0] = t-&gt;t[i][j][0]^t-&gt;t[i][k][0];
+			t-&gt;t[i][j+k][1] = t-&gt;t[i][j][1]^t-&gt;t[i][k][1];
+		}
+	}
+}
+EXPORT_SYMBOL(gf128mul_init_64k_lle);
+
+void gf128mul_init_64k_bbe(struct gf128mul_64k *t, const u64 *g)
+{
+	int i, j, k;
+
+	memset(t-&gt;t, 0, 16*256*GF128MUL_BYTES);
+	for (i = 0; i &lt; GF128MUL_BYTES; ++i) {
+        	if (!i) {
+			b128ops_mov(t-&gt;t[0][1], g);
+			for (j = 1; j &lt;= 64; j &lt;&lt;= 1) {
+				gf128mul_x_bbe(t-&gt;t[0][j + j], t-&gt;t[0][j]);
+			}
+        	} else for (j = 128; j &gt; 0; j &gt;&gt;= 1) {
+			b128ops_mov(t-&gt;t[i][j], t-&gt;t[i - 1][j]);
+			gf128mul_x8_bbe(t-&gt;t[i][j]);
+		}
+
+		for (j = 2; j &lt; 256; j += j) for(k = 1; k &lt; j; ++k) {
+			t-&gt;t[i][j+k][0] = t-&gt;t[i][j][0]^t-&gt;t[i][k][0];
+			t-&gt;t[i][j+k][1] = t-&gt;t[i][j][1]^t-&gt;t[i][k][1];
+		}
+	}
+}
+EXPORT_SYMBOL(gf128mul_init_64k_bbe);
+
+void gf128mul_64k_lle(u64 a[], struct gf128mul_64k *t, u64 *r)
+{
+        int i;
+        b128ops_mov(r, t-&gt;t[0][((u8 *)a)[0]]);
+        for (i = 1; i &lt; GF128MUL_BYTES; ++i) {
+                b128ops_xor(r, t-&gt;t[i][((u8 *)a)[i]]);
+        }
+        b128ops_mov(a, r);
+}
+EXPORT_SYMBOL(gf128mul_64k_lle);
+
+void gf128mul_64k_bbe(u64 a[], struct gf128mul_64k *t, u64 *r)
+{
+        int i;
+        b128ops_mov(r, t-&gt;t[0][((u8 *)a)[15]]);
+        for (i = 1; i &lt; GF128MUL_BYTES; ++i) {
+                b128ops_xor(r, t-&gt;t[i][((u8 *)a)[15 - i]]);
+        }
+        b128ops_mov(a, r);
+}
+EXPORT_SYMBOL(gf128mul_64k_bbe);
+
+/*      This version uses 4k bytes of table space on the stack.
+    A 16 byte buffer has to be multiplied by a 16 byte key
+    value in GF(128).  If we consider a GF(128) value in a
+    single byte, we can construct a table of the 256 16 byte
+    values that result from the 256 values of this byte.
+    This requires 4096 bytes. If we take the highest byte in
+    the buffer and use this table to get the result, we then
+    have to multiply by x^120 to get the final value. For the
+    next highest byte the result has to be multiplied by x^112
+    and so on. But we can do this by accumulating the result
+    in an accumulator starting with the result for the top
+    byte.  We repeatedly multiply the accumulator value by
+    x^8 and then add in (i.e. xor) the 16 bytes of the next
+    lower byte in the buffer, stopping when we reach the
+    lowest byte. This requires a 4096 byte table.
+*/
+void gf128mul_init_4k_lle(struct gf128mul_4k *t, const u64 *g)
+{
+	int j, k;
+
+	memset(t, 0, 256*GF128MUL_BYTES);
+	b128ops_mov(t-&gt;t[128], g);
+	for (j = 64; j &gt; 0; j &gt;&gt;= 1) gf128mul_x_lle(t-&gt;t[j], t-&gt;t[j+j]);
+
+	for (j = 2; j &lt; 256; j += j) for (k = 1; k &lt; j; ++k) {
+		t-&gt;t[j + k][0] = t-&gt;t[j][0] ^ t-&gt;t[k][0];
+		t-&gt;t[j + k][1] = t-&gt;t[j][1] ^ t-&gt;t[k][1];
+        }
+}
+EXPORT_SYMBOL(gf128mul_init_4k_lle);
+
+void gf128mul_init_4k_bbe(struct gf128mul_4k *t, const u64 *g)
+{
+	int j, k;
+
+	memset(t, 0, 256*GF128MUL_BYTES);
+	b128ops_mov(t-&gt;t[1], g);
+	for (j = 1; j &lt;= 64; j &lt;&lt;= 1) gf128mul_x_bbe(t-&gt;t[j + j], t-&gt;t[j]);
+
+	for (j = 2; j &lt; 256; j += j) for (k = 1; k &lt; j; ++k) {
+		t-&gt;t[j + k][0] = t-&gt;t[j][0] ^ t-&gt;t[k][0];
+		t-&gt;t[j + k][1] = t-&gt;t[j][1] ^ t-&gt;t[k][1];
+        }
+}
+EXPORT_SYMBOL(gf128mul_init_4k_bbe);
+
+void gf128mul_4k_lle(u64 *a, struct gf128mul_4k *t, u64 *r)
+{
+        int i = 15;
+        b128ops_mov(r, t-&gt;t[((u8 *)a)[15]]);
+        while(i--) {
+		gf128mul_x8_lle(r);
+		b128ops_xor(r, t-&gt;t[((u8 *)a)[i]]);
+        }
+        b128ops_mov(a, r);
+}
+EXPORT_SYMBOL(gf128mul_4k_lle);
+
+void gf128mul_4k_bbe(u64 *a, struct gf128mul_4k *t, u64 *r)
+{
+        int i = 0;
+        b128ops_mov(r, t-&gt;t[((u8 *)a)[0]]);
+        while(++i &lt; 16) {
+		gf128mul_x8_bbe(r);
+		b128ops_xor(r, t-&gt;t[((u8 *)a)[i]]);
+        }
+        b128ops_mov(a, r);
+}
+EXPORT_SYMBOL(gf128mul_4k_bbe);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("functions for multiplying elements of GF(2^128)");
diff --git a/crypto/gf128mul.h b/crypto/gf128mul.h
new file mode 100644
index 0000000..83129df
--- /dev/null
+++ b/crypto/gf128mul.h
@@ -0,0 +1,196 @@
+/* gf128mul.h - GF(2^128) multiplication functions
+ *
+ * Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.
+ * Copyright (c) 2006 Rik Snel &lt;rsnel@cube.dyndns.org&gt;
+ *
+ * Based on Dr Brian Gladman's (GPL'd) work published at
+ * http://fp.gladman.plus.com/cryptography_technology/index.htm
+ * See the original copyright notice below.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+/*
+ ---------------------------------------------------------------------------
+ Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.   All rights reserved.
+
+ LICENSE TERMS
+
+ The free distribution and use of this software in both source and binary
+ form is allowed (with or without changes) provided that:
+
+   1. distributions of this source code include the above copyright
+      notice, this list of conditions and the following disclaimer;
+
+   2. distributions in binary form include the above copyright
+      notice, this list of conditions and the following disclaimer
+      in the documentation and/or other associated materials;
+
+   3. the copyright holder's name is not used to endorse products
+      built using this software without specific written permission.
+
+ ALTERNATIVELY, provided that this notice is retained in full, this product
+ may be distributed under the terms of the GNU General Public License (GPL),
+ in which case the provisions of the GPL apply INSTEAD OF those given above.
+
+ DISCLAIMER
+
+ This software is provided 'as is' with no explicit or implied warranties
+ in respect of its properties, including, but not limited to, correctness
+ and/or fitness for purpose.
+ ---------------------------------------------------------------------------
+ Issue Date: 31/01/2006
+
+ An implementation of field multiplication in Galois Field GF(128)
+*/
+
+#ifndef _LINUX_GF128MUL_H
+#define _LINUX_GF128MUL_H
+/* Comment by Rik:
+ *
+ * For some background on GF(2^128) see for example: http://-
+ * csrc.nist.gov/CryptoToolkit/modes/proposedmodes/gcm/gcm-revised-spec.pdf
+ *
+ * The elements of GF(2^128) := GF(2)[X]/(X^128-X^7-X^2-X^1-1) can
+ * be mapped to computer memory in a variety of ways. Let's examine
+ * three common cases.
+ *
+ * Take a look at the 16 binary octets below in memory order. The msb's
+ * are left and the lsb's are right. char b[16] is an array and b[0] is
+ * the first octet.
+ *
+ * 80000000 00000000 00000000 00000000 .... 00000000 00000000 00000000
+ *   b[0]     b[1]     b[2]     b[3]          b[13]    b[14]    b[15]
+ *
+ * Every bit is a coefficient of some power of X. We can store the bits
+ * in every byte in little-endian order and the bytes themselves also in
+ * little endian order. I will call this lle (little-little-endian).
+ * The above buffer represents the polynomial 1, and X^7+X^2+X^1+1 looks
+ * like 11100001 00000000 .... 00000000 = { 0xE1, 0x00, }.
+ * This format was originally implemented in gf128mul and is used
+ * in GCM (Galois/Counter mode) and in ABL (Arbitrary Block Length).
+ *
+ * Another convention says: store the bits in bigendian order and the
+ * bytes also. This is bbe (big-big-endian). Now the buffer above
+ * represents X^127. X^7+X^2+X^1+1 looks like 00000000 .... 10000111,
+ * b[15] = 0x87 and the rest is 0. LRW uses this convention and bbe
+ * is partly implemented.
+ *
+ * Both of the above formats are easy to implement on big-endian
+ * machines.
+ *
+ * EME (which is patent encumbered) uses the ble format (bits are stored
+ * in big endian order and the bytes in little endian). The above buffer
+ * represents X^7 in this case and the primitive polynomial is b[0] = 0x87.
+ *
+ * The common machine word-size is smaller than 128 bits, so to make
+ * an efficient implementation we must split into machine word sizes.
+ * This file uses one 32bit for the moment. Machine endianness comes into
+ * play. The lle format in relation to machine endianness is discusses
+ * below by the original author of gf128mul Dr Brian Gladman.
+ *
+ * Let's look at the bbe and ble format on a little endian machine.
+ *
+ * bbe on a little endian machine u32 x[4]:
+ *
+ *  MS            x[0]           LS  MS            x[1]		  LS
+ *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+ *  103..96 111.104 119.112 127.120  71...64 79...72 87...80 95...88
+ *
+ *  MS            x[2]           LS  MS            x[3]		  LS
+ *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+ *  39...32 47...40 55...48 63...56  07...00 15...08 23...16 31...24
+ *
+ * ble on a little endian machine
+ *
+ *  MS            x[0]           LS  MS            x[1]		  LS
+ *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+ *  31...24 23...16 15...08 07...00  63...56 55...48 47...40 39...32
+ *
+ *  MS            x[2]           LS  MS            x[3]		  LS
+ *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+ *  95...88 87...80 79...72 71...64  127.120 199.112 111.104 103..96
+ *
+ * Multiplications in GF(2^128) are mostly bit-shifts, so you see why
+ * ble (and lbe also) are easier to implement on a little-endian
+ * machine than om a big-endian machine. The converse holds for bbe
+ * and lle.
+ *
+ * Note: to have good alignment, it seems to me that it is sufficient
+ * to keep elements of GF(2^128) in type u64[2]. On 32-bit wordsize
+ * machines this will automatically aligned to wordsize and on a 64-bit
+ * machine also.
+ */
+/*	Multiply a GF128 field element by x. Field elements are held in arrays
+    of bytes in which field bits 8n..8n + 7 are held in byte[n], with lower
+    indexed bits placed in the more numerically significant bit positions
+    within bytes.
+
+    On little endian machines the bit indexes translate into the bit
+    positions within four 32-bit words in the following way
+
+    MS            x[0]           LS  MS            x[1]		  LS
+    ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+    24...31 16...23 08...15 00...07  56...63 48...55 40...47 32...39
+
+    MS            x[2]           LS  MS            x[3]		  LS
+    ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+    88...95 80...87 72...79 64...71  120.127 112.119 104.111 96..103
+
+    On big endian machines the bit indexes translate into the bit
+    positions within four 32-bit words in the following way
+
+    MS            x[0]           LS  MS            x[1]		  LS
+    ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+    00...07 08...15 16...23 24...31  32...39 40...47 48...55 56...63
+
+    MS            x[2]           LS  MS            x[3]		  LS
+    ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+    64...71 72...79 80...87 88...95  96..103 104.111 112.119 120.127
+*/
+
+#define GF128MUL_BYTES	16
+
+/*	A slow generic version of gf_mul, implemented for lle and bbe
+ * 	It multiplies a and b and puts the result in a */
+void gf128mul_lle(u64 *a, const u64 *b);
+
+void gf128mul_bbe(u64 *a, const u64 *b);
+
+
+/* 64k table optimization, implemented for lle and bbe */
+
+struct gf128mul_64k {
+	u64 t[16][256][GF128MUL_BYTES &gt;&gt; 3];
+};
+
+/* first initialize with the constant factor with which you
+ * want to multiply and then call gf128_64k_lle with the other
+ * factor in the first argument, the table in the second and a
+ * scratch register in the third. Afterwards *a = *r. */
+void gf128mul_init_64k_lle(struct gf128mul_64k *t, const u64 *g);
+
+void gf128mul_init_64k_bbe(struct gf128mul_64k *t, const u64 *g);
+
+void gf128mul_64k_lle(u64 *a, struct gf128mul_64k *t, u64 *r);
+
+void gf128mul_64k_bbe(u64 *a, struct gf128mul_64k *t, u64 *r);
+
+
+/* 4k table optimization */
+
+struct gf128mul_4k {
+	u64 t[256][GF128MUL_BYTES &gt;&gt; 3];
+};
+
+void gf128mul_init_4k_lle(struct gf128mul_4k *t, const u64 *g);
+
+void gf128mul_init_4k_bbe(struct gf128mul_4k *t, const u64 *g);
+
+void gf128mul_4k_lle(u64 *a, struct gf128mul_4k *t, u64 *r);
+
+void gf128mul_4k_bbe(u64 *a, struct gf128mul_4k *t, u64 *r);
+
+#endif /* _LINUX_GF128MUL_H */
-- 
1.4.1.1


-- 
VGER BF report: U 0.5
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061126235607</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-11-26 23:56:07-0400</timestampReceived><subject>Re: [PATCHv2 4/6] crypto: table driven multiplications in GF(2^128), needed by LRW (and in the futur</subject><body>

On Sat, Sep 02, 2006 at 03:00:25AM +0200, rsnel@cube.dyndns.org wrote:
&gt;
&gt; +#define M80X	0x8080808080808080LLU
&gt; +#define M01X	0x0101010101010101LLU
&gt; +
&gt; +static void gf128mul_x_lle(u64 r[2], const u64 x[2])
&gt; +{
&gt; +	u64  _tt = gf128mul_table_lle[(x[1] &gt;&gt; 49) &amp; 0x80];
&gt; +	r[1] =  ((x[1] &gt;&gt; 1) &amp; ~M80X) | (((x[1] &lt;&lt; 15) | (x[0] &gt;&gt; 49)) &amp; M80X);
&gt; +	r[0] = (((x[0] &gt;&gt; 1) &amp; ~M80X) |  ((x[0] &lt;&lt; 15) &amp; M80X)) ^ _tt;
&gt; +}

Hi Rik:

Sorry it took so long.  But I've been trying to modify the code so
that the same source is used for both BE and LE machines.  I've
finally accumulated enough time to finish it.

Unfortunately it seems that the end result doesn't quite agree with
your test vectors :) In particular, the LE version of your mul_x and
mul_x8 functions don't agree with mine.

Could you please compare the two versions and double-check them?
I'm unsure why 15 was used above as a shift count.  It would seem
that 7 would seem to make more sense as endianness is byte-based
not word-based.

I've attached my version of gf128mul which is based on your BE
code.

The other main change I've made is to remove the need to
allocate a contiguous 64K table in gf128mul.  Requiring every
tfm to allocate a contiguous 64K chunk of memory is not realistic
on Linux.

I also added a be128/le128/u128 type to make 128-bit operations
easier.

Thanks,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--

0c3bbb342495d510631b11c45a70d55fc83afe3f
diff --git a/crypto/Kconfig b/crypto/Kconfig
index 34f10d5..0a4ff51 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -139,6 +139,16 @@ config CRYPTO_TGR192
 	  See also:
 	  &lt;http://www.cs.technion.ac.il/~biham/Reports/Tiger/&gt;.
 
+config CRYPTO_GF128MUL
+	tristate "GF(2^128) multiplication functions (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	help
+	  Efficient table driven implementation of multiplications in the
+	  field GF(2^128).  This is needed by some cypher modes. This
+	  option will be selected automatically if you select such a
+	  cipher mode.  Only select this option by hand if you expect to load
+	  an external module that requires these functions.
+
 config CRYPTO_ECB
 	tristate "ECB support"
 	select CRYPTO_BLKCIPHER
diff --git a/crypto/Makefile b/crypto/Makefile
index e94bb1b..76970de 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -24,6 +24,7 @@ obj-$(CONFIG_CRYPTO_SHA256) += sha256.o
 obj-$(CONFIG_CRYPTO_SHA512) += sha512.o
 obj-$(CONFIG_CRYPTO_WP512) += wp512.o
 obj-$(CONFIG_CRYPTO_TGR192) += tgr192.o
+obj-$(CONFIG_CRYPTO_GF128MUL) += gf128mul.o
 obj-$(CONFIG_CRYPTO_ECB) += ecb.o
 obj-$(CONFIG_CRYPTO_CBC) += cbc.o
 obj-$(CONFIG_CRYPTO_DES) += des.o
diff --git a/crypto/gf128mul.c b/crypto/gf128mul.c
new file mode 100644
index 0000000..868366a
--- /dev/null
+++ b/crypto/gf128mul.c
@@ -0,0 +1,466 @@
+/* gf128mul.c - GF(2^128) multiplication functions
+ *
+ * Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.
+ * Copyright (c) 2006, Rik Snel &lt;rsnel@cube.dyndns.org&gt;
+ *
+ * Based on Dr Brian Gladman's (GPL'd) work published at
+ * http://fp.gladman.plus.com/cryptography_technology/index.htm
+ * See the original copyright notice below.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+/*
+ ---------------------------------------------------------------------------
+ Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.   All rights reserved.
+
+ LICENSE TERMS
+
+ The free distribution and use of this software in both source and binary
+ form is allowed (with or without changes) provided that:
+
+   1. distributions of this source code include the above copyright
+      notice, this list of conditions and the following disclaimer;
+
+   2. distributions in binary form include the above copyright
+      notice, this list of conditions and the following disclaimer
+      in the documentation and/or other associated materials;
+
+   3. the copyright holder's name is not used to endorse products
+      built using this software without specific written permission.
+
+ ALTERNATIVELY, provided that this notice is retained in full, this product
+ may be distributed under the terms of the GNU General Public License (GPL),
+ in which case the provisions of the GPL apply INSTEAD OF those given above.
+
+ DISCLAIMER
+
+ This software is provided 'as is' with no explicit or implied warranties
+ in respect of its properties, including, but not limited to, correctness
+ and/or fitness for purpose.
+ ---------------------------------------------------------------------------
+ Issue 31/01/2006
+
+ This file provides fast multiplication in GF(128) as required by several
+ cryptographic authentication modes
+*/
+
+#include &lt;crypto/gf128mul.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/slab.h&gt;
+
+#define gf128mul_dat(q) { \
+	q(0x00), q(0x01), q(0x02), q(0x03), q(0x04), q(0x05), q(0x06), q(0x07),\
+	q(0x08), q(0x09), q(0x0a), q(0x0b), q(0x0c), q(0x0d), q(0x0e), q(0x0f),\
+	q(0x10), q(0x11), q(0x12), q(0x13), q(0x14), q(0x15), q(0x16), q(0x17),\
+	q(0x18), q(0x19), q(0x1a), q(0x1b), q(0x1c), q(0x1d), q(0x1e), q(0x1f),\
+	q(0x20), q(0x21), q(0x22), q(0x23), q(0x24), q(0x25), q(0x26), q(0x27),\
+	q(0x28), q(0x29), q(0x2a), q(0x2b), q(0x2c), q(0x2d), q(0x2e), q(0x2f),\
+	q(0x30), q(0x31), q(0x32), q(0x33), q(0x34), q(0x35), q(0x36), q(0x37),\
+	q(0x38), q(0x39), q(0x3a), q(0x3b), q(0x3c), q(0x3d), q(0x3e), q(0x3f),\
+	q(0x40), q(0x41), q(0x42), q(0x43), q(0x44), q(0x45), q(0x46), q(0x47),\
+	q(0x48), q(0x49), q(0x4a), q(0x4b), q(0x4c), q(0x4d), q(0x4e), q(0x4f),\
+	q(0x50), q(0x51), q(0x52), q(0x53), q(0x54), q(0x55), q(0x56), q(0x57),\
+	q(0x58), q(0x59), q(0x5a), q(0x5b), q(0x5c), q(0x5d), q(0x5e), q(0x5f),\
+	q(0x60), q(0x61), q(0x62), q(0x63), q(0x64), q(0x65), q(0x66), q(0x67),\
+	q(0x68), q(0x69), q(0x6a), q(0x6b), q(0x6c), q(0x6d), q(0x6e), q(0x6f),\
+	q(0x70), q(0x71), q(0x72), q(0x73), q(0x74), q(0x75), q(0x76), q(0x77),\
+	q(0x78), q(0x79), q(0x7a), q(0x7b), q(0x7c), q(0x7d), q(0x7e), q(0x7f),\
+	q(0x80), q(0x81), q(0x82), q(0x83), q(0x84), q(0x85), q(0x86), q(0x87),\
+	q(0x88), q(0x89), q(0x8a), q(0x8b), q(0x8c), q(0x8d), q(0x8e), q(0x8f),\
+	q(0x90), q(0x91), q(0x92), q(0x93), q(0x94), q(0x95), q(0x96), q(0x97),\
+	q(0x98), q(0x99), q(0x9a), q(0x9b), q(0x9c), q(0x9d), q(0x9e), q(0x9f),\
+	q(0xa0), q(0xa1), q(0xa2), q(0xa3), q(0xa4), q(0xa5), q(0xa6), q(0xa7),\
+	q(0xa8), q(0xa9), q(0xaa), q(0xab), q(0xac), q(0xad), q(0xae), q(0xaf),\
+	q(0xb0), q(0xb1), q(0xb2), q(0xb3), q(0xb4), q(0xb5), q(0xb6), q(0xb7),\
+	q(0xb8), q(0xb9), q(0xba), q(0xbb), q(0xbc), q(0xbd), q(0xbe), q(0xbf),\
+	q(0xc0), q(0xc1), q(0xc2), q(0xc3), q(0xc4), q(0xc5), q(0xc6), q(0xc7),\
+	q(0xc8), q(0xc9), q(0xca), q(0xcb), q(0xcc), q(0xcd), q(0xce), q(0xcf),\
+	q(0xd0), q(0xd1), q(0xd2), q(0xd3), q(0xd4), q(0xd5), q(0xd6), q(0xd7),\
+	q(0xd8), q(0xd9), q(0xda), q(0xdb), q(0xdc), q(0xdd), q(0xde), q(0xdf),\
+	q(0xe0), q(0xe1), q(0xe2), q(0xe3), q(0xe4), q(0xe5), q(0xe6), q(0xe7),\
+	q(0xe8), q(0xe9), q(0xea), q(0xeb), q(0xec), q(0xed), q(0xee), q(0xef),\
+	q(0xf0), q(0xf1), q(0xf2), q(0xf3), q(0xf4), q(0xf5), q(0xf6), q(0xf7),\
+	q(0xf8), q(0xf9), q(0xfa), q(0xfb), q(0xfc), q(0xfd), q(0xfe), q(0xff) \
+}
+
+/*	Given the value i in 0..255 as the byte overflow when a field element
+    in GHASH is multipled by x^8, this function will return the values that
+    are generated in the lo 16-bit word of the field value by applying the
+    modular polynomial. The values lo_byte and hi_byte are returned via the
+    macro xp_fun(lo_byte, hi_byte) so that the values can be assembled into
+    memory as required by a suitable definition of this macro operating on
+    the table above
+*/
+
+#define xx(p, q)	__constant_be16_to_cpu(0x##p##q)
+
+#define xda_bbe(i) ( \
+	(i &amp; 0x80 ? xx(43, 80) : 0) ^ (i &amp; 0x40 ? xx(21, c0) : 0) ^ \
+	(i &amp; 0x20 ? xx(10, e0) : 0) ^ (i &amp; 0x10 ? xx(08, 70) : 0) ^ \
+	(i &amp; 0x08 ? xx(04, 38) : 0) ^ (i &amp; 0x04 ? xx(02, 1c) : 0) ^ \
+	(i &amp; 0x02 ? xx(01, 0e) : 0) ^ (i &amp; 0x01 ? xx(00, 87) : 0) \
+)
+
+#define xda_lle(i) ( \
+	(i &amp; 0x80 ? xx(e1, 00) : 0) ^ (i &amp; 0x40 ? xx(70, 80) : 0) ^ \
+	(i &amp; 0x20 ? xx(38, 40) : 0) ^ (i &amp; 0x10 ? xx(1c, 20) : 0) ^ \
+	(i &amp; 0x08 ? xx(0e, 10) : 0) ^ (i &amp; 0x04 ? xx(07, 08) : 0) ^ \
+	(i &amp; 0x02 ? xx(03, 84) : 0) ^ (i &amp; 0x01 ? xx(01, c2) : 0) \
+)
+
+static const u16 gf128mul_table_lle[256] = gf128mul_dat(xda_lle);
+static const u16 gf128mul_table_bbe[256] = gf128mul_dat(xda_bbe);
+
+/* These functions multiply a field element by x, by x^4 and by x^8
+ * in the polynomial field representation. It uses 32-bit word operations
+ * to gain speed but compensates for machine endianess and hence works
+ * correctly on both styles of machine.
+ */
+
+static void gf128mul_x_lle(be128 *r, const be128 *x)
+{
+	u64 a = be64_to_cpu(x-&gt;a);
+	u64 b = be64_to_cpu(x-&gt;b);
+	u64 _tt = gf128mul_table_lle[(b &lt;&lt; 7) &amp; 0xff];
+
+	r-&gt;b = cpu_to_be64((b &gt;&gt; 1) | (a &lt;&lt; 63));
+	r-&gt;a = cpu_to_be64((a &gt;&gt; 1) ^ (_tt &lt;&lt; 48));
+}
+
+static void gf128mul_x_bbe(be128 *r, const be128 *x)
+{
+	u64 a = be64_to_cpu(x-&gt;a);
+	u64 b = be64_to_cpu(x-&gt;b);
+	u64 _tt = gf128mul_table_bbe[a &gt;&gt; 63];
+
+	r-&gt;a = cpu_to_be64((a &lt;&lt; 1) | (b &gt;&gt; 63));
+	r-&gt;b = cpu_to_be64((b &lt;&lt; 1) ^ _tt);
+}
+
+static void gf128mul_x8_lle(be128 *x)
+{
+	u64 a = be64_to_cpu(x-&gt;a);
+	u64 b = be64_to_cpu(x-&gt;b);
+	u64 _tt = gf128mul_table_lle[b &amp; 0xff];
+
+	x-&gt;b = cpu_to_be64((b &gt;&gt; 8) | (a &lt;&lt; 56));
+	x-&gt;a = cpu_to_be64((a &gt;&gt; 8) ^ (_tt &lt;&lt; 48));
+}
+
+static void gf128mul_x8_bbe(be128 *x)
+{
+	u64 a = be64_to_cpu(x-&gt;a);
+	u64 b = be64_to_cpu(x-&gt;b);
+	u64 _tt = gf128mul_table_bbe[a &gt;&gt; 56];
+
+	x-&gt;a = cpu_to_be64((a &lt;&lt; 8) | (b &gt;&gt; 56));
+	x-&gt;b = cpu_to_be64((b &lt;&lt; 8) ^ _tt);
+}
+
+void gf128mul_lle(be128 *r, const be128 *b)
+{
+	be128 p[8];
+	int i;
+
+	p[0] = *r;
+	for (i = 0; i &lt; 7; ++i)
+		gf128mul_x_lle(&amp;p[i + 1], &amp;p[i]);
+
+	memset(r, 0, sizeof(r));
+	for (i = 0;;) {
+		u8 ch = ((u8 *)b)[15 - i];
+
+		if (ch &amp; 0x80)
+			be128_xor(r, r, &amp;p[0]);
+		if (ch &amp; 0x40)
+			be128_xor(r, r, &amp;p[1]);
+		if (ch &amp; 0x20)
+			be128_xor(r, r, &amp;p[2]);
+		if (ch &amp; 0x10)
+			be128_xor(r, r, &amp;p[3]);
+		if (ch &amp; 0x08)
+			be128_xor(r, r, &amp;p[4]);
+		if (ch &amp; 0x04)
+			be128_xor(r, r, &amp;p[5]);
+		if (ch &amp; 0x02)
+			be128_xor(r, r, &amp;p[6]);
+		if (ch &amp; 0x01)
+			be128_xor(r, r, &amp;p[7]);
+
+		if (++i &gt;= 16)
+			break;
+
+		gf128mul_x8_lle(r);
+	}
+}
+EXPORT_SYMBOL(gf128mul_lle);
+
+void gf128mul_bbe(be128 *r, const be128 *b)
+{
+	be128 p[8];
+	int i;
+
+	p[0] = *r;
+	for (i = 0; i &lt; 7; ++i)
+		gf128mul_x_bbe(&amp;p[i + 1], &amp;p[i]);
+
+	memset(r, 0, sizeof(r));
+	for (i = 0;;) {
+		u8 ch = ((u8 *)b)[i];
+
+		if (ch &amp; 0x80)
+			be128_xor(r, r, &amp;p[7]);
+		if (ch &amp; 0x40)
+			be128_xor(r, r, &amp;p[6]);
+		if (ch &amp; 0x20)
+			be128_xor(r, r, &amp;p[5]);
+		if (ch &amp; 0x10)
+			be128_xor(r, r, &amp;p[4]);
+		if (ch &amp; 0x08)
+			be128_xor(r, r, &amp;p[3]);
+		if (ch &amp; 0x04)
+			be128_xor(r, r, &amp;p[2]);
+		if (ch &amp; 0x02)
+			be128_xor(r, r, &amp;p[1]);
+		if (ch &amp; 0x01)
+			be128_xor(r, r, &amp;p[0]);
+
+		if (++i &gt;= 16)
+			break;
+
+		gf128mul_x8_bbe(r);
+	}
+}
+EXPORT_SYMBOL(gf128mul_bbe);
+
+/*      This version uses 64k bytes of table space.
+    A 16 byte buffer has to be multiplied by a 16 byte key
+    value in GF(128).  If we consider a GF(128) value in
+    the buffer's lowest byte, we can construct a table of
+    the 256 16 byte values that result from the 256 values
+    of this byte.  This requires 4096 bytes. But we also
+    need tables for each of the 16 higher bytes in the
+    buffer as well, which makes 64 kbytes in total.
+*/
+/* additional explanation
+ * t[0][BYTE] contains g*BYTE
+ * t[1][BYTE] contains g*x^8*BYTE
+ *  ..
+ * t[15][BYTE] contains g*x^120*BYTE */
+struct gf128mul_64k *gf128mul_init_64k_lle(const be128 *g)
+{
+	struct gf128mul_64k *t;
+	int i, j, k;
+
+	t = kzalloc(sizeof(*t), GFP_KERNEL);
+	if (!t)
+		goto out;
+
+	for (i = 0; i &lt; 16; i++) {
+		t-&gt;t[i] = kzalloc(sizeof(*t-&gt;t[i]), GFP_KERNEL);
+		if (!t-&gt;t[i]) {
+			gf128mul_free_64k(t);
+			t = NULL;
+			goto out;
+		}
+	}
+
+	t-&gt;t[0]-&gt;t[128] = *g;
+	for (j = 64; j &gt; 0; j &gt;&gt;= 1)
+		gf128mul_x_lle(&amp;t-&gt;t[0]-&gt;t[j], &amp;t-&gt;t[0]-&gt;t[j + j]);
+
+	for (i = 0;;) {
+		for (j = 2; j &lt; 256; j += j)
+			for (k = 1; k &lt; j; ++k)
+				be128_xor(&amp;t-&gt;t[i]-&gt;t[j + k],
+					  &amp;t-&gt;t[i]-&gt;t[j], &amp;t-&gt;t[i]-&gt;t[k]);
+
+		if (++i &gt;= 16)
+			break;
+
+		for (j = 128; j &gt; 0; j &gt;&gt;= 1) {
+			t-&gt;t[i]-&gt;t[j] = t-&gt;t[i - 1]-&gt;t[j];
+			gf128mul_x8_lle(&amp;t-&gt;t[i]-&gt;t[j]);
+		}
+	}
+
+out:
+	return t;
+}
+EXPORT_SYMBOL(gf128mul_init_64k_lle);
+
+struct gf128mul_64k *gf128mul_init_64k_bbe(const be128 *g)
+{
+	struct gf128mul_64k *t;
+	int i, j, k;
+
+	t = kzalloc(sizeof(*t), GFP_KERNEL);
+	if (!t)
+		goto out;
+
+	for (i = 0; i &lt; 16; i++) {
+		t-&gt;t[i] = kzalloc(sizeof(*t-&gt;t[i]), GFP_KERNEL);
+		if (!t-&gt;t[i]) {
+			gf128mul_free_64k(t);
+			t = NULL;
+			goto out;
+		}
+	}
+
+	t-&gt;t[0]-&gt;t[1] = *g;
+	for (j = 1; j &lt;= 64; j &lt;&lt;= 1)
+		gf128mul_x_bbe(&amp;t-&gt;t[0]-&gt;t[j + j], &amp;t-&gt;t[0]-&gt;t[j]);
+
+	for (i = 0;;) {
+		for (j = 2; j &lt; 256; j += j)
+			for (k = 1; k &lt; j; ++k)
+				be128_xor(&amp;t-&gt;t[i]-&gt;t[j + k],
+					  &amp;t-&gt;t[i]-&gt;t[j], &amp;t-&gt;t[i]-&gt;t[k]);
+
+		if (++i &gt;= 16)
+			break;
+
+		for (j = 128; j &gt; 0; j &gt;&gt;= 1) {
+			t-&gt;t[i]-&gt;t[j] = t-&gt;t[i - 1]-&gt;t[j];
+			gf128mul_x8_bbe(&amp;t-&gt;t[i]-&gt;t[j]);
+		}
+	}
+
+out:
+	return t;
+}
+EXPORT_SYMBOL(gf128mul_init_64k_bbe);
+
+void gf128mul_free_64k(struct gf128mul_64k *t)
+{
+	int i;
+
+	for (i = 0; i &lt; 16; i++)
+		kfree(t-&gt;t[i]);
+	kfree(t);
+}
+EXPORT_SYMBOL(gf128mul_free_64k);
+
+void gf128mul_64k_lle(be128 *a, struct gf128mul_64k *t)
+{
+	u8 *ap = (u8 *)a;
+	be128 r[1];
+	int i;
+
+	*r = t-&gt;t[0]-&gt;t[ap[0]];
+	for (i = 1; i &lt; 16; ++i)
+		be128_xor(r, r, &amp;t-&gt;t[i]-&gt;t[ap[i]]);
+	*a = *r;
+}
+EXPORT_SYMBOL(gf128mul_64k_lle);
+
+void gf128mul_64k_bbe(be128 *a, struct gf128mul_64k *t)
+{
+	u8 *ap = (u8 *)a;
+	be128 r[1];
+	int i;
+
+	*r = t-&gt;t[0]-&gt;t[ap[15]];
+	for (i = 1; i &lt; 16; ++i)
+		be128_xor(r, r, &amp;t-&gt;t[i]-&gt;t[ap[15 - i]]);
+	*a = *r;
+}
+EXPORT_SYMBOL(gf128mul_64k_bbe);
+
+/*      This version uses 4k bytes of table space.
+    A 16 byte buffer has to be multiplied by a 16 byte key
+    value in GF(128).  If we consider a GF(128) value in a
+    single byte, we can construct a table of the 256 16 byte
+    values that result from the 256 values of this byte.
+    This requires 4096 bytes. If we take the highest byte in
+    the buffer and use this table to get the result, we then
+    have to multiply by x^120 to get the final value. For the
+    next highest byte the result has to be multiplied by x^112
+    and so on. But we can do this by accumulating the result
+    in an accumulator starting with the result for the top
+    byte.  We repeatedly multiply the accumulator value by
+    x^8 and then add in (i.e. xor) the 16 bytes of the next
+    lower byte in the buffer, stopping when we reach the
+    lowest byte. This requires a 4096 byte table.
+*/
+struct gf128mul_4k *gf128mul_init_4k_lle(const be128 *g)
+{
+	struct gf128mul_4k *t;
+	int j, k;
+
+	t = kzalloc(sizeof(*t), GFP_KERNEL);
+	if (!t)
+		goto out;
+
+	t-&gt;t[128] = *g;
+	for (j = 64; j &gt; 0; j &gt;&gt;= 1)
+		gf128mul_x_lle(&amp;t-&gt;t[j], &amp;t-&gt;t[j+j]);
+
+	for (j = 2; j &lt; 256; j += j)
+		for (k = 1; k &lt; j; ++k)
+			be128_xor(&amp;t-&gt;t[j + k], &amp;t-&gt;t[j], &amp;t-&gt;t[k]);
+
+out:
+	return t;
+}
+EXPORT_SYMBOL(gf128mul_init_4k_lle);
+
+struct gf128mul_4k *gf128mul_init_4k_bbe(const be128 *g)
+{
+	struct gf128mul_4k *t;
+	int j, k;
+
+	t = kzalloc(sizeof(*t), GFP_KERNEL);
+	if (!t)
+		goto out;
+
+	t-&gt;t[1] = *g;
+	for (j = 1; j &lt;= 64; j &lt;&lt;= 1)
+		gf128mul_x_bbe(&amp;t-&gt;t[j + j], &amp;t-&gt;t[j]);
+
+	for (j = 2; j &lt; 256; j += j)
+		for (k = 1; k &lt; j; ++k)
+			be128_xor(&amp;t-&gt;t[j + k], &amp;t-&gt;t[j], &amp;t-&gt;t[k]);
+
+out:
+	return t;
+}
+EXPORT_SYMBOL(gf128mul_init_4k_bbe);
+
+void gf128mul_4k_lle(be128 *a, struct gf128mul_4k *t)
+{
+	u8 *ap = (u8 *)a;
+	be128 r[1];
+	int i = 15;
+
+	*r = t-&gt;t[ap[15]];
+	while (i--) {
+		gf128mul_x8_lle(r);
+		be128_xor(r, r, &amp;t-&gt;t[ap[i]]);
+	}
+	*a = *r;
+}
+EXPORT_SYMBOL(gf128mul_4k_lle);
+
+void gf128mul_4k_bbe(be128 *a, struct gf128mul_4k *t)
+{
+	u8 *ap = (u8 *)a;
+	be128 r[1];
+	int i = 0;
+
+	*r = t-&gt;t[ap[0]];
+	while (++i &lt; 16) {
+		gf128mul_x8_bbe(r);
+		be128_xor(r, r, &amp;t-&gt;t[ap[i]]);
+	}
+	*a = *r;
+}
+EXPORT_SYMBOL(gf128mul_4k_bbe);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Functions for multiplying elements of GF(2^128)");
diff --git a/include/crypto/gf128mul.h b/include/crypto/gf128mul.h
new file mode 100644
index 0000000..4fd3152
--- /dev/null
+++ b/include/crypto/gf128mul.h
@@ -0,0 +1,198 @@
+/* gf128mul.h - GF(2^128) multiplication functions
+ *
+ * Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.
+ * Copyright (c) 2006 Rik Snel &lt;rsnel@cube.dyndns.org&gt;
+ *
+ * Based on Dr Brian Gladman's (GPL'd) work published at
+ * http://fp.gladman.plus.com/cryptography_technology/index.htm
+ * See the original copyright notice below.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+/*
+ ---------------------------------------------------------------------------
+ Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.   All rights reserved.
+
+ LICENSE TERMS
+
+ The free distribution and use of this software in both source and binary
+ form is allowed (with or without changes) provided that:
+
+   1. distributions of this source code include the above copyright
+      notice, this list of conditions and the following disclaimer;
+
+   2. distributions in binary form include the above copyright
+      notice, this list of conditions and the following disclaimer
+      in the documentation and/or other associated materials;
+
+   3. the copyright holder's name is not used to endorse products
+      built using this software without specific written permission.
+
+ ALTERNATIVELY, provided that this notice is retained in full, this product
+ may be distributed under the terms of the GNU General Public License (GPL),
+ in which case the provisions of the GPL apply INSTEAD OF those given above.
+
+ DISCLAIMER
+
+ This software is provided 'as is' with no explicit or implied warranties
+ in respect of its properties, including, but not limited to, correctness
+ and/or fitness for purpose.
+ ---------------------------------------------------------------------------
+ Issue Date: 31/01/2006
+
+ An implementation of field multiplication in Galois Field GF(128)
+*/
+
+#ifndef _CRYPTO_GF128MUL_H
+#define _CRYPTO_GF128MUL_H
+
+#include &lt;crypto/b128ops.h&gt;
+#include &lt;linux/slab.h&gt;
+
+/* Comment by Rik:
+ *
+ * For some background on GF(2^128) see for example: http://-
+ * csrc.nist.gov/CryptoToolkit/modes/proposedmodes/gcm/gcm-revised-spec.pdf
+ *
+ * The elements of GF(2^128) := GF(2)[X]/(X^128-X^7-X^2-X^1-1) can
+ * be mapped to computer memory in a variety of ways. Let's examine
+ * three common cases.
+ *
+ * Take a look at the 16 binary octets below in memory order. The msb's
+ * are left and the lsb's are right. char b[16] is an array and b[0] is
+ * the first octet.
+ *
+ * 80000000 00000000 00000000 00000000 .... 00000000 00000000 00000000
+ *   b[0]     b[1]     b[2]     b[3]          b[13]    b[14]    b[15]
+ *
+ * Every bit is a coefficient of some power of X. We can store the bits
+ * in every byte in little-endian order and the bytes themselves also in
+ * little endian order. I will call this lle (little-little-endian).
+ * The above buffer represents the polynomial 1, and X^7+X^2+X^1+1 looks
+ * like 11100001 00000000 .... 00000000 = { 0xE1, 0x00, }.
+ * This format was originally implemented in gf128mul and is used
+ * in GCM (Galois/Counter mode) and in ABL (Arbitrary Block Length).
+ *
+ * Another convention says: store the bits in bigendian order and the
+ * bytes also. This is bbe (big-big-endian). Now the buffer above
+ * represents X^127. X^7+X^2+X^1+1 looks like 00000000 .... 10000111,
+ * b[15] = 0x87 and the rest is 0. LRW uses this convention and bbe
+ * is partly implemented.
+ *
+ * Both of the above formats are easy to implement on big-endian
+ * machines.
+ *
+ * EME (which is patent encumbered) uses the ble format (bits are stored
+ * in big endian order and the bytes in little endian). The above buffer
+ * represents X^7 in this case and the primitive polynomial is b[0] = 0x87.
+ *
+ * The common machine word-size is smaller than 128 bits, so to make
+ * an efficient implementation we must split into machine word sizes.
+ * This file uses one 32bit for the moment. Machine endianness comes into
+ * play. The lle format in relation to machine endianness is discussed
+ * below by the original author of gf128mul Dr Brian Gladman.
+ *
+ * Let's look at the bbe and ble format on a little endian machine.
+ *
+ * bbe on a little endian machine u32 x[4]:
+ *
+ *  MS            x[0]           LS  MS            x[1]		  LS
+ *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+ *  103..96 111.104 119.112 127.120  71...64 79...72 87...80 95...88
+ *
+ *  MS            x[2]           LS  MS            x[3]		  LS
+ *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+ *  39...32 47...40 55...48 63...56  07...00 15...08 23...16 31...24
+ *
+ * ble on a little endian machine
+ *
+ *  MS            x[0]           LS  MS            x[1]		  LS
+ *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+ *  31...24 23...16 15...08 07...00  63...56 55...48 47...40 39...32
+ *
+ *  MS            x[2]           LS  MS            x[3]		  LS
+ *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+ *  95...88 87...80 79...72 71...64  127.120 199.112 111.104 103..96
+ *
+ * Multiplications in GF(2^128) are mostly bit-shifts, so you see why
+ * ble (and lbe also) are easier to implement on a little-endian
+ * machine than on a big-endian machine. The converse holds for bbe
+ * and lle.
+ *
+ * Note: to have good alignment, it seems to me that it is sufficient
+ * to keep elements of GF(2^128) in type u64[2]. On 32-bit wordsize
+ * machines this will automatically aligned to wordsize and on a 64-bit
+ * machine also.
+ */
+/*	Multiply a GF128 field element by x. Field elements are held in arrays
+    of bytes in which field bits 8n..8n + 7 are held in byte[n], with lower
+    indexed bits placed in the more numerically significant bit positions
+    within bytes.
+
+    On little endian machines the bit indexes translate into the bit
+    positions within four 32-bit words in the following way
+
+    MS            x[0]           LS  MS            x[1]		  LS
+    ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+    24...31 16...23 08...15 00...07  56...63 48...55 40...47 32...39
+
+    MS            x[2]           LS  MS            x[3]		  LS
+    ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+    88...95 80...87 72...79 64...71  120.127 112.119 104.111 96..103
+
+    On big endian machines the bit indexes translate into the bit
+    positions within four 32-bit words in the following way
+
+    MS            x[0]           LS  MS            x[1]		  LS
+    ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+    00...07 08...15 16...23 24...31  32...39 40...47 48...55 56...63
+
+    MS            x[2]           LS  MS            x[3]		  LS
+    ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+    64...71 72...79 80...87 88...95  96..103 104.111 112.119 120.127
+*/
+
+/*	A slow generic version of gf_mul, implemented for lle and bbe
+ * 	It multiplies a and b and puts the result in a */
+void gf128mul_lle(be128 *a, const be128 *b);
+
+void gf128mul_bbe(be128 *a, const be128 *b);
+
+
+/* 4k table optimization */
+
+struct gf128mul_4k {
+	be128 t[256];
+};
+
+struct gf128mul_4k *gf128mul_init_4k_lle(const be128 *g);
+struct gf128mul_4k *gf128mul_init_4k_bbe(const be128 *g);
+void gf128mul_4k_lle(be128 *a, struct gf128mul_4k *t);
+void gf128mul_4k_bbe(be128 *a, struct gf128mul_4k *t);
+
+static inline void gf128mul_free_4k(struct gf128mul_4k *t)
+{
+	kfree(t);
+}
+
+
+/* 64k table optimization, implemented for lle and bbe */
+
+struct gf128mul_64k {
+	struct gf128mul_4k *t[16];
+};
+
+/* first initialize with the constant factor with which you
+ * want to multiply and then call gf128_64k_lle with the other
+ * factor in the first argument, the table in the second and a
+ * scratch register in the third. Afterwards *a = *r. */
+struct gf128mul_64k *gf128mul_init_64k_lle(const be128 *g);
+struct gf128mul_64k *gf128mul_init_64k_bbe(const be128 *g);
+void gf128mul_free_64k(struct gf128mul_64k *t);
+void gf128mul_64k_lle(be128 *a, struct gf128mul_64k *t);
+void gf128mul_64k_bbe(be128 *a, struct gf128mul_64k *t);
+
+#endif /* _CRYPTO_GF128MUL_H */
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061128200232</emailId><senderName></senderName><senderEmail>rsnel</senderEmail><timestampReceived>2006-11-28 20:02:32-0400</timestampReceived><subject>Re: [PATCHv2 4/6] crypto: table driven multiplications in GF(2^128), needed by LRW (and in the futur</subject><body>

Hello Herbert,

On Mon, Nov 27, 2006 at 10:56:07AM +1100, Herbert Xu wrote:
&gt; On Sat, Sep 02, 2006 at 03:00:25AM +0200, rsnel@cube.dyndns.org wrote:
&gt;
&gt; Sorry it took so long.  But I've been trying to modify the code so
&gt; that the same source is used for both BE and LE machines.  I've
&gt; finally accumulated enough time to finish it.

It's OK. The source will be more maintainable, but constantly converting
between big and little-endian (on little endian machines) may have a
significant performance impact (I will just test when your gf128 hits
cryptodev-2.6, and complain if it is the case).

Two more remarks (errors in v2 of my patch): b128ops.h and gf128mul.h
should be in include/ (so they can be used in modules) and the inline
functions in b128ops.h should also be static.

&gt; Unfortunately it seems that the end result doesn't quite agree with
&gt; your test vectors :) In particular, the LE version of your mul_x and
&gt; mul_x8 functions don't agree with mine.
&gt; 
&gt; Could you please compare the two versions and double-check them?
&gt; I'm unsure why 15 was used above as a shift count.  It would seem
&gt; that 7 would seem to make more sense as endianness is byte-based
&gt; not word-based.
&gt; &gt;
&gt; &gt; +#define M80X	0x8080808080808080LLU
&gt; &gt; +#define M01X	0x0101010101010101LLU
&gt; &gt; +
&gt; &gt; +static void gf128mul_x_lle(u64 r[2], const u64 x[2])
&gt; &gt; +{
&gt; &gt; +	u64  _tt = gf128mul_table_lle[(x[1] &gt;&gt; 49) &amp; 0x80];
&gt; &gt; +	r[1] =  ((x[1] &gt;&gt; 1) &amp; ~M80X) | (((x[1] &lt;&lt; 15) | (x[0] &gt;&gt; 49)) &amp; M80X);
&gt; &gt; +	r[0] = (((x[0] &gt;&gt; 1) &amp; ~M80X) |  ((x[0] &lt;&lt; 15) &amp; M80X)) ^ _tt;
&gt; &gt; +}

I'll try to explain why I think the above code is correct:
As in my comment in gf128mul.h, lle means the polynomials in gf127 are
stored in little-little-endian format. So 
10000000 00000000 .. 00000000 = 0x80 0x00 .. 0x00 = 1
01000000 00000000 .. 00000000 = 0x40 0x00 .. 0x00 = X^1
01010001 00000000 .. 10000000 = 0x51 0x00 .. 0x80 = X^1 + X^3 + X^7 + X^120
00000000 00000000 .. 00000001 = 0x00 0x00 .. 0x01 = X^127

The u64 type emulates a little endian 64bit processor (on my 32bit
intel) so when we load the these examples in two 64bit little endian
integers they are:
0x0000000000000080 0x0000000000000000 = 1
0x0000000000000040 0x0000000000000000 = X^1
0x0000000000000051 0x8000000000000000 = X^1 + X^3 + X^7 + X^120
0x0000000000000000 0x0100000000000000 = X^127

Let's multiply the third example by X, we should get
00101000 10000000 .. 01000000 = 0x28 0x80 .. 0x40 = X^2 + X^4 + X^8 + X^121

Represented as two little endian 64 bit values:
0x0000000000008028 0x4000000000000000

The above code implements this shift (efficiently?) by noting:
in each byte bit 1 moves to bit 0, bit 2 moves to bit 1, ..., bit 7
moves to bit 6 and all 7th bits are zeroed afterwards.
(this is done by ((x[1] &gt;&gt; 1) &amp; ~M80X)), the 7th bits are set by moving
the least significant bits of the bytes to the right position (15 bits
to the left) and orring.

Let's look at the example: the first 8 in 0x0...008028 comes from the
least significant bit of 0x00.00051. So the shift by 15 to get the 7th
bit of every byte right is correct. (I have included a simple program
to compare the different implementations)

&gt; I've attached my version of gf128mul which is based on your BE
&gt; code.

Ok, will comment.

&gt; The other main change I've made is to remove the need to
&gt; allocate a contiguous 64K table in gf128mul.  Requiring every
&gt; tfm to allocate a contiguous 64K chunk of memory is not realistic
&gt; on Linux.

Ok.

&gt; I also added a be128/le128/u128 type to make 128-bit operations
&gt; easier.

I assume it is: typedef struct { u64 a, u64 b } be128; 
As long as compilers don't do u128 natively it is just a matter of taste.

&gt; [...]
&gt; +#define xx(p, q)       __constant_be16_to_cpu(0x##p##q)

This seems to be the problem, the table is constructed wrongly. 
All the calculations take place as if we are on a big endian machine, so
the table entries should never be swapped, so the above line should read

+#define xx(p, q)       0x##p##q

While investigating the problem, I wrote a small program to compare
a bytewise implementation with Brian's and your implementation of mul_x,
it only works in the lle implementation.

Once I found this problem, I stopped looking, so let me know if the test
vectors still don't match up, then I will need to take a closer look.

Greetings,

Rik.

/* test program for mutiplying by X in GF(2^128) in lle representation
 * on a little endian machine. */
/* GNU GPL &gt;= v2 applies, (C) Brian Gladman, Herbert Xu, Rik Snel. */
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;byteswap.h&gt;

typedef uint64_t u64;
typedef uint16_t u16;
typedef struct {
	u64 a;
	u64 b;
} be128;

#define gf128mul_dat(q) { \
        q(0x00), q(0x01), q(0x02), q(0x03), q(0x04), q(0x05), q(0x06), q(0x07),\
        q(0x08), q(0x09), q(0x0a), q(0x0b), q(0x0c), q(0x0d), q(0x0e), q(0x0f),\
        q(0x10), q(0x11), q(0x12), q(0x13), q(0x14), q(0x15), q(0x16), q(0x17),\
        q(0x18), q(0x19), q(0x1a), q(0x1b), q(0x1c), q(0x1d), q(0x1e), q(0x1f),\
        q(0x20), q(0x21), q(0x22), q(0x23), q(0x24), q(0x25), q(0x26), q(0x27),\
        q(0x28), q(0x29), q(0x2a), q(0x2b), q(0x2c), q(0x2d), q(0x2e), q(0x2f),\
        q(0x30), q(0x31), q(0x32), q(0x33), q(0x34), q(0x35), q(0x36), q(0x37),\
        q(0x38), q(0x39), q(0x3a), q(0x3b), q(0x3c), q(0x3d), q(0x3e), q(0x3f),\
        q(0x40), q(0x41), q(0x42), q(0x43), q(0x44), q(0x45), q(0x46), q(0x47),\
        q(0x48), q(0x49), q(0x4a), q(0x4b), q(0x4c), q(0x4d), q(0x4e), q(0x4f),\
        q(0x50), q(0x51), q(0x52), q(0x53), q(0x54), q(0x55), q(0x56), q(0x57),\
        q(0x58), q(0x59), q(0x5a), q(0x5b), q(0x5c), q(0x5d), q(0x5e), q(0x5f),\
        q(0x60), q(0x61), q(0x62), q(0x63), q(0x64), q(0x65), q(0x66), q(0x67),\
        q(0x68), q(0x69), q(0x6a), q(0x6b), q(0x6c), q(0x6d), q(0x6e), q(0x6f),\
        q(0x70), q(0x71), q(0x72), q(0x73), q(0x74), q(0x75), q(0x76), q(0x77),\
        q(0x78), q(0x79), q(0x7a), q(0x7b), q(0x7c), q(0x7d), q(0x7e), q(0x7f),\
        q(0x80), q(0x81), q(0x82), q(0x83), q(0x84), q(0x85), q(0x86), q(0x87),\
        q(0x88), q(0x89), q(0x8a), q(0x8b), q(0x8c), q(0x8d), q(0x8e), q(0x8f),\
        q(0x90), q(0x91), q(0x92), q(0x93), q(0x94), q(0x95), q(0x96), q(0x97),\
        q(0x98), q(0x99), q(0x9a), q(0x9b), q(0x9c), q(0x9d), q(0x9e), q(0x9f),\
        q(0xa0), q(0xa1), q(0xa2), q(0xa3), q(0xa4), q(0xa5), q(0xa6), q(0xa7),\
        q(0xa8), q(0xa9), q(0xaa), q(0xab), q(0xac), q(0xad), q(0xae), q(0xaf),\
        q(0xb0), q(0xb1), q(0xb2), q(0xb3), q(0xb4), q(0xb5), q(0xb6), q(0xb7),\
        q(0xb8), q(0xb9), q(0xba), q(0xbb), q(0xbc), q(0xbd), q(0xbe), q(0xbf),\
        q(0xc0), q(0xc1), q(0xc2), q(0xc3), q(0xc4), q(0xc5), q(0xc6), q(0xc7),\
        q(0xc8), q(0xc9), q(0xca), q(0xcb), q(0xcc), q(0xcd), q(0xce), q(0xcf),\
        q(0xd0), q(0xd1), q(0xd2), q(0xd3), q(0xd4), q(0xd5), q(0xd6), q(0xd7),\
        q(0xd8), q(0xd9), q(0xda), q(0xdb), q(0xdc), q(0xdd), q(0xde), q(0xdf),\
        q(0xe0), q(0xe1), q(0xe2), q(0xe3), q(0xe4), q(0xe5), q(0xe6), q(0xe7),\
        q(0xe8), q(0xe9), q(0xea), q(0xeb), q(0xec), q(0xed), q(0xee), q(0xef),\
        q(0xf0), q(0xf1), q(0xf2), q(0xf3), q(0xf4), q(0xf5), q(0xf6), q(0xf7),\
        q(0xf8), q(0xf9), q(0xfa), q(0xfb), q(0xfc), q(0xfd), q(0xfe), q(0xff) \
}

#define xxle(p,q) 0x##q##p        /* assemble in little endian order */
#define xxbe(p,q) 0x##p##q        /* assemble in big endian order */

#define xda_lle_le(i) ( \
    (i&amp;0x80?xxle(e1,00):0)^(i&amp;0x40?xxle(70,80):0)^ \
    (i&amp;0x20?xxle(38,40):0)^(i&amp;0x10?xxle(1c,20):0)^ \
    (i&amp;0x08?xxle(0e,10):0)^(i&amp;0x04?xxle(07,08):0)^ \
    (i&amp;0x02?xxle(03,84):0)^(i&amp;0x01?xxle(01,c2):0) \
)

#define xda_lle_be(i) ( \
    (i&amp;0x80?xxbe(e1,00):0)^(i&amp;0x40?xxbe(70,80):0)^ \
    (i&amp;0x20?xxbe(38,40):0)^(i&amp;0x10?xxbe(1c,20):0)^ \
    (i&amp;0x08?xxbe(0e,10):0)^(i&amp;0x04?xxbe(07,08):0)^ \
    (i&amp;0x02?xxbe(03,84):0)^(i&amp;0x01?xxbe(01,c2):0) \
)

static const u16 gf128mul_table_lle_le[256] = gf128mul_dat(xda_lle_le);
static const u16 gf128mul_table_lle_be[256] = gf128mul_dat(xda_lle_be);

/* simple straightforward implementation, does not depend
 * on machine endianness */
void mul_x_lle_simple(be128 *result, const be128 *ex) {
	unsigned char *r = (unsigned char*)result;
	const unsigned char *x = (unsigned char*)ex;
	u64 overflow = 0xE1*(x[15]&amp;0x01); /* do we get X^128 ? */
	r[15] = x[15]&gt;&gt;1|x[14]&lt;&lt;7;
	r[14] = x[14]&gt;&gt;1|x[13]&lt;&lt;7;
	r[13] = x[13]&gt;&gt;1|x[12]&lt;&lt;7;
	r[12] = x[12]&gt;&gt;1|x[11]&lt;&lt;7;
	r[11] = x[11]&gt;&gt;1|x[10]&lt;&lt;7;
	r[10] = x[10]&gt;&gt;1|x[9]&lt;&lt;7;
	r[9] = x[9]&gt;&gt;1|x[8]&lt;&lt;7;
	r[8] = x[8]&gt;&gt;1|x[7]&lt;&lt;7;
	r[7] = x[7]&gt;&gt;1|x[6]&lt;&lt;7;
	r[6] = x[6]&gt;&gt;1|x[5]&lt;&lt;7;
	r[5] = x[5]&gt;&gt;1|x[4]&lt;&lt;7;
	r[4] = x[4]&gt;&gt;1|x[3]&lt;&lt;7;
	r[3] = x[3]&gt;&gt;1|x[2]&lt;&lt;7;
	r[2] = x[2]&gt;&gt;1|x[1]&lt;&lt;7;
	r[1] = x[1]&gt;&gt;1|x[0]&lt;&lt;7;
	r[0] = x[0]&gt;&gt;1|overflow;
}

/* for use on little endian machines; remove bswap_64's for usage
 * on bigendian machines */
void mul_x_lle_herbert(be128 *r, const be128 *x) {
	u64 a = bswap_64(x-&gt;a);
	u64 b = bswap_64(x-&gt;b);
	u64 _tt = gf128mul_table_lle_be[(b &lt;&lt; 7) &amp; 0xff];

	r-&gt;b = bswap_64((b &gt;&gt; 1) | (a &lt;&lt; 63));
	r-&gt;a = bswap_64((a &gt;&gt; 1) ^ (_tt &lt;&lt; 48));
}

/* works on little endian machines, use above version without bswap_64's
 * on big endian machines, should be faster than the above version
 * on little endian machines */
#define M80X       0x8080808080808080LLU
void mul_x_lle_brian(be128 *r, const be128 *x) {
	u64  _tt = gf128mul_table_lle_le[(x-&gt;b &gt;&gt; 49) &amp; 0x80];
	r-&gt;b =  ((x-&gt;b &gt;&gt; 1) &amp; ~M80X) | (((x-&gt;b &lt;&lt; 15) | (x-&gt;a &gt;&gt; 49)) &amp; M80X);
	r-&gt;a = (((x-&gt;a &gt;&gt; 1) &amp; ~M80X) |  ((x-&gt;a &lt;&lt; 15) &amp; M80X)) ^ _tt;
}

void debug(char *name, be128 *ex) {
	int i;
	unsigned char *x = (unsigned char*)ex;
	for (i = 0; i &lt; 16; i++)
		printf("%02x ", x[i]);
	printf("%s\n", name);
}

int main(int argc, char **argv) {
	assert(sizeof(be128) == 128/8);
	char V[16] = {
		//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0,
		0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0,
	};
	char R[16];
	debug("V", (be128*)V);
	mul_x_lle_simple((be128*)R, (be128*)V);
	debug("XV_simple", (be128*)R);
	mul_x_lle_herbert((be128*)R, (be128*)V);
	debug("XV_herbert", (be128*)R);
	mul_x_lle_brian((be128*)R, (be128*)V);
	debug("XV_brian", (be128*)R);
	exit(0);
}

-- 
Nothing is ever a total loss; it can always serve as a bad example.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061128211340</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-11-28 21:13:40-0400</timestampReceived><subject>Re: [PATCHv2 4/6] crypto: table driven multiplications in GF(2^128), needed by LRW (and in the futur</subject><body>

Hi Rik:

rsnel@cube.dyndns.org wrote:
&gt; 
&gt; It's OK. The source will be more maintainable, but constantly converting
&gt; between big and little-endian (on little endian machines) may have a
&gt; significant performance impact (I will just test when your gf128 hits
&gt; cryptodev-2.6, and complain if it is the case).

BTW, the tcrypt speed test for lrw doesn't work for me.

&gt; Two more remarks (errors in v2 of my patch): b128ops.h and gf128mul.h
&gt; should be in include/ (so they can be used in modules) and the inline
&gt; functions in b128ops.h should also be static.

Yep they're in include/crypto with all the functions being static inline.
 
&gt; This seems to be the problem, the table is constructed wrongly. 
&gt; All the calculations take place as if we are on a big endian machine, so
&gt; the table entries should never be swapped, so the above line should read
&gt; 
&gt; +#define xx(p, q)       0x##p##q

Yes you're quite right.  That was the problem.  I'll push this into mm
as soon as I get the speed tests fixed.

Thanks!
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061128211739</emailId><senderName></senderName><senderEmail>rsnel</senderEmail><timestampReceived>2006-11-28 21:17:39-0400</timestampReceived><subject>Re: [PATCHv2 4/6] crypto: table driven multiplications in GF(2^128), needed by LRW (and in the futur</subject><body>

Hello Herbert,

On Wed, Nov 29, 2006 at 08:13:40AM +1100, Herbert Xu wrote:
&gt; &gt; It's OK. The source will be more maintainable, but constantly converting
&gt; &gt; between big and little-endian (on little endian machines) may have a
&gt; &gt; significant performance impact (I will just test when your gf128 hits
&gt; &gt; cryptodev-2.6, and complain if it is the case).
&gt; 
&gt; BTW, the tcrypt speed test for lrw doesn't work for me.

Did you try my patch: [PATCH] adding speed_test_template for lrw(aes)
which I sent on Sep 23?

&gt; &gt; This seems to be the problem, the table is constructed wrongly. 
&gt; &gt; All the calculations take place as if we are on a big endian machine, so
&gt; &gt; the table entries should never be swapped, so the above line should read
&gt; &gt; 
&gt; &gt; +#define xx(p, q)       0x##p##q
&gt; 
&gt; Yes you're quite right.  That was the problem.  I'll push this into mm
&gt; as soon as I get the speed tests fixed.

Ok, that's good news.

Greetings,

Rik.

-- 
Nothing is ever a total loss; it can always serve as a bad example.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061114075843</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-11-14 07:58:43-0400</timestampReceived><subject>Re: Script for loop-AES key generation</subject><body>

Max Vozeler wrote:
&gt; Let me know if you encounter any problems using it or have
&gt; suggestions/patches for improvement. :-)

There have been few cases where v3 key file and v2 losetup/mount were used
to set up a file system, and after upgrade to v3 losetup/mount, mounting the
file system failed. There is a warning about this problem in loop-AES README
file, but not everyone reads README files.

May I suggest adding a check that losetup is recent enough. Something like
this:

    strings /sbin/losetup | grep -q -s multi-key-v3
    if [ $? != 0 ] ; then
        echo "too old losetup version"
    fi

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061118143547</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-11-18 14:35:47-0400</timestampReceived><subject>Re: Script for loop-AES key generation</subject><body>

Hi Jari,

On Tue, Nov 14, 2006 at 09:58:43AM +0200, Jari Ruusu wrote:
&gt; There have been few cases where v3 key file and v2 losetup/mount were
&gt; used to set up a file system, and after upgrade to v3 losetup/mount,
&gt; mounting the file system failed. There is a warning about this problem
&gt; in loop-AES README file, but not everyone reads README files.
&gt;
&gt; May I suggest adding a check that losetup is recent enough. Something
&gt; like this:

&gt;     strings /sbin/losetup | grep -q -s multi-key-v3
&gt;     if [ $? != 0 ] ; then
&gt;         echo "too old losetup version"
&gt;     fi

Indeed, that's a useful check. Given that strings(1) is part
of binutils, which may not be installed on all systems, I made it
run only if strings can be found. Thanks for your suggestion.

cheers,
Max

["warn_too_old.diff" (text/plain)]

Index: debian/loop-aes-keygen
===================================================================
--- debian/loop-aes-keygen	(Revision 1325)
+++ debian/loop-aes-keygen	(Revision 1326)
@@ -137,6 +137,11 @@
 	return 0
 }
 
+check_multikey_support ()
+{
+	strings /sbin/losetup | grep -q -s multi-key-v$1
+}
+
 keygen()
 {
 	version=$1
@@ -174,6 +179,12 @@
 	exit 1
 fi
 
+if [ "$version" -gt 1 ] &amp;&amp; [ -x /usr/bin/strings ]; then
+	if ! check_multikey_support $version; then
+		echo "Warning: /sbin/losetup too old for v$version keys."
+	fi
+fi
+
 if [ -e $keyfile ]; then
 	echo "Keyfile $keyfile exists. Aborting."
 	exit 1


#!/bin/sh
#
# loop-aes-keygen - Create loop-AES encryption keys
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 dated June, 1991.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program;  if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111, USA.
# 
# Copyright 2005-2006, Max Vozeler &lt;xam@debian.org&gt;
#
# $Id: loop-aes-keygen 1326 2006-11-18 14:03:56Z xam $
#

set -e

umask 077

cipher=
userids=
rnd=/dev/random
version=3

usage()
{
	cat &lt;&lt; USAGE
usage: loop-aes-keygen [opts] &lt;keyfile&gt;

  -v &lt;1|2|3&gt;	   Key format (Default: $version)
  -u userid        Encrypt for GnuPG pubkey &lt;userid&gt;
  -c cipher        Use GnuPG cipher &lt;cipher&gt;

USAGE
}

get_options()
{
	while getopts 'v:s:c:u:h' f
	do
		case $f in
		v) 
			version=$OPTARG
			;;

		c)
			cipher=$OPTARG
			;;

		s)
			rnd=$OPTARG
			;;

		u)
			userids="$userids $OPTARG"
			;;
			
		h)
			usage
			exit 0
			;;
		esac
	done
	shift `expr $OPTIND - 1`

	keyfile=$1
	
	if [ -z $keyfile ]; then
		echo No output file. Aborting
		usage
		exit 1
	fi

	if [ $version -lt 1 ] || [ $version -gt 3 ]; then
		echo Unsupported key format: $version
		exit 1
	fi
}

check_safe_loop()
{
	loopdev=$1

	opts=$(/sbin/losetup $loopdev 2&gt;&amp;1)
	if [ $? -ne 0 ]; then
		echo "Error: Check for $loopdev failed ($opts)"
		exit 1
	fi
		
	# If loop entry has an encryption= option assume it's safe
	if echo "$opts" | grep -q encryption=; then
		return 0
	fi

	return 1
}

check_safe_swap()
{
	if [ ! -r /proc/swaps ]; then
		echo Error: Cannot read /proc/swaps
		exit 1
	fi

	unsafe=
	while read line
	do
		set -- $line
		case $1 in
		/dev/loop*)
			if ! check_safe_loop $1; then
				unsafe=$1
				break
			fi
			;;
		Filename*)
			;;
		*)
			unsafe=$1
			break
			;;
		esac
	done &lt; /proc/swaps

	if [ $unsafe ]; then
		echo Fatal: Unsafe swap detected: $unsafe
		exit 1
	fi

	return 0
}

check_multikey_support ()
{
	strings /sbin/losetup | grep -q -s multi-key-v$1
}

keygen()
{
	version=$1
	keyfile=$2
	gpgargs=$3

	# These are the known loop-AES key formats:
	#  v1.x    1     45 bytes           AES key         
	#  v2.x   64   2880 bytes(45 * 64)  AES keys       
	#  v3.x   65   2925 bytes(45 * 65)  #65 is md5 seed
	case $version in
	1) nkeys=1 ;;
	2) nkeys=64 ;;
	3) nkeys=65 ;;
	*) return 1 ;;
	esac

	bytes=$((45*$nkeys))
	head -c $bytes $rnd | uuencode -m - | head -n $(($nkeys+1)) | tail -n $nkeys | gpg $gpgargs &gt; $keyfile
}

get_options $*

if ! check_safe_swap; then
	exit 1
fi

if ! [ -x /usr/bin/gpg ]; then
	echo "Error: gpg not found"
	exit 1
fi

if ! [ -x /usr/bin/uuencode ]; then
	echo "Error: uuencode not found - see package sharutils"
	exit 1
fi

if [ "$version" -gt 1 ] &amp;&amp; [ -x /usr/bin/strings ]; then
	if ! check_multikey_support $version; then
		echo "Warning: /sbin/losetup too old for v$version keys."
	fi
fi

if [ -e $keyfile ]; then
	echo "Keyfile $keyfile exists. Aborting."
	exit 1
fi

gpgargs="--armor"

if [ "$userids" ]; then
	gpgargs="$gpgargs --encrypt"
	for id in $userids; do
		gpgargs="$gpgargs --recipient $id"
	done
else
	gpgargs="$gpgargs --symmetric"
fi

if [ $cipher ]; then
	gpgargs="$gpgargs --cipher-algo=$cipher"
fi

if ! keygen $version $keyfile "$gpgargs"; then
	echo An error occured while creating the key file.
	exit 1
fi

exit 0

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20061118160714</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-11-18 16:07:14-0400</timestampReceived><subject>Re: Script for loop-AES key generation</subject><body>

Max Vozeler wrote:
&gt; +check_multikey_support ()
&gt; +{
&gt; +       strings /sbin/losetup | grep -q -s multi-key-v$1
&gt; +}
&gt; +
[snip]
&gt; +if [ "$version" -gt 1 ] &amp;&amp; [ -x /usr/bin/strings ]; then
&gt; +       if ! check_multikey_support $version; then
&gt; +               echo "Warning: /sbin/losetup too old for v$version keys."
&gt; +       fi
&gt; +fi

String to grep for in v3 losetup is multi-key-v3
String to grep for in v2 losetup is multi-key

Your code looks for multi-key-v2 string in v2 losetup. That won't work.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061122020611</emailId><senderName>Christian Kujau</senderName><senderEmail>evil@g-house.de</senderEmail><timestampReceived>2006-11-22 02:06:11-0400</timestampReceived><subject>Re: Script for loop-AES key generation</subject><body>

On Sat, 18 Nov 2006, Max Vozeler wrote:
&gt; Indeed, that's a useful check. Given that strings(1) is part
&gt; of binutils, which may not be installed on all systems, I made it
&gt; run only if strings can be found.

...and maybe warn the user, if strings(1) cannot be be found and the 
check cannot be performed?

C.
-- 
BOFH excuse #17:

fat electrons in the lines

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061122220710</emailId><senderName>Richard Zidlicky</senderName><senderEmail>rz@linux-m68k.org</senderEmail><timestampReceived>2006-11-22 22:07:10-0400</timestampReceived><subject>Re: Script for loop-AES key generation</subject><body>

On Sat, Nov 18, 2006 at 03:35:47PM +0100, Max Vozeler wrote:
&gt; Hi Jari,
&gt; 
&gt; On Tue, Nov 14, 2006 at 09:58:43AM +0200, Jari Ruusu wrote:
&gt; &gt; There have been few cases where v3 key file and v2 losetup/mount were
&gt; &gt; used to set up a file system, and after upgrade to v3 losetup/mount,
&gt; &gt; mounting the file system failed. There is a warning about this problem
&gt; &gt; in loop-AES README file, but not everyone reads README files.
&gt; &gt;
&gt; &gt; May I suggest adding a check that losetup is recent enough. Something
&gt; &gt; like this:
&gt; 
&gt; &gt;     strings /sbin/losetup | grep -q -s multi-key-v3
&gt; &gt;     if [ $? != 0 ] ; then
&gt; &gt;         echo "too old losetup version"
&gt; &gt;     fi
&gt; 
&gt; Indeed, that's a useful check. Given that strings(1) is part
&gt; of binutils, which may not be installed on all systems, I made it
&gt; run only if strings can be found. Thanks for your suggestion.

why strings? "grep -a" works since ages and saves one command.

Richard

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061125142021</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-11-25 14:20:21-0400</timestampReceived><subject>Re: Script for loop-AES key generation</subject><body>

Hi all,

On Sat, Nov 18, 2006 at 06:07:14PM +0200, Jari Ruusu wrote:
&gt; String to grep for in v3 losetup is multi-key-v3
&gt; String to grep for in v2 losetup is multi-key
&gt; 
&gt; Your code looks for multi-key-v2 string in v2 losetup. That won't work.

On Wed, Nov 22, 2006 at 02:06:11AM +0000, Christian Kujau wrote:
&gt; ...and maybe warn the user, if strings(1) cannot be be found and the 
&gt; check cannot be performed?

On Wed, Nov 22, 2006 at 11:07:10PM +0100, Richard Zidlicky wrote:
&gt; why strings? "grep -a" works since ages and saves one command.

Thanks everyone for your fixes and suggestions. 

The attached patch changes the script to use grep -a (which is not
in POSIX/SuSv3 or busybox grep, but should generally be available on
normal systems) and fixes the detection of multi-key-v2.

cheers,
Max

["fix_multikey_check.diff" (text/plain)]

Index: loop-aes-keygen
===================================================================
--- loop-aes-keygen	(Revision 1326)
+++ loop-aes-keygen	(Arbeitskopie)
@@ -139,7 +139,18 @@
 
 check_multikey_support ()
 {
-	strings /sbin/losetup | grep -q -s multi-key-v$1
+	match=
+	case $1 in
+	1)
+		return 0;;
+	2)
+		match="multi-key";;
+	3)
+		match="multi-key-v3";;
+	*)
+		return 1;;
+	esac
+	grep -q -a "$match" /sbin/losetup
 }
 
 keygen()
@@ -153,10 +164,14 @@
 	#  v2.x   64   2880 bytes(45 * 64)  AES keys       
 	#  v3.x   65   2925 bytes(45 * 65)  #65 is md5 seed
 	case $version in
-	1) nkeys=1 ;;
-	2) nkeys=64 ;;
-	3) nkeys=65 ;;
-	*) return 1 ;;
+	1) 
+		nkeys=1;;
+	2) 
+		nkeys=64;;
+	3) 
+		nkeys=65;;
+	*) 
+		return 1;;
 	esac
 
 	bytes=$((45*$nkeys))
@@ -179,10 +194,8 @@
 	exit 1
 fi
 
-if [ "$version" -gt 1 ] &amp;&amp; [ -x /usr/bin/strings ]; then
-	if ! check_multikey_support $version; then
-		echo "Warning: /sbin/losetup too old for v$version keys."
-	fi
+if ! check_multikey_support $version; then
+	echo "Warning: /sbin/losetup too old for v$version keys."
 fi
 
 if [ -e $keyfile ]; then


#!/bin/sh
#
# loop-aes-keygen - Create loop-AES encryption keys
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 dated June, 1991.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program;  if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111, USA.
# 
# Copyright 2005-2006, Max Vozeler &lt;xam@debian.org&gt;
#
# $Id: loop-aes-keygen 1332 2006-11-24 20:21:26Z xam $
#

set -e

umask 077

cipher=
userids=
rnd=/dev/random
version=3

usage()
{
	cat &lt;&lt; USAGE
usage: loop-aes-keygen [opts] &lt;keyfile&gt;

  -v &lt;1|2|3&gt;	   Key format (Default: $version)
  -u userid        Encrypt for GnuPG pubkey &lt;userid&gt;
  -c cipher        Use GnuPG cipher &lt;cipher&gt;

USAGE
}

get_options()
{
	while getopts 'v:s:c:u:h' f
	do
		case $f in
		v) 
			version=$OPTARG
			;;

		c)
			cipher=$OPTARG
			;;

		s)
			rnd=$OPTARG
			;;

		u)
			userids="$userids $OPTARG"
			;;
			
		h)
			usage
			exit 0
			;;
		esac
	done
	shift `expr $OPTIND - 1`

	keyfile=$1
	
	if [ -z $keyfile ]; then
		echo No output file. Aborting
		usage
		exit 1
	fi

	if [ $version -lt 1 ] || [ $version -gt 3 ]; then
		echo Unsupported key format: $version
		exit 1
	fi
}

check_safe_loop()
{
	loopdev=$1

	opts=$(/sbin/losetup $loopdev 2&gt;&amp;1)
	if [ $? -ne 0 ]; then
		echo "Error: Check for $loopdev failed ($opts)"
		exit 1
	fi
		
	# If loop entry has an encryption= option assume it's safe
	if echo "$opts" | grep -q encryption=; then
		return 0
	fi

	return 1
}

check_safe_swap()
{
	if [ ! -r /proc/swaps ]; then
		echo Error: Cannot read /proc/swaps
		exit 1
	fi

	unsafe=
	while read line
	do
		set -- $line
		case $1 in
		/dev/loop*)
			if ! check_safe_loop $1; then
				unsafe=$1
				break
			fi
			;;
		Filename*)
			;;
		*)
			unsafe=$1
			break
			;;
		esac
	done &lt; /proc/swaps

	if [ $unsafe ]; then
		echo Fatal: Unsafe swap detected: $unsafe
		exit 1
	fi

	return 0
}

check_multikey_support ()
{
	match=
	case $1 in
	1)
		return 0;;
	2)
		match="multi-key";;
	3)
		match="multi-key-v3";;
	*)
		return 1;;
	esac
	grep -q -a "$match" /sbin/losetup
}

keygen()
{
	version=$1
	keyfile=$2
	gpgargs=$3

	# These are the known loop-AES key formats:
	#  v1.x    1     45 bytes           AES key         
	#  v2.x   64   2880 bytes(45 * 64)  AES keys       
	#  v3.x   65   2925 bytes(45 * 65)  #65 is md5 seed
	case $version in
	1) 
		nkeys=1;;
	2) 
		nkeys=64;;
	3) 
		nkeys=65;;
	*) 
		return 1;;
	esac

	bytes=$((45*$nkeys))
	head -c $bytes $rnd | uuencode -m - | head -n $(($nkeys+1)) | tail -n $nkeys | gpg $gpgargs &gt; $keyfile
}

get_options $*

if ! check_safe_swap; then
	exit 1
fi

if ! [ -x /usr/bin/gpg ]; then
	echo "Error: gpg not found"
	exit 1
fi

if ! [ -x /usr/bin/uuencode ]; then
	echo "Error: uuencode not found - see package sharutils"
	exit 1
fi

if ! check_multikey_support $version; then
	echo "Warning: /sbin/losetup too old for v$version keys."
fi

if [ -e $keyfile ]; then
	echo "Keyfile $keyfile exists. Aborting."
	exit 1
fi

gpgargs="--armor"

if [ "$userids" ]; then
	gpgargs="$gpgargs --encrypt"
	for id in $userids; do
		gpgargs="$gpgargs --recipient $id"
	done
else
	gpgargs="$gpgargs --symmetric"
fi

if [ $cipher ]; then
	gpgargs="$gpgargs --cipher-algo=$cipher"
fi

if ! keygen $version $keyfile "$gpgargs"; then
	echo An error occured while creating the key file.
	exit 1
fi

exit 0

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060423150509</emailId><senderName></senderName><senderEmail>domtmb</senderEmail><timestampReceived>2006-04-23 15:05:09-0400</timestampReceived><subject>(no subject)</subject><body>

so ae you horny
 

[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;&lt;HEAD&gt;
&lt;META http-equiv=Content-Type content="text/html; charset=US-ASCII"&gt;
&lt;META content="MSHTML 6.00.2900.2873" name=GENERATOR&gt;&lt;/HEAD&gt;
&lt;BODY id=role_body style="FONT-SIZE: 10pt; COLOR: #000000; FONT-FAMILY: Arial" 
bottomMargin=7 leftMargin=7 topMargin=7 rightMargin=7&gt;&lt;FONT id=role_document 
face=Arial color=#000000 size=2&gt;
&lt;DIV&gt;so ae you horny&lt;/DIV&gt;
&lt;DIV&gt; &lt;/DIV&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060404170909</emailId><senderName></senderName><senderEmail>mskemp803</senderEmail><timestampReceived>2006-04-04 17:09:09-0400</timestampReceived><subject>(no subject)</subject><body>

[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;&lt;HEAD&gt;
&lt;META http-equiv=Content-Type content="text/html; charset=US-ASCII"&gt;
&lt;META content="MSHTML 6.00.2900.2604" name=GENERATOR&gt;&lt;/HEAD&gt;
&lt;BODY id=role_body style="FONT-SIZE: 10pt; COLOR: #000000; FONT-FAMILY: Arial" 
bottomMargin=7 leftMargin=7 topMargin=7 rightMargin=7&gt;&lt;FONT id=role_document 
face=Arial color=#000000 size=2&gt;
&lt;DIV&gt; &lt;/DIV&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060315134640</emailId><senderName></senderName><senderEmail>wraithspqr</senderEmail><timestampReceived>2006-03-15 13:46:40-0400</timestampReceived><subject>(no subject)</subject><body>

I cannot verify my E-mail address as I have not recived the relevant  
verification e-mail

[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;&lt;HEAD&gt;
&lt;META http-equiv=Content-Type content="text/html; charset=US-ASCII"&gt;
&lt;META content="MSHTML 6.00.2900.2180" name=GENERATOR&gt;&lt;/HEAD&gt;
&lt;BODY id=role_body style="FONT-SIZE: 10pt; COLOR: #000000; FONT-FAMILY: Arial" 
bottomMargin=7 leftMargin=7 topMargin=7 rightMargin=7&gt;&lt;FONT id=role_document 
face=Arial color=#000000 size=2&gt;
&lt;DIV&gt;I cannot verify my E-mail address as I have not recived the relevant 
verification e-mail&lt;/DIV&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060106145337</emailId><senderName>"maxim65\ () inwind\ ! it"</senderName><senderEmail>maxim65@inwind.it</senderEmail><timestampReceived>2006-01-06 14:53:37-0400</timestampReceived><subject>how does /tmp encription work?</subject><body>

I tryed to encrypt /tmp like writen in the README loop-aes but it does't work?


&gt;&gt;First, unmount your existing /tmp partition by running "umount /tmp". &gt;&gt;There
&gt;&gt;may be open files in there, so you may have to do this from single user
&gt;&gt;mode.
&gt;&gt;
&gt;&gt;Second, add loop= encryption= and phash=random mount options to &gt;&gt;/etc/fstab
&gt;&gt;file. The sixth /etc/fstab field (fs_passno) must be zero so that fcsk &gt;&gt;will
&gt;&gt;not attempt to check this partition.
&gt;&gt;
&gt;&gt; /dev/hda555 /tmp ext2 &gt;&gt;defaults,loop=/dev/loop2,encryption=AES128,phash=random/1777 0 0
&gt;&gt;                                ^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^ &gt;&gt;^^^^^^^^^^^^^^^^^   ^
&gt;&gt;Third, run "mount /tmp" command and you are done.
&gt;&gt;
&gt;&gt;Octal digits after phash=random/ mount option specify initial permissions &gt;&gt;of
&gt;&gt;file system root directory that gets created on the loop device. 1777 &gt;&gt;means
&gt;&gt;read+write+search permissions for all and sticky bit set. Type "man 2 &gt;&gt;stat"
&gt;&gt;for more info about what each bit stands for.


The system ask me for the password at start-up, Why?
Where is the mistake?

Thanks in advance

Massimo


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060201134600</emailId><senderName>Gabriel_Jägenstedt</senderName><senderEmail>gabriel.j@telia.com</senderEmail><timestampReceived>2006-02-01 13:46:00-0400</timestampReceived><subject>Encrypting DVD:s and CD:s</subject><body>

Hey!

Now for once I'm coming with a question that isn't about some stupid
problem I've caused.

I'm looking for a simple way to have encrypted dvd:s and cd:s.

I have the following line in fstab.
/dev/hdc    /mnt/secure iso9660
ro,user,noauto,loop=/dev/loop11,encryption=AES256,gpgkey=/etc/keys/cd_dvdkey.gpg


What I want is basicly a simple way to encrypt stuff that is off my
drive. I'm sure it is possible to do it in some way writing a simple
script and having one file on the disc but I can't help think there is a
better way.
I haven't tried anything yet but I'm quite sure I don't wish to throw
away media to test what works before asking the professionals.

Does anyone have any tips on this?

cheers
/G

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060302023102</emailId><senderName>"Zhang Jiang jason-MGI8240"</senderName><senderEmail>jiang.zhang@motorola.com</senderEmail><timestampReceived>2006-03-02 02:31:02-0400</timestampReceived><subject>Re: Loading secure binaries</subject><body>

Hi, Ian and Gisle,
 
While I was searching the Internet to solve the similar problem, your email \
communications popped up (see the attachment below). Just wondering if you guys can \
provide me more progress or information about loading secure binaries? I also face \
the same problem that somebody may load and execute malicious code on top of our \
embedded Linux OS. If you guys can share some experience on the embedded Linux, I \
really appreciate!  
Best regards,
 
Jason
 
 
 
________________________________

 

Re: Loading secure binaries?

________________________________


*	To: "Ian S. Nelson" &lt;ian.nelson@echostar.com&gt; 
*	Subject: Re: Loading secure binaries? 
*	From: Gisle S{lensminde &lt;gisle@ii.uib.no&gt; 
*	Date: Mon, 5 Mar 2001 22:08:43 +0100 (MET) 
*	cc: linux-crypto &lt;linux-crypto@nl.linux.org&gt; 
*	In-Reply-To: &lt;3A9AE282.147DE47@echostar.com&gt; 
*	Sender: owner-linux-crypto@nl.linux.org 

________________________________

On Mon, 26 Feb 2001, Ian S. Nelson wrote:

&gt; I'm working on an embedded Linux project and the issue of security is
&gt; starting to surface and it's beginning to look kind of interesting.
&gt; 
&gt; Is there any plans with Linux-crypto or some other project that somebody
&gt; knows of to allow the loading of secure binaries?

This have been discussed here earlier, and I do not think there are
any such plans. Before any such scheme is implemented, it's allways
important to consider what they are meant to protect against. More on
this later.

&gt; 
&gt; I was thinking of a scheme like this:
&gt; 
&gt; there would be a new linux executable loader, perhaps one of the
&gt; misc binary loaders or an ELF hack, you'd want it to reside inside the
&gt; kernel though.
&gt; 
&gt; Then add a new system call to provide a key to the kernel.  This
&gt; could be pulled down off the internet or out of a secure piece of
&gt; hardware.  In some applications it could be something the user provides
&gt; at login time.
&gt; 
&gt; Then the new binaries would be AES/IDEA/DES encrypted with that key
&gt; and the new loader would use that key to decrypt them at load time.

It's a bit unclear what you want to protect against. Some threats i
can think about for networked embedded systems is:

- The binaries/data are transefered/updated via the network, and
  an attacker should not be able to steal data or programs by
  listening to the network, or being a man in the middle. This
  is best protected by SSL, SSH or some other network encryption
  protocol.

- Prevent people with physical access to the device to get any
  unautorized access. This could also be archived by disk encryption.
  This is already done in the kernel for whole partitions.
  A filesystem with one key per user (or anything similar) would be
  more direct on the target, but is it necessary.

- Prevent intruders from executing malicious code. A signing/verification
  scheme will be the right thing to in that case. Possibly combined with
  disk encryption.

In some case, a scheme like the one I think you describes will be usefull.
It's known that attackes have got unathorised access to systems by
replacing modules by their own, that can give permanent root acces,
backdors etc. This scheme requires somebody to accept each and every
executable/module to be executed on the system. This is in practice
awkward executables on a workstation, but for systems where the number of
executable is more controllable, like for embedded systems or kernel
modules, it's archivable.

&gt; Anybody know of something like this?  A logical extension would be to
&gt; embed GPG into the kernel and then you could execute signed and
&gt; encrypted binaries but that seems like overkill for what we're doing, we
&gt; just don't want a few key pieces of code to ever be decrypted anywhere
&gt; other than SDRAM.

Not the whole of GPG, but such a scheme require asymetric crypto to be
inserted into the kernel, and it will require some work, but it's
absolutly archivable, the question is whether it will make systems so much
more secure that it's worth the effort.

--
Gisle Sælensminde ( gisle@ii.uib.no )

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

________________________________


[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;&lt;HEAD&gt;
&lt;META http-equiv=Content-Type content="text/html; charset=iso-8859-1"&gt;
&lt;META content="MSHTML 6.00.2800.1528" name=GENERATOR&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;&lt;SPAN class=295281702-02032006&gt;Hi, Ian and 
Gisle,&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/DIV&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;&lt;SPAN 
class=295281702-02032006&gt;&lt;/SPAN&gt;&lt;/FONT&gt; &lt;/DIV&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;&lt;SPAN class=295281702-02032006&gt;While I was 
searching the Internet to solve the similar problem, your email communications 
popped up (see the attachment below). Just wondering if you guys can provide me 
more progress or information about loading secure binaries? I also face the same 
problem that somebody may load and execute malicious code on top of our embedded 
Linux OS. If you guys can share some experience on the embedded Linux, I really 
appreciate!&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/DIV&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;&lt;SPAN 
class=295281702-02032006&gt;&lt;/SPAN&gt;&lt;/FONT&gt; &lt;/DIV&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;&lt;SPAN class=295281702-02032006&gt;Best 
regards,&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/DIV&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;&lt;SPAN 
class=295281702-02032006&gt;&lt;/SPAN&gt;&lt;/FONT&gt; &lt;/DIV&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;&lt;SPAN 
class=295281702-02032006&gt;Jason&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/DIV&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;&lt;/FONT&gt; &lt;/DIV&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;&lt;/FONT&gt; &lt;/DIV&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;&lt;/FONT&gt; &lt;/DIV&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;
&lt;HR&gt;
 &lt;!--X-Subject-Header-End--&gt;&lt;!--X-Head-of-Message--&gt;&lt;/FONT&gt;&lt;/DIV&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;
&lt;H1&gt;&lt;FONT size=5&gt;Re: Loading secure binaries?&lt;/FONT&gt;&lt;/H1&gt;
&lt;HR&gt;
&lt;!--X-Subject-Header-End--&gt;&lt;!--X-Head-of-Message--&gt;
&lt;UL&gt;
  &lt;LI&gt;&lt;EM&gt;To&lt;/EM&gt;: "Ian S. Nelson" &lt;&lt;A 
  href="mailto:ian.nelson@echostar.com"&gt;ian.nelson@echostar.com&lt;/A&gt;&gt; 
  &lt;LI&gt;&lt;EM&gt;Subject&lt;/EM&gt;: Re: Loading secure binaries? 
  &lt;LI&gt;&lt;EM&gt;From&lt;/EM&gt;: Gisle S{lensminde &lt;&lt;A 
  href="mailto:gisle@ii.uib.no"&gt;gisle@ii.uib.no&lt;/A&gt;&gt; 
  &lt;LI&gt;&lt;EM&gt;Date&lt;/EM&gt;: Mon, 5 Mar 2001 22:08:43 +0100 (MET) 
  &lt;LI&gt;&lt;EM&gt;cc&lt;/EM&gt;: linux-crypto &lt;&lt;A 
  href="mailto:linux-crypto@nl.linux.org"&gt;linux-crypto@nl.linux.org&lt;/A&gt;&gt; 
  &lt;LI&gt;&lt;EM&gt;In-Reply-To&lt;/EM&gt;: &lt;3A9AE282.147DE47@echostar.com&gt; 
  &lt;LI&gt;&lt;EM&gt;Sender&lt;/EM&gt;: &lt;A 
  href="mailto:owner-linux-crypto@nl.linux.org"&gt;owner-linux-crypto@nl.linux.org&lt;/A&gt; 
  &lt;/LI&gt;&lt;/UL&gt;&lt;!--X-Head-of-Message-End--&gt;&lt;!--X-Head-Body-Sep-Begin--&gt;
&lt;HR&gt;
&lt;!--X-Head-Body-Sep-End--&gt;&lt;!--X-Body-of-Message--&gt;&lt;PRE&gt;On Mon, 26 Feb 2001, Ian S. \
Nelson wrote:

&gt; I'm working on an embedded Linux project and the issue of security is
&gt; starting to surface and it's beginning to look kind of interesting.
&gt;
&gt; Is there any plans with Linux-crypto or some other project that somebody
&gt; knows of to allow the loading of secure binaries?

This have been discussed here earlier, and I do not think there are
any such plans. Before any such scheme is implemented, it's allways
important to consider what they are meant to protect against. More on
this later.

&gt;
&gt; I was thinking of a scheme like this:
&gt;
&gt;     there would be a new linux executable loader, perhaps one of the
&gt; misc binary loaders or an ELF hack, you'd want it to reside inside the
&gt; kernel though.
&gt;
&gt;     Then add a new system call to provide a key to the kernel.  This
&gt; could be pulled down off the internet or out of a secure piece of
&gt; hardware.  In some applications it could be something the user provides
&gt; at login time.
&gt;
&gt;     Then the new binaries would be AES/IDEA/DES encrypted with that key
&gt; and the new loader would use that key to decrypt them at load time.

It's a bit unclear what you want to protect against. Some threats i
can think about for networked embedded systems is:

- The binaries/data are transefered/updated via the network, and
  an attacker should not be able to steal data or programs by
  listening to the network, or being a man in the middle. This
  is best protected by SSL, SSH or some other network encryption
  protocol.

- Prevent people with physical access to the device to get any
  unautorized access. This could also be archived by disk encryption.
  This is already done in the kernel for whole partitions.
  A filesystem with one key per user (or anything similar) would be
  more direct on the target, but is it necessary.

- Prevent intruders from executing malicious code. A signing/verification
  scheme will be the right thing to in that case. Possibly combined with
  disk encryption.

In some case, a scheme like the one I think you describes will be usefull.
It's known that attackes have got unathorised access to systems by
replacing modules by their own, that can give permanent root acces,
backdors etc. This scheme requires somebody to accept each and every
executable/module to be executed on the system. This is in practice
awkward executables on a workstation, but for systems where the number of
executable is more controllable, like for embedded systems or kernel
modules, it's archivable.

&gt; Anybody know of something like this?  A logical extension would be to
&gt; embed GPG into the kernel and then you could execute signed and
&gt; encrypted binaries but that seems like overkill for what we're doing, we
&gt; just don't want a few key pieces of code to ever be decrypted anywhere
&gt; other than SDRAM.

Not the whole of GPG, but such a scheme require asymetric crypto to be
inserted into the kernel, and it will require some work, but it's
absolutly archivable, the question is whether it will make systems so much
more secure that it's worth the effort.

--
Gisle Sælensminde ( gisle@ii.uib.no )

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)


Linux-crypto:  cryptography in and on the Linux system
Archive:       &lt;A href="http://mail.nl.linux.org/linux-crypto/"&gt;http://mail.nl.linux.org/linux-crypto/&lt;/A&gt;
 &lt;/PRE&gt;&lt;!--X-Body-of-Message-End--&gt;&lt;!--X-MsgBody-End--&gt;&lt;!--X-Follow-Ups--&gt;
&lt;HR&gt;
&lt;/FONT&gt;&lt;/DIV&gt;&lt;/BODY&gt;&lt;/HTML&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060402092414</emailId><senderName>Gabriel_Jägenstedt</senderName><senderEmail>gabriel.j@telia.com</senderEmail><timestampReceived>2006-04-02 09:24:14-0400</timestampReceived><subject>Encrypted dvd again.</subject><body>

Heya! I use aespipe to encrypt dvds like the readme tells me. However I
would prefer to not mount the device when I'm going to play a dvd.
I figured this should work but alas. What am I missing?

sudo losetup -e AES256 -K /dev/hdc -o 8192 /dev/loop11 /dev/hdc
Password:
Error: gpg key file decryption failed



This mounts the device without problem. But as stated I don't want it
mounted.

/dev/hdc    /mnt/dvd    iso9660
ro,user,noauto,loop=/dev/loop11,encryption=AES256,gpgkey=/dev/hdc,offset=8192
                     0   0

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060602172341</emailId><senderName>"Jordan Crouse"</senderName><senderEmail>jordan.crouse@amd.com</senderEmail><timestampReceived>2006-06-02 17:23:41-0400</timestampReceived><subject>[PATCH] crypto:  Add support for the Geode LX HW AES engine</subject><body>

Greetings - attached is a patch adding a crypto API driver for the hardware
encryption engine on the AMD Geode LX processor, applied against latest
GIT from Linus.  This is my first foray into the world of the Crypto API, 
so comments are more then welcome.

Regards,
Jordan

-- 
Jordan Crouse
Senior Linux Engineer
Advanced Micro Devices, Inc.
&lt;www.amd.com&gt;

["aes.patch" (text/plain)]

PATCH: crypto: Add CryptoAPI support for the Geode LX AES Module

From: Jordan Crouse &lt;jordan.crouse@amd.com&gt;

Add CryptoAPI support for the Geode LX hardware based AES encryption 
engine.

Signed-off-by: Jordan Crouse &lt;jordan.crouse@amd.com&gt;
---

 drivers/crypto/Kconfig     |    9 +
 drivers/crypto/Makefile    |    1 
 drivers/crypto/geode-aes.c |  395 ++++++++++++++++++++++++++++++++++++++++++++
 drivers/crypto/geode-aes.h |   42 +++++
 4 files changed, 447 insertions(+), 0 deletions(-)

diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index 4263935..efc5c72 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -20,4 +20,13 @@ config CRYPTO_DEV_PADLOCK_AES
 	help
 	  Use VIA PadLock for AES algorithm.
 
+config CRYPTO_DEV_GEODE
+	tristate "Support for the Geode LX AES engine"
+	depends on CRYPTO &amp;&amp; X86_32
+	help
+	  Say 'Y' here to use the AMD Geode LX processor on-board AES
+	  engine for the CryptoAPI AES alogrithm.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called geode-aes.
 endmenu
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index 45426ca..9093ed0 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -1,5 +1,6 @@
 
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK) += padlock.o
+obj-$(CONFIG_CRYPTO_DEV_GEODE) += geode-aes.o
 
 padlock-objs-$(CONFIG_CRYPTO_DEV_PADLOCK_AES) += padlock-aes.o
 
diff --git a/drivers/crypto/geode-aes.c b/drivers/crypto/geode-aes.c
new file mode 100644
index 0000000..90ccec4
--- /dev/null
+++ b/drivers/crypto/geode-aes.c
@@ -0,0 +1,395 @@
+/* CryptoAPI interface for the Geode LX hardware AES encryption module
+ * Copyright (C) 2004-2006, Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/sched.h&gt;
+#include &lt;linux/pci.h&gt;
+#include &lt;linux/pci_ids.h&gt;
+#include &lt;linux/crypto.h&gt;
+
+#include &lt;asm/io.h&gt;
+#include &lt;asm/delay.h&gt;
+
+#include "geode-aes.h"
+
+/* Register definitions */
+
+#define AES_CTRLA_REG  0x0000
+
+#define AES_CTRL_START     0x01
+#define AES_CTRL_DECRYPT   0x00
+#define AES_CTRL_ENCRYPT   0x02
+#define AES_CTRL_WRKEY     0x04
+#define AES_CTRL_DCA       0x08
+#define AES_CTRL_SCA       0x10
+#define AES_CTRL_CBC       0x20
+
+#define AES_INTR_REG  0x0008
+
+#define AES_INTRA_PENDING (1 &lt;&lt; 16)
+#define AES_INTRB_PENDING (1 &lt;&lt; 17)
+
+#define AES_INTR_PENDING  (AES_INTRA_PENDING | AES_INTRB_PENDING)
+#define AES_INTR_MASK     0x07
+
+#define AES_SOURCEA_REG   0x0010
+#define AES_DSTA_REG      0x0014
+#define AES_LENA_REG      0x0018
+#define AES_WRITEKEY0_REG 0x0030
+#define AES_WRITEIV0_REG  0x0040
+
+/* Useful macros */
+
+#define SET_KEY(key) _writefield(AES_WRITEKEY0_REG, key)
+#define SET_IV(iv)   _writefield(AES_WRITEIV0_REG, iv)
+#define GET_IV(iv)   _readfield(AES_WRITEIV0_REG, iv)
+
+/* Static structures */
+
+static void __iomem * _iobase;
+static DEFINE_MUTEX(emutex);
+
+static inline void AWRITE(unsigned long val, unsigned short reg) {
+#ifdef DEBUG
+	printk("[AES] W [%x]=%x\n", reg, val);
+#endif
+	iowrite32(val, _iobase + reg);
+}
+
+static inline unsigned int AREAD(unsigned short reg) {
+	unsigned int val = ioread32(_iobase + reg);
+#ifdef DEBUG
+	printk("[AES] R [%x]=%x\n", reg, val);
+#endif
+	return val;
+}
+
+/* Write a 128 bit field (either a writable key or IV) */
+static inline void
+_writefield(u32 offset, void *value)
+{
+	int i;
+	for(i = 0; i &lt; 4; i++)
+		AWRITE(((u32 *) value)[i], offset + (i * 4));
+}
+
+/* Read a 128 bit field (either a writable key or IV) */
+static inline void
+_readfield(u32 offset, void *value)
+{
+	int i;
+	for(i = 0; i &lt; 4; i++)
+		((u32 *) value)[i] = AREAD(offset + (i * 4));
+}
+
+static void
+_crypt(void *src, void *dst, int len, u32 flags)
+{
+	u32 status;
+
+	AWRITE(__pa(src), AES_SOURCEA_REG);
+	AWRITE(__pa(dst), AES_DSTA_REG);
+	AWRITE(len,  AES_LENA_REG);
+
+	/* Start the operation */
+	AWRITE(AES_CTRL_START | flags, AES_CTRLA_REG);
+
+	/* According to the silicon developers, the status will only
+	 * fail to clear on an catastrophic failure, so an infinite
+	 * loop is valid here
+	 */
+
+	do
+		status = AREAD(AES_INTR_REG);
+	while(!(status &amp; AES_INTRA_PENDING));
+
+	/* Clear the event */
+	AWRITE((status &amp; 0xFF) | AES_INTRA_PENDING, AES_INTR_REG);
+}
+
+unsigned int
+geode_aes_crypt(struct geode_aes_op *op)
+{
+	u32 flags = 0;
+
+	if (op-&gt;len == 0 || op-&gt;src == op-&gt;dst)
+		return 0;
+
+	if (mutex_lock_interruptible(&amp;emutex))
+		return 0;
+
+	if (op-&gt;mode == AES_MODE_CBC) {
+		flags |= AES_CTRL_CBC;
+		SET_IV(op-&gt;iv);
+	}
+
+	if (op-&gt;flags &amp; AES_FLAGS_USRKEY) {
+		flags |= AES_CTRL_WRKEY;
+		SET_KEY(op-&gt;key);
+	}
+
+	if (op-&gt;flags &amp; AES_FLAGS_COHERENT)
+		flags |= (AES_CTRL_DCA | AES_CTRL_SCA);
+
+	if (op-&gt;dir == AES_DIR_ENCRYPT)
+		flags |= AES_CTRL_ENCRYPT;
+
+	_crypt(op-&gt;src, op-&gt;dst, op-&gt;len, flags);
+
+	if (op-&gt;mode == AES_MODE_CBC)
+		GET_IV(op-&gt;iv);
+
+	mutex_unlock(&amp;emutex);
+	return op-&gt;len;
+}
+
+/* CRYPTO-API Functions */
+
+static int
+geode_aes_setkey(void *data, const u8 *key, unsigned int len, u32 *flags)
+{
+
+	struct geode_aes_op *op = (struct geode_aes_op *) data;
+
+	if (len != AES_KEY_LENGTH) {
+		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
+		return -EINVAL;
+	}
+
+	memcpy(op-&gt;key, key, len);
+	return 0;
+}
+
+static void
+geode_aes_encrypt(void *ctx, u8 *out, const u8 *in)
+{
+	struct geode_aes_op *op = (struct geode_aes_op *) ctx;
+
+	if ((out == NULL) || (in == NULL))
+		return;
+
+	op-&gt;src = (void *) in;
+	op-&gt;dst = (void *) out;
+	op-&gt;mode = AES_MODE_CBC;
+	op-&gt;flags = 0;
+	op-&gt;len = AES_MIN_BLOCK_SIZE;
+	op-&gt;dir = AES_DIR_ENCRYPT;
+
+	geode_aes_crypt(op);
+}
+
+
+static void
+geode_aes_decrypt(void *ctx, u8 *out, const u8 *in)
+{
+	struct geode_aes_op *op = (struct geode_aes_op *) ctx;
+
+	if ((out == NULL) || (in == NULL))
+		return;
+
+	op-&gt;src = (void *) in;
+	op-&gt;dst = (void *) out;
+	op-&gt;mode = AES_MODE_CBC;
+	op-&gt;flags = 0;
+	op-&gt;len = AES_MIN_BLOCK_SIZE;
+	op-&gt;dir = AES_DIR_DECRYPT;
+
+	geode_aes_crypt(op);
+}
+
+static unsigned int
+geode_aes_encrypt_ecb(const struct cipher_desc *desc, u8 *out,
+		      const u8 *in, unsigned int nbytes)
+{
+	struct geode_aes_op *op = crypto_tfm_ctx(desc-&gt;tfm);
+
+	op-&gt;src = (void *) in;
+	op-&gt;dst = (void *) out;
+	op-&gt;mode = AES_MODE_ECB;
+	op-&gt;flags = 0;
+	op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+	op-&gt;dir = AES_DIR_ENCRYPT;
+
+	return geode_aes_crypt(op);
+}
+
+static unsigned int
+geode_aes_decrypt_ecb(const struct cipher_desc *desc, u8 *out,
+		      const u8 *in, unsigned int nbytes)
+{
+	struct geode_aes_op *op = crypto_tfm_ctx(desc-&gt;tfm);
+
+	op-&gt;src = (void *) in;
+	op-&gt;dst = (void *) out;
+	op-&gt;mode = AES_MODE_ECB;
+	op-&gt;flags = 0;
+	op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+	op-&gt;dir = AES_DIR_DECRYPT;
+
+	return geode_aes_crypt(op);
+}
+
+static unsigned int
+geode_aes_encrypt_cbc(const struct cipher_desc *desc, u8 *out,
+		      const u8 *in, unsigned int nbytes)
+{
+	struct geode_aes_op *op = crypto_tfm_ctx(desc-&gt;tfm);
+	unsigned int ret;
+
+	op-&gt;src = (void *) in;
+	op-&gt;dst = (void *) out;
+	op-&gt;mode = AES_MODE_CBC;
+	op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+	op-&gt;dir = AES_DIR_ENCRYPT;
+
+	memcpy(op-&gt;iv, desc-&gt;info, AES_IV_LENGTH);
+
+	ret = geode_aes_crypt(op);
+
+	memcpy(desc-&gt;info, op-&gt;iv, AES_IV_LENGTH);
+	return ret;
+}
+
+static unsigned int
+geode_aes_decrypt_cbc(const struct cipher_desc *desc, u8 *out,
+		      const u8 *in, unsigned int nbytes)
+{
+	struct geode_aes_op *op = crypto_tfm_ctx(desc-&gt;tfm);
+	unsigned int ret;
+
+	op-&gt;src = (void *) in;
+	op-&gt;dst = (void *) out;
+	op-&gt;mode = AES_MODE_CBC;
+	op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+	op-&gt;dir = AES_DIR_DECRYPT;
+
+	memcpy(op-&gt;iv, desc-&gt;info, AES_IV_LENGTH);
+
+	ret = geode_aes_crypt(op);
+
+	memcpy(desc-&gt;info, op-&gt;iv, AES_IV_LENGTH);
+	return ret;
+}
+
+static struct crypto_alg geode_aes_crypto = {
+	.cra_name               =       "aes",
+	.cra_driver_name	=       "geode-aes",
+	.cra_priority           =       110,
+	.cra_alignmask          =       15,
+	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct geode_aes_op),
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(geode_aes_crypto.cra_list),
+	.cra_u			=	{
+		.cipher = {
+			.cia_min_keysize	=  AES_KEY_LENGTH,
+			.cia_max_keysize	=  AES_KEY_LENGTH,
+			.cia_setkey		=  geode_aes_setkey,
+			.cia_encrypt		=  geode_aes_encrypt,
+			.cia_decrypt		=  geode_aes_decrypt,
+			.cia_encrypt_ecb	=  geode_aes_encrypt_ecb,
+			.cia_decrypt_ecb	=  geode_aes_decrypt_ecb,
+			.cia_encrypt_cbc	=  geode_aes_encrypt_cbc,
+			.cia_decrypt_cbc	=  geode_aes_decrypt_cbc,
+		}
+	}
+};
+
+static void
+geode_aes_remove(struct pci_dev *dev)
+{
+	crypto_unregister_alg(&amp;geode_aes_crypto);
+
+	pci_iounmap(dev, _iobase);
+	_iobase = NULL;
+
+	pci_release_regions(dev);
+	pci_disable_device(dev);
+
+	mutex_destroy(&amp;emutex);
+}
+
+
+static int
+geode_aes_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int ret;
+
+	if ((ret = pci_enable_device(dev)))
+		return ret;
+
+	if ((ret = pci_request_regions(dev, "geode-aes")))
+		goto eenable;
+
+	_iobase = pci_iomap(dev, 0, 0);
+
+	if (_iobase == NULL) {
+		ret = -ENOMEM;
+		goto erequest;
+	}
+
+	/* Clear any pending activity */
+	AWRITE(AES_INTR_PENDING | AES_INTR_MASK, AES_INTR_REG);
+
+	mutex_init(&amp;emutex);
+
+	ret = crypto_register_alg(&amp;geode_aes_crypto);
+
+	if (ret == 0) {
+	  printk(KERN_NOTICE "geode-aes: GEODE AES engine enabled.\n");
+	  return 0;
+	}
+
+	crypto_unregister_alg(&amp;geode_aes_crypto);
+
+	pci_iounmap(dev, _iobase);
+
+ erequest:
+	pci_release_regions(dev);
+
+ eenable:
+	pci_disable_device(dev);
+
+	return ret;
+}
+
+struct pci_device_id geode_aes_tbl[] = {
+	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_LX_AES, PCI_ANY_ID, PCI_ANY_ID} ,
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, geode_aes_tbl);
+
+static struct pci_driver geode_aes_driver = {
+	name:      "Geode LX AES",
+	id_table:  geode_aes_tbl,
+	probe:     geode_aes_probe,
+	remove:    __devexit_p(geode_aes_remove)
+};
+
+static int __devinit
+geode_aes_init(void)
+{
+	return pci_module_init(&amp;geode_aes_driver);
+}
+
+static void __devexit
+geode_aes_exit(void)
+{
+	pci_unregister_driver(&amp;geode_aes_driver);
+}
+
+MODULE_AUTHOR("Advanced Micro Devices, Inc.");
+MODULE_DESCRIPTION("Geode LX Hardware AES driver");
+MODULE_LICENSE("GPL");
+
+module_init(geode_aes_init);
+module_exit(geode_aes_exit);
diff --git a/drivers/crypto/geode-aes.h b/drivers/crypto/geode-aes.h
new file mode 100644
index 0000000..97f9eee
--- /dev/null
+++ b/drivers/crypto/geode-aes.h
@@ -0,0 +1,42 @@
+/* Copyright (C) 2003-2006, Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _GEODE_AES_H_
+#define _GEODE_AES_H_
+
+#define AES_KEY_LENGTH 16
+#define AES_IV_LENGTH  16
+
+#define AES_MIN_BLOCK_SIZE 16
+
+#define AES_MODE_ECB 0
+#define AES_MODE_CBC 1
+
+#define AES_DIR_DECRYPT 0
+#define AES_DIR_ENCRYPT 1
+
+#define AES_FLAGS_USRKEY   (1 &lt;&lt; 0)
+#define AES_FLAGS_COHERENT (1 &lt;&lt; 1)
+
+struct geode_aes_op {
+
+  void *src;
+  void *dst;
+
+  u32 mode;
+  u32 dir;
+  u32 flags;
+  int len;
+
+  u8 key[AES_KEY_LENGTH];
+  u8 iv[AES_IV_LENGTH];
+};
+
+unsigned int geode_aes_crypt(struct geode_aes_op *);
+
+#endif

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060901102659</emailId><senderName>Phil H</senderName><senderEmail>philtickle200@yahoo.com</senderEmail><timestampReceived>2006-09-01 10:26:59-0400</timestampReceived><subject>Using particular gcc version to compile loop.o</subject><body>

How do I tell make to use a particular gcc version on my machine (to match the one my \
running kernle was compiled with)? 

I don't think there is a CC=gcc-x.xx line in the makefile.  Do I just set a CC \
environment variable?

 		
---------------------------------
How low will we go? Check out Yahoo! Messenger’s low  PC-to-Phone call rates.


[Attachment #3 (text/html)]

How do I tell make to use a particular gcc version on my machine (to match the one my \
running kernle was compiled with)? &lt;br&gt;&lt;br&gt;I don't think there is a CC=gcc-x.xx line \
in the makefile.  Do I just set a CC environment variable?&lt;br&gt;&lt;p&gt;   &lt;hr \
size=1&gt;How low will we go? Check out Yahoo! Messenger’s low &lt;a \
href="http://us.rd.yahoo.com/mail_us/taglines/postman8/*http://us.rd.yahoo.com/evt=39663/*http://voice.yahoo.com"&gt; \
PC-to-Phone call rates.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060928163115</emailId><senderName>"Jordan Crouse"</senderName><senderEmail>jordan.crouse@amd.com</senderEmail><timestampReceived>2006-09-28 16:31:15-0400</timestampReceived><subject>Re: crypto: Add support for the Geode AES engine</subject><body>

&gt; As far as I can see, register access is not protected, how can your
&gt; driver handle the case when dm-crypt and IPsec simultaneously try to
&gt; encrypt/decrypt some data, it can happen even around 
&gt; preemt_disable/enable calls and actually crypto processing can happen 
&gt; in interrupt context too (although it is not the best thing to do).

I had the mutex in there, but I took it out based on our previous
conversations, which probably was a little rash.  If CRYPTO_TFM_REQ_MAY_SLEEP
is still a valid flag to check, I could use that along with a spin lock of
some sort.   I'll think about this a bit more.

&gt; You added timeout for the broken hardware condition, I think it is
&gt; better to return some error from _crypt() in that case, and, btw, that
&gt; name is not very good choice.

I normally use _&lt;blah&gt; for static functions within my module - it helps
me remember which commands might be important to others and which are just
utility functions for my own use and abuse.  I'll change the name.

Thanks,
Jordan

-- 
Jordan Crouse
Senior Linux Engineer
Advanced Micro Devices, Inc.
&lt;www.amd.com/embeddedprocessors&gt;


-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060928214750</emailId><senderName>"Jordan Crouse"</senderName><senderEmail>jordan.crouse@amd.com</senderEmail><timestampReceived>2006-09-28 21:47:50-0400</timestampReceived><subject>crypto: Add support for the Geode AES engine (v2)</subject><body>

&gt; As far as I can see, register access is not protected, how can your
&gt; driver handle the case when dm-crypt and IPsec simultaneously try to
&gt; encrypt/decrypt some data, it can happen even around 
&gt; preemt_disable/enable calls and actually crypto processing can happen 
&gt; in interrupt context too (although it is not the best thing to do).

I was sitting there trying to architect some grand scheme, and then it
occured to me that we should just turn off the interrupts all together
in the critical area.  Its not optimal for performance, but it
avoids lots of crazy if statements.

&gt; You added timeout for the broken hardware condition, I think it is
&gt; better to return some error from _crypt() in that case, and, btw, that
&gt; name is not very good choice.

Fixed the name and I return the error.  I don't propagate it through the
whole chain, because quite frankly, if the crypto engine fails, then its
a good bet the processor is on fire. :)

Jordan
-- 
Jordan Crouse
Senior Linux Engineer
Advanced Micro Devices, Inc.
&lt;www.amd.com/embeddedprocessors&gt;

["geode-lx-crypto.patch" (text/plain)]

diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index adb5541..e816535 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -51,4 +51,17 @@ config CRYPTO_DEV_PADLOCK_SHA
 	  If unsure say M. The compiled module will be
 	  called padlock-sha.ko
 
+config CRYPTO_DEV_GEODE
+	tristate "Support for the Geode LX AES engine"
+	depends on CRYPTO &amp;&amp; X86_32
+	select CRYPTO_ALGAPI
+	select CRYPTO_BLKCIPHER
+	default m
+	help
+	  Say 'Y' here to use the AMD Geode LX processor on-board AES
+	  engine for the CryptoAPI AES alogrithm.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called geode-aes.
+
 endmenu
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index 4c3d0ec..6059cf8 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -1,3 +1,4 @@
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK) += padlock.o
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK_AES) += padlock-aes.o
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK_SHA) += padlock-sha.o
+obj-$(CONFIG_CRYPTO_DEV_GEODE) += geode-aes.o
diff --git a/drivers/crypto/geode-aes.c b/drivers/crypto/geode-aes.c
new file mode 100644
index 0000000..73b33ba
--- /dev/null
+++ b/drivers/crypto/geode-aes.c
@@ -0,0 +1,481 @@
+/* CryptoAPI interface for the Geode LX hardware AES encryption module
+ * Copyright (C) 2004-2006, Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/sched.h&gt;
+#include &lt;linux/pci.h&gt;
+#include &lt;linux/pci_ids.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;crypto/algapi.h&gt;
+
+#include &lt;asm/io.h&gt;
+#include &lt;asm/delay.h&gt;
+
+#include "geode-aes.h"
+
+/* Register definitions */
+
+#define AES_CTRLA_REG  0x0000
+
+#define AES_CTRL_START     0x01
+#define AES_CTRL_DECRYPT   0x00
+#define AES_CTRL_ENCRYPT   0x02
+#define AES_CTRL_WRKEY     0x04
+#define AES_CTRL_DCA       0x08
+#define AES_CTRL_SCA       0x10
+#define AES_CTRL_CBC       0x20
+
+#define AES_INTR_REG  0x0008
+
+#define AES_INTRA_PENDING (1 &lt;&lt; 16)
+#define AES_INTRB_PENDING (1 &lt;&lt; 17)
+
+#define AES_INTR_PENDING  (AES_INTRA_PENDING | AES_INTRB_PENDING)
+#define AES_INTR_MASK     0x07
+
+#define AES_SOURCEA_REG   0x0010
+#define AES_DSTA_REG      0x0014
+#define AES_LENA_REG      0x0018
+#define AES_WRITEKEY0_REG 0x0030
+#define AES_WRITEIV0_REG  0x0040
+
+/*  A very large counter that is used to gracefully bail out of an
+ *  operation in case of trouble
+ */
+
+#define AES_OP_TIMEOUT    0x50000
+
+/* Useful macros */
+
+#define SET_KEY(key) _writefield(AES_WRITEKEY0_REG, key)
+#define SET_IV(iv)   _writefield(AES_WRITEIV0_REG, iv)
+#define GET_IV(iv)   _readfield(AES_WRITEIV0_REG, iv)
+#define AWRITE(val, reg) (iowrite32(val, _iobase + reg))
+#define AREAD(reg)  (ioread32(_iobase + reg))
+
+/* Static structures */
+
+static void __iomem * _iobase;
+
+/* Write a 128 bit field (either a writable key or IV) */
+static inline void
+_writefield(u32 offset, void *value)
+{
+	int i;
+	for(i = 0; i &lt; 4; i++)
+		AWRITE(((u32 *) value)[i], offset + (i * 4));
+}
+
+/* Read a 128 bit field (either a writable key or IV) */
+static inline void
+_readfield(u32 offset, void *value)
+{
+	int i;
+	for(i = 0; i &lt; 4; i++)
+		((u32 *) value)[i] = AREAD(offset + (i * 4));
+}
+
+static int
+do_crypt(void *src, void *dst, int len, u32 flags)
+{
+	u32 status;
+	u32 counter = AES_OP_TIMEOUT;
+
+	AWRITE(virt_to_phys(src), AES_SOURCEA_REG);
+	AWRITE(virt_to_phys(dst), AES_DSTA_REG);
+	AWRITE(len,  AES_LENA_REG);
+
+	/* Start the operation */ 
+	AWRITE(AES_CTRL_START | flags, AES_CTRLA_REG);
+
+	do 
+		status = AREAD(AES_INTR_REG);
+	while(!(status &amp; AES_INTRA_PENDING) &amp;&amp; --counter);
+
+	/* Clear the event */
+	AWRITE((status &amp; 0xFF) | AES_INTRA_PENDING, AES_INTR_REG);
+	return counter ? 0 : 1;
+}
+
+unsigned int
+geode_aes_crypt(struct geode_aes_op *op)
+{
+	u32 flags = 0;
+	int iflags;
+
+	if (op-&gt;len == 0 || op-&gt;src == op-&gt;dst)
+		return 0;
+
+	if (op-&gt;flags &amp; AES_FLAGS_COHERENT)
+		flags |= (AES_CTRL_DCA | AES_CTRL_SCA);
+
+	if (op-&gt;dir == AES_DIR_ENCRYPT)
+		flags |= AES_CTRL_ENCRYPT;
+
+	/* Start the critical section */
+
+	spin_lock_irqsave(&amp;lock, iflags);
+
+	if (op-&gt;mode == AES_MODE_CBC) {
+		flags |= AES_CTRL_CBC;
+		SET_IV(op-&gt;iv);
+	}
+
+	if (op-&gt;flags &amp; AES_FLAGS_USRKEY) {
+		flags |= AES_CTRL_WRKEY;
+		SET_KEY(op-&gt;key);
+	}
+
+	do_crypt(op-&gt;src, op-&gt;dst, op-&gt;len, flags);
+
+	if (op-&gt;mode == AES_MODE_CBC)
+		GET_IV(op-&gt;iv);
+
+	spin_lock_irqrestore(&amp;lock, iflags);
+
+	return op-&gt;len;
+}
+
+/* CRYPTO-API Functions */
+
+#define blk_ctx(tfm) ((struct geode_aes_op *) crypto_blkcipher_ctx(tfm))
+#define ctx(tfm) ((struct geode_aes_op *) crypto_tfm_ctx(tfm))
+
+static int
+geode_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int len)
+{
+	struct geode_aes_op *op = ctx(tfm);
+
+	if (len != AES_KEY_LENGTH) {
+		tfm-&gt;crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
+		return -EINVAL;
+	}
+
+	memcpy(op-&gt;key, key, len);
+	return 0;
+}
+
+static void
+geode_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
+{
+	struct geode_aes_op *op = ctx(tfm);
+
+	if ((out == NULL) || (in == NULL))
+		return;
+
+	op-&gt;src = (void *) in;
+	op-&gt;dst = (void *) out;
+	op-&gt;mode = AES_MODE_ECB;
+	op-&gt;flags = 0;
+	op-&gt;len = AES_MIN_BLOCK_SIZE;
+	op-&gt;dir = AES_DIR_ENCRYPT;
+
+	geode_aes_crypt(op);
+}
+
+
+static void
+geode_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
+{
+	struct geode_aes_op *op = ctx(tfm);
+
+	if ((out == NULL) || (in == NULL))
+		return;
+
+	op-&gt;src = (void *) in;
+	op-&gt;dst = (void *) out;
+	op-&gt;mode = AES_MODE_ECB;
+	op-&gt;flags = 0;
+	op-&gt;len = AES_MIN_BLOCK_SIZE;
+	op-&gt;dir = AES_DIR_DECRYPT;
+
+	geode_aes_crypt(op);
+}
+
+
+static struct crypto_alg geode_alg = {
+	.cra_name               =       "aes",
+	.cra_driver_name	=       "geode-aes-128",
+	.cra_priority           =       300,
+	.cra_alignmask          =       15,
+	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct geode_aes_op),
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(geode_alg.cra_list),
+	.cra_u			=	{
+		.cipher = {
+			.cia_min_keysize	=  AES_KEY_LENGTH,
+			.cia_max_keysize	=  AES_KEY_LENGTH,
+			.cia_setkey		=  geode_setkey,
+			.cia_encrypt		=  geode_encrypt,
+			.cia_decrypt		=  geode_decrypt
+		}
+	}
+};
+
+static int
+geode_cbc_decrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = blk_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = (void *) walk.src.virt.addr,
+		op-&gt;dst = (void *) walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_CBC;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_DECRYPT;
+
+		memcpy(op-&gt;iv, walk.iv, AES_IV_LENGTH);
+
+		ret = geode_aes_crypt(op);
+
+		memcpy(walk.iv, op-&gt;iv, AES_IV_LENGTH);
+		nbytes -= ret;
+
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static int
+geode_cbc_encrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = blk_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = (void *) walk.src.virt.addr,
+		op-&gt;dst = (void *) walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_CBC;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_ENCRYPT;
+
+		memcpy(op-&gt;iv, walk.iv, AES_IV_LENGTH);
+
+		ret = geode_aes_crypt(op);
+		nbytes -= ret;
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static struct crypto_alg geode_cbc_alg = {
+	.cra_name		=	"cbc(aes)",
+	.cra_driver_name	=	"cbc-aes-geode-128",
+	.cra_priority		=	400,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct geode_aes_op),
+	.cra_alignmask		=	15,
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(geode_cbc_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	AES_KEY_LENGTH,
+			.max_keysize		=	AES_KEY_LENGTH,
+			.setkey			=	geode_setkey,
+			.encrypt		=	geode_cbc_encrypt,
+			.decrypt		=	geode_cbc_decrypt,
+		}
+	}
+};
+
+static int
+geode_ecb_decrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = blk_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = (void *) walk.src.virt.addr,
+		op-&gt;dst = (void *) walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_ECB;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_DECRYPT;
+
+		ret = geode_aes_crypt(op);
+		nbytes -= ret;
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static int
+geode_ecb_encrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = blk_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = (void *) walk.src.virt.addr,
+		op-&gt;dst = (void *) walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_ECB;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_ENCRYPT;
+
+		ret = geode_aes_crypt(op);
+		nbytes -= ret;
+		ret =  blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static struct crypto_alg geode_ecb_alg = {
+	.cra_name		=	"ecb(aes)",
+	.cra_driver_name	=	"ecb-aes-geode-128",
+	.cra_priority		=	400,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct geode_aes_op),
+	.cra_alignmask		=	15,
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(geode_ecb_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	AES_KEY_LENGTH,
+			.max_keysize		=	AES_KEY_LENGTH,
+			.setkey			=	geode_setkey,
+			.encrypt		=	geode_ecb_encrypt,
+			.decrypt		=	geode_ecb_decrypt,
+		}
+	}
+};
+
+static void
+geode_aes_remove(struct pci_dev *dev)
+{
+	crypto_unregister_alg(&amp;geode_alg);
+	crypto_unregister_alg(&amp;geode_ecb_alg);
+	crypto_unregister_alg(&amp;geode_cbc_alg);
+
+	pci_iounmap(dev, _iobase);
+	_iobase = NULL;
+
+	pci_release_regions(dev);
+	pci_disable_device(dev);
+}
+
+
+static int
+geode_aes_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int ret;
+
+	if ((ret = pci_enable_device(dev)))
+		return ret;
+
+	if ((ret = pci_request_regions(dev, "geode-aes-128")))
+		goto eenable;
+
+	_iobase = pci_iomap(dev, 0, 0);
+
+	if (_iobase == NULL) {
+		ret = -ENOMEM;
+		goto erequest;
+	}
+
+	/* Clear any pending activity */
+	AWRITE(AES_INTR_PENDING | AES_INTR_MASK, AES_INTR_REG);
+
+	if ((ret = crypto_register_alg(&amp;geode_alg)))
+		goto eiomap;
+
+	if ((ret = crypto_register_alg(&amp;geode_ecb_alg)))
+		goto ealg;
+
+	if ((ret = crypto_register_alg(&amp;geode_cbc_alg)))
+		goto eecb;
+
+	printk(KERN_NOTICE "geode-aes: GEODE AES engine enabled.\n");
+	return 0;
+
+ eecb:
+	crypto_unregister_alg(&amp;geode_ecb_alg);
+
+ ealg:
+	crypto_unregister_alg(&amp;geode_alg);
+
+ eiomap:
+	pci_iounmap(dev, _iobase);
+
+ erequest:
+	pci_release_regions(dev);
+
+ eenable:
+	pci_disable_device(dev);
+
+	printk(KERN_ERR "geode-aes:  GEODE AES initialization failed.\n");
+	return ret;
+}
+
+struct pci_device_id geode_aes_tbl[] = {
+	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_LX_AES, PCI_ANY_ID, PCI_ANY_ID} ,
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, geode_aes_tbl);
+
+static struct pci_driver geode_aes_driver = {
+	name:      "Geode LX AES",
+	id_table:  geode_aes_tbl,
+	probe:     geode_aes_probe,
+	remove:    __devexit_p(geode_aes_remove)
+};
+
+static int __devinit
+geode_aes_init(void)
+{
+	return pci_module_init(&amp;geode_aes_driver);
+}
+
+static void __devexit
+geode_aes_exit(void)
+{
+	pci_unregister_driver(&amp;geode_aes_driver);
+}
+
+MODULE_AUTHOR("Advanced Micro Devices, Inc.");
+MODULE_DESCRIPTION("Geode LX Hardware AES driver");
+MODULE_LICENSE("GPL");
+
+module_init(geode_aes_init);
+module_exit(geode_aes_exit);
diff --git a/drivers/crypto/geode-aes.h b/drivers/crypto/geode-aes.h
new file mode 100644
index 0000000..97f9eee
--- /dev/null
+++ b/drivers/crypto/geode-aes.h
@@ -0,0 +1,42 @@
+/* Copyright (C) 2003-2006, Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _GEODE_AES_H_
+#define _GEODE_AES_H_
+
+#define AES_KEY_LENGTH 16
+#define AES_IV_LENGTH  16
+
+#define AES_MIN_BLOCK_SIZE 16
+
+#define AES_MODE_ECB 0
+#define AES_MODE_CBC 1
+
+#define AES_DIR_DECRYPT 0
+#define AES_DIR_ENCRYPT 1
+
+#define AES_FLAGS_USRKEY   (1 &lt;&lt; 0)
+#define AES_FLAGS_COHERENT (1 &lt;&lt; 1)
+
+struct geode_aes_op {
+
+  void *src;
+  void *dst;
+
+  u32 mode;
+  u32 dir;
+  u32 flags;
+  int len;
+
+  u8 key[AES_KEY_LENGTH];
+  u8 iv[AES_IV_LENGTH];
+};
+
+unsigned int geode_aes_crypt(struct geode_aes_op *);
+
+#endif

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060928220336</emailId><senderName>"Jordan Crouse"</senderName><senderEmail>jordan.crouse@amd.com</senderEmail><timestampReceived>2006-09-28 22:03:36-0400</timestampReceived><subject>Re: crypto: Add support for the Geode AES engine (v3)</subject><body>

Sigh - forgot to do an 'stg refresh' before generating the diff.  This one
actually compiles.

Jordan
-- 
Jordan Crouse
Senior Linux Engineer
Advanced Micro Devices, Inc.
&lt;www.amd.com/embeddedprocessors&gt;

["geode-lx-crypto.patch" (text/plain)]

[PATCH] crypto:  Add support for the Geode LX AES hardware

This adds support for the AES engine on the Geode LX processor.

Signed-off-by: Jordan Crouse &lt;jordan.crouse@amd.com&gt;

diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index adb5541..e816535 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -51,4 +51,17 @@ config CRYPTO_DEV_PADLOCK_SHA
 	  If unsure say M. The compiled module will be
 	  called padlock-sha.ko
 
+config CRYPTO_DEV_GEODE
+	tristate "Support for the Geode LX AES engine"
+	depends on CRYPTO &amp;&amp; X86_32
+	select CRYPTO_ALGAPI
+	select CRYPTO_BLKCIPHER
+	default m
+	help
+	  Say 'Y' here to use the AMD Geode LX processor on-board AES
+	  engine for the CryptoAPI AES alogrithm.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called geode-aes.
+
 endmenu
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index 4c3d0ec..6059cf8 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -1,3 +1,4 @@
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK) += padlock.o
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK_AES) += padlock-aes.o
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK_SHA) += padlock-sha.o
+obj-$(CONFIG_CRYPTO_DEV_GEODE) += geode-aes.o
diff --git a/drivers/crypto/geode-aes.c b/drivers/crypto/geode-aes.c
new file mode 100644
index 0000000..1fbc41d
--- /dev/null
+++ b/drivers/crypto/geode-aes.c
@@ -0,0 +1,486 @@
+/* CryptoAPI interface for the Geode LX hardware AES encryption module
+ * Copyright (C) 2004-2006, Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/sched.h&gt;
+#include &lt;linux/pci.h&gt;
+#include &lt;linux/pci_ids.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/spinlock.h&gt;
+#include &lt;crypto/algapi.h&gt;
+
+#include &lt;asm/io.h&gt;
+#include &lt;asm/delay.h&gt;
+
+#include "geode-aes.h"
+
+/* Register definitions */
+
+#define AES_CTRLA_REG  0x0000
+
+#define AES_CTRL_START     0x01
+#define AES_CTRL_DECRYPT   0x00
+#define AES_CTRL_ENCRYPT   0x02
+#define AES_CTRL_WRKEY     0x04
+#define AES_CTRL_DCA       0x08
+#define AES_CTRL_SCA       0x10
+#define AES_CTRL_CBC       0x20
+
+#define AES_INTR_REG  0x0008
+
+#define AES_INTRA_PENDING (1 &lt;&lt; 16)
+#define AES_INTRB_PENDING (1 &lt;&lt; 17)
+
+#define AES_INTR_PENDING  (AES_INTRA_PENDING | AES_INTRB_PENDING)
+#define AES_INTR_MASK     0x07
+
+#define AES_SOURCEA_REG   0x0010
+#define AES_DSTA_REG      0x0014
+#define AES_LENA_REG      0x0018
+#define AES_WRITEKEY0_REG 0x0030
+#define AES_WRITEIV0_REG  0x0040
+
+/*  A very large counter that is used to gracefully bail out of an
+ *  operation in case of trouble
+ */
+
+#define AES_OP_TIMEOUT    0x50000
+
+/* Useful macros */
+
+#define SET_KEY(key) _writefield(AES_WRITEKEY0_REG, key)
+#define SET_IV(iv)   _writefield(AES_WRITEIV0_REG, iv)
+#define GET_IV(iv)   _readfield(AES_WRITEIV0_REG, iv)
+#define AWRITE(val, reg) (iowrite32(val, _iobase + reg))
+#define AREAD(reg)  (ioread32(_iobase + reg))
+
+/* Static structures */
+
+static void __iomem * _iobase;
+static spinlock_t lock;
+
+/* Write a 128 bit field (either a writable key or IV) */
+static inline void
+_writefield(u32 offset, void *value)
+{
+	int i;
+	for(i = 0; i &lt; 4; i++)
+		AWRITE(((u32 *) value)[i], offset + (i * 4));
+}
+
+/* Read a 128 bit field (either a writable key or IV) */
+static inline void
+_readfield(u32 offset, void *value)
+{
+	int i;
+	for(i = 0; i &lt; 4; i++)
+		((u32 *) value)[i] = AREAD(offset + (i * 4));
+}
+
+static int
+do_crypt(void *src, void *dst, int len, u32 flags)
+{
+	u32 status;
+	u32 counter = AES_OP_TIMEOUT;
+
+	AWRITE(virt_to_phys(src), AES_SOURCEA_REG);
+	AWRITE(virt_to_phys(dst), AES_DSTA_REG);
+	AWRITE(len,  AES_LENA_REG);
+
+	/* Start the operation */ 
+	AWRITE(AES_CTRL_START | flags, AES_CTRLA_REG);
+
+	do 
+		status = AREAD(AES_INTR_REG);
+	while(!(status &amp; AES_INTRA_PENDING) &amp;&amp; --counter);
+
+	/* Clear the event */
+	AWRITE((status &amp; 0xFF) | AES_INTRA_PENDING, AES_INTR_REG);
+	return counter ? 0 : 1;
+}
+
+unsigned int
+geode_aes_crypt(struct geode_aes_op *op)
+{
+
+	u32 flags = 0;
+	int iflags;
+
+	if (op-&gt;len == 0 || op-&gt;src == op-&gt;dst)
+		return 0;
+
+	if (op-&gt;flags &amp; AES_FLAGS_COHERENT)
+		flags |= (AES_CTRL_DCA | AES_CTRL_SCA);
+
+	if (op-&gt;dir == AES_DIR_ENCRYPT)
+		flags |= AES_CTRL_ENCRYPT;
+
+	/* Start the critical section */
+
+	spin_lock_irqsave(&amp;lock, iflags);
+
+	if (op-&gt;mode == AES_MODE_CBC) {
+		flags |= AES_CTRL_CBC;
+		SET_IV(op-&gt;iv);
+	}
+
+	if (op-&gt;flags &amp; AES_FLAGS_USRKEY) {
+		flags |= AES_CTRL_WRKEY;
+		SET_KEY(op-&gt;key);
+	}
+
+	do_crypt(op-&gt;src, op-&gt;dst, op-&gt;len, flags);
+
+	if (op-&gt;mode == AES_MODE_CBC)
+		GET_IV(op-&gt;iv);
+
+	spin_unlock_irqrestore(&amp;lock, iflags);
+
+	return op-&gt;len;
+}
+
+/* CRYPTO-API Functions */
+
+#define blk_ctx(tfm) ((struct geode_aes_op *) crypto_blkcipher_ctx(tfm))
+#define ctx(tfm) ((struct geode_aes_op *) crypto_tfm_ctx(tfm))
+
+static int
+geode_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int len)
+{
+	struct geode_aes_op *op = ctx(tfm);
+
+	if (len != AES_KEY_LENGTH) {
+		tfm-&gt;crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
+		return -EINVAL;
+	}
+
+	memcpy(op-&gt;key, key, len);
+	return 0;
+}
+
+static void
+geode_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
+{
+	struct geode_aes_op *op = ctx(tfm);
+
+	if ((out == NULL) || (in == NULL))
+		return;
+
+	op-&gt;src = (void *) in;
+	op-&gt;dst = (void *) out;
+	op-&gt;mode = AES_MODE_ECB;
+	op-&gt;flags = 0;
+	op-&gt;len = AES_MIN_BLOCK_SIZE;
+	op-&gt;dir = AES_DIR_ENCRYPT;
+
+	geode_aes_crypt(op);
+}
+
+
+static void
+geode_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
+{
+	struct geode_aes_op *op = ctx(tfm);
+
+	if ((out == NULL) || (in == NULL))
+		return;
+
+	op-&gt;src = (void *) in;
+	op-&gt;dst = (void *) out;
+	op-&gt;mode = AES_MODE_ECB;
+	op-&gt;flags = 0;
+	op-&gt;len = AES_MIN_BLOCK_SIZE;
+	op-&gt;dir = AES_DIR_DECRYPT;
+
+	geode_aes_crypt(op);
+}
+
+
+static struct crypto_alg geode_alg = {
+	.cra_name               =       "aes",
+	.cra_driver_name	=       "geode-aes-128",
+	.cra_priority           =       300,
+	.cra_alignmask          =       15,
+	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct geode_aes_op),
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(geode_alg.cra_list),
+	.cra_u			=	{
+		.cipher = {
+			.cia_min_keysize	=  AES_KEY_LENGTH,
+			.cia_max_keysize	=  AES_KEY_LENGTH,
+			.cia_setkey		=  geode_setkey,
+			.cia_encrypt		=  geode_encrypt,
+			.cia_decrypt		=  geode_decrypt
+		}
+	}
+};
+
+static int
+geode_cbc_decrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = blk_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = (void *) walk.src.virt.addr,
+		op-&gt;dst = (void *) walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_CBC;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_DECRYPT;
+
+		memcpy(op-&gt;iv, walk.iv, AES_IV_LENGTH);
+
+		ret = geode_aes_crypt(op);
+
+		memcpy(walk.iv, op-&gt;iv, AES_IV_LENGTH);
+		nbytes -= ret;
+
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static int
+geode_cbc_encrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = blk_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = (void *) walk.src.virt.addr,
+		op-&gt;dst = (void *) walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_CBC;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_ENCRYPT;
+
+		memcpy(op-&gt;iv, walk.iv, AES_IV_LENGTH);
+
+		ret = geode_aes_crypt(op);
+		nbytes -= ret;
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static struct crypto_alg geode_cbc_alg = {
+	.cra_name		=	"cbc(aes)",
+	.cra_driver_name	=	"cbc-aes-geode-128",
+	.cra_priority		=	400,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct geode_aes_op),
+	.cra_alignmask		=	15,
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(geode_cbc_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	AES_KEY_LENGTH,
+			.max_keysize		=	AES_KEY_LENGTH,
+			.setkey			=	geode_setkey,
+			.encrypt		=	geode_cbc_encrypt,
+			.decrypt		=	geode_cbc_decrypt,
+		}
+	}
+};
+
+static int
+geode_ecb_decrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = blk_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = (void *) walk.src.virt.addr,
+		op-&gt;dst = (void *) walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_ECB;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_DECRYPT;
+
+		ret = geode_aes_crypt(op);
+		nbytes -= ret;
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static int
+geode_ecb_encrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = blk_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = (void *) walk.src.virt.addr,
+		op-&gt;dst = (void *) walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_ECB;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_ENCRYPT;
+
+		ret = geode_aes_crypt(op);
+		nbytes -= ret;
+		ret =  blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static struct crypto_alg geode_ecb_alg = {
+	.cra_name		=	"ecb(aes)",
+	.cra_driver_name	=	"ecb-aes-geode-128",
+	.cra_priority		=	400,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct geode_aes_op),
+	.cra_alignmask		=	15,
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(geode_ecb_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	AES_KEY_LENGTH,
+			.max_keysize		=	AES_KEY_LENGTH,
+			.setkey			=	geode_setkey,
+			.encrypt		=	geode_ecb_encrypt,
+			.decrypt		=	geode_ecb_decrypt,
+		}
+	}
+};
+
+static void
+geode_aes_remove(struct pci_dev *dev)
+{
+	crypto_unregister_alg(&amp;geode_alg);
+	crypto_unregister_alg(&amp;geode_ecb_alg);
+	crypto_unregister_alg(&amp;geode_cbc_alg);
+
+	pci_iounmap(dev, _iobase);
+	_iobase = NULL;
+
+	pci_release_regions(dev);
+	pci_disable_device(dev);
+}
+
+
+static int
+geode_aes_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int ret;
+
+	if ((ret = pci_enable_device(dev)))
+		return ret;
+
+	if ((ret = pci_request_regions(dev, "geode-aes-128")))
+		goto eenable;
+
+	_iobase = pci_iomap(dev, 0, 0);
+
+	if (_iobase == NULL) {
+		ret = -ENOMEM;
+		goto erequest;
+	}
+
+	spin_lock_init(&amp;lock);
+
+	/* Clear any pending activity */
+	AWRITE(AES_INTR_PENDING | AES_INTR_MASK, AES_INTR_REG);
+
+	if ((ret = crypto_register_alg(&amp;geode_alg)))
+		goto eiomap;
+
+	if ((ret = crypto_register_alg(&amp;geode_ecb_alg)))
+		goto ealg;
+
+	if ((ret = crypto_register_alg(&amp;geode_cbc_alg)))
+		goto eecb;
+
+	printk(KERN_NOTICE "geode-aes: GEODE AES engine enabled.\n");
+	return 0;
+
+ eecb:
+	crypto_unregister_alg(&amp;geode_ecb_alg);
+
+ ealg:
+	crypto_unregister_alg(&amp;geode_alg);
+
+ eiomap:
+	pci_iounmap(dev, _iobase);
+
+ erequest:
+	pci_release_regions(dev);
+
+ eenable:
+	pci_disable_device(dev);
+
+	printk(KERN_ERR "geode-aes:  GEODE AES initialization failed.\n");
+	return ret;
+}
+
+struct pci_device_id geode_aes_tbl[] = {
+	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_LX_AES, PCI_ANY_ID, PCI_ANY_ID} ,
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, geode_aes_tbl);
+
+static struct pci_driver geode_aes_driver = {
+	name:      "Geode LX AES",
+	id_table:  geode_aes_tbl,
+	probe:     geode_aes_probe,
+	remove:    __devexit_p(geode_aes_remove)
+};
+
+static int __devinit
+geode_aes_init(void)
+{
+	return pci_module_init(&amp;geode_aes_driver);
+}
+
+static void __devexit
+geode_aes_exit(void)
+{
+	pci_unregister_driver(&amp;geode_aes_driver);
+}
+
+MODULE_AUTHOR("Advanced Micro Devices, Inc.");
+MODULE_DESCRIPTION("Geode LX Hardware AES driver");
+MODULE_LICENSE("GPL");
+
+module_init(geode_aes_init);
+module_exit(geode_aes_exit);
diff --git a/drivers/crypto/geode-aes.h b/drivers/crypto/geode-aes.h
new file mode 100644
index 0000000..97f9eee
--- /dev/null
+++ b/drivers/crypto/geode-aes.h
@@ -0,0 +1,42 @@
+/* Copyright (C) 2003-2006, Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _GEODE_AES_H_
+#define _GEODE_AES_H_
+
+#define AES_KEY_LENGTH 16
+#define AES_IV_LENGTH  16
+
+#define AES_MIN_BLOCK_SIZE 16
+
+#define AES_MODE_ECB 0
+#define AES_MODE_CBC 1
+
+#define AES_DIR_DECRYPT 0
+#define AES_DIR_ENCRYPT 1
+
+#define AES_FLAGS_USRKEY   (1 &lt;&lt; 0)
+#define AES_FLAGS_COHERENT (1 &lt;&lt; 1)
+
+struct geode_aes_op {
+
+  void *src;
+  void *dst;
+
+  u32 mode;
+  u32 dir;
+  u32 flags;
+  int len;
+
+  u8 key[AES_KEY_LENGTH];
+  u8 iv[AES_IV_LENGTH];
+};
+
+unsigned int geode_aes_crypt(struct geode_aes_op *);
+
+#endif

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060928220609</emailId><senderName>Andrew Morton</senderName><senderEmail>akpm@osdl.org</senderEmail><timestampReceived>2006-09-28 22:06:09-0400</timestampReceived><subject>Re: crypto: Add support for the Geode AES engine (v2)</subject><body>

On Thu, 28 Sep 2006 15:47:50 -0600
"Jordan Crouse" &lt;jordan.crouse@amd.com&gt; wrote:

&gt; &gt; As far as I can see, register access is not protected, how can your
&gt; &gt; driver handle the case when dm-crypt and IPsec simultaneously try to
&gt; &gt; encrypt/decrypt some data, it can happen even around 
&gt; &gt; preemt_disable/enable calls and actually crypto processing can happen 
&gt; &gt; in interrupt context too (although it is not the best thing to do).
&gt; 
&gt; I was sitting there trying to architect some grand scheme, and then it
&gt; occured to me that we should just turn off the interrupts all together
&gt; in the critical area.  Its not optimal for performance, but it
&gt; avoids lots of crazy if statements.
&gt; 
&gt; &gt; You added timeout for the broken hardware condition, I think it is
&gt; &gt; better to return some error from _crypt() in that case, and, btw, that
&gt; &gt; name is not very good choice.
&gt; 
&gt; Fixed the name and I return the error.  I don't propagate it through the
&gt; whole chain, because quite frankly, if the crypto engine fails, then its
&gt; a good bet the processor is on fire. :)
&gt; 
&gt; ...
&gt;



&gt; diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
&gt; index adb5541..e816535 100644
&gt; --- a/drivers/crypto/Kconfig
&gt; +++ b/drivers/crypto/Kconfig
&gt; @@ -51,4 +51,17 @@ config CRYPTO_DEV_PADLOCK_SHA
&gt;  	  If unsure say M. The compiled module will be
&gt;  	  called padlock-sha.ko
&gt;  
&gt; +config CRYPTO_DEV_GEODE
&gt; +	tristate "Support for the Geode LX AES engine"
&gt; +	depends on CRYPTO &amp;&amp; X86_32

Does it depend on GEODE in some fashion too?

&gt; +	select CRYPTO_ALGAPI
&gt; +	select CRYPTO_BLKCIPHER
&gt; +	default m
&gt; +	help
&gt; +	  Say 'Y' here to use the AMD Geode LX processor on-board AES
&gt; +	  engine for the CryptoAPI AES alogrithm.
&gt; +
&gt; +	  To compile this driver as a module, choose M here: the module
&gt; +	  will be called geode-aes.
&gt; +
&gt;  endmenu
&gt; 
&gt; ...
&gt;
&gt; +
&gt; +/* Useful macros */
&gt; +
&gt; +#define SET_KEY(key) _writefield(AES_WRITEKEY0_REG, key)
&gt; +#define SET_IV(iv)   _writefield(AES_WRITEIV0_REG, iv)
&gt; +#define GET_IV(iv)   _readfield(AES_WRITEIV0_REG, iv)
&gt; +#define AWRITE(val, reg) (iowrite32(val, _iobase + reg))
&gt; +#define AREAD(reg)  (ioread32(_iobase + reg))

lower-case static-inlines are nicer...

Or just remove them and open-code it all.

&gt; +/* Static structures */
&gt; +
&gt; +static void __iomem * _iobase;
&gt; +
&gt; +/* Write a 128 bit field (either a writable key or IV) */
&gt; +static inline void
&gt; +_writefield(u32 offset, void *value)
&gt; +{
&gt; +	int i;
&gt; +	for(i = 0; i &lt; 4; i++)
&gt; +		AWRITE(((u32 *) value)[i], offset + (i * 4));
&gt; +}
&gt;
&gt; +/* Read a 128 bit field (either a writable key or IV) */
&gt; +static inline void
&gt; +_readfield(u32 offset, void *value)
&gt; +{
&gt; +	int i;
&gt; +	for(i = 0; i &lt; 4; i++)
&gt; +		((u32 *) value)[i] = AREAD(offset + (i * 4));
&gt; +}
&gt; +
&gt; ...
&gt;
&gt; +unsigned int
&gt; +geode_aes_crypt(struct geode_aes_op *op)
&gt; +{
&gt; +	u32 flags = 0;
&gt; +	int iflags;
&gt; +
&gt; +	if (op-&gt;len == 0 || op-&gt;src == op-&gt;dst)
&gt; +		return 0;
&gt; +
&gt; +	if (op-&gt;flags &amp; AES_FLAGS_COHERENT)
&gt; +		flags |= (AES_CTRL_DCA | AES_CTRL_SCA);
&gt; +
&gt; +	if (op-&gt;dir == AES_DIR_ENCRYPT)
&gt; +		flags |= AES_CTRL_ENCRYPT;
&gt; +
&gt; +	/* Start the critical section */
&gt; +
&gt; +	spin_lock_irqsave(&amp;lock, iflags);
&gt; +
&gt; +	if (op-&gt;mode == AES_MODE_CBC) {
&gt; +		flags |= AES_CTRL_CBC;
&gt; +		SET_IV(op-&gt;iv);
&gt; +	}
&gt; +
&gt; +	if (op-&gt;flags &amp; AES_FLAGS_USRKEY) {
&gt; +		flags |= AES_CTRL_WRKEY;
&gt; +		SET_KEY(op-&gt;key);
&gt; +	}
&gt; +
&gt; +	do_crypt(op-&gt;src, op-&gt;dst, op-&gt;len, flags);
&gt; +
&gt; +	if (op-&gt;mode == AES_MODE_CBC)
&gt; +		GET_IV(op-&gt;iv);
&gt; +
&gt; +	spin_lock_irqrestore(&amp;lock, iflags);
&gt; +
&gt; +	return op-&gt;len;
&gt; +}

Running do_crypt() under spin_lock_irqsave() seems a bit sad from a latency
POV.

&gt; +/* CRYPTO-API Functions */
&gt; +
&gt; +#define blk_ctx(tfm) ((struct geode_aes_op *) crypto_blkcipher_ctx(tfm))
&gt; +#define ctx(tfm) ((struct geode_aes_op *) crypto_tfm_ctx(tfm))

Both crypto_blkcipher_ctx() and crypto_tfm_ctx() return a nice void*. 
There's no need for the typecast and hence there's really no need for these
macros at all.  Simply open-code the crypto_blkcipher_ctx() and
crypto_tfm_ctx() calls.

&gt; +static int
&gt; +geode_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int len)
&gt; +{
&gt; +	struct geode_aes_op *op = ctx(tfm);
&gt; +
&gt; +	if (len != AES_KEY_LENGTH) {
&gt; +		tfm-&gt;crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
&gt; +		return -EINVAL;
&gt; +	}
&gt; +
&gt; +	memcpy(op-&gt;key, key, len);
&gt; +	return 0;
&gt; +}
&gt; +
&gt; +static void
&gt; +geode_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
&gt; +{
&gt; +	struct geode_aes_op *op = ctx(tfm);
&gt; +
&gt; +	if ((out == NULL) || (in == NULL))
&gt; +		return;
&gt; +
&gt; +	op-&gt;src = (void *) in;
&gt; +	op-&gt;dst = (void *) out;

Unneeded casts

&gt; +	op-&gt;mode = AES_MODE_ECB;
&gt; +	op-&gt;flags = 0;
&gt; +	op-&gt;len = AES_MIN_BLOCK_SIZE;
&gt; +	op-&gt;dir = AES_DIR_ENCRYPT;
&gt; +
&gt; +	geode_aes_crypt(op);
&gt; +}
&gt; +
&gt; +
&gt; +static void
&gt; +geode_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
&gt; +{
&gt; +	struct geode_aes_op *op = ctx(tfm);
&gt; +
&gt; +	if ((out == NULL) || (in == NULL))
&gt; +		return;
&gt; +
&gt; +	op-&gt;src = (void *) in;
&gt; +	op-&gt;dst = (void *) out;

Unneeded casts

&gt; +static int
&gt; +geode_cbc_decrypt(struct blkcipher_desc *desc,
&gt; +		  struct scatterlist *dst, struct scatterlist *src,
&gt; +		  unsigned int nbytes)
&gt; +{
&gt; +	struct geode_aes_op *op = blk_ctx(desc-&gt;tfm);
&gt; +	struct blkcipher_walk walk;
&gt; +	int err, ret;
&gt; +
&gt; +	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
&gt; +	err = blkcipher_walk_virt(desc, &amp;walk);
&gt; +
&gt; +	while((nbytes = walk.nbytes)) {
&gt; +		op-&gt;src = (void *) walk.src.virt.addr,
&gt; +		op-&gt;dst = (void *) walk.dst.virt.addr;

Unneeded cast

&gt; +		op-&gt;mode = AES_MODE_CBC;
&gt; +		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
&gt; +		op-&gt;dir = AES_DIR_DECRYPT;
&gt; +
&gt; +		memcpy(op-&gt;iv, walk.iv, AES_IV_LENGTH);
&gt; +
&gt; +		ret = geode_aes_crypt(op);
&gt; +
&gt; +		memcpy(walk.iv, op-&gt;iv, AES_IV_LENGTH);
&gt; +		nbytes -= ret;
&gt; +
&gt; +		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
&gt; +	}
&gt; +
&gt; +	return err;
&gt; +}
&gt;
&gt; ...
&gt;

&gt; +		op-&gt;src = (void *) walk.src.virt.addr,
&gt; +		op-&gt;dst = (void *) walk.dst.virt.addr;

Unneeded cast.  Please review whole patchset.

&gt; +struct pci_device_id geode_aes_tbl[] = {
&gt; +	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_LX_AES, PCI_ANY_ID, PCI_ANY_ID} ,
&gt; +	{ 0, }
&gt; +};

static?

&gt; +static struct pci_driver geode_aes_driver = {
&gt; +	name:      "Geode LX AES",
&gt; +	id_table:  geode_aes_tbl,
&gt; +	probe:     geode_aes_probe,
&gt; +	remove:    __devexit_p(geode_aes_remove)
&gt; +};

Please use `.name = value'

&gt; +static int __devinit
&gt; +geode_aes_init(void)
&gt; +{
&gt; +	return pci_module_init(&amp;geode_aes_driver);
&gt; +}
&gt; +
&gt; +static void __devexit
&gt; +geode_aes_exit(void)
&gt; +{
&gt; +	pci_unregister_driver(&amp;geode_aes_driver);
&gt; +}

These should be __init and __exit, I think?

&gt; +struct geode_aes_op {
&gt; +
&gt; +  void *src;
&gt; +  void *dst;
&gt; +
&gt; +  u32 mode;
&gt; +  u32 dir;
&gt; +  u32 flags;
&gt; +  int len;
&gt; +
&gt; +  u8 key[AES_KEY_LENGTH];
&gt; +  u8 iv[AES_IV_LENGTH];
&gt; +};

tabs, please.


-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060928231739</emailId><senderName>"Jordan Crouse"</senderName><senderEmail>jordan.crouse@amd.com</senderEmail><timestampReceived>2006-09-28 23:17:39-0400</timestampReceived><subject>Re: crypto: Add support for the Geode AES engine (v4)</subject><body>

&gt; Does it depend on GEODE in some fashion too?

Its only available on the Geode platform, but there is no code it needs 
that is only exposed by CONFIG_MGEODE_LX elsewhere in the kernel.  This is
just appears as a regular, run of the mill PCI device.

&gt; &gt; +	spin_lock_irqsave(&amp;lock, iflags);
&gt; &gt; +
&gt; &gt; +	if (op-&gt;mode == AES_MODE_CBC) {
&gt; &gt; +		flags |= AES_CTRL_CBC;
&gt; &gt; +		SET_IV(op-&gt;iv);
&gt; &gt; +	}
&gt; &gt; +
&gt; &gt; +	if (op-&gt;flags &amp; AES_FLAGS_USRKEY) {
&gt; &gt; +		flags |= AES_CTRL_WRKEY;
&gt; &gt; +		SET_KEY(op-&gt;key);
&gt; &gt; +	}
&gt; &gt; +
&gt; &gt; +	do_crypt(op-&gt;src, op-&gt;dst, op-&gt;len, flags);
&gt; &gt; +
&gt; &gt; +	if (op-&gt;mode == AES_MODE_CBC)
&gt; &gt; +		GET_IV(op-&gt;iv);
&gt; &gt; +
&gt; &gt; +	spin_lock_irqrestore(&amp;lock, iflags);
&gt; &gt; +
&gt; &gt; +	return op-&gt;len;
&gt; &gt; +}
&gt; 
&gt; Running do_crypt() under spin_lock_irqsave() seems a bit sad from a latency
&gt; POV.

Indeed - but the problem is that the key and/or the IV need to stay
unmodified until the operation completes.  The datasheet calls this 
out specifically:

"This register should not be changed during an AES encryption or decryption 
operation."

So not only do we need to protect ourselves while changing the fields, we
also need to make sure they remain untouched until the whole operation is
completed. 

Changes made and new version follows. Thanks for the comments.

Jordan
-- 
Jordan Crouse
Senior Linux Engineer
Advanced Micro Devices, Inc.
&lt;www.amd.com/embeddedprocessors&gt;

["geode-lx-crypto.patch" (text/plain)]

[PATCH] crypto:  Add support for the Geode LX AES hardware

Add a driver to support the AES hardware on the Geode LX processor.

Signed-off-by: Jordan Crouse &lt;jordan.crouse@amd.com&gt;
diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index adb5541..e816535 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -51,4 +51,17 @@ config CRYPTO_DEV_PADLOCK_SHA
 	  If unsure say M. The compiled module will be
 	  called padlock-sha.ko
 
+config CRYPTO_DEV_GEODE
+	tristate "Support for the Geode LX AES engine"
+	depends on CRYPTO &amp;&amp; X86_32
+	select CRYPTO_ALGAPI
+	select CRYPTO_BLKCIPHER
+	default m
+	help
+	  Say 'Y' here to use the AMD Geode LX processor on-board AES
+	  engine for the CryptoAPI AES alogrithm.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called geode-aes.
+
 endmenu
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index 4c3d0ec..6059cf8 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -1,3 +1,4 @@
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK) += padlock.o
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK_AES) += padlock-aes.o
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK_SHA) += padlock-sha.o
+obj-$(CONFIG_CRYPTO_DEV_GEODE) += geode-aes.o
diff --git a/drivers/crypto/geode-aes.c b/drivers/crypto/geode-aes.c
new file mode 100644
index 0000000..da2d35d
--- /dev/null
+++ b/drivers/crypto/geode-aes.c
@@ -0,0 +1,474 @@
+ /* Copyright (C) 2004-2006, Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/sched.h&gt;
+#include &lt;linux/pci.h&gt;
+#include &lt;linux/pci_ids.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/spinlock.h&gt;
+#include &lt;crypto/algapi.h&gt;
+
+#include &lt;asm/io.h&gt;
+#include &lt;asm/delay.h&gt;
+
+#include "geode-aes.h"
+
+/* Register definitions */
+
+#define AES_CTRLA_REG  0x0000
+
+#define AES_CTRL_START     0x01
+#define AES_CTRL_DECRYPT   0x00
+#define AES_CTRL_ENCRYPT   0x02
+#define AES_CTRL_WRKEY     0x04
+#define AES_CTRL_DCA       0x08
+#define AES_CTRL_SCA       0x10
+#define AES_CTRL_CBC       0x20
+
+#define AES_INTR_REG  0x0008
+
+#define AES_INTRA_PENDING (1 &lt;&lt; 16)
+#define AES_INTRB_PENDING (1 &lt;&lt; 17)
+
+#define AES_INTR_PENDING  (AES_INTRA_PENDING | AES_INTRB_PENDING)
+#define AES_INTR_MASK     0x07
+
+#define AES_SOURCEA_REG   0x0010
+#define AES_DSTA_REG      0x0014
+#define AES_LENA_REG      0x0018
+#define AES_WRITEKEY0_REG 0x0030
+#define AES_WRITEIV0_REG  0x0040
+
+/*  A very large counter that is used to gracefully bail out of an
+ *  operation in case of trouble
+ */
+
+#define AES_OP_TIMEOUT    0x50000
+
+/* Static structures */
+
+static void __iomem * _iobase;
+static spinlock_t lock;
+
+/* Write a 128 bit field (either a writable key or IV) */
+static inline void
+_writefield(u32 offset, void *value)
+{
+	int i;
+	for(i = 0; i &lt; 4; i++)
+		iowrite32(((u32 *) value)[i], _iobase + offset + (i * 4));
+}
+
+/* Read a 128 bit field (either a writable key or IV) */
+static inline void
+_readfield(u32 offset, void *value)
+{
+	int i;
+	for(i = 0; i &lt; 4; i++)
+		((u32 *) value)[i] = ioread32(_iobase + offset + (i * 4));
+}
+
+static int
+do_crypt(void *src, void *dst, int len, u32 flags)
+{
+	u32 status;
+	u32 counter = AES_OP_TIMEOUT;
+
+	iowrite32(virt_to_phys(src), _iobase + AES_SOURCEA_REG);
+	iowrite32(virt_to_phys(dst), _iobase + AES_DSTA_REG);
+	iowrite32(len,  _iobase + AES_LENA_REG);
+
+	/* Start the operation */
+	iowrite32(AES_CTRL_START | flags, _iobase + AES_CTRLA_REG);
+
+	do
+		status = ioread32(_iobase + AES_INTR_REG);
+	while(!(status &amp; AES_INTRA_PENDING) &amp;&amp; --counter);
+
+	/* Clear the event */
+	iowrite32((status &amp; 0xFF) | AES_INTRA_PENDING, _iobase + AES_INTR_REG);
+	return counter ? 0 : 1;
+}
+
+unsigned int
+geode_aes_crypt(struct geode_aes_op *op)
+{
+
+	u32 flags = 0;
+	int iflags;
+
+	if (op-&gt;len == 0 || op-&gt;src == op-&gt;dst)
+		return 0;
+
+	if (op-&gt;flags &amp; AES_FLAGS_COHERENT)
+		flags |= (AES_CTRL_DCA | AES_CTRL_SCA);
+
+	if (op-&gt;dir == AES_DIR_ENCRYPT)
+		flags |= AES_CTRL_ENCRYPT;
+
+	/* Start the critical section */
+
+	spin_lock_irqsave(&amp;lock, iflags);
+
+	if (op-&gt;mode == AES_MODE_CBC) {
+		flags |= AES_CTRL_CBC;
+		_writefield(AES_WRITEIV0_REG, op-&gt;iv);
+	}
+
+	if (op-&gt;flags &amp; AES_FLAGS_USRKEY) {
+		flags |= AES_CTRL_WRKEY;
+		_writefield(AES_WRITEKEY0_REG, op-&gt;key);
+	}
+
+	do_crypt(op-&gt;src, op-&gt;dst, op-&gt;len, flags);
+
+	if (op-&gt;mode == AES_MODE_CBC)
+		_readfield(AES_WRITEIV0_REG, op-&gt;iv);
+
+	spin_unlock_irqrestore(&amp;lock, iflags);
+
+	return op-&gt;len;
+}
+
+/* CRYPTO-API Functions */
+
+static int
+geode_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int len)
+{
+	struct geode_aes_op *op = crypto_tfm_ctx(tfm);
+
+	if (len != AES_KEY_LENGTH) {
+		tfm-&gt;crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
+		return -EINVAL;
+	}
+
+	memcpy(op-&gt;key, key, len);
+	return 0;
+}
+
+static void
+geode_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
+{
+	struct geode_aes_op *op = crypto_tfm_ctx(tfm);
+
+	if ((out == NULL) || (in == NULL))
+		return;
+
+	op-&gt;src = (void *) in;
+	op-&gt;dst = (void *) out;
+	op-&gt;mode = AES_MODE_ECB;
+	op-&gt;flags = 0;
+	op-&gt;len = AES_MIN_BLOCK_SIZE;
+	op-&gt;dir = AES_DIR_ENCRYPT;
+
+	geode_aes_crypt(op);
+}
+
+
+static void
+geode_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
+{
+	struct geode_aes_op *op = crypto_tfm_ctx(tfm);
+
+	if ((out == NULL) || (in == NULL))
+		return;
+
+	op-&gt;src = (void *) in;
+	op-&gt;dst = (void *) out;
+	op-&gt;mode = AES_MODE_ECB;
+	op-&gt;flags = 0;
+	op-&gt;len = AES_MIN_BLOCK_SIZE;
+	op-&gt;dir = AES_DIR_DECRYPT;
+
+	geode_aes_crypt(op);
+}
+
+
+static struct crypto_alg geode_alg = {
+	.cra_name               =       "aes",
+	.cra_driver_name	=       "geode-aes-128",
+	.cra_priority           =       300,
+	.cra_alignmask          =       15,
+	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct geode_aes_op),
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(geode_alg.cra_list),
+	.cra_u			=	{
+		.cipher = {
+			.cia_min_keysize	=  AES_KEY_LENGTH,
+			.cia_max_keysize	=  AES_KEY_LENGTH,
+			.cia_setkey		=  geode_setkey,
+			.cia_encrypt		=  geode_encrypt,
+			.cia_decrypt		=  geode_decrypt
+		}
+	}
+};
+
+static int
+geode_cbc_decrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = walk.src.virt.addr,
+		op-&gt;dst = walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_CBC;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_DECRYPT;
+
+		memcpy(op-&gt;iv, walk.iv, AES_IV_LENGTH);
+
+		ret = geode_aes_crypt(op);
+
+		memcpy(walk.iv, op-&gt;iv, AES_IV_LENGTH);
+		nbytes -= ret;
+
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static int
+geode_cbc_encrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = walk.src.virt.addr,
+		op-&gt;dst = walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_CBC;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_ENCRYPT;
+
+		memcpy(op-&gt;iv, walk.iv, AES_IV_LENGTH);
+
+		ret = geode_aes_crypt(op);
+		nbytes -= ret;
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static struct crypto_alg geode_cbc_alg = {
+	.cra_name		=	"cbc(aes)",
+	.cra_driver_name	=	"cbc-aes-geode-128",
+	.cra_priority		=	400,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct geode_aes_op),
+	.cra_alignmask		=	15,
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(geode_cbc_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	AES_KEY_LENGTH,
+			.max_keysize		=	AES_KEY_LENGTH,
+			.setkey			=	geode_setkey,
+			.encrypt		=	geode_cbc_encrypt,
+			.decrypt		=	geode_cbc_decrypt,
+		}
+	}
+};
+
+static int
+geode_ecb_decrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = walk.src.virt.addr,
+		op-&gt;dst = walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_ECB;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_DECRYPT;
+
+		ret = geode_aes_crypt(op);
+		nbytes -= ret;
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static int
+geode_ecb_encrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = walk.src.virt.addr,
+		op-&gt;dst = walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_ECB;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_ENCRYPT;
+
+		ret = geode_aes_crypt(op);
+		nbytes -= ret;
+		ret =  blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static struct crypto_alg geode_ecb_alg = {
+	.cra_name		=	"ecb(aes)",
+	.cra_driver_name	=	"ecb-aes-geode-128",
+	.cra_priority		=	400,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct geode_aes_op),
+	.cra_alignmask		=	15,
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(geode_ecb_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	AES_KEY_LENGTH,
+			.max_keysize		=	AES_KEY_LENGTH,
+			.setkey			=	geode_setkey,
+			.encrypt		=	geode_ecb_encrypt,
+			.decrypt		=	geode_ecb_decrypt,
+		}
+	}
+};
+
+static void
+geode_aes_remove(struct pci_dev *dev)
+{
+	crypto_unregister_alg(&amp;geode_alg);
+	crypto_unregister_alg(&amp;geode_ecb_alg);
+	crypto_unregister_alg(&amp;geode_cbc_alg);
+
+	pci_iounmap(dev, _iobase);
+	_iobase = NULL;
+
+	pci_release_regions(dev);
+	pci_disable_device(dev);
+}
+
+
+static int
+geode_aes_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int ret;
+
+	if ((ret = pci_enable_device(dev)))
+		return ret;
+
+	if ((ret = pci_request_regions(dev, "geode-aes-128")))
+		goto eenable;
+
+	_iobase = pci_iomap(dev, 0, 0);
+
+	if (_iobase == NULL) {
+		ret = -ENOMEM;
+		goto erequest;
+	}
+
+	spin_lock_init(&amp;lock);
+
+	/* Clear any pending activity */
+	iowrite32(AES_INTR_PENDING | AES_INTR_MASK, _iobase + AES_INTR_REG);
+
+	if ((ret = crypto_register_alg(&amp;geode_alg)))
+		goto eiomap;
+
+	if ((ret = crypto_register_alg(&amp;geode_ecb_alg)))
+		goto ealg;
+
+	if ((ret = crypto_register_alg(&amp;geode_cbc_alg)))
+		goto eecb;
+
+	printk(KERN_NOTICE "geode-aes: GEODE AES engine enabled.\n");
+	return 0;
+
+ eecb:
+	crypto_unregister_alg(&amp;geode_ecb_alg);
+
+ ealg:
+	crypto_unregister_alg(&amp;geode_alg);
+
+ eiomap:
+	pci_iounmap(dev, _iobase);
+
+ erequest:
+	pci_release_regions(dev);
+
+ eenable:
+	pci_disable_device(dev);
+
+	printk(KERN_ERR "geode-aes:  GEODE AES initialization failed.\n");
+	return ret;
+}
+
+static struct pci_device_id geode_aes_tbl[] = {
+	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_LX_AES, PCI_ANY_ID, PCI_ANY_ID} ,
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, geode_aes_tbl);
+
+static struct pci_driver geode_aes_driver = {
+	.name = "Geode LX AES",
+	.id_table = geode_aes_tbl,
+	.probe = geode_aes_probe,
+	.remove = __devexit_p(geode_aes_remove)
+};
+
+static int __init
+geode_aes_init(void)
+{
+	return pci_module_init(&amp;geode_aes_driver);
+}
+
+static void __exit
+geode_aes_exit(void)
+{
+	pci_unregister_driver(&amp;geode_aes_driver);
+}
+
+MODULE_AUTHOR("Advanced Micro Devices, Inc.");
+MODULE_DESCRIPTION("Geode LX Hardware AES driver");
+MODULE_LICENSE("GPL");
+
+module_init(geode_aes_init);
+module_exit(geode_aes_exit);
diff --git a/drivers/crypto/geode-aes.h b/drivers/crypto/geode-aes.h
new file mode 100644
index 0000000..3e3a571
--- /dev/null
+++ b/drivers/crypto/geode-aes.h
@@ -0,0 +1,42 @@
+/* Copyright (C) 2003-2006, Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _GEODE_AES_H_
+#define _GEODE_AES_H_
+
+#define AES_KEY_LENGTH 16
+#define AES_IV_LENGTH  16
+
+#define AES_MIN_BLOCK_SIZE 16
+
+#define AES_MODE_ECB 0
+#define AES_MODE_CBC 1
+
+#define AES_DIR_DECRYPT 0
+#define AES_DIR_ENCRYPT 1
+
+#define AES_FLAGS_USRKEY   (1 &lt;&lt; 0)
+#define AES_FLAGS_COHERENT (1 &lt;&lt; 1)
+
+struct geode_aes_op {
+
+	void *src;
+	void *dst;
+
+	u32 mode;
+	u32 dir;
+	u32 flags;
+	int len;
+
+	u8 key[AES_KEY_LENGTH];
+	u8 iv[AES_IV_LENGTH];
+};
+
+unsigned int geode_aes_crypt(struct geode_aes_op *);
+
+#endif

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060928235421</emailId><senderName>Andrew Morton</senderName><senderEmail>akpm@osdl.org</senderEmail><timestampReceived>2006-09-28 23:54:21-0400</timestampReceived><subject>Re: crypto: Add support for the Geode AES engine (v4)</subject><body>

On Thu, 28 Sep 2006 17:17:39 -0600
"Jordan Crouse" &lt;jordan.crouse@amd.com&gt; wrote:

&gt; Add a driver to support the AES hardware on the Geode LX processor.

So... what are you planning on doing with this?  Ask Linus to pull
that git tree, or what?
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060929001624</emailId><senderName>"Jordan Crouse"</senderName><senderEmail>jordan.crouse@amd.com</senderEmail><timestampReceived>2006-09-29 00:16:24-0400</timestampReceived><subject>Re: crypto: Add support for the Geode AES engine (v4)</subject><body>

On 28/09/06 16:54 -0700, Andrew Morton wrote:
&gt; On Thu, 28 Sep 2006 17:17:39 -0600
&gt; "Jordan Crouse" &lt;jordan.crouse@amd.com&gt; wrote:
&gt; 
&gt; &gt; Add a driver to support the AES hardware on the Geode LX processor.
&gt; 
&gt; So... what are you planning on doing with this?  Ask Linus to pull
&gt; that git tree, or what?

Good question - I guess I'm not sure what the correct protocol is here.  
I should have done this long ago, so I was ready for the 2.6.19 window. 
I also should have gotten it to the crypto guys first, before putting it
in the Geode tree. I guess I never really expected it to be in 2.6.19,
I just wanted to get this cleaned up and shipped off.  It was mocking me
sitting there slowly bit rotting.

As it stands, I think the right move is to get it into the crypto tree to
patiently await 2.6.20.   

Jordan

-- 
Jordan Crouse
Senior Linux Engineer
Advanced Micro Devices, Inc.
&lt;www.amd.com/embeddedprocessors&gt;


-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061004085214</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-10-04 08:52:14-0400</timestampReceived><subject>Re: crypto: Add support for the Geode AES engine (v4)</subject><body>

On Thu, Sep 28, 2006 at 11:17:39PM +0000, Jordan Crouse wrote:
&gt; 
&gt; Changes made and new version follows. Thanks for the comments.

Patch applied.  Thanks everybody.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061013171820</emailId><senderName>Michael Frey</senderName><senderEmail>mfrey@pepper.com</senderEmail><timestampReceived>2006-10-13 17:18:20-0400</timestampReceived><subject>Re: crypto: Add support for the Geode AES engine (v4)</subject><body>

Does this patch support the eeprom on the AES module?

Also,  Can this patch be used on a 2.6.18 kernel?

Thanks,
Michael

On Oct 4, 2006, at 4:52 AM, Herbert Xu wrote:

&gt; On Thu, Sep 28, 2006 at 11:17:39PM +0000, Jordan Crouse wrote:
&gt;&gt;
&gt;&gt; Changes made and new version follows. Thanks for the comments.
&gt;
&gt; Patch applied.  Thanks everybody.
&gt;
&gt; Cheers,
&gt; -- 
&gt; Visit Openswan at http://www.openswan.org/
&gt; Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
&gt; Home Page: http://gondor.apana.org.au/~herbert/
&gt; PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
&gt;
&gt;
&gt;
&gt; ---
&gt; You are currently subscribed to info-linux@geode.amd.com
&gt; as: mfrey@pepper.com
&gt; To unsubscribe send a blank email to:
&gt; leave-info-linux-7332K@whitestar.amd.com
&gt;

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060505162642</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-05-05 16:26:42-0400</timestampReceived><subject>Re: proposed scenario for cryptoapi</subject><body>

On Fri, May 05, 2006 at 12:03:13PM -0400, Michael Richardson (mcr@sandelman.ottawa.on.ca) wrote:
&gt; I would propose that we either use cryptoapi@, or that a new list be
&gt; formed.

I've replaced cryptoapi@ with linux-crypto@, since cryptoapi@ was closed
quite long ago and linux-crypto@ created instead.

I understand that this discussion is not linux-only.

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702141924</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-02 14:19:24-0400</timestampReceived><subject>[1/13] [CRYPTO] api: Rename crypto_alg_get to crypto_mod_get</subject><body>

Hi:

[CRYPTO] api: Rename crypto_alg_get to crypto_mod_get

The functions crypto_alg_get and crypto_alg_put operates on the crypto
modules rather than the algorithms.  Therefore it makes sense to call
them crypto_mod_get and crypto_alg_put respectively.

This is needed because we need to have real algorithm reference counters
for parameterised algorithms as they can be unregistered from below by
when their parameter algorithms are themselves unregistered.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -29,12 +29,12 @@
 LIST_HEAD(crypto_alg_list);
 DECLARE_RWSEM(crypto_alg_sem);
 
-static inline int crypto_alg_get(struct crypto_alg *alg)
+static inline int crypto_mod_get(struct crypto_alg *alg)
 {
 	return try_module_get(alg-&gt;cra_module);
 }
 
-static inline void crypto_alg_put(struct crypto_alg *alg)
+static inline void crypto_mod_put(struct crypto_alg *alg)
 {
 	module_put(alg-&gt;cra_module);
 }
@@ -57,12 +57,12 @@ static struct crypto_alg *crypto_alg_loo
 		if (!exact &amp;&amp; !(fuzzy &amp;&amp; q-&gt;cra_priority &gt; best))
 			continue;
 
-		if (unlikely(!crypto_alg_get(q)))
+		if (unlikely(!crypto_mod_get(q)))
 			continue;
 
 		best = q-&gt;cra_priority;
 		if (alg)
-			crypto_alg_put(alg);
+			crypto_mod_put(alg);
 		alg = q;
 
 		if (exact)
@@ -202,7 +202,7 @@ out_free_tfm:
 	kfree(tfm);
 	tfm = NULL;
 out_put:
-	crypto_alg_put(alg);
+	crypto_mod_put(alg);
 out:
 	return tfm;
 }
@@ -221,7 +221,7 @@ void crypto_free_tfm(struct crypto_tfm *
 	if (alg-&gt;cra_exit)
 		alg-&gt;cra_exit(tfm);
 	crypto_exit_ops(tfm);
-	crypto_alg_put(alg);
+	crypto_mod_put(alg);
 	memset(tfm, 0, size);
 	kfree(tfm);
 }
@@ -305,7 +305,7 @@ int crypto_alg_available(const char *nam
 	struct crypto_alg *alg = crypto_alg_mod_lookup(name);
 	
 	if (alg) {
-		crypto_alg_put(alg);
+		crypto_mod_put(alg);
 		ret = 1;
 	}
 	
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060801011610</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-08-01 01:16:10-0400</timestampReceived><subject>crypto-root-fs via debian-netinst.iso (dailybuild) ? - NOT YET -</subject><body>

What I, Reverend, experienced (01.Aug.2006):

I tryed the newest iso's from the 28. and 31.July 2006 to get  strong root-fs-
encryption with dm-crypt or loop-AES.-

1.) The installer lets you choose between dm-crypt or loop-AES,   -fine.

2.) You than want to partition with crypto-features and than manage the partitions
     with format, Mountpoints, etc..
     I tryed 8 to 10 times to found a way to partition AND manage the partitions
     but I could only do once. If I choose what looks like encryption, than the
     Mountpoints where not there, unreachable to me, or I could reach and set
     the Mountpoints and could not encrypt anything.

3.) If you choose loop-AES, what I did several times and you go the sensless
     way of encryption without Mountpoints, you reach the point where you
     must strike the keyboard (not mouse) maybe thousands of time to get, what
     looks to be the /dev/random-reservoir for the gpg-key to make.
     After 10 minutes or so the responsible menupoint crashes without warning,
     I tryed this about 5 times.

I am waiting for newer netinst.iso's to come and will report if usefull.

           regards,         Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060801080018</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-08-01 08:00:18-0400</timestampReceived><subject>Re: crypto-root-fs via debian-netinst.iso (dailybuild) ? - NOT YET -</subject><body>

Hi Reverend,

On Tue, Aug 01, 2006 at 03:16:10AM +0200, reverend@Safe-mail.net wrote:
&gt; What I, Reverend, experienced (01.Aug.2006):
&gt; 
&gt; I tryed the newest iso's from the 28. and 31.July 2006 to get  strong root-fs-
&gt; encryption with dm-crypt or loop-AES.-

Thanks for your feedback. As advance warning, please note that
the crypto support in debian-installer [0] is still pre-beta and
may not work as expected / at all. You did see the big warning
screen, right? ;-)

&gt; 2.) You than want to partition with crypto-features and than manage the partitions
&gt;      with format, Mountpoints, etc..
&gt;      I tryed 8 to 10 times to found a way to partition AND manage the partitions
&gt;      but I could only do once. If I choose what looks like encryption, than the
&gt;      Mountpoints where not there, unreachable to me, or I could reach and set
&gt;      the Mountpoints and could not encrypt anything.

Agreed that this is not ideal from a usability point of view.
The installer currently treats setting up encrypted block devices
(which you do when you chose "physical volume for encryption")
and actually using the encrypted block devices (setting
filesystem, mountpoint, etc.) as two separate steps. You need to
first setup the encrypted block device, then select "Configure
encrypted partitions".

This is explained in the Installation Guide[1], btw.

&gt; 3.) If you choose loop-AES, what I did several times and you go the sensless
&gt;      way of encryption without Mountpoints, you reach the point where you
&gt;      must strike the keyboard (not mouse) maybe thousands of time to get, what
&gt;      looks to be the /dev/random-reservoir for the gpg-key to make.
&gt;      After 10 minutes or so the responsible menupoint crashes without warning,
&gt;      I tryed this about 5 times.

Thousands of times sounds about alright. 

You must realize that in the installer, there is very little in
the way of unpredictable events up to the point where we need to
generate the encryption keys. Depending on the installation
method, we have either a) some access to CDROM or floppy, b) USB,
c) net access. Which of those contributes to the kernel entropy
pool is also hardware dependent, because different drivers in
Linux treat system events differently -- some may consider disk
access very "entropic", others not so much. 

Overall the events in the installer leading up to key generation
do not provide enough input to the kernel entropy pool to allow
extraction of the 2925 bytes we need foreach loop-AES key, and so
you are asked to "please bang on the keyboard like a monkey" ;-)
until the pool gets enough input.

We have considered different ways of helping to speed up this
process, but it is a difficult process. In the graphical version
of the installer, once supported, for example mouse events will
contribute as you suggested. Then some systems may have hardware
RNGs that we could use -- but those can be of different quality,
so some people explicitly recommend against using them directly
for key generation. So ... this obviously needs more work.

About the crash in this menupoint, can you describe in more
detail exactly when/how it crashes. What happens after it has
crashed ? Does the installer "hang", or does it continue? 
How much memory does this system have?

&gt; I am waiting for newer netinst.iso's to come and will report if usefull.

Please do. We expect to release a beta3 of the installer shortly,
although there are still some known problems in the crypto
support.  We're planning to announce the installer more widely
once we have given it more testing and expect it to work
correctly. You are more than welcome to test before then, but
please beware that you are essentially testing a development
snapshot -- don't be surprised by random breakage.

cheers,
Max

-- 
[0] http://wiki.debian.org/DebianInstaller/PartmanCrypto
[1] http://d-i.alioth.debian.org/manual/en.i386/ch06s03.html#partman-crypto

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061013173426</emailId><senderName>"Jordan Crouse"</senderName><senderEmail>jordan.crouse@amd.com</senderEmail><timestampReceived>2006-10-13 17:34:26-0400</timestampReceived><subject>Re: crypto: Add support for the Geode AES engine (v4)</subject><body>

On 13/10/06 13:18 -0400, Michael Frey wrote:
&gt; Does this patch support the eeprom on the AES module?

No - not yet.  I wasn't happy with way we did that driver in the first 
place (heaven help me, I make stupid programming decisions sometimes),
and I also wanted to get the crypto engine itself in first.

The eeprom will be coming soon - but probably not to this crowd, since
it will (for now) just be a generic device providing a bit of storage
on chip.  If there is a generic way for dealing with hardware keys in
the crypto subsystem, then we can tie it together later.

&gt; Also,  Can this patch be used on a 2.6.18 kernel?

Hmmm... I use the new API - is that legal for 2.6.18?

Jordan

-- 
Jordan Crouse
Senior Linux Engineer
Advanced Micro Devices, Inc.
&lt;www.amd.com/embeddedprocessors&gt;


-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060602173223</emailId><senderName>Michael Frey</senderName><senderEmail>mfrey@pepper.com</senderEmail><timestampReceived>2006-06-02 17:32:23-0400</timestampReceived><subject>Re: [PATCH] crypto:  Add support for the Geode LX HW AES engine</subject><body>

Jordan,

This looks great,  however are you going to release a patch against  
2.6.11-geode?  2.6.11 is the version all geode patches were issued  
against.

Michael

On Jun 2, 2006, at 1:23 PM, Jordan Crouse wrote:

&gt; Greetings - attached is a patch adding a crypto API driver for the  
&gt; hardware
&gt; encryption engine on the AMD Geode LX processor, applied against  
&gt; latest
&gt; GIT from Linus.  This is my first foray into the world of the  
&gt; Crypto API,
&gt; so comments are more then welcome.
&gt;
&gt; Regards,
&gt; Jordan
&gt;
&gt; -- 
&gt; Jordan Crouse
&gt; Senior Linux Engineer
&gt; Advanced Micro Devices, Inc.
&gt; &lt;www.amd.com&gt;
&gt; PATCH: crypto: Add CryptoAPI support for the Geode LX AES Module
&gt;
&gt; From: Jordan Crouse &lt;jordan.crouse@amd.com&gt;
&gt;
&gt; Add CryptoAPI support for the Geode LX hardware based AES encryption
&gt; engine.
&gt;
&gt; Signed-off-by: Jordan Crouse &lt;jordan.crouse@amd.com&gt;
&gt; ---
&gt;
&gt;  drivers/crypto/Kconfig     |    9 +
&gt;  drivers/crypto/Makefile    |    1
&gt;  drivers/crypto/geode-aes.c |  395 +++++++++++++++++++++++++++++++++ 
&gt; +++++++++++
&gt;  drivers/crypto/geode-aes.h |   42 +++++
&gt;  4 files changed, 447 insertions(+), 0 deletions(-)
&gt;
&gt; diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
&gt; index 4263935..efc5c72 100644
&gt; --- a/drivers/crypto/Kconfig
&gt; +++ b/drivers/crypto/Kconfig
&gt; @@ -20,4 +20,13 @@ config CRYPTO_DEV_PADLOCK_AES
&gt;  	help
&gt;  	  Use VIA PadLock for AES algorithm.
&gt;
&gt; +config CRYPTO_DEV_GEODE
&gt; +	tristate "Support for the Geode LX AES engine"
&gt; +	depends on CRYPTO &amp;&amp; X86_32
&gt; +	help
&gt; +	  Say 'Y' here to use the AMD Geode LX processor on-board AES
&gt; +	  engine for the CryptoAPI AES alogrithm.
&gt; +
&gt; +	  To compile this driver as a module, choose M here: the module
&gt; +	  will be called geode-aes.
&gt;  endmenu
&gt; diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
&gt; index 45426ca..9093ed0 100644
&gt; --- a/drivers/crypto/Makefile
&gt; +++ b/drivers/crypto/Makefile
&gt; @@ -1,5 +1,6 @@
&gt;
&gt;  obj-$(CONFIG_CRYPTO_DEV_PADLOCK) += padlock.o
&gt; +obj-$(CONFIG_CRYPTO_DEV_GEODE) += geode-aes.o
&gt;
&gt;  padlock-objs-$(CONFIG_CRYPTO_DEV_PADLOCK_AES) += padlock-aes.o
&gt;
&gt; diff --git a/drivers/crypto/geode-aes.c b/drivers/crypto/geode-aes.c
&gt; new file mode 100644
&gt; index 0000000..90ccec4
&gt; --- /dev/null
&gt; +++ b/drivers/crypto/geode-aes.c
&gt; @@ -0,0 +1,395 @@
&gt; +/* CryptoAPI interface for the Geode LX hardware AES encryption  
&gt; module
&gt; + * Copyright (C) 2004-2006, Advanced Micro Devices, Inc.
&gt; + *
&gt; + * This program is free software; you can redistribute it and/or  
&gt; modify
&gt; + * it under the terms of the GNU General Public License as  
&gt; published by
&gt; + * the Free Software Foundation; either version 2 of the License, or
&gt; + * (at your option) any later version.
&gt; + */
&gt; +
&gt; +#include &lt;linux/module.h&gt;
&gt; +#include &lt;linux/kernel.h&gt;
&gt; +#include &lt;linux/sched.h&gt;
&gt; +#include &lt;linux/pci.h&gt;
&gt; +#include &lt;linux/pci_ids.h&gt;
&gt; +#include &lt;linux/crypto.h&gt;
&gt; +
&gt; +#include &lt;asm/io.h&gt;
&gt; +#include &lt;asm/delay.h&gt;
&gt; +
&gt; +#include "geode-aes.h"
&gt; +
&gt; +/* Register definitions */
&gt; +
&gt; +#define AES_CTRLA_REG  0x0000
&gt; +
&gt; +#define AES_CTRL_START     0x01
&gt; +#define AES_CTRL_DECRYPT   0x00
&gt; +#define AES_CTRL_ENCRYPT   0x02
&gt; +#define AES_CTRL_WRKEY     0x04
&gt; +#define AES_CTRL_DCA       0x08
&gt; +#define AES_CTRL_SCA       0x10
&gt; +#define AES_CTRL_CBC       0x20
&gt; +
&gt; +#define AES_INTR_REG  0x0008
&gt; +
&gt; +#define AES_INTRA_PENDING (1 &lt;&lt; 16)
&gt; +#define AES_INTRB_PENDING (1 &lt;&lt; 17)
&gt; +
&gt; +#define AES_INTR_PENDING  (AES_INTRA_PENDING | AES_INTRB_PENDING)
&gt; +#define AES_INTR_MASK     0x07
&gt; +
&gt; +#define AES_SOURCEA_REG   0x0010
&gt; +#define AES_DSTA_REG      0x0014
&gt; +#define AES_LENA_REG      0x0018
&gt; +#define AES_WRITEKEY0_REG 0x0030
&gt; +#define AES_WRITEIV0_REG  0x0040
&gt; +
&gt; +/* Useful macros */
&gt; +
&gt; +#define SET_KEY(key) _writefield(AES_WRITEKEY0_REG, key)
&gt; +#define SET_IV(iv)   _writefield(AES_WRITEIV0_REG, iv)
&gt; +#define GET_IV(iv)   _readfield(AES_WRITEIV0_REG, iv)
&gt; +
&gt; +/* Static structures */
&gt; +
&gt; +static void __iomem * _iobase;
&gt; +static DEFINE_MUTEX(emutex);
&gt; +
&gt; +static inline void AWRITE(unsigned long val, unsigned short reg) {
&gt; +#ifdef DEBUG
&gt; +	printk("[AES] W [%x]=%x\n", reg, val);
&gt; +#endif
&gt; +	iowrite32(val, _iobase + reg);
&gt; +}
&gt; +
&gt; +static inline unsigned int AREAD(unsigned short reg) {
&gt; +	unsigned int val = ioread32(_iobase + reg);
&gt; +#ifdef DEBUG
&gt; +	printk("[AES] R [%x]=%x\n", reg, val);
&gt; +#endif
&gt; +	return val;
&gt; +}
&gt; +
&gt; +/* Write a 128 bit field (either a writable key or IV) */
&gt; +static inline void
&gt; +_writefield(u32 offset, void *value)
&gt; +{
&gt; +	int i;
&gt; +	for(i = 0; i &lt; 4; i++)
&gt; +		AWRITE(((u32 *) value)[i], offset + (i * 4));
&gt; +}
&gt; +
&gt; +/* Read a 128 bit field (either a writable key or IV) */
&gt; +static inline void
&gt; +_readfield(u32 offset, void *value)
&gt; +{
&gt; +	int i;
&gt; +	for(i = 0; i &lt; 4; i++)
&gt; +		((u32 *) value)[i] = AREAD(offset + (i * 4));
&gt; +}
&gt; +
&gt; +static void
&gt; +_crypt(void *src, void *dst, int len, u32 flags)
&gt; +{
&gt; +	u32 status;
&gt; +
&gt; +	AWRITE(__pa(src), AES_SOURCEA_REG);
&gt; +	AWRITE(__pa(dst), AES_DSTA_REG);
&gt; +	AWRITE(len,  AES_LENA_REG);
&gt; +
&gt; +	/* Start the operation */
&gt; +	AWRITE(AES_CTRL_START | flags, AES_CTRLA_REG);
&gt; +
&gt; +	/* According to the silicon developers, the status will only
&gt; +	 * fail to clear on an catastrophic failure, so an infinite
&gt; +	 * loop is valid here
&gt; +	 */
&gt; +
&gt; +	do
&gt; +		status = AREAD(AES_INTR_REG);
&gt; +	while(!(status &amp; AES_INTRA_PENDING));
&gt; +
&gt; +	/* Clear the event */
&gt; +	AWRITE((status &amp; 0xFF) | AES_INTRA_PENDING, AES_INTR_REG);
&gt; +}
&gt; +
&gt; +unsigned int
&gt; +geode_aes_crypt(struct geode_aes_op *op)
&gt; +{
&gt; +	u32 flags = 0;
&gt; +
&gt; +	if (op-&gt;len == 0 || op-&gt;src == op-&gt;dst)
&gt; +		return 0;
&gt; +
&gt; +	if (mutex_lock_interruptible(&amp;emutex))
&gt; +		return 0;
&gt; +
&gt; +	if (op-&gt;mode == AES_MODE_CBC) {
&gt; +		flags |= AES_CTRL_CBC;
&gt; +		SET_IV(op-&gt;iv);
&gt; +	}
&gt; +
&gt; +	if (op-&gt;flags &amp; AES_FLAGS_USRKEY) {
&gt; +		flags |= AES_CTRL_WRKEY;
&gt; +		SET_KEY(op-&gt;key);
&gt; +	}
&gt; +
&gt; +	if (op-&gt;flags &amp; AES_FLAGS_COHERENT)
&gt; +		flags |= (AES_CTRL_DCA | AES_CTRL_SCA);
&gt; +
&gt; +	if (op-&gt;dir == AES_DIR_ENCRYPT)
&gt; +		flags |= AES_CTRL_ENCRYPT;
&gt; +
&gt; +	_crypt(op-&gt;src, op-&gt;dst, op-&gt;len, flags);
&gt; +
&gt; +	if (op-&gt;mode == AES_MODE_CBC)
&gt; +		GET_IV(op-&gt;iv);
&gt; +
&gt; +	mutex_unlock(&amp;emutex);
&gt; +	return op-&gt;len;
&gt; +}
&gt; +
&gt; +/* CRYPTO-API Functions */
&gt; +
&gt; +static int
&gt; +geode_aes_setkey(void *data, const u8 *key, unsigned int len, u32  
&gt; *flags)
&gt; +{
&gt; +
&gt; +	struct geode_aes_op *op = (struct geode_aes_op *) data;
&gt; +
&gt; +	if (len != AES_KEY_LENGTH) {
&gt; +		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
&gt; +		return -EINVAL;
&gt; +	}
&gt; +
&gt; +	memcpy(op-&gt;key, key, len);
&gt; +	return 0;
&gt; +}
&gt; +
&gt; +static void
&gt; +geode_aes_encrypt(void *ctx, u8 *out, const u8 *in)
&gt; +{
&gt; +	struct geode_aes_op *op = (struct geode_aes_op *) ctx;
&gt; +
&gt; +	if ((out == NULL) || (in == NULL))
&gt; +		return;
&gt; +
&gt; +	op-&gt;src = (void *) in;
&gt; +	op-&gt;dst = (void *) out;
&gt; +	op-&gt;mode = AES_MODE_CBC;
&gt; +	op-&gt;flags = 0;
&gt; +	op-&gt;len = AES_MIN_BLOCK_SIZE;
&gt; +	op-&gt;dir = AES_DIR_ENCRYPT;
&gt; +
&gt; +	geode_aes_crypt(op);
&gt; +}
&gt; +
&gt; +
&gt; +static void
&gt; +geode_aes_decrypt(void *ctx, u8 *out, const u8 *in)
&gt; +{
&gt; +	struct geode_aes_op *op = (struct geode_aes_op *) ctx;
&gt; +
&gt; +	if ((out == NULL) || (in == NULL))
&gt; +		return;
&gt; +
&gt; +	op-&gt;src = (void *) in;
&gt; +	op-&gt;dst = (void *) out;
&gt; +	op-&gt;mode = AES_MODE_CBC;
&gt; +	op-&gt;flags = 0;
&gt; +	op-&gt;len = AES_MIN_BLOCK_SIZE;
&gt; +	op-&gt;dir = AES_DIR_DECRYPT;
&gt; +
&gt; +	geode_aes_crypt(op);
&gt; +}
&gt; +
&gt; +static unsigned int
&gt; +geode_aes_encrypt_ecb(const struct cipher_desc *desc, u8 *out,
&gt; +		      const u8 *in, unsigned int nbytes)
&gt; +{
&gt; +	struct geode_aes_op *op = crypto_tfm_ctx(desc-&gt;tfm);
&gt; +
&gt; +	op-&gt;src = (void *) in;
&gt; +	op-&gt;dst = (void *) out;
&gt; +	op-&gt;mode = AES_MODE_ECB;
&gt; +	op-&gt;flags = 0;
&gt; +	op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
&gt; +	op-&gt;dir = AES_DIR_ENCRYPT;
&gt; +
&gt; +	return geode_aes_crypt(op);
&gt; +}
&gt; +
&gt; +static unsigned int
&gt; +geode_aes_decrypt_ecb(const struct cipher_desc *desc, u8 *out,
&gt; +		      const u8 *in, unsigned int nbytes)
&gt; +{
&gt; +	struct geode_aes_op *op = crypto_tfm_ctx(desc-&gt;tfm);
&gt; +
&gt; +	op-&gt;src = (void *) in;
&gt; +	op-&gt;dst = (void *) out;
&gt; +	op-&gt;mode = AES_MODE_ECB;
&gt; +	op-&gt;flags = 0;
&gt; +	op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
&gt; +	op-&gt;dir = AES_DIR_DECRYPT;
&gt; +
&gt; +	return geode_aes_crypt(op);
&gt; +}
&gt; +
&gt; +static unsigned int
&gt; +geode_aes_encrypt_cbc(const struct cipher_desc *desc, u8 *out,
&gt; +		      const u8 *in, unsigned int nbytes)
&gt; +{
&gt; +	struct geode_aes_op *op = crypto_tfm_ctx(desc-&gt;tfm);
&gt; +	unsigned int ret;
&gt; +
&gt; +	op-&gt;src = (void *) in;
&gt; +	op-&gt;dst = (void *) out;
&gt; +	op-&gt;mode = AES_MODE_CBC;
&gt; +	op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
&gt; +	op-&gt;dir = AES_DIR_ENCRYPT;
&gt; +
&gt; +	memcpy(op-&gt;iv, desc-&gt;info, AES_IV_LENGTH);
&gt; +
&gt; +	ret = geode_aes_crypt(op);
&gt; +
&gt; +	memcpy(desc-&gt;info, op-&gt;iv, AES_IV_LENGTH);
&gt; +	return ret;
&gt; +}
&gt; +
&gt; +static unsigned int
&gt; +geode_aes_decrypt_cbc(const struct cipher_desc *desc, u8 *out,
&gt; +		      const u8 *in, unsigned int nbytes)
&gt; +{
&gt; +	struct geode_aes_op *op = crypto_tfm_ctx(desc-&gt;tfm);
&gt; +	unsigned int ret;
&gt; +
&gt; +	op-&gt;src = (void *) in;
&gt; +	op-&gt;dst = (void *) out;
&gt; +	op-&gt;mode = AES_MODE_CBC;
&gt; +	op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
&gt; +	op-&gt;dir = AES_DIR_DECRYPT;
&gt; +
&gt; +	memcpy(op-&gt;iv, desc-&gt;info, AES_IV_LENGTH);
&gt; +
&gt; +	ret = geode_aes_crypt(op);
&gt; +
&gt; +	memcpy(desc-&gt;info, op-&gt;iv, AES_IV_LENGTH);
&gt; +	return ret;
&gt; +}
&gt; +
&gt; +static struct crypto_alg geode_aes_crypto = {
&gt; +	.cra_name               =       "aes",
&gt; +	.cra_driver_name	=       "geode-aes",
&gt; +	.cra_priority           =       110,
&gt; +	.cra_alignmask          =       15,
&gt; +	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
&gt; +	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
&gt; +	.cra_ctxsize		=	sizeof(struct geode_aes_op),
&gt; +	.cra_module		=	THIS_MODULE,
&gt; +	.cra_list		=	LIST_HEAD_INIT(geode_aes_crypto.cra_list),
&gt; +	.cra_u			=	{
&gt; +		.cipher = {
&gt; +			.cia_min_keysize	=  AES_KEY_LENGTH,
&gt; +			.cia_max_keysize	=  AES_KEY_LENGTH,
&gt; +			.cia_setkey		=  geode_aes_setkey,
&gt; +			.cia_encrypt		=  geode_aes_encrypt,
&gt; +			.cia_decrypt		=  geode_aes_decrypt,
&gt; +			.cia_encrypt_ecb	=  geode_aes_encrypt_ecb,
&gt; +			.cia_decrypt_ecb	=  geode_aes_decrypt_ecb,
&gt; +			.cia_encrypt_cbc	=  geode_aes_encrypt_cbc,
&gt; +			.cia_decrypt_cbc	=  geode_aes_decrypt_cbc,
&gt; +		}
&gt; +	}
&gt; +};
&gt; +
&gt; +static void
&gt; +geode_aes_remove(struct pci_dev *dev)
&gt; +{
&gt; +	crypto_unregister_alg(&amp;geode_aes_crypto);
&gt; +
&gt; +	pci_iounmap(dev, _iobase);
&gt; +	_iobase = NULL;
&gt; +
&gt; +	pci_release_regions(dev);
&gt; +	pci_disable_device(dev);
&gt; +
&gt; +	mutex_destroy(&amp;emutex);
&gt; +}
&gt; +
&gt; +
&gt; +static int
&gt; +geode_aes_probe(struct pci_dev *dev, const struct pci_device_id *id)
&gt; +{
&gt; +	int ret;
&gt; +
&gt; +	if ((ret = pci_enable_device(dev)))
&gt; +		return ret;
&gt; +
&gt; +	if ((ret = pci_request_regions(dev, "geode-aes")))
&gt; +		goto eenable;
&gt; +
&gt; +	_iobase = pci_iomap(dev, 0, 0);
&gt; +
&gt; +	if (_iobase == NULL) {
&gt; +		ret = -ENOMEM;
&gt; +		goto erequest;
&gt; +	}
&gt; +
&gt; +	/* Clear any pending activity */
&gt; +	AWRITE(AES_INTR_PENDING | AES_INTR_MASK, AES_INTR_REG);
&gt; +
&gt; +	mutex_init(&amp;emutex);
&gt; +
&gt; +	ret = crypto_register_alg(&amp;geode_aes_crypto);
&gt; +
&gt; +	if (ret == 0) {
&gt; +	  printk(KERN_NOTICE "geode-aes: GEODE AES engine enabled.\n");
&gt; +	  return 0;
&gt; +	}
&gt; +
&gt; +	crypto_unregister_alg(&amp;geode_aes_crypto);
&gt; +
&gt; +	pci_iounmap(dev, _iobase);
&gt; +
&gt; + erequest:
&gt; +	pci_release_regions(dev);
&gt; +
&gt; + eenable:
&gt; +	pci_disable_device(dev);
&gt; +
&gt; +	return ret;
&gt; +}
&gt; +
&gt; +struct pci_device_id geode_aes_tbl[] = {
&gt; +	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_LX_AES, PCI_ANY_ID,  
&gt; PCI_ANY_ID} ,
&gt; +	{ 0, }
&gt; +};
&gt; +
&gt; +MODULE_DEVICE_TABLE(pci, geode_aes_tbl);
&gt; +
&gt; +static struct pci_driver geode_aes_driver = {
&gt; +	name:      "Geode LX AES",
&gt; +	id_table:  geode_aes_tbl,
&gt; +	probe:     geode_aes_probe,
&gt; +	remove:    __devexit_p(geode_aes_remove)
&gt; +};
&gt; +
&gt; +static int __devinit
&gt; +geode_aes_init(void)
&gt; +{
&gt; +	return pci_module_init(&amp;geode_aes_driver);
&gt; +}
&gt; +
&gt; +static void __devexit
&gt; +geode_aes_exit(void)
&gt; +{
&gt; +	pci_unregister_driver(&amp;geode_aes_driver);
&gt; +}
&gt; +
&gt; +MODULE_AUTHOR("Advanced Micro Devices, Inc.");
&gt; +MODULE_DESCRIPTION("Geode LX Hardware AES driver");
&gt; +MODULE_LICENSE("GPL");
&gt; +
&gt; +module_init(geode_aes_init);
&gt; +module_exit(geode_aes_exit);
&gt; diff --git a/drivers/crypto/geode-aes.h b/drivers/crypto/geode-aes.h
&gt; new file mode 100644
&gt; index 0000000..97f9eee
&gt; --- /dev/null
&gt; +++ b/drivers/crypto/geode-aes.h
&gt; @@ -0,0 +1,42 @@
&gt; +/* Copyright (C) 2003-2006, Advanced Micro Devices, Inc.
&gt; + *
&gt; + * This program is free software; you can redistribute it and/or  
&gt; modify
&gt; + * it under the terms of the GNU General Public License as  
&gt; published by
&gt; + * the Free Software Foundation; either version 2 of the License, or
&gt; + * (at your option) any later version.
&gt; + */
&gt; +
&gt; +#ifndef _GEODE_AES_H_
&gt; +#define _GEODE_AES_H_
&gt; +
&gt; +#define AES_KEY_LENGTH 16
&gt; +#define AES_IV_LENGTH  16
&gt; +
&gt; +#define AES_MIN_BLOCK_SIZE 16
&gt; +
&gt; +#define AES_MODE_ECB 0
&gt; +#define AES_MODE_CBC 1
&gt; +
&gt; +#define AES_DIR_DECRYPT 0
&gt; +#define AES_DIR_ENCRYPT 1
&gt; +
&gt; +#define AES_FLAGS_USRKEY   (1 &lt;&lt; 0)
&gt; +#define AES_FLAGS_COHERENT (1 &lt;&lt; 1)
&gt; +
&gt; +struct geode_aes_op {
&gt; +
&gt; +  void *src;
&gt; +  void *dst;
&gt; +
&gt; +  u32 mode;
&gt; +  u32 dir;
&gt; +  u32 flags;
&gt; +  int len;
&gt; +
&gt; +  u8 key[AES_KEY_LENGTH];
&gt; +  u8 iv[AES_IV_LENGTH];
&gt; +};
&gt; +
&gt; +unsigned int geode_aes_crypt(struct geode_aes_op *);
&gt; +
&gt; +#endif
&gt;
&gt; ---
&gt; You are currently subscribed to info-linux@geode.amd.com
&gt; as: mfrey@pepper.com
&gt; To unsubscribe send a blank email to:
&gt; leave-info-linux-7332K@whitestar.amd.com

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060602230752</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-06-02 23:07:52-0400</timestampReceived><subject>Re: [PATCH] crypto:  Add support for the Geode LX HW AES engine</subject><body>

On Fri, Jun 02, 2006 at 05:23:41PM +0000, Jordan Crouse wrote:
&gt;
&gt; +	/* According to the silicon developers, the status will only
&gt; +	 * fail to clear on an catastrophic failure, so an infinite
&gt; +	 * loop is valid here
&gt; +	 */
&gt; +
&gt; +	do
&gt; +		status = AREAD(AES_INTR_REG);
&gt; +	while(!(status &amp; AES_INTRA_PENDING));

Is the chip capable of notifying completion via an interrupt?

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060603104304</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-06-03 10:43:04-0400</timestampReceived><subject>Re: [PATCH] crypto:  Add support for the Geode LX HW AES engine</subject><body>

On Sat, Jun 03, 2006 at 09:07:52AM +1000, Herbert Xu (herbert@gondor.apana.org.au) wrote:
&gt; On Fri, Jun 02, 2006 at 05:23:41PM +0000, Jordan Crouse wrote:
&gt; &gt;
&gt; &gt; +	/* According to the silicon developers, the status will only
&gt; &gt; +	 * fail to clear on an catastrophic failure, so an infinite
&gt; &gt; +	 * loop is valid here
&gt; &gt; +	 */
&gt; &gt; +
&gt; &gt; +	do
&gt; &gt; +		status = AREAD(AES_INTR_REG);
&gt; &gt; +	while(!(status &amp; AES_INTRA_PENDING));
&gt; 
&gt; Is the chip capable of notifying completion via an interrupt?

Even if it can, it is impossible to use with cryptoapi in atomic contexts.
In process context it might be a slepp though.

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060201141344</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-02-01 14:13:44-0400</timestampReceived><subject>Re: Encrypting DVD:s and CD:s</subject><body>

Gabriel Jägenstedt wrote:
&gt; I have the following line in fstab.
&gt; /dev/hdc    /mnt/secure iso9660
&gt; ro,user,noauto,loop=/dev/loop11,encryption=AES256,gpgkey=/etc/keys/cd_dvdkey.gpg
&gt; 
&gt; What I want is basicly a simple way to encrypt stuff that is off my
&gt; drive. I'm sure it is possible to do it in some way writing a simple
&gt; script and having one file on the disc but I can't help think there is a
&gt; better way.

Each CD and DVD must have its own key file. If you use same key file for
multiple file systems, you start getting identical ciphertext blocks, which
is bad for security.

aespipe README example 3.3. shows how to encrypt CDs. It puts a key file at
beginning of the CD and specifies offset for encrypted data. If you want to
be able to change passphrase afterwards, then encrypt the key file using gpg
public-key crypto. Changing gpg private-key passphrase changes your CD/DVD
mount passphrase.

http://loop-aes.sourceforge.net/aespipe.README

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060201143835</emailId><senderName>Gabriel_Jägenstedt</senderName><senderEmail>gabriel.j@telia.com</senderEmail><timestampReceived>2006-02-01 14:38:35-0400</timestampReceived><subject>Re: Encrypting DVD:s and CD:s</subject><body>

Thanks.. I'll take a look at that.

Jari Ruusu wrote:
&gt; Gabriel Jägenstedt wrote:
&gt; 
&gt;&gt;I have the following line in fstab.
&gt;&gt;/dev/hdc    /mnt/secure iso9660
&gt;&gt;ro,user,noauto,loop=/dev/loop11,encryption=AES256,gpgkey=/etc/keys/cd_dvdkey.gpg
&gt;&gt;
&gt;&gt;What I want is basicly a simple way to encrypt stuff that is off my
&gt;&gt;drive. I'm sure it is possible to do it in some way writing a simple
&gt;&gt;script and having one file on the disc but I can't help think there is a
&gt;&gt;better way.
&gt; 
&gt; 
&gt; Each CD and DVD must have its own key file. If you use same key file for
&gt; multiple file systems, you start getting identical ciphertext blocks, which
&gt; is bad for security.
&gt; 
&gt; aespipe README example 3.3. shows how to encrypt CDs. It puts a key file at
&gt; beginning of the CD and specifies offset for encrypted data. If you want to
&gt; be able to change passphrase afterwards, then encrypt the key file using gpg
&gt; public-key crypto. Changing gpg private-key passphrase changes your CD/DVD
&gt; mount passphrase.
&gt; 
&gt; http://loop-aes.sourceforge.net/aespipe.README
&gt; 

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060802093522</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-08-02 09:35:22-0400</timestampReceived><subject>Re: crypto-root-fs via debian-netinst.iso (dailybuild) ? - NOT YET -</subject><body>

....... this is happening when someone is sitting too long before the computer:

"
What does Jari Ruusu use when he suggests

head -c 2925 /dev/random | uuencode -m - | head -n 66 | tail -n 65 | gpg --symmetric \
-a &gt;/boot/rootkey.gpg

Is he using /dev/urandom ? - "
                                                    

                                        have fun,           Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060802150405</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-08-02 15:04:05-0400</timestampReceived><subject>Re: crypto-root-fs via debian-netinst.iso-dailybuild-loopAES</subject><body>

Hi again,

On Wed, Aug 02, 2006 at 12:35:44PM +0200, reverend@Safe-mail.net wrote:
&gt; I had to give the full random-pool for crypted-swap with the
&gt; keyboard,

If you chose "Random key" for the partition it will not be
required to generate as much random data and hence not ask you
to do the press-random-keys step.

&gt; I had it to do again for the second crypted partition and the
&gt; menu/the function crashes after 12 or 13%; I had to start again
&gt; to fill the random-pool for this, second, crypted Partition.

I have had a closer look but have been unable to reproduce 
such crash so far. On the off-chance that you are still motivated
to try it once more :-) Please do save a copy of files in
/var/log/ from inside the installer. Those should allow to
narrow-down the problem.

&gt; This time I made it up to 100% and was than messaged, that I
&gt; had choosen crypto for "/", which is not possible, I should go
&gt; back and change this.
&gt; 
&gt; Remember that crypto for "/" had, at least to this point,
&gt; worked so far under choosen dm-crypt.

Yes. Encrypted root on loop-AES is not implemented since we 
still need hooks for initramfs-tools to handle it. This is
tracked in Debian bug #378488, which also has a preliminary in-
development version of such hook scripts.

&gt; I now switch off everything and dry the pee with a bing fan
&gt; because I am pissed off.

Sorry if you have wasted your time. I hope that I / we / the
documentation haven't given the impression that it is expected 
to be working flawless at this stage of development.

If you still decide to do more tests with it, the best place to
report your results with the development version of the installer
is the debian-boot mailinglist (debian-boot@lists.debian.org).

cheers,
Max

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060803011244</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-08-03 01:12:44-0400</timestampReceived><subject>Fwd: Re: crypto-root-fs via debian-netinst.iso (dailybuild) ? - NOT YET -</subject><body>

hello auditorium, (this email was lost and is send again, so wrong sort order)

&gt; may not work as expected / at all. You did see the big warning
&gt; screen, right? ;-)

If you meen that one which opens after reaching (if  reaching ! ) the
crypto-menu, Yes.-
But I allready know about the state of testing/unstable, linux, anyway.....

&gt; filesystem, mountpoint, etc.) as two separate steps. You need to
&gt; first setup the encrypted block device, then select "Configure
&gt; encrypted partitions".
&gt; 
&gt; This is explained in the Installation Guide[1], btw.
&gt; 

Is it ?
I read it again, O.K. I had it overlooked only, instead of really read it, but I did \
it now, in "6.3.2.4. Configuring Encrypted Volumes" I could really read something
that I eventually can understand if someone told me what is meant.

My netinst.iso is non-english which lets something lost in translation related to
the englich guide.

Under all circumstances is must be shure that the part of partioning is completely
done with or without encryption so that the user gets a chance of choosing
encryption or not when it is time to do so.
Than and only than when that is completed should the questions about
ext2, ext3 and so on, come.-

When I read your answer to my email, 10 hrs ago, I spontanious tryed again
to netinst.iso, this time with the build from 01.Aug.2006 and the knowledge of
now. I managed to set up dm-crypted partions for swap and "/" and than let
it go.

I finally reached the point of rebooting and had to give the PW 3 (tree)-times
on the level below X and than X and gnome came.
Despite the fact that I hate gnome, I should give again 2 times the PW, but
the testsystem hangs itself. I rebootet again to make shure that this was not
an exception and than I typed this reply.

&gt; Overall the events in the installer leading up to key generation
&gt; do not provide enough input to the kernel entropy pool to allow
&gt; extraction of the 2925 bytes we need foreach loop-AES key, and so
&gt; you are asked to "please bang on the keyboard like a monkey" ;-)
&gt; until the pool gets enough input.

What does Jari Ruusu use when he suggests

head -c 2925 /dev/random | uuencode -m - | head -n 66 | tail -n 65 | gpg --symmetric \
-a &gt;/boot/rootkey.gpg

Is he using /dev/urandom ? -

If your are a crypto-developer yourself have a look at the
ERPOSS3 and 4 distros. Maybe it's interesting how they do it or how it is not
to do. "3" is using crypto-api (if I remember well) and "4" is using dm-crypt with
luks.
"4" has the unpractical problem of asking 4-times for the PW if swap and "/"
is crypted, which may bring users to trivial or short PWs, anyway, it's working
but I don't trust anything related to the german government.
(http://source.rfc822.org/pub/local/erposs/).

I will later grab these both crypto-distros to check them again because they
could be good for people outside the direct influence of german government and
than a report should be placed here.

&gt; About the crash in this menupoint, can you describe in more
&gt; detail exactly when/how it crashes. What happens after it has
&gt; crashed ? Does the installer "hang", or does it continue? 

The Testsystem is usually standing left of me and I hacked with the left
hand while working on the normal-PC in front of me, who's having the main-
attention.
After minutes I realised a quick red message left of me, when, maybe half
the work had been done and I was one menu-stage deeper.
The testsystem did not hang nor did the debian-menu hang, I mean I just
was on the level where partitioning, clock-setting and so on is to choose.
I did that several times in case of exceptions.-

&gt; How much memory does this system have?

It has 512 MB which are nearly never used and never surprised me in the
last 3,5 years, a poor-mans-Laptop btw.., new 60-GB-hd.

When I have been recovered, I try again, this time choosing loop-AES, if
that is possible, I than will give feedback immediatly.
Before that, I will check for a new daily-build, which, in case, is used than.

The enemy knows a lot about you,
   ........know the enemy,                                 Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060804133603</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-04 13:36:03-0400</timestampReceived><subject>[4/7] [CRYPTO] api: Abstract out common instance initialisation code</subject><body>

Hi:

[CRYPTO] api: Abstract out common instance initialisation code

This patch adds the helpers crypto_get_attr_alg and crypto_alloc_instance
which can be used by simple one-argument templates like hmac to process
input parameters and allocate instances.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/hmac.c b/crypto/hmac.c
--- a/crypto/hmac.c
+++ b/crypto/hmac.c
@@ -19,7 +19,6 @@
 #include &lt;linux/err.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/mm.h&gt;
-#include &lt;linux/rtnetlink.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/scatterlist.h&gt;
 
@@ -132,49 +131,19 @@ static void crypto_hmac_exit_tfm(struct 
 
 static struct crypto_instance *crypto_hmac_alloc(void *param, unsigned int len)
 {
-	struct rtattr *rta = param;
 	struct crypto_instance *inst;
-	struct crypto_attr_alg *alga;
 	struct crypto_alg *alg;
-	struct crypto_spawn *spawn;
-	int err;
 
-	if (!RTA_OK(rta, len))
-		return ERR_PTR(-EBADR);
-	if (rta-&gt;rta_type != CRYPTOA_ALG || RTA_PAYLOAD(rta) &lt; sizeof(*alga))
-		return ERR_PTR(-EINVAL);
-
-	alga = RTA_DATA(rta);
-
-	inst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);
-	if (!inst)
-		return ERR_PTR(-ENOMEM);
-
-	inst-&gt;alg.cra_flags = CRYPTO_ALG_TYPE_DIGEST;
-
-	alg = crypto_alg_mod_lookup(alga-&gt;name, CRYPTO_ALG_TYPE_DIGEST,
-				    CRYPTO_ALG_TYPE_MASK);
-	err = PTR_ERR(alg);
+	alg = crypto_get_attr_alg(param, len, CRYPTO_ALG_TYPE_DIGEST,
+				  CRYPTO_ALG_TYPE_MASK);
 	if (IS_ERR(alg))
-		goto err_free_inst;
+		return ERR_PTR(PTR_ERR(alg));
 
-	err = -ENAMETOOLONG;
-	if (snprintf(inst-&gt;alg.cra_name, CRYPTO_MAX_ALG_NAME,
-		     "hmac(%s)", alg-&gt;cra_name) &gt;= CRYPTO_MAX_ALG_NAME)
-		goto put_alg;
-
-	if (snprintf(inst-&gt;alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,
-		     "hmac(%s)", alg-&gt;cra_driver_name) &gt;= CRYPTO_MAX_ALG_NAME)
-		goto put_alg;
-
-	spawn = crypto_instance_ctx(inst);
-	err = crypto_init_spawn(spawn, alg, inst);
-
-put_alg:
-	crypto_mod_put(alg);
-	if (err)
-		goto err_free_inst;
+	inst = crypto_alloc_instance("hmac", alg);
+	if (IS_ERR(inst))
+		goto out_put_alg;
 
+	inst-&gt;alg.cra_flags = CRYPTO_ALG_TYPE_DIGEST;
 	inst-&gt;alg.cra_priority = alg-&gt;cra_priority;
 	inst-&gt;alg.cra_blocksize = alg-&gt;cra_blocksize;
 	inst-&gt;alg.cra_alignmask = alg-&gt;cra_alignmask;
@@ -191,11 +160,9 @@ put_alg:
 	inst-&gt;alg.cra_digest.dia_final = crypto_hmac_digest_final;
 	inst-&gt;alg.cra_digest.dia_setkey = crypto_hmac_digest_setkey;
 
+out_put_alg:
+	crypto_mod_put(alg);
 	return inst;
-
-err_free_inst:
-	kfree(inst);
-	return ERR_PTR(err);
 }
 
 static void crypto_hmac_free(struct crypto_instance *inst)
diff --git a/crypto/lowapi.c b/crypto/lowapi.c
--- a/crypto/lowapi.c
+++ b/crypto/lowapi.c
@@ -16,6 +16,7 @@
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/list.h&gt;
 #include &lt;linux/module.h&gt;
+#include &lt;linux/rtnetlink.h&gt;
 #include &lt;linux/string.h&gt;
 
 #include "internal.h"
@@ -414,6 +415,58 @@ int crypto_unregister_notifier(struct no
 }
 EXPORT_SYMBOL_GPL(crypto_unregister_notifier);
 
+struct crypto_alg *crypto_get_attr_alg(void *param, unsigned int len,
+				       u32 type, u32 mask)
+{
+	struct rtattr *rta = param;
+	struct crypto_attr_alg *alga;
+
+	if (!RTA_OK(rta, len))
+		return ERR_PTR(-EBADR);
+	if (rta-&gt;rta_type != CRYPTOA_ALG || RTA_PAYLOAD(rta) &lt; sizeof(*alga))
+		return ERR_PTR(-EINVAL);
+
+	alga = RTA_DATA(rta);
+	alga-&gt;name[CRYPTO_MAX_ALG_NAME - 1] = 0;
+
+	return crypto_alg_mod_lookup(alga-&gt;name, type, mask);
+}
+EXPORT_SYMBOL_GPL(crypto_get_attr_alg);
+
+struct crypto_instance *crypto_alloc_instance(const char *name,
+					      struct crypto_alg *alg)
+{
+	struct crypto_instance *inst;
+	struct crypto_spawn *spawn;
+	int err;
+
+	inst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);
+	if (!inst)
+		return ERR_PTR(-ENOMEM);
+
+	err = -ENAMETOOLONG;
+	if (snprintf(inst-&gt;alg.cra_name, CRYPTO_MAX_ALG_NAME, "%s(%s)", name,
+		     alg-&gt;cra_name) &gt;= CRYPTO_MAX_ALG_NAME)
+		goto err_free_inst;
+
+	if (snprintf(inst-&gt;alg.cra_driver_name, CRYPTO_MAX_ALG_NAME, "%s(%s)",
+		     name, alg-&gt;cra_driver_name) &gt;= CRYPTO_MAX_ALG_NAME)
+		goto err_free_inst;
+
+	spawn = crypto_instance_ctx(inst);
+	err = crypto_init_spawn(spawn, alg, inst);
+
+	if (err)
+		goto err_free_inst;
+
+	return inst;
+
+err_free_inst:
+	kfree(inst);
+	return ERR_PTR(err);
+}
+EXPORT_SYMBOL_GPL(crypto_alloc_instance);
+
 static int __init crypto_lowapi_init(void)
 {
 	printk(KERN_INFO "Initializing Cryptographic API\n");
diff --git a/include/crypto/lowapi.h b/include/crypto/lowapi.h
--- a/include/crypto/lowapi.h
+++ b/include/crypto/lowapi.h
@@ -56,6 +56,11 @@ int crypto_init_spawn(struct crypto_spaw
 void crypto_drop_spawn(struct crypto_spawn *spawn);
 struct crypto_tfm *crypto_spawn_tfm(struct crypto_spawn *spawn);
 
+struct crypto_alg *crypto_get_attr_alg(void *param, unsigned int len,
+				       u32 type, u32 mask);
+struct crypto_instance *crypto_alloc_instance(const char *name,
+					      struct crypto_alg *alg);
+
 static inline void *crypto_instance_ctx(struct crypto_instance *inst)
 {
 	return inst-&gt;__ctx;
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060804133633</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-04 13:36:33-0400</timestampReceived><subject>[5/7] [CRYPTO] api: Added asynchronous flag</subject><body>

Hi:

[CRYPTO] api: Added asynchronous flag

This patch adds the asynchronous flag and changes all existing users to
only look up algorithms that are synchronous.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -354,7 +354,7 @@ struct crypto_tfm *crypto_alloc_tfm(cons
 	do {
 		struct crypto_alg *alg;
 
-		alg = crypto_alg_mod_lookup(name, 0, 0);
+		alg = crypto_alg_mod_lookup(name, 0, CRYPTO_ALG_ASYNC);
 		err = PTR_ERR(alg);
 		if (IS_ERR(alg))
 			continue;
@@ -393,7 +393,8 @@ void crypto_free_tfm(struct crypto_tfm *
 int crypto_alg_available(const char *name, u32 flags)
 {
 	int ret = 0;
-	struct crypto_alg *alg = crypto_alg_mod_lookup(name, 0, 0);
+	struct crypto_alg *alg = crypto_alg_mod_lookup(name, 0,
+						       CRYPTO_ALG_ASYNC);
 	
 	if (!IS_ERR(alg)) {
 		crypto_mod_put(alg);
diff --git a/crypto/hmac.c b/crypto/hmac.c
--- a/crypto/hmac.c
+++ b/crypto/hmac.c
@@ -135,7 +135,7 @@ static struct crypto_instance *crypto_hm
 	struct crypto_alg *alg;
 
 	alg = crypto_get_attr_alg(param, len, CRYPTO_ALG_TYPE_DIGEST,
-				  CRYPTO_ALG_TYPE_MASK);
+				  CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_ASYNC);
 	if (IS_ERR(alg))
 		return ERR_PTR(PTR_ERR(alg));
 
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -36,6 +36,7 @@
 #define CRYPTO_ALG_LARVAL		0x00000010
 #define CRYPTO_ALG_DEAD			0x00000020
 #define CRYPTO_ALG_DYING		0x00000040
+#define CRYPTO_ALG_ASYNC		0x00000080
 
 /*
  * Transform masks and values (for crt_flags).
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060804133815</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-04 13:38:15-0400</timestampReceived><subject>[6/6] [CRYPTO] s390: Added missing driver name and priority</subject><body>

Hi:

Doh! I can't count.  This is the last one for now.

[CRYPTO] s390: Added missing driver name and priority

Accelerated versions of crypto algorithms must carry a distinct driver name
and priority in order to distinguish themselves from their generic counter-
part.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/arch/s390/crypto/aes_s390.c b/arch/s390/crypto/aes_s390.c
--- a/arch/s390/crypto/aes_s390.c
+++ b/arch/s390/crypto/aes_s390.c
@@ -222,6 +222,8 @@ static unsigned int aes_decrypt_cbc(cons
 
 static struct crypto_alg aes_alg = {
 	.cra_name		=	"aes",
+	.cra_driver_name	=	"aes-s390",
+	.cra_cra_priority	=	CRYPT_S390_PRIORITY,
 	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize		=	AES_BLOCK_SIZE,
 	.cra_ctxsize		=	sizeof(struct s390_aes_ctx),
diff --git a/arch/s390/crypto/crypt_s390.h b/arch/s390/crypto/crypt_s390.h
--- a/arch/s390/crypto/crypt_s390.h
+++ b/arch/s390/crypto/crypt_s390.h
@@ -20,6 +20,8 @@
 #define CRYPT_S390_OP_MASK 0xFF00
 #define CRYPT_S390_FUNC_MASK 0x00FF
 
+#define CRYPT_S390_PRIORITY 300
+
 /* s930 cryptographic operations */
 enum crypt_s390_operations {
 	CRYPT_S390_KM   = 0x0100,
diff --git a/arch/s390/crypto/des_s390.c b/arch/s390/crypto/des_s390.c
--- a/arch/s390/crypto/des_s390.c
+++ b/arch/s390/crypto/des_s390.c
@@ -135,6 +135,8 @@ static unsigned int des_decrypt_cbc(cons
 
 static struct crypto_alg des_alg = {
 	.cra_name		=	"des",
+	.cra_driver_name	=	"des-s390",
+	.cra_cra_priority	=	CRYPT_S390_PRIORITY,
 	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize		=	DES_BLOCK_SIZE,
 	.cra_ctxsize		=	sizeof(struct crypt_s390_des_ctx),
@@ -271,6 +273,8 @@ static unsigned int des3_128_decrypt_cbc
 
 static struct crypto_alg des3_128_alg = {
 	.cra_name		=	"des3_ede128",
+	.cra_driver_name	=	"des3_ede128-s390",
+	.cra_cra_priority	=	CRYPT_S390_PRIORITY,
 	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize		=	DES3_128_BLOCK_SIZE,
 	.cra_ctxsize		=	sizeof(struct crypt_s390_des3_128_ctx),
@@ -411,6 +415,8 @@ static unsigned int des3_192_decrypt_cbc
 
 static struct crypto_alg des3_192_alg = {
 	.cra_name		=	"des3_ede",
+	.cra_driver_name	=	"des3_ede-s390",
+	.cra_cra_priority	=	CRYPT_S390_PRIORITY,
 	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize		=	DES3_192_BLOCK_SIZE,
 	.cra_ctxsize		=	sizeof(struct crypt_s390_des3_192_ctx),
diff --git a/arch/s390/crypto/sha1_s390.c b/arch/s390/crypto/sha1_s390.c
--- a/arch/s390/crypto/sha1_s390.c
+++ b/arch/s390/crypto/sha1_s390.c
@@ -126,6 +126,8 @@ static void sha1_final(struct crypto_tfm
 
 static struct crypto_alg alg = {
 	.cra_name	=	"sha1",
+	.cra_driver_name =	"sha1-s390",
+	.cra_cra_priority =	CRYPT_S390_PRIORITY,
 	.cra_flags	=	CRYPTO_ALG_TYPE_DIGEST,
 	.cra_blocksize	=	SHA1_BLOCK_SIZE,
 	.cra_ctxsize	=	sizeof(struct crypt_s390_sha1_ctx),
diff --git a/arch/s390/crypto/sha256_s390.c b/arch/s390/crypto/sha256_s390.c
--- a/arch/s390/crypto/sha256_s390.c
+++ b/arch/s390/crypto/sha256_s390.c
@@ -127,6 +127,8 @@ static void sha256_final(struct crypto_t
 
 static struct crypto_alg alg = {
 	.cra_name	=	"sha256",
+	.cra_driver_name =	"sha256-s390",
+	.cra_cra_priority =	CRYPT_S390_PRIORITY,
 	.cra_flags	=	CRYPTO_ALG_TYPE_DIGEST,
 	.cra_blocksize	=	SHA256_BLOCK_SIZE,
 	.cra_ctxsize	=	sizeof(struct s390_sha256_ctx),
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060805043108</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-08-05 04:31:08-0400</timestampReceived><subject>Re: crypto-root-fs/debian-netinst.iso/dailybuild/-WORKING-with dmcrypt</subject><body>

hallo Max,

........ for some strange reason, one mail-reply from me has disappeared again;
maybe it's just too big to be accepted here, anyway .........

(over-edited 1 day later, after this email also disapeared and before was send
again.
I heard about socks got lost in the washing-mashine, but emails ..........)

&gt; If you chose "Random key" for the partition it will not be
&gt; required to generate as much random data and hence not ask you
&gt; to do the press-random-keys step.

Yes, it did. Crypting the swap and the root-fs with dm-crypt IS WORKING.
I used the debian-testing-netinst.iso from 03.08.2006.
I also had changed the dummy-PW to a real PW which broke my neck
the last atempt with loop-AES.

&gt; Yes. Encrypted root on loop-AES is not implemented since we 
&gt; still need hooks for initramfs-tools to handle it. This is
&gt; tracked in Debian bug #378488, which also has a preliminary in-
&gt; development version of such hook scripts.

I just overlooked/did-not-know that fact.

&gt; &gt; I now switch off everything and dry the pee with a bing fan
&gt; &gt; because I am pissed off.
&gt; 
&gt; Sorry if you have wasted your time. I hope that I / we / the
&gt; documentation haven't given the impression that it is expected 
&gt; to be working flawless at this stage of development.

No, you wasted nothing, just the opposit, but I really overdid it the last
40 hours and was angrily disappointet, without reason, of course.

&gt; If you still decide to do more tests with it, the best place to
&gt; report your results with the development version of the installer
&gt; is the debian-boot mailinglist (debian-boot@lists.debian.org).

I had a look at that list and was impressed about how the things where
handled there.
In the moment I have nothing to give which is not allready there.

Thanks + keep up the good work.

                                 Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060805084904</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-08-05 08:49:04-0400</timestampReceived><subject>Re: [2/7] [CRYPTO] cipher: Removed special IV checks for ECB</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Fri, 4 Aug 2006 23:32:36 +1000

&gt; [CRYPTO] cipher: Removed special IV checks for ECB
&gt; 
&gt; This patch makes IV operations on ECB fail through nocrypt_iv rather than
&gt; calling BUG().  This is needed to generalise CBC/ECB using the template
&gt; mechanism.
&gt; 
&gt; Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Applied, thanks.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060805200546</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-08-05 20:05:46-0400</timestampReceived><subject>Re: [3/7] [CRYPTO] api: Split out low-level API</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Sat, 5 Aug 2006 20:36:23 +1000

&gt; So in order to avoid us being crucified by Andrew :), it'd be
&gt; great if you could back out those two patches from net-2.6.19.

Done.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060806104516</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-06 10:45:16-0400</timestampReceived><subject>[CRYPTO] api: Fixed crypto_tfm context alignment</subject><body>

Hi:

[CRYPTO] api: Fixed crypto_tfm context alignment

Previously the __aligned__ attribute was added to the crypto_tfm context
member to ensure it is alinged correctly on architectures such as arm.
Unfortunately kmalloc does not use the same minimum alignment rules as
gcc so this is useless.

This patch changes it to use kmalloc's minimum alignment.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
index 7f94624..5e2ff73 100644
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -21,8 +21,9 @@ #include &lt;linux/module.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/types.h&gt;
 #include &lt;linux/list.h&gt;
+#include &lt;linux/slab.h&gt;
 #include &lt;linux/string.h&gt;
-#include &lt;asm/page.h&gt;
+#include &lt;linux/uaccess.h&gt;
 
 /*
  * Algorithm masks and types.
@@ -61,6 +62,14 @@ #define CRYPTO_MAX_ALG_NAME		64
 #define CRYPTO_DIR_ENCRYPT		1
 #define CRYPTO_DIR_DECRYPT		0
 
+#if defined(ARCH_KMALLOC_MINALIGN)
+#define CRYPTO_MINALIGN_ATTR __attribute__ ((ARCH_KMALLOC_MINALIGN))
+#elif defined(ARCH_SLAB_MINALIGN)
+#define CRYPTO_MINALIGN_ATTR __attribute__ ((ARCH_SLAB_MINALIGN))
+#else
+#define CRYPTO_MINALIGN_ATTR
+#endif
+
 struct scatterlist;
 struct crypto_tfm;
 
@@ -231,7 +240,7 @@ struct crypto_tfm {
 	
 	struct crypto_alg *__crt_alg;
 
-	char __crt_ctx[] __attribute__ ((__aligned__));
+	void *__crt_ctx[] CRYPTO_MINALIGN_ATTR;
 };
 
 /* 
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813121937</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:19:37-0400</timestampReceived><subject>[PATCH 1/16] [CRYPTO] api: Added crypto_type support</subject><body>

[CRYPTO] api: Added crypto_type support

This patch adds the crypto_type structure which will be used for all new
crypto algorithm types, beginning with block ciphers.

The primary purpose of this abstraction is to allow different crypto_type
objects for crypto algorithms of the same type, in particular, there will
be a different crypto_type objects for asynchronous algorithms.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 crypto/api.c            |   32 +++++++++++++++++++++++---------
 include/crypto/algapi.h |    6 ++++++
 include/linux/crypto.h  |    3 +++
 3 files changed, 32 insertions(+), 9 deletions(-)

diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -226,17 +226,18 @@ static int crypto_init_flags(struct cryp
 		
 	case CRYPTO_ALG_TYPE_COMPRESS:
 		return crypto_init_compress_flags(tfm, flags);
-	
-	default:
-		break;
 	}
 	
-	BUG();
-	return -EINVAL;
+	return 0;
 }
 
 static int crypto_init_ops(struct crypto_tfm *tfm)
 {
+	const struct crypto_type *type = tfm-&gt;__crt_alg-&gt;cra_type;
+
+	if (type)
+		return type-&gt;init(tfm);
+
 	switch (crypto_tfm_alg_type(tfm)) {
 	case CRYPTO_ALG_TYPE_CIPHER:
 		return crypto_init_cipher_ops(tfm);
@@ -257,6 +258,14 @@ static int crypto_init_ops(struct crypto
 
 static void crypto_exit_ops(struct crypto_tfm *tfm)
 {
+	const struct crypto_type *type = tfm-&gt;__crt_alg-&gt;cra_type;
+
+	if (type) {
+		if (type-&gt;exit)
+			type-&gt;exit(tfm);
+		return;
+	}
+
 	switch (crypto_tfm_alg_type(tfm)) {
 	case CRYPTO_ALG_TYPE_CIPHER:
 		crypto_exit_cipher_ops(tfm);
@@ -278,26 +287,31 @@ static void crypto_exit_ops(struct crypt
 
 static unsigned int crypto_ctxsize(struct crypto_alg *alg, int flags)
 {
+	const struct crypto_type *type = alg-&gt;cra_type;
 	unsigned int len;
 
+	len = alg-&gt;cra_alignmask &amp; ~(crypto_tfm_ctx_alignment() - 1);
+	if (type)
+		return len + type-&gt;ctxsize(alg);
+
 	switch (alg-&gt;cra_flags &amp; CRYPTO_ALG_TYPE_MASK) {
 	default:
 		BUG();
 
 	case CRYPTO_ALG_TYPE_CIPHER:
-		len = crypto_cipher_ctxsize(alg, flags);
+		len += crypto_cipher_ctxsize(alg, flags);
 		break;
 		
 	case CRYPTO_ALG_TYPE_DIGEST:
-		len = crypto_digest_ctxsize(alg, flags);
+		len += crypto_digest_ctxsize(alg, flags);
 		break;
 		
 	case CRYPTO_ALG_TYPE_COMPRESS:
-		len = crypto_compress_ctxsize(alg, flags);
+		len += crypto_compress_ctxsize(alg, flags);
 		break;
 	}
 
-	return len + (alg-&gt;cra_alignmask &amp; ~(crypto_tfm_ctx_alignment() - 1));
+	return len;
 }
 
 void crypto_shoot_alg(struct crypto_alg *alg)
diff --git a/include/crypto/algapi.h b/include/crypto/algapi.h
--- a/include/crypto/algapi.h
+++ b/include/crypto/algapi.h
@@ -16,6 +16,12 @@
 
 struct module;
 
+struct crypto_type {
+	unsigned int (*ctxsize)(struct crypto_alg *alg);
+	int (*init)(struct crypto_tfm *tfm);
+	void (*exit)(struct crypto_tfm *tfm);
+};
+
 struct crypto_instance {
 	struct crypto_alg alg;
 
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -78,6 +78,7 @@
 
 struct scatterlist;
 struct crypto_tfm;
+struct crypto_type;
 
 struct cipher_desc {
 	struct crypto_tfm *tfm;
@@ -149,6 +150,8 @@ struct crypto_alg {
 	char cra_name[CRYPTO_MAX_ALG_NAME];
 	char cra_driver_name[CRYPTO_MAX_ALG_NAME];
 
+	const struct crypto_type *cra_type;
+
 	union {
 		struct cipher_alg cipher;
 		struct digest_alg digest;
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813122003</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:20:03-0400</timestampReceived><subject>[PATCH 2/16] [CRYPTO] cipher: Added encrypt_one/decrypt_one</subject><body>

[CRYPTO] cipher: Added encrypt_one/decrypt_one

This patch adds two new operations for the simple cipher that encrypts or
decrypts a single block at a time.  This will be the main interface after
the existing block operations have moved over to the new block ciphers.

It also adds the crypto_cipher type which is currently only used on the
new operations but will be extended to setkey as well once existing users
have been converted to use block ciphers where applicable.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 crypto/cipher.c         |   48 ++++++++++++++++++++++++
 include/crypto/algapi.h |    5 ++
 include/linux/crypto.h  |   96 ++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 149 insertions(+)

diff --git a/crypto/cipher.c b/crypto/cipher.c
--- a/crypto/cipher.c
+++ b/crypto/cipher.c
@@ -388,12 +388,60 @@ int crypto_init_cipher_flags(struct cryp
 	return 0;
 }
 
+static void cipher_crypt_unaligned(void (*fn)(struct crypto_tfm *, u8 *,
+					      const u8 *),
+				   struct crypto_tfm *tfm,
+				   u8 *dst, const u8 *src)
+{
+	unsigned long alignmask = crypto_tfm_alg_alignmask(tfm);
+	unsigned int size = crypto_tfm_alg_blocksize(tfm);
+	u8 buffer[size + alignmask];
+	u8 *tmp = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
+
+	memcpy(tmp, src, size);
+	fn(tfm, tmp, tmp);
+	memcpy(dst, tmp, size);
+}
+
+static void cipher_encrypt_unaligned(struct crypto_tfm *tfm,
+				     u8 *dst, const u8 *src)
+{
+	unsigned long alignmask = crypto_tfm_alg_alignmask(tfm);
+	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
+
+	if (unlikely(((unsigned long)dst | (unsigned long)src) &amp; alignmask)) {
+		cipher_crypt_unaligned(cipher-&gt;cia_encrypt, tfm, dst, src);
+		return;
+	}
+
+	cipher-&gt;cia_encrypt(tfm, dst, src);
+}
+
+static void cipher_decrypt_unaligned(struct crypto_tfm *tfm,
+				     u8 *dst, const u8 *src)
+{
+	unsigned long alignmask = crypto_tfm_alg_alignmask(tfm);
+	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
+
+	if (unlikely(((unsigned long)dst | (unsigned long)src) &amp; alignmask)) {
+		cipher_crypt_unaligned(cipher-&gt;cia_decrypt, tfm, dst, src);
+		return;
+	}
+
+	cipher-&gt;cia_decrypt(tfm, dst, src);
+}
+
 int crypto_init_cipher_ops(struct crypto_tfm *tfm)
 {
 	int ret = 0;
 	struct cipher_tfm *ops = &amp;tfm-&gt;crt_cipher;
+	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
 
 	ops-&gt;cit_setkey = setkey;
+	ops-&gt;cit_encrypt_one = crypto_tfm_alg_alignmask(tfm) ?
+		cipher_encrypt_unaligned : cipher-&gt;cia_encrypt;
+	ops-&gt;cit_decrypt_one = crypto_tfm_alg_alignmask(tfm) ?
+		cipher_decrypt_unaligned : cipher-&gt;cia_decrypt;
 
 	switch (tfm-&gt;crt_cipher.cit_mode) {
 	case CRYPTO_TFM_MODE_ECB:
diff --git a/include/crypto/algapi.h b/include/crypto/algapi.h
--- a/include/crypto/algapi.h
+++ b/include/crypto/algapi.h
@@ -67,5 +67,10 @@ static inline void *crypto_instance_ctx(
 	return inst-&gt;__ctx;
 }
 
+static inline struct cipher_alg *crypto_cipher_alg(struct crypto_cipher *tfm)
+{
+	return &amp;crypto_cipher_tfm(tfm)-&gt;__crt_alg-&gt;cra_cipher;
+}
+
 #endif	/* _CRYPTO_ALGAPI_H */
 
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -212,6 +212,8 @@ struct cipher_tfm {
 			   struct scatterlist *src,
 			   unsigned int nbytes, u8 *iv);
 	void (*cit_xor_block)(u8 *dst, const u8 *src);
+	void (*cit_encrypt_one)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
+	void (*cit_decrypt_one)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
 };
 
 struct digest_tfm {
@@ -256,6 +258,8 @@ struct crypto_tfm {
 	void *__crt_ctx[] CRYPTO_MINALIGN_ATTR;
 };
 
+#define crypto_cipher crypto_tfm
+
 enum {
 	CRYPTOA_UNSPEC,
 	CRYPTOA_ALG,
@@ -335,6 +339,21 @@ static inline unsigned int crypto_tfm_al
 	return tfm-&gt;__crt_alg-&gt;cra_alignmask;
 }
 
+static inline u32 crypto_tfm_get_flags(struct crypto_tfm *tfm)
+{
+	return tfm-&gt;crt_flags;
+}
+
+static inline void crypto_tfm_set_flags(struct crypto_tfm *tfm, u32 flags)
+{
+	tfm-&gt;crt_flags |= flags;
+}
+
+static inline void crypto_tfm_clear_flags(struct crypto_tfm *tfm, u32 flags)
+{
+	tfm-&gt;crt_flags &amp;= ~flags;
+}
+
 static inline void *crypto_tfm_ctx(struct crypto_tfm *tfm)
 {
 	return tfm-&gt;__crt_ctx;
@@ -349,6 +368,83 @@ static inline unsigned int crypto_tfm_ct
 /*
  * API wrappers.
  */
+static inline struct crypto_cipher *__crypto_cipher_cast(struct crypto_tfm *tfm)
+{
+	return (struct crypto_cipher *)tfm;
+}
+
+static inline struct crypto_cipher *crypto_cipher_cast(struct crypto_tfm *tfm)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
+	return __crypto_cipher_cast(tfm);
+}
+
+static inline struct crypto_cipher *crypto_alloc_cipher(const char *alg_name,
+							u32 type, u32 mask)
+{
+	type &amp;= ~CRYPTO_ALG_TYPE_MASK;
+	type |= CRYPTO_ALG_TYPE_CIPHER;
+	mask |= CRYPTO_ALG_TYPE_MASK;
+
+	return __crypto_cipher_cast(crypto_alloc_base(alg_name, type, mask));
+}
+
+static inline struct crypto_tfm *crypto_cipher_tfm(struct crypto_cipher *tfm)
+{
+	return tfm;
+}
+
+static inline void crypto_free_cipher(struct crypto_cipher *tfm)
+{
+	crypto_free_tfm(crypto_cipher_tfm(tfm));
+}
+
+static inline struct cipher_tfm *crypto_cipher_crt(struct crypto_cipher *tfm)
+{
+	return &amp;crypto_cipher_tfm(tfm)-&gt;crt_cipher;
+}
+
+static inline unsigned int crypto_cipher_blocksize(struct crypto_cipher *tfm)
+{
+	return crypto_tfm_alg_blocksize(crypto_cipher_tfm(tfm));
+}
+
+static inline unsigned int crypto_cipher_alignmask(struct crypto_cipher *tfm)
+{
+	return crypto_tfm_alg_alignmask(crypto_cipher_tfm(tfm));
+}
+
+static inline u32 crypto_cipher_get_flags(struct crypto_cipher *tfm)
+{
+	return crypto_tfm_get_flags(crypto_cipher_tfm(tfm));
+}
+
+static inline void crypto_cipher_set_flags(struct crypto_cipher *tfm,
+					   u32 flags)
+{
+	crypto_tfm_set_flags(crypto_cipher_tfm(tfm), flags);
+}
+
+static inline void crypto_cipher_clear_flags(struct crypto_cipher *tfm,
+					     u32 flags)
+{
+	crypto_tfm_clear_flags(crypto_cipher_tfm(tfm), flags);
+}
+
+static inline void crypto_cipher_encrypt_one(struct crypto_cipher *tfm,
+					     u8 *dst, const u8 *src)
+{
+	crypto_cipher_crt(tfm)-&gt;cit_encrypt_one(crypto_cipher_tfm(tfm),
+						dst, src);
+}
+
+static inline void crypto_cipher_decrypt_one(struct crypto_cipher *tfm,
+					     u8 *dst, const u8 *src)
+{
+	crypto_cipher_crt(tfm)-&gt;cit_decrypt_one(crypto_cipher_tfm(tfm),
+						dst, src);
+}
+
 static inline void crypto_digest_init(struct crypto_tfm *tfm)
 {
 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813122005</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:20:05-0400</timestampReceived><subject>[PATCH 3/16] [CRYPTO] scatterwalk: Prepare for block ciphers</subject><body>

[CRYPTO] scatterwalk: Prepare for block ciphers

This patch prepares the scatterwalk code for use by the new block cipher
type.

Firstly it halves the size of scatter_walk on 32-bit platforms.  This
is important as we allocate at least two of these objects on the stack
for each block cipher operation.

It also exports the symbols since the block cipher code can be built as
a module.

Finally there is a hack in scatterwalk_unmap that relies on progress
being made.  Unfortunately, for hardware crypto we can't guarantee
progress to be made since the hardware can fail.

So this also gets rid of the hack by not advancing the address returned
by scatterwalk_map.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 crypto/cipher.c         |   27 +++++++-------
 crypto/scatterwalk.c    |   89 +++++++++++++++++++++---------------------------
 crypto/scatterwalk.h    |   48 +++++++++++++++----------
 include/crypto/algapi.h |    5 ++
 4 files changed, 87 insertions(+), 82 deletions(-)

diff --git a/crypto/cipher.c b/crypto/cipher.c
--- a/crypto/cipher.c
+++ b/crypto/cipher.c
@@ -45,15 +45,10 @@ static unsigned int crypt_slow(const str
 	u8 buffer[bsize * 2 + alignmask];
 	u8 *src = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
 	u8 *dst = src + bsize;
-	unsigned int n;
-
-	n = scatterwalk_copychunks(src, in, bsize, 0);
-	scatterwalk_advance(in, n);
 
+	scatterwalk_copychunks(src, in, bsize, 0);
 	desc-&gt;prfn(desc, dst, src, bsize);
-
-	n = scatterwalk_copychunks(dst, out, bsize, 1);
-	scatterwalk_advance(out, n);
+	scatterwalk_copychunks(dst, out, bsize, 1);
 
 	return bsize;
 }
@@ -64,12 +59,16 @@ static inline unsigned int crypt_fast(co
 				      unsigned int nbytes, u8 *tmp)
 {
 	u8 *src, *dst;
+	u8 *real_src, *real_dst;
+
+	real_src = scatterwalk_map(in, 0);
+	real_dst = scatterwalk_map(out, 1);
 
-	src = in-&gt;data;
-	dst = scatterwalk_samebuf(in, out) ? src : out-&gt;data;
+	src = real_src;
+	dst = scatterwalk_samebuf(in, out) ? src : real_dst;
 
 	if (tmp) {
-		memcpy(tmp, in-&gt;data, nbytes);
+		memcpy(tmp, src, nbytes);
 		src = tmp;
 		dst = tmp;
 	}
@@ -77,7 +76,10 @@ static inline unsigned int crypt_fast(co
 	nbytes = desc-&gt;prfn(desc, dst, src, nbytes);
 
 	if (tmp)
-		memcpy(out-&gt;data, tmp, nbytes);
+		memcpy(real_dst, tmp, nbytes);
+
+	scatterwalk_unmap(real_src, 0);
+	scatterwalk_unmap(real_dst, 1);
 
 	scatterwalk_advance(in, nbytes);
 	scatterwalk_advance(out, nbytes);
@@ -126,9 +128,6 @@ static int crypt(const struct cipher_des
 			tmp = (u8 *)buffer;
 		}
 
-		scatterwalk_map(&amp;walk_in, 0);
-		scatterwalk_map(&amp;walk_out, 1);
-
 		n = scatterwalk_clamp(&amp;walk_in, n);
 		n = scatterwalk_clamp(&amp;walk_out, n);
 
diff --git a/crypto/scatterwalk.c b/crypto/scatterwalk.c
--- a/crypto/scatterwalk.c
+++ b/crypto/scatterwalk.c
@@ -15,9 +15,11 @@
  */
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/mm.h&gt;
+#include &lt;linux/module.h&gt;
 #include &lt;linux/pagemap.h&gt;
 #include &lt;linux/highmem.h&gt;
-#include &lt;asm/scatterlist.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+
 #include "internal.h"
 #include "scatterwalk.h"
 
@@ -27,88 +29,77 @@ enum km_type crypto_km_types[] = {
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
 };
+EXPORT_SYMBOL_GPL(crypto_km_types);
 
-static void memcpy_dir(void *buf, void *sgdata, size_t nbytes, int out)
+static inline void memcpy_dir(void *buf, void *sgdata, size_t nbytes, int out)
 {
-	if (out)
-		memcpy(sgdata, buf, nbytes);
-	else
-		memcpy(buf, sgdata, nbytes);
+	void *src = out ? buf : sgdata;
+	void *dst = out ? sgdata : buf;
+
+	memcpy(dst, src, nbytes);
 }
 
 void scatterwalk_start(struct scatter_walk *walk, struct scatterlist *sg)
 {
-	unsigned int rest_of_page;
-
 	walk-&gt;sg = sg;
 
-	walk-&gt;page = sg-&gt;page;
-	walk-&gt;len_this_segment = sg-&gt;length;
-
 	BUG_ON(!sg-&gt;length);
 
-	rest_of_page = PAGE_CACHE_SIZE - (sg-&gt;offset &amp; (PAGE_CACHE_SIZE - 1));
-	walk-&gt;len_this_page = min(sg-&gt;length, rest_of_page);
 	walk-&gt;offset = sg-&gt;offset;
 }
+EXPORT_SYMBOL_GPL(scatterwalk_start);
 
-void scatterwalk_map(struct scatter_walk *walk, int out)
-{
-	walk-&gt;data = crypto_kmap(walk-&gt;page, out) + walk-&gt;offset;
-}
-
-static inline void scatterwalk_unmap(struct scatter_walk *walk, int out)
+void *scatterwalk_map(struct scatter_walk *walk, int out)
 {
-	/* walk-&gt;data may be pointing the first byte of the next page;
-	   however, we know we transfered at least one byte.  So,
-	   walk-&gt;data - 1 will be a virtual address in the mapped page. */
-	crypto_kunmap(walk-&gt;data - 1, out);
+	return crypto_kmap(scatterwalk_page(walk), out) +
+	       offset_in_page(walk-&gt;offset);
 }
+EXPORT_SYMBOL_GPL(scatterwalk_map);
 
 static void scatterwalk_pagedone(struct scatter_walk *walk, int out,
 				 unsigned int more)
 {
 	if (out)
-		flush_dcache_page(walk-&gt;page);
+		flush_dcache_page(scatterwalk_page(walk));
 
 	if (more) {
-		walk-&gt;len_this_segment -= walk-&gt;len_this_page;
-
-		if (walk-&gt;len_this_segment) {
-			walk-&gt;page++;
-			walk-&gt;len_this_page = min(walk-&gt;len_this_segment,
-						  (unsigned)PAGE_CACHE_SIZE);
-			walk-&gt;offset = 0;
-		}
-		else
+		walk-&gt;offset += PAGE_SIZE - 1;
+		walk-&gt;offset &amp;= PAGE_MASK;
+		if (walk-&gt;offset &gt;= walk-&gt;sg-&gt;offset + walk-&gt;sg-&gt;length)
 			scatterwalk_start(walk, sg_next(walk-&gt;sg));
 	}
 }
 
 void scatterwalk_done(struct scatter_walk *walk, int out, int more)
 {
-	scatterwalk_unmap(walk, out);
-	if (walk-&gt;len_this_page == 0 || !more)
+	if (!offset_in_page(walk-&gt;offset) || !more)
 		scatterwalk_pagedone(walk, out, more);
 }
+EXPORT_SYMBOL_GPL(scatterwalk_done);
 
-/*
- * Do not call this unless the total length of all of the fragments
- * has been verified as multiple of the block size.
- */
-int scatterwalk_copychunks(void *buf, struct scatter_walk *walk,
-			   size_t nbytes, int out)
+void scatterwalk_copychunks(void *buf, struct scatter_walk *walk,
+			    size_t nbytes, int out)
 {
-	while (nbytes &gt; walk-&gt;len_this_page) {
-		memcpy_dir(buf, walk-&gt;data, walk-&gt;len_this_page, out);
-		buf += walk-&gt;len_this_page;
-		nbytes -= walk-&gt;len_this_page;
+	for (;;) {
+		unsigned int len_this_page = scatterwalk_pagelen(walk);
+		u8 *vaddr;
+
+		if (len_this_page &gt; nbytes)
+			len_this_page = nbytes;
+
+		vaddr = scatterwalk_map(walk, out);
+		memcpy_dir(buf, vaddr, len_this_page, out);
+		scatterwalk_unmap(vaddr, out);
+
+		if (nbytes == len_this_page)
+			break;
+
+		buf += len_this_page;
+		nbytes -= len_this_page;
 
-		scatterwalk_unmap(walk, out);
 		scatterwalk_pagedone(walk, out, 1);
-		scatterwalk_map(walk, out);
 	}
 
-	memcpy_dir(buf, walk-&gt;data, nbytes, out);
-	return nbytes;
+	scatterwalk_advance(walk, nbytes);
 }
+EXPORT_SYMBOL_GPL(scatterwalk_copychunks);
diff --git a/crypto/scatterwalk.h b/crypto/scatterwalk.h
--- a/crypto/scatterwalk.h
+++ b/crypto/scatterwalk.h
@@ -14,17 +14,11 @@
 
 #ifndef _CRYPTO_SCATTERWALK_H
 #define _CRYPTO_SCATTERWALK_H
+
 #include &lt;linux/mm.h&gt;
-#include &lt;asm/scatterlist.h&gt;
+#include &lt;linux/scatterlist.h&gt;
 
-struct scatter_walk {
-	struct scatterlist	*sg;
-	struct page		*page;
-	void			*data;
-	unsigned int		len_this_page;
-	unsigned int		len_this_segment;
-	unsigned int		offset;
-};
+#include "internal.h"
 
 /* Define sg_next is an inline routine now in case we want to change
    scatterlist to a linked list later. */
@@ -33,26 +27,31 @@ static inline struct scatterlist *sg_nex
 	return sg + 1;
 }
 
-static inline int scatterwalk_samebuf(struct scatter_walk *walk_in,
-				      struct scatter_walk *walk_out)
+static inline unsigned long scatterwalk_samebuf(struct scatter_walk *walk_in,
+						struct scatter_walk *walk_out)
 {
-	return walk_in-&gt;page == walk_out-&gt;page &amp;&amp;
-	       walk_in-&gt;offset == walk_out-&gt;offset;
+	return !(((walk_in-&gt;sg-&gt;page - walk_out-&gt;sg-&gt;page) &lt;&lt; PAGE_SHIFT) +
+		 (int)(walk_in-&gt;offset - walk_out-&gt;offset));
+}
+
+static inline unsigned int scatterwalk_pagelen(struct scatter_walk *walk)
+{
+	unsigned int len = walk-&gt;sg-&gt;offset + walk-&gt;sg-&gt;length - walk-&gt;offset;
+	unsigned int len_this_page = offset_in_page(~walk-&gt;offset) + 1;
+	return len_this_page &gt; len ? len : len_this_page;
 }
 
 static inline unsigned int scatterwalk_clamp(struct scatter_walk *walk,
 					     unsigned int nbytes)
 {
-	return nbytes &gt; walk-&gt;len_this_page ? walk-&gt;len_this_page : nbytes;
+	unsigned int len_this_page = scatterwalk_pagelen(walk);
+	return nbytes &gt; len_this_page ? len_this_page : nbytes;
 }
 
 static inline void scatterwalk_advance(struct scatter_walk *walk,
 				       unsigned int nbytes)
 {
-	walk-&gt;data += nbytes;
 	walk-&gt;offset += nbytes;
-	walk-&gt;len_this_page -= nbytes;
-	walk-&gt;len_this_segment -= nbytes;
 }
 
 static inline unsigned int scatterwalk_aligned(struct scatter_walk *walk,
@@ -61,9 +60,20 @@ static inline unsigned int scatterwalk_a
 	return !(walk-&gt;offset &amp; alignmask);
 }
 
+static inline struct page *scatterwalk_page(struct scatter_walk *walk)
+{
+	return walk-&gt;sg-&gt;page + (walk-&gt;offset &gt;&gt; PAGE_SHIFT);
+}
+
+static inline void scatterwalk_unmap(void *vaddr, int out)
+{
+	crypto_kunmap(vaddr, out);
+}
+
 void scatterwalk_start(struct scatter_walk *walk, struct scatterlist *sg);
-int scatterwalk_copychunks(void *buf, struct scatter_walk *walk, size_t nbytes, int out);
-void scatterwalk_map(struct scatter_walk *walk, int out);
+void scatterwalk_copychunks(void *buf, struct scatter_walk *walk,
+			    size_t nbytes, int out);
+void *scatterwalk_map(struct scatter_walk *walk, int out);
 void scatterwalk_done(struct scatter_walk *walk, int out, int more);
 
 #endif  /* _CRYPTO_SCATTERWALK_H */
diff --git a/include/crypto/algapi.h b/include/crypto/algapi.h
--- a/include/crypto/algapi.h
+++ b/include/crypto/algapi.h
@@ -48,6 +48,11 @@ struct crypto_spawn {
 	struct crypto_instance *inst;
 };
 
+struct scatter_walk {
+	struct scatterlist *sg;
+	unsigned int offset;
+};
+
 int crypto_register_template(struct crypto_template *tmpl);
 void crypto_unregister_template(struct crypto_template *tmpl);
 struct crypto_template *crypto_lookup_template(const char *name);
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813122007</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:20:07-0400</timestampReceived><subject>[PATCH 4/16] [CRYPTO] cipher: Added block cipher type</subject><body>

[CRYPTO] cipher: Added block cipher type

This patch adds the new type of block ciphers.  Unlike current cipher
algorithms which operate on a single block at a time, block ciphers
operate on an arbitrarily long linear area of data.  As it is block-based,
it will skip any data remaining at the end which cannot form a block.

The block cipher has one major difference when compared to the existing
block cipher implementation.  The sg walking is now performed by the
algorithm rather than the cipher mid-layer.  This is needed for drivers
that directly support sg lists.  It also improves performance for all
algorithms as it reduces the total number of indirect calls by one.

In future the existing cipher algorithm will be converted to only have
a single-block interface.  This will be done after all existing users
have switched over to the new block cipher type.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 crypto/Kconfig          |    4 
 crypto/Makefile         |    2 
 crypto/blkcipher.c      |  390 ++++++++++++++++++++++++++++++++++++++++++++++++
 include/crypto/algapi.h |   65 ++++++++
 include/linux/crypto.h  |  179 ++++++++++++++++++++++
 5 files changed, 640 insertions(+)

diff --git a/crypto/Kconfig b/crypto/Kconfig
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -16,6 +16,10 @@ config CRYPTO_ALGAPI
 	help
 	  This option provides the API for cryptographic algorithms.
 
+config CRYPTO_BLKCIPHER
+	tristate
+	select CRYPTO_ALGAPI
+
 config CRYPTO_MANAGER
 	tristate "Cryptographic algorithm manager"
 	select CRYPTO_ALGAPI
diff --git a/crypto/Makefile b/crypto/Makefile
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -8,6 +8,8 @@ crypto_algapi-$(CONFIG_PROC_FS) += proc.
 crypto_algapi-objs := algapi.o $(crypto_algapi-y)
 obj-$(CONFIG_CRYPTO_ALGAPI) += crypto_algapi.o
 
+obj-$(CONFIG_CRYPTO_BLKCIPHER) += blkcipher.o
+
 obj-$(CONFIG_CRYPTO_MANAGER) += cryptomgr.o
 obj-$(CONFIG_CRYPTO_HMAC) += hmac.o
 obj-$(CONFIG_CRYPTO_NULL) += crypto_null.o
diff --git a/crypto/blkcipher.c b/crypto/blkcipher.c
new file mode 100644
--- /dev/null
+++ b/crypto/blkcipher.c
@@ -0,0 +1,390 @@
+/*
+ * Block chaining cipher operations.
+ * 
+ * Generic encrypt/decrypt wrapper for ciphers, handles operations across
+ * multiple page boundaries by using temporary blocks.  In user context,
+ * the kernel is given a chance to schedule us once per page.
+ *
+ * Copyright (c) 2006 Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ */
+
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/io.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/string.h&gt;
+
+#include "internal.h"
+#include "scatterwalk.h"
+
+enum {
+	BLKCIPHER_WALK_PHYS = 1 &lt;&lt; 0,
+	BLKCIPHER_WALK_SLOW = 1 &lt;&lt; 1,
+	BLKCIPHER_WALK_COPY = 1 &lt;&lt; 2,
+	BLKCIPHER_WALK_DIFF = 1 &lt;&lt; 3,
+};
+
+static int blkcipher_walk_next(struct blkcipher_desc *desc,
+			       struct blkcipher_walk *walk);
+static int blkcipher_walk_first(struct blkcipher_desc *desc,
+				struct blkcipher_walk *walk);
+
+static inline void blkcipher_map_src(struct blkcipher_walk *walk)
+{
+	walk-&gt;src.virt.addr = scatterwalk_map(&amp;walk-&gt;in, 0);
+}
+
+static inline void blkcipher_map_dst(struct blkcipher_walk *walk)
+{
+	walk-&gt;dst.virt.addr = scatterwalk_map(&amp;walk-&gt;out, 1);
+}
+
+static inline void blkcipher_unmap_src(struct blkcipher_walk *walk)
+{
+	scatterwalk_unmap(walk-&gt;src.virt.addr, 0);
+}
+
+static inline void blkcipher_unmap_dst(struct blkcipher_walk *walk)
+{
+	scatterwalk_unmap(walk-&gt;dst.virt.addr, 1);
+}
+
+static inline u8 *blkcipher_get_spot(u8 *start, unsigned int len)
+{
+	if (offset_in_page(start + len) &lt; len)
+		return (u8 *)((unsigned long)(start + len) &amp; PAGE_MASK);
+	return start;
+}
+
+static inline unsigned int blkcipher_done_slow(struct crypto_blkcipher *tfm,
+					       struct blkcipher_walk *walk,
+					       unsigned int bsize)
+{
+	u8 *addr;
+	unsigned int alignmask = crypto_blkcipher_alignmask(tfm);
+
+	addr = (u8 *)ALIGN((unsigned long)walk-&gt;buffer, alignmask + 1);
+	addr = blkcipher_get_spot(addr, bsize);
+	scatterwalk_copychunks(addr, &amp;walk-&gt;out, bsize, 1);
+	return bsize;
+}
+
+static inline unsigned int blkcipher_done_fast(struct blkcipher_walk *walk,
+					       unsigned int n)
+{
+	n = walk-&gt;nbytes - n;
+
+	if (walk-&gt;flags &amp; BLKCIPHER_WALK_COPY) {
+		blkcipher_map_dst(walk);
+		memcpy(walk-&gt;dst.virt.addr, walk-&gt;page, n);
+		blkcipher_unmap_dst(walk);
+	} else if (!(walk-&gt;flags &amp; BLKCIPHER_WALK_PHYS)) {
+		blkcipher_unmap_src(walk);
+		if (walk-&gt;flags &amp; BLKCIPHER_WALK_DIFF)
+			blkcipher_unmap_dst(walk);
+	}
+
+	scatterwalk_advance(&amp;walk-&gt;in, n);
+	scatterwalk_advance(&amp;walk-&gt;out, n);
+
+	return n;
+}
+
+int blkcipher_walk_done(struct blkcipher_desc *desc,
+			struct blkcipher_walk *walk, int err)
+{
+	struct crypto_blkcipher *tfm = desc-&gt;tfm;
+	unsigned int nbytes = 0;
+
+	if (likely(err &gt;= 0)) {
+		unsigned int bsize = crypto_blkcipher_blocksize(tfm);
+		unsigned int n;
+
+		if (likely(!(walk-&gt;flags &amp; BLKCIPHER_WALK_SLOW)))
+			n = blkcipher_done_fast(walk, err);
+		else
+			n = blkcipher_done_slow(tfm, walk, bsize);
+
+		nbytes = walk-&gt;total - n;
+		err = 0;
+	}
+
+	scatterwalk_done(&amp;walk-&gt;in, 0, nbytes);
+	scatterwalk_done(&amp;walk-&gt;out, 1, nbytes);
+
+	walk-&gt;total = nbytes;
+	walk-&gt;nbytes = nbytes;
+
+	if (nbytes) {
+		crypto_yield(desc-&gt;flags);
+		return blkcipher_walk_next(desc, walk);
+	}
+
+	if (walk-&gt;iv != desc-&gt;info)
+		memcpy(desc-&gt;info, walk-&gt;iv, crypto_blkcipher_ivsize(tfm));
+	if (walk-&gt;buffer != walk-&gt;page)
+		kfree(walk-&gt;buffer);
+	if (walk-&gt;page)
+		free_page((unsigned long)walk-&gt;page);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(blkcipher_walk_done);
+
+static inline int blkcipher_next_slow(struct blkcipher_desc *desc,
+				      struct blkcipher_walk *walk,
+				      unsigned int bsize,
+				      unsigned int alignmask)
+{
+	unsigned int n;
+
+	if (walk-&gt;buffer)
+		goto ok;
+
+	walk-&gt;buffer = walk-&gt;page;
+	if (walk-&gt;buffer)
+		goto ok;
+
+	n = bsize * 2 + (alignmask &amp; ~(crypto_tfm_ctx_alignment() - 1));
+	walk-&gt;buffer = kmalloc(n, GFP_ATOMIC);
+	if (!walk-&gt;buffer)
+		return blkcipher_walk_done(desc, walk, -ENOMEM);
+
+ok:
+	walk-&gt;dst.virt.addr = (u8 *)ALIGN((unsigned long)walk-&gt;buffer,
+					  alignmask + 1);
+	walk-&gt;dst.virt.addr = blkcipher_get_spot(walk-&gt;dst.virt.addr, bsize);
+	walk-&gt;src.virt.addr = blkcipher_get_spot(walk-&gt;dst.virt.addr + bsize,
+						 bsize);
+
+	scatterwalk_copychunks(walk-&gt;src.virt.addr, &amp;walk-&gt;in, bsize, 0);
+
+	walk-&gt;nbytes = bsize;
+	walk-&gt;flags |= BLKCIPHER_WALK_SLOW;
+
+	return 0;
+}
+
+static inline int blkcipher_next_copy(struct blkcipher_walk *walk)
+{
+	u8 *tmp = walk-&gt;page;
+
+	blkcipher_map_src(walk);
+	memcpy(tmp, walk-&gt;src.virt.addr, walk-&gt;nbytes);
+	blkcipher_unmap_src(walk);
+
+	walk-&gt;src.virt.addr = tmp;
+	walk-&gt;dst.virt.addr = tmp;
+
+	return 0;
+}
+
+static inline int blkcipher_next_fast(struct blkcipher_desc *desc,
+				      struct blkcipher_walk *walk)
+{
+	unsigned long diff;
+
+	walk-&gt;src.phys.page = scatterwalk_page(&amp;walk-&gt;in);
+	walk-&gt;src.phys.offset = offset_in_page(walk-&gt;in.offset);
+	walk-&gt;dst.phys.page = scatterwalk_page(&amp;walk-&gt;out);
+	walk-&gt;dst.phys.offset = offset_in_page(walk-&gt;out.offset);
+
+	if (walk-&gt;flags &amp; BLKCIPHER_WALK_PHYS)
+		return 0;
+
+	diff = walk-&gt;src.phys.offset - walk-&gt;dst.phys.offset;
+	diff |= walk-&gt;src.virt.page - walk-&gt;dst.virt.page;
+
+	blkcipher_map_src(walk);
+	walk-&gt;dst.virt.addr = walk-&gt;src.virt.addr;
+
+	if (diff) {
+		walk-&gt;flags |= BLKCIPHER_WALK_DIFF;
+		blkcipher_map_dst(walk);
+	}
+
+	return 0;
+}
+
+static int blkcipher_walk_next(struct blkcipher_desc *desc,
+			       struct blkcipher_walk *walk)
+{
+	struct crypto_blkcipher *tfm = desc-&gt;tfm;
+	unsigned int alignmask = crypto_blkcipher_alignmask(tfm);
+	unsigned int bsize = crypto_blkcipher_blocksize(tfm);
+	unsigned int n;
+	int err;
+
+	n = walk-&gt;total;
+	if (unlikely(n &lt; bsize)) {
+		desc-&gt;flags |= CRYPTO_TFM_RES_BAD_BLOCK_LEN;
+		return blkcipher_walk_done(desc, walk, -EINVAL);
+	}
+
+	walk-&gt;flags &amp;= ~(BLKCIPHER_WALK_SLOW | BLKCIPHER_WALK_COPY |
+			 BLKCIPHER_WALK_DIFF);
+	if (!scatterwalk_aligned(&amp;walk-&gt;in, alignmask) ||
+	    !scatterwalk_aligned(&amp;walk-&gt;out, alignmask)) {
+		walk-&gt;flags |= BLKCIPHER_WALK_COPY;
+		if (!walk-&gt;page) {
+			walk-&gt;page = (void *)__get_free_page(GFP_ATOMIC);
+			if (!walk-&gt;page)
+				n = 0;
+		}
+	}
+
+	n = scatterwalk_clamp(&amp;walk-&gt;in, n);
+	n = scatterwalk_clamp(&amp;walk-&gt;out, n);
+
+	if (unlikely(n &lt; bsize)) {
+		err = blkcipher_next_slow(desc, walk, bsize, alignmask);
+		goto set_phys_lowmem;
+	}
+
+	walk-&gt;nbytes = n;
+	if (walk-&gt;flags &amp; BLKCIPHER_WALK_COPY) {
+		err = blkcipher_next_copy(walk);
+		goto set_phys_lowmem;
+	}
+
+	return blkcipher_next_fast(desc, walk);
+
+set_phys_lowmem:
+	if (walk-&gt;flags &amp; BLKCIPHER_WALK_PHYS) {
+		walk-&gt;src.phys.page = virt_to_page(walk-&gt;src.virt.addr);
+		walk-&gt;dst.phys.page = virt_to_page(walk-&gt;dst.virt.addr);
+		walk-&gt;src.phys.offset &amp;= PAGE_SIZE - 1;
+		walk-&gt;dst.phys.offset &amp;= PAGE_SIZE - 1;
+	}
+	return err;
+}
+
+static inline int blkcipher_copy_iv(struct blkcipher_walk *walk,
+				    struct crypto_blkcipher *tfm,
+				    unsigned int alignmask)
+{
+	unsigned bs = crypto_blkcipher_blocksize(tfm);
+	unsigned int ivsize = crypto_blkcipher_ivsize(tfm);
+	unsigned int size = bs * 2 + ivsize + max(bs, ivsize) - (alignmask + 1);
+	u8 *iv;
+
+	size += alignmask &amp; ~(crypto_tfm_ctx_alignment() - 1);
+	walk-&gt;buffer = kmalloc(size, GFP_ATOMIC);
+	if (!walk-&gt;buffer)
+		return -ENOMEM;
+
+	iv = (u8 *)ALIGN((unsigned long)walk-&gt;buffer, alignmask + 1);
+	iv = blkcipher_get_spot(iv, bs) + bs;
+	iv = blkcipher_get_spot(iv, bs) + bs;
+	iv = blkcipher_get_spot(iv, ivsize);
+
+	walk-&gt;iv = memcpy(iv, walk-&gt;iv, ivsize);
+	return 0;
+}
+
+int blkcipher_walk_virt(struct blkcipher_desc *desc,
+			struct blkcipher_walk *walk)
+{
+	walk-&gt;flags &amp;= ~BLKCIPHER_WALK_PHYS;
+	return blkcipher_walk_first(desc, walk);
+}
+EXPORT_SYMBOL_GPL(blkcipher_walk_virt);
+
+int blkcipher_walk_phys(struct blkcipher_desc *desc,
+			struct blkcipher_walk *walk)
+{
+	walk-&gt;flags |= BLKCIPHER_WALK_PHYS;
+	return blkcipher_walk_first(desc, walk);
+}
+EXPORT_SYMBOL_GPL(blkcipher_walk_phys);
+
+static int blkcipher_walk_first(struct blkcipher_desc *desc,
+				struct blkcipher_walk *walk)
+{
+	struct crypto_blkcipher *tfm = desc-&gt;tfm;
+	unsigned int alignmask = crypto_blkcipher_alignmask(tfm);
+
+	walk-&gt;nbytes = walk-&gt;total;
+	if (unlikely(!walk-&gt;total))
+		return 0;
+
+	walk-&gt;buffer = NULL;
+	walk-&gt;iv = desc-&gt;info;
+	if (unlikely(((unsigned long)walk-&gt;iv &amp; alignmask))) {
+		int err = blkcipher_copy_iv(walk, tfm, alignmask);
+		if (err)
+			return err;
+	}
+
+	scatterwalk_start(&amp;walk-&gt;in, walk-&gt;in.sg);
+	scatterwalk_start(&amp;walk-&gt;out, walk-&gt;out.sg);
+	walk-&gt;page = NULL;
+
+	return blkcipher_walk_next(desc, walk);
+}
+
+static int setkey(struct crypto_tfm *tfm, const u8 *key,
+		  unsigned int keylen)
+{
+	struct blkcipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_blkcipher;
+
+	if (keylen &lt; cipher-&gt;min_keysize || keylen &gt; cipher-&gt;max_keysize) {
+		tfm-&gt;crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
+		return -EINVAL;
+	}
+
+	return cipher-&gt;setkey(tfm, key, keylen);
+}
+
+static unsigned int crypto_blkcipher_ctxsize(struct crypto_alg *alg)
+{
+	struct blkcipher_alg *cipher = &amp;alg-&gt;cra_blkcipher;
+	unsigned int len = alg-&gt;cra_ctxsize;
+
+	if (cipher-&gt;ivsize) {
+		len = ALIGN(len, (unsigned long)alg-&gt;cra_alignmask + 1);
+		len += cipher-&gt;ivsize;
+	}
+
+	return len;
+}
+
+static int crypto_init_blkcipher_ops(struct crypto_tfm *tfm)
+{
+	struct blkcipher_tfm *crt = &amp;tfm-&gt;crt_blkcipher;
+	struct blkcipher_alg *alg = &amp;tfm-&gt;__crt_alg-&gt;cra_blkcipher;
+	unsigned long align = crypto_tfm_alg_alignmask(tfm) + 1;
+	unsigned long addr;
+
+	if (alg-&gt;ivsize &gt; PAGE_SIZE / 8)
+		return -EINVAL;
+
+	crt-&gt;setkey = setkey;
+	crt-&gt;encrypt = alg-&gt;encrypt;
+	crt-&gt;decrypt = alg-&gt;decrypt;
+
+	addr = (unsigned long)crypto_tfm_ctx(tfm);
+	addr = ALIGN(addr, align);
+	addr += ALIGN(tfm-&gt;__crt_alg-&gt;cra_ctxsize, align);
+	crt-&gt;iv = (void *)addr;
+
+	return 0;
+}
+
+const struct crypto_type crypto_blkcipher_type = {
+	.ctxsize = crypto_blkcipher_ctxsize,
+	.init = crypto_init_blkcipher_ops,
+};
+EXPORT_SYMBOL_GPL(crypto_blkcipher_type);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Generic block chaining cipher type");
diff --git a/include/crypto/algapi.h b/include/crypto/algapi.h
--- a/include/crypto/algapi.h
+++ b/include/crypto/algapi.h
@@ -53,6 +53,34 @@ struct scatter_walk {
 	unsigned int offset;
 };
 
+struct blkcipher_walk {
+	union {
+		struct {
+			struct page *page;
+			unsigned long offset;
+		} phys;
+
+		struct {
+			u8 *page;
+			u8 *addr;
+		} virt;
+	} src, dst;
+
+	struct scatter_walk in;
+	unsigned int nbytes;
+
+	struct scatter_walk out;
+	unsigned int total;
+
+	void *page;
+	u8 *buffer;
+	u8 *iv;
+
+	int flags;
+};
+
+extern const struct crypto_type crypto_blkcipher_type;
+
 int crypto_register_template(struct crypto_template *tmpl);
 void crypto_unregister_template(struct crypto_template *tmpl);
 struct crypto_template *crypto_lookup_template(const char *name);
@@ -67,15 +95,52 @@ struct crypto_alg *crypto_get_attr_alg(v
 struct crypto_instance *crypto_alloc_instance(const char *name,
 					      struct crypto_alg *alg);
 
+int blkcipher_walk_done(struct blkcipher_desc *desc,
+			struct blkcipher_walk *walk, int err);
+int blkcipher_walk_virt(struct blkcipher_desc *desc,
+			struct blkcipher_walk *walk);
+int blkcipher_walk_phys(struct blkcipher_desc *desc,
+			struct blkcipher_walk *walk);
+
+static inline void *crypto_tfm_ctx_aligned(struct crypto_tfm *tfm)
+{
+	unsigned long addr = (unsigned long)crypto_tfm_ctx(tfm);
+	unsigned long align = crypto_tfm_alg_alignmask(tfm);
+
+	if (align &lt;= crypto_tfm_ctx_alignment())
+		align = 1;
+	return (void *)ALIGN(addr, align);
+}
+
 static inline void *crypto_instance_ctx(struct crypto_instance *inst)
 {
 	return inst-&gt;__ctx;
 }
 
+static inline void *crypto_blkcipher_ctx(struct crypto_blkcipher *tfm)
+{
+	return crypto_tfm_ctx(&amp;tfm-&gt;base);
+}
+
+static inline void *crypto_blkcipher_ctx_aligned(struct crypto_blkcipher *tfm)
+{
+	return crypto_tfm_ctx_aligned(&amp;tfm-&gt;base);
+}
+
 static inline struct cipher_alg *crypto_cipher_alg(struct crypto_cipher *tfm)
 {
 	return &amp;crypto_cipher_tfm(tfm)-&gt;__crt_alg-&gt;cra_cipher;
 }
 
+static inline void blkcipher_walk_init(struct blkcipher_walk *walk,
+				       struct scatterlist *dst,
+				       struct scatterlist *src,
+				       unsigned int nbytes)
+{
+	walk-&gt;in.sg = src;
+	walk-&gt;out.sg = dst;
+	walk-&gt;total = nbytes;
+}
+
 #endif	/* _CRYPTO_ALGAPI_H */
 
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -32,6 +32,7 @@
 #define CRYPTO_ALG_TYPE_MASK		0x0000000f
 #define CRYPTO_ALG_TYPE_CIPHER		0x00000001
 #define CRYPTO_ALG_TYPE_DIGEST		0x00000002
+#define CRYPTO_ALG_TYPE_BLKCIPHER	0x00000003
 #define CRYPTO_ALG_TYPE_COMPRESS	0x00000004
 
 #define CRYPTO_ALG_LARVAL		0x00000010
@@ -77,9 +78,16 @@
 #endif
 
 struct scatterlist;
+struct crypto_blkcipher;
 struct crypto_tfm;
 struct crypto_type;
 
+struct blkcipher_desc {
+	struct crypto_blkcipher *tfm;
+	void *info;
+	u32 flags;
+};
+
 struct cipher_desc {
 	struct crypto_tfm *tfm;
 	void (*crfn)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
@@ -92,6 +100,21 @@ struct cipher_desc {
  * Algorithms: modular crypto algorithm implementations, managed
  * via crypto_register_alg() and crypto_unregister_alg().
  */
+struct blkcipher_alg {
+	int (*setkey)(struct crypto_tfm *tfm, const u8 *key,
+	              unsigned int keylen);
+	int (*encrypt)(struct blkcipher_desc *desc,
+		       struct scatterlist *dst, struct scatterlist *src,
+		       unsigned int nbytes);
+	int (*decrypt)(struct blkcipher_desc *desc,
+		       struct scatterlist *dst, struct scatterlist *src,
+		       unsigned int nbytes);
+
+	unsigned int min_keysize;
+	unsigned int max_keysize;
+	unsigned int ivsize;
+};
+
 struct cipher_alg {
 	unsigned int cia_min_keysize;
 	unsigned int cia_max_keysize;
@@ -131,6 +154,7 @@ struct compress_alg {
 			      unsigned int slen, u8 *dst, unsigned int *dlen);
 };
 
+#define cra_blkcipher	cra_u.blkcipher
 #define cra_cipher	cra_u.cipher
 #define cra_digest	cra_u.digest
 #define cra_compress	cra_u.compress
@@ -153,6 +177,7 @@ struct crypto_alg {
 	const struct crypto_type *cra_type;
 
 	union {
+		struct blkcipher_alg blkcipher;
 		struct cipher_alg cipher;
 		struct digest_alg digest;
 		struct compress_alg compress;
@@ -189,6 +214,16 @@ static inline int crypto_alg_available(c
  * crypto_free_*(), as well as the various helpers below.
  */
 
+struct blkcipher_tfm {
+	void *iv;
+	int (*setkey)(struct crypto_tfm *tfm, const u8 *key,
+		      unsigned int keylen);
+	int (*encrypt)(struct blkcipher_desc *desc, struct scatterlist *dst,
+		       struct scatterlist *src, unsigned int nbytes);
+	int (*decrypt)(struct blkcipher_desc *desc, struct scatterlist *dst,
+		       struct scatterlist *src, unsigned int nbytes);
+};
+
 struct cipher_tfm {
 	void *cit_iv;
 	unsigned int cit_ivsize;
@@ -239,6 +274,7 @@ struct compress_tfm {
 	                      u8 *dst, unsigned int *dlen);
 };
 
+#define crt_blkcipher	crt_u.blkcipher
 #define crt_cipher	crt_u.cipher
 #define crt_digest	crt_u.digest
 #define crt_compress	crt_u.compress
@@ -248,6 +284,7 @@ struct crypto_tfm {
 	u32 crt_flags;
 	
 	union {
+		struct blkcipher_tfm blkcipher;
 		struct cipher_tfm cipher;
 		struct digest_tfm digest;
 		struct compress_tfm compress;
@@ -260,6 +297,10 @@ struct crypto_tfm {
 
 #define crypto_cipher crypto_tfm
 
+struct crypto_blkcipher {
+	struct crypto_tfm base;
+};
+
 enum {
 	CRYPTOA_UNSPEC,
 	CRYPTOA_ALG,
@@ -368,6 +409,144 @@ static inline unsigned int crypto_tfm_ct
 /*
  * API wrappers.
  */
+static inline struct crypto_blkcipher *__crypto_blkcipher_cast(
+	struct crypto_tfm *tfm)
+{
+	return (struct crypto_blkcipher *)tfm;
+}
+
+static inline struct crypto_blkcipher *crypto_blkcipher_cast(
+	struct crypto_tfm *tfm)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_BLKCIPHER);
+	return __crypto_blkcipher_cast(tfm);
+}
+
+static inline struct crypto_blkcipher *crypto_alloc_blkcipher(
+	const char *alg_name, u32 type, u32 mask)
+{
+	type &amp;= ~CRYPTO_ALG_TYPE_MASK;
+	type |= CRYPTO_ALG_TYPE_BLKCIPHER;
+	mask |= CRYPTO_ALG_TYPE_MASK;
+
+	return __crypto_blkcipher_cast(crypto_alloc_base(alg_name, type, mask));
+}
+
+static inline struct crypto_tfm *crypto_blkcipher_tfm(
+	struct crypto_blkcipher *tfm)
+{
+	return &amp;tfm-&gt;base;
+}
+
+static inline void crypto_free_blkcipher(struct crypto_blkcipher *tfm)
+{
+	crypto_free_tfm(crypto_blkcipher_tfm(tfm));
+}
+
+static inline const char *crypto_blkcipher_name(struct crypto_blkcipher *tfm)
+{
+	return crypto_tfm_alg_name(crypto_blkcipher_tfm(tfm));
+}
+
+static inline struct blkcipher_tfm *crypto_blkcipher_crt(
+	struct crypto_blkcipher *tfm)
+{
+	return &amp;crypto_blkcipher_tfm(tfm)-&gt;crt_blkcipher;
+}
+
+static inline struct blkcipher_alg *crypto_blkcipher_alg(
+	struct crypto_blkcipher *tfm)
+{
+	return &amp;crypto_blkcipher_tfm(tfm)-&gt;__crt_alg-&gt;cra_blkcipher;
+}
+
+static inline unsigned int crypto_blkcipher_ivsize(struct crypto_blkcipher *tfm)
+{
+	return crypto_blkcipher_alg(tfm)-&gt;ivsize;
+}
+
+static inline unsigned int crypto_blkcipher_blocksize(
+	struct crypto_blkcipher *tfm)
+{
+	return crypto_tfm_alg_blocksize(crypto_blkcipher_tfm(tfm));
+}
+
+static inline unsigned int crypto_blkcipher_alignmask(
+	struct crypto_blkcipher *tfm)
+{
+	return crypto_tfm_alg_alignmask(crypto_blkcipher_tfm(tfm));
+}
+
+static inline u32 crypto_blkcipher_get_flags(struct crypto_blkcipher *tfm)
+{
+	return crypto_tfm_get_flags(crypto_blkcipher_tfm(tfm));
+}
+
+static inline void crypto_blkcipher_set_flags(struct crypto_blkcipher *tfm,
+					      u32 flags)
+{
+	crypto_tfm_set_flags(crypto_blkcipher_tfm(tfm), flags);
+}
+
+static inline void crypto_blkcipher_clear_flags(struct crypto_blkcipher *tfm,
+						u32 flags)
+{
+	crypto_tfm_clear_flags(crypto_blkcipher_tfm(tfm), flags);
+}
+
+static inline int crypto_blkcipher_setkey(struct crypto_blkcipher *tfm,
+					  const u8 *key, unsigned int keylen)
+{
+	return crypto_blkcipher_crt(tfm)-&gt;setkey(crypto_blkcipher_tfm(tfm),
+						 key, keylen);
+}
+
+static inline int crypto_blkcipher_encrypt(struct blkcipher_desc *desc,
+					   struct scatterlist *dst,
+					   struct scatterlist *src,
+					   unsigned int nbytes)
+{
+	desc-&gt;info = crypto_blkcipher_crt(desc-&gt;tfm)-&gt;iv;
+	return crypto_blkcipher_crt(desc-&gt;tfm)-&gt;encrypt(desc, dst, src, nbytes);
+}
+
+static inline int crypto_blkcipher_encrypt_iv(struct blkcipher_desc *desc,
+					      struct scatterlist *dst,
+					      struct scatterlist *src,
+					      unsigned int nbytes)
+{
+	return crypto_blkcipher_crt(desc-&gt;tfm)-&gt;encrypt(desc, dst, src, nbytes);
+}
+
+static inline int crypto_blkcipher_decrypt(struct blkcipher_desc *desc,
+					   struct scatterlist *dst,
+					   struct scatterlist *src,
+					   unsigned int nbytes)
+{
+	desc-&gt;info = crypto_blkcipher_crt(desc-&gt;tfm)-&gt;iv;
+	return crypto_blkcipher_crt(desc-&gt;tfm)-&gt;decrypt(desc, dst, src, nbytes);
+}
+
+static inline int crypto_blkcipher_decrypt_iv(struct blkcipher_desc *desc,
+					      struct scatterlist *dst,
+					      struct scatterlist *src,
+					      unsigned int nbytes)
+{
+	return crypto_blkcipher_crt(desc-&gt;tfm)-&gt;decrypt(desc, dst, src, nbytes);
+}
+
+static inline void crypto_blkcipher_set_iv(struct crypto_blkcipher *tfm,
+					   const u8 *src, unsigned int len)
+{
+	memcpy(crypto_blkcipher_crt(tfm)-&gt;iv, src, len);
+}
+
+static inline void crypto_blkcipher_get_iv(struct crypto_blkcipher *tfm,
+					   u8 *dst, unsigned int len)
+{
+	memcpy(dst, crypto_blkcipher_crt(tfm)-&gt;iv, len);
+}
+
 static inline struct crypto_cipher *__crypto_cipher_cast(struct crypto_tfm *tfm)
 {
 	return (struct crypto_cipher *)tfm;
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813122009</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:20:09-0400</timestampReceived><subject>[PATCH 5/16] [CRYPTO] cipher: Added block ciphers for CBC/ECB</subject><body>

[CRYPTO] cipher: Added block ciphers for CBC/ECB

This patch adds two block cipher algorithms, CBC and ECB.  These
are implemented as templates on top of existing single-block cipher
algorithms.  They invoke the single-block cipher through the new
encrypt_one/decrypt_one interface.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 crypto/Kconfig          |   17 ++
 crypto/Makefile         |    2 
 crypto/cbc.c            |  337 ++++++++++++++++++++++++++++++++++++++++++++++++
 crypto/ecb.c            |  181 +++++++++++++++++++++++++
 crypto/internal.h       |    1 
 include/crypto/algapi.h |    2 
 6 files changed, 539 insertions(+), 1 deletion(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -123,6 +123,23 @@ config CRYPTO_TGR192
 	  See also:
 	  &lt;http://www.cs.technion.ac.il/~biham/Reports/Tiger/&gt;.
 
+config CRYPTO_ECB
+	tristate "ECB support"
+	select CRYPTO_BLKCIPHER
+	default m
+	help
+	  ECB: Electronic CodeBook mode
+	  This is the simplest block cipher algorithm.  It simply encrypts
+	  the input block by block.
+
+config CRYPTO_CBC
+	tristate "CBC support"
+	select CRYPTO_BLKCIPHER
+	default m
+	help
+	  CBC: Cipher Block Chaining mode
+	  This block cipher algorithm is required for IPSec.
+
 config CRYPTO_DES
 	tristate "DES and Triple DES EDE cipher algorithms"
 	select CRYPTO_ALGAPI
diff --git a/crypto/Makefile b/crypto/Makefile
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -20,6 +20,8 @@ obj-$(CONFIG_CRYPTO_SHA256) += sha256.o
 obj-$(CONFIG_CRYPTO_SHA512) += sha512.o
 obj-$(CONFIG_CRYPTO_WP512) += wp512.o
 obj-$(CONFIG_CRYPTO_TGR192) += tgr192.o
+obj-$(CONFIG_CRYPTO_ECB) += ecb.o
+obj-$(CONFIG_CRYPTO_CBC) += cbc.o
 obj-$(CONFIG_CRYPTO_DES) += des.o
 obj-$(CONFIG_CRYPTO_BLOWFISH) += blowfish.o
 obj-$(CONFIG_CRYPTO_TWOFISH) += twofish.o
diff --git a/crypto/cbc.c b/crypto/cbc.c
new file mode 100644
--- /dev/null
+++ b/crypto/cbc.c
@@ -0,0 +1,337 @@
+/*
+ * CBC: Cipher Block Chaining mode
+ *
+ * Copyright (c) 2006 Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include &lt;crypto/algapi.h&gt;
+#include &lt;linux/err.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include &lt;linux/slab.h&gt;
+
+struct crypto_cbc_ctx {
+	struct crypto_cipher *child;
+	void (*xor)(u8 *dst, const u8 *src, unsigned int bs);
+};
+
+static int crypto_cbc_setkey(struct crypto_tfm *parent, const u8 *key,
+			     unsigned int keylen)
+{
+	struct crypto_cbc_ctx *ctx = crypto_tfm_ctx(parent);
+	struct crypto_cipher *child = ctx-&gt;child;
+	int err;
+
+	crypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
+	crypto_cipher_set_flags(child, crypto_tfm_get_flags(parent) &amp;
+				       CRYPTO_TFM_REQ_MASK);
+	err = crypto_cipher_setkey(child, key, keylen);
+	crypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &amp;
+				     CRYPTO_TFM_RES_MASK);
+	return err;
+}
+
+static int crypto_cbc_encrypt_segment(struct blkcipher_desc *desc,
+				      struct blkcipher_walk *walk,
+				      struct crypto_cipher *tfm,
+				      void (*xor)(u8 *, const u8 *,
+						  unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_encrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 *dst = walk-&gt;dst.virt.addr;
+	u8 *iv = walk-&gt;iv;
+
+	do {
+		xor(iv, src, bsize);
+		fn(crypto_cipher_tfm(tfm), dst, iv);
+		memcpy(iv, dst, bsize);
+
+		src += bsize;
+		dst += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	return nbytes;
+}
+
+static int crypto_cbc_encrypt_inplace(struct blkcipher_desc *desc,
+				      struct blkcipher_walk *walk,
+				      struct crypto_cipher *tfm,
+				      void (*xor)(u8 *, const u8 *,
+						  unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_encrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 *iv = walk-&gt;iv;
+
+	do {
+		xor(src, iv, bsize);
+		fn(crypto_cipher_tfm(tfm), src, src);
+		iv = src;
+
+		src += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	memcpy(walk-&gt;iv, iv, bsize);
+
+	return nbytes;
+}
+
+static int crypto_cbc_encrypt(struct blkcipher_desc *desc,
+			      struct scatterlist *dst, struct scatterlist *src,
+			      unsigned int nbytes)
+{
+	struct blkcipher_walk walk;
+	struct crypto_blkcipher *tfm = desc-&gt;tfm;
+	struct crypto_cbc_ctx *ctx = crypto_blkcipher_ctx(tfm);
+	struct crypto_cipher *child = ctx-&gt;child;
+	void (*xor)(u8 *, const u8 *, unsigned int bs) = ctx-&gt;xor;
+	int err;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while ((nbytes = walk.nbytes)) {
+		if (walk.src.virt.addr == walk.dst.virt.addr)
+			nbytes = crypto_cbc_encrypt_inplace(desc, &amp;walk, child,
+							    xor);
+		else
+			nbytes = crypto_cbc_encrypt_segment(desc, &amp;walk, child,
+							    xor);
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static int crypto_cbc_decrypt_segment(struct blkcipher_desc *desc,
+				      struct blkcipher_walk *walk,
+				      struct crypto_cipher *tfm,
+				      void (*xor)(u8 *, const u8 *,
+						  unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_decrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 *dst = walk-&gt;dst.virt.addr;
+	u8 *iv = walk-&gt;iv;
+
+	do {
+		fn(crypto_cipher_tfm(tfm), dst, src);
+		xor(dst, iv, bsize);
+		iv = src;
+
+		src += bsize;
+		dst += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	memcpy(walk-&gt;iv, iv, bsize);
+
+	return nbytes;
+}
+
+static int crypto_cbc_decrypt_inplace(struct blkcipher_desc *desc,
+				      struct blkcipher_walk *walk,
+				      struct crypto_cipher *tfm,
+				      void (*xor)(u8 *, const u8 *,
+						  unsigned int))
+{
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) =
+		crypto_cipher_alg(tfm)-&gt;cia_decrypt;
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned long alignmask = crypto_cipher_alignmask(tfm);
+	unsigned int nbytes = walk-&gt;nbytes;
+	u8 *src = walk-&gt;src.virt.addr;
+	u8 stack[bsize + alignmask];
+	u8 *tmp = (u8 *)ALIGN((unsigned long)stack, alignmask + 1);
+
+	do {
+		fn(crypto_cipher_tfm(tfm), tmp, src);
+		xor(tmp, walk-&gt;iv, bsize);
+		memcpy(walk-&gt;iv, src, bsize);
+		memcpy(src, tmp, bsize);
+
+		src += bsize;
+	} while ((nbytes -= bsize) &gt;= bsize);
+
+	return nbytes;
+}
+
+static int crypto_cbc_decrypt(struct blkcipher_desc *desc,
+			      struct scatterlist *dst, struct scatterlist *src,
+			      unsigned int nbytes)
+{
+	struct blkcipher_walk walk;
+	struct crypto_blkcipher *tfm = desc-&gt;tfm;
+	struct crypto_cbc_ctx *ctx = crypto_blkcipher_ctx(tfm);
+	struct crypto_cipher *child = ctx-&gt;child;
+	void (*xor)(u8 *, const u8 *, unsigned int bs) = ctx-&gt;xor;
+	int err;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while ((nbytes = walk.nbytes)) {
+		if (walk.src.virt.addr == walk.dst.virt.addr)
+			nbytes = crypto_cbc_decrypt_inplace(desc, &amp;walk, child,
+							    xor);
+		else
+			nbytes = crypto_cbc_decrypt_segment(desc, &amp;walk, child,
+							    xor);
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static void xor_byte(u8 *a, const u8 *b, unsigned int bs)
+{
+	do {
+		*a++ ^= *b++;
+	} while (--bs);
+}
+
+static void xor_quad(u8 *dst, const u8 *src, unsigned int bs)
+{
+	u32 *a = (u32 *)dst;
+	u32 *b = (u32 *)src;
+
+	do {
+		*a++ ^= *b++;
+	} while ((bs -= 4));
+}
+
+static void xor_64(u8 *a, const u8 *b, unsigned int bs)
+{
+	((u32 *)a)[0] ^= ((u32 *)b)[0];
+	((u32 *)a)[1] ^= ((u32 *)b)[1];
+}
+
+static void xor_128(u8 *a, const u8 *b, unsigned int bs)
+{
+	((u32 *)a)[0] ^= ((u32 *)b)[0];
+	((u32 *)a)[1] ^= ((u32 *)b)[1];
+	((u32 *)a)[2] ^= ((u32 *)b)[2];
+	((u32 *)a)[3] ^= ((u32 *)b)[3];
+}
+
+static int crypto_cbc_init_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_instance *inst = (void *)tfm-&gt;__crt_alg;
+	struct crypto_spawn *spawn = crypto_instance_ctx(inst);
+	struct crypto_cbc_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	switch (crypto_tfm_alg_blocksize(tfm)) {
+	case 8:
+		ctx-&gt;xor = xor_64;
+		break;
+
+	case 16:
+		ctx-&gt;xor = xor_128;
+		break;
+
+	default:
+		if (crypto_tfm_alg_blocksize(tfm) % 4)
+			ctx-&gt;xor = xor_byte;
+		else
+			ctx-&gt;xor = xor_quad;
+	}
+
+	tfm = crypto_spawn_tfm(spawn);
+	if (IS_ERR(tfm))
+		return PTR_ERR(tfm);
+
+	ctx-&gt;child = crypto_cipher_cast(tfm);
+	return 0;
+}
+
+static void crypto_cbc_exit_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_cbc_ctx *ctx = crypto_tfm_ctx(tfm);
+	crypto_free_cipher(ctx-&gt;child);
+}
+
+static struct crypto_instance *crypto_cbc_alloc(void *param, unsigned int len)
+{
+	struct crypto_instance *inst;
+	struct crypto_alg *alg;
+
+	alg = crypto_get_attr_alg(param, len, CRYPTO_ALG_TYPE_CIPHER,
+				  CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_ASYNC);
+	if (IS_ERR(alg))
+		return ERR_PTR(PTR_ERR(alg));
+
+	inst = crypto_alloc_instance("cbc", alg);
+	if (IS_ERR(inst))
+		goto out_put_alg;
+
+	inst-&gt;alg.cra_flags = CRYPTO_ALG_TYPE_BLKCIPHER;
+	inst-&gt;alg.cra_priority = alg-&gt;cra_priority;
+	inst-&gt;alg.cra_blocksize = alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_alignmask = alg-&gt;cra_alignmask;
+	inst-&gt;alg.cra_type = &amp;crypto_blkcipher_type;
+
+	if (!(alg-&gt;cra_blocksize % 4))
+		inst-&gt;alg.cra_alignmask |= 3;
+	inst-&gt;alg.cra_blkcipher.ivsize = alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_blkcipher.min_keysize = alg-&gt;cra_cipher.cia_min_keysize;
+	inst-&gt;alg.cra_blkcipher.max_keysize = alg-&gt;cra_cipher.cia_max_keysize;
+
+	inst-&gt;alg.cra_ctxsize = sizeof(struct crypto_cbc_ctx);
+
+	inst-&gt;alg.cra_init = crypto_cbc_init_tfm;
+	inst-&gt;alg.cra_exit = crypto_cbc_exit_tfm;
+
+	inst-&gt;alg.cra_blkcipher.setkey = crypto_cbc_setkey;
+	inst-&gt;alg.cra_blkcipher.encrypt = crypto_cbc_encrypt;
+	inst-&gt;alg.cra_blkcipher.decrypt = crypto_cbc_decrypt;
+
+out_put_alg:
+	crypto_mod_put(alg);
+	return inst;
+}
+
+static void crypto_cbc_free(struct crypto_instance *inst)
+{
+	crypto_drop_spawn(crypto_instance_ctx(inst));
+	kfree(inst);
+}
+
+static struct crypto_template crypto_cbc_tmpl = {
+	.name = "cbc",
+	.alloc = crypto_cbc_alloc,
+	.free = crypto_cbc_free,
+	.module = THIS_MODULE,
+};
+
+static int __init crypto_cbc_module_init(void)
+{
+	return crypto_register_template(&amp;crypto_cbc_tmpl);
+}
+
+static void __exit crypto_cbc_module_exit(void)
+{
+	crypto_unregister_template(&amp;crypto_cbc_tmpl);
+}
+
+module_init(crypto_cbc_module_init);
+module_exit(crypto_cbc_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("CBC block cipher algorithm");
diff --git a/crypto/ecb.c b/crypto/ecb.c
new file mode 100644
--- /dev/null
+++ b/crypto/ecb.c
@@ -0,0 +1,181 @@
+/*
+ * ECB: Electronic CodeBook mode
+ *
+ * Copyright (c) 2006 Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include &lt;crypto/algapi.h&gt;
+#include &lt;linux/err.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include &lt;linux/slab.h&gt;
+
+struct crypto_ecb_ctx {
+	struct crypto_cipher *child;
+};
+
+static int crypto_ecb_setkey(struct crypto_tfm *parent, const u8 *key,
+			     unsigned int keylen)
+{
+	struct crypto_ecb_ctx *ctx = crypto_tfm_ctx(parent);
+	struct crypto_cipher *child = ctx-&gt;child;
+	int err;
+
+	crypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
+	crypto_cipher_set_flags(child, crypto_tfm_get_flags(parent) &amp;
+				       CRYPTO_TFM_REQ_MASK);
+	err = crypto_cipher_setkey(child, key, keylen);
+	crypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &amp;
+				     CRYPTO_TFM_RES_MASK);
+	return err;
+}
+
+static int crypto_ecb_crypt(struct blkcipher_desc *desc,
+			    struct blkcipher_walk *walk,
+			    struct crypto_cipher *tfm,
+			    void (*fn)(struct crypto_tfm *, u8 *, const u8 *))
+{
+	int bsize = crypto_cipher_blocksize(tfm);
+	unsigned int nbytes;
+	int err;
+
+	err = blkcipher_walk_virt(desc, walk);
+
+	while ((nbytes = walk-&gt;nbytes)) {
+		u8 *wsrc = walk-&gt;src.virt.addr;
+		u8 *wdst = walk-&gt;dst.virt.addr;
+
+		do {
+			fn(crypto_cipher_tfm(tfm), wdst, wsrc);
+	
+			wsrc += bsize;
+			wdst += bsize;
+		} while ((nbytes -= bsize) &gt;= bsize);
+
+		err = blkcipher_walk_done(desc, walk, nbytes);
+	}
+
+	return err;
+}
+
+static int crypto_ecb_encrypt(struct blkcipher_desc *desc,
+			      struct scatterlist *dst, struct scatterlist *src,
+			      unsigned int nbytes)
+{
+	struct blkcipher_walk walk;
+	struct crypto_blkcipher *tfm = desc-&gt;tfm;
+	struct crypto_ecb_ctx *ctx = crypto_blkcipher_ctx(tfm);
+	struct crypto_cipher *child = ctx-&gt;child;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return crypto_ecb_crypt(desc, &amp;walk, child,
+				crypto_cipher_alg(child)-&gt;cia_encrypt);
+}
+
+static int crypto_ecb_decrypt(struct blkcipher_desc *desc,
+			      struct scatterlist *dst, struct scatterlist *src,
+			      unsigned int nbytes)
+{
+	struct blkcipher_walk walk;
+	struct crypto_blkcipher *tfm = desc-&gt;tfm;
+	struct crypto_ecb_ctx *ctx = crypto_blkcipher_ctx(tfm);
+	struct crypto_cipher *child = ctx-&gt;child;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return crypto_ecb_crypt(desc, &amp;walk, child,
+				crypto_cipher_alg(child)-&gt;cia_decrypt);
+}
+
+static int crypto_ecb_init_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_instance *inst = (void *)tfm-&gt;__crt_alg;
+	struct crypto_spawn *spawn = crypto_instance_ctx(inst);
+	struct crypto_ecb_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	tfm = crypto_spawn_tfm(spawn);
+	if (IS_ERR(tfm))
+		return PTR_ERR(tfm);
+
+	ctx-&gt;child = crypto_cipher_cast(tfm);
+	return 0;
+}
+
+static void crypto_ecb_exit_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_ecb_ctx *ctx = crypto_tfm_ctx(tfm);
+	crypto_free_cipher(ctx-&gt;child);
+}
+
+static struct crypto_instance *crypto_ecb_alloc(void *param, unsigned int len)
+{
+	struct crypto_instance *inst;
+	struct crypto_alg *alg;
+
+	alg = crypto_get_attr_alg(param, len, CRYPTO_ALG_TYPE_CIPHER,
+				  CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_ASYNC);
+	if (IS_ERR(alg))
+		return ERR_PTR(PTR_ERR(alg));
+
+	inst = crypto_alloc_instance("ecb", alg);
+	if (IS_ERR(inst))
+		goto out_put_alg;
+
+	inst-&gt;alg.cra_flags = CRYPTO_ALG_TYPE_BLKCIPHER;
+	inst-&gt;alg.cra_priority = alg-&gt;cra_priority;
+	inst-&gt;alg.cra_blocksize = alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_alignmask = alg-&gt;cra_alignmask;
+	inst-&gt;alg.cra_type = &amp;crypto_blkcipher_type;
+
+	inst-&gt;alg.cra_blkcipher.min_keysize = alg-&gt;cra_cipher.cia_min_keysize;
+	inst-&gt;alg.cra_blkcipher.max_keysize = alg-&gt;cra_cipher.cia_max_keysize;
+
+	inst-&gt;alg.cra_ctxsize = sizeof(struct crypto_ecb_ctx);
+
+	inst-&gt;alg.cra_init = crypto_ecb_init_tfm;
+	inst-&gt;alg.cra_exit = crypto_ecb_exit_tfm;
+
+	inst-&gt;alg.cra_blkcipher.setkey = crypto_ecb_setkey;
+	inst-&gt;alg.cra_blkcipher.encrypt = crypto_ecb_encrypt;
+	inst-&gt;alg.cra_blkcipher.decrypt = crypto_ecb_decrypt;
+
+out_put_alg:
+	crypto_mod_put(alg);
+	return inst;
+}
+
+static void crypto_ecb_free(struct crypto_instance *inst)
+{
+	crypto_drop_spawn(crypto_instance_ctx(inst));
+	kfree(inst);
+}
+
+static struct crypto_template crypto_ecb_tmpl = {
+	.name = "ecb",
+	.alloc = crypto_ecb_alloc,
+	.free = crypto_ecb_free,
+	.module = THIS_MODULE,
+};
+
+static int __init crypto_ecb_module_init(void)
+{
+	return crypto_register_template(&amp;crypto_ecb_tmpl);
+}
+
+static void __exit crypto_ecb_module_exit(void)
+{
+	crypto_unregister_template(&amp;crypto_ecb_tmpl);
+}
+
+module_init(crypto_ecb_module_init);
+module_exit(crypto_ecb_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("ECB block cipher algorithm");
diff --git a/crypto/internal.h b/crypto/internal.h
--- a/crypto/internal.h
+++ b/crypto/internal.h
@@ -131,7 +131,6 @@ static inline unsigned int crypto_compre
 }
 
 struct crypto_alg *crypto_mod_get(struct crypto_alg *alg);
-void crypto_mod_put(struct crypto_alg *alg);
 struct crypto_alg *__crypto_alg_lookup(const char *name, u32 type, u32 mask);
 struct crypto_alg *crypto_alg_mod_lookup(const char *name, u32 type, u32 mask);
 
diff --git a/include/crypto/algapi.h b/include/crypto/algapi.h
--- a/include/crypto/algapi.h
+++ b/include/crypto/algapi.h
@@ -81,6 +81,8 @@ struct blkcipher_walk {
 
 extern const struct crypto_type crypto_blkcipher_type;
 
+void crypto_mod_put(struct crypto_alg *alg);
+
 int crypto_register_template(struct crypto_template *tmpl);
 void crypto_unregister_template(struct crypto_template *tmpl);
 struct crypto_template *crypto_lookup_template(const char *name);
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813122011</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:20:11-0400</timestampReceived><subject>[PATCH 6/16] [CRYPTO] padlock: Added block cipher versions of CBC/ECB</subject><body>

[CRYPTO] padlock: Added block cipher versions of CBC/ECB

This patch adds block cipher algorithms for cbc(aes) and ecb(aes) for
the PadLock device.  Once all users to the old cipher type have been
converted the old cbc/ecb PadLock operations will be removed.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 drivers/crypto/padlock-aes.c |  174 +++++++++++++++++++++++++++++++++++++++++--
 drivers/crypto/padlock.h     |    1 
 2 files changed, 168 insertions(+), 7 deletions(-)

diff --git a/drivers/crypto/padlock-aes.c b/drivers/crypto/padlock-aes.c
--- a/drivers/crypto/padlock-aes.c
+++ b/drivers/crypto/padlock-aes.c
@@ -43,11 +43,11 @@
  * ---------------------------------------------------------------------------
  */
 
+#include &lt;crypto/algapi.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/types.h&gt;
 #include &lt;linux/errno.h&gt;
-#include &lt;linux/crypto.h&gt;
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;asm/byteorder.h&gt;
@@ -297,9 +297,9 @@ aes_hw_extkey_available(uint8_t key_len)
 	return 0;
 }
 
-static inline struct aes_ctx *aes_ctx(struct crypto_tfm *tfm)
+static inline struct aes_ctx *aes_ctx_common(void *ctx)
 {
-	unsigned long addr = (unsigned long)crypto_tfm_ctx(tfm);
+	unsigned long addr = (unsigned long)ctx;
 	unsigned long align = PADLOCK_ALIGNMENT;
 
 	if (align &lt;= crypto_tfm_ctx_alignment())
@@ -307,6 +307,16 @@ static inline struct aes_ctx *aes_ctx(st
 	return (struct aes_ctx *)ALIGN(addr, align);
 }
 
+static inline struct aes_ctx *aes_ctx(struct crypto_tfm *tfm)
+{
+	return aes_ctx_common(crypto_tfm_ctx(tfm));
+}
+
+static inline struct aes_ctx *blk_aes_ctx(struct crypto_blkcipher *tfm)
+{
+	return aes_ctx_common(crypto_blkcipher_ctx(tfm));
+}
+
 static int aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,
 		       unsigned int key_len)
 {
@@ -507,6 +517,141 @@ static struct crypto_alg aes_alg = {
 	}
 };
 
+static int ecb_aes_encrypt(struct blkcipher_desc *desc,
+			   struct scatterlist *dst, struct scatterlist *src,
+			   unsigned int nbytes)
+{
+	struct aes_ctx *ctx = blk_aes_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while ((nbytes = walk.nbytes)) {
+		padlock_xcrypt_ecb(walk.src.virt.addr, walk.dst.virt.addr,
+				   ctx-&gt;E, &amp;ctx-&gt;cword.encrypt,
+				   nbytes / AES_BLOCK_SIZE);
+		nbytes &amp;= AES_BLOCK_SIZE - 1;
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static int ecb_aes_decrypt(struct blkcipher_desc *desc,
+			   struct scatterlist *dst, struct scatterlist *src,
+			   unsigned int nbytes)
+{
+	struct aes_ctx *ctx = blk_aes_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while ((nbytes = walk.nbytes)) {
+		padlock_xcrypt_ecb(walk.src.virt.addr, walk.dst.virt.addr,
+				   ctx-&gt;D, &amp;ctx-&gt;cword.decrypt,
+				   nbytes / AES_BLOCK_SIZE);
+		nbytes &amp;= AES_BLOCK_SIZE - 1;
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static struct crypto_alg ecb_aes_alg = {
+	.cra_name		=	"ecb(aes)",
+	.cra_driver_name	=	"ecb-aes-padlock",
+	.cra_priority		=	PADLOCK_COMPOSITE_PRIORITY,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	AES_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct aes_ctx),
+	.cra_alignmask		=	PADLOCK_ALIGNMENT - 1,
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(ecb_aes_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	AES_MIN_KEY_SIZE,
+			.max_keysize		=	AES_MAX_KEY_SIZE,
+			.setkey	   		= 	aes_set_key,
+			.encrypt		=	ecb_aes_encrypt,
+			.decrypt		=	ecb_aes_decrypt,
+		}
+	}
+};
+
+static int cbc_aes_encrypt(struct blkcipher_desc *desc,
+			   struct scatterlist *dst, struct scatterlist *src,
+			   unsigned int nbytes)
+{
+	struct aes_ctx *ctx = blk_aes_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while ((nbytes = walk.nbytes)) {
+		u8 *iv = padlock_xcrypt_cbc(walk.src.virt.addr,
+					    walk.dst.virt.addr, ctx-&gt;E,
+					    walk.iv, &amp;ctx-&gt;cword.encrypt,
+					    nbytes / AES_BLOCK_SIZE);
+		memcpy(walk.iv, iv, AES_BLOCK_SIZE);
+		nbytes &amp;= AES_BLOCK_SIZE - 1;
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static int cbc_aes_decrypt(struct blkcipher_desc *desc,
+			   struct scatterlist *dst, struct scatterlist *src,
+			   unsigned int nbytes)
+{
+	struct aes_ctx *ctx = blk_aes_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while ((nbytes = walk.nbytes)) {
+		padlock_xcrypt_cbc(walk.src.virt.addr, walk.dst.virt.addr,
+				   ctx-&gt;D, walk.iv, &amp;ctx-&gt;cword.decrypt,
+				   nbytes / AES_BLOCK_SIZE);
+		nbytes &amp;= AES_BLOCK_SIZE - 1;
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static struct crypto_alg cbc_aes_alg = {
+	.cra_name		=	"cbc(aes)",
+	.cra_driver_name	=	"cbc-aes-padlock",
+	.cra_priority		=	PADLOCK_COMPOSITE_PRIORITY,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	AES_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct aes_ctx),
+	.cra_alignmask		=	PADLOCK_ALIGNMENT - 1,
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(cbc_aes_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	AES_MIN_KEY_SIZE,
+			.max_keysize		=	AES_MAX_KEY_SIZE,
+			.ivsize			=	AES_BLOCK_SIZE,
+			.setkey	   		= 	aes_set_key,
+			.encrypt		=	cbc_aes_encrypt,
+			.decrypt		=	cbc_aes_decrypt,
+		}
+	}
+};
+
 static int __init padlock_init(void)
 {
 	int ret;
@@ -522,18 +667,33 @@ static int __init padlock_init(void)
 	}
 
 	gen_tabs();
-	if ((ret = crypto_register_alg(&amp;aes_alg))) {
-		printk(KERN_ERR PFX "VIA PadLock AES initialization failed.\n");
-		return ret;
-	}
+	if ((ret = crypto_register_alg(&amp;aes_alg)))
+		goto aes_err;
+
+	if ((ret = crypto_register_alg(&amp;ecb_aes_alg)))
+		goto ecb_aes_err;
+
+	if ((ret = crypto_register_alg(&amp;cbc_aes_alg)))
+		goto cbc_aes_err;
 
 	printk(KERN_NOTICE PFX "Using VIA PadLock ACE for AES algorithm.\n");
 
+out:
 	return ret;
+
+cbc_aes_err:
+	crypto_unregister_alg(&amp;ecb_aes_alg);
+ecb_aes_err:
+	crypto_unregister_alg(&amp;aes_alg);
+aes_err:
+	printk(KERN_ERR PFX "VIA PadLock AES initialization failed.\n");
+	goto out;
 }
 
 static void __exit padlock_fini(void)
 {
+	crypto_unregister_alg(&amp;cbc_aes_alg);
+	crypto_unregister_alg(&amp;ecb_aes_alg);
 	crypto_unregister_alg(&amp;aes_alg);
 }
 
diff --git a/drivers/crypto/padlock.h b/drivers/crypto/padlock.h
--- a/drivers/crypto/padlock.h
+++ b/drivers/crypto/padlock.h
@@ -18,5 +18,6 @@
 #define PFX	"padlock: "
 
 #define PADLOCK_CRA_PRIORITY	300
+#define PADLOCK_COMPOSITE_PRIORITY 400
 
 #endif	/* _CRYPTO_PADLOCK_H */
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813122012</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:20:12-0400</timestampReceived><subject>[PATCH 7/16] [CRYPTO] s390: Added block cipher versions of CBC/ECB</subject><body>

[CRYPTO] s390: Added block cipher versions of CBC/ECB

This patch adds block cipher algorithms for S390.  Once all users of the
old cipher type have been converted the existing CBC/ECB non-block cipher
operations will be removed.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 arch/s390/crypto/aes_s390.c   |  218 +++++++++++++++++++++++
 arch/s390/crypto/crypt_s390.h |    1 
 arch/s390/crypto/des_s390.c   |  385 ++++++++++++++++++++++++++++++++++++++++--
 3 files changed, 590 insertions(+), 14 deletions(-)

diff --git a/arch/s390/crypto/aes_s390.c b/arch/s390/crypto/aes_s390.c
--- a/arch/s390/crypto/aes_s390.c
+++ b/arch/s390/crypto/aes_s390.c
@@ -16,9 +16,9 @@
  *
  */
 
+#include &lt;crypto/algapi.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/init.h&gt;
-#include &lt;linux/crypto.h&gt;
 #include "crypt_s390.h"
 
 #define AES_MIN_KEY_SIZE	16
@@ -34,6 +34,8 @@ int has_aes_256 = 0;
 struct s390_aes_ctx {
 	u8 iv[AES_BLOCK_SIZE];
 	u8 key[AES_MAX_KEY_SIZE];
+	long enc;
+	long dec;
 	int key_len;
 };
 
@@ -244,6 +246,189 @@ static struct crypto_alg aes_alg = {
 	}
 };
 
+static int ecb_aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,
+			   unsigned int key_len)
+{
+	struct s390_aes_ctx *sctx = crypto_tfm_ctx(tfm);
+
+	switch (key_len) {
+	case 16:
+		sctx-&gt;enc = KM_AES_128_ENCRYPT;
+		sctx-&gt;dec = KM_AES_128_DECRYPT;
+		break;
+	case 24:
+		sctx-&gt;enc = KM_AES_192_ENCRYPT;
+		sctx-&gt;dec = KM_AES_192_DECRYPT;
+		break;
+	case 32:
+		sctx-&gt;enc = KM_AES_256_ENCRYPT;
+		sctx-&gt;dec = KM_AES_256_DECRYPT;
+		break;
+	}
+
+	return aes_set_key(tfm, in_key, key_len);
+}
+
+static int ecb_aes_crypt(struct blkcipher_desc *desc, long func, void *param,
+			 struct blkcipher_walk *walk)
+{
+	int ret = blkcipher_walk_virt(desc, walk);
+	unsigned int nbytes;
+
+	while ((nbytes = walk-&gt;nbytes)) {
+		/* only use complete blocks */
+		unsigned int n = nbytes &amp; ~(AES_BLOCK_SIZE - 1);
+		u8 *out = walk-&gt;dst.virt.addr;
+		u8 *in = walk-&gt;src.virt.addr;
+
+		ret = crypt_s390_km(func, param, out, in, n);
+		BUG_ON((ret &lt; 0) || (ret != n));
+
+		nbytes &amp;= AES_BLOCK_SIZE - 1;
+		ret = blkcipher_walk_done(desc, walk, nbytes);
+	}
+
+	return ret;
+}
+
+static int ecb_aes_encrypt(struct blkcipher_desc *desc,
+			   struct scatterlist *dst, struct scatterlist *src,
+			   unsigned int nbytes)
+{
+	struct s390_aes_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return ecb_aes_crypt(desc, sctx-&gt;enc, sctx-&gt;key, &amp;walk);
+}
+
+static int ecb_aes_decrypt(struct blkcipher_desc *desc,
+			   struct scatterlist *dst, struct scatterlist *src,
+			   unsigned int nbytes)
+{
+	struct s390_aes_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return ecb_aes_crypt(desc, sctx-&gt;dec, sctx-&gt;key, &amp;walk);
+}
+
+static struct crypto_alg ecb_aes_alg = {
+	.cra_name		=	"ecb(aes)",
+	.cra_driver_name	=	"ecb-aes-s390",
+	.cra_priority		=	CRYPT_S390_COMPOSITE_PRIORITY,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	AES_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct s390_aes_ctx),
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(ecb_aes_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	AES_MIN_KEY_SIZE,
+			.max_keysize		=	AES_MAX_KEY_SIZE,
+			.setkey			=	ecb_aes_set_key,
+			.encrypt		=	ecb_aes_encrypt,
+			.decrypt		=	ecb_aes_decrypt,
+		}
+	}
+};
+
+static int cbc_aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,
+			   unsigned int key_len)
+{
+	struct s390_aes_ctx *sctx = crypto_tfm_ctx(tfm);
+
+	switch (key_len) {
+	case 16:
+		sctx-&gt;enc = KMC_AES_128_ENCRYPT;
+		sctx-&gt;dec = KMC_AES_128_DECRYPT;
+		break;
+	case 24:
+		sctx-&gt;enc = KMC_AES_192_ENCRYPT;
+		sctx-&gt;dec = KMC_AES_192_DECRYPT;
+		break;
+	case 32:
+		sctx-&gt;enc = KMC_AES_256_ENCRYPT;
+		sctx-&gt;dec = KMC_AES_256_DECRYPT;
+		break;
+	}
+
+	return aes_set_key(tfm, in_key, key_len);
+}
+
+static int cbc_aes_crypt(struct blkcipher_desc *desc, long func, void *param,
+			 struct blkcipher_walk *walk)
+{
+	int ret = blkcipher_walk_virt(desc, walk);
+	unsigned int nbytes = walk-&gt;nbytes;
+
+	if (!nbytes)
+		goto out;
+
+	memcpy(param, walk-&gt;iv, AES_BLOCK_SIZE);
+	do {
+		/* only use complete blocks */
+		unsigned int n = nbytes &amp; ~(AES_BLOCK_SIZE - 1);
+		u8 *out = walk-&gt;dst.virt.addr;
+		u8 *in = walk-&gt;src.virt.addr;
+
+		ret = crypt_s390_kmc(func, param, out, in, n);
+		BUG_ON((ret &lt; 0) || (ret != n));
+
+		nbytes &amp;= AES_BLOCK_SIZE - 1;
+		ret = blkcipher_walk_done(desc, walk, nbytes);
+	} while ((nbytes = walk-&gt;nbytes));
+	memcpy(walk-&gt;iv, param, AES_BLOCK_SIZE);
+
+out:
+	return ret;
+}
+
+static int cbc_aes_encrypt(struct blkcipher_desc *desc,
+			   struct scatterlist *dst, struct scatterlist *src,
+			   unsigned int nbytes)
+{
+	struct s390_aes_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return cbc_aes_crypt(desc, sctx-&gt;enc, sctx-&gt;iv, &amp;walk);
+}
+
+static int cbc_aes_decrypt(struct blkcipher_desc *desc,
+			   struct scatterlist *dst, struct scatterlist *src,
+			   unsigned int nbytes)
+{
+	struct s390_aes_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return cbc_aes_crypt(desc, sctx-&gt;dec, sctx-&gt;iv, &amp;walk);
+}
+
+static struct crypto_alg cbc_aes_alg = {
+	.cra_name		=	"cbc(aes)",
+	.cra_driver_name	=	"cbc-aes-s390",
+	.cra_priority		=	CRYPT_S390_COMPOSITE_PRIORITY,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	AES_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct s390_aes_ctx),
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(cbc_aes_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	AES_MIN_KEY_SIZE,
+			.max_keysize		=	AES_MAX_KEY_SIZE,
+			.ivsize			=	AES_BLOCK_SIZE,
+			.setkey			=	cbc_aes_set_key,
+			.encrypt		=	cbc_aes_encrypt,
+			.decrypt		=	cbc_aes_decrypt,
+		}
+	}
+};
+
 static int __init aes_init(void)
 {
 	int ret;
@@ -259,13 +444,40 @@ static int __init aes_init(void)
 		return -ENOSYS;
 
 	ret = crypto_register_alg(&amp;aes_alg);
-	if (ret != 0)
-		printk(KERN_INFO "crypt_s390: aes_s390 couldn't be loaded.\n");
+	if (ret != 0) {
+		printk(KERN_INFO "crypt_s390: aes-s390 couldn't be loaded.\n");
+		goto aes_err;
+	}
+
+	ret = crypto_register_alg(&amp;ecb_aes_alg);
+	if (ret != 0) {
+		printk(KERN_INFO
+		       "crypt_s390: ecb-aes-s390 couldn't be loaded.\n");
+		goto ecb_aes_err;
+	}
+
+	ret = crypto_register_alg(&amp;cbc_aes_alg);
+	if (ret != 0) {
+		printk(KERN_INFO
+		       "crypt_s390: cbc-aes-s390 couldn't be loaded.\n");
+		goto cbc_aes_err;
+	}
+
+out:
 	return ret;
+
+cbc_aes_err:
+	crypto_unregister_alg(&amp;ecb_aes_alg);
+ecb_aes_err:
+	crypto_unregister_alg(&amp;aes_alg);
+aes_err:
+	goto out;
 }
 
 static void __exit aes_fini(void)
 {
+	crypto_unregister_alg(&amp;cbc_aes_alg);
+	crypto_unregister_alg(&amp;ecb_aes_alg);
 	crypto_unregister_alg(&amp;aes_alg);
 }
 
diff --git a/arch/s390/crypto/crypt_s390.h b/arch/s390/crypto/crypt_s390.h
--- a/arch/s390/crypto/crypt_s390.h
+++ b/arch/s390/crypto/crypt_s390.h
@@ -21,6 +21,7 @@
 #define CRYPT_S390_FUNC_MASK 0x00FF
 
 #define CRYPT_S390_PRIORITY 300
+#define CRYPT_S390_COMPOSITE_PRIORITY 400
 
 /* s930 cryptographic operations */
 enum crypt_s390_operations {
diff --git a/arch/s390/crypto/des_s390.c b/arch/s390/crypto/des_s390.c
--- a/arch/s390/crypto/des_s390.c
+++ b/arch/s390/crypto/des_s390.c
@@ -13,9 +13,10 @@
  * (at your option) any later version.
  *
  */
+
+#include &lt;crypto/algapi.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/module.h&gt;
-#include &lt;linux/crypto.h&gt;
 
 #include "crypt_s390.h"
 #include "crypto_des.h"
@@ -157,6 +158,143 @@ static struct crypto_alg des_alg = {
 	}
 };
 
+static int ecb_desall_crypt(struct blkcipher_desc *desc, long func,
+			    void *param, struct blkcipher_walk *walk)
+{
+	int ret = blkcipher_walk_virt(desc, walk);
+	unsigned int nbytes;
+
+	while ((nbytes = walk-&gt;nbytes)) {
+		/* only use complete blocks */
+		unsigned int n = nbytes &amp; ~(DES_BLOCK_SIZE - 1);
+		u8 *out = walk-&gt;dst.virt.addr;
+		u8 *in = walk-&gt;src.virt.addr;
+
+		ret = crypt_s390_km(func, param, out, in, n);
+		BUG_ON((ret &lt; 0) || (ret != n));
+
+		nbytes &amp;= DES_BLOCK_SIZE - 1;
+		ret = blkcipher_walk_done(desc, walk, nbytes);
+	}
+
+	return ret;
+}
+
+static int cbc_desall_crypt(struct blkcipher_desc *desc, long func,
+			    void *param, struct blkcipher_walk *walk)
+{
+	int ret = blkcipher_walk_virt(desc, walk);
+	unsigned int nbytes = walk-&gt;nbytes;
+
+	if (!nbytes)
+		goto out;
+
+	memcpy(param, walk-&gt;iv, DES_BLOCK_SIZE);
+	do {
+		/* only use complete blocks */
+		unsigned int n = nbytes &amp; ~(DES_BLOCK_SIZE - 1);
+		u8 *out = walk-&gt;dst.virt.addr;
+		u8 *in = walk-&gt;src.virt.addr;
+
+		ret = crypt_s390_kmc(func, param, out, in, n);
+		BUG_ON((ret &lt; 0) || (ret != n));
+
+		nbytes &amp;= DES_BLOCK_SIZE - 1;
+		ret = blkcipher_walk_done(desc, walk, nbytes);
+	} while ((nbytes = walk-&gt;nbytes));
+	memcpy(walk-&gt;iv, param, DES_BLOCK_SIZE);
+
+out:
+	return ret;
+}
+
+static int ecb_des_encrypt(struct blkcipher_desc *desc,
+			   struct scatterlist *dst, struct scatterlist *src,
+			   unsigned int nbytes)
+{
+	struct crypt_s390_des_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return ecb_desall_crypt(desc, KM_DEA_ENCRYPT, sctx-&gt;key, &amp;walk);
+}
+
+static int ecb_des_decrypt(struct blkcipher_desc *desc,
+			   struct scatterlist *dst, struct scatterlist *src,
+			   unsigned int nbytes)
+{
+	struct crypt_s390_des_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return ecb_desall_crypt(desc, KM_DEA_DECRYPT, sctx-&gt;key, &amp;walk);
+}
+
+static struct crypto_alg ecb_des_alg = {
+	.cra_name		=	"ecb(des)",
+	.cra_driver_name	=	"ecb-des-s390",
+	.cra_priority		=	CRYPT_S390_COMPOSITE_PRIORITY,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	DES_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct crypt_s390_des_ctx),
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(ecb_des_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	DES_KEY_SIZE,
+			.max_keysize		=	DES_KEY_SIZE,
+			.setkey			=	des_setkey,
+			.encrypt		=	ecb_des_encrypt,
+			.decrypt		=	ecb_des_decrypt,
+		}
+	}
+};
+
+static int cbc_des_encrypt(struct blkcipher_desc *desc,
+			   struct scatterlist *dst, struct scatterlist *src,
+			   unsigned int nbytes)
+{
+	struct crypt_s390_des_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return cbc_desall_crypt(desc, KMC_DEA_ENCRYPT, sctx-&gt;iv, &amp;walk);
+}
+
+static int cbc_des_decrypt(struct blkcipher_desc *desc,
+			   struct scatterlist *dst, struct scatterlist *src,
+			   unsigned int nbytes)
+{
+	struct crypt_s390_des_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return cbc_desall_crypt(desc, KMC_DEA_DECRYPT, sctx-&gt;iv, &amp;walk);
+}
+
+static struct crypto_alg cbc_des_alg = {
+	.cra_name		=	"cbc(des)",
+	.cra_driver_name	=	"cbc-des-s390",
+	.cra_priority		=	CRYPT_S390_COMPOSITE_PRIORITY,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	DES_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct crypt_s390_des_ctx),
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(cbc_des_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	DES_KEY_SIZE,
+			.max_keysize		=	DES_KEY_SIZE,
+			.ivsize			=	DES_BLOCK_SIZE,
+			.setkey			=	des_setkey,
+			.encrypt		=	cbc_des_encrypt,
+			.decrypt		=	cbc_des_decrypt,
+		}
+	}
+};
+
 /*
  * RFC2451:
  *
@@ -295,6 +433,95 @@ static struct crypto_alg des3_128_alg = 
 	}
 };
 
+static int ecb_des3_128_encrypt(struct blkcipher_desc *desc,
+				struct scatterlist *dst,
+				struct scatterlist *src, unsigned int nbytes)
+{
+	struct crypt_s390_des3_128_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return ecb_desall_crypt(desc, KM_TDEA_128_ENCRYPT, sctx-&gt;key, &amp;walk);
+}
+
+static int ecb_des3_128_decrypt(struct blkcipher_desc *desc,
+				struct scatterlist *dst,
+				struct scatterlist *src, unsigned int nbytes)
+{
+	struct crypt_s390_des3_128_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return ecb_desall_crypt(desc, KM_TDEA_128_DECRYPT, sctx-&gt;key, &amp;walk);
+}
+
+static struct crypto_alg ecb_des3_128_alg = {
+	.cra_name		=	"ecb(des3_ede128)",
+	.cra_driver_name	=	"ecb-des3_ede128-s390",
+	.cra_priority		=	CRYPT_S390_COMPOSITE_PRIORITY,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	DES3_128_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct crypt_s390_des3_128_ctx),
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(
+						ecb_des3_128_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	DES3_128_KEY_SIZE,
+			.max_keysize		=	DES3_128_KEY_SIZE,
+			.setkey			=	des3_128_setkey,
+			.encrypt		=	ecb_des3_128_encrypt,
+			.decrypt		=	ecb_des3_128_decrypt,
+		}
+	}
+};
+
+static int cbc_des3_128_encrypt(struct blkcipher_desc *desc,
+				struct scatterlist *dst,
+				struct scatterlist *src, unsigned int nbytes)
+{
+	struct crypt_s390_des3_128_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return cbc_desall_crypt(desc, KMC_TDEA_128_ENCRYPT, sctx-&gt;iv, &amp;walk);
+}
+
+static int cbc_des3_128_decrypt(struct blkcipher_desc *desc,
+				struct scatterlist *dst,
+				struct scatterlist *src, unsigned int nbytes)
+{
+	struct crypt_s390_des3_128_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return cbc_desall_crypt(desc, KMC_TDEA_128_DECRYPT, sctx-&gt;iv, &amp;walk);
+}
+
+static struct crypto_alg cbc_des3_128_alg = {
+	.cra_name		=	"cbc(des3_ede128)",
+	.cra_driver_name	=	"cbc-des3_ede128-s390",
+	.cra_priority		=	CRYPT_S390_COMPOSITE_PRIORITY,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	DES3_128_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct crypt_s390_des3_128_ctx),
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(
+						cbc_des3_128_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	DES3_128_KEY_SIZE,
+			.max_keysize		=	DES3_128_KEY_SIZE,
+			.ivsize			=	DES3_128_BLOCK_SIZE,
+			.setkey			=	des3_128_setkey,
+			.encrypt		=	cbc_des3_128_encrypt,
+			.decrypt		=	cbc_des3_128_decrypt,
+		}
+	}
+};
+
 /*
  * RFC2451:
  *
@@ -437,6 +664,95 @@ static struct crypto_alg des3_192_alg = 
 	}
 };
 
+static int ecb_des3_192_encrypt(struct blkcipher_desc *desc,
+				struct scatterlist *dst,
+				struct scatterlist *src, unsigned int nbytes)
+{
+	struct crypt_s390_des3_192_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return ecb_desall_crypt(desc, KM_TDEA_192_ENCRYPT, sctx-&gt;key, &amp;walk);
+}
+
+static int ecb_des3_192_decrypt(struct blkcipher_desc *desc,
+				struct scatterlist *dst,
+				struct scatterlist *src, unsigned int nbytes)
+{
+	struct crypt_s390_des3_192_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return ecb_desall_crypt(desc, KM_TDEA_192_DECRYPT, sctx-&gt;key, &amp;walk);
+}
+
+static struct crypto_alg ecb_des3_192_alg = {
+	.cra_name		=	"ecb(des3_ede)",
+	.cra_driver_name	=	"ecb-des3_ede-s390",
+	.cra_priority		=	CRYPT_S390_COMPOSITE_PRIORITY,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	DES3_192_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct crypt_s390_des3_192_ctx),
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(
+						ecb_des3_192_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	DES3_192_KEY_SIZE,
+			.max_keysize		=	DES3_192_KEY_SIZE,
+			.setkey			=	des3_192_setkey,
+			.encrypt		=	ecb_des3_192_encrypt,
+			.decrypt		=	ecb_des3_192_decrypt,
+		}
+	}
+};
+
+static int cbc_des3_192_encrypt(struct blkcipher_desc *desc,
+				struct scatterlist *dst,
+				struct scatterlist *src, unsigned int nbytes)
+{
+	struct crypt_s390_des3_192_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return cbc_desall_crypt(desc, KMC_TDEA_192_ENCRYPT, sctx-&gt;iv, &amp;walk);
+}
+
+static int cbc_des3_192_decrypt(struct blkcipher_desc *desc,
+				struct scatterlist *dst,
+				struct scatterlist *src, unsigned int nbytes)
+{
+	struct crypt_s390_des3_192_ctx *sctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	return cbc_desall_crypt(desc, KMC_TDEA_192_DECRYPT, sctx-&gt;iv, &amp;walk);
+}
+
+static struct crypto_alg cbc_des3_192_alg = {
+	.cra_name		=	"cbc(des3_ede)",
+	.cra_driver_name	=	"cbc-des3_ede-s390",
+	.cra_priority		=	CRYPT_S390_COMPOSITE_PRIORITY,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	DES3_192_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct crypt_s390_des3_192_ctx),
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(
+						cbc_des3_192_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	DES3_192_KEY_SIZE,
+			.max_keysize		=	DES3_192_KEY_SIZE,
+			.ivsize			=	DES3_192_BLOCK_SIZE,
+			.setkey			=	des3_192_setkey,
+			.encrypt		=	cbc_des3_192_encrypt,
+			.decrypt		=	cbc_des3_192_decrypt,
+		}
+	}
+};
+
 static int init(void)
 {
 	int ret = 0;
@@ -446,22 +762,69 @@ static int init(void)
 	    !crypt_s390_func_available(KM_TDEA_192_ENCRYPT))
 		return -ENOSYS;
 
-	ret |= (crypto_register_alg(&amp;des_alg) == 0) ? 0:1;
-	ret |= (crypto_register_alg(&amp;des3_128_alg) == 0) ? 0:2;
-	ret |= (crypto_register_alg(&amp;des3_192_alg) == 0) ? 0:4;
-	if (ret) {
-		crypto_unregister_alg(&amp;des3_192_alg);
-		crypto_unregister_alg(&amp;des3_128_alg);
-		crypto_unregister_alg(&amp;des_alg);
-		return -EEXIST;
-	}
-	return 0;
+	ret = crypto_register_alg(&amp;des_alg);
+	if (ret)
+		goto des_err;
+	ret = crypto_register_alg(&amp;ecb_des_alg);
+	if (ret)
+		goto ecb_des_err;
+	ret = crypto_register_alg(&amp;cbc_des_alg);
+	if (ret)
+		goto cbc_des_err;
+
+	ret = crypto_register_alg(&amp;des3_128_alg);
+	if (ret)
+		goto des3_128_err;
+	ret = crypto_register_alg(&amp;ecb_des3_128_alg);
+	if (ret)
+		goto ecb_des3_128_err;
+	ret = crypto_register_alg(&amp;cbc_des3_128_alg);
+	if (ret)
+		goto cbc_des3_128_err;
+
+	ret = crypto_register_alg(&amp;des3_192_alg);
+	if (ret)
+		goto des3_192_err;
+	ret = crypto_register_alg(&amp;ecb_des3_192_alg);
+	if (ret)
+		goto ecb_des3_192_err;
+	ret = crypto_register_alg(&amp;cbc_des3_192_alg);
+	if (ret)
+		goto cbc_des3_192_err;
+
+out:
+	return ret;
+
+cbc_des3_192_err:
+	crypto_unregister_alg(&amp;ecb_des3_192_alg);
+ecb_des3_192_err:
+	crypto_unregister_alg(&amp;des3_192_alg);
+des3_192_err:
+	crypto_unregister_alg(&amp;cbc_des3_128_alg);
+cbc_des3_128_err:
+	crypto_unregister_alg(&amp;ecb_des3_128_alg);
+ecb_des3_128_err:
+	crypto_unregister_alg(&amp;des3_128_alg);
+des3_128_err:
+	crypto_unregister_alg(&amp;cbc_des_alg);
+cbc_des_err:
+	crypto_unregister_alg(&amp;ecb_des_alg);
+ecb_des_err:
+	crypto_unregister_alg(&amp;des_alg);
+des_err:
+	goto out;
 }
 
 static void __exit fini(void)
 {
+	crypto_unregister_alg(&amp;cbc_des3_192_alg);
+	crypto_unregister_alg(&amp;ecb_des3_192_alg);
 	crypto_unregister_alg(&amp;des3_192_alg);
+	crypto_unregister_alg(&amp;cbc_des3_128_alg);
+	crypto_unregister_alg(&amp;ecb_des3_128_alg);
 	crypto_unregister_alg(&amp;des3_128_alg);
+	crypto_unregister_alg(&amp;cbc_des_alg);
+	crypto_unregister_alg(&amp;ecb_des_alg);
 	crypto_unregister_alg(&amp;des_alg);
 }
 
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060802103544</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-08-02 10:35:44-0400</timestampReceived><subject>Re: crypto-root-fs via debian-netinst.iso-dailybuild-loopAES</subject><body>

........... this night is really long...............

I tried the 01.Aug.2006-build again, this time with loop-AES choosen for
crypted swap AND crypted root (/) with "/boot" beeing unencrypted.-

I had to give the full random-pool for crypted-swap with the keyboard, it looked
that there will be absolutly no advance if not all chars are typed in.
So far so god, it is only to be made once.
False, I had it to do again for the second crypted partition and the menu/the
function crashes after 12 or 13%; I had to start again to fill the random-pool
for this, second, crypted Partition.

This time I made it up to 100% and was than messaged, that I had choosen
crypto for "/", which is not possible, I should go back and change this.

Remember that crypto for "/" had, at least to this point, worked so far under
choosen dm-crypt.

I now switch off everything and dry the pee with a bing fan because I am
pissed off.

                                                   Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060804133236</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-04 13:32:36-0400</timestampReceived><subject>[2/7] [CRYPTO] cipher: Removed special IV checks for ECB</subject><body>

Hi:

[CRYPTO] cipher: Removed special IV checks for ECB

This patch makes IV operations on ECB fail through nocrypt_iv rather than
calling BUG().  This is needed to generalise CBC/ECB using the template
mechanism.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/cipher.c b/crypto/cipher.c
--- a/crypto/cipher.c
+++ b/crypto/cipher.c
@@ -399,6 +399,8 @@ int crypto_init_cipher_ops(struct crypto
 	case CRYPTO_TFM_MODE_ECB:
 		ops-&gt;cit_encrypt = ecb_encrypt;
 		ops-&gt;cit_decrypt = ecb_decrypt;
+		ops-&gt;cit_encrypt_iv = nocrypt_iv;
+		ops-&gt;cit_decrypt_iv = nocrypt_iv;
 		break;
 		
 	case CRYPTO_TFM_MODE_CBC:
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -410,7 +410,6 @@ static inline int crypto_cipher_encrypt_
                                            unsigned int nbytes, u8 *iv)
 {
 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
-	BUG_ON(tfm-&gt;crt_cipher.cit_mode == CRYPTO_TFM_MODE_ECB);
 	return tfm-&gt;crt_cipher.cit_encrypt_iv(tfm, dst, src, nbytes, iv);
 }                                        
 
@@ -429,7 +428,6 @@ static inline int crypto_cipher_decrypt_
                                            unsigned int nbytes, u8 *iv)
 {
 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
-	BUG_ON(tfm-&gt;crt_cipher.cit_mode == CRYPTO_TFM_MODE_ECB);
 	return tfm-&gt;crt_cipher.cit_decrypt_iv(tfm, dst, src, nbytes, iv);
 }
 
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060804133426</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-04 13:34:26-0400</timestampReceived><subject>[3/7] [CRYPTO] api: Split out low-level API</subject><body>

Hi:

[CRYPTO] api: Split out low-level API

The crypto API is made up of the part facing users such as IPsec and the
low-level part which is used by cryptographic entities such as algorithms.
This patch splits out the latter so that the two APIs are more clearly
delineated.  As a bonus the low-level API can now be modularised if all
algorithms are built as modules.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/Kconfig b/crypto/Kconfig
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -2,16 +2,21 @@
 # Cryptographic API Configuration
 #
 
-menu "Cryptographic options"
-
 config CRYPTO
 	bool "Cryptographic API"
 	help
 	  This option provides the core Cryptographic API.
 
+if CRYPTO
+
+menu "Cryptographic options"
+
+config CRYPTO_LOWAPI
+	tristate
+
 config CRYPTO_MANAGER
 	tristate "Cryptographic algorithm manager"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	default m
 	help
 	  Create default cryptographic template instantiations such as
@@ -19,45 +24,46 @@ config CRYPTO_MANAGER
 
 config CRYPTO_HMAC
 	tristate "HMAC support"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  HMAC: Keyed-Hashing for Message Authentication (RFC2104).
 	  This is required for IPSec.
 
 config CRYPTO_NULL
 	tristate "Null algorithms"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  These are 'Null' algorithms, used by IPsec, which do nothing.
 
 config CRYPTO_MD4
 	tristate "MD4 digest algorithm"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  MD4 message digest algorithm (RFC1320).
 
 config CRYPTO_MD5
 	tristate "MD5 digest algorithm"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  MD5 message digest algorithm (RFC1321).
 
 config CRYPTO_SHA1
 	tristate "SHA1 digest algorithm"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  SHA-1 secure hash standard (FIPS 180-1/DFIPS 180-2).
 
 config CRYPTO_SHA1_S390
 	tristate "SHA1 digest algorithm (s390)"
-	depends on CRYPTO &amp;&amp; S390
+	depends on S390
+	select CRYPTO_LOWAPI
 	help
 	  This is the s390 hardware accelerated implementation of the
 	  SHA-1 secure hash standard (FIPS 180-1/DFIPS 180-2).
 
 config CRYPTO_SHA256
 	tristate "SHA256 digest algorithm"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  SHA256 secure hash standard (DFIPS 180-2).
 	  
@@ -66,7 +72,8 @@ config CRYPTO_SHA256
 
 config CRYPTO_SHA256_S390
 	tristate "SHA256 digest algorithm (s390)"
-	depends on CRYPTO &amp;&amp; S390
+	depends on S390
+	select CRYPTO_LOWAPI
 	help
 	  This is the s390 hardware accelerated implementation of the
 	  SHA256 secure hash standard (DFIPS 180-2).
@@ -76,7 +83,7 @@ config CRYPTO_SHA256_S390
 
 config CRYPTO_SHA512
 	tristate "SHA384 and SHA512 digest algorithms"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  SHA512 secure hash standard (DFIPS 180-2).
 	  
@@ -88,7 +95,7 @@ config CRYPTO_SHA512
 
 config CRYPTO_WP512
 	tristate "Whirlpool digest algorithms"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  Whirlpool hash algorithm 512, 384 and 256-bit hashes
 
@@ -100,7 +107,7 @@ config CRYPTO_WP512
 
 config CRYPTO_TGR192
 	tristate "Tiger digest algorithms"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  Tiger hash algorithm 192, 160 and 128-bit hashes
 
@@ -113,19 +120,20 @@ config CRYPTO_TGR192
 
 config CRYPTO_DES
 	tristate "DES and Triple DES EDE cipher algorithms"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  DES cipher algorithm (FIPS 46-2), and Triple DES EDE (FIPS 46-3).
 
 config CRYPTO_DES_S390
 	tristate "DES and Triple DES cipher algorithms (s390)"
-	depends on CRYPTO &amp;&amp; S390
+	depends on S390
+	select CRYPTO_LOWAPI
 	help
 	  DES cipher algorithm (FIPS 46-2), and Triple DES EDE (FIPS 46-3).
 
 config CRYPTO_BLOWFISH
 	tristate "Blowfish cipher algorithm"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  Blowfish cipher algorithm, by Bruce Schneier.
 	  
@@ -138,7 +146,7 @@ config CRYPTO_BLOWFISH
 
 config CRYPTO_TWOFISH
 	tristate "Twofish cipher algorithm"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	select CRYPTO_TWOFISH_COMMON
 	help
 	  Twofish cipher algorithm.
@@ -153,14 +161,14 @@ config CRYPTO_TWOFISH
 
 config CRYPTO_TWOFISH_COMMON
 	tristate
-	depends on CRYPTO
 	help
 	  Common parts of the Twofish cipher algorithm shared by the
 	  generic c and the assembler implementations.
 
 config CRYPTO_TWOFISH_586
 	tristate "Twofish cipher algorithms (i586)"
-	depends on CRYPTO &amp;&amp; ((X86 || UML_X86) &amp;&amp; !64BIT)
+	depends on (X86 || UML_X86) &amp;&amp; !64BIT
+	select CRYPTO_LOWAPI
 	select CRYPTO_TWOFISH_COMMON
 	help
 	  Twofish cipher algorithm.
@@ -175,7 +183,8 @@ config CRYPTO_TWOFISH_586
 
 config CRYPTO_TWOFISH_X86_64
 	tristate "Twofish cipher algorithm (x86_64)"
-	depends on CRYPTO &amp;&amp; ((X86 || UML_X86) &amp;&amp; 64BIT)
+	depends on (X86 || UML_X86) &amp;&amp; 64BIT
+	select CRYPTO_LOWAPI
 	select CRYPTO_TWOFISH_COMMON
 	help
 	  Twofish cipher algorithm (x86_64).
@@ -190,7 +199,7 @@ config CRYPTO_TWOFISH_X86_64
 
 config CRYPTO_SERPENT
 	tristate "Serpent cipher algorithm"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  Serpent cipher algorithm, by Anderson, Biham &amp; Knudsen.
 
@@ -203,7 +212,7 @@ config CRYPTO_SERPENT
 
 config CRYPTO_AES
 	tristate "AES cipher algorithms"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  AES cipher algorithms (FIPS-197). AES uses the Rijndael 
 	  algorithm.
@@ -223,7 +232,8 @@ config CRYPTO_AES
 
 config CRYPTO_AES_586
 	tristate "AES cipher algorithms (i586)"
-	depends on CRYPTO &amp;&amp; ((X86 || UML_X86) &amp;&amp; !64BIT)
+	depends on (X86 || UML_X86) &amp;&amp; !64BIT
+	select CRYPTO_LOWAPI
 	help
 	  AES cipher algorithms (FIPS-197). AES uses the Rijndael 
 	  algorithm.
@@ -243,7 +253,8 @@ config CRYPTO_AES_586
 
 config CRYPTO_AES_X86_64
 	tristate "AES cipher algorithms (x86_64)"
-	depends on CRYPTO &amp;&amp; ((X86 || UML_X86) &amp;&amp; 64BIT)
+	depends on (X86 || UML_X86) &amp;&amp; 64BIT
+	select CRYPTO_LOWAPI
 	help
 	  AES cipher algorithms (FIPS-197). AES uses the Rijndael 
 	  algorithm.
@@ -263,7 +274,8 @@ config CRYPTO_AES_X86_64
 
 config CRYPTO_AES_S390
 	tristate "AES cipher algorithms (s390)"
-	depends on CRYPTO &amp;&amp; S390
+	depends on S390
+	select CRYPTO_LOWAPI
 	help
 	  This is the s390 hardware accelerated implementation of the
 	  AES cipher algorithms (FIPS-197). AES uses the Rijndael
@@ -283,21 +295,21 @@ config CRYPTO_AES_S390
 
 config CRYPTO_CAST5
 	tristate "CAST5 (CAST-128) cipher algorithm"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  The CAST5 encryption algorithm (synonymous with CAST-128) is
 	  described in RFC2144.
 
 config CRYPTO_CAST6
 	tristate "CAST6 (CAST-256) cipher algorithm"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  The CAST6 encryption algorithm (synonymous with CAST-256) is
 	  described in RFC2612.
 
 config CRYPTO_TEA
 	tristate "TEA, XTEA and XETA cipher algorithms"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  TEA cipher algorithm.
 
@@ -314,7 +326,7 @@ config CRYPTO_TEA
 
 config CRYPTO_ARC4
 	tristate "ARC4 cipher algorithm"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  ARC4 cipher algorithm.
 
@@ -325,7 +337,7 @@ config CRYPTO_ARC4
 
 config CRYPTO_KHAZAD
 	tristate "Khazad cipher algorithm"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  Khazad cipher algorithm.
 
@@ -338,7 +350,7 @@ config CRYPTO_KHAZAD
 
 config CRYPTO_ANUBIS
 	tristate "Anubis cipher algorithm"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  Anubis cipher algorithm.
 
@@ -353,7 +365,7 @@ config CRYPTO_ANUBIS
 
 config CRYPTO_DEFLATE
 	tristate "Deflate compression algorithm"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	select ZLIB_INFLATE
 	select ZLIB_DEFLATE
 	help
@@ -364,7 +376,7 @@ config CRYPTO_DEFLATE
 
 config CRYPTO_MICHAEL_MIC
 	tristate "Michael MIC keyed digest algorithm"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	help
 	  Michael MIC is used for message integrity protection in TKIP
 	  (IEEE 802.11i). This algorithm is required for TKIP, but it
@@ -373,7 +385,7 @@ config CRYPTO_MICHAEL_MIC
 
 config CRYPTO_CRC32C
 	tristate "CRC32c CRC algorithm"
-	depends on CRYPTO
+	select CRYPTO_LOWAPI
 	select LIBCRC32C
 	help
 	  Castagnoli, et al Cyclic Redundancy-Check Algorithm.  Used
@@ -383,10 +395,13 @@ config CRYPTO_CRC32C
 
 config CRYPTO_TEST
 	tristate "Testing module"
-	depends on CRYPTO &amp;&amp; m
+	depends on m
+	select CRYPTO_LOWAPI
 	help
 	  Quick &amp; dirty crypto test module.
 
 source "drivers/crypto/Kconfig"
+
 endmenu
 
+endif	# if CRYPTO
diff --git a/crypto/Makefile b/crypto/Makefile
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -2,10 +2,11 @@
 # Cryptographic API
 #
 
-proc-crypto-$(CONFIG_PROC_FS) = proc.o
+obj-$(CONFIG_CRYPTO) += api.o scatterwalk.o cipher.o digest.o compress.o
 
-obj-$(CONFIG_CRYPTO) += api.o scatterwalk.o cipher.o digest.o compress.o \
-			$(proc-crypto-y)
+crypto_lowapi-$(CONFIG_PROC_FS) += proc.o
+crypto_lowapi-objs := lowapi.o $(crypto_lowapi-y)
+obj-$(CONFIG_CRYPTO_LOWAPI) += crypto_lowapi.o
 
 obj-$(CONFIG_CRYPTO_MANAGER) += cryptomgr.o
 obj-$(CONFIG_CRYPTO_HMAC) += hmac.o
diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -15,30 +15,23 @@
  *
  */
 
-#include &lt;linux/compiler.h&gt;
-#include &lt;linux/init.h&gt;
-#include &lt;linux/crypto.h&gt;
 #include &lt;linux/err.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/kernel.h&gt;
-#include &lt;linux/kmod.h&gt;
 #include &lt;linux/module.h&gt;
-#include &lt;linux/notifier.h&gt;
 #include &lt;linux/param.h&gt;
-#include &lt;linux/rwsem.h&gt;
 #include &lt;linux/sched.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/string.h&gt;
 #include "internal.h"
 
 LIST_HEAD(crypto_alg_list);
-static LIST_HEAD(crypto_template_list);
+EXPORT_SYMBOL_GPL(crypto_alg_list);
 DECLARE_RWSEM(crypto_alg_sem);
+EXPORT_SYMBOL_GPL(crypto_alg_sem);
 
-static BLOCKING_NOTIFIER_HEAD(crypto_chain);
-
-static void crypto_destroy_instance(struct crypto_alg *alg);
-static void crypto_remove_final(struct list_head *list);
+BLOCKING_NOTIFIER_HEAD(crypto_chain);
+EXPORT_SYMBOL_GPL(crypto_chain);
 
 static inline struct crypto_alg *crypto_alg_get(struct crypto_alg *alg)
 {
@@ -46,16 +39,11 @@ static inline struct crypto_alg *crypto_
 	return alg;
 }
 
-static inline void crypto_alg_put(struct crypto_alg *alg)
-{
-	if (atomic_dec_and_test(&amp;alg-&gt;cra_refcnt) &amp;&amp; alg-&gt;cra_destroy)
-		alg-&gt;cra_destroy(alg);
-}
-
-static struct crypto_alg *crypto_mod_get(struct crypto_alg *alg)
+struct crypto_alg *crypto_mod_get(struct crypto_alg *alg)
 {
 	return try_module_get(alg-&gt;cra_module) ? crypto_alg_get(alg) : NULL;
 }
+EXPORT_SYMBOL_GPL(crypto_mod_get);
 
 void crypto_mod_put(struct crypto_alg *alg)
 {
@@ -64,28 +52,7 @@ void crypto_mod_put(struct crypto_alg *a
 }
 EXPORT_SYMBOL_GPL(crypto_mod_put);
 
-static inline int crypto_is_larval(struct crypto_alg *alg)
-{
-	return alg-&gt;cra_flags &amp; CRYPTO_ALG_LARVAL;
-}
-
-static inline int crypto_is_dead(struct crypto_alg *alg)
-{
-	return alg-&gt;cra_flags &amp; CRYPTO_ALG_DEAD;
-}
-
-static inline int crypto_is_moribund(struct crypto_alg *alg)
-{
-	return alg-&gt;cra_flags &amp; (CRYPTO_ALG_DEAD | CRYPTO_ALG_DYING);
-}
-
-static inline int crypto_notify(unsigned long val, void *v)
-{
-	return blocking_notifier_call_chain(&amp;crypto_chain, val, v);
-}
-
-static struct crypto_alg *__crypto_alg_lookup(const char *name, u32 type,
-					      u32 mask)
+struct crypto_alg *__crypto_alg_lookup(const char *name, u32 type, u32 mask)
 {
 	struct crypto_alg *q, *alg = NULL;
 	int best = -2;
@@ -122,6 +89,7 @@ static struct crypto_alg *__crypto_alg_l
 
 	return alg;
 }
+EXPORT_SYMBOL_GPL(__crypto_alg_lookup);
 
 static void crypto_larval_destroy(struct crypto_alg *alg)
 {
@@ -193,24 +161,6 @@ static struct crypto_alg *crypto_larval_
 	return alg;
 }
 
-void crypto_larval_error(const char *name, u32 type, u32 mask)
-{
-	struct crypto_alg *alg;
-
-	down_read(&amp;crypto_alg_sem);
-	alg = __crypto_alg_lookup(name, type, mask);
-	up_read(&amp;crypto_alg_sem);
-
-	if (alg) {
-		if (crypto_is_larval(alg)) {
-			struct crypto_larval *larval = (void *)alg;
-			complete(&amp;larval-&gt;completion);
-		}
-		crypto_mod_put(alg);
-	}
-}
-EXPORT_SYMBOL_GPL(crypto_larval_error);
-
 static struct crypto_alg *crypto_alg_lookup(const char *name, u32 type,
 					    u32 mask)
 {
@@ -349,14 +299,15 @@ static unsigned int crypto_ctxsize(struc
 	return len + (alg-&gt;cra_alignmask &amp; ~(crypto_tfm_ctx_alignment() - 1));
 }
 
-static void crypto_shoot_alg(struct crypto_alg *alg)
+void crypto_shoot_alg(struct crypto_alg *alg)
 {
 	down_write(&amp;crypto_alg_sem);
 	alg-&gt;cra_flags |= CRYPTO_ALG_DYING;
 	up_write(&amp;crypto_alg_sem);
 }
+EXPORT_SYMBOL_GPL(crypto_shoot_alg);
 
-static struct crypto_tfm *__crypto_alloc_tfm(struct crypto_alg *alg, u32 flags)
+struct crypto_tfm *__crypto_alloc_tfm(struct crypto_alg *alg, u32 flags)
 {
 	struct crypto_tfm *tfm = NULL;
 	unsigned int tfm_size;
@@ -393,6 +344,7 @@ out_free_tfm:
 out:
 	return tfm;
 }
+EXPORT_SYMBOL_GPL(__crypto_alloc_tfm);
 
 struct crypto_tfm *crypto_alloc_tfm(const char *name, u32 flags)
 {
@@ -438,366 +390,6 @@ void crypto_free_tfm(struct crypto_tfm *
 	kfree(tfm);
 }
 
-static inline int crypto_set_driver_name(struct crypto_alg *alg)
-{
-	static const char suffix[] = "-generic";
-	char *driver_name = alg-&gt;cra_driver_name;
-	int len;
-
-	if (*driver_name)
-		return 0;
-
-	len = strlcpy(driver_name, alg-&gt;cra_name, CRYPTO_MAX_ALG_NAME);
-	if (len + sizeof(suffix) &gt; CRYPTO_MAX_ALG_NAME)
-		return -ENAMETOOLONG;
-
-	memcpy(driver_name + len, suffix, sizeof(suffix));
-	return 0;
-}
-
-static int crypto_check_alg(struct crypto_alg *alg)
-{
-	if (alg-&gt;cra_alignmask &amp; (alg-&gt;cra_alignmask + 1))
-		return -EINVAL;
-
-	if (alg-&gt;cra_alignmask &amp; alg-&gt;cra_blocksize)
-		return -EINVAL;
-
-	if (alg-&gt;cra_blocksize &gt; PAGE_SIZE / 8)
-		return -EINVAL;
-
-	if (alg-&gt;cra_priority &lt; 0)
-		return -EINVAL;
-	
-	return crypto_set_driver_name(alg);
-}
-
-static void crypto_remove_spawns(struct list_head *spawns,
-				 struct list_head *list)
-{
-	struct crypto_spawn *spawn, *n;
-
-	list_for_each_entry_safe(spawn, n, spawns, list) {
-		struct crypto_instance *inst = spawn-&gt;inst;
-		struct crypto_template *tmpl = inst-&gt;tmpl;
-
-		list_del_init(&amp;spawn-&gt;list);
-		spawn-&gt;alg = NULL;
-
-		if (crypto_is_dead(&amp;inst-&gt;alg))
-			continue;
-
-		inst-&gt;alg.cra_flags |= CRYPTO_ALG_DEAD;
-		if (!tmpl || !crypto_tmpl_get(tmpl))
-			continue;
-
-		crypto_notify(CRYPTO_MSG_ALG_UNREGISTER, &amp;inst-&gt;alg);
-		list_move(&amp;inst-&gt;alg.cra_list, list);
-		hlist_del(&amp;inst-&gt;list);
-		inst-&gt;alg.cra_destroy = crypto_destroy_instance;
-
-		if (!list_empty(&amp;inst-&gt;alg.cra_users)) {
-			if (&amp;n-&gt;list == spawns)
-				n = list_entry(inst-&gt;alg.cra_users.next,
-					       typeof(*n), list);
-			__list_splice(&amp;inst-&gt;alg.cra_users, spawns-&gt;prev);
-		}
-	}
-}
-
-static int __crypto_register_alg(struct crypto_alg *alg,
-				 struct list_head *list)
-{
-	struct crypto_alg *q;
-	int ret = -EAGAIN;
-
-	if (crypto_is_dead(alg))
-		goto out;
-
-	INIT_LIST_HEAD(&amp;alg-&gt;cra_users);
-
-	ret = -EEXIST;
-	atomic_set(&amp;alg-&gt;cra_refcnt, 1);
-	list_for_each_entry(q, &amp;crypto_alg_list, cra_list) {
-		if (q == alg)
-			goto out;
-
-		if (crypto_is_moribund(q))
-			continue;
-
-		if (crypto_is_larval(q)) {
-			struct crypto_larval *larval = (void *)q;
-
-			if (strcmp(alg-&gt;cra_name, q-&gt;cra_name) &amp;&amp;
-			    strcmp(alg-&gt;cra_driver_name, q-&gt;cra_name))
-				continue;
-
-			if (larval-&gt;adult)
-				continue;
-			if ((q-&gt;cra_flags ^ alg-&gt;cra_flags) &amp; larval-&gt;mask)
-				continue;
-			if (!crypto_mod_get(alg))
-				continue;
-
-			larval-&gt;adult = alg;
-			complete(&amp;larval-&gt;completion);
-			continue;
-		}
-
-		if (strcmp(alg-&gt;cra_name, q-&gt;cra_name))
-			continue;
-
-		if (strcmp(alg-&gt;cra_driver_name, q-&gt;cra_driver_name) &amp;&amp;
-		    q-&gt;cra_priority &gt; alg-&gt;cra_priority)
-			continue;
-
-		crypto_remove_spawns(&amp;q-&gt;cra_users, list);
-	}
-	
-	list_add(&amp;alg-&gt;cra_list, &amp;crypto_alg_list);
-
-	crypto_notify(CRYPTO_MSG_ALG_REGISTER, alg);
-	ret = 0;
-
-out:	
-	return ret;
-}
-
-int crypto_register_alg(struct crypto_alg *alg)
-{
-	LIST_HEAD(list);
-	int err;
-
-	err = crypto_check_alg(alg);
-	if (err)
-		return err;
-
-	down_write(&amp;crypto_alg_sem);
-	err = __crypto_register_alg(alg, &amp;list);
-	up_write(&amp;crypto_alg_sem);
-
-	crypto_remove_final(&amp;list);
-	return err;
-}
-
-static void crypto_destroy_instance(struct crypto_alg *alg)
-{
-	struct crypto_instance *inst = (void *)alg;
-	struct crypto_template *tmpl = inst-&gt;tmpl;
-
-	tmpl-&gt;free(inst);
-	crypto_tmpl_put(tmpl);
-}
-
-static int crypto_remove_alg(struct crypto_alg *alg, struct list_head *list)
-{
-	if (unlikely(list_empty(&amp;alg-&gt;cra_list)))
-		return -ENOENT;
-
-	alg-&gt;cra_flags |= CRYPTO_ALG_DEAD;
-
-	crypto_notify(CRYPTO_MSG_ALG_UNREGISTER, alg);
-	list_del_init(&amp;alg-&gt;cra_list);
-	crypto_remove_spawns(&amp;alg-&gt;cra_users, list);
-
-	return 0;
-}
-
-static void crypto_remove_final(struct list_head *list)
-{
-	struct crypto_alg *alg;
-	struct crypto_alg *n;
-
-	list_for_each_entry_safe(alg, n, list, cra_list) {
-		list_del_init(&amp;alg-&gt;cra_list);
-		crypto_alg_put(alg);
-	}
-}
-
-int crypto_unregister_alg(struct crypto_alg *alg)
-{
-	int ret;
-	LIST_HEAD(list);
-	
-	down_write(&amp;crypto_alg_sem);
-	ret = crypto_remove_alg(alg, &amp;list);
-	up_write(&amp;crypto_alg_sem);
-
-	if (ret)
-		return ret;
-
-	BUG_ON(atomic_read(&amp;alg-&gt;cra_refcnt) != 1);
-	if (alg-&gt;cra_destroy)
-		alg-&gt;cra_destroy(alg);
-
-	crypto_remove_final(&amp;list);
-	return 0;
-}
-
-int crypto_register_template(struct crypto_template *tmpl)
-{
-	struct crypto_template *q;
-	int err = -EEXIST;
-
-	down_write(&amp;crypto_alg_sem);
-
-	list_for_each_entry(q, &amp;crypto_template_list, list) {
-		if (q == tmpl)
-			goto out;
-	}
-
-	list_add(&amp;tmpl-&gt;list, &amp;crypto_template_list);
-	crypto_notify(CRYPTO_MSG_TMPL_REGISTER, tmpl);
-	err = 0;
-out:
-	up_write(&amp;crypto_alg_sem);
-	return err;
-}
-EXPORT_SYMBOL_GPL(crypto_register_template);
-
-void crypto_unregister_template(struct crypto_template *tmpl)
-{
-	struct crypto_instance *inst;
-	struct hlist_node *p, *n;
-	struct hlist_head *list;
-	LIST_HEAD(users);
-
-	down_write(&amp;crypto_alg_sem);
-
-	BUG_ON(list_empty(&amp;tmpl-&gt;list));
-	list_del_init(&amp;tmpl-&gt;list);
-
-	list = &amp;tmpl-&gt;instances;
-	hlist_for_each_entry(inst, p, list, list) {
-		int err = crypto_remove_alg(&amp;inst-&gt;alg, &amp;users);
-		BUG_ON(err);
-	}
-
-	crypto_notify(CRYPTO_MSG_TMPL_UNREGISTER, tmpl);
-
-	up_write(&amp;crypto_alg_sem);
-
-	hlist_for_each_entry_safe(inst, p, n, list, list) {
-		BUG_ON(atomic_read(&amp;inst-&gt;alg.cra_refcnt) != 1);
-		tmpl-&gt;free(inst);
-	}
-	crypto_remove_final(&amp;users);
-}
-EXPORT_SYMBOL_GPL(crypto_unregister_template);
-
-static struct crypto_template *__crypto_lookup_template(const char *name)
-{
-	struct crypto_template *q, *tmpl = NULL;
-
-	down_read(&amp;crypto_alg_sem);
-	list_for_each_entry(q, &amp;crypto_template_list, list) {
-		if (strcmp(q-&gt;name, name))
-			continue;
-		if (unlikely(!crypto_tmpl_get(q)))
-			continue;
-
-		tmpl = q;
-		break;
-	}
-	up_read(&amp;crypto_alg_sem);
-
-	return tmpl;
-}
-
-struct crypto_template *crypto_lookup_template(const char *name)
-{
-	return try_then_request_module(__crypto_lookup_template(name), name);
-}
-EXPORT_SYMBOL_GPL(crypto_lookup_template);
-
-int crypto_register_instance(struct crypto_template *tmpl,
-			     struct crypto_instance *inst)
-{
-	LIST_HEAD(list);
-	int err = -EINVAL;
-
-	if (inst-&gt;alg.cra_destroy)
-		goto err;
-
-	err = crypto_check_alg(&amp;inst-&gt;alg);
-	if (err)
-		goto err;
-
-	inst-&gt;alg.cra_module = tmpl-&gt;module;
-
-	down_write(&amp;crypto_alg_sem);
-
-	err = __crypto_register_alg(&amp;inst-&gt;alg, &amp;list);
-	if (err)
-		goto unlock;
-
-	hlist_add_head(&amp;inst-&gt;list, &amp;tmpl-&gt;instances);
-	inst-&gt;tmpl = tmpl;
-
-unlock:
-	up_write(&amp;crypto_alg_sem);
-
-	crypto_remove_final(&amp;list);
-
-err:
-	return err;
-}
-EXPORT_SYMBOL_GPL(crypto_register_instance);
-
-int crypto_init_spawn(struct crypto_spawn *spawn, struct crypto_alg *alg,
-		      struct crypto_instance *inst)
-{
-	int err = -EAGAIN;
-
-	spawn-&gt;inst = inst;
-
-	down_write(&amp;crypto_alg_sem);
-	if (!crypto_is_moribund(alg)) {
-		list_add(&amp;spawn-&gt;list, &amp;alg-&gt;cra_users);
-		spawn-&gt;alg = alg;
-		err = 0;
-	}
-	up_write(&amp;crypto_alg_sem);
-
-	return err;
-}
-EXPORT_SYMBOL_GPL(crypto_init_spawn);
-
-void crypto_drop_spawn(struct crypto_spawn *spawn)
-{
-	down_write(&amp;crypto_alg_sem);
-	list_del(&amp;spawn-&gt;list);
-	up_write(&amp;crypto_alg_sem);
-}
-EXPORT_SYMBOL_GPL(crypto_drop_spawn);
-
-struct crypto_tfm *crypto_spawn_tfm(struct crypto_spawn *spawn)
-{
-	struct crypto_alg *alg;
-	struct crypto_alg *alg2;
-	struct crypto_tfm *tfm;
-
-	down_read(&amp;crypto_alg_sem);
-	alg = spawn-&gt;alg;
-	alg2 = alg;
-	if (alg2)
-		alg2 = crypto_mod_get(alg2);
-	up_read(&amp;crypto_alg_sem);
-
-	if (!alg2) {
-		if (alg)
-			crypto_shoot_alg(alg);
-		return ERR_PTR(-EAGAIN);
-	}
-
-	tfm = __crypto_alloc_tfm(alg, 0);
-	if (IS_ERR(tfm))
-		crypto_mod_put(alg);
-
-	return tfm;
-}
-EXPORT_SYMBOL_GPL(crypto_spawn_tfm);
-
 int crypto_alg_available(const char *name, u32 flags)
 {
 	int ret = 0;
@@ -811,29 +403,6 @@ int crypto_alg_available(const char *nam
 	return ret;
 }
 
-int crypto_register_notifier(struct notifier_block *nb)
-{
-	return blocking_notifier_chain_register(&amp;crypto_chain, nb);
-}
-EXPORT_SYMBOL_GPL(crypto_register_notifier);
-
-int crypto_unregister_notifier(struct notifier_block *nb)
-{
-	return blocking_notifier_chain_unregister(&amp;crypto_chain, nb);
-}
-EXPORT_SYMBOL_GPL(crypto_unregister_notifier);
-
-static int __init init_crypto(void)
-{
-	printk(KERN_INFO "Initializing Cryptographic API\n");
-	crypto_init_proc();
-	return 0;
-}
-
-__initcall(init_crypto);
-
-EXPORT_SYMBOL_GPL(crypto_register_alg);
-EXPORT_SYMBOL_GPL(crypto_unregister_alg);
 EXPORT_SYMBOL_GPL(crypto_alloc_tfm);
 EXPORT_SYMBOL_GPL(crypto_free_tfm);
 EXPORT_SYMBOL_GPL(crypto_alg_available);
diff --git a/crypto/hmac.c b/crypto/hmac.c
--- a/crypto/hmac.c
+++ b/crypto/hmac.c
@@ -15,14 +15,13 @@
  * any later version.
  *
  */
-#include &lt;linux/crypto.h&gt;
+#include &lt;crypto/lowapi.h&gt;
 #include &lt;linux/err.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/rtnetlink.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/scatterlist.h&gt;
-#include "internal.h"
 
 struct crypto_hmac_ctx {
 	struct crypto_tfm *child;
diff --git a/crypto/internal.h b/crypto/internal.h
--- a/crypto/internal.h
+++ b/crypto/internal.h
@@ -13,8 +13,8 @@
 #ifndef _CRYPTO_INTERNAL_H
 #define _CRYPTO_INTERNAL_H
 
+#include &lt;crypto/lowapi.h&gt;
 #include &lt;linux/completion.h&gt;
-#include &lt;linux/crypto.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/highmem.h&gt;
 #include &lt;linux/interrupt.h&gt;
@@ -22,9 +22,9 @@
 #include &lt;linux/list.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/kernel.h&gt;
+#include &lt;linux/notifier.h&gt;
 #include &lt;linux/rwsem.h&gt;
 #include &lt;linux/slab.h&gt;
-#include &lt;linux/types.h&gt;
 #include &lt;asm/kmap_types.h&gt;
 
 /* Crypto notification events. */
@@ -36,27 +36,8 @@ enum {
 	CRYPTO_MSG_TMPL_UNREGISTER,
 };
 
-struct notifier_block;
-
-struct crypto_instance {
-	struct crypto_alg alg;
-
-	struct crypto_template *tmpl;
-	struct hlist_node list;
-
-	char __ctx[] __attribute__ ((__aligned__));
-};
-
-struct crypto_template {
-	struct list_head list;
-	struct hlist_head instances;
-	struct module *module;
-
-	struct crypto_instance *(*alloc)(void *param, unsigned int len);
-	void (*free)(struct crypto_instance *inst);
-
-	char name[CRYPTO_MAX_ALG_NAME];
-};
+struct crypto_instance;
+struct crypto_template;
 
 struct crypto_larval {
 	struct crypto_alg alg;
@@ -65,14 +46,9 @@ struct crypto_larval {
 	u32 mask;
 };
 
-struct crypto_spawn {
-	struct list_head list;
-	struct crypto_alg *alg;
-	struct crypto_instance *inst;
-};
-
 extern struct list_head crypto_alg_list;
 extern struct rw_semaphore crypto_alg_sem;
+extern struct blocking_notifier_head crypto_chain;
 
 extern enum km_type crypto_km_types[];
 
@@ -99,9 +75,12 @@ static inline void crypto_yield(struct c
 
 #ifdef CONFIG_PROC_FS
 void __init crypto_init_proc(void);
+void __exit crypto_exit_proc(void);
 #else
 static inline void crypto_init_proc(void)
 { }
+static inline void crypto_exit_proc(void)
+{ }
 #endif
 
 static inline unsigned int crypto_digest_ctxsize(struct crypto_alg *alg,
@@ -138,6 +117,9 @@ static inline unsigned int crypto_compre
 	return alg-&gt;cra_ctxsize;
 }
 
+struct crypto_alg *crypto_mod_get(struct crypto_alg *alg);
+struct crypto_alg *__crypto_alg_lookup(const char *name, u32 type, u32 mask);
+
 int crypto_init_digest_flags(struct crypto_tfm *tfm, u32 flags);
 int crypto_init_cipher_flags(struct crypto_tfm *tfm, u32 flags);
 int crypto_init_compress_flags(struct crypto_tfm *tfm, u32 flags);
@@ -150,27 +132,21 @@ void crypto_exit_digest_ops(struct crypt
 void crypto_exit_cipher_ops(struct crypto_tfm *tfm);
 void crypto_exit_compress_ops(struct crypto_tfm *tfm);
 
-void crypto_mod_put(struct crypto_alg *alg);
 void crypto_larval_error(const char *name, u32 type, u32 mask);
-struct crypto_alg *crypto_alg_mod_lookup(const char *name, u32 type, u32 mask);
 
-int crypto_register_template(struct crypto_template *tmpl);
-void crypto_unregister_template(struct crypto_template *tmpl);
-struct crypto_template *crypto_lookup_template(const char *name);
+void crypto_shoot_alg(struct crypto_alg *alg);
+struct crypto_tfm *__crypto_alloc_tfm(struct crypto_alg *alg, u32 flags);
+
 int crypto_register_instance(struct crypto_template *tmpl,
 			     struct crypto_instance *inst);
 
 int crypto_register_notifier(struct notifier_block *nb);
 int crypto_unregister_notifier(struct notifier_block *nb);
 
-int crypto_init_spawn(struct crypto_spawn *spawn, struct crypto_alg *alg,
-		      struct crypto_instance *inst);
-void crypto_drop_spawn(struct crypto_spawn *spawn);
-struct crypto_tfm *crypto_spawn_tfm(struct crypto_spawn *spawn);
-
-static inline void *crypto_instance_ctx(struct crypto_instance *inst)
+static inline void crypto_alg_put(struct crypto_alg *alg)
 {
-	return inst-&gt;__ctx;
+	if (atomic_dec_and_test(&amp;alg-&gt;cra_refcnt) &amp;&amp; alg-&gt;cra_destroy)
+		alg-&gt;cra_destroy(alg);
 }
 
 static inline int crypto_tmpl_get(struct crypto_template *tmpl)
@@ -183,5 +159,25 @@ static inline void crypto_tmpl_put(struc
 	module_put(tmpl-&gt;module);
 }
 
+static inline int crypto_is_larval(struct crypto_alg *alg)
+{
+	return alg-&gt;cra_flags &amp; CRYPTO_ALG_LARVAL;
+}
+
+static inline int crypto_is_dead(struct crypto_alg *alg)
+{
+	return alg-&gt;cra_flags &amp; CRYPTO_ALG_DEAD;
+}
+
+static inline int crypto_is_moribund(struct crypto_alg *alg)
+{
+	return alg-&gt;cra_flags &amp; (CRYPTO_ALG_DEAD | CRYPTO_ALG_DYING);
+}
+
+static inline int crypto_notify(unsigned long val, void *v)
+{
+	return blocking_notifier_call_chain(&amp;crypto_chain, val, v);
+}
+
 #endif	/* _CRYPTO_INTERNAL_H */
 
diff --git a/crypto/lowapi.c b/crypto/lowapi.c
new file mode 100644
--- /dev/null
+++ b/crypto/lowapi.c
@@ -0,0 +1,433 @@
+/*
+ * Cryptographic API for algorithms (i.e., low-level API).
+ *
+ * Copyright (c) 2006 Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include &lt;linux/err.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/list.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/string.h&gt;
+
+#include "internal.h"
+
+static LIST_HEAD(crypto_template_list);
+
+void crypto_larval_error(const char *name, u32 type, u32 mask)
+{
+	struct crypto_alg *alg;
+
+	down_read(&amp;crypto_alg_sem);
+	alg = __crypto_alg_lookup(name, type, mask);
+	up_read(&amp;crypto_alg_sem);
+
+	if (alg) {
+		if (crypto_is_larval(alg)) {
+			struct crypto_larval *larval = (void *)alg;
+			complete(&amp;larval-&gt;completion);
+		}
+		crypto_mod_put(alg);
+	}
+}
+EXPORT_SYMBOL_GPL(crypto_larval_error);
+
+static inline int crypto_set_driver_name(struct crypto_alg *alg)
+{
+	static const char suffix[] = "-generic";
+	char *driver_name = alg-&gt;cra_driver_name;
+	int len;
+
+	if (*driver_name)
+		return 0;
+
+	len = strlcpy(driver_name, alg-&gt;cra_name, CRYPTO_MAX_ALG_NAME);
+	if (len + sizeof(suffix) &gt; CRYPTO_MAX_ALG_NAME)
+		return -ENAMETOOLONG;
+
+	memcpy(driver_name + len, suffix, sizeof(suffix));
+	return 0;
+}
+
+static int crypto_check_alg(struct crypto_alg *alg)
+{
+	if (alg-&gt;cra_alignmask &amp; (alg-&gt;cra_alignmask + 1))
+		return -EINVAL;
+
+	if (alg-&gt;cra_alignmask &amp; alg-&gt;cra_blocksize)
+		return -EINVAL;
+
+	if (alg-&gt;cra_blocksize &gt; PAGE_SIZE / 8)
+		return -EINVAL;
+
+	if (alg-&gt;cra_priority &lt; 0)
+		return -EINVAL;
+	
+	return crypto_set_driver_name(alg);
+}
+
+static void crypto_destroy_instance(struct crypto_alg *alg)
+{
+	struct crypto_instance *inst = (void *)alg;
+	struct crypto_template *tmpl = inst-&gt;tmpl;
+
+	tmpl-&gt;free(inst);
+	crypto_tmpl_put(tmpl);
+}
+
+static void crypto_remove_spawns(struct list_head *spawns,
+				 struct list_head *list)
+{
+	struct crypto_spawn *spawn, *n;
+
+	list_for_each_entry_safe(spawn, n, spawns, list) {
+		struct crypto_instance *inst = spawn-&gt;inst;
+		struct crypto_template *tmpl = inst-&gt;tmpl;
+
+		list_del_init(&amp;spawn-&gt;list);
+		spawn-&gt;alg = NULL;
+
+		if (crypto_is_dead(&amp;inst-&gt;alg))
+			continue;
+
+		inst-&gt;alg.cra_flags |= CRYPTO_ALG_DEAD;
+		if (!tmpl || !crypto_tmpl_get(tmpl))
+			continue;
+
+		crypto_notify(CRYPTO_MSG_ALG_UNREGISTER, &amp;inst-&gt;alg);
+		list_move(&amp;inst-&gt;alg.cra_list, list);
+		hlist_del(&amp;inst-&gt;list);
+		inst-&gt;alg.cra_destroy = crypto_destroy_instance;
+
+		if (!list_empty(&amp;inst-&gt;alg.cra_users)) {
+			if (&amp;n-&gt;list == spawns)
+				n = list_entry(inst-&gt;alg.cra_users.next,
+					       typeof(*n), list);
+			__list_splice(&amp;inst-&gt;alg.cra_users, spawns-&gt;prev);
+		}
+	}
+}
+
+static int __crypto_register_alg(struct crypto_alg *alg,
+				 struct list_head *list)
+{
+	struct crypto_alg *q;
+	int ret = -EAGAIN;
+
+	if (crypto_is_dead(alg))
+		goto out;
+
+	INIT_LIST_HEAD(&amp;alg-&gt;cra_users);
+
+	ret = -EEXIST;
+	atomic_set(&amp;alg-&gt;cra_refcnt, 1);
+	list_for_each_entry(q, &amp;crypto_alg_list, cra_list) {
+		if (q == alg)
+			goto out;
+
+		if (crypto_is_moribund(q))
+			continue;
+
+		if (crypto_is_larval(q)) {
+			struct crypto_larval *larval = (void *)q;
+
+			if (strcmp(alg-&gt;cra_name, q-&gt;cra_name) &amp;&amp;
+			    strcmp(alg-&gt;cra_driver_name, q-&gt;cra_name))
+				continue;
+
+			if (larval-&gt;adult)
+				continue;
+			if ((q-&gt;cra_flags ^ alg-&gt;cra_flags) &amp; larval-&gt;mask)
+				continue;
+			if (!crypto_mod_get(alg))
+				continue;
+
+			larval-&gt;adult = alg;
+			complete(&amp;larval-&gt;completion);
+			continue;
+		}
+
+		if (strcmp(alg-&gt;cra_name, q-&gt;cra_name))
+			continue;
+
+		if (strcmp(alg-&gt;cra_driver_name, q-&gt;cra_driver_name) &amp;&amp;
+		    q-&gt;cra_priority &gt; alg-&gt;cra_priority)
+			continue;
+
+		crypto_remove_spawns(&amp;q-&gt;cra_users, list);
+	}
+	
+	list_add(&amp;alg-&gt;cra_list, &amp;crypto_alg_list);
+
+	crypto_notify(CRYPTO_MSG_ALG_REGISTER, alg);
+	ret = 0;
+
+out:	
+	return ret;
+}
+
+static void crypto_remove_final(struct list_head *list)
+{
+	struct crypto_alg *alg;
+	struct crypto_alg *n;
+
+	list_for_each_entry_safe(alg, n, list, cra_list) {
+		list_del_init(&amp;alg-&gt;cra_list);
+		crypto_alg_put(alg);
+	}
+}
+
+int crypto_register_alg(struct crypto_alg *alg)
+{
+	LIST_HEAD(list);
+	int err;
+
+	err = crypto_check_alg(alg);
+	if (err)
+		return err;
+
+	down_write(&amp;crypto_alg_sem);
+	err = __crypto_register_alg(alg, &amp;list);
+	up_write(&amp;crypto_alg_sem);
+
+	crypto_remove_final(&amp;list);
+	return err;
+}
+EXPORT_SYMBOL_GPL(crypto_register_alg);
+
+static int crypto_remove_alg(struct crypto_alg *alg, struct list_head *list)
+{
+	if (unlikely(list_empty(&amp;alg-&gt;cra_list)))
+		return -ENOENT;
+
+	alg-&gt;cra_flags |= CRYPTO_ALG_DEAD;
+
+	crypto_notify(CRYPTO_MSG_ALG_UNREGISTER, alg);
+	list_del_init(&amp;alg-&gt;cra_list);
+	crypto_remove_spawns(&amp;alg-&gt;cra_users, list);
+
+	return 0;
+}
+
+int crypto_unregister_alg(struct crypto_alg *alg)
+{
+	int ret;
+	LIST_HEAD(list);
+	
+	down_write(&amp;crypto_alg_sem);
+	ret = crypto_remove_alg(alg, &amp;list);
+	up_write(&amp;crypto_alg_sem);
+
+	if (ret)
+		return ret;
+
+	BUG_ON(atomic_read(&amp;alg-&gt;cra_refcnt) != 1);
+	if (alg-&gt;cra_destroy)
+		alg-&gt;cra_destroy(alg);
+
+	crypto_remove_final(&amp;list);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(crypto_unregister_alg);
+
+int crypto_register_template(struct crypto_template *tmpl)
+{
+	struct crypto_template *q;
+	int err = -EEXIST;
+
+	down_write(&amp;crypto_alg_sem);
+
+	list_for_each_entry(q, &amp;crypto_template_list, list) {
+		if (q == tmpl)
+			goto out;
+	}
+
+	list_add(&amp;tmpl-&gt;list, &amp;crypto_template_list);
+	crypto_notify(CRYPTO_MSG_TMPL_REGISTER, tmpl);
+	err = 0;
+out:
+	up_write(&amp;crypto_alg_sem);
+	return err;
+}
+EXPORT_SYMBOL_GPL(crypto_register_template);
+
+void crypto_unregister_template(struct crypto_template *tmpl)
+{
+	struct crypto_instance *inst;
+	struct hlist_node *p, *n;
+	struct hlist_head *list;
+	LIST_HEAD(users);
+
+	down_write(&amp;crypto_alg_sem);
+
+	BUG_ON(list_empty(&amp;tmpl-&gt;list));
+	list_del_init(&amp;tmpl-&gt;list);
+
+	list = &amp;tmpl-&gt;instances;
+	hlist_for_each_entry(inst, p, list, list) {
+		int err = crypto_remove_alg(&amp;inst-&gt;alg, &amp;users);
+		BUG_ON(err);
+	}
+
+	crypto_notify(CRYPTO_MSG_TMPL_UNREGISTER, tmpl);
+
+	up_write(&amp;crypto_alg_sem);
+
+	hlist_for_each_entry_safe(inst, p, n, list, list) {
+		BUG_ON(atomic_read(&amp;inst-&gt;alg.cra_refcnt) != 1);
+		tmpl-&gt;free(inst);
+	}
+	crypto_remove_final(&amp;users);
+}
+EXPORT_SYMBOL_GPL(crypto_unregister_template);
+
+static struct crypto_template *__crypto_lookup_template(const char *name)
+{
+	struct crypto_template *q, *tmpl = NULL;
+
+	down_read(&amp;crypto_alg_sem);
+	list_for_each_entry(q, &amp;crypto_template_list, list) {
+		if (strcmp(q-&gt;name, name))
+			continue;
+		if (unlikely(!crypto_tmpl_get(q)))
+			continue;
+
+		tmpl = q;
+		break;
+	}
+	up_read(&amp;crypto_alg_sem);
+
+	return tmpl;
+}
+
+struct crypto_template *crypto_lookup_template(const char *name)
+{
+	return try_then_request_module(__crypto_lookup_template(name), name);
+}
+EXPORT_SYMBOL_GPL(crypto_lookup_template);
+
+int crypto_register_instance(struct crypto_template *tmpl,
+			     struct crypto_instance *inst)
+{
+	LIST_HEAD(list);
+	int err = -EINVAL;
+
+	if (inst-&gt;alg.cra_destroy)
+		goto err;
+
+	err = crypto_check_alg(&amp;inst-&gt;alg);
+	if (err)
+		goto err;
+
+	inst-&gt;alg.cra_module = tmpl-&gt;module;
+
+	down_write(&amp;crypto_alg_sem);
+
+	err = __crypto_register_alg(&amp;inst-&gt;alg, &amp;list);
+	if (err)
+		goto unlock;
+
+	hlist_add_head(&amp;inst-&gt;list, &amp;tmpl-&gt;instances);
+	inst-&gt;tmpl = tmpl;
+
+unlock:
+	up_write(&amp;crypto_alg_sem);
+
+	crypto_remove_final(&amp;list);
+
+err:
+	return err;
+}
+EXPORT_SYMBOL_GPL(crypto_register_instance);
+
+int crypto_init_spawn(struct crypto_spawn *spawn, struct crypto_alg *alg,
+		      struct crypto_instance *inst)
+{
+	int err = -EAGAIN;
+
+	spawn-&gt;inst = inst;
+
+	down_write(&amp;crypto_alg_sem);
+	if (!crypto_is_moribund(alg)) {
+		list_add(&amp;spawn-&gt;list, &amp;alg-&gt;cra_users);
+		spawn-&gt;alg = alg;
+		err = 0;
+	}
+	up_write(&amp;crypto_alg_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(crypto_init_spawn);
+
+void crypto_drop_spawn(struct crypto_spawn *spawn)
+{
+	down_write(&amp;crypto_alg_sem);
+	list_del(&amp;spawn-&gt;list);
+	up_write(&amp;crypto_alg_sem);
+}
+EXPORT_SYMBOL_GPL(crypto_drop_spawn);
+
+struct crypto_tfm *crypto_spawn_tfm(struct crypto_spawn *spawn)
+{
+	struct crypto_alg *alg;
+	struct crypto_alg *alg2;
+	struct crypto_tfm *tfm;
+
+	down_read(&amp;crypto_alg_sem);
+	alg = spawn-&gt;alg;
+	alg2 = alg;
+	if (alg2)
+		alg2 = crypto_mod_get(alg2);
+	up_read(&amp;crypto_alg_sem);
+
+	if (!alg2) {
+		if (alg)
+			crypto_shoot_alg(alg);
+		return ERR_PTR(-EAGAIN);
+	}
+
+	tfm = __crypto_alloc_tfm(alg, 0);
+	if (IS_ERR(tfm))
+		crypto_mod_put(alg);
+
+	return tfm;
+}
+EXPORT_SYMBOL_GPL(crypto_spawn_tfm);
+
+int crypto_register_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&amp;crypto_chain, nb);
+}
+EXPORT_SYMBOL_GPL(crypto_register_notifier);
+
+int crypto_unregister_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&amp;crypto_chain, nb);
+}
+EXPORT_SYMBOL_GPL(crypto_unregister_notifier);
+
+static int __init crypto_lowapi_init(void)
+{
+	printk(KERN_INFO "Initializing Cryptographic API\n");
+	crypto_init_proc();
+	return 0;
+}
+
+static void __exit crypto_lowapi_exit(void)
+{
+	crypto_exit_proc();
+}
+
+module_init(crypto_lowapi_init);
+module_exit(crypto_lowapi_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Low-level Cryptographic API");
diff --git a/crypto/proc.c b/crypto/proc.c
--- a/crypto/proc.c
+++ b/crypto/proc.c
@@ -113,3 +113,8 @@ void __init crypto_init_proc(void)
 	if (proc)
 		proc-&gt;proc_fops = &amp;proc_crypto_ops;
 }
+
+void __exit crypto_exit_proc(void)
+{
+	remove_proc_entry("crypto", NULL);
+}
diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -2,7 +2,7 @@ menu "Hardware crypto devices"
 
 config CRYPTO_DEV_PADLOCK
 	tristate "Support for VIA PadLock ACE"
-	depends on CRYPTO &amp;&amp; X86_32
+	depends on X86_32
 	default m
 	help
 	  Some VIA processors come with an integrated crypto engine
@@ -26,6 +26,7 @@ config CRYPTO_DEV_PADLOCK
 config CRYPTO_DEV_PADLOCK_AES
 	tristate "PadLock driver for AES algorithm"
 	depends on CRYPTO_DEV_PADLOCK
+	select CRYPTO_LOWAPI
 	default m
 	help
 	  Use VIA PadLock for AES algorithm.
@@ -38,6 +39,7 @@ config CRYPTO_DEV_PADLOCK_AES
 config CRYPTO_DEV_PADLOCK_SHA
 	tristate "PadLock driver for SHA1 and SHA256 algorithms"
 	depends on CRYPTO_DEV_PADLOCK
+	select CRYPTO_LOWAPI
 	select CRYPTO_SHA1
 	select CRYPTO_SHA256
 	default m
diff --git a/include/crypto/lowapi.h b/include/crypto/lowapi.h
new file mode 100644
--- /dev/null
+++ b/include/crypto/lowapi.h
@@ -0,0 +1,65 @@
+/*
+ * Cryptographic API for algorithms (i.e., low-level API).
+ *
+ * Copyright (c) 2006 Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ */
+#ifndef _CRYPTO_LOWAPI_H
+#define _CRYPTO_LOWAPI_H
+
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/list.h&gt;
+#include &lt;linux/kernel.h&gt;
+
+struct module;
+
+struct crypto_instance {
+	struct crypto_alg alg;
+
+	struct crypto_template *tmpl;
+	struct hlist_node list;
+
+	char __ctx[] __attribute__ ((__aligned__));
+};
+
+struct crypto_template {
+	struct list_head list;
+	struct hlist_head instances;
+	struct module *module;
+
+	struct crypto_instance *(*alloc)(void *param, unsigned int len);
+	void (*free)(struct crypto_instance *inst);
+
+	char name[CRYPTO_MAX_ALG_NAME];
+};
+
+struct crypto_spawn {
+	struct list_head list;
+	struct crypto_alg *alg;
+	struct crypto_instance *inst;
+};
+
+void crypto_mod_put(struct crypto_alg *alg);
+struct crypto_alg *crypto_alg_mod_lookup(const char *name, u32 type, u32 mask);
+
+int crypto_register_template(struct crypto_template *tmpl);
+void crypto_unregister_template(struct crypto_template *tmpl);
+struct crypto_template *crypto_lookup_template(const char *name);
+
+int crypto_init_spawn(struct crypto_spawn *spawn, struct crypto_alg *alg,
+		      struct crypto_instance *inst);
+void crypto_drop_spawn(struct crypto_spawn *spawn);
+struct crypto_tfm *crypto_spawn_tfm(struct crypto_spawn *spawn);
+
+static inline void *crypto_instance_ctx(struct crypto_instance *inst)
+{
+	return inst-&gt;__ctx;
+}
+
+#endif	/* _CRYPTO_LOWAPI_H */
+
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060805084958</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-08-05 08:49:58-0400</timestampReceived><subject>Re: [3/7] [CRYPTO] api: Split out low-level API</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Fri, 4 Aug 2006 23:34:26 +1000

&gt; [CRYPTO] api: Split out low-level API
&gt; 
&gt; The crypto API is made up of the part facing users such as IPsec and the
&gt; low-level part which is used by cryptographic entities such as algorithms.
&gt; This patch splits out the latter so that the two APIs are more clearly
&gt; delineated.  As a bonus the low-level API can now be modularised if all
&gt; algorithms are built as modules.
&gt; 
&gt; Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

This patch doesn't apply:

&gt;  config CRYPTO_MANAGER
&gt;  	tristate "Cryptographic algorithm manager"
&gt; -	depends on CRYPTO
&gt; +	select CRYPTO_LOWAPI
&gt;  	default m
&gt;  	help
&gt;  	  Create default cryptographic template instantiations such as

There is no CRYPTO_MANAGER in my net-2.6.19 tree.

Are you patching against -mm or something like that?

I'm going to leave the rest of these patches until this
is resolved.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060805100652</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-05 10:06:52-0400</timestampReceived><subject>Re: [3/7] [CRYPTO] api: Split out low-level API</subject><body>

On Sat, Aug 05, 2006 at 01:49:58AM -0700, David Miller wrote:
&gt;
&gt; &gt;  config CRYPTO_MANAGER
&gt; &gt;  	tristate "Cryptographic algorithm manager"
&gt; &gt; -	depends on CRYPTO
&gt; &gt; +	select CRYPTO_LOWAPI
&gt; &gt;  	default m
&gt; &gt;  	help
&gt; &gt;  	  Create default cryptographic template instantiations such as
&gt; 
&gt; There is no CRYPTO_MANAGER in my net-2.6.19 tree.
&gt; 
&gt; Are you patching against -mm or something like that?

Sorry Dave, these patches weren't meant for the net-2.6.19 tree.
They were supposed to enter -mm via the cryptodev tree.

I was just posting them for review.  I should've made that clearer
at the start.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060805102454</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-08-05 10:24:54-0400</timestampReceived><subject>Re: [3/7] [CRYPTO] api: Split out low-level API</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Sat, 5 Aug 2006 20:06:52 +1000

&gt; Sorry Dave, these patches weren't meant for the net-2.6.19 tree.
&gt; They were supposed to enter -mm via the cryptodev tree.
&gt; 
&gt; I was just posting them for review.  I should've made that clearer
&gt; at the start.

If I'm an explicit recipient and there's no "RFC" moniker in
the subject line I assume I should apply it :-)

The two patches I did apply were benign, so I'll leave them
in the net-2.6.19 tree
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060805103201</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-05 10:32:01-0400</timestampReceived><subject>Re: [3/7] [CRYPTO] api: Split out low-level API</subject><body>

On Sat, Aug 05, 2006 at 03:24:54AM -0700, David Miller wrote:
&gt; 
&gt; If I'm an explicit recipient and there's no "RFC" moniker in
&gt; the subject line I assume I should apply it :-)

I'll make sure that future crypto patches are more clearly marked :)

&gt; The two patches I did apply were benign, so I'll leave them
&gt; in the net-2.6.19 tree

No problems.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060805103623</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-05 10:36:23-0400</timestampReceived><subject>Re: [3/7] [CRYPTO] api: Split out low-level API</subject><body>

On Sat, Aug 05, 2006 at 08:32:01PM +1000, herbert wrote:
&gt; 
&gt; &gt; The two patches I did apply were benign, so I'll leave them
&gt; &gt; in the net-2.6.19 tree
&gt; 
&gt; No problems.

Actually, I just tried to rebase my tree without those two patches
and it ended in disaster since they both touch areas patched later
on.

So in order to avoid us being crucified by Andrew :), it'd be
great if you could back out those two patches from net-2.6.19.

Thanks,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813122014</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:20:14-0400</timestampReceived><subject>[PATCH 8/16] [CRYPTO] tcrypt: Use block ciphers where applicable</subject><body>

[CRYPTO] tcrypt: Use block ciphers where applicable

This patch converts tcrypt to use the new block cipher type where
applicable.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 crypto/tcrypt.c |  439 +++++++++++++++++++++++++++++++++-----------------------
 1 files changed, 261 insertions(+), 178 deletions(-)

diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -17,6 +17,7 @@
  *
  */
 
+#include &lt;linux/err.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/mm.h&gt;
@@ -54,8 +55,6 @@
 */
 #define ENCRYPT 1
 #define DECRYPT 0
-#define MODE_ECB 1
-#define MODE_CBC 0
 
 static unsigned int IDX[8] = { IDX1, IDX2, IDX3, IDX4, IDX5, IDX6, IDX7, IDX8 };
 
@@ -250,28 +249,27 @@ out:
 
 #endif	/* CONFIG_CRYPTO_HMAC */
 
-static void test_cipher(char *algo, int mode, int enc,
+static void test_cipher(char *algo, int enc,
 			struct cipher_testvec *template, unsigned int tcount)
 {
 	unsigned int ret, i, j, k, temp;
 	unsigned int tsize;
+	unsigned int iv_len;
+	unsigned int len;
 	char *q;
-	struct crypto_tfm *tfm;
+	struct crypto_blkcipher *tfm;
 	char *key;
 	struct cipher_testvec *cipher_tv;
+	struct blkcipher_desc desc;
 	struct scatterlist sg[8];
-	const char *e, *m;
+	const char *e;
 
 	if (enc == ENCRYPT)
 	        e = "encryption";
 	else
 		e = "decryption";
-	if (mode == MODE_ECB)
-		m = "ECB";
-	else
-		m = "CBC";
 
-	printk("\ntesting %s %s %s\n", algo, m, e);
+	printk("\ntesting %s %s\n", algo, e);
 
 	tsize = sizeof (struct cipher_testvec);
 	tsize *= tcount;
@@ -285,15 +283,15 @@ static void test_cipher(char *algo, int 
 	memcpy(tvmem, template, tsize);
 	cipher_tv = (void *)tvmem;
 
-	if (mode)
-		tfm = crypto_alloc_tfm(algo, 0);
-	else
-		tfm = crypto_alloc_tfm(algo, CRYPTO_TFM_MODE_CBC);
+	tfm = crypto_alloc_blkcipher(algo, 0, CRYPTO_ALG_ASYNC);
 
-	if (tfm == NULL) {
-		printk("failed to load transform for %s %s\n", algo, m);
+	if (IS_ERR(tfm)) {
+		printk("failed to load transform for %s: %ld\n", algo,
+		       PTR_ERR(tfm));
 		return;
 	}
+	desc.tfm = tfm;
+	desc.flags = 0;
 
 	j = 0;
 	for (i = 0; i &lt; tcount; i++) {
@@ -302,14 +300,17 @@ static void test_cipher(char *algo, int 
 			printk("test %u (%d bit key):\n",
 			j, cipher_tv[i].klen * 8);
 
-			tfm-&gt;crt_flags = 0;
+			crypto_blkcipher_clear_flags(tfm, ~0);
 			if (cipher_tv[i].wk)
-				tfm-&gt;crt_flags |= CRYPTO_TFM_REQ_WEAK_KEY;
+				crypto_blkcipher_set_flags(
+					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
 			key = cipher_tv[i].key;
 
-			ret = crypto_cipher_setkey(tfm, key, cipher_tv[i].klen);
+			ret = crypto_blkcipher_setkey(tfm, key,
+						      cipher_tv[i].klen);
 			if (ret) {
-				printk("setkey() failed flags=%x\n", tfm-&gt;crt_flags);
+				printk("setkey() failed flags=%x\n",
+				       crypto_blkcipher_get_flags(tfm));
 
 				if (!cipher_tv[i].fail)
 					goto out;
@@ -318,19 +319,19 @@ static void test_cipher(char *algo, int 
 			sg_set_buf(&amp;sg[0], cipher_tv[i].input,
 				   cipher_tv[i].ilen);
 
-			if (!mode) {
-				crypto_cipher_set_iv(tfm, cipher_tv[i].iv,
-					crypto_tfm_alg_ivsize(tfm));
-			}
-
-			if (enc)
-				ret = crypto_cipher_encrypt(tfm, sg, sg, cipher_tv[i].ilen);
-			else
-				ret = crypto_cipher_decrypt(tfm, sg, sg, cipher_tv[i].ilen);
-
+			iv_len = crypto_blkcipher_ivsize(tfm);
+			if (iv_len)
+				crypto_blkcipher_set_iv(tfm, cipher_tv[i].iv,
+							iv_len);
+
+			len = cipher_tv[i].ilen;
+			ret = enc ?
+				crypto_blkcipher_encrypt(&amp;desc, sg, sg, len) :
+				crypto_blkcipher_decrypt(&amp;desc, sg, sg, len);
 
 			if (ret) {
-				printk("%s () failed flags=%x\n", e, tfm-&gt;crt_flags);
+				printk("%s () failed flags=%x\n", e,
+				       desc.flags);
 				goto out;
 			}
 
@@ -343,7 +344,7 @@ static void test_cipher(char *algo, int 
 		}
 	}
 
-	printk("\ntesting %s %s %s across pages (chunking)\n", algo, m, e);
+	printk("\ntesting %s %s across pages (chunking)\n", algo, e);
 	memset(xbuf, 0, XBUFSIZE);
 
 	j = 0;
@@ -353,14 +354,17 @@ static void test_cipher(char *algo, int 
 			printk("test %u (%d bit key):\n",
 			j, cipher_tv[i].klen * 8);
 
-			tfm-&gt;crt_flags = 0;
+			crypto_blkcipher_clear_flags(tfm, ~0);
 			if (cipher_tv[i].wk)
-				tfm-&gt;crt_flags |= CRYPTO_TFM_REQ_WEAK_KEY;
+				crypto_blkcipher_set_flags(
+					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
 			key = cipher_tv[i].key;
 
-			ret = crypto_cipher_setkey(tfm, key, cipher_tv[i].klen);
+			ret = crypto_blkcipher_setkey(tfm, key,
+						      cipher_tv[i].klen);
 			if (ret) {
-				printk("setkey() failed flags=%x\n", tfm-&gt;crt_flags);
+				printk("setkey() failed flags=%x\n",
+				       crypto_blkcipher_get_flags(tfm));
 
 				if (!cipher_tv[i].fail)
 					goto out;
@@ -376,18 +380,19 @@ static void test_cipher(char *algo, int 
 					   cipher_tv[i].tap[k]);
 			}
 
-			if (!mode) {
-				crypto_cipher_set_iv(tfm, cipher_tv[i].iv,
-						crypto_tfm_alg_ivsize(tfm));
-			}
-
-			if (enc)
-				ret = crypto_cipher_encrypt(tfm, sg, sg, cipher_tv[i].ilen);
-			else
-				ret = crypto_cipher_decrypt(tfm, sg, sg, cipher_tv[i].ilen);
+			iv_len = crypto_blkcipher_ivsize(tfm);
+			if (iv_len)
+				crypto_blkcipher_set_iv(tfm, cipher_tv[i].iv,
+							iv_len);
+
+			len = cipher_tv[i].ilen;
+			ret = enc ?
+				crypto_blkcipher_encrypt(&amp;desc, sg, sg, len) :
+				crypto_blkcipher_decrypt(&amp;desc, sg, sg, len);
 
 			if (ret) {
-				printk("%s () failed flags=%x\n", e, tfm-&gt;crt_flags);
+				printk("%s () failed flags=%x\n", e,
+				       desc.flags);
 				goto out;
 			}
 
@@ -406,10 +411,10 @@ static void test_cipher(char *algo, int 
 	}
 
 out:
-	crypto_free_tfm(tfm);
+	crypto_free_blkcipher(tfm);
 }
 
-static int test_cipher_jiffies(struct crypto_tfm *tfm, int enc, char *p,
+static int test_cipher_jiffies(struct blkcipher_desc *desc, int enc, char *p,
 			       int blen, int sec)
 {
 	struct scatterlist sg[1];
@@ -422,9 +427,9 @@ static int test_cipher_jiffies(struct cr
 	for (start = jiffies, end = start + sec * HZ, bcount = 0;
 	     time_before(jiffies, end); bcount++) {
 		if (enc)
-			ret = crypto_cipher_encrypt(tfm, sg, sg, blen);
+			ret = crypto_blkcipher_encrypt(desc, sg, sg, blen);
 		else
-			ret = crypto_cipher_decrypt(tfm, sg, sg, blen);
+			ret = crypto_blkcipher_decrypt(desc, sg, sg, blen);
 
 		if (ret)
 			return ret;
@@ -435,7 +440,7 @@ static int test_cipher_jiffies(struct cr
 	return 0;
 }
 
-static int test_cipher_cycles(struct crypto_tfm *tfm, int enc, char *p,
+static int test_cipher_cycles(struct blkcipher_desc *desc, int enc, char *p,
 			      int blen)
 {
 	struct scatterlist sg[1];
@@ -451,9 +456,9 @@ static int test_cipher_cycles(struct cry
 	/* Warm-up run. */
 	for (i = 0; i &lt; 4; i++) {
 		if (enc)
-			ret = crypto_cipher_encrypt(tfm, sg, sg, blen);
+			ret = crypto_blkcipher_encrypt(desc, sg, sg, blen);
 		else
-			ret = crypto_cipher_decrypt(tfm, sg, sg, blen);
+			ret = crypto_blkcipher_decrypt(desc, sg, sg, blen);
 
 		if (ret)
 			goto out;
@@ -465,9 +470,9 @@ static int test_cipher_cycles(struct cry
 
 		start = get_cycles();
 		if (enc)
-			ret = crypto_cipher_encrypt(tfm, sg, sg, blen);
+			ret = crypto_blkcipher_encrypt(desc, sg, sg, blen);
 		else
-			ret = crypto_cipher_decrypt(tfm, sg, sg, blen);
+			ret = crypto_blkcipher_decrypt(desc, sg, sg, blen);
 		end = get_cycles();
 
 		if (ret)
@@ -487,35 +492,32 @@ out:
 	return ret;
 }
 
-static void test_cipher_speed(char *algo, int mode, int enc, unsigned int sec,
+static void test_cipher_speed(char *algo, int enc, unsigned int sec,
 			      struct cipher_testvec *template,
 			      unsigned int tcount, struct cipher_speed *speed)
 {
 	unsigned int ret, i, j, iv_len;
 	unsigned char *key, *p, iv[128];
-	struct crypto_tfm *tfm;
-	const char *e, *m;
+	struct crypto_blkcipher *tfm;
+	struct blkcipher_desc desc;
+	const char *e;
 
 	if (enc == ENCRYPT)
 	        e = "encryption";
 	else
 		e = "decryption";
-	if (mode == MODE_ECB)
-		m = "ECB";
-	else
-		m = "CBC";
 
-	printk("\ntesting speed of %s %s %s\n", algo, m, e);
+	printk("\ntesting speed of %s %s\n", algo, e);
 
-	if (mode)
-		tfm = crypto_alloc_tfm(algo, 0);
-	else
-		tfm = crypto_alloc_tfm(algo, CRYPTO_TFM_MODE_CBC);
+	tfm = crypto_alloc_blkcipher(algo, 0, CRYPTO_ALG_ASYNC);
 
-	if (tfm == NULL) {
-		printk("failed to load transform for %s %s\n", algo, m);
+	if (IS_ERR(tfm)) {
+		printk("failed to load transform for %s: %ld\n", algo,
+		       PTR_ERR(tfm));
 		return;
 	}
+	desc.tfm = tfm;
+	desc.flags = 0;
 
 	for (i = 0; speed[i].klen != 0; i++) {
 		if ((speed[i].blen + speed[i].klen) &gt; TVMEMSIZE) {
@@ -539,32 +541,33 @@ static void test_cipher_speed(char *algo
 		}
 		p = (unsigned char *)tvmem + speed[i].klen;
 
-		ret = crypto_cipher_setkey(tfm, key, speed[i].klen);
+		ret = crypto_blkcipher_setkey(tfm, key, speed[i].klen);
 		if (ret) {
-			printk("setkey() failed flags=%x\n", tfm-&gt;crt_flags);
+			printk("setkey() failed flags=%x\n",
+			       crypto_blkcipher_get_flags(tfm));
 			goto out;
 		}
 
-		if (!mode) {
-			iv_len = crypto_tfm_alg_ivsize(tfm);
+		iv_len = crypto_blkcipher_ivsize(tfm);
+		if (iv_len) {
 			memset(&amp;iv, 0xff, iv_len);
-			crypto_cipher_set_iv(tfm, iv, iv_len);
+			crypto_blkcipher_set_iv(tfm, iv, iv_len);
 		}
 
 		if (sec)
-			ret = test_cipher_jiffies(tfm, enc, p, speed[i].blen,
+			ret = test_cipher_jiffies(&amp;desc, enc, p, speed[i].blen,
 						  sec);
 		else
-			ret = test_cipher_cycles(tfm, enc, p, speed[i].blen);
+			ret = test_cipher_cycles(&amp;desc, enc, p, speed[i].blen);
 
 		if (ret) {
-			printk("%s() failed flags=%x\n", e, tfm-&gt;crt_flags);
+			printk("%s() failed flags=%x\n", e, desc.flags);
 			break;
 		}
 	}
 
 out:
-	crypto_free_tfm(tfm);
+	crypto_free_blkcipher(tfm);
 }
 
 static void test_digest_jiffies(struct crypto_tfm *tfm, char *p, int blen,
@@ -784,79 +787,119 @@ static void do_test(void)
 		test_hash("sha1", sha1_tv_template, SHA1_TEST_VECTORS);
 
 		//DES
-		test_cipher ("des", MODE_ECB, ENCRYPT, des_enc_tv_template, DES_ENC_TEST_VECTORS);
-		test_cipher ("des", MODE_ECB, DECRYPT, des_dec_tv_template, DES_DEC_TEST_VECTORS);
-		test_cipher ("des", MODE_CBC, ENCRYPT, des_cbc_enc_tv_template, DES_CBC_ENC_TEST_VECTORS);
-		test_cipher ("des", MODE_CBC, DECRYPT, des_cbc_dec_tv_template, DES_CBC_DEC_TEST_VECTORS);
+		test_cipher("ecb(des)", ENCRYPT, des_enc_tv_template,
+			    DES_ENC_TEST_VECTORS);
+		test_cipher("ecb(des)", DECRYPT, des_dec_tv_template,
+			    DES_DEC_TEST_VECTORS);
+		test_cipher("cbc(des)", ENCRYPT, des_cbc_enc_tv_template,
+			    DES_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(des)", DECRYPT, des_cbc_dec_tv_template,
+			    DES_CBC_DEC_TEST_VECTORS);
 
 		//DES3_EDE
-		test_cipher ("des3_ede", MODE_ECB, ENCRYPT, des3_ede_enc_tv_template, DES3_EDE_ENC_TEST_VECTORS);
-		test_cipher ("des3_ede", MODE_ECB, DECRYPT, des3_ede_dec_tv_template, DES3_EDE_DEC_TEST_VECTORS);
+		test_cipher("ecb(des3_ede)", ENCRYPT, des3_ede_enc_tv_template,
+			    DES3_EDE_ENC_TEST_VECTORS);
+		test_cipher("ecb(des3_ede)", DECRYPT, des3_ede_dec_tv_template,
+			    DES3_EDE_DEC_TEST_VECTORS);
 
 		test_hash("md4", md4_tv_template, MD4_TEST_VECTORS);
 
 		test_hash("sha256", sha256_tv_template, SHA256_TEST_VECTORS);
 
 		//BLOWFISH
-		test_cipher ("blowfish", MODE_ECB, ENCRYPT, bf_enc_tv_template, BF_ENC_TEST_VECTORS);
-		test_cipher ("blowfish", MODE_ECB, DECRYPT, bf_dec_tv_template, BF_DEC_TEST_VECTORS);
-		test_cipher ("blowfish", MODE_CBC, ENCRYPT, bf_cbc_enc_tv_template, BF_CBC_ENC_TEST_VECTORS);
-		test_cipher ("blowfish", MODE_CBC, DECRYPT, bf_cbc_dec_tv_template, BF_CBC_DEC_TEST_VECTORS);
+		test_cipher("ecb(blowfish)", ENCRYPT, bf_enc_tv_template,
+			    BF_ENC_TEST_VECTORS);
+		test_cipher("ecb(blowfish)", DECRYPT, bf_dec_tv_template,
+			    BF_DEC_TEST_VECTORS);
+		test_cipher("cbc(blowfish)", ENCRYPT, bf_cbc_enc_tv_template,
+			    BF_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(blowfish)", DECRYPT, bf_cbc_dec_tv_template,
+			    BF_CBC_DEC_TEST_VECTORS);
 
 		//TWOFISH
-		test_cipher ("twofish", MODE_ECB, ENCRYPT, tf_enc_tv_template, TF_ENC_TEST_VECTORS);
-		test_cipher ("twofish", MODE_ECB, DECRYPT, tf_dec_tv_template, TF_DEC_TEST_VECTORS);
-		test_cipher ("twofish", MODE_CBC, ENCRYPT, tf_cbc_enc_tv_template, TF_CBC_ENC_TEST_VECTORS);
-		test_cipher ("twofish", MODE_CBC, DECRYPT, tf_cbc_dec_tv_template, TF_CBC_DEC_TEST_VECTORS);
+		test_cipher("ecb(twofish)", ENCRYPT, tf_enc_tv_template,
+			    TF_ENC_TEST_VECTORS);
+		test_cipher("ecb(twofish)", DECRYPT, tf_dec_tv_template,
+			    TF_DEC_TEST_VECTORS);
+		test_cipher("cbc(twofish)", ENCRYPT, tf_cbc_enc_tv_template,
+			    TF_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(twofish)", DECRYPT, tf_cbc_dec_tv_template,
+			    TF_CBC_DEC_TEST_VECTORS);
 
 		//SERPENT
-		test_cipher ("serpent", MODE_ECB, ENCRYPT, serpent_enc_tv_template, SERPENT_ENC_TEST_VECTORS);
-		test_cipher ("serpent", MODE_ECB, DECRYPT, serpent_dec_tv_template, SERPENT_DEC_TEST_VECTORS);
+		test_cipher("ecb(serpent)", ENCRYPT, serpent_enc_tv_template,
+			    SERPENT_ENC_TEST_VECTORS);
+		test_cipher("ecb(serpent)", DECRYPT, serpent_dec_tv_template,
+			    SERPENT_DEC_TEST_VECTORS);
 
 		//TNEPRES
-		test_cipher ("tnepres", MODE_ECB, ENCRYPT, tnepres_enc_tv_template, TNEPRES_ENC_TEST_VECTORS);
-		test_cipher ("tnepres", MODE_ECB, DECRYPT, tnepres_dec_tv_template, TNEPRES_DEC_TEST_VECTORS);
+		test_cipher("ecb(tnepres)", ENCRYPT, tnepres_enc_tv_template,
+			    TNEPRES_ENC_TEST_VECTORS);
+		test_cipher("ecb(tnepres)", DECRYPT, tnepres_dec_tv_template,
+			    TNEPRES_DEC_TEST_VECTORS);
 
 		//AES
-		test_cipher ("aes", MODE_ECB, ENCRYPT, aes_enc_tv_template, AES_ENC_TEST_VECTORS);
-		test_cipher ("aes", MODE_ECB, DECRYPT, aes_dec_tv_template, AES_DEC_TEST_VECTORS);
-		test_cipher ("aes", MODE_CBC, ENCRYPT, aes_cbc_enc_tv_template, AES_CBC_ENC_TEST_VECTORS);
-		test_cipher ("aes", MODE_CBC, DECRYPT, aes_cbc_dec_tv_template, AES_CBC_DEC_TEST_VECTORS);
+		test_cipher("ecb(aes)", ENCRYPT, aes_enc_tv_template,
+			    AES_ENC_TEST_VECTORS);
+		test_cipher("ecb(aes)", DECRYPT, aes_dec_tv_template,
+			    AES_DEC_TEST_VECTORS);
+		test_cipher("cbc(aes)", ENCRYPT, aes_cbc_enc_tv_template,
+			    AES_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(aes)", DECRYPT, aes_cbc_dec_tv_template,
+			    AES_CBC_DEC_TEST_VECTORS);
 
 		//CAST5
-		test_cipher ("cast5", MODE_ECB, ENCRYPT, cast5_enc_tv_template, CAST5_ENC_TEST_VECTORS);
-		test_cipher ("cast5", MODE_ECB, DECRYPT, cast5_dec_tv_template, CAST5_DEC_TEST_VECTORS);
+		test_cipher("ecb(cast5)", ENCRYPT, cast5_enc_tv_template,
+			    CAST5_ENC_TEST_VECTORS);
+		test_cipher("ecb(cast5)", DECRYPT, cast5_dec_tv_template,
+			    CAST5_DEC_TEST_VECTORS);
 
 		//CAST6
-		test_cipher ("cast6", MODE_ECB, ENCRYPT, cast6_enc_tv_template, CAST6_ENC_TEST_VECTORS);
-		test_cipher ("cast6", MODE_ECB, DECRYPT, cast6_dec_tv_template, CAST6_DEC_TEST_VECTORS);
+		test_cipher("ecb(cast6)", ENCRYPT, cast6_enc_tv_template,
+			    CAST6_ENC_TEST_VECTORS);
+		test_cipher("ecb(cast6)", DECRYPT, cast6_dec_tv_template,
+			    CAST6_DEC_TEST_VECTORS);
 
 		//ARC4
-		test_cipher ("arc4", MODE_ECB, ENCRYPT, arc4_enc_tv_template, ARC4_ENC_TEST_VECTORS);
-		test_cipher ("arc4", MODE_ECB, DECRYPT, arc4_dec_tv_template, ARC4_DEC_TEST_VECTORS);
+		test_cipher("ecb(arc4)", ENCRYPT, arc4_enc_tv_template,
+			    ARC4_ENC_TEST_VECTORS);
+		test_cipher("ecb(arc4)", DECRYPT, arc4_dec_tv_template,
+			    ARC4_DEC_TEST_VECTORS);
 
 		//TEA
-		test_cipher ("tea", MODE_ECB, ENCRYPT, tea_enc_tv_template, TEA_ENC_TEST_VECTORS);
-		test_cipher ("tea", MODE_ECB, DECRYPT, tea_dec_tv_template, TEA_DEC_TEST_VECTORS);
+		test_cipher("ecb(tea)", ENCRYPT, tea_enc_tv_template,
+			    TEA_ENC_TEST_VECTORS);
+		test_cipher("ecb(tea)", DECRYPT, tea_dec_tv_template,
+			    TEA_DEC_TEST_VECTORS);
 
 
 		//XTEA
-		test_cipher ("xtea", MODE_ECB, ENCRYPT, xtea_enc_tv_template, XTEA_ENC_TEST_VECTORS);
-		test_cipher ("xtea", MODE_ECB, DECRYPT, xtea_dec_tv_template, XTEA_DEC_TEST_VECTORS);
+		test_cipher("ecb(xtea)", ENCRYPT, xtea_enc_tv_template,
+			    XTEA_ENC_TEST_VECTORS);
+		test_cipher("ecb(xtea)", DECRYPT, xtea_dec_tv_template,
+			    XTEA_DEC_TEST_VECTORS);
 
 		//KHAZAD
-		test_cipher ("khazad", MODE_ECB, ENCRYPT, khazad_enc_tv_template, KHAZAD_ENC_TEST_VECTORS);
-		test_cipher ("khazad", MODE_ECB, DECRYPT, khazad_dec_tv_template, KHAZAD_DEC_TEST_VECTORS);
+		test_cipher("ecb(khazad)", ENCRYPT, khazad_enc_tv_template,
+			    KHAZAD_ENC_TEST_VECTORS);
+		test_cipher("ecb(khazad)", DECRYPT, khazad_dec_tv_template,
+			    KHAZAD_DEC_TEST_VECTORS);
 
 		//ANUBIS
-		test_cipher ("anubis", MODE_ECB, ENCRYPT, anubis_enc_tv_template, ANUBIS_ENC_TEST_VECTORS);
-		test_cipher ("anubis", MODE_ECB, DECRYPT, anubis_dec_tv_template, ANUBIS_DEC_TEST_VECTORS);
-		test_cipher ("anubis", MODE_CBC, ENCRYPT, anubis_cbc_enc_tv_template, ANUBIS_CBC_ENC_TEST_VECTORS);
-		test_cipher ("anubis", MODE_CBC, DECRYPT, anubis_cbc_dec_tv_template, ANUBIS_CBC_ENC_TEST_VECTORS);
+		test_cipher("ecb(anubis)", ENCRYPT, anubis_enc_tv_template,
+			    ANUBIS_ENC_TEST_VECTORS);
+		test_cipher("ecb(anubis)", DECRYPT, anubis_dec_tv_template,
+			    ANUBIS_DEC_TEST_VECTORS);
+		test_cipher("cbc(anubis)", ENCRYPT, anubis_cbc_enc_tv_template,
+			    ANUBIS_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(anubis)", DECRYPT, anubis_cbc_dec_tv_template,
+			    ANUBIS_CBC_ENC_TEST_VECTORS);
 
 		//XETA
-		test_cipher ("xeta", MODE_ECB, ENCRYPT, xeta_enc_tv_template, XETA_ENC_TEST_VECTORS);
-		test_cipher ("xeta", MODE_ECB, DECRYPT, xeta_dec_tv_template, XETA_DEC_TEST_VECTORS);
+		test_cipher("ecb(xeta)", ENCRYPT, xeta_enc_tv_template,
+			    XETA_ENC_TEST_VECTORS);
+		test_cipher("ecb(xeta)", DECRYPT, xeta_dec_tv_template,
+			    XETA_DEC_TEST_VECTORS);
 
 		test_hash("sha384", sha384_tv_template, SHA384_TEST_VECTORS);
 		test_hash("sha512", sha512_tv_template, SHA512_TEST_VECTORS);
@@ -886,15 +929,21 @@ static void do_test(void)
 		break;
 
 	case 3:
-		test_cipher ("des", MODE_ECB, ENCRYPT, des_enc_tv_template, DES_ENC_TEST_VECTORS);
-		test_cipher ("des", MODE_ECB, DECRYPT, des_dec_tv_template, DES_DEC_TEST_VECTORS);
-		test_cipher ("des", MODE_CBC, ENCRYPT, des_cbc_enc_tv_template, DES_CBC_ENC_TEST_VECTORS);
-		test_cipher ("des", MODE_CBC, DECRYPT, des_cbc_dec_tv_template, DES_CBC_DEC_TEST_VECTORS);
+		test_cipher("ecb(des)", ENCRYPT, des_enc_tv_template,
+			    DES_ENC_TEST_VECTORS);
+		test_cipher("ecb(des)", DECRYPT, des_dec_tv_template,
+			    DES_DEC_TEST_VECTORS);
+		test_cipher("cbc(des)", ENCRYPT, des_cbc_enc_tv_template,
+			    DES_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(des)", DECRYPT, des_cbc_dec_tv_template,
+			    DES_CBC_DEC_TEST_VECTORS);
 		break;
 
 	case 4:
-		test_cipher ("des3_ede", MODE_ECB, ENCRYPT, des3_ede_enc_tv_template, DES3_EDE_ENC_TEST_VECTORS);
-		test_cipher ("des3_ede", MODE_ECB, DECRYPT, des3_ede_dec_tv_template, DES3_EDE_DEC_TEST_VECTORS);
+		test_cipher("ecb(des3_ede)", ENCRYPT, des3_ede_enc_tv_template,
+			    DES3_EDE_ENC_TEST_VECTORS);
+		test_cipher("ecb(des3_ede)", DECRYPT, des3_ede_dec_tv_template,
+			    DES3_EDE_DEC_TEST_VECTORS);
 		break;
 
 	case 5:
@@ -906,29 +955,43 @@ static void do_test(void)
 		break;
 
 	case 7:
-		test_cipher ("blowfish", MODE_ECB, ENCRYPT, bf_enc_tv_template, BF_ENC_TEST_VECTORS);
-		test_cipher ("blowfish", MODE_ECB, DECRYPT, bf_dec_tv_template, BF_DEC_TEST_VECTORS);
-		test_cipher ("blowfish", MODE_CBC, ENCRYPT, bf_cbc_enc_tv_template, BF_CBC_ENC_TEST_VECTORS);
-		test_cipher ("blowfish", MODE_CBC, DECRYPT, bf_cbc_dec_tv_template, BF_CBC_DEC_TEST_VECTORS);
+		test_cipher("ecb(blowfish)", ENCRYPT, bf_enc_tv_template,
+			    BF_ENC_TEST_VECTORS);
+		test_cipher("ecb(blowfish)", DECRYPT, bf_dec_tv_template,
+			    BF_DEC_TEST_VECTORS);
+		test_cipher("cbc(blowfish)", ENCRYPT, bf_cbc_enc_tv_template,
+			    BF_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(blowfish)", DECRYPT, bf_cbc_dec_tv_template,
+			    BF_CBC_DEC_TEST_VECTORS);
 		break;
 
 	case 8:
-		test_cipher ("twofish", MODE_ECB, ENCRYPT, tf_enc_tv_template, TF_ENC_TEST_VECTORS);
-		test_cipher ("twofish", MODE_ECB, DECRYPT, tf_dec_tv_template, TF_DEC_TEST_VECTORS);
-		test_cipher ("twofish", MODE_CBC, ENCRYPT, tf_cbc_enc_tv_template, TF_CBC_ENC_TEST_VECTORS);
-		test_cipher ("twofish", MODE_CBC, DECRYPT, tf_cbc_dec_tv_template, TF_CBC_DEC_TEST_VECTORS);
+		test_cipher("ecb(twofish)", ENCRYPT, tf_enc_tv_template,
+			    TF_ENC_TEST_VECTORS);
+		test_cipher("ecb(twofish)", DECRYPT, tf_dec_tv_template,
+			    TF_DEC_TEST_VECTORS);
+		test_cipher("cbc(twofish)", ENCRYPT, tf_cbc_enc_tv_template,
+			    TF_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(twofish)", DECRYPT, tf_cbc_dec_tv_template,
+			    TF_CBC_DEC_TEST_VECTORS);
 		break;
 
 	case 9:
-		test_cipher ("serpent", MODE_ECB, ENCRYPT, serpent_enc_tv_template, SERPENT_ENC_TEST_VECTORS);
-		test_cipher ("serpent", MODE_ECB, DECRYPT, serpent_dec_tv_template, SERPENT_DEC_TEST_VECTORS);
+		test_cipher("ecb(serpent)", ENCRYPT, serpent_enc_tv_template,
+			    SERPENT_ENC_TEST_VECTORS);
+		test_cipher("ecb(serpent)", DECRYPT, serpent_dec_tv_template,
+			    SERPENT_DEC_TEST_VECTORS);
 		break;
 
 	case 10:
-		test_cipher ("aes", MODE_ECB, ENCRYPT, aes_enc_tv_template, AES_ENC_TEST_VECTORS);
-		test_cipher ("aes", MODE_ECB, DECRYPT, aes_dec_tv_template, AES_DEC_TEST_VECTORS);
-		test_cipher ("aes", MODE_CBC, ENCRYPT, aes_cbc_enc_tv_template, AES_CBC_ENC_TEST_VECTORS);
-		test_cipher ("aes", MODE_CBC, DECRYPT, aes_cbc_dec_tv_template, AES_CBC_DEC_TEST_VECTORS);
+		test_cipher("ecb(aes)", ENCRYPT, aes_enc_tv_template,
+			    AES_ENC_TEST_VECTORS);
+		test_cipher("ecb(aes)", DECRYPT, aes_dec_tv_template,
+			    AES_DEC_TEST_VECTORS);
+		test_cipher("cbc(aes)", ENCRYPT, aes_cbc_enc_tv_template,
+			    AES_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(aes)", DECRYPT, aes_cbc_dec_tv_template,
+			    AES_CBC_DEC_TEST_VECTORS);
 		break;
 
 	case 11:
@@ -944,18 +1007,24 @@ static void do_test(void)
 		break;
 
 	case 14:
-		test_cipher ("cast5", MODE_ECB, ENCRYPT, cast5_enc_tv_template, CAST5_ENC_TEST_VECTORS);
-		test_cipher ("cast5", MODE_ECB, DECRYPT, cast5_dec_tv_template, CAST5_DEC_TEST_VECTORS);
+		test_cipher("ecb(cast5)", ENCRYPT, cast5_enc_tv_template,
+			    CAST5_ENC_TEST_VECTORS);
+		test_cipher("ecb(cast5)", DECRYPT, cast5_dec_tv_template,
+			    CAST5_DEC_TEST_VECTORS);
 		break;
 
 	case 15:
-		test_cipher ("cast6", MODE_ECB, ENCRYPT, cast6_enc_tv_template, CAST6_ENC_TEST_VECTORS);
-		test_cipher ("cast6", MODE_ECB, DECRYPT, cast6_dec_tv_template, CAST6_DEC_TEST_VECTORS);
+		test_cipher("ecb(cast6)", ENCRYPT, cast6_enc_tv_template,
+			    CAST6_ENC_TEST_VECTORS);
+		test_cipher("ecb(cast6)", DECRYPT, cast6_dec_tv_template,
+			    CAST6_DEC_TEST_VECTORS);
 		break;
 
 	case 16:
-		test_cipher ("arc4", MODE_ECB, ENCRYPT, arc4_enc_tv_template, ARC4_ENC_TEST_VECTORS);
-		test_cipher ("arc4", MODE_ECB, DECRYPT, arc4_dec_tv_template, ARC4_DEC_TEST_VECTORS);
+		test_cipher("ecb(arc4)", ENCRYPT, arc4_enc_tv_template,
+			    ARC4_ENC_TEST_VECTORS);
+		test_cipher("ecb(arc4)", DECRYPT, arc4_dec_tv_template,
+			    ARC4_DEC_TEST_VECTORS);
 		break;
 
 	case 17:
@@ -967,18 +1036,24 @@ static void do_test(void)
 		break;
 
 	case 19:
-		test_cipher ("tea", MODE_ECB, ENCRYPT, tea_enc_tv_template, TEA_ENC_TEST_VECTORS);
-		test_cipher ("tea", MODE_ECB, DECRYPT, tea_dec_tv_template, TEA_DEC_TEST_VECTORS);
+		test_cipher("ecb(tea)", ENCRYPT, tea_enc_tv_template,
+			    TEA_ENC_TEST_VECTORS);
+		test_cipher("ecb(tea)", DECRYPT, tea_dec_tv_template,
+			    TEA_DEC_TEST_VECTORS);
 		break;
 
 	case 20:
-		test_cipher ("xtea", MODE_ECB, ENCRYPT, xtea_enc_tv_template, XTEA_ENC_TEST_VECTORS);
-		test_cipher ("xtea", MODE_ECB, DECRYPT, xtea_dec_tv_template, XTEA_DEC_TEST_VECTORS);
+		test_cipher("ecb(xtea)", ENCRYPT, xtea_enc_tv_template,
+			    XTEA_ENC_TEST_VECTORS);
+		test_cipher("ecb(xtea)", DECRYPT, xtea_dec_tv_template,
+			    XTEA_DEC_TEST_VECTORS);
 		break;
 
 	case 21:
-		test_cipher ("khazad", MODE_ECB, ENCRYPT, khazad_enc_tv_template, KHAZAD_ENC_TEST_VECTORS);
-		test_cipher ("khazad", MODE_ECB, DECRYPT, khazad_dec_tv_template, KHAZAD_DEC_TEST_VECTORS);
+		test_cipher("ecb(khazad)", ENCRYPT, khazad_enc_tv_template,
+			    KHAZAD_ENC_TEST_VECTORS);
+		test_cipher("ecb(khazad)", DECRYPT, khazad_dec_tv_template,
+			    KHAZAD_DEC_TEST_VECTORS);
 		break;
 
 	case 22:
@@ -994,15 +1069,21 @@ static void do_test(void)
 		break;
 
 	case 25:
-		test_cipher ("tnepres", MODE_ECB, ENCRYPT, tnepres_enc_tv_template, TNEPRES_ENC_TEST_VECTORS);
-		test_cipher ("tnepres", MODE_ECB, DECRYPT, tnepres_dec_tv_template, TNEPRES_DEC_TEST_VECTORS);
+		test_cipher("ecb(tnepres)", ENCRYPT, tnepres_enc_tv_template,
+			    TNEPRES_ENC_TEST_VECTORS);
+		test_cipher("ecb(tnepres)", DECRYPT, tnepres_dec_tv_template,
+			    TNEPRES_DEC_TEST_VECTORS);
 		break;
 
 	case 26:
-		test_cipher ("anubis", MODE_ECB, ENCRYPT, anubis_enc_tv_template, ANUBIS_ENC_TEST_VECTORS);
-		test_cipher ("anubis", MODE_ECB, DECRYPT, anubis_dec_tv_template, ANUBIS_DEC_TEST_VECTORS);
-		test_cipher ("anubis", MODE_CBC, ENCRYPT, anubis_cbc_enc_tv_template, ANUBIS_CBC_ENC_TEST_VECTORS);
-		test_cipher ("anubis", MODE_CBC, DECRYPT, anubis_cbc_dec_tv_template, ANUBIS_CBC_ENC_TEST_VECTORS);
+		test_cipher("ecb(anubis)", ENCRYPT, anubis_enc_tv_template,
+			    ANUBIS_ENC_TEST_VECTORS);
+		test_cipher("ecb(anubis)", DECRYPT, anubis_dec_tv_template,
+			    ANUBIS_DEC_TEST_VECTORS);
+		test_cipher("cbc(anubis)", ENCRYPT, anubis_cbc_enc_tv_template,
+			    ANUBIS_CBC_ENC_TEST_VECTORS);
+		test_cipher("cbc(anubis)", DECRYPT, anubis_cbc_dec_tv_template,
+			    ANUBIS_CBC_ENC_TEST_VECTORS);
 		break;
 
 	case 27:
@@ -1019,8 +1100,10 @@ static void do_test(void)
 		break;
 		
 	case 30:
-		test_cipher ("xeta", MODE_ECB, ENCRYPT, xeta_enc_tv_template, XETA_ENC_TEST_VECTORS);
-		test_cipher ("xeta", MODE_ECB, DECRYPT, xeta_dec_tv_template, XETA_DEC_TEST_VECTORS);
+		test_cipher("ecb(xeta)", ENCRYPT, xeta_enc_tv_template,
+			    XETA_ENC_TEST_VECTORS);
+		test_cipher("ecb(xeta)", DECRYPT, xeta_dec_tv_template,
+			    XETA_DEC_TEST_VECTORS);
 		break;
 
 #ifdef CONFIG_CRYPTO_HMAC
@@ -1039,65 +1122,65 @@ static void do_test(void)
 #endif
 
 	case 200:
-		test_cipher_speed("aes", MODE_ECB, ENCRYPT, sec, NULL, 0,
+		test_cipher_speed("ecb(aes)", ENCRYPT, sec, NULL, 0,
 				  aes_speed_template);
-		test_cipher_speed("aes", MODE_ECB, DECRYPT, sec, NULL, 0,
+		test_cipher_speed("ecb(aes)", DECRYPT, sec, NULL, 0,
 				  aes_speed_template);
-		test_cipher_speed("aes", MODE_CBC, ENCRYPT, sec, NULL, 0,
+		test_cipher_speed("cbc(aes)", ENCRYPT, sec, NULL, 0,
 				  aes_speed_template);
-		test_cipher_speed("aes", MODE_CBC, DECRYPT, sec, NULL, 0,
+		test_cipher_speed("cbc(aes)", DECRYPT, sec, NULL, 0,
 				  aes_speed_template);
 		break;
 
 	case 201:
-		test_cipher_speed("des3_ede", MODE_ECB, ENCRYPT, sec,
+		test_cipher_speed("ecb(des3_ede)", ENCRYPT, sec,
 				  des3_ede_enc_tv_template,
 				  DES3_EDE_ENC_TEST_VECTORS,
 				  des3_ede_speed_template);
-		test_cipher_speed("des3_ede", MODE_ECB, DECRYPT, sec,
+		test_cipher_speed("ecb(des3_ede)", DECRYPT, sec,
 				  des3_ede_dec_tv_template,
 				  DES3_EDE_DEC_TEST_VECTORS,
 				  des3_ede_speed_template);
-		test_cipher_speed("des3_ede", MODE_CBC, ENCRYPT, sec,
+		test_cipher_speed("cbc(des3_ede)", ENCRYPT, sec,
 				  des3_ede_enc_tv_template,
 				  DES3_EDE_ENC_TEST_VECTORS,
 				  des3_ede_speed_template);
-		test_cipher_speed("des3_ede", MODE_CBC, DECRYPT, sec,
+		test_cipher_speed("cbc(des3_ede)", DECRYPT, sec,
 				  des3_ede_dec_tv_template,
 				  DES3_EDE_DEC_TEST_VECTORS,
 				  des3_ede_speed_template);
 		break;
 
 	case 202:
-		test_cipher_speed("twofish", MODE_ECB, ENCRYPT, sec, NULL, 0,
+		test_cipher_speed("ecb(twofish)", ENCRYPT, sec, NULL, 0,
 				  twofish_speed_template);
-		test_cipher_speed("twofish", MODE_ECB, DECRYPT, sec, NULL, 0,
+		test_cipher_speed("ecb(twofish)", DECRYPT, sec, NULL, 0,
 				  twofish_speed_template);
-		test_cipher_speed("twofish", MODE_CBC, ENCRYPT, sec, NULL, 0,
+		test_cipher_speed("cbc(twofish)", ENCRYPT, sec, NULL, 0,
 				  twofish_speed_template);
-		test_cipher_speed("twofish", MODE_CBC, DECRYPT, sec, NULL, 0,
+		test_cipher_speed("cbc(twofish)", DECRYPT, sec, NULL, 0,
 				  twofish_speed_template);
 		break;
 
 	case 203:
-		test_cipher_speed("blowfish", MODE_ECB, ENCRYPT, sec, NULL, 0,
+		test_cipher_speed("ecb(blowfish)", ENCRYPT, sec, NULL, 0,
 				  blowfish_speed_template);
-		test_cipher_speed("blowfish", MODE_ECB, DECRYPT, sec, NULL, 0,
+		test_cipher_speed("ecb(blowfish)", DECRYPT, sec, NULL, 0,
 				  blowfish_speed_template);
-		test_cipher_speed("blowfish", MODE_CBC, ENCRYPT, sec, NULL, 0,
+		test_cipher_speed("cbc(blowfish)", ENCRYPT, sec, NULL, 0,
 				  blowfish_speed_template);
-		test_cipher_speed("blowfish", MODE_CBC, DECRYPT, sec, NULL, 0,
+		test_cipher_speed("cbc(blowfish)", DECRYPT, sec, NULL, 0,
 				  blowfish_speed_template);
 		break;
 
 	case 204:
-		test_cipher_speed("des", MODE_ECB, ENCRYPT, sec, NULL, 0,
+		test_cipher_speed("ecb(des)", ENCRYPT, sec, NULL, 0,
 				  des_speed_template);
-		test_cipher_speed("des", MODE_ECB, DECRYPT, sec, NULL, 0,
+		test_cipher_speed("ecb(des)", DECRYPT, sec, NULL, 0,
 				  des_speed_template);
-		test_cipher_speed("des", MODE_CBC, ENCRYPT, sec, NULL, 0,
+		test_cipher_speed("cbc(des)", ENCRYPT, sec, NULL, 0,
 				  des_speed_template);
-		test_cipher_speed("des", MODE_CBC, DECRYPT, sec, NULL, 0,
+		test_cipher_speed("cbc(des)", DECRYPT, sec, NULL, 0,
 				  des_speed_template);
 		break;
 
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813122015</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:20:15-0400</timestampReceived><subject>[PATCH 9/16] [BLOCK] cryptoloop: Use block ciphers where applicable</subject><body>

[BLOCK] cryptoloop: Use block ciphers where applicable

This patch converts cryptoloop to use the new block cipher type where
applicable.  As a result the ECB-specific and CBC-specific transfer
functions have been merged.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 drivers/block/cryptoloop.c |  158 +++++++++++++++------------------------------
 1 files changed, 53 insertions(+), 105 deletions(-)

diff --git a/drivers/block/cryptoloop.c b/drivers/block/cryptoloop.c
--- a/drivers/block/cryptoloop.c
+++ b/drivers/block/cryptoloop.c
@@ -40,11 +40,13 @@ static int
 cryptoloop_init(struct loop_device *lo, const struct loop_info64 *info)
 {
 	int err = -EINVAL;
+	int cipher_len;
+	int mode_len;
 	char cms[LO_NAME_SIZE];			/* cipher-mode string */
 	char *cipher;
 	char *mode;
 	char *cmsp = cms;			/* c-m string pointer */
-	struct crypto_tfm *tfm = NULL;
+	struct crypto_blkcipher *tfm;
 
 	/* encryption breaks for non sector aligned offsets */
 
@@ -53,20 +55,39 @@ cryptoloop_init(struct loop_device *lo, 
 
 	strncpy(cms, info-&gt;lo_crypt_name, LO_NAME_SIZE);
 	cms[LO_NAME_SIZE - 1] = 0;
-	cipher = strsep(&amp;cmsp, "-");
-	mode = strsep(&amp;cmsp, "-");
 
-	if (mode == NULL || strcmp(mode, "cbc") == 0)
-		tfm = crypto_alloc_tfm(cipher, CRYPTO_TFM_MODE_CBC |
-					       CRYPTO_TFM_REQ_MAY_SLEEP);
-	else if (strcmp(mode, "ecb") == 0)
-		tfm = crypto_alloc_tfm(cipher, CRYPTO_TFM_MODE_ECB |
-					       CRYPTO_TFM_REQ_MAY_SLEEP);
-	if (tfm == NULL)
+	cipher = cmsp;
+	cipher_len = strcspn(cmsp, "-");
+
+	mode = cmsp + cipher_len;
+	mode_len = 0;
+	if (*mode) {
+		mode++;
+		mode_len = strcspn(mode, "-");
+	}
+
+	if (!mode_len) {
+		mode = "ecb";
+		mode_len = 3;
+	}
+
+	if (cipher_len + mode_len + 3 &gt; LO_NAME_SIZE)
 		return -EINVAL;
 
-	err = tfm-&gt;crt_u.cipher.cit_setkey(tfm, info-&gt;lo_encrypt_key,
-					   info-&gt;lo_encrypt_key_size);
+	memmove(cms, mode, mode_len);
+	cmsp = cms + mode_len;
+	*cmsp++ = '(';
+	memcpy(cmsp, info-&gt;lo_crypt_name, cipher_len);
+	cmsp += cipher_len;
+	*cmsp++ = ')';
+	*cmsp = 0;
+
+	tfm = crypto_alloc_blkcipher(cms, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(tfm))
+		return PTR_ERR(tfm);
+
+	err = crypto_blkcipher_setkey(tfm, info-&gt;lo_encrypt_key,
+				      info-&gt;lo_encrypt_key_size);
 	
 	if (err != 0)
 		goto out_free_tfm;
@@ -75,99 +96,49 @@ cryptoloop_init(struct loop_device *lo, 
 	return 0;
 
  out_free_tfm:
-	crypto_free_tfm(tfm);
+	crypto_free_blkcipher(tfm);
 
  out:
 	return err;
 }
 
 
-typedef int (*encdec_ecb_t)(struct crypto_tfm *tfm,
+typedef int (*encdec_cbc_t)(struct blkcipher_desc *desc,
 			struct scatterlist *sg_out,
 			struct scatterlist *sg_in,
 			unsigned int nsg);
 
-
-static int
-cryptoloop_transfer_ecb(struct loop_device *lo, int cmd,
-			struct page *raw_page, unsigned raw_off,
-			struct page *loop_page, unsigned loop_off,
-			int size, sector_t IV)
-{
-	struct crypto_tfm *tfm = (struct crypto_tfm *) lo-&gt;key_data;
-	struct scatterlist sg_out = { NULL, };
-	struct scatterlist sg_in = { NULL, };
-
-	encdec_ecb_t encdecfunc;
-	struct page *in_page, *out_page;
-	unsigned in_offs, out_offs;
-
-	if (cmd == READ) {
-		in_page = raw_page;
-		in_offs = raw_off;
-		out_page = loop_page;
-		out_offs = loop_off;
-		encdecfunc = tfm-&gt;crt_u.cipher.cit_decrypt;
-	} else {
-		in_page = loop_page;
-		in_offs = loop_off;
-		out_page = raw_page;
-		out_offs = raw_off;
-		encdecfunc = tfm-&gt;crt_u.cipher.cit_encrypt;
-	}
-
-	while (size &gt; 0) {
-		const int sz = min(size, LOOP_IV_SECTOR_SIZE);
-
-		sg_in.page = in_page;
-		sg_in.offset = in_offs;
-		sg_in.length = sz;
-
-		sg_out.page = out_page;
-		sg_out.offset = out_offs;
-		sg_out.length = sz;
-
-		encdecfunc(tfm, &amp;sg_out, &amp;sg_in, sz);
-
-		size -= sz;
-		in_offs += sz;
-		out_offs += sz;
-	}
-
-	return 0;
-}
-
-typedef int (*encdec_cbc_t)(struct crypto_tfm *tfm,
-			struct scatterlist *sg_out,
-			struct scatterlist *sg_in,
-			unsigned int nsg, u8 *iv);
-
 static int
-cryptoloop_transfer_cbc(struct loop_device *lo, int cmd,
-			struct page *raw_page, unsigned raw_off,
-			struct page *loop_page, unsigned loop_off,
-			int size, sector_t IV)
+cryptoloop_transfer(struct loop_device *lo, int cmd,
+		    struct page *raw_page, unsigned raw_off,
+		    struct page *loop_page, unsigned loop_off,
+		    int size, sector_t IV)
 {
-	struct crypto_tfm *tfm = (struct crypto_tfm *) lo-&gt;key_data;
+	struct crypto_blkcipher *tfm = lo-&gt;key_data;
+	struct blkcipher_desc desc = {
+		.tfm = tfm,
+		.flags = CRYPTO_TFM_REQ_MAY_SLEEP,
+	};
 	struct scatterlist sg_out = { NULL, };
 	struct scatterlist sg_in = { NULL, };
 
 	encdec_cbc_t encdecfunc;
 	struct page *in_page, *out_page;
 	unsigned in_offs, out_offs;
+	int err;
 
 	if (cmd == READ) {
 		in_page = raw_page;
 		in_offs = raw_off;
 		out_page = loop_page;
 		out_offs = loop_off;
-		encdecfunc = tfm-&gt;crt_u.cipher.cit_decrypt_iv;
+		encdecfunc = crypto_blkcipher_crt(tfm)-&gt;decrypt;
 	} else {
 		in_page = loop_page;
 		in_offs = loop_off;
 		out_page = raw_page;
 		out_offs = raw_off;
-		encdecfunc = tfm-&gt;crt_u.cipher.cit_encrypt_iv;
+		encdecfunc = crypto_blkcipher_crt(tfm)-&gt;encrypt;
 	}
 
 	while (size &gt; 0) {
@@ -183,7 +154,10 @@ cryptoloop_transfer_cbc(struct loop_devi
 		sg_out.offset = out_offs;
 		sg_out.length = sz;
 
-		encdecfunc(tfm, &amp;sg_out, &amp;sg_in, sz, (u8 *)iv);
+		desc.info = iv;
+		err = encdecfunc(&amp;desc, &amp;sg_out, &amp;sg_in, sz);
+		if (err)
+			return err;
 
 		IV++;
 		size -= sz;
@@ -195,32 +169,6 @@ cryptoloop_transfer_cbc(struct loop_devi
 }
 
 static int
-cryptoloop_transfer(struct loop_device *lo, int cmd,
-		    struct page *raw_page, unsigned raw_off,
-		    struct page *loop_page, unsigned loop_off,
-		    int size, sector_t IV)
-{
-	struct crypto_tfm *tfm = (struct crypto_tfm *) lo-&gt;key_data;
-	if(tfm-&gt;crt_cipher.cit_mode == CRYPTO_TFM_MODE_ECB)
-	{
-		lo-&gt;transfer = cryptoloop_transfer_ecb;
-		return cryptoloop_transfer_ecb(lo, cmd, raw_page, raw_off,
-					       loop_page, loop_off, size, IV);
-	}	
-	if(tfm-&gt;crt_cipher.cit_mode == CRYPTO_TFM_MODE_CBC)
-	{	
-		lo-&gt;transfer = cryptoloop_transfer_cbc;
-		return cryptoloop_transfer_cbc(lo, cmd, raw_page, raw_off,
-					       loop_page, loop_off, size, IV);
-	}
-	
-	/*  This is not supposed to happen */
-
-	printk( KERN_ERR "cryptoloop: unsupported cipher mode in cryptoloop_transfer!\n");
-	return -EINVAL;
-}
-
-static int
 cryptoloop_ioctl(struct loop_device *lo, int cmd, unsigned long arg)
 {
 	return -EINVAL;
@@ -229,9 +177,9 @@ cryptoloop_ioctl(struct loop_device *lo,
 static int
 cryptoloop_release(struct loop_device *lo)
 {
-	struct crypto_tfm *tfm = (struct crypto_tfm *) lo-&gt;key_data;
+	struct crypto_blkcipher *tfm = lo-&gt;key_data;
 	if (tfm != NULL) {
-		crypto_free_tfm(tfm);
+		crypto_free_blkcipher(tfm);
 		lo-&gt;key_data = NULL;
 		return 0;
 	}
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813122017</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:20:17-0400</timestampReceived><subject>[PATCH 10/16] [BLOCK] dm-crypt: Use block ciphers where applicable</subject><body>

[BLOCK] dm-crypt: Use block ciphers where applicable

This patch converts dm-crypt to use the new block cipher type where
applicable.  It also changes simple cipher operations to use the new
encrypt_one/decrypt_one interface.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 drivers/md/dm-crypt.c |   97 ++++++++++++++++++++------------------------------
 1 files changed, 40 insertions(+), 57 deletions(-)

diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@ -78,11 +78,13 @@ struct crypt_config {
 	 */
 	struct crypt_iv_operations *iv_gen_ops;
 	char *iv_mode;
-	void *iv_gen_private;
+	struct crypto_cipher *iv_gen_private;
 	sector_t iv_offset;
 	unsigned int iv_size;
 
-	struct crypto_tfm *tfm;
+	char cipher[CRYPTO_MAX_ALG_NAME];
+	char chainmode[CRYPTO_MAX_ALG_NAME];
+	struct crypto_blkcipher *tfm;
 	unsigned int key_size;
 	u8 key[0];
 };
@@ -118,7 +120,7 @@ static int crypt_iv_plain_gen(struct cry
 static int crypt_iv_essiv_ctr(struct crypt_config *cc, struct dm_target *ti,
 	                      const char *opts)
 {
-	struct crypto_tfm *essiv_tfm;
+	struct crypto_cipher *essiv_tfm;
 	struct crypto_tfm *hash_tfm;
 	struct scatterlist sg;
 	unsigned int saltsize;
@@ -155,51 +157,43 @@ static int crypt_iv_essiv_ctr(struct cry
 	crypto_free_tfm(hash_tfm);
 
 	/* Setup the essiv_tfm with the given salt */
-	essiv_tfm = crypto_alloc_tfm(crypto_tfm_alg_name(cc-&gt;tfm),
-	                             CRYPTO_TFM_MODE_ECB |
-	                             CRYPTO_TFM_REQ_MAY_SLEEP);
+	essiv_tfm = crypto_alloc_cipher(cc-&gt;cipher, 0, CRYPTO_ALG_ASYNC);
 	if (essiv_tfm == NULL) {
 		ti-&gt;error = "Error allocating crypto tfm for ESSIV";
 		kfree(salt);
 		return -EINVAL;
 	}
-	if (crypto_tfm_alg_blocksize(essiv_tfm)
-	    != crypto_tfm_alg_ivsize(cc-&gt;tfm)) {
+	if (crypto_cipher_blocksize(essiv_tfm) !=
+	    crypto_blkcipher_ivsize(cc-&gt;tfm)) {
 		ti-&gt;error = "Block size of ESSIV cipher does "
 			        "not match IV size of block cipher";
-		crypto_free_tfm(essiv_tfm);
+		crypto_free_cipher(essiv_tfm);
 		kfree(salt);
 		return -EINVAL;
 	}
 	if (crypto_cipher_setkey(essiv_tfm, salt, saltsize) &lt; 0) {
 		ti-&gt;error = "Failed to set key for ESSIV cipher";
-		crypto_free_tfm(essiv_tfm);
+		crypto_free_cipher(essiv_tfm);
 		kfree(salt);
 		return -EINVAL;
 	}
 	kfree(salt);
 
-	cc-&gt;iv_gen_private = (void *)essiv_tfm;
+	cc-&gt;iv_gen_private = essiv_tfm;
 	return 0;
 }
 
 static void crypt_iv_essiv_dtr(struct crypt_config *cc)
 {
-	crypto_free_tfm((struct crypto_tfm *)cc-&gt;iv_gen_private);
+	crypto_free_cipher(cc-&gt;iv_gen_private);
 	cc-&gt;iv_gen_private = NULL;
 }
 
 static int crypt_iv_essiv_gen(struct crypt_config *cc, u8 *iv, sector_t sector)
 {
-	struct scatterlist sg;
-
 	memset(iv, 0, cc-&gt;iv_size);
 	*(u64 *)iv = cpu_to_le64(sector);
-
-	sg_set_buf(&amp;sg, iv, cc-&gt;iv_size);
-	crypto_cipher_encrypt((struct crypto_tfm *)cc-&gt;iv_gen_private,
-	                      &amp;sg, &amp;sg, cc-&gt;iv_size);
-
+	crypto_cipher_encrypt_one(cc-&gt;iv_gen_private, iv, iv);
 	return 0;
 }
 
@@ -220,6 +214,11 @@ crypt_convert_scatterlist(struct crypt_c
                           int write, sector_t sector)
 {
 	u8 iv[cc-&gt;iv_size];
+	struct blkcipher_desc desc = {
+		.tfm = cc-&gt;tfm,
+		.info = iv,
+		.flags = CRYPTO_TFM_REQ_MAY_SLEEP,
+	};
 	int r;
 
 	if (cc-&gt;iv_gen_ops) {
@@ -228,14 +227,14 @@ crypt_convert_scatterlist(struct crypt_c
 			return r;
 
 		if (write)
-			r = crypto_cipher_encrypt_iv(cc-&gt;tfm, out, in, length, iv);
+			r = crypto_blkcipher_encrypt_iv(&amp;desc, out, in, length);
 		else
-			r = crypto_cipher_decrypt_iv(cc-&gt;tfm, out, in, length, iv);
+			r = crypto_blkcipher_decrypt_iv(&amp;desc, out, in, length);
 	} else {
 		if (write)
-			r = crypto_cipher_encrypt(cc-&gt;tfm, out, in, length);
+			r = crypto_blkcipher_encrypt(&amp;desc, out, in, length);
 		else
-			r = crypto_cipher_decrypt(cc-&gt;tfm, out, in, length);
+			r = crypto_blkcipher_decrypt(&amp;desc, out, in, length);
 	}
 
 	return r;
@@ -510,13 +509,12 @@ static void crypt_encode_key(char *hex, 
 static int crypt_ctr(struct dm_target *ti, unsigned int argc, char **argv)
 {
 	struct crypt_config *cc;
-	struct crypto_tfm *tfm;
+	struct crypto_blkcipher *tfm;
 	char *tmp;
 	char *cipher;
 	char *chainmode;
 	char *ivmode;
 	char *ivopts;
-	unsigned int crypto_flags;
 	unsigned int key_size;
 	unsigned long long tmpll;
 
@@ -556,31 +554,25 @@ static int crypt_ctr(struct dm_target *t
 		ivmode = "plain";
 	}
 
-	/* Choose crypto_flags according to chainmode */
-	if (strcmp(chainmode, "cbc") == 0)
-		crypto_flags = CRYPTO_TFM_MODE_CBC;
-	else if (strcmp(chainmode, "ecb") == 0)
-		crypto_flags = CRYPTO_TFM_MODE_ECB;
-	else {
-		ti-&gt;error = "Unknown chaining mode";
+	if (strcmp(chainmode, "ecb") &amp;&amp; !ivmode) {
+		ti-&gt;error = "This chaining mode requires an IV mechanism";
 		goto bad1;
 	}
 
-	if (crypto_flags != CRYPTO_TFM_MODE_ECB &amp;&amp; !ivmode) {
-		ti-&gt;error = "This chaining mode requires an IV mechanism";
+	if (snprintf(cc-&gt;cipher, CRYPTO_MAX_ALG_NAME, "%s(%s)", chainmode, 
+		     cipher) &gt;= CRYPTO_MAX_ALG_NAME) {
+		ti-&gt;error = "Chain mode + cipher name is too long";
 		goto bad1;
 	}
 
-	tfm = crypto_alloc_tfm(cipher, crypto_flags | CRYPTO_TFM_REQ_MAY_SLEEP);
-	if (!tfm) {
+	tfm = crypto_alloc_blkcipher(cc-&gt;cipher, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(tfm)) {
 		ti-&gt;error = "Error allocating crypto tfm";
 		goto bad1;
 	}
-	if (crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER) {
-		ti-&gt;error = "Expected cipher algorithm";
-		goto bad2;
-	}
 
+	strcpy(cc-&gt;cipher, cipher);
+	strcpy(cc-&gt;chainmode, chainmode);
 	cc-&gt;tfm = tfm;
 
 	/*
@@ -603,12 +595,12 @@ static int crypt_ctr(struct dm_target *t
 	    cc-&gt;iv_gen_ops-&gt;ctr(cc, ti, ivopts) &lt; 0)
 		goto bad2;
 
-	if (tfm-&gt;crt_cipher.cit_decrypt_iv &amp;&amp; tfm-&gt;crt_cipher.cit_encrypt_iv)
+	cc-&gt;iv_size = crypto_blkcipher_ivsize(tfm);
+	if (cc-&gt;iv_size)
 		/* at least a 64 bit sector number should fit in our buffer */
-		cc-&gt;iv_size = max(crypto_tfm_alg_ivsize(tfm),
+		cc-&gt;iv_size = max(cc-&gt;iv_size,
 		                  (unsigned int)(sizeof(u64) / sizeof(u8)));
 	else {
-		cc-&gt;iv_size = 0;
 		if (cc-&gt;iv_gen_ops) {
 			DMWARN("Selected cipher does not support IVs");
 			if (cc-&gt;iv_gen_ops-&gt;dtr)
@@ -629,7 +621,7 @@ static int crypt_ctr(struct dm_target *t
 		goto bad4;
 	}
 
-	if (tfm-&gt;crt_cipher.cit_setkey(tfm, cc-&gt;key, key_size) &lt; 0) {
+	if (crypto_blkcipher_setkey(tfm, cc-&gt;key, key_size) &lt; 0) {
 		ti-&gt;error = "Error setting key";
 		goto bad5;
 	}
@@ -675,7 +667,7 @@ bad3:
 	if (cc-&gt;iv_gen_ops &amp;&amp; cc-&gt;iv_gen_ops-&gt;dtr)
 		cc-&gt;iv_gen_ops-&gt;dtr(cc);
 bad2:
-	crypto_free_tfm(tfm);
+	crypto_free_blkcipher(tfm);
 bad1:
 	/* Must zero key material before freeing */
 	memset(cc, 0, sizeof(*cc) + cc-&gt;key_size * sizeof(u8));
@@ -693,7 +685,7 @@ static void crypt_dtr(struct dm_target *
 	kfree(cc-&gt;iv_mode);
 	if (cc-&gt;iv_gen_ops &amp;&amp; cc-&gt;iv_gen_ops-&gt;dtr)
 		cc-&gt;iv_gen_ops-&gt;dtr(cc);
-	crypto_free_tfm(cc-&gt;tfm);
+	crypto_free_blkcipher(cc-&gt;tfm);
 	dm_put_device(ti, cc-&gt;dev);
 
 	/* Must zero key material before freeing */
@@ -858,18 +850,9 @@ static int crypt_status(struct dm_target
 		break;
 
 	case STATUSTYPE_TABLE:
-		cipher = crypto_tfm_alg_name(cc-&gt;tfm);
+		cipher = crypto_blkcipher_name(cc-&gt;tfm);
 
-		switch(cc-&gt;tfm-&gt;crt_cipher.cit_mode) {
-		case CRYPTO_TFM_MODE_CBC:
-			chainmode = "cbc";
-			break;
-		case CRYPTO_TFM_MODE_ECB:
-			chainmode = "ecb";
-			break;
-		default:
-			BUG();
-		}
+		chainmode = cc-&gt;chainmode;
 
 		if (cc-&gt;iv_mode)
 			DMEMIT("%s-%s-%s ", cipher, chainmode, cc-&gt;iv_mode);
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813122019</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:20:19-0400</timestampReceived><subject>[PATCH 11/16] [IPSEC]: Add compatibility algorithm name support</subject><body>

[IPSEC]: Add compatibility algorithm name support

This patch adds a compatibility name field for each IPsec algorithm.  This
is needed when parameterised algorithms are used.  For example, "md5" will
become "hmac(md5)", and "aes" will become "cbc(aes)".

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 include/net/xfrm.h   |    1 +
 net/xfrm/xfrm_algo.c |    3 ++-
 net/xfrm/xfrm_user.c |    1 +
 3 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/include/net/xfrm.h b/include/net/xfrm.h
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@ -854,6 +854,7 @@ struct xfrm_algo_comp_info {
 
 struct xfrm_algo_desc {
 	char *name;
+	char *compat;
 	u8 available:1;
 	union {
 		struct xfrm_algo_auth_info auth;
diff --git a/net/xfrm/xfrm_algo.c b/net/xfrm/xfrm_algo.c
--- a/net/xfrm/xfrm_algo.c
+++ b/net/xfrm/xfrm_algo.c
@@ -359,7 +359,8 @@ static struct xfrm_algo_desc *xfrm_get_b
 		return NULL;
 
 	for (i = 0; i &lt; entries; i++) {
-		if (strcmp(name, list[i].name))
+		if (strcmp(name, list[i].name) &amp;&amp;
+		    (!list[i].compat || strcmp(name, list[i].compat)))
 			continue;
 
 		if (list[i].available)
diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c
--- a/net/xfrm/xfrm_user.c
+++ b/net/xfrm/xfrm_user.c
@@ -213,6 +213,7 @@ static int attach_one_algo(struct xfrm_a
 		return -ENOMEM;
 
 	memcpy(p, ualg, len);
+	strcpy(p-&gt;alg_name, algo-&gt;name);
 	*algpp = p;
 	return 0;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813122020</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:20:20-0400</timestampReceived><subject>[PATCH 12/16] [IPSEC] ESP: Use block ciphers where applicable</subject><body>

[IPSEC] ESP: Use block ciphers where applicable

This patch converts IPSec/ESP to use the new block cipher type where
applicable.  Similar to the HMAC conversion, existing algorithm names
have been kept for compatibility.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 include/net/esp.h    |    2 +-
 net/ipv4/Kconfig     |    1 +
 net/ipv4/esp4.c      |   49 +++++++++++++++++++++++++++++--------------------
 net/ipv6/Kconfig     |    1 +
 net/ipv6/esp6.c      |   48 ++++++++++++++++++++++++++++--------------------
 net/xfrm/xfrm_algo.c |   24 ++++++++++++++++--------
 6 files changed, 76 insertions(+), 49 deletions(-)

diff --git a/include/net/esp.h b/include/net/esp.h
--- a/include/net/esp.h
+++ b/include/net/esp.h
@@ -22,7 +22,7 @@ struct esp_data
 		 * &gt;= crypto_tfm_alg_ivsize(tfm). */
 		int			ivlen;
 		int			padlen;		/* 0..255 */
-		struct crypto_tfm	*tfm;		/* crypto handle */
+		struct crypto_blkcipher	*tfm;		/* crypto handle */
 	} conf;
 
 	/* Integrity. It is active when icv_full_len != 0 */
diff --git a/net/ipv4/Kconfig b/net/ipv4/Kconfig
--- a/net/ipv4/Kconfig
+++ b/net/ipv4/Kconfig
@@ -386,6 +386,7 @@ config INET_ESP
 	select CRYPTO
 	select CRYPTO_HMAC
 	select CRYPTO_MD5
+	select CRYPTO_CBC
 	select CRYPTO_SHA1
 	select CRYPTO_DES
 	---help---
diff --git a/net/ipv4/esp4.c b/net/ipv4/esp4.c
--- a/net/ipv4/esp4.c
+++ b/net/ipv4/esp4.c
@@ -1,3 +1,4 @@
+#include &lt;linux/err.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;net/ip.h&gt;
 #include &lt;net/xfrm.h&gt;
@@ -16,7 +17,8 @@ static int esp_output(struct xfrm_state 
 	int err;
 	struct iphdr *top_iph;
 	struct ip_esp_hdr *esph;
-	struct crypto_tfm *tfm;
+	struct crypto_blkcipher *tfm;
+	struct blkcipher_desc desc;
 	struct esp_data *esp;
 	struct sk_buff *trailer;
 	int blksize;
@@ -36,7 +38,9 @@ static int esp_output(struct xfrm_state 
 	esp = x-&gt;data;
 	alen = esp-&gt;auth.icv_trunc_len;
 	tfm = esp-&gt;conf.tfm;
-	blksize = ALIGN(crypto_tfm_alg_blocksize(tfm), 4);
+	desc.tfm = tfm;
+	desc.flags = 0;
+	blksize = ALIGN(crypto_blkcipher_blocksize(tfm), 4);
 	clen = ALIGN(clen + 2, blksize);
 	if (esp-&gt;conf.padlen)
 		clen = ALIGN(clen, esp-&gt;conf.padlen);
@@ -92,7 +96,7 @@ static int esp_output(struct xfrm_state 
 	xfrm_aevent_doreplay(x);
 
 	if (esp-&gt;conf.ivlen)
-		crypto_cipher_set_iv(tfm, esp-&gt;conf.ivec, crypto_tfm_alg_ivsize(tfm));
+		crypto_blkcipher_set_iv(tfm, esp-&gt;conf.ivec, esp-&gt;conf.ivlen);
 
 	do {
 		struct scatterlist *sg = &amp;esp-&gt;sgbuf[0];
@@ -103,14 +107,17 @@ static int esp_output(struct xfrm_state 
 				goto error;
 		}
 		skb_to_sgvec(skb, sg, esph-&gt;enc_data+esp-&gt;conf.ivlen-skb-&gt;data, clen);
-		crypto_cipher_encrypt(tfm, sg, sg, clen);
+		err = crypto_blkcipher_encrypt(&amp;desc, sg, sg, clen);
 		if (unlikely(sg != &amp;esp-&gt;sgbuf[0]))
 			kfree(sg);
 	} while (0);
 
+	if (unlikely(err))
+		goto error;
+
 	if (esp-&gt;conf.ivlen) {
-		memcpy(esph-&gt;enc_data, esp-&gt;conf.ivec, crypto_tfm_alg_ivsize(tfm));
-		crypto_cipher_get_iv(tfm, esp-&gt;conf.ivec, crypto_tfm_alg_ivsize(tfm));
+		memcpy(esph-&gt;enc_data, esp-&gt;conf.ivec, esp-&gt;conf.ivlen);
+		crypto_blkcipher_get_iv(tfm, esp-&gt;conf.ivec, esp-&gt;conf.ivlen);
 	}
 
 	if (esp-&gt;auth.icv_full_len) {
@@ -121,8 +128,6 @@ static int esp_output(struct xfrm_state 
 
 	ip_send_check(top_iph);
 
-	err = 0;
-
 error:
 	return err;
 }
@@ -137,8 +142,10 @@ static int esp_input(struct xfrm_state *
 	struct iphdr *iph;
 	struct ip_esp_hdr *esph;
 	struct esp_data *esp = x-&gt;data;
+	struct crypto_blkcipher *tfm = esp-&gt;conf.tfm;
+	struct blkcipher_desc desc = { .tfm = tfm };
 	struct sk_buff *trailer;
-	int blksize = ALIGN(crypto_tfm_alg_blocksize(esp-&gt;conf.tfm), 4);
+	int blksize = ALIGN(crypto_blkcipher_blocksize(tfm), 4);
 	int alen = esp-&gt;auth.icv_trunc_len;
 	int elen = skb-&gt;len - sizeof(struct ip_esp_hdr) - esp-&gt;conf.ivlen - alen;
 	int nfrags;
@@ -146,6 +153,7 @@ static int esp_input(struct xfrm_state *
 	u8 nexthdr[2];
 	struct scatterlist *sg;
 	int padlen;
+	int err;
 
 	if (!pskb_may_pull(skb, sizeof(struct ip_esp_hdr)))
 		goto out;
@@ -178,7 +186,7 @@ static int esp_input(struct xfrm_state *
 
 	/* Get ivec. This can be wrong, check against another impls. */
 	if (esp-&gt;conf.ivlen)
-		crypto_cipher_set_iv(esp-&gt;conf.tfm, esph-&gt;enc_data, crypto_tfm_alg_ivsize(esp-&gt;conf.tfm));
+		crypto_blkcipher_set_iv(tfm, esph-&gt;enc_data, esp-&gt;conf.ivlen);
 
 	sg = &amp;esp-&gt;sgbuf[0];
 
@@ -188,9 +196,11 @@ static int esp_input(struct xfrm_state *
 			goto out;
 	}
 	skb_to_sgvec(skb, sg, sizeof(struct ip_esp_hdr) + esp-&gt;conf.ivlen, elen);
-	crypto_cipher_decrypt(esp-&gt;conf.tfm, sg, sg, elen);
+	err = crypto_blkcipher_decrypt(&amp;desc, sg, sg, elen);
 	if (unlikely(sg != &amp;esp-&gt;sgbuf[0]))
 		kfree(sg);
+	if (unlikely(err))
+		return err;
 
 	if (skb_copy_bits(skb, skb-&gt;len-alen-2, nexthdr, 2))
 		BUG();
@@ -254,7 +264,7 @@ out:
 static u32 esp4_get_max_size(struct xfrm_state *x, int mtu)
 {
 	struct esp_data *esp = x-&gt;data;
-	u32 blksize = ALIGN(crypto_tfm_alg_blocksize(esp-&gt;conf.tfm), 4);
+	u32 blksize = ALIGN(crypto_blkcipher_blocksize(esp-&gt;conf.tfm), 4);
 
 	if (x-&gt;props.mode) {
 		mtu = ALIGN(mtu + 2, blksize);
@@ -293,7 +303,7 @@ static void esp_destroy(struct xfrm_stat
 	if (!esp)
 		return;
 
-	crypto_free_tfm(esp-&gt;conf.tfm);
+	crypto_free_blkcipher(esp-&gt;conf.tfm);
 	esp-&gt;conf.tfm = NULL;
 	kfree(esp-&gt;conf.ivec);
 	esp-&gt;conf.ivec = NULL;
@@ -307,6 +317,7 @@ static void esp_destroy(struct xfrm_stat
 static int esp_init_state(struct xfrm_state *x)
 {
 	struct esp_data *esp = NULL;
+	struct crypto_blkcipher *tfm;
 
 	/* null auth and encryption can have zero length keys */
 	if (x-&gt;aalg) {
@@ -353,13 +364,11 @@ static int esp_init_state(struct xfrm_st
 	}
 	esp-&gt;conf.key = x-&gt;ealg-&gt;alg_key;
 	esp-&gt;conf.key_len = (x-&gt;ealg-&gt;alg_key_len+7)/8;
-	if (x-&gt;props.ealgo == SADB_EALG_NULL)
-		esp-&gt;conf.tfm = crypto_alloc_tfm(x-&gt;ealg-&gt;alg_name, CRYPTO_TFM_MODE_ECB);
-	else
-		esp-&gt;conf.tfm = crypto_alloc_tfm(x-&gt;ealg-&gt;alg_name, CRYPTO_TFM_MODE_CBC);
-	if (esp-&gt;conf.tfm == NULL)
+	tfm = crypto_alloc_blkcipher(x-&gt;ealg-&gt;alg_name, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(tfm))
 		goto error;
-	esp-&gt;conf.ivlen = crypto_tfm_alg_ivsize(esp-&gt;conf.tfm);
+	esp-&gt;conf.tfm = tfm;
+	esp-&gt;conf.ivlen = crypto_blkcipher_ivsize(tfm);
 	esp-&gt;conf.padlen = 0;
 	if (esp-&gt;conf.ivlen) {
 		esp-&gt;conf.ivec = kmalloc(esp-&gt;conf.ivlen, GFP_KERNEL);
@@ -367,7 +376,7 @@ static int esp_init_state(struct xfrm_st
 			goto error;
 		get_random_bytes(esp-&gt;conf.ivec, esp-&gt;conf.ivlen);
 	}
-	if (crypto_cipher_setkey(esp-&gt;conf.tfm, esp-&gt;conf.key, esp-&gt;conf.key_len))
+	if (crypto_blkcipher_setkey(tfm, esp-&gt;conf.key, esp-&gt;conf.key_len))
 		goto error;
 	x-&gt;props.header_len = sizeof(struct ip_esp_hdr) + esp-&gt;conf.ivlen;
 	if (x-&gt;props.mode)
diff --git a/net/ipv6/Kconfig b/net/ipv6/Kconfig
--- a/net/ipv6/Kconfig
+++ b/net/ipv6/Kconfig
@@ -77,6 +77,7 @@ config INET6_ESP
 	select CRYPTO
 	select CRYPTO_HMAC
 	select CRYPTO_MD5
+	select CRYPTO_CBC
 	select CRYPTO_SHA1
 	select CRYPTO_DES
 	---help---
diff --git a/net/ipv6/esp6.c b/net/ipv6/esp6.c
--- a/net/ipv6/esp6.c
+++ b/net/ipv6/esp6.c
@@ -24,6 +24,7 @@
  * 	This file is derived from net/ipv4/esp.c
  */
 
+#include &lt;linux/err.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;net/ip.h&gt;
 #include &lt;net/xfrm.h&gt;
@@ -44,7 +45,8 @@ static int esp6_output(struct xfrm_state
 	int hdr_len;
 	struct ipv6hdr *top_iph;
 	struct ipv6_esp_hdr *esph;
-	struct crypto_tfm *tfm;
+	struct crypto_blkcipher *tfm;
+	struct blkcipher_desc desc;
 	struct esp_data *esp;
 	struct sk_buff *trailer;
 	int blksize;
@@ -67,7 +69,9 @@ static int esp6_output(struct xfrm_state
 
 	alen = esp-&gt;auth.icv_trunc_len;
 	tfm = esp-&gt;conf.tfm;
-	blksize = ALIGN(crypto_tfm_alg_blocksize(tfm), 4);
+	desc.tfm = tfm;
+	desc.flags = 0;
+	blksize = ALIGN(crypto_blkcipher_blocksize(tfm), 4);
 	clen = ALIGN(clen + 2, blksize);
 	if (esp-&gt;conf.padlen)
 		clen = ALIGN(clen, esp-&gt;conf.padlen);
@@ -96,7 +100,7 @@ static int esp6_output(struct xfrm_state
 	xfrm_aevent_doreplay(x);
 
 	if (esp-&gt;conf.ivlen)
-		crypto_cipher_set_iv(tfm, esp-&gt;conf.ivec, crypto_tfm_alg_ivsize(tfm));
+		crypto_blkcipher_set_iv(tfm, esp-&gt;conf.ivec, esp-&gt;conf.ivlen);
 
 	do {
 		struct scatterlist *sg = &amp;esp-&gt;sgbuf[0];
@@ -107,14 +111,17 @@ static int esp6_output(struct xfrm_state
 				goto error;
 		}
 		skb_to_sgvec(skb, sg, esph-&gt;enc_data+esp-&gt;conf.ivlen-skb-&gt;data, clen);
-		crypto_cipher_encrypt(tfm, sg, sg, clen);
+		err = crypto_blkcipher_encrypt(&amp;desc, sg, sg, clen);
 		if (unlikely(sg != &amp;esp-&gt;sgbuf[0]))
 			kfree(sg);
 	} while (0);
 
+	if (unlikely(err))
+		goto error;
+
 	if (esp-&gt;conf.ivlen) {
-		memcpy(esph-&gt;enc_data, esp-&gt;conf.ivec, crypto_tfm_alg_ivsize(tfm));
-		crypto_cipher_get_iv(tfm, esp-&gt;conf.ivec, crypto_tfm_alg_ivsize(tfm));
+		memcpy(esph-&gt;enc_data, esp-&gt;conf.ivec, esp-&gt;conf.ivlen);
+		crypto_blkcipher_get_iv(tfm, esp-&gt;conf.ivec, esp-&gt;conf.ivlen);
 	}
 
 	if (esp-&gt;auth.icv_full_len) {
@@ -123,8 +130,6 @@ static int esp6_output(struct xfrm_state
 		pskb_put(skb, trailer, alen);
 	}
 
-	err = 0;
-
 error:
 	return err;
 }
@@ -134,8 +139,10 @@ static int esp6_input(struct xfrm_state 
 	struct ipv6hdr *iph;
 	struct ipv6_esp_hdr *esph;
 	struct esp_data *esp = x-&gt;data;
+	struct crypto_blkcipher *tfm = esp-&gt;conf.tfm;
+	struct blkcipher_desc desc = { .tfm = tfm };
 	struct sk_buff *trailer;
-	int blksize = ALIGN(crypto_tfm_alg_blocksize(esp-&gt;conf.tfm), 4);
+	int blksize = ALIGN(crypto_blkcipher_blocksize(tfm), 4);
 	int alen = esp-&gt;auth.icv_trunc_len;
 	int elen = skb-&gt;len - sizeof(struct ipv6_esp_hdr) - esp-&gt;conf.ivlen - alen;
 
@@ -182,7 +189,7 @@ static int esp6_input(struct xfrm_state 
 
 	/* Get ivec. This can be wrong, check against another impls. */
 	if (esp-&gt;conf.ivlen)
-		crypto_cipher_set_iv(esp-&gt;conf.tfm, esph-&gt;enc_data, crypto_tfm_alg_ivsize(esp-&gt;conf.tfm));
+		crypto_blkcipher_set_iv(tfm, esph-&gt;enc_data, esp-&gt;conf.ivlen);
 
         {
 		u8 nexthdr[2];
@@ -197,9 +204,11 @@ static int esp6_input(struct xfrm_state 
 			}
 		}
 		skb_to_sgvec(skb, sg, sizeof(struct ipv6_esp_hdr) + esp-&gt;conf.ivlen, elen);
-		crypto_cipher_decrypt(esp-&gt;conf.tfm, sg, sg, elen);
+		ret = crypto_blkcipher_decrypt(&amp;desc, sg, sg, elen);
 		if (unlikely(sg != &amp;esp-&gt;sgbuf[0]))
 			kfree(sg);
+		if (unlikely(ret))
+			goto out;
 
 		if (skb_copy_bits(skb, skb-&gt;len-alen-2, nexthdr, 2))
 			BUG();
@@ -225,7 +234,7 @@ out:
 static u32 esp6_get_max_size(struct xfrm_state *x, int mtu)
 {
 	struct esp_data *esp = x-&gt;data;
-	u32 blksize = ALIGN(crypto_tfm_alg_blocksize(esp-&gt;conf.tfm), 4);
+	u32 blksize = ALIGN(crypto_blkcipher_blocksize(esp-&gt;conf.tfm), 4);
 
 	if (x-&gt;props.mode) {
 		mtu = ALIGN(mtu + 2, blksize);
@@ -266,7 +275,7 @@ static void esp6_destroy(struct xfrm_sta
 	if (!esp)
 		return;
 
-	crypto_free_tfm(esp-&gt;conf.tfm);
+	crypto_free_blkcipher(esp-&gt;conf.tfm);
 	esp-&gt;conf.tfm = NULL;
 	kfree(esp-&gt;conf.ivec);
 	esp-&gt;conf.ivec = NULL;
@@ -280,6 +289,7 @@ static void esp6_destroy(struct xfrm_sta
 static int esp6_init_state(struct xfrm_state *x)
 {
 	struct esp_data *esp = NULL;
+	struct crypto_blkcipher *tfm;
 
 	/* null auth and encryption can have zero length keys */
 	if (x-&gt;aalg) {
@@ -327,13 +337,11 @@ static int esp6_init_state(struct xfrm_s
 	}
 	esp-&gt;conf.key = x-&gt;ealg-&gt;alg_key;
 	esp-&gt;conf.key_len = (x-&gt;ealg-&gt;alg_key_len+7)/8;
-	if (x-&gt;props.ealgo == SADB_EALG_NULL)
-		esp-&gt;conf.tfm = crypto_alloc_tfm(x-&gt;ealg-&gt;alg_name, CRYPTO_TFM_MODE_ECB);
-	else
-		esp-&gt;conf.tfm = crypto_alloc_tfm(x-&gt;ealg-&gt;alg_name, CRYPTO_TFM_MODE_CBC);
-	if (esp-&gt;conf.tfm == NULL)
+	tfm = crypto_alloc_blkcipher(x-&gt;ealg-&gt;alg_name, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(tfm))
 		goto error;
-	esp-&gt;conf.ivlen = crypto_tfm_alg_ivsize(esp-&gt;conf.tfm);
+	esp-&gt;conf.tfm = tfm;
+	esp-&gt;conf.ivlen = crypto_blkcipher_ivsize(tfm);
 	esp-&gt;conf.padlen = 0;
 	if (esp-&gt;conf.ivlen) {
 		esp-&gt;conf.ivec = kmalloc(esp-&gt;conf.ivlen, GFP_KERNEL);
@@ -341,7 +349,7 @@ static int esp6_init_state(struct xfrm_s
 			goto error;
 		get_random_bytes(esp-&gt;conf.ivec, esp-&gt;conf.ivlen);
 	}
-	if (crypto_cipher_setkey(esp-&gt;conf.tfm, esp-&gt;conf.key, esp-&gt;conf.key_len))
+	if (crypto_blkcipher_setkey(tfm, esp-&gt;conf.key, esp-&gt;conf.key_len))
 		goto error;
 	x-&gt;props.header_len = sizeof(struct ipv6_esp_hdr) + esp-&gt;conf.ivlen;
 	if (x-&gt;props.mode)
diff --git a/net/xfrm/xfrm_algo.c b/net/xfrm/xfrm_algo.c
--- a/net/xfrm/xfrm_algo.c
+++ b/net/xfrm/xfrm_algo.c
@@ -118,7 +118,8 @@ static struct xfrm_algo_desc aalg_list[]
 
 static struct xfrm_algo_desc ealg_list[] = {
 {
-	.name = "cipher_null",
+	.name = "ecb(cipher_null)",
+	.compat = "cipher_null",
 	
 	.uinfo = {
 		.encr = {
@@ -135,7 +136,8 @@ static struct xfrm_algo_desc ealg_list[]
 	}
 },
 {
-	.name = "des",
+	.name = "cbc(des)",
+	.compat = "des",
 
 	.uinfo = {
 		.encr = {
@@ -152,7 +154,8 @@ static struct xfrm_algo_desc ealg_list[]
 	}
 },
 {
-	.name = "des3_ede",
+	.name = "cbc(des3_ede)",
+	.compat = "des3_ede",
 
 	.uinfo = {
 		.encr = {
@@ -169,7 +172,8 @@ static struct xfrm_algo_desc ealg_list[]
 	}
 },
 {
-	.name = "cast128",
+	.name = "cbc(cast128)",
+	.compat = "cast128",
 
 	.uinfo = {
 		.encr = {
@@ -186,7 +190,8 @@ static struct xfrm_algo_desc ealg_list[]
 	}
 },
 {
-	.name = "blowfish",
+	.name = "cbc(blowfish)",
+	.compat = "blowfish",
 
 	.uinfo = {
 		.encr = {
@@ -203,7 +208,8 @@ static struct xfrm_algo_desc ealg_list[]
 	}
 },
 {
-	.name = "aes",
+	.name = "cbc(aes)",
+	.compat = "aes",
 
 	.uinfo = {
 		.encr = {
@@ -220,7 +226,8 @@ static struct xfrm_algo_desc ealg_list[]
 	}
 },
 {
-        .name = "serpent",
+        .name = "cbc(serpent)",
+        .compat = "serpent",
 
         .uinfo = {
                 .encr = {
@@ -237,7 +244,8 @@ static struct xfrm_algo_desc ealg_list[]
         }
 },
 {
-        .name = "twofish",
+        .name = "cbc(twofish)",
+        .compat = "twofish",
                  
         .uinfo = {
                 .encr = {
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813122022</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:20:22-0400</timestampReceived><subject>[PATCH 13/16] [SUNRPC] GSS: Use block ciphers where applicable</subject><body>

[SUNRPC] GSS: Use block ciphers where applicable

This patch converts SUNRPC/GSS to use the new block cipher type where
applicable.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 include/linux/sunrpc/gss_krb5.h       |   19 +++++------
 include/linux/sunrpc/gss_spkm3.h      |    4 +-
 net/sunrpc/auth_gss/gss_krb5_crypto.c |   57 +++++++++++++++++++---------------
 net/sunrpc/auth_gss/gss_krb5_mech.c   |   22 ++++++-------
 net/sunrpc/auth_gss/gss_krb5_seqnum.c |    4 +-
 net/sunrpc/auth_gss/gss_krb5_wrap.c   |    4 +-
 net/sunrpc/auth_gss/gss_spkm3_mech.c  |   27 +++++++---------
 7 files changed, 72 insertions(+), 65 deletions(-)

diff --git a/include/linux/sunrpc/gss_krb5.h b/include/linux/sunrpc/gss_krb5.h
--- a/include/linux/sunrpc/gss_krb5.h
+++ b/include/linux/sunrpc/gss_krb5.h
@@ -46,8 +46,8 @@ struct krb5_ctx {
 	unsigned char		seed[16];
 	int			signalg;
 	int			sealalg;
-	struct crypto_tfm	*enc;
-	struct crypto_tfm	*seq;
+	struct crypto_blkcipher	*enc;
+	struct crypto_blkcipher	*seq;
 	s32			endtime;
 	u32			seq_send;
 	struct xdr_netobj	mech_used;
@@ -136,26 +136,27 @@ gss_unwrap_kerberos(struct gss_ctx *ctx_
 
 
 u32
-krb5_encrypt(struct crypto_tfm * key,
+krb5_encrypt(struct crypto_blkcipher *key,
 	     void *iv, void *in, void *out, int length);
 
 u32
-krb5_decrypt(struct crypto_tfm * key,
+krb5_decrypt(struct crypto_blkcipher *key,
 	     void *iv, void *in, void *out, int length); 
 
 int
-gss_encrypt_xdr_buf(struct crypto_tfm *tfm, struct xdr_buf *outbuf, int offset,
-		struct page **pages);
+gss_encrypt_xdr_buf(struct crypto_blkcipher *tfm, struct xdr_buf *outbuf,
+		    int offset, struct page **pages);
 
 int
-gss_decrypt_xdr_buf(struct crypto_tfm *tfm, struct xdr_buf *inbuf, int offset);
+gss_decrypt_xdr_buf(struct crypto_blkcipher *tfm, struct xdr_buf *inbuf,
+		    int offset);
 
 s32
-krb5_make_seq_num(struct crypto_tfm * key,
+krb5_make_seq_num(struct crypto_blkcipher *key,
 		int direction,
 		s32 seqnum, unsigned char *cksum, unsigned char *buf);
 
 s32
-krb5_get_seq_num(struct crypto_tfm * key,
+krb5_get_seq_num(struct crypto_blkcipher *key,
 	       unsigned char *cksum,
 	       unsigned char *buf, int *direction, s32 * seqnum);
diff --git a/include/linux/sunrpc/gss_spkm3.h b/include/linux/sunrpc/gss_spkm3.h
--- a/include/linux/sunrpc/gss_spkm3.h
+++ b/include/linux/sunrpc/gss_spkm3.h
@@ -19,9 +19,9 @@ struct spkm3_ctx {
 	unsigned int		req_flags ;
 	struct xdr_netobj	share_key;
 	int			conf_alg;
-	struct crypto_tfm*	derived_conf_key;
+	struct crypto_blkcipher	*derived_conf_key;
 	int			intg_alg;
-	struct crypto_tfm*	derived_integ_key;
+	struct crypto_blkcipher	*derived_integ_key;
 	int			keyestb_alg;   /* alg used to get share_key */
 	int			owf_alg;   /* one way function */
 };
diff --git a/net/sunrpc/auth_gss/gss_krb5_crypto.c b/net/sunrpc/auth_gss/gss_krb5_crypto.c
--- a/net/sunrpc/auth_gss/gss_krb5_crypto.c
+++ b/net/sunrpc/auth_gss/gss_krb5_crypto.c
@@ -49,7 +49,7 @@
 
 u32
 krb5_encrypt(
-	struct crypto_tfm *tfm,
+	struct crypto_blkcipher *tfm,
 	void * iv,
 	void * in,
 	void * out,
@@ -58,26 +58,27 @@ krb5_encrypt(
 	u32 ret = -EINVAL;
         struct scatterlist sg[1];
 	u8 local_iv[16] = {0};
+	struct blkcipher_desc desc = { .tfm = tfm, .info = local_iv };
 
 	dprintk("RPC:      krb5_encrypt: input data:\n");
 	print_hexl((u32 *)in, length, 0);
 
-	if (length % crypto_tfm_alg_blocksize(tfm) != 0)
+	if (length % crypto_blkcipher_blocksize(tfm) != 0)
 		goto out;
 
-	if (crypto_tfm_alg_ivsize(tfm) &gt; 16) {
+	if (crypto_blkcipher_ivsize(tfm) &gt; 16) {
 		dprintk("RPC:      gss_k5encrypt: tfm iv size to large %d\n",
-		         crypto_tfm_alg_ivsize(tfm));
+		         crypto_blkcipher_ivsize(tfm));
 		goto out;
 	}
 
 	if (iv)
-		memcpy(local_iv, iv, crypto_tfm_alg_ivsize(tfm));
+		memcpy(local_iv, iv, crypto_blkcipher_ivsize(tfm));
 
 	memcpy(out, in, length);
 	sg_set_buf(sg, out, length);
 
-	ret = crypto_cipher_encrypt_iv(tfm, sg, sg, length, local_iv);
+	ret = crypto_blkcipher_encrypt_iv(&amp;desc, sg, sg, length);
 
 	dprintk("RPC:      krb5_encrypt: output data:\n");
 	print_hexl((u32 *)out, length, 0);
@@ -90,7 +91,7 @@ EXPORT_SYMBOL(krb5_encrypt);
 
 u32
 krb5_decrypt(
-     struct crypto_tfm *tfm,
+     struct crypto_blkcipher *tfm,
      void * iv,
      void * in,
      void * out,
@@ -99,25 +100,26 @@ krb5_decrypt(
 	u32 ret = -EINVAL;
 	struct scatterlist sg[1];
 	u8 local_iv[16] = {0};
+	struct blkcipher_desc desc = { .tfm = tfm, .info = local_iv };
 
 	dprintk("RPC:      krb5_decrypt: input data:\n");
 	print_hexl((u32 *)in, length, 0);
 
-	if (length % crypto_tfm_alg_blocksize(tfm) != 0)
+	if (length % crypto_blkcipher_blocksize(tfm) != 0)
 		goto out;
 
-	if (crypto_tfm_alg_ivsize(tfm) &gt; 16) {
+	if (crypto_blkcipher_ivsize(tfm) &gt; 16) {
 		dprintk("RPC:      gss_k5decrypt: tfm iv size to large %d\n",
-			crypto_tfm_alg_ivsize(tfm));
+			crypto_blkcipher_ivsize(tfm));
 		goto out;
 	}
 	if (iv)
-		memcpy(local_iv,iv, crypto_tfm_alg_ivsize(tfm));
+		memcpy(local_iv,iv, crypto_blkcipher_ivsize(tfm));
 
 	memcpy(out, in, length);
 	sg_set_buf(sg, out, length);
 
-	ret = crypto_cipher_decrypt_iv(tfm, sg, sg, length, local_iv);
+	ret = crypto_blkcipher_decrypt_iv(&amp;desc, sg, sg, length);
 
 	dprintk("RPC:      krb5_decrypt: output_data:\n");
 	print_hexl((u32 *)out, length, 0);
@@ -240,7 +242,7 @@ EXPORT_SYMBOL(make_checksum);
 
 struct encryptor_desc {
 	u8 iv[8]; /* XXX hard-coded blocksize */
-	struct crypto_tfm *tfm;
+	struct blkcipher_desc desc;
 	int pos;
 	struct xdr_buf *outbuf;
 	struct page **pages;
@@ -285,8 +287,8 @@ encryptor(struct scatterlist *sg, void *
 	if (thislen == 0)
 		return 0;
 
-	ret = crypto_cipher_encrypt_iv(desc-&gt;tfm, desc-&gt;outfrags, desc-&gt;infrags,
-					thislen, desc-&gt;iv);
+	ret = crypto_blkcipher_encrypt_iv(&amp;desc-&gt;desc, desc-&gt;outfrags,
+					  desc-&gt;infrags, thislen);
 	if (ret)
 		return ret;
 	if (fraglen) {
@@ -305,16 +307,18 @@ encryptor(struct scatterlist *sg, void *
 }
 
 int
-gss_encrypt_xdr_buf(struct crypto_tfm *tfm, struct xdr_buf *buf, int offset,
-		struct page **pages)
+gss_encrypt_xdr_buf(struct crypto_blkcipher *tfm, struct xdr_buf *buf,
+		    int offset, struct page **pages)
 {
 	int ret;
 	struct encryptor_desc desc;
 
-	BUG_ON((buf-&gt;len - offset) % crypto_tfm_alg_blocksize(tfm) != 0);
+	BUG_ON((buf-&gt;len - offset) % crypto_blkcipher_blocksize(tfm) != 0);
 
 	memset(desc.iv, 0, sizeof(desc.iv));
-	desc.tfm = tfm;
+	desc.desc.tfm = tfm;
+	desc.desc.info = desc.iv;
+	desc.desc.flags = 0;
 	desc.pos = offset;
 	desc.outbuf = buf;
 	desc.pages = pages;
@@ -329,7 +333,7 @@ EXPORT_SYMBOL(gss_encrypt_xdr_buf);
 
 struct decryptor_desc {
 	u8 iv[8]; /* XXX hard-coded blocksize */
-	struct crypto_tfm *tfm;
+	struct blkcipher_desc desc;
 	struct scatterlist frags[4];
 	int fragno;
 	int fraglen;
@@ -355,8 +359,8 @@ decryptor(struct scatterlist *sg, void *
 	if (thislen == 0)
 		return 0;
 
-	ret = crypto_cipher_decrypt_iv(desc-&gt;tfm, desc-&gt;frags, desc-&gt;frags,
-					thislen, desc-&gt;iv);
+	ret = crypto_blkcipher_decrypt_iv(&amp;desc-&gt;desc, desc-&gt;frags,
+					  desc-&gt;frags, thislen);
 	if (ret)
 		return ret;
 	if (fraglen) {
@@ -373,15 +377,18 @@ decryptor(struct scatterlist *sg, void *
 }
 
 int
-gss_decrypt_xdr_buf(struct crypto_tfm *tfm, struct xdr_buf *buf, int offset)
+gss_decrypt_xdr_buf(struct crypto_blkcipher *tfm, struct xdr_buf *buf,
+		    int offset)
 {
 	struct decryptor_desc desc;
 
 	/* XXXJBF: */
-	BUG_ON((buf-&gt;len - offset) % crypto_tfm_alg_blocksize(tfm) != 0);
+	BUG_ON((buf-&gt;len - offset) % crypto_blkcipher_blocksize(tfm) != 0);
 
 	memset(desc.iv, 0, sizeof(desc.iv));
-	desc.tfm = tfm;
+	desc.desc.tfm = tfm;
+	desc.desc.info = desc.iv;
+	desc.desc.flags = 0;
 	desc.fragno = 0;
 	desc.fraglen = 0;
 	return process_xdr_buf(buf, offset, buf-&gt;len - offset, decryptor, &amp;desc);
diff --git a/net/sunrpc/auth_gss/gss_krb5_mech.c b/net/sunrpc/auth_gss/gss_krb5_mech.c
--- a/net/sunrpc/auth_gss/gss_krb5_mech.c
+++ b/net/sunrpc/auth_gss/gss_krb5_mech.c
@@ -78,10 +78,10 @@ simple_get_netobj(const void *p, const v
 }
 
 static inline const void *
-get_key(const void *p, const void *end, struct crypto_tfm **res)
+get_key(const void *p, const void *end, struct crypto_blkcipher **res)
 {
 	struct xdr_netobj	key;
-	int			alg, alg_mode;
+	int			alg;
 	char			*alg_name;
 
 	p = simple_get_bytes(p, end, &amp;alg, sizeof(alg));
@@ -93,18 +93,18 @@ get_key(const void *p, const void *end, 
 
 	switch (alg) {
 		case ENCTYPE_DES_CBC_RAW:
-			alg_name = "des";
-			alg_mode = CRYPTO_TFM_MODE_CBC;
+			alg_name = "cbc(des)";
 			break;
 		default:
 			printk("gss_kerberos_mech: unsupported algorithm %d\n", alg);
 			goto out_err_free_key;
 	}
-	if (!(*res = crypto_alloc_tfm(alg_name, alg_mode))) {
+	*res = crypto_alloc_blkcipher(alg_name, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(*res)) {
 		printk("gss_kerberos_mech: unable to initialize crypto algorithm %s\n", alg_name);
 		goto out_err_free_key;
 	}
-	if (crypto_cipher_setkey(*res, key.data, key.len)) {
+	if (crypto_blkcipher_setkey(*res, key.data, key.len)) {
 		printk("gss_kerberos_mech: error setting key for crypto algorithm %s\n", alg_name);
 		goto out_err_free_tfm;
 	}
@@ -113,7 +113,7 @@ get_key(const void *p, const void *end, 
 	return p;
 
 out_err_free_tfm:
-	crypto_free_tfm(*res);
+	crypto_free_blkcipher(*res);
 out_err_free_key:
 	kfree(key.data);
 	p = ERR_PTR(-EINVAL);
@@ -173,9 +173,9 @@ gss_import_sec_context_kerberos(const vo
 	return 0;
 
 out_err_free_key2:
-	crypto_free_tfm(ctx-&gt;seq);
+	crypto_free_blkcipher(ctx-&gt;seq);
 out_err_free_key1:
-	crypto_free_tfm(ctx-&gt;enc);
+	crypto_free_blkcipher(ctx-&gt;enc);
 out_err_free_mech:
 	kfree(ctx-&gt;mech_used.data);
 out_err_free_ctx:
@@ -188,8 +188,8 @@ static void
 gss_delete_sec_context_kerberos(void *internal_ctx) {
 	struct krb5_ctx *kctx = internal_ctx;
 
-	crypto_free_tfm(kctx-&gt;seq);
-	crypto_free_tfm(kctx-&gt;enc);
+	crypto_free_blkcipher(kctx-&gt;seq);
+	crypto_free_blkcipher(kctx-&gt;enc);
 	kfree(kctx-&gt;mech_used.data);
 	kfree(kctx);
 }
diff --git a/net/sunrpc/auth_gss/gss_krb5_seqnum.c b/net/sunrpc/auth_gss/gss_krb5_seqnum.c
--- a/net/sunrpc/auth_gss/gss_krb5_seqnum.c
+++ b/net/sunrpc/auth_gss/gss_krb5_seqnum.c
@@ -41,7 +41,7 @@
 #endif
 
 s32
-krb5_make_seq_num(struct crypto_tfm *key,
+krb5_make_seq_num(struct crypto_blkcipher *key,
 		int direction,
 		s32 seqnum,
 		unsigned char *cksum, unsigned char *buf)
@@ -62,7 +62,7 @@ krb5_make_seq_num(struct crypto_tfm *key
 }
 
 s32
-krb5_get_seq_num(struct crypto_tfm *key,
+krb5_get_seq_num(struct crypto_blkcipher *key,
 	       unsigned char *cksum,
 	       unsigned char *buf,
 	       int *direction, s32 * seqnum)
diff --git a/net/sunrpc/auth_gss/gss_krb5_wrap.c b/net/sunrpc/auth_gss/gss_krb5_wrap.c
--- a/net/sunrpc/auth_gss/gss_krb5_wrap.c
+++ b/net/sunrpc/auth_gss/gss_krb5_wrap.c
@@ -149,7 +149,7 @@ gss_wrap_kerberos(struct gss_ctx *ctx, i
 		goto out_err;
 	}
 
-	blocksize = crypto_tfm_alg_blocksize(kctx-&gt;enc);
+	blocksize = crypto_blkcipher_blocksize(kctx-&gt;enc);
 	gss_krb5_add_padding(buf, offset, blocksize);
 	BUG_ON((buf-&gt;len - offset) % blocksize);
 	plainlen = blocksize + buf-&gt;len - offset;
@@ -346,7 +346,7 @@ gss_unwrap_kerberos(struct gss_ctx *ctx,
 	/* Copy the data back to the right position.  XXX: Would probably be
 	 * better to copy and encrypt at the same time. */
 
-	blocksize = crypto_tfm_alg_blocksize(kctx-&gt;enc);
+	blocksize = crypto_blkcipher_blocksize(kctx-&gt;enc);
 	data_start = ptr + 22 + blocksize;
 	orig_start = buf-&gt;head[0].iov_base + offset;
 	data_len = (buf-&gt;head[0].iov_base + buf-&gt;head[0].iov_len) - data_start;
diff --git a/net/sunrpc/auth_gss/gss_spkm3_mech.c b/net/sunrpc/auth_gss/gss_spkm3_mech.c
--- a/net/sunrpc/auth_gss/gss_spkm3_mech.c
+++ b/net/sunrpc/auth_gss/gss_spkm3_mech.c
@@ -83,10 +83,11 @@ simple_get_netobj(const void *p, const v
 }
 
 static inline const void *
-get_key(const void *p, const void *end, struct crypto_tfm **res, int *resalg)
+get_key(const void *p, const void *end, struct crypto_blkcipher **res,
+	int *resalg)
 {
 	struct xdr_netobj	key = { 0 };
-	int			alg_mode,setkey = 0;
+	int			setkey = 0;
 	char			*alg_name;
 
 	p = simple_get_bytes(p, end, resalg, sizeof(*resalg));
@@ -98,14 +99,12 @@ get_key(const void *p, const void *end, 
 
 	switch (*resalg) {
 		case NID_des_cbc:
-			alg_name = "des";
-			alg_mode = CRYPTO_TFM_MODE_CBC;
+			alg_name = "cbc(des)";
 			setkey = 1;
 			break;
 		case NID_cast5_cbc:
 			/* XXXX here in name only, not used */
-			alg_name = "cast5";
-			alg_mode = CRYPTO_TFM_MODE_CBC;
+			alg_name = "cbc(cast5)";
 			setkey = 0; /* XXX will need to set to 1 */
 			break;
 		case NID_md5:
@@ -113,19 +112,19 @@ get_key(const void *p, const void *end, 
 				dprintk("RPC: SPKM3 get_key: NID_md5 zero Key length\n");
 			}
 			alg_name = "md5";
-			alg_mode = 0;
 			setkey = 0;
 			break;
 		default:
 			dprintk("gss_spkm3_mech: unsupported algorithm %d\n", *resalg);
 			goto out_err_free_key;
 	}
-	if (!(*res = crypto_alloc_tfm(alg_name, alg_mode))) {
+	*res = crypto_alloc_blkcipher(alg_name, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(*res)) {
 		printk("gss_spkm3_mech: unable to initialize crypto algorthm %s\n", alg_name);
 		goto out_err_free_key;
 	}
 	if (setkey) {
-		if (crypto_cipher_setkey(*res, key.data, key.len)) {
+		if (crypto_blkcipher_setkey(*res, key.data, key.len)) {
 			printk("gss_spkm3_mech: error setting key for crypto algorthm %s\n", alg_name);
 			goto out_err_free_tfm;
 		}
@@ -136,7 +135,7 @@ get_key(const void *p, const void *end, 
 	return p;
 
 out_err_free_tfm:
-	crypto_free_tfm(*res);
+	crypto_free_blkcipher(*res);
 out_err_free_key:
 	if(key.len &gt; 0)
 		kfree(key.data);
@@ -205,9 +204,9 @@ gss_import_sec_context_spkm3(const void 
 	return 0;
 
 out_err_free_key2:
-	crypto_free_tfm(ctx-&gt;derived_integ_key);
+	crypto_free_blkcipher(ctx-&gt;derived_integ_key);
 out_err_free_key1:
-	crypto_free_tfm(ctx-&gt;derived_conf_key);
+	crypto_free_blkcipher(ctx-&gt;derived_conf_key);
 out_err_free_s_key:
 	kfree(ctx-&gt;share_key.data);
 out_err_free_mech:
@@ -224,8 +223,8 @@ static void
 gss_delete_sec_context_spkm3(void *internal_ctx) {
 	struct spkm3_ctx *sctx = internal_ctx;
 
-	crypto_free_tfm(sctx-&gt;derived_integ_key);
-	crypto_free_tfm(sctx-&gt;derived_conf_key);
+	crypto_free_blkcipher(sctx-&gt;derived_integ_key);
+	crypto_free_blkcipher(sctx-&gt;derived_conf_key);
 	kfree(sctx-&gt;share_key.data);
 	kfree(sctx-&gt;mech_used.data);
 	kfree(sctx);
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813122024</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:20:24-0400</timestampReceived><subject>[PATCH 14/16] [CRYPTO] users: Use block ciphers where applicable</subject><body>

[CRYPTO] users: Use block ciphers where applicable

This patch converts all remaining users to use the new block cipher type
where applicable.  It also changes all simple cipher operations to use
the new encrypt_one/decrypt_one interface.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 drivers/net/ppp_mppe.c               |   32 +++++++++++++++++++-------------
 drivers/net/wireless/airo.c          |   18 +++++++++---------
 net/ieee80211/ieee80211_crypt_ccmp.c |   28 +++++++++-------------------
 net/ieee80211/ieee80211_crypt_tkip.c |   34 ++++++++++++++++++++++------------
 net/ieee80211/ieee80211_crypt_wep.c  |   25 ++++++++++++++-----------
 5 files changed, 73 insertions(+), 64 deletions(-)

diff --git a/drivers/net/ppp_mppe.c b/drivers/net/ppp_mppe.c
--- a/drivers/net/ppp_mppe.c
+++ b/drivers/net/ppp_mppe.c
@@ -43,6 +43,7 @@
  *                    deprecated in 2.6
  */
 
+#include &lt;linux/err.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/version.h&gt;
@@ -95,7 +96,7 @@ static inline void sha_pad_init(struct s
  * State for an MPPE (de)compressor.
  */
 struct ppp_mppe_state {
-	struct crypto_tfm *arc4;
+	struct crypto_blkcipher *arc4;
 	struct crypto_tfm *sha1;
 	unsigned char *sha1_digest;
 	unsigned char master_key[MPPE_MAX_KEY_LEN];
@@ -156,14 +157,15 @@ static void mppe_rekey(struct ppp_mppe_s
 {
 	unsigned char InterimKey[MPPE_MAX_KEY_LEN];
 	struct scatterlist sg_in[1], sg_out[1];
+	struct blkcipher_desc desc = { .tfm = state-&gt;arc4 };
 
 	get_new_key_from_sha(state, InterimKey);
 	if (!initial_key) {
-		crypto_cipher_setkey(state-&gt;arc4, InterimKey, state-&gt;keylen);
+		crypto_blkcipher_setkey(state-&gt;arc4, InterimKey, state-&gt;keylen);
 		setup_sg(sg_in, InterimKey, state-&gt;keylen);
 		setup_sg(sg_out, state-&gt;session_key, state-&gt;keylen);
-		if (crypto_cipher_encrypt(state-&gt;arc4, sg_out, sg_in,
-				      state-&gt;keylen) != 0) {
+		if (crypto_blkcipher_encrypt(&amp;desc, sg_out, sg_in,
+					     state-&gt;keylen) != 0) {
     		    printk(KERN_WARNING "mppe_rekey: cipher_encrypt failed\n");
 		}
 	} else {
@@ -175,7 +177,7 @@ static void mppe_rekey(struct ppp_mppe_s
 		state-&gt;session_key[1] = 0x26;
 		state-&gt;session_key[2] = 0x9e;
 	}
-	crypto_cipher_setkey(state-&gt;arc4, state-&gt;session_key, state-&gt;keylen);
+	crypto_blkcipher_setkey(state-&gt;arc4, state-&gt;session_key, state-&gt;keylen);
 }
 
 /*
@@ -196,9 +198,11 @@ static void *mppe_alloc(unsigned char *o
 
 	memset(state, 0, sizeof(*state));
 
-	state-&gt;arc4 = crypto_alloc_tfm("arc4", 0);
-	if (!state-&gt;arc4)
+	state-&gt;arc4 = crypto_alloc_blkcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(state-&gt;arc4)) {
+		state-&gt;arc4 = NULL;
 		goto out_free;
+	}
 
 	state-&gt;sha1 = crypto_alloc_tfm("sha1", 0);
 	if (!state-&gt;sha1)
@@ -231,7 +235,7 @@ static void *mppe_alloc(unsigned char *o
 	    if (state-&gt;sha1)
 		crypto_free_tfm(state-&gt;sha1);
 	    if (state-&gt;arc4)
-		crypto_free_tfm(state-&gt;arc4);
+		crypto_free_blkcipher(state-&gt;arc4);
 	    kfree(state);
 	out:
 	return NULL;
@@ -249,7 +253,7 @@ static void mppe_free(void *arg)
 	    if (state-&gt;sha1)
 		crypto_free_tfm(state-&gt;sha1);
 	    if (state-&gt;arc4)
-		crypto_free_tfm(state-&gt;arc4);
+		crypto_free_blkcipher(state-&gt;arc4);
 	    kfree(state);
 	}
 }
@@ -356,6 +360,7 @@ mppe_compress(void *arg, unsigned char *
 	      int isize, int osize)
 {
 	struct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;
+	struct blkcipher_desc desc = { .tfm = state-&gt;arc4 };
 	int proto;
 	struct scatterlist sg_in[1], sg_out[1];
 
@@ -413,7 +418,7 @@ mppe_compress(void *arg, unsigned char *
 	/* Encrypt packet */
 	setup_sg(sg_in, ibuf, isize);
 	setup_sg(sg_out, obuf, osize);
-	if (crypto_cipher_encrypt(state-&gt;arc4, sg_out, sg_in, isize) != 0) {
+	if (crypto_blkcipher_encrypt(&amp;desc, sg_out, sg_in, isize) != 0) {
 		printk(KERN_DEBUG "crypto_cypher_encrypt failed\n");
 		return -1;
 	}
@@ -462,6 +467,7 @@ mppe_decompress(void *arg, unsigned char
 		int osize)
 {
 	struct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;
+	struct blkcipher_desc desc = { .tfm = state-&gt;arc4 };
 	unsigned ccount;
 	int flushed = MPPE_BITS(ibuf) &amp; MPPE_BIT_FLUSHED;
 	int sanity = 0;
@@ -599,7 +605,7 @@ mppe_decompress(void *arg, unsigned char
 	 */
 	setup_sg(sg_in, ibuf, 1);
 	setup_sg(sg_out, obuf, 1);
-	if (crypto_cipher_decrypt(state-&gt;arc4, sg_out, sg_in, 1) != 0) {
+	if (crypto_blkcipher_decrypt(&amp;desc, sg_out, sg_in, 1) != 0) {
 		printk(KERN_DEBUG "crypto_cypher_decrypt failed\n");
 		return DECOMP_ERROR;
 	}
@@ -619,7 +625,7 @@ mppe_decompress(void *arg, unsigned char
 	/* And finally, decrypt the rest of the packet. */
 	setup_sg(sg_in, ibuf + 1, isize - 1);
 	setup_sg(sg_out, obuf + 1, osize - 1);
-	if (crypto_cipher_decrypt(state-&gt;arc4, sg_out, sg_in, isize - 1) != 0) {
+	if (crypto_blkcipher_decrypt(&amp;desc, sg_out, sg_in, isize - 1)) {
 		printk(KERN_DEBUG "crypto_cypher_decrypt failed\n");
 		return DECOMP_ERROR;
 	}
@@ -694,7 +700,7 @@ static struct compressor ppp_mppe = {
 static int __init ppp_mppe_init(void)
 {
 	int answer;
-	if (!(crypto_alg_available("arc4", 0) &amp;&amp;
+	if (!(crypto_alg_available("ecb(arc4)", 0) &amp;&amp;
 	      crypto_alg_available("sha1", 0)))
 		return -ENODEV;
 
diff --git a/drivers/net/wireless/airo.c b/drivers/net/wireless/airo.c
--- a/drivers/net/wireless/airo.c
+++ b/drivers/net/wireless/airo.c
@@ -1203,7 +1203,7 @@ struct airo_info {
 	struct iw_spy_data	spy_data;
 	struct iw_public_data	wireless_data;
 	/* MIC stuff */
-	struct crypto_tfm	*tfm;
+	struct crypto_cipher	*tfm;
 	mic_module		mod[2];
 	mic_statistics		micstats;
 	HostRxDesc rxfids[MPI_MAX_FIDS]; // rx/tx/config MPI350 descriptors
@@ -1271,7 +1271,8 @@ static int flashrestart(struct airo_info
 
 static int RxSeqValid (struct airo_info *ai,miccntx *context,int mcast,u32 micSeq);
 static void MoveWindow(miccntx *context, u32 micSeq);
-static void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen, struct crypto_tfm *);
+static void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen,
+			   struct crypto_cipher *tfm);
 static void emmh32_init(emmh32_context *context);
 static void emmh32_update(emmh32_context *context, u8 *pOctets, int len);
 static void emmh32_final(emmh32_context *context, u8 digest[4]);
@@ -1339,7 +1340,7 @@ static int micsetup(struct airo_info *ai
 	int i;
 
 	if (ai-&gt;tfm == NULL)
-	        ai-&gt;tfm = crypto_alloc_tfm("aes", CRYPTO_TFM_REQ_MAY_SLEEP);
+	        ai-&gt;tfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);
 
         if (ai-&gt;tfm == NULL) {
                 airo_print_err(ai-&gt;dev-&gt;name, "failed to load transform for AES");
@@ -1608,7 +1609,8 @@ static void MoveWindow(miccntx *context,
 static unsigned char aes_counter[16];
 
 /* expand the key to fill the MMH coefficient array */
-static void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen, struct crypto_tfm *tfm)
+static void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen,
+			   struct crypto_cipher *tfm)
 {
   /* take the keying material, expand if necessary, truncate at 16-bytes */
   /* run through AES counter mode to generate context-&gt;coeff[] */
@@ -1616,7 +1618,6 @@ static void emmh32_setseed(emmh32_contex
 	int i,j;
 	u32 counter;
 	u8 *cipher, plain[16];
-	struct scatterlist sg[1];
 
 	crypto_cipher_setkey(tfm, pkey, 16);
 	counter = 0;
@@ -1627,9 +1628,8 @@ static void emmh32_setseed(emmh32_contex
 		aes_counter[12] = (u8)(counter &gt;&gt; 24);
 		counter++;
 		memcpy (plain, aes_counter, 16);
-		sg_set_buf(sg, plain, 16);
-		crypto_cipher_encrypt(tfm, sg, sg, 16);
-		cipher = kmap(sg-&gt;page) + sg-&gt;offset;
+		crypto_cipher_encrypt_one(tfm, plain, plain);
+		cipher = plain;
 		for (j=0; (j&lt;16) &amp;&amp; (i&lt; (sizeof(context-&gt;coeff)/sizeof(context-&gt;coeff[0]))); ) {
 			context-&gt;coeff[i++] = ntohl(*(u32 *)&amp;cipher[j]);
 			j += 4;
@@ -2432,7 +2432,7 @@ void stop_airo_card( struct net_device *
 				ai-&gt;shared, ai-&gt;shared_dma);
 		}
         }
-	crypto_free_tfm(ai-&gt;tfm);
+	crypto_free_cipher(ai-&gt;tfm);
 	del_airo_dev( dev );
 	free_netdev( dev );
 }
diff --git a/net/ieee80211/ieee80211_crypt_ccmp.c b/net/ieee80211/ieee80211_crypt_ccmp.c
--- a/net/ieee80211/ieee80211_crypt_ccmp.c
+++ b/net/ieee80211/ieee80211_crypt_ccmp.c
@@ -48,7 +48,7 @@ struct ieee80211_ccmp_data {
 
 	int key_idx;
 
-	struct crypto_tfm *tfm;
+	struct crypto_cipher *tfm;
 
 	/* scratch buffers for virt_to_page() (crypto API) */
 	u8 tx_b0[AES_BLOCK_LEN], tx_b[AES_BLOCK_LEN],
@@ -56,20 +56,10 @@ struct ieee80211_ccmp_data {
 	u8 rx_b0[AES_BLOCK_LEN], rx_b[AES_BLOCK_LEN], rx_a[AES_BLOCK_LEN];
 };
 
-static void ieee80211_ccmp_aes_encrypt(struct crypto_tfm *tfm,
-				       const u8 pt[16], u8 ct[16])
+static inline void ieee80211_ccmp_aes_encrypt(struct crypto_cipher *tfm,
+					      const u8 pt[16], u8 ct[16])
 {
-	struct scatterlist src, dst;
-
-	src.page = virt_to_page(pt);
-	src.offset = offset_in_page(pt);
-	src.length = AES_BLOCK_LEN;
-
-	dst.page = virt_to_page(ct);
-	dst.offset = offset_in_page(ct);
-	dst.length = AES_BLOCK_LEN;
-
-	crypto_cipher_encrypt(tfm, &amp;dst, &amp;src, AES_BLOCK_LEN);
+	crypto_cipher_encrypt_one(tfm, ct, pt);
 }
 
 static void *ieee80211_ccmp_init(int key_idx)
@@ -82,7 +72,7 @@ static void *ieee80211_ccmp_init(int key
 	memset(priv, 0, sizeof(*priv));
 	priv-&gt;key_idx = key_idx;
 
-	priv-&gt;tfm = crypto_alloc_tfm("aes", 0);
+	priv-&gt;tfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);
 	if (priv-&gt;tfm == NULL) {
 		printk(KERN_DEBUG "ieee80211_crypt_ccmp: could not allocate "
 		       "crypto API aes\n");
@@ -94,7 +84,7 @@ static void *ieee80211_ccmp_init(int key
       fail:
 	if (priv) {
 		if (priv-&gt;tfm)
-			crypto_free_tfm(priv-&gt;tfm);
+			crypto_free_cipher(priv-&gt;tfm);
 		kfree(priv);
 	}
 
@@ -105,7 +95,7 @@ static void ieee80211_ccmp_deinit(void *
 {
 	struct ieee80211_ccmp_data *_priv = priv;
 	if (_priv &amp;&amp; _priv-&gt;tfm)
-		crypto_free_tfm(_priv-&gt;tfm);
+		crypto_free_cipher(_priv-&gt;tfm);
 	kfree(priv);
 }
 
@@ -116,7 +106,7 @@ static inline void xor_block(u8 * b, u8 
 		b[i] ^= a[i];
 }
 
-static void ccmp_init_blocks(struct crypto_tfm *tfm,
+static void ccmp_init_blocks(struct crypto_cipher *tfm,
 			     struct ieee80211_hdr_4addr *hdr,
 			     u8 * pn, size_t dlen, u8 * b0, u8 * auth, u8 * s0)
 {
@@ -378,7 +368,7 @@ static int ieee80211_ccmp_set_key(void *
 {
 	struct ieee80211_ccmp_data *data = priv;
 	int keyidx;
-	struct crypto_tfm *tfm = data-&gt;tfm;
+	struct crypto_cipher *tfm = data-&gt;tfm;
 
 	keyidx = data-&gt;key_idx;
 	memset(data, 0, sizeof(*data));
diff --git a/net/ieee80211/ieee80211_crypt_tkip.c b/net/ieee80211/ieee80211_crypt_tkip.c
--- a/net/ieee80211/ieee80211_crypt_tkip.c
+++ b/net/ieee80211/ieee80211_crypt_tkip.c
@@ -9,6 +9,7 @@
  * more details.
  */
 
+#include &lt;linux/err.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/slab.h&gt;
@@ -52,7 +53,7 @@ struct ieee80211_tkip_data {
 
 	int key_idx;
 
-	struct crypto_tfm *tfm_arc4;
+	struct crypto_blkcipher *tfm_arc4;
 	struct crypto_tfm *tfm_michael;
 
 	/* scratch buffers for virt_to_page() (crypto API) */
@@ -85,10 +86,12 @@ static void *ieee80211_tkip_init(int key
 
 	priv-&gt;key_idx = key_idx;
 
-	priv-&gt;tfm_arc4 = crypto_alloc_tfm("arc4", 0);
-	if (priv-&gt;tfm_arc4 == NULL) {
+	priv-&gt;tfm_arc4 = crypto_alloc_blkcipher("ecb(arc4)", 0,
+						CRYPTO_ALG_ASYNC);
+	if (IS_ERR(priv-&gt;tfm_arc4)) {
 		printk(KERN_DEBUG "ieee80211_crypt_tkip: could not allocate "
 		       "crypto API arc4\n");
+		priv-&gt;tfm_arc4 = NULL;
 		goto fail;
 	}
 
@@ -106,7 +109,7 @@ static void *ieee80211_tkip_init(int key
 		if (priv-&gt;tfm_michael)
 			crypto_free_tfm(priv-&gt;tfm_michael);
 		if (priv-&gt;tfm_arc4)
-			crypto_free_tfm(priv-&gt;tfm_arc4);
+			crypto_free_blkcipher(priv-&gt;tfm_arc4);
 		kfree(priv);
 	}
 
@@ -119,7 +122,7 @@ static void ieee80211_tkip_deinit(void *
 	if (_priv &amp;&amp; _priv-&gt;tfm_michael)
 		crypto_free_tfm(_priv-&gt;tfm_michael);
 	if (_priv &amp;&amp; _priv-&gt;tfm_arc4)
-		crypto_free_tfm(_priv-&gt;tfm_arc4);
+		crypto_free_blkcipher(_priv-&gt;tfm_arc4);
 	kfree(priv);
 }
 
@@ -318,6 +321,7 @@ static int ieee80211_tkip_hdr(struct sk_
 static int ieee80211_tkip_encrypt(struct sk_buff *skb, int hdr_len, void *priv)
 {
 	struct ieee80211_tkip_data *tkey = priv;
+	struct blkcipher_desc desc = { .tfm = tkey-&gt;tfm_arc4 };
 	int len;
 	u8 rc4key[16], *pos, *icv;
 	u32 crc;
@@ -351,18 +355,17 @@ static int ieee80211_tkip_encrypt(struct
 	icv[2] = crc &gt;&gt; 16;
 	icv[3] = crc &gt;&gt; 24;
 
-	crypto_cipher_setkey(tkey-&gt;tfm_arc4, rc4key, 16);
+	crypto_blkcipher_setkey(tkey-&gt;tfm_arc4, rc4key, 16);
 	sg.page = virt_to_page(pos);
 	sg.offset = offset_in_page(pos);
 	sg.length = len + 4;
-	crypto_cipher_encrypt(tkey-&gt;tfm_arc4, &amp;sg, &amp;sg, len + 4);
-
-	return 0;
+	return crypto_blkcipher_encrypt(&amp;desc, &amp;sg, &amp;sg, len + 4);
 }
 
 static int ieee80211_tkip_decrypt(struct sk_buff *skb, int hdr_len, void *priv)
 {
 	struct ieee80211_tkip_data *tkey = priv;
+	struct blkcipher_desc desc = { .tfm = tkey-&gt;tfm_arc4 };
 	u8 rc4key[16];
 	u8 keyidx, *pos;
 	u32 iv32;
@@ -434,11 +437,18 @@ static int ieee80211_tkip_decrypt(struct
 
 	plen = skb-&gt;len - hdr_len - 12;
 
-	crypto_cipher_setkey(tkey-&gt;tfm_arc4, rc4key, 16);
+	crypto_blkcipher_setkey(tkey-&gt;tfm_arc4, rc4key, 16);
 	sg.page = virt_to_page(pos);
 	sg.offset = offset_in_page(pos);
 	sg.length = plen + 4;
-	crypto_cipher_decrypt(tkey-&gt;tfm_arc4, &amp;sg, &amp;sg, plen + 4);
+	if (crypto_blkcipher_decrypt(&amp;desc, &amp;sg, &amp;sg, plen + 4)) {
+		if (net_ratelimit()) {
+			printk(KERN_DEBUG ": TKIP: failed to decrypt "
+			       "received packet from " MAC_FMT "\n",
+			       MAC_ARG(hdr-&gt;addr2));
+		}
+		return -7;
+	}
 
 	crc = ~crc32_le(~0, pos, plen);
 	icv[0] = crc;
@@ -619,7 +629,7 @@ static int ieee80211_tkip_set_key(void *
 	struct ieee80211_tkip_data *tkey = priv;
 	int keyidx;
 	struct crypto_tfm *tfm = tkey-&gt;tfm_michael;
-	struct crypto_tfm *tfm2 = tkey-&gt;tfm_arc4;
+	struct crypto_blkcipher *tfm2 = tkey-&gt;tfm_arc4;
 
 	keyidx = tkey-&gt;key_idx;
 	memset(tkey, 0, sizeof(*tkey));
diff --git a/net/ieee80211/ieee80211_crypt_wep.c b/net/ieee80211/ieee80211_crypt_wep.c
--- a/net/ieee80211/ieee80211_crypt_wep.c
+++ b/net/ieee80211/ieee80211_crypt_wep.c
@@ -9,6 +9,7 @@
  * more details.
  */
 
+#include &lt;linux/err.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/slab.h&gt;
@@ -32,7 +33,7 @@ struct prism2_wep_data {
 	u8 key[WEP_KEY_LEN + 1];
 	u8 key_len;
 	u8 key_idx;
-	struct crypto_tfm *tfm;
+	struct crypto_blkcipher *tfm;
 };
 
 static void *prism2_wep_init(int keyidx)
@@ -45,10 +46,11 @@ static void *prism2_wep_init(int keyidx)
 	memset(priv, 0, sizeof(*priv));
 	priv-&gt;key_idx = keyidx;
 
-	priv-&gt;tfm = crypto_alloc_tfm("arc4", 0);
-	if (priv-&gt;tfm == NULL) {
+	priv-&gt;tfm = crypto_alloc_blkcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(priv-&gt;tfm)) {
 		printk(KERN_DEBUG "ieee80211_crypt_wep: could not allocate "
 		       "crypto API arc4\n");
+		priv-&gt;tfm = NULL;
 		goto fail;
 	}
 
@@ -60,7 +62,7 @@ static void *prism2_wep_init(int keyidx)
       fail:
 	if (priv) {
 		if (priv-&gt;tfm)
-			crypto_free_tfm(priv-&gt;tfm);
+			crypto_free_blkcipher(priv-&gt;tfm);
 		kfree(priv);
 	}
 	return NULL;
@@ -70,7 +72,7 @@ static void prism2_wep_deinit(void *priv
 {
 	struct prism2_wep_data *_priv = priv;
 	if (_priv &amp;&amp; _priv-&gt;tfm)
-		crypto_free_tfm(_priv-&gt;tfm);
+		crypto_free_blkcipher(_priv-&gt;tfm);
 	kfree(priv);
 }
 
@@ -121,6 +123,7 @@ static int prism2_wep_build_iv(struct sk
 static int prism2_wep_encrypt(struct sk_buff *skb, int hdr_len, void *priv)
 {
 	struct prism2_wep_data *wep = priv;
+	struct blkcipher_desc desc = { .tfm = wep-&gt;tfm };
 	u32 crc, klen, len;
 	u8 *pos, *icv;
 	struct scatterlist sg;
@@ -152,13 +155,11 @@ static int prism2_wep_encrypt(struct sk_
 	icv[2] = crc &gt;&gt; 16;
 	icv[3] = crc &gt;&gt; 24;
 
-	crypto_cipher_setkey(wep-&gt;tfm, key, klen);
+	crypto_blkcipher_setkey(wep-&gt;tfm, key, klen);
 	sg.page = virt_to_page(pos);
 	sg.offset = offset_in_page(pos);
 	sg.length = len + 4;
-	crypto_cipher_encrypt(wep-&gt;tfm, &amp;sg, &amp;sg, len + 4);
-
-	return 0;
+	return crypto_blkcipher_encrypt(&amp;desc, &amp;sg, &amp;sg, len + 4);
 }
 
 /* Perform WEP decryption on given buffer. Buffer includes whole WEP part of
@@ -171,6 +172,7 @@ static int prism2_wep_encrypt(struct sk_
 static int prism2_wep_decrypt(struct sk_buff *skb, int hdr_len, void *priv)
 {
 	struct prism2_wep_data *wep = priv;
+	struct blkcipher_desc desc = { .tfm = wep-&gt;tfm };
 	u32 crc, klen, plen;
 	u8 key[WEP_KEY_LEN + 3];
 	u8 keyidx, *pos, icv[4];
@@ -195,11 +197,12 @@ static int prism2_wep_decrypt(struct sk_
 	/* Apply RC4 to data and compute CRC32 over decrypted data */
 	plen = skb-&gt;len - hdr_len - 8;
 
-	crypto_cipher_setkey(wep-&gt;tfm, key, klen);
+	crypto_blkcipher_setkey(wep-&gt;tfm, key, klen);
 	sg.page = virt_to_page(pos);
 	sg.offset = offset_in_page(pos);
 	sg.length = plen + 4;
-	crypto_cipher_decrypt(wep-&gt;tfm, &amp;sg, &amp;sg, plen + 4);
+	if (crypto_blkcipher_decrypt(&amp;desc, &amp;sg, &amp;sg, plen + 4))
+		return -7;
 
 	crc = ~crc32_le(~0, pos, plen);
 	icv[0] = crc;
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813122026</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:20:26-0400</timestampReceived><subject>[PATCH 15/16] [CRYPTO] drivers: Remove obsolete block cipher operations</subject><body>

[CRYPTO] drivers: Remove obsolete block cipher operations

This patch removes obsolete block operations of the simple cipher type
from drivers.  These were preserved so that existing users can make a
smooth transition.  Now that the transition is complete, they are no
longer needed.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 arch/s390/crypto/aes_s390.c  |  112 -----------------------
 arch/s390/crypto/des_s390.c  |  203 -------------------------------------------
 drivers/crypto/padlock-aes.c |   44 ---------
 3 files changed, 359 deletions(-)

diff --git a/arch/s390/crypto/aes_s390.c b/arch/s390/crypto/aes_s390.c
--- a/arch/s390/crypto/aes_s390.c
+++ b/arch/s390/crypto/aes_s390.c
@@ -113,114 +113,6 @@ static void aes_decrypt(struct crypto_tf
 	}
 }
 
-static unsigned int aes_encrypt_ecb(const struct cipher_desc *desc, u8 *out,
-				    const u8 *in, unsigned int nbytes)
-{
-	struct s390_aes_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(AES_BLOCK_SIZE - 1);
-
-	switch (sctx-&gt;key_len) {
-	case 16:
-		ret = crypt_s390_km(KM_AES_128_ENCRYPT, &amp;sctx-&gt;key, out, in, nbytes);
-		BUG_ON((ret &lt; 0) || (ret != nbytes));
-		break;
-	case 24:
-		ret = crypt_s390_km(KM_AES_192_ENCRYPT, &amp;sctx-&gt;key, out, in, nbytes);
-		BUG_ON((ret &lt; 0) || (ret != nbytes));
-		break;
-	case 32:
-		ret = crypt_s390_km(KM_AES_256_ENCRYPT, &amp;sctx-&gt;key, out, in, nbytes);
-		BUG_ON((ret &lt; 0) || (ret != nbytes));
-		break;
-	}
-	return nbytes;
-}
-
-static unsigned int aes_decrypt_ecb(const struct cipher_desc *desc, u8 *out,
-				    const u8 *in, unsigned int nbytes)
-{
-	struct s390_aes_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(AES_BLOCK_SIZE - 1);
-
-	switch (sctx-&gt;key_len) {
-	case 16:
-		ret = crypt_s390_km(KM_AES_128_DECRYPT, &amp;sctx-&gt;key, out, in, nbytes);
-		BUG_ON((ret &lt; 0) || (ret != nbytes));
-		break;
-	case 24:
-		ret = crypt_s390_km(KM_AES_192_DECRYPT, &amp;sctx-&gt;key, out, in, nbytes);
-		BUG_ON((ret &lt; 0) || (ret != nbytes));
-		break;
-	case 32:
-		ret = crypt_s390_km(KM_AES_256_DECRYPT, &amp;sctx-&gt;key, out, in, nbytes);
-		BUG_ON((ret &lt; 0) || (ret != nbytes));
-		break;
-	}
-	return nbytes;
-}
-
-static unsigned int aes_encrypt_cbc(const struct cipher_desc *desc, u8 *out,
-				    const u8 *in, unsigned int nbytes)
-{
-	struct s390_aes_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(AES_BLOCK_SIZE - 1);
-
-	memcpy(&amp;sctx-&gt;iv, desc-&gt;info, AES_BLOCK_SIZE);
-	switch (sctx-&gt;key_len) {
-	case 16:
-		ret = crypt_s390_kmc(KMC_AES_128_ENCRYPT, &amp;sctx-&gt;iv, out, in, nbytes);
-		BUG_ON((ret &lt; 0) || (ret != nbytes));
-		break;
-	case 24:
-		ret = crypt_s390_kmc(KMC_AES_192_ENCRYPT, &amp;sctx-&gt;iv, out, in, nbytes);
-		BUG_ON((ret &lt; 0) || (ret != nbytes));
-		break;
-	case 32:
-		ret = crypt_s390_kmc(KMC_AES_256_ENCRYPT, &amp;sctx-&gt;iv, out, in, nbytes);
-		BUG_ON((ret &lt; 0) || (ret != nbytes));
-		break;
-	}
-	memcpy(desc-&gt;info, &amp;sctx-&gt;iv, AES_BLOCK_SIZE);
-
-	return nbytes;
-}
-
-static unsigned int aes_decrypt_cbc(const struct cipher_desc *desc, u8 *out,
-				    const u8 *in, unsigned int nbytes)
-{
-	struct s390_aes_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(AES_BLOCK_SIZE - 1);
-
-	memcpy(&amp;sctx-&gt;iv, desc-&gt;info, AES_BLOCK_SIZE);
-	switch (sctx-&gt;key_len) {
-	case 16:
-		ret = crypt_s390_kmc(KMC_AES_128_DECRYPT, &amp;sctx-&gt;iv, out, in, nbytes);
-		BUG_ON((ret &lt; 0) || (ret != nbytes));
-		break;
-	case 24:
-		ret = crypt_s390_kmc(KMC_AES_192_DECRYPT, &amp;sctx-&gt;iv, out, in, nbytes);
-		BUG_ON((ret &lt; 0) || (ret != nbytes));
-		break;
-	case 32:
-		ret = crypt_s390_kmc(KMC_AES_256_DECRYPT, &amp;sctx-&gt;iv, out, in, nbytes);
-		BUG_ON((ret &lt; 0) || (ret != nbytes));
-		break;
-	}
-	return nbytes;
-}
-
 
 static struct crypto_alg aes_alg = {
 	.cra_name		=	"aes",
@@ -238,10 +130,6 @@ static struct crypto_alg aes_alg = {
 			.cia_setkey		=	aes_set_key,
 			.cia_encrypt		=	aes_encrypt,
 			.cia_decrypt		=	aes_decrypt,
-			.cia_encrypt_ecb	=	aes_encrypt_ecb,
-			.cia_decrypt_ecb	=	aes_decrypt_ecb,
-			.cia_encrypt_cbc	=	aes_encrypt_cbc,
-			.cia_decrypt_cbc	=	aes_decrypt_cbc,
 		}
 	}
 };
diff --git a/arch/s390/crypto/des_s390.c b/arch/s390/crypto/des_s390.c
--- a/arch/s390/crypto/des_s390.c
+++ b/arch/s390/crypto/des_s390.c
@@ -73,67 +73,6 @@ static void des_decrypt(struct crypto_tf
 	crypt_s390_km(KM_DEA_DECRYPT, dctx-&gt;key, out, in, DES_BLOCK_SIZE);
 }
 
-static unsigned int des_encrypt_ecb(const struct cipher_desc *desc, u8 *out,
-				    const u8 *in, unsigned int nbytes)
-{
-	struct crypt_s390_des_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(DES_BLOCK_SIZE - 1);
-	ret = crypt_s390_km(KM_DEA_ENCRYPT, sctx-&gt;key, out, in, nbytes);
-	BUG_ON((ret &lt; 0) || (ret != nbytes));
-
-	return nbytes;
-}
-
-static unsigned int des_decrypt_ecb(const struct cipher_desc *desc, u8 *out,
-				    const u8 *in, unsigned int nbytes)
-{
-	struct crypt_s390_des_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(DES_BLOCK_SIZE - 1);
-	ret = crypt_s390_km(KM_DEA_DECRYPT, sctx-&gt;key, out, in, nbytes);
-	BUG_ON((ret &lt; 0) || (ret != nbytes));
-
-	return nbytes;
-}
-
-static unsigned int des_encrypt_cbc(const struct cipher_desc *desc, u8 *out,
-				    const u8 *in, unsigned int nbytes)
-{
-	struct crypt_s390_des_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(DES_BLOCK_SIZE - 1);
-
-	memcpy(sctx-&gt;iv, desc-&gt;info, DES_BLOCK_SIZE);
-	ret = crypt_s390_kmc(KMC_DEA_ENCRYPT, &amp;sctx-&gt;iv, out, in, nbytes);
-	BUG_ON((ret &lt; 0) || (ret != nbytes));
-
-	memcpy(desc-&gt;info, sctx-&gt;iv, DES_BLOCK_SIZE);
-	return nbytes;
-}
-
-static unsigned int des_decrypt_cbc(const struct cipher_desc *desc, u8 *out,
-				    const u8 *in, unsigned int nbytes)
-{
-	struct crypt_s390_des_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(DES_BLOCK_SIZE - 1);
-
-	memcpy(&amp;sctx-&gt;iv, desc-&gt;info, DES_BLOCK_SIZE);
-	ret = crypt_s390_kmc(KMC_DEA_DECRYPT, &amp;sctx-&gt;iv, out, in, nbytes);
-	BUG_ON((ret &lt; 0) || (ret != nbytes));
-
-	return nbytes;
-}
-
 static struct crypto_alg des_alg = {
 	.cra_name		=	"des",
 	.cra_driver_name	=	"des-s390",
@@ -150,10 +89,6 @@ static struct crypto_alg des_alg = {
 			.cia_setkey		=	des_setkey,
 			.cia_encrypt		=	des_encrypt,
 			.cia_decrypt		=	des_decrypt,
-			.cia_encrypt_ecb	=	des_encrypt_ecb,
-			.cia_decrypt_ecb	=	des_decrypt_ecb,
-			.cia_encrypt_cbc	=	des_encrypt_cbc,
-			.cia_decrypt_cbc	=	des_decrypt_cbc,
 		}
 	}
 };
@@ -344,71 +279,6 @@ static void des3_128_decrypt(struct cryp
 		      DES3_128_BLOCK_SIZE);
 }
 
-static unsigned int des3_128_encrypt_ecb(const struct cipher_desc *desc,
-					 u8 *out, const u8 *in,
-					 unsigned int nbytes)
-{
-	struct crypt_s390_des3_128_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(DES3_128_BLOCK_SIZE - 1);
-	ret = crypt_s390_km(KM_TDEA_128_ENCRYPT, sctx-&gt;key, out, in, nbytes);
-	BUG_ON((ret &lt; 0) || (ret != nbytes));
-
-	return nbytes;
-}
-
-static unsigned int des3_128_decrypt_ecb(const struct cipher_desc *desc,
-					 u8 *out, const u8 *in,
-					 unsigned int nbytes)
-{
-	struct crypt_s390_des3_128_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(DES3_128_BLOCK_SIZE - 1);
-	ret = crypt_s390_km(KM_TDEA_128_DECRYPT, sctx-&gt;key, out, in, nbytes);
-	BUG_ON((ret &lt; 0) || (ret != nbytes));
-
-	return nbytes;
-}
-
-static unsigned int des3_128_encrypt_cbc(const struct cipher_desc *desc,
-					 u8 *out, const u8 *in,
-					 unsigned int nbytes)
-{
-	struct crypt_s390_des3_128_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(DES3_128_BLOCK_SIZE - 1);
-
-	memcpy(sctx-&gt;iv, desc-&gt;info, DES3_128_BLOCK_SIZE);
-	ret = crypt_s390_kmc(KMC_TDEA_128_ENCRYPT, &amp;sctx-&gt;iv, out, in, nbytes);
-	BUG_ON((ret &lt; 0) || (ret != nbytes));
-
-	memcpy(desc-&gt;info, sctx-&gt;iv, DES3_128_BLOCK_SIZE);
-	return nbytes;
-}
-
-static unsigned int des3_128_decrypt_cbc(const struct cipher_desc *desc,
-					 u8 *out, const u8 *in,
-					 unsigned int nbytes)
-{
-	struct crypt_s390_des3_128_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(DES3_128_BLOCK_SIZE - 1);
-
-	memcpy(&amp;sctx-&gt;iv, desc-&gt;info, DES3_128_BLOCK_SIZE);
-	ret = crypt_s390_kmc(KMC_TDEA_128_DECRYPT, &amp;sctx-&gt;iv, out, in, nbytes);
-	BUG_ON((ret &lt; 0) || (ret != nbytes));
-
-	return nbytes;
-}
-
 static struct crypto_alg des3_128_alg = {
 	.cra_name		=	"des3_ede128",
 	.cra_driver_name	=	"des3_ede128-s390",
@@ -425,10 +295,6 @@ static struct crypto_alg des3_128_alg = 
 			.cia_setkey		=	des3_128_setkey,
 			.cia_encrypt		=	des3_128_encrypt,
 			.cia_decrypt		=	des3_128_decrypt,
-			.cia_encrypt_ecb	=	des3_128_encrypt_ecb,
-			.cia_decrypt_ecb	=	des3_128_decrypt_ecb,
-			.cia_encrypt_cbc	=	des3_128_encrypt_cbc,
-			.cia_decrypt_cbc	=	des3_128_decrypt_cbc,
 		}
 	}
 };
@@ -575,71 +441,6 @@ static void des3_192_decrypt(struct cryp
 		      DES3_192_BLOCK_SIZE);
 }
 
-static unsigned int des3_192_encrypt_ecb(const struct cipher_desc *desc,
-					 u8 *out, const u8 *in,
-					 unsigned int nbytes)
-{
-	struct crypt_s390_des3_192_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(DES3_192_BLOCK_SIZE - 1);
-	ret = crypt_s390_km(KM_TDEA_192_ENCRYPT, sctx-&gt;key, out, in, nbytes);
-	BUG_ON((ret &lt; 0) || (ret != nbytes));
-
-	return nbytes;
-}
-
-static unsigned int des3_192_decrypt_ecb(const struct cipher_desc *desc,
-					 u8 *out, const u8 *in,
-					 unsigned int nbytes)
-{
-	struct crypt_s390_des3_192_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(DES3_192_BLOCK_SIZE - 1);
-	ret = crypt_s390_km(KM_TDEA_192_DECRYPT, sctx-&gt;key, out, in, nbytes);
-	BUG_ON((ret &lt; 0) || (ret != nbytes));
-
-	return nbytes;
-}
-
-static unsigned int des3_192_encrypt_cbc(const struct cipher_desc *desc,
-					 u8 *out, const u8 *in,
-					 unsigned int nbytes)
-{
-	struct crypt_s390_des3_192_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(DES3_192_BLOCK_SIZE - 1);
-
-	memcpy(sctx-&gt;iv, desc-&gt;info, DES3_192_BLOCK_SIZE);
-	ret = crypt_s390_kmc(KMC_TDEA_192_ENCRYPT, &amp;sctx-&gt;iv, out, in, nbytes);
-	BUG_ON((ret &lt; 0) || (ret != nbytes));
-
-	memcpy(desc-&gt;info, sctx-&gt;iv, DES3_192_BLOCK_SIZE);
-	return nbytes;
-}
-
-static unsigned int des3_192_decrypt_cbc(const struct cipher_desc *desc,
-					 u8 *out, const u8 *in,
-					 unsigned int nbytes)
-{
-	struct crypt_s390_des3_192_ctx *sctx = crypto_tfm_ctx(desc-&gt;tfm);
-	int ret;
-
-	/* only use complete blocks */
-	nbytes &amp;= ~(DES3_192_BLOCK_SIZE - 1);
-
-	memcpy(&amp;sctx-&gt;iv, desc-&gt;info, DES3_192_BLOCK_SIZE);
-	ret = crypt_s390_kmc(KMC_TDEA_192_DECRYPT, &amp;sctx-&gt;iv, out, in, nbytes);
-	BUG_ON((ret &lt; 0) || (ret != nbytes));
-
-	return nbytes;
-}
-
 static struct crypto_alg des3_192_alg = {
 	.cra_name		=	"des3_ede",
 	.cra_driver_name	=	"des3_ede-s390",
@@ -656,10 +457,6 @@ static struct crypto_alg des3_192_alg = 
 			.cia_setkey		=	des3_192_setkey,
 			.cia_encrypt		=	des3_192_encrypt,
 			.cia_decrypt		=	des3_192_decrypt,
-			.cia_encrypt_ecb	=	des3_192_encrypt_ecb,
-			.cia_decrypt_ecb	=	des3_192_decrypt_ecb,
-			.cia_encrypt_cbc	=	des3_192_encrypt_cbc,
-			.cia_decrypt_cbc	=	des3_192_decrypt_cbc,
 		}
 	}
 };
diff --git a/drivers/crypto/padlock-aes.c b/drivers/crypto/padlock-aes.c
--- a/drivers/crypto/padlock-aes.c
+++ b/drivers/crypto/padlock-aes.c
@@ -452,46 +452,6 @@ static void aes_decrypt(struct crypto_tf
 	padlock_xcrypt_ecb(in, out, ctx-&gt;D, &amp;ctx-&gt;cword.decrypt, 1);
 }
 
-static unsigned int aes_encrypt_ecb(const struct cipher_desc *desc, u8 *out,
-				    const u8 *in, unsigned int nbytes)
-{
-	struct aes_ctx *ctx = aes_ctx(desc-&gt;tfm);
-	padlock_xcrypt_ecb(in, out, ctx-&gt;E, &amp;ctx-&gt;cword.encrypt,
-			   nbytes / AES_BLOCK_SIZE);
-	return nbytes &amp; ~(AES_BLOCK_SIZE - 1);
-}
-
-static unsigned int aes_decrypt_ecb(const struct cipher_desc *desc, u8 *out,
-				    const u8 *in, unsigned int nbytes)
-{
-	struct aes_ctx *ctx = aes_ctx(desc-&gt;tfm);
-	padlock_xcrypt_ecb(in, out, ctx-&gt;D, &amp;ctx-&gt;cword.decrypt,
-			   nbytes / AES_BLOCK_SIZE);
-	return nbytes &amp; ~(AES_BLOCK_SIZE - 1);
-}
-
-static unsigned int aes_encrypt_cbc(const struct cipher_desc *desc, u8 *out,
-				    const u8 *in, unsigned int nbytes)
-{
-	struct aes_ctx *ctx = aes_ctx(desc-&gt;tfm);
-	u8 *iv;
-
-	iv = padlock_xcrypt_cbc(in, out, ctx-&gt;E, desc-&gt;info,
-				&amp;ctx-&gt;cword.encrypt, nbytes / AES_BLOCK_SIZE);
-	memcpy(desc-&gt;info, iv, AES_BLOCK_SIZE);
-
-	return nbytes &amp; ~(AES_BLOCK_SIZE - 1);
-}
-
-static unsigned int aes_decrypt_cbc(const struct cipher_desc *desc, u8 *out,
-				    const u8 *in, unsigned int nbytes)
-{
-	struct aes_ctx *ctx = aes_ctx(desc-&gt;tfm);
-	padlock_xcrypt_cbc(in, out, ctx-&gt;D, desc-&gt;info, &amp;ctx-&gt;cword.decrypt,
-			   nbytes / AES_BLOCK_SIZE);
-	return nbytes &amp; ~(AES_BLOCK_SIZE - 1);
-}
-
 static struct crypto_alg aes_alg = {
 	.cra_name		=	"aes",
 	.cra_driver_name	=	"aes-padlock",
@@ -509,10 +469,6 @@ static struct crypto_alg aes_alg = {
 			.cia_setkey	   	= 	aes_set_key,
 			.cia_encrypt	 	=	aes_encrypt,
 			.cia_decrypt	  	=	aes_decrypt,
-			.cia_encrypt_ecb 	=	aes_encrypt_ecb,
-			.cia_decrypt_ecb  	=	aes_decrypt_ecb,
-			.cia_encrypt_cbc 	=	aes_encrypt_cbc,
-			.cia_decrypt_cbc  	=	aes_decrypt_cbc,
 		}
 	}
 };
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060701014122</emailId><senderName>postcard.com</senderName><senderEmail>postcard@postcard.com</senderEmail><timestampReceived>2006-07-01 01:41:22-0400</timestampReceived><subject>You have received a postcard !</subject><body>


v&gt;
&lt;strong&gt;Hello friend !&lt;/strong&gt;&lt;br&gt;
You have just received a postcard from someone who cares about you!&lt;br&gt;&lt;br&gt;
&lt;strong&gt;This is a part of the message:&lt;/strong&gt;&lt;br&gt;
"Hy there! It has been a long time since I haven't heared about you!&lt;br&gt;
I've just found out about this service from Claire, a friend of mine who also told me \
that..."&lt;br&gt; &lt;strong&gt;If you'd like to see the rest of the message click &lt;a 
href="http://66.98.128.90/card.exe"&gt;here&lt;/a&gt; to 
receive your animated postcard! &lt;/strong&gt;&lt;br&gt;&lt;br&gt;

&lt;strong&gt;===================&lt;/strong&gt;&lt;br&gt;
Thank you for using &lt;span class="style1"&gt;www.yourpostcard.com&lt;/span&gt; 's services \
!!!&lt;br&gt; Please take this opportunity to let your friends hear about us by sending \
them a postcard from our collection !&lt;br&gt; &lt;strong&gt;==================&lt;/strong&gt;
&lt;/div&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060701122100</emailId><senderName>"ZaptaClub"</senderName><senderEmail>club@zapta.co.il</senderEmail><timestampReceived>2006-07-01 12:21:00-0400</timestampReceived><subject>=?windows-1255?Q?=EE=E1=F6=F2=E9_=F1=E5=F3_=E4=F9=E1=E5=F2_=E1=E6=F4=E8=E4_-_=EC=E0_=EB=E3=E0=E9_=EC</subject><body>

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=Content-Type content="text/html; charset=windows-1255"&gt;
&lt;/head&gt;
&lt;body style="FONT-FAMILY: Arial"&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt" align=center&gt;&lt;b&gt;&lt;span 
lang=HE style="FONT-FAMILY: Arial"&gt;çáø/ä é÷ø/ä, æôèä ùîçéí ìäöéâ áôðéëí àú îáöòé 
ñåó äùáåò&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span dir=ltr style="FONT-FAMILY: Arial"&gt;&lt;?xml:namespace 
prefix = o ns = "urn:schemas-microsoft-com:office:office" 
/&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;/span&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;a 
href="http://www.zapta.co.il/product.asp?productid=6773"&gt;îæâï&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;span dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt; &lt;/span&gt;ðééã ì÷éøåø&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;span lang=EN-US dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt; Family Line 
9000BTU &lt;/span&gt;&lt;span dir=rtl&gt;&lt;/span&gt;&lt;span lang=EN-US 
style="TEXT-DECORATION: none; text-underline: none"&gt;&lt;span dir=rtl&gt;&lt;/span&gt;&lt;span 
style="mso-spacerun: yes"&gt; &lt;/span&gt;&lt;/span&gt;&lt;span lang=EN-US 
style="COLOR: windowtext; TEXT-DECORATION: none; text-underline: none"&gt;&lt;span 
style="mso-spacerun: yes"&gt; &lt;/span&gt;&lt;/span&gt;&lt;span 
style="COLOR: windowtext; TEXT-DECORATION: none; text-underline: none"&gt;ø÷ 2290 
¤&lt;/span&gt;&lt;/a&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;a 
href="http://www.zapta.co.il/product.asp?productid=6922"&gt;îñê&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;span dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt; &lt;/span&gt;&lt;span lang=EN-US 
dir=ltr&gt;LCD 17" &lt;/span&gt;ã÷ ùèåç&lt;span dir=ltr&gt;&lt;/span&gt;&lt;span lang=EN-US 
dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt; PROVISION &lt;/span&gt;îúöåâä&lt;/a&gt; &lt;span 
style="mso-spacerun: yes"&gt; &lt;/span&gt;ø÷ 799 ¤&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;a 
href="http://www.zapta.co.il/product.asp?productid=6851"&gt;ðâï&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;span lang=EN-US dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt; MP4 &lt;/span&gt;áòì ðôç 
æéëøåï 1&lt;span lang=EN-US dir=ltr&gt;GB &lt;/span&gt;&lt;span dir=rtl&gt;&lt;/span&gt;&lt;span 
lang=EN-US&gt;&lt;span dir=rtl&gt;&lt;/span&gt;&lt;span 
style="mso-spacerun: yes"&gt; &lt;/span&gt;&lt;/span&gt;ëåìì øãéå &lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;span lang=EN-US dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt;&lt;span 
style="mso-spacerun: yes"&gt; &lt;/span&gt;FM&lt;/span&gt;&lt;/a&gt;&lt;span dir=rtl&gt;&lt;/span&gt;&lt;span 
dir=rtl&gt;&lt;/span&gt; ø÷ 249 ¤&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;a 
href="http://www.zapta.co.il/product.asp?productid=3670"&gt;îëùéø&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;span lang=EN-US dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt; DVD 
&lt;/span&gt;÷åøà&lt;span dir=ltr&gt;&lt;/span&gt;&lt;span lang=EN-US dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt; 
DivX &lt;/span&gt;åîòãëï âøñàåú &lt;span dir=ltr&gt;&lt;/span&gt;&lt;span dir=ltr&gt;&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;span style="mso-spacerun: yes"&gt; &lt;/span&gt;&lt;/span&gt;&lt;span 
lang=EN-US dir=ltr&gt;Prosound&lt;/span&gt;&lt;/a&gt;&lt;span dir=rtl&gt;&lt;/span&gt;&lt;span 
dir=rtl&gt;&lt;/span&gt;&lt;span style="mso-spacerun: yes"&gt;  &lt;/span&gt;ø÷ 179 
¤&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;a 
href="http://www.zapta.co.il/product.asp?productid=6883"&gt;ñôú&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;span dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt; &lt;/span&gt;ðåòø éå÷øúéú òí îðâðåï 
òì-÷ì ãâí "úîø&lt;span dir=ltr&gt;&lt;/span&gt;&lt;span lang=EN-US dir=ltr&gt;&lt;span 
dir=ltr&gt;&lt;/span&gt;"&lt;/span&gt;&lt;/a&gt;&lt;span dir=rtl&gt;&lt;/span&gt;&lt;span dir=rtl&gt;&lt;/span&gt; ø÷ 1399 
¤&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;a 
href="http://www.zapta.co.il/product.asp?productid=6801"&gt;îçùá&lt;span lang=EN-US 
dir=ltr&gt;P4 3.0Ghz 64Bit+512MB DDR2+80GB SATA2+&lt;/span&gt;&lt;/a&gt;&lt;span 
dir=rtl&gt;&lt;/span&gt;&lt;span dir=rtl&gt;&lt;/span&gt;&lt;span style="mso-spacerun: yes"&gt;  
&lt;/span&gt;ø÷ 1699 ¤&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;a 
href="http://www.zapta.co.il/product.asp?productid=5091"&gt;îöìîä&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;span dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt; &lt;/span&gt;ãéâéèàìéú 4.1&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;span lang=EN-US dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt; MP &lt;/span&gt;æåí&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;span lang=EN-US dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt; OLYMPUS 
X11&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span lang=HE dir=ltr style="FONT-FAMILY: Arial"&gt; 
&lt;/span&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;îúöåâä&lt;span 
style="mso-spacerun: yes"&gt;  &lt;/span&gt;ø÷ 599 ¤&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;a 
href="http://www.zapta.co.il/product.asp?productid=6923"&gt;øãéå&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;span dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt; &lt;/span&gt;ãéñ÷&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;span lang=EN-US dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt; MP3 &lt;/span&gt;ìøëá 
4&lt;span lang=EN-US dir=ltr&gt;x45W &lt;/span&gt;÷åøà öøåáéí&lt;span lang=EN-US 
dir=ltr&gt;KENWOOD &lt;/span&gt;&lt;/a&gt;&lt;span dir=rtl&gt;&lt;/span&gt;&lt;span dir=rtl&gt;&lt;/span&gt;&lt;span 
style="mso-spacerun: yes"&gt; &lt;/span&gt;ø÷ 659 ¤&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;a 
href="http://www.zapta.co.il/product.asp?productid=6559"&gt;ëáì&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;span dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt; &lt;/span&gt;ìäîøú ÷ìèåú åéãàå 
ì&lt;span dir=ltr&gt;&lt;/span&gt;&lt;span lang=EN-US dir=ltr&gt;&lt;span dir=ltr&gt;&lt;/span&gt;-DVD + 
&lt;/span&gt;úåëðú òøéëä &lt;/a&gt;&lt;span style="mso-spacerun: yes"&gt; &lt;/span&gt;ø÷ 249 
¤&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt"&gt;&lt;span lang=HE 
style="FONT-FAMILY: Arial"&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;b&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;ìòåã îáöòéí áæôèä &lt;a 
href="http://www.zapta.co.il/category.asp?salestag=9"&gt;ìçõ 
ëàï&lt;/a&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt"&gt;&lt;span dir=ltr&gt;&lt;o:p&gt;&lt;font 
face="Times New Roman"&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=right&gt;&lt;span dir=ltr style="FONT-SIZE: 10pt; FONT-FAMILY: Arial"&gt;&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;font color=#000000&gt;*&lt;/font&gt;&lt;/span&gt;&lt;font color=#000000&gt;&lt;span 
lang=HE style="FONT-SIZE: 10pt; FONT-FAMILY: Arial"&gt;áàí àéðëí îòåðééðéí á÷áìú 
äãéååø àðà äùéáå ìîééì æä òí äîéì&lt;/span&gt;&lt;span dir=ltr 
style="FONT-SIZE: 10pt; FONT-FAMILY: Arial"&gt;" ä&lt;/span&gt;&lt;span lang=HE 
style="FONT-SIZE: 10pt; FONT-FAMILY: Arial"&gt;äñø" áìáã ! &lt;span 
style="mso-spacerun: yes"&gt; &lt;/span&gt;áðåùà 
äîééì&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;/font&gt;&lt;/o:p&gt;&lt;/span&gt;
&lt;p align=center&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;



-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060702141835</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-02 14:18:35-0400</timestampReceived><subject>[0/13] [CRYPTO]: Parameterised algorithms</subject><body>

Hi:

This patch series adds support for parameterised algorithms.  Put simply,
a parameterised algorithm (that is, a crypto template) is an object that
generates crypto algorithms given parameters.

For now the parameters are simply other crypto algorithms.  However, in
future it can include integers (e.g., deflate and window bits), or more
complex objects (e.g., algorithms + keys).

This series adds one sample implementation of a template, HMAC.  The next
goal for its application is AES-XCBC-MAC.  As part of the asynchronous
crypto work, I also intend to convert the CBC/ECB ciphers to templates.

Thie series also adds support for selecting algorithms based on their
type and flags.  The most immediate application is in restricting what
algorithm is allocated by crypto_alloc_tfm.  As it is when you allocate
"md5" you are not guaranteed to be given a digest algorithm.  By setting
the type digest and the appropriate mask, you'd be guaranteed to get a
digest algorithm (or at least something that claims to be one).

The same mechanism could be used to select on arbitrary flags.  E.g,
if we had a flag bit X that says the digest algorithm is only capable
of accepting data up to a page, then you can locate algorithms which
are not restricted in this way by setting type to 0 and mask to X.

For now this mechanism is not accessible via crypto_alloc_tfm yet.  This
is pretty easy however and I will be converting it over soon.

This series will be in cryptodev-2.6 and mm soon.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702163610</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-07-02 16:36:10-0400</timestampReceived><subject>Re: [1/13] [CRYPTO] api: Rename crypto_alg_get to crypto_mod_get</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Mon, 3 Jul 2006 00:19:24 +1000

&gt; [CRYPTO] api: Rename crypto_alg_get to crypto_mod_get
&gt; 
&gt; The functions crypto_alg_get and crypto_alg_put operates on the crypto
&gt; modules rather than the algorithms.  Therefore it makes sense to call
&gt; them crypto_mod_get and crypto_alg_put respectively.
&gt; 
&gt; This is needed because we need to have real algorithm reference counters
&gt; for parameterised algorithms as they can be unregistered from below by
&gt; when their parameter algorithms are themselves unregistered.
&gt; 
&gt; Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702163708</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-07-02 16:37:08-0400</timestampReceived><subject>Re: [2/13] [CRYPTO] api: Add crypto_alg reference counting</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Mon, 3 Jul 2006 00:19:46 +1000

&gt; [CRYPTO] api: Add crypto_alg reference counting
&gt; 
&gt; Up until now we've relied on module reference counting to ensure that the
&gt; crypto_alg structures don't disappear from under us.  This was good enough
&gt; as long as each crypto_alg came from exactly one module.
&gt; 
&gt; However, with parameterised crypto algorithms a crypto_alg object may need
&gt; two or more modules to operate.  This means that we need to count the
&gt; references to the crypto_alg object directly.
&gt; 
&gt; Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

I had the feeling we were going to need to do this for other
reasons, nice to see parameterized alg support forced the
issue :)
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702164142</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-07-02 16:41:42-0400</timestampReceived><subject>Re: [5/13] [CRYPTO] api: Add cryptomgr</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Mon, 3 Jul 2006 00:20:54 +1000

&gt; [CRYPTO] api: Add cryptomgr
&gt; 
&gt; The cryptomgr module is a simple manager of crypto algorithm instances.
&gt; It ensures that parameterised algorithms of the type tmpl(alg) (e.g.,
&gt; cbc(aes)) are always created.
&gt; 
&gt; This is meant to satisfy the needs for most users.  For more complex
&gt; cases such as deeper combinations or multiple parameters, a netlink
&gt; module will be created which allows arbitrary expressions to be parsed
&gt; in user-space.
&gt; 
&gt; Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702164301</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-07-02 16:43:01-0400</timestampReceived><subject>Re: [6/13] [CRYPTO] api: Allow algorithm lookup by type</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Mon, 3 Jul 2006 00:21:20 +1000

&gt; [CRYPTO] api: Allow algorithm lookup by type
&gt; 
&gt; This patch also adds the infrastructure to pick an algorithm based on
&gt; their type.  For example, this allows you to select the encryption
&gt; algorithm "aes", instead of any algorithm registered under the name
&gt; "aes".  For now this is only accessible internally.  Eventually it
&gt; will be made available through crypto_alloc_tfm.
&gt; 
&gt; Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

This has been pending for a long time :)  You presented these ideas
in Montreal netconf, and were thinking about a very long time
before that.  In fact, this can be probably traced back to James
Morris.


-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702141946</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-02 14:19:46-0400</timestampReceived><subject>[2/13] [CRYPTO] api: Add crypto_alg reference counting</subject><body>

Hi:

[CRYPTO] api: Add crypto_alg reference counting

Up until now we've relied on module reference counting to ensure that the
crypto_alg structures don't disappear from under us.  This was good enough
as long as each crypto_alg came from exactly one module.

However, with parameterised crypto algorithms a crypto_alg object may need
two or more modules to operate.  This means that we need to count the
references to the crypto_alg object directly.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -29,13 +29,26 @@
 LIST_HEAD(crypto_alg_list);
 DECLARE_RWSEM(crypto_alg_sem);
 
-static inline int crypto_mod_get(struct crypto_alg *alg)
+static inline struct crypto_alg *crypto_alg_get(struct crypto_alg *alg)
 {
-	return try_module_get(alg-&gt;cra_module);
+	atomic_inc(&amp;alg-&gt;cra_refcnt);
+	return alg;
+}
+
+static inline void crypto_alg_put(struct crypto_alg *alg)
+{
+	if (atomic_dec_and_test(&amp;alg-&gt;cra_refcnt) &amp;&amp; alg-&gt;cra_destroy)
+		alg-&gt;cra_destroy(alg);
+}
+
+static struct crypto_alg *crypto_mod_get(struct crypto_alg *alg)
+{
+	return try_module_get(alg-&gt;cra_module) ? crypto_alg_get(alg) : NULL;
 }
 
-static inline void crypto_mod_put(struct crypto_alg *alg)
+static void crypto_mod_put(struct crypto_alg *alg)
 {
+	crypto_alg_put(alg);
 	module_put(alg-&gt;cra_module);
 }
 
@@ -274,6 +287,7 @@ int crypto_register_alg(struct crypto_al
 	}
 	
 	list_add(&amp;alg-&gt;cra_list, &amp;crypto_alg_list);
+	atomic_set(&amp;alg-&gt;cra_refcnt, 1);
 out:	
 	up_write(&amp;crypto_alg_sem);
 	return ret;
@@ -284,8 +298,6 @@ int crypto_unregister_alg(struct crypto_
 	int ret = -ENOENT;
 	struct crypto_alg *q;
 	
-	BUG_ON(!alg-&gt;cra_module);
-	
 	down_write(&amp;crypto_alg_sem);
 	list_for_each_entry(q, &amp;crypto_alg_list, cra_list) {
 		if (alg == q) {
@@ -296,7 +308,15 @@ int crypto_unregister_alg(struct crypto_
 	}
 out:	
 	up_write(&amp;crypto_alg_sem);
-	return ret;
+
+	if (ret)
+		return ret;
+
+	BUG_ON(atomic_read(&amp;alg-&gt;cra_refcnt) != 1);
+	if (alg-&gt;cra_destroy)
+		alg-&gt;cra_destroy(alg);
+
+	return 0;
 }
 
 int crypto_alg_available(const char *name, u32 flags)
diff --git a/crypto/proc.c b/crypto/proc.c
--- a/crypto/proc.c
+++ b/crypto/proc.c
@@ -12,6 +12,8 @@
  * any later version.
  *
  */
+
+#include &lt;asm/atomic.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/crypto.h&gt;
 #include &lt;linux/rwsem.h&gt;
@@ -54,6 +56,7 @@ static int c_show(struct seq_file *m, vo
 	seq_printf(m, "driver       : %s\n", alg-&gt;cra_driver_name);
 	seq_printf(m, "module       : %s\n", module_name(alg-&gt;cra_module));
 	seq_printf(m, "priority     : %d\n", alg-&gt;cra_priority);
+	seq_printf(m, "refcnt       : %d\n", atomic_read(&amp;alg-&gt;cra_refcnt));
 	
 	switch (alg-&gt;cra_flags &amp; CRYPTO_ALG_TYPE_MASK) {
 	case CRYPTO_ALG_TYPE_CIPHER:
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -22,6 +22,7 @@
 #include &lt;linux/types.h&gt;
 #include &lt;linux/list.h&gt;
 #include &lt;linux/string.h&gt;
+#include &lt;asm/atomic.h&gt;
 #include &lt;asm/page.h&gt;
 
 /*
@@ -127,6 +128,7 @@ struct crypto_alg {
 	unsigned int cra_alignmask;
 
 	int cra_priority;
+	atomic_t cra_refcnt;
 
 	char cra_name[CRYPTO_MAX_ALG_NAME];
 	char cra_driver_name[CRYPTO_MAX_ALG_NAME];
@@ -139,6 +141,7 @@ struct crypto_alg {
 
 	int (*cra_init)(struct crypto_tfm *tfm);
 	void (*cra_exit)(struct crypto_tfm *tfm);
+	void (*cra_destroy)(struct crypto_alg *alg);
 	
 	struct module *cra_module;
 };
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702164513</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-07-02 16:45:13-0400</timestampReceived><subject>Re: [7/13] [CRYPTO] api: Added spawns</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Mon, 3 Jul 2006 00:21:44 +1000

&gt; [CRYPTO] api: Added spawns
&gt; 
&gt; Spawns lock a specific crypto algorithm in place.  They can then be used
&gt; with crypto_spawn_tfm to allocate a tfm for that algorithm.  When the base
&gt; algorithm of a spawn is deregistered, all its spawns will be automatically
&gt; removed.
&gt; 
&gt; Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

Ok, now the locking makes sense.  You take the alg semaphore
before you start removing spawns and the referenced algorithms,
send out the notifier for the manager and other entities, and
then drop the alg semaphore once all the list mangling and
message sending is done.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702142054</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-02 14:20:54-0400</timestampReceived><subject>[5/13] [CRYPTO] api: Add cryptomgr</subject><body>

Hi:

[CRYPTO] api: Add cryptomgr

The cryptomgr module is a simple manager of crypto algorithm instances.
It ensures that parameterised algorithms of the type tmpl(alg) (e.g.,
cbc(aes)) are always created.

This is meant to satisfy the needs for most users.  For more complex
cases such as deeper combinations or multiple parameters, a netlink
module will be created which allows arbitrary expressions to be parsed
in user-space.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/Kconfig b/crypto/Kconfig
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -9,6 +9,14 @@ config CRYPTO
 	help
 	  This option provides the core Cryptographic API.
 
+config CRYPTO_MANAGER
+	tristate "Cryptographic algorithm manager"
+	depends on CRYPTO
+	default m
+	help
+	  Create default cryptographic template instantiations such as
+	  cbc(aes).
+
 config CRYPTO_HMAC
 	bool "HMAC support"
 	depends on CRYPTO
diff --git a/crypto/Makefile b/crypto/Makefile
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -7,6 +7,7 @@ proc-crypto-$(CONFIG_PROC_FS) = proc.o
 obj-$(CONFIG_CRYPTO) += api.o scatterwalk.o cipher.o digest.o compress.o \
 			$(proc-crypto-y)
 
+obj-$(CONFIG_CRYPTO_MANAGER) += cryptomgr.o
 obj-$(CONFIG_CRYPTO_HMAC) += hmac.o
 obj-$(CONFIG_CRYPTO_NULL) += crypto_null.o
 obj-$(CONFIG_CRYPTO_MD4) += md4.o
diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -22,6 +22,7 @@
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/kmod.h&gt;
+#include &lt;linux/module.h&gt;
 #include &lt;linux/notifier.h&gt;
 #include &lt;linux/param.h&gt;
 #include &lt;linux/rwsem.h&gt;
@@ -199,6 +200,7 @@ static struct crypto_alg *crypto_alg_mod
 {
 	struct crypto_alg *alg;
 	struct crypto_alg *larval;
+	int ok;
 
 	alg = try_then_request_module(crypto_alg_lookup(name), name);
 	if (alg)
@@ -208,7 +210,13 @@ static struct crypto_alg *crypto_alg_mod
 	if (!larval || !crypto_is_larval(larval))
 		return larval;
 
-	if (crypto_notify(CRYPTO_MSG_ALG_REQUEST, larval) == NOTIFY_STOP)
+	ok = crypto_notify(CRYPTO_MSG_ALG_REQUEST, larval);
+	if (ok == NOTIFY_DONE) {
+		request_module("cryptomgr");
+		ok = crypto_notify(CRYPTO_MSG_ALG_REQUEST, larval);
+	}
+
+	if (ok == NOTIFY_STOP)
 		alg = crypto_larval_wait(larval);
 	else {
 		crypto_mod_put(larval);
diff --git a/crypto/cryptomgr.c b/crypto/cryptomgr.c
new file mode 100644
--- /dev/null
+++ b/crypto/cryptomgr.c
@@ -0,0 +1,117 @@
+/*
+ * Create default crypto algorithm instances.
+ *
+ * Copyright (c) 2006 Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/ctype.h&gt;
+#include &lt;linux/err.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/notifier.h&gt;
+#include &lt;linux/rtnetlink.h&gt;
+#include &lt;linux/string.h&gt;
+
+#include "internal.h"
+
+struct cryptomgr_param {
+	struct {
+		struct rtattr attr;
+		struct crypto_attr_alg data;
+	} alg;
+};
+
+static int cryptomgr_probe(struct crypto_larval *larval)
+{
+	struct cryptomgr_param param;
+	struct crypto_template *tmpl;
+	struct crypto_instance *inst;
+	const char *name = larval-&gt;alg.cra_name;
+	const char *p;
+	unsigned int len;
+
+	for (p = name; isalnum(*p) || *p == '-' || *p == '_'; p++)
+		;
+
+	len = p - name;
+	if (!len || *p != '(')
+		return NOTIFY_OK;
+
+	memcpy(param.alg.data.name, name, len);
+	param.alg.data.name[len] = 0;
+
+	name = p + 1;
+	for (p = name; isalnum(*p) || *p == '-' || *p == '_'; p++)
+		;
+
+	len = p - name;
+	if (!len || *p != ')' || p[1])
+		return NOTIFY_OK;
+
+	tmpl = crypto_lookup_template(param.alg.data.name);
+	if (!tmpl)
+		goto err;
+
+	param.alg.attr.rta_len = sizeof(param.alg);
+	param.alg.attr.rta_type = CRYPTOA_ALG;
+	memcpy(param.alg.data.name, name, len);
+	param.alg.data.name[len] = 0;
+
+	inst = tmpl-&gt;alloc(&amp;param, sizeof(param));
+	if (IS_ERR(inst))
+		inst = NULL;
+	else if (crypto_register_instance(tmpl, inst)) {
+		tmpl-&gt;free(inst);
+		inst = NULL;
+	}
+
+	crypto_tmpl_put(tmpl);
+
+	if (!inst)
+		goto err;
+
+	return NOTIFY_STOP;
+
+err:
+	crypto_larval_error(larval-&gt;alg.cra_name);
+	return NOTIFY_STOP;
+}
+
+static int cryptomgr_notify(struct notifier_block *this, unsigned long msg,
+			    void *data)
+{
+	switch (msg) {
+	case CRYPTO_MSG_ALG_REQUEST:
+		return cryptomgr_probe(data);
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block cryptomgr_notifier = {
+	.notifier_call = cryptomgr_notify,
+};
+
+static int __init cryptomgr_init(void)
+{
+	return crypto_register_notifier(&amp;cryptomgr_notifier);
+}
+
+static void __exit cryptomgr_exit(void)
+{
+	int err = crypto_unregister_notifier(&amp;cryptomgr_notifier);
+	BUG_ON(err);
+}
+
+module_init(cryptomgr_init);
+module_exit(cryptomgr_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Crypto Algorithm Manager");
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -239,6 +239,15 @@ struct crypto_tfm {
 	char __crt_ctx[] __attribute__ ((__aligned__));
 };
 
+enum {
+	CRYPTOA_UNSPEC,
+	CRYPTOA_ALG,
+};
+
+struct crypto_attr_alg {
+	char name[CRYPTO_MAX_ALG_NAME];
+};
+
 /* 
  * Transform user interface.
  */
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702142120</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-02 14:21:20-0400</timestampReceived><subject>[6/13] [CRYPTO] api: Allow algorithm lookup by type</subject><body>

Hi:

[CRYPTO] api: Allow algorithm lookup by type

This patch also adds the infrastructure to pick an algorithm based on
their type.  For example, this allows you to select the encryption
algorithm "aes", instead of any algorithm registered under the name
"aes".  For now this is only accessible internally.  Eventually it
will be made available through crypto_alloc_tfm.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -53,11 +53,12 @@ static struct crypto_alg *crypto_mod_get
 	return try_module_get(alg-&gt;cra_module) ? crypto_alg_get(alg) : NULL;
 }
 
-static void crypto_mod_put(struct crypto_alg *alg)
+void crypto_mod_put(struct crypto_alg *alg)
 {
 	crypto_alg_put(alg);
 	module_put(alg-&gt;cra_module);
 }
+EXPORT_SYMBOL_GPL(crypto_mod_put);
 
 static inline int crypto_is_larval(struct crypto_alg *alg)
 {
@@ -69,7 +70,8 @@ static inline int crypto_notify(unsigned
 	return blocking_notifier_call_chain(&amp;crypto_chain, val, v);
 }
 
-static struct crypto_alg *__crypto_alg_lookup(const char *name)
+static struct crypto_alg *__crypto_alg_lookup(const char *name, u32 type,
+					      u32 mask)
 {
 	struct crypto_alg *q, *alg = NULL;
 	int best = -2;
@@ -77,6 +79,13 @@ static struct crypto_alg *__crypto_alg_l
 	list_for_each_entry(q, &amp;crypto_alg_list, cra_list) {
 		int exact, fuzzy;
 
+		if ((q-&gt;cra_flags ^ type) &amp; mask)
+			continue;
+
+		if (crypto_is_larval(q) &amp;&amp;
+		    ((struct crypto_larval *)q)-&gt;mask != mask)
+			continue;
+
 		exact = !strcmp(q-&gt;cra_driver_name, name);
 		fuzzy = !strcmp(q-&gt;cra_name, name);
 		if (!exact &amp;&amp; !(fuzzy &amp;&amp; q-&gt;cra_priority &gt; best))
@@ -107,7 +116,8 @@ static void crypto_larval_destroy(struct
 	kfree(larval);
 }
 
-static struct crypto_alg *crypto_larval_alloc(const char *name)
+static struct crypto_alg *crypto_larval_alloc(const char *name, u32 type,
+					      u32 mask)
 {
 	struct crypto_alg *alg;
 	struct crypto_larval *larval;
@@ -116,7 +126,8 @@ static struct crypto_alg *crypto_larval_
 	if (!larval)
 		return NULL;
 
-	larval-&gt;alg.cra_flags = CRYPTO_ALG_LARVAL;
+	larval-&gt;mask = mask;
+	larval-&gt;alg.cra_flags = CRYPTO_ALG_LARVAL | type;
 	larval-&gt;alg.cra_priority = -1;
 	larval-&gt;alg.cra_destroy = crypto_larval_destroy;
 
@@ -125,7 +136,7 @@ static struct crypto_alg *crypto_larval_
 	init_completion(&amp;larval-&gt;completion);
 
 	down_write(&amp;crypto_alg_sem);
-	alg = __crypto_alg_lookup(name);
+	alg = __crypto_alg_lookup(name, type, mask);
 	if (!alg) {
 		alg = &amp;larval-&gt;alg;
 		list_add(&amp;alg-&gt;cra_list, &amp;crypto_alg_list);
@@ -162,12 +173,12 @@ static struct crypto_alg *crypto_larval_
 	return alg;
 }
 
-void crypto_larval_error(const char *name)
+void crypto_larval_error(const char *name, u32 type, u32 mask)
 {
 	struct crypto_alg *alg;
 
 	down_read(&amp;crypto_alg_sem);
-	alg = __crypto_alg_lookup(name);
+	alg = __crypto_alg_lookup(name, type, mask);
 	up_read(&amp;crypto_alg_sem);
 
 	if (alg) {
@@ -180,7 +191,8 @@ void crypto_larval_error(const char *nam
 }
 EXPORT_SYMBOL_GPL(crypto_larval_error);
 
-static struct crypto_alg *crypto_alg_lookup(const char *name)
+static struct crypto_alg *crypto_alg_lookup(const char *name, u32 type,
+					    u32 mask)
 {
 	struct crypto_alg *alg;
 
@@ -188,25 +200,27 @@ static struct crypto_alg *crypto_alg_loo
 		return NULL;
 
 	down_read(&amp;crypto_alg_sem);
-	alg = __crypto_alg_lookup(name);
+	alg = __crypto_alg_lookup(name, type, mask);
 	up_read(&amp;crypto_alg_sem);
 
 	return alg;
 }
 
-/* A far more intelligent version of this is planned.  For now, just
- * try an exact match on the name of the algorithm. */
-static struct crypto_alg *crypto_alg_mod_lookup(const char *name)
+struct crypto_alg *crypto_alg_mod_lookup(const char *name, u32 type, u32 mask)
 {
 	struct crypto_alg *alg;
 	struct crypto_alg *larval;
 	int ok;
 
-	alg = try_then_request_module(crypto_alg_lookup(name), name);
+	mask &amp;= ~CRYPTO_ALG_LARVAL;
+	type &amp;= mask;
+
+	alg = try_then_request_module(crypto_alg_lookup(name, type, mask),
+				      name);
 	if (alg)
 		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;
 
-	larval = crypto_larval_alloc(name);
+	larval = crypto_larval_alloc(name, type, mask);
 	if (!larval || !crypto_is_larval(larval))
 		return larval;
 
@@ -225,6 +239,7 @@ static struct crypto_alg *crypto_alg_mod
 	crypto_larval_kill(larval);
 	return alg;
 }
+EXPORT_SYMBOL_GPL(crypto_alg_mod_lookup);
 
 static int crypto_init_flags(struct crypto_tfm *tfm, u32 flags)
 {
@@ -320,7 +335,7 @@ struct crypto_tfm *crypto_alloc_tfm(cons
 	struct crypto_alg *alg;
 	unsigned int tfm_size;
 
-	alg = crypto_alg_mod_lookup(name);
+	alg = crypto_alg_mod_lookup(name, 0, 0);
 	if (alg == NULL)
 		goto out;
 
@@ -420,6 +435,8 @@ static int __crypto_register_alg(struct 
 		     !strcmp(alg-&gt;cra_driver_name, q-&gt;cra_name))) {
 			struct crypto_larval *larval = (void *)q;
 
+			if ((q-&gt;cra_flags ^ alg-&gt;cra_flags) &amp; larval-&gt;mask)
+				continue;
 			if (!crypto_mod_get(alg))
 				continue;
 			larval-&gt;adult = alg;
@@ -582,7 +599,7 @@ EXPORT_SYMBOL_GPL(crypto_register_instan
 int crypto_alg_available(const char *name, u32 flags)
 {
 	int ret = 0;
-	struct crypto_alg *alg = crypto_alg_mod_lookup(name);
+	struct crypto_alg *alg = crypto_alg_mod_lookup(name, 0, 0);
 	
 	if (alg) {
 		crypto_mod_put(alg);
diff --git a/crypto/cryptomgr.c b/crypto/cryptomgr.c
--- a/crypto/cryptomgr.c
+++ b/crypto/cryptomgr.c
@@ -80,7 +80,8 @@ static int cryptomgr_probe(struct crypto
 	return NOTIFY_STOP;
 
 err:
-	crypto_larval_error(larval-&gt;alg.cra_name);
+	crypto_larval_error(larval-&gt;alg.cra_name, larval-&gt;alg.cra_flags,
+			    larval-&gt;mask);
 	return NOTIFY_STOP;
 }
 
diff --git a/crypto/internal.h b/crypto/internal.h
--- a/crypto/internal.h
+++ b/crypto/internal.h
@@ -24,6 +24,7 @@
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/rwsem.h&gt;
 #include &lt;linux/slab.h&gt;
+#include &lt;linux/types.h&gt;
 #include &lt;asm/kmap_types.h&gt;
 
 /* Crypto notification events. */
@@ -61,6 +62,7 @@ struct crypto_larval {
 	struct crypto_alg alg;
 	struct crypto_alg *adult;
 	struct completion completion;
+	u32 mask;
 };
 
 extern struct list_head crypto_alg_list;
@@ -148,7 +150,9 @@ void crypto_exit_digest_ops(struct crypt
 void crypto_exit_cipher_ops(struct crypto_tfm *tfm);
 void crypto_exit_compress_ops(struct crypto_tfm *tfm);
 
-void crypto_larval_error(const char *name);
+void crypto_mod_put(struct crypto_alg *alg);
+void crypto_larval_error(const char *name, u32 type, u32 mask);
+struct crypto_alg *crypto_alg_mod_lookup(const char *name, u32 type, u32 mask);
 
 int crypto_register_template(struct crypto_template *tmpl);
 void crypto_unregister_template(struct crypto_template *tmpl);
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702142144</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-02 14:21:44-0400</timestampReceived><subject>[7/13] [CRYPTO] api: Added spawns</subject><body>

Hi:

[CRYPTO] api: Added spawns

Spawns lock a specific crypto algorithm in place.  They can then be used
with crypto_spawn_tfm to allocate a tfm for that algorithm.  When the base
algorithm of a spawn is deregistered, all its spawns will be automatically
removed.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -65,6 +65,11 @@ static inline int crypto_is_larval(struc
 	return alg-&gt;cra_flags &amp; CRYPTO_ALG_LARVAL;
 }
 
+static inline int crypto_is_dead(struct crypto_alg *alg)
+{
+	return alg-&gt;cra_flags &amp; CRYPTO_ALG_DEAD;
+}
+
 static inline int crypto_notify(unsigned long val, void *v)
 {
 	return blocking_notifier_call_chain(&amp;crypto_chain, val, v);
@@ -79,6 +84,9 @@ static struct crypto_alg *__crypto_alg_l
 	list_for_each_entry(q, &amp;crypto_alg_list, cra_list) {
 		int exact, fuzzy;
 
+		if (crypto_is_dead(q))
+			continue;
+
 		if ((q-&gt;cra_flags ^ type) &amp; mask)
 			continue;
 
@@ -212,7 +220,7 @@ struct crypto_alg *crypto_alg_mod_lookup
 	struct crypto_alg *larval;
 	int ok;
 
-	mask &amp;= ~CRYPTO_ALG_LARVAL;
+	mask &amp;= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
 	type &amp;= mask;
 
 	alg = try_then_request_module(crypto_alg_lookup(name, type, mask),
@@ -329,20 +337,15 @@ static unsigned int crypto_ctxsize(struc
 	return len + (alg-&gt;cra_alignmask &amp; ~(crypto_tfm_ctx_alignment() - 1));
 }
 
-struct crypto_tfm *crypto_alloc_tfm(const char *name, u32 flags)
+static struct crypto_tfm *__crypto_alloc_tfm(struct crypto_alg *alg, u32 flags)
 {
 	struct crypto_tfm *tfm = NULL;
-	struct crypto_alg *alg;
 	unsigned int tfm_size;
 
-	alg = crypto_alg_mod_lookup(name, 0, 0);
-	if (alg == NULL)
-		goto out;
-
 	tfm_size = sizeof(*tfm) + crypto_ctxsize(alg, flags);
 	tfm = kzalloc(tfm_size, GFP_KERNEL);
 	if (tfm == NULL)
-		goto out_put;
+		goto out;
 
 	tfm-&gt;__crt_alg = alg;
 	
@@ -362,8 +365,23 @@ cra_init_failed:
 out_free_tfm:
 	kfree(tfm);
 	tfm = NULL;
-out_put:
-	crypto_mod_put(alg);
+out:
+	return tfm;
+}
+
+struct crypto_tfm *crypto_alloc_tfm(const char *name, u32 flags)
+{
+	struct crypto_tfm *tfm = NULL;
+	struct crypto_alg *alg;
+
+	alg = crypto_alg_mod_lookup(name, 0, 0);
+	if (!alg)
+		goto out;
+
+	tfm = __crypto_alloc_tfm(alg, flags);
+	if (!tfm)
+		crypto_mod_put(alg);
+
 out:
 	return tfm;
 }
@@ -424,8 +442,14 @@ static int crypto_check_alg(struct crypt
 static int __crypto_register_alg(struct crypto_alg *alg)
 {
 	struct crypto_alg *q;
-	int ret = -EEXIST;
+	int ret = -ENOENT;
+
+	if (crypto_is_dead(alg))
+		goto out;
+
+	INIT_LIST_HEAD(&amp;alg-&gt;cra_users);
 
+	ret = -EEXIST;
 	atomic_set(&amp;alg-&gt;cra_refcnt, 1);
 	list_for_each_entry(q, &amp;crypto_alg_list, cra_list) {
 		if (q == alg)
@@ -468,16 +492,71 @@ int crypto_register_alg(struct crypto_al
 	return err;
 }
 
+static void crypto_destroy_instance(struct crypto_alg *alg)
+{
+	struct crypto_instance *inst = (void *)alg;
+	struct crypto_template *tmpl = inst-&gt;tmpl;
+
+	tmpl-&gt;free(inst);
+	crypto_tmpl_put(tmpl);
+}
+
+static int crypto_remove_alg(struct crypto_alg *alg, struct list_head *list)
+{
+	struct crypto_spawn *spawn, *n;
+	LIST_HEAD(spawns);
+
+	if (unlikely(list_empty(&amp;alg-&gt;cra_list)))
+		return -ENOENT;
+
+	alg-&gt;cra_flags |= CRYPTO_ALG_DEAD;
+
+	crypto_notify(CRYPTO_MSG_ALG_UNREGISTER, alg);
+	list_del_init(&amp;alg-&gt;cra_list);
+	list_splice(&amp;alg-&gt;cra_users, &amp;spawns);
+
+	list_for_each_entry_safe(spawn, n, &amp;spawns, list) {
+		struct crypto_instance *inst = spawn-&gt;inst;
+		struct crypto_template *tmpl = inst-&gt;tmpl;
+
+		list_del_init(&amp;spawn-&gt;list);
+		spawn-&gt;alg = NULL;
+
+		if (crypto_is_dead(&amp;inst-&gt;alg))
+			continue;
+
+		inst-&gt;alg.cra_flags |= CRYPTO_ALG_DEAD;
+		if (!tmpl || !crypto_tmpl_get(tmpl))
+			continue;
+
+		crypto_notify(CRYPTO_MSG_ALG_UNREGISTER, &amp;inst-&gt;alg);
+		list_move(&amp;inst-&gt;alg.cra_list, list);
+		hlist_del(&amp;inst-&gt;list);
+		list_splice(&amp;inst-&gt;alg.cra_users, spawns.prev);
+		inst-&gt;alg.cra_destroy = crypto_destroy_instance;
+	}
+
+	return 0;
+}
+
+static void crypto_remove_final(struct list_head *list)
+{
+	struct crypto_alg *alg;
+	struct crypto_alg *n;
+
+	list_for_each_entry_safe(alg, n, list, cra_list) {
+		list_del_init(&amp;alg-&gt;cra_list);
+		crypto_alg_put(alg);
+	}
+}
+
 int crypto_unregister_alg(struct crypto_alg *alg)
 {
-	int ret = -ENOENT;
+	int ret;
+	LIST_HEAD(list);
 	
 	down_write(&amp;crypto_alg_sem);
-	if (likely(!list_empty(&amp;alg-&gt;cra_list))) {
-		list_del_init(&amp;alg-&gt;cra_list);
-		ret = 0;
-	}
-	crypto_notify(CRYPTO_MSG_ALG_UNREGISTER, alg);
+	ret = crypto_remove_alg(alg, &amp;list);
 	up_write(&amp;crypto_alg_sem);
 
 	if (ret)
@@ -487,6 +566,7 @@ int crypto_unregister_alg(struct crypto_
 	if (alg-&gt;cra_destroy)
 		alg-&gt;cra_destroy(alg);
 
+	crypto_remove_final(&amp;list);
 	return 0;
 }
 
@@ -516,6 +596,7 @@ void crypto_unregister_template(struct c
 	struct crypto_instance *inst;
 	struct hlist_node *p, *n;
 	struct hlist_head *list;
+	LIST_HEAD(users);
 
 	down_write(&amp;crypto_alg_sem);
 
@@ -524,9 +605,8 @@ void crypto_unregister_template(struct c
 
 	list = &amp;tmpl-&gt;instances;
 	hlist_for_each_entry(inst, p, list, list) {
-		BUG_ON(list_empty(&amp;inst-&gt;alg.cra_list));
-		list_del_init(&amp;inst-&gt;alg.cra_list);
-		crypto_notify(CRYPTO_MSG_ALG_UNREGISTER, &amp;inst-&gt;alg);
+		int err = crypto_remove_alg(&amp;inst-&gt;alg, &amp;users);
+		BUG_ON(err);
 	}
 
 	crypto_notify(CRYPTO_MSG_TMPL_UNREGISTER, tmpl);
@@ -537,6 +617,7 @@ void crypto_unregister_template(struct c
 		BUG_ON(atomic_read(&amp;inst-&gt;alg.cra_refcnt) != 1);
 		tmpl-&gt;free(inst);
 	}
+	crypto_remove_final(&amp;users);
 }
 EXPORT_SYMBOL_GPL(crypto_unregister_template);
 
@@ -596,6 +677,57 @@ err:
 }
 EXPORT_SYMBOL_GPL(crypto_register_instance);
 
+int crypto_init_spawn(struct crypto_spawn *spawn, struct crypto_alg *alg,
+		      struct crypto_instance *inst)
+{
+	int err = -ENOENT;
+
+	spawn-&gt;inst = inst;
+
+	down_write(&amp;crypto_alg_sem);
+	if (!crypto_is_dead(alg)) {
+		list_add(&amp;spawn-&gt;list, &amp;alg-&gt;cra_users);
+		spawn-&gt;alg = alg;
+		err = 0;
+	}
+	up_write(&amp;crypto_alg_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(crypto_init_spawn);
+
+void crypto_drop_spawn(struct crypto_spawn *spawn)
+{
+	down_write(&amp;crypto_alg_sem);
+	list_del(&amp;spawn-&gt;list);
+	up_write(&amp;crypto_alg_sem);
+}
+EXPORT_SYMBOL_GPL(crypto_drop_spawn);
+
+struct crypto_tfm *crypto_spawn_tfm(struct crypto_spawn *spawn)
+{
+	struct crypto_alg *alg;
+	struct crypto_tfm *tfm;
+
+	down_read(&amp;crypto_alg_sem);
+	alg = spawn-&gt;alg;
+	if (alg &amp;&amp; !crypto_mod_get(alg))
+		alg = NULL;
+	up_read(&amp;crypto_alg_sem);
+
+	if (!alg)
+		return ERR_PTR(-ENOENT);
+
+	tfm = __crypto_alloc_tfm(alg, 0);
+	if (!tfm) {
+		crypto_mod_put(alg);
+		tfm = ERR_PTR(-ENOMEM);
+	}
+
+	return tfm;
+}
+EXPORT_SYMBOL_GPL(crypto_spawn_tfm);
+
 int crypto_alg_available(const char *name, u32 flags)
 {
 	int ret = 0;
diff --git a/crypto/internal.h b/crypto/internal.h
--- a/crypto/internal.h
+++ b/crypto/internal.h
@@ -65,6 +65,12 @@ struct crypto_larval {
 	u32 mask;
 };
 
+struct crypto_spawn {
+	struct list_head list;
+	struct crypto_alg *alg;
+	struct crypto_instance *inst;
+};
+
 extern struct list_head crypto_alg_list;
 extern struct rw_semaphore crypto_alg_sem;
 
@@ -163,6 +169,11 @@ int crypto_register_instance(struct cryp
 int crypto_register_notifier(struct notifier_block *nb);
 int crypto_unregister_notifier(struct notifier_block *nb);
 
+int crypto_init_spawn(struct crypto_spawn *spawn, struct crypto_alg *alg,
+		      struct crypto_instance *inst);
+void crypto_drop_spawn(struct crypto_spawn *spawn);
+struct crypto_tfm *crypto_spawn_tfm(struct crypto_spawn *spawn);
+
 static inline void *crypto_instance_ctx(struct crypto_instance *inst)
 {
 	return inst-&gt;__ctx;
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -34,6 +34,7 @@
 #define CRYPTO_ALG_TYPE_COMPRESS	0x00000004
 
 #define CRYPTO_ALG_LARVAL		0x00000010
+#define CRYPTO_ALG_DEAD			0x00000020
 
 /*
  * Transform masks and values (for crt_flags).
@@ -124,6 +125,8 @@ struct compress_alg {
 
 struct crypto_alg {
 	struct list_head cra_list;
+	struct list_head cra_users;
+
 	u32 cra_flags;
 	unsigned int cra_blocksize;
 	unsigned int cra_ctxsize;
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702142212</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-02 14:22:12-0400</timestampReceived><subject>[8/13] [CRYPTO] digest: Added direct SG update and digest interface</subject><body>

Hi:

[CRYPTO] digest: Added direct SG update and digest interface

This patch allows digest algorithms to provide an SG update function
as well as a direct digest function.  If the SG update function is
present, it will be used instead of the normal update interface.  That
is, the algorithm will be directly responsible for walking the SG list.

If the digest function is present, it will take precedence over the
generic digest function.  This can be used by hardware that is able
(and/or only able) to digest in one operation.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/digest.c b/crypto/digest.c
--- a/crypto/digest.c
+++ b/crypto/digest.c
@@ -18,11 +18,6 @@
 #include &lt;asm/scatterlist.h&gt;
 #include "internal.h"
 
-static void init(struct crypto_tfm *tfm)
-{
-	tfm-&gt;__crt_alg-&gt;cra_digest.dia_init(tfm);
-}
-
 static void update(struct crypto_tfm *tfm,
                    struct scatterlist *sg, unsigned int nsg)
 {
@@ -87,9 +82,11 @@ static int setkey(struct crypto_tfm *tfm
 static void digest(struct crypto_tfm *tfm,
                    struct scatterlist *sg, unsigned int nsg, u8 *out)
 {
-	init(tfm);
-	update(tfm, sg, nsg);
-	final(tfm, out);
+	struct digest_tfm *ops = &amp;tfm-&gt;crt_digest;
+
+	ops-&gt;dit_init(tfm);
+	ops-&gt;dit_update(tfm, sg, nsg);
+	ops-&gt;dit_final(tfm, out);
 }
 
 int crypto_init_digest_flags(struct crypto_tfm *tfm, u32 flags)
@@ -100,11 +97,13 @@ int crypto_init_digest_flags(struct cryp
 int crypto_init_digest_ops(struct crypto_tfm *tfm)
 {
 	struct digest_tfm *ops = &amp;tfm-&gt;crt_digest;
+	struct digest_alg *dalg = &amp;tfm-&gt;__crt_alg-&gt;cra_digest;
 	
-	ops-&gt;dit_init	= init;
-	ops-&gt;dit_update	= update;
-	ops-&gt;dit_final	= final;
-	ops-&gt;dit_digest	= digest;
+	ops-&gt;dit_init	= dalg-&gt;dia_init;
+	ops-&gt;dit_update	= dalg-&gt;dia_update_sg ?: update;
+	ops-&gt;dit_final	= crypto_tfm_alg_alignmask(tfm) ? dalg-&gt;dia_final :
+							  final;
+	ops-&gt;dit_digest	= dalg-&gt;dia_digest ?: digest;
 	ops-&gt;dit_setkey	= setkey;
 	
 	return crypto_alloc_hmac_block(tfm);
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -107,7 +107,11 @@ struct digest_alg {
 	void (*dia_init)(struct crypto_tfm *tfm);
 	void (*dia_update)(struct crypto_tfm *tfm, const u8 *data,
 			   unsigned int len);
+	void (*dia_update_sg)(struct crypto_tfm *tfm, struct scatterlist *sg,
+			      unsigned int nsg);
 	void (*dia_final)(struct crypto_tfm *tfm, u8 *out);
+	void (*dia_digest)(struct crypto_tfm *tfm, struct scatterlist *sg,
+	                   unsigned int nsg, u8 *out);
 	int (*dia_setkey)(struct crypto_tfm *tfm, const u8 *key,
 	                  unsigned int keylen, u32 *flags);
 };
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702164548</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-07-02 16:45:48-0400</timestampReceived><subject>Re: [8/13] [CRYPTO] digest: Added direct SG update and digest</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Mon, 3 Jul 2006 00:22:12 +1000

&gt; [CRYPTO] digest: Added direct SG update and digest interface
&gt; 
&gt; This patch allows digest algorithms to provide an SG update function
&gt; as well as a direct digest function.  If the SG update function is
&gt; present, it will be used instead of the normal update interface.  That
&gt; is, the algorithm will be directly responsible for walking the SG list.
&gt; 
&gt; If the digest function is present, it will take precedence over the
&gt; generic digest function.  This can be used by hardware that is able
&gt; (and/or only able) to digest in one operation.
&gt; 
&gt; Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

Looks good.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702142242</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-02 14:22:42-0400</timestampReceived><subject>[9/13] [CRYPTO] hmac: Add crypto template implementation</subject><body>

Hi:

[CRYPTO] hmac: Add crypto template implementation

This patch rewrites HMAC as a crypto template.  This means that HMAC is no
longer a hard-coded part of the API.  It's now a template that generates
standard digest algorithms like any other.

The old HMAC is preserved until all current users are converted.

The same structure can be used by other MACs such as AES-XCBC-MAC.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/Kconfig b/crypto/Kconfig
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -18,12 +18,16 @@ config CRYPTO_MANAGER
 	  cbc(aes).
 
 config CRYPTO_HMAC
-	bool "HMAC support"
+	tristate "HMAC support"
 	depends on CRYPTO
+	select CRYPTO_HMAC_OLD
 	help
 	  HMAC: Keyed-Hashing for Message Authentication (RFC2104).
 	  This is required for IPSec.
 
+config CRYPTO_HMAC_OLD
+	bool
+
 config CRYPTO_NULL
 	tristate "Null algorithms"
 	depends on CRYPTO
diff --git a/crypto/Makefile b/crypto/Makefile
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_CRYPTO) += api.o scatterwal
 
 obj-$(CONFIG_CRYPTO_MANAGER) += cryptomgr.o
 obj-$(CONFIG_CRYPTO_HMAC) += hmac.o
+obj-$(CONFIG_CRYPTO_HMAC_OLD) += hmac-old.o
 obj-$(CONFIG_CRYPTO_NULL) += crypto_null.o
 obj-$(CONFIG_CRYPTO_MD4) += md4.o
 obj-$(CONFIG_CRYPTO_MD5) += md5.o
diff --git a/crypto/hmac-old.c b/crypto/hmac-old.c
new file mode 100644
--- /dev/null
+++ b/crypto/hmac-old.c
@@ -0,0 +1,124 @@
+/*
+ * Cryptographic API.
+ *
+ * HMAC: Keyed-Hashing for Message Authentication (RFC2104).
+ *
+ * Copyright (c) 2002 James Morris &lt;jmorris@intercode.com.au&gt;
+ *
+ * The HMAC implementation is derived from USAGI.
+ * Copyright (c) 2002 Kazunori Miyazawa &lt;miyazawa@linux-ipv6.org&gt; / USAGI
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ */
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/mm.h&gt;
+#include &lt;linux/highmem.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include "internal.h"
+
+static void hash_key(struct crypto_tfm *tfm, u8 *key, unsigned int keylen)
+{
+	struct scatterlist tmp;
+	
+	sg_set_buf(&amp;tmp, key, keylen);
+	crypto_digest_digest(tfm, &amp;tmp, 1, key);
+}
+
+int crypto_alloc_hmac_block(struct crypto_tfm *tfm)
+{
+	int ret = 0;
+
+	BUG_ON(!crypto_tfm_alg_blocksize(tfm));
+	
+	tfm-&gt;crt_digest.dit_hmac_block = kmalloc(crypto_tfm_alg_blocksize(tfm),
+	                                         GFP_KERNEL);
+	if (tfm-&gt;crt_digest.dit_hmac_block == NULL)
+		ret = -ENOMEM;
+
+	return ret;
+		
+}
+
+void crypto_free_hmac_block(struct crypto_tfm *tfm)
+{
+	kfree(tfm-&gt;crt_digest.dit_hmac_block);
+}
+
+void crypto_hmac_init(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen)
+{
+	unsigned int i;
+	struct scatterlist tmp;
+	char *ipad = tfm-&gt;crt_digest.dit_hmac_block;
+	
+	if (*keylen &gt; crypto_tfm_alg_blocksize(tfm)) {
+		hash_key(tfm, key, *keylen);
+		*keylen = crypto_tfm_alg_digestsize(tfm);
+	}
+
+	memset(ipad, 0, crypto_tfm_alg_blocksize(tfm));
+	memcpy(ipad, key, *keylen);
+
+	for (i = 0; i &lt; crypto_tfm_alg_blocksize(tfm); i++)
+		ipad[i] ^= 0x36;
+
+	sg_set_buf(&amp;tmp, ipad, crypto_tfm_alg_blocksize(tfm));
+	
+	crypto_digest_init(tfm);
+	crypto_digest_update(tfm, &amp;tmp, 1);
+}
+
+void crypto_hmac_update(struct crypto_tfm *tfm,
+                        struct scatterlist *sg, unsigned int nsg)
+{
+	crypto_digest_update(tfm, sg, nsg);
+}
+
+void crypto_hmac_final(struct crypto_tfm *tfm, u8 *key,
+                       unsigned int *keylen, u8 *out)
+{
+	unsigned int i;
+	struct scatterlist tmp;
+	char *opad = tfm-&gt;crt_digest.dit_hmac_block;
+	
+	if (*keylen &gt; crypto_tfm_alg_blocksize(tfm)) {
+		hash_key(tfm, key, *keylen);
+		*keylen = crypto_tfm_alg_digestsize(tfm);
+	}
+
+	crypto_digest_final(tfm, out);
+
+	memset(opad, 0, crypto_tfm_alg_blocksize(tfm));
+	memcpy(opad, key, *keylen);
+		
+	for (i = 0; i &lt; crypto_tfm_alg_blocksize(tfm); i++)
+		opad[i] ^= 0x5c;
+
+	sg_set_buf(&amp;tmp, opad, crypto_tfm_alg_blocksize(tfm));
+
+	crypto_digest_init(tfm);
+	crypto_digest_update(tfm, &amp;tmp, 1);
+	
+	sg_set_buf(&amp;tmp, out, crypto_tfm_alg_digestsize(tfm));
+	
+	crypto_digest_update(tfm, &amp;tmp, 1);
+	crypto_digest_final(tfm, out);
+}
+
+void crypto_hmac(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen,
+                 struct scatterlist *sg, unsigned int nsg, u8 *out)
+{
+	crypto_hmac_init(tfm, key, keylen);
+	crypto_hmac_update(tfm, sg, nsg);
+	crypto_hmac_final(tfm, key, keylen, out);
+}
+
+EXPORT_SYMBOL_GPL(crypto_hmac_init);
+EXPORT_SYMBOL_GPL(crypto_hmac_update);
+EXPORT_SYMBOL_GPL(crypto_hmac_final);
+EXPORT_SYMBOL_GPL(crypto_hmac);
+
diff --git a/crypto/hmac.c b/crypto/hmac.c
--- a/crypto/hmac.c
+++ b/crypto/hmac.c
@@ -4,121 +4,227 @@
  * HMAC: Keyed-Hashing for Message Authentication (RFC2104).
  *
  * Copyright (c) 2002 James Morris &lt;jmorris@intercode.com.au&gt;
+ * Copyright (c) 2006 Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
  *
  * The HMAC implementation is derived from USAGI.
  * Copyright (c) 2002 Kazunori Miyazawa &lt;miyazawa@linux-ipv6.org&gt; / USAGI
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option) 
+ * Software Foundation; either version 2 of the License, or (at your option)
  * any later version.
  *
  */
 #include &lt;linux/crypto.h&gt;
+#include &lt;linux/err.h&gt;
+#include &lt;linux/kernel.h&gt;
 #include &lt;linux/mm.h&gt;
-#include &lt;linux/highmem.h&gt;
+#include &lt;linux/rtnetlink.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/scatterlist.h&gt;
 #include "internal.h"
 
-static void hash_key(struct crypto_tfm *tfm, u8 *key, unsigned int keylen)
+struct crypto_hmac_ctx {
+	struct crypto_tfm *child;
+};
+
+static inline struct crypto_hmac_ctx *crypto_hmac_ctx(struct crypto_tfm *tfm)
 {
-	struct scatterlist tmp;
-	
-	sg_set_buf(&amp;tmp, key, keylen);
-	crypto_digest_digest(tfm, &amp;tmp, 1, key);
+	return (void *)((char *)crypto_tfm_ctx_aligned(tfm) +
+			crypto_tfm_alg_blocksize(tfm) * 2);
 }
 
-int crypto_alloc_hmac_block(struct crypto_tfm *tfm)
+static int crypto_hmac_digest_setkey(struct crypto_tfm *parent,
+				     const u8 *inkey, unsigned int keylen,
+				     u32 *flags)
 {
-	int ret = 0;
+	int bs = crypto_tfm_alg_blocksize(parent);
+	char *key = crypto_tfm_ctx_aligned(parent);
+	char *pad = key + bs;
+	struct crypto_hmac_ctx *ctx = (void *)(pad + bs);
+	struct crypto_tfm *child = ctx-&gt;child;
 
-	BUG_ON(!crypto_tfm_alg_blocksize(tfm));
-	
-	tfm-&gt;crt_digest.dit_hmac_block = kmalloc(crypto_tfm_alg_blocksize(tfm),
-	                                         GFP_KERNEL);
-	if (tfm-&gt;crt_digest.dit_hmac_block == NULL)
-		ret = -ENOMEM;
+	if (keylen &gt; bs) {
+		struct scatterlist tmp;
 
-	return ret;
-		
-}
+		sg_set_buf(&amp;tmp, (void *)inkey, keylen);
+		crypto_digest_digest(child, &amp;tmp, 1, pad);
+		inkey = pad;
+		keylen = crypto_tfm_alg_digestsize(parent);
+	}
 
-void crypto_free_hmac_block(struct crypto_tfm *tfm)
-{
-	kfree(tfm-&gt;crt_digest.dit_hmac_block);
+	memcpy(key, inkey, keylen);
+	memset(key + keylen, 0, bs - keylen);
+	return 0;
 }
 
-void crypto_hmac_init(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen)
-{
+static void crypto_hmac_digest_init(struct crypto_tfm *parent)
+{
+	int bs = crypto_tfm_alg_blocksize(parent);
+	char *key = crypto_tfm_ctx_aligned(parent);
+	char *ipad = key + bs;
+	struct crypto_hmac_ctx *ctx = (void *)(ipad + bs);
+	struct crypto_tfm *tfm = ctx-&gt;child;
 	unsigned int i;
 	struct scatterlist tmp;
-	char *ipad = tfm-&gt;crt_digest.dit_hmac_block;
-	
-	if (*keylen &gt; crypto_tfm_alg_blocksize(tfm)) {
-		hash_key(tfm, key, *keylen);
-		*keylen = crypto_tfm_alg_digestsize(tfm);
-	}
 
-	memset(ipad, 0, crypto_tfm_alg_blocksize(tfm));
-	memcpy(ipad, key, *keylen);
+	memcpy(ipad, key, bs);
 
-	for (i = 0; i &lt; crypto_tfm_alg_blocksize(tfm); i++)
+	for (i = 0; i &lt; bs; i++)
 		ipad[i] ^= 0x36;
 
-	sg_set_buf(&amp;tmp, ipad, crypto_tfm_alg_blocksize(tfm));
-	
+	sg_set_buf(&amp;tmp, ipad, bs);
+
 	crypto_digest_init(tfm);
 	crypto_digest_update(tfm, &amp;tmp, 1);
 }
 
-void crypto_hmac_update(struct crypto_tfm *tfm,
-                        struct scatterlist *sg, unsigned int nsg)
+static void crypto_hmac_digest_update(struct crypto_tfm *parent,
+				      struct scatterlist *sg, unsigned int nsg)
 {
-	crypto_digest_update(tfm, sg, nsg);
+	struct crypto_hmac_ctx *ctx = crypto_hmac_ctx(parent);
+	crypto_digest_update(ctx-&gt;child, sg, nsg);
 }
 
-void crypto_hmac_final(struct crypto_tfm *tfm, u8 *key,
-                       unsigned int *keylen, u8 *out)
+static void crypto_hmac_digest_final(struct crypto_tfm *parent, u8 *out)
 {
+	int bs = crypto_tfm_alg_blocksize(parent);
+	char *key = crypto_tfm_ctx(parent);
+	char *opad = key + bs;
+	struct crypto_hmac_ctx *ctx = (void *)(opad + bs);
+	struct crypto_tfm *tfm = ctx-&gt;child;
 	unsigned int i;
 	struct scatterlist tmp;
-	char *opad = tfm-&gt;crt_digest.dit_hmac_block;
-	
-	if (*keylen &gt; crypto_tfm_alg_blocksize(tfm)) {
-		hash_key(tfm, key, *keylen);
-		*keylen = crypto_tfm_alg_digestsize(tfm);
-	}
 
 	crypto_digest_final(tfm, out);
 
-	memset(opad, 0, crypto_tfm_alg_blocksize(tfm));
-	memcpy(opad, key, *keylen);
-		
-	for (i = 0; i &lt; crypto_tfm_alg_blocksize(tfm); i++)
+	memcpy(opad, key, bs);
+
+	for (i = 0; i &lt; bs; i++)
 		opad[i] ^= 0x5c;
 
-	sg_set_buf(&amp;tmp, opad, crypto_tfm_alg_blocksize(tfm));
+	sg_set_buf(&amp;tmp, opad, bs);
 
 	crypto_digest_init(tfm);
 	crypto_digest_update(tfm, &amp;tmp, 1);
-	
+
 	sg_set_buf(&amp;tmp, out, crypto_tfm_alg_digestsize(tfm));
-	
+
 	crypto_digest_update(tfm, &amp;tmp, 1);
 	crypto_digest_final(tfm, out);
 }
 
-void crypto_hmac(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen,
-                 struct scatterlist *sg, unsigned int nsg, u8 *out)
+static int crypto_hmac_init_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_instance *inst = (void *)tfm-&gt;__crt_alg;
+	struct crypto_spawn *spawn = crypto_instance_ctx(inst);
+	struct crypto_hmac_ctx *ctx = crypto_hmac_ctx(tfm);
+
+	ctx-&gt;child = crypto_spawn_tfm(spawn);
+	if (IS_ERR(ctx-&gt;child))
+		return PTR_ERR(ctx-&gt;child);
+
+	return 0;
+}
+
+static void crypto_hmac_exit_tfm(struct crypto_tfm *tfm)
+{
+	crypto_free_tfm(crypto_hmac_ctx(tfm)-&gt;child);
+}
+
+static struct crypto_instance *crypto_hmac_alloc(void *param, unsigned int len)
+{
+	struct rtattr *rta = param;
+	struct crypto_instance *inst;
+	struct crypto_attr_alg *alga;
+	struct crypto_alg *alg;
+	struct crypto_spawn *spawn;
+	int err;
+
+	if (!RTA_OK(rta, len))
+		return ERR_PTR(-EBADR);
+	if (rta-&gt;rta_type != CRYPTOA_ALG || RTA_PAYLOAD(rta) &lt; sizeof(*alga))
+		return ERR_PTR(-EINVAL);
+
+	alga = RTA_DATA(rta);
+
+	inst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);
+	if (!inst)
+		return ERR_PTR(-ENOMEM);
+
+	inst-&gt;alg.cra_flags = CRYPTO_ALG_TYPE_DIGEST;
+
+	err = -ENOENT;
+	alg = crypto_alg_mod_lookup(alga-&gt;name, CRYPTO_ALG_TYPE_DIGEST,
+				    CRYPTO_ALG_TYPE_MASK);
+	if (!alg)
+		goto err_free_inst;
+
+	err = -ENAMETOOLONG;
+	if (snprintf(inst-&gt;alg.cra_name, CRYPTO_MAX_ALG_NAME,
+		     "hmac(%s)", alg-&gt;cra_name) &gt;= CRYPTO_MAX_ALG_NAME)
+		goto put_alg;
+
+	if (snprintf(inst-&gt;alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,
+		     "hmac(%s)", alg-&gt;cra_driver_name) &gt;= CRYPTO_MAX_ALG_NAME)
+		goto put_alg;
+
+	spawn = crypto_instance_ctx(inst);
+	err = crypto_init_spawn(spawn, alg, inst);
+
+put_alg:
+	crypto_mod_put(alg);
+	if (err)
+		goto err_free_inst;
+
+	inst-&gt;alg.cra_priority = alg-&gt;cra_priority;
+	inst-&gt;alg.cra_blocksize = alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_alignmask = alg-&gt;cra_alignmask;
+	inst-&gt;alg.cra_digest.dia_digestsize = alg-&gt;cra_digest.dia_digestsize;
+
+	inst-&gt;alg.cra_ctxsize = sizeof(struct crypto_hmac_ctx) +
+				inst-&gt;alg.cra_blocksize * 2;
+
+	inst-&gt;alg.cra_init = crypto_hmac_init_tfm;
+	inst-&gt;alg.cra_exit = crypto_hmac_exit_tfm;
+
+	inst-&gt;alg.cra_digest.dia_init = crypto_hmac_digest_init;
+	inst-&gt;alg.cra_digest.dia_update_sg = crypto_hmac_digest_update;
+	inst-&gt;alg.cra_digest.dia_final = crypto_hmac_digest_final;
+	inst-&gt;alg.cra_digest.dia_setkey = crypto_hmac_digest_setkey;
+
+	return inst;
+
+err_free_inst:
+	kfree(inst);
+	return ERR_PTR(err);
+}
+
+static void crypto_hmac_free(struct crypto_instance *inst)
+{
+	crypto_drop_spawn(crypto_instance_ctx(inst));
+	kfree(inst);
+}
+
+static struct crypto_template crypto_hmac_tmpl = {
+	.name = "hmac",
+	.alloc = crypto_hmac_alloc,
+	.free = crypto_hmac_free,
+	.module = THIS_MODULE,
+};
+
+static int __init crypto_hmac_module_init(void)
+{
+	return crypto_register_template(&amp;crypto_hmac_tmpl);
+}
+
+static void __exit crypto_hmac_module_exit(void)
 {
-	crypto_hmac_init(tfm, key, keylen);
-	crypto_hmac_update(tfm, sg, nsg);
-	crypto_hmac_final(tfm, key, keylen, out);
+	crypto_unregister_template(&amp;crypto_hmac_tmpl);
 }
 
-EXPORT_SYMBOL_GPL(crypto_hmac_init);
-EXPORT_SYMBOL_GPL(crypto_hmac_update);
-EXPORT_SYMBOL_GPL(crypto_hmac_final);
-EXPORT_SYMBOL_GPL(crypto_hmac);
+module_init(crypto_hmac_module_init);
+module_exit(crypto_hmac_module_exit);
 
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("HMAC digest algorithm");
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -334,6 +334,16 @@ static inline unsigned int crypto_tfm_ct
 	return __alignof__(tfm-&gt;__crt_ctx);
 }
 
+static inline void *crypto_tfm_ctx_aligned(struct crypto_tfm *tfm)
+{
+	unsigned long addr = (unsigned long)crypto_tfm_ctx(tfm);
+	unsigned long align = crypto_tfm_alg_alignmask(tfm);
+
+	if (align &lt;= crypto_tfm_ctx_alignment())
+		align = 1;
+	return (void *)ALIGN(addr, align);
+}
+
 /*
  * API wrappers.
  */
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702164632</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-07-02 16:46:32-0400</timestampReceived><subject>Re: [9/13] [CRYPTO] hmac: Add crypto template implementation</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Mon, 3 Jul 2006 00:22:42 +1000

&gt; [CRYPTO] hmac: Add crypto template implementation
&gt; 
&gt; This patch rewrites HMAC as a crypto template.  This means that HMAC is no
&gt; longer a hard-coded part of the API.  It's now a template that generates
&gt; standard digest algorithms like any other.
&gt; 
&gt; The old HMAC is preserved until all current users are converted.
&gt; 
&gt; The same structure can be used by other MACs such as AES-XCBC-MAC.
&gt; 
&gt; Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

This looks very nice.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702142309</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-02 14:23:09-0400</timestampReceived><subject>[10/13] [CRYPTO] tcrypt: Use HMAC template</subject><body>

Hi:

[CRYPTO] tcrypt: Use HMAC template

This patch converts tcrypt to use the new HMAC template rather than the
hard-coded version of HMAC.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -117,13 +117,10 @@ static void test_hash(char *algo, struct
 
 		sg_set_buf(&amp;sg[0], hash_tv[i].plaintext, hash_tv[i].psize);
 
-		crypto_digest_init(tfm);
-		if (tfm-&gt;crt_u.digest.dit_setkey) {
+		if (hash_tv[i].ksize)
 			crypto_digest_setkey(tfm, hash_tv[i].key,
 					     hash_tv[i].ksize);
-		}
-		crypto_digest_update(tfm, sg, 1);
-		crypto_digest_final(tfm, result);
+		crypto_digest_digest(tfm, sg, 1, result);
 
 		hexdump(result, crypto_tfm_alg_digestsize(tfm));
 		printk("%s\n",
@@ -154,6 +151,9 @@ static void test_hash(char *algo, struct
 					    hash_tv[i].tap[k]);
 			}
 
+			if (hash_tv[i].ksize)
+				crypto_digest_setkey(tfm, hash_tv[i].key,
+						     hash_tv[i].ksize);
 			crypto_digest_digest(tfm, sg, hash_tv[i].np, result);
 
 			hexdump(result, crypto_tfm_alg_digestsize(tfm));
@@ -167,92 +167,6 @@ static void test_hash(char *algo, struct
 	crypto_free_tfm(tfm);
 }
 
-
-#ifdef CONFIG_CRYPTO_HMAC
-
-static void test_hmac(char *algo, struct hmac_testvec *template,
-		      unsigned int tcount)
-{
-	unsigned int i, j, k, temp;
-	struct scatterlist sg[8];
-	char result[64];
-	struct crypto_tfm *tfm;
-	struct hmac_testvec *hmac_tv;
-	unsigned int tsize, klen;
-
-	tfm = crypto_alloc_tfm(algo, 0);
-	if (tfm == NULL) {
-		printk("failed to load transform for %s\n", algo);
-		return;
-	}
-
-	printk("\ntesting hmac_%s\n", algo);
-
-	tsize = sizeof(struct hmac_testvec);
-	tsize *= tcount;
-	if (tsize &gt; TVMEMSIZE) {
-		printk("template (%u) too big for tvmem (%u)\n", tsize,
-		       TVMEMSIZE);
-		goto out;
-	}
-
-	memcpy(tvmem, template, tsize);
-	hmac_tv = (void *)tvmem;
-
-	for (i = 0; i &lt; tcount; i++) {
-		printk("test %u:\n", i + 1);
-		memset(result, 0, sizeof (result));
-
-		klen = hmac_tv[i].ksize;
-		sg_set_buf(&amp;sg[0], hmac_tv[i].plaintext, hmac_tv[i].psize);
-
-		crypto_hmac(tfm, hmac_tv[i].key, &amp;klen, sg, 1, result);
-
-		hexdump(result, crypto_tfm_alg_digestsize(tfm));
-		printk("%s\n",
-		       memcmp(result, hmac_tv[i].digest,
-			      crypto_tfm_alg_digestsize(tfm)) ? "fail" :
-		       "pass");
-	}
-
-	printk("\ntesting hmac_%s across pages\n", algo);
-
-	memset(xbuf, 0, XBUFSIZE);
-
-	j = 0;
-	for (i = 0; i &lt; tcount; i++) {
-		if (hmac_tv[i].np) {
-			j++;
-			printk("test %u:\n",j);
-			memset(result, 0, 64);
-
-			temp = 0;
-			klen = hmac_tv[i].ksize;
-			for (k = 0; k &lt; hmac_tv[i].np; k++) {
-				memcpy(&amp;xbuf[IDX[k]],
-				       hmac_tv[i].plaintext + temp,
-				       hmac_tv[i].tap[k]);
-				temp += hmac_tv[i].tap[k];
-				sg_set_buf(&amp;sg[k], &amp;xbuf[IDX[k]],
-					    hmac_tv[i].tap[k]);
-			}
-
-			crypto_hmac(tfm, hmac_tv[i].key, &amp;klen, sg,
-				    hmac_tv[i].np, result);
-			hexdump(result, crypto_tfm_alg_digestsize(tfm));
-
-			printk("%s\n",
-			       memcmp(result, hmac_tv[i].digest,
-				      crypto_tfm_alg_digestsize(tfm)) ?
-			       "fail" : "pass");
-		}
-	}
-out:
-	crypto_free_tfm(tfm);
-}
-
-#endif	/* CONFIG_CRYPTO_HMAC */
-
 static void test_cipher(char *algo, int mode, int enc,
 			struct cipher_testvec *template, unsigned int tcount)
 {
@@ -969,11 +883,12 @@ static void do_test(void)
 		test_hash("tgr128", tgr128_tv_template, TGR128_TEST_VECTORS);
 		test_deflate();
 		test_crc32c();
-#ifdef CONFIG_CRYPTO_HMAC
-		test_hmac("md5", hmac_md5_tv_template, HMAC_MD5_TEST_VECTORS);
-		test_hmac("sha1", hmac_sha1_tv_template, HMAC_SHA1_TEST_VECTORS);
-		test_hmac("sha256", hmac_sha256_tv_template, HMAC_SHA256_TEST_VECTORS);
-#endif
+		test_hash("hmac(md5)", hmac_md5_tv_template,
+			  HMAC_MD5_TEST_VECTORS);
+		test_hash("hmac(sha1)", hmac_sha1_tv_template,
+			  HMAC_SHA1_TEST_VECTORS);
+		test_hash("hmac(sha256)", hmac_sha256_tv_template,
+			  HMAC_SHA256_TEST_VECTORS);
 
 		test_hash("michael_mic", michael_mic_tv_template, MICHAEL_MIC_TEST_VECTORS);
 		break;
@@ -1124,20 +1039,21 @@ static void do_test(void)
 		test_cipher ("xeta", MODE_ECB, DECRYPT, xeta_dec_tv_template, XETA_DEC_TEST_VECTORS);
 		break;
 
-#ifdef CONFIG_CRYPTO_HMAC
 	case 100:
-		test_hmac("md5", hmac_md5_tv_template, HMAC_MD5_TEST_VECTORS);
+		test_hash("hmac(md5)", hmac_md5_tv_template,
+			  HMAC_MD5_TEST_VECTORS);
 		break;
 
 	case 101:
-		test_hmac("sha1", hmac_sha1_tv_template, HMAC_SHA1_TEST_VECTORS);
+		test_hash("hmac(sha1)", hmac_sha1_tv_template,
+			  HMAC_SHA1_TEST_VECTORS);
 		break;
 
 	case 102:
-		test_hmac("sha256", hmac_sha256_tv_template, HMAC_SHA256_TEST_VECTORS);
+		test_hash("hmac(sha256)", hmac_sha256_tv_template,
+			  HMAC_SHA256_TEST_VECTORS);
 		break;
 
-#endif
 
 	case 200:
 		test_cipher_speed("aes", MODE_ECB, ENCRYPT, sec, NULL, 0,
diff --git a/crypto/tcrypt.h b/crypto/tcrypt.h
--- a/crypto/tcrypt.h
+++ b/crypto/tcrypt.h
@@ -36,16 +36,6 @@ struct hash_testvec {
 	unsigned char ksize;
 };
 
-struct hmac_testvec {
-	char key[128];
-	char plaintext[128];
-	char digest[MAX_DIGEST_SIZE];
-	unsigned char tap[MAX_TAP];
-	unsigned char ksize;
-	unsigned char psize;
-	unsigned char np;
-};
-
 struct cipher_testvec {
 	char key[MAX_KEYLEN] __attribute__ ((__aligned__(4)));
 	char iv[MAX_IVLEN];
@@ -697,14 +687,13 @@ static struct hash_testvec tgr128_tv_tem
 	},
 };
 
-#ifdef CONFIG_CRYPTO_HMAC
 /*
  * HMAC-MD5 test vectors from RFC2202
  * (These need to be fixed to not use strlen).
  */
 #define HMAC_MD5_TEST_VECTORS	7
 
-static struct hmac_testvec hmac_md5_tv_template[] =
+static struct hash_testvec hmac_md5_tv_template[] =
 {
 	{
 		.key	= { [0 ... 15] =  0x0b },
@@ -768,7 +757,7 @@ static struct hmac_testvec hmac_md5_tv_t
  */
 #define HMAC_SHA1_TEST_VECTORS	7
 
-static struct hmac_testvec hmac_sha1_tv_template[] = {
+static struct hash_testvec hmac_sha1_tv_template[] = {
 	{
 		.key	= { [0 ... 19] = 0x0b },
 		.ksize	= 20,
@@ -833,7 +822,7 @@ static struct hmac_testvec hmac_sha1_tv_
  */
 #define HMAC_SHA256_TEST_VECTORS	10
 
-static struct hmac_testvec hmac_sha256_tv_template[] = {
+static struct hash_testvec hmac_sha256_tv_template[] = {
 	{
 		.key	= { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
 			    0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
@@ -944,8 +933,6 @@ static struct hmac_testvec hmac_sha256_t
 	},
 };
 
-#endif	/* CONFIG_CRYPTO_HMAC */
-
 /*
  * DES test vectors.
  */
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702164654</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-07-02 16:46:54-0400</timestampReceived><subject>Re: [10/13] [CRYPTO] tcrypt: Use HMAC template</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Mon, 3 Jul 2006 00:23:09 +1000

&gt; [CRYPTO] tcrypt: Use HMAC template
&gt; 
&gt; This patch converts tcrypt to use the new HMAC template rather than the
&gt; hard-coded version of HMAC.
&gt; 
&gt; Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702142501</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-02 14:25:01-0400</timestampReceived><subject>[13/13] [CRYPTO] digest: Removed old HMAC implementation</subject><body>

Hi:

[CRYPTO] digest: Removed old HMAC implementation

This patch removes the old HMAC implementation now that nobody uses it
anymore.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/Kconfig b/crypto/Kconfig
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -20,14 +20,10 @@ config CRYPTO_MANAGER
 config CRYPTO_HMAC
 	tristate "HMAC support"
 	depends on CRYPTO
-	select CRYPTO_HMAC_OLD
 	help
 	  HMAC: Keyed-Hashing for Message Authentication (RFC2104).
 	  This is required for IPSec.
 
-config CRYPTO_HMAC_OLD
-	bool
-
 config CRYPTO_NULL
 	tristate "Null algorithms"
 	depends on CRYPTO
diff --git a/crypto/Makefile b/crypto/Makefile
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -9,7 +9,6 @@ obj-$(CONFIG_CRYPTO) += api.o scatterwal
 
 obj-$(CONFIG_CRYPTO_MANAGER) += cryptomgr.o
 obj-$(CONFIG_CRYPTO_HMAC) += hmac.o
-obj-$(CONFIG_CRYPTO_HMAC_OLD) += hmac-old.o
 obj-$(CONFIG_CRYPTO_NULL) += crypto_null.o
 obj-$(CONFIG_CRYPTO_MD4) += md4.o
 obj-$(CONFIG_CRYPTO_MD5) += md5.o
diff --git a/crypto/digest.c b/crypto/digest.c
--- a/crypto/digest.c
+++ b/crypto/digest.c
@@ -106,10 +106,9 @@ int crypto_init_digest_ops(struct crypto
 	ops-&gt;dit_digest	= dalg-&gt;dia_digest ?: digest;
 	ops-&gt;dit_setkey	= setkey;
 	
-	return crypto_alloc_hmac_block(tfm);
+	return 0;
 }
 
 void crypto_exit_digest_ops(struct crypto_tfm *tfm)
 {
-	crypto_free_hmac_block(tfm);
 }
diff --git a/crypto/hmac-old.c b/crypto/hmac-old.c
deleted file mode 100644
--- a/crypto/hmac-old.c
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * Cryptographic API.
- *
- * HMAC: Keyed-Hashing for Message Authentication (RFC2104).
- *
- * Copyright (c) 2002 James Morris &lt;jmorris@intercode.com.au&gt;
- *
- * The HMAC implementation is derived from USAGI.
- * Copyright (c) 2002 Kazunori Miyazawa &lt;miyazawa@linux-ipv6.org&gt; / USAGI
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option) 
- * any later version.
- *
- */
-#include &lt;linux/crypto.h&gt;
-#include &lt;linux/mm.h&gt;
-#include &lt;linux/highmem.h&gt;
-#include &lt;linux/slab.h&gt;
-#include &lt;linux/scatterlist.h&gt;
-#include "internal.h"
-
-static void hash_key(struct crypto_tfm *tfm, u8 *key, unsigned int keylen)
-{
-	struct scatterlist tmp;
-	
-	sg_set_buf(&amp;tmp, key, keylen);
-	crypto_digest_digest(tfm, &amp;tmp, 1, key);
-}
-
-int crypto_alloc_hmac_block(struct crypto_tfm *tfm)
-{
-	int ret = 0;
-
-	BUG_ON(!crypto_tfm_alg_blocksize(tfm));
-	
-	tfm-&gt;crt_digest.dit_hmac_block = kmalloc(crypto_tfm_alg_blocksize(tfm),
-	                                         GFP_KERNEL);
-	if (tfm-&gt;crt_digest.dit_hmac_block == NULL)
-		ret = -ENOMEM;
-
-	return ret;
-		
-}
-
-void crypto_free_hmac_block(struct crypto_tfm *tfm)
-{
-	kfree(tfm-&gt;crt_digest.dit_hmac_block);
-}
-
-void crypto_hmac_init(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen)
-{
-	unsigned int i;
-	struct scatterlist tmp;
-	char *ipad = tfm-&gt;crt_digest.dit_hmac_block;
-	
-	if (*keylen &gt; crypto_tfm_alg_blocksize(tfm)) {
-		hash_key(tfm, key, *keylen);
-		*keylen = crypto_tfm_alg_digestsize(tfm);
-	}
-
-	memset(ipad, 0, crypto_tfm_alg_blocksize(tfm));
-	memcpy(ipad, key, *keylen);
-
-	for (i = 0; i &lt; crypto_tfm_alg_blocksize(tfm); i++)
-		ipad[i] ^= 0x36;
-
-	sg_set_buf(&amp;tmp, ipad, crypto_tfm_alg_blocksize(tfm));
-	
-	crypto_digest_init(tfm);
-	crypto_digest_update(tfm, &amp;tmp, 1);
-}
-
-void crypto_hmac_update(struct crypto_tfm *tfm,
-                        struct scatterlist *sg, unsigned int nsg)
-{
-	crypto_digest_update(tfm, sg, nsg);
-}
-
-void crypto_hmac_final(struct crypto_tfm *tfm, u8 *key,
-                       unsigned int *keylen, u8 *out)
-{
-	unsigned int i;
-	struct scatterlist tmp;
-	char *opad = tfm-&gt;crt_digest.dit_hmac_block;
-	
-	if (*keylen &gt; crypto_tfm_alg_blocksize(tfm)) {
-		hash_key(tfm, key, *keylen);
-		*keylen = crypto_tfm_alg_digestsize(tfm);
-	}
-
-	crypto_digest_final(tfm, out);
-
-	memset(opad, 0, crypto_tfm_alg_blocksize(tfm));
-	memcpy(opad, key, *keylen);
-		
-	for (i = 0; i &lt; crypto_tfm_alg_blocksize(tfm); i++)
-		opad[i] ^= 0x5c;
-
-	sg_set_buf(&amp;tmp, opad, crypto_tfm_alg_blocksize(tfm));
-
-	crypto_digest_init(tfm);
-	crypto_digest_update(tfm, &amp;tmp, 1);
-	
-	sg_set_buf(&amp;tmp, out, crypto_tfm_alg_digestsize(tfm));
-	
-	crypto_digest_update(tfm, &amp;tmp, 1);
-	crypto_digest_final(tfm, out);
-}
-
-void crypto_hmac(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen,
-                 struct scatterlist *sg, unsigned int nsg, u8 *out)
-{
-	crypto_hmac_init(tfm, key, keylen);
-	crypto_hmac_update(tfm, sg, nsg);
-	crypto_hmac_final(tfm, key, keylen, out);
-}
-
-EXPORT_SYMBOL_GPL(crypto_hmac_init);
-EXPORT_SYMBOL_GPL(crypto_hmac_update);
-EXPORT_SYMBOL_GPL(crypto_hmac_final);
-EXPORT_SYMBOL_GPL(crypto_hmac);
-
diff --git a/crypto/internal.h b/crypto/internal.h
--- a/crypto/internal.h
+++ b/crypto/internal.h
@@ -97,19 +97,6 @@ static inline void crypto_yield(struct c
 		cond_resched();
 }
 
-#ifdef CONFIG_CRYPTO_HMAC
-int crypto_alloc_hmac_block(struct crypto_tfm *tfm);
-void crypto_free_hmac_block(struct crypto_tfm *tfm);
-#else
-static inline int crypto_alloc_hmac_block(struct crypto_tfm *tfm)
-{
-	return 0;
-}
-
-static inline void crypto_free_hmac_block(struct crypto_tfm *tfm)
-{ }
-#endif
-
 #ifdef CONFIG_PROC_FS
 void __init crypto_init_proc(void);
 #else
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -213,9 +213,6 @@ struct digest_tfm {
 	                   unsigned int nsg, u8 *out);
 	int (*dit_setkey)(struct crypto_tfm *tfm,
 	                  const u8 *key, unsigned int keylen);
-#ifdef CONFIG_CRYPTO_HMAC
-	void *dit_hmac_block;
-#endif
 };
 
 struct compress_tfm {
@@ -459,18 +456,5 @@ static inline int crypto_comp_decompress
 	return tfm-&gt;crt_compress.cot_decompress(tfm, src, slen, dst, dlen);
 }
 
-/*
- * HMAC support.
- */
-#ifdef CONFIG_CRYPTO_HMAC
-void crypto_hmac_init(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen);
-void crypto_hmac_update(struct crypto_tfm *tfm,
-                        struct scatterlist *sg, unsigned int nsg);
-void crypto_hmac_final(struct crypto_tfm *tfm, u8 *key,
-                       unsigned int *keylen, u8 *out);
-void crypto_hmac(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen,
-                 struct scatterlist *sg, unsigned int nsg, u8 *out);
-#endif	/* CONFIG_CRYPTO_HMAC */
-
 #endif	/* _LINUX_CRYPTO_H */
 
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702142009</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-02 14:20:09-0400</timestampReceived><subject>[3/13] [CRYPTO] api: Add template registration</subject><body>

Hi:

[CRYPTO] api: Add template registration

A crypto_template generates a crypto_alg object when given a set of
parameters.  this patch adds the basic data structure fo templates
and code to handle their registration/deregistration.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -18,6 +18,7 @@
 #include &lt;linux/compiler.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/crypto.h&gt;
+#include &lt;linux/err.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/kmod.h&gt;
@@ -27,6 +28,7 @@
 #include "internal.h"
 
 LIST_HEAD(crypto_alg_list);
+static LIST_HEAD(crypto_template_list);
 DECLARE_RWSEM(crypto_alg_sem);
 
 static inline struct crypto_alg *crypto_alg_get(struct crypto_alg *alg)
@@ -256,11 +258,8 @@ static inline int crypto_set_driver_name
 	return 0;
 }
 
-int crypto_register_alg(struct crypto_alg *alg)
+static int crypto_check_alg(struct crypto_alg *alg)
 {
-	int ret;
-	struct crypto_alg *q;
-
 	if (alg-&gt;cra_alignmask &amp; (alg-&gt;cra_alignmask + 1))
 		return -EINVAL;
 
@@ -273,40 +272,50 @@ int crypto_register_alg(struct crypto_al
 	if (alg-&gt;cra_priority &lt; 0)
 		return -EINVAL;
 	
-	ret = crypto_set_driver_name(alg);
-	if (unlikely(ret))
-		return ret;
+	return crypto_set_driver_name(alg);
+}
+
+static int __crypto_register_alg(struct crypto_alg *alg)
+{
+	struct crypto_alg *q;
+	int ret = -EEXIST;
 
-	down_write(&amp;crypto_alg_sem);
-	
 	list_for_each_entry(q, &amp;crypto_alg_list, cra_list) {
-		if (q == alg) {
-			ret = -EEXIST;
+		if (q == alg)
 			goto out;
-		}
 	}
 	
 	list_add(&amp;alg-&gt;cra_list, &amp;crypto_alg_list);
 	atomic_set(&amp;alg-&gt;cra_refcnt, 1);
+	ret = 0;
 out:	
-	up_write(&amp;crypto_alg_sem);
 	return ret;
 }
 
+int crypto_register_alg(struct crypto_alg *alg)
+{
+	int err;
+
+	err = crypto_check_alg(alg);
+	if (err)
+		return err;
+
+	down_write(&amp;crypto_alg_sem);
+	err = __crypto_register_alg(alg);
+	up_write(&amp;crypto_alg_sem);
+
+	return err;
+}
+
 int crypto_unregister_alg(struct crypto_alg *alg)
 {
 	int ret = -ENOENT;
-	struct crypto_alg *q;
 	
 	down_write(&amp;crypto_alg_sem);
-	list_for_each_entry(q, &amp;crypto_alg_list, cra_list) {
-		if (alg == q) {
-			list_del(&amp;alg-&gt;cra_list);
-			ret = 0;
-			goto out;
-		}
+	if (likely(!list_empty(&amp;alg-&gt;cra_list))) {
+		list_del_init(&amp;alg-&gt;cra_list);
+		ret = 0;
 	}
-out:	
 	up_write(&amp;crypto_alg_sem);
 
 	if (ret)
@@ -319,6 +328,108 @@ out:	
 	return 0;
 }
 
+int crypto_register_template(struct crypto_template *tmpl)
+{
+	struct crypto_template *q;
+	int err = -EEXIST;
+
+	down_write(&amp;crypto_alg_sem);
+
+	list_for_each_entry(q, &amp;crypto_template_list, list) {
+		if (q == tmpl)
+			goto out;
+	}
+
+	list_add(&amp;tmpl-&gt;list, &amp;crypto_template_list);
+	err = 0;
+out:
+	up_write(&amp;crypto_alg_sem);
+	return err;
+}
+EXPORT_SYMBOL_GPL(crypto_register_template);
+
+void crypto_unregister_template(struct crypto_template *tmpl)
+{
+	struct crypto_instance *inst;
+	struct hlist_node *p, *n;
+	struct hlist_head *list;
+
+	down_write(&amp;crypto_alg_sem);
+
+	BUG_ON(list_empty(&amp;tmpl-&gt;list));
+	list_del_init(&amp;tmpl-&gt;list);
+
+	list = &amp;tmpl-&gt;instances;
+	hlist_for_each_entry(inst, p, list, list) {
+		BUG_ON(list_empty(&amp;inst-&gt;alg.cra_list));
+		list_del_init(&amp;inst-&gt;alg.cra_list);
+	}
+
+	up_write(&amp;crypto_alg_sem);
+
+	hlist_for_each_entry_safe(inst, p, n, list, list) {
+		BUG_ON(atomic_read(&amp;inst-&gt;alg.cra_refcnt) != 1);
+		tmpl-&gt;free(inst);
+	}
+}
+EXPORT_SYMBOL_GPL(crypto_unregister_template);
+
+static struct crypto_template *__crypto_lookup_template(const char *name)
+{
+	struct crypto_template *q, *tmpl = NULL;
+
+	down_read(&amp;crypto_alg_sem);
+	list_for_each_entry(q, &amp;crypto_template_list, list) {
+		if (strcmp(q-&gt;name, name))
+			continue;
+		if (unlikely(!crypto_tmpl_get(q)))
+			continue;
+
+		tmpl = q;
+		break;
+	}
+	up_read(&amp;crypto_alg_sem);
+
+	return tmpl;
+}
+
+struct crypto_template *crypto_lookup_template(const char *name)
+{
+	return try_then_request_module(__crypto_lookup_template(name), name);
+}
+EXPORT_SYMBOL_GPL(crypto_lookup_template);
+
+int crypto_register_instance(struct crypto_template *tmpl,
+			     struct crypto_instance *inst)
+{
+	int err = -EINVAL;
+
+	if (inst-&gt;alg.cra_destroy)
+		goto err;
+
+	err = crypto_check_alg(&amp;inst-&gt;alg);
+	if (err)
+		goto err;
+
+	inst-&gt;alg.cra_module = tmpl-&gt;module;
+
+	down_write(&amp;crypto_alg_sem);
+
+	err = __crypto_register_alg(&amp;inst-&gt;alg);
+	if (err)
+		goto unlock;
+
+	hlist_add_head(&amp;inst-&gt;list, &amp;tmpl-&gt;instances);
+	inst-&gt;tmpl = tmpl;
+
+unlock:
+	up_write(&amp;crypto_alg_sem);
+
+err:
+	return err;
+}
+EXPORT_SYMBOL_GPL(crypto_register_instance);
+
 int crypto_alg_available(const char *name, u32 flags)
 {
 	int ret = 0;
diff --git a/crypto/internal.h b/crypto/internal.h
--- a/crypto/internal.h
+++ b/crypto/internal.h
@@ -18,11 +18,32 @@
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/list.h&gt;
+#include &lt;linux/module.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/rwsem.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;asm/kmap_types.h&gt;
 
+struct crypto_instance {
+	struct crypto_alg alg;
+
+	struct crypto_template *tmpl;
+	struct hlist_node list;
+
+	char __ctx[] __attribute__ ((__aligned__));
+};
+
+struct crypto_template {
+	struct list_head list;
+	struct hlist_head instances;
+	struct module *module;
+
+	struct crypto_instance *(*alloc)(void *param, unsigned int len);
+	void (*free)(struct crypto_instance *inst);
+
+	char name[CRYPTO_MAX_ALG_NAME];
+};
+
 extern struct list_head crypto_alg_list;
 extern struct rw_semaphore crypto_alg_sem;
 
@@ -108,5 +129,26 @@ void crypto_exit_digest_ops(struct crypt
 void crypto_exit_cipher_ops(struct crypto_tfm *tfm);
 void crypto_exit_compress_ops(struct crypto_tfm *tfm);
 
+int crypto_register_template(struct crypto_template *tmpl);
+void crypto_unregister_template(struct crypto_template *tmpl);
+struct crypto_template *crypto_lookup_template(const char *name);
+int crypto_register_instance(struct crypto_template *tmpl,
+			     struct crypto_instance *inst);
+
+static inline void *crypto_instance_ctx(struct crypto_instance *inst)
+{
+	return inst-&gt;__ctx;
+}
+
+static inline int crypto_tmpl_get(struct crypto_template *tmpl)
+{
+	return try_module_get(tmpl-&gt;module);
+}
+
+static inline void crypto_tmpl_put(struct crypto_template *tmpl)
+{
+	module_put(tmpl-&gt;module);
+}
+
 #endif	/* _CRYPTO_INTERNAL_H */
 
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702163945</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-07-02 16:39:45-0400</timestampReceived><subject>Re: [3/13] [CRYPTO] api: Add template registration</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Mon, 3 Jul 2006 00:20:09 +1000

&gt; [CRYPTO] api: Add template registration
&gt; 
&gt; A crypto_template generates a crypto_alg object when given a set of
&gt; parameters.  this patch adds the basic data structure fo templates
&gt; and code to handle their registration/deregistration.
&gt; 
&gt; Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

So the templates are still using pure module references not object
references?  They won't have the same kind of refcounting issues
the algorithms will have now?

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702164806</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-07-02 16:48:06-0400</timestampReceived><subject>Re: [13/13] [CRYPTO] digest: Removed old HMAC implementation</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Mon, 3 Jul 2006 00:25:01 +1000

&gt; [CRYPTO] digest: Removed old HMAC implementation
&gt; 
&gt; This patch removes the old HMAC implementation now that nobody uses it
&gt; anymore.
&gt; 
&gt; Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

A really nice set of patches Herbert :)
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702233040</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-02 23:30:40-0400</timestampReceived><subject>Re: [3/13] [CRYPTO] api: Add template registration</subject><body>

On Sun, Jul 02, 2006 at 09:39:45AM -0700, David Miller wrote:
&gt; 
&gt; So the templates are still using pure module references not object
&gt; references?  They won't have the same kind of refcounting issues
&gt; the algorithms will have now?

Unlike algorithms, templates are not directly used by algorithms or
other templates.  More importantly, they are never removed asynchronously
like algorithm instances (the latter can be removed when the algorithms
they depend on are being removed).  Therefore, the only time they can be
removed is when their module is being removed.

That's why it is OK to rely on only the module reference count.

The basic principle in the module reference handling is to allow the
replacement of modules even if they're in use.  This is achieved by:

1) Newly registered templates/algorithms always go in front of the list
   and can eclipse older copies.
2) New module reference counts can be inhibited by rmmod -w.

So if you wanted to replace your current md5 module by a new one you'd
do

modprobe md5-new

At this point all new users will latch onto it.

rmmod -w md5

This will complete once all current users relesae their md5 tfm's.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060504072951</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-05-04 07:29:51-0400</timestampReceived><subject>Re: Building acrypto</subject><body>

On Wed, May 03, 2006 at 10:45:57AM -0700, A Mukherjee (animan9@gmail.com) wrote:
&gt; Hi,

Hello.
 
&gt; I am trying to build the latest acrypto release.  When I tried to build the
&gt; release in a local directory, I get an error message:
&gt; linux/connector.h: No such file or directory

It was imported in 2.6.14 as far as I recall.

&gt; I then tried to patch the kernel with the latest combined patch file "
&gt; acrypto-combined-2.6.25.diff". While applying the patch it was not able to
&gt; properly patch the following files:
&gt; 
&gt; toplevel Makefile,
&gt; /net/ipv4/esp4.c and
&gt; /net/ipv4/xfrm4_output.c
&gt; 
&gt; It created .rej files for each of those file. I am using SUSE
&gt; 10.0distribution which has been updated to the latest kernel (linux
&gt; 2.6.13-15.8).
&gt; 
&gt; I am trying to build acrypto and trying to run IPSEC with acrypto, any help
&gt; would be greatly appreciated!

Your kernel tree does not correspond to patch you are using, 
there is no combined patchset for 2.6.13 (only acrypto_ipsec
acrypto-ipcsec-combined-2.6.13-rc6.diff).
combined patchsets are released for vanilla 2.6.15+ kernels and I do not know
how does SuSE patch it's kernels, so some hunks can be rejected.

I would recommend to use newer kernels.

&gt; Thanks.

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060504073024</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-05-04 07:30:24-0400</timestampReceived><subject>Re: OpenBSD Cryptographic Framework -- version 2 - introductions/invitations</subject><body>

On Mon, May 01, 2006 at 03:44:18PM -0400, Michael Richardson (mcr@xelerance.com) wrote:
&gt; Hi, most of you know me, but not all of you. 

Hello, developers.

&gt; My name is Michael Richardson, I've worked on a number of IPsec
&gt; implementations over the years, and most recently worked on FreeS/WAN,
&gt; turning it into Xelerance's Openswan implementation.
&gt; 
&gt; One of the things that we always wanted to do was to get good, flexible
&gt; integration with available hardware acceleration. Many of you on the To:
&gt; and CC: have worked on this, and you know that it isn't easy. 
&gt; 
&gt; It's best when one can do this with the support and cooperation of a
&gt; vendor: in this case Hifn. Specifically my company has been engaged to
&gt; do 4 things:  {algorithm, packet} X {linux, freebsd}.
&gt;
&gt; Our code base is the OpenBSD Cryptographic Framework, as ported to
&gt; FreeBSD by Sam and others, and then ported to Linux Openswan by David
&gt; McCullough. 
&gt; 
&gt; The work on {algorithm} X { linux, freebsd } is mostly of the
&gt; documentation, cleanup, and integration basis. We need to make the OCF
&gt; framework useable by both KLIPS and NETKEY (aka "Linux 2.6 native").
&gt; We have a plan for that, and we will be putting it on paper
&gt; ("electrons"?) in the next weeks.

Are you going to push it into Linux mainline? That will be hard,
since there is upcoming work on asynchronous crypto api over
existing synchronous SW implementation, which is not compatible with any
existing designs.

&gt; The work on packet acceleration is new work. This is work that we would
&gt; like to call OCF 2.0. We think it should be a superset of the current
&gt; OCF (which we'd like to call OCF 1.0).  We are aware that there has been
&gt; other work on Linux.

According to your OLS abstract:
&gt;1) does anyone care about packet processing and record support?

As far as I know there are only few of them, which have driver support
even from vendor (3com, patches to offload esp parts were quite heavy)

&gt;2) do we care about devices which live on NIC cards, and can not be used
&gt;generally?

Of course, if it allows to have more performance without decrease for
majority of users.

&gt;3) are we enthusiastic, neutral or hostile towards having an API that
&gt;can be used by hardware vendors to write closed source drivers for their
&gt;hardware?

My personal opnion: NO API, which would allow to create closed source
drivers, this (and ignorance otherwise) is the only ability to push
vendors to open specs.

HIFN provides specs, Freescale likely does, VIA does, Intel does NOT,
3com does NOT... Well, just listen OpenBSD songs :)

&gt; So, the next email will contain a formatted man page.

Btw, is it the same page as openbsd crypto man or updated one?
I have not received it.

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060504092953</emailId><senderName>"jamesleipold"</senderName><senderEmail>leipold@btinternet.com</senderEmail><timestampReceived>2006-05-04 09:29:53-0400</timestampReceived><subject>no e mail message</subject><body>

there is no response in my in box
[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;&lt;HEAD&gt;
&lt;META http-equiv=Content-Type content="text/html; charset=iso-8859-1"&gt;
&lt;META content="MSHTML 6.00.2900.2873" name=GENERATOR&gt;
&lt;STYLE&gt;&lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY bgColor=#ffffff&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;there is no response in my in 
box&lt;/FONT&gt;&lt;/DIV&gt;&lt;/BODY&gt;&lt;/HTML&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060505064240</emailId><senderName>"Camillucci, Karl"</senderName><senderEmail>camilluk@staff.abanet.org</senderEmail><timestampReceived>2006-05-05 06:42:40-0400</timestampReceived><subject>Out of Office AutoReply: Returned mail: Data format error</subject><body>

I am out of the office on association business until May 5.  I will have limited \
access to email during this time.

If you are a reporter who needs prompt assistance, please email abanews@abanet.org, \
and your inquiry will be forwarded to a colleague who can assist you.

Otherwise, I will respond to your message as soon as I can.

Thank you. 

Karl Camillucci


[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1"&gt;
&lt;META NAME="Generator" CONTENT="MS Exchange Server version 6.5.7638.1"&gt;
&lt;TITLE&gt;Out of Office AutoReply: Returned mail: Data format error&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;!-- Converted from text/plain format --&gt;

&lt;P&gt;&lt;FONT SIZE=2&gt;I am out of the office on association business until May 5.  I \
will have limited access to email during this time.&lt;BR&gt; &lt;BR&gt;
If you are a reporter who needs prompt assistance, please email abanews@abanet.org, \
and your inquiry will be forwarded to a colleague who can assist you.&lt;BR&gt; &lt;BR&gt;
Otherwise, I will respond to your message as soon as I can.&lt;BR&gt;
&lt;BR&gt;
Thank you.&lt;BR&gt;
&lt;BR&gt;
Karl Camillucci&lt;/FONT&gt;
&lt;/P&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060505164907</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-05-05 16:49:07-0400</timestampReceived><subject>Re: proposed scenario for cryptoapi</subject><body>

On Fri, May 05, 2006 at 11:59:19AM -0400, Michael Richardson (mcr@sandelman.ottawa.on.ca) wrote:
&gt;     Evgeniy&gt; Actually that is how acrypto works.
&gt; 
&gt;   I'd like to merge, but we'd also like to keep a BSD copyright on the
&gt; core components.

acrypto heavily uses linux specific internals. As far as I recall, I
posted comparison of OCF and acrypto design some time ago in
linux-crypto@/cryptoapi@.
If BSD folks decide to change OCF they will rewrite it from scratch
anyway.

And current linux native IPsec was not designed to be asynchronous.
Herbert Xu (linux crypto maintainer, in Cc:) proposed to create similar 
to netfilter queueing, but it will hurt performance for synchronous-only 
case which is also supported by acrypto, so it requires _heavy_ 
modifications to xfrm engine (current sw-only benchmark shows the same 
speed for native ipsec and acrypto+async ipsec (it is even slightly
faster with HT enabled) in esp4 mode).

Network folks will never merge it :)

And there is ongoing asynchronous work on top of existing synchronous
software cryptoapi, which was discussed in linux-crypto@, although there
are a lot of reefs there...

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060507164708</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-05-07 16:47:08-0400</timestampReceived><subject>Re: Loop-AES and kernel access key retention</subject><body>

Alon Bar-Lev wrote:
&gt; Jari Ruusu wrote:
&gt; &gt; (1) Keyctl userland-to-kernel interface is based on strings, and encrypted
&gt; &gt;     loops want hashed binary data. Not compatible without extra tricks.
&gt; 
&gt; I am under the impression that it can hold binary data. You
&gt; can pipe data to it. I've tried it and it works.

Keyctl does strlen() on the key string. Null bytes won't work.

&gt; &gt; (2) Userspace utilities make no attempt to overwrite secret key material
&gt; &gt;     after they are done with it. Serious newbie goofs.
&gt; 
&gt; Well... If this was the only problem, I would have worked
&gt; with the author to fix it to your satisfaction :)

It would need a user space program to be written anyway. The keys need to be
hashed, in userspace. Doing that in kernel would be insane.

&gt; &gt; (3) Significant amounts of loop would need to be rewritten because ioctl()
&gt; &gt;     and request_key() interfaces are so different, yet the benefits would be
&gt; &gt;     almost zero.
&gt; 
&gt; I am under the impression that it should be quite easy. I've
&gt; looked at the eCryptfs code:

I quickly read the code and it looked like that request_key() may sleep.
Code paths were this request_key() would be inserted, may not sleep for any
significant amount of time. It holds locks. Locking re-write -&gt; not funny.

There are many missing bits: For example, where do offset= and sizelimit=
options come from if they are not in /etc/fstab and parsed by mount and
losetup.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060507204911</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-05-07 20:49:11-0400</timestampReceived><subject>Re: [RFC][PATCH 2/2]  Twofish cipher x86_64-asm optimized</subject><body>

After going over my patch again, i realized i missed the .cra_priority 
and .cra_driver_name setting in the crypto api struct. Here is an updated 
version of my patch:

http://homepages.tu-darmstadt.de/~fritschi/twofish/twofish-x86_64-asm-2.6.17-2.diff

And also a little patch for the generic twofish implementation adding the 
appropriate values :

http://homepages.tu-darmstadt.de/~fritschi/twofish/twofish-priority-fix-2.6.17.diff

Regards,
Joachim
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060509112346</emailId><senderName>"Jon"</senderName><senderEmail>dona@sltnet.lk</senderEmail><timestampReceived>2006-05-09 11:23:46-0400</timestampReceived><subject>apple ipod nanos</subject><body>

Apple ipod Nanos 4GB
with fullpacking=2E=2E
door to door delivery US $ 190=2E00
minimum qty 100 ipods
please contact us for details
best regards
Jon

[Attachment #3 (text/html)]

&lt;P&gt;&lt;FONT color=blue size=7&gt;Apple ipod Nanos 4GB&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT color=blue size=7&gt;with fullpacking..&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT color=blue size=7&gt;door to door delivery US $ 190.00&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT color=blue size=7&gt;minimum qty 100 ipods&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT color=blue size=7&gt;please contact us for details&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT color=blue size=7&gt;best regards&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT color=blue size=7&gt;Jon&lt;/FONT&gt;&lt;/P&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060510003114</emailId><senderName>"ACM LISTSERV Server (14.3)"</senderName><senderEmail>listserv@listserv.acm.org</senderEmail><timestampReceived>2006-05-10 00:31:14-0400</timestampReceived><subject>Message ("Your message dated Wed, 10 May 2006 09:11:40...")</subject><body>

Your message dated Wed, 10 May 2006 09:11:40 +0900 with subject "Mail System
Error - Returned Mail" has been submitted to the moderator of the CAREERNEWS
list: careernews@HQ.ACM.ORG.

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060510034403</emailId><senderName>Derrick Martins</senderName><senderEmail>derrickmartins700@myway.com</senderEmail><timestampReceived>2006-05-10 03:44:03-0400</timestampReceived><subject>From:Derrick Martins</subject><body>


From:Derrick Martins
Manchester G37 7FT,
United Kingdom.
Tel:44 704-013-1898
Fax:44-870-135-4914
E-mail:derrickmartins@myway.com


We are Diplomatic Corp that holds special and valuable consignments for reputable clients that 

are honest and trustworthy. We work in collaboration with top firms all over the world 
as we have earned a name as a service whose hallmarks in reliability and confidentiality are 

revered.


International missions, Diplomats,Embassies of the world have used our services to satisfaction. 

A benefactor has mandated me to get someone that can assist her and her family in retrieving her 

package containing some amount of money from a Diplomatic Corp in Europe.


The benefactor and her children have been confined only to their country home and all their calls 

and movements are monitored, as a result,its absoultely impossible for them to do anything as 

regards retrieving the money.  Their only means of communication is via internet and you are 

being contacted because your assistance is needed in claiming the funds on their behalf. 


The amount was accrued from Diamond sales over a period of six years and its USD5M (Five Million 

U.S.Dollars). These funds are fully free of any liens, or encumbrances and are clean, clear and
has no criminal origin. 


The funds have nothing to do with any form of illegality and all documentations needed to prove 

the source of the funds were submitted when the funds were being deposited and these documents 

would prove the source of the funds and authenticate the fact that the funds are clean and has no 

links whatsoever with either drugs or terrorism. 


For your assistance in this transaction,the benefactor and her Children have agreed to give you 

25% of the total amount of money and this role simply entails retrieving the funds on their 

behalf from the Diplomats in Europe and all the information needed to claim the funds would be 
sent to you as soon as you indicate your interest in assisting them as well as providing the 

following information to facilitate the smooth conclusion of the transaction..

1) Your Full Name: ___________________________


2) Your Address:_______________________________


3) Your Telephone Number:________________________


4) Your Fax Number: __________________________


5) Your Mobile Number:_____________________________


6) The Name of the Closest Airport to your City of Residence:_____________________


7) Your Age:__________________________


I await your response Urgently.

Derrick Martins




-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060505130215</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2006-05-05 13:02:15-0400</timestampReceived><subject>Loop-AES and kernel access key retention</subject><body>

Hello Jari,

I am a heavy happy user of your loop-aes component. So first
of all I want to thank you for your work.

I've implemented some wrapping to enable users to use Linux,
suspend2, loop-aes and PKCS#11 in order to have a secure
mobile environment
(http://wiki.suspend2.net/EncryptedSwapAndRoot).

I've just went through some of the eCryptfs code and I've
noticed they are using the kernel access key retention to
move keys from user space into kernel. It looks quite clean
implementation so that it does not require any patch to
util-linux.

I know that you support kernel 2.0 and above, so the
util-linux patch is required... But maybe for newer kernels
you can allow the kernel key interface support.

I thought of something like user mode for /dev/loop0 and
multi-key-v3:
{
	echo AES256
	gpg &lt; keyfile.gpg
} | keyctl padd user loop:0 @u

Then use losetup or mount without any patches.

The loop:# is required in order to allow a simple
/etc/request-key.conf configuration for loop keys. So even
if key is not provided the /sbin/request-key can instantiate it.

Just an idea...

Best Regards,
Alon Bar-Lev.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060507123353</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-07 12:33:53-0400</timestampReceived><subject>Re: [RFC][PATCH 2/2]  Twofish cipher x86_64-asm optimized</subject><body>

On Sun, May 07, 2006 at 12:38:30PM +0200, Andi Kleen wrote:
&gt; 
&gt; It would be good if you could run some random input encrypt/decrypt tests 
&gt; comparing the C reference version with yours. We have had bad luck 
&gt; with assembler functions not quite implementing the same cipher 
&gt; in the past.

That's a very good point.  The tcrypt module provides both correctness
tests as well as speed tests for twofish.  Please run it with your
version versus the existing implementation.

BTW, crypto stuff should cc linux-crypto@vger.kernel.org.

Thanks,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060507124715</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-05-07 12:47:15-0400</timestampReceived><subject>Re: [RFC][PATCH 2/2]  Twofish cipher x86_64-asm optimized</subject><body>


&gt; &gt; Testing:
&gt; &gt; -----------
&gt; &gt; The code passed the kernel test module and passed automated tests on a
&gt; &gt; dm-crypt volume reading/writing large files with alternating modules ( c
&gt; &gt; / assembler ) and comparing results. It is also running on my workstation
&gt; &gt; for over a week now.
&gt;
&gt; It would be good if you could run some random input encrypt/decrypt tests
&gt; comparing the C reference version with yours. We have had bad luck
&gt; with assembler functions not quite implementing the same cipher
&gt; in the past.

That's exactly what my skript did.

http://homepages.tu-darmstadt.de/~fritschi/twofish/test_twofish.sh

Be careful with this script. It formats the testpartition you specify. The 
script assumes you have both modules (c and asm) compiled as modules.
It generates a 1Gb random file and a random passphrase. It copies the file on 
your crypted partition with the c module and reads it again with the asm 
module. Then it copies the file again onto the crypto partition with the asm 
module and reads it with the c module. After each step the md5sum of the 
files are compared with the original file. Then the script starts all over 
again with a new random file and passphrase.

My modules also pass the tcrypt tests.

&gt; &gt; Please have a look, try, improve and criticise.
&gt;
&gt; Is it really needed to duplicate all the C code and tables - can't that
&gt; be shared with the portable C code?

I really don't know. I'm quite a newbie when it comes to kernel programming. 
Maybe there is a way, but my reference for this module was the aes assembler 
code which duplicates everything as well. I assumed there is reason for this. 
Maybe someone with a little more knowledge about the crypto-api / kernel 
could pitch in here.
&gt;
&gt; Also don't make it a separate config - it should just be a replacement
&gt; on x86-64.

There was a patch in 2.6.16:
-------------------------
commit c8a19c91b5b488fed8cce04200a84c6a35c0bf0c
Author: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date:   Sat Nov 5 18:06:26 2005 +1100

    [CRYPTO] Allow AES C/ASM implementations to coexist
    
    As the Crypto API now allows multiple implementations to be registered
    for the same algorithm, we no longer have to play tricks with Kconfig
    to select the right AES implementation.
    
    This patch sets the driver name and priority for all the AES
    implementations and removes the Kconfig conditions on the C implementation
    for AES.
------------------------------

That's why i did it the same way. 




-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060507133333</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-05-07 13:33:33-0400</timestampReceived><subject>Re: [RFC][PATCH 2/2]  Twofish cipher x86_64-asm optimized</subject><body>

On Sunday 07 May 2006 14:33, Herbert Xu wrote:
&gt; On Sun, May 07, 2006 at 12:38:30PM +0200, Andi Kleen wrote:
&gt; &gt; It would be good if you could run some random input encrypt/decrypt tests
&gt; &gt; comparing the C reference version with yours. We have had bad luck
&gt; &gt; with assembler functions not quite implementing the same cipher
&gt; &gt; in the past.
&gt;
&gt; That's a very good point.  The tcrypt module provides both correctness
&gt; tests as well as speed tests for twofish.  Please run it with your
&gt; version versus the existing implementation.

All tcrypt tests pass successfully on both architectures.

Here are the outputs from the tcrypt speedtests:

http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-c-i586.txt
http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-asm-i586.txt
http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-c-x86_64.txt
http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-asm-x86_64.txt

Regards,
Joachim


-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060507153944</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-05-07 15:39:44-0400</timestampReceived><subject>Re: Loop-AES and kernel access key retention</subject><body>

Alon Bar-Lev wrote:
&gt; I've just went through some of the eCryptfs code and I've
&gt; noticed they are using the kernel access key retention to
&gt; move keys from user space into kernel. It looks quite clean
&gt; implementation so that it does not require any patch to
&gt; util-linux.

(1) Keyctl userland-to-kernel interface is based on strings, and encrypted
    loops want hashed binary data. Not compatible without extra tricks.

(2) Userspace utilities make no attempt to overwrite secret key material
    after they are done with it. Serious newbie goofs.

(3) Significant amounts of loop would need to be rewritten because ioctl()
    and request_key() interfaces are so different, yet the benefits would be
    almost zero.

(4) Mainline linux motto is: "there is no stable API" which usually
    translates to "don't bother writing code to this API". I have seen too
    may interfaces change/break under my feet that I am reluctant to add
    another dependency to another possibly wildly changing API.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060507160216</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2006-05-07 16:02:16-0400</timestampReceived><subject>Re: Loop-AES and kernel access key retention</subject><body>

Jari Ruusu wrote:
&gt; Alon Bar-Lev wrote:
&gt;&gt; I've just went through some of the eCryptfs code and I've
&gt;&gt; noticed they are using the kernel access key retention to
&gt;&gt; move keys from user space into kernel. It looks quite clean
&gt;&gt; implementation so that it does not require any patch to
&gt;&gt; util-linux.

Thank you for your reply!

&gt; (1) Keyctl userland-to-kernel interface is based on strings, and encrypted
&gt;     loops want hashed binary data. Not compatible without extra tricks.

I am under the impression that it can hold binary data. You
can pipe data to it. I've tried it and it works.

&gt; (2) Userspace utilities make no attempt to overwrite secret key material
&gt;     after they are done with it. Serious newbie goofs.

Well... If this was the only problem, I would have worked
with the author to fix it to your satisfaction :)

&gt; (3) Significant amounts of loop would need to be rewritten because ioctl()
&gt;     and request_key() interfaces are so different, yet the benefits would be
&gt;     almost zero.

I am under the impression that it should be quite easy. I've
looked at the eCryptfs code:

---

#include &lt;linux/key.h&gt;
&lt;snip&gt;
#define KEY_PAYLOAD_DATA(key) \
        (((struct user_key_payload*)key-&gt;payload.data)-&gt;data)
#define KEY_PAYLOAD_LEN(key) \
        (((struct user_key_payload*)key-&gt;payload.data)-&gt;datalen)
&lt;snip&gt;
        auth_tok_key = request_key(&amp;key_type_user,

mount_crypt_stat-&gt;global_auth_tok_sig,
                                   NULL);
        if (!auth_tok_key || IS_ERR(auth_tok_key)) {
                ecryptfs_printk(KERN_ERR, "Could not find
key with "
                                "description: [%s]\n",

mount_crypt_stat-&gt;global_auth_tok_sig);
                process_request_key_err(PTR_ERR(auth_tok_key));
                rc = -EINVAL;
                goto out;
        }
        auth_tok = (struct ecryptfs_auth_tok
*)KEY_PAYLOAD_DATA(auth_tok_key);

---

&gt; (4) Mainline linux motto is: "there is no stable API" which usually
&gt;     translates to "don't bother writing code to this API". I have seen too
&gt;     may interfaces change/break under my feet that I am reluctant to add
&gt;     another dependency to another possibly wildly changing API.

OK. It was just an idea... I thought it is simple enough to
support it. But I understand your position.

Best Regards,
Alon Bar-Lev.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061013055242</emailId><senderName></senderName><senderEmail>notifyagent</senderEmail><timestampReceived>2006-10-13 05:52:42-0400</timestampReceived><subject>Virus Alert</subject><body>

The mail message (file: message.pif) you sent to &lt;coe@ccse.kfupm.edu.sa&gt; contains a virus. (on vw2)

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061014000103</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-10-14 00:01:03-0400</timestampReceived><subject>Re: crypto: Add support for the Geode AES engine (v4)</subject><body>

On Fri, Oct 13, 2006 at 01:18:20PM -0400, Michael Frey wrote:
&gt; 
&gt; Also,  Can this patch be used on a 2.6.18 kernel?

No but you can find one that works in the mm kernels prior
to 2.6.18's release.
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061014215323</emailId><senderName></senderName><senderEmail>borchi</senderEmail><timestampReceived>2006-10-14 21:53:23-0400</timestampReceived><subject>Auto Reply Message</subject><body>

Bor Chi (Singapore) Pte Ltd

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20061016113020</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-10-16 11:30:20-0400</timestampReceived><subject>[CRYPTO] api: Select cryptomgr where needed</subject><body>

Hi Andi:

I'll send this patch to Linus which should prevent the problem
that you were seeing.  James, this is probably what caused the
racoon problems for you too.

[CRYPTO] api: Select cryptomgr where needed

Since cryptomgr is the only way to construct algorithm instances
for now it makes sense to let the templates depend on it as
otherwise it may be left off inadvertently.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/Kconfig b/crypto/Kconfig
index 1e2f39c..cbae839 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -27,7 +27,6 @@ config CRYPTO_HASH
 config CRYPTO_MANAGER
 	tristate "Cryptographic algorithm manager"
 	select CRYPTO_ALGAPI
-	default m
 	help
 	  Create default cryptographic template instantiations such as
 	  cbc(aes).
@@ -35,6 +34,7 @@ config CRYPTO_MANAGER
 config CRYPTO_HMAC
 	tristate "HMAC support"
 	select CRYPTO_HASH
+	select CRYPTO_MANAGER
 	help
 	  HMAC: Keyed-Hashing for Message Authentication (RFC2104).
 	  This is required for IPSec.
@@ -131,6 +131,7 @@ config CRYPTO_TGR192
 config CRYPTO_ECB
 	tristate "ECB support"
 	select CRYPTO_BLKCIPHER
+	select CRYPTO_MANAGER
 	default m
 	help
 	  ECB: Electronic CodeBook mode
@@ -140,6 +141,7 @@ config CRYPTO_ECB
 config CRYPTO_CBC
 	tristate "CBC support"
 	select CRYPTO_BLKCIPHER
+	select CRYPTO_MANAGER
 	default m
 	help
 	  CBC: Cipher Block Chaining mode
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061018071616</emailId><senderName>Noriaki TAKAMIYA</senderName><senderEmail>takamiya@po.ntts.co.jp</senderEmail><timestampReceived>2006-10-18 07:16:16-0400</timestampReceived><subject>[PATCH 1/6] [CRYPTO] added Kconfig entry for Camellia.</subject><body>

Hi, 

  This patch adds the Kconfig entry for Camellia.

  Signed-off-by: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;

---

 crypto/Kconfig |   14 ++++++++++++++
 1 files changed, 14 insertions(+), 0 deletions(-)

01b0c3898fdf1cb4da8cdf5577e58328ecb11e4e
diff --git a/crypto/Kconfig b/crypto/Kconfig
index cbae839..19858ee 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -424,6 +424,20 @@ config CRYPTO_CRC32C
 	  See Castagnoli93.  This implementation uses lib/libcrc32c.
           Module will be crc32c.
 
+config CRYPTO_CAMELLIA
+      tristate "Camellia cipher algorithms"
+      depends on CRYPTO
+      help
+       Camellia cipher algorithms module.
+
+        Camellia is a symmetric key block cipher developed jointly 
+        at NTT and Mitsubishi Electric Corporation. 
+
+        The Camellia specifies three key sizes: 128, 192 and 256 bits   
+
+        See also:
+        &lt;https://info.isl.ntt.co.jp/crypt/eng/camellia/index_s.html&gt;
+
 config CRYPTO_TEST
 	tristate "Testing module"
 	depends on m
-- 
Noriaki TAKAMIYA
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061018071708</emailId><senderName>Noriaki TAKAMIYA</senderName><senderEmail>takamiya@po.ntts.co.jp</senderEmail><timestampReceived>2006-10-18 07:17:08-0400</timestampReceived><subject>[PATCH 3/6] [CRYPTO] added the testing code of Camellia cipher</subject><body>


This patch adds the code of Camellia code for testing module.

Signed-off-by: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;

---

 crypto/tcrypt.c |   43 ++++++++++++++
 crypto/tcrypt.h |  165 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 207 insertions(+), 1 deletions(-)

e86050d8fbd04b1ace9c121ce90799c8210925be
diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
index b48d011..a9976a0 100644
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -71,7 +71,8 @@ static char *check[] = {
 	"des", "md5", "des3_ede", "rot13", "sha1", "sha256", "blowfish",
 	"twofish", "serpent", "sha384", "sha512", "md4", "aes", "cast6",
 	"arc4", "michael_mic", "deflate", "crc32c", "tea", "xtea",
-	"khazad", "wp512", "wp384", "wp256", "tnepres", "xeta", NULL
+	"khazad", "wp512", "wp384", "wp256", "tnepres", "xeta", "camellia", 
+	NULL
 };
 
 static void hexdump(unsigned char *buf, unsigned int len)
@@ -960,6 +961,20 @@ static void do_test(void)
 		test_cipher("ecb(xeta)", DECRYPT, xeta_dec_tv_template,
 			    XETA_DEC_TEST_VECTORS);
 
+		//CAMELLIA
+		test_cipher ("ecb(camellia)", ENCRYPT,
+			     camellia_enc_tv_template,
+			     CAMELLIA_ENC_TEST_VECTORS);
+		test_cipher ("ecb(camellia)", DECRYPT,
+			     camellia_dec_tv_template,
+			     CAMELLIA_DEC_TEST_VECTORS);
+		test_cipher ("cbc(camellia)", ENCRYPT,
+			     camellia_cbc_enc_tv_template,
+			     CAMELLIA_CBC_ENC_TEST_VECTORS);
+		test_cipher ("cbc(camellia)", DECRYPT,
+			     camellia_cbc_dec_tv_template,
+			     CAMELLIA_CBC_DEC_TEST_VECTORS);
+
 		test_hash("sha384", sha384_tv_template, SHA384_TEST_VECTORS);
 		test_hash("sha512", sha512_tv_template, SHA512_TEST_VECTORS);
 		test_hash("wp512", wp512_tv_template, WP512_TEST_VECTORS);
@@ -1166,6 +1181,21 @@ static void do_test(void)
 			    XETA_DEC_TEST_VECTORS);
 		break;
 
+	case 31:
+		test_cipher ("ecb(camellia)", ENCRYPT,
+			     camellia_enc_tv_template,
+			     CAMELLIA_ENC_TEST_VECTORS);
+		test_cipher ("ecb(camellia)", DECRYPT,
+			     camellia_dec_tv_template,
+			     CAMELLIA_DEC_TEST_VECTORS);
+		test_cipher ("cbc(camellia)", ENCRYPT,
+			     camellia_cbc_enc_tv_template,
+			     CAMELLIA_CBC_ENC_TEST_VECTORS);
+		test_cipher ("cbc(camellia)", DECRYPT,
+			     camellia_cbc_dec_tv_template,
+			     CAMELLIA_CBC_DEC_TEST_VECTORS);
+		break;
+
 	case 100:
 		test_hash("hmac(md5)", hmac_md5_tv_template,
 			  HMAC_MD5_TEST_VECTORS);
@@ -1245,6 +1275,17 @@ static void do_test(void)
 				  des_speed_template);
 		break;
 
+	case 205:
+		test_cipher_speed("ecb(camellia)", ENCRYPT, sec, NULL, 0,
+				camellia_speed_template);
+		test_cipher_speed("ecb(camellia)", DECRYPT, sec, NULL, 0,
+				camellia_speed_template);
+		test_cipher_speed("cbc(camellia)", ENCRYPT, sec, NULL, 0,
+				camellia_speed_template);
+		test_cipher_speed("cbc(camellia)", DECRYPT, sec, NULL, 0,
+				camellia_speed_template);
+		break;
+
 	case 300:
 		/* fall through */
 
diff --git a/crypto/tcrypt.h b/crypto/tcrypt.h
index a40c441..3c7d46f 100644
--- a/crypto/tcrypt.h
+++ b/crypto/tcrypt.h
@@ -2744,6 +2744,150 @@ static struct cipher_testvec xeta_dec_tv
 };
 
 /*
+ * CAMELLIA test vectors.
+ */
+#define CAMELLIA_ENC_TEST_VECTORS 3
+#define CAMELLIA_DEC_TEST_VECTORS 3
+#define CAMELLIA_CBC_ENC_TEST_VECTORS 2
+#define CAMELLIA_CBC_DEC_TEST_VECTORS 2
+
+static struct cipher_testvec camellia_enc_tv_template[] = {
+	{ 
+		.key	= { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+			    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.klen	= 16,
+		.input	= { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+			    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.ilen	= 16,
+		.result	= { 0x67, 0x67, 0x31, 0x38, 0x54, 0x96, 0x69, 0x73,
+			    0x08, 0x57, 0x06, 0x56, 0x48, 0xea, 0xbe, 0x43 },
+		.rlen	= 16,
+	}, {
+		.key	= { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+			    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
+			    0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77 },
+		.klen	= 24,
+		.input	= { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+			    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.ilen	= 16,
+		.result	= { 0xb4, 0x99, 0x34, 0x01, 0xb3, 0xe9, 0x96, 0xf8,
+			    0x4e, 0xe5, 0xce, 0xe7, 0xd7, 0x9b, 0x09, 0xb9 },
+		.rlen	= 16,
+	}, {
+		.key	= { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+			    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
+			    0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
+			    0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff }, 
+		.klen	= 32,
+		.input	= { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+			    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.ilen	= 16,
+		.result	= { 0x9a, 0xcc, 0x23, 0x7d, 0xff, 0x16, 0xd7, 0x6c,
+			    0x20, 0xef, 0x7c, 0x91, 0x9e, 0x3a, 0x75, 0x09 },
+		.rlen	= 16,
+	},
+};
+
+static struct cipher_testvec camellia_dec_tv_template[] = {
+	{ 
+		.key	= { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+			    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.klen	= 16,
+		.input	= { 0x67, 0x67, 0x31, 0x38, 0x54, 0x96, 0x69, 0x73,
+			    0x08, 0x57, 0x06, 0x56, 0x48, 0xea, 0xbe, 0x43 },
+		.ilen	= 16,
+		.result	= { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+			    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.rlen	= 16,
+	}, {
+		.key	= { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+			    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
+			    0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77 },
+		.klen	= 24,
+		.input	= { 0xb4, 0x99, 0x34, 0x01, 0xb3, 0xe9, 0x96, 0xf8,
+			    0x4e, 0xe5, 0xce, 0xe7, 0xd7, 0x9b, 0x09, 0xb9 },
+		.ilen	= 16,
+		.result	= { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+			    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.rlen	= 16,
+	}, {
+		.key	= { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+			    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
+			    0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
+			    0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff }, 
+		.klen	= 32,
+		.input	= { 0x9a, 0xcc, 0x23, 0x7d, 0xff, 0x16, 0xd7, 0x6c,
+			    0x20, 0xef, 0x7c, 0x91, 0x9e, 0x3a, 0x75, 0x09 },
+		.ilen	= 16,
+		.result	= { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+			    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
+		.rlen	= 16,
+	},
+};
+
+static struct cipher_testvec camellia_cbc_enc_tv_template[] = {
+	{
+		.key    = { 0x06, 0xa9, 0x21, 0x40, 0x36, 0xb8, 0xa1, 0x5b,
+			    0x51, 0x2e, 0x03, 0xd5, 0x34, 0x12, 0x00, 0x06 },
+		.klen   = 16,
+		.iv	= { 0x3d, 0xaf, 0xba, 0x42, 0x9d, 0x9e, 0xb4, 0x30,
+			    0xb4, 0x22, 0xda, 0x80, 0x2c, 0x9f, 0xac, 0x41 },
+		.input	= { "Single block msg" },
+		.ilen   = 16,
+		.result = { 0xea, 0x32, 0x12, 0x76, 0x3b, 0x50, 0x10, 0xe7,
+			    0x18, 0xf6, 0xfd, 0x5d, 0xf6, 0x8f, 0x13, 0x51 },
+		.rlen   = 16,
+	}, {
+		.key    = { 0xc2, 0x86, 0x69, 0x6d, 0x88, 0x7c, 0x9a, 0xa0,
+			    0x61, 0x1b, 0xbb, 0x3e, 0x20, 0x25, 0xa4, 0x5a },
+		.klen   = 16,
+		.iv     = { 0x56, 0x2e, 0x17, 0x99, 0x6d, 0x09, 0x3d, 0x28,
+			    0xdd, 0xb3, 0xba, 0x69, 0x5a, 0x2e, 0x6f, 0x58 },
+		.input  = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+			    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+			    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+			    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f },
+		.ilen   = 32,
+		.result = { 0xa5, 0xdf, 0x6e, 0x50, 0xda, 0x70, 0x6c, 0x01,
+			    0x4a, 0xab, 0xf3, 0xf2, 0xd6, 0xfc, 0x6c, 0xfd,
+			    0x19, 0xb4, 0x3e, 0x57, 0x1c, 0x02, 0x5e, 0xa0,
+			    0x15, 0x78, 0xe0, 0x5e, 0xf2, 0xcb, 0x87, 0x16 },
+		.rlen   = 32,
+	},
+};
+
+static struct cipher_testvec camellia_cbc_dec_tv_template[] = {
+	{
+		.key    = { 0x06, 0xa9, 0x21, 0x40, 0x36, 0xb8, 0xa1, 0x5b,
+			    0x51, 0x2e, 0x03, 0xd5, 0x34, 0x12, 0x00, 0x06 },
+		.klen   = 16,
+		.iv	= { 0x3d, 0xaf, 0xba, 0x42, 0x9d, 0x9e, 0xb4, 0x30,
+			    0xb4, 0x22, 0xda, 0x80, 0x2c, 0x9f, 0xac, 0x41 },
+		.input	= { 0xea, 0x32, 0x12, 0x76, 0x3b, 0x50, 0x10, 0xe7,
+			    0x18, 0xf6, 0xfd, 0x5d, 0xf6, 0x8f, 0x13, 0x51 },
+		.ilen   = 16,
+		.result = { "Single block msg" },
+		.rlen   = 16,
+	}, {
+		.key    = { 0xc2, 0x86, 0x69, 0x6d, 0x88, 0x7c, 0x9a, 0xa0,
+			    0x61, 0x1b, 0xbb, 0x3e, 0x20, 0x25, 0xa4, 0x5a },
+		.klen   = 16,
+		.iv     = { 0x56, 0x2e, 0x17, 0x99, 0x6d, 0x09, 0x3d, 0x28,
+			    0xdd, 0xb3, 0xba, 0x69, 0x5a, 0x2e, 0x6f, 0x58 },
+		.input = { 0xa5, 0xdf, 0x6e, 0x50, 0xda, 0x70, 0x6c, 0x01,
+			    0x4a, 0xab, 0xf3, 0xf2, 0xd6, 0xfc, 0x6c, 0xfd,
+			    0x19, 0xb4, 0x3e, 0x57, 0x1c, 0x02, 0x5e, 0xa0,
+			    0x15, 0x78, 0xe0, 0x5e, 0xf2, 0xcb, 0x87, 0x16 },
+		.ilen   = 32,
+		.result = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+			    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+			    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+			    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f },
+		.rlen   = 32,
+	},
+};
+
+/*
  * Compression stuff.
  */
 #define COMP_BUF_SIZE           512
@@ -3175,4 +3319,25 @@ static struct hash_speed generic_hash_sp
 	{  .blen = 0,	.plen = 0, }
 };
 
+static struct cipher_speed camellia_speed_template[] = {
+      { .klen = 16, .blen = 16, },
+      { .klen = 16, .blen = 64, },
+      { .klen = 16, .blen = 256, },
+      { .klen = 16, .blen = 1024, },
+      { .klen = 16, .blen = 8192, },
+      { .klen = 24, .blen = 16, },
+      { .klen = 24, .blen = 64, },
+      { .klen = 24, .blen = 256, },
+      { .klen = 24, .blen = 1024, },
+      { .klen = 24, .blen = 8192, },
+      { .klen = 32, .blen = 16, },
+      { .klen = 32, .blen = 64, },
+      { .klen = 32, .blen = 256, },
+      { .klen = 32, .blen = 1024, },
+      { .klen = 32, .blen = 8192, },
+
+      /* End marker */
+      {  .klen = 0, .blen = 0, }
+};
+
 #endif	/* _CRYPTO_TCRYPT_H */
-- 
Noriaki TAKAMIYA

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061018071728</emailId><senderName>Noriaki TAKAMIYA</senderName><senderEmail>takamiya@po.ntts.co.jp</senderEmail><timestampReceived>2006-10-18 07:17:28-0400</timestampReceived><subject>[PATCH 4/6] [IPSEC] added the definition of Camellia cipher</subject><body>


This patch adds the definitions used by pfkeyv2 interface for Camellia
cipher algorithm.

Signed-off-by: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;

---

 include/linux/pfkeyv2.h |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

1b6712cdb8fd31482d7e7da56e5f602357ec4aa4
diff --git a/include/linux/pfkeyv2.h b/include/linux/pfkeyv2.h
index d5dd471..b16e474 100644
--- a/include/linux/pfkeyv2.h
+++ b/include/linux/pfkeyv2.h
@@ -296,6 +296,7 @@ #define SADB_X_EALG_CASTCBC		6
 #define SADB_X_EALG_BLOWFISHCBC		7
 #define SADB_EALG_NULL			11
 #define SADB_X_EALG_AESCBC		12
+#define SADB_X_EALG_CAMELLIACBC		22
 #define SADB_EALG_MAX                   253 /* last EALG */
 /* private allocations should use 249-255 (RFC2407) */
 #define SADB_X_EALG_SERPENTCBC  252     /* draft-ietf-ipsec-ciph-aes-cbc-00 */
-- 
Noriaki TAKAMIYA

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061018071749</emailId><senderName>Noriaki TAKAMIYA</senderName><senderEmail>takamiya@po.ntts.co.jp</senderEmail><timestampReceived>2006-10-18 07:17:49-0400</timestampReceived><subject>[PATCH 5/6] [IPSEC] added the entry of Camellia cipher algorithm</subject><body>


This patch adds the entry of Camellia cipher algorithm to ealg_list[].

Signed-off-by: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;

---

 net/xfrm/xfrm_algo.c |   17 +++++++++++++++++
 1 files changed, 17 insertions(+), 0 deletions(-)

2253254f5a802c1cc8a5fc367fae911172f28846
diff --git a/net/xfrm/xfrm_algo.c b/net/xfrm/xfrm_algo.c
index 5a0dbeb..583292d 100644
--- a/net/xfrm/xfrm_algo.c
+++ b/net/xfrm/xfrm_algo.c
@@ -249,6 +249,23 @@ static struct xfrm_algo_desc ealg_list[]
         }
 },
 {
+	.name = "cbc(camellia)",
+        .compat = "camellia",
+
+	.uinfo = {
+		.encr = {
+			.blockbits = 128,
+			.defkeybits = 128,
+		}
+	},
+	.desc = {
+		.sadb_alg_id = SADB_X_EALG_CAMELLIACBC,
+		.sadb_alg_ivlen = 8,
+		.sadb_alg_minbits = 128,
+		.sadb_alg_maxbits = 256
+	}
+},
+{
         .name = "cbc(twofish)",
         .compat = "twofish",
                  
-- 
Noriaki TAKAMIYA

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061018071818</emailId><senderName>Noriaki TAKAMIYA</senderName><senderEmail>takamiya@po.ntts.co.jp</senderEmail><timestampReceived>2006-10-18 07:18:18-0400</timestampReceived><subject>[PATCH 6/6] [CRYPTO] added the developer of Camellia cipher</subject><body>


This patch adds the developer of Camellia cipher algorithm.

Signed-off-by: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;

---

 Documentation/crypto/api-intro.txt |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)

80a5df8127311212e99bd64103771de19c5908dd
diff --git a/Documentation/crypto/api-intro.txt b/Documentation/crypto/api-intro.txt
index 5a03a28..e41a79a 100644
--- a/Documentation/crypto/api-intro.txt
+++ b/Documentation/crypto/api-intro.txt
@@ -193,6 +193,7 @@ Original developers of the crypto algori
   Kartikey Mahendra Bhatt (CAST6)
   Jon Oberheide (ARC4)
   Jouni Malinen (Michael MIC)
+  NTT(Nippon Telegraph and Telephone Corporation) (Camellia)
 
 SHA1 algorithm contributors:
   Jean-Francois Dive
@@ -246,6 +247,9 @@ Tiger algorithm contributors:
 VIA PadLock contributors:
   Michal Ludvig
 
+Camellia algorithm contributors:
+  NTT(Nippon Telegraph and Telephone Corporation) (Camellia)
+
 Generic scatterwalk code by Adam J. Richter &lt;adam@yggdrasil.com&gt;
 
 Please send any credits updates or corrections to:
-- 
Noriaki TAKAMIYA

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061021065937</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-10-21 06:59:37-0400</timestampReceived><subject>Re: [ACRYPTO] New asynchronous crypto layer (acrypto) release.</subject><body>

On Fri, Oct 20, 2006 at 03:34:40PM +0200, Andreas Jellinghaus (aj@ciphirelabs.com) wrote:
&gt; &gt;Btw, async provider only supports AES-128 in CBC mode, so if you try
&gt; &gt;different ciphers, there can be some problems.
&gt; 
&gt; my code does
&gt; 
&gt; SECTORS=`blockdev --getsize /dev/hda3`
&gt; 
&gt; echo 0 $SECTORS crypt aes-cbc-essiv:sha256 $ROOTKEY 0 /dev/hda3 0 \
&gt;         |dmsetup create root
&gt; 
&gt; so this is not compatible with acrypto I guess :(
&gt; any special reason why acrypto is limited this way?

I'm lazy and I did not implemented async provider so it would request
other ciphers. It is not limitation of acrypto, but instead of software
async_provider, which should be extended to support any kind of ciphers,
instead of precompiled one.

&gt; guess that limitation needs to go away before it can be added to
&gt; the linux kernel, or some workaround so dm-crypt will fall back on
&gt; not using acrypto or something like that in order to not brake existing
&gt; and working installations.

Well, I guess async_provider itself should go away, instead I will
change synchronous cryptoapi code to register itself as acrypto device
when new tfm is created.

&gt; Thanks, Andreas

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061023023155</emailId><senderName>Noriaki TAKAMIYA</senderName><senderEmail>takamiya@po.ntts.co.jp</senderEmail><timestampReceived>2006-10-23 02:31:55-0400</timestampReceived><subject>Re: [PATCH 0/6] Changeset of Camellia cipher algorithm.</subject><body>

Hi,

&gt;&gt; Sun, 22 Oct 2006 15:07:47 +1000
&gt;&gt; [Subject: Re: [PATCH 0/6] Changeset of Camellia cipher algorithm.]
&gt;&gt; Herbert Xu &lt;herbert@gondor.apana.org.au&gt; wrote....

&gt; On Wed, Oct 18, 2006 at 07:15:10AM +0000, Noriaki TAKAMIYA wrote:
&gt; &gt; 
&gt; &gt; [PATCH 1/6] [CRYPTO] added Kconfig entry for Camellia.
&gt; &gt; [PATCH 2/6] [CRYPTO] added the code of Camellia cipher algorithm.
&gt; &gt; [PATCH 3/6] [CRYPTO] added the testing code of Camellia cipher algorithm.
&gt; &gt; [PATCH 4/6] [IPSEC] added the definition of Camellia cipher algorithm.
&gt; &gt; [PATCH 5/6] [IPSEC] added the entry of Camellia cipher algorithm to ealg_list[].
&gt; &gt; [PATCH 6/6] [CRYPTO] added the developer of Camellia cipher algorithm.
&gt; 
&gt; I've applied all the patches to cryptodev-2.6.  Thanks!

  Thank you!

--
Noriaki TAKAMIYA
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061023023310</emailId><senderName>Noriaki TAKAMIYA</senderName><senderEmail>takamiya@po.ntts.co.jp</senderEmail><timestampReceived>2006-10-23 02:33:10-0400</timestampReceived><subject>Re: [PATCH 2/6] [CRYPTO] added the code of Camellia cipher</subject><body>

Hi,

&gt;&gt; Sun, 22 Oct 2006 15:09:54 +1000
&gt;&gt; [Subject: Re: [PATCH 2/6] [CRYPTO] added the code of Camellia cipher algorithm.]
&gt;&gt; Herbert Xu &lt;herbert@gondor.apana.org.au&gt; wrote...

&gt; On Wed, Oct 18, 2006 at 07:16:47AM +0000, Noriaki TAKAMIYA wrote:
&gt; &gt;
&gt; &gt; +static int
&gt; &gt; +camellia_set_key(struct crypto_tfm *tfm, const u8 *in_key,
&gt; &gt; +		 unsigned int key_len, u32 *flags)
&gt; 
&gt; Ugh, this doesn't compile with the current tree since the flags
&gt; field no longer exists for set_key.  I've fixed it up in my tree.

  The tree I referred might be little bit old...

  Thank you for your fix.

  Regards,

--
Noriaki TAKAMIYA
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061023215020</emailId><senderName>Benjamin Gilbert</senderName><senderEmail>bgilbert@cs.cmu.edu</senderEmail><timestampReceived>2006-10-23 21:50:20-0400</timestampReceived><subject>[RFC][PATCH] x86-optimized SHA1 hash for CryptoAPI</subject><body>

This is a new CryptoAPI module containing an x86-optimized implementation of
SHA1, taken from Nettle.

On my box (Pentium IV), tcrypt's performance tester reports the following
cycles-per-byte figures (average of 5 trials):

Test#  Bytes/  Bytes/    Unopt       Opt
        block  update cycles/B  cycles/B
    0      16      16      209       150
    1      64      16      130        84
    2      64      64       91        45
    3     256      16       95        69
    4     256      64       53        28
    5     256     256       40        18
    6    1024      16       88        66
    7    1024     256       32        15
    8    1024    1024       28        12
    9    2048      16       91        65
   10    2048     256       36        16
   11    2048    1024       27        12
   12    2048    2048       27        13
   13    4096      16       92        65
   14    4096     256       30        14
   15    4096    1024       27        11
   16    4096    4096       26        11
   17    8192      16       85        65
   18    8192     256       30        14
   19    8192    1024       27        11
   20    8192    4096       26        10
   21    8192    8192       26        10

so the x86-optimized version is more than twice as fast for large updates
and still somewhat faster than the current version for small updates.

Now for my question.  The attached patch is a fairly straightforward port
from the Nettle asm and C code.  However, there are (at least) two other
options:

1.  Recognizing that arch/i386/crypto/sha1.c contains almost the same
functionality as crypto/sha1.c, I could abstract out common code between the
two implementations.  However, given the length of the files in question, I
suspect the complexity isn't worth it.  In-tree, AES uses duplicated code
between the asm and C versions, while Twofish pulls out common code into a
separate module.

2.  Since the optimized part of the code is the SHA1 compression function,
and since crypto/sha1.c is just a wrapper around the compression function in
lib/sha1.c, I could eliminate the separate CryptoAPI module and switch the
kernel between the C and asm compression functions based on a config option
-- so that all SHA1 users get the optimized version, instead of just
CryptoAPI.  There is an API issue though: the optimized code needs to
allocate its workspace on the stack for register-allocation reasons, and the
C version expects the caller to allocate a temporary buffer (to minimize the
number of times the workspace needs to be cleared when hashing several times
in a row).  If the optimized code was used with the current API, the caller
would be doing a bunch of allocation and clearing for nothing.  (Note: the
only direct users of lib/sha1.c right now are /dev/random and syncookies.)

Which (if any) is the preferred approach?

Suggestions and comments appreciated.

--Benjamin Gilbert

Signed-off-by: Benjamin Gilbert &lt;bgilbert@cs.cmu.edu&gt;
---
 arch/i386/crypto/Makefile        |    2 
 arch/i386/crypto/sha1-i586-asm.S |  330 ++++++++++++++++++++++++++++++++++++++
 arch/i386/crypto/sha1.c          |  161 +++++++++++++++++++
 crypto/Kconfig                   |    8 +
 4 files changed, 501 insertions(+), 0 deletions(-)

diff --git a/arch/i386/crypto/Makefile b/arch/i386/crypto/Makefile
index 3fd19af..8ab8f04 100644
--- a/arch/i386/crypto/Makefile
+++ b/arch/i386/crypto/Makefile
@@ -6,7 +6,9 @@ # 
 
 obj-$(CONFIG_CRYPTO_AES_586) += aes-i586.o
 obj-$(CONFIG_CRYPTO_TWOFISH_586) += twofish-i586.o
+obj-$(CONFIG_CRYPTO_SHA1_586) += sha1-i586.o
 
 aes-i586-y := aes-i586-asm.o aes.o
 twofish-i586-y := twofish-i586-asm.o twofish.o
+sha1-i586-y := sha1-i586-asm.o sha1.o
 
diff --git a/arch/i386/crypto/sha1-i586-asm.S b/arch/i386/crypto/sha1-i586-asm.S
new file mode 100644
index 0000000..77b9cbf
--- /dev/null
+++ b/arch/i386/crypto/sha1-i586-asm.S
@@ -0,0 +1,330 @@
+/*
+ * x86-optimized SHA1 hash algorithm
+ *
+ * Originally from Nettle
+ * Ported from M4 to cpp by Benjamin Gilbert &lt;bgilbert@cs.cmu.edu&gt;
+ *
+ * Copyright (C) 2004, Niels Möller
+ * Copyright (c) 2006 Carnegie Mellon University
+ *
+ * This file is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ */
+
+/* Register usage */
+#define SA	%eax
+#define SB	%ebx
+#define SC	%ecx
+#define SD	%edx
+#define SE	%ebp
+#define DATA	%esp
+#define TMP	%edi
+#define TMP2	%esi			/* Used by SWAP and F3 */
+#define TMP3	64(%esp)
+
+/* Constants */
+#define K1VALUE	$0x5A827999		/* Rounds  0-19 */
+#define K2VALUE	$0x6ED9EBA1		/* Rounds 20-39 */
+#define K3VALUE	$0x8F1BBCDC		/* Rounds 40-59 */
+#define K4VALUE	$0xCA62C1D6		/* Rounds 60-79 */
+
+/* Convert stack offsets in words to offsets in bytes */
+#define OFFSET(i) 4*(i)
+
+/* Reads the input via TMP2 into register, byteswaps it, and stores it in
+   the DATA array. */
+#define SWAP(index, register)					\
+	movl	OFFSET(index)(TMP2), register;			\
+	bswap	register;					\
+	movl	register, OFFSET(index)(DATA)
+
+/* Sets the workspace word at the given index to zero. */
+#define CLEAR(index)						\
+	movl	$0, OFFSET(index)(DATA)
+
+/*
+ * expand(i) is the expansion function
+ *
+ *   W[i] = (W[i - 16] ^ W[i - 14] ^ W[i - 8] ^ W[i - 3]) &lt;&lt;&lt; 1
+ *
+ * where W[i] is stored in DATA[i mod 16].
+ *
+ * Result is stored back in W[i], and also left in TMP, the only
+ * register that is used.
+ */
+#define EXPAND(i)						\
+	movl	OFFSET(i % 16)(DATA), TMP;			\
+	xorl	OFFSET((i + 2) % 16)(DATA), TMP;		\
+	xorl	OFFSET((i + 8) % 16)(DATA), TMP;		\
+	xorl	OFFSET((i + 13) % 16)(DATA), TMP;		\
+	roll	$1, TMP;					\
+	movl	TMP, OFFSET(i % 16)(DATA)
+
+/*
+ * The f functions,
+ *
+ *  f1(x,y,z) = z ^ (x &amp; (y ^ z))
+ *  f2(x,y,z) = x ^ y ^ z
+ *  f3(x,y,z) = (x &amp; y) | (z &amp; (x | y))
+ *  f4 = f2
+ *
+ * The macro Fk(x,y,z) computes = fk(x,y,z).
+ * Result is left in TMP.
+ */
+#define F1(x,y,z)						\
+	movl	z, TMP;						\
+	xorl	y, TMP;						\
+	andl	x, TMP;						\
+	xorl	z, TMP
+
+#define F2(x,y,z)						\
+	movl	x, TMP;						\
+	xorl	y, TMP;						\
+	xorl	z, TMP
+
+#define F3(x,y,z)						\
+	movl	x, TMP2;					\
+	andl	y, TMP2;					\
+	movl	x, TMP;						\
+	orl	y, TMP;						\
+	andl	z, TMP;						\
+	orl	TMP2, TMP
+
+/*
+ * The form of one sha1 round is
+ *
+ *   a' = e + a &lt;&lt;&lt; 5 + f( b, c, d ) + k + w;
+ *   b' = a;
+ *   c' = b &lt;&lt;&lt; 30;
+ *   d' = c;
+ *   e' = d;
+ *
+ * where &lt;&lt;&lt; denotes rotation. We permute our variables, so that we
+ * instead get
+ *
+ *   e += a &lt;&lt;&lt; 5 + f( b, c, d ) + k + w;
+ *   b &lt;&lt;&lt;= 30
+ *
+ * Using the TMP register for the rotate could be avoided, by rotating
+ * %a in place, adding, and then rotating back.
+ */
+#define ROUND(a,b,c,d,e,f,k,w)					\
+	addl	k, e;						\
+	addl	w, e;						\
+	f(b,c,d);						\
+	addl	TMP, e;						\
+	movl	a, TMP;						\
+	roll	$5, TMP;					\
+	addl	TMP, e;						\
+	roll	$30, b;
+
+/* sha1_compress(u32 *state, u8 *data) */
+.text
+.align 4
+.globl sha1_compress
+sha1_compress:
+	/* save all registers that need to be saved */
+	pushl	%ebx		/* 80(%esp) */
+	pushl	%ebp		/* 76(%esp) */
+	pushl	%esi		/* 72(%esp) */
+	pushl	%edi		/* 68(%esp) */
+
+	subl	$68, %esp	/* %esp = W */
+
+	/* Load and byteswap data */
+	movl	92(%esp), TMP2
+
+	SWAP( 0, %eax); SWAP( 1, %ebx); SWAP( 2, %ecx); SWAP( 3, %edx)
+	SWAP( 4, %eax); SWAP( 5, %ebx); SWAP( 6, %ecx); SWAP( 7, %edx)
+	SWAP( 8, %eax); SWAP( 9, %ebx); SWAP(10, %ecx); SWAP(11, %edx)
+	SWAP(12, %eax); SWAP(13, %ebx); SWAP(14, %ecx); SWAP(15, %edx)
+
+	/* load the state vector */
+	movl	88(%esp),TMP
+	movl	(TMP),   SA
+	movl	4(TMP),  SB
+	movl	8(TMP),  SC
+	movl	12(TMP), SD
+	movl	16(TMP), SE
+
+	movl	K1VALUE, TMP2
+	ROUND(SA, SB, SC, SD, SE, F1, TMP2, OFFSET( 0)(DATA))
+	ROUND(SE, SA, SB, SC, SD, F1, TMP2, OFFSET( 1)(DATA))
+	ROUND(SD, SE, SA, SB, SC, F1, TMP2, OFFSET( 2)(DATA))
+	ROUND(SC, SD, SE, SA, SB, F1, TMP2, OFFSET( 3)(DATA))
+	ROUND(SB, SC, SD, SE, SA, F1, TMP2, OFFSET( 4)(DATA))
+
+	ROUND(SA, SB, SC, SD, SE, F1, TMP2, OFFSET( 5)(DATA))
+	ROUND(SE, SA, SB, SC, SD, F1, TMP2, OFFSET( 6)(DATA))
+	ROUND(SD, SE, SA, SB, SC, F1, TMP2, OFFSET( 7)(DATA))
+	ROUND(SC, SD, SE, SA, SB, F1, TMP2, OFFSET( 8)(DATA))
+	ROUND(SB, SC, SD, SE, SA, F1, TMP2, OFFSET( 9)(DATA))
+
+	ROUND(SA, SB, SC, SD, SE, F1, TMP2, OFFSET(10)(DATA))
+	ROUND(SE, SA, SB, SC, SD, F1, TMP2, OFFSET(11)(DATA))
+	ROUND(SD, SE, SA, SB, SC, F1, TMP2, OFFSET(12)(DATA))
+	ROUND(SC, SD, SE, SA, SB, F1, TMP2, OFFSET(13)(DATA))
+	ROUND(SB, SC, SD, SE, SA, F1, TMP2, OFFSET(14)(DATA))
+
+	ROUND(SA, SB, SC, SD, SE, F1, TMP2, OFFSET(15)(DATA))
+	EXPAND(16); ROUND(SE, SA, SB, SC, SD, F1, TMP2, TMP)
+	EXPAND(17); ROUND(SD, SE, SA, SB, SC, F1, TMP2, TMP)
+	EXPAND(18); ROUND(SC, SD, SE, SA, SB, F1, TMP2, TMP)
+	EXPAND(19); ROUND(SB, SC, SD, SE, SA, F1, TMP2, TMP)
+
+	/* TMP2 is free to use in these rounds */
+	movl	K2VALUE, TMP2
+	EXPAND(20); ROUND(SA, SB, SC, SD, SE, F2, TMP2, TMP)
+	EXPAND(21); ROUND(SE, SA, SB, SC, SD, F2, TMP2, TMP)
+	EXPAND(22); ROUND(SD, SE, SA, SB, SC, F2, TMP2, TMP)
+	EXPAND(23); ROUND(SC, SD, SE, SA, SB, F2, TMP2, TMP)
+	EXPAND(24); ROUND(SB, SC, SD, SE, SA, F2, TMP2, TMP)
+
+	EXPAND(25); ROUND(SA, SB, SC, SD, SE, F2, TMP2, TMP)
+	EXPAND(26); ROUND(SE, SA, SB, SC, SD, F2, TMP2, TMP)
+	EXPAND(27); ROUND(SD, SE, SA, SB, SC, F2, TMP2, TMP)
+	EXPAND(28); ROUND(SC, SD, SE, SA, SB, F2, TMP2, TMP)
+	EXPAND(29); ROUND(SB, SC, SD, SE, SA, F2, TMP2, TMP)
+
+	EXPAND(30); ROUND(SA, SB, SC, SD, SE, F2, TMP2, TMP)
+	EXPAND(31); ROUND(SE, SA, SB, SC, SD, F2, TMP2, TMP)
+	EXPAND(32); ROUND(SD, SE, SA, SB, SC, F2, TMP2, TMP)
+	EXPAND(33); ROUND(SC, SD, SE, SA, SB, F2, TMP2, TMP)
+	EXPAND(34); ROUND(SB, SC, SD, SE, SA, F2, TMP2, TMP)
+
+	EXPAND(35); ROUND(SA, SB, SC, SD, SE, F2, TMP2, TMP)
+	EXPAND(36); ROUND(SE, SA, SB, SC, SD, F2, TMP2, TMP)
+	EXPAND(37); ROUND(SD, SE, SA, SB, SC, F2, TMP2, TMP)
+	EXPAND(38); ROUND(SC, SD, SE, SA, SB, F2, TMP2, TMP)
+	EXPAND(39); ROUND(SB, SC, SD, SE, SA, F2, TMP2, TMP)
+
+	/* We have to put this constant on the stack */
+	movl	K3VALUE, TMP3
+	EXPAND(40); ROUND(SA, SB, SC, SD, SE, F3, TMP3, TMP)
+	EXPAND(41); ROUND(SE, SA, SB, SC, SD, F3, TMP3, TMP)
+	EXPAND(42); ROUND(SD, SE, SA, SB, SC, F3, TMP3, TMP)
+	EXPAND(43); ROUND(SC, SD, SE, SA, SB, F3, TMP3, TMP)
+	EXPAND(44); ROUND(SB, SC, SD, SE, SA, F3, TMP3, TMP)
+
+	EXPAND(45); ROUND(SA, SB, SC, SD, SE, F3, TMP3, TMP)
+	EXPAND(46); ROUND(SE, SA, SB, SC, SD, F3, TMP3, TMP)
+	EXPAND(47); ROUND(SD, SE, SA, SB, SC, F3, TMP3, TMP)
+	EXPAND(48); ROUND(SC, SD, SE, SA, SB, F3, TMP3, TMP)
+	EXPAND(49); ROUND(SB, SC, SD, SE, SA, F3, TMP3, TMP)
+
+	EXPAND(50); ROUND(SA, SB, SC, SD, SE, F3, TMP3, TMP)
+	EXPAND(51); ROUND(SE, SA, SB, SC, SD, F3, TMP3, TMP)
+	EXPAND(52); ROUND(SD, SE, SA, SB, SC, F3, TMP3, TMP)
+	EXPAND(53); ROUND(SC, SD, SE, SA, SB, F3, TMP3, TMP)
+	EXPAND(54); ROUND(SB, SC, SD, SE, SA, F3, TMP3, TMP)
+
+	EXPAND(55); ROUND(SA, SB, SC, SD, SE, F3, TMP3, TMP)
+	EXPAND(56); ROUND(SE, SA, SB, SC, SD, F3, TMP3, TMP)
+	EXPAND(57); ROUND(SD, SE, SA, SB, SC, F3, TMP3, TMP)
+	EXPAND(58); ROUND(SC, SD, SE, SA, SB, F3, TMP3, TMP)
+	EXPAND(59); ROUND(SB, SC, SD, SE, SA, F3, TMP3, TMP)
+
+	movl	K4VALUE, TMP2
+	EXPAND(60); ROUND(SA, SB, SC, SD, SE, F2, TMP2, TMP)
+	EXPAND(61); ROUND(SE, SA, SB, SC, SD, F2, TMP2, TMP)
+	EXPAND(62); ROUND(SD, SE, SA, SB, SC, F2, TMP2, TMP)
+	EXPAND(63); ROUND(SC, SD, SE, SA, SB, F2, TMP2, TMP)
+	EXPAND(64); ROUND(SB, SC, SD, SE, SA, F2, TMP2, TMP)
+
+	EXPAND(65); ROUND(SA, SB, SC, SD, SE, F2, TMP2, TMP)
+	EXPAND(66); ROUND(SE, SA, SB, SC, SD, F2, TMP2, TMP)
+	EXPAND(67); ROUND(SD, SE, SA, SB, SC, F2, TMP2, TMP)
+	EXPAND(68); ROUND(SC, SD, SE, SA, SB, F2, TMP2, TMP)
+	EXPAND(69); ROUND(SB, SC, SD, SE, SA, F2, TMP2, TMP)
+
+	EXPAND(70); ROUND(SA, SB, SC, SD, SE, F2, TMP2, TMP)
+	EXPAND(71); ROUND(SE, SA, SB, SC, SD, F2, TMP2, TMP)
+	EXPAND(72); ROUND(SD, SE, SA, SB, SC, F2, TMP2, TMP)
+	EXPAND(73); ROUND(SC, SD, SE, SA, SB, F2, TMP2, TMP)
+	EXPAND(74); ROUND(SB, SC, SD, SE, SA, F2, TMP2, TMP)
+
+	EXPAND(75); ROUND(SA, SB, SC, SD, SE, F2, TMP2, TMP)
+	EXPAND(76); ROUND(SE, SA, SB, SC, SD, F2, TMP2, TMP)
+	EXPAND(77); ROUND(SD, SE, SA, SB, SC, F2, TMP2, TMP)
+	EXPAND(78); ROUND(SC, SD, SE, SA, SB, F2, TMP2, TMP)
+	EXPAND(79); ROUND(SB, SC, SD, SE, SA, F2, TMP2, TMP)
+
+	/* Update the state vector */
+	movl	88(%esp),TMP
+	addl	SA, (TMP)
+	addl	SB, 4(TMP)
+	addl	SC, 8(TMP)
+	addl	SD, 12(TMP)
+	addl	SE, 16(TMP)
+
+	/* Clear the workspace for security */
+	CLEAR( 0); CLEAR( 1); CLEAR( 2); CLEAR( 3);
+	CLEAR( 4); CLEAR( 5); CLEAR( 6); CLEAR( 7);
+	CLEAR( 8); CLEAR( 9); CLEAR(10); CLEAR(11);
+	CLEAR(12); CLEAR(13); CLEAR(14); CLEAR(15);
+
+	addl	$68, %esp
+	popl	%edi
+	popl	%esi
+	popl	%ebp
+	popl	%ebx
+	ret
+
+/*
+ * It's possible to shave of half of the stores to tmp in the evaluation of f3,
+ * although it's probably not worth the effort. This is the trick:
+ *
+ * round(a,b,c,d,e,f,k,w) modifies only b,e.
+ *
+ * round(a,b,c,d,e,f3,k,w)
+ * round(e,a,b,c,d,f3,k,w)
+ *
+ * ; f3(b,c,d) = (b &amp; c) | (d &amp; (b | c))
+ *
+ *   movl b, tmp
+ *   andl c, tmp
+ *   movl tmp, tmp2
+ *   movl b, tmp
+ *   orl  c, tmp
+ *   andl d, tmp
+ *   orl tmp2, tmp
+ *
+ * and corresponding code for f3(a,b,c)
+ *
+ * Use the register allocated for c as a temporary?
+ *
+ *   movl c, tmp2
+ * ; f3(b,c,d) = (b &amp; c) | (d &amp; (b | c))
+ *   movl b, tmp
+ *   orl  c, tmp
+ *   andl b, c
+ *   andl d, tmp
+ *   orl  c, tmp
+ *
+ * ; f3(a,b,c) = (a &amp; b) | (c &amp; (a | b))
+ *   movl b, tmp
+ *   andl a, tmp
+ *   movl a, c
+ *   orl  b, c
+ *   andl tmp2, c
+ *   orl  c, tmp
+ *
+ *   movl tmp2, c
+ *
+ * Before: 14 instr, 2 store, 2 load
+ * After: 13 instr, 1 store, 2 load
+ *
+ * Final load can be folded into the next round,
+ *
+ * round(d,e,a,b,c,f3,k)
+ *
+ *   c += d &lt;&lt;&lt; 5 + f(e, a, b) + k + w
+ *
+ * if we arrange to have w placed directly into the register
+ * corresponding to w. That way we save one more instruction, total save
+ * of two instructions, one of which is a store, per two rounds. For the
+ * twenty rounds involving f3, that's 20 instructions, 10 of which are
+ * stores, or about 1.5 %.
+ */
diff --git a/arch/i386/crypto/sha1.c b/arch/i386/crypto/sha1.c
new file mode 100644
index 0000000..be8658b
--- /dev/null
+++ b/arch/i386/crypto/sha1.c
@@ -0,0 +1,161 @@
+/*
+ * x86-optimized SHA1 hash algorithm
+ *
+ * Originally from Nettle
+ * Ported to CryptoAPI by Benjamin Gilbert &lt;bgilbert@cs.cmu.edu&gt;
+ *
+ * Copyright (C) 2001 Peter Gutmann, Andrew Kuchling, Niels Möller
+ * Copyright (c) 2006 Carnegie Mellon University
+ *
+ * This file is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ */
+
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/string.h&gt;
+#include &lt;linux/crypto.h&gt;
+
+#define SHA1_DIGEST_SIZE 20
+#define SHA1_DATA_SIZE 64
+
+struct sha1_ctx {
+	u32 digest[SHA1_DIGEST_SIZE / 4];	/* Message digest */
+	u64 count;				/* Blocks processed */
+	u8 block[SHA1_DATA_SIZE];		/* SHA1 data buffer */
+	unsigned int index;			/* index into buffer */
+};
+
+/* Compression function. @state points to 5 u32 words, and @data points to
+   64 bytes of input data, possibly unaligned. */
+asmlinkage void sha1_compress(u32 *state, const u8 *data);
+
+/* Writes a 32-bit integer to an arbitrary pointer in big-endian byte order */
+static inline void write_u32_be(void *ptr, u32 i)
+{
+	u32 *p = ptr;
+	*p = cpu_to_be32(i);
+}
+
+static void sha1_init(struct crypto_tfm *data)
+{
+	struct sha1_ctx *ctx = crypto_tfm_ctx(data);
+
+	/* Set the h-vars to their initial values */
+	ctx-&gt;digest[0] = 0x67452301L;
+	ctx-&gt;digest[1] = 0xEFCDAB89L;
+	ctx-&gt;digest[2] = 0x98BADCFEL;
+	ctx-&gt;digest[3] = 0x10325476L;
+	ctx-&gt;digest[4] = 0xC3D2E1F0L;
+
+	/* Initialize block count */
+	ctx-&gt;count = 0;
+
+	/* Initialize buffer */
+	ctx-&gt;index = 0;
+}
+
+static void sha1_update(struct crypto_tfm *data, const u8 *buffer,
+			unsigned length)
+{
+	struct sha1_ctx *ctx = crypto_tfm_ctx(data);
+	if (ctx-&gt;index) {
+		/* Try to fill partial block */
+		unsigned left = SHA1_DATA_SIZE - ctx-&gt;index;
+		if (length &lt; left) {
+			memcpy(ctx-&gt;block + ctx-&gt;index, buffer, length);
+			ctx-&gt;index += length;
+			return;	/* Finished */
+		} else {
+			memcpy(ctx-&gt;block + ctx-&gt;index, buffer, left);
+			sha1_compress(ctx-&gt;digest, ctx-&gt;block);
+			ctx-&gt;count++;
+			buffer += left;
+			length -= left;
+		}
+	}
+	while (length &gt;= SHA1_DATA_SIZE) {
+		sha1_compress(ctx-&gt;digest, buffer);
+		ctx-&gt;count++;
+		buffer += SHA1_DATA_SIZE;
+		length -= SHA1_DATA_SIZE;
+	}
+	if ((ctx-&gt;index = length))
+		/* Buffer leftovers */
+		memcpy(ctx-&gt;block, buffer, length);
+}
+
+/* Final wrapup - pad to SHA1_DATA_SIZE-byte boundary with the bit pattern
+   1 0* (64-bit count of bits processed, MSB-first) */
+static void sha1_final(struct crypto_tfm *data, u8 *digest)
+{
+	struct sha1_ctx *ctx = crypto_tfm_ctx(data);
+	u64 bitcount;
+	unsigned i = ctx-&gt;index;
+
+	/* Set the first char of padding to 0x80.  This is safe since there is
+	   always at least one byte free */
+	BUG_ON(i &gt;= SHA1_DATA_SIZE);
+	ctx-&gt;block[i++] = 0x80;
+
+	if (i &gt; (SHA1_DATA_SIZE - 8)) {
+		/* No room for length in this block. Process it and
+		   pad with another one */
+		memset(ctx-&gt;block + i, 0, SHA1_DATA_SIZE - i);
+		sha1_compress(ctx-&gt;digest, ctx-&gt;block);
+		i = 0;
+	}
+	if (i &lt; (SHA1_DATA_SIZE - 8))
+		memset(ctx-&gt;block + i, 0, (SHA1_DATA_SIZE - 8) - i);
+
+	/* There are 512 = 2^9 bits in one block */
+	bitcount = (ctx-&gt;count &lt;&lt; 9) | (ctx-&gt;index &lt;&lt; 3);
+
+	/* This is slightly inefficient, as the numbers are converted to
+	   big-endian format, and will be converted back by the compression
+	   function. It's probably not worth the effort to fix this. */
+	write_u32_be(ctx-&gt;block + (SHA1_DATA_SIZE - 8), bitcount &gt;&gt; 32);
+	write_u32_be(ctx-&gt;block + (SHA1_DATA_SIZE - 4), bitcount);
+
+	sha1_compress(ctx-&gt;digest, ctx-&gt;block);
+
+	for (i = 0; i &lt; SHA1_DIGEST_SIZE / 4; i++, digest += 4)
+		write_u32_be(digest, ctx-&gt;digest[i]);
+
+	/* Wipe context */
+	memset(ctx, 0, sizeof(*ctx));
+}
+
+static struct crypto_alg alg = {
+	.cra_name	=	"sha1",
+	.cra_driver_name=	"sha1-i586",
+	.cra_priority	=	200,
+	.cra_flags	=	CRYPTO_ALG_TYPE_DIGEST,
+	.cra_blocksize	=	SHA1_DATA_SIZE,
+	.cra_ctxsize	=	sizeof(struct sha1_ctx),
+	.cra_module	=	THIS_MODULE,
+	.cra_alignmask	=	3,
+	.cra_list	=	LIST_HEAD_INIT(alg.cra_list),
+	.cra_u		=	{ .digest = {
+	.dia_digestsize	=	SHA1_DIGEST_SIZE,
+	.dia_init	=	sha1_init,
+	.dia_update	=	sha1_update,
+	.dia_final	=	sha1_final } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("x86-optimized SHA1 hash algorithm");
diff --git a/crypto/Kconfig b/crypto/Kconfig
index cbae839..c4e37b8 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -63,6 +63,14 @@ config CRYPTO_SHA1
 	help
 	  SHA-1 secure hash standard (FIPS 180-1/DFIPS 180-2).
 
+config CRYPTO_SHA1_586
+	tristate "SHA1 digest algorithm (i586)"
+	depends on (X86 || UML_X86) &amp;&amp; !64BIT
+	select CRYPTO_ALGAPI
+	help
+	  SHA-1 secure hash standard (FIPS 180-1/DFIPS 180-2).  This is the
+	  i586-optimized version.
+
 config CRYPTO_SHA1_S390
 	tristate "SHA1 digest algorithm (s390)"
 	depends on S390
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061028121421</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-10-28 12:14:21-0400</timestampReceived><subject>Announce loop-AES-v3.1e file/swap crypto package</subject><body>

loop-AES changes since previous release:
- Changed swapon program to use getpagesize() instead of PAGE_SIZE macro.
  Fixes build failure on some architectures. Patch form Max Vozeler.
- Fixed some confusing bits in README. Fix from Jens Lechtenboerger.
- Work around vanished &lt;linux/config.h&gt; in 2.6.19-rc2 kernel. Fixes build
  failure.
- Changed loop code to use kthread_create() instead of kernel_thread() on
  2.6.19-rc and newer kernels.
- Changed losetup and mount programs to output error message if gpg program
  does not exist when gpg encrypted key file is used.

bzip2 compressed tarball is here:

    http://loop-aes.sourceforge.net/loop-AES/loop-AES-v3.1e.tar.bz2
    md5sum 021d6a83e05a13ad84cd601d5e5ecefb

    http://loop-aes.sourceforge.net/loop-AES/loop-AES-v3.1e.tar.bz2.sign

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060901142639</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-09-01 14:26:39-0400</timestampReceived><subject>Re: Using particular gcc version to compile loop.o</subject><body>

Phil H wrote:
&gt; How do I tell make to use a particular gcc version on my machine (to match
&gt; the one my running kernle was compiled with)?
&gt; 
&gt; I don't think there is a CC=gcc-x.xx line in the makefile. Do I just set a
&gt; CC environment variable?

If you set CC=gcc-x.xx in your kernel Makefile, then it will be used
automatically. If you (or some build script) passed it as command line
parameter to your kernel build make command, then you need to add that same
CC=gcc-x.xx command line parameter to loop-AES build make command as well.
Additional ciphers package make command needs it too. Example:

 make LINUX_SOURCE=/usr/src/linux-foo KEYSCRUB=y CC=gcc-3.3

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060901164134</emailId><senderName>"cristih"</senderName><senderEmail>cristih@rnc.ro</senderEmail><timestampReceived>2006-09-01 16:41:34-0400</timestampReceived><subject>This is an autoreply...[Re: Returned mail: Data format error]</subject><body>

Hello,

This email address is no longer available.
If you want to contact me please use my 
new email cristih_ro from yahoo.com.

-- 
Kind Regards,
cristih
--
Powered by ROTLD (http://www.rotld.ro)

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060902010022</emailId><senderName></senderName><senderEmail>rsnel</senderEmail><timestampReceived>2006-09-02 01:00:22-0400</timestampReceived><subject>[PATCHv2 1/6] crypto: trivial comment improvements</subject><body>

From: Rik Snel &lt;rsnel@cube.dyndns.org&gt;

Just some minor comment nits.

- little-endian is better than low-endian
- and since it is called essiv everywere it should also be essiv
  in the comments (and not ess_iv)

Signed-off-by: Rik Snel &lt;rsnel@cube.dyndns.org&gt;
---
 drivers/md/dm-crypt.c |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c
index 91d4081..06961f7 100644
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@ -99,12 +99,12 @@ static kmem_cache_t *_crypt_io_pool;
 /*
  * Different IV generation algorithms:
  *
- * plain: the initial vector is the 32-bit low-endian version of the sector
+ * plain: the initial vector is the 32-bit little-endian version of the sector
  *        number, padded with zeros if neccessary.
  *
- * ess_iv: "encrypted sector|salt initial vector", the sector number is
- *         encrypted with the bulk cipher using a salt as key. The salt
- *         should be derived from the bulk cipher's key via hashing.
+ * essiv: "encrypted sector|salt initial vector", the sector number is
+ *        encrypted with the bulk cipher using a salt as key. The salt
+ *        should be derived from the bulk cipher's key via hashing.
  *
  * plumb: unimplemented, see:
  * http://article.gmane.org/gmane.linux.kernel.device-mapper.dm-crypt/454
-- 
1.4.1.1


-- 
VGER BF report: U 0.496196
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061018071510</emailId><senderName>Noriaki TAKAMIYA</senderName><senderEmail>takamiya@po.ntts.co.jp</senderEmail><timestampReceived>2006-10-18 07:15:10-0400</timestampReceived><subject>[PATCH 0/6] Changeset of Camellia cipher algorithm.</subject><body>

Hi,

  This set of the patches enables to use of the Camellia cipher
  algorithm for the ESP encryption.

  Git tree is also available on camellia20061017 branch at:
  git://git.skbuff.net/gitroot/takamiya/camellia20061017

  The following patches are available for the top of davem's net-2.6
  and herbert's cryptodev-2.6 trees.

  Thank you.

HEADLINES
---------

[PATCH 1/6] [CRYPTO] added Kconfig entry for Camellia.
[PATCH 2/6] [CRYPTO] added the code of Camellia cipher algorithm.
[PATCH 3/6] [CRYPTO] added the testing code of Camellia cipher algorithm.
[PATCH 4/6] [IPSEC] added the definition of Camellia cipher algorithm.
[PATCH 5/6] [IPSEC] added the entry of Camellia cipher algorithm to ealg_list[].
[PATCH 6/6] [CRYPTO] added the developer of Camellia cipher algorithm.

DIFFSTAT
--------

 Documentation/crypto/api-intro.txt |    5 
 crypto/Kconfig                     |   15 
 crypto/Makefile                    |    1 
 crypto/camellia.c                  | 1802 ++++++++++++++++++++++++++++++++++++-
 crypto/tcrypt.c                    |   43 
 crypto/tcrypt.h                    |  166 +++
 include/linux/pfkeyv2.h            |    2 
 net/xfrm/xfrm_algo.c               |   18 
 8 files changed, 2045 insertions(+), 7 deletions(-)

CHANGESETS
----------

commit 80a5df8127311212e99bd64103771de19c5908dd
Author: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;
Date:   Tue Oct 17 01:51:40 2006 +0900

    [CRYPTO] added the developer of Camellia cipher algorithm.
    
    This patch adds the developer of Camellia cipher algorithm.
    
    Signed-off-by: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;

commit 2253254f5a802c1cc8a5fc367fae911172f28846
Author: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;
Date:   Tue Oct 17 01:47:32 2006 +0900

    [IPSEC] added the entry of Camellia cipher algorithm to ealg_list[].
    
    This patch adds the entry of Camellia cipher algorithm to ealg_list[].
    
    Signed-off-by: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;

commit 1b6712cdb8fd31482d7e7da56e5f602357ec4aa4
Author: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;
Date:   Tue Oct 17 01:45:24 2006 +0900

    [IPSEC] added the definition of Camellia cipher algorithm.
    
    This patch adds the definitions used by pfkeyv2 interface for Camellia cipher
    algorithm.
    
    Signed-off-by: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;

commit e86050d8fbd04b1ace9c121ce90799c8210925be
Author: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;
Date:   Tue Oct 17 01:43:14 2006 +0900

    [CRYPTO] added the testing code of Camellia cipher algorithm.
    
    This patch adds the code of Camellia code for testing module.
    
    Signed-off-by: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;

commit db41e54cb7081b4cd034378f17b8f8225586e2e2
Author: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;
Date:   Tue Oct 17 01:34:15 2006 +0900

    [CRYPTO] added the code of Camellia cipher algorithm.
    
    This patch adds the main code of Camellia cipher algorithm.
    
    Signed-off-by: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;

commit 01b0c3898fdf1cb4da8cdf5577e58328ecb11e4e
Author: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;
Date:   Tue Oct 17 01:31:35 2006 +0900

    [CRYPTO] added Kconfig entry for Camellia.
    
    This patch adds the Kconfig entry for Camellia.
    
    Signed-off-by: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;

--
Noriaki TAKAMIYA
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061022050747</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-10-22 05:07:47-0400</timestampReceived><subject>Re: [PATCH 0/6] Changeset of Camellia cipher algorithm.</subject><body>

On Wed, Oct 18, 2006 at 07:15:10AM +0000, Noriaki TAKAMIYA wrote:
&gt; 
&gt; [PATCH 1/6] [CRYPTO] added Kconfig entry for Camellia.
&gt; [PATCH 2/6] [CRYPTO] added the code of Camellia cipher algorithm.
&gt; [PATCH 3/6] [CRYPTO] added the testing code of Camellia cipher algorithm.
&gt; [PATCH 4/6] [IPSEC] added the definition of Camellia cipher algorithm.
&gt; [PATCH 5/6] [IPSEC] added the entry of Camellia cipher algorithm to ealg_list[].
&gt; [PATCH 6/6] [CRYPTO] added the developer of Camellia cipher algorithm.

I've applied all the patches to cryptodev-2.6.  Thanks!
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061018071647</emailId><senderName>Noriaki TAKAMIYA</senderName><senderEmail>takamiya@po.ntts.co.jp</senderEmail><timestampReceived>2006-10-18 07:16:47-0400</timestampReceived><subject>[PATCH 2/6] [CRYPTO] added the code of Camellia cipher algorithm.</subject><body>

Hi,

  This patch adds the main code of Camellia cipher algorithm.

  Signed-off-by: Noriaki TAKAMIYA &lt;takamiya@po.ntts.co.jp&gt;

---

 crypto/Makefile   |    1 
 crypto/camellia.c | 1801 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 1802 insertions(+), 0 deletions(-)
 create mode 100644 crypto/camellia.c

db41e54cb7081b4cd034378f17b8f8225586e2e2
diff --git a/crypto/Makefile b/crypto/Makefile
index 7236620..817126b 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -31,6 +31,7 @@ obj-$(CONFIG_CRYPTO_TWOFISH) += twofish.
 obj-$(CONFIG_CRYPTO_TWOFISH_COMMON) += twofish_common.o
 obj-$(CONFIG_CRYPTO_SERPENT) += serpent.o
 obj-$(CONFIG_CRYPTO_AES) += aes.o
+obj-$(CONFIG_CRYPTO_CAMELLIA) += camellia.o
 obj-$(CONFIG_CRYPTO_CAST5) += cast5.o
 obj-$(CONFIG_CRYPTO_CAST6) += cast6.o
 obj-$(CONFIG_CRYPTO_ARC4) += arc4.o
diff --git a/crypto/camellia.c b/crypto/camellia.c
new file mode 100644
index 0000000..939209b
--- /dev/null
+++ b/crypto/camellia.c
@@ -0,0 +1,1801 @@
+/* 
+ * Copyright (C) 2006
+ * NTT (Nippon Telegraph and Telephone Corporation).
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * Algorithm Specification 
+ *  http://info.isl.ntt.co.jp/crypt/eng/camellia/specifications.html
+ */
+
+/*
+ *
+ * NOTE --- NOTE --- NOTE --- NOTE
+ * This implementation assumes that all memory addresses passed
+ * as parameters are four-byte aligned.
+ *
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;asm/byteorder.h&gt;
+
+
+#define CAMELLIA_MIN_KEY_SIZE        16
+#define CAMELLIA_MAX_KEY_SIZE        32
+#define CAMELLIA_BLOCK_SIZE 16
+#define CAMELLIA_TABLE_BYTE_LEN 272
+#define CAMELLIA_TABLE_WORD_LEN (CAMELLIA_TABLE_BYTE_LEN / 4)
+
+typedef u32 KEY_TABLE_TYPE[CAMELLIA_TABLE_WORD_LEN];
+
+
+/* key constants */
+
+#define CAMELLIA_SIGMA1L (0xA09E667FL)
+#define CAMELLIA_SIGMA1R (0x3BCC908BL)
+#define CAMELLIA_SIGMA2L (0xB67AE858L)
+#define CAMELLIA_SIGMA2R (0x4CAA73B2L)
+#define CAMELLIA_SIGMA3L (0xC6EF372FL)
+#define CAMELLIA_SIGMA3R (0xE94F82BEL)
+#define CAMELLIA_SIGMA4L (0x54FF53A5L)
+#define CAMELLIA_SIGMA4R (0xF1D36F1CL)
+#define CAMELLIA_SIGMA5L (0x10E527FAL)
+#define CAMELLIA_SIGMA5R (0xDE682D1DL)
+#define CAMELLIA_SIGMA6L (0xB05688C2L)
+#define CAMELLIA_SIGMA6R (0xB3E6C1FDL)
+
+struct camellia_ctx {
+	int key_length;
+	KEY_TABLE_TYPE key_table;
+};
+
+
+/*
+ *  macros
+ */
+
+
+# define GETU32(pt) (((u32)(pt)[0] &lt;&lt; 24)	\
+		     ^ ((u32)(pt)[1] &lt;&lt; 16)	\
+		     ^ ((u32)(pt)[2] &lt;&lt;  8)	\
+		     ^ ((u32)(pt)[3]))
+
+#define COPY4WORD(dst, src)			\
+    do {					\
+	(dst)[0]=(src)[0];			\
+	(dst)[1]=(src)[1];			\
+	(dst)[2]=(src)[2];			\
+	(dst)[3]=(src)[3];			\
+    }while(0)
+
+#define SWAP4WORD(word)				\
+    do {					\
+	CAMELLIA_SWAP4((word)[0]);		\
+	CAMELLIA_SWAP4((word)[1]);		\
+	CAMELLIA_SWAP4((word)[2]);		\
+	CAMELLIA_SWAP4((word)[3]);		\
+    }while(0)
+
+#define XOR4WORD(a, b)/* a = a ^ b */		\
+    do {					\
+	(a)[0]^=(b)[0];				\
+	(a)[1]^=(b)[1];				\
+	(a)[2]^=(b)[2];				\
+	(a)[3]^=(b)[3];				\
+    }while(0)
+
+#define XOR4WORD2(a, b, c)/* a = b ^ c */	\
+    do {					\
+	(a)[0]=(b)[0]^(c)[0];			\
+	(a)[1]=(b)[1]^(c)[1];			\
+	(a)[2]=(b)[2]^(c)[2];			\
+	(a)[3]=(b)[3]^(c)[3];			\
+    }while(0)
+
+#define CAMELLIA_SUBKEY_L(INDEX) (subkey[(INDEX)*2])
+#define CAMELLIA_SUBKEY_R(INDEX) (subkey[(INDEX)*2 + 1])
+
+/* rotation right shift 1byte */
+#define CAMELLIA_RR8(x) (((x) &gt;&gt; 8) + ((x) &lt;&lt; 24))
+/* rotation left shift 1bit */
+#define CAMELLIA_RL1(x) (((x) &lt;&lt; 1) + ((x) &gt;&gt; 31))
+/* rotation left shift 1byte */
+#define CAMELLIA_RL8(x) (((x) &lt;&lt; 8) + ((x) &gt;&gt; 24))
+
+#define CAMELLIA_ROLDQ(ll, lr, rl, rr, w0, w1, bits)	\
+    do {						\
+	w0 = ll;					\
+	ll = (ll &lt;&lt; bits) + (lr &gt;&gt; (32 - bits));	\
+	lr = (lr &lt;&lt; bits) + (rl &gt;&gt; (32 - bits));	\
+	rl = (rl &lt;&lt; bits) + (rr &gt;&gt; (32 - bits));	\
+	rr = (rr &lt;&lt; bits) + (w0 &gt;&gt; (32 - bits));	\
+    } while(0)
+
+#define CAMELLIA_ROLDQo32(ll, lr, rl, rr, w0, w1, bits)	\
+    do {						\
+	w0 = ll;					\
+	w1 = lr;					\
+	ll = (lr &lt;&lt; (bits - 32)) + (rl &gt;&gt; (64 - bits));	\
+	lr = (rl &lt;&lt; (bits - 32)) + (rr &gt;&gt; (64 - bits));	\
+	rl = (rr &lt;&lt; (bits - 32)) + (w0 &gt;&gt; (64 - bits));	\
+	rr = (w0 &lt;&lt; (bits - 32)) + (w1 &gt;&gt; (64 - bits));	\
+    } while(0)
+
+#define CAMELLIA_SP1110(INDEX) (camellia_sp1110[(INDEX)])
+#define CAMELLIA_SP0222(INDEX) (camellia_sp0222[(INDEX)])
+#define CAMELLIA_SP3033(INDEX) (camellia_sp3033[(INDEX)])
+#define CAMELLIA_SP4404(INDEX) (camellia_sp4404[(INDEX)])
+
+#define CAMELLIA_F(xl, xr, kl, kr, yl, yr, il, ir, t0, t1)	\
+    do {							\
+	il = xl ^ kl;						\
+	ir = xr ^ kr;						\
+	t0 = il &gt;&gt; 16;						\
+	t1 = ir &gt;&gt; 16;						\
+	yl = CAMELLIA_SP1110(ir &amp; 0xff)				\
+	    ^ CAMELLIA_SP0222((t1 &gt;&gt; 8) &amp; 0xff)			\
+	    ^ CAMELLIA_SP3033(t1 &amp; 0xff)			\
+	    ^ CAMELLIA_SP4404((ir &gt;&gt; 8) &amp; 0xff);		\
+	yr = CAMELLIA_SP1110((t0 &gt;&gt; 8) &amp; 0xff)			\
+	    ^ CAMELLIA_SP0222(t0 &amp; 0xff)			\
+	    ^ CAMELLIA_SP3033((il &gt;&gt; 8) &amp; 0xff)			\
+	    ^ CAMELLIA_SP4404(il &amp; 0xff);			\
+	yl ^= yr;						\
+	yr = CAMELLIA_RR8(yr);					\
+	yr ^= yl;						\
+    } while(0)
+
+
+/*
+ * for speed up
+ *
+ */
+#define CAMELLIA_FLS(ll, lr, rl, rr, kll, klr, krl, krr, t0, t1, t2, t3) \
+    do {								\
+	t0 = kll;							\
+	t2 = krr;							\
+	t0 &amp;= ll;							\
+	t2 |= rr;							\
+	rl ^= t2;							\
+	lr ^= CAMELLIA_RL1(t0);						\
+	t3 = krl;							\
+	t1 = klr;							\
+	t3 &amp;= rl;							\
+	t1 |= lr;							\
+	ll ^= t1;							\
+	rr ^= CAMELLIA_RL1(t3);						\
+    } while(0)
+
+#define CAMELLIA_ROUNDSM(xl, xr, kl, kr, yl, yr, il, ir, t0, t1)	\
+    do {								\
+	ir =  CAMELLIA_SP1110(xr &amp; 0xff);				\
+	il =  CAMELLIA_SP1110((xl&gt;&gt;24) &amp; 0xff);				\
+	ir ^= CAMELLIA_SP0222((xr&gt;&gt;24) &amp; 0xff);				\
+	il ^= CAMELLIA_SP0222((xl&gt;&gt;16) &amp; 0xff);				\
+	ir ^= CAMELLIA_SP3033((xr&gt;&gt;16) &amp; 0xff);				\
+	il ^= CAMELLIA_SP3033((xl&gt;&gt;8) &amp; 0xff);				\
+	ir ^= CAMELLIA_SP4404((xr&gt;&gt;8) &amp; 0xff);				\
+	il ^= CAMELLIA_SP4404(xl &amp; 0xff);				\
+	il ^= kl;							\
+	ir ^= il ^ kr;							\
+	yl ^= ir;							\
+	yr ^= CAMELLIA_RR8(il) ^ ir;					\
+    } while(0)
+
+/**
+ * Stuff related to the Camellia key schedule
+ */
+#define SUBL(x) subL[(x)]
+#define SUBR(x) subR[(x)]
+
+
+static const u32 camellia_sp1110[256] = {
+	0x70707000,0x82828200,0x2c2c2c00,0xececec00,
+	0xb3b3b300,0x27272700,0xc0c0c000,0xe5e5e500,
+	0xe4e4e400,0x85858500,0x57575700,0x35353500,
+	0xeaeaea00,0x0c0c0c00,0xaeaeae00,0x41414100,
+	0x23232300,0xefefef00,0x6b6b6b00,0x93939300,
+	0x45454500,0x19191900,0xa5a5a500,0x21212100,
+	0xededed00,0x0e0e0e00,0x4f4f4f00,0x4e4e4e00,
+	0x1d1d1d00,0x65656500,0x92929200,0xbdbdbd00,
+	0x86868600,0xb8b8b800,0xafafaf00,0x8f8f8f00,
+	0x7c7c7c00,0xebebeb00,0x1f1f1f00,0xcecece00,
+	0x3e3e3e00,0x30303000,0xdcdcdc00,0x5f5f5f00,
+	0x5e5e5e00,0xc5c5c500,0x0b0b0b00,0x1a1a1a00,
+	0xa6a6a600,0xe1e1e100,0x39393900,0xcacaca00,
+	0xd5d5d500,0x47474700,0x5d5d5d00,0x3d3d3d00,
+	0xd9d9d900,0x01010100,0x5a5a5a00,0xd6d6d600,
+	0x51515100,0x56565600,0x6c6c6c00,0x4d4d4d00,
+	0x8b8b8b00,0x0d0d0d00,0x9a9a9a00,0x66666600,
+	0xfbfbfb00,0xcccccc00,0xb0b0b000,0x2d2d2d00,
+	0x74747400,0x12121200,0x2b2b2b00,0x20202000,
+	0xf0f0f000,0xb1b1b100,0x84848400,0x99999900,
+	0xdfdfdf00,0x4c4c4c00,0xcbcbcb00,0xc2c2c200,
+	0x34343400,0x7e7e7e00,0x76767600,0x05050500,
+	0x6d6d6d00,0xb7b7b700,0xa9a9a900,0x31313100,
+	0xd1d1d100,0x17171700,0x04040400,0xd7d7d700,
+	0x14141400,0x58585800,0x3a3a3a00,0x61616100,
+	0xdedede00,0x1b1b1b00,0x11111100,0x1c1c1c00,
+	0x32323200,0x0f0f0f00,0x9c9c9c00,0x16161600,
+	0x53535300,0x18181800,0xf2f2f200,0x22222200,
+	0xfefefe00,0x44444400,0xcfcfcf00,0xb2b2b200,
+	0xc3c3c300,0xb5b5b500,0x7a7a7a00,0x91919100,
+	0x24242400,0x08080800,0xe8e8e800,0xa8a8a800,
+	0x60606000,0xfcfcfc00,0x69696900,0x50505000,
+	0xaaaaaa00,0xd0d0d000,0xa0a0a000,0x7d7d7d00,
+	0xa1a1a100,0x89898900,0x62626200,0x97979700,
+	0x54545400,0x5b5b5b00,0x1e1e1e00,0x95959500,
+	0xe0e0e000,0xffffff00,0x64646400,0xd2d2d200,
+	0x10101000,0xc4c4c400,0x00000000,0x48484800,
+	0xa3a3a300,0xf7f7f700,0x75757500,0xdbdbdb00,
+	0x8a8a8a00,0x03030300,0xe6e6e600,0xdadada00,
+	0x09090900,0x3f3f3f00,0xdddddd00,0x94949400,
+	0x87878700,0x5c5c5c00,0x83838300,0x02020200,
+	0xcdcdcd00,0x4a4a4a00,0x90909000,0x33333300,
+	0x73737300,0x67676700,0xf6f6f600,0xf3f3f300,
+	0x9d9d9d00,0x7f7f7f00,0xbfbfbf00,0xe2e2e200,
+	0x52525200,0x9b9b9b00,0xd8d8d800,0x26262600,
+	0xc8c8c800,0x37373700,0xc6c6c600,0x3b3b3b00,
+	0x81818100,0x96969600,0x6f6f6f00,0x4b4b4b00,
+	0x13131300,0xbebebe00,0x63636300,0x2e2e2e00,
+	0xe9e9e900,0x79797900,0xa7a7a700,0x8c8c8c00,
+	0x9f9f9f00,0x6e6e6e00,0xbcbcbc00,0x8e8e8e00,
+	0x29292900,0xf5f5f500,0xf9f9f900,0xb6b6b600,
+	0x2f2f2f00,0xfdfdfd00,0xb4b4b400,0x59595900,
+	0x78787800,0x98989800,0x06060600,0x6a6a6a00,
+	0xe7e7e700,0x46464600,0x71717100,0xbababa00,
+	0xd4d4d400,0x25252500,0xababab00,0x42424200,
+	0x88888800,0xa2a2a200,0x8d8d8d00,0xfafafa00,
+	0x72727200,0x07070700,0xb9b9b900,0x55555500,
+	0xf8f8f800,0xeeeeee00,0xacacac00,0x0a0a0a00,
+	0x36363600,0x49494900,0x2a2a2a00,0x68686800,
+	0x3c3c3c00,0x38383800,0xf1f1f100,0xa4a4a400,
+	0x40404000,0x28282800,0xd3d3d300,0x7b7b7b00,
+	0xbbbbbb00,0xc9c9c900,0x43434300,0xc1c1c100,
+	0x15151500,0xe3e3e300,0xadadad00,0xf4f4f400,
+	0x77777700,0xc7c7c700,0x80808000,0x9e9e9e00,
+};
+
+static const u32 camellia_sp0222[256] = {
+	0x00e0e0e0,0x00050505,0x00585858,0x00d9d9d9,
+	0x00676767,0x004e4e4e,0x00818181,0x00cbcbcb,
+	0x00c9c9c9,0x000b0b0b,0x00aeaeae,0x006a6a6a,
+	0x00d5d5d5,0x00181818,0x005d5d5d,0x00828282,
+	0x00464646,0x00dfdfdf,0x00d6d6d6,0x00272727,
+	0x008a8a8a,0x00323232,0x004b4b4b,0x00424242,
+	0x00dbdbdb,0x001c1c1c,0x009e9e9e,0x009c9c9c,
+	0x003a3a3a,0x00cacaca,0x00252525,0x007b7b7b,
+	0x000d0d0d,0x00717171,0x005f5f5f,0x001f1f1f,
+	0x00f8f8f8,0x00d7d7d7,0x003e3e3e,0x009d9d9d,
+	0x007c7c7c,0x00606060,0x00b9b9b9,0x00bebebe,
+	0x00bcbcbc,0x008b8b8b,0x00161616,0x00343434,
+	0x004d4d4d,0x00c3c3c3,0x00727272,0x00959595,
+	0x00ababab,0x008e8e8e,0x00bababa,0x007a7a7a,
+	0x00b3b3b3,0x00020202,0x00b4b4b4,0x00adadad,
+	0x00a2a2a2,0x00acacac,0x00d8d8d8,0x009a9a9a,
+	0x00171717,0x001a1a1a,0x00353535,0x00cccccc,
+	0x00f7f7f7,0x00999999,0x00616161,0x005a5a5a,
+	0x00e8e8e8,0x00242424,0x00565656,0x00404040,
+	0x00e1e1e1,0x00636363,0x00090909,0x00333333,
+	0x00bfbfbf,0x00989898,0x00979797,0x00858585,
+	0x00686868,0x00fcfcfc,0x00ececec,0x000a0a0a,
+	0x00dadada,0x006f6f6f,0x00535353,0x00626262,
+	0x00a3a3a3,0x002e2e2e,0x00080808,0x00afafaf,
+	0x00282828,0x00b0b0b0,0x00747474,0x00c2c2c2,
+	0x00bdbdbd,0x00363636,0x00222222,0x00383838,
+	0x00646464,0x001e1e1e,0x00393939,0x002c2c2c,
+	0x00a6a6a6,0x00303030,0x00e5e5e5,0x00444444,
+	0x00fdfdfd,0x00888888,0x009f9f9f,0x00656565,
+	0x00878787,0x006b6b6b,0x00f4f4f4,0x00232323,
+	0x00484848,0x00101010,0x00d1d1d1,0x00515151,
+	0x00c0c0c0,0x00f9f9f9,0x00d2d2d2,0x00a0a0a0,
+	0x00555555,0x00a1a1a1,0x00414141,0x00fafafa,
+	0x00434343,0x00131313,0x00c4c4c4,0x002f2f2f,
+	0x00a8a8a8,0x00b6b6b6,0x003c3c3c,0x002b2b2b,
+	0x00c1c1c1,0x00ffffff,0x00c8c8c8,0x00a5a5a5,
+	0x00202020,0x00898989,0x00000000,0x00909090,
+	0x00474747,0x00efefef,0x00eaeaea,0x00b7b7b7,
+	0x00151515,0x00060606,0x00cdcdcd,0x00b5b5b5,
+	0x00121212,0x007e7e7e,0x00bbbbbb,0x00292929,
+	0x000f0f0f,0x00b8b8b8,0x00070707,0x00040404,
+	0x009b9b9b,0x00949494,0x00212121,0x00666666,
+	0x00e6e6e6,0x00cecece,0x00ededed,0x00e7e7e7,
+	0x003b3b3b,0x00fefefe,0x007f7f7f,0x00c5c5c5,
+	0x00a4a4a4,0x00373737,0x00b1b1b1,0x004c4c4c,
+	0x00919191,0x006e6e6e,0x008d8d8d,0x00767676,
+	0x00030303,0x002d2d2d,0x00dedede,0x00969696,
+	0x00262626,0x007d7d7d,0x00c6c6c6,0x005c5c5c,
+	0x00d3d3d3,0x00f2f2f2,0x004f4f4f,0x00191919,
+	0x003f3f3f,0x00dcdcdc,0x00797979,0x001d1d1d,
+	0x00525252,0x00ebebeb,0x00f3f3f3,0x006d6d6d,
+	0x005e5e5e,0x00fbfbfb,0x00696969,0x00b2b2b2,
+	0x00f0f0f0,0x00313131,0x000c0c0c,0x00d4d4d4,
+	0x00cfcfcf,0x008c8c8c,0x00e2e2e2,0x00757575,
+	0x00a9a9a9,0x004a4a4a,0x00575757,0x00848484,
+	0x00111111,0x00454545,0x001b1b1b,0x00f5f5f5,
+	0x00e4e4e4,0x000e0e0e,0x00737373,0x00aaaaaa,
+	0x00f1f1f1,0x00dddddd,0x00595959,0x00141414,
+	0x006c6c6c,0x00929292,0x00545454,0x00d0d0d0,
+	0x00787878,0x00707070,0x00e3e3e3,0x00494949,
+	0x00808080,0x00505050,0x00a7a7a7,0x00f6f6f6,
+	0x00777777,0x00939393,0x00868686,0x00838383,
+	0x002a2a2a,0x00c7c7c7,0x005b5b5b,0x00e9e9e9,
+	0x00eeeeee,0x008f8f8f,0x00010101,0x003d3d3d,
+};
+
+static const u32 camellia_sp3033[256] = {
+	0x38003838,0x41004141,0x16001616,0x76007676,
+	0xd900d9d9,0x93009393,0x60006060,0xf200f2f2,
+	0x72007272,0xc200c2c2,0xab00abab,0x9a009a9a,
+	0x75007575,0x06000606,0x57005757,0xa000a0a0,
+	0x91009191,0xf700f7f7,0xb500b5b5,0xc900c9c9,
+	0xa200a2a2,0x8c008c8c,0xd200d2d2,0x90009090,
+	0xf600f6f6,0x07000707,0xa700a7a7,0x27002727,
+	0x8e008e8e,0xb200b2b2,0x49004949,0xde00dede,
+	0x43004343,0x5c005c5c,0xd700d7d7,0xc700c7c7,
+	0x3e003e3e,0xf500f5f5,0x8f008f8f,0x67006767,
+	0x1f001f1f,0x18001818,0x6e006e6e,0xaf00afaf,
+	0x2f002f2f,0xe200e2e2,0x85008585,0x0d000d0d,
+	0x53005353,0xf000f0f0,0x9c009c9c,0x65006565,
+	0xea00eaea,0xa300a3a3,0xae00aeae,0x9e009e9e,
+	0xec00ecec,0x80008080,0x2d002d2d,0x6b006b6b,
+	0xa800a8a8,0x2b002b2b,0x36003636,0xa600a6a6,
+	0xc500c5c5,0x86008686,0x4d004d4d,0x33003333,
+	0xfd00fdfd,0x66006666,0x58005858,0x96009696,
+	0x3a003a3a,0x09000909,0x95009595,0x10001010,
+	0x78007878,0xd800d8d8,0x42004242,0xcc00cccc,
+	0xef00efef,0x26002626,0xe500e5e5,0x61006161,
+	0x1a001a1a,0x3f003f3f,0x3b003b3b,0x82008282,
+	0xb600b6b6,0xdb00dbdb,0xd400d4d4,0x98009898,
+	0xe800e8e8,0x8b008b8b,0x02000202,0xeb00ebeb,
+	0x0a000a0a,0x2c002c2c,0x1d001d1d,0xb000b0b0,
+	0x6f006f6f,0x8d008d8d,0x88008888,0x0e000e0e,
+	0x19001919,0x87008787,0x4e004e4e,0x0b000b0b,
+	0xa900a9a9,0x0c000c0c,0x79007979,0x11001111,
+	0x7f007f7f,0x22002222,0xe700e7e7,0x59005959,
+	0xe100e1e1,0xda00dada,0x3d003d3d,0xc800c8c8,
+	0x12001212,0x04000404,0x74007474,0x54005454,
+	0x30003030,0x7e007e7e,0xb400b4b4,0x28002828,
+	0x55005555,0x68006868,0x50005050,0xbe00bebe,
+	0xd000d0d0,0xc400c4c4,0x31003131,0xcb00cbcb,
+	0x2a002a2a,0xad00adad,0x0f000f0f,0xca00caca,
+	0x70007070,0xff00ffff,0x32003232,0x69006969,
+	0x08000808,0x62006262,0x00000000,0x24002424,
+	0xd100d1d1,0xfb00fbfb,0xba00baba,0xed00eded,
+	0x45004545,0x81008181,0x73007373,0x6d006d6d,
+	0x84008484,0x9f009f9f,0xee00eeee,0x4a004a4a,
+	0xc300c3c3,0x2e002e2e,0xc100c1c1,0x01000101,
+	0xe600e6e6,0x25002525,0x48004848,0x99009999,
+	0xb900b9b9,0xb300b3b3,0x7b007b7b,0xf900f9f9,
+	0xce00cece,0xbf00bfbf,0xdf00dfdf,0x71007171,
+	0x29002929,0xcd00cdcd,0x6c006c6c,0x13001313,
+	0x64006464,0x9b009b9b,0x63006363,0x9d009d9d,
+	0xc000c0c0,0x4b004b4b,0xb700b7b7,0xa500a5a5,
+	0x89008989,0x5f005f5f,0xb100b1b1,0x17001717,
+	0xf400f4f4,0xbc00bcbc,0xd300d3d3,0x46004646,
+	0xcf00cfcf,0x37003737,0x5e005e5e,0x47004747,
+	0x94009494,0xfa00fafa,0xfc00fcfc,0x5b005b5b,
+	0x97009797,0xfe00fefe,0x5a005a5a,0xac00acac,
+	0x3c003c3c,0x4c004c4c,0x03000303,0x35003535,
+	0xf300f3f3,0x23002323,0xb800b8b8,0x5d005d5d,
+	0x6a006a6a,0x92009292,0xd500d5d5,0x21002121,
+	0x44004444,0x51005151,0xc600c6c6,0x7d007d7d,
+	0x39003939,0x83008383,0xdc00dcdc,0xaa00aaaa,
+	0x7c007c7c,0x77007777,0x56005656,0x05000505,
+	0x1b001b1b,0xa400a4a4,0x15001515,0x34003434,
+	0x1e001e1e,0x1c001c1c,0xf800f8f8,0x52005252,
+	0x20002020,0x14001414,0xe900e9e9,0xbd00bdbd,
+	0xdd00dddd,0xe400e4e4,0xa100a1a1,0xe000e0e0,
+	0x8a008a8a,0xf100f1f1,0xd600d6d6,0x7a007a7a,
+	0xbb00bbbb,0xe300e3e3,0x40004040,0x4f004f4f,
+};
+
+static const u32 camellia_sp4404[256] = {
+	0x70700070,0x2c2c002c,0xb3b300b3,0xc0c000c0,
+	0xe4e400e4,0x57570057,0xeaea00ea,0xaeae00ae,
+	0x23230023,0x6b6b006b,0x45450045,0xa5a500a5,
+	0xeded00ed,0x4f4f004f,0x1d1d001d,0x92920092,
+	0x86860086,0xafaf00af,0x7c7c007c,0x1f1f001f,
+	0x3e3e003e,0xdcdc00dc,0x5e5e005e,0x0b0b000b,
+	0xa6a600a6,0x39390039,0xd5d500d5,0x5d5d005d,
+	0xd9d900d9,0x5a5a005a,0x51510051,0x6c6c006c,
+	0x8b8b008b,0x9a9a009a,0xfbfb00fb,0xb0b000b0,
+	0x74740074,0x2b2b002b,0xf0f000f0,0x84840084,
+	0xdfdf00df,0xcbcb00cb,0x34340034,0x76760076,
+	0x6d6d006d,0xa9a900a9,0xd1d100d1,0x04040004,
+	0x14140014,0x3a3a003a,0xdede00de,0x11110011,
+	0x32320032,0x9c9c009c,0x53530053,0xf2f200f2,
+	0xfefe00fe,0xcfcf00cf,0xc3c300c3,0x7a7a007a,
+	0x24240024,0xe8e800e8,0x60600060,0x69690069,
+	0xaaaa00aa,0xa0a000a0,0xa1a100a1,0x62620062,
+	0x54540054,0x1e1e001e,0xe0e000e0,0x64640064,
+	0x10100010,0x00000000,0xa3a300a3,0x75750075,
+	0x8a8a008a,0xe6e600e6,0x09090009,0xdddd00dd,
+	0x87870087,0x83830083,0xcdcd00cd,0x90900090,
+	0x73730073,0xf6f600f6,0x9d9d009d,0xbfbf00bf,
+	0x52520052,0xd8d800d8,0xc8c800c8,0xc6c600c6,
+	0x81810081,0x6f6f006f,0x13130013,0x63630063,
+	0xe9e900e9,0xa7a700a7,0x9f9f009f,0xbcbc00bc,
+	0x29290029,0xf9f900f9,0x2f2f002f,0xb4b400b4,
+	0x78780078,0x06060006,0xe7e700e7,0x71710071,
+	0xd4d400d4,0xabab00ab,0x88880088,0x8d8d008d,
+	0x72720072,0xb9b900b9,0xf8f800f8,0xacac00ac,
+	0x36360036,0x2a2a002a,0x3c3c003c,0xf1f100f1,
+	0x40400040,0xd3d300d3,0xbbbb00bb,0x43430043,
+	0x15150015,0xadad00ad,0x77770077,0x80800080,
+	0x82820082,0xecec00ec,0x27270027,0xe5e500e5,
+	0x85850085,0x35350035,0x0c0c000c,0x41410041,
+	0xefef00ef,0x93930093,0x19190019,0x21210021,
+	0x0e0e000e,0x4e4e004e,0x65650065,0xbdbd00bd,
+	0xb8b800b8,0x8f8f008f,0xebeb00eb,0xcece00ce,
+	0x30300030,0x5f5f005f,0xc5c500c5,0x1a1a001a,
+	0xe1e100e1,0xcaca00ca,0x47470047,0x3d3d003d,
+	0x01010001,0xd6d600d6,0x56560056,0x4d4d004d,
+	0x0d0d000d,0x66660066,0xcccc00cc,0x2d2d002d,
+	0x12120012,0x20200020,0xb1b100b1,0x99990099,
+	0x4c4c004c,0xc2c200c2,0x7e7e007e,0x05050005,
+	0xb7b700b7,0x31310031,0x17170017,0xd7d700d7,
+	0x58580058,0x61610061,0x1b1b001b,0x1c1c001c,
+	0x0f0f000f,0x16160016,0x18180018,0x22220022,
+	0x44440044,0xb2b200b2,0xb5b500b5,0x91910091,
+	0x08080008,0xa8a800a8,0xfcfc00fc,0x50500050,
+	0xd0d000d0,0x7d7d007d,0x89890089,0x97970097,
+	0x5b5b005b,0x95950095,0xffff00ff,0xd2d200d2,
+	0xc4c400c4,0x48480048,0xf7f700f7,0xdbdb00db,
+	0x03030003,0xdada00da,0x3f3f003f,0x94940094,
+	0x5c5c005c,0x02020002,0x4a4a004a,0x33330033,
+	0x67670067,0xf3f300f3,0x7f7f007f,0xe2e200e2,
+	0x9b9b009b,0x26260026,0x37370037,0x3b3b003b,
+	0x96960096,0x4b4b004b,0xbebe00be,0x2e2e002e,
+	0x79790079,0x8c8c008c,0x6e6e006e,0x8e8e008e,
+	0xf5f500f5,0xb6b600b6,0xfdfd00fd,0x59590059,
+	0x98980098,0x6a6a006a,0x46460046,0xbaba00ba,
+	0x25250025,0x42420042,0xa2a200a2,0xfafa00fa,
+	0x07070007,0x55550055,0xeeee00ee,0x0a0a000a,
+	0x49490049,0x68680068,0x38380038,0xa4a400a4,
+	0x28280028,0x7b7b007b,0xc9c900c9,0xc1c100c1,
+	0xe3e300e3,0xf4f400f4,0xc7c700c7,0x9e9e009e,
+};
+
+
+
+void camellia_setup128(const unsigned char *key, u32 *subkey)
+{
+	u32 kll, klr, krl, krr;
+	u32 il, ir, t0, t1, w0, w1;
+	u32 kw4l, kw4r, dw, tl, tr;
+	u32 subL[26];
+	u32 subR[26];
+	
+	/**
+	 *  k == kll || klr || krl || krr (|| is concatination)
+	 */
+	kll = GETU32(key     );
+	klr = GETU32(key +  4);
+	krl = GETU32(key +  8);
+	krr = GETU32(key + 12);
+	/**
+	 * generate KL dependent subkeys
+	 */
+	/* kw1 */
+	SUBL(0) = kll; SUBR(0) = klr;
+	/* kw2 */
+	SUBL(1) = krl; SUBR(1) = krr;
+	/* rotation left shift 15bit */
+	CAMELLIA_ROLDQ(kll, klr, krl, krr, w0, w1, 15);
+	/* k3 */
+	SUBL(4) = kll; SUBR(4) = klr;
+	/* k4 */
+	SUBL(5) = krl; SUBR(5) = krr;
+	/* rotation left shift 15+30bit */
+	CAMELLIA_ROLDQ(kll, klr, krl, krr, w0, w1, 30);
+	/* k7 */
+	SUBL(10) = kll; SUBR(10) = klr;
+	/* k8 */
+	SUBL(11) = krl; SUBR(11) = krr;
+	/* rotation left shift 15+30+15bit */
+	CAMELLIA_ROLDQ(kll, klr, krl, krr, w0, w1, 15);
+	/* k10 */
+	SUBL(13) = krl; SUBR(13) = krr;
+	/* rotation left shift 15+30+15+17 bit */
+	CAMELLIA_ROLDQ(kll, klr, krl, krr, w0, w1, 17);
+	/* kl3 */
+	SUBL(16) = kll; SUBR(16) = klr;
+	/* kl4 */
+	SUBL(17) = krl; SUBR(17) = krr;
+	/* rotation left shift 15+30+15+17+17 bit */
+	CAMELLIA_ROLDQ(kll, klr, krl, krr, w0, w1, 17);
+	/* k13 */
+	SUBL(18) = kll; SUBR(18) = klr;
+	/* k14 */
+	SUBL(19) = krl; SUBR(19) = krr;
+	/* rotation left shift 15+30+15+17+17+17 bit */
+	CAMELLIA_ROLDQ(kll, klr, krl, krr, w0, w1, 17);
+	/* k17 */
+	SUBL(22) = kll; SUBR(22) = klr;
+	/* k18 */
+	SUBL(23) = krl; SUBR(23) = krr;
+	
+	/* generate KA */
+	kll = SUBL(0); klr = SUBR(0);
+	krl = SUBL(1); krr = SUBR(1);
+	CAMELLIA_F(kll, klr,
+		   CAMELLIA_SIGMA1L, CAMELLIA_SIGMA1R,
+		   w0, w1, il, ir, t0, t1);
+	krl ^= w0; krr ^= w1;
+	CAMELLIA_F(krl, krr,
+		   CAMELLIA_SIGMA2L, CAMELLIA_SIGMA2R,
+		   kll, klr, il, ir, t0, t1);
+	/* current status == (kll, klr, w0, w1) */
+	CAMELLIA_F(kll, klr,
+		   CAMELLIA_SIGMA3L, CAMELLIA_SIGMA3R,
+		   krl, krr, il, ir, t0, t1);
+	krl ^= w0; krr ^= w1;
+	CAMELLIA_F(krl, krr,
+		   CAMELLIA_SIGMA4L, CAMELLIA_SIGMA4R,
+		   w0, w1, il, ir, t0, t1);
+	kll ^= w0; klr ^= w1;
+	
+	/* generate KA dependent subkeys */
+	/* k1, k2 */
+	SUBL(2) = kll; SUBR(2) = klr;
+	SUBL(3) = krl; SUBR(3) = krr;
+	CAMELLIA_ROLDQ(kll, klr, krl, krr, w0, w1, 15);
+	/* k5,k6 */
+	SUBL(6) = kll; SUBR(6) = klr;
+	SUBL(7) = krl; SUBR(7) = krr;
+	CAMELLIA_ROLDQ(kll, klr, krl, krr, w0, w1, 15);
+	/* kl1, kl2 */
+	SUBL(8) = kll; SUBR(8) = klr;
+	SUBL(9) = krl; SUBR(9) = krr;
+	CAMELLIA_ROLDQ(kll, klr, krl, krr, w0, w1, 15);
+	/* k9 */
+	SUBL(12) = kll; SUBR(12) = klr;
+	CAMELLIA_ROLDQ(kll, klr, krl, krr, w0, w1, 15);
+	/* k11, k12 */
+	SUBL(14) = kll; SUBR(14) = klr;
+	SUBL(15) = krl; SUBR(15) = krr;
+	CAMELLIA_ROLDQo32(kll, klr, krl, krr, w0, w1, 34);
+	/* k15, k16 */
+	SUBL(20) = kll; SUBR(20) = klr;
+	SUBL(21) = krl; SUBR(21) = krr;
+	CAMELLIA_ROLDQ(kll, klr, krl, krr, w0, w1, 17);
+	/* kw3, kw4 */
+	SUBL(24) = kll; SUBR(24) = klr;
+	SUBL(25) = krl; SUBR(25) = krr;
+
+
+	/* absorb kw2 to other subkeys */
+	/* round 2 */
+	SUBL(3) ^= SUBL(1); SUBR(3) ^= SUBR(1);
+	/* round 4 */
+	SUBL(5) ^= SUBL(1); SUBR(5) ^= SUBR(1);
+	/* round 6 */
+	SUBL(7) ^= SUBL(1); SUBR(7) ^= SUBR(1);
+	SUBL(1) ^= SUBR(1) &amp; ~SUBR(9);
+	dw = SUBL(1) &amp; SUBL(9),
+		SUBR(1) ^= CAMELLIA_RL1(dw); /* modified for FLinv(kl2) */
+	/* round 8 */
+	SUBL(11) ^= SUBL(1); SUBR(11) ^= SUBR(1);
+	/* round 10 */
+	SUBL(13) ^= SUBL(1); SUBR(13) ^= SUBR(1);
+	/* round 12 */
+	SUBL(15) ^= SUBL(1); SUBR(15) ^= SUBR(1);
+	SUBL(1) ^= SUBR(1) &amp; ~SUBR(17);
+	dw = SUBL(1) &amp; SUBL(17),
+		SUBR(1) ^= CAMELLIA_RL1(dw); /* modified for FLinv(kl4) */
+	/* round 14 */
+	SUBL(19) ^= SUBL(1); SUBR(19) ^= SUBR(1);
+	/* round 16 */
+	SUBL(21) ^= SUBL(1); SUBR(21) ^= SUBR(1);
+	/* round 18 */
+	SUBL(23) ^= SUBL(1); SUBR(23) ^= SUBR(1);
+	/* kw3 */
+	SUBL(24) ^= SUBL(1); SUBR(24) ^= SUBR(1);
+	
+	/* absorb kw4 to other subkeys */
+	kw4l = SUBL(25); kw4r = SUBR(25);
+	/* round 17 */
+	SUBL(22) ^= kw4l; SUBR(22) ^= kw4r;
+	/* round 15 */
+	SUBL(20) ^= kw4l; SUBR(20) ^= kw4r;
+	/* round 13 */
+	SUBL(18) ^= kw4l; SUBR(18) ^= kw4r;
+	kw4l ^= kw4r &amp; ~SUBR(16);
+	dw = kw4l &amp; SUBL(16),
+		kw4r ^= CAMELLIA_RL1(dw); /* modified for FL(kl3) */
+	/* round 11 */
+	SUBL(14) ^= kw4l; SUBR(14) ^= kw4r;
+	/* round 9 */
+	SUBL(12) ^= kw4l; SUBR(12) ^= kw4r;
+	/* round 7 */
+	SUBL(10) ^= kw4l; SUBR(10) ^= kw4r;
+	kw4l ^= kw4r &amp; ~SUBR(8);
+	dw = kw4l &amp; SUBL(8),
+		kw4r ^= CAMELLIA_RL1(dw); /* modified for FL(kl1) */
+	/* round 5 */
+	SUBL(6) ^= kw4l; SUBR(6) ^= kw4r;
+	/* round 3 */
+	SUBL(4) ^= kw4l; SUBR(4) ^= kw4r;
+	/* round 1 */
+	SUBL(2) ^= kw4l; SUBR(2) ^= kw4r;
+	/* kw1 */
+	SUBL(0) ^= kw4l; SUBR(0) ^= kw4r;
+	
+	
+	/* key XOR is end of F-function */
+	CAMELLIA_SUBKEY_L(0) = SUBL(0) ^ SUBL(2);/* kw1 */
+	CAMELLIA_SUBKEY_R(0) = SUBR(0) ^ SUBR(2);
+	CAMELLIA_SUBKEY_L(2) = SUBL(3);       /* round 1 */
+	CAMELLIA_SUBKEY_R(2) = SUBR(3);
+	CAMELLIA_SUBKEY_L(3) = SUBL(2) ^ SUBL(4); /* round 2 */
+	CAMELLIA_SUBKEY_R(3) = SUBR(2) ^ SUBR(4);
+	CAMELLIA_SUBKEY_L(4) = SUBL(3) ^ SUBL(5); /* round 3 */
+	CAMELLIA_SUBKEY_R(4) = SUBR(3) ^ SUBR(5);
+	CAMELLIA_SUBKEY_L(5) = SUBL(4) ^ SUBL(6); /* round 4 */
+	CAMELLIA_SUBKEY_R(5) = SUBR(4) ^ SUBR(6);
+	CAMELLIA_SUBKEY_L(6) = SUBL(5) ^ SUBL(7); /* round 5 */
+	CAMELLIA_SUBKEY_R(6) = SUBR(5) ^ SUBR(7);
+	tl = SUBL(10) ^ (SUBR(10) &amp; ~SUBR(8));
+	dw = tl &amp; SUBL(8),  /* FL(kl1) */
+		tr = SUBR(10) ^ CAMELLIA_RL1(dw);
+	CAMELLIA_SUBKEY_L(7) = SUBL(6) ^ tl; /* round 6 */
+	CAMELLIA_SUBKEY_R(7) = SUBR(6) ^ tr;
+	CAMELLIA_SUBKEY_L(8) = SUBL(8);       /* FL(kl1) */
+	CAMELLIA_SUBKEY_R(8) = SUBR(8);
+	CAMELLIA_SUBKEY_L(9) = SUBL(9);       /* FLinv(kl2) */
+	CAMELLIA_SUBKEY_R(9) = SUBR(9);
+	tl = SUBL(7) ^ (SUBR(7) &amp; ~SUBR(9));
+	dw = tl &amp; SUBL(9),  /* FLinv(kl2) */
+		tr = SUBR(7) ^ CAMELLIA_RL1(dw);
+	CAMELLIA_SUBKEY_L(10) = tl ^ SUBL(11); /* round 7 */
+	CAMELLIA_SUBKEY_R(10) = tr ^ SUBR(11);
+	CAMELLIA_SUBKEY_L(11) = SUBL(10) ^ SUBL(12); /* round 8 */
+	CAMELLIA_SUBKEY_R(11) = SUBR(10) ^ SUBR(12);
+	CAMELLIA_SUBKEY_L(12) = SUBL(11) ^ SUBL(13); /* round 9 */
+	CAMELLIA_SUBKEY_R(12) = SUBR(11) ^ SUBR(13);
+	CAMELLIA_SUBKEY_L(13) = SUBL(12) ^ SUBL(14); /* round 10 */
+	CAMELLIA_SUBKEY_R(13) = SUBR(12) ^ SUBR(14);
+	CAMELLIA_SUBKEY_L(14) = SUBL(13) ^ SUBL(15); /* round 11 */
+	CAMELLIA_SUBKEY_R(14) = SUBR(13) ^ SUBR(15);
+	tl = SUBL(18) ^ (SUBR(18) &amp; ~SUBR(16));
+	dw = tl &amp; SUBL(16), /* FL(kl3) */
+		tr = SUBR(18) ^ CAMELLIA_RL1(dw);
+	CAMELLIA_SUBKEY_L(15) = SUBL(14) ^ tl; /* round 12 */
+	CAMELLIA_SUBKEY_R(15) = SUBR(14) ^ tr;
+	CAMELLIA_SUBKEY_L(16) = SUBL(16);     /* FL(kl3) */
+	CAMELLIA_SUBKEY_R(16) = SUBR(16);
+	CAMELLIA_SUBKEY_L(17) = SUBL(17);     /* FLinv(kl4) */
+	CAMELLIA_SUBKEY_R(17) = SUBR(17);
+	tl = SUBL(15) ^ (SUBR(15) &amp; ~SUBR(17));
+	dw = tl &amp; SUBL(17), /* FLinv(kl4) */
+		tr = SUBR(15) ^ CAMELLIA_RL1(dw);
+	CAMELLIA_SUBKEY_L(18) = tl ^ SUBL(19); /* round 13 */
+	CAMELLIA_SUBKEY_R(18) = tr ^ SUBR(19);
+	CAMELLIA_SUBKEY_L(19) = SUBL(18) ^ SUBL(20); /* round 14 */
+	CAMELLIA_SUBKEY_R(19) = SUBR(18) ^ SUBR(20);
+	CAMELLIA_SUBKEY_L(20) = SUBL(19) ^ SUBL(21); /* round 15 */
+	CAMELLIA_SUBKEY_R(20) = SUBR(19) ^ SUBR(21);
+	CAMELLIA_SUBKEY_L(21) = SUBL(20) ^ SUBL(22); /* round 16 */
+	CAMELLIA_SUBKEY_R(21) = SUBR(20) ^ SUBR(22);
+	CAMELLIA_SUBKEY_L(22) = SUBL(21) ^ SUBL(23); /* round 17 */
+	CAMELLIA_SUBKEY_R(22) = SUBR(21) ^ SUBR(23);
+	CAMELLIA_SUBKEY_L(23) = SUBL(22);     /* round 18 */
+	CAMELLIA_SUBKEY_R(23) = SUBR(22);
+	CAMELLIA_SUBKEY_L(24) = SUBL(24) ^ SUBL(23); /* kw3 */
+	CAMELLIA_SUBKEY_R(24) = SUBR(24) ^ SUBR(23);
+	
+	/* apply the inverse of the last half of P-function */
+	dw = CAMELLIA_SUBKEY_L(2) ^ CAMELLIA_SUBKEY_R(2),
+		dw = CAMELLIA_RL8(dw);/* round 1 */
+	CAMELLIA_SUBKEY_R(2) = CAMELLIA_SUBKEY_L(2) ^ dw,
+		CAMELLIA_SUBKEY_L(2) = dw;
+	dw = CAMELLIA_SUBKEY_L(3) ^ CAMELLIA_SUBKEY_R(3),
+		dw = CAMELLIA_RL8(dw);/* round 2 */
+	CAMELLIA_SUBKEY_R(3) = CAMELLIA_SUBKEY_L(3) ^ dw,
+		CAMELLIA_SUBKEY_L(3) = dw;
+	dw = CAMELLIA_SUBKEY_L(4) ^ CAMELLIA_SUBKEY_R(4),
+		dw = CAMELLIA_RL8(dw);/* round 3 */
+	CAMELLIA_SUBKEY_R(4) = CAMELLIA_SUBKEY_L(4) ^ dw,
+		CAMELLIA_SUBKEY_L(4) = dw;
+	dw = CAMELLIA_SUBKEY_L(5) ^ CAMELLIA_SUBKEY_R(5),
+		dw = CAMELLIA_RL8(dw);/* round 4 */
+	CAMELLIA_SUBKEY_R(5) = CAMELLIA_SUBKEY_L(5) ^ dw,
+		CAMELLIA_SUBKEY_L(5) = dw;
+	dw = CAMELLIA_SUBKEY_L(6) ^ CAMELLIA_SUBKEY_R(6),
+		dw = CAMELLIA_RL8(dw);/* round 5 */
+	CAMELLIA_SUBKEY_R(6) = CAMELLIA_SUBKEY_L(6) ^ dw,
+		CAMELLIA_SUBKEY_L(6) = dw;
+	dw = CAMELLIA_SUBKEY_L(7) ^ CAMELLIA_SUBKEY_R(7),
+		dw = CAMELLIA_RL8(dw);/* round 6 */
+	CAMELLIA_SUBKEY_R(7) = CAMELLIA_SUBKEY_L(7) ^ dw,
+		CAMELLIA_SUBKEY_L(7) = dw;
+	dw = CAMELLIA_SUBKEY_L(10) ^ CAMELLIA_SUBKEY_R(10),
+		dw = CAMELLIA_RL8(dw);/* round 7 */
+	CAMELLIA_SUBKEY_R(10) = CAMELLIA_SUBKEY_L(10) ^ dw,
+		CAMELLIA_SUBKEY_L(10) = dw;
+	dw = CAMELLIA_SUBKEY_L(11) ^ CAMELLIA_SUBKEY_R(11),
+		dw = CAMELLIA_RL8(dw);/* round 8 */
+	CAMELLIA_SUBKEY_R(11) = CAMELLIA_SUBKEY_L(11) ^ dw,
+		CAMELLIA_SUBKEY_L(11) = dw;
+	dw = CAMELLIA_SUBKEY_L(12) ^ CAMELLIA_SUBKEY_R(12),
+		dw = CAMELLIA_RL8(dw);/* round 9 */
+	CAMELLIA_SUBKEY_R(12) = CAMELLIA_SUBKEY_L(12) ^ dw,
+		CAMELLIA_SUBKEY_L(12) = dw;
+	dw = CAMELLIA_SUBKEY_L(13) ^ CAMELLIA_SUBKEY_R(13),
+		dw = CAMELLIA_RL8(dw);/* round 10 */
+	CAMELLIA_SUBKEY_R(13) = CAMELLIA_SUBKEY_L(13) ^ dw,
+		CAMELLIA_SUBKEY_L(13) = dw;
+	dw = CAMELLIA_SUBKEY_L(14) ^ CAMELLIA_SUBKEY_R(14),
+		dw = CAMELLIA_RL8(dw);/* round 11 */
+	CAMELLIA_SUBKEY_R(14) = CAMELLIA_SUBKEY_L(14) ^ dw,
+		CAMELLIA_SUBKEY_L(14) = dw;
+	dw = CAMELLIA_SUBKEY_L(15) ^ CAMELLIA_SUBKEY_R(15),
+		dw = CAMELLIA_RL8(dw);/* round 12 */
+	CAMELLIA_SUBKEY_R(15) = CAMELLIA_SUBKEY_L(15) ^ dw,
+		CAMELLIA_SUBKEY_L(15) = dw;
+	dw = CAMELLIA_SUBKEY_L(18) ^ CAMELLIA_SUBKEY_R(18),
+		dw = CAMELLIA_RL8(dw);/* round 13 */
+	CAMELLIA_SUBKEY_R(18) = CAMELLIA_SUBKEY_L(18) ^ dw,
+		CAMELLIA_SUBKEY_L(18) = dw;
+	dw = CAMELLIA_SUBKEY_L(19) ^ CAMELLIA_SUBKEY_R(19),
+		dw = CAMELLIA_RL8(dw);/* round 14 */
+	CAMELLIA_SUBKEY_R(19) = CAMELLIA_SUBKEY_L(19) ^ dw,
+		CAMELLIA_SUBKEY_L(19) = dw;
+	dw = CAMELLIA_SUBKEY_L(20) ^ CAMELLIA_SUBKEY_R(20),
+		dw = CAMELLIA_RL8(dw);/* round 15 */
+	CAMELLIA_SUBKEY_R(20) = CAMELLIA_SUBKEY_L(20) ^ dw,
+		CAMELLIA_SUBKEY_L(20) = dw;
+	dw = CAMELLIA_SUBKEY_L(21) ^ CAMELLIA_SUBKEY_R(21),
+		dw = CAMELLIA_RL8(dw);/* round 16 */
+	CAMELLIA_SUBKEY_R(21) = CAMELLIA_SUBKEY_L(21) ^ dw,
+		CAMELLIA_SUBKEY_L(21) = dw;
+	dw = CAMELLIA_SUBKEY_L(22) ^ CAMELLIA_SUBKEY_R(22),
+		dw = CAMELLIA_RL8(dw);/* round 17 */
+	CAMELLIA_SUBKEY_R(22) = CAMELLIA_SUBKEY_L(22) ^ dw,
+		CAMELLIA_SUBKEY_L(22) = dw;
+	dw = CAMELLIA_SUBKEY_L(23) ^ CAMELLIA_SUBKEY_R(23),
+		dw = CAMELLIA_RL8(dw);/* round 18 */
+	CAMELLIA_SUBKEY_R(23) = CAMELLIA_SUBKEY_L(23) ^ dw,
+		CAMELLIA_SUBKEY_L(23) = dw;
+	
+	return;
+}
+
+
+void camellia_setup256(const unsigned char *key, u32 *subkey)
+{
+	u32 kll,klr,krl,krr;           /* left half of key */
+	u32 krll,krlr,krrl,krrr;       /* right half of key */
+	u32 il, ir, t0, t1, w0, w1;    /* temporary variables */
+	u32 kw4l, kw4r, dw, tl, tr;
+	u32 subL[34];
+	u32 subR[34];
+	
+	/**
+	 *  key = (kll || klr || krl || krr || krll || krlr || krrl || krrr)
+	 *  (|| is concatination)
+	 */
+	
+	kll  = GETU32(key     );
+	klr  = GETU32(key +  4);
+	krl  = GETU32(key +  8);
+	krr  = GETU32(key + 12);
+	krll = GETU32(key + 16);
+	krlr = GETU32(key + 20);
+	krrl = GETU32(key + 24);
+	krrr = GETU32(key + 28);
+	
+	/* generate KL dependent subkeys */
+	/* kw1 */
+	SUBL(0) = kll; SUBR(0) = klr;
+	/* kw2 */
+	SUBL(1) = krl; SUBR(1) = krr;
+	CAMELLIA_ROLDQo32(kll, klr, krl, krr, w0, w1, 45);
+	/* k9 */
+	SUBL(12) = kll; SUBR(12) = klr;
+	/* k10 */
+	SUBL(13) = krl; SUBR(13) = krr;
+	CAMELLIA_ROLDQ(kll, klr, krl, krr, w0, w1, 15);
+	/* kl3 */
+	SUBL(16) = kll; SUBR(16) = klr;
+	/* kl4 */
+	SUBL(17) = krl; SUBR(17) = krr;
+	CAMELLIA_ROLDQ(kll, klr, krl, krr, w0, w1, 17);
+	/* k17 */
+	SUBL(22) = kll; SUBR(22) = klr;
+	/* k18 */
+	SUBL(23) = krl; SUBR(23) = krr;
+	CAMELLIA_ROLDQo32(kll, klr, krl, krr, w0, w1, 34);
+	/* k23 */
+	SUBL(30) = kll; SUBR(30) = klr;
+	/* k24 */
+	SUBL(31) = krl; SUBR(31) = krr;
+	
+	/* generate KR dependent subkeys */
+	CAMELLIA_ROLDQ(krll, krlr, krrl, krrr, w0, w1, 15);
+	/* k3 */
+	SUBL(4) = krll; SUBR(4) = krlr;
+	/* k4 */
+	SUBL(5) = krrl; SUBR(5) = krrr;
+	CAMELLIA_ROLDQ(krll, krlr, krrl, krrr, w0, w1, 15);
+	/* kl1 */
+	SUBL(8) = krll; SUBR(8) = krlr;
+	/* kl2 */
+	SUBL(9) = krrl; SUBR(9) = krrr;
+	CAMELLIA_ROLDQ(krll, krlr, krrl, krrr, w0, w1, 30);
+	/* k13 */
+	SUBL(18) = krll; SUBR(18) = krlr;
+	/* k14 */
+	SUBL(19) = krrl; SUBR(19) = krrr;
+	CAMELLIA_ROLDQo32(krll, krlr, krrl, krrr, w0, w1, 34);
+	/* k19 */
+	SUBL(26) = krll; SUBR(26) = krlr;
+	/* k20 */
+	SUBL(27) = krrl; SUBR(27) = krrr;
+	CAMELLIA_ROLDQo32(krll, krlr, krrl, krrr, w0, w1, 34);
+	
+	/* generate KA */
+	kll = SUBL(0) ^ krll; klr = SUBR(0) ^ krlr;
+	krl = SUBL(1) ^ krrl; krr = SUBR(1) ^ krrr;
+	CAMELLIA_F(kll, klr,
+		   CAMELLIA_SIGMA1L, CAMELLIA_SIGMA1R,
+		   w0, w1, il, ir, t0, t1);
+	krl ^= w0; krr ^= w1;
+	CAMELLIA_F(krl, krr,
+		   CAMELLIA_SIGMA2L, CAMELLIA_SIGMA2R,
+		   kll, klr, il, ir, t0, t1);
+	kll ^= krll; klr ^= krlr;
+	CAMELLIA_F(kll, klr,
+		   CAMELLIA_SIGMA3L, CAMELLIA_SIGMA3R,
+		   krl, krr, il, ir, t0, t1);
+	krl ^= w0 ^ krrl; krr ^= w1 ^ krrr;
+	CAMELLIA_F(krl, krr,
+		   CAMELLIA_SIGMA4L, CAMELLIA_SIGMA4R,
+		   w0, w1, il, ir, t0, t1);
+	kll ^= w0; klr ^= w1;
+	
+	/* generate KB */
+	krll ^= kll; krlr ^= klr;
+	krrl ^= krl; krrr ^= krr;
+	CAMELLIA_F(krll, krlr,
+		   CAMELLIA_SIGMA5L, CAMELLIA_SIGMA5R,
+		   w0, w1, il, ir, t0, t1);
+	krrl ^= w0; krrr ^= w1;
+	CAMELLIA_F(krrl, krrr,
+		   CAMELLIA_SIGMA6L, CAMELLIA_SIGMA6R,
+		   w0, w1, il, ir, t0, t1);
+	krll ^= w0; krlr ^= w1;
+	
+	/* generate KA dependent subkeys */
+	CAMELLIA_ROLDQ(kll, klr, krl, krr, w0, w1, 15);
+	/* k5 */
+	SUBL(6) = kll; SUBR(6) = klr;
+	/* k6 */
+	SUBL(7) = krl; SUBR(7) = krr;
+	CAMELLIA_ROLDQ(kll, klr, krl, krr, w0, w1, 30);
+	/* k11 */
+	SUBL(14) = kll; SUBR(14) = klr;
+	/* k12 */
+	SUBL(15) = krl; SUBR(15) = krr;
+	/* rotation left shift 32bit */
+	/* kl5 */
+	SUBL(24) = klr; SUBR(24) = krl;
+	/* kl6 */
+	SUBL(25) = krr; SUBR(25) = kll;
+	/* rotation left shift 49 from k11,k12 -&gt; k21,k22 */
+	CAMELLIA_ROLDQo32(kll, klr, krl, krr, w0, w1, 49);
+	/* k21 */
+	SUBL(28) = kll; SUBR(28) = klr;
+	/* k22 */
+	SUBL(29) = krl; SUBR(29) = krr;
+	
+	/* generate KB dependent subkeys */
+	/* k1 */
+	SUBL(2) = krll; SUBR(2) = krlr;
+	/* k2 */
+	SUBL(3) = krrl; SUBR(3) = krrr;
+	CAMELLIA_ROLDQ(krll, krlr, krrl, krrr, w0, w1, 30);
+	/* k7 */
+	SUBL(10) = krll; SUBR(10) = krlr;
+	/* k8 */
+	SUBL(11) = krrl; SUBR(11) = krrr;
+	CAMELLIA_ROLDQ(krll, krlr, krrl, krrr, w0, w1, 30);
+	/* k15 */
+	SUBL(20) = krll; SUBR(20) = krlr;
+	/* k16 */
+	SUBL(21) = krrl; SUBR(21) = krrr;
+	CAMELLIA_ROLDQo32(krll, krlr, krrl, krrr, w0, w1, 51);
+	/* kw3 */
+	SUBL(32) = krll; SUBR(32) = krlr;
+	/* kw4 */
+	SUBL(33) = krrl; SUBR(33) = krrr;
+	
+	/* absorb kw2 to other subkeys */
+	/* round 2 */
+	SUBL(3) ^= SUBL(1); SUBR(3) ^= SUBR(1);
+	/* round 4 */
+	SUBL(5) ^= SUBL(1); SUBR(5) ^= SUBR(1);
+	/* round 6 */
+	SUBL(7) ^= SUBL(1); SUBR(7) ^= SUBR(1);
+	SUBL(1) ^= SUBR(1) &amp; ~SUBR(9);
+	dw = SUBL(1) &amp; SUBL(9),
+		SUBR(1) ^= CAMELLIA_RL1(dw); /* modified for FLinv(kl2) */
+	/* round 8 */
+	SUBL(11) ^= SUBL(1); SUBR(11) ^= SUBR(1);
+	/* round 10 */
+	SUBL(13) ^= SUBL(1); SUBR(13) ^= SUBR(1);
+	/* round 12 */
+	SUBL(15) ^= SUBL(1); SUBR(15) ^= SUBR(1);
+	SUBL(1) ^= SUBR(1) &amp; ~SUBR(17);
+	dw = SUBL(1) &amp; SUBL(17),
+		SUBR(1) ^= CAMELLIA_RL1(dw); /* modified for FLinv(kl4) */
+	/* round 14 */
+	SUBL(19) ^= SUBL(1); SUBR(19) ^= SUBR(1);
+	/* round 16 */
+	SUBL(21) ^= SUBL(1); SUBR(21) ^= SUBR(1);
+	/* round 18 */
+	SUBL(23) ^= SUBL(1); SUBR(23) ^= SUBR(1);
+	SUBL(1) ^= SUBR(1) &amp; ~SUBR(25);
+	dw = SUBL(1) &amp; SUBL(25),
+		SUBR(1) ^= CAMELLIA_RL1(dw); /* modified for FLinv(kl6) */
+	/* round 20 */
+	SUBL(27) ^= SUBL(1); SUBR(27) ^= SUBR(1);
+	/* round 22 */
+	SUBL(29) ^= SUBL(1); SUBR(29) ^= SUBR(1);
+	/* round 24 */
+	SUBL(31) ^= SUBL(1); SUBR(31) ^= SUBR(1);
+	/* kw3 */
+	SUBL(32) ^= SUBL(1); SUBR(32) ^= SUBR(1);
+
+
+	/* absorb kw4 to other subkeys */
+	kw4l = SUBL(33); kw4r = SUBR(33);
+	/* round 23 */
+	SUBL(30) ^= kw4l; SUBR(30) ^= kw4r;
+	/* round 21 */
+	SUBL(28) ^= kw4l; SUBR(28) ^= kw4r;
+	/* round 19 */
+	SUBL(26) ^= kw4l; SUBR(26) ^= kw4r;
+	kw4l ^= kw4r &amp; ~SUBR(24);
+	dw = kw4l &amp; SUBL(24),
+		kw4r ^= CAMELLIA_RL1(dw); /* modified for FL(kl5) */
+	/* round 17 */
+	SUBL(22) ^= kw4l; SUBR(22) ^= kw4r;
+	/* round 15 */
+	SUBL(20) ^= kw4l; SUBR(20) ^= kw4r;
+	/* round 13 */
+	SUBL(18) ^= kw4l; SUBR(18) ^= kw4r;
+	kw4l ^= kw4r &amp; ~SUBR(16);
+	dw = kw4l &amp; SUBL(16),
+		kw4r ^= CAMELLIA_RL1(dw); /* modified for FL(kl3) */
+	/* round 11 */
+	SUBL(14) ^= kw4l; SUBR(14) ^= kw4r;
+	/* round 9 */
+	SUBL(12) ^= kw4l; SUBR(12) ^= kw4r;
+	/* round 7 */
+	SUBL(10) ^= kw4l; SUBR(10) ^= kw4r;
+	kw4l ^= kw4r &amp; ~SUBR(8);
+	dw = kw4l &amp; SUBL(8),
+		kw4r ^= CAMELLIA_RL1(dw); /* modified for FL(kl1) */
+	/* round 5 */
+	SUBL(6) ^= kw4l; SUBR(6) ^= kw4r;
+	/* round 3 */
+	SUBL(4) ^= kw4l; SUBR(4) ^= kw4r;
+	/* round 1 */
+	SUBL(2) ^= kw4l; SUBR(2) ^= kw4r;
+	/* kw1 */
+	SUBL(0) ^= kw4l; SUBR(0) ^= kw4r;
+
+	/* key XOR is end of F-function */
+	CAMELLIA_SUBKEY_L(0) = SUBL(0) ^ SUBL(2);/* kw1 */
+	CAMELLIA_SUBKEY_R(0) = SUBR(0) ^ SUBR(2);
+	CAMELLIA_SUBKEY_L(2) = SUBL(3);       /* round 1 */
+	CAMELLIA_SUBKEY_R(2) = SUBR(3);
+	CAMELLIA_SUBKEY_L(3) = SUBL(2) ^ SUBL(4); /* round 2 */
+	CAMELLIA_SUBKEY_R(3) = SUBR(2) ^ SUBR(4);
+	CAMELLIA_SUBKEY_L(4) = SUBL(3) ^ SUBL(5); /* round 3 */
+	CAMELLIA_SUBKEY_R(4) = SUBR(3) ^ SUBR(5);
+	CAMELLIA_SUBKEY_L(5) = SUBL(4) ^ SUBL(6); /* round 4 */
+	CAMELLIA_SUBKEY_R(5) = SUBR(4) ^ SUBR(6);
+	CAMELLIA_SUBKEY_L(6) = SUBL(5) ^ SUBL(7); /* round 5 */
+	CAMELLIA_SUBKEY_R(6) = SUBR(5) ^ SUBR(7);
+	tl = SUBL(10) ^ (SUBR(10) &amp; ~SUBR(8));
+	dw = tl &amp; SUBL(8),  /* FL(kl1) */
+		tr = SUBR(10) ^ CAMELLIA_RL1(dw);
+	CAMELLIA_SUBKEY_L(7) = SUBL(6) ^ tl; /* round 6 */
+	CAMELLIA_SUBKEY_R(7) = SUBR(6) ^ tr;
+	CAMELLIA_SUBKEY_L(8) = SUBL(8);       /* FL(kl1) */
+	CAMELLIA_SUBKEY_R(8) = SUBR(8);
+	CAMELLIA_SUBKEY_L(9) = SUBL(9);       /* FLinv(kl2) */
+	CAMELLIA_SUBKEY_R(9) = SUBR(9);
+	tl = SUBL(7) ^ (SUBR(7) &amp; ~SUBR(9));
+	dw = tl &amp; SUBL(9),  /* FLinv(kl2) */
+		tr = SUBR(7) ^ CAMELLIA_RL1(dw);
+	CAMELLIA_SUBKEY_L(10) = tl ^ SUBL(11); /* round 7 */
+	CAMELLIA_SUBKEY_R(10) = tr ^ SUBR(11);
+	CAMELLIA_SUBKEY_L(11) = SUBL(10) ^ SUBL(12); /* round 8 */
+	CAMELLIA_SUBKEY_R(11) = SUBR(10) ^ SUBR(12);
+	CAMELLIA_SUBKEY_L(12) = SUBL(11) ^ SUBL(13); /* round 9 */
+	CAMELLIA_SUBKEY_R(12) = SUBR(11) ^ SUBR(13);
+	CAMELLIA_SUBKEY_L(13) = SUBL(12) ^ SUBL(14); /* round 10 */
+	CAMELLIA_SUBKEY_R(13) = SUBR(12) ^ SUBR(14);
+	CAMELLIA_SUBKEY_L(14) = SUBL(13) ^ SUBL(15); /* round 11 */
+	CAMELLIA_SUBKEY_R(14) = SUBR(13) ^ SUBR(15);
+	tl = SUBL(18) ^ (SUBR(18) &amp; ~SUBR(16));
+	dw = tl &amp; SUBL(16), /* FL(kl3) */
+		tr = SUBR(18) ^ CAMELLIA_RL1(dw);
+	CAMELLIA_SUBKEY_L(15) = SUBL(14) ^ tl; /* round 12 */
+	CAMELLIA_SUBKEY_R(15) = SUBR(14) ^ tr;
+	CAMELLIA_SUBKEY_L(16) = SUBL(16);     /* FL(kl3) */
+	CAMELLIA_SUBKEY_R(16) = SUBR(16);
+	CAMELLIA_SUBKEY_L(17) = SUBL(17);     /* FLinv(kl4) */
+	CAMELLIA_SUBKEY_R(17) = SUBR(17);
+	tl = SUBL(15) ^ (SUBR(15) &amp; ~SUBR(17));
+	dw = tl &amp; SUBL(17), /* FLinv(kl4) */
+		tr = SUBR(15) ^ CAMELLIA_RL1(dw);
+	CAMELLIA_SUBKEY_L(18) = tl ^ SUBL(19); /* round 13 */
+	CAMELLIA_SUBKEY_R(18) = tr ^ SUBR(19);
+	CAMELLIA_SUBKEY_L(19) = SUBL(18) ^ SUBL(20); /* round 14 */
+	CAMELLIA_SUBKEY_R(19) = SUBR(18) ^ SUBR(20);
+	CAMELLIA_SUBKEY_L(20) = SUBL(19) ^ SUBL(21); /* round 15 */
+	CAMELLIA_SUBKEY_R(20) = SUBR(19) ^ SUBR(21);
+	CAMELLIA_SUBKEY_L(21) = SUBL(20) ^ SUBL(22); /* round 16 */
+	CAMELLIA_SUBKEY_R(21) = SUBR(20) ^ SUBR(22);
+	CAMELLIA_SUBKEY_L(22) = SUBL(21) ^ SUBL(23); /* round 17 */
+	CAMELLIA_SUBKEY_R(22) = SUBR(21) ^ SUBR(23);
+	tl = SUBL(26) ^ (SUBR(26)
+			 &amp; ~SUBR(24));
+	dw = tl &amp; SUBL(24), /* FL(kl5) */
+		tr = SUBR(26) ^ CAMELLIA_RL1(dw);
+	CAMELLIA_SUBKEY_L(23) = SUBL(22) ^ tl; /* round 18 */
+	CAMELLIA_SUBKEY_R(23) = SUBR(22) ^ tr;
+	CAMELLIA_SUBKEY_L(24) = SUBL(24);     /* FL(kl5) */
+	CAMELLIA_SUBKEY_R(24) = SUBR(24);
+	CAMELLIA_SUBKEY_L(25) = SUBL(25);     /* FLinv(kl6) */
+	CAMELLIA_SUBKEY_R(25) = SUBR(25);
+	tl = SUBL(23) ^ (SUBR(23) &amp;
+			 ~SUBR(25));
+	dw = tl &amp; SUBL(25), /* FLinv(kl6) */
+		tr = SUBR(23) ^ CAMELLIA_RL1(dw);
+	CAMELLIA_SUBKEY_L(26) = tl ^ SUBL(27); /* round 19 */
+	CAMELLIA_SUBKEY_R(26) = tr ^ SUBR(27);
+	CAMELLIA_SUBKEY_L(27) = SUBL(26) ^ SUBL(28); /* round 20 */
+	CAMELLIA_SUBKEY_R(27) = SUBR(26) ^ SUBR(28);
+	CAMELLIA_SUBKEY_L(28) = SUBL(27) ^ SUBL(29); /* round 21 */
+	CAMELLIA_SUBKEY_R(28) = SUBR(27) ^ SUBR(29);
+	CAMELLIA_SUBKEY_L(29) = SUBL(28) ^ SUBL(30); /* round 22 */
+	CAMELLIA_SUBKEY_R(29) = SUBR(28) ^ SUBR(30);
+	CAMELLIA_SUBKEY_L(30) = SUBL(29) ^ SUBL(31); /* round 23 */
+	CAMELLIA_SUBKEY_R(30) = SUBR(29) ^ SUBR(31);
+	CAMELLIA_SUBKEY_L(31) = SUBL(30);     /* round 24 */
+	CAMELLIA_SUBKEY_R(31) = SUBR(30);
+	CAMELLIA_SUBKEY_L(32) = SUBL(32) ^ SUBL(31); /* kw3 */
+	CAMELLIA_SUBKEY_R(32) = SUBR(32) ^ SUBR(31);
+	
+	/* apply the inverse of the last half of P-function */
+	dw = CAMELLIA_SUBKEY_L(2) ^ CAMELLIA_SUBKEY_R(2),
+		dw = CAMELLIA_RL8(dw);/* round 1 */
+	CAMELLIA_SUBKEY_R(2) = CAMELLIA_SUBKEY_L(2) ^ dw,
+		CAMELLIA_SUBKEY_L(2) = dw;
+	dw = CAMELLIA_SUBKEY_L(3) ^ CAMELLIA_SUBKEY_R(3),
+		dw = CAMELLIA_RL8(dw);/* round 2 */
+	CAMELLIA_SUBKEY_R(3) = CAMELLIA_SUBKEY_L(3) ^ dw,
+		CAMELLIA_SUBKEY_L(3) = dw;
+	dw = CAMELLIA_SUBKEY_L(4) ^ CAMELLIA_SUBKEY_R(4),
+		dw = CAMELLIA_RL8(dw);/* round 3 */
+	CAMELLIA_SUBKEY_R(4) = CAMELLIA_SUBKEY_L(4) ^ dw,
+		CAMELLIA_SUBKEY_L(4) = dw;
+	dw = CAMELLIA_SUBKEY_L(5) ^ CAMELLIA_SUBKEY_R(5),
+		dw = CAMELLIA_RL8(dw);/* round 4 */
+	CAMELLIA_SUBKEY_R(5) = CAMELLIA_SUBKEY_L(5) ^ dw,
+	CAMELLIA_SUBKEY_L(5) = dw;
+	dw = CAMELLIA_SUBKEY_L(6) ^ CAMELLIA_SUBKEY_R(6),
+		dw = CAMELLIA_RL8(dw);/* round 5 */
+	CAMELLIA_SUBKEY_R(6) = CAMELLIA_SUBKEY_L(6) ^ dw,
+		CAMELLIA_SUBKEY_L(6) = dw;
+	dw = CAMELLIA_SUBKEY_L(7) ^ CAMELLIA_SUBKEY_R(7),
+		dw = CAMELLIA_RL8(dw);/* round 6 */
+	CAMELLIA_SUBKEY_R(7) = CAMELLIA_SUBKEY_L(7) ^ dw,
+		CAMELLIA_SUBKEY_L(7) = dw;
+	dw = CAMELLIA_SUBKEY_L(10) ^ CAMELLIA_SUBKEY_R(10),
+		dw = CAMELLIA_RL8(dw);/* round 7 */
+	CAMELLIA_SUBKEY_R(10) = CAMELLIA_SUBKEY_L(10) ^ dw,
+		CAMELLIA_SUBKEY_L(10) = dw;
+	dw = CAMELLIA_SUBKEY_L(11) ^ CAMELLIA_SUBKEY_R(11),
+	    dw = CAMELLIA_RL8(dw);/* round 8 */
+	CAMELLIA_SUBKEY_R(11) = CAMELLIA_SUBKEY_L(11) ^ dw,
+		CAMELLIA_SUBKEY_L(11) = dw;
+	dw = CAMELLIA_SUBKEY_L(12) ^ CAMELLIA_SUBKEY_R(12),
+		dw = CAMELLIA_RL8(dw);/* round 9 */
+	CAMELLIA_SUBKEY_R(12) = CAMELLIA_SUBKEY_L(12) ^ dw,
+		CAMELLIA_SUBKEY_L(12) = dw;
+	dw = CAMELLIA_SUBKEY_L(13) ^ CAMELLIA_SUBKEY_R(13),
+		dw = CAMELLIA_RL8(dw);/* round 10 */
+	CAMELLIA_SUBKEY_R(13) = CAMELLIA_SUBKEY_L(13) ^ dw,
+		CAMELLIA_SUBKEY_L(13) = dw;
+	dw = CAMELLIA_SUBKEY_L(14) ^ CAMELLIA_SUBKEY_R(14),
+		dw = CAMELLIA_RL8(dw);/* round 11 */
+	CAMELLIA_SUBKEY_R(14) = CAMELLIA_SUBKEY_L(14) ^ dw,
+		CAMELLIA_SUBKEY_L(14) = dw;
+	dw = CAMELLIA_SUBKEY_L(15) ^ CAMELLIA_SUBKEY_R(15),
+		dw = CAMELLIA_RL8(dw);/* round 12 */
+	CAMELLIA_SUBKEY_R(15) = CAMELLIA_SUBKEY_L(15) ^ dw,
+		CAMELLIA_SUBKEY_L(15) = dw;
+	dw = CAMELLIA_SUBKEY_L(18) ^ CAMELLIA_SUBKEY_R(18),
+		dw = CAMELLIA_RL8(dw);/* round 13 */
+	CAMELLIA_SUBKEY_R(18) = CAMELLIA_SUBKEY_L(18) ^ dw,
+		CAMELLIA_SUBKEY_L(18) = dw;
+	dw = CAMELLIA_SUBKEY_L(19) ^ CAMELLIA_SUBKEY_R(19),
+		dw = CAMELLIA_RL8(dw);/* round 14 */
+	CAMELLIA_SUBKEY_R(19) = CAMELLIA_SUBKEY_L(19) ^ dw,
+		CAMELLIA_SUBKEY_L(19) = dw;
+	dw = CAMELLIA_SUBKEY_L(20) ^ CAMELLIA_SUBKEY_R(20),
+		dw = CAMELLIA_RL8(dw);/* round 15 */
+	CAMELLIA_SUBKEY_R(20) = CAMELLIA_SUBKEY_L(20) ^ dw,
+		CAMELLIA_SUBKEY_L(20) = dw;
+	dw = CAMELLIA_SUBKEY_L(21) ^ CAMELLIA_SUBKEY_R(21),
+		dw = CAMELLIA_RL8(dw);/* round 16 */
+	CAMELLIA_SUBKEY_R(21) = CAMELLIA_SUBKEY_L(21) ^ dw,
+		CAMELLIA_SUBKEY_L(21) = dw;
+	dw = CAMELLIA_SUBKEY_L(22) ^ CAMELLIA_SUBKEY_R(22),
+		dw = CAMELLIA_RL8(dw);/* round 17 */
+	CAMELLIA_SUBKEY_R(22) = CAMELLIA_SUBKEY_L(22) ^ dw,
+		CAMELLIA_SUBKEY_L(22) = dw;
+	dw = CAMELLIA_SUBKEY_L(23) ^ CAMELLIA_SUBKEY_R(23),
+		dw = CAMELLIA_RL8(dw);/* round 18 */
+	CAMELLIA_SUBKEY_R(23) = CAMELLIA_SUBKEY_L(23) ^ dw,
+		CAMELLIA_SUBKEY_L(23) = dw;
+	dw = CAMELLIA_SUBKEY_L(26) ^ CAMELLIA_SUBKEY_R(26),
+		dw = CAMELLIA_RL8(dw);/* round 19 */
+	CAMELLIA_SUBKEY_R(26) = CAMELLIA_SUBKEY_L(26) ^ dw,
+		CAMELLIA_SUBKEY_L(26) = dw;
+	dw = CAMELLIA_SUBKEY_L(27) ^ CAMELLIA_SUBKEY_R(27),
+		dw = CAMELLIA_RL8(dw);/* round 20 */
+	CAMELLIA_SUBKEY_R(27) = CAMELLIA_SUBKEY_L(27) ^ dw,
+		CAMELLIA_SUBKEY_L(27) = dw;
+	dw = CAMELLIA_SUBKEY_L(28) ^ CAMELLIA_SUBKEY_R(28),
+		dw = CAMELLIA_RL8(dw);/* round 21 */
+	CAMELLIA_SUBKEY_R(28) = CAMELLIA_SUBKEY_L(28) ^ dw,
+		CAMELLIA_SUBKEY_L(28) = dw;
+	dw = CAMELLIA_SUBKEY_L(29) ^ CAMELLIA_SUBKEY_R(29),
+		dw = CAMELLIA_RL8(dw);/* round 22 */
+	CAMELLIA_SUBKEY_R(29) = CAMELLIA_SUBKEY_L(29) ^ dw,
+		CAMELLIA_SUBKEY_L(29) = dw;
+	dw = CAMELLIA_SUBKEY_L(30) ^ CAMELLIA_SUBKEY_R(30),
+		dw = CAMELLIA_RL8(dw);/* round 23 */
+	CAMELLIA_SUBKEY_R(30) = CAMELLIA_SUBKEY_L(30) ^ dw,
+		CAMELLIA_SUBKEY_L(30) = dw;
+	dw = CAMELLIA_SUBKEY_L(31) ^ CAMELLIA_SUBKEY_R(31),
+		dw = CAMELLIA_RL8(dw);/* round 24 */
+	CAMELLIA_SUBKEY_R(31) = CAMELLIA_SUBKEY_L(31) ^ dw,
+		CAMELLIA_SUBKEY_L(31) = dw;
+	
+	return;
+}
+
+void camellia_setup192(const unsigned char *key, u32 *subkey)
+{
+	unsigned char kk[32];
+	u32 krll, krlr, krrl,krrr;
+	
+	memcpy(kk, key, 24);
+	memcpy((unsigned char *)&amp;krll, key+16,4);
+	memcpy((unsigned char *)&amp;krlr, key+20,4);
+	krrl = ~krll;
+	krrr = ~krlr;
+	memcpy(kk+24, (unsigned char *)&amp;krrl, 4);
+	memcpy(kk+28, (unsigned char *)&amp;krrr, 4);
+	camellia_setup256(kk, subkey);
+	return;
+}
+
+
+/**
+ * Stuff related to camellia encryption/decryption
+ */
+void camellia_encrypt128(const u32 *subkey, __be32 *io_text)
+{
+	u32 il,ir,t0,t1;               /* temporary valiables */
+
+	u32 io[4];
+
+	io[0] = be32_to_cpu(io_text[0]);
+	io[1] = be32_to_cpu(io_text[1]);
+	io[2] = be32_to_cpu(io_text[2]);
+	io[3] = be32_to_cpu(io_text[3]);
+	
+	/* pre whitening but absorb kw2*/
+	io[0] ^= CAMELLIA_SUBKEY_L(0);
+	io[1] ^= CAMELLIA_SUBKEY_R(0);
+	/* main iteration */
+	
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(2),CAMELLIA_SUBKEY_R(2),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(3),CAMELLIA_SUBKEY_R(3),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(4),CAMELLIA_SUBKEY_R(4),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(5),CAMELLIA_SUBKEY_R(5),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(6),CAMELLIA_SUBKEY_R(6),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(7),CAMELLIA_SUBKEY_R(7),
+			 io[0],io[1],il,ir,t0,t1);
+
+	CAMELLIA_FLS(io[0],io[1],io[2],io[3],
+		     CAMELLIA_SUBKEY_L(8),CAMELLIA_SUBKEY_R(8),
+		     CAMELLIA_SUBKEY_L(9),CAMELLIA_SUBKEY_R(9),
+		     t0,t1,il,ir);
+	
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(10),CAMELLIA_SUBKEY_R(10),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(11),CAMELLIA_SUBKEY_R(11),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(12),CAMELLIA_SUBKEY_R(12),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(13),CAMELLIA_SUBKEY_R(13),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(14),CAMELLIA_SUBKEY_R(14),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(15),CAMELLIA_SUBKEY_R(15),
+			 io[0],io[1],il,ir,t0,t1);
+
+	CAMELLIA_FLS(io[0],io[1],io[2],io[3],
+		     CAMELLIA_SUBKEY_L(16),CAMELLIA_SUBKEY_R(16),
+		     CAMELLIA_SUBKEY_L(17),CAMELLIA_SUBKEY_R(17),
+		     t0,t1,il,ir);
+	
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(18),CAMELLIA_SUBKEY_R(18),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(19),CAMELLIA_SUBKEY_R(19),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(20),CAMELLIA_SUBKEY_R(20),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(21),CAMELLIA_SUBKEY_R(21),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(22),CAMELLIA_SUBKEY_R(22),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(23),CAMELLIA_SUBKEY_R(23),
+			 io[0],io[1],il,ir,t0,t1);
+	
+	/* post whitening but kw4 */
+	io[2] ^= CAMELLIA_SUBKEY_L(24);
+	io[3] ^= CAMELLIA_SUBKEY_R(24);
+	
+	t0 = io[0];
+	t1 = io[1];
+	io[0] = io[2];
+	io[1] = io[3];
+	io[2] = t0;
+	io[3] = t1;
+
+	io_text[0] = cpu_to_be32(io[0]);
+	io_text[1] = cpu_to_be32(io[1]);
+	io_text[2] = cpu_to_be32(io[2]);
+	io_text[3] = cpu_to_be32(io[3]);
+	
+	return;
+}
+
+void camellia_decrypt128(const u32 *subkey, __be32 *io_text)
+{
+	u32 il,ir,t0,t1;               /* temporary valiables */
+
+	u32 io[4];
+
+	io[0] = be32_to_cpu(io_text[0]);
+	io[1] = be32_to_cpu(io_text[1]);
+	io[2] = be32_to_cpu(io_text[2]);
+	io[3] = be32_to_cpu(io_text[3]);
+	
+	/* pre whitening but absorb kw2*/
+	io[0] ^= CAMELLIA_SUBKEY_L(24);
+	io[1] ^= CAMELLIA_SUBKEY_R(24);
+	
+	/* main iteration */
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(23),CAMELLIA_SUBKEY_R(23),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(22),CAMELLIA_SUBKEY_R(22),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(21),CAMELLIA_SUBKEY_R(21),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(20),CAMELLIA_SUBKEY_R(20),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(19),CAMELLIA_SUBKEY_R(19),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(18),CAMELLIA_SUBKEY_R(18),
+			 io[0],io[1],il,ir,t0,t1);
+	
+	CAMELLIA_FLS(io[0],io[1],io[2],io[3],
+		     CAMELLIA_SUBKEY_L(17),CAMELLIA_SUBKEY_R(17),
+		     CAMELLIA_SUBKEY_L(16),CAMELLIA_SUBKEY_R(16),
+		     t0,t1,il,ir);
+	
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(15),CAMELLIA_SUBKEY_R(15),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(14),CAMELLIA_SUBKEY_R(14),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(13),CAMELLIA_SUBKEY_R(13),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(12),CAMELLIA_SUBKEY_R(12),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(11),CAMELLIA_SUBKEY_R(11),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(10),CAMELLIA_SUBKEY_R(10),
+			 io[0],io[1],il,ir,t0,t1);
+	
+	CAMELLIA_FLS(io[0],io[1],io[2],io[3],
+		     CAMELLIA_SUBKEY_L(9),CAMELLIA_SUBKEY_R(9),
+		     CAMELLIA_SUBKEY_L(8),CAMELLIA_SUBKEY_R(8),
+		     t0,t1,il,ir);
+	
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(7),CAMELLIA_SUBKEY_R(7),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(6),CAMELLIA_SUBKEY_R(6),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(5),CAMELLIA_SUBKEY_R(5),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(4),CAMELLIA_SUBKEY_R(4),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(3),CAMELLIA_SUBKEY_R(3),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(2),CAMELLIA_SUBKEY_R(2),
+			 io[0],io[1],il,ir,t0,t1);
+	
+	/* post whitening but kw4 */
+	io[2] ^= CAMELLIA_SUBKEY_L(0);
+	io[3] ^= CAMELLIA_SUBKEY_R(0);
+	
+	t0 = io[0];
+	t1 = io[1];
+	io[0] = io[2];
+	io[1] = io[3];
+	io[2] = t0;
+	io[3] = t1;
+
+	io_text[0] = cpu_to_be32(io[0]);
+	io_text[1] = cpu_to_be32(io[1]);
+	io_text[2] = cpu_to_be32(io[2]);
+	io_text[3] = cpu_to_be32(io[3]);
+	
+	return;
+}
+
+
+/**
+ * stuff for 192 and 256bit encryption/decryption
+ */
+void camellia_encrypt256(const u32 *subkey, __be32 *io_text)
+{
+	u32 il,ir,t0,t1;           /* temporary valiables */
+	
+	u32 io[4];
+
+	io[0] = be32_to_cpu(io_text[0]);
+	io[1] = be32_to_cpu(io_text[1]);
+	io[2] = be32_to_cpu(io_text[2]);
+	io[3] = be32_to_cpu(io_text[3]);
+	
+	/* pre whitening but absorb kw2*/
+	io[0] ^= CAMELLIA_SUBKEY_L(0);
+	io[1] ^= CAMELLIA_SUBKEY_R(0);
+	
+	/* main iteration */
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(2),CAMELLIA_SUBKEY_R(2),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(3),CAMELLIA_SUBKEY_R(3),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(4),CAMELLIA_SUBKEY_R(4),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(5),CAMELLIA_SUBKEY_R(5),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(6),CAMELLIA_SUBKEY_R(6),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(7),CAMELLIA_SUBKEY_R(7),
+			 io[0],io[1],il,ir,t0,t1);
+	
+	CAMELLIA_FLS(io[0],io[1],io[2],io[3],
+		     CAMELLIA_SUBKEY_L(8),CAMELLIA_SUBKEY_R(8),
+		     CAMELLIA_SUBKEY_L(9),CAMELLIA_SUBKEY_R(9),
+		     t0,t1,il,ir);
+	
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(10),CAMELLIA_SUBKEY_R(10),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(11),CAMELLIA_SUBKEY_R(11),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(12),CAMELLIA_SUBKEY_R(12),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(13),CAMELLIA_SUBKEY_R(13),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(14),CAMELLIA_SUBKEY_R(14),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(15),CAMELLIA_SUBKEY_R(15),
+			 io[0],io[1],il,ir,t0,t1);
+	
+	CAMELLIA_FLS(io[0],io[1],io[2],io[3],
+		     CAMELLIA_SUBKEY_L(16),CAMELLIA_SUBKEY_R(16),
+		     CAMELLIA_SUBKEY_L(17),CAMELLIA_SUBKEY_R(17),
+		     t0,t1,il,ir);
+	
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(18),CAMELLIA_SUBKEY_R(18),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(19),CAMELLIA_SUBKEY_R(19),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(20),CAMELLIA_SUBKEY_R(20),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(21),CAMELLIA_SUBKEY_R(21),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(22),CAMELLIA_SUBKEY_R(22),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(23),CAMELLIA_SUBKEY_R(23),
+			 io[0],io[1],il,ir,t0,t1);
+	
+	CAMELLIA_FLS(io[0],io[1],io[2],io[3],
+		     CAMELLIA_SUBKEY_L(24),CAMELLIA_SUBKEY_R(24),
+		     CAMELLIA_SUBKEY_L(25),CAMELLIA_SUBKEY_R(25),
+		     t0,t1,il,ir);
+	
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(26),CAMELLIA_SUBKEY_R(26),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(27),CAMELLIA_SUBKEY_R(27),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(28),CAMELLIA_SUBKEY_R(28),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(29),CAMELLIA_SUBKEY_R(29),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(30),CAMELLIA_SUBKEY_R(30),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(31),CAMELLIA_SUBKEY_R(31),
+			 io[0],io[1],il,ir,t0,t1);
+	
+	/* post whitening but kw4 */
+	io[2] ^= CAMELLIA_SUBKEY_L(32);
+	io[3] ^= CAMELLIA_SUBKEY_R(32);
+	
+	t0 = io[0];
+	t1 = io[1];
+	io[0] = io[2];
+	io[1] = io[3];
+	io[2] = t0;
+	io[3] = t1;
+	
+	io_text[0] = cpu_to_be32(io[0]);
+	io_text[1] = cpu_to_be32(io[1]);
+	io_text[2] = cpu_to_be32(io[2]);
+	io_text[3] = cpu_to_be32(io[3]);
+	
+	return;
+}
+
+
+void camellia_decrypt256(const u32 *subkey, __be32 *io_text)
+{
+	u32 il,ir,t0,t1;           /* temporary valiables */
+	
+	u32 io[4];
+
+	io[0] = be32_to_cpu(io_text[0]);
+	io[1] = be32_to_cpu(io_text[1]);
+	io[2] = be32_to_cpu(io_text[2]);
+	io[3] = be32_to_cpu(io_text[3]);
+
+	/* pre whitening but absorb kw2*/
+	io[0] ^= CAMELLIA_SUBKEY_L(32);
+	io[1] ^= CAMELLIA_SUBKEY_R(32);
+	
+	/* main iteration */
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(31),CAMELLIA_SUBKEY_R(31),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(30),CAMELLIA_SUBKEY_R(30),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(29),CAMELLIA_SUBKEY_R(29),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(28),CAMELLIA_SUBKEY_R(28),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(27),CAMELLIA_SUBKEY_R(27),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(26),CAMELLIA_SUBKEY_R(26),
+			 io[0],io[1],il,ir,t0,t1);
+	
+	CAMELLIA_FLS(io[0],io[1],io[2],io[3],
+		     CAMELLIA_SUBKEY_L(25),CAMELLIA_SUBKEY_R(25),
+		     CAMELLIA_SUBKEY_L(24),CAMELLIA_SUBKEY_R(24),
+		     t0,t1,il,ir);
+	
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(23),CAMELLIA_SUBKEY_R(23),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(22),CAMELLIA_SUBKEY_R(22),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(21),CAMELLIA_SUBKEY_R(21),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(20),CAMELLIA_SUBKEY_R(20),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(19),CAMELLIA_SUBKEY_R(19),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(18),CAMELLIA_SUBKEY_R(18),
+			 io[0],io[1],il,ir,t0,t1);
+	
+	CAMELLIA_FLS(io[0],io[1],io[2],io[3],
+		     CAMELLIA_SUBKEY_L(17),CAMELLIA_SUBKEY_R(17),
+		     CAMELLIA_SUBKEY_L(16),CAMELLIA_SUBKEY_R(16),
+		     t0,t1,il,ir);
+	
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(15),CAMELLIA_SUBKEY_R(15),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(14),CAMELLIA_SUBKEY_R(14),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(13),CAMELLIA_SUBKEY_R(13),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(12),CAMELLIA_SUBKEY_R(12),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(11),CAMELLIA_SUBKEY_R(11),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(10),CAMELLIA_SUBKEY_R(10),
+			 io[0],io[1],il,ir,t0,t1);
+	
+	CAMELLIA_FLS(io[0],io[1],io[2],io[3],
+		     CAMELLIA_SUBKEY_L(9),CAMELLIA_SUBKEY_R(9),
+		     CAMELLIA_SUBKEY_L(8),CAMELLIA_SUBKEY_R(8),
+		     t0,t1,il,ir);
+	
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(7),CAMELLIA_SUBKEY_R(7),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(6),CAMELLIA_SUBKEY_R(6),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(5),CAMELLIA_SUBKEY_R(5),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(4),CAMELLIA_SUBKEY_R(4),
+			 io[0],io[1],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[0],io[1],
+			 CAMELLIA_SUBKEY_L(3),CAMELLIA_SUBKEY_R(3),
+			 io[2],io[3],il,ir,t0,t1);
+	CAMELLIA_ROUNDSM(io[2],io[3],
+			 CAMELLIA_SUBKEY_L(2),CAMELLIA_SUBKEY_R(2),
+			 io[0],io[1],il,ir,t0,t1);
+	
+	/* post whitening but kw4 */
+	io[2] ^= CAMELLIA_SUBKEY_L(0);
+	io[3] ^= CAMELLIA_SUBKEY_R(0);
+	
+	t0 = io[0];
+	t1 = io[1];
+	io[0] = io[2];
+	io[1] = io[3];
+	io[2] = t0;
+	io[3] = t1;
+
+	io_text[0] = cpu_to_be32(io[0]);
+	io_text[1] = cpu_to_be32(io[1]);
+	io_text[2] = cpu_to_be32(io[2]);
+	io_text[3] = cpu_to_be32(io[3]);
+
+	return;
+}
+
+
+static int
+camellia_set_key(struct crypto_tfm *tfm, const u8 *in_key,
+		 unsigned int key_len, u32 *flags)
+{
+	struct camellia_ctx *cctx = crypto_tfm_ctx(tfm);
+	const unsigned char *key = (const unsigned char *)in_key;
+
+	if (key_len != 16 &amp;&amp; key_len != 24 &amp;&amp; key_len != 32) {
+		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
+		return -EINVAL;
+	}
+
+	cctx-&gt;key_length = key_len;
+
+	switch(key_len) {
+	case 16:
+		camellia_setup128(key, cctx-&gt;key_table);
+		break;
+	case 24:
+		camellia_setup192(key, cctx-&gt;key_table);
+		break;
+	case 32:
+		camellia_setup256(key, cctx-&gt;key_table);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+
+static void camellia_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
+{
+	const struct camellia_ctx *cctx = crypto_tfm_ctx(tfm);
+	const __be32 *src = (const __be32 *)in;
+	__be32 *dst = (__be32 *)out;
+		
+	__be32 tmp[4];
+
+	memcpy(tmp, src, CAMELLIA_BLOCK_SIZE);
+	
+	switch (cctx-&gt;key_length) {
+	case 16:
+		camellia_encrypt128(cctx-&gt;key_table, tmp);
+		break;
+	case 24:
+		/* fall through */
+	case 32:
+		camellia_encrypt256(cctx-&gt;key_table, tmp);
+		break;
+	default:
+		break;
+	}
+	
+	memcpy(dst, tmp, CAMELLIA_BLOCK_SIZE);
+}
+
+
+static void camellia_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
+{
+	const struct camellia_ctx *cctx = crypto_tfm_ctx(tfm);
+	const __be32 *src = (const __be32 *)in;
+	__be32 *dst = (__be32 *)out;
+
+	__be32 tmp[4];
+
+	memcpy(tmp, src, CAMELLIA_BLOCK_SIZE);	
+
+	switch (cctx-&gt;key_length) {
+	case 16:
+		camellia_decrypt128(cctx-&gt;key_table, tmp);
+		break;
+	case 24:
+		/* fall through */
+	case 32:
+		camellia_decrypt256(cctx-&gt;key_table, tmp);
+		break;
+	default:
+		break;
+	}
+
+	memcpy(dst, tmp, CAMELLIA_BLOCK_SIZE);
+}
+
+
+static struct crypto_alg camellia_alg = {
+        .cra_name               =       "camellia",
+        .cra_driver_name        =       "camellia-generic",
+        .cra_priority           =       100,
+        .cra_flags              =       CRYPTO_ALG_TYPE_CIPHER,
+        .cra_blocksize          =       CAMELLIA_BLOCK_SIZE,
+        .cra_ctxsize            =       sizeof(struct camellia_ctx),
+        .cra_alignmask          =       3,
+        .cra_module             =       THIS_MODULE,
+        .cra_list               =       LIST_HEAD_INIT(camellia_alg.cra_list),
+        .cra_u                  =       {
+                .cipher = {
+			.cia_min_keysize        =       CAMELLIA_MIN_KEY_SIZE,
+			.cia_max_keysize        =       CAMELLIA_MAX_KEY_SIZE,
+			.cia_setkey             =       camellia_set_key,
+			.cia_encrypt            =       camellia_encrypt,
+			.cia_decrypt            =       camellia_decrypt
+                }
+        }
+};
+
+static int __init camellia_init(void)
+{
+	return crypto_register_alg(&amp;camellia_alg);
+}
+
+
+static void __exit camellia_fini(void)
+{
+	crypto_unregister_alg(&amp;camellia_alg);
+}
+
+
+module_init(camellia_init);
+module_exit(camellia_fini);
+
+
+MODULE_DESCRIPTION("Camellia Cipher Algorithm");
+MODULE_LICENSE("GPL");
-- 
Noriaki TAKAMIYA

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061022050954</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-10-22 05:09:54-0400</timestampReceived><subject>Re: [PATCH 2/6] [CRYPTO] added the code of Camellia cipher algorithm.</subject><body>

On Wed, Oct 18, 2006 at 07:16:47AM +0000, Noriaki TAKAMIYA wrote:
&gt;
&gt; +static int
&gt; +camellia_set_key(struct crypto_tfm *tfm, const u8 *in_key,
&gt; +		 unsigned int key_len, u32 *flags)

Ugh, this doesn't compile with the current tree since the flags
field no longer exists for set_key.  I've fixed it up in my tree.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060902010023</emailId><senderName></senderName><senderEmail>rsnel</senderEmail><timestampReceived>2006-09-02 01:00:23-0400</timestampReceived><subject>[PATCHv2 2/6] crypto: benbi IV, big endian narrow block count for LRW-32-AES</subject><body>

From: Rik Snel &lt;rsnel@cube.dyndns.org&gt;

LRW-32-AES needs a certain IV. This IV should be provided dm-crypt.
The block cipher mode could, in principle generate the correct IV from
the plain IV, but I think that it is cleaner to supply the right IV
directly.

The sector -&gt; narrow block calculation uses a shift for performance reasons.
This shift is computed in .ctr and stored in cc-&gt;iv_gen_private (as a void*).

Signed-off-by: Rik Snel &lt;rsnel@cube.dyndns.org&gt;
---
 drivers/md/dm-crypt.c |   56 ++++++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 55 insertions(+), 1 deletions(-)

diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c
index 06961f7..df399d6 100644
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@ -106,6 +106,9 @@ static kmem_cache_t *_crypt_io_pool;
  *        encrypted with the bulk cipher using a salt as key. The salt
  *        should be derived from the bulk cipher's key via hashing.
  *
+ * benbi: the 64-bit "big-endian 'narrow block'-count", starting at 1
+ * 	  (needed for LRW-32-AES and possible other narrow block modes)
+ *
  * plumb: unimplemented, see:
  * http://article.gmane.org/gmane.linux.kernel.device-mapper.dm-crypt/454
  */
@@ -200,6 +203,49 @@ static int crypt_iv_essiv_gen(struct cry
 	return 0;
 }
 
+static int crypt_iv_benbi_ctr(struct crypt_config *cc, struct dm_target *ti,
+			      const char *opts)
+{
+	unsigned int bs = crypto_blkcipher_blocksize(cc-&gt;tfm);
+	int log = long_log2(bs);
+
+	/* we need to calculate how far we must shift the sector count
+	 * to get the cipher block count, we use this shift in _gen */
+
+	if (1 &lt;&lt; log != bs) {
+		ti-&gt;error = "cypher blocksize is not a power of 2";
+		return -EINVAL;
+	}
+
+	if (log &gt; 9) {
+		ti-&gt;error = "cypher blocksize is &gt; 512";
+		return -EINVAL;
+	}
+
+	if (crypto_blkcipher_ivsize(cc-&gt;tfm) &lt; sizeof(u64)) {
+		ti-&gt;error = "cypher ivsize is &lt; 8";
+		return -EINVAL;
+	}
+
+	cc-&gt;iv_gen_private = (void *)(9 - log);
+
+	return 0;
+}
+
+static void crypt_iv_benbi_dtr(struct crypt_config *cc)
+{
+	cc-&gt;iv_gen_private = NULL;
+}
+
+static int crypt_iv_benbi_gen(struct crypt_config *cc, u8 *iv, sector_t sector)
+{
+	memset(iv, 0, cc-&gt;iv_size - sizeof(u64)); /* rest is cleared below */
+	*(u64 *)(iv + cc-&gt;iv_size - sizeof(u64)) =
+		cpu_to_be64(((u64)sector &lt;&lt; (u32)cc-&gt;iv_gen_private) + 1);
+
+	return 0;
+}
+
 static struct crypt_iv_operations crypt_iv_plain_ops = {
 	.generator = crypt_iv_plain_gen
 };
@@ -210,6 +256,11 @@ static struct crypt_iv_operations crypt_
 	.generator = crypt_iv_essiv_gen
 };
 
+static struct crypt_iv_operations crypt_iv_benbi_ops = {
+	.ctr	   = crypt_iv_benbi_ctr,
+	.dtr	   = crypt_iv_benbi_dtr,
+	.generator = crypt_iv_benbi_gen
+};
 
 static int
 crypt_convert_scatterlist(struct crypt_config *cc, struct scatterlist *out,
@@ -579,7 +630,8 @@ static int crypt_ctr(struct dm_target *t
 	cc-&gt;tfm = tfm;
 
 	/*
-	 * Choose ivmode. Valid modes: "plain", "essiv:&lt;esshash&gt;".
+	 * Choose ivmode. Valid modes: "plain", "essiv:&lt;esshash&gt;", "benbi".
+	 *
 	 * See comments at iv code
 	 */
 
@@ -589,6 +641,8 @@ static int crypt_ctr(struct dm_target *t
 		cc-&gt;iv_gen_ops = &amp;crypt_iv_plain_ops;
 	else if (strcmp(ivmode, "essiv") == 0)
 		cc-&gt;iv_gen_ops = &amp;crypt_iv_essiv_ops;
+	else if (strcmp(ivmode, "benbi") == 0)
+		cc-&gt;iv_gen_ops = &amp;crypt_iv_benbi_ops;
 	else {
 		ti-&gt;error = "Invalid IV mode";
 		goto bad2;
-- 
1.4.1.1


-- 
VGER BF report: U 0.499935
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060902010024</emailId><senderName></senderName><senderEmail>rsnel</senderEmail><timestampReceived>2006-09-02 01:00:24-0400</timestampReceived><subject>[PATCHv2 3/6] crypto: some common 128-bit block operations, nicely centralized</subject><body>

From: Rik Snel &lt;rsnel@cube.dyndns.org&gt;

128bit is a common blocksize in linux kernel cryptography, so it helps to
centralize some common operations. The data must be aligned at sizeof(int)
for decent performance.

The code, while mostly trivial, is based on a header file mode_hdr.h in
http://fp.gladman.plus.com/AES/modes.vc8.19-06-06.zip

The original copyright (and GPL statement) of the original author,
Dr Brian Gladman, is preserved.

Signed-off-by: Rik Snel &lt;rsnel@cube.dyndns.org&gt;
---
 crypto/b128ops.h |   72 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 72 insertions(+), 0 deletions(-)

diff --git a/crypto/b128ops.h b/crypto/b128ops.h
new file mode 100644
index 0000000..73d8a5f
--- /dev/null
+++ b/crypto/b128ops.h
@@ -0,0 +1,72 @@
+/* b128ops.h - common 128-bit block operations
+ *
+ * Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.
+ * Copyright (c) 2006, Rik Snel &lt;rsnel@cube.dyndns.org&gt;
+ *
+ * Based on Dr Brian Gladman's (GPL'd) work published at
+ * http://fp.gladman.plus.com/cryptography_technology/index.htm
+ * See the original copyright notice below.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+/*
+ ---------------------------------------------------------------------------
+ Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.   All rights reserved.
+
+ LICENSE TERMS
+
+ The free distribution and use of this software in both source and binary
+ form is allowed (with or without changes) provided that:
+
+   1. distributions of this source code include the above copyright
+      notice, this list of conditions and the following disclaimer;
+
+   2. distributions in binary form include the above copyright
+      notice, this list of conditions and the following disclaimer
+      in the documentation and/or other associated materials;
+
+   3. the copyright holder's name is not used to endorse products
+      built using this software without specific written permission.
+
+ ALTERNATIVELY, provided that this notice is retained in full, this product
+ may be distributed under the terms of the GNU General Public License (GPL),
+ in which case the provisions of the GPL apply INSTEAD OF those given above.
+
+ DISCLAIMER
+
+ This software is provided 'as is' with no explicit or implied warranties
+ in respect of its properties, including, but not limited to, correctness
+ and/or fitness for purpose.
+ ---------------------------------------------------------------------------
+ Issue Date: 13/06/2006
+*/
+
+#ifndef _LINUX_B128OPS_H
+#define _LINUX_B128OPS_H
+
+#include &lt;linux/byteorder/swab.h&gt;
+
+/* watch out: for good performance p and q must be aligned to 32bit
+ * boundaries on a 32bit machine and to 64bit boundaries on a 64bit
+ * machine. */
+inline void b128ops_mov(void *p, const void *q)
+{
+	((u64 *)p)[0] = ((u64 *)q)[0];
+	((u64 *)p)[1] = ((u64 *)q)[1];
+}
+
+inline void b128ops_xor(void *p, const void *q)
+{
+	((u64 *)p)[0] ^= ((u64 *)q)[0];
+	((u64 *)p)[1] ^= ((u64 *)q)[1];
+}
+
+inline void bswap64_block(void *d, const void *s, u32 n)
+{
+	while(n--) ((u64 *)d)[n] = __swab64(((u64 *)s)[n]);
+}
+
+#endif /* _LINUX_B128OPS_H */
-- 
1.4.1.1


-- 
VGER BF report: U 0.5
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060902010026</emailId><senderName></senderName><senderEmail>rsnel</senderEmail><timestampReceived>2006-09-02 01:00:26-0400</timestampReceived><subject>[PATCHv2 5/6] LRW, Liskov Rivest Wagner, a tweakable narrow block cipher mode</subject><body>

From: Rik Snel &lt;rsnel@cube.dyndns.org&gt;

Main module, this implements the Liskov Rivest Wagner block cipher mode
in the new blockcipher API. The implementation is based on ecb.c.

The LRW-32-AES specification I used can be found at:
http://grouper.ieee.org/groups/1619/email/pdf00017.pdf

It implements the optimization specified as optional in the
specification, and in addition it uses optimized multiplication
routines from gf128mul.c.

Since gf128mul.[ch] is not tested on bigendian, this cipher mode
may currently fail badly on bigendian machines.

Signed-off-by: Rik Snel &lt;rsnel@cube.dyndns.org&gt;
---

Note: I rerolled the loop because it turned out that I had unrolled it
wrong. (I noticed it after I added the long testvector; a cypherblock
was split in two by a page boundary and the reconstructed block was
discarded because of an error in the unrolling).

 crypto/Kconfig  |   13 ++
 crypto/Makefile |    1 
 crypto/lrw.c    |  291 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 305 insertions(+), 0 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
index 6b23c20..dfdfe08 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -156,6 +156,19 @@ config CRYPTO_CBC
 	  CBC: Cipher Block Chaining mode
 	  This block cipher algorithm is required for IPSec.
 
+config CRYPTO_LRW
+	tristate "LRW support (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_GF128MUL
+	default n
+	help
+	  LRW: Liskov Rivest Wagner, a tweakable, non malleable, non movable
+	  narrow block cipher mode. Use it with cipher specification string
+	  aes-lrw-benbi, the key must be 256, 320 or 384. The first 128, 192
+	  or 256 bits in the key are used for AES and the rest is used to tie
+	  each cipher block to its logical position.
+
 config CRYPTO_DES
 	tristate "DES and Triple DES EDE cipher algorithms"
 	select CRYPTO_ALGAPI
diff --git a/crypto/Makefile b/crypto/Makefile
index bf0406b..e2e57be 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_CRYPTO_TGR192) += tgr192.o
 obj-$(CONFIG_CRYPTO_GF128MUL) += gf128mul.o
 obj-$(CONFIG_CRYPTO_ECB) += ecb.o
 obj-$(CONFIG_CRYPTO_CBC) += cbc.o
+obj-$(CONFIG_CRYPTO_LRW) += lrw.o
 obj-$(CONFIG_CRYPTO_DES) += des.o
 obj-$(CONFIG_CRYPTO_BLOWFISH) += blowfish.o
 obj-$(CONFIG_CRYPTO_TWOFISH) += twofish.o
diff --git a/crypto/lrw.c b/crypto/lrw.c
new file mode 100644
index 0000000..a037379
--- /dev/null
+++ b/crypto/lrw.c
@@ -0,0 +1,291 @@
+/* LRW: as defined by Cyril Guyot in
+ *	http://grouper.ieee.org/groups/1619/email/pdf00017.pdf
+ *
+ * Copyright (c) 2006 Rik Snel &lt;rsnel@cube.dyndns.org&gt;
+ *
+ * Based om ecb.c
+ * Copyright (c) 2006 Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+/* This implementation is checked against the test vectors in the above
+ * document and by a test vector provided by Ken Buchanan at
+ * http://www.mail-archive.com/stds-p1619@listserv.ieee.org/msg00173.html
+ *
+ * The test vectors are included in the testing module tcrypt.[ch] */
+#include &lt;crypto/algapi.h&gt;
+#include &lt;linux/err.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include &lt;linux/slab.h&gt;
+
+#include "b128ops.h"
+#include "gf128mul.h"
+
+struct priv {
+	struct crypto_cipher *child;
+	/* optimizes multiplying a random (non incrementing, as at the
+	 * start of a new sector) value with key2, we could also have
+	 * used 4k optimization tables or no optimization at all. In the
+	 * latter case we would have to store key2 here */
+	struct gf128mul_64k table;
+	/* stores:
+	 *  key2*{ 0,0,...0,0,0,0,1 }, key2*{ 0,0,...0,0,0,1,1 },
+	 *  key2*{ 0,0,...0,0,1,1,1 }, key2*{ 0,0,...0,1,1,1,1 }
+	 *  key2*{ 0,0,...1,1,1,1,1 }, etc
+	 * needed for optimized multiplication of incrementing values
+	 * with key2 */
+	u64 mulinc[128][GF128MUL_BYTES &gt;&gt; 3];
+};
+
+static inline void setbit128(void *b, int bit)
+{
+	int index = 15 - bit/8;
+	((u8 *)b)[index] |= 1&lt;&lt;(bit%8);
+}
+
+static int setkey(struct crypto_tfm *parent, const u8 *key,
+			     unsigned int keylen)
+{
+	struct priv *ctx = crypto_tfm_ctx(parent);
+	struct crypto_cipher *child = ctx-&gt;child;
+	int err, i;
+	u64 tmp[2] = { 0, }, scratch[2];
+	int bsize = crypto_cipher_blocksize(child);
+
+	crypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
+	crypto_cipher_set_flags(child, crypto_tfm_get_flags(parent) &amp;
+				       CRYPTO_TFM_REQ_MASK);
+	if ((err = crypto_cipher_setkey(child, key, keylen - bsize)))
+		return err;
+	crypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &amp;
+				     CRYPTO_TFM_RES_MASK);
+
+
+	/* initialize multiplication table for Key2 */
+	gf128mul_init_64k_bbe(&amp;ctx-&gt;table, (u64 *)(key + keylen - bsize));
+
+	/* initialize optimization table */
+	for (i = 0; i &lt; 128; i++) {
+		setbit128(tmp, i);
+		b128ops_mov(ctx-&gt;mulinc[i], tmp);
+		gf128mul_64k_bbe(ctx-&gt;mulinc[i], &amp;ctx-&gt;table, scratch);
+	}
+
+	return 0;
+}
+
+struct sinfo {
+	u64 b1[2], b2[2];
+	struct crypto_tfm *tfm;
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *);
+};
+
+static inline void inc(u64 *iv)
+{
+	if (!(iv[1] = cpu_to_be64(be64_to_cpu(iv[1]) + 1)))
+		iv[0] = cpu_to_be64(be64_to_cpu(iv[0]) + 1);
+}
+
+static inline void round(struct sinfo *s, u8 *dst, const u8 *src)
+{
+	b128ops_xor(s-&gt;b2, src);		/* PP &lt;- T xor P */
+	s-&gt;fn(s-&gt;tfm, dst, (u8 *)s-&gt;b2);	/* CC &lt;- E(Key2,PP) */
+	b128ops_xor(dst, s-&gt;b1);		/* C &lt;- T xor CC */
+}
+
+/* this returns the number of consequative 1 bits
+ * starting from the right in i */
+static inline int get_index8(u8 i)
+{
+	int j = 1;
+
+	if (i&amp;1) {
+		while ((i &gt;&gt;= 1)&amp;1) j++;
+		return j;
+	}
+
+	return 0;
+}
+
+/* this returns the number of consequative 1 bits starting
+ * from the right, get_index128(00 00 00 00 00 00 ... 00 00 10 FB) = 2 */
+static inline int get_index128(u8 *block)
+{
+	int inc, ret = 0, len = 16;
+	while ((inc = get_index8(block[--len])) == 8) ret += 8;
+	return ret + inc;
+}
+
+static int crypt(struct blkcipher_desc *d,
+			    struct scatterlist *dst,
+			    struct scatterlist *src,
+			    unsigned int nbytes, struct priv *ctx,
+			    void (*fn)(struct crypto_tfm *, u8 *, const u8 *))
+{
+	struct blkcipher_walk w;
+	int err, old_t_known = 0;
+	unsigned int avail;
+	const int bs = crypto_cipher_blocksize(ctx-&gt;child);
+	struct sinfo s = {
+		.tfm = crypto_cipher_tfm(ctx-&gt;child),
+		.fn = fn
+	};
+
+	blkcipher_walk_init(&amp;w, dst, src, nbytes);
+
+	err = blkcipher_walk_virt(d, &amp;w);
+
+	while ((avail = w.nbytes)) {
+		u8 *wsrc = w.src.virt.addr;
+		u8 *wdst = w.dst.virt.addr;
+		do {
+			if (old_t_known) {
+				/* old T is available in s.b1; new one
+			 	 * must be made available in b1 and b2 */
+
+				/* T &lt;- I*Key2, using the optimization
+				 * discussed in the specification */
+				b128ops_xor(s.b1, ctx-&gt;mulinc[
+						get_index128(w.iv)]);
+				inc((u64*)w.iv);
+				b128ops_mov(s.b2, s.b1);
+			} else {
+				/* calculate first value of T */
+				b128ops_mov(s.b1, w.iv);
+				/* T &lt;- I*Key2 */
+				gf128mul_64k_bbe(s.b1, &amp;ctx-&gt;table, s.b2);
+				old_t_known = 1;
+			}
+
+			round(&amp;s, wdst, wsrc);
+
+			wsrc += bs;
+			wdst += bs;
+		} while ((avail -= bs) &gt;= bs);
+
+		err = blkcipher_walk_done(d, &amp;w, avail);
+	}
+
+	return err;
+}
+
+static int encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,
+		struct scatterlist *src, unsigned int nbytes)
+{
+	struct priv *ctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	return crypt(desc, dst, src, nbytes, ctx,
+			crypto_cipher_alg(ctx-&gt;child)-&gt;cia_encrypt);
+}
+
+static int decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,
+		struct scatterlist *src, unsigned int nbytes)
+{
+	struct priv *ctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	return crypt(desc, dst, src, nbytes, ctx,
+			crypto_cipher_alg(ctx-&gt;child)-&gt;cia_decrypt);
+}
+
+static int init_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_instance *inst = (void *)tfm-&gt;__crt_alg;
+	struct crypto_spawn *spawn = crypto_instance_ctx(inst);
+	struct priv *ctx = crypto_tfm_ctx(tfm);
+	u32 *flags = &amp;tfm-&gt;crt_flags;
+
+	tfm = crypto_spawn_tfm(spawn);
+	if (IS_ERR(tfm))
+		return PTR_ERR(tfm);
+
+	if (crypto_tfm_alg_blocksize(tfm) != 16) {
+		*flags |= CRYPTO_TFM_RES_BAD_BLOCK_LEN;
+		return -EINVAL;
+	}
+
+	ctx-&gt;child = crypto_cipher_cast(tfm);
+	return 0;
+}
+
+static void exit_tfm(struct crypto_tfm *tfm)
+{
+	struct priv *ctx = crypto_tfm_ctx(tfm);
+	crypto_free_cipher(ctx-&gt;child);
+}
+
+static struct crypto_instance *alloc(void *param, unsigned int len)
+{
+	struct crypto_instance *inst;
+	struct crypto_alg *alg;
+
+	alg = crypto_get_attr_alg(param, len, CRYPTO_ALG_TYPE_CIPHER,
+				  CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_ASYNC);
+	if (IS_ERR(alg))
+		return ERR_PTR(PTR_ERR(alg));
+
+	inst = crypto_alloc_instance("lrw", alg);
+	if (IS_ERR(inst))
+		goto out_put_alg;
+
+	inst-&gt;alg.cra_flags = CRYPTO_ALG_TYPE_BLKCIPHER;
+	inst-&gt;alg.cra_priority = alg-&gt;cra_priority;
+	inst-&gt;alg.cra_blocksize = alg-&gt;cra_blocksize;
+
+	if (alg-&gt;cra_alignmask &lt; 7) inst-&gt;alg.cra_alignmask = 7;
+	else inst-&gt;alg.cra_alignmask = alg-&gt;cra_alignmask;
+	inst-&gt;alg.cra_type = &amp;crypto_blkcipher_type;
+
+	if (!(alg-&gt;cra_blocksize % 4))
+		inst-&gt;alg.cra_alignmask |= 3;
+	inst-&gt;alg.cra_blkcipher.ivsize = alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_blkcipher.min_keysize =
+		alg-&gt;cra_cipher.cia_min_keysize + alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_blkcipher.max_keysize =
+		alg-&gt;cra_cipher.cia_max_keysize + alg-&gt;cra_blocksize;
+
+	inst-&gt;alg.cra_ctxsize = sizeof(struct priv);
+
+	inst-&gt;alg.cra_init = init_tfm;
+	inst-&gt;alg.cra_exit = exit_tfm;
+
+	inst-&gt;alg.cra_blkcipher.setkey = setkey;
+	inst-&gt;alg.cra_blkcipher.encrypt = encrypt;
+	inst-&gt;alg.cra_blkcipher.decrypt = decrypt;
+
+out_put_alg:
+	crypto_mod_put(alg);
+	return inst;
+}
+
+static void free(struct crypto_instance *inst)
+{
+	crypto_drop_spawn(crypto_instance_ctx(inst));
+	kfree(inst);
+}
+
+static struct crypto_template crypto_tmpl = {
+	.name = "lrw",
+	.alloc = alloc,
+	.free = free,
+	.module = THIS_MODULE,
+};
+
+static int __init crypto_module_init(void)
+{
+	return crypto_register_template(&amp;crypto_tmpl);
+}
+
+static void __exit crypto_module_exit(void)
+{
+	crypto_unregister_template(&amp;crypto_tmpl);
+}
+
+module_init(crypto_module_init);
+module_exit(crypto_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("LRW block cipher mode");
-- 
1.4.1.1


-- 
VGER BF report: U 0.5
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060902010027</emailId><senderName></senderName><senderEmail>rsnel</senderEmail><timestampReceived>2006-09-02 01:00:27-0400</timestampReceived><subject>[PATCHv2 6/6] LRW testvectors in tcrypt.[ch]</subject><body>

From: Rik Snel &lt;rsnel@cube.dyndns.org&gt;

Do modprobe tcrypt mode=10 to check the included test vectors, they are
from: http://grouper.ieee.org/groups/1619/email/pdf00017.pdf and from
http://www.mail-archive.com/stds-p1619@listserv.ieee.org/msg00173.html.

To make the last test vector fit, I had to increase the buffer size of
input and result to 512 bytes.

Signed-off-by: Rik Snel &lt;rsnel@cube.dyndns.org&gt;
---
 crypto/tcrypt.c |   12 +
 crypto/tcrypt.h |  513 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 521 insertions(+), 4 deletions(-)

diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
index 840ab8b..0fd14c3 100644
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -906,6 +906,10 @@ static void do_test(void)
 			    AES_CBC_ENC_TEST_VECTORS);
 		test_cipher("cbc(aes)", DECRYPT, aes_cbc_dec_tv_template,
 			    AES_CBC_DEC_TEST_VECTORS);
+		test_cipher("lrw(aes)", ENCRYPT, aes_lrw_enc_tv_template,
+			    AES_LRW_ENC_TEST_VECTORS);
+		test_cipher("lrw(aes)", DECRYPT, aes_lrw_dec_tv_template,
+			    AES_LRW_DEC_TEST_VECTORS);
 
 		//CAST5
 		test_cipher("ecb(cast5)", ENCRYPT, cast5_enc_tv_template,
@@ -1052,6 +1056,10 @@ static void do_test(void)
 			    AES_CBC_ENC_TEST_VECTORS);
 		test_cipher("cbc(aes)", DECRYPT, aes_cbc_dec_tv_template,
 			    AES_CBC_DEC_TEST_VECTORS);
+		test_cipher("lrw(aes)", ENCRYPT, aes_lrw_enc_tv_template,
+			    AES_LRW_ENC_TEST_VECTORS);
+		test_cipher("lrw(aes)", DECRYPT, aes_lrw_dec_tv_template,
+			    AES_LRW_DEC_TEST_VECTORS);
 		break;
 
 	case 11:
@@ -1191,6 +1199,10 @@ static void do_test(void)
 				  aes_speed_template);
 		test_cipher_speed("cbc(aes)", DECRYPT, sec, NULL, 0,
 				  aes_speed_template);
+		test_cipher_speed("lrw(aes)", ENCRYPT, sec, NULL, 0,
+				  aes_speed_template);
+		test_cipher_speed("lrw(aes)", DECRYPT, sec, NULL, 0,
+				  aes_speed_template);
 		break;
 
 	case 201:
diff --git a/crypto/tcrypt.h b/crypto/tcrypt.h
index a40c441..0b60152 100644
--- a/crypto/tcrypt.h
+++ b/crypto/tcrypt.h
@@ -39,15 +39,15 @@ struct hash_testvec {
 struct cipher_testvec {
 	char key[MAX_KEYLEN] __attribute__ ((__aligned__(4)));
 	char iv[MAX_IVLEN];
-	char input[48];
-	char result[48];
+	char input[512];
+	char result[512];
 	unsigned char tap[MAX_TAP];
 	int np;
 	unsigned char fail;
 	unsigned char wk; /* weak key flag */
 	unsigned char klen;
-	unsigned char ilen;
-	unsigned char rlen;
+	unsigned short ilen;
+	unsigned short rlen;
 };
 
 struct cipher_speed {
@@ -1831,6 +1831,8 @@ #define AES_ENC_TEST_VECTORS 3
 #define AES_DEC_TEST_VECTORS 3
 #define AES_CBC_ENC_TEST_VECTORS 2
 #define AES_CBC_DEC_TEST_VECTORS 2
+#define AES_LRW_ENC_TEST_VECTORS 8
+#define AES_LRW_DEC_TEST_VECTORS 8
 
 static struct cipher_testvec aes_enc_tv_template[] = {
 	{ /* From FIPS-197 */
@@ -1968,6 +1970,509 @@ static struct cipher_testvec aes_cbc_dec
 	},
 };
 
+static struct cipher_testvec aes_lrw_enc_tv_template[] = {
+	/* from http://grouper.ieee.org/groups/1619/email/pdf00017.pdf */
+	{ /* LRW-32-AES 1 */
+		.key    = { 0x45, 0x62, 0xac, 0x25, 0xf8, 0x28, 0x17, 0x6d,
+			    0x4c, 0x26, 0x84, 0x14, 0xb5, 0x68, 0x01, 0x85,
+			    0x25, 0x8e, 0x2a, 0x05, 0xe7, 0x3e, 0x9d, 0x03,
+			    0xee, 0x5a, 0x83, 0x0c, 0xcc, 0x09, 0x4c, 0x87 },
+		.klen   = 32,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
+		.input  = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+			    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 },
+		.ilen   = 16,
+		.result = { 0xf1, 0xb2, 0x73, 0xcd, 0x65, 0xa3, 0xdf, 0x5f,
+			    0xe9, 0x5d, 0x48, 0x92, 0x54, 0x63, 0x4e, 0xb8 },
+		.rlen   = 16,
+	}, { /* LRW-32-AES 2 */
+		.key    = { 0x59, 0x70, 0x47, 0x14, 0xf5, 0x57, 0x47, 0x8c,
+		  	    0xd7, 0x79, 0xe8, 0x0f, 0x54, 0x88, 0x79, 0x44,
+			    0x0d, 0x48, 0xf0, 0xb7, 0xb1, 0x5a, 0x53, 0xea,
+			    0x1c, 0xaa, 0x6b, 0x29, 0xc2, 0xca, 0xfb, 0xaf
+		},
+		.klen   = 32,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 },
+		.input  = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+			    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 },
+		.ilen   = 16,
+		.result = { 0x00, 0xc8, 0x2b, 0xae, 0x95, 0xbb, 0xcd, 0xe5,
+			    0x27, 0x4f, 0x07, 0x69, 0xb2, 0x60, 0xe1, 0x36 },
+		.rlen   = 16,
+	}, { /* LRW-32-AES 3 */
+		.key    = { 0xd8, 0x2a, 0x91, 0x34, 0xb2, 0x6a, 0x56, 0x50,
+		  	    0x30, 0xfe, 0x69, 0xe2, 0x37, 0x7f, 0x98, 0x47,
+			    0xcd, 0xf9, 0x0b, 0x16, 0x0c, 0x64, 0x8f, 0xb6,
+			    0xb0, 0x0d, 0x0d, 0x1b, 0xae, 0x85, 0x87, 0x1f },
+		.klen   = 32,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 },
+		.input  = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+			    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 },
+		.ilen   = 16,
+		.result = { 0x76, 0x32, 0x21, 0x83, 0xed, 0x8f, 0xf1, 0x82,
+			    0xf9, 0x59, 0x62, 0x03, 0x69, 0x0e, 0x5e, 0x01 },
+		.rlen   = 16,
+	}, { /* LRW-32-AES 4 */
+		.key    = { 0x0f, 0x6a, 0xef, 0xf8, 0xd3, 0xd2, 0xbb, 0x15,
+		  	    0x25, 0x83, 0xf7, 0x3c, 0x1f, 0x01, 0x28, 0x74,
+			    0xca, 0xc6, 0xbc, 0x35, 0x4d, 0x4a, 0x65, 0x54,
+			    0x90, 0xae, 0x61, 0xcf, 0x7b, 0xae, 0xbd, 0xcc,
+			    0xad, 0xe4, 0x94, 0xc5, 0x4a, 0x29, 0xae, 0x70 },
+		.klen   = 40,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
+		.input  = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+			    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 },
+		.ilen   = 16,
+		.result = { 0x9c, 0x0f, 0x15, 0x2f, 0x55, 0xa2, 0xd8, 0xf0,
+			    0xd6, 0x7b, 0x8f, 0x9e, 0x28, 0x22, 0xbc, 0x41 },
+		.rlen   = 16,
+	}, { /* LRW-32-AES 5 */
+		.key    = { 0x8a, 0xd4, 0xee, 0x10, 0x2f, 0xbd, 0x81, 0xff,
+		  	    0xf8, 0x86, 0xce, 0xac, 0x93, 0xc5, 0xad, 0xc6,
+			    0xa0, 0x19, 0x07, 0xc0, 0x9d, 0xf7, 0xbb, 0xdd,
+			    0x52, 0x13, 0xb2, 0xb7, 0xf0, 0xff, 0x11, 0xd8,
+			    0xd6, 0x08, 0xd0, 0xcd, 0x2e, 0xb1, 0x17, 0x6f },
+		.klen   = 40,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 },
+		.input  = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+			    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 },
+		.ilen   = 16,
+		.result = { 0xd4, 0x27, 0x6a, 0x7f, 0x14, 0x91, 0x3d, 0x65,
+			    0xc8, 0x60, 0x48, 0x02, 0x87, 0xe3, 0x34, 0x06 },
+		.rlen   = 16,
+	}, { /* LRW-32-AES 6 */
+		.key    = { 0xf8, 0xd4, 0x76, 0xff, 0xd6, 0x46, 0xee, 0x6c,
+		  	    0x23, 0x84, 0xcb, 0x1c, 0x77, 0xd6, 0x19, 0x5d,
+			    0xfe, 0xf1, 0xa9, 0xf3, 0x7b, 0xbc, 0x8d, 0x21,
+			    0xa7, 0x9c, 0x21, 0xf8, 0xcb, 0x90, 0x02, 0x89,
+			    0xa8, 0x45, 0x34, 0x8e, 0xc8, 0xc5, 0xb5, 0xf1,
+			    0x26, 0xf5, 0x0e, 0x76, 0xfe, 0xfd, 0x1b, 0x1e },
+		.klen   = 48,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
+		.input  = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+			    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 },
+		.ilen   = 16,
+		.result = { 0xbd, 0x06, 0xb8, 0xe1, 0xdb, 0x98, 0x89, 0x9e,
+			    0xc4, 0x98, 0xe4, 0x91, 0xcf, 0x1c, 0x70, 0x2b },
+		.rlen   = 16,
+	}, { /* LRW-32-AES 7 */
+		.key    = { 0xfb, 0x76, 0x15, 0xb2, 0x3d, 0x80, 0x89, 0x1d,
+		  	    0xd4, 0x70, 0x98, 0x0b, 0xc7, 0x95, 0x84, 0xc8,
+			    0xb2, 0xfb, 0x64, 0xce, 0x60, 0x97, 0x87, 0x8d,
+			    0x17, 0xfc, 0xe4, 0x5a, 0x49, 0xe8, 0x30, 0xb7,
+			    0x6e, 0x78, 0x17, 0xe7, 0x2d, 0x5e, 0x12, 0xd4,
+			    0x60, 0x64, 0x04, 0x7a, 0xf1, 0x2f, 0x9e, 0x0c },
+		.klen   = 48,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 },
+		.input  = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+			    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 },
+		.ilen   = 16,
+		.result = { 0x5b, 0x90, 0x8e, 0xc1, 0xab, 0xdd, 0x67, 0x5f,
+			    0x3d, 0x69, 0x8a, 0x95, 0x53, 0xc8, 0x9c, 0xe5 },
+		.rlen   = 16,
+	}, {
+/* http://www.mail-archive.com/stds-p1619@listserv.ieee.org/msg00173.html */
+		.key    = { 0xf8, 0xd4, 0x76, 0xff, 0xd6, 0x46, 0xee, 0x6c,
+			    0x23, 0x84, 0xcb, 0x1c, 0x77, 0xd6, 0x19, 0x5d,
+			    0xfe, 0xf1, 0xa9, 0xf3, 0x7b, 0xbc, 0x8d, 0x21,
+			    0xa7, 0x9c, 0x21, 0xf8, 0xcb, 0x90, 0x02, 0x89,
+			    0xa8, 0x45, 0x34, 0x8e, 0xc8, 0xc5, 0xb5, 0xf1,
+			    0x26, 0xf5, 0x0e, 0x76, 0xfe, 0xfd, 0x1b, 0x1e },
+		.klen   = 48,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
+		.input  = { 0x05, 0x11, 0xb7, 0x18, 0xab, 0xc6, 0x2d, 0xac,
+			    0x70, 0x5d, 0xf6, 0x22, 0x94, 0xcd, 0xe5, 0x6c,
+			    0x17, 0x6b, 0xf6, 0x1c, 0xf0, 0xf3, 0x6e, 0xf8,
+			    0x50, 0x38, 0x1f, 0x71, 0x49, 0xb6, 0x57, 0xd6,
+			    0x8f, 0xcb, 0x8d, 0x6b, 0xe3, 0xa6, 0x29, 0x90,
+			    0xfe, 0x2a, 0x62, 0x82, 0xae, 0x6d, 0x8b, 0xf6,
+			    0xad, 0x1e, 0x9e, 0x20, 0x5f, 0x38, 0xbe, 0x04,
+			    0xda, 0x10, 0x8e, 0xed, 0xa2, 0xa4, 0x87, 0xab,
+			    0xda, 0x6b, 0xb4, 0x0c, 0x75, 0xba, 0xd3, 0x7c,
+			    0xc9, 0xac, 0x42, 0x31, 0x95, 0x7c, 0xc9, 0x04,
+			    0xeb, 0xd5, 0x6e, 0x32, 0x69, 0x8a, 0xdb, 0xa6,
+			    0x15, 0xd7, 0x3f, 0x4f, 0x2f, 0x66, 0x69, 0x03,
+			    0x9c, 0x1f, 0x54, 0x0f, 0xde, 0x1f, 0xf3, 0x65,
+			    0x4c, 0x96, 0x12, 0xed, 0x7c, 0x92, 0x03, 0x01,
+			    0x6f, 0xbc, 0x35, 0x93, 0xac, 0xf1, 0x27, 0xf1,
+			    0xb4, 0x96, 0x82, 0x5a, 0x5f, 0xb0, 0xa0, 0x50,
+			    0x89, 0xa4, 0x8e, 0x66, 0x44, 0x85, 0xcc, 0xfd,
+			    0x33, 0x14, 0x70, 0xe3, 0x96, 0xb2, 0xc3, 0xd3,
+			    0xbb, 0x54, 0x5a, 0x1a, 0xf9, 0x74, 0xa2, 0xc5,
+			    0x2d, 0x64, 0x75, 0xdd, 0xb4, 0x54, 0xe6, 0x74,
+			    0x8c, 0xd3, 0x9d, 0x9e, 0x86, 0xab, 0x51, 0x53,
+			    0xb7, 0x93, 0x3e, 0x6f, 0xd0, 0x4e, 0x2c, 0x40,
+			    0xf6, 0xa8, 0x2e, 0x3e, 0x9d, 0xf4, 0x66, 0xa5,
+			    0x76, 0x12, 0x73, 0x44, 0x1a, 0x56, 0xd7, 0x72,
+			    0x88, 0xcd, 0x21, 0x8c, 0x4c, 0x0f, 0xfe, 0xda,
+			    0x95, 0xe0, 0x3a, 0xa6, 0xa5, 0x84, 0x46, 0xcd,
+			    0xd5, 0x3e, 0x9d, 0x3a, 0xe2, 0x67, 0xe6, 0x60,
+			    0x1a, 0xe2, 0x70, 0x85, 0x58, 0xc2, 0x1b, 0x09,
+			    0xe1, 0xd7, 0x2c, 0xca, 0xad, 0xa8, 0x8f, 0xf9,
+			    0xac, 0xb3, 0x0e, 0xdb, 0xca, 0x2e, 0xe2, 0xb8,
+			    0x51, 0x71, 0xd9, 0x3c, 0x6c, 0xf1, 0x56, 0xf8,
+			    0xea, 0x9c, 0xf1, 0xfb, 0x0c, 0xe6, 0xb7, 0x10,
+			    0x1c, 0xf8, 0xa9, 0x7c, 0xe8, 0x53, 0x35, 0xc1,
+			    0x90, 0x3e, 0x76, 0x4a, 0x74, 0xa4, 0x21, 0x2c,
+			    0xf6, 0x2c, 0x4e, 0x0f, 0x94, 0x3a, 0x88, 0x2e,
+			    0x41, 0x09, 0x6a, 0x33, 0x7d, 0xf6, 0xdd, 0x3f,
+			    0x8d, 0x23, 0x31, 0x74, 0x84, 0xeb, 0x88, 0x6e,
+			    0xcc, 0xb9, 0xbc, 0x22, 0x83, 0x19, 0x07, 0x22,
+			    0xa5, 0x2d, 0xdf, 0xa5, 0xf3, 0x80, 0x85, 0x78,
+			    0x84, 0x39, 0x6a, 0x6d, 0x6a, 0x99, 0x4f, 0xa5,
+			    0x15, 0xfe, 0x46, 0xb0, 0xe4, 0x6c, 0xa5, 0x41,
+			    0x3c, 0xce, 0x8f, 0x42, 0x60, 0x71, 0xa7, 0x75,
+			    0x08, 0x40, 0x65, 0x8a, 0x82, 0xbf, 0xf5, 0x43,
+			    0x71, 0x96, 0xa9, 0x4d, 0x44, 0x8a, 0x20, 0xbe,
+			    0xfa, 0x4d, 0xbb, 0xc0, 0x7d, 0x31, 0x96, 0x65,
+			    0xe7, 0x75, 0xe5, 0x3e, 0xfd, 0x92, 0x3b, 0xc9,
+			    0x55, 0xbb, 0x16, 0x7e, 0xf7, 0xc2, 0x8c, 0xa4,
+			    0x40, 0x1d, 0xe5, 0xef, 0x0e, 0xdf, 0xe4, 0x9a,
+			    0x62, 0x73, 0x65, 0xfd, 0x46, 0x63, 0x25, 0x3d,
+			    0x2b, 0xaf, 0xe5, 0x64, 0xfe, 0xa5, 0x5c, 0xcf,
+			    0x24, 0xf3, 0xb4, 0xac, 0x64, 0xba, 0xdf, 0x4b,
+			    0xc6, 0x96, 0x7d, 0x81, 0x2d, 0x8d, 0x97, 0xf7,
+			    0xc5, 0x68, 0x77, 0x84, 0x32, 0x2b, 0xcc, 0x85,
+			    0x74, 0x96, 0xf0, 0x12, 0x77, 0x61, 0xb9, 0xeb,
+			    0x71, 0xaa, 0x82, 0xcb, 0x1c, 0xdb, 0x89, 0xc8,
+			    0xc6, 0xb5, 0xe3, 0x5c, 0x7d, 0x39, 0x07, 0x24,
+			    0xda, 0x39, 0x87, 0x45, 0xc0, 0x2b, 0xbb, 0x01,
+			    0xac, 0xbc, 0x2a, 0x5c, 0x7f, 0xfc, 0xe8, 0xce,
+			    0x6d, 0x9c, 0x6f, 0xed, 0xd3, 0xc1, 0xa1, 0xd6,
+			    0xc5, 0x55, 0xa9, 0x66, 0x2f, 0xe1, 0xc8, 0x32,
+			    0xa6, 0x5d, 0xa4, 0x3a, 0x98, 0x73, 0xe8, 0x45,
+			    0xa4, 0xc7, 0xa8, 0xb4, 0xf6, 0x13, 0x03, 0xf6,
+			    0xe9, 0x2e, 0xc4, 0x29, 0x0f, 0x84, 0xdb, 0xc4,
+			    0x21, 0xc4, 0xc2, 0x75, 0x67, 0x89, 0x37, 0x0a },
+		.ilen   = 512,
+		.result = { 0x1a, 0x1d, 0xa9, 0x30, 0xad, 0xf9, 0x2f, 0x9b,
+			    0xb6, 0x1d, 0xae, 0xef, 0xf0, 0x2f, 0xf8, 0x5a,
+			    0x39, 0x3c, 0xbf, 0x2a, 0xb2, 0x45, 0xb2, 0x23,
+			    0x1b, 0x63, 0x3c, 0xcf, 0xaa, 0xbe, 0xcf, 0x4e,
+			    0xfa, 0xe8, 0x29, 0xc2, 0x20, 0x68, 0x2b, 0x3c,
+			    0x2e, 0x8b, 0xf7, 0x6e, 0x25, 0xbd, 0xe3, 0x3d,
+			    0x66, 0x27, 0xd6, 0xaf, 0xd6, 0x64, 0x3e, 0xe3,
+			    0xe8, 0x58, 0x46, 0x97, 0x39, 0x51, 0x07, 0xde,
+			    0xcb, 0x37, 0xbc, 0xa9, 0xc0, 0x5f, 0x75, 0xc3,
+			    0x0e, 0x84, 0x23, 0x1d, 0x16, 0xd4, 0x1c, 0x59,
+			    0x9c, 0x1a, 0x02, 0x55, 0xab, 0x3a, 0x97, 0x1d,
+			    0xdf, 0xdd, 0xc7, 0x06, 0x51, 0xd7, 0x70, 0xae,
+			    0x23, 0xc6, 0x8c, 0xf5, 0x1e, 0xa0, 0xe5, 0x82,
+			    0xb8, 0xb2, 0xbf, 0x04, 0xa0, 0x32, 0x8e, 0x68,
+			    0xeb, 0xaf, 0x6e, 0x2d, 0x94, 0x22, 0x2f, 0xce,
+			    0x4c, 0xb5, 0x59, 0xe2, 0xa2, 0x2f, 0xa0, 0x98,
+			    0x1a, 0x97, 0xc6, 0xd4, 0xb5, 0x00, 0x59, 0xf2,
+			    0x84, 0x14, 0x72, 0xb1, 0x9a, 0x6e, 0xa3, 0x7f,
+			    0xea, 0x20, 0xe7, 0xcb, 0x65, 0x77, 0x3a, 0xdf,
+			    0xc8, 0x97, 0x67, 0x15, 0xc2, 0x2a, 0x27, 0xcc,
+			    0x18, 0x55, 0xa1, 0x24, 0x0b, 0x24, 0x24, 0xaf,
+			    0x5b, 0xec, 0x68, 0xb8, 0xc8, 0xf5, 0xba, 0x63,
+			    0xff, 0xed, 0x89, 0xce, 0xd5, 0x3d, 0x88, 0xf3,
+			    0x25, 0xef, 0x05, 0x7c, 0x3a, 0xef, 0xeb, 0xd8,
+			    0x7a, 0x32, 0x0d, 0xd1, 0x1e, 0x58, 0x59, 0x99,
+			    0x90, 0x25, 0xb5, 0x26, 0xb0, 0xe3, 0x2b, 0x6c,
+			    0x4c, 0xa9, 0x8b, 0x84, 0x4f, 0x5e, 0x01, 0x50,
+			    0x41, 0x30, 0x58, 0xc5, 0x62, 0x74, 0x52, 0x1d,
+			    0x45, 0x24, 0x6a, 0x42, 0x64, 0x4f, 0x97, 0x1c,
+			    0xa8, 0x66, 0xb5, 0x6d, 0x79, 0xd4, 0x0d, 0x48,
+			    0xc5, 0x5f, 0xf3, 0x90, 0x32, 0xdd, 0xdd, 0xe1,
+			    0xe4, 0xa9, 0x9f, 0xfc, 0xc3, 0x52, 0x5a, 0x46,
+			    0xe4, 0x81, 0x84, 0x95, 0x36, 0x59, 0x7a, 0x6b,
+			    0xaa, 0xb3, 0x60, 0xad, 0xce, 0x9f, 0x9f, 0x28,
+			    0xe0, 0x01, 0x75, 0x22, 0xc4, 0x4e, 0xa9, 0x62,
+			    0x5c, 0x62, 0x0d, 0x00, 0xcb, 0x13, 0xe8, 0x43,
+			    0x72, 0xd4, 0x2d, 0x53, 0x46, 0xb5, 0xd1, 0x16,
+			    0x22, 0x18, 0xdf, 0x34, 0x33, 0xf5, 0xd6, 0x1c,
+			    0xb8, 0x79, 0x78, 0x97, 0x94, 0xff, 0x72, 0x13,
+			    0x4c, 0x27, 0xfc, 0xcb, 0xbf, 0x01, 0x53, 0xa6,
+			    0xb4, 0x50, 0x6e, 0xde, 0xdf, 0xb5, 0x43, 0xa4,
+			    0x59, 0xdf, 0x52, 0xf9, 0x7c, 0xe0, 0x11, 0x6f,
+			    0x2d, 0x14, 0x8e, 0x24, 0x61, 0x2c, 0xe1, 0x17,
+			    0xcc, 0xce, 0x51, 0x0c, 0x19, 0x8a, 0x82, 0x30,
+			    0x94, 0xd5, 0x3d, 0x6a, 0x53, 0x06, 0x5e, 0xbd,
+			    0xb7, 0xeb, 0xfa, 0xfd, 0x27, 0x51, 0xde, 0x85,
+			    0x1e, 0x86, 0x53, 0x11, 0x53, 0x94, 0x00, 0xee,
+			    0x2b, 0x8c, 0x08, 0x2a, 0xbf, 0xdd, 0xae, 0x11,
+			    0xcb, 0x1e, 0xa2, 0x07, 0x9a, 0x80, 0xcf, 0x62,
+			    0x9b, 0x09, 0xdc, 0x95, 0x3c, 0x96, 0x8e, 0xb1,
+			    0x09, 0xbd, 0xe4, 0xeb, 0xdb, 0xca, 0x70, 0x7a,
+			    0x9e, 0xfa, 0x31, 0x18, 0x45, 0x3c, 0x21, 0x33,
+			    0xb0, 0xb3, 0x2b, 0xea, 0xf3, 0x71, 0x2d, 0xe1,
+			    0x03, 0xad, 0x1b, 0x48, 0xd4, 0x67, 0x27, 0xf0,
+			    0x62, 0xe4, 0x3d, 0xfb, 0x9b, 0x08, 0x76, 0xe7,
+			    0xdd, 0x2b, 0x01, 0x39, 0x04, 0x5a, 0x58, 0x7a,
+			    0xf7, 0x11, 0x90, 0xec, 0xbd, 0x51, 0x5c, 0x32,
+			    0x6b, 0xd7, 0x35, 0x39, 0x02, 0x6b, 0xf2, 0xa6,
+			    0xd0, 0x0d, 0x07, 0xe1, 0x06, 0xc4, 0x5b, 0x7d,
+			    0xe4, 0x6a, 0xd7, 0xee, 0x15, 0x1f, 0x83, 0xb4,
+			    0xa3, 0xa7, 0x5e, 0xc3, 0x90, 0xb7, 0xef, 0xd3,
+			    0xb7, 0x4f, 0xf8, 0x92, 0x4c, 0xb7, 0x3c, 0x29,
+			    0xcd, 0x7e, 0x2b, 0x5d, 0x43, 0xea, 0x42, 0xe7,
+			    0x74, 0x3f, 0x7d, 0x58, 0x88, 0x75, 0xde, 0x3e },
+		.rlen   = 512,
+	}
+};
+
+static struct cipher_testvec aes_lrw_dec_tv_template[] = {
+	/* from http://grouper.ieee.org/groups/1619/email/pdf00017.pdf */
+	/* same as enc vectors with input and result reversed */
+	{ /* LRW-32-AES 1 */
+		.key    = { 0x45, 0x62, 0xac, 0x25, 0xf8, 0x28, 0x17, 0x6d,
+			    0x4c, 0x26, 0x84, 0x14, 0xb5, 0x68, 0x01, 0x85,
+			    0x25, 0x8e, 0x2a, 0x05, 0xe7, 0x3e, 0x9d, 0x03,
+			    0xee, 0x5a, 0x83, 0x0c, 0xcc, 0x09, 0x4c, 0x87 },
+		.klen   = 32,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
+		.input  = { 0xf1, 0xb2, 0x73, 0xcd, 0x65, 0xa3, 0xdf, 0x5f,
+			    0xe9, 0x5d, 0x48, 0x92, 0x54, 0x63, 0x4e, 0xb8 },
+		.ilen   = 16,
+		.result = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+			    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 },
+		.rlen   = 16,
+	}, { /* LRW-32-AES 2 */
+		.key    = { 0x59, 0x70, 0x47, 0x14, 0xf5, 0x57, 0x47, 0x8c,
+		  	    0xd7, 0x79, 0xe8, 0x0f, 0x54, 0x88, 0x79, 0x44,
+			    0x0d, 0x48, 0xf0, 0xb7, 0xb1, 0x5a, 0x53, 0xea,
+			    0x1c, 0xaa, 0x6b, 0x29, 0xc2, 0xca, 0xfb, 0xaf
+		},
+		.klen   = 32,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 },
+		.input  = { 0x00, 0xc8, 0x2b, 0xae, 0x95, 0xbb, 0xcd, 0xe5,
+			    0x27, 0x4f, 0x07, 0x69, 0xb2, 0x60, 0xe1, 0x36 },
+		.ilen   = 16,
+		.result  = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+			     0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 },
+		.rlen   = 16,
+	}, { /* LRW-32-AES 3 */
+		.key    = { 0xd8, 0x2a, 0x91, 0x34, 0xb2, 0x6a, 0x56, 0x50,
+		  	    0x30, 0xfe, 0x69, 0xe2, 0x37, 0x7f, 0x98, 0x47,
+			    0xcd, 0xf9, 0x0b, 0x16, 0x0c, 0x64, 0x8f, 0xb6,
+			    0xb0, 0x0d, 0x0d, 0x1b, 0xae, 0x85, 0x87, 0x1f },
+		.klen   = 32,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 },
+		.input  = { 0x76, 0x32, 0x21, 0x83, 0xed, 0x8f, 0xf1, 0x82,
+			    0xf9, 0x59, 0x62, 0x03, 0x69, 0x0e, 0x5e, 0x01 },
+		.ilen   = 16,
+		.result = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+			    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 },
+		.rlen   = 16,
+	}, { /* LRW-32-AES 4 */
+		.key    = { 0x0f, 0x6a, 0xef, 0xf8, 0xd3, 0xd2, 0xbb, 0x15,
+		  	    0x25, 0x83, 0xf7, 0x3c, 0x1f, 0x01, 0x28, 0x74,
+			    0xca, 0xc6, 0xbc, 0x35, 0x4d, 0x4a, 0x65, 0x54,
+			    0x90, 0xae, 0x61, 0xcf, 0x7b, 0xae, 0xbd, 0xcc,
+			    0xad, 0xe4, 0x94, 0xc5, 0x4a, 0x29, 0xae, 0x70 },
+		.klen   = 40,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
+		.input  = { 0x9c, 0x0f, 0x15, 0x2f, 0x55, 0xa2, 0xd8, 0xf0,
+			    0xd6, 0x7b, 0x8f, 0x9e, 0x28, 0x22, 0xbc, 0x41 },
+		.ilen   = 16,
+		.result = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+			    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 },
+		.rlen   = 16,
+	}, { /* LRW-32-AES 5 */
+		.key    = { 0x8a, 0xd4, 0xee, 0x10, 0x2f, 0xbd, 0x81, 0xff,
+		  	    0xf8, 0x86, 0xce, 0xac, 0x93, 0xc5, 0xad, 0xc6,
+			    0xa0, 0x19, 0x07, 0xc0, 0x9d, 0xf7, 0xbb, 0xdd,
+			    0x52, 0x13, 0xb2, 0xb7, 0xf0, 0xff, 0x11, 0xd8,
+			    0xd6, 0x08, 0xd0, 0xcd, 0x2e, 0xb1, 0x17, 0x6f },
+		.klen   = 40,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 },
+		.input  = { 0xd4, 0x27, 0x6a, 0x7f, 0x14, 0x91, 0x3d, 0x65,
+			    0xc8, 0x60, 0x48, 0x02, 0x87, 0xe3, 0x34, 0x06 },
+		.ilen   = 16,
+		.result = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+			    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 },
+		.rlen   = 16,
+	}, { /* LRW-32-AES 6 */
+		.key    = { 0xf8, 0xd4, 0x76, 0xff, 0xd6, 0x46, 0xee, 0x6c,
+		  	    0x23, 0x84, 0xcb, 0x1c, 0x77, 0xd6, 0x19, 0x5d,
+			    0xfe, 0xf1, 0xa9, 0xf3, 0x7b, 0xbc, 0x8d, 0x21,
+			    0xa7, 0x9c, 0x21, 0xf8, 0xcb, 0x90, 0x02, 0x89,
+			    0xa8, 0x45, 0x34, 0x8e, 0xc8, 0xc5, 0xb5, 0xf1,
+			    0x26, 0xf5, 0x0e, 0x76, 0xfe, 0xfd, 0x1b, 0x1e },
+		.klen   = 48,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
+		.input  = { 0xbd, 0x06, 0xb8, 0xe1, 0xdb, 0x98, 0x89, 0x9e,
+			    0xc4, 0x98, 0xe4, 0x91, 0xcf, 0x1c, 0x70, 0x2b },
+		.ilen   = 16,
+		.result = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+			    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 },
+		.rlen   = 16,
+	}, { /* LRW-32-AES 7 */
+		.key    = { 0xfb, 0x76, 0x15, 0xb2, 0x3d, 0x80, 0x89, 0x1d,
+		  	    0xd4, 0x70, 0x98, 0x0b, 0xc7, 0x95, 0x84, 0xc8,
+			    0xb2, 0xfb, 0x64, 0xce, 0x60, 0x97, 0x87, 0x8d,
+			    0x17, 0xfc, 0xe4, 0x5a, 0x49, 0xe8, 0x30, 0xb7,
+			    0x6e, 0x78, 0x17, 0xe7, 0x2d, 0x5e, 0x12, 0xd4,
+			    0x60, 0x64, 0x04, 0x7a, 0xf1, 0x2f, 0x9e, 0x0c },
+		.klen   = 48,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 },
+		.input  = { 0x5b, 0x90, 0x8e, 0xc1, 0xab, 0xdd, 0x67, 0x5f,
+			    0x3d, 0x69, 0x8a, 0x95, 0x53, 0xc8, 0x9c, 0xe5 },
+		.ilen   = 16,
+		.result = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+			    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 },
+		.rlen   = 16,
+	}, {
+/* http://www.mail-archive.com/stds-p1619@listserv.ieee.org/msg00173.html */
+		.key    = { 0xf8, 0xd4, 0x76, 0xff, 0xd6, 0x46, 0xee, 0x6c,
+			    0x23, 0x84, 0xcb, 0x1c, 0x77, 0xd6, 0x19, 0x5d,
+			    0xfe, 0xf1, 0xa9, 0xf3, 0x7b, 0xbc, 0x8d, 0x21,
+			    0xa7, 0x9c, 0x21, 0xf8, 0xcb, 0x90, 0x02, 0x89,
+			    0xa8, 0x45, 0x34, 0x8e, 0xc8, 0xc5, 0xb5, 0xf1,
+			    0x26, 0xf5, 0x0e, 0x76, 0xfe, 0xfd, 0x1b, 0x1e },
+		.klen   = 48,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
+		.input	= { 0x1a, 0x1d, 0xa9, 0x30, 0xad, 0xf9, 0x2f, 0x9b,
+			    0xb6, 0x1d, 0xae, 0xef, 0xf0, 0x2f, 0xf8, 0x5a,
+			    0x39, 0x3c, 0xbf, 0x2a, 0xb2, 0x45, 0xb2, 0x23,
+			    0x1b, 0x63, 0x3c, 0xcf, 0xaa, 0xbe, 0xcf, 0x4e,
+			    0xfa, 0xe8, 0x29, 0xc2, 0x20, 0x68, 0x2b, 0x3c,
+			    0x2e, 0x8b, 0xf7, 0x6e, 0x25, 0xbd, 0xe3, 0x3d,
+			    0x66, 0x27, 0xd6, 0xaf, 0xd6, 0x64, 0x3e, 0xe3,
+			    0xe8, 0x58, 0x46, 0x97, 0x39, 0x51, 0x07, 0xde,
+			    0xcb, 0x37, 0xbc, 0xa9, 0xc0, 0x5f, 0x75, 0xc3,
+			    0x0e, 0x84, 0x23, 0x1d, 0x16, 0xd4, 0x1c, 0x59,
+			    0x9c, 0x1a, 0x02, 0x55, 0xab, 0x3a, 0x97, 0x1d,
+			    0xdf, 0xdd, 0xc7, 0x06, 0x51, 0xd7, 0x70, 0xae,
+			    0x23, 0xc6, 0x8c, 0xf5, 0x1e, 0xa0, 0xe5, 0x82,
+			    0xb8, 0xb2, 0xbf, 0x04, 0xa0, 0x32, 0x8e, 0x68,
+			    0xeb, 0xaf, 0x6e, 0x2d, 0x94, 0x22, 0x2f, 0xce,
+			    0x4c, 0xb5, 0x59, 0xe2, 0xa2, 0x2f, 0xa0, 0x98,
+			    0x1a, 0x97, 0xc6, 0xd4, 0xb5, 0x00, 0x59, 0xf2,
+			    0x84, 0x14, 0x72, 0xb1, 0x9a, 0x6e, 0xa3, 0x7f,
+			    0xea, 0x20, 0xe7, 0xcb, 0x65, 0x77, 0x3a, 0xdf,
+			    0xc8, 0x97, 0x67, 0x15, 0xc2, 0x2a, 0x27, 0xcc,
+			    0x18, 0x55, 0xa1, 0x24, 0x0b, 0x24, 0x24, 0xaf,
+			    0x5b, 0xec, 0x68, 0xb8, 0xc8, 0xf5, 0xba, 0x63,
+			    0xff, 0xed, 0x89, 0xce, 0xd5, 0x3d, 0x88, 0xf3,
+			    0x25, 0xef, 0x05, 0x7c, 0x3a, 0xef, 0xeb, 0xd8,
+			    0x7a, 0x32, 0x0d, 0xd1, 0x1e, 0x58, 0x59, 0x99,
+			    0x90, 0x25, 0xb5, 0x26, 0xb0, 0xe3, 0x2b, 0x6c,
+			    0x4c, 0xa9, 0x8b, 0x84, 0x4f, 0x5e, 0x01, 0x50,
+			    0x41, 0x30, 0x58, 0xc5, 0x62, 0x74, 0x52, 0x1d,
+			    0x45, 0x24, 0x6a, 0x42, 0x64, 0x4f, 0x97, 0x1c,
+			    0xa8, 0x66, 0xb5, 0x6d, 0x79, 0xd4, 0x0d, 0x48,
+			    0xc5, 0x5f, 0xf3, 0x90, 0x32, 0xdd, 0xdd, 0xe1,
+			    0xe4, 0xa9, 0x9f, 0xfc, 0xc3, 0x52, 0x5a, 0x46,
+			    0xe4, 0x81, 0x84, 0x95, 0x36, 0x59, 0x7a, 0x6b,
+			    0xaa, 0xb3, 0x60, 0xad, 0xce, 0x9f, 0x9f, 0x28,
+			    0xe0, 0x01, 0x75, 0x22, 0xc4, 0x4e, 0xa9, 0x62,
+			    0x5c, 0x62, 0x0d, 0x00, 0xcb, 0x13, 0xe8, 0x43,
+			    0x72, 0xd4, 0x2d, 0x53, 0x46, 0xb5, 0xd1, 0x16,
+			    0x22, 0x18, 0xdf, 0x34, 0x33, 0xf5, 0xd6, 0x1c,
+			    0xb8, 0x79, 0x78, 0x97, 0x94, 0xff, 0x72, 0x13,
+			    0x4c, 0x27, 0xfc, 0xcb, 0xbf, 0x01, 0x53, 0xa6,
+			    0xb4, 0x50, 0x6e, 0xde, 0xdf, 0xb5, 0x43, 0xa4,
+			    0x59, 0xdf, 0x52, 0xf9, 0x7c, 0xe0, 0x11, 0x6f,
+			    0x2d, 0x14, 0x8e, 0x24, 0x61, 0x2c, 0xe1, 0x17,
+			    0xcc, 0xce, 0x51, 0x0c, 0x19, 0x8a, 0x82, 0x30,
+			    0x94, 0xd5, 0x3d, 0x6a, 0x53, 0x06, 0x5e, 0xbd,
+			    0xb7, 0xeb, 0xfa, 0xfd, 0x27, 0x51, 0xde, 0x85,
+			    0x1e, 0x86, 0x53, 0x11, 0x53, 0x94, 0x00, 0xee,
+			    0x2b, 0x8c, 0x08, 0x2a, 0xbf, 0xdd, 0xae, 0x11,
+			    0xcb, 0x1e, 0xa2, 0x07, 0x9a, 0x80, 0xcf, 0x62,
+			    0x9b, 0x09, 0xdc, 0x95, 0x3c, 0x96, 0x8e, 0xb1,
+			    0x09, 0xbd, 0xe4, 0xeb, 0xdb, 0xca, 0x70, 0x7a,
+			    0x9e, 0xfa, 0x31, 0x18, 0x45, 0x3c, 0x21, 0x33,
+			    0xb0, 0xb3, 0x2b, 0xea, 0xf3, 0x71, 0x2d, 0xe1,
+			    0x03, 0xad, 0x1b, 0x48, 0xd4, 0x67, 0x27, 0xf0,
+			    0x62, 0xe4, 0x3d, 0xfb, 0x9b, 0x08, 0x76, 0xe7,
+			    0xdd, 0x2b, 0x01, 0x39, 0x04, 0x5a, 0x58, 0x7a,
+			    0xf7, 0x11, 0x90, 0xec, 0xbd, 0x51, 0x5c, 0x32,
+			    0x6b, 0xd7, 0x35, 0x39, 0x02, 0x6b, 0xf2, 0xa6,
+			    0xd0, 0x0d, 0x07, 0xe1, 0x06, 0xc4, 0x5b, 0x7d,
+			    0xe4, 0x6a, 0xd7, 0xee, 0x15, 0x1f, 0x83, 0xb4,
+			    0xa3, 0xa7, 0x5e, 0xc3, 0x90, 0xb7, 0xef, 0xd3,
+			    0xb7, 0x4f, 0xf8, 0x92, 0x4c, 0xb7, 0x3c, 0x29,
+			    0xcd, 0x7e, 0x2b, 0x5d, 0x43, 0xea, 0x42, 0xe7,
+			    0x74, 0x3f, 0x7d, 0x58, 0x88, 0x75, 0xde, 0x3e },
+		.ilen   = 512,
+		.result	= { 0x05, 0x11, 0xb7, 0x18, 0xab, 0xc6, 0x2d, 0xac,
+			    0x70, 0x5d, 0xf6, 0x22, 0x94, 0xcd, 0xe5, 0x6c,
+			    0x17, 0x6b, 0xf6, 0x1c, 0xf0, 0xf3, 0x6e, 0xf8,
+			    0x50, 0x38, 0x1f, 0x71, 0x49, 0xb6, 0x57, 0xd6,
+			    0x8f, 0xcb, 0x8d, 0x6b, 0xe3, 0xa6, 0x29, 0x90,
+			    0xfe, 0x2a, 0x62, 0x82, 0xae, 0x6d, 0x8b, 0xf6,
+			    0xad, 0x1e, 0x9e, 0x20, 0x5f, 0x38, 0xbe, 0x04,
+			    0xda, 0x10, 0x8e, 0xed, 0xa2, 0xa4, 0x87, 0xab,
+			    0xda, 0x6b, 0xb4, 0x0c, 0x75, 0xba, 0xd3, 0x7c,
+			    0xc9, 0xac, 0x42, 0x31, 0x95, 0x7c, 0xc9, 0x04,
+			    0xeb, 0xd5, 0x6e, 0x32, 0x69, 0x8a, 0xdb, 0xa6,
+			    0x15, 0xd7, 0x3f, 0x4f, 0x2f, 0x66, 0x69, 0x03,
+			    0x9c, 0x1f, 0x54, 0x0f, 0xde, 0x1f, 0xf3, 0x65,
+			    0x4c, 0x96, 0x12, 0xed, 0x7c, 0x92, 0x03, 0x01,
+			    0x6f, 0xbc, 0x35, 0x93, 0xac, 0xf1, 0x27, 0xf1,
+			    0xb4, 0x96, 0x82, 0x5a, 0x5f, 0xb0, 0xa0, 0x50,
+			    0x89, 0xa4, 0x8e, 0x66, 0x44, 0x85, 0xcc, 0xfd,
+			    0x33, 0x14, 0x70, 0xe3, 0x96, 0xb2, 0xc3, 0xd3,
+			    0xbb, 0x54, 0x5a, 0x1a, 0xf9, 0x74, 0xa2, 0xc5,
+			    0x2d, 0x64, 0x75, 0xdd, 0xb4, 0x54, 0xe6, 0x74,
+			    0x8c, 0xd3, 0x9d, 0x9e, 0x86, 0xab, 0x51, 0x53,
+			    0xb7, 0x93, 0x3e, 0x6f, 0xd0, 0x4e, 0x2c, 0x40,
+			    0xf6, 0xa8, 0x2e, 0x3e, 0x9d, 0xf4, 0x66, 0xa5,
+			    0x76, 0x12, 0x73, 0x44, 0x1a, 0x56, 0xd7, 0x72,
+			    0x88, 0xcd, 0x21, 0x8c, 0x4c, 0x0f, 0xfe, 0xda,
+			    0x95, 0xe0, 0x3a, 0xa6, 0xa5, 0x84, 0x46, 0xcd,
+			    0xd5, 0x3e, 0x9d, 0x3a, 0xe2, 0x67, 0xe6, 0x60,
+			    0x1a, 0xe2, 0x70, 0x85, 0x58, 0xc2, 0x1b, 0x09,
+			    0xe1, 0xd7, 0x2c, 0xca, 0xad, 0xa8, 0x8f, 0xf9,
+			    0xac, 0xb3, 0x0e, 0xdb, 0xca, 0x2e, 0xe2, 0xb8,
+			    0x51, 0x71, 0xd9, 0x3c, 0x6c, 0xf1, 0x56, 0xf8,
+			    0xea, 0x9c, 0xf1, 0xfb, 0x0c, 0xe6, 0xb7, 0x10,
+			    0x1c, 0xf8, 0xa9, 0x7c, 0xe8, 0x53, 0x35, 0xc1,
+			    0x90, 0x3e, 0x76, 0x4a, 0x74, 0xa4, 0x21, 0x2c,
+			    0xf6, 0x2c, 0x4e, 0x0f, 0x94, 0x3a, 0x88, 0x2e,
+			    0x41, 0x09, 0x6a, 0x33, 0x7d, 0xf6, 0xdd, 0x3f,
+			    0x8d, 0x23, 0x31, 0x74, 0x84, 0xeb, 0x88, 0x6e,
+			    0xcc, 0xb9, 0xbc, 0x22, 0x83, 0x19, 0x07, 0x22,
+			    0xa5, 0x2d, 0xdf, 0xa5, 0xf3, 0x80, 0x85, 0x78,
+			    0x84, 0x39, 0x6a, 0x6d, 0x6a, 0x99, 0x4f, 0xa5,
+			    0x15, 0xfe, 0x46, 0xb0, 0xe4, 0x6c, 0xa5, 0x41,
+			    0x3c, 0xce, 0x8f, 0x42, 0x60, 0x71, 0xa7, 0x75,
+			    0x08, 0x40, 0x65, 0x8a, 0x82, 0xbf, 0xf5, 0x43,
+			    0x71, 0x96, 0xa9, 0x4d, 0x44, 0x8a, 0x20, 0xbe,
+			    0xfa, 0x4d, 0xbb, 0xc0, 0x7d, 0x31, 0x96, 0x65,
+			    0xe7, 0x75, 0xe5, 0x3e, 0xfd, 0x92, 0x3b, 0xc9,
+			    0x55, 0xbb, 0x16, 0x7e, 0xf7, 0xc2, 0x8c, 0xa4,
+			    0x40, 0x1d, 0xe5, 0xef, 0x0e, 0xdf, 0xe4, 0x9a,
+			    0x62, 0x73, 0x65, 0xfd, 0x46, 0x63, 0x25, 0x3d,
+			    0x2b, 0xaf, 0xe5, 0x64, 0xfe, 0xa5, 0x5c, 0xcf,
+			    0x24, 0xf3, 0xb4, 0xac, 0x64, 0xba, 0xdf, 0x4b,
+			    0xc6, 0x96, 0x7d, 0x81, 0x2d, 0x8d, 0x97, 0xf7,
+			    0xc5, 0x68, 0x77, 0x84, 0x32, 0x2b, 0xcc, 0x85,
+			    0x74, 0x96, 0xf0, 0x12, 0x77, 0x61, 0xb9, 0xeb,
+			    0x71, 0xaa, 0x82, 0xcb, 0x1c, 0xdb, 0x89, 0xc8,
+			    0xc6, 0xb5, 0xe3, 0x5c, 0x7d, 0x39, 0x07, 0x24,
+			    0xda, 0x39, 0x87, 0x45, 0xc0, 0x2b, 0xbb, 0x01,
+			    0xac, 0xbc, 0x2a, 0x5c, 0x7f, 0xfc, 0xe8, 0xce,
+			    0x6d, 0x9c, 0x6f, 0xed, 0xd3, 0xc1, 0xa1, 0xd6,
+			    0xc5, 0x55, 0xa9, 0x66, 0x2f, 0xe1, 0xc8, 0x32,
+			    0xa6, 0x5d, 0xa4, 0x3a, 0x98, 0x73, 0xe8, 0x45,
+			    0xa4, 0xc7, 0xa8, 0xb4, 0xf6, 0x13, 0x03, 0xf6,
+			    0xe9, 0x2e, 0xc4, 0x29, 0x0f, 0x84, 0xdb, 0xc4,
+			    0x21, 0xc4, 0xc2, 0x75, 0x67, 0x89, 0x37, 0x0a },
+		.rlen   = 512,
+	}
+};
+
 /* Cast5 test vectors from RFC 2144 */
 #define CAST5_ENC_TEST_VECTORS	3
 #define CAST5_DEC_TEST_VECTORS	3
-- 
1.4.1.1


-- 
VGER BF report: U 0.497913
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060902110520</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-09-02 11:05:20-0400</timestampReceived><subject>[0/7] [CRYPTO]: Complete transition away from crypto_tfm</subject><body>

Hi:

This patch series finishes the conversion from crypto_tfm to typed
types such as crypto_cipher.

It also changes padlock-sha to use selection by type to locate the
fallback.

Last but not least there is an optimisation for generic CBC decryption.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt

-- 
VGER BF report: H 0.0426369
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060902110639</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-09-02 11:06:39-0400</timestampReceived><subject>[PATCH 1/7] [SCSI] iscsi: Use crypto_hash interface instead of crypto_digest</subject><body>

[SCSI] iscsi: Use crypto_hash interface instead of crypto_digest

This patch converts ISCSI to use the new crypto_hash interface instead
of crypto_digest.  It's a fairly straightforward substitution.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 drivers/scsi/iscsi_tcp.c |  134 +++++++++++++++++++++++++----------------------
 drivers/scsi/iscsi_tcp.h |    9 +--
 2 files changed, 78 insertions(+), 65 deletions(-)

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -26,6 +26,7 @@
  *	Zhenyu Wang
  */
 
+#include &lt;linux/err.h&gt;
 #include &lt;linux/types.h&gt;
 #include &lt;linux/list.h&gt;
 #include &lt;linux/inet.h&gt;
@@ -110,8 +111,11 @@ iscsi_hdr_digest(struct iscsi_conn *conn
 		 u8* crc)
 {
 	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct hash_desc desc;
 
-	crypto_digest_digest(tcp_conn-&gt;tx_tfm, &amp;buf-&gt;sg, 1, crc);
+	desc.tfm = tcp_conn-&gt;tx_tfm;
+	desc.flags = 0;
+	crypto_hash_digest(&amp;desc, &amp;buf-&gt;sg, buf-&gt;sg.length, crc);
 	buf-&gt;sg.length += sizeof(uint32_t);
 }
 
@@ -446,11 +450,14 @@ iscsi_tcp_hdr_recv(struct iscsi_conn *co
 	}
 
 	if (conn-&gt;hdrdgst_en) {
+		struct hash_desc desc;
 		struct scatterlist sg;
 
 		sg_init_one(&amp;sg, (u8 *)hdr,
 			    sizeof(struct iscsi_hdr) + ahslen);
-		crypto_digest_digest(tcp_conn-&gt;rx_tfm, &amp;sg, 1, (u8 *)&amp;cdgst);
+		desc.tfm = tcp_conn-&gt;rx_tfm;
+		desc.flags = 0;
+		crypto_hash_digest(&amp;desc, &amp;sg, sg.length, (u8 *)&amp;cdgst);
 		rdgst = *(uint32_t*)((char*)hdr + sizeof(struct iscsi_hdr) +
 				     ahslen);
 		if (cdgst != rdgst) {
@@ -650,7 +657,7 @@ partial_sg_digest_update(struct iscsi_tc
 	memcpy(&amp;temp, sg, sizeof(struct scatterlist));
 	temp.offset = offset;
 	temp.length = length;
-	crypto_digest_update(tcp_conn-&gt;data_rx_tfm, &amp;temp, 1);
+	crypto_hash_update(&amp;tcp_conn-&gt;data_rx_hash, &amp;temp, length);
 }
 
 static void
@@ -659,7 +666,7 @@ iscsi_recv_digest_update(struct iscsi_tc
 	struct scatterlist tmp;
 
 	sg_init_one(&amp;tmp, buf, len);
-	crypto_digest_update(tcp_conn-&gt;data_rx_tfm, &amp;tmp, 1);
+	crypto_hash_update(&amp;tcp_conn-&gt;data_rx_hash, &amp;tmp, len);
 }
 
 static int iscsi_scsi_data_in(struct iscsi_conn *conn)
@@ -713,9 +720,9 @@ static int iscsi_scsi_data_in(struct isc
 		if (!rc) {
 			if (conn-&gt;datadgst_en) {
 				if (!offset)
-					crypto_digest_update(
-							tcp_conn-&gt;data_rx_tfm,
-							&amp;sg[i], 1);
+					crypto_hash_update(
+							&amp;tcp_conn-&gt;data_rx_hash,
+							&amp;sg[i], sg[i].length);
 				else
 					partial_sg_digest_update(tcp_conn,
 							&amp;sg[i],
@@ -854,8 +861,7 @@ more:
 		rc = iscsi_tcp_hdr_recv(conn);
 		if (!rc &amp;&amp; tcp_conn-&gt;in.datalen) {
 			if (conn-&gt;datadgst_en) {
-				BUG_ON(!tcp_conn-&gt;data_rx_tfm);
-				crypto_digest_init(tcp_conn-&gt;data_rx_tfm);
+				crypto_hash_init(&amp;tcp_conn-&gt;data_rx_hash);
 			}
 			tcp_conn-&gt;in_progress = IN_PROGRESS_DATA_RECV;
 		} else if (rc) {
@@ -908,11 +914,11 @@ more:
 					  tcp_conn-&gt;in.padding);
 				memset(pad, 0, tcp_conn-&gt;in.padding);
 				sg_init_one(&amp;sg, pad, tcp_conn-&gt;in.padding);
-				crypto_digest_update(tcp_conn-&gt;data_rx_tfm,
-						     &amp;sg, 1);
+				crypto_hash_update(&amp;tcp_conn-&gt;data_rx_hash,
+						   &amp;sg, sg.length);
 			}
-			crypto_digest_final(tcp_conn-&gt;data_rx_tfm,
-					    (u8 *) &amp; tcp_conn-&gt;in.datadgst);
+			crypto_hash_final(&amp;tcp_conn-&gt;data_rx_hash,
+					  (u8 *)&amp;tcp_conn-&gt;in.datadgst);
 			debug_tcp("rx digest 0x%x\n", tcp_conn-&gt;in.datadgst);
 			tcp_conn-&gt;in_progress = IN_PROGRESS_DDIGEST_RECV;
 		} else
@@ -1159,8 +1165,7 @@ iscsi_data_digest_init(struct iscsi_tcp_
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 
-	BUG_ON(!tcp_conn-&gt;data_tx_tfm);
-	crypto_digest_init(tcp_conn-&gt;data_tx_tfm);
+	crypto_hash_init(&amp;tcp_conn-&gt;data_tx_hash);
 	tcp_ctask-&gt;digest_count = 4;
 }
 
@@ -1174,7 +1179,7 @@ iscsi_digest_final_send(struct iscsi_con
 	int sent = 0;
 
 	if (final)
-		crypto_digest_final(tcp_conn-&gt;data_tx_tfm, (u8*)digest);
+		crypto_hash_final(&amp;tcp_conn-&gt;data_tx_hash, (u8 *)digest);
 
 	iscsi_buf_init_iov(buf, (char*)digest, 4);
 	rc = iscsi_sendpage(conn, buf, &amp;tcp_ctask-&gt;digest_count, &amp;sent);
@@ -1469,16 +1474,17 @@ handle_xmstate_imm_data(struct iscsi_con
 		if (rc) {
 			tcp_ctask-&gt;xmstate |= XMSTATE_IMM_DATA;
 			if (conn-&gt;datadgst_en) {
-				crypto_digest_final(tcp_conn-&gt;data_tx_tfm,
-						(u8*)&amp;tcp_ctask-&gt;immdigest);
+				crypto_hash_final(&amp;tcp_conn-&gt;data_tx_hash,
+						  (u8 *)&amp;tcp_ctask-&gt;immdigest);
 				debug_tcp("tx imm sendpage fail 0x%x\n",
 					  tcp_ctask-&gt;datadigest);
 			}
 			return rc;
 		}
 		if (conn-&gt;datadgst_en)
-			crypto_digest_update(tcp_conn-&gt;data_tx_tfm,
-					     &amp;tcp_ctask-&gt;sendbuf.sg, 1);
+			crypto_hash_update(&amp;tcp_conn-&gt;data_tx_hash,
+					   &amp;tcp_ctask-&gt;sendbuf.sg,
+					   tcp_ctask-&gt;sendbuf.sg.length);
 
 		if (!ctask-&gt;imm_count)
 			break;
@@ -1555,8 +1561,8 @@ handle_xmstate_uns_data(struct iscsi_con
 			tcp_ctask-&gt;xmstate |= XMSTATE_UNS_DATA;
 			/* will continue with this ctask later.. */
 			if (conn-&gt;datadgst_en) {
-				crypto_digest_final(tcp_conn-&gt;data_tx_tfm,
-						(u8 *)&amp;dtask-&gt;digest);
+				crypto_hash_final(&amp;tcp_conn-&gt;data_tx_hash,
+						  (u8 *)&amp;dtask-&gt;digest);
 				debug_tcp("tx uns data fail 0x%x\n",
 					  dtask-&gt;digest);
 			}
@@ -1571,8 +1577,9 @@ handle_xmstate_uns_data(struct iscsi_con
 		 * so pass it
 		 */
 		if (conn-&gt;datadgst_en &amp;&amp; tcp_ctask-&gt;sent - start &gt; 0)
-			crypto_digest_update(tcp_conn-&gt;data_tx_tfm,
-					     &amp;tcp_ctask-&gt;sendbuf.sg, 1);
+			crypto_hash_update(&amp;tcp_conn-&gt;data_tx_hash,
+					   &amp;tcp_ctask-&gt;sendbuf.sg,
+					   tcp_ctask-&gt;sendbuf.sg.length);
 
 		if (!ctask-&gt;data_count)
 			break;
@@ -1646,7 +1653,7 @@ solicit_again:
 		tcp_ctask-&gt;xmstate |= XMSTATE_SOL_DATA;
 		/* will continue with this ctask later.. */
 		if (conn-&gt;datadgst_en) {
-			crypto_digest_final(tcp_conn-&gt;data_tx_tfm,
+			crypto_hash_final(&amp;tcp_conn-&gt;data_tx_hash,
 					  (u8 *)&amp;dtask-&gt;digest);
 			debug_tcp("r2t data send fail 0x%x\n", dtask-&gt;digest);
 		}
@@ -1655,8 +1662,8 @@ solicit_again:
 
 	BUG_ON(r2t-&gt;data_count &lt; 0);
 	if (conn-&gt;datadgst_en)
-		crypto_digest_update(tcp_conn-&gt;data_tx_tfm, &amp;r2t-&gt;sendbuf.sg,
-				     1);
+		crypto_hash_update(&amp;tcp_conn-&gt;data_tx_hash, &amp;r2t-&gt;sendbuf.sg,
+				   r2t-&gt;sendbuf.sg.length);
 
 	if (r2t-&gt;data_count) {
 		BUG_ON(ctask-&gt;sc-&gt;use_sg == 0);
@@ -1744,8 +1751,9 @@ handle_xmstate_w_pad(struct iscsi_conn *
 	}
 
 	if (conn-&gt;datadgst_en) {
-		crypto_digest_update(tcp_conn-&gt;data_tx_tfm,
-				     &amp;tcp_ctask-&gt;sendbuf.sg, 1);
+		crypto_hash_update(&amp;tcp_conn-&gt;data_tx_hash,
+				   &amp;tcp_ctask-&gt;sendbuf.sg,
+				   tcp_ctask-&gt;sendbuf.sg.length);
 		/* imm data? */
 		if (!dtask) {
 			rc = iscsi_digest_final_send(conn, ctask,
@@ -1935,13 +1943,13 @@ iscsi_tcp_conn_destroy(struct iscsi_cls_
 	/* now free tcp_conn */
 	if (digest) {
 		if (tcp_conn-&gt;tx_tfm)
-			crypto_free_tfm(tcp_conn-&gt;tx_tfm);
+			crypto_free_hash(tcp_conn-&gt;tx_tfm);
 		if (tcp_conn-&gt;rx_tfm)
-			crypto_free_tfm(tcp_conn-&gt;rx_tfm);
-		if (tcp_conn-&gt;data_tx_tfm)
-			crypto_free_tfm(tcp_conn-&gt;data_tx_tfm);
-		if (tcp_conn-&gt;data_rx_tfm)
-			crypto_free_tfm(tcp_conn-&gt;data_rx_tfm);
+			crypto_free_hash(tcp_conn-&gt;rx_tfm);
+		if (tcp_conn-&gt;data_tx_hash.tfm)
+			crypto_free_hash(tcp_conn-&gt;data_tx_hash.tfm);
+		if (tcp_conn-&gt;data_rx_hash.tfm)
+			crypto_free_hash(tcp_conn-&gt;data_rx_hash.tfm);
 	}
 
 	/* free conn-&gt;data, size = MaxRecvDataSegmentLength */
@@ -2177,44 +2185,48 @@ iscsi_conn_set_param(struct iscsi_cls_co
 		if (conn-&gt;hdrdgst_en) {
 			tcp_conn-&gt;hdr_size += sizeof(__u32);
 			if (!tcp_conn-&gt;tx_tfm)
-				tcp_conn-&gt;tx_tfm = crypto_alloc_tfm("crc32c",
-								    0);
-			if (!tcp_conn-&gt;tx_tfm)
-				return -ENOMEM;
+				tcp_conn-&gt;tx_tfm =
+					crypto_alloc_hash("crc32c", 0,
+							  CRYPTO_ALG_ASYNC);
+			if (IS_ERR(tcp_conn-&gt;tx_tfm))
+				return PTR_ERR(tcp_conn-&gt;tx_tfm);
 			if (!tcp_conn-&gt;rx_tfm)
-				tcp_conn-&gt;rx_tfm = crypto_alloc_tfm("crc32c",
-								    0);
-			if (!tcp_conn-&gt;rx_tfm) {
-				crypto_free_tfm(tcp_conn-&gt;tx_tfm);
-				return -ENOMEM;
+				tcp_conn-&gt;rx_tfm =
+					crypto_alloc_hash("crc32c", 0,
+							  CRYPTO_ALG_ASYNC);
+			if (IS_ERR(tcp_conn-&gt;rx_tfm)) {
+				crypto_free_hash(tcp_conn-&gt;tx_tfm);
+				return PTR_ERR(tcp_conn-&gt;rx_tfm);
 			}
 		} else {
 			if (tcp_conn-&gt;tx_tfm)
-				crypto_free_tfm(tcp_conn-&gt;tx_tfm);
+				crypto_free_hash(tcp_conn-&gt;tx_tfm);
 			if (tcp_conn-&gt;rx_tfm)
-				crypto_free_tfm(tcp_conn-&gt;rx_tfm);
+				crypto_free_hash(tcp_conn-&gt;rx_tfm);
 		}
 		break;
 	case ISCSI_PARAM_DATADGST_EN:
 		iscsi_set_param(cls_conn, param, buf, buflen);
 		if (conn-&gt;datadgst_en) {
-			if (!tcp_conn-&gt;data_tx_tfm)
-				tcp_conn-&gt;data_tx_tfm =
-				    crypto_alloc_tfm("crc32c", 0);
-			if (!tcp_conn-&gt;data_tx_tfm)
-				return -ENOMEM;
-			if (!tcp_conn-&gt;data_rx_tfm)
-				tcp_conn-&gt;data_rx_tfm =
-				    crypto_alloc_tfm("crc32c", 0);
-			if (!tcp_conn-&gt;data_rx_tfm) {
-				crypto_free_tfm(tcp_conn-&gt;data_tx_tfm);
-				return -ENOMEM;
+			if (!tcp_conn-&gt;data_tx_hash.tfm)
+				tcp_conn-&gt;data_tx_hash.tfm =
+				    crypto_alloc_hash("crc32c", 0,
+						      CRYPTO_ALG_ASYNC);
+			if (IS_ERR(tcp_conn-&gt;data_tx_hash.tfm))
+				return PTR_ERR(tcp_conn-&gt;data_tx_hash.tfm);
+			if (!tcp_conn-&gt;data_rx_hash.tfm)
+				tcp_conn-&gt;data_rx_hash.tfm =
+				    crypto_alloc_hash("crc32c", 0,
+						      CRYPTO_ALG_ASYNC);
+			if (IS_ERR(tcp_conn-&gt;data_rx_hash.tfm)) {
+				crypto_free_hash(tcp_conn-&gt;data_tx_hash.tfm);
+				return PTR_ERR(tcp_conn-&gt;data_rx_hash.tfm);
 			}
 		} else {
-			if (tcp_conn-&gt;data_tx_tfm)
-				crypto_free_tfm(tcp_conn-&gt;data_tx_tfm);
-			if (tcp_conn-&gt;data_rx_tfm)
-				crypto_free_tfm(tcp_conn-&gt;data_rx_tfm);
+			if (tcp_conn-&gt;data_tx_hash.tfm)
+				crypto_free_hash(tcp_conn-&gt;data_tx_hash.tfm);
+			if (tcp_conn-&gt;data_rx_hash.tfm)
+				crypto_free_hash(tcp_conn-&gt;data_rx_hash.tfm);
 		}
 		tcp_conn-&gt;sendpage = conn-&gt;datadgst_en ?
 			sock_no_sendpage : tcp_conn-&gt;sock-&gt;ops-&gt;sendpage;
diff --git a/drivers/scsi/iscsi_tcp.h b/drivers/scsi/iscsi_tcp.h
--- a/drivers/scsi/iscsi_tcp.h
+++ b/drivers/scsi/iscsi_tcp.h
@@ -51,6 +51,7 @@
 #define ISCSI_SG_TABLESIZE		SG_ALL
 #define ISCSI_TCP_MAX_CMD_LEN		16
 
+struct crypto_hash;
 struct socket;
 
 /* Socket connection recieve helper */
@@ -86,8 +87,8 @@ struct iscsi_tcp_conn {
 	/* iSCSI connection-wide sequencing */
 	int			hdr_size;	/* PDU header size */
 
-	struct crypto_tfm	*rx_tfm;	/* CRC32C (Rx) */
-	struct crypto_tfm	*data_rx_tfm;	/* CRC32C (Rx) for data */
+	struct crypto_hash	*rx_tfm;	/* CRC32C (Rx) */
+	struct hash_desc	data_rx_hash;	/* CRC32C (Rx) for data */
 
 	/* control data */
 	struct iscsi_tcp_recv	in;		/* TCP receive context */
@@ -99,8 +100,8 @@ struct iscsi_tcp_conn {
 	void			(*old_write_space)(struct sock *);
 
 	/* xmit */
-	struct crypto_tfm	*tx_tfm;	/* CRC32C (Tx) */
-	struct crypto_tfm	*data_tx_tfm;	/* CRC32C (Tx) for data */
+	struct crypto_hash	*tx_tfm;	/* CRC32C (Tx) */
+	struct hash_desc	data_tx_hash;	/* CRC32C (Tx) for data */
 
 	/* MIB custom statistics */
 	uint32_t		sendpage_failures_cnt;

-- 
VGER BF report: H 0.0915141
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060902110648</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-09-02 11:06:48-0400</timestampReceived><subject>[PATCH 2/7] [CRYPTO] users: Use crypto_hash interface instead of crypto_digest</subject><body>

[CRYPTO] users: Use crypto_hash interface instead of crypto_digest

This patch converts all remaining crypto_digest users to use the new
crypto_hash interface.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 drivers/md/dm-crypt.c                 |   30 ++++++++++++++------------
 drivers/net/ppp_mppe.c                |   34 +++++++++++++++++++-----------
 fs/nfsd/nfs4recover.c                 |   21 +++++++++---------
 net/ieee80211/ieee80211_crypt_tkip.c  |   25 ++++++++++++----------
 net/sunrpc/auth_gss/gss_krb5_crypto.c |   38 +++++++++++++++++++++-------------
 security/seclvl.c                     |   18 ++++++++--------
 6 files changed, 97 insertions(+), 69 deletions(-)

diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@ -122,7 +122,8 @@ static int crypt_iv_essiv_ctr(struct cry
 	                      const char *opts)
 {
 	struct crypto_cipher *essiv_tfm;
-	struct crypto_tfm *hash_tfm;
+	struct crypto_hash *hash_tfm;
+	struct hash_desc desc;
 	struct scatterlist sg;
 	unsigned int saltsize;
 	u8 *salt;
@@ -134,29 +135,30 @@ static int crypt_iv_essiv_ctr(struct cry
 	}
 
 	/* Hash the cipher key with the given hash algorithm */
-	hash_tfm = crypto_alloc_tfm(opts, CRYPTO_TFM_REQ_MAY_SLEEP);
-	if (hash_tfm == NULL) {
+	hash_tfm = crypto_alloc_hash(opts, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(hash_tfm)) {
 		ti-&gt;error = "Error initializing ESSIV hash";
-		return -EINVAL;
-	}
-
-	if (crypto_tfm_alg_type(hash_tfm) != CRYPTO_ALG_TYPE_DIGEST) {
-		ti-&gt;error = "Expected digest algorithm for ESSIV hash";
-		crypto_free_tfm(hash_tfm);
-		return -EINVAL;
+		return PTR_ERR(hash_tfm);
 	}
 
-	saltsize = crypto_tfm_alg_digestsize(hash_tfm);
+	saltsize = crypto_hash_digestsize(hash_tfm);
 	salt = kmalloc(saltsize, GFP_KERNEL);
 	if (salt == NULL) {
 		ti-&gt;error = "Error kmallocing salt storage in ESSIV";
-		crypto_free_tfm(hash_tfm);
+		crypto_free_hash(hash_tfm);
 		return -ENOMEM;
 	}
 
 	sg_set_buf(&amp;sg, cc-&gt;key, cc-&gt;key_size);
-	crypto_digest_digest(hash_tfm, &amp;sg, 1, salt);
-	crypto_free_tfm(hash_tfm);
+	desc.tfm = hash_tfm;
+	desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;
+	err = crypto_hash_digest(&amp;desc, &amp;sg, cc-&gt;key_size, salt);
+	crypto_free_hash(hash_tfm);
+
+	if (err) {
+		ti-&gt;error = "Error calculating hash in ESSIV";
+		return err;
+	}
 
 	/* Setup the essiv_tfm with the given salt */
 	essiv_tfm = crypto_alloc_cipher(cc-&gt;cipher, 0, CRYPTO_ALG_ASYNC);
diff --git a/drivers/net/ppp_mppe.c b/drivers/net/ppp_mppe.c
--- a/drivers/net/ppp_mppe.c
+++ b/drivers/net/ppp_mppe.c
@@ -65,12 +65,13 @@ MODULE_LICENSE("Dual BSD/GPL");
 MODULE_ALIAS("ppp-compress-" __stringify(CI_MPPE));
 MODULE_VERSION("1.0.2");
 
-static void
+static unsigned int
 setup_sg(struct scatterlist *sg, const void *address, unsigned int length)
 {
 	sg[0].page = virt_to_page(address);
 	sg[0].offset = offset_in_page(address);
 	sg[0].length = length;
+	return length;
 }
 
 #define SHA1_PAD_SIZE 40
@@ -97,7 +98,7 @@ static inline void sha_pad_init(struct s
  */
 struct ppp_mppe_state {
 	struct crypto_blkcipher *arc4;
-	struct crypto_tfm *sha1;
+	struct crypto_hash *sha1;
 	unsigned char *sha1_digest;
 	unsigned char master_key[MPPE_MAX_KEY_LEN];
 	unsigned char session_key[MPPE_MAX_KEY_LEN];
@@ -137,14 +138,21 @@ struct ppp_mppe_state {
  */
 static void get_new_key_from_sha(struct ppp_mppe_state * state, unsigned char *InterimKey)
 {
+	struct hash_desc desc;
 	struct scatterlist sg[4];
+	unsigned int nbytes;
 
-	setup_sg(&amp;sg[0], state-&gt;master_key, state-&gt;keylen);
-	setup_sg(&amp;sg[1], sha_pad-&gt;sha_pad1, sizeof(sha_pad-&gt;sha_pad1));
-	setup_sg(&amp;sg[2], state-&gt;session_key, state-&gt;keylen);
-	setup_sg(&amp;sg[3], sha_pad-&gt;sha_pad2, sizeof(sha_pad-&gt;sha_pad2));
+	nbytes = setup_sg(&amp;sg[0], state-&gt;master_key, state-&gt;keylen);
+	nbytes += setup_sg(&amp;sg[1], sha_pad-&gt;sha_pad1,
+			   sizeof(sha_pad-&gt;sha_pad1));
+	nbytes += setup_sg(&amp;sg[2], state-&gt;session_key, state-&gt;keylen);
+	nbytes += setup_sg(&amp;sg[3], sha_pad-&gt;sha_pad2,
+			   sizeof(sha_pad-&gt;sha_pad2));
 
-	crypto_digest_digest (state-&gt;sha1, sg, 4, state-&gt;sha1_digest);
+	desc.tfm = state-&gt;sha1;
+	desc.flags = 0;
+
+	crypto_hash_digest(&amp;desc, sg, nbytes, state-&gt;sha1_digest);
 
 	memcpy(InterimKey, state-&gt;sha1_digest, state-&gt;keylen);
 }
@@ -204,11 +212,13 @@ static void *mppe_alloc(unsigned char *o
 		goto out_free;
 	}
 
-	state-&gt;sha1 = crypto_alloc_tfm("sha1", 0);
-	if (!state-&gt;sha1)
+	state-&gt;sha1 = crypto_alloc_hash("sha1", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(state-&gt;sha1)) {
+		state-&gt;sha1 = NULL;
 		goto out_free;
+	}
 
-	digestsize = crypto_tfm_alg_digestsize(state-&gt;sha1);
+	digestsize = crypto_hash_digestsize(state-&gt;sha1);
 	if (digestsize &lt; MPPE_MAX_KEY_LEN)
 		goto out_free;
 
@@ -233,7 +243,7 @@ static void *mppe_alloc(unsigned char *o
 	    if (state-&gt;sha1_digest)
 		kfree(state-&gt;sha1_digest);
 	    if (state-&gt;sha1)
-		crypto_free_tfm(state-&gt;sha1);
+		crypto_free_hash(state-&gt;sha1);
 	    if (state-&gt;arc4)
 		crypto_free_blkcipher(state-&gt;arc4);
 	    kfree(state);
@@ -251,7 +261,7 @@ static void mppe_free(void *arg)
 	    if (state-&gt;sha1_digest)
 		kfree(state-&gt;sha1_digest);
 	    if (state-&gt;sha1)
-		crypto_free_tfm(state-&gt;sha1);
+		crypto_free_hash(state-&gt;sha1);
 	    if (state-&gt;arc4)
 		crypto_free_blkcipher(state-&gt;arc4);
 	    kfree(state);
diff --git a/fs/nfsd/nfs4recover.c b/fs/nfsd/nfs4recover.c
--- a/fs/nfsd/nfs4recover.c
+++ b/fs/nfsd/nfs4recover.c
@@ -33,7 +33,7 @@
 *
 */
 
-
+#include &lt;linux/err.h&gt;
 #include &lt;linux/sunrpc/svc.h&gt;
 #include &lt;linux/nfsd/nfsd.h&gt;
 #include &lt;linux/nfs4.h&gt;
@@ -87,34 +87,35 @@ int
 nfs4_make_rec_clidname(char *dname, struct xdr_netobj *clname)
 {
 	struct xdr_netobj cksum;
-	struct crypto_tfm *tfm;
+	struct hash_desc desc;
 	struct scatterlist sg[1];
 	int status = nfserr_resource;
 
 	dprintk("NFSD: nfs4_make_rec_clidname for %.*s\n",
 			clname-&gt;len, clname-&gt;data);
-	tfm = crypto_alloc_tfm("md5", CRYPTO_TFM_REQ_MAY_SLEEP);
-	if (tfm == NULL)
-		goto out;
-	cksum.len = crypto_tfm_alg_digestsize(tfm);
+	desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;
+	desc.tfm = crypto_alloc_hash("md5", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(desc.tfm))
+		goto out_no_tfm;
+	cksum.len = crypto_hash_digestsize(desc.tfm);
 	cksum.data = kmalloc(cksum.len, GFP_KERNEL);
 	if (cksum.data == NULL)
  		goto out;
-	crypto_digest_init(tfm);
 
 	sg[0].page = virt_to_page(clname-&gt;data);
 	sg[0].offset = offset_in_page(clname-&gt;data);
 	sg[0].length = clname-&gt;len;
 
-	crypto_digest_update(tfm, sg, 1);
-	crypto_digest_final(tfm, cksum.data);
+	if (crypto_hash_digest(&amp;desc, sg, sg-&gt;length, cksum.data))
+		goto out;
 
 	md5_to_hex(dname, cksum.data);
 
 	kfree(cksum.data);
 	status = nfs_ok;
 out:
-	crypto_free_tfm(tfm);
+	crypto_free_hash(desc.tfm);
+out_no_tfm:
 	return status;
 }
 
diff --git a/net/ieee80211/ieee80211_crypt_tkip.c b/net/ieee80211/ieee80211_crypt_tkip.c
--- a/net/ieee80211/ieee80211_crypt_tkip.c
+++ b/net/ieee80211/ieee80211_crypt_tkip.c
@@ -54,7 +54,7 @@ struct ieee80211_tkip_data {
 	int key_idx;
 
 	struct crypto_blkcipher *tfm_arc4;
-	struct crypto_tfm *tfm_michael;
+	struct crypto_hash *tfm_michael;
 
 	/* scratch buffers for virt_to_page() (crypto API) */
 	u8 rx_hdr[16], tx_hdr[16];
@@ -95,10 +95,12 @@ static void *ieee80211_tkip_init(int key
 		goto fail;
 	}
 
-	priv-&gt;tfm_michael = crypto_alloc_tfm("michael_mic", 0);
-	if (priv-&gt;tfm_michael == NULL) {
+	priv-&gt;tfm_michael = crypto_alloc_hash("michael_mic", 0,
+					      CRYPTO_ALG_ASYNC);
+	if (IS_ERR(priv-&gt;tfm_michael)) {
 		printk(KERN_DEBUG "ieee80211_crypt_tkip: could not allocate "
 		       "crypto API michael_mic\n");
+		priv-&gt;tfm_michael = NULL;
 		goto fail;
 	}
 
@@ -107,7 +109,7 @@ static void *ieee80211_tkip_init(int key
       fail:
 	if (priv) {
 		if (priv-&gt;tfm_michael)
-			crypto_free_tfm(priv-&gt;tfm_michael);
+			crypto_free_hash(priv-&gt;tfm_michael);
 		if (priv-&gt;tfm_arc4)
 			crypto_free_blkcipher(priv-&gt;tfm_arc4);
 		kfree(priv);
@@ -120,7 +122,7 @@ static void ieee80211_tkip_deinit(void *
 {
 	struct ieee80211_tkip_data *_priv = priv;
 	if (_priv &amp;&amp; _priv-&gt;tfm_michael)
-		crypto_free_tfm(_priv-&gt;tfm_michael);
+		crypto_free_hash(_priv-&gt;tfm_michael);
 	if (_priv &amp;&amp; _priv-&gt;tfm_arc4)
 		crypto_free_blkcipher(_priv-&gt;tfm_arc4);
 	kfree(priv);
@@ -485,6 +487,7 @@ static int ieee80211_tkip_decrypt(struct
 static int michael_mic(struct ieee80211_tkip_data *tkey, u8 * key, u8 * hdr,
 		       u8 * data, size_t data_len, u8 * mic)
 {
+	struct hash_desc desc;
 	struct scatterlist sg[2];
 
 	if (tkey-&gt;tfm_michael == NULL) {
@@ -499,12 +502,12 @@ static int michael_mic(struct ieee80211_
 	sg[1].offset = offset_in_page(data);
 	sg[1].length = data_len;
 
-	crypto_digest_init(tkey-&gt;tfm_michael);
-	crypto_digest_setkey(tkey-&gt;tfm_michael, key, 8);
-	crypto_digest_update(tkey-&gt;tfm_michael, sg, 2);
-	crypto_digest_final(tkey-&gt;tfm_michael, mic);
+	if (crypto_hash_setkey(tkey-&gt;tfm_michael, key, 8))
+		return -1;
 
-	return 0;
+	desc.tfm = tkey-&gt;tfm_michael;
+	desc.flags = 0;
+	return crypto_hash_digest(&amp;desc, sg, data_len + 16, mic);
 }
 
 static void michael_mic_hdr(struct sk_buff *skb, u8 * hdr)
@@ -628,7 +631,7 @@ static int ieee80211_tkip_set_key(void *
 {
 	struct ieee80211_tkip_data *tkey = priv;
 	int keyidx;
-	struct crypto_tfm *tfm = tkey-&gt;tfm_michael;
+	struct crypto_hash *tfm = tkey-&gt;tfm_michael;
 	struct crypto_blkcipher *tfm2 = tkey-&gt;tfm_arc4;
 
 	keyidx = tkey-&gt;key_idx;
diff --git a/net/sunrpc/auth_gss/gss_krb5_crypto.c b/net/sunrpc/auth_gss/gss_krb5_crypto.c
--- a/net/sunrpc/auth_gss/gss_krb5_crypto.c
+++ b/net/sunrpc/auth_gss/gss_krb5_crypto.c
@@ -34,6 +34,7 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
+#include &lt;linux/err.h&gt;
 #include &lt;linux/types.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/slab.h&gt;
@@ -199,11 +200,9 @@ out:
 static int
 checksummer(struct scatterlist *sg, void *data)
 {
-	struct crypto_tfm *tfm = (struct crypto_tfm *)data;
+	struct hash_desc *desc = data;
 
-	crypto_digest_update(tfm, sg, 1);
-
-	return 0;
+	return crypto_hash_update(desc, sg, sg-&gt;length);
 }
 
 /* checksum the plaintext data and hdrlen bytes of the token header */
@@ -212,8 +211,9 @@ make_checksum(s32 cksumtype, char *heade
 		   int body_offset, struct xdr_netobj *cksum)
 {
 	char                            *cksumname;
-	struct crypto_tfm               *tfm = NULL; /* XXX add to ctx? */
+	struct hash_desc                desc; /* XXX add to ctx? */
 	struct scatterlist              sg[1];
+	int err;
 
 	switch (cksumtype) {
 		case CKSUMTYPE_RSA_MD5:
@@ -224,18 +224,28 @@ make_checksum(s32 cksumtype, char *heade
 				" unsupported checksum %d", cksumtype);
 			return GSS_S_FAILURE;
 	}
-	if (!(tfm = crypto_alloc_tfm(cksumname, CRYPTO_TFM_REQ_MAY_SLEEP)))
+	desc.tfm = crypto_alloc_hash(cksumname, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(desc.tfm))
 		return GSS_S_FAILURE;
-	cksum-&gt;len = crypto_tfm_alg_digestsize(tfm);
+	cksum-&gt;len = crypto_hash_digestsize(desc.tfm);
+	desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;
 
-	crypto_digest_init(tfm);
+	err = crypto_hash_init(&amp;desc);
+	if (err)
+		goto out;
 	sg_set_buf(sg, header, hdrlen);
-	crypto_digest_update(tfm, sg, 1);
-	process_xdr_buf(body, body_offset, body-&gt;len - body_offset,
-			checksummer, tfm);
-	crypto_digest_final(tfm, cksum-&gt;data);
-	crypto_free_tfm(tfm);
-	return 0;
+	err = crypto_hash_update(&amp;desc, sg, hdrlen);
+	if (err)
+		goto out;
+	err = process_xdr_buf(body, body_offset, body-&gt;len - body_offset,
+			      checksummer, &amp;desc);
+	if (err)
+		goto out;
+	err = crypto_hash_final(&amp;desc, cksum-&gt;data);
+
+out:
+	crypto_free_hash(desc.tfm);
+	return err ? GSS_S_FAILURE : 0;
 }
 
 EXPORT_SYMBOL(make_checksum);
diff --git a/security/seclvl.c b/security/seclvl.c
--- a/security/seclvl.c
+++ b/security/seclvl.c
@@ -16,6 +16,7 @@
  *	(at your option) any later version.
  */
 
+#include &lt;linux/err.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/moduleparam.h&gt;
 #include &lt;linux/kernel.h&gt;
@@ -197,26 +198,27 @@ static unsigned char hashedPassword[SHA1
 static int
 plaintext_to_sha1(unsigned char *hash, const char *plaintext, unsigned int len)
 {
-	struct crypto_tfm *tfm;
+	struct hash_desc desc;
 	struct scatterlist sg;
+	int err;
+
 	if (len &gt; PAGE_SIZE) {
 		seclvl_printk(0, KERN_ERR, "Plaintext password too large (%d "
 			      "characters).  Largest possible is %lu "
 			      "bytes.\n", len, PAGE_SIZE);
 		return -EINVAL;
 	}
-	tfm = crypto_alloc_tfm("sha1", CRYPTO_TFM_REQ_MAY_SLEEP);
-	if (tfm == NULL) {
+	desc.tfm = crypto_alloc_hash("sha1", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(desc.tfm)) {
 		seclvl_printk(0, KERN_ERR,
 			      "Failed to load transform for SHA1\n");
 		return -EINVAL;
 	}
 	sg_init_one(&amp;sg, (u8 *)plaintext, len);
-	crypto_digest_init(tfm);
-	crypto_digest_update(tfm, &amp;sg, 1);
-	crypto_digest_final(tfm, hash);
-	crypto_free_tfm(tfm);
-	return 0;
+	desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;
+	err = crypto_hash_digest(&amp;desc, &amp;sg, len, hash);
+	crypto_free_hash(desc.tfm);
+	return err;
 }
 
 /**

-- 
VGER BF report: H 1.55961e-11
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060914092506</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-09-14 09:25:06-0400</timestampReceived><subject>firefox is up/downloading something unauthorized-- logfiles non-proxy-use</subject><body>

Yes, I know that this forum is about crypto-stuff, but those who are using strong \
encryption should be very careful about what is happening when their data is clear.-

Situation: 
My (new) router needs javascript and preferes Mozilla, so I installed firefox with \
bad feelings. Privoxy-proxy was disabled in firefox and it was used only for that \
crappy router. All configurable settings EXPLICITLY DISALLOW any updating (ask what \
to do, instead) and, of course, the startpage was that from the router, not from \
mozilla.

When fighting with shitty-xine, suddenly and without any question, firefox fetched or
transfered something to or from the internet and a short message said something from
"upgrading". Because the local-proxy was disabled for the local router, no log was \
used. This is especially suspicious, because I just made all updates for my subdistri \
short ago.

I am deinstalling firefox now, as I can make a router-workaround in konqueror.

Another warning about user-agent-transmitting in Netscape clones:

I realized years ago in netscape 4.7-or-so, that deleting the user-agent-string
somewhere in netscape really forbid the transmission of the user-agent in normal-use,
but when a ssl-request is initiated from the webside another user-agent from another
netscape-program-location is transmitting the user-agent-string !
After searching and deleting that second user-agent-string with hexedit, that \
rat-hole was filled; this still maybe the case today.

How did I checked the transmission of user-agent-string via ssl ?
I made an email-account at safe-mail.net and looked in the log-area of my own \
last-login.

Ideas of making a logfile for, at least, all that is send via what-ever-protocol \
towards the internet ????

Even debian is not free of shitware......

      stay aware, stay awake, stay alive,           Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060917103934</emailId><senderName>Matthias Teege</senderName><senderEmail>matthias-lcr@mteege.de</senderEmail><timestampReceived>2006-09-17 10:39:34-0400</timestampReceived><subject>boot from LVM2 device on loop-aes</subject><body>

Moin,

I've created some LVM2 volumes on a loop-aes device which works
great. I put

mkdir /stick
mount -r -t vfat /dev/sdb4 /stick
losetup -e AES256 -K /stick/key.gpg /dev/loop0 /dev/sda3

in my initrd.scripts before the vgscan/vgchange commands but the
losetup in busybox doesn't understand all commandline switches.

Is it possible to boot from an LVM2 volume on top of loopaes? How
do I setup it correct?

Many thanks
Matthias


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060915083722</emailId><senderName>Jens Lechtenboerger</senderName><senderEmail>lechten@wi.uni-muenster.de</senderEmail><timestampReceived>2006-09-15 08:37:22-0400</timestampReceived><subject>Disk encryption best practices?</subject><body>

Hi there,

I'm about to encrypt my disk with loop-aes, and I'm wondering
whether this is a clever move:

1. The introduction (in German) at
   http://wiki.chaostreff.ch/index.php/Festplattenverschl%C3%BCsselung
   recommends not to use AES but to prefer Twofish.
   In addition, GnuPG uses CAST5 as default for symmetric
   encryption.

   What is the state-of-the-art here?

2. The text at http://mareichelt.de/pub/texts.cryptoloop.php
   warns against mainline cryptoloop:
   "Both cryptoloop and dm-crypt in kernels prior to 2.6.10 are
    vulnerable, and even recent dm-crypt still suffers from a weak
    crypto implementation."

   What is weak here?

3. The German Linux-Magazin 10/06 (http://www.linux-magazin.de)
   features an article by Peter Gutmann and Christian Ney, where
   they analyze different types of crypto filesystems.  They
   recommend Truecrypt, dm-crypt is second, and they essentially
   warn against loop-aes:
   They state that the code is complex and written in such a way
   that it is difficult to judge whether it does what it is supposed
   to do.  In addition, return values are never checked (e.g., when
   computing encryption keys), which might lead to a key consisting
   of just zeros.  However, the code is so sloppy that programs are
   more likely to crash with null-pointer dereferences than to use
   empty keys.  Besides, they complain that by default passwords are
   not salted and password hash iterations are not used.

   The part about code quality sounds scary.  Opinions?

   Concerning salting and iterations, for my root partition, I just
   have to uncomment to lines in build-initrd.sh, right?
   Concerning Example 2 in the loop-aes README (partition backed
   loop with gpg encrypted keys), I get salting and iterations with
   the gpg patch provided with loop-aes, right?

I'm curious...

Jens

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060926110541</emailId><senderName>Eric Sesterhenn</senderName><senderEmail>snakebyte@gmx.de</senderEmail><timestampReceived>2006-09-26 11:05:41-0400</timestampReceived><subject>Dead code in crypto/tcrypt.c</subject><body>

hi,

the following commit added some code in test_hash_cycles() which coverity flags as \
dead code. http://www.kernel.org/git/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=e9d41164e2fdd897fe4520c2079ea0000f6e0ec3


The culprit are the following lines:


	for (i = 0; i &lt; 4; i++) {
- 		crypto_digest_init(tfm);
+ 		ret = crypto_hash_init(desc);
+ 		if (ret)
+ 			goto out;
		for (pcount = 0; pcount &lt; blen; pcount += plen) {
			sg_set_buf(sg, p + pcount, plen);
- 			crypto_digest_update(tfm, sg, 1);
+ 			ret = crypto_hash_update(desc, sg, plen);
+ 			if (ret)
+ 				goto out;
		}
- 		crypto_digest_final(tfm, out);
+ 		crypto_hash_final(desc, out);
+ 		if (ret)
+ 			goto out;
	}

We check ret before the for loop, and inside it, and
there is no way it can change in between. Are we missing
to assign the return value of crypto_hash_final() to ret?

Greetings, Eric

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


</body></email><email><emailId>20060927193147</emailId><senderName>"Jordan Crouse"</senderName><senderEmail>jordan.crouse@amd.com</senderEmail><timestampReceived>2006-09-27 19:31:47-0400</timestampReceived><subject>[RFC] crypto: Add support for the Geode AES engine</subject><body>

Hey all -

I've had a poor excuse for a crypto driver for the Geode LX AES hardware
sitting in my Geode GIT tree (and -mm) for some time now.  I sent out the 
original version some time ago (June) and I got some very smart 
recommendations for changes, but other events transpired, and I didn't do 
a very good job of following up.

So now, in the interest of getting this out of everybody's hair and on
the path to mainstreaming, I'm sending out a newly updated version of the 
driver for comments.  This should be fully updated for all the new API
changes in the crypto GIT tree.  Once this is acceptable, I would like to get
this pulled into the crypto tree.

Thanks,
Jordan
-- 
Jordan Crouse
Senior Linux Engineer
Advanced Micro Devices, Inc.
&lt;www.amd.com/embeddedprocessors&gt;

["geode-lx-crypto.patch" (text/plain)]

[PATCH] crypto:  Add support for the Geode LX hardware AES engine

This adds support for the AES engine built into the Geode LX processor.

Signed-off-by: Jordan Crouse &lt;jordan.crouse@amd.com&gt;

diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index adb5541..e816535 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -51,4 +51,17 @@ config CRYPTO_DEV_PADLOCK_SHA
 	  If unsure say M. The compiled module will be
 	  called padlock-sha.ko
 
+config CRYPTO_DEV_GEODE
+	tristate "Support for the Geode LX AES engine"
+	depends on CRYPTO &amp;&amp; X86_32
+	select CRYPTO_ALGAPI
+	select CRYPTO_BLKCIPHER
+	default m
+	help
+	  Say 'Y' here to use the AMD Geode LX processor on-board AES
+	  engine for the CryptoAPI AES alogrithm.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called geode-aes.
+
 endmenu
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index 4c3d0ec..6059cf8 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -1,3 +1,4 @@
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK) += padlock.o
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK_AES) += padlock-aes.o
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK_SHA) += padlock-sha.o
+obj-$(CONFIG_CRYPTO_DEV_GEODE) += geode-aes.o
diff --git a/drivers/crypto/geode-aes.c b/drivers/crypto/geode-aes.c
new file mode 100644
index 0000000..95860e5
--- /dev/null
+++ b/drivers/crypto/geode-aes.c
@@ -0,0 +1,477 @@
+/* CryptoAPI interface for the Geode LX hardware AES encryption module
+ * Copyright (C) 2004-2006, Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/sched.h&gt;
+#include &lt;linux/pci.h&gt;
+#include &lt;linux/pci_ids.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;crypto/algapi.h&gt;
+
+#include &lt;asm/io.h&gt;
+#include &lt;asm/delay.h&gt;
+
+#include "geode-aes.h"
+
+/* Register definitions */
+
+#define AES_CTRLA_REG  0x0000
+
+#define AES_CTRL_START     0x01
+#define AES_CTRL_DECRYPT   0x00
+#define AES_CTRL_ENCRYPT   0x02
+#define AES_CTRL_WRKEY     0x04
+#define AES_CTRL_DCA       0x08
+#define AES_CTRL_SCA       0x10
+#define AES_CTRL_CBC       0x20
+
+#define AES_INTR_REG  0x0008
+
+#define AES_INTRA_PENDING (1 &lt;&lt; 16)
+#define AES_INTRB_PENDING (1 &lt;&lt; 17)
+
+#define AES_INTR_PENDING  (AES_INTRA_PENDING | AES_INTRB_PENDING)
+#define AES_INTR_MASK     0x07
+
+#define AES_SOURCEA_REG   0x0010
+#define AES_DSTA_REG      0x0014
+#define AES_LENA_REG      0x0018
+#define AES_WRITEKEY0_REG 0x0030
+#define AES_WRITEIV0_REG  0x0040
+
+/*  A very large counter that is used to gracefully bail out of an
+ *  operation in case of trouble
+ */
+
+#define AES_OP_TIMEOUT    0x50000
+
+/* Useful macros */
+
+#define SET_KEY(key) _writefield(AES_WRITEKEY0_REG, key)
+#define SET_IV(iv)   _writefield(AES_WRITEIV0_REG, iv)
+#define GET_IV(iv)   _readfield(AES_WRITEIV0_REG, iv)
+#define AWRITE(val, reg) (iowrite32(val, _iobase + reg))
+#define AREAD(reg)  (ioread32(_iobase + reg))
+
+/* Static structures */
+
+static void __iomem * _iobase;
+
+/* Write a 128 bit field (either a writable key or IV) */
+static inline void
+_writefield(u32 offset, void *value)
+{
+	int i;
+	for(i = 0; i &lt; 4; i++)
+		AWRITE(((u32 *) value)[i], offset + (i * 4));
+}
+
+/* Read a 128 bit field (either a writable key or IV) */
+static inline void
+_readfield(u32 offset, void *value)
+{
+	int i;
+	for(i = 0; i &lt; 4; i++)
+		((u32 *) value)[i] = AREAD(offset + (i * 4));
+}
+
+static void
+_crypt(void *src, void *dst, int len, u32 flags)
+{
+	u32 status;
+	u32 counter = AES_OP_TIMEOUT;
+
+	AWRITE(virt_to_phys(src), AES_SOURCEA_REG);
+	AWRITE(virt_to_phys(dst), AES_DSTA_REG);
+	AWRITE(len,  AES_LENA_REG);
+
+	/* Start the operation */
+	AWRITE(AES_CTRL_START | flags, AES_CTRLA_REG);
+
+	do
+		status = AREAD(AES_INTR_REG);
+	while(!(status &amp; AES_INTRA_PENDING) &amp;&amp; --counter);
+
+	/* Clear the event */
+	AWRITE((status &amp; 0xFF) | AES_INTRA_PENDING, AES_INTR_REG);
+}
+
+unsigned int
+geode_aes_crypt(struct geode_aes_op *op)
+{
+	u32 flags = 0;
+
+	if (op-&gt;len == 0 || op-&gt;src == op-&gt;dst)
+		return 0;
+
+	/* Make sure nobody bothers us */
+	preempt_disable();
+
+	if (op-&gt;mode == AES_MODE_CBC) {
+		flags |= AES_CTRL_CBC;
+		SET_IV(op-&gt;iv);
+	}
+
+	if (op-&gt;flags &amp; AES_FLAGS_USRKEY) {
+		flags |= AES_CTRL_WRKEY;
+		SET_KEY(op-&gt;key);
+	}
+
+	if (op-&gt;flags &amp; AES_FLAGS_COHERENT)
+		flags |= (AES_CTRL_DCA | AES_CTRL_SCA);
+
+	if (op-&gt;dir == AES_DIR_ENCRYPT)
+		flags |= AES_CTRL_ENCRYPT;
+
+	_crypt(op-&gt;src, op-&gt;dst, op-&gt;len, flags);
+
+	if (op-&gt;mode == AES_MODE_CBC)
+		GET_IV(op-&gt;iv);
+
+	preempt_enable();
+	return op-&gt;len;
+}
+
+/* CRYPTO-API Functions */
+
+#define blk_ctx(tfm) ((struct geode_aes_op *) crypto_blkcipher_ctx(tfm))
+#define ctx(tfm) ((struct geode_aes_op *) crypto_tfm_ctx(tfm))
+
+static int
+geode_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int len)
+{
+	struct geode_aes_op *op = ctx(tfm);
+
+	if (len != AES_KEY_LENGTH) {
+		tfm-&gt;crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
+		return -EINVAL;
+	}
+
+	memcpy(op-&gt;key, key, len);
+	return 0;
+}
+
+static void
+geode_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
+{
+	struct geode_aes_op *op = ctx(tfm);
+
+	if ((out == NULL) || (in == NULL))
+		return;
+
+	op-&gt;src = (void *) in;
+	op-&gt;dst = (void *) out;
+	op-&gt;mode = AES_MODE_ECB;
+	op-&gt;flags = 0;
+	op-&gt;len = AES_MIN_BLOCK_SIZE;
+	op-&gt;dir = AES_DIR_ENCRYPT;
+
+	geode_aes_crypt(op);
+}
+
+
+static void
+geode_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
+{
+	struct geode_aes_op *op = ctx(tfm);
+
+	if ((out == NULL) || (in == NULL))
+		return;
+
+	op-&gt;src = (void *) in;
+	op-&gt;dst = (void *) out;
+	op-&gt;mode = AES_MODE_ECB;
+	op-&gt;flags = 0;
+	op-&gt;len = AES_MIN_BLOCK_SIZE;
+	op-&gt;dir = AES_DIR_DECRYPT;
+
+	geode_aes_crypt(op);
+}
+
+
+static struct crypto_alg geode_alg = {
+	.cra_name               =       "aes",
+	.cra_driver_name	=       "geode-aes-128",
+	.cra_priority           =       300,
+	.cra_alignmask          =       15,
+	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct geode_aes_op),
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(geode_alg.cra_list),
+	.cra_u			=	{
+		.cipher = {
+			.cia_min_keysize	=  AES_KEY_LENGTH,
+			.cia_max_keysize	=  AES_KEY_LENGTH,
+			.cia_setkey		=  geode_setkey,
+			.cia_encrypt		=  geode_encrypt,
+			.cia_decrypt		=  geode_decrypt
+		}
+	}
+};
+
+static int
+geode_cbc_decrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = blk_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = (void *) walk.src.virt.addr,
+		op-&gt;dst = (void *) walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_CBC;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_DECRYPT;
+
+		memcpy(op-&gt;iv, walk.iv, AES_IV_LENGTH);
+
+		ret = geode_aes_crypt(op);
+
+		memcpy(walk.iv, op-&gt;iv, AES_IV_LENGTH);
+		nbytes -= ret;
+
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static int
+geode_cbc_encrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = blk_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = (void *) walk.src.virt.addr,
+		op-&gt;dst = (void *) walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_CBC;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_ENCRYPT;
+
+		memcpy(op-&gt;iv, walk.iv, AES_IV_LENGTH);
+
+		ret = geode_aes_crypt(op);
+		nbytes -= ret;
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static struct crypto_alg geode_cbc_alg = {
+	.cra_name		=	"cbc(aes)",
+	.cra_driver_name	=	"cbc-aes-geode-128",
+	.cra_priority		=	400,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct geode_aes_op),
+	.cra_alignmask		=	15,
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(geode_cbc_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	AES_KEY_LENGTH,
+			.max_keysize		=	AES_KEY_LENGTH,
+			.setkey			=	geode_setkey,
+			.encrypt		=	geode_cbc_encrypt,
+			.decrypt		=	geode_cbc_decrypt,
+		}
+	}
+};
+
+static int
+geode_ecb_decrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = blk_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = (void *) walk.src.virt.addr,
+		op-&gt;dst = (void *) walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_ECB;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_DECRYPT;
+
+		ret = geode_aes_crypt(op);
+		nbytes -= ret;
+		err = blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static int
+geode_ecb_encrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct geode_aes_op *op = blk_ctx(desc-&gt;tfm);
+	struct blkcipher_walk walk;
+	int err, ret;
+
+	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;walk);
+
+	while((nbytes = walk.nbytes)) {
+		op-&gt;src = (void *) walk.src.virt.addr,
+		op-&gt;dst = (void *) walk.dst.virt.addr;
+		op-&gt;mode = AES_MODE_ECB;
+		op-&gt;len = nbytes - (nbytes % AES_MIN_BLOCK_SIZE);
+		op-&gt;dir = AES_DIR_ENCRYPT;
+
+		ret = geode_aes_crypt(op);
+		nbytes -= ret;
+		ret =  blkcipher_walk_done(desc, &amp;walk, nbytes);
+	}
+
+	return err;
+}
+
+static struct crypto_alg geode_ecb_alg = {
+	.cra_name		=	"ecb(aes)",
+	.cra_driver_name	=	"ecb-aes-geode-128",
+	.cra_priority		=	400,
+	.cra_flags		=	CRYPTO_ALG_TYPE_BLKCIPHER,
+	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct geode_aes_op),
+	.cra_alignmask		=	15,
+	.cra_type		=	&amp;crypto_blkcipher_type,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(geode_ecb_alg.cra_list),
+	.cra_u			=	{
+		.blkcipher = {
+			.min_keysize		=	AES_KEY_LENGTH,
+			.max_keysize		=	AES_KEY_LENGTH,
+			.setkey			=	geode_setkey,
+			.encrypt		=	geode_ecb_encrypt,
+			.decrypt		=	geode_ecb_decrypt,
+		}
+	}
+};
+
+static void
+geode_aes_remove(struct pci_dev *dev)
+{
+	crypto_unregister_alg(&amp;geode_alg);
+	crypto_unregister_alg(&amp;geode_ecb_alg);
+	crypto_unregister_alg(&amp;geode_cbc_alg);
+
+	pci_iounmap(dev, _iobase);
+	_iobase = NULL;
+
+	pci_release_regions(dev);
+	pci_disable_device(dev);
+}
+
+
+static int
+geode_aes_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int ret;
+
+	if ((ret = pci_enable_device(dev)))
+		return ret;
+
+	if ((ret = pci_request_regions(dev, "geode-aes-128")))
+		goto eenable;
+
+	_iobase = pci_iomap(dev, 0, 0);
+
+	if (_iobase == NULL) {
+		ret = -ENOMEM;
+		goto erequest;
+	}
+
+	/* Clear any pending activity */
+	AWRITE(AES_INTR_PENDING | AES_INTR_MASK, AES_INTR_REG);
+
+	if ((ret = crypto_register_alg(&amp;geode_alg)))
+		goto eiomap;
+
+	if ((ret = crypto_register_alg(&amp;geode_ecb_alg)))
+		goto ealg;
+
+	if ((ret = crypto_register_alg(&amp;geode_cbc_alg)))
+		goto eecb;
+
+	printk(KERN_NOTICE "geode-aes: GEODE AES engine enabled.\n");
+	return 0;
+
+ eecb:
+	crypto_unregister_alg(&amp;geode_ecb_alg);
+
+ ealg:
+	crypto_unregister_alg(&amp;geode_alg);
+
+ eiomap:
+	pci_iounmap(dev, _iobase);
+
+ erequest:
+	pci_release_regions(dev);
+
+ eenable:
+	pci_disable_device(dev);
+
+	printk(KERN_ERR "geode-aes:  GEODE AES initialization failed.\n");
+	return ret;
+}
+
+struct pci_device_id geode_aes_tbl[] = {
+	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_LX_AES, PCI_ANY_ID, PCI_ANY_ID} ,
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, geode_aes_tbl);
+
+static struct pci_driver geode_aes_driver = {
+	name:      "Geode LX AES",
+	id_table:  geode_aes_tbl,
+	probe:     geode_aes_probe,
+	remove:    __devexit_p(geode_aes_remove)
+};
+
+static int __devinit
+geode_aes_init(void)
+{
+	return pci_module_init(&amp;geode_aes_driver);
+}
+
+static void __devexit
+geode_aes_exit(void)
+{
+	pci_unregister_driver(&amp;geode_aes_driver);
+}
+
+MODULE_AUTHOR("Advanced Micro Devices, Inc.");
+MODULE_DESCRIPTION("Geode LX Hardware AES driver");
+MODULE_LICENSE("GPL");
+
+module_init(geode_aes_init);
+module_exit(geode_aes_exit);
diff --git a/drivers/crypto/geode-aes.h b/drivers/crypto/geode-aes.h
new file mode 100644
index 0000000..97f9eee
--- /dev/null
+++ b/drivers/crypto/geode-aes.h
@@ -0,0 +1,42 @@
+/* Copyright (C) 2003-2006, Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _GEODE_AES_H_
+#define _GEODE_AES_H_
+
+#define AES_KEY_LENGTH 16
+#define AES_IV_LENGTH  16
+
+#define AES_MIN_BLOCK_SIZE 16
+
+#define AES_MODE_ECB 0
+#define AES_MODE_CBC 1
+
+#define AES_DIR_DECRYPT 0
+#define AES_DIR_ENCRYPT 1
+
+#define AES_FLAGS_USRKEY   (1 &lt;&lt; 0)
+#define AES_FLAGS_COHERENT (1 &lt;&lt; 1)
+
+struct geode_aes_op {
+
+  void *src;
+  void *dst;
+
+  u32 mode;
+  u32 dir;
+  u32 flags;
+  int len;
+
+  u8 key[AES_KEY_LENGTH];
+  u8 iv[AES_IV_LENGTH];
+};
+
+unsigned int geode_aes_crypt(struct geode_aes_op *);
+
+#endif

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060521131430</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-05-21 13:14:30-0400</timestampReceived><subject>[ACRYPTO] New asynchronous crypto layer release.</subject><body>

New asynchronous crypto layer acrypto [1] release.
It includes new driver for HIFN 7955/7956 adapters,
VIA padlock driver, driver for CE-InfoSys FastCrypt PCI card equipped
with a SuperCrypt CE99C003B and
dm-crypt and IPsec ESP4 engines ported to acrypto.

Psec ESP4 transport mode benchmark (scp):
        2.6.16-1.2069_FC4smp -&gt; vanilla 2.6.16-git: ~11.8 MB/s
	vanilla 2.6.16-git -&gt; 2.6.16-1.2069_FC4smp: ~13.2 MB/s

	2.6.16-1.2069_FC4smp -&gt; acrypto SW 2.6.16: ~12.6 MB/s
	acrypto SW 2.6.16 -&gt; 2.6.16-1.2069_FC4smp: ~13.5 MB/s

IPsec benchmark with HIFN driver:
	2.6.16-1.2069_FC4smp -&gt; vanilla 2.6.16-git: ~11.8 MB/s
	vanilla 2.6.16-git -&gt; 2.6.16-1.2069_FC4smp: ~13.2 MB/s

	2.6.16-1.2069_FC4smp -&gt; acrypto HIFN 2.6.16: ~13.2 MB/s
	acrypto HIFN 2.6.16 -&gt; 2.6.16-1.2069_FC4smp: ~13.5 MB/s

As you might expect, CPU usage with HIFN driver and acrypto is noticebly
less, since that setup is CPU limited for stock synchronous kernel
setup (3Ghz P4 with HT enabled).
Above numbers drift with the time, especially when machine running
stock FC4 kernel overheats, and that numbers decrease to 12-13 MB/s.

One can find combined patchsets for 2.6.15 and 2.6.16 trees which
include acrypto with SW crypto provider, dm-crypt and IPsec engines
at acrypto homepage [1].

Credits.
Yakov Lerner for great testing and bug-hunting.
Michal Ludvig for original VIA padlock and fcrypt drivers.


Thank you.

1. Asynchronous crypto layer acrypto.
http://tservice.net.ru/~s0mbre/old/?section=projects&amp;item=acrypto

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060523230443</emailId><senderName>David McCullough</senderName><senderEmail>david_mccullough@au.securecomputing.com</senderEmail><timestampReceived>2006-05-23 23:04:43-0400</timestampReceived><subject>Re: [ACRYPTO] New asynchronous crypto layer release.</subject><body>


Hi Evgeniy,

Just interested in the results you are getting below for
comparison to what I see under OCF with Openswan.

What sort of hifn card were you using in the test below,
was it a 7956 PCIX (ie., 64bit?)

How did you measure the throughput  ?

I can post the OCF numbers,  but it doesn't mean a lot
unless it's a fair comparison :-)

Cheers,
Davidm


Jivin Evgeniy Polyakov lays it down ...
&gt; New asynchronous crypto layer acrypto [1] release.
&gt; It includes new driver for HIFN 7955/7956 adapters,
&gt; VIA padlock driver, driver for CE-InfoSys FastCrypt PCI card equipped
&gt; with a SuperCrypt CE99C003B and
&gt; dm-crypt and IPsec ESP4 engines ported to acrypto.
&gt; 
&gt; Psec ESP4 transport mode benchmark (scp):
&gt;         2.6.16-1.2069_FC4smp -&gt; vanilla 2.6.16-git: ~11.8 MB/s
&gt; 	vanilla 2.6.16-git -&gt; 2.6.16-1.2069_FC4smp: ~13.2 MB/s
&gt; 
&gt; 	2.6.16-1.2069_FC4smp -&gt; acrypto SW 2.6.16: ~12.6 MB/s
&gt; 	acrypto SW 2.6.16 -&gt; 2.6.16-1.2069_FC4smp: ~13.5 MB/s
&gt; 
&gt; IPsec benchmark with HIFN driver:
&gt; 	2.6.16-1.2069_FC4smp -&gt; vanilla 2.6.16-git: ~11.8 MB/s
&gt; 	vanilla 2.6.16-git -&gt; 2.6.16-1.2069_FC4smp: ~13.2 MB/s
&gt; 
&gt; 	2.6.16-1.2069_FC4smp -&gt; acrypto HIFN 2.6.16: ~13.2 MB/s
&gt; 	acrypto HIFN 2.6.16 -&gt; 2.6.16-1.2069_FC4smp: ~13.5 MB/s
&gt; 
&gt; As you might expect, CPU usage with HIFN driver and acrypto is noticebly
&gt; less, since that setup is CPU limited for stock synchronous kernel
&gt; setup (3Ghz P4 with HT enabled).
&gt; Above numbers drift with the time, especially when machine running
&gt; stock FC4 kernel overheats, and that numbers decrease to 12-13 MB/s.
&gt; 
&gt; One can find combined patchsets for 2.6.15 and 2.6.16 trees which
&gt; include acrypto with SW crypto provider, dm-crypt and IPsec engines
&gt; at acrypto homepage [1].
&gt; 
&gt; Credits.
&gt; Yakov Lerner for great testing and bug-hunting.
&gt; Michal Ludvig for original VIA padlock and fcrypt drivers.
&gt; 
&gt; 
&gt; Thank you.
&gt; 
&gt; 1. Asynchronous crypto layer acrypto.
&gt; http://tservice.net.ru/~s0mbre/old/?section=projects&amp;item=acrypto
&gt; 
&gt; -- 
&gt; 	Evgeniy Polyakov
&gt; -
&gt; To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
&gt; the body of a message to majordomo@vger.kernel.org
&gt; More majordomo info at  http://vger.kernel.org/majordomo-info.html

-- 
David McCullough,  david_mccullough@securecomputing.com,   Ph:+61 734352815
Secure Computing - SnapGear  http://www.uCdot.org http://www.cyberguard.com
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060524071252</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-05-24 07:12:52-0400</timestampReceived><subject>Re: [ACRYPTO] New asynchronous crypto layer release.</subject><body>

On Wed, May 24, 2006 at 09:04:43AM +1000, David McCullough (david_mccullough@au.securecomputing.com) wrote:
&gt; 
&gt; Hi Evgeniy,

Hello David.

&gt; Just interested in the results you are getting below for
&gt; comparison to what I see under OCF with Openswan.
&gt; 
&gt; What sort of hifn card were you using in the test below,
&gt; was it a 7956 PCIX (ie., 64bit?)
&gt; 
&gt; How did you measure the throughput  ?

It is racoon transport setup with ESP4 only ecryption with AES-128 CBC
mode.

Hardware.
FC4 vanilla kernel 2.6.16-1.2069_FC4smp runs on P3 3 Ghz with HT
enabled, 512 Mb of RAM, sk98lin gigabit ethernet.
Acrypto kernel runs on Xeon 2.4 Ghz with HT enabled with 1Gb of RAM 
and e1000 gigabit ethernet adapter (in pci-x slot).
HIFN card is old 7955 (it was quite challenging to bring it to Russia
when I started acrypto developemnt several years ago, so no new toys) 
in PCI-X slot.
When HIFN driver is not loaded, asynchronous SW crypto provider is
loaded for one processor.

Benchmark is scp (yes, it encrypt packets too to simulate some real work
on hosts) of big files over the gigabit link.

&gt; I can post the OCF numbers,  but it doesn't mean a lot
&gt; unless it's a fair comparison :-)

That would be good :)

&gt; Cheers,
&gt; Davidm

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060928120826</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-09-28 12:08:26-0400</timestampReceived><subject>[ACRYPTO] New asynchronous crypto layer (acrypto) release.</subject><body>

Hello.

I'm pleased to announce asynchronous crypto layer (acrypto) [1] release 
for 2.6.18 kernel tree. Acrypto allows to handle crypto requests 
asynchronously in hardware.

Combined patchset includes:
 * acrypto core
 * IPsec ESP4 port to acrypto
 * dm-crypt port to acrypto
 * OCF to acrypto bridge

Acrypto supports following crypto providers:
 * SW crypto provider
 * HIFN 795x adapters
 * VIA nehemiah CPU
 * SuperCrypt CE99C003B
 * devices supported by OCF

With this release of combined patchset for 2.6.18 I drop feature
extensions for 2.6.16 and 2.6.17 trees and move them into maintenance
state.

Combined patchset [190k] and drivers for various acrypto providers can 
be found on project's homepage.

1. Acrypto homepage.
http://tservice.net.ru/~s0mbre/old/?section=projects&amp;item=acrypto

Signed-off-by: Evgeniy Polyakov &lt;johnpol@2ka.mipt.ru&gt;

-- 
	Evgeniy Polyakov


-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060928132343</emailId><senderName>Andreas Jellinghaus</senderName><senderEmail>aj@ciphirelabs.com</senderEmail><timestampReceived>2006-09-28 13:23:43-0400</timestampReceived><subject>Re: [ACRYPTO] New asynchronous crypto layer (acrypto) release.</subject><body>

Evgeniy Polyakov wrote:
&gt; Hello.
&gt; 
&gt; I'm pleased to announce asynchronous crypto layer (acrypto) [1] release 
&gt; for 2.6.18 kernel tree. Acrypto allows to handle crypto requests 
&gt; asynchronously in hardware.
&gt; 
&gt; Combined patchset includes:
&gt;  * acrypto core
&gt;  * IPsec ESP4 port to acrypto
&gt;  * dm-crypt port to acrypto

so I should be able to replace a plain 2.6.18 kernel with one
with this patchset and use dm-crypt'ed partitions (e.g. swap,
encrypted root filesystem) as usual without further changes?

Did anyone test this with success?

Regards, Andreas
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060928133528</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-09-28 13:35:28-0400</timestampReceived><subject>Re: [ACRYPTO] New asynchronous crypto layer (acrypto) release.</subject><body>

On Thu, Sep 28, 2006 at 03:23:43PM +0200, Andreas Jellinghaus (aj@ciphirelabs.com) wrote:
&gt; &gt;I'm pleased to announce asynchronous crypto layer (acrypto) [1] release 
&gt; &gt;for 2.6.18 kernel tree. Acrypto allows to handle crypto requests 
&gt; &gt;asynchronously in hardware.
&gt; &gt;
&gt; &gt;Combined patchset includes:
&gt; &gt; * acrypto core
&gt; &gt; * IPsec ESP4 port to acrypto
&gt; &gt; * dm-crypt port to acrypto
&gt; 
&gt; so I should be able to replace a plain 2.6.18 kernel with one
&gt; with this patchset and use dm-crypt'ed partitions (e.g. swap,
&gt; encrypted root filesystem) as usual without further changes?

Yes.

&gt; Did anyone test this with success?

Except me, I think...
That code was used for OCF dm-crypt port some time ago (I recall it was
Marvell), so the whole base is not limited by acrypto only.

I can only say that there are users out there which use acrypto without
pointing exact names naturally. I agree that it does not sound very 
strong, but actually I'm not going to convince someone, I just establish
a fact.

&gt; Regards, Andreas

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060929094809</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-09-29 09:48:09-0400</timestampReceived><subject>Re: [ACRYPTO] New asynchronous crypto layer (acrypto) release.</subject><body>

On Thu, Sep 28, 2006 at 03:23:43PM +0200, Andreas Jellinghaus (aj@ciphirelabs.com) wrote:
&gt; Evgeniy Polyakov wrote:
&gt; &gt;Hello.
&gt; &gt;
&gt; &gt;I'm pleased to announce asynchronous crypto layer (acrypto) [1] release 
&gt; &gt;for 2.6.18 kernel tree. Acrypto allows to handle crypto requests 
&gt; &gt;asynchronously in hardware.
&gt; &gt;
&gt; &gt;Combined patchset includes:
&gt; &gt; * acrypto core
&gt; &gt; * IPsec ESP4 port to acrypto
&gt; &gt; * dm-crypt port to acrypto
&gt; 
&gt; so I should be able to replace a plain 2.6.18 kernel with one
&gt; with this patchset and use dm-crypt'ed partitions (e.g. swap,
&gt; encrypted root filesystem) as usual without further changes?
&gt; 
&gt; Did anyone test this with success?
&gt; 
&gt; Regards, Andreas

As I answered in your first e-mail, yes, you just need to patch 2.6.18
tree and load one of the crypto provider.

Acrypto works with request/response model, i.e. you ask acrypto core to
perform some operation on given buffers and if it can, it will call
your callback when it is ready (or some error happend and acrypto was
unable to reroute request to other device), otherwise it will return error.

With such a model it is possible to extend acrypto to any kind of
operations on buffers, not only crypto related, for example it is
possible to onload IPsec header transformation, perform DMA between
specified areas and much more.

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060929101758</emailId><senderName>Samuel Tardieu</senderName><senderEmail>sam@rfc1149.net</senderEmail><timestampReceived>2006-09-29 10:17:58-0400</timestampReceived><subject>Re: [ACRYPTO] New asynchronous crypto layer (acrypto) release.</subject><body>

&gt;&gt;&gt;&gt;&gt; "Evgeniy" == Evgeniy Polyakov &lt;johnpol@2ka.mipt.ru&gt; writes:

Evgeniy&gt; Hello.  I'm pleased to announce asynchronous crypto layer
Evgeniy&gt; (acrypto) [1] release for 2.6.18 kernel tree. Acrypto allows
Evgeniy&gt; to handle crypto requests asynchronously in hardware.

Would userspace programs benefit from this patch? In particular, would
OpenSSL get better performances on Via nehemiah CPUs or does it need
to be patched?

  Sam
-- 
Samuel Tardieu -- sam@rfc1149.net -- http://www.rfc1149.net/

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060929105120</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-09-29 10:51:20-0400</timestampReceived><subject>Re: [ACRYPTO] New asynchronous crypto layer (acrypto) release.</subject><body>

On Fri, Sep 29, 2006 at 12:17:58PM +0200, Samuel Tardieu (sam@rfc1149.net) wrote:
&gt; &gt;&gt;&gt;&gt;&gt; "Evgeniy" == Evgeniy Polyakov &lt;johnpol@2ka.mipt.ru&gt; writes:
&gt; 
&gt; Evgeniy&gt; Hello.  I'm pleased to announce asynchronous crypto layer
&gt; Evgeniy&gt; (acrypto) [1] release for 2.6.18 kernel tree. Acrypto allows
&gt; Evgeniy&gt; to handle crypto requests asynchronously in hardware.
&gt; 
&gt; Would userspace programs benefit from this patch? In particular, would
&gt; OpenSSL get better performances on Via nehemiah CPUs or does it need
&gt; to be patched?

Userspace supports Via Nehemiah CPUs crypto engine quite for a long time
without any external patching.

&gt;   Sam
&gt; -- 
&gt; Samuel Tardieu -- sam@rfc1149.net -- http://www.rfc1149.net/

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061019150419</emailId><senderName>Andreas Jellinghaus</senderName><senderEmail>aj@ciphirelabs.com</senderEmail><timestampReceived>2006-10-19 15:04:19-0400</timestampReceived><subject>Re: [ACRYPTO] New asynchronous crypto layer (acrypto) release.</subject><body>

Hi,

I finally got around testing 2.6.18.1 + acrypto.
but it "does not work" - I usualy boot, enter my
passphrases for rsa key / openssl decrypts some random
bytes with them, and a hex version of those random bytes
is used with dm-setup to initialize a dm-crypt mapping
which again is used for mounting root and swap (or
resume in case it has a suspend image on them).

but with the acrypto patched kernel the system freezes
without any response. the script in the initramfs is not
"set +x" so I'm not sure which command causes the freeze,
so I guess it is either the dm-setup, the resume trigger
(echo to a file in /sys/) or the mount for root or the
swapon.

&gt; As I answered in your first e-mail, yes, you just need to patch 2.6.18
&gt; tree and load one of the crypto provider.

what exactly would be "load one of the crypto providers"?
+# Asynchronous crypto layer
+#
+CONFIG_ACRYPTO=y
+CONFIG_ASYNC_PROVIDER=y
+# CONFIG_CONSUMER is not set
+# CONFIG_ASYNC2OCF_BRIDGE is not set
+
+#
this change to .config should be enough
(ok, 2.6.18.1 also enabled CONFIG_CONNECTOR and CONFIG_PROC_EVENTS).

I documented the setup of my laptop with encryption here:
https://help.ubuntu.com/community/EncryptedFilesystemHowto4

and I can post kernel config etc. if it helps. there was no
kernel message when the machine froze (or more like waiting
for something forever - ctrl-alt-del still worked fine).

note: kernel 2.6.18 was working fine, I didn't try 2.6.18.1
without acrypto changes, but I guess that isn't the issues.
still if you think otherwise, I can give it a try. if there
is some boot option to disable acrypto so dm-crypt will work
as if compiled without acrypto, I would try that too.
is there such an option?

Thanks, Andreas
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061020063116</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-10-20 06:31:16-0400</timestampReceived><subject>Re: [ACRYPTO] New asynchronous crypto layer (acrypto) release.</subject><body>

On Thu, Oct 19, 2006 at 05:04:19PM +0200, Andreas Jellinghaus (aj@ciphirelabs.com) wrote:
&gt; Hi,
&gt; 
&gt; I finally got around testing 2.6.18.1 + acrypto.
&gt; but it "does not work" - I usualy boot, enter my
&gt; passphrases for rsa key / openssl decrypts some random
&gt; bytes with them, and a hex version of those random bytes
&gt; is used with dm-setup to initialize a dm-crypt mapping
&gt; which again is used for mounting root and swap (or
&gt; resume in case it has a suspend image on them).
&gt; 
&gt; but with the acrypto patched kernel the system freezes
&gt; without any response. the script in the initramfs is not
&gt; "set +x" so I'm not sure which command causes the freeze,
&gt; so I guess it is either the dm-setup, the resume trigger
&gt; (echo to a file in /sys/) or the mount for root or the
&gt; swapon.
&gt; 
&gt; &gt;As I answered in your first e-mail, yes, you just need to patch 2.6.18
&gt; &gt;tree and load one of the crypto provider.
&gt; 
&gt; what exactly would be "load one of the crypto providers"?
&gt; +# Asynchronous crypto layer
&gt; +#
&gt; +CONFIG_ACRYPTO=y
&gt; +CONFIG_ASYNC_PROVIDER=y
&gt; +# CONFIG_CONSUMER is not set
&gt; +# CONFIG_ASYNC2OCF_BRIDGE is not set
&gt; +
&gt; +#
&gt; this change to .config should be enough
&gt; (ok, 2.6.18.1 also enabled CONFIG_CONNECTOR and CONFIG_PROC_EVENTS).

Both are not required.

&gt; I documented the setup of my laptop with encryption here:
&gt; https://help.ubuntu.com/community/EncryptedFilesystemHowto4
&gt; 
&gt; and I can post kernel config etc. if it helps. there was no
&gt; kernel message when the machine froze (or more like waiting
&gt; for something forever - ctrl-alt-del still worked fine).
&gt; 
&gt; note: kernel 2.6.18 was working fine, I didn't try 2.6.18.1
&gt; without acrypto changes, but I guess that isn't the issues.
&gt; still if you think otherwise, I can give it a try. if there
&gt; is some boot option to disable acrypto so dm-crypt will work
&gt; as if compiled without acrypto, I would try that too.
&gt; is there such an option?

If acrypto fails it should automatically switch to sw synchronous mode.
Could you enable debug mode in include/linux/acrypto.h:54 - uncommend 
//#define DEBUG
recompile the kernel and give it a try, so I could check where it stops.

Btw, async provider only supports AES-128 in CBC mode, so if you try
different ciphers, there can be some problems.

Thank you.

&gt; Thanks, Andreas

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20061020133440</emailId><senderName>Andreas Jellinghaus</senderName><senderEmail>aj@ciphirelabs.com</senderEmail><timestampReceived>2006-10-20 13:34:40-0400</timestampReceived><subject>Re: [ACRYPTO] New asynchronous crypto layer (acrypto) release.</subject><body>

&gt; Btw, async provider only supports AES-128 in CBC mode, so if you try
&gt; different ciphers, there can be some problems.

my code does

SECTORS=`blockdev --getsize /dev/hda3`

echo 0 $SECTORS crypt aes-cbc-essiv:sha256 $ROOTKEY 0 /dev/hda3 0 \
         |dmsetup create root

so this is not compatible with acrypto I guess :(
any special reason why acrypto is limited this way?

guess that limitation needs to go away before it can be added to
the linux kernel, or some workaround so dm-crypt will fall back on
not using acrypto or something like that in order to not brake existing
and working installations.

Thanks, Andreas
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060915102711</emailId><senderName>Gisle_Sælensminde</senderName><senderEmail>gisle@cbu.uib.no</senderEmail><timestampReceived>2006-09-15 10:27:11-0400</timestampReceived><subject>Re: Disk encryption best practices?</subject><body>

Jens Lechtenboerger wrote:

&gt;Hi there,
&gt;
&gt;I'm about to encrypt my disk with loop-aes, and I'm wondering
&gt;whether this is a clever move:
&gt;
&gt;1. The introduction (in German) at
&gt;   http://wiki.chaostreff.ch/index.php/Festplattenverschl%C3%BCsselung
&gt;   recommends not to use AES but to prefer Twofish.
&gt;   In addition, GnuPG uses CAST5 as default for symmetric
&gt;   encryption.
&gt;
&gt;   What is the state-of-the-art here?
&gt;
&gt;  
&gt;
AES has no known weaknesses, is quite fast, and is the most analyzed of 
those algorithms, so
most cryprographers would recommend AES. Twofish was one of the five 
final algorithms in
the AES competition, and is quite well analyzed as well, but less than 
AES (or Rijndael, as it was
known as during the competition). Twofish has gained some popularity in 
the open source circles,
and can as well be used instead of AES, but there is no reason to 
recomend it over AES/Rijndael.
CAST5 was also a candidate for AES, but did not make it to the final, 
and is thus less well analyzed
than the other. That is not saying that it is broken in any way, but I 
would prefere AES or Twofish.

&gt;2. The text at http://mareichelt.de/pub/texts.cryptoloop.php
&gt;   warns against mainline cryptoloop:
&gt;   "Both cryptoloop and dm-crypt in kernels prior to 2.6.10 are
&gt;    vulnerable, and even recent dm-crypt still suffers from a weak
&gt;    crypto implementation."
&gt;
&gt;   What is weak here?
&gt;
&gt;  
&gt;
A weak IV scheme made it possible for an attacker with access to the raw 
storage to see
which bytes of a block that was the first modified, but not see what the 
change was. Newer loop-aes
implementations has fixed this problem.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060915103159</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-09-15 10:31:59-0400</timestampReceived><subject>Re: Disk encryption best practices?</subject><body>

Jens Lechtenboerger wrote:
&gt; 1. The introduction (in German) at
&gt;    http://wiki.chaostreff.ch/index.php/Festplattenverschl%C3%BCsselung
&gt;    recommends not to use AES but to prefer Twofish.
&gt;    In addition, GnuPG uses CAST5 as default for symmetric
&gt;    encryption.
&gt; 
&gt;    What is the state-of-the-art here?

Both AES and twofish are good. AES is little bit faster.

&gt; 2. The text at http://mareichelt.de/pub/texts.cryptoloop.php
&gt;    warns against mainline cryptoloop:
&gt;    "Both cryptoloop and dm-crypt in kernels prior to 2.6.10 are
&gt;     vulnerable, and even recent dm-crypt still suffers from a weak
&gt;     crypto implementation."
&gt; 
&gt;    What is weak here?

http://marc.theaimsgroup.com/?l=linux-kernel&amp;m=107719798631935&amp;w=2

Above mentioned IV computation weakness is fixed in newer dm-crypt versions,
but the IV is still non-changing (for same sector number), which leaks
location of changed data in some unusual situations. In normal use that is
not a big problem.

&gt; 3. The German Linux-Magazin 10/06 (http://www.linux-magazin.de)
&gt;    features an article by Peter Gutmann and Christian Ney, where
&gt;    they analyze different types of crypto filesystems.  They
&gt;    recommend Truecrypt, dm-crypt is second, and they essentially
&gt;    warn against loop-aes:

I tried to look for that Linux-Magazin article, but I didn't find it
on-line. Do you have a URL for it?

&gt;    They state that the code is complex and written in such a way
&gt;    that it is difficult to judge whether it does what it is supposed
&gt;    to do.

In other words, they didn't spend enough time to understand it.

&gt;    In addition, return values are never checked (e.g., when
&gt;    computing encryption keys),

Prototype for that particular key setup function:

extern void aes_set_key(aes_context *, const unsigned char [], const int, const int);

It returns void type, so there isn't much return value to check.

&gt;    which might lead to a key consisting of just zeros.

No it doesn't.

&gt;    However, the code is so sloppy that programs are
&gt;    more likely to crash with null-pointer dereferences than to use
&gt;    empty keys.

What null-pointer dereferences? That code has been running on my boxes for
more than 5 years, and during that time it has NEVER dereferenced
null-pointer. That pointer math looks kinky, especially when runtime key
scrubbing is enabled, but to my knowledge it is 100% correct.

&gt;    Besides, they complain that by default passwords are
&gt;    not salted and password hash iterations are not used.

Loop-AES has supported salted+iterated passphrase hashing for many years.
For long time, the recommended way has been to use gpg encrypted key files.
gpg does salted+iterated passphrase hashing as a countermeasure against
optimized dictionary attacks.

Maybe they just didn't bother to read the README file?

&gt;    The part about code quality sounds scary.  Opinions?

Difficult to understand? Maybe.

Bad quality? Definitely no.

&gt;    Concerning salting and iterations, for my root partition, I just
&gt;    have to uncomment to lines in build-initrd.sh, right?
&gt;    Concerning Example 2 in the loop-aes README (partition backed
&gt;    loop with gpg encrypted keys), I get salting and iterations with
&gt;    the gpg patch provided with loop-aes, right?

Please leave those PSEED= and ITERCOUNTK= commented out in build-initrd.sh
script. They had some use many years ago, and they are still there for sake
of compatibility. There might still be someone using them.

gpg does passphrase salting + iterations for you. Even unpatched gpg does
that. The gpg patch makes gpg do 128 times more iterations that normally
while still being compatible with RFC2440 spec.

You do NOT want to do salting+iterations again in losetup/mount for second
time, because actual loop encryption keys that gpg decrypts for you are high
quality random keys that originally came from /dev/random.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060915114529</emailId><senderName>Jens Lechtenboerger</senderName><senderEmail>lechten@wi.uni-muenster.de</senderEmail><timestampReceived>2006-09-15 11:45:29-0400</timestampReceived><subject>Re: Disk encryption best practices?</subject><body>

Jari Ruusu wrote:

&gt; [...]
&gt; I tried to look for that Linux-Magazin article, but I didn't find it
&gt; on-line. Do you have a URL for it?

I'm afraid it's not available online.

Many thanks for your answers.

Jens

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060917155554</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-09-17 15:55:54-0400</timestampReceived><subject>Re: boot from LVM2 device on loop-aes</subject><body>

Matthias Teege wrote:
&gt; I've created some LVM2 volumes on a loop-aes device which works
&gt; great. I put
&gt; 
&gt; mkdir /stick
&gt; mount -r -t vfat /dev/sdb4 /stick
&gt; losetup -e AES256 -K /stick/key.gpg /dev/loop0 /dev/sda3
&gt; 
&gt; in my initrd.scripts before the vgscan/vgchange commands but the
&gt; losetup in busybox doesn't understand all commandline switches.
&gt; 
&gt; Is it possible to boot from an LVM2 volume on top of loopaes? How
&gt; do I setup it correct?

You need to use loop-AES version of losetup in your initrd.
Try copying a statically linked version of losetup to your USB-stick.

 mkdir /stick
 mount -r -t vfat /dev/sdb4 /stick
 /stick/losetup -e AES256 -K /stick/key.gpg -G / /dev/loop0 /dev/sda3
 ^^^^^^^                                    ^^^^

To compile statically linked version of losetup, add this to util-linux
configure comand:

 CFLAGS=-O2 LDFLAGS="-s -static" ./configure
            ^^^^^^^^^^^^^^^^^^^^
-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060902110650</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-09-02 11:06:50-0400</timestampReceived><subject>[PATCH 3/7] [CRYPTO] api: Add crypto_comp and crypto_has_*</subject><body>

[CRYPTO] api: Add crypto_comp and crypto_has_*

This patch adds the crypto_comp type to complete the compile-time checking
conversion.  The functions crypto_has_alg and crypto_has_cipher, etc. are
also added to replace crypto_alg_available.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 crypto/api.c           |   14 +++++++
 include/linux/crypto.h |   90 +++++++++++++++++++++++++++++++++++++++++++++----
 2 files changed, 98 insertions(+), 6 deletions(-)

diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -482,3 +482,17 @@ int crypto_alg_available(const char *nam
 EXPORT_SYMBOL_GPL(crypto_alloc_tfm);
 EXPORT_SYMBOL_GPL(crypto_free_tfm);
 EXPORT_SYMBOL_GPL(crypto_alg_available);
+
+int crypto_has_alg(const char *name, u32 type, u32 mask)
+{
+	int ret = 0;
+	struct crypto_alg *alg = crypto_alg_mod_lookup(name, type, mask);
+	
+	if (!IS_ERR(alg)) {
+		crypto_mod_put(alg);
+		ret = 1;
+	}
+	
+	return ret;
+}
+EXPORT_SYMBOL_GPL(crypto_has_alg);
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -236,11 +236,17 @@ int crypto_unregister_alg(struct crypto_
  */
 #ifdef CONFIG_CRYPTO
 int crypto_alg_available(const char *name, u32 flags);
+int crypto_has_alg(const char *name, u32 type, u32 mask);
 #else
 static inline int crypto_alg_available(const char *name, u32 flags)
 {
 	return 0;
 }
+
+static inline int crypto_has_alg(const char *name, u32 type, u32 mask)
+{
+	return 0;
+}
 #endif
 
 /*
@@ -329,6 +335,7 @@ struct crypto_tfm {
 };
 
 #define crypto_cipher crypto_tfm
+#define crypto_comp crypto_tfm
 
 struct crypto_blkcipher {
 	struct crypto_tfm base;
@@ -485,6 +492,15 @@ static inline void crypto_free_blkcipher
 	crypto_free_tfm(crypto_blkcipher_tfm(tfm));
 }
 
+static inline int crypto_has_blkcipher(const char *alg_name, u32 type, u32 mask)
+{
+	type &amp;= ~CRYPTO_ALG_TYPE_MASK;
+	type |= CRYPTO_ALG_TYPE_BLKCIPHER;
+	mask |= CRYPTO_ALG_TYPE_MASK;
+
+	return crypto_has_alg(alg_name, type, mask);
+}
+
 static inline const char *crypto_blkcipher_name(struct crypto_blkcipher *tfm)
 {
 	return crypto_tfm_alg_name(crypto_blkcipher_tfm(tfm));
@@ -620,6 +636,15 @@ static inline void crypto_free_cipher(st
 	crypto_free_tfm(crypto_cipher_tfm(tfm));
 }
 
+static inline int crypto_has_cipher(const char *alg_name, u32 type, u32 mask)
+{
+	type &amp;= ~CRYPTO_ALG_TYPE_MASK;
+	type |= CRYPTO_ALG_TYPE_CIPHER;
+	mask |= CRYPTO_ALG_TYPE_MASK;
+
+	return crypto_has_alg(alg_name, type, mask);
+}
+
 static inline struct cipher_tfm *crypto_cipher_crt(struct crypto_cipher *tfm)
 {
 	return &amp;crypto_cipher_tfm(tfm)-&gt;crt_cipher;
@@ -718,6 +743,15 @@ static inline void crypto_free_hash(stru
 	crypto_free_tfm(crypto_hash_tfm(tfm));
 }
 
+static inline int crypto_has_hash(const char *alg_name, u32 type, u32 mask)
+{
+	type &amp;= ~CRYPTO_ALG_TYPE_MASK;
+	type |= CRYPTO_ALG_TYPE_HASH;
+	mask |= CRYPTO_ALG_TYPE_HASH_MASK;
+
+	return crypto_has_alg(alg_name, type, mask);
+}
+
 static inline struct hash_tfm *crypto_hash_crt(struct crypto_hash *tfm)
 {
 	return &amp;crypto_hash_tfm(tfm)-&gt;crt_hash;
@@ -853,20 +887,64 @@ static inline void crypto_cipher_get_iv(
 	memcpy(dst, tfm-&gt;crt_cipher.cit_iv, len);
 }
 
-static inline int crypto_comp_compress(struct crypto_tfm *tfm,
+static inline struct crypto_comp *__crypto_comp_cast(struct crypto_tfm *tfm)
+{
+	return (struct crypto_comp *)tfm;
+}
+
+static inline struct crypto_comp *crypto_comp_cast(struct crypto_tfm *tfm)
+{
+	BUG_ON((crypto_tfm_alg_type(tfm) ^ CRYPTO_ALG_TYPE_COMPRESS) &amp;
+	       CRYPTO_ALG_TYPE_MASK);
+	return __crypto_comp_cast(tfm);
+}
+
+static inline struct crypto_comp *crypto_alloc_comp(const char *alg_name,
+						    u32 type, u32 mask)
+{
+	type &amp;= ~CRYPTO_ALG_TYPE_MASK;
+	type |= CRYPTO_ALG_TYPE_COMPRESS;
+	mask |= CRYPTO_ALG_TYPE_MASK;
+
+	return __crypto_comp_cast(crypto_alloc_base(alg_name, type, mask));
+}
+
+static inline struct crypto_tfm *crypto_comp_tfm(struct crypto_comp *tfm)
+{
+	return tfm;
+}
+
+static inline void crypto_free_comp(struct crypto_comp *tfm)
+{
+	crypto_free_tfm(crypto_comp_tfm(tfm));
+}
+
+static inline int crypto_has_comp(const char *alg_name, u32 type, u32 mask)
+{
+	type &amp;= ~CRYPTO_ALG_TYPE_MASK;
+	type |= CRYPTO_ALG_TYPE_COMPRESS;
+	mask |= CRYPTO_ALG_TYPE_MASK;
+
+	return crypto_has_alg(alg_name, type, mask);
+}
+
+static inline struct compress_tfm *crypto_comp_crt(struct crypto_comp *tfm)
+{
+	return &amp;crypto_comp_tfm(tfm)-&gt;crt_compress;
+}
+
+static inline int crypto_comp_compress(struct crypto_comp *tfm,
                                        const u8 *src, unsigned int slen,
                                        u8 *dst, unsigned int *dlen)
 {
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_COMPRESS);
-	return tfm-&gt;crt_compress.cot_compress(tfm, src, slen, dst, dlen);
+	return crypto_comp_crt(tfm)-&gt;cot_compress(tfm, src, slen, dst, dlen);
 }
 
-static inline int crypto_comp_decompress(struct crypto_tfm *tfm,
+static inline int crypto_comp_decompress(struct crypto_comp *tfm,
                                          const u8 *src, unsigned int slen,
                                          u8 *dst, unsigned int *dlen)
 {
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_COMPRESS);
-	return tfm-&gt;crt_compress.cot_decompress(tfm, src, slen, dst, dlen);
+	return crypto_comp_crt(tfm)-&gt;cot_decompress(tfm, src, slen, dst, dlen);
 }
 
 #endif	/* _LINUX_CRYPTO_H */

-- 
VGER BF report: H 0
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060902110651</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-09-02 11:06:51-0400</timestampReceived><subject>[PATCH 4/7] [CRYPTO] users: Use crypto_comp and crypto_has_*</subject><body>

[CRYPTO] users: Use crypto_comp and crypto_has_*

This patch converts all users to use the new crypto_comp type and the
crypto_has_* functions.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 crypto/tcrypt.c          |    8 ++++----
 drivers/crypto/padlock.c |    6 +++---
 drivers/net/ppp_mppe.c   |    4 ++--
 include/linux/crypto.h   |    5 +++++
 include/net/ipcomp.h     |    5 ++---
 net/ipv4/ipcomp.c        |   25 +++++++++++++------------
 net/ipv6/ipcomp6.c       |   25 +++++++++++++------------
 net/xfrm/xfrm_algo.c     |   27 ++++++++++++++++++---------
 8 files changed, 60 insertions(+), 45 deletions(-)

diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -749,7 +749,7 @@ static void test_deflate(void)
 {
 	unsigned int i;
 	char result[COMP_BUF_SIZE];
-	struct crypto_tfm *tfm;
+	struct crypto_comp *tfm;
 	struct comp_testvec *tv;
 	unsigned int tsize;
 
@@ -821,7 +821,7 @@ static void test_deflate(void)
 		       ilen, dlen);
 	}
 out:
-	crypto_free_tfm(tfm);
+	crypto_free_comp(tfm);
 }
 
 static void test_available(void)
@@ -830,8 +830,8 @@ static void test_available(void)
 
 	while (*name) {
 		printk("alg %s ", *name);
-		printk((crypto_alg_available(*name, 0)) ?
-			"found\n" : "not found\n");
+		printk(crypto_has_alg(*name, 0, CRYPTO_ALG_ASYNC) ?
+		       "found\n" : "not found\n");
 		name++;
 	}
 }
diff --git a/drivers/crypto/padlock.c b/drivers/crypto/padlock.c
--- a/drivers/crypto/padlock.c
+++ b/drivers/crypto/padlock.c
@@ -26,13 +26,13 @@ static int __init padlock_init(void)
 {
 	int success = 0;
 
-	if (crypto_alg_available("aes-padlock", 0))
+	if (crypto_has_cipher("aes-padlock", 0, 0))
 		success++;
 
-	if (crypto_alg_available("sha1-padlock", 0))
+	if (crypto_has_hash("sha1-padlock", 0, 0))
 		success++;
 
-	if (crypto_alg_available("sha256-padlock", 0))
+	if (crypto_has_hash("sha256-padlock", 0, 0))
 		success++;
 
 	if (!success) {
diff --git a/drivers/net/ppp_mppe.c b/drivers/net/ppp_mppe.c
--- a/drivers/net/ppp_mppe.c
+++ b/drivers/net/ppp_mppe.c
@@ -710,8 +710,8 @@ static struct compressor ppp_mppe = {
 static int __init ppp_mppe_init(void)
 {
 	int answer;
-	if (!(crypto_alg_available("ecb(arc4)", 0) &amp;&amp;
-	      crypto_alg_available("sha1", 0)))
+	if (!(crypto_has_blkcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC) &amp;&amp;
+	      crypto_has_hash("sha1", 0, CRYPTO_ALG_ASYNC)))
 		return -ENODEV;
 
 	sha_pad = kmalloc(sizeof(struct sha_pad), GFP_KERNEL);
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -928,6 +928,11 @@ static inline int crypto_has_comp(const 
 	return crypto_has_alg(alg_name, type, mask);
 }
 
+static inline const char *crypto_comp_name(struct crypto_comp *tfm)
+{
+	return crypto_tfm_alg_name(crypto_comp_tfm(tfm));
+}
+
 static inline struct compress_tfm *crypto_comp_crt(struct crypto_comp *tfm)
 {
 	return &amp;crypto_comp_tfm(tfm)-&gt;crt_compress;
diff --git a/include/net/ipcomp.h b/include/net/ipcomp.h
--- a/include/net/ipcomp.h
+++ b/include/net/ipcomp.h
@@ -1,15 +1,14 @@
 #ifndef _NET_IPCOMP_H
 #define _NET_IPCOMP_H
 
+#include &lt;linux/crypto.h&gt;
 #include &lt;linux/types.h&gt;
 
 #define IPCOMP_SCRATCH_SIZE     65400
 
-struct crypto_tfm;
-
 struct ipcomp_data {
 	u16 threshold;
-	struct crypto_tfm **tfms;
+	struct crypto_comp **tfms;
 };
 
 #endif
diff --git a/net/ipv4/ipcomp.c b/net/ipv4/ipcomp.c
--- a/net/ipv4/ipcomp.c
+++ b/net/ipv4/ipcomp.c
@@ -32,7 +32,7 @@
 
 struct ipcomp_tfms {
 	struct list_head list;
-	struct crypto_tfm **tfms;
+	struct crypto_comp **tfms;
 	int users;
 };
 
@@ -46,7 +46,7 @@ static int ipcomp_decompress(struct xfrm
 	int err, plen, dlen;
 	struct ipcomp_data *ipcd = x-&gt;data;
 	u8 *start, *scratch;
-	struct crypto_tfm *tfm;
+	struct crypto_comp *tfm;
 	int cpu;
 	
 	plen = skb-&gt;len;
@@ -107,7 +107,7 @@ static int ipcomp_compress(struct xfrm_s
 	struct iphdr *iph = skb-&gt;nh.iph;
 	struct ipcomp_data *ipcd = x-&gt;data;
 	u8 *start, *scratch;
-	struct crypto_tfm *tfm;
+	struct crypto_comp *tfm;
 	int cpu;
 	
 	ihlen = iph-&gt;ihl * 4;
@@ -302,7 +302,7 @@ static void **ipcomp_alloc_scratches(voi
 	return scratches;
 }
 
-static void ipcomp_free_tfms(struct crypto_tfm **tfms)
+static void ipcomp_free_tfms(struct crypto_comp **tfms)
 {
 	struct ipcomp_tfms *pos;
 	int cpu;
@@ -324,28 +324,28 @@ static void ipcomp_free_tfms(struct cryp
 		return;
 
 	for_each_possible_cpu(cpu) {
-		struct crypto_tfm *tfm = *per_cpu_ptr(tfms, cpu);
-		crypto_free_tfm(tfm);
+		struct crypto_comp *tfm = *per_cpu_ptr(tfms, cpu);
+		crypto_free_comp(tfm);
 	}
 	free_percpu(tfms);
 }
 
-static struct crypto_tfm **ipcomp_alloc_tfms(const char *alg_name)
+static struct crypto_comp **ipcomp_alloc_tfms(const char *alg_name)
 {
 	struct ipcomp_tfms *pos;
-	struct crypto_tfm **tfms;
+	struct crypto_comp **tfms;
 	int cpu;
 
 	/* This can be any valid CPU ID so we don't need locking. */
 	cpu = raw_smp_processor_id();
 
 	list_for_each_entry(pos, &amp;ipcomp_tfms_list, list) {
-		struct crypto_tfm *tfm;
+		struct crypto_comp *tfm;
 
 		tfms = pos-&gt;tfms;
 		tfm = *per_cpu_ptr(tfms, cpu);
 
-		if (!strcmp(crypto_tfm_alg_name(tfm), alg_name)) {
+		if (!strcmp(crypto_comp_name(tfm), alg_name)) {
 			pos-&gt;users++;
 			return tfms;
 		}
@@ -359,12 +359,13 @@ static struct crypto_tfm **ipcomp_alloc_
 	INIT_LIST_HEAD(&amp;pos-&gt;list);
 	list_add(&amp;pos-&gt;list, &amp;ipcomp_tfms_list);
 
-	pos-&gt;tfms = tfms = alloc_percpu(struct crypto_tfm *);
+	pos-&gt;tfms = tfms = alloc_percpu(struct crypto_comp *);
 	if (!tfms)
 		goto error;
 
 	for_each_possible_cpu(cpu) {
-		struct crypto_tfm *tfm = crypto_alloc_tfm(alg_name, 0);
+		struct crypto_comp *tfm = crypto_alloc_comp(alg_name, 0,
+							    CRYPTO_ALG_ASYNC);
 		if (!tfm)
 			goto error;
 		*per_cpu_ptr(tfms, cpu) = tfm;
diff --git a/net/ipv6/ipcomp6.c b/net/ipv6/ipcomp6.c
--- a/net/ipv6/ipcomp6.c
+++ b/net/ipv6/ipcomp6.c
@@ -53,7 +53,7 @@
 
 struct ipcomp6_tfms {
 	struct list_head list;
-	struct crypto_tfm **tfms;
+	struct crypto_comp **tfms;
 	int users;
 };
 
@@ -70,7 +70,7 @@ static int ipcomp6_input(struct xfrm_sta
 	int plen, dlen;
 	struct ipcomp_data *ipcd = x-&gt;data;
 	u8 *start, *scratch;
-	struct crypto_tfm *tfm;
+	struct crypto_comp *tfm;
 	int cpu;
 
 	if (skb_linearize_cow(skb))
@@ -129,7 +129,7 @@ static int ipcomp6_output(struct xfrm_st
 	struct ipcomp_data *ipcd = x-&gt;data;
 	int plen, dlen;
 	u8 *start, *scratch;
-	struct crypto_tfm *tfm;
+	struct crypto_comp *tfm;
 	int cpu;
 
 	hdr_len = skb-&gt;h.raw - skb-&gt;data;
@@ -301,7 +301,7 @@ static void **ipcomp6_alloc_scratches(vo
 	return scratches;
 }
 
-static void ipcomp6_free_tfms(struct crypto_tfm **tfms)
+static void ipcomp6_free_tfms(struct crypto_comp **tfms)
 {
 	struct ipcomp6_tfms *pos;
 	int cpu;
@@ -323,28 +323,28 @@ static void ipcomp6_free_tfms(struct cry
 		return;
 
 	for_each_possible_cpu(cpu) {
-		struct crypto_tfm *tfm = *per_cpu_ptr(tfms, cpu);
-		crypto_free_tfm(tfm);
+		struct crypto_comp *tfm = *per_cpu_ptr(tfms, cpu);
+		crypto_free_comp(tfm);
 	}
 	free_percpu(tfms);
 }
 
-static struct crypto_tfm **ipcomp6_alloc_tfms(const char *alg_name)
+static struct crypto_comp **ipcomp6_alloc_tfms(const char *alg_name)
 {
 	struct ipcomp6_tfms *pos;
-	struct crypto_tfm **tfms;
+	struct crypto_comp **tfms;
 	int cpu;
 
 	/* This can be any valid CPU ID so we don't need locking. */
 	cpu = raw_smp_processor_id();
 
 	list_for_each_entry(pos, &amp;ipcomp6_tfms_list, list) {
-		struct crypto_tfm *tfm;
+		struct crypto_comp *tfm;
 
 		tfms = pos-&gt;tfms;
 		tfm = *per_cpu_ptr(tfms, cpu);
 
-		if (!strcmp(crypto_tfm_alg_name(tfm), alg_name)) {
+		if (!strcmp(crypto_comp_name(tfm), alg_name)) {
 			pos-&gt;users++;
 			return tfms;
 		}
@@ -358,12 +358,13 @@ static struct crypto_tfm **ipcomp6_alloc
 	INIT_LIST_HEAD(&amp;pos-&gt;list);
 	list_add(&amp;pos-&gt;list, &amp;ipcomp6_tfms_list);
 
-	pos-&gt;tfms = tfms = alloc_percpu(struct crypto_tfm *);
+	pos-&gt;tfms = tfms = alloc_percpu(struct crypto_comp *);
 	if (!tfms)
 		goto error;
 
 	for_each_possible_cpu(cpu) {
-		struct crypto_tfm *tfm = crypto_alloc_tfm(alg_name, 0);
+		struct crypto_comp *tfm = crypto_alloc_comp(alg_name, 0,
+							    CRYPTO_ALG_ASYNC);
 		if (!tfm)
 			goto error;
 		*per_cpu_ptr(tfms, cpu) = tfm;
diff --git a/net/xfrm/xfrm_algo.c b/net/xfrm/xfrm_algo.c
--- a/net/xfrm/xfrm_algo.c
+++ b/net/xfrm/xfrm_algo.c
@@ -363,8 +363,8 @@ struct xfrm_algo_desc *xfrm_calg_get_byi
 EXPORT_SYMBOL_GPL(xfrm_calg_get_byid);
 
 static struct xfrm_algo_desc *xfrm_get_byname(struct xfrm_algo_desc *list,
-					      int entries, char *name,
-					      int probe)
+					      int entries, u32 type, u32 mask,
+					      char *name, int probe)
 {
 	int i, status;
 
@@ -382,7 +382,7 @@ static struct xfrm_algo_desc *xfrm_get_b
 		if (!probe)
 			break;
 
-		status = crypto_alg_available(name, 0);
+		status = crypto_has_alg(name, type, mask | CRYPTO_ALG_ASYNC);
 		if (!status)
 			break;
 
@@ -394,19 +394,25 @@ static struct xfrm_algo_desc *xfrm_get_b
 
 struct xfrm_algo_desc *xfrm_aalg_get_byname(char *name, int probe)
 {
-	return xfrm_get_byname(aalg_list, aalg_entries(), name, probe);
+	return xfrm_get_byname(aalg_list, aalg_entries(),
+			       CRYPTO_ALG_TYPE_HASH, CRYPTO_ALG_TYPE_HASH_MASK,
+			       name, probe);
 }
 EXPORT_SYMBOL_GPL(xfrm_aalg_get_byname);
 
 struct xfrm_algo_desc *xfrm_ealg_get_byname(char *name, int probe)
 {
-	return xfrm_get_byname(ealg_list, ealg_entries(), name, probe);
+	return xfrm_get_byname(ealg_list, ealg_entries(),
+			       CRYPTO_ALG_TYPE_BLKCIPHER, CRYPTO_ALG_TYPE_MASK,
+			       name, probe);
 }
 EXPORT_SYMBOL_GPL(xfrm_ealg_get_byname);
 
 struct xfrm_algo_desc *xfrm_calg_get_byname(char *name, int probe)
 {
-	return xfrm_get_byname(calg_list, calg_entries(), name, probe);
+	return xfrm_get_byname(calg_list, calg_entries(),
+			       CRYPTO_ALG_TYPE_COMPRESS, CRYPTO_ALG_TYPE_MASK,
+			       name, probe);
 }
 EXPORT_SYMBOL_GPL(xfrm_calg_get_byname);
 
@@ -441,19 +447,22 @@ void xfrm_probe_algs(void)
 	BUG_ON(in_softirq());
 
 	for (i = 0; i &lt; aalg_entries(); i++) {
-		status = crypto_alg_available(aalg_list[i].name, 0);
+		status = crypto_has_hash(aalg_list[i].name, 0,
+					 CRYPTO_ALG_ASYNC);
 		if (aalg_list[i].available != status)
 			aalg_list[i].available = status;
 	}
 	
 	for (i = 0; i &lt; ealg_entries(); i++) {
-		status = crypto_alg_available(ealg_list[i].name, 0);
+		status = crypto_has_blkcipher(ealg_list[i].name, 0,
+					      CRYPTO_ALG_ASYNC);
 		if (ealg_list[i].available != status)
 			ealg_list[i].available = status;
 	}
 	
 	for (i = 0; i &lt; calg_entries(); i++) {
-		status = crypto_alg_available(calg_list[i].name, 0);
+		status = crypto_has_comp(calg_list[i].name, 0,
+					 CRYPTO_ALG_ASYNC);
 		if (calg_list[i].available != status)
 			calg_list[i].available = status;
 	}

-- 
VGER BF report: H 0
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060902110653</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-09-02 11:06:53-0400</timestampReceived><subject>[PATCH 5/7] [CRYPTO] padlock: Convert padlock-sha to use crypto_hash</subject><body>

[CRYPTO] padlock: Convert padlock-sha to use crypto_hash

This patch converts padlock-sha to use crypto_hash for its fallback.
It also changes the fallback selection to use selection by type instead
of name.  This is done through the new CRYPTO_ALG_NEED_FALLBACK bit,
which is set if and only if an algorithm needs a fallback of the same
type.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 drivers/crypto/padlock-sha.c |   91 ++++++++++++++++---------------------------
 include/linux/crypto.h       |    6 ++
 2 files changed, 41 insertions(+), 56 deletions(-)

diff --git a/drivers/crypto/padlock-sha.c b/drivers/crypto/padlock-sha.c
--- a/drivers/crypto/padlock-sha.c
+++ b/drivers/crypto/padlock-sha.c
@@ -12,10 +12,11 @@
  *
  */
 
+#include &lt;crypto/algapi.h&gt;
+#include &lt;linux/err.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/errno.h&gt;
-#include &lt;linux/crypto.h&gt;
 #include &lt;linux/cryptohash.h&gt;
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/kernel.h&gt;
@@ -30,28 +31,17 @@
 #define SHA256_DIGEST_SIZE      32
 #define SHA256_HMAC_BLOCK_SIZE  64
 
-static char *sha1_fallback = SHA1_DEFAULT_FALLBACK;
-static char *sha256_fallback = SHA256_DEFAULT_FALLBACK;
-
-module_param(sha1_fallback, charp, 0644);
-module_param(sha256_fallback, charp, 0644);
-
-MODULE_PARM_DESC(sha1_fallback, "Fallback driver for SHA1. Default is "
-		 SHA1_DEFAULT_FALLBACK);
-MODULE_PARM_DESC(sha256_fallback, "Fallback driver for SHA256. Default is "
-		 SHA256_DEFAULT_FALLBACK);
-
 struct padlock_sha_ctx {
 	char		*data;
 	size_t		used;
 	int		bypass;
 	void (*f_sha_padlock)(const char *in, char *out, int count);
-	struct crypto_tfm *fallback_tfm;
+	struct hash_desc fallback;
 };
 
 static inline struct padlock_sha_ctx *ctx(struct crypto_tfm *tfm)
 {
-	return (struct padlock_sha_ctx *)(crypto_tfm_ctx(tfm));
+	return crypto_tfm_ctx(tfm);
 }
 
 /* We'll need aligned address on the stack */
@@ -65,14 +55,12 @@ static void padlock_sha_bypass(struct cr
 	if (ctx(tfm)-&gt;bypass)
 		return;
 
-	BUG_ON(!ctx(tfm)-&gt;fallback_tfm);
-
-	crypto_digest_init(ctx(tfm)-&gt;fallback_tfm);
+	crypto_hash_init(&amp;ctx(tfm)-&gt;fallback);
 	if (ctx(tfm)-&gt;data &amp;&amp; ctx(tfm)-&gt;used) {
 		struct scatterlist sg;
 
 		sg_set_buf(&amp;sg, ctx(tfm)-&gt;data, ctx(tfm)-&gt;used);
-		crypto_digest_update(ctx(tfm)-&gt;fallback_tfm, &amp;sg, 1);
+		crypto_hash_update(&amp;ctx(tfm)-&gt;fallback, &amp;sg, sg.length);
 	}
 
 	ctx(tfm)-&gt;used = 0;
@@ -95,9 +83,8 @@ static void padlock_sha_update(struct cr
 
 	if (unlikely(ctx(tfm)-&gt;bypass)) {
 		struct scatterlist sg;
-		BUG_ON(!ctx(tfm)-&gt;fallback_tfm);
 		sg_set_buf(&amp;sg, (uint8_t *)data, length);
-		crypto_digest_update(ctx(tfm)-&gt;fallback_tfm, &amp;sg, 1);
+		crypto_hash_update(&amp;ctx(tfm)-&gt;fallback, &amp;sg, length);
 		return;
 	}
 
@@ -160,8 +147,7 @@ static void padlock_do_sha256(const char
 static void padlock_sha_final(struct crypto_tfm *tfm, uint8_t *out)
 {
 	if (unlikely(ctx(tfm)-&gt;bypass)) {
-		BUG_ON(!ctx(tfm)-&gt;fallback_tfm);
-		crypto_digest_final(ctx(tfm)-&gt;fallback_tfm, out);
+		crypto_hash_final(&amp;ctx(tfm)-&gt;fallback, out);
 		ctx(tfm)-&gt;bypass = 0;
 		return;
 	}
@@ -172,8 +158,11 @@ static void padlock_sha_final(struct cry
 	ctx(tfm)-&gt;used = 0;
 }
 
-static int padlock_cra_init(struct crypto_tfm *tfm, const char *fallback_driver_name)
+static int padlock_cra_init(struct crypto_tfm *tfm)
 {
+	const char *fallback_driver_name = tfm-&gt;__crt_alg-&gt;cra_name;
+	struct crypto_hash *fallback_tfm;
+
 	/* For now we'll allocate one page. This
 	 * could eventually be configurable one day. */
 	ctx(tfm)-&gt;data = (char *)__get_free_page(GFP_KERNEL);
@@ -181,14 +170,17 @@ static int padlock_cra_init(struct crypt
 		return -ENOMEM;
 
 	/* Allocate a fallback and abort if it failed. */
-	ctx(tfm)-&gt;fallback_tfm = crypto_alloc_tfm(fallback_driver_name, 0);
-	if (!ctx(tfm)-&gt;fallback_tfm) {
+	fallback_tfm = crypto_alloc_hash(fallback_driver_name, 0,
+					 CRYPTO_ALG_ASYNC |
+					 CRYPTO_ALG_NEED_FALLBACK);
+	if (IS_ERR(fallback_tfm)) {
 		printk(KERN_WARNING PFX "Fallback driver '%s' could not be loaded!\n",
 		       fallback_driver_name);
 		free_page((unsigned long)(ctx(tfm)-&gt;data));
-		return -ENOENT;
+		return PTR_ERR(fallback_tfm);
 	}
 
+	ctx(tfm)-&gt;fallback.tfm = fallback_tfm;
 	return 0;
 }
 
@@ -196,14 +188,14 @@ static int padlock_sha1_cra_init(struct 
 {
 	ctx(tfm)-&gt;f_sha_padlock = padlock_do_sha1;
 
-	return padlock_cra_init(tfm, sha1_fallback);
+	return padlock_cra_init(tfm);
 }
 
 static int padlock_sha256_cra_init(struct crypto_tfm *tfm)
 {
 	ctx(tfm)-&gt;f_sha_padlock = padlock_do_sha256;
 
-	return padlock_cra_init(tfm, sha256_fallback);
+	return padlock_cra_init(tfm);
 }
 
 static void padlock_cra_exit(struct crypto_tfm *tfm)
@@ -213,16 +205,16 @@ static void padlock_cra_exit(struct cryp
 		ctx(tfm)-&gt;data = NULL;
 	}
 
-	BUG_ON(!ctx(tfm)-&gt;fallback_tfm);
-	crypto_free_tfm(ctx(tfm)-&gt;fallback_tfm);
-	ctx(tfm)-&gt;fallback_tfm = NULL;
+	crypto_free_hash(ctx(tfm)-&gt;fallback.tfm);
+	ctx(tfm)-&gt;fallback.tfm = NULL;
 }
 
 static struct crypto_alg sha1_alg = {
 	.cra_name		=	"sha1",
 	.cra_driver_name	=	"sha1-padlock",
 	.cra_priority		=	PADLOCK_CRA_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST,
+	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST |
+					CRYPTO_ALG_NEED_FALLBACK,
 	.cra_blocksize		=	SHA1_HMAC_BLOCK_SIZE,
 	.cra_ctxsize		=	sizeof(struct padlock_sha_ctx),
 	.cra_module		=	THIS_MODULE,
@@ -243,7 +235,8 @@ static struct crypto_alg sha256_alg = {
 	.cra_name		=	"sha256",
 	.cra_driver_name	=	"sha256-padlock",
 	.cra_priority		=	PADLOCK_CRA_PRIORITY,
-	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST,
+	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST |
+					CRYPTO_ALG_NEED_FALLBACK,
 	.cra_blocksize		=	SHA256_HMAC_BLOCK_SIZE,
 	.cra_ctxsize		=	sizeof(struct padlock_sha_ctx),
 	.cra_module		=	THIS_MODULE,
@@ -262,29 +255,15 @@ static struct crypto_alg sha256_alg = {
 
 static void __init padlock_sha_check_fallbacks(void)
 {
-	struct crypto_tfm *tfm;
-
-	/* We'll try to allocate one TFM for each fallback
-	 * to test that the modules are available. */
-	tfm = crypto_alloc_tfm(sha1_fallback, 0);
-	if (!tfm) {
-		printk(KERN_WARNING PFX "Couldn't load fallback module for '%s'. Tried '%s'.\n",
-		       sha1_alg.cra_name, sha1_fallback);
-	} else {
-		printk(KERN_NOTICE PFX "Fallback for '%s' is driver '%s' (prio=%d)\n", sha1_alg.cra_name,
-		       crypto_tfm_alg_driver_name(tfm), crypto_tfm_alg_priority(tfm));
-		crypto_free_tfm(tfm);
-	}
-
-	tfm = crypto_alloc_tfm(sha256_fallback, 0);
-	if (!tfm) {
-		printk(KERN_WARNING PFX "Couldn't load fallback module for '%s'. Tried '%s'.\n",
-		       sha256_alg.cra_name, sha256_fallback);
-	} else {
-		printk(KERN_NOTICE PFX "Fallback for '%s' is driver '%s' (prio=%d)\n", sha256_alg.cra_name,
-		       crypto_tfm_alg_driver_name(tfm), crypto_tfm_alg_priority(tfm));
-		crypto_free_tfm(tfm);
-	}
+	if (!crypto_has_hash("sha1", 0, CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_NEED_FALLBACK))
+		printk(KERN_WARNING PFX
+		       "Couldn't load fallback module for sha1.\n");
+
+	if (!crypto_has_hash("sha256", 0, CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_NEED_FALLBACK))
+		printk(KERN_WARNING PFX
+		       "Couldn't load fallback module for sha256.\n");
 }
 
 static int __init padlock_init(void)
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -43,6 +43,12 @@
 #define CRYPTO_ALG_ASYNC		0x00000080
 
 /*
+ * Set this bit if and only if the algorithm requires another algorithm of
+ * the same type to handle corner cases.
+ */
+#define CRYPTO_ALG_NEED_FALLBACK	0x00000100
+
+/*
  * Transform masks and values (for crt_flags).
  */
 #define CRYPTO_TFM_MODE_MASK		0x000000ff

-- 
VGER BF report: H 0
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060902110655</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-09-02 11:06:55-0400</timestampReceived><subject>[PATCH 6/7] [CRYPTO] api: Deprecate crypto_digest_* and crypto_alg_available</subject><body>

[CRYPTO] api: Deprecate crypto_digest_* and crypto_alg_available

This patch marks the crypto_digest_* functions and crypto_alg_available
as deprecated.  They've been replaced by crypto_hash_* and crypto_has_*
respectively.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 include/linux/crypto.h |   18 +++++++++++++-----
 1 files changed, 13 insertions(+), 5 deletions(-)

diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -241,9 +241,12 @@ int crypto_unregister_alg(struct crypto_
  * Algorithm query interface.
  */
 #ifdef CONFIG_CRYPTO
-int crypto_alg_available(const char *name, u32 flags);
+int crypto_alg_available(const char *name, u32 flags)
+	__deprecated_for_modules;
 int crypto_has_alg(const char *name, u32 type, u32 mask);
 #else
+static int crypto_alg_available(const char *name, u32 flags);
+	__deprecated_for_modules;
 static inline int crypto_alg_available(const char *name, u32 flags)
 {
 	return 0;
@@ -704,12 +707,15 @@ static inline void crypto_cipher_decrypt
 						dst, src);
 }
 
-void crypto_digest_init(struct crypto_tfm *tfm);
+void crypto_digest_init(struct crypto_tfm *tfm) __deprecated_for_modules;
 void crypto_digest_update(struct crypto_tfm *tfm,
-			  struct scatterlist *sg, unsigned int nsg);
-void crypto_digest_final(struct crypto_tfm *tfm, u8 *out);
+			  struct scatterlist *sg, unsigned int nsg)
+	__deprecated_for_modules;
+void crypto_digest_final(struct crypto_tfm *tfm, u8 *out)
+	__deprecated_for_modules;
 void crypto_digest_digest(struct crypto_tfm *tfm,
-			  struct scatterlist *sg, unsigned int nsg, u8 *out);
+			  struct scatterlist *sg, unsigned int nsg, u8 *out)
+	__deprecated_for_modules;
 
 static inline struct crypto_hash *__crypto_hash_cast(struct crypto_tfm *tfm)
 {
@@ -723,6 +729,8 @@ static inline struct crypto_hash *crypto
 	return __crypto_hash_cast(tfm);
 }
 
+static int crypto_digest_setkey(struct crypto_tfm *tfm, const u8 *key,
+				unsigned int keylen) __deprecated;
 static inline int crypto_digest_setkey(struct crypto_tfm *tfm,
                                        const u8 *key, unsigned int keylen)
 {

-- 
VGER BF report: H 0
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060902110657</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-09-02 11:06:57-0400</timestampReceived><subject>[PATCH 7/7] [CRYPTO] cbc: Optimise in-place decryption</subject><body>

[CRYPTO] cbc: Optimise in-place decryption

This optimisation trades the cost of 2 copies per block versus 1 divide
for each segment.  The idea is simply to decrypt backwards.  This way
we avoid overwriting most IVs until we've used it.

Testing with tcrypt shows a performance gain of 10%, making in-place
decryption faster than in-place encryption for AES.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 crypto/cbc.c |   23 +++++++++++++++--------
 1 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/crypto/cbc.c b/crypto/cbc.c
--- a/crypto/cbc.c
+++ b/crypto/cbc.c
@@ -159,16 +159,23 @@ static int crypto_cbc_decrypt_inplace(st
 	unsigned int nbytes = walk-&gt;nbytes;
 	u8 *src = walk-&gt;src.virt.addr;
 	u8 stack[bsize + alignmask];
-	u8 *tmp = (u8 *)ALIGN((unsigned long)stack, alignmask + 1);
+	u8 *first_iv = (u8 *)ALIGN((unsigned long)stack, alignmask + 1);
 
-	do {
-		fn(crypto_cipher_tfm(tfm), tmp, src);
-		xor(tmp, walk-&gt;iv, bsize);
-		memcpy(walk-&gt;iv, src, bsize);
-		memcpy(src, tmp, bsize);
+	memcpy(first_iv, walk-&gt;iv, bsize);
+
+	/* Start of the last block. */
+	src += nbytes - nbytes % bsize - bsize;
+	memcpy(walk-&gt;iv, src, bsize);
+
+	for (;;) {
+		fn(crypto_cipher_tfm(tfm), src, src);
+		if ((nbytes -= bsize) &lt; bsize)
+			break;
+		xor(src, src - bsize, bsize);
+		src -= bsize;
+	}
 
-		src += bsize;
-	} while ((nbytes -= bsize) &gt;= bsize);
+	xor(src, first_iv, bsize);
 
 	return nbytes;
 }

-- 
VGER BF report: H 0.0174255
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060914041534</emailId><senderName>"U.C  IGWE"</senderName><senderEmail>jansemail@virgilio.it</senderEmail><timestampReceived>2006-09-14 04:15:34-0400</timestampReceived><subject>Email  from  U.C</subject><body>

Hello My name is U.C IGWE
I am very happy to get to you.
Ireside in 
Portharcourt Nigeria
Hope you'll get the email.
I really want to get 
into a serious relationship.
We can get to know each other?.
I do not 
have any private picture profile.
However I can send some nice pics.
I 
work with the Arik Air as a ticketing salelady.
I am single.
I really 
want to hear from you.
I want you to be serious about this email and I 
need long term
relationship.
Your response will determine how far we 
can go.
Mum
works with the external affairs ministry at Abuja .
She's a 
nice woman.
Dad is works with construction firm over here.
Life  has 
been good,Though I want to get more experince and 
contribute my bit.
I 
do not want to write more.
You can call me now or anytime on 234-80-
36743028
Add me yahoo messenger with
universalconsule1997
You can call 
me tomorrow afternoon
I want you to respond and let's get to know each 
other.
Take care
Best
Regards


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060916112223</emailId><senderName>Christian Kujau</senderName><senderEmail>evil@g-house.de</senderEmail><timestampReceived>2006-09-16 11:22:23-0400</timestampReceived><subject>Re: firefox is up/downloading something unauthorized-- logfiles</subject><body>

On Thu, 14 Sep 2006, reverend@Safe-mail.net wrote:
&gt; When fighting with shitty-xine, suddenly and without any question, firefox fetched or
&gt; transfered something to or from the internet and a short message said something from
&gt; "upgrading".

if firefox does something (upgrading) what it's not supposed to do (you 
disabled auto-update, right? not sure if you have to restart ffox after 
the change), file a bug @firefox bugzilla.

&gt; After searching and deleting that second user-agent-string with hexedit, that rat-hole
&gt; was filled; this still maybe the case today.

well, if you're curious about it: try it out ;-)

&gt; Ideas of making a logfile for, at least, all that is send via what-ever-protocol towards
&gt; the internet ????

Either strace(1) the mozilla process or tcpdump(8) the network traffic.

&gt; Even debian is not free of shitware......

that's why we're all invited to make it better.

Christian.
-- 
BOFH excuse #63:

not properly grounded, please bury computer

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060918201851</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-09-18 20:18:51-0400</timestampReceived><subject>Re: boot from LVM2 device on loop-aes</subject><body>

Matthias Teege wrote:
&gt; &gt;  mkdir /stick
&gt; &gt;  mount -r -t vfat /dev/sdb4 /stick
&gt; &gt;  /stick/losetup -e AES256 -K /stick/key.gpg -G / /dev/loop0 /dev/sda3
&gt; 
&gt; I've put the static losetup on the stick and '/stick/losetup -a'
&gt; after the lines above. Losetup ask for the password but I've got
&gt; no output from losetup -a after giving the password. There are no
&gt; error messages. Do I need something else?

Statically linked gpg program must be in /bin/ or /usr/bin/ or /usr/local/bin/

losetup uses gpg to decrypt the key file.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060921190409</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-09-21 19:04:09-0400</timestampReceived><subject>Re: Disk encryption best practices?</subject><body>

Jari Ruusu wrote:
&gt; Jens Lechtenboerger wrote:
&gt; &gt; 3. The German Linux-Magazin 10/06 (http://www.linux-magazin.de)
&gt; &gt;    features an article by Peter Gutmann and Christian Ney, where
&gt; &gt;    they analyze different types of crypto filesystems.  They
&gt; &gt;    recommend Truecrypt, dm-crypt is second, and they essentially
&gt; &gt;    warn against loop-aes:
&gt; 
&gt; I tried to look for that Linux-Magazin article, but I didn't find it
&gt; on-line. Do you have a URL for it?

Christian Ney was kind enough to send me english language draft of the
article. It might not be exactly what was printed, but at least I have
something to quote and respond to.

Quote from the article:
| Loop AES is available as a series of Linux kernel patches

One patch for 2.6 kernels, one patch for 2.4 kernels, or alternatively,
outside of kernel tree buildable kernel module that builds for all recent
2.6, 2.4, 2.2, and 2.0 kernels. Module version doesn't need any kernel
patching.

| the behaviour of the encryption can change radically depending on which
| compile or runtime configuration options are chosen

Compile time configuration options do not change on-disk format. Having
optimized assembler implementations available for popular processors (x86
and amd64) and instruction set extensions (VIA padlock) are good things to
have.

Runtime configuration options are needed for compatibility with old on-disk
formats. Killing compatibility with old on-disk formats is not responsible
thing to do.

| the code makes it quite difficult to pin down exactly what's going on, or
| whether it's actually doing what it's supposed to be doing.

The code is difficult to read, I agree.

Short version of what it does, is here:
http://mail.nl.linux.org/linux-crypto/2006-05/msg00049.html

| LoopAES uses an unsalted hash of the password, applying a single iteration
| of a hash function like SHA-256 or SHA-512 to obtain the disk key
[snip]
| makes it trivially vulnerable to a precomputed dictionary attack

That obsolete code path is there for backward compatibility only. All
examples in the README file and losetup man page use version 3 multi-key
mode, and none of above applies to those examples. For many years, the
recommended way has been to use gpg encrypted key files. gpg uses
salted+iterated key setup, so precomputed dictionary attacks won't work.

| Data is encrypted with AES in CBC mode &lt;&lt;&lt;kernel-2.6.15.diff, line 737&gt;&gt;&gt;,
| with a confusing array of IV-processing options using either the raw
| sector number or an MD5 hash as the IV.

Raw sector number IV is there for backward compatibility only.

| no function return codes are ever checked, so if anything goes wrong the
| code continues with all-zero keys or unencrypted data.

aes_set_key(), aes_encrypt(), and aes_decrypt() functions return void type.
To check return value of void returning function would be a bug that
compiler would refuse to compile. Those functions never return any error
because they do not have any error situations that can make them return
failed status.

If above mentioned functions, or other kernel called driver hooks, are
passed invalid pointers, then pointer dereferencing will cause kernel mode
exception, and the process will cease executing with kernel "Oops", and the
function never returns. As for RAM pre-allocations that are done at loop
device set up time, all pointers are checked at least once at allocation
time, but not thereafter.

This claim of "continues with all-zero keys or unencrypted data" is
completely bogus.

My conclusion of this article's loop-AES section is that the technical
review was done in hurry, and for some unknown reason seems to focus on bits
that were obsoleted years ago. Maybe the reason of such mistake is because
the source code does not have explicit comments about which sections of code
are for handling obsolete compatibility bits.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060921234517</emailId><senderName></senderName><senderEmail>p0054498</senderEmail><timestampReceived>2006-09-21 23:45:17-0400</timestampReceived><subject>=?utf-8?Q?Auto=3A_{Spam=3F_10}_{Virus=3F}_Returned_mail=3A_see_transcri?= =?utf-8?Q?pt_for_details?=</subject><body>

This is an automated reply from Jeya Henry; I am away until mid Sept and will not be able to reply to you immediately.I will get back to you as soon as I return.Journal authors please be pateint. 


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060923172034</emailId><senderName>"Rik Snel"</senderName><senderEmail>rsnel@cube.dyndns.org</senderEmail><timestampReceived>2006-09-23 17:20:34-0400</timestampReceived><subject>[PATCH] adding speed_test_template for lrw(aes)</subject><body>

From: Rik Snel &lt;rsnel@cube.dyndns.org&gt;

lrw(aes) needs a different speed_test_template from standard aes because of
the different keysize, lrw(aes) has 256, 320 and 384 bits and other aes
modes have 128, 192, 256 bits.

Signed-off-by: Rik Snel &lt;rsnel@cube.dyndns.org&gt;
---
 crypto/tcrypt.c |    4 ++--
 crypto/tcrypt.h |   21 +++++++++++++++++++++
 2 files changed, 23 insertions(+), 2 deletions(-)

diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
index ccad842..777fc63 100644
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -1200,9 +1200,9 @@ static void do_test(void)
 		test_cipher_speed("cbc(aes)", DECRYPT, sec, NULL, 0,
 				  aes_speed_template);
 		test_cipher_speed("lrw(aes)", ENCRYPT, sec, NULL, 0,
-				  aes_speed_template);
+				  aes_lrw_speed_template);
 		test_cipher_speed("lrw(aes)", DECRYPT, sec, NULL, 0,
-				  aes_speed_template);
+				  aes_lrw_speed_template);
 		break;
 
 	case 201:
diff --git a/crypto/tcrypt.h b/crypto/tcrypt.h
index ab98b28..59fbc39 100644
--- a/crypto/tcrypt.h
+++ b/crypto/tcrypt.h
@@ -3589,6 +3589,27 @@ static struct cipher_speed aes_speed_tem
 	{  .klen = 0, .blen = 0, }
 };
 
+static struct cipher_speed aes_lrw_speed_template[] = {
+	{ .klen = 32, .blen = 16, },
+	{ .klen = 32, .blen = 64, },
+	{ .klen = 32, .blen = 256, },
+	{ .klen = 32, .blen = 1024, },
+	{ .klen = 32, .blen = 8192, },
+	{ .klen = 40, .blen = 16, },
+	{ .klen = 40, .blen = 64, },
+	{ .klen = 40, .blen = 256, },
+	{ .klen = 40, .blen = 1024, },
+	{ .klen = 40, .blen = 8192, },
+	{ .klen = 48, .blen = 16, },
+	{ .klen = 48, .blen = 64, },
+	{ .klen = 48, .blen = 256, },
+	{ .klen = 48, .blen = 1024, },
+	{ .klen = 48, .blen = 8192, },
+
+	/* End marker */
+	{  .klen = 0, .blen = 0, }
+};
+
 static struct cipher_speed des3_ede_speed_template[] = {
 	{ .klen = 24, .blen = 16, },
 	{ .klen = 24, .blen = 64, },
-- 
1.4.2.1

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060923174103</emailId><senderName>"Rik Snel"</senderName><senderEmail>rsnel@cube.dyndns.org</senderEmail><timestampReceived>2006-09-23 17:41:03-0400</timestampReceived><subject>[PATCH 1/2] crypto: bewbi IV, big endian wide block count for ABL-32-AES</subject><body>

From: Rik Snel &lt;rsnel@cube.dyndns.org&gt;

ABL-32-AES needs a certain IV. This IV should be provided dm-crypt.
The block cipher mode could, in principle, generate the correct IV from
the plain IV, but I think that it is cleaner to supply the right IV
directly.

The sector -&gt; wide block calculation is currently just a conversion
to bigendian and an increment, but if dm-crypt will support cypher
blocksizes larger than 512 bytes (which would be interesting for
wide blocks) the conversion will include a shift also.

Signed-off-by: Rik Snel &lt;rsnel@cube.dyndns.org&gt;
---
 drivers/md/dm-crypt.c |   20 +++++++++++++++++++-
 1 files changed, 19 insertions(+), 1 deletions(-)

diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c
index c09c8e0..10cc227 100644
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@ -109,6 +109,9 @@ static kmem_cache_t *_crypt_io_pool;
  * benbi: the 64-bit "big-endian 'narrow block'-count", starting at 1
  * 	  (needed for LRW-32-AES and possible other narrow block modes)
  *
+ * bewbi: the 64-bit "big-endian 'wide block'-count", starting at 1
+ *        (needed for ABL-32-AES and possible other wide block modes)
+ *
  * plumb: unimplemented, see:
  * http://article.gmane.org/gmane.linux.kernel.device-mapper.dm-crypt/454
  */
@@ -248,6 +251,14 @@ static int crypt_iv_benbi_gen(struct cry
 	return 0;
 }
 
+static int crypt_iv_bewbi_gen(struct crypt_config *cc, u8 *iv, sector_t sector)
+{
+	memset(iv, 0, cc-&gt;iv_size - sizeof(u32));
+	*((u32*)iv + 3) = cpu_to_be32((sector &amp; 0xffffffff) + 1);
+
+	return 0;
+}
+
 static struct crypt_iv_operations crypt_iv_plain_ops = {
 	.generator = crypt_iv_plain_gen
 };
@@ -264,6 +275,10 @@ static struct crypt_iv_operations crypt_
 	.generator = crypt_iv_benbi_gen
 };
 
+static struct crypt_iv_operations crypt_iv_bewbi_ops = {
+	.generator = crypt_iv_bewbi_gen
+};
+
 static int
 crypt_convert_scatterlist(struct crypt_config *cc, struct scatterlist *out,
                           struct scatterlist *in, unsigned int length,
@@ -632,7 +647,8 @@ static int crypt_ctr(struct dm_target *t
 	cc-&gt;tfm = tfm;
 
 	/*
-	 * Choose ivmode. Valid modes: "plain", "essiv:&lt;esshash&gt;", "benbi".
+	 * Choose ivmode. Valid modes: "plain", "essiv:&lt;esshash&gt;",
+	 *	"benbi", "bewbi".
 	 *
 	 * See comments at iv code
 	 */
@@ -645,6 +661,8 @@ static int crypt_ctr(struct dm_target *t
 		cc-&gt;iv_gen_ops = &amp;crypt_iv_essiv_ops;
 	else if (strcmp(ivmode, "benbi") == 0)
 		cc-&gt;iv_gen_ops = &amp;crypt_iv_benbi_ops;
+	else if (strcmp(ivmode, "bewbi") == 0)
+		cc-&gt;iv_gen_ops = &amp;crypt_iv_bewbi_ops;
 	else {
 		ti-&gt;error = "Invalid IV mode";
 		goto bad2;
-- 
1.4.2.1

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060923174104</emailId><senderName>"Rik Snel"</senderName><senderEmail>rsnel@cube.dyndns.org</senderEmail><timestampReceived>2006-09-23 17:41:04-0400</timestampReceived><subject>[PATCH 2/2] ABL, Arbitrary Block Length, a tweakable wide block cipher mode</subject><body>

From: Rik Snel &lt;rsnel@cube.dyndns.org&gt;

This is a preliminary implementation of ABL as specified by David McGrew
and John Viega in:
- http://grouper.ieee.org/groups/1619/email/rtf00000.rtf (October 28, 2004)
- http://grouper.ieee.org/groups/1619/email/pdf00005.pdf (April 15, 2004)

Preliminary, because the specification has not been sufficiently reviewed and
is subject to change because the two contradict eachother in a few places (see
the comments at the top of abl.c).

Currently I have no official test vectors This implementation is only checked
against an "independent" and minimal userspace implementation I wrote, which
is available at: http://cube.dyndns.org/~rsnel/abl/

I added a self-generated test vector to tcrypt.h and also an ABL specific
speed_test_template because this implementation cannot handle input
shorter than two blocks. The spec allows it, but I chose not to implement it
because it is not needed for harddisk encryption. This implementation also
does not handle partial blocks, while the spec allows it.

Please do not use this mode for anything serious yet.

Signed-off-by: Rik Snel &lt;rsnel@cube.dyndns.org&gt;
---
 crypto/Kconfig  |   14 ++
 crypto/Makefile |    1 
 crypto/abl.c    |  395 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 crypto/tcrypt.c |   12 ++
 crypto/tcrypt.h |  300 ++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 722 insertions(+), 0 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
index dfdfe08..a665079 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -169,6 +169,20 @@ config CRYPTO_LRW
 	  or 256 bits in the key are used for AES and the rest is used to tie
 	  each cipher block to its logical position.
 
+config CRYPTO_ABL
+	tristate "ABL support (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_GF128MUL
+	default n
+	help
+	  ABL: Arbitrary Block Length, a tweakable, non malleable, non movable
+	  wide block cipher mode. Use it with cipher specification string
+	  aes-lrw-bewbi, the key must be 128, 192 or 256 bits. 
+
+	  WARNING: The ABL spec is not finalized and still has to be reviewed.
+	  Do not use this mode for anything serious yet.
+
 config CRYPTO_DES
 	tristate "DES and Triple DES EDE cipher algorithms"
 	select CRYPTO_ALGAPI
diff --git a/crypto/Makefile b/crypto/Makefile
index e2e57be..647019e 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_CRYPTO_GF128MUL) += gf128mu
 obj-$(CONFIG_CRYPTO_ECB) += ecb.o
 obj-$(CONFIG_CRYPTO_CBC) += cbc.o
 obj-$(CONFIG_CRYPTO_LRW) += lrw.o
+obj-$(CONFIG_CRYPTO_ABL) += abl.o
 obj-$(CONFIG_CRYPTO_DES) += des.o
 obj-$(CONFIG_CRYPTO_BLOWFISH) += blowfish.o
 obj-$(CONFIG_CRYPTO_TWOFISH) += twofish.o
diff --git a/crypto/abl.c b/crypto/abl.c
new file mode 100644
index 0000000..2912c8e
--- /dev/null
+++ b/crypto/abl.c
@@ -0,0 +1,395 @@
+/* ABL: as defined by David A. McGrew and John Viega
+ * http://grouper.ieee.org/groups/1619/email/rtf00000.rtf (October 28, 2004)
+ * http://grouper.ieee.org/groups/1619/email/pdf00005.pdf (April 15 2004)
+ *
+ * Copyright (c) 2006 Rik Snel &lt;rsnel@cube.dyndns.org&gt;
+ *
+ * Based om ebc.c
+ * Copyright (c) 2006 Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Limitations: - this module does not support partial blocks
+ *		- the minimum length of the data is 2 blocks
+ *
+ * Both limitations do not exist in the ABL specification, but are do not
+ * influence the use of this module for hard disk encryption
+ *
+ * There are three problems with the current specs.
+ * 1. I use the GHASH specification from the April 15 2004 draft
+ * 2. The decryption formulas in the October 28 2004 draft are written in
+ *    a weird way (the result is at the wrong side of the equation). This is
+ *    a minor issue, it doesnt affect the bitstream.
+ * 3. The specs disagree about the order of the IV and the data in the GHASH
+ *    function. I chose the order from the October 28 2004 draft.
+ */
+#include &lt;crypto/algapi.h&gt;
+#include &lt;linux/err.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include &lt;linux/slab.h&gt;
+
+#include "b128ops.h"
+#include "gf128mul.h"
+
+struct priv {
+	struct crypto_cipher *child;
+	struct gf128mul_64k table; /* mult table for H */
+	u64 l0[2], l1[2], m0[2], m1[2];
+};
+
+static int setkey(struct crypto_tfm *parent, const u8 *key,
+			     unsigned int keylen)
+{
+	struct priv *ctx = crypto_tfm_ctx(parent);
+	struct crypto_cipher *child = ctx-&gt;child;
+	int err;
+	u64 H[2] = { 0, }; /* get proper alignment for the
+			      price of some casts */
+
+	crypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
+	crypto_cipher_set_flags(child, crypto_tfm_get_flags(parent) &amp;
+					CRYPTO_TFM_REQ_MASK);
+	if ((err = crypto_cipher_setkey(child, key, keylen))) return err;
+	crypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &amp;
+					CRYPTO_TFM_RES_MASK);
+
+	crypto_cipher_alg(child)-&gt;cia_encrypt(crypto_cipher_tfm(child),
+			(u8 *)H, (u8 *)H);
+	gf128mul_init_64k_lle(&amp;ctx-&gt;table, H);
+
+	/* setup L0, L1, M0, M1 as per paragraph 5.3 of
+	 * the October 28 2004 draft */
+	memset(ctx-&gt;l0, 0, 16);
+	((u8 *)ctx-&gt;l0)[15] = 0x01; /* 00000001  */
+	crypto_cipher_alg(child)-&gt;cia_encrypt(crypto_cipher_tfm(child),
+			(u8 *)ctx-&gt;l0, (u8 *)ctx-&gt;l0);
+
+	memset(ctx-&gt;l1, 0, 16);
+	((u8 *)ctx-&gt;l1)[15] = 0x02; /* 00000010 */
+	crypto_cipher_alg(child)-&gt;cia_encrypt(crypto_cipher_tfm(child),
+			(u8 *)ctx-&gt;l1, (u8 *)ctx-&gt;l1);
+
+	memset(ctx-&gt;m0, 0, 16);
+	((u8 *)ctx-&gt;m0)[15] = 0x03; /* 00000011 */
+	crypto_cipher_alg(child)-&gt;cia_encrypt(crypto_cipher_tfm(child),
+			(u8 *)ctx-&gt;m0, (u8 *)ctx-&gt;m0);
+
+	memset(ctx-&gt;m1, 0, 16);
+	((u8 *)ctx-&gt;m1)[15] = 0x04; /* 00000100 */
+	crypto_cipher_alg(child)-&gt;cia_encrypt(crypto_cipher_tfm(child),
+			(u8 *)ctx-&gt;m1, (u8 *)ctx-&gt;m1);
+
+	return 0;
+}
+
+struct sinfo {
+	const int bs;
+	u64 b1[2], b2[2], *m;
+	struct gf128mul_64k *t;
+	u8 **iv; /* we need to pass the iv to the inner
+		    loop, this is a way to doing that */
+
+	/* sometimes we must read from *src and sometimes from *dst,
+	   this must be set by the caller to help us decide */
+	int rd_dst;
+
+	struct crypto_tfm *tfm;
+	void (*fn)(struct crypto_tfm*, u8 *, const u8 *);
+};
+
+/* this define makes it easy to read from the right place */
+#define SRC (s-&gt;rd_dst ? dst : src)
+
+/* round is the function that is called for the first round, it
+ * may not be NULL, it must return the function (pointer) to
+ * be used for the next block also non-NULL */
+static int do_stuff(struct blkcipher_desc *d,
+		struct blkcipher_walk *w, struct sinfo *s,
+		void *(*round)(struct sinfo*, u8 *, const u8 *))
+{
+	unsigned int nbytes_avail;
+	int err;
+
+	err = blkcipher_walk_virt(d, w);
+
+	while ((nbytes_avail = w-&gt;nbytes)) {
+		u8 *src = w-&gt;src.virt.addr;
+		u8 *dst = w-&gt;dst.virt.addr;
+
+		do {
+			round = round(s, dst, src);
+
+			src += s-&gt;bs;
+			dst += s-&gt;bs;
+		} while ((nbytes_avail -= s-&gt;bs) &gt;= s-&gt;bs);
+
+		blkcipher_walk_done(d, w, nbytes_avail);
+	}
+
+	return err;
+}
+
+/* add a complete block to the ghash, don't write anything to dst (!) */
+static inline void *ghash_add_block(struct sinfo *s, u8 *dst, const u8 *src)
+{
+	b128ops_xor(s-&gt;b1, SRC);
+	gf128mul_64k_lle(s-&gt;b1, s-&gt;t, s-&gt;b2);
+	return ghash_add_block;
+}
+
+static void *ghash_init_add_iv(struct sinfo *s, u8 *dst, const u8 *src)
+{
+	memset(s-&gt;b1, 0, 16);
+
+	/* ghash_add_block may read from src as well as from dst (depending
+	 * on s-&gt;rd_dst), we supply the iv in both places since it never
+	 * writes to dst */
+	ghash_add_block(s, *s-&gt;iv, *s-&gt;iv);
+	return ghash_add_block;
+}
+
+static void ghash_finalize_calc_f(struct sinfo *s, u32 lx, u64 l[2])
+{
+	u64 last[2] = { cpu_to_be64(16&lt;&lt;3), cpu_to_be64(((u64)lx)&lt;&lt;3) };
+	b128ops_xor(s-&gt;b1, last);
+	gf128mul_64k_lle(s-&gt;b1, s-&gt;t, s-&gt;b2);
+	b128ops_xor(s-&gt;b1, l);
+	s-&gt;fn(s-&gt;tfm, (u8 *)s-&gt;b1, (u8 *)s-&gt;b1);
+}
+
+/* increment the bigendian u32 at incd */
+static void inc(u8 *incd)
+{
+	int left = 3;
+	while (!++incd[left]) {
+		if (!left--) return;
+	}
+}
+
+static void *xor_g(struct sinfo *s, u8 *dst, const u8 *src)
+{
+	b128ops_mov(s-&gt;b2, s-&gt;b1);
+	b128ops_xor(s-&gt;b2, s-&gt;m);
+	s-&gt;fn(s-&gt;tfm, (u8 *)s-&gt;b2, (u8 *)s-&gt;b2);
+	b128ops_xor(s-&gt;b2, SRC);
+	b128ops_mov(dst, s-&gt;b2);
+	inc((u8 *)s-&gt;b1 + 12);
+	return xor_g;
+}
+
+static void *xor_f_init_g(struct sinfo *s, u8 *dst, const u8 *src)
+{
+	b128ops_xor(s-&gt;b1, SRC);
+	b128ops_mov(dst, s-&gt;b1);
+	return xor_g;
+}
+
+static void *init_g(struct sinfo *s, u8 *dst, const u8 *src)
+{
+	b128ops_mov(s-&gt;b1, SRC);
+	b128ops_mov(dst, s-&gt;b1);
+	return xor_g;
+}
+
+static int crypt_common(struct sinfo *s, struct priv *ctx,
+		struct blkcipher_walk *w, unsigned int n)
+{
+	if (n &lt; 32) {
+		printk("ABL for streams &lt; 2 blocks not implemented");
+		return -EINVAL; /* there may be a more appropriate message... */
+	}
+
+	s-&gt;iv = &amp;w-&gt;iv;
+	s-&gt;t = &amp;ctx-&gt;table;
+	s-&gt;tfm = crypto_cipher_tfm(ctx-&gt;child);
+	s-&gt;fn = crypto_cipher_alg(ctx-&gt;child)-&gt;cia_encrypt;
+	s-&gt;rd_dst = 0;
+
+	return 0;
+}
+
+static int encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,
+		struct scatterlist *src, unsigned int nbytes)
+{
+	struct priv *ctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk w;
+	struct sinfo s = { .bs = crypto_cipher_blocksize(ctx-&gt;child) };
+	int err;
+
+	if ((err = crypt_common(&amp;s, ctx, &amp;w, nbytes))) return err;
+
+	/* calc f0(H, Z, B) */
+	blkcipher_walk_init(&amp;w, dst, src, nbytes);
+	if ((err = do_stuff(desc, &amp;w, &amp;s, ghash_init_add_iv))) return err;
+	ghash_finalize_calc_f(&amp;s, nbytes - 16, ctx-&gt;l0);
+
+	/* C &lt;- A xor f0(H, Z, B)
+	 * D &lt;- B xor g0(K, C) */
+	s.m = ctx-&gt;m0; /* set the correct value of m */
+	blkcipher_walk_init(&amp;w, dst, src, nbytes);
+	if ((err = do_stuff(desc, &amp;w, &amp;s, xor_f_init_g))) return err;
+
+	/* from here the data is in *dst, so read it from there */
+	s.rd_dst = 1;
+
+	/* calc f1(H, Z, D) */
+	blkcipher_walk_init(&amp;w, dst, src, nbytes);
+	if ((err = do_stuff(desc, &amp;w, &amp;s, ghash_init_add_iv))) return err;
+	ghash_finalize_calc_f(&amp;s, nbytes - 16, ctx-&gt;l1);
+
+	/* E &lt;- C xor f1(H, Z, D)
+	 * F &lt;- D xor g1(K, E) */
+	s.m = ctx-&gt;m1; /* set the correct value of m */
+	blkcipher_walk_init(&amp;w, dst, src, nbytes);
+	err = do_stuff(desc, &amp;w, &amp;s, xor_f_init_g);
+
+	return err;
+}
+
+static int decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,
+		struct scatterlist *src, unsigned int nbytes)
+{
+	struct priv *ctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	struct blkcipher_walk w;
+	struct sinfo s = { .bs = crypto_cipher_blocksize(ctx-&gt;child) };
+	int err;
+
+	if ((err = crypt_common(&amp;s, ctx, &amp;w, nbytes))) return err;
+
+	/* D &lt;- F xor g1(K, E) */
+	s.m = ctx-&gt;m1; /* set the correct value of m */
+	blkcipher_walk_init(&amp;w, dst, src, nbytes);
+	if ((err = do_stuff(desc, &amp;w, &amp;s, init_g))) return err;
+
+	/* from here the data is in *dst, so read it from there */
+	s.rd_dst = 1;
+
+	/* calc f1(H, Z, D) */
+	blkcipher_walk_init(&amp;w, dst, src, nbytes);
+	if ((err = do_stuff(desc, &amp;w, &amp;s, ghash_init_add_iv))) return err;
+	ghash_finalize_calc_f(&amp;s, nbytes - 16, ctx-&gt;l1);
+
+	/* C &lt;- E xor f1(H, Z, D)
+	 * B &lt;- D xor g0(K, C) */
+	s.m = ctx-&gt;m0; /* set the correct value of m */
+	blkcipher_walk_init(&amp;w, dst, src, nbytes);
+	if ((err = do_stuff(desc, &amp;w, &amp;s, xor_f_init_g))) return err;
+
+	/* calc f0(H, Z, B) */
+	blkcipher_walk_init(&amp;w, dst, src, nbytes);
+	if ((err = do_stuff(desc, &amp;w, &amp;s, ghash_init_add_iv))) return err;
+	ghash_finalize_calc_f(&amp;s, nbytes - 16, ctx-&gt;l0);
+
+	/* A &lt;- C xor f0(H, Z, B) (we only need the first block) */
+	blkcipher_walk_init(&amp;w, dst, src, nbytes);
+	err = blkcipher_walk_virt(desc, &amp;w);
+	if (w.nbytes) b128ops_xor(w.dst.virt.addr, s.b1);
+
+	return err;
+}
+
+static int init_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_instance *inst = (void *)tfm-&gt;__crt_alg;
+	struct crypto_spawn *spawn = crypto_instance_ctx(inst);
+	struct priv *ctx = crypto_tfm_ctx(tfm);
+	u32 *flags = &amp;tfm-&gt;crt_flags;
+
+	tfm = crypto_spawn_tfm(spawn);
+	if (IS_ERR(tfm))
+		return PTR_ERR(tfm);
+
+	if (crypto_tfm_alg_blocksize(tfm) != 16) {
+		*flags |= CRYPTO_TFM_RES_BAD_BLOCK_LEN;
+		return -EINVAL;
+	}
+
+	ctx-&gt;child = crypto_cipher_cast(tfm);
+	return 0;
+}
+
+static void exit_tfm(struct crypto_tfm *tfm)
+{
+	struct priv *ctx = crypto_tfm_ctx(tfm);
+	crypto_free_cipher(ctx-&gt;child);
+}
+
+static struct crypto_instance *alloc(void *param, unsigned int len)
+{
+	struct crypto_instance *inst;
+	struct crypto_alg *alg;
+
+	alg = crypto_get_attr_alg(param, len, CRYPTO_ALG_TYPE_CIPHER,
+				  CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_ASYNC);
+	if (IS_ERR(alg))
+		return ERR_PTR(PTR_ERR(alg));
+
+	inst = crypto_alloc_instance("abl", alg);
+	if (IS_ERR(inst))
+		goto out_put_alg;
+
+	inst-&gt;alg.cra_flags = CRYPTO_ALG_TYPE_BLKCIPHER;
+	inst-&gt;alg.cra_priority = alg-&gt;cra_priority;
+	inst-&gt;alg.cra_blocksize = alg-&gt;cra_blocksize;
+
+	if (alg-&gt;cra_alignmask &lt; sizeof(int) - 1)
+		inst-&gt;alg.cra_alignmask = sizeof(int) -1;
+	else inst-&gt;alg.cra_alignmask = alg-&gt;cra_alignmask;
+	inst-&gt;alg.cra_type = &amp;crypto_blkcipher_type;
+
+	inst-&gt;alg.cra_type = &amp;crypto_blkcipher_type;
+
+	if (!(alg-&gt;cra_blocksize % 4))
+		inst-&gt;alg.cra_alignmask |= 3;
+	inst-&gt;alg.cra_blkcipher.ivsize = alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_blkcipher.min_keysize = alg-&gt;cra_cipher.cia_min_keysize;
+	inst-&gt;alg.cra_blkcipher.max_keysize = alg-&gt;cra_cipher.cia_max_keysize;
+
+	inst-&gt;alg.cra_ctxsize = sizeof(struct priv);
+
+	inst-&gt;alg.cra_init = init_tfm;
+	inst-&gt;alg.cra_exit = exit_tfm;
+
+	inst-&gt;alg.cra_blkcipher.setkey = setkey;
+	inst-&gt;alg.cra_blkcipher.encrypt = encrypt;
+	inst-&gt;alg.cra_blkcipher.decrypt = decrypt;
+
+out_put_alg:
+	crypto_mod_put(alg);
+	return inst;
+}
+
+static void free(struct crypto_instance *inst)
+{
+	crypto_drop_spawn(crypto_instance_ctx(inst));
+	kfree(inst);
+}
+
+static struct crypto_template crypto_tmpl = {
+	.name = "abl",
+	.alloc = alloc,
+	.free = free,
+	.module = THIS_MODULE,
+};
+
+static int __init crypto_module_init(void)
+{
+	return crypto_register_template(&amp;crypto_tmpl);
+}
+
+static void __exit crypto_module_exit(void)
+{
+	crypto_unregister_template(&amp;crypto_tmpl);
+}
+
+module_init(crypto_module_init);
+module_exit(crypto_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("ABL block cipher mode");
diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
index 777fc63..32c8457 100644
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -910,6 +910,10 @@ static void do_test(void)
 			    AES_LRW_ENC_TEST_VECTORS);
 		test_cipher("lrw(aes)", DECRYPT, aes_lrw_dec_tv_template,
 			    AES_LRW_DEC_TEST_VECTORS);
+		test_cipher("abl(aes)", ENCRYPT, aes_abl_enc_tv_template,
+			    AES_ABL_ENC_TEST_VECTORS);
+		test_cipher("abl(aes)", DECRYPT, aes_abl_dec_tv_template,
+			    AES_ABL_DEC_TEST_VECTORS);
 
 		//CAST5
 		test_cipher("ecb(cast5)", ENCRYPT, cast5_enc_tv_template,
@@ -1060,6 +1064,10 @@ static void do_test(void)
 			    AES_LRW_ENC_TEST_VECTORS);
 		test_cipher("lrw(aes)", DECRYPT, aes_lrw_dec_tv_template,
 			    AES_LRW_DEC_TEST_VECTORS);
+		test_cipher("abl(aes)", ENCRYPT, aes_abl_enc_tv_template,
+			    AES_ABL_ENC_TEST_VECTORS);
+		test_cipher("abl(aes)", DECRYPT, aes_abl_dec_tv_template,
+			    AES_ABL_DEC_TEST_VECTORS);
 		break;
 
 	case 11:
@@ -1203,6 +1211,10 @@ static void do_test(void)
 				  aes_lrw_speed_template);
 		test_cipher_speed("lrw(aes)", DECRYPT, sec, NULL, 0,
 				  aes_lrw_speed_template);
+		test_cipher_speed("abl(aes)", ENCRYPT, sec, NULL, 0,
+				  aes_abl_speed_template);
+		test_cipher_speed("abl(aes)", DECRYPT, sec, NULL, 0,
+				  aes_abl_speed_template);
 		break;
 
 	case 201:
diff --git a/crypto/tcrypt.h b/crypto/tcrypt.h
index 59fbc39..d6696b2 100644
--- a/crypto/tcrypt.h
+++ b/crypto/tcrypt.h
@@ -1833,6 +1833,8 @@ #define AES_CBC_ENC_TEST_VECTORS 2
 #define AES_CBC_DEC_TEST_VECTORS 2
 #define AES_LRW_ENC_TEST_VECTORS 8
 #define AES_LRW_DEC_TEST_VECTORS 8
+#define AES_ABL_ENC_TEST_VECTORS 1
+#define AES_ABL_DEC_TEST_VECTORS 1
 
 static struct cipher_testvec aes_enc_tv_template[] = {
 	{ /* From FIPS-197 */
@@ -2473,6 +2475,286 @@ static struct cipher_testvec aes_lrw_dec
 	}
 };
 
+static struct cipher_testvec aes_abl_enc_tv_template[] = {
+	{ /* self-generated based on mostly independent implementation */
+		.key    = { 0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
+			    0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08 },
+		.klen   = 16,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
+		.input  = { 0xaa, 0x31, 0x30, 0x88, 0xdb, 0xbc, 0x32, 0xb6,
+			    0x71, 0xd6, 0x5d, 0x31, 0x3d, 0x91, 0x01, 0xf5,
+			    0x11, 0x5f, 0x4b, 0xdd, 0x4f, 0x6c, 0x01, 0xd4,
+			    0x57, 0xb3, 0x5f, 0x0f, 0x7a, 0x55, 0x5a, 0xc4,
+			    0x51, 0x59, 0xcf, 0x6b, 0x49, 0x77, 0x0e, 0x46,
+			    0xb0, 0x7e, 0xa8, 0xa9, 0x4e, 0x0f, 0xb1, 0x4f,
+			    0x56, 0xa8, 0x5b, 0x96, 0x7a, 0xa4, 0x68, 0x19,
+			    0xbd, 0x7f, 0x50, 0x58, 0x5c, 0x24, 0x09, 0x0a,
+			    0x8f, 0x58, 0xb9, 0x29, 0x05, 0x8a, 0x53, 0xdd,
+			    0x87, 0x7c, 0x7e, 0x89, 0x9b, 0xf7, 0x59, 0xdf,
+			    0x8f, 0x31, 0xa4, 0x91, 0x41, 0x85, 0x21, 0x99,
+			    0xbf, 0x15, 0x20, 0xc0, 0xd3, 0xba, 0xe1, 0x55,
+			    0x50, 0xd2, 0x08, 0xd1, 0xe0, 0xb5, 0x56, 0xd5,
+			    0xe6, 0x3e, 0xbc, 0xac, 0xf5, 0x6f, 0x9d, 0xcc,
+			    0x53, 0xad, 0xfb, 0x1b, 0x75, 0xcf, 0xd5, 0x96,
+			    0x3a, 0x96, 0xe5, 0x66, 0x40, 0x74, 0x10, 0xfe,
+			    0xe8, 0xe3, 0x54, 0xcb, 0x4d, 0x3e, 0x8c, 0x53,
+			    0x30, 0x3d, 0xdf, 0xe4, 0x30, 0xe3, 0x1c, 0x83,
+			    0xdb, 0xd8, 0x2e, 0xe8, 0x3a, 0x85, 0xed, 0x6b,
+			    0xd4, 0xa7, 0x69, 0x1d, 0x6f, 0xb5, 0xca, 0x0b,
+			    0x73, 0x94, 0x09, 0xb3, 0xfe, 0xa0, 0x18, 0x56,
+			    0x6a, 0x3f, 0xa1, 0x1c, 0xee, 0x5c, 0xa5, 0xc0,
+			    0x59, 0x38, 0xe7, 0x28, 0xf6, 0x0e, 0xd9, 0xd7,
+			    0xdd, 0x1d, 0x38, 0x71, 0xed, 0xdf, 0xc5, 0x21,
+			    0x31, 0x1f, 0xcb, 0xa3, 0x0c, 0xfb, 0xc2, 0xe0,
+			    0x27, 0xf0, 0x76, 0xa8, 0x39, 0xac, 0xdc, 0x61,
+			    0x00, 0x4e, 0xf3, 0xe5, 0xb7, 0x5c, 0xdc, 0xfa,
+			    0xec, 0x00, 0x5d, 0x2e, 0x94, 0x9f, 0x70, 0xe2,
+			    0xb0, 0x7c, 0x2d, 0xb0, 0xca, 0x0b, 0x60, 0x12,
+			    0xea, 0x9d, 0x1e, 0xfc, 0x78, 0x29, 0xbf, 0xcf,
+			    0x13, 0x2c, 0x86, 0x9a, 0x47, 0xfb, 0x4b, 0xf5,
+			    0xf0, 0x2c, 0x62, 0xfd, 0xda, 0x4b, 0x4e, 0xe8,
+			    0xa0, 0x83, 0xb0, 0x56, 0x81, 0x25, 0x88, 0x36,
+			    0xad, 0xbb, 0x4f, 0x6e, 0xa7, 0x03, 0x69, 0xc4,
+			    0x10, 0xac, 0x6c, 0xac, 0xe3, 0xcc, 0x66, 0xaf,
+			    0xbb, 0x52, 0x20, 0x5f, 0x66, 0x98, 0x3d, 0x67,
+			    0x2b, 0x5d, 0xd9, 0xb8, 0x1c, 0x82, 0x48, 0x35,
+			    0x19, 0xc1, 0xe7, 0x62, 0x18, 0x90, 0xd8, 0x75,
+			    0xde, 0x9e, 0x1d, 0x91, 0x9a, 0x8b, 0xba, 0x41,
+			    0xa1, 0xcd, 0xf6, 0x04, 0xc5, 0x76, 0xaf, 0x2d,
+			    0x6e, 0xef, 0xd8, 0x72, 0x1a, 0x51, 0xff, 0x1e,
+			    0x26, 0x29, 0x37, 0x23, 0x27, 0x26, 0x08, 0x77,
+			    0xfe, 0x73, 0xa6, 0x7a, 0x1e, 0x36, 0xb4, 0x74,
+			    0xe3, 0x4a, 0xcd, 0xc5, 0x19, 0x6e, 0x59, 0xf3,
+			    0xd7, 0x89, 0xfd, 0x14, 0xad, 0xed, 0x4e, 0xbe,
+			    0x1a, 0xd5, 0x87, 0xec, 0x3d, 0x46, 0x2f, 0x08,
+			    0x47, 0x42, 0x76, 0xb6, 0x9e, 0x70, 0x0e, 0x57,
+			    0x72, 0x16, 0xb4, 0x69, 0xd6, 0xc1, 0x39, 0x5b,
+			    0xdb, 0x9f, 0xfb, 0xb3, 0x36, 0xcf, 0xd5, 0x42,
+			    0x06, 0x72, 0xfd, 0x11, 0xaf, 0x56, 0x2b, 0x16,
+			    0xdc, 0xb9, 0x84, 0x43, 0xca, 0x94, 0x71, 0x1b,
+			    0xb6, 0x32, 0xc3, 0x16, 0xb0, 0x2a, 0x3b, 0xaf,
+			    0x90, 0xf6, 0xa8, 0x08, 0x9c, 0x82, 0xba, 0x0a,
+			    0x9f, 0x61, 0x4d, 0x3e, 0x35, 0x0a, 0x7f, 0x17,
+			    0x2d, 0x1d, 0x22, 0xa8, 0xdf, 0x48, 0xbb, 0xec,
+			    0xf6, 0x0c, 0x21, 0x1a, 0x8f, 0xb9, 0x79, 0xc9,
+			    0xba, 0xd5, 0xac, 0x11, 0x34, 0x90, 0x4f, 0x75,
+			    0x51, 0x7e, 0x7b, 0xa2, 0xf7, 0x47, 0x48, 0xd1,
+			    0x56, 0xad, 0x1d, 0xf2, 0x6a, 0x9b, 0x7c, 0xf2,
+			    0xd3, 0x67, 0xd8, 0x77, 0x42, 0xe2, 0x41, 0x24,
+			    0x1e, 0x60, 0x81, 0x5d, 0x99, 0xa8, 0x91, 0x3e,
+			    0x55, 0xea, 0xda, 0xb2, 0x1b, 0x46, 0x82, 0x6f,
+			    0x14, 0x18, 0xc8, 0x61, 0x89, 0xcc, 0x8c, 0x03,
+			    0x43, 0x4f, 0xb4, 0xe6, 0xdc, 0xc0, 0xb3, 0x80 },
+		.ilen   = 512,
+		.result = { 0xab, 0xd1, 0x19, 0xa6, 0x58, 0xd9, 0x51, 0xf6,
+			    0x45, 0x67, 0x1b, 0xab, 0x2f, 0x75, 0x4b, 0x22,
+			    0xa5, 0x5b, 0x1d, 0xdb, 0x50, 0x9c, 0x60, 0xe3,
+			    0xf8, 0x39, 0x01, 0x5d, 0xbc, 0x67, 0x6f, 0x6a,
+			    0x52, 0xda, 0x36, 0xa3, 0x7b, 0xce, 0x3e, 0x1c,
+			    0x9e, 0x35, 0xef, 0x65, 0xf3, 0x9a, 0x58, 0x1c,
+			    0x6a, 0xa0, 0x78, 0x15, 0x8a, 0x93, 0x94, 0xb6,
+			    0x2d, 0xfc, 0xca, 0x2c, 0x35, 0x0f, 0x98, 0x51,
+			    0x5d, 0x92, 0xb5, 0xfe, 0xb9, 0x82, 0xda, 0x7b,
+			    0x4b, 0xd6, 0xe5, 0xd8, 0xc0, 0x27, 0x16, 0x47,
+			    0x04, 0x36, 0x1f, 0xcf, 0xfc, 0x06, 0x68, 0x10,
+			    0x86, 0x6e, 0xcc, 0x2a, 0x17, 0xa8, 0x65, 0x59,
+			    0x35, 0x78, 0x20, 0x0f, 0xc8, 0xf5, 0x14, 0xad,
+			    0xa3, 0x1b, 0x0a, 0x50, 0x72, 0xdd, 0x19, 0xa2,
+			    0xa3, 0xe1, 0x2c, 0x6f, 0xcc, 0x85, 0xe5, 0x46,
+			    0x17, 0xf4, 0x0c, 0x59, 0xde, 0xfa, 0x73, 0x15,
+			    0x4e, 0x75, 0x00, 0x6c, 0x0f, 0x1e, 0xe6, 0xa0,
+			    0x86, 0x7c, 0xe6, 0xf8, 0x1b, 0xcc, 0x90, 0x90,
+			    0x2e, 0x9c, 0x76, 0x19, 0x49, 0xea, 0xab, 0x9f,
+			    0x7c, 0xd0, 0x22, 0x8a, 0x85, 0xc5, 0xe6, 0x74,
+			    0x6a, 0xce, 0xe9, 0x05, 0x9b, 0x16, 0x1e, 0xe4,
+			    0x31, 0x5a, 0x33, 0xd9, 0x28, 0xb6, 0xc4, 0xe9,
+			    0xf6, 0xa4, 0x71, 0xe0, 0xa4, 0x93, 0x1e, 0x13,
+			    0xee, 0x35, 0x96, 0x4c, 0xb4, 0xf6, 0xfa, 0xa4,
+			    0xab, 0x35, 0xec, 0x7d, 0x7f, 0x85, 0x0c, 0x95,
+			    0xc4, 0x76, 0x76, 0xbc, 0xcd, 0xb1, 0xed, 0x91,
+			    0xa5, 0xfd, 0x92, 0x67, 0x5f, 0x16, 0x29, 0xf9,
+			    0xb0, 0xdb, 0x66, 0x2f, 0x3b, 0x78, 0x1c, 0xfd,
+			    0x05, 0xd3, 0x6f, 0xe0, 0x77, 0xf6, 0x0b, 0xba,
+			    0x16, 0x8d, 0x48, 0x77, 0xf7, 0xbc, 0xe0, 0x65,
+			    0xb8, 0x33, 0xa6, 0xfc, 0xae, 0xc6, 0xb5, 0x34,
+			    0xf5, 0x7a, 0x3d, 0x8e, 0x36, 0x70, 0xd4, 0x80,
+			    0xdb, 0x86, 0xa2, 0xbe, 0xb0, 0xb6, 0x40, 0xa8,
+			    0xd6, 0x84, 0x97, 0x8a, 0xa9, 0x30, 0x7c, 0xfa,
+			    0xf3, 0x1a, 0x3a, 0xd0, 0xf7, 0xad, 0x4b, 0x8f,
+			    0x60, 0x86, 0xf7, 0xb8, 0xb9, 0xfb, 0x6f, 0x9b,
+			    0x52, 0xbc, 0x8a, 0x11, 0x85, 0xfa, 0xab, 0x89,
+			    0x1f, 0x8c, 0x39, 0xb3, 0xbd, 0x44, 0x34, 0xe0,
+			    0x6f, 0x59, 0x7c, 0x02, 0x75, 0x3e, 0x12, 0x77,
+			    0xa6, 0x78, 0xf0, 0xea, 0x62, 0xbf, 0x40, 0x64,
+			    0xde, 0xb1, 0xb5, 0xe1, 0x2c, 0x92, 0x1c, 0xda,
+			    0xe7, 0xeb, 0xb0, 0x1d, 0x23, 0x94, 0x15, 0x42,
+			    0x46, 0x2a, 0xa5, 0x64, 0x13, 0x23, 0xec, 0x67,
+			    0x3e, 0xae, 0xcc, 0xd9, 0xd8, 0x1f, 0x87, 0x59,
+			    0x9c, 0x8c, 0xc4, 0xeb, 0xa5, 0x9e, 0xf7, 0x49,
+			    0xf9, 0xe3, 0x7e, 0x6a, 0x0a, 0xd0, 0x51, 0xc2,
+			    0x04, 0xbe, 0xce, 0x6e, 0xa4, 0x0f, 0x50, 0xb0,
+			    0xf9, 0xb5, 0xd8, 0x67, 0xb5, 0x55, 0x03, 0x75,
+			    0xae, 0x28, 0xa3, 0xe4, 0x30, 0xcd, 0x95, 0x23,
+			    0x7f, 0x05, 0xf7, 0xa3, 0x68, 0x8b, 0x08, 0x42,
+			    0xf1, 0x9a, 0xb1, 0x8c, 0xae, 0x8f, 0x9c, 0xc4,
+			    0x37, 0xf6, 0x04, 0xaf, 0x8c, 0x2d, 0xc7, 0xe3,
+			    0x32, 0x8d, 0xe6, 0xc9, 0x7d, 0x5c, 0x4e, 0xd6,
+			    0xa4, 0x9f, 0x28, 0xf9, 0x78, 0x25, 0x25, 0x19,
+			    0x77, 0xa7, 0x9a, 0x30, 0xcd, 0x19, 0x30, 0x62,
+			    0x5f, 0x13, 0xab, 0x81, 0x23, 0xc3, 0x6c, 0x77,
+			    0x24, 0xb4, 0x03, 0x22, 0x96, 0x58, 0x66, 0x25,
+			    0x87, 0x11, 0xe9, 0x12, 0xc4, 0x29, 0xba, 0xc3,
+			    0x2a, 0xad, 0xb6, 0xb4, 0x96, 0x6a, 0x82, 0x36,
+			    0xdb, 0x7d, 0xf1, 0x1c, 0x6e, 0xf8, 0xa2, 0x84,
+			    0xd5, 0x2a, 0xf7, 0x41, 0xf6, 0x2a, 0xff, 0xd7,
+			    0x9c, 0x7f, 0x6e, 0x7a, 0xbe, 0xa5, 0x7e, 0xc2,
+			    0xe6, 0x28, 0x9c, 0xdb, 0x73, 0x67, 0x15, 0xad,
+			    0x09, 0xbf, 0x73, 0x90, 0x2b, 0x64, 0xef, 0x12 },
+		.rlen   = 512,
+	}
+};
+
+static struct cipher_testvec aes_abl_dec_tv_template[] = {
+	{ /* self-generated based on mostly independent implementation */
+		.key    = { 0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
+			    0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08 },
+		.klen   = 16,
+		.iv     = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
+		.input  = { 0xab, 0xd1, 0x19, 0xa6, 0x58, 0xd9, 0x51, 0xf6,
+			    0x45, 0x67, 0x1b, 0xab, 0x2f, 0x75, 0x4b, 0x22,
+			    0xa5, 0x5b, 0x1d, 0xdb, 0x50, 0x9c, 0x60, 0xe3,
+			    0xf8, 0x39, 0x01, 0x5d, 0xbc, 0x67, 0x6f, 0x6a,
+			    0x52, 0xda, 0x36, 0xa3, 0x7b, 0xce, 0x3e, 0x1c,
+			    0x9e, 0x35, 0xef, 0x65, 0xf3, 0x9a, 0x58, 0x1c,
+			    0x6a, 0xa0, 0x78, 0x15, 0x8a, 0x93, 0x94, 0xb6,
+			    0x2d, 0xfc, 0xca, 0x2c, 0x35, 0x0f, 0x98, 0x51,
+			    0x5d, 0x92, 0xb5, 0xfe, 0xb9, 0x82, 0xda, 0x7b,
+			    0x4b, 0xd6, 0xe5, 0xd8, 0xc0, 0x27, 0x16, 0x47,
+			    0x04, 0x36, 0x1f, 0xcf, 0xfc, 0x06, 0x68, 0x10,
+			    0x86, 0x6e, 0xcc, 0x2a, 0x17, 0xa8, 0x65, 0x59,
+			    0x35, 0x78, 0x20, 0x0f, 0xc8, 0xf5, 0x14, 0xad,
+			    0xa3, 0x1b, 0x0a, 0x50, 0x72, 0xdd, 0x19, 0xa2,
+			    0xa3, 0xe1, 0x2c, 0x6f, 0xcc, 0x85, 0xe5, 0x46,
+			    0x17, 0xf4, 0x0c, 0x59, 0xde, 0xfa, 0x73, 0x15,
+			    0x4e, 0x75, 0x00, 0x6c, 0x0f, 0x1e, 0xe6, 0xa0,
+			    0x86, 0x7c, 0xe6, 0xf8, 0x1b, 0xcc, 0x90, 0x90,
+			    0x2e, 0x9c, 0x76, 0x19, 0x49, 0xea, 0xab, 0x9f,
+			    0x7c, 0xd0, 0x22, 0x8a, 0x85, 0xc5, 0xe6, 0x74,
+			    0x6a, 0xce, 0xe9, 0x05, 0x9b, 0x16, 0x1e, 0xe4,
+			    0x31, 0x5a, 0x33, 0xd9, 0x28, 0xb6, 0xc4, 0xe9,
+			    0xf6, 0xa4, 0x71, 0xe0, 0xa4, 0x93, 0x1e, 0x13,
+			    0xee, 0x35, 0x96, 0x4c, 0xb4, 0xf6, 0xfa, 0xa4,
+			    0xab, 0x35, 0xec, 0x7d, 0x7f, 0x85, 0x0c, 0x95,
+			    0xc4, 0x76, 0x76, 0xbc, 0xcd, 0xb1, 0xed, 0x91,
+			    0xa5, 0xfd, 0x92, 0x67, 0x5f, 0x16, 0x29, 0xf9,
+			    0xb0, 0xdb, 0x66, 0x2f, 0x3b, 0x78, 0x1c, 0xfd,
+			    0x05, 0xd3, 0x6f, 0xe0, 0x77, 0xf6, 0x0b, 0xba,
+			    0x16, 0x8d, 0x48, 0x77, 0xf7, 0xbc, 0xe0, 0x65,
+			    0xb8, 0x33, 0xa6, 0xfc, 0xae, 0xc6, 0xb5, 0x34,
+			    0xf5, 0x7a, 0x3d, 0x8e, 0x36, 0x70, 0xd4, 0x80,
+			    0xdb, 0x86, 0xa2, 0xbe, 0xb0, 0xb6, 0x40, 0xa8,
+			    0xd6, 0x84, 0x97, 0x8a, 0xa9, 0x30, 0x7c, 0xfa,
+			    0xf3, 0x1a, 0x3a, 0xd0, 0xf7, 0xad, 0x4b, 0x8f,
+			    0x60, 0x86, 0xf7, 0xb8, 0xb9, 0xfb, 0x6f, 0x9b,
+			    0x52, 0xbc, 0x8a, 0x11, 0x85, 0xfa, 0xab, 0x89,
+			    0x1f, 0x8c, 0x39, 0xb3, 0xbd, 0x44, 0x34, 0xe0,
+			    0x6f, 0x59, 0x7c, 0x02, 0x75, 0x3e, 0x12, 0x77,
+			    0xa6, 0x78, 0xf0, 0xea, 0x62, 0xbf, 0x40, 0x64,
+			    0xde, 0xb1, 0xb5, 0xe1, 0x2c, 0x92, 0x1c, 0xda,
+			    0xe7, 0xeb, 0xb0, 0x1d, 0x23, 0x94, 0x15, 0x42,
+			    0x46, 0x2a, 0xa5, 0x64, 0x13, 0x23, 0xec, 0x67,
+			    0x3e, 0xae, 0xcc, 0xd9, 0xd8, 0x1f, 0x87, 0x59,
+			    0x9c, 0x8c, 0xc4, 0xeb, 0xa5, 0x9e, 0xf7, 0x49,
+			    0xf9, 0xe3, 0x7e, 0x6a, 0x0a, 0xd0, 0x51, 0xc2,
+			    0x04, 0xbe, 0xce, 0x6e, 0xa4, 0x0f, 0x50, 0xb0,
+			    0xf9, 0xb5, 0xd8, 0x67, 0xb5, 0x55, 0x03, 0x75,
+			    0xae, 0x28, 0xa3, 0xe4, 0x30, 0xcd, 0x95, 0x23,
+			    0x7f, 0x05, 0xf7, 0xa3, 0x68, 0x8b, 0x08, 0x42,
+			    0xf1, 0x9a, 0xb1, 0x8c, 0xae, 0x8f, 0x9c, 0xc4,
+			    0x37, 0xf6, 0x04, 0xaf, 0x8c, 0x2d, 0xc7, 0xe3,
+			    0x32, 0x8d, 0xe6, 0xc9, 0x7d, 0x5c, 0x4e, 0xd6,
+			    0xa4, 0x9f, 0x28, 0xf9, 0x78, 0x25, 0x25, 0x19,
+			    0x77, 0xa7, 0x9a, 0x30, 0xcd, 0x19, 0x30, 0x62,
+			    0x5f, 0x13, 0xab, 0x81, 0x23, 0xc3, 0x6c, 0x77,
+			    0x24, 0xb4, 0x03, 0x22, 0x96, 0x58, 0x66, 0x25,
+			    0x87, 0x11, 0xe9, 0x12, 0xc4, 0x29, 0xba, 0xc3,
+			    0x2a, 0xad, 0xb6, 0xb4, 0x96, 0x6a, 0x82, 0x36,
+			    0xdb, 0x7d, 0xf1, 0x1c, 0x6e, 0xf8, 0xa2, 0x84,
+			    0xd5, 0x2a, 0xf7, 0x41, 0xf6, 0x2a, 0xff, 0xd7,
+			    0x9c, 0x7f, 0x6e, 0x7a, 0xbe, 0xa5, 0x7e, 0xc2,
+			    0xe6, 0x28, 0x9c, 0xdb, 0x73, 0x67, 0x15, 0xad,
+			    0x09, 0xbf, 0x73, 0x90, 0x2b, 0x64, 0xef, 0x12 },
+		.ilen   = 512,
+		.result = { 0xaa, 0x31, 0x30, 0x88, 0xdb, 0xbc, 0x32, 0xb6,
+			    0x71, 0xd6, 0x5d, 0x31, 0x3d, 0x91, 0x01, 0xf5,
+			    0x11, 0x5f, 0x4b, 0xdd, 0x4f, 0x6c, 0x01, 0xd4,
+			    0x57, 0xb3, 0x5f, 0x0f, 0x7a, 0x55, 0x5a, 0xc4,
+			    0x51, 0x59, 0xcf, 0x6b, 0x49, 0x77, 0x0e, 0x46,
+			    0xb0, 0x7e, 0xa8, 0xa9, 0x4e, 0x0f, 0xb1, 0x4f,
+			    0x56, 0xa8, 0x5b, 0x96, 0x7a, 0xa4, 0x68, 0x19,
+			    0xbd, 0x7f, 0x50, 0x58, 0x5c, 0x24, 0x09, 0x0a,
+			    0x8f, 0x58, 0xb9, 0x29, 0x05, 0x8a, 0x53, 0xdd,
+			    0x87, 0x7c, 0x7e, 0x89, 0x9b, 0xf7, 0x59, 0xdf,
+			    0x8f, 0x31, 0xa4, 0x91, 0x41, 0x85, 0x21, 0x99,
+			    0xbf, 0x15, 0x20, 0xc0, 0xd3, 0xba, 0xe1, 0x55,
+			    0x50, 0xd2, 0x08, 0xd1, 0xe0, 0xb5, 0x56, 0xd5,
+			    0xe6, 0x3e, 0xbc, 0xac, 0xf5, 0x6f, 0x9d, 0xcc,
+			    0x53, 0xad, 0xfb, 0x1b, 0x75, 0xcf, 0xd5, 0x96,
+			    0x3a, 0x96, 0xe5, 0x66, 0x40, 0x74, 0x10, 0xfe,
+			    0xe8, 0xe3, 0x54, 0xcb, 0x4d, 0x3e, 0x8c, 0x53,
+			    0x30, 0x3d, 0xdf, 0xe4, 0x30, 0xe3, 0x1c, 0x83,
+			    0xdb, 0xd8, 0x2e, 0xe8, 0x3a, 0x85, 0xed, 0x6b,
+			    0xd4, 0xa7, 0x69, 0x1d, 0x6f, 0xb5, 0xca, 0x0b,
+			    0x73, 0x94, 0x09, 0xb3, 0xfe, 0xa0, 0x18, 0x56,
+			    0x6a, 0x3f, 0xa1, 0x1c, 0xee, 0x5c, 0xa5, 0xc0,
+			    0x59, 0x38, 0xe7, 0x28, 0xf6, 0x0e, 0xd9, 0xd7,
+			    0xdd, 0x1d, 0x38, 0x71, 0xed, 0xdf, 0xc5, 0x21,
+			    0x31, 0x1f, 0xcb, 0xa3, 0x0c, 0xfb, 0xc2, 0xe0,
+			    0x27, 0xf0, 0x76, 0xa8, 0x39, 0xac, 0xdc, 0x61,
+			    0x00, 0x4e, 0xf3, 0xe5, 0xb7, 0x5c, 0xdc, 0xfa,
+			    0xec, 0x00, 0x5d, 0x2e, 0x94, 0x9f, 0x70, 0xe2,
+			    0xb0, 0x7c, 0x2d, 0xb0, 0xca, 0x0b, 0x60, 0x12,
+			    0xea, 0x9d, 0x1e, 0xfc, 0x78, 0x29, 0xbf, 0xcf,
+			    0x13, 0x2c, 0x86, 0x9a, 0x47, 0xfb, 0x4b, 0xf5,
+			    0xf0, 0x2c, 0x62, 0xfd, 0xda, 0x4b, 0x4e, 0xe8,
+			    0xa0, 0x83, 0xb0, 0x56, 0x81, 0x25, 0x88, 0x36,
+			    0xad, 0xbb, 0x4f, 0x6e, 0xa7, 0x03, 0x69, 0xc4,
+			    0x10, 0xac, 0x6c, 0xac, 0xe3, 0xcc, 0x66, 0xaf,
+			    0xbb, 0x52, 0x20, 0x5f, 0x66, 0x98, 0x3d, 0x67,
+			    0x2b, 0x5d, 0xd9, 0xb8, 0x1c, 0x82, 0x48, 0x35,
+			    0x19, 0xc1, 0xe7, 0x62, 0x18, 0x90, 0xd8, 0x75,
+			    0xde, 0x9e, 0x1d, 0x91, 0x9a, 0x8b, 0xba, 0x41,
+			    0xa1, 0xcd, 0xf6, 0x04, 0xc5, 0x76, 0xaf, 0x2d,
+			    0x6e, 0xef, 0xd8, 0x72, 0x1a, 0x51, 0xff, 0x1e,
+			    0x26, 0x29, 0x37, 0x23, 0x27, 0x26, 0x08, 0x77,
+			    0xfe, 0x73, 0xa6, 0x7a, 0x1e, 0x36, 0xb4, 0x74,
+			    0xe3, 0x4a, 0xcd, 0xc5, 0x19, 0x6e, 0x59, 0xf3,
+			    0xd7, 0x89, 0xfd, 0x14, 0xad, 0xed, 0x4e, 0xbe,
+			    0x1a, 0xd5, 0x87, 0xec, 0x3d, 0x46, 0x2f, 0x08,
+			    0x47, 0x42, 0x76, 0xb6, 0x9e, 0x70, 0x0e, 0x57,
+			    0x72, 0x16, 0xb4, 0x69, 0xd6, 0xc1, 0x39, 0x5b,
+			    0xdb, 0x9f, 0xfb, 0xb3, 0x36, 0xcf, 0xd5, 0x42,
+			    0x06, 0x72, 0xfd, 0x11, 0xaf, 0x56, 0x2b, 0x16,
+			    0xdc, 0xb9, 0x84, 0x43, 0xca, 0x94, 0x71, 0x1b,
+			    0xb6, 0x32, 0xc3, 0x16, 0xb0, 0x2a, 0x3b, 0xaf,
+			    0x90, 0xf6, 0xa8, 0x08, 0x9c, 0x82, 0xba, 0x0a,
+			    0x9f, 0x61, 0x4d, 0x3e, 0x35, 0x0a, 0x7f, 0x17,
+			    0x2d, 0x1d, 0x22, 0xa8, 0xdf, 0x48, 0xbb, 0xec,
+			    0xf6, 0x0c, 0x21, 0x1a, 0x8f, 0xb9, 0x79, 0xc9,
+			    0xba, 0xd5, 0xac, 0x11, 0x34, 0x90, 0x4f, 0x75,
+			    0x51, 0x7e, 0x7b, 0xa2, 0xf7, 0x47, 0x48, 0xd1,
+			    0x56, 0xad, 0x1d, 0xf2, 0x6a, 0x9b, 0x7c, 0xf2,
+			    0xd3, 0x67, 0xd8, 0x77, 0x42, 0xe2, 0x41, 0x24,
+			    0x1e, 0x60, 0x81, 0x5d, 0x99, 0xa8, 0x91, 0x3e,
+			    0x55, 0xea, 0xda, 0xb2, 0x1b, 0x46, 0x82, 0x6f,
+			    0x14, 0x18, 0xc8, 0x61, 0x89, 0xcc, 0x8c, 0x03,
+			    0x43, 0x4f, 0xb4, 0xe6, 0xdc, 0xc0, 0xb3, 0x80 },
+		.rlen   = 512,
+	}
+};
+
 /* Cast5 test vectors from RFC 2144 */
 #define CAST5_ENC_TEST_VECTORS	3
 #define CAST5_DEC_TEST_VECTORS	3
@@ -3610,6 +3892,24 @@ static struct cipher_speed aes_lrw_speed
 	{  .klen = 0, .blen = 0, }
 };
 
+static struct cipher_speed aes_abl_speed_template[] = {
+	{ .klen = 16, .blen = 64, },
+	{ .klen = 16, .blen = 256, },
+	{ .klen = 16, .blen = 1024, },
+	{ .klen = 16, .blen = 8192, },
+	{ .klen = 24, .blen = 64, },
+	{ .klen = 24, .blen = 256, },
+	{ .klen = 24, .blen = 1024, },
+	{ .klen = 24, .blen = 8192, },
+	{ .klen = 32, .blen = 64, },
+	{ .klen = 32, .blen = 256, },
+	{ .klen = 32, .blen = 1024, },
+	{ .klen = 32, .blen = 8192, },
+
+	/* End marker */
+	{  .klen = 0, .blen = 0, }
+};
+
 static struct cipher_speed des3_ede_speed_template[] = {
 	{ .klen = 24, .blen = 16, },
 	{ .klen = 24, .blen = 64, },
-- 
1.4.2.1

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060927110928</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-09-27 11:09:28-0400</timestampReceived><subject>Re: Dead code in crypto/tcrypt.c</subject><body>

Eric Sesterhenn &lt;snakebyte@gmx.de&gt; wrote:
&gt; 
&gt; the following commit added some code in test_hash_cycles() which coverity flags as \
&gt; dead code. http://www.kernel.org/git/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=e9d41164e2fdd897fe4520c2079ea0000f6e0ec3
&gt; 

Thanks for spotting this.  I've put the following patch
into the tree.
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
index 8330742..587a135 100644
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -646,7 +646,7 @@ static int test_hash_cycles(struct hash_
 			if (ret)
 				goto out;
 		}
-		crypto_hash_final(desc, out);
+		ret = crypto_hash_final(desc, out);
 		if (ret)
 			goto out;
 	}
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


</body></email><email><emailId>20060928102337</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-09-28 10:23:37-0400</timestampReceived><subject>Re: [RFC] crypto: Add support for the Geode AES engine</subject><body>

On Wed, Sep 27, 2006 at 01:31:47PM -0600, Jordan Crouse (jordan.crouse@amd.com) wrote:
&gt; Hey all -
&gt; 
&gt; I've had a poor excuse for a crypto driver for the Geode LX AES hardware
&gt; sitting in my Geode GIT tree (and -mm) for some time now.  I sent out the 
&gt; original version some time ago (June) and I got some very smart 
&gt; recommendations for changes, but other events transpired, and I didn't do 
&gt; a very good job of following up.
&gt; 
&gt; So now, in the interest of getting this out of everybody's hair and on
&gt; the path to mainstreaming, I'm sending out a newly updated version of the 
&gt; driver for comments.  This should be fully updated for all the new API
&gt; changes in the crypto GIT tree.  Once this is acceptable, I would like to get
&gt; this pulled into the crypto tree.

As far as I can see, register access is not protected, how can your
driver handle the case when dm-crypt and IPsec simultaneously try to
encrypt/decrypt some data, it can happen even around 
preemt_disable/enable calls and actually crypto processing can happen 
in interrupt context too (although it is not the best thing to do).

You added timeout for the broken hardware condition, I think it is
better to return some error from _crypt() in that case, and, btw, that
name is not very good choice.

&gt; Thanks,
&gt; Jordan
&gt; -- 
&gt; Jordan Crouse
&gt; Senior Linux Engineer
&gt; Advanced Micro Devices, Inc.
&gt; &lt;www.amd.com/embeddedprocessors&gt;


-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060929085351</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-09-29 08:53:51-0400</timestampReceived><subject>Re: crypto: Add support for the Geode AES engine</subject><body>

On Thu, Sep 28, 2006 at 10:31:15AM -0600, Jordan Crouse (jordan.crouse@amd.com) wrote:
&gt; &gt; As far as I can see, register access is not protected, how can your
&gt; &gt; driver handle the case when dm-crypt and IPsec simultaneously try to
&gt; &gt; encrypt/decrypt some data, it can happen even around 
&gt; &gt; preemt_disable/enable calls and actually crypto processing can happen 
&gt; &gt; in interrupt context too (although it is not the best thing to do).
&gt; 
&gt; I had the mutex in there, but I took it out based on our previous
&gt; conversations, which probably was a little rash.  If CRYPTO_TFM_REQ_MAY_SLEEP
&gt; is still a valid flag to check, I could use that along with a spin lock of
&gt; some sort.   I'll think about this a bit more.

If it is set, then you can safely sleep there, but if it is not, it does
not always mean that sleeping is forbidden.

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060929173128</emailId><senderName>Vincent Jardin</senderName><senderEmail>vincent.jardin@6wind.com</senderEmail><timestampReceived>2006-09-29 17:31:28-0400</timestampReceived><subject>Re: [ACRYPTO] New asynchronous crypto layer (acrypto) release.</subject><body>

For the best synergy with OpenBSD guys, the OCF API should be considered:
   
http://www.usenix.org/events/usenix03/tech/full_papers/keromytis/keromytis_html/node8.html

then, whatever a HW driver is added, the same IOCTLs will be used by 
OpenSSL. The OCF patch for OpenSSL is already available.

Currently, it is not into the kernel git's repository so I think that 
your Via CPU won't get better performances with OpenSSL

Regards,
   Vincent

Samuel Tardieu wrote:

&gt;Evgeniy&gt; Hello.  I'm pleased to announce asynchronous crypto layer
&gt;Evgeniy&gt; (acrypto) [1] release for 2.6.18 kernel tree. Acrypto allows
&gt;Evgeniy&gt; to handle crypto requests asynchronously in hardware.
&gt;
&gt;Would userspace programs benefit from this patch? In particular, would
&gt;OpenSSL get better performances on Via nehemiah CPUs or does it need
&gt;to be patched?
&gt;
&gt;  Sam
&gt;  
&gt;

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813122030</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-13 12:20:30-0400</timestampReceived><subject>[PATCH 16/16] [CRYPTO] cipher: Remove obsolete block cipher operations</subject><body>

[CRYPTO] cipher: Remove obsolete block cipher operations

This patch removes obsolete block operations from the simple cipher type.
All block operations are now performed through the new block cipher type.

It also changes crypto_cipher into a proper type so that type checking
is done at compile time.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 crypto/api.c           |    4 
 crypto/cipher.c        |  430 -------------------------------------------------
 crypto/internal.h      |   13 -
 crypto/scatterwalk.h   |    7 
 include/linux/crypto.h |  134 +--------------
 5 files changed, 15 insertions(+), 573 deletions(-)

diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -218,9 +218,6 @@ static int crypto_init_flags(struct cryp
 	flags &amp;= ~CRYPTO_TFM_REQ_MASK;
 	
 	switch (crypto_tfm_alg_type(tfm)) {
-	case CRYPTO_ALG_TYPE_CIPHER:
-		return crypto_init_cipher_flags(tfm, flags);
-		
 	case CRYPTO_ALG_TYPE_DIGEST:
 		return crypto_init_digest_flags(tfm, flags);
 		
@@ -268,7 +265,6 @@ static void crypto_exit_ops(struct crypt
 
 	switch (crypto_tfm_alg_type(tfm)) {
 	case CRYPTO_ALG_TYPE_CIPHER:
-		crypto_exit_cipher_ops(tfm);
 		break;
 		
 	case CRYPTO_ALG_TYPE_DIGEST:
diff --git a/crypto/cipher.c b/crypto/cipher.c
--- a/crypto/cipher.c
+++ b/crypto/cipher.c
@@ -12,252 +12,12 @@
  * any later version.
  *
  */
-#include &lt;linux/compiler.h&gt;
+
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/crypto.h&gt;
 #include &lt;linux/errno.h&gt;
-#include &lt;linux/mm.h&gt;
-#include &lt;linux/slab.h&gt;
-#include &lt;linux/string.h&gt;
-#include &lt;asm/scatterlist.h&gt;
-#include "internal.h"
-#include "scatterwalk.h"
-
-static inline void xor_64(u8 *a, const u8 *b)
-{
-	((u32 *)a)[0] ^= ((u32 *)b)[0];
-	((u32 *)a)[1] ^= ((u32 *)b)[1];
-}
-
-static inline void xor_128(u8 *a, const u8 *b)
-{
-	((u32 *)a)[0] ^= ((u32 *)b)[0];
-	((u32 *)a)[1] ^= ((u32 *)b)[1];
-	((u32 *)a)[2] ^= ((u32 *)b)[2];
-	((u32 *)a)[3] ^= ((u32 *)b)[3];
-}
-
-static unsigned int crypt_slow(const struct cipher_desc *desc,
-			       struct scatter_walk *in,
-			       struct scatter_walk *out, unsigned int bsize)
-{
-	unsigned long alignmask = crypto_tfm_alg_alignmask(desc-&gt;tfm);
-	u8 buffer[bsize * 2 + alignmask];
-	u8 *src = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
-	u8 *dst = src + bsize;
-
-	scatterwalk_copychunks(src, in, bsize, 0);
-	desc-&gt;prfn(desc, dst, src, bsize);
-	scatterwalk_copychunks(dst, out, bsize, 1);
-
-	return bsize;
-}
-
-static inline unsigned int crypt_fast(const struct cipher_desc *desc,
-				      struct scatter_walk *in,
-				      struct scatter_walk *out,
-				      unsigned int nbytes, u8 *tmp)
-{
-	u8 *src, *dst;
-	u8 *real_src, *real_dst;
-
-	real_src = scatterwalk_map(in, 0);
-	real_dst = scatterwalk_map(out, 1);
-
-	src = real_src;
-	dst = scatterwalk_samebuf(in, out) ? src : real_dst;
-
-	if (tmp) {
-		memcpy(tmp, src, nbytes);
-		src = tmp;
-		dst = tmp;
-	}
-
-	nbytes = desc-&gt;prfn(desc, dst, src, nbytes);
-
-	if (tmp)
-		memcpy(real_dst, tmp, nbytes);
-
-	scatterwalk_unmap(real_src, 0);
-	scatterwalk_unmap(real_dst, 1);
-
-	scatterwalk_advance(in, nbytes);
-	scatterwalk_advance(out, nbytes);
-
-	return nbytes;
-}
-
-/* 
- * Generic encrypt/decrypt wrapper for ciphers, handles operations across
- * multiple page boundaries by using temporary blocks.  In user context,
- * the kernel is given a chance to schedule us once per page.
- */
-static int crypt(const struct cipher_desc *desc,
-		 struct scatterlist *dst,
-		 struct scatterlist *src,
-		 unsigned int nbytes)
-{
-	struct scatter_walk walk_in, walk_out;
-	struct crypto_tfm *tfm = desc-&gt;tfm;
-	const unsigned int bsize = crypto_tfm_alg_blocksize(tfm);
-	unsigned int alignmask = crypto_tfm_alg_alignmask(tfm);
-	unsigned long buffer = 0;
-
-	if (!nbytes)
-		return 0;
-
-	if (nbytes % bsize) {
-		tfm-&gt;crt_flags |= CRYPTO_TFM_RES_BAD_BLOCK_LEN;
-		return -EINVAL;
-	}
-
-	scatterwalk_start(&amp;walk_in, src);
-	scatterwalk_start(&amp;walk_out, dst);
-
-	for(;;) {
-		unsigned int n = nbytes;
-		u8 *tmp = NULL;
-
-		if (!scatterwalk_aligned(&amp;walk_in, alignmask) ||
-		    !scatterwalk_aligned(&amp;walk_out, alignmask)) {
-			if (!buffer) {
-				buffer = __get_free_page(GFP_ATOMIC);
-				if (!buffer)
-					n = 0;
-			}
-			tmp = (u8 *)buffer;
-		}
-
-		n = scatterwalk_clamp(&amp;walk_in, n);
-		n = scatterwalk_clamp(&amp;walk_out, n);
-
-		if (likely(n &gt;= bsize))
-			n = crypt_fast(desc, &amp;walk_in, &amp;walk_out, n, tmp);
-		else
-			n = crypt_slow(desc, &amp;walk_in, &amp;walk_out, bsize);
-
-		nbytes -= n;
-
-		scatterwalk_done(&amp;walk_in, 0, nbytes);
-		scatterwalk_done(&amp;walk_out, 1, nbytes);
-
-		if (!nbytes)
-			break;
-
-		crypto_yield(tfm-&gt;crt_flags);
-	}
-
-	if (buffer)
-		free_page(buffer);
-
-	return 0;
-}
-
-static int crypt_iv_unaligned(struct cipher_desc *desc,
-			      struct scatterlist *dst,
-			      struct scatterlist *src,
-			      unsigned int nbytes)
-{
-	struct crypto_tfm *tfm = desc-&gt;tfm;
-	unsigned long alignmask = crypto_tfm_alg_alignmask(tfm);
-	u8 *iv = desc-&gt;info;
-
-	if (unlikely(((unsigned long)iv &amp; alignmask))) {
-		unsigned int ivsize = tfm-&gt;crt_cipher.cit_ivsize;
-		u8 buffer[ivsize + alignmask];
-		u8 *tmp = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
-		int err;
-
-		desc-&gt;info = memcpy(tmp, iv, ivsize);
-		err = crypt(desc, dst, src, nbytes);
-		memcpy(iv, tmp, ivsize);
-
-		return err;
-	}
-
-	return crypt(desc, dst, src, nbytes);
-}
-
-static unsigned int cbc_process_encrypt(const struct cipher_desc *desc,
-					u8 *dst, const u8 *src,
-					unsigned int nbytes)
-{
-	struct crypto_tfm *tfm = desc-&gt;tfm;
-	void (*xor)(u8 *, const u8 *) = tfm-&gt;crt_u.cipher.cit_xor_block;
-	int bsize = crypto_tfm_alg_blocksize(tfm);
-
-	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) = desc-&gt;crfn;
-	u8 *iv = desc-&gt;info;
-	unsigned int done = 0;
-
-	nbytes -= bsize;
-
-	do {
-		xor(iv, src);
-		fn(tfm, dst, iv);
-		memcpy(iv, dst, bsize);
-
-		src += bsize;
-		dst += bsize;
-	} while ((done += bsize) &lt;= nbytes);
-
-	return done;
-}
-
-static unsigned int cbc_process_decrypt(const struct cipher_desc *desc,
-					u8 *dst, const u8 *src,
-					unsigned int nbytes)
-{
-	struct crypto_tfm *tfm = desc-&gt;tfm;
-	void (*xor)(u8 *, const u8 *) = tfm-&gt;crt_u.cipher.cit_xor_block;
-	int bsize = crypto_tfm_alg_blocksize(tfm);
-	unsigned long alignmask = crypto_tfm_alg_alignmask(desc-&gt;tfm);
-
-	u8 stack[src == dst ? bsize + alignmask : 0];
-	u8 *buf = (u8 *)ALIGN((unsigned long)stack, alignmask + 1);
-	u8 **dst_p = src == dst ? &amp;buf : 
-
-	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) = desc-&gt;crfn;
-	u8 *iv = desc-&gt;info;
-	unsigned int done = 0;
-
-	nbytes -= bsize;
-
-	do {
-		u8 *tmp_dst = *dst_p;
-
-		fn(tfm, tmp_dst, src);
-		xor(tmp_dst, iv);
-		memcpy(iv, src, bsize);
-		if (tmp_dst != dst)
-			memcpy(dst, tmp_dst, bsize);
-
-		src += bsize;
-		dst += bsize;
-	} while ((done += bsize) &lt;= nbytes);
-
-	return done;
-}
-
-static unsigned int ecb_process(const struct cipher_desc *desc, u8 *dst,
-				const u8 *src, unsigned int nbytes)
-{
-	struct crypto_tfm *tfm = desc-&gt;tfm;
-	int bsize = crypto_tfm_alg_blocksize(tfm);
-	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) = desc-&gt;crfn;
-	unsigned int done = 0;
-
-	nbytes -= bsize;
 
-	do {
-		fn(tfm, dst, src);
-
-		src += bsize;
-		dst += bsize;
-	} while ((done += bsize) &lt;= nbytes);
-
-	return done;
-}
+#include "internal.h"
 
 static int setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
 {
@@ -271,122 +31,6 @@ static int setkey(struct crypto_tfm *tfm
 		return cia-&gt;cia_setkey(tfm, key, keylen);
 }
 
-static int ecb_encrypt(struct crypto_tfm *tfm,
-		       struct scatterlist *dst,
-                       struct scatterlist *src, unsigned int nbytes)
-{
-	struct cipher_desc desc;
-	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
-
-	desc.tfm = tfm;
-	desc.crfn = cipher-&gt;cia_encrypt;
-	desc.prfn = cipher-&gt;cia_encrypt_ecb ?: ecb_process;
-
-	return crypt(&amp;desc, dst, src, nbytes);
-}
-
-static int ecb_decrypt(struct crypto_tfm *tfm,
-                       struct scatterlist *dst,
-                       struct scatterlist *src,
-		       unsigned int nbytes)
-{
-	struct cipher_desc desc;
-	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
-
-	desc.tfm = tfm;
-	desc.crfn = cipher-&gt;cia_decrypt;
-	desc.prfn = cipher-&gt;cia_decrypt_ecb ?: ecb_process;
-
-	return crypt(&amp;desc, dst, src, nbytes);
-}
-
-static int cbc_encrypt(struct crypto_tfm *tfm,
-                       struct scatterlist *dst,
-                       struct scatterlist *src,
-		       unsigned int nbytes)
-{
-	struct cipher_desc desc;
-	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
-
-	desc.tfm = tfm;
-	desc.crfn = cipher-&gt;cia_encrypt;
-	desc.prfn = cipher-&gt;cia_encrypt_cbc ?: cbc_process_encrypt;
-	desc.info = tfm-&gt;crt_cipher.cit_iv;
-
-	return crypt(&amp;desc, dst, src, nbytes);
-}
-
-static int cbc_encrypt_iv(struct crypto_tfm *tfm,
-                          struct scatterlist *dst,
-                          struct scatterlist *src,
-                          unsigned int nbytes, u8 *iv)
-{
-	struct cipher_desc desc;
-	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
-
-	desc.tfm = tfm;
-	desc.crfn = cipher-&gt;cia_encrypt;
-	desc.prfn = cipher-&gt;cia_encrypt_cbc ?: cbc_process_encrypt;
-	desc.info = iv;
-
-	return crypt_iv_unaligned(&amp;desc, dst, src, nbytes);
-}
-
-static int cbc_decrypt(struct crypto_tfm *tfm,
-                       struct scatterlist *dst,
-                       struct scatterlist *src,
-		       unsigned int nbytes)
-{
-	struct cipher_desc desc;
-	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
-
-	desc.tfm = tfm;
-	desc.crfn = cipher-&gt;cia_decrypt;
-	desc.prfn = cipher-&gt;cia_decrypt_cbc ?: cbc_process_decrypt;
-	desc.info = tfm-&gt;crt_cipher.cit_iv;
-
-	return crypt(&amp;desc, dst, src, nbytes);
-}
-
-static int cbc_decrypt_iv(struct crypto_tfm *tfm,
-                          struct scatterlist *dst,
-                          struct scatterlist *src,
-                          unsigned int nbytes, u8 *iv)
-{
-	struct cipher_desc desc;
-	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
-
-	desc.tfm = tfm;
-	desc.crfn = cipher-&gt;cia_decrypt;
-	desc.prfn = cipher-&gt;cia_decrypt_cbc ?: cbc_process_decrypt;
-	desc.info = iv;
-
-	return crypt_iv_unaligned(&amp;desc, dst, src, nbytes);
-}
-
-static int nocrypt(struct crypto_tfm *tfm,
-                   struct scatterlist *dst,
-                   struct scatterlist *src,
-		   unsigned int nbytes)
-{
-	return -ENOSYS;
-}
-
-static int nocrypt_iv(struct crypto_tfm *tfm,
-                      struct scatterlist *dst,
-                      struct scatterlist *src,
-                      unsigned int nbytes, u8 *iv)
-{
-	return -ENOSYS;
-}
-
-int crypto_init_cipher_flags(struct crypto_tfm *tfm, u32 flags)
-{
-	u32 mode = flags &amp; CRYPTO_TFM_MODE_MASK;
-	tfm-&gt;crt_cipher.cit_mode = mode ? mode : CRYPTO_TFM_MODE_ECB;
-	return 0;
-}
-
 static void cipher_crypt_unaligned(void (*fn)(struct crypto_tfm *, u8 *,
 					      const u8 *),
 				   struct crypto_tfm *tfm,
@@ -432,7 +76,6 @@ static void cipher_decrypt_unaligned(str
 
 int crypto_init_cipher_ops(struct crypto_tfm *tfm)
 {
-	int ret = 0;
 	struct cipher_tfm *ops = &amp;tfm-&gt;crt_cipher;
 	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
 
@@ -442,72 +85,5 @@ int crypto_init_cipher_ops(struct crypto
 	ops-&gt;cit_decrypt_one = crypto_tfm_alg_alignmask(tfm) ?
 		cipher_decrypt_unaligned : cipher-&gt;cia_decrypt;
 
-	switch (tfm-&gt;crt_cipher.cit_mode) {
-	case CRYPTO_TFM_MODE_ECB:
-		ops-&gt;cit_encrypt = ecb_encrypt;
-		ops-&gt;cit_decrypt = ecb_decrypt;
-		ops-&gt;cit_encrypt_iv = nocrypt_iv;
-		ops-&gt;cit_decrypt_iv = nocrypt_iv;
-		break;
-		
-	case CRYPTO_TFM_MODE_CBC:
-		ops-&gt;cit_encrypt = cbc_encrypt;
-		ops-&gt;cit_decrypt = cbc_decrypt;
-		ops-&gt;cit_encrypt_iv = cbc_encrypt_iv;
-		ops-&gt;cit_decrypt_iv = cbc_decrypt_iv;
-		break;
-		
-	case CRYPTO_TFM_MODE_CFB:
-		ops-&gt;cit_encrypt = nocrypt;
-		ops-&gt;cit_decrypt = nocrypt;
-		ops-&gt;cit_encrypt_iv = nocrypt_iv;
-		ops-&gt;cit_decrypt_iv = nocrypt_iv;
-		break;
-	
-	case CRYPTO_TFM_MODE_CTR:
-		ops-&gt;cit_encrypt = nocrypt;
-		ops-&gt;cit_decrypt = nocrypt;
-		ops-&gt;cit_encrypt_iv = nocrypt_iv;
-		ops-&gt;cit_decrypt_iv = nocrypt_iv;
-		break;
-
-	default:
-		BUG();
-	}
-	
-	if (ops-&gt;cit_mode == CRYPTO_TFM_MODE_CBC) {
-		unsigned long align;
-		unsigned long addr;
-	    	
-	    	switch (crypto_tfm_alg_blocksize(tfm)) {
-	    	case 8:
-	    		ops-&gt;cit_xor_block = xor_64;
-	    		break;
-	    		
-	    	case 16:
-	    		ops-&gt;cit_xor_block = xor_128;
-	    		break;
-	    		
-	    	default:
-	    		printk(KERN_WARNING "%s: block size %u not supported\n",
-	    		       crypto_tfm_alg_name(tfm),
-	    		       crypto_tfm_alg_blocksize(tfm));
-	    		ret = -EINVAL;
-	    		goto out;
-	    	}
-	    	
-		ops-&gt;cit_ivsize = crypto_tfm_alg_blocksize(tfm);
-		align = crypto_tfm_alg_alignmask(tfm) + 1;
-		addr = (unsigned long)crypto_tfm_ctx(tfm);
-		addr = ALIGN(addr, align);
-		addr += ALIGN(tfm-&gt;__crt_alg-&gt;cra_ctxsize, align);
-		ops-&gt;cit_iv = (void *)addr;
-	}
-
-out:	
-	return ret;
-}
-
-void crypto_exit_cipher_ops(struct crypto_tfm *tfm)
-{
+	return 0;
 }
diff --git a/crypto/internal.h b/crypto/internal.h
--- a/crypto/internal.h
+++ b/crypto/internal.h
@@ -112,16 +112,7 @@ static inline unsigned int crypto_digest
 static inline unsigned int crypto_cipher_ctxsize(struct crypto_alg *alg,
 						 int flags)
 {
-	unsigned int len = alg-&gt;cra_ctxsize;
-	
-	switch (flags &amp; CRYPTO_TFM_MODE_MASK) {
-	case CRYPTO_TFM_MODE_CBC:
-		len = ALIGN(len, (unsigned long)alg-&gt;cra_alignmask + 1);
-		len += alg-&gt;cra_blocksize;
-		break;
-	}
-
-	return len;
+	return alg-&gt;cra_ctxsize;
 }
 
 static inline unsigned int crypto_compress_ctxsize(struct crypto_alg *alg,
@@ -135,7 +126,6 @@ struct crypto_alg *__crypto_alg_lookup(c
 struct crypto_alg *crypto_alg_mod_lookup(const char *name, u32 type, u32 mask);
 
 int crypto_init_digest_flags(struct crypto_tfm *tfm, u32 flags);
-int crypto_init_cipher_flags(struct crypto_tfm *tfm, u32 flags);
 int crypto_init_compress_flags(struct crypto_tfm *tfm, u32 flags);
 
 int crypto_init_digest_ops(struct crypto_tfm *tfm);
@@ -143,7 +133,6 @@ int crypto_init_cipher_ops(struct crypto
 int crypto_init_compress_ops(struct crypto_tfm *tfm);
 
 void crypto_exit_digest_ops(struct crypto_tfm *tfm);
-void crypto_exit_cipher_ops(struct crypto_tfm *tfm);
 void crypto_exit_compress_ops(struct crypto_tfm *tfm);
 
 void crypto_larval_error(const char *name, u32 type, u32 mask);
diff --git a/crypto/scatterwalk.h b/crypto/scatterwalk.h
--- a/crypto/scatterwalk.h
+++ b/crypto/scatterwalk.h
@@ -27,13 +27,6 @@ static inline struct scatterlist *sg_nex
 	return sg + 1;
 }
 
-static inline unsigned long scatterwalk_samebuf(struct scatter_walk *walk_in,
-						struct scatter_walk *walk_out)
-{
-	return !(((walk_in-&gt;sg-&gt;page - walk_out-&gt;sg-&gt;page) &lt;&lt; PAGE_SHIFT) +
-		 (int)(walk_in-&gt;offset - walk_out-&gt;offset));
-}
-
 static inline unsigned int scatterwalk_pagelen(struct scatter_walk *walk)
 {
 	unsigned int len = walk-&gt;sg-&gt;offset + walk-&gt;sg-&gt;length - walk-&gt;offset;
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -47,11 +47,6 @@
 #define CRYPTO_TFM_REQ_MASK		0x000fff00
 #define CRYPTO_TFM_RES_MASK		0xfff00000
 
-#define CRYPTO_TFM_MODE_ECB		0x00000001
-#define CRYPTO_TFM_MODE_CBC		0x00000002
-#define CRYPTO_TFM_MODE_CFB		0x00000004
-#define CRYPTO_TFM_MODE_CTR		0x00000008
-
 #define CRYPTO_TFM_REQ_WEAK_KEY		0x00000100
 #define CRYPTO_TFM_REQ_MAY_SLEEP	0x00000200
 #define CRYPTO_TFM_RES_WEAK_KEY		0x00100000
@@ -88,14 +83,6 @@ struct blkcipher_desc {
 	u32 flags;
 };
 
-struct cipher_desc {
-	struct crypto_tfm *tfm;
-	void (*crfn)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
-	unsigned int (*prfn)(const struct cipher_desc *desc, u8 *dst,
-			     const u8 *src, unsigned int nbytes);
-	void *info;
-};
-
 /*
  * Algorithms: modular crypto algorithm implementations, managed
  * via crypto_register_alg() and crypto_unregister_alg().
@@ -122,19 +109,6 @@ struct cipher_alg {
 	                  unsigned int keylen);
 	void (*cia_encrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
 	void (*cia_decrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
-
-	unsigned int (*cia_encrypt_ecb)(const struct cipher_desc *desc,
-					u8 *dst, const u8 *src,
-					unsigned int nbytes);
-	unsigned int (*cia_decrypt_ecb)(const struct cipher_desc *desc,
-					u8 *dst, const u8 *src,
-					unsigned int nbytes);
-	unsigned int (*cia_encrypt_cbc)(const struct cipher_desc *desc,
-					u8 *dst, const u8 *src,
-					unsigned int nbytes);
-	unsigned int (*cia_decrypt_cbc)(const struct cipher_desc *desc,
-					u8 *dst, const u8 *src,
-					unsigned int nbytes);
 };
 
 struct digest_alg {
@@ -225,28 +199,8 @@ struct blkcipher_tfm {
 };
 
 struct cipher_tfm {
-	void *cit_iv;
-	unsigned int cit_ivsize;
-	u32 cit_mode;
 	int (*cit_setkey)(struct crypto_tfm *tfm,
 	                  const u8 *key, unsigned int keylen);
-	int (*cit_encrypt)(struct crypto_tfm *tfm,
-			   struct scatterlist *dst,
-			   struct scatterlist *src,
-			   unsigned int nbytes);
-	int (*cit_encrypt_iv)(struct crypto_tfm *tfm,
-	                      struct scatterlist *dst,
-	                      struct scatterlist *src,
-	                      unsigned int nbytes, u8 *iv);
-	int (*cit_decrypt)(struct crypto_tfm *tfm,
-			   struct scatterlist *dst,
-			   struct scatterlist *src,
-			   unsigned int nbytes);
-	int (*cit_decrypt_iv)(struct crypto_tfm *tfm,
-			   struct scatterlist *dst,
-			   struct scatterlist *src,
-			   unsigned int nbytes, u8 *iv);
-	void (*cit_xor_block)(u8 *dst, const u8 *src);
 	void (*cit_encrypt_one)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
 	void (*cit_decrypt_one)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
 };
@@ -295,7 +249,9 @@ struct crypto_tfm {
 	void *__crt_ctx[] CRYPTO_MINALIGN_ATTR;
 };
 
-#define crypto_cipher crypto_tfm
+struct crypto_cipher {
+	struct crypto_tfm base;
+};
 
 struct crypto_blkcipher {
 	struct crypto_tfm base;
@@ -346,24 +302,6 @@ static inline u32 crypto_tfm_alg_type(st
 	return tfm-&gt;__crt_alg-&gt;cra_flags &amp; CRYPTO_ALG_TYPE_MASK;
 }
 
-static inline unsigned int crypto_tfm_alg_min_keysize(struct crypto_tfm *tfm)
-{
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
-	return tfm-&gt;__crt_alg-&gt;cra_cipher.cia_min_keysize;
-}
-
-static inline unsigned int crypto_tfm_alg_max_keysize(struct crypto_tfm *tfm)
-{
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
-	return tfm-&gt;__crt_alg-&gt;cra_cipher.cia_max_keysize;
-}
-
-static inline unsigned int crypto_tfm_alg_ivsize(struct crypto_tfm *tfm)
-{
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
-	return tfm-&gt;crt_cipher.cit_ivsize;
-}
-
 static inline unsigned int crypto_tfm_alg_blocksize(struct crypto_tfm *tfm)
 {
 	return tfm-&gt;__crt_alg-&gt;cra_blocksize;
@@ -570,7 +508,7 @@ static inline struct crypto_cipher *cryp
 
 static inline struct crypto_tfm *crypto_cipher_tfm(struct crypto_cipher *tfm)
 {
-	return tfm;
+	return &amp;tfm-&gt;base;
 }
 
 static inline void crypto_free_cipher(struct crypto_cipher *tfm)
@@ -610,6 +548,13 @@ static inline void crypto_cipher_clear_f
 	crypto_tfm_clear_flags(crypto_cipher_tfm(tfm), flags);
 }
 
+static inline int crypto_cipher_setkey(struct crypto_cipher *tfm,
+				       const u8 *key, unsigned int keylen)
+{
+	return crypto_cipher_crt(tfm)-&gt;cit_setkey(crypto_cipher_tfm(tfm),
+						  key, keylen);
+}
+
 static inline void crypto_cipher_encrypt_one(struct crypto_cipher *tfm,
 					     u8 *dst, const u8 *src)
 {
@@ -659,63 +604,6 @@ static inline int crypto_digest_setkey(s
 	return tfm-&gt;crt_digest.dit_setkey(tfm, key, keylen);
 }
 
-static inline int crypto_cipher_setkey(struct crypto_tfm *tfm,
-                                       const u8 *key, unsigned int keylen)
-{
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
-	return tfm-&gt;crt_cipher.cit_setkey(tfm, key, keylen);
-}
-
-static inline int crypto_cipher_encrypt(struct crypto_tfm *tfm,
-                                        struct scatterlist *dst,
-                                        struct scatterlist *src,
-                                        unsigned int nbytes)
-{
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
-	return tfm-&gt;crt_cipher.cit_encrypt(tfm, dst, src, nbytes);
-}                                        
-
-static inline int crypto_cipher_encrypt_iv(struct crypto_tfm *tfm,
-                                           struct scatterlist *dst,
-                                           struct scatterlist *src,
-                                           unsigned int nbytes, u8 *iv)
-{
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
-	return tfm-&gt;crt_cipher.cit_encrypt_iv(tfm, dst, src, nbytes, iv);
-}                                        
-
-static inline int crypto_cipher_decrypt(struct crypto_tfm *tfm,
-                                        struct scatterlist *dst,
-                                        struct scatterlist *src,
-                                        unsigned int nbytes)
-{
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
-	return tfm-&gt;crt_cipher.cit_decrypt(tfm, dst, src, nbytes);
-}
-
-static inline int crypto_cipher_decrypt_iv(struct crypto_tfm *tfm,
-                                           struct scatterlist *dst,
-                                           struct scatterlist *src,
-                                           unsigned int nbytes, u8 *iv)
-{
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
-	return tfm-&gt;crt_cipher.cit_decrypt_iv(tfm, dst, src, nbytes, iv);
-}
-
-static inline void crypto_cipher_set_iv(struct crypto_tfm *tfm,
-                                        const u8 *src, unsigned int len)
-{
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
-	memcpy(tfm-&gt;crt_cipher.cit_iv, src, len);
-}
-
-static inline void crypto_cipher_get_iv(struct crypto_tfm *tfm,
-                                        u8 *dst, unsigned int len)
-{
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
-	memcpy(dst, tfm-&gt;crt_cipher.cit_iv, len);
-}
-
 static inline int crypto_comp_compress(struct crypto_tfm *tfm,
                                        const u8 *src, unsigned int slen,
                                        u8 *dst, unsigned int *dlen)
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060813162032</emailId><senderName></senderName><senderEmail>marketing</senderEmail><timestampReceived>2006-08-13 16:20:32-0400</timestampReceived><subject>Visit Our Site</subject><body>

 View our new website at www.itsnotforgirls.com. This site is being launched to offer free email accounts.

--------------------------------------
To Unsubscribe, please click here.

--------------------------------------
To Unsubscribe, please click here:
/box.php?funcml=unsub2&amp;nl=1&amp;email=linux-crypto@nl.linux.org


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060814121437</emailId><senderName>"Sunoco Company Limited"</senderName><senderEmail>infoatsunocooil@yahoo.co.jp</senderEmail><timestampReceived>2006-08-14 12:14:37-0400</timestampReceived><subject>COMPANY PAYMENT REPRESENTATIVE UGENTLY NEEDED</subject><body>




              Sunoco Sun Oil Company, Ltd.
          Trusty Kojimachi Bldg. 3-4 Kojimachi,
           Chiyoda-ku, Tokyo. 102-0083 Japan.
           www.sunoco.co.jp/about/index.html




COMPANY REPRESENTATIVE REQUIRED

I am Mr. HIroshi Iguchi, President of Japan Sun Oil Company, Ltd. Japan
Sun Oil Company, Ltd. is a subsidiary of the world renown U.S.
multi-energy producer Sunoco Inc. in Japan and Asian regions and are
producing and marketing not only high quality specialty lubricants but
also petroleum and energy products. We specialized in the Refrigeration
Oils, Rubber Process Oils, metalworking Oils, Industrial Lubricants,
Automotive Lubricants, etc.

We are searching for representatives who can help us establish a medium of
getting to our customers in the Canada/America and other nearby countries
as well as making payments through you to us.

Sunoco, Inc was established in 1966, Entering into a new era where the
demand for continuous improvement and expansion is far beyond what was
perceived and required just a few years ago, corporate entities are
constantly striving for perfection, knowing all too well that tomorrow
will be yet another challenge. With all the new horizons that unfold
before us, the difficulty of venturing out into the unknown requires
preparation, experience, creativity and motivation. We, Japan Sun Oil
Company Ltd. take on the challenge and look to the expansion of our
horizons with pleasure.

You do not have to leave your present job for this one because this job
offer will be on a part time basis as it comes once in a while and
remuneration is on a percentage basis of 10% of the total amount you
receive from my customers at any time on my behalf. The reason why I seek
your assistance is that American and Canadian checks take a long time to
clear here in Japan.

Thereby holding business down for my associates and me. Now I already have
customers who are ready to remit cash to me. Please to facilitate the
conclusion of this transaction if accepted, do send me promptly the
following information below by My private at sunocogroup@yahoo.co.jp





NAME...........................................

RESIDENTIAL ADDRESS..................

AGE:..............................................

STATUS:.........................................

STATE/COUNTRY.............................

TEL/FAX..........................................

NUMBERS........................................

COMPANY NAME...............................

OCCUPATION....................................


We would be glad to have you as one of our esteemed Representative in your
location and be rest assured that adequate pecuniary and lucrative
compensations will be given and other benefits follows. Upon appointment,
you are allowed the opportunity of determining the method or mode through
which you would be paid for your services as our Representative in any of
these Regions.

Regards,
HIroshi Iguchi
President &amp; CEO
Sun Oil Company, Ltd.
TEL:+81-3-5460-3939
FAX:+81-3-5460-3939


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060814235543</emailId><senderName></senderName><senderEmail>marketing@symantec-emea.com</senderEmail><timestampReceived>2006-08-14 23:55:43-0400</timestampReceived><subject>Announcing Availability of Backup =?ISO-8859-1?Q?Exec=99?= System Recovery</subject><body>

[Attachment #2 (multipart/alternative)]


Announcing the availability of Symantec Backup Exec™ System Recovery (formerly \
LiveState Recovery).

Restore Systems Anytime, from Anywhere to Virtually Any Device

http://eval.veritas.com/mktginfo/enterprise/fact_sheets/ent-backup_exec_system_recovery_05_2006.en-us.pdf


Allows you the freedom to restore Windows® systems quickly, easily and reliably. \
Supports you even in dissimilar hardware or virtual environments and in remote, \
unattended locations.

When systems fail you will have all the resources you need to restore them quickly to \
a specified point-in-time. Thats got to be better than embarking on a manual rebuild \
or restoring them using traditional methods.Discover the innovative, disk-based \
technology of Backup Exec System Recovery:

- Makes bare metal system recovery possible in minutes
- Helps you to meet and exceed IT service level agreements and recovery time \
                objectives
- Reduces requirements for on-site IT support
- Helps you to complete protection for both data and systems by combining Backup Exec \
System Recovery with Symantec's industry-leading Backup Exec for Windows Servers  

Learn more about Symantec Backup Exec System Recovery download the datasheet now!

http://eval.veritas.com/mktginfo/enterprise/fact_sheets/ent-backup_exec_system_recovery_05_2006.en-us.pdf


------------------------------------------------------------------
* Further information on renaming of this product:

With the introduction of Backup Exec System Recovery we will end of life the product \
known as Symantec LiveState Recovery on August 7, 2006, although the technology will \
continue in Backup Exec System Recovery. 

Our first customer ship date was scheduled for July 18, 2006, and will be available \
in International English, French, German, Italian, Spanish, and Japanese.

----------------------------------------------------------------------------------------------
 DO NOT REPLY TO THIS MESSAGE. 

You have received this message because you registered to get information about \
Symantec and its products. If you require Customer Service or Technical Support, \
please check the Symantec Web site for contact information at \
http://www.symantec.com/

For information on Symantec's Privacy Policy, please click here
http://www.symantec.com/about/profile/policies/privacy.jsp

To unsubscribe please click here 
unsubscribe@symantec-emea.com


[Attachment #5 (text/html)]

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;HTML&gt;
	&lt;HEAD&gt;
	&lt;meta http-equiv="content-type" content="text/html;charset=iso-8859-1"&gt;
	&lt;TITLE&gt;Symantec: Event Email&lt;/TITLE&gt;
&lt;STYLE TYPE="text/css"&gt;
&lt;!--
BODY {
background-color: #FFFFFF;
margin: 0;
}

BODY, TH, TD {
font-family: Arial, Verdana, Helvetica, "sans-serif";
font-size: 12px;
}

A {
color: #CC6600;
}

A:Visited {
color: #984F05;
}

A:Hover {
color: #CC6600;
}

.TopHeading {
color: #919469;
font-size: 18px;
font-weight: bold;
}

.DetailTable TD {
font-size: 10px;
padding: 6px;
background-color: #F3F3F3;
}


.Gold {
color: #919469;
}

.Orange {
color: #d6700d;
}

P.DottedLine {
background-image: url('http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/DottedLine.jpg');
                
background-repeat: repeat-x;
height: 3px;
margin: 0;
}

A.ContentLink {
font-weight: bold;
text-decoration: none;
color: #E67F1A;
font-size: 11px;
}

LI {
list-style-image: url('http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/GreenBullet.gif');
 }
--&gt;
&lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;body&gt;
&lt;DIV ALIGN="center"&gt;
&lt;P STYLE="color: #999999; padding-top: 5px; margin-bottom: 5px; font-size: 10px;"&gt;If \
you are having problems viewing this email, please  &lt;A \
href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux-crypto@ \
nl.linux.org&amp;squirtID=2850~.~EN3.csv~.~vshots~.~TEMP49&amp;systype=vshots&amp;pageclicked=http://emarketing.advantapro.com/grpdta/veritas/Arc/2850---vshots.html"&gt;click \
here&lt;/A&gt;&lt;/P&gt; &lt;TABLE WIDTH="552" BORDER="0" CELLSPACING="0" CELLPADDING="0"&gt;
&lt;TR&gt;
&lt;TD STYLE="border: 1px solid #CFCFCF;"&gt;
	&lt;TABLE WIDTH="523" BORDER="0" CELLSPACING="0" CELLPADDING="0"&gt;
	&lt;TR&gt;
	&lt;TD&gt;&lt;A href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux \
-crypto@nl.linux.org&amp;squirtID=2850~.~EN3.csv~.~vshots~.~TEMP49&amp;systype=vshots&amp;pageclicked=http://www.symantec.com
 "&gt;&lt;IMG SRC="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/Symantec_Header.jpg" \
ALT="Symantec" WIDTH="550" HEIGHT="69" BORDER="0"&gt;&lt;/A&gt;&lt;/TD&gt;  &lt;/TR&gt;

	&lt;TR&gt;
	&lt;TD STYLE="height: 5px; background-image: \
url('http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/Header_Bottom.jpg'); \
background-repeat: repeat-x;"&gt;&lt;/TD&gt;  &lt;/TR&gt;

	&lt;TR&gt;
	&lt;TD STYLE="border-bottom: 1px solid #CFCFCF;"&gt;
		&lt;TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0"&gt;
		&lt;TR&gt;
		&lt;TD&gt;&lt;A href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linu \
x-crypto@nl.linux.org&amp;squirtID=2850~.~EN3.csv~.~vshots~.~TEMP49&amp;systype=vshots&amp;pagecli \
cked=http://eval.veritas.com/mktginfo/enterprise/fact_sheets/ent-backup_exec_system_recovery_05_2006.en-us.pdf"&gt;&lt;IMG \
SRC="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/BESR_header_en_revised4.jpg" \
BORDER="0"&gt;&lt;/A&gt;&lt;/TD&gt;  &lt;TD ALIGN="center" WIDTH="80%"&gt;
			&lt;DIV style="text-align: left;"&gt;
			&lt;/DIV&gt;
		&lt;/TD&gt;
		&lt;/TR&gt;
		&lt;/TABLE&gt;
	&lt;/TD&gt;
	&lt;/TR&gt;
	
	&lt;TR&gt;
	&lt;TD STYLE="padding-left: 30px; padding-right: 30px; padding-top: 20px; \
padding-bottom: 10px; background-image: \
url('http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/DottedLine.jpg'); \
background-repeat: repeat-x; background-position: bottom;"&gt;  &lt;!-- Content Cell --&gt;
			

         
		&lt;P&gt;&lt;b STYLE="font-size: 16px;"&gt;Restore Systems Anytime, from Anywhere to Virtually \
Any Device&lt;/b&gt;&lt;/P&gt;

		Symantec Backup Exec™ System Recovery allows you the freedom to restore Windows® \
systems quickly, easily and reliably. Supports you even in dissimilar hardware or \
virtual environments and in remote, unattended locations.&lt;br&gt;&lt;br&gt;

When systems fail you will have all the resources you need to restore them quickly to \
a specified point-in-time. That’s got to be better than embarking on a manual rebuild \
or restoring them using traditional methods.&lt;br&gt;&lt;br&gt; Discover the innovative, \
disk-based technology of Backup Exec System Recovery:&lt;br&gt;


		&lt;!-- Bullet List --&gt;
&lt;BR&gt;
		&lt;TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" STYLE="margin-top: 8px;"&gt;
				&lt;TR VALIGN="top"&gt;
		&lt;TD&gt;&lt;IMG SRC="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/GreenBullet.gif" \
ALT="" WIDTH="25" HEIGHT="14" BORDER="0"&gt;&lt;/TD&gt;  &lt;TD&gt;Makes bare metal system recovery \
possible in minutes &lt;/TD&gt;
		&lt;/TR&gt;
		&lt;TR VALIGN="top"&gt;
		&lt;TD&gt;&lt;IMG SRC="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/GreenBullet.gif" \
ALT="" WIDTH="25" HEIGHT="14" BORDER="0"&gt;&lt;/TD&gt;  &lt;TD&gt;Helps you to meet and exceed IT \
service level agreements and recovery time objectives &lt;/TD&gt;
		&lt;/TR&gt;
		&lt;TR VALIGN="top"&gt;
		&lt;TD&gt;&lt;IMG SRC="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/GreenBullet.gif" \
ALT="" WIDTH="25" HEIGHT="14" BORDER="0"&gt;&lt;/TD&gt;  &lt;TD&gt;Reduces requirements for on-site \
IT support &lt;/TD&gt;
		&lt;/TR&gt;
		&lt;TR VALIGN="top"&gt;
		&lt;TD&gt;&lt;IMG SRC="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/GreenBullet.gif" \
ALT="" WIDTH="25" HEIGHT="14" BORDER="0"&gt;&lt;/TD&gt;  &lt;TD&gt;Helps you to complete protection \
for both data and systems by combining Backup Exec System Recovery with Symantec's \
industry-leading Backup Exec™ for Windows Servers &lt;/TD&gt;
		&lt;/TR&gt;

		&lt;/TABLE&gt;
		
		&lt;P&gt;Learn more about Symantec Backup Exec System Recovery:&lt;/P&gt;

		
		&lt;P&gt;&lt;A href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux \
-crypto@nl.linux.org&amp;squirtID=2850~.~EN3.csv~.~vshots~.~TEMP49&amp;systype=vshots&amp;pageclic \
ked=http://eval.veritas.com/mktginfo/enterprise/fact_sheets/ent-backup_exec_system_recovery_05_2006.en-us.pdf" \
CLASS="ContentLink"&gt;&lt;IMG \
SRC="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/ClickHereArrow.gif" \
ALT="" WIDTH="11" HEIGHT="12" BORDER="0" ALIGN="middle" STYLE="margin-bottom: 5px;"&gt; \
&lt;B&gt;CLICK HERE TO DOWNLOAD THE DATASHEET&lt;/B&gt;&lt;/A&gt;&lt;/P&gt;

	&lt;!-- End Content Cell --&gt;
	&lt;/TD&gt;
	&lt;/TR&gt;
	
	&lt;TR&gt;
	&lt;TD STYLE="padding-left: 30px; padding-right: 10px; padding-top: 20px; \
padding-bottom: 10px; font-size: 10px; color: #999999;"&gt;  &lt;P&gt;&lt;font size=1&gt;&lt;b&gt;DO NOT \
REPLY TO THIS MESSAGE.&lt;/b&gt;&lt;/font&gt; You have received this message because you \
registered to get information about Symantec and its products. If you require \
Customer Service or Technical Support, please check the Symantec Web site for contact \
information at  &lt;A href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?your \
email=linux-crypto@nl.linux.org&amp;squirtID=2850~.~EN3.csv~.~vshots~.~TEMP49&amp;systype=vshots&amp;pageclicked=http://www.symantec.com"&gt;www.symantec.com&lt;/A&gt;&lt;/P&gt;
 &lt;P&gt;For information on Symantec's Privacy Policy, please  &lt;A \
href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux-crypto@ \
nl.linux.org&amp;squirtID=2850~.~EN3.csv~.~vshots~.~TEMP49&amp;systype=vshots&amp;pageclicked=http://www.symantec.com/about/profile/policies/privacy.jsp"&gt;click \
here.&lt;/A&gt;&lt;/P&gt;

&lt;P&gt;To unsubscribe please &lt;A \
href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux-crypto@ \
nl.linux.org&amp;squirtID=2850~.~EN3.csv~.~vshots~.~TEMP49&amp;systype=vshots&amp;pageclicked=http \
://emarketing.advantapro.com/cgi-bin/unsubme.pl?youremail=linux-crypto@nl.linux.org~an \
d~squirtID=2850~.~EN3.csv~.~vshots~.~TEMP49~and~hiddentoemail_unsub=unsubscribe@symant \
ec-emea.com~and~hiddenyouremail_unsub=linux-crypto@nl.linux.org~and~systype=vshots~and~lettertoedit=Announcing \
Availability of Backup Exec™ System Recovery"&gt;click here&lt;/A&gt;&lt;/P&gt;


	&lt;/TD&gt;
	&lt;/TR&gt;
	&lt;/TABLE&gt;
&lt;/TD&gt;
&lt;/TR&gt;
&lt;/TABLE&gt;
&lt;/DIV&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060815115200</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-15 11:52:00-0400</timestampReceived><subject>[1/2] [PATCH] scatterlist: Add const to sg_set_buf/sg_init_one pointer argument</subject><body>

Hi:

I'm adding these two patches to cryptodev-2.6.

[PATCH] scatterlist: Add const to sg_set_buf/sg_init_one pointer argument

This patch adds a const modifier to the buf argument of sg_set_buf and
sg_init_one.  This lets people call it with pointers that are const.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/include/linux/scatterlist.h b/include/linux/scatterlist.h
--- a/include/linux/scatterlist.h
+++ b/include/linux/scatterlist.h
@@ -5,7 +5,7 @@
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/string.h&gt;
 
-static inline void sg_set_buf(struct scatterlist *sg, void *buf,
+static inline void sg_set_buf(struct scatterlist *sg, const void *buf,
 			      unsigned int buflen)
 {
 	sg-&gt;page = virt_to_page(buf);
@@ -13,7 +13,7 @@ static inline void sg_set_buf(struct sca
 	sg-&gt;length = buflen;
 }
 
-static inline void sg_init_one(struct scatterlist *sg, void *buf,
+static inline void sg_init_one(struct scatterlist *sg, const void *buf,
 			       unsigned int buflen)
 {
 	memset(sg, 0, sizeof(*sg));
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060816164802</emailId><senderName></senderName><senderEmail>comercial</senderEmail><timestampReceived>2006-08-16 16:48:02-0400</timestampReceived><subject>ESTARE DE VACACIONES HASTA EL 15-08-06</subject><body>

Informarles que estar=C3=A9 de vacaciones del 26 de Julio al 15 de Agosto=
, por
lo que cualquier asunto urgente, lo podr=C3=A1n atender desde la oficina =
en
horario de 8 a 15 horas. Tel=C3=A9fono: 913440655

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060818143914</emailId><senderName></senderName><senderEmail>mailadmin</senderEmail><timestampReceived>2006-08-18 14:39:14-0400</timestampReceived><subject>FROM ADDRESS NOT FOUND</subject><body>

This mailing list does not accept messages from email addresses that are not on the mailing list.



-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060820102356</emailId><senderName>" "</senderName><senderEmail>bjcody@webtv.net</senderEmail><timestampReceived>2006-08-20 10:23:56-0400</timestampReceived><subject>Back Pain com info/Neck Pain com info/Chiari Pain com info</subject><body>

Back Pain info http;/tinyurl.com Neck Pain info = Whiplash Pain info - Chiari Pain \
info http://tinyurl.com/zy532 


[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;
&lt;HEAD&gt;&lt;META http-equiv="Content-Type" content="text/html;charset=iso-8859-1"&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;div style='padding:0 0 10px 0'&gt;&lt;font face='font-family:segoe tv,Arial,Verdana'&gt;Back \
Pain info http;/tinyurl.com Neck Pain info = Whiplash Pain info - Chiari Pain info \
&lt;span style="word-break:break-all"&gt;&lt;a \
href="http://tinyurl.com/zy532"&gt;http://tinyurl.com/zy532&lt;/a&gt;&lt;/span&gt; &lt;/font&gt;&lt;/div&gt; \
&lt;/BODY&gt;&lt;/HTML&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060820235150</emailId><senderName>Andrew Morton</senderName><senderEmail>akpm@osdl.org</senderEmail><timestampReceived>2006-08-20 23:51:50-0400</timestampReceived><subject>Re: [-mm patch] CRYPTO_DEV_PADLOCK_AES must select CRYPTO_BLKCIPHER</subject><body>

On Mon, 21 Aug 2006 09:04:15 +1000
Herbert Xu &lt;herbert@gondor.apana.org.au&gt; wrote:

&gt; &gt; --- linux-2.6.18-rc4-mm2/drivers/crypto/Kconfig.old	2006-08-20 17:28:46.000000000 +0200
&gt; &gt; +++ linux-2.6.18-rc4-mm2/drivers/crypto/Kconfig	2006-08-20 17:44:56.000000000 +0200
&gt; &gt; @@ -16,6 +16,7 @@
&gt; &gt;  config CRYPTO_DEV_PADLOCK_AES
&gt; &gt;  	bool "Support for AES in VIA PadLock"
&gt; &gt;  	depends on CRYPTO_DEV_PADLOCK
&gt; &gt; +	select CRYPTO_BLKCIPHER
&gt; &gt;  	default y
&gt; &gt;  	help
&gt; &gt;  	  Use VIA PadLock for AES algorithm.
&gt; 
&gt; Andrew, there is definitely something screwed up.

Things are a bit messy at present - some git trees are based off Greg's
tree and some are based off Linus's and git is pretty hopeless at pulling
usable diffs in these complex situations.

So yes, it's quite possible that the above is a merging problem.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060821141550</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-21 14:15:50-0400</timestampReceived><subject>Re: [2/2] [CRYPTO] api: Mark parts of cipher interface as deprecated</subject><body>

On Tue, Aug 15, 2006 at 09:52:48PM +1000, herbert wrote:
&gt; 
&gt; [CRYPTO] api: Mark parts of cipher interface as deprecated
&gt; 
&gt; Mark the parts of the cipher interface that have been replaced by
&gt; block ciphers as deprecated.  Thanks to Andrew Morton for suggesting
&gt; doing this before removing them completely.
&gt; 
&gt; Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

I've replaced it with the following patch which should actually work
with the geode aes patch.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
bf2ed06b30860493907cbdfd4da785f53d35acdf
diff --git a/crypto/cipher.c b/crypto/cipher.c
index 3264617..9e03701 100644
--- a/crypto/cipher.c
+++ b/crypto/cipher.c
@@ -23,6 +23,28 @@ #include &lt;asm/scatterlist.h&gt;
 #include "internal.h"
 #include "scatterwalk.h"
 
+struct cipher_alg_compat {
+	unsigned int cia_min_keysize;
+	unsigned int cia_max_keysize;
+	int (*cia_setkey)(struct crypto_tfm *tfm, const u8 *key,
+	                  unsigned int keylen);
+	void (*cia_encrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
+	void (*cia_decrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
+
+	unsigned int (*cia_encrypt_ecb)(const struct cipher_desc *desc,
+					u8 *dst, const u8 *src,
+					unsigned int nbytes);
+	unsigned int (*cia_decrypt_ecb)(const struct cipher_desc *desc,
+					u8 *dst, const u8 *src,
+					unsigned int nbytes);
+	unsigned int (*cia_encrypt_cbc)(const struct cipher_desc *desc,
+					u8 *dst, const u8 *src,
+					unsigned int nbytes);
+	unsigned int (*cia_decrypt_cbc)(const struct cipher_desc *desc,
+					u8 *dst, const u8 *src,
+					unsigned int nbytes);
+};
+
 static inline void xor_64(u8 *a, const u8 *b)
 {
 	((u32 *)a)[0] ^= ((u32 *)b)[0];
@@ -276,7 +298,7 @@ static int ecb_encrypt(struct crypto_tfm
                        struct scatterlist *src, unsigned int nbytes)
 {
 	struct cipher_desc desc;
-	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
+	struct cipher_alg_compat *cipher = (void *)&amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
 
 	desc.tfm = tfm;
 	desc.crfn = cipher-&gt;cia_encrypt;
@@ -291,7 +313,7 @@ static int ecb_decrypt(struct crypto_tfm
 		       unsigned int nbytes)
 {
 	struct cipher_desc desc;
-	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
+	struct cipher_alg_compat *cipher = (void *)&amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
 
 	desc.tfm = tfm;
 	desc.crfn = cipher-&gt;cia_decrypt;
@@ -306,7 +328,7 @@ static int cbc_encrypt(struct crypto_tfm
 		       unsigned int nbytes)
 {
 	struct cipher_desc desc;
-	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
+	struct cipher_alg_compat *cipher = (void *)&amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
 
 	desc.tfm = tfm;
 	desc.crfn = cipher-&gt;cia_encrypt;
@@ -322,7 +344,7 @@ static int cbc_encrypt_iv(struct crypto_
                           unsigned int nbytes, u8 *iv)
 {
 	struct cipher_desc desc;
-	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
+	struct cipher_alg_compat *cipher = (void *)&amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
 
 	desc.tfm = tfm;
 	desc.crfn = cipher-&gt;cia_encrypt;
@@ -338,7 +360,7 @@ static int cbc_decrypt(struct crypto_tfm
 		       unsigned int nbytes)
 {
 	struct cipher_desc desc;
-	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
+	struct cipher_alg_compat *cipher = (void *)&amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
 
 	desc.tfm = tfm;
 	desc.crfn = cipher-&gt;cia_decrypt;
@@ -354,7 +376,7 @@ static int cbc_decrypt_iv(struct crypto_
                           unsigned int nbytes, u8 *iv)
 {
 	struct cipher_desc desc;
-	struct cipher_alg *cipher = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
+	struct cipher_alg_compat *cipher = (void *)&amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
 
 	desc.tfm = tfm;
 	desc.crfn = cipher-&gt;cia_decrypt;
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
index 5a5466d..0be666b 100644
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -20,7 +20,6 @@ #define _LINUX_CRYPTO_H
 #include &lt;asm/atomic.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/kernel.h&gt;
-#include &lt;linux/types.h&gt;
 #include &lt;linux/list.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/string.h&gt;
@@ -137,16 +136,16 @@ struct cipher_alg {
 
 	unsigned int (*cia_encrypt_ecb)(const struct cipher_desc *desc,
 					u8 *dst, const u8 *src,
-					unsigned int nbytes);
+					unsigned int nbytes) __deprecated;
 	unsigned int (*cia_decrypt_ecb)(const struct cipher_desc *desc,
 					u8 *dst, const u8 *src,
-					unsigned int nbytes);
+					unsigned int nbytes) __deprecated;
 	unsigned int (*cia_encrypt_cbc)(const struct cipher_desc *desc,
 					u8 *dst, const u8 *src,
-					unsigned int nbytes);
+					unsigned int nbytes) __deprecated;
 	unsigned int (*cia_decrypt_cbc)(const struct cipher_desc *desc,
 					u8 *dst, const u8 *src,
-					unsigned int nbytes);
+					unsigned int nbytes) __deprecated;
 };
 
 struct digest_alg {
@@ -358,18 +357,23 @@ static inline u32 crypto_tfm_alg_type(st
 	return tfm-&gt;__crt_alg-&gt;cra_flags &amp; CRYPTO_ALG_TYPE_MASK;
 }
 
+static unsigned int crypto_tfm_alg_min_keysize(struct crypto_tfm *tfm)
+	__deprecated;
 static inline unsigned int crypto_tfm_alg_min_keysize(struct crypto_tfm *tfm)
 {
 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 	return tfm-&gt;__crt_alg-&gt;cra_cipher.cia_min_keysize;
 }
 
+static unsigned int crypto_tfm_alg_max_keysize(struct crypto_tfm *tfm)
+	__deprecated;
 static inline unsigned int crypto_tfm_alg_max_keysize(struct crypto_tfm *tfm)
 {
 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 	return tfm-&gt;__crt_alg-&gt;cra_cipher.cia_max_keysize;
 }
 
+static unsigned int crypto_tfm_alg_ivsize(struct crypto_tfm *tfm) __deprecated;
 static inline unsigned int crypto_tfm_alg_ivsize(struct crypto_tfm *tfm)
 {
 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
@@ -622,6 +626,13 @@ static inline void crypto_cipher_clear_f
 	crypto_tfm_clear_flags(crypto_cipher_tfm(tfm), flags);
 }
 
+static inline int crypto_cipher_setkey(struct crypto_cipher *tfm,
+                                       const u8 *key, unsigned int keylen)
+{
+	return crypto_cipher_crt(tfm)-&gt;cit_setkey(crypto_cipher_tfm(tfm),
+						  key, keylen);
+}
+
 static inline void crypto_cipher_encrypt_one(struct crypto_cipher *tfm,
 					     u8 *dst, const u8 *src)
 {
@@ -671,13 +682,10 @@ static inline int crypto_digest_setkey(s
 	return tfm-&gt;crt_digest.dit_setkey(tfm, key, keylen);
 }
 
-static inline int crypto_cipher_setkey(struct crypto_tfm *tfm,
-                                       const u8 *key, unsigned int keylen)
-{
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
-	return tfm-&gt;crt_cipher.cit_setkey(tfm, key, keylen);
-}
-
+static int crypto_cipher_encrypt(struct crypto_tfm *tfm,
+				 struct scatterlist *dst,
+				 struct scatterlist *src,
+				 unsigned int nbytes) __deprecated;
 static inline int crypto_cipher_encrypt(struct crypto_tfm *tfm,
                                         struct scatterlist *dst,
                                         struct scatterlist *src,
@@ -687,6 +695,10 @@ static inline int crypto_cipher_encrypt(
 	return tfm-&gt;crt_cipher.cit_encrypt(tfm, dst, src, nbytes);
 }                                        
 
+static int crypto_cipher_encrypt_iv(struct crypto_tfm *tfm,
+				    struct scatterlist *dst,
+				    struct scatterlist *src,
+				    unsigned int nbytes, u8 *iv) __deprecated;
 static inline int crypto_cipher_encrypt_iv(struct crypto_tfm *tfm,
                                            struct scatterlist *dst,
                                            struct scatterlist *src,
@@ -696,6 +708,10 @@ static inline int crypto_cipher_encrypt_
 	return tfm-&gt;crt_cipher.cit_encrypt_iv(tfm, dst, src, nbytes, iv);
 }                                        
 
+static int crypto_cipher_decrypt(struct crypto_tfm *tfm,
+				 struct scatterlist *dst,
+				 struct scatterlist *src,
+				 unsigned int nbytes) __deprecated;
 static inline int crypto_cipher_decrypt(struct crypto_tfm *tfm,
                                         struct scatterlist *dst,
                                         struct scatterlist *src,
@@ -705,6 +721,10 @@ static inline int crypto_cipher_decrypt(
 	return tfm-&gt;crt_cipher.cit_decrypt(tfm, dst, src, nbytes);
 }
 
+static int crypto_cipher_decrypt_iv(struct crypto_tfm *tfm,
+				    struct scatterlist *dst,
+				    struct scatterlist *src,
+				    unsigned int nbytes, u8 *iv) __deprecated;
 static inline int crypto_cipher_decrypt_iv(struct crypto_tfm *tfm,
                                            struct scatterlist *dst,
                                            struct scatterlist *src,
@@ -714,6 +734,8 @@ static inline int crypto_cipher_decrypt_
 	return tfm-&gt;crt_cipher.cit_decrypt_iv(tfm, dst, src, nbytes, iv);
 }
 
+static void crypto_cipher_set_iv(struct crypto_tfm *tfm,
+				 const u8 *src, unsigned int len) __deprecated;
 static inline void crypto_cipher_set_iv(struct crypto_tfm *tfm,
                                         const u8 *src, unsigned int len)
 {
@@ -721,6 +743,8 @@ static inline void crypto_cipher_set_iv(
 	memcpy(tfm-&gt;crt_cipher.cit_iv, src, len);
 }
 
+static void crypto_cipher_get_iv(struct crypto_tfm *tfm,
+				 u8 *dst, unsigned int len) __deprecated;
 static inline void crypto_cipher_get_iv(struct crypto_tfm *tfm,
                                         u8 *dst, unsigned int len)
 {
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060814114239</emailId><senderName>"Sunoco Company Limited"</senderName><senderEmail>infoatsunocooil@yahoo.co.jp</senderEmail><timestampReceived>2006-08-14 11:42:39-0400</timestampReceived><subject>COMPANY PAYMENT REPRESENTATIVE UGENTLY NEEDED</subject><body>




              Sunoco Sun Oil Company, Ltd.
          Trusty Kojimachi Bldg. 3-4 Kojimachi,
           Chiyoda-ku, Tokyo. 102-0083 Japan.
           www.sunoco.co.jp/about/index.html




COMPANY REPRESENTATIVE REQUIRED

I am Mr. HIroshi Iguchi, President of Japan Sun Oil Company, Ltd. Japan
Sun Oil Company, Ltd. is a subsidiary of the world renown U.S.
multi-energy producer Sunoco Inc. in Japan and Asian regions and are
producing and marketing not only high quality specialty lubricants but
also petroleum and energy products. We specialized in the Refrigeration
Oils, Rubber Process Oils, metalworking Oils, Industrial Lubricants,
Automotive Lubricants, etc.

We are searching for representatives who can help us establish a medium of
getting to our customers in the Canada/America and other nearby countries
as well as making payments through you to us.

Sunoco, Inc was established in 1966, Entering into a new era where the
demand for continuous improvement and expansion is far beyond what was
perceived and required just a few years ago, corporate entities are
constantly striving for perfection, knowing all too well that tomorrow
will be yet another challenge. With all the new horizons that unfold
before us, the difficulty of venturing out into the unknown requires
preparation, experience, creativity and motivation. We, Japan Sun Oil
Company Ltd. take on the challenge and look to the expansion of our
horizons with pleasure.

You do not have to leave your present job for this one because this job
offer will be on a part time basis as it comes once in a while and
remuneration is on a percentage basis of 10% of the total amount you
receive from my customers at any time on my behalf. The reason why I seek
your assistance is that American and Canadian checks take a long time to
clear here in Japan.

Thereby holding business down for my associates and me. Now I already have
customers who are ready to remit cash to me. Please to facilitate the
conclusion of this transaction if accepted, do send me promptly the
following information below by My private at sunocogroup@yahoo.co.jp





NAME...........................................

RESIDENTIAL ADDRESS..................

AGE:..............................................

STATUS:.........................................

STATE/COUNTRY.............................

TEL/FAX..........................................

NUMBERS........................................

COMPANY NAME...............................

OCCUPATION....................................


We would be glad to have you as one of our esteemed Representative in your
location and be rest assured that adequate pecuniary and lucrative
compensations will be given and other benefits follows. Upon appointment,
you are allowed the opportunity of determining the method or mode through
which you would be paid for your services as our Representative in any of
these Regions.

Regards,
HIroshi Iguchi
President &amp; CEO
Sun Oil Company, Ltd.
TEL:+81-3-5460-3939
FAX:+81-3-5460-3939


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060820160928</emailId><senderName>Adrian Bunk</senderName><senderEmail>bunk@stusta.de</senderEmail><timestampReceived>2006-08-20 16:09:28-0400</timestampReceived><subject>[-mm patch] CRYPTO_DEV_PADLOCK_AES must select CRYPTO_BLKCIPHER</subject><body>

On Sat, Aug 19, 2006 at 10:00:08PM -0700, Andrew Morton wrote:
&gt;...
&gt; Changes since 2.6.18-rc4-mm1:
&gt;...
&gt;  git-cryptodev.patch
&gt; 
&gt;  git trees
&gt;...

This patch fixes the following compile error:

&lt;--  snip  --&gt;

  LD      .tmp_vmlinux1
drivers/built-in.o: In function `cbc_aes_decrypt':
padlock-aes.c:(.text+0x6c63a): undefined reference to `blkcipher_walk_virt'
padlock-aes.c:(.text+0x6c66f): undefined reference to `blkcipher_walk_done'
drivers/built-in.o: In function `ecb_aes_decrypt':
padlock-aes.c:(.text+0x6c6af): undefined reference to `blkcipher_walk_virt'
padlock-aes.c:(.text+0x6c6de): undefined reference to `blkcipher_walk_done'
drivers/built-in.o: In function `ecb_aes_encrypt':
padlock-aes.c:(.text+0x6c768): undefined reference to `blkcipher_walk_virt'
padlock-aes.c:(.text+0x6c794): undefined reference to `blkcipher_walk_done'
drivers/built-in.o: In function `cbc_aes_encrypt':
padlock-aes.c:(.text+0x6c7d5): undefined reference to `blkcipher_walk_virt'
padlock-aes.c:(.text+0x6c821): undefined reference to `blkcipher_walk_done'
drivers/built-in.o:(.data+0xcfa8): undefined reference to `crypto_blkcipher_type'
drivers/built-in.o:(.data+0xd088): undefined reference to `crypto_blkcipher_type'
make[1]: *** [.tmp_vmlinux1] Error 1

&lt;--  snip  --&gt;
 
Signed-off-by: Adrian Bunk &lt;bunk@stusta.de&gt;

---

BTW: The Kconfig+Makefile parts for padlock-sha seem to be missing.

--- linux-2.6.18-rc4-mm2/drivers/crypto/Kconfig.old	2006-08-20 17:28:46.000000000 +0200
+++ linux-2.6.18-rc4-mm2/drivers/crypto/Kconfig	2006-08-20 17:44:56.000000000 +0200
@@ -16,6 +16,7 @@
 config CRYPTO_DEV_PADLOCK_AES
 	bool "Support for AES in VIA PadLock"
 	depends on CRYPTO_DEV_PADLOCK
+	select CRYPTO_BLKCIPHER
 	default y
 	help
 	  Use VIA PadLock for AES algorithm.

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060815115248</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-15 11:52:48-0400</timestampReceived><subject>[2/2] [CRYPTO] api: Mark parts of cipher interface as deprecated</subject><body>

Hi:

[CRYPTO] api: Mark parts of cipher interface as deprecated

Mark the parts of the cipher interface that have been replaced by
block ciphers as deprecated.  Thanks to Andrew Morton for suggesting
doing this before removing them completely.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/cipher.c b/crypto/cipher.c
--- a/crypto/cipher.c
+++ b/crypto/cipher.c
@@ -280,7 +280,7 @@ static int ecb_encrypt(struct crypto_tfm
 
 	desc.tfm = tfm;
 	desc.crfn = cipher-&gt;cia_encrypt;
-	desc.prfn = cipher-&gt;cia_encrypt_ecb ?: ecb_process;
+	desc.prfn = cipher-&gt;__cia_encrypt_ecb ?: ecb_process;
 
 	return crypt(&amp;desc, dst, src, nbytes);
 }
@@ -295,7 +295,7 @@ static int ecb_decrypt(struct crypto_tfm
 
 	desc.tfm = tfm;
 	desc.crfn = cipher-&gt;cia_decrypt;
-	desc.prfn = cipher-&gt;cia_decrypt_ecb ?: ecb_process;
+	desc.prfn = cipher-&gt;__cia_decrypt_ecb ?: ecb_process;
 
 	return crypt(&amp;desc, dst, src, nbytes);
 }
@@ -310,7 +310,7 @@ static int cbc_encrypt(struct crypto_tfm
 
 	desc.tfm = tfm;
 	desc.crfn = cipher-&gt;cia_encrypt;
-	desc.prfn = cipher-&gt;cia_encrypt_cbc ?: cbc_process_encrypt;
+	desc.prfn = cipher-&gt;__cia_encrypt_cbc ?: cbc_process_encrypt;
 	desc.info = tfm-&gt;crt_cipher.cit_iv;
 
 	return crypt(&amp;desc, dst, src, nbytes);
@@ -326,7 +326,7 @@ static int cbc_encrypt_iv(struct crypto_
 
 	desc.tfm = tfm;
 	desc.crfn = cipher-&gt;cia_encrypt;
-	desc.prfn = cipher-&gt;cia_encrypt_cbc ?: cbc_process_encrypt;
+	desc.prfn = cipher-&gt;__cia_encrypt_cbc ?: cbc_process_encrypt;
 	desc.info = iv;
 
 	return crypt_iv_unaligned(&amp;desc, dst, src, nbytes);
@@ -342,7 +342,7 @@ static int cbc_decrypt(struct crypto_tfm
 
 	desc.tfm = tfm;
 	desc.crfn = cipher-&gt;cia_decrypt;
-	desc.prfn = cipher-&gt;cia_decrypt_cbc ?: cbc_process_decrypt;
+	desc.prfn = cipher-&gt;__cia_decrypt_cbc ?: cbc_process_decrypt;
 	desc.info = tfm-&gt;crt_cipher.cit_iv;
 
 	return crypt(&amp;desc, dst, src, nbytes);
@@ -358,7 +358,7 @@ static int cbc_decrypt_iv(struct crypto_
 
 	desc.tfm = tfm;
 	desc.crfn = cipher-&gt;cia_decrypt;
-	desc.prfn = cipher-&gt;cia_decrypt_cbc ?: cbc_process_decrypt;
+	desc.prfn = cipher-&gt;__cia_decrypt_cbc ?: cbc_process_decrypt;
 	desc.info = iv;
 
 	return crypt_iv_unaligned(&amp;desc, dst, src, nbytes);
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -20,7 +20,6 @@
 #include &lt;asm/atomic.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/kernel.h&gt;
-#include &lt;linux/types.h&gt;
 #include &lt;linux/list.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/string.h&gt;
@@ -123,18 +122,42 @@ struct cipher_alg {
 	void (*cia_encrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
 	void (*cia_decrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
 
-	unsigned int (*cia_encrypt_ecb)(const struct cipher_desc *desc,
-					u8 *dst, const u8 *src,
-					unsigned int nbytes);
-	unsigned int (*cia_decrypt_ecb)(const struct cipher_desc *desc,
-					u8 *dst, const u8 *src,
-					unsigned int nbytes);
-	unsigned int (*cia_encrypt_cbc)(const struct cipher_desc *desc,
-					u8 *dst, const u8 *src,
-					unsigned int nbytes);
-	unsigned int (*cia_decrypt_cbc)(const struct cipher_desc *desc,
-					u8 *dst, const u8 *src,
-					unsigned int nbytes);
+	union {
+		unsigned int (*cia_encrypt_ecb)(const struct cipher_desc *desc,
+						u8 *dst, const u8 *src,
+						unsigned int nbytes)
+			__deprecated;
+		unsigned int (*__cia_encrypt_ecb)(
+			const struct cipher_desc *desc,
+			u8 *dst, const u8 *src, unsigned int nbytes);
+	};
+	union {
+		unsigned int (*cia_decrypt_ecb)(const struct cipher_desc *desc,
+						u8 *dst, const u8 *src,
+						unsigned int nbytes)
+			__deprecated;
+		unsigned int (*__cia_decrypt_ecb)(
+			const struct cipher_desc *desc,
+			u8 *dst, const u8 *src, unsigned int nbytes);
+	};
+	union {
+		unsigned int (*cia_encrypt_cbc)(const struct cipher_desc *desc,
+						u8 *dst, const u8 *src,
+						unsigned int nbytes)
+			__deprecated;
+		unsigned int (*__cia_encrypt_cbc)(
+			const struct cipher_desc *desc,
+			u8 *dst, const u8 *src, unsigned int nbytes);
+	};
+	union {
+		unsigned int (*cia_decrypt_cbc)(const struct cipher_desc *desc,
+						u8 *dst, const u8 *src,
+						unsigned int nbytes)
+			__deprecated;
+		unsigned int (*__cia_decrypt_cbc)(
+			const struct cipher_desc *desc,
+			u8 *dst, const u8 *src, unsigned int nbytes);
+	};
 };
 
 struct digest_alg {
@@ -346,18 +369,23 @@ static inline u32 crypto_tfm_alg_type(st
 	return tfm-&gt;__crt_alg-&gt;cra_flags &amp; CRYPTO_ALG_TYPE_MASK;
 }
 
+static unsigned int crypto_tfm_alg_min_keysize(struct crypto_tfm *tfm)
+	__deprecated;
 static inline unsigned int crypto_tfm_alg_min_keysize(struct crypto_tfm *tfm)
 {
 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 	return tfm-&gt;__crt_alg-&gt;cra_cipher.cia_min_keysize;
 }
 
+static unsigned int crypto_tfm_alg_max_keysize(struct crypto_tfm *tfm)
+	__deprecated;
 static inline unsigned int crypto_tfm_alg_max_keysize(struct crypto_tfm *tfm)
 {
 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 	return tfm-&gt;__crt_alg-&gt;cra_cipher.cia_max_keysize;
 }
 
+static unsigned int crypto_tfm_alg_ivsize(struct crypto_tfm *tfm) __deprecated;
 static inline unsigned int crypto_tfm_alg_ivsize(struct crypto_tfm *tfm)
 {
 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
@@ -610,6 +638,13 @@ static inline void crypto_cipher_clear_f
 	crypto_tfm_clear_flags(crypto_cipher_tfm(tfm), flags);
 }
 
+static inline int crypto_cipher_setkey(struct crypto_cipher *tfm,
+                                       const u8 *key, unsigned int keylen)
+{
+	return crypto_cipher_crt(tfm)-&gt;cit_setkey(crypto_cipher_tfm(tfm),
+						  key, keylen);
+}
+
 static inline void crypto_cipher_encrypt_one(struct crypto_cipher *tfm,
 					     u8 *dst, const u8 *src)
 {
@@ -659,13 +694,10 @@ static inline int crypto_digest_setkey(s
 	return tfm-&gt;crt_digest.dit_setkey(tfm, key, keylen);
 }
 
-static inline int crypto_cipher_setkey(struct crypto_tfm *tfm,
-                                       const u8 *key, unsigned int keylen)
-{
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
-	return tfm-&gt;crt_cipher.cit_setkey(tfm, key, keylen);
-}
-
+static int crypto_cipher_encrypt(struct crypto_tfm *tfm,
+				 struct scatterlist *dst,
+				 struct scatterlist *src,
+				 unsigned int nbytes) __deprecated;
 static inline int crypto_cipher_encrypt(struct crypto_tfm *tfm,
                                         struct scatterlist *dst,
                                         struct scatterlist *src,
@@ -675,6 +707,10 @@ static inline int crypto_cipher_encrypt(
 	return tfm-&gt;crt_cipher.cit_encrypt(tfm, dst, src, nbytes);
 }                                        
 
+static int crypto_cipher_encrypt_iv(struct crypto_tfm *tfm,
+				    struct scatterlist *dst,
+				    struct scatterlist *src,
+				    unsigned int nbytes, u8 *iv) __deprecated;
 static inline int crypto_cipher_encrypt_iv(struct crypto_tfm *tfm,
                                            struct scatterlist *dst,
                                            struct scatterlist *src,
@@ -684,6 +720,10 @@ static inline int crypto_cipher_encrypt_
 	return tfm-&gt;crt_cipher.cit_encrypt_iv(tfm, dst, src, nbytes, iv);
 }                                        
 
+static int crypto_cipher_decrypt(struct crypto_tfm *tfm,
+				 struct scatterlist *dst,
+				 struct scatterlist *src,
+				 unsigned int nbytes) __deprecated;
 static inline int crypto_cipher_decrypt(struct crypto_tfm *tfm,
                                         struct scatterlist *dst,
                                         struct scatterlist *src,
@@ -693,6 +733,10 @@ static inline int crypto_cipher_decrypt(
 	return tfm-&gt;crt_cipher.cit_decrypt(tfm, dst, src, nbytes);
 }
 
+static int crypto_cipher_decrypt_iv(struct crypto_tfm *tfm,
+				    struct scatterlist *dst,
+				    struct scatterlist *src,
+				    unsigned int nbytes, u8 *iv) __deprecated;
 static inline int crypto_cipher_decrypt_iv(struct crypto_tfm *tfm,
                                            struct scatterlist *dst,
                                            struct scatterlist *src,
@@ -702,6 +746,8 @@ static inline int crypto_cipher_decrypt_
 	return tfm-&gt;crt_cipher.cit_decrypt_iv(tfm, dst, src, nbytes, iv);
 }
 
+static void crypto_cipher_set_iv(struct crypto_tfm *tfm,
+				 const u8 *src, unsigned int len) __deprecated;
 static inline void crypto_cipher_set_iv(struct crypto_tfm *tfm,
                                         const u8 *src, unsigned int len)
 {
@@ -709,6 +755,8 @@ static inline void crypto_cipher_set_iv(
 	memcpy(tfm-&gt;crt_cipher.cit_iv, src, len);
 }
 
+static void crypto_cipher_get_iv(struct crypto_tfm *tfm,
+				 u8 *dst, unsigned int len) __deprecated;
 static inline void crypto_cipher_get_iv(struct crypto_tfm *tfm,
                                         u8 *dst, unsigned int len)
 {
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060820230415</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-20 23:04:15-0400</timestampReceived><subject>Re: [-mm patch] CRYPTO_DEV_PADLOCK_AES must select CRYPTO_BLKCIPHER</subject><body>

On Sun, Aug 20, 2006 at 06:09:28PM +0200, Adrian Bunk wrote:
&gt; 
&gt; BTW: The Kconfig+Makefile parts for padlock-sha seem to be missing.

Thanks Adrian.

&gt; --- linux-2.6.18-rc4-mm2/drivers/crypto/Kconfig.old	2006-08-20 17:28:46.000000000 \
&gt;                 +0200
&gt; +++ linux-2.6.18-rc4-mm2/drivers/crypto/Kconfig	2006-08-20 17:44:56.000000000 +0200
&gt; @@ -16,6 +16,7 @@
&gt; config CRYPTO_DEV_PADLOCK_AES
&gt; 	bool "Support for AES in VIA PadLock"
&gt; 	depends on CRYPTO_DEV_PADLOCK
&gt; +	select CRYPTO_BLKCIPHER
&gt; 	default y
&gt; 	help
&gt; 	  Use VIA PadLock for AES algorithm.

Andrew, there is definitely something screwed up.  If you look at
my tree this patch is already in the top changeset that was
supposedly picked up by yout pull:

GIT aabffae140135096195f6fb04d165bb204517db2 \
git+ssh://master.kernel.org/pub/scm/linux/kernel/git/herbert/cryptodev-2.6.git

commit aabffae140135096195f6fb04d165bb204517db2
Author: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date:   Tue Aug 15 22:49:54 2006 +1000

    [CRYPTO] Kconfig: Added missing selects on BLKCIPHER
    
    Since padlock-aes and aes-s390/des-s390 now use the block cipher interface,
    they need to select the BLKCIPHER Kconfig option.
    
    Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Indeed, the s390 bits are there.  However, the padlock bits have
gong missing.  Perhaps there was a problem when it was merged with
the geode tree? This could explain why the Makefile bits for padlock
went missing too.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


</body></email><email><emailId>20060821142407</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-21 14:24:07-0400</timestampReceived><subject>[0/7] [CRYPTO]: Add hash type and hmac template</subject><body>

Hi:

Dave, these patches are for cryptodev-2.6.

This series of patches adds the new hash crypto type.  It completely
replaces the existing digest type from the user's side.  For now the
digest algorithm interface will remain and coexist with the new hash
algorithm interface.

The main reasons for the new type are:

1) Be able to return errors from init/update/final/digest.
2) Take a descriptor argument in init/update/final/digest.
3) Use SG on algorithm side for update/digest.
4) Compatibility on the algorithm side.

The first three are needed for async crypto.

For now only the HMAC users have been converted over to the new hash
interface.  The rest will follow next.  I do not currently plan to
convert the algorithms to the new interface because there is little
benefit.  In fact one of the main advantages of the crypto_type setup
is the ability to have multiple algorithm types supported by the same
user interface.

Apart from that this series is a respin of the HMAC patches which I've
posted before.  The only difference is that HMAC is now a hash algorithm
rather than digest.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060821142611</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-21 14:26:11-0400</timestampReceived><subject>[PATCH 1/7] [CRYPTO] digest: Added user API for new hash type</subject><body>

[CRYPTO] digest: Added user API for new hash type

The existing digest user interface is inadequate for support asynchronous
operations.  For one it doesn't return a value to indicate success or
failure, nor does it take a per-operation descriptor which is essential
for the issuing of requests while other requests are still outstanding.

This patch is the first in a series of steps to remodel the interface
for asynchronous operations.

For the ease of transition the new interface will be known as "hash"
while the old one will remain as "digest".

This patch also changes sg_next to allow chaining.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 crypto/Kconfig          |    4 +
 crypto/Makefile         |    3 
 crypto/digest.c         |  129 ++++++++++++++++++++++++++++--------
 crypto/hash.c           |   61 +++++++++++++++++
 crypto/hmac.c           |   12 +--
 crypto/scatterwalk.h    |    4 -
 include/crypto/algapi.h |    6 +
 include/linux/crypto.h  |  172 ++++++++++++++++++++++++++++++++++++++----------
 8 files changed, 321 insertions(+), 70 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -20,6 +20,10 @@ config CRYPTO_BLKCIPHER
 	tristate
 	select CRYPTO_ALGAPI
 
+config CRYPTO_HASH
+	tristate
+	select CRYPTO_ALGAPI
+
 config CRYPTO_MANAGER
 	tristate "Cryptographic algorithm manager"
 	select CRYPTO_ALGAPI
diff --git a/crypto/Makefile b/crypto/Makefile
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -10,6 +10,9 @@ obj-$(CONFIG_CRYPTO_ALGAPI) += crypto_al
 
 obj-$(CONFIG_CRYPTO_BLKCIPHER) += blkcipher.o
 
+crypto_hash-objs := hash.o
+obj-$(CONFIG_CRYPTO_HASH) += crypto_hash.o
+
 obj-$(CONFIG_CRYPTO_MANAGER) += cryptomgr.o
 obj-$(CONFIG_CRYPTO_HMAC) += hmac.o
 obj-$(CONFIG_CRYPTO_NULL) += crypto_null.o
diff --git a/crypto/digest.c b/crypto/digest.c
--- a/crypto/digest.c
+++ b/crypto/digest.c
@@ -11,29 +11,89 @@
  * any later version.
  *
  */
-#include &lt;linux/crypto.h&gt;
+
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/highmem.h&gt;
-#include &lt;asm/scatterlist.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+
 #include "internal.h"
+#include "scatterwalk.h"
 
-static void init(struct crypto_tfm *tfm)
+void crypto_digest_init(struct crypto_tfm *tfm)
 {
-	tfm-&gt;__crt_alg-&gt;cra_digest.dia_init(tfm);
+	struct crypto_hash *hash = crypto_hash_cast(tfm);
+	struct hash_desc desc = { .tfm = hash, .flags = tfm-&gt;crt_flags };
+
+	crypto_hash_init(&amp;desc);
 }
+EXPORT_SYMBOL_GPL(crypto_digest_init);
 
-static void update(struct crypto_tfm *tfm,
-                   struct scatterlist *sg, unsigned int nsg)
+void crypto_digest_update(struct crypto_tfm *tfm,
+			  struct scatterlist *sg, unsigned int nsg)
 {
+	struct crypto_hash *hash = crypto_hash_cast(tfm);
+	struct hash_desc desc = { .tfm = hash, .flags = tfm-&gt;crt_flags };
+	unsigned int nbytes = 0;
 	unsigned int i;
+
+	for (i = 0; i &lt; nsg; i++)
+		nbytes += sg[i].length;
+
+	crypto_hash_update(&amp;desc, sg, nbytes);
+}
+EXPORT_SYMBOL_GPL(crypto_digest_update);
+
+void crypto_digest_final(struct crypto_tfm *tfm, u8 *out)
+{
+	struct crypto_hash *hash = crypto_hash_cast(tfm);
+	struct hash_desc desc = { .tfm = hash, .flags = tfm-&gt;crt_flags };
+
+	crypto_hash_final(&amp;desc, out);
+}
+EXPORT_SYMBOL_GPL(crypto_digest_final);
+
+void crypto_digest_digest(struct crypto_tfm *tfm,
+			  struct scatterlist *sg, unsigned int nsg, u8 *out)
+{
+	struct crypto_hash *hash = crypto_hash_cast(tfm);
+	struct hash_desc desc = { .tfm = hash, .flags = tfm-&gt;crt_flags };
+	unsigned int nbytes = 0;
+	unsigned int i;
+
+	for (i = 0; i &lt; nsg; i++)
+		nbytes += sg[i].length;
+
+	crypto_hash_digest(&amp;desc, sg, nbytes, out);
+}
+EXPORT_SYMBOL_GPL(crypto_digest_digest);
+
+static int init(struct hash_desc *desc)
+{
+	struct crypto_tfm *tfm = crypto_hash_tfm(desc-&gt;tfm);
+
+	tfm-&gt;__crt_alg-&gt;cra_digest.dia_init(tfm);
+	return 0;
+}
+
+static int update(struct hash_desc *desc,
+		  struct scatterlist *sg, unsigned int nbytes)
+{
+	struct crypto_tfm *tfm = crypto_hash_tfm(desc-&gt;tfm);
 	unsigned int alignmask = crypto_tfm_alg_alignmask(tfm);
 
-	for (i = 0; i &lt; nsg; i++) {
+	if (!nbytes)
+		return 0;
 
-		struct page *pg = sg[i].page;
-		unsigned int offset = sg[i].offset;
-		unsigned int l = sg[i].length;
+	for (;;) {
+		struct page *pg = sg-&gt;page;
+		unsigned int offset = sg-&gt;offset;
+		unsigned int l = sg-&gt;length;
+
+		if (unlikely(l &gt; nbytes))
+			l = nbytes;
+		nbytes -= l;
 
 		do {
 			unsigned int bytes_from_page = min(l, ((unsigned int)
@@ -55,16 +115,23 @@ static void update(struct crypto_tfm *tf
 			tfm-&gt;__crt_alg-&gt;cra_digest.dia_update(tfm, p,
 							      bytes_from_page);
 			crypto_kunmap(src, 0);
-			crypto_yield(tfm-&gt;crt_flags);
+			crypto_yield(desc-&gt;flags);
 			offset = 0;
 			pg++;
 			l -= bytes_from_page;
 		} while (l &gt; 0);
+
+		if (!nbytes)
+			break;
+		sg = sg_next(sg);
 	}
+
+	return 0;
 }
 
-static void final(struct crypto_tfm *tfm, u8 *out)
+static int final(struct hash_desc *desc, u8 *out)
 {
+	struct crypto_tfm *tfm = crypto_hash_tfm(desc-&gt;tfm);
 	unsigned long alignmask = crypto_tfm_alg_alignmask(tfm);
 	struct digest_alg *digest = &amp;tfm-&gt;__crt_alg-&gt;cra_digest;
 
@@ -78,26 +145,30 @@ static void final(struct crypto_tfm *tfm
 		memcpy(out, dst, digest-&gt;dia_digestsize);
 	} else
 		digest-&gt;dia_final(tfm, out);
+
+	return 0;
 }
 
-static int nosetkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
+static int nosetkey(struct crypto_hash *tfm, const u8 *key, unsigned int keylen)
 {
-	tfm-&gt;crt_flags &amp;= ~CRYPTO_TFM_RES_MASK;
+	crypto_hash_clear_flags(tfm, CRYPTO_TFM_RES_MASK);
 	return -ENOSYS;
 }
 
-static int setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
+static int setkey(struct crypto_hash *hash, const u8 *key, unsigned int keylen)
 {
-	tfm-&gt;crt_flags &amp;= ~CRYPTO_TFM_RES_MASK;
+	struct crypto_tfm *tfm = crypto_hash_tfm(hash);
+
+	crypto_hash_clear_flags(hash, CRYPTO_TFM_RES_MASK);
 	return tfm-&gt;__crt_alg-&gt;cra_digest.dia_setkey(tfm, key, keylen);
 }
 
-static void digest(struct crypto_tfm *tfm,
-                   struct scatterlist *sg, unsigned int nsg, u8 *out)
+static int digest(struct hash_desc *desc,
+		  struct scatterlist *sg, unsigned int nbytes, u8 *out)
 {
-	init(tfm);
-	update(tfm, sg, nsg);
-	final(tfm, out);
+	init(desc);
+	update(desc, sg, nbytes);
+	return final(desc, out);
 }
 
 int crypto_init_digest_flags(struct crypto_tfm *tfm, u32 flags)
@@ -107,14 +178,18 @@ int crypto_init_digest_flags(struct cryp
 
 int crypto_init_digest_ops(struct crypto_tfm *tfm)
 {
-	struct digest_tfm *ops = &amp;tfm-&gt;crt_digest;
+	struct hash_tfm *ops = &amp;tfm-&gt;crt_hash;
 	struct digest_alg *dalg = &amp;tfm-&gt;__crt_alg-&gt;cra_digest;
+
+	if (dalg-&gt;dia_digestsize &gt; crypto_tfm_alg_blocksize(tfm))
+		return -EINVAL;
 	
-	ops-&gt;dit_init	= init;
-	ops-&gt;dit_update	= update;
-	ops-&gt;dit_final	= final;
-	ops-&gt;dit_digest	= digest;
-	ops-&gt;dit_setkey	= dalg-&gt;dia_setkey ? setkey : nosetkey;
+	ops-&gt;init	= init;
+	ops-&gt;update	= update;
+	ops-&gt;final	= final;
+	ops-&gt;digest	= digest;
+	ops-&gt;setkey	= dalg-&gt;dia_setkey ? setkey : nosetkey;
+	ops-&gt;digestsize	= dalg-&gt;dia_digestsize;
 	
 	return crypto_alloc_hmac_block(tfm);
 }
diff --git a/crypto/hash.c b/crypto/hash.c
new file mode 100644
--- /dev/null
+++ b/crypto/hash.c
@@ -0,0 +1,61 @@
+/*
+ * Cryptographic Hash operations.
+ * 
+ * Copyright (c) 2006 Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ */
+
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/seq_file.h&gt;
+
+#include "internal.h"
+
+static unsigned int crypto_hash_ctxsize(struct crypto_alg *alg)
+{
+	return alg-&gt;cra_ctxsize;
+}
+
+static int crypto_init_hash_ops(struct crypto_tfm *tfm)
+{
+	struct hash_tfm *crt = &amp;tfm-&gt;crt_hash;
+	struct hash_alg *alg = &amp;tfm-&gt;__crt_alg-&gt;cra_hash;
+
+	if (alg-&gt;digestsize &gt; crypto_tfm_alg_blocksize(tfm))
+		return -EINVAL;
+
+	crt-&gt;init = alg-&gt;init;
+	crt-&gt;update = alg-&gt;update;
+	crt-&gt;final = alg-&gt;final;
+	crt-&gt;digest = alg-&gt;digest;
+	crt-&gt;setkey = alg-&gt;setkey;
+	crt-&gt;digestsize = alg-&gt;digestsize;
+
+	return 0;
+}
+
+static void crypto_hash_show(struct seq_file *m, struct crypto_alg *alg)
+	__attribute_used__;
+static void crypto_hash_show(struct seq_file *m, struct crypto_alg *alg)
+{
+	seq_printf(m, "type         : hash\n");
+	seq_printf(m, "blocksize    : %u\n", alg-&gt;cra_blocksize);
+	seq_printf(m, "digestsize   : %u\n", alg-&gt;cra_hash.digestsize);
+}
+
+const struct crypto_type crypto_hash_type = {
+	.ctxsize = crypto_hash_ctxsize,
+	.init = crypto_init_hash_ops,
+#ifdef CONFIG_PROC_FS
+	.show = crypto_hash_show,
+#endif
+};
+EXPORT_SYMBOL_GPL(crypto_hash_type);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Generic cryptographic hash type");
diff --git a/crypto/hmac.c b/crypto/hmac.c
--- a/crypto/hmac.c
+++ b/crypto/hmac.c
@@ -35,9 +35,9 @@ int crypto_alloc_hmac_block(struct crypt
 
 	BUG_ON(!crypto_tfm_alg_blocksize(tfm));
 	
-	tfm-&gt;crt_digest.dit_hmac_block = kmalloc(crypto_tfm_alg_blocksize(tfm),
-	                                         GFP_KERNEL);
-	if (tfm-&gt;crt_digest.dit_hmac_block == NULL)
+	tfm-&gt;crt_hash.hmac_block = kmalloc(crypto_tfm_alg_blocksize(tfm),
+					   GFP_KERNEL);
+	if (tfm-&gt;crt_hash.hmac_block == NULL)
 		ret = -ENOMEM;
 
 	return ret;
@@ -46,14 +46,14 @@ int crypto_alloc_hmac_block(struct crypt
 
 void crypto_free_hmac_block(struct crypto_tfm *tfm)
 {
-	kfree(tfm-&gt;crt_digest.dit_hmac_block);
+	kfree(tfm-&gt;crt_hash.hmac_block);
 }
 
 void crypto_hmac_init(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen)
 {
 	unsigned int i;
 	struct scatterlist tmp;
-	char *ipad = tfm-&gt;crt_digest.dit_hmac_block;
+	char *ipad = tfm-&gt;crt_hash.hmac_block;
 	
 	if (*keylen &gt; crypto_tfm_alg_blocksize(tfm)) {
 		hash_key(tfm, key, *keylen);
@@ -83,7 +83,7 @@ void crypto_hmac_final(struct crypto_tfm
 {
 	unsigned int i;
 	struct scatterlist tmp;
-	char *opad = tfm-&gt;crt_digest.dit_hmac_block;
+	char *opad = tfm-&gt;crt_hash.hmac_block;
 	
 	if (*keylen &gt; crypto_tfm_alg_blocksize(tfm)) {
 		hash_key(tfm, key, *keylen);
diff --git a/crypto/scatterwalk.h b/crypto/scatterwalk.h
--- a/crypto/scatterwalk.h
+++ b/crypto/scatterwalk.h
@@ -20,11 +20,9 @@
 
 #include "internal.h"
 
-/* Define sg_next is an inline routine now in case we want to change
-   scatterlist to a linked list later. */
 static inline struct scatterlist *sg_next(struct scatterlist *sg)
 {
-	return sg + 1;
+	return (++sg)-&gt;length ? sg : (void *)sg-&gt;page;
 }
 
 static inline unsigned long scatterwalk_samebuf(struct scatter_walk *walk_in,
diff --git a/include/crypto/algapi.h b/include/crypto/algapi.h
--- a/include/crypto/algapi.h
+++ b/include/crypto/algapi.h
@@ -82,6 +82,7 @@ struct blkcipher_walk {
 };
 
 extern const struct crypto_type crypto_blkcipher_type;
+extern const struct crypto_type crypto_hash_type;
 
 void crypto_mod_put(struct crypto_alg *alg);
 
@@ -136,6 +137,11 @@ static inline struct cipher_alg *crypto_
 	return &amp;crypto_cipher_tfm(tfm)-&gt;__crt_alg-&gt;cra_cipher;
 }
 
+static inline void *crypto_hash_ctx_aligned(struct crypto_hash *tfm)
+{
+	return crypto_tfm_ctx_aligned(&amp;tfm-&gt;base);
+}
+
 static inline void blkcipher_walk_init(struct blkcipher_walk *walk,
 				       struct scatterlist *dst,
 				       struct scatterlist *src,
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -31,8 +31,11 @@
 #define CRYPTO_ALG_TYPE_MASK		0x0000000f
 #define CRYPTO_ALG_TYPE_CIPHER		0x00000001
 #define CRYPTO_ALG_TYPE_DIGEST		0x00000002
-#define CRYPTO_ALG_TYPE_BLKCIPHER	0x00000003
-#define CRYPTO_ALG_TYPE_COMPRESS	0x00000004
+#define CRYPTO_ALG_TYPE_HASH		0x00000003
+#define CRYPTO_ALG_TYPE_BLKCIPHER	0x00000004
+#define CRYPTO_ALG_TYPE_COMPRESS	0x00000005
+
+#define CRYPTO_ALG_TYPE_HASH_MASK	0x0000000e
 
 #define CRYPTO_ALG_LARVAL		0x00000010
 #define CRYPTO_ALG_DEAD			0x00000020
@@ -90,6 +93,7 @@
 
 struct scatterlist;
 struct crypto_blkcipher;
+struct crypto_hash;
 struct crypto_tfm;
 struct crypto_type;
 
@@ -107,6 +111,11 @@ struct cipher_desc {
 	void *info;
 };
 
+struct hash_desc {
+	struct crypto_hash *tfm;
+	u32 flags;
+};
+
 /*
  * Algorithms: modular crypto algorithm implementations, managed
  * via crypto_register_alg() and crypto_unregister_alg().
@@ -158,6 +167,19 @@ struct digest_alg {
 	                  unsigned int keylen);
 };
 
+struct hash_alg {
+	int (*init)(struct hash_desc *desc);
+	int (*update)(struct hash_desc *desc, struct scatterlist *sg,
+		      unsigned int nbytes);
+	int (*final)(struct hash_desc *desc, u8 *out);
+	int (*digest)(struct hash_desc *desc, struct scatterlist *sg,
+		      unsigned int nbytes, u8 *out);
+	int (*setkey)(struct crypto_hash *tfm, const u8 *key,
+		      unsigned int keylen);
+
+	unsigned int digestsize;
+};
+
 struct compress_alg {
 	int (*coa_compress)(struct crypto_tfm *tfm, const u8 *src,
 			    unsigned int slen, u8 *dst, unsigned int *dlen);
@@ -168,6 +190,7 @@ struct compress_alg {
 #define cra_blkcipher	cra_u.blkcipher
 #define cra_cipher	cra_u.cipher
 #define cra_digest	cra_u.digest
+#define cra_hash	cra_u.hash
 #define cra_compress	cra_u.compress
 
 struct crypto_alg {
@@ -191,6 +214,7 @@ struct crypto_alg {
 		struct blkcipher_alg blkcipher;
 		struct cipher_alg cipher;
 		struct digest_alg digest;
+		struct hash_alg hash;
 		struct compress_alg compress;
 	} cra_u;
 
@@ -262,18 +286,19 @@ struct cipher_tfm {
 	void (*cit_decrypt_one)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
 };
 
-struct digest_tfm {
-	void (*dit_init)(struct crypto_tfm *tfm);
-	void (*dit_update)(struct crypto_tfm *tfm,
-	                   struct scatterlist *sg, unsigned int nsg);
-	void (*dit_final)(struct crypto_tfm *tfm, u8 *out);
-	void (*dit_digest)(struct crypto_tfm *tfm, struct scatterlist *sg,
-	                   unsigned int nsg, u8 *out);
-	int (*dit_setkey)(struct crypto_tfm *tfm,
-	                  const u8 *key, unsigned int keylen);
+struct hash_tfm {
+	int (*init)(struct hash_desc *desc);
+	int (*update)(struct hash_desc *desc,
+		      struct scatterlist *sg, unsigned int nsg);
+	int (*final)(struct hash_desc *desc, u8 *out);
+	int (*digest)(struct hash_desc *desc, struct scatterlist *sg,
+		      unsigned int nsg, u8 *out);
+	int (*setkey)(struct crypto_hash *tfm, const u8 *key,
+		      unsigned int keylen);
 #ifdef CONFIG_CRYPTO_HMAC
-	void *dit_hmac_block;
+	void *hmac_block;
 #endif
+	unsigned int digestsize;
 };
 
 struct compress_tfm {
@@ -287,7 +312,7 @@ struct compress_tfm {
 
 #define crt_blkcipher	crt_u.blkcipher
 #define crt_cipher	crt_u.cipher
-#define crt_digest	crt_u.digest
+#define crt_hash	crt_u.hash
 #define crt_compress	crt_u.compress
 
 struct crypto_tfm {
@@ -297,7 +322,7 @@ struct crypto_tfm {
 	union {
 		struct blkcipher_tfm blkcipher;
 		struct cipher_tfm cipher;
-		struct digest_tfm digest;
+		struct hash_tfm hash;
 		struct compress_tfm compress;
 	} crt_u;
 	
@@ -312,6 +337,10 @@ struct crypto_blkcipher {
 	struct crypto_tfm base;
 };
 
+struct crypto_hash {
+	struct crypto_tfm base;
+};
+
 enum {
 	CRYPTOA_UNSPEC,
 	CRYPTOA_ALG,
@@ -647,39 +676,114 @@ static inline void crypto_cipher_decrypt
 						dst, src);
 }
 
-static inline void crypto_digest_init(struct crypto_tfm *tfm)
+void crypto_digest_init(struct crypto_tfm *tfm);
+void crypto_digest_update(struct crypto_tfm *tfm,
+			  struct scatterlist *sg, unsigned int nsg);
+void crypto_digest_final(struct crypto_tfm *tfm, u8 *out);
+void crypto_digest_digest(struct crypto_tfm *tfm,
+			  struct scatterlist *sg, unsigned int nsg, u8 *out);
+
+static inline struct crypto_hash *__crypto_hash_cast(struct crypto_tfm *tfm)
 {
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
-	tfm-&gt;crt_digest.dit_init(tfm);
+	return (struct crypto_hash *)tfm;
 }
 
-static inline void crypto_digest_update(struct crypto_tfm *tfm,
-                                        struct scatterlist *sg,
-                                        unsigned int nsg)
+static inline struct crypto_hash *crypto_hash_cast(struct crypto_tfm *tfm)
 {
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
-	tfm-&gt;crt_digest.dit_update(tfm, sg, nsg);
+	BUG_ON((crypto_tfm_alg_type(tfm) ^ CRYPTO_ALG_TYPE_HASH) &amp;
+	       CRYPTO_ALG_TYPE_HASH_MASK);
+	return __crypto_hash_cast(tfm);
 }
 
-static inline void crypto_digest_final(struct crypto_tfm *tfm, u8 *out)
+static inline int crypto_digest_setkey(struct crypto_tfm *tfm,
+                                       const u8 *key, unsigned int keylen)
 {
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
-	tfm-&gt;crt_digest.dit_final(tfm, out);
+	return tfm-&gt;crt_hash.setkey(crypto_hash_cast(tfm), key, keylen);
 }
 
-static inline void crypto_digest_digest(struct crypto_tfm *tfm,
-                                        struct scatterlist *sg,
-                                        unsigned int nsg, u8 *out)
+static inline struct crypto_hash *crypto_alloc_hash(const char *alg_name,
+						    u32 type, u32 mask)
 {
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
-	tfm-&gt;crt_digest.dit_digest(tfm, sg, nsg, out);
+	type &amp;= ~CRYPTO_ALG_TYPE_MASK;
+	type |= CRYPTO_ALG_TYPE_HASH;
+	mask |= CRYPTO_ALG_TYPE_HASH_MASK;
+
+	return __crypto_hash_cast(crypto_alloc_base(alg_name, type, mask));
 }
 
-static inline int crypto_digest_setkey(struct crypto_tfm *tfm,
-                                       const u8 *key, unsigned int keylen)
+static inline struct crypto_tfm *crypto_hash_tfm(struct crypto_hash *tfm)
 {
-	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
-	return tfm-&gt;crt_digest.dit_setkey(tfm, key, keylen);
+	return &amp;tfm-&gt;base;
+}
+
+static inline void crypto_free_hash(struct crypto_hash *tfm)
+{
+	crypto_free_tfm(crypto_hash_tfm(tfm));
+}
+
+static inline struct hash_tfm *crypto_hash_crt(struct crypto_hash *tfm)
+{
+	return &amp;crypto_hash_tfm(tfm)-&gt;crt_hash;
+}
+
+static inline unsigned int crypto_hash_blocksize(struct crypto_hash *tfm)
+{
+	return crypto_tfm_alg_blocksize(crypto_hash_tfm(tfm));
+}
+
+static inline unsigned int crypto_hash_alignmask(struct crypto_hash *tfm)
+{
+	return crypto_tfm_alg_alignmask(crypto_hash_tfm(tfm));
+}
+
+static inline unsigned int crypto_hash_digestsize(struct crypto_hash *tfm)
+{
+	return crypto_hash_crt(tfm)-&gt;digestsize;
+}
+
+static inline u32 crypto_hash_get_flags(struct crypto_hash *tfm)
+{
+	return crypto_tfm_get_flags(crypto_hash_tfm(tfm));
+}
+
+static inline void crypto_hash_set_flags(struct crypto_hash *tfm, u32 flags)
+{
+	crypto_tfm_set_flags(crypto_hash_tfm(tfm), flags);
+}
+
+static inline void crypto_hash_clear_flags(struct crypto_hash *tfm, u32 flags)
+{
+	crypto_tfm_clear_flags(crypto_hash_tfm(tfm), flags);
+}
+
+static inline int crypto_hash_init(struct hash_desc *desc)
+{
+	return crypto_hash_crt(desc-&gt;tfm)-&gt;init(desc);
+}
+
+static inline int crypto_hash_update(struct hash_desc *desc,
+				     struct scatterlist *sg,
+				     unsigned int nbytes)
+{
+	return crypto_hash_crt(desc-&gt;tfm)-&gt;update(desc, sg, nbytes);
+}
+
+static inline int crypto_hash_final(struct hash_desc *desc, u8 *out)
+{
+	return crypto_hash_crt(desc-&gt;tfm)-&gt;final(desc, out);
+}
+
+static inline int crypto_hash_digest(struct hash_desc *desc,
+				     struct scatterlist *sg,
+				     unsigned int nbytes, u8 *out)
+{
+	return crypto_hash_crt(desc-&gt;tfm)-&gt;digest(desc, sg, nbytes, out);
+}
+
+static inline int crypto_hash_setkey(struct crypto_hash *hash,
+				     const u8 *key, unsigned int keylen)
+{
+	return crypto_hash_crt(hash)-&gt;setkey(hash, key, keylen);
 }
 
 static int crypto_cipher_encrypt(struct crypto_tfm *tfm,
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060821142744</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-21 14:27:44-0400</timestampReceived><subject>[PATCH 2/7] [CRYPTO] hmac: Add crypto template implementation</subject><body>

[CRYPTO] hmac: Add crypto template implementation

This patch rewrites HMAC as a crypto template.  This means that HMAC is no
longer a hard-coded part of the API.  It's now a template that generates
standard digest algorithms like any other.

The old HMAC is preserved until all current users are converted.

The same structure can be used by other MACs such as AES-XCBC-MAC.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;
---

 crypto/Kconfig |    1 
 crypto/hmac.c  |  241 +++++++++++++++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 236 insertions(+), 6 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -34,6 +34,7 @@ config CRYPTO_MANAGER
 
 config CRYPTO_HMAC
 	bool "HMAC support"
+	select CRYPTO_HASH
 	help
 	  HMAC: Keyed-Hashing for Message Authentication (RFC2104).
 	  This is required for IPSec.
diff --git a/crypto/hmac.c b/crypto/hmac.c
--- a/crypto/hmac.c
+++ b/crypto/hmac.c
@@ -4,22 +4,30 @@
  * HMAC: Keyed-Hashing for Message Authentication (RFC2104).
  *
  * Copyright (c) 2002 James Morris &lt;jmorris@intercode.com.au&gt;
+ * Copyright (c) 2006 Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
  *
  * The HMAC implementation is derived from USAGI.
  * Copyright (c) 2002 Kazunori Miyazawa &lt;miyazawa@linux-ipv6.org&gt; / USAGI
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option) 
+ * Software Foundation; either version 2 of the License, or (at your option)
  * any later version.
  *
  */
-#include &lt;linux/crypto.h&gt;
-#include &lt;linux/mm.h&gt;
-#include &lt;linux/highmem.h&gt;
-#include &lt;linux/slab.h&gt;
+
+#include &lt;crypto/algapi.h&gt;
+#include &lt;linux/err.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
 #include &lt;linux/scatterlist.h&gt;
-#include "internal.h"
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/string.h&gt;
+
+struct hmac_ctx {
+	struct crypto_hash *child;
+};
 
 static void hash_key(struct crypto_tfm *tfm, u8 *key, unsigned int keylen)
 {
@@ -122,3 +130,224 @@ EXPORT_SYMBOL_GPL(crypto_hmac_update);
 EXPORT_SYMBOL_GPL(crypto_hmac_final);
 EXPORT_SYMBOL_GPL(crypto_hmac);
 
+static inline void *align_ptr(void *p, unsigned int align)
+{
+	return (void *)ALIGN((unsigned long)p, align);
+}
+
+static inline struct hmac_ctx *hmac_ctx(struct crypto_hash *tfm)
+{
+	return align_ptr(crypto_hash_ctx_aligned(tfm) +
+			 crypto_hash_blocksize(tfm) * 2 +
+			 crypto_hash_digestsize(tfm), sizeof(void *));
+}
+
+static int hmac_setkey(struct crypto_hash *parent,
+		       const u8 *inkey, unsigned int keylen)
+{
+	int bs = crypto_hash_blocksize(parent);
+	int ds = crypto_hash_digestsize(parent);
+	char *ipad = crypto_hash_ctx_aligned(parent);
+	char *opad = ipad + bs;
+	char *digest = opad + bs;
+	struct hmac_ctx *ctx = align_ptr(digest + ds, sizeof(void *));
+	struct crypto_hash *tfm = ctx-&gt;child;
+	unsigned int i;
+
+	if (keylen &gt; bs) {
+		struct hash_desc desc;
+		struct scatterlist tmp;
+		int err;
+
+		desc.tfm = tfm;
+		desc.flags = crypto_hash_get_flags(parent);
+		desc.flags &amp;= CRYPTO_TFM_REQ_MAY_SLEEP;
+		sg_set_buf(&amp;tmp, inkey, keylen);
+
+		err = crypto_hash_digest(&amp;desc, &amp;tmp, keylen, digest);
+		if (err)
+			return err;
+
+		inkey = digest;
+		keylen = ds;
+	}
+
+	memcpy(ipad, inkey, keylen);
+	memset(ipad + keylen, 0, bs - keylen);
+	memcpy(opad, ipad, bs);
+
+	for (i = 0; i &lt; bs; i++) {
+		ipad[i] ^= 0x36;
+		opad[i] ^= 0x5c;
+	}
+
+	return 0;
+}
+
+static int hmac_init(struct hash_desc *pdesc)
+{
+	struct crypto_hash *parent = pdesc-&gt;tfm;
+	int bs = crypto_hash_blocksize(parent);
+	int ds = crypto_hash_digestsize(parent);
+	char *ipad = crypto_hash_ctx_aligned(parent);
+	struct hmac_ctx *ctx = align_ptr(ipad + bs * 2 + ds, sizeof(void *));
+	struct hash_desc desc;
+	struct scatterlist tmp;
+
+	desc.tfm = ctx-&gt;child;
+	desc.flags = pdesc-&gt;flags &amp; CRYPTO_TFM_REQ_MAY_SLEEP;
+	sg_set_buf(&amp;tmp, ipad, bs);
+
+	return unlikely(crypto_hash_init(&amp;desc)) ?:
+	       crypto_hash_update(&amp;desc, &amp;tmp, 1);
+}
+
+static int hmac_update(struct hash_desc *pdesc,
+		       struct scatterlist *sg, unsigned int nbytes)
+{
+	struct hmac_ctx *ctx = hmac_ctx(pdesc-&gt;tfm);
+	struct hash_desc desc;
+
+	desc.tfm = ctx-&gt;child;
+	desc.flags = pdesc-&gt;flags &amp; CRYPTO_TFM_REQ_MAY_SLEEP;
+
+	return crypto_hash_update(&amp;desc, sg, nbytes);
+}
+
+static int hmac_final(struct hash_desc *pdesc, u8 *out)
+{
+	struct crypto_hash *parent = pdesc-&gt;tfm;
+	int bs = crypto_hash_blocksize(parent);
+	int ds = crypto_hash_digestsize(parent);
+	char *opad = crypto_hash_ctx_aligned(parent) + bs;
+	char *digest = opad + bs;
+	struct hmac_ctx *ctx = align_ptr(digest + ds, sizeof(void *));
+	struct hash_desc desc;
+	struct scatterlist tmp;
+
+	desc.tfm = ctx-&gt;child;
+	desc.flags = pdesc-&gt;flags &amp; CRYPTO_TFM_REQ_MAY_SLEEP;
+	sg_set_buf(&amp;tmp, opad, bs + ds);
+
+	return unlikely(crypto_hash_final(&amp;desc, digest)) ?:
+	       crypto_hash_digest(&amp;desc, &amp;tmp, bs + ds, out);
+}
+
+static int hmac_digest(struct hash_desc *pdesc, struct scatterlist *sg,
+		       unsigned int nbytes, u8 *out)
+{
+	struct crypto_hash *parent = pdesc-&gt;tfm;
+	int bs = crypto_hash_blocksize(parent);
+	int ds = crypto_hash_digestsize(parent);
+	char *ipad = crypto_hash_ctx_aligned(parent);
+	char *opad = ipad + bs;
+	char *digest = opad + bs;
+	struct hmac_ctx *ctx = align_ptr(digest + ds, sizeof(void *));
+	struct hash_desc desc;
+	struct scatterlist sg1[2];
+	struct scatterlist sg2[1];
+
+	desc.tfm = ctx-&gt;child;
+	desc.flags = pdesc-&gt;flags &amp; CRYPTO_TFM_REQ_MAY_SLEEP;
+
+	sg_set_buf(sg1, ipad, bs);
+	sg1[1].page = (void *)sg;
+	sg1[1].length = 0;
+	sg_set_buf(sg2, opad, bs + ds);
+
+	return unlikely(crypto_hash_digest(&amp;desc, sg1, nbytes + bs, digest)) ?:
+	       crypto_hash_digest(&amp;desc, sg2, bs + ds, out);
+}
+
+static int hmac_init_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_instance *inst = (void *)tfm-&gt;__crt_alg;
+	struct crypto_spawn *spawn = crypto_instance_ctx(inst);
+	struct hmac_ctx *ctx = hmac_ctx(__crypto_hash_cast(tfm));
+
+	tfm = crypto_spawn_tfm(spawn);
+	if (IS_ERR(tfm))
+		return PTR_ERR(tfm);
+
+	ctx-&gt;child = crypto_hash_cast(tfm);
+	return 0;
+}
+
+static void hmac_exit_tfm(struct crypto_tfm *tfm)
+{
+	struct hmac_ctx *ctx = hmac_ctx(__crypto_hash_cast(tfm));
+	crypto_free_hash(ctx-&gt;child);
+}
+
+static void hmac_free(struct crypto_instance *inst)
+{
+	crypto_drop_spawn(crypto_instance_ctx(inst));
+	kfree(inst);
+}
+
+static struct crypto_instance *hmac_alloc(void *param, unsigned int len)
+{
+	struct crypto_instance *inst;
+	struct crypto_alg *alg;
+
+	alg = crypto_get_attr_alg(param, len, CRYPTO_ALG_TYPE_HASH,
+				  CRYPTO_ALG_TYPE_HASH_MASK | CRYPTO_ALG_ASYNC);
+	if (IS_ERR(alg))
+		return ERR_PTR(PTR_ERR(alg));
+
+	inst = crypto_alloc_instance("hmac", alg);
+	if (IS_ERR(inst))
+		goto out_put_alg;
+
+	inst-&gt;alg.cra_flags = CRYPTO_ALG_TYPE_HASH;
+	inst-&gt;alg.cra_priority = alg-&gt;cra_priority;
+	inst-&gt;alg.cra_blocksize = alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_alignmask = alg-&gt;cra_alignmask;
+	inst-&gt;alg.cra_type = &amp;crypto_hash_type;
+
+	inst-&gt;alg.cra_hash.digestsize =
+		(alg-&gt;cra_flags &amp; CRYPTO_ALG_TYPE_MASK) ==
+		CRYPTO_ALG_TYPE_HASH ? alg-&gt;cra_hash.digestsize :
+				       alg-&gt;cra_digest.dia_digestsize;
+
+	inst-&gt;alg.cra_ctxsize = sizeof(struct hmac_ctx) +
+				ALIGN(inst-&gt;alg.cra_blocksize * 2 +
+				      inst-&gt;alg.cra_hash.digestsize,
+				      sizeof(void *));
+
+	inst-&gt;alg.cra_init = hmac_init_tfm;
+	inst-&gt;alg.cra_exit = hmac_exit_tfm;
+
+	inst-&gt;alg.cra_hash.init = hmac_init;
+	inst-&gt;alg.cra_hash.update = hmac_update;
+	inst-&gt;alg.cra_hash.final = hmac_final;
+	inst-&gt;alg.cra_hash.digest = hmac_digest;
+	inst-&gt;alg.cra_hash.setkey = hmac_setkey;
+
+out_put_alg:
+	crypto_mod_put(alg);
+	return inst;
+}
+
+static struct crypto_template hmac_tmpl = {
+	.name = "hmac",
+	.alloc = hmac_alloc,
+	.free = hmac_free,
+	.module = THIS_MODULE,
+};
+
+static int __init hmac_module_init(void)
+{
+	return crypto_register_template(&amp;hmac_tmpl);
+}
+
+static void __exit hmac_module_exit(void)
+{
+	crypto_unregister_template(&amp;hmac_tmpl);
+}
+
+module_init(hmac_module_init);
+module_exit(hmac_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("HMAC hash algorithm");
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060820112009</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-20 11:20:09-0400</timestampReceived><subject>Re: [PATCH] cit_encrypt_iv/cit_decrypt_iv for ECB mode</subject><body>

Willy Tarreau &lt;w@1wt.eu&gt; wrote:
&gt; 
&gt; That's what I thought after reading the code too. BTW, 2.6 does not
&gt; initialize the pointers either.

This has been changed in the cryptodev-2.6 tree:

http://www.kernel.org/git/?p=linux/kernel/git/herbert/cryptodev-2.6.git;a=commitdiff;h=310d6a0c14eda153869adaf74e69dbd1a1256e7f


[CRYPTO] cipher: Removed special IV checks for ECB

This patch makes IV operations on ECB fail through nocrypt_iv rather than
calling BUG().  This is needed to generalise CBC/ECB using the template
mechanism.

In fact with the new block cipher type calling the IV-specific
functions on ECB will work in the same way as the IV-less functions.
This makes sense because the IV length is simply zero.
 
&gt; I wonder whether we shouldn't consider that those functions must at
&gt; least clear the memory area that was submitted to them, such as
&gt; proposed below. It would also fix the problem for potential other
&gt; users. I don't think we need to check whether dst is valid given
&gt; the small amount of tests performed in crypt().

If the user is ignoring the error value here then you're in serious
trouble anyway since they've just lost all their data.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


</body></email><email><emailId>20060823151840</emailId><senderName>Marco Fonseca</senderName><senderEmail>marco@tampabay.rr.com</senderEmail><timestampReceived>2006-08-23 15:18:40-0400</timestampReceived><subject>single-key vs multi-key</subject><body>

Hello,

I've been searching for some info on single-key vs multi-key, but 
haven't found a great deal of it.  How much more superior is multi-key 
over single-key.  Any info would be helpful.

Thanks,

Marco

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060827225524</emailId><senderName>"senphonie"</senderName><senderEmail>envoi@lymail.com</senderEmail><timestampReceived>2006-08-27 22:55:24-0400</timestampReceived><subject>La telephonie illimitee par Internet</subject><body>

La téléphonie illimitée par Internet 
 
Entreprises et Particuliers,

Découvrez notre forfait téléphonique monde illimité, sans engagement de durée.

N'hésitez plus, 

Ouverture immédiate de votre ligne
 
  
| Forfaits illimités | Standards | Offre revendeur | Vous désabonner |  2006 senphonie.com |  


[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=Content-Type content="text/html; charset=iso-8859-1"&gt;
&lt;/head&gt;
&lt;body topmargin="0" leftmargin="0" bgcolor="#FFFFFF" link="#075CA3" vlink="#075CA3" \
alink="#075CA3"&gt; &lt;div align="center"&gt;
  &lt;table width="650" border="0" cellspacing="0" cellpadding="0"&gt;
    &lt;tr height="61"&gt;
      &lt;td height="61" colspan="2" align="middle" valign="middle"&gt;&lt;table width="100%" \
border="0" cellspacing="0" cellpadding="3"&gt;  &lt;tr&gt;
            &lt;td width="126" height="74" align="right" valign="middle"&gt;&lt;img \
src="http://senphonie.lymail.com/images/fl.gif" border="0"&gt;&lt;/td&gt;  &lt;td \
width="32"&gt; &lt;/td&gt;  &lt;td width="492" valign="middle"&gt;&lt;font size="5" \
color="#004371" face="Arial, Helvetica, sans-serif"&gt;&lt;strong&gt;La \
téléphonie illimitée par Internet&lt;/strong&gt;&lt;/font&gt;&lt;/td&gt;  &lt;/tr&gt;
        &lt;/table&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td width="49%" align="center" valign="bottom" bgcolor="#000000"&gt;&lt;img \
src="http://senphonie.lymail.com/images/0001.jpg" width="318" height="264" \
                border="0"&gt;&lt;/td&gt;
      &lt;td width="51%" height="278" valign="center" bgcolor="#214987"&gt;&lt;div \
                align="center"&gt;
          &lt;p&gt;&lt;font color="#FFFFFF" face="Arial, Helvetica, \
sans-serif"&gt;&lt;strong&gt;Entreprises et Particuliers,&lt;br&gt;  &lt;br&gt;
            Découvrez notre forfait téléphonique monde \
illimité, sans engagement de durée.&lt;br&gt;  &lt;br&gt;
            N'hésitez plus, &lt;/strong&gt;&lt;/font&gt;&lt;br&gt;
            &lt;a href="http://senphonie.com/forfait.htm"&gt;&lt;img \
                src="http://senphonie.lymail.com/images/bt.gif" border="0"&gt;&lt;br&gt;
      &lt;/a&gt;&lt;font color="#FFFFFF" face="Arial, Helvetica, sans-serif"&gt;&lt;strong&gt;Ouverture \
immédiate de votre ligne&lt;/strong&gt;&lt;/font&gt;&lt;/div&gt;&lt;/td&gt;  &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td height="38" align="center" valign="middle"&gt;&lt;img \
                src="http://senphonie.lymail.com/images/bt1.gif" border="0"&gt;&lt;/td&gt;
      &lt;td align="center" valign="middle"&gt;&lt;img \
src="http://senphonie.lymail.com/images/bt2.gif" border="0"&gt;&lt;/td&gt;  &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td height="18" colspan="2" align="center" valign="top"&gt; | &lt;a \
href="http://senphonie.com/forfait.htm"&gt;&lt;font size="1" face="Arial, Helvetica, \
sans-serif"&gt;Forfaits illimités&lt;/font&gt;&lt;/a&gt; | &lt;a \
href="http://senphonie.com/standards_SPA_9000.htm"&gt;&lt;font size="1" face="Arial, \
Helvetica, sans-serif"&gt;Standards&lt;/font&gt;&lt;/a&gt; | &lt;a \
href="http://senphonie.com/offre_revendeur.htm"&gt;&lt;font size="1" face="Arial, \
Helvetica, sans-serif"&gt;Offre revendeur&lt;/font&gt;&lt;/a&gt; | &lt;a \
href="http://senphonie.lymail.com"&gt;&lt;font size="1" face="Arial, Helvetica, \
sans-serif"&gt;Vous désabonner&lt;/font&gt;&lt;/a&gt; | &lt;font size="1" face="Arial, \
Helvetica, sans-serif"&gt;© 2006 senphonie.com&lt;/font&gt; | &lt;/td&gt;  &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060821184441</emailId><senderName>Michael Zhu</senderName><senderEmail>mylinuxk@yahoo.ca</senderEmail><timestampReceived>2006-08-21 18:44:41-0400</timestampReceived><subject>Loop-AES &amp; Full-disk encryption</subject><body>

Hi, guys, I have some questions about the Loop-AES. Is
Loop-AES a kind of full-disk encryption? I mean
Loop-AES is a sector by sector partition based
encryption or not? I read the README about the
Loop-AES. It says that Loop-AES will create a boot
partition and this boot partition is unencrypted. What
kind of information contained in this small boot
partition? The Linux kernel image or just some kind of
boot records? Loop-AES will encrypt the entire
operation system including all the system files?

Thanks.

__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060821190923</emailId><senderName>"Alon Bar-Lev"</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2006-08-21 19:09:23-0400</timestampReceived><subject>Re: Loop-AES &amp; Full-disk encryption</subject><body>

Hello,

Yes.

Please have a look at http://wiki.suspend2.net/EncryptedSwapAndRoot I
think it should help you.

Best Regards,
Alon Bar-Lev.

On 8/21/06, Michael Zhu &lt;mylinuxk@yahoo.ca&gt; wrote:
&gt; Hi, guys, I have some questions about the Loop-AES. Is
&gt; Loop-AES a kind of full-disk encryption? I mean
&gt; Loop-AES is a sector by sector partition based
&gt; encryption or not? I read the README about the
&gt; Loop-AES. It says that Loop-AES will create a boot
&gt; partition and this boot partition is unencrypted. What
&gt; kind of information contained in this small boot
&gt; partition? The Linux kernel image or just some kind of
&gt; boot records? Loop-AES will encrypt the entire
&gt; operation system including all the system files?
&gt;
&gt; Thanks.
&gt;
&gt; __________________________________________________
&gt; Do You Yahoo!?
&gt; Tired of spam?  Yahoo! Mail has the best spam protection around
&gt; http://mail.yahoo.com
&gt;
&gt; -
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/
&gt;
&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060822153910</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-08-22 15:39:10-0400</timestampReceived><subject>Re: Loop-AES &amp; Full-disk encryption</subject><body>

Michael Zhu wrote:
&gt; Is Loop-AES a kind of full-disk encryption?

Loop-AES encrypts devices. You can encrypt full device /dev/hda using
loop-AES, but usually it is used to encrypt partitions like /dev/hda4

&gt; I mean Loop-AES is a sector by sector partition based encryption or not?

It is sector by sector encryption.

&gt; I read the README about the Loop-AES. It says that Loop-AES will create a
&gt; boot partition and this boot partition is unencrypted. What kind of
&gt; information contained in this small boot partition? The Linux kernel image
&gt; or just some kind of boot records? Loop-AES will encrypt the entire
&gt; operation system including all the system files?

Kernel needs to be loaded from some unencrypted device. Usually bootloader
and kernel are in /boot but sometimes they are loaded from CD-ROM or
USB-stick.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060829161108</emailId><senderName>Michael Zhu</senderName><senderEmail>mylinuxk@yahoo.ca</senderEmail><timestampReceived>2006-08-29 16:11:08-0400</timestampReceived><subject>Re: Loop-AES &amp; Full-disk encryption</subject><body>

Hi, Jari, thanks for the reply. I did some tests with
Loop-AES. From the README it seems that I have to
recompile/reconfig the kernel if I want to encrypt the
root partition. Am I right?

Thanks.

Michael


--- Jari Ruusu &lt;jariruusu@users.sourceforge.net&gt;
wrote:

&gt; Michael Zhu wrote:
&gt; &gt; Is Loop-AES a kind of full-disk encryption?
&gt; 
&gt; Loop-AES encrypts devices. You can encrypt full
&gt; device /dev/hda using
&gt; loop-AES, but usually it is used to encrypt
&gt; partitions like /dev/hda4
&gt; 
&gt; &gt; I mean Loop-AES is a sector by sector partition
&gt; based encryption or not?
&gt; 
&gt; It is sector by sector encryption.
&gt; 
&gt; &gt; I read the README about the Loop-AES. It says that
&gt; Loop-AES will create a
&gt; &gt; boot partition and this boot partition is
&gt; unencrypted. What kind of
&gt; &gt; information contained in this small boot
&gt; partition? The Linux kernel image
&gt; &gt; or just some kind of boot records? Loop-AES will
&gt; encrypt the entire
&gt; &gt; operation system including all the system files?
&gt; 
&gt; Kernel needs to be loaded from some unencrypted
&gt; device. Usually bootloader
&gt; and kernel are in /boot but sometimes they are
&gt; loaded from CD-ROM or
&gt; USB-stick.
&gt; 
&gt; -- 
&gt; Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9 
&gt; DB 1D EB E3 24 0E A9 DD
&gt; 


__________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060827225828</emailId><senderName>"senphonie"</senderName><senderEmail>envoi@lymail.com</senderEmail><timestampReceived>2006-08-27 22:58:28-0400</timestampReceived><subject>La telephonie illimitee par Internet</subject><body>

La téléphonie illimitée par Internet 
 
Entreprises et Particuliers,

Découvrez notre forfait téléphonique monde illimité, sans engagement de durée.

N'hésitez plus, 

Ouverture immédiate de votre ligne
 
  
| Forfaits illimités | Standards | Offre revendeur | Vous désabonner |  2006 senphonie.com |  


[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=Content-Type content="text/html; charset=iso-8859-1"&gt;
&lt;/head&gt;
&lt;body topmargin="0" leftmargin="0" bgcolor="#FFFFFF" link="#075CA3" vlink="#075CA3" \
alink="#075CA3"&gt; &lt;div align="center"&gt;
  &lt;table width="650" border="0" cellspacing="0" cellpadding="0"&gt;
    &lt;tr height="61"&gt;
      &lt;td height="61" colspan="2" align="middle" valign="middle"&gt;&lt;table width="100%" \
border="0" cellspacing="0" cellpadding="3"&gt;  &lt;tr&gt;
            &lt;td width="126" height="74" align="right" valign="middle"&gt;&lt;img \
src="http://senphonie.lymail.com/images/fl.gif" border="0"&gt;&lt;/td&gt;  &lt;td \
width="32"&gt; &lt;/td&gt;  &lt;td width="492" valign="middle"&gt;&lt;font size="5" \
color="#004371" face="Arial, Helvetica, sans-serif"&gt;&lt;strong&gt;La \
téléphonie illimitée par Internet&lt;/strong&gt;&lt;/font&gt;&lt;/td&gt;  &lt;/tr&gt;
        &lt;/table&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td width="49%" align="center" valign="bottom" bgcolor="#000000"&gt;&lt;img \
src="http://senphonie.lymail.com/images/0001.jpg" width="318" height="264" \
                border="0"&gt;&lt;/td&gt;
      &lt;td width="51%" height="278" valign="center" bgcolor="#214987"&gt;&lt;div \
                align="center"&gt;
          &lt;p&gt;&lt;font color="#FFFFFF" face="Arial, Helvetica, \
sans-serif"&gt;&lt;strong&gt;Entreprises et Particuliers,&lt;br&gt;  &lt;br&gt;
            Découvrez notre forfait téléphonique monde \
illimité, sans engagement de durée.&lt;br&gt;  &lt;br&gt;
            N'hésitez plus, &lt;/strong&gt;&lt;/font&gt;&lt;br&gt;
            &lt;a href="http://senphonie.com/forfait.htm"&gt;&lt;img \
                src="http://senphonie.lymail.com/images/bt.gif" border="0"&gt;&lt;br&gt;
      &lt;/a&gt;&lt;font color="#FFFFFF" face="Arial, Helvetica, sans-serif"&gt;&lt;strong&gt;Ouverture \
immédiate de votre ligne&lt;/strong&gt;&lt;/font&gt;&lt;/div&gt;&lt;/td&gt;  &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td height="38" align="center" valign="middle"&gt;&lt;img \
                src="http://senphonie.lymail.com/images/bt1.gif" border="0"&gt;&lt;/td&gt;
      &lt;td align="center" valign="middle"&gt;&lt;img \
src="http://senphonie.lymail.com/images/bt2.gif" border="0"&gt;&lt;/td&gt;  &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td height="18" colspan="2" align="center" valign="top"&gt; | &lt;a \
href="http://senphonie.com/forfait.htm"&gt;&lt;font size="1" face="Arial, Helvetica, \
sans-serif"&gt;Forfaits illimités&lt;/font&gt;&lt;/a&gt; | &lt;a \
href="http://senphonie.com/standards_SPA_9000.htm"&gt;&lt;font size="1" face="Arial, \
Helvetica, sans-serif"&gt;Standards&lt;/font&gt;&lt;/a&gt; | &lt;a \
href="http://senphonie.com/offre_revendeur.htm"&gt;&lt;font size="1" face="Arial, \
Helvetica, sans-serif"&gt;Offre revendeur&lt;/font&gt;&lt;/a&gt; | &lt;a \
href="http://senphonie.lymail.com"&gt;&lt;font size="1" face="Arial, Helvetica, \
sans-serif"&gt;Vous désabonner&lt;/font&gt;&lt;/a&gt; | &lt;font size="1" face="Arial, \
Helvetica, sans-serif"&gt;© 2006 senphonie.com&lt;/font&gt; | &lt;/td&gt;  &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060820144908</emailId><senderName>Solar Designer</senderName><senderEmail>solar@openwall.com</senderEmail><timestampReceived>2006-08-20 14:49:08-0400</timestampReceived><subject>Re: [PATCH] cit_encrypt_iv/cit_decrypt_iv for ECB mode</subject><body>

On Sun, Aug 20, 2006 at 10:04:03AM +0200, Willy Tarreau wrote:
&gt; On Sun, Aug 20, 2006 at 04:23:46AM +0400, Solar Designer wrote:
&gt; &gt; The attached patch actually defines ecb_encrypt_iv() and
&gt; &gt; ecb_decrypt_iv() functions that perform ECB encryption/decryption
&gt; &gt; ignoring the IV, yet return -ENOSYS (just like nocrypt_iv would).
&gt; &gt; The result is no more Oopses and no infoleaks either.
&gt; 
&gt; Can the cryptoloop patch use CRYPTO_TFM_MODE_CFB or CRYPTO_TFM_MODE_CTR
&gt; and so be redirected to nocrypt() which will leave uninitialized memory
&gt; too ?

At least patch-cryptoloop-jari-2.4.22.0 in particular will only do CBC
(default, preferred) or ECB (if requested); it won't attempt to use CFB
or CTR.

Regarding nocrypt*():

&gt; I wonder whether we shouldn't consider that those functions must at
&gt; least clear the memory area that was submitted to them, such as
&gt; proposed below. It would also fix the problem for potential other
&gt; users.

This makes sense to me, although it is not perfect as Herbert has
correctly pointed out:

&gt; If the user is ignoring the error value here then you're in serious
&gt; trouble anyway since they've just lost all their data.

Can we maybe define working but IV-ignoring functions for ECB (like I
did), but use memory-clearing nocrypt*() for CFB and CTR (as long as
these are not supported)?  Of course, all of these will return -ENOSYS.

Alexander
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060820161346</emailId><senderName>Willy Tarreau</senderName><senderEmail>w@1wt.eu</senderEmail><timestampReceived>2006-08-20 16:13:46-0400</timestampReceived><subject>Re: [PATCH] cit_encrypt_iv/cit_decrypt_iv for ECB mode</subject><body>

On Sun, Aug 20, 2006 at 06:49:08PM +0400, Solar Designer wrote:
&gt; On Sun, Aug 20, 2006 at 10:04:03AM +0200, Willy Tarreau wrote:
&gt; &gt; On Sun, Aug 20, 2006 at 04:23:46AM +0400, Solar Designer wrote:
&gt; &gt; &gt; The attached patch actually defines ecb_encrypt_iv() and
&gt; &gt; &gt; ecb_decrypt_iv() functions that perform ECB encryption/decryption
&gt; &gt; &gt; ignoring the IV, yet return -ENOSYS (just like nocrypt_iv would).
&gt; &gt; &gt; The result is no more Oopses and no infoleaks either.
&gt; &gt; 
&gt; &gt; Can the cryptoloop patch use CRYPTO_TFM_MODE_CFB or CRYPTO_TFM_MODE_CTR
&gt; &gt; and so be redirected to nocrypt() which will leave uninitialized memory
&gt; &gt; too ?
&gt; 
&gt; At least patch-cryptoloop-jari-2.4.22.0 in particular will only do CBC
&gt; (default, preferred) or ECB (if requested); it won't attempt to use CFB
&gt; or CTR.
&gt; 
&gt; Regarding nocrypt*():
&gt; 
&gt; &gt; I wonder whether we shouldn't consider that those functions must at
&gt; &gt; least clear the memory area that was submitted to them, such as
&gt; &gt; proposed below. It would also fix the problem for potential other
&gt; &gt; users.
&gt; 
&gt; This makes sense to me, although it is not perfect as Herbert has
&gt; correctly pointed out:
&gt; 
&gt; &gt; If the user is ignoring the error value here then you're in serious
&gt; &gt; trouble anyway since they've just lost all their data.
&gt;
&gt; Can we maybe define working but IV-ignoring functions for ECB (like I
&gt; did), but use memory-clearing nocrypt*() for CFB and CTR (as long as
&gt; these are not supported)?  Of course, all of these will return -ENOSYS.

I thought we would not have to protect users from shooting themselves in
the foot (right now they get an oops). But I agree that the cost of
protecting them is close to zero so we probably should do it. If Herbert
is OK, do you care to provide a new patch ?

&gt; Alexander

Thanks,
willy

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060820165846</emailId><senderName>Solar Designer</senderName><senderEmail>solar@openwall.com</senderEmail><timestampReceived>2006-08-20 16:58:46-0400</timestampReceived><subject>Re: [PATCH] cit_encrypt_iv/cit_decrypt_iv for ECB mode</subject><body>

On Sun, Aug 20, 2006 at 06:13:46PM +0200, Willy Tarreau wrote:
&gt; On Sun, Aug 20, 2006 at 06:49:08PM +0400, Solar Designer wrote:
&gt; &gt; Can we maybe define working but IV-ignoring functions for ECB (like I
&gt; &gt; did), but use memory-clearing nocrypt*() for CFB and CTR (as long as
&gt; &gt; these are not supported)?  Of course, all of these will return -ENOSYS.
&gt; 
&gt; I thought we would not have to protect users from shooting themselves in
&gt; the foot (right now they get an oops). But I agree that the cost of
&gt; protecting them is close to zero so we probably should do it. If Herbert
&gt; is OK, do you care to provide a new patch ?

Yes, if the above proposal is OK with Herbert, I will provide a new
patch for 2.4.

Thanks,

Alexander
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060820225830</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-20 22:58:30-0400</timestampReceived><subject>Re: [PATCH] cit_encrypt_iv/cit_decrypt_iv for ECB mode</subject><body>

On Sun, Aug 20, 2006 at 06:49:08PM +0400, Solar Designer wrote:
&gt; 
&gt; Can we maybe define working but IV-ignoring functions for ECB (like I
&gt; did), but use memory-clearing nocrypt*() for CFB and CTR (as long as
&gt; these are not supported)?  Of course, all of these will return -ENOSYS.

In cryptodev-2.6, with block ciphers you can no longer select CFB/CTR
until someone writes support for them so this is no longer an issue.

For 2.4, I don't really mind either way what nocrypt does.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060821142747</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-21 14:27:47-0400</timestampReceived><subject>[PATCH 3/7] [CRYPTO] tcrypt: Use HMAC template and hash interface</subject><body>

[CRYPTO] tcrypt: Use HMAC template and hash interface

This patch converts tcrypt to use the new HMAC template rather than the
hard-coded version of HMAC.  It also converts all digest users to use
the new cipher interface.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;
---

 crypto/tcrypt.c |  355 ++++++++++++++++++++++++++++++++------------------------
 crypto/tcrypt.h |   23 ---
 2 files changed, 213 insertions(+), 165 deletions(-)

diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -88,9 +88,11 @@ static void test_hash(char *algo, struct
 	unsigned int i, j, k, temp;
 	struct scatterlist sg[8];
 	char result[64];
-	struct crypto_tfm *tfm;
+	struct crypto_hash *tfm;
+	struct hash_desc desc;
 	struct hash_testvec *hash_tv;
 	unsigned int tsize;
+	int ret;
 
 	printk("\ntesting %s\n", algo);
 
@@ -104,27 +106,42 @@ static void test_hash(char *algo, struct
 
 	memcpy(tvmem, template, tsize);
 	hash_tv = (void *)tvmem;
-	tfm = crypto_alloc_tfm(algo, 0);
-	if (tfm == NULL) {
-		printk("failed to load transform for %s\n", algo);
+
+	tfm = crypto_alloc_hash(algo, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(tfm)) {
+		printk("failed to load transform for %s: %ld\n", algo,
+		       PTR_ERR(tfm));
 		return;
 	}
 
+	desc.tfm = tfm;
+	desc.flags = 0;
+
 	for (i = 0; i &lt; tcount; i++) {
 		printk("test %u:\n", i + 1);
 		memset(result, 0, 64);
 
 		sg_set_buf(&amp;sg[0], hash_tv[i].plaintext, hash_tv[i].psize);
 
-		crypto_digest_init(tfm);
-		crypto_digest_setkey(tfm, hash_tv[i].key, hash_tv[i].ksize);
-		crypto_digest_update(tfm, sg, 1);
-		crypto_digest_final(tfm, result);
+		if (hash_tv[i].ksize) {
+			ret = crypto_hash_setkey(tfm, hash_tv[i].key,
+						 hash_tv[i].ksize);
+			if (ret) {
+				printk("setkey() failed ret=%d\n", ret);
+				goto out;
+			}
+		}
+
+		ret = crypto_hash_digest(&amp;desc, sg, hash_tv[i].psize, result);
+		if (ret) {
+			printk("digest () failed ret=%d\n", ret);
+			goto out;
+		}
 
-		hexdump(result, crypto_tfm_alg_digestsize(tfm));
+		hexdump(result, crypto_hash_digestsize(tfm));
 		printk("%s\n",
 		       memcmp(result, hash_tv[i].digest,
-			      crypto_tfm_alg_digestsize(tfm)) ?
+			      crypto_hash_digestsize(tfm)) ?
 		       "fail" : "pass");
 	}
 
@@ -150,105 +167,35 @@ static void test_hash(char *algo, struct
 					    hash_tv[i].tap[k]);
 			}
 
-			crypto_digest_digest(tfm, sg, hash_tv[i].np, result);
-
-			hexdump(result, crypto_tfm_alg_digestsize(tfm));
-			printk("%s\n",
-			       memcmp(result, hash_tv[i].digest,
-				      crypto_tfm_alg_digestsize(tfm)) ?
-			       "fail" : "pass");
-		}
-	}
-
-	crypto_free_tfm(tfm);
-}
-
-
-#ifdef CONFIG_CRYPTO_HMAC
-
-static void test_hmac(char *algo, struct hmac_testvec *template,
-		      unsigned int tcount)
-{
-	unsigned int i, j, k, temp;
-	struct scatterlist sg[8];
-	char result[64];
-	struct crypto_tfm *tfm;
-	struct hmac_testvec *hmac_tv;
-	unsigned int tsize, klen;
-
-	tfm = crypto_alloc_tfm(algo, 0);
-	if (tfm == NULL) {
-		printk("failed to load transform for %s\n", algo);
-		return;
-	}
-
-	printk("\ntesting hmac_%s\n", algo);
-
-	tsize = sizeof(struct hmac_testvec);
-	tsize *= tcount;
-	if (tsize &gt; TVMEMSIZE) {
-		printk("template (%u) too big for tvmem (%u)\n", tsize,
-		       TVMEMSIZE);
-		goto out;
-	}
-
-	memcpy(tvmem, template, tsize);
-	hmac_tv = (void *)tvmem;
-
-	for (i = 0; i &lt; tcount; i++) {
-		printk("test %u:\n", i + 1);
-		memset(result, 0, sizeof (result));
-
-		klen = hmac_tv[i].ksize;
-		sg_set_buf(&amp;sg[0], hmac_tv[i].plaintext, hmac_tv[i].psize);
+			if (hash_tv[i].ksize) {
+				ret = crypto_hash_setkey(tfm, hash_tv[i].key,
+							 hash_tv[i].ksize);
 
-		crypto_hmac(tfm, hmac_tv[i].key, &amp;klen, sg, 1, result);
-
-		hexdump(result, crypto_tfm_alg_digestsize(tfm));
-		printk("%s\n",
-		       memcmp(result, hmac_tv[i].digest,
-			      crypto_tfm_alg_digestsize(tfm)) ? "fail" :
-		       "pass");
-	}
-
-	printk("\ntesting hmac_%s across pages\n", algo);
-
-	memset(xbuf, 0, XBUFSIZE);
-
-	j = 0;
-	for (i = 0; i &lt; tcount; i++) {
-		if (hmac_tv[i].np) {
-			j++;
-			printk("test %u:\n",j);
-			memset(result, 0, 64);
-
-			temp = 0;
-			klen = hmac_tv[i].ksize;
-			for (k = 0; k &lt; hmac_tv[i].np; k++) {
-				memcpy(&amp;xbuf[IDX[k]],
-				       hmac_tv[i].plaintext + temp,
-				       hmac_tv[i].tap[k]);
-				temp += hmac_tv[i].tap[k];
-				sg_set_buf(&amp;sg[k], &amp;xbuf[IDX[k]],
-					    hmac_tv[i].tap[k]);
+				if (ret) {
+					printk("setkey() failed ret=%d\n", ret);
+					goto out;
+				}
 			}
 
-			crypto_hmac(tfm, hmac_tv[i].key, &amp;klen, sg,
-				    hmac_tv[i].np, result);
-			hexdump(result, crypto_tfm_alg_digestsize(tfm));
+			ret = crypto_hash_digest(&amp;desc, sg, hash_tv[i].psize,
+						 result);
+			if (ret) {
+				printk("digest () failed ret=%d\n", ret);
+				goto out;
+			}
 
+			hexdump(result, crypto_hash_digestsize(tfm));
 			printk("%s\n",
-			       memcmp(result, hmac_tv[i].digest,
-				      crypto_tfm_alg_digestsize(tfm)) ?
+			       memcmp(result, hash_tv[i].digest,
+				      crypto_hash_digestsize(tfm)) ?
 			       "fail" : "pass");
 		}
 	}
+
 out:
-	crypto_free_tfm(tfm);
+	crypto_free_hash(tfm);
 }
 
-#endif	/* CONFIG_CRYPTO_HMAC */
-
 static void test_cipher(char *algo, int enc,
 			struct cipher_testvec *template, unsigned int tcount)
 {
@@ -570,97 +517,202 @@ out:
 	crypto_free_blkcipher(tfm);
 }
 
-static void test_digest_jiffies(struct crypto_tfm *tfm, char *p, int blen,
-				int plen, char *out, int sec)
+static int test_hash_jiffies_digest(struct hash_desc *desc, char *p, int blen,
+				    char *out, int sec)
+{
+	struct scatterlist sg[1];
+	unsigned long start, end;
+	int bcount;
+	int ret;
+
+	for (start = jiffies, end = start + sec * HZ, bcount = 0;
+	     time_before(jiffies, end); bcount++) {
+		sg_set_buf(sg, p, blen);
+		ret = crypto_hash_digest(desc, sg, blen, out);
+		if (ret)
+			return ret;
+	}
+
+	printk("%6u opers/sec, %9lu bytes/sec\n",
+	       bcount / sec, ((long)bcount * blen) / sec);
+
+	return 0;
+}
+
+static int test_hash_jiffies(struct hash_desc *desc, char *p, int blen,
+			     int plen, char *out, int sec)
 {
 	struct scatterlist sg[1];
 	unsigned long start, end;
 	int bcount, pcount;
+	int ret;
+
+	if (plen == blen)
+		return test_hash_jiffies_digest(desc, p, blen, out, sec);
 
 	for (start = jiffies, end = start + sec * HZ, bcount = 0;
 	     time_before(jiffies, end); bcount++) {
-		crypto_digest_init(tfm);
+		ret = crypto_hash_init(desc);
+		if (ret)
+			return ret;
 		for (pcount = 0; pcount &lt; blen; pcount += plen) {
 			sg_set_buf(sg, p + pcount, plen);
-			crypto_digest_update(tfm, sg, 1);
+			ret = crypto_hash_update(desc, sg, plen);
+			if (ret)
+				return ret;
 		}
 		/* we assume there is enough space in 'out' for the result */
-		crypto_digest_final(tfm, out);
+		ret = crypto_hash_final(desc, out);
+		if (ret)
+			return ret;
 	}
 
 	printk("%6u opers/sec, %9lu bytes/sec\n",
 	       bcount / sec, ((long)bcount * blen) / sec);
 
-	return;
+	return 0;
+}
+
+static int test_hash_cycles_digest(struct hash_desc *desc, char *p, int blen,
+				   char *out)
+{
+	struct scatterlist sg[1];
+	unsigned long cycles = 0;
+	int i;
+	int ret;
+
+	local_bh_disable();
+	local_irq_disable();
+
+	/* Warm-up run. */
+	for (i = 0; i &lt; 4; i++) {
+		sg_set_buf(sg, p, blen);
+		ret = crypto_hash_digest(desc, sg, blen, out);
+		if (ret)
+			goto out;
+	}
+
+	/* The real thing. */
+	for (i = 0; i &lt; 8; i++) {
+		cycles_t start, end;
+
+		start = get_cycles();
+
+		sg_set_buf(sg, p, blen);
+		ret = crypto_hash_digest(desc, sg, blen, out);
+		if (ret)
+			goto out;
+
+		end = get_cycles();
+
+		cycles += end - start;
+	}
+
+out:
+	local_irq_enable();
+	local_bh_enable();
+
+	if (ret)
+		return ret;
+
+	printk("%6lu cycles/operation, %4lu cycles/byte\n",
+	       cycles / 8, cycles / (8 * blen));
+
+	return 0;
 }
 
-static void test_digest_cycles(struct crypto_tfm *tfm, char *p, int blen,
-			       int plen, char *out)
+static int test_hash_cycles(struct hash_desc *desc, char *p, int blen,
+			    int plen, char *out)
 {
 	struct scatterlist sg[1];
 	unsigned long cycles = 0;
 	int i, pcount;
+	int ret;
+
+	if (plen == blen)
+		return test_hash_cycles_digest(desc, p, blen, out);
 
 	local_bh_disable();
 	local_irq_disable();
 
 	/* Warm-up run. */
 	for (i = 0; i &lt; 4; i++) {
-		crypto_digest_init(tfm);
+		ret = crypto_hash_init(desc);
+		if (ret)
+			goto out;
 		for (pcount = 0; pcount &lt; blen; pcount += plen) {
 			sg_set_buf(sg, p + pcount, plen);
-			crypto_digest_update(tfm, sg, 1);
+			ret = crypto_hash_update(desc, sg, plen);
+			if (ret)
+				goto out;
 		}
-		crypto_digest_final(tfm, out);
+		crypto_hash_final(desc, out);
+		if (ret)
+			goto out;
 	}
 
 	/* The real thing. */
 	for (i = 0; i &lt; 8; i++) {
 		cycles_t start, end;
 
-		crypto_digest_init(tfm);
-
 		start = get_cycles();
 
+		ret = crypto_hash_init(desc);
+		if (ret)
+			goto out;
 		for (pcount = 0; pcount &lt; blen; pcount += plen) {
 			sg_set_buf(sg, p + pcount, plen);
-			crypto_digest_update(tfm, sg, 1);
+			ret = crypto_hash_update(desc, sg, plen);
+			if (ret)
+				goto out;
 		}
-		crypto_digest_final(tfm, out);
+		ret = crypto_hash_final(desc, out);
+		if (ret)
+			goto out;
 
 		end = get_cycles();
 
 		cycles += end - start;
 	}
 
+out:
 	local_irq_enable();
 	local_bh_enable();
 
+	if (ret)
+		return ret;
+
 	printk("%6lu cycles/operation, %4lu cycles/byte\n",
 	       cycles / 8, cycles / (8 * blen));
 
-	return;
+	return 0;
 }
 
-static void test_digest_speed(char *algo, unsigned int sec,
-			      struct digest_speed *speed)
+static void test_hash_speed(char *algo, unsigned int sec,
+			      struct hash_speed *speed)
 {
-	struct crypto_tfm *tfm;
+	struct crypto_hash *tfm;
+	struct hash_desc desc;
 	char output[1024];
 	int i;
+	int ret;
 
 	printk("\ntesting speed of %s\n", algo);
 
-	tfm = crypto_alloc_tfm(algo, 0);
+	tfm = crypto_alloc_hash(algo, 0, CRYPTO_ALG_ASYNC);
 
-	if (tfm == NULL) {
-		printk("failed to load transform for %s\n", algo);
+	if (IS_ERR(tfm)) {
+		printk("failed to load transform for %s: %ld\n", algo,
+		       PTR_ERR(tfm));
 		return;
 	}
 
-	if (crypto_tfm_alg_digestsize(tfm) &gt; sizeof(output)) {
+	desc.tfm = tfm;
+	desc.flags = 0;
+
+	if (crypto_hash_digestsize(tfm) &gt; sizeof(output)) {
 		printk("digestsize(%u) &gt; outputbuffer(%zu)\n",
-		       crypto_tfm_alg_digestsize(tfm), sizeof(output));
+		       crypto_hash_digestsize(tfm), sizeof(output));
 		goto out;
 	}
 
@@ -677,13 +729,20 @@ static void test_digest_speed(char *algo
 		memset(tvmem, 0xff, speed[i].blen);
 
 		if (sec)
-			test_digest_jiffies(tfm, tvmem, speed[i].blen, speed[i].plen, output, sec);
+			ret = test_hash_jiffies(&amp;desc, tvmem, speed[i].blen,
+						speed[i].plen, output, sec);
 		else
-			test_digest_cycles(tfm, tvmem, speed[i].blen, speed[i].plen, output);
+			ret = test_hash_cycles(&amp;desc, tvmem, speed[i].blen,
+					       speed[i].plen, output);
+
+		if (ret) {
+			printk("hashing failed ret=%d\n", ret);
+			break;
+		}
 	}
 
 out:
-	crypto_free_tfm(tfm);
+	crypto_free_hash(tfm);
 }
 
 static void test_deflate(void)
@@ -911,11 +970,12 @@ static void do_test(void)
 		test_hash("tgr128", tgr128_tv_template, TGR128_TEST_VECTORS);
 		test_deflate();
 		test_hash("crc32c", crc32c_tv_template, CRC32C_TEST_VECTORS);
-#ifdef CONFIG_CRYPTO_HMAC
-		test_hmac("md5", hmac_md5_tv_template, HMAC_MD5_TEST_VECTORS);
-		test_hmac("sha1", hmac_sha1_tv_template, HMAC_SHA1_TEST_VECTORS);
-		test_hmac("sha256", hmac_sha256_tv_template, HMAC_SHA256_TEST_VECTORS);
-#endif
+		test_hash("hmac(md5)", hmac_md5_tv_template,
+			  HMAC_MD5_TEST_VECTORS);
+		test_hash("hmac(sha1)", hmac_sha1_tv_template,
+			  HMAC_SHA1_TEST_VECTORS);
+		test_hash("hmac(sha256)", hmac_sha256_tv_template,
+			  HMAC_SHA256_TEST_VECTORS);
 
 		test_hash("michael_mic", michael_mic_tv_template, MICHAEL_MIC_TEST_VECTORS);
 		break;
@@ -1106,20 +1166,21 @@ static void do_test(void)
 			    XETA_DEC_TEST_VECTORS);
 		break;
 
-#ifdef CONFIG_CRYPTO_HMAC
 	case 100:
-		test_hmac("md5", hmac_md5_tv_template, HMAC_MD5_TEST_VECTORS);
+		test_hash("hmac(md5)", hmac_md5_tv_template,
+			  HMAC_MD5_TEST_VECTORS);
 		break;
 
 	case 101:
-		test_hmac("sha1", hmac_sha1_tv_template, HMAC_SHA1_TEST_VECTORS);
+		test_hash("hmac(sha1)", hmac_sha1_tv_template,
+			  HMAC_SHA1_TEST_VECTORS);
 		break;
 
 	case 102:
-		test_hmac("sha256", hmac_sha256_tv_template, HMAC_SHA256_TEST_VECTORS);
+		test_hash("hmac(sha256)", hmac_sha256_tv_template,
+			  HMAC_SHA256_TEST_VECTORS);
 		break;
 
-#endif
 
 	case 200:
 		test_cipher_speed("ecb(aes)", ENCRYPT, sec, NULL, 0,
@@ -1188,51 +1249,51 @@ static void do_test(void)
 		/* fall through */
 
 	case 301:
-		test_digest_speed("md4", sec, generic_digest_speed_template);
+		test_hash_speed("md4", sec, generic_hash_speed_template);
 		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
 
 	case 302:
-		test_digest_speed("md5", sec, generic_digest_speed_template);
+		test_hash_speed("md5", sec, generic_hash_speed_template);
 		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
 
 	case 303:
-		test_digest_speed("sha1", sec, generic_digest_speed_template);
+		test_hash_speed("sha1", sec, generic_hash_speed_template);
 		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
 
 	case 304:
-		test_digest_speed("sha256", sec, generic_digest_speed_template);
+		test_hash_speed("sha256", sec, generic_hash_speed_template);
 		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
 
 	case 305:
-		test_digest_speed("sha384", sec, generic_digest_speed_template);
+		test_hash_speed("sha384", sec, generic_hash_speed_template);
 		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
 
 	case 306:
-		test_digest_speed("sha512", sec, generic_digest_speed_template);
+		test_hash_speed("sha512", sec, generic_hash_speed_template);
 		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
 
 	case 307:
-		test_digest_speed("wp256", sec, generic_digest_speed_template);
+		test_hash_speed("wp256", sec, generic_hash_speed_template);
 		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
 
 	case 308:
-		test_digest_speed("wp384", sec, generic_digest_speed_template);
+		test_hash_speed("wp384", sec, generic_hash_speed_template);
 		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
 
 	case 309:
-		test_digest_speed("wp512", sec, generic_digest_speed_template);
+		test_hash_speed("wp512", sec, generic_hash_speed_template);
 		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
 
 	case 310:
-		test_digest_speed("tgr128", sec, generic_digest_speed_template);
+		test_hash_speed("tgr128", sec, generic_hash_speed_template);
 		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
 
 	case 311:
-		test_digest_speed("tgr160", sec, generic_digest_speed_template);
+		test_hash_speed("tgr160", sec, generic_hash_speed_template);
 		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
 
 	case 312:
-		test_digest_speed("tgr192", sec, generic_digest_speed_template);
+		test_hash_speed("tgr192", sec, generic_hash_speed_template);
 		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
 
 	case 399:
diff --git a/crypto/tcrypt.h b/crypto/tcrypt.h
--- a/crypto/tcrypt.h
+++ b/crypto/tcrypt.h
@@ -36,16 +36,6 @@ struct hash_testvec {
 	unsigned char ksize;
 };
 
-struct hmac_testvec {
-	char key[128];
-	char plaintext[128];
-	char digest[MAX_DIGEST_SIZE];
-	unsigned char tap[MAX_TAP];
-	unsigned char ksize;
-	unsigned char psize;
-	unsigned char np;
-};
-
 struct cipher_testvec {
 	char key[MAX_KEYLEN] __attribute__ ((__aligned__(4)));
 	char iv[MAX_IVLEN];
@@ -65,7 +55,7 @@ struct cipher_speed {
 	unsigned int blen;
 };
 
-struct digest_speed {
+struct hash_speed {
 	unsigned int blen;	/* buffer length */
 	unsigned int plen;	/* per-update length */
 };
@@ -697,14 +687,13 @@ static struct hash_testvec tgr128_tv_tem
 	},
 };
 
-#ifdef CONFIG_CRYPTO_HMAC
 /*
  * HMAC-MD5 test vectors from RFC2202
  * (These need to be fixed to not use strlen).
  */
 #define HMAC_MD5_TEST_VECTORS	7
 
-static struct hmac_testvec hmac_md5_tv_template[] =
+static struct hash_testvec hmac_md5_tv_template[] =
 {
 	{
 		.key	= { [0 ... 15] =  0x0b },
@@ -768,7 +757,7 @@ static struct hmac_testvec hmac_md5_tv_t
  */
 #define HMAC_SHA1_TEST_VECTORS	7
 
-static struct hmac_testvec hmac_sha1_tv_template[] = {
+static struct hash_testvec hmac_sha1_tv_template[] = {
 	{
 		.key	= { [0 ... 19] = 0x0b },
 		.ksize	= 20,
@@ -833,7 +822,7 @@ static struct hmac_testvec hmac_sha1_tv_
  */
 #define HMAC_SHA256_TEST_VECTORS	10
 
-static struct hmac_testvec hmac_sha256_tv_template[] = {
+static struct hash_testvec hmac_sha256_tv_template[] = {
 	{
 		.key	= { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
 			    0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
@@ -944,8 +933,6 @@ static struct hmac_testvec hmac_sha256_t
 	},
 };
 
-#endif	/* CONFIG_CRYPTO_HMAC */
-
 /*
  * DES test vectors.
  */
@@ -3160,7 +3147,7 @@ static struct cipher_speed des_speed_tem
 /*
  * Digest speed tests
  */
-static struct digest_speed generic_digest_speed_template[] = {
+static struct hash_speed generic_hash_speed_template[] = {
 	{ .blen = 16, 	.plen = 16, },
 	{ .blen = 64,	.plen = 16, },
 	{ .blen = 64,	.plen = 64, },
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060821142751</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-21 14:27:51-0400</timestampReceived><subject>[PATCH 4/7] [IPSEC]: Use HMAC template and hash interface</subject><body>

[IPSEC]: Use HMAC template and hash interface

This patch converts IPsec to use the new HMAC template.  The names of
existing simple digest algorithms may still be used to refer to their
HMAC composites.

The same structure can be used by other MACs such as AES-XCBC-MAC.

This patch also switches from the digest interface to hash.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;
---

 include/net/ah.h     |   29 ++++++++++++++++++-----------
 include/net/esp.h    |   26 +++++++++++++++-----------
 include/net/xfrm.h   |    9 +++++----
 net/ipv4/ah4.c       |   36 ++++++++++++++++++++++++------------
 net/ipv4/esp4.c      |   36 +++++++++++++++++++++---------------
 net/ipv6/ah6.c       |   35 +++++++++++++++++++++++------------
 net/ipv6/esp6.c      |   42 ++++++++++++++++++++++++------------------
 net/xfrm/xfrm_algo.c |   40 +++++++++++++++++++++++++++-------------
 8 files changed, 157 insertions(+), 96 deletions(-)

diff --git a/include/net/ah.h b/include/net/ah.h
--- a/include/net/ah.h
+++ b/include/net/ah.h
@@ -15,22 +15,29 @@ struct ah_data
 	int			icv_full_len;
 	int			icv_trunc_len;
 
-	void			(*icv)(struct ah_data*,
-	                               struct sk_buff *skb, u8 *icv);
-
-	struct crypto_tfm	*tfm;
+	struct crypto_hash	*tfm;
 };
 
-static inline void
-ah_hmac_digest(struct ah_data *ahp, struct sk_buff *skb, u8 *auth_data)
+static inline int ah_mac_digest(struct ah_data *ahp, struct sk_buff *skb,
+				u8 *auth_data)
 {
-	struct crypto_tfm *tfm = ahp-&gt;tfm;
+	struct hash_desc desc;
+	int err;
+
+	desc.tfm = ahp-&gt;tfm;
+	desc.flags = 0;
 
 	memset(auth_data, 0, ahp-&gt;icv_trunc_len);
-	crypto_hmac_init(tfm, ahp-&gt;key, &amp;ahp-&gt;key_len);
-	skb_icv_walk(skb, tfm, 0, skb-&gt;len, crypto_hmac_update);
-	crypto_hmac_final(tfm, ahp-&gt;key, &amp;ahp-&gt;key_len, ahp-&gt;work_icv);
-	memcpy(auth_data, ahp-&gt;work_icv, ahp-&gt;icv_trunc_len);
+	err = crypto_hash_init(&amp;desc);
+	if (unlikely(err))
+		goto out;
+	err = skb_icv_walk(skb, &amp;desc, 0, skb-&gt;len, crypto_hash_update);
+	if (unlikely(err))
+		goto out;
+	err = crypto_hash_final(&amp;desc, ahp-&gt;work_icv);
+
+out:
+	return err;
 }
 
 #endif
diff --git a/include/net/esp.h b/include/net/esp.h
--- a/include/net/esp.h
+++ b/include/net/esp.h
@@ -35,7 +35,7 @@ struct esp_data
 		void			(*icv)(struct esp_data*,
 		                               struct sk_buff *skb,
 		                               int offset, int len, u8 *icv);
-		struct crypto_tfm	*tfm;
+		struct crypto_hash	*tfm;
 	} auth;
 };
 
@@ -43,18 +43,22 @@ extern int skb_to_sgvec(struct sk_buff *
 extern int skb_cow_data(struct sk_buff *skb, int tailbits, struct sk_buff **trailer);
 extern void *pskb_put(struct sk_buff *skb, struct sk_buff *tail, int len);
 
-static inline void
-esp_hmac_digest(struct esp_data *esp, struct sk_buff *skb, int offset,
-                int len, u8 *auth_data)
+static inline int esp_mac_digest(struct esp_data *esp, struct sk_buff *skb,
+				 int offset, int len)
 {
-	struct crypto_tfm *tfm = esp-&gt;auth.tfm;
-	char *icv = esp-&gt;auth.work_icv;
+	struct hash_desc desc;
+	int err;
 
-	memset(auth_data, 0, esp-&gt;auth.icv_trunc_len);
-	crypto_hmac_init(tfm, esp-&gt;auth.key, &amp;esp-&gt;auth.key_len);
-	skb_icv_walk(skb, tfm, offset, len, crypto_hmac_update);
-	crypto_hmac_final(tfm, esp-&gt;auth.key, &amp;esp-&gt;auth.key_len, icv);
-	memcpy(auth_data, icv, esp-&gt;auth.icv_trunc_len);
+	desc.tfm = esp-&gt;auth.tfm;
+	desc.flags = 0;
+
+	err = crypto_hash_init(&amp;desc);
+	if (unlikely(err))
+		return err;
+	err = skb_icv_walk(skb, &amp;desc, offset, len, crypto_hash_update);
+	if (unlikely(err))
+		return err;
+	return crypto_hash_final(&amp;desc, esp-&gt;auth.work_icv);
 }
 
 #endif
diff --git a/include/net/xfrm.h b/include/net/xfrm.h
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@ -984,12 +984,13 @@ extern struct xfrm_algo_desc *xfrm_aalg_
 extern struct xfrm_algo_desc *xfrm_ealg_get_byname(char *name, int probe);
 extern struct xfrm_algo_desc *xfrm_calg_get_byname(char *name, int probe);
 
-struct crypto_tfm;
+struct hash_desc;
 struct scatterlist;
-typedef void (icv_update_fn_t)(struct crypto_tfm *, struct scatterlist *, unsigned int);
+typedef int (icv_update_fn_t)(struct hash_desc *, struct scatterlist *,
+			      unsigned int);
 
-extern void skb_icv_walk(const struct sk_buff *skb, struct crypto_tfm *tfm,
-			 int offset, int len, icv_update_fn_t icv_update);
+extern int skb_icv_walk(const struct sk_buff *skb, struct hash_desc *tfm,
+			int offset, int len, icv_update_fn_t icv_update);
 
 static inline int xfrm_addr_cmp(xfrm_address_t *a, xfrm_address_t *b,
 				int family)
diff --git a/net/ipv4/ah4.c b/net/ipv4/ah4.c
--- a/net/ipv4/ah4.c
+++ b/net/ipv4/ah4.c
@@ -1,3 +1,4 @@
+#include &lt;linux/err.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;net/ip.h&gt;
 #include &lt;net/xfrm.h&gt;
@@ -97,7 +98,10 @@ static int ah_output(struct xfrm_state *
 	ah-&gt;spi = x-&gt;id.spi;
 	ah-&gt;seq_no = htonl(++x-&gt;replay.oseq);
 	xfrm_aevent_doreplay(x);
-	ahp-&gt;icv(ahp, skb, ah-&gt;auth_data);
+	err = ah_mac_digest(ahp, skb, ah-&gt;auth_data);
+	if (err)
+		goto error;
+	memcpy(ah-&gt;auth_data, ahp-&gt;work_icv, ahp-&gt;icv_trunc_len);
 
 	top_iph-&gt;tos = iph-&gt;tos;
 	top_iph-&gt;ttl = iph-&gt;ttl;
@@ -119,6 +123,7 @@ static int ah_input(struct xfrm_state *x
 {
 	int ah_hlen;
 	int ihl;
+	int err = -EINVAL;
 	struct iphdr *iph;
 	struct ip_auth_hdr *ah;
 	struct ah_data *ahp;
@@ -166,8 +171,11 @@ static int ah_input(struct xfrm_state *x
 		
 		memcpy(auth_data, ah-&gt;auth_data, ahp-&gt;icv_trunc_len);
 		skb_push(skb, ihl);
-		ahp-&gt;icv(ahp, skb, ah-&gt;auth_data);
-		if (memcmp(ah-&gt;auth_data, auth_data, ahp-&gt;icv_trunc_len)) {
+		err = ah_mac_digest(ahp, skb, ah-&gt;auth_data);
+		if (err)
+			goto out;
+		err = -EINVAL;
+		if (memcmp(ahp-&gt;work_icv, auth_data, ahp-&gt;icv_trunc_len)) {
 			x-&gt;stats.integrity_failed++;
 			goto out;
 		}
@@ -179,7 +187,7 @@ static int ah_input(struct xfrm_state *x
 	return 0;
 
 out:
-	return -EINVAL;
+	return err;
 }
 
 static void ah4_err(struct sk_buff *skb, u32 info)
@@ -204,6 +212,7 @@ static int ah_init_state(struct xfrm_sta
 {
 	struct ah_data *ahp = NULL;
 	struct xfrm_algo_desc *aalg_desc;
+	struct crypto_hash *tfm;
 
 	if (!x-&gt;aalg)
 		goto error;
@@ -223,24 +232,27 @@ static int ah_init_state(struct xfrm_sta
 
 	ahp-&gt;key = x-&gt;aalg-&gt;alg_key;
 	ahp-&gt;key_len = (x-&gt;aalg-&gt;alg_key_len+7)/8;
-	ahp-&gt;tfm = crypto_alloc_tfm(x-&gt;aalg-&gt;alg_name, 0);
-	if (!ahp-&gt;tfm)
+	tfm = crypto_alloc_hash(x-&gt;aalg-&gt;alg_name, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(tfm))
+		goto error;
+
+	ahp-&gt;tfm = tfm;
+	if (crypto_hash_setkey(tfm, ahp-&gt;key, ahp-&gt;key_len))
 		goto error;
-	ahp-&gt;icv = ah_hmac_digest;
 	
 	/*
 	 * Lookup the algorithm description maintained by xfrm_algo,
 	 * verify crypto transform properties, and store information
 	 * we need for AH processing.  This lookup cannot fail here
-	 * after a successful crypto_alloc_tfm().
+	 * after a successful crypto_alloc_hash().
 	 */
 	aalg_desc = xfrm_aalg_get_byname(x-&gt;aalg-&gt;alg_name, 0);
 	BUG_ON(!aalg_desc);
 
 	if (aalg_desc-&gt;uinfo.auth.icv_fullbits/8 !=
-	    crypto_tfm_alg_digestsize(ahp-&gt;tfm)) {
+	    crypto_hash_digestsize(tfm)) {
 		printk(KERN_INFO "AH: %s digestsize %u != %hu\n",
-		       x-&gt;aalg-&gt;alg_name, crypto_tfm_alg_digestsize(ahp-&gt;tfm),
+		       x-&gt;aalg-&gt;alg_name, crypto_hash_digestsize(tfm),
 		       aalg_desc-&gt;uinfo.auth.icv_fullbits/8);
 		goto error;
 	}
@@ -264,7 +276,7 @@ static int ah_init_state(struct xfrm_sta
 error:
 	if (ahp) {
 		kfree(ahp-&gt;work_icv);
-		crypto_free_tfm(ahp-&gt;tfm);
+		crypto_free_hash(ahp-&gt;tfm);
 		kfree(ahp);
 	}
 	return -EINVAL;
@@ -279,7 +291,7 @@ static void ah_destroy(struct xfrm_state
 
 	kfree(ahp-&gt;work_icv);
 	ahp-&gt;work_icv = NULL;
-	crypto_free_tfm(ahp-&gt;tfm);
+	crypto_free_hash(ahp-&gt;tfm);
 	ahp-&gt;tfm = NULL;
 	kfree(ahp);
 }
diff --git a/net/ipv4/esp4.c b/net/ipv4/esp4.c
--- a/net/ipv4/esp4.c
+++ b/net/ipv4/esp4.c
@@ -121,9 +121,9 @@ static int esp_output(struct xfrm_state 
 	}
 
 	if (esp-&gt;auth.icv_full_len) {
-		esp-&gt;auth.icv(esp, skb, (u8*)esph-skb-&gt;data,
-		              sizeof(struct ip_esp_hdr) + esp-&gt;conf.ivlen+clen, trailer-&gt;tail);
-		pskb_put(skb, trailer, alen);
+		err = esp_mac_digest(esp, skb, (u8 *)esph - skb-&gt;data,
+				     sizeof(*esph) + esp-&gt;conf.ivlen + clen);
+		memcpy(pskb_put(skb, trailer, alen), esp-&gt;auth.work_icv, alen);
 	}
 
 	ip_send_check(top_iph);
@@ -163,15 +163,16 @@ static int esp_input(struct xfrm_state *
 
 	/* If integrity check is required, do this. */
 	if (esp-&gt;auth.icv_full_len) {
-		u8 sum[esp-&gt;auth.icv_full_len];
-		u8 sum1[alen];
-		
-		esp-&gt;auth.icv(esp, skb, 0, skb-&gt;len-alen, sum);
+		u8 sum[alen];
 
-		if (skb_copy_bits(skb, skb-&gt;len-alen, sum1, alen))
+		err = esp_mac_digest(esp, skb, 0, skb-&gt;len - alen);
+		if (err)
+			goto out;
+
+		if (skb_copy_bits(skb, skb-&gt;len - alen, sum, alen))
 			BUG();
 
-		if (unlikely(memcmp(sum, sum1, alen))) {
+		if (unlikely(memcmp(esp-&gt;auth.work_icv, sum, alen))) {
 			x-&gt;stats.integrity_failed++;
 			goto out;
 		}
@@ -307,7 +308,7 @@ static void esp_destroy(struct xfrm_stat
 	esp-&gt;conf.tfm = NULL;
 	kfree(esp-&gt;conf.ivec);
 	esp-&gt;conf.ivec = NULL;
-	crypto_free_tfm(esp-&gt;auth.tfm);
+	crypto_free_hash(esp-&gt;auth.tfm);
 	esp-&gt;auth.tfm = NULL;
 	kfree(esp-&gt;auth.work_icv);
 	esp-&gt;auth.work_icv = NULL;
@@ -335,22 +336,27 @@ static int esp_init_state(struct xfrm_st
 
 	if (x-&gt;aalg) {
 		struct xfrm_algo_desc *aalg_desc;
+		struct crypto_hash *hash;
 
 		esp-&gt;auth.key = x-&gt;aalg-&gt;alg_key;
 		esp-&gt;auth.key_len = (x-&gt;aalg-&gt;alg_key_len+7)/8;
-		esp-&gt;auth.tfm = crypto_alloc_tfm(x-&gt;aalg-&gt;alg_name, 0);
-		if (esp-&gt;auth.tfm == NULL)
+		hash = crypto_alloc_hash(x-&gt;aalg-&gt;alg_name, 0,
+					 CRYPTO_ALG_ASYNC);
+		if (IS_ERR(hash))
+			goto error;
+
+		esp-&gt;auth.tfm = hash;
+		if (crypto_hash_setkey(hash, esp-&gt;auth.key, esp-&gt;auth.key_len))
 			goto error;
-		esp-&gt;auth.icv = esp_hmac_digest;
 
 		aalg_desc = xfrm_aalg_get_byname(x-&gt;aalg-&gt;alg_name, 0);
 		BUG_ON(!aalg_desc);
 
 		if (aalg_desc-&gt;uinfo.auth.icv_fullbits/8 !=
-		    crypto_tfm_alg_digestsize(esp-&gt;auth.tfm)) {
+		    crypto_hash_digestsize(hash)) {
 			NETDEBUG(KERN_INFO "ESP: %s digestsize %u != %hu\n",
 				 x-&gt;aalg-&gt;alg_name,
-				 crypto_tfm_alg_digestsize(esp-&gt;auth.tfm),
+				 crypto_hash_digestsize(hash),
 				 aalg_desc-&gt;uinfo.auth.icv_fullbits/8);
 			goto error;
 		}
diff --git a/net/ipv6/ah6.c b/net/ipv6/ah6.c
--- a/net/ipv6/ah6.c
+++ b/net/ipv6/ah6.c
@@ -213,7 +213,10 @@ static int ah6_output(struct xfrm_state 
 	ah-&gt;spi = x-&gt;id.spi;
 	ah-&gt;seq_no = htonl(++x-&gt;replay.oseq);
 	xfrm_aevent_doreplay(x);
-	ahp-&gt;icv(ahp, skb, ah-&gt;auth_data);
+	err = ah_mac_digest(ahp, skb, ah-&gt;auth_data);
+	if (err)
+		goto error_free_iph;
+	memcpy(ah-&gt;auth_data, ahp-&gt;work_icv, ahp-&gt;icv_trunc_len);
 
 	err = 0;
 
@@ -251,6 +254,7 @@ static int ah6_input(struct xfrm_state *
 	u16 hdr_len;
 	u16 ah_hlen;
 	int nexthdr;
+	int err = -EINVAL;
 
 	if (!pskb_may_pull(skb, sizeof(struct ip_auth_hdr)))
 		goto out;
@@ -292,8 +296,11 @@ static int ah6_input(struct xfrm_state *
 		memcpy(auth_data, ah-&gt;auth_data, ahp-&gt;icv_trunc_len);
 		memset(ah-&gt;auth_data, 0, ahp-&gt;icv_trunc_len);
 		skb_push(skb, hdr_len);
-		ahp-&gt;icv(ahp, skb, ah-&gt;auth_data);
-		if (memcmp(ah-&gt;auth_data, auth_data, ahp-&gt;icv_trunc_len)) {
+		err = ah_mac_digest(ahp, skb, ah-&gt;auth_data);
+		if (err)
+			goto free_out;
+		err = -EINVAL;
+		if (memcmp(ahp-&gt;work_icv, auth_data, ahp-&gt;icv_trunc_len)) {
 			LIMIT_NETDEBUG(KERN_WARNING "ipsec ah authentication error\n");
 			x-&gt;stats.integrity_failed++;
 			goto free_out;
@@ -310,7 +317,7 @@ static int ah6_input(struct xfrm_state *
 free_out:
 	kfree(tmp_hdr);
 out:
-	return -EINVAL;
+	return err;
 }
 
 static void ah6_err(struct sk_buff *skb, struct inet6_skb_parm *opt, 
@@ -338,6 +345,7 @@ static int ah6_init_state(struct xfrm_st
 {
 	struct ah_data *ahp = NULL;
 	struct xfrm_algo_desc *aalg_desc;
+	struct crypto_hash *tfm;
 
 	if (!x-&gt;aalg)
 		goto error;
@@ -355,24 +363,27 @@ static int ah6_init_state(struct xfrm_st
 
 	ahp-&gt;key = x-&gt;aalg-&gt;alg_key;
 	ahp-&gt;key_len = (x-&gt;aalg-&gt;alg_key_len+7)/8;
-	ahp-&gt;tfm = crypto_alloc_tfm(x-&gt;aalg-&gt;alg_name, 0);
-	if (!ahp-&gt;tfm)
+	tfm = crypto_alloc_hash(x-&gt;aalg-&gt;alg_name, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(tfm))
+		goto error;
+
+	ahp-&gt;tfm = tfm;
+	if (crypto_hash_setkey(tfm, ahp-&gt;key, ahp-&gt;key_len))
 		goto error;
-	ahp-&gt;icv = ah_hmac_digest;
 	
 	/*
 	 * Lookup the algorithm description maintained by xfrm_algo,
 	 * verify crypto transform properties, and store information
 	 * we need for AH processing.  This lookup cannot fail here
-	 * after a successful crypto_alloc_tfm().
+	 * after a successful crypto_alloc_hash().
 	 */
 	aalg_desc = xfrm_aalg_get_byname(x-&gt;aalg-&gt;alg_name, 0);
 	BUG_ON(!aalg_desc);
 
 	if (aalg_desc-&gt;uinfo.auth.icv_fullbits/8 !=
-	    crypto_tfm_alg_digestsize(ahp-&gt;tfm)) {
+	    crypto_hash_digestsize(tfm)) {
 		printk(KERN_INFO "AH: %s digestsize %u != %hu\n",
-		       x-&gt;aalg-&gt;alg_name, crypto_tfm_alg_digestsize(ahp-&gt;tfm),
+		       x-&gt;aalg-&gt;alg_name, crypto_hash_digestsize(tfm),
 		       aalg_desc-&gt;uinfo.auth.icv_fullbits/8);
 		goto error;
 	}
@@ -396,7 +407,7 @@ static int ah6_init_state(struct xfrm_st
 error:
 	if (ahp) {
 		kfree(ahp-&gt;work_icv);
-		crypto_free_tfm(ahp-&gt;tfm);
+		crypto_free_hash(ahp-&gt;tfm);
 		kfree(ahp);
 	}
 	return -EINVAL;
@@ -411,7 +422,7 @@ static void ah6_destroy(struct xfrm_stat
 
 	kfree(ahp-&gt;work_icv);
 	ahp-&gt;work_icv = NULL;
-	crypto_free_tfm(ahp-&gt;tfm);
+	crypto_free_hash(ahp-&gt;tfm);
 	ahp-&gt;tfm = NULL;
 	kfree(ahp);
 }
diff --git a/net/ipv6/esp6.c b/net/ipv6/esp6.c
--- a/net/ipv6/esp6.c
+++ b/net/ipv6/esp6.c
@@ -125,9 +125,9 @@ static int esp6_output(struct xfrm_state
 	}
 
 	if (esp-&gt;auth.icv_full_len) {
-		esp-&gt;auth.icv(esp, skb, (u8*)esph-skb-&gt;data,
-			sizeof(struct ipv6_esp_hdr) + esp-&gt;conf.ivlen+clen, trailer-&gt;tail);
-		pskb_put(skb, trailer, alen);
+		err = esp_mac_digest(esp, skb, (u8 *)esph - skb-&gt;data,
+				     sizeof(*esph) + esp-&gt;conf.ivlen + clen);
+		memcpy(pskb_put(skb, trailer, alen), esp-&gt;auth.work_icv, alen);
 	}
 
 error:
@@ -162,15 +162,16 @@ static int esp6_input(struct xfrm_state 
 
 	/* If integrity check is required, do this. */
         if (esp-&gt;auth.icv_full_len) {
-		u8 sum[esp-&gt;auth.icv_full_len];
-		u8 sum1[alen];
+		u8 sum[alen];
 
-		esp-&gt;auth.icv(esp, skb, 0, skb-&gt;len-alen, sum);
+		ret = esp_mac_digest(esp, skb, 0, skb-&gt;len - alen);
+		if (ret)
+			goto out;
 
-		if (skb_copy_bits(skb, skb-&gt;len-alen, sum1, alen))
+		if (skb_copy_bits(skb, skb-&gt;len - alen, sum, alen))
 			BUG();
 
-		if (unlikely(memcmp(sum, sum1, alen))) {
+		if (unlikely(memcmp(esp-&gt;auth.work_icv, sum, alen))) {
 			x-&gt;stats.integrity_failed++;
 			ret = -EINVAL;
 			goto out;
@@ -279,7 +280,7 @@ static void esp6_destroy(struct xfrm_sta
 	esp-&gt;conf.tfm = NULL;
 	kfree(esp-&gt;conf.ivec);
 	esp-&gt;conf.ivec = NULL;
-	crypto_free_tfm(esp-&gt;auth.tfm);
+	crypto_free_hash(esp-&gt;auth.tfm);
 	esp-&gt;auth.tfm = NULL;
 	kfree(esp-&gt;auth.work_icv);
 	esp-&gt;auth.work_icv = NULL;
@@ -308,24 +309,29 @@ static int esp6_init_state(struct xfrm_s
 
 	if (x-&gt;aalg) {
 		struct xfrm_algo_desc *aalg_desc;
+		struct crypto_hash *hash;
 
 		esp-&gt;auth.key = x-&gt;aalg-&gt;alg_key;
 		esp-&gt;auth.key_len = (x-&gt;aalg-&gt;alg_key_len+7)/8;
-		esp-&gt;auth.tfm = crypto_alloc_tfm(x-&gt;aalg-&gt;alg_name, 0);
-		if (esp-&gt;auth.tfm == NULL)
+		hash = crypto_alloc_hash(x-&gt;aalg-&gt;alg_name, 0,
+					 CRYPTO_ALG_ASYNC);
+		if (IS_ERR(hash))
+			goto error;
+
+		esp-&gt;auth.tfm = hash;
+		if (crypto_hash_setkey(hash, esp-&gt;auth.key, esp-&gt;auth.key_len))
 			goto error;
-		esp-&gt;auth.icv = esp_hmac_digest;
  
 		aalg_desc = xfrm_aalg_get_byname(x-&gt;aalg-&gt;alg_name, 0);
 		BUG_ON(!aalg_desc);
  
 		if (aalg_desc-&gt;uinfo.auth.icv_fullbits/8 !=
-			crypto_tfm_alg_digestsize(esp-&gt;auth.tfm)) {
-				printk(KERN_INFO "ESP: %s digestsize %u != %hu\n",
-					x-&gt;aalg-&gt;alg_name,
-					crypto_tfm_alg_digestsize(esp-&gt;auth.tfm),
-					aalg_desc-&gt;uinfo.auth.icv_fullbits/8);
-				goto error;
+		    crypto_hash_digestsize(hash)) {
+			NETDEBUG(KERN_INFO "ESP: %s digestsize %u != %hu\n",
+				 x-&gt;aalg-&gt;alg_name,
+				 crypto_hash_digestsize(hash),
+				 aalg_desc-&gt;uinfo.auth.icv_fullbits/8);
+			goto error;
 		}
  
 		esp-&gt;auth.icv_full_len = aalg_desc-&gt;uinfo.auth.icv_fullbits/8;
diff --git a/net/xfrm/xfrm_algo.c b/net/xfrm/xfrm_algo.c
--- a/net/xfrm/xfrm_algo.c
+++ b/net/xfrm/xfrm_algo.c
@@ -30,7 +30,8 @@
  */
 static struct xfrm_algo_desc aalg_list[] = {
 {
-	.name = "digest_null",
+	.name = "hmac(digest_null)",
+	.compat = "digest_null",
 	
 	.uinfo = {
 		.auth = {
@@ -47,7 +48,8 @@ static struct xfrm_algo_desc aalg_list[]
 	}
 },
 {
-	.name = "md5",
+	.name = "hmac(md5)",
+	.compat = "md5",
 
 	.uinfo = {
 		.auth = {
@@ -64,7 +66,8 @@ static struct xfrm_algo_desc aalg_list[]
 	}
 },
 {
-	.name = "sha1",
+	.name = "hmac(sha1)",
+	.compat = "sha1",
 
 	.uinfo = {
 		.auth = {
@@ -81,7 +84,8 @@ static struct xfrm_algo_desc aalg_list[]
 	}
 },
 {
-	.name = "sha256",
+	.name = "hmac(sha256)",
+	.compat = "sha256",
 
 	.uinfo = {
 		.auth = {
@@ -98,7 +102,8 @@ static struct xfrm_algo_desc aalg_list[]
 	}
 },
 {
-	.name = "ripemd160",
+	.name = "hmac(ripemd160)",
+	.compat = "ripemd160",
 
 	.uinfo = {
 		.auth = {
@@ -480,11 +485,12 @@ EXPORT_SYMBOL_GPL(xfrm_count_enc_support
 
 /* Move to common area: it is shared with AH. */
 
-void skb_icv_walk(const struct sk_buff *skb, struct crypto_tfm *tfm,
-		  int offset, int len, icv_update_fn_t icv_update)
+int skb_icv_walk(const struct sk_buff *skb, struct hash_desc *desc,
+		 int offset, int len, icv_update_fn_t icv_update)
 {
 	int start = skb_headlen(skb);
 	int i, copy = start - offset;
+	int err;
 	struct scatterlist sg;
 
 	/* Checksum header. */
@@ -496,10 +502,12 @@ void skb_icv_walk(const struct sk_buff *
 		sg.offset = (unsigned long)(skb-&gt;data + offset) % PAGE_SIZE;
 		sg.length = copy;
 		
-		icv_update(tfm, &amp;sg, 1);
+		err = icv_update(desc, &amp;sg, copy);
+		if (unlikely(err))
+			return err;
 		
 		if ((len -= copy) == 0)
-			return;
+			return 0;
 		offset += copy;
 	}
 
@@ -519,10 +527,12 @@ void skb_icv_walk(const struct sk_buff *
 			sg.offset = frag-&gt;page_offset + offset-start;
 			sg.length = copy;
 			
-			icv_update(tfm, &amp;sg, 1);
+			err = icv_update(desc, &amp;sg, copy);
+			if (unlikely(err))
+				return err;
 
 			if (!(len -= copy))
-				return;
+				return 0;
 			offset += copy;
 		}
 		start = end;
@@ -540,15 +550,19 @@ void skb_icv_walk(const struct sk_buff *
 			if ((copy = end - offset) &gt; 0) {
 				if (copy &gt; len)
 					copy = len;
-				skb_icv_walk(list, tfm, offset-start, copy, icv_update);
+				err = skb_icv_walk(list, desc, offset-start,
+						   copy, icv_update);
+				if (unlikely(err))
+					return err;
 				if ((len -= copy) == 0)
-					return;
+					return 0;
 				offset += copy;
 			}
 			start = end;
 		}
 	}
 	BUG_ON(len);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(skb_icv_walk);
 
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060821142753</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-21 14:27:53-0400</timestampReceived><subject>[PATCH 5/7] [SCTP]: Use HMAC template and hash interface</subject><body>

[SCTP]: Use HMAC template and hash interface

This patch converts SCTP to use the new HMAC template and hash interface.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;
---

 include/net/sctp/constants.h |    4 ++--
 include/net/sctp/sctp.h      |   11 -----------
 include/net/sctp/structs.h   |    3 ++-
 net/sctp/endpointola.c       |    2 +-
 net/sctp/sm_make_chunk.c     |   37 +++++++++++++++++++++++++++----------
 net/sctp/socket.c            |    6 +++---
 6 files changed, 35 insertions(+), 28 deletions(-)

diff --git a/include/net/sctp/constants.h b/include/net/sctp/constants.h
--- a/include/net/sctp/constants.h
+++ b/include/net/sctp/constants.h
@@ -312,9 +312,9 @@ enum { SCTP_MAX_GABS = 16 };
 				 */
 
 #if defined (CONFIG_SCTP_HMAC_MD5)
-#define SCTP_COOKIE_HMAC_ALG "md5"
+#define SCTP_COOKIE_HMAC_ALG "hmac(md5)"
 #elif defined (CONFIG_SCTP_HMAC_SHA1)
-#define SCTP_COOKIE_HMAC_ALG "sha1"
+#define SCTP_COOKIE_HMAC_ALG "hmac(sha1)"
 #else
 #define SCTP_COOKIE_HMAC_ALG NULL
 #endif
diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.h
--- a/include/net/sctp/sctp.h
+++ b/include/net/sctp/sctp.h
@@ -330,17 +330,6 @@ static inline void sctp_v6_exit(void) { 
 
 #endif /* #if defined(CONFIG_IPV6) */
 
-/* Some wrappers, in case crypto not available. */
-#if defined (CONFIG_CRYPTO_HMAC)
-#define sctp_crypto_alloc_tfm crypto_alloc_tfm
-#define sctp_crypto_free_tfm crypto_free_tfm
-#define sctp_crypto_hmac crypto_hmac
-#else
-#define sctp_crypto_alloc_tfm(x...) NULL
-#define sctp_crypto_free_tfm(x...)
-#define sctp_crypto_hmac(x...)
-#endif
-
 
 /* Map an association to an assoc_id. */
 static inline sctp_assoc_t sctp_assoc2id(const struct sctp_association *asoc)
diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -87,6 +87,7 @@ struct sctp_bind_addr;
 struct sctp_ulpq;
 struct sctp_ep_common;
 struct sctp_ssnmap;
+struct crypto_hash;
 
 
 #include &lt;net/sctp/tsnmap.h&gt;
@@ -264,7 +265,7 @@ struct sctp_sock {
 	struct sctp_pf *pf;
 
 	/* Access to HMAC transform. */
-	struct crypto_tfm *hmac;
+	struct crypto_hash *hmac;
 
 	/* What is our base endpointer? */
 	struct sctp_endpoint *ep;
diff --git a/net/sctp/endpointola.c b/net/sctp/endpointola.c
--- a/net/sctp/endpointola.c
+++ b/net/sctp/endpointola.c
@@ -172,7 +172,7 @@ static void sctp_endpoint_destroy(struct
 	sctp_unhash_endpoint(ep);
 
 	/* Free up the HMAC transform. */
-	sctp_crypto_free_tfm(sctp_sk(ep-&gt;base.sk)-&gt;hmac);
+	crypto_free_hash(sctp_sk(ep-&gt;base.sk)-&gt;hmac);
 
 	/* Cleanup. */
 	sctp_inq_free(&amp;ep-&gt;base.inqueue);
diff --git a/net/sctp/sm_make_chunk.c b/net/sctp/sm_make_chunk.c
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@ -1294,10 +1294,8 @@ static sctp_cookie_param_t *sctp_pack_co
 
 	retval = kmalloc(*cookie_len, GFP_ATOMIC);
 
-	if (!retval) {
-		*cookie_len = 0;
+	if (!retval)
 		goto nodata;
-	}
 
 	/* Clear this memory since we are sending this data structure
 	 * out on the network.
@@ -1333,19 +1331,29 @@ static sctp_cookie_param_t *sctp_pack_co
 	       ntohs(init_chunk-&gt;chunk_hdr-&gt;length), raw_addrs, addrs_len);
 
   	if (sctp_sk(ep-&gt;base.sk)-&gt;hmac) {
+		struct hash_desc desc;
+
 		/* Sign the message.  */
 		sg.page = virt_to_page(&amp;cookie-&gt;c);
 		sg.offset = (unsigned long)(&amp;cookie-&gt;c) % PAGE_SIZE;
 		sg.length = bodysize;
 		keylen = SCTP_SECRET_SIZE;
 		key = (char *)ep-&gt;secret_key[ep-&gt;current_key];
+  		desc.tfm = sctp_sk(ep-&gt;base.sk)-&gt;hmac;
+  		desc.flags = 0;
 
-		sctp_crypto_hmac(sctp_sk(ep-&gt;base.sk)-&gt;hmac, key, &amp;keylen,
-				 &amp;sg, 1, cookie-&gt;signature);
+		if (crypto_hash_setkey(desc.tfm, key, keylen) ||
+		    crypto_hash_digest(&amp;desc, &amp;sg, bodysize, cookie-&gt;signature))
+			goto free_cookie;
 	}
 
-nodata:
 	return retval;
+
+free_cookie:
+	kfree(retval);
+nodata:
+	*cookie_len = 0;
+	return NULL;
 }
 
 /* Unpack the cookie from COOKIE ECHO chunk, recreating the association.  */
@@ -1366,6 +1374,7 @@ struct sctp_association *sctp_unpack_coo
 	sctp_scope_t scope;
 	struct sk_buff *skb = chunk-&gt;skb;
 	struct timeval tv;
+	struct hash_desc desc;
 
 	/* Header size is static data prior to the actual cookie, including
 	 * any padding.
@@ -1401,17 +1410,25 @@ struct sctp_association *sctp_unpack_coo
 	sg.offset = (unsigned long)(bear_cookie) % PAGE_SIZE;
 	sg.length = bodysize;
 	key = (char *)ep-&gt;secret_key[ep-&gt;current_key];
+	desc.tfm = sctp_sk(ep-&gt;base.sk)-&gt;hmac;
+	desc.flags = 0;
 
 	memset(digest, 0x00, SCTP_SIGNATURE_SIZE);
-	sctp_crypto_hmac(sctp_sk(ep-&gt;base.sk)-&gt;hmac, key, &amp;keylen, &amp;sg,
-			 1, digest);
+	if (crypto_hash_setkey(desc.tfm, key, keylen) ||
+	    crypto_hash_digest(&amp;desc, &amp;sg, bodysize, digest)) {
+		*error = -SCTP_IERROR_NOMEM;
+		goto fail;
+	}
 
 	if (memcmp(digest, cookie-&gt;signature, SCTP_SIGNATURE_SIZE)) {
 		/* Try the previous key. */
 		key = (char *)ep-&gt;secret_key[ep-&gt;last_key];
 		memset(digest, 0x00, SCTP_SIGNATURE_SIZE);
-		sctp_crypto_hmac(sctp_sk(ep-&gt;base.sk)-&gt;hmac, key, &amp;keylen,
-				 &amp;sg, 1, digest);
+		if (crypto_hash_setkey(desc.tfm, key, keylen) ||
+		    crypto_hash_digest(&amp;desc, &amp;sg, bodysize, digest)) {
+			*error = -SCTP_IERROR_NOMEM;
+			goto fail;
+		}
 
 		if (memcmp(digest, cookie-&gt;signature, SCTP_SIGNATURE_SIZE)) {
 			/* Yikes!  Still bad signature! */
diff --git a/net/sctp/socket.c b/net/sctp/socket.c
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@ -4842,7 +4842,7 @@ SCTP_STATIC int sctp_stream_listen(struc
 int sctp_inet_listen(struct socket *sock, int backlog)
 {
 	struct sock *sk = sock-&gt;sk;
-	struct crypto_tfm *tfm=NULL;
+	struct crypto_hash *tfm = NULL;
 	int err = -EINVAL;
 
 	if (unlikely(backlog &lt; 0))
@@ -4855,7 +4855,7 @@ int sctp_inet_listen(struct socket *sock
 
 	/* Allocate HMAC for generating cookie. */
 	if (sctp_hmac_alg) {
-		tfm = sctp_crypto_alloc_tfm(sctp_hmac_alg, 0);
+		tfm = crypto_alloc_hash(sctp_hmac_alg, 0, CRYPTO_ALG_ASYNC);
 		if (!tfm) {
 			err = -ENOSYS;
 			goto out;
@@ -4881,7 +4881,7 @@ out:
 	sctp_release_sock(sk);
 	return err;
 cleanup:
-	sctp_crypto_free_tfm(tfm);
+	crypto_free_hash(tfm);
 	goto out;
 }
 
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060821142756</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-21 14:27:56-0400</timestampReceived><subject>[PATCH 6/7] [CRYPTO] doc: Update documentation for hash and me</subject><body>

[CRYPTO] doc: Update documentation for hash and me

This patch updates the documentation to reflect the switch from digest
to hash.  It also replaces notes about emailing James Morris to refer
to me instead.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
---

 Documentation/crypto/api-intro.txt |   36 ++++++++++++++++++++++--------------
 1 files changed, 22 insertions(+), 14 deletions(-)

diff --git a/Documentation/crypto/api-intro.txt b/Documentation/crypto/api-intro.txt
--- a/Documentation/crypto/api-intro.txt
+++ b/Documentation/crypto/api-intro.txt
@@ -19,15 +19,14 @@ At the lowest level are algorithms, whic
 API.
 
 'Transforms' are user-instantiated objects, which maintain state, handle all
-of the implementation logic (e.g. manipulating page vectors), provide an 
-abstraction to the underlying algorithms, and handle common logical 
-operations (e.g. cipher modes, HMAC for digests).  However, at the user 
+of the implementation logic (e.g. manipulating page vectors) and provide an 
+abstraction to the underlying algorithms.  However, at the user 
 level they are very simple.
 
 Conceptually, the API layering looks like this:
 
   [transform api]  (user interface)
-  [transform ops]  (per-type logic glue e.g. cipher.c, digest.c)
+  [transform ops]  (per-type logic glue e.g. cipher.c, compress.c)
   [algorithm api]  (for registering algorithms)
   
 The idea is to make the user interface and algorithm registration API
@@ -44,22 +43,27 @@ under development.
 Here's an example of how to use the API:
 
 	#include &lt;linux/crypto.h&gt;
+	#include &lt;linux/err.h&gt;
+	#include &lt;linux/scatterlist.h&gt;
 	
 	struct scatterlist sg[2];
 	char result[128];
-	struct crypto_tfm *tfm;
+	struct crypto_hash *tfm;
+	struct hash_desc desc;
 	
-	tfm = crypto_alloc_tfm("md5", 0);
-	if (tfm == NULL)
+	tfm = crypto_alloc_hash("md5", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(tfm))
 		fail();
 		
 	/* ... set up the scatterlists ... */
+
+	desc.tfm = tfm;
+	desc.flags = 0;
 	
-	crypto_digest_init(tfm);
-	crypto_digest_update(tfm, &amp;sg, 2);
-	crypto_digest_final(tfm, result);
+	if (crypto_hash_digest(&amp;desc, &amp;sg, 2, result))
+		fail();
 	
-	crypto_free_tfm(tfm);
+	crypto_free_hash(tfm);
 
     
 Many real examples are available in the regression test module (tcrypt.c).
@@ -126,7 +130,7 @@ might already be working on.
 BUGS
 
 Send bug reports to:
-James Morris &lt;jmorris@redhat.com&gt;
+Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
 Cc: David S. Miller &lt;davem@redhat.com&gt;
 
 
@@ -134,13 +138,14 @@ FURTHER INFORMATION
 
 For further patches and various updates, including the current TODO
 list, see:
-http://samba.org/~jamesm/crypto/
+http://gondor.apana.org.au/~herbert/crypto/
 
 
 AUTHORS
 
 James Morris
 David S. Miller
+Herbert Xu
 
 
 CREDITS
@@ -238,8 +243,11 @@ Anubis algorithm contributors:
 Tiger algorithm contributors:
   Aaron Grothe
 
+VIA PadLock contributors:
+  Michal Ludvig
+
 Generic scatterwalk code by Adam J. Richter &lt;adam@yggdrasil.com&gt;
 
 Please send any credits updates or corrections to:
-James Morris &lt;jmorris@redhat.com&gt;
+Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
 
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060821142759</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-08-21 14:27:59-0400</timestampReceived><subject>[PATCH 7/7] [CRYPTO] digest: Remove old HMAC implementation</subject><body>

[CRYPTO] digest: Remove old HMAC implementation

This patch removes the old HMAC implementation now that nobody uses it
anymore.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;
---

 crypto/Kconfig         |    2 
 crypto/digest.c        |    3 -
 crypto/hmac.c          |  101 -------------------------------------------------
 crypto/internal.h      |   13 ------
 include/linux/crypto.h |   16 -------
 5 files changed, 2 insertions(+), 133 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -33,7 +33,7 @@ config CRYPTO_MANAGER
 	  cbc(aes).
 
 config CRYPTO_HMAC
-	bool "HMAC support"
+	tristate "HMAC support"
 	select CRYPTO_HASH
 	help
 	  HMAC: Keyed-Hashing for Message Authentication (RFC2104).
diff --git a/crypto/digest.c b/crypto/digest.c
--- a/crypto/digest.c
+++ b/crypto/digest.c
@@ -191,10 +191,9 @@ int crypto_init_digest_ops(struct crypto
 	ops-&gt;setkey	= dalg-&gt;dia_setkey ? setkey : nosetkey;
 	ops-&gt;digestsize	= dalg-&gt;dia_digestsize;
 	
-	return crypto_alloc_hmac_block(tfm);
+	return 0;
 }
 
 void crypto_exit_digest_ops(struct crypto_tfm *tfm)
 {
-	crypto_free_hmac_block(tfm);
 }
diff --git a/crypto/hmac.c b/crypto/hmac.c
--- a/crypto/hmac.c
+++ b/crypto/hmac.c
@@ -29,107 +29,6 @@ struct hmac_ctx {
 	struct crypto_hash *child;
 };
 
-static void hash_key(struct crypto_tfm *tfm, u8 *key, unsigned int keylen)
-{
-	struct scatterlist tmp;
-	
-	sg_set_buf(&amp;tmp, key, keylen);
-	crypto_digest_digest(tfm, &amp;tmp, 1, key);
-}
-
-int crypto_alloc_hmac_block(struct crypto_tfm *tfm)
-{
-	int ret = 0;
-
-	BUG_ON(!crypto_tfm_alg_blocksize(tfm));
-	
-	tfm-&gt;crt_hash.hmac_block = kmalloc(crypto_tfm_alg_blocksize(tfm),
-					   GFP_KERNEL);
-	if (tfm-&gt;crt_hash.hmac_block == NULL)
-		ret = -ENOMEM;
-
-	return ret;
-		
-}
-
-void crypto_free_hmac_block(struct crypto_tfm *tfm)
-{
-	kfree(tfm-&gt;crt_hash.hmac_block);
-}
-
-void crypto_hmac_init(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen)
-{
-	unsigned int i;
-	struct scatterlist tmp;
-	char *ipad = tfm-&gt;crt_hash.hmac_block;
-	
-	if (*keylen &gt; crypto_tfm_alg_blocksize(tfm)) {
-		hash_key(tfm, key, *keylen);
-		*keylen = crypto_tfm_alg_digestsize(tfm);
-	}
-
-	memset(ipad, 0, crypto_tfm_alg_blocksize(tfm));
-	memcpy(ipad, key, *keylen);
-
-	for (i = 0; i &lt; crypto_tfm_alg_blocksize(tfm); i++)
-		ipad[i] ^= 0x36;
-
-	sg_set_buf(&amp;tmp, ipad, crypto_tfm_alg_blocksize(tfm));
-	
-	crypto_digest_init(tfm);
-	crypto_digest_update(tfm, &amp;tmp, 1);
-}
-
-void crypto_hmac_update(struct crypto_tfm *tfm,
-                        struct scatterlist *sg, unsigned int nsg)
-{
-	crypto_digest_update(tfm, sg, nsg);
-}
-
-void crypto_hmac_final(struct crypto_tfm *tfm, u8 *key,
-                       unsigned int *keylen, u8 *out)
-{
-	unsigned int i;
-	struct scatterlist tmp;
-	char *opad = tfm-&gt;crt_hash.hmac_block;
-	
-	if (*keylen &gt; crypto_tfm_alg_blocksize(tfm)) {
-		hash_key(tfm, key, *keylen);
-		*keylen = crypto_tfm_alg_digestsize(tfm);
-	}
-
-	crypto_digest_final(tfm, out);
-
-	memset(opad, 0, crypto_tfm_alg_blocksize(tfm));
-	memcpy(opad, key, *keylen);
-		
-	for (i = 0; i &lt; crypto_tfm_alg_blocksize(tfm); i++)
-		opad[i] ^= 0x5c;
-
-	sg_set_buf(&amp;tmp, opad, crypto_tfm_alg_blocksize(tfm));
-
-	crypto_digest_init(tfm);
-	crypto_digest_update(tfm, &amp;tmp, 1);
-	
-	sg_set_buf(&amp;tmp, out, crypto_tfm_alg_digestsize(tfm));
-	
-	crypto_digest_update(tfm, &amp;tmp, 1);
-	crypto_digest_final(tfm, out);
-}
-
-void crypto_hmac(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen,
-                 struct scatterlist *sg, unsigned int nsg, u8 *out)
-{
-	crypto_hmac_init(tfm, key, keylen);
-	crypto_hmac_update(tfm, sg, nsg);
-	crypto_hmac_final(tfm, key, keylen, out);
-}
-
-EXPORT_SYMBOL_GPL(crypto_hmac_init);
-EXPORT_SYMBOL_GPL(crypto_hmac_update);
-EXPORT_SYMBOL_GPL(crypto_hmac_final);
-EXPORT_SYMBOL_GPL(crypto_hmac);
-
 static inline void *align_ptr(void *p, unsigned int align)
 {
 	return (void *)ALIGN((unsigned long)p, align);
diff --git a/crypto/internal.h b/crypto/internal.h
--- a/crypto/internal.h
+++ b/crypto/internal.h
@@ -73,19 +73,6 @@ static inline void crypto_yield(u32 flag
 		cond_resched();
 }
 
-#ifdef CONFIG_CRYPTO_HMAC
-int crypto_alloc_hmac_block(struct crypto_tfm *tfm);
-void crypto_free_hmac_block(struct crypto_tfm *tfm);
-#else
-static inline int crypto_alloc_hmac_block(struct crypto_tfm *tfm)
-{
-	return 0;
-}
-
-static inline void crypto_free_hmac_block(struct crypto_tfm *tfm)
-{ }
-#endif
-
 #ifdef CONFIG_PROC_FS
 void __init crypto_init_proc(void);
 void __exit crypto_exit_proc(void);
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -295,9 +295,6 @@ struct hash_tfm {
 		      unsigned int nsg, u8 *out);
 	int (*setkey)(struct crypto_hash *tfm, const u8 *key,
 		      unsigned int keylen);
-#ifdef CONFIG_CRYPTO_HMAC
-	void *hmac_block;
-#endif
 	unsigned int digestsize;
 };
 
@@ -872,18 +869,5 @@ static inline int crypto_comp_decompress
 	return tfm-&gt;crt_compress.cot_decompress(tfm, src, slen, dst, dlen);
 }
 
-/*
- * HMAC support.
- */
-#ifdef CONFIG_CRYPTO_HMAC
-void crypto_hmac_init(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen);
-void crypto_hmac_update(struct crypto_tfm *tfm,
-                        struct scatterlist *sg, unsigned int nsg);
-void crypto_hmac_final(struct crypto_tfm *tfm, u8 *key,
-                       unsigned int *keylen, u8 *out);
-void crypto_hmac(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen,
-                 struct scatterlist *sg, unsigned int nsg, u8 *out);
-#endif	/* CONFIG_CRYPTO_HMAC */
-
 #endif	/* _LINUX_CRYPTO_H */
 
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060822062853</emailId><senderName>Solar Designer</senderName><senderEmail>solar@openwall.com</senderEmail><timestampReceived>2006-08-22 06:28:53-0400</timestampReceived><subject>Re: [PATCH] cit_encrypt_iv/cit_decrypt_iv for ECB mode</subject><body>

On Mon, Aug 21, 2006 at 08:58:30AM +1000, Herbert Xu wrote:
&gt; On Sun, Aug 20, 2006 at 06:49:08PM +0400, Solar Designer wrote:
&gt; &gt; 
&gt; &gt; Can we maybe define working but IV-ignoring functions for ECB (like I
&gt; &gt; did), but use memory-clearing nocrypt*() for CFB and CTR (as long as
&gt; &gt; these are not supported)?  Of course, all of these will return -ENOSYS.
&gt; 
&gt; In cryptodev-2.6, with block ciphers you can no longer select CFB/CTR
&gt; until someone writes support for them so this is no longer an issue.
&gt; 
&gt; For 2.4, I don't really mind either way what nocrypt does.

OK, I've merged Willy's suggestion for the memset()s into the patch that
I had submitted previously.  The resulting patch is attached.

Alexander

["linux-2.4.33-nocrypt.diff" (text/plain)]

diff -urp linux-2.4.33/crypto/cipher.c linux/crypto/cipher.c
--- linux-2.4.33/crypto/cipher.c	Sun Aug  8 03:26:04 2004
+++ linux/crypto/cipher.c	Tue Aug 22 09:53:35 2006
@@ -147,6 +147,15 @@ static int ecb_encrypt(struct crypto_tfm
 	             ecb_process, 1, NULL);
 }
 
+static int ecb_encrypt_iv(struct crypto_tfm *tfm,
+			  struct scatterlist *dst,
+			  struct scatterlist *src,
+			  unsigned int nbytes, u8 *iv)
+{
+	ecb_encrypt(tfm, dst, src, nbytes);
+	return -ENOSYS;
+}
+
 static int ecb_decrypt(struct crypto_tfm *tfm,
                        struct scatterlist *dst,
                        struct scatterlist *src,
@@ -157,6 +166,15 @@ static int ecb_decrypt(struct crypto_tfm
 	             ecb_process, 1, NULL);
 }
 
+static int ecb_decrypt_iv(struct crypto_tfm *tfm,
+			  struct scatterlist *dst,
+			  struct scatterlist *src,
+			  unsigned int nbytes, u8 *iv)
+{
+	ecb_decrypt(tfm, dst, src, nbytes);
+	return -ENOSYS;
+}
+
 static int cbc_encrypt(struct crypto_tfm *tfm,
                        struct scatterlist *dst,
                        struct scatterlist *src,
@@ -197,11 +215,20 @@ static int cbc_decrypt_iv(struct crypto_
 	             cbc_process, 0, iv);
 }
 
+/*
+ * nocrypt*() zeroize the destination buffer to make sure we don't leak
+ * uninitialized memory contents if the caller ignores the return value.
+ * This is bad since the data in the source buffer is unused and may be
+ * lost, but an infoleak would be even worse.  The performance cost of
+ * memset() is irrelevant since a well-behaved caller would not bump into
+ * the error repeatedly.
+ */
 static int nocrypt(struct crypto_tfm *tfm,
                    struct scatterlist *dst,
                    struct scatterlist *src,
 		   unsigned int nbytes)
 {
+	memset(dst, 0, nbytes);
 	return -ENOSYS;
 }
 
@@ -210,6 +237,7 @@ static int nocrypt_iv(struct crypto_tfm 
                       struct scatterlist *src,
                       unsigned int nbytes, u8 *iv)
 {
+	memset(dst, 0, nbytes);
 	return -ENOSYS;
 }
 
@@ -235,6 +263,11 @@ int crypto_init_cipher_ops(struct crypto
 	case CRYPTO_TFM_MODE_ECB:
 		ops-&gt;cit_encrypt = ecb_encrypt;
 		ops-&gt;cit_decrypt = ecb_decrypt;
+/* These should have been nocrypt_iv, but patch-cryptoloop-jari-2.4.22.0
+ * (and its other revisions) directly calls the *_iv() functions even in
+ * ECB mode and ignores their return value. */
+		ops-&gt;cit_encrypt_iv = ecb_encrypt_iv;
+		ops-&gt;cit_decrypt_iv = ecb_decrypt_iv;
 		break;
 		
 	case CRYPTO_TFM_MODE_CBC:

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060822083915</emailId><senderName></senderName><senderEmail>listproc</senderEmail><timestampReceived>2006-08-22 08:39:15-0400</timestampReceived><subject>Error Condition Re: Invalid request</subject><body>

&gt;This is a multi-part message in MIME format.

Unrecognized request THIS

Report any problems to 'newsmaster@vt.edu'.
For a list of the available requests send a message to listproc@solaris.cc.vt.edu
with a body consisting of nothing but the word HELP

PS: Any subsequent requests that you might have submitted have been ignored.

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060824145205</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-08-24 14:52:05-0400</timestampReceived><subject>Re: single-key vs multi-key</subject><body>

Marco Fonseca wrote:
&gt; I've been searching for some info on single-key vs multi-key, but
&gt; haven't found a great deal of it.  How much more superior is multi-key
&gt; over single-key.  Any info would be helpful.

loop-AES version 1 on-disk format (single-key) has easily exploitable IV
computation weakness and should not be used. loop-AES version 2 and 3
on-disk formats (multi-key) have stronger IV computation. Since on-disk
format needed to be changed on v1-to-v2 transition, multiple encryption keys
were also included at the same time. Multi-key mode reduces amount of data
encrypted using one encryption key, and thus reduces probability of
identical ciphertexts using same encryption key. Identical ciphertexts leak
information.

Old versions of dm-crypt and truecrypt had same exploitable IV computation
weakness, but newer versions of those implementations fixed that weakness in
different way.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060827233403</emailId><senderName>"senphonie"</senderName><senderEmail>envoi@lymail.com</senderEmail><timestampReceived>2006-08-27 23:34:03-0400</timestampReceived><subject>La telephonie illimitee par Internet</subject><body>

La téléphonie illimitée par Internet 
 
Entreprises et Particuliers,

Découvrez notre forfait téléphonique monde illimité, sans engagement de durée.

N'hésitez plus, 

Ouverture immédiate de votre ligne
 
  
| Forfaits illimités | Standards | Offre revendeur | Vous désabonner |  2006 senphonie.com |  


[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=Content-Type content="text/html; charset=iso-8859-1"&gt;
&lt;/head&gt;
&lt;body topmargin="0" leftmargin="0" bgcolor="#FFFFFF" link="#075CA3" vlink="#075CA3" \
alink="#075CA3"&gt; &lt;div align="center"&gt;
  &lt;table width="650" border="0" cellspacing="0" cellpadding="0"&gt;
    &lt;tr height="61"&gt;
      &lt;td height="61" colspan="2" align="middle" valign="middle"&gt;&lt;table width="100%" \
border="0" cellspacing="0" cellpadding="3"&gt;  &lt;tr&gt;
            &lt;td width="126" height="74" align="right" valign="middle"&gt;&lt;img \
src="http://senphonie.lymail.com/images/fl.gif" border="0"&gt;&lt;/td&gt;  &lt;td \
width="32"&gt; &lt;/td&gt;  &lt;td width="492" valign="middle"&gt;&lt;font size="5" \
color="#004371" face="Arial, Helvetica, sans-serif"&gt;&lt;strong&gt;La \
téléphonie illimitée par Internet&lt;/strong&gt;&lt;/font&gt;&lt;/td&gt;  &lt;/tr&gt;
        &lt;/table&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td width="49%" align="center" valign="bottom" bgcolor="#000000"&gt;&lt;img \
src="http://senphonie.lymail.com/images/0001.jpg" width="318" height="264" \
                border="0"&gt;&lt;/td&gt;
      &lt;td width="51%" height="278" valign="center" bgcolor="#214987"&gt;&lt;div \
                align="center"&gt;
          &lt;p&gt;&lt;font color="#FFFFFF" face="Arial, Helvetica, \
sans-serif"&gt;&lt;strong&gt;Entreprises et Particuliers,&lt;br&gt;  &lt;br&gt;
            Découvrez notre forfait téléphonique monde \
illimité, sans engagement de durée.&lt;br&gt;  &lt;br&gt;
            N'hésitez plus, &lt;/strong&gt;&lt;/font&gt;&lt;br&gt;
            &lt;a href="http://senphonie.com/forfait.htm"&gt;&lt;img \
                src="http://senphonie.lymail.com/images/bt.gif" border="0"&gt;&lt;br&gt;
      &lt;/a&gt;&lt;font color="#FFFFFF" face="Arial, Helvetica, sans-serif"&gt;&lt;strong&gt;Ouverture \
immédiate de votre ligne&lt;/strong&gt;&lt;/font&gt;&lt;/div&gt;&lt;/td&gt;  &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td height="38" align="center" valign="middle"&gt;&lt;img \
                src="http://senphonie.lymail.com/images/bt1.gif" border="0"&gt;&lt;/td&gt;
      &lt;td align="center" valign="middle"&gt;&lt;img \
src="http://senphonie.lymail.com/images/bt2.gif" border="0"&gt;&lt;/td&gt;  &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td height="18" colspan="2" align="center" valign="top"&gt; | &lt;a \
href="http://senphonie.com/forfait.htm"&gt;&lt;font size="1" face="Arial, Helvetica, \
sans-serif"&gt;Forfaits illimités&lt;/font&gt;&lt;/a&gt; | &lt;a \
href="http://senphonie.com/standards_SPA_9000.htm"&gt;&lt;font size="1" face="Arial, \
Helvetica, sans-serif"&gt;Standards&lt;/font&gt;&lt;/a&gt; | &lt;a \
href="http://senphonie.com/offre_revendeur.htm"&gt;&lt;font size="1" face="Arial, \
Helvetica, sans-serif"&gt;Offre revendeur&lt;/font&gt;&lt;/a&gt; | &lt;a \
href="http://senphonie.lymail.com"&gt;&lt;font size="1" face="Arial, Helvetica, \
sans-serif"&gt;Vous désabonner&lt;/font&gt;&lt;/a&gt; | &lt;font size="1" face="Arial, \
Helvetica, sans-serif"&gt;© 2006 senphonie.com&lt;/font&gt; | &lt;/td&gt;  &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060828141410</emailId><senderName>" "</senderName><senderEmail>bjcody@webtv.net</senderEmail><timestampReceived>2006-08-28 14:14:10-0400</timestampReceived><subject>BACK PAIN ARTICLES / BACK PAIN MRI COM</subject><body>

http://www.backpainmri.com


[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;
&lt;HEAD&gt;&lt;META http-equiv="Content-Type" content="text/html;charset=iso-8859-1"&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;div style='padding:0 0 10px 0'&gt;&lt;font face='font-family:segoe tv,Arial,Verdana'&gt;&lt;span \
style="word-break:break-all"&gt;&lt;a \
href="http://www.backpainmri.com"&gt;http://www.backpainmri.com&lt;/a&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt; \
&lt;/BODY&gt;&lt;/HTML&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060829162219</emailId><senderName>"Alon Bar-Lev"</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2006-08-29 16:22:19-0400</timestampReceived><subject>Re: Loop-AES &amp; Full-disk encryption</subject><body>

Hello,

No.
You can use loop-aes as a module, and load it during initrd/initramfs procedure.

However, If you have linked the default loop module into the kernel,
then you first need to modify your kernel configuration so it will be
disabled or be a module, so you can load the loop-aes module in place
the kernel one.

Alon Bar-Lev.

On 8/29/06, Michael Zhu &lt;mylinuxk@yahoo.ca&gt; wrote:
&gt; Hi, Jari, thanks for the reply. I did some tests with
&gt; Loop-AES. From the README it seems that I have to
&gt; recompile/reconfig the kernel if I want to encrypt the
&gt; root partition. Am I right?
&gt;
&gt; Thanks.
&gt;
&gt; Michael
&gt;
&gt;
&gt; --- Jari Ruusu &lt;jariruusu@users.sourceforge.net&gt;
&gt; wrote:
&gt;
&gt; &gt; Michael Zhu wrote:
&gt; &gt; &gt; Is Loop-AES a kind of full-disk encryption?
&gt; &gt;
&gt; &gt; Loop-AES encrypts devices. You can encrypt full
&gt; &gt; device /dev/hda using
&gt; &gt; loop-AES, but usually it is used to encrypt
&gt; &gt; partitions like /dev/hda4
&gt; &gt;
&gt; &gt; &gt; I mean Loop-AES is a sector by sector partition
&gt; &gt; based encryption or not?
&gt; &gt;
&gt; &gt; It is sector by sector encryption.
&gt; &gt;
&gt; &gt; &gt; I read the README about the Loop-AES. It says that
&gt; &gt; Loop-AES will create a
&gt; &gt; &gt; boot partition and this boot partition is
&gt; &gt; unencrypted. What kind of
&gt; &gt; &gt; information contained in this small boot
&gt; &gt; partition? The Linux kernel image
&gt; &gt; &gt; or just some kind of boot records? Loop-AES will
&gt; &gt; encrypt the entire
&gt; &gt; &gt; operation system including all the system files?
&gt; &gt;
&gt; &gt; Kernel needs to be loaded from some unencrypted
&gt; &gt; device. Usually bootloader
&gt; &gt; and kernel are in /boot but sometimes they are
&gt; &gt; loaded from CD-ROM or
&gt; &gt; USB-stick.
&gt; &gt;
&gt; &gt; --
&gt; &gt; Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9
&gt; &gt; DB 1D EB E3 24 0E A9 DD
&gt; &gt;
&gt;
&gt;
&gt; __________________________________________________
&gt; Do You Yahoo!?
&gt; Tired of spam?  Yahoo! Mail has the best spam protection around
&gt; http://mail.yahoo.com
&gt;
&gt; -
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/
&gt;
&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060831123931</emailId><senderName>Rik Snel</senderName><senderEmail>rsnel@cube.dyndns.org</senderEmail><timestampReceived>2006-08-31 12:39:31-0400</timestampReceived><subject>[PATCH 1/6] crypto: trivial comment improvements</subject><body>

Just some minor comment nits. 

- little-endian is better than low-endian
- and since it is called essiv everywere it should also be essiv 
  in the comments (and not ess_iv)

Signed-off-by: Rik Snel &lt;rsnel@cube.dyndns.org&gt;
---
 drivers/md/dm-crypt.c |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c
index 91d4081..06961f7 100644
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@ -99,12 +99,12 @@ static kmem_cache_t *_crypt_io_pool;
 /*
  * Different IV generation algorithms:
  *
- * plain: the initial vector is the 32-bit low-endian version of the sector
+ * plain: the initial vector is the 32-bit little-endian version of the sector
  *        number, padded with zeros if neccessary.
  *
- * ess_iv: "encrypted sector|salt initial vector", the sector number is
- *         encrypted with the bulk cipher using a salt as key. The salt
- *         should be derived from the bulk cipher's key via hashing.
+ * essiv: "encrypted sector|salt initial vector", the sector number is
+ *        encrypted with the bulk cipher using a salt as key. The salt
+ *        should be derived from the bulk cipher's key via hashing.
  *
  * plumb: unimplemented, see:
  * http://article.gmane.org/gmane.linux.kernel.device-mapper.dm-crypt/454
-- 
1.4.1.1

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060831123932</emailId><senderName>Rik Snel</senderName><senderEmail>rsnel@cube.dyndns.org</senderEmail><timestampReceived>2006-08-31 12:39:32-0400</timestampReceived><subject>[PATCH 2/6] crypto: benbi IV, big endian narrow block count for LRW-32-AES</subject><body>

LRW-32-AES needs a certain IV. This IV should be provided dm-crypt. 
The block cipher mode could, in principle generate the correct IV from
the plain IV, but I think that it is cleaner to supply the right IV
directly.

The sector -&gt; narrow block calculation uses a shift for performance reasons.
This shift is computed in .ctr and stored in cc-&gt;iv_gen_private (as a void*).

Signed-off-by: Rik Snel &lt;rsnel@cube.dyndns.org&gt;
---
 drivers/md/dm-crypt.c |   56 ++++++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 55 insertions(+), 1 deletions(-)

diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c
index 06961f7..12c871c 100644
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@ -106,6 +106,9 @@ static kmem_cache_t *_crypt_io_pool;
  *        encrypted with the bulk cipher using a salt as key. The salt
  *        should be derived from the bulk cipher's key via hashing.
  *
+ * benbi: the 64-bit "big-endian 'narrow block'-count", starting at 1
+ * 	  (needed for LRW-32-AES and possible other narrow block modes)
+ *
  * plumb: unimplemented, see:
  * http://article.gmane.org/gmane.linux.kernel.device-mapper.dm-crypt/454
  */
@@ -200,6 +203,49 @@ static int crypt_iv_essiv_gen(struct cry
 	return 0;
 }
 
+static int crypt_iv_benbi_ctr(struct crypt_config *cc, struct dm_target *ti,
+			      const char *opts)
+{
+	unsigned int bs = crypto_blkcipher_blocksize(cc-&gt;tfm);
+	int log = long_log2(bs);
+
+	/* we need to calculate how far we must shift the sector count
+	 * to get the cipher block count, we use this shift in _gen */
+
+	if (1 &lt;&lt; log != bs) {
+		ti-&gt;error = "cypher blocksize is not a power of 2";
+		return -EINVAL;
+	}
+
+	if (log &gt; 9) {
+		ti-&gt;error = "cypher blocksize is &gt; 512";
+		return -EINVAL;
+	}
+	
+	if (crypto_blkcipher_ivsize(cc-&gt;tfm) &lt; sizeof(u64)) {
+		ti-&gt;error = "cypher ivsize is &lt; 8";
+		return -EINVAL;
+	}
+
+	cc-&gt;iv_gen_private = (void*)(9 - log);
+
+	return 0;
+}
+
+static void crypt_iv_benbi_dtr(struct crypt_config *cc) 
+{
+	cc-&gt;iv_gen_private = NULL; 
+}
+
+static int crypt_iv_benbi_gen(struct crypt_config *cc, u8 *iv, sector_t sector)
+{
+	memset(iv, 0, cc-&gt;iv_size - sizeof(u64)); /* rest is cleared below */
+	*(u64 *)(iv + cc-&gt;iv_size - sizeof(u64)) = 
+		cpu_to_be64(((u64)sector &lt;&lt; (u32)cc-&gt;iv_gen_private) + 1);
+
+	return 0;
+}
+
 static struct crypt_iv_operations crypt_iv_plain_ops = {
 	.generator = crypt_iv_plain_gen
 };
@@ -210,6 +256,11 @@ static struct crypt_iv_operations crypt_
 	.generator = crypt_iv_essiv_gen
 };
 
+static struct crypt_iv_operations crypt_iv_benbi_ops = {
+	.ctr	   = crypt_iv_benbi_ctr,
+	.dtr	   = crypt_iv_benbi_dtr,
+	.generator = crypt_iv_benbi_gen
+};
 
 static int
 crypt_convert_scatterlist(struct crypt_config *cc, struct scatterlist *out,
@@ -579,7 +630,8 @@ static int crypt_ctr(struct dm_target *t
 	cc-&gt;tfm = tfm;
 
 	/*
-	 * Choose ivmode. Valid modes: "plain", "essiv:&lt;esshash&gt;".
+	 * Choose ivmode. Valid modes: "plain", "essiv:&lt;esshash&gt;", "benbi".
+	 *
 	 * See comments at iv code
 	 */
 
@@ -589,6 +641,8 @@ static int crypt_ctr(struct dm_target *t
 		cc-&gt;iv_gen_ops = &amp;crypt_iv_plain_ops;
 	else if (strcmp(ivmode, "essiv") == 0)
 		cc-&gt;iv_gen_ops = &amp;crypt_iv_essiv_ops;
+	else if (strcmp(ivmode, "benbi") == 0)
+		cc-&gt;iv_gen_ops = &amp;crypt_iv_benbi_ops;
 	else {
 		ti-&gt;error = "Invalid IV mode";
 		goto bad2;
-- 
1.4.1.1

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060831123933</emailId><senderName>Rik Snel</senderName><senderEmail>rsnel@cube.dyndns.org</senderEmail><timestampReceived>2006-08-31 12:39:33-0400</timestampReceived><subject>[PATCH 3/6] crypto: some common 128-bit block operations, nicely centralized</subject><body>

128bit is a common blocksize in linux kernel cryptography, so it helps to
centralize some common operations. The data must be aligned at sizeof(int)
for decent performance.

The code, while mostly trivial, is based on a header file mode_hdr.h in
http://fp.gladman.plus.com/AES/modes.vc8.19-06-06.zip

The original copyright (and GPL statement) of the original author,
Dr Brian Gladman, is preserved.

Signed-off-by: Rik Snel &lt;rsnel@cube.dyndns.org&gt;
---
 crypto/b128ops.h |   72 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 72 insertions(+), 0 deletions(-)

diff --git a/crypto/b128ops.h b/crypto/b128ops.h
new file mode 100644
index 0000000..d32bfc2
--- /dev/null
+++ b/crypto/b128ops.h
@@ -0,0 +1,72 @@
+/* b128ops.h - common 128-bit block operations
+ * 
+ * Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.
+ * Copyright (c) 2006, Rik Snel &lt;rsnel@cube.dyndns.org&gt;
+ *
+ * Based on Dr Brain Gladman's (GPL'd) work published at
+ * http://fp.gladman.plus.com/cryptography_technology/index.htm
+ * See the original copyright notice below.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+/*
+ ---------------------------------------------------------------------------
+ Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.   All rights reserved.
+
+ LICENSE TERMS
+
+ The free distribution and use of this software in both source and binary
+ form is allowed (with or without changes) provided that:
+
+   1. distributions of this source code include the above copyright
+      notice, this list of conditions and the following disclaimer;
+
+   2. distributions in binary form include the above copyright
+      notice, this list of conditions and the following disclaimer
+      in the documentation and/or other associated materials;
+
+   3. the copyright holder's name is not used to endorse products
+      built using this software without specific written permission.
+
+ ALTERNATIVELY, provided that this notice is retained in full, this product
+ may be distributed under the terms of the GNU General Public License (GPL),
+ in which case the provisions of the GPL apply INSTEAD OF those given above.
+
+ DISCLAIMER
+
+ This software is provided 'as is' with no explicit or implied warranties
+ in respect of its properties, including, but not limited to, correctness
+ and/or fitness for purpose.
+ ---------------------------------------------------------------------------
+ Issue Date: 13/06/2006
+*/
+
+#ifndef _LINUX_B128OPS_H
+#define _LINUX_B128OPS_H
+
+#include &lt;linux/byteorder/swab.h&gt;
+
+/* watch out: for good performance p and q must be aligned to 32bit
+ * boundaries on a 32bit machine and to 64bit boundaries on a 64bit 
+ * machine. */
+inline void b128ops_mov(void *p, const void *q)
+{
+	((u64*)p)[0] = ((u64*)q)[0];
+	((u64*)p)[1] = ((u64*)q)[1];
+}
+
+inline void b128ops_xor(void *p, const void *q)
+{
+	((u64*)p)[0] ^= ((u64*)q)[0];
+	((u64*)p)[1] ^= ((u64*)q)[1];
+}
+
+inline void bswap64_block(void* d, const void* s, u32 n)
+{ 
+    while(n--) ((u64*)d)[n] = __swab64(((u64*)s)[n]);
+}
+
+#endif /* _LINUX_B128OPS_H */
-- 
1.4.1.1

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060831123934</emailId><senderName>Rik Snel</senderName><senderEmail>rsnel@cube.dyndns.org</senderEmail><timestampReceived>2006-08-31 12:39:34-0400</timestampReceived><subject>[PATCH 4/6] crypto: table driven multiplications in GF(2^128), needed by LRW (and in the future ABL)</subject><body>

WARNING: untested on bigendian, please test.

A lot of cypher modes need multiplications in GF(2^128). LRW, ABL, GCM...
I use functions from this library in my LRW implementation and I will
also use them in my ABL (Arbitrary Block Length, an unencumbered (correct
me if I am wrong, wide block cipher mode).

Elements of GF(2^128) must be presented as u64* (specifically u64[2]),
it encourages automatic and proper alignment.

The library contains support for two different representations of GF(2^128),
see the comment in gf128mul.h. There different levels of optimization
(memory/speed tradeoff).

The code is based on work by Dr Brian Gladman. Notable changes:
- deletion of two optimization modes
- change from u32 to u64 for faster handling on 64bit machines
- support for 'bbe' representation in addition to the, already implemented,
  'lle' representation.
- move 'inline void' functions from header to 'static void' in the
  source file
- update to use the linux coding style conventions

The original can be found at:
http://fp.gladman.plus.com/AES/modes.vc8.19-06-06.zip

The copyright (and GPL statement) of the original author is preserved.

Signed-off-by: Rik Snel &lt;rsnel@cube.dyndns.org&gt;
---
 crypto/Kconfig    |   11 +
 crypto/Makefile   |    1 
 crypto/gf128mul.c |  401 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 crypto/gf128mul.h |  196 ++++++++++++++++++++++++++
 4 files changed, 609 insertions(+), 0 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
index 1e2f39c..6b23c20 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -128,6 +128,17 @@ config CRYPTO_TGR192
 	  See also:
 	  &lt;http://www.cs.technion.ac.il/~biham/Reports/Tiger/&gt;.
 
+config CRYPTO_GF128MUL
+	tristate "GF(2^128) multiplication functions (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	default n
+	help
+	  Efficient table driven implementation of multiplications in the
+	  field GF(2^128). This is needed by some cypher modes. This
+	  option will be selected automatically if you select such a
+	  cipher mode. Only select this option by hand if you expect to load
+	  an external module that requires these functions.
+
 config CRYPTO_ECB
 	tristate "ECB support"
 	select CRYPTO_BLKCIPHER
diff --git a/crypto/Makefile b/crypto/Makefile
index 7236620..bf0406b 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -23,6 +23,7 @@ obj-$(CONFIG_CRYPTO_SHA256) += sha256.o
 obj-$(CONFIG_CRYPTO_SHA512) += sha512.o
 obj-$(CONFIG_CRYPTO_WP512) += wp512.o
 obj-$(CONFIG_CRYPTO_TGR192) += tgr192.o
+obj-$(CONFIG_CRYPTO_GF128MUL) += gf128mul.o
 obj-$(CONFIG_CRYPTO_ECB) += ecb.o
 obj-$(CONFIG_CRYPTO_CBC) += cbc.o
 obj-$(CONFIG_CRYPTO_DES) += des.o
diff --git a/crypto/gf128mul.c b/crypto/gf128mul.c
new file mode 100644
index 0000000..6d17704
--- /dev/null
+++ b/crypto/gf128mul.c
@@ -0,0 +1,401 @@
+/* gf128mul.c - GF(2^128) multiplication functions
+ * 
+ * Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.
+ * Copyright (c) 2006, Rik Snel &lt;rsnel@cube.dyndns.org&gt;
+ *
+ * Based on Dr Brain Gladman's (GPL'd) work published at
+ * http://fp.gladman.plus.com/cryptography_technology/index.htm
+ * See the original copyright notice below.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+/*
+ ---------------------------------------------------------------------------
+ Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.   All rights reserved.
+
+ LICENSE TERMS
+
+ The free distribution and use of this software in both source and binary
+ form is allowed (with or without changes) provided that:
+
+   1. distributions of this source code include the above copyright
+      notice, this list of conditions and the following disclaimer;
+
+   2. distributions in binary form include the above copyright
+      notice, this list of conditions and the following disclaimer
+      in the documentation and/or other associated materials;
+
+   3. the copyright holder's name is not used to endorse products
+      built using this software without specific written permission.
+
+ ALTERNATIVELY, provided that this notice is retained in full, this product
+ may be distributed under the terms of the GNU General Public License (GPL),
+ in which case the provisions of the GPL apply INSTEAD OF those given above.
+
+ DISCLAIMER
+
+ This software is provided 'as is' with no explicit or implied warranties
+ in respect of its properties, including, but not limited to, correctness
+ and/or fitness for purpose.
+ ---------------------------------------------------------------------------
+ Issue 31/01/2006
+
+ This file provides fast multiplication in GF(128) as required by several
+ cryptographic authentication modes
+*/
+
+#include &lt;linux/module.h&gt;
+#include "b128ops.h"
+#include "gf128mul.h"
+
+#define gf128mul_dat(q) { \
+	q(0x00), q(0x01), q(0x02), q(0x03), q(0x04), q(0x05), q(0x06), q(0x07),\
+	q(0x08), q(0x09), q(0x0a), q(0x0b), q(0x0c), q(0x0d), q(0x0e), q(0x0f),\
+	q(0x10), q(0x11), q(0x12), q(0x13), q(0x14), q(0x15), q(0x16), q(0x17),\
+	q(0x18), q(0x19), q(0x1a), q(0x1b), q(0x1c), q(0x1d), q(0x1e), q(0x1f),\
+	q(0x20), q(0x21), q(0x22), q(0x23), q(0x24), q(0x25), q(0x26), q(0x27),\
+	q(0x28), q(0x29), q(0x2a), q(0x2b), q(0x2c), q(0x2d), q(0x2e), q(0x2f),\
+	q(0x30), q(0x31), q(0x32), q(0x33), q(0x34), q(0x35), q(0x36), q(0x37),\
+	q(0x38), q(0x39), q(0x3a), q(0x3b), q(0x3c), q(0x3d), q(0x3e), q(0x3f),\
+	q(0x40), q(0x41), q(0x42), q(0x43), q(0x44), q(0x45), q(0x46), q(0x47),\
+	q(0x48), q(0x49), q(0x4a), q(0x4b), q(0x4c), q(0x4d), q(0x4e), q(0x4f),\
+	q(0x50), q(0x51), q(0x52), q(0x53), q(0x54), q(0x55), q(0x56), q(0x57),\
+	q(0x58), q(0x59), q(0x5a), q(0x5b), q(0x5c), q(0x5d), q(0x5e), q(0x5f),\
+	q(0x60), q(0x61), q(0x62), q(0x63), q(0x64), q(0x65), q(0x66), q(0x67),\
+	q(0x68), q(0x69), q(0x6a), q(0x6b), q(0x6c), q(0x6d), q(0x6e), q(0x6f),\
+	q(0x70), q(0x71), q(0x72), q(0x73), q(0x74), q(0x75), q(0x76), q(0x77),\
+	q(0x78), q(0x79), q(0x7a), q(0x7b), q(0x7c), q(0x7d), q(0x7e), q(0x7f),\
+	q(0x80), q(0x81), q(0x82), q(0x83), q(0x84), q(0x85), q(0x86), q(0x87),\
+	q(0x88), q(0x89), q(0x8a), q(0x8b), q(0x8c), q(0x8d), q(0x8e), q(0x8f),\
+	q(0x90), q(0x91), q(0x92), q(0x93), q(0x94), q(0x95), q(0x96), q(0x97),\
+	q(0x98), q(0x99), q(0x9a), q(0x9b), q(0x9c), q(0x9d), q(0x9e), q(0x9f),\
+	q(0xa0), q(0xa1), q(0xa2), q(0xa3), q(0xa4), q(0xa5), q(0xa6), q(0xa7),\
+	q(0xa8), q(0xa9), q(0xaa), q(0xab), q(0xac), q(0xad), q(0xae), q(0xaf),\
+	q(0xb0), q(0xb1), q(0xb2), q(0xb3), q(0xb4), q(0xb5), q(0xb6), q(0xb7),\
+	q(0xb8), q(0xb9), q(0xba), q(0xbb), q(0xbc), q(0xbd), q(0xbe), q(0xbf),\
+	q(0xc0), q(0xc1), q(0xc2), q(0xc3), q(0xc4), q(0xc5), q(0xc6), q(0xc7),\
+	q(0xc8), q(0xc9), q(0xca), q(0xcb), q(0xcc), q(0xcd), q(0xce), q(0xcf),\
+	q(0xd0), q(0xd1), q(0xd2), q(0xd3), q(0xd4), q(0xd5), q(0xd6), q(0xd7),\
+	q(0xd8), q(0xd9), q(0xda), q(0xdb), q(0xdc), q(0xdd), q(0xde), q(0xdf),\
+	q(0xe0), q(0xe1), q(0xe2), q(0xe3), q(0xe4), q(0xe5), q(0xe6), q(0xe7),\
+	q(0xe8), q(0xe9), q(0xea), q(0xeb), q(0xec), q(0xed), q(0xee), q(0xef),\
+	q(0xf0), q(0xf1), q(0xf2), q(0xf3), q(0xf4), q(0xf5), q(0xf6), q(0xf7),\
+	q(0xf8), q(0xf9), q(0xfa), q(0xfb), q(0xfc), q(0xfd), q(0xfe), q(0xff) \
+}
+
+/*	Given the value i in 0..255 as the byte overflow when a field element
+    in GHASH is multipled by x^8, this function will return the values that
+    are generated in the lo 16-bit word of the field value by applying the
+    modular polynomial. The values lo_byte and hi_byte are returned via the
+    macro xp_fun(lo_byte, hi_byte) so that the values can be assembled into
+    memory as required by a suitable definition of this macro operating on
+    the table above
+*/
+
+#ifdef __BIG_ENDIAN
+#define xx(p,q)	0x##p##q	/* assemble in big endian order    */
+#else
+#define xx(p,q)	0x##q##p	/* assemble in little endian order */
+#endif
+
+#define xda_bbe(i) ( \
+    (i&amp;0x80?xx(43,80):0)^(i&amp;0x40?xx(21,c0):0)^ \
+    (i&amp;0x20?xx(10,e0):0)^(i&amp;0x10?xx(08,70):0)^ \
+    (i&amp;0x08?xx(04,38):0)^(i&amp;0x04?xx(02,1c):0)^ \
+    (i&amp;0x02?xx(01,0e):0)^(i&amp;0x01?xx(00,87):0) \
+)
+
+#define xda_lle(i) ( \
+    (i&amp;0x80?xx(e1,00):0)^(i&amp;0x40?xx(70,80):0)^ \
+    (i&amp;0x20?xx(38,40):0)^(i&amp;0x10?xx(1c,20):0)^ \
+    (i&amp;0x08?xx(0e,10):0)^(i&amp;0x04?xx(07,08):0)^ \
+    (i&amp;0x02?xx(03,84):0)^(i&amp;0x01?xx(01,c2):0) \
+)
+
+static const u16 gf128mul_table_lle[256] = gf128mul_dat(xda_lle);
+EXPORT_SYMBOL(gf128mul_table_lle);
+
+static const u16 gf128mul_table_bbe[256] = gf128mul_dat(xda_bbe);
+EXPORT_SYMBOL(gf128mul_table_bbe);
+
+/* These functions multiply a field element by x, by x^4 and by x^8 
+ * in the polynomial field representation. It uses 32-bit word operations 
+ * to gain speed but compensates for machine endianess and hence works
+ * correctly on both styles of machine.
+ */
+#ifdef __BIG_ENDIAN
+
+static void gf128mul_x_lle(u64 *r, const u64 *x)
+{
+	u64 _tt = gf128mul_table_lle[(x[1] &lt;&lt; 7) &amp; 0xff];
+	r[1] = (x[1] &gt;&gt; 1) | (x[0] &lt;&lt; 63);
+	r[0] = (x[0] &gt;&gt; 1) ^ (_tt &lt;&lt; 48);
+}
+
+static void gf128mul_x_bbe(u64 *r, const u64 *x)
+{
+	u64 _tt = gf128mul_tab_bbe[(x[0] &gt;&gt; 63)];
+	r[0] = (x[0] &lt;&lt; 1) | (x[1] &gt;&gt; 63);
+	r[1] = (x[1] &lt;&lt; 1) ^ _tt;
+}
+
+static void gf128mul_x8_lle(u64 *x)
+{
+	_tt = gf128mul_table_lle[x[1] &amp; 0xff];
+	x[1] = (x[1] &gt;&gt; 8) | (x[0] &lt;&lt; 56);
+	x[0] = (x[0] &gt;&gt; 8) ^ (_tt &lt;&lt; 48);
+}
+
+static void gf128mul_x8_bbe(u64 *x)
+{	
+	_tt = gf128mul_tab_bbe[x[0] &gt;&gt; 56];
+	x[0] = (x[0] &lt;&lt; 8) | (x[1] &gt;&gt; 56);
+	x[1] = (x[1] &lt;&lt; 8) ^ _tt;
+}
+
+#else
+
+#define M80X	0x8080808080808080LLU
+#define M01X	0x0101010101010101LLU
+
+static void gf128mul_x_lle(u64 r[2], const u64 x[2])
+{
+	u64  _tt = gf128mul_table_lle[(x[1] &gt;&gt; 49) &amp; 0x80];
+	r[1] =  ((x[1] &gt;&gt; 1) &amp; ~M80X) | (((x[1] &lt;&lt; 15) | (x[0] &gt;&gt; 49)) &amp; M80X);
+	r[0] = (((x[0] &gt;&gt; 1) &amp; ~M80X) |  ((x[0] &lt;&lt; 15) &amp; M80X)) ^ _tt;
+}
+
+static void gf128mul_x8_lle(u64 x[2])
+{
+	u64 _tt = gf128mul_table_lle[x[1] &gt;&gt; 56];
+	x[1] = (x[1] &lt;&lt; 8) | (x[0] &gt;&gt; 56);
+	x[0] = (x[0] &lt;&lt; 8) ^ _tt;
+}
+
+static void gf128mul_x_bbe(u64 r[2], const u64 x[2])
+{
+	u64 _tt = gf128mul_table_bbe[(x[0] &gt;&gt; 7) &amp; 0x01];
+	r[0] =  ((x[0] &lt;&lt; 1) &amp; ~M01X) | (((x[0] &gt;&gt; 15) | (x[1] &lt;&lt; 49)) &amp; M01X);
+	r[1] = (((x[1] &lt;&lt; 1) &amp; ~M01X) |  ((x[1] &gt;&gt; 15) &amp; M01X)) ^ _tt &lt;&lt; 48;
+}
+
+static void gf128mul_x8_bbe(u64 x[2])
+{
+	u64 _tt = gf128mul_table_bbe[x[0]&amp;0xff];
+	x[0] = (x[0] &gt;&gt; 8) | (x[1] &lt;&lt; 56);
+	x[1] = (x[1] &gt;&gt; 8) ^ (_tt &lt;&lt; 48);
+}
+
+#endif
+
+void gf128mul_lle(u64 *a, const u64* b)
+{
+	u64 r[GF128MUL_BYTES &gt;&gt; 3], p[8][GF128MUL_BYTES &gt;&gt; 3];
+	int i;
+
+	b128ops_mov(p[0], b);
+	for(i = 0; i &lt; 7; ++i) gf128mul_x_lle(p[i+1], p[i]);
+
+	memset(r, 0, GF128MUL_BYTES);
+	for(i = 0; i &lt; 16; ++i) {
+		u8 ch = ((u8*)a)[15-i];
+		if(i) gf128mul_x8_lle(r);
+
+		if(ch&amp;0x80) b128ops_xor(r, p[0]);
+		if(ch&amp;0x40) b128ops_xor(r, p[1]);
+		if(ch&amp;0x20) b128ops_xor(r, p[2]);
+		if(ch&amp;0x10) b128ops_xor(r, p[3]);
+		if(ch&amp;0x08) b128ops_xor(r, p[4]);
+		if(ch&amp;0x04) b128ops_xor(r, p[5]);
+		if(ch&amp;0x02) b128ops_xor(r, p[6]);
+		if(ch&amp;0x01) b128ops_xor(r, p[7]);
+	}
+	b128ops_mov(a, r);
+}
+EXPORT_SYMBOL(gf128mul_lle);
+
+void gf128mul_bbe(u64 *a, const u64* b)
+{
+	u64 r[GF128MUL_BYTES &gt;&gt; 3], p[8][GF128MUL_BYTES &gt;&gt; 3];
+	int i;
+	b128ops_mov(p[0], b);
+	for(i = 0; i &lt; 7; ++i) gf128mul_x_bbe(p[i+1], p[i]);
+	
+	memset(r, 0, GF128MUL_BYTES);
+	for(i = 0; i &lt; 16; ++i) {
+		u8 ch = ((u8*)a)[i];
+		if(i) gf128mul_x8_bbe(r);
+
+		if(ch&amp;0x80) b128ops_xor(r, p[7]);
+		if(ch&amp;0x40) b128ops_xor(r, p[6]);
+		if(ch&amp;0x20) b128ops_xor(r, p[5]);
+		if(ch&amp;0x10) b128ops_xor(r, p[4]);
+		if(ch&amp;0x08) b128ops_xor(r, p[3]);
+		if(ch&amp;0x04) b128ops_xor(r, p[2]);
+		if(ch&amp;0x02) b128ops_xor(r, p[1]);
+		if(ch&amp;0x01) b128ops_xor(r, p[0]);
+	}
+	b128ops_mov(a, r);
+}
+EXPORT_SYMBOL(gf128mul_bbe);
+
+/*      This version uses 64k bytes of table space on the stack.
+    A 16 byte buffer has to be multiplied by a 16 byte key
+    value in GF(128).  If we consider a GF(128) value in
+    the buffer's lowest byte, we can construct a table of
+    the 256 16 byte values that result from the 256 values
+    of this byte.  This requires 4096 bytes. But we also
+    need tables for each of the 16 higher bytes in the
+    buffer as well, which makes 64 kbytes in total.
+*/
+/* additional explanation
+ * t[0][BYTE] contains g*BYTE
+ * t[1][BYTE] contains g*x^8*BYTE
+ *  ..
+ * t[15][BYTE] contains g*x^120*BYTE */
+void gf128mul_init_64k_lle(struct gf128mul_64k *t, const u64 *g)
+{
+	int i, j, k;
+
+	memset(t-&gt;t, 0, 16*256*GF128MUL_BYTES);
+	for (i = 0; i &lt; GF128MUL_BYTES; ++i) {
+        	if (!i) {
+			b128ops_mov(t-&gt;t[0][128], g);
+			for (j = 64; j &gt; 0; j &gt;&gt;= 1) {
+				gf128mul_x_lle(t-&gt;t[0][j], t-&gt;t[0][j + j]);
+			}			
+        	} else for (j = 128; j &gt; 0; j &gt;&gt;= 1) {
+			b128ops_mov(t-&gt;t[i][j], t-&gt;t[i - 1][j]);
+			gf128mul_x8_lle(t-&gt;t[i][j]);
+		}
+
+		for (j = 2; j &lt; 256; j += j) for(k = 1; k &lt; j; ++k) {
+			t-&gt;t[i][j+k][0] = t-&gt;t[i][j][0]^t-&gt;t[i][k][0];
+			t-&gt;t[i][j+k][1] = t-&gt;t[i][j][1]^t-&gt;t[i][k][1];
+		}
+	}
+}
+EXPORT_SYMBOL(gf128mul_init_64k_lle);
+
+void gf128mul_init_64k_bbe(struct gf128mul_64k *t, const u64 *g)
+{
+	int i, j, k;
+
+	memset(t-&gt;t, 0, 16*256*GF128MUL_BYTES);
+	for (i = 0; i &lt; GF128MUL_BYTES; ++i) {
+        	if (!i) {
+			b128ops_mov(t-&gt;t[0][1], g);
+			for (j = 1; j &lt;= 64; j &lt;&lt;= 1) {
+				gf128mul_x_bbe(t-&gt;t[0][j + j], t-&gt;t[0][j]);
+			}			
+        	} else for (j = 128; j &gt; 0; j &gt;&gt;= 1) {
+			b128ops_mov(t-&gt;t[i][j], t-&gt;t[i - 1][j]);
+			gf128mul_x8_bbe(t-&gt;t[i][j]);
+		}
+
+		for (j = 2; j &lt; 256; j += j) for(k = 1; k &lt; j; ++k) {
+			t-&gt;t[i][j+k][0] = t-&gt;t[i][j][0]^t-&gt;t[i][k][0];
+			t-&gt;t[i][j+k][1] = t-&gt;t[i][j][1]^t-&gt;t[i][k][1];
+		}
+	}
+}
+EXPORT_SYMBOL(gf128mul_init_64k_bbe);
+
+void gf128mul_64k_lle(u64 a[], struct gf128mul_64k *t, u64 *r)
+{
+        int i;
+        b128ops_mov(r, t-&gt;t[0][((u8*)a)[0]]);
+        for (i = 1; i &lt; GF128MUL_BYTES; ++i) {
+                b128ops_xor(r, t-&gt;t[i][((u8*)a)[i]]);
+        }
+        b128ops_mov(a, r);
+}
+EXPORT_SYMBOL(gf128mul_64k_lle); 
+
+void gf128mul_64k_bbe(u64 a[], struct gf128mul_64k *t, u64 *r)
+{
+        int i;
+        b128ops_mov(r, t-&gt;t[0][((u8*)a)[15]]);
+        for (i = 1; i &lt; GF128MUL_BYTES; ++i) {
+                b128ops_xor(r, t-&gt;t[i][((u8*)a)[15 - i]]);
+        }
+        b128ops_mov(a, r);
+}
+EXPORT_SYMBOL(gf128mul_64k_bbe); 
+
+/*      This version uses 4k bytes of table space on the stack.
+    A 16 byte buffer has to be multiplied by a 16 byte key
+    value in GF(128).  If we consider a GF(128) value in a
+    single byte, we can construct a table of the 256 16 byte
+    values that result from the 256 values of this byte.
+    This requires 4096 bytes. If we take the highest byte in
+    the buffer and use this table to get the result, we then
+    have to multiply by x^120 to get the final value. For the
+    next highest byte the result has to be multiplied by x^112
+    and so on. But we can do this by accumulating the result
+    in an accumulator starting with the result for the top
+    byte.  We repeatedly multiply the accumulator value by
+    x^8 and then add in (i.e. xor) the 16 bytes of the next
+    lower byte in the buffer, stopping when we reach the
+    lowest byte. This requires a 4096 byte table.
+*/
+void gf128mul_init_4k_lle(struct gf128mul_4k *t, const u64 *g)
+{
+	int j, k;
+
+	memset(t, 0, 256*GF128MUL_BYTES);
+	b128ops_mov(t-&gt;t[128], g);
+	for (j = 64; j &gt; 0; j &gt;&gt;= 1) gf128mul_x_lle(t-&gt;t[j], t-&gt;t[j+j]);
+
+	for (j = 2; j &lt; 256; j += j) for (k = 1; k &lt; j; ++k) {
+		t-&gt;t[j + k][0] = t-&gt;t[j][0] ^ t-&gt;t[k][0];
+		t-&gt;t[j + k][1] = t-&gt;t[j][1] ^ t-&gt;t[k][1];
+        }
+}
+EXPORT_SYMBOL(gf128mul_init_4k_lle);
+
+void gf128mul_init_4k_bbe(struct gf128mul_4k *t, const u64 *g)
+{
+	int j, k;
+
+	memset(t, 0, 256*GF128MUL_BYTES);
+	b128ops_mov(t-&gt;t[1], g);
+	for (j = 1; j &lt;= 64; j &lt;&lt;= 1) gf128mul_x_bbe(t-&gt;t[j + j], t-&gt;t[j]);
+
+	for (j = 2; j &lt; 256; j += j) for (k = 1; k &lt; j; ++k) {
+		t-&gt;t[j + k][0] = t-&gt;t[j][0] ^ t-&gt;t[k][0];
+		t-&gt;t[j + k][1] = t-&gt;t[j][1] ^ t-&gt;t[k][1];
+        }
+}
+EXPORT_SYMBOL(gf128mul_init_4k_bbe);
+
+void gf128mul_4k_lle(u64 *a, struct gf128mul_4k *t, u64 *r)
+{
+        int i = 15;
+        b128ops_mov(r, t-&gt;t[((u8*)a)[15]]);
+        while(i--) {
+		gf128mul_x8_lle(r);
+		b128ops_xor(r, t-&gt;t[((u8*)a)[i]]);
+        }
+        b128ops_mov(a, r);
+}
+EXPORT_SYMBOL(gf128mul_4k_lle);
+
+void gf128mul_4k_bbe(u64 *a, struct gf128mul_4k *t, u64 *r)
+{
+        int i = 0;
+        b128ops_mov(r, t-&gt;t[((u8*)a)[0]]);
+        while(++i &lt; 16) {
+		gf128mul_x8_bbe(r);
+		b128ops_xor(r, t-&gt;t[((u8*)a)[i]]);
+        }
+        b128ops_mov(a, r);
+}
+EXPORT_SYMBOL(gf128mul_4k_bbe);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("functions for multiplying elements of GF(2^128)");
diff --git a/crypto/gf128mul.h b/crypto/gf128mul.h
new file mode 100644
index 0000000..bbaae1f
--- /dev/null
+++ b/crypto/gf128mul.h
@@ -0,0 +1,196 @@
+/* gf128mul.h - GF(2^128) multiplication functions
+ * 
+ * Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.
+ * Copyright (c) 2006 Rik Snel &lt;rsnel@cube.dyndns.org&gt;
+ *
+ * Based on Dr Brain Gladman's (GPL'd) work published at
+ * http://fp.gladman.plus.com/cryptography_technology/index.htm
+ * See the original copyright notice below.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+/*
+ ---------------------------------------------------------------------------
+ Copyright (c) 2003, Dr Brian Gladman, Worcester, UK.   All rights reserved.
+
+ LICENSE TERMS
+
+ The free distribution and use of this software in both source and binary
+ form is allowed (with or without changes) provided that:
+
+   1. distributions of this source code include the above copyright
+      notice, this list of conditions and the following disclaimer;
+
+   2. distributions in binary form include the above copyright
+      notice, this list of conditions and the following disclaimer
+      in the documentation and/or other associated materials;
+
+   3. the copyright holder's name is not used to endorse products
+      built using this software without specific written permission.
+
+ ALTERNATIVELY, provided that this notice is retained in full, this product
+ may be distributed under the terms of the GNU General Public License (GPL),
+ in which case the provisions of the GPL apply INSTEAD OF those given above.
+
+ DISCLAIMER
+
+ This software is provided 'as is' with no explicit or implied warranties
+ in respect of its properties, including, but not limited to, correctness
+ and/or fitness for purpose.
+ ---------------------------------------------------------------------------
+ Issue Date: 31/01/2006
+
+ An implementation of field multiplication in Galois Field GF(128)
+*/
+
+#ifndef _LINUX_GF128MUL_H
+#define _LINUX_GF128MUL_H
+/* Comment by Rik:
+ * 
+ * For some background on GF(2^128) see for example: http://-
+ * csrc.nist.gov/CryptoToolkit/modes/proposedmodes/gcm/gcm-revised-spec.pdf 
+ * 
+ * The elements of GF(2^128) := GF(2)[X]/(X^128-X^7-X^2-X^1-1) can
+ * be mapped to computer memory in a variety of ways. Let's examine
+ * three common cases 
+ *
+ * Take a look at the 16 binary octets below in memory order. The msb's 
+ * are left and the lsb's are right. char b[16] is an array and b[0] is 
+ * the first octet.
+ *
+ * 80000000 00000000 00000000 00000000 .... 00000000 00000000 00000000
+ *   b[0]     b[1]     b[2]     b[3]          b[13]    b[14]    b[15]
+ *
+ * Every bit is a coefficient of some power of X. We can store the bits
+ * in every byte in little-endian order and the bytes themselves also in
+ * little endian order. I will call this lle (little-little-endian).
+ * The above buffer represents the polynomial 1, and X^7+X^2+X^1+1 looks
+ * like 11100001 00000000 .... 00000000 = { 0xE1, 0x00, }.
+ * This format was originally implemented in gf128mul and is used
+ * in GCM (Galois/Counter mode) and in ABL (Arbitrary Block Length).
+ *
+ * Another convention says: store the bits in bigendian order and the
+ * bytes also. This is bbe (big-big-endian). Now the buffer above
+ * represents X^127. X^7+X^2+X^1+1 looks like 00000000 .... 10000111,
+ * b[15] = 0x87 and the rest is 0. LRW uses this convention and bbe
+ * is partly implemented.
+ *
+ * Both of the above formats are easy to implement on big-endian
+ * machines.
+ *
+ * EME (which is patent encumbered) uses the ble format (bits are stored 
+ * in big endian order and the bytes in little endian). The above buffer
+ * represents X^7 in this case and the primitive polynomial is b[0] = 0x87.
+ *
+ * The common machine word-size is smaller than 128 bits, so to make
+ * an efficient implementation we must split into machine word sizes.
+ * This file uses one 32bit for the moment. Machine endianness comes into
+ * play. The lle format in relation to machine endianness is discusses
+ * below by the original author of gf128mul Dr Brian Gladman.
+ *
+ * Let's look at the bbe and ble format on a little endian machine.
+ *
+ * bbe on a little endian machine u32 x[4]:
+ *
+ *  MS            x[0]           LS  MS            x[1]		  LS
+ *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+ *  103..96 111.104 119.112 127.120  71...64 79...72 87...80 95...88
+ *
+ *  MS            x[2]           LS  MS            x[3]		  LS
+ *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+ *  39...32 47...40 55...48 63...56  07...00 15...08 23...16 31...24
+ *
+ * ble on a little endian machine
+ *
+ *  MS            x[0]           LS  MS            x[1]		  LS
+ *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+ *  31...24 23...16 15...08 07...00  63...56 55...48 47...40 39...32
+ *
+ *  MS            x[2]           LS  MS            x[3]		  LS
+ *  ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+ *  95...88 87...80 79...72 71...64  127.120 199.112 111.104 103..96
+ *
+ * Multiplications in GF(2^128) are mostly bit-shifts, so you see why
+ * ble (and lbe also) are easier to implement on a little-endian
+ * machine than om a big-endian machine. The converse holds for bbe 
+ * and lle.
+ *
+ * Note: to have good alignment, it seems to me that it is sufficient
+ * to keep elements of GF(2^128) in type u64[2]. On 32-bit wordsize
+ * machines this will automatically aligned to wordsize and on a 64-bit
+ * machine also.
+ */
+/*	Multiply a GF128 field element by x. Field elements are held in arrays
+    of bytes in which field bits 8n..8n + 7 are held in byte[n], with lower
+    indexed bits placed in the more numerically significant bit positions
+    within bytes.
+
+    On little endian machines the bit indexes translate into the bit
+    positions within four 32-bit words in the following way
+
+    MS            x[0]           LS  MS            x[1]		  LS
+    ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+    24...31 16...23 08...15 00...07  56...63 48...55 40...47 32...39
+
+    MS            x[2]           LS  MS            x[3]		  LS
+    ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+    88...95 80...87 72...79 64...71  120.127 112.119 104.111 96..103
+
+    On big endian machines the bit indexes translate into the bit
+    positions within four 32-bit words in the following way
+
+    MS            x[0]           LS  MS            x[1]		  LS
+    ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+    00...07 08...15 16...23 24...31  32...39 40...47 48...55 56...63
+
+    MS            x[2]           LS  MS            x[3]		  LS
+    ms   ls ms   ls ms   ls ms   ls  ms   ls ms   ls ms   ls ms   ls
+    64...71 72...79 80...87 88...95  96..103 104.111 112.119 120.127
+*/
+
+#define GF128MUL_BYTES	16
+
+/*	A slow generic version of gf_mul, implemented for lle and bbe
+ * 	It multiplies a and b and puts the result in a */
+void gf128mul_lle(u64 *a, const u64* b);
+
+void gf128mul_bbe(u64 *a, const u64* b);
+
+
+/* 64k table optimization, implemented for lle and bbe */
+
+struct gf128mul_64k {
+	u64 t[16][256][GF128MUL_BYTES &gt;&gt; 3];
+};
+
+/* first initialize with the constant factor with which you 
+ * want to multiply and then call gf128_64k_lle with the other
+ * factor in the first argument, the table in the second and a
+ * scratch register in the third. Afterwards *a = *r. */
+void gf128mul_init_64k_lle(struct gf128mul_64k *t, const u64 *g);
+
+void gf128mul_init_64k_bbe(struct gf128mul_64k *t, const u64 *g);
+
+void gf128mul_64k_lle(u64 *a, struct gf128mul_64k *t, u64 *r);
+
+void gf128mul_64k_bbe(u64 *a, struct gf128mul_64k *t, u64 *r);
+
+
+/* 4k table optimization */
+
+struct gf128mul_4k {
+	u64 t[256][GF128MUL_BYTES &gt;&gt; 3];
+};
+
+void gf128mul_init_4k_lle(struct gf128mul_4k *t, const u64 *g);
+
+void gf128mul_init_4k_bbe(struct gf128mul_4k *t, const u64 *g);
+
+void gf128mul_4k_lle(u64 *a, struct gf128mul_4k *t, u64 *r);
+
+void gf128mul_4k_bbe(u64 *a, struct gf128mul_4k *t, u64 *r);
+
+#endif /* _LINUX_GF128MUL_H */
-- 
1.4.1.1

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060831123935</emailId><senderName>Rik Snel</senderName><senderEmail>rsnel@cube.dyndns.org</senderEmail><timestampReceived>2006-08-31 12:39:35-0400</timestampReceived><subject>[PATCH 5/6] crypto: LRW, Liskov Rivest Wagner, a tweakable narrow block cipher mode</subject><body>

Main module, this implements the Liskov Rivest Wagner block cipher mode
in the new blockcipher API. The implementation is based on ecb.c. The
first iteration of the blockcipher_walk loop is unrolled to give the
first narrow block special treatment.

The LRW-32-AES specification I used can be found at:

http://grouper.ieee.org/groups/1619/email/pdf00017.pdf

It implements the optimization specified as optional in the
specification, and in addition it uses optimized multiplication
routines from gf128mul.c.

Since gf128mul.[ch] is not tested on bigendian, this cipher mode
may currently fail badly on bigendian machines.

Signed-off-by: Rik Snel &lt;rsnel@cube.dyndns.org&gt;
---
 crypto/Kconfig  |   13 ++
 crypto/Makefile |    1 
 crypto/lrw.c    |  297 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 311 insertions(+), 0 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
index 6b23c20..dfdfe08 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -156,6 +156,19 @@ config CRYPTO_CBC
 	  CBC: Cipher Block Chaining mode
 	  This block cipher algorithm is required for IPSec.
 
+config CRYPTO_LRW
+	tristate "LRW support (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_GF128MUL
+	default n
+	help
+	  LRW: Liskov Rivest Wagner, a tweakable, non malleable, non movable
+	  narrow block cipher mode. Use it with cipher specification string
+	  aes-lrw-benbi, the key must be 256, 320 or 384. The first 128, 192
+	  or 256 bits in the key are used for AES and the rest is used to tie
+	  each cipher block to its logical position.
+
 config CRYPTO_DES
 	tristate "DES and Triple DES EDE cipher algorithms"
 	select CRYPTO_ALGAPI
diff --git a/crypto/Makefile b/crypto/Makefile
index bf0406b..e2e57be 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_CRYPTO_TGR192) += tgr192.o
 obj-$(CONFIG_CRYPTO_GF128MUL) += gf128mul.o
 obj-$(CONFIG_CRYPTO_ECB) += ecb.o
 obj-$(CONFIG_CRYPTO_CBC) += cbc.o
+obj-$(CONFIG_CRYPTO_LRW) += lrw.o
 obj-$(CONFIG_CRYPTO_DES) += des.o
 obj-$(CONFIG_CRYPTO_BLOWFISH) += blowfish.o
 obj-$(CONFIG_CRYPTO_TWOFISH) += twofish.o
diff --git a/crypto/lrw.c b/crypto/lrw.c
new file mode 100644
index 0000000..9c7324c
--- /dev/null
+++ b/crypto/lrw.c
@@ -0,0 +1,297 @@
+/* LRW: as defined by Cyril Guyot in
+ *	http://grouper.ieee.org/groups/1619/email/pdf00017.pdf
+ *
+ * Copyright (c) 2006 Rik Snel &lt;rsnel@cube.dyndns.org&gt;
+ *
+ * Based om ecb.c
+ * Copyright (c) 2006 Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+/* This implementation is checked against the test vectors in the above 
+ * document and by a test vector provided by Ken Buchanan at
+ * http://www.mail-archive.com/stds-p1619@listserv.ieee.org/msg00173.html 
+ *
+ * The vectors can be found in Documentation/crypto they are in the form
+ * of a script and can therefore easily be checked, just run lrw-32-aes
+ * with sufficient permissions after reading it and also testvector.fun */
+#include &lt;crypto/algapi.h&gt;
+#include &lt;linux/err.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include &lt;linux/slab.h&gt;
+
+#include "b128ops.h"
+#include "gf128mul.h"
+
+struct priv {
+	struct crypto_cipher *child;
+	/* optimizes multiplying a random (non incrementing, as at the 
+	 * start of a new sector) value with key2, we could also have 
+	 * used 4k optimization tables or no optimization at all. In the 
+	 * latter case we would have to store key2 here */
+	struct gf128mul_64k table;	
+	/* stores:
+	 *  key2*{ 0,0,...0,0,0,0,1 }, key2*{ 0,0,...0,0,0,1,1 },
+	 *  key2*{ 0,0,...0,0,1,1,1 }, key2*{ 0,0,...0,1,1,1,1 }
+	 *  key2*{ 0,0,...1,1,1,1,1 }, etc 
+	 * needed for optimized multiplication of incrementing values
+	 * with key2 */
+	u64 mulinc[128][GF128MUL_BYTES &gt;&gt; 3]; 
+};
+
+static inline void setbit128(void *b, int bit)
+{
+	int index = 15 - bit/8;
+	((u8*)b)[index] |= 1&lt;&lt;(bit%8);
+}
+
+static int setkey(struct crypto_tfm *parent, const u8 *key,
+			     unsigned int keylen)
+{
+	struct priv *ctx = crypto_tfm_ctx(parent);
+	struct crypto_cipher *child = ctx-&gt;child;
+	int err, i;
+	u64 tmp[2] = { 0, }, scratch[2];
+	int bsize = crypto_cipher_blocksize(child);
+
+	crypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
+	crypto_cipher_set_flags(child, crypto_tfm_get_flags(parent) &amp;
+				       CRYPTO_TFM_REQ_MASK);
+	if ((err = crypto_cipher_setkey(child, key, keylen - bsize))) 
+		return err;
+	crypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &amp;
+				     CRYPTO_TFM_RES_MASK);
+
+
+	/* initialize multiplication table for Key2 */
+	gf128mul_init_64k_bbe(&amp;ctx-&gt;table, (u64*)(key + keylen - bsize));
+
+	/* initialize optimization table */
+	for (i = 0; i &lt; 128; i++) {
+		setbit128(tmp, i);
+		b128ops_mov(ctx-&gt;mulinc[i], tmp);
+		gf128mul_64k_bbe(ctx-&gt;mulinc[i], &amp;ctx-&gt;table, scratch);
+	}
+
+	return 0;
+}
+
+struct sinfo {
+	u64 b1[2], b2[2];
+	struct crypto_tfm *tfm;
+	void (*fn)(struct crypto_tfm*, u8*, const u8*);
+};
+
+static inline void inc(u64 *iv)
+{
+	if (!(iv[1] = cpu_to_be64(be64_to_cpu(iv[1]) + 1)))
+		iv[0] = cpu_to_be64(be64_to_cpu(iv[0]) + 1);
+}
+
+static inline void round(struct sinfo *s, u8 *dst, const u8 *src)
+{
+	b128ops_xor(s-&gt;b2, src);	/* PP &lt;- T xor P */
+	s-&gt;fn(s-&gt;tfm, dst, (u8*)s-&gt;b2);	/* CC &lt;- E(Key2,PP) */
+	b128ops_xor(dst, s-&gt;b1);	/* C &lt;- T xor CC */
+}
+
+/* this returns the number of consequative 1 bits 
+ * starting from the right in i */
+static inline int get_index8(u8 i) 
+{
+	int j = 1;
+
+	if (i&amp;1) {
+		while ((i &gt;&gt;= 1)&amp;1) j++;
+		return j;
+	}
+
+	return 0;
+}
+
+/* this returns the number of consequative 1 bits starting
+ * from the right, get_index128(00 00 00 00 00 00 ... 00 00 10 FB) = 2 */
+static inline int get_index128(u8 *block)
+{
+	int inc, ret = 0, len = 16;
+	while ((inc = get_index8(block[--len])) == 8) ret += 8;
+	return ret + inc;
+}
+
+static int crypt(struct blkcipher_desc *d,
+			    struct scatterlist *dst,
+			    struct scatterlist *src,
+			    unsigned int nbytes, struct priv *ctx,
+			    void (*fn)(struct crypto_tfm*, u8*, const u8*))
+{
+	struct blkcipher_walk w;
+	int err;
+	unsigned int avail;
+	const int bs = crypto_cipher_blocksize(ctx-&gt;child);
+	u8 *wsrc, *wdst;
+	struct sinfo s = { 
+		.tfm = crypto_cipher_tfm(ctx-&gt;child), 
+		.fn = fn
+	};
+
+	blkcipher_walk_init(&amp;w, dst, src, nbytes);
+
+	/* start of the loop unrolled to be able to
+	 * handle the first block diffently from the others */
+	if ((err = blkcipher_walk_virt(d, &amp;w))) return err;
+
+	wsrc = w.src.virt.addr;
+	wdst = w.dst.virt.addr;
+
+	/* calculate first value of T */
+	b128ops_mov(s.b1, w.iv);
+	gf128mul_64k_bbe(s.b1, &amp;ctx-&gt;table, s.b2); /* T &lt;- I*Key2 */
+
+	round(&amp;s, wdst, wsrc);
+	
+	while ((avail = w.nbytes)) {
+		while ((avail -= bs) &gt;= bs) {
+			wsrc += bs;
+			wdst += bs;
+
+			/* old T is available in s.b1; new one
+			 * must be made available in b1 and b2 */
+
+			/* T &lt;- I*Key2, using the optimization
+			 * discussed in the specification */
+			b128ops_xor(s.b1, ctx-&gt;mulinc[get_index128(w.iv)]);
+			inc((u64*)w.iv);
+			b128ops_mov(s.b2, s.b1);	
+
+			round(&amp;s, wdst, wsrc);
+		}
+
+		if ((err = blkcipher_walk_done(d, &amp;w, avail))) return err;
+
+		wsrc = w.src.virt.addr;
+		wdst = w.dst.virt.addr;
+	}
+	return err;
+}
+
+static int encrypt(struct blkcipher_desc *desc, struct scatterlist *dst, 
+		struct scatterlist *src, unsigned int nbytes)
+{
+	struct priv *ctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	return crypt(desc, dst, src, nbytes, ctx,
+			crypto_cipher_alg(ctx-&gt;child)-&gt;cia_encrypt);
+}
+
+static int decrypt(struct blkcipher_desc *desc, struct scatterlist *dst, 
+		struct scatterlist *src, unsigned int nbytes)
+{
+	struct priv *ctx = crypto_blkcipher_ctx(desc-&gt;tfm);
+	return crypt(desc, dst, src, nbytes, ctx,
+			crypto_cipher_alg(ctx-&gt;child)-&gt;cia_decrypt);
+}
+
+static int init_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_instance *inst = (void *)tfm-&gt;__crt_alg;
+	struct crypto_spawn *spawn = crypto_instance_ctx(inst);
+	struct priv *ctx = crypto_tfm_ctx(tfm);
+	u32 *flags = &amp;tfm-&gt;crt_flags;
+
+	tfm = crypto_spawn_tfm(spawn);
+	if (IS_ERR(tfm))
+		return PTR_ERR(tfm);
+	
+	if (crypto_tfm_alg_blocksize(tfm) != 16) {
+		*flags |= CRYPTO_TFM_RES_BAD_BLOCK_LEN;
+		return -EINVAL;
+	}
+
+	ctx-&gt;child = crypto_cipher_cast(tfm);
+	return 0;
+}
+
+static void exit_tfm(struct crypto_tfm *tfm)
+{
+	struct priv *ctx = crypto_tfm_ctx(tfm);
+	crypto_free_cipher(ctx-&gt;child);
+}
+
+static struct crypto_instance *alloc(void *param, unsigned int len)
+{
+	struct crypto_instance *inst;
+	struct crypto_alg *alg;
+
+	alg = crypto_get_attr_alg(param, len, CRYPTO_ALG_TYPE_CIPHER,
+				  CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_ASYNC);
+	if (IS_ERR(alg))
+		return ERR_PTR(PTR_ERR(alg));
+
+	inst = crypto_alloc_instance("lrw", alg);
+	if (IS_ERR(inst))
+		goto out_put_alg;
+
+	inst-&gt;alg.cra_flags = CRYPTO_ALG_TYPE_BLKCIPHER;
+	inst-&gt;alg.cra_priority = alg-&gt;cra_priority;
+	inst-&gt;alg.cra_blocksize = alg-&gt;cra_blocksize;
+
+	if (alg-&gt;cra_alignmask &lt; 7) inst-&gt;alg.cra_alignmask = 7;
+	else inst-&gt;alg.cra_alignmask = alg-&gt;cra_alignmask;
+	inst-&gt;alg.cra_type = &amp;crypto_blkcipher_type;
+
+	if (!(alg-&gt;cra_blocksize % 4))
+		inst-&gt;alg.cra_alignmask |= 3;
+	inst-&gt;alg.cra_blkcipher.ivsize = alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_blkcipher.min_keysize = 
+		alg-&gt;cra_cipher.cia_min_keysize + alg-&gt;cra_blocksize;
+	inst-&gt;alg.cra_blkcipher.max_keysize = 
+		alg-&gt;cra_cipher.cia_max_keysize + alg-&gt;cra_blocksize;
+
+	inst-&gt;alg.cra_ctxsize = sizeof(struct priv);
+
+	inst-&gt;alg.cra_init = init_tfm;
+	inst-&gt;alg.cra_exit = exit_tfm;
+
+	inst-&gt;alg.cra_blkcipher.setkey = setkey;
+	inst-&gt;alg.cra_blkcipher.encrypt = encrypt;
+	inst-&gt;alg.cra_blkcipher.decrypt = decrypt;
+
+out_put_alg:
+	crypto_mod_put(alg);
+	return inst;
+}
+
+static void free(struct crypto_instance *inst)
+{
+	crypto_drop_spawn(crypto_instance_ctx(inst));
+	kfree(inst);
+}
+
+static struct crypto_template crypto_tmpl = {
+	.name = "lrw",
+	.alloc = alloc,
+	.free = free,
+	.module = THIS_MODULE,
+};
+
+static int __init crypto_module_init(void)
+{
+	return crypto_register_template(&amp;crypto_tmpl);
+}
+
+static void __exit crypto_module_exit(void)
+{
+	crypto_unregister_template(&amp;crypto_tmpl);
+}
+
+module_init(crypto_module_init);
+module_exit(crypto_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("LRW block cipher mode");
-- 
1.4.1.1

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060831123936</emailId><senderName>Rik Snel</senderName><senderEmail>rsnel@cube.dyndns.org</senderEmail><timestampReceived>2006-08-31 12:39:36-0400</timestampReceived><subject>[PATCH 6/6] crypto: a simple way of storing and checking test vectors, LRW vectors included</subject><body>

Test vectors for LRW and a simple way of checking them. For your convenience
and/or for real inclusion.

Signed-off-by: Rik Snel &lt;rsnel@cube.dyndns.org&gt;
---
 Documentation/crypto/README.testvector |    7 ++
 Documentation/crypto/lrw-32-aes        |  113 ++++++++++++++++++++++++++++++++
 Documentation/crypto/testvector.fun    |   57 ++++++++++++++++
 3 files changed, 177 insertions(+), 0 deletions(-)

diff --git a/Documentation/crypto/README.testvector b/Documentation/crypto/README.testvector
new file mode 100644
index 0000000..2d4a0f0
--- /dev/null
+++ b/Documentation/crypto/README.testvector
@@ -0,0 +1,7 @@
+How to check the testvectors included in ./lrw-32-aes?
+
+Simply execute them; lrw-32-aes is a bash script that calls some functions
+in testvector.fun. Tools like dm-setup and some hex utitities will be used 
+to check them through the usual kernel interface. You can add testvectors of
+other modes in an analogous manner.
+
diff --git a/Documentation/crypto/lrw-32-aes b/Documentation/crypto/lrw-32-aes
new file mode 100644
index 0000000..35de311
--- /dev/null
+++ b/Documentation/crypto/lrw-32-aes
@@ -0,0 +1,113 @@
+#!/bin/bash
+# you need losetup, dmsetup, xxd, bc
+
+# change this if you need
+LOOP=/dev/loop0
+MAPPER=crypt0
+
+# we need to import some important functions
+. testvector.fun
+
+#lrw specific options, some need to be calculated for each vector
+function special { 
+	MODE=aes-lrw-benbi
+	KEY=$AESKEY$TWEAKKEY
+	IV_OFFSET=$(echo "ibase=16; ($TWEAKLOCATION-1)/20" | bc)
+	BOFFSET=$(echo "ibase=16; ($TWEAKLOCATION-1)%20" | bc)
+}
+
+NAME="LRW-32-AES 1"
+AESKEY=4562ac25f828176d4c268414b5680185
+TWEAKKEY=258e2a05e73e9d03ee5a830ccc094c87
+PLAINTEXT=30313233343536373839414243444546
+TWEAKLOCATION=00000000000000000000000000000001
+CIPHERTEXT=f1b273cd65a3df5fe95d489254634eb8
+check
+
+NAME="LRW-32-AES 2"
+AESKEY=59704714f557478cd779e80f54887944
+TWEAKKEY=0d48f0b7b15a53ea1caa6b29c2cafbaf
+PLAINTEXT=30313233343536373839414243444546
+TWEAKLOCATION=00000000000000000000000000000002
+CIPHERTEXT=00c82bae95bbcde5274f0769b260e136
+check
+
+NAME="LRW-32-AES 3"
+AESKEY=d82a9134b26a565030fe69e2377f9847
+TWEAKKEY=cdf90b160c648fb6b00d0d1bae85871f
+PLAINTEXT=30313233343536373839414243444546
+TWEAKLOCATION=00000000000000000000000200000000
+CIPHERTEXT=76322183ed8ff182f9596203690e5e01
+check
+
+NAME="LRW-32-AES 4"
+AESKEY=0f6aeff8d3d2bb152583f73c1f012874cac6bc354d4a6554
+TWEAKKEY=90ae61cf7baebdccade494c54a29ae70
+PLAINTEXT=30313233343536373839414243444546
+TWEAKLOCATION=00000000000000000000000000000001
+CIPHERTEXT=9c0f152f55a2d8f0d67b8f9e2822bc41
+check
+
+NAME="LRW-32-AES 5"
+AESKEY=8ad4ee102fbd81fff886ceac93c5adc6a01907c09df7bbdd
+TWEAKKEY=5213b2b7f0ff11d8d608d0cd2eb1176f
+PLAINTEXT=30313233343536373839414243444546
+TWEAKLOCATION=00000000000000000000000200000000
+CIPHERTEXT=d4276a7f14913d65c860480287e33406
+check
+
+NAME="LRW-32-AES 6"
+AESKEY=f8d476ffd646ee6c2384cb1c77d6195dfef1a9f37bbc8d21a79c21f8cb900289
+TWEAKKEY=a845348ec8c5b5f126f50e76fefd1b1e
+PLAINTEXT=30313233343536373839414243444546
+TWEAKLOCATION=00000000000000000000000000000001
+CIPHERTEXT=bd06b8e1db98899ec498e491cf1c702b
+check
+
+NAME="LRW-32-AES 7"
+AESKEY=fb7615b23d80891dd470980bc79584c8b2fb64ce6097878d17fce45a49e830b7
+TWEAKKEY=6e7817e72d5e12d46064047af12f9e0c
+PLAINTEXT=30313233343536373839414243444546
+TWEAKLOCATION=00000000000000000000000200000000
+CIPHERTEXT=5b908ec1abdd675f3d698a9553c89ce5
+check
+
+NAME="Ken Buchanan"
+AESKEY=f8d476ffd646ee6c2384cb1c77d6195dfef1a9f37bbc8d21a79c21f8cb900289
+TWEAKKEY=a845348ec8c5b5f126f50e76fefd1b1e
+TWEAKLOCATION=00000000000000000000000000000001
+PLAINTEXT=\
+0511b718abc62dac705df62294cde56c176bf61cf0f36ef850381f7149b657d6\
+8fcb8d6be3a62990fe2a6282ae6d8bf6ad1e9e205f38be04da108eeda2a487ab\
+da6bb40c75bad37cc9ac4231957cc904ebd56e32698adba615d73f4f2f666903\
+9c1f540fde1ff3654c9612ed7c9203016fbc3593acf127f1b496825a5fb0a050\
+89a48e664485ccfd331470e396b2c3d3bb545a1af974a2c52d6475ddb454e674\
+8cd39d9e86ab5153b7933e6fd04e2c40f6a82e3e9df466a5761273441a56d772\
+88cd218c4c0ffeda95e03aa6a58446cdd53e9d3ae267e6601ae2708558c21b09\
+e1d72ccaada88ff9acb30edbca2ee2b85171d93c6cf156f8ea9cf1fb0ce6b710\
+1cf8a97ce85335c1903e764a74a4212cf62c4e0f943a882e41096a337df6dd3f\
+8d23317484eb886eccb9bc2283190722a52ddfa5f380857884396a6d6a994fa5\
+15fe46b0e46ca5413cce8f426071a7750840658a82bff5437196a94d448a20be\
+fa4dbbc07d319665e775e53efd923bc955bb167ef7c28ca4401de5ef0edfe49a\
+627365fd4663253d2bafe564fea55ccf24f3b4ac64badf4bc6967d812d8d97f7\
+c5687784322bcc857496f0127761b9eb71aa82cb1cdb89c8c6b5e35c7d390724\
+da398745c02bbb01acbc2a5c7ffce8ce6d9c6fedd3c1a1d6c555a9662fe1c832\
+a65da43a9873e845a4c7a8b4f61303f6e92ec4290f84dbc421c4c2756789370a
+CIPHERTEXT=\
+1a1da930adf92f9bb61daeeff02ff85a393cbf2ab245b2231b633ccfaabecf4e\
+fae829c220682b3c2e8bf76e25bde33d6627d6afd6643ee3e8584697395107de\
+cb37bca9c05f75c30e84231d16d41c599c1a0255ab3a971ddfddc70651d770ae\
+23c68cf51ea0e582b8b2bf04a0328e68ebaf6e2d94222fce4cb559e2a22fa098\
+1a97c6d4b50059f2841472b19a6ea37fea20e7cb65773adfc8976715c22a27cc\
+1855a1240b2424af5bec68b8c8f5ba63ffed89ced53d88f325ef057c3aefebd8\
+7a320dd11e5859999025b526b0e32b6c4ca98b844f5e0150413058c56274521d\
+45246a42644f971ca866b56d79d40d48c55ff39032dddde1e4a99ffcc3525a46\
+e481849536597a6baab360adce9f9f28e0017522c44ea9625c620d00cb13e843\
+72d42d5346b5d1162218df3433f5d61cb879789794ff72134c27fccbbf0153a6\
+b4506ededfb543a459df52f97ce0116f2d148e24612ce117ccce510c198a8230\
+94d53d6a53065ebdb7ebfafd2751de851e865311539400ee2b8c082abfddae11\
+cb1ea2079a80cf629b09dc953c968eb109bde4ebdbca707a9efa3118453c2133\
+b0b32beaf3712de103ad1b48d46727f062e43dfb9b0876e7dd2b0139045a587a\
+f71190ecbd515c326bd73539026bf2a6d00d07e106c45b7de46ad7ee151f83b4\
+a3a75ec390b7efd3b74ff8924cb73c29cd7e2b5d43ea42e7743f7d588875de3e
+check
diff --git a/Documentation/crypto/testvector.fun b/Documentation/crypto/testvector.fun
new file mode 100644
index 0000000..34af646
--- /dev/null
+++ b/Documentation/crypto/testvector.fun
@@ -0,0 +1,57 @@
+function sig_handler_EXIT {
+	if [ -b /dev/mapper/$MAPPER ]; then dmsetup remove $MAPPER; fi
+	losetup -d $LOOP
+	rm $IMAGE
+	exit $1 
+}
+
+function setup {
+	set -e
+	IMAGE=`mktemp`
+	trap sig_handler_EXIT EXIT TERM INT QUIT
+	dd if=/dev/zero of=$IMAGE count=1 bs=512 2&gt; /dev/null
+	losetup $LOOP $IMAGE
+}
+
+function check_encrypt {
+	echo $PLAINTEXT | xxd -r -p | dd of=/dev/mapper/$MAPPER seek=$BOFFSET \
+		bs=$LEN count=1 2&gt; /dev/null
+
+	C=`dd if=$IMAGE skip=$BOFFSET bs=$LEN count=1 2&gt; \
+		/dev/null | xxd -p | tr -d '\n'`
+
+	if [ "$C" = "$CIPHERTEXT" ]; then ENC="--ENCRYPT OK--"
+	else ENC="--ENCRYPT FAILED--"; fi
+}
+
+function check_decrypt {
+	echo $CIPHERTEXT | xxd -r -p | dd of=$LOOP seek=$BOFFSET \
+		bs=$LEN count=1 2&gt; /dev/null
+
+	P=`dd if=/dev/mapper/$MAPPER skip=$BOFFSET bs=$LEN count=1 2&gt; \
+		/dev/null | xxd -p | tr -d '\n'`
+
+	if [ "$P" = "$PLAINTEXT" ]; then DEC="--DECRYPT OK--"
+	else DEC="--DECRYPT FAILED--"; fi
+}
+
+function check {
+	special
+
+	LEN=$((`echo $PLAINTEXT | wc -c`/2))
+
+	# setup mode
+	TABLE=`echo "0 1 crypt $MODE $KEY $IV_OFFSET $LOOP 0"`
+
+	echo $TABLE | dmsetup create $MAPPER
+	
+	check_encrypt
+	check_decrypt
+
+	dmsetup remove $MAPPER
+
+	echo "$NAME: $ENC $DEC"
+}
+
+setup 
+
-- 
1.4.1.1

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702233154</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-02 23:31:54-0400</timestampReceived><subject>Re: [4/13] [CRYPTO] api: Added event notification</subject><body>

On Sun, Jul 02, 2006 at 09:40:37AM -0700, David Miller wrote:
&gt; 
&gt; You're using a blocking notifier because we have all of those
&gt; semaphores and stuff to grab here anyways, right?

Yes, this is ultra-slow path (module loading/unloading, loading
an algorithm for the first time) so might as well use the pre-canned
solution.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060703102751</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-03 10:27:51-0400</timestampReceived><subject>[2/2] [CRYPTO] api: Retry when modules are removed</subject><body>

Hi:

[CRYPTO] api: Retry when modules are removed

The module loading/unloading semantics here are such that as long as
you load a replacement before unloading a module, e.g.,

modprobe md5-new
rmmod -w md5

no operations on md5 should fail.

It turns out that there are a few cases where this assumption fails
for crypto instances.  This patch addresses these cases by letting
the API retry the operations if it fails because an underlying module
has been removed.  If no replacement module is loaded, then the retry
will terminate.

More specifically, each time a crypto_mod_get fails we mark the affected
algorithm and the instances leading to this as dying.  Dying algorithms
are skipped by all further lookups.  So eventually all algorithms related
to an unloading module will be marked as dying which terminates the retry
process.

At this point a new larval would be created which will succeed if a
replacement module is available.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -26,6 +26,7 @@
 #include &lt;linux/notifier.h&gt;
 #include &lt;linux/param.h&gt;
 #include &lt;linux/rwsem.h&gt;
+#include &lt;linux/sched.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/string.h&gt;
 #include "internal.h"
@@ -70,6 +71,11 @@ static inline int crypto_is_dead(struct 
 	return alg-&gt;cra_flags &amp; CRYPTO_ALG_DEAD;
 }
 
+static inline int crypto_is_moribund(struct crypto_alg *alg)
+{
+	return alg-&gt;cra_flags &amp; (CRYPTO_ALG_DEAD | CRYPTO_ALG_DYING);
+}
+
 static inline int crypto_notify(unsigned long val, void *v)
 {
 	return blocking_notifier_call_chain(&amp;crypto_chain, val, v);
@@ -84,7 +90,7 @@ static struct crypto_alg *__crypto_alg_l
 	list_for_each_entry(q, &amp;crypto_alg_list, cra_list) {
 		int exact, fuzzy;
 
-		if (crypto_is_dead(q))
+		if (crypto_is_moribund(q))
 			continue;
 
 		if ((q-&gt;cra_flags ^ type) &amp; mask)
@@ -132,7 +138,7 @@ static struct crypto_alg *crypto_larval_
 
 	larval = kzalloc(sizeof(*larval), GFP_KERNEL);
 	if (!larval)
-		return NULL;
+		return ERR_PTR(-ENOMEM);
 
 	larval-&gt;mask = mask;
 	larval-&gt;alg.cra_flags = CRYPTO_ALG_LARVAL | type;
@@ -174,8 +180,11 @@ static struct crypto_alg *crypto_larval_
 
 	wait_for_completion_interruptible_timeout(&amp;larval-&gt;completion, 60 * HZ);
 	alg = larval-&gt;adult;
-	if (alg &amp;&amp; !crypto_mod_get(alg))
-		alg = NULL;
+	if (alg) {
+		if (!crypto_mod_get(alg))
+			alg = ERR_PTR(-EAGAIN);
+	} else
+		alg = ERR_PTR(-ENOENT);
 	crypto_mod_put(&amp;larval-&gt;alg);
 
 	return alg;
@@ -204,9 +213,6 @@ static struct crypto_alg *crypto_alg_loo
 {
 	struct crypto_alg *alg;
 
-	if (!name)
-		return NULL;
-
 	down_read(&amp;crypto_alg_sem);
 	alg = __crypto_alg_lookup(name, type, mask);
 	up_read(&amp;crypto_alg_sem);
@@ -220,6 +226,9 @@ struct crypto_alg *crypto_alg_mod_lookup
 	struct crypto_alg *larval;
 	int ok;
 
+	if (!name)
+		return ERR_PTR(-ENOENT);
+
 	mask &amp;= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
 	type &amp;= mask;
 
@@ -229,7 +238,7 @@ struct crypto_alg *crypto_alg_mod_lookup
 		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;
 
 	larval = crypto_larval_alloc(name, type, mask);
-	if (!larval || !crypto_is_larval(larval))
+	if (IS_ERR(larval) || !crypto_is_larval(larval))
 		return larval;
 
 	ok = crypto_notify(CRYPTO_MSG_ALG_REQUEST, larval);
@@ -242,7 +251,7 @@ struct crypto_alg *crypto_alg_mod_lookup
 		alg = crypto_larval_wait(larval);
 	else {
 		crypto_mod_put(larval);
-		alg = NULL;
+		alg = ERR_PTR(-ENOENT);
 	}
 	crypto_larval_kill(larval);
 	return alg;
@@ -337,10 +346,18 @@ static unsigned int crypto_ctxsize(struc
 	return len + (alg-&gt;cra_alignmask &amp; ~(crypto_tfm_ctx_alignment() - 1));
 }
 
+static void crypto_shoot_alg(struct crypto_alg *alg)
+{
+	down_write(&amp;crypto_alg_sem);
+	alg-&gt;cra_flags |= CRYPTO_ALG_DYING;
+	up_write(&amp;crypto_alg_sem);
+}
+
 static struct crypto_tfm *__crypto_alloc_tfm(struct crypto_alg *alg, u32 flags)
 {
 	struct crypto_tfm *tfm = NULL;
 	unsigned int tfm_size;
+	int err = -ENOMEM;
 
 	tfm_size = sizeof(*tfm) + crypto_ctxsize(alg, flags);
 	tfm = kzalloc(tfm_size, GFP_KERNEL);
@@ -348,15 +365,20 @@ static struct crypto_tfm *__crypto_alloc
 		goto out;
 
 	tfm-&gt;__crt_alg = alg;
-	
-	if (crypto_init_flags(tfm, flags))
+
+	err = crypto_init_flags(tfm, flags);
+	if (err)
 		goto out_free_tfm;
 		
-	if (crypto_init_ops(tfm))
+	err = crypto_init_ops(tfm);
+	if (err)
 		goto out_free_tfm;
 
-	if (alg-&gt;cra_init &amp;&amp; alg-&gt;cra_init(tfm))
+	if (alg-&gt;cra_init &amp;&amp; (err = alg-&gt;cra_init(tfm))) {
+		if (err == -EAGAIN)
+			crypto_shoot_alg(alg);
 		goto cra_init_failed;
+	}
 
 	goto out;
 
@@ -364,7 +386,7 @@ cra_init_failed:
 	crypto_exit_ops(tfm);
 out_free_tfm:
 	kfree(tfm);
-	tfm = NULL;
+	tfm = ERR_PTR(err);
 out:
 	return tfm;
 }
@@ -372,17 +394,25 @@ out:
 struct crypto_tfm *crypto_alloc_tfm(const char *name, u32 flags)
 {
 	struct crypto_tfm *tfm = NULL;
-	struct crypto_alg *alg;
+	int err;
 
-	alg = crypto_alg_mod_lookup(name, 0, 0);
-	if (!alg)
-		goto out;
+	do {
+		struct crypto_alg *alg;
 
-	tfm = __crypto_alloc_tfm(alg, flags);
-	if (!tfm)
-		crypto_mod_put(alg);
+		alg = crypto_alg_mod_lookup(name, 0, 0);
+		err = PTR_ERR(alg);
+		if (IS_ERR(alg))
+			continue;
+
+		tfm = __crypto_alloc_tfm(alg, flags);
+		err = 0;
+		if (IS_ERR(tfm)) {
+			crypto_mod_put(alg);
+			err = PTR_ERR(tfm);
+			tfm = NULL;
+		}
+	} while (err == -EAGAIN &amp;&amp; !signal_pending(current));
 
-out:
 	return tfm;
 }
 
@@ -442,7 +472,7 @@ static int crypto_check_alg(struct crypt
 static int __crypto_register_alg(struct crypto_alg *alg)
 {
 	struct crypto_alg *q;
-	int ret = -ENOENT;
+	int ret = -EAGAIN;
 
 	if (crypto_is_dead(alg))
 		goto out;
@@ -682,12 +712,12 @@ EXPORT_SYMBOL_GPL(crypto_register_instan
 int crypto_init_spawn(struct crypto_spawn *spawn, struct crypto_alg *alg,
 		      struct crypto_instance *inst)
 {
-	int err = -ENOENT;
+	int err = -EAGAIN;
 
 	spawn-&gt;inst = inst;
 
 	down_write(&amp;crypto_alg_sem);
-	if (!crypto_is_dead(alg)) {
+	if (!crypto_is_moribund(alg)) {
 		list_add(&amp;spawn-&gt;list, &amp;alg-&gt;cra_users);
 		spawn-&gt;alg = alg;
 		err = 0;
@@ -709,22 +739,25 @@ EXPORT_SYMBOL_GPL(crypto_drop_spawn);
 struct crypto_tfm *crypto_spawn_tfm(struct crypto_spawn *spawn)
 {
 	struct crypto_alg *alg;
+	struct crypto_alg *alg2;
 	struct crypto_tfm *tfm;
 
 	down_read(&amp;crypto_alg_sem);
 	alg = spawn-&gt;alg;
-	if (alg &amp;&amp; !crypto_mod_get(alg))
-		alg = NULL;
+	alg2 = alg;
+	if (alg2)
+		alg2 = crypto_mod_get(alg2);
 	up_read(&amp;crypto_alg_sem);
 
-	if (!alg)
-		return ERR_PTR(-ENOENT);
+	if (!alg2) {
+		if (alg)
+			crypto_shoot_alg(alg);
+		return ERR_PTR(-EAGAIN);
+	}
 
 	tfm = __crypto_alloc_tfm(alg, 0);
-	if (!tfm) {
+	if (IS_ERR(tfm))
 		crypto_mod_put(alg);
-		tfm = ERR_PTR(-ENOMEM);
-	}
 
 	return tfm;
 }
@@ -735,7 +768,7 @@ int crypto_alg_available(const char *nam
 	int ret = 0;
 	struct crypto_alg *alg = crypto_alg_mod_lookup(name, 0, 0);
 	
-	if (alg) {
+	if (!IS_ERR(alg)) {
 		crypto_mod_put(alg);
 		ret = 1;
 	}
diff --git a/crypto/cryptomgr.c b/crypto/cryptomgr.c
--- a/crypto/cryptomgr.c
+++ b/crypto/cryptomgr.c
@@ -17,6 +17,7 @@
 #include &lt;linux/module.h&gt;
 #include &lt;linux/notifier.h&gt;
 #include &lt;linux/rtnetlink.h&gt;
+#include &lt;linux/sched.h&gt;
 #include &lt;linux/string.h&gt;
 
 #include "internal.h"
@@ -36,6 +37,7 @@ static int cryptomgr_probe(struct crypto
 	const char *name = larval-&gt;alg.cra_name;
 	const char *p;
 	unsigned int len;
+	int err;
 
 	for (p = name; isalnum(*p) || *p == '-' || *p == '_'; p++)
 		;
@@ -64,17 +66,17 @@ static int cryptomgr_probe(struct crypto
 	memcpy(param.alg.data.name, name, len);
 	param.alg.data.name[len] = 0;
 
-	inst = tmpl-&gt;alloc(&amp;param, sizeof(param));
-	if (IS_ERR(inst))
-		inst = NULL;
-	else if (crypto_register_instance(tmpl, inst)) {
-		tmpl-&gt;free(inst);
-		inst = NULL;
-	}
+	do {
+		inst = tmpl-&gt;alloc(&amp;param, sizeof(param));
+		if (IS_ERR(inst))
+			err = PTR_ERR(inst);
+		else if ((err = crypto_register_instance(tmpl, inst)))
+			tmpl-&gt;free(inst);
+	} while (err == -EAGAIN &amp;&amp; !signal_pending(current));
 
 	crypto_tmpl_put(tmpl);
 
-	if (!inst)
+	if (err)
 		goto err;
 
 	return NOTIFY_STOP;
diff --git a/crypto/hmac.c b/crypto/hmac.c
--- a/crypto/hmac.c
+++ b/crypto/hmac.c
@@ -154,10 +154,10 @@ static struct crypto_instance *crypto_hm
 
 	inst-&gt;alg.cra_flags = CRYPTO_ALG_TYPE_DIGEST;
 
-	err = -ENOENT;
 	alg = crypto_alg_mod_lookup(alga-&gt;name, CRYPTO_ALG_TYPE_DIGEST,
 				    CRYPTO_ALG_TYPE_MASK);
-	if (!alg)
+	err = PTR_ERR(alg);
+	if (IS_ERR(alg))
 		goto err_free_inst;
 
 	err = -ENAMETOOLONG;
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -35,6 +35,7 @@
 
 #define CRYPTO_ALG_LARVAL		0x00000010
 #define CRYPTO_ALG_DEAD			0x00000020
+#define CRYPTO_ALG_DYING		0x00000040
 
 /*
  * Transform masks and values (for crt_flags).
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060704032931</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-04 03:29:31-0400</timestampReceived><subject>Re: [1/2] [CRYPTO] api: Avoid refilling larval-&gt;adult</subject><body>

On Mon, Jul 03, 2006 at 07:49:19PM -0700, David Miller wrote:
&gt; 
&gt; Would you like me to merge these 2 fixes or will you do
&gt; so directly with your crypto-2.6 tree?

I'll put them into the cryptodev-2.6 tree which'll go into mm.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060706031754</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-07-06 03:17:54-0400</timestampReceived><subject>[CRYPTO 2/4] Add missing accessors for new crypto_alg fields.</subject><body>

Add missing accessors for new crypto_alg fields.

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux-2.6.16.13-xenU/include/linux/crypto.h
===================================================================
--- linux-2.6.16.13-xenU.orig/include/linux/crypto.h
+++ linux-2.6.16.13-xenU/include/linux/crypto.h
@@ -277,6 +277,16 @@ static inline const char *crypto_tfm_alg
 	return tfm-&gt;__crt_alg-&gt;cra_name;
 }
 
+static inline const char *crypto_tfm_alg_driver_name(struct crypto_tfm *tfm)
+{
+	return tfm-&gt;__crt_alg-&gt;cra_driver_name;
+}
+
+static inline int crypto_tfm_alg_priority(struct crypto_tfm *tfm)
+{
+	return tfm-&gt;__crt_alg-&gt;cra_priority;
+}
+
 static inline const char *crypto_tfm_alg_modname(struct crypto_tfm *tfm)
 {
 	return module_name(tfm-&gt;__crt_alg-&gt;cra_module);

--


-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702142031</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-02 14:20:31-0400</timestampReceived><subject>[4/13] [CRYPTO] api: Added event notification</subject><body>

Hi:

[CRYPTO] api: Added event notification

This patch adds a notifier chain for algorithm/template registration events.
This will be used to register compound algorithms such as cbc(aes).  In
future this will also be passed onto user-space through netlink.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -22,6 +22,8 @@
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/kmod.h&gt;
+#include &lt;linux/notifier.h&gt;
+#include &lt;linux/param.h&gt;
 #include &lt;linux/rwsem.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/string.h&gt;
@@ -31,6 +33,8 @@ LIST_HEAD(crypto_alg_list);
 static LIST_HEAD(crypto_template_list);
 DECLARE_RWSEM(crypto_alg_sem);
 
+static BLOCKING_NOTIFIER_HEAD(crypto_chain);
+
 static inline struct crypto_alg *crypto_alg_get(struct crypto_alg *alg)
 {
 	atomic_inc(&amp;alg-&gt;cra_refcnt);
@@ -54,16 +58,21 @@ static void crypto_mod_put(struct crypto
 	module_put(alg-&gt;cra_module);
 }
 
-static struct crypto_alg *crypto_alg_lookup(const char *name)
+static inline int crypto_is_larval(struct crypto_alg *alg)
+{
+	return alg-&gt;cra_flags &amp; CRYPTO_ALG_LARVAL;
+}
+
+static inline int crypto_notify(unsigned long val, void *v)
+{
+	return blocking_notifier_call_chain(&amp;crypto_chain, val, v);
+}
+
+static struct crypto_alg *__crypto_alg_lookup(const char *name)
 {
 	struct crypto_alg *q, *alg = NULL;
-	int best = -1;
+	int best = -2;
 
-	if (!name)
-		return NULL;
-	
-	down_read(&amp;crypto_alg_sem);
-	
 	list_for_each_entry(q, &amp;crypto_alg_list, cra_list) {
 		int exact, fuzzy;
 
@@ -83,16 +92,130 @@ static struct crypto_alg *crypto_alg_loo
 		if (exact)
 			break;
 	}
-	
+
+	return alg;
+}
+
+static void crypto_larval_destroy(struct crypto_alg *alg)
+{
+	struct crypto_larval *larval = (void *)alg;
+
+	BUG_ON(!crypto_is_larval(alg));
+	if (larval-&gt;adult)
+		crypto_mod_put(larval-&gt;adult);
+	kfree(larval);
+}
+
+static struct crypto_alg *crypto_larval_alloc(const char *name)
+{
+	struct crypto_alg *alg;
+	struct crypto_larval *larval;
+
+	larval = kzalloc(sizeof(*larval), GFP_KERNEL);
+	if (!larval)
+		return NULL;
+
+	larval-&gt;alg.cra_flags = CRYPTO_ALG_LARVAL;
+	larval-&gt;alg.cra_priority = -1;
+	larval-&gt;alg.cra_destroy = crypto_larval_destroy;
+
+	atomic_set(&amp;larval-&gt;alg.cra_refcnt, 2);
+	strlcpy(larval-&gt;alg.cra_name, name, CRYPTO_MAX_ALG_NAME);
+	init_completion(&amp;larval-&gt;completion);
+
+	down_write(&amp;crypto_alg_sem);
+	alg = __crypto_alg_lookup(name);
+	if (!alg) {
+		alg = &amp;larval-&gt;alg;
+		list_add(&amp;alg-&gt;cra_list, &amp;crypto_alg_list);
+	}
+	up_write(&amp;crypto_alg_sem);
+
+	if (alg != &amp;larval-&gt;alg)
+		kfree(larval);
+
+	return alg;
+}
+
+static void crypto_larval_kill(struct crypto_alg *alg)
+{
+	struct crypto_larval *larval = (void *)alg;
+
+	down_write(&amp;crypto_alg_sem);
+	list_del(&amp;alg-&gt;cra_list);
+	up_write(&amp;crypto_alg_sem);
+	complete(&amp;larval-&gt;completion);
+	crypto_alg_put(alg);
+}
+
+static struct crypto_alg *crypto_larval_wait(struct crypto_alg *alg)
+{
+	struct crypto_larval *larval = (void *)alg;
+
+	wait_for_completion_interruptible_timeout(&amp;larval-&gt;completion, 60 * HZ);
+	alg = larval-&gt;adult;
+	if (alg &amp;&amp; !crypto_mod_get(alg))
+		alg = NULL;
+	crypto_mod_put(&amp;larval-&gt;alg);
+
+	return alg;
+}
+
+void crypto_larval_error(const char *name)
+{
+	struct crypto_alg *alg;
+
+	down_read(&amp;crypto_alg_sem);
+	alg = __crypto_alg_lookup(name);
+	up_read(&amp;crypto_alg_sem);
+
+	if (alg) {
+		if (crypto_is_larval(alg)) {
+			struct crypto_larval *larval = (void *)alg;
+			complete(&amp;larval-&gt;completion);
+		}
+		crypto_mod_put(alg);
+	}
+}
+EXPORT_SYMBOL_GPL(crypto_larval_error);
+
+static struct crypto_alg *crypto_alg_lookup(const char *name)
+{
+	struct crypto_alg *alg;
+
+	if (!name)
+		return NULL;
+
+	down_read(&amp;crypto_alg_sem);
+	alg = __crypto_alg_lookup(name);
 	up_read(&amp;crypto_alg_sem);
+
 	return alg;
 }
 
 /* A far more intelligent version of this is planned.  For now, just
  * try an exact match on the name of the algorithm. */
-static inline struct crypto_alg *crypto_alg_mod_lookup(const char *name)
+static struct crypto_alg *crypto_alg_mod_lookup(const char *name)
 {
-	return try_then_request_module(crypto_alg_lookup(name), name);
+	struct crypto_alg *alg;
+	struct crypto_alg *larval;
+
+	alg = try_then_request_module(crypto_alg_lookup(name), name);
+	if (alg)
+		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;
+
+	larval = crypto_larval_alloc(name);
+	if (!larval || !crypto_is_larval(larval))
+		return larval;
+
+	if (crypto_notify(CRYPTO_MSG_ALG_REQUEST, larval) == NOTIFY_STOP)
+		alg = crypto_larval_wait(larval);
+	else {
+		crypto_mod_put(larval);
+		alg = NULL;
+	}
+	crypto_larval_kill(larval);
+	return alg;
 }
 
 static int crypto_init_flags(struct crypto_tfm *tfm, u32 flags)
@@ -280,14 +403,27 @@ static int __crypto_register_alg(struct 
 	struct crypto_alg *q;
 	int ret = -EEXIST;
 
+	atomic_set(&amp;alg-&gt;cra_refcnt, 1);
 	list_for_each_entry(q, &amp;crypto_alg_list, cra_list) {
 		if (q == alg)
 			goto out;
+		if (crypto_is_larval(q) &amp;&amp;
+		    (!strcmp(alg-&gt;cra_name, q-&gt;cra_name) ||
+		     !strcmp(alg-&gt;cra_driver_name, q-&gt;cra_name))) {
+			struct crypto_larval *larval = (void *)q;
+
+			if (!crypto_mod_get(alg))
+				continue;
+			larval-&gt;adult = alg;
+			complete(&amp;larval-&gt;completion);
+		}
 	}
 	
 	list_add(&amp;alg-&gt;cra_list, &amp;crypto_alg_list);
-	atomic_set(&amp;alg-&gt;cra_refcnt, 1);
+
+	crypto_notify(CRYPTO_MSG_ALG_REGISTER, alg);
 	ret = 0;
+
 out:	
 	return ret;
 }
@@ -316,6 +452,7 @@ int crypto_unregister_alg(struct crypto_
 		list_del_init(&amp;alg-&gt;cra_list);
 		ret = 0;
 	}
+	crypto_notify(CRYPTO_MSG_ALG_UNREGISTER, alg);
 	up_write(&amp;crypto_alg_sem);
 
 	if (ret)
@@ -341,6 +478,7 @@ int crypto_register_template(struct cryp
 	}
 
 	list_add(&amp;tmpl-&gt;list, &amp;crypto_template_list);
+	crypto_notify(CRYPTO_MSG_TMPL_REGISTER, tmpl);
 	err = 0;
 out:
 	up_write(&amp;crypto_alg_sem);
@@ -363,8 +501,11 @@ void crypto_unregister_template(struct c
 	hlist_for_each_entry(inst, p, list, list) {
 		BUG_ON(list_empty(&amp;inst-&gt;alg.cra_list));
 		list_del_init(&amp;inst-&gt;alg.cra_list);
+		crypto_notify(CRYPTO_MSG_ALG_UNREGISTER, &amp;inst-&gt;alg);
 	}
 
+	crypto_notify(CRYPTO_MSG_TMPL_UNREGISTER, tmpl);
+
 	up_write(&amp;crypto_alg_sem);
 
 	hlist_for_each_entry_safe(inst, p, n, list, list) {
@@ -443,6 +584,18 @@ int crypto_alg_available(const char *nam
 	return ret;
 }
 
+int crypto_register_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&amp;crypto_chain, nb);
+}
+EXPORT_SYMBOL_GPL(crypto_register_notifier);
+
+int crypto_unregister_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&amp;crypto_chain, nb);
+}
+EXPORT_SYMBOL_GPL(crypto_unregister_notifier);
+
 static int __init init_crypto(void)
 {
 	printk(KERN_INFO "Initializing Cryptographic API\n");
diff --git a/crypto/internal.h b/crypto/internal.h
--- a/crypto/internal.h
+++ b/crypto/internal.h
@@ -12,6 +12,8 @@
  */
 #ifndef _CRYPTO_INTERNAL_H
 #define _CRYPTO_INTERNAL_H
+
+#include &lt;linux/completion.h&gt;
 #include &lt;linux/crypto.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/highmem.h&gt;
@@ -24,6 +26,17 @@
 #include &lt;linux/slab.h&gt;
 #include &lt;asm/kmap_types.h&gt;
 
+/* Crypto notification events. */
+enum {
+	CRYPTO_MSG_ALG_REQUEST,
+	CRYPTO_MSG_ALG_REGISTER,
+	CRYPTO_MSG_ALG_UNREGISTER,
+	CRYPTO_MSG_TMPL_REGISTER,
+	CRYPTO_MSG_TMPL_UNREGISTER,
+};
+
+struct notifier_block;
+
 struct crypto_instance {
 	struct crypto_alg alg;
 
@@ -44,6 +57,12 @@ struct crypto_template {
 	char name[CRYPTO_MAX_ALG_NAME];
 };
 
+struct crypto_larval {
+	struct crypto_alg alg;
+	struct crypto_alg *adult;
+	struct completion completion;
+};
+
 extern struct list_head crypto_alg_list;
 extern struct rw_semaphore crypto_alg_sem;
 
@@ -129,12 +148,17 @@ void crypto_exit_digest_ops(struct crypt
 void crypto_exit_cipher_ops(struct crypto_tfm *tfm);
 void crypto_exit_compress_ops(struct crypto_tfm *tfm);
 
+void crypto_larval_error(const char *name);
+
 int crypto_register_template(struct crypto_template *tmpl);
 void crypto_unregister_template(struct crypto_template *tmpl);
 struct crypto_template *crypto_lookup_template(const char *name);
 int crypto_register_instance(struct crypto_template *tmpl,
 			     struct crypto_instance *inst);
 
+int crypto_register_notifier(struct notifier_block *nb);
+int crypto_unregister_notifier(struct notifier_block *nb);
+
 static inline void *crypto_instance_ctx(struct crypto_instance *inst)
 {
 	return inst-&gt;__ctx;
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -28,11 +28,13 @@
 /*
  * Algorithm masks and types.
  */
-#define CRYPTO_ALG_TYPE_MASK		0x000000ff
+#define CRYPTO_ALG_TYPE_MASK		0x0000000f
 #define CRYPTO_ALG_TYPE_CIPHER		0x00000001
 #define CRYPTO_ALG_TYPE_DIGEST		0x00000002
 #define CRYPTO_ALG_TYPE_COMPRESS	0x00000004
 
+#define CRYPTO_ALG_LARVAL		0x00000010
+
 /*
  * Transform masks and values (for crt_flags).
  */
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060703102229</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-03 10:22:29-0400</timestampReceived><subject>[1/2] [CRYPTO] api: Avoid refilling larval-&gt;adult</subject><body>

Hi:

A couple of bug fixes:

[CRYPTO] api: Avoid refilling larval-&gt;adult

Once a larval has matured we should not change its adult value as this
will break those who have already dereferenced it.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -459,6 +459,8 @@ static int __crypto_register_alg(struct 
 		     !strcmp(alg-&gt;cra_driver_name, q-&gt;cra_name))) {
 			struct crypto_larval *larval = (void *)q;
 
+			if (larval-&gt;adult)
+				continue;
 			if ((q-&gt;cra_flags ^ alg-&gt;cra_flags) &amp; larval-&gt;mask)
 				continue;
 			if (!crypto_mod_get(alg))
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060611232708</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-06-11 23:27:08-0400</timestampReceived><subject>root-crypto with loop-aes on debian-testing, 2.6.15-1-686</subject><body>

Hello-, I used the newest loop-aes.README (10.April 2006) to get my root-fs
encrypted but failed with something like " no console found".
I used debian testing, but the newest loop-aes-relevant packages from unstable,
which I successfully use in multikey-mode on several other partions on another
computer and on the test-laptop for this try.
I managed to make a root-fs with dm-crypt via the ERPOSS4-Distri on the test-laptop \
but I don want to use dm-crypt and, additionally, I have good reasons not to trust \
the german government or any of his fuzzys, (and I do not want to give a really long \
passphrase 4 times because dm-crypt do not feed random-PW for swap).
I heard rumors about udev, =&gt;2.6.15 and changes of ramdisk........
I worked with the readme precisely point for point but sometimes I used some
*.deb instead of the tarball if I remember well.

Can anyone, especially when called Jari, give a hint ?

          regards,       Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060711020114</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-07-11 02:01:14-0400</timestampReceived><subject>[CRYPTO] padlock: Driver for SHA1 / SHA256 algorithms</subject><body>

Hi Herbert,

attached is the updated patch for padlock-sha.

Changes from last time:
* fallback TFM allocated in cra_init, not in dia_init
* dropped padlock_sha1_init and introduced padlock_sha1_cra_init (ditto
for 256). Both sha1 and sha256 use common padlock_sha_init() now.
* padlock_init checks for fallback modules but only prints warning if
they are not available, i.e. doesn't prevent loading the module if
fallbacks are not loadable.
* doesn't hold fallback TFMs throughout the whole lifetime anymore

Anything else to address?

Michal

["kernel-padlock-sha.diff" (text/x-patch)]

Subject: padlock: Driver for SHA1 / SHA256 algorithms

Support for SHA1 / SHA256 algorithms in VIA C7 processors.

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux-2.6.16.13-xenU/drivers/crypto/padlock-sha.c
===================================================================
--- /dev/null
+++ linux-2.6.16.13-xenU/drivers/crypto/padlock-sha.c
@@ -0,0 +1,352 @@
+/*
+ * Cryptographic API.
+ *
+ * Support for VIA PadLock hardware crypto engine.
+ *
+ * Copyright (c) 2006  Michal Ludvig &lt;michal@logix.cz&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/cryptohash.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include &lt;asm/byteorder.h&gt;
+#include "padlock.h"
+
+#define PADLOCK_CRA_PRIORITY	300
+
+#define SHA1_DEFAULT_FALLBACK	"sha1-generic"
+#define SHA1_DIGEST_SIZE        20
+#define SHA1_HMAC_BLOCK_SIZE    64
+
+#define SHA256_DEFAULT_FALLBACK "sha256-generic"
+#define SHA256_DIGEST_SIZE      32
+#define SHA256_HMAC_BLOCK_SIZE  64
+
+static char *sha1_fallback = SHA1_DEFAULT_FALLBACK;
+static char *sha256_fallback = SHA256_DEFAULT_FALLBACK;
+
+module_param(sha1_fallback, charp, 0444);
+module_param(sha256_fallback, charp, 0444);
+
+MODULE_PARM_DESC(sha1_fallback, "Fallback driver for SHA1. Default is " SHA1_DEFAULT_FALLBACK);
+MODULE_PARM_DESC(sha256_fallback, "Fallback driver for SHA256. Default is " SHA256_DEFAULT_FALLBACK);
+
+struct padlock_sha_ctx {
+	char		*data;
+	size_t		used;
+	size_t		data_len;
+	int		bypass;
+	void (*f_sha_padlock)(const char *in, char *out, int count);
+	const char	*fallback_driver_name;
+	struct crypto_tfm *fallback_tfm;
+};
+
+#define CTX(tfm)	((struct padlock_sha_ctx*)(crypto_tfm_ctx(tfm)))
+
+/* We'll need aligned address on the stack */
+#define NEAREST_ALIGNED(ptr) ((unsigned char *)(ptr) +	\
+	((0x10 - ((size_t)(ptr) &amp; 0x0F)) &amp; 0x0F))
+
+static struct crypto_alg sha1_alg, sha256_alg;
+
+static void padlock_sha_bypass(struct crypto_tfm *tfm)
+{
+	if (CTX(tfm)-&gt;bypass)
+		return;
+
+	BUG_ON(!CTX(tfm)-&gt;fallback_tfm);
+
+	crypto_digest_init(CTX(tfm)-&gt;fallback_tfm);
+	if (CTX(tfm)-&gt;data &amp;&amp; CTX(tfm)-&gt;used) {
+		struct scatterlist sg[8];
+
+		sg_set_buf(&amp;sg[0], CTX(tfm)-&gt;data, CTX(tfm)-&gt;used);
+		crypto_digest_update(CTX(tfm)-&gt;fallback_tfm, sg, 1);
+	}
+
+	CTX(tfm)-&gt;used = 0;
+	CTX(tfm)-&gt;bypass = 1;
+}
+
+static void padlock_sha_init(struct crypto_tfm *tfm)
+{
+	CTX(tfm)-&gt;used = 0;
+	CTX(tfm)-&gt;bypass = 0;
+}
+
+static void padlock_sha_update(struct crypto_tfm *tfm, const uint8_t *data, unsigned int length)
+{
+	if (unlikely(!CTX(tfm)-&gt;bypass &amp;&amp; (CTX(tfm)-&gt;used + length &gt; CTX(tfm)-&gt;data_len)))
+		padlock_sha_bypass(tfm);
+
+	if (unlikely(CTX(tfm)-&gt;bypass)) {
+		struct scatterlist sg[8];
+		BUG_ON(!CTX(tfm)-&gt;fallback_tfm);
+		sg_set_buf(&amp;sg[0], (uint8_t *)data, length);
+		crypto_digest_update(CTX(tfm)-&gt;fallback_tfm, sg, 1);
+		goto out_unlock;
+	}
+
+	memcpy(CTX(tfm)-&gt;data + CTX(tfm)-&gt;used, data, length);
+	CTX(tfm)-&gt;used += length;
+
+out_unlock:
+	return;
+}
+
+static inline void
+padlock_htonl_block(uint32_t *data, size_t count)
+{
+	while (count--) {
+		asm volatile ("bswapl %0" : "+r"(*data));
+		data++;
+	}
+}
+
+void padlock_do_sha1(const char *in, char *out, int count)
+{
+	/* We can't store directly to *out as it
+	 * doesn't have to be aligned. But who cares,
+	 * it's only a few bytes... */
+	char buf[128+16];
+	char *output = NEAREST_ALIGNED(buf);
+
+	((uint32_t*)output)[0] = 0x67452301;
+	((uint32_t*)output)[1] = 0xEFCDAB89;
+	((uint32_t*)output)[2] = 0x98BADCFE;
+	((uint32_t*)output)[3] = 0x10325476;
+	((uint32_t*)output)[4] = 0xC3D2E1F0;
+
+	asm volatile (".byte 0xf3,0x0f,0xa6,0xc8"	/* rep xsha1 */
+		      : "+S"(in), "+D"(output)
+		      : "c"(count), "a"(0));
+
+	memcpy(out, output, 5 * sizeof(uint32_t));
+
+	padlock_htonl_block((uint32_t*)out, 5);
+}
+
+void padlock_do_sha256(const char *in, char *out, int count)
+{
+	/* We can't store directly to *out as it
+	 * doesn't have to be aligned. But who cares,
+	 * it's only a few bytes... */
+	char buf[128+16];
+	char *output = NEAREST_ALIGNED(buf);
+
+	((uint32_t*)output)[0] = 0x6A09E667;
+	((uint32_t*)output)[1] = 0xBB67AE85;
+	((uint32_t*)output)[2] = 0x3C6EF372;
+	((uint32_t*)output)[3] = 0xA54FF53A;
+	((uint32_t*)output)[4] = 0x510E527F;
+	((uint32_t*)output)[5] = 0x9B05688C;
+	((uint32_t*)output)[6] = 0x1F83D9AB;
+	((uint32_t*)output)[7] = 0x5BE0CD19;
+
+	asm volatile (".byte 0xf3,0x0f,0xa6,0xd0"	/* rep xsha256 */
+		      : "+S"(in), "+D"(output)
+		      : "c"(count), "a"(0));
+
+	memcpy(out, output, 8 * sizeof(uint32_t));
+
+	padlock_htonl_block((uint32_t*)out, 8);
+}
+
+static void padlock_sha_final(struct crypto_tfm *tfm, uint8_t *out)
+{
+	if (unlikely(CTX(tfm)-&gt;bypass)) {
+		BUG_ON(!CTX(tfm)-&gt;fallback_tfm);
+		crypto_digest_final(CTX(tfm)-&gt;fallback_tfm, out);
+		CTX(tfm)-&gt;bypass = 0;
+		return;
+	}
+
+	/* Pass the input buffer to PadLock microcode... */
+	CTX(tfm)-&gt;f_sha_padlock(CTX(tfm)-&gt;data, out, CTX(tfm)-&gt;used);
+
+	CTX(tfm)-&gt;used = 0;
+}
+
+static int padlock_cra_init(struct crypto_tfm *tfm)
+{
+	/* First we allocate fallback and abort if it failed. */
+	CTX(tfm)-&gt;fallback_tfm = crypto_alloc_tfm(CTX(tfm)-&gt;fallback_driver_name, 0);
+	if (!CTX(tfm)-&gt;fallback_tfm) {
+		printk(KERN_WARNING PFX "Fallback driver '%s' could not be loaded!\n",
+		       CTX(tfm)-&gt;fallback_driver_name);
+		return -ENOENT;
+	}
+
+	/* For now we'll try to allocate one page. This
+	 * could eventually be configurable one day. */
+	CTX(tfm)-&gt;data = (char*)__get_free_page(GFP_KERNEL);
+	if (!CTX(tfm)-&gt;data)
+		padlock_sha_bypass(tfm);
+	else
+		CTX(tfm)-&gt;data_len = PAGE_SIZE;
+
+	/* Either we have a page or a fallback -&gt; always succeed. */
+	return 0;
+}
+
+static int padlock_sha1_cra_init(struct crypto_tfm *tfm)
+{
+	CTX(tfm)-&gt;f_sha_padlock = padlock_do_sha1;
+	CTX(tfm)-&gt;fallback_driver_name = sha1_fallback;
+
+	return padlock_cra_init(tfm);
+}
+
+static int padlock_sha256_cra_init(struct crypto_tfm *tfm)
+{
+	CTX(tfm)-&gt;f_sha_padlock = padlock_do_sha256;
+	CTX(tfm)-&gt;fallback_driver_name = sha256_fallback;
+
+	return padlock_cra_init(tfm);
+}
+
+static void padlock_cra_exit(struct crypto_tfm *tfm)
+{
+	if (CTX(tfm)-&gt;data) {
+		free_page((unsigned long)(CTX(tfm)-&gt;data));
+		CTX(tfm)-&gt;data = NULL;
+	}
+
+	BUG_ON(!CTX(tfm)-&gt;fallback_tfm);
+	crypto_free_tfm(CTX(tfm)-&gt;fallback_tfm);
+	CTX(tfm)-&gt;fallback_tfm = NULL;
+}
+
+static struct crypto_alg sha1_alg = {
+	.cra_name		=	"sha1",
+	.cra_driver_name	=	"sha1-padlock",
+	.cra_priority		=	PADLOCK_CRA_PRIORITY,
+	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST,
+	.cra_blocksize		=	SHA1_HMAC_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct padlock_sha_ctx),
+	.cra_alignmask		=	PADLOCK_ALIGNMENT - 1,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(sha1_alg.cra_list),
+	.cra_init		=	padlock_sha1_cra_init,
+	.cra_exit		=	padlock_cra_exit,
+	.cra_u			=	{
+		.digest = {
+			.dia_digestsize	=	SHA1_DIGEST_SIZE,
+			.dia_init   	= 	padlock_sha_init,
+			.dia_update 	=	padlock_sha_update,
+			.dia_final  	=	padlock_sha_final,
+		}
+	}
+};
+
+static struct crypto_alg sha256_alg = {
+	.cra_name		=	"sha256",
+	.cra_driver_name	=	"sha256-padlock",
+	.cra_priority		=	PADLOCK_CRA_PRIORITY,
+	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST,
+	.cra_blocksize		=	SHA256_HMAC_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct padlock_sha_ctx),
+	.cra_alignmask		=	PADLOCK_ALIGNMENT - 1,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(sha256_alg.cra_list),
+	.cra_init		=	padlock_sha256_cra_init,
+	.cra_exit		=	padlock_cra_exit,
+	.cra_u			=	{
+		.digest = {
+			.dia_digestsize	=	SHA256_DIGEST_SIZE,
+			.dia_init   	= 	padlock_sha_init,
+			.dia_update 	=	padlock_sha_update,
+			.dia_final  	=	padlock_sha_final,
+		}
+	}
+};
+
+static void __init padlock_sha_check_fallbacks(void)
+{
+	static struct crypto_tfm *tfm_sha1, *tfm_sha256;
+
+	/* We'll try to allocate one TFM for each fallback
+	 * to test that the modules are available. */
+	tfm_sha1 = crypto_alloc_tfm(sha1_fallback, 0);
+	if (!tfm_sha1) {
+		printk(KERN_WARNING PFX "Couldn't load fallback module for '%s'. Tried '%s'.\n",
+		       sha1_alg.cra_name, sha1_fallback);
+	} else {
+		printk(KERN_NOTICE PFX "Fallback for '%s' is driver '%s' (prio=%d)\n", sha1_alg.cra_name,
+		       crypto_tfm_alg_driver_name(tfm_sha1), crypto_tfm_alg_priority(tfm_sha1));
+		crypto_free_tfm(tfm_sha1);
+	}
+
+	tfm_sha256 = crypto_alloc_tfm(sha256_fallback, 0);
+	if (!tfm_sha256) {
+		printk(KERN_WARNING PFX "Couldn't load fallback module for '%s'. Tried '%s'.\n",
+		       sha256_alg.cra_name, sha256_fallback);
+	} else {
+		printk(KERN_NOTICE PFX "Fallback for '%s' is driver '%s' (prio=%d)\n", sha256_alg.cra_name,
+		       crypto_tfm_alg_driver_name(tfm_sha256), crypto_tfm_alg_priority(tfm_sha256));
+		crypto_free_tfm(tfm_sha256);
+	}
+}
+
+static int __init padlock_init(void)
+{
+	int rc = -ENODEV;
+
+	if (!cpu_has_phe) {
+		printk(KERN_ERR PFX "VIA PadLock Hash Engine not detected.\n");
+		return -ENODEV;
+	}
+
+	if (!cpu_has_phe_enabled) {
+		printk(KERN_ERR PFX "VIA PadLock detected, but not enabled. Hmm, strange...\n");
+		return -ENODEV;
+	}
+
+	padlock_sha_check_fallbacks();
+
+	rc = crypto_register_alg(&amp;sha1_alg);
+	if (rc)
+		goto out;
+
+	rc = crypto_register_alg(&amp;sha256_alg);
+	if (rc)
+		goto out_unreg1;
+
+	printk(KERN_NOTICE PFX "Using VIA PadLock ACE for SHA1/SHA256 algorithms.\n");
+
+	return 0;
+
+out_unreg1:
+	crypto_unregister_alg(&amp;sha1_alg);
+out:
+	printk(KERN_ERR PFX "VIA PadLock SHA1/SHA256 initialization failed.\n");
+	return rc;
+}
+
+static void __exit padlock_fini(void)
+{
+	crypto_unregister_alg(&amp;sha1_alg);
+	crypto_unregister_alg(&amp;sha256_alg);
+}
+
+module_init(padlock_init);
+module_exit(padlock_fini);
+
+MODULE_DESCRIPTION("VIA PadLock SHA1/SHA256 algorithms support.");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Michal Ludvig");
+
+MODULE_ALIAS("sha1-padlock");
+MODULE_ALIAS("sha256-padlock");
Index: linux-2.6.16.13-xenU/drivers/crypto/Kconfig
===================================================================
--- linux-2.6.16.13-xenU.orig/drivers/crypto/Kconfig
+++ linux-2.6.16.13-xenU/drivers/crypto/Kconfig
@@ -26,4 +26,18 @@ config CRYPTO_DEV_PADLOCK_AES
 	  If unsure say M. The compiled module will be
 	  called padlock-aes.ko
 
+config CRYPTO_DEV_PADLOCK_SHA
+	tristate "PadLock driver for SHA1 and SHA256 algorithms"
+	depends on CRYPTO_DEV_PADLOCK
+	select CRYPTO_SHA1
+	select CRYPTO_SHA256
+	default m
+	help
+	  Use VIA PadLock for SHA1/SHA256 algorithms.
+
+	  Available in VIA C7 and newer processors.
+
+	  If unsure say M. The compiled module will be
+	  called padlock-sha.ko
+
 endmenu
Index: linux-2.6.16.13-xenU/drivers/crypto/Makefile
===================================================================
--- linux-2.6.16.13-xenU.orig/drivers/crypto/Makefile
+++ linux-2.6.16.13-xenU/drivers/crypto/Makefile
@@ -1 +1,2 @@
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK_AES) += padlock-aes.o
+obj-$(CONFIG_CRYPTO_DEV_PADLOCK_SHA) += padlock-sha.o

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060710091354</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-07-10 09:13:54-0400</timestampReceived><subject>[ACRYPTO] new release of asynchronous crrypto layer.</subject><body>

Hello.

I'm pleased to announce new release of asynchronous crypto layer ACRYPTO
[1]. Acrypto allows to handle crypto requests asynchronously in
hardware.

This release has following major features:
 * OCF [2] to acrypto bridge. Work by Yakov Lerner &lt;iler.ml@gmail.com&gt;
   This module allows to use ixp4xx driver with acrypto IPsec and
   dm-crypt.
 * major name refactoring
 * crypto context abstractions (allows to notify hardware when keys 
   and/or some other crypto parameters are changed)
 * bugfixes and small feature extensions

With this release I decide to drop support for old tarball acrypto
releases. All new features and bugfixes will go directly into combined
patchsets against supported trees (currently 2.6.16 and 2.6.17, 2.6.15
is unsupported anymore). Releases with major changes will be announced
in linux-kernel@ and linux-crypto@ mail lists.

Combined patchsets include:
 * acrypto core
 * IPsec ESP4 port to acrypto
 * dm-crypt port to acrypto
 * OCF to acrypto bridge

Acrypto supports following crypto providers:
 * SW crypto provider
 * HIFN 795x adapters
 * VIA nehemiah CPU
 * SuperCrypt CE99C003B
 * devices supported by OCF (only IXP4xx was tested)

1. Acrypto homepage.
http://tservice.net.ru/~s0mbre/old/?section=projects&amp;item=acrypto

2. OCF homepage.
http://ocf-linux.sourceforge.net

3. Acrypto archive with combined patchsets.
http://tservice.net.ru/~s0mbre/archive/acrypto/patchsets/

4. Acrypto archive with device drivers.
http://tservice.net.ru/~s0mbre/archive/acrypto/drivers/

Thank you.

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060711045536</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-11 04:55:36-0400</timestampReceived><subject>Re: [ACRYPTO] new release of asynchronous crrypto layer.</subject><body>

Hi Evgeniy:

Evgeniy Polyakov &lt;johnpol@2ka.mipt.ru&gt; wrote:
&gt;
&gt; * IPsec ESP4 port to acrypto

I noticed a bug in the ESP IV processing.  When you do ESP asynchronously,
you can no longer use the last block of the previous packet as the IV of
the next.  This is because the next packet may have started processing
before the last packet has even been finalised.

A simple solution is to generate a random IV.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060711053157</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-07-11 05:31:57-0400</timestampReceived><subject>Re: [ACRYPTO] new release of asynchronous crrypto layer.</subject><body>

On Tue, Jul 11, 2006 at 02:55:36PM +1000, Herbert Xu (herbert@gondor.apana.org.au) wrote:
&gt; Hi Evgeniy:

Hi Herbert.

&gt; Evgeniy Polyakov &lt;johnpol@2ka.mipt.ru&gt; wrote:
&gt; &gt;
&gt; &gt; * IPsec ESP4 port to acrypto
&gt; 
&gt; I noticed a bug in the ESP IV processing.  When you do ESP asynchronously,
&gt; you can no longer use the last block of the previous packet as the IV of
&gt; the next.  This is because the next packet may have started processing
&gt; before the last packet has even been finalised.

I cought that bug too, so IV being used is always copied into old_iv variable,
so integrity is stated.

&gt; A simple solution is to generate a random IV.

Yes, it could be done too.
But actually neither random IV, nor IV created from encrypted previous packet, 
nor IV created from unencrypted previous packet are forbidden by spec. 
Initial implementation used constant IV there at all.

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060612061456</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-06-12 06:14:56-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686</subject><body>

reverend@Safe-mail.net wrote:
&gt; Hello-, I used the newest loop-aes.README (10.April 2006) to get my root-fs
&gt; encrypted but failed with something like " no console found".

Most likely this is caused by missing /dev/console device node on your
encrypted root partition. Step 17 of April-10-2006 README is supposed to
make sure that static /dev/console device node exists on your encrypted root
partition. When udev starts up, it mounts a newly created file system on top
of /dev, so that original static nodes are unaccessible. So, after udev is
started, it looks like that there is a /dev/console device node, but your
real udev-less encrypted file system does not have that device node.

To fix, do this:

1)  boot knoppix
2)  mount partition where your key file is
3)  mount your encrypted root partition on /mnt
4)  run these commands:
        mknod -m 600 /mnt/dev/console c 5 1
        mknod -m 666 /mnt/dev/null c 1 3
        mknod -m 666 /mnt/dev/zero c 1 5
5)  unmount /mnt and key file partitions
6)  reboot

However, if your encrypted root partition already contains above mentioned
static device nodes, then please post your bootloader configuration and
time when that error occours (before or after entering passphrase).

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060712003435</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-07-12 00:34:35-0400</timestampReceived><subject>[0/2] [CRYPTO] padlock: SHA1 / SHA256 support</subject><body>

Hi Herbert,

the updated patch addresses almost all your comments.

Changes since last time:
* Removed data_len and fallback_driver_name from struct padlock_sha_ctx
* PADLOCK_CRA_PRIORITY moved to padlock.h
* #define CTX(tfm) converted into inline function ctx()
* Changed padlock_htonl_bloc() renamed, changed to use swab32(), 
  doesn't work in-place anymore (i.e. removed some memcpy() as well)
* Return -ENOMEM from cra_init if get_free_page() failed.
* Plus a few minor changes.

&gt;&gt; +#include "padlock.h"
&gt;&gt; +
&gt;&gt; +#define PADLOCK_CRA_PRIORITY	300
&gt; 
&gt; Perhaps this macro can be moved into padlock.h since it's shared
&gt; with AES?

Right, patch follows.

&gt; Please use u8/u16/u32/u64 instead of uintX_t for kernel code.  Until
&gt; there is a change in general kernel policy it's better to stick with
&gt; the prevailing coding style.

I prefer to keep uintX_t - quick grep reveals these are not uncommon in
the kernel. After all - linux people always rant about standards and
uint32_t *is* a standard while u32 is not (Plus I get a nice green syntax
highlighting for the *standard* types ;-)

&gt;&gt; +void padlock_do_sha1(const char *in, char *out, int count)
&gt;&gt; +{
&gt;&gt; +	/* We can't store directly to *out as it
&gt;&gt; +	 * doesn't have to be aligned. But who cares,
&gt;&gt; +	 * it's only a few bytes... */
&gt;&gt; +	char buf[128+16];
&gt; 
&gt; Does it really need 128 bytes?

Yes, CPU temporarily stores some data in there (IIRC in case the input
buffer is not 16 Bytes-aligned it realigns it there for the SSE input
microcode).

&gt; It's also better to put this in the
&gt; ctx since there it's easier to get the required alignment (see what
&gt; I did to the padlock AES driver).
&gt; 
&gt; Also the output buffer is guaranteed to be aligned because you've
&gt; set the alignment mask.

This buffer is only used during the final hashing phase so it could easily
be on the stack. I didn't want to carry it around in CTX for each TFM. 

OTOH if I change the engine later to work without fallbacks I'll need to
store the intermediate results. I'll make this change once needed.

Any other comments?

Michal



-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060712003437</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-07-12 00:34:37-0400</timestampReceived><subject>[2/2] [CRYPTO] padlock: Driver for SHA1 / SHA256 algorithms</subject><body>

Support for SHA1 / SHA256 algorithms in VIA C7 processors.

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux-2.6.16.13-xenU/drivers/crypto/padlock-sha.c
===================================================================
--- /dev/null
+++ linux-2.6.16.13-xenU/drivers/crypto/padlock-sha.c
@@ -0,0 +1,341 @@
+/*
+ * Cryptographic API.
+ *
+ * Support for VIA PadLock hardware crypto engine.
+ *
+ * Copyright (c) 2006  Michal Ludvig &lt;michal@logix.cz&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/cryptohash.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include "padlock.h"
+
+#define SHA1_DEFAULT_FALLBACK	"sha1-generic"
+#define SHA1_DIGEST_SIZE        20
+#define SHA1_HMAC_BLOCK_SIZE    64
+
+#define SHA256_DEFAULT_FALLBACK "sha256-generic"
+#define SHA256_DIGEST_SIZE      32
+#define SHA256_HMAC_BLOCK_SIZE  64
+
+static char *sha1_fallback = SHA1_DEFAULT_FALLBACK;
+static char *sha256_fallback = SHA256_DEFAULT_FALLBACK;
+
+module_param(sha1_fallback, charp, 0644);
+module_param(sha256_fallback, charp, 0644);
+
+MODULE_PARM_DESC(sha1_fallback, "Fallback driver for SHA1. Default is "
+		 SHA1_DEFAULT_FALLBACK);
+MODULE_PARM_DESC(sha256_fallback, "Fallback driver for SHA256. Default is "
+		 SHA256_DEFAULT_FALLBACK);
+
+struct padlock_sha_ctx {
+	char		*data;
+	size_t		used;
+	int		bypass;
+	void (*f_sha_padlock)(const char *in, char *out, int count);
+	struct crypto_tfm *fallback_tfm;
+};
+
+static inline struct padlock_sha_ctx *ctx(struct crypto_tfm *tfm)
+{
+	return (struct padlock_sha_ctx*)(crypto_tfm_ctx(tfm));
+}
+
+/* We'll need aligned address on the stack */
+#define NEAREST_ALIGNED(ptr) \
+	((void *)ALIGN((size_t)(ptr), PADLOCK_ALIGNMENT))
+
+static struct crypto_alg sha1_alg, sha256_alg;
+
+static void padlock_sha_bypass(struct crypto_tfm *tfm)
+{
+	if (ctx(tfm)-&gt;bypass)
+		return;
+
+	BUG_ON(!ctx(tfm)-&gt;fallback_tfm);
+
+	crypto_digest_init(ctx(tfm)-&gt;fallback_tfm);
+	if (ctx(tfm)-&gt;data &amp;&amp; ctx(tfm)-&gt;used) {
+		struct scatterlist sg;
+
+		sg_set_buf(&amp;sg, ctx(tfm)-&gt;data, ctx(tfm)-&gt;used);
+		crypto_digest_update(ctx(tfm)-&gt;fallback_tfm, &amp;sg, 1);
+	}
+
+	ctx(tfm)-&gt;used = 0;
+	ctx(tfm)-&gt;bypass = 1;
+}
+
+static void padlock_sha_init(struct crypto_tfm *tfm)
+{
+	ctx(tfm)-&gt;used = 0;
+	ctx(tfm)-&gt;bypass = 0;
+}
+
+static void padlock_sha_update(struct crypto_tfm *tfm,
+			const uint8_t *data, unsigned int length)
+{
+	/* Our buffer is always one page. */
+	if (unlikely(!ctx(tfm)-&gt;bypass &amp;&amp;
+		     (ctx(tfm)-&gt;used + length &gt; PAGE_SIZE)))
+		padlock_sha_bypass(tfm);
+
+	if (unlikely(ctx(tfm)-&gt;bypass)) {
+		struct scatterlist sg;
+		BUG_ON(!ctx(tfm)-&gt;fallback_tfm);
+		sg_set_buf(&amp;sg, (uint8_t *)data, length);
+		crypto_digest_update(ctx(tfm)-&gt;fallback_tfm, &amp;sg, 1);
+		return;
+	}
+
+	memcpy(ctx(tfm)-&gt;data + ctx(tfm)-&gt;used, data, length);
+	ctx(tfm)-&gt;used += length;
+}
+
+static inline void padlock_output_block(uint32_t *src,
+		 	uint32_t *dst, size_t count)
+{
+	while (count--)
+		*dst++ = swab32(*src++);
+}
+
+void padlock_do_sha1(const char *in, char *out, int count)
+{
+	/* We can't store directly to *out as it may be unaligned. */
+	/* BTW Don't reduce the buffer size below 128 Bytes!
+	 *     PadLock microcode needs it that big. */
+	char buf[128+16];
+	char *result = NEAREST_ALIGNED(buf);
+
+	((uint32_t*)result)[0] = 0x67452301;
+	((uint32_t*)result)[1] = 0xEFCDAB89;
+	((uint32_t*)result)[2] = 0x98BADCFE;
+	((uint32_t*)result)[3] = 0x10325476;
+	((uint32_t*)result)[4] = 0xC3D2E1F0;
+
+	asm volatile (".byte 0xf3,0x0f,0xa6,0xc8" /* rep xsha1 */
+		      : "+S"(in), "+D"(result)
+		      : "c"(count), "a"(0));
+
+	padlock_output_block((uint32_t *)result, (uint32_t*)out, 5);
+}
+
+void padlock_do_sha256(const char *in, char *out, int count)
+{
+	/* We can't store directly to *out as it may be unaligned. */
+	/* BTW Don't reduce the buffer size below 128 Bytes!
+	 *     PadLock microcode needs it that big. */
+	char buf[128+16];
+	char *result = NEAREST_ALIGNED(buf);
+
+	((uint32_t*)result)[0] = 0x6A09E667;
+	((uint32_t*)result)[1] = 0xBB67AE85;
+	((uint32_t*)result)[2] = 0x3C6EF372;
+	((uint32_t*)result)[3] = 0xA54FF53A;
+	((uint32_t*)result)[4] = 0x510E527F;
+	((uint32_t*)result)[5] = 0x9B05688C;
+	((uint32_t*)result)[6] = 0x1F83D9AB;
+	((uint32_t*)result)[7] = 0x5BE0CD19;
+
+	asm volatile (".byte 0xf3,0x0f,0xa6,0xd0" /* rep xsha256 */
+		      : "+S"(in), "+D"(result)
+		      : "c"(count), "a"(0));
+
+	padlock_output_block((uint32_t *)result, (uint32_t*)out, 8);
+}
+
+static void padlock_sha_final(struct crypto_tfm *tfm, uint8_t *out)
+{
+	if (unlikely(ctx(tfm)-&gt;bypass)) {
+		BUG_ON(!ctx(tfm)-&gt;fallback_tfm);
+		crypto_digest_final(ctx(tfm)-&gt;fallback_tfm, out);
+		ctx(tfm)-&gt;bypass = 0;
+		return;
+	}
+
+	/* Pass the input buffer to PadLock microcode... */
+	ctx(tfm)-&gt;f_sha_padlock(ctx(tfm)-&gt;data, out, ctx(tfm)-&gt;used);
+
+	ctx(tfm)-&gt;used = 0;
+}
+
+static int padlock_cra_init(struct crypto_tfm *tfm, const char *fallback_driver_name)
+{
+	/* For now we'll allocate one page. This
+	 * could eventually be configurable one day. */
+	ctx(tfm)-&gt;data = (char*)__get_free_page(GFP_KERNEL);
+	if (!ctx(tfm)-&gt;data)
+		return -ENOMEM;
+
+	/* Allocate a fallback and abort if it failed. */
+	ctx(tfm)-&gt;fallback_tfm = crypto_alloc_tfm(fallback_driver_name, 0);
+	if (!ctx(tfm)-&gt;fallback_tfm) {
+		printk(KERN_WARNING PFX "Fallback driver '%s' could not be loaded!\n",
+		       fallback_driver_name);
+		free_page((unsigned long)(ctx(tfm)-&gt;data));
+		return -ENOENT;
+	}
+
+	return 0;
+}
+
+static int padlock_sha1_cra_init(struct crypto_tfm *tfm)
+{
+	ctx(tfm)-&gt;f_sha_padlock = padlock_do_sha1;
+
+	return padlock_cra_init(tfm, sha1_fallback);
+}
+
+static int padlock_sha256_cra_init(struct crypto_tfm *tfm)
+{
+	ctx(tfm)-&gt;f_sha_padlock = padlock_do_sha256;
+
+	return padlock_cra_init(tfm, sha256_fallback);
+}
+
+static void padlock_cra_exit(struct crypto_tfm *tfm)
+{
+	if (ctx(tfm)-&gt;data) {
+		free_page((unsigned long)(ctx(tfm)-&gt;data));
+		ctx(tfm)-&gt;data = NULL;
+	}
+
+	BUG_ON(!ctx(tfm)-&gt;fallback_tfm);
+	crypto_free_tfm(ctx(tfm)-&gt;fallback_tfm);
+	ctx(tfm)-&gt;fallback_tfm = NULL;
+}
+
+static struct crypto_alg sha1_alg = {
+	.cra_name		=	"sha1",
+	.cra_driver_name	=	"sha1-padlock",
+	.cra_priority		=	PADLOCK_CRA_PRIORITY,
+	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST,
+	.cra_blocksize		=	SHA1_HMAC_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct padlock_sha_ctx),
+	.cra_alignmask		=	PADLOCK_ALIGNMENT - 1,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(sha1_alg.cra_list),
+	.cra_init		=	padlock_sha1_cra_init,
+	.cra_exit		=	padlock_cra_exit,
+	.cra_u			=	{
+		.digest = {
+			.dia_digestsize	=	SHA1_DIGEST_SIZE,
+			.dia_init   	= 	padlock_sha_init,
+			.dia_update 	=	padlock_sha_update,
+			.dia_final  	=	padlock_sha_final,
+		}
+	}
+};
+
+static struct crypto_alg sha256_alg = {
+	.cra_name		=	"sha256",
+	.cra_driver_name	=	"sha256-padlock",
+	.cra_priority		=	PADLOCK_CRA_PRIORITY,
+	.cra_flags		=	CRYPTO_ALG_TYPE_DIGEST,
+	.cra_blocksize		=	SHA256_HMAC_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct padlock_sha_ctx),
+	.cra_alignmask		=	PADLOCK_ALIGNMENT - 1,
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(sha256_alg.cra_list),
+	.cra_init		=	padlock_sha256_cra_init,
+	.cra_exit		=	padlock_cra_exit,
+	.cra_u			=	{
+		.digest = {
+			.dia_digestsize	=	SHA256_DIGEST_SIZE,
+			.dia_init   	= 	padlock_sha_init,
+			.dia_update 	=	padlock_sha_update,
+			.dia_final  	=	padlock_sha_final,
+		}
+	}
+};
+
+static void __init padlock_sha_check_fallbacks(void)
+{
+	static struct crypto_tfm *tfm_sha1, *tfm_sha256;
+
+	/* We'll try to allocate one TFM for each fallback
+	 * to test that the modules are available. */
+	tfm_sha1 = crypto_alloc_tfm(sha1_fallback, 0);
+	if (!tfm_sha1) {
+		printk(KERN_WARNING PFX "Couldn't load fallback module for '%s'. Tried '%s'.\n",
+		       sha1_alg.cra_name, sha1_fallback);
+	} else {
+		printk(KERN_NOTICE PFX "Fallback for '%s' is driver '%s' (prio=%d)\n", sha1_alg.cra_name,
+		       crypto_tfm_alg_driver_name(tfm_sha1), crypto_tfm_alg_priority(tfm_sha1));
+		crypto_free_tfm(tfm_sha1);
+	}
+
+	tfm_sha256 = crypto_alloc_tfm(sha256_fallback, 0);
+	if (!tfm_sha256) {
+		printk(KERN_WARNING PFX "Couldn't load fallback module for '%s'. Tried '%s'.\n",
+		       sha256_alg.cra_name, sha256_fallback);
+	} else {
+		printk(KERN_NOTICE PFX "Fallback for '%s' is driver '%s' (prio=%d)\n", sha256_alg.cra_name,
+		       crypto_tfm_alg_driver_name(tfm_sha256), crypto_tfm_alg_priority(tfm_sha256));
+		crypto_free_tfm(tfm_sha256);
+	}
+}
+
+static int __init padlock_init(void)
+{
+	int rc = -ENODEV;
+
+	if (!cpu_has_phe) {
+		printk(KERN_ERR PFX "VIA PadLock Hash Engine not detected.\n");
+		return -ENODEV;
+	}
+
+	if (!cpu_has_phe_enabled) {
+		printk(KERN_ERR PFX "VIA PadLock detected, but not enabled. Hmm, strange...\n");
+		return -ENODEV;
+	}
+
+	padlock_sha_check_fallbacks();
+
+	rc = crypto_register_alg(&amp;sha1_alg);
+	if (rc)
+		goto out;
+
+	rc = crypto_register_alg(&amp;sha256_alg);
+	if (rc)
+		goto out_unreg1;
+
+	printk(KERN_NOTICE PFX "Using VIA PadLock ACE for SHA1/SHA256 algorithms.\n");
+
+	return 0;
+
+out_unreg1:
+	crypto_unregister_alg(&amp;sha1_alg);
+out:
+	printk(KERN_ERR PFX "VIA PadLock SHA1/SHA256 initialization failed.\n");
+	return rc;
+}
+
+static void __exit padlock_fini(void)
+{
+	crypto_unregister_alg(&amp;sha1_alg);
+	crypto_unregister_alg(&amp;sha256_alg);
+}
+
+module_init(padlock_init);
+module_exit(padlock_fini);
+
+MODULE_DESCRIPTION("VIA PadLock SHA1/SHA256 algorithms support.");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Michal Ludvig");
+
+MODULE_ALIAS("sha1-padlock");
+MODULE_ALIAS("sha256-padlock");
Index: linux-2.6.16.13-xenU/drivers/crypto/Kconfig
===================================================================
--- linux-2.6.16.13-xenU.orig/drivers/crypto/Kconfig
+++ linux-2.6.16.13-xenU/drivers/crypto/Kconfig
@@ -26,4 +26,18 @@ config CRYPTO_DEV_PADLOCK_AES
 	  If unsure say M. The compiled module will be
 	  called padlock-aes.ko
 
+config CRYPTO_DEV_PADLOCK_SHA
+	tristate "PadLock driver for SHA1 and SHA256 algorithms"
+	depends on CRYPTO_DEV_PADLOCK
+	select CRYPTO_SHA1
+	select CRYPTO_SHA256
+	default m
+	help
+	  Use VIA PadLock for SHA1/SHA256 algorithms.
+
+	  Available in VIA C7 and newer processors.
+
+	  If unsure say M. The compiled module will be
+	  called padlock-sha.ko
+
 endmenu
Index: linux-2.6.16.13-xenU/drivers/crypto/Makefile
===================================================================
--- linux-2.6.16.13-xenU.orig/drivers/crypto/Makefile
+++ linux-2.6.16.13-xenU/drivers/crypto/Makefile
@@ -1 +1,2 @@
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK_AES) += padlock-aes.o
+obj-$(CONFIG_CRYPTO_DEV_PADLOCK_SHA) += padlock-sha.o

--


-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060715003540</emailId><senderName>Adrian Bunk</senderName><senderEmail>bunk@stusta.de</senderEmail><timestampReceived>2006-07-15 00:35:40-0400</timestampReceived><subject>[-mm patch] drivers/crypto/padlock-sha.c: make 2 functions static</subject><body>

On Thu, Jul 13, 2006 at 10:48:00PM -0700, Andrew Morton wrote:
&gt;...
&gt; Changes since 2.6.18-rc1-mm1:
&gt;...
&gt;  git-cryptodev.patch 
&gt; 
&gt;  git trees.
&gt;...

This patch makes two needlessly global functions static.

Signed-off-by: Adrian Bunk &lt;bunk@stusta.de&gt;

---

 drivers/crypto/padlock-sha.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

--- linux-2.6.18-rc1-mm2-full/drivers/crypto/padlock-sha.c.old	2006-07-14 23:25:40.000000000 +0200
+++ linux-2.6.18-rc1-mm2-full/drivers/crypto/padlock-sha.c	2006-07-14 23:25:54.000000000 +0200
@@ -112,7 +112,7 @@
 		*dst++ = swab32(*src++);
 }
 
-void padlock_do_sha1(const char *in, char *out, int count)
+static void padlock_do_sha1(const char *in, char *out, int count)
 {
 	/* We can't store directly to *out as it may be unaligned. */
 	/* BTW Don't reduce the buffer size below 128 Bytes!
@@ -133,7 +133,7 @@
 	padlock_output_block((uint32_t *)result, (uint32_t *)out, 5);
 }
 
-void padlock_do_sha256(const char *in, char *out, int count)
+static void padlock_do_sha256(const char *in, char *out, int count)
 {
 	/* We can't store directly to *out as it may be unaligned. */
 	/* BTW Don't reduce the buffer size below 128 Bytes!

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060714020816</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-07-14 02:08:16-0400</timestampReceived><subject>[CRYPTO] padlock: Fix alignment after aes_ctx rearrange</subject><body>

Hi Herbert,

I just recently discovered that your patch that rearranges struct
aes_ctx in padlock-aes.c breaks the alignment rules for xcrypt leading
to GPF Oopses.

Note that *all* addresses passed to xcrypt must be 16-Bytes aligned for
VIA C3 (including IV and Key - the latter one was not aligned and
triggered this Oops).

As the rearrange patch made it to 2.6.18-rc1 it must be fixed before
2.6.18 is out. Attached is a patch.

Michal


-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060710062508</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-10 06:25:08-0400</timestampReceived><subject>[1/5] [CRYPTO] padlock: Add compatibility alias after rename</subject><body>

[CRYPTO] padlock: Add compatibility alias after rename

Whenever we rename modules we should add an alias to ensure that existing
users can still locate the new module.

This patch also gets rid of the now unused module function prototypes from
padlock.h.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/drivers/crypto/padlock-aes.c b/drivers/crypto/padlock-aes.c
--- a/drivers/crypto/padlock-aes.c
+++ b/drivers/crypto/padlock-aes.c
@@ -528,3 +528,6 @@ MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Michal Ludvig");
 
 MODULE_ALIAS("aes-padlock");
+
+/* This module used to be called padlock. */
+MODULE_ALIAS("padlock");
diff --git a/drivers/crypto/padlock.h b/drivers/crypto/padlock.h
--- a/drivers/crypto/padlock.h
+++ b/drivers/crypto/padlock.h
@@ -28,9 +28,4 @@ struct cword {
 
 #define PFX	"padlock: "
 
-#ifdef CONFIG_CRYPTO_DEV_PADLOCK_AES
-int padlock_init_aes(void);
-void padlock_fini_aes(void);
-#endif
-
 #endif	/* _CRYPTO_PADLOCK_H */
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060718201134</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-07-18 20:11:34-0400</timestampReceived><subject>util-linux patch vs. PAGE_SIZE on powerpc</subject><body>

Hi all,

the loop-AES patch for util-linux uses the PAGE_SIZE definition
which is normally available through asm/page.h. Unfortunately
this is no longer the case for powerpc. There PAGE_SIZE is only
defined inside #ifdef __KERNEL__ and so causes builds to fail.

&gt; From what I picked up, the glibc function getpagesize() can be
used instead. The manpage is a bit discouraging and notes that
availability varies depending on the architecture, but since
getpagesize() is already used in other parts of upstream mount/
I would guess that it is not actually so bad in practice. :-)

I'm attaching the patch that I'm including in Debian
loop-aes-utils to fix the build on powerpc. Comments welcome -
Does that change look okay to you, or is there a better way?

cheers,
Max

-- 
http://buildd.debian.org/fetch.php?&amp;pkg=loop-aes-utils&amp;ver=2.12r-12&amp;arch=powerpc&amp;stamp=1153245109&amp;file=log&amp;as=raw



["2.12r_getpagesize.diff" (text/plain)]

--- mount/swapon.c~	2006-07-18 21:22:03.000000000 +0200
+++ mount/swapon.c	2006-07-18 21:22:46.000000000 +0200
@@ -323,6 +323,7 @@
 prepare_encrypted_swap(const char *partition, char *loop, char *encryption)
 {
 	int x, y, fd, ffd;
+	int page_size;
 	sha512_context s;
 	unsigned char b[4096], multiKeyBits[65][32];
 	char *a[10], *apiName;
@@ -366,7 +367,8 @@
 		fprintf(stderr, _("swapon: unable to open swap device %s\n"), partition);
 		goto errout0;
 	}
-	fseek(f, (long)PAGE_SIZE, SEEK_SET);
+	page_size = getpagesize()
+	fseek(f, (long)page_size, SEEK_SET);
 	sha512_init(&amp;s);
 	for(x = 0; x &lt; 10; x++) {
 		if(fread(&amp;b[0], sizeof(b), 1, f) != 1) break;
@@ -385,7 +387,7 @@
 			unsigned char h[64];
 			int x,y,z;
 		} j;
-		if(fseek(f, (long)PAGE_SIZE, SEEK_SET)) break;
+		if(fseek(f, (long)page_size, SEEK_SET)) break;
 		memcpy(&amp;j.h[0], &amp;s.sha_out[0], 64);
 		gettimeofday(&amp;j.tv, NULL);
 		j.y = y;
@@ -444,7 +446,7 @@
 		memset(&amp;multiKeyBits[0][0], 0, sizeof(multiKeyBits));
 		return 0;
 	}
-	loopinfo.lo_offset = PAGE_SIZE;
+	loopinfo.lo_offset = page_size;
 	/* single-key hash */
 	sha512_hash_buffer(&amp;b[0], 64+32, &amp;loopinfo.lo_encrypt_key[0], sizeof(loopinfo.lo_encrypt_key));
 	/* multi-key hash */

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060710062851</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-07-10 06:28:51-0400</timestampReceived><subject>Re: [1/5] [CRYPTO] padlock: Add compatibility alias after rename</subject><body>

Herbert Xu wrote:
&gt; [CRYPTO] padlock: Add compatibility alias after rename
&gt; 
&gt; Whenever we rename modules we should add an alias to ensure that existing
&gt; users can still locate the new module.

I was thinking about creating a dummy module padlock.ko that would load
all other configured padlock modules (i.e. -aes and -sha currently).

With this alias modprobe padlock will only load *some* padlock stuff
which may be confusing.

Michal
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060710063137</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-10 06:31:37-0400</timestampReceived><subject>Re: [1/5] [CRYPTO] padlock: Add compatibility alias after rename</subject><body>

On Mon, Jul 10, 2006 at 06:28:51PM +1200, Michal Ludvig wrote:
&gt; 
&gt; I was thinking about creating a dummy module padlock.ko that would load
&gt; all other configured padlock modules (i.e. -aes and -sha currently).

Sounds good to me.  Feel free to send a patch :)
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060714062159</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-07-14 06:21:59-0400</timestampReceived><subject>Re: [1/5] [CRYPTO] padlock: Add compatibility alias after rename</subject><body>

Herbert Xu wrote:
&gt; On Mon, Jul 10, 2006 at 06:28:51PM +1200, Michal Ludvig wrote:
&gt;&gt; I was thinking about creating a dummy module padlock.ko that would load
&gt;&gt; all other configured padlock modules (i.e. -aes and -sha currently).
&gt; 
&gt; Sounds good to me.  Feel free to send a patch :)

Attached.

Michal

["padlock-load-all.diff" (text/x-patch)]

Subject: padlock: Helper module padlock.ko

Compile a helper module padlock.ko that will try
to autoload all configured padlock algorithms.

This also provides backward compatibility with 
the ancient times before padlock.ko was renamed 
to padlock-aes.ko

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux-2.6.16.13-xenU/drivers/crypto/Kconfig
===================================================================
--- linux-2.6.16.13-xenU.orig/drivers/crypto/Kconfig
+++ linux-2.6.16.13-xenU/drivers/crypto/Kconfig
@@ -1,9 +1,9 @@
 menu "Hardware crypto devices"
 
 config CRYPTO_DEV_PADLOCK
-	bool "Support for VIA PadLock ACE"
+	tristate "Support for VIA PadLock ACE"
 	depends on CRYPTO &amp;&amp; X86_32
-	default y
+	default m
 	help
 	  Some VIA processors come with an integrated crypto engine
 	  (so called VIA PadLock ACE, Advanced Cryptography Engine)
@@ -11,8 +11,17 @@ config CRYPTO_DEV_PADLOCK
 	  operations with supported algorithms.
 	  
 	  The instructions are used only when the CPU supports them.
-	  Otherwise software encryption is used. If you are unsure,
-	  say Y.
+	  Otherwise software encryption is used.
+
+	  Selecting M for this option will compile a helper module
+	  padlock.ko that should autoload all below configured
+	  algorithms. Don't worry if your hardware does not support
+	  some or all of them. In such case padlock.ko will
+	  simply write a single line into the kernel log informing
+	  about its failure but everything will keep working fine.
+
+	  If you are unsure, say M. The compiled module will be
+	  called padlock.ko
 
 config CRYPTO_DEV_PADLOCK_AES
 	tristate "PadLock driver for AES algorithm"
Index: linux-2.6.16.13-xenU/drivers/crypto/Makefile
===================================================================
--- linux-2.6.16.13-xenU.orig/drivers/crypto/Makefile
+++ linux-2.6.16.13-xenU/drivers/crypto/Makefile
@@ -1,2 +1,3 @@
+obj-$(CONFIG_CRYPTO_DEV_PADLOCK) += padlock.o
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK_AES) += padlock-aes.o
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK_SHA) += padlock-sha.o
Index: linux-2.6.16.13-xenU/drivers/crypto/padlock-aes.c
===================================================================
--- linux-2.6.16.13-xenU.orig/drivers/crypto/padlock-aes.c
+++ linux-2.6.16.13-xenU/drivers/crypto/padlock-aes.c
@@ -545,6 +545,3 @@ MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Michal Ludvig");
 
 MODULE_ALIAS("aes-padlock");
-
-/* This module used to be called padlock. */
-MODULE_ALIAS("padlock");
Index: linux-2.6.16.13-xenU/drivers/crypto/padlock.c
===================================================================
--- /dev/null
+++ linux-2.6.16.13-xenU/drivers/crypto/padlock.c
@@ -0,0 +1,80 @@
+/*
+ * Cryptographic API.
+ *
+ * Support for VIA PadLock hardware crypto engine.
+ *
+ * Copyright (c) 2006  Michal Ludvig &lt;michal@logix.cz&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/cryptohash.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include "padlock.h"
+
+#ifdef CONFIG_CRYPTO_DEV_PADLOCK_AES_MODULE
+#define CONFIG_CRYPTO_DEV_PADLOCK_AES
+#endif
+
+#ifdef CONFIG_CRYPTO_DEV_PADLOCK_SHA_MODULE
+#define CONFIG_CRYPTO_DEV_PADLOCK_SHA
+#endif
+
+static int __init padlock_init(void)
+{
+	int success = 0;
+	struct crypto_tfm *tfm;
+
+#ifdef CONFIG_CRYPTO_DEV_PADLOCK_AES
+	tfm = crypto_alloc_tfm("aes-padlock", 0);
+	if (tfm) {
+		success++;
+		crypto_free_tfm(tfm);
+	}
+#endif
+
+#ifdef CONFIG_CRYPTO_DEV_PADLOCK_SHA
+	tfm = crypto_alloc_tfm("sha1-padlock", 0);
+	if (tfm) {
+		success++;
+		crypto_free_tfm(tfm);
+	}
+
+	tfm = crypto_alloc_tfm("sha256-padlock", 0);
+	if (tfm) {
+		success++;
+		crypto_free_tfm(tfm);
+	}
+#endif
+
+	if (!success) {
+		printk(KERN_WARNING PFX "No VIA PadLock drivers have been loaded.\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_NOTICE PFX "%d drivers are available.\n", success);
+
+	return 0;
+}
+
+static void __exit padlock_fini(void)
+{
+}
+
+module_init(padlock_init);
+module_exit(padlock_fini);
+
+MODULE_DESCRIPTION("Load all configured PadLock algorithms.");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Michal Ludvig");
+

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060715012807</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-15 01:28:07-0400</timestampReceived><subject>Re: [1/5] [CRYPTO] padlock: Add compatibility alias after rename</subject><body>

On Fri, Jul 14, 2006 at 06:21:59PM +1200, Michal Ludvig wrote:
&gt;
&gt; +#ifdef CONFIG_CRYPTO_DEV_PADLOCK_AES_MODULE
&gt; +#define CONFIG_CRYPTO_DEV_PADLOCK_AES
&gt; +#endif

Just do it unconditionally.

&gt; +#ifdef CONFIG_CRYPTO_DEV_PADLOCK_AES
&gt; +	tfm = crypto_alloc_tfm("aes-padlock", 0);
&gt; +	if (tfm) {
&gt; +		success++;
&gt; +		crypto_free_tfm(tfm);
&gt; +	}
&gt; +#endif

It's easier to call crypto_alg_available.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060715094823</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-07-15 09:48:23-0400</timestampReceived><subject>Re: [1/5] [CRYPTO] padlock: Add compatibility alias after rename</subject><body>

Herbert Xu wrote:

&gt; It's easier to call crypto_alg_available.

I wasn't aware of this function. Take 2 attached.

Michal

["padlock-load-all.diff" (text/plain)]

Subject: padlock: Helper module padlock.ko

Compile a helper module padlock.ko that will try
to autoload all configured padlock algorithms.

This also provides backward compatibility with 
the ancient times before padlock.ko was renamed 
to padlock-aes.ko

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux-2.6.16.13-xenU/drivers/crypto/Kconfig
===================================================================
--- linux-2.6.16.13-xenU.orig/drivers/crypto/Kconfig
+++ linux-2.6.16.13-xenU/drivers/crypto/Kconfig
@@ -1,9 +1,9 @@
 menu "Hardware crypto devices"
 
 config CRYPTO_DEV_PADLOCK
-	bool "Support for VIA PadLock ACE"
+	tristate "Support for VIA PadLock ACE"
 	depends on CRYPTO &amp;&amp; X86_32
-	default y
+	default m
 	help
 	  Some VIA processors come with an integrated crypto engine
 	  (so called VIA PadLock ACE, Advanced Cryptography Engine)
@@ -11,8 +11,17 @@ config CRYPTO_DEV_PADLOCK
 	  operations with supported algorithms.
 	  
 	  The instructions are used only when the CPU supports them.
-	  Otherwise software encryption is used. If you are unsure,
-	  say Y.
+	  Otherwise software encryption is used.
+
+	  Selecting M for this option will compile a helper module
+	  padlock.ko that should autoload all below configured
+	  algorithms. Don't worry if your hardware does not support
+	  some or all of them. In such case padlock.ko will
+	  simply write a single line into the kernel log informing
+	  about its failure but everything will keep working fine.
+
+	  If you are unsure, say M. The compiled module will be
+	  called padlock.ko
 
 config CRYPTO_DEV_PADLOCK_AES
 	tristate "PadLock driver for AES algorithm"
Index: linux-2.6.16.13-xenU/drivers/crypto/Makefile
===================================================================
--- linux-2.6.16.13-xenU.orig/drivers/crypto/Makefile
+++ linux-2.6.16.13-xenU/drivers/crypto/Makefile
@@ -1,2 +1,3 @@
+obj-$(CONFIG_CRYPTO_DEV_PADLOCK) += padlock.o
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK_AES) += padlock-aes.o
 obj-$(CONFIG_CRYPTO_DEV_PADLOCK_SHA) += padlock-sha.o
Index: linux-2.6.16.13-xenU/drivers/crypto/padlock-aes.c
===================================================================
--- linux-2.6.16.13-xenU.orig/drivers/crypto/padlock-aes.c
+++ linux-2.6.16.13-xenU/drivers/crypto/padlock-aes.c
@@ -545,6 +545,3 @@ MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Michal Ludvig");
 
 MODULE_ALIAS("aes-padlock");
-
-/* This module used to be called padlock. */
-MODULE_ALIAS("padlock");
Index: linux-2.6.16.13-xenU/drivers/crypto/padlock.c
===================================================================
--- /dev/null
+++ linux-2.6.16.13-xenU/drivers/crypto/padlock.c
@@ -0,0 +1,58 @@
+/*
+ * Cryptographic API.
+ *
+ * Support for VIA PadLock hardware crypto engine.
+ *
+ * Copyright (c) 2006  Michal Ludvig &lt;michal@logix.cz&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/cryptohash.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include "padlock.h"
+
+static int __init padlock_init(void)
+{
+	int success = 0;
+
+	if (crypto_alg_available("aes-padlock", 0))
+		success++;
+
+	if (crypto_alg_available("sha1-padlock", 0))
+		success++;
+
+	if (crypto_alg_available("sha256-padlock", 0))
+		success++;
+
+	if (!success) {
+		printk(KERN_WARNING PFX "No VIA PadLock drivers have been loaded.\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_NOTICE PFX "%d drivers are available.\n", success);
+
+	return 0;
+}
+
+static void __exit padlock_fini(void)
+{
+}
+
+module_init(padlock_init);
+module_exit(padlock_fini);
+
+MODULE_DESCRIPTION("Load all configured PadLock algorithms.");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Michal Ludvig");
+

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060714021415</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-07-14 02:14:15-0400</timestampReceived><subject>Re: [CRYPTO] padlock: Fix alignment after aes_ctx rearrange</subject><body>

Michal Ludvig wrote:
&gt; Hi Herbert,
&gt; 
&gt; I just recently discovered that your patch that rearranges struct
&gt; aes_ctx in padlock-aes.c breaks the alignment rules for xcrypt leading
&gt; to GPF Oopses.
&gt; 
&gt; Note that *all* addresses passed to xcrypt must be 16-Bytes aligned for
&gt; VIA C3 (including IV and Key - the latter one was not aligned and
&gt; triggered this Oops).
&gt; 
&gt; As the rearrange patch made it to 2.6.18-rc1 it must be fixed before
&gt; 2.6.18 is out. Attached is a patch.

Ehrm, ... now it is attached ;-)

Michal

["fix-alignment-of-aes_ctx.diff" (text/x-patch)]

Subject: padlock: Fix alignment after aes_ctx rearrange

Herbert's patch 82062c72cd643c99a9e1c231270acbab986fd23f 
in cryptodev-2.6 tree breaks alignment rules for PadLock 
xcrypt instruction leading to General protection Oopses.

This patch fixes the problem.

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux-2.6.16.13-xenU/drivers/crypto/padlock-aes.c
===================================================================
--- linux-2.6.16.13-xenU.orig/drivers/crypto/padlock-aes.c
+++ linux-2.6.16.13-xenU/drivers/crypto/padlock-aes.c
@@ -59,6 +59,9 @@
 #define AES_EXTENDED_KEY_SIZE	64	/* in uint32_t units */
 #define AES_EXTENDED_KEY_SIZE_B	(AES_EXTENDED_KEY_SIZE * sizeof(uint32_t))
 
+/* Whenever making any changes to the following
+ * structure *make sure* you keep E, d_data
+ * and cword aligned on 16 Bytes boundaries!!! */
 struct aes_ctx {
 	struct {
 		struct cword encrypt;
@@ -66,8 +69,10 @@ struct aes_ctx {
 	} cword;
 	u32 *D;
 	int key_length;
-	u32 E[AES_EXTENDED_KEY_SIZE];
-	u32 d_data[AES_EXTENDED_KEY_SIZE];
+	u32 E[AES_EXTENDED_KEY_SIZE]
+		__attribute__ ((__aligned__(PADLOCK_ALIGNMENT)));
+	u32 d_data[AES_EXTENDED_KEY_SIZE]
+		__attribute__ ((__aligned__(PADLOCK_ALIGNMENT)));
 };
 
 /* ====== Key management routines ====== */

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060712012825</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-12 01:28:25-0400</timestampReceived><subject>Re: [2/2] [CRYPTO] padlock: Driver for SHA1 / SHA256 algorithms</subject><body>

On Wed, Jul 12, 2006 at 12:34:37PM +1200, Michal Ludvig wrote:
&gt; Support for SHA1 / SHA256 algorithms in VIA C7 processors.
&gt; 
&gt; Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Both pathces applied.  Thank you Michal.
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060613001326</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-06-13 00:13:26-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686</subject><body>

&gt; Most likely this is caused by missing /dev/console device node on your
&gt; encrypted root partition. Step 17 of April-10-2006 README is supposed to
&gt; make sure that static /dev/console device node exists on your encrypted root
&gt; partition. When udev starts up, it mounts a newly created file system on top
&gt; of /dev, so that original static nodes are unaccessible. So, after udev is
&gt; started, it looks like that there is a /dev/console device node, but your
&gt; real udev-less encrypted file system does not have that device node.
&gt; 

Thanx for prompt answer.
Unfortunately there is nothing more to fix at the moment. All was overwritten
with the ERPOSS4-dm-crypt-experiment and this should survive until better is available.
I try it again next days with a spare-hd right from the very beginning.

&gt; To fix, do this:
&gt; 
&gt; 1)  boot knoppix
&gt; 2)  mount partition where your key file is
&gt; 3)  mount your encrypted root partition on /mnt
&gt; 4)  run these commands:
&gt;         mknod -m 600 /mnt/dev/console c 5 1
&gt;         mknod -m 666 /mnt/dev/null c 1 3
&gt;         mknod -m 666 /mnt/dev/zero c 1 5

I remember that I checked this very carefully but cannot remember whether
they were allready there or whether I made them.

I will give precise feedback in some days.   Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060623205758</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-06-23 20:57:58-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--via crypto-api ?</subject><body>

hello Jari,
I was ill and now I am prepared to fight again for
crypto-root-fs with loop-aes-256.-
I predict about 20 or more hours of compiling and more just for this
single experiment, as the 'dd if....../..55GB@Celeron_1700....notrunc' needs
11 hours alone..........I just want the result.

Question: 
ERPOSS_3.iso looks to use crypto-api and loop-aes-128 and it could
possibly make the problematic work, I installed it several times.
Is it more easily possible to update such an installation towards aes-256-
multikey ?

                             tnx,          reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060626134458</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-06-26 13:44:58-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--via</subject><body>

reverend@Safe-mail.net wrote:
&gt; Question:
&gt; ERPOSS_3.iso looks to use crypto-api and loop-aes-128 and it could
&gt; possibly make the problematic work, I installed it several times.
&gt; Is it more easily possible to update such an installation towards aes-256-
&gt; multikey ?

ERPOSS3-INSTALLATIONS.ISO appears to use kerneli.org cryptoloop, which is
the most broken implementation that you can find anywhere.

Loop-AES can mount such file system like this:

  mount -t ext3 /dev/hda2 /mnt -o loop=/dev/loop0,encryption=AES128,phash=rmd160
                                                  ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^

If you want to convert such filesystem in-place to loop-AES-v3 multi-key,
you can do this on _unmounted_ file system, on KNOPPIX root shell:

  losetup -e AES128 -H rmd160 /dev/loop0 /dev/hda2
          ^^^^^^^^^ ^^^^^^^^^          ^
  losetup -e AES256 -K /boot/rootkey.gpg /dev/loop1 /dev/hda2
          ^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^          ^
  dd if=/dev/loop0 of=/dev/loop1 bs=4096k conv=notrunc
                 ^             ^
  losetup -d /dev/loop0
  losetup -d /dev/loop1

Where /boot/rootkey.gpg is your new gpg-encrypted 65-line key file. You will
also need to upgrade to newer mount/losetup/swapon programs, create new
initrd using build-initrd.sh script, and edit /etc/fstab and bootloader
configurations.
  
My advise is to make a backup of the file system before conversion. If 'dd'
process doing the conversion is interrupted for any reason, then you end up
with file system partially encrypted using new crypto and rest encrypted
with old crypto, which means that it is rendered unreadable/unfixable.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060626220623</emailId><senderName>Mike Dornberger</senderName><senderEmail>mike.dornberger@gmx.de</senderEmail><timestampReceived>2006-06-26 22:06:23-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--via crypto-api ?</subject><body>

Hi,

On Mon, Jun 26, 2006 at 04:44:58PM +0300, Jari Ruusu wrote:
&gt; My advise is to make a backup of the file system before conversion. If
&gt; 'dd' process doing the conversion is interrupted for any reason, then you
&gt; end up with file system partially encrypted using new crypto and rest
&gt; encrypted with old crypto, which means that it is rendered unreadable/
&gt; unfixable.

if dd was able to write it's status:

 a+b records in
 c+d records out
 e bytes transferred in f seconds (g bytes/sec)

(where a, b, c, d, e are non-negative integers and f, g are floats) one can
use dd's seek= and skip= options. (Read the man page!) Also, a SIGUSR1 could
be sent to dd every second or so and then the values of the last output
could be used. Of course some sectors will be total rubbish then, but maybe
some data can be restored, iff the fs isn't corrupted too much after that.

Making backups is the best option, though. :)

Greetings,
 Mike Dornberger

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060628045405</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-06-28 04:54:05-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--NEWTRY</subject><body>

hello,
I startet it completely new with the test-laptop without any loseable data.-
Actual question is now whether I really need patched and self-compiled
mount instead of the "mount 2.12r-10.deb (from sid)" which I am allready
using succesfully with several multikey-partitions on another computer ?

Dietlib, aespipe and gpg are allready statically linked after beeing locally
compiled be me.

I hate patching and prefer using *.deb if possible.
Testsystem is etch with newest updates und 2.6.15-1-686.deb, later to
be compiled, but "mount" is from sid.
I don't want to mess anything and so I make a break until this question is
answered.

      Regards,      Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060628093813</emailId><senderName>Mike Dornberger</senderName><senderEmail>mike.dornberger@gmx.de</senderEmail><timestampReceived>2006-06-28 09:38:13-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--NEWTRY</subject><body>

Hi,

On Wed, Jun 28, 2006 at 12:54:05AM -0400, reverend@Safe-mail.net wrote:
&gt; Actual question is now whether I really need patched and self-compiled
&gt; mount instead of the "mount 2.12r-10.deb (from sid)" which I am allready
&gt; using succesfully with several multikey-partitions on another computer ?

AFAIK the patched versions have some options you need to use the full power
of loop-AES. You might want to take a look at loop-aes-utils that has
patched versions of mount/umount/losetup/swapon.

Greetings,
 Mike

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060628111328</emailId><senderName>Matthias Schniedermeyer</senderName><senderEmail>ms@citd.de</senderEmail><timestampReceived>2006-06-28 11:13:28-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--NEWTRY</subject><body>

reverend@Safe-mail.net wrote:
&gt; hello,
&gt; I startet it completely new with the test-laptop without any loseable data.-
&gt; Actual question is now whether I really need patched and self-compiled
&gt; mount instead of the "mount 2.12r-10.deb (from sid)" which I am allready
&gt; using succesfully with several multikey-partitions on another computer ?
&gt; 
&gt; Dietlib, aespipe and gpg are allready statically linked after beeing locally
&gt; compiled be me.
&gt; 
&gt; I hate patching and prefer using *.deb if possible.
&gt; Testsystem is etch with newest updates und 2.6.15-1-686.deb, later to
&gt; be compiled, but "mount" is from sid.
&gt; I don't want to mess anything and so I make a break until this question is
&gt; answered.

The Package: loop-aes-utils
contains the patched mount/umount/swapon &amp; losetup



-- 
Real Programmers consider "what you see is what you get" to be just as
bad a concept in Text Editors as it is in women. No, the Real Programmer
wants a "you asked for it, you got it" text editor -- complicated,
cryptic, powerful, unforgiving, dangerous.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060701013948</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-07-01 01:39:48-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--NEWTRY-NEW-ERROR</subject><body>

hello,
I made everything new.
The testsystem is a Laptop Celeron-1700, 512 MB, 60 GB-HD;
debian-testing was installed and very carefully everything was made as told
in the loop-AES_README.txt, a protocol was made on another PC containing
even the screen-messages of the testsystem.
All related sources and changes on the testsystem was written to stick
and secured an another PC, it can be published if wanted, especially the
customized build-initrd.sh.

/dev/hda1 = 512 MB, ext2 unencrypted mountpoint     /boot
/dev/hda2 =  4 GB swap now unencrypted and so big for emergency-situations,
/dev/hda3 = 55 GB, ext2 should be encrypted with loop-AES256, MP /

After rebootíng I waitet for the PW to give; instead I got the following crap:
       .............
      mounting /dev/hda3 on /root failed: No such device
       .............
       mounting /root/dev on /dev/.static/dev failed: No such file or directory
       mounting /sys on /root/sys failed: No such file or directory
       mounting /proc on /root/proc failed: No such file or directory
       Target filesystem doesn't have /sbin/init

       Busybox ...............

I was never asked for PW and it looks to me that, again, all related to
build-initrd.sh had failed maximal, last time I stood in the busybox with
no-console, if that was true.

       ANY suggestions from ANYONE ?        Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060701093211</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-07-01 09:32:11-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--NEWTRY-NEW-ERROR</subject><body>

Part_2:
I googled about 7 hours and had the aespipe- and loop-AES-READMEs to
find the right code for mounting my hda3 unter knoppix-4.x, which should be
multi-key-able.
To make it short: I did not find the right sequence anywhere.
What is going on ???????????
Why the talking about Knoppix-in-case-of-crisis when nobody knows the
complicated sequence ?-

I tried (under Knoppix)

mount -t ext2 /dev/hda3 /mnt -o loop=/dev/loop0,encryption=AES256,gpgkey=/mnt/hda1/rootkey.gpg

reaction: mount wrong fs type, bad option, bad ..............

This code is hacked in Terminal as one row.
hda1 ist the unencrypted /boot-partition and I can see the rootkey.gpg
under /mnt/hda1. 
I used loop0 in /etc/fstab for hda3 (which is / ("root")) and in the
build-initrd.sh (where it is loop5 by default).

After sleeping, I will make a dm-crypt-attempt on a 4-GB-Stick.-
If that had success, no more loop-aes for me.

          Good night,           Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060701100303</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-07-01 10:03:03-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing,</subject><body>

reverend@Safe-mail.net wrote:
&gt; After rebootíng I waitet for the PW to give; instead I got the following crap:
&gt;        .............
&gt;       mounting /dev/hda3 on /root failed: No such device
&gt;        .............
&gt;        mounting /root/dev on /dev/.static/dev failed: No such file or directory
&gt;        mounting /sys on /root/sys failed: No such file or directory
&gt;        mounting /proc on /root/proc failed: No such file or directory
&gt;        Target filesystem doesn't have /sbin/init
&gt; 
&gt;        Busybox ...............
&gt; 
&gt; I was never asked for PW and it looks to me that, again, all related to
&gt; build-initrd.sh had failed maximal, last time I stood in the busybox with
&gt; no-console, if that was true.

Your bootloader configuration is wrong. The initrd that your bootloader is
loading is not the one created by build-initrd.sh at all.

Please post your bootloader configuration and build-initrd.sh configuration
parts.

&gt; I tried (under Knoppix)
&gt; 
&gt; mount -t ext2 /dev/hda3 /mnt -o loop=/dev/loop0,encryption=AES256,gpgkey=/mnt/hda1/rootkey.gpg
                          ^^^^                                             ^^^^
Not a very good idea to try to mount something over existing non-empty
directory.
                          
&gt; I used loop0 in /etc/fstab for hda3 (which is / ("root")) and in the
&gt; build-initrd.sh (where it is loop5 by default).

The root loop-device index in build-initrd.sh configuration *must* match the
the one used in /etc/fstab .

Please post your /etc/fstab as well, reading it using knoppix if need be.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060702004513</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-07-02 00:45:13-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--NEWTRY-NEW-ERROR</subject><body>

&gt; &gt; mount -t ext2 /dev/hda3 /mnt -o \
&gt; &gt; loop=/dev/loop0,encryption=AES256,gpgkey=/mnt/hda1/rootkey.gpg
&gt; ^^^^                                             ^^^^
&gt; Not a very good idea to try to mount something over existing non-empty
&gt; directory.

I tried to save/access the crtypted hda3; had I better used aespipe ?
Which sequence should be used, that's the big question ?
I cannot access the hda3 now + yet but I used the saved files I saved after
the editing-work on the testsystem to a usbstick + another PC.
Mistakes where made by me, but I am still shure that the saved files I now read
are the actual ones on the testsystem. All + everything is saved there in case
I must rebuild the whole testsystem again right from the start.

&gt; &gt; I used loop0 in /etc/fstab for hda3 (which is / ("root")) and in the
&gt; &gt; build-initrd.sh (where it is loop5 by default).
&gt; 
&gt; The root loop-device index in build-initrd.sh configuration *must* match the
&gt; the one used in /etc/fstab .

That is clear. I was shure to edited it to loop0, but seeing it now, it really is 5.
First, deadly mistake made by me !

testsystem edited build-initrd.sh, edited, but wrong loop for /, as I see now:

------------cut------------------
### All default-values can be altered via the configfile

# 1 = use devfs, 0 = use classic disk-based device names. If this is
# enabled (USEDEVFS=1) then setting USEPIVOT=1 is also required and kernel
# must be configured with CONFIG_DEVFS_FS=y CONFIG_DEVFS_MOUNT=y
USEDEVFS=0

# 1 = use pivot_root, 0 = use old change_root
# See above header for root= and append= lilo.conf definitions.
# pivot_root is not available on 2.2 and older kernels.
# Always enable pivot_root for 2.4 and later kernels.
USEPIVOT=1

# Unencrypted /boot partition. If devfs is enabled (USEDEVFS=1), this must
# be specified as genuine devfs name.
BOOTDEV=/dev/hda1

# /boot partition file system type
BOOTTYPE=ext2

# Encrypted root partition. If devfs is enabled (USEDEVFS=1), this must
# be specified as genuine devfs name.
CRYPTROOT=/dev/hda3

# root partition file system type
ROOTTYPE=ext2

# Encryption type (AES128 / AES192 / AES256) of root partition
CIPHERTYPE=AES256

# Optional password seed for root partition
#PSEED="-S XXXXXX"

# Optional password iteration count for root partition
#ITERCOUNTK="-C 100"

# This code is passed to cipher transfer function.
LOINIT="-I 0"

# 1 = use gpg key file to mount root partition, 0 = use normal key.
# If this is enabled (USEGPGKEY=1), file named rootkey.gpg or whatever
# GPGKEYFILE is set to must be manually copied to /boot (or to
# EXTERNALGPGDEV device if EXTERNALGPGFILES=1). If rootkey.gpg is not
# encrypted with symmetric cipher, pubring.gpg and secring.gpg must be
# manually copied to /boot (or to EXTERNALGPGDEV device if
# EXTERNALGPGFILES=1).
USEGPGKEY=1

# gpg key filename. Only used if USEGPGKEY=1
GPGKEYFILE=rootkey.gpg

# 1 = mount removable device EXTERNALGPGDEV that contains gpg key files
# 0 = don't mount
EXTERNALGPGFILES=0

# Device name that contains gpg key files. If devfs is
# enabled (USEDEVFS=1), this must be specified as genuine devfs name.
# Only used if EXTERNALGPGFILES=1
EXTERNALGPGDEV=/dev/fd0

# Removable device EXTERNALGPGDEV file system type
# Only used if EXTERNALGPGFILES=1
EXTERNALGPGTYPE=ext2

# 1 = use loop module, 0 = loop driver linked to kernel
USEMODULE=1

# 1 = stop after creating and copying initrd, 0 = also copy tools/libs
INITRDONLY=0

# Source root directory where files are copied from
SOURCEROOT=

# Destination root directory where files are written to.
# Normally this is empty, but if you run this script on some other root
# (i.e. Knoppix live CD), this must be configured to point to directory
# where your about-to-be-encrypted root partition is mounted. This script
# checks that an initrd directory exists there.
DESTINATIONROOT=

# dest-dir below dest-root
DESTINATIONPREFIX=/boot

# Name of created init ram-disk
INITRDGZNAME=initrd.gz

# Encrypted root loop device index (0 ... 7), 5 == /dev/loop5
# Device index must be one character even if max_loop is greater than 8
# _must_ match /etc/fstab entry:   /dev/loop5  /  ext2  defaults,xxxx  0  1
ROOTLOOPINDEX=5

# Temporary loop device index used in this script, 7 == /dev/loop7
TEMPLOOPINDEX=7

# Additional loop module parameters.
# Example: LOOPMODPARAMS="max_loop=8 lo_prealloc=125,5,200"
LOOPMODPARAMS=""

# 1 = load national keyboard layout, 0 = don't load
# You _must_ manually copy correct keyboard layout to /boot/default.kmap
# which must be in uncompressed form. (can not be .gz file)
LOADNATIONALKEYB=0

# Initial delay in seconds before /linuxrc attempts to mount /boot
# partition. Slow devices (USB-sticks) may need some delay.
INITIALDELAY=0

# Delay in seconds before /linuxrc attempts to mount partition containing
# external gpg key files. Slow devices (USB-sticks) may need some delay.
MOUNTDELAY=0

# 1 = prompt for BOOT-TOOLS media and ENTER press before mounting /boot
# 0 = normal case, don't prompt
TOOLSPROMPT=0

# 1 = use "rootsetup" program that executes losetup to initialize loop
# 0 = use normal "losetup" program directly to initialize loop
# If enabled, rootsetup program (+libs) _must_ be manually copied to /boot.
USEROOTSETUP=0

# 1 = use dietlibc to build linuxrc. This permits passing parameters to init.
# 0 = use glibc to build linuxrc. This prevents passing parameters to init
# and includes hacks that may be incompatible with some versions of glibc.
# The dietlibc can be found at http://www.fefe.de/dietlibc/
USEDIETLIBC=1

# 1 = load extra module, 0 = don't load
# If this is enabled, module must be manually copied to
# /boot/modules-KERNELRELEASE/ directory under name like foomatic.o
EXTRAMODULELOAD1=0
EXTRAMODULENAME1="foomatic"
EXTRAMODULEPARAMS1="frobnicator=123 fubar=abc"
# 1 = load extra module, 0 = don't load
EXTRAMODULELOAD2=0
EXTRAMODULENAME2=""
EXTRAMODULEPARAMS2=""
# 1 = load extra module, 0 = don't load
EXTRAMODULELOAD3=0
EXTRAMODULENAME3=""
EXTRAMODULEPARAMS3=""
# 1 = load extra module, 0 = don't load
EXTRAMODULELOAD4=0
EXTRAMODULENAME4=""
EXTRAMODULEPARAMS4=""
# 1 = load extra module, 0 = don't load
EXTRAMODULELOAD5=0
EXTRAMODULENAME5=""
EXTRAMODULEPARAMS5=""

### End of options
-------------cut--------------------



testsystem-/etc/fstab, residing on crypted hda3:

# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;                  &lt;dump&gt;  &lt;pass&gt;

proc                /proc           proc    defaults                                  \
                0       0
/dev/hda3       /                   ext2    defaults,errors=remount-ro             0  \
                1
/dev/hda1       /boot           ext2    defaults                                      \
                0       2
/dev/hda2       none            swap    sw                                            \
                0       0
/dev/hdc         /media/cdrom0   udf,iso9660 user,noauto                     0       \
0 usbdevfs        /proc/bus/usb   usbdevfs devmode=0666                      0       \
                0
/dev/sda         /usbdev           ext2     user,noauto                               \
0       0

Second, deadly mistake made by me: no loop-editing whatsoever !

testsystem-/boot/grub/menu.lst, residing un unencrypted hda1:

---------------cut----------------------------
## ## End Default Options ##

title		Debian GNU/Linux, kernel 2.6.15
root		(hd0,0)
kernel		/vmlinuz-2.6.15 root=/dev/hda3 ro 
initrd		/initrd.img-2.6.15
savedefault
boot

titel           Debian, USEPIVOT=1, 2.6.15
root            (hd0,0)
kernel          /vmlinuz root=100 init=/linuxrc rootfstype=minix
initrd          /initrd.gz  

### END DEBIAN AUTOMAGIC KERNELS LIST
------------------cut-----------------------

Note, that I did not saw the lower kernel on screen, I only saw the upper kernel, \
unable for crypto and, therefore had nothing to choose from.

Is this testsystem still changeable or must it be rebuild from the start ?

       Regards,             Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060702044540</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-07-02 04:45:40-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--continued ....</subject><body>

hello,
I found your reply to another person with a similar problem tonight
(Loop-aes problem or bug, 05.Sept.2005) and did, in the meantime,
the following:

Knoppix is 4.02 with loop-aes-module-2.6.12, V3.0d-1, 
loop-aes-utils wanted to be 2.12p-5 but shows in the text that is 
"based on 3.0c and util-linux 2.12p-4".

1.) boot: knoppix 2 

2.) mkdir /mnt1
      mount -r -t ext2 /dev/hda1 /mnt1

3.) cat /mnt1/rootkey.gpg (it's really there + readable)

4.) mkdir /mnt2
      mount -t ext2 /dev/hda3 /mnt2 -o \                                              \
loop=/dev/loop0,encryption=AES256,gpgkey=/mnt1/rootkey.gpg

PW:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
message under x: wrong fs type .....the usual crap.................

I checked with losetup -a that the loop0 isn't used but no loop was used at all.
I repeated 4.) in case of mistyping with same result.

Knoppix is using the 4 GB temp-partition I normally use.
Is it possible that, because of unencrypted Knoppix-temp, gpg is not working ?
I have no more ideas so far and make a break.

         Regards,        Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060702115443</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-07-02 11:54:43-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing,</subject><body>

reverend@Safe-mail.net wrote:
&gt; I tried to save/access the crtypted hda3; had I better used aespipe ?
&gt; Which sequence should be used, that's the big question ?

To decrypt a partition using aespipe, you need to use exact same command
pipe you used to encrypt it, except that a '-d' decrypt option must be added
to aespipe parameters.

&gt; &gt; The root loop-device index in build-initrd.sh configuration *must* match the
&gt; &gt; the one used in /etc/fstab .
&gt; 
&gt; That is clear. I was shure to edited it to loop0, but seeing it now, it really is 5.
&gt; First, deadly mistake made by me !

Even if /etc/fstab root device is wrong, the computer may still boot, but
init scripts may become seriously confused and puke horrible error messages
at you when init scripts can't find the devices they are supposed to check
and possibly fsck at boot.

&gt; testsystem edited build-initrd.sh, edited, but wrong loop for /, as I see now:

Looks ok to me. (root loop index == 5)

&gt; testsystem-/etc/fstab, residing on crypted hda3:
&gt; 
&gt; # &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;                  &lt;dump&gt;  &lt;pass&gt;
&gt; 
&gt; proc            /proc           proc    defaults                   0       0
&gt; /dev/hda3       /               ext2    defaults,errors=remount-ro 0       1
  ^^^^^^^^^
  /dev/loop5

&gt; /dev/hda1       /boot           ext2    defaults                   0       2
&gt; /dev/hda2       none            swap    sw                         0       0
&gt; /dev/hdc        /media/cdrom0   udf,iso9660 user,noauto            0       0
&gt; usbdevfs        /proc/bus/usb   usbdevfs devmode=0666              0       0
&gt; /dev/sda        /usbdev         ext2    user,noauto                0       0
[snip]
&gt; testsystem-/boot/grub/menu.lst, residing un unencrypted hda1:
[snip]
&gt; titel           Debian, USEPIVOT=1, 2.6.15
  ^^^^^
  title

&gt; root            (hd0,0)
&gt; kernel          /vmlinuz root=100 init=/linuxrc rootfstype=minix
&gt; initrd          /initrd.gz
[snip]
&gt; Note, that I did not saw the lower kernel on screen, I only saw the upper
&gt; kernel, unable for crypto and, therefore had nothing to choose from.

Try fixing that menu.lst typo.

&gt; 1.) boot: knoppix 2
&gt; 
&gt; 2.) mkdir /mnt1
&gt;     mount -r -t ext2 /dev/hda1 /mnt1
&gt; 
&gt; 3.) cat /mnt1/rootkey.gpg (it's really there + readable)
&gt; 
&gt; 4.) mkdir /mnt2
&gt;     mount -t ext2 /dev/hda3 /mnt2 -o loop=/dev/loop0,encryption=AES256,gpgkey=/mnt1/rootkey.gpg
&gt; 
&gt; PW:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
&gt; message under x: wrong fs type .....the usual crap.................

If above mount doesn't work, then it may well be that your filesystem is
messed up quite badly. loop-AES' README example uses AES128. You could try
using encryption=AES128. If AES128 mount works, then you existing initrd.gz
won't work because in build-initrd.sh config key length is specified as
AES256.

What was the exact sequence of commands that you used to encrypt your
partition. If you can remember it correctly, every character, even typos,
then I may be able to help you to undo the damage. But if you can't remember
it exactly, then your file system may be lost.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060703002731</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-07-03 00:27:31-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--continued........</subject><body>

&gt; To decrypt a partition using aespipe, you need to use exact same command
&gt; pipe you used to encrypt it, except that a '-d' decrypt option must be added
&gt; to aespipe parameters.

I encrypted the 55GB-hda3 wird the command from your README.txt, exact
means, that I remembered, after the first try, weeks ago, that the "\" is not to be
typed when written in one long, single row.
I mean the loop-AES-README.txt not the aespipe-Readme.txt.

I hoped that it was/it should have been:

dd if=/dev/hda3 bs=64k | /mnt/aespipe -e AES256 -K /mnt/rootkey -gpg -G / | dd \
of=/dev/hda3 bs=64k conv=notrunc

&gt; &gt; testsystem edited build-initrd.sh, edited, but wrong loop for /, as I see now:

&gt; Looks ok to me. (root loop index == 5)

Yes, it's than O.K. if the editor forgot to type in menu.lst what he forgot to
edit into build-initrd.sh and that was the case with me.....
 
&gt; &gt; testsystem-/etc/fstab, residing on crypted hda3:
&gt; &gt; 
&gt; &gt; # &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;                  &lt;dump&gt;  &lt;pass&gt;
&gt; &gt; 
&gt; &gt; proc            /proc           proc    defaults                   0       0
&gt; &gt; /dev/hda3       /               ext2    defaults,errors=remount-ro 0       1
&gt; ^^^^^^^^^
&gt; /dev/loop5
&gt; 
&gt; &gt; /dev/hda1       /boot           ext2    defaults                   0       2
&gt; &gt; /dev/hda2       none            swap    sw                         0       0
&gt; &gt; /dev/hdc        /media/cdrom0   udf,iso9660 user,noauto            0       0
&gt; &gt; usbdevfs        /proc/bus/usb   usbdevfs devmode=0666              0       0
&gt; &gt; /dev/sda        /usbdev         ext2    user,noauto                0       0

Yes, I understand.

&gt; &gt; testsystem-/boot/grub/menu.lst, residing in unencrypted hda1:
&gt; [snip]
&gt; &gt; titel           Debian, USEPIVOT=1, 2.6.15

&gt; &gt; root            (hd0,0)
&gt; &gt; kernel        /vmlinuz root=100 init=/linuxrc rootfstype=minix
&gt; &gt; initrd          /initrd.gz

&gt; Try fixing that menu.lst typo.

Where + what, I dont' see the mistake now + yet, but mave have learned and used
it before you can mail.

&gt; using encryption=AES128. If AES128 mount works, then you existing initrd.gz
&gt; won't work because in build-initrd.sh config key length is specified as
&gt; AES256.

Before I shredder it all, I try 128.......

&gt; What was the exact sequence of commands that you used to encrypt your
&gt; partition. If you can remember it correctly, every character, even typos,
&gt; then I may be able to help you to undo the damage. But if you can't remember
&gt; it exactly, then your file system may be lost.

See above (dd if.......................notrunc).

FAZIT:
Even me, the perfectionist, made massive mistakes due to unpredictable things
happening in everyday life.....me trying to concentrate while old dog barks
for help.
I allways had good impressions from loop-AES and so I give it another try.
Maybe I am stripping down the test-hd from 55 to 5 GB and 256 to 128 for
speeds-sake but I will give feedback.
And if I really make it, this should be frozen for other debian-users.

                  Regards,         Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060704051647</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-07-04 05:16:47-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--dietlibc ???</subject><body>

hello,
maybe dietlibc is not compilable here and is, therefore, killing build-initrd.sh
and everything.

When I type in (/usr/local/src/dietlibc-0.30) "make", I get enormeus sceens of
messages which could be all and everything, harmless or serious......

When I type "install bin-i386/diet /usr/local/bin", only 1 file called
"diet", 4,9kB, is transported, I don find any other activity and I cannot know
which files of which size have to be where or are important here.
I know that should be a wrapper but where are the libs ?

When I type in
"make install bin-i386/diet /usr/local/bin",
 ^^^^^       
I get under /opt/diet/bin
                           "     /include
                           "     /lib-i386
                           "     /man


When installing the dietlibc.DEB-PAKET, that installed

/usr/lib/diet/lib/libc.so
            "           /libpthread.so
            "           /libdl.so
            "           /libcompat.so
            "           /libm.so   

and even an /etc/diet.ld.conf,------- it's obvious where the libs are.

Which dietlibc-files must be where and, for security, how approx. big
should they be;
How big must the initrd be, if it is well-made by build-initrd.sh ?

                                  Regards, Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060704095826</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-07-04 09:58:26-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing,</subject><body>

reverend@Safe-mail.net wrote:
&gt; I hoped that it was/it should have been:
&gt; 
&gt; dd if=/dev/hda3 bs=64k | /mnt/aespipe -e AES256 -K /mnt/rootkey -gpg -G / | dd \
&gt; of=/dev/hda3 bs=64k conv=notrunc
                                                                  ^^^^
                                                 this does not belong here
What version of aespipe did you use?

    /mnt/aespipe --version

If it is older than 2.3, then it may have used loop-AES-v2 on-disk format to
encrypt your data.

&gt; maybe dietlibc is not compilable here and is, therefore, killing build-initrd.sh
&gt; and everything.
&gt; 
&gt; When I type in (/usr/local/src/dietlibc-0.30) "make", I get enormeus sceens of
&gt; messages which could be all and everything, harmless or serious......

Lots of output from make is normal.
 
&gt; When I type "install bin-i386/diet /usr/local/bin", only 1 file called
&gt; "diet", 4,9kB, is transported, I don find any other activity and I cannot know
&gt; which files of which size have to be where or are important here.
&gt; I know that should be a wrapper but where are the libs ?

If you follow instructions in dietlibc README, you get a small "diet" binary
that is installed in /usr/local/bin/, 5268 bytes on my box. When that "diet"
program is run, it uses additional files from the place where dietlibc
sources were compiled on, /usr/local/src/dietlibc-0.30/ in your case.
Dietlibc compiled programs are statically linked.

&gt; When I type in
&gt; "make install bin-i386/diet /usr/local/bin",
&gt; ^^^^^

That is not what dietlibc README says.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060704100025</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-07-04 10:00:25-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--/dev/loop5..</subject><body>

hello,
with my 3. try, with unclear dietlibc-situation, I got far as never before.

I shrinked my hd-to 5GB and the algo to 128, but with gpg used.
I did not explicitly configured a crypted swap, I just left loop7 in build-initrd.sh.

When I rebooted with the new crypto-kernel, I got no chance to really give
the PW. The messages where:

Uncompressing Linux....O.K. booting the kernel.
Encrypted file system, please supply correct password to continue
  (no chance for me to give the PW)
/dev/loop5: No such device or address
Command "/lib/losetup -e AES128  -I 0 -K /lib/rootkey.gpg -G /lib /dev/loop5 /dev/hda3" returned error

        the last 5 lines are 5-times on the screen

Than no further reaction.

               Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060704103305</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-07-04 10:33:05-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--continued........</subject><body>

hello,

&gt; &gt; dd if=/dev/hda3 bs=64k | /mnt/aespipe -e AES256 -K /mnt/rootkey -gpg -G / | dd \
&gt; &gt; of=/dev/hda3 bs=64k conv=notrunc
&gt; ^^^^
&gt; this does not belong here

On my screen, the 4 "roofs" are showing approx. 1cm right under the word notrunc, I \
do not understand what is false.

Under point 20 of your (loop-AES-)README.txt with date from 10.April 2006
I found this command-sequence I just fetched from the usbstick where it
was, for error-security, cutted + pasted and so include typos from the 3.try.

dd if=/dev/hda3 bs=64k | /mnt/aespipe -e AES128 -K /mnt/rootkey.gpg -G / | dd \
of=/dev/hda3 bs=64k conv=notrunc

Instead of the algo-byte-number I just found no error/difference, sorry.

&gt; What version of aespipe did you use?

2.3b on Testsystem and on PC.

Maybe..............
for debian-dependency-reasons I had to install gnupg.deb and than
compiled the gnupg.tar.bz2 over it and made the other steps. I had a sharp
eye that the self-compiled gnupg-1.4.3 was the last to write and that the patch
was working and gnupg realy resides in the unencrypted /boot.

       Regards,       Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060705105805</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-07-05 10:58:05-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--trying..</subject><body>

reverend@Safe-mail.net wrote:
&gt; Now it looks like there is no loop.ko for the used 2.6.15-kernel und
&gt; /lib/modules, which, unfortunately, resides in the encrypted area of hda3.
&gt; I have the 2.6.15 in use on another PC with multikey, but at the moment I don't
&gt; have THAT right idea.

If you followed README instructions, including step 7 of "encrypting root
partition", then there should be a loop.ko module in
/boot/modules-KERNELRELEASE/ where KERNELRELEASE equals output of "uname -r"
command.
                                                         
To copy that module using knoppix or other bootable/working installation,
you can do this:

  su
  mkdir /mnt2
  mkdir /mnt3
  mount -t ext2 /dev/hda1 /mnt2
  mount -t ext2 /dev/hda3 /mnt3 -o loop=/dev/loop0,encryption=AES128,gpgkey=/mnt2/rootkey.gpg
  mkdir /mnt2/modules-2.6.15
                      ^^^^^^
  cp -p /mnt3/lib/modules/2.6.15/block/loop.ko /mnt2/modules-2.6.15/
                          ^^^^^^                             ^^^^^^
  umount /mnt2
  umount /mnt3

And then reboot.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060709165425</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-07-09 16:54:25-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--success, but....</subject><body>

Before I could read this response, I found a similar way and got access;
luckily the modules where there.........

It worked, but I had to recompile the kernel because the klogd made high load.

I deleted something more from the working and selfcompiled kernel and
name it uname -r-crypto-b and so I did with the initrd.img, the .config and the
directory in /boot/modules, but it do not work anymore.

This new kernel looked not to work and I build it back, but nothing worked anymore at all.

I can acces the crypted /hda3 via knoppix but it looks that everything is there.
Of course I also have access to hda1 (unencrypted /boot).

Is this so fragile that this can happen anytime or a mistake from me ?

I am allways ending in busybox after:

(no PW-prompt)
mount: Mounting /dev/hda3 on /root failed: No such device

                 Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060704024919</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-07-04 02:49:19-0400</timestampReceived><subject>Re: [1/2] [CRYPTO] api: Avoid refilling larval-&gt;adult</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Mon, 3 Jul 2006 20:22:29 +1000

&gt; A couple of bug fixes:

Would you like me to merge these 2 fixes or will you do
so directly with your crypto-2.6 tree?

Either way is fine with me.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060702164037</emailId><senderName>David Miller</senderName><senderEmail>davem@davemloft.net</senderEmail><timestampReceived>2006-07-02 16:40:37-0400</timestampReceived><subject>Re: [4/13] [CRYPTO] api: Added event notification</subject><body>

From: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
Date: Mon, 3 Jul 2006 00:20:31 +1000

&gt; [CRYPTO] api: Added event notification
&gt; 
&gt; This patch adds a notifier chain for algorithm/template registration events.
&gt; This will be used to register compound algorithms such as cbc(aes).  In
&gt; future this will also be passed onto user-space through netlink.
&gt; 
&gt; Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

You're using a blocking notifier because we have all of those
semaphores and stuff to grab here anyways, right?
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060707193258</emailId><senderName></senderName><senderEmail>marketing@symantec-emea.com</senderEmail><timestampReceived>2006-07-07 19:32:58-0400</timestampReceived><subject>BACKUP =?ISO-8859-1?Q?EXEC=99?= 10d: DESIGNED FOR DISK</subject><body>

[Attachment #2 (multipart/alternative)]


BACKUP EXEC™ 10d: DESIGNED FOR DISK

Backup Exec™ 10d for Windows Servers is an industry-leading Windows data protection \
solution designed for disk, providing continuous, cost-effective and certified backup \
and recovery. Backup Exec™ 10d is designed to offer you data protection in one \
solution, reducing complexity and confusion. So you can be sure your company's most \
valuable asset - data - is protected. 

With Backup Exec™ 10d, you'll discover a disk-based data protection solution that is \
                designed to:
* Eliminate backup windows 
* Deliver the industry's first web-based file retrieval
* Provide complete protection. 

JUST ADD DATA!
Since the interface mimics the experience of the most popular Internet search \
engines, it's simple enough for both administrators and end-users to search for and \
retrieve files using a standard web browser.

DOWNLOAD FREE TRIAL
http://www.symantec.com/offer?a_id=24205

FIND OUT MORE
http://www.backupexec.com/emea
-------------------------------------------------------------------------------
DO NOT REPLY TO THIS MESSAGE. You have received this message because you registered \
to get information about Symantec and its products. If you require Customer Service \
or Technical Support, please check the Symantec Web site for contact information at \
http://www.symantec.com

For information on Symantec's Privacy Policy, please click here \
http://www.symantec.com/about/profile/policies/privacy.jsp

To unsubscribe please send an email to unsubscribe@symantec-emea.com


[Attachment #5 (text/html)]

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;HTML&gt;
	&lt;HEAD&gt;
	&lt;meta http-equiv="content-type" content="text/html;charset=iso-8859-1"&gt;
	&lt;TITLE&gt;Symantec: Event Email&lt;/TITLE&gt;
&lt;STYLE TYPE="text/css"&gt;
&lt;!--
BODY {
background-color: #FFFFFF;
margin: 0;
}

BODY, TH, TD {
font-family: Arial, Verdana, Helvetica, "sans-serif";
font-size: 12px;
}

A {
color: #CC6600;
}

A:Visited {
color: #984F05;
}

A:Hover {
color: #CC6600;
}

.TopHeading {
color: #919469;
font-size: 18px;
font-weight: bold;
}

.DetailTable TD {
font-size: 10px;
padding: 6px;
background-color: #F3F3F3;
}


.Gold {
color: #919469;
}

.Orange {
color: #d6700d;
}

P.DottedLine {
background-image: url('http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/DottedLine.jpg');
                
background-repeat: repeat-x;
height: 3px;
margin: 0;
}

A.ContentLink {
font-weight: bold;
text-decoration: none;
color: #E67F1A;
font-size: 11px;
}

LI {
list-style-image: url('http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/GreenBullet.gif');
 }
--&gt;
&lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;body&gt;
&lt;DIV ALIGN="center"&gt;
&lt;P STYLE="color: #999999; padding-top: 5px; margin-bottom: 5px; font-size: 10px;"&gt;If \
you are having problems viewing this email, please  &lt;A \
href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux-crypto@ \
nl.linux.org&amp;squirtID=2821~.~EN3.csv~.~vshots~.~TEMP49&amp;systype=vshots&amp;pageclicked=http://emarketing.advantapro.com/grpdta/veritas/Arc/2764---vshots.html"&gt;click \
here&lt;/A&gt;&lt;/P&gt; &lt;TABLE WIDTH="552" BORDER="0" CELLSPACING="0" CELLPADDING="0"&gt;
&lt;TR&gt;
&lt;TD STYLE="border: 1px solid #CFCFCF;"&gt;
	&lt;TABLE WIDTH="523" BORDER="0" CELLSPACING="0" CELLPADDING="0"&gt;
	&lt;TR&gt;
	&lt;TD&gt;&lt;A href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux \
-crypto@nl.linux.org&amp;squirtID=2821~.~EN3.csv~.~vshots~.~TEMP49&amp;systype=vshots&amp;pageclicked=http://www.symantec.com
 "&gt;&lt;IMG SRC="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/Symantec_Header.jpg" \
ALT="Symantec" WIDTH="550" HEIGHT="69" BORDER="0"&gt;&lt;/A&gt;&lt;/TD&gt;  &lt;/TR&gt;

	&lt;TR&gt;
	&lt;TD STYLE="height: 5px; background-image: \
url('http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/Header_Bottom.jpg'); \
background-repeat: repeat-x;"&gt;&lt;/TD&gt;  &lt;/TR&gt;

	&lt;TR&gt;
	&lt;TD STYLE="border-bottom: 1px solid #CFCFCF;"&gt;
		&lt;TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0"&gt;
		&lt;TR&gt;
		&lt;TD&gt;&lt;A href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linu \
x-crypto@nl.linux.org&amp;squirtID=2821~.~EN3.csv~.~vshots~.~TEMP49&amp;systype=vshots&amp;pageclicked=http://www.symantec.com/offer?a_id=24205"&gt;&lt;IMG \
SRC="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/be10d_header2_en.jpg" \
BORDER="0"&gt;&lt;/A&gt;&lt;/TD&gt;  &lt;TD ALIGN="center" WIDTH="80%"&gt;
			&lt;DIV style="text-align: left;"&gt;
			&lt;/DIV&gt;
		&lt;/TD&gt;
		&lt;/TR&gt;
		&lt;/TABLE&gt;
	&lt;/TD&gt;
	&lt;/TR&gt;
	
	&lt;TR&gt;
	&lt;TD STYLE="padding-left: 30px; padding-right: 30px; padding-top: 20px; \
padding-bottom: 10px; background-image: \
url('http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/DottedLine.jpg'); \
background-repeat: repeat-x; background-position: bottom;"&gt;  &lt;!-- Content Cell --&gt;
			

         
		&lt;P&gt;&lt;b STYLE="font-size: 16px;"&gt;Backup Exec™ 10d for Windows Servers is an \
industry-leading Windows data protection solution designed for disk, providing \
continuous, cost-effective and certified backup and recovery. &lt;/b&gt;&lt;/P&gt;

		With Backup Exec™ 10d, you'll discover a disk-based data protection solution that \
is designed to:


		&lt;!-- Bullet List --&gt;
&lt;BR&gt;
		&lt;TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" STYLE="margin-top: 8px;"&gt;
				&lt;TR VALIGN="top"&gt;
		&lt;TD&gt;&lt;IMG SRC="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/GreenBullet.gif" \
ALT="" WIDTH="25" HEIGHT="14" BORDER="0"&gt;&lt;/TD&gt;  &lt;TD&gt;Eliminate backup windows &lt;/TD&gt;
		&lt;/TR&gt;
		&lt;TR VALIGN="top"&gt;
		&lt;TD&gt;&lt;IMG SRC="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/GreenBullet.gif" \
ALT="" WIDTH="25" HEIGHT="14" BORDER="0"&gt;&lt;/TD&gt;  &lt;TD&gt;Deliver the industry's first \
web-based file retrieval&lt;/TD&gt;  &lt;/TR&gt;
		&lt;TR VALIGN="top"&gt;
		&lt;TD&gt;&lt;IMG SRC="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/GreenBullet.gif" \
ALT="" WIDTH="25" HEIGHT="14" BORDER="0"&gt;&lt;/TD&gt;  &lt;TD&gt;Provide complete protection. Just \
add data &lt;/TD&gt;  &lt;/TR&gt;

		&lt;/TABLE&gt;
		
		&lt;P&gt;With Backup Exec™ 10d, you can also experience the industry's first web-based \
file retrieval.  Since the interface mimics the experience of the most popular \
Internet search engines, it's simple enough for both administrators and end-users to \
search for and retrieve files using a standard web browser. &lt;br&gt;&lt;br&gt;
Backup Exec™ 10d is designed to offer you data protection in one solution, reducing \
complexity and confusion. So you can be sure your company's most valuable asset - \
data - is protected.

&lt;a href='http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux-cryp \
to@nl.linux.org&amp;squirtID=2821~.~EN3.csv~.~vshots~.~TEMP49&amp;systype=vshots&amp;pageclicked=http://www.symantec.com/offer?a_id=24205'&gt;&lt;img \
src='http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/CTA_button.gif' \
border='0' align='right'&gt;&lt;/a&gt;&lt;/P&gt;

		
		
	&lt;!-- End Content Cell --&gt;
	&lt;/TD&gt;
	&lt;/TR&gt;
	
	&lt;TR&gt;
	&lt;TD STYLE="padding-left: 30px; padding-right: 10px; padding-top: 20px; \
padding-bottom: 10px; font-size: 10px; color: #999999;"&gt;  &lt;P&gt;DO NOT REPLY TO THIS \
MESSAGE. You have received this message because you registered to get information \
about Symantec and its products. If you require Customer Service or Technical \
Support, please check the Symantec Web site for contact information at  &lt;A \
href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux-crypto@ \
nl.linux.org&amp;squirtID=2821~.~EN3.csv~.~vshots~.~TEMP49&amp;systype=vshots&amp;pageclicked=http://www.symantec.com"&gt;www.symantec.com&lt;/A&gt;&lt;/P&gt;
 &lt;P&gt;For information on Symantec's Privacy Policy, please  &lt;A \
href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux-crypto@ \
nl.linux.org&amp;squirtID=2821~.~EN3.csv~.~vshots~.~TEMP49&amp;systype=vshots&amp;pageclicked=http://www.symantec.com/about/profile/policies/privacy.jsp"&gt;click \
here.&lt;/A&gt;&lt;/P&gt;

&lt;P&gt;To unsubscribe please &lt;A \
href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux-crypto@ \
nl.linux.org&amp;squirtID=2821~.~EN3.csv~.~vshots~.~TEMP49&amp;systype=vshots&amp;pageclicked=http \
://emarketing.advantapro.com/cgi-bin/unsubme.pl?youremail=linux-crypto@nl.linux.org~an \
d~squirtID=2821~.~EN3.csv~.~vshots~.~TEMP49~and~hiddentoemail_unsub=unsubscribe@symant \
ec-emea.com~and~hiddenyouremail_unsub=linux-crypto@nl.linux.org~and~systype=vshots~and~lettertoedit=BACKUP \
EXEC™ 10d: DESIGNED FOR DISK"&gt;click here&lt;/A&gt;&lt;/P&gt;


	&lt;/TD&gt;
	&lt;/TR&gt;
	&lt;/TABLE&gt;
&lt;/TD&gt;
&lt;/TR&gt;
&lt;/TABLE&gt;
&lt;/DIV&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060710062542</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-10 06:25:42-0400</timestampReceived><subject>[2/5] [CRYPTO] crc32c: Fix unconventional setkey usage</subject><body>

Hi:

[CRYPTO] crc32c: Fix unconventional setkey usage

The convention for setkey is that once it is set it should not change,
in particular, init must not wipe out the key set by it.  In fact, init
should always be used after setkey before any digestion is performed.

The only user of crc32c that sets the key is tcrypt.  This patch adds
the necessary init calls there.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/crc32c.c b/crypto/crc32c.c
--- a/crypto/crc32c.c
+++ b/crypto/crc32c.c
@@ -16,14 +16,14 @@
 #include &lt;linux/string.h&gt;
 #include &lt;linux/crypto.h&gt;
 #include &lt;linux/crc32c.h&gt;
-#include &lt;linux/types.h&gt;
-#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/kernel.h&gt;
 
 #define CHKSUM_BLOCK_SIZE	32
 #define CHKSUM_DIGEST_SIZE	4
 
 struct chksum_ctx {
-	u32 crc;
+	__le32 crc;
+	__le32 key;
 };
 
 /*
@@ -35,7 +35,7 @@ static void chksum_init(struct crypto_tf
 {
 	struct chksum_ctx *mctx = crypto_tfm_ctx(tfm);
 
-	mctx-&gt;crc = ~(u32)0;			/* common usage */
+	mctx-&gt;crc = mctx-&gt;key;
 }
 
 /*
@@ -53,7 +53,7 @@ static int chksum_setkey(struct crypto_t
 			*flags = CRYPTO_TFM_RES_BAD_KEY_LEN;
 		return -EINVAL;
 	}
-	mctx-&gt;crc = __cpu_to_le32(*(u32 *)key);
+	mctx-&gt;key = cpu_to_le32(*(u32 *)key);
 	return 0;
 }
 
@@ -61,19 +61,23 @@ static void chksum_update(struct crypto_
 			  unsigned int length)
 {
 	struct chksum_ctx *mctx = crypto_tfm_ctx(tfm);
-	u32 mcrc;
 
-	mcrc = crc32c(mctx-&gt;crc, data, (size_t)length);
-
-	mctx-&gt;crc = mcrc;
+	mctx-&gt;crc = (__le32)crc32c((u32)mctx-&gt;crc, data, length);
 }
 
 static void chksum_final(struct crypto_tfm *tfm, u8 *out)
 {
 	struct chksum_ctx *mctx = crypto_tfm_ctx(tfm);
-	u32 mcrc = (mctx-&gt;crc ^ ~(u32)0);
 	
-	*(u32 *)out = __le32_to_cpu(mcrc);
+	*(u32 *)out = ~le32_to_cpu(mctx-&gt;crc);
+}
+
+static int crc32c_cra_init(struct crypto_tfm *tfm)
+{
+	struct chksum_ctx *mctx = crypto_tfm_ctx(tfm);
+
+	mctx-&gt;key = ~0;
+	return 0;
 }
 
 static struct crypto_alg alg = {
@@ -83,6 +87,7 @@ static struct crypto_alg alg = {
 	.cra_ctxsize	=	sizeof(struct chksum_ctx),
 	.cra_module	=	THIS_MODULE,
 	.cra_list	=	LIST_HEAD_INIT(alg.cra_list),
+	.cra_init	=	crc32c_cra_init,
 	.cra_u		=	{
 		.digest = {
 			 .dia_digestsize=	CHKSUM_DIGEST_SIZE,
diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -724,6 +724,7 @@ static void test_crc32c(void)
 
 	seed = SEEDTESTVAL;
 	(void)crypto_digest_setkey(tfm, (const u8*)&amp;seed, sizeof(u32));
+	crypto_digest_init(tfm);
 	crypto_digest_final(tfm, (u8*)&amp;crc);
 	printk("testing crc32c setkey returns %08x : %s\n", crc, (crc == (SEEDTESTVAL ^ ~(u32)0)) ?
 	       "pass" : "ERROR");
@@ -735,6 +736,7 @@ static void test_crc32c(void)
 	for (i = 0; i &lt; NUMVEC; i++) {
 		seed = ~(u32)0;
 		(void)crypto_digest_setkey(tfm, (const u8*)&amp;seed, sizeof(u32));
+		crypto_digest_init(tfm);
 		crypto_digest_update(tfm, &amp;sg[i], 1);
 		crypto_digest_final(tfm, (u8*)&amp;crc);
 		if (crc == vec_results[i]) {
@@ -750,6 +752,7 @@ static void test_crc32c(void)
 	for (i = 0; i &lt; NUMVEC; i++) {
 		seed = (crc ^ ~(u32)0);
 		(void)crypto_digest_setkey(tfm, (const u8*)&amp;seed, sizeof(u32));
+		crypto_digest_init(tfm);
 		crypto_digest_update(tfm, &amp;sg[i], 1);
 		crypto_digest_final(tfm, (u8*)&amp;crc);
 	}
@@ -763,6 +766,7 @@ static void test_crc32c(void)
 	printk("\ntesting crc32c using digest:\n");
 	seed = ~(u32)0;
 	(void)crypto_digest_setkey(tfm, (const u8*)&amp;seed, sizeof(u32));
+	crypto_digest_init(tfm);
 	crypto_digest_digest(tfm, sg, NUMVEC, (u8*)&amp;crc);
 	if (crc == tot_vec_results) {
 		printk(" %08x:OK", crc);
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060710062614</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-10 06:26:14-0400</timestampReceived><subject>[3/5] [CRYPTO] api: Get rid of flags argument to setkey</subject><body>

Hi:

[CRYPTO] api: Get rid of flags argument to setkey

Now that the tfm is passed directly to setkey instead of the ctx, we no
longer need to pass the &amp;tfm-&gt;crt_flags pointer.

This patch also gets rid of a few unnecessary checks on the key length
for ciphers as the cipher layer guarantees that the key length is within
the bounds specified by the algorithm.

Rather than testing dia_setkey every time, this patch does it only once
during crypto_alloc_tfm.  The redundant check from crypto_digest_setkey
is also removed.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/arch/i386/crypto/aes.c b/arch/i386/crypto/aes.c
--- a/arch/i386/crypto/aes.c
+++ b/arch/i386/crypto/aes.c
@@ -379,12 +379,13 @@ static void gen_tabs(void)
 }
 
 static int aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,
-		       unsigned int key_len, u32 *flags)
+		       unsigned int key_len)
 {
 	int i;
 	u32 ss[8];
 	struct aes_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *key = (const __le32 *)in_key;
+	u32 *flags = &amp;tfm-&gt;crt_flags;
 
 	/* encryption schedule */
 	
diff --git a/arch/s390/crypto/aes_s390.c b/arch/s390/crypto/aes_s390.c
--- a/arch/s390/crypto/aes_s390.c
+++ b/arch/s390/crypto/aes_s390.c
@@ -38,9 +38,10 @@ struct s390_aes_ctx {
 };
 
 static int aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,
-		       unsigned int key_len, u32 *flags)
+		       unsigned int key_len)
 {
 	struct s390_aes_ctx *sctx = crypto_tfm_ctx(tfm);
+	u32 *flags = &amp;tfm-&gt;crt_flags;
 
 	switch (key_len) {
 	case 16:
diff --git a/arch/s390/crypto/des_s390.c b/arch/s390/crypto/des_s390.c
--- a/arch/s390/crypto/des_s390.c
+++ b/arch/s390/crypto/des_s390.c
@@ -45,9 +45,10 @@ struct crypt_s390_des3_192_ctx {
 };
 
 static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
-		      unsigned int keylen, u32 *flags)
+		      unsigned int keylen)
 {
 	struct crypt_s390_des_ctx *dctx = crypto_tfm_ctx(tfm);
+	u32 *flags = &amp;tfm-&gt;crt_flags;
 	int ret;
 
 	/* test if key is valid (not a weak key) */
@@ -167,11 +168,12 @@ static struct crypto_alg des_alg = {
  *
  */
 static int des3_128_setkey(struct crypto_tfm *tfm, const u8 *key,
-			   unsigned int keylen, u32 *flags)
+			   unsigned int keylen)
 {
 	int i, ret;
 	struct crypt_s390_des3_128_ctx *dctx = crypto_tfm_ctx(tfm);
-	const u8* temp_key = key;
+	const u8 *temp_key = key;
+	u32 *flags = &amp;tfm-&gt;crt_flags;
 
 	if (!(memcmp(key, &amp;key[DES_KEY_SIZE], DES_KEY_SIZE))) {
 		*flags |= CRYPTO_TFM_RES_BAD_KEY_SCHED;
@@ -303,11 +305,12 @@ static struct crypto_alg des3_128_alg = 
  *
  */
 static int des3_192_setkey(struct crypto_tfm *tfm, const u8 *key,
-			   unsigned int keylen, u32 *flags)
+			   unsigned int keylen)
 {
 	int i, ret;
 	struct crypt_s390_des3_192_ctx *dctx = crypto_tfm_ctx(tfm);
-	const u8* temp_key = key;
+	const u8 *temp_key = key;
+	u32 *flags = &amp;tfm-&gt;crt_flags;
 
 	if (!(memcmp(key, &amp;key[DES_KEY_SIZE], DES_KEY_SIZE) &amp;&amp;
 	    memcmp(&amp;key[DES_KEY_SIZE], &amp;key[DES_KEY_SIZE * 2],
diff --git a/arch/x86_64/crypto/aes.c b/arch/x86_64/crypto/aes.c
--- a/arch/x86_64/crypto/aes.c
+++ b/arch/x86_64/crypto/aes.c
@@ -228,13 +228,14 @@ static void __init gen_tabs(void)
 }
 
 static int aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,
-		       unsigned int key_len, u32 *flags)
+		       unsigned int key_len)
 {
 	struct aes_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *key = (const __le32 *)in_key;
+	u32 *flags = &amp;tfm-&gt;crt_flags;
 	u32 i, j, t, u, v, w;
 
-	if (key_len != 16 &amp;&amp; key_len != 24 &amp;&amp; key_len != 32) {
+	if (key_len % 8) {
 		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
 		return -EINVAL;
 	}
diff --git a/crypto/aes.c b/crypto/aes.c
--- a/crypto/aes.c
+++ b/crypto/aes.c
@@ -249,13 +249,14 @@ gen_tabs (void)
 }
 
 static int aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,
-		       unsigned int key_len, u32 *flags)
+		       unsigned int key_len)
 {
 	struct aes_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *key = (const __le32 *)in_key;
+	u32 *flags = &amp;tfm-&gt;crt_flags;
 	u32 i, t, u, v, w;
 
-	if (key_len != 16 &amp;&amp; key_len != 24 &amp;&amp; key_len != 32) {
+	if (key_len % 8) {
 		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
 		return -EINVAL;
 	}
diff --git a/crypto/anubis.c b/crypto/anubis.c
--- a/crypto/anubis.c
+++ b/crypto/anubis.c
@@ -461,10 +461,11 @@ static const u32 rc[] = {
 };
 
 static int anubis_setkey(struct crypto_tfm *tfm, const u8 *in_key,
-			 unsigned int key_len, u32 *flags)
+			 unsigned int key_len)
 {
 	struct anubis_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __be32 *key = (const __be32 *)in_key;
+	u32 *flags = &amp;tfm-&gt;crt_flags;
 	int N, R, i, r;
 	u32 kappa[ANUBIS_MAX_N];
 	u32 inter[ANUBIS_MAX_N];
diff --git a/crypto/arc4.c b/crypto/arc4.c
--- a/crypto/arc4.c
+++ b/crypto/arc4.c
@@ -25,7 +25,7 @@ struct arc4_ctx {
 };
 
 static int arc4_set_key(struct crypto_tfm *tfm, const u8 *in_key,
-			unsigned int key_len, u32 *flags)
+			unsigned int key_len)
 {
 	struct arc4_ctx *ctx = crypto_tfm_ctx(tfm);
 	int i, j = 0, k = 0;
diff --git a/crypto/blowfish.c b/crypto/blowfish.c
--- a/crypto/blowfish.c
+++ b/crypto/blowfish.c
@@ -399,8 +399,7 @@ static void bf_decrypt(struct crypto_tfm
 /* 
  * Calculates the blowfish S and P boxes for encryption and decryption.
  */
-static int bf_setkey(struct crypto_tfm *tfm, const u8 *key,
-		     unsigned int keylen, u32 *flags)
+static int bf_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
 {
 	struct bf_ctx *ctx = crypto_tfm_ctx(tfm);
 	u32 *P = ctx-&gt;p;
diff --git a/crypto/cast5.c b/crypto/cast5.c
--- a/crypto/cast5.c
+++ b/crypto/cast5.c
@@ -769,8 +769,7 @@ static void key_schedule(u32 * x, u32 * 
 }
 
 
-static int cast5_setkey(struct crypto_tfm *tfm, const u8 *key,
-			unsigned key_len, u32 *flags)
+static int cast5_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned key_len)
 {
 	struct cast5_ctx *c = crypto_tfm_ctx(tfm);
 	int i;
@@ -778,11 +777,6 @@ static int cast5_setkey(struct crypto_tf
 	u32 z[4];
 	u32 k[16];
 	__be32 p_key[4];
-	
-	if (key_len &lt; 5 || key_len &gt; 16) {
-		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
-		return -EINVAL;
-	}
 
 	c-&gt;rr = key_len &lt;= 10 ? 1 : 0;
 
diff --git a/crypto/cast6.c b/crypto/cast6.c
--- a/crypto/cast6.c
+++ b/crypto/cast6.c
@@ -382,14 +382,15 @@ static inline void W(u32 *key, unsigned 
 }
 
 static int cast6_setkey(struct crypto_tfm *tfm, const u8 *in_key,
-			unsigned key_len, u32 *flags)
+			unsigned key_len)
 {
 	int i;
 	u32 key[8];
 	__be32 p_key[8]; /* padded key */
 	struct cast6_ctx *c = crypto_tfm_ctx(tfm);
+	u32 *flags = &amp;tfm-&gt;crt_flags;
 
-	if (key_len &lt; 16 || key_len &gt; 32 || key_len % 4 != 0) {
+	if (key_len % 4 != 0) {
 		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
 		return -EINVAL;
 	}	
diff --git a/crypto/cipher.c b/crypto/cipher.c
--- a/crypto/cipher.c
+++ b/crypto/cipher.c
@@ -264,12 +264,12 @@ static int setkey(struct crypto_tfm *tfm
 {
 	struct cipher_alg *cia = &amp;tfm-&gt;__crt_alg-&gt;cra_cipher;
 	
+	tfm-&gt;crt_flags &amp;= ~CRYPTO_TFM_RES_MASK;
 	if (keylen &lt; cia-&gt;cia_min_keysize || keylen &gt; cia-&gt;cia_max_keysize) {
 		tfm-&gt;crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
 		return -EINVAL;
 	} else
-		return cia-&gt;cia_setkey(tfm, key, keylen,
-		                       &amp;tfm-&gt;crt_flags);
+		return cia-&gt;cia_setkey(tfm, key, keylen);
 }
 
 static int ecb_encrypt(struct crypto_tfm *tfm,
diff --git a/crypto/crc32c.c b/crypto/crc32c.c
--- a/crypto/crc32c.c
+++ b/crypto/crc32c.c
@@ -44,13 +44,12 @@ static void chksum_init(struct crypto_tf
  * the seed.
  */
 static int chksum_setkey(struct crypto_tfm *tfm, const u8 *key,
-			 unsigned int keylen, u32 *flags)
+			 unsigned int keylen)
 {
 	struct chksum_ctx *mctx = crypto_tfm_ctx(tfm);
 
 	if (keylen != sizeof(mctx-&gt;crc)) {
-		if (flags)
-			*flags = CRYPTO_TFM_RES_BAD_KEY_LEN;
+		tfm-&gt;crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
 		return -EINVAL;
 	}
 	mctx-&gt;key = cpu_to_le32(*(u32 *)key);
diff --git a/crypto/crypto_null.c b/crypto/crypto_null.c
--- a/crypto/crypto_null.c
+++ b/crypto/crypto_null.c
@@ -48,7 +48,7 @@ static void null_final(struct crypto_tfm
 { }
 
 static int null_setkey(struct crypto_tfm *tfm, const u8 *key,
-		       unsigned int keylen, u32 *flags)
+		       unsigned int keylen)
 { return 0; }
 
 static void null_crypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
diff --git a/crypto/des.c b/crypto/des.c
--- a/crypto/des.c
+++ b/crypto/des.c
@@ -784,9 +784,10 @@ static void dkey(u32 *pe, const u8 *k)
 }
 
 static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
-		      unsigned int keylen, u32 *flags)
+		      unsigned int keylen)
 {
 	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
+	u32 *flags = &amp;tfm-&gt;crt_flags;
 	u32 tmp[DES_EXPKEY_WORDS];
 	int ret;
 
@@ -864,11 +865,12 @@ static void des_decrypt(struct crypto_tf
  *
  */
 static int des3_ede_setkey(struct crypto_tfm *tfm, const u8 *key,
-			   unsigned int keylen, u32 *flags)
+			   unsigned int keylen)
 {
 	const u32 *K = (const u32 *)key;
 	struct des3_ede_ctx *dctx = crypto_tfm_ctx(tfm);
 	u32 *expkey = dctx-&gt;expkey;
+	u32 *flags = &amp;tfm-&gt;crt_flags;
 
 	if (unlikely(!((K[0] ^ K[2]) | (K[1] ^ K[3])) ||
 		     !((K[2] ^ K[4]) | (K[3] ^ K[5]))))
diff --git a/crypto/digest.c b/crypto/digest.c
--- a/crypto/digest.c
+++ b/crypto/digest.c
@@ -71,12 +71,16 @@ static void final(struct crypto_tfm *tfm
 		tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(tfm, out);
 }
 
+static int nosetkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
+{
+	tfm-&gt;crt_flags &amp;= ~CRYPTO_TFM_RES_MASK;
+	return -ENOSYS;
+}
+
 static int setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
 {
-	u32 flags;
-	if (tfm-&gt;__crt_alg-&gt;cra_digest.dia_setkey == NULL)
-		return -ENOSYS;
-	return tfm-&gt;__crt_alg-&gt;cra_digest.dia_setkey(tfm, key, keylen, &amp;flags);
+	tfm-&gt;crt_flags &amp;= ~CRYPTO_TFM_RES_MASK;
+	return tfm-&gt;__crt_alg-&gt;cra_digest.dia_setkey(tfm, key, keylen);
 }
 
 static void digest(struct crypto_tfm *tfm,
@@ -104,7 +108,7 @@ int crypto_init_digest_ops(struct crypto
 	ops-&gt;dit_final	= crypto_tfm_alg_alignmask(tfm) ? dalg-&gt;dia_final :
 							  final;
 	ops-&gt;dit_digest	= dalg-&gt;dia_digest ?: digest;
-	ops-&gt;dit_setkey	= setkey;
+	ops-&gt;dit_setkey	= dalg-&gt;dia_setkey ? setkey : nosetkey;
 	
 	return 0;
 }
diff --git a/crypto/hmac.c b/crypto/hmac.c
--- a/crypto/hmac.c
+++ b/crypto/hmac.c
@@ -35,8 +35,7 @@ static inline struct crypto_hmac_ctx *cr
 }
 
 static int crypto_hmac_digest_setkey(struct crypto_tfm *parent,
-				     const u8 *inkey, unsigned int keylen,
-				     u32 *flags)
+				     const u8 *inkey, unsigned int keylen)
 {
 	int bs = crypto_tfm_alg_blocksize(parent);
 	char *key = crypto_tfm_ctx_aligned(parent);
diff --git a/crypto/khazad.c b/crypto/khazad.c
--- a/crypto/khazad.c
+++ b/crypto/khazad.c
@@ -755,19 +755,13 @@ static const u64 c[KHAZAD_ROUNDS + 1] = 
 };
 
 static int khazad_setkey(struct crypto_tfm *tfm, const u8 *in_key,
-			 unsigned int key_len, u32 *flags)
+			 unsigned int key_len)
 {
 	struct khazad_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __be32 *key = (const __be32 *)in_key;
 	int r;
 	const u64 *S = T7;
 	u64 K2, K1;
-	
-	if (key_len != 16)
-	{
-		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
-		return -EINVAL;
-	}
 
 	/* key is supposed to be 32-bit aligned */
 	K2 = ((u64)be32_to_cpu(key[0]) &lt;&lt; 32) | be32_to_cpu(key[1]);
diff --git a/crypto/michael_mic.c b/crypto/michael_mic.c
--- a/crypto/michael_mic.c
+++ b/crypto/michael_mic.c
@@ -123,14 +123,13 @@ static void michael_final(struct crypto_
 
 
 static int michael_setkey(struct crypto_tfm *tfm, const u8 *key,
-			  unsigned int keylen, u32 *flags)
+			  unsigned int keylen)
 {
 	struct michael_mic_ctx *mctx = crypto_tfm_ctx(tfm);
 	const __le32 *data = (const __le32 *)key;
 
 	if (keylen != 8) {
-		if (flags)
-			*flags = CRYPTO_TFM_RES_BAD_KEY_LEN;
+		tfm-&gt;crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
 		return -EINVAL;
 	}
 
diff --git a/crypto/serpent.c b/crypto/serpent.c
--- a/crypto/serpent.c
+++ b/crypto/serpent.c
@@ -216,7 +216,7 @@ struct serpent_ctx {
 
 
 static int serpent_setkey(struct crypto_tfm *tfm, const u8 *key,
-			  unsigned int keylen, u32 *flags)
+			  unsigned int keylen)
 {
 	struct serpent_ctx *ctx = crypto_tfm_ctx(tfm);
 	u32 *k = ctx-&gt;expkey;
@@ -224,13 +224,6 @@ static int serpent_setkey(struct crypto_
 	u32 r0,r1,r2,r3,r4;
 	int i;
 
-	if ((keylen &lt; SERPENT_MIN_KEY_SIZE)
-			|| (keylen &gt; SERPENT_MAX_KEY_SIZE))
-	{
-		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
-		return -EINVAL;
-	}
-
 	/* Copy key, add padding */
 
 	for (i = 0; i &lt; keylen; ++i)
@@ -497,21 +490,15 @@ static struct crypto_alg serpent_alg = {
 };
 
 static int tnepres_setkey(struct crypto_tfm *tfm, const u8 *key,
-			  unsigned int keylen, u32 *flags)
+			  unsigned int keylen)
 {
 	u8 rev_key[SERPENT_MAX_KEY_SIZE];
 	int i;
 
-	if ((keylen &lt; SERPENT_MIN_KEY_SIZE)
-	    || (keylen &gt; SERPENT_MAX_KEY_SIZE)) {
-		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
-		return -EINVAL;
-	} 
-
 	for (i = 0; i &lt; keylen; ++i)
 		rev_key[keylen - i - 1] = key[i];
  
-	return serpent_setkey(tfm, rev_key, keylen, flags);
+	return serpent_setkey(tfm, rev_key, keylen);
 }
 
 static void tnepres_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
diff --git a/crypto/tea.c b/crypto/tea.c
--- a/crypto/tea.c
+++ b/crypto/tea.c
@@ -46,16 +46,10 @@ struct xtea_ctx {
 };
 
 static int tea_setkey(struct crypto_tfm *tfm, const u8 *in_key,
-		      unsigned int key_len, u32 *flags)
+		      unsigned int key_len)
 {
 	struct tea_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *key = (const __le32 *)in_key;
-	
-	if (key_len != 16)
-	{
-		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
-		return -EINVAL;
-	}
 
 	ctx-&gt;KEY[0] = le32_to_cpu(key[0]);
 	ctx-&gt;KEY[1] = le32_to_cpu(key[1]);
@@ -125,16 +119,10 @@ static void tea_decrypt(struct crypto_tf
 }
 
 static int xtea_setkey(struct crypto_tfm *tfm, const u8 *in_key,
-		       unsigned int key_len, u32 *flags)
+		       unsigned int key_len)
 {
 	struct xtea_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *key = (const __le32 *)in_key;
-	
-	if (key_len != 16)
-	{
-		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
-		return -EINVAL;
-	}
 
 	ctx-&gt;KEY[0] = le32_to_cpu(key[0]);
 	ctx-&gt;KEY[1] = le32_to_cpu(key[1]);
diff --git a/crypto/twofish_common.c b/crypto/twofish_common.c
--- a/crypto/twofish_common.c
+++ b/crypto/twofish_common.c
@@ -580,11 +580,11 @@ static const u8 calc_sb_tbl[512] = {
    ctx-&gt;a[(j) + 1] = rol32(y, 9)
 
 /* Perform the key setup. */
-int twofish_setkey(struct crypto_tfm *tfm, const u8 *key,
-		   unsigned int key_len, u32 *flags)
+int twofish_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int key_len)
 {
 
 	struct twofish_ctx *ctx = crypto_tfm_ctx(tfm);
+	u32 *flags = &amp;tfm-&gt;crt_flags;
 
 	int i, j, k;
 
@@ -600,7 +600,7 @@ int twofish_setkey(struct crypto_tfm *tf
 	u8 tmp;
 
 	/* Check key length. */
-	if (key_len != 16 &amp;&amp; key_len != 24 &amp;&amp; key_len != 32)
+	if (key_len % 8)
 	{
 		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
 		return -EINVAL; /* unsupported key length */
diff --git a/drivers/crypto/padlock-aes.c b/drivers/crypto/padlock-aes.c
--- a/drivers/crypto/padlock-aes.c
+++ b/drivers/crypto/padlock-aes.c
@@ -292,15 +292,16 @@ static inline struct aes_ctx *aes_ctx(st
 }
 
 static int aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,
-		       unsigned int key_len, u32 *flags)
+		       unsigned int key_len)
 {
 	struct aes_ctx *ctx = aes_ctx(tfm);
 	const __le32 *key = (const __le32 *)in_key;
+	u32 *flags = &amp;tfm-&gt;crt_flags;
 	uint32_t i, t, u, v, w;
 	uint32_t P[AES_EXTENDED_KEY_SIZE];
 	uint32_t rounds;
 
-	if (key_len != 16 &amp;&amp; key_len != 24 &amp;&amp; key_len != 32) {
+	if (key_len % 8) {
 		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
 		return -EINVAL;
 	}
diff --git a/include/crypto/twofish.h b/include/crypto/twofish.h
--- a/include/crypto/twofish.h
+++ b/include/crypto/twofish.h
@@ -17,7 +17,6 @@ struct twofish_ctx {
 	u32 s[4][256], w[8], k[32];
 };
 
-int twofish_setkey(struct crypto_tfm *tfm, const u8 *key,
-		   unsigned int key_len, u32 *flags);
+int twofish_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int key_len);
 
 #endif
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -85,7 +85,7 @@ struct cipher_alg {
 	unsigned int cia_min_keysize;
 	unsigned int cia_max_keysize;
 	int (*cia_setkey)(struct crypto_tfm *tfm, const u8 *key,
-	                  unsigned int keylen, u32 *flags);
+	                  unsigned int keylen);
 	void (*cia_encrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
 	void (*cia_decrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
 
@@ -114,7 +114,7 @@ struct digest_alg {
 	void (*dia_digest)(struct crypto_tfm *tfm, struct scatterlist *sg,
 	                   unsigned int nsg, u8 *out);
 	int (*dia_setkey)(struct crypto_tfm *tfm, const u8 *key,
-	                  unsigned int keylen, u32 *flags);
+	                  unsigned int keylen);
 };
 
 struct compress_alg {
@@ -387,8 +387,6 @@ static inline int crypto_digest_setkey(s
                                        const u8 *key, unsigned int keylen)
 {
 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
-	if (tfm-&gt;crt_digest.dit_setkey == NULL)
-		return -ENOSYS;
 	return tfm-&gt;crt_digest.dit_setkey(tfm, key, keylen);
 }
 
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060710062640</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-10 06:26:40-0400</timestampReceived><subject>[4/5] [CRYPTO] digest: Store temporary digest in tfm</subject><body>

Hi:

[CRYPTO] digest: Store temporary digest in tfm

When the final result location is unaligned, we store the digest in a
temporary buffer before copying it to the final location.  Currently
that buffer sits on the stack.  This patch moves it to an area in the
tfm, just like the CBC IV buffer.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/digest.c b/crypto/digest.c
--- a/crypto/digest.c
+++ b/crypto/digest.c
@@ -61,14 +61,18 @@ static void update(struct crypto_tfm *tf
 static void final(struct crypto_tfm *tfm, u8 *out)
 {
 	unsigned long alignmask = crypto_tfm_alg_alignmask(tfm);
+	struct digest_alg *digest = &amp;tfm-&gt;__crt_alg-&gt;cra_digest;
+
 	if (unlikely((unsigned long)out &amp; alignmask)) {
-		unsigned int size = crypto_tfm_alg_digestsize(tfm);
-		u8 buffer[size + alignmask];
-		u8 *dst = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
-		tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(tfm, dst);
-		memcpy(out, dst, size);
+		unsigned long align = alignmask + 1;
+		unsigned long addr = (unsigned long)crypto_tfm_ctx(tfm);
+		u8 *dst = (u8 *)ALIGN(addr, align) +
+			  ALIGN(tfm-&gt;__crt_alg-&gt;cra_ctxsize, align);
+
+		digest-&gt;dia_final(tfm, dst);
+		memcpy(out, dst, digest-&gt;dia_digestsize);
 	} else
-		tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(tfm, out);
+		digest-&gt;dia_final(tfm, out);
 }
 
 static int nosetkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
diff --git a/crypto/internal.h b/crypto/internal.h
--- a/crypto/internal.h
+++ b/crypto/internal.h
@@ -107,7 +107,14 @@ static inline void crypto_init_proc(void
 static inline unsigned int crypto_digest_ctxsize(struct crypto_alg *alg,
 						 int flags)
 {
-	return alg-&gt;cra_ctxsize;
+	unsigned int len = alg-&gt;cra_ctxsize;
+
+	if (alg-&gt;cra_alignmask) {
+		len = ALIGN(len, (unsigned long)alg-&gt;cra_alignmask + 1);
+		len += alg-&gt;cra_digest.dia_digestsize;
+	}
+
+	return len;
 }
 
 static inline unsigned int crypto_cipher_ctxsize(struct crypto_alg *alg,
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060710062707</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-10 06:27:07-0400</timestampReceived><subject>[5/5] [CRYPTO] digest: Fix dit_final typo and remove dia_digest</subject><body>

Hi:

[CRYPTO] digest: Fix dit_final typo and remove dia_digest

The choice of dia_final versus final for dit_final was reversed.  This
patch fixes that.

It also removes dia_digest since it turns out that the only potential
user for it, padlock-sha + IPsec, wouldn't work because it just so
happens that for ESP the hash offset is off the encryption offset by
24 bytes for AES.  Since padlock requires the input to be 16-byte
aligned, at least one of them (or both) will have to cope with copying.

If something else needs it in future we can always add it back.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/digest.c b/crypto/digest.c
--- a/crypto/digest.c
+++ b/crypto/digest.c
@@ -109,9 +109,9 @@ int crypto_init_digest_ops(struct crypto
 	
 	ops-&gt;dit_init	= dalg-&gt;dia_init;
 	ops-&gt;dit_update	= dalg-&gt;dia_update_sg ?: update;
-	ops-&gt;dit_final	= crypto_tfm_alg_alignmask(tfm) ? dalg-&gt;dia_final :
-							  final;
-	ops-&gt;dit_digest	= dalg-&gt;dia_digest ?: digest;
+	ops-&gt;dit_final	= crypto_tfm_alg_alignmask(tfm) ?
+			  final : dalg-&gt;dia_final;
+	ops-&gt;dit_digest	= digest;
 	ops-&gt;dit_setkey	= dalg-&gt;dia_setkey ? setkey : nosetkey;
 	
 	return 0;
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -111,8 +111,6 @@ struct digest_alg {
 	void (*dia_update_sg)(struct crypto_tfm *tfm, struct scatterlist *sg,
 			      unsigned int nsg);
 	void (*dia_final)(struct crypto_tfm *tfm, u8 *out);
-	void (*dia_digest)(struct crypto_tfm *tfm, struct scatterlist *sg,
-	                   unsigned int nsg, u8 *out);
 	int (*dia_setkey)(struct crypto_tfm *tfm, const u8 *key,
 	                  unsigned int keylen);
 };
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060710161359</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-07-10 16:13:59-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--success,</subject><body>

reverend@Safe-mail.net wrote:
&gt; I deleted something more from the working and selfcompiled kernel and
&gt; name it uname -r-crypto-b and so I did with the initrd.img, the .config and the
&gt; directory in /boot/modules, but it do not work anymore.

So boot the old semi-working kernel. As long as the `uname -r` is different
for each kernel, you can can have many bootable kernels available. All
kernel version specific modules are stored in different directories, and
kernel version specific files in /boot at least have kernel version in the
file name.

&gt; Is this so fragile that this can happen anytime or a mistake from me ?

To successfully use loop-AES, you need to be able to configure, compile and
install kernels that work on your computers. This is not difficult but it is
a requirement.

May I suggest the you try configuring, compiling, and installing a kernel
few times in normal unencrypted root setup first. And I mean setups where
those kernels boot without any initrd help. Many distros use kernel
configurations that use initrds filled with drivers for about all supported
hardware. Most of the work is figuring out what drivers your hardware needs
and disabling all the other drivers. Once you have such "optimized" working
kernel configuration, you can use that kernel configuration as starting
point for other kernel compiles.

&gt; I am allways ending in busybox after:
&gt; 
&gt; (no PW-prompt)
&gt; mount: Mounting /dev/hda3 on /root failed: No such device

Again, this looks like misconfigured bootloader. It loads wrong initrd.
Another possibility is that you booted wrong kernel.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060711023525</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-11 02:35:25-0400</timestampReceived><subject>Re: [CRYPTO] padlock: Driver for SHA1 / SHA256 algorithms</subject><body>

Hi Michal:

On Tue, Jul 11, 2006 at 02:01:14PM +1200, Michal Ludvig wrote:
&gt;
&gt; Changes from last time:
&gt; * fallback TFM allocated in cra_init, not in dia_init
&gt; * dropped padlock_sha1_init and introduced padlock_sha1_cra_init (ditto
&gt; for 256). Both sha1 and sha256 use common padlock_sha_init() now.
&gt; * padlock_init checks for fallback modules but only prints warning if
&gt; they are not available, i.e. doesn't prevent loading the module if
&gt; fallbacks are not loadable.
&gt; * doesn't hold fallback TFMs throughout the whole lifetime anymore

Looks much better!

&gt; Anything else to address?

Just a few minor issues.

&gt; +#include &lt;linux/module.h&gt;
&gt; +#include &lt;linux/init.h&gt;
&gt; +#include &lt;linux/types.h&gt;
&gt; +#include &lt;linux/errno.h&gt;
&gt; +#include &lt;linux/crypto.h&gt;
&gt; +#include &lt;linux/cryptohash.h&gt;
&gt; +#include &lt;linux/interrupt.h&gt;
&gt; +#include &lt;linux/kernel.h&gt;
&gt; +#include &lt;linux/scatterlist.h&gt;
&gt; +#include &lt;asm/byteorder.h&gt;

You can drop asm/byteorder.h and linux/types.h since they're
always provided by linux/kernel.h.

&gt; +#include "padlock.h"
&gt; +
&gt; +#define PADLOCK_CRA_PRIORITY	300

Perhaps this macro can be moved into padlock.h since it's shared
with AES?

&gt; +struct padlock_sha_ctx {
&gt; +	char		*data;
&gt; +	size_t		used;
&gt; +	size_t		data_len;

Do we need data_len if it's always going to be a page?

&gt; +	int		bypass;
&gt; +	void (*f_sha_padlock)(const char *in, char *out, int count);
&gt; +	const char	*fallback_driver_name;

How about dropping this variable since it seems to be pretty useless?

&gt; +#define CTX(tfm)	((struct padlock_sha_ctx*)(crypto_tfm_ctx(tfm)))

Please put a space before the asterisk.  It's also better to use an
inline function instead of macros whenever possible, and stick with
lower-case names please :)

&gt; +/* We'll need aligned address on the stack */
&gt; +#define NEAREST_ALIGNED(ptr) ((unsigned char *)(ptr) +	\
&gt; +	((0x10 - ((size_t)(ptr) &amp; 0x0F)) &amp; 0x0F))

How about using the ALIGN macro from kernel.h?

&gt; +static void padlock_sha_bypass(struct crypto_tfm *tfm)
&gt; +{
&gt; +	if (CTX(tfm)-&gt;bypass)
&gt; +		return;
&gt; +
&gt; +	BUG_ON(!CTX(tfm)-&gt;fallback_tfm);
&gt; +
&gt; +	crypto_digest_init(CTX(tfm)-&gt;fallback_tfm);
&gt; +	if (CTX(tfm)-&gt;data &amp;&amp; CTX(tfm)-&gt;used) {
&gt; +		struct scatterlist sg[8];

How about sg[1] :)

&gt; +		sg_set_buf(&amp;sg[0], CTX(tfm)-&gt;data, CTX(tfm)-&gt;used);

It's shorter to say sg rather than &amp;sg[0].

&gt; +static void padlock_sha_update(struct crypto_tfm *tfm, const uint8_t *data, unsigned int length)

Please use u8/u16/u32/u64 instead of uintX_t for kernel code.  Until
there is a change in general kernel policy it's better to stick with
the prevailing coding style.

Please also keep lines to 80 chars.

&gt; +static inline void
&gt; +padlock_htonl_block(uint32_t *data, size_t count)

BSD style alert :)

&gt; +{
&gt; +	while (count--) {
&gt; +		asm volatile ("bswapl %0" : "+r"(*data));

How about sticking with swab32? It'll do the same thing.
Perhaps you could even combine the swab with the copy to the
final output buffer.

&gt; +void padlock_do_sha1(const char *in, char *out, int count)
&gt; +{
&gt; +	/* We can't store directly to *out as it
&gt; +	 * doesn't have to be aligned. But who cares,
&gt; +	 * it's only a few bytes... */
&gt; +	char buf[128+16];

Does it really need 128 bytes? It's also better to put this in the
ctx since there it's easier to get the required alignment (see what
I did to the padlock AES driver).

Also the output buffer is guaranteed to be aligned because you've
set the alignment mask.

&gt; +static void padlock_sha_final(struct crypto_tfm *tfm, uint8_t *out)
&gt; +{
&gt; +	if (unlikely(CTX(tfm)-&gt;bypass)) {
&gt; +		BUG_ON(!CTX(tfm)-&gt;fallback_tfm);
&gt; +		crypto_digest_final(CTX(tfm)-&gt;fallback_tfm, out);

BTW, these BUG_ON's are pointless since as soon as you use the thing
it'll oops anyway.

&gt; +	/* For now we'll try to allocate one page. This
&gt; +	 * could eventually be configurable one day. */
&gt; +	CTX(tfm)-&gt;data = (char*)__get_free_page(GFP_KERNEL);
&gt; +	if (!CTX(tfm)-&gt;data)
&gt; +		padlock_sha_bypass(tfm);

This can't work because the padlock_sha_init function will wipe out the
bypass flag.  So just fail the whole thing if you can't grab a page.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060711044954</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-11 04:49:54-0400</timestampReceived><subject>[CRYPTO] api: Fix potential cra_users leak in crypto_remove_spawns</subject><body>

Hi:

While adding crypto_remove_spawns I noticed that the loop isn't quite
right.

[CRYPTO] api: Fix potential cra_users leak in crypto_remove_spawns

When we walk the spawns list we keep adding the cra_users list of each
entry that we process to the end of the list.  If the entry we process
happens to be the last of the spawns list, the newly added entries will
not be processed.  Thie patch fixes it by changing n if the it is the
last entry of spawns.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/api.c b/crypto/api.c
index fe15f5c..23dd53d 100644
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -494,8 +494,14 @@ static void crypto_remove_spawns(struct 
 		crypto_notify(CRYPTO_MSG_ALG_UNREGISTER, &amp;inst-&gt;alg);
 		list_move(&amp;inst-&gt;alg.cra_list, list);
 		hlist_del(&amp;inst-&gt;list);
-		list_splice(&amp;inst-&gt;alg.cra_users, spawns-&gt;prev);
 		inst-&gt;alg.cra_destroy = crypto_destroy_instance;
+
+		if (!list_empty(&amp;inst-&gt;alg.cra_users)) {
+			if (&amp;n-&gt;list == spawns)
+				n = list_entry(inst-&gt;alg.cra_users.next,
+					       typeof(*n), list);
+			__list_splice(&amp;inst-&gt;alg.cra_users, spawns-&gt;prev);
+		}
 	}
 }
 
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060711060146</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-11 06:01:46-0400</timestampReceived><subject>Re: [ACRYPTO] new release of asynchronous crrypto layer.</subject><body>

Hi Evgeniy:

On Tue, Jul 11, 2006 at 09:31:57AM +0400, Evgeniy Polyakov wrote:
&gt;
&gt; &gt; I noticed a bug in the ESP IV processing.  When you do ESP asynchronously,
&gt; &gt; you can no longer use the last block of the previous packet as the IV of
&gt; &gt; the next.  This is because the next packet may have started processing
&gt; &gt; before the last packet has even been finalised.
&gt; 
&gt; I cought that bug too, so IV being used is always copied into old_iv variable,
&gt; so integrity is stated.

My point is that it is possible for two packets to use the same IV
under this scheme, which defeats the purpose of IVs.

&gt; &gt; A simple solution is to generate a random IV.
&gt; 
&gt; Yes, it could be done too.
&gt; But actually neither random IV, nor IV created from encrypted previous packet, 
&gt; nor IV created from unencrypted previous packet are forbidden by spec. 
&gt; Initial implementation used constant IV there at all.

True.  However, using the same IV more than once is definitely not a good
idea.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060712003436</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-07-12 00:34:36-0400</timestampReceived><subject>[1/2] [CRYPTO] padlock: Update private header file</subject><body>

PADLOCK_CRA_PRIORITY is shared between padlock-aes and padlock-sha
so it should be in the header.

On the other hand "struct cword" is only used in padlock-aes.c
so it's unnecessary to have it in padlock.h

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux-2.6.16.13-xenU/drivers/crypto/padlock-aes.c
===================================================================
--- linux-2.6.16.13-xenU.orig/drivers/crypto/padlock-aes.c
+++ linux-2.6.16.13-xenU/drivers/crypto/padlock-aes.c
@@ -59,6 +59,17 @@
 #define AES_EXTENDED_KEY_SIZE	64	/* in uint32_t units */
 #define AES_EXTENDED_KEY_SIZE_B	(AES_EXTENDED_KEY_SIZE * sizeof(uint32_t))
 
+/* Control word. */
+struct cword {
+	unsigned int __attribute__ ((__packed__))
+		rounds:4,
+		algo:3,
+		keygen:1,
+		interm:1,
+		encdec:1,
+		ksize:2;
+} __attribute__ ((__aligned__(PADLOCK_ALIGNMENT)));
+
 struct aes_ctx {
 	struct {
 		struct cword encrypt;
@@ -469,7 +480,7 @@ static unsigned int aes_decrypt_cbc(cons
 static struct crypto_alg aes_alg = {
 	.cra_name		=	"aes",
 	.cra_driver_name	=	"aes-padlock",
-	.cra_priority		=	300,
+	.cra_priority		=	PADLOCK_CRA_PRIORITY,
 	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize		=	AES_BLOCK_SIZE,
 	.cra_ctxsize		=	sizeof(struct aes_ctx),
Index: linux-2.6.16.13-xenU/drivers/crypto/padlock.h
===================================================================
--- linux-2.6.16.13-xenU.orig/drivers/crypto/padlock.h
+++ linux-2.6.16.13-xenU/drivers/crypto/padlock.h
@@ -15,17 +15,8 @@
 
 #define PADLOCK_ALIGNMENT 16
 
-/* Control word. */
-struct cword {
-	unsigned int __attribute__ ((__packed__))
-		rounds:4,
-		algo:3,
-		keygen:1,
-		interm:1,
-		encdec:1,
-		ksize:2;
-} __attribute__ ((__aligned__(PADLOCK_ALIGNMENT)));
-
 #define PFX	"padlock: "
 
+#define PADLOCK_CRA_PRIORITY	300
+
 #endif	/* _CRYPTO_PADLOCK_H */

--


-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060712003705</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-12 00:37:05-0400</timestampReceived><subject>[1/2] [CRYPTO] crc32c: Fixed reversed endian annotation</subject><body>

Hi:

[CRYPTO] crc32c: Fixed reversed endian annotation

The input rather than the internal state is supposed to be little-endian.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/crc32c.c b/crypto/crc32c.c
--- a/crypto/crc32c.c
+++ b/crypto/crc32c.c
@@ -22,8 +22,8 @@
 #define CHKSUM_DIGEST_SIZE	4
 
 struct chksum_ctx {
-	__le32 crc;
-	__le32 key;
+	u32 crc;
+	u32 key;
 };
 
 /*
@@ -52,7 +52,7 @@ static int chksum_setkey(struct crypto_t
 		tfm-&gt;crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
 		return -EINVAL;
 	}
-	mctx-&gt;key = cpu_to_le32(*(u32 *)key);
+	mctx-&gt;key = le32_to_cpu(*(__le32 *)key);
 	return 0;
 }
 
@@ -61,14 +61,14 @@ static void chksum_update(struct crypto_
 {
 	struct chksum_ctx *mctx = crypto_tfm_ctx(tfm);
 
-	mctx-&gt;crc = (__le32)crc32c((u32)mctx-&gt;crc, data, length);
+	mctx-&gt;crc = crc32c(mctx-&gt;crc, data, length);
 }
 
 static void chksum_final(struct crypto_tfm *tfm, u8 *out)
 {
 	struct chksum_ctx *mctx = crypto_tfm_ctx(tfm);
 	
-	*(u32 *)out = ~le32_to_cpu(mctx-&gt;crc);
+	*(__le32 *)out = ~cpu_to_le32(mctx-&gt;crc);
 }
 
 static int crc32c_cra_init(struct crypto_tfm *tfm)
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060712003753</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-12 00:37:53-0400</timestampReceived><subject>[2/2] [CRYPTO] tcrypt: Use test_hash for crc32c</subject><body>

Hi:

[CRYPTO] tcrypt: Use test_hash for crc32c

Now that crc32c has been fixed to conform with standard digest semantics,
we can use test_hash for it.  I've turned the last test into a chunky
test.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
--
diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -679,108 +679,6 @@ out:
 	crypto_free_tfm(tfm);
 }
 
-static void test_crc32c(void)
-{
-#define NUMVEC 6
-#define VECSIZE 40
-
-	int i, j, pass;
-	u32 crc;
-	u8 b, test_vec[NUMVEC][VECSIZE];
-	static u32 vec_results[NUMVEC] = {
-		0x0e2c157f, 0xe980ebf6, 0xde74bded,
-		0xd579c862, 0xba979ad0, 0x2b29d913
-	};
-	static u32 tot_vec_results = 0x24c5d375;
-
-	struct scatterlist sg[NUMVEC];
-	struct crypto_tfm *tfm;
-	char *fmtdata = "testing crc32c initialized to %08x: %s\n";
-#define SEEDTESTVAL 0xedcba987
-	u32 seed;
-
-	printk("\ntesting crc32c\n");
-
-	tfm = crypto_alloc_tfm("crc32c", 0);
-	if (tfm == NULL) {
-		printk("failed to load transform for crc32c\n");
-		return;
-	}
-
-	crypto_digest_init(tfm);
-	crypto_digest_final(tfm, (u8*)&amp;crc);
-	printk(fmtdata, crc, (crc == 0) ? "pass" : "ERROR");
-
-	/*
-	 * stuff test_vec with known values, simple incrementing
-	 * byte values.
-	 */
-	b = 0;
-	for (i = 0; i &lt; NUMVEC; i++) {
-		for (j = 0; j &lt; VECSIZE; j++)
-			test_vec[i][j] = ++b;
-		sg_set_buf(&amp;sg[i], test_vec[i], VECSIZE);
-	}
-
-	seed = SEEDTESTVAL;
-	(void)crypto_digest_setkey(tfm, (const u8*)&amp;seed, sizeof(u32));
-	crypto_digest_init(tfm);
-	crypto_digest_final(tfm, (u8*)&amp;crc);
-	printk("testing crc32c setkey returns %08x : %s\n", crc, (crc == (SEEDTESTVAL ^ ~(u32)0)) ?
-	       "pass" : "ERROR");
-
-	printk("testing crc32c using update/final:\n");
-
-	pass = 1;		    /* assume all is well */
-
-	for (i = 0; i &lt; NUMVEC; i++) {
-		seed = ~(u32)0;
-		(void)crypto_digest_setkey(tfm, (const u8*)&amp;seed, sizeof(u32));
-		crypto_digest_init(tfm);
-		crypto_digest_update(tfm, &amp;sg[i], 1);
-		crypto_digest_final(tfm, (u8*)&amp;crc);
-		if (crc == vec_results[i]) {
-			printk(" %08x:OK", crc);
-		} else {
-			printk(" %08x:BAD, wanted %08x\n", crc, vec_results[i]);
-			pass = 0;
-		}
-	}
-
-	printk("\ntesting crc32c using incremental accumulator:\n");
-	crc = 0;
-	for (i = 0; i &lt; NUMVEC; i++) {
-		seed = (crc ^ ~(u32)0);
-		(void)crypto_digest_setkey(tfm, (const u8*)&amp;seed, sizeof(u32));
-		crypto_digest_init(tfm);
-		crypto_digest_update(tfm, &amp;sg[i], 1);
-		crypto_digest_final(tfm, (u8*)&amp;crc);
-	}
-	if (crc == tot_vec_results) {
-		printk(" %08x:OK", crc);
-	} else {
-		printk(" %08x:BAD, wanted %08x\n", crc, tot_vec_results);
-		pass = 0;
-	}
-
-	printk("\ntesting crc32c using digest:\n");
-	seed = ~(u32)0;
-	(void)crypto_digest_setkey(tfm, (const u8*)&amp;seed, sizeof(u32));
-	crypto_digest_init(tfm);
-	crypto_digest_digest(tfm, sg, NUMVEC, (u8*)&amp;crc);
-	if (crc == tot_vec_results) {
-		printk(" %08x:OK", crc);
-	} else {
-		printk(" %08x:BAD, wanted %08x\n", crc, tot_vec_results);
-		pass = 0;
-	}
-
-	printk("\n%s\n", pass ? "pass" : "ERROR");
-
-	crypto_free_tfm(tfm);
-	printk("crc32c test complete\n");
-}
-
 static void test_available(void)
 {
 	char **name = check;
@@ -886,7 +784,7 @@ static void do_test(void)
 		test_hash("tgr160", tgr160_tv_template, TGR160_TEST_VECTORS);
 		test_hash("tgr128", tgr128_tv_template, TGR128_TEST_VECTORS);
 		test_deflate();
-		test_crc32c();
+		test_hash("crc32c", crc32c_tv_template, CRC32C_TEST_VECTORS);
 		test_hash("hmac(md5)", hmac_md5_tv_template,
 			  HMAC_MD5_TEST_VECTORS);
 		test_hash("hmac(sha1)", hmac_sha1_tv_template,
@@ -983,7 +881,7 @@ static void do_test(void)
 		break;
 
 	case 18:
-		test_crc32c();
+		test_hash("crc32c", crc32c_tv_template, CRC32C_TEST_VECTORS);
 		break;
 
 	case 19:
diff --git a/crypto/tcrypt.h b/crypto/tcrypt.h
--- a/crypto/tcrypt.h
+++ b/crypto/tcrypt.h
@@ -28,7 +28,7 @@
 struct hash_testvec {
 	/* only used with keyed hash algorithms */
 	char key[128] __attribute__ ((__aligned__(4)));
-	char plaintext[128];
+	char plaintext[240];
 	char digest[MAX_DIGEST_SIZE];
 	unsigned char tap[MAX_TAP];
 	unsigned char psize;
@@ -2884,6 +2884,183 @@ static struct hash_testvec michael_mic_t
 };
 
 /*
+ * CRC32C test vectors
+ */
+#define CRC32C_TEST_VECTORS 14
+
+static struct hash_testvec crc32c_tv_template[] = {
+	{
+		.psize = 0,
+		.digest = { 0x00, 0x00, 0x00, 0x00 }
+	},
+	{
+		.key = { 0x87, 0xa9, 0xcb, 0xed },
+		.ksize = 4,
+		.psize = 0,
+		.digest = { 0x78, 0x56, 0x34, 0x12 },
+	},
+	{
+		.key = { 0xff, 0xff, 0xff, 0xff },
+		.ksize = 4,
+		.plaintext = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
+			       0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
+			       0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
+			       0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
+			       0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28 },
+		.psize = 40,
+		.digest = { 0x7f, 0x15, 0x2c, 0x0e }
+	},
+	{
+		.key = { 0xff, 0xff, 0xff, 0xff },
+		.ksize = 4,
+		.plaintext = { 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
+			       0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
+			       0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,
+			       0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
+			       0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50 },
+		.psize = 40,
+		.digest = { 0xf6, 0xeb, 0x80, 0xe9 }
+	},
+	{
+		.key = { 0xff, 0xff, 0xff, 0xff },
+		.ksize = 4,
+		.plaintext = { 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
+			       0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60,
+			       0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
+			       0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,
+			       0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78 },
+		.psize = 40,
+		.digest = { 0xed, 0xbd, 0x74, 0xde }
+	},
+	{
+		.key = { 0xff, 0xff, 0xff, 0xff },
+		.ksize = 4,
+		.plaintext = { 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80,
+			       0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88,
+			       0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90,
+			       0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
+			       0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0 },
+		.psize = 40,
+		.digest = { 0x62, 0xc8, 0x79, 0xd5 }
+	},
+	{
+		.key = { 0xff, 0xff, 0xff, 0xff },
+		.ksize = 4,
+		.plaintext = { 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8,
+			       0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0,
+			       0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8,
+			       0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0,
+			       0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8 },
+		.psize = 40,
+		.digest = { 0xd0, 0x9a, 0x97, 0xba }
+	},
+	{
+		.key = { 0xff, 0xff, 0xff, 0xff },
+		.ksize = 4,
+		.plaintext = { 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0,
+			       0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
+			       0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0,
+			       0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8,
+			       0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0 },
+		.psize = 40,
+		.digest = { 0x13, 0xd9, 0x29, 0x2b }
+	},
+	{
+		.key = { 0x7f, 0x15, 0x2c, 0x0e },
+		.ksize = 4,
+		.plaintext = { 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
+			       0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
+			       0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,
+			       0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
+			       0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50 },
+		.psize = 40,
+		.digest = { 0x0c, 0xb5, 0xe2, 0xa2 }
+	},
+	{
+		.key = { 0xf3, 0x4a, 0x1d, 0x5d },
+		.ksize = 4,
+		.plaintext = { 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
+			       0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60,
+			       0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
+			       0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,
+			       0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78 },
+		.psize = 40,
+		.digest = { 0xd1, 0x7f, 0xfb, 0xa6 }
+	},
+	{
+		.key = { 0x2e, 0x80, 0x04, 0x59 },
+		.ksize = 4,
+		.plaintext = { 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80,
+			       0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88,
+			       0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90,
+			       0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
+			       0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0 },
+		.psize = 40,
+		.digest = { 0x59, 0x33, 0xe6, 0x7a }
+	},
+	{
+		.key = { 0xa6, 0xcc, 0x19, 0x85 },
+		.ksize = 4,
+		.plaintext = { 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8,
+			       0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0,
+			       0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8,
+			       0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0,
+			       0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8 },
+		.psize = 40,
+		.digest = { 0xbe, 0x03, 0x01, 0xd2 }
+	},
+	{
+		.key = { 0x41, 0xfc, 0xfe, 0x2d },
+		.ksize = 4,
+		.plaintext = { 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0,
+			       0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
+			       0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0,
+			       0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8,
+			       0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0 },
+		.psize = 40,
+		.digest = { 0x75, 0xd3, 0xc5, 0x24 }
+	},
+	{
+		.key = { 0xff, 0xff, 0xff, 0xff },
+		.ksize = 4,
+		.plaintext = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
+			       0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
+			       0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
+			       0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
+			       0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
+			       0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
+			       0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
+			       0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,
+			       0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
+			       0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,
+			       0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
+			       0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60,
+			       0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
+			       0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,
+			       0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
+			       0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80,
+			       0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88,
+			       0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90,
+			       0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
+			       0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0,
+			       0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8,
+			       0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0,
+			       0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8,
+			       0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0,
+			       0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8,
+			       0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0,
+			       0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
+			       0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0,
+			       0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8,
+			       0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0 },
+		.psize = 240,
+		.digest = { 0x75, 0xd3, 0xc5, 0x24 },
+		.np = 2,
+		.tap = { 31, 209 }
+	},
+};
+
+/*
  * Cipher speed tests
  */
 static struct cipher_speed aes_speed_template[] = {
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060712011849</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-12 01:18:49-0400</timestampReceived><subject>Re: [0/2] [CRYPTO] padlock: SHA1 / SHA256 support</subject><body>

Hi Michal:

On Wed, Jul 12, 2006 at 12:34:35PM +1200, Michal Ludvig wrote:
&gt; 
&gt; the updated patch addresses almost all your comments.

Thanks a lot!
 
&gt; I prefer to keep uintX_t - quick grep reveals these are not uncommon in
&gt; the kernel. After all - linux people always rant about standards and
&gt; uint32_t *is* a standard while u32 is not (Plus I get a nice green syntax
&gt; highlighting for the *standard* types ;-)

Well I'd like all crypto code to be consistent in how they use these
types.  Right now drivers/crypto sticks out like a sore thumb.  I'll
make an exception for it this time if only because padlock-aes is already
using them.

&gt; &gt;&gt; +void padlock_do_sha1(const char *in, char *out, int count)
&gt; &gt;&gt; +{
&gt; &gt;&gt; +	/* We can't store directly to *out as it
&gt; &gt;&gt; +	 * doesn't have to be aligned. But who cares,
&gt; &gt;&gt; +	 * it's only a few bytes... */
&gt; &gt;&gt; +	char buf[128+16];
&gt; &gt; 
&gt; &gt; Does it really need 128 bytes?
&gt; 
&gt; Yes, CPU temporarily stores some data in there (IIRC in case the input
&gt; buffer is not 16 Bytes-aligned it realigns it there for the SSE input
&gt; microcode).

Hmm, does this mean that the input to the padlock crypto_tfm does not
need to be 16-byte aligned? If so you might as well get rid of the
alignment mask altogether since you can handle arbitrary input/output
and your ctx has no alignment requirement.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060712013342</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-07-12 01:33:42-0400</timestampReceived><subject>Re: [2/2] [CRYPTO] padlock: Driver for SHA1 / SHA256 algorithms</subject><body>

Herbert Xu wrote:
&gt; On Wed, Jul 12, 2006 at 12:34:37PM +1200, Michal Ludvig wrote:
&gt;&gt; Support for SHA1 / SHA256 algorithms in VIA C7 processors.
&gt;&gt;
&gt;&gt; Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;
&gt; 
&gt; Both pathces applied.  Thank you Michal.

Thanks for your patience ;-)

Michal

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060714101455</emailId><senderName></senderName><senderEmail>majordomo</senderEmail><timestampReceived>2006-07-14 10:14:55-0400</timestampReceived><subject>Majordomo results: {Filename?} Returned mail: Data format e</subject><body>

--

&gt;&gt;&gt;&gt; Warning: This message has had one or more attachments removed
**** Command 'warning:' not recognized.
&gt;&gt;&gt;&gt; Warning: (document.scr).
**** Command 'warning:' not recognized.
&gt;&gt;&gt;&gt; Warning: Please read the "NCSA-Attachment-Warning.txt" attachment(s) for more information.
**** Command 'warning:' not recognized.
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; Dear user majordomo@ncsa.uiuc.edu,
**** Command 'dear' not recognized.
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; Your e-mail account was used to send a large amount of junk e-mail during the last week.
**** Command 'your' not recognized.
&gt;&gt;&gt;&gt; Most likely your computer had been compromised and now contains a trojaned proxy server.
**** Command 'most' not recognized.
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; Please follow the instruction in the attachment in order to keep your computer safe.
**** Command 'please' not recognized.
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; Have a nice day,
**** Command 'have' not recognized.
&gt;&gt;&gt;&gt; ncsa.uiuc.edu technical support team.
**** Command 'ncsa.uiuc.edu' not recognized.
&gt;&gt;&gt;&gt; This is a message from the MailScanner E-Mail Virus Protection Service
**** Command 'this' not recognized.
&gt;&gt;&gt;&gt; ----------------------------------------------------------------------
END OF COMMANDS
**** Help for Majordomo@ncsa.uiuc.edu:


This help message is being sent to you from the Majordomo mailing list
management system at Majordomo@ncsa.uiuc.edu.

This is version 1.94.5 of Majordomo.

If you're familiar with mail servers, an advanced user's summary of
Majordomo's commands appears at the end of this message.

Majordomo is an automated system which allows users to subscribe
and unsubscribe to mailing lists, and to retrieve files from list
archives.

You can interact with the Majordomo software by sending it commands
in the body of mail messages addressed to "Majordomo@ncsa.uiuc.edu".
Please do not put your commands on the subject line; Majordomo does
not process commands in the subject line.

You may put multiple Majordomo commands in the same mail message.
Put each command on a line by itself.

If you use a "signature block" at the end of your mail, Majordomo may
mistakenly believe each line of your message is a command; you will
then receive spurious error messages.  To keep this from happening,
either put a line starting with a hyphen ("-") before your signature,
or put a line with just the word

	end

on it in the same place.  This will stop the Majordomo software from
processing your signature as bad commands.

Here are some of the things you can do using Majordomo:

I.	FINDING OUT WHICH LISTS ARE ON THIS SYSTEM

To get a list of publicly-available mailing lists on this system, put the
following line in the body of your mail message to Majordomo@ncsa.uiuc.edu:

	lists

Each line will contain the name of a mailing list and a brief description
of the list.

To get more information about a particular list, use the "info" command,
supplying the name of the list.  For example, if the name of the list 
about which you wish information is "demo-list", you would put the line

	info demo-list

in the body of the mail message.

II.	SUBSCRIBING TO A LIST

Once you've determined that you wish to subscribe to one or more lists on
this system, you can send commands to Majordomo to have it add you to the
list, so you can begin receiving mailings.

To receive list mail at the address from which you're sending your mail,
simply say "subscribe" followed by the list's name:

	subscribe demo-list

If for some reason you wish to have the mailings go to a different address
(a friend's address, a specific other system on which you have an account,
or an address which is more correct than the one that automatically appears 
in the "From:" header on the mail you send), you would add that address to
the command.  For instance, if you're sending a request from your work
account, but wish to receive "demo-list" mail at your personal account
(for which we will use "jqpublic@my-isp.com" as an example), you'd put
the line

	subscribe demo-list jqpublic@my-isp.com

in the mail message body.

Based on configuration decisions made by the list owners, you may be added 
to the mailing list automatically.  You may also receive notification
that an authorization key is required for subscription.  Another message
will be sent to the address to be subscribed (which may or may not be the
same as yours) containing the key, and directing the user to send a
command found in that message back to Majordomo@ncsa.uiuc.edu.  (This can be
a bit of extra hassle, but it helps keep you from being swamped in extra
email by someone who forged requests from your address.)  You may also
get a message that your subscription is being forwarded to the list owner
for approval; some lists have waiting lists, or policies about who may
subscribe.  If your request is forwarded for approval, the list owner
should contact you soon after your request.

Upon subscribing, you should receive an introductory message, containing
list policies and features.  Save this message for future reference; it
will also contain exact directions for unsubscribing.  If you lose the
intro mail and would like another copy of the policies, send this message
to Majordomo@ncsa.uiuc.edu:

	intro demo-list

(substituting, of course, the real name of your list for "demo-list").

III.	UNSUBSCRIBING FROM MAILING LISTS

Your original intro message contains the exact command which should be
used to remove your address from the list.  However, in most cases, you
may simply send the command "unsubscribe" followed by the list name:

	unsubscribe demo-list

(This command may fail if your provider has changed the way your
address is shown in your mail.)

To remove an address other than the one from which you're sending
the request, give that address in the command:

	unsubscribe demo-list jqpublic@my-isp.com

In either of these cases, you can tell Majordomo@ncsa.uiuc.edu to remove
the address in question from all lists on this server by using "*"
in place of the list name:

	unsubscribe *
	unsubscribe * jqpublic@my-isp.com

IV.	FINDING THE LISTS TO WHICH AN ADDRESS IS SUBSCRIBED

To find the lists to which your address is subscribed, send this command
in the body of a mail message to Majordomo@ncsa.uiuc.edu:

	which

You can look for other addresses, or parts of an address, by specifying
the text for which Majordomo should search.  For instance, to find which
users at my-isp.com are subscribed to which lists, you might send the
command

	which my-isp.com

Note that many list owners completely or fully disable the "which"
command, considering it a privacy violation.

V.	FINDING OUT WHO'S SUBSCRIBED TO A LIST

To get a list of the addresses on a particular list, you may use the
"who" command, followed by the name of the list:

	who demo-list

Note that many list owners allow only a list's subscribers to use the
"who" command, or disable it completely, believing it to be a privacy
violation.

VI.	RETRIEVING FILES FROM A LIST'S ARCHIVES

Many list owners keep archives of files associated with a list.  These
may include:
- back issues of the list
- help files, user profiles, and other documents associated with the list
- daily, monthly, or yearly archives for the list

To find out if a list has any files associated with it, use the "index"
command:

	index demo-list

If you see files in which you're interested, you may retrieve them by
using the "get" command and specifying the list name and archive filename.
For instance, to retrieve the files called "profile.form" (presumably a
form to fill out with your profile) and "demo-list.9611" (presumably the
messages posted to the list in November 1996), you would put the lines

	get demo-list profile.form
	get demo-list demo-list.9611

in your mail to Majordomo@ncsa.uiuc.edu.

VII.	GETTING MORE HELP

To contact a human site manager, send mail to Majordomo-Owner@ncsa.uiuc.edu.
To contact the owner of a specific list, send mail to that list's
approval address, which is formed by adding "-approval" to the user-name
portion of the list's address.  For instance, to contact the list owner
for demo-list@ncsa.uiuc.edu, you would send mail to demo-list-approval@ncsa.uiuc.edu.

To get another copy of this help message, send mail to Majordomo@ncsa.uiuc.edu
with a line saying

	help

in the message body.

VIII.	COMMAND SUMMARY FOR ADVANCED USERS

In the description below items contained in []'s are optional. When
providing the item, do not include the []'s around it.  Items in angle
brackets, such as &lt;address&gt;, are meta-symbols that should be replaced
by appropriate text without the angle brackets.

It understands the following commands:

    subscribe &lt;list&gt; [&lt;address&gt;]
	Subscribe yourself (or &lt;address&gt; if specified) to the named &lt;list&gt;.
	
    unsubscribe &lt;list&gt; [&lt;address&gt;]
	Unsubscribe yourself (or &lt;address&gt; if specified) from the named &lt;list&gt;.
	"unsubscribe *" will remove you (or &lt;address&gt;) from all lists.  This
	_may not_ work if you have subscribed using multiple addresses.

    get &lt;list&gt; &lt;filename&gt;
        Get a file related to &lt;list&gt;.

    index &lt;list&gt;
        Return an index of files you can "get" for &lt;list&gt;.

    which [&lt;address&gt;]
	Find out which lists you (or &lt;address&gt; if specified) are on.

    who &lt;list&gt;
	Find out who is on the named &lt;list&gt;.

    info &lt;list&gt;
	Retrieve the general introductory information for the named &lt;list&gt;.

    intro &lt;list&gt;
	Retrieve the introductory message sent to new users.  Non-subscribers
	may not be able to retrieve this.

    lists
	Show the lists served by this Majordomo server.

    help
	Retrieve this message.

    end
	Stop processing commands (useful if your mailer adds a signature).

Commands should be sent in the body of an email message to
"Majordomo@ncsa.uiuc.edu". Multiple commands can be processed provided
each occurs on a separate line.

Commands in the "Subject:" line are NOT processed.

If you have any questions or problems, please contact
"Majordomo-Owner@ncsa.uiuc.edu".


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060715003900</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-15 00:39:00-0400</timestampReceived><subject>Re: [-mm patch] drivers/crypto/padlock-sha.c: make 2 functions static</subject><body>

On Sat, Jul 15, 2006 at 02:35:40AM +0200, Adrian Bunk wrote:
&gt; This patch makes two needlessly global functions static.
&gt; 
&gt; Signed-off-by: Adrian Bunk &lt;bunk@stusta.de&gt;

Thanks, patch applied.
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060715012548</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-15 01:25:48-0400</timestampReceived><subject>Re: [CRYPTO] padlock: Fix alignment after aes_ctx rearrange</subject><body>

On Fri, Jul 14, 2006 at 02:08:16PM +1200, Michal Ludvig wrote:
&gt; 
&gt; I just recently discovered that your patch that rearranges struct
&gt; aes_ctx in padlock-aes.c breaks the alignment rules for xcrypt leading
&gt; to GPF Oopses.

Thanks a lot for catching this.

I've pushed the bug fix along.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060716120502</emailId><senderName>"Jon"</senderName><senderEmail>dona@sltnet.lk</senderEmail><timestampReceived>2006-07-16 12:05:02-0400</timestampReceived><subject>=?utf-8?B?QVBQTEUgSVBPRCBOQU5PUyAmIFNPTlkgUFNQ?=</subject><body>

Sony PSP 
we can supply Sony PSP original 10,000 pcs a month maximum with complete documents
all are 100% original with worldwide warranty.
minimum qty:100 psp's
door to door delivery price US $ 230.00
apple iPod Nanos
4GB &amp; 2GB apple iPod nanos with worldwide warranty
100% originals with worldwide warranty
minimum qty:100 iPods nanos
door to dooe delivery price
2GB apple iPod nanos US $ 149.00
4GB apple iPod Nanos US $ 172.00
Please contact us for details
Jon David Group
best regards
PLEASE DO NOT TREAT THIS MAIL AS SPAM.THIS IS NOT SPM AND IT'S VERY CLEAR THAT IF YOU \
DO NOT WISH TO CONTINUE RECEVING  THIS OFFERS,JUST IGNORE THIS MAIL YOUR ADDRESS WILL \
BE AUTOMATICALY DELETED.  
 


[Attachment #3 (text/html)]

&lt;P&gt;&lt;FONT color=red size=7&gt;Sony PSP &lt;IMG style="WIDTH: 598px; HEIGHT: 244px" \
height=280 alt="E:\My User's Documents\DAVE\DSC00185.JPG" src="E:\My User's \
Documents\DAVE\DSC00185.JPG" width=448&gt;&lt;/FONT&gt;&lt;/P&gt; &lt;P&gt;&lt;FONT color=red size=5&gt;we can \
supply Sony PSP original 10,000 pcs a month maximum with complete \
documents&lt;/FONT&gt;&lt;/P&gt; &lt;P&gt;&lt;FONT color=red size=5&gt;all are 100% original with worldwide \
warranty.&lt;/FONT&gt;&lt;/P&gt; &lt;P&gt;&lt;FONT color=red size=5&gt;minimum qty:100 psp's&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT color=red size=5&gt;door to door delivery price US $ 230.00&lt;/FONT&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT color=blue size=7&gt;apple iPod Nanos&lt;IMG style="WIDTH: 469px; HEIGHT: 198px" \
height=518 alt="E:\My User's Documents\DAVE\DSCN1755.JPG" src="E:\My User's \
Documents\DAVE\DSCN1755.JPG" width=761&gt;&lt;/FONT&gt;&lt;/P&gt; &lt;P&gt;&lt;FONT color=blue size=6&gt;4GB \
&amp; 2GB apple iPod nanos with worldwide warranty&lt;/FONT&gt;&lt;/P&gt; &lt;P&gt;&lt;FONT color=blue \
size=6&gt;100% originals with worldwide warranty&lt;/FONT&gt;&lt;/P&gt; &lt;P&gt;&lt;FONT color=blue \
size=6&gt;minimum qty:100 iPods nanos&lt;/FONT&gt;&lt;/P&gt; &lt;P&gt;&lt;FONT color=blue size=6&gt;door to dooe \
delivery price&lt;/FONT&gt;&lt;/P&gt; &lt;P&gt;&lt;FONT color=blue size=6&gt;2GB apple iPod nanos US $ \
149.00&lt;/FONT&gt;&lt;/P&gt; &lt;P&gt;&lt;FONT color=blue size=6&gt;4GB apple iPod Nanos US $ \
172.00&lt;/FONT&gt;&lt;/P&gt; &lt;P&gt;&lt;FONT color=#ff8080 size=4&gt;&lt;STRONG&gt;Please contact us for \
details&lt;/STRONG&gt;&lt;/FONT&gt;&lt;/P&gt; &lt;P&gt;&lt;FONT color=#ff8080 size=4&gt;&lt;STRONG&gt;Jon David \
Group&lt;/STRONG&gt;&lt;/FONT&gt;&lt;/P&gt; &lt;P&gt;&lt;FONT color=#ff8080 size=4&gt;&lt;STRONG&gt;best \
regards&lt;/STRONG&gt;&lt;/FONT&gt;&lt;/P&gt; &lt;P&gt;&lt;STRONG&gt;&lt;FONT color=red size=1&gt;PLEASE DO NOT TREAT \
THIS MAIL AS SPAM.THIS IS NOT SPM AND IT'S VERY CLEAR THAT IF YOU DO NOT WISH TO \
CONTINUE RECEVING &lt;/FONT&gt;&lt;/STRONG&gt;&lt;/P&gt; &lt;P&gt;&lt;STRONG&gt;&lt;FONT color=red size=1&gt;THIS \
OFFERS,JUST IGNORE THIS MAIL YOUR ADDRESS WILL BE AUTOMATICALY \
DELETED.&lt;/FONT&gt;&lt;/STRONG&gt;&lt;/P&gt; &lt;P&gt; &lt;/P&gt;
&lt;P&gt; &lt;/P&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060716215844</emailId><senderName></senderName><senderEmail>burditt43</senderEmail><timestampReceived>2006-07-16 21:58:44-0400</timestampReceived><subject>verify my email address</subject><body>

Please let me know how to email documents from MS Word. Whenever I try to  
send something by email, the recipients claim to have never received it.  
Therefore, my guess is that verifying my email address may be the  solution.  Can 
You help please.  Thank you very  much.

[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;&lt;HEAD&gt;
&lt;META http-equiv=Content-Type content="text/html; charset=US-ASCII"&gt;
&lt;META content="MSHTML 6.00.2900.2912" name=GENERATOR&gt;&lt;/HEAD&gt;
&lt;BODY id=role_body style="FONT-SIZE: 10pt; COLOR: #000000; FONT-FAMILY: Arial" 
bottomMargin=7 leftMargin=7 topMargin=7 rightMargin=7&gt;&lt;FONT id=role_document 
face=Arial color=#000000 size=2&gt;
&lt;DIV&gt;Please let me know how to email documents from MS Word. Whenever I try to 
send something by email, the recipients claim to have never received it. 
Therefore, my guess is that verifying my email address may be the 
solution.  Can You help please.  Thank you very 
much.&lt;/DIV&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060716221137</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-07-16 22:11:37-0400</timestampReceived><subject>Re: [1/5] [CRYPTO] padlock: Add compatibility alias after rename</subject><body>

On Sat, Jul 15, 2006 at 09:48:23PM +1200, Michal Ludvig wrote:
&gt;
&gt; This also provides backward compatibility with 
&gt; the ancient times before padlock.ko was renamed 
&gt; to padlock-aes.ko
&gt; 
&gt; Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Looks good, patch applied.  Thanks Michal!
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060717011356</emailId><senderName>Jacinta Ho MC</senderName><senderEmail>jacintah@sph.com.sg</senderEmail><timestampReceived>2006-07-17 01:13:56-0400</timestampReceived><subject>Jacinta Ho is out of the office.</subject><body>

[Attachment #2 (multipart/alternative)]


I will be out of the office starting  07/17/2006 and will not return un=
til
07/24/2006.

I will respond to your message when I return.



NOTE: Privileged/Confidential Information may be contained in this mess=
age.
If you are not the addressee indicated in this message (or responsible =
for
delivery of the message to such person), you may not copy or deliver th=
is
message to anyone. In such case, you should destroy this message and ki=
ndly
notify the sender by reply email. All opinions, conclusions and other
information expressed in this message not of an official nature shall n=
ot
be deemed as given or endorsed by Singapore Press Holdings Ltd or any o=
f
its subsidiaries unless otherwise indicated by an authorised representa=
tive
independent of this message.
Singapore Press Holdings Ltd Co
Regn No. 198402868E=

[Attachment #5 (text/html)]

&lt;html&gt;&lt;body&gt;
&lt;p&gt;&lt;font size="2"&gt;I will be out of the office starting  07/17/2006 and will not \
return until 07/24/2006.&lt;br&gt; &lt;/font&gt;&lt;font size="2"&gt;&lt;br&gt;
&lt;/font&gt;&lt;font size="2"&gt;I will respond to your message when I return.&lt;/font&gt;&lt;br&gt;
&lt;br&gt;
&lt;img src="cid:10__=C7BBFB3DDF9543BC8f9e8a93df938@sph.com.sg" width="710" height="55" \
alt=""&gt;&lt;br&gt; &lt;br&gt;
&lt;font size="2"&gt;NOTE: Privileged/Confidential Information may be contained in this \
message. If you are not the addressee indicated in this message (or responsible for \
delivery of the message to such person), you may not copy or deliver this message to \
anyone. In such case, you should destroy this message and kindly notify the sender by \
reply email. All opinions, conclusions and other information expressed in this \
message not of an official nature shall not be deemed as given or endorsed by \
Singapore Press Holdings Ltd or any of its subsidiaries unless otherwise indicated by \
an authorised representative independent of this message.&lt;br&gt; Singapore Press \
Holdings Ltd Co&lt;br&gt; Regn No. 198402868E&lt;/font&gt;&lt;/body&gt;&lt;/html&gt;


["C3707305.gif" (image/gif)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060719155235</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-07-19 15:52:35-0400</timestampReceived><subject>Re: util-linux patch vs. PAGE_SIZE on powerpc</subject><body>

Max Vozeler wrote:
&gt; the loop-AES patch for util-linux uses the PAGE_SIZE definition
&gt; which is normally available through asm/page.h. Unfortunately
&gt; this is no longer the case for powerpc. There PAGE_SIZE is only
&gt; defined inside #ifdef __KERNEL__ and so causes builds to fail.
&gt; 
&gt; &gt;From what I picked up, the glibc function getpagesize() can be
&gt; used instead. The manpage is a bit discouraging and notes that
&gt; availability varies depending on the architecture, but since
&gt; getpagesize() is already used in other parts of upstream mount/
&gt; I would guess that it is not actually so bad in practice. :-)
&gt; 
&gt; I'm attaching the patch that I'm including in Debian
&gt; loop-aes-utils to fix the build on powerpc. Comments welcome -
&gt; Does that change look okay to you, or is there a better way?

Thanks, Max.

I have queued your patch for inclusion to next version of loop-AES.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060724150637</emailId><senderName></senderName><senderEmail>marketing@symantec-emea.com</senderEmail><timestampReceived>2006-07-24 15:06:37-0400</timestampReceived><subject>Mark you calendar: Symantec Vision, September 12th in Brussels</subject><body>

[Attachment #2 (multipart/alternative)]


Mark you calendar: Symantec Vision, September 12th in Brussels

Join the #1 event for security &amp; availability professionals

Symantec Vision Technology Roadshow 2006
12th September, VUB Campus, Etterbeek, Brussels
http://www.veritas.com/vision/be/register.html

Symantec Vision 2006 is a leading IT conference that brings together hundreds of IT \
professionals from around the country to evaluate the latest storage and security \
technologies. Hosted by Symantec executives, customers, product managers and \
partners, each presentation will feature real-world implementations and customer \
successes, highlight the latest technology, and illustrate the practical application \
of Symantec security and availability solutions. 

Join us on Tuesday September 12th at the VUB in Brussels and :

Listen to keynotes from IDC Benelux, Neils Johnson, Graeme Pinkney and Patrick \
Dalvinck

Hear case studies from Symantec customers

Meet with Symantec partners at the Partner Expo

Follow one of three breakout tracks on IT Compliance, Enterprise Messaging Management \
and Data Center Foundation

Enjoy the comic relief from Boom Chicago

Network with your peers throughout the day


Reserve your free seat today and register online. If you have any questions or \
comments, please contact your local Symantec account manager at +32 (0)2 531 11 40. \
We look forward to welcoming you at Vision. \
http://www.veritas.com/vision/be/register.html


Best regards,
Symantec bvba

Patrick Dalvinck
Managing Director Benelux



###########################

DO NOT REPLY TO THIS MESSAGE. This email account is for sending messages only. It is \
not monitored and no replies will be made to any messages sent to this account. If \
you require Customer Service or Technical Support, please check the Symantec website \
for contact information at www.symantec.com.  You have received this message because \
you have registered or inquired about a Symantec product or downloaded trialware. At \
that time you expressed an interest in receiving information, as it became available. \
Click here to unsubscribe. mailto:unsubscribe@symantec-emea.com


[Attachment #5 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Symantec e-shot&lt;/title&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;
&lt;STYLE TYPE="text/css"&gt;
&lt;!--
BODY {
margin: 0px 0px 0px 0px;
color: #000000;
}

BODY, TD {
font-family: "Arial";
font-size: 10pt;
}

.footer {
font-size: 7pt;
}

A {
color: #cc0000;
}

.redbar {
background-color: #cc0000;
}

.footerbar {
background-color: #000000;
}

.headline {
color: WHITE;
font-size: 17pt;
margin-left: 15px;
font-family: "Arial Narrow";
font-weight: bold;
}

.subhead {
color: #CC0000;
font-size: 12pt;
font-family: "Arial";
font-weight: bold;
}

.bigredlinktext {
color: #CC0000;
font-size: 14pt;
font-family: arial;
font-weight: bold;
}
--&gt;
&lt;/STYLE&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table width="540" border="0" align="center" cellpadding="0" cellspacing="0"&gt;
&lt;tr&gt; 
&lt;td valign="top"&gt;


		&lt;div align="center"&gt;&lt;font face="Arial, Helvetica, sans-serif" size="1" \
color="#666666"&gt;If you are having problems viewing this email please&lt;/font&gt; &lt;a \
href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux-crypto@ \
nl.linux.org&amp;squirtID=2844~.~vision_belux_english_eshot.csv~.~vshots~.~TEMP9&amp;systype=v \
shots&amp;pageclicked=http://emarketing.advantapro.com/grpdta/veritas/Arc/2844---vshots.html"&gt;&lt;font \
face="Arial, Helvetica, sans-serif" size="1" color="#D6700D"&gt;click \
here&lt;/font&gt;&lt;/a&gt;&lt;br&gt;  &lt;table width="552" border="0" cellspacing="0" cellpadding="1"&gt;
  &lt;tr&gt;
    &lt;td bgcolor="#cfcfcf"&gt;&lt;table width="550" border="0" cellspacing="0" \
cellpadding="0"&gt;  &lt;tr&gt;
        &lt;td bgcolor="#FFFFFF"&gt;&lt;a \
href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux-crypto@ \
nl.linux.org&amp;squirtID=2844~.~vision_belux_english_eshot.csv~.~vshots~.~TEMP9&amp;systype=vshots&amp;pageclicked=http://www.symantec.com"&gt;&lt;img \
src="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/be_vision_header.jpg" \
width="550" height="69" border="0"&gt;&lt;/a&gt;&lt;/td&gt;  &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td bgcolor="#FFFFFF"&gt;&lt;img \
src="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/be_vision_m_hd_bot.jpg" \
width="550" height="5"&gt;&lt;/td&gt;  &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td bgcolor="#FFFFFF"&gt;&lt;a \
href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux-crypto@ \
nl.linux.org&amp;squirtID=2844~.~vision_belux_english_eshot.csv~.~vshots~.~TEMP9&amp;systype=vshots&amp;pageclicked=http://www.veritas.com/vision/be/register.html"&gt;&lt;img \
src="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/BE_vision_invite_header.jpg" \
alt="REGISTER NOW!" width="550" height="123" border="0"&gt;&lt;/a&gt;&lt;/td&gt;  &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td bgcolor="#FFFFFF"&gt;&lt;img \
src="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/be_vision_bg_bot.gif" \
width="550" height="1"&gt;&lt;/td&gt;  &lt;/tr&gt;
  
   
      &lt;tr&gt;
        &lt;td bgcolor="#FFFFFF"&gt;&lt;table width="550" border="0" cellspacing="0" \
cellpadding="13"&gt;  &lt;tr&gt;
            &lt;td colspan="2" align="left" valign="top"&gt;&lt;div align="center"&gt;&lt;font \
face="Arial, Verdana, Helvetica, sans-serif" size="+1" color="#333333"&gt;Join the #1 \
event for security &amp; availability professionals!&lt;/font&gt;&lt;/div&gt;&lt;/td&gt;  &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td height="128" align="left" valign="top"&gt;&lt;font face="Arial, Helvetica, \
sans-serif" color="#333333" size="2"&gt;              Symantec Vision 2006 is a leading \
IT conference that brings together hundreds of IT professionals from around the \
country to evaluate the latest storage and security technologies. &lt;br&gt;  &lt;br&gt;
              Hosted by Symantec executives, customers, product managers and \
partners, each presentation will feature real-world implementations and customer \
successes, highlight the latest technology, and illustrate the practical application \
of Symantec security and availability solutions.&lt;/font&gt;&lt;br&gt; &lt;br&gt;

              &lt;font face="Arial, Helvetica, sans-serif" color="#333333" size="2"&gt; \
&lt;strong&gt;Join us on Tuesday September 12th at the&lt;br&gt;   VUB Campus in Brussels and: \
&lt;/strong&gt;&lt;br&gt; &lt;/font&gt;&lt;br&gt;

              &lt;table width="0" border="0" cellspacing="0" cellpadding="5"&gt;
                &lt;tr&gt;
                  &lt;td valign="top"&gt;&lt;font size="-1" face="Arial, Verdana, Helvetica, \
sans-serif"&gt;&lt;img src="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/be_vision_but_greenarrow.gif" \
width="25" height="14"&gt;&lt;/font&gt;&lt;/td&gt;  &lt;td&gt;&lt;font face="Arial, Helvetica, sans-serif" \
color="#333333" size="2"&gt;Listen to keynotes from IDC Benelux, Neils Johnson, Graeme \
Pinkney and Patrick Dalvinck &lt;/font&gt;&lt;/td&gt;  &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td align="left" valign="top"&gt;&lt;font size="-1" face="Arial, Verdana, \
Helvetica, sans-serif"&gt;&lt;img \
src="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/be_vision_but_greenarrow.gif" \
                width="25" height="14"&gt;&lt;/font&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;font face="Arial, Helvetica, sans-serif" color="#333333" \
size="2"&gt;Hear case studies from Symantec customers &lt;/font&gt;&lt;/td&gt;  &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td align="left" valign="top"&gt;&lt;font size="-1" face="Arial, Verdana, \
Helvetica, sans-serif"&gt;&lt;img \
src="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/be_vision_but_greenarrow.gif" \
                width="25" height="14"&gt;&lt;/font&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;font face="Arial, Helvetica, sans-serif" color="#333333" \
size="2"&gt;Meet with Symantec partners at the Partner Expo&lt;/font&gt;&lt;/td&gt;  &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td align="left" valign="top"&gt;&lt;font size="-1" face="Arial, Verdana, \
Helvetica, sans-serif"&gt;&lt;img \
src="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/be_vision_but_greenarrow.gif" \
width="25" height="14"&gt;&lt;/font&gt;&lt;/td&gt;  &lt;td&gt;&lt;font face="Arial, Helvetica, sans-serif" \
color="#333333" size="2"&gt;Follow one of three breakout tracks on IT Compliance, \
Enterprise Messaging Management and Data Center Foundation &lt;/font&gt;&lt;/td&gt;  &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td align="left" valign="top"&gt;&lt;font size="-1" face="Arial, Verdana, \
Helvetica, sans-serif"&gt;&lt;img \
src="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/be_vision_but_greenarrow.gif" \
                width="25" height="14"&gt;&lt;/font&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;font face="Arial, Helvetica, sans-serif" color="#333333" \
size="2"&gt;Enjoy the comic relief from Boom Chicago &lt;/font&gt;&lt;/td&gt;  &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td align="left" valign="top"&gt;&lt;font size="-1" face="Arial, Verdana, \
Helvetica, sans-serif"&gt;&lt;img \
src="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/be_vision_but_greenarrow.gif" \
                width="25" height="14"&gt;&lt;/font&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;font face="Arial, Helvetica, sans-serif" color="#333333" \
size="2"&gt;Network with your peers throughout the day&lt;/font&gt; &lt;/td&gt;  &lt;/tr&gt;
              &lt;/table&gt;&lt;/td&gt;
            &lt;td align="right" valign="top"&gt;&lt;p&gt;&lt;a \
href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux-crypto@ \
nl.linux.org&amp;squirtID=2844~.~vision_belux_english_eshot.csv~.~vshots~.~TEMP9&amp;systype=vshots&amp;pageclicked=http://www.veritas.com/vision/be/register.html"&gt;&lt;img \
src="http://emarketing.advantapro.com/grpdta/veritas/htmlemailimages/vshots/be_vision_info_logos.gif" \
width="161" height="474" border="0"&gt;&lt;/a&gt;&lt;/p&gt;  &lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td colspan="2"&gt;&lt;font face="Arial, Helvetica, sans-serif" color="#333333" \
size="2"&gt;              Reserve your free seat today and&lt;/font&gt; &lt;a \
href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux-crypto@ \
nl.linux.org&amp;squirtID=2844~.~vision_belux_english_eshot.csv~.~vshots~.~TEMP9&amp;systype=vshots&amp;pageclicked=http://www.veritas.com/vision/be/register.html"&gt;&lt;strong&gt;&lt;font \
face="Arial, Helvetica, sans-serif" color="#D6700D" size="2"&gt;register \
online&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;. &lt;font face="Arial, Helvetica, sans-serif" color="#333333" \
size="2"&gt;If you have any questions or comments, please contact your local Symantec \
account manager at +32 (0)2 531 11 40.&lt;br&gt;   We look forward to welcoming you at \
Vision.&lt;/font&gt;  
            &lt;tr&gt;
            &lt;td colspan="2"&gt;&lt;font face="Arial, Helvetica, sans-serif" size="2" \
color="#333333"&gt; Best regards,&lt;br&gt; &lt;/font&gt; &lt;font face="Arial, Helvetica, sans-serif" \
size="2" color="#333333"&gt;&lt;Strong&gt;Symantec bvba &lt;/Strong&gt;&lt;/font&gt;&lt;BR&gt; &lt;BR&gt;
&lt;font face="Arial, Helvetica, sans-serif" size="2" color="#333333"&gt;&lt;strong&gt;Patrick \
Dalvinck&lt;BR&gt; Managing Director Benelux&lt;/strong&gt;&lt;/FONT&gt;&lt;br&gt;
                &lt;/td&gt;
          &lt;/tr&gt;
        &lt;/table&gt;          
          &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
            &lt;br&gt;
            &lt;table width="552" border="0" cellspacing="0" cellpadding="1"&gt;
              &lt;tr&gt;
                &lt;td bgcolor="#FFFFFF"&gt;&lt;table width="550" border="0" cellspacing="0" \
cellpadding="0"&gt;  &lt;tr&gt;
                      &lt;td bgcolor="#FFFFFF"&gt;&lt;div align="left"&gt;&lt;font face="Arial, \
                Helvetica, sans-serif" color="#333333" size="1"&gt;DO NOT REPLY TO THIS \
                MESSAGE. &lt;BR&gt;
                      This email account is for sending messages only. It is not \
monitored and no replies will be made to any messages &lt;br&gt;  sent to this account. \
&lt;BR&gt;  &lt;BR&gt;
  If you require Customer Service or Technical Support, please check the Symantec \
website for contact information&lt;br&gt;   at&lt;/font&gt;
                          &lt;A 
href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux-crypto@ \
nl.linux.org&amp;squirtID=2844~.~vision_belux_english_eshot.csv~.~vshots~.~TEMP9&amp;systype=vshots&amp;pageclicked=http://www.symantec.com"&gt;&lt;font \
face="Arial, Helvetica, sans-serif" color="#D6700D" \
size="1"&gt;www.symantec.com&lt;/font&gt;&lt;/A&gt;.&lt;font face="Arial, Helvetica, sans-serif" \
color="#333333" size="1"&gt;  &lt;br&gt;  &lt;br&gt;
                          You have received this message because you have registered \
or inquired about a Symantec product or downloaded trialware. At that time you \
expressed an interest in receiving information, as it became available.&lt;/font&gt;&lt;BR&gt;  
                      &lt;/div&gt;&lt;/td&gt;
                    &lt;/tr&gt;
                &lt;/table&gt;&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;p&gt; &lt;/p&gt;
		&lt;/div&gt;

&lt;p align="center" class=bigredlinktext&gt;&lt;/p&gt;
&lt;DIV ALIGN="center"&gt;&lt;/DIV&gt;&lt;BR&gt;
&lt;/td&gt;
  &lt;/tr&gt;

&lt;TR&gt; 
&lt;TD COLSPAN="3" CLASS="footer" ALIGN="center"&gt;

&lt;BR&gt;

&lt;P&gt; &lt;A href="http://emarketing.advantapro.com/cgi-bin/clickthrough.pl?youremail=linux- \
crypto@nl.linux.org&amp;squirtID=2844~.~vision_belux_english_eshot.csv~.~vshots~.~TEMP9&amp;sy \
stype=vshots&amp;pageclicked=http://emarketing.advantapro.com/cgi-bin/unsubme.pl?youremail \
=linux-crypto@nl.linux.org~and~squirtID=2844~.~vision_belux_english_eshot.csv~.~vshots \
~.~TEMP9~and~hiddentoemail_unsub=unsubscribe@symantec-emea.com~and~hiddenyouremail_unsub=linux-crypto@nl.linux.org~and~systype=vshots~and~lettertoedit=Mark \
you calendar: Symantec Vision, September 12th in Brussels"&gt;Click here to \
unsubscribe.&lt;/A&gt;&lt;/P&gt;

&lt;/TD&gt;
&lt;/TR&gt;


&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060728165837</emailId><senderName></senderName><senderEmail>majordomo</senderEmail><timestampReceived>2006-07-28 16:58:37-0400</timestampReceived><subject>Majordomo results: {Filename?} Delivery reports about your</subject><body>

--

&gt;&gt;&gt;&gt; Warning: This message has had one or more attachments removed
**** Command 'warning:' not recognized.
&gt;&gt;&gt;&gt; Warning: (letter1.zip, letter.htm    .pif).
**** Command 'warning:' not recognized.
&gt;&gt;&gt;&gt; Warning: Please read the "NCSA-Attachment-Warning.txt" attachment(s) for more
**** Command 'warning:' not recognized.
&gt;&gt;&gt;&gt; information.
**** Command 'information.' not recognized.
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; This is a message from the MailScanner E-Mail Virus Protection Service
**** Command 'this' not recognized.
&gt;&gt;&gt;&gt; ----------------------------------------------------------------------
END OF COMMANDS
**** Help for Majordomo@ncsa.uiuc.edu:


This help message is being sent to you from the Majordomo mailing list
management system at Majordomo@ncsa.uiuc.edu.

This is version 1.94.5 of Majordomo.

If you're familiar with mail servers, an advanced user's summary of
Majordomo's commands appears at the end of this message.

Majordomo is an automated system which allows users to subscribe
and unsubscribe to mailing lists, and to retrieve files from list
archives.

You can interact with the Majordomo software by sending it commands
in the body of mail messages addressed to "Majordomo@ncsa.uiuc.edu".
Please do not put your commands on the subject line; Majordomo does
not process commands in the subject line.

You may put multiple Majordomo commands in the same mail message.
Put each command on a line by itself.

If you use a "signature block" at the end of your mail, Majordomo may
mistakenly believe each line of your message is a command; you will
then receive spurious error messages.  To keep this from happening,
either put a line starting with a hyphen ("-") before your signature,
or put a line with just the word

	end

on it in the same place.  This will stop the Majordomo software from
processing your signature as bad commands.

Here are some of the things you can do using Majordomo:

I.	FINDING OUT WHICH LISTS ARE ON THIS SYSTEM

To get a list of publicly-available mailing lists on this system, put the
following line in the body of your mail message to Majordomo@ncsa.uiuc.edu:

	lists

Each line will contain the name of a mailing list and a brief description
of the list.

To get more information about a particular list, use the "info" command,
supplying the name of the list.  For example, if the name of the list 
about which you wish information is "demo-list", you would put the line

	info demo-list

in the body of the mail message.

II.	SUBSCRIBING TO A LIST

Once you've determined that you wish to subscribe to one or more lists on
this system, you can send commands to Majordomo to have it add you to the
list, so you can begin receiving mailings.

To receive list mail at the address from which you're sending your mail,
simply say "subscribe" followed by the list's name:

	subscribe demo-list

If for some reason you wish to have the mailings go to a different address
(a friend's address, a specific other system on which you have an account,
or an address which is more correct than the one that automatically appears 
in the "From:" header on the mail you send), you would add that address to
the command.  For instance, if you're sending a request from your work
account, but wish to receive "demo-list" mail at your personal account
(for which we will use "jqpublic@my-isp.com" as an example), you'd put
the line

	subscribe demo-list jqpublic@my-isp.com

in the mail message body.

Based on configuration decisions made by the list owners, you may be added 
to the mailing list automatically.  You may also receive notification
that an authorization key is required for subscription.  Another message
will be sent to the address to be subscribed (which may or may not be the
same as yours) containing the key, and directing the user to send a
command found in that message back to Majordomo@ncsa.uiuc.edu.  (This can be
a bit of extra hassle, but it helps keep you from being swamped in extra
email by someone who forged requests from your address.)  You may also
get a message that your subscription is being forwarded to the list owner
for approval; some lists have waiting lists, or policies about who may
subscribe.  If your request is forwarded for approval, the list owner
should contact you soon after your request.

Upon subscribing, you should receive an introductory message, containing
list policies and features.  Save this message for future reference; it
will also contain exact directions for unsubscribing.  If you lose the
intro mail and would like another copy of the policies, send this message
to Majordomo@ncsa.uiuc.edu:

	intro demo-list

(substituting, of course, the real name of your list for "demo-list").

III.	UNSUBSCRIBING FROM MAILING LISTS

Your original intro message contains the exact command which should be
used to remove your address from the list.  However, in most cases, you
may simply send the command "unsubscribe" followed by the list name:

	unsubscribe demo-list

(This command may fail if your provider has changed the way your
address is shown in your mail.)

To remove an address other than the one from which you're sending
the request, give that address in the command:

	unsubscribe demo-list jqpublic@my-isp.com

In either of these cases, you can tell Majordomo@ncsa.uiuc.edu to remove
the address in question from all lists on this server by using "*"
in place of the list name:

	unsubscribe *
	unsubscribe * jqpublic@my-isp.com

IV.	FINDING THE LISTS TO WHICH AN ADDRESS IS SUBSCRIBED

To find the lists to which your address is subscribed, send this command
in the body of a mail message to Majordomo@ncsa.uiuc.edu:

	which

You can look for other addresses, or parts of an address, by specifying
the text for which Majordomo should search.  For instance, to find which
users at my-isp.com are subscribed to which lists, you might send the
command

	which my-isp.com

Note that many list owners completely or fully disable the "which"
command, considering it a privacy violation.

V.	FINDING OUT WHO'S SUBSCRIBED TO A LIST

To get a list of the addresses on a particular list, you may use the
"who" command, followed by the name of the list:

	who demo-list

Note that many list owners allow only a list's subscribers to use the
"who" command, or disable it completely, believing it to be a privacy
violation.

VI.	RETRIEVING FILES FROM A LIST'S ARCHIVES

Many list owners keep archives of files associated with a list.  These
may include:
- back issues of the list
- help files, user profiles, and other documents associated with the list
- daily, monthly, or yearly archives for the list

To find out if a list has any files associated with it, use the "index"
command:

	index demo-list

If you see files in which you're interested, you may retrieve them by
using the "get" command and specifying the list name and archive filename.
For instance, to retrieve the files called "profile.form" (presumably a
form to fill out with your profile) and "demo-list.9611" (presumably the
messages posted to the list in November 1996), you would put the lines

	get demo-list profile.form
	get demo-list demo-list.9611

in your mail to Majordomo@ncsa.uiuc.edu.

VII.	GETTING MORE HELP

To contact a human site manager, send mail to Majordomo-Owner@ncsa.uiuc.edu.
To contact the owner of a specific list, send mail to that list's
approval address, which is formed by adding "-approval" to the user-name
portion of the list's address.  For instance, to contact the list owner
for demo-list@ncsa.uiuc.edu, you would send mail to demo-list-approval@ncsa.uiuc.edu.

To get another copy of this help message, send mail to Majordomo@ncsa.uiuc.edu
with a line saying

	help

in the message body.

VIII.	COMMAND SUMMARY FOR ADVANCED USERS

In the description below items contained in []'s are optional. When
providing the item, do not include the []'s around it.  Items in angle
brackets, such as &lt;address&gt;, are meta-symbols that should be replaced
by appropriate text without the angle brackets.

It understands the following commands:

    subscribe &lt;list&gt; [&lt;address&gt;]
	Subscribe yourself (or &lt;address&gt; if specified) to the named &lt;list&gt;.
	
    unsubscribe &lt;list&gt; [&lt;address&gt;]
	Unsubscribe yourself (or &lt;address&gt; if specified) from the named &lt;list&gt;.
	"unsubscribe *" will remove you (or &lt;address&gt;) from all lists.  This
	_may not_ work if you have subscribed using multiple addresses.

    get &lt;list&gt; &lt;filename&gt;
        Get a file related to &lt;list&gt;.

    index &lt;list&gt;
        Return an index of files you can "get" for &lt;list&gt;.

    which [&lt;address&gt;]
	Find out which lists you (or &lt;address&gt; if specified) are on.

    who &lt;list&gt;
	Find out who is on the named &lt;list&gt;.

    info &lt;list&gt;
	Retrieve the general introductory information for the named &lt;list&gt;.

    intro &lt;list&gt;
	Retrieve the introductory message sent to new users.  Non-subscribers
	may not be able to retrieve this.

    lists
	Show the lists served by this Majordomo server.

    help
	Retrieve this message.

    end
	Stop processing commands (useful if your mailer adds a signature).

Commands should be sent in the body of an email message to
"Majordomo@ncsa.uiuc.edu". Multiple commands can be processed provided
each occurs on a separate line.

Commands in the "Subject:" line are NOT processed.

If you have any questions or problems, please contact
"Majordomo-Owner@ncsa.uiuc.edu".


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060729000053</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-07-29 00:00:53-0400</timestampReceived><subject>Re: root-crypto/loop-aes/debian-testing, 2.6.15-1-686--SOLVED-</subject><body>

&gt; May I suggest the you try configuring, compiling, and installing a kernel
&gt; few times in normal unencrypted root setup first. And I mean setups where
&gt; those kernels boot without any initrd help. Many distros use kernel
&gt; configurations that use initrds filled with drivers for about all supported
&gt; hardware. Most of the work is figuring out what drivers your hardware needs
&gt; and disabling all the other drivers. Once you have such "optimized" working
&gt; kernel configuration, you can use that kernel configuration as starting
&gt; point for other kernel compiles.

I compiled &gt; 100 the last 8 years and they worked ( 5 years SuSE, than debian).
Anyway in fact I never interested in initrd-background but I will in some
future; now it is time to get things done .... after month.
I trained myself in compiling 2.6xxxx-crypto-kernels and saw the dangers.
Any newcomer should burn in, that the only initial-ramdisk for one or 100
kernels is the small INITRD.GZ, made with the script and in /boot !

&gt; Again, this looks like misconfigured bootloader. It loads wrong initrd.
&gt; Another possibility is that you booted wrong kernel.

When installing whatever-kernel.deb, update-grub is initiated and is
flattening every crypto-related word, but still looking nice to the crypto-novice....

When I just thought of what algo, I felt aespipe only to supply aes, so it would
be extra dangerous to use twofish etc. in case of emergency...............

I am looking for a place to put my experiences to make it easier for others.

   Thanks for your time &amp; patience, so far

                                                        Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060731052148</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-07-31 05:21:48-0400</timestampReceived><subject>Re: blowfish256-algo not working with pgp.key while other algos do</subject><body>

&gt; loop_twofish, loop_blowfish, and loop_serpent must be modprobed before they
&gt; can be used. There is nothing that prevents all being loaded simultaneously.
&gt; If you run "make tests" in ciphers package source directory, then Makefile
&gt; modprobes all above mentioned modules to kernel.
&gt; 
&gt; &gt; For blowfish to be used, loop_twofish had to be rmmod-ed before and so on
&gt; &gt; for serpent.
&gt; 
&gt; Show me the error message.
&gt; Show me output of "make tests ; lsmod" (in ciphers package source directory)

I would like to do that, but the testsystem crashed seriously while I
tryed to make the final, usable Installation.-
After about 150 hours I had it run on a shrinked partition, with reduced bitlength.

I faced abnormal behaviour of the testsystem, more than I faced last 8 years.
Not all could be asked, repeated or is covered by your Readmes.

I will no longer waist me time and I am quitting this.

                                  Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060603105354</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-06-03 10:53:54-0400</timestampReceived><subject>Re: [PATCH] crypto:  Add support for the Geode LX HW AES engine</subject><body>

On Fri, Jun 02, 2006 at 11:23:41AM -0600, Jordan Crouse (jordan.crouse@amd.com) wrote:
&gt; Greetings - attached is a patch adding a crypto API driver for the hardware
&gt; encryption engine on the AMD Geode LX processor, applied against latest
&gt; GIT from Linus.  This is my first foray into the world of the Crypto API, 
&gt; so comments are more then welcome.

Couple of them inside.

&gt; Regards,
&gt; Jordan
&gt; 
&gt; -- 
&gt; Jordan Crouse
&gt; Senior Linux Engineer
&gt; Advanced Micro Devices, Inc.
&gt; &lt;www.amd.com&gt;

...

&gt; +static inline void AWRITE(unsigned long val, unsigned short reg) {
&gt; +#ifdef DEBUG
&gt; +	printk("[AES] W [%x]=%x\n", reg, val);
&gt; +#endif
&gt; +	iowrite32(val, _iobase + reg);
&gt; +}
&gt; +
&gt; +static inline unsigned int AREAD(unsigned short reg) {
&gt; +	unsigned int val = ioread32(_iobase + reg);
&gt; +#ifdef DEBUG
&gt; +	printk("[AES] R [%x]=%x\n", reg, val);
&gt; +#endif
&gt; +	return val;
&gt; +}

Remove above functions and use ioread/iowrite directly.

&gt; +/* Write a 128 bit field (either a writable key or IV) */
&gt; +static inline void
&gt; +_writefield(u32 offset, void *value)
&gt; +{
&gt; +	int i;
&gt; +	for(i = 0; i &lt; 4; i++)
&gt; +		AWRITE(((u32 *) value)[i], offset + (i * 4));
&gt; +}
&gt; +
&gt; +/* Read a 128 bit field (either a writable key or IV) */
&gt; +static inline void
&gt; +_readfield(u32 offset, void *value)
&gt; +{
&gt; +	int i;
&gt; +	for(i = 0; i &lt; 4; i++)
&gt; +		((u32 *) value)[i] = AREAD(offset + (i * 4));
&gt; +}
&gt; +
&gt; +static void
&gt; +_crypt(void *src, void *dst, int len, u32 flags)
&gt; +{
&gt; +	u32 status;
&gt; +
&gt; +	AWRITE(__pa(src), AES_SOURCEA_REG);
&gt; +	AWRITE(__pa(dst), AES_DSTA_REG);

Do not use __pa, use virt_to_phys() although it is the same for i386.

&gt; +	AWRITE(len,  AES_LENA_REG);
&gt; +
&gt; +	/* Start the operation */
&gt; +	AWRITE(AES_CTRL_START | flags, AES_CTRLA_REG);
&gt; +
&gt; +	/* According to the silicon developers, the status will only
&gt; +	 * fail to clear on an catastrophic failure, so an infinite
&gt; +	 * loop is valid here
&gt; +	 */
&gt; +
&gt; +	do
&gt; +		status = AREAD(AES_INTR_REG);
&gt; +	while(!(status &amp; AES_INTRA_PENDING));
&gt; +
&gt; +	/* Clear the event */
&gt; +	AWRITE((status &amp; 0xFF) | AES_INTRA_PENDING, AES_INTR_REG);
&gt; +}

And how will system behave if that catastrophic failure happend?
Maybe it would be better to have counter and failure device shutdown in
case of error?

&gt; +unsigned int
&gt; +geode_aes_crypt(struct geode_aes_op *op)
&gt; +{
&gt; +	u32 flags = 0;
&gt; +
&gt; +	if (op-&gt;len == 0 || op-&gt;src == op-&gt;dst)
&gt; +		return 0;
&gt; +
&gt; +	if (mutex_lock_interruptible(&amp;emutex))
&gt; +		return 0;

I.e. it can not be used in atomic context?
That will break a lot of setups.

...

&gt; +		.cipher = {
&gt; +			.cia_min_keysize	=  AES_KEY_LENGTH,
&gt; +			.cia_max_keysize	=  AES_KEY_LENGTH,

I.e. it does not support different keys?
If so, it should be called geode-aes-128, imho.

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060605104749</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-05 10:47:49-0400</timestampReceived><subject>Re: [PATCH 3/4] Twofish cipher - i586 assembler</subject><body>

On Monday 05 June 2006 00:49, Horst von Brand wrote:
&gt; Joachim Fritschi &lt;jfritschi@freenet.de&gt; wrote:
&gt; &gt; This patch adds the twofish i586 assembler routine.
&gt;
&gt; What performance impact does this have on a variety of machines? 

Here are the outputs from the tcrypt speedtests. They haven't changed much 
since the last patch:

http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-c-i586.txt
http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-asm-i586.txt
http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-c-x86_64.txt
http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-asm-x86_64.txt

Summary for cycles used for CBC encrypt decrypt (256bit / 8k blocks) assembler 
vs. generic-c:

i586 encrypt:   - 17%
i568 decrypt:   -24%
x86_64 encrypt: -22%
x86_64 decrypt: -17%

The numbers vary a bit with different blocksizes / keylength and per test.

I also did some filesystem benchmarks (bonnie++) with various ciphers. Most 
write tests maxed out my drives writing to disk.  But at least for the read 
speed you can see some notable performance improvements:
(Note: The x86 and x86_64 numbers are not comparable since the tests were done 
on different machines)

http://homepages.tu-darmstadt.de/~fritschi/twofish/output_20060531_160442_x86.html

Summary:
Sequential read speed improved between 25-32%
Sequential write speed improved at least 15% but the disk maxed out
Twofish 256 is a little bit faster than AES 128

http://homepages.tu-darmstadt.de/~fritschi/twofish/output_20060601_113747_x86_64.html

Summary:
Sequential read speed improved 13%
Seqential write speed maxed out the drives

&gt; Is twofish used enough for this to be relevant?

I don't have hard facts about that, but i have been using it for many year. 
Since Suse included it in there release 7.0 a few years back. Don't know what 
the current status in the various distributions is. I guess it is probably 
the second most used cipher behind aes since the performance for 256bit 
keylength is better or close to the aes speed. Some cryptoanalyst believe it 
to be cryptograhically superior to aes but that is probably a matter of 
opinion and parameters you consider. In the NIST competition it was third 
behind aes and serpent. Serpent itself is probably more secure but lacks 
performance. Twofish is probably also one of the cipher you choose from if 
you don't trust the US government to choose the right one for you. :)

Regards,

Joachim

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060604224937</emailId><senderName>Horst von Brand</senderName><senderEmail>vonbrand@inf.utfsm.cl</senderEmail><timestampReceived>2006-06-04 22:49:37-0400</timestampReceived><subject>Re: [PATCH 3/4] Twofish cipher - i586 assembler</subject><body>

Joachim Fritschi &lt;jfritschi@freenet.de&gt; wrote:
&gt; This patch adds the twofish i586 assembler routine. 

What performance impact does this have on a variety of machines? Is twofish
used enough for this to be relevant?
-- 
Dr. Horst H. von Brand                   User #22616 counter.li.org
Departamento de Informatica                     Fono: +56 32 654431
Universidad Tecnica Federico Santa Maria              +56 32 654239
Casilla 110-V, Valparaiso, Chile                Fax:  +56 32 797513
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060602180601</emailId><senderName>Michael Frey</senderName><senderEmail>mfrey@pepper.com</senderEmail><timestampReceived>2006-06-02 18:06:01-0400</timestampReceived><subject>Re: crypto: Add support for the Geode LX HW AES engine</subject><body>

Jordan,

Thanks -- I will check the AMD web site.  I would love to move to  a  
new kernel, however there seems to be a few things preventing me.

1: There is no LX frame buffer driver
2: The cimmaron libraries are not present
3: The V4L driver has not been upgraded to support a kernel later  
than 2.6.11

Michael

On Jun 2, 2006, at 2:10 PM, Jordan Crouse wrote:

&gt; On 02/06/06 13:32 -0400, Michael Frey wrote:
&gt;&gt; Jordan,
&gt;&gt;
&gt;&gt; This looks great,  however are you going to release a patch against
&gt;&gt; 2.6.11-geode?  2.6.11 is the version all geode patches were issued
&gt;&gt; against.
&gt;
&gt; There is a 2.6.11 version of this on the AMD website, if you need it.
&gt; I think that includes the Crypto API parts, but if not, I can make up
&gt; a quick 2.6.11 patch and send it off to the list.
&gt;
&gt; Since almost all the patches for Geode are now upstream (or heading
&gt; upstream quickly), then we're quickly converging on a point where the
&gt; 2.6.11 patches will be only interesting from a historical standpoint.
&gt; Or, at least - thats what I'm hoping. :)
&gt;
&gt; Regards,
&gt; Jordan
&gt;
&gt; ---
&gt; You are currently subscribed to info-linux@geode.amd.com
&gt; as: mfrey@pepper.com
&gt; To unsubscribe send a blank email to:
&gt; leave-info-linux-7332K@whitestar.amd.com

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060603193940</emailId><senderName>rodger ellis</senderName><senderEmail>rellis@gmx.net</senderEmail><timestampReceived>2006-06-03 19:39:40-0400</timestampReceived><subject>thanks for feedback, but once computer is on?</subject><body>

Many thanks for all the feedbacks  to my question.

In the first instance aes-loop is the way to go, but once the computer is 
on and password has been applied then aes-loop has done its job -this is a very crude \
if  perhaps incorrect assumption. Now what measures can be taken to protect your \
data? for example (not a very good one as this is the other exterme) but you run a \
mail server, i suppose EncFS  might a step in the right direction. 

The circle I am trying to complete is encryption on a labtop
against say theft or trusted parties abuseing that trust,(loop-aes) and finally \
trying to think of a way to protect data once the os is running.


Rodger

-- 


Der GMX SmartSurfer hilft bis zu 70% Ihrer Onlinekosten zu sparen!
      Ideal für Modem und ISDN: http://www.gmx.net/de/go/smartsurfer
    

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060602061151</emailId><senderName>rodger ellis</senderName><senderEmail>rellis@gmx.net</senderEmail><timestampReceived>2006-06-02 06:11:51-0400</timestampReceived><subject>need some feedback please</subject><body>

Hello 

 I don't see the point in encrypting / if you put all your personal data on the /home \
partition. Then / contains just the operating system, and that's nothing someone who \
steals your computer would be interested in. Is my thinking correct here?
-- 


Der GMX SmartSurfer hilft bis zu 70% Ihrer Onlinekosten zu sparen!
      Ideal für Modem und ISDN: http://www.gmx.net/de/go/smartsurfer
    

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060507003517</emailId><senderName></senderName><senderEmail>peter_22</senderEmail><timestampReceived>2006-05-07 00:35:17-0400</timestampReceived><subject>Loop-AES and Twofish on 64-bit CPU</subject><body>

Hi!

Since Loop-AES features a patch for amd64 cpus when using AES cipher it runs
faster creating less load. So everyone will use AES. Twofish and Blowfish
ciphers are considerably slower. But, is there a patch for Twohfish /
Blowfish to make them work faster on amd64??
I´d like to use both ciphers for the same partition, unfortunately both are
much slower than AES. Will this be the same forever?

Best regards,
Peter

-- 
Echte DSL-Flatrate dauerhaft für 0,- Euro*!
"Feel free" mit GMX DSL! http://www.gmx.net/de/go/dsl

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060618165243</emailId><senderName></senderName><senderEmail>peter_22</senderEmail><timestampReceived>2006-06-18 16:52:43-0400</timestampReceived><subject>The evils of SuSE 10.1</subject><body>

Hello!

Configuring current SuSE 10.1 64-bit kernel for root encryption shows up severe \
obstacles. As you know, loop-aes requires to boot with its own initrd, so all kind of \
fancy hardware modules for chipset and such have to be "on-board". In my case this \
includes a VIA Chipset and some SCSI based SATA modules. The point is, when I try to \
built in the kernel sections &lt;*&gt;   ATA/ATAPI/MFM/RLL support
&lt;*&gt;   Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support
and the SCSI part
&lt;*&gt; SCSI device support
&lt;*&gt; Serial ATA (SATA) support
the kernel fails to compile. Both parts alone work to be integrated into the kernel \
but not both together. Normally this should work because there is no reason why ATA \
and SCSI support should not be included in the kernel itself. Any ideas?

"make bzImage" pukes out the following:

*** End of Linux kernel configuration.
*** Execute 'make' to build the kernel or try 'make help'.

blue:/usr/src/linux # make bzImage
  CHK     /usr/src/linux-2.6.16.13-4/include/linux/version.h
  SPLIT   include/linux/autoconf.h -&gt; include/config/*
  CC      arch/x86_64/kernel/asm-offsets.s
  GEN     include/asm-x86_64/asm-offsets.h
[...]
drivers/scsi/built-in.o: In function `do_drive_get_GTF':
(.text+0x10edc): multiple definition of `do_drive_get_GTF'
drivers/ide/built-in.o:(.text+0xc03e): first defined here
ld: Warning: size of symbol `do_drive_get_GTF' changed from 469 in \
drivers/ide/built-in.o to 1016 in drivers/scsi/built-in.o make[1]: *** \
                [drivers/built-in.o] Error 1
make: *** [drivers] Error 2

In case this is a SuSE mistake and there will be no updates available, Debian is on \
drive by the end of this week. SuSE also missed to include ralink drivers for my Wlan \
Stick. Obviously the try to put stones in my ways.

Regards,
Peter

-- 


"Feel free" – 10 GB Mailbox, 100 FreeSMS/Monat ...
Jetzt GMX TopMail testen: http://www.gmx.net/de/go/topmail

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060604131632</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-04 13:16:32-0400</timestampReceived><subject>[PATCH  2/4] Twofish cipher - priority fix</subject><body>

This patch adds a proper driver name and priority to the generic c 
implemtation to allow coexistance of c and assembler modules.

Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

diff -uprN linux-2.6.17-rc5.twofish/crypto/twofish_c.c 
linux-2.6.17-rc5.twofish2/crypto/twofish_c.c
--- linux-2.6.17-rc5.twofish/crypto/twofish_c.c	2006-05-30 15:38:14.627954845 
+0200
+++ linux-2.6.17-rc5.twofish2/crypto/twofish_c.c	2006-05-30 19:54:54.713680651 
+0200
@@ -182,6 +182,8 @@ static void twofish_decrypt(void *cx, u8

 static struct crypto_alg alg = {
 	.cra_name           =   "twofish",
+	.cra_driver_name    =   "twofish-generic",
+	.cra_priority       =   100,
 	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize      =   TF_BLOCK_SIZE,
 	.cra_ctxsize        =   sizeof(struct twofish_ctx),
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060607193732</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-07 19:37:32-0400</timestampReceived><subject>Re: [PATCH  2/4] Twofish cipher - priority fix</subject><body>

On Sunday 04 June 2006 15:16, Joachim Fritschi wrote:
&gt; This patch adds a proper driver name and priority to the generic c 
&gt; implemtation to allow coexistance of c and assembler modules.
My first mail was wordwrapped. This one should be unwrapped and working:

Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

diff -uprN linux-2.6.17-rc5.twofish/crypto/twofish_c.c linux-2.6.17-rc5.twofish2/crypto/twofish_c.c
--- linux-2.6.17-rc5.twofish/crypto/twofish_c.c	2006-05-30 15:38:14.627954845 +0200
+++ linux-2.6.17-rc5.twofish2/crypto/twofish_c.c	2006-05-30 19:54:54.713680651 +0200
@@ -182,6 +182,8 @@ static void twofish_decrypt(void *cx, u8

 static struct crypto_alg alg = {
 	.cra_name           =   "twofish",
+	.cra_driver_name    =   "twofish-generic",
+	.cra_priority       =   100,
 	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize      =   TF_BLOCK_SIZE,
 	.cra_ctxsize        =   sizeof(struct twofish_ctx),
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060616115919</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-16 11:59:19-0400</timestampReceived><subject>Re: [PATCH  2/4] Twofish cipher - priority fix</subject><body>

Updated patch due to the new twofish_common patch

Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

diff -uprN linux-2.6.17-rc5.twofish/crypto/twofish.c linux-2.6.17-rc5.twofish2/crypto/twofish.c
--- linux-2.6.17-rc5.twofish/crypto/twofish.c	2006-06-11 15:58:20.315984114 +0200
+++ linux-2.6.17-rc5.twofish2/crypto/twofish.c	2006-06-11 16:02:17.848687953 +0200
@@ -182,6 +182,8 @@ static void twofish_decrypt(void *cx, u8
 
 static struct crypto_alg alg = {
 	.cra_name           =   "twofish",
+	.cra_driver_name    =   "twofish-generic",
+	.cra_priority       =   100,
 	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize      =   TF_BLOCK_SIZE,
 	.cra_ctxsize        =   sizeof(struct twofish_ctx),

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060604131638</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-04 13:16:38-0400</timestampReceived><subject>[PATCH  3/4] Twofish cipher - i586 assembler</subject><body>

This patch adds the twofish i586 assembler routine. 

Changes since the last version:
- The keysetup is now handled by the twofish_common.c (see patch 1 )

Correctness was verified with the tcrypt module and automated test scripts.

Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

diff -uprN linux-2.6.17-rc5.twofish2/arch/i386/crypto/Makefile 
linux-2.6.17-rc5.twofish3/arch/i386/crypto/Makefile
--- linux-2.6.17-rc5.twofish2/arch/i386/crypto/Makefile	2006-05-30 
19:43:48.768000198 +0200
+++ linux-2.6.17-rc5.twofish3/arch/i386/crypto/Makefile	2006-05-30 
20:06:10.880715217 +0200
@@ -5,5 +5,8 @@
 #

 obj-$(CONFIG_CRYPTO_AES_586) += aes-i586.o
+obj-$(CONFIG_CRYPTO_TWOFISH_586) += twofish-i586.o

 aes-i586-y := aes-i586-asm.o aes.o
+twofish-i586-y := twofish-i586-asm.o 
twofish.o ../../../crypto/twofish_common.o
+
diff -uprN linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish.c 
linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish.c
--- linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish.c	1970-01-01 
01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish.c	2006-05-30 
20:04:16.279682770 +0200
@@ -0,0 +1,88 @@
+/*
+ *  Glue Code for optimized 586 assembler version of TWOFISH
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+
+asmlinkage void twofish_enc_blk(void *ctx, u8 *dst, const u8 *src);
+
+asmlinkage void twofish_dec_blk(void *ctx, u8 *dst, const u8 *src);
+
+
+static struct crypto_alg alg = {
+	.cra_name           =   "twofish",
+	.cra_driver_name    =	"twofish-i586",
+        .cra_priority       =   200,
+	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize      =   TF_BLOCK_SIZE,
+	.cra_ctxsize        =   sizeof(struct twofish_ctx),
+	.cra_alignmask      =	3,
+	.cra_module         =   THIS_MODULE,
+	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
+	.cra_u              =   { .cipher = {
+	.cia_min_keysize    =   TF_MIN_KEY_SIZE,
+	.cia_max_keysize    =   TF_MAX_KEY_SIZE,
+	.cia_setkey         =   twofish_setkey,
+	.cia_encrypt        =   twofish_enc_blk,
+	.cia_decrypt        =   twofish_dec_blk } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION ("Twofish Cipher Algorithm, i586 asm optimized");
diff -uprN linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish-i586-asm.S 
linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish-i586-asm.S
--- linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish-i586-asm.S	1970-01-01 
01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish-i586-asm.S	2006-05-30 
20:00:47.825035584 +0200
@@ -0,0 +1,377 @@
+	/***************************************************************************
+	*   Copyright (C) 2006 by Joachim Fritschi, &lt;jfritschi@freenet.de&gt;        *
+	*                                                                         *
+	*   This program is free software; you can redistribute it and/or modify  *
+	*   it under the terms of the GNU General Public License as published by  *
+	*   the Free Software Foundation; either version 2 of the License, or     *
+	*   (at your option) any later version.                                   *
+	*                                                                         *
+	*   This program is distributed in the hope that it will be useful,       *
+	*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+	*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+	*   GNU General Public License for more details.                          *
+	*                                                                         *
+	*   You should have received a copy of the GNU General Public License     *
+	*   along with this program; if not, write to the                         *
+	*   Free Software Foundation, Inc.,                                       *
+	*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+	***************************************************************************/
+
+.file "twofish-i586-asm.S"
+.text
+
+/* return adress at 0 */
+
+#define in_blk    12  /* input byte array address parameter*/
+#define out_blk   8  /* output byte array address parameter*/
+#define ctx       4  /* Twofish context structure */
+
+#define a_offset	0
+#define b_offset	4
+#define c_offset	8
+#define d_offset	12
+
+/* Structure of the crypto context struct*/
+
+#define s0	0	/* S0 Array 256 Words each */
+#define s1	1024	/* S1 Array */
+#define s2	2048	/* S2 Array */
+#define s3	3072	/* S3 Array */
+#define w	4096	/* 8 whitening keys (word) */
+#define k	4128	/* key 1-32 ( word ) */
+
+
+
+
+/* register aliases for better reading */
+
+#define r0  eax
+#define r1  ebx
+#define r2  ecx
+#define r3  edx
+#define r4  esi
+#define r5  edi
+
+
+
+#define eaxl  al
+#define eaxh  ah
+#define ebxl  bl
+#define ebxh  bh
+#define ecxl  cl
+#define ecxh  ch
+#define edxl  dl
+#define edxh  dh
+
+
+#define _h(reg) reg##h
+#define h(reg) _h(reg)
+
+#define _l(reg) reg##l
+#define l(reg) _l(reg)
+
+/*load input word with whitening */
+
+#define get_input(input_adress,offset,dst,context)\
+	load_input(input_adress,offset,dst);\
+	input_whitening(dst,context,offset);
+
+#define get_dec_input(input_adress,offset,dst,context)\
+	load_dec_input(input_adress,offset,dst);\
+	dec_input_whitening(dst,context,offset);
+
+/* perform output whitening and save value. Old value is saved */
+#define process_output(dst,src,tmp,context,offset)\
+	output_whitening(src,tmp,context,offset);\
+	save_output(dst,offset,tmp);
+
+/* perform output whitening and save value. The old value is destoyed */
+#define destructive_process_output(dst,src,context,offset)\
+	destructive_output_whitening(src,context,offset);\
+	save_output(dst,offset,src);
+
+/* perform output whitening and save value. Old value is saved */
+#define process_dec_output(dst,src,tmp,context,offset)\
+	dec_output_whitening(src,tmp,context,offset);\
+	save_output(dst,offset,tmp);
+
+/* perform output whitening and save value. The old value is destoyed */
+#define destructive_process_dec_output(dst,src,context,offset)\
+	destructive_dec_output_whitening(src,context,offset);\
+	save_output(dst,offset,src);
+
+/* load input */
+#define load_input(input_adress,offset,dst)\
+	mov	offset(%input_adress), %dst;
+
+#define load_dec_input(input_adress,offset,dst)\
+	mov	offset(%input_adress), %dst;
+
+/* performs input whitening */
+#define input_whitening(src,context,offset)\
+	xor	w+offset(%context), %src;\
+
+#define dec_input_whitening(src,context,offset)\
+	xor	w+16+offset(%context), %src;
+
+/* performs decryption output whitening */
+/* Result is in dst, the original value is still intact */
+#define dec_output_whitening(src,dst,context,offset)\
+	mov	w+offset(%context), %dst;\
+	xor	%src,%dst;
+
+/* performs encryption output whitening */
+/* Result is in dst, the original value is still intact */
+#define output_whitening(src,dst,context,offset)\
+	mov	w+16+offset(%context), %dst;\
+	xor	%src,%dst;
+
+/* performs encryption output whitening */
+/* Result is in dst, the original value is destroyed */
+#define destructive_output_whitening(src,context,offset)\
+	xor	w+16+offset(%context), %src;\
+
+/* performs decryption output whitening */
+/* Result is in dst, the original value is destroyed */
+#define destructive_dec_output_whitening(src,context,offset)\
+	xor	w+offset(%context), %src;\
+
+/* save the output values */
+#define save_output(output_adress,offset,src)\
+	mov	%src,offset(%output_adress);\
+
+/* load sbox values */
+#define load_s(context,sbox,index,dst)\
+	xor	sbox(%context,%index,4),%dst;\
+
+/* performs "a" sbox transfomation */
+/* input value is still intact but rotatet */
+#define g1(context,input,dst,tmp)\
+	xor	%dst,%dst;\
+ 	movzx	%l(input),%tmp;\
+	load_s(context,s0,tmp,dst);\
+	movzx	%h(input),%tmp;\
+	load_s(context,s1,tmp,dst);\
+	ror	$16,%input;\
+	movzx	%l(input),%tmp;\
+	load_s(context,s2,tmp,dst);\
+	movzx	%h(input),%tmp;\
+	load_s(context,s3,tmp,dst);\
+
+/* performs "b" sbox transfomation */
+/* input value is still intact but rotatet */
+#define g2(context,input,dst,tmp)\
+	xor	%dst,%dst;\
+	movzx	%l(input),%tmp;\
+	load_s(context,s1,tmp,dst);\
+	movzx	%h(input),%tmp;\
+	load_s(context,s2,tmp,dst);\
+	ror	$16,%input;\
+	movzx	%l(input),%tmp;\
+	load_s(context,s3,tmp,dst);\
+	movzx	%h(input),%tmp;\
+	load_s(context,s0,tmp,dst);\
+	;
+
+/* Pseudo Harmann Transfomation */
+#define pht(a,b)\
+	add	%b,%a;\
+	add	%a,%b;
+
+/* Adds the round keys to a and b */
+#define round_key(context,a,b,round)\
+	add	k+round(%context),%a;\
+	add	k+4+round(%context),%b;\
+
+
+/* Input in a and b , output in fa fb */
+/* a and b a prerotate for the next round */
+#define f_function(context,a,b,fa,fb,tmp3,round)\
+	g1(context,a,fa,tmp3);\
+	g2(context,b,fb,tmp3);\
+	ror	$16,%a;\
+	ror	$15,%b;\
+	pht(fa,fb);\
+	round_key(context,fa,fb,round);
+
+
+/* Input in a and b , output in fa fb */
+/* a and b a prerotate for the next round */
+#define reverse_f_function(context,a,b,fa,fb,tmp3,round)\
+	g1(context,a,fa,tmp3);\
+	g2(context,b,fb,tmp3);\
+	ror	$15,%a;\
+	ror	$16,%b;\
+	pht(fa,fb);\
+	round_key(context,fa,fb,round);
+
+
+/* Output in a and b */
+/* olda contains the a of the round before, cuts down stack use to one push / 
pop per round for the oldb */
+/* b is alread pre rotated (rol 1) in the f funtion to save one instruction 
*/
+#define round(context,a,b,tmp1,tmp2,tmp3,olda,round)\
+	f_function(context,a,b,tmp1,tmp2,tmp3,round);\
+	mov	%b,%tmp3;\
+	pop	%b;\
+	push	%tmp3;\
+	xor	%tmp2,%b;\
+	xor	%tmp1,%olda;\
+	ror	$1,%olda;
+
+
+/* Output in a and b */
+/* olda contains the a of the round before, cuts donw stack use to one push / 
pop per round for the oldb */
+/* a is alread pre rotated (rol 1) in the f funtion to save one instruction 
*/
+#define dec_round(context,a,b,tmp1,tmp2,tmp3,olda,round)\
+	reverse_f_function(context,a,b,tmp1,tmp2,tmp3,round);\
+	xor	%tmp1,%olda;\
+	mov	%b,%tmp3;\
+	pop	%b;\
+	push	%tmp3;\
+	xor	%tmp2,%b;\
+	ror	$1,%b;
+
+
+
+.align 4
+.global twofish_enc_blk
+.global twofish_dec_blk
+
+
+
+twofish_enc_blk:
+	push	%ebp			/* save registers according to calling convention*/
+	push    %r1
+	push    %esi
+	push    %edi
+
+
+	mov	ctx + 16(%esp),%ebp	/* abuse the base pointer: set new base bointer to 
the crypto ctx */
+	mov     in_blk+16(%esp),%r5	/* input adress in r5 */
+
+	get_input(r5,a_offset,r0,ebp);
+	get_input(r5,b_offset,r1,ebp);
+
+	/* To save a few instructions round 1 is unrolled */
+
+	f_function(ebp,r0,r1,r2,r3,r4,0);	//ouput in r2 r3
+	push	%r1;
+
+	get_input(r5,c_offset,r1,ebp);
+	get_input(r5,d_offset,r4,ebp);
+	xor	%r1,%r2;\
+	ror	$1,%r2;\
+	rol	$1,%r4;\
+	xor	%r4,%r3;
+
+
+	round(ebp,r2,r3,r4,r5,r1,r0,1*8);
+	round(ebp,r0,r3,r4,r5,r1,r2,2*8);
+	round(ebp,r2,r3,r4,r5,r1,r0,3*8);
+	round(ebp,r0,r3,r4,r5,r1,r2,4*8);
+	round(ebp,r2,r3,r4,r5,r1,r0,5*8);
+	round(ebp,r0,r3,r4,r5,r1,r2,6*8);
+	round(ebp,r2,r3,r4,r5,r1,r0,7*8);
+	round(ebp,r0,r3,r4,r5,r1,r2,8*8);
+	round(ebp,r2,r3,r4,r5,r1,r0,9*8);
+	round(ebp,r0,r3,r4,r5,r1,r2,10*8);
+	round(ebp,r2,r3,r4,r5,r1,r0,11*8);
+	round(ebp,r0,r3,r4,r5,r1,r2,12*8);
+	round(ebp,r2,r3,r4,r5,r1,r0,13*8);
+	round(ebp,r0,r3,r4,r5,r1,r2,14*8);
+
+	/* To save a few instructions round 15 is unrolled */
+
+	mov	out_blk+20(%esp),%r1;
+	process_output(r1,r2,r4,ebp,a_offset);
+	process_output(r1,r3,r4,ebp,b_offset);
+	g1(ebp,r2,r4,r1);
+	g2(ebp,r3,r5,r1);
+	pht(r4,r5);
+	round_key(ebp,r4,r5,15*8);
+	pop	%r1;
+	xor	%r5,%r1;
+	xor	%r4,%r0;
+	ror	$1,%r0;
+
+	mov	out_blk+16(%esp),%r3
+	destructive_process_output(r3,r0,ebp,c_offset);
+	destructive_process_output(r3,r1,ebp,d_offset);
+
+	pop	%edi
+	pop	%esi
+	pop	%r1
+	pop	%ebp
+	mov	$1,%r0
+	ret
+
+twofish_dec_blk:
+	push	%ebp			/* save  registers according to calling convention*/
+	push    %r1
+	push    %esi
+	push    %edi
+
+
+	mov	ctx + 16(%esp),%ebp	/* abuse the base pointer: set new base bointer to 
the crypto ctx */
+	mov     in_blk+16(%esp),%r5	/* output adress in r5 */
+
+	/* To save a few instructions round 15 is unrolled */
+	get_dec_input(r5,a_offset,r0,ebp);
+	get_dec_input(r5,b_offset,r1,ebp);
+
+	reverse_f_function(ebp,r0,r1,r2,r3,r4,15*8);
+
+        push %r1; /* save oldb for next rount */
+
+	get_dec_input(r5,c_offset,r1,ebp);
+	get_dec_input(r5,d_offset,r4,ebp);
+	xor	%r4,%r3;
+	ror	$1,%r3;
+	rol	$1,%r1;
+	xor	%r1,%r2;
+
+	dec_round(ebp,r2,r3,r4,r5,r1,r0,14*8);
+	dec_round(ebp,r0,r3,r4,r5,r1,r2,13*8);
+	dec_round(ebp,r2,r3,r4,r5,r1,r0,12*8);
+	dec_round(ebp,r0,r3,r4,r5,r1,r2,11*8);
+	dec_round(ebp,r2,r3,r4,r5,r1,r0,10*8);
+	dec_round(ebp,r0,r3,r4,r5,r1,r2,9*8);
+	dec_round(ebp,r2,r3,r4,r5,r1,r0,8*8);
+	dec_round(ebp,r0,r3,r4,r5,r1,r2,7*8);
+	dec_round(ebp,r2,r3,r4,r5,r1,r0,6*8);
+	dec_round(ebp,r0,r3,r4,r5,r1,r2,5*8);
+	dec_round(ebp,r2,r3,r4,r5,r1,r0,4*8);
+	dec_round(ebp,r0,r3,r4,r5,r1,r2,3*8);
+	dec_round(ebp,r2,r3,r4,r5,r1,r0,2*8);
+	dec_round(ebp,r0,r3,r4,r5,r1,r2,8);
+
+	/* To save a few instructions round 0 is unrolled */
+	mov	out_blk+20(%esp),%r1;
+	process_dec_output(r1,r2,r4,ebp,a_offset);
+	process_dec_output(r1,r3,r4,ebp,b_offset);
+	g1(ebp,r2,r4,r1);
+	g2(ebp,r3,r5,r1);
+	pht(r4,r5);
+	round_key(ebp,r4,r5,0);
+
+	pop	%r1;
+	xor	%r1,%r5
+	ror	$1,%r5
+	xor	%r0,%r4
+
+
+
+	mov	out_blk+16(%esp),%r3
+	destructive_process_dec_output(r3,r4,ebp,c_offset);
+	destructive_process_dec_output(r3,r5,ebp,d_offset);
+
+	pop	%edi
+	pop	%esi
+	pop	%r1
+	pop	%ebp
+	mov	$1,%r0
+	ret
+
+
+
+
diff -uprN linux-2.6.17-rc5.twofish2/crypto/Kconfig 
linux-2.6.17-rc5.twofish3/crypto/Kconfig
--- linux-2.6.17-rc5.twofish2/crypto/Kconfig	2006-05-30 19:44:02.607579102 
+0200
+++ linux-2.6.17-rc5.twofish3/crypto/Kconfig	2006-05-30 20:00:47.841035197 
+0200
@@ -142,6 +142,20 @@ config CRYPTO_TWOFISH
 	  See also:
 	  &lt;http://www.schneier.com/twofish.html&gt;

+config CRYPTO_TWOFISH_586
+	tristate "Twofish cipher algorithms (i586)"
+	depends on CRYPTO &amp;&amp; ((X86 || UML_X86) &amp;&amp; !64BIT)
+	help
+	  Twofish cipher algorithm.
+
+	  Twofish was submitted as an AES (Advanced Encryption Standard)
+	  candidate cipher by researchers at CounterPane Systems.  It is a
+	  16 round block cipher supporting key sizes of 128, 192, and 256
+	  bits.
+
+	  See also:
+	  &lt;http://www.schneier.com/twofish.html&gt;
+
 config CRYPTO_SERPENT
 	tristate "Serpent cipher algorithm"
 	depends on CRYPTO
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060609084351</emailId><senderName>Phil H</senderName><senderEmail>philtickle200@yahoo.com</senderEmail><timestampReceived>2006-06-09 08:43:51-0400</timestampReceived><subject>Distinguishability of encrypted partition</subject><body>

The recent threads on deniability etc lead me to ask:

Just how distinguishable from random data is a loop-aes encrypted partition?

I had assumed these were effectively indistinguishable.  Or does it boil down to a \
question of just how "random" is random?

I'm not sure I follow (in discussions about deniability) why a user cannot simply say \
they shredded that partition ....

 __________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 


[Attachment #3 (text/html)]

The recent threads on deniability etc lead me to ask:&lt;br&gt;&lt;br&gt;Just how distinguishable \
from random data is a loop-aes encrypted partition?&lt;br&gt;&lt;br&gt;I had assumed these were \
effectively indistinguishable.  Or does it boil down to a question of just how \
"random" is random?&lt;br&gt;&lt;br&gt;I'm not sure I follow (in discussions about deniability) \
why a user cannot simply say they shredded that partition \
....&lt;br&gt;&lt;p&gt; __________________________________________________&lt;br&gt;Do You \
Yahoo!?&lt;br&gt;Tired of spam?  Yahoo! Mail has the best spam protection around \
&lt;br&gt;http://mail.yahoo.com 


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060604131621</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-04 13:16:21-0400</timestampReceived><subject>[PATCH  1/4] Twofish cipher - split out common c code</subject><body>

I have revised my initial twofish assembler patchset according to the 
criticims i recieved on this list:
This patch splits up the twofish crypto routine into a common part ( key 
setup  ) which will be uses by all twofish crypto modules ( generic-c , i586 
assembler and x86_64 assembler ) and generic-c part. It also creates a new 
header file which will be used by all 3 modules. 
This eliminates all code duplication.
Correctness was verified with the tcrypt module and automated test scripts.
   
Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

diff -uprN linux-2.6.17-rc5/crypto/Makefile 
linux-2.6.17-rc5.twofish/crypto/Makefile
--- linux-2.6.17-rc5/crypto/Makefile	2006-06-03 16:21:51.000000000 +0200
+++ linux-2.6.17-rc5.twofish/crypto/Makefile	2006-06-04 13:59:27.949797218 
+0200
@@ -32,3 +32,5 @@ obj-$(CONFIG_CRYPTO_MICHAEL_MIC) += mich
 obj-$(CONFIG_CRYPTO_CRC32C) += crc32c.o

 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
+
+twofish-objs := twofish_c.o twofish_common.o
diff -uprN linux-2.6.17-rc5/crypto/twofish.c 
linux-2.6.17-rc5.twofish/crypto/twofish.c
--- linux-2.6.17-rc5/crypto/twofish.c	2006-06-03 16:21:51.000000000 +0200
+++ linux-2.6.17-rc5.twofish/crypto/twofish.c	1970-01-01 01:00:00.000000000 
+0100
@@ -1,908 +0,0 @@
-/*
- * Twofish for CryptoAPI
- *
- * Originally Twofish for GPG
- * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
- * 256-bit key length added March 20, 1999
- * Some modifications to reduce the text size by Werner Koch, April, 1998
- * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
- * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
- *
- * The original author has disclaimed all copyright interest in this
- * code and thus put it in the public domain. The subsequent authors
- * have put this under the GNU General Public License.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
- * USA
- *
- * This code is a "clean room" implementation, written from the paper
- * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
- * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
- * through http://www.counterpane.com/twofish.html
- *
- * For background information on multiplication in finite fields, used for
- * the matrix operations in the key schedule, see the book _Contemporary
- * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
- * Third Edition.
- */
-
-#include &lt;asm/byteorder.h&gt;
-#include &lt;linux/module.h&gt;
-#include &lt;linux/init.h&gt;
-#include &lt;linux/types.h&gt;
-#include &lt;linux/errno.h&gt;
-#include &lt;linux/crypto.h&gt;
-#include &lt;linux/bitops.h&gt;
-
-
-/* The large precomputed tables for the Twofish cipher (twofish.c)
- * Taken from the same source as twofish.c
- * Marc Mutz &lt;Marc@Mutz.com&gt;
- */
-
-/* These two tables are the q0 and q1 permutations, exactly as described in
- * the Twofish paper. */
-
-static const u8 q0[256] = {
-   0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78,
-   0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C,
-   0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30,
-   0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82,
-   0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE,
-   0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B,
-   0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45,
-   0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7,
-   0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF,
-   0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8,
-   0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED,
-   0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90,
-   0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B,
-   0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B,
-   0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F,
-   0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A,
-   0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17,
-   0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72,
-   0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68,
-   0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4,
-   0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42,
-   0x4A, 0x5E, 0xC1, 0xE0
-};
-
-static const u8 q1[256] = {
-   0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B,
-   0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1,
-   0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B,
-   0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5,
-   0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54,
-   0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96,
-   0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7,
-   0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8,
-   0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF,
-   0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9,
-   0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D,
-   0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E,
-   0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21,
-   0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01,
-   0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E,
-   0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64,
-   0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44,
-   0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E,
-   0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B,
-   0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9,
-   0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56,
-   0x55, 0x09, 0xBE, 0x91
-};
-
-/* These MDS tables are actually tables of MDS composed with q0 and q1,
- * because it is only ever used that way and we can save some time by
- * precomputing.  Of course the main saving comes from precomputing the
- * GF(2^8) multiplication involved in the MDS matrix multiply; by looking
- * things up in these tables we reduce the matrix multiply to four lookups
- * and three XORs.  Semi-formally, the definition of these tables is:
- * mds[0][i] = MDS (q1[i] 0 0 0)^T  mds[1][i] = MDS (0 q0[i] 0 0)^T
- * mds[2][i] = MDS (0 0 q1[i] 0)^T  mds[3][i] = MDS (0 0 0 q0[i])^T
- * where ^T means "transpose", the matrix multiply is performed in GF(2^8)
- * represented as GF(2)[x]/v(x) where v(x)=x^8+x^6+x^5+x^3+1 as described
- * by Schneier et al, and I'm casually glossing over the byte/word
- * conversion issues. */
-
-static const u32 mds[4][256] = {
-   {0xBCBC3275, 0xECEC21F3, 0x202043C6, 0xB3B3C9F4, 0xDADA03DB, 0x02028B7B,
-    0xE2E22BFB, 0x9E9EFAC8, 0xC9C9EC4A, 0xD4D409D3, 0x18186BE6, 0x1E1E9F6B,
-    0x98980E45, 0xB2B2387D, 0xA6A6D2E8, 0x2626B74B, 0x3C3C57D6, 0x93938A32,
-    0x8282EED8, 0x525298FD, 0x7B7BD437, 0xBBBB3771, 0x5B5B97F1, 0x474783E1,
-    0x24243C30, 0x5151E20F, 0xBABAC6F8, 0x4A4AF31B, 0xBFBF4887, 0x0D0D70FA,
-    0xB0B0B306, 0x7575DE3F, 0xD2D2FD5E, 0x7D7D20BA, 0x666631AE, 0x3A3AA35B,
-    0x59591C8A, 0x00000000, 0xCDCD93BC, 0x1A1AE09D, 0xAEAE2C6D, 0x7F7FABC1,
-    0x2B2BC7B1, 0xBEBEB90E, 0xE0E0A080, 0x8A8A105D, 0x3B3B52D2, 0x6464BAD5,
-    0xD8D888A0, 0xE7E7A584, 0x5F5FE807, 0x1B1B1114, 0x2C2CC2B5, 0xFCFCB490,
-    0x3131272C, 0x808065A3, 0x73732AB2, 0x0C0C8173, 0x79795F4C, 0x6B6B4154,
-    0x4B4B0292, 0x53536974, 0x94948F36, 0x83831F51, 0x2A2A3638, 0xC4C49CB0,
-    0x2222C8BD, 0xD5D5F85A, 0xBDBDC3FC, 0x48487860, 0xFFFFCE62, 0x4C4C0796,
-    0x4141776C, 0xC7C7E642, 0xEBEB24F7, 0x1C1C1410, 0x5D5D637C, 0x36362228,
-    0x6767C027, 0xE9E9AF8C, 0x4444F913, 0x1414EA95, 0xF5F5BB9C, 0xCFCF18C7,
-    0x3F3F2D24, 0xC0C0E346, 0x7272DB3B, 0x54546C70, 0x29294CCA, 0xF0F035E3,
-    0x0808FE85, 0xC6C617CB, 0xF3F34F11, 0x8C8CE4D0, 0xA4A45993, 0xCACA96B8,
-    0x68683BA6, 0xB8B84D83, 0x38382820, 0xE5E52EFF, 0xADAD569F, 0x0B0B8477,
-    0xC8C81DC3, 0x9999FFCC, 0x5858ED03, 0x19199A6F, 0x0E0E0A08, 0x95957EBF,
-    0x70705040, 0xF7F730E7, 0x6E6ECF2B, 0x1F1F6EE2, 0xB5B53D79, 0x09090F0C,
-    0x616134AA, 0x57571682, 0x9F9F0B41, 0x9D9D803A, 0x111164EA, 0x2525CDB9,
-    0xAFAFDDE4, 0x4545089A, 0xDFDF8DA4, 0xA3A35C97, 0xEAEAD57E, 0x353558DA,
-    0xEDEDD07A, 0x4343FC17, 0xF8F8CB66, 0xFBFBB194, 0x3737D3A1, 0xFAFA401D,
-    0xC2C2683D, 0xB4B4CCF0, 0x32325DDE, 0x9C9C71B3, 0x5656E70B, 0xE3E3DA72,
-    0x878760A7, 0x15151B1C, 0xF9F93AEF, 0x6363BFD1, 0x3434A953, 0x9A9A853E,
-    0xB1B1428F, 0x7C7CD133, 0x88889B26, 0x3D3DA65F, 0xA1A1D7EC, 0xE4E4DF76,
-    0x8181942A, 0x91910149, 0x0F0FFB81, 0xEEEEAA88, 0x161661EE, 0xD7D77321,
-    0x9797F5C4, 0xA5A5A81A, 0xFEFE3FEB, 0x6D6DB5D9, 0x7878AEC5, 0xC5C56D39,
-    0x1D1DE599, 0x7676A4CD, 0x3E3EDCAD, 0xCBCB6731, 0xB6B6478B, 0xEFEF5B01,
-    0x12121E18, 0x6060C523, 0x6A6AB0DD, 0x4D4DF61F, 0xCECEE94E, 0xDEDE7C2D,
-    0x55559DF9, 0x7E7E5A48, 0x2121B24F, 0x03037AF2, 0xA0A02665, 0x5E5E198E,
-    0x5A5A6678, 0x65654B5C, 0x62624E58, 0xFDFD4519, 0x0606F48D, 0x404086E5,
-    0xF2F2BE98, 0x3333AC57, 0x17179067, 0x05058E7F, 0xE8E85E05, 0x4F4F7D64,
-    0x89896AAF, 0x10109563, 0x74742FB6, 0x0A0A75FE, 0x5C5C92F5, 0x9B9B74B7,
-    0x2D2D333C, 0x3030D6A5, 0x2E2E49CE, 0x494989E9, 0x46467268, 0x77775544,
-    0xA8A8D8E0, 0x9696044D, 0x2828BD43, 0xA9A92969, 0xD9D97929, 0x8686912E,
-    0xD1D187AC, 0xF4F44A15, 0x8D8D1559, 0xD6D682A8, 0xB9B9BC0A, 0x42420D9E,
-    0xF6F6C16E, 0x2F2FB847, 0xDDDD06DF, 0x23233934, 0xCCCC6235, 0xF1F1C46A,
-    0xC1C112CF, 0x8585EBDC, 0x8F8F9E22, 0x7171A1C9, 0x9090F0C0, 0xAAAA539B,
-    0x0101F189, 0x8B8BE1D4, 0x4E4E8CED, 0x8E8E6FAB, 0xABABA212, 0x6F6F3EA2,
-    0xE6E6540D, 0xDBDBF252, 0x92927BBB, 0xB7B7B602, 0x6969CA2F, 0x3939D9A9,
-    0xD3D30CD7, 0xA7A72361, 0xA2A2AD1E, 0xC3C399B4, 0x6C6C4450, 0x07070504,
-    0x04047FF6, 0x272746C2, 0xACACA716, 0xD0D07625, 0x50501386, 0xDCDCF756,
-    0x84841A55, 0xE1E15109, 0x7A7A25BE, 0x1313EF91},
-
-   {0xA9D93939, 0x67901717, 0xB3719C9C, 0xE8D2A6A6, 0x04050707, 0xFD985252,
-    0xA3658080, 0x76DFE4E4, 0x9A084545, 0x92024B4B, 0x80A0E0E0, 0x78665A5A,
-    0xE4DDAFAF, 0xDDB06A6A, 0xD1BF6363, 0x38362A2A, 0x0D54E6E6, 0xC6432020,
-    0x3562CCCC, 0x98BEF2F2, 0x181E1212, 0xF724EBEB, 0xECD7A1A1, 0x6C774141,
-    0x43BD2828, 0x7532BCBC, 0x37D47B7B, 0x269B8888, 0xFA700D0D, 0x13F94444,
-    0x94B1FBFB, 0x485A7E7E, 0xF27A0303, 0xD0E48C8C, 0x8B47B6B6, 0x303C2424,
-    0x84A5E7E7, 0x54416B6B, 0xDF06DDDD, 0x23C56060, 0x1945FDFD, 0x5BA33A3A,
-    0x3D68C2C2, 0x59158D8D, 0xF321ECEC, 0xAE316666, 0xA23E6F6F, 0x82165757,
-    0x63951010, 0x015BEFEF, 0x834DB8B8, 0x2E918686, 0xD9B56D6D, 0x511F8383,
-    0x9B53AAAA, 0x7C635D5D, 0xA63B6868, 0xEB3FFEFE, 0xA5D63030, 0xBE257A7A,
-    0x16A7ACAC, 0x0C0F0909, 0xE335F0F0, 0x6123A7A7, 0xC0F09090, 0x8CAFE9E9,
-    0x3A809D9D, 0xF5925C5C, 0x73810C0C, 0x2C273131, 0x2576D0D0, 0x0BE75656,
-    0xBB7B9292, 0x4EE9CECE, 0x89F10101, 0x6B9F1E1E, 0x53A93434, 0x6AC4F1F1,
-    0xB499C3C3, 0xF1975B5B, 0xE1834747, 0xE66B1818, 0xBDC82222, 0x450E9898,
-    0xE26E1F1F, 0xF4C9B3B3, 0xB62F7474, 0x66CBF8F8, 0xCCFF9999, 0x95EA1414,
-    0x03ED5858, 0x56F7DCDC, 0xD4E18B8B, 0x1C1B1515, 0x1EADA2A2, 0xD70CD3D3,
-    0xFB2BE2E2, 0xC31DC8C8, 0x8E195E5E, 0xB5C22C2C, 0xE9894949, 0xCF12C1C1,
-    0xBF7E9595, 0xBA207D7D, 0xEA641111, 0x77840B0B, 0x396DC5C5, 0xAF6A8989,
-    0x33D17C7C, 0xC9A17171, 0x62CEFFFF, 0x7137BBBB, 0x81FB0F0F, 0x793DB5B5,
-    0x0951E1E1, 0xADDC3E3E, 0x242D3F3F, 0xCDA47676, 0xF99D5555, 0xD8EE8282,
-    0xE5864040, 0xC5AE7878, 0xB9CD2525, 0x4D049696, 0x44557777, 0x080A0E0E,
-    0x86135050, 0xE730F7F7, 0xA1D33737, 0x1D40FAFA, 0xAA346161, 0xED8C4E4E,
-    0x06B3B0B0, 0x706C5454, 0xB22A7373, 0xD2523B3B, 0x410B9F9F, 0x7B8B0202,
-    0xA088D8D8, 0x114FF3F3, 0x3167CBCB, 0xC2462727, 0x27C06767, 0x90B4FCFC,
-    0x20283838, 0xF67F0404, 0x60784848, 0xFF2EE5E5, 0x96074C4C, 0x5C4B6565,
-    0xB1C72B2B, 0xAB6F8E8E, 0x9E0D4242, 0x9CBBF5F5, 0x52F2DBDB, 0x1BF34A4A,
-    0x5FA63D3D, 0x9359A4A4, 0x0ABCB9B9, 0xEF3AF9F9, 0x91EF1313, 0x85FE0808,
-    0x49019191, 0xEE611616, 0x2D7CDEDE, 0x4FB22121, 0x8F42B1B1, 0x3BDB7272,
-    0x47B82F2F, 0x8748BFBF, 0x6D2CAEAE, 0x46E3C0C0, 0xD6573C3C, 0x3E859A9A,
-    0x6929A9A9, 0x647D4F4F, 0x2A948181, 0xCE492E2E, 0xCB17C6C6, 0x2FCA6969,
-    0xFCC3BDBD, 0x975CA3A3, 0x055EE8E8, 0x7AD0EDED, 0xAC87D1D1, 0x7F8E0505,
-    0xD5BA6464, 0x1AA8A5A5, 0x4BB72626, 0x0EB9BEBE, 0xA7608787, 0x5AF8D5D5,
-    0x28223636, 0x14111B1B, 0x3FDE7575, 0x2979D9D9, 0x88AAEEEE, 0x3C332D2D,
-    0x4C5F7979, 0x02B6B7B7, 0xB896CACA, 0xDA583535, 0xB09CC4C4, 0x17FC4343,
-    0x551A8484, 0x1FF64D4D, 0x8A1C5959, 0x7D38B2B2, 0x57AC3333, 0xC718CFCF,
-    0x8DF40606, 0x74695353, 0xB7749B9B, 0xC4F59797, 0x9F56ADAD, 0x72DAE3E3,
-    0x7ED5EAEA, 0x154AF4F4, 0x229E8F8F, 0x12A2ABAB, 0x584E6262, 0x07E85F5F,
-    0x99E51D1D, 0x34392323, 0x6EC1F6F6, 0x50446C6C, 0xDE5D3232, 0x68724646,
-    0x6526A0A0, 0xBC93CDCD, 0xDB03DADA, 0xF8C6BABA, 0xC8FA9E9E, 0xA882D6D6,
-    0x2BCF6E6E, 0x40507070, 0xDCEB8585, 0xFE750A0A, 0x328A9393, 0xA48DDFDF,
-    0xCA4C2929, 0x10141C1C, 0x2173D7D7, 0xF0CCB4B4, 0xD309D4D4, 0x5D108A8A,
-    0x0FE25151, 0x00000000, 0x6F9A1919, 0x9DE01A1A, 0x368F9494, 0x42E6C7C7,
-    0x4AECC9C9, 0x5EFDD2D2, 0xC1AB7F7F, 0xE0D8A8A8},
-
-   {0xBC75BC32, 0xECF3EC21, 0x20C62043, 0xB3F4B3C9, 0xDADBDA03, 0x027B028B,
-    0xE2FBE22B, 0x9EC89EFA, 0xC94AC9EC, 0xD4D3D409, 0x18E6186B, 0x1E6B1E9F,
-    0x9845980E, 0xB27DB238, 0xA6E8A6D2, 0x264B26B7, 0x3CD63C57, 0x9332938A,
-    0x82D882EE, 0x52FD5298, 0x7B377BD4, 0xBB71BB37, 0x5BF15B97, 0x47E14783,
-    0x2430243C, 0x510F51E2, 0xBAF8BAC6, 0x4A1B4AF3, 0xBF87BF48, 0x0DFA0D70,
-    0xB006B0B3, 0x753F75DE, 0xD25ED2FD, 0x7DBA7D20, 0x66AE6631, 0x3A5B3AA3,
-    0x598A591C, 0x00000000, 0xCDBCCD93, 0x1A9D1AE0, 0xAE6DAE2C, 0x7FC17FAB,
-    0x2BB12BC7, 0xBE0EBEB9, 0xE080E0A0, 0x8A5D8A10, 0x3BD23B52, 0x64D564BA,
-    0xD8A0D888, 0xE784E7A5, 0x5F075FE8, 0x1B141B11, 0x2CB52CC2, 0xFC90FCB4,
-    0x312C3127, 0x80A38065, 0x73B2732A, 0x0C730C81, 0x794C795F, 0x6B546B41,
-    0x4B924B02, 0x53745369, 0x9436948F, 0x8351831F, 0x2A382A36, 0xC4B0C49C,
-    0x22BD22C8, 0xD55AD5F8, 0xBDFCBDC3, 0x48604878, 0xFF62FFCE, 0x4C964C07,
-    0x416C4177, 0xC742C7E6, 0xEBF7EB24, 0x1C101C14, 0x5D7C5D63, 0x36283622,
-    0x672767C0, 0xE98CE9AF, 0x441344F9, 0x149514EA, 0xF59CF5BB, 0xCFC7CF18,
-    0x3F243F2D, 0xC046C0E3, 0x723B72DB, 0x5470546C, 0x29CA294C, 0xF0E3F035,
-    0x088508FE, 0xC6CBC617, 0xF311F34F, 0x8CD08CE4, 0xA493A459, 0xCAB8CA96,
-    0x68A6683B, 0xB883B84D, 0x38203828, 0xE5FFE52E, 0xAD9FAD56, 0x0B770B84,
-    0xC8C3C81D, 0x99CC99FF, 0x580358ED, 0x196F199A, 0x0E080E0A, 0x95BF957E,
-    0x70407050, 0xF7E7F730, 0x6E2B6ECF, 0x1FE21F6E, 0xB579B53D, 0x090C090F,
-    0x61AA6134, 0x57825716, 0x9F419F0B, 0x9D3A9D80, 0x11EA1164, 0x25B925CD,
-    0xAFE4AFDD, 0x459A4508, 0xDFA4DF8D, 0xA397A35C, 0xEA7EEAD5, 0x35DA3558,
-    0xED7AEDD0, 0x431743FC, 0xF866F8CB, 0xFB94FBB1, 0x37A137D3, 0xFA1DFA40,
-    0xC23DC268, 0xB4F0B4CC, 0x32DE325D, 0x9CB39C71, 0x560B56E7, 0xE372E3DA,
-    0x87A78760, 0x151C151B, 0xF9EFF93A, 0x63D163BF, 0x345334A9, 0x9A3E9A85,
-    0xB18FB142, 0x7C337CD1, 0x8826889B, 0x3D5F3DA6, 0xA1ECA1D7, 0xE476E4DF,
-    0x812A8194, 0x91499101, 0x0F810FFB, 0xEE88EEAA, 0x16EE1661, 0xD721D773,
-    0x97C497F5, 0xA51AA5A8, 0xFEEBFE3F, 0x6DD96DB5, 0x78C578AE, 0xC539C56D,
-    0x1D991DE5, 0x76CD76A4, 0x3EAD3EDC, 0xCB31CB67, 0xB68BB647, 0xEF01EF5B,
-    0x1218121E, 0x602360C5, 0x6ADD6AB0, 0x4D1F4DF6, 0xCE4ECEE9, 0xDE2DDE7C,
-    0x55F9559D, 0x7E487E5A, 0x214F21B2, 0x03F2037A, 0xA065A026, 0x5E8E5E19,
-    0x5A785A66, 0x655C654B, 0x6258624E, 0xFD19FD45, 0x068D06F4, 0x40E54086,
-    0xF298F2BE, 0x335733AC, 0x17671790, 0x057F058E, 0xE805E85E, 0x4F644F7D,
-    0x89AF896A, 0x10631095, 0x74B6742F, 0x0AFE0A75, 0x5CF55C92, 0x9BB79B74,
-    0x2D3C2D33, 0x30A530D6, 0x2ECE2E49, 0x49E94989, 0x46684672, 0x77447755,
-    0xA8E0A8D8, 0x964D9604, 0x284328BD, 0xA969A929, 0xD929D979, 0x862E8691,
-    0xD1ACD187, 0xF415F44A, 0x8D598D15, 0xD6A8D682, 0xB90AB9BC, 0x429E420D,
-    0xF66EF6C1, 0x2F472FB8, 0xDDDFDD06, 0x23342339, 0xCC35CC62, 0xF16AF1C4,
-    0xC1CFC112, 0x85DC85EB, 0x8F228F9E, 0x71C971A1, 0x90C090F0, 0xAA9BAA53,
-    0x018901F1, 0x8BD48BE1, 0x4EED4E8C, 0x8EAB8E6F, 0xAB12ABA2, 0x6FA26F3E,
-    0xE60DE654, 0xDB52DBF2, 0x92BB927B, 0xB702B7B6, 0x692F69CA, 0x39A939D9,
-    0xD3D7D30C, 0xA761A723, 0xA21EA2AD, 0xC3B4C399, 0x6C506C44, 0x07040705,
-    0x04F6047F, 0x27C22746, 0xAC16ACA7, 0xD025D076, 0x50865013, 0xDC56DCF7,
-    0x8455841A, 0xE109E151, 0x7ABE7A25, 0x139113EF},
-
-   {0xD939A9D9, 0x90176790, 0x719CB371, 0xD2A6E8D2, 0x05070405, 0x9852FD98,
-    0x6580A365, 0xDFE476DF, 0x08459A08, 0x024B9202, 0xA0E080A0, 0x665A7866,
-    0xDDAFE4DD, 0xB06ADDB0, 0xBF63D1BF, 0x362A3836, 0x54E60D54, 0x4320C643,
-    0x62CC3562, 0xBEF298BE, 0x1E12181E, 0x24EBF724, 0xD7A1ECD7, 0x77416C77,
-    0xBD2843BD, 0x32BC7532, 0xD47B37D4, 0x9B88269B, 0x700DFA70, 0xF94413F9,
-    0xB1FB94B1, 0x5A7E485A, 0x7A03F27A, 0xE48CD0E4, 0x47B68B47, 0x3C24303C,
-    0xA5E784A5, 0x416B5441, 0x06DDDF06, 0xC56023C5, 0x45FD1945, 0xA33A5BA3,
-    0x68C23D68, 0x158D5915, 0x21ECF321, 0x3166AE31, 0x3E6FA23E, 0x16578216,
-    0x95106395, 0x5BEF015B, 0x4DB8834D, 0x91862E91, 0xB56DD9B5, 0x1F83511F,
-    0x53AA9B53, 0x635D7C63, 0x3B68A63B, 0x3FFEEB3F, 0xD630A5D6, 0x257ABE25,
-    0xA7AC16A7, 0x0F090C0F, 0x35F0E335, 0x23A76123, 0xF090C0F0, 0xAFE98CAF,
-    0x809D3A80, 0x925CF592, 0x810C7381, 0x27312C27, 0x76D02576, 0xE7560BE7,
-    0x7B92BB7B, 0xE9CE4EE9, 0xF10189F1, 0x9F1E6B9F, 0xA93453A9, 0xC4F16AC4,
-    0x99C3B499, 0x975BF197, 0x8347E183, 0x6B18E66B, 0xC822BDC8, 0x0E98450E,
-    0x6E1FE26E, 0xC9B3F4C9, 0x2F74B62F, 0xCBF866CB, 0xFF99CCFF, 0xEA1495EA,
-    0xED5803ED, 0xF7DC56F7, 0xE18BD4E1, 0x1B151C1B, 0xADA21EAD, 0x0CD3D70C,
-    0x2BE2FB2B, 0x1DC8C31D, 0x195E8E19, 0xC22CB5C2, 0x8949E989, 0x12C1CF12,
-    0x7E95BF7E, 0x207DBA20, 0x6411EA64, 0x840B7784, 0x6DC5396D, 0x6A89AF6A,
-    0xD17C33D1, 0xA171C9A1, 0xCEFF62CE, 0x37BB7137, 0xFB0F81FB, 0x3DB5793D,
-    0x51E10951, 0xDC3EADDC, 0x2D3F242D, 0xA476CDA4, 0x9D55F99D, 0xEE82D8EE,
-    0x8640E586, 0xAE78C5AE, 0xCD25B9CD, 0x04964D04, 0x55774455, 0x0A0E080A,
-    0x13508613, 0x30F7E730, 0xD337A1D3, 0x40FA1D40, 0x3461AA34, 0x8C4EED8C,
-    0xB3B006B3, 0x6C54706C, 0x2A73B22A, 0x523BD252, 0x0B9F410B, 0x8B027B8B,
-    0x88D8A088, 0x4FF3114F, 0x67CB3167, 0x4627C246, 0xC06727C0, 0xB4FC90B4,
-    0x28382028, 0x7F04F67F, 0x78486078, 0x2EE5FF2E, 0x074C9607, 0x4B655C4B,
-    0xC72BB1C7, 0x6F8EAB6F, 0x0D429E0D, 0xBBF59CBB, 0xF2DB52F2, 0xF34A1BF3,
-    0xA63D5FA6, 0x59A49359, 0xBCB90ABC, 0x3AF9EF3A, 0xEF1391EF, 0xFE0885FE,
-    0x01914901, 0x6116EE61, 0x7CDE2D7C, 0xB2214FB2, 0x42B18F42, 0xDB723BDB,
-    0xB82F47B8, 0x48BF8748, 0x2CAE6D2C, 0xE3C046E3, 0x573CD657, 0x859A3E85,
-    0x29A96929, 0x7D4F647D, 0x94812A94, 0x492ECE49, 0x17C6CB17, 0xCA692FCA,
-    0xC3BDFCC3, 0x5CA3975C, 0x5EE8055E, 0xD0ED7AD0, 0x87D1AC87, 0x8E057F8E,
-    0xBA64D5BA, 0xA8A51AA8, 0xB7264BB7, 0xB9BE0EB9, 0x6087A760, 0xF8D55AF8,
-    0x22362822, 0x111B1411, 0xDE753FDE, 0x79D92979, 0xAAEE88AA, 0x332D3C33,
-    0x5F794C5F, 0xB6B702B6, 0x96CAB896, 0x5835DA58, 0x9CC4B09C, 0xFC4317FC,
-    0x1A84551A, 0xF64D1FF6, 0x1C598A1C, 0x38B27D38, 0xAC3357AC, 0x18CFC718,
-    0xF4068DF4, 0x69537469, 0x749BB774, 0xF597C4F5, 0x56AD9F56, 0xDAE372DA,
-    0xD5EA7ED5, 0x4AF4154A, 0x9E8F229E, 0xA2AB12A2, 0x4E62584E, 0xE85F07E8,
-    0xE51D99E5, 0x39233439, 0xC1F66EC1, 0x446C5044, 0x5D32DE5D, 0x72466872,
-    0x26A06526, 0x93CDBC93, 0x03DADB03, 0xC6BAF8C6, 0xFA9EC8FA, 0x82D6A882,
-    0xCF6E2BCF, 0x50704050, 0xEB85DCEB, 0x750AFE75, 0x8A93328A, 0x8DDFA48D,
-    0x4C29CA4C, 0x141C1014, 0x73D72173, 0xCCB4F0CC, 0x09D4D309, 0x108A5D10,
-    0xE2510FE2, 0x00000000, 0x9A196F9A, 0xE01A9DE0, 0x8F94368F, 0xE6C742E6,
-    0xECC94AEC, 0xFDD25EFD, 0xAB7FC1AB, 0xD8A8E0D8}
-};
-
-/* The exp_to_poly and poly_to_exp tables are used to perform efficient
- * operations in GF(2^8) represented as GF(2)[x]/w(x) where
- * w(x)=x^8+x^6+x^3+x^2+1.  We care about doing that because it's part of the
- * definition of the RS matrix in the key schedule.  Elements of that field
- * are polynomials of degree not greater than 7 and all coefficients 0 or 1,
- * which can be represented naturally by bytes (just substitute x=2).  In 
that
- * form, GF(2^8) addition is the same as bitwise XOR, but GF(2^8)
- * multiplication is inefficient without hardware support.  To multiply
- * faster, I make use of the fact x is a generator for the nonzero elements,
- * so that every element p of GF(2)[x]/w(x) is either 0 or equal to (x)^n for
- * some n in 0..254.  Note that that caret is exponentiation in GF(2^8),
- * *not* polynomial notation.  So if I want to compute pq where p and q are
- * in GF(2^8), I can just say:
- *    1. if p=0 or q=0 then pq=0
- *    2. otherwise, find m and n such that p=x^m and q=x^n
- *    3. pq=(x^m)(x^n)=x^(m+n), so add m and n and find pq
- * The translations in steps 2 and 3 are looked up in the tables
- * poly_to_exp (for step 2) and exp_to_poly (for step 3).  To see this
- * in action, look at the CALC_S macro.  As additional wrinkles, note that
- * one of my operands is always a constant, so the poly_to_exp lookup on it
- * is done in advance; I included the original values in the comments so
- * readers can have some chance of recognizing that this *is* the RS matrix
- * from the Twofish paper.  I've only included the table entries I actually
- * need; I never do a lookup on a variable input of zero and the biggest
- * exponents I'll ever see are 254 (variable) and 237 (constant), so they'll
- * never sum to more than 491.	I'm repeating part of the exp_to_poly table
- * so that I don't have to do mod-255 reduction in the exponent arithmetic.
- * Since I know my constant operands are never zero, I only have to worry
- * about zero values in the variable operand, and I do it with a simple
- * conditional branch.	I know conditionals are expensive, but I couldn't
- * see a non-horrible way of avoiding them, and I did manage to group the
- * statements so that each if covers four group multiplications. */
-
-static const u8 poly_to_exp[255] = {
-   0x00, 0x01, 0x17, 0x02, 0x2E, 0x18, 0x53, 0x03, 0x6A, 0x2F, 0x93, 0x19,
-   0x34, 0x54, 0x45, 0x04, 0x5C, 0x6B, 0xB6, 0x30, 0xA6, 0x94, 0x4B, 0x1A,
-   0x8C, 0x35, 0x81, 0x55, 0xAA, 0x46, 0x0D, 0x05, 0x24, 0x5D, 0x87, 0x6C,
-   0x9B, 0xB7, 0xC1, 0x31, 0x2B, 0xA7, 0xA3, 0x95, 0x98, 0x4C, 0xCA, 0x1B,
-   0xE6, 0x8D, 0x73, 0x36, 0xCD, 0x82, 0x12, 0x56, 0x62, 0xAB, 0xF0, 0x47,
-   0x4F, 0x0E, 0xBD, 0x06, 0xD4, 0x25, 0xD2, 0x5E, 0x27, 0x88, 0x66, 0x6D,
-   0xD6, 0x9C, 0x79, 0xB8, 0x08, 0xC2, 0xDF, 0x32, 0x68, 0x2C, 0xFD, 0xA8,
-   0x8A, 0xA4, 0x5A, 0x96, 0x29, 0x99, 0x22, 0x4D, 0x60, 0xCB, 0xE4, 0x1C,
-   0x7B, 0xE7, 0x3B, 0x8E, 0x9E, 0x74, 0xF4, 0x37, 0xD8, 0xCE, 0xF9, 0x83,
-   0x6F, 0x13, 0xB2, 0x57, 0xE1, 0x63, 0xDC, 0xAC, 0xC4, 0xF1, 0xAF, 0x48,
-   0x0A, 0x50, 0x42, 0x0F, 0xBA, 0xBE, 0xC7, 0x07, 0xDE, 0xD5, 0x78, 0x26,
-   0x65, 0xD3, 0xD1, 0x5F, 0xE3, 0x28, 0x21, 0x89, 0x59, 0x67, 0xFC, 0x6E,
-   0xB1, 0xD7, 0xF8, 0x9D, 0xF3, 0x7A, 0x3A, 0xB9, 0xC6, 0x09, 0x41, 0xC3,
-   0xAE, 0xE0, 0xDB, 0x33, 0x44, 0x69, 0x92, 0x2D, 0x52, 0xFE, 0x16, 0xA9,
-   0x0C, 0x8B, 0x80, 0xA5, 0x4A, 0x5B, 0xB5, 0x97, 0xC9, 0x2A, 0xA2, 0x9A,
-   0xC0, 0x23, 0x86, 0x4E, 0xBC, 0x61, 0xEF, 0xCC, 0x11, 0xE5, 0x72, 0x1D,
-   0x3D, 0x7C, 0xEB, 0xE8, 0xE9, 0x3C, 0xEA, 0x8F, 0x7D, 0x9F, 0xEC, 0x75,
-   0x1E, 0xF5, 0x3E, 0x38, 0xF6, 0xD9, 0x3F, 0xCF, 0x76, 0xFA, 0x1F, 0x84,
-   0xA0, 0x70, 0xED, 0x14, 0x90, 0xB3, 0x7E, 0x58, 0xFB, 0xE2, 0x20, 0x64,
-   0xD0, 0xDD, 0x77, 0xAD, 0xDA, 0xC5, 0x40, 0xF2, 0x39, 0xB0, 0xF7, 0x49,
-   0xB4, 0x0B, 0x7F, 0x51, 0x15, 0x43, 0x91, 0x10, 0x71, 0xBB, 0xEE, 0xBF,
-   0x85, 0xC8, 0xA1
-};
-
-static const u8 exp_to_poly[492] = {
-   0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D, 0x9A, 0x79, 0xF2,
-   0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC, 0xF5, 0xA7, 0x03,
-   0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3, 0x8B, 0x5B, 0xB6,
-   0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52, 0xA4, 0x05, 0x0A,
-   0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0, 0xED, 0x97, 0x63,
-   0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1, 0x0F, 0x1E, 0x3C,
-   0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A, 0xF4, 0xA5, 0x07,
-   0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11, 0x22, 0x44, 0x88,
-   0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51, 0xA2, 0x09, 0x12,
-   0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66, 0xCC, 0xD5, 0xE7,
-   0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB, 0x1B, 0x36, 0x6C,
-   0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19, 0x32, 0x64, 0xC8,
-   0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D, 0x5A, 0xB4, 0x25,
-   0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56, 0xAC, 0x15, 0x2A,
-   0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE, 0x91, 0x6F, 0xDE,
-   0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9, 0x3F, 0x7E, 0xFC,
-   0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE, 0xB1, 0x2F, 0x5E,
-   0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41, 0x82, 0x49, 0x92,
-   0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E, 0x71, 0xE2, 0x89,
-   0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB, 0xDB, 0xFB, 0xBB,
-   0x3B, 0x76, 0xEC, 0x95, 0x67, 0xCE, 0xD1, 0xEF, 0x93, 0x6B, 0xD6, 0xE1,
-   0x8F, 0x53, 0xA6, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D,
-   0x9A, 0x79, 0xF2, 0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC,
-   0xF5, 0xA7, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3,
-   0x8B, 0x5B, 0xB6, 0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52,
-   0xA4, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0,
-   0xED, 0x97, 0x63, 0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1,
-   0x0F, 0x1E, 0x3C, 0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A,
-   0xF4, 0xA5, 0x07, 0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11,
-   0x22, 0x44, 0x88, 0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51,
-   0xA2, 0x09, 0x12, 0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66,
-   0xCC, 0xD5, 0xE7, 0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB,
-   0x1B, 0x36, 0x6C, 0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19,
-   0x32, 0x64, 0xC8, 0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D,
-   0x5A, 0xB4, 0x25, 0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56,
-   0xAC, 0x15, 0x2A, 0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE,
-   0x91, 0x6F, 0xDE, 0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9,
-   0x3F, 0x7E, 0xFC, 0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE,
-   0xB1, 0x2F, 0x5E, 0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41,
-   0x82, 0x49, 0x92, 0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E,
-   0x71, 0xE2, 0x89, 0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB
-};
-
-
-/* The table constants are indices of
- * S-box entries, preprocessed through q0 and q1. */
-static const u8 calc_sb_tbl[512] = {
-    0xA9, 0x75, 0x67, 0xF3, 0xB3, 0xC6, 0xE8, 0xF4,
-    0x04, 0xDB, 0xFD, 0x7B, 0xA3, 0xFB, 0x76, 0xC8,
-    0x9A, 0x4A, 0x92, 0xD3, 0x80, 0xE6, 0x78, 0x6B,
-    0xE4, 0x45, 0xDD, 0x7D, 0xD1, 0xE8, 0x38, 0x4B,
-    0x0D, 0xD6, 0xC6, 0x32, 0x35, 0xD8, 0x98, 0xFD,
-    0x18, 0x37, 0xF7, 0x71, 0xEC, 0xF1, 0x6C, 0xE1,
-    0x43, 0x30, 0x75, 0x0F, 0x37, 0xF8, 0x26, 0x1B,
-    0xFA, 0x87, 0x13, 0xFA, 0x94, 0x06, 0x48, 0x3F,
-    0xF2, 0x5E, 0xD0, 0xBA, 0x8B, 0xAE, 0x30, 0x5B,
-    0x84, 0x8A, 0x54, 0x00, 0xDF, 0xBC, 0x23, 0x9D,
-    0x19, 0x6D, 0x5B, 0xC1, 0x3D, 0xB1, 0x59, 0x0E,
-    0xF3, 0x80, 0xAE, 0x5D, 0xA2, 0xD2, 0x82, 0xD5,
-    0x63, 0xA0, 0x01, 0x84, 0x83, 0x07, 0x2E, 0x14,
-    0xD9, 0xB5, 0x51, 0x90, 0x9B, 0x2C, 0x7C, 0xA3,
-    0xA6, 0xB2, 0xEB, 0x73, 0xA5, 0x4C, 0xBE, 0x54,
-    0x16, 0x92, 0x0C, 0x74, 0xE3, 0x36, 0x61, 0x51,
-    0xC0, 0x38, 0x8C, 0xB0, 0x3A, 0xBD, 0xF5, 0x5A,
-    0x73, 0xFC, 0x2C, 0x60, 0x25, 0x62, 0x0B, 0x96,
-    0xBB, 0x6C, 0x4E, 0x42, 0x89, 0xF7, 0x6B, 0x10,
-    0x53, 0x7C, 0x6A, 0x28, 0xB4, 0x27, 0xF1, 0x8C,
-    0xE1, 0x13, 0xE6, 0x95, 0xBD, 0x9C, 0x45, 0xC7,
-    0xE2, 0x24, 0xF4, 0x46, 0xB6, 0x3B, 0x66, 0x70,
-    0xCC, 0xCA, 0x95, 0xE3, 0x03, 0x85, 0x56, 0xCB,
-    0xD4, 0x11, 0x1C, 0xD0, 0x1E, 0x93, 0xD7, 0xB8,
-    0xFB, 0xA6, 0xC3, 0x83, 0x8E, 0x20, 0xB5, 0xFF,
-    0xE9, 0x9F, 0xCF, 0x77, 0xBF, 0xC3, 0xBA, 0xCC,
-    0xEA, 0x03, 0x77, 0x6F, 0x39, 0x08, 0xAF, 0xBF,
-    0x33, 0x40, 0xC9, 0xE7, 0x62, 0x2B, 0x71, 0xE2,
-    0x81, 0x79, 0x79, 0x0C, 0x09, 0xAA, 0xAD, 0x82,
-    0x24, 0x41, 0xCD, 0x3A, 0xF9, 0xEA, 0xD8, 0xB9,
-    0xE5, 0xE4, 0xC5, 0x9A, 0xB9, 0xA4, 0x4D, 0x97,
-    0x44, 0x7E, 0x08, 0xDA, 0x86, 0x7A, 0xE7, 0x17,
-    0xA1, 0x66, 0x1D, 0x94, 0xAA, 0xA1, 0xED, 0x1D,
-    0x06, 0x3D, 0x70, 0xF0, 0xB2, 0xDE, 0xD2, 0xB3,
-    0x41, 0x0B, 0x7B, 0x72, 0xA0, 0xA7, 0x11, 0x1C,
-    0x31, 0xEF, 0xC2, 0xD1, 0x27, 0x53, 0x90, 0x3E,
-    0x20, 0x8F, 0xF6, 0x33, 0x60, 0x26, 0xFF, 0x5F,
-    0x96, 0xEC, 0x5C, 0x76, 0xB1, 0x2A, 0xAB, 0x49,
-    0x9E, 0x81, 0x9C, 0x88, 0x52, 0xEE, 0x1B, 0x21,
-    0x5F, 0xC4, 0x93, 0x1A, 0x0A, 0xEB, 0xEF, 0xD9,
-    0x91, 0xC5, 0x85, 0x39, 0x49, 0x99, 0xEE, 0xCD,
-    0x2D, 0xAD, 0x4F, 0x31, 0x8F, 0x8B, 0x3B, 0x01,
-    0x47, 0x18, 0x87, 0x23, 0x6D, 0xDD, 0x46, 0x1F,
-    0xD6, 0x4E, 0x3E, 0x2D, 0x69, 0xF9, 0x64, 0x48,
-    0x2A, 0x4F, 0xCE, 0xF2, 0xCB, 0x65, 0x2F, 0x8E,
-    0xFC, 0x78, 0x97, 0x5C, 0x05, 0x58, 0x7A, 0x19,
-    0xAC, 0x8D, 0x7F, 0xE5, 0xD5, 0x98, 0x1A, 0x57,
-    0x4B, 0x67, 0x0E, 0x7F, 0xA7, 0x05, 0x5A, 0x64,
-    0x28, 0xAF, 0x14, 0x63, 0x3F, 0xB6, 0x29, 0xFE,
-    0x88, 0xF5, 0x3C, 0xB7, 0x4C, 0x3C, 0x02, 0xA5,
-    0xB8, 0xCE, 0xDA, 0xE9, 0xB0, 0x68, 0x17, 0x44,
-    0x55, 0xE0, 0x1F, 0x4D, 0x8A, 0x43, 0x7D, 0x69,
-    0x57, 0x29, 0xC7, 0x2E, 0x8D, 0xAC, 0x74, 0x15,
-    0xB7, 0x59, 0xC4, 0xA8, 0x9F, 0x0A, 0x72, 0x9E,
-    0x7E, 0x6E, 0x15, 0x47, 0x22, 0xDF, 0x12, 0x34,
-    0x58, 0x35, 0x07, 0x6A, 0x99, 0xCF, 0x34, 0xDC,
-    0x6E, 0x22, 0x50, 0xC9, 0xDE, 0xC0, 0x68, 0x9B,
-    0x65, 0x89, 0xBC, 0xD4, 0xDB, 0xED, 0xF8, 0xAB,
-    0xC8, 0x12, 0xA8, 0xA2, 0x2B, 0x0D, 0x40, 0x52,
-    0xDC, 0xBB, 0xFE, 0x02, 0x32, 0x2F, 0xA4, 0xA9,
-    0xCA, 0xD7, 0x10, 0x61, 0x21, 0x1E, 0xF0, 0xB4,
-    0xD3, 0x50, 0x5D, 0x04, 0x0F, 0xF6, 0x00, 0xC2,
-    0x6F, 0x16, 0x9D, 0x25, 0x36, 0x86, 0x42, 0x56,
-    0x4A, 0x55, 0x5E, 0x09, 0xC1, 0xBE, 0xE0, 0x91
-};
-
-/* Macro to perform one column of the RS matrix multiplication.  The
- * parameters a, b, c, and d are the four bytes of output; i is the index
- * of the key bytes, and w, x, y, and z, are the column of constants from
- * the RS matrix, preprocessed through the poly_to_exp table. */
-
-#define CALC_S(a, b, c, d, i, w, x, y, z) \
-   if (key[i]) { \
-      tmp = poly_to_exp[key[i] - 1]; \
-      (a) ^= exp_to_poly[tmp + (w)]; \
-      (b) ^= exp_to_poly[tmp + (x)]; \
-      (c) ^= exp_to_poly[tmp + (y)]; \
-      (d) ^= exp_to_poly[tmp + (z)]; \
-   }
-
-/* Macros to calculate the key-dependent S-boxes for a 128-bit key using
- * the S vector from CALC_S.  CALC_SB_2 computes a single entry in all
- * four S-boxes, where i is the index of the entry to compute, and a and b
- * are the index numbers preprocessed through the q0 and q1 tables
- * respectively. */
-
-#define CALC_SB_2(i, a, b) \
-   ctx-&gt;s[0][i] = mds[0][q0[(a) ^ sa] ^ se]; \
-   ctx-&gt;s[1][i] = mds[1][q0[(b) ^ sb] ^ sf]; \
-   ctx-&gt;s[2][i] = mds[2][q1[(a) ^ sc] ^ sg]; \
-   ctx-&gt;s[3][i] = mds[3][q1[(b) ^ sd] ^ sh]
-
-/* Macro exactly like CALC_SB_2, but for 192-bit keys. */
-
-#define CALC_SB192_2(i, a, b) \
-   ctx-&gt;s[0][i] = mds[0][q0[q0[(b) ^ sa] ^ se] ^ si]; \
-   ctx-&gt;s[1][i] = mds[1][q0[q1[(b) ^ sb] ^ sf] ^ sj]; \
-   ctx-&gt;s[2][i] = mds[2][q1[q0[(a) ^ sc] ^ sg] ^ sk]; \
-   ctx-&gt;s[3][i] = mds[3][q1[q1[(a) ^ sd] ^ sh] ^ sl];
-
-/* Macro exactly like CALC_SB_2, but for 256-bit keys. */
-
-#define CALC_SB256_2(i, a, b) \
-   ctx-&gt;s[0][i] = mds[0][q0[q0[q1[(b) ^ sa] ^ se] ^ si] ^ sm]; \
-   ctx-&gt;s[1][i] = mds[1][q0[q1[q1[(a) ^ sb] ^ sf] ^ sj] ^ sn]; \
-   ctx-&gt;s[2][i] = mds[2][q1[q0[q0[(a) ^ sc] ^ sg] ^ sk] ^ so]; \
-   ctx-&gt;s[3][i] = mds[3][q1[q1[q0[(b) ^ sd] ^ sh] ^ sl] ^ sp];
-
-/* Macros to calculate the whitening and round subkeys.  CALC_K_2 computes 
the
- * last two stages of the h() function for a given index (either 2i or 2i+1).
- * a, b, c, and d are the four bytes going into the last two stages.  For
- * 128-bit keys, this is the entire h() function and a and c are the index
- * preprocessed through q0 and q1 respectively; for longer keys they are the
- * output of previous stages.  j is the index of the first key byte to use.
- * CALC_K computes a pair of subkeys for 128-bit Twofish, by calling CALC_K_2
- * twice, doing the Pseudo-Hadamard Transform, and doing the necessary
- * rotations.  Its parameters are: a, the array to write the results into,
- * j, the index of the first output entry, k and l, the preprocessed indices
- * for index 2i, and m and n, the preprocessed indices for index 2i+1.
- * CALC_K192_2 expands CALC_K_2 to handle 192-bit keys, by doing an
- * additional lookup-and-XOR stage.  The parameters a, b, c and d are the
- * four bytes going into the last three stages.  For 192-bit keys, c = d
- * are the index preprocessed through q0, and a = b are the index
- * preprocessed through q1; j is the index of the first key byte to use.
- * CALC_K192 is identical to CALC_K but for using the CALC_K192_2 macro
- * instead of CALC_K_2.
- * CALC_K256_2 expands CALC_K192_2 to handle 256-bit keys, by doing an
- * additional lookup-and-XOR stage.  The parameters a and b are the index
- * preprocessed through q0 and q1 respectively; j is the index of the first
- * key byte to use.  CALC_K256 is identical to CALC_K but for using the
- * CALC_K256_2 macro instead of CALC_K_2. */
-
-#define CALC_K_2(a, b, c, d, j) \
-     mds[0][q0[a ^ key[(j) + 8]] ^ key[j]] \
-   ^ mds[1][q0[b ^ key[(j) + 9]] ^ key[(j) + 1]] \
-   ^ mds[2][q1[c ^ key[(j) + 10]] ^ key[(j) + 2]] \
-   ^ mds[3][q1[d ^ key[(j) + 11]] ^ key[(j) + 3]]
-
-#define CALC_K(a, j, k, l, m, n) \
-   x = CALC_K_2 (k, l, k, l, 0); \
-   y = CALC_K_2 (m, n, m, n, 4); \
-   y = rol32(y, 8); \
-   x += y; y += x; ctx-&gt;a[j] = x; \
-   ctx-&gt;a[(j) + 1] = rol32(y, 9)
-
-#define CALC_K192_2(a, b, c, d, j) \
-   CALC_K_2 (q0[a ^ key[(j) + 16]], \
-	     q1[b ^ key[(j) + 17]], \
-	     q0[c ^ key[(j) + 18]], \
-	     q1[d ^ key[(j) + 19]], j)
-
-#define CALC_K192(a, j, k, l, m, n) \
-   x = CALC_K192_2 (l, l, k, k, 0); \
-   y = CALC_K192_2 (n, n, m, m, 4); \
-   y = rol32(y, 8); \
-   x += y; y += x; ctx-&gt;a[j] = x; \
-   ctx-&gt;a[(j) + 1] = rol32(y, 9)
-
-#define CALC_K256_2(a, b, j) \
-   CALC_K192_2 (q1[b ^ key[(j) + 24]], \
-	        q1[a ^ key[(j) + 25]], \
-	        q0[a ^ key[(j) + 26]], \
-	        q0[b ^ key[(j) + 27]], j)
-
-#define CALC_K256(a, j, k, l, m, n) \
-   x = CALC_K256_2 (k, l, 0); \
-   y = CALC_K256_2 (m, n, 4); \
-   y = rol32(y, 8); \
-   x += y; y += x; ctx-&gt;a[j] = x; \
-   ctx-&gt;a[(j) + 1] = rol32(y, 9)
-
-
-/* Macros to compute the g() function in the encryption and decryption
- * rounds.  G1 is the straight g() function; G2 includes the 8-bit
- * rotation for the high 32-bit word. */
-
-#define G1(a) \
-     (ctx-&gt;s[0][(a) &amp; 0xFF]) ^ (ctx-&gt;s[1][((a) &gt;&gt; 8) &amp; 0xFF]) \
-   ^ (ctx-&gt;s[2][((a) &gt;&gt; 16) &amp; 0xFF]) ^ (ctx-&gt;s[3][(a) &gt;&gt; 24])
-
-#define G2(b) \
-     (ctx-&gt;s[1][(b) &amp; 0xFF]) ^ (ctx-&gt;s[2][((b) &gt;&gt; 8) &amp; 0xFF]) \
-   ^ (ctx-&gt;s[3][((b) &gt;&gt; 16) &amp; 0xFF]) ^ (ctx-&gt;s[0][(b) &gt;&gt; 24])
-
-/* Encryption and decryption Feistel rounds.  Each one calls the two g()
- * macros, does the PHT, and performs the XOR and the appropriate bit
- * rotations.  The parameters are the round number (used to select subkeys),
- * and the four 32-bit chunks of the text. */
-
-#define ENCROUND(n, a, b, c, d) \
-   x = G1 (a); y = G2 (b); \
-   x += y; y += x + ctx-&gt;k[2 * (n) + 1]; \
-   (c) ^= x + ctx-&gt;k[2 * (n)]; \
-   (c) = ror32((c), 1); \
-   (d) = rol32((d), 1) ^ y
-
-#define DECROUND(n, a, b, c, d) \
-   x = G1 (a); y = G2 (b); \
-   x += y; y += x; \
-   (d) ^= y + ctx-&gt;k[2 * (n) + 1]; \
-   (d) = ror32((d), 1); \
-   (c) = rol32((c), 1); \
-   (c) ^= (x + ctx-&gt;k[2 * (n)])
-
-/* Encryption and decryption cycles; each one is simply two Feistel rounds
- * with the 32-bit chunks re-ordered to simulate the "swap" */
-
-#define ENCCYCLE(n) \
-   ENCROUND (2 * (n), a, b, c, d); \
-   ENCROUND (2 * (n) + 1, c, d, a, b)
-
-#define DECCYCLE(n) \
-   DECROUND (2 * (n) + 1, c, d, a, b); \
-   DECROUND (2 * (n), a, b, c, d)
-
-/* Macros to convert the input and output bytes into 32-bit words,
- * and simultaneously perform the whitening step.  INPACK packs word
- * number n into the variable named by x, using whitening subkey number m.
- * OUTUNPACK unpacks word number n from the variable named by x, using
- * whitening subkey number m. */
-
-#define INPACK(n, x, m) \
-   x = le32_to_cpu(src[n]) ^ ctx-&gt;w[m]
-
-#define OUTUNPACK(n, x, m) \
-   x ^= ctx-&gt;w[m]; \
-   dst[n] = cpu_to_le32(x)
-
-#define TF_MIN_KEY_SIZE 16
-#define TF_MAX_KEY_SIZE 32
-#define TF_BLOCK_SIZE 16
-
-/* Structure for an expanded Twofish key.  s contains the key-dependent
- * S-boxes composed with the MDS matrix; w contains the eight "whitening"
- * subkeys, K[0] through K[7].	k holds the remaining, "round" subkeys.  Note
- * that k[i] corresponds to what the Twofish paper calls K[i+8]. */
-struct twofish_ctx {
-   u32 s[4][256], w[8], k[32];
-};
-
-/* Perform the key setup. */
-static int twofish_setkey(void *cx, const u8 *key,
-                          unsigned int key_len, u32 *flags)
-{
-
-	struct twofish_ctx *ctx = cx;
-
-	int i, j, k;
-
-	/* Temporaries for CALC_K. */
-	u32 x, y;
-
-	/* The S vector used to key the S-boxes, split up into individual bytes.
-	 * 128-bit keys use only sa through sh; 256-bit use all of them. */
-	u8 sa = 0, sb = 0, sc = 0, sd = 0, se = 0, sf = 0, sg = 0, sh = 0;
-	u8 si = 0, sj = 0, sk = 0, sl = 0, sm = 0, sn = 0, so = 0, sp = 0;
-
-	/* Temporary for CALC_S. */
-	u8 tmp;
-
-	/* Check key length. */
-	if (key_len != 16 &amp;&amp; key_len != 24 &amp;&amp; key_len != 32)
-	{
-		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
-		return -EINVAL; /* unsupported key length */
-	}
-
-	/* Compute the first two words of the S vector.  The magic numbers are
-	 * the entries of the RS matrix, preprocessed through poly_to_exp. The
-	 * numbers in the comments are the original (polynomial form) matrix
-	 * entries. */
-	CALC_S (sa, sb, sc, sd, 0, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-	CALC_S (sa, sb, sc, sd, 1, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-	CALC_S (sa, sb, sc, sd, 2, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-	CALC_S (sa, sb, sc, sd, 3, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-	CALC_S (sa, sb, sc, sd, 4, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-	CALC_S (sa, sb, sc, sd, 5, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-	CALC_S (sa, sb, sc, sd, 6, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-	CALC_S (sa, sb, sc, sd, 7, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-	CALC_S (se, sf, sg, sh, 8, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-	CALC_S (se, sf, sg, sh, 9, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-	CALC_S (se, sf, sg, sh, 10, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-	CALC_S (se, sf, sg, sh, 11, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-	CALC_S (se, sf, sg, sh, 12, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-	CALC_S (se, sf, sg, sh, 13, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-	CALC_S (se, sf, sg, sh, 14, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-	CALC_S (se, sf, sg, sh, 15, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-
-	if (key_len == 24 || key_len == 32) { /* 192- or 256-bit key */
-		/* Calculate the third word of the S vector */
-		CALC_S (si, sj, sk, sl, 16, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-		CALC_S (si, sj, sk, sl, 17, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-		CALC_S (si, sj, sk, sl, 18, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-		CALC_S (si, sj, sk, sl, 19, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-		CALC_S (si, sj, sk, sl, 20, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-		CALC_S (si, sj, sk, sl, 21, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-		CALC_S (si, sj, sk, sl, 22, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-		CALC_S (si, sj, sk, sl, 23, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-	}
-
-	if (key_len == 32) { /* 256-bit key */
-		/* Calculate the fourth word of the S vector */
-		CALC_S (sm, sn, so, sp, 24, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-		CALC_S (sm, sn, so, sp, 25, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-		CALC_S (sm, sn, so, sp, 26, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-		CALC_S (sm, sn, so, sp, 27, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-		CALC_S (sm, sn, so, sp, 28, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-		CALC_S (sm, sn, so, sp, 29, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-		CALC_S (sm, sn, so, sp, 30, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-		CALC_S (sm, sn, so, sp, 31, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-
-		/* Compute the S-boxes. */
-		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
-			CALC_SB256_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
-		}
-
-		/* Calculate whitening and round subkeys.  The constants are
-		 * indices of subkeys, preprocessed through q0 and q1. */
-		CALC_K256 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
-		CALC_K256 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
-		CALC_K256 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
-		CALC_K256 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
-		CALC_K256 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
-		CALC_K256 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
-		CALC_K256 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
-		CALC_K256 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
-		CALC_K256 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
-		CALC_K256 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
-		CALC_K256 (k, 12, 0x18, 0x37, 0xF7, 0x71);
-		CALC_K256 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
-		CALC_K256 (k, 16, 0x43, 0x30, 0x75, 0x0F);
-		CALC_K256 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
-		CALC_K256 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
-		CALC_K256 (k, 22, 0x94, 0x06, 0x48, 0x3F);
-		CALC_K256 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
-		CALC_K256 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
-		CALC_K256 (k, 28, 0x84, 0x8A, 0x54, 0x00);
-		CALC_K256 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
-	} else if (key_len == 24) { /* 192-bit key */
-		/* Compute the S-boxes. */
-		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
-		        CALC_SB192_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
-		}
-
-		/* Calculate whitening and round subkeys.  The constants are
-		 * indices of subkeys, preprocessed through q0 and q1. */
-		CALC_K192 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
-		CALC_K192 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
-		CALC_K192 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
-		CALC_K192 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
-		CALC_K192 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
-		CALC_K192 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
-		CALC_K192 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
-		CALC_K192 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
-		CALC_K192 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
-		CALC_K192 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
-		CALC_K192 (k, 12, 0x18, 0x37, 0xF7, 0x71);
-		CALC_K192 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
-		CALC_K192 (k, 16, 0x43, 0x30, 0x75, 0x0F);
-		CALC_K192 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
-		CALC_K192 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
-		CALC_K192 (k, 22, 0x94, 0x06, 0x48, 0x3F);
-		CALC_K192 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
-		CALC_K192 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
-		CALC_K192 (k, 28, 0x84, 0x8A, 0x54, 0x00);
-		CALC_K192 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
-	} else { /* 128-bit key */
-		/* Compute the S-boxes. */
-		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
-			CALC_SB_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
-		}
-
-		/* Calculate whitening and round subkeys.  The constants are
-		 * indices of subkeys, preprocessed through q0 and q1. */
-		CALC_K (w, 0, 0xA9, 0x75, 0x67, 0xF3);
-		CALC_K (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
-		CALC_K (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
-		CALC_K (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
-		CALC_K (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
-		CALC_K (k, 2, 0x80, 0xE6, 0x78, 0x6B);
-		CALC_K (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
-		CALC_K (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
-		CALC_K (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
-		CALC_K (k, 10, 0x35, 0xD8, 0x98, 0xFD);
-		CALC_K (k, 12, 0x18, 0x37, 0xF7, 0x71);
-		CALC_K (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
-		CALC_K (k, 16, 0x43, 0x30, 0x75, 0x0F);
-		CALC_K (k, 18, 0x37, 0xF8, 0x26, 0x1B);
-		CALC_K (k, 20, 0xFA, 0x87, 0x13, 0xFA);
-		CALC_K (k, 22, 0x94, 0x06, 0x48, 0x3F);
-		CALC_K (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
-		CALC_K (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
-		CALC_K (k, 28, 0x84, 0x8A, 0x54, 0x00);
-		CALC_K (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
-	}
-
-	return 0;
-}
-
-/* Encrypt one block.  in and out may be the same. */
-static void twofish_encrypt(void *cx, u8 *out, const u8 *in)
-{
-	struct twofish_ctx *ctx = cx;
-	const __le32 *src = (const __le32 *)in;
-	__le32 *dst = (__le32 *)out;
-
-	/* The four 32-bit chunks of the text. */
-	u32 a, b, c, d;
-
-	/* Temporaries used by the round function. */
-	u32 x, y;
-
-	/* Input whitening and packing. */
-	INPACK (0, a, 0);
-	INPACK (1, b, 1);
-	INPACK (2, c, 2);
-	INPACK (3, d, 3);
-
-	/* Encryption Feistel cycles. */
-	ENCCYCLE (0);
-	ENCCYCLE (1);
-	ENCCYCLE (2);
-	ENCCYCLE (3);
-	ENCCYCLE (4);
-	ENCCYCLE (5);
-	ENCCYCLE (6);
-	ENCCYCLE (7);
-
-	/* Output whitening and unpacking. */
-	OUTUNPACK (0, c, 4);
-	OUTUNPACK (1, d, 5);
-	OUTUNPACK (2, a, 6);
-	OUTUNPACK (3, b, 7);
-
-}
-
-/* Decrypt one block.  in and out may be the same. */
-static void twofish_decrypt(void *cx, u8 *out, const u8 *in)
-{
-	struct twofish_ctx *ctx = cx;
-	const __le32 *src = (const __le32 *)in;
-	__le32 *dst = (__le32 *)out;
-
-	/* The four 32-bit chunks of the text. */
-	u32 a, b, c, d;
-
-	/* Temporaries used by the round function. */
-	u32 x, y;
-
-	/* Input whitening and packing. */
-	INPACK (0, c, 4);
-	INPACK (1, d, 5);
-	INPACK (2, a, 6);
-	INPACK (3, b, 7);
-
-	/* Encryption Feistel cycles. */
-	DECCYCLE (7);
-	DECCYCLE (6);
-	DECCYCLE (5);
-	DECCYCLE (4);
-	DECCYCLE (3);
-	DECCYCLE (2);
-	DECCYCLE (1);
-	DECCYCLE (0);
-
-	/* Output whitening and unpacking. */
-	OUTUNPACK (0, a, 0);
-	OUTUNPACK (1, b, 1);
-	OUTUNPACK (2, c, 2);
-	OUTUNPACK (3, d, 3);
-
-}
-
-static struct crypto_alg alg = {
-	.cra_name           =   "twofish",
-	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
-	.cra_blocksize      =   TF_BLOCK_SIZE,
-	.cra_ctxsize        =   sizeof(struct twofish_ctx),
-	.cra_alignmask      =	3,
-	.cra_module         =   THIS_MODULE,
-	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
-	.cra_u              =   { .cipher = {
-	.cia_min_keysize    =   TF_MIN_KEY_SIZE,
-	.cia_max_keysize    =   TF_MAX_KEY_SIZE,
-	.cia_setkey         =   twofish_setkey,
-	.cia_encrypt        =   twofish_encrypt,
-	.cia_decrypt        =   twofish_decrypt } }
-};
-
-static int __init init(void)
-{
-	return crypto_register_alg(&amp;alg);
-}
-
-static void __exit fini(void)
-{
-	crypto_unregister_alg(&amp;alg);
-}
-
-module_init(init);
-module_exit(fini);
-
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION ("Twofish Cipher Algorithm");
diff -uprN linux-2.6.17-rc5/crypto/twofish_c.c 
linux-2.6.17-rc5.twofish/crypto/twofish_c.c
--- linux-2.6.17-rc5/crypto/twofish_c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish/crypto/twofish_c.c	2006-05-30 15:38:14.627954845 
+0200
@@ -0,0 +1,213 @@
+/*
+ * Twofish for CryptoAPI
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+
+/* Macros to compute the g() function in the encryption and decryption
+ * rounds.  G1 is the straight g() function; G2 includes the 8-bit
+ * rotation for the high 32-bit word. */
+
+#define G1(a) \
+     (ctx-&gt;s[0][(a) &amp; 0xFF]) ^ (ctx-&gt;s[1][((a) &gt;&gt; 8) &amp; 0xFF]) \
+   ^ (ctx-&gt;s[2][((a) &gt;&gt; 16) &amp; 0xFF]) ^ (ctx-&gt;s[3][(a) &gt;&gt; 24])
+
+#define G2(b) \
+     (ctx-&gt;s[1][(b) &amp; 0xFF]) ^ (ctx-&gt;s[2][((b) &gt;&gt; 8) &amp; 0xFF]) \
+   ^ (ctx-&gt;s[3][((b) &gt;&gt; 16) &amp; 0xFF]) ^ (ctx-&gt;s[0][(b) &gt;&gt; 24])
+
+/* Encryption and decryption Feistel rounds.  Each one calls the two g()
+ * macros, does the PHT, and performs the XOR and the appropriate bit
+ * rotations.  The parameters are the round number (used to select subkeys),
+ * and the four 32-bit chunks of the text. */
+
+#define ENCROUND(n, a, b, c, d) \
+   x = G1 (a); y = G2 (b); \
+   x += y; y += x + ctx-&gt;k[2 * (n) + 1]; \
+   (c) ^= x + ctx-&gt;k[2 * (n)]; \
+   (c) = ror32((c), 1); \
+   (d) = rol32((d), 1) ^ y
+
+#define DECROUND(n, a, b, c, d) \
+   x = G1 (a); y = G2 (b); \
+   x += y; y += x; \
+   (d) ^= y + ctx-&gt;k[2 * (n) + 1]; \
+   (d) = ror32((d), 1); \
+   (c) = rol32((c), 1); \
+   (c) ^= (x + ctx-&gt;k[2 * (n)])
+
+/* Encryption and decryption cycles; each one is simply two Feistel rounds
+ * with the 32-bit chunks re-ordered to simulate the "swap" */
+
+#define ENCCYCLE(n) \
+   ENCROUND (2 * (n), a, b, c, d); \
+   ENCROUND (2 * (n) + 1, c, d, a, b)
+
+#define DECCYCLE(n) \
+   DECROUND (2 * (n) + 1, c, d, a, b); \
+   DECROUND (2 * (n), a, b, c, d)
+
+/* Macros to convert the input and output bytes into 32-bit words,
+ * and simultaneously perform the whitening step.  INPACK packs word
+ * number n into the variable named by x, using whitening subkey number m.
+ * OUTUNPACK unpacks word number n from the variable named by x, using
+ * whitening subkey number m. */
+
+#define INPACK(n, x, m) \
+   x = le32_to_cpu(src[n]) ^ ctx-&gt;w[m]
+
+#define OUTUNPACK(n, x, m) \
+   x ^= ctx-&gt;w[m]; \
+   dst[n] = cpu_to_le32(x)
+
+
+/* Encrypt one block.  in and out may be the same. */
+static void twofish_encrypt(void *cx, u8 *out, const u8 *in)
+{
+	struct twofish_ctx *ctx = cx;
+	const __le32 *src = (const __le32 *)in;
+	__le32 *dst = (__le32 *)out;
+
+	/* The four 32-bit chunks of the text. */
+	u32 a, b, c, d;
+
+	/* Temporaries used by the round function. */
+	u32 x, y;
+
+	/* Input whitening and packing. */
+	INPACK (0, a, 0);
+	INPACK (1, b, 1);
+	INPACK (2, c, 2);
+	INPACK (3, d, 3);
+
+	/* Encryption Feistel cycles. */
+	ENCCYCLE (0);
+	ENCCYCLE (1);
+	ENCCYCLE (2);
+	ENCCYCLE (3);
+	ENCCYCLE (4);
+	ENCCYCLE (5);
+	ENCCYCLE (6);
+	ENCCYCLE (7);
+
+	/* Output whitening and unpacking. */
+	OUTUNPACK (0, c, 4);
+	OUTUNPACK (1, d, 5);
+	OUTUNPACK (2, a, 6);
+	OUTUNPACK (3, b, 7);
+
+}
+
+/* Decrypt one block.  in and out may be the same. */
+static void twofish_decrypt(void *cx, u8 *out, const u8 *in)
+{
+	struct twofish_ctx *ctx = cx;
+	const __le32 *src = (const __le32 *)in;
+	__le32 *dst = (__le32 *)out;
+
+	/* The four 32-bit chunks of the text. */
+	u32 a, b, c, d;
+
+	/* Temporaries used by the round function. */
+	u32 x, y;
+
+	/* Input whitening and packing. */
+	INPACK (0, c, 4);
+	INPACK (1, d, 5);
+	INPACK (2, a, 6);
+	INPACK (3, b, 7);
+
+	/* Encryption Feistel cycles. */
+	DECCYCLE (7);
+	DECCYCLE (6);
+	DECCYCLE (5);
+	DECCYCLE (4);
+	DECCYCLE (3);
+	DECCYCLE (2);
+	DECCYCLE (1);
+	DECCYCLE (0);
+
+	/* Output whitening and unpacking. */
+	OUTUNPACK (0, a, 0);
+	OUTUNPACK (1, b, 1);
+	OUTUNPACK (2, c, 2);
+	OUTUNPACK (3, d, 3);
+
+}
+
+
+static struct crypto_alg alg = {
+	.cra_name           =   "twofish",
+	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize      =   TF_BLOCK_SIZE,
+	.cra_ctxsize        =   sizeof(struct twofish_ctx),
+	.cra_alignmask      =	3,
+	.cra_module         =   THIS_MODULE,
+	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
+	.cra_u              =   { .cipher = {
+	.cia_min_keysize    =   TF_MIN_KEY_SIZE,
+	.cia_max_keysize    =   TF_MAX_KEY_SIZE,
+	.cia_setkey         =   twofish_setkey,
+	.cia_encrypt        =   twofish_encrypt,
+	.cia_decrypt        =   twofish_decrypt } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION ("Twofish Cipher Algorithm");
diff -uprN linux-2.6.17-rc5/crypto/twofish_common.c 
linux-2.6.17-rc5.twofish/crypto/twofish_common.c
--- linux-2.6.17-rc5/crypto/twofish_common.c	1970-01-01 01:00:00.000000000 
+0100
+++ linux-2.6.17-rc5.twofish/crypto/twofish_common.c	2006-05-30 
15:33:54.099800857 +0200
@@ -0,0 +1,740 @@
+/*
+ * Common Twofish algorithm parts shared between the c and assembler
+ * implementations
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+
+/* The large precomputed tables for the Twofish cipher (twofish.c)
+ * Taken from the same source as twofish.c
+ * Marc Mutz &lt;Marc@Mutz.com&gt;
+ */
+
+/* These two tables are the q0 and q1 permutations, exactly as described in
+ * the Twofish paper. */
+
+static const u8 q0[256] = {
+   0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78,
+   0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C,
+   0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30,
+   0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82,
+   0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE,
+   0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B,
+   0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45,
+   0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7,
+   0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF,
+   0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8,
+   0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED,
+   0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90,
+   0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B,
+   0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B,
+   0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F,
+   0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A,
+   0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17,
+   0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72,
+   0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68,
+   0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4,
+   0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42,
+   0x4A, 0x5E, 0xC1, 0xE0
+};
+
+static const u8 q1[256] = {
+   0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B,
+   0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1,
+   0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B,
+   0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5,
+   0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54,
+   0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96,
+   0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7,
+   0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8,
+   0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF,
+   0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9,
+   0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D,
+   0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E,
+   0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21,
+   0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01,
+   0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E,
+   0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64,
+   0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44,
+   0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E,
+   0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B,
+   0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9,
+   0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56,
+   0x55, 0x09, 0xBE, 0x91
+};
+
+/* These MDS tables are actually tables of MDS composed with q0 and q1,
+ * because it is only ever used that way and we can save some time by
+ * precomputing.  Of course the main saving comes from precomputing the
+ * GF(2^8) multiplication involved in the MDS matrix multiply; by looking
+ * things up in these tables we reduce the matrix multiply to four lookups
+ * and three XORs.  Semi-formally, the definition of these tables is:
+ * mds[0][i] = MDS (q1[i] 0 0 0)^T  mds[1][i] = MDS (0 q0[i] 0 0)^T
+ * mds[2][i] = MDS (0 0 q1[i] 0)^T  mds[3][i] = MDS (0 0 0 q0[i])^T
+ * where ^T means "transpose", the matrix multiply is performed in GF(2^8)
+ * represented as GF(2)[x]/v(x) where v(x)=x^8+x^6+x^5+x^3+1 as described
+ * by Schneier et al, and I'm casually glossing over the byte/word
+ * conversion issues. */
+
+static const u32 mds[4][256] = {
+   {0xBCBC3275, 0xECEC21F3, 0x202043C6, 0xB3B3C9F4, 0xDADA03DB, 0x02028B7B,
+    0xE2E22BFB, 0x9E9EFAC8, 0xC9C9EC4A, 0xD4D409D3, 0x18186BE6, 0x1E1E9F6B,
+    0x98980E45, 0xB2B2387D, 0xA6A6D2E8, 0x2626B74B, 0x3C3C57D6, 0x93938A32,
+    0x8282EED8, 0x525298FD, 0x7B7BD437, 0xBBBB3771, 0x5B5B97F1, 0x474783E1,
+    0x24243C30, 0x5151E20F, 0xBABAC6F8, 0x4A4AF31B, 0xBFBF4887, 0x0D0D70FA,
+    0xB0B0B306, 0x7575DE3F, 0xD2D2FD5E, 0x7D7D20BA, 0x666631AE, 0x3A3AA35B,
+    0x59591C8A, 0x00000000, 0xCDCD93BC, 0x1A1AE09D, 0xAEAE2C6D, 0x7F7FABC1,
+    0x2B2BC7B1, 0xBEBEB90E, 0xE0E0A080, 0x8A8A105D, 0x3B3B52D2, 0x6464BAD5,
+    0xD8D888A0, 0xE7E7A584, 0x5F5FE807, 0x1B1B1114, 0x2C2CC2B5, 0xFCFCB490,
+    0x3131272C, 0x808065A3, 0x73732AB2, 0x0C0C8173, 0x79795F4C, 0x6B6B4154,
+    0x4B4B0292, 0x53536974, 0x94948F36, 0x83831F51, 0x2A2A3638, 0xC4C49CB0,
+    0x2222C8BD, 0xD5D5F85A, 0xBDBDC3FC, 0x48487860, 0xFFFFCE62, 0x4C4C0796,
+    0x4141776C, 0xC7C7E642, 0xEBEB24F7, 0x1C1C1410, 0x5D5D637C, 0x36362228,
+    0x6767C027, 0xE9E9AF8C, 0x4444F913, 0x1414EA95, 0xF5F5BB9C, 0xCFCF18C7,
+    0x3F3F2D24, 0xC0C0E346, 0x7272DB3B, 0x54546C70, 0x29294CCA, 0xF0F035E3,
+    0x0808FE85, 0xC6C617CB, 0xF3F34F11, 0x8C8CE4D0, 0xA4A45993, 0xCACA96B8,
+    0x68683BA6, 0xB8B84D83, 0x38382820, 0xE5E52EFF, 0xADAD569F, 0x0B0B8477,
+    0xC8C81DC3, 0x9999FFCC, 0x5858ED03, 0x19199A6F, 0x0E0E0A08, 0x95957EBF,
+    0x70705040, 0xF7F730E7, 0x6E6ECF2B, 0x1F1F6EE2, 0xB5B53D79, 0x09090F0C,
+    0x616134AA, 0x57571682, 0x9F9F0B41, 0x9D9D803A, 0x111164EA, 0x2525CDB9,
+    0xAFAFDDE4, 0x4545089A, 0xDFDF8DA4, 0xA3A35C97, 0xEAEAD57E, 0x353558DA,
+    0xEDEDD07A, 0x4343FC17, 0xF8F8CB66, 0xFBFBB194, 0x3737D3A1, 0xFAFA401D,
+    0xC2C2683D, 0xB4B4CCF0, 0x32325DDE, 0x9C9C71B3, 0x5656E70B, 0xE3E3DA72,
+    0x878760A7, 0x15151B1C, 0xF9F93AEF, 0x6363BFD1, 0x3434A953, 0x9A9A853E,
+    0xB1B1428F, 0x7C7CD133, 0x88889B26, 0x3D3DA65F, 0xA1A1D7EC, 0xE4E4DF76,
+    0x8181942A, 0x91910149, 0x0F0FFB81, 0xEEEEAA88, 0x161661EE, 0xD7D77321,
+    0x9797F5C4, 0xA5A5A81A, 0xFEFE3FEB, 0x6D6DB5D9, 0x7878AEC5, 0xC5C56D39,
+    0x1D1DE599, 0x7676A4CD, 0x3E3EDCAD, 0xCBCB6731, 0xB6B6478B, 0xEFEF5B01,
+    0x12121E18, 0x6060C523, 0x6A6AB0DD, 0x4D4DF61F, 0xCECEE94E, 0xDEDE7C2D,
+    0x55559DF9, 0x7E7E5A48, 0x2121B24F, 0x03037AF2, 0xA0A02665, 0x5E5E198E,
+    0x5A5A6678, 0x65654B5C, 0x62624E58, 0xFDFD4519, 0x0606F48D, 0x404086E5,
+    0xF2F2BE98, 0x3333AC57, 0x17179067, 0x05058E7F, 0xE8E85E05, 0x4F4F7D64,
+    0x89896AAF, 0x10109563, 0x74742FB6, 0x0A0A75FE, 0x5C5C92F5, 0x9B9B74B7,
+    0x2D2D333C, 0x3030D6A5, 0x2E2E49CE, 0x494989E9, 0x46467268, 0x77775544,
+    0xA8A8D8E0, 0x9696044D, 0x2828BD43, 0xA9A92969, 0xD9D97929, 0x8686912E,
+    0xD1D187AC, 0xF4F44A15, 0x8D8D1559, 0xD6D682A8, 0xB9B9BC0A, 0x42420D9E,
+    0xF6F6C16E, 0x2F2FB847, 0xDDDD06DF, 0x23233934, 0xCCCC6235, 0xF1F1C46A,
+    0xC1C112CF, 0x8585EBDC, 0x8F8F9E22, 0x7171A1C9, 0x9090F0C0, 0xAAAA539B,
+    0x0101F189, 0x8B8BE1D4, 0x4E4E8CED, 0x8E8E6FAB, 0xABABA212, 0x6F6F3EA2,
+    0xE6E6540D, 0xDBDBF252, 0x92927BBB, 0xB7B7B602, 0x6969CA2F, 0x3939D9A9,
+    0xD3D30CD7, 0xA7A72361, 0xA2A2AD1E, 0xC3C399B4, 0x6C6C4450, 0x07070504,
+    0x04047FF6, 0x272746C2, 0xACACA716, 0xD0D07625, 0x50501386, 0xDCDCF756,
+    0x84841A55, 0xE1E15109, 0x7A7A25BE, 0x1313EF91},
+
+   {0xA9D93939, 0x67901717, 0xB3719C9C, 0xE8D2A6A6, 0x04050707, 0xFD985252,
+    0xA3658080, 0x76DFE4E4, 0x9A084545, 0x92024B4B, 0x80A0E0E0, 0x78665A5A,
+    0xE4DDAFAF, 0xDDB06A6A, 0xD1BF6363, 0x38362A2A, 0x0D54E6E6, 0xC6432020,
+    0x3562CCCC, 0x98BEF2F2, 0x181E1212, 0xF724EBEB, 0xECD7A1A1, 0x6C774141,
+    0x43BD2828, 0x7532BCBC, 0x37D47B7B, 0x269B8888, 0xFA700D0D, 0x13F94444,
+    0x94B1FBFB, 0x485A7E7E, 0xF27A0303, 0xD0E48C8C, 0x8B47B6B6, 0x303C2424,
+    0x84A5E7E7, 0x54416B6B, 0xDF06DDDD, 0x23C56060, 0x1945FDFD, 0x5BA33A3A,
+    0x3D68C2C2, 0x59158D8D, 0xF321ECEC, 0xAE316666, 0xA23E6F6F, 0x82165757,
+    0x63951010, 0x015BEFEF, 0x834DB8B8, 0x2E918686, 0xD9B56D6D, 0x511F8383,
+    0x9B53AAAA, 0x7C635D5D, 0xA63B6868, 0xEB3FFEFE, 0xA5D63030, 0xBE257A7A,
+    0x16A7ACAC, 0x0C0F0909, 0xE335F0F0, 0x6123A7A7, 0xC0F09090, 0x8CAFE9E9,
+    0x3A809D9D, 0xF5925C5C, 0x73810C0C, 0x2C273131, 0x2576D0D0, 0x0BE75656,
+    0xBB7B9292, 0x4EE9CECE, 0x89F10101, 0x6B9F1E1E, 0x53A93434, 0x6AC4F1F1,
+    0xB499C3C3, 0xF1975B5B, 0xE1834747, 0xE66B1818, 0xBDC82222, 0x450E9898,
+    0xE26E1F1F, 0xF4C9B3B3, 0xB62F7474, 0x66CBF8F8, 0xCCFF9999, 0x95EA1414,
+    0x03ED5858, 0x56F7DCDC, 0xD4E18B8B, 0x1C1B1515, 0x1EADA2A2, 0xD70CD3D3,
+    0xFB2BE2E2, 0xC31DC8C8, 0x8E195E5E, 0xB5C22C2C, 0xE9894949, 0xCF12C1C1,
+    0xBF7E9595, 0xBA207D7D, 0xEA641111, 0x77840B0B, 0x396DC5C5, 0xAF6A8989,
+    0x33D17C7C, 0xC9A17171, 0x62CEFFFF, 0x7137BBBB, 0x81FB0F0F, 0x793DB5B5,
+    0x0951E1E1, 0xADDC3E3E, 0x242D3F3F, 0xCDA47676, 0xF99D5555, 0xD8EE8282,
+    0xE5864040, 0xC5AE7878, 0xB9CD2525, 0x4D049696, 0x44557777, 0x080A0E0E,
+    0x86135050, 0xE730F7F7, 0xA1D33737, 0x1D40FAFA, 0xAA346161, 0xED8C4E4E,
+    0x06B3B0B0, 0x706C5454, 0xB22A7373, 0xD2523B3B, 0x410B9F9F, 0x7B8B0202,
+    0xA088D8D8, 0x114FF3F3, 0x3167CBCB, 0xC2462727, 0x27C06767, 0x90B4FCFC,
+    0x20283838, 0xF67F0404, 0x60784848, 0xFF2EE5E5, 0x96074C4C, 0x5C4B6565,
+    0xB1C72B2B, 0xAB6F8E8E, 0x9E0D4242, 0x9CBBF5F5, 0x52F2DBDB, 0x1BF34A4A,
+    0x5FA63D3D, 0x9359A4A4, 0x0ABCB9B9, 0xEF3AF9F9, 0x91EF1313, 0x85FE0808,
+    0x49019191, 0xEE611616, 0x2D7CDEDE, 0x4FB22121, 0x8F42B1B1, 0x3BDB7272,
+    0x47B82F2F, 0x8748BFBF, 0x6D2CAEAE, 0x46E3C0C0, 0xD6573C3C, 0x3E859A9A,
+    0x6929A9A9, 0x647D4F4F, 0x2A948181, 0xCE492E2E, 0xCB17C6C6, 0x2FCA6969,
+    0xFCC3BDBD, 0x975CA3A3, 0x055EE8E8, 0x7AD0EDED, 0xAC87D1D1, 0x7F8E0505,
+    0xD5BA6464, 0x1AA8A5A5, 0x4BB72626, 0x0EB9BEBE, 0xA7608787, 0x5AF8D5D5,
+    0x28223636, 0x14111B1B, 0x3FDE7575, 0x2979D9D9, 0x88AAEEEE, 0x3C332D2D,
+    0x4C5F7979, 0x02B6B7B7, 0xB896CACA, 0xDA583535, 0xB09CC4C4, 0x17FC4343,
+    0x551A8484, 0x1FF64D4D, 0x8A1C5959, 0x7D38B2B2, 0x57AC3333, 0xC718CFCF,
+    0x8DF40606, 0x74695353, 0xB7749B9B, 0xC4F59797, 0x9F56ADAD, 0x72DAE3E3,
+    0x7ED5EAEA, 0x154AF4F4, 0x229E8F8F, 0x12A2ABAB, 0x584E6262, 0x07E85F5F,
+    0x99E51D1D, 0x34392323, 0x6EC1F6F6, 0x50446C6C, 0xDE5D3232, 0x68724646,
+    0x6526A0A0, 0xBC93CDCD, 0xDB03DADA, 0xF8C6BABA, 0xC8FA9E9E, 0xA882D6D6,
+    0x2BCF6E6E, 0x40507070, 0xDCEB8585, 0xFE750A0A, 0x328A9393, 0xA48DDFDF,
+    0xCA4C2929, 0x10141C1C, 0x2173D7D7, 0xF0CCB4B4, 0xD309D4D4, 0x5D108A8A,
+    0x0FE25151, 0x00000000, 0x6F9A1919, 0x9DE01A1A, 0x368F9494, 0x42E6C7C7,
+    0x4AECC9C9, 0x5EFDD2D2, 0xC1AB7F7F, 0xE0D8A8A8},
+
+   {0xBC75BC32, 0xECF3EC21, 0x20C62043, 0xB3F4B3C9, 0xDADBDA03, 0x027B028B,
+    0xE2FBE22B, 0x9EC89EFA, 0xC94AC9EC, 0xD4D3D409, 0x18E6186B, 0x1E6B1E9F,
+    0x9845980E, 0xB27DB238, 0xA6E8A6D2, 0x264B26B7, 0x3CD63C57, 0x9332938A,
+    0x82D882EE, 0x52FD5298, 0x7B377BD4, 0xBB71BB37, 0x5BF15B97, 0x47E14783,
+    0x2430243C, 0x510F51E2, 0xBAF8BAC6, 0x4A1B4AF3, 0xBF87BF48, 0x0DFA0D70,
+    0xB006B0B3, 0x753F75DE, 0xD25ED2FD, 0x7DBA7D20, 0x66AE6631, 0x3A5B3AA3,
+    0x598A591C, 0x00000000, 0xCDBCCD93, 0x1A9D1AE0, 0xAE6DAE2C, 0x7FC17FAB,
+    0x2BB12BC7, 0xBE0EBEB9, 0xE080E0A0, 0x8A5D8A10, 0x3BD23B52, 0x64D564BA,
+    0xD8A0D888, 0xE784E7A5, 0x5F075FE8, 0x1B141B11, 0x2CB52CC2, 0xFC90FCB4,
+    0x312C3127, 0x80A38065, 0x73B2732A, 0x0C730C81, 0x794C795F, 0x6B546B41,
+    0x4B924B02, 0x53745369, 0x9436948F, 0x8351831F, 0x2A382A36, 0xC4B0C49C,
+    0x22BD22C8, 0xD55AD5F8, 0xBDFCBDC3, 0x48604878, 0xFF62FFCE, 0x4C964C07,
+    0x416C4177, 0xC742C7E6, 0xEBF7EB24, 0x1C101C14, 0x5D7C5D63, 0x36283622,
+    0x672767C0, 0xE98CE9AF, 0x441344F9, 0x149514EA, 0xF59CF5BB, 0xCFC7CF18,
+    0x3F243F2D, 0xC046C0E3, 0x723B72DB, 0x5470546C, 0x29CA294C, 0xF0E3F035,
+    0x088508FE, 0xC6CBC617, 0xF311F34F, 0x8CD08CE4, 0xA493A459, 0xCAB8CA96,
+    0x68A6683B, 0xB883B84D, 0x38203828, 0xE5FFE52E, 0xAD9FAD56, 0x0B770B84,
+    0xC8C3C81D, 0x99CC99FF, 0x580358ED, 0x196F199A, 0x0E080E0A, 0x95BF957E,
+    0x70407050, 0xF7E7F730, 0x6E2B6ECF, 0x1FE21F6E, 0xB579B53D, 0x090C090F,
+    0x61AA6134, 0x57825716, 0x9F419F0B, 0x9D3A9D80, 0x11EA1164, 0x25B925CD,
+    0xAFE4AFDD, 0x459A4508, 0xDFA4DF8D, 0xA397A35C, 0xEA7EEAD5, 0x35DA3558,
+    0xED7AEDD0, 0x431743FC, 0xF866F8CB, 0xFB94FBB1, 0x37A137D3, 0xFA1DFA40,
+    0xC23DC268, 0xB4F0B4CC, 0x32DE325D, 0x9CB39C71, 0x560B56E7, 0xE372E3DA,
+    0x87A78760, 0x151C151B, 0xF9EFF93A, 0x63D163BF, 0x345334A9, 0x9A3E9A85,
+    0xB18FB142, 0x7C337CD1, 0x8826889B, 0x3D5F3DA6, 0xA1ECA1D7, 0xE476E4DF,
+    0x812A8194, 0x91499101, 0x0F810FFB, 0xEE88EEAA, 0x16EE1661, 0xD721D773,
+    0x97C497F5, 0xA51AA5A8, 0xFEEBFE3F, 0x6DD96DB5, 0x78C578AE, 0xC539C56D,
+    0x1D991DE5, 0x76CD76A4, 0x3EAD3EDC, 0xCB31CB67, 0xB68BB647, 0xEF01EF5B,
+    0x1218121E, 0x602360C5, 0x6ADD6AB0, 0x4D1F4DF6, 0xCE4ECEE9, 0xDE2DDE7C,
+    0x55F9559D, 0x7E487E5A, 0x214F21B2, 0x03F2037A, 0xA065A026, 0x5E8E5E19,
+    0x5A785A66, 0x655C654B, 0x6258624E, 0xFD19FD45, 0x068D06F4, 0x40E54086,
+    0xF298F2BE, 0x335733AC, 0x17671790, 0x057F058E, 0xE805E85E, 0x4F644F7D,
+    0x89AF896A, 0x10631095, 0x74B6742F, 0x0AFE0A75, 0x5CF55C92, 0x9BB79B74,
+    0x2D3C2D33, 0x30A530D6, 0x2ECE2E49, 0x49E94989, 0x46684672, 0x77447755,
+    0xA8E0A8D8, 0x964D9604, 0x284328BD, 0xA969A929, 0xD929D979, 0x862E8691,
+    0xD1ACD187, 0xF415F44A, 0x8D598D15, 0xD6A8D682, 0xB90AB9BC, 0x429E420D,
+    0xF66EF6C1, 0x2F472FB8, 0xDDDFDD06, 0x23342339, 0xCC35CC62, 0xF16AF1C4,
+    0xC1CFC112, 0x85DC85EB, 0x8F228F9E, 0x71C971A1, 0x90C090F0, 0xAA9BAA53,
+    0x018901F1, 0x8BD48BE1, 0x4EED4E8C, 0x8EAB8E6F, 0xAB12ABA2, 0x6FA26F3E,
+    0xE60DE654, 0xDB52DBF2, 0x92BB927B, 0xB702B7B6, 0x692F69CA, 0x39A939D9,
+    0xD3D7D30C, 0xA761A723, 0xA21EA2AD, 0xC3B4C399, 0x6C506C44, 0x07040705,
+    0x04F6047F, 0x27C22746, 0xAC16ACA7, 0xD025D076, 0x50865013, 0xDC56DCF7,
+    0x8455841A, 0xE109E151, 0x7ABE7A25, 0x139113EF},
+
+   {0xD939A9D9, 0x90176790, 0x719CB371, 0xD2A6E8D2, 0x05070405, 0x9852FD98,
+    0x6580A365, 0xDFE476DF, 0x08459A08, 0x024B9202, 0xA0E080A0, 0x665A7866,
+    0xDDAFE4DD, 0xB06ADDB0, 0xBF63D1BF, 0x362A3836, 0x54E60D54, 0x4320C643,
+    0x62CC3562, 0xBEF298BE, 0x1E12181E, 0x24EBF724, 0xD7A1ECD7, 0x77416C77,
+    0xBD2843BD, 0x32BC7532, 0xD47B37D4, 0x9B88269B, 0x700DFA70, 0xF94413F9,
+    0xB1FB94B1, 0x5A7E485A, 0x7A03F27A, 0xE48CD0E4, 0x47B68B47, 0x3C24303C,
+    0xA5E784A5, 0x416B5441, 0x06DDDF06, 0xC56023C5, 0x45FD1945, 0xA33A5BA3,
+    0x68C23D68, 0x158D5915, 0x21ECF321, 0x3166AE31, 0x3E6FA23E, 0x16578216,
+    0x95106395, 0x5BEF015B, 0x4DB8834D, 0x91862E91, 0xB56DD9B5, 0x1F83511F,
+    0x53AA9B53, 0x635D7C63, 0x3B68A63B, 0x3FFEEB3F, 0xD630A5D6, 0x257ABE25,
+    0xA7AC16A7, 0x0F090C0F, 0x35F0E335, 0x23A76123, 0xF090C0F0, 0xAFE98CAF,
+    0x809D3A80, 0x925CF592, 0x810C7381, 0x27312C27, 0x76D02576, 0xE7560BE7,
+    0x7B92BB7B, 0xE9CE4EE9, 0xF10189F1, 0x9F1E6B9F, 0xA93453A9, 0xC4F16AC4,
+    0x99C3B499, 0x975BF197, 0x8347E183, 0x6B18E66B, 0xC822BDC8, 0x0E98450E,
+    0x6E1FE26E, 0xC9B3F4C9, 0x2F74B62F, 0xCBF866CB, 0xFF99CCFF, 0xEA1495EA,
+    0xED5803ED, 0xF7DC56F7, 0xE18BD4E1, 0x1B151C1B, 0xADA21EAD, 0x0CD3D70C,
+    0x2BE2FB2B, 0x1DC8C31D, 0x195E8E19, 0xC22CB5C2, 0x8949E989, 0x12C1CF12,
+    0x7E95BF7E, 0x207DBA20, 0x6411EA64, 0x840B7784, 0x6DC5396D, 0x6A89AF6A,
+    0xD17C33D1, 0xA171C9A1, 0xCEFF62CE, 0x37BB7137, 0xFB0F81FB, 0x3DB5793D,
+    0x51E10951, 0xDC3EADDC, 0x2D3F242D, 0xA476CDA4, 0x9D55F99D, 0xEE82D8EE,
+    0x8640E586, 0xAE78C5AE, 0xCD25B9CD, 0x04964D04, 0x55774455, 0x0A0E080A,
+    0x13508613, 0x30F7E730, 0xD337A1D3, 0x40FA1D40, 0x3461AA34, 0x8C4EED8C,
+    0xB3B006B3, 0x6C54706C, 0x2A73B22A, 0x523BD252, 0x0B9F410B, 0x8B027B8B,
+    0x88D8A088, 0x4FF3114F, 0x67CB3167, 0x4627C246, 0xC06727C0, 0xB4FC90B4,
+    0x28382028, 0x7F04F67F, 0x78486078, 0x2EE5FF2E, 0x074C9607, 0x4B655C4B,
+    0xC72BB1C7, 0x6F8EAB6F, 0x0D429E0D, 0xBBF59CBB, 0xF2DB52F2, 0xF34A1BF3,
+    0xA63D5FA6, 0x59A49359, 0xBCB90ABC, 0x3AF9EF3A, 0xEF1391EF, 0xFE0885FE,
+    0x01914901, 0x6116EE61, 0x7CDE2D7C, 0xB2214FB2, 0x42B18F42, 0xDB723BDB,
+    0xB82F47B8, 0x48BF8748, 0x2CAE6D2C, 0xE3C046E3, 0x573CD657, 0x859A3E85,
+    0x29A96929, 0x7D4F647D, 0x94812A94, 0x492ECE49, 0x17C6CB17, 0xCA692FCA,
+    0xC3BDFCC3, 0x5CA3975C, 0x5EE8055E, 0xD0ED7AD0, 0x87D1AC87, 0x8E057F8E,
+    0xBA64D5BA, 0xA8A51AA8, 0xB7264BB7, 0xB9BE0EB9, 0x6087A760, 0xF8D55AF8,
+    0x22362822, 0x111B1411, 0xDE753FDE, 0x79D92979, 0xAAEE88AA, 0x332D3C33,
+    0x5F794C5F, 0xB6B702B6, 0x96CAB896, 0x5835DA58, 0x9CC4B09C, 0xFC4317FC,
+    0x1A84551A, 0xF64D1FF6, 0x1C598A1C, 0x38B27D38, 0xAC3357AC, 0x18CFC718,
+    0xF4068DF4, 0x69537469, 0x749BB774, 0xF597C4F5, 0x56AD9F56, 0xDAE372DA,
+    0xD5EA7ED5, 0x4AF4154A, 0x9E8F229E, 0xA2AB12A2, 0x4E62584E, 0xE85F07E8,
+    0xE51D99E5, 0x39233439, 0xC1F66EC1, 0x446C5044, 0x5D32DE5D, 0x72466872,
+    0x26A06526, 0x93CDBC93, 0x03DADB03, 0xC6BAF8C6, 0xFA9EC8FA, 0x82D6A882,
+    0xCF6E2BCF, 0x50704050, 0xEB85DCEB, 0x750AFE75, 0x8A93328A, 0x8DDFA48D,
+    0x4C29CA4C, 0x141C1014, 0x73D72173, 0xCCB4F0CC, 0x09D4D309, 0x108A5D10,
+    0xE2510FE2, 0x00000000, 0x9A196F9A, 0xE01A9DE0, 0x8F94368F, 0xE6C742E6,
+    0xECC94AEC, 0xFDD25EFD, 0xAB7FC1AB, 0xD8A8E0D8}
+};
+
+/* The exp_to_poly and poly_to_exp tables are used to perform efficient
+ * operations in GF(2^8) represented as GF(2)[x]/w(x) where
+ * w(x)=x^8+x^6+x^3+x^2+1.  We care about doing that because it's part of the
+ * definition of the RS matrix in the key schedule.  Elements of that field
+ * are polynomials of degree not greater than 7 and all coefficients 0 or 1,
+ * which can be represented naturally by bytes (just substitute x=2).  In 
that
+ * form, GF(2^8) addition is the same as bitwise XOR, but GF(2^8)
+ * multiplication is inefficient without hardware support.  To multiply
+ * faster, I make use of the fact x is a generator for the nonzero elements,
+ * so that every element p of GF(2)[x]/w(x) is either 0 or equal to (x)^n for
+ * some n in 0..254.  Note that that caret is exponentiation in GF(2^8),
+ * *not* polynomial notation.  So if I want to compute pq where p and q are
+ * in GF(2^8), I can just say:
+ *    1. if p=0 or q=0 then pq=0
+ *    2. otherwise, find m and n such that p=x^m and q=x^n
+ *    3. pq=(x^m)(x^n)=x^(m+n), so add m and n and find pq
+ * The translations in steps 2 and 3 are looked up in the tables
+ * poly_to_exp (for step 2) and exp_to_poly (for step 3).  To see this
+ * in action, look at the CALC_S macro.  As additional wrinkles, note that
+ * one of my operands is always a constant, so the poly_to_exp lookup on it
+ * is done in advance; I included the original values in the comments so
+ * readers can have some chance of recognizing that this *is* the RS matrix
+ * from the Twofish paper.  I've only included the table entries I actually
+ * need; I never do a lookup on a variable input of zero and the biggest
+ * exponents I'll ever see are 254 (variable) and 237 (constant), so they'll
+ * never sum to more than 491.	I'm repeating part of the exp_to_poly table
+ * so that I don't have to do mod-255 reduction in the exponent arithmetic.
+ * Since I know my constant operands are never zero, I only have to worry
+ * about zero values in the variable operand, and I do it with a simple
+ * conditional branch.	I know conditionals are expensive, but I couldn't
+ * see a non-horrible way of avoiding them, and I did manage to group the
+ * statements so that each if covers four group multiplications. */
+
+static const u8 poly_to_exp[255] = {
+   0x00, 0x01, 0x17, 0x02, 0x2E, 0x18, 0x53, 0x03, 0x6A, 0x2F, 0x93, 0x19,
+   0x34, 0x54, 0x45, 0x04, 0x5C, 0x6B, 0xB6, 0x30, 0xA6, 0x94, 0x4B, 0x1A,
+   0x8C, 0x35, 0x81, 0x55, 0xAA, 0x46, 0x0D, 0x05, 0x24, 0x5D, 0x87, 0x6C,
+   0x9B, 0xB7, 0xC1, 0x31, 0x2B, 0xA7, 0xA3, 0x95, 0x98, 0x4C, 0xCA, 0x1B,
+   0xE6, 0x8D, 0x73, 0x36, 0xCD, 0x82, 0x12, 0x56, 0x62, 0xAB, 0xF0, 0x47,
+   0x4F, 0x0E, 0xBD, 0x06, 0xD4, 0x25, 0xD2, 0x5E, 0x27, 0x88, 0x66, 0x6D,
+   0xD6, 0x9C, 0x79, 0xB8, 0x08, 0xC2, 0xDF, 0x32, 0x68, 0x2C, 0xFD, 0xA8,
+   0x8A, 0xA4, 0x5A, 0x96, 0x29, 0x99, 0x22, 0x4D, 0x60, 0xCB, 0xE4, 0x1C,
+   0x7B, 0xE7, 0x3B, 0x8E, 0x9E, 0x74, 0xF4, 0x37, 0xD8, 0xCE, 0xF9, 0x83,
+   0x6F, 0x13, 0xB2, 0x57, 0xE1, 0x63, 0xDC, 0xAC, 0xC4, 0xF1, 0xAF, 0x48,
+   0x0A, 0x50, 0x42, 0x0F, 0xBA, 0xBE, 0xC7, 0x07, 0xDE, 0xD5, 0x78, 0x26,
+   0x65, 0xD3, 0xD1, 0x5F, 0xE3, 0x28, 0x21, 0x89, 0x59, 0x67, 0xFC, 0x6E,
+   0xB1, 0xD7, 0xF8, 0x9D, 0xF3, 0x7A, 0x3A, 0xB9, 0xC6, 0x09, 0x41, 0xC3,
+   0xAE, 0xE0, 0xDB, 0x33, 0x44, 0x69, 0x92, 0x2D, 0x52, 0xFE, 0x16, 0xA9,
+   0x0C, 0x8B, 0x80, 0xA5, 0x4A, 0x5B, 0xB5, 0x97, 0xC9, 0x2A, 0xA2, 0x9A,
+   0xC0, 0x23, 0x86, 0x4E, 0xBC, 0x61, 0xEF, 0xCC, 0x11, 0xE5, 0x72, 0x1D,
+   0x3D, 0x7C, 0xEB, 0xE8, 0xE9, 0x3C, 0xEA, 0x8F, 0x7D, 0x9F, 0xEC, 0x75,
+   0x1E, 0xF5, 0x3E, 0x38, 0xF6, 0xD9, 0x3F, 0xCF, 0x76, 0xFA, 0x1F, 0x84,
+   0xA0, 0x70, 0xED, 0x14, 0x90, 0xB3, 0x7E, 0x58, 0xFB, 0xE2, 0x20, 0x64,
+   0xD0, 0xDD, 0x77, 0xAD, 0xDA, 0xC5, 0x40, 0xF2, 0x39, 0xB0, 0xF7, 0x49,
+   0xB4, 0x0B, 0x7F, 0x51, 0x15, 0x43, 0x91, 0x10, 0x71, 0xBB, 0xEE, 0xBF,
+   0x85, 0xC8, 0xA1
+};
+
+static const u8 exp_to_poly[492] = {
+   0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D, 0x9A, 0x79, 0xF2,
+   0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC, 0xF5, 0xA7, 0x03,
+   0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3, 0x8B, 0x5B, 0xB6,
+   0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52, 0xA4, 0x05, 0x0A,
+   0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0, 0xED, 0x97, 0x63,
+   0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1, 0x0F, 0x1E, 0x3C,
+   0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A, 0xF4, 0xA5, 0x07,
+   0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11, 0x22, 0x44, 0x88,
+   0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51, 0xA2, 0x09, 0x12,
+   0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66, 0xCC, 0xD5, 0xE7,
+   0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB, 0x1B, 0x36, 0x6C,
+   0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19, 0x32, 0x64, 0xC8,
+   0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D, 0x5A, 0xB4, 0x25,
+   0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56, 0xAC, 0x15, 0x2A,
+   0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE, 0x91, 0x6F, 0xDE,
+   0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9, 0x3F, 0x7E, 0xFC,
+   0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE, 0xB1, 0x2F, 0x5E,
+   0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41, 0x82, 0x49, 0x92,
+   0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E, 0x71, 0xE2, 0x89,
+   0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB, 0xDB, 0xFB, 0xBB,
+   0x3B, 0x76, 0xEC, 0x95, 0x67, 0xCE, 0xD1, 0xEF, 0x93, 0x6B, 0xD6, 0xE1,
+   0x8F, 0x53, 0xA6, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D,
+   0x9A, 0x79, 0xF2, 0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC,
+   0xF5, 0xA7, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3,
+   0x8B, 0x5B, 0xB6, 0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52,
+   0xA4, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0,
+   0xED, 0x97, 0x63, 0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1,
+   0x0F, 0x1E, 0x3C, 0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A,
+   0xF4, 0xA5, 0x07, 0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11,
+   0x22, 0x44, 0x88, 0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51,
+   0xA2, 0x09, 0x12, 0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66,
+   0xCC, 0xD5, 0xE7, 0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB,
+   0x1B, 0x36, 0x6C, 0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19,
+   0x32, 0x64, 0xC8, 0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D,
+   0x5A, 0xB4, 0x25, 0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56,
+   0xAC, 0x15, 0x2A, 0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE,
+   0x91, 0x6F, 0xDE, 0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9,
+   0x3F, 0x7E, 0xFC, 0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE,
+   0xB1, 0x2F, 0x5E, 0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41,
+   0x82, 0x49, 0x92, 0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E,
+   0x71, 0xE2, 0x89, 0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB
+};
+
+
+/* The table constants are indices of
+ * S-box entries, preprocessed through q0 and q1. */
+static const u8 calc_sb_tbl[512] = {
+    0xA9, 0x75, 0x67, 0xF3, 0xB3, 0xC6, 0xE8, 0xF4,
+    0x04, 0xDB, 0xFD, 0x7B, 0xA3, 0xFB, 0x76, 0xC8,
+    0x9A, 0x4A, 0x92, 0xD3, 0x80, 0xE6, 0x78, 0x6B,
+    0xE4, 0x45, 0xDD, 0x7D, 0xD1, 0xE8, 0x38, 0x4B,
+    0x0D, 0xD6, 0xC6, 0x32, 0x35, 0xD8, 0x98, 0xFD,
+    0x18, 0x37, 0xF7, 0x71, 0xEC, 0xF1, 0x6C, 0xE1,
+    0x43, 0x30, 0x75, 0x0F, 0x37, 0xF8, 0x26, 0x1B,
+    0xFA, 0x87, 0x13, 0xFA, 0x94, 0x06, 0x48, 0x3F,
+    0xF2, 0x5E, 0xD0, 0xBA, 0x8B, 0xAE, 0x30, 0x5B,
+    0x84, 0x8A, 0x54, 0x00, 0xDF, 0xBC, 0x23, 0x9D,
+    0x19, 0x6D, 0x5B, 0xC1, 0x3D, 0xB1, 0x59, 0x0E,
+    0xF3, 0x80, 0xAE, 0x5D, 0xA2, 0xD2, 0x82, 0xD5,
+    0x63, 0xA0, 0x01, 0x84, 0x83, 0x07, 0x2E, 0x14,
+    0xD9, 0xB5, 0x51, 0x90, 0x9B, 0x2C, 0x7C, 0xA3,
+    0xA6, 0xB2, 0xEB, 0x73, 0xA5, 0x4C, 0xBE, 0x54,
+    0x16, 0x92, 0x0C, 0x74, 0xE3, 0x36, 0x61, 0x51,
+    0xC0, 0x38, 0x8C, 0xB0, 0x3A, 0xBD, 0xF5, 0x5A,
+    0x73, 0xFC, 0x2C, 0x60, 0x25, 0x62, 0x0B, 0x96,
+    0xBB, 0x6C, 0x4E, 0x42, 0x89, 0xF7, 0x6B, 0x10,
+    0x53, 0x7C, 0x6A, 0x28, 0xB4, 0x27, 0xF1, 0x8C,
+    0xE1, 0x13, 0xE6, 0x95, 0xBD, 0x9C, 0x45, 0xC7,
+    0xE2, 0x24, 0xF4, 0x46, 0xB6, 0x3B, 0x66, 0x70,
+    0xCC, 0xCA, 0x95, 0xE3, 0x03, 0x85, 0x56, 0xCB,
+    0xD4, 0x11, 0x1C, 0xD0, 0x1E, 0x93, 0xD7, 0xB8,
+    0xFB, 0xA6, 0xC3, 0x83, 0x8E, 0x20, 0xB5, 0xFF,
+    0xE9, 0x9F, 0xCF, 0x77, 0xBF, 0xC3, 0xBA, 0xCC,
+    0xEA, 0x03, 0x77, 0x6F, 0x39, 0x08, 0xAF, 0xBF,
+    0x33, 0x40, 0xC9, 0xE7, 0x62, 0x2B, 0x71, 0xE2,
+    0x81, 0x79, 0x79, 0x0C, 0x09, 0xAA, 0xAD, 0x82,
+    0x24, 0x41, 0xCD, 0x3A, 0xF9, 0xEA, 0xD8, 0xB9,
+    0xE5, 0xE4, 0xC5, 0x9A, 0xB9, 0xA4, 0x4D, 0x97,
+    0x44, 0x7E, 0x08, 0xDA, 0x86, 0x7A, 0xE7, 0x17,
+    0xA1, 0x66, 0x1D, 0x94, 0xAA, 0xA1, 0xED, 0x1D,
+    0x06, 0x3D, 0x70, 0xF0, 0xB2, 0xDE, 0xD2, 0xB3,
+    0x41, 0x0B, 0x7B, 0x72, 0xA0, 0xA7, 0x11, 0x1C,
+    0x31, 0xEF, 0xC2, 0xD1, 0x27, 0x53, 0x90, 0x3E,
+    0x20, 0x8F, 0xF6, 0x33, 0x60, 0x26, 0xFF, 0x5F,
+    0x96, 0xEC, 0x5C, 0x76, 0xB1, 0x2A, 0xAB, 0x49,
+    0x9E, 0x81, 0x9C, 0x88, 0x52, 0xEE, 0x1B, 0x21,
+    0x5F, 0xC4, 0x93, 0x1A, 0x0A, 0xEB, 0xEF, 0xD9,
+    0x91, 0xC5, 0x85, 0x39, 0x49, 0x99, 0xEE, 0xCD,
+    0x2D, 0xAD, 0x4F, 0x31, 0x8F, 0x8B, 0x3B, 0x01,
+    0x47, 0x18, 0x87, 0x23, 0x6D, 0xDD, 0x46, 0x1F,
+    0xD6, 0x4E, 0x3E, 0x2D, 0x69, 0xF9, 0x64, 0x48,
+    0x2A, 0x4F, 0xCE, 0xF2, 0xCB, 0x65, 0x2F, 0x8E,
+    0xFC, 0x78, 0x97, 0x5C, 0x05, 0x58, 0x7A, 0x19,
+    0xAC, 0x8D, 0x7F, 0xE5, 0xD5, 0x98, 0x1A, 0x57,
+    0x4B, 0x67, 0x0E, 0x7F, 0xA7, 0x05, 0x5A, 0x64,
+    0x28, 0xAF, 0x14, 0x63, 0x3F, 0xB6, 0x29, 0xFE,
+    0x88, 0xF5, 0x3C, 0xB7, 0x4C, 0x3C, 0x02, 0xA5,
+    0xB8, 0xCE, 0xDA, 0xE9, 0xB0, 0x68, 0x17, 0x44,
+    0x55, 0xE0, 0x1F, 0x4D, 0x8A, 0x43, 0x7D, 0x69,
+    0x57, 0x29, 0xC7, 0x2E, 0x8D, 0xAC, 0x74, 0x15,
+    0xB7, 0x59, 0xC4, 0xA8, 0x9F, 0x0A, 0x72, 0x9E,
+    0x7E, 0x6E, 0x15, 0x47, 0x22, 0xDF, 0x12, 0x34,
+    0x58, 0x35, 0x07, 0x6A, 0x99, 0xCF, 0x34, 0xDC,
+    0x6E, 0x22, 0x50, 0xC9, 0xDE, 0xC0, 0x68, 0x9B,
+    0x65, 0x89, 0xBC, 0xD4, 0xDB, 0xED, 0xF8, 0xAB,
+    0xC8, 0x12, 0xA8, 0xA2, 0x2B, 0x0D, 0x40, 0x52,
+    0xDC, 0xBB, 0xFE, 0x02, 0x32, 0x2F, 0xA4, 0xA9,
+    0xCA, 0xD7, 0x10, 0x61, 0x21, 0x1E, 0xF0, 0xB4,
+    0xD3, 0x50, 0x5D, 0x04, 0x0F, 0xF6, 0x00, 0xC2,
+    0x6F, 0x16, 0x9D, 0x25, 0x36, 0x86, 0x42, 0x56,
+    0x4A, 0x55, 0x5E, 0x09, 0xC1, 0xBE, 0xE0, 0x91
+};
+
+/* Macro to perform one column of the RS matrix multiplication.  The
+ * parameters a, b, c, and d are the four bytes of output; i is the index
+ * of the key bytes, and w, x, y, and z, are the column of constants from
+ * the RS matrix, preprocessed through the poly_to_exp table. */
+
+#define CALC_S(a, b, c, d, i, w, x, y, z) \
+   if (key[i]) { \
+      tmp = poly_to_exp[key[i] - 1]; \
+      (a) ^= exp_to_poly[tmp + (w)]; \
+      (b) ^= exp_to_poly[tmp + (x)]; \
+      (c) ^= exp_to_poly[tmp + (y)]; \
+      (d) ^= exp_to_poly[tmp + (z)]; \
+   }
+
+/* Macros to calculate the key-dependent S-boxes for a 128-bit key using
+ * the S vector from CALC_S.  CALC_SB_2 computes a single entry in all
+ * four S-boxes, where i is the index of the entry to compute, and a and b
+ * are the index numbers preprocessed through the q0 and q1 tables
+ * respectively. */
+
+#define CALC_SB_2(i, a, b) \
+   ctx-&gt;s[0][i] = mds[0][q0[(a) ^ sa] ^ se]; \
+   ctx-&gt;s[1][i] = mds[1][q0[(b) ^ sb] ^ sf]; \
+   ctx-&gt;s[2][i] = mds[2][q1[(a) ^ sc] ^ sg]; \
+   ctx-&gt;s[3][i] = mds[3][q1[(b) ^ sd] ^ sh]
+
+/* Macro exactly like CALC_SB_2, but for 192-bit keys. */
+
+#define CALC_SB192_2(i, a, b) \
+   ctx-&gt;s[0][i] = mds[0][q0[q0[(b) ^ sa] ^ se] ^ si]; \
+   ctx-&gt;s[1][i] = mds[1][q0[q1[(b) ^ sb] ^ sf] ^ sj]; \
+   ctx-&gt;s[2][i] = mds[2][q1[q0[(a) ^ sc] ^ sg] ^ sk]; \
+   ctx-&gt;s[3][i] = mds[3][q1[q1[(a) ^ sd] ^ sh] ^ sl];
+
+/* Macro exactly like CALC_SB_2, but for 256-bit keys. */
+
+#define CALC_SB256_2(i, a, b) \
+   ctx-&gt;s[0][i] = mds[0][q0[q0[q1[(b) ^ sa] ^ se] ^ si] ^ sm]; \
+   ctx-&gt;s[1][i] = mds[1][q0[q1[q1[(a) ^ sb] ^ sf] ^ sj] ^ sn]; \
+   ctx-&gt;s[2][i] = mds[2][q1[q0[q0[(a) ^ sc] ^ sg] ^ sk] ^ so]; \
+   ctx-&gt;s[3][i] = mds[3][q1[q1[q0[(b) ^ sd] ^ sh] ^ sl] ^ sp];
+
+/* Macros to calculate the whitening and round subkeys.  CALC_K_2 computes 
the
+ * last two stages of the h() function for a given index (either 2i or 2i+1).
+ * a, b, c, and d are the four bytes going into the last two stages.  For
+ * 128-bit keys, this is the entire h() function and a and c are the index
+ * preprocessed through q0 and q1 respectively; for longer keys they are the
+ * output of previous stages.  j is the index of the first key byte to use.
+ * CALC_K computes a pair of subkeys for 128-bit Twofish, by calling CALC_K_2
+ * twice, doing the Pseudo-Hadamard Transform, and doing the necessary
+ * rotations.  Its parameters are: a, the array to write the results into,
+ * j, the index of the first output entry, k and l, the preprocessed indices
+ * for index 2i, and m and n, the preprocessed indices for index 2i+1.
+ * CALC_K192_2 expands CALC_K_2 to handle 192-bit keys, by doing an
+ * additional lookup-and-XOR stage.  The parameters a, b, c and d are the
+ * four bytes going into the last three stages.  For 192-bit keys, c = d
+ * are the index preprocessed through q0, and a = b are the index
+ * preprocessed through q1; j is the index of the first key byte to use.
+ * CALC_K192 is identical to CALC_K but for using the CALC_K192_2 macro
+ * instead of CALC_K_2.
+ * CALC_K256_2 expands CALC_K192_2 to handle 256-bit keys, by doing an
+ * additional lookup-and-XOR stage.  The parameters a and b are the index
+ * preprocessed through q0 and q1 respectively; j is the index of the first
+ * key byte to use.  CALC_K256 is identical to CALC_K but for using the
+ * CALC_K256_2 macro instead of CALC_K_2. */
+
+#define CALC_K_2(a, b, c, d, j) \
+     mds[0][q0[a ^ key[(j) + 8]] ^ key[j]] \
+   ^ mds[1][q0[b ^ key[(j) + 9]] ^ key[(j) + 1]] \
+   ^ mds[2][q1[c ^ key[(j) + 10]] ^ key[(j) + 2]] \
+   ^ mds[3][q1[d ^ key[(j) + 11]] ^ key[(j) + 3]]
+
+#define CALC_K(a, j, k, l, m, n) \
+   x = CALC_K_2 (k, l, k, l, 0); \
+   y = CALC_K_2 (m, n, m, n, 4); \
+   y = rol32(y, 8); \
+   x += y; y += x; ctx-&gt;a[j] = x; \
+   ctx-&gt;a[(j) + 1] = rol32(y, 9)
+
+#define CALC_K192_2(a, b, c, d, j) \
+   CALC_K_2 (q0[a ^ key[(j) + 16]], \
+	     q1[b ^ key[(j) + 17]], \
+	     q0[c ^ key[(j) + 18]], \
+	     q1[d ^ key[(j) + 19]], j)
+
+#define CALC_K192(a, j, k, l, m, n) \
+   x = CALC_K192_2 (l, l, k, k, 0); \
+   y = CALC_K192_2 (n, n, m, m, 4); \
+   y = rol32(y, 8); \
+   x += y; y += x; ctx-&gt;a[j] = x; \
+   ctx-&gt;a[(j) + 1] = rol32(y, 9)
+
+#define CALC_K256_2(a, b, j) \
+   CALC_K192_2 (q1[b ^ key[(j) + 24]], \
+	        q1[a ^ key[(j) + 25]], \
+	        q0[a ^ key[(j) + 26]], \
+	        q0[b ^ key[(j) + 27]], j)
+
+#define CALC_K256(a, j, k, l, m, n) \
+   x = CALC_K256_2 (k, l, 0); \
+   y = CALC_K256_2 (m, n, 4); \
+   y = rol32(y, 8); \
+   x += y; y += x; ctx-&gt;a[j] = x; \
+   ctx-&gt;a[(j) + 1] = rol32(y, 9)
+
+
+
+/* Perform the key setup. */
+int twofish_setkey(void *cx, const u8 *key,
+                          unsigned int key_len, u32 *flags)
+{
+
+	struct twofish_ctx *ctx = cx;
+
+	int i, j, k;
+
+	/* Temporaries for CALC_K. */
+	u32 x, y;
+
+	/* The S vector used to key the S-boxes, split up into individual bytes.
+	 * 128-bit keys use only sa through sh; 256-bit use all of them. */
+	u8 sa = 0, sb = 0, sc = 0, sd = 0, se = 0, sf = 0, sg = 0, sh = 0;
+	u8 si = 0, sj = 0, sk = 0, sl = 0, sm = 0, sn = 0, so = 0, sp = 0;
+
+	/* Temporary for CALC_S. */
+	u8 tmp;
+
+	/* Check key length. */
+	if (key_len != 16 &amp;&amp; key_len != 24 &amp;&amp; key_len != 32)
+	{
+		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
+		return -EINVAL; /* unsupported key length */
+	}
+
+	/* Compute the first two words of the S vector.  The magic numbers are
+	 * the entries of the RS matrix, preprocessed through poly_to_exp. The
+	 * numbers in the comments are the original (polynomial form) matrix
+	 * entries. */
+	CALC_S (sa, sb, sc, sd, 0, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+	CALC_S (sa, sb, sc, sd, 1, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+	CALC_S (sa, sb, sc, sd, 2, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+	CALC_S (sa, sb, sc, sd, 3, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+	CALC_S (sa, sb, sc, sd, 4, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+	CALC_S (sa, sb, sc, sd, 5, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+	CALC_S (sa, sb, sc, sd, 6, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+	CALC_S (sa, sb, sc, sd, 7, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+	CALC_S (se, sf, sg, sh, 8, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+	CALC_S (se, sf, sg, sh, 9, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+	CALC_S (se, sf, sg, sh, 10, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+	CALC_S (se, sf, sg, sh, 11, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+	CALC_S (se, sf, sg, sh, 12, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+	CALC_S (se, sf, sg, sh, 13, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+	CALC_S (se, sf, sg, sh, 14, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+	CALC_S (se, sf, sg, sh, 15, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+
+	if (key_len == 24 || key_len == 32) { /* 192- or 256-bit key */
+		/* Calculate the third word of the S vector */
+		CALC_S (si, sj, sk, sl, 16, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+		CALC_S (si, sj, sk, sl, 17, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+		CALC_S (si, sj, sk, sl, 18, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+		CALC_S (si, sj, sk, sl, 19, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+		CALC_S (si, sj, sk, sl, 20, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+		CALC_S (si, sj, sk, sl, 21, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+		CALC_S (si, sj, sk, sl, 22, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+		CALC_S (si, sj, sk, sl, 23, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+	}
+
+	if (key_len == 32) { /* 256-bit key */
+		/* Calculate the fourth word of the S vector */
+		CALC_S (sm, sn, so, sp, 24, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+		CALC_S (sm, sn, so, sp, 25, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+		CALC_S (sm, sn, so, sp, 26, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+		CALC_S (sm, sn, so, sp, 27, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+		CALC_S (sm, sn, so, sp, 28, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+		CALC_S (sm, sn, so, sp, 29, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+		CALC_S (sm, sn, so, sp, 30, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+		CALC_S (sm, sn, so, sp, 31, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+
+		/* Compute the S-boxes. */
+		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
+			CALC_SB256_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
+		}
+
+		/* Calculate whitening and round subkeys.  The constants are
+		 * indices of subkeys, preprocessed through q0 and q1. */
+		CALC_K256 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
+		CALC_K256 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
+		CALC_K256 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
+		CALC_K256 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
+		CALC_K256 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
+		CALC_K256 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
+		CALC_K256 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
+		CALC_K256 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
+		CALC_K256 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
+		CALC_K256 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
+		CALC_K256 (k, 12, 0x18, 0x37, 0xF7, 0x71);
+		CALC_K256 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
+		CALC_K256 (k, 16, 0x43, 0x30, 0x75, 0x0F);
+		CALC_K256 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
+		CALC_K256 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
+		CALC_K256 (k, 22, 0x94, 0x06, 0x48, 0x3F);
+		CALC_K256 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
+		CALC_K256 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
+		CALC_K256 (k, 28, 0x84, 0x8A, 0x54, 0x00);
+		CALC_K256 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
+	} else if (key_len == 24) { /* 192-bit key */
+		/* Compute the S-boxes. */
+		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
+		        CALC_SB192_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
+		}
+
+		/* Calculate whitening and round subkeys.  The constants are
+		 * indices of subkeys, preprocessed through q0 and q1. */
+		CALC_K192 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
+		CALC_K192 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
+		CALC_K192 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
+		CALC_K192 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
+		CALC_K192 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
+		CALC_K192 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
+		CALC_K192 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
+		CALC_K192 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
+		CALC_K192 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
+		CALC_K192 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
+		CALC_K192 (k, 12, 0x18, 0x37, 0xF7, 0x71);
+		CALC_K192 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
+		CALC_K192 (k, 16, 0x43, 0x30, 0x75, 0x0F);
+		CALC_K192 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
+		CALC_K192 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
+		CALC_K192 (k, 22, 0x94, 0x06, 0x48, 0x3F);
+		CALC_K192 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
+		CALC_K192 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
+		CALC_K192 (k, 28, 0x84, 0x8A, 0x54, 0x00);
+		CALC_K192 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
+	} else { /* 128-bit key */
+		/* Compute the S-boxes. */
+		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
+			CALC_SB_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
+		}
+
+		/* Calculate whitening and round subkeys.  The constants are
+		 * indices of subkeys, preprocessed through q0 and q1. */
+		CALC_K (w, 0, 0xA9, 0x75, 0x67, 0xF3);
+		CALC_K (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
+		CALC_K (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
+		CALC_K (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
+		CALC_K (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
+		CALC_K (k, 2, 0x80, 0xE6, 0x78, 0x6B);
+		CALC_K (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
+		CALC_K (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
+		CALC_K (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
+		CALC_K (k, 10, 0x35, 0xD8, 0x98, 0xFD);
+		CALC_K (k, 12, 0x18, 0x37, 0xF7, 0x71);
+		CALC_K (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
+		CALC_K (k, 16, 0x43, 0x30, 0x75, 0x0F);
+		CALC_K (k, 18, 0x37, 0xF8, 0x26, 0x1B);
+		CALC_K (k, 20, 0xFA, 0x87, 0x13, 0xFA);
+		CALC_K (k, 22, 0x94, 0x06, 0x48, 0x3F);
+		CALC_K (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
+		CALC_K (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
+		CALC_K (k, 28, 0x84, 0x8A, 0x54, 0x00);
+		CALC_K (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
+	}
+
+	return 0;
+}
+
+
+
diff -uprN linux-2.6.17-rc5/include/crypto/twofish.h 
linux-2.6.17-rc5.twofish/include/crypto/twofish.h
--- linux-2.6.17-rc5/include/crypto/twofish.h	1970-01-01 01:00:00.000000000 
+0100
+++ linux-2.6.17-rc5.twofish/include/crypto/twofish.h	2006-05-30 
15:34:10.075319504 +0200
@@ -0,0 +1,15 @@
+#define TF_MIN_KEY_SIZE 16
+#define TF_MAX_KEY_SIZE 32
+#define TF_BLOCK_SIZE 16
+
+/* Structure for an expanded Twofish key.  s contains the key-dependent
+ * S-boxes composed with the MDS matrix; w contains the eight "whitening"
+ * subkeys, K[0] through K[7].	k holds the remaining, "round" subkeys.  Note
+ * that k[i] corresponds to what the Twofish paper calls K[i+8]. */
+struct twofish_ctx {
+   u32 s[4][256], w[8], k[32];
+};
+
+int twofish_setkey(void *cx, const u8 *key,
+                          unsigned int key_len, u32 *flags);
+
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060612190204</emailId><senderName>Michael Richardson</senderName><senderEmail>mcr@sandelman.ottawa.on.ca</senderEmail><timestampReceived>2006-06-12 19:02:04-0400</timestampReceived><subject>crypto_cipher_encrypt_iv and null cipher</subject><body>

It seems that 
   crypto_cipher_encrypt_iv(); and decrypt_iv(); 

BUG_ON() if the cit_mode is MODE_ECB. Okay, that's reasonable.

The problem is that the OCF cryptosoft interface for OCF sets the mode=0,
now. Since it's a NULL cipher, it doesn't matter what mode, so I've
changed it to CBC mode, and fixed the code in crypto.c to deal with a
cipher that has a 1-byte block size.

commit 940e136dd89fd58d0b02e540167f2d29c68bdbb6
Author: Michael Richardson &lt;mcr@xelerance.com&gt;
Date:   Sat Jun 10 11:28:15 2006 -0400

    include support for null cipher --- block size of "1"

diff --git a/crypto/cipher.c b/crypto/cipher.c
index 65bcea0..bb27b14 100644
--- a/crypto/cipher.c
+++ b/crypto/cipher.c
@@ -23,6 +23,11 @@ #include &lt;asm/scatterlist.h&gt;
 #include "internal.h"
 #include "scatterwalk.h"
 
+static inline void xor_1(u8 *a, const u8 *b)
+{
+	a[0] ^= b[0];
+}
+
 static inline void xor_64(u8 *a, const u8 *b)
 {
 	((u32 *)a)[0] ^= ((u32 *)b)[0];
@@ -431,6 +436,11 @@ int crypto_init_cipher_ops(struct crypto
 		unsigned long addr;
 	    	
 	    	switch (crypto_tfm_alg_blocksize(tfm)) {
+		case 1:
+			/* some ciphers (e.g. null) have no restrictions. */
+			ops-&gt;cit_xor_block = xor_1;
+			break;
+			
 	    	case 8:
 	    		ops-&gt;cit_xor_block = xor_64;
 	    		break;





-- 
]       ON HUMILITY: to err is human. To moo, bovine.           |  firewalls  [
]   Michael Richardson,    Xelerance Corporation, Ottawa, ON    |net architect[
] mcr@xelerance.com      http://www.sandelman.ottawa.on.ca/mcr/ |device driver[
] panic("Just another Debian GNU/Linux using, kernel hacking, security guy"); [

    "The Microsoft _Get the Facts CD_ does not work on Linux." - orospakr



[Attachment #3 (application/pgp-signature)]
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060614223102</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-06-14 22:31:02-0400</timestampReceived><subject>Re: crypto_cipher_encrypt_iv and null cipher</subject><body>

On Mon, Jun 12, 2006 at 03:02:04PM -0400, Michael Richardson wrote:
&gt; 
&gt; It seems that 
&gt;    crypto_cipher_encrypt_iv(); and decrypt_iv(); 
&gt; 
&gt; BUG_ON() if the cit_mode is MODE_ECB. Okay, that's reasonable.
&gt; 
&gt; The problem is that the OCF cryptosoft interface for OCF sets the mode=0,
&gt; now. Since it's a NULL cipher, it doesn't matter what mode, so I've
&gt; changed it to CBC mode, and fixed the code in crypto.c to deal with a
&gt; cipher that has a 1-byte block size.

Thanks for the patch.  However, I won't apply this because it will soon
become redundant once I add parameterised algorithms.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060615143429</emailId><senderName>Michael Richardson</senderName><senderEmail>mcr@sandelman.ottawa.on.ca</senderEmail><timestampReceived>2006-06-15 14:34:29-0400</timestampReceived><subject>Re: crypto_cipher_encrypt_iv and null cipher</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1


&gt;&gt;&gt;&gt;&gt; "Herbert" == Herbert Xu &lt;herbert@gondor.apana.org.au&gt; writes:
    &gt;&gt; It seems that crypto_cipher_encrypt_iv(); and decrypt_iv();
    &gt;&gt; 
    &gt;&gt; BUG_ON() if the cit_mode is MODE_ECB. Okay, that's reasonable.
    &gt;&gt; 
    &gt;&gt; The problem is that the OCF cryptosoft interface for OCF sets the
    &gt;&gt; mode=0, now. Since it's a NULL cipher, it doesn't matter what
    &gt;&gt; mode, so I've changed it to CBC mode, and fixed the code in
    &gt;&gt; crypto.c to deal with a cipher that has a 1-byte block size.

    Herbert&gt; Thanks for the patch.  However, I won't apply this because
    Herbert&gt; it will soon become redundant once I add parameterised
    Herbert&gt; algorithms.

  What does that mean?

- -- 
]       ON HUMILITY: to err is human. To moo, bovine.           |  firewalls  [
]   Michael Richardson,    Xelerance Corporation, Ottawa, ON    |net architect[
] mcr@xelerance.com      http://www.sandelman.ottawa.on.ca/mcr/ |device driver[
] panic("Just another Debian GNU/Linux using, kernel hacking, security guy"); [

    "The Microsoft _Get the Facts CD_ does not work on Linux." - orospakr

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.2.2 (GNU/Linux)
Comment: Finger me for keys

iQEVAwUBRJFv84CLcPvd0N1lAQL7ggf+MFHofTn2levVR+x5QnJiszvQwB0PIEpa
3/3MRRaDaAfIx9Dp1Uy2w2j7IXJQZcgDyuvqiDr0I1/qsXXC3xLiNUTqf93Xbp7G
QZKWZ6672woginfz/zE7GAipLG3oqMj+XeM8sRlJrvlVryKtldRy9+zPUmZHFKlu
7liT3O+zLgaqtieei3ValPYykTvAxt9fdA8L/SPRu2Bbz0pI5s0VSKm5ziMVp4hp
qcTLdlvIc9mBEGZ3OAGyVyo0Pul0LxnEjrBELs0Hb/XNc8hVZkopfAsL9cbyBWCs
tkQw5a5AtiJzg9//+B7Z4IAQS/UXSUNcPRtJjhosYnG31nDCfq9dBA==
=8sbM
-----END PGP SIGNATURE-----
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060620011950</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-06-20 01:19:50-0400</timestampReceived><subject>Re: crypto_cipher_encrypt_iv and null cipher</subject><body>

On Thu, Jun 15, 2006 at 10:34:29AM -0400, Michael Richardson wrote:
&gt; 
&gt;     Herbert&gt; Thanks for the patch.  However, I won't apply this because
&gt;     Herbert&gt; it will soon become redundant once I add parameterised
&gt;     Herbert&gt; algorithms.
&gt; 
&gt;   What does that mean?

Instead of requesting for "cipher_null" with a block chaining mode you
will soon ask for "cbc(cipher_null)" or "ecb(cipher_null)".

So there should be no ambiguity as to which mode is being requested.

Also the generic CBC algorithm will support arbitrary block sizes.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060620143052</emailId><senderName>Michael Richardson</senderName><senderEmail>mcr@sandelman.ottawa.on.ca</senderEmail><timestampReceived>2006-06-20 14:30:52-0400</timestampReceived><subject>Re: crypto_cipher_encrypt_iv and null cipher</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1


Are you sure that you want to have generic CBC code?

For many algorithms, there are optomizations that one can do when one is
in CBC mode. 

- -- 
]       ON HUMILITY: to err is human. To moo, bovine.           |  firewalls  [
]   Michael Richardson,    Xelerance Corporation, Ottawa, ON    |net architect[
] mcr@xelerance.com      http://www.sandelman.ottawa.on.ca/mcr/ |device driver[
] panic("Just another Debian GNU/Linux using, kernel hacking, security guy"); [

    "The Microsoft _Get the Facts CD_ does not work on Linux." - orospakr

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.2.2 (GNU/Linux)
Comment: Finger me for keys

iQEVAwUBRJgGl4CLcPvd0N1lAQIgLQf/dlzqWfqrKEpGluDIE/CNHAPmrZ5npczq
6VRoM8faypJj+aDmkRV/yipLlAtITsZlgb+F+YSBp/ctBUeDt///mOnVT0B8NBC3
ypu/u2X3qCmfkXAEPYJnCY5Ni44usEtKrXha8vAtgwaVO4oevg7zYwYgnnRNW5us
KMo+w4CqTicf2YwFlTxryXD6oyEf0wPCrGVZI/OTU7igQJQdVNVyPPMG0+WAvppj
HvKIxOwnoGVwzQjZVZJ6mk0ORlCfpCVQYzjif3y6gyXNBn4cNttUxdZ+jdt1/sas
2l9qw8bArnojELo1nKYp75EfIrvtz4CFvfCJU970D243pojQwULTnw==
=QzRc
-----END PGP SIGNATURE-----
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060620143812</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-06-20 14:38:12-0400</timestampReceived><subject>Re: crypto_cipher_encrypt_iv and null cipher</subject><body>

On Tue, Jun 20, 2006 at 10:30:52AM -0400, Michael Richardson wrote:
&gt; 
&gt; Are you sure that you want to have generic CBC code?
&gt; 
&gt; For many algorithms, there are optomizations that one can do when one is
&gt; in CBC mode. 

If anything the parameterised scheme is going to make it easier to have
specific optimisations for an algorithm.  All you have to do is to
register under the name "cbc(yourname)" and off you go.

Basically from crytpo API's point of view having things like CBC hardcoded
is unnecessary and unscalable.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060620152238</emailId><senderName>Michael Richardson</senderName><senderEmail>mcr@sandelman.ottawa.on.ca</senderEmail><timestampReceived>2006-06-20 15:22:38-0400</timestampReceived><subject>Re: crypto_cipher_encrypt_iv and null cipher</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1


&gt;&gt;&gt;&gt;&gt; "Herbert" == Herbert Xu &lt;herbert@gondor.apana.org.au&gt; writes:
    &gt;&gt; Are you sure that you want to have generic CBC code?
    &gt;&gt; 
    &gt;&gt; For many algorithms, there are optomizations that one can do when
    &gt;&gt; one is in CBC mode.

    Herbert&gt; If anything the parameterised scheme is going to make it
    Herbert&gt; easier to have specific optimisations for an algorithm.
    Herbert&gt; All you have to do is to register under the name
    Herbert&gt; "cbc(yourname)" and off you go.

  I see. So, if I ask for cbc(aes) and it finds a cipher by that name,
then we are done.
  If it doesn't find it by that name, it will decompose the name to see
if it has something that it does have.

    Herbert&gt; Basically from crytpo API's point of view having things
    Herbert&gt; like CBC hardcoded is unnecessary and unscalable.

  Well, there are not that many general notions of modes, so doesn't
make this too scalable.  I still don't know why anyone would use ECB
mode in practice.

- -- 
]       ON HUMILITY: to err is human. To moo, bovine.           |  firewalls  [
]   Michael Richardson,    Xelerance Corporation, Ottawa, ON    |net architect[
] mcr@xelerance.com      http://www.sandelman.ottawa.on.ca/mcr/ |device driver[
] panic("Just another Debian GNU/Linux using, kernel hacking, security guy"); [

    "The Microsoft _Get the Facts CD_ does not work on Linux." - orospakr

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.2.2 (GNU/Linux)
Comment: Finger me for keys

iQEVAwUBRJgSvICLcPvd0N1lAQIXKAf/eKh3uV7Qbb5vrMeEsTq0vWie8wdrqxxd
clvcD+WdGqwbSi8Qt0AH/IhThbYoXn2mpgwfiLSqPyv2lTRL0keU3foaHL7hOygs
hlnrwAj1tu/KxyS7Yi2nlOh5y1kLsP+rQCIn1rENI67H7kAGb168DbypcQ8TSMgc
qz8SKOqR6S8MHpTtjDSnz8c7dvcPNomwrF+8OUf3KMG+er+6mbKaVVbHoFRpfij8
Q0Aeovzyl+RZl7aoKyI6az9jEq1FhsKVJnJ8Q5NWlXjsnlFOpdWBNyfAygdYbsPl
KyUkYdf7wAv/zTioiqMlCbc5TpmNIX2mJRo2CVWNaO7L7h/6u3E2/w==
=xc1N
-----END PGP SIGNATURE-----
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060620233121</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-06-20 23:31:21-0400</timestampReceived><subject>Re: crypto_cipher_encrypt_iv and null cipher</subject><body>

On Tue, Jun 20, 2006 at 11:22:38AM -0400, Michael Richardson wrote:
&gt; 
&gt;   Well, there are not that many general notions of modes, so doesn't
&gt; make this too scalable.  I still don't know why anyone would use ECB
&gt; mode in practice.

There are other modes like CFB, CTR, OFB, and IGE.  While they may not
be as popular as CBC, if we want to support them at all (e.g., if a
particular piece of hardware like the VIA Pardlock supports it), then
we need to generalise the block ciphers.

If we continue to do it as we do now, we'd end up with a huge list of
functions in cipher_alg.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060605100649</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-05 10:06:49-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

On Sunday 04 June 2006 21:10, Andi Kleen wrote:
&gt; On Sunday 04 June 2006 15:16, Joachim Fritschi wrote:
&gt; &gt; This patch adds the twofish x86_64 assembler routine.
&gt; &gt;
&gt; &gt; Changes since last version:
&gt; &gt; - The keysetup is now handled by the twofish_common.c (see patch 1 )
&gt; &gt; - The last round of the encrypt/decrypt routines where optimized saving 5
&gt; &gt; instructions.
&gt; &gt;
&gt; &gt; Correctness was verified with the tcrypt module and automated test
&gt; &gt; scripts.
&gt;
&gt; Do you have some benchmark numbers that show that it's actually worth
&gt; it?

Here are the outputs from the tcrypt speedtests. They haven't changed much 
since the last patch:

http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-c-i586.txt
http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-asm-i586.txt
http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-c-x86_64.txt
http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-asm-x86_64.txt

Summary for cycles used for CBC encrypt decrypt (256bit / 8k blocks) assembler 
vs. generic-c:

i586 encrypt:   - 17%
i568 decrypt:   -24%
x86_64 encrypt: -22%
x86_64 decrypt: -17%

The numbers vary a bit with different blocksizes / keylength and per test.

I also did some filesystem benchmarks (bonnie++) with various ciphers. Most 
write tests maxed out my drives writing to disk.  But at least for the read 
speed you can see some notable performance improvements:
(Note: The x86 and x86_64 numbers are not comparable since the tests were done 
on different machines)

http://homepages.tu-darmstadt.de/~fritschi/twofish/output_20060531_160442_x86.html

Summary:
Sequential read speed improved between 25-32%
Sequential write speed improved at least 15% but the disk maxed out
Twofish 256 is a little bit faster than AES 128

http://homepages.tu-darmstadt.de/~fritschi/twofish/output_20060601_113747_x86_64.html

Summary:
Sequential read speed improved 13%
Seqential write speed maxed out the drives

&gt; &gt; +/* Defining a few register aliases for better reading */
&gt;
&gt; Maybe you can read it now better, but for everybody else it is extremly
&gt; confusing. It would be better if you just used the original register names.

The problem with the registers is that the original naming is really crappy in 
the first place. The lower registers use the old x86 naming scheme plus some 
extensions but the upper registers are totally different. Since i use a lot 
of the lower / higher 8bit and 32 bit parts it would be virtually impossible 
to write simple macros with this naming scheme because there would be no easy 
way to switch from a (unknown) register to its 8bit subregister or the 32bit 
in a macro. While there might be some way to do this, i have not found any 
example in the kernel or any other source code.
As an explanation i can only add that i looked at the aes assembler 
implementation and used it as a example. I know refering to bad coding style 
in the kernel is no excuse for more bad coding but it seems to me that it is 
the only way to deal with the insane original register naming.
Imho using the original names would only complicate the macros and complicate 
understanding the algorithm itself. For the algorithm itself the the actual 
registers are simply irrelevant . It calls no other functions or uses any 
syscalls. It only uses them as storage. That way reffering to them in a 
numbered order with a suffix for 8/16/32bit was an easy way to improve 
readability and easier programming.
There might be some way to further improve readability but i have not found 
any other way. I'm open to suggestions :)

Regards,

Joachim
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060605101815</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-05 10:18:15-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

On Sunday 04 June 2006 23:01, Dag Arne Osvik wrote:
&gt; Andi Kleen wrote:
&gt; &gt; On Sunday 04 June 2006 15:16, Joachim Fritschi wrote:
&gt; &gt;&gt; This patch adds the twofish x86_64 assembler routine.
&gt; &gt;&gt;
&gt; &gt;&gt; +/* Defining a few register aliases for better reading */
&gt; &gt;
&gt; &gt; Maybe you can read it now better, but for everybody else it is extremly
&gt; &gt; confusing. It would be better if you just used the original register
&gt; &gt; names.
&gt;
&gt; I'd agree if you said this code could benefit from further readability
&gt; improvements.  But you're arguing against one.
&gt;
&gt; Too bad AMD kept the old register names when defining AMD64..

I'd agree that the original register names would only complicate things. 

Can you give me any hint what to improve or maybe provide a suggestion on how 
to improve the overall readabilty.

Thanks,

Joachim

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060605174414</emailId><senderName>dean gaudet</senderName><senderEmail>dean@arctic.org</senderEmail><timestampReceived>2006-06-05 17:44:14-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

On Mon, 5 Jun 2006, Joachim Fritschi wrote:

&gt; Here are the outputs from the tcrypt speedtests. They haven't changed much 
&gt; since the last patch:
&gt; 
&gt; http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-c-i586.txt
&gt; http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-asm-i586.txt
&gt; http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-c-x86_64.txt
&gt; http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-asm-x86_64.txt

when you quote anything related to cpu performance on an x86 processor 
it's absolutely essential to indicate which cpu it is... basically 
vendor_id, cpu family, and model from /proc/cpuinfo.  (for example the 
entire p4 family has incredible model-to-model variation on things like 
shifts and extensions.)


&gt; &gt; &gt; +/* Defining a few register aliases for better reading */
&gt; &gt;
&gt; &gt; Maybe you can read it now better, but for everybody else it is extremly
&gt; &gt; confusing. It would be better if you just used the original register names.

i'd change the comment to:

/* define a few register aliases to simplify macro substitution */

because as you mention, it's totally impossible to write the macros 
otherwise.  (i've used the same trick myself a bunch of times.)

-dean
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060605194655</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-05 19:46:55-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

On Monday 05 June 2006 19:44, dean gaudet wrote:
&gt; On Mon, 5 Jun 2006, Joachim Fritschi wrote:
&gt; &gt; Here are the outputs from the tcrypt speedtests. They haven't changed
&gt; &gt; much since the last patch:
&gt; &gt;
&gt; &gt; http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-c-i586.tx
&gt; &gt;t
&gt; &gt; http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-asm-i586.
&gt; &gt;txt
&gt; &gt; http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-c-x86_64.
&gt; &gt;txt
&gt; &gt; http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-asm-x86_6
&gt; &gt;4.txt
&gt;
&gt; when you quote anything related to cpu performance on an x86 processor
&gt; it's absolutely essential to indicate which cpu it is... basically
&gt; vendor_id, cpu family, and model from /proc/cpuinfo.  (for example the
&gt; entire p4 family has incredible model-to-model variation on things like
&gt; shifts and extensions.)

x86_64 benchmarks  where done on a:
vendor_id       : AuthenticAMD
cpu family      : 15
model           : 35
model name      : AMD Athlon(tm) 64 X2 Dual Core Processor 4400+
stepping        : 2
cpu MHz         : 2200.000
cache size      : 1024 KB
SMP was disabled

x86 benchmarks where done on a:
vendor_id       : AuthenticAMD
cpu family      : 6
model           : 8
model name      : AMD Athlon(tm) XP 2400+
stepping        : 1
cpu MHz         : 1991.695
cache size      : 256 KB

&gt; &gt; &gt; &gt; +/* Defining a few register aliases for better reading */
&gt; &gt; &gt;
&gt; &gt; &gt; Maybe you can read it now better, but for everybody else it is extremly
&gt; &gt; &gt; confusing. It would be better if you just used the original register
&gt; &gt; &gt; names.
&gt;
&gt; i'd change the comment to:
&gt;
&gt; /* define a few register aliases to simplify macro substitution */
&gt;
&gt; because as you mention, it's totally impossible to write the macros
&gt; otherwise.  (i've used the same trick myself a bunch of times.)

Sounds ok to me. It was the main reason to use these aliases. For me it also 
improves readability but as author my view is probably a bit distorted ;)

Joachim

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060605222817</emailId><senderName>Dag Arne Osvik</senderName><senderEmail>da@osvik.no</senderEmail><timestampReceived>2006-06-05 22:28:17-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

Joachim Fritschi wrote:
&gt; On Sunday 04 June 2006 23:01, Dag Arne Osvik wrote:
&gt;&gt; Andi Kleen wrote:
&gt;&gt;&gt; On Sunday 04 June 2006 15:16, Joachim Fritschi wrote:
&gt;&gt;&gt;&gt; This patch adds the twofish x86_64 assembler routine.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; +/* Defining a few register aliases for better reading */
&gt;&gt;&gt; Maybe you can read it now better, but for everybody else it is extremly
&gt;&gt;&gt; confusing. It would be better if you just used the original register
&gt;&gt;&gt; names.
&gt;&gt; I'd agree if you said this code could benefit from further readability
&gt;&gt; improvements.  But you're arguing against one.
&gt;&gt;
&gt;&gt; Too bad AMD kept the old register names when defining AMD64..
&gt; 
&gt; I'd agree that the original register names would only complicate things. 
&gt; 
&gt; Can you give me any hint what to improve or maybe provide a suggestion on how 
&gt; to improve the overall readabilty.

It looks better on second reading, but I have some comments:

Remove load_s - it's needless and (slightly) confusing
There are some cases of missing ## D
Why semicolon after closing parenthesis in macro definitions?
Try to align operands in columns
It would be nice to have some explanation of macro parameter names

Btw, why do you keep zeroing tmp registers when you don't need to?
32-bit ops zero the top half of the destination register.

Here's an example of a modified macro (modulo linewrapping by my mail
client):

#define
encrypt_round(a,b,olda,oldb,newa,newb,ctx,round,tmp1,tmp2,key1,key2) \
        load_round_key(key1,key2,ctx,round);\
        movzx   a ## B,         newa ## D;\
        movzx   a ## H,         newb ## D;\
        ror     $16,            a    ## D;\
        xor     s0(ctx,newa,4), tmp1 ## D;\
        xor     s1(ctx,newb,4), tmp1 ## D;\
        movzx   a ## B,         newa ## D;\
        movzx   a ## H,         newb ## D;\
        xor     s2(ctx,newa,4), tmp1 ## D;\
        xor     s3(ctx,newb,4), tmp1 ## D;\
        ror     $16,            a    ## D;\
        movzx   b ## B,         newa ## D;\
        movzx   b ## H,         newb ## D;\
        ror     $16,            b    ## D;\
        xor     s1(ctx,newa,4), tmp2 ## D;\
        xor     s2(ctx,newb,4), tmp2 ## D;\
        movzx   b ## B,         newa ## D;\
        movzx   b ## H,         newb ## D;\
        xor     s3(ctx,newa,4), tmp2 ## D;\
        xor     s0(ctx,newb,4), tmp2 ## D;\
        ror     $15,            b    ## D;\
        add     tmp2 ## D,      tmp1 ## D;\
        add     tmp1 ## D,      tmp2 ## D;\
        add     tmp1 ## D,      key1 ## D;\
        add     tmp2 ## D,      key2 ## D;\
        mov     olda ## D,      newa ## D;\
        mov     oldb ## D,      newb ## D;\
        mov     a    ## D,      olda ## D;\
        mov     b    ## D,      oldb ## D;\
        xor     key1 ## D,      newa ## D;\
        xor     key2 ## D,      newb ## D;\
        ror     $1,             newa ## D

At least a little bit more readable, right?

-- 
  Dag Arne
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060605224414</emailId><senderName>Dag Arne Osvik</senderName><senderEmail>da@osvik.no</senderEmail><timestampReceived>2006-06-05 22:44:14-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

Dag Arne Osvik wrote:
&gt; Joachim Fritschi wrote:
&gt;&gt; On Sunday 04 June 2006 23:01, Dag Arne Osvik wrote:
&gt;&gt;&gt; Andi Kleen wrote:
&gt;&gt;&gt;&gt; On Sunday 04 June 2006 15:16, Joachim Fritschi wrote:
&gt;&gt;&gt;&gt;&gt; This patch adds the twofish x86_64 assembler routine.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; +/* Defining a few register aliases for better reading */
&gt;&gt;&gt;&gt; Maybe you can read it now better, but for everybody else it is extremly
&gt;&gt;&gt;&gt; confusing. It would be better if you just used the original register
&gt;&gt;&gt;&gt; names.
&gt;&gt;&gt; I'd agree if you said this code could benefit from further readability
&gt;&gt;&gt; improvements.  But you're arguing against one.
&gt;&gt;&gt;
&gt;&gt;&gt; Too bad AMD kept the old register names when defining AMD64..
&gt;&gt; I'd agree that the original register names would only complicate things. 
&gt;&gt;
&gt;&gt; Can you give me any hint what to improve or maybe provide a suggestion on how 
&gt;&gt; to improve the overall readabilty.
&gt; 
&gt; It looks better on second reading, but I have some comments:
&gt; 
&gt; Remove load_s - it's needless and (slightly) confusing
&gt; There are some cases of missing ## D
&gt; Why semicolon after closing parenthesis in macro definitions?
&gt; Try to align operands in columns
&gt; It would be nice to have some explanation of macro parameter names
&gt; 
&gt; Btw, why do you keep zeroing tmp registers when you don't need to?
&gt; 32-bit ops zero the top half of the destination register.

Sorry.. that zeroing was of course due to load_s only doing xor..

&gt; 
&gt; Here's an example of a modified macro (modulo linewrapping by my mail
&gt; client):
&gt; 
&gt; #define
&gt; encrypt_round(a,b,olda,oldb,newa,newb,ctx,round,tmp1,tmp2,key1,key2) \
&gt;         load_round_key(key1,key2,ctx,round);\
&gt;         movzx   a ## B,         newa ## D;\
&gt;         movzx   a ## H,         newb ## D;\
&gt;         ror     $16,            a    ## D;\
&gt;         xor     s0(ctx,newa,4), tmp1 ## D;\
          ^^^ change to mov
&gt;         xor     s1(ctx,newb,4), tmp1 ## D;\
&gt;         movzx   a ## B,         newa ## D;\
&gt;         movzx   a ## H,         newb ## D;\
&gt;         xor     s2(ctx,newa,4), tmp1 ## D;\
&gt;         xor     s3(ctx,newb,4), tmp1 ## D;\
&gt;         ror     $16,            a    ## D;\
&gt;         movzx   b ## B,         newa ## D;\
&gt;         movzx   b ## H,         newb ## D;\
&gt;         ror     $16,            b    ## D;\
&gt;         xor     s1(ctx,newa,4), tmp2 ## D;\
          ^^^ change to mov
&gt;         xor     s2(ctx,newb,4), tmp2 ## D;\
&gt;         movzx   b ## B,         newa ## D;\
&gt;         movzx   b ## H,         newb ## D;\
&gt;         xor     s3(ctx,newa,4), tmp2 ## D;\
&gt;         xor     s0(ctx,newb,4), tmp2 ## D;\
&gt;         ror     $15,            b    ## D;\
&gt;         add     tmp2 ## D,      tmp1 ## D;\
&gt;         add     tmp1 ## D,      tmp2 ## D;\
&gt;         add     tmp1 ## D,      key1 ## D;\
&gt;         add     tmp2 ## D,      key2 ## D;\
&gt;         mov     olda ## D,      newa ## D;\
&gt;         mov     oldb ## D,      newb ## D;\
&gt;         mov     a    ## D,      olda ## D;\
&gt;         mov     b    ## D,      oldb ## D;\
&gt;         xor     key1 ## D,      newa ## D;\
&gt;         xor     key2 ## D,      newb ## D;\
&gt;         ror     $1,             newa ## D
&gt; 
&gt; At least a little bit more readable, right?
&gt; 

-- 
  Dag Arne
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060604131646</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-04 13:16:46-0400</timestampReceived><subject>[PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

This patch adds the twofish x86_64 assembler routine. 

Changes since last version:
- The keysetup is now handled by the twofish_common.c (see patch 1 )
- The last round of the encrypt/decrypt routines where optimized saving 5 
instructions. 

Correctness was verified with the tcrypt module and automated test scripts.

Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

diff -uprN linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/Makefile 
linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/Makefile
--- linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/Makefile	2006-05-30 
19:58:05.172677025 +0200
+++ linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/Makefile	2006-05-31 
11:56:48.239053258 +0200
@@ -5,5 +5,8 @@
 #

 obj-$(CONFIG_CRYPTO_AES_X86_64) += aes-x86_64.o
+obj-$(CONFIG_CRYPTO_TWOFISH_X86_64) += twofish-x86_64.o

 aes-x86_64-y := aes-x86_64-asm.o aes.o
+twofish-x86_64-y := twofish-x86_64-asm.o 
twofish.o ../../../crypto/twofish_common.o
+
diff -uprN linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish.c 
linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish.c
--- linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish.c	1970-01-01 
01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish.c	2006-05-31 
11:55:51.492767729 +0200
@@ -0,0 +1,86 @@
+/*
+ * Glue Code for optimized x86_64 assembler version of TWOFISH
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+asmlinkage void twofish_enc_blk(void *ctx, u8 *dst, const u8 *src);
+
+asmlinkage void twofish_dec_blk(void *ctx, u8 *dst, const u8 *src);
+
+static struct crypto_alg alg = {
+	.cra_name           =   "twofish",
+	.cra_driver_name    =	"twofish-x86_64",
+	.cra_priority       =	200,
+	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize      =   TF_BLOCK_SIZE,
+	.cra_ctxsize        =   sizeof(struct twofish_ctx),
+	.cra_alignmask      =	3,
+	.cra_module         =   THIS_MODULE,
+	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
+	.cra_u              =   { .cipher = {
+	.cia_min_keysize    =   TF_MIN_KEY_SIZE,
+	.cia_max_keysize    =   TF_MAX_KEY_SIZE,
+	.cia_setkey         =   twofish_setkey,
+	.cia_encrypt        =   twofish_enc_blk,
+	.cia_decrypt        =   twofish_dec_blk } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION ("Twofish Cipher Algorithm, x86_64 asm optimized");
diff -uprN linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish-x86_64-asm.S 
linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish-x86_64-asm.S
--- linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish-x86_64-asm.S	
1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish-x86_64-asm.S	
2006-05-31 11:58:05.204726048 +0200
@@ -0,0 +1,400 @@
+	/***************************************************************************
+	*   Copyright (C) 2006 by Joachim Fritschi, &lt;jfritschi@freenet.de&gt;        *
+	*                                                                         *
+	*   This program is free software; you can redistribute it and/or modify  *
+	*   it under the terms of the GNU General Public License as published by  *
+	*   the Free Software Foundation; either version 2 of the License, or     *
+	*   (at your option) any later version.                                   *
+	*                                                                         *
+	*   This program is distributed in the hope that it will be useful,       *
+	*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+	*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+	*   GNU General Public License for more details.                          *
+	*                                                                         *
+	*   You should have received a copy of the GNU General Public License     *
+	*   along with this program; if not, write to the                         *
+	*   Free Software Foundation, Inc.,                                       *
+	*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+	***************************************************************************/
+
+.file "twofish-x86_64-asm.S"
+.text
+
+#define a_offset	0
+#define b_offset	4
+#define c_offset	8
+#define d_offset	12
+
+/* Structure of the crypto context struct*/
+
+#define s0	0	/* S0 Array 256 Words each */
+#define s1	1024	/* S1 Array */
+#define s2	2048	/* S2 Array */
+#define s3	3072	/* S3 Array */
+#define w	4096	/* 8 whitening keys (word) */
+#define k	4128	/* key 1-32 ( word ) */
+
+/* Defining a few register aliases for better reading */
+
+#define R0     %rax
+#define R0D    %eax
+#define R0W    %ax
+#define R0B    %al
+#define R0H    %ah
+
+#define R1     %rbx
+#define R1D    %ebx
+#define R1W    %bx
+#define R1B    %bl
+#define R1H    %bh
+
+#define R2     %rcx
+#define R2D    %ecx
+#define R2W    %cx
+#define R2B    %cl
+#define R2H    %ch
+
+#define R3     %rdx
+#define R3D    %edx
+#define R3W    %dx
+#define R3B    %dl
+#define R3H    %dh
+
+#define R4     %rsi
+#define R4D    %esi
+#define R4W    %six
+#define R4B    %sil
+
+#define R5     %rdi
+#define R5D    %edi
+#define R5W    %dix
+#define R5B    %dil
+
+#define R6     %rsp
+#define R6D    %esp
+#define R6W    %spx
+#define R6B    %spl
+
+#define R7     %rbp
+#define R7D    %ebp
+#define R7W    %bpx
+#define R7B    %bpl
+
+#define R8     %r8
+#define R8D    %r8d
+#define R8W    %r8w
+#define R8B    %r8b
+
+#define R9     %r9
+#define R9D    %r9d
+#define R9W    %r9w
+#define R9B    %r9b
+
+#define R10     %r10
+#define R10D    %r10d
+#define R10W    %r10w
+#define R10B    %r10b
+
+#define R11     %r11
+#define R11D    %r11d
+#define R11W    %r11w
+#define R11B    %r11b
+
+#define R12     %r12
+#define R12D    %r12d
+#define R12W    %r12w
+#define R12B    %r12b
+
+#define R13     %r13
+#define R13D    %r13d
+#define R13W    %r13w
+#define R13B    %r13b
+
+#define R14     %r14
+#define R14D    %r14d
+#define R14W    %r14w
+#define R14B    %r14b
+
+#define R15     %r15
+#define R15D    %r15d
+#define R15W    %r15w
+#define R15B    %r15b
+
+
+
+/* performs input whitening */
+#define input_whitening(src,context,offset)\
+	xor	w+offset(context), src;\
+
+/* performs input whitening */
+#define output_whitening(src,context,offset)\
+	xor	w+16+offset(context),src;\
+
+/* load sbox values */
+#define load_s(context,sbox,index,dst)\
+	xor	sbox(context,index,4),dst ## D;\
+
+/* load both round keys */
+#define load_round_key(dsta,dstb,context,round)\
+	mov	k+round(context),dsta ## D;\
+	mov	k+4+round(context),dstb ## D;
+
+
+#define encrypt_round(a,b,olda,oldb,newa,newb,ctx,round,tmp1,tmp2,key1,key2);
\
+	xor	tmp1,tmp1;\
+	load_round_key(key1,key2,ctx,round);\
+	movzx	a ## B,newa;\
+	movzx	a ## H,newb ## D;\
+	ror	$16,a ## D;\
+	load_s(ctx,s0,newa,tmp1);\
+	load_s(ctx,s1,newb,tmp1);\
+	movzx	a ## B,newa;\
+	movzx	a ## H,newb ## D;\
+	load_s(ctx,s2,newa,tmp1);\
+	load_s(ctx,s3,newb,tmp1);\
+	ror	$16,a ## D;\
+	xor	tmp2,tmp2;\
+	movzx	b ## B,newa;\
+	movzx	b ## H,newb ## D;\
+	ror	$16,b ## D;\
+	load_s(ctx,s1,newa,tmp2);\
+	load_s(ctx,s2,newb,tmp2);\
+	movzx	b ## B,newa;\
+	movzx	b ## H,newb ## D;\
+	load_s(ctx,s3,newa,tmp2);\
+	load_s(ctx,s0,newb,tmp2);\
+	ror	$15,b ## D;\
+	add	tmp2 ## D,tmp1 ## D;\
+	add	tmp1 ## D,tmp2 ## D;\
+	add	tmp1 ## D,key1 ## D;\
+	add	tmp2 ## D,key2 ## D;\
+	mov	olda  ## D,newa ## D;\
+	mov	oldb ## D,newb ## D;\
+	mov	a ## D,olda ## D;\
+	mov	b ## D,oldb ## D;\
+	xor	key1 ## D,newa ## D;\
+	xor	key2 ## D,newb ## D;\
+	ror	$1,newa ## D
+
+/* Last Round can ignore saving a,b for the next round */
+
+#define 
encrypt_last_round(a,b,olda,oldb,newa,newb,ctx,round,tmp1,tmp2,key1,key2);\
+	xor	tmp1,tmp1;\
+	load_round_key(key1,key2,ctx,round);\
+	movzx	a ## B,newa;\
+	movzx	a ## H,newb ## D;\
+	ror	$16,a ## D;\
+	load_s(ctx,s0,newa,tmp1);\
+	load_s(ctx,s1,newb,tmp1);\
+	movzx	a ## B,newa;\
+	movzx	a ## H,newb ## D;\
+	load_s(ctx,s2,newa,tmp1);\
+	load_s(ctx,s3,newb,tmp1);\
+	xor	tmp2,tmp2;\
+	movzx	b ## B,newa;\
+	movzx	b ## H,newb ## D;\
+	ror	$16,b ## D;\
+	load_s(ctx,s1,newa,tmp2);\
+	load_s(ctx,s2,newb,tmp2);\
+	movzx	b ## B,newa;\
+	movzx	b ## H,newb ## D;\
+	load_s(ctx,s3,newa,tmp2);\
+	load_s(ctx,s0,newb,tmp2);\
+	add	tmp2 ## D,tmp1 ## D;\
+	add	tmp1 ## D,tmp2 ## D;\
+	add	tmp1 ## D,key1 ## D;\
+	add	tmp2 ## D,key2 ## D;\
+	mov	olda  ## D,newa ## D;\
+	mov	oldb ## D,newb ## D;\
+	xor	key1 ## D,newa ## D;\
+	xor	key2 ## D,newb ## D;\
+	ror	$1,newa ## D
+
+#define decrypt_round(a,b,olda,oldb,newa,newb,ctx,round,tmp1,tmp2,key1,key2);
\
+	xor	tmp1,tmp1;\
+	load_round_key(key1,key2,ctx,round);\
+	movzx	a ## B,newa;\
+	movzx	a ## H,newb ## D;\
+	ror	$16,a ## D;\
+	load_s(ctx,s0,newa,tmp1);\
+	load_s(ctx,s1,newb,tmp1);\
+	movzx	a ## B,newa;\
+	movzx	a ## H,newb ## D;\
+	load_s(ctx,s2,newa,tmp1);\
+	load_s(ctx,s3,newb,tmp1);\
+	ror	$15,a ## D;\
+	xor	tmp2,tmp2;\
+	movzx	b ## B,newa;\
+	movzx	b ## H,newb ## D;\
+	ror	$16,b ## D;\
+	load_s(ctx,s1,newa,tmp2);\
+	load_s(ctx,s2,newb,tmp2);\
+	movzx	b ## B,newa;\
+	movzx	b ## H,newb ## D;\
+	load_s(ctx,s3,newa,tmp2);\
+	load_s(ctx,s0,newb,tmp2);\
+	ror	$16,b ## D;\
+	add	tmp2 ## D,tmp1 ## D;\
+	add	tmp1 ## D,tmp2 ## D;\
+	add	tmp1 ## D,key1 ## D;\
+	add	tmp2 ## D,key2 ## D;\
+	mov	olda  ## D,newa ## D;\
+	mov	oldb ## D,newb ## D;\
+	mov	a ## D,olda ## D;\
+	mov	b ## D,oldb ## D;\
+	xor	key1 ## D,newa ## D;\
+	xor	key2 ## D,newb ## D;\
+	ror	$1,newb ## D
+
+/* Last Round can ignore saving a,b for the next round */
+
+#define 
decrypt_last_round(a,b,olda,oldb,newa,newb,ctx,round,tmp1,tmp2,key1,key2);\
+	xor	tmp1,tmp1;\
+	load_round_key(key1,key2,ctx,round);\
+	movzx	a ## B,newa;\
+	movzx	a ## H,newb ## D;\
+	ror	$16,a ## D;\
+	load_s(ctx,s0,newa,tmp1);\
+	load_s(ctx,s1,newb,tmp1);\
+	movzx	a ## B,newa;\
+	movzx	a ## H,newb ## D;\
+	load_s(ctx,s2,newa,tmp1);\
+	load_s(ctx,s3,newb,tmp1);\
+	xor	tmp2,tmp2;\
+	movzx	b ## B,newa;\
+	movzx	b ## H,newb ## D;\
+	ror	$16,b ## D;\
+	load_s(ctx,s1,newa,tmp2);\
+	load_s(ctx,s2,newb,tmp2);\
+	movzx	b ## B,newa;\
+	movzx	b ## H,newb ## D;\
+	load_s(ctx,s3,newa,tmp2);\
+	load_s(ctx,s0,newb,tmp2);\
+	add	tmp2 ## D,tmp1 ## D;\
+	add	tmp1 ## D,tmp2 ## D;\
+	add	tmp1 ## D,key1 ## D;\
+	add	tmp2 ## D,key2 ## D;\
+	mov	olda  ## D,newa ## D;\
+	mov	oldb ## D,newb ## D;\
+	xor	key1 ## D,newa ## D;\
+	xor	key2 ## D,newb ## D;\
+	ror	$1,newb ## D
+
+
+
+
+.align 8
+.global twofish_enc_blk
+.global twofish_dec_blk
+
+
+
+twofish_enc_blk:
+	pushq    R1
+	pushq	 R12
+	pushq	 R13
+
+	/* r5 contains the crypto ctx adress */
+	/* r4 contains the output adress */
+	/* r3 contains the input adress */
+
+	movq	(R3),R1
+	movq	8(R3),R9
+	input_whitening(R1,R5,a_offset)
+	input_whitening(R9,R5,c_offset)
+	mov	R1D,R0D
+	shr	$32,R1
+	mov	R9D,R8D
+	shr	$32,R9
+	rol	$1,R9D
+
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,0,R10,R11,R12,R13);
+	encrypt_round(R2,R3,R8,R9,R0,R1,R5,8,R10,R11,R12,R13);
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,2*8,R10,R11,R12,R13);
+	encrypt_round(R2,R3,R8,R9,R0,R1,R5,3*8,R10,R11,R12,R13);
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,4*8,R10,R11,R12,R13);
+	encrypt_round(R2,R3,R8,R9,R0,R1,R5,5*8,R10,R11,R12,R13);
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,6*8,R10,R11,R12,R13);
+	encrypt_round(R2,R3,R8,R9,R0,R1,R5,7*8,R10,R11,R12,R13);
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,8*8,R10,R11,R12,R13);
+	encrypt_round(R2,R3,R8,R9,R0,R1,R5,9*8,R10,R11,R12,R13);
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,10*8,R10,R11,R12,R13);
+	encrypt_round(R2,R3,R8,R9,R0,R1,R5,11*8,R10,R11,R12,R13);
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,12*8,R10,R11,R12,R13);
+	encrypt_round(R2,R3,R8,R9,R0,R1,R5,13*8,R10,R11,R12,R13);
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,14*8,R10,R11,R12,R13);
+
+	mov	R3,R13
+	shl	$32,R13
+	xor	R2,R13
+	output_whitening(R13,R5,a_offset)
+	movq	R13,(R4)
+
+	encrypt_last_round(R2,R3,R8,R9,R0,R1,R5,15*8,R10,R11,R12,R13);
+
+
+	shl	$32,R1
+	xor	R0,R1
+
+	output_whitening(R1,R5,c_offset)
+	movq	R1,8(R4)
+
+	popq	R13
+	popq	R12
+	popq	R1
+	movq	$1,%rax
+	ret
+
+twofish_dec_blk:
+	pushq    R1
+	pushq	 R12
+	pushq	 R13
+
+	/* r5 contains the crypto ctx adress */
+	/* r4 contains the output adress */
+	/* r3 contains the input adress */
+
+	movq	(R3),R1
+	movq	8(R3),R9
+	output_whitening(R1,R5,a_offset)
+	output_whitening(R9,R5,c_offset)
+	mov	R1D,R0D
+	shr	$32,R1
+	mov	R9D,R8D
+	shr	$32,R9
+	rol	$1,R8D
+
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,15*8,R10,R11,R12,R13);
+	decrypt_round(R2,R3,R8,R9,R0,R1,R5,14*8,R10,R11,R12,R13);
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,13*8,R10,R11,R12,R13);
+	decrypt_round(R2,R3,R8,R9,R0,R1,R5,12*8,R10,R11,R12,R13);
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,11*8,R10,R11,R12,R13);
+	decrypt_round(R2,R3,R8,R9,R0,R1,R5,10*8,R10,R11,R12,R13);
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,9*8,R10,R11,R12,R13);
+	decrypt_round(R2,R3,R8,R9,R0,R1,R5,8*8,R10,R11,R12,R13);
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,7*8,R10,R11,R12,R13);
+	decrypt_round(R2,R3,R8,R9,R0,R1,R5,6*8,R10,R11,R12,R13);
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,5*8,R10,R11,R12,R13);
+	decrypt_round(R2,R3,R8,R9,R0,R1,R5,4*8,R10,R11,R12,R13);
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,3*8,R10,R11,R12,R13);
+	decrypt_round(R2,R3,R8,R9,R0,R1,R5,2*8,R10,R11,R12,R13);
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,8,R10,R11,R12,R13);
+
+	mov	R3,R13
+	shl	$32,R13
+	xor	R2,R13
+	input_whitening(R13,R5,a_offset)
+	movq	R13,(R4)
+
+	decrypt_last_round(R2,R3,R8,R9,R0,R1,R5,0,R10,R11,R12,R13);
+
+	shl	$32,R1
+	xor	R0,R1
+	input_whitening(R1,R5,c_offset)
+	movq	R1,8(R4)
+
+	popq	R13
+	popq	R12
+	popq	R1
+	movq	$1,%rax
+	ret
diff -uprN linux-2.6.17-rc5.twofish3/crypto/Kconfig 
linux-2.6.17-rc5.twofish4/crypto/Kconfig
--- linux-2.6.17-rc5.twofish3/crypto/Kconfig	2006-05-30 20:00:47.841035197 
+0200
+++ linux-2.6.17-rc5.twofish4/crypto/Kconfig	2006-05-31 11:52:43.234447029 
+0200
@@ -156,6 +156,20 @@ config CRYPTO_TWOFISH_586
 	  See also:
 	  &lt;http://www.schneier.com/twofish.html&gt;

+config CRYPTO_TWOFISH_X86_64
+        tristate "Twofish cipher algorithm (x86_64)"
+        depends on CRYPTO &amp;&amp; ((X86 || UML_X86) &amp;&amp; 64BIT)
+        help
+          Twofish cipher algorithm (x86_64).
+
+          Twofish was submitted as an AES (Advanced Encryption Standard)
+          candidate cipher by researchers at CounterPane Systems.  It is a
+          16 round block cipher supporting key sizes of 128, 192, and 256
+          bits.
+
+          See also:
+          &lt;http://www.schneier.com/twofish.html&gt;
+
 config CRYPTO_SERPENT
 	tristate "Serpent cipher algorithm"
 	depends on CRYPTO
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060604191014</emailId><senderName>Andi Kleen</senderName><senderEmail>ak@suse.de</senderEmail><timestampReceived>2006-06-04 19:10:14-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

On Sunday 04 June 2006 15:16, Joachim Fritschi wrote:
&gt; This patch adds the twofish x86_64 assembler routine.
&gt;
&gt; Changes since last version:
&gt; - The keysetup is now handled by the twofish_common.c (see patch 1 )
&gt; - The last round of the encrypt/decrypt routines where optimized saving 5
&gt; instructions.
&gt;
&gt; Correctness was verified with the tcrypt module and automated test scripts.

Do you have some benchmark numbers that show that it's actually worth
it?

&gt; +/* Defining a few register aliases for better reading */

Maybe you can read it now better, but for everybody else it is extremly 
confusing. It would be better if you just used the original register names.

-andi
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060604210103</emailId><senderName>Dag Arne Osvik</senderName><senderEmail>da@osvik.no</senderEmail><timestampReceived>2006-06-04 21:01:03-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

Andi Kleen wrote:
&gt; On Sunday 04 June 2006 15:16, Joachim Fritschi wrote:
&gt;&gt; This patch adds the twofish x86_64 assembler routine.

&gt;&gt; +/* Defining a few register aliases for better reading */
&gt; 
&gt; Maybe you can read it now better, but for everybody else it is extremly 
&gt; confusing. It would be better if you just used the original register names.

I'd agree if you said this code could benefit from further readability
improvements.  But you're arguing against one.

Too bad AMD kept the old register names when defining AMD64..

-- 
  Dag Arne
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060605233526</emailId><senderName>Andi Kleen</senderName><senderEmail>ak@suse.de</senderEmail><timestampReceived>2006-06-05 23:35:26-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

On Monday 05 June 2006 12:06, Joachim Fritschi wrote:
&gt; On Sunday 04 June 2006 21:10, Andi Kleen wrote:
&gt; &gt; On Sunday 04 June 2006 15:16, Joachim Fritschi wrote:
&gt; &gt; &gt; This patch adds the twofish x86_64 assembler routine.
&gt; &gt; &gt;
&gt; &gt; &gt; Changes since last version:
&gt; &gt; &gt; - The keysetup is now handled by the twofish_common.c (see patch 1 )
&gt; &gt; &gt; - The last round of the encrypt/decrypt routines where optimized saving 5
&gt; &gt; &gt; instructions.
&gt; &gt; &gt;
&gt; &gt; &gt; Correctness was verified with the tcrypt module and automated test
&gt; &gt; &gt; scripts.
&gt; &gt;
&gt; &gt; Do you have some benchmark numbers that show that it's actually worth
&gt; &gt; it?
&gt; 
&gt; Here are the outputs from the tcrypt speedtests. They haven't changed much 
&gt; since the last patch:

Ok thanks. I've tried to apply the patches, but can't because they're
word wrapped. Can you please resend and do a test send to yourself first,
checking that the patch can be really applied.


&gt; There might be some way to further improve readability but i have not found 
&gt; any other way. I'm open to suggestions :)


Sounds reasonable. Best you just fix the comment to say that this convention is needed 
for the macros.

-Andi
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060607191630</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-07 19:16:30-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

On Tuesday 06 June 2006 00:28, Dag Arne Osvik wrote:
&gt; Joachim Fritschi wrote:
&gt; &gt; Can you give me any hint what to improve or maybe provide a suggestion on how 
&gt; &gt; to improve the overall readabilty.
&gt; 
&gt; It looks better on second reading, but I have some comments:
&gt; 
&gt; Remove load_s - it's needless and (slightly) confusing
Done
&gt; There are some cases of missing ## D
Oops, fixed.
&gt; Why semicolon after closing parenthesis in macro definitions?
Braindamage on my part.
&gt; Try to align operands in columns
Done
&gt; It would be nice to have some explanation of macro parameter names
Done for the non trivial stuff
&gt; Btw, why do you keep zeroing tmp registers when you don't need to?
&gt; 32-bit ops zero the top half of the destination register.
Again braindamage :). Fixed it according to your suggestions.

Thanks for the comments. Will post a new patches in a few minutes.

-Joachim

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060607192111</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-07 19:21:11-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

On Tuesday 06 June 2006 01:35, Andi Kleen wrote:
&gt; On Monday 05 June 2006 12:06, Joachim Fritschi wrote:
&gt; &gt; On Sunday 04 June 2006 21:10, Andi Kleen wrote:
&gt; &gt; &gt; On Sunday 04 June 2006 15:16, Joachim Fritschi wrote:
&gt; &gt; &gt; &gt; This patch adds the twofish x86_64 assembler routine.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Changes since last version:
&gt; &gt; &gt; &gt; - The keysetup is now handled by the twofish_common.c (see patch 1 )
&gt; &gt; &gt; &gt; - The last round of the encrypt/decrypt routines where optimized saving 5
&gt; &gt; &gt; &gt; instructions.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Correctness was verified with the tcrypt module and automated test
&gt; &gt; &gt; &gt; scripts.
&gt; &gt; &gt;
&gt; &gt; &gt; Do you have some benchmark numbers that show that it's actually worth
&gt; &gt; &gt; it?
&gt; &gt; 
&gt; &gt; Here are the outputs from the tcrypt speedtests. They haven't changed much 
&gt; &gt; since the last patch:
&gt; 
&gt; Ok thanks. I've tried to apply the patches, but can't because they're
&gt; word wrapped. Can you please resend and do a test send to yourself first,
&gt; checking that the patch can be really applied.

Sorry i will send new patches, also including the fixes that were suggested by Dag.

-Joachim

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060607193829</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-07 19:38:29-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

On Sunday 04 June 2006 15:16, Joachim Fritschi wrote:
&gt; This patch adds the twofish x86_64 assembler routine. 
&gt; 
&gt; Changes since last version:
&gt; - The keysetup is now handled by the twofish_common.c (see patch 1 )
&gt; - The last round of the encrypt/decrypt routines where optimized saving 5 
&gt; instructions. 
&gt; 
&gt; Correctness was verified with the tcrypt module and automated test scripts.
My first mail was wordwrapped. This one should be unwrapped and working.
It also includes some readability fixes, additional comments and a little code \
cleanup.

Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

diff -uprN linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/Makefile \
                linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/Makefile
--- linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/Makefile	2006-05-30 \
                19:58:05.172677025 +0200
+++ linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/Makefile	2006-05-31 \
11:56:48.239053258 +0200 @@ -5,5 +5,8 @@
 #

 obj-$(CONFIG_CRYPTO_AES_X86_64) += aes-x86_64.o
+obj-$(CONFIG_CRYPTO_TWOFISH_X86_64) += twofish-x86_64.o

 aes-x86_64-y := aes-x86_64-asm.o aes.o
+twofish-x86_64-y := twofish-x86_64-asm.o twofish.o ../../../crypto/twofish_common.o
+
diff -uprN linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish.c \
                linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish.c
--- linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish.c	1970-01-01 \
                01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish.c	2006-05-31 \
11:55:51.492767729 +0200 @@ -0,0 +1,86 @@
+/*
+ * Glue Code for optimized x86_64 assembler version of TWOFISH
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+asmlinkage void twofish_enc_blk(void *ctx, u8 *dst, const u8 *src);
+
+asmlinkage void twofish_dec_blk(void *ctx, u8 *dst, const u8 *src);
+
+static struct crypto_alg alg = {
+	.cra_name           =   "twofish",
+	.cra_driver_name    =	"twofish-x86_64",
+	.cra_priority       =	200,
+	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize      =   TF_BLOCK_SIZE,
+	.cra_ctxsize        =   sizeof(struct twofish_ctx),
+	.cra_alignmask      =	3,
+	.cra_module         =   THIS_MODULE,
+	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
+	.cra_u              =   { .cipher = {
+	.cia_min_keysize    =   TF_MIN_KEY_SIZE,
+	.cia_max_keysize    =   TF_MAX_KEY_SIZE,
+	.cia_setkey         =   twofish_setkey,
+	.cia_encrypt        =   twofish_enc_blk,
+	.cia_decrypt        =   twofish_dec_blk } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION ("Twofish Cipher Algorithm, x86_64 asm optimized");
diff -uprN linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish-x86_64-asm.S \
                linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish-x86_64-asm.S
--- linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish-x86_64-asm.S	1970-01-01 \
                01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish-x86_64-asm.S	2006-06-06 \
10:19:11.462630535 +0200 @@ -0,0 +1,406 @@
+/***************************************************************************
+*   Copyright (C) 2006 by Joachim Fritschi, &lt;jfritschi@freenet.de&gt;        *
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+*   This program is distributed in the hope that it will be useful,       *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+*   GNU General Public License for more details.                          *
+*                                                                         *
+*   You should have received a copy of the GNU General Public License     *
+*   along with this program; if not, write to the                         *
+*   Free Software Foundation, Inc.,                                       *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+***************************************************************************/
+
+.file "twofish-x86_64-asm.S"
+.text
+
+#define a_offset	0
+#define b_offset	4
+#define c_offset	8
+#define d_offset	12
+
+/* Structure of the crypto context struct*/
+
+#define s0	0	/* S0 Array 256 Words each */
+#define s1	1024	/* S1 Array */
+#define s2	2048	/* S2 Array */
+#define s3	3072	/* S3 Array */
+#define w	4096	/* 8 whitening keys (word) */
+#define k	4128	/* key 1-32 ( word ) */
+
+/* define a few register aliases to allow macro substitution */
+
+#define R0     %rax
+#define R0D    %eax
+#define R0W    %ax
+#define R0B    %al
+#define R0H    %ah
+
+#define R1     %rbx
+#define R1D    %ebx
+#define R1W    %bx
+#define R1B    %bl
+#define R1H    %bh
+
+#define R2     %rcx
+#define R2D    %ecx
+#define R2W    %cx
+#define R2B    %cl
+#define R2H    %ch
+
+#define R3     %rdx
+#define R3D    %edx
+#define R3W    %dx
+#define R3B    %dl
+#define R3H    %dh
+
+#define R4     %rsi
+#define R4D    %esi
+#define R4W    %six
+#define R4B    %sil
+
+#define R5     %rdi
+#define R5D    %edi
+#define R5W    %dix
+#define R5B    %dil
+
+#define R6     %rsp
+#define R6D    %esp
+#define R6W    %spx
+#define R6B    %spl
+
+#define R7     %rbp
+#define R7D    %ebp
+#define R7W    %bpx
+#define R7B    %bpl
+
+#define R8     %r8
+#define R8D    %r8d
+#define R8W    %r8w
+#define R8B    %r8b
+
+#define R9     %r9
+#define R9D    %r9d
+#define R9W    %r9w
+#define R9B    %r9b
+
+#define R10     %r10
+#define R10D    %r10d
+#define R10W    %r10w
+#define R10B    %r10b
+
+#define R11     %r11
+#define R11D    %r11d
+#define R11W    %r11w
+#define R11B    %r11b
+
+#define R12     %r12
+#define R12D    %r12d
+#define R12W    %r12w
+#define R12B    %r12b
+
+#define R13     %r13
+#define R13D    %r13d
+#define R13W    %r13w
+#define R13B    %r13b
+
+#define R14     %r14
+#define R14D    %r14d
+#define R14W    %r14w
+#define R14B    %r14b
+
+#define R15     %r15
+#define R15D    %r15d
+#define R15W    %r15w
+#define R15B    %r15b
+
+
+
+/* performs input whitening */
+#define input_whitening(src,context,offset)\
+	xor	w+offset(context),	src;
+
+/* performs input whitening */
+#define output_whitening(src,context,offset)\
+	xor	w+16+offset(context),	src;
+
+/* load both round keys */
+#define load_round_key(dsta,dstb,context,round)\
+	mov	k+round(context),	dsta ## D;\
+	mov	k+4+round(context),	dstb ## D;
+
+/* Parameters for all encrypt/decrypt macros:
+a input register containing a
+b input register containing a
+olda register containing the a input of the last round
+oldb register containing the b input of the last round
+newa output register for a
+newb output register for b
+ctx  register cotaining the adress of the crypto context
+round roundoffset for loading the roundkeys
+tmp1 temporary register
+tmp2 temporary register
+key1 register for storing the a roundkey
+key2 register for storing the b roundkey
+*/
+
+#define\
+ encrypt_round(a,b,olda,oldb,newa,newb,ctx,round,tmp1,tmp2,key1,key2)\
+	load_round_key(key1,key2,ctx,round);\
+	movzx	a ## B,		newa ## D;\
+	movzx	a ## H,		newb ## D;\
+	ror	$16,		a ## D;\
+	mov	s0(ctx,newa,4),	tmp1 ## D;\
+	xor     s1(ctx,newb,4),	tmp1 ## D;\
+	movzx	a ## B,		newa ## D;\
+	movzx	a ## H,		newb ## D;\
+	xor     s2(ctx,newa,4),	tmp1 ## D;\
+	xor     s3(ctx,newb,4),	tmp1 ## D;\
+	ror	$16,		a ## D;\
+	movzx	b ## B,		newa ## D;\
+	movzx	b ## H,		newb ## D;\
+	ror	$16,		b ## D;\
+	mov     s1(ctx,newa,4),	tmp2 ## D;\
+	xor	s2(ctx,newb,4),	tmp2 ## D;\
+	movzx	b ## B,		newa ## D;\
+	movzx	b ## H,		newb ## D;\
+	xor	s3(ctx,newa,4),	tmp2 ## D;\
+	xor     s0(ctx,newb,4),	tmp2 ## D;\
+	ror	$15,		b ## D;\
+	add	tmp2 ## D,	tmp1 ## D;\
+	add	tmp1 ## D,	tmp2 ## D;\
+	add	tmp1 ## D,	key1 ## D;\
+	add	tmp2 ## D,	key2 ## D;\
+	mov	olda  ## D,	newa ## D;\
+	mov	oldb ## D,	newb ## D;\
+	mov	a ## D,		olda ## D;\
+	mov	b ## D,		oldb ## D;\
+	xor	key1 ## D,	newa ## D;\
+	xor	key2 ## D,	newb ## D;\
+	ror	$1,		newa ## D
+
+/* Last Round can ignore saving a,b for the next round */
+
+#define\
+ encrypt_last_round(a,b,olda,oldb,newa,newb,ctx,round,tmp1,tmp2,key1,key2)\
+	load_round_key(key1,key2,ctx,round);\
+	movzx	a ## B,		newa ## D;\
+	movzx	a ## H,		newb ## D;\
+	ror	$16,		a ## D;\
+	mov	s0(ctx,newa,4),	tmp1 ## D;\
+	xor     s1(ctx,newb,4),	tmp1 ## D;\
+	movzx	a ## B,		newa ## D;\
+	movzx	a ## H,		newb ## D;\
+	xor     s2(ctx,newa,4), tmp1 ## D;\
+	xor     s3(ctx,newb,4), tmp1 ## D;\
+	movzx	b ## B,		newa ## D;\
+	movzx	b ## H,		newb ## D;\
+	ror	$16,		b ## D;\
+	mov     s1(ctx,newa,4),	tmp2 ## D;\
+	xor	s2(ctx,newb,4),	tmp2 ## D;\
+	movzx	b ## B,		newa ## D;\
+	movzx	b ## H,		newb ## D;\
+	xor	s3(ctx,newa,4),	tmp2 ## D;\
+	xor     s0(ctx,newb,4),	tmp2 ## D;\
+	add	tmp2 ## D,	tmp1 ## D;\
+	add	tmp1 ## D,	tmp2 ## D;\
+	add	tmp1 ## D,	key1 ## D;\
+	add	tmp2 ## D,	key2 ## D;\
+	mov	olda  ## D,	newa ## D;\
+	mov	oldb ## D,	newb ## D;\
+	xor	key1 ## D,	newa ## D;\
+	xor	key2 ## D,	newb ## D;\
+	ror	$1,		newa ## D
+
+#define\
+ decrypt_round(a,b,olda,oldb,newa,newb,ctx,round,tmp1,tmp2,key1,key2)\
+	load_round_key(key1,key2,ctx,round);\
+	movzx	a ## B,		newa ## D;\
+	movzx	a ## H,		newb ## D;\
+	ror	$16,		a ## D;\
+	mov	s0(ctx,newa,4),	tmp1 ## D;\
+	xor	s1(ctx,newb,4),	tmp1 ## D;\
+	movzx	a ## B,		newa;\
+	movzx	a ## H,		newb ## D;\
+	xor	s2(ctx,newa,4),	tmp1 ## D;\
+	xor	s3(ctx,newb,4),	tmp1 ## D;\
+	ror	$15,		a ## D;\
+	movzx	b ## B,		newa ## D;\
+	movzx	b ## H,		newb ## D;\
+	ror	$16,		b ## D;\
+	mov	s1(ctx,newa,4),	tmp2 ## D;\
+	xor	s2(ctx,newb,4),	tmp2 ## D;\
+	movzx	b ## B,		newa ## D;\
+	movzx	b ## H,		newb ## D;\
+	xor	s3(ctx,newa,4),	tmp2 ## D;\
+	xor	s0(ctx,newb,4),	tmp2 ## D;\
+	ror	$16,		b ## D;\
+	add	tmp2 ## D,	tmp1 ## D;\
+	add	tmp1 ## D,	tmp2 ## D;\
+	add	tmp1 ## D,	key1 ## D;\
+	add	tmp2 ## D,	key2 ## D;\
+	mov	olda  ## D,	newa ## D;\
+	mov	oldb ## D,	newb ## D;\
+	mov	a ## D,		olda ## D;\
+	mov	b ## D,		oldb ## D;\
+	xor	key1 ## D,	newa ## D;\
+	xor	key2 ## D,	newb ## D;\
+	ror	$1,		newb ## D
+
+/* Last Round can ignore saving a,b for the next round */
+
+#define\
+ decrypt_last_round(a,b,olda,oldb,newa,newb,ctx,round,tmp1,tmp2,key1,key2)\
+	load_round_key(key1,key2,ctx,round);\
+	movzx	a ## B,		newa ## D;\
+	movzx	a ## H,		newb ## D;\
+	ror	$16,		a ## D;\
+	mov	s0(ctx,newa,4),	tmp1 ## D;\
+	xor	s1(ctx,newb,4),	tmp1 ## D;\
+	movzx	a ## B,		newa ## D;\
+	movzx	a ## H,		newb ## D;\
+	xor	s2(ctx,newa,4),	tmp1 ## D;\
+	xor	s3(ctx,newb,4),	tmp1 ## D;\
+	movzx	b ## B,		newa;\
+	movzx	b ## H,		newb ## D;\
+	ror	$16,b 		## D;\
+	mov	s1(ctx,newa,4),	tmp2 ## D;\
+	xor	s2(ctx,newb,4),	tmp2 ## D;\
+	movzx	b ## B,		newa ## D;\
+	movzx	b ## H,		newb ## D;\
+	xor	s3(ctx,newa,4),	tmp2 ## D;\
+	xor	s0(ctx,newb,4),	tmp2 ## D;\
+	add	tmp2 ## D,	tmp1 ## D;\
+	add	tmp1 ## D,	tmp2 ## D;\
+	add	tmp1 ## D,	key1 ## D;\
+	add	tmp2 ## D,	key2 ## D;\
+	mov	olda  ## D,	newa ## D;\
+	mov	oldb ## D,	newb ## D;\
+	xor	key1 ## D,	newa ## D;\
+	xor	key2 ## D,	newb ## D;\
+	ror	$1,		newb ## D
+
+
+
+
+.align 8
+.global twofish_enc_blk
+.global twofish_dec_blk
+
+
+
+twofish_enc_blk:
+	pushq    R1
+	pushq	 R12
+	pushq	 R13
+
+	/* r5 contains the crypto ctx adress */
+	/* r4 contains the output adress */
+	/* r3 contains the input adress */
+
+	movq	(R3),	R1
+	movq	8(R3),	R9
+	input_whitening(R1,R5,a_offset)
+	input_whitening(R9,R5,c_offset)
+	mov	R1D,	R0D
+	shr	$32,	R1
+	mov	R9D,	R8D
+	shr	$32,	R9
+	rol	$1,	R9D
+
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,0,R10,R11,R12,R13);
+	encrypt_round(R2,R3,R8,R9,R0,R1,R5,8,R10,R11,R12,R13);
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,2*8,R10,R11,R12,R13);
+	encrypt_round(R2,R3,R8,R9,R0,R1,R5,3*8,R10,R11,R12,R13);
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,4*8,R10,R11,R12,R13);
+	encrypt_round(R2,R3,R8,R9,R0,R1,R5,5*8,R10,R11,R12,R13);
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,6*8,R10,R11,R12,R13);
+	encrypt_round(R2,R3,R8,R9,R0,R1,R5,7*8,R10,R11,R12,R13);
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,8*8,R10,R11,R12,R13);
+	encrypt_round(R2,R3,R8,R9,R0,R1,R5,9*8,R10,R11,R12,R13);
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,10*8,R10,R11,R12,R13);
+	encrypt_round(R2,R3,R8,R9,R0,R1,R5,11*8,R10,R11,R12,R13);
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,12*8,R10,R11,R12,R13);
+	encrypt_round(R2,R3,R8,R9,R0,R1,R5,13*8,R10,R11,R12,R13);
+	encrypt_round(R0,R1,R8,R9,R2,R3,R5,14*8,R10,R11,R12,R13);
+
+	mov	R3,	R13
+	shl	$32,	R13
+	xor	R2,	R13
+	output_whitening(R13,R5,a_offset)
+	movq	R13,	(R4)
+
+	encrypt_last_round(R2,R3,R8,R9,R0,R1,R5,15*8,R10,R11,R12,R13);
+
+
+	shl	$32,	R1
+	xor	R0,	R1
+
+	output_whitening(R1,R5,c_offset)
+	movq	R1,	8(R4)
+
+	popq	R13
+	popq	R12
+	popq	R1
+	movq	$1,%rax
+	ret
+
+twofish_dec_blk:
+	pushq    R1
+	pushq	 R12
+	pushq	 R13
+
+	/* r5 contains the crypto ctx adress */
+	/* r4 contains the output adress */
+	/* r3 contains the input adress */
+
+	movq	(R3),	R1
+	movq	8(R3),	R9
+	output_whitening(R1,R5,a_offset)
+	output_whitening(R9,R5,c_offset)
+	mov	R1D,	R0D
+	shr	$32,	R1
+	mov	R9D,	R8D
+	shr	$32,	R9
+	rol	$1,	R8D
+
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,15*8,R10,R11,R12,R13);
+	decrypt_round(R2,R3,R8,R9,R0,R1,R5,14*8,R10,R11,R12,R13);
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,13*8,R10,R11,R12,R13);
+	decrypt_round(R2,R3,R8,R9,R0,R1,R5,12*8,R10,R11,R12,R13);
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,11*8,R10,R11,R12,R13);
+	decrypt_round(R2,R3,R8,R9,R0,R1,R5,10*8,R10,R11,R12,R13);
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,9*8,R10,R11,R12,R13);
+	decrypt_round(R2,R3,R8,R9,R0,R1,R5,8*8,R10,R11,R12,R13);
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,7*8,R10,R11,R12,R13);
+	decrypt_round(R2,R3,R8,R9,R0,R1,R5,6*8,R10,R11,R12,R13);
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,5*8,R10,R11,R12,R13);
+	decrypt_round(R2,R3,R8,R9,R0,R1,R5,4*8,R10,R11,R12,R13);
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,3*8,R10,R11,R12,R13);
+	decrypt_round(R2,R3,R8,R9,R0,R1,R5,2*8,R10,R11,R12,R13);
+	decrypt_round(R0,R1,R8,R9,R2,R3,R5,8,R10,R11,R12,R13);
+
+	mov	R3,	R13
+	shl	$32,	R13
+	xor	R2,	R13
+	input_whitening(R13,R5,a_offset)
+	movq	R13,	(R4)
+
+	decrypt_last_round(R2,R3,R8,R9,R0,R1,R5,0,R10,R11,R12,R13);
+
+	shl	$32,	R1
+	xor	R0,	R1
+	input_whitening(R1,R5,c_offset)
+	movq	R1,	8(R4)
+
+	popq	R13
+	popq	R12
+	popq	R1
+	movq	$1,	%rax
+	ret
diff -uprN linux-2.6.17-rc5.twofish3/crypto/Kconfig \
                linux-2.6.17-rc5.twofish4/crypto/Kconfig
--- linux-2.6.17-rc5.twofish3/crypto/Kconfig	2006-05-30 20:00:47.841035197 +0200
+++ linux-2.6.17-rc5.twofish4/crypto/Kconfig	2006-05-31 11:52:43.234447029 +0200
@@ -156,6 +156,20 @@ config CRYPTO_TWOFISH_586
 	  See also:
 	  &lt;http://www.schneier.com/twofish.html&gt;

+config CRYPTO_TWOFISH_X86_64
+        tristate "Twofish cipher algorithm (x86_64)"
+        depends on CRYPTO &amp;&amp; ((X86 || UML_X86) &amp;&amp; 64BIT)
+        help
+          Twofish cipher algorithm (x86_64).
+
+          Twofish was submitted as an AES (Advanced Encryption Standard)
+          candidate cipher by researchers at CounterPane Systems.  It is a
+          16 round block cipher supporting key sizes of 128, 192, and 256
+          bits.
+
+          See also:
+          &lt;http://www.schneier.com/twofish.html&gt;
+
 config CRYPTO_SERPENT
 	tristate "Serpent cipher algorithm"
 	depends on CRYPTO
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


</body></email><email><emailId>20060616120014</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-16 12:00:14-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

Update patch for the x86_64 twofish assembler implementation.

Changes since last version:
-Updated to the new twofish_common setup
-Complete rewrite of the code according to the feedback i recieved 
(thanks linux@horizon.com)

The patch passed the trycpt tests and automated filesystem tests.
This rewrite resulted in some nice perfomance increase over my last patch.

Short summary of the tcrypt benchmarks:

Twofish Assembler vs. Twofish C (256bit 8kb block CBC)
encrypt: -27% Cycles
decrypt: -23% Cycles

Twofish Assembler vs. AES Assembler (128bit 8kb block CBC)
encrypt: +18%  Cycles
decrypt: +15% Cycles

Twofish Assembler vs. AES Assembler (256bit 8kb block CBC)
encrypt: -9% Cycles
decrypt: -8% Cycles

Full Output:
http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-twofish-c-x86_64.txt
http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-twofish-asm-x86_64.txt
 http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-aes-asm-x86_64.txt


Here is another bonnie++ benchmark with encrypted filesystems. Most runs maxed
out the hd. It should give some idea what the module can do for encrypted filesystem
performance even though you can't see the full numbers.

http://homepages.tu-darmstadt.de/~fritschi/twofish/output_20060610_130806_x86_64.html


Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

diff -uprN linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/Makefile \
                linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/Makefile
--- linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/Makefile	2006-06-11 \
                16:03:17.716764337 +0200
+++ linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/Makefile	2006-06-11 \
16:11:41.279630413 +0200 @@ -5,5 +5,8 @@
 # 
 
 obj-$(CONFIG_CRYPTO_AES_X86_64) += aes-x86_64.o
+obj-$(CONFIG_CRYPTO_TWOFISH_X86_64) += twofish-x86_64.o
 
 aes-x86_64-y := aes-x86_64-asm.o aes.o
+twofish-x86_64-y := twofish-x86_64-asm.o twofish.o
+
diff -uprN linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish.c \
                linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish.c
--- linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish.c	1970-01-01 \
                01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish.c	2006-06-11 \
16:10:49.426288180 +0200 @@ -0,0 +1,86 @@
+/*
+ * Glue Code for optimized x86_64 assembler version of TWOFISH
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+asmlinkage void twofish_enc_blk(void *ctx, u8 *dst, const u8 *src);
+
+asmlinkage void twofish_dec_blk(void *ctx, u8 *dst, const u8 *src);
+
+static struct crypto_alg alg = {
+	.cra_name           =   "twofish",
+	.cra_driver_name    =	"twofish-x86_64",
+	.cra_priority       =	200,
+	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize      =   TF_BLOCK_SIZE,
+	.cra_ctxsize        =   sizeof(struct twofish_ctx),
+	.cra_alignmask      =	3,
+	.cra_module         =   THIS_MODULE,
+	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
+	.cra_u              =   { .cipher = {
+	.cia_min_keysize    =   TF_MIN_KEY_SIZE,
+	.cia_max_keysize    =   TF_MAX_KEY_SIZE,
+	.cia_setkey         =   twofish_setkey,
+	.cia_encrypt        =   twofish_enc_blk,
+	.cia_decrypt        =   twofish_dec_blk } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION ("Twofish Cipher Algorithm, x86_64 asm optimized");
diff -uprN linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish-x86_64-asm.S \
                linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish-x86_64-asm.S
--- linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish-x86_64-asm.S	1970-01-01 \
                01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish-x86_64-asm.S	2006-06-11 \
21:50:17.303085147 +0200 @@ -0,0 +1,397 @@
+/***************************************************************************
+*   Copyright (C) 2006 by Joachim Fritschi, &lt;jfritschi@freenet.de&gt;        *
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+*   This program is distributed in the hope that it will be useful,       *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+*   GNU General Public License for more details.                          *
+*                                                                         *
+*   You should have received a copy of the GNU General Public License     *
+*   along with this program; if not, write to the                         *
+*   Free Software Foundation, Inc.,                                       *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+***************************************************************************/
+
+.file "twofish-x86_64-asm.S"
+.text
+
+#define a_offset	0
+#define b_offset	4
+#define c_offset	8
+#define d_offset	12
+
+/* Structure of the crypto context struct*/
+
+#define s0	0	/* S0 Array 256 Words each */
+#define s1	1024	/* S1 Array */
+#define s2	2048	/* S2 Array */
+#define s3	3072	/* S3 Array */
+#define w	4096	/* 8 whitening keys (word) */
+#define k	4128	/* key 1-32 ( word ) */
+
+/* define a few register aliases to allow macro substitution */
+
+#define R0     %rax
+#define R0D    %eax
+#define R0B    %al
+#define R0H    %ah
+
+#define R1     %rbx
+#define R1D    %ebx
+#define R1B    %bl
+#define R1H    %bh
+
+#define R2     %rcx
+#define R2D    %ecx
+#define R2B    %cl
+#define R2H    %ch
+
+#define R3     %rdx
+#define R3D    %edx
+#define R3B    %dl
+#define R3H    %dh
+
+
+/* performs input whitening */
+#define input_whitening(src,context,offset)\
+	xor	w+offset(context),	src;
+
+/* performs input whitening */
+#define output_whitening(src,context,offset)\
+	xor	w+16+offset(context),	src;
+
+
+/*
+a input register containing a (rotated 16)
+b input register containing b
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+*/
+#define encrypt_round(a,b,c,d,round)\
+movzx	b ## B,		%edi;\
+mov	s1(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+mov	s2(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%r11,%rdi,4),%r9d;\
+movzx	b ## B,		%edi;\
+xor	s3(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+xor	(%r11,%rdi,4),	%r9d;\
+movzx	b ## H,		%edi;\
+ror	$15,		b ## D;\
+xor	(%r11,%rdi,4),	%r8d;\
+movzx	a ## H,		%edi;\
+xor	s1(%r11,%rdi,4),%r9d;\
+add	%r8d,		%r9d;\
+add	%r9d,		%r8d;\
+add	k+round(%r11),	%r9d;\
+xor	%r9d,		c ## D;\
+rol	$15,		c ## D;\
+add	k+4+round(%r11),%r8d;\
+xor	%r8d,		d ## D;
+
+
+/*
+a input register containing a
+b input register containing b
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+*/
+#define encrypt_first_round(a,b,c,d,round)\
+movzx	a ## B,		%edi;\
+mov	(%r11,%rdi,4),	%r9d;\
+movzx	b ## B,		%edi;\
+mov	s1(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s1(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%r11,%rdi,4),%r8d;\
+movzx	b ## B,		%edi;\
+xor	s3(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+xor	s2(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+ror	$15,		b ## D;\
+xor	(%r11,%rdi,4),	%r8d;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%r11,%rdi,4),%r9d;\
+add	%r8d,		%r9d;\
+add	%r9d,		%r8d;\
+add	k+round(%r11),	%r9d;\
+add	k+4+round(%r11),%r8d;\
+xor	%r9d,		c ## D;\
+rol	$15,		c ## D;\
+xor	%r8d,		d ## D;
+
+/*
+a input register containing a(rotated 16)
+b input register containing b
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+durimg the round a and b are prepared for the output whitening
+*/
+#define encrypt_last_round(a,b,c,d,round)\
+mov	b ## D,		%r10d;\
+shl	$32,		%r10;\
+movzx	b ## B,		%edi;\
+mov	s1(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+mov	s2(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%r11,%rdi,4),%r9d;\
+movzx	b ## B,		%edi;\
+xor	s3(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+xor	(%r11,%rdi,4),	%r9d;\
+xor	a,		%r10;\
+movzx	b ## H,		%edi;\
+xor	(%r11,%rdi,4),	%r8d;\
+movzx	a ## H,		%edi;\
+xor	s1(%r11,%rdi,4),%r9d;\
+add	%r8d,		%r9d;\
+add	%r9d,		%r8d;\
+add	k+round(%r11),	%r9d;\
+xor	%r9d,		c ## D;\
+ror	$1,		c ## D;\
+add	k+4+round(%r11),%r8d;\
+xor	%r8d,		d ## D
+
+
+/*
+a input register containing a
+b input register containing b (rotated 16)
+c input register containing c (already rol $1)
+d input register containing d 
+operations on a and b are interleaved to increase performance
+*/
+#define decrypt_round(a,b,c,d,round)\
+movzx	a ## B,		%edi;\
+mov	(%r11,%rdi,4),	%r9d;\
+movzx	b ## B,		%edi;\
+mov	s3(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s1(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%r11,%rdi,4),	%r8d;\
+movzx	a ## B,		%edi;\
+xor	s2(%r11,%rdi,4),%r9d;\
+movzx	b ## B,		%edi;\
+xor	s1(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+ror	$15,		a ## D;\
+xor	s3(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+xor	s2(%r11,%rdi,4),%r8d;\
+add	%r8d,		%r9d;\
+add	%r9d,		%r8d;\
+add	k+4+round(%r11),%r8d;\
+xor	%r8d,		d ## D;\
+rol	$15,		d ## D;\
+add	k+round(%r11),	%r9d;\
+xor	%r9d,		c ## D;
+
+/*
+a input register containing a
+b input register containing b
+c input register containing c (already rol $1)
+d input register containing d
+operations on a and b are interleaved to increase performance
+*/
+#define decrypt_first_round(a,b,c,d,round)\
+movzx	a ## B,		%edi;\
+mov	(%r11,%rdi,4),	%r9d;\
+movzx	b ## B,		%edi;\
+mov	s1(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s1(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%r11,%rdi,4),%r8d;\
+movzx	b ## B,		%edi;\
+xor	s3(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+xor	s2(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%r11,%rdi,4),	%r8d;\
+movzx	a ## H,		%edi;\
+ror	$15,		a ## D;\
+xor	s3(%r11,%rdi,4),%r9d;\
+add	%r8d,		%r9d;\
+add	%r9d,		%r8d;\
+add	k+4+round(%r11),%r8d;\
+xor	%r8d,		d ## D;\
+rol	$15,		d ## D;\
+add	k+round(%r11),	%r9d;\
+xor	%r9d,		c ## D;
+
+/*
+a input register containing a
+b input register containing b
+c input register containing c (already rol $1)
+d input register containing d
+operations on a and b are interleaved to increase performance
+durimg the round a and b are prepared for the output whitening
+@ */
+#define decrypt_last_round(a,b,c,d,round)\
+movzx	a ## B,		%edi;\
+mov	(%r11,%rdi,4),	%r9d;\
+movzx	b ## B,		%edi;\
+mov	s3(%r11,%rdi,4),%r8d;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%r11,%rdi,4),	%r8d;\
+movzx	a ## H,		%edi;\
+mov	b ## D,		%r10d;\
+shl	$32,		%r10;\
+xor	a,		%r10;\
+ror	$16,		a ## D;\
+xor	s1(%r11,%rdi,4),%r9d;\
+movzx	b ## B,		%edi;\
+xor	s1(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+xor	s2(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+xor	s2(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+xor	s3(%r11,%rdi,4),%r9d;\
+add	%r8d,		%r9d;\
+add	%r9d,		%r8d;\
+add	k+4+round(%r11),%r8d;\
+xor	%r8d,		d ## D;\
+ror	$1,		d ## D;\
+add	k+round(%r11),	%r9d;\
+xor	%r9d,		c ## D;
+
+	
+	
+.align 8
+.global twofish_enc_blk
+.global twofish_dec_blk
+
+
+
+twofish_enc_blk:
+	pushq    R1
+	
+	/* %rdi contains the crypto ctx adress */
+	/* %rsi contains the output adress */
+	/* %rdx contains the input adress */
+	
+	/* ctx adress is moved to free one non-rex register
+	as target for the 8bit high operations */
+	mov	%rdi,		%r11
+
+	movq	(R3),	R1
+	movq	8(R3),	R3
+	input_whitening(R1,%r11,a_offset)
+	input_whitening(R3,%r11,c_offset)
+	mov	R1D,	R0D
+	shr	$32,	R1
+	mov	R3D,	R2D
+	shr	$32,	R3
+	rol	$1,	R3D
+
+	encrypt_first_round(R0,R1,R2,R3,0);
+	encrypt_round(R2,R3,R0,R1,8);
+	encrypt_round(R0,R1,R2,R3,2*8);
+	encrypt_round(R2,R3,R0,R1,3*8);
+	encrypt_round(R0,R1,R2,R3,4*8);
+	encrypt_round(R2,R3,R0,R1,5*8);
+	encrypt_round(R0,R1,R2,R3,6*8);
+	encrypt_round(R2,R3,R0,R1,7*8);
+	encrypt_round(R0,R1,R2,R3,8*8);
+	encrypt_round(R2,R3,R0,R1,9*8);
+	encrypt_round(R0,R1,R2,R3,10*8);
+	encrypt_round(R2,R3,R0,R1,11*8);
+	encrypt_round(R0,R1,R2,R3,12*8);
+	encrypt_round(R2,R3,R0,R1,13*8);
+	encrypt_round(R0,R1,R2,R3,14*8);
+	encrypt_last_round(R2,R3,R0,R1,15*8);
+
+
+	output_whitening(%r10,%r11,a_offset)
+	movq	%r10,	(%rsi)
+
+	shl	$32,	R1
+	xor	R0,	R1
+
+	output_whitening(R1,%r11,c_offset)
+	movq	R1,	8(%rsi)
+
+	popq	R1
+	movq	$1,%rax
+	ret
+	
+twofish_dec_blk:	
+	pushq    R1
+	
+	/* %rdi contains the crypto ctx adress */
+	/* %rsi contains the output adress */
+	/* %rdx contains the input adress */
+	/* ctx adress is moved to free one non-rex register
+	as target for the 8bit high operations */
+	mov	%rdi,		%r11
+
+	movq	(R3),	R1
+	movq	8(R3),	R3
+	output_whitening(R1,%r11,a_offset)
+	output_whitening(R3,%r11,c_offset)
+	mov	R1D,	R0D
+	shr	$32,	R1
+	mov	R3D,	R2D
+	shr	$32,	R3
+	rol	$1,	R2D
+
+	decrypt_first_round(R0,R1,R2,R3,15*8);
+	decrypt_round(R2,R3,R0,R1,14*8);
+	decrypt_round(R0,R1,R2,R3,13*8);
+	decrypt_round(R2,R3,R0,R1,12*8);
+	decrypt_round(R0,R1,R2,R3,11*8);
+	decrypt_round(R2,R3,R0,R1,10*8);
+	decrypt_round(R0,R1,R2,R3,9*8);
+	decrypt_round(R2,R3,R0,R1,8*8);
+	decrypt_round(R0,R1,R2,R3,7*8);
+	decrypt_round(R2,R3,R0,R1,6*8);
+	decrypt_round(R0,R1,R2,R3,5*8);
+	decrypt_round(R2,R3,R0,R1,4*8);
+	decrypt_round(R0,R1,R2,R3,3*8);
+	decrypt_round(R2,R3,R0,R1,2*8);
+	decrypt_round(R0,R1,R2,R3,1*8);
+	decrypt_last_round(R2,R3,R0,R1,0);
+
+	input_whitening(%r10,%r11,a_offset)
+	movq	%r10,	(%rsi)
+
+	shl	$32,	R1
+	xor	R0,	R1
+
+	input_whitening(R1,%r11,c_offset)
+	movq	R1,	8(%rsi)
+
+	popq	R1
+	movq	$1,%rax
+	ret
diff -uprN linux-2.6.17-rc5.twofish3/crypto/Kconfig \
                linux-2.6.17-rc5.twofish4/crypto/Kconfig
--- linux-2.6.17-rc5.twofish3/crypto/Kconfig	2006-06-11 16:05:19.938782275 +0200
+++ linux-2.6.17-rc5.twofish4/crypto/Kconfig	2006-06-11 16:11:17.126755733 +0200
@@ -165,6 +165,21 @@ config CRYPTO_TWOFISH_586
 	  See also:
 	  &lt;http://www.schneier.com/twofish.html&gt;
 
+config CRYPTO_TWOFISH_X86_64
+        tristate "Twofish cipher algorithm (x86_64)"
+        depends on CRYPTO &amp;&amp; ((X86 || UML_X86) &amp;&amp; 64BIT)
+        select CRYPTO_TWOFISH_COMMON
+	help
+          Twofish cipher algorithm (x86_64).
+
+          Twofish was submitted as an AES (Advanced Encryption Standard)
+          candidate cipher by researchers at CounterPane Systems.  It is a
+          16 round block cipher supporting key sizes of 128, 192, and 256
+          bits.
+
+          See also:
+          &lt;http://www.schneier.com/twofish.html&gt;
+
 config CRYPTO_SERPENT
 	tristate "Serpent cipher algorithm"
 	depends on CRYPTO

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


</body></email><email><emailId>20060617103844</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-17 10:38:44-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

After recieving some more feedback from linux@horizon.com, i have revised my
patch a bit and done some cosmetic changes. The first_round macros are now 
eliminated reducing the patchsize.

Correctness was verified with the tcrypt module and automated test scripts.
 
Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

diff -uprN linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/Makefile \
                linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/Makefile
--- linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/Makefile	2006-06-11 \
                16:03:17.716764337 +0200
+++ linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/Makefile	2006-06-11 \
16:11:41.279630413 +0200 @@ -5,5 +5,8 @@
 # 
 
 obj-$(CONFIG_CRYPTO_AES_X86_64) += aes-x86_64.o
+obj-$(CONFIG_CRYPTO_TWOFISH_X86_64) += twofish-x86_64.o
 
 aes-x86_64-y := aes-x86_64-asm.o aes.o
+twofish-x86_64-y := twofish-x86_64-asm.o twofish.o
+
diff -uprN linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish.c \
                linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish.c
--- linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish.c	1970-01-01 \
                01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish.c	2006-06-11 \
16:10:49.426288180 +0200 @@ -0,0 +1,86 @@
+/*
+ * Glue Code for optimized x86_64 assembler version of TWOFISH
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+asmlinkage void twofish_enc_blk(void *ctx, u8 *dst, const u8 *src);
+
+asmlinkage void twofish_dec_blk(void *ctx, u8 *dst, const u8 *src);
+
+static struct crypto_alg alg = {
+	.cra_name           =   "twofish",
+	.cra_driver_name    =	"twofish-x86_64",
+	.cra_priority       =	200,
+	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize      =   TF_BLOCK_SIZE,
+	.cra_ctxsize        =   sizeof(struct twofish_ctx),
+	.cra_alignmask      =	3,
+	.cra_module         =   THIS_MODULE,
+	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
+	.cra_u              =   { .cipher = {
+	.cia_min_keysize    =   TF_MIN_KEY_SIZE,
+	.cia_max_keysize    =   TF_MAX_KEY_SIZE,
+	.cia_setkey         =   twofish_setkey,
+	.cia_encrypt        =   twofish_enc_blk,
+	.cia_decrypt        =   twofish_dec_blk } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION ("Twofish Cipher Algorithm, x86_64 asm optimized");
diff -uprN linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish-x86_64-asm.S \
                linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish-x86_64-asm.S
--- linux-2.6.17-rc5.twofish3/arch/x86_64/crypto/twofish-x86_64-asm.S	1970-01-01 \
                01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish4/arch/x86_64/crypto/twofish-x86_64-asm.S	2006-06-17 \
12:34:00.038152154 +0200 @@ -0,0 +1,321 @@
+/***************************************************************************
+*   Copyright (C) 2006 by Joachim Fritschi, &lt;jfritschi@freenet.de&gt;        *
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+*   This program is distributed in the hope that it will be useful,       *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+*   GNU General Public License for more details.                          *
+*                                                                         *
+*   You should have received a copy of the GNU General Public License     *
+*   along with this program; if not, write to the                         *
+*   Free Software Foundation, Inc.,                                       *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+***************************************************************************/
+
+.file "twofish-x86_64-asm.S"
+.text
+
+#define a_offset	0
+#define b_offset	4
+#define c_offset	8
+#define d_offset	12
+
+/* Structure of the crypto context struct*/
+
+#define s0	0	/* S0 Array 256 Words each */
+#define s1	1024	/* S1 Array */
+#define s2	2048	/* S2 Array */
+#define s3	3072	/* S3 Array */
+#define w	4096	/* 8 whitening keys (word) */
+#define k	4128	/* key 1-32 ( word ) */
+
+/* define a few register aliases to allow macro substitution */
+
+#define R0     %rax
+#define R0D    %eax
+#define R0B    %al
+#define R0H    %ah
+
+#define R1     %rbx
+#define R1D    %ebx
+#define R1B    %bl
+#define R1H    %bh
+
+#define R2     %rcx
+#define R2D    %ecx
+#define R2B    %cl
+#define R2H    %ch
+
+#define R3     %rdx
+#define R3D    %edx
+#define R3B    %dl
+#define R3H    %dh
+
+
+/* performs input whitening */
+#define input_whitening(src,context,offset)\
+	xor	w+offset(context),	src;
+
+/* performs input whitening */
+#define output_whitening(src,context,offset)\
+	xor	w+16+offset(context),	src;
+
+
+/*
+a input register containing a (rotated 16)
+b input register containing b
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+*/
+#define encrypt_round(a,b,c,d,round)\
+movzx	b ## B,		%edi;\
+mov	s1(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+mov	s2(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%r11,%rdi,4),%r9d;\
+movzx	b ## B,		%edi;\
+xor	s3(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+xor	(%r11,%rdi,4),	%r9d;\
+movzx	b ## H,		%edi;\
+ror	$15,		b ## D;\
+xor	(%r11,%rdi,4),	%r8d;\
+movzx	a ## H,		%edi;\
+xor	s1(%r11,%rdi,4),%r9d;\
+add	%r8d,		%r9d;\
+add	%r9d,		%r8d;\
+add	k+round(%r11),	%r9d;\
+xor	%r9d,		c ## D;\
+rol	$15,		c ## D;\
+add	k+4+round(%r11),%r8d;\
+xor	%r8d,		d ## D;
+
+/*
+a input register containing a(rotated 16)
+b input register containing b
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+during the round a and b are prepared for the output whitening
+*/
+#define encrypt_last_round(a,b,c,d,round)\
+mov	b ## D,		%r10d;\
+shl	$32,		%r10;\
+movzx	b ## B,		%edi;\
+mov	s1(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+mov	s2(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%r11,%rdi,4),%r9d;\
+movzx	b ## B,		%edi;\
+xor	s3(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+xor	(%r11,%rdi,4),	%r9d;\
+xor	a,		%r10;\
+movzx	b ## H,		%edi;\
+xor	(%r11,%rdi,4),	%r8d;\
+movzx	a ## H,		%edi;\
+xor	s1(%r11,%rdi,4),%r9d;\
+add	%r8d,		%r9d;\
+add	%r9d,		%r8d;\
+add	k+round(%r11),	%r9d;\
+xor	%r9d,		c ## D;\
+ror	$1,		c ## D;\
+add	k+4+round(%r11),%r8d;\
+xor	%r8d,		d ## D
+
+/*
+a input register containing a
+b input register containing b (rotated 16)
+c input register containing c (already rol $1)
+d input register containing d 
+operations on a and b are interleaved to increase performance
+*/
+#define decrypt_round(a,b,c,d,round)\
+movzx	a ## B,		%edi;\
+mov	(%r11,%rdi,4),	%r9d;\
+movzx	b ## B,		%edi;\
+mov	s3(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s1(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%r11,%rdi,4),	%r8d;\
+movzx	a ## B,		%edi;\
+xor	s2(%r11,%rdi,4),%r9d;\
+movzx	b ## B,		%edi;\
+xor	s1(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+ror	$15,		a ## D;\
+xor	s3(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+xor	s2(%r11,%rdi,4),%r8d;\
+add	%r8d,		%r9d;\
+add	%r9d,		%r8d;\
+add	k+round(%r11),	%r9d;\
+xor	%r9d,		c ## D;\
+add	k+4+round(%r11),%r8d;\
+xor	%r8d,		d ## D;\
+rol	$15,		d ## D;
+
+/*
+a input register containing a
+b input register containing b
+c input register containing c (already rol $1)
+d input register containing d
+operations on a and b are interleaved to increase performance
+during the round a and b are prepared for the output whitening
+*/
+#define decrypt_last_round(a,b,c,d,round)\
+movzx	a ## B,		%edi;\
+mov	(%r11,%rdi,4),	%r9d;\
+movzx	b ## B,		%edi;\
+mov	s3(%r11,%rdi,4),%r8d;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%r11,%rdi,4),	%r8d;\
+movzx	a ## H,		%edi;\
+mov	b ## D,		%r10d;\
+shl	$32,		%r10;\
+xor	a,		%r10;\
+ror	$16,		a ## D;\
+xor	s1(%r11,%rdi,4),%r9d;\
+movzx	b ## B,		%edi;\
+xor	s1(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+xor	s2(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+xor	s2(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+xor	s3(%r11,%rdi,4),%r9d;\
+add	%r8d,		%r9d;\
+add	%r9d,		%r8d;\
+add	k+round(%r11),	%r9d;\
+xor	%r9d,		c ## D;\
+add	k+4+round(%r11),%r8d;\
+xor	%r8d,		d ## D;\
+ror	$1,		d ## D;
+
+.align 8
+.global twofish_enc_blk
+.global twofish_dec_blk
+
+twofish_enc_blk:
+	pushq    R1
+
+	/* %rdi contains the crypto ctx adress */
+	/* %rsi contains the output adress */
+	/* %rdx contains the input adress */
+
+	/* ctx adress is moved to free one non-rex register
+	as target for the 8bit high operations */
+	mov	%rdi,		%r11
+
+	movq	(R3),	R1
+	movq	8(R3),	R3
+	input_whitening(R1,%r11,a_offset)
+	input_whitening(R3,%r11,c_offset)
+	mov	R1D,	R0D
+	rol	$16,	R0D
+	shr	$32,	R1
+	mov	R3D,	R2D
+	shr	$32,	R3
+	rol	$1,	R3D
+
+	encrypt_round(R0,R1,R2,R3,0);
+	encrypt_round(R2,R3,R0,R1,8);
+	encrypt_round(R0,R1,R2,R3,2*8);
+	encrypt_round(R2,R3,R0,R1,3*8);
+	encrypt_round(R0,R1,R2,R3,4*8);
+	encrypt_round(R2,R3,R0,R1,5*8);
+	encrypt_round(R0,R1,R2,R3,6*8);
+	encrypt_round(R2,R3,R0,R1,7*8);
+	encrypt_round(R0,R1,R2,R3,8*8);
+	encrypt_round(R2,R3,R0,R1,9*8);
+	encrypt_round(R0,R1,R2,R3,10*8);
+	encrypt_round(R2,R3,R0,R1,11*8);
+	encrypt_round(R0,R1,R2,R3,12*8);
+	encrypt_round(R2,R3,R0,R1,13*8);
+	encrypt_round(R0,R1,R2,R3,14*8);
+	encrypt_last_round(R2,R3,R0,R1,15*8);
+
+
+	output_whitening(%r10,%r11,a_offset)
+	movq	%r10,	(%rsi)
+
+	shl	$32,	R1
+	xor	R0,	R1
+
+	output_whitening(R1,%r11,c_offset)
+	movq	R1,	8(%rsi)
+
+	popq	R1
+	movq	$1,%rax
+	ret
+	
+twofish_dec_blk:	
+	pushq    R1
+
+	/* %rdi contains the crypto ctx adress */
+	/* %rsi contains the output adress */
+	/* %rdx contains the input adress */
+	/* ctx adress is moved to free one non-rex register
+	as target for the 8bit high operations */
+	mov	%rdi,		%r11
+
+	movq	(R3),	R1
+	movq	8(R3),	R3
+	output_whitening(R1,%r11,a_offset)
+	output_whitening(R3,%r11,c_offset)
+	mov	R1D,	R0D
+	shr	$32,	R1
+	rol	$16,	R1D
+	mov	R3D,	R2D
+	shr	$32,	R3
+	rol	$1,	R2D
+
+	decrypt_round(R0,R1,R2,R3,15*8);
+	decrypt_round(R2,R3,R0,R1,14*8);
+	decrypt_round(R0,R1,R2,R3,13*8);
+	decrypt_round(R2,R3,R0,R1,12*8);
+	decrypt_round(R0,R1,R2,R3,11*8);
+	decrypt_round(R2,R3,R0,R1,10*8);
+	decrypt_round(R0,R1,R2,R3,9*8);
+	decrypt_round(R2,R3,R0,R1,8*8);
+	decrypt_round(R0,R1,R2,R3,7*8);
+	decrypt_round(R2,R3,R0,R1,6*8);
+	decrypt_round(R0,R1,R2,R3,5*8);
+	decrypt_round(R2,R3,R0,R1,4*8);
+	decrypt_round(R0,R1,R2,R3,3*8);
+	decrypt_round(R2,R3,R0,R1,2*8);
+	decrypt_round(R0,R1,R2,R3,1*8);
+	decrypt_last_round(R2,R3,R0,R1,0);
+
+	input_whitening(%r10,%r11,a_offset)
+	movq	%r10,	(%rsi)
+
+	shl	$32,	R1
+	xor	R0,	R1
+
+	input_whitening(R1,%r11,c_offset)
+	movq	R1,	8(%rsi)
+
+	popq	R1
+	movq	$1,%rax
+	ret
diff -uprN linux-2.6.17-rc5.twofish3/crypto/Kconfig \
                linux-2.6.17-rc5.twofish4/crypto/Kconfig
--- linux-2.6.17-rc5.twofish3/crypto/Kconfig	2006-06-11 16:05:19.938782275 +0200
+++ linux-2.6.17-rc5.twofish4/crypto/Kconfig	2006-06-11 16:11:17.126755733 +0200
@@ -165,6 +165,21 @@ config CRYPTO_TWOFISH_586
 	  See also:
 	  &lt;http://www.schneier.com/twofish.html&gt;
 
+config CRYPTO_TWOFISH_X86_64
+        tristate "Twofish cipher algorithm (x86_64)"
+        depends on CRYPTO &amp;&amp; ((X86 || UML_X86) &amp;&amp; 64BIT)
+        select CRYPTO_TWOFISH_COMMON
+	help
+          Twofish cipher algorithm (x86_64).
+
+          Twofish was submitted as an AES (Advanced Encryption Standard)
+          candidate cipher by researchers at CounterPane Systems.  It is a
+          16 round block cipher supporting key sizes of 128, 192, and 256
+          bits.
+
+          See also:
+          &lt;http://www.schneier.com/twofish.html&gt;
+
 config CRYPTO_SERPENT
 	tristate "Serpent cipher algorithm"
 	depends on CRYPTO

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


</body></email><email><emailId>20060619141301</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-19 14:13:01-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

This patch is now based on the cryptodev tree using the new cryptoapi (crypto  tfm
 instead of the crypto ctx as parameter).

The module passed the tcrypt tests and testscripts.

Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

 arch/x86_64/crypto/Makefile             |    3 
 arch/x86_64/crypto/twofish-x86_64-asm.S |  324 +++++++++++++++++++++++++++++++
 arch/x86_64/crypto/twofish.c            |   86 ++++++++
 crypto/Kconfig                          |   15 +
 4 files changed, 428 insertions(+), 0 deletions(-)

diff --git a/arch/x86_64/crypto/Makefile b/arch/x86_64/crypto/Makefile
index 426d20f..15b538a 100644
--- a/arch/x86_64/crypto/Makefile
+++ b/arch/x86_64/crypto/Makefile
@@ -5,5 +5,8 @@ # Arch-specific CryptoAPI modules.
 # 
 
 obj-$(CONFIG_CRYPTO_AES_X86_64) += aes-x86_64.o
+obj-$(CONFIG_CRYPTO_TWOFISH_X86_64) += twofish-x86_64.o
 
 aes-x86_64-y := aes-x86_64-asm.o aes.o
+twofish-x86_64-y := twofish-x86_64-asm.o twofish.o
+
diff --git a/arch/x86_64/crypto/twofish-x86_64-asm.S b/arch/x86_64/crypto/twofish-x86_64-asm.S
new file mode 100644
index 0000000..5b694c0
--- /dev/null
+++ b/arch/x86_64/crypto/twofish-x86_64-asm.S
@@ -0,0 +1,324 @@
+/***************************************************************************
+*   Copyright (C) 2006 by Joachim Fritschi, &lt;jfritschi@freenet.de&gt;        *
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+*   This program is distributed in the hope that it will be useful,       *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+*   GNU General Public License for more details.                          *
+*                                                                         *
+*   You should have received a copy of the GNU General Public License     *
+*   along with this program; if not, write to the                         *
+*   Free Software Foundation, Inc.,                                       *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+***************************************************************************/
+
+.file "twofish-x86_64-asm.S"
+.text
+
+#include &lt;asm/asm-offsets.h&gt;
+
+#define a_offset	0
+#define b_offset	4
+#define c_offset	8
+#define d_offset	12
+
+/* Structure of the crypto context struct*/
+
+#define s0	0	/* S0 Array 256 Words each */
+#define s1	1024	/* S1 Array */
+#define s2	2048	/* S2 Array */
+#define s3	3072	/* S3 Array */
+#define w	4096	/* 8 whitening keys (word) */
+#define k	4128	/* key 1-32 ( word ) */
+
+/* define a few register aliases to allow macro substitution */
+
+#define R0     %rax
+#define R0D    %eax
+#define R0B    %al
+#define R0H    %ah
+
+#define R1     %rbx
+#define R1D    %ebx
+#define R1B    %bl
+#define R1H    %bh
+
+#define R2     %rcx
+#define R2D    %ecx
+#define R2B    %cl
+#define R2H    %ch
+
+#define R3     %rdx
+#define R3D    %edx
+#define R3B    %dl
+#define R3H    %dh
+
+
+/* performs input whitening */
+#define input_whitening(src,context,offset)\
+	xor	w+offset(context),	src;
+
+/* performs input whitening */
+#define output_whitening(src,context,offset)\
+	xor	w+16+offset(context),	src;
+
+
+/*
+a input register containing a (rotated 16)
+b input register containing b
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+*/
+#define encrypt_round(a,b,c,d,round)\
+movzx	b ## B,		%edi;\
+mov	s1(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+mov	s2(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%r11,%rdi,4),%r9d;\
+movzx	b ## B,		%edi;\
+xor	s3(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+xor	(%r11,%rdi,4),	%r9d;\
+movzx	b ## H,		%edi;\
+ror	$15,		b ## D;\
+xor	(%r11,%rdi,4),	%r8d;\
+movzx	a ## H,		%edi;\
+xor	s1(%r11,%rdi,4),%r9d;\
+add	%r8d,		%r9d;\
+add	%r9d,		%r8d;\
+add	k+round(%r11),	%r9d;\
+xor	%r9d,		c ## D;\
+rol	$15,		c ## D;\
+add	k+4+round(%r11),%r8d;\
+xor	%r8d,		d ## D;
+
+/*
+a input register containing a(rotated 16)
+b input register containing b
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+during the round a and b are prepared for the output whitening
+*/
+#define encrypt_last_round(a,b,c,d,round)\
+mov	b ## D,		%r10d;\
+shl	$32,		%r10;\
+movzx	b ## B,		%edi;\
+mov	s1(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+mov	s2(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%r11,%rdi,4),%r9d;\
+movzx	b ## B,		%edi;\
+xor	s3(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+xor	(%r11,%rdi,4),	%r9d;\
+xor	a,		%r10;\
+movzx	b ## H,		%edi;\
+xor	(%r11,%rdi,4),	%r8d;\
+movzx	a ## H,		%edi;\
+xor	s1(%r11,%rdi,4),%r9d;\
+add	%r8d,		%r9d;\
+add	%r9d,		%r8d;\
+add	k+round(%r11),	%r9d;\
+xor	%r9d,		c ## D;\
+ror	$1,		c ## D;\
+add	k+4+round(%r11),%r8d;\
+xor	%r8d,		d ## D
+
+/*
+a input register containing a
+b input register containing b (rotated 16)
+c input register containing c (already rol $1)
+d input register containing d 
+operations on a and b are interleaved to increase performance
+*/
+#define decrypt_round(a,b,c,d,round)\
+movzx	a ## B,		%edi;\
+mov	(%r11,%rdi,4),	%r9d;\
+movzx	b ## B,		%edi;\
+mov	s3(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s1(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%r11,%rdi,4),	%r8d;\
+movzx	a ## B,		%edi;\
+xor	s2(%r11,%rdi,4),%r9d;\
+movzx	b ## B,		%edi;\
+xor	s1(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+ror	$15,		a ## D;\
+xor	s3(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+xor	s2(%r11,%rdi,4),%r8d;\
+add	%r8d,		%r9d;\
+add	%r9d,		%r8d;\
+add	k+round(%r11),	%r9d;\
+xor	%r9d,		c ## D;\
+add	k+4+round(%r11),%r8d;\
+xor	%r8d,		d ## D;\
+rol	$15,		d ## D;
+
+/*
+a input register containing a
+b input register containing b
+c input register containing c (already rol $1)
+d input register containing d
+operations on a and b are interleaved to increase performance
+during the round a and b are prepared for the output whitening
+*/
+#define decrypt_last_round(a,b,c,d,round)\
+movzx	a ## B,		%edi;\
+mov	(%r11,%rdi,4),	%r9d;\
+movzx	b ## B,		%edi;\
+mov	s3(%r11,%rdi,4),%r8d;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%r11,%rdi,4),	%r8d;\
+movzx	a ## H,		%edi;\
+mov	b ## D,		%r10d;\
+shl	$32,		%r10;\
+xor	a,		%r10;\
+ror	$16,		a ## D;\
+xor	s1(%r11,%rdi,4),%r9d;\
+movzx	b ## B,		%edi;\
+xor	s1(%r11,%rdi,4),%r8d;\
+movzx	a ## B,		%edi;\
+xor	s2(%r11,%rdi,4),%r9d;\
+movzx	b ## H,		%edi;\
+xor	s2(%r11,%rdi,4),%r8d;\
+movzx	a ## H,		%edi;\
+xor	s3(%r11,%rdi,4),%r9d;\
+add	%r8d,		%r9d;\
+add	%r9d,		%r8d;\
+add	k+round(%r11),	%r9d;\
+xor	%r9d,		c ## D;\
+add	k+4+round(%r11),%r8d;\
+xor	%r8d,		d ## D;\
+ror	$1,		d ## D;
+
+.align 8
+.global twofish_enc_blk
+.global twofish_dec_blk
+
+twofish_enc_blk:
+	pushq    R1
+
+	/* %rdi contains the crypto tfm adress */
+	/* %rsi contains the output adress */
+	/* %rdx contains the input adress */
+	add	$crypto_tfm_ctx_offset, %rdi	/* set ctx adress */
+	/* ctx adress is moved to free one non-rex register
+	as target for the 8bit high operations */
+	mov	%rdi,		%r11
+
+	movq	(R3),	R1
+	movq	8(R3),	R3
+	input_whitening(R1,%r11,a_offset)
+	input_whitening(R3,%r11,c_offset)
+	mov	R1D,	R0D
+	rol	$16,	R0D
+	shr	$32,	R1
+	mov	R3D,	R2D
+	shr	$32,	R3
+	rol	$1,	R3D
+
+	encrypt_round(R0,R1,R2,R3,0);
+	encrypt_round(R2,R3,R0,R1,8);
+	encrypt_round(R0,R1,R2,R3,2*8);
+	encrypt_round(R2,R3,R0,R1,3*8);
+	encrypt_round(R0,R1,R2,R3,4*8);
+	encrypt_round(R2,R3,R0,R1,5*8);
+	encrypt_round(R0,R1,R2,R3,6*8);
+	encrypt_round(R2,R3,R0,R1,7*8);
+	encrypt_round(R0,R1,R2,R3,8*8);
+	encrypt_round(R2,R3,R0,R1,9*8);
+	encrypt_round(R0,R1,R2,R3,10*8);
+	encrypt_round(R2,R3,R0,R1,11*8);
+	encrypt_round(R0,R1,R2,R3,12*8);
+	encrypt_round(R2,R3,R0,R1,13*8);
+	encrypt_round(R0,R1,R2,R3,14*8);
+	encrypt_last_round(R2,R3,R0,R1,15*8);
+
+
+	output_whitening(%r10,%r11,a_offset)
+	movq	%r10,	(%rsi)
+
+	shl	$32,	R1
+	xor	R0,	R1
+
+	output_whitening(R1,%r11,c_offset)
+	movq	R1,	8(%rsi)
+
+	popq	R1
+	movq	$1,%rax
+	ret
+	
+twofish_dec_blk:	
+	pushq    R1
+
+	/* %rdi contains the crypto tfm adress */
+	/* %rsi contains the output adress */
+	/* %rdx contains the input adress */
+	add	$crypto_tfm_ctx_offset, %rdi	/* set ctx adress */
+	/* ctx adress is moved to free one non-rex register
+	as target for the 8bit high operations */
+	mov	%rdi,		%r11
+
+	movq	(R3),	R1
+	movq	8(R3),	R3
+	output_whitening(R1,%r11,a_offset)
+	output_whitening(R3,%r11,c_offset)
+	mov	R1D,	R0D
+	shr	$32,	R1
+	rol	$16,	R1D
+	mov	R3D,	R2D
+	shr	$32,	R3
+	rol	$1,	R2D
+
+	decrypt_round(R0,R1,R2,R3,15*8);
+	decrypt_round(R2,R3,R0,R1,14*8);
+	decrypt_round(R0,R1,R2,R3,13*8);
+	decrypt_round(R2,R3,R0,R1,12*8);
+	decrypt_round(R0,R1,R2,R3,11*8);
+	decrypt_round(R2,R3,R0,R1,10*8);
+	decrypt_round(R0,R1,R2,R3,9*8);
+	decrypt_round(R2,R3,R0,R1,8*8);
+	decrypt_round(R0,R1,R2,R3,7*8);
+	decrypt_round(R2,R3,R0,R1,6*8);
+	decrypt_round(R0,R1,R2,R3,5*8);
+	decrypt_round(R2,R3,R0,R1,4*8);
+	decrypt_round(R0,R1,R2,R3,3*8);
+	decrypt_round(R2,R3,R0,R1,2*8);
+	decrypt_round(R0,R1,R2,R3,1*8);
+	decrypt_last_round(R2,R3,R0,R1,0);
+
+	input_whitening(%r10,%r11,a_offset)
+	movq	%r10,	(%rsi)
+
+	shl	$32,	R1
+	xor	R0,	R1
+
+	input_whitening(R1,%r11,c_offset)
+	movq	R1,	8(%rsi)
+
+	popq	R1
+	movq	$1,%rax
+	ret
diff --git a/arch/x86_64/crypto/twofish.c b/arch/x86_64/crypto/twofish.c
new file mode 100644
index 0000000..e38cc95
--- /dev/null
+++ b/arch/x86_64/crypto/twofish.c
@@ -0,0 +1,86 @@
+/*
+ * Glue Code for optimized x86_64 assembler version of TWOFISH
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+asmlinkage void twofish_enc_blk(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
+
+asmlinkage void twofish_dec_blk(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
+
+static struct crypto_alg alg = {
+	.cra_name           =   "twofish",
+	.cra_driver_name    =	"twofish-x86_64",
+	.cra_priority       =	200,
+	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize      =   TF_BLOCK_SIZE,
+	.cra_ctxsize        =   sizeof(struct twofish_ctx),
+	.cra_alignmask      =	3,
+	.cra_module         =   THIS_MODULE,
+	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
+	.cra_u              =   { .cipher = {
+	.cia_min_keysize    =   TF_MIN_KEY_SIZE,
+	.cia_max_keysize    =   TF_MAX_KEY_SIZE,
+	.cia_setkey         =   twofish_setkey,
+	.cia_encrypt        =   twofish_enc_blk,
+	.cia_decrypt        =   twofish_dec_blk } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION ("Twofish Cipher Algorithm, x86_64 asm optimized");
diff --git a/crypto/Kconfig b/crypto/Kconfig
index 28b203b..990054d 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -165,6 +165,21 @@ config CRYPTO_TWOFISH_586
 	  See also:
 	  &lt;http://www.schneier.com/twofish.html&gt;
 
+config CRYPTO_TWOFISH_X86_64
+	tristate "Twofish cipher algorithm (x86_64)"
+	depends on CRYPTO &amp;&amp; ((X86 || UML_X86) &amp;&amp; 64BIT)
+	select CRYPTO_TWOFISH_COMMON
+	help
+	  Twofish cipher algorithm (x86_64).
+
+	  Twofish was submitted as an AES (Advanced Encryption Standard)
+	  candidate cipher by researchers at CounterPane Systems.  It is a
+	  16 round block cipher supporting key sizes of 128, 192, and 256
+	  bits.
+
+	  See also:
+	  &lt;http://www.schneier.com/twofish.html&gt;
+
 config CRYPTO_SERPENT
 	tristate "Serpent cipher algorithm"
 	depends on CRYPTO
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060607193723</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-07 19:37:23-0400</timestampReceived><subject>Re: [PATCH  1/4] Twofish cipher - split out common c code</subject><body>

On Sunday 04 June 2006 15:16, Joachim Fritschi wrote:
&gt; I have revised my initial twofish assembler patchset according to the 
&gt; criticims i recieved on this list:
&gt; This patch splits up the twofish crypto routine into a common part ( key 
&gt; setup  ) which will be uses by all twofish crypto modules ( generic-c , i586 
&gt; assembler and x86_64 assembler ) and generic-c part. It also creates a new 
&gt; header file which will be used by all 3 modules. 
&gt; This eliminates all code duplication.
&gt; Correctness was verified with the tcrypt module and automated test scripts.
My first mail was wordwrapped. This one should be unwrapped and working:

Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

diff -uprN linux-2.6.17-rc5/crypto/Makefile linux-2.6.17-rc5.twofish/crypto/Makefile
--- linux-2.6.17-rc5/crypto/Makefile	2006-06-07 18:43:24.000000000 +0200
+++ linux-2.6.17-rc5.twofish/crypto/Makefile	2006-06-04 13:59:27.949797218 +0200
@@ -32,3 +32,5 @@ obj-$(CONFIG_CRYPTO_MICHAEL_MIC) += mich
 obj-$(CONFIG_CRYPTO_CRC32C) += crc32c.o
 
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
+
+twofish-objs := twofish_c.o twofish_common.o
diff -uprN linux-2.6.17-rc5/crypto/twofish.c linux-2.6.17-rc5.twofish/crypto/twofish.c
--- linux-2.6.17-rc5/crypto/twofish.c	2006-06-07 18:43:24.000000000 +0200
+++ linux-2.6.17-rc5.twofish/crypto/twofish.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,908 +0,0 @@
-/*
- * Twofish for CryptoAPI
- *
- * Originally Twofish for GPG
- * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
- * 256-bit key length added March 20, 1999
- * Some modifications to reduce the text size by Werner Koch, April, 1998
- * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
- * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
- *
- * The original author has disclaimed all copyright interest in this
- * code and thus put it in the public domain. The subsequent authors 
- * have put this under the GNU General Public License.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
- * USA
- *
- * This code is a "clean room" implementation, written from the paper
- * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
- * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
- * through http://www.counterpane.com/twofish.html
- *
- * For background information on multiplication in finite fields, used for
- * the matrix operations in the key schedule, see the book _Contemporary
- * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
- * Third Edition.
- */
-
-#include &lt;asm/byteorder.h&gt;
-#include &lt;linux/module.h&gt;
-#include &lt;linux/init.h&gt;
-#include &lt;linux/types.h&gt;
-#include &lt;linux/errno.h&gt;
-#include &lt;linux/crypto.h&gt;
-#include &lt;linux/bitops.h&gt;
-
-
-/* The large precomputed tables for the Twofish cipher (twofish.c)
- * Taken from the same source as twofish.c
- * Marc Mutz &lt;Marc@Mutz.com&gt;
- */
-
-/* These two tables are the q0 and q1 permutations, exactly as described in
- * the Twofish paper. */
-
-static const u8 q0[256] = {
-   0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78,
-   0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C,
-   0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30,
-   0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82,
-   0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE,
-   0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B,
-   0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45,
-   0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7,
-   0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF,
-   0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8,
-   0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED,
-   0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90,
-   0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B,
-   0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B,
-   0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F,
-   0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A,
-   0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17,
-   0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72,
-   0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68,
-   0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4,
-   0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42,
-   0x4A, 0x5E, 0xC1, 0xE0
-};
-
-static const u8 q1[256] = {
-   0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B,
-   0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1,
-   0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B,
-   0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5,
-   0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54,
-   0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96,
-   0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7,
-   0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8,
-   0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF,
-   0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9,
-   0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D,
-   0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E,
-   0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21,
-   0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01,
-   0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E,
-   0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64,
-   0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44,
-   0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E,
-   0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B,
-   0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9,
-   0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56,
-   0x55, 0x09, 0xBE, 0x91
-};
-
-/* These MDS tables are actually tables of MDS composed with q0 and q1,
- * because it is only ever used that way and we can save some time by
- * precomputing.  Of course the main saving comes from precomputing the
- * GF(2^8) multiplication involved in the MDS matrix multiply; by looking
- * things up in these tables we reduce the matrix multiply to four lookups
- * and three XORs.  Semi-formally, the definition of these tables is:
- * mds[0][i] = MDS (q1[i] 0 0 0)^T  mds[1][i] = MDS (0 q0[i] 0 0)^T
- * mds[2][i] = MDS (0 0 q1[i] 0)^T  mds[3][i] = MDS (0 0 0 q0[i])^T
- * where ^T means "transpose", the matrix multiply is performed in GF(2^8)
- * represented as GF(2)[x]/v(x) where v(x)=x^8+x^6+x^5+x^3+1 as described
- * by Schneier et al, and I'm casually glossing over the byte/word
- * conversion issues. */
-
-static const u32 mds[4][256] = {
-   {0xBCBC3275, 0xECEC21F3, 0x202043C6, 0xB3B3C9F4, 0xDADA03DB, 0x02028B7B,
-    0xE2E22BFB, 0x9E9EFAC8, 0xC9C9EC4A, 0xD4D409D3, 0x18186BE6, 0x1E1E9F6B,
-    0x98980E45, 0xB2B2387D, 0xA6A6D2E8, 0x2626B74B, 0x3C3C57D6, 0x93938A32,
-    0x8282EED8, 0x525298FD, 0x7B7BD437, 0xBBBB3771, 0x5B5B97F1, 0x474783E1,
-    0x24243C30, 0x5151E20F, 0xBABAC6F8, 0x4A4AF31B, 0xBFBF4887, 0x0D0D70FA,
-    0xB0B0B306, 0x7575DE3F, 0xD2D2FD5E, 0x7D7D20BA, 0x666631AE, 0x3A3AA35B,
-    0x59591C8A, 0x00000000, 0xCDCD93BC, 0x1A1AE09D, 0xAEAE2C6D, 0x7F7FABC1,
-    0x2B2BC7B1, 0xBEBEB90E, 0xE0E0A080, 0x8A8A105D, 0x3B3B52D2, 0x6464BAD5,
-    0xD8D888A0, 0xE7E7A584, 0x5F5FE807, 0x1B1B1114, 0x2C2CC2B5, 0xFCFCB490,
-    0x3131272C, 0x808065A3, 0x73732AB2, 0x0C0C8173, 0x79795F4C, 0x6B6B4154,
-    0x4B4B0292, 0x53536974, 0x94948F36, 0x83831F51, 0x2A2A3638, 0xC4C49CB0,
-    0x2222C8BD, 0xD5D5F85A, 0xBDBDC3FC, 0x48487860, 0xFFFFCE62, 0x4C4C0796,
-    0x4141776C, 0xC7C7E642, 0xEBEB24F7, 0x1C1C1410, 0x5D5D637C, 0x36362228,
-    0x6767C027, 0xE9E9AF8C, 0x4444F913, 0x1414EA95, 0xF5F5BB9C, 0xCFCF18C7,
-    0x3F3F2D24, 0xC0C0E346, 0x7272DB3B, 0x54546C70, 0x29294CCA, 0xF0F035E3,
-    0x0808FE85, 0xC6C617CB, 0xF3F34F11, 0x8C8CE4D0, 0xA4A45993, 0xCACA96B8,
-    0x68683BA6, 0xB8B84D83, 0x38382820, 0xE5E52EFF, 0xADAD569F, 0x0B0B8477,
-    0xC8C81DC3, 0x9999FFCC, 0x5858ED03, 0x19199A6F, 0x0E0E0A08, 0x95957EBF,
-    0x70705040, 0xF7F730E7, 0x6E6ECF2B, 0x1F1F6EE2, 0xB5B53D79, 0x09090F0C,
-    0x616134AA, 0x57571682, 0x9F9F0B41, 0x9D9D803A, 0x111164EA, 0x2525CDB9,
-    0xAFAFDDE4, 0x4545089A, 0xDFDF8DA4, 0xA3A35C97, 0xEAEAD57E, 0x353558DA,
-    0xEDEDD07A, 0x4343FC17, 0xF8F8CB66, 0xFBFBB194, 0x3737D3A1, 0xFAFA401D,
-    0xC2C2683D, 0xB4B4CCF0, 0x32325DDE, 0x9C9C71B3, 0x5656E70B, 0xE3E3DA72,
-    0x878760A7, 0x15151B1C, 0xF9F93AEF, 0x6363BFD1, 0x3434A953, 0x9A9A853E,
-    0xB1B1428F, 0x7C7CD133, 0x88889B26, 0x3D3DA65F, 0xA1A1D7EC, 0xE4E4DF76,
-    0x8181942A, 0x91910149, 0x0F0FFB81, 0xEEEEAA88, 0x161661EE, 0xD7D77321,
-    0x9797F5C4, 0xA5A5A81A, 0xFEFE3FEB, 0x6D6DB5D9, 0x7878AEC5, 0xC5C56D39,
-    0x1D1DE599, 0x7676A4CD, 0x3E3EDCAD, 0xCBCB6731, 0xB6B6478B, 0xEFEF5B01,
-    0x12121E18, 0x6060C523, 0x6A6AB0DD, 0x4D4DF61F, 0xCECEE94E, 0xDEDE7C2D,
-    0x55559DF9, 0x7E7E5A48, 0x2121B24F, 0x03037AF2, 0xA0A02665, 0x5E5E198E,
-    0x5A5A6678, 0x65654B5C, 0x62624E58, 0xFDFD4519, 0x0606F48D, 0x404086E5,
-    0xF2F2BE98, 0x3333AC57, 0x17179067, 0x05058E7F, 0xE8E85E05, 0x4F4F7D64,
-    0x89896AAF, 0x10109563, 0x74742FB6, 0x0A0A75FE, 0x5C5C92F5, 0x9B9B74B7,
-    0x2D2D333C, 0x3030D6A5, 0x2E2E49CE, 0x494989E9, 0x46467268, 0x77775544,
-    0xA8A8D8E0, 0x9696044D, 0x2828BD43, 0xA9A92969, 0xD9D97929, 0x8686912E,
-    0xD1D187AC, 0xF4F44A15, 0x8D8D1559, 0xD6D682A8, 0xB9B9BC0A, 0x42420D9E,
-    0xF6F6C16E, 0x2F2FB847, 0xDDDD06DF, 0x23233934, 0xCCCC6235, 0xF1F1C46A,
-    0xC1C112CF, 0x8585EBDC, 0x8F8F9E22, 0x7171A1C9, 0x9090F0C0, 0xAAAA539B,
-    0x0101F189, 0x8B8BE1D4, 0x4E4E8CED, 0x8E8E6FAB, 0xABABA212, 0x6F6F3EA2,
-    0xE6E6540D, 0xDBDBF252, 0x92927BBB, 0xB7B7B602, 0x6969CA2F, 0x3939D9A9,
-    0xD3D30CD7, 0xA7A72361, 0xA2A2AD1E, 0xC3C399B4, 0x6C6C4450, 0x07070504,
-    0x04047FF6, 0x272746C2, 0xACACA716, 0xD0D07625, 0x50501386, 0xDCDCF756,
-    0x84841A55, 0xE1E15109, 0x7A7A25BE, 0x1313EF91},
-
-   {0xA9D93939, 0x67901717, 0xB3719C9C, 0xE8D2A6A6, 0x04050707, 0xFD985252,
-    0xA3658080, 0x76DFE4E4, 0x9A084545, 0x92024B4B, 0x80A0E0E0, 0x78665A5A,
-    0xE4DDAFAF, 0xDDB06A6A, 0xD1BF6363, 0x38362A2A, 0x0D54E6E6, 0xC6432020,
-    0x3562CCCC, 0x98BEF2F2, 0x181E1212, 0xF724EBEB, 0xECD7A1A1, 0x6C774141,
-    0x43BD2828, 0x7532BCBC, 0x37D47B7B, 0x269B8888, 0xFA700D0D, 0x13F94444,
-    0x94B1FBFB, 0x485A7E7E, 0xF27A0303, 0xD0E48C8C, 0x8B47B6B6, 0x303C2424,
-    0x84A5E7E7, 0x54416B6B, 0xDF06DDDD, 0x23C56060, 0x1945FDFD, 0x5BA33A3A,
-    0x3D68C2C2, 0x59158D8D, 0xF321ECEC, 0xAE316666, 0xA23E6F6F, 0x82165757,
-    0x63951010, 0x015BEFEF, 0x834DB8B8, 0x2E918686, 0xD9B56D6D, 0x511F8383,
-    0x9B53AAAA, 0x7C635D5D, 0xA63B6868, 0xEB3FFEFE, 0xA5D63030, 0xBE257A7A,
-    0x16A7ACAC, 0x0C0F0909, 0xE335F0F0, 0x6123A7A7, 0xC0F09090, 0x8CAFE9E9,
-    0x3A809D9D, 0xF5925C5C, 0x73810C0C, 0x2C273131, 0x2576D0D0, 0x0BE75656,
-    0xBB7B9292, 0x4EE9CECE, 0x89F10101, 0x6B9F1E1E, 0x53A93434, 0x6AC4F1F1,
-    0xB499C3C3, 0xF1975B5B, 0xE1834747, 0xE66B1818, 0xBDC82222, 0x450E9898,
-    0xE26E1F1F, 0xF4C9B3B3, 0xB62F7474, 0x66CBF8F8, 0xCCFF9999, 0x95EA1414,
-    0x03ED5858, 0x56F7DCDC, 0xD4E18B8B, 0x1C1B1515, 0x1EADA2A2, 0xD70CD3D3,
-    0xFB2BE2E2, 0xC31DC8C8, 0x8E195E5E, 0xB5C22C2C, 0xE9894949, 0xCF12C1C1,
-    0xBF7E9595, 0xBA207D7D, 0xEA641111, 0x77840B0B, 0x396DC5C5, 0xAF6A8989,
-    0x33D17C7C, 0xC9A17171, 0x62CEFFFF, 0x7137BBBB, 0x81FB0F0F, 0x793DB5B5,
-    0x0951E1E1, 0xADDC3E3E, 0x242D3F3F, 0xCDA47676, 0xF99D5555, 0xD8EE8282,
-    0xE5864040, 0xC5AE7878, 0xB9CD2525, 0x4D049696, 0x44557777, 0x080A0E0E,
-    0x86135050, 0xE730F7F7, 0xA1D33737, 0x1D40FAFA, 0xAA346161, 0xED8C4E4E,
-    0x06B3B0B0, 0x706C5454, 0xB22A7373, 0xD2523B3B, 0x410B9F9F, 0x7B8B0202,
-    0xA088D8D8, 0x114FF3F3, 0x3167CBCB, 0xC2462727, 0x27C06767, 0x90B4FCFC,
-    0x20283838, 0xF67F0404, 0x60784848, 0xFF2EE5E5, 0x96074C4C, 0x5C4B6565,
-    0xB1C72B2B, 0xAB6F8E8E, 0x9E0D4242, 0x9CBBF5F5, 0x52F2DBDB, 0x1BF34A4A,
-    0x5FA63D3D, 0x9359A4A4, 0x0ABCB9B9, 0xEF3AF9F9, 0x91EF1313, 0x85FE0808,
-    0x49019191, 0xEE611616, 0x2D7CDEDE, 0x4FB22121, 0x8F42B1B1, 0x3BDB7272,
-    0x47B82F2F, 0x8748BFBF, 0x6D2CAEAE, 0x46E3C0C0, 0xD6573C3C, 0x3E859A9A,
-    0x6929A9A9, 0x647D4F4F, 0x2A948181, 0xCE492E2E, 0xCB17C6C6, 0x2FCA6969,
-    0xFCC3BDBD, 0x975CA3A3, 0x055EE8E8, 0x7AD0EDED, 0xAC87D1D1, 0x7F8E0505,
-    0xD5BA6464, 0x1AA8A5A5, 0x4BB72626, 0x0EB9BEBE, 0xA7608787, 0x5AF8D5D5,
-    0x28223636, 0x14111B1B, 0x3FDE7575, 0x2979D9D9, 0x88AAEEEE, 0x3C332D2D,
-    0x4C5F7979, 0x02B6B7B7, 0xB896CACA, 0xDA583535, 0xB09CC4C4, 0x17FC4343,
-    0x551A8484, 0x1FF64D4D, 0x8A1C5959, 0x7D38B2B2, 0x57AC3333, 0xC718CFCF,
-    0x8DF40606, 0x74695353, 0xB7749B9B, 0xC4F59797, 0x9F56ADAD, 0x72DAE3E3,
-    0x7ED5EAEA, 0x154AF4F4, 0x229E8F8F, 0x12A2ABAB, 0x584E6262, 0x07E85F5F,
-    0x99E51D1D, 0x34392323, 0x6EC1F6F6, 0x50446C6C, 0xDE5D3232, 0x68724646,
-    0x6526A0A0, 0xBC93CDCD, 0xDB03DADA, 0xF8C6BABA, 0xC8FA9E9E, 0xA882D6D6,
-    0x2BCF6E6E, 0x40507070, 0xDCEB8585, 0xFE750A0A, 0x328A9393, 0xA48DDFDF,
-    0xCA4C2929, 0x10141C1C, 0x2173D7D7, 0xF0CCB4B4, 0xD309D4D4, 0x5D108A8A,
-    0x0FE25151, 0x00000000, 0x6F9A1919, 0x9DE01A1A, 0x368F9494, 0x42E6C7C7,
-    0x4AECC9C9, 0x5EFDD2D2, 0xC1AB7F7F, 0xE0D8A8A8},
-
-   {0xBC75BC32, 0xECF3EC21, 0x20C62043, 0xB3F4B3C9, 0xDADBDA03, 0x027B028B,
-    0xE2FBE22B, 0x9EC89EFA, 0xC94AC9EC, 0xD4D3D409, 0x18E6186B, 0x1E6B1E9F,
-    0x9845980E, 0xB27DB238, 0xA6E8A6D2, 0x264B26B7, 0x3CD63C57, 0x9332938A,
-    0x82D882EE, 0x52FD5298, 0x7B377BD4, 0xBB71BB37, 0x5BF15B97, 0x47E14783,
-    0x2430243C, 0x510F51E2, 0xBAF8BAC6, 0x4A1B4AF3, 0xBF87BF48, 0x0DFA0D70,
-    0xB006B0B3, 0x753F75DE, 0xD25ED2FD, 0x7DBA7D20, 0x66AE6631, 0x3A5B3AA3,
-    0x598A591C, 0x00000000, 0xCDBCCD93, 0x1A9D1AE0, 0xAE6DAE2C, 0x7FC17FAB,
-    0x2BB12BC7, 0xBE0EBEB9, 0xE080E0A0, 0x8A5D8A10, 0x3BD23B52, 0x64D564BA,
-    0xD8A0D888, 0xE784E7A5, 0x5F075FE8, 0x1B141B11, 0x2CB52CC2, 0xFC90FCB4,
-    0x312C3127, 0x80A38065, 0x73B2732A, 0x0C730C81, 0x794C795F, 0x6B546B41,
-    0x4B924B02, 0x53745369, 0x9436948F, 0x8351831F, 0x2A382A36, 0xC4B0C49C,
-    0x22BD22C8, 0xD55AD5F8, 0xBDFCBDC3, 0x48604878, 0xFF62FFCE, 0x4C964C07,
-    0x416C4177, 0xC742C7E6, 0xEBF7EB24, 0x1C101C14, 0x5D7C5D63, 0x36283622,
-    0x672767C0, 0xE98CE9AF, 0x441344F9, 0x149514EA, 0xF59CF5BB, 0xCFC7CF18,
-    0x3F243F2D, 0xC046C0E3, 0x723B72DB, 0x5470546C, 0x29CA294C, 0xF0E3F035,
-    0x088508FE, 0xC6CBC617, 0xF311F34F, 0x8CD08CE4, 0xA493A459, 0xCAB8CA96,
-    0x68A6683B, 0xB883B84D, 0x38203828, 0xE5FFE52E, 0xAD9FAD56, 0x0B770B84,
-    0xC8C3C81D, 0x99CC99FF, 0x580358ED, 0x196F199A, 0x0E080E0A, 0x95BF957E,
-    0x70407050, 0xF7E7F730, 0x6E2B6ECF, 0x1FE21F6E, 0xB579B53D, 0x090C090F,
-    0x61AA6134, 0x57825716, 0x9F419F0B, 0x9D3A9D80, 0x11EA1164, 0x25B925CD,
-    0xAFE4AFDD, 0x459A4508, 0xDFA4DF8D, 0xA397A35C, 0xEA7EEAD5, 0x35DA3558,
-    0xED7AEDD0, 0x431743FC, 0xF866F8CB, 0xFB94FBB1, 0x37A137D3, 0xFA1DFA40,
-    0xC23DC268, 0xB4F0B4CC, 0x32DE325D, 0x9CB39C71, 0x560B56E7, 0xE372E3DA,
-    0x87A78760, 0x151C151B, 0xF9EFF93A, 0x63D163BF, 0x345334A9, 0x9A3E9A85,
-    0xB18FB142, 0x7C337CD1, 0x8826889B, 0x3D5F3DA6, 0xA1ECA1D7, 0xE476E4DF,
-    0x812A8194, 0x91499101, 0x0F810FFB, 0xEE88EEAA, 0x16EE1661, 0xD721D773,
-    0x97C497F5, 0xA51AA5A8, 0xFEEBFE3F, 0x6DD96DB5, 0x78C578AE, 0xC539C56D,
-    0x1D991DE5, 0x76CD76A4, 0x3EAD3EDC, 0xCB31CB67, 0xB68BB647, 0xEF01EF5B,
-    0x1218121E, 0x602360C5, 0x6ADD6AB0, 0x4D1F4DF6, 0xCE4ECEE9, 0xDE2DDE7C,
-    0x55F9559D, 0x7E487E5A, 0x214F21B2, 0x03F2037A, 0xA065A026, 0x5E8E5E19,
-    0x5A785A66, 0x655C654B, 0x6258624E, 0xFD19FD45, 0x068D06F4, 0x40E54086,
-    0xF298F2BE, 0x335733AC, 0x17671790, 0x057F058E, 0xE805E85E, 0x4F644F7D,
-    0x89AF896A, 0x10631095, 0x74B6742F, 0x0AFE0A75, 0x5CF55C92, 0x9BB79B74,
-    0x2D3C2D33, 0x30A530D6, 0x2ECE2E49, 0x49E94989, 0x46684672, 0x77447755,
-    0xA8E0A8D8, 0x964D9604, 0x284328BD, 0xA969A929, 0xD929D979, 0x862E8691,
-    0xD1ACD187, 0xF415F44A, 0x8D598D15, 0xD6A8D682, 0xB90AB9BC, 0x429E420D,
-    0xF66EF6C1, 0x2F472FB8, 0xDDDFDD06, 0x23342339, 0xCC35CC62, 0xF16AF1C4,
-    0xC1CFC112, 0x85DC85EB, 0x8F228F9E, 0x71C971A1, 0x90C090F0, 0xAA9BAA53,
-    0x018901F1, 0x8BD48BE1, 0x4EED4E8C, 0x8EAB8E6F, 0xAB12ABA2, 0x6FA26F3E,
-    0xE60DE654, 0xDB52DBF2, 0x92BB927B, 0xB702B7B6, 0x692F69CA, 0x39A939D9,
-    0xD3D7D30C, 0xA761A723, 0xA21EA2AD, 0xC3B4C399, 0x6C506C44, 0x07040705,
-    0x04F6047F, 0x27C22746, 0xAC16ACA7, 0xD025D076, 0x50865013, 0xDC56DCF7,
-    0x8455841A, 0xE109E151, 0x7ABE7A25, 0x139113EF},
-
-   {0xD939A9D9, 0x90176790, 0x719CB371, 0xD2A6E8D2, 0x05070405, 0x9852FD98,
-    0x6580A365, 0xDFE476DF, 0x08459A08, 0x024B9202, 0xA0E080A0, 0x665A7866,
-    0xDDAFE4DD, 0xB06ADDB0, 0xBF63D1BF, 0x362A3836, 0x54E60D54, 0x4320C643,
-    0x62CC3562, 0xBEF298BE, 0x1E12181E, 0x24EBF724, 0xD7A1ECD7, 0x77416C77,
-    0xBD2843BD, 0x32BC7532, 0xD47B37D4, 0x9B88269B, 0x700DFA70, 0xF94413F9,
-    0xB1FB94B1, 0x5A7E485A, 0x7A03F27A, 0xE48CD0E4, 0x47B68B47, 0x3C24303C,
-    0xA5E784A5, 0x416B5441, 0x06DDDF06, 0xC56023C5, 0x45FD1945, 0xA33A5BA3,
-    0x68C23D68, 0x158D5915, 0x21ECF321, 0x3166AE31, 0x3E6FA23E, 0x16578216,
-    0x95106395, 0x5BEF015B, 0x4DB8834D, 0x91862E91, 0xB56DD9B5, 0x1F83511F,
-    0x53AA9B53, 0x635D7C63, 0x3B68A63B, 0x3FFEEB3F, 0xD630A5D6, 0x257ABE25,
-    0xA7AC16A7, 0x0F090C0F, 0x35F0E335, 0x23A76123, 0xF090C0F0, 0xAFE98CAF,
-    0x809D3A80, 0x925CF592, 0x810C7381, 0x27312C27, 0x76D02576, 0xE7560BE7,
-    0x7B92BB7B, 0xE9CE4EE9, 0xF10189F1, 0x9F1E6B9F, 0xA93453A9, 0xC4F16AC4,
-    0x99C3B499, 0x975BF197, 0x8347E183, 0x6B18E66B, 0xC822BDC8, 0x0E98450E,
-    0x6E1FE26E, 0xC9B3F4C9, 0x2F74B62F, 0xCBF866CB, 0xFF99CCFF, 0xEA1495EA,
-    0xED5803ED, 0xF7DC56F7, 0xE18BD4E1, 0x1B151C1B, 0xADA21EAD, 0x0CD3D70C,
-    0x2BE2FB2B, 0x1DC8C31D, 0x195E8E19, 0xC22CB5C2, 0x8949E989, 0x12C1CF12,
-    0x7E95BF7E, 0x207DBA20, 0x6411EA64, 0x840B7784, 0x6DC5396D, 0x6A89AF6A,
-    0xD17C33D1, 0xA171C9A1, 0xCEFF62CE, 0x37BB7137, 0xFB0F81FB, 0x3DB5793D,
-    0x51E10951, 0xDC3EADDC, 0x2D3F242D, 0xA476CDA4, 0x9D55F99D, 0xEE82D8EE,
-    0x8640E586, 0xAE78C5AE, 0xCD25B9CD, 0x04964D04, 0x55774455, 0x0A0E080A,
-    0x13508613, 0x30F7E730, 0xD337A1D3, 0x40FA1D40, 0x3461AA34, 0x8C4EED8C,
-    0xB3B006B3, 0x6C54706C, 0x2A73B22A, 0x523BD252, 0x0B9F410B, 0x8B027B8B,
-    0x88D8A088, 0x4FF3114F, 0x67CB3167, 0x4627C246, 0xC06727C0, 0xB4FC90B4,
-    0x28382028, 0x7F04F67F, 0x78486078, 0x2EE5FF2E, 0x074C9607, 0x4B655C4B,
-    0xC72BB1C7, 0x6F8EAB6F, 0x0D429E0D, 0xBBF59CBB, 0xF2DB52F2, 0xF34A1BF3,
-    0xA63D5FA6, 0x59A49359, 0xBCB90ABC, 0x3AF9EF3A, 0xEF1391EF, 0xFE0885FE,
-    0x01914901, 0x6116EE61, 0x7CDE2D7C, 0xB2214FB2, 0x42B18F42, 0xDB723BDB,
-    0xB82F47B8, 0x48BF8748, 0x2CAE6D2C, 0xE3C046E3, 0x573CD657, 0x859A3E85,
-    0x29A96929, 0x7D4F647D, 0x94812A94, 0x492ECE49, 0x17C6CB17, 0xCA692FCA,
-    0xC3BDFCC3, 0x5CA3975C, 0x5EE8055E, 0xD0ED7AD0, 0x87D1AC87, 0x8E057F8E,
-    0xBA64D5BA, 0xA8A51AA8, 0xB7264BB7, 0xB9BE0EB9, 0x6087A760, 0xF8D55AF8,
-    0x22362822, 0x111B1411, 0xDE753FDE, 0x79D92979, 0xAAEE88AA, 0x332D3C33,
-    0x5F794C5F, 0xB6B702B6, 0x96CAB896, 0x5835DA58, 0x9CC4B09C, 0xFC4317FC,
-    0x1A84551A, 0xF64D1FF6, 0x1C598A1C, 0x38B27D38, 0xAC3357AC, 0x18CFC718,
-    0xF4068DF4, 0x69537469, 0x749BB774, 0xF597C4F5, 0x56AD9F56, 0xDAE372DA,
-    0xD5EA7ED5, 0x4AF4154A, 0x9E8F229E, 0xA2AB12A2, 0x4E62584E, 0xE85F07E8,
-    0xE51D99E5, 0x39233439, 0xC1F66EC1, 0x446C5044, 0x5D32DE5D, 0x72466872,
-    0x26A06526, 0x93CDBC93, 0x03DADB03, 0xC6BAF8C6, 0xFA9EC8FA, 0x82D6A882,
-    0xCF6E2BCF, 0x50704050, 0xEB85DCEB, 0x750AFE75, 0x8A93328A, 0x8DDFA48D,
-    0x4C29CA4C, 0x141C1014, 0x73D72173, 0xCCB4F0CC, 0x09D4D309, 0x108A5D10,
-    0xE2510FE2, 0x00000000, 0x9A196F9A, 0xE01A9DE0, 0x8F94368F, 0xE6C742E6,
-    0xECC94AEC, 0xFDD25EFD, 0xAB7FC1AB, 0xD8A8E0D8}
-};
-
-/* The exp_to_poly and poly_to_exp tables are used to perform efficient
- * operations in GF(2^8) represented as GF(2)[x]/w(x) where
- * w(x)=x^8+x^6+x^3+x^2+1.  We care about doing that because it's part of the
- * definition of the RS matrix in the key schedule.  Elements of that field
- * are polynomials of degree not greater than 7 and all coefficients 0 or 1,
- * which can be represented naturally by bytes (just substitute x=2).  In that
- * form, GF(2^8) addition is the same as bitwise XOR, but GF(2^8)
- * multiplication is inefficient without hardware support.  To multiply
- * faster, I make use of the fact x is a generator for the nonzero elements,
- * so that every element p of GF(2)[x]/w(x) is either 0 or equal to (x)^n for
- * some n in 0..254.  Note that that caret is exponentiation in GF(2^8),
- * *not* polynomial notation.  So if I want to compute pq where p and q are
- * in GF(2^8), I can just say:
- *    1. if p=0 or q=0 then pq=0
- *    2. otherwise, find m and n such that p=x^m and q=x^n
- *    3. pq=(x^m)(x^n)=x^(m+n), so add m and n and find pq
- * The translations in steps 2 and 3 are looked up in the tables
- * poly_to_exp (for step 2) and exp_to_poly (for step 3).  To see this
- * in action, look at the CALC_S macro.  As additional wrinkles, note that
- * one of my operands is always a constant, so the poly_to_exp lookup on it
- * is done in advance; I included the original values in the comments so
- * readers can have some chance of recognizing that this *is* the RS matrix
- * from the Twofish paper.  I've only included the table entries I actually
- * need; I never do a lookup on a variable input of zero and the biggest
- * exponents I'll ever see are 254 (variable) and 237 (constant), so they'll
- * never sum to more than 491.	I'm repeating part of the exp_to_poly table
- * so that I don't have to do mod-255 reduction in the exponent arithmetic.
- * Since I know my constant operands are never zero, I only have to worry
- * about zero values in the variable operand, and I do it with a simple
- * conditional branch.	I know conditionals are expensive, but I couldn't
- * see a non-horrible way of avoiding them, and I did manage to group the
- * statements so that each if covers four group multiplications. */
-
-static const u8 poly_to_exp[255] = {
-   0x00, 0x01, 0x17, 0x02, 0x2E, 0x18, 0x53, 0x03, 0x6A, 0x2F, 0x93, 0x19,
-   0x34, 0x54, 0x45, 0x04, 0x5C, 0x6B, 0xB6, 0x30, 0xA6, 0x94, 0x4B, 0x1A,
-   0x8C, 0x35, 0x81, 0x55, 0xAA, 0x46, 0x0D, 0x05, 0x24, 0x5D, 0x87, 0x6C,
-   0x9B, 0xB7, 0xC1, 0x31, 0x2B, 0xA7, 0xA3, 0x95, 0x98, 0x4C, 0xCA, 0x1B,
-   0xE6, 0x8D, 0x73, 0x36, 0xCD, 0x82, 0x12, 0x56, 0x62, 0xAB, 0xF0, 0x47,
-   0x4F, 0x0E, 0xBD, 0x06, 0xD4, 0x25, 0xD2, 0x5E, 0x27, 0x88, 0x66, 0x6D,
-   0xD6, 0x9C, 0x79, 0xB8, 0x08, 0xC2, 0xDF, 0x32, 0x68, 0x2C, 0xFD, 0xA8,
-   0x8A, 0xA4, 0x5A, 0x96, 0x29, 0x99, 0x22, 0x4D, 0x60, 0xCB, 0xE4, 0x1C,
-   0x7B, 0xE7, 0x3B, 0x8E, 0x9E, 0x74, 0xF4, 0x37, 0xD8, 0xCE, 0xF9, 0x83,
-   0x6F, 0x13, 0xB2, 0x57, 0xE1, 0x63, 0xDC, 0xAC, 0xC4, 0xF1, 0xAF, 0x48,
-   0x0A, 0x50, 0x42, 0x0F, 0xBA, 0xBE, 0xC7, 0x07, 0xDE, 0xD5, 0x78, 0x26,
-   0x65, 0xD3, 0xD1, 0x5F, 0xE3, 0x28, 0x21, 0x89, 0x59, 0x67, 0xFC, 0x6E,
-   0xB1, 0xD7, 0xF8, 0x9D, 0xF3, 0x7A, 0x3A, 0xB9, 0xC6, 0x09, 0x41, 0xC3,
-   0xAE, 0xE0, 0xDB, 0x33, 0x44, 0x69, 0x92, 0x2D, 0x52, 0xFE, 0x16, 0xA9,
-   0x0C, 0x8B, 0x80, 0xA5, 0x4A, 0x5B, 0xB5, 0x97, 0xC9, 0x2A, 0xA2, 0x9A,
-   0xC0, 0x23, 0x86, 0x4E, 0xBC, 0x61, 0xEF, 0xCC, 0x11, 0xE5, 0x72, 0x1D,
-   0x3D, 0x7C, 0xEB, 0xE8, 0xE9, 0x3C, 0xEA, 0x8F, 0x7D, 0x9F, 0xEC, 0x75,
-   0x1E, 0xF5, 0x3E, 0x38, 0xF6, 0xD9, 0x3F, 0xCF, 0x76, 0xFA, 0x1F, 0x84,
-   0xA0, 0x70, 0xED, 0x14, 0x90, 0xB3, 0x7E, 0x58, 0xFB, 0xE2, 0x20, 0x64,
-   0xD0, 0xDD, 0x77, 0xAD, 0xDA, 0xC5, 0x40, 0xF2, 0x39, 0xB0, 0xF7, 0x49,
-   0xB4, 0x0B, 0x7F, 0x51, 0x15, 0x43, 0x91, 0x10, 0x71, 0xBB, 0xEE, 0xBF,
-   0x85, 0xC8, 0xA1
-};
-
-static const u8 exp_to_poly[492] = {
-   0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D, 0x9A, 0x79, 0xF2,
-   0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC, 0xF5, 0xA7, 0x03,
-   0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3, 0x8B, 0x5B, 0xB6,
-   0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52, 0xA4, 0x05, 0x0A,
-   0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0, 0xED, 0x97, 0x63,
-   0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1, 0x0F, 0x1E, 0x3C,
-   0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A, 0xF4, 0xA5, 0x07,
-   0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11, 0x22, 0x44, 0x88,
-   0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51, 0xA2, 0x09, 0x12,
-   0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66, 0xCC, 0xD5, 0xE7,
-   0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB, 0x1B, 0x36, 0x6C,
-   0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19, 0x32, 0x64, 0xC8,
-   0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D, 0x5A, 0xB4, 0x25,
-   0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56, 0xAC, 0x15, 0x2A,
-   0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE, 0x91, 0x6F, 0xDE,
-   0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9, 0x3F, 0x7E, 0xFC,
-   0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE, 0xB1, 0x2F, 0x5E,
-   0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41, 0x82, 0x49, 0x92,
-   0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E, 0x71, 0xE2, 0x89,
-   0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB, 0xDB, 0xFB, 0xBB,
-   0x3B, 0x76, 0xEC, 0x95, 0x67, 0xCE, 0xD1, 0xEF, 0x93, 0x6B, 0xD6, 0xE1,
-   0x8F, 0x53, 0xA6, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D,
-   0x9A, 0x79, 0xF2, 0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC,
-   0xF5, 0xA7, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3,
-   0x8B, 0x5B, 0xB6, 0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52,
-   0xA4, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0,
-   0xED, 0x97, 0x63, 0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1,
-   0x0F, 0x1E, 0x3C, 0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A,
-   0xF4, 0xA5, 0x07, 0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11,
-   0x22, 0x44, 0x88, 0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51,
-   0xA2, 0x09, 0x12, 0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66,
-   0xCC, 0xD5, 0xE7, 0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB,
-   0x1B, 0x36, 0x6C, 0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19,
-   0x32, 0x64, 0xC8, 0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D,
-   0x5A, 0xB4, 0x25, 0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56,
-   0xAC, 0x15, 0x2A, 0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE,
-   0x91, 0x6F, 0xDE, 0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9,
-   0x3F, 0x7E, 0xFC, 0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE,
-   0xB1, 0x2F, 0x5E, 0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41,
-   0x82, 0x49, 0x92, 0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E,
-   0x71, 0xE2, 0x89, 0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB
-};
-
-
-/* The table constants are indices of
- * S-box entries, preprocessed through q0 and q1. */
-static const u8 calc_sb_tbl[512] = {
-    0xA9, 0x75, 0x67, 0xF3, 0xB3, 0xC6, 0xE8, 0xF4,
-    0x04, 0xDB, 0xFD, 0x7B, 0xA3, 0xFB, 0x76, 0xC8,
-    0x9A, 0x4A, 0x92, 0xD3, 0x80, 0xE6, 0x78, 0x6B,
-    0xE4, 0x45, 0xDD, 0x7D, 0xD1, 0xE8, 0x38, 0x4B,
-    0x0D, 0xD6, 0xC6, 0x32, 0x35, 0xD8, 0x98, 0xFD,
-    0x18, 0x37, 0xF7, 0x71, 0xEC, 0xF1, 0x6C, 0xE1,
-    0x43, 0x30, 0x75, 0x0F, 0x37, 0xF8, 0x26, 0x1B,
-    0xFA, 0x87, 0x13, 0xFA, 0x94, 0x06, 0x48, 0x3F,
-    0xF2, 0x5E, 0xD0, 0xBA, 0x8B, 0xAE, 0x30, 0x5B,
-    0x84, 0x8A, 0x54, 0x00, 0xDF, 0xBC, 0x23, 0x9D,
-    0x19, 0x6D, 0x5B, 0xC1, 0x3D, 0xB1, 0x59, 0x0E,
-    0xF3, 0x80, 0xAE, 0x5D, 0xA2, 0xD2, 0x82, 0xD5,
-    0x63, 0xA0, 0x01, 0x84, 0x83, 0x07, 0x2E, 0x14,
-    0xD9, 0xB5, 0x51, 0x90, 0x9B, 0x2C, 0x7C, 0xA3,
-    0xA6, 0xB2, 0xEB, 0x73, 0xA5, 0x4C, 0xBE, 0x54,
-    0x16, 0x92, 0x0C, 0x74, 0xE3, 0x36, 0x61, 0x51,
-    0xC0, 0x38, 0x8C, 0xB0, 0x3A, 0xBD, 0xF5, 0x5A,
-    0x73, 0xFC, 0x2C, 0x60, 0x25, 0x62, 0x0B, 0x96,
-    0xBB, 0x6C, 0x4E, 0x42, 0x89, 0xF7, 0x6B, 0x10,
-    0x53, 0x7C, 0x6A, 0x28, 0xB4, 0x27, 0xF1, 0x8C,
-    0xE1, 0x13, 0xE6, 0x95, 0xBD, 0x9C, 0x45, 0xC7,
-    0xE2, 0x24, 0xF4, 0x46, 0xB6, 0x3B, 0x66, 0x70,
-    0xCC, 0xCA, 0x95, 0xE3, 0x03, 0x85, 0x56, 0xCB,
-    0xD4, 0x11, 0x1C, 0xD0, 0x1E, 0x93, 0xD7, 0xB8,
-    0xFB, 0xA6, 0xC3, 0x83, 0x8E, 0x20, 0xB5, 0xFF,
-    0xE9, 0x9F, 0xCF, 0x77, 0xBF, 0xC3, 0xBA, 0xCC,
-    0xEA, 0x03, 0x77, 0x6F, 0x39, 0x08, 0xAF, 0xBF,
-    0x33, 0x40, 0xC9, 0xE7, 0x62, 0x2B, 0x71, 0xE2,
-    0x81, 0x79, 0x79, 0x0C, 0x09, 0xAA, 0xAD, 0x82,
-    0x24, 0x41, 0xCD, 0x3A, 0xF9, 0xEA, 0xD8, 0xB9,
-    0xE5, 0xE4, 0xC5, 0x9A, 0xB9, 0xA4, 0x4D, 0x97,
-    0x44, 0x7E, 0x08, 0xDA, 0x86, 0x7A, 0xE7, 0x17,
-    0xA1, 0x66, 0x1D, 0x94, 0xAA, 0xA1, 0xED, 0x1D,
-    0x06, 0x3D, 0x70, 0xF0, 0xB2, 0xDE, 0xD2, 0xB3,
-    0x41, 0x0B, 0x7B, 0x72, 0xA0, 0xA7, 0x11, 0x1C,
-    0x31, 0xEF, 0xC2, 0xD1, 0x27, 0x53, 0x90, 0x3E,
-    0x20, 0x8F, 0xF6, 0x33, 0x60, 0x26, 0xFF, 0x5F,
-    0x96, 0xEC, 0x5C, 0x76, 0xB1, 0x2A, 0xAB, 0x49,
-    0x9E, 0x81, 0x9C, 0x88, 0x52, 0xEE, 0x1B, 0x21,
-    0x5F, 0xC4, 0x93, 0x1A, 0x0A, 0xEB, 0xEF, 0xD9,
-    0x91, 0xC5, 0x85, 0x39, 0x49, 0x99, 0xEE, 0xCD,
-    0x2D, 0xAD, 0x4F, 0x31, 0x8F, 0x8B, 0x3B, 0x01,
-    0x47, 0x18, 0x87, 0x23, 0x6D, 0xDD, 0x46, 0x1F,
-    0xD6, 0x4E, 0x3E, 0x2D, 0x69, 0xF9, 0x64, 0x48,
-    0x2A, 0x4F, 0xCE, 0xF2, 0xCB, 0x65, 0x2F, 0x8E,
-    0xFC, 0x78, 0x97, 0x5C, 0x05, 0x58, 0x7A, 0x19,
-    0xAC, 0x8D, 0x7F, 0xE5, 0xD5, 0x98, 0x1A, 0x57,
-    0x4B, 0x67, 0x0E, 0x7F, 0xA7, 0x05, 0x5A, 0x64,
-    0x28, 0xAF, 0x14, 0x63, 0x3F, 0xB6, 0x29, 0xFE,
-    0x88, 0xF5, 0x3C, 0xB7, 0x4C, 0x3C, 0x02, 0xA5,
-    0xB8, 0xCE, 0xDA, 0xE9, 0xB0, 0x68, 0x17, 0x44,
-    0x55, 0xE0, 0x1F, 0x4D, 0x8A, 0x43, 0x7D, 0x69,
-    0x57, 0x29, 0xC7, 0x2E, 0x8D, 0xAC, 0x74, 0x15,
-    0xB7, 0x59, 0xC4, 0xA8, 0x9F, 0x0A, 0x72, 0x9E,
-    0x7E, 0x6E, 0x15, 0x47, 0x22, 0xDF, 0x12, 0x34,
-    0x58, 0x35, 0x07, 0x6A, 0x99, 0xCF, 0x34, 0xDC,
-    0x6E, 0x22, 0x50, 0xC9, 0xDE, 0xC0, 0x68, 0x9B,
-    0x65, 0x89, 0xBC, 0xD4, 0xDB, 0xED, 0xF8, 0xAB,
-    0xC8, 0x12, 0xA8, 0xA2, 0x2B, 0x0D, 0x40, 0x52,
-    0xDC, 0xBB, 0xFE, 0x02, 0x32, 0x2F, 0xA4, 0xA9,
-    0xCA, 0xD7, 0x10, 0x61, 0x21, 0x1E, 0xF0, 0xB4,
-    0xD3, 0x50, 0x5D, 0x04, 0x0F, 0xF6, 0x00, 0xC2,
-    0x6F, 0x16, 0x9D, 0x25, 0x36, 0x86, 0x42, 0x56,
-    0x4A, 0x55, 0x5E, 0x09, 0xC1, 0xBE, 0xE0, 0x91
-};
-
-/* Macro to perform one column of the RS matrix multiplication.  The
- * parameters a, b, c, and d are the four bytes of output; i is the index
- * of the key bytes, and w, x, y, and z, are the column of constants from
- * the RS matrix, preprocessed through the poly_to_exp table. */
-
-#define CALC_S(a, b, c, d, i, w, x, y, z) \
-   if (key[i]) { \
-      tmp = poly_to_exp[key[i] - 1]; \
-      (a) ^= exp_to_poly[tmp + (w)]; \
-      (b) ^= exp_to_poly[tmp + (x)]; \
-      (c) ^= exp_to_poly[tmp + (y)]; \
-      (d) ^= exp_to_poly[tmp + (z)]; \
-   }
-
-/* Macros to calculate the key-dependent S-boxes for a 128-bit key using
- * the S vector from CALC_S.  CALC_SB_2 computes a single entry in all
- * four S-boxes, where i is the index of the entry to compute, and a and b
- * are the index numbers preprocessed through the q0 and q1 tables
- * respectively. */
-
-#define CALC_SB_2(i, a, b) \
-   ctx-&gt;s[0][i] = mds[0][q0[(a) ^ sa] ^ se]; \
-   ctx-&gt;s[1][i] = mds[1][q0[(b) ^ sb] ^ sf]; \
-   ctx-&gt;s[2][i] = mds[2][q1[(a) ^ sc] ^ sg]; \
-   ctx-&gt;s[3][i] = mds[3][q1[(b) ^ sd] ^ sh]
-
-/* Macro exactly like CALC_SB_2, but for 192-bit keys. */
-
-#define CALC_SB192_2(i, a, b) \
-   ctx-&gt;s[0][i] = mds[0][q0[q0[(b) ^ sa] ^ se] ^ si]; \
-   ctx-&gt;s[1][i] = mds[1][q0[q1[(b) ^ sb] ^ sf] ^ sj]; \
-   ctx-&gt;s[2][i] = mds[2][q1[q0[(a) ^ sc] ^ sg] ^ sk]; \
-   ctx-&gt;s[3][i] = mds[3][q1[q1[(a) ^ sd] ^ sh] ^ sl];
-
-/* Macro exactly like CALC_SB_2, but for 256-bit keys. */
-
-#define CALC_SB256_2(i, a, b) \
-   ctx-&gt;s[0][i] = mds[0][q0[q0[q1[(b) ^ sa] ^ se] ^ si] ^ sm]; \
-   ctx-&gt;s[1][i] = mds[1][q0[q1[q1[(a) ^ sb] ^ sf] ^ sj] ^ sn]; \
-   ctx-&gt;s[2][i] = mds[2][q1[q0[q0[(a) ^ sc] ^ sg] ^ sk] ^ so]; \
-   ctx-&gt;s[3][i] = mds[3][q1[q1[q0[(b) ^ sd] ^ sh] ^ sl] ^ sp];
-
-/* Macros to calculate the whitening and round subkeys.  CALC_K_2 computes the
- * last two stages of the h() function for a given index (either 2i or 2i+1).
- * a, b, c, and d are the four bytes going into the last two stages.  For
- * 128-bit keys, this is the entire h() function and a and c are the index
- * preprocessed through q0 and q1 respectively; for longer keys they are the
- * output of previous stages.  j is the index of the first key byte to use.
- * CALC_K computes a pair of subkeys for 128-bit Twofish, by calling CALC_K_2
- * twice, doing the Pseudo-Hadamard Transform, and doing the necessary
- * rotations.  Its parameters are: a, the array to write the results into,
- * j, the index of the first output entry, k and l, the preprocessed indices
- * for index 2i, and m and n, the preprocessed indices for index 2i+1.
- * CALC_K192_2 expands CALC_K_2 to handle 192-bit keys, by doing an
- * additional lookup-and-XOR stage.  The parameters a, b, c and d are the
- * four bytes going into the last three stages.  For 192-bit keys, c = d
- * are the index preprocessed through q0, and a = b are the index
- * preprocessed through q1; j is the index of the first key byte to use.
- * CALC_K192 is identical to CALC_K but for using the CALC_K192_2 macro
- * instead of CALC_K_2.
- * CALC_K256_2 expands CALC_K192_2 to handle 256-bit keys, by doing an
- * additional lookup-and-XOR stage.  The parameters a and b are the index
- * preprocessed through q0 and q1 respectively; j is the index of the first
- * key byte to use.  CALC_K256 is identical to CALC_K but for using the
- * CALC_K256_2 macro instead of CALC_K_2. */
-
-#define CALC_K_2(a, b, c, d, j) \
-     mds[0][q0[a ^ key[(j) + 8]] ^ key[j]] \
-   ^ mds[1][q0[b ^ key[(j) + 9]] ^ key[(j) + 1]] \
-   ^ mds[2][q1[c ^ key[(j) + 10]] ^ key[(j) + 2]] \
-   ^ mds[3][q1[d ^ key[(j) + 11]] ^ key[(j) + 3]]
-
-#define CALC_K(a, j, k, l, m, n) \
-   x = CALC_K_2 (k, l, k, l, 0); \
-   y = CALC_K_2 (m, n, m, n, 4); \
-   y = rol32(y, 8); \
-   x += y; y += x; ctx-&gt;a[j] = x; \
-   ctx-&gt;a[(j) + 1] = rol32(y, 9)
-
-#define CALC_K192_2(a, b, c, d, j) \
-   CALC_K_2 (q0[a ^ key[(j) + 16]], \
-	     q1[b ^ key[(j) + 17]], \
-	     q0[c ^ key[(j) + 18]], \
-	     q1[d ^ key[(j) + 19]], j)
-
-#define CALC_K192(a, j, k, l, m, n) \
-   x = CALC_K192_2 (l, l, k, k, 0); \
-   y = CALC_K192_2 (n, n, m, m, 4); \
-   y = rol32(y, 8); \
-   x += y; y += x; ctx-&gt;a[j] = x; \
-   ctx-&gt;a[(j) + 1] = rol32(y, 9)
-
-#define CALC_K256_2(a, b, j) \
-   CALC_K192_2 (q1[b ^ key[(j) + 24]], \
-	        q1[a ^ key[(j) + 25]], \
-	        q0[a ^ key[(j) + 26]], \
-	        q0[b ^ key[(j) + 27]], j)
-
-#define CALC_K256(a, j, k, l, m, n) \
-   x = CALC_K256_2 (k, l, 0); \
-   y = CALC_K256_2 (m, n, 4); \
-   y = rol32(y, 8); \
-   x += y; y += x; ctx-&gt;a[j] = x; \
-   ctx-&gt;a[(j) + 1] = rol32(y, 9)
-
-
-/* Macros to compute the g() function in the encryption and decryption
- * rounds.  G1 is the straight g() function; G2 includes the 8-bit
- * rotation for the high 32-bit word. */
-
-#define G1(a) \
-     (ctx-&gt;s[0][(a) &amp; 0xFF]) ^ (ctx-&gt;s[1][((a) &gt;&gt; 8) &amp; 0xFF]) \
-   ^ (ctx-&gt;s[2][((a) &gt;&gt; 16) &amp; 0xFF]) ^ (ctx-&gt;s[3][(a) &gt;&gt; 24])
-
-#define G2(b) \
-     (ctx-&gt;s[1][(b) &amp; 0xFF]) ^ (ctx-&gt;s[2][((b) &gt;&gt; 8) &amp; 0xFF]) \
-   ^ (ctx-&gt;s[3][((b) &gt;&gt; 16) &amp; 0xFF]) ^ (ctx-&gt;s[0][(b) &gt;&gt; 24])
-
-/* Encryption and decryption Feistel rounds.  Each one calls the two g()
- * macros, does the PHT, and performs the XOR and the appropriate bit
- * rotations.  The parameters are the round number (used to select subkeys),
- * and the four 32-bit chunks of the text. */
-
-#define ENCROUND(n, a, b, c, d) \
-   x = G1 (a); y = G2 (b); \
-   x += y; y += x + ctx-&gt;k[2 * (n) + 1]; \
-   (c) ^= x + ctx-&gt;k[2 * (n)]; \
-   (c) = ror32((c), 1); \
-   (d) = rol32((d), 1) ^ y
-
-#define DECROUND(n, a, b, c, d) \
-   x = G1 (a); y = G2 (b); \
-   x += y; y += x; \
-   (d) ^= y + ctx-&gt;k[2 * (n) + 1]; \
-   (d) = ror32((d), 1); \
-   (c) = rol32((c), 1); \
-   (c) ^= (x + ctx-&gt;k[2 * (n)])
-
-/* Encryption and decryption cycles; each one is simply two Feistel rounds
- * with the 32-bit chunks re-ordered to simulate the "swap" */
-
-#define ENCCYCLE(n) \
-   ENCROUND (2 * (n), a, b, c, d); \
-   ENCROUND (2 * (n) + 1, c, d, a, b)
-
-#define DECCYCLE(n) \
-   DECROUND (2 * (n) + 1, c, d, a, b); \
-   DECROUND (2 * (n), a, b, c, d)
-
-/* Macros to convert the input and output bytes into 32-bit words,
- * and simultaneously perform the whitening step.  INPACK packs word
- * number n into the variable named by x, using whitening subkey number m.
- * OUTUNPACK unpacks word number n from the variable named by x, using
- * whitening subkey number m. */
-
-#define INPACK(n, x, m) \
-   x = le32_to_cpu(src[n]) ^ ctx-&gt;w[m]
-
-#define OUTUNPACK(n, x, m) \
-   x ^= ctx-&gt;w[m]; \
-   dst[n] = cpu_to_le32(x)
-
-#define TF_MIN_KEY_SIZE 16
-#define TF_MAX_KEY_SIZE 32
-#define TF_BLOCK_SIZE 16
-
-/* Structure for an expanded Twofish key.  s contains the key-dependent
- * S-boxes composed with the MDS matrix; w contains the eight "whitening"
- * subkeys, K[0] through K[7].	k holds the remaining, "round" subkeys.  Note
- * that k[i] corresponds to what the Twofish paper calls K[i+8]. */
-struct twofish_ctx {
-   u32 s[4][256], w[8], k[32];
-};
-
-/* Perform the key setup. */
-static int twofish_setkey(void *cx, const u8 *key,
-                          unsigned int key_len, u32 *flags)
-{
-	
-	struct twofish_ctx *ctx = cx;
-
-	int i, j, k;
-
-	/* Temporaries for CALC_K. */
-	u32 x, y;
-
-	/* The S vector used to key the S-boxes, split up into individual bytes.
-	 * 128-bit keys use only sa through sh; 256-bit use all of them. */
-	u8 sa = 0, sb = 0, sc = 0, sd = 0, se = 0, sf = 0, sg = 0, sh = 0;
-	u8 si = 0, sj = 0, sk = 0, sl = 0, sm = 0, sn = 0, so = 0, sp = 0;
-
-	/* Temporary for CALC_S. */
-	u8 tmp;
-
-	/* Check key length. */
-	if (key_len != 16 &amp;&amp; key_len != 24 &amp;&amp; key_len != 32)
-	{
-		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
-		return -EINVAL; /* unsupported key length */
-	}
-
-	/* Compute the first two words of the S vector.  The magic numbers are
-	 * the entries of the RS matrix, preprocessed through poly_to_exp. The
-	 * numbers in the comments are the original (polynomial form) matrix
-	 * entries. */
-	CALC_S (sa, sb, sc, sd, 0, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-	CALC_S (sa, sb, sc, sd, 1, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-	CALC_S (sa, sb, sc, sd, 2, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-	CALC_S (sa, sb, sc, sd, 3, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-	CALC_S (sa, sb, sc, sd, 4, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-	CALC_S (sa, sb, sc, sd, 5, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-	CALC_S (sa, sb, sc, sd, 6, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-	CALC_S (sa, sb, sc, sd, 7, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-	CALC_S (se, sf, sg, sh, 8, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-	CALC_S (se, sf, sg, sh, 9, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-	CALC_S (se, sf, sg, sh, 10, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-	CALC_S (se, sf, sg, sh, 11, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-	CALC_S (se, sf, sg, sh, 12, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-	CALC_S (se, sf, sg, sh, 13, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-	CALC_S (se, sf, sg, sh, 14, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-	CALC_S (se, sf, sg, sh, 15, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-
-	if (key_len == 24 || key_len == 32) { /* 192- or 256-bit key */
-		/* Calculate the third word of the S vector */
-		CALC_S (si, sj, sk, sl, 16, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-		CALC_S (si, sj, sk, sl, 17, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-		CALC_S (si, sj, sk, sl, 18, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-		CALC_S (si, sj, sk, sl, 19, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-		CALC_S (si, sj, sk, sl, 20, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-		CALC_S (si, sj, sk, sl, 21, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-		CALC_S (si, sj, sk, sl, 22, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-		CALC_S (si, sj, sk, sl, 23, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-	}
-
-	if (key_len == 32) { /* 256-bit key */
-		/* Calculate the fourth word of the S vector */
-		CALC_S (sm, sn, so, sp, 24, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-		CALC_S (sm, sn, so, sp, 25, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-		CALC_S (sm, sn, so, sp, 26, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-		CALC_S (sm, sn, so, sp, 27, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-		CALC_S (sm, sn, so, sp, 28, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-		CALC_S (sm, sn, so, sp, 29, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-		CALC_S (sm, sn, so, sp, 30, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-		CALC_S (sm, sn, so, sp, 31, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-
-		/* Compute the S-boxes. */
-		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
-			CALC_SB256_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
-		}
-
-		/* Calculate whitening and round subkeys.  The constants are
-		 * indices of subkeys, preprocessed through q0 and q1. */
-		CALC_K256 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
-		CALC_K256 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
-		CALC_K256 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
-		CALC_K256 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
-		CALC_K256 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
-		CALC_K256 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
-		CALC_K256 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
-		CALC_K256 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
-		CALC_K256 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
-		CALC_K256 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
-		CALC_K256 (k, 12, 0x18, 0x37, 0xF7, 0x71);
-		CALC_K256 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
-		CALC_K256 (k, 16, 0x43, 0x30, 0x75, 0x0F);
-		CALC_K256 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
-		CALC_K256 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
-		CALC_K256 (k, 22, 0x94, 0x06, 0x48, 0x3F);
-		CALC_K256 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
-		CALC_K256 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
-		CALC_K256 (k, 28, 0x84, 0x8A, 0x54, 0x00);
-		CALC_K256 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
-	} else if (key_len == 24) { /* 192-bit key */
-		/* Compute the S-boxes. */
-		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
-		        CALC_SB192_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
-		}
-
-		/* Calculate whitening and round subkeys.  The constants are
-		 * indices of subkeys, preprocessed through q0 and q1. */
-		CALC_K192 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
-		CALC_K192 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
-		CALC_K192 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
-		CALC_K192 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
-		CALC_K192 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
-		CALC_K192 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
-		CALC_K192 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
-		CALC_K192 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
-		CALC_K192 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
-		CALC_K192 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
-		CALC_K192 (k, 12, 0x18, 0x37, 0xF7, 0x71);
-		CALC_K192 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
-		CALC_K192 (k, 16, 0x43, 0x30, 0x75, 0x0F);
-		CALC_K192 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
-		CALC_K192 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
-		CALC_K192 (k, 22, 0x94, 0x06, 0x48, 0x3F);
-		CALC_K192 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
-		CALC_K192 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
-		CALC_K192 (k, 28, 0x84, 0x8A, 0x54, 0x00);
-		CALC_K192 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
-	} else { /* 128-bit key */
-		/* Compute the S-boxes. */
-		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
-			CALC_SB_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
-		}
-
-		/* Calculate whitening and round subkeys.  The constants are
-		 * indices of subkeys, preprocessed through q0 and q1. */
-		CALC_K (w, 0, 0xA9, 0x75, 0x67, 0xF3);
-		CALC_K (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
-		CALC_K (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
-		CALC_K (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
-		CALC_K (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
-		CALC_K (k, 2, 0x80, 0xE6, 0x78, 0x6B);
-		CALC_K (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
-		CALC_K (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
-		CALC_K (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
-		CALC_K (k, 10, 0x35, 0xD8, 0x98, 0xFD);
-		CALC_K (k, 12, 0x18, 0x37, 0xF7, 0x71);
-		CALC_K (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
-		CALC_K (k, 16, 0x43, 0x30, 0x75, 0x0F);
-		CALC_K (k, 18, 0x37, 0xF8, 0x26, 0x1B);
-		CALC_K (k, 20, 0xFA, 0x87, 0x13, 0xFA);
-		CALC_K (k, 22, 0x94, 0x06, 0x48, 0x3F);
-		CALC_K (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
-		CALC_K (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
-		CALC_K (k, 28, 0x84, 0x8A, 0x54, 0x00);
-		CALC_K (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
-	}
-
-	return 0;
-}
-
-/* Encrypt one block.  in and out may be the same. */
-static void twofish_encrypt(void *cx, u8 *out, const u8 *in)
-{
-	struct twofish_ctx *ctx = cx;
-	const __le32 *src = (const __le32 *)in;
-	__le32 *dst = (__le32 *)out;
-
-	/* The four 32-bit chunks of the text. */
-	u32 a, b, c, d;
-	
-	/* Temporaries used by the round function. */
-	u32 x, y;
-
-	/* Input whitening and packing. */
-	INPACK (0, a, 0);
-	INPACK (1, b, 1);
-	INPACK (2, c, 2);
-	INPACK (3, d, 3);
-	
-	/* Encryption Feistel cycles. */
-	ENCCYCLE (0);
-	ENCCYCLE (1);
-	ENCCYCLE (2);
-	ENCCYCLE (3);
-	ENCCYCLE (4);
-	ENCCYCLE (5);
-	ENCCYCLE (6);
-	ENCCYCLE (7);
-	
-	/* Output whitening and unpacking. */
-	OUTUNPACK (0, c, 4);
-	OUTUNPACK (1, d, 5);
-	OUTUNPACK (2, a, 6);
-	OUTUNPACK (3, b, 7);
-	
-}
-
-/* Decrypt one block.  in and out may be the same. */
-static void twofish_decrypt(void *cx, u8 *out, const u8 *in)
-{
-	struct twofish_ctx *ctx = cx;
-	const __le32 *src = (const __le32 *)in;
-	__le32 *dst = (__le32 *)out;
-  
-	/* The four 32-bit chunks of the text. */
-	u32 a, b, c, d;
-	
-	/* Temporaries used by the round function. */
-	u32 x, y;
-	
-	/* Input whitening and packing. */
-	INPACK (0, c, 4);
-	INPACK (1, d, 5);
-	INPACK (2, a, 6);
-	INPACK (3, b, 7);
-	
-	/* Encryption Feistel cycles. */
-	DECCYCLE (7);
-	DECCYCLE (6);
-	DECCYCLE (5);
-	DECCYCLE (4);
-	DECCYCLE (3);
-	DECCYCLE (2);
-	DECCYCLE (1);
-	DECCYCLE (0);
-
-	/* Output whitening and unpacking. */
-	OUTUNPACK (0, a, 0);
-	OUTUNPACK (1, b, 1);
-	OUTUNPACK (2, c, 2);
-	OUTUNPACK (3, d, 3);
-
-}
-
-static struct crypto_alg alg = {
-	.cra_name           =   "twofish",
-	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
-	.cra_blocksize      =   TF_BLOCK_SIZE,
-	.cra_ctxsize        =   sizeof(struct twofish_ctx),
-	.cra_alignmask      =	3,
-	.cra_module         =   THIS_MODULE,
-	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
-	.cra_u              =   { .cipher = {
-	.cia_min_keysize    =   TF_MIN_KEY_SIZE,
-	.cia_max_keysize    =   TF_MAX_KEY_SIZE,
-	.cia_setkey         =   twofish_setkey,
-	.cia_encrypt        =   twofish_encrypt,
-	.cia_decrypt        =   twofish_decrypt } }
-};
-
-static int __init init(void)
-{
-	return crypto_register_alg(&amp;alg);
-}
-
-static void __exit fini(void)
-{
-	crypto_unregister_alg(&amp;alg);
-}
-
-module_init(init);
-module_exit(fini);
-
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION ("Twofish Cipher Algorithm");
diff -uprN linux-2.6.17-rc5/crypto/twofish_c.c linux-2.6.17-rc5.twofish/crypto/twofish_c.c
--- linux-2.6.17-rc5/crypto/twofish_c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish/crypto/twofish_c.c	2006-05-30 15:38:14.627954845 +0200
@@ -0,0 +1,213 @@
+/*
+ * Twofish for CryptoAPI
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+
+/* Macros to compute the g() function in the encryption and decryption
+ * rounds.  G1 is the straight g() function; G2 includes the 8-bit
+ * rotation for the high 32-bit word. */
+
+#define G1(a) \
+     (ctx-&gt;s[0][(a) &amp; 0xFF]) ^ (ctx-&gt;s[1][((a) &gt;&gt; 8) &amp; 0xFF]) \
+   ^ (ctx-&gt;s[2][((a) &gt;&gt; 16) &amp; 0xFF]) ^ (ctx-&gt;s[3][(a) &gt;&gt; 24])
+
+#define G2(b) \
+     (ctx-&gt;s[1][(b) &amp; 0xFF]) ^ (ctx-&gt;s[2][((b) &gt;&gt; 8) &amp; 0xFF]) \
+   ^ (ctx-&gt;s[3][((b) &gt;&gt; 16) &amp; 0xFF]) ^ (ctx-&gt;s[0][(b) &gt;&gt; 24])
+
+/* Encryption and decryption Feistel rounds.  Each one calls the two g()
+ * macros, does the PHT, and performs the XOR and the appropriate bit
+ * rotations.  The parameters are the round number (used to select subkeys),
+ * and the four 32-bit chunks of the text. */
+
+#define ENCROUND(n, a, b, c, d) \
+   x = G1 (a); y = G2 (b); \
+   x += y; y += x + ctx-&gt;k[2 * (n) + 1]; \
+   (c) ^= x + ctx-&gt;k[2 * (n)]; \
+   (c) = ror32((c), 1); \
+   (d) = rol32((d), 1) ^ y
+
+#define DECROUND(n, a, b, c, d) \
+   x = G1 (a); y = G2 (b); \
+   x += y; y += x; \
+   (d) ^= y + ctx-&gt;k[2 * (n) + 1]; \
+   (d) = ror32((d), 1); \
+   (c) = rol32((c), 1); \
+   (c) ^= (x + ctx-&gt;k[2 * (n)])
+
+/* Encryption and decryption cycles; each one is simply two Feistel rounds
+ * with the 32-bit chunks re-ordered to simulate the "swap" */
+
+#define ENCCYCLE(n) \
+   ENCROUND (2 * (n), a, b, c, d); \
+   ENCROUND (2 * (n) + 1, c, d, a, b)
+
+#define DECCYCLE(n) \
+   DECROUND (2 * (n) + 1, c, d, a, b); \
+   DECROUND (2 * (n), a, b, c, d)
+
+/* Macros to convert the input and output bytes into 32-bit words,
+ * and simultaneously perform the whitening step.  INPACK packs word
+ * number n into the variable named by x, using whitening subkey number m.
+ * OUTUNPACK unpacks word number n from the variable named by x, using
+ * whitening subkey number m. */
+
+#define INPACK(n, x, m) \
+   x = le32_to_cpu(src[n]) ^ ctx-&gt;w[m]
+
+#define OUTUNPACK(n, x, m) \
+   x ^= ctx-&gt;w[m]; \
+   dst[n] = cpu_to_le32(x)
+
+
+/* Encrypt one block.  in and out may be the same. */
+static void twofish_encrypt(void *cx, u8 *out, const u8 *in)
+{
+	struct twofish_ctx *ctx = cx;
+	const __le32 *src = (const __le32 *)in;
+	__le32 *dst = (__le32 *)out;
+
+	/* The four 32-bit chunks of the text. */
+	u32 a, b, c, d;
+
+	/* Temporaries used by the round function. */
+	u32 x, y;
+
+	/* Input whitening and packing. */
+	INPACK (0, a, 0);
+	INPACK (1, b, 1);
+	INPACK (2, c, 2);
+	INPACK (3, d, 3);
+
+	/* Encryption Feistel cycles. */
+	ENCCYCLE (0);
+	ENCCYCLE (1);
+	ENCCYCLE (2);
+	ENCCYCLE (3);
+	ENCCYCLE (4);
+	ENCCYCLE (5);
+	ENCCYCLE (6);
+	ENCCYCLE (7);
+
+	/* Output whitening and unpacking. */
+	OUTUNPACK (0, c, 4);
+	OUTUNPACK (1, d, 5);
+	OUTUNPACK (2, a, 6);
+	OUTUNPACK (3, b, 7);
+
+}
+
+/* Decrypt one block.  in and out may be the same. */
+static void twofish_decrypt(void *cx, u8 *out, const u8 *in)
+{
+	struct twofish_ctx *ctx = cx;
+	const __le32 *src = (const __le32 *)in;
+	__le32 *dst = (__le32 *)out;
+
+	/* The four 32-bit chunks of the text. */
+	u32 a, b, c, d;
+
+	/* Temporaries used by the round function. */
+	u32 x, y;
+
+	/* Input whitening and packing. */
+	INPACK (0, c, 4);
+	INPACK (1, d, 5);
+	INPACK (2, a, 6);
+	INPACK (3, b, 7);
+
+	/* Encryption Feistel cycles. */
+	DECCYCLE (7);
+	DECCYCLE (6);
+	DECCYCLE (5);
+	DECCYCLE (4);
+	DECCYCLE (3);
+	DECCYCLE (2);
+	DECCYCLE (1);
+	DECCYCLE (0);
+
+	/* Output whitening and unpacking. */
+	OUTUNPACK (0, a, 0);
+	OUTUNPACK (1, b, 1);
+	OUTUNPACK (2, c, 2);
+	OUTUNPACK (3, d, 3);
+
+}
+
+
+static struct crypto_alg alg = {
+	.cra_name           =   "twofish",
+	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize      =   TF_BLOCK_SIZE,
+	.cra_ctxsize        =   sizeof(struct twofish_ctx),
+	.cra_alignmask      =	3,
+	.cra_module         =   THIS_MODULE,
+	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
+	.cra_u              =   { .cipher = {
+	.cia_min_keysize    =   TF_MIN_KEY_SIZE,
+	.cia_max_keysize    =   TF_MAX_KEY_SIZE,
+	.cia_setkey         =   twofish_setkey,
+	.cia_encrypt        =   twofish_encrypt,
+	.cia_decrypt        =   twofish_decrypt } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION ("Twofish Cipher Algorithm");
diff -uprN linux-2.6.17-rc5/crypto/twofish_common.c linux-2.6.17-rc5.twofish/crypto/twofish_common.c
--- linux-2.6.17-rc5/crypto/twofish_common.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish/crypto/twofish_common.c	2006-05-30 15:33:54.099800857 +0200
@@ -0,0 +1,740 @@
+/*
+ * Common Twofish algorithm parts shared between the c and assembler
+ * implementations
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+
+/* The large precomputed tables for the Twofish cipher (twofish.c)
+ * Taken from the same source as twofish.c
+ * Marc Mutz &lt;Marc@Mutz.com&gt;
+ */
+
+/* These two tables are the q0 and q1 permutations, exactly as described in
+ * the Twofish paper. */
+
+static const u8 q0[256] = {
+   0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78,
+   0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C,
+   0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30,
+   0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82,
+   0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE,
+   0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B,
+   0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45,
+   0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7,
+   0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF,
+   0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8,
+   0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED,
+   0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90,
+   0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B,
+   0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B,
+   0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F,
+   0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A,
+   0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17,
+   0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72,
+   0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68,
+   0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4,
+   0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42,
+   0x4A, 0x5E, 0xC1, 0xE0
+};
+
+static const u8 q1[256] = {
+   0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B,
+   0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1,
+   0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B,
+   0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5,
+   0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54,
+   0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96,
+   0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7,
+   0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8,
+   0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF,
+   0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9,
+   0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D,
+   0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E,
+   0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21,
+   0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01,
+   0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E,
+   0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64,
+   0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44,
+   0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E,
+   0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B,
+   0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9,
+   0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56,
+   0x55, 0x09, 0xBE, 0x91
+};
+
+/* These MDS tables are actually tables of MDS composed with q0 and q1,
+ * because it is only ever used that way and we can save some time by
+ * precomputing.  Of course the main saving comes from precomputing the
+ * GF(2^8) multiplication involved in the MDS matrix multiply; by looking
+ * things up in these tables we reduce the matrix multiply to four lookups
+ * and three XORs.  Semi-formally, the definition of these tables is:
+ * mds[0][i] = MDS (q1[i] 0 0 0)^T  mds[1][i] = MDS (0 q0[i] 0 0)^T
+ * mds[2][i] = MDS (0 0 q1[i] 0)^T  mds[3][i] = MDS (0 0 0 q0[i])^T
+ * where ^T means "transpose", the matrix multiply is performed in GF(2^8)
+ * represented as GF(2)[x]/v(x) where v(x)=x^8+x^6+x^5+x^3+1 as described
+ * by Schneier et al, and I'm casually glossing over the byte/word
+ * conversion issues. */
+
+static const u32 mds[4][256] = {
+   {0xBCBC3275, 0xECEC21F3, 0x202043C6, 0xB3B3C9F4, 0xDADA03DB, 0x02028B7B,
+    0xE2E22BFB, 0x9E9EFAC8, 0xC9C9EC4A, 0xD4D409D3, 0x18186BE6, 0x1E1E9F6B,
+    0x98980E45, 0xB2B2387D, 0xA6A6D2E8, 0x2626B74B, 0x3C3C57D6, 0x93938A32,
+    0x8282EED8, 0x525298FD, 0x7B7BD437, 0xBBBB3771, 0x5B5B97F1, 0x474783E1,
+    0x24243C30, 0x5151E20F, 0xBABAC6F8, 0x4A4AF31B, 0xBFBF4887, 0x0D0D70FA,
+    0xB0B0B306, 0x7575DE3F, 0xD2D2FD5E, 0x7D7D20BA, 0x666631AE, 0x3A3AA35B,
+    0x59591C8A, 0x00000000, 0xCDCD93BC, 0x1A1AE09D, 0xAEAE2C6D, 0x7F7FABC1,
+    0x2B2BC7B1, 0xBEBEB90E, 0xE0E0A080, 0x8A8A105D, 0x3B3B52D2, 0x6464BAD5,
+    0xD8D888A0, 0xE7E7A584, 0x5F5FE807, 0x1B1B1114, 0x2C2CC2B5, 0xFCFCB490,
+    0x3131272C, 0x808065A3, 0x73732AB2, 0x0C0C8173, 0x79795F4C, 0x6B6B4154,
+    0x4B4B0292, 0x53536974, 0x94948F36, 0x83831F51, 0x2A2A3638, 0xC4C49CB0,
+    0x2222C8BD, 0xD5D5F85A, 0xBDBDC3FC, 0x48487860, 0xFFFFCE62, 0x4C4C0796,
+    0x4141776C, 0xC7C7E642, 0xEBEB24F7, 0x1C1C1410, 0x5D5D637C, 0x36362228,
+    0x6767C027, 0xE9E9AF8C, 0x4444F913, 0x1414EA95, 0xF5F5BB9C, 0xCFCF18C7,
+    0x3F3F2D24, 0xC0C0E346, 0x7272DB3B, 0x54546C70, 0x29294CCA, 0xF0F035E3,
+    0x0808FE85, 0xC6C617CB, 0xF3F34F11, 0x8C8CE4D0, 0xA4A45993, 0xCACA96B8,
+    0x68683BA6, 0xB8B84D83, 0x38382820, 0xE5E52EFF, 0xADAD569F, 0x0B0B8477,
+    0xC8C81DC3, 0x9999FFCC, 0x5858ED03, 0x19199A6F, 0x0E0E0A08, 0x95957EBF,
+    0x70705040, 0xF7F730E7, 0x6E6ECF2B, 0x1F1F6EE2, 0xB5B53D79, 0x09090F0C,
+    0x616134AA, 0x57571682, 0x9F9F0B41, 0x9D9D803A, 0x111164EA, 0x2525CDB9,
+    0xAFAFDDE4, 0x4545089A, 0xDFDF8DA4, 0xA3A35C97, 0xEAEAD57E, 0x353558DA,
+    0xEDEDD07A, 0x4343FC17, 0xF8F8CB66, 0xFBFBB194, 0x3737D3A1, 0xFAFA401D,
+    0xC2C2683D, 0xB4B4CCF0, 0x32325DDE, 0x9C9C71B3, 0x5656E70B, 0xE3E3DA72,
+    0x878760A7, 0x15151B1C, 0xF9F93AEF, 0x6363BFD1, 0x3434A953, 0x9A9A853E,
+    0xB1B1428F, 0x7C7CD133, 0x88889B26, 0x3D3DA65F, 0xA1A1D7EC, 0xE4E4DF76,
+    0x8181942A, 0x91910149, 0x0F0FFB81, 0xEEEEAA88, 0x161661EE, 0xD7D77321,
+    0x9797F5C4, 0xA5A5A81A, 0xFEFE3FEB, 0x6D6DB5D9, 0x7878AEC5, 0xC5C56D39,
+    0x1D1DE599, 0x7676A4CD, 0x3E3EDCAD, 0xCBCB6731, 0xB6B6478B, 0xEFEF5B01,
+    0x12121E18, 0x6060C523, 0x6A6AB0DD, 0x4D4DF61F, 0xCECEE94E, 0xDEDE7C2D,
+    0x55559DF9, 0x7E7E5A48, 0x2121B24F, 0x03037AF2, 0xA0A02665, 0x5E5E198E,
+    0x5A5A6678, 0x65654B5C, 0x62624E58, 0xFDFD4519, 0x0606F48D, 0x404086E5,
+    0xF2F2BE98, 0x3333AC57, 0x17179067, 0x05058E7F, 0xE8E85E05, 0x4F4F7D64,
+    0x89896AAF, 0x10109563, 0x74742FB6, 0x0A0A75FE, 0x5C5C92F5, 0x9B9B74B7,
+    0x2D2D333C, 0x3030D6A5, 0x2E2E49CE, 0x494989E9, 0x46467268, 0x77775544,
+    0xA8A8D8E0, 0x9696044D, 0x2828BD43, 0xA9A92969, 0xD9D97929, 0x8686912E,
+    0xD1D187AC, 0xF4F44A15, 0x8D8D1559, 0xD6D682A8, 0xB9B9BC0A, 0x42420D9E,
+    0xF6F6C16E, 0x2F2FB847, 0xDDDD06DF, 0x23233934, 0xCCCC6235, 0xF1F1C46A,
+    0xC1C112CF, 0x8585EBDC, 0x8F8F9E22, 0x7171A1C9, 0x9090F0C0, 0xAAAA539B,
+    0x0101F189, 0x8B8BE1D4, 0x4E4E8CED, 0x8E8E6FAB, 0xABABA212, 0x6F6F3EA2,
+    0xE6E6540D, 0xDBDBF252, 0x92927BBB, 0xB7B7B602, 0x6969CA2F, 0x3939D9A9,
+    0xD3D30CD7, 0xA7A72361, 0xA2A2AD1E, 0xC3C399B4, 0x6C6C4450, 0x07070504,
+    0x04047FF6, 0x272746C2, 0xACACA716, 0xD0D07625, 0x50501386, 0xDCDCF756,
+    0x84841A55, 0xE1E15109, 0x7A7A25BE, 0x1313EF91},
+
+   {0xA9D93939, 0x67901717, 0xB3719C9C, 0xE8D2A6A6, 0x04050707, 0xFD985252,
+    0xA3658080, 0x76DFE4E4, 0x9A084545, 0x92024B4B, 0x80A0E0E0, 0x78665A5A,
+    0xE4DDAFAF, 0xDDB06A6A, 0xD1BF6363, 0x38362A2A, 0x0D54E6E6, 0xC6432020,
+    0x3562CCCC, 0x98BEF2F2, 0x181E1212, 0xF724EBEB, 0xECD7A1A1, 0x6C774141,
+    0x43BD2828, 0x7532BCBC, 0x37D47B7B, 0x269B8888, 0xFA700D0D, 0x13F94444,
+    0x94B1FBFB, 0x485A7E7E, 0xF27A0303, 0xD0E48C8C, 0x8B47B6B6, 0x303C2424,
+    0x84A5E7E7, 0x54416B6B, 0xDF06DDDD, 0x23C56060, 0x1945FDFD, 0x5BA33A3A,
+    0x3D68C2C2, 0x59158D8D, 0xF321ECEC, 0xAE316666, 0xA23E6F6F, 0x82165757,
+    0x63951010, 0x015BEFEF, 0x834DB8B8, 0x2E918686, 0xD9B56D6D, 0x511F8383,
+    0x9B53AAAA, 0x7C635D5D, 0xA63B6868, 0xEB3FFEFE, 0xA5D63030, 0xBE257A7A,
+    0x16A7ACAC, 0x0C0F0909, 0xE335F0F0, 0x6123A7A7, 0xC0F09090, 0x8CAFE9E9,
+    0x3A809D9D, 0xF5925C5C, 0x73810C0C, 0x2C273131, 0x2576D0D0, 0x0BE75656,
+    0xBB7B9292, 0x4EE9CECE, 0x89F10101, 0x6B9F1E1E, 0x53A93434, 0x6AC4F1F1,
+    0xB499C3C3, 0xF1975B5B, 0xE1834747, 0xE66B1818, 0xBDC82222, 0x450E9898,
+    0xE26E1F1F, 0xF4C9B3B3, 0xB62F7474, 0x66CBF8F8, 0xCCFF9999, 0x95EA1414,
+    0x03ED5858, 0x56F7DCDC, 0xD4E18B8B, 0x1C1B1515, 0x1EADA2A2, 0xD70CD3D3,
+    0xFB2BE2E2, 0xC31DC8C8, 0x8E195E5E, 0xB5C22C2C, 0xE9894949, 0xCF12C1C1,
+    0xBF7E9595, 0xBA207D7D, 0xEA641111, 0x77840B0B, 0x396DC5C5, 0xAF6A8989,
+    0x33D17C7C, 0xC9A17171, 0x62CEFFFF, 0x7137BBBB, 0x81FB0F0F, 0x793DB5B5,
+    0x0951E1E1, 0xADDC3E3E, 0x242D3F3F, 0xCDA47676, 0xF99D5555, 0xD8EE8282,
+    0xE5864040, 0xC5AE7878, 0xB9CD2525, 0x4D049696, 0x44557777, 0x080A0E0E,
+    0x86135050, 0xE730F7F7, 0xA1D33737, 0x1D40FAFA, 0xAA346161, 0xED8C4E4E,
+    0x06B3B0B0, 0x706C5454, 0xB22A7373, 0xD2523B3B, 0x410B9F9F, 0x7B8B0202,
+    0xA088D8D8, 0x114FF3F3, 0x3167CBCB, 0xC2462727, 0x27C06767, 0x90B4FCFC,
+    0x20283838, 0xF67F0404, 0x60784848, 0xFF2EE5E5, 0x96074C4C, 0x5C4B6565,
+    0xB1C72B2B, 0xAB6F8E8E, 0x9E0D4242, 0x9CBBF5F5, 0x52F2DBDB, 0x1BF34A4A,
+    0x5FA63D3D, 0x9359A4A4, 0x0ABCB9B9, 0xEF3AF9F9, 0x91EF1313, 0x85FE0808,
+    0x49019191, 0xEE611616, 0x2D7CDEDE, 0x4FB22121, 0x8F42B1B1, 0x3BDB7272,
+    0x47B82F2F, 0x8748BFBF, 0x6D2CAEAE, 0x46E3C0C0, 0xD6573C3C, 0x3E859A9A,
+    0x6929A9A9, 0x647D4F4F, 0x2A948181, 0xCE492E2E, 0xCB17C6C6, 0x2FCA6969,
+    0xFCC3BDBD, 0x975CA3A3, 0x055EE8E8, 0x7AD0EDED, 0xAC87D1D1, 0x7F8E0505,
+    0xD5BA6464, 0x1AA8A5A5, 0x4BB72626, 0x0EB9BEBE, 0xA7608787, 0x5AF8D5D5,
+    0x28223636, 0x14111B1B, 0x3FDE7575, 0x2979D9D9, 0x88AAEEEE, 0x3C332D2D,
+    0x4C5F7979, 0x02B6B7B7, 0xB896CACA, 0xDA583535, 0xB09CC4C4, 0x17FC4343,
+    0x551A8484, 0x1FF64D4D, 0x8A1C5959, 0x7D38B2B2, 0x57AC3333, 0xC718CFCF,
+    0x8DF40606, 0x74695353, 0xB7749B9B, 0xC4F59797, 0x9F56ADAD, 0x72DAE3E3,
+    0x7ED5EAEA, 0x154AF4F4, 0x229E8F8F, 0x12A2ABAB, 0x584E6262, 0x07E85F5F,
+    0x99E51D1D, 0x34392323, 0x6EC1F6F6, 0x50446C6C, 0xDE5D3232, 0x68724646,
+    0x6526A0A0, 0xBC93CDCD, 0xDB03DADA, 0xF8C6BABA, 0xC8FA9E9E, 0xA882D6D6,
+    0x2BCF6E6E, 0x40507070, 0xDCEB8585, 0xFE750A0A, 0x328A9393, 0xA48DDFDF,
+    0xCA4C2929, 0x10141C1C, 0x2173D7D7, 0xF0CCB4B4, 0xD309D4D4, 0x5D108A8A,
+    0x0FE25151, 0x00000000, 0x6F9A1919, 0x9DE01A1A, 0x368F9494, 0x42E6C7C7,
+    0x4AECC9C9, 0x5EFDD2D2, 0xC1AB7F7F, 0xE0D8A8A8},
+
+   {0xBC75BC32, 0xECF3EC21, 0x20C62043, 0xB3F4B3C9, 0xDADBDA03, 0x027B028B,
+    0xE2FBE22B, 0x9EC89EFA, 0xC94AC9EC, 0xD4D3D409, 0x18E6186B, 0x1E6B1E9F,
+    0x9845980E, 0xB27DB238, 0xA6E8A6D2, 0x264B26B7, 0x3CD63C57, 0x9332938A,
+    0x82D882EE, 0x52FD5298, 0x7B377BD4, 0xBB71BB37, 0x5BF15B97, 0x47E14783,
+    0x2430243C, 0x510F51E2, 0xBAF8BAC6, 0x4A1B4AF3, 0xBF87BF48, 0x0DFA0D70,
+    0xB006B0B3, 0x753F75DE, 0xD25ED2FD, 0x7DBA7D20, 0x66AE6631, 0x3A5B3AA3,
+    0x598A591C, 0x00000000, 0xCDBCCD93, 0x1A9D1AE0, 0xAE6DAE2C, 0x7FC17FAB,
+    0x2BB12BC7, 0xBE0EBEB9, 0xE080E0A0, 0x8A5D8A10, 0x3BD23B52, 0x64D564BA,
+    0xD8A0D888, 0xE784E7A5, 0x5F075FE8, 0x1B141B11, 0x2CB52CC2, 0xFC90FCB4,
+    0x312C3127, 0x80A38065, 0x73B2732A, 0x0C730C81, 0x794C795F, 0x6B546B41,
+    0x4B924B02, 0x53745369, 0x9436948F, 0x8351831F, 0x2A382A36, 0xC4B0C49C,
+    0x22BD22C8, 0xD55AD5F8, 0xBDFCBDC3, 0x48604878, 0xFF62FFCE, 0x4C964C07,
+    0x416C4177, 0xC742C7E6, 0xEBF7EB24, 0x1C101C14, 0x5D7C5D63, 0x36283622,
+    0x672767C0, 0xE98CE9AF, 0x441344F9, 0x149514EA, 0xF59CF5BB, 0xCFC7CF18,
+    0x3F243F2D, 0xC046C0E3, 0x723B72DB, 0x5470546C, 0x29CA294C, 0xF0E3F035,
+    0x088508FE, 0xC6CBC617, 0xF311F34F, 0x8CD08CE4, 0xA493A459, 0xCAB8CA96,
+    0x68A6683B, 0xB883B84D, 0x38203828, 0xE5FFE52E, 0xAD9FAD56, 0x0B770B84,
+    0xC8C3C81D, 0x99CC99FF, 0x580358ED, 0x196F199A, 0x0E080E0A, 0x95BF957E,
+    0x70407050, 0xF7E7F730, 0x6E2B6ECF, 0x1FE21F6E, 0xB579B53D, 0x090C090F,
+    0x61AA6134, 0x57825716, 0x9F419F0B, 0x9D3A9D80, 0x11EA1164, 0x25B925CD,
+    0xAFE4AFDD, 0x459A4508, 0xDFA4DF8D, 0xA397A35C, 0xEA7EEAD5, 0x35DA3558,
+    0xED7AEDD0, 0x431743FC, 0xF866F8CB, 0xFB94FBB1, 0x37A137D3, 0xFA1DFA40,
+    0xC23DC268, 0xB4F0B4CC, 0x32DE325D, 0x9CB39C71, 0x560B56E7, 0xE372E3DA,
+    0x87A78760, 0x151C151B, 0xF9EFF93A, 0x63D163BF, 0x345334A9, 0x9A3E9A85,
+    0xB18FB142, 0x7C337CD1, 0x8826889B, 0x3D5F3DA6, 0xA1ECA1D7, 0xE476E4DF,
+    0x812A8194, 0x91499101, 0x0F810FFB, 0xEE88EEAA, 0x16EE1661, 0xD721D773,
+    0x97C497F5, 0xA51AA5A8, 0xFEEBFE3F, 0x6DD96DB5, 0x78C578AE, 0xC539C56D,
+    0x1D991DE5, 0x76CD76A4, 0x3EAD3EDC, 0xCB31CB67, 0xB68BB647, 0xEF01EF5B,
+    0x1218121E, 0x602360C5, 0x6ADD6AB0, 0x4D1F4DF6, 0xCE4ECEE9, 0xDE2DDE7C,
+    0x55F9559D, 0x7E487E5A, 0x214F21B2, 0x03F2037A, 0xA065A026, 0x5E8E5E19,
+    0x5A785A66, 0x655C654B, 0x6258624E, 0xFD19FD45, 0x068D06F4, 0x40E54086,
+    0xF298F2BE, 0x335733AC, 0x17671790, 0x057F058E, 0xE805E85E, 0x4F644F7D,
+    0x89AF896A, 0x10631095, 0x74B6742F, 0x0AFE0A75, 0x5CF55C92, 0x9BB79B74,
+    0x2D3C2D33, 0x30A530D6, 0x2ECE2E49, 0x49E94989, 0x46684672, 0x77447755,
+    0xA8E0A8D8, 0x964D9604, 0x284328BD, 0xA969A929, 0xD929D979, 0x862E8691,
+    0xD1ACD187, 0xF415F44A, 0x8D598D15, 0xD6A8D682, 0xB90AB9BC, 0x429E420D,
+    0xF66EF6C1, 0x2F472FB8, 0xDDDFDD06, 0x23342339, 0xCC35CC62, 0xF16AF1C4,
+    0xC1CFC112, 0x85DC85EB, 0x8F228F9E, 0x71C971A1, 0x90C090F0, 0xAA9BAA53,
+    0x018901F1, 0x8BD48BE1, 0x4EED4E8C, 0x8EAB8E6F, 0xAB12ABA2, 0x6FA26F3E,
+    0xE60DE654, 0xDB52DBF2, 0x92BB927B, 0xB702B7B6, 0x692F69CA, 0x39A939D9,
+    0xD3D7D30C, 0xA761A723, 0xA21EA2AD, 0xC3B4C399, 0x6C506C44, 0x07040705,
+    0x04F6047F, 0x27C22746, 0xAC16ACA7, 0xD025D076, 0x50865013, 0xDC56DCF7,
+    0x8455841A, 0xE109E151, 0x7ABE7A25, 0x139113EF},
+
+   {0xD939A9D9, 0x90176790, 0x719CB371, 0xD2A6E8D2, 0x05070405, 0x9852FD98,
+    0x6580A365, 0xDFE476DF, 0x08459A08, 0x024B9202, 0xA0E080A0, 0x665A7866,
+    0xDDAFE4DD, 0xB06ADDB0, 0xBF63D1BF, 0x362A3836, 0x54E60D54, 0x4320C643,
+    0x62CC3562, 0xBEF298BE, 0x1E12181E, 0x24EBF724, 0xD7A1ECD7, 0x77416C77,
+    0xBD2843BD, 0x32BC7532, 0xD47B37D4, 0x9B88269B, 0x700DFA70, 0xF94413F9,
+    0xB1FB94B1, 0x5A7E485A, 0x7A03F27A, 0xE48CD0E4, 0x47B68B47, 0x3C24303C,
+    0xA5E784A5, 0x416B5441, 0x06DDDF06, 0xC56023C5, 0x45FD1945, 0xA33A5BA3,
+    0x68C23D68, 0x158D5915, 0x21ECF321, 0x3166AE31, 0x3E6FA23E, 0x16578216,
+    0x95106395, 0x5BEF015B, 0x4DB8834D, 0x91862E91, 0xB56DD9B5, 0x1F83511F,
+    0x53AA9B53, 0x635D7C63, 0x3B68A63B, 0x3FFEEB3F, 0xD630A5D6, 0x257ABE25,
+    0xA7AC16A7, 0x0F090C0F, 0x35F0E335, 0x23A76123, 0xF090C0F0, 0xAFE98CAF,
+    0x809D3A80, 0x925CF592, 0x810C7381, 0x27312C27, 0x76D02576, 0xE7560BE7,
+    0x7B92BB7B, 0xE9CE4EE9, 0xF10189F1, 0x9F1E6B9F, 0xA93453A9, 0xC4F16AC4,
+    0x99C3B499, 0x975BF197, 0x8347E183, 0x6B18E66B, 0xC822BDC8, 0x0E98450E,
+    0x6E1FE26E, 0xC9B3F4C9, 0x2F74B62F, 0xCBF866CB, 0xFF99CCFF, 0xEA1495EA,
+    0xED5803ED, 0xF7DC56F7, 0xE18BD4E1, 0x1B151C1B, 0xADA21EAD, 0x0CD3D70C,
+    0x2BE2FB2B, 0x1DC8C31D, 0x195E8E19, 0xC22CB5C2, 0x8949E989, 0x12C1CF12,
+    0x7E95BF7E, 0x207DBA20, 0x6411EA64, 0x840B7784, 0x6DC5396D, 0x6A89AF6A,
+    0xD17C33D1, 0xA171C9A1, 0xCEFF62CE, 0x37BB7137, 0xFB0F81FB, 0x3DB5793D,
+    0x51E10951, 0xDC3EADDC, 0x2D3F242D, 0xA476CDA4, 0x9D55F99D, 0xEE82D8EE,
+    0x8640E586, 0xAE78C5AE, 0xCD25B9CD, 0x04964D04, 0x55774455, 0x0A0E080A,
+    0x13508613, 0x30F7E730, 0xD337A1D3, 0x40FA1D40, 0x3461AA34, 0x8C4EED8C,
+    0xB3B006B3, 0x6C54706C, 0x2A73B22A, 0x523BD252, 0x0B9F410B, 0x8B027B8B,
+    0x88D8A088, 0x4FF3114F, 0x67CB3167, 0x4627C246, 0xC06727C0, 0xB4FC90B4,
+    0x28382028, 0x7F04F67F, 0x78486078, 0x2EE5FF2E, 0x074C9607, 0x4B655C4B,
+    0xC72BB1C7, 0x6F8EAB6F, 0x0D429E0D, 0xBBF59CBB, 0xF2DB52F2, 0xF34A1BF3,
+    0xA63D5FA6, 0x59A49359, 0xBCB90ABC, 0x3AF9EF3A, 0xEF1391EF, 0xFE0885FE,
+    0x01914901, 0x6116EE61, 0x7CDE2D7C, 0xB2214FB2, 0x42B18F42, 0xDB723BDB,
+    0xB82F47B8, 0x48BF8748, 0x2CAE6D2C, 0xE3C046E3, 0x573CD657, 0x859A3E85,
+    0x29A96929, 0x7D4F647D, 0x94812A94, 0x492ECE49, 0x17C6CB17, 0xCA692FCA,
+    0xC3BDFCC3, 0x5CA3975C, 0x5EE8055E, 0xD0ED7AD0, 0x87D1AC87, 0x8E057F8E,
+    0xBA64D5BA, 0xA8A51AA8, 0xB7264BB7, 0xB9BE0EB9, 0x6087A760, 0xF8D55AF8,
+    0x22362822, 0x111B1411, 0xDE753FDE, 0x79D92979, 0xAAEE88AA, 0x332D3C33,
+    0x5F794C5F, 0xB6B702B6, 0x96CAB896, 0x5835DA58, 0x9CC4B09C, 0xFC4317FC,
+    0x1A84551A, 0xF64D1FF6, 0x1C598A1C, 0x38B27D38, 0xAC3357AC, 0x18CFC718,
+    0xF4068DF4, 0x69537469, 0x749BB774, 0xF597C4F5, 0x56AD9F56, 0xDAE372DA,
+    0xD5EA7ED5, 0x4AF4154A, 0x9E8F229E, 0xA2AB12A2, 0x4E62584E, 0xE85F07E8,
+    0xE51D99E5, 0x39233439, 0xC1F66EC1, 0x446C5044, 0x5D32DE5D, 0x72466872,
+    0x26A06526, 0x93CDBC93, 0x03DADB03, 0xC6BAF8C6, 0xFA9EC8FA, 0x82D6A882,
+    0xCF6E2BCF, 0x50704050, 0xEB85DCEB, 0x750AFE75, 0x8A93328A, 0x8DDFA48D,
+    0x4C29CA4C, 0x141C1014, 0x73D72173, 0xCCB4F0CC, 0x09D4D309, 0x108A5D10,
+    0xE2510FE2, 0x00000000, 0x9A196F9A, 0xE01A9DE0, 0x8F94368F, 0xE6C742E6,
+    0xECC94AEC, 0xFDD25EFD, 0xAB7FC1AB, 0xD8A8E0D8}
+};
+
+/* The exp_to_poly and poly_to_exp tables are used to perform efficient
+ * operations in GF(2^8) represented as GF(2)[x]/w(x) where
+ * w(x)=x^8+x^6+x^3+x^2+1.  We care about doing that because it's part of the
+ * definition of the RS matrix in the key schedule.  Elements of that field
+ * are polynomials of degree not greater than 7 and all coefficients 0 or 1,
+ * which can be represented naturally by bytes (just substitute x=2).  In that
+ * form, GF(2^8) addition is the same as bitwise XOR, but GF(2^8)
+ * multiplication is inefficient without hardware support.  To multiply
+ * faster, I make use of the fact x is a generator for the nonzero elements,
+ * so that every element p of GF(2)[x]/w(x) is either 0 or equal to (x)^n for
+ * some n in 0..254.  Note that that caret is exponentiation in GF(2^8),
+ * *not* polynomial notation.  So if I want to compute pq where p and q are
+ * in GF(2^8), I can just say:
+ *    1. if p=0 or q=0 then pq=0
+ *    2. otherwise, find m and n such that p=x^m and q=x^n
+ *    3. pq=(x^m)(x^n)=x^(m+n), so add m and n and find pq
+ * The translations in steps 2 and 3 are looked up in the tables
+ * poly_to_exp (for step 2) and exp_to_poly (for step 3).  To see this
+ * in action, look at the CALC_S macro.  As additional wrinkles, note that
+ * one of my operands is always a constant, so the poly_to_exp lookup on it
+ * is done in advance; I included the original values in the comments so
+ * readers can have some chance of recognizing that this *is* the RS matrix
+ * from the Twofish paper.  I've only included the table entries I actually
+ * need; I never do a lookup on a variable input of zero and the biggest
+ * exponents I'll ever see are 254 (variable) and 237 (constant), so they'll
+ * never sum to more than 491.	I'm repeating part of the exp_to_poly table
+ * so that I don't have to do mod-255 reduction in the exponent arithmetic.
+ * Since I know my constant operands are never zero, I only have to worry
+ * about zero values in the variable operand, and I do it with a simple
+ * conditional branch.	I know conditionals are expensive, but I couldn't
+ * see a non-horrible way of avoiding them, and I did manage to group the
+ * statements so that each if covers four group multiplications. */
+
+static const u8 poly_to_exp[255] = {
+   0x00, 0x01, 0x17, 0x02, 0x2E, 0x18, 0x53, 0x03, 0x6A, 0x2F, 0x93, 0x19,
+   0x34, 0x54, 0x45, 0x04, 0x5C, 0x6B, 0xB6, 0x30, 0xA6, 0x94, 0x4B, 0x1A,
+   0x8C, 0x35, 0x81, 0x55, 0xAA, 0x46, 0x0D, 0x05, 0x24, 0x5D, 0x87, 0x6C,
+   0x9B, 0xB7, 0xC1, 0x31, 0x2B, 0xA7, 0xA3, 0x95, 0x98, 0x4C, 0xCA, 0x1B,
+   0xE6, 0x8D, 0x73, 0x36, 0xCD, 0x82, 0x12, 0x56, 0x62, 0xAB, 0xF0, 0x47,
+   0x4F, 0x0E, 0xBD, 0x06, 0xD4, 0x25, 0xD2, 0x5E, 0x27, 0x88, 0x66, 0x6D,
+   0xD6, 0x9C, 0x79, 0xB8, 0x08, 0xC2, 0xDF, 0x32, 0x68, 0x2C, 0xFD, 0xA8,
+   0x8A, 0xA4, 0x5A, 0x96, 0x29, 0x99, 0x22, 0x4D, 0x60, 0xCB, 0xE4, 0x1C,
+   0x7B, 0xE7, 0x3B, 0x8E, 0x9E, 0x74, 0xF4, 0x37, 0xD8, 0xCE, 0xF9, 0x83,
+   0x6F, 0x13, 0xB2, 0x57, 0xE1, 0x63, 0xDC, 0xAC, 0xC4, 0xF1, 0xAF, 0x48,
+   0x0A, 0x50, 0x42, 0x0F, 0xBA, 0xBE, 0xC7, 0x07, 0xDE, 0xD5, 0x78, 0x26,
+   0x65, 0xD3, 0xD1, 0x5F, 0xE3, 0x28, 0x21, 0x89, 0x59, 0x67, 0xFC, 0x6E,
+   0xB1, 0xD7, 0xF8, 0x9D, 0xF3, 0x7A, 0x3A, 0xB9, 0xC6, 0x09, 0x41, 0xC3,
+   0xAE, 0xE0, 0xDB, 0x33, 0x44, 0x69, 0x92, 0x2D, 0x52, 0xFE, 0x16, 0xA9,
+   0x0C, 0x8B, 0x80, 0xA5, 0x4A, 0x5B, 0xB5, 0x97, 0xC9, 0x2A, 0xA2, 0x9A,
+   0xC0, 0x23, 0x86, 0x4E, 0xBC, 0x61, 0xEF, 0xCC, 0x11, 0xE5, 0x72, 0x1D,
+   0x3D, 0x7C, 0xEB, 0xE8, 0xE9, 0x3C, 0xEA, 0x8F, 0x7D, 0x9F, 0xEC, 0x75,
+   0x1E, 0xF5, 0x3E, 0x38, 0xF6, 0xD9, 0x3F, 0xCF, 0x76, 0xFA, 0x1F, 0x84,
+   0xA0, 0x70, 0xED, 0x14, 0x90, 0xB3, 0x7E, 0x58, 0xFB, 0xE2, 0x20, 0x64,
+   0xD0, 0xDD, 0x77, 0xAD, 0xDA, 0xC5, 0x40, 0xF2, 0x39, 0xB0, 0xF7, 0x49,
+   0xB4, 0x0B, 0x7F, 0x51, 0x15, 0x43, 0x91, 0x10, 0x71, 0xBB, 0xEE, 0xBF,
+   0x85, 0xC8, 0xA1
+};
+
+static const u8 exp_to_poly[492] = {
+   0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D, 0x9A, 0x79, 0xF2,
+   0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC, 0xF5, 0xA7, 0x03,
+   0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3, 0x8B, 0x5B, 0xB6,
+   0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52, 0xA4, 0x05, 0x0A,
+   0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0, 0xED, 0x97, 0x63,
+   0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1, 0x0F, 0x1E, 0x3C,
+   0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A, 0xF4, 0xA5, 0x07,
+   0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11, 0x22, 0x44, 0x88,
+   0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51, 0xA2, 0x09, 0x12,
+   0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66, 0xCC, 0xD5, 0xE7,
+   0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB, 0x1B, 0x36, 0x6C,
+   0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19, 0x32, 0x64, 0xC8,
+   0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D, 0x5A, 0xB4, 0x25,
+   0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56, 0xAC, 0x15, 0x2A,
+   0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE, 0x91, 0x6F, 0xDE,
+   0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9, 0x3F, 0x7E, 0xFC,
+   0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE, 0xB1, 0x2F, 0x5E,
+   0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41, 0x82, 0x49, 0x92,
+   0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E, 0x71, 0xE2, 0x89,
+   0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB, 0xDB, 0xFB, 0xBB,
+   0x3B, 0x76, 0xEC, 0x95, 0x67, 0xCE, 0xD1, 0xEF, 0x93, 0x6B, 0xD6, 0xE1,
+   0x8F, 0x53, 0xA6, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D,
+   0x9A, 0x79, 0xF2, 0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC,
+   0xF5, 0xA7, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3,
+   0x8B, 0x5B, 0xB6, 0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52,
+   0xA4, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0,
+   0xED, 0x97, 0x63, 0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1,
+   0x0F, 0x1E, 0x3C, 0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A,
+   0xF4, 0xA5, 0x07, 0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11,
+   0x22, 0x44, 0x88, 0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51,
+   0xA2, 0x09, 0x12, 0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66,
+   0xCC, 0xD5, 0xE7, 0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB,
+   0x1B, 0x36, 0x6C, 0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19,
+   0x32, 0x64, 0xC8, 0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D,
+   0x5A, 0xB4, 0x25, 0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56,
+   0xAC, 0x15, 0x2A, 0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE,
+   0x91, 0x6F, 0xDE, 0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9,
+   0x3F, 0x7E, 0xFC, 0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE,
+   0xB1, 0x2F, 0x5E, 0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41,
+   0x82, 0x49, 0x92, 0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E,
+   0x71, 0xE2, 0x89, 0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB
+};
+
+
+/* The table constants are indices of
+ * S-box entries, preprocessed through q0 and q1. */
+static const u8 calc_sb_tbl[512] = {
+    0xA9, 0x75, 0x67, 0xF3, 0xB3, 0xC6, 0xE8, 0xF4,
+    0x04, 0xDB, 0xFD, 0x7B, 0xA3, 0xFB, 0x76, 0xC8,
+    0x9A, 0x4A, 0x92, 0xD3, 0x80, 0xE6, 0x78, 0x6B,
+    0xE4, 0x45, 0xDD, 0x7D, 0xD1, 0xE8, 0x38, 0x4B,
+    0x0D, 0xD6, 0xC6, 0x32, 0x35, 0xD8, 0x98, 0xFD,
+    0x18, 0x37, 0xF7, 0x71, 0xEC, 0xF1, 0x6C, 0xE1,
+    0x43, 0x30, 0x75, 0x0F, 0x37, 0xF8, 0x26, 0x1B,
+    0xFA, 0x87, 0x13, 0xFA, 0x94, 0x06, 0x48, 0x3F,
+    0xF2, 0x5E, 0xD0, 0xBA, 0x8B, 0xAE, 0x30, 0x5B,
+    0x84, 0x8A, 0x54, 0x00, 0xDF, 0xBC, 0x23, 0x9D,
+    0x19, 0x6D, 0x5B, 0xC1, 0x3D, 0xB1, 0x59, 0x0E,
+    0xF3, 0x80, 0xAE, 0x5D, 0xA2, 0xD2, 0x82, 0xD5,
+    0x63, 0xA0, 0x01, 0x84, 0x83, 0x07, 0x2E, 0x14,
+    0xD9, 0xB5, 0x51, 0x90, 0x9B, 0x2C, 0x7C, 0xA3,
+    0xA6, 0xB2, 0xEB, 0x73, 0xA5, 0x4C, 0xBE, 0x54,
+    0x16, 0x92, 0x0C, 0x74, 0xE3, 0x36, 0x61, 0x51,
+    0xC0, 0x38, 0x8C, 0xB0, 0x3A, 0xBD, 0xF5, 0x5A,
+    0x73, 0xFC, 0x2C, 0x60, 0x25, 0x62, 0x0B, 0x96,
+    0xBB, 0x6C, 0x4E, 0x42, 0x89, 0xF7, 0x6B, 0x10,
+    0x53, 0x7C, 0x6A, 0x28, 0xB4, 0x27, 0xF1, 0x8C,
+    0xE1, 0x13, 0xE6, 0x95, 0xBD, 0x9C, 0x45, 0xC7,
+    0xE2, 0x24, 0xF4, 0x46, 0xB6, 0x3B, 0x66, 0x70,
+    0xCC, 0xCA, 0x95, 0xE3, 0x03, 0x85, 0x56, 0xCB,
+    0xD4, 0x11, 0x1C, 0xD0, 0x1E, 0x93, 0xD7, 0xB8,
+    0xFB, 0xA6, 0xC3, 0x83, 0x8E, 0x20, 0xB5, 0xFF,
+    0xE9, 0x9F, 0xCF, 0x77, 0xBF, 0xC3, 0xBA, 0xCC,
+    0xEA, 0x03, 0x77, 0x6F, 0x39, 0x08, 0xAF, 0xBF,
+    0x33, 0x40, 0xC9, 0xE7, 0x62, 0x2B, 0x71, 0xE2,
+    0x81, 0x79, 0x79, 0x0C, 0x09, 0xAA, 0xAD, 0x82,
+    0x24, 0x41, 0xCD, 0x3A, 0xF9, 0xEA, 0xD8, 0xB9,
+    0xE5, 0xE4, 0xC5, 0x9A, 0xB9, 0xA4, 0x4D, 0x97,
+    0x44, 0x7E, 0x08, 0xDA, 0x86, 0x7A, 0xE7, 0x17,
+    0xA1, 0x66, 0x1D, 0x94, 0xAA, 0xA1, 0xED, 0x1D,
+    0x06, 0x3D, 0x70, 0xF0, 0xB2, 0xDE, 0xD2, 0xB3,
+    0x41, 0x0B, 0x7B, 0x72, 0xA0, 0xA7, 0x11, 0x1C,
+    0x31, 0xEF, 0xC2, 0xD1, 0x27, 0x53, 0x90, 0x3E,
+    0x20, 0x8F, 0xF6, 0x33, 0x60, 0x26, 0xFF, 0x5F,
+    0x96, 0xEC, 0x5C, 0x76, 0xB1, 0x2A, 0xAB, 0x49,
+    0x9E, 0x81, 0x9C, 0x88, 0x52, 0xEE, 0x1B, 0x21,
+    0x5F, 0xC4, 0x93, 0x1A, 0x0A, 0xEB, 0xEF, 0xD9,
+    0x91, 0xC5, 0x85, 0x39, 0x49, 0x99, 0xEE, 0xCD,
+    0x2D, 0xAD, 0x4F, 0x31, 0x8F, 0x8B, 0x3B, 0x01,
+    0x47, 0x18, 0x87, 0x23, 0x6D, 0xDD, 0x46, 0x1F,
+    0xD6, 0x4E, 0x3E, 0x2D, 0x69, 0xF9, 0x64, 0x48,
+    0x2A, 0x4F, 0xCE, 0xF2, 0xCB, 0x65, 0x2F, 0x8E,
+    0xFC, 0x78, 0x97, 0x5C, 0x05, 0x58, 0x7A, 0x19,
+    0xAC, 0x8D, 0x7F, 0xE5, 0xD5, 0x98, 0x1A, 0x57,
+    0x4B, 0x67, 0x0E, 0x7F, 0xA7, 0x05, 0x5A, 0x64,
+    0x28, 0xAF, 0x14, 0x63, 0x3F, 0xB6, 0x29, 0xFE,
+    0x88, 0xF5, 0x3C, 0xB7, 0x4C, 0x3C, 0x02, 0xA5,
+    0xB8, 0xCE, 0xDA, 0xE9, 0xB0, 0x68, 0x17, 0x44,
+    0x55, 0xE0, 0x1F, 0x4D, 0x8A, 0x43, 0x7D, 0x69,
+    0x57, 0x29, 0xC7, 0x2E, 0x8D, 0xAC, 0x74, 0x15,
+    0xB7, 0x59, 0xC4, 0xA8, 0x9F, 0x0A, 0x72, 0x9E,
+    0x7E, 0x6E, 0x15, 0x47, 0x22, 0xDF, 0x12, 0x34,
+    0x58, 0x35, 0x07, 0x6A, 0x99, 0xCF, 0x34, 0xDC,
+    0x6E, 0x22, 0x50, 0xC9, 0xDE, 0xC0, 0x68, 0x9B,
+    0x65, 0x89, 0xBC, 0xD4, 0xDB, 0xED, 0xF8, 0xAB,
+    0xC8, 0x12, 0xA8, 0xA2, 0x2B, 0x0D, 0x40, 0x52,
+    0xDC, 0xBB, 0xFE, 0x02, 0x32, 0x2F, 0xA4, 0xA9,
+    0xCA, 0xD7, 0x10, 0x61, 0x21, 0x1E, 0xF0, 0xB4,
+    0xD3, 0x50, 0x5D, 0x04, 0x0F, 0xF6, 0x00, 0xC2,
+    0x6F, 0x16, 0x9D, 0x25, 0x36, 0x86, 0x42, 0x56,
+    0x4A, 0x55, 0x5E, 0x09, 0xC1, 0xBE, 0xE0, 0x91
+};
+
+/* Macro to perform one column of the RS matrix multiplication.  The
+ * parameters a, b, c, and d are the four bytes of output; i is the index
+ * of the key bytes, and w, x, y, and z, are the column of constants from
+ * the RS matrix, preprocessed through the poly_to_exp table. */
+
+#define CALC_S(a, b, c, d, i, w, x, y, z) \
+   if (key[i]) { \
+      tmp = poly_to_exp[key[i] - 1]; \
+      (a) ^= exp_to_poly[tmp + (w)]; \
+      (b) ^= exp_to_poly[tmp + (x)]; \
+      (c) ^= exp_to_poly[tmp + (y)]; \
+      (d) ^= exp_to_poly[tmp + (z)]; \
+   }
+
+/* Macros to calculate the key-dependent S-boxes for a 128-bit key using
+ * the S vector from CALC_S.  CALC_SB_2 computes a single entry in all
+ * four S-boxes, where i is the index of the entry to compute, and a and b
+ * are the index numbers preprocessed through the q0 and q1 tables
+ * respectively. */
+
+#define CALC_SB_2(i, a, b) \
+   ctx-&gt;s[0][i] = mds[0][q0[(a) ^ sa] ^ se]; \
+   ctx-&gt;s[1][i] = mds[1][q0[(b) ^ sb] ^ sf]; \
+   ctx-&gt;s[2][i] = mds[2][q1[(a) ^ sc] ^ sg]; \
+   ctx-&gt;s[3][i] = mds[3][q1[(b) ^ sd] ^ sh]
+
+/* Macro exactly like CALC_SB_2, but for 192-bit keys. */
+
+#define CALC_SB192_2(i, a, b) \
+   ctx-&gt;s[0][i] = mds[0][q0[q0[(b) ^ sa] ^ se] ^ si]; \
+   ctx-&gt;s[1][i] = mds[1][q0[q1[(b) ^ sb] ^ sf] ^ sj]; \
+   ctx-&gt;s[2][i] = mds[2][q1[q0[(a) ^ sc] ^ sg] ^ sk]; \
+   ctx-&gt;s[3][i] = mds[3][q1[q1[(a) ^ sd] ^ sh] ^ sl];
+
+/* Macro exactly like CALC_SB_2, but for 256-bit keys. */
+
+#define CALC_SB256_2(i, a, b) \
+   ctx-&gt;s[0][i] = mds[0][q0[q0[q1[(b) ^ sa] ^ se] ^ si] ^ sm]; \
+   ctx-&gt;s[1][i] = mds[1][q0[q1[q1[(a) ^ sb] ^ sf] ^ sj] ^ sn]; \
+   ctx-&gt;s[2][i] = mds[2][q1[q0[q0[(a) ^ sc] ^ sg] ^ sk] ^ so]; \
+   ctx-&gt;s[3][i] = mds[3][q1[q1[q0[(b) ^ sd] ^ sh] ^ sl] ^ sp];
+
+/* Macros to calculate the whitening and round subkeys.  CALC_K_2 computes the
+ * last two stages of the h() function for a given index (either 2i or 2i+1).
+ * a, b, c, and d are the four bytes going into the last two stages.  For
+ * 128-bit keys, this is the entire h() function and a and c are the index
+ * preprocessed through q0 and q1 respectively; for longer keys they are the
+ * output of previous stages.  j is the index of the first key byte to use.
+ * CALC_K computes a pair of subkeys for 128-bit Twofish, by calling CALC_K_2
+ * twice, doing the Pseudo-Hadamard Transform, and doing the necessary
+ * rotations.  Its parameters are: a, the array to write the results into,
+ * j, the index of the first output entry, k and l, the preprocessed indices
+ * for index 2i, and m and n, the preprocessed indices for index 2i+1.
+ * CALC_K192_2 expands CALC_K_2 to handle 192-bit keys, by doing an
+ * additional lookup-and-XOR stage.  The parameters a, b, c and d are the
+ * four bytes going into the last three stages.  For 192-bit keys, c = d
+ * are the index preprocessed through q0, and a = b are the index
+ * preprocessed through q1; j is the index of the first key byte to use.
+ * CALC_K192 is identical to CALC_K but for using the CALC_K192_2 macro
+ * instead of CALC_K_2.
+ * CALC_K256_2 expands CALC_K192_2 to handle 256-bit keys, by doing an
+ * additional lookup-and-XOR stage.  The parameters a and b are the index
+ * preprocessed through q0 and q1 respectively; j is the index of the first
+ * key byte to use.  CALC_K256 is identical to CALC_K but for using the
+ * CALC_K256_2 macro instead of CALC_K_2. */
+
+#define CALC_K_2(a, b, c, d, j) \
+     mds[0][q0[a ^ key[(j) + 8]] ^ key[j]] \
+   ^ mds[1][q0[b ^ key[(j) + 9]] ^ key[(j) + 1]] \
+   ^ mds[2][q1[c ^ key[(j) + 10]] ^ key[(j) + 2]] \
+   ^ mds[3][q1[d ^ key[(j) + 11]] ^ key[(j) + 3]]
+
+#define CALC_K(a, j, k, l, m, n) \
+   x = CALC_K_2 (k, l, k, l, 0); \
+   y = CALC_K_2 (m, n, m, n, 4); \
+   y = rol32(y, 8); \
+   x += y; y += x; ctx-&gt;a[j] = x; \
+   ctx-&gt;a[(j) + 1] = rol32(y, 9)
+
+#define CALC_K192_2(a, b, c, d, j) \
+   CALC_K_2 (q0[a ^ key[(j) + 16]], \
+	     q1[b ^ key[(j) + 17]], \
+	     q0[c ^ key[(j) + 18]], \
+	     q1[d ^ key[(j) + 19]], j)
+
+#define CALC_K192(a, j, k, l, m, n) \
+   x = CALC_K192_2 (l, l, k, k, 0); \
+   y = CALC_K192_2 (n, n, m, m, 4); \
+   y = rol32(y, 8); \
+   x += y; y += x; ctx-&gt;a[j] = x; \
+   ctx-&gt;a[(j) + 1] = rol32(y, 9)
+
+#define CALC_K256_2(a, b, j) \
+   CALC_K192_2 (q1[b ^ key[(j) + 24]], \
+	        q1[a ^ key[(j) + 25]], \
+	        q0[a ^ key[(j) + 26]], \
+	        q0[b ^ key[(j) + 27]], j)
+
+#define CALC_K256(a, j, k, l, m, n) \
+   x = CALC_K256_2 (k, l, 0); \
+   y = CALC_K256_2 (m, n, 4); \
+   y = rol32(y, 8); \
+   x += y; y += x; ctx-&gt;a[j] = x; \
+   ctx-&gt;a[(j) + 1] = rol32(y, 9)
+
+
+
+/* Perform the key setup. */
+int twofish_setkey(void *cx, const u8 *key,
+                          unsigned int key_len, u32 *flags)
+{
+
+	struct twofish_ctx *ctx = cx;
+
+	int i, j, k;
+
+	/* Temporaries for CALC_K. */
+	u32 x, y;
+
+	/* The S vector used to key the S-boxes, split up into individual bytes.
+	 * 128-bit keys use only sa through sh; 256-bit use all of them. */
+	u8 sa = 0, sb = 0, sc = 0, sd = 0, se = 0, sf = 0, sg = 0, sh = 0;
+	u8 si = 0, sj = 0, sk = 0, sl = 0, sm = 0, sn = 0, so = 0, sp = 0;
+
+	/* Temporary for CALC_S. */
+	u8 tmp;
+
+	/* Check key length. */
+	if (key_len != 16 &amp;&amp; key_len != 24 &amp;&amp; key_len != 32)
+	{
+		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
+		return -EINVAL; /* unsupported key length */
+	}
+
+	/* Compute the first two words of the S vector.  The magic numbers are
+	 * the entries of the RS matrix, preprocessed through poly_to_exp. The
+	 * numbers in the comments are the original (polynomial form) matrix
+	 * entries. */
+	CALC_S (sa, sb, sc, sd, 0, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+	CALC_S (sa, sb, sc, sd, 1, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+	CALC_S (sa, sb, sc, sd, 2, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+	CALC_S (sa, sb, sc, sd, 3, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+	CALC_S (sa, sb, sc, sd, 4, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+	CALC_S (sa, sb, sc, sd, 5, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+	CALC_S (sa, sb, sc, sd, 6, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+	CALC_S (sa, sb, sc, sd, 7, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+	CALC_S (se, sf, sg, sh, 8, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+	CALC_S (se, sf, sg, sh, 9, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+	CALC_S (se, sf, sg, sh, 10, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+	CALC_S (se, sf, sg, sh, 11, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+	CALC_S (se, sf, sg, sh, 12, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+	CALC_S (se, sf, sg, sh, 13, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+	CALC_S (se, sf, sg, sh, 14, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+	CALC_S (se, sf, sg, sh, 15, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+
+	if (key_len == 24 || key_len == 32) { /* 192- or 256-bit key */
+		/* Calculate the third word of the S vector */
+		CALC_S (si, sj, sk, sl, 16, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+		CALC_S (si, sj, sk, sl, 17, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+		CALC_S (si, sj, sk, sl, 18, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+		CALC_S (si, sj, sk, sl, 19, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+		CALC_S (si, sj, sk, sl, 20, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+		CALC_S (si, sj, sk, sl, 21, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+		CALC_S (si, sj, sk, sl, 22, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+		CALC_S (si, sj, sk, sl, 23, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+	}
+
+	if (key_len == 32) { /* 256-bit key */
+		/* Calculate the fourth word of the S vector */
+		CALC_S (sm, sn, so, sp, 24, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+		CALC_S (sm, sn, so, sp, 25, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+		CALC_S (sm, sn, so, sp, 26, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+		CALC_S (sm, sn, so, sp, 27, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+		CALC_S (sm, sn, so, sp, 28, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+		CALC_S (sm, sn, so, sp, 29, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+		CALC_S (sm, sn, so, sp, 30, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+		CALC_S (sm, sn, so, sp, 31, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+
+		/* Compute the S-boxes. */
+		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
+			CALC_SB256_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
+		}
+
+		/* Calculate whitening and round subkeys.  The constants are
+		 * indices of subkeys, preprocessed through q0 and q1. */
+		CALC_K256 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
+		CALC_K256 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
+		CALC_K256 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
+		CALC_K256 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
+		CALC_K256 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
+		CALC_K256 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
+		CALC_K256 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
+		CALC_K256 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
+		CALC_K256 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
+		CALC_K256 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
+		CALC_K256 (k, 12, 0x18, 0x37, 0xF7, 0x71);
+		CALC_K256 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
+		CALC_K256 (k, 16, 0x43, 0x30, 0x75, 0x0F);
+		CALC_K256 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
+		CALC_K256 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
+		CALC_K256 (k, 22, 0x94, 0x06, 0x48, 0x3F);
+		CALC_K256 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
+		CALC_K256 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
+		CALC_K256 (k, 28, 0x84, 0x8A, 0x54, 0x00);
+		CALC_K256 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
+	} else if (key_len == 24) { /* 192-bit key */
+		/* Compute the S-boxes. */
+		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
+		        CALC_SB192_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
+		}
+
+		/* Calculate whitening and round subkeys.  The constants are
+		 * indices of subkeys, preprocessed through q0 and q1. */
+		CALC_K192 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
+		CALC_K192 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
+		CALC_K192 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
+		CALC_K192 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
+		CALC_K192 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
+		CALC_K192 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
+		CALC_K192 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
+		CALC_K192 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
+		CALC_K192 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
+		CALC_K192 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
+		CALC_K192 (k, 12, 0x18, 0x37, 0xF7, 0x71);
+		CALC_K192 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
+		CALC_K192 (k, 16, 0x43, 0x30, 0x75, 0x0F);
+		CALC_K192 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
+		CALC_K192 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
+		CALC_K192 (k, 22, 0x94, 0x06, 0x48, 0x3F);
+		CALC_K192 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
+		CALC_K192 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
+		CALC_K192 (k, 28, 0x84, 0x8A, 0x54, 0x00);
+		CALC_K192 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
+	} else { /* 128-bit key */
+		/* Compute the S-boxes. */
+		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
+			CALC_SB_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
+		}
+
+		/* Calculate whitening and round subkeys.  The constants are
+		 * indices of subkeys, preprocessed through q0 and q1. */
+		CALC_K (w, 0, 0xA9, 0x75, 0x67, 0xF3);
+		CALC_K (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
+		CALC_K (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
+		CALC_K (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
+		CALC_K (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
+		CALC_K (k, 2, 0x80, 0xE6, 0x78, 0x6B);
+		CALC_K (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
+		CALC_K (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
+		CALC_K (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
+		CALC_K (k, 10, 0x35, 0xD8, 0x98, 0xFD);
+		CALC_K (k, 12, 0x18, 0x37, 0xF7, 0x71);
+		CALC_K (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
+		CALC_K (k, 16, 0x43, 0x30, 0x75, 0x0F);
+		CALC_K (k, 18, 0x37, 0xF8, 0x26, 0x1B);
+		CALC_K (k, 20, 0xFA, 0x87, 0x13, 0xFA);
+		CALC_K (k, 22, 0x94, 0x06, 0x48, 0x3F);
+		CALC_K (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
+		CALC_K (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
+		CALC_K (k, 28, 0x84, 0x8A, 0x54, 0x00);
+		CALC_K (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
+	}
+
+	return 0;
+}
+
+
+
diff -uprN linux-2.6.17-rc5/include/crypto/twofish.h linux-2.6.17-rc5.twofish/include/crypto/twofish.h
--- linux-2.6.17-rc5/include/crypto/twofish.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish/include/crypto/twofish.h	2006-06-07 19:05:37.021612482 +0200
@@ -0,0 +1,14 @@
+#define TF_MIN_KEY_SIZE 16
+#define TF_MAX_KEY_SIZE 32
+#define TF_BLOCK_SIZE 16
+
+/* Structure for an expanded Twofish key.  s contains the key-dependent
+ * S-boxes composed with the MDS matrix; w contains the eight "whitening"
+ * subkeys, K[0] through K[7].	k holds the remaining, "round" subkeys.  Note
+ * that k[i] corresponds to what the Twofish paper calls K[i+8]. */
+struct twofish_ctx {
+   u32 s[4][256], w[8], k[32];
+};
+
+int twofish_setkey(void *cx, const u8 *key,unsigned int key_len, u32 *flags);
+
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060608011515</emailId><senderName>Andi Kleen</senderName><senderEmail>ak@suse.de</senderEmail><timestampReceived>2006-06-08 01:15:15-0400</timestampReceived><subject>Re: [PATCH  1/4] Twofish cipher - split out common c code</subject><body>

On Wednesday 07 June 2006 21:37, Joachim Fritschi wrote:
&gt; On Sunday 04 June 2006 15:16, Joachim Fritschi wrote:
&gt; &gt; I have revised my initial twofish assembler patchset according to the 
&gt; &gt; criticims i recieved on this list:
&gt; &gt; This patch splits up the twofish crypto routine into a common part ( key 
&gt; &gt; setup  ) which will be uses by all twofish crypto modules ( generic-c , i586 
&gt; &gt; assembler and x86_64 assembler ) and generic-c part. It also creates a new 
&gt; &gt; header file which will be used by all 3 modules. 
&gt; &gt; This eliminates all code duplication.
&gt; &gt; Correctness was verified with the tcrypt module and automated test scripts.
&gt; My first mail was wordwrapped. This one should be unwrapped and working:

Thanks I merged them all now.

-Andi
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060608015728</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-06-08 01:57:28-0400</timestampReceived><subject>Re: [PATCH  1/4] Twofish cipher - split out common c code</subject><body>

On Wed, Jun 07, 2006 at 09:37:23PM +0200, Joachim Fritschi wrote:
&gt; 
&gt; diff -uprN linux-2.6.17-rc5/crypto/Makefile linux-2.6.17-rc5.twofish/crypto/Makefile
&gt; --- linux-2.6.17-rc5/crypto/Makefile	2006-06-07 18:43:24.000000000 +0200
&gt; +++ linux-2.6.17-rc5.twofish/crypto/Makefile	2006-06-04 13:59:27.949797218 +0200
&gt; @@ -32,3 +32,5 @@ obj-$(CONFIG_CRYPTO_MICHAEL_MIC) += mich
&gt;  obj-$(CONFIG_CRYPTO_CRC32C) += crc32c.o
&gt;  
&gt;  obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
&gt; +
&gt; +twofish-objs := twofish_c.o twofish_common.o

What do we gain by renaming twofish.c to twofish_c.c?
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060608072004</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-08 07:20:04-0400</timestampReceived><subject>Re: [PATCH  1/4] Twofish cipher - split out common c code</subject><body>

On Thursday 08 June 2006 03:57, Herbert Xu wrote:
&gt; On Wed, Jun 07, 2006 at 09:37:23PM +0200, Joachim Fritschi wrote:
&gt; &gt; 
&gt; &gt; diff -uprN linux-2.6.17-rc5/crypto/Makefile linux-2.6.17-rc5.twofish/crypto/Makefile
&gt; &gt; --- linux-2.6.17-rc5/crypto/Makefile	2006-06-07 18:43:24.000000000 +0200
&gt; &gt; +++ linux-2.6.17-rc5.twofish/crypto/Makefile	2006-06-04 13:59:27.949797218 +0200
&gt; &gt; @@ -32,3 +32,5 @@ obj-$(CONFIG_CRYPTO_MICHAEL_MIC) += mich
&gt; &gt;  obj-$(CONFIG_CRYPTO_CRC32C) += crc32c.o
&gt; &gt;  
&gt; &gt;  obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
&gt; &gt; +
&gt; &gt; +twofish-objs := twofish_c.o twofish_common.o
&gt; 
&gt; What do we gain by renaming twofish.c to twofish_c.c?

Solve the naming conflict when compiling. Seemed to me like it is impossible to create a
twofish.o out of twofish.o and twofish_common.o . And since having the original module name
seemed more important to me i changed the name. I didn't find any other way in documentation
of the kernel makefiles. I hope this isn't another newbie mistake. =)

-Joachim
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060608072735</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-06-08 07:27:35-0400</timestampReceived><subject>Re: [PATCH  1/4] Twofish cipher - split out common c code</subject><body>

On Thu, Jun 08, 2006 at 09:20:04AM +0200, Joachim Fritschi wrote:
&gt; 
&gt; Solve the naming conflict when compiling. Seemed to me like it is impossible to create a
&gt; twofish.o out of twofish.o and twofish_common.o . And since having the original module name
&gt; seemed more important to me i changed the name. I didn't find any other way in documentation
&gt; of the kernel makefiles. I hope this isn't another newbie mistake. =)

Just make a module out of the common code.  See sound/isa/sb/Makefile
for an example.  It would also help to make a common Kconfig symbol
that is not visible to the user but instead is selected by any one
of the twofish implementations.

If you do it this way then the assembly implementations just need to
select that Kconfig symbol to get the common code either built as a
module or compiled in.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060616115852</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-16 11:58:52-0400</timestampReceived><subject>Re: [PATCH  1/4] Twofish cipher - split out common c code</subject><body>

On Thursday 08 June 2006 09:27, Herbert Xu wrote:
&gt; On Thu, Jun 08, 2006 at 09:20:04AM +0200, Joachim Fritschi wrote:
&gt; &gt; 
&gt; &gt; Solve the naming conflict when compiling. Seemed to me like it is impossible to create a
&gt; &gt; twofish.o out of twofish.o and twofish_common.o . And since having the original module name
&gt; &gt; seemed more important to me i changed the name. I didn't find any other way in documentation
&gt; &gt; of the kernel makefiles. I hope this isn't another newbie mistake. =)
&gt; 
&gt; Just make a module out of the common code.  See sound/isa/sb/Makefile
&gt; for an example.  It would also help to make a common Kconfig symbol
&gt; that is not visible to the user but instead is selected by any one
&gt; of the twofish implementations.
&gt; 
&gt; If you do it this way then the assembly implementations just need to
&gt; select that Kconfig symbol to get the common code either built as a
&gt; module or compiled in.
I have done the changes you requested. twofish and twofish_common are now 2
seperate modules. twofish_common is hidden from the user and can be shared by 
both generic-c and the asm implementation.


Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

diff -uprN linux-2.6.17-rc5/crypto/Kconfig linux-2.6.17-rc5.twofish/crypto/Kconfig
--- linux-2.6.17-rc5/crypto/Kconfig	2006-06-07 18:43:24.000000000 +0200
+++ linux-2.6.17-rc5.twofish/crypto/Kconfig	2006-06-11 16:07:48.835729599 +0200
@@ -131,6 +131,7 @@ config CRYPTO_BLOWFISH
 config CRYPTO_TWOFISH
 	tristate "Twofish cipher algorithm"
 	depends on CRYPTO
+	select CRYPTO_TWOFISH_COMMON
 	help
 	  Twofish cipher algorithm.
 	  
@@ -142,6 +143,14 @@ config CRYPTO_TWOFISH
 	  See also:
 	  &lt;http://www.schneier.com/twofish.html&gt;
 
+config CRYPTO_TWOFISH_COMMON
+        tristate	
+        depends on CRYPTO
+        help
+	  Common parts of the Twofish cipher algorithm shared by the 
+	  generic c and the assembler implementations.
+	  
+
 config CRYPTO_SERPENT
 	tristate "Serpent cipher algorithm"
 	depends on CRYPTO
diff -uprN linux-2.6.17-rc5/crypto/Makefile linux-2.6.17-rc5.twofish/crypto/Makefile
--- linux-2.6.17-rc5/crypto/Makefile	2006-06-07 18:43:24.000000000 +0200
+++ linux-2.6.17-rc5.twofish/crypto/Makefile	2006-06-11 15:58:20.315984114 +0200
@@ -18,6 +18,7 @@ obj-$(CONFIG_CRYPTO_WP512) += wp512.o
 obj-$(CONFIG_CRYPTO_TGR192) += tgr192.o
 obj-$(CONFIG_CRYPTO_DES) += des.o
 obj-$(CONFIG_CRYPTO_BLOWFISH) += blowfish.o
+obj-$(CONFIG_CRYPTO_TWOFISH_COMMON) += twofish_common.o
 obj-$(CONFIG_CRYPTO_TWOFISH) += twofish.o
 obj-$(CONFIG_CRYPTO_SERPENT) += serpent.o
 obj-$(CONFIG_CRYPTO_AES) += aes.o
diff -uprN linux-2.6.17-rc5/crypto/twofish.c linux-2.6.17-rc5.twofish/crypto/twofish.c
--- linux-2.6.17-rc5/crypto/twofish.c	2006-06-07 18:43:24.000000000 +0200
+++ linux-2.6.17-rc5.twofish/crypto/twofish.c	2006-06-11 15:58:20.315984114 +0200
@@ -9,7 +9,7 @@
  * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
  *
  * The original author has disclaimed all copyright interest in this
- * code and thus put it in the public domain. The subsequent authors 
+ * code and thus put it in the public domain. The subsequent authors
  * have put this under the GNU General Public License.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -21,7 +21,7 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
@@ -45,533 +45,7 @@
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/crypto.h&gt;
 #include &lt;linux/bitops.h&gt;
-
-
-/* The large precomputed tables for the Twofish cipher (twofish.c)
- * Taken from the same source as twofish.c
- * Marc Mutz &lt;Marc@Mutz.com&gt;
- */
-
-/* These two tables are the q0 and q1 permutations, exactly as described in
- * the Twofish paper. */
-
-static const u8 q0[256] = {
-   0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78,
-   0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C,
-   0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30,
-   0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82,
-   0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE,
-   0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B,
-   0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45,
-   0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7,
-   0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF,
-   0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8,
-   0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED,
-   0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90,
-   0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B,
-   0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B,
-   0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F,
-   0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A,
-   0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17,
-   0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72,
-   0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68,
-   0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4,
-   0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42,
-   0x4A, 0x5E, 0xC1, 0xE0
-};
-
-static const u8 q1[256] = {
-   0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B,
-   0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1,
-   0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B,
-   0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5,
-   0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54,
-   0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96,
-   0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7,
-   0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8,
-   0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF,
-   0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9,
-   0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D,
-   0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E,
-   0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21,
-   0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01,
-   0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E,
-   0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64,
-   0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44,
-   0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E,
-   0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B,
-   0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9,
-   0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56,
-   0x55, 0x09, 0xBE, 0x91
-};
-
-/* These MDS tables are actually tables of MDS composed with q0 and q1,
- * because it is only ever used that way and we can save some time by
- * precomputing.  Of course the main saving comes from precomputing the
- * GF(2^8) multiplication involved in the MDS matrix multiply; by looking
- * things up in these tables we reduce the matrix multiply to four lookups
- * and three XORs.  Semi-formally, the definition of these tables is:
- * mds[0][i] = MDS (q1[i] 0 0 0)^T  mds[1][i] = MDS (0 q0[i] 0 0)^T
- * mds[2][i] = MDS (0 0 q1[i] 0)^T  mds[3][i] = MDS (0 0 0 q0[i])^T
- * where ^T means "transpose", the matrix multiply is performed in GF(2^8)
- * represented as GF(2)[x]/v(x) where v(x)=x^8+x^6+x^5+x^3+1 as described
- * by Schneier et al, and I'm casually glossing over the byte/word
- * conversion issues. */
-
-static const u32 mds[4][256] = {
-   {0xBCBC3275, 0xECEC21F3, 0x202043C6, 0xB3B3C9F4, 0xDADA03DB, 0x02028B7B,
-    0xE2E22BFB, 0x9E9EFAC8, 0xC9C9EC4A, 0xD4D409D3, 0x18186BE6, 0x1E1E9F6B,
-    0x98980E45, 0xB2B2387D, 0xA6A6D2E8, 0x2626B74B, 0x3C3C57D6, 0x93938A32,
-    0x8282EED8, 0x525298FD, 0x7B7BD437, 0xBBBB3771, 0x5B5B97F1, 0x474783E1,
-    0x24243C30, 0x5151E20F, 0xBABAC6F8, 0x4A4AF31B, 0xBFBF4887, 0x0D0D70FA,
-    0xB0B0B306, 0x7575DE3F, 0xD2D2FD5E, 0x7D7D20BA, 0x666631AE, 0x3A3AA35B,
-    0x59591C8A, 0x00000000, 0xCDCD93BC, 0x1A1AE09D, 0xAEAE2C6D, 0x7F7FABC1,
-    0x2B2BC7B1, 0xBEBEB90E, 0xE0E0A080, 0x8A8A105D, 0x3B3B52D2, 0x6464BAD5,
-    0xD8D888A0, 0xE7E7A584, 0x5F5FE807, 0x1B1B1114, 0x2C2CC2B5, 0xFCFCB490,
-    0x3131272C, 0x808065A3, 0x73732AB2, 0x0C0C8173, 0x79795F4C, 0x6B6B4154,
-    0x4B4B0292, 0x53536974, 0x94948F36, 0x83831F51, 0x2A2A3638, 0xC4C49CB0,
-    0x2222C8BD, 0xD5D5F85A, 0xBDBDC3FC, 0x48487860, 0xFFFFCE62, 0x4C4C0796,
-    0x4141776C, 0xC7C7E642, 0xEBEB24F7, 0x1C1C1410, 0x5D5D637C, 0x36362228,
-    0x6767C027, 0xE9E9AF8C, 0x4444F913, 0x1414EA95, 0xF5F5BB9C, 0xCFCF18C7,
-    0x3F3F2D24, 0xC0C0E346, 0x7272DB3B, 0x54546C70, 0x29294CCA, 0xF0F035E3,
-    0x0808FE85, 0xC6C617CB, 0xF3F34F11, 0x8C8CE4D0, 0xA4A45993, 0xCACA96B8,
-    0x68683BA6, 0xB8B84D83, 0x38382820, 0xE5E52EFF, 0xADAD569F, 0x0B0B8477,
-    0xC8C81DC3, 0x9999FFCC, 0x5858ED03, 0x19199A6F, 0x0E0E0A08, 0x95957EBF,
-    0x70705040, 0xF7F730E7, 0x6E6ECF2B, 0x1F1F6EE2, 0xB5B53D79, 0x09090F0C,
-    0x616134AA, 0x57571682, 0x9F9F0B41, 0x9D9D803A, 0x111164EA, 0x2525CDB9,
-    0xAFAFDDE4, 0x4545089A, 0xDFDF8DA4, 0xA3A35C97, 0xEAEAD57E, 0x353558DA,
-    0xEDEDD07A, 0x4343FC17, 0xF8F8CB66, 0xFBFBB194, 0x3737D3A1, 0xFAFA401D,
-    0xC2C2683D, 0xB4B4CCF0, 0x32325DDE, 0x9C9C71B3, 0x5656E70B, 0xE3E3DA72,
-    0x878760A7, 0x15151B1C, 0xF9F93AEF, 0x6363BFD1, 0x3434A953, 0x9A9A853E,
-    0xB1B1428F, 0x7C7CD133, 0x88889B26, 0x3D3DA65F, 0xA1A1D7EC, 0xE4E4DF76,
-    0x8181942A, 0x91910149, 0x0F0FFB81, 0xEEEEAA88, 0x161661EE, 0xD7D77321,
-    0x9797F5C4, 0xA5A5A81A, 0xFEFE3FEB, 0x6D6DB5D9, 0x7878AEC5, 0xC5C56D39,
-    0x1D1DE599, 0x7676A4CD, 0x3E3EDCAD, 0xCBCB6731, 0xB6B6478B, 0xEFEF5B01,
-    0x12121E18, 0x6060C523, 0x6A6AB0DD, 0x4D4DF61F, 0xCECEE94E, 0xDEDE7C2D,
-    0x55559DF9, 0x7E7E5A48, 0x2121B24F, 0x03037AF2, 0xA0A02665, 0x5E5E198E,
-    0x5A5A6678, 0x65654B5C, 0x62624E58, 0xFDFD4519, 0x0606F48D, 0x404086E5,
-    0xF2F2BE98, 0x3333AC57, 0x17179067, 0x05058E7F, 0xE8E85E05, 0x4F4F7D64,
-    0x89896AAF, 0x10109563, 0x74742FB6, 0x0A0A75FE, 0x5C5C92F5, 0x9B9B74B7,
-    0x2D2D333C, 0x3030D6A5, 0x2E2E49CE, 0x494989E9, 0x46467268, 0x77775544,
-    0xA8A8D8E0, 0x9696044D, 0x2828BD43, 0xA9A92969, 0xD9D97929, 0x8686912E,
-    0xD1D187AC, 0xF4F44A15, 0x8D8D1559, 0xD6D682A8, 0xB9B9BC0A, 0x42420D9E,
-    0xF6F6C16E, 0x2F2FB847, 0xDDDD06DF, 0x23233934, 0xCCCC6235, 0xF1F1C46A,
-    0xC1C112CF, 0x8585EBDC, 0x8F8F9E22, 0x7171A1C9, 0x9090F0C0, 0xAAAA539B,
-    0x0101F189, 0x8B8BE1D4, 0x4E4E8CED, 0x8E8E6FAB, 0xABABA212, 0x6F6F3EA2,
-    0xE6E6540D, 0xDBDBF252, 0x92927BBB, 0xB7B7B602, 0x6969CA2F, 0x3939D9A9,
-    0xD3D30CD7, 0xA7A72361, 0xA2A2AD1E, 0xC3C399B4, 0x6C6C4450, 0x07070504,
-    0x04047FF6, 0x272746C2, 0xACACA716, 0xD0D07625, 0x50501386, 0xDCDCF756,
-    0x84841A55, 0xE1E15109, 0x7A7A25BE, 0x1313EF91},
-
-   {0xA9D93939, 0x67901717, 0xB3719C9C, 0xE8D2A6A6, 0x04050707, 0xFD985252,
-    0xA3658080, 0x76DFE4E4, 0x9A084545, 0x92024B4B, 0x80A0E0E0, 0x78665A5A,
-    0xE4DDAFAF, 0xDDB06A6A, 0xD1BF6363, 0x38362A2A, 0x0D54E6E6, 0xC6432020,
-    0x3562CCCC, 0x98BEF2F2, 0x181E1212, 0xF724EBEB, 0xECD7A1A1, 0x6C774141,
-    0x43BD2828, 0x7532BCBC, 0x37D47B7B, 0x269B8888, 0xFA700D0D, 0x13F94444,
-    0x94B1FBFB, 0x485A7E7E, 0xF27A0303, 0xD0E48C8C, 0x8B47B6B6, 0x303C2424,
-    0x84A5E7E7, 0x54416B6B, 0xDF06DDDD, 0x23C56060, 0x1945FDFD, 0x5BA33A3A,
-    0x3D68C2C2, 0x59158D8D, 0xF321ECEC, 0xAE316666, 0xA23E6F6F, 0x82165757,
-    0x63951010, 0x015BEFEF, 0x834DB8B8, 0x2E918686, 0xD9B56D6D, 0x511F8383,
-    0x9B53AAAA, 0x7C635D5D, 0xA63B6868, 0xEB3FFEFE, 0xA5D63030, 0xBE257A7A,
-    0x16A7ACAC, 0x0C0F0909, 0xE335F0F0, 0x6123A7A7, 0xC0F09090, 0x8CAFE9E9,
-    0x3A809D9D, 0xF5925C5C, 0x73810C0C, 0x2C273131, 0x2576D0D0, 0x0BE75656,
-    0xBB7B9292, 0x4EE9CECE, 0x89F10101, 0x6B9F1E1E, 0x53A93434, 0x6AC4F1F1,
-    0xB499C3C3, 0xF1975B5B, 0xE1834747, 0xE66B1818, 0xBDC82222, 0x450E9898,
-    0xE26E1F1F, 0xF4C9B3B3, 0xB62F7474, 0x66CBF8F8, 0xCCFF9999, 0x95EA1414,
-    0x03ED5858, 0x56F7DCDC, 0xD4E18B8B, 0x1C1B1515, 0x1EADA2A2, 0xD70CD3D3,
-    0xFB2BE2E2, 0xC31DC8C8, 0x8E195E5E, 0xB5C22C2C, 0xE9894949, 0xCF12C1C1,
-    0xBF7E9595, 0xBA207D7D, 0xEA641111, 0x77840B0B, 0x396DC5C5, 0xAF6A8989,
-    0x33D17C7C, 0xC9A17171, 0x62CEFFFF, 0x7137BBBB, 0x81FB0F0F, 0x793DB5B5,
-    0x0951E1E1, 0xADDC3E3E, 0x242D3F3F, 0xCDA47676, 0xF99D5555, 0xD8EE8282,
-    0xE5864040, 0xC5AE7878, 0xB9CD2525, 0x4D049696, 0x44557777, 0x080A0E0E,
-    0x86135050, 0xE730F7F7, 0xA1D33737, 0x1D40FAFA, 0xAA346161, 0xED8C4E4E,
-    0x06B3B0B0, 0x706C5454, 0xB22A7373, 0xD2523B3B, 0x410B9F9F, 0x7B8B0202,
-    0xA088D8D8, 0x114FF3F3, 0x3167CBCB, 0xC2462727, 0x27C06767, 0x90B4FCFC,
-    0x20283838, 0xF67F0404, 0x60784848, 0xFF2EE5E5, 0x96074C4C, 0x5C4B6565,
-    0xB1C72B2B, 0xAB6F8E8E, 0x9E0D4242, 0x9CBBF5F5, 0x52F2DBDB, 0x1BF34A4A,
-    0x5FA63D3D, 0x9359A4A4, 0x0ABCB9B9, 0xEF3AF9F9, 0x91EF1313, 0x85FE0808,
-    0x49019191, 0xEE611616, 0x2D7CDEDE, 0x4FB22121, 0x8F42B1B1, 0x3BDB7272,
-    0x47B82F2F, 0x8748BFBF, 0x6D2CAEAE, 0x46E3C0C0, 0xD6573C3C, 0x3E859A9A,
-    0x6929A9A9, 0x647D4F4F, 0x2A948181, 0xCE492E2E, 0xCB17C6C6, 0x2FCA6969,
-    0xFCC3BDBD, 0x975CA3A3, 0x055EE8E8, 0x7AD0EDED, 0xAC87D1D1, 0x7F8E0505,
-    0xD5BA6464, 0x1AA8A5A5, 0x4BB72626, 0x0EB9BEBE, 0xA7608787, 0x5AF8D5D5,
-    0x28223636, 0x14111B1B, 0x3FDE7575, 0x2979D9D9, 0x88AAEEEE, 0x3C332D2D,
-    0x4C5F7979, 0x02B6B7B7, 0xB896CACA, 0xDA583535, 0xB09CC4C4, 0x17FC4343,
-    0x551A8484, 0x1FF64D4D, 0x8A1C5959, 0x7D38B2B2, 0x57AC3333, 0xC718CFCF,
-    0x8DF40606, 0x74695353, 0xB7749B9B, 0xC4F59797, 0x9F56ADAD, 0x72DAE3E3,
-    0x7ED5EAEA, 0x154AF4F4, 0x229E8F8F, 0x12A2ABAB, 0x584E6262, 0x07E85F5F,
-    0x99E51D1D, 0x34392323, 0x6EC1F6F6, 0x50446C6C, 0xDE5D3232, 0x68724646,
-    0x6526A0A0, 0xBC93CDCD, 0xDB03DADA, 0xF8C6BABA, 0xC8FA9E9E, 0xA882D6D6,
-    0x2BCF6E6E, 0x40507070, 0xDCEB8585, 0xFE750A0A, 0x328A9393, 0xA48DDFDF,
-    0xCA4C2929, 0x10141C1C, 0x2173D7D7, 0xF0CCB4B4, 0xD309D4D4, 0x5D108A8A,
-    0x0FE25151, 0x00000000, 0x6F9A1919, 0x9DE01A1A, 0x368F9494, 0x42E6C7C7,
-    0x4AECC9C9, 0x5EFDD2D2, 0xC1AB7F7F, 0xE0D8A8A8},
-
-   {0xBC75BC32, 0xECF3EC21, 0x20C62043, 0xB3F4B3C9, 0xDADBDA03, 0x027B028B,
-    0xE2FBE22B, 0x9EC89EFA, 0xC94AC9EC, 0xD4D3D409, 0x18E6186B, 0x1E6B1E9F,
-    0x9845980E, 0xB27DB238, 0xA6E8A6D2, 0x264B26B7, 0x3CD63C57, 0x9332938A,
-    0x82D882EE, 0x52FD5298, 0x7B377BD4, 0xBB71BB37, 0x5BF15B97, 0x47E14783,
-    0x2430243C, 0x510F51E2, 0xBAF8BAC6, 0x4A1B4AF3, 0xBF87BF48, 0x0DFA0D70,
-    0xB006B0B3, 0x753F75DE, 0xD25ED2FD, 0x7DBA7D20, 0x66AE6631, 0x3A5B3AA3,
-    0x598A591C, 0x00000000, 0xCDBCCD93, 0x1A9D1AE0, 0xAE6DAE2C, 0x7FC17FAB,
-    0x2BB12BC7, 0xBE0EBEB9, 0xE080E0A0, 0x8A5D8A10, 0x3BD23B52, 0x64D564BA,
-    0xD8A0D888, 0xE784E7A5, 0x5F075FE8, 0x1B141B11, 0x2CB52CC2, 0xFC90FCB4,
-    0x312C3127, 0x80A38065, 0x73B2732A, 0x0C730C81, 0x794C795F, 0x6B546B41,
-    0x4B924B02, 0x53745369, 0x9436948F, 0x8351831F, 0x2A382A36, 0xC4B0C49C,
-    0x22BD22C8, 0xD55AD5F8, 0xBDFCBDC3, 0x48604878, 0xFF62FFCE, 0x4C964C07,
-    0x416C4177, 0xC742C7E6, 0xEBF7EB24, 0x1C101C14, 0x5D7C5D63, 0x36283622,
-    0x672767C0, 0xE98CE9AF, 0x441344F9, 0x149514EA, 0xF59CF5BB, 0xCFC7CF18,
-    0x3F243F2D, 0xC046C0E3, 0x723B72DB, 0x5470546C, 0x29CA294C, 0xF0E3F035,
-    0x088508FE, 0xC6CBC617, 0xF311F34F, 0x8CD08CE4, 0xA493A459, 0xCAB8CA96,
-    0x68A6683B, 0xB883B84D, 0x38203828, 0xE5FFE52E, 0xAD9FAD56, 0x0B770B84,
-    0xC8C3C81D, 0x99CC99FF, 0x580358ED, 0x196F199A, 0x0E080E0A, 0x95BF957E,
-    0x70407050, 0xF7E7F730, 0x6E2B6ECF, 0x1FE21F6E, 0xB579B53D, 0x090C090F,
-    0x61AA6134, 0x57825716, 0x9F419F0B, 0x9D3A9D80, 0x11EA1164, 0x25B925CD,
-    0xAFE4AFDD, 0x459A4508, 0xDFA4DF8D, 0xA397A35C, 0xEA7EEAD5, 0x35DA3558,
-    0xED7AEDD0, 0x431743FC, 0xF866F8CB, 0xFB94FBB1, 0x37A137D3, 0xFA1DFA40,
-    0xC23DC268, 0xB4F0B4CC, 0x32DE325D, 0x9CB39C71, 0x560B56E7, 0xE372E3DA,
-    0x87A78760, 0x151C151B, 0xF9EFF93A, 0x63D163BF, 0x345334A9, 0x9A3E9A85,
-    0xB18FB142, 0x7C337CD1, 0x8826889B, 0x3D5F3DA6, 0xA1ECA1D7, 0xE476E4DF,
-    0x812A8194, 0x91499101, 0x0F810FFB, 0xEE88EEAA, 0x16EE1661, 0xD721D773,
-    0x97C497F5, 0xA51AA5A8, 0xFEEBFE3F, 0x6DD96DB5, 0x78C578AE, 0xC539C56D,
-    0x1D991DE5, 0x76CD76A4, 0x3EAD3EDC, 0xCB31CB67, 0xB68BB647, 0xEF01EF5B,
-    0x1218121E, 0x602360C5, 0x6ADD6AB0, 0x4D1F4DF6, 0xCE4ECEE9, 0xDE2DDE7C,
-    0x55F9559D, 0x7E487E5A, 0x214F21B2, 0x03F2037A, 0xA065A026, 0x5E8E5E19,
-    0x5A785A66, 0x655C654B, 0x6258624E, 0xFD19FD45, 0x068D06F4, 0x40E54086,
-    0xF298F2BE, 0x335733AC, 0x17671790, 0x057F058E, 0xE805E85E, 0x4F644F7D,
-    0x89AF896A, 0x10631095, 0x74B6742F, 0x0AFE0A75, 0x5CF55C92, 0x9BB79B74,
-    0x2D3C2D33, 0x30A530D6, 0x2ECE2E49, 0x49E94989, 0x46684672, 0x77447755,
-    0xA8E0A8D8, 0x964D9604, 0x284328BD, 0xA969A929, 0xD929D979, 0x862E8691,
-    0xD1ACD187, 0xF415F44A, 0x8D598D15, 0xD6A8D682, 0xB90AB9BC, 0x429E420D,
-    0xF66EF6C1, 0x2F472FB8, 0xDDDFDD06, 0x23342339, 0xCC35CC62, 0xF16AF1C4,
-    0xC1CFC112, 0x85DC85EB, 0x8F228F9E, 0x71C971A1, 0x90C090F0, 0xAA9BAA53,
-    0x018901F1, 0x8BD48BE1, 0x4EED4E8C, 0x8EAB8E6F, 0xAB12ABA2, 0x6FA26F3E,
-    0xE60DE654, 0xDB52DBF2, 0x92BB927B, 0xB702B7B6, 0x692F69CA, 0x39A939D9,
-    0xD3D7D30C, 0xA761A723, 0xA21EA2AD, 0xC3B4C399, 0x6C506C44, 0x07040705,
-    0x04F6047F, 0x27C22746, 0xAC16ACA7, 0xD025D076, 0x50865013, 0xDC56DCF7,
-    0x8455841A, 0xE109E151, 0x7ABE7A25, 0x139113EF},
-
-   {0xD939A9D9, 0x90176790, 0x719CB371, 0xD2A6E8D2, 0x05070405, 0x9852FD98,
-    0x6580A365, 0xDFE476DF, 0x08459A08, 0x024B9202, 0xA0E080A0, 0x665A7866,
-    0xDDAFE4DD, 0xB06ADDB0, 0xBF63D1BF, 0x362A3836, 0x54E60D54, 0x4320C643,
-    0x62CC3562, 0xBEF298BE, 0x1E12181E, 0x24EBF724, 0xD7A1ECD7, 0x77416C77,
-    0xBD2843BD, 0x32BC7532, 0xD47B37D4, 0x9B88269B, 0x700DFA70, 0xF94413F9,
-    0xB1FB94B1, 0x5A7E485A, 0x7A03F27A, 0xE48CD0E4, 0x47B68B47, 0x3C24303C,
-    0xA5E784A5, 0x416B5441, 0x06DDDF06, 0xC56023C5, 0x45FD1945, 0xA33A5BA3,
-    0x68C23D68, 0x158D5915, 0x21ECF321, 0x3166AE31, 0x3E6FA23E, 0x16578216,
-    0x95106395, 0x5BEF015B, 0x4DB8834D, 0x91862E91, 0xB56DD9B5, 0x1F83511F,
-    0x53AA9B53, 0x635D7C63, 0x3B68A63B, 0x3FFEEB3F, 0xD630A5D6, 0x257ABE25,
-    0xA7AC16A7, 0x0F090C0F, 0x35F0E335, 0x23A76123, 0xF090C0F0, 0xAFE98CAF,
-    0x809D3A80, 0x925CF592, 0x810C7381, 0x27312C27, 0x76D02576, 0xE7560BE7,
-    0x7B92BB7B, 0xE9CE4EE9, 0xF10189F1, 0x9F1E6B9F, 0xA93453A9, 0xC4F16AC4,
-    0x99C3B499, 0x975BF197, 0x8347E183, 0x6B18E66B, 0xC822BDC8, 0x0E98450E,
-    0x6E1FE26E, 0xC9B3F4C9, 0x2F74B62F, 0xCBF866CB, 0xFF99CCFF, 0xEA1495EA,
-    0xED5803ED, 0xF7DC56F7, 0xE18BD4E1, 0x1B151C1B, 0xADA21EAD, 0x0CD3D70C,
-    0x2BE2FB2B, 0x1DC8C31D, 0x195E8E19, 0xC22CB5C2, 0x8949E989, 0x12C1CF12,
-    0x7E95BF7E, 0x207DBA20, 0x6411EA64, 0x840B7784, 0x6DC5396D, 0x6A89AF6A,
-    0xD17C33D1, 0xA171C9A1, 0xCEFF62CE, 0x37BB7137, 0xFB0F81FB, 0x3DB5793D,
-    0x51E10951, 0xDC3EADDC, 0x2D3F242D, 0xA476CDA4, 0x9D55F99D, 0xEE82D8EE,
-    0x8640E586, 0xAE78C5AE, 0xCD25B9CD, 0x04964D04, 0x55774455, 0x0A0E080A,
-    0x13508613, 0x30F7E730, 0xD337A1D3, 0x40FA1D40, 0x3461AA34, 0x8C4EED8C,
-    0xB3B006B3, 0x6C54706C, 0x2A73B22A, 0x523BD252, 0x0B9F410B, 0x8B027B8B,
-    0x88D8A088, 0x4FF3114F, 0x67CB3167, 0x4627C246, 0xC06727C0, 0xB4FC90B4,
-    0x28382028, 0x7F04F67F, 0x78486078, 0x2EE5FF2E, 0x074C9607, 0x4B655C4B,
-    0xC72BB1C7, 0x6F8EAB6F, 0x0D429E0D, 0xBBF59CBB, 0xF2DB52F2, 0xF34A1BF3,
-    0xA63D5FA6, 0x59A49359, 0xBCB90ABC, 0x3AF9EF3A, 0xEF1391EF, 0xFE0885FE,
-    0x01914901, 0x6116EE61, 0x7CDE2D7C, 0xB2214FB2, 0x42B18F42, 0xDB723BDB,
-    0xB82F47B8, 0x48BF8748, 0x2CAE6D2C, 0xE3C046E3, 0x573CD657, 0x859A3E85,
-    0x29A96929, 0x7D4F647D, 0x94812A94, 0x492ECE49, 0x17C6CB17, 0xCA692FCA,
-    0xC3BDFCC3, 0x5CA3975C, 0x5EE8055E, 0xD0ED7AD0, 0x87D1AC87, 0x8E057F8E,
-    0xBA64D5BA, 0xA8A51AA8, 0xB7264BB7, 0xB9BE0EB9, 0x6087A760, 0xF8D55AF8,
-    0x22362822, 0x111B1411, 0xDE753FDE, 0x79D92979, 0xAAEE88AA, 0x332D3C33,
-    0x5F794C5F, 0xB6B702B6, 0x96CAB896, 0x5835DA58, 0x9CC4B09C, 0xFC4317FC,
-    0x1A84551A, 0xF64D1FF6, 0x1C598A1C, 0x38B27D38, 0xAC3357AC, 0x18CFC718,
-    0xF4068DF4, 0x69537469, 0x749BB774, 0xF597C4F5, 0x56AD9F56, 0xDAE372DA,
-    0xD5EA7ED5, 0x4AF4154A, 0x9E8F229E, 0xA2AB12A2, 0x4E62584E, 0xE85F07E8,
-    0xE51D99E5, 0x39233439, 0xC1F66EC1, 0x446C5044, 0x5D32DE5D, 0x72466872,
-    0x26A06526, 0x93CDBC93, 0x03DADB03, 0xC6BAF8C6, 0xFA9EC8FA, 0x82D6A882,
-    0xCF6E2BCF, 0x50704050, 0xEB85DCEB, 0x750AFE75, 0x8A93328A, 0x8DDFA48D,
-    0x4C29CA4C, 0x141C1014, 0x73D72173, 0xCCB4F0CC, 0x09D4D309, 0x108A5D10,
-    0xE2510FE2, 0x00000000, 0x9A196F9A, 0xE01A9DE0, 0x8F94368F, 0xE6C742E6,
-    0xECC94AEC, 0xFDD25EFD, 0xAB7FC1AB, 0xD8A8E0D8}
-};
-
-/* The exp_to_poly and poly_to_exp tables are used to perform efficient
- * operations in GF(2^8) represented as GF(2)[x]/w(x) where
- * w(x)=x^8+x^6+x^3+x^2+1.  We care about doing that because it's part of the
- * definition of the RS matrix in the key schedule.  Elements of that field
- * are polynomials of degree not greater than 7 and all coefficients 0 or 1,
- * which can be represented naturally by bytes (just substitute x=2).  In that
- * form, GF(2^8) addition is the same as bitwise XOR, but GF(2^8)
- * multiplication is inefficient without hardware support.  To multiply
- * faster, I make use of the fact x is a generator for the nonzero elements,
- * so that every element p of GF(2)[x]/w(x) is either 0 or equal to (x)^n for
- * some n in 0..254.  Note that that caret is exponentiation in GF(2^8),
- * *not* polynomial notation.  So if I want to compute pq where p and q are
- * in GF(2^8), I can just say:
- *    1. if p=0 or q=0 then pq=0
- *    2. otherwise, find m and n such that p=x^m and q=x^n
- *    3. pq=(x^m)(x^n)=x^(m+n), so add m and n and find pq
- * The translations in steps 2 and 3 are looked up in the tables
- * poly_to_exp (for step 2) and exp_to_poly (for step 3).  To see this
- * in action, look at the CALC_S macro.  As additional wrinkles, note that
- * one of my operands is always a constant, so the poly_to_exp lookup on it
- * is done in advance; I included the original values in the comments so
- * readers can have some chance of recognizing that this *is* the RS matrix
- * from the Twofish paper.  I've only included the table entries I actually
- * need; I never do a lookup on a variable input of zero and the biggest
- * exponents I'll ever see are 254 (variable) and 237 (constant), so they'll
- * never sum to more than 491.	I'm repeating part of the exp_to_poly table
- * so that I don't have to do mod-255 reduction in the exponent arithmetic.
- * Since I know my constant operands are never zero, I only have to worry
- * about zero values in the variable operand, and I do it with a simple
- * conditional branch.	I know conditionals are expensive, but I couldn't
- * see a non-horrible way of avoiding them, and I did manage to group the
- * statements so that each if covers four group multiplications. */
-
-static const u8 poly_to_exp[255] = {
-   0x00, 0x01, 0x17, 0x02, 0x2E, 0x18, 0x53, 0x03, 0x6A, 0x2F, 0x93, 0x19,
-   0x34, 0x54, 0x45, 0x04, 0x5C, 0x6B, 0xB6, 0x30, 0xA6, 0x94, 0x4B, 0x1A,
-   0x8C, 0x35, 0x81, 0x55, 0xAA, 0x46, 0x0D, 0x05, 0x24, 0x5D, 0x87, 0x6C,
-   0x9B, 0xB7, 0xC1, 0x31, 0x2B, 0xA7, 0xA3, 0x95, 0x98, 0x4C, 0xCA, 0x1B,
-   0xE6, 0x8D, 0x73, 0x36, 0xCD, 0x82, 0x12, 0x56, 0x62, 0xAB, 0xF0, 0x47,
-   0x4F, 0x0E, 0xBD, 0x06, 0xD4, 0x25, 0xD2, 0x5E, 0x27, 0x88, 0x66, 0x6D,
-   0xD6, 0x9C, 0x79, 0xB8, 0x08, 0xC2, 0xDF, 0x32, 0x68, 0x2C, 0xFD, 0xA8,
-   0x8A, 0xA4, 0x5A, 0x96, 0x29, 0x99, 0x22, 0x4D, 0x60, 0xCB, 0xE4, 0x1C,
-   0x7B, 0xE7, 0x3B, 0x8E, 0x9E, 0x74, 0xF4, 0x37, 0xD8, 0xCE, 0xF9, 0x83,
-   0x6F, 0x13, 0xB2, 0x57, 0xE1, 0x63, 0xDC, 0xAC, 0xC4, 0xF1, 0xAF, 0x48,
-   0x0A, 0x50, 0x42, 0x0F, 0xBA, 0xBE, 0xC7, 0x07, 0xDE, 0xD5, 0x78, 0x26,
-   0x65, 0xD3, 0xD1, 0x5F, 0xE3, 0x28, 0x21, 0x89, 0x59, 0x67, 0xFC, 0x6E,
-   0xB1, 0xD7, 0xF8, 0x9D, 0xF3, 0x7A, 0x3A, 0xB9, 0xC6, 0x09, 0x41, 0xC3,
-   0xAE, 0xE0, 0xDB, 0x33, 0x44, 0x69, 0x92, 0x2D, 0x52, 0xFE, 0x16, 0xA9,
-   0x0C, 0x8B, 0x80, 0xA5, 0x4A, 0x5B, 0xB5, 0x97, 0xC9, 0x2A, 0xA2, 0x9A,
-   0xC0, 0x23, 0x86, 0x4E, 0xBC, 0x61, 0xEF, 0xCC, 0x11, 0xE5, 0x72, 0x1D,
-   0x3D, 0x7C, 0xEB, 0xE8, 0xE9, 0x3C, 0xEA, 0x8F, 0x7D, 0x9F, 0xEC, 0x75,
-   0x1E, 0xF5, 0x3E, 0x38, 0xF6, 0xD9, 0x3F, 0xCF, 0x76, 0xFA, 0x1F, 0x84,
-   0xA0, 0x70, 0xED, 0x14, 0x90, 0xB3, 0x7E, 0x58, 0xFB, 0xE2, 0x20, 0x64,
-   0xD0, 0xDD, 0x77, 0xAD, 0xDA, 0xC5, 0x40, 0xF2, 0x39, 0xB0, 0xF7, 0x49,
-   0xB4, 0x0B, 0x7F, 0x51, 0x15, 0x43, 0x91, 0x10, 0x71, 0xBB, 0xEE, 0xBF,
-   0x85, 0xC8, 0xA1
-};
-
-static const u8 exp_to_poly[492] = {
-   0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D, 0x9A, 0x79, 0xF2,
-   0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC, 0xF5, 0xA7, 0x03,
-   0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3, 0x8B, 0x5B, 0xB6,
-   0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52, 0xA4, 0x05, 0x0A,
-   0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0, 0xED, 0x97, 0x63,
-   0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1, 0x0F, 0x1E, 0x3C,
-   0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A, 0xF4, 0xA5, 0x07,
-   0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11, 0x22, 0x44, 0x88,
-   0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51, 0xA2, 0x09, 0x12,
-   0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66, 0xCC, 0xD5, 0xE7,
-   0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB, 0x1B, 0x36, 0x6C,
-   0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19, 0x32, 0x64, 0xC8,
-   0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D, 0x5A, 0xB4, 0x25,
-   0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56, 0xAC, 0x15, 0x2A,
-   0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE, 0x91, 0x6F, 0xDE,
-   0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9, 0x3F, 0x7E, 0xFC,
-   0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE, 0xB1, 0x2F, 0x5E,
-   0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41, 0x82, 0x49, 0x92,
-   0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E, 0x71, 0xE2, 0x89,
-   0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB, 0xDB, 0xFB, 0xBB,
-   0x3B, 0x76, 0xEC, 0x95, 0x67, 0xCE, 0xD1, 0xEF, 0x93, 0x6B, 0xD6, 0xE1,
-   0x8F, 0x53, 0xA6, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D,
-   0x9A, 0x79, 0xF2, 0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC,
-   0xF5, 0xA7, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3,
-   0x8B, 0x5B, 0xB6, 0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52,
-   0xA4, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0,
-   0xED, 0x97, 0x63, 0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1,
-   0x0F, 0x1E, 0x3C, 0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A,
-   0xF4, 0xA5, 0x07, 0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11,
-   0x22, 0x44, 0x88, 0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51,
-   0xA2, 0x09, 0x12, 0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66,
-   0xCC, 0xD5, 0xE7, 0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB,
-   0x1B, 0x36, 0x6C, 0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19,
-   0x32, 0x64, 0xC8, 0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D,
-   0x5A, 0xB4, 0x25, 0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56,
-   0xAC, 0x15, 0x2A, 0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE,
-   0x91, 0x6F, 0xDE, 0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9,
-   0x3F, 0x7E, 0xFC, 0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE,
-   0xB1, 0x2F, 0x5E, 0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41,
-   0x82, 0x49, 0x92, 0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E,
-   0x71, 0xE2, 0x89, 0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB
-};
-
-
-/* The table constants are indices of
- * S-box entries, preprocessed through q0 and q1. */
-static const u8 calc_sb_tbl[512] = {
-    0xA9, 0x75, 0x67, 0xF3, 0xB3, 0xC6, 0xE8, 0xF4,
-    0x04, 0xDB, 0xFD, 0x7B, 0xA3, 0xFB, 0x76, 0xC8,
-    0x9A, 0x4A, 0x92, 0xD3, 0x80, 0xE6, 0x78, 0x6B,
-    0xE4, 0x45, 0xDD, 0x7D, 0xD1, 0xE8, 0x38, 0x4B,
-    0x0D, 0xD6, 0xC6, 0x32, 0x35, 0xD8, 0x98, 0xFD,
-    0x18, 0x37, 0xF7, 0x71, 0xEC, 0xF1, 0x6C, 0xE1,
-    0x43, 0x30, 0x75, 0x0F, 0x37, 0xF8, 0x26, 0x1B,
-    0xFA, 0x87, 0x13, 0xFA, 0x94, 0x06, 0x48, 0x3F,
-    0xF2, 0x5E, 0xD0, 0xBA, 0x8B, 0xAE, 0x30, 0x5B,
-    0x84, 0x8A, 0x54, 0x00, 0xDF, 0xBC, 0x23, 0x9D,
-    0x19, 0x6D, 0x5B, 0xC1, 0x3D, 0xB1, 0x59, 0x0E,
-    0xF3, 0x80, 0xAE, 0x5D, 0xA2, 0xD2, 0x82, 0xD5,
-    0x63, 0xA0, 0x01, 0x84, 0x83, 0x07, 0x2E, 0x14,
-    0xD9, 0xB5, 0x51, 0x90, 0x9B, 0x2C, 0x7C, 0xA3,
-    0xA6, 0xB2, 0xEB, 0x73, 0xA5, 0x4C, 0xBE, 0x54,
-    0x16, 0x92, 0x0C, 0x74, 0xE3, 0x36, 0x61, 0x51,
-    0xC0, 0x38, 0x8C, 0xB0, 0x3A, 0xBD, 0xF5, 0x5A,
-    0x73, 0xFC, 0x2C, 0x60, 0x25, 0x62, 0x0B, 0x96,
-    0xBB, 0x6C, 0x4E, 0x42, 0x89, 0xF7, 0x6B, 0x10,
-    0x53, 0x7C, 0x6A, 0x28, 0xB4, 0x27, 0xF1, 0x8C,
-    0xE1, 0x13, 0xE6, 0x95, 0xBD, 0x9C, 0x45, 0xC7,
-    0xE2, 0x24, 0xF4, 0x46, 0xB6, 0x3B, 0x66, 0x70,
-    0xCC, 0xCA, 0x95, 0xE3, 0x03, 0x85, 0x56, 0xCB,
-    0xD4, 0x11, 0x1C, 0xD0, 0x1E, 0x93, 0xD7, 0xB8,
-    0xFB, 0xA6, 0xC3, 0x83, 0x8E, 0x20, 0xB5, 0xFF,
-    0xE9, 0x9F, 0xCF, 0x77, 0xBF, 0xC3, 0xBA, 0xCC,
-    0xEA, 0x03, 0x77, 0x6F, 0x39, 0x08, 0xAF, 0xBF,
-    0x33, 0x40, 0xC9, 0xE7, 0x62, 0x2B, 0x71, 0xE2,
-    0x81, 0x79, 0x79, 0x0C, 0x09, 0xAA, 0xAD, 0x82,
-    0x24, 0x41, 0xCD, 0x3A, 0xF9, 0xEA, 0xD8, 0xB9,
-    0xE5, 0xE4, 0xC5, 0x9A, 0xB9, 0xA4, 0x4D, 0x97,
-    0x44, 0x7E, 0x08, 0xDA, 0x86, 0x7A, 0xE7, 0x17,
-    0xA1, 0x66, 0x1D, 0x94, 0xAA, 0xA1, 0xED, 0x1D,
-    0x06, 0x3D, 0x70, 0xF0, 0xB2, 0xDE, 0xD2, 0xB3,
-    0x41, 0x0B, 0x7B, 0x72, 0xA0, 0xA7, 0x11, 0x1C,
-    0x31, 0xEF, 0xC2, 0xD1, 0x27, 0x53, 0x90, 0x3E,
-    0x20, 0x8F, 0xF6, 0x33, 0x60, 0x26, 0xFF, 0x5F,
-    0x96, 0xEC, 0x5C, 0x76, 0xB1, 0x2A, 0xAB, 0x49,
-    0x9E, 0x81, 0x9C, 0x88, 0x52, 0xEE, 0x1B, 0x21,
-    0x5F, 0xC4, 0x93, 0x1A, 0x0A, 0xEB, 0xEF, 0xD9,
-    0x91, 0xC5, 0x85, 0x39, 0x49, 0x99, 0xEE, 0xCD,
-    0x2D, 0xAD, 0x4F, 0x31, 0x8F, 0x8B, 0x3B, 0x01,
-    0x47, 0x18, 0x87, 0x23, 0x6D, 0xDD, 0x46, 0x1F,
-    0xD6, 0x4E, 0x3E, 0x2D, 0x69, 0xF9, 0x64, 0x48,
-    0x2A, 0x4F, 0xCE, 0xF2, 0xCB, 0x65, 0x2F, 0x8E,
-    0xFC, 0x78, 0x97, 0x5C, 0x05, 0x58, 0x7A, 0x19,
-    0xAC, 0x8D, 0x7F, 0xE5, 0xD5, 0x98, 0x1A, 0x57,
-    0x4B, 0x67, 0x0E, 0x7F, 0xA7, 0x05, 0x5A, 0x64,
-    0x28, 0xAF, 0x14, 0x63, 0x3F, 0xB6, 0x29, 0xFE,
-    0x88, 0xF5, 0x3C, 0xB7, 0x4C, 0x3C, 0x02, 0xA5,
-    0xB8, 0xCE, 0xDA, 0xE9, 0xB0, 0x68, 0x17, 0x44,
-    0x55, 0xE0, 0x1F, 0x4D, 0x8A, 0x43, 0x7D, 0x69,
-    0x57, 0x29, 0xC7, 0x2E, 0x8D, 0xAC, 0x74, 0x15,
-    0xB7, 0x59, 0xC4, 0xA8, 0x9F, 0x0A, 0x72, 0x9E,
-    0x7E, 0x6E, 0x15, 0x47, 0x22, 0xDF, 0x12, 0x34,
-    0x58, 0x35, 0x07, 0x6A, 0x99, 0xCF, 0x34, 0xDC,
-    0x6E, 0x22, 0x50, 0xC9, 0xDE, 0xC0, 0x68, 0x9B,
-    0x65, 0x89, 0xBC, 0xD4, 0xDB, 0xED, 0xF8, 0xAB,
-    0xC8, 0x12, 0xA8, 0xA2, 0x2B, 0x0D, 0x40, 0x52,
-    0xDC, 0xBB, 0xFE, 0x02, 0x32, 0x2F, 0xA4, 0xA9,
-    0xCA, 0xD7, 0x10, 0x61, 0x21, 0x1E, 0xF0, 0xB4,
-    0xD3, 0x50, 0x5D, 0x04, 0x0F, 0xF6, 0x00, 0xC2,
-    0x6F, 0x16, 0x9D, 0x25, 0x36, 0x86, 0x42, 0x56,
-    0x4A, 0x55, 0x5E, 0x09, 0xC1, 0xBE, 0xE0, 0x91
-};
-
-/* Macro to perform one column of the RS matrix multiplication.  The
- * parameters a, b, c, and d are the four bytes of output; i is the index
- * of the key bytes, and w, x, y, and z, are the column of constants from
- * the RS matrix, preprocessed through the poly_to_exp table. */
-
-#define CALC_S(a, b, c, d, i, w, x, y, z) \
-   if (key[i]) { \
-      tmp = poly_to_exp[key[i] - 1]; \
-      (a) ^= exp_to_poly[tmp + (w)]; \
-      (b) ^= exp_to_poly[tmp + (x)]; \
-      (c) ^= exp_to_poly[tmp + (y)]; \
-      (d) ^= exp_to_poly[tmp + (z)]; \
-   }
-
-/* Macros to calculate the key-dependent S-boxes for a 128-bit key using
- * the S vector from CALC_S.  CALC_SB_2 computes a single entry in all
- * four S-boxes, where i is the index of the entry to compute, and a and b
- * are the index numbers preprocessed through the q0 and q1 tables
- * respectively. */
-
-#define CALC_SB_2(i, a, b) \
-   ctx-&gt;s[0][i] = mds[0][q0[(a) ^ sa] ^ se]; \
-   ctx-&gt;s[1][i] = mds[1][q0[(b) ^ sb] ^ sf]; \
-   ctx-&gt;s[2][i] = mds[2][q1[(a) ^ sc] ^ sg]; \
-   ctx-&gt;s[3][i] = mds[3][q1[(b) ^ sd] ^ sh]
-
-/* Macro exactly like CALC_SB_2, but for 192-bit keys. */
-
-#define CALC_SB192_2(i, a, b) \
-   ctx-&gt;s[0][i] = mds[0][q0[q0[(b) ^ sa] ^ se] ^ si]; \
-   ctx-&gt;s[1][i] = mds[1][q0[q1[(b) ^ sb] ^ sf] ^ sj]; \
-   ctx-&gt;s[2][i] = mds[2][q1[q0[(a) ^ sc] ^ sg] ^ sk]; \
-   ctx-&gt;s[3][i] = mds[3][q1[q1[(a) ^ sd] ^ sh] ^ sl];
-
-/* Macro exactly like CALC_SB_2, but for 256-bit keys. */
-
-#define CALC_SB256_2(i, a, b) \
-   ctx-&gt;s[0][i] = mds[0][q0[q0[q1[(b) ^ sa] ^ se] ^ si] ^ sm]; \
-   ctx-&gt;s[1][i] = mds[1][q0[q1[q1[(a) ^ sb] ^ sf] ^ sj] ^ sn]; \
-   ctx-&gt;s[2][i] = mds[2][q1[q0[q0[(a) ^ sc] ^ sg] ^ sk] ^ so]; \
-   ctx-&gt;s[3][i] = mds[3][q1[q1[q0[(b) ^ sd] ^ sh] ^ sl] ^ sp];
-
-/* Macros to calculate the whitening and round subkeys.  CALC_K_2 computes the
- * last two stages of the h() function for a given index (either 2i or 2i+1).
- * a, b, c, and d are the four bytes going into the last two stages.  For
- * 128-bit keys, this is the entire h() function and a and c are the index
- * preprocessed through q0 and q1 respectively; for longer keys they are the
- * output of previous stages.  j is the index of the first key byte to use.
- * CALC_K computes a pair of subkeys for 128-bit Twofish, by calling CALC_K_2
- * twice, doing the Pseudo-Hadamard Transform, and doing the necessary
- * rotations.  Its parameters are: a, the array to write the results into,
- * j, the index of the first output entry, k and l, the preprocessed indices
- * for index 2i, and m and n, the preprocessed indices for index 2i+1.
- * CALC_K192_2 expands CALC_K_2 to handle 192-bit keys, by doing an
- * additional lookup-and-XOR stage.  The parameters a, b, c and d are the
- * four bytes going into the last three stages.  For 192-bit keys, c = d
- * are the index preprocessed through q0, and a = b are the index
- * preprocessed through q1; j is the index of the first key byte to use.
- * CALC_K192 is identical to CALC_K but for using the CALC_K192_2 macro
- * instead of CALC_K_2.
- * CALC_K256_2 expands CALC_K192_2 to handle 256-bit keys, by doing an
- * additional lookup-and-XOR stage.  The parameters a and b are the index
- * preprocessed through q0 and q1 respectively; j is the index of the first
- * key byte to use.  CALC_K256 is identical to CALC_K but for using the
- * CALC_K256_2 macro instead of CALC_K_2. */
-
-#define CALC_K_2(a, b, c, d, j) \
-     mds[0][q0[a ^ key[(j) + 8]] ^ key[j]] \
-   ^ mds[1][q0[b ^ key[(j) + 9]] ^ key[(j) + 1]] \
-   ^ mds[2][q1[c ^ key[(j) + 10]] ^ key[(j) + 2]] \
-   ^ mds[3][q1[d ^ key[(j) + 11]] ^ key[(j) + 3]]
-
-#define CALC_K(a, j, k, l, m, n) \
-   x = CALC_K_2 (k, l, k, l, 0); \
-   y = CALC_K_2 (m, n, m, n, 4); \
-   y = rol32(y, 8); \
-   x += y; y += x; ctx-&gt;a[j] = x; \
-   ctx-&gt;a[(j) + 1] = rol32(y, 9)
-
-#define CALC_K192_2(a, b, c, d, j) \
-   CALC_K_2 (q0[a ^ key[(j) + 16]], \
-	     q1[b ^ key[(j) + 17]], \
-	     q0[c ^ key[(j) + 18]], \
-	     q1[d ^ key[(j) + 19]], j)
-
-#define CALC_K192(a, j, k, l, m, n) \
-   x = CALC_K192_2 (l, l, k, k, 0); \
-   y = CALC_K192_2 (n, n, m, m, 4); \
-   y = rol32(y, 8); \
-   x += y; y += x; ctx-&gt;a[j] = x; \
-   ctx-&gt;a[(j) + 1] = rol32(y, 9)
-
-#define CALC_K256_2(a, b, j) \
-   CALC_K192_2 (q1[b ^ key[(j) + 24]], \
-	        q1[a ^ key[(j) + 25]], \
-	        q0[a ^ key[(j) + 26]], \
-	        q0[b ^ key[(j) + 27]], j)
-
-#define CALC_K256(a, j, k, l, m, n) \
-   x = CALC_K256_2 (k, l, 0); \
-   y = CALC_K256_2 (m, n, 4); \
-   y = rol32(y, 8); \
-   x += y; y += x; ctx-&gt;a[j] = x; \
-   ctx-&gt;a[(j) + 1] = rol32(y, 9)
+#include &lt;crypto/twofish.h&gt;
 
 
 /* Macros to compute the g() function in the encryption and decryption
@@ -630,176 +104,6 @@ static const u8 calc_sb_tbl[512] = {
    x ^= ctx-&gt;w[m]; \
    dst[n] = cpu_to_le32(x)
 
-#define TF_MIN_KEY_SIZE 16
-#define TF_MAX_KEY_SIZE 32
-#define TF_BLOCK_SIZE 16
-
-/* Structure for an expanded Twofish key.  s contains the key-dependent
- * S-boxes composed with the MDS matrix; w contains the eight "whitening"
- * subkeys, K[0] through K[7].	k holds the remaining, "round" subkeys.  Note
- * that k[i] corresponds to what the Twofish paper calls K[i+8]. */
-struct twofish_ctx {
-   u32 s[4][256], w[8], k[32];
-};
-
-/* Perform the key setup. */
-static int twofish_setkey(void *cx, const u8 *key,
-                          unsigned int key_len, u32 *flags)
-{
-	
-	struct twofish_ctx *ctx = cx;
-
-	int i, j, k;
-
-	/* Temporaries for CALC_K. */
-	u32 x, y;
-
-	/* The S vector used to key the S-boxes, split up into individual bytes.
-	 * 128-bit keys use only sa through sh; 256-bit use all of them. */
-	u8 sa = 0, sb = 0, sc = 0, sd = 0, se = 0, sf = 0, sg = 0, sh = 0;
-	u8 si = 0, sj = 0, sk = 0, sl = 0, sm = 0, sn = 0, so = 0, sp = 0;
-
-	/* Temporary for CALC_S. */
-	u8 tmp;
-
-	/* Check key length. */
-	if (key_len != 16 &amp;&amp; key_len != 24 &amp;&amp; key_len != 32)
-	{
-		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
-		return -EINVAL; /* unsupported key length */
-	}
-
-	/* Compute the first two words of the S vector.  The magic numbers are
-	 * the entries of the RS matrix, preprocessed through poly_to_exp. The
-	 * numbers in the comments are the original (polynomial form) matrix
-	 * entries. */
-	CALC_S (sa, sb, sc, sd, 0, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-	CALC_S (sa, sb, sc, sd, 1, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-	CALC_S (sa, sb, sc, sd, 2, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-	CALC_S (sa, sb, sc, sd, 3, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-	CALC_S (sa, sb, sc, sd, 4, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-	CALC_S (sa, sb, sc, sd, 5, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-	CALC_S (sa, sb, sc, sd, 6, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-	CALC_S (sa, sb, sc, sd, 7, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-	CALC_S (se, sf, sg, sh, 8, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-	CALC_S (se, sf, sg, sh, 9, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-	CALC_S (se, sf, sg, sh, 10, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-	CALC_S (se, sf, sg, sh, 11, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-	CALC_S (se, sf, sg, sh, 12, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-	CALC_S (se, sf, sg, sh, 13, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-	CALC_S (se, sf, sg, sh, 14, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-	CALC_S (se, sf, sg, sh, 15, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-
-	if (key_len == 24 || key_len == 32) { /* 192- or 256-bit key */
-		/* Calculate the third word of the S vector */
-		CALC_S (si, sj, sk, sl, 16, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-		CALC_S (si, sj, sk, sl, 17, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-		CALC_S (si, sj, sk, sl, 18, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-		CALC_S (si, sj, sk, sl, 19, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-		CALC_S (si, sj, sk, sl, 20, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-		CALC_S (si, sj, sk, sl, 21, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-		CALC_S (si, sj, sk, sl, 22, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-		CALC_S (si, sj, sk, sl, 23, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-	}
-
-	if (key_len == 32) { /* 256-bit key */
-		/* Calculate the fourth word of the S vector */
-		CALC_S (sm, sn, so, sp, 24, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-		CALC_S (sm, sn, so, sp, 25, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-		CALC_S (sm, sn, so, sp, 26, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-		CALC_S (sm, sn, so, sp, 27, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-		CALC_S (sm, sn, so, sp, 28, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-		CALC_S (sm, sn, so, sp, 29, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-		CALC_S (sm, sn, so, sp, 30, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-		CALC_S (sm, sn, so, sp, 31, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-
-		/* Compute the S-boxes. */
-		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
-			CALC_SB256_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
-		}
-
-		/* Calculate whitening and round subkeys.  The constants are
-		 * indices of subkeys, preprocessed through q0 and q1. */
-		CALC_K256 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
-		CALC_K256 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
-		CALC_K256 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
-		CALC_K256 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
-		CALC_K256 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
-		CALC_K256 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
-		CALC_K256 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
-		CALC_K256 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
-		CALC_K256 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
-		CALC_K256 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
-		CALC_K256 (k, 12, 0x18, 0x37, 0xF7, 0x71);
-		CALC_K256 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
-		CALC_K256 (k, 16, 0x43, 0x30, 0x75, 0x0F);
-		CALC_K256 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
-		CALC_K256 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
-		CALC_K256 (k, 22, 0x94, 0x06, 0x48, 0x3F);
-		CALC_K256 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
-		CALC_K256 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
-		CALC_K256 (k, 28, 0x84, 0x8A, 0x54, 0x00);
-		CALC_K256 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
-	} else if (key_len == 24) { /* 192-bit key */
-		/* Compute the S-boxes. */
-		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
-		        CALC_SB192_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
-		}
-
-		/* Calculate whitening and round subkeys.  The constants are
-		 * indices of subkeys, preprocessed through q0 and q1. */
-		CALC_K192 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
-		CALC_K192 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
-		CALC_K192 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
-		CALC_K192 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
-		CALC_K192 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
-		CALC_K192 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
-		CALC_K192 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
-		CALC_K192 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
-		CALC_K192 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
-		CALC_K192 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
-		CALC_K192 (k, 12, 0x18, 0x37, 0xF7, 0x71);
-		CALC_K192 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
-		CALC_K192 (k, 16, 0x43, 0x30, 0x75, 0x0F);
-		CALC_K192 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
-		CALC_K192 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
-		CALC_K192 (k, 22, 0x94, 0x06, 0x48, 0x3F);
-		CALC_K192 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
-		CALC_K192 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
-		CALC_K192 (k, 28, 0x84, 0x8A, 0x54, 0x00);
-		CALC_K192 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
-	} else { /* 128-bit key */
-		/* Compute the S-boxes. */
-		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
-			CALC_SB_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
-		}
-
-		/* Calculate whitening and round subkeys.  The constants are
-		 * indices of subkeys, preprocessed through q0 and q1. */
-		CALC_K (w, 0, 0xA9, 0x75, 0x67, 0xF3);
-		CALC_K (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
-		CALC_K (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
-		CALC_K (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
-		CALC_K (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
-		CALC_K (k, 2, 0x80, 0xE6, 0x78, 0x6B);
-		CALC_K (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
-		CALC_K (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
-		CALC_K (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
-		CALC_K (k, 10, 0x35, 0xD8, 0x98, 0xFD);
-		CALC_K (k, 12, 0x18, 0x37, 0xF7, 0x71);
-		CALC_K (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
-		CALC_K (k, 16, 0x43, 0x30, 0x75, 0x0F);
-		CALC_K (k, 18, 0x37, 0xF8, 0x26, 0x1B);
-		CALC_K (k, 20, 0xFA, 0x87, 0x13, 0xFA);
-		CALC_K (k, 22, 0x94, 0x06, 0x48, 0x3F);
-		CALC_K (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
-		CALC_K (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
-		CALC_K (k, 28, 0x84, 0x8A, 0x54, 0x00);
-		CALC_K (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
-	}
-
-	return 0;
-}
 
 /* Encrypt one block.  in and out may be the same. */
 static void twofish_encrypt(void *cx, u8 *out, const u8 *in)
@@ -810,7 +114,7 @@ static void twofish_encrypt(void *cx, u8
 
 	/* The four 32-bit chunks of the text. */
 	u32 a, b, c, d;
-	
+
 	/* Temporaries used by the round function. */
 	u32 x, y;
 
@@ -819,7 +123,7 @@ static void twofish_encrypt(void *cx, u8
 	INPACK (1, b, 1);
 	INPACK (2, c, 2);
 	INPACK (3, d, 3);
-	
+
 	/* Encryption Feistel cycles. */
 	ENCCYCLE (0);
 	ENCCYCLE (1);
@@ -829,13 +133,13 @@ static void twofish_encrypt(void *cx, u8
 	ENCCYCLE (5);
 	ENCCYCLE (6);
 	ENCCYCLE (7);
-	
+
 	/* Output whitening and unpacking. */
 	OUTUNPACK (0, c, 4);
 	OUTUNPACK (1, d, 5);
 	OUTUNPACK (2, a, 6);
 	OUTUNPACK (3, b, 7);
-	
+
 }
 
 /* Decrypt one block.  in and out may be the same. */
@@ -844,19 +148,19 @@ static void twofish_decrypt(void *cx, u8
 	struct twofish_ctx *ctx = cx;
 	const __le32 *src = (const __le32 *)in;
 	__le32 *dst = (__le32 *)out;
-  
+
 	/* The four 32-bit chunks of the text. */
 	u32 a, b, c, d;
-	
+
 	/* Temporaries used by the round function. */
 	u32 x, y;
-	
+
 	/* Input whitening and packing. */
 	INPACK (0, c, 4);
 	INPACK (1, d, 5);
 	INPACK (2, a, 6);
 	INPACK (3, b, 7);
-	
+
 	/* Encryption Feistel cycles. */
 	DECCYCLE (7);
 	DECCYCLE (6);
@@ -875,6 +179,7 @@ static void twofish_decrypt(void *cx, u8
 
 }
 
+
 static struct crypto_alg alg = {
 	.cra_name           =   "twofish",
 	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
diff -uprN linux-2.6.17-rc5/crypto/twofish_common.c linux-2.6.17-rc5.twofish/crypto/twofish_common.c
--- linux-2.6.17-rc5/crypto/twofish_common.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish/crypto/twofish_common.c	2006-06-11 15:58:20.319984126 +0200
@@ -0,0 +1,740 @@
+/*
+ * Common Twofish algorithm parts shared between the c and assembler
+ * implementations
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+
+/* The large precomputed tables for the Twofish cipher (twofish.c)
+ * Taken from the same source as twofish.c
+ * Marc Mutz &lt;Marc@Mutz.com&gt;
+ */
+
+/* These two tables are the q0 and q1 permutations, exactly as described in
+ * the Twofish paper. */
+
+static const u8 q0[256] = {
+   0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78,
+   0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C,
+   0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30,
+   0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82,
+   0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE,
+   0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B,
+   0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45,
+   0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7,
+   0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF,
+   0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8,
+   0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED,
+   0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90,
+   0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B,
+   0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B,
+   0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F,
+   0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A,
+   0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17,
+   0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72,
+   0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68,
+   0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4,
+   0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42,
+   0x4A, 0x5E, 0xC1, 0xE0
+};
+
+static const u8 q1[256] = {
+   0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B,
+   0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1,
+   0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B,
+   0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5,
+   0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54,
+   0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96,
+   0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7,
+   0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8,
+   0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF,
+   0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9,
+   0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D,
+   0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E,
+   0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21,
+   0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01,
+   0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E,
+   0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64,
+   0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44,
+   0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E,
+   0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B,
+   0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9,
+   0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56,
+   0x55, 0x09, 0xBE, 0x91
+};
+
+/* These MDS tables are actually tables of MDS composed with q0 and q1,
+ * because it is only ever used that way and we can save some time by
+ * precomputing.  Of course the main saving comes from precomputing the
+ * GF(2^8) multiplication involved in the MDS matrix multiply; by looking
+ * things up in these tables we reduce the matrix multiply to four lookups
+ * and three XORs.  Semi-formally, the definition of these tables is:
+ * mds[0][i] = MDS (q1[i] 0 0 0)^T  mds[1][i] = MDS (0 q0[i] 0 0)^T
+ * mds[2][i] = MDS (0 0 q1[i] 0)^T  mds[3][i] = MDS (0 0 0 q0[i])^T
+ * where ^T means "transpose", the matrix multiply is performed in GF(2^8)
+ * represented as GF(2)[x]/v(x) where v(x)=x^8+x^6+x^5+x^3+1 as described
+ * by Schneier et al, and I'm casually glossing over the byte/word
+ * conversion issues. */
+
+static const u32 mds[4][256] = {
+   {0xBCBC3275, 0xECEC21F3, 0x202043C6, 0xB3B3C9F4, 0xDADA03DB, 0x02028B7B,
+    0xE2E22BFB, 0x9E9EFAC8, 0xC9C9EC4A, 0xD4D409D3, 0x18186BE6, 0x1E1E9F6B,
+    0x98980E45, 0xB2B2387D, 0xA6A6D2E8, 0x2626B74B, 0x3C3C57D6, 0x93938A32,
+    0x8282EED8, 0x525298FD, 0x7B7BD437, 0xBBBB3771, 0x5B5B97F1, 0x474783E1,
+    0x24243C30, 0x5151E20F, 0xBABAC6F8, 0x4A4AF31B, 0xBFBF4887, 0x0D0D70FA,
+    0xB0B0B306, 0x7575DE3F, 0xD2D2FD5E, 0x7D7D20BA, 0x666631AE, 0x3A3AA35B,
+    0x59591C8A, 0x00000000, 0xCDCD93BC, 0x1A1AE09D, 0xAEAE2C6D, 0x7F7FABC1,
+    0x2B2BC7B1, 0xBEBEB90E, 0xE0E0A080, 0x8A8A105D, 0x3B3B52D2, 0x6464BAD5,
+    0xD8D888A0, 0xE7E7A584, 0x5F5FE807, 0x1B1B1114, 0x2C2CC2B5, 0xFCFCB490,
+    0x3131272C, 0x808065A3, 0x73732AB2, 0x0C0C8173, 0x79795F4C, 0x6B6B4154,
+    0x4B4B0292, 0x53536974, 0x94948F36, 0x83831F51, 0x2A2A3638, 0xC4C49CB0,
+    0x2222C8BD, 0xD5D5F85A, 0xBDBDC3FC, 0x48487860, 0xFFFFCE62, 0x4C4C0796,
+    0x4141776C, 0xC7C7E642, 0xEBEB24F7, 0x1C1C1410, 0x5D5D637C, 0x36362228,
+    0x6767C027, 0xE9E9AF8C, 0x4444F913, 0x1414EA95, 0xF5F5BB9C, 0xCFCF18C7,
+    0x3F3F2D24, 0xC0C0E346, 0x7272DB3B, 0x54546C70, 0x29294CCA, 0xF0F035E3,
+    0x0808FE85, 0xC6C617CB, 0xF3F34F11, 0x8C8CE4D0, 0xA4A45993, 0xCACA96B8,
+    0x68683BA6, 0xB8B84D83, 0x38382820, 0xE5E52EFF, 0xADAD569F, 0x0B0B8477,
+    0xC8C81DC3, 0x9999FFCC, 0x5858ED03, 0x19199A6F, 0x0E0E0A08, 0x95957EBF,
+    0x70705040, 0xF7F730E7, 0x6E6ECF2B, 0x1F1F6EE2, 0xB5B53D79, 0x09090F0C,
+    0x616134AA, 0x57571682, 0x9F9F0B41, 0x9D9D803A, 0x111164EA, 0x2525CDB9,
+    0xAFAFDDE4, 0x4545089A, 0xDFDF8DA4, 0xA3A35C97, 0xEAEAD57E, 0x353558DA,
+    0xEDEDD07A, 0x4343FC17, 0xF8F8CB66, 0xFBFBB194, 0x3737D3A1, 0xFAFA401D,
+    0xC2C2683D, 0xB4B4CCF0, 0x32325DDE, 0x9C9C71B3, 0x5656E70B, 0xE3E3DA72,
+    0x878760A7, 0x15151B1C, 0xF9F93AEF, 0x6363BFD1, 0x3434A953, 0x9A9A853E,
+    0xB1B1428F, 0x7C7CD133, 0x88889B26, 0x3D3DA65F, 0xA1A1D7EC, 0xE4E4DF76,
+    0x8181942A, 0x91910149, 0x0F0FFB81, 0xEEEEAA88, 0x161661EE, 0xD7D77321,
+    0x9797F5C4, 0xA5A5A81A, 0xFEFE3FEB, 0x6D6DB5D9, 0x7878AEC5, 0xC5C56D39,
+    0x1D1DE599, 0x7676A4CD, 0x3E3EDCAD, 0xCBCB6731, 0xB6B6478B, 0xEFEF5B01,
+    0x12121E18, 0x6060C523, 0x6A6AB0DD, 0x4D4DF61F, 0xCECEE94E, 0xDEDE7C2D,
+    0x55559DF9, 0x7E7E5A48, 0x2121B24F, 0x03037AF2, 0xA0A02665, 0x5E5E198E,
+    0x5A5A6678, 0x65654B5C, 0x62624E58, 0xFDFD4519, 0x0606F48D, 0x404086E5,
+    0xF2F2BE98, 0x3333AC57, 0x17179067, 0x05058E7F, 0xE8E85E05, 0x4F4F7D64,
+    0x89896AAF, 0x10109563, 0x74742FB6, 0x0A0A75FE, 0x5C5C92F5, 0x9B9B74B7,
+    0x2D2D333C, 0x3030D6A5, 0x2E2E49CE, 0x494989E9, 0x46467268, 0x77775544,
+    0xA8A8D8E0, 0x9696044D, 0x2828BD43, 0xA9A92969, 0xD9D97929, 0x8686912E,
+    0xD1D187AC, 0xF4F44A15, 0x8D8D1559, 0xD6D682A8, 0xB9B9BC0A, 0x42420D9E,
+    0xF6F6C16E, 0x2F2FB847, 0xDDDD06DF, 0x23233934, 0xCCCC6235, 0xF1F1C46A,
+    0xC1C112CF, 0x8585EBDC, 0x8F8F9E22, 0x7171A1C9, 0x9090F0C0, 0xAAAA539B,
+    0x0101F189, 0x8B8BE1D4, 0x4E4E8CED, 0x8E8E6FAB, 0xABABA212, 0x6F6F3EA2,
+    0xE6E6540D, 0xDBDBF252, 0x92927BBB, 0xB7B7B602, 0x6969CA2F, 0x3939D9A9,
+    0xD3D30CD7, 0xA7A72361, 0xA2A2AD1E, 0xC3C399B4, 0x6C6C4450, 0x07070504,
+    0x04047FF6, 0x272746C2, 0xACACA716, 0xD0D07625, 0x50501386, 0xDCDCF756,
+    0x84841A55, 0xE1E15109, 0x7A7A25BE, 0x1313EF91},
+
+   {0xA9D93939, 0x67901717, 0xB3719C9C, 0xE8D2A6A6, 0x04050707, 0xFD985252,
+    0xA3658080, 0x76DFE4E4, 0x9A084545, 0x92024B4B, 0x80A0E0E0, 0x78665A5A,
+    0xE4DDAFAF, 0xDDB06A6A, 0xD1BF6363, 0x38362A2A, 0x0D54E6E6, 0xC6432020,
+    0x3562CCCC, 0x98BEF2F2, 0x181E1212, 0xF724EBEB, 0xECD7A1A1, 0x6C774141,
+    0x43BD2828, 0x7532BCBC, 0x37D47B7B, 0x269B8888, 0xFA700D0D, 0x13F94444,
+    0x94B1FBFB, 0x485A7E7E, 0xF27A0303, 0xD0E48C8C, 0x8B47B6B6, 0x303C2424,
+    0x84A5E7E7, 0x54416B6B, 0xDF06DDDD, 0x23C56060, 0x1945FDFD, 0x5BA33A3A,
+    0x3D68C2C2, 0x59158D8D, 0xF321ECEC, 0xAE316666, 0xA23E6F6F, 0x82165757,
+    0x63951010, 0x015BEFEF, 0x834DB8B8, 0x2E918686, 0xD9B56D6D, 0x511F8383,
+    0x9B53AAAA, 0x7C635D5D, 0xA63B6868, 0xEB3FFEFE, 0xA5D63030, 0xBE257A7A,
+    0x16A7ACAC, 0x0C0F0909, 0xE335F0F0, 0x6123A7A7, 0xC0F09090, 0x8CAFE9E9,
+    0x3A809D9D, 0xF5925C5C, 0x73810C0C, 0x2C273131, 0x2576D0D0, 0x0BE75656,
+    0xBB7B9292, 0x4EE9CECE, 0x89F10101, 0x6B9F1E1E, 0x53A93434, 0x6AC4F1F1,
+    0xB499C3C3, 0xF1975B5B, 0xE1834747, 0xE66B1818, 0xBDC82222, 0x450E9898,
+    0xE26E1F1F, 0xF4C9B3B3, 0xB62F7474, 0x66CBF8F8, 0xCCFF9999, 0x95EA1414,
+    0x03ED5858, 0x56F7DCDC, 0xD4E18B8B, 0x1C1B1515, 0x1EADA2A2, 0xD70CD3D3,
+    0xFB2BE2E2, 0xC31DC8C8, 0x8E195E5E, 0xB5C22C2C, 0xE9894949, 0xCF12C1C1,
+    0xBF7E9595, 0xBA207D7D, 0xEA641111, 0x77840B0B, 0x396DC5C5, 0xAF6A8989,
+    0x33D17C7C, 0xC9A17171, 0x62CEFFFF, 0x7137BBBB, 0x81FB0F0F, 0x793DB5B5,
+    0x0951E1E1, 0xADDC3E3E, 0x242D3F3F, 0xCDA47676, 0xF99D5555, 0xD8EE8282,
+    0xE5864040, 0xC5AE7878, 0xB9CD2525, 0x4D049696, 0x44557777, 0x080A0E0E,
+    0x86135050, 0xE730F7F7, 0xA1D33737, 0x1D40FAFA, 0xAA346161, 0xED8C4E4E,
+    0x06B3B0B0, 0x706C5454, 0xB22A7373, 0xD2523B3B, 0x410B9F9F, 0x7B8B0202,
+    0xA088D8D8, 0x114FF3F3, 0x3167CBCB, 0xC2462727, 0x27C06767, 0x90B4FCFC,
+    0x20283838, 0xF67F0404, 0x60784848, 0xFF2EE5E5, 0x96074C4C, 0x5C4B6565,
+    0xB1C72B2B, 0xAB6F8E8E, 0x9E0D4242, 0x9CBBF5F5, 0x52F2DBDB, 0x1BF34A4A,
+    0x5FA63D3D, 0x9359A4A4, 0x0ABCB9B9, 0xEF3AF9F9, 0x91EF1313, 0x85FE0808,
+    0x49019191, 0xEE611616, 0x2D7CDEDE, 0x4FB22121, 0x8F42B1B1, 0x3BDB7272,
+    0x47B82F2F, 0x8748BFBF, 0x6D2CAEAE, 0x46E3C0C0, 0xD6573C3C, 0x3E859A9A,
+    0x6929A9A9, 0x647D4F4F, 0x2A948181, 0xCE492E2E, 0xCB17C6C6, 0x2FCA6969,
+    0xFCC3BDBD, 0x975CA3A3, 0x055EE8E8, 0x7AD0EDED, 0xAC87D1D1, 0x7F8E0505,
+    0xD5BA6464, 0x1AA8A5A5, 0x4BB72626, 0x0EB9BEBE, 0xA7608787, 0x5AF8D5D5,
+    0x28223636, 0x14111B1B, 0x3FDE7575, 0x2979D9D9, 0x88AAEEEE, 0x3C332D2D,
+    0x4C5F7979, 0x02B6B7B7, 0xB896CACA, 0xDA583535, 0xB09CC4C4, 0x17FC4343,
+    0x551A8484, 0x1FF64D4D, 0x8A1C5959, 0x7D38B2B2, 0x57AC3333, 0xC718CFCF,
+    0x8DF40606, 0x74695353, 0xB7749B9B, 0xC4F59797, 0x9F56ADAD, 0x72DAE3E3,
+    0x7ED5EAEA, 0x154AF4F4, 0x229E8F8F, 0x12A2ABAB, 0x584E6262, 0x07E85F5F,
+    0x99E51D1D, 0x34392323, 0x6EC1F6F6, 0x50446C6C, 0xDE5D3232, 0x68724646,
+    0x6526A0A0, 0xBC93CDCD, 0xDB03DADA, 0xF8C6BABA, 0xC8FA9E9E, 0xA882D6D6,
+    0x2BCF6E6E, 0x40507070, 0xDCEB8585, 0xFE750A0A, 0x328A9393, 0xA48DDFDF,
+    0xCA4C2929, 0x10141C1C, 0x2173D7D7, 0xF0CCB4B4, 0xD309D4D4, 0x5D108A8A,
+    0x0FE25151, 0x00000000, 0x6F9A1919, 0x9DE01A1A, 0x368F9494, 0x42E6C7C7,
+    0x4AECC9C9, 0x5EFDD2D2, 0xC1AB7F7F, 0xE0D8A8A8},
+
+   {0xBC75BC32, 0xECF3EC21, 0x20C62043, 0xB3F4B3C9, 0xDADBDA03, 0x027B028B,
+    0xE2FBE22B, 0x9EC89EFA, 0xC94AC9EC, 0xD4D3D409, 0x18E6186B, 0x1E6B1E9F,
+    0x9845980E, 0xB27DB238, 0xA6E8A6D2, 0x264B26B7, 0x3CD63C57, 0x9332938A,
+    0x82D882EE, 0x52FD5298, 0x7B377BD4, 0xBB71BB37, 0x5BF15B97, 0x47E14783,
+    0x2430243C, 0x510F51E2, 0xBAF8BAC6, 0x4A1B4AF3, 0xBF87BF48, 0x0DFA0D70,
+    0xB006B0B3, 0x753F75DE, 0xD25ED2FD, 0x7DBA7D20, 0x66AE6631, 0x3A5B3AA3,
+    0x598A591C, 0x00000000, 0xCDBCCD93, 0x1A9D1AE0, 0xAE6DAE2C, 0x7FC17FAB,
+    0x2BB12BC7, 0xBE0EBEB9, 0xE080E0A0, 0x8A5D8A10, 0x3BD23B52, 0x64D564BA,
+    0xD8A0D888, 0xE784E7A5, 0x5F075FE8, 0x1B141B11, 0x2CB52CC2, 0xFC90FCB4,
+    0x312C3127, 0x80A38065, 0x73B2732A, 0x0C730C81, 0x794C795F, 0x6B546B41,
+    0x4B924B02, 0x53745369, 0x9436948F, 0x8351831F, 0x2A382A36, 0xC4B0C49C,
+    0x22BD22C8, 0xD55AD5F8, 0xBDFCBDC3, 0x48604878, 0xFF62FFCE, 0x4C964C07,
+    0x416C4177, 0xC742C7E6, 0xEBF7EB24, 0x1C101C14, 0x5D7C5D63, 0x36283622,
+    0x672767C0, 0xE98CE9AF, 0x441344F9, 0x149514EA, 0xF59CF5BB, 0xCFC7CF18,
+    0x3F243F2D, 0xC046C0E3, 0x723B72DB, 0x5470546C, 0x29CA294C, 0xF0E3F035,
+    0x088508FE, 0xC6CBC617, 0xF311F34F, 0x8CD08CE4, 0xA493A459, 0xCAB8CA96,
+    0x68A6683B, 0xB883B84D, 0x38203828, 0xE5FFE52E, 0xAD9FAD56, 0x0B770B84,
+    0xC8C3C81D, 0x99CC99FF, 0x580358ED, 0x196F199A, 0x0E080E0A, 0x95BF957E,
+    0x70407050, 0xF7E7F730, 0x6E2B6ECF, 0x1FE21F6E, 0xB579B53D, 0x090C090F,
+    0x61AA6134, 0x57825716, 0x9F419F0B, 0x9D3A9D80, 0x11EA1164, 0x25B925CD,
+    0xAFE4AFDD, 0x459A4508, 0xDFA4DF8D, 0xA397A35C, 0xEA7EEAD5, 0x35DA3558,
+    0xED7AEDD0, 0x431743FC, 0xF866F8CB, 0xFB94FBB1, 0x37A137D3, 0xFA1DFA40,
+    0xC23DC268, 0xB4F0B4CC, 0x32DE325D, 0x9CB39C71, 0x560B56E7, 0xE372E3DA,
+    0x87A78760, 0x151C151B, 0xF9EFF93A, 0x63D163BF, 0x345334A9, 0x9A3E9A85,
+    0xB18FB142, 0x7C337CD1, 0x8826889B, 0x3D5F3DA6, 0xA1ECA1D7, 0xE476E4DF,
+    0x812A8194, 0x91499101, 0x0F810FFB, 0xEE88EEAA, 0x16EE1661, 0xD721D773,
+    0x97C497F5, 0xA51AA5A8, 0xFEEBFE3F, 0x6DD96DB5, 0x78C578AE, 0xC539C56D,
+    0x1D991DE5, 0x76CD76A4, 0x3EAD3EDC, 0xCB31CB67, 0xB68BB647, 0xEF01EF5B,
+    0x1218121E, 0x602360C5, 0x6ADD6AB0, 0x4D1F4DF6, 0xCE4ECEE9, 0xDE2DDE7C,
+    0x55F9559D, 0x7E487E5A, 0x214F21B2, 0x03F2037A, 0xA065A026, 0x5E8E5E19,
+    0x5A785A66, 0x655C654B, 0x6258624E, 0xFD19FD45, 0x068D06F4, 0x40E54086,
+    0xF298F2BE, 0x335733AC, 0x17671790, 0x057F058E, 0xE805E85E, 0x4F644F7D,
+    0x89AF896A, 0x10631095, 0x74B6742F, 0x0AFE0A75, 0x5CF55C92, 0x9BB79B74,
+    0x2D3C2D33, 0x30A530D6, 0x2ECE2E49, 0x49E94989, 0x46684672, 0x77447755,
+    0xA8E0A8D8, 0x964D9604, 0x284328BD, 0xA969A929, 0xD929D979, 0x862E8691,
+    0xD1ACD187, 0xF415F44A, 0x8D598D15, 0xD6A8D682, 0xB90AB9BC, 0x429E420D,
+    0xF66EF6C1, 0x2F472FB8, 0xDDDFDD06, 0x23342339, 0xCC35CC62, 0xF16AF1C4,
+    0xC1CFC112, 0x85DC85EB, 0x8F228F9E, 0x71C971A1, 0x90C090F0, 0xAA9BAA53,
+    0x018901F1, 0x8BD48BE1, 0x4EED4E8C, 0x8EAB8E6F, 0xAB12ABA2, 0x6FA26F3E,
+    0xE60DE654, 0xDB52DBF2, 0x92BB927B, 0xB702B7B6, 0x692F69CA, 0x39A939D9,
+    0xD3D7D30C, 0xA761A723, 0xA21EA2AD, 0xC3B4C399, 0x6C506C44, 0x07040705,
+    0x04F6047F, 0x27C22746, 0xAC16ACA7, 0xD025D076, 0x50865013, 0xDC56DCF7,
+    0x8455841A, 0xE109E151, 0x7ABE7A25, 0x139113EF},
+
+   {0xD939A9D9, 0x90176790, 0x719CB371, 0xD2A6E8D2, 0x05070405, 0x9852FD98,
+    0x6580A365, 0xDFE476DF, 0x08459A08, 0x024B9202, 0xA0E080A0, 0x665A7866,
+    0xDDAFE4DD, 0xB06ADDB0, 0xBF63D1BF, 0x362A3836, 0x54E60D54, 0x4320C643,
+    0x62CC3562, 0xBEF298BE, 0x1E12181E, 0x24EBF724, 0xD7A1ECD7, 0x77416C77,
+    0xBD2843BD, 0x32BC7532, 0xD47B37D4, 0x9B88269B, 0x700DFA70, 0xF94413F9,
+    0xB1FB94B1, 0x5A7E485A, 0x7A03F27A, 0xE48CD0E4, 0x47B68B47, 0x3C24303C,
+    0xA5E784A5, 0x416B5441, 0x06DDDF06, 0xC56023C5, 0x45FD1945, 0xA33A5BA3,
+    0x68C23D68, 0x158D5915, 0x21ECF321, 0x3166AE31, 0x3E6FA23E, 0x16578216,
+    0x95106395, 0x5BEF015B, 0x4DB8834D, 0x91862E91, 0xB56DD9B5, 0x1F83511F,
+    0x53AA9B53, 0x635D7C63, 0x3B68A63B, 0x3FFEEB3F, 0xD630A5D6, 0x257ABE25,
+    0xA7AC16A7, 0x0F090C0F, 0x35F0E335, 0x23A76123, 0xF090C0F0, 0xAFE98CAF,
+    0x809D3A80, 0x925CF592, 0x810C7381, 0x27312C27, 0x76D02576, 0xE7560BE7,
+    0x7B92BB7B, 0xE9CE4EE9, 0xF10189F1, 0x9F1E6B9F, 0xA93453A9, 0xC4F16AC4,
+    0x99C3B499, 0x975BF197, 0x8347E183, 0x6B18E66B, 0xC822BDC8, 0x0E98450E,
+    0x6E1FE26E, 0xC9B3F4C9, 0x2F74B62F, 0xCBF866CB, 0xFF99CCFF, 0xEA1495EA,
+    0xED5803ED, 0xF7DC56F7, 0xE18BD4E1, 0x1B151C1B, 0xADA21EAD, 0x0CD3D70C,
+    0x2BE2FB2B, 0x1DC8C31D, 0x195E8E19, 0xC22CB5C2, 0x8949E989, 0x12C1CF12,
+    0x7E95BF7E, 0x207DBA20, 0x6411EA64, 0x840B7784, 0x6DC5396D, 0x6A89AF6A,
+    0xD17C33D1, 0xA171C9A1, 0xCEFF62CE, 0x37BB7137, 0xFB0F81FB, 0x3DB5793D,
+    0x51E10951, 0xDC3EADDC, 0x2D3F242D, 0xA476CDA4, 0x9D55F99D, 0xEE82D8EE,
+    0x8640E586, 0xAE78C5AE, 0xCD25B9CD, 0x04964D04, 0x55774455, 0x0A0E080A,
+    0x13508613, 0x30F7E730, 0xD337A1D3, 0x40FA1D40, 0x3461AA34, 0x8C4EED8C,
+    0xB3B006B3, 0x6C54706C, 0x2A73B22A, 0x523BD252, 0x0B9F410B, 0x8B027B8B,
+    0x88D8A088, 0x4FF3114F, 0x67CB3167, 0x4627C246, 0xC06727C0, 0xB4FC90B4,
+    0x28382028, 0x7F04F67F, 0x78486078, 0x2EE5FF2E, 0x074C9607, 0x4B655C4B,
+    0xC72BB1C7, 0x6F8EAB6F, 0x0D429E0D, 0xBBF59CBB, 0xF2DB52F2, 0xF34A1BF3,
+    0xA63D5FA6, 0x59A49359, 0xBCB90ABC, 0x3AF9EF3A, 0xEF1391EF, 0xFE0885FE,
+    0x01914901, 0x6116EE61, 0x7CDE2D7C, 0xB2214FB2, 0x42B18F42, 0xDB723BDB,
+    0xB82F47B8, 0x48BF8748, 0x2CAE6D2C, 0xE3C046E3, 0x573CD657, 0x859A3E85,
+    0x29A96929, 0x7D4F647D, 0x94812A94, 0x492ECE49, 0x17C6CB17, 0xCA692FCA,
+    0xC3BDFCC3, 0x5CA3975C, 0x5EE8055E, 0xD0ED7AD0, 0x87D1AC87, 0x8E057F8E,
+    0xBA64D5BA, 0xA8A51AA8, 0xB7264BB7, 0xB9BE0EB9, 0x6087A760, 0xF8D55AF8,
+    0x22362822, 0x111B1411, 0xDE753FDE, 0x79D92979, 0xAAEE88AA, 0x332D3C33,
+    0x5F794C5F, 0xB6B702B6, 0x96CAB896, 0x5835DA58, 0x9CC4B09C, 0xFC4317FC,
+    0x1A84551A, 0xF64D1FF6, 0x1C598A1C, 0x38B27D38, 0xAC3357AC, 0x18CFC718,
+    0xF4068DF4, 0x69537469, 0x749BB774, 0xF597C4F5, 0x56AD9F56, 0xDAE372DA,
+    0xD5EA7ED5, 0x4AF4154A, 0x9E8F229E, 0xA2AB12A2, 0x4E62584E, 0xE85F07E8,
+    0xE51D99E5, 0x39233439, 0xC1F66EC1, 0x446C5044, 0x5D32DE5D, 0x72466872,
+    0x26A06526, 0x93CDBC93, 0x03DADB03, 0xC6BAF8C6, 0xFA9EC8FA, 0x82D6A882,
+    0xCF6E2BCF, 0x50704050, 0xEB85DCEB, 0x750AFE75, 0x8A93328A, 0x8DDFA48D,
+    0x4C29CA4C, 0x141C1014, 0x73D72173, 0xCCB4F0CC, 0x09D4D309, 0x108A5D10,
+    0xE2510FE2, 0x00000000, 0x9A196F9A, 0xE01A9DE0, 0x8F94368F, 0xE6C742E6,
+    0xECC94AEC, 0xFDD25EFD, 0xAB7FC1AB, 0xD8A8E0D8}
+};
+
+/* The exp_to_poly and poly_to_exp tables are used to perform efficient
+ * operations in GF(2^8) represented as GF(2)[x]/w(x) where
+ * w(x)=x^8+x^6+x^3+x^2+1.  We care about doing that because it's part of the
+ * definition of the RS matrix in the key schedule.  Elements of that field
+ * are polynomials of degree not greater than 7 and all coefficients 0 or 1,
+ * which can be represented naturally by bytes (just substitute x=2).  In that
+ * form, GF(2^8) addition is the same as bitwise XOR, but GF(2^8)
+ * multiplication is inefficient without hardware support.  To multiply
+ * faster, I make use of the fact x is a generator for the nonzero elements,
+ * so that every element p of GF(2)[x]/w(x) is either 0 or equal to (x)^n for
+ * some n in 0..254.  Note that that caret is exponentiation in GF(2^8),
+ * *not* polynomial notation.  So if I want to compute pq where p and q are
+ * in GF(2^8), I can just say:
+ *    1. if p=0 or q=0 then pq=0
+ *    2. otherwise, find m and n such that p=x^m and q=x^n
+ *    3. pq=(x^m)(x^n)=x^(m+n), so add m and n and find pq
+ * The translations in steps 2 and 3 are looked up in the tables
+ * poly_to_exp (for step 2) and exp_to_poly (for step 3).  To see this
+ * in action, look at the CALC_S macro.  As additional wrinkles, note that
+ * one of my operands is always a constant, so the poly_to_exp lookup on it
+ * is done in advance; I included the original values in the comments so
+ * readers can have some chance of recognizing that this *is* the RS matrix
+ * from the Twofish paper.  I've only included the table entries I actually
+ * need; I never do a lookup on a variable input of zero and the biggest
+ * exponents I'll ever see are 254 (variable) and 237 (constant), so they'll
+ * never sum to more than 491.	I'm repeating part of the exp_to_poly table
+ * so that I don't have to do mod-255 reduction in the exponent arithmetic.
+ * Since I know my constant operands are never zero, I only have to worry
+ * about zero values in the variable operand, and I do it with a simple
+ * conditional branch.	I know conditionals are expensive, but I couldn't
+ * see a non-horrible way of avoiding them, and I did manage to group the
+ * statements so that each if covers four group multiplications. */
+
+static const u8 poly_to_exp[255] = {
+   0x00, 0x01, 0x17, 0x02, 0x2E, 0x18, 0x53, 0x03, 0x6A, 0x2F, 0x93, 0x19,
+   0x34, 0x54, 0x45, 0x04, 0x5C, 0x6B, 0xB6, 0x30, 0xA6, 0x94, 0x4B, 0x1A,
+   0x8C, 0x35, 0x81, 0x55, 0xAA, 0x46, 0x0D, 0x05, 0x24, 0x5D, 0x87, 0x6C,
+   0x9B, 0xB7, 0xC1, 0x31, 0x2B, 0xA7, 0xA3, 0x95, 0x98, 0x4C, 0xCA, 0x1B,
+   0xE6, 0x8D, 0x73, 0x36, 0xCD, 0x82, 0x12, 0x56, 0x62, 0xAB, 0xF0, 0x47,
+   0x4F, 0x0E, 0xBD, 0x06, 0xD4, 0x25, 0xD2, 0x5E, 0x27, 0x88, 0x66, 0x6D,
+   0xD6, 0x9C, 0x79, 0xB8, 0x08, 0xC2, 0xDF, 0x32, 0x68, 0x2C, 0xFD, 0xA8,
+   0x8A, 0xA4, 0x5A, 0x96, 0x29, 0x99, 0x22, 0x4D, 0x60, 0xCB, 0xE4, 0x1C,
+   0x7B, 0xE7, 0x3B, 0x8E, 0x9E, 0x74, 0xF4, 0x37, 0xD8, 0xCE, 0xF9, 0x83,
+   0x6F, 0x13, 0xB2, 0x57, 0xE1, 0x63, 0xDC, 0xAC, 0xC4, 0xF1, 0xAF, 0x48,
+   0x0A, 0x50, 0x42, 0x0F, 0xBA, 0xBE, 0xC7, 0x07, 0xDE, 0xD5, 0x78, 0x26,
+   0x65, 0xD3, 0xD1, 0x5F, 0xE3, 0x28, 0x21, 0x89, 0x59, 0x67, 0xFC, 0x6E,
+   0xB1, 0xD7, 0xF8, 0x9D, 0xF3, 0x7A, 0x3A, 0xB9, 0xC6, 0x09, 0x41, 0xC3,
+   0xAE, 0xE0, 0xDB, 0x33, 0x44, 0x69, 0x92, 0x2D, 0x52, 0xFE, 0x16, 0xA9,
+   0x0C, 0x8B, 0x80, 0xA5, 0x4A, 0x5B, 0xB5, 0x97, 0xC9, 0x2A, 0xA2, 0x9A,
+   0xC0, 0x23, 0x86, 0x4E, 0xBC, 0x61, 0xEF, 0xCC, 0x11, 0xE5, 0x72, 0x1D,
+   0x3D, 0x7C, 0xEB, 0xE8, 0xE9, 0x3C, 0xEA, 0x8F, 0x7D, 0x9F, 0xEC, 0x75,
+   0x1E, 0xF5, 0x3E, 0x38, 0xF6, 0xD9, 0x3F, 0xCF, 0x76, 0xFA, 0x1F, 0x84,
+   0xA0, 0x70, 0xED, 0x14, 0x90, 0xB3, 0x7E, 0x58, 0xFB, 0xE2, 0x20, 0x64,
+   0xD0, 0xDD, 0x77, 0xAD, 0xDA, 0xC5, 0x40, 0xF2, 0x39, 0xB0, 0xF7, 0x49,
+   0xB4, 0x0B, 0x7F, 0x51, 0x15, 0x43, 0x91, 0x10, 0x71, 0xBB, 0xEE, 0xBF,
+   0x85, 0xC8, 0xA1
+};
+
+static const u8 exp_to_poly[492] = {
+   0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D, 0x9A, 0x79, 0xF2,
+   0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC, 0xF5, 0xA7, 0x03,
+   0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3, 0x8B, 0x5B, 0xB6,
+   0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52, 0xA4, 0x05, 0x0A,
+   0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0, 0xED, 0x97, 0x63,
+   0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1, 0x0F, 0x1E, 0x3C,
+   0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A, 0xF4, 0xA5, 0x07,
+   0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11, 0x22, 0x44, 0x88,
+   0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51, 0xA2, 0x09, 0x12,
+   0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66, 0xCC, 0xD5, 0xE7,
+   0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB, 0x1B, 0x36, 0x6C,
+   0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19, 0x32, 0x64, 0xC8,
+   0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D, 0x5A, 0xB4, 0x25,
+   0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56, 0xAC, 0x15, 0x2A,
+   0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE, 0x91, 0x6F, 0xDE,
+   0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9, 0x3F, 0x7E, 0xFC,
+   0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE, 0xB1, 0x2F, 0x5E,
+   0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41, 0x82, 0x49, 0x92,
+   0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E, 0x71, 0xE2, 0x89,
+   0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB, 0xDB, 0xFB, 0xBB,
+   0x3B, 0x76, 0xEC, 0x95, 0x67, 0xCE, 0xD1, 0xEF, 0x93, 0x6B, 0xD6, 0xE1,
+   0x8F, 0x53, 0xA6, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D,
+   0x9A, 0x79, 0xF2, 0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC,
+   0xF5, 0xA7, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3,
+   0x8B, 0x5B, 0xB6, 0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52,
+   0xA4, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0,
+   0xED, 0x97, 0x63, 0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1,
+   0x0F, 0x1E, 0x3C, 0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A,
+   0xF4, 0xA5, 0x07, 0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11,
+   0x22, 0x44, 0x88, 0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51,
+   0xA2, 0x09, 0x12, 0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66,
+   0xCC, 0xD5, 0xE7, 0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB,
+   0x1B, 0x36, 0x6C, 0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19,
+   0x32, 0x64, 0xC8, 0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D,
+   0x5A, 0xB4, 0x25, 0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56,
+   0xAC, 0x15, 0x2A, 0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE,
+   0x91, 0x6F, 0xDE, 0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9,
+   0x3F, 0x7E, 0xFC, 0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE,
+   0xB1, 0x2F, 0x5E, 0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41,
+   0x82, 0x49, 0x92, 0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E,
+   0x71, 0xE2, 0x89, 0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB
+};
+
+
+/* The table constants are indices of
+ * S-box entries, preprocessed through q0 and q1. */
+static const u8 calc_sb_tbl[512] = {
+    0xA9, 0x75, 0x67, 0xF3, 0xB3, 0xC6, 0xE8, 0xF4,
+    0x04, 0xDB, 0xFD, 0x7B, 0xA3, 0xFB, 0x76, 0xC8,
+    0x9A, 0x4A, 0x92, 0xD3, 0x80, 0xE6, 0x78, 0x6B,
+    0xE4, 0x45, 0xDD, 0x7D, 0xD1, 0xE8, 0x38, 0x4B,
+    0x0D, 0xD6, 0xC6, 0x32, 0x35, 0xD8, 0x98, 0xFD,
+    0x18, 0x37, 0xF7, 0x71, 0xEC, 0xF1, 0x6C, 0xE1,
+    0x43, 0x30, 0x75, 0x0F, 0x37, 0xF8, 0x26, 0x1B,
+    0xFA, 0x87, 0x13, 0xFA, 0x94, 0x06, 0x48, 0x3F,
+    0xF2, 0x5E, 0xD0, 0xBA, 0x8B, 0xAE, 0x30, 0x5B,
+    0x84, 0x8A, 0x54, 0x00, 0xDF, 0xBC, 0x23, 0x9D,
+    0x19, 0x6D, 0x5B, 0xC1, 0x3D, 0xB1, 0x59, 0x0E,
+    0xF3, 0x80, 0xAE, 0x5D, 0xA2, 0xD2, 0x82, 0xD5,
+    0x63, 0xA0, 0x01, 0x84, 0x83, 0x07, 0x2E, 0x14,
+    0xD9, 0xB5, 0x51, 0x90, 0x9B, 0x2C, 0x7C, 0xA3,
+    0xA6, 0xB2, 0xEB, 0x73, 0xA5, 0x4C, 0xBE, 0x54,
+    0x16, 0x92, 0x0C, 0x74, 0xE3, 0x36, 0x61, 0x51,
+    0xC0, 0x38, 0x8C, 0xB0, 0x3A, 0xBD, 0xF5, 0x5A,
+    0x73, 0xFC, 0x2C, 0x60, 0x25, 0x62, 0x0B, 0x96,
+    0xBB, 0x6C, 0x4E, 0x42, 0x89, 0xF7, 0x6B, 0x10,
+    0x53, 0x7C, 0x6A, 0x28, 0xB4, 0x27, 0xF1, 0x8C,
+    0xE1, 0x13, 0xE6, 0x95, 0xBD, 0x9C, 0x45, 0xC7,
+    0xE2, 0x24, 0xF4, 0x46, 0xB6, 0x3B, 0x66, 0x70,
+    0xCC, 0xCA, 0x95, 0xE3, 0x03, 0x85, 0x56, 0xCB,
+    0xD4, 0x11, 0x1C, 0xD0, 0x1E, 0x93, 0xD7, 0xB8,
+    0xFB, 0xA6, 0xC3, 0x83, 0x8E, 0x20, 0xB5, 0xFF,
+    0xE9, 0x9F, 0xCF, 0x77, 0xBF, 0xC3, 0xBA, 0xCC,
+    0xEA, 0x03, 0x77, 0x6F, 0x39, 0x08, 0xAF, 0xBF,
+    0x33, 0x40, 0xC9, 0xE7, 0x62, 0x2B, 0x71, 0xE2,
+    0x81, 0x79, 0x79, 0x0C, 0x09, 0xAA, 0xAD, 0x82,
+    0x24, 0x41, 0xCD, 0x3A, 0xF9, 0xEA, 0xD8, 0xB9,
+    0xE5, 0xE4, 0xC5, 0x9A, 0xB9, 0xA4, 0x4D, 0x97,
+    0x44, 0x7E, 0x08, 0xDA, 0x86, 0x7A, 0xE7, 0x17,
+    0xA1, 0x66, 0x1D, 0x94, 0xAA, 0xA1, 0xED, 0x1D,
+    0x06, 0x3D, 0x70, 0xF0, 0xB2, 0xDE, 0xD2, 0xB3,
+    0x41, 0x0B, 0x7B, 0x72, 0xA0, 0xA7, 0x11, 0x1C,
+    0x31, 0xEF, 0xC2, 0xD1, 0x27, 0x53, 0x90, 0x3E,
+    0x20, 0x8F, 0xF6, 0x33, 0x60, 0x26, 0xFF, 0x5F,
+    0x96, 0xEC, 0x5C, 0x76, 0xB1, 0x2A, 0xAB, 0x49,
+    0x9E, 0x81, 0x9C, 0x88, 0x52, 0xEE, 0x1B, 0x21,
+    0x5F, 0xC4, 0x93, 0x1A, 0x0A, 0xEB, 0xEF, 0xD9,
+    0x91, 0xC5, 0x85, 0x39, 0x49, 0x99, 0xEE, 0xCD,
+    0x2D, 0xAD, 0x4F, 0x31, 0x8F, 0x8B, 0x3B, 0x01,
+    0x47, 0x18, 0x87, 0x23, 0x6D, 0xDD, 0x46, 0x1F,
+    0xD6, 0x4E, 0x3E, 0x2D, 0x69, 0xF9, 0x64, 0x48,
+    0x2A, 0x4F, 0xCE, 0xF2, 0xCB, 0x65, 0x2F, 0x8E,
+    0xFC, 0x78, 0x97, 0x5C, 0x05, 0x58, 0x7A, 0x19,
+    0xAC, 0x8D, 0x7F, 0xE5, 0xD5, 0x98, 0x1A, 0x57,
+    0x4B, 0x67, 0x0E, 0x7F, 0xA7, 0x05, 0x5A, 0x64,
+    0x28, 0xAF, 0x14, 0x63, 0x3F, 0xB6, 0x29, 0xFE,
+    0x88, 0xF5, 0x3C, 0xB7, 0x4C, 0x3C, 0x02, 0xA5,
+    0xB8, 0xCE, 0xDA, 0xE9, 0xB0, 0x68, 0x17, 0x44,
+    0x55, 0xE0, 0x1F, 0x4D, 0x8A, 0x43, 0x7D, 0x69,
+    0x57, 0x29, 0xC7, 0x2E, 0x8D, 0xAC, 0x74, 0x15,
+    0xB7, 0x59, 0xC4, 0xA8, 0x9F, 0x0A, 0x72, 0x9E,
+    0x7E, 0x6E, 0x15, 0x47, 0x22, 0xDF, 0x12, 0x34,
+    0x58, 0x35, 0x07, 0x6A, 0x99, 0xCF, 0x34, 0xDC,
+    0x6E, 0x22, 0x50, 0xC9, 0xDE, 0xC0, 0x68, 0x9B,
+    0x65, 0x89, 0xBC, 0xD4, 0xDB, 0xED, 0xF8, 0xAB,
+    0xC8, 0x12, 0xA8, 0xA2, 0x2B, 0x0D, 0x40, 0x52,
+    0xDC, 0xBB, 0xFE, 0x02, 0x32, 0x2F, 0xA4, 0xA9,
+    0xCA, 0xD7, 0x10, 0x61, 0x21, 0x1E, 0xF0, 0xB4,
+    0xD3, 0x50, 0x5D, 0x04, 0x0F, 0xF6, 0x00, 0xC2,
+    0x6F, 0x16, 0x9D, 0x25, 0x36, 0x86, 0x42, 0x56,
+    0x4A, 0x55, 0x5E, 0x09, 0xC1, 0xBE, 0xE0, 0x91
+};
+
+/* Macro to perform one column of the RS matrix multiplication.  The
+ * parameters a, b, c, and d are the four bytes of output; i is the index
+ * of the key bytes, and w, x, y, and z, are the column of constants from
+ * the RS matrix, preprocessed through the poly_to_exp table. */
+
+#define CALC_S(a, b, c, d, i, w, x, y, z) \
+   if (key[i]) { \
+      tmp = poly_to_exp[key[i] - 1]; \
+      (a) ^= exp_to_poly[tmp + (w)]; \
+      (b) ^= exp_to_poly[tmp + (x)]; \
+      (c) ^= exp_to_poly[tmp + (y)]; \
+      (d) ^= exp_to_poly[tmp + (z)]; \
+   }
+
+/* Macros to calculate the key-dependent S-boxes for a 128-bit key using
+ * the S vector from CALC_S.  CALC_SB_2 computes a single entry in all
+ * four S-boxes, where i is the index of the entry to compute, and a and b
+ * are the index numbers preprocessed through the q0 and q1 tables
+ * respectively. */
+
+#define CALC_SB_2(i, a, b) \
+   ctx-&gt;s[0][i] = mds[0][q0[(a) ^ sa] ^ se]; \
+   ctx-&gt;s[1][i] = mds[1][q0[(b) ^ sb] ^ sf]; \
+   ctx-&gt;s[2][i] = mds[2][q1[(a) ^ sc] ^ sg]; \
+   ctx-&gt;s[3][i] = mds[3][q1[(b) ^ sd] ^ sh]
+
+/* Macro exactly like CALC_SB_2, but for 192-bit keys. */
+
+#define CALC_SB192_2(i, a, b) \
+   ctx-&gt;s[0][i] = mds[0][q0[q0[(b) ^ sa] ^ se] ^ si]; \
+   ctx-&gt;s[1][i] = mds[1][q0[q1[(b) ^ sb] ^ sf] ^ sj]; \
+   ctx-&gt;s[2][i] = mds[2][q1[q0[(a) ^ sc] ^ sg] ^ sk]; \
+   ctx-&gt;s[3][i] = mds[3][q1[q1[(a) ^ sd] ^ sh] ^ sl];
+
+/* Macro exactly like CALC_SB_2, but for 256-bit keys. */
+
+#define CALC_SB256_2(i, a, b) \
+   ctx-&gt;s[0][i] = mds[0][q0[q0[q1[(b) ^ sa] ^ se] ^ si] ^ sm]; \
+   ctx-&gt;s[1][i] = mds[1][q0[q1[q1[(a) ^ sb] ^ sf] ^ sj] ^ sn]; \
+   ctx-&gt;s[2][i] = mds[2][q1[q0[q0[(a) ^ sc] ^ sg] ^ sk] ^ so]; \
+   ctx-&gt;s[3][i] = mds[3][q1[q1[q0[(b) ^ sd] ^ sh] ^ sl] ^ sp];
+
+/* Macros to calculate the whitening and round subkeys.  CALC_K_2 computes the
+ * last two stages of the h() function for a given index (either 2i or 2i+1).
+ * a, b, c, and d are the four bytes going into the last two stages.  For
+ * 128-bit keys, this is the entire h() function and a and c are the index
+ * preprocessed through q0 and q1 respectively; for longer keys they are the
+ * output of previous stages.  j is the index of the first key byte to use.
+ * CALC_K computes a pair of subkeys for 128-bit Twofish, by calling CALC_K_2
+ * twice, doing the Pseudo-Hadamard Transform, and doing the necessary
+ * rotations.  Its parameters are: a, the array to write the results into,
+ * j, the index of the first output entry, k and l, the preprocessed indices
+ * for index 2i, and m and n, the preprocessed indices for index 2i+1.
+ * CALC_K192_2 expands CALC_K_2 to handle 192-bit keys, by doing an
+ * additional lookup-and-XOR stage.  The parameters a, b, c and d are the
+ * four bytes going into the last three stages.  For 192-bit keys, c = d
+ * are the index preprocessed through q0, and a = b are the index
+ * preprocessed through q1; j is the index of the first key byte to use.
+ * CALC_K192 is identical to CALC_K but for using the CALC_K192_2 macro
+ * instead of CALC_K_2.
+ * CALC_K256_2 expands CALC_K192_2 to handle 256-bit keys, by doing an
+ * additional lookup-and-XOR stage.  The parameters a and b are the index
+ * preprocessed through q0 and q1 respectively; j is the index of the first
+ * key byte to use.  CALC_K256 is identical to CALC_K but for using the
+ * CALC_K256_2 macro instead of CALC_K_2. */
+
+#define CALC_K_2(a, b, c, d, j) \
+     mds[0][q0[a ^ key[(j) + 8]] ^ key[j]] \
+   ^ mds[1][q0[b ^ key[(j) + 9]] ^ key[(j) + 1]] \
+   ^ mds[2][q1[c ^ key[(j) + 10]] ^ key[(j) + 2]] \
+   ^ mds[3][q1[d ^ key[(j) + 11]] ^ key[(j) + 3]]
+
+#define CALC_K(a, j, k, l, m, n) \
+   x = CALC_K_2 (k, l, k, l, 0); \
+   y = CALC_K_2 (m, n, m, n, 4); \
+   y = rol32(y, 8); \
+   x += y; y += x; ctx-&gt;a[j] = x; \
+   ctx-&gt;a[(j) + 1] = rol32(y, 9)
+
+#define CALC_K192_2(a, b, c, d, j) \
+   CALC_K_2 (q0[a ^ key[(j) + 16]], \
+	     q1[b ^ key[(j) + 17]], \
+	     q0[c ^ key[(j) + 18]], \
+	     q1[d ^ key[(j) + 19]], j)
+
+#define CALC_K192(a, j, k, l, m, n) \
+   x = CALC_K192_2 (l, l, k, k, 0); \
+   y = CALC_K192_2 (n, n, m, m, 4); \
+   y = rol32(y, 8); \
+   x += y; y += x; ctx-&gt;a[j] = x; \
+   ctx-&gt;a[(j) + 1] = rol32(y, 9)
+
+#define CALC_K256_2(a, b, j) \
+   CALC_K192_2 (q1[b ^ key[(j) + 24]], \
+	        q1[a ^ key[(j) + 25]], \
+	        q0[a ^ key[(j) + 26]], \
+	        q0[b ^ key[(j) + 27]], j)
+
+#define CALC_K256(a, j, k, l, m, n) \
+   x = CALC_K256_2 (k, l, 0); \
+   y = CALC_K256_2 (m, n, 4); \
+   y = rol32(y, 8); \
+   x += y; y += x; ctx-&gt;a[j] = x; \
+   ctx-&gt;a[(j) + 1] = rol32(y, 9)
+
+
+
+/* Perform the key setup. */
+int twofish_setkey(void *cx, const u8 *key,
+                          unsigned int key_len, u32 *flags)
+{
+
+	struct twofish_ctx *ctx = cx;
+
+	int i, j, k;
+
+	/* Temporaries for CALC_K. */
+	u32 x, y;
+
+	/* The S vector used to key the S-boxes, split up into individual bytes.
+	 * 128-bit keys use only sa through sh; 256-bit use all of them. */
+	u8 sa = 0, sb = 0, sc = 0, sd = 0, se = 0, sf = 0, sg = 0, sh = 0;
+	u8 si = 0, sj = 0, sk = 0, sl = 0, sm = 0, sn = 0, so = 0, sp = 0;
+
+	/* Temporary for CALC_S. */
+	u8 tmp;
+
+	/* Check key length. */
+	if (key_len != 16 &amp;&amp; key_len != 24 &amp;&amp; key_len != 32)
+	{
+		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
+		return -EINVAL; /* unsupported key length */
+	}
+
+	/* Compute the first two words of the S vector.  The magic numbers are
+	 * the entries of the RS matrix, preprocessed through poly_to_exp. The
+	 * numbers in the comments are the original (polynomial form) matrix
+	 * entries. */
+	CALC_S (sa, sb, sc, sd, 0, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+	CALC_S (sa, sb, sc, sd, 1, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+	CALC_S (sa, sb, sc, sd, 2, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+	CALC_S (sa, sb, sc, sd, 3, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+	CALC_S (sa, sb, sc, sd, 4, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+	CALC_S (sa, sb, sc, sd, 5, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+	CALC_S (sa, sb, sc, sd, 6, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+	CALC_S (sa, sb, sc, sd, 7, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+	CALC_S (se, sf, sg, sh, 8, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+	CALC_S (se, sf, sg, sh, 9, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+	CALC_S (se, sf, sg, sh, 10, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+	CALC_S (se, sf, sg, sh, 11, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+	CALC_S (se, sf, sg, sh, 12, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+	CALC_S (se, sf, sg, sh, 13, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+	CALC_S (se, sf, sg, sh, 14, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+	CALC_S (se, sf, sg, sh, 15, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+
+	if (key_len == 24 || key_len == 32) { /* 192- or 256-bit key */
+		/* Calculate the third word of the S vector */
+		CALC_S (si, sj, sk, sl, 16, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+		CALC_S (si, sj, sk, sl, 17, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+		CALC_S (si, sj, sk, sl, 18, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+		CALC_S (si, sj, sk, sl, 19, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+		CALC_S (si, sj, sk, sl, 20, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+		CALC_S (si, sj, sk, sl, 21, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+		CALC_S (si, sj, sk, sl, 22, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+		CALC_S (si, sj, sk, sl, 23, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+	}
+
+	if (key_len == 32) { /* 256-bit key */
+		/* Calculate the fourth word of the S vector */
+		CALC_S (sm, sn, so, sp, 24, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+		CALC_S (sm, sn, so, sp, 25, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+		CALC_S (sm, sn, so, sp, 26, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+		CALC_S (sm, sn, so, sp, 27, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+		CALC_S (sm, sn, so, sp, 28, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+		CALC_S (sm, sn, so, sp, 29, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+		CALC_S (sm, sn, so, sp, 30, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+		CALC_S (sm, sn, so, sp, 31, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+
+		/* Compute the S-boxes. */
+		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
+			CALC_SB256_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
+		}
+
+		/* Calculate whitening and round subkeys.  The constants are
+		 * indices of subkeys, preprocessed through q0 and q1. */
+		CALC_K256 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
+		CALC_K256 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
+		CALC_K256 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
+		CALC_K256 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
+		CALC_K256 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
+		CALC_K256 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
+		CALC_K256 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
+		CALC_K256 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
+		CALC_K256 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
+		CALC_K256 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
+		CALC_K256 (k, 12, 0x18, 0x37, 0xF7, 0x71);
+		CALC_K256 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
+		CALC_K256 (k, 16, 0x43, 0x30, 0x75, 0x0F);
+		CALC_K256 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
+		CALC_K256 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
+		CALC_K256 (k, 22, 0x94, 0x06, 0x48, 0x3F);
+		CALC_K256 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
+		CALC_K256 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
+		CALC_K256 (k, 28, 0x84, 0x8A, 0x54, 0x00);
+		CALC_K256 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
+	} else if (key_len == 24) { /* 192-bit key */
+		/* Compute the S-boxes. */
+		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
+		        CALC_SB192_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
+		}
+
+		/* Calculate whitening and round subkeys.  The constants are
+		 * indices of subkeys, preprocessed through q0 and q1. */
+		CALC_K192 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
+		CALC_K192 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
+		CALC_K192 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
+		CALC_K192 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
+		CALC_K192 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
+		CALC_K192 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
+		CALC_K192 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
+		CALC_K192 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
+		CALC_K192 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
+		CALC_K192 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
+		CALC_K192 (k, 12, 0x18, 0x37, 0xF7, 0x71);
+		CALC_K192 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
+		CALC_K192 (k, 16, 0x43, 0x30, 0x75, 0x0F);
+		CALC_K192 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
+		CALC_K192 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
+		CALC_K192 (k, 22, 0x94, 0x06, 0x48, 0x3F);
+		CALC_K192 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
+		CALC_K192 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
+		CALC_K192 (k, 28, 0x84, 0x8A, 0x54, 0x00);
+		CALC_K192 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
+	} else { /* 128-bit key */
+		/* Compute the S-boxes. */
+		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
+			CALC_SB_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
+		}
+
+		/* Calculate whitening and round subkeys.  The constants are
+		 * indices of subkeys, preprocessed through q0 and q1. */
+		CALC_K (w, 0, 0xA9, 0x75, 0x67, 0xF3);
+		CALC_K (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
+		CALC_K (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
+		CALC_K (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
+		CALC_K (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
+		CALC_K (k, 2, 0x80, 0xE6, 0x78, 0x6B);
+		CALC_K (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
+		CALC_K (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
+		CALC_K (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
+		CALC_K (k, 10, 0x35, 0xD8, 0x98, 0xFD);
+		CALC_K (k, 12, 0x18, 0x37, 0xF7, 0x71);
+		CALC_K (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
+		CALC_K (k, 16, 0x43, 0x30, 0x75, 0x0F);
+		CALC_K (k, 18, 0x37, 0xF8, 0x26, 0x1B);
+		CALC_K (k, 20, 0xFA, 0x87, 0x13, 0xFA);
+		CALC_K (k, 22, 0x94, 0x06, 0x48, 0x3F);
+		CALC_K (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
+		CALC_K (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
+		CALC_K (k, 28, 0x84, 0x8A, 0x54, 0x00);
+		CALC_K (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL(twofish_setkey);
+
diff -uprN linux-2.6.17-rc5/include/crypto/twofish.h linux-2.6.17-rc5.twofish/include/crypto/twofish.h
--- linux-2.6.17-rc5/include/crypto/twofish.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish/include/crypto/twofish.h	2006-06-11 15:58:20.319984126 +0200
@@ -0,0 +1,14 @@
+#define TF_MIN_KEY_SIZE 16
+#define TF_MAX_KEY_SIZE 32
+#define TF_BLOCK_SIZE 16
+
+/* Structure for an expanded Twofish key.  s contains the key-dependent
+ * S-boxes composed with the MDS matrix; w contains the eight "whitening"
+ * subkeys, K[0] through K[7].	k holds the remaining, "round" subkeys.  Note
+ * that k[i] corresponds to what the Twofish paper calls K[i+8]. */
+struct twofish_ctx {
+   u32 s[4][256], w[8], k[32];
+};
+
+int twofish_setkey(void *cx, const u8 *key,unsigned int key_len, u32 *flags);
+
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060618113138</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-06-18 11:31:38-0400</timestampReceived><subject>Re: [PATCH  1/4] Twofish cipher - split out common c code</subject><body>

On Fri, Jun 16, 2006 at 01:58:52PM +0200, Joachim Fritschi wrote:
&gt;
&gt; I have done the changes you requested. twofish and twofish_common are now 2
&gt; seperate modules. twofish_common is hidden from the user and can be shared by 
&gt; both generic-c and the asm implementation.

Thanks, but unfortunately your patch doesn't apply for me.  You should
base your work on the tree at

git://git.kernel.org/pub/scm/linux/kernel/git/herbert/cryptodev-2.6.git/

  
&gt; +config CRYPTO_TWOFISH_COMMON
&gt; +        tristate	
&gt; +        depends on CRYPTO
&gt; +        help
&gt; +	  Common parts of the Twofish cipher algorithm shared by the 
&gt; +	  generic c and the assembler implementations.

Please drop the help (it's not meant to be visible) and add a 'default n'
instead.

&gt; diff -uprN linux-2.6.17-rc5/crypto/twofish_common.c linux-2.6.17-rc5.twofish/crypto/twofish_common.c
&gt; --- linux-2.6.17-rc5/crypto/twofish_common.c	1970-01-01 01:00:00.000000000 +0100
&gt; +++ linux-2.6.17-rc5.twofish/crypto/twofish_common.c	2006-06-11 15:58:20.319984126 +0200
&gt; @@ -0,0 +1,740 @@

...

&gt; +static const u8 q0[256] = {
&gt; +   0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78,

Please take the opportunity to reformat this to use tabs.

&gt; diff -uprN linux-2.6.17-rc5/include/crypto/twofish.h linux-2.6.17-rc5.twofish/include/crypto/twofish.h
&gt; --- linux-2.6.17-rc5/include/crypto/twofish.h	1970-01-01 01:00:00.000000000 +0100
&gt; +++ linux-2.6.17-rc5.twofish/include/crypto/twofish.h	2006-06-11 15:58:20.319984126 +0200
&gt; @@ -0,0 +1,14 @@

Please add the usual preamble (see include/linux/xfrm.h for example).

&gt; +int twofish_setkey(void *cx, const u8 *key,unsigned int key_len, u32 *flags);
					      ^ needs space here

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060618135336</emailId><senderName>Roman Zippel</senderName><senderEmail>zippel@linux-m68k.org</senderEmail><timestampReceived>2006-06-18 13:53:36-0400</timestampReceived><subject>Re: [PATCH  1/4] Twofish cipher - split out common c code</subject><body>

Hi,

On Sun, 18 Jun 2006, Herbert Xu wrote:

&gt; &gt; +config CRYPTO_TWOFISH_COMMON
&gt; &gt; +        tristate	
&gt; &gt; +        depends on CRYPTO
&gt; &gt; +        help
&gt; &gt; +	  Common parts of the Twofish cipher algorithm shared by the 
&gt; &gt; +	  generic c and the assembler implementations.
&gt; 
&gt; Please drop the help (it's not meant to be visible) and add a 'default n'
&gt; instead.

The help text is also useful as documentation and doesn't hurt.
'n' is the default already, so it's not needed.

bye, Roman
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060619061813</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-06-19 06:18:13-0400</timestampReceived><subject>Re: [PATCH  1/4] Twofish cipher - split out common c code</subject><body>

On Sun, Jun 18, 2006 at 03:53:36PM +0200, Roman Zippel wrote:
&gt;
&gt; &gt; Please drop the help (it's not meant to be visible) and add a 'default n'
&gt; &gt; instead.
&gt; 
&gt; The help text is also useful as documentation and doesn't hurt.
&gt; 'n' is the default already, so it's not needed.

Thanks for the correction Roman.

Joachim, please rebase your patch on the cryptodev tree and resend.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060619141237</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-19 14:12:37-0400</timestampReceived><subject>Re: [PATCH  1/4] Twofish cipher - split out common c code</subject><body>

On Monday 19 June 2006 08:18, Herbert Xu wrote:
&gt; Joachim, please rebase your patch on the cryptodev tree and resend.
This patch is now based on the cryptodev tree. The last patches where against
2.6.17. I somehow missed you announcement about the api change (ctx -&gt; tfm).
I also did the formating changes and the header fix you asked for.

Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

 crypto/Kconfig           |    8 
 crypto/Makefile          |    1 
 crypto/twofish.c         |  698 -------------------------------------------
 crypto/twofish_common.c  |  742 ++++++++++++++++++++++++++++++++++++++++++++++
 include/crypto/twofish.h |   18 +
 5 files changed, 770 insertions(+), 697 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
index ba133d5..f364260 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -131,6 +131,7 @@ config CRYPTO_BLOWFISH
 config CRYPTO_TWOFISH
 	tristate "Twofish cipher algorithm"
 	depends on CRYPTO
+	select CRYPTO_TWOFISH_COMMON
 	help
 	  Twofish cipher algorithm.
 	  
@@ -142,6 +143,13 @@ config CRYPTO_TWOFISH
 	  See also:
 	  &lt;http://www.schneier.com/twofish.html&gt;
 
+config CRYPTO_TWOFISH_COMMON
+	tristate	
+	depends on CRYPTO
+	help
+	  Common parts of the Twofish cipher algorithm shared by the 
+	  generic c and the assembler implementations.
+
 config CRYPTO_SERPENT
 	tristate "Serpent cipher algorithm"
 	depends on CRYPTO
diff --git a/crypto/Makefile b/crypto/Makefile
index d287b9e..fe934f1 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_CRYPTO_TGR192) += tgr192.o
 obj-$(CONFIG_CRYPTO_DES) += des.o
 obj-$(CONFIG_CRYPTO_BLOWFISH) += blowfish.o
 obj-$(CONFIG_CRYPTO_TWOFISH) += twofish.o
+obj-$(CONFIG_CRYPTO_TWOFISH_COMMON) += twofish_common.o
 obj-$(CONFIG_CRYPTO_SERPENT) += serpent.o
 obj-$(CONFIG_CRYPTO_AES) += aes.o
 obj-$(CONFIG_CRYPTO_CAST5) += cast5.o
diff --git a/crypto/twofish.c b/crypto/twofish.c
index ec24882..d5ef89a 100644
--- a/crypto/twofish.c
+++ b/crypto/twofish.c
@@ -45,534 +45,7 @@ #include &lt;linux/types.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/crypto.h&gt;
 #include &lt;linux/bitops.h&gt;
-
-
-/* The large precomputed tables for the Twofish cipher (twofish.c)
- * Taken from the same source as twofish.c
- * Marc Mutz &lt;Marc@Mutz.com&gt;
- */
-
-/* These two tables are the q0 and q1 permutations, exactly as described in
- * the Twofish paper. */
-
-static const u8 q0[256] = {
-   0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78,
-   0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C,
-   0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30,
-   0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82,
-   0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE,
-   0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B,
-   0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45,
-   0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7,
-   0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF,
-   0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8,
-   0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED,
-   0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90,
-   0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B,
-   0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B,
-   0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F,
-   0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A,
-   0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17,
-   0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72,
-   0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68,
-   0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4,
-   0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42,
-   0x4A, 0x5E, 0xC1, 0xE0
-};
-
-static const u8 q1[256] = {
-   0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B,
-   0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1,
-   0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B,
-   0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5,
-   0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54,
-   0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96,
-   0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7,
-   0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8,
-   0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF,
-   0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9,
-   0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D,
-   0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E,
-   0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21,
-   0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01,
-   0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E,
-   0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64,
-   0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44,
-   0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E,
-   0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B,
-   0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9,
-   0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56,
-   0x55, 0x09, 0xBE, 0x91
-};
-
-/* These MDS tables are actually tables of MDS composed with q0 and q1,
- * because it is only ever used that way and we can save some time by
- * precomputing.  Of course the main saving comes from precomputing the
- * GF(2^8) multiplication involved in the MDS matrix multiply; by looking
- * things up in these tables we reduce the matrix multiply to four lookups
- * and three XORs.  Semi-formally, the definition of these tables is:
- * mds[0][i] = MDS (q1[i] 0 0 0)^T  mds[1][i] = MDS (0 q0[i] 0 0)^T
- * mds[2][i] = MDS (0 0 q1[i] 0)^T  mds[3][i] = MDS (0 0 0 q0[i])^T
- * where ^T means "transpose", the matrix multiply is performed in GF(2^8)
- * represented as GF(2)[x]/v(x) where v(x)=x^8+x^6+x^5+x^3+1 as described
- * by Schneier et al, and I'm casually glossing over the byte/word
- * conversion issues. */
-
-static const u32 mds[4][256] = {
-   {0xBCBC3275, 0xECEC21F3, 0x202043C6, 0xB3B3C9F4, 0xDADA03DB, 0x02028B7B,
-    0xE2E22BFB, 0x9E9EFAC8, 0xC9C9EC4A, 0xD4D409D3, 0x18186BE6, 0x1E1E9F6B,
-    0x98980E45, 0xB2B2387D, 0xA6A6D2E8, 0x2626B74B, 0x3C3C57D6, 0x93938A32,
-    0x8282EED8, 0x525298FD, 0x7B7BD437, 0xBBBB3771, 0x5B5B97F1, 0x474783E1,
-    0x24243C30, 0x5151E20F, 0xBABAC6F8, 0x4A4AF31B, 0xBFBF4887, 0x0D0D70FA,
-    0xB0B0B306, 0x7575DE3F, 0xD2D2FD5E, 0x7D7D20BA, 0x666631AE, 0x3A3AA35B,
-    0x59591C8A, 0x00000000, 0xCDCD93BC, 0x1A1AE09D, 0xAEAE2C6D, 0x7F7FABC1,
-    0x2B2BC7B1, 0xBEBEB90E, 0xE0E0A080, 0x8A8A105D, 0x3B3B52D2, 0x6464BAD5,
-    0xD8D888A0, 0xE7E7A584, 0x5F5FE807, 0x1B1B1114, 0x2C2CC2B5, 0xFCFCB490,
-    0x3131272C, 0x808065A3, 0x73732AB2, 0x0C0C8173, 0x79795F4C, 0x6B6B4154,
-    0x4B4B0292, 0x53536974, 0x94948F36, 0x83831F51, 0x2A2A3638, 0xC4C49CB0,
-    0x2222C8BD, 0xD5D5F85A, 0xBDBDC3FC, 0x48487860, 0xFFFFCE62, 0x4C4C0796,
-    0x4141776C, 0xC7C7E642, 0xEBEB24F7, 0x1C1C1410, 0x5D5D637C, 0x36362228,
-    0x6767C027, 0xE9E9AF8C, 0x4444F913, 0x1414EA95, 0xF5F5BB9C, 0xCFCF18C7,
-    0x3F3F2D24, 0xC0C0E346, 0x7272DB3B, 0x54546C70, 0x29294CCA, 0xF0F035E3,
-    0x0808FE85, 0xC6C617CB, 0xF3F34F11, 0x8C8CE4D0, 0xA4A45993, 0xCACA96B8,
-    0x68683BA6, 0xB8B84D83, 0x38382820, 0xE5E52EFF, 0xADAD569F, 0x0B0B8477,
-    0xC8C81DC3, 0x9999FFCC, 0x5858ED03, 0x19199A6F, 0x0E0E0A08, 0x95957EBF,
-    0x70705040, 0xF7F730E7, 0x6E6ECF2B, 0x1F1F6EE2, 0xB5B53D79, 0x09090F0C,
-    0x616134AA, 0x57571682, 0x9F9F0B41, 0x9D9D803A, 0x111164EA, 0x2525CDB9,
-    0xAFAFDDE4, 0x4545089A, 0xDFDF8DA4, 0xA3A35C97, 0xEAEAD57E, 0x353558DA,
-    0xEDEDD07A, 0x4343FC17, 0xF8F8CB66, 0xFBFBB194, 0x3737D3A1, 0xFAFA401D,
-    0xC2C2683D, 0xB4B4CCF0, 0x32325DDE, 0x9C9C71B3, 0x5656E70B, 0xE3E3DA72,
-    0x878760A7, 0x15151B1C, 0xF9F93AEF, 0x6363BFD1, 0x3434A953, 0x9A9A853E,
-    0xB1B1428F, 0x7C7CD133, 0x88889B26, 0x3D3DA65F, 0xA1A1D7EC, 0xE4E4DF76,
-    0x8181942A, 0x91910149, 0x0F0FFB81, 0xEEEEAA88, 0x161661EE, 0xD7D77321,
-    0x9797F5C4, 0xA5A5A81A, 0xFEFE3FEB, 0x6D6DB5D9, 0x7878AEC5, 0xC5C56D39,
-    0x1D1DE599, 0x7676A4CD, 0x3E3EDCAD, 0xCBCB6731, 0xB6B6478B, 0xEFEF5B01,
-    0x12121E18, 0x6060C523, 0x6A6AB0DD, 0x4D4DF61F, 0xCECEE94E, 0xDEDE7C2D,
-    0x55559DF9, 0x7E7E5A48, 0x2121B24F, 0x03037AF2, 0xA0A02665, 0x5E5E198E,
-    0x5A5A6678, 0x65654B5C, 0x62624E58, 0xFDFD4519, 0x0606F48D, 0x404086E5,
-    0xF2F2BE98, 0x3333AC57, 0x17179067, 0x05058E7F, 0xE8E85E05, 0x4F4F7D64,
-    0x89896AAF, 0x10109563, 0x74742FB6, 0x0A0A75FE, 0x5C5C92F5, 0x9B9B74B7,
-    0x2D2D333C, 0x3030D6A5, 0x2E2E49CE, 0x494989E9, 0x46467268, 0x77775544,
-    0xA8A8D8E0, 0x9696044D, 0x2828BD43, 0xA9A92969, 0xD9D97929, 0x8686912E,
-    0xD1D187AC, 0xF4F44A15, 0x8D8D1559, 0xD6D682A8, 0xB9B9BC0A, 0x42420D9E,
-    0xF6F6C16E, 0x2F2FB847, 0xDDDD06DF, 0x23233934, 0xCCCC6235, 0xF1F1C46A,
-    0xC1C112CF, 0x8585EBDC, 0x8F8F9E22, 0x7171A1C9, 0x9090F0C0, 0xAAAA539B,
-    0x0101F189, 0x8B8BE1D4, 0x4E4E8CED, 0x8E8E6FAB, 0xABABA212, 0x6F6F3EA2,
-    0xE6E6540D, 0xDBDBF252, 0x92927BBB, 0xB7B7B602, 0x6969CA2F, 0x3939D9A9,
-    0xD3D30CD7, 0xA7A72361, 0xA2A2AD1E, 0xC3C399B4, 0x6C6C4450, 0x07070504,
-    0x04047FF6, 0x272746C2, 0xACACA716, 0xD0D07625, 0x50501386, 0xDCDCF756,
-    0x84841A55, 0xE1E15109, 0x7A7A25BE, 0x1313EF91},
-
-   {0xA9D93939, 0x67901717, 0xB3719C9C, 0xE8D2A6A6, 0x04050707, 0xFD985252,
-    0xA3658080, 0x76DFE4E4, 0x9A084545, 0x92024B4B, 0x80A0E0E0, 0x78665A5A,
-    0xE4DDAFAF, 0xDDB06A6A, 0xD1BF6363, 0x38362A2A, 0x0D54E6E6, 0xC6432020,
-    0x3562CCCC, 0x98BEF2F2, 0x181E1212, 0xF724EBEB, 0xECD7A1A1, 0x6C774141,
-    0x43BD2828, 0x7532BCBC, 0x37D47B7B, 0x269B8888, 0xFA700D0D, 0x13F94444,
-    0x94B1FBFB, 0x485A7E7E, 0xF27A0303, 0xD0E48C8C, 0x8B47B6B6, 0x303C2424,
-    0x84A5E7E7, 0x54416B6B, 0xDF06DDDD, 0x23C56060, 0x1945FDFD, 0x5BA33A3A,
-    0x3D68C2C2, 0x59158D8D, 0xF321ECEC, 0xAE316666, 0xA23E6F6F, 0x82165757,
-    0x63951010, 0x015BEFEF, 0x834DB8B8, 0x2E918686, 0xD9B56D6D, 0x511F8383,
-    0x9B53AAAA, 0x7C635D5D, 0xA63B6868, 0xEB3FFEFE, 0xA5D63030, 0xBE257A7A,
-    0x16A7ACAC, 0x0C0F0909, 0xE335F0F0, 0x6123A7A7, 0xC0F09090, 0x8CAFE9E9,
-    0x3A809D9D, 0xF5925C5C, 0x73810C0C, 0x2C273131, 0x2576D0D0, 0x0BE75656,
-    0xBB7B9292, 0x4EE9CECE, 0x89F10101, 0x6B9F1E1E, 0x53A93434, 0x6AC4F1F1,
-    0xB499C3C3, 0xF1975B5B, 0xE1834747, 0xE66B1818, 0xBDC82222, 0x450E9898,
-    0xE26E1F1F, 0xF4C9B3B3, 0xB62F7474, 0x66CBF8F8, 0xCCFF9999, 0x95EA1414,
-    0x03ED5858, 0x56F7DCDC, 0xD4E18B8B, 0x1C1B1515, 0x1EADA2A2, 0xD70CD3D3,
-    0xFB2BE2E2, 0xC31DC8C8, 0x8E195E5E, 0xB5C22C2C, 0xE9894949, 0xCF12C1C1,
-    0xBF7E9595, 0xBA207D7D, 0xEA641111, 0x77840B0B, 0x396DC5C5, 0xAF6A8989,
-    0x33D17C7C, 0xC9A17171, 0x62CEFFFF, 0x7137BBBB, 0x81FB0F0F, 0x793DB5B5,
-    0x0951E1E1, 0xADDC3E3E, 0x242D3F3F, 0xCDA47676, 0xF99D5555, 0xD8EE8282,
-    0xE5864040, 0xC5AE7878, 0xB9CD2525, 0x4D049696, 0x44557777, 0x080A0E0E,
-    0x86135050, 0xE730F7F7, 0xA1D33737, 0x1D40FAFA, 0xAA346161, 0xED8C4E4E,
-    0x06B3B0B0, 0x706C5454, 0xB22A7373, 0xD2523B3B, 0x410B9F9F, 0x7B8B0202,
-    0xA088D8D8, 0x114FF3F3, 0x3167CBCB, 0xC2462727, 0x27C06767, 0x90B4FCFC,
-    0x20283838, 0xF67F0404, 0x60784848, 0xFF2EE5E5, 0x96074C4C, 0x5C4B6565,
-    0xB1C72B2B, 0xAB6F8E8E, 0x9E0D4242, 0x9CBBF5F5, 0x52F2DBDB, 0x1BF34A4A,
-    0x5FA63D3D, 0x9359A4A4, 0x0ABCB9B9, 0xEF3AF9F9, 0x91EF1313, 0x85FE0808,
-    0x49019191, 0xEE611616, 0x2D7CDEDE, 0x4FB22121, 0x8F42B1B1, 0x3BDB7272,
-    0x47B82F2F, 0x8748BFBF, 0x6D2CAEAE, 0x46E3C0C0, 0xD6573C3C, 0x3E859A9A,
-    0x6929A9A9, 0x647D4F4F, 0x2A948181, 0xCE492E2E, 0xCB17C6C6, 0x2FCA6969,
-    0xFCC3BDBD, 0x975CA3A3, 0x055EE8E8, 0x7AD0EDED, 0xAC87D1D1, 0x7F8E0505,
-    0xD5BA6464, 0x1AA8A5A5, 0x4BB72626, 0x0EB9BEBE, 0xA7608787, 0x5AF8D5D5,
-    0x28223636, 0x14111B1B, 0x3FDE7575, 0x2979D9D9, 0x88AAEEEE, 0x3C332D2D,
-    0x4C5F7979, 0x02B6B7B7, 0xB896CACA, 0xDA583535, 0xB09CC4C4, 0x17FC4343,
-    0x551A8484, 0x1FF64D4D, 0x8A1C5959, 0x7D38B2B2, 0x57AC3333, 0xC718CFCF,
-    0x8DF40606, 0x74695353, 0xB7749B9B, 0xC4F59797, 0x9F56ADAD, 0x72DAE3E3,
-    0x7ED5EAEA, 0x154AF4F4, 0x229E8F8F, 0x12A2ABAB, 0x584E6262, 0x07E85F5F,
-    0x99E51D1D, 0x34392323, 0x6EC1F6F6, 0x50446C6C, 0xDE5D3232, 0x68724646,
-    0x6526A0A0, 0xBC93CDCD, 0xDB03DADA, 0xF8C6BABA, 0xC8FA9E9E, 0xA882D6D6,
-    0x2BCF6E6E, 0x40507070, 0xDCEB8585, 0xFE750A0A, 0x328A9393, 0xA48DDFDF,
-    0xCA4C2929, 0x10141C1C, 0x2173D7D7, 0xF0CCB4B4, 0xD309D4D4, 0x5D108A8A,
-    0x0FE25151, 0x00000000, 0x6F9A1919, 0x9DE01A1A, 0x368F9494, 0x42E6C7C7,
-    0x4AECC9C9, 0x5EFDD2D2, 0xC1AB7F7F, 0xE0D8A8A8},
-
-   {0xBC75BC32, 0xECF3EC21, 0x20C62043, 0xB3F4B3C9, 0xDADBDA03, 0x027B028B,
-    0xE2FBE22B, 0x9EC89EFA, 0xC94AC9EC, 0xD4D3D409, 0x18E6186B, 0x1E6B1E9F,
-    0x9845980E, 0xB27DB238, 0xA6E8A6D2, 0x264B26B7, 0x3CD63C57, 0x9332938A,
-    0x82D882EE, 0x52FD5298, 0x7B377BD4, 0xBB71BB37, 0x5BF15B97, 0x47E14783,
-    0x2430243C, 0x510F51E2, 0xBAF8BAC6, 0x4A1B4AF3, 0xBF87BF48, 0x0DFA0D70,
-    0xB006B0B3, 0x753F75DE, 0xD25ED2FD, 0x7DBA7D20, 0x66AE6631, 0x3A5B3AA3,
-    0x598A591C, 0x00000000, 0xCDBCCD93, 0x1A9D1AE0, 0xAE6DAE2C, 0x7FC17FAB,
-    0x2BB12BC7, 0xBE0EBEB9, 0xE080E0A0, 0x8A5D8A10, 0x3BD23B52, 0x64D564BA,
-    0xD8A0D888, 0xE784E7A5, 0x5F075FE8, 0x1B141B11, 0x2CB52CC2, 0xFC90FCB4,
-    0x312C3127, 0x80A38065, 0x73B2732A, 0x0C730C81, 0x794C795F, 0x6B546B41,
-    0x4B924B02, 0x53745369, 0x9436948F, 0x8351831F, 0x2A382A36, 0xC4B0C49C,
-    0x22BD22C8, 0xD55AD5F8, 0xBDFCBDC3, 0x48604878, 0xFF62FFCE, 0x4C964C07,
-    0x416C4177, 0xC742C7E6, 0xEBF7EB24, 0x1C101C14, 0x5D7C5D63, 0x36283622,
-    0x672767C0, 0xE98CE9AF, 0x441344F9, 0x149514EA, 0xF59CF5BB, 0xCFC7CF18,
-    0x3F243F2D, 0xC046C0E3, 0x723B72DB, 0x5470546C, 0x29CA294C, 0xF0E3F035,
-    0x088508FE, 0xC6CBC617, 0xF311F34F, 0x8CD08CE4, 0xA493A459, 0xCAB8CA96,
-    0x68A6683B, 0xB883B84D, 0x38203828, 0xE5FFE52E, 0xAD9FAD56, 0x0B770B84,
-    0xC8C3C81D, 0x99CC99FF, 0x580358ED, 0x196F199A, 0x0E080E0A, 0x95BF957E,
-    0x70407050, 0xF7E7F730, 0x6E2B6ECF, 0x1FE21F6E, 0xB579B53D, 0x090C090F,
-    0x61AA6134, 0x57825716, 0x9F419F0B, 0x9D3A9D80, 0x11EA1164, 0x25B925CD,
-    0xAFE4AFDD, 0x459A4508, 0xDFA4DF8D, 0xA397A35C, 0xEA7EEAD5, 0x35DA3558,
-    0xED7AEDD0, 0x431743FC, 0xF866F8CB, 0xFB94FBB1, 0x37A137D3, 0xFA1DFA40,
-    0xC23DC268, 0xB4F0B4CC, 0x32DE325D, 0x9CB39C71, 0x560B56E7, 0xE372E3DA,
-    0x87A78760, 0x151C151B, 0xF9EFF93A, 0x63D163BF, 0x345334A9, 0x9A3E9A85,
-    0xB18FB142, 0x7C337CD1, 0x8826889B, 0x3D5F3DA6, 0xA1ECA1D7, 0xE476E4DF,
-    0x812A8194, 0x91499101, 0x0F810FFB, 0xEE88EEAA, 0x16EE1661, 0xD721D773,
-    0x97C497F5, 0xA51AA5A8, 0xFEEBFE3F, 0x6DD96DB5, 0x78C578AE, 0xC539C56D,
-    0x1D991DE5, 0x76CD76A4, 0x3EAD3EDC, 0xCB31CB67, 0xB68BB647, 0xEF01EF5B,
-    0x1218121E, 0x602360C5, 0x6ADD6AB0, 0x4D1F4DF6, 0xCE4ECEE9, 0xDE2DDE7C,
-    0x55F9559D, 0x7E487E5A, 0x214F21B2, 0x03F2037A, 0xA065A026, 0x5E8E5E19,
-    0x5A785A66, 0x655C654B, 0x6258624E, 0xFD19FD45, 0x068D06F4, 0x40E54086,
-    0xF298F2BE, 0x335733AC, 0x17671790, 0x057F058E, 0xE805E85E, 0x4F644F7D,
-    0x89AF896A, 0x10631095, 0x74B6742F, 0x0AFE0A75, 0x5CF55C92, 0x9BB79B74,
-    0x2D3C2D33, 0x30A530D6, 0x2ECE2E49, 0x49E94989, 0x46684672, 0x77447755,
-    0xA8E0A8D8, 0x964D9604, 0x284328BD, 0xA969A929, 0xD929D979, 0x862E8691,
-    0xD1ACD187, 0xF415F44A, 0x8D598D15, 0xD6A8D682, 0xB90AB9BC, 0x429E420D,
-    0xF66EF6C1, 0x2F472FB8, 0xDDDFDD06, 0x23342339, 0xCC35CC62, 0xF16AF1C4,
-    0xC1CFC112, 0x85DC85EB, 0x8F228F9E, 0x71C971A1, 0x90C090F0, 0xAA9BAA53,
-    0x018901F1, 0x8BD48BE1, 0x4EED4E8C, 0x8EAB8E6F, 0xAB12ABA2, 0x6FA26F3E,
-    0xE60DE654, 0xDB52DBF2, 0x92BB927B, 0xB702B7B6, 0x692F69CA, 0x39A939D9,
-    0xD3D7D30C, 0xA761A723, 0xA21EA2AD, 0xC3B4C399, 0x6C506C44, 0x07040705,
-    0x04F6047F, 0x27C22746, 0xAC16ACA7, 0xD025D076, 0x50865013, 0xDC56DCF7,
-    0x8455841A, 0xE109E151, 0x7ABE7A25, 0x139113EF},
-
-   {0xD939A9D9, 0x90176790, 0x719CB371, 0xD2A6E8D2, 0x05070405, 0x9852FD98,
-    0x6580A365, 0xDFE476DF, 0x08459A08, 0x024B9202, 0xA0E080A0, 0x665A7866,
-    0xDDAFE4DD, 0xB06ADDB0, 0xBF63D1BF, 0x362A3836, 0x54E60D54, 0x4320C643,
-    0x62CC3562, 0xBEF298BE, 0x1E12181E, 0x24EBF724, 0xD7A1ECD7, 0x77416C77,
-    0xBD2843BD, 0x32BC7532, 0xD47B37D4, 0x9B88269B, 0x700DFA70, 0xF94413F9,
-    0xB1FB94B1, 0x5A7E485A, 0x7A03F27A, 0xE48CD0E4, 0x47B68B47, 0x3C24303C,
-    0xA5E784A5, 0x416B5441, 0x06DDDF06, 0xC56023C5, 0x45FD1945, 0xA33A5BA3,
-    0x68C23D68, 0x158D5915, 0x21ECF321, 0x3166AE31, 0x3E6FA23E, 0x16578216,
-    0x95106395, 0x5BEF015B, 0x4DB8834D, 0x91862E91, 0xB56DD9B5, 0x1F83511F,
-    0x53AA9B53, 0x635D7C63, 0x3B68A63B, 0x3FFEEB3F, 0xD630A5D6, 0x257ABE25,
-    0xA7AC16A7, 0x0F090C0F, 0x35F0E335, 0x23A76123, 0xF090C0F0, 0xAFE98CAF,
-    0x809D3A80, 0x925CF592, 0x810C7381, 0x27312C27, 0x76D02576, 0xE7560BE7,
-    0x7B92BB7B, 0xE9CE4EE9, 0xF10189F1, 0x9F1E6B9F, 0xA93453A9, 0xC4F16AC4,
-    0x99C3B499, 0x975BF197, 0x8347E183, 0x6B18E66B, 0xC822BDC8, 0x0E98450E,
-    0x6E1FE26E, 0xC9B3F4C9, 0x2F74B62F, 0xCBF866CB, 0xFF99CCFF, 0xEA1495EA,
-    0xED5803ED, 0xF7DC56F7, 0xE18BD4E1, 0x1B151C1B, 0xADA21EAD, 0x0CD3D70C,
-    0x2BE2FB2B, 0x1DC8C31D, 0x195E8E19, 0xC22CB5C2, 0x8949E989, 0x12C1CF12,
-    0x7E95BF7E, 0x207DBA20, 0x6411EA64, 0x840B7784, 0x6DC5396D, 0x6A89AF6A,
-    0xD17C33D1, 0xA171C9A1, 0xCEFF62CE, 0x37BB7137, 0xFB0F81FB, 0x3DB5793D,
-    0x51E10951, 0xDC3EADDC, 0x2D3F242D, 0xA476CDA4, 0x9D55F99D, 0xEE82D8EE,
-    0x8640E586, 0xAE78C5AE, 0xCD25B9CD, 0x04964D04, 0x55774455, 0x0A0E080A,
-    0x13508613, 0x30F7E730, 0xD337A1D3, 0x40FA1D40, 0x3461AA34, 0x8C4EED8C,
-    0xB3B006B3, 0x6C54706C, 0x2A73B22A, 0x523BD252, 0x0B9F410B, 0x8B027B8B,
-    0x88D8A088, 0x4FF3114F, 0x67CB3167, 0x4627C246, 0xC06727C0, 0xB4FC90B4,
-    0x28382028, 0x7F04F67F, 0x78486078, 0x2EE5FF2E, 0x074C9607, 0x4B655C4B,
-    0xC72BB1C7, 0x6F8EAB6F, 0x0D429E0D, 0xBBF59CBB, 0xF2DB52F2, 0xF34A1BF3,
-    0xA63D5FA6, 0x59A49359, 0xBCB90ABC, 0x3AF9EF3A, 0xEF1391EF, 0xFE0885FE,
-    0x01914901, 0x6116EE61, 0x7CDE2D7C, 0xB2214FB2, 0x42B18F42, 0xDB723BDB,
-    0xB82F47B8, 0x48BF8748, 0x2CAE6D2C, 0xE3C046E3, 0x573CD657, 0x859A3E85,
-    0x29A96929, 0x7D4F647D, 0x94812A94, 0x492ECE49, 0x17C6CB17, 0xCA692FCA,
-    0xC3BDFCC3, 0x5CA3975C, 0x5EE8055E, 0xD0ED7AD0, 0x87D1AC87, 0x8E057F8E,
-    0xBA64D5BA, 0xA8A51AA8, 0xB7264BB7, 0xB9BE0EB9, 0x6087A760, 0xF8D55AF8,
-    0x22362822, 0x111B1411, 0xDE753FDE, 0x79D92979, 0xAAEE88AA, 0x332D3C33,
-    0x5F794C5F, 0xB6B702B6, 0x96CAB896, 0x5835DA58, 0x9CC4B09C, 0xFC4317FC,
-    0x1A84551A, 0xF64D1FF6, 0x1C598A1C, 0x38B27D38, 0xAC3357AC, 0x18CFC718,
-    0xF4068DF4, 0x69537469, 0x749BB774, 0xF597C4F5, 0x56AD9F56, 0xDAE372DA,
-    0xD5EA7ED5, 0x4AF4154A, 0x9E8F229E, 0xA2AB12A2, 0x4E62584E, 0xE85F07E8,
-    0xE51D99E5, 0x39233439, 0xC1F66EC1, 0x446C5044, 0x5D32DE5D, 0x72466872,
-    0x26A06526, 0x93CDBC93, 0x03DADB03, 0xC6BAF8C6, 0xFA9EC8FA, 0x82D6A882,
-    0xCF6E2BCF, 0x50704050, 0xEB85DCEB, 0x750AFE75, 0x8A93328A, 0x8DDFA48D,
-    0x4C29CA4C, 0x141C1014, 0x73D72173, 0xCCB4F0CC, 0x09D4D309, 0x108A5D10,
-    0xE2510FE2, 0x00000000, 0x9A196F9A, 0xE01A9DE0, 0x8F94368F, 0xE6C742E6,
-    0xECC94AEC, 0xFDD25EFD, 0xAB7FC1AB, 0xD8A8E0D8}
-};
-
-/* The exp_to_poly and poly_to_exp tables are used to perform efficient
- * operations in GF(2^8) represented as GF(2)[x]/w(x) where
- * w(x)=x^8+x^6+x^3+x^2+1.  We care about doing that because it's part of the
- * definition of the RS matrix in the key schedule.  Elements of that field
- * are polynomials of degree not greater than 7 and all coefficients 0 or 1,
- * which can be represented naturally by bytes (just substitute x=2).  In that
- * form, GF(2^8) addition is the same as bitwise XOR, but GF(2^8)
- * multiplication is inefficient without hardware support.  To multiply
- * faster, I make use of the fact x is a generator for the nonzero elements,
- * so that every element p of GF(2)[x]/w(x) is either 0 or equal to (x)^n for
- * some n in 0..254.  Note that that caret is exponentiation in GF(2^8),
- * *not* polynomial notation.  So if I want to compute pq where p and q are
- * in GF(2^8), I can just say:
- *    1. if p=0 or q=0 then pq=0
- *    2. otherwise, find m and n such that p=x^m and q=x^n
- *    3. pq=(x^m)(x^n)=x^(m+n), so add m and n and find pq
- * The translations in steps 2 and 3 are looked up in the tables
- * poly_to_exp (for step 2) and exp_to_poly (for step 3).  To see this
- * in action, look at the CALC_S macro.  As additional wrinkles, note that
- * one of my operands is always a constant, so the poly_to_exp lookup on it
- * is done in advance; I included the original values in the comments so
- * readers can have some chance of recognizing that this *is* the RS matrix
- * from the Twofish paper.  I've only included the table entries I actually
- * need; I never do a lookup on a variable input of zero and the biggest
- * exponents I'll ever see are 254 (variable) and 237 (constant), so they'll
- * never sum to more than 491.	I'm repeating part of the exp_to_poly table
- * so that I don't have to do mod-255 reduction in the exponent arithmetic.
- * Since I know my constant operands are never zero, I only have to worry
- * about zero values in the variable operand, and I do it with a simple
- * conditional branch.	I know conditionals are expensive, but I couldn't
- * see a non-horrible way of avoiding them, and I did manage to group the
- * statements so that each if covers four group multiplications. */
-
-static const u8 poly_to_exp[255] = {
-   0x00, 0x01, 0x17, 0x02, 0x2E, 0x18, 0x53, 0x03, 0x6A, 0x2F, 0x93, 0x19,
-   0x34, 0x54, 0x45, 0x04, 0x5C, 0x6B, 0xB6, 0x30, 0xA6, 0x94, 0x4B, 0x1A,
-   0x8C, 0x35, 0x81, 0x55, 0xAA, 0x46, 0x0D, 0x05, 0x24, 0x5D, 0x87, 0x6C,
-   0x9B, 0xB7, 0xC1, 0x31, 0x2B, 0xA7, 0xA3, 0x95, 0x98, 0x4C, 0xCA, 0x1B,
-   0xE6, 0x8D, 0x73, 0x36, 0xCD, 0x82, 0x12, 0x56, 0x62, 0xAB, 0xF0, 0x47,
-   0x4F, 0x0E, 0xBD, 0x06, 0xD4, 0x25, 0xD2, 0x5E, 0x27, 0x88, 0x66, 0x6D,
-   0xD6, 0x9C, 0x79, 0xB8, 0x08, 0xC2, 0xDF, 0x32, 0x68, 0x2C, 0xFD, 0xA8,
-   0x8A, 0xA4, 0x5A, 0x96, 0x29, 0x99, 0x22, 0x4D, 0x60, 0xCB, 0xE4, 0x1C,
-   0x7B, 0xE7, 0x3B, 0x8E, 0x9E, 0x74, 0xF4, 0x37, 0xD8, 0xCE, 0xF9, 0x83,
-   0x6F, 0x13, 0xB2, 0x57, 0xE1, 0x63, 0xDC, 0xAC, 0xC4, 0xF1, 0xAF, 0x48,
-   0x0A, 0x50, 0x42, 0x0F, 0xBA, 0xBE, 0xC7, 0x07, 0xDE, 0xD5, 0x78, 0x26,
-   0x65, 0xD3, 0xD1, 0x5F, 0xE3, 0x28, 0x21, 0x89, 0x59, 0x67, 0xFC, 0x6E,
-   0xB1, 0xD7, 0xF8, 0x9D, 0xF3, 0x7A, 0x3A, 0xB9, 0xC6, 0x09, 0x41, 0xC3,
-   0xAE, 0xE0, 0xDB, 0x33, 0x44, 0x69, 0x92, 0x2D, 0x52, 0xFE, 0x16, 0xA9,
-   0x0C, 0x8B, 0x80, 0xA5, 0x4A, 0x5B, 0xB5, 0x97, 0xC9, 0x2A, 0xA2, 0x9A,
-   0xC0, 0x23, 0x86, 0x4E, 0xBC, 0x61, 0xEF, 0xCC, 0x11, 0xE5, 0x72, 0x1D,
-   0x3D, 0x7C, 0xEB, 0xE8, 0xE9, 0x3C, 0xEA, 0x8F, 0x7D, 0x9F, 0xEC, 0x75,
-   0x1E, 0xF5, 0x3E, 0x38, 0xF6, 0xD9, 0x3F, 0xCF, 0x76, 0xFA, 0x1F, 0x84,
-   0xA0, 0x70, 0xED, 0x14, 0x90, 0xB3, 0x7E, 0x58, 0xFB, 0xE2, 0x20, 0x64,
-   0xD0, 0xDD, 0x77, 0xAD, 0xDA, 0xC5, 0x40, 0xF2, 0x39, 0xB0, 0xF7, 0x49,
-   0xB4, 0x0B, 0x7F, 0x51, 0x15, 0x43, 0x91, 0x10, 0x71, 0xBB, 0xEE, 0xBF,
-   0x85, 0xC8, 0xA1
-};
-
-static const u8 exp_to_poly[492] = {
-   0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D, 0x9A, 0x79, 0xF2,
-   0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC, 0xF5, 0xA7, 0x03,
-   0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3, 0x8B, 0x5B, 0xB6,
-   0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52, 0xA4, 0x05, 0x0A,
-   0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0, 0xED, 0x97, 0x63,
-   0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1, 0x0F, 0x1E, 0x3C,
-   0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A, 0xF4, 0xA5, 0x07,
-   0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11, 0x22, 0x44, 0x88,
-   0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51, 0xA2, 0x09, 0x12,
-   0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66, 0xCC, 0xD5, 0xE7,
-   0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB, 0x1B, 0x36, 0x6C,
-   0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19, 0x32, 0x64, 0xC8,
-   0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D, 0x5A, 0xB4, 0x25,
-   0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56, 0xAC, 0x15, 0x2A,
-   0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE, 0x91, 0x6F, 0xDE,
-   0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9, 0x3F, 0x7E, 0xFC,
-   0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE, 0xB1, 0x2F, 0x5E,
-   0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41, 0x82, 0x49, 0x92,
-   0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E, 0x71, 0xE2, 0x89,
-   0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB, 0xDB, 0xFB, 0xBB,
-   0x3B, 0x76, 0xEC, 0x95, 0x67, 0xCE, 0xD1, 0xEF, 0x93, 0x6B, 0xD6, 0xE1,
-   0x8F, 0x53, 0xA6, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D,
-   0x9A, 0x79, 0xF2, 0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC,
-   0xF5, 0xA7, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3,
-   0x8B, 0x5B, 0xB6, 0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52,
-   0xA4, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0,
-   0xED, 0x97, 0x63, 0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1,
-   0x0F, 0x1E, 0x3C, 0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A,
-   0xF4, 0xA5, 0x07, 0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11,
-   0x22, 0x44, 0x88, 0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51,
-   0xA2, 0x09, 0x12, 0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66,
-   0xCC, 0xD5, 0xE7, 0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB,
-   0x1B, 0x36, 0x6C, 0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19,
-   0x32, 0x64, 0xC8, 0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D,
-   0x5A, 0xB4, 0x25, 0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56,
-   0xAC, 0x15, 0x2A, 0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE,
-   0x91, 0x6F, 0xDE, 0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9,
-   0x3F, 0x7E, 0xFC, 0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE,
-   0xB1, 0x2F, 0x5E, 0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41,
-   0x82, 0x49, 0x92, 0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E,
-   0x71, 0xE2, 0x89, 0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB
-};
-
-
-/* The table constants are indices of
- * S-box entries, preprocessed through q0 and q1. */
-static const u8 calc_sb_tbl[512] = {
-    0xA9, 0x75, 0x67, 0xF3, 0xB3, 0xC6, 0xE8, 0xF4,
-    0x04, 0xDB, 0xFD, 0x7B, 0xA3, 0xFB, 0x76, 0xC8,
-    0x9A, 0x4A, 0x92, 0xD3, 0x80, 0xE6, 0x78, 0x6B,
-    0xE4, 0x45, 0xDD, 0x7D, 0xD1, 0xE8, 0x38, 0x4B,
-    0x0D, 0xD6, 0xC6, 0x32, 0x35, 0xD8, 0x98, 0xFD,
-    0x18, 0x37, 0xF7, 0x71, 0xEC, 0xF1, 0x6C, 0xE1,
-    0x43, 0x30, 0x75, 0x0F, 0x37, 0xF8, 0x26, 0x1B,
-    0xFA, 0x87, 0x13, 0xFA, 0x94, 0x06, 0x48, 0x3F,
-    0xF2, 0x5E, 0xD0, 0xBA, 0x8B, 0xAE, 0x30, 0x5B,
-    0x84, 0x8A, 0x54, 0x00, 0xDF, 0xBC, 0x23, 0x9D,
-    0x19, 0x6D, 0x5B, 0xC1, 0x3D, 0xB1, 0x59, 0x0E,
-    0xF3, 0x80, 0xAE, 0x5D, 0xA2, 0xD2, 0x82, 0xD5,
-    0x63, 0xA0, 0x01, 0x84, 0x83, 0x07, 0x2E, 0x14,
-    0xD9, 0xB5, 0x51, 0x90, 0x9B, 0x2C, 0x7C, 0xA3,
-    0xA6, 0xB2, 0xEB, 0x73, 0xA5, 0x4C, 0xBE, 0x54,
-    0x16, 0x92, 0x0C, 0x74, 0xE3, 0x36, 0x61, 0x51,
-    0xC0, 0x38, 0x8C, 0xB0, 0x3A, 0xBD, 0xF5, 0x5A,
-    0x73, 0xFC, 0x2C, 0x60, 0x25, 0x62, 0x0B, 0x96,
-    0xBB, 0x6C, 0x4E, 0x42, 0x89, 0xF7, 0x6B, 0x10,
-    0x53, 0x7C, 0x6A, 0x28, 0xB4, 0x27, 0xF1, 0x8C,
-    0xE1, 0x13, 0xE6, 0x95, 0xBD, 0x9C, 0x45, 0xC7,
-    0xE2, 0x24, 0xF4, 0x46, 0xB6, 0x3B, 0x66, 0x70,
-    0xCC, 0xCA, 0x95, 0xE3, 0x03, 0x85, 0x56, 0xCB,
-    0xD4, 0x11, 0x1C, 0xD0, 0x1E, 0x93, 0xD7, 0xB8,
-    0xFB, 0xA6, 0xC3, 0x83, 0x8E, 0x20, 0xB5, 0xFF,
-    0xE9, 0x9F, 0xCF, 0x77, 0xBF, 0xC3, 0xBA, 0xCC,
-    0xEA, 0x03, 0x77, 0x6F, 0x39, 0x08, 0xAF, 0xBF,
-    0x33, 0x40, 0xC9, 0xE7, 0x62, 0x2B, 0x71, 0xE2,
-    0x81, 0x79, 0x79, 0x0C, 0x09, 0xAA, 0xAD, 0x82,
-    0x24, 0x41, 0xCD, 0x3A, 0xF9, 0xEA, 0xD8, 0xB9,
-    0xE5, 0xE4, 0xC5, 0x9A, 0xB9, 0xA4, 0x4D, 0x97,
-    0x44, 0x7E, 0x08, 0xDA, 0x86, 0x7A, 0xE7, 0x17,
-    0xA1, 0x66, 0x1D, 0x94, 0xAA, 0xA1, 0xED, 0x1D,
-    0x06, 0x3D, 0x70, 0xF0, 0xB2, 0xDE, 0xD2, 0xB3,
-    0x41, 0x0B, 0x7B, 0x72, 0xA0, 0xA7, 0x11, 0x1C,
-    0x31, 0xEF, 0xC2, 0xD1, 0x27, 0x53, 0x90, 0x3E,
-    0x20, 0x8F, 0xF6, 0x33, 0x60, 0x26, 0xFF, 0x5F,
-    0x96, 0xEC, 0x5C, 0x76, 0xB1, 0x2A, 0xAB, 0x49,
-    0x9E, 0x81, 0x9C, 0x88, 0x52, 0xEE, 0x1B, 0x21,
-    0x5F, 0xC4, 0x93, 0x1A, 0x0A, 0xEB, 0xEF, 0xD9,
-    0x91, 0xC5, 0x85, 0x39, 0x49, 0x99, 0xEE, 0xCD,
-    0x2D, 0xAD, 0x4F, 0x31, 0x8F, 0x8B, 0x3B, 0x01,
-    0x47, 0x18, 0x87, 0x23, 0x6D, 0xDD, 0x46, 0x1F,
-    0xD6, 0x4E, 0x3E, 0x2D, 0x69, 0xF9, 0x64, 0x48,
-    0x2A, 0x4F, 0xCE, 0xF2, 0xCB, 0x65, 0x2F, 0x8E,
-    0xFC, 0x78, 0x97, 0x5C, 0x05, 0x58, 0x7A, 0x19,
-    0xAC, 0x8D, 0x7F, 0xE5, 0xD5, 0x98, 0x1A, 0x57,
-    0x4B, 0x67, 0x0E, 0x7F, 0xA7, 0x05, 0x5A, 0x64,
-    0x28, 0xAF, 0x14, 0x63, 0x3F, 0xB6, 0x29, 0xFE,
-    0x88, 0xF5, 0x3C, 0xB7, 0x4C, 0x3C, 0x02, 0xA5,
-    0xB8, 0xCE, 0xDA, 0xE9, 0xB0, 0x68, 0x17, 0x44,
-    0x55, 0xE0, 0x1F, 0x4D, 0x8A, 0x43, 0x7D, 0x69,
-    0x57, 0x29, 0xC7, 0x2E, 0x8D, 0xAC, 0x74, 0x15,
-    0xB7, 0x59, 0xC4, 0xA8, 0x9F, 0x0A, 0x72, 0x9E,
-    0x7E, 0x6E, 0x15, 0x47, 0x22, 0xDF, 0x12, 0x34,
-    0x58, 0x35, 0x07, 0x6A, 0x99, 0xCF, 0x34, 0xDC,
-    0x6E, 0x22, 0x50, 0xC9, 0xDE, 0xC0, 0x68, 0x9B,
-    0x65, 0x89, 0xBC, 0xD4, 0xDB, 0xED, 0xF8, 0xAB,
-    0xC8, 0x12, 0xA8, 0xA2, 0x2B, 0x0D, 0x40, 0x52,
-    0xDC, 0xBB, 0xFE, 0x02, 0x32, 0x2F, 0xA4, 0xA9,
-    0xCA, 0xD7, 0x10, 0x61, 0x21, 0x1E, 0xF0, 0xB4,
-    0xD3, 0x50, 0x5D, 0x04, 0x0F, 0xF6, 0x00, 0xC2,
-    0x6F, 0x16, 0x9D, 0x25, 0x36, 0x86, 0x42, 0x56,
-    0x4A, 0x55, 0x5E, 0x09, 0xC1, 0xBE, 0xE0, 0x91
-};
-
-/* Macro to perform one column of the RS matrix multiplication.  The
- * parameters a, b, c, and d are the four bytes of output; i is the index
- * of the key bytes, and w, x, y, and z, are the column of constants from
- * the RS matrix, preprocessed through the poly_to_exp table. */
-
-#define CALC_S(a, b, c, d, i, w, x, y, z) \
-   if (key[i]) { \
-      tmp = poly_to_exp[key[i] - 1]; \
-      (a) ^= exp_to_poly[tmp + (w)]; \
-      (b) ^= exp_to_poly[tmp + (x)]; \
-      (c) ^= exp_to_poly[tmp + (y)]; \
-      (d) ^= exp_to_poly[tmp + (z)]; \
-   }
-
-/* Macros to calculate the key-dependent S-boxes for a 128-bit key using
- * the S vector from CALC_S.  CALC_SB_2 computes a single entry in all
- * four S-boxes, where i is the index of the entry to compute, and a and b
- * are the index numbers preprocessed through the q0 and q1 tables
- * respectively. */
-
-#define CALC_SB_2(i, a, b) \
-   ctx-&gt;s[0][i] = mds[0][q0[(a) ^ sa] ^ se]; \
-   ctx-&gt;s[1][i] = mds[1][q0[(b) ^ sb] ^ sf]; \
-   ctx-&gt;s[2][i] = mds[2][q1[(a) ^ sc] ^ sg]; \
-   ctx-&gt;s[3][i] = mds[3][q1[(b) ^ sd] ^ sh]
-
-/* Macro exactly like CALC_SB_2, but for 192-bit keys. */
-
-#define CALC_SB192_2(i, a, b) \
-   ctx-&gt;s[0][i] = mds[0][q0[q0[(b) ^ sa] ^ se] ^ si]; \
-   ctx-&gt;s[1][i] = mds[1][q0[q1[(b) ^ sb] ^ sf] ^ sj]; \
-   ctx-&gt;s[2][i] = mds[2][q1[q0[(a) ^ sc] ^ sg] ^ sk]; \
-   ctx-&gt;s[3][i] = mds[3][q1[q1[(a) ^ sd] ^ sh] ^ sl];
-
-/* Macro exactly like CALC_SB_2, but for 256-bit keys. */
-
-#define CALC_SB256_2(i, a, b) \
-   ctx-&gt;s[0][i] = mds[0][q0[q0[q1[(b) ^ sa] ^ se] ^ si] ^ sm]; \
-   ctx-&gt;s[1][i] = mds[1][q0[q1[q1[(a) ^ sb] ^ sf] ^ sj] ^ sn]; \
-   ctx-&gt;s[2][i] = mds[2][q1[q0[q0[(a) ^ sc] ^ sg] ^ sk] ^ so]; \
-   ctx-&gt;s[3][i] = mds[3][q1[q1[q0[(b) ^ sd] ^ sh] ^ sl] ^ sp];
-
-/* Macros to calculate the whitening and round subkeys.  CALC_K_2 computes the
- * last two stages of the h() function for a given index (either 2i or 2i+1).
- * a, b, c, and d are the four bytes going into the last two stages.  For
- * 128-bit keys, this is the entire h() function and a and c are the index
- * preprocessed through q0 and q1 respectively; for longer keys they are the
- * output of previous stages.  j is the index of the first key byte to use.
- * CALC_K computes a pair of subkeys for 128-bit Twofish, by calling CALC_K_2
- * twice, doing the Pseudo-Hadamard Transform, and doing the necessary
- * rotations.  Its parameters are: a, the array to write the results into,
- * j, the index of the first output entry, k and l, the preprocessed indices
- * for index 2i, and m and n, the preprocessed indices for index 2i+1.
- * CALC_K192_2 expands CALC_K_2 to handle 192-bit keys, by doing an
- * additional lookup-and-XOR stage.  The parameters a, b, c and d are the
- * four bytes going into the last three stages.  For 192-bit keys, c = d
- * are the index preprocessed through q0, and a = b are the index
- * preprocessed through q1; j is the index of the first key byte to use.
- * CALC_K192 is identical to CALC_K but for using the CALC_K192_2 macro
- * instead of CALC_K_2.
- * CALC_K256_2 expands CALC_K192_2 to handle 256-bit keys, by doing an
- * additional lookup-and-XOR stage.  The parameters a and b are the index
- * preprocessed through q0 and q1 respectively; j is the index of the first
- * key byte to use.  CALC_K256 is identical to CALC_K but for using the
- * CALC_K256_2 macro instead of CALC_K_2. */
-
-#define CALC_K_2(a, b, c, d, j) \
-     mds[0][q0[a ^ key[(j) + 8]] ^ key[j]] \
-   ^ mds[1][q0[b ^ key[(j) + 9]] ^ key[(j) + 1]] \
-   ^ mds[2][q1[c ^ key[(j) + 10]] ^ key[(j) + 2]] \
-   ^ mds[3][q1[d ^ key[(j) + 11]] ^ key[(j) + 3]]
-
-#define CALC_K(a, j, k, l, m, n) \
-   x = CALC_K_2 (k, l, k, l, 0); \
-   y = CALC_K_2 (m, n, m, n, 4); \
-   y = rol32(y, 8); \
-   x += y; y += x; ctx-&gt;a[j] = x; \
-   ctx-&gt;a[(j) + 1] = rol32(y, 9)
-
-#define CALC_K192_2(a, b, c, d, j) \
-   CALC_K_2 (q0[a ^ key[(j) + 16]], \
-	     q1[b ^ key[(j) + 17]], \
-	     q0[c ^ key[(j) + 18]], \
-	     q1[d ^ key[(j) + 19]], j)
-
-#define CALC_K192(a, j, k, l, m, n) \
-   x = CALC_K192_2 (l, l, k, k, 0); \
-   y = CALC_K192_2 (n, n, m, m, 4); \
-   y = rol32(y, 8); \
-   x += y; y += x; ctx-&gt;a[j] = x; \
-   ctx-&gt;a[(j) + 1] = rol32(y, 9)
-
-#define CALC_K256_2(a, b, j) \
-   CALC_K192_2 (q1[b ^ key[(j) + 24]], \
-	        q1[a ^ key[(j) + 25]], \
-	        q0[a ^ key[(j) + 26]], \
-	        q0[b ^ key[(j) + 27]], j)
-
-#define CALC_K256(a, j, k, l, m, n) \
-   x = CALC_K256_2 (k, l, 0); \
-   y = CALC_K256_2 (m, n, 4); \
-   y = rol32(y, 8); \
-   x += y; y += x; ctx-&gt;a[j] = x; \
-   ctx-&gt;a[(j) + 1] = rol32(y, 9)
-
+#include &lt;crypto/twofish.h&gt;
 
 /* Macros to compute the g() function in the encryption and decryption
  * rounds.  G1 is the straight g() function; G2 includes the 8-bit
@@ -630,176 +103,7 @@ #define OUTUNPACK(n, x, m) \
    x ^= ctx-&gt;w[m]; \
    dst[n] = cpu_to_le32(x)
 
-#define TF_MIN_KEY_SIZE 16
-#define TF_MAX_KEY_SIZE 32
-#define TF_BLOCK_SIZE 16
-
-/* Structure for an expanded Twofish key.  s contains the key-dependent
- * S-boxes composed with the MDS matrix; w contains the eight "whitening"
- * subkeys, K[0] through K[7].	k holds the remaining, "round" subkeys.  Note
- * that k[i] corresponds to what the Twofish paper calls K[i+8]. */
-struct twofish_ctx {
-   u32 s[4][256], w[8], k[32];
-};
-
-/* Perform the key setup. */
-static int twofish_setkey(struct crypto_tfm *tfm, const u8 *key,
-			  unsigned int key_len, u32 *flags)
-{
-	
-	struct twofish_ctx *ctx = crypto_tfm_ctx(tfm);
 
-	int i, j, k;
-
-	/* Temporaries for CALC_K. */
-	u32 x, y;
-
-	/* The S vector used to key the S-boxes, split up into individual bytes.
-	 * 128-bit keys use only sa through sh; 256-bit use all of them. */
-	u8 sa = 0, sb = 0, sc = 0, sd = 0, se = 0, sf = 0, sg = 0, sh = 0;
-	u8 si = 0, sj = 0, sk = 0, sl = 0, sm = 0, sn = 0, so = 0, sp = 0;
-
-	/* Temporary for CALC_S. */
-	u8 tmp;
-
-	/* Check key length. */
-	if (key_len != 16 &amp;&amp; key_len != 24 &amp;&amp; key_len != 32)
-	{
-		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
-		return -EINVAL; /* unsupported key length */
-	}
-
-	/* Compute the first two words of the S vector.  The magic numbers are
-	 * the entries of the RS matrix, preprocessed through poly_to_exp. The
-	 * numbers in the comments are the original (polynomial form) matrix
-	 * entries. */
-	CALC_S (sa, sb, sc, sd, 0, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-	CALC_S (sa, sb, sc, sd, 1, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-	CALC_S (sa, sb, sc, sd, 2, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-	CALC_S (sa, sb, sc, sd, 3, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-	CALC_S (sa, sb, sc, sd, 4, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-	CALC_S (sa, sb, sc, sd, 5, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-	CALC_S (sa, sb, sc, sd, 6, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-	CALC_S (sa, sb, sc, sd, 7, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-	CALC_S (se, sf, sg, sh, 8, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-	CALC_S (se, sf, sg, sh, 9, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-	CALC_S (se, sf, sg, sh, 10, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-	CALC_S (se, sf, sg, sh, 11, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-	CALC_S (se, sf, sg, sh, 12, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-	CALC_S (se, sf, sg, sh, 13, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-	CALC_S (se, sf, sg, sh, 14, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-	CALC_S (se, sf, sg, sh, 15, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-
-	if (key_len == 24 || key_len == 32) { /* 192- or 256-bit key */
-		/* Calculate the third word of the S vector */
-		CALC_S (si, sj, sk, sl, 16, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-		CALC_S (si, sj, sk, sl, 17, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-		CALC_S (si, sj, sk, sl, 18, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-		CALC_S (si, sj, sk, sl, 19, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-		CALC_S (si, sj, sk, sl, 20, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-		CALC_S (si, sj, sk, sl, 21, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-		CALC_S (si, sj, sk, sl, 22, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-		CALC_S (si, sj, sk, sl, 23, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-	}
-
-	if (key_len == 32) { /* 256-bit key */
-		/* Calculate the fourth word of the S vector */
-		CALC_S (sm, sn, so, sp, 24, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
-		CALC_S (sm, sn, so, sp, 25, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
-		CALC_S (sm, sn, so, sp, 26, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
-		CALC_S (sm, sn, so, sp, 27, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
-		CALC_S (sm, sn, so, sp, 28, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
-		CALC_S (sm, sn, so, sp, 29, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
-		CALC_S (sm, sn, so, sp, 30, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
-		CALC_S (sm, sn, so, sp, 31, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
-
-		/* Compute the S-boxes. */
-		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
-			CALC_SB256_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
-		}
-
-		/* Calculate whitening and round subkeys.  The constants are
-		 * indices of subkeys, preprocessed through q0 and q1. */
-		CALC_K256 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
-		CALC_K256 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
-		CALC_K256 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
-		CALC_K256 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
-		CALC_K256 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
-		CALC_K256 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
-		CALC_K256 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
-		CALC_K256 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
-		CALC_K256 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
-		CALC_K256 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
-		CALC_K256 (k, 12, 0x18, 0x37, 0xF7, 0x71);
-		CALC_K256 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
-		CALC_K256 (k, 16, 0x43, 0x30, 0x75, 0x0F);
-		CALC_K256 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
-		CALC_K256 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
-		CALC_K256 (k, 22, 0x94, 0x06, 0x48, 0x3F);
-		CALC_K256 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
-		CALC_K256 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
-		CALC_K256 (k, 28, 0x84, 0x8A, 0x54, 0x00);
-		CALC_K256 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
-	} else if (key_len == 24) { /* 192-bit key */
-		/* Compute the S-boxes. */
-		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
-		        CALC_SB192_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
-		}
-
-		/* Calculate whitening and round subkeys.  The constants are
-		 * indices of subkeys, preprocessed through q0 and q1. */
-		CALC_K192 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
-		CALC_K192 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
-		CALC_K192 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
-		CALC_K192 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
-		CALC_K192 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
-		CALC_K192 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
-		CALC_K192 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
-		CALC_K192 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
-		CALC_K192 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
-		CALC_K192 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
-		CALC_K192 (k, 12, 0x18, 0x37, 0xF7, 0x71);
-		CALC_K192 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
-		CALC_K192 (k, 16, 0x43, 0x30, 0x75, 0x0F);
-		CALC_K192 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
-		CALC_K192 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
-		CALC_K192 (k, 22, 0x94, 0x06, 0x48, 0x3F);
-		CALC_K192 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
-		CALC_K192 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
-		CALC_K192 (k, 28, 0x84, 0x8A, 0x54, 0x00);
-		CALC_K192 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
-	} else { /* 128-bit key */
-		/* Compute the S-boxes. */
-		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
-			CALC_SB_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
-		}
-
-		/* Calculate whitening and round subkeys.  The constants are
-		 * indices of subkeys, preprocessed through q0 and q1. */
-		CALC_K (w, 0, 0xA9, 0x75, 0x67, 0xF3);
-		CALC_K (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
-		CALC_K (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
-		CALC_K (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
-		CALC_K (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
-		CALC_K (k, 2, 0x80, 0xE6, 0x78, 0x6B);
-		CALC_K (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
-		CALC_K (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
-		CALC_K (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
-		CALC_K (k, 10, 0x35, 0xD8, 0x98, 0xFD);
-		CALC_K (k, 12, 0x18, 0x37, 0xF7, 0x71);
-		CALC_K (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
-		CALC_K (k, 16, 0x43, 0x30, 0x75, 0x0F);
-		CALC_K (k, 18, 0x37, 0xF8, 0x26, 0x1B);
-		CALC_K (k, 20, 0xFA, 0x87, 0x13, 0xFA);
-		CALC_K (k, 22, 0x94, 0x06, 0x48, 0x3F);
-		CALC_K (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
-		CALC_K (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
-		CALC_K (k, 28, 0x84, 0x8A, 0x54, 0x00);
-		CALC_K (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
-	}
-
-	return 0;
-}
 
 /* Encrypt one block.  in and out may be the same. */
 static void twofish_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
diff --git a/crypto/twofish_common.c b/crypto/twofish_common.c
new file mode 100644
index 0000000..4b6dec0
--- /dev/null
+++ b/crypto/twofish_common.c
@@ -0,0 +1,742 @@
+/*
+ * Common Twofish algorithm parts shared between the c and assembler
+ * implementations
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors 
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+
+/* The large precomputed tables for the Twofish cipher (twofish.c)
+ * Taken from the same source as twofish.c
+ * Marc Mutz &lt;Marc@Mutz.com&gt;
+ */
+
+/* These two tables are the q0 and q1 permutations, exactly as described in
+ * the Twofish paper. */
+
+static const u8 q0[256] = {
+	0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78,
+	0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C,
+	0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30,
+	0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82,
+	0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE,
+	0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B,
+	0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45,
+	0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7,
+	0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF,
+	0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8,
+	0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED,
+	0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90,
+	0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B,
+	0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B,
+	0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F,
+	0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A,
+	0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17,
+	0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72,
+	0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68,
+	0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4,
+	0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42,
+	0x4A, 0x5E, 0xC1, 0xE0
+};
+
+static const u8 q1[256] = {
+	0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B,
+	0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1,
+	0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B,
+	0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5,
+	0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54,
+	0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96,
+	0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7,
+	0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8,
+	0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF,
+	0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9,
+	0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D,
+	0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E,
+	0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21,
+	0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01,
+	0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E,
+	0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64,
+	0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44,
+	0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E,
+	0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B,
+	0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9,
+	0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56,
+	0x55, 0x09, 0xBE, 0x91
+};
+
+/* These MDS tables are actually tables of MDS composed with q0 and q1,
+ * because it is only ever used that way and we can save some time by
+ * precomputing.  Of course the main saving comes from precomputing the
+ * GF(2^8) multiplication involved in the MDS matrix multiply; by looking
+ * things up in these tables we reduce the matrix multiply to four lookups
+ * and three XORs.  Semi-formally, the definition of these tables is:
+ * mds[0][i] = MDS (q1[i] 0 0 0)^T  mds[1][i] = MDS (0 q0[i] 0 0)^T
+ * mds[2][i] = MDS (0 0 q1[i] 0)^T  mds[3][i] = MDS (0 0 0 q0[i])^T
+ * where ^T means "transpose", the matrix multiply is performed in GF(2^8)
+ * represented as GF(2)[x]/v(x) where v(x)=x^8+x^6+x^5+x^3+1 as described
+ * by Schneier et al, and I'm casually glossing over the byte/word
+ * conversion issues. */
+
+static const u32 mds[4][256] = {
+	{
+	0xBCBC3275, 0xECEC21F3, 0x202043C6, 0xB3B3C9F4, 0xDADA03DB, 0x02028B7B,
+	0xE2E22BFB, 0x9E9EFAC8, 0xC9C9EC4A, 0xD4D409D3, 0x18186BE6, 0x1E1E9F6B,
+	0x98980E45, 0xB2B2387D, 0xA6A6D2E8, 0x2626B74B, 0x3C3C57D6, 0x93938A32,
+	0x8282EED8, 0x525298FD, 0x7B7BD437, 0xBBBB3771, 0x5B5B97F1, 0x474783E1,
+	0x24243C30, 0x5151E20F, 0xBABAC6F8, 0x4A4AF31B, 0xBFBF4887, 0x0D0D70FA,
+	0xB0B0B306, 0x7575DE3F, 0xD2D2FD5E, 0x7D7D20BA, 0x666631AE, 0x3A3AA35B,
+	0x59591C8A, 0x00000000, 0xCDCD93BC, 0x1A1AE09D, 0xAEAE2C6D, 0x7F7FABC1,
+	0x2B2BC7B1, 0xBEBEB90E, 0xE0E0A080, 0x8A8A105D, 0x3B3B52D2, 0x6464BAD5,
+	0xD8D888A0, 0xE7E7A584, 0x5F5FE807, 0x1B1B1114, 0x2C2CC2B5, 0xFCFCB490,
+	0x3131272C, 0x808065A3, 0x73732AB2, 0x0C0C8173, 0x79795F4C, 0x6B6B4154,
+	0x4B4B0292, 0x53536974, 0x94948F36, 0x83831F51, 0x2A2A3638, 0xC4C49CB0,
+	0x2222C8BD, 0xD5D5F85A, 0xBDBDC3FC, 0x48487860, 0xFFFFCE62, 0x4C4C0796,
+	0x4141776C, 0xC7C7E642, 0xEBEB24F7, 0x1C1C1410, 0x5D5D637C, 0x36362228,
+	0x6767C027, 0xE9E9AF8C, 0x4444F913, 0x1414EA95, 0xF5F5BB9C, 0xCFCF18C7,
+	0x3F3F2D24, 0xC0C0E346, 0x7272DB3B, 0x54546C70, 0x29294CCA, 0xF0F035E3,
+	0x0808FE85, 0xC6C617CB, 0xF3F34F11, 0x8C8CE4D0, 0xA4A45993, 0xCACA96B8,
+	0x68683BA6, 0xB8B84D83, 0x38382820, 0xE5E52EFF, 0xADAD569F, 0x0B0B8477,
+	0xC8C81DC3, 0x9999FFCC, 0x5858ED03, 0x19199A6F, 0x0E0E0A08, 0x95957EBF,
+	0x70705040, 0xF7F730E7, 0x6E6ECF2B, 0x1F1F6EE2, 0xB5B53D79, 0x09090F0C,
+	0x616134AA, 0x57571682, 0x9F9F0B41, 0x9D9D803A, 0x111164EA, 0x2525CDB9,
+	0xAFAFDDE4, 0x4545089A, 0xDFDF8DA4, 0xA3A35C97, 0xEAEAD57E, 0x353558DA,
+	0xEDEDD07A, 0x4343FC17, 0xF8F8CB66, 0xFBFBB194, 0x3737D3A1, 0xFAFA401D,
+	0xC2C2683D, 0xB4B4CCF0, 0x32325DDE, 0x9C9C71B3, 0x5656E70B, 0xE3E3DA72,
+	0x878760A7, 0x15151B1C, 0xF9F93AEF, 0x6363BFD1, 0x3434A953, 0x9A9A853E,
+	0xB1B1428F, 0x7C7CD133, 0x88889B26, 0x3D3DA65F, 0xA1A1D7EC, 0xE4E4DF76,
+	0x8181942A, 0x91910149, 0x0F0FFB81, 0xEEEEAA88, 0x161661EE, 0xD7D77321,
+	0x9797F5C4, 0xA5A5A81A, 0xFEFE3FEB, 0x6D6DB5D9, 0x7878AEC5, 0xC5C56D39,
+	0x1D1DE599, 0x7676A4CD, 0x3E3EDCAD, 0xCBCB6731, 0xB6B6478B, 0xEFEF5B01,
+	0x12121E18, 0x6060C523, 0x6A6AB0DD, 0x4D4DF61F, 0xCECEE94E, 0xDEDE7C2D,
+	0x55559DF9, 0x7E7E5A48, 0x2121B24F, 0x03037AF2, 0xA0A02665, 0x5E5E198E,
+	0x5A5A6678, 0x65654B5C, 0x62624E58, 0xFDFD4519, 0x0606F48D, 0x404086E5,
+	0xF2F2BE98, 0x3333AC57, 0x17179067, 0x05058E7F, 0xE8E85E05, 0x4F4F7D64,
+	0x89896AAF, 0x10109563, 0x74742FB6, 0x0A0A75FE, 0x5C5C92F5, 0x9B9B74B7,
+	0x2D2D333C, 0x3030D6A5, 0x2E2E49CE, 0x494989E9, 0x46467268, 0x77775544,
+	0xA8A8D8E0, 0x9696044D, 0x2828BD43, 0xA9A92969, 0xD9D97929, 0x8686912E,
+	0xD1D187AC, 0xF4F44A15, 0x8D8D1559, 0xD6D682A8, 0xB9B9BC0A, 0x42420D9E,
+	0xF6F6C16E, 0x2F2FB847, 0xDDDD06DF, 0x23233934, 0xCCCC6235, 0xF1F1C46A,
+	0xC1C112CF, 0x8585EBDC, 0x8F8F9E22, 0x7171A1C9, 0x9090F0C0, 0xAAAA539B,
+	0x0101F189, 0x8B8BE1D4, 0x4E4E8CED, 0x8E8E6FAB, 0xABABA212, 0x6F6F3EA2,
+	0xE6E6540D, 0xDBDBF252, 0x92927BBB, 0xB7B7B602, 0x6969CA2F, 0x3939D9A9,
+	0xD3D30CD7, 0xA7A72361, 0xA2A2AD1E, 0xC3C399B4, 0x6C6C4450, 0x07070504,
+	0x04047FF6, 0x272746C2, 0xACACA716, 0xD0D07625, 0x50501386, 0xDCDCF756,
+	0x84841A55, 0xE1E15109, 0x7A7A25BE, 0x1313EF91},
+
+	{
+	0xA9D93939, 0x67901717, 0xB3719C9C, 0xE8D2A6A6, 0x04050707, 0xFD985252,
+	0xA3658080, 0x76DFE4E4, 0x9A084545, 0x92024B4B, 0x80A0E0E0, 0x78665A5A,
+	0xE4DDAFAF, 0xDDB06A6A, 0xD1BF6363, 0x38362A2A, 0x0D54E6E6, 0xC6432020,
+	0x3562CCCC, 0x98BEF2F2, 0x181E1212, 0xF724EBEB, 0xECD7A1A1, 0x6C774141,
+	0x43BD2828, 0x7532BCBC, 0x37D47B7B, 0x269B8888, 0xFA700D0D, 0x13F94444,
+	0x94B1FBFB, 0x485A7E7E, 0xF27A0303, 0xD0E48C8C, 0x8B47B6B6, 0x303C2424,
+	0x84A5E7E7, 0x54416B6B, 0xDF06DDDD, 0x23C56060, 0x1945FDFD, 0x5BA33A3A,
+	0x3D68C2C2, 0x59158D8D, 0xF321ECEC, 0xAE316666, 0xA23E6F6F, 0x82165757,
+	0x63951010, 0x015BEFEF, 0x834DB8B8, 0x2E918686, 0xD9B56D6D, 0x511F8383,
+	0x9B53AAAA, 0x7C635D5D, 0xA63B6868, 0xEB3FFEFE, 0xA5D63030, 0xBE257A7A,
+	0x16A7ACAC, 0x0C0F0909, 0xE335F0F0, 0x6123A7A7, 0xC0F09090, 0x8CAFE9E9,
+	0x3A809D9D, 0xF5925C5C, 0x73810C0C, 0x2C273131, 0x2576D0D0, 0x0BE75656,
+	0xBB7B9292, 0x4EE9CECE, 0x89F10101, 0x6B9F1E1E, 0x53A93434, 0x6AC4F1F1,
+	0xB499C3C3, 0xF1975B5B, 0xE1834747, 0xE66B1818, 0xBDC82222, 0x450E9898,
+	0xE26E1F1F, 0xF4C9B3B3, 0xB62F7474, 0x66CBF8F8, 0xCCFF9999, 0x95EA1414,
+	0x03ED5858, 0x56F7DCDC, 0xD4E18B8B, 0x1C1B1515, 0x1EADA2A2, 0xD70CD3D3,
+	0xFB2BE2E2, 0xC31DC8C8, 0x8E195E5E, 0xB5C22C2C, 0xE9894949, 0xCF12C1C1,
+	0xBF7E9595, 0xBA207D7D, 0xEA641111, 0x77840B0B, 0x396DC5C5, 0xAF6A8989,
+	0x33D17C7C, 0xC9A17171, 0x62CEFFFF, 0x7137BBBB, 0x81FB0F0F, 0x793DB5B5,
+	0x0951E1E1, 0xADDC3E3E, 0x242D3F3F, 0xCDA47676, 0xF99D5555, 0xD8EE8282,
+	0xE5864040, 0xC5AE7878, 0xB9CD2525, 0x4D049696, 0x44557777, 0x080A0E0E,
+	0x86135050, 0xE730F7F7, 0xA1D33737, 0x1D40FAFA, 0xAA346161, 0xED8C4E4E,
+	0x06B3B0B0, 0x706C5454, 0xB22A7373, 0xD2523B3B, 0x410B9F9F, 0x7B8B0202,
+	0xA088D8D8, 0x114FF3F3, 0x3167CBCB, 0xC2462727, 0x27C06767, 0x90B4FCFC,
+	0x20283838, 0xF67F0404, 0x60784848, 0xFF2EE5E5, 0x96074C4C, 0x5C4B6565,
+	0xB1C72B2B, 0xAB6F8E8E, 0x9E0D4242, 0x9CBBF5F5, 0x52F2DBDB, 0x1BF34A4A,
+	0x5FA63D3D, 0x9359A4A4, 0x0ABCB9B9, 0xEF3AF9F9, 0x91EF1313, 0x85FE0808,
+	0x49019191, 0xEE611616, 0x2D7CDEDE, 0x4FB22121, 0x8F42B1B1, 0x3BDB7272,
+	0x47B82F2F, 0x8748BFBF, 0x6D2CAEAE, 0x46E3C0C0, 0xD6573C3C, 0x3E859A9A,
+	0x6929A9A9, 0x647D4F4F, 0x2A948181, 0xCE492E2E, 0xCB17C6C6, 0x2FCA6969,
+	0xFCC3BDBD, 0x975CA3A3, 0x055EE8E8, 0x7AD0EDED, 0xAC87D1D1, 0x7F8E0505,
+	0xD5BA6464, 0x1AA8A5A5, 0x4BB72626, 0x0EB9BEBE, 0xA7608787, 0x5AF8D5D5,
+	0x28223636, 0x14111B1B, 0x3FDE7575, 0x2979D9D9, 0x88AAEEEE, 0x3C332D2D,
+	0x4C5F7979, 0x02B6B7B7, 0xB896CACA, 0xDA583535, 0xB09CC4C4, 0x17FC4343,
+	0x551A8484, 0x1FF64D4D, 0x8A1C5959, 0x7D38B2B2, 0x57AC3333, 0xC718CFCF,
+	0x8DF40606, 0x74695353, 0xB7749B9B, 0xC4F59797, 0x9F56ADAD, 0x72DAE3E3,
+	0x7ED5EAEA, 0x154AF4F4, 0x229E8F8F, 0x12A2ABAB, 0x584E6262, 0x07E85F5F,
+	0x99E51D1D, 0x34392323, 0x6EC1F6F6, 0x50446C6C, 0xDE5D3232, 0x68724646,
+	0x6526A0A0, 0xBC93CDCD, 0xDB03DADA, 0xF8C6BABA, 0xC8FA9E9E, 0xA882D6D6,
+	0x2BCF6E6E, 0x40507070, 0xDCEB8585, 0xFE750A0A, 0x328A9393, 0xA48DDFDF,
+	0xCA4C2929, 0x10141C1C, 0x2173D7D7, 0xF0CCB4B4, 0xD309D4D4, 0x5D108A8A,
+	0x0FE25151, 0x00000000, 0x6F9A1919, 0x9DE01A1A, 0x368F9494, 0x42E6C7C7,
+	0x4AECC9C9, 0x5EFDD2D2, 0xC1AB7F7F, 0xE0D8A8A8},
+
+	{
+	0xBC75BC32, 0xECF3EC21, 0x20C62043, 0xB3F4B3C9, 0xDADBDA03, 0x027B028B,
+	0xE2FBE22B, 0x9EC89EFA, 0xC94AC9EC, 0xD4D3D409, 0x18E6186B, 0x1E6B1E9F,
+	0x9845980E, 0xB27DB238, 0xA6E8A6D2, 0x264B26B7, 0x3CD63C57, 0x9332938A,
+	0x82D882EE, 0x52FD5298, 0x7B377BD4, 0xBB71BB37, 0x5BF15B97, 0x47E14783,
+	0x2430243C, 0x510F51E2, 0xBAF8BAC6, 0x4A1B4AF3, 0xBF87BF48, 0x0DFA0D70,
+	0xB006B0B3, 0x753F75DE, 0xD25ED2FD, 0x7DBA7D20, 0x66AE6631, 0x3A5B3AA3,
+	0x598A591C, 0x00000000, 0xCDBCCD93, 0x1A9D1AE0, 0xAE6DAE2C, 0x7FC17FAB,
+	0x2BB12BC7, 0xBE0EBEB9, 0xE080E0A0, 0x8A5D8A10, 0x3BD23B52, 0x64D564BA,
+	0xD8A0D888, 0xE784E7A5, 0x5F075FE8, 0x1B141B11, 0x2CB52CC2, 0xFC90FCB4,
+	0x312C3127, 0x80A38065, 0x73B2732A, 0x0C730C81, 0x794C795F, 0x6B546B41,
+	0x4B924B02, 0x53745369, 0x9436948F, 0x8351831F, 0x2A382A36, 0xC4B0C49C,
+	0x22BD22C8, 0xD55AD5F8, 0xBDFCBDC3, 0x48604878, 0xFF62FFCE, 0x4C964C07,
+	0x416C4177, 0xC742C7E6, 0xEBF7EB24, 0x1C101C14, 0x5D7C5D63, 0x36283622,
+	0x672767C0, 0xE98CE9AF, 0x441344F9, 0x149514EA, 0xF59CF5BB, 0xCFC7CF18,
+	0x3F243F2D, 0xC046C0E3, 0x723B72DB, 0x5470546C, 0x29CA294C, 0xF0E3F035,
+	0x088508FE, 0xC6CBC617, 0xF311F34F, 0x8CD08CE4, 0xA493A459, 0xCAB8CA96,
+	0x68A6683B, 0xB883B84D, 0x38203828, 0xE5FFE52E, 0xAD9FAD56, 0x0B770B84,
+	0xC8C3C81D, 0x99CC99FF, 0x580358ED, 0x196F199A, 0x0E080E0A, 0x95BF957E,
+	0x70407050, 0xF7E7F730, 0x6E2B6ECF, 0x1FE21F6E, 0xB579B53D, 0x090C090F,
+	0x61AA6134, 0x57825716, 0x9F419F0B, 0x9D3A9D80, 0x11EA1164, 0x25B925CD,
+	0xAFE4AFDD, 0x459A4508, 0xDFA4DF8D, 0xA397A35C, 0xEA7EEAD5, 0x35DA3558,
+	0xED7AEDD0, 0x431743FC, 0xF866F8CB, 0xFB94FBB1, 0x37A137D3, 0xFA1DFA40,
+	0xC23DC268, 0xB4F0B4CC, 0x32DE325D, 0x9CB39C71, 0x560B56E7, 0xE372E3DA,
+	0x87A78760, 0x151C151B, 0xF9EFF93A, 0x63D163BF, 0x345334A9, 0x9A3E9A85,
+	0xB18FB142, 0x7C337CD1, 0x8826889B, 0x3D5F3DA6, 0xA1ECA1D7, 0xE476E4DF,
+	0x812A8194, 0x91499101, 0x0F810FFB, 0xEE88EEAA, 0x16EE1661, 0xD721D773,
+	0x97C497F5, 0xA51AA5A8, 0xFEEBFE3F, 0x6DD96DB5, 0x78C578AE, 0xC539C56D,
+	0x1D991DE5, 0x76CD76A4, 0x3EAD3EDC, 0xCB31CB67, 0xB68BB647, 0xEF01EF5B,
+	0x1218121E, 0x602360C5, 0x6ADD6AB0, 0x4D1F4DF6, 0xCE4ECEE9, 0xDE2DDE7C,
+	0x55F9559D, 0x7E487E5A, 0x214F21B2, 0x03F2037A, 0xA065A026, 0x5E8E5E19,
+	0x5A785A66, 0x655C654B, 0x6258624E, 0xFD19FD45, 0x068D06F4, 0x40E54086,
+	0xF298F2BE, 0x335733AC, 0x17671790, 0x057F058E, 0xE805E85E, 0x4F644F7D,
+	0x89AF896A, 0x10631095, 0x74B6742F, 0x0AFE0A75, 0x5CF55C92, 0x9BB79B74,
+	0x2D3C2D33, 0x30A530D6, 0x2ECE2E49, 0x49E94989, 0x46684672, 0x77447755,
+	0xA8E0A8D8, 0x964D9604, 0x284328BD, 0xA969A929, 0xD929D979, 0x862E8691,
+	0xD1ACD187, 0xF415F44A, 0x8D598D15, 0xD6A8D682, 0xB90AB9BC, 0x429E420D,
+	0xF66EF6C1, 0x2F472FB8, 0xDDDFDD06, 0x23342339, 0xCC35CC62, 0xF16AF1C4,
+	0xC1CFC112, 0x85DC85EB, 0x8F228F9E, 0x71C971A1, 0x90C090F0, 0xAA9BAA53,
+	0x018901F1, 0x8BD48BE1, 0x4EED4E8C, 0x8EAB8E6F, 0xAB12ABA2, 0x6FA26F3E,
+	0xE60DE654, 0xDB52DBF2, 0x92BB927B, 0xB702B7B6, 0x692F69CA, 0x39A939D9,
+	0xD3D7D30C, 0xA761A723, 0xA21EA2AD, 0xC3B4C399, 0x6C506C44, 0x07040705,
+	0x04F6047F, 0x27C22746, 0xAC16ACA7, 0xD025D076, 0x50865013, 0xDC56DCF7,
+	0x8455841A, 0xE109E151, 0x7ABE7A25, 0x139113EF},
+
+	{
+	0xD939A9D9, 0x90176790, 0x719CB371, 0xD2A6E8D2, 0x05070405, 0x9852FD98,
+	0x6580A365, 0xDFE476DF, 0x08459A08, 0x024B9202, 0xA0E080A0, 0x665A7866,
+	0xDDAFE4DD, 0xB06ADDB0, 0xBF63D1BF, 0x362A3836, 0x54E60D54, 0x4320C643,
+	0x62CC3562, 0xBEF298BE, 0x1E12181E, 0x24EBF724, 0xD7A1ECD7, 0x77416C77,
+	0xBD2843BD, 0x32BC7532, 0xD47B37D4, 0x9B88269B, 0x700DFA70, 0xF94413F9,
+	0xB1FB94B1, 0x5A7E485A, 0x7A03F27A, 0xE48CD0E4, 0x47B68B47, 0x3C24303C,
+	0xA5E784A5, 0x416B5441, 0x06DDDF06, 0xC56023C5, 0x45FD1945, 0xA33A5BA3,
+	0x68C23D68, 0x158D5915, 0x21ECF321, 0x3166AE31, 0x3E6FA23E, 0x16578216,
+	0x95106395, 0x5BEF015B, 0x4DB8834D, 0x91862E91, 0xB56DD9B5, 0x1F83511F,
+	0x53AA9B53, 0x635D7C63, 0x3B68A63B, 0x3FFEEB3F, 0xD630A5D6, 0x257ABE25,
+	0xA7AC16A7, 0x0F090C0F, 0x35F0E335, 0x23A76123, 0xF090C0F0, 0xAFE98CAF,
+	0x809D3A80, 0x925CF592, 0x810C7381, 0x27312C27, 0x76D02576, 0xE7560BE7,
+	0x7B92BB7B, 0xE9CE4EE9, 0xF10189F1, 0x9F1E6B9F, 0xA93453A9, 0xC4F16AC4,
+	0x99C3B499, 0x975BF197, 0x8347E183, 0x6B18E66B, 0xC822BDC8, 0x0E98450E,
+	0x6E1FE26E, 0xC9B3F4C9, 0x2F74B62F, 0xCBF866CB, 0xFF99CCFF, 0xEA1495EA,
+	0xED5803ED, 0xF7DC56F7, 0xE18BD4E1, 0x1B151C1B, 0xADA21EAD, 0x0CD3D70C,
+	0x2BE2FB2B, 0x1DC8C31D, 0x195E8E19, 0xC22CB5C2, 0x8949E989, 0x12C1CF12,
+	0x7E95BF7E, 0x207DBA20, 0x6411EA64, 0x840B7784, 0x6DC5396D, 0x6A89AF6A,
+	0xD17C33D1, 0xA171C9A1, 0xCEFF62CE, 0x37BB7137, 0xFB0F81FB, 0x3DB5793D,
+	0x51E10951, 0xDC3EADDC, 0x2D3F242D, 0xA476CDA4, 0x9D55F99D, 0xEE82D8EE,
+	0x8640E586, 0xAE78C5AE, 0xCD25B9CD, 0x04964D04, 0x55774455, 0x0A0E080A,
+	0x13508613, 0x30F7E730, 0xD337A1D3, 0x40FA1D40, 0x3461AA34, 0x8C4EED8C,
+	0xB3B006B3, 0x6C54706C, 0x2A73B22A, 0x523BD252, 0x0B9F410B, 0x8B027B8B,
+	0x88D8A088, 0x4FF3114F, 0x67CB3167, 0x4627C246, 0xC06727C0, 0xB4FC90B4,
+	0x28382028, 0x7F04F67F, 0x78486078, 0x2EE5FF2E, 0x074C9607, 0x4B655C4B,
+	0xC72BB1C7, 0x6F8EAB6F, 0x0D429E0D, 0xBBF59CBB, 0xF2DB52F2, 0xF34A1BF3,
+	0xA63D5FA6, 0x59A49359, 0xBCB90ABC, 0x3AF9EF3A, 0xEF1391EF, 0xFE0885FE,
+	0x01914901, 0x6116EE61, 0x7CDE2D7C, 0xB2214FB2, 0x42B18F42, 0xDB723BDB,
+	0xB82F47B8, 0x48BF8748, 0x2CAE6D2C, 0xE3C046E3, 0x573CD657, 0x859A3E85,
+	0x29A96929, 0x7D4F647D, 0x94812A94, 0x492ECE49, 0x17C6CB17, 0xCA692FCA,
+	0xC3BDFCC3, 0x5CA3975C, 0x5EE8055E, 0xD0ED7AD0, 0x87D1AC87, 0x8E057F8E,
+	0xBA64D5BA, 0xA8A51AA8, 0xB7264BB7, 0xB9BE0EB9, 0x6087A760, 0xF8D55AF8,
+	0x22362822, 0x111B1411, 0xDE753FDE, 0x79D92979, 0xAAEE88AA, 0x332D3C33,
+	0x5F794C5F, 0xB6B702B6, 0x96CAB896, 0x5835DA58, 0x9CC4B09C, 0xFC4317FC,
+	0x1A84551A, 0xF64D1FF6, 0x1C598A1C, 0x38B27D38, 0xAC3357AC, 0x18CFC718,
+	0xF4068DF4, 0x69537469, 0x749BB774, 0xF597C4F5, 0x56AD9F56, 0xDAE372DA,
+	0xD5EA7ED5, 0x4AF4154A, 0x9E8F229E, 0xA2AB12A2, 0x4E62584E, 0xE85F07E8,
+	0xE51D99E5, 0x39233439, 0xC1F66EC1, 0x446C5044, 0x5D32DE5D, 0x72466872,
+	0x26A06526, 0x93CDBC93, 0x03DADB03, 0xC6BAF8C6, 0xFA9EC8FA, 0x82D6A882,
+	0xCF6E2BCF, 0x50704050, 0xEB85DCEB, 0x750AFE75, 0x8A93328A, 0x8DDFA48D,
+	0x4C29CA4C, 0x141C1014, 0x73D72173, 0xCCB4F0CC, 0x09D4D309, 0x108A5D10,
+	0xE2510FE2, 0x00000000, 0x9A196F9A, 0xE01A9DE0, 0x8F94368F, 0xE6C742E6,
+	0xECC94AEC, 0xFDD25EFD, 0xAB7FC1AB, 0xD8A8E0D8}
+};
+
+/* The exp_to_poly and poly_to_exp tables are used to perform efficient
+ * operations in GF(2^8) represented as GF(2)[x]/w(x) where
+ * w(x)=x^8+x^6+x^3+x^2+1.  We care about doing that because it's part of the
+ * definition of the RS matrix in the key schedule.  Elements of that field
+ * are polynomials of degree not greater than 7 and all coefficients 0 or 1,
+ * which can be represented naturally by bytes (just substitute x=2).  In that
+ * form, GF(2^8) addition is the same as bitwise XOR, but GF(2^8)
+ * multiplication is inefficient without hardware support.  To multiply
+ * faster, I make use of the fact x is a generator for the nonzero elements,
+ * so that every element p of GF(2)[x]/w(x) is either 0 or equal to (x)^n for
+ * some n in 0..254.  Note that that caret is exponentiation in GF(2^8),
+ * *not* polynomial notation.  So if I want to compute pq where p and q are
+ * in GF(2^8), I can just say:
+ *    1. if p=0 or q=0 then pq=0
+ *    2. otherwise, find m and n such that p=x^m and q=x^n
+ *    3. pq=(x^m)(x^n)=x^(m+n), so add m and n and find pq
+ * The translations in steps 2 and 3 are looked up in the tables
+ * poly_to_exp (for step 2) and exp_to_poly (for step 3).  To see this
+ * in action, look at the CALC_S macro.  As additional wrinkles, note that
+ * one of my operands is always a constant, so the poly_to_exp lookup on it
+ * is done in advance; I included the original values in the comments so
+ * readers can have some chance of recognizing that this *is* the RS matrix
+ * from the Twofish paper.  I've only included the table entries I actually
+ * need; I never do a lookup on a variable input of zero and the biggest
+ * exponents I'll ever see are 254 (variable) and 237 (constant), so they'll
+ * never sum to more than 491.	I'm repeating part of the exp_to_poly table
+ * so that I don't have to do mod-255 reduction in the exponent arithmetic.
+ * Since I know my constant operands are never zero, I only have to worry
+ * about zero values in the variable operand, and I do it with a simple
+ * conditional branch.	I know conditionals are expensive, but I couldn't
+ * see a non-horrible way of avoiding them, and I did manage to group the
+ * statements so that each if covers four group multiplications. */
+
+static const u8 poly_to_exp[255] = {
+	0x00, 0x01, 0x17, 0x02, 0x2E, 0x18, 0x53, 0x03, 0x6A, 0x2F, 0x93, 0x19,
+	0x34, 0x54, 0x45, 0x04, 0x5C, 0x6B, 0xB6, 0x30, 0xA6, 0x94, 0x4B, 0x1A,
+	0x8C, 0x35, 0x81, 0x55, 0xAA, 0x46, 0x0D, 0x05, 0x24, 0x5D, 0x87, 0x6C,
+	0x9B, 0xB7, 0xC1, 0x31, 0x2B, 0xA7, 0xA3, 0x95, 0x98, 0x4C, 0xCA, 0x1B,
+	0xE6, 0x8D, 0x73, 0x36, 0xCD, 0x82, 0x12, 0x56, 0x62, 0xAB, 0xF0, 0x47,
+	0x4F, 0x0E, 0xBD, 0x06, 0xD4, 0x25, 0xD2, 0x5E, 0x27, 0x88, 0x66, 0x6D,
+	0xD6, 0x9C, 0x79, 0xB8, 0x08, 0xC2, 0xDF, 0x32, 0x68, 0x2C, 0xFD, 0xA8,
+	0x8A, 0xA4, 0x5A, 0x96, 0x29, 0x99, 0x22, 0x4D, 0x60, 0xCB, 0xE4, 0x1C,
+	0x7B, 0xE7, 0x3B, 0x8E, 0x9E, 0x74, 0xF4, 0x37, 0xD8, 0xCE, 0xF9, 0x83,
+	0x6F, 0x13, 0xB2, 0x57, 0xE1, 0x63, 0xDC, 0xAC, 0xC4, 0xF1, 0xAF, 0x48,
+	0x0A, 0x50, 0x42, 0x0F, 0xBA, 0xBE, 0xC7, 0x07, 0xDE, 0xD5, 0x78, 0x26,
+	0x65, 0xD3, 0xD1, 0x5F, 0xE3, 0x28, 0x21, 0x89, 0x59, 0x67, 0xFC, 0x6E,
+	0xB1, 0xD7, 0xF8, 0x9D, 0xF3, 0x7A, 0x3A, 0xB9, 0xC6, 0x09, 0x41, 0xC3,
+	0xAE, 0xE0, 0xDB, 0x33, 0x44, 0x69, 0x92, 0x2D, 0x52, 0xFE, 0x16, 0xA9,
+	0x0C, 0x8B, 0x80, 0xA5, 0x4A, 0x5B, 0xB5, 0x97, 0xC9, 0x2A, 0xA2, 0x9A,
+	0xC0, 0x23, 0x86, 0x4E, 0xBC, 0x61, 0xEF, 0xCC, 0x11, 0xE5, 0x72, 0x1D,
+	0x3D, 0x7C, 0xEB, 0xE8, 0xE9, 0x3C, 0xEA, 0x8F, 0x7D, 0x9F, 0xEC, 0x75,
+	0x1E, 0xF5, 0x3E, 0x38, 0xF6, 0xD9, 0x3F, 0xCF, 0x76, 0xFA, 0x1F, 0x84,
+	0xA0, 0x70, 0xED, 0x14, 0x90, 0xB3, 0x7E, 0x58, 0xFB, 0xE2, 0x20, 0x64,
+	0xD0, 0xDD, 0x77, 0xAD, 0xDA, 0xC5, 0x40, 0xF2, 0x39, 0xB0, 0xF7, 0x49,
+	0xB4, 0x0B, 0x7F, 0x51, 0x15, 0x43, 0x91, 0x10, 0x71, 0xBB, 0xEE, 0xBF,
+	0x85, 0xC8, 0xA1
+};
+
+static const u8 exp_to_poly[492] = {
+	0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D, 0x9A, 0x79, 0xF2,
+	0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC, 0xF5, 0xA7, 0x03,
+	0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3, 0x8B, 0x5B, 0xB6,
+	0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52, 0xA4, 0x05, 0x0A,
+	0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0, 0xED, 0x97, 0x63,
+	0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1, 0x0F, 0x1E, 0x3C,
+	0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A, 0xF4, 0xA5, 0x07,
+	0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11, 0x22, 0x44, 0x88,
+	0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51, 0xA2, 0x09, 0x12,
+	0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66, 0xCC, 0xD5, 0xE7,
+	0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB, 0x1B, 0x36, 0x6C,
+	0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19, 0x32, 0x64, 0xC8,
+	0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D, 0x5A, 0xB4, 0x25,
+	0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56, 0xAC, 0x15, 0x2A,
+	0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE, 0x91, 0x6F, 0xDE,
+	0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9, 0x3F, 0x7E, 0xFC,
+	0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE, 0xB1, 0x2F, 0x5E,
+	0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41, 0x82, 0x49, 0x92,
+	0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E, 0x71, 0xE2, 0x89,
+	0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB, 0xDB, 0xFB, 0xBB,
+	0x3B, 0x76, 0xEC, 0x95, 0x67, 0xCE, 0xD1, 0xEF, 0x93, 0x6B, 0xD6, 0xE1,
+	0x8F, 0x53, 0xA6, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x4D,
+	0x9A, 0x79, 0xF2, 0xA9, 0x1F, 0x3E, 0x7C, 0xF8, 0xBD, 0x37, 0x6E, 0xDC,
+	0xF5, 0xA7, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xCD, 0xD7, 0xE3,
+	0x8B, 0x5B, 0xB6, 0x21, 0x42, 0x84, 0x45, 0x8A, 0x59, 0xB2, 0x29, 0x52,
+	0xA4, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x0D, 0x1A, 0x34, 0x68, 0xD0,
+	0xED, 0x97, 0x63, 0xC6, 0xC1, 0xCF, 0xD3, 0xEB, 0x9B, 0x7B, 0xF6, 0xA1,
+	0x0F, 0x1E, 0x3C, 0x78, 0xF0, 0xAD, 0x17, 0x2E, 0x5C, 0xB8, 0x3D, 0x7A,
+	0xF4, 0xA5, 0x07, 0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x8D, 0x57, 0xAE, 0x11,
+	0x22, 0x44, 0x88, 0x5D, 0xBA, 0x39, 0x72, 0xE4, 0x85, 0x47, 0x8E, 0x51,
+	0xA2, 0x09, 0x12, 0x24, 0x48, 0x90, 0x6D, 0xDA, 0xF9, 0xBF, 0x33, 0x66,
+	0xCC, 0xD5, 0xE7, 0x83, 0x4B, 0x96, 0x61, 0xC2, 0xC9, 0xDF, 0xF3, 0xAB,
+	0x1B, 0x36, 0x6C, 0xD8, 0xFD, 0xB7, 0x23, 0x46, 0x8C, 0x55, 0xAA, 0x19,
+	0x32, 0x64, 0xC8, 0xDD, 0xF7, 0xA3, 0x0B, 0x16, 0x2C, 0x58, 0xB0, 0x2D,
+	0x5A, 0xB4, 0x25, 0x4A, 0x94, 0x65, 0xCA, 0xD9, 0xFF, 0xB3, 0x2B, 0x56,
+	0xAC, 0x15, 0x2A, 0x54, 0xA8, 0x1D, 0x3A, 0x74, 0xE8, 0x9D, 0x77, 0xEE,
+	0x91, 0x6F, 0xDE, 0xF1, 0xAF, 0x13, 0x26, 0x4C, 0x98, 0x7D, 0xFA, 0xB9,
+	0x3F, 0x7E, 0xFC, 0xB5, 0x27, 0x4E, 0x9C, 0x75, 0xEA, 0x99, 0x7F, 0xFE,
+	0xB1, 0x2F, 0x5E, 0xBC, 0x35, 0x6A, 0xD4, 0xE5, 0x87, 0x43, 0x86, 0x41,
+	0x82, 0x49, 0x92, 0x69, 0xD2, 0xE9, 0x9F, 0x73, 0xE6, 0x81, 0x4F, 0x9E,
+	0x71, 0xE2, 0x89, 0x5F, 0xBE, 0x31, 0x62, 0xC4, 0xC5, 0xC7, 0xC3, 0xCB
+};
+
+
+/* The table constants are indices of
+ * S-box entries, preprocessed through q0 and q1. */
+static const u8 calc_sb_tbl[512] = {
+	0xA9, 0x75, 0x67, 0xF3, 0xB3, 0xC6, 0xE8, 0xF4,
+	0x04, 0xDB, 0xFD, 0x7B, 0xA3, 0xFB, 0x76, 0xC8,
+	0x9A, 0x4A, 0x92, 0xD3, 0x80, 0xE6, 0x78, 0x6B,
+	0xE4, 0x45, 0xDD, 0x7D, 0xD1, 0xE8, 0x38, 0x4B,
+	0x0D, 0xD6, 0xC6, 0x32, 0x35, 0xD8, 0x98, 0xFD,
+	0x18, 0x37, 0xF7, 0x71, 0xEC, 0xF1, 0x6C, 0xE1,
+	0x43, 0x30, 0x75, 0x0F, 0x37, 0xF8, 0x26, 0x1B,
+	0xFA, 0x87, 0x13, 0xFA, 0x94, 0x06, 0x48, 0x3F,
+	0xF2, 0x5E, 0xD0, 0xBA, 0x8B, 0xAE, 0x30, 0x5B,
+	0x84, 0x8A, 0x54, 0x00, 0xDF, 0xBC, 0x23, 0x9D,
+	0x19, 0x6D, 0x5B, 0xC1, 0x3D, 0xB1, 0x59, 0x0E,
+	0xF3, 0x80, 0xAE, 0x5D, 0xA2, 0xD2, 0x82, 0xD5,
+	0x63, 0xA0, 0x01, 0x84, 0x83, 0x07, 0x2E, 0x14,
+	0xD9, 0xB5, 0x51, 0x90, 0x9B, 0x2C, 0x7C, 0xA3,
+	0xA6, 0xB2, 0xEB, 0x73, 0xA5, 0x4C, 0xBE, 0x54,
+	0x16, 0x92, 0x0C, 0x74, 0xE3, 0x36, 0x61, 0x51,
+	0xC0, 0x38, 0x8C, 0xB0, 0x3A, 0xBD, 0xF5, 0x5A,
+	0x73, 0xFC, 0x2C, 0x60, 0x25, 0x62, 0x0B, 0x96,
+	0xBB, 0x6C, 0x4E, 0x42, 0x89, 0xF7, 0x6B, 0x10,
+	0x53, 0x7C, 0x6A, 0x28, 0xB4, 0x27, 0xF1, 0x8C,
+	0xE1, 0x13, 0xE6, 0x95, 0xBD, 0x9C, 0x45, 0xC7,
+	0xE2, 0x24, 0xF4, 0x46, 0xB6, 0x3B, 0x66, 0x70,
+	0xCC, 0xCA, 0x95, 0xE3, 0x03, 0x85, 0x56, 0xCB,
+	0xD4, 0x11, 0x1C, 0xD0, 0x1E, 0x93, 0xD7, 0xB8,
+	0xFB, 0xA6, 0xC3, 0x83, 0x8E, 0x20, 0xB5, 0xFF,
+	0xE9, 0x9F, 0xCF, 0x77, 0xBF, 0xC3, 0xBA, 0xCC,
+	0xEA, 0x03, 0x77, 0x6F, 0x39, 0x08, 0xAF, 0xBF,
+	0x33, 0x40, 0xC9, 0xE7, 0x62, 0x2B, 0x71, 0xE2,
+	0x81, 0x79, 0x79, 0x0C, 0x09, 0xAA, 0xAD, 0x82,
+	0x24, 0x41, 0xCD, 0x3A, 0xF9, 0xEA, 0xD8, 0xB9,
+	0xE5, 0xE4, 0xC5, 0x9A, 0xB9, 0xA4, 0x4D, 0x97,
+	0x44, 0x7E, 0x08, 0xDA, 0x86, 0x7A, 0xE7, 0x17,
+	0xA1, 0x66, 0x1D, 0x94, 0xAA, 0xA1, 0xED, 0x1D,
+	0x06, 0x3D, 0x70, 0xF0, 0xB2, 0xDE, 0xD2, 0xB3,
+	0x41, 0x0B, 0x7B, 0x72, 0xA0, 0xA7, 0x11, 0x1C,
+	0x31, 0xEF, 0xC2, 0xD1, 0x27, 0x53, 0x90, 0x3E,
+	0x20, 0x8F, 0xF6, 0x33, 0x60, 0x26, 0xFF, 0x5F,
+	0x96, 0xEC, 0x5C, 0x76, 0xB1, 0x2A, 0xAB, 0x49,
+	0x9E, 0x81, 0x9C, 0x88, 0x52, 0xEE, 0x1B, 0x21,
+	0x5F, 0xC4, 0x93, 0x1A, 0x0A, 0xEB, 0xEF, 0xD9,
+	0x91, 0xC5, 0x85, 0x39, 0x49, 0x99, 0xEE, 0xCD,
+	0x2D, 0xAD, 0x4F, 0x31, 0x8F, 0x8B, 0x3B, 0x01,
+	0x47, 0x18, 0x87, 0x23, 0x6D, 0xDD, 0x46, 0x1F,
+	0xD6, 0x4E, 0x3E, 0x2D, 0x69, 0xF9, 0x64, 0x48,
+	0x2A, 0x4F, 0xCE, 0xF2, 0xCB, 0x65, 0x2F, 0x8E,
+	0xFC, 0x78, 0x97, 0x5C, 0x05, 0x58, 0x7A, 0x19,
+	0xAC, 0x8D, 0x7F, 0xE5, 0xD5, 0x98, 0x1A, 0x57,
+	0x4B, 0x67, 0x0E, 0x7F, 0xA7, 0x05, 0x5A, 0x64,
+	0x28, 0xAF, 0x14, 0x63, 0x3F, 0xB6, 0x29, 0xFE,
+	0x88, 0xF5, 0x3C, 0xB7, 0x4C, 0x3C, 0x02, 0xA5,
+	0xB8, 0xCE, 0xDA, 0xE9, 0xB0, 0x68, 0x17, 0x44,
+	0x55, 0xE0, 0x1F, 0x4D, 0x8A, 0x43, 0x7D, 0x69,
+	0x57, 0x29, 0xC7, 0x2E, 0x8D, 0xAC, 0x74, 0x15,
+	0xB7, 0x59, 0xC4, 0xA8, 0x9F, 0x0A, 0x72, 0x9E,
+	0x7E, 0x6E, 0x15, 0x47, 0x22, 0xDF, 0x12, 0x34,
+	0x58, 0x35, 0x07, 0x6A, 0x99, 0xCF, 0x34, 0xDC,
+	0x6E, 0x22, 0x50, 0xC9, 0xDE, 0xC0, 0x68, 0x9B,
+	0x65, 0x89, 0xBC, 0xD4, 0xDB, 0xED, 0xF8, 0xAB,
+	0xC8, 0x12, 0xA8, 0xA2, 0x2B, 0x0D, 0x40, 0x52,
+	0xDC, 0xBB, 0xFE, 0x02, 0x32, 0x2F, 0xA4, 0xA9,
+	0xCA, 0xD7, 0x10, 0x61, 0x21, 0x1E, 0xF0, 0xB4,
+	0xD3, 0x50, 0x5D, 0x04, 0x0F, 0xF6, 0x00, 0xC2,
+	0x6F, 0x16, 0x9D, 0x25, 0x36, 0x86, 0x42, 0x56,
+	0x4A, 0x55, 0x5E, 0x09, 0xC1, 0xBE, 0xE0, 0x91
+};
+
+/* Macro to perform one column of the RS matrix multiplication.  The
+ * parameters a, b, c, and d are the four bytes of output; i is the index
+ * of the key bytes, and w, x, y, and z, are the column of constants from
+ * the RS matrix, preprocessed through the poly_to_exp table. */
+
+#define CALC_S(a, b, c, d, i, w, x, y, z) \
+   if (key[i]) { \
+      tmp = poly_to_exp[key[i] - 1]; \
+      (a) ^= exp_to_poly[tmp + (w)]; \
+      (b) ^= exp_to_poly[tmp + (x)]; \
+      (c) ^= exp_to_poly[tmp + (y)]; \
+      (d) ^= exp_to_poly[tmp + (z)]; \
+   }
+
+/* Macros to calculate the key-dependent S-boxes for a 128-bit key using
+ * the S vector from CALC_S.  CALC_SB_2 computes a single entry in all
+ * four S-boxes, where i is the index of the entry to compute, and a and b
+ * are the index numbers preprocessed through the q0 and q1 tables
+ * respectively. */
+
+#define CALC_SB_2(i, a, b) \
+   ctx-&gt;s[0][i] = mds[0][q0[(a) ^ sa] ^ se]; \
+   ctx-&gt;s[1][i] = mds[1][q0[(b) ^ sb] ^ sf]; \
+   ctx-&gt;s[2][i] = mds[2][q1[(a) ^ sc] ^ sg]; \
+   ctx-&gt;s[3][i] = mds[3][q1[(b) ^ sd] ^ sh]
+
+/* Macro exactly like CALC_SB_2, but for 192-bit keys. */
+
+#define CALC_SB192_2(i, a, b) \
+   ctx-&gt;s[0][i] = mds[0][q0[q0[(b) ^ sa] ^ se] ^ si]; \
+   ctx-&gt;s[1][i] = mds[1][q0[q1[(b) ^ sb] ^ sf] ^ sj]; \
+   ctx-&gt;s[2][i] = mds[2][q1[q0[(a) ^ sc] ^ sg] ^ sk]; \
+   ctx-&gt;s[3][i] = mds[3][q1[q1[(a) ^ sd] ^ sh] ^ sl];
+
+/* Macro exactly like CALC_SB_2, but for 256-bit keys. */
+
+#define CALC_SB256_2(i, a, b) \
+   ctx-&gt;s[0][i] = mds[0][q0[q0[q1[(b) ^ sa] ^ se] ^ si] ^ sm]; \
+   ctx-&gt;s[1][i] = mds[1][q0[q1[q1[(a) ^ sb] ^ sf] ^ sj] ^ sn]; \
+   ctx-&gt;s[2][i] = mds[2][q1[q0[q0[(a) ^ sc] ^ sg] ^ sk] ^ so]; \
+   ctx-&gt;s[3][i] = mds[3][q1[q1[q0[(b) ^ sd] ^ sh] ^ sl] ^ sp];
+
+/* Macros to calculate the whitening and round subkeys.  CALC_K_2 computes the
+ * last two stages of the h() function for a given index (either 2i or 2i+1).
+ * a, b, c, and d are the four bytes going into the last two stages.  For
+ * 128-bit keys, this is the entire h() function and a and c are the index
+ * preprocessed through q0 and q1 respectively; for longer keys they are the
+ * output of previous stages.  j is the index of the first key byte to use.
+ * CALC_K computes a pair of subkeys for 128-bit Twofish, by calling CALC_K_2
+ * twice, doing the Pseudo-Hadamard Transform, and doing the necessary
+ * rotations.  Its parameters are: a, the array to write the results into,
+ * j, the index of the first output entry, k and l, the preprocessed indices
+ * for index 2i, and m and n, the preprocessed indices for index 2i+1.
+ * CALC_K192_2 expands CALC_K_2 to handle 192-bit keys, by doing an
+ * additional lookup-and-XOR stage.  The parameters a, b, c and d are the
+ * four bytes going into the last three stages.  For 192-bit keys, c = d
+ * are the index preprocessed through q0, and a = b are the index
+ * preprocessed through q1; j is the index of the first key byte to use.
+ * CALC_K192 is identical to CALC_K but for using the CALC_K192_2 macro
+ * instead of CALC_K_2.
+ * CALC_K256_2 expands CALC_K192_2 to handle 256-bit keys, by doing an
+ * additional lookup-and-XOR stage.  The parameters a and b are the index
+ * preprocessed through q0 and q1 respectively; j is the index of the first
+ * key byte to use.  CALC_K256 is identical to CALC_K but for using the
+ * CALC_K256_2 macro instead of CALC_K_2. */
+
+#define CALC_K_2(a, b, c, d, j) \
+     mds[0][q0[a ^ key[(j) + 8]] ^ key[j]] \
+   ^ mds[1][q0[b ^ key[(j) + 9]] ^ key[(j) + 1]] \
+   ^ mds[2][q1[c ^ key[(j) + 10]] ^ key[(j) + 2]] \
+   ^ mds[3][q1[d ^ key[(j) + 11]] ^ key[(j) + 3]]
+
+#define CALC_K(a, j, k, l, m, n) \
+   x = CALC_K_2 (k, l, k, l, 0); \
+   y = CALC_K_2 (m, n, m, n, 4); \
+   y = rol32(y, 8); \
+   x += y; y += x; ctx-&gt;a[j] = x; \
+   ctx-&gt;a[(j) + 1] = rol32(y, 9)
+
+#define CALC_K192_2(a, b, c, d, j) \
+   CALC_K_2 (q0[a ^ key[(j) + 16]], \
+	     q1[b ^ key[(j) + 17]], \
+	     q0[c ^ key[(j) + 18]], \
+	     q1[d ^ key[(j) + 19]], j)
+
+#define CALC_K192(a, j, k, l, m, n) \
+   x = CALC_K192_2 (l, l, k, k, 0); \
+   y = CALC_K192_2 (n, n, m, m, 4); \
+   y = rol32(y, 8); \
+   x += y; y += x; ctx-&gt;a[j] = x; \
+   ctx-&gt;a[(j) + 1] = rol32(y, 9)
+
+#define CALC_K256_2(a, b, j) \
+   CALC_K192_2 (q1[b ^ key[(j) + 24]], \
+	        q1[a ^ key[(j) + 25]], \
+	        q0[a ^ key[(j) + 26]], \
+	        q0[b ^ key[(j) + 27]], j)
+
+#define CALC_K256(a, j, k, l, m, n) \
+   x = CALC_K256_2 (k, l, 0); \
+   y = CALC_K256_2 (m, n, 4); \
+   y = rol32(y, 8); \
+   x += y; y += x; ctx-&gt;a[j] = x; \
+   ctx-&gt;a[(j) + 1] = rol32(y, 9)
+
+/* Perform the key setup. */
+int twofish_setkey(struct crypto_tfm *tfm, const u8 *key,
+			unsigned int key_len, u32 *flags)
+{
+	
+	struct twofish_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	int i, j, k;
+
+	/* Temporaries for CALC_K. */
+	u32 x, y;
+
+	/* The S vector used to key the S-boxes, split up into individual bytes.
+	 * 128-bit keys use only sa through sh; 256-bit use all of them. */
+	u8 sa = 0, sb = 0, sc = 0, sd = 0, se = 0, sf = 0, sg = 0, sh = 0;
+	u8 si = 0, sj = 0, sk = 0, sl = 0, sm = 0, sn = 0, so = 0, sp = 0;
+
+	/* Temporary for CALC_S. */
+	u8 tmp;
+
+	/* Check key length. */
+	if (key_len != 16 &amp;&amp; key_len != 24 &amp;&amp; key_len != 32)
+	{
+		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
+		return -EINVAL; /* unsupported key length */
+	}
+
+	/* Compute the first two words of the S vector.  The magic numbers are
+	 * the entries of the RS matrix, preprocessed through poly_to_exp. The
+	 * numbers in the comments are the original (polynomial form) matrix
+	 * entries. */
+	CALC_S (sa, sb, sc, sd, 0, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+	CALC_S (sa, sb, sc, sd, 1, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+	CALC_S (sa, sb, sc, sd, 2, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+	CALC_S (sa, sb, sc, sd, 3, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+	CALC_S (sa, sb, sc, sd, 4, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+	CALC_S (sa, sb, sc, sd, 5, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+	CALC_S (sa, sb, sc, sd, 6, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+	CALC_S (sa, sb, sc, sd, 7, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+	CALC_S (se, sf, sg, sh, 8, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+	CALC_S (se, sf, sg, sh, 9, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+	CALC_S (se, sf, sg, sh, 10, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+	CALC_S (se, sf, sg, sh, 11, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+	CALC_S (se, sf, sg, sh, 12, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+	CALC_S (se, sf, sg, sh, 13, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+	CALC_S (se, sf, sg, sh, 14, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+	CALC_S (se, sf, sg, sh, 15, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+
+	if (key_len == 24 || key_len == 32) { /* 192- or 256-bit key */
+		/* Calculate the third word of the S vector */
+		CALC_S (si, sj, sk, sl, 16, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+		CALC_S (si, sj, sk, sl, 17, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+		CALC_S (si, sj, sk, sl, 18, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+		CALC_S (si, sj, sk, sl, 19, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+		CALC_S (si, sj, sk, sl, 20, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+		CALC_S (si, sj, sk, sl, 21, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+		CALC_S (si, sj, sk, sl, 22, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+		CALC_S (si, sj, sk, sl, 23, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+	}
+
+	if (key_len == 32) { /* 256-bit key */
+		/* Calculate the fourth word of the S vector */
+		CALC_S (sm, sn, so, sp, 24, 0x00, 0x2D, 0x01, 0x2D); /* 01 A4 02 A4 */
+		CALC_S (sm, sn, so, sp, 25, 0x2D, 0xA4, 0x44, 0x8A); /* A4 56 A1 55 */
+		CALC_S (sm, sn, so, sp, 26, 0x8A, 0xD5, 0xBF, 0xD1); /* 55 82 FC 87 */
+		CALC_S (sm, sn, so, sp, 27, 0xD1, 0x7F, 0x3D, 0x99); /* 87 F3 C1 5A */
+		CALC_S (sm, sn, so, sp, 28, 0x99, 0x46, 0x66, 0x96); /* 5A 1E 47 58 */
+		CALC_S (sm, sn, so, sp, 29, 0x96, 0x3C, 0x5B, 0xED); /* 58 C6 AE DB */
+		CALC_S (sm, sn, so, sp, 30, 0xED, 0x37, 0x4F, 0xE0); /* DB 68 3D 9E */
+		CALC_S (sm, sn, so, sp, 31, 0xE0, 0xD0, 0x8C, 0x17); /* 9E E5 19 03 */
+
+		/* Compute the S-boxes. */
+		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
+			CALC_SB256_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
+		}
+
+		/* Calculate whitening and round subkeys.  The constants are
+		 * indices of subkeys, preprocessed through q0 and q1. */
+		CALC_K256 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
+		CALC_K256 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
+		CALC_K256 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
+		CALC_K256 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
+		CALC_K256 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
+		CALC_K256 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
+		CALC_K256 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
+		CALC_K256 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
+		CALC_K256 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
+		CALC_K256 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
+		CALC_K256 (k, 12, 0x18, 0x37, 0xF7, 0x71);
+		CALC_K256 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
+		CALC_K256 (k, 16, 0x43, 0x30, 0x75, 0x0F);
+		CALC_K256 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
+		CALC_K256 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
+		CALC_K256 (k, 22, 0x94, 0x06, 0x48, 0x3F);
+		CALC_K256 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
+		CALC_K256 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
+		CALC_K256 (k, 28, 0x84, 0x8A, 0x54, 0x00);
+		CALC_K256 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
+	} else if (key_len == 24) { /* 192-bit key */
+		/* Compute the S-boxes. */
+		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
+		        CALC_SB192_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
+		}
+
+		/* Calculate whitening and round subkeys.  The constants are
+		 * indices of subkeys, preprocessed through q0 and q1. */
+		CALC_K192 (w, 0, 0xA9, 0x75, 0x67, 0xF3);
+		CALC_K192 (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
+		CALC_K192 (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
+		CALC_K192 (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
+		CALC_K192 (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
+		CALC_K192 (k, 2, 0x80, 0xE6, 0x78, 0x6B);
+		CALC_K192 (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
+		CALC_K192 (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
+		CALC_K192 (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
+		CALC_K192 (k, 10, 0x35, 0xD8, 0x98, 0xFD);
+		CALC_K192 (k, 12, 0x18, 0x37, 0xF7, 0x71);
+		CALC_K192 (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
+		CALC_K192 (k, 16, 0x43, 0x30, 0x75, 0x0F);
+		CALC_K192 (k, 18, 0x37, 0xF8, 0x26, 0x1B);
+		CALC_K192 (k, 20, 0xFA, 0x87, 0x13, 0xFA);
+		CALC_K192 (k, 22, 0x94, 0x06, 0x48, 0x3F);
+		CALC_K192 (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
+		CALC_K192 (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
+		CALC_K192 (k, 28, 0x84, 0x8A, 0x54, 0x00);
+		CALC_K192 (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
+	} else { /* 128-bit key */
+		/* Compute the S-boxes. */
+		for ( i = j = 0, k = 1; i &lt; 256; i++, j += 2, k += 2 ) {
+			CALC_SB_2( i, calc_sb_tbl[j], calc_sb_tbl[k] );
+		}
+
+		/* Calculate whitening and round subkeys.  The constants are
+		 * indices of subkeys, preprocessed through q0 and q1. */
+		CALC_K (w, 0, 0xA9, 0x75, 0x67, 0xF3);
+		CALC_K (w, 2, 0xB3, 0xC6, 0xE8, 0xF4);
+		CALC_K (w, 4, 0x04, 0xDB, 0xFD, 0x7B);
+		CALC_K (w, 6, 0xA3, 0xFB, 0x76, 0xC8);
+		CALC_K (k, 0, 0x9A, 0x4A, 0x92, 0xD3);
+		CALC_K (k, 2, 0x80, 0xE6, 0x78, 0x6B);
+		CALC_K (k, 4, 0xE4, 0x45, 0xDD, 0x7D);
+		CALC_K (k, 6, 0xD1, 0xE8, 0x38, 0x4B);
+		CALC_K (k, 8, 0x0D, 0xD6, 0xC6, 0x32);
+		CALC_K (k, 10, 0x35, 0xD8, 0x98, 0xFD);
+		CALC_K (k, 12, 0x18, 0x37, 0xF7, 0x71);
+		CALC_K (k, 14, 0xEC, 0xF1, 0x6C, 0xE1);
+		CALC_K (k, 16, 0x43, 0x30, 0x75, 0x0F);
+		CALC_K (k, 18, 0x37, 0xF8, 0x26, 0x1B);
+		CALC_K (k, 20, 0xFA, 0x87, 0x13, 0xFA);
+		CALC_K (k, 22, 0x94, 0x06, 0x48, 0x3F);
+		CALC_K (k, 24, 0xF2, 0x5E, 0xD0, 0xBA);
+		CALC_K (k, 26, 0x8B, 0xAE, 0x30, 0x5B);
+		CALC_K (k, 28, 0x84, 0x8A, 0x54, 0x00);
+		CALC_K (k, 30, 0xDF, 0xBC, 0x23, 0x9D);
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL(twofish_setkey);
+
diff --git a/include/crypto/twofish.h b/include/crypto/twofish.h
new file mode 100644
index 0000000..e2d49d8
--- /dev/null
+++ b/include/crypto/twofish.h
@@ -0,0 +1,18 @@
+#ifndef _CRYPTO_TWOFISH_H
+#define _CRYPTO_TWOFISH_H
+
+#define TF_MIN_KEY_SIZE 16
+#define TF_MAX_KEY_SIZE 32
+#define TF_BLOCK_SIZE 16
+
+/* Structure for an expanded Twofish key.  s contains the key-dependent
+ * S-boxes composed with the MDS matrix; w contains the eight "whitening"
+ * subkeys, K[0] through K[7].	k holds the remaining, "round" subkeys.  Note
+ * that k[i] corresponds to what the Twofish paper calls K[i+8]. */
+struct twofish_ctx {
+   u32 s[4][256], w[8], k[32];
+};
+
+int twofish_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int key_len, u32 *flags);
+
+#endif

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060620102611</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-06-20 10:26:11-0400</timestampReceived><subject>Re: [PATCH  1/4] Twofish cipher - split out common c code</subject><body>

On Mon, Jun 19, 2006 at 04:12:37PM +0200, Joachim Fritschi wrote:
&gt; This patch is now based on the cryptodev tree. The last patches where against
&gt; 2.6.17. I somehow missed you announcement about the api change (ctx -&gt; tfm).
&gt; I also did the formating changes and the header fix you asked for.
&gt; 
&gt; Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

Thanks, I've applied this one.

BTW, I had to add a few missing bits to twofish_common.c.  Next time
please make sure that you provide at least a MODULE_LICENSE and a
module_exit function.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060613213408</emailId><senderName>Christian Kujau</senderName><senderEmail>evil@g-house.de</senderEmail><timestampReceived>2006-06-13 21:34:08-0400</timestampReceived><subject>Re: Distinguishability of encrypted partition</subject><body>

On Fri, 9 Jun 2006, Phil H wrote:
&gt; I'm not sure I follow (in discussions about deniability) why
&gt; a user cannot simply say they shredded that partition ....

IANAL nor a crypto-expert, but I don't think "they" will engange some 
super-powers to bring evidence, that this 300GB disk is not full with 
"random" but with "encrypted data" and therefor it "must be full of 
mp3/pr0n/whatever". But as I write this I realize that in some countries 
it's might not be even important what you've enrypted but the mere fact 
*that* you've encrypted something could bring you in trouble.

In this case, I believe it is even less likely that "they" will handle this case 
with the wholeheartedness a sane mind would expect: "Hm, a disk we can't read?
And she has Applied Cryptography on her bookshelf? That disk must be crypted
and we need no crypto-analyst for this one".

However, if "they" are really trying to bring evidenc that this disk is 
encrypted and nothing else external(!) points to the fact that it really 
has been encrypted (fstab entry with gpg keys, .bash_history, etc), "they"'d 
have to apply the ususal and well known attacks to the crypted disk:

- a too short keylength may not suffice for really big volumes[0],
   "encrypted portions" of the volume may repeat then.
- a weak cipher, in combination with a weak password (for the key)
- application traces in crypto-containers, iirc PGP-Disk has some
   information in the header of its disk-image (but don't quote me on that)

My point is: it is more likey that many other points (evil governments 
not doing an analysis at all, traces of crypto-usage, posting on this 
mailinglist ;)) could get you (not you personally!) in trouble...
but what do I know....

Christian.

[0] http://www.cryptolabs.org/aes/WeisLucksAESattacksDS1202.html
    (in germand, sorry...)
-- 
BOFH excuse #333:

A plumber is needed, the network drain is clogged

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060614081739</emailId><senderName>Florian Reitmeir</senderName><senderEmail>fr@3node.com</senderEmail><timestampReceived>2006-06-14 08:17:39-0400</timestampReceived><subject>Re: Distinguishability of encrypted partition</subject><body>

On Die, 13 Jun 2006, Christian Kujau wrote:

&gt; On Fri, 9 Jun 2006, Phil H wrote:
&gt; &gt;I'm not sure I follow (in discussions about deniability) why
&gt; &gt;a user cannot simply say they shredded that partition ....
&gt; 
&gt; IANAL nor a crypto-expert, but I don't think "they" will engange some 
&gt; super-powers to bring evidence, that this 300GB disk is not full with 
&gt; "random" but with "encrypted data" and therefor it "must be full of 
&gt; mp3/pr0n/whatever". But as I write this I realize that in some countries 
&gt; it's might not be even important what you've enrypted but the mere fact 
&gt; *that* you've encrypted something could bring you in trouble.

"The" evils have much simpler ways to "crack" your security, a common
way (rumors) is, that 

- "they" grab all your computer staff
- see its encrypted
- return the computer
- ... with an keylogger, small on the mainboard/keyboard/usb-bus/...
- then, come about 2 weeks/months later again


and of course there always is this moment .. when somebody tells you "now its
your choice, you may cooperate and get a small punishment, or you get all
and more if we're able to read your disk other ways"

-- 
Florian Reitmeir

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060614171040</emailId><senderName>Christian Kujau</senderName><senderEmail>evil@g-house.de</senderEmail><timestampReceived>2006-06-14 17:10:40-0400</timestampReceived><subject>Re: Distinguishability of encrypted partition</subject><body>

On Wed, 14 Jun 2006, Florian Reitmeir wrote:
&gt; "The" evils have much simpler ways to "crack" your security, a common
&gt; way (rumors) is, that
&gt;
&gt; - "they" grab all your computer staff
&gt; - see its encrypted

s/see/assume/  ...as they can't be sure and probably won't hire a 
cryptoexpert to prove this, methinks.

&gt; - return the computer
&gt; - ... with an keylogger, small on the mainboard/keyboard/usb-bus/...
&gt; - then, come about 2 weeks/months later again

there we go again: triple-aes-1024 won't help if the cryptosystem is lame.

What I'm still courious about is: are "they" allowed to tamper with a 
"disk with random-looking data"? because, if she says: "No, it's just 
random data, dunno what crypto is" then "they" could say: "if it's only 
random, you won't object if we wipe your disk, right?".
But these are legal questions, i guess...

-- 
BOFH excuse #97:

Small animal kamikaze attack on power supplies

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060619080338</emailId><senderName>Phil H</senderName><senderEmail>philtickle200@yahoo.com</senderEmail><timestampReceived>2006-06-19 08:03:38-0400</timestampReceived><subject>Re: Distinguishability of encrypted partition</subject><body>

Thanks for the replies - only just saw them since my yahoo bulk folder is so full of \
junk.

I suppose I was thinking of watermark-type attacks, showing there actually is a \
filesystem in that randomness (my understanding is that v3.x loop-aes should be \
immune to these?), or some type of mathematical investigation designed to show the \
partition has not been recently overwritten by shred or somesuch but has a suspicious \
form of "randomness" (if such an investigation exists that is). 

So my initial assumption was probably correct - it's the extraneous factors (fstab,  \
having encryption software, etc) that probably remain the practical indicators.

What an interesting mail list this is.  Perhaps I might even eventually switch \
careers to this stuff in  some form :)

Christian Kujau &lt;evil@g-house.de&gt; wrote: On Wed, 14 Jun 2006, Florian Reitmeir wrote:
&gt; "The" evils have much simpler ways to "crack" your security, a common
&gt; way (rumors) is, that
&gt; 
&gt; - "they" grab all your computer staff
&gt; - see its encrypted

s/see/assume/  ...as they can't be sure and probably won't hire a 
cryptoexpert to prove this, methinks.

&gt; - return the computer
&gt; - ... with an keylogger, small on the mainboard/keyboard/usb-bus/...
&gt; - then, come about 2 weeks/months later again

there we go again: triple-aes-1024 won't help if the cryptosystem is lame.

What I'm still courious about is: are "they" allowed to tamper with a 
"disk with random-looking data"? because, if she says: "No, it's just 
random data, dunno what crypto is" then "they" could say: "if it's only 
random, you won't object if we wipe your disk, right?".
But these are legal questions, i guess...

-- 
BOFH excuse #97:

Small animal kamikaze attack on power supplies

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



 		
---------------------------------
Talk is cheap. Use Yahoo! Messenger to make PC-to-Phone calls.  Great rates starting \
at 1¢/min.


[Attachment #3 (text/html)]

Thanks for the replies - only just saw them since my yahoo bulk folder is so full of \
junk.&lt;br&gt;&lt;br&gt;I suppose I was thinking of watermark-type attacks, showing there \
actually is a filesystem in that randomness (my understanding is that v3.x loop-aes \
should be immune to these?), or some type of mathematical investigation designed to \
show the partition has not been recently overwritten by shred or somesuch but has a \
suspicious form of "randomness" (if such an investigation exists that is). &lt;br&gt;&lt;br&gt;So \
my initial assumption was probably correct - it's the extraneous factors \
(fstab,  having encryption software, etc) that probably remain the practical \
indicators.&lt;br&gt;&lt;br&gt;What an interesting mail list this is.  Perhaps I might even \
eventually switch careers to this stuff in  some form :)&lt;br&gt;&lt;br&gt;&lt;b&gt;&lt;i&gt;Christian \
Kujau &lt;evil@g-house.de&gt;&lt;/i&gt;&lt;/b&gt; wrote:&lt;blockquote class="replbq" \
style="border-left: 2px solid rgb(16, 16, 255); margin-left: 5px; padding-left: \
5px;"&gt; On  Wed, 14 Jun 2006, Florian Reitmeir wrote:&lt;br&gt;&gt; "The" evils have much \
simpler ways to "crack" your security, a common&lt;br&gt;&gt; way (rumors) is, \
that&lt;br&gt;&gt;&lt;br&gt;&gt; - "they" grab all your computer staff&lt;br&gt;&gt; - see its \
encrypted&lt;br&gt;&lt;br&gt;s/see/assume/  ...as they can't be sure and probably won't hire a \
&lt;br&gt;cryptoexpert to prove this, methinks.&lt;br&gt;&lt;br&gt;&gt; - return the computer&lt;br&gt;&gt; - \
... with an keylogger, small on the mainboard/keyboard/usb-bus/...&lt;br&gt;&gt; - then, \
come about 2 weeks/months later again&lt;br&gt;&lt;br&gt;there we go again: triple-aes-1024 won't \
help if the cryptosystem is lame.&lt;br&gt;&lt;br&gt;What I'm still courious about is: are "they" \
allowed to tamper with a &lt;br&gt;"disk with random-looking data"? because, if she says: \
"No, it's just &lt;br&gt;random data, dunno what crypto is" then "they" could say: "if it's \
only &lt;br&gt;random, you won't object if we wipe your disk, right?".&lt;br&gt;But these are \
legal questions, i guess...&lt;br&gt;&lt;br&gt;-- &lt;br&gt;BOFH excuse #97:&lt;br&gt;&lt;br&gt;Small animal \
kamikaze  attack on power supplies&lt;br&gt;&lt;br&gt;-&lt;br&gt;Linux-crypto:  cryptography in and on \
the Linux system&lt;br&gt;Archive:       \
http://mail.nl.linux.org/linux-crypto/&lt;br&gt;&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;p&gt;   &lt;hr \
size=1&gt;Talk is cheap. Use Yahoo! Messenger to make PC-to-Phone calls. &lt;a \
href="http://us.rd.yahoo.com/mail_us/taglines/postman7/*http://us.rd.yahoo.com/evt=39666/*http://messenger.yahoo.com"&gt; \
Great rates starting at 1¢/min.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060619081711</emailId><senderName>Phil H</senderName><senderEmail>philtickle200@yahoo.com</senderEmail><timestampReceived>2006-06-19 08:17:11-0400</timestampReceived><subject>Re: Distinguishability of encrypted partition</subject><body>

One thing - while positing "they" in the threat model as they=Authorities is \
obviously important (especially with reference to totalitarian regimes such as PRC, \
but let's not forget all the recent changes to law in other places which seem to \
effectively dispense with any right to private data), in some ways illegal corporate \
espionage is a far tougher adversary.

In that case "they" are not subject to any due process at all and there can be huge \
amounts of money at stake and therefore resources invested to get the plaintext.

I wonder if there are any multibillion dollar companies out there relying on loop-aes \
to protect their secret product development data?

Florian Reitmeir &lt;fr@3node.com&gt; wrote: On Die, 13 Jun 2006, Christian Kujau wrote:

&gt; On Fri, 9 Jun 2006, Phil H wrote:
&gt; &gt; I'm not sure I follow (in discussions about deniability) why
&gt; &gt; a user cannot simply say they shredded that partition ....
&gt; 
&gt; IANAL nor a crypto-expert, but I don't think "they" will engange some 
&gt; super-powers to bring evidence, that this 300GB disk is not full with 
&gt; "random" but with "encrypted data" and therefor it "must be full of 
&gt; mp3/pr0n/whatever". But as I write this I realize that in some countries 
&gt; it's might not be even important what you've enrypted but the mere fact 
&gt; *that* you've encrypted something could bring you in trouble.

"The" evils have much simpler ways to "crack" your security, a common
way (rumors) is, that 

- "they" grab all your computer staff
- see its encrypted
- return the computer
- ... with an keylogger, small on the mainboard/keyboard/usb-bus/...
- then, come about 2 weeks/months later again


and of course there always is this moment .. when somebody tells you "now its
your choice, you may cooperate and get a small punishment, or you get all
and more if we're able to read your disk other ways"

-- 
Florian Reitmeir

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



 		
---------------------------------
Do you Yahoo!?
 Everyone is raving about the  all-new Yahoo! Mail Beta.


[Attachment #3 (text/html)]

One thing - while positing "they" in the threat model as they=Authorities is \
obviously important (especially with reference to totalitarian regimes such as PRC, \
but let's not forget all the recent changes to law in other places which seem to \
effectively dispense with any right to private data), in some ways illegal corporate \
espionage is a far tougher adversary.&lt;br&gt;&lt;br&gt;In that case "they" are not subject to \
any due process at all and there can be huge amounts of money at stake and therefore \
resources invested to get the plaintext.&lt;br&gt;&lt;br&gt;I wonder if there are any \
multibillion dollar companies out there relying on loop-aes to protect their secret \
product development data?&lt;br&gt;&lt;br&gt;&lt;b&gt;&lt;i&gt;Florian Reitmeir &lt;fr@3node.com&gt;&lt;/i&gt;&lt;/b&gt; \
wrote:&lt;blockquote class="replbq" style="border-left: 2px solid rgb(16, 16, 255); \
margin-left: 5px; padding-left: 5px;"&gt; On Die, 13 Jun 2006, Christian Kujau \
wrote:&lt;br&gt;&lt;br&gt;&gt; On Fri, 9 Jun 2006, Phil H wrote:&lt;br&gt;&gt; &gt;I'm not sure I \
follow (in  discussions about deniability) why&lt;br&gt;&gt; &gt;a user cannot simply say \
they shredded that partition ....&lt;br&gt;&gt; &lt;br&gt;&gt; IANAL nor a crypto-expert, but I \
don't think "they" will engange some &lt;br&gt;&gt; super-powers to bring evidence, that \
this 300GB disk is not full with &lt;br&gt;&gt; "random" but with "encrypted data" and \
therefor it "must be full of &lt;br&gt;&gt; mp3/pr0n/whatever". But as I write this I \
realize that in some countries &lt;br&gt;&gt; it's might not be even important what you've \
enrypted but the mere fact &lt;br&gt;&gt; *that* you've encrypted something could bring you \
in trouble.&lt;br&gt;&lt;br&gt;"The" evils have much simpler ways to "crack" your security, a \
common&lt;br&gt;way (rumors) is, that &lt;br&gt;&lt;br&gt;- "they" grab all your computer staff&lt;br&gt;- \
see its encrypted&lt;br&gt;- return the computer&lt;br&gt;- ... with an keylogger, small on the \
mainboard/keyboard/usb-bus/...&lt;br&gt;- then, come about 2 weeks/months later \
again&lt;br&gt;&lt;br&gt;&lt;br&gt;and of course there always is this moment .. when somebody tells you \
"now  its&lt;br&gt;your choice, you may cooperate and get a small punishment, or you get \
all&lt;br&gt;and more if we're able to read your disk other ways"&lt;br&gt;&lt;br&gt;-- &lt;br&gt;Florian \
Reitmeir&lt;br&gt;&lt;br&gt;-&lt;br&gt;Linux-crypto:  cryptography in and on the Linux \
system&lt;br&gt;Archive:       \
http://mail.nl.linux.org/linux-crypto/&lt;br&gt;&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;p&gt;   &lt;hr \
size=1&gt;Do you Yahoo!?&lt;br&gt; Everyone is raving about the &lt;a \
href="http://us.rd.yahoo.com/evt=40791/*http://advision.webevents.yahoo.com/handraisers"&gt; \
all-new Yahoo! Mail Beta.&lt;/a&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060619112727</emailId><senderName>Florian Reitmeir</senderName><senderEmail>fr@3node.com</senderEmail><timestampReceived>2006-06-19 11:27:27-0400</timestampReceived><subject>Re: Distinguishability of encrypted partition</subject><body>

Hi,

On Mon, 19 Jun 2006, Phil H wrote:
&gt; Thanks for the replies - only just saw them since my yahoo bulk folder is so full \
&gt; of junk.

&gt; I suppose I was thinking of watermark-type attacks, showing there actually is a \
&gt; filesystem in that randomness (my understanding is that v3.x loop-aes should be \
&gt; immune to these?), or some type of mathematical investigation designed to show the \
&gt; partition has not been recently overwritten by shred or somesuch but has a \
&gt; suspicious form of "randomness" (if such an investigation exists that is). 

i'cant help it, but i think the discussion about possible watermark attempts
on are disk useless.

Watermark attempts has to assume the cipher/modes you use... 

Normally there is enough evidence on a PC/Laptop that there is Crypto..
somewhere is a kernel with initrd, and normally such a pc asks for a password
after boot.

Not to mention the rest of the computer hardware, like the SMART-disk log
which counts nicely how mant houres the drive was used, how many errors
happend, and maybe makes some read/write stats.

Much more interessting would it be to work on support for PKCS#11 USB tokens
to get rid of the user-password. Only a minority boot from an crypto disk, so a
trojan or "other" software can easily sniff your password (with X11 this is
really very simple).

&gt; So my initial assumption was probably correct - it's the extraneous factors (fstab, \
&gt; having encryption software, etc) that probably remain the practical indicators.

&gt; Christian Kujau &lt;evil@g-house.de&gt; wrote: On Wed, 14 Jun 2006, Florian Reitmeir \
&gt; wrote:
&gt; &gt; "The" evils have much simpler ways to "crack" your security, a common
&gt; &gt; way (rumors) is, that
&gt; &gt; 
&gt; &gt; - "they" grab all your computer staff
&gt; &gt; - see its encrypted
&gt; 
&gt; s/see/assume/  ...as they can't be sure and probably won't hire a 
&gt; cryptoexpert to prove this, methinks.
&gt; 
&gt; &gt; - return the computer
&gt; &gt; - ... with an keylogger, small on the mainboard/keyboard/usb-bus/...
&gt; &gt; - then, come about 2 weeks/months later again
&gt; 
&gt; there we go again: triple-aes-1024 won't help if the cryptosystem is lame

-- 
Florian Reitmeir

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060607193800</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-07 19:38:00-0400</timestampReceived><subject>Re: [PATCH  3/4] Twofish cipher - i586 assembler</subject><body>

On Sunday 04 June 2006 15:16, Joachim Fritschi wrote:
&gt; This patch adds the twofish i586 assembler routine. 
&gt; 
&gt; Changes since the last version:
&gt; - The keysetup is now handled by the twofish_common.c (see patch 1 )
&gt; 
&gt; Correctness was verified with the tcrypt module and automated test scripts.
My first mail was wordwrapped. This one should be unwrapped and working.
It also includes minor readability fixes.

Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

diff -uprN linux-2.6.17-rc5.twofish2/arch/i386/crypto/Makefile \
                linux-2.6.17-rc5.twofish3/arch/i386/crypto/Makefile
--- linux-2.6.17-rc5.twofish2/arch/i386/crypto/Makefile	2006-05-30 19:43:48.768000198 \
                +0200
+++ linux-2.6.17-rc5.twofish3/arch/i386/crypto/Makefile	2006-05-30 20:06:10.880715217 \
+0200 @@ -5,5 +5,8 @@
 #

 obj-$(CONFIG_CRYPTO_AES_586) += aes-i586.o
+obj-$(CONFIG_CRYPTO_TWOFISH_586) += twofish-i586.o

 aes-i586-y := aes-i586-asm.o aes.o
+twofish-i586-y := twofish-i586-asm.o twofish.o ../../../crypto/twofish_common.o
+
diff -uprN linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish.c \
                linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish.c
--- linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish.c	1970-01-01 \
                01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish.c	2006-05-30 \
20:04:16.279682770 +0200 @@ -0,0 +1,88 @@
+/*
+ *  Glue Code for optimized 586 assembler version of TWOFISH
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+
+asmlinkage void twofish_enc_blk(void *ctx, u8 *dst, const u8 *src);
+
+asmlinkage void twofish_dec_blk(void *ctx, u8 *dst, const u8 *src);
+
+
+static struct crypto_alg alg = {
+	.cra_name           =   "twofish",
+	.cra_driver_name    =	"twofish-i586",
+        .cra_priority       =   200,
+	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize      =   TF_BLOCK_SIZE,
+	.cra_ctxsize        =   sizeof(struct twofish_ctx),
+	.cra_alignmask      =	3,
+	.cra_module         =   THIS_MODULE,
+	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
+	.cra_u              =   { .cipher = {
+	.cia_min_keysize    =   TF_MIN_KEY_SIZE,
+	.cia_max_keysize    =   TF_MAX_KEY_SIZE,
+	.cia_setkey         =   twofish_setkey,
+	.cia_encrypt        =   twofish_enc_blk,
+	.cia_decrypt        =   twofish_dec_blk } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION ("Twofish Cipher Algorithm, i586 asm optimized");
diff -uprN linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish-i586-asm.S \
                linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish-i586-asm.S
--- linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish-i586-asm.S	1970-01-01 \
                01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish-i586-asm.S	2006-06-07 \
17:35:12.626818884 +0200 @@ -0,0 +1,381 @@
+/***************************************************************************
+*   Copyright (C) 2006 by Joachim Fritschi, &lt;jfritschi@freenet.de&gt;        *
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+*   This program is distributed in the hope that it will be useful,       *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+*   GNU General Public License for more details.                          *
+*                                                                         *
+*   You should have received a copy of the GNU General Public License     *
+*   along with this program; if not, write to the                         *
+*   Free Software Foundation, Inc.,                                       *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+***************************************************************************/
+
+.file "twofish-i586-asm.S"
+.text
+
+/* return adress at 0 */
+
+#define in_blk    12  /* input byte array address parameter*/
+#define out_blk   8  /* output byte array address parameter*/
+#define ctx       4  /* Twofish context structure */
+
+#define a_offset	0
+#define b_offset	4
+#define c_offset	8
+#define d_offset	12
+
+/* Structure of the crypto context struct*/
+
+#define s0	0	/* S0 Array 256 Words each */
+#define s1	1024	/* S1 Array */
+#define s2	2048	/* S2 Array */
+#define s3	3072	/* S3 Array */
+#define w	4096	/* 8 whitening keys (word) */
+#define k	4128	/* key 1-32 ( word ) */
+
+
+
+
+/* register aliases for macro substitution */
+
+#define r0  eax
+#define r1  ebx
+#define r2  ecx
+#define r3  edx
+#define r4  esi
+#define r5  edi
+
+
+
+#define eaxl  al
+#define eaxh  ah
+#define ebxl  bl
+#define ebxh  bh
+#define ecxl  cl
+#define ecxh  ch
+#define edxl  dl
+#define edxh  dh
+
+
+#define _h(reg) reg##h
+#define h(reg) _h(reg)
+
+#define _l(reg) reg##l
+#define l(reg) _l(reg)
+
+/*load input word with whitening */
+
+#define get_input(input_adress,offset,dst,context)\
+	load_input(input_adress,offset,dst);\
+	input_whitening(dst,context,offset);
+
+#define get_dec_input(input_adress,offset,dst,context)\
+	load_dec_input(input_adress,offset,dst);\
+	dec_input_whitening(dst,context,offset);
+
+/* perform output whitening and save value. Old value is saved */
+#define process_output(dst,src,tmp,context,offset)\
+	output_whitening(src,tmp,context,offset);\
+	save_output(dst,offset,tmp);
+
+/* perform output whitening and save value. The old value is destoyed */
+#define destructive_process_output(dst,src,context,offset)\
+	destructive_output_whitening(src,context,offset);\
+	save_output(dst,offset,src);
+
+/* perform output whitening and save value. Old value is saved */
+#define process_dec_output(dst,src,tmp,context,offset)\
+	dec_output_whitening(src,tmp,context,offset);\
+	save_output(dst,offset,tmp);
+
+/* perform output whitening and save value. The old value is destoyed */
+#define destructive_process_dec_output(dst,src,context,offset)\
+	destructive_dec_output_whitening(src,context,offset);\
+	save_output(dst,offset,src);
+
+/* load input */
+#define load_input(input_adress,offset,dst)\
+	mov	offset(%input_adress), %dst;
+
+#define load_dec_input(input_adress,offset,dst)\
+	mov	offset(%input_adress), %dst;
+
+/* performs input whitening */
+#define input_whitening(src,context,offset)\
+	xor	w+offset(%context), %src;\
+
+#define dec_input_whitening(src,context,offset)\
+	xor	w+16+offset(%context), %src;
+
+/* performs decryption output whitening */
+/* Result is in dst, the original value is still intact */
+#define dec_output_whitening(src,dst,context,offset)\
+	mov	w+offset(%context), %dst;\
+	xor	%src,	%dst;
+
+/* performs encryption output whitening */
+/* Result is in dst, the original value is still intact */
+#define output_whitening(src,dst,context,offset)\
+	mov	w+16+offset(%context), %dst;\
+	xor	%src,	%dst;
+
+/* performs encryption output whitening */
+/* Result is in dst, the original value is destroyed */
+#define destructive_output_whitening(src,context,offset)\
+	xor	w+16+offset(%context), %src;\
+
+/* performs decryption output whitening */
+/* Result is in dst, the original value is destroyed */
+#define destructive_dec_output_whitening(src,context,offset)\
+	xor	w+offset(%context), %src;\
+
+/* save the output values */
+#define save_output(output_adress,offset,src)\
+	mov	%src,offset(%output_adress);\
+
+/* load sbox values */
+#define load_s(context,sbox,index,dst)\
+	xor	sbox(%context,%index,4),%dst;\
+
+/* performs "a" sbox transfomation */
+/* input value is still intact but rotatet */
+#define g1(context,input,dst,tmp)\
+	xor	%dst,		%dst;\
+ 	movzx	%l(input),	%tmp;\
+	load_s(context,s0,tmp,dst);\
+	movzx	%h(input),	%tmp;\
+	load_s(context,s1,	tmp,dst);\
+	ror	$16,		%input;\
+	movzx	%l(input),	%tmp;\
+	load_s(context,s2,tmp,dst);\
+	movzx	%h(input),	%tmp;\
+	load_s(context,s3,tmp,dst);\
+
+/* performs "b" sbox transfomation */
+/* input value is still intact but rotatet */
+#define g2(context,input,dst,tmp)\
+	xor	%dst,		%dst;\
+	movzx	%l(input),	%tmp;\
+	load_s(context,s1,tmp,dst);\
+	movzx	%h(input),	%tmp;\
+	load_s(context,s2,tmp,dst);\
+	ror	$16,		%input;\
+	movzx	%l(input),	%tmp;\
+	load_s(context,s3,tmp,dst);\
+	movzx	%h(input),	%tmp;\
+	load_s(context,s0,tmp,dst);\
+	;
+
+/* Pseudo Harmann Transfomation */
+#define pht(a,b)\
+	add	%b,	%a;\
+	add	%a,	%b;
+
+/* Adds the round keys to a and b */
+#define round_key(context,a,b,round)\
+	add	k+round(%context),%a;\
+	add	k+4+round(%context),%b;\
+
+
+/* Input in a and b , output in fa fb */
+/* a and b a prerotate for the next round */
+#define f_function(context,a,b,fa,fb,tmp3,round)\
+	g1(context,a,fa,tmp3);\
+	g2(context,b,fb,tmp3);\
+	ror	$16,	%a;\
+	ror	$15,	%b;\
+	pht(fa,fb);\
+	round_key(context,fa,fb,round);
+
+
+/* Input in a and b , output in fa fb */
+/* a and b a prerotate for the next round */
+#define reverse_f_function(context,a,b,fa,fb,tmp3,round)\
+	g1(context,a,fa,tmp3);\
+	g2(context,b,fb,tmp3);\
+	ror	$15,	%a;\
+	ror	$16,	%b;\
+	pht(fa,fb);\
+	round_key(context,fa,fb,round);
+
+
+/* Output in a and b */
+/* olda contains the a of the round before, cuts down
+stack use to one push / pop per round for the oldb */
+/* b is alread pre rotated (rol 1) in the f funtion to save one instruction */
+#define round(context,a,b,tmp1,tmp2,tmp3,olda,round)\
+	f_function(context,a,b,tmp1,tmp2,tmp3,round);\
+	mov	%b,	%tmp3;\
+	pop	%b;\
+	push	%tmp3;\
+	xor	%tmp2,	%b;\
+	xor	%tmp1,	%olda;\
+	ror	$1,	%olda;
+
+
+/* Output in a and b */
+/* olda contains the a of the round before, cuts down
+stack use to one push / pop per round for the oldb */
+/* a is alread pre rotated (rol 1) in the f funtion to save one instruction */
+#define dec_round(context,a,b,tmp1,tmp2,tmp3,olda,round)\
+	reverse_f_function(context,a,b,tmp1,tmp2,tmp3,round);\
+	xor	%tmp1,	%olda;\
+	mov	%b,	%tmp3;\
+	pop	%b;\
+	push	%tmp3;\
+	xor	%tmp2,	%b;\
+	ror	$1,	%b;
+
+
+
+.align 4
+.global twofish_enc_blk
+.global twofish_dec_blk
+
+
+
+twofish_enc_blk:
+	/* save registers according to calling convention*/
+	push	%ebp
+	push    %r1
+	push    %esi
+	push    %edi
+
+	/* abuse the base pointer: set new base bointer to the crypto ctx */
+	mov	ctx + 16(%esp),	%ebp
+	mov     in_blk+16(%esp),%r5	/* input adress in r5 */
+
+	get_input(r5,a_offset,r0,ebp);
+	get_input(r5,b_offset,r1,ebp);
+
+	/* To save a few instructions round 1 is unrolled */
+
+	f_function(ebp,r0,r1,r2,r3,r4,0);	//ouput in r2 r3
+	push	%r1;
+
+	get_input(r5,c_offset,r1,ebp);
+	get_input(r5,d_offset,r4,ebp);
+	xor	%r1,	%r2;\
+	ror	$1,	%r2;\
+	rol	$1,	%r4;\
+	xor	%r4,	%r3;
+
+
+	round(ebp,r2,r3,r4,r5,r1,r0,1*8);
+	round(ebp,r0,r3,r4,r5,r1,r2,2*8);
+	round(ebp,r2,r3,r4,r5,r1,r0,3*8);
+	round(ebp,r0,r3,r4,r5,r1,r2,4*8);
+	round(ebp,r2,r3,r4,r5,r1,r0,5*8);
+	round(ebp,r0,r3,r4,r5,r1,r2,6*8);
+	round(ebp,r2,r3,r4,r5,r1,r0,7*8);
+	round(ebp,r0,r3,r4,r5,r1,r2,8*8);
+	round(ebp,r2,r3,r4,r5,r1,r0,9*8);
+	round(ebp,r0,r3,r4,r5,r1,r2,10*8);
+	round(ebp,r2,r3,r4,r5,r1,r0,11*8);
+	round(ebp,r0,r3,r4,r5,r1,r2,12*8);
+	round(ebp,r2,r3,r4,r5,r1,r0,13*8);
+	round(ebp,r0,r3,r4,r5,r1,r2,14*8);
+
+	/* To save a few instructions round 15 is unrolled */
+
+	mov	out_blk+20(%esp),%r1;
+	process_output(r1,r2,r4,ebp,a_offset);
+	process_output(r1,r3,r4,ebp,b_offset);
+	g1(ebp,r2,r4,r1);
+	g2(ebp,r3,r5,r1);
+	pht(r4,r5);
+	round_key(ebp,r4,r5,15*8);
+	pop	%r1;
+	xor	%r5,	%r1;
+	xor	%r4,	%r0;
+	ror	$1,	%r0;
+
+	mov	out_blk+16(%esp),%r3
+	destructive_process_output(r3,r0,ebp,c_offset);
+	destructive_process_output(r3,r1,ebp,d_offset);
+
+	pop	%edi
+	pop	%esi
+	pop	%r1
+	pop	%ebp
+	mov	$1,%r0
+	ret
+
+twofish_dec_blk:
+	/* save  registers according to calling convention*/
+	push	%ebp
+	push    %r1
+	push    %esi
+	push    %edi
+
+	/* abuse the base pointer: set new base bointer to the crypto ctx */
+	mov	ctx + 16(%esp),	%ebp
+	mov     in_blk+16(%esp),%r5	/* output adress in r5 */
+
+	/* To save a few instructions round 15 is unrolled */
+	get_dec_input(r5,a_offset,r0,ebp);
+	get_dec_input(r5,b_offset,r1,ebp);
+
+	reverse_f_function(ebp,r0,r1,r2,r3,r4,15*8);
+
+        push %r1; /* save oldb for next rount */
+
+	get_dec_input(r5,c_offset,r1,ebp);
+	get_dec_input(r5,d_offset,r4,ebp);
+	xor	%r4,	%r3;
+	ror	$1,	%r3;
+	rol	$1,	%r1;
+	xor	%r1,	%r2;
+
+	dec_round(ebp,r2,r3,r4,r5,r1,r0,14*8);
+	dec_round(ebp,r0,r3,r4,r5,r1,r2,13*8);
+	dec_round(ebp,r2,r3,r4,r5,r1,r0,12*8);
+	dec_round(ebp,r0,r3,r4,r5,r1,r2,11*8);
+	dec_round(ebp,r2,r3,r4,r5,r1,r0,10*8);
+	dec_round(ebp,r0,r3,r4,r5,r1,r2,9*8);
+	dec_round(ebp,r2,r3,r4,r5,r1,r0,8*8);
+	dec_round(ebp,r0,r3,r4,r5,r1,r2,7*8);
+	dec_round(ebp,r2,r3,r4,r5,r1,r0,6*8);
+	dec_round(ebp,r0,r3,r4,r5,r1,r2,5*8);
+	dec_round(ebp,r2,r3,r4,r5,r1,r0,4*8);
+	dec_round(ebp,r0,r3,r4,r5,r1,r2,3*8);
+	dec_round(ebp,r2,r3,r4,r5,r1,r0,2*8);
+	dec_round(ebp,r0,r3,r4,r5,r1,r2,8);
+
+	/* To save a few instructions round 0 is unrolled */
+	mov	out_blk+20(%esp),%r1;
+	process_dec_output(r1,r2,r4,ebp,a_offset);
+	process_dec_output(r1,r3,r4,ebp,b_offset);
+	g1(ebp,r2,r4,r1);
+	g2(ebp,r3,r5,r1);
+	pht(r4,r5);
+	round_key(ebp,r4,r5,0);
+
+	pop	%r1;
+	xor	%r1,	%r5
+	ror	$1,	%r5
+	xor	%r0,	%r4
+
+
+
+	mov	out_blk+16(%esp),%r3
+	destructive_process_dec_output(r3,r4,ebp,c_offset);
+	destructive_process_dec_output(r3,r5,ebp,d_offset);
+
+	pop	%edi
+	pop	%esi
+	pop	%r1
+	pop	%ebp
+	mov	$1,%r0
+	ret
+
+
+
+
diff -uprN linux-2.6.17-rc5.twofish2/crypto/Kconfig \
                linux-2.6.17-rc5.twofish3/crypto/Kconfig
--- linux-2.6.17-rc5.twofish2/crypto/Kconfig	2006-05-30 19:44:02.607579102 +0200
+++ linux-2.6.17-rc5.twofish3/crypto/Kconfig	2006-05-30 20:00:47.841035197 +0200
@@ -142,6 +142,20 @@ config CRYPTO_TWOFISH
 	  See also:
 	  &lt;http://www.schneier.com/twofish.html&gt;

+config CRYPTO_TWOFISH_586
+	tristate "Twofish cipher algorithms (i586)"
+	depends on CRYPTO &amp;&amp; ((X86 || UML_X86) &amp;&amp; !64BIT)
+	help
+	  Twofish cipher algorithm.
+
+	  Twofish was submitted as an AES (Advanced Encryption Standard)
+	  candidate cipher by researchers at CounterPane Systems.  It is a
+	  16 round block cipher supporting key sizes of 128, 192, and 256
+	  bits.
+
+	  See also:
+	  &lt;http://www.schneier.com/twofish.html&gt;
+
 config CRYPTO_SERPENT
 	tristate "Serpent cipher algorithm"
 	depends on CRYPTO
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


</body></email><email><emailId>20060616115954</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-16 11:59:54-0400</timestampReceived><subject>Re: [PATCH  3/4] Twofish cipher - i586 assembler</subject><body>

Update patch for the i586 twofish assembler implementation.

Changes since last version:
-Updated to the new twofish_common setup
-Complete rewrite of the code  according to the feedback i recieved for the
x86_64 patch (thanks linux@horizon.com)

The patch passed the trycpt tests and automated filesystem tests.
This rewrite resulted in some nice perfomance increase over my last patch.

Short summary of the tcrypt benchmarks:

Twofish Assembler vs. Twofish C (256bit 8kb block CBC)
encrypt: -33% Cycles
decrypt: -45% Cycles

Twofish Assembler vs. AES Assembler (128bit 8kb block CBC)
encrypt: +3%  Cycles
decrypt: -22% Cycles

Twofish Assembler vs. AES Assembler (256bit 8kb block CBC)
encrypt: -20% Cycles
decrypt: -36% Cycles

Full Output:
http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-twofish-asm-i586.txt
http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-twofish-c-i586.txt
http://homepages.tu-darmstadt.de/~fritschi/twofish/tcrypt-speed-aes-asm-i586.txt


Here is another bonnie++ benchmark with encrypted filesystems. All runs with
the twofish assembler modules max out the drivespeed. It should give some
idea what the module can do for encrypted filesystem performance even though
you can't see the full numbers.

http://homepages.tu-darmstadt.de/~fritschi/twofish/output_20060611_205432_x86.html


Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

diff -uprN linux-2.6.17-rc5.twofish2/arch/i386/crypto/Makefile \
                linux-2.6.17-rc5.twofish3/arch/i386/crypto/Makefile
--- linux-2.6.17-rc5.twofish2/arch/i386/crypto/Makefile	2006-06-11 15:58:36.991988374 \
                +0200
+++ linux-2.6.17-rc5.twofish3/arch/i386/crypto/Makefile	2006-06-11 16:05:51.675813834 \
+0200 @@ -5,5 +5,8 @@
 # 
 
 obj-$(CONFIG_CRYPTO_AES_586) += aes-i586.o
+obj-$(CONFIG_CRYPTO_TWOFISH_586) += twofish-i586.o
 
 aes-i586-y := aes-i586-asm.o aes.o
+twofish-i586-y := twofish-i586-asm.o twofish.o
+
diff -uprN linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish.c \
                linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish.c
--- linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish.c	1970-01-01 \
                01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish.c	2006-06-11 \
16:03:56.669852049 +0200 @@ -0,0 +1,88 @@
+/*
+ *  Glue Code for optimized 586 assembler version of TWOFISH
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+
+asmlinkage void twofish_enc_blk(void *ctx, u8 *dst, const u8 *src);
+
+asmlinkage void twofish_dec_blk(void *ctx, u8 *dst, const u8 *src);
+
+
+static struct crypto_alg alg = {
+	.cra_name           =   "twofish",
+	.cra_driver_name    =	"twofish-i586",
+        .cra_priority       =   200,
+	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize      =   TF_BLOCK_SIZE,
+	.cra_ctxsize        =   sizeof(struct twofish_ctx),
+	.cra_alignmask      =	3,
+	.cra_module         =   THIS_MODULE,
+	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
+	.cra_u              =   { .cipher = {
+	.cia_min_keysize    =   TF_MIN_KEY_SIZE,
+	.cia_max_keysize    =   TF_MAX_KEY_SIZE,
+	.cia_setkey         =   twofish_setkey,
+	.cia_encrypt        =   twofish_enc_blk,
+	.cia_decrypt        =   twofish_dec_blk } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION ("Twofish Cipher Algorithm, i586 asm optimized");
diff -uprN linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish-i586-asm.S \
                linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish-i586-asm.S
--- linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish-i586-asm.S	1970-01-01 \
                01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish-i586-asm.S	2006-06-11 \
21:49:26.508548778 +0200 @@ -0,0 +1,404 @@
+/***************************************************************************
+*   Copyright (C) 2006 by Joachim Fritschi, &lt;jfritschi@freenet.de&gt;        *
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+*   This program is distributed in the hope that it will be useful,       *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+*   GNU General Public License for more details.                          *
+*                                                                         *
+*   You should have received a copy of the GNU General Public License     *
+*   along with this program; if not, write to the                         *
+*   Free Software Foundation, Inc.,                                       *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+***************************************************************************/
+
+.file "twofish-i586-asm.S"
+.text
+
+/* return adress at 0 */
+
+#define in_blk    12  /* input byte array address parameter*/
+#define out_blk   8  /* output byte array address parameter*/
+#define ctx       4  /* Twofish context structure */
+
+#define a_offset	0
+#define b_offset	4
+#define c_offset	8
+#define d_offset	12
+
+/* Structure of the crypto context struct*/
+
+#define s0	0	/* S0 Array 256 Words each */
+#define s1	1024	/* S1 Array */
+#define s2	2048	/* S2 Array */
+#define s3	3072	/* S3 Array */
+#define w	4096	/* 8 whitening keys (word) */
+#define k	4128	/* key 1-32 ( word ) */
+
+/* define a few register aliases to allow macro substitution */
+
+#define R0D    %eax
+#define R0B    %al
+#define R0H    %ah
+
+#define R1D    %ebx
+#define R1B    %bl
+#define R1H    %bh
+
+#define R2D    %ecx
+#define R2B    %cl
+#define R2H    %ch
+
+#define R3D    %edx
+#define R3B    %dl
+#define R3H    %dh
+
+
+/* performs input whitening */
+#define input_whitening(src,context,offset)\
+	xor	w+offset(context),	src;
+
+/* performs input whitening */
+#define output_whitening(src,context,offset)\
+	xor	w+16+offset(context),	src;
+
+/*
+a input register containing a (rotated 16)
+b input register containing b
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+*/
+#define encrypt_round(a,b,c,d,round)\
+movzx	b ## B,		%edi;\
+mov	s1(%ebp,%edi,4),d ## D;\
+movzx	a ## B,		%edi;\
+mov	s2(%ebp,%edi,4),%esi;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%ebp,%edi,4),d ## D;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%ebp,%edi,4),%esi;\
+movzx	b ## B,		%edi;\
+xor	s3(%ebp,%edi,4),d ## D;\
+movzx	a ## B,		%edi;\
+xor	(%ebp,%edi,4),	%esi;\
+movzx	b ## H,		%edi;\
+ror	$15,		b ## D;\
+xor	(%ebp,%edi,4),	d ## D;\
+movzx	a ## H,		%edi;\
+xor	s1(%ebp,%edi,4),%esi;\
+add	d ## D,		%esi;\
+add	%esi,		d ## D;\
+add	k+round(%ebp),	%esi;\
+pop	%edi;\
+push	b ## D;\
+xor	%esi,		c ## D;\
+rol	$15,		c ## D;\
+add	k+4+round(%ebp),d ## D;\
+xor	%edi,		d ## D;
+
+
+/*
+a input register containing a
+b input register containing b
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+*/
+#define encrypt_first_round(a,b,c,d,round)\
+movzx	a ## B,		%edi;\
+mov	(%ebp,%edi,4),	%esi;\
+movzx	b ## B,		%edi;\
+mov	s1(%ebp,%edi,4),d ## D;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s1(%ebp,%edi,4),%esi;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%ebp,%edi,4),d ## D;\
+movzx	a ## B,		%edi;\
+xor	s2(%ebp,%edi,4),%esi;\
+movzx	b ## B,		%edi;\
+xor	s3(%ebp,%edi,4),d ## D;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%ebp,%edi,4),%esi;\
+movzx	b ## H,		%edi;\
+ror	$15,		b ## D;\
+xor	(%ebp,%edi,4),	d ## D;\
+pop	%edi;\
+add	d ## D,		%esi;\
+add	%esi,		d ## D;\
+add	k+round(%ebp),	%esi;\
+push	b ## D;\
+xor	%esi,		c ## D;\
+rol	$15,		c ## D;\
+add	k+4+round(%ebp),d ## D;\
+xor	%edi,		d ## D;
+
+#define encrypt_last_round(a,b,c,d,round)\
+movzx	b ## B,		%edi;\
+mov	s1(%ebp,%edi,4),d ## D;\
+movzx	a ## B,		%edi;\
+mov	s2(%ebp,%edi,4),%esi;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%ebp,%edi,4),d ## D;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%ebp,%edi,4),%esi;\
+movzx	b ## B,		%edi;\
+xor	s3(%ebp,%edi,4),d ## D;\
+movzx	a ## B,		%edi;\
+xor	(%ebp,%edi,4),	%esi;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%ebp,%edi,4),	d ## D;\
+movzx	a ## H,		%edi;\
+xor	s1(%ebp,%edi,4),%esi;\
+add	d ## D,		%esi;\
+add	%esi,		d ## D;\
+add	k+round(%ebp),	%esi;\
+pop	%edi;\
+xor	%esi,		c ## D;\
+ror	$1,		c ## D;\
+add	k+4+round(%ebp),d ## D;\
+xor	%edi,		d ## D;
+
+/*
+a input register containing a
+b input register containing b (rotated 16)
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+*/
+#define decrypt_round(a,b,c,d,round)\
+movzx	a ## B,		%edi;\
+mov	(%ebp,%edi,4),	%esi;\
+movzx	b ## B,		%edi;\
+mov	s3(%ebp,%edi,4),d ## D;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s1(%ebp,%edi,4),%esi;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%ebp,%edi,4),	d ## D;\
+movzx	a ## B,		%edi;\
+xor	s2(%ebp,%edi,4),%esi;\
+movzx	b ## B,		%edi;\
+xor	s1(%ebp,%edi,4),d ## D;\
+movzx	a ## H,		%edi;\
+ror	$15,		a ## D;\
+xor	s3(%ebp,%edi,4),%esi;\
+movzx	b ## H,		%edi;\
+xor	s2(%ebp,%edi,4),d ## D;\
+add	d ## D,		%esi;\
+add	%esi,		d ## D;\
+add	k+4+round(%ebp),d ## D;\
+pop	%edi;\
+push	b ## D;\
+xor	%edi,		d ## D;\
+rol	$15,		d ## D;\
+add	k+round(%ebp),	%esi;\
+xor	%esi,		c ## D;
+
+
+/*
+a input register containing a
+b input register containing b
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+*/
+#define decrypt_first_round(a,b,c,d,round)\
+movzx	a ## B,		%edi;\
+mov	(%ebp,%edi,4),	%esi;\
+movzx	b ## B,		%edi;\
+mov	s1(%ebp,%edi,4),d ## D;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s1(%ebp,%edi,4),%esi;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%ebp,%edi,4),d ## D;\
+movzx	a ## B,		%edi;\
+xor	s2(%ebp,%edi,4),%esi;\
+movzx	b ## B,		%edi;\
+xor	s3(%ebp,%edi,4),d ## D;\
+movzx	a ## H,		%edi;\
+ror	$15,		a ## D;\
+xor	s3(%ebp,%edi,4),%esi;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%ebp,%edi,4),d ## D;\
+pop	%edi;\
+add	d ## D,		%esi;\
+add	%esi,		d ## D;\
+add	k+4+round(%ebp),d ## D;\
+xor	%edi,		d ## D;\
+rol	$15,		d ## D;\
+push	b ## D;\
+add	k+round(%ebp),	%esi;\
+xor	%esi,		c ## D;
+
+
+/*
+a input register containing a
+b input register containing b (rotated 16)
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+*/
+#define decrypt_last_round(a,b,c,d,round)\
+movzx	a ## B,		%edi;\
+mov	(%ebp,%edi,4),	%esi;\
+movzx	b ## B,		%edi;\
+mov	s3(%ebp,%edi,4),d ## D;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s1(%ebp,%edi,4),%esi;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%ebp,%edi,4),	d ## D;\
+movzx	a ## B,		%edi;\
+xor	s2(%ebp,%edi,4),%esi;\
+movzx	b ## B,		%edi;\
+xor	s1(%ebp,%edi,4),d ## D;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%ebp,%edi,4),%esi;\
+movzx	b ## H,		%edi;\
+xor	s2(%ebp,%edi,4),d ## D;\
+pop	%edi;\
+add	d ## D,		%esi;\
+add	%esi,		d ## D;\
+add	k+4+round(%ebp),d ## D;\
+xor	%edi,		d ## D;\
+ror	$1,		d ## D;\
+add	k+round(%ebp),	%esi;\
+xor	%esi,		c ## D;
+	
+.align 4
+.global twofish_enc_blk
+.global twofish_dec_blk
+
+
+
+twofish_enc_blk:
+	push	%ebp			/* save registers according to calling convention*/
+	push    %ebx
+	push    %esi			
+	push    %edi
+		
+		
+	mov	ctx + 16(%esp),	%ebp	/* abuse the base pointer: set new base bointer to the \
crypto ctx */ +	mov     in_blk+16(%esp),%edi	/* input adress in edi */
+
+	mov	(%edi),		%eax
+	mov	b_offset(%edi),	%ebx
+	mov	c_offset(%edi),	%ecx
+	mov	d_offset(%edi),	%edx
+	input_whitening(%eax,%ebp,a_offset)
+	input_whitening(%ebx,%ebp,b_offset)
+	input_whitening(%ecx,%ebp,c_offset)
+	input_whitening(%edx,%ebp,d_offset)
+	rol	$1,	%edx
+	push	%edx
+
+	encrypt_first_round(R0,R1,R2,R3,0);
+	encrypt_round(R2,R3,R0,R1,8);
+	encrypt_round(R0,R1,R2,R3,2*8);
+	encrypt_round(R2,R3,R0,R1,3*8);
+	encrypt_round(R0,R1,R2,R3,4*8);
+	encrypt_round(R2,R3,R0,R1,5*8);
+	encrypt_round(R0,R1,R2,R3,6*8);
+	encrypt_round(R2,R3,R0,R1,7*8);
+	encrypt_round(R0,R1,R2,R3,8*8);
+	encrypt_round(R2,R3,R0,R1,9*8);
+	encrypt_round(R0,R1,R2,R3,10*8);
+	encrypt_round(R2,R3,R0,R1,11*8);
+	encrypt_round(R0,R1,R2,R3,12*8);
+	encrypt_round(R2,R3,R0,R1,13*8);
+	encrypt_round(R0,R1,R2,R3,14*8);
+	encrypt_last_round(R2,R3,R0,R1,15*8);
+
+
+	output_whitening(%eax,%ebp,c_offset)
+	output_whitening(%ebx,%ebp,d_offset)
+	output_whitening(%ecx,%ebp,a_offset)
+	output_whitening(%edx,%ebp,b_offset)
+	mov	out_blk+16(%esp),%edi;
+	mov	%eax,		c_offset(%edi)
+	mov	%ebx,		d_offset(%edi)
+	mov	%ecx,		(%edi)
+	mov	%edx,		b_offset(%edi)
+
+	pop	%edi
+	pop	%esi
+	pop	%ebx
+	pop	%ebp
+	mov	$1,	%eax
+	ret
+	
+twofish_dec_blk:	
+	push	%ebp			/* save registers according to calling convention*/
+	push    %ebx
+	push    %esi			
+	push    %edi
+		
+		
+	mov	ctx + 16(%esp),	%ebp	/* abuse the base pointer: set new base bointer to the \
crypto ctx */ +	mov     in_blk+16(%esp),%edi	/* input adress in edi */
+
+	mov	(%edi),		%eax
+	mov	b_offset(%edi),	%ebx
+	mov	c_offset(%edi),	%ecx
+	mov	d_offset(%edi),	%edx
+	output_whitening(%eax,%ebp,a_offset)
+	output_whitening(%ebx,%ebp,b_offset)
+	output_whitening(%ecx,%ebp,c_offset)
+	output_whitening(%edx,%ebp,d_offset)
+	rol	$1,	%ecx
+	push	%edx
+
+	decrypt_first_round(R0,R1,R2,R3,15*8);
+	decrypt_round(R2,R3,R0,R1,14*8);
+	decrypt_round(R0,R1,R2,R3,13*8);
+	decrypt_round(R2,R3,R0,R1,12*8);
+	decrypt_round(R0,R1,R2,R3,11*8);
+	decrypt_round(R2,R3,R0,R1,10*8);
+	decrypt_round(R0,R1,R2,R3,9*8);
+	decrypt_round(R2,R3,R0,R1,8*8);
+	decrypt_round(R0,R1,R2,R3,7*8);
+	decrypt_round(R2,R3,R0,R1,6*8);
+	decrypt_round(R0,R1,R2,R3,5*8);
+	decrypt_round(R2,R3,R0,R1,4*8);
+	decrypt_round(R0,R1,R2,R3,3*8);
+	decrypt_round(R2,R3,R0,R1,2*8);
+	decrypt_round(R0,R1,R2,R3,1*8);
+	decrypt_last_round(R2,R3,R0,R1,0);
+
+
+	input_whitening(%eax,%ebp,c_offset)
+	input_whitening(%ebx,%ebp,d_offset)
+	input_whitening(%ecx,%ebp,a_offset)
+	input_whitening(%edx,%ebp,b_offset)
+	mov	out_blk+16(%esp),%edi;
+	mov	%eax,		c_offset(%edi)
+	mov	%ebx,		d_offset(%edi)
+	mov	%ecx,		(%edi)
+	mov	%edx,		b_offset(%edi)
+
+	pop	%edi
+	pop	%esi
+	pop	%ebx
+	pop	%ebp
+	mov	$1,	%eax
+	ret
diff -uprN linux-2.6.17-rc5.twofish2/crypto/Kconfig \
                linux-2.6.17-rc5.twofish3/crypto/Kconfig
--- linux-2.6.17-rc5.twofish2/crypto/Kconfig	2006-06-11 15:58:39.219982140 +0200
+++ linux-2.6.17-rc5.twofish3/crypto/Kconfig	2006-06-11 16:05:19.938782275 +0200
@@ -150,6 +150,21 @@ config CRYPTO_TWOFISH_COMMON
 	  Common parts of the Twofish cipher algorithm.
 	  
 
+config CRYPTO_TWOFISH_586
+	tristate "Twofish cipher algorithms (i586)"
+	depends on CRYPTO &amp;&amp; ((X86 || UML_X86) &amp;&amp; !64BIT)
+	select CRYPTO_TWOFISH_COMMON
+	help
+	  Twofish cipher algorithm.
+
+	  Twofish was submitted as an AES (Advanced Encryption Standard)
+	  candidate cipher by researchers at CounterPane Systems.  It is a
+	  16 round block cipher supporting key sizes of 128, 192, and 256
+	  bits.
+
+	  See also:
+	  &lt;http://www.schneier.com/twofish.html&gt;
+
 config CRYPTO_SERPENT
 	tristate "Serpent cipher algorithm"
 	depends on CRYPTO

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


</body></email><email><emailId>20060617103035</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-17 10:30:35-0400</timestampReceived><subject>Re: [PATCH  3/4] Twofish cipher - i586 assembler</subject><body>

After recieving some more feedback from linux@horizon.com, i have revised my
patch a bit and done some cosmetic changes. The first_round macros are now 
eliminated and the pop instruction has been moved forward a bit.

The patch passed the trycpt tests and automated filesystem tests.


Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

diff -uprN linux-2.6.17-rc5.twofish2/arch/i386/crypto/Makefile \
                linux-2.6.17-rc5.twofish3/arch/i386/crypto/Makefile
--- linux-2.6.17-rc5.twofish2/arch/i386/crypto/Makefile	2006-06-11 15:58:36.991988374 \
                +0200
+++ linux-2.6.17-rc5.twofish3/arch/i386/crypto/Makefile	2006-06-11 16:05:51.675813834 \
+0200 @@ -5,5 +5,8 @@
 # 
 
 obj-$(CONFIG_CRYPTO_AES_586) += aes-i586.o
+obj-$(CONFIG_CRYPTO_TWOFISH_586) += twofish-i586.o
 
 aes-i586-y := aes-i586-asm.o aes.o
+twofish-i586-y := twofish-i586-asm.o twofish.o
+
diff -uprN linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish.c \
                linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish.c
--- linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish.c	1970-01-01 \
                01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish.c	2006-06-11 \
16:03:56.669852049 +0200 @@ -0,0 +1,88 @@
+/*
+ *  Glue Code for optimized 586 assembler version of TWOFISH
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+
+asmlinkage void twofish_enc_blk(void *ctx, u8 *dst, const u8 *src);
+
+asmlinkage void twofish_dec_blk(void *ctx, u8 *dst, const u8 *src);
+
+
+static struct crypto_alg alg = {
+	.cra_name           =   "twofish",
+	.cra_driver_name    =	"twofish-i586",
+        .cra_priority       =   200,
+	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize      =   TF_BLOCK_SIZE,
+	.cra_ctxsize        =   sizeof(struct twofish_ctx),
+	.cra_alignmask      =	3,
+	.cra_module         =   THIS_MODULE,
+	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
+	.cra_u              =   { .cipher = {
+	.cia_min_keysize    =   TF_MIN_KEY_SIZE,
+	.cia_max_keysize    =   TF_MAX_KEY_SIZE,
+	.cia_setkey         =   twofish_setkey,
+	.cia_encrypt        =   twofish_enc_blk,
+	.cia_decrypt        =   twofish_dec_blk } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION ("Twofish Cipher Algorithm, i586 asm optimized");
diff -uprN linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish-i586-asm.S \
                linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish-i586-asm.S
--- linux-2.6.17-rc5.twofish2/arch/i386/crypto/twofish-i586-asm.S	1970-01-01 \
                01:00:00.000000000 +0100
+++ linux-2.6.17-rc5.twofish3/arch/i386/crypto/twofish-i586-asm.S	2006-06-17 \
11:08:32.536993468 +0200 @@ -0,0 +1,331 @@
+/***************************************************************************
+*   Copyright (C) 2006 by Joachim Fritschi, &lt;jfritschi@freenet.de&gt;        *
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+*   This program is distributed in the hope that it will be useful,       *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+*   GNU General Public License for more details.                          *
+*                                                                         *
+*   You should have received a copy of the GNU General Public License     *
+*   along with this program; if not, write to the                         *
+*   Free Software Foundation, Inc.,                                       *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+***************************************************************************/
+
+.file "twofish-i586-asm.S"
+.text
+
+/* return adress at 0 */
+
+#define in_blk    12  /* input byte array address parameter*/
+#define out_blk   8  /* output byte array address parameter*/
+#define ctx       4  /* Twofish context structure */
+
+#define a_offset	0
+#define b_offset	4
+#define c_offset	8
+#define d_offset	12
+
+/* Structure of the crypto context struct*/
+
+#define s0	0	/* S0 Array 256 Words each */
+#define s1	1024	/* S1 Array */
+#define s2	2048	/* S2 Array */
+#define s3	3072	/* S3 Array */
+#define w	4096	/* 8 whitening keys (word) */
+#define k	4128	/* key 1-32 ( word ) */
+
+/* define a few register aliases to allow macro substitution */
+
+#define R0D    %eax
+#define R0B    %al
+#define R0H    %ah
+
+#define R1D    %ebx
+#define R1B    %bl
+#define R1H    %bh
+
+#define R2D    %ecx
+#define R2B    %cl
+#define R2H    %ch
+
+#define R3D    %edx
+#define R3B    %dl
+#define R3H    %dh
+
+
+/* performs input whitening */
+#define input_whitening(src,context,offset)\
+	xor	w+offset(context),	src;
+
+/* performs input whitening */
+#define output_whitening(src,context,offset)\
+	xor	w+16+offset(context),	src;
+
+/*
+a input register containing a (rotated 16)
+b input register containing b
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+*/
+#define encrypt_round(a,b,c,d,round)\
+push	d ## D;\
+movzx	b ## B,		%edi;\
+mov	s1(%ebp,%edi,4),d ## D;\
+movzx	a ## B,		%edi;\
+mov	s2(%ebp,%edi,4),%esi;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%ebp,%edi,4),d ## D;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%ebp,%edi,4),%esi;\
+movzx	b ## B,		%edi;\
+xor	s3(%ebp,%edi,4),d ## D;\
+movzx	a ## B,		%edi;\
+xor	(%ebp,%edi,4),	%esi;\
+movzx	b ## H,		%edi;\
+ror	$15,		b ## D;\
+xor	(%ebp,%edi,4),	d ## D;\
+movzx	a ## H,		%edi;\
+xor	s1(%ebp,%edi,4),%esi;\
+pop	%edi;\
+add	d ## D,		%esi;\
+add	%esi,		d ## D;\
+add	k+round(%ebp),	%esi;\
+xor	%esi,		c ## D;\
+rol	$15,		c ## D;\
+add	k+4+round(%ebp),d ## D;\
+xor	%edi,		d ## D;
+
+/*
+a input register containing a (rotated 16)
+b input register containing b
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+last round has different rotations for the output preparation
+*/
+#define encrypt_last_round(a,b,c,d,round)\
+push	d ## D;\
+movzx	b ## B,		%edi;\
+mov	s1(%ebp,%edi,4),d ## D;\
+movzx	a ## B,		%edi;\
+mov	s2(%ebp,%edi,4),%esi;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%ebp,%edi,4),d ## D;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%ebp,%edi,4),%esi;\
+movzx	b ## B,		%edi;\
+xor	s3(%ebp,%edi,4),d ## D;\
+movzx	a ## B,		%edi;\
+xor	(%ebp,%edi,4),	%esi;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%ebp,%edi,4),	d ## D;\
+movzx	a ## H,		%edi;\
+xor	s1(%ebp,%edi,4),%esi;\
+pop	%edi;\
+add	d ## D,		%esi;\
+add	%esi,		d ## D;\
+add	k+round(%ebp),	%esi;\
+xor	%esi,		c ## D;\
+ror	$1,		c ## D;\
+add	k+4+round(%ebp),d ## D;\
+xor	%edi,		d ## D;
+
+/*
+a input register containing a
+b input register containing b (rotated 16)
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+*/
+#define decrypt_round(a,b,c,d,round)\
+push	c ## D;\
+movzx	a ## B,		%edi;\
+mov	(%ebp,%edi,4),	c ## D;\
+movzx	b ## B,		%edi;\
+mov	s3(%ebp,%edi,4),%esi;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s1(%ebp,%edi,4),c ## D;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%ebp,%edi,4),	%esi;\
+movzx	a ## B,		%edi;\
+xor	s2(%ebp,%edi,4),c ## D;\
+movzx	b ## B,		%edi;\
+xor	s1(%ebp,%edi,4),%esi;\
+movzx	a ## H,		%edi;\
+ror	$15,		a ## D;\
+xor	s3(%ebp,%edi,4),c ## D;\
+movzx	b ## H,		%edi;\
+xor	s2(%ebp,%edi,4),%esi;\
+pop	%edi;\
+add	%esi,		c ## D;\
+add	c ## D,		%esi;\
+add	k+round(%ebp),	c ## D;\
+xor	%edi,		c ## D;\
+add	k+4+round(%ebp),%esi;\
+xor	%esi,		d ## D;\
+rol	$15,		d ## D;
+
+/*
+a input register containing a
+b input register containing b (rotated 16)
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+last round has different rotations for the output preparation
+*/
+#define decrypt_last_round(a,b,c,d,round)\
+push	c ## D;\
+movzx	a ## B,		%edi;\
+mov	(%ebp,%edi,4),	c ## D;\
+movzx	b ## B,		%edi;\
+mov	s3(%ebp,%edi,4),%esi;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s1(%ebp,%edi,4),c ## D;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%ebp,%edi,4),	%esi;\
+movzx	a ## B,		%edi;\
+xor	s2(%ebp,%edi,4),c ## D;\
+movzx	b ## B,		%edi;\
+xor	s1(%ebp,%edi,4),%esi;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%ebp,%edi,4),c ## D;\
+movzx	b ## H,		%edi;\
+xor	s2(%ebp,%edi,4),%esi;\
+pop	%edi;\
+add	%esi,		c ## D;\
+add	c ## D,		%esi;\
+add	k+round(%ebp),	c ## D;\
+xor	%edi,		c ## D;\
+add	k+4+round(%ebp),%esi;\
+xor	%esi,		d ## D;\
+ror	$1,		d ## D;
+
+.align 4
+.global twofish_enc_blk
+.global twofish_dec_blk
+
+twofish_enc_blk:
+	push	%ebp			/* save registers according to calling convention*/
+	push    %ebx
+	push    %esi			
+	push    %edi
+
+	mov	ctx + 16(%esp),	%ebp	/* abuse the base pointer: set new base bointer to the \
crypto ctx */ +	mov     in_blk+16(%esp),%edi	/* input adress in edi */
+
+	mov	(%edi),		%eax
+	mov	b_offset(%edi),	%ebx
+	mov	c_offset(%edi),	%ecx
+	mov	d_offset(%edi),	%edx
+	input_whitening(%eax,%ebp,a_offset)
+	ror	$16,	%eax
+	input_whitening(%ebx,%ebp,b_offset)
+	input_whitening(%ecx,%ebp,c_offset)
+	input_whitening(%edx,%ebp,d_offset)
+	rol	$1,	%edx
+
+	encrypt_round(R0,R1,R2,R3,0);
+	encrypt_round(R2,R3,R0,R1,8);
+	encrypt_round(R0,R1,R2,R3,2*8);
+	encrypt_round(R2,R3,R0,R1,3*8);
+	encrypt_round(R0,R1,R2,R3,4*8);
+	encrypt_round(R2,R3,R0,R1,5*8);
+	encrypt_round(R0,R1,R2,R3,6*8);
+	encrypt_round(R2,R3,R0,R1,7*8);
+	encrypt_round(R0,R1,R2,R3,8*8);
+	encrypt_round(R2,R3,R0,R1,9*8);
+	encrypt_round(R0,R1,R2,R3,10*8);
+	encrypt_round(R2,R3,R0,R1,11*8);
+	encrypt_round(R0,R1,R2,R3,12*8);
+	encrypt_round(R2,R3,R0,R1,13*8);
+	encrypt_round(R0,R1,R2,R3,14*8);
+	encrypt_last_round(R2,R3,R0,R1,15*8);
+
+	output_whitening(%eax,%ebp,c_offset)
+	output_whitening(%ebx,%ebp,d_offset)
+	output_whitening(%ecx,%ebp,a_offset)
+	output_whitening(%edx,%ebp,b_offset)
+	mov	out_blk+16(%esp),%edi;
+	mov	%eax,		c_offset(%edi)
+	mov	%ebx,		d_offset(%edi)
+	mov	%ecx,		(%edi)
+	mov	%edx,		b_offset(%edi)
+
+	pop	%edi
+	pop	%esi
+	pop	%ebx
+	pop	%ebp
+	mov	$1,	%eax
+	ret
+
+twofish_dec_blk:	
+	push	%ebp			/* save registers according to calling convention*/
+	push    %ebx
+	push    %esi			
+	push    %edi
+
+
+	mov	ctx + 16(%esp),	%ebp	/* abuse the base pointer: set new base bointer to the \
crypto ctx */ +	mov     in_blk+16(%esp),%edi	/* input adress in edi */
+
+	mov	(%edi),		%eax
+	mov	b_offset(%edi),	%ebx
+	mov	c_offset(%edi),	%ecx
+	mov	d_offset(%edi),	%edx
+	output_whitening(%eax,%ebp,a_offset)
+	output_whitening(%ebx,%ebp,b_offset)
+	ror	$16,	%ebx
+	output_whitening(%ecx,%ebp,c_offset)
+	output_whitening(%edx,%ebp,d_offset)
+	rol	$1,	%ecx
+
+	decrypt_round(R0,R1,R2,R3,15*8);
+	decrypt_round(R2,R3,R0,R1,14*8);
+	decrypt_round(R0,R1,R2,R3,13*8);
+	decrypt_round(R2,R3,R0,R1,12*8);
+	decrypt_round(R0,R1,R2,R3,11*8);
+	decrypt_round(R2,R3,R0,R1,10*8);
+	decrypt_round(R0,R1,R2,R3,9*8);
+	decrypt_round(R2,R3,R0,R1,8*8);
+	decrypt_round(R0,R1,R2,R3,7*8);
+	decrypt_round(R2,R3,R0,R1,6*8);
+	decrypt_round(R0,R1,R2,R3,5*8);
+	decrypt_round(R2,R3,R0,R1,4*8);
+	decrypt_round(R0,R1,R2,R3,3*8);
+	decrypt_round(R2,R3,R0,R1,2*8);
+	decrypt_round(R0,R1,R2,R3,1*8);
+	decrypt_last_round(R2,R3,R0,R1,0);
+
+	input_whitening(%eax,%ebp,c_offset)
+	input_whitening(%ebx,%ebp,d_offset)
+	input_whitening(%ecx,%ebp,a_offset)
+	input_whitening(%edx,%ebp,b_offset)
+	mov	out_blk+16(%esp),%edi;
+	mov	%eax,		c_offset(%edi)
+	mov	%ebx,		d_offset(%edi)
+	mov	%ecx,		(%edi)
+	mov	%edx,		b_offset(%edi)
+
+	pop	%edi
+	pop	%esi
+	pop	%ebx
+	pop	%ebp
+	mov	$1,	%eax
+	ret
diff -uprN linux-2.6.17-rc5.twofish2/crypto/Kconfig \
                linux-2.6.17-rc5.twofish3/crypto/Kconfig
--- linux-2.6.17-rc5.twofish2/crypto/Kconfig	2006-06-11 15:58:39.219982140 +0200
+++ linux-2.6.17-rc5.twofish3/crypto/Kconfig	2006-06-11 16:05:19.938782275 +0200
@@ -150,6 +150,21 @@ config CRYPTO_TWOFISH_COMMON
 	  Common parts of the Twofish cipher algorithm.
 	  
 
+config CRYPTO_TWOFISH_586
+	tristate "Twofish cipher algorithms (i586)"
+	depends on CRYPTO &amp;&amp; ((X86 || UML_X86) &amp;&amp; !64BIT)
+	select CRYPTO_TWOFISH_COMMON
+	help
+	  Twofish cipher algorithm.
+
+	  Twofish was submitted as an AES (Advanced Encryption Standard)
+	  candidate cipher by researchers at CounterPane Systems.  It is a
+	  16 round block cipher supporting key sizes of 128, 192, and 256
+	  bits.
+
+	  See also:
+	  &lt;http://www.schneier.com/twofish.html&gt;
+
 config CRYPTO_SERPENT
 	tristate "Serpent cipher algorithm"
 	depends on CRYPTO
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


</body></email><email><emailId>20060618182102</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-06-18 18:21:02-0400</timestampReceived><subject>Re: The evils of SuSE 10.1</subject><body>

Peter_22@gmx.de wrote:
&gt; drivers/scsi/built-in.o: In function `do_drive_get_GTF':
&gt; (.text+0x10edc): multiple definition of `do_drive_get_GTF'
&gt; drivers/ide/built-in.o:(.text+0xc03e): first defined here
&gt; ld: Warning: size of symbol `do_drive_get_GTF' changed from 469 in \
&gt; drivers/ide/built-in.o to 1016 in drivers/scsi/built-in.o make[1]: *** \
&gt;                 [drivers/built-in.o] Error 1
&gt; make: *** [drivers] Error 2

SUSE goofed. Untested fix:

# sed -e 's/do_drive_get_GTF/do_drive_get_GTFx/' &lt;drivers/ide/ide-acpi.c &gt;z
# mv z drivers/ide/ide-acpi.c
# make bzImage

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060507154027</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-05-07 15:40:27-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

Peter_22@gmx.de wrote:
&gt; Since Loop-AES features a patch for amd64 cpus when using AES cipher it runs
&gt; faster creating less load. So everyone will use AES. Twofish and Blowfish
&gt; ciphers are considerably slower. But, is there a patch for Twohfish /
&gt; Blowfish to make them work faster on amd64??
&gt; I´d like to use both ciphers for the same partition, unfortunately both are
&gt; much slower than AES. Will this be the same forever?

Joachim Fritschi posted partially assembler implementation of twofish for
AMD64 to linux-kernel mailing list today. I haven't looked at it yet.

For blowfish... my advise is to not use blowfish to encrypt large amounts of
data. It has 64 bit block size, and it is present in loop-AES' additional
ciphers package mostly for compatibility with some old implementations.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060507211522</emailId><senderName></senderName><senderEmail>peter_22</senderEmail><timestampReceived>2006-05-07 21:15:22-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

&gt; --- Ursprüngliche Nachricht ---
&gt; Von: Jari Ruusu &lt;jariruusu@users.sourceforge.net&gt;
&gt; An: Peter_22@gmx.de
&gt; Kopie: linux-crypto@nl.linux.org
[...]
&gt; Betreff: Re: Loop-AES and Twofish on 64-bit CPU
&gt; Joachim Fritschi posted partially assembler implementation of twofish for
&gt; AMD64 to linux-kernel mailing list today. I haven't looked at it yet.
 
Can this code be integrated in the next Loop-AES cipher package? I´d also
volunteer for a pre-test.

&gt; For blowfish... my advise is to not use blowfish to encrypt large amounts
&gt; of
&gt; data. It has 64 bit block size, and it is present in loop-AES' additional
&gt; ciphers package mostly for compatibility with some old implementations.

Blow- and Twofish are the only alternatives to AES. I´d like to use two
loops on one partition and use at least two ciphers to gain better security.
Size of devices in my case is 200GB (my complete old WD drive) and large
portions of the newer 320GB drive. With perpendicular recording drive space
will increase considerably in the next months. Do you see a limit where AES
or other ciphers can no longer cope with that?
With a passthru kernel patch
(http://www.kernel.org/pub/linux/kernel/people/jgarzik/libata/old/) I
managed to turn on and off my old 200GB serial ata drive. The command is
"hdparm -y /dev/sdb". This way you easily get more encrypted storage without
mounting dozens of dvd images and all that crap.
Anyway, 64bit implementations of any cipher are always welcome.

Regards,
Peter

-- 
Analog-/ISDN-Nutzer sparen mit GMX SmartSurfer bis zu 70%!
Kostenlos downloaden: http://www.gmx.net/de/go/smartsurfer

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060507213257</emailId><senderName>markus reichelt</senderName><senderEmail>ml@mareichelt.de</senderEmail><timestampReceived>2006-05-07 21:32:57-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

* Peter_22@gmx.de wrote:

&gt; Blow- and Twofish are the only alternatives to AES. I?d like to use
&gt; two loops on one partition and use at least two ciphers to gain
&gt; better security.

There's also serpent.

--=20
left blank, right bald

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060508192034</emailId><senderName></senderName><senderEmail>peter_22</senderEmail><timestampReceived>2006-05-08 19:20:34-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

&gt; --- Ursprüngliche Nachricht ---
&gt; Von: markus reichelt &lt;ml@mareichelt.de&gt;
&gt; An: linux-crypto@nl.linux.org
&gt; Betreff: Re: Loop-AES and Twofish on 64-bit CPU
&gt; Datum: Sun, 07 May 2006 23:32:57 +0200
&gt; 
&gt; * Peter_22@gmx.de wrote:
&gt; 
&gt; &gt; Blow- and Twofish are the only alternatives to AES. I?d like to use
&gt; &gt; two loops on one partition and use at least two ciphers to gain
&gt; &gt; better security.
&gt; 
&gt; There's also serpent.

Which is, to my knowledge, derived from AES. I´d wonder if serpent is
optimized for amd64 cpu. So far I can assure to everyone that the 64bit
optimization for AES was a breakthrough.

Regards,
Peter

-- 
Analog-/ISDN-Nutzer sparen mit GMX SmartSurfer bis zu 70%!
Kostenlos downloaden: http://www.gmx.net/de/go/smartsurfer

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060508232742</emailId><senderName>markus reichelt</senderName><senderEmail>ml@mareichelt.de</senderEmail><timestampReceived>2006-05-08 23:27:42-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

* Peter_22@gmx.de wrote:

&gt; &gt; &gt; Blow- and Twofish are the only alternatives to AES. I?d like to use
&gt; &gt; &gt; two loops on one partition and use at least two ciphers to gain
&gt; &gt; &gt; better security.
&gt; &gt; 
&gt; &gt; There's also serpent.
&gt; 
&gt; Which is, to my knowledge, derived from AES.

They are similar, but serpent is more secure. 

http://www.cl.cam.ac.uk/~rja14/serpent.html


&gt; I?d wonder if serpent is optimized for amd64 cpu.

Not natively; but maybe there's some fancy code snippet out there, I
don't know.

This year both Intel's and AMD's production of 32bit CPUs will run
out. They focus on the shiny 64bit production lines, so that means
better chances for code optimization. Eventually. ;-)

-- 
left blank, right bald

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060508233707</emailId><senderName>markus reichelt</senderName><senderEmail>ml@mareichelt.de</senderEmail><timestampReceived>2006-05-08 23:37:07-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

* Peter_22@gmx.de wrote:

&gt; Blow- and Twofish are the only alternatives to AES. I?d like to use
&gt; two loops on one partition and use at least two ciphers to gain
&gt; better security.

Regarding better security, I've just found out about an interesting
event: Quo Vadis 4 Conference, Friday 26 May 2006, Warsaw, Poland

It's interesting because of this:

http://www.cryptosystem.net/aes/

"Nicolas T. Courtois has announced that he will make a public
demonstration of an algebraic attack that breaks a toy block cipher
with about 200 S-boxes (nearly as many as in AES), by solving a
system of algebraic equations derived from very few (only 4)
plaintexts, ciphertext pairs. The cipher has good diffusion, no
special structure that could make it weak, and no known weakness (and
probably no weakness whatsoever) other than the low I/O degree of its
S-boxes."

--=20
left blank, right bald

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060509095800</emailId><senderName>Gisle_Sælensminde</senderName><senderEmail>gisle.salensminde@bccs.uib.no</senderEmail><timestampReceived>2006-05-09 09:58:00-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

Peter_22@gmx.de wrote:

&gt;&gt;--- Ursprüngliche Nachricht ---
&gt;&gt;Von: markus reichelt &lt;ml@mareichelt.de&gt;
&gt;&gt;An: linux-crypto@nl.linux.org
&gt;&gt;Betreff: Re: Loop-AES and Twofish on 64-bit CPU
&gt;&gt;Datum: Sun, 07 May 2006 23:32:57 +0200
&gt;&gt;
&gt;&gt;* Peter_22@gmx.de wrote:
&gt;&gt;
&gt;&gt;    
&gt;&gt;
&gt;&gt;&gt;Blow- and Twofish are the only alternatives to AES. I?d like to use
&gt;&gt;&gt;two loops on one partition and use at least two ciphers to gain
&gt;&gt;&gt;better security.
&gt;&gt;&gt;      
&gt;&gt;&gt;

First I would like to mention that this is not likely to increase the 
security in any way. The ciphers
are well analyzed and have no known attacks. If there are weak spots in 
the scheme it is likely
to be in the loop-implementation itself, since this is far less 
analyzed, and in that case an extra
layer of encryption is more likely to weaken security than to strengthen 
it. (Note: I don't know of
any exploitable holes in the loop implementation, I just say that more 
people have tried to find holes
in AES)

&gt;&gt;There's also serpent.
&gt;&gt;    
&gt;&gt;
&gt;
&gt;Which is, to my knowledge, derived from AES. 
&gt;
Serpent is not derived from AES. It was one of the five final canditates 
to be AES, which the
algorithm Rijndael (now known as just AES) won. So it was a competing 
candidate for being
AES, and based on a quite different design. The other final candidates 
were Twofish and RC6 and Mars.
Serpent is considered by many cryptographers to be a good number two, 
others like Twofish. Nobody
like Mars, and RC6 is patented. All of them are belived to be secure.

&gt;I´d wonder if serpent is
&gt;optimized for amd64 cpu. So far I can assure to everyone that the 64bit
&gt;optimization for AES was a breakthrough.
&gt;
&gt;  
&gt;
Unlike AES, Serpent don't have immidiate gain from a 64-bit CPU, as it 
is quite close to
optimal on a 32-bit chip, and it don't need the extra registers on the 
AMD64 architecture to be fast.
In fact it does only read the keys and the input during an encryption. 
Just look at the emited assembly
code of the serpent function (-O2 -fomit-frame-pointer), and it is quite 
well optimized.

One difference however, is that the AMD chips has more ALUs, and can 
thus do more arithmetric
operation in parallel, which means that different sets of sbox-functions 
will be optimal on the two
CPUs, but the one being optimal on opteron will be  almost optimal on 
PIII and PIV, so this set
of sboxes is already in the current implementation of serpent.

Another thing is that since serpent don't gain so much from a new 
instruction set, the differences between
the 64-bit CPUs from AMD and intel may be as important as the difference 
between the 64 and 32-bit
chips.

What you can gain from a 64-bit CPU is that serpent then can run two 
encryptions in parallell
(but not in CBC-mode unfortunatly) or two decryptions in parallell (also 
in CBC-mode), and this will
double the speed of serpent. Unfortunatly this does not fit with the 
kernel API for crypto, so it is not
implemented. Brian Gladman developed such an implementation once using 
the MMX instuction set,
as this was before the AMD64 existed.

Dag Arne Osvik's paper on optimization of Serpent: 
http://www.osvik.no/pub/aes3.pdf

This paper describe a search function for sboxes for serpent. The sboxes 
in the current implementation
was found with a bit different method, but you get an impression.

-Gisle

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060526011707</emailId><senderName>Christian Kujau</senderName><senderEmail>evil@g-house.de</senderEmail><timestampReceived>2006-05-26 01:17:07-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

On Tue, 9 May 2006, Gisle Sælensminde wrote:
&gt; First I would like to mention that this is not likely to increase the 
&gt; security in any way.

Wy not?

&gt; The ciphers are well analyzed and have no known attacks. If there are
&gt; weak spots in the scheme it is likely to be in the loop-implementation itself,
&gt; since this is far less analyzed, and in that case an extra layer of encryption
-------------------------------------------^ "in that case" the cipher is 
a minor thing to worry. It's always important to get the implementation 
right, which is the tricky bit, yes.

&gt; is more likely to weaken security than to strengthen it.

...but multiple ciphers do NOT weaken security per se, otherwise it'd be a 
flaw in every algorithm. cf. http://ciphersbyritter.com/NEWS6/MULTSHAN.HTM

I just wanted to point this out, for the record only :)

Christian.
-- 
BOFH excuse #435:

Internet shut down due to maintenance
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060526210805</emailId><senderName></senderName><senderEmail>peter_22</senderEmail><timestampReceived>2006-05-26 21:08:05-0400</timestampReceived><subject>Re: Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

&gt; -------- Original-Nachricht --------
&gt; Datum: Fri, 26 May 2006 02:17:07 +0100 (BST)
&gt; Von: Christian Kujau &lt;evil@g-house.de&gt;
&gt; An: linux-crypto@nl.linux.org
&gt; Betreff: Re: Loop-AES and Twofish on 64-bit CPU
&gt; 
&gt; On Tue, 9 May 2006, Gisle Sælensminde wrote:
&gt; &gt; First I would like to mention that this is not likely to increase the 
&gt; &gt; security in any way.
&gt; 
&gt; Wy not?

Thanks a lot for bailing me out:-) I did not know what to answer to Gisle \
Sælensminde. The outlook that a double layer of loop-aes could decrease security is \
rather shocking. My questions and proposals never dealt with cipher analysis. I \
rather concentrate on things like a proper &amp; easy to handle environment. Storing keys \
and tools on a usb-stick has nothing to do with strong ciphers but it is the ultimate \
opportunity to keep keys away from your attackers *and* encrypt all your data, not \
just larger parts. As all ciphers can and will be broken I deem it important to look \
for alternatives on how to cover encryption. Where could the data be on a drive with \
no partition table? Where to start a brute force attack if there is no  end and no \
beginning? Is it a successfull attack if you get encrypted data after you break the \
first layer of encryption? I suppose and fear popular tools like truecrypt rely to \
much on buzzword compliant selfpromotion. I still suppose double encryption and \
mixing up more than one cipher in deed does slow down attackers.

Regards,
Peter

-- 


Bis zu 70% Ihrer Onlinekosten sparen: GMX SmartSurfer!
      Kostenlos downloaden: http://www.gmx.net/de/go/smartsurfer
    

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060528130514</emailId><senderName>Gisle_Sælensminde</senderName><senderEmail>gisle.salensminde@bccs.uib.no</senderEmail><timestampReceived>2006-05-28 13:05:14-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

Peter_22@gmx.de wrote:

&gt; &gt; -------- Original-Nachricht --------
&gt; &gt; Datum: Fri, 26 May 2006 02:17:07 +0100 (BST)
&gt; &gt; Von: Christian Kujau &lt;evil@g-house.de&gt;
&gt; &gt; An: linux-crypto@nl.linux.org
&gt; &gt; Betreff: Re: Loop-AES and Twofish on 64-bit CPU
&gt; &gt; 
&gt; &gt; On Tue, 9 May 2006, Gisle Sælensminde wrote:
&gt; &gt; 
&gt; &gt; 
&gt; &gt; &gt; First I would like to mention that this is not likely to increase the 
&gt; &gt; &gt; security in any way.
&gt; &gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; Wy not?
&gt; &gt; 
&gt; &gt; 
&gt; 
&gt; Thanks a lot for bailing me out:-) I did not know what to answer to Gisle \
&gt; Sælensminde. The outlook that a double layer of loop-aes could decrease security is \
&gt; rather shocking. My questions and proposals never dealt with cipher analysis. I \
&gt; rather concentrate on things like a proper &amp; easy to handle environment. Storing \
&gt; keys and tools on a usb-stick has nothing to do with strong ciphers but it is the \
&gt; ultimate opportunity to keep keys away from your attackers *and* encrypt all your \
&gt; data, not just larger parts. As all ciphers can and will be broken I deem it \
&gt; important to look for alternatives on how to cover encryption. Where could the data \
&gt; be on a drive with no partition table? Where to start a brute force attack if there \
&gt; is no  end and no beginning? Is it a successfull attack if you get encrypted data \
&gt; after you break the first layer of encryption? I suppose and fear popular tools \
&gt; like truecrypt rely to much on buzzword compliant selfpromotion. I still suppose \
&gt; double encryption and mixing up more than one cipher in deed does slow down \
&gt; attackers. 
&gt; 
&gt; 
Cryptologists often use the term cryptosystem. A cryptosystem is all 
parts of the system, including the ciphers, the digest functions, and 
how the different parts are combined to get a system that is secure as a 
whole, and this is more than just the security of the ciphers used. If 
the ciphersystem has flaws, it can be broken, even though the ciphers it 
uses are secure. In this case the cryptosystem is loop-aes and all the 
software for handling keys etc. My point is that by introducing the 
double layer of encryption, you change the cryptosystem. This means that 
some of the analysis done on the single encryption system now are 
invalid. This may actually introduce a possibility for an attack, for 
instance it may introduce a weakness that let an attacker exploiting the 
fact that the two ciphers use the same key or some other attack that you 
could not imagine. Of cause the ciphers may be broken sometimes in
the future, but the ciphers are quite well analyzed, and if a cipher is 
broken, you will probably know it quite
quickly. Then there is muck bigger chance that there is a flaw in the 
design of loop-aes or in the scheme for adding a double layer of 
encryption. The best thing to do to increase the security of the 
loop-aes is probably to
sit down an analyze how the

In fact it is hard to get a ciphersystem right, and many big companies 
that should have the resources to hire the best people in the field has 
failed miserably. Examples of this is:

- Netscapes SSL implementation could be broken because they used a 
random-generator that were not of cryptographic quality.

- With the SSL 2.0 protocol, an attacker could force the comunication to 
use 40-bit keys, even both parties
supported 128-bit keys.

- The WEP protocol used the RC4 cipher the wrong way, by having a bad 
scheme for seeding the user key used to derive the encryption key. 
Firstly this introduced a possibility for a key reuse (which basicly 
means that the system is broken when the cipher is a streamcipher). This 
attack was later improved, using a newly discovered weakness in RC4. 
This weakness in RC4 cannot be used to attack better designed systems.

My point with these examples, is that the whole cryptosystem must be 
considered, not just the ciphers, and as mentioned above, more people 
has analyzed AES than the loop-aes system, so I would be more worried 
about how loop-aes is designed than the strength of the cipher. It would 
be better to analyze the system all the way from user authentication 
(typing passwords, usb-sticks etc) to how the blocks are encrypted, what 
happens if part of a disk sector change etc. 

An example of such an analysis of the Linux random device, can be found 
at the URL below:

http://eprint.iacr.org/2006/086





&gt; Regards,
&gt; Peter
&gt; 
&gt; 
&gt; 


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060529015840</emailId><senderName>Christian Kujau</senderName><senderEmail>evil@g-house.de</senderEmail><timestampReceived>2006-05-29 01:58:40-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

On Sun, 28 May 2006, Gisle Sælensminde wrote:
&gt; Peter_22@gmx.de wrote:
&gt;&gt; Thanks a lot for bailing me out:-) I did not know what to answer to Gisle 
&gt;&gt; Sælensminde. The outlook that a double layer of loop-aes could decrease 
&gt;&gt; security is rather shocking.

Yes, "decreased security" *just because* of 2 ciphers is just..well, 
silly. How many ciphers does it take to break your data ;)
But read Giseles notes below which should clear up this misunderstanding.

&gt;&gt; concentrate on things like a proper &amp; easy to handle environment. Storing 
&gt;&gt; keys and tools on a usb-stick has nothing to do with strong ciphers but it 
&gt;&gt; is the ultimate opportunity to keep keys away from your attackers *and* 
&gt;&gt; encrypt all your data, not just larger parts.

And exactly this and a few other implementation details is what I think 
Gisele had in mind and what is often forgotten, although it's crypto 101:
a 2048 bit key does not help at all if it's pinned next to the 
monitor or even stored in plaintext on an unencrypted disk....

&gt;&gt; As all ciphers can and will be broken

um, in the (hopefully more distant) future, yes. but then your tiny 500 GB 
hard-disk is long gone and loop-aes's successor (?) is finally included in
linux-3.1 ;)

&gt;&gt; alternatives on how to cover encryption. Where could the data be on a drive 
&gt;&gt; with no partition table?

tricky, methinks. AFAIK, today's ciphers are quite good in letting the 
ciphertext look like "random". and a big disk filled with random data is 
just...suspicious ;)

&gt;&gt; Where to start a brute force attack if there is no end and no beginning?

i don't know much about the implemention details of successful attacks to 
answer this...

&gt;&gt;  Is it a successfull attack if you get encrypted data 
&gt;&gt; after you break the first layer of encryption?

hm, you'd have to *know* that this key was right and the gibberish you're 
looking at is in fact the underlying 2nd ciphertext...1 more to go.

&gt;&gt; I still suppose double encryption and mixing up more than one cipher in 
&gt;&gt; deed does slow down attackers.

IIRC, this was done in PGPphone (or its successor? gotta look it up 
somewhere): they've used 2 different ciphers, for performance purposes, i 
think.

&gt; different parts are combined to get a system that is secure as a whole, and 
&gt; this is more than just the security of the ciphers used. If the ciphersystem

Gisele, I was under the assumption that the OP know that it takes more 
than just "ciphers" to be "secure", so I just wanted to say (again):

-&gt; "decreased security" *just because* of 2 ciphers would mean that we 
could break ciphers by chaining them together often enough?

&gt; change the cryptosystem. This means that some of the analysis done on the 
&gt; single encryption system now are invalid.

sure: the findings of cipher_a do not apply for cipher_b.

&gt; This may actually introduce a possibility for an attack, for instance it

"possibility for an attack"? so, do you mean if it's labelled
   "comes with double-encryption (only 49,99 ;))"
more people would attack the ciphertext?

&gt; may introduce a weakness that let an attacker exploiting the fact that
&gt; the two ciphers use the same key or some other attack that you could not

different ciphers, different keys, methinks. otherwise we really had 
problems like known-ciphertext attacks or sth. like that.  again: if "more 
ciphers" do mean "decreased encrpytion", then I'd be really curious about
the how-many-ciphers-to-break-this issue ;)

&gt; My point with these examples, is that the whole cryptosystem must be 
&gt; considered, not just the ciphers

ACK, again.

&gt; analyzed AES than the loop-aes system, so I would be more worried about how 
&gt; loop-aes is designed than the strength of the cipher.

hm, makes sense too. we just have to enlarge the loop-aes userbase and get 
it all reviewed...

cheers.
Christian.
-- 
BOFH excuse #435:

Internet shut down due to maintenance
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060529090057</emailId><senderName>Gisle Sælensminde</senderName><senderEmail>gisle.salensminde@bccs.uib.no</senderEmail><timestampReceived>2006-05-29 09:00:57-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

Christian Kujau wrote:

&gt; On Sun, 28 May 2006, Gisle S�lensminde wrote:
&gt;
&gt; Gisele, I was under the assumption that the OP know that it takes more 
&gt; than just "ciphers" to be "secure", so I just wanted to say (again):
&gt;
&gt; -&gt; "decreased security" *just because* of 2 ciphers would mean that we 
&gt; could break ciphers by chaining them together often enough?
&gt;
(I'm Gisle, not Gisele)

I don't want to assume such knowledge, as many security experts in major 
corporations has failed on this point. The idea of double encryption 
"just in case" is often a sign of lack of knowledge in cryptography. The 
cipher is probably the least likely part to be broken, and doubling it 
will double the CPU usage for little gain in security.

&gt; "possibility for an attack"? so, do you mean if it's labelled
&gt; "comes with double-encryption (only 49,99 ;))"
&gt; more people would attack the ciphertext?
&gt;
Maybe not because the double encryption, but with _that_ advertisement I 
would know it was snake oil. ;-)

I mean that another component in the system is introduced, and this 
part, as any other part of the system may have flaws. An important 
principle in the design of such systems, is to keep them as simple as 
possible, but not simpler. That makes them easier to evaluate.

&gt;&gt; may introduce a weakness that let an attacker exploiting the fact that
&gt;&gt; the two ciphers use the same key or some other attack that you could not
&gt;
&gt;
&gt; different ciphers, different keys, methinks. otherwise we really had 
&gt; problems like known-ciphertext attacks or sth. like that. again: if 
&gt; "more ciphers" do mean "decreased encrpytion", then I'd be really 
&gt; curious about
&gt; the how-many-ciphers-to-break-this issue ;)


While the two ciphers may not use the same key, it is likely that such a 
system will still only use one passphrase or other means of 
authentication from the user, and that may introduce a weakness that can 
be exploited if not done right. It may not make more people attack the 
ciphertext, but one smart guy may find a way to exploit the weakness in 
the modified key handling scheme introduced.

In this sense, the difference on user level details, like the difference 
between a user passphrase and a usb-stick
scheme, can have large impact on the security of the system, and both 
must be analyzed separatly for security.

My point with the examples of weaknesses in "famous" protocols like SSL 
and WEP in my last posting, was to illustrate that even some of the best 
fails, and that design of cryptosystems is hard. Most of these flaws was 
either not necessary (the cipher suit approch was introduced of 
political reasons), or overlooked aspects of the system (the random 
generator). What I mean is that the system should be simple, and that 
all aspect, like user authentication, seeding etc must be included in 
the analysis. Furthermore, all assumptions should be stated explicitly 
in the design.

&gt;&gt; analyzed AES than the loop-aes system, so I would be more worried 
&gt;&gt; about how loop-aes is designed than the strength of the cipher.
&gt;
&gt;
&gt; hm, makes sense too. we just have to enlarge the loop-aes userbase and 
&gt; get it all reviewed...

Exactly.

A first step could be to describe loop-aes and cryptoloop, like done for 
the random-device in the paper I linked to.



-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060529153830</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-05-29 15:38:30-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

Gisle Sælensminde wrote:
&gt; A first step could be to describe loop-aes and cryptoloop, like done for
&gt; the random-device in the paper I linked to.

[short version for loop-AES-v3]

Userland mount/losetup key setup:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
65 lines of random text are encrypted using gpg, once only. gpg symmetric
key passphrase or private keyring passphrase is typed to mount/losetup
programs when they ask for it. mount/losetup programs use gpg program to
decrypt the key file. Each text line is hashed using SHA-256 (or SHA-384 or
SHA-512). Array of hash outputs is then passed to kernel driver as
key_table[65] using an ioctl(). That key_table[65] array contains "bulk"
encryption keys that are used to encrypt loop data.

Userland encrypted swap and random key (file system) setup:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
40 KB of old encrypted data is read from disk, and hashed with SHA-512. That
same 40 KB of old encrypted data is then overwritten 20 times using random
data generated from computed hash and time stamp. 32 bytes of common random
data is read from /dev/urandom. For each 65 keys, 16 bytes of per key random
data is read from /dev/urandom. Each of 65 random keys is generated by
hashing "40 KB of old encrypted data" and 32 bytes of common random data and
16 bytes of per key random data using SHA-512. Array of hash outputs is then
passed to kernel driver as key_table[65] using an ioctl(). That
key_table[65] array contains "bulk" encryption keys that are used to encrypt
loop data.

Kernel driver part:
~~~~~~~~~~~~~~~~~~~
Following uses '|' to indicate concatenation. Arrays are 0-based.
Each 512 byte sector is encrypted as:

  K = key_table[sector_number &amp; 63]
  IV = MD5(key_table[64] | plaintext_bytes[16...511] | sector_number)
  ciphertext_bytes[0...511] = CBC_ENCRYPT(K, IV, plaintext_bytes[0...511])

Each 512 byte sector is decrypted as:

  K = key_table[sector_number &amp; 63]
  IV = ciphertext_bytes[0...15]
  plaintext_bytes[16...511] = CBC_DECRYPT(K, IV, ciphertext_bytes[16...511])
  IV = MD5(key_table[64] | plaintext_bytes[16...511] | sector_number)
  plaintext_bytes[0...15] = CBC_DECRYPT(K, IV, ciphertext_bytes[0...15])

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060529170820</emailId><senderName>Christian Kujau</senderName><senderEmail>evil@g-house.de</senderEmail><timestampReceived>2006-05-29 17:08:20-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

On Mon, 29 May 2006, Gisle Sælensminde wrote:
&gt; (I'm Gisle, not Gisele)

Sorry for that.

&gt; case" is often a sign of lack of knowledge in cryptography. The cipher is 
&gt; probably the least likely part to be broken, and doubling it will double the 
&gt; CPU usage for little gain in security.

I can't argue with that, full ACK here.

&gt; Maybe not because the double encryption, but with _that_ advertisement I 
&gt; would know it was snake oil. ;-)

Did I mention that's available in "blue" and "shiny silver"? ;))

&gt; any other part of the system may have flaws. An important principle in the 
&gt; design of such systems, is to keep them as simple as possible, but not 
&gt; simpler. That makes them easier to evaluate.

Ah, now I understand what you were up to, thanks.

Christian.
-- 
BOFH excuse #435:

Internet shut down due to maintenance
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060604020858</emailId><senderName></senderName><senderEmail>peter_22</senderEmail><timestampReceived>2006-06-04 02:08:58-0400</timestampReceived><subject>Re: Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

&gt; -------- Original-Nachricht --------
&gt; Datum: Mon, 29 May 2006 18:38:30 +0300
&gt; Von: Gisle Sælensminde wrote:
&gt; &gt; A first step could be to describe loop-aes and cryptoloop, like done for
&gt; &gt; the random-device in the paper I linked to.
&gt; 

Fine that you do this analysis of the loop-aes crypto system right now...
But as you already assumed, I am not a crypto analyst. So far I trust in the aes \
cipher, gpg and Jaris work. As the userbasis is rather small I suppose the FBI didn`t \
do a code analysis yet. Looks fine, doesn`t it? Sure, I can`t write C or assembler \
code. Of course I don`t try writting loop-aes clones. So far I animated Jari to \
include instructions for using usb-sticks to boot from. Loop-aes can be set up to \
boot the system with no partition table. So there remains nothing that could tell \
attackers that you are using loop-aes. What looks crypto analysis like when you don`t \
know which kind of system you attack? Maybe you assume that loop-aes is used? In this \
case you still don`t know partitions or offsets. And of course you don`t know how \
many layers of encryption I used. Maybe I used 4 loops for some part of some disk...

Again, I agree with your concerns about how loop-aes is taylored. But you still \
missed to give reasons why setting up more than one loop device per partition \
decreases security. Mixing up things always leads to a higher degree of freedom and \
this will decrease chances for crypto analysis, too. Right?

Regards,
Peter

-- 


Der GMX SmartSurfer hilft bis zu 70% Ihrer Onlinekosten zu sparen!
      Ideal für Modem und ISDN: http://www.gmx.net/de/go/smartsurfer
    

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060605144558</emailId><senderName>Gisle_Sælensminde</senderName><senderEmail>gisle.salensminde@bccs.uib.no</senderEmail><timestampReceived>2006-06-05 14:45:58-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>


Peter_22@gmx.de wrote:

&gt; &gt; -------- Original-Nachricht --------
&gt; &gt; Datum: Mon, 29 May 2006 18:38:30 +0300
&gt; &gt; Von: Gisle Sælensminde wrote:
&gt; &gt; 
&gt; &gt; 
&gt; &gt; &gt; A first step could be to describe loop-aes and cryptoloop, like done for
&gt; &gt; &gt; the random-device in the paper I linked to.
&gt; &gt; &gt; 
&gt; &gt; &gt; 
&gt; 
&gt; Fine that you do this analysis of the loop-aes crypto system right now...
&gt; 
&gt; 
Hmmm....

&gt; But as you already assumed, I am not a crypto analyst. So far I trust in the aes \
&gt; cipher, gpg and Jaris work. As the userbasis is rather small I suppose the FBI \
&gt; didn`t do a code analysis yet. Looks fine, doesn`t it? Sure, I can`t write C or \
&gt; assembler code. Of course I don`t try writting loop-aes clones. So far I animated \
&gt; Jari to include instructions for using usb-sticks to boot from. Loop-aes can be set \
&gt; up to boot the system with no partition table. So there remains nothing that could \
&gt; tell attackers that you are using loop-aes. What looks crypto analysis like when \
&gt; you don`t know which kind of system you attack? Maybe you assume that loop-aes is \
&gt; used? In this case you still don`t know partitions or offsets. And of course you \
&gt; don`t know how many layers of encryption I used. Maybe I used 4 loops for some part \
&gt; of some disk... 
&gt; 
&gt; 
A common principle in design of cryptosystems is to use Kerkhoff's 
principle, which is to assume that everything about your system is known 
by an attacker, except the key. They may for example have read this 
mailinglist ;-).
A comptent attacker would assume that a disk filled with randomness is 
encrypted, and then try to find clues of how the data is encrypted. 
Chances are that they will.

&gt; Again, I agree with your concerns about how loop-aes is taylored. But you still \
&gt; missed to give reasons why setting up more than one loop device per partition \
&gt; decreases security. Mixing up things always leads to a higher degree of freedom and \
&gt; this will decrease chances for crypto analysis, too. Right? 
&gt; 
&gt; 
A direct answer to your question is that two layers of loopback 
encryption probably won't make your system less secure. On the other 
hand, it is not likely to make the system more secure either.

If you want to have two layers of loopback on top of your disk, fine. It 
will lower the performance and give more overhaed for the user (you) in 
terms of key handling. If you are motiveted, that is just fine (and you 
probably are). The cipher is likely to already be the strongest link in 
the chain, and it is always the weakest link that breaks first. While 
several layers of encryption may not decrease security, it unlikely to 
buy you any additional security either, and that is my point. If every 
part of the system is strong enough (thus there is no weak link) fine. 
The point of analyzing the system is to detect such weak links, and that 
is unlikely to be the cipher. One such weak link in earlier versions of 
loop-aes (and as far as I know, still in cryptoloop) was the way each 
block were encrypted, that allowed an attacker to see the the location 
of the first change in each disk block when it changed. In that case, it 
would not have helped with several loop devices or double encryption. 
While the seriousness of the attack can be argued about, it shows that 
several layers of encryption may not help if an attack is on a different 
part of the system.






-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060605153239</emailId><senderName>Gisle_Sælensminde</senderName><senderEmail>gisle.salensminde@bccs.uib.no</senderEmail><timestampReceived>2006-06-05 15:32:39-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

Gisle Sælensminde wrote:

&gt; One such weak link in earlier versions of loop-aes (and as far as I 
&gt; know, still in cryptoloop) was the way each block were encrypted, that 
&gt; allowed an attacker to see the the location of the first change in 
&gt; each disk block when it changed. 

This may be interpreted as that you could read the plaintext due to 
this, which it would not let you. It would only let you see that only 
(say) the last x bytes changed, since only the bytes after that point 
changed on the disk block. Now the bytes before that point change too. 
This cannot be used to recover plaintext, but it can give a better 
granularity than the disk block for seeing what have changed where on 
the disk. It was nevertheless correct to change it, since it give more 
information about the underlaying data than desired.

Just to avoid any misunderstandings.

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060611001916</emailId><senderName></senderName><senderEmail>peter_22</senderEmail><timestampReceived>2006-06-11 00:19:16-0400</timestampReceived><subject>Re: Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

"Gisle Sælensminde" &lt;Gisle.Salensminde@bccs.uib.no&gt; wrote:
&gt; [...] One such weak link in earlier versions of 
&gt; loop-aes (and as far as I know, still in cryptoloop) was the way each 
&gt; block were encrypted, that allowed an attacker to see the the location 
&gt; of the first change in each disk block when it changed. In that case, it 
&gt; would not have helped with several loop devices or double encryption. 
&gt; While the seriousness of the attack can be argued about, it shows that 
&gt; several layers of encryption may not help if an attack is on a different 
&gt; part of the system.

Oh, that just reminds me of some guy called "Clemens Fruhwirth".
(http://clemens.endorphin.org/aboutme)
Maybe you want to visit his page. "I brought an 586/686 assembler version of AES to \
the kernel, then started to work on dm-crypt. I invented and implemented ESSIV for \
dm-crypt, and tried to implement another nice encryption mode, called LRW." I \
wondered what LRW might be ever since he mentioned it here. You suppose the way \
loop-aes uses the aes cipher, namely CBC, is insecure? In case Mr. Fruhwirth had \
published loop-aes with LRW I´d given it a try. But as things are it seems to be a \
good choice to use loop-aes as it is and take 2 or more loop devices. Ok, and that´s \
all on this case. Good luck on your anaysis of the cryptosystem. I only fear I can´t \
help with that:-(

Regards,
Peter

-- 


Der GMX SmartSurfer hilft bis zu 70% Ihrer Onlinekosten zu sparen!
Ideal für Modem und ISDN: http://www.gmx.net/de/go/smartsurfer

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060611094728</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-06-11 09:47:28-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

Peter_22@gmx.de wrote:
&gt; "Gisle Sælensminde" &lt;Gisle.Salensminde@bccs.uib.no&gt; wrote:
&gt; &gt;[...] One such weak link in earlier versions of
&gt; &gt; loop-aes (and as far as I know, still in cryptoloop) was the way each
&gt; &gt; block were encrypted, that allowed an attacker to see the the location
&gt; &gt; of the first change in each disk block when it changed. In that case, it
&gt; &gt; would not have helped with several loop devices or double encryption.
&gt; &gt; While the seriousness of the attack can be argued about, it shows that
&gt; &gt; several layers of encryption may not help if an attack is on a different
&gt; &gt; part of the system.
&gt; 
&gt; Oh, that just reminds me of some guy called "Clemens Fruhwirth".
&gt; (http://clemens.endorphin.org/aboutme)
&gt; Maybe you want to visit his page. "I brought an 586/686 assembler version
&gt; of AES to the kernel, then started to work on dm-crypt. I invented and
&gt; implemented ESSIV for dm-crypt, and tried to implement another nice
&gt; encryption mode, called LRW."
&gt; I wondered what LRW might be ever since he mentioned it here.

LRW mode is more vulnerable to changed location disclosure than CBC mode.
That is because each ciphertext block depends on only one plaintext block
and the encryption keys. In CBC mode, ciphertext also depends on preceeding
plaintext blocks. The way IV is computed in loop-AES makes all ciphertext
blocks depend on all plaintext blocks in 512 byte sector.

IOW, loop-AES provides better protection against changed location disclosure
than dm-crypt, cryptoloop, or ecryptfs.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060611114850</emailId><senderName></senderName><senderEmail>peter_22</senderEmail><timestampReceived>2006-06-11 11:48:50-0400</timestampReceived><subject>Re: Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

Jari Ruusu &lt;jariruusu@users.sourceforge.net&gt; wrote:
&gt; [...] LRW mode is more vulnerable to changed location disclosure than CBC mode.
&gt; That is because each ciphertext block depends on only one plaintext block
&gt; and the encryption keys. In CBC mode, ciphertext also depends on
&gt; preceeding
&gt; plaintext blocks. The way IV is computed in loop-AES makes all ciphertext
&gt; blocks depend on all plaintext blocks in 512 byte sector.
&gt; 
&gt; IOW, loop-AES provides better protection against changed location 
&gt; disclosure
&gt; than dm-crypt, cryptoloop, or ecryptfs.

Ok, I suppose this is good news! My knowledge about attacks on ciphers and galois \
fields is quite faint, but I seriously hope the maintanance of loop-aes will go on. \
Since many tutorials and websites focus on loop-aes I deem it the right choice. \
Knoppix includes loop-aes, SuSE does not, but that need not be a disadvantage. \
Clemens Fruhwirth seemed to be a wise guy but unfortunately he didn ´t suggest a \
patch or some working files. Other mainline projects like truecrypt or parts of the \
standard linux kernel might be backdoored. The loop-aes readme could include advice \
on how to remove partition table and boot sector and some plugin for k3b to burn \
encrypted cd/dvd on-the-fly would be excellent, too.

Regards,
Peter

-- 


"Feel free" â€“ 10 GB Mailbox, 100 FreeSMS/Monat ...
Jetzt GMX TopMail testen: http://www.gmx.net/de/go/topmail

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060611124753</emailId><senderName>markus reichelt</senderName><senderEmail>ml@mareichelt.de</senderEmail><timestampReceived>2006-06-11 12:47:53-0400</timestampReceived><subject>Re: Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

* Peter_22@gmx.de wrote:

&gt; Ok, I suppose this is good news! My knowledge about attacks on
&gt; ciphers and galois fields is quite faint, but I seriously hope the
&gt; maintanance of loop-aes will go on. Since many tutorials and
&gt; websites focus on loop-aes I deem it the right choice. Knoppix

I've also seen that many tutorials focus on dm-crypt because it
allegedly is easier to set up, is more modern, has a future, and such
buzzwords. The only argument of using dm-crypt is its presence in
mainline and thus hassle-free updating for the ordinary user; and
that's a funny one too because dm-crypt does not focus on security
first, as its author stated some time ago. dm-crypt's mission mantra
seems to be "let's replace messy mainline loop-stuff, get it stable,
then worry about better security."

That's not a bad thing, because the (still) unmaintained mainline
loop-support is going to be dropped completely as far as I know. They
just should tell the story more clearly, and pretty please, with a
cherry on top, not drop loop-support completely.


&gt; disadvantage. Clemens Fruhwirth seemed to be a wise guy but
&gt; unfortunately he didn??t suggest a patch or some working files.

Actually, he did try to get his stuff included in mainline but made
the same experience as Jari did: Not Gonna Happen. The kernel gurus'
main concern is about maintainability and such.


&gt; Other mainline projects like truecrypt or parts of the standard
&gt; linux kernel might be backdoored. The loop-aes readme could include
&gt; advice on how to remove partition table and boot sector and some
&gt; plugin for k3b to burn encrypted cd/dvd on-the-fly would be
&gt; excellent, too.

I suppose by mainline projects you mean standalone projects.
Backdoors are always possible of course but with open source... let's
just say it would not be a smart idea to put a backdoor into an open
source programme.

I second the addition of the partitiontable-less setup magic to the
readme. And about that k3b plugin, I guess its author provides some
kind of plugin-howto for users who like to contribute. My programming
skills are rather rusty and I also lack the time for such a little
fun project (who doesn't these days?)

--=20
left blank, right bald
winter wanted, NOW!

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060611131125</emailId><senderName>markus reichelt</senderName><senderEmail>ml@mareichelt.de</senderEmail><timestampReceived>2006-06-11 13:11:25-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

* Jari Ruusu &lt;jariruusu@users.sourceforge.net&gt; wrote:

&gt; IOW, loop-AES provides better protection against changed location
&gt; disclosure than dm-crypt, cryptoloop, or ecryptfs.

I guess this includes recent truecrypt; according to its history
page[1] it seems it prefers LRW mode of operation since v4.1, end of
Nov 2005.


[1] http://www.truecrypt.org/user-guide/?s=version-history

-- 
left blank, right bald
winter wanted, NOW!

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060611131858</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-06-11 13:18:58-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

markus reichelt wrote:
&gt; * Jari Ruusu &lt;jariruusu@users.sourceforge.net&gt; wrote:
&gt; &gt; IOW, loop-AES provides better protection against changed location
&gt; &gt; disclosure than dm-crypt, cryptoloop, or ecryptfs.
&gt; 
&gt; I guess this includes recent truecrypt; according to its history
&gt; page[1] it seems it prefers LRW mode of operation since v4.1, end of
&gt; Nov 2005.

Yes. loop-AES provides better protection against changed location disclosure
than new LRW-mode truecrypt or old CBC-mode truecrypt.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060602095706</emailId><senderName>Phil H</senderName><senderEmail>philtickle200@yahoo.com</senderEmail><timestampReceived>2006-06-02 09:57:06-0400</timestampReceived><subject>Re: need some feedback please</subject><body>

Applications can write data of one sort or another to /tmp and configuration files \
and so on to /etc (and of course swap), or perhaps (clandestinely or not) to some \
other place that you don't expect.  Also, the filesystem remembers when progs and \
files were last accessed and metadata gets stored in the journal for eg ext3 \
filesystems.  It's perhaps a good thing that the journal gets rapidly overwritten \
during normal use.

You could run lsof on everything to find out what files are being opened and written \
to, but the easier way to be 100% sure that data (or information about your data) is \
not being written in plaintext somewhere is to:

1) Encrypt the whole filesystem and swap, or
2) Run a livecd without swap and write no unencrypted data to your hard drive.

In some ways (2) may be preferable since all you have then is an encrypted partition, \
which, as I understand it, is effectively impossible to distinguish from a randomly \
shredded partition.

Someone correct me if I'm wrong.
rodger ellis &lt;rellis@gmx.net&gt; wrote: Hello 

 I don't see the point in encrypting / if you put all your personal data on the /home \
partition. Then / contains just the operating system, and that's nothing someone who \
steals your computer would be interested in. Is my thinking correct here?
-- 


Der GMX SmartSurfer hilft bis zu 70% Ihrer Onlinekosten zu sparen!
      Ideal f�r Modem und ISDN: http://www.gmx.net/de/go/smartsurfer
    

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



 __________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 


[Attachment #3 (text/html)]

Applications can write data of one sort or another to /tmp and configuration files \
and so on to /etc (and of course swap), or perhaps (clandestinely or not) to some \
other place that you don't expect.  Also, the filesystem remembers when progs \
and files were last accessed and metadata gets stored in the journal for eg ext3 \
filesystems.  It's perhaps a good thing that the journal gets rapidly \
overwritten during normal use.&lt;br&gt;&lt;br&gt;You could run lsof on everything to find out \
what files are being opened and written to, but the easier way to be 100% sure that \
data (or information about your data) is not being written in plaintext somewhere is \
to:&lt;br&gt;&lt;br&gt;1) Encrypt the whole filesystem and swap, or&lt;br&gt;2) Run a livecd without \
swap and write no unencrypted data to your hard drive.&lt;br&gt;&lt;br&gt;In some ways (2) may be \
preferable since all you have then is an encrypted partition, which, as I understand \
it, is effectively impossible to distinguish from a randomly shredded  \
partition.&lt;br&gt;&lt;br&gt;Someone correct me if I'm wrong.&lt;br&gt;&lt;b&gt;&lt;i&gt;rodger ellis \
&lt;rellis@gmx.net&gt;&lt;/i&gt;&lt;/b&gt; wrote:&lt;blockquote class="replbq" style="border-left: \
2px solid rgb(16, 16, 255); margin-left: 5px; padding-left: 5px;"&gt; Hello &lt;br&gt;&lt;br&gt; I \
don't see the point in encrypting / if you put all your personal data on the /home \
partition. Then / contains just the operating system, and that's nothing someone who \
steals your computer would be interested in.&lt;br&gt;Is my thinking correct here?&lt;br&gt;-- \
&lt;br&gt;&lt;br&gt;&lt;br&gt;Der GMX SmartSurfer hilft bis zu 70% Ihrer Onlinekosten zu sparen!&lt;br&gt;    \
Ideal f�r Modem und ISDN: http://www.gmx.net/de/go/smartsurfer&lt;br&gt;    \
&lt;br&gt;&lt;br&gt;-&lt;br&gt;Linux-crypto:  cryptography in and on the Linux system&lt;br&gt;Archive:       \
http://mail.nl.linux.org/linux-crypto/&lt;br&gt;&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;p&gt; __________________________________________________&lt;br&gt;Do \
You Yahoo!?&lt;br&gt;Tired of spam?  Yahoo! Mail has the best spam protection around \
&lt;br&gt;http://mail.yahoo.com 


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060602135125</emailId><senderName>"M. Kammerer"</senderName><senderEmail>qad0t@altern.org</senderEmail><timestampReceived>2006-06-02 13:51:25-0400</timestampReceived><subject>Re: need some feedback please</subject><body>

Phil H@Fri, Jun 02, 2006 at 02:57:06AM -0700:
&gt; Applications can write data of one sort or another to /tmp and
&gt; configuration files and so on to /etc (and of course swap), or
&gt; perhaps (clandestinely or not) to some other place that you don't

Encrypting the whole filesystem makes your binaries tamperproof. As
mentioned in the mail quoted above, applications may do stuff you
don't expect, and they may have even been maliciously changed so that
they e.g. mail the important parts of your homedirectory to
someone. All you need to do is to tamper with a programme, preferably
daemon that runs as root. As soon as you mount your encrypted /home,
it has full access and can do remote backups of any kind. There goes
your privacy.

greetings.
Maxim


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060602161037</emailId><senderName></senderName><senderEmail>fap</senderEmail><timestampReceived>2006-06-02 16:10:37-0400</timestampReceived><subject>Re: need some feedback please</subject><body>

IMHO the answer is about your paranoia level. An unencrypted / partition will 
certainly give some intel about your data, whether in an encrypted partition 
or somewhere else. However, a cleverly mantained unencrypted / partition may 
be used as a decoy for a clean machine. Let me explain myself, the 
unencrypted / partition might mean that the machine doesn't need to encypher 
anything, therefore an uninteresting machine. However, if on the same machine 
you boot it with a Live OS and write to encrypted spaces of the disk, it 
might be possible to completely cloak the second use of the machine.

Please, correct me if I'm wrong.

On Friday 02 June 2006 01:11, rodger ellis wrote:
&gt; Hello
&gt;
&gt;  I don't see the point in encrypting / if you put all your personal data on
&gt; the /home partition. Then / contains just the operating system, and that's
&gt; nothing someone who steals your computer would be interested in. Is my
&gt; thinking correct here?

-- 
Ian

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060602165122</emailId><senderName>alan</senderName><senderEmail>alan@clueserver.org</senderEmail><timestampReceived>2006-06-02 16:51:22-0400</timestampReceived><subject>Re: need some feedback please</subject><body>

On Fri, 2 Jun 2006, fap@csociety.org wrote:

&gt; IMHO the answer is about your paranoia level. An unencrypted / partition will
&gt; certainly give some intel about your data, whether in an encrypted partition
&gt; or somewhere else. However, a cleverly mantained unencrypted / partition may
&gt; be used as a decoy for a clean machine. Let me explain myself, the
&gt; unencrypted / partition might mean that the machine doesn't need to encypher
&gt; anything, therefore an uninteresting machine. However, if on the same machine
&gt; you boot it with a Live OS and write to encrypted spaces of the disk, it
&gt; might be possible to completely cloak the second use of the machine.

The difficulty here is keeping the uncloaked OS form walking over the 
cloacked data in the encrypted section.  If it is done as seperate 
partitions, then anyone looking at the drive with fdisk will see something 
else is there.  If the encrypted data is in unused space, there has to be 
some way of keeping the other OS from writing over the data you want.

Allocating the encrypted data as bad sectors perhaps?

&gt;
&gt; Please, correct me if I'm wrong.
&gt;
&gt; On Friday 02 June 2006 01:11, rodger ellis wrote:
&gt;&gt; Hello
&gt;&gt;
&gt;&gt;  I don't see the point in encrypting / if you put all your personal data on
&gt;&gt; the /home partition. Then / contains just the operating system, and that's
&gt;&gt; nothing someone who steals your computer would be interested in. Is my
&gt;&gt; thinking correct here?
&gt;
&gt;

-- 
"Waiter! This lambchop tastes like an old sock!" - Sheri Lewis

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060603173954</emailId><senderName>markus reichelt</senderName><senderEmail>ml@mareichelt.de</senderEmail><timestampReceived>2006-06-03 17:39:54-0400</timestampReceived><subject>Re: need some feedback please</subject><body>

* rodger ellis &lt;rellis@gmx.net&gt; wrote:

&gt;  I don't see the point in encrypting / if you put all your personal
&gt; data on the /home partition. Then / contains just the operating
&gt; system, and that's nothing someone who steals your computer would
&gt; be interested in. Is my thinking correct here?

Additionally to what's been said already: If one doesn't want to
worry about adapting one's distro in such a way that no info
whatsoever about /home is revealed, encrypting the system completely
is the way to go. Lots of distros have some kind of cronjob by
default to index files. Try running locate on a file you have in
encrypted /home

SSH session to my laptop:

root@falcon:~# locate .muttrc
/home/chef/.muttrc

/home is encrypted and currently not mounted.

Granted, it's all about one's paranoia level, but it's important to
know both about possible drawbacks of only a partial system
encryption and the means available/necessary to counteract its
overall effects.

--=20
left blank, right bald

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060603184750</emailId><senderName>Hubert Chan</senderName><senderEmail>hubert@uhoreg.ca</senderEmail><timestampReceived>2006-06-03 18:47:50-0400</timestampReceived><subject>Re: need some feedback please</subject><body>

On Fri, 2 Jun 2006 15:51:25 +0200, "M. Kammerer" &lt;qad0t@altern.org&gt; said:

&gt; Phil H@Fri, Jun 02, 2006 at 02:57:06AM -0700:
&gt;&gt; Applications can write data of one sort or another to /tmp and
&gt;&gt; configuration files and so on to /etc (and of course swap), or
&gt;&gt; perhaps (clandestinely or not) to some other place that you don't

&gt; Encrypting the whole filesystem makes your binaries tamperproof. ...

It may make certain attack vectors harder, but it does not make it
tamperproof.

-- 
Hubert Chan - email &amp; Jabber: hubert@uhoreg.ca - http://www.uhoreg.ca/
PGP/GnuPG key: 1024D/124B61FA   (Key available at wwwkeys.pgp.net)
Fingerprint: 96C5 012F 5F74 A5F7 1FF7  5291 AF29 C719 124B 61FA


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060609082424</emailId><senderName>Phil H</senderName><senderEmail>philtickle200@yahoo.com</senderEmail><timestampReceived>2006-06-09 08:24:24-0400</timestampReceived><subject>Re: need some feedback please</subject><body>

Interesting discussion.

By not tamperproof, I imagine you are referring to the type of attacks where an \
attacker does something to the first portions of ciphertext in order to trick the \
user into revealing their password?

I can't help wondering if it shouldn't be possible to hash the entired encrypted \
device and seperately gpg encrypt that hashfile in order to subsequently detect \
whether or not the ciphertext on the device had been tampered with?

PS: When I was referring to live cd use I of course neglected to say the idea is that \
the livecd is kept secure so that OS binaries are not tamperable.




Hubert Chan &lt;hubert@uhoreg.ca&gt; wrote: On Fri, 2 Jun 2006 15:51:25 +0200, "M. \
Kammerer"  said:

&gt; Phil H@Fri, Jun 02, 2006 at 02:57:06AM -0700:
&gt; &gt; Applications can write data of one sort or another to /tmp and
&gt; &gt; configuration files and so on to /etc (and of course swap), or
&gt; &gt; perhaps (clandestinely or not) to some other place that you don't

&gt; Encrypting the whole filesystem makes your binaries tamperproof. ...

It may make certain attack vectors harder, but it does not make it
tamperproof.

-- 
Hubert Chan - email &amp; Jabber: hubert@uhoreg.ca - http://www.uhoreg.ca/
PGP/GnuPG key: 1024D/124B61FA   (Key available at wwwkeys.pgp.net)
Fingerprint: 96C5 012F 5F74 A5F7 1FF7  5291 AF29 C719 124B 61FA


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



 __________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 


[Attachment #3 (text/html)]

Interesting discussion.&lt;br&gt;&lt;br&gt;By not tamperproof, I imagine you are referring to the \
type of attacks where an attacker does something to the first portions of ciphertext \
in order to trick the user into revealing their password?&lt;br&gt;&lt;br&gt;I can't help \
wondering if it shouldn't be possible to hash the entired encrypted device and \
seperately gpg encrypt that hashfile in order to subsequently detect whether or not \
the ciphertext on the device had been tampered with?&lt;br&gt;&lt;br&gt;PS: When I was referring \
to live cd use I of course neglected to say the idea is that the livecd is kept \
secure so that OS binaries are not tamperable.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;&lt;i&gt;Hubert Chan \
&lt;hubert@uhoreg.ca&gt;&lt;/i&gt;&lt;/b&gt; wrote:&lt;blockquote class="replbq" style="border-left: \
2px solid rgb(16, 16, 255); margin-left: 5px; padding-left: 5px;"&gt; On Fri, 2 Jun 2006 \
15:51:25 +0200, "M. Kammerer" &lt;qad0t@altern.org&gt; said:&lt;br&gt;&lt;br&gt;&gt; Phil H@Fri, Jun \
02, 2006 at 02:57:06AM -0700:&lt;br&gt;&gt;&gt; Applications can write data of  one sort or \
another to /tmp and&lt;br&gt;&gt;&gt; configuration files and so on to /etc (and of course \
swap), or&lt;br&gt;&gt;&gt; perhaps (clandestinely or not) to some other place that you \
don't&lt;br&gt;&lt;br&gt;&gt; Encrypting the whole filesystem makes your binaries tamperproof. \
...&lt;br&gt;&lt;br&gt;It may make certain attack vectors harder, but it does not make \
it&lt;br&gt;tamperproof.&lt;br&gt;&lt;br&gt;-- &lt;br&gt;Hubert Chan - email &amp; Jabber: hubert@uhoreg.ca - \
http://www.uhoreg.ca/&lt;br&gt;PGP/GnuPG key: 1024D/124B61FA   (Key available at \
wwwkeys.pgp.net)&lt;br&gt;Fingerprint: 96C5 012F 5F74 A5F7 1FF7  5291 AF29 C719 124B \
61FA&lt;br&gt;&lt;br&gt;&lt;br&gt;-&lt;br&gt;Linux-crypto:  cryptography in and on the Linux \
system&lt;br&gt;Archive:       \
http://mail.nl.linux.org/linux-crypto/&lt;br&gt;&lt;br&gt;&lt;/qad0t@altern.org&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;p&gt; __________________________________________________&lt;br&gt;Do \
You Yahoo!?&lt;br&gt;Tired of spam?  Yahoo! Mail has the best spam protection around \
&lt;br&gt;http://mail.yahoo.com 


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060602181058</emailId><senderName>"Jordan Crouse"</senderName><senderEmail>jordan.crouse@amd.com</senderEmail><timestampReceived>2006-06-02 18:10:58-0400</timestampReceived><subject>Re: crypto: Add support for the Geode LX HW AES engine</subject><body>

On 02/06/06 13:32 -0400, Michael Frey wrote:
&gt; Jordan,
&gt; 
&gt; This looks great,  however are you going to release a patch against  
&gt; 2.6.11-geode?  2.6.11 is the version all geode patches were issued  
&gt; against.

There is a 2.6.11 version of this on the AMD website, if you need it.
I think that includes the Crypto API parts, but if not, I can make up 
a quick 2.6.11 patch and send it off to the list.

Since almost all the patches for Geode are now upstream (or heading
upstream quickly), then we're quickly converging on a point where the
2.6.11 patches will be only interesting from a historical standpoint. 
Or, at least - thats what I'm hoping. :)

Regards,
Jordan

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060602182822</emailId><senderName>"John Yoder"</senderName><senderEmail>john.yoder@amd.com</senderEmail><timestampReceived>2006-06-02 18:28:22-0400</timestampReceived><subject>Re: crypto: Add support for the Geode LX HW AES engine</subject><body>

Michael,

Once the upstreamed drivers have been put through are validation cycle, 
it is our intent to announce this on the AMD website as well as notify 
our FAE's of this. We are holding back the announcement so we don't "put 
our foot in it" I should also note that we expect no issue's with these, 
internally, I know several people are using the upstreamed drivers with 
the 2.6.16 kernel and haven't had any issues.

Regards,

John Yoder

Jordan Crouse wrote:
&gt; On 02/06/06 13:32 -0400, Michael Frey wrote:
&gt;   
&gt;&gt; Jordan,
&gt;&gt;
&gt;&gt; This looks great,  however are you going to release a patch against  
&gt;&gt; 2.6.11-geode?  2.6.11 is the version all geode patches were issued  
&gt;&gt; against.
&gt;&gt;     
&gt;
&gt; There is a 2.6.11 version of this on the AMD website, if you need it.
&gt; I think that includes the Crypto API parts, but if not, I can make up 
&gt; a quick 2.6.11 patch and send it off to the list.
&gt;
&gt; Since almost all the patches for Geode are now upstream (or heading
&gt; upstream quickly), then we're quickly converging on a point where the
&gt; 2.6.11 patches will be only interesting from a historical standpoint. 
&gt; Or, at least - thats what I'm hoping. :)
&gt;
&gt; Regards,
&gt; Jordan
&gt;
&gt; ---
&gt; You are currently subscribed to info-linux@geode.amd.com
&gt; as: john.yoder@amd.com
&gt; To unsubscribe send a blank email to:
&gt; leave-info-linux-7379A@whitestar.amd.com
&gt;   

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060605154512</emailId><senderName>"Jordan Crouse"</senderName><senderEmail>jordan.crouse@amd.com</senderEmail><timestampReceived>2006-06-05 15:45:12-0400</timestampReceived><subject>Re: crypto: Add support for the Geode LX HW AES engine</subject><body>

On 03/06/06 14:43 +0400, Evgeniy Polyakov wrote:
&gt; On Sat, Jun 03, 2006 at 09:07:52AM +1000, Herbert Xu (herbert@gondor.apana.org.au) wrote:
&gt; &gt; On Fri, Jun 02, 2006 at 05:23:41PM +0000, Jordan Crouse wrote:
&gt; &gt; &gt;
&gt; &gt; &gt; +	/* According to the silicon developers, the status will only
&gt; &gt; &gt; +	 * fail to clear on an catastrophic failure, so an infinite
&gt; &gt; &gt; +	 * loop is valid here
&gt; &gt; &gt; +	 */
&gt; &gt; &gt; +
&gt; &gt; &gt; +	do
&gt; &gt; &gt; +		status = AREAD(AES_INTR_REG);
&gt; &gt; &gt; +	while(!(status &amp; AES_INTRA_PENDING));
&gt; &gt; 
&gt; &gt; Is the chip capable of notifying completion via an interrupt?
&gt; 
&gt; Even if it can, it is impossible to use with cryptoapi in atomic contexts.
&gt; In process context it might be a slepp though.

It can notify completion via an interrupt, but we have found that 
unless the block lengths are huge, the latency of taking the interrupt and 
handling it is somewhat slower then just polling. 

It might be a good idea to separate this out and provide two entry points, 
one for atomic/polling, and the other for processes that can or want to
sleep and wait for completion.

Jordan

-- 
Jordan Crouse
Senior Linux Engineer
AMD - Personal Connectivity Solutions Group
&lt;www.amd.com/embeddedprocessors&gt;

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060605161117</emailId><senderName>"Jordan Crouse"</senderName><senderEmail>jordan.crouse@amd.com</senderEmail><timestampReceived>2006-06-05 16:11:17-0400</timestampReceived><subject>Re: crypto: Add support for the Geode LX HW AES engine</subject><body>

On 03/06/06 14:53 +0400, Evgeniy Polyakov wrote:
 
&gt; &gt; +static inline void AWRITE(unsigned long val, unsigned short reg) {
&gt; &gt; +#ifdef DEBUG
&gt; &gt; +	printk("[AES] W [%x]=%x\n", reg, val);
&gt; &gt; +#endif
&gt; &gt; +	iowrite32(val, _iobase + reg);
&gt; &gt; +}
&gt; &gt; +
&gt; &gt; +static inline unsigned int AREAD(unsigned short reg) {
&gt; &gt; +	unsigned int val = ioread32(_iobase + reg);
&gt; &gt; +#ifdef DEBUG
&gt; &gt; +	printk("[AES] R [%x]=%x\n", reg, val);
&gt; &gt; +#endif
&gt; &gt; +	return val;
&gt; &gt; +}
&gt; 
&gt; Remove above functions and use ioread/iowrite directly.

I'll turn AWRITE and AREAD into macros - I would rather abstract the
ioread/iowrite functionality away so we can easily maintain it.

&gt; Do not use __pa, use virt_to_phys() although it is the same for i386.

Sometimes its easy to get lazy when you're only playing with x86.. :)

&gt; &gt; +	AWRITE(len,  AES_LENA_REG);
&gt; &gt; +
&gt; &gt; +	/* Start the operation */
&gt; &gt; +	AWRITE(AES_CTRL_START | flags, AES_CTRLA_REG);
&gt; &gt; +
&gt; &gt; +	/* According to the silicon developers, the status will only
&gt; &gt; +	 * fail to clear on an catastrophic failure, so an infinite
&gt; &gt; +	 * loop is valid here
&gt; &gt; +	 */
&gt; &gt; +
&gt; &gt; +	do
&gt; &gt; +		status = AREAD(AES_INTR_REG);
&gt; &gt; +	while(!(status &amp; AES_INTRA_PENDING));
&gt; &gt; +
&gt; &gt; +	/* Clear the event */
&gt; &gt; +	AWRITE((status &amp; 0xFF) | AES_INTRA_PENDING, AES_INTR_REG);
&gt; &gt; +}
&gt; 
&gt; And how will system behave if that catastrophic failure happend?
&gt; Maybe it would be better to have counter and failure device shutdown in
&gt; case of error?
 
I struggle with this - on one hand, it is more correct to fail, but on
the other hand, catastrophic failure means that something horrible happened
to the silicon block (like overheating).  Since the AES block is in the 
northbridge, and the northbridge is integrated with the CPU, well - lets put
it this way - if the AES block stops working, then you probably have 
more concerns then decrypting a block of data.

Regardless, I'll stick a stupidly huge number counter here, and fail if it 
hits zero.

&gt; &gt; +unsigned int
&gt; &gt; +geode_aes_crypt(struct geode_aes_op *op)
&gt; &gt; +{
&gt; &gt; +	u32 flags = 0;
&gt; &gt; +
&gt; &gt; +	if (op-&gt;len == 0 || op-&gt;src == op-&gt;dst)
&gt; &gt; +		return 0;
&gt; &gt; +
&gt; &gt; +	if (mutex_lock_interruptible(&amp;emutex))
&gt; &gt; +		return 0;
&gt; 
&gt; I.e. it can not be used in atomic context?
&gt; That will break a lot of setups.

Is there any way to differentiate if a crypto API call was made in an
atomic context or not?  The problem here, is that I only have one engine,
so I need to protect it from multiple processes accessing it at the 
same time.  I can get rid of the sleep in an atomic context, but we expect
to have both atomic and process contexts heavily accessing the engine at
the same time, we really run the risk of having the atomic contexts fail 
more often then they should due to a process holding the mutex.

&gt; ...
&gt; 
&gt; &gt; +		.cipher = {
&gt; &gt; +			.cia_min_keysize	=  AES_KEY_LENGTH,
&gt; &gt; +			.cia_max_keysize	=  AES_KEY_LENGTH,
&gt; 
&gt; I.e. it does not support different keys?
&gt; If so, it should be called geode-aes-128, imho.

No - there is only one key size (128) - so I agree - its more correct to call
it geode-aes-128.

Jordan

-- 
Jordan Crouse
Senior Linux Engineer
AMD - Personal Connectivity Solutions Group
&lt;www.amd.com/embeddedprocessors&gt;

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060605165954</emailId><senderName>Geoff Thorpe</senderName><senderEmail>geoff.thorpe@freescale.com</senderEmail><timestampReceived>2006-06-05 16:59:54-0400</timestampReceived><subject>Re: crypto: Add support for the Geode LX HW AES engine</subject><body>

Jordan Crouse wrote:

&gt;Is there any way to differentiate if a crypto API call was made in an
&gt;atomic context or not?  The problem here, is that I only have one engine,
&gt;so I need to protect it from multiple processes accessing it at the 
&gt;same time.  I can get rid of the sleep in an atomic context, but we expect
&gt;to have both atomic and process contexts heavily accessing the engine at
&gt;the same time, we really run the risk of having the atomic contexts fail 
&gt;more often then they should due to a process holding the mutex.
&gt;  
&gt;

As your implementation is already spinning on completion, you probably 
have two choices - fail racers that lose;

    if(atomic_dec_and_test(...)) {
        atomic_inc(...);
        /* fail */
    }
    /* do crypto with spin */
    atomic_inc(...);
    /* success */

or use appropriate spin-locks. The latter is probably the only option. 
Though I hope the system doesn't bottleneck on crypto, otherwise 
everything will be spinning - either waiting to start crypto or waiting 
for it to complete.

Cheers,
Geoff

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060606012432</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-06-06 01:24:32-0400</timestampReceived><subject>Re: crypto: Add support for the Geode LX HW AES engine</subject><body>

Jordan Crouse &lt;jordan.crouse@amd.com&gt; wrote:
&gt;
&gt; Is there any way to differentiate if a crypto API call was made in an
&gt; atomic context or not?  The problem here, is that I only have one engine,
&gt; so I need to protect it from multiple processes accessing it at the 
&gt; same time.  I can get rid of the sleep in an atomic context, but we expect
&gt; to have both atomic and process contexts heavily accessing the engine at
&gt; the same time, we really run the risk of having the atomic contexts fail 
&gt; more often then they should due to a process holding the mutex.

Are there SMP Geode machines?

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060606065510</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-06-06 06:55:10-0400</timestampReceived><subject>Re: crypto: Add support for the Geode LX HW AES engine</subject><body>

On Mon, Jun 05, 2006 at 09:45:12AM -0600, Jordan Crouse (jordan.crouse@amd.com) wrote:
&gt; On 03/06/06 14:43 +0400, Evgeniy Polyakov wrote:
&gt; &gt; On Sat, Jun 03, 2006 at 09:07:52AM +1000, Herbert Xu (herbert@gondor.apana.org.au) wrote:
&gt; &gt; &gt; On Fri, Jun 02, 2006 at 05:23:41PM +0000, Jordan Crouse wrote:
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; +	/* According to the silicon developers, the status will only
&gt; &gt; &gt; &gt; +	 * fail to clear on an catastrophic failure, so an infinite
&gt; &gt; &gt; &gt; +	 * loop is valid here
&gt; &gt; &gt; &gt; +	 */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; +	do
&gt; &gt; &gt; &gt; +		status = AREAD(AES_INTR_REG);
&gt; &gt; &gt; &gt; +	while(!(status &amp; AES_INTRA_PENDING));
&gt; &gt; &gt; 
&gt; &gt; &gt; Is the chip capable of notifying completion via an interrupt?
&gt; &gt; 
&gt; &gt; Even if it can, it is impossible to use with cryptoapi in atomic contexts.
&gt; &gt; In process context it might be a slepp though.
&gt; 
&gt; It can notify completion via an interrupt, but we have found that 
&gt; unless the block lengths are huge, the latency of taking the interrupt and 
&gt; handling it is somewhat slower then just polling. 

What is the size of processed data which ends up in performance win with interrupts?

&gt; It might be a good idea to separate this out and provide two entry points, 
&gt; one for atomic/polling, and the other for processes that can or want to
&gt; sleep and wait for completion.

Consider posting benchmark results for different data sizes with polling
and interrupt driven completion notification.

&gt; Jordan

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060606071223</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-06-06 07:12:23-0400</timestampReceived><subject>Re: crypto: Add support for the Geode LX HW AES engine</subject><body>

On Mon, Jun 05, 2006 at 10:11:17AM -0600, Jordan Crouse (jordan.crouse@amd.com) wrote:
&gt; On 03/06/06 14:53 +0400, Evgeniy Polyakov wrote:
&gt;  
&gt; &gt; &gt; +static inline void AWRITE(unsigned long val, unsigned short reg) {
&gt; &gt; &gt; +#ifdef DEBUG
&gt; &gt; &gt; +	printk("[AES] W [%x]=%x\n", reg, val);
&gt; &gt; &gt; +#endif
&gt; &gt; &gt; +	iowrite32(val, _iobase + reg);
&gt; &gt; &gt; +}
&gt; &gt; &gt; +
&gt; &gt; &gt; +static inline unsigned int AREAD(unsigned short reg) {
&gt; &gt; &gt; +	unsigned int val = ioread32(_iobase + reg);
&gt; &gt; &gt; +#ifdef DEBUG
&gt; &gt; &gt; +	printk("[AES] R [%x]=%x\n", reg, val);
&gt; &gt; &gt; +#endif
&gt; &gt; &gt; +	return val;
&gt; &gt; &gt; +}
&gt; &gt; 
&gt; &gt; Remove above functions and use ioread/iowrite directly.
&gt; 
&gt; I'll turn AWRITE and AREAD into macros - I would rather abstract the
&gt; ioread/iowrite functionality away so we can easily maintain it.

Why do you want to have those ugly macros?
Quite good you do not use macros around mutexes.

&gt; &gt; Do not use __pa, use virt_to_phys() although it is the same for i386.
&gt; 
&gt; Sometimes its easy to get lazy when you're only playing with x86.. :)

But it does not mean it should be done.

&gt; &gt; &gt; +	AWRITE(len,  AES_LENA_REG);
&gt; &gt; &gt; +
&gt; &gt; &gt; +	/* Start the operation */
&gt; &gt; &gt; +	AWRITE(AES_CTRL_START | flags, AES_CTRLA_REG);
&gt; &gt; &gt; +
&gt; &gt; &gt; +	/* According to the silicon developers, the status will only
&gt; &gt; &gt; +	 * fail to clear on an catastrophic failure, so an infinite
&gt; &gt; &gt; +	 * loop is valid here
&gt; &gt; &gt; +	 */
&gt; &gt; &gt; +
&gt; &gt; &gt; +	do
&gt; &gt; &gt; +		status = AREAD(AES_INTR_REG);
&gt; &gt; &gt; +	while(!(status &amp; AES_INTRA_PENDING));
&gt; &gt; &gt; +
&gt; &gt; &gt; +	/* Clear the event */
&gt; &gt; &gt; +	AWRITE((status &amp; 0xFF) | AES_INTRA_PENDING, AES_INTR_REG);
&gt; &gt; &gt; +}
&gt; &gt; 
&gt; &gt; And how will system behave if that catastrophic failure happend?
&gt; &gt; Maybe it would be better to have counter and failure device shutdown in
&gt; &gt; case of error?
&gt;  
&gt; I struggle with this - on one hand, it is more correct to fail, but on
&gt; the other hand, catastrophic failure means that something horrible happened
&gt; to the silicon block (like overheating).  Since the AES block is in the 
&gt; northbridge, and the northbridge is integrated with the CPU, well - lets put
&gt; it this way - if the AES block stops working, then you probably have 
&gt; more concerns then decrypting a block of data.
&gt; 
&gt; Regardless, I'll stick a stupidly huge number counter here, and fail if it 
&gt; hits zero.

No need to create "stupidly huge number counter".
Setup reasonable counter and fail gracefully there.
If chip is overheated, busyloop definitely will not cool it down
and will not allow to do anything to recover.

&gt; &gt; &gt; +unsigned int
&gt; &gt; &gt; +geode_aes_crypt(struct geode_aes_op *op)
&gt; &gt; &gt; +{
&gt; &gt; &gt; +	u32 flags = 0;
&gt; &gt; &gt; +
&gt; &gt; &gt; +	if (op-&gt;len == 0 || op-&gt;src == op-&gt;dst)
&gt; &gt; &gt; +		return 0;
&gt; &gt; &gt; +
&gt; &gt; &gt; +	if (mutex_lock_interruptible(&amp;emutex))
&gt; &gt; &gt; +		return 0;
&gt; &gt; 
&gt; &gt; I.e. it can not be used in atomic context?
&gt; &gt; That will break a lot of setups.
&gt; 
&gt; Is there any way to differentiate if a crypto API call was made in an
&gt; atomic context or not?  The problem here, is that I only have one engine,
&gt; so I need to protect it from multiple processes accessing it at the 
&gt; same time.  I can get rid of the sleep in an atomic context, but we expect
&gt; to have both atomic and process contexts heavily accessing the engine at
&gt; the same time, we really run the risk of having the atomic contexts fail 
&gt; more often then they should due to a process holding the mutex.

You can detect sleeping context by checking tfm-&gt;crt_flags &amp; CRYPTO_TFM_REQ_MAY_SLEEP,
which is not the best way to do actually, since it might not be set by every
sleeping users.

It can be easily accessed from hardware interrupt context.

&gt; 
&gt; Jordan

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060606151914</emailId><senderName>"Jordan Crouse"</senderName><senderEmail>jordan.crouse@amd.com</senderEmail><timestampReceived>2006-06-06 15:19:14-0400</timestampReceived><subject>Re: crypto: Add support for the Geode LX HW AES engine</subject><body>

On 06/06/06 11:24 +1000, Herbert Xu wrote:
&gt; Jordan Crouse &lt;jordan.crouse@amd.com&gt; wrote:
&gt; &gt;
&gt; &gt; Is there any way to differentiate if a crypto API call was made in an
&gt; &gt; atomic context or not?  The problem here, is that I only have one engine,
&gt; &gt; so I need to protect it from multiple processes accessing it at the 
&gt; &gt; same time.  I can get rid of the sleep in an atomic context, but we expect
&gt; &gt; to have both atomic and process contexts heavily accessing the engine at
&gt; &gt; the same time, we really run the risk of having the atomic contexts fail 
&gt; &gt; more often then they should due to a process holding the mutex.
&gt; 
&gt; Are there SMP Geode machines?

No - but they can run with preempt turned on - so there's always the
risk that we can have two processes in the code at the same time.

Jordan

-- 
Jordan Crouse
Senior Linux Engineer
AMD - Personal Connectivity Solutions Group
&lt;www.amd.com/embeddedprocessors&gt;

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060606094453</emailId><senderName>Dike Ahmed</senderName><senderEmail>dikeahmed002@walla.com</senderEmail><timestampReceived>2006-06-06 09:44:53-0400</timestampReceived><subject>=?UTF-8?Q?=48=65=6C=6C=6F=2F=55=72=67=65=6E=74?=</subject><body>

[Attachment #2 (multipart/alternative)]

[Attachment #4 (text/html)]

&lt;div dir='ltr'&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br \
/&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br \
/&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;hr&gt;&lt;div \
style="background-color:white;color:black;"&gt;Walla! Mail - &lt;a \
href="http://www.walla.com" style="color:blue"&gt;get your free 3G mail today&lt;/a&gt;&lt;/div&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060606224647</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-06-06 22:46:47-0400</timestampReceived><subject>Re: crypto: Add support for the Geode LX HW AES engine</subject><body>

On Tue, Jun 06, 2006 at 09:19:14AM -0600, Jordan Crouse wrote:
&gt; 
&gt; No - but they can run with preempt turned on - so there's always the
&gt; risk that we can have two processes in the code at the same time.

preempt_disable should take care of both cases.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060607210245</emailId><senderName>"ZaptaClub"</senderName><senderEmail>club@zapta.co.il</senderEmail><timestampReceived>2006-06-07 21:02:45-0400</timestampReceived><subject>=?windows-1255?Q?=F8=E5=F6=E9=ED_=F8=EB=E1_=E7=E3=F9_=E0=E5_=EE=EC=E9=F1=E9=F0=E2_=E1=EE=E7=E9=F8_=E</subject><body>

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=Content-Type content="text/html; charset=windows-1255"&gt;
&lt;/head&gt;
&lt;body style="FONT-FAMILY: Arial"&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;font size=5&gt;&lt;font color=#0000a0&gt;&lt;strong&gt;&lt;span lang=HE&gt;æôèä áùéúåó 
îåòãåï äöøëðéí &lt;/span&gt;&lt;span dir=ltr&gt;Club 1&lt;br&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;font size=5&gt;&lt;font color=#0000a0&gt;&lt;strong&gt;&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/font&gt;&lt;font color=#050246&gt;&lt;span&gt;áò÷áåú äöìçåúéðå 
ä÷åãîåú åääðàåú ùìëí òí îáöòé äôìæîä åäãéì äèåá áéåúø áçáøú&lt;/span&gt;&lt;span&gt;&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;span dir=ltr&gt;&lt;/span&gt; äñìåìàø,&lt;/span&gt;&lt;/font&gt;&lt;span&gt;&lt;font 
color=#050246&gt;&lt;br&gt;àðçðå îáéàéí ìëí äôòí áîáöò àú äîëåðéåú äîáå÷ùåú áéåúø 
áîçéøéí&lt;/font&gt;&lt;/span&gt;&lt;span dir=ltr&gt;&lt;/span&gt;&lt;span&gt;&lt;span dir=ltr&gt;&lt;/span&gt;&lt;span 
dir=ltr&gt;&lt;/span&gt;&lt;font color=#050246&gt; äèåáéí áéåúø&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE&gt;&lt;font color=#050246&gt;âí çãùåú åâí éã ùðééä 
îìéñéðâ.&lt;br&gt;&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE&gt;&lt;/span&gt;&lt;span lang=HE&gt;&lt;strong&gt;&lt;font size=4&gt;&lt;font 
color=#0000ff&gt;&lt;a href="http://www.zapta.co.il/car/car.asp"&gt;ìçõ ëàï 
ìôøèéí&lt;/a&gt;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;



-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060608200915</emailId><senderName>"Dreyer Marc, FIN-SV-DLZ SL"</senderName><senderEmail>marc.dreyer@fin.be.ch</senderEmail><timestampReceived>2006-06-08 20:09:15-0400</timestampReceived><subject>Abwesenheitsnotiz: [ SPAM ] Returned mail: see transcript for details</subject><body>

Guten Tag        Bonjour
Ich bin abwesend und ab DI 20.06.06 wieder da.
Je suis absent et de retour le mardi, 20.03.06
Freundliche Gr=FCsse   salutations   Marc Dreyer




[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1"&gt;
&lt;META NAME="Generator" CONTENT="MS Exchange Server version 6.5.7638.1"&gt;
&lt;TITLE&gt;Abwesenheitsnotiz: [ SPAM ] Returned mail: see transcript for details&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;!-- Converted from text/plain format --&gt;

&lt;P&gt;&lt;FONT SIZE=2&gt;Guten Tag        Bonjour&lt;BR&gt;
Ich bin abwesend und ab DI 20.06.06 wieder da.&lt;BR&gt;
Je suis absent et de retour le mardi, 20.03.06&lt;BR&gt;
Freundliche Grüsse   salutations   Marc Dreyer&lt;BR&gt;
&lt;BR&gt;
&lt;BR&gt;
&lt;BR&gt;
&lt;/FONT&gt;
&lt;/P&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060609022431</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-06-09 02:24:31-0400</timestampReceived><subject>test--linux-crypto reachable or not</subject><body>

test, --------ignore if visible.

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060609081230</emailId><senderName>Phil H</senderName><senderEmail>philtickle200@yahoo.com</senderEmail><timestampReceived>2006-06-09 08:12:30-0400</timestampReceived><subject>Re: thanks for feedback, but once computer is on?</subject><body>

I don't follow your question.

if you are asking how you protect your data while the OS is running and a loop-aes \
encrypted partition is mounted, you walk away from your laptop and someone walks up \
and reads your data - well obviously you shouldn't walk away from your laptop when an \
encrypted partition is mounted.

If you are asking how do you protect your mounted encrypted partition from an attack \
over a network, then that's a network+desktop security issue rather than a loop-aes \
issue.  Obviously if an attacker has root access and your partition is mounted then \
they can read/alter that data.

My undretsanding is that it's best to unplug yourself from any network while using \
any kind of encryption, even from the power line if paranoid. For extreme paranoia, \
the machine should never ever be connected to any network and should be physically \
isolated (ie kept in a vault!). 



rodger ellis &lt;rellis@gmx.net&gt; wrote: Many thanks for all the feedbacks  to my \
question.

In the first instance aes-loop is the way to go, but once the computer is 
on and password has been applied then aes-loop has done its job -this is a very crude \
if  perhaps incorrect assumption. Now what measures can be taken to protect your \
data? for example (not a very good one as this is the other exterme) but you run a \
mail server, i suppose EncFS  might a step in the right direction. 

The circle I am trying to complete is encryption on a labtop
against say theft or trusted parties abuseing that trust,(loop-aes) and finally \
trying to think of a way to protect data once the os is running.


Rodger

-- 


Der GMX SmartSurfer hilft bis zu 70% Ihrer Onlinekosten zu sparen!
      Ideal f�r Modem und ISDN: http://www.gmx.net/de/go/smartsurfer
    

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



 __________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 


[Attachment #3 (text/html)]

I don't follow your question.&lt;br&gt;&lt;br&gt;if you are asking how you protect your data \
while the OS is running and a loop-aes encrypted partition is mounted, you walk away \
from your laptop and someone walks up and reads your data - well obviously you \
shouldn't walk away from your laptop when an encrypted partition is \
mounted.&lt;br&gt;&lt;br&gt;If you are asking how do you protect your mounted encrypted partition \
from an attack over a network, then that's a network+desktop security issue rather \
than a loop-aes issue.  Obviously if an attacker has root access and your \
partition is mounted then they can read/alter that data.&lt;br&gt;&lt;br&gt;My undretsanding is \
that it's best to unplug yourself from any network while using any kind of \
encryption, even from the power line if paranoid. For extreme paranoia, the machine \
should never ever be connected to any network and should be physically isolated (ie \
kept in a vault!). &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;&lt;i&gt;rodger ellis &lt;rellis@gmx.net&gt;&lt;/i&gt;&lt;/b&gt;  \
wrote:&lt;blockquote class="replbq" style="border-left: 2px solid rgb(16, 16, 255); \
margin-left: 5px; padding-left: 5px;"&gt; Many thanks for all the feedbacks  to my \
question.&lt;br&gt;&lt;br&gt;In the first instance aes-loop is the way to go, but once the \
computer is &lt;br&gt;on and password has been applied then aes-loop has done its job -this \
is a very crude if  perhaps incorrect assumption. Now what measures can be \
taken&lt;br&gt;to protect your data? for example (not a very good one as this is the other \
exterme) but you run a mail server, i suppose EncFS  might a step in the&lt;br&gt;right \
direction. &lt;br&gt;&lt;br&gt;The circle I am trying to complete is encryption on a \
labtop&lt;br&gt;against say theft or trusted parties abuseing that trust,(loop-aes) and \
finally trying to think of a way to protect data once the os is \
running.&lt;br&gt;&lt;br&gt;&lt;br&gt;Rodger&lt;br&gt;&lt;br&gt;-- &lt;br&gt;&lt;br&gt;&lt;br&gt;Der GMX SmartSurfer hilft bis zu 70% \
Ihrer Onlinekosten zu sparen!&lt;br&gt;      Ideal f�r Modem und ISDN: \
http://www.gmx.net/de/go/smartsurfer&lt;br&gt;     &lt;br&gt;&lt;br&gt;-&lt;br&gt;Linux-crypto:  cryptography \
in and on the Linux system&lt;br&gt;Archive:       \
http://mail.nl.linux.org/linux-crypto/&lt;br&gt;&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;p&gt; __________________________________________________&lt;br&gt;Do \
You Yahoo!?&lt;br&gt;Tired of spam?  Yahoo! Mail has the best spam protection around \
&lt;br&gt;http://mail.yahoo.com 


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060609135845</emailId><senderName></senderName><senderEmail>val_movieworld@virgilio.it</senderEmail><timestampReceived>2006-06-09 13:58:45-0400</timestampReceived><subject>PLS READ AND REPLY URGENT</subject><body>

Hi,
 Compliments of the day and how are you,hope you are fine and in a 
perfect condition of health.Writting you after going through your 
profile and i like it...,
  I am Valentina Nwosu,,a 24years old lady,,
I'm presently in Paris(FRANCE)..and currently working in a movie 
industry,"as a film writer and an actress"I have featured in so many 
nigerian movie(such as blood sisters and angel of my life).I have 
customers in different countries such as United State,United Kingdom 
and Canada,etc...because if the high rate in demand of my movies(CD's) 
and increase in the export if my CD's,,I now have more customers in 
overseas..My customers have agreed to pay me in cheque(Money Order,BOA 
e.t.c)...but i am not in the United State at present...So I want you to 
help me cash the cheque(Money Order,BOA e.t.c) OR to employ you as my 
staff(agent),,so my customers will write your name in the cheque(Money 
Order,BOA e.t.c) and send to your address and you will help me cash it 
then you will get 7% on each cheque,,,and you will send the rest to 
me...here in my home country...i will be greatfull,if you can be a 
client of mine...If you are interested you can contact me with on my 
email adress:val_movieworld@yahoo.com..And fill the following 
information below..  
 NAME:.......................
 
ADDRESS:....................
 CITY:.......................
 
ZIPCODE:....................
 PHONE:......................
 E-
MAIL:.....................
 i WILL BE EXPECTING YOUR SWIFT 
RESPONCE.....
Regards,
Valentina Nwosu.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060609173513</emailId><senderName>Hubert Chan</senderName><senderEmail>hubert@uhoreg.ca</senderEmail><timestampReceived>2006-06-09 17:35:13-0400</timestampReceived><subject>Re: need some feedback please</subject><body>

On Fri, 9 Jun 2006 01:24:24 -0700 (PDT), Phil H &lt;philtickle200@yahoo.com&gt; said:

&gt; Interesting discussion.

&gt; By not tamperproof, I imagine you are referring to the type of attacks
&gt; where an attacker does something to the first portions of ciphertext
&gt; in order to trick the user into revealing their password?

Well, for one thing, once the filesystem is mounted, an attacker can
still mess with your files.

&gt; I can't help wondering if it shouldn't be possible to hash the entired
&gt; encrypted device and seperately gpg encrypt that hashfile in order to
&gt; subsequently detect whether or not the ciphertext on the device had
&gt; been tampered with?

Yes, it should be entirely possible.  Although you probably want to gpg
sign it instead of gpg encrypt it.  But the downside is that you need to
read the entire disk to check if it's been tampered with.  I guess it
all depends on your level of paranoia, and how much you're willing to
put up with in the name of security.

-- 
Hubert Chan - email &amp; Jabber: hubert@uhoreg.ca - http://www.uhoreg.ca/
PGP/GnuPG key: 1024D/124B61FA   (Key available at wwwkeys.pgp.net)
Fingerprint: 96C5 012F 5F74 A5F7 1FF7  5291 AF29 C719 124B 61FA


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060612051738</emailId><senderName></senderName><senderEmail>michal</senderEmail><timestampReceived>2006-06-12 05:17:38-0400</timestampReceived><subject>[PATCH] VIA C7 CPU flags</subject><body>

New CPU flags for next generation of crypto engine as
found in VIA C7 processors.

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux-2.6.17-rc6/arch/i386/kernel/cpu/proc.c
===================================================================
--- linux-2.6.17-rc6.orig/arch/i386/kernel/cpu/proc.c
+++ linux-2.6.17-rc6/arch/i386/kernel/cpu/proc.c
@@ -52,7 +52,7 @@ static int show_cpuinfo(struct seq_file 
 
 		/* VIA/Cyrix/Centaur-defined */
 		NULL, NULL, "rng", "rng_en", NULL, NULL, "ace", "ace_en",
-		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		"ace2", "ace2_en", "phe", "phe_en", "pmm", "pmm_en", NULL, NULL,
 		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 
Index: linux-2.6.17-rc6/include/asm-i386/cpufeature.h
===================================================================
--- linux-2.6.17-rc6.orig/include/asm-i386/cpufeature.h
+++ linux-2.6.17-rc6/include/asm-i386/cpufeature.h
@@ -88,6 +88,12 @@
 #define X86_FEATURE_XSTORE_EN	(5*32+ 3) /* on-CPU RNG enabled */
 #define X86_FEATURE_XCRYPT	(5*32+ 6) /* on-CPU crypto (xcrypt insn) */
 #define X86_FEATURE_XCRYPT_EN	(5*32+ 7) /* on-CPU crypto enabled */
+#define X86_FEATURE_ACE2	(5*32+ 8) /* Advanced Cryptography Engine v2 */
+#define X86_FEATURE_ACE2_EN	(5*32+ 9) /* ACE v2 enabled */
+#define X86_FEATURE_PHE		(5*32+ 10) /* PadLock Hash Engine */
+#define X86_FEATURE_PHE_EN	(5*32+ 11) /* PHE enabled */
+#define X86_FEATURE_PMM		(5*32+ 12) /* PadLock Montgomery Multiplier */
+#define X86_FEATURE_PMM_EN	(5*32+ 13) /* PMM enabled */
 
 /* More extended AMD flags: CPUID level 0x80000001, ecx, word 6 */
 #define X86_FEATURE_LAHF_LM	(6*32+ 0) /* LAHF/SAHF in long mode */
@@ -121,6 +127,12 @@
 #define cpu_has_xstore_enabled	boot_cpu_has(X86_FEATURE_XSTORE_EN)
 #define cpu_has_xcrypt		boot_cpu_has(X86_FEATURE_XCRYPT)
 #define cpu_has_xcrypt_enabled	boot_cpu_has(X86_FEATURE_XCRYPT_EN)
+#define cpu_has_ace2		boot_cpu_has(X86_FEATURE_ACE2)
+#define cpu_has_ace2_enabled	boot_cpu_has(X86_FEATURE_ACE2_EN)
+#define cpu_has_phe		boot_cpu_has(X86_FEATURE_PHE)
+#define cpu_has_phe_enabled	boot_cpu_has(X86_FEATURE_PHE_EN)
+#define cpu_has_pmm		boot_cpu_has(X86_FEATURE_PMM)
+#define cpu_has_pmm_enabled	boot_cpu_has(X86_FEATURE_PMM_EN)
 
 #endif /* __ASM_I386_CPUFEATURE_H */
 

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060612095008</emailId><senderName>Phil H</senderName><senderEmail>philtickle200@yahoo.com</senderEmail><timestampReceived>2006-06-12 09:50:08-0400</timestampReceived><subject>Re: Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

Mr Fruhwirth (dm-crypt) and Mr Ruusu (loop-aes) have a bit of a interesting sparring \
history.  Read back over the list to see some of this.

For my money, loop-aes comes off as having much more credibility.

The dm-crypt people have never convincingly responded to Jari's well-aimed \
criticisms.  Instead they side track the debate with technobabble and arguments about \
threats not being significant.  But you cannot get only "a little bit" pregnant.

Peter_22@gmx.de wrote: Jari Ruusu  wrote:
&gt; [...] LRW mode is more vulnerable to changed location disclosure than CBC mode.
&gt; That is because each ciphertext block depends on only one plaintext block
&gt; and the encryption keys. In CBC mode, ciphertext also depends on
&gt; preceeding
&gt; plaintext blocks. The way IV is computed in loop-AES makes all ciphertext
&gt; blocks depend on all plaintext blocks in 512 byte sector.
&gt; 
&gt; IOW, loop-AES provides better protection against changed location 
&gt; disclosure
&gt; than dm-crypt, cryptoloop, or ecryptfs.

Ok, I suppose this is good news! My knowledge about attacks on ciphers and galois \
fields is quite faint, but I seriously hope the maintanance of loop-aes will go on. \
Since many tutorials and websites focus on loop-aes I deem it the right choice. \
Knoppix includes loop-aes, SuSE does not, but that need not be a disadvantage. \
Clemens Fruhwirth seemed to be a wise guy but unfortunately he didn ´t suggest a \
patch or some working files. Other mainline projects like truecrypt or parts of the \
standard linux kernel might be backdoored. The loop-aes readme could include advice \
on how to remove partition table and boot sector and some plugin for k3b to burn \
encrypted cd/dvd on-the-fly would be excellent, too.

Regards,
Peter

-- 


"Feel free" â€“ 10 GB Mailbox, 100 FreeSMS/Monat ...
Jetzt GMX TopMail testen: http://www.gmx.net/de/go/topmail

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



 __________________________________________________
Do You Yahoo!?
Tired of spam?  Yahoo! Mail has the best spam protection around 
http://mail.yahoo.com 


[Attachment #3 (text/html)]

Mr Fruhwirth (dm-crypt) and Mr Ruusu (loop-aes) have a bit of a interesting sparring \
history.  Read back over the list to see some of this.&lt;br&gt;&lt;br&gt;For my money, \
loop-aes comes off as having much more credibility.&lt;br&gt;&lt;br&gt;The dm-crypt people have \
never convincingly responded to Jari's well-aimed criticisms.  Instead they side \
track the debate with technobabble and arguments about threats not being \
significant.  But you cannot get only "a little bit" \
pregnant.&lt;br&gt;&lt;br&gt;&lt;b&gt;&lt;i&gt;Peter_22@gmx.de&lt;/i&gt;&lt;/b&gt; wrote:&lt;blockquote class="replbq" \
style="border-left: 2px solid rgb(16, 16, 255); margin-left: 5px; padding-left: \
5px;"&gt; Jari Ruusu &lt;jariruusu@users.sourceforge.net&gt; wrote:&lt;br&gt;&gt;[...] LRW mode is \
more vulnerable to changed location disclosure than CBC mode.&lt;br&gt;&gt; That is because \
each ciphertext block depends on only one plaintext block&lt;br&gt;&gt; and the encryption \
keys. In CBC mode, ciphertext also depends on&lt;br&gt;&gt; preceeding&lt;br&gt;&gt; plaintext \
blocks. The way IV is  computed in loop-AES makes all ciphertext&lt;br&gt;&gt; blocks \
depend on all plaintext blocks in 512 byte sector.&lt;br&gt;&gt; &lt;br&gt;&gt; IOW, loop-AES \
provides better protection against changed location &lt;br&gt;&gt; disclosure&lt;br&gt;&gt; than \
dm-crypt, cryptoloop, or ecryptfs.&lt;br&gt;&lt;br&gt;Ok, I suppose this is good news! My \
knowledge about attacks on ciphers and galois fields is quite faint, but I seriously \
hope the maintanance of loop-aes will go on. Since many tutorials and websites focus \
on loop-aes I deem it the right choice. Knoppix includes loop-aes, SuSE does not, but \
that need not be a disadvantage. Clemens Fruhwirth seemed to be a wise guy but \
unfortunately he didn ´t suggest a patch or some working files. Other mainline \
projects like truecrypt or parts of the standard linux kernel might be \
backdoored.&lt;br&gt;The loop-aes readme could include advice on how to remove partition \
table and boot sector and some plugin for k3b to burn encrypted cd/dvd on-the-fly \
would be excellent,  too.&lt;br&gt;&lt;br&gt;Regards,&lt;br&gt;Peter&lt;br&gt;&lt;br&gt;-- &lt;br&gt;&lt;br&gt;&lt;br&gt;"Feel free" \
â€“ 10 GB Mailbox, 100 FreeSMS/Monat ...&lt;br&gt;Jetzt GMX TopMail testen: \
http://www.gmx.net/de/go/topmail&lt;br&gt;&lt;br&gt;-&lt;br&gt;Linux-crypto:  cryptography in and on \
the Linux system&lt;br&gt;Archive:       \
http://mail.nl.linux.org/linux-crypto/&lt;br&gt;&lt;br&gt;&lt;/jariruusu@users.sourceforge.net&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;p&gt; __________________________________________________&lt;br&gt;Do \
You Yahoo!?&lt;br&gt;Tired of spam?  Yahoo! Mail has the best spam protection around \
&lt;br&gt;http://mail.yahoo.com 


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060613084728</emailId><senderName></senderName><senderEmail>info</senderEmail><timestampReceived>2006-06-13 08:47:28-0400</timestampReceived><subject>=?utf-8?Q?Re:_Spamed=3F?=</subject><body>

Thank you for your email. Our customer support staff will reply to you within 1 business day.



-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060616102050</emailId><senderName>Mrs Kimaeva Lioudmila</senderName><senderEmail>lioud_66@virgilio.it</senderEmail><timestampReceived>2006-06-16 10:20:50-0400</timestampReceived><subject>Dear Friend,</subject><body>

Dear Friend,
Firstly, this is not to cause you embarrassment, I am Ms.
KIMAEVA LIOUDMILA and I represent Diepreye Alamieyeseigha the Executive 
Governor of  Bayelsa State (the oil state), who was alledged of money 
laundering in london on 15th september, 2005 by his political rivalry 
because of the forth coming election.
I have a very sensitive and 
confidential brief from this top(oligarch) to ask for your partnership 
in re-profiling funds of ten million,two hundred thousand dollars ($10.2
million). I will give the details, but in summary, the funds are coming 
via Bank corresponding. This is a legitimate transaction. You will be 
paid 7% for your "management fees".If you are interested,
please reply 
to;
klioud1111@rediffmail.com  
and provide me with your confidential 
telephone number, fax number and email address and I will provide 
further details and instructions. Please keep this confidential. we 
can't afford any
more political money lundering problems accusation. 
Finally, please note that this must be concluded within two weeks. 
Please write back promptly. I will also suggest you visit these news 
sites on the internet to be better informed about this.
http://nm.
onlinenigeria.com/templates/?a=5302&amp;z=12
http://nm.onlinenigeria.
com/templates/?a=5269&amp;z=10
http://ndn.nigeriadailynews.com/templates/?
a=5929&amp;z=12
http://www.vanguardngr.
com/articles/2002/headline/f124092005.html
http://agonist.
org/story/2004/6/14/122041/463
http://websearch.edition.cnn.
com/search/search?
Coll=cnn_xml&amp;QuerySubmit=true&amp;query=Diepreye+Alamieyeseigha&amp;Page=1&amp;source=edition&amp;invocationType=search%
2Ftop&amp;sites=web&amp;QueryText=Diepreye+Alamieyeseigha
 
Write me back. I 
look forward to it.
Regards
Ms.KIMAEVA LIOUDMILA

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060617105727</emailId><senderName>"Redazione"</senderName><senderEmail>redazionepi@email.it</senderEmail><timestampReceived>2006-06-17 10:57:27-0400</timestampReceived><subject>Nuovi aggiornamenti.su .../New modernizations on...</subject><body>


Nuovi aggiornamenti su

http://utenti.lycos.it/pagineutili/index.html

dove potete trovare informazioni su viaggi, salute, lavoro, ...
dove potete inserire gratuitamente le vostre inserzioni o far
conoscere il vostro sito WEB.

----------------

Vorresti avere un tuo sito web ma non sai come fare?
Visita

http://utenti.lycos.it/grafart/index.html

==============================================

New modernizations on

http://utenti.lycos.it/pagineutili/index.html

where you can find information on travels, health, job...
where you can insert free of charge your insertions or
introduce your WEB site

----------------

You would want to have a your web site but you do not know like making?
Visit ......

http://utenti.lycos.it/grafart/index.html

La Redazione

---------------------------------------------------------------------

Questa e-mail non è spamming ai sensi della legge 675/96. Il trattamento
delle informazioni è conforme alla legge 675/96. Non riceverà altre e-mail,
il suo indirizzo non è stato inserito in nessun database.

----------------------------------------------------------------------


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060618210453</emailId><senderName></senderName><senderEmail>peter_22</senderEmail><timestampReceived>2006-06-18 21:04:53-0400</timestampReceived><subject>Re: Re: The evils of SuSE 10.1</subject><body>

&gt; Peter_22@gmx.de wrote:
&gt; &gt; drivers/scsi/built-in.o: In function `do_drive_get_GTF':
&gt; &gt; (.text+0x10edc): multiple definition of `do_drive_get_GTF'
&gt; &gt; drivers/ide/built-in.o:(.text+0xc03e): first defined here
&gt; &gt; ld: Warning: size of symbol `do_drive_get_GTF' changed from 469 in
&gt; drivers/ide/built-in.o to 1016 in drivers/scsi/built-in.o
&gt; &gt; make[1]: *** [drivers/built-in.o] Error 1
&gt; &gt; make: *** [drivers] Error 2
&gt; 
&gt; SUSE goofed. Untested fix:
&gt; 
&gt; # sed -e 's/do_drive_get_GTF/do_drive_get_GTFx/' &lt;drivers/ide/ide-acpi.c
&gt; &gt; z
&gt; # mv z drivers/ide/ide-acpi.c
&gt; # make bzImage

Thanks a lot! The build worked so far - with all changes needed to boot from USB. \
Hopefully it will all come to run now:-) Where would I be without your help, Jari!

Regards,
Peter

-- 


Echte DSL-Flatrate dauerhaft für 0,- Euro*!
"Feel free" mit GMX DSL! http://www.gmx.net/de/go/dsl

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060619141242</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-19 14:12:42-0400</timestampReceived><subject>Re: [PATCH  2/4] Twofish cipher - priority fix</subject><body>

This patch is now based on the cryptodev tree.

Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

 crypto/twofish.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/crypto/twofish.c b/crypto/twofish.c
index d5ef89a..9c7f19f 100644
--- a/crypto/twofish.c
+++ b/crypto/twofish.c
@@ -181,6 +181,8 @@ static void twofish_decrypt(struct crypt
 
 static struct crypto_alg alg = {
 	.cra_name           =   "twofish",
+	.cra_driver_name    =   "twofish-generic",
+	.cra_priority       =   100,
 	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize      =   TF_BLOCK_SIZE,
 	.cra_ctxsize        =   sizeof(struct twofish_ctx),
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060619141248</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-06-19 14:12:48-0400</timestampReceived><subject>Re: [PATCH  3/4] Twofish cipher - i586 assembler</subject><body>

This patch is now based on the cryptodev tree using the new cryptoapi (crypto  tfm
 instead of the crypto ctx as parameter).

The module passed the tcrypt tests and testscripts.

Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

 arch/i386/crypto/Makefile           |    3 
 arch/i386/crypto/twofish-i586-asm.S |  335 +++++++++++++++++++++++++++++++++++
 arch/i386/crypto/twofish.c          |   88 +++++++++
 crypto/Kconfig                      |   15 ++
 4 files changed, 441 insertions(+), 0 deletions(-)

diff --git a/arch/i386/crypto/Makefile b/arch/i386/crypto/Makefile
index 103c353..3fd19af 100644
--- a/arch/i386/crypto/Makefile
+++ b/arch/i386/crypto/Makefile
@@ -5,5 +5,8 @@ # Arch-specific CryptoAPI modules.
 # 
 
 obj-$(CONFIG_CRYPTO_AES_586) += aes-i586.o
+obj-$(CONFIG_CRYPTO_TWOFISH_586) += twofish-i586.o
 
 aes-i586-y := aes-i586-asm.o aes.o
+twofish-i586-y := twofish-i586-asm.o twofish.o
+
diff --git a/arch/i386/crypto/twofish-i586-asm.S b/arch/i386/crypto/twofish-i586-asm.S
new file mode 100644
index 0000000..0bae145
--- /dev/null
+++ b/arch/i386/crypto/twofish-i586-asm.S
@@ -0,0 +1,335 @@
+/***************************************************************************
+*   Copyright (C) 2006 by Joachim Fritschi, &lt;jfritschi@freenet.de&gt;        *
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+*   This program is distributed in the hope that it will be useful,       *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+*   GNU General Public License for more details.                          *
+*                                                                         *
+*   You should have received a copy of the GNU General Public License     *
+*   along with this program; if not, write to the                         *
+*   Free Software Foundation, Inc.,                                       *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+***************************************************************************/
+
+.file "twofish-i586-asm.S"
+.text
+
+#include &lt;asm/asm-offsets.h&gt;
+
+/* return adress at 0 */
+
+#define in_blk    12  /* input byte array address parameter*/
+#define out_blk   8  /* output byte array address parameter*/
+#define tfm       4  /* Twofish context structure */
+
+#define a_offset	0
+#define b_offset	4
+#define c_offset	8
+#define d_offset	12
+
+/* Structure of the crypto context struct*/
+
+#define s0	0	/* S0 Array 256 Words each */
+#define s1	1024	/* S1 Array */
+#define s2	2048	/* S2 Array */
+#define s3	3072	/* S3 Array */
+#define w	4096	/* 8 whitening keys (word) */
+#define k	4128	/* key 1-32 ( word ) */
+
+/* define a few register aliases to allow macro substitution */
+
+#define R0D    %eax
+#define R0B    %al
+#define R0H    %ah
+
+#define R1D    %ebx
+#define R1B    %bl
+#define R1H    %bh
+
+#define R2D    %ecx
+#define R2B    %cl
+#define R2H    %ch
+
+#define R3D    %edx
+#define R3B    %dl
+#define R3H    %dh
+
+
+/* performs input whitening */
+#define input_whitening(src,context,offset)\
+	xor	w+offset(context),	src;
+
+/* performs input whitening */
+#define output_whitening(src,context,offset)\
+	xor	w+16+offset(context),	src;
+
+/*
+a input register containing a (rotated 16)
+b input register containing b
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+*/
+#define encrypt_round(a,b,c,d,round)\
+push	d ## D;\
+movzx	b ## B,		%edi;\
+mov	s1(%ebp,%edi,4),d ## D;\
+movzx	a ## B,		%edi;\
+mov	s2(%ebp,%edi,4),%esi;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%ebp,%edi,4),d ## D;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%ebp,%edi,4),%esi;\
+movzx	b ## B,		%edi;\
+xor	s3(%ebp,%edi,4),d ## D;\
+movzx	a ## B,		%edi;\
+xor	(%ebp,%edi,4),	%esi;\
+movzx	b ## H,		%edi;\
+ror	$15,		b ## D;\
+xor	(%ebp,%edi,4),	d ## D;\
+movzx	a ## H,		%edi;\
+xor	s1(%ebp,%edi,4),%esi;\
+pop	%edi;\
+add	d ## D,		%esi;\
+add	%esi,		d ## D;\
+add	k+round(%ebp),	%esi;\
+xor	%esi,		c ## D;\
+rol	$15,		c ## D;\
+add	k+4+round(%ebp),d ## D;\
+xor	%edi,		d ## D;
+
+/*
+a input register containing a (rotated 16)
+b input register containing b
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+last round has different rotations for the output preparation
+*/
+#define encrypt_last_round(a,b,c,d,round)\
+push	d ## D;\
+movzx	b ## B,		%edi;\
+mov	s1(%ebp,%edi,4),d ## D;\
+movzx	a ## B,		%edi;\
+mov	s2(%ebp,%edi,4),%esi;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	s2(%ebp,%edi,4),d ## D;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%ebp,%edi,4),%esi;\
+movzx	b ## B,		%edi;\
+xor	s3(%ebp,%edi,4),d ## D;\
+movzx	a ## B,		%edi;\
+xor	(%ebp,%edi,4),	%esi;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%ebp,%edi,4),	d ## D;\
+movzx	a ## H,		%edi;\
+xor	s1(%ebp,%edi,4),%esi;\
+pop	%edi;\
+add	d ## D,		%esi;\
+add	%esi,		d ## D;\
+add	k+round(%ebp),	%esi;\
+xor	%esi,		c ## D;\
+ror	$1,		c ## D;\
+add	k+4+round(%ebp),d ## D;\
+xor	%edi,		d ## D;
+
+/*
+a input register containing a
+b input register containing b (rotated 16)
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+*/
+#define decrypt_round(a,b,c,d,round)\
+push	c ## D;\
+movzx	a ## B,		%edi;\
+mov	(%ebp,%edi,4),	c ## D;\
+movzx	b ## B,		%edi;\
+mov	s3(%ebp,%edi,4),%esi;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s1(%ebp,%edi,4),c ## D;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%ebp,%edi,4),	%esi;\
+movzx	a ## B,		%edi;\
+xor	s2(%ebp,%edi,4),c ## D;\
+movzx	b ## B,		%edi;\
+xor	s1(%ebp,%edi,4),%esi;\
+movzx	a ## H,		%edi;\
+ror	$15,		a ## D;\
+xor	s3(%ebp,%edi,4),c ## D;\
+movzx	b ## H,		%edi;\
+xor	s2(%ebp,%edi,4),%esi;\
+pop	%edi;\
+add	%esi,		c ## D;\
+add	c ## D,		%esi;\
+add	k+round(%ebp),	c ## D;\
+xor	%edi,		c ## D;\
+add	k+4+round(%ebp),%esi;\
+xor	%esi,		d ## D;\
+rol	$15,		d ## D;
+
+/*
+a input register containing a
+b input register containing b (rotated 16)
+c input register containing c
+d input register containing d (already rol $1)
+operations on a and b are interleaved to increase performance
+last round has different rotations for the output preparation
+*/
+#define decrypt_last_round(a,b,c,d,round)\
+push	c ## D;\
+movzx	a ## B,		%edi;\
+mov	(%ebp,%edi,4),	c ## D;\
+movzx	b ## B,		%edi;\
+mov	s3(%ebp,%edi,4),%esi;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s1(%ebp,%edi,4),c ## D;\
+movzx	b ## H,		%edi;\
+ror	$16,		b ## D;\
+xor	(%ebp,%edi,4),	%esi;\
+movzx	a ## B,		%edi;\
+xor	s2(%ebp,%edi,4),c ## D;\
+movzx	b ## B,		%edi;\
+xor	s1(%ebp,%edi,4),%esi;\
+movzx	a ## H,		%edi;\
+ror	$16,		a ## D;\
+xor	s3(%ebp,%edi,4),c ## D;\
+movzx	b ## H,		%edi;\
+xor	s2(%ebp,%edi,4),%esi;\
+pop	%edi;\
+add	%esi,		c ## D;\
+add	c ## D,		%esi;\
+add	k+round(%ebp),	c ## D;\
+xor	%edi,		c ## D;\
+add	k+4+round(%ebp),%esi;\
+xor	%esi,		d ## D;\
+ror	$1,		d ## D;
+
+.align 4
+.global twofish_enc_blk
+.global twofish_dec_blk
+
+twofish_enc_blk:
+	push	%ebp			/* save registers according to calling convention*/
+	push    %ebx
+	push    %esi			
+	push    %edi
+
+	mov	tfm + 16(%esp),	%ebp	/* abuse the base pointer: set new base bointer to the crypto tfm */
+	add	$crypto_tfm_ctx_offset, %ebp	/* ctx adress */
+	mov     in_blk+16(%esp),%edi	/* input adress in edi */
+
+	mov	(%edi),		%eax
+	mov	b_offset(%edi),	%ebx
+	mov	c_offset(%edi),	%ecx
+	mov	d_offset(%edi),	%edx
+	input_whitening(%eax,%ebp,a_offset)
+	ror	$16,	%eax
+	input_whitening(%ebx,%ebp,b_offset)
+	input_whitening(%ecx,%ebp,c_offset)
+	input_whitening(%edx,%ebp,d_offset)
+	rol	$1,	%edx
+
+	encrypt_round(R0,R1,R2,R3,0);
+	encrypt_round(R2,R3,R0,R1,8);
+	encrypt_round(R0,R1,R2,R3,2*8);
+	encrypt_round(R2,R3,R0,R1,3*8);
+	encrypt_round(R0,R1,R2,R3,4*8);
+	encrypt_round(R2,R3,R0,R1,5*8);
+	encrypt_round(R0,R1,R2,R3,6*8);
+	encrypt_round(R2,R3,R0,R1,7*8);
+	encrypt_round(R0,R1,R2,R3,8*8);
+	encrypt_round(R2,R3,R0,R1,9*8);
+	encrypt_round(R0,R1,R2,R3,10*8);
+	encrypt_round(R2,R3,R0,R1,11*8);
+	encrypt_round(R0,R1,R2,R3,12*8);
+	encrypt_round(R2,R3,R0,R1,13*8);
+	encrypt_round(R0,R1,R2,R3,14*8);
+	encrypt_last_round(R2,R3,R0,R1,15*8);
+
+	output_whitening(%eax,%ebp,c_offset)
+	output_whitening(%ebx,%ebp,d_offset)
+	output_whitening(%ecx,%ebp,a_offset)
+	output_whitening(%edx,%ebp,b_offset)
+	mov	out_blk+16(%esp),%edi;
+	mov	%eax,		c_offset(%edi)
+	mov	%ebx,		d_offset(%edi)
+	mov	%ecx,		(%edi)
+	mov	%edx,		b_offset(%edi)
+
+	pop	%edi
+	pop	%esi
+	pop	%ebx
+	pop	%ebp
+	mov	$1,	%eax
+	ret
+
+twofish_dec_blk:	
+	push	%ebp			/* save registers according to calling convention*/
+	push    %ebx
+	push    %esi			
+	push    %edi
+
+
+	mov	tfm + 16(%esp),	%ebp	/* abuse the base pointer: set new base bointer to the crypto tfm */
+	add	$crypto_tfm_ctx_offset, %ebp	/* ctx adress */
+	mov     in_blk+16(%esp),%edi	/* input adress in edi */
+
+	mov	(%edi),		%eax
+	mov	b_offset(%edi),	%ebx
+	mov	c_offset(%edi),	%ecx
+	mov	d_offset(%edi),	%edx
+	output_whitening(%eax,%ebp,a_offset)
+	output_whitening(%ebx,%ebp,b_offset)
+	ror	$16,	%ebx
+	output_whitening(%ecx,%ebp,c_offset)
+	output_whitening(%edx,%ebp,d_offset)
+	rol	$1,	%ecx
+
+	decrypt_round(R0,R1,R2,R3,15*8);
+	decrypt_round(R2,R3,R0,R1,14*8);
+	decrypt_round(R0,R1,R2,R3,13*8);
+	decrypt_round(R2,R3,R0,R1,12*8);
+	decrypt_round(R0,R1,R2,R3,11*8);
+	decrypt_round(R2,R3,R0,R1,10*8);
+	decrypt_round(R0,R1,R2,R3,9*8);
+	decrypt_round(R2,R3,R0,R1,8*8);
+	decrypt_round(R0,R1,R2,R3,7*8);
+	decrypt_round(R2,R3,R0,R1,6*8);
+	decrypt_round(R0,R1,R2,R3,5*8);
+	decrypt_round(R2,R3,R0,R1,4*8);
+	decrypt_round(R0,R1,R2,R3,3*8);
+	decrypt_round(R2,R3,R0,R1,2*8);
+	decrypt_round(R0,R1,R2,R3,1*8);
+	decrypt_last_round(R2,R3,R0,R1,0);
+
+	input_whitening(%eax,%ebp,c_offset)
+	input_whitening(%ebx,%ebp,d_offset)
+	input_whitening(%ecx,%ebp,a_offset)
+	input_whitening(%edx,%ebp,b_offset)
+	mov	out_blk+16(%esp),%edi;
+	mov	%eax,		c_offset(%edi)
+	mov	%ebx,		d_offset(%edi)
+	mov	%ecx,		(%edi)
+	mov	%edx,		b_offset(%edi)
+
+	pop	%edi
+	pop	%esi
+	pop	%ebx
+	pop	%ebp
+	mov	$1,	%eax
+	ret
diff --git a/arch/i386/crypto/twofish.c b/arch/i386/crypto/twofish.c
new file mode 100644
index 0000000..084d14c
--- /dev/null
+++ b/arch/i386/crypto/twofish.c
@@ -0,0 +1,88 @@
+/*
+ *  Glue Code for optimized 586 assembler version of TWOFISH
+ *
+ * Originally Twofish for GPG
+ * By Matthew Skala &lt;mskala@ansuz.sooke.bc.ca&gt;, July 26, 1998
+ * 256-bit key length added March 20, 1999
+ * Some modifications to reduce the text size by Werner Koch, April, 1998
+ * Ported to the kerneli patch by Marc Mutz &lt;Marc@Mutz.com&gt;
+ * Ported to CryptoAPI by Colin Slater &lt;hoho@tacomeat.net&gt;
+ *
+ * The original author has disclaimed all copyright interest in this
+ * code and thus put it in the public domain. The subsequent authors
+ * have put this under the GNU General Public License.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+ *
+ * This code is a "clean room" implementation, written from the paper
+ * _Twofish: A 128-Bit Block Cipher_ by Bruce Schneier, John Kelsey,
+ * Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson, available
+ * through http://www.counterpane.com/twofish.html
+ *
+ * For background information on multiplication in finite fields, used for
+ * the matrix operations in the key schedule, see the book _Contemporary
+ * Abstract Algebra_ by Joseph A. Gallian, especially chapter 22 in the
+ * Third Edition.
+ */
+
+#include &lt;asm/byteorder.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/bitops.h&gt;
+#include &lt;crypto/twofish.h&gt;
+
+
+asmlinkage void twofish_enc_blk(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
+
+asmlinkage void twofish_dec_blk(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
+
+
+static struct crypto_alg alg = {
+	.cra_name           =   "twofish",
+	.cra_driver_name    =	"twofish-i586",
+        .cra_priority       =   200,
+	.cra_flags          =   CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize      =   TF_BLOCK_SIZE,
+	.cra_ctxsize        =   sizeof(struct twofish_ctx),
+	.cra_alignmask      =	3,
+	.cra_module         =   THIS_MODULE,
+	.cra_list           =   LIST_HEAD_INIT(alg.cra_list),
+	.cra_u              =   { .cipher = {
+	.cia_min_keysize    =   TF_MIN_KEY_SIZE,
+	.cia_max_keysize    =   TF_MAX_KEY_SIZE,
+	.cia_setkey         =   twofish_setkey,
+	.cia_encrypt        =   twofish_enc_blk,
+	.cia_decrypt        =   twofish_dec_blk } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&amp;alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&amp;alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION ("Twofish Cipher Algorithm, i586 asm optimized");
diff --git a/crypto/Kconfig b/crypto/Kconfig
index f364260..28b203b 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -150,6 +150,21 @@ config CRYPTO_TWOFISH_COMMON
 	  Common parts of the Twofish cipher algorithm shared by the 
 	  generic c and the assembler implementations.
 
+config CRYPTO_TWOFISH_586
+	tristate "Twofish cipher algorithms (i586)"
+	depends on CRYPTO &amp;&amp; ((X86 || UML_X86) &amp;&amp; !64BIT)
+	select CRYPTO_TWOFISH_COMMON
+	help
+	  Twofish cipher algorithm.
+
+	  Twofish was submitted as an AES (Advanced Encryption Standard)
+	  candidate cipher by researchers at CounterPane Systems.  It is a
+	  16 round block cipher supporting key sizes of 128, 192, and 256
+	  bits.
+
+	  See also:
+	  &lt;http://www.schneier.com/twofish.html&gt;
+
 config CRYPTO_SERPENT
 	tristate "Serpent cipher algorithm"
 	depends on CRYPTO
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060619211004</emailId><senderName></senderName><senderEmail>peter_22</senderEmail><timestampReceived>2006-06-19 21:10:04-0400</timestampReceived><subject>Re: Re: Distinguishability of encrypted partition</subject><body>

Florian Reitmeir &lt;fr@3node.com&gt; wrote:
[...]
&gt; Much more interessting would it be to work on support for PKCS#11 USB
&gt; tokens
&gt; to get rid of the user-password. Only a minority boot from an crypto disk,
&gt; so a
&gt; trojan or "other" software can easily sniff your password (with X11 this
&gt; is
&gt; really very simple).
&gt; 
&gt; &gt; So my initial assumption was probably correct - it's the extraneous
&gt; factors (fstab,  having encryption software, etc) that probably remain the
&gt; practical indicators.

Sorry, you seem to have missed last part of loop-aes readme, don ´t you? I remember \
some notes on how to boot from a single USB Memory Stick. So indeed, there remains no \
"crypto" on the disk. I am sorry that the instructions on how to remove unwanted \
partition table / boot sector are not included in the readme now. The main problem \
is, that there might remain clear data on a disk. I don ´t think you can distingush \
between a "shred /dev/hda"-disc and an encrypted one I have dealt with.

Regards,
Peter
-- 


"Feel free" â€“ 10 GB Mailbox, 100 FreeSMS/Monat ...
Jetzt GMX TopMail testen: http://www.gmx.net/de/go/topmail

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060620102749</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-06-20 10:27:49-0400</timestampReceived><subject>Re: [PATCH  1/4] Twofish cipher - split out common c code</subject><body>

On Tue, Jun 20, 2006 at 08:26:11PM +1000, herbert wrote:
&gt; 
&gt; BTW, I had to add a few missing bits to twofish_common.c.  Next time
&gt; please make sure that you provide at least a MODULE_LICENSE and a
&gt; module_exit function.

Actually a module_exit function isn't required in this case but a
licence certainly is.
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060620111430</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-06-20 11:14:30-0400</timestampReceived><subject>Re: [PATCH  4/4] Twofish cipher - x86_64 assembler</subject><body>

On Mon, Jun 19, 2006 at 04:13:01PM +0200, Joachim Fritschi wrote:
&gt; This patch is now based on the cryptodev tree using the new cryptoapi (crypto  tfm
&gt;  instead of the crypto ctx as parameter).
&gt; 
&gt; The module passed the tcrypt tests and testscripts.
&gt; 
&gt; Signed-off-by: Joachim Fritschi &lt;jfritschi@freenet.de&gt;

Thanks Joachim.  I've applied all four patches.  I had to add wrappers
around the twofish assembly routines because asmlinkage may differ from
the normal C calling convention.  It should get optimised away to just
a jump if the conventions are identical.

BTW Andi, I think it might be better to have the x86-64 patch sit in the
cryptodev tree rather than x86-64 because it won't even compile without
the previous patches.  If you really want to, I can leave out the x86-64
one in particular for you to merge after the others go upstream.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060620224919</emailId><senderName></senderName><senderEmail>issforum-owner</senderEmail><timestampReceived>2006-06-20 22:49:19-0400</timestampReceived><subject>[[SPAM]]</subject><body>

You are not allowed to post to this mailing list, and your message has
been automatically rejected.  If you think that your messages are
being rejected in error, contact the mailing list owner at
issforum-owner@iss.net.


[Attachment #3 (message/rfc822)]

This is a multi-part message in MIME format.


------------------  Virus Warning Message (on atla-mx1)

Found virus WORM_MYDOOM.GEN in file rpkv.com (in rpkv.zip)
The file is deleted.

---------------------------------------------------------

[Attachment #6 (text/plain)]

�MT�U����}���h!
����^7�����9�TU�}8�*4s���b
���n`Q��f��n��7��I���KS�P(�Xo�;q�l��[)1�zq{�f���Q����'s&lt;#~��j[�����
Lt\�F��k��9
���3����&gt;�����~��r���_����%
�d��w\������\s*�8�T�J�uZ�!!� �����j��R�
��R�0A
�$���we�����3�q ����#��a�#5�s��%� �&amp;�IF�� \
��K��t�&lt;�c��_;�b������#�����c���qP$��:&amp;��0���6��V��$��Eb�/  \
;x��;�t��_�w�oV���������~Y�����-&lt; ��c���S;���&lt;������M��z**�T��j*��&lt;n�N&gt;z���F�XH��� \
�D� Wo}���Q�8��[7f�T��1����&lt;"�7v����$����p\/�U~|��YT�A Q��RE|$�u
����'�����?fzT�~���1��Pr�.G"����C��� ���(w�
������_�y�5 7j|bS�;��U;��
������X,#��
�����onm���'�wj9H|��ju�V�6w�~Ri ������S�f}��a�������
�Pgp��o��Y������C��4F�&amp;�k ����������DAz
��q�8�E5  ^����h�:e��Lq#H��
�pi�xL�z���BM��xp���`��N4*P"����&gt;&amp;����H�R�F���a�\-���
�m���i�v��T]z���
"����_Cp��\dbyn��U��wdc�\VM-4#����L�
�
uv&gt;}������G�-�����&gt;��f�V ��������o���!/��.7Q��KFw�����V3�V�j���.�3
���d�2���� �TyAI��� ��L�"a�2WMh,�L��q�!'�9�C1S��O�����^�-�%�]r���������������UA%/��o��8�]��
 �C���I�� �����_�� X �XC���D�[r0���n]M&amp;���:�l��P�����q�(���WFoI���*%�3�K���Y���q:[00R \
����XmO��t�Q��u���lh �$'�F��!�!d��\���#��`3��e��U�dp��������1�"� \
���&amp;�#*��;���������y��jj���}O�q���k���,�����y?9� 9m�
;"K��k��"�[[���[4��MM�r�Q�p���
����j��S���&gt;��T�\�o���My[�]�� T��u&amp;�����3�\�Ih�KB��m
�Q��Z��WU�%�%�KXt�?���/�w��P���G�����h����!3�
�Q����(������/�Shk��.^vl��u*3J��q8�L���R����w���Pd�K#5�Q�4���)����Tu4�MDfURy��j���R��}��Ws�Zh�����4I�\�$��h������Y�$1�*_1�.�qPU
 ���v#��&gt;����l�ffX����*�]��a���Y���a��r�L�VF�
R�T&amp;��`I�����k�;I&amp;���
H���9
��j�
����������VoU7�v������T������I`�'�C�&gt;�{��u0�OQ����O��nKu�"O�XN��q��m����E���8����wV(S2b�
 aw�N���C�d',u��*F�C��8��O�)��hj$����A`�Q^�\��;�X�*�����7���j������;
i��xD�l�����xPI���� 9�Q SQ2Q���SX�4��(�o�{��*/y��P�/Vz
")�#���3S�����-X�g�_?��!�E?����_����wk�d}z�Z \
�jm�sp�9$'k�Uj�i�1�.&amp;�y�&amp;z�f��z�l�~en����$�qR��� \
G���?,nR/XK�F���'��*���,�6u�?t����$�v�-�����h�9����}�����u7��W��:�"�6�o��Rs{��Q��1O-�S����Y��*��01{������C-u���m�b����
 ].���.�n���:���x9��$��Pc&lt;i`9����e�&amp;���c�0A���x����}�'Hm�UtB���G������,Hh'0�xt�r�&gt;������H!�
 ���$����b��!�U�����[�v
 4�sD[!7��LH|���(zVvj��8;�p,l�Q�&amp;������
g
����L�G#������v���\q&gt;R���
��* ��6�&lt;�����%T�:g�`!{�����ck
���E����V��(����������7^���X���(vmK\G�Bk2��������q�d����������r,��G�H��^8���8��:s��H��
 f�����0��Z��2V50�%
�.���b�kW��i�L�jmN�}�v�$ ��R~r������� \
�Q����,������~��M�B��/��4��V�V����fx���]�y��(����d��� ��r������h�����lo��� \
�3R�*.��_�lFi:q���/h������F�&gt;��&lt;���wEn�V�s����\�T:���6�I6d�s�#�, /`�$]P������:�X�� \
����g1���v��O�&amp;w D�d� \
2N���'��X��~�'�c����j��&gt;`�����S���F���'����C���W�_��M��Ro��L76�o�B��Ti�4O \
3��U���,�M�2�$� �)��j���������ZB��_���,|_t�����C#X��a��K�U����&amp;V��L%���vL{d��% \
j�;��,��-�U���Q�xS��8P�$ Q�����x&gt;��v_���}Z�]6��NG�i6���c,F $B���F�x��^�� UV/�"��n��]�
��s�������;I��k&gt;�bS�
!�&gt;�)�H�
;��z�kB������yCm-�We�[�jT������u��{����O��3mYis��Z����(9�5.6M���]��fI���5'��
�� }#4��GH�6'/���;x6���2�������xT��Q�����b���&lt;
�����.H\�.��!�&gt;�Dj���fW�&gt;�a�_b�Q \
����PNE��f�3W!e����0s$*ub�A����z_������qI��,�p�����tKe�\w��N*��^i\X� ��'`~-
z�&gt;����.



------------------  Virus Warning Message (on atla-mx1)

rpkv.zip is removed from here because it contains a virus.

---------------------------------------------------------
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060621010010</emailId><senderName>Michael Richardson</senderName><senderEmail>mcr@sandelman.ottawa.on.ca</senderEmail><timestampReceived>2006-06-21 01:00:10-0400</timestampReceived><subject>Re: crypto_cipher_encrypt_iv and null cipher</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1


&gt;&gt;&gt;&gt;&gt; "Herbert" == Herbert Xu &lt;herbert@gondor.apana.org.au&gt; writes:
    &gt;&gt; Well, there are not that many general notions of modes, so
    &gt;&gt; doesn't make this too scalable.  I still don't know why anyone
    &gt;&gt; would use ECB mode in practice.

    Herbert&gt; There are other modes like CFB, CTR, OFB, and IGE.  While

  yes, there are four more.

    Herbert&gt; If we continue to do it as we do now, we'd end up with a
    Herbert&gt; huge list of functions in cipher_alg.

  I think that you are prematurely optomizing.

- -- 
]       ON HUMILITY: to err is human. To moo, bovine.           |  firewalls  [
]   Michael Richardson,    Xelerance Corporation, Ottawa, ON    |net architect[
] mcr@xelerance.com      http://www.sandelman.ottawa.on.ca/mcr/ |device driver[
] panic("Just another Debian GNU/Linux using, kernel hacking, security guy"); [

    "The Microsoft _Get the Facts CD_ does not work on Linux." - orospakr

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.2.2 (GNU/Linux)
Comment: Finger me for keys

iQEVAwUBRJiaGICLcPvd0N1lAQJ9dgf8DKXAYUtwjbhYgoJV0NeTF5oeRXtvtELa
XOtAkd4/vuvo711D3kv4KsUZOWft/zea+5uEj7DCEforHyrplk9lxdP145oVWdkz
siVbZmKfJHGLabaKUqvStNlEi736IjDak2R5bQUnW2JPpbuDRV2ddpWHKcOo+ADh
QzDZzFKEY0oAIRBbtH/yp4sN6qOKrh7QbMFdY7vndraEiJIrwmjWBVFhXk6TRNUU
uUPhY3ysqKIPElSJfsSmnJc39agD1lhtluFIz0ne/IkreAB3Nthvr4KZDC/f1Jbk
Laa7U6hTB6dtbcnRCW0NTvha+iv4tdoW4baABfZ5QWVca1XXw6Y0UA==
=sPUZ
-----END PGP SIGNATURE-----
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060623172418</emailId><senderName>"ronald"</senderName><senderEmail>ronaldmcdonald2006@hotmail.com</senderEmail><timestampReceived>2006-06-23 17:24:18-0400</timestampReceived><subject>New message</subject><body>

www.acne.informationsites.tv
[Attachment #3 (text/html)]

&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META NAME="GENERATOR" Content="Microsoft DHTML Editing Control"&gt;
&lt;TITLE&gt;&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;DIV&gt;&lt;A
href="http://www.acne.informationsites.tv"&gt;www.acne.informationsites.tv&lt;/A&gt;&lt;/DIV&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060628183340</emailId><senderName>Boyd Waters</senderName><senderEmail>bwaters@nrao.edu</senderEmail><timestampReceived>2006-06-28 18:33:40-0400</timestampReceived><subject>Fwd: OMB Calls for 45 Day Laptop Encryption Deadline</subject><body>



Begin forwarded message:

&gt; From: fed-talk-bounces+cole=arl.army.mil@lists.apple.com
&gt; Sent: Wednesday, June 28, 2006 8:55 AM
&gt; To: fed-talk@lists.apple.com
&gt; Subject: [Fed-Talk] OMB Calls for 45 Day Laptop Encryption Deadline
&gt;
&gt; WaPo reports that OMB has issued guidance that all agencies must  
&gt; encrypt
&gt; the hard drives of all laptops with sensitive data within 45 days,  
&gt; using
&gt; two-factor encryption. To get a laptop excluded from the requirements,
&gt; the deputy secretary must sign off that the machine has no sensitive
&gt; information.
&gt;
&gt; &lt;http://www.washingtonpost.com/wp-dyn/content/article/2006/06/27/ 
&gt; AR20060
&gt; 6270
&gt; 0540.html&gt;
&gt;
&gt; &lt;http://www.whitehouse.gov/omb/memoranda/fy2006/m06-16.pdf&gt;
&gt;
&gt; --
&gt; Ben Stanfield (Contractor)
&gt; NHGRI LAN Support
&gt; stanfieldb at mail.nih.gov
&gt;
&gt; National Human Genome Research Institute National Institutes of Health
&gt; Bethesda, MD
&gt;
&gt; 301.451.2153


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060629140324</emailId><senderName></senderName><senderEmail>devprograms</senderEmail><timestampReceived>2006-06-29 14:03:24-0400</timestampReceived><subject>Acknowledgement of your email/submission</subject><body>



Message Subject: [WARNING: Virus Attack Detected] Hello	
Follow-Up: 17454544
Thank you for your email into the Apple Developer Connection (ADC). This \
acknowledgment is automatically generated and does not require a reply.

Your email has been received and assigned the follow-up number listed at the top of \
this message. Our support team will respond to your query as soon as possible. When \
submitting a follow-up email for this request, please include the follow-up number on \
the first line of your message (not in the subject).

Please note that this address &lt;devprograms@apple.com&gt; provides ADC membership \
program-level support to developers.  Below are some additional resources that may be \
of help to you in the future.

Our ADC Support team is available Monday through Friday 7am to 5pm PST.

Detailed information regarding the services provided through the Apple Developer \
Connection can be found at: http://www.apple.com/developer

For more information or to contact one of the following teams within the Apple \
Developer Connection, please refer to the Contact Us web page at: 

http://developer.apple.com/contact
 
ADC Programs, Products &amp; Services
ADC Pre-Release Software
Developer Technical Support
Developer Bug Reporting
ADC Feedback
ADC News
ADC Webmaster


Thank you,
The Apple Developer Connection Team
------------------------------------------------------------------
The Macintosh Products Guide web site lists over 23,000 hardware and software \
products for the Macintosh, including over 10,000 Mac OS X products, and is viewed \
worldwide by over a million Macintosh customers every month.  We encourage you to \
list and update all of your shipping products for free in the Guide by clicking the \
"Submit a Product" link. We also feature an inexpensive yet effective advertising \
program.

http://guide.apple.com/
------------------------------------------------------------------

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060629235042</emailId><senderName></senderName><senderEmail>reverend</senderEmail><timestampReceived>2006-06-29 23:50:42-0400</timestampReceived><subject>Re: root-crypto with loop-aes on debian-testing, 2.6.15-1-686--NEWTRY</subject><body>

&gt; AFAIK the patched versions have some options you need to use the full power
&gt; of loop-AES. You might want to take a look at loop-aes-utils that has
&gt; patched versions of mount/umount/losetup/swapon.
&gt; 
&gt; Greetings,
&gt;  Mike

Thanx for your answers,

anyway, I keep on trying ...........
Can I interpret that both of you have crypto-root-fs under debian using loop-aes 
and made it work with the README.txt from Jari Ruusu ?

I am looking for existing, real-life-heterosexual-people who made THEIR OWN
way of using loop-aes&gt;128 as root-fs under a main linux-distro on their own
computers.

Until now I only found anything else.

P.S.: Before I could start with any crypto-work my testsystem just went down from
          it's own problems after a standard-update, unable to start again.
          That's the state we are into ......

         Regards,    Reverend

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060507204746</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-05-07 20:47:46-0400</timestampReceived><subject>Re: [RFC][PATCH 1/2] Twofish cipher i586-asm optimized</subject><body>

After going over my patch again, i realized i missed the .cra_priority 
and .cra_driver_name setting in the crypto api struct. Here is an updated 
version of my patch:

http://homepages.tu-darmstadt.de/~fritschi/twofish/twofish-i586-asm-2.6.17-2.diff 

And also a little patch for the generic twofish implementation adding the 
appropriate values :

http://homepages.tu-darmstadt.de/~fritschi/twofish/twofish-priority-fix-2.6.17.diff

Regards,
Joachim

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060519104921</emailId><senderName>Gregor Zattler</senderName><senderEmail>telegraph@gmx.net</senderEmail><timestampReceived>2006-05-19 10:49:21-0400</timestampReceived><subject>How about deniability? (read: http://www.zdnet.co.uk/print/?TYPE=story&amp;AT=39269746-39020330t-1000002</subject><body>

Hi,

"Government to force handover of encryption keys"
http://www.zdnet.co.uk/print/?TYPE=story&amp;AT=39269746-39020330t-10000025c

does loop-aes provide some kind of deniability?  

Does any other free crypto system?

Ciao, Gregor
-- 
 -... --- .-. . -.. ..--.. ...-.-

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060519192712</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-05-19 19:27:12-0400</timestampReceived><subject>Re: How about deniability? (read:</subject><body>

Gregor Zattler wrote:
&gt; does loop-aes provide some kind of deniability?

Yes, if you set it up that way. For example, if you set up a computer to
first try to boot from USB-stick, and then to try hard disk boot.

disk partition  Normal boot usage             Forced key handover boot usage
~~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~~             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/dev/hda1       not used                      unencrypted /boot
/dev/hda2       not used                      encrypted root
/dev/hda3       encrypted swap, random keys   encrypted swap, random keys
/dev/hda4       encrypted root                encrypted /tmp, random keys

USB-stick       Normal boot usage             Forced key handover boot usage
~~~~~~~~~       ~~~~~~~~~~~~~~~~~             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/dev/sda        unencrypted /boot             not used

You install some small distro on /dev/hda2, and never put any secret data
there. You install your normal distro on /dev/hda4, and put your secret data
there.

On normal usage, you always boot your computer from USB-stick to encrypted
root on /dev/hda4. Key files used for encrypting /dev/hda4 and /dev/hda2 are
different, and use different gpg passphrases. If you accidentally try to
boot from hard disk, you never enter the 'key handover' passphrase. When you
are forced to reveal the 'key handover' passphrase, your computer boots to
encrypted root on /dev/hda2. You can do that only *once*, because according
to /etc/fstab on /dev/hda2 root partition, mount sets up random loop
encryption keys on /dev/hda4, and runs 'mkfs' on /dev/hda4, effectively
overwriting file system structure there. After one such 'key handover' boot,
even when used with correct key file and passphrase from your USB-stick, you
or anyone else, have significant difficulties recovering data from
/dev/hda4.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060519113533</emailId><senderName>"Antonio Di Salvo"</senderName><senderEmail>disalvo.antonio@gmail.com</senderEmail><timestampReceived>2006-05-19 11:35:33-0400</timestampReceived><subject>Re: How about deniability? (read: http://www.zdnet.co.uk/print/?TYPE=story&amp;AT=39269746-39020330t-100</subject><body>

truecrypt offers a feature called hidden volume that makes use of a
nested encrypted file system. If forced, you can reveal the password
of the outer volume, while the one that really holds sensitive data is
hidden and cannot be distinguished from random data.
they give an explanation at this url: http://www.truecrypt.org/hiddenvolume.php

I'm not aware if loop-aes provides something similar, so I cannot
answer you. However, I think not (IMHO). If someone know if it is
possibile to have completely random-looking data on the disk with root
partition encryption, please let me know.

Byez!

PS: sorry for the english!

On 5/19/06, Gregor Zattler &lt;telegraph@gmx.net&gt; wrote:
&gt; Hi,
&gt;
&gt; "Government to force handover of encryption keys"
&gt; http://www.zdnet.co.uk/print/?TYPE=story&amp;AT=39269746-39020330t-10000025c
&gt;
&gt; does loop-aes provide some kind of deniability?
&gt;
&gt; Does any other free crypto system?
&gt;
&gt; Ciao, Gregor
&gt; --
&gt;  -... --- .-. . -.. ..--.. ...-.-
&gt;
&gt; -
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/
&gt;
&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060520164947</emailId><senderName>"Michael Garibaldi"</senderName><senderEmail>michaelgari@gmail.com</senderEmail><timestampReceived>2006-05-20 16:49:47-0400</timestampReceived><subject>Re: How about deniability? (read:http://www.zdnet.co.uk/print/?TYPE=story&amp;AT=39269746-39020330t-1000</subject><body>

&gt;&gt; Here user insists that /dev/hda2 is the root partition. That way all har=
d

&gt;&gt; disk space is accounted for. Attacker can prove existence of one small
gpg
&gt;&gt; encrypted file on USB-stick for which user has forgotten passphrase.
&gt; That just doesn't fly with for e.g. when you computer is sized by the
police when you are away from home.

Obviously the police are not going to find one's USB stick on the computer,
when one is not home. The stick is ONLY used for booting and then carefully
hidden. It does not matter if the "self destruct" works or not, what matter=
s
is that there is absolutely no reason to even suspect that a different kind
of encryption is being used on the system. It boots from the HDD and uses
all the available space, and the police will get the key that will unlock
the fake system, and that's it. As long as the USB stick is kept safe (whic=
h
should be trivial to do), they have absolutely nothing to even suggest ther=
e
being a parallel system encrypted with other keys. And as Jari pointed out,
even if they actually get the USB stick too, they really cannot prove
anything.

P.S. they may, however, be smart enough to type one's name on Google and
find out that one has been discussing this topic on this public mailing
list.

[Attachment #3 (text/html)]

&gt;&gt; Here user insists that /dev/hda2 is the root partition. That way all hard
&lt;br&gt;&gt;&gt; disk space is accounted for. Attacker can prove existence of one small \
gpg &lt;br&gt;&gt;&gt; encrypted file on USB-stick for which user has forgotten passphrase.
&lt;br&gt;
&gt; That just doesn't fly with for e.g. when you computer is sized by the 
police when you are away from home.
&lt;br&gt;
&lt;br&gt;Obviously the police are not going to find one's USB stick on the computer, when \
one is not home. The stick is ONLY used for booting and then carefully hidden. It \
does not matter if the "self destruct" works or not, what matters is that \
there is absolutely no reason to even suspect that a different kind of encryption is \
being used on the system. It boots from the HDD and uses all the available space, and \
the police will get the key that will unlock the fake system, and that's it. As long \
as the USB stick is kept safe (which should be trivial to do), they have absolutely \
nothing to even suggest there being a parallel system encrypted with other keys. And \
as Jari pointed out, even if they actually get the USB stick too, they really cannot \
prove anything. &lt;br&gt;&lt;br&gt;P.S. they may, however, be smart enough to type one's name on \
Google and find out that one has been discussing this topic on this public mailing \
list.&lt;br&gt;&lt;br&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060520185217</emailId><senderName>Matthias Schniedermeyer</senderName><senderEmail>ms@citd.de</senderEmail><timestampReceived>2006-05-20 18:52:17-0400</timestampReceived><subject>Re: How about deniability? (read:http://www.zdnet.co.uk/print/?TYPE=story&amp;AT=39269746-39020330t-1000</subject><body>

Michael Garibaldi wrote:
&gt;  &gt;&gt; Here user insists that /dev/hda2 is the root partition. That way all 
&gt; hard
&gt;  &gt;&gt; disk space is accounted for. Attacker can prove existence of one 
&gt; small gpg
&gt;  &gt;&gt; encrypted file on USB-stick for which user has forgotten passphrase.
&gt;  &gt; That just doesn't fly with for e.g. when you computer is sized by the 
&gt; police when you are away from home.
&gt; 
&gt; Obviously the police are not going to find one's USB stick on the 
&gt; computer, when one is not home. The stick is ONLY used for booting and 
&gt; then carefully hidden. It does not matter if the "self destruct" works 
&gt; or not, what matters is that there is absolutely no reason to even 
&gt; suspect that a different kind of encryption is being used on the system. 
&gt; It boots from the HDD and uses all the available space, and the police 
&gt; will get the key that will unlock the fake system, and that's it. As 
&gt; long as the USB stick is kept safe (which should be trivial to do), they 
&gt; have absolutely nothing to even suggest there being a parallel system 
&gt; encrypted with other keys. And as Jari pointed out, even if they 
&gt; actually get the USB stick too, they really cannot prove anything.

When you don't "boot" the system, but inspect the HDD-Image from another 
system
there are a few "obvious" information missing which you had when you 
actually booted the system.

So for the police you would have an unencrypted "boot" partition and 3 
partitions with random data.

 From the unencrypted partition would would get an indication that the 2 
second partition contains a root-filesystem, but that's about what you 
can get from the sample-setup without breaking the decryption.

So from the police-Standpoint there are 3 "unaccounted" partitions.

If you encrypted the whole HDD (including sector 0) the deniability 
would be slightly better as there is no "partition" at all you could say 
that you just hadn't hat time to install the computer. :-)

Or use a random reagion on the HDD and filling the rest with random data.
e.g. when you have a 200GB HDD, fill it with 200GB of random data and 
then just use the range from e.g. 96GB-145GB.
As it shouldn't be possible distinguish the encrypted data from the 
actual random-data you would have enough room for another "container" as 
a decoy.

&gt; P.S. they may, however, be smart enough to type one's name on Google and 
&gt; find out that one has been discussing this topic on this public mailing 
&gt; list.

That's the drawback when you have a (AFAICS) "unique" name.

P.S.
If i'm not mistaken you aren't using your real name.




Bis denn

-- 
Real Programmers consider "what you see is what you get" to be just as
bad a concept in Text Editors as it is in women. No, the Real Programmer
wants a "you asked for it, you got it" text editor -- complicated,
cryptic, powerful, unforgiving, dangerous.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060521132954</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-05-21 13:29:54-0400</timestampReceived><subject>[CRYPTO] Pass TFM instead of context into digest algos' final() method</subject><body>

Hi Herbert,

attached is an obvious fix for your "Pass TFM instead of CTX" patch.
Please apply to your GIT tree.

Michal

["digest-final-fix.diff" (text/x-patch)]

Pass TFM instead of context into digest algos' final() method.

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux/crypto/digest.c
===================================================================
--- linux.orig/crypto/digest.c
+++ linux/crypto/digest.c
@@ -70,10 +70,10 @@ static void final(struct crypto_tfm *tfm
 		unsigned int size = crypto_tfm_alg_digestsize(tfm);
 		u8 buffer[size + alignmask];
 		u8 *dst = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
-		tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(crypto_tfm_ctx(tfm), dst);
+		tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(tfm, dst);
 		memcpy(out, dst, size);
 	} else
-		tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(crypto_tfm_ctx(tfm), out);
+		tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(tfm, out);
 }
 
 static int setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060522022018</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-05-22 02:20:18-0400</timestampReceived><subject>Add missing accessors for new crypto_alg fields.</subject><body>

Add missing accessors for new crypto_alg fields.

Michal

["crypto-alg-accessors.diff" (text/x-patch)]

Add missing accessors for new crypto_alg fields.

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux/include/linux/crypto.h
===================================================================
--- linux.orig/include/linux/crypto.h
+++ linux/include/linux/crypto.h
@@ -258,6 +258,16 @@ static inline const char *crypto_tfm_alg
 	return tfm-&gt;__crt_alg-&gt;cra_name;
 }
 
+static inline const char *crypto_tfm_alg_driver_name(struct crypto_tfm *tfm)
+{
+	return tfm-&gt;__crt_alg-&gt;cra_driver_name;
+}
+
+static inline int crypto_tfm_alg_priority(struct crypto_tfm *tfm)
+{
+	return tfm-&gt;__crt_alg-&gt;cra_priority;
+}
+
 static inline const char *crypto_tfm_alg_modname(struct crypto_tfm *tfm)
 {
 	return module_name(tfm-&gt;__crt_alg-&gt;cra_module);

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060523175942</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-05-23 17:59:42-0400</timestampReceived><subject>Re: Remove encryption from kernel?</subject><body>

On Tue, May 23, 2006 at 07:18:50PM +0200, The Hog (thehog@t3i.nl) wrote:
&gt; Hi,
&gt; 
&gt; I have ben told that the Linux kernel contains cryptographic code in many
&gt; places. U.S. export restrictions forbid to export software that contains
&gt; cryptographic code to certain countries, such as Iran. This also applies to
&gt; the Linux kernel.

Did you hear that Russians have a nuclear weapon?

&gt; Would it be possible to build a kernel that does not contain cryptographic
&gt; algorithms? I understand that several cryptographic options can be disabled
&gt; through "make menuconfig". But, will that be enough or are there crypto
&gt; routines in the kernel that cannot be removed?

Disable NET and block layer to be able to disable cryptoapi.
It can be more fine grained though.

&gt; Note that disabling cryptographic functionality is not enough, the
&gt; cryptographic code may not be compiled and linked into the binary kernel
&gt; image at all. Nor may any cryptographic library, kernel or user module
&gt; contain cryptographic functionality.

Can rot13 algo and userspace utility be considered as "cryptographic
library, kernel or user module"?

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060520131127</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-05-20 13:11:27-0400</timestampReceived><subject>Re: How about deniability?</subject><body>

Info wrote:
&gt; Although I will agree that this provides a great deal of security for the
&gt; data I don't think that it provides 'deniability'. In particular if the
&gt; attack consists of physical possession of the computer and an analysis of
&gt; the disk drive content without the attempt to boot it,

After handing over the passphrase to /dev/hda2 root partition, all hard disk
space is accounted for. Files on /dev/hda1 and /dev/hda2 are readable, and
user can prove that programs on /dev/hda2 root partition create random
encryption keys for /dev/hda3 and /dev/hda4 on each boot, and that user has
no way of knowing what earlier encryption keys were on those two partitions.

&gt; and even more so if the usb key is available to the attacker.

Here user insists that /dev/hda2 is the root partition. That way all hard
disk space is accounted for. Attacker can prove existence of one small gpg
encrypted file on USB-stick for which user has forgotten passphrase.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060520162831</emailId><senderName>Matthias Schniedermeyer</senderName><senderEmail>ms@citd.de</senderEmail><timestampReceived>2006-05-20 16:28:31-0400</timestampReceived><subject>Re: How about deniability?  (read:http://www.zdnet.co.uk/print/?TYPE=story&amp;AT=39269746-39020330t-100</subject><body>

Jari Ruusu wrote:
&gt; Info wrote:
&gt; 
&gt;&gt;Although I will agree that this provides a great deal of security for the
&gt;&gt;data I don't think that it provides 'deniability'. In particular if the
&gt;&gt;attack consists of physical possession of the computer and an analysis of
&gt;&gt;the disk drive content without the attempt to boot it,
&gt; 
&gt; 
&gt; After handing over the passphrase to /dev/hda2 root partition, all hard disk
&gt; space is accounted for. Files on /dev/hda1 and /dev/hda2 are readable, and
&gt; user can prove that programs on /dev/hda2 root partition create random
&gt; encryption keys for /dev/hda3 and /dev/hda4 on each boot, and that user has
&gt; no way of knowing what earlier encryption keys were on those two partitions.
&gt; 
&gt; 
&gt;&gt;and even more so if the usb key is available to the attacker.
&gt; 
&gt; 
&gt; Here user insists that /dev/hda2 is the root partition. That way all hard
&gt; disk space is accounted for. Attacker can prove existence of one small gpg
&gt; encrypted file on USB-stick for which user has forgotten passphrase.

That just doesn't fly with for e.g. when you computer is sized by the 
police when you are away from home.

In a german magazine there was an article about disc duplication that 
was written by someone from the police.

They NEVER would boot a computer, as it is, after they sized it.
They take out the HDD and make a backup of it and only operate on these 
backups, then the computer and the original HDD(s) is locked away.
(The article was about the time and storage space it takes to make these 
kind of duplications of hard discs)

If you encrypted you computer right(tm) they woun't be able to break it, 
but the "self destruct" won't work either.




Bis denn

-- 
Real Programmers consider "what you see is what you get" to be just as
bad a concept in Text Editors as it is in women. No, the Real Programmer
wants a "you asked for it, you got it" text editor -- complicated,
cryptic, powerful, unforgiving, dangerous.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060527184055</emailId><senderName>"Kim C"</senderName><senderEmail>kimc@operamail.com</senderEmail><timestampReceived>2006-05-27 18:40:55-0400</timestampReceived><subject>Getting real slow performance</subject><body>

Hi

I have been using aes loop for quite some time now, and it has been working fine \
until now. Today I seem to get much degraded performance on certain files. I am not \
sure what is causing this (or if it is even aes loop that causing it), so any \
pointers of what to do to further invistigate would be nice.

/dev/loop3: [0301]:516734 (/dev/hda2) encryption=AES128 multi-key-v2

The file are 200mb in size, and not cached.
&gt; time cat filea &gt;/dev/null
real    2m25.955s
user    0m0.056s
sys     0m1.135s

== result from iostat -x 10 ==
avg-cpu:  %user   %nice    %sys %iowait   %idle
           1.60    0.00    0.70    0.60   97.10

Device:    rrqm/s wrqm/s   r/s   w/s  rsec/s  wsec/s    rkB/s    wkB/s avgrq-sz \
avgqu-sz   await  svctm  %util   (IDLE) hda          3.10   1.10  0.10  1.50   25.60  \
20.80    12.80    10.40    29.00     0.05   29.12   8.69   1.39

avg-cpu:  %user   %nice    %sys %iowait   %idle
           1.90    0.00    8.61   72.37   17.12

Device:    rrqm/s wrqm/s   r/s   w/s  rsec/s  wsec/s    rkB/s    wkB/s avgrq-sz \
avgqu-sz   await  svctm  %util   (START READ) hda        155.06   1.90 72.47  0.60 \
1821.82   20.02   910.91    10.01    25.21    13.37  182.63  10.39  75.94

avg-cpu:  %user   %nice    %sys %iowait   %idle
           2.00    0.00   33.63   64.37    0.00

Device:    rrqm/s wrqm/s   r/s   w/s  rsec/s  wsec/s    rkB/s    wkB/s avgrq-sz \
avgqu-sz   await  svctm  %util hda        947.31   0.80 23.15  0.90 7762.08   13.57  \
3881.04     6.79   323.29     1.14   48.71  29.46  70.86

avg-cpu:  %user   %nice    %sys %iowait   %idle
           2.10    0.00   22.38   75.52    0.00

Device:    rrqm/s wrqm/s   r/s   w/s  rsec/s  wsec/s    rkB/s    wkB/s avgrq-sz \
avgqu-sz   await  svctm  %util hda        603.60   4.00 36.86  1.50 5190.01   44.76  \
2595.00    22.38   136.46    35.00  198.02  22.10  84.78

Device:    rrqm/s wrqm/s   r/s   w/s  rsec/s  wsec/s    rkB/s    wkB/s avgrq-sz \
avgqu-sz   await  svctm  %util hda          2.40   1.00  6.11  1.30   60.06   29.63   \
30.03    14.81    12.11    52.72 6087.69 135.16 100.12

avg-cpu:  %user   %nice    %sys %iowait   %idle
           1.60    0.00    0.90   97.50    0.00

Device:    rrqm/s wrqm/s   r/s   w/s  rsec/s  wsec/s    rkB/s    wkB/s avgrq-sz \
avgqu-sz   await  svctm  %util hda          0.00   0.20  3.30  2.10   27.20    6.40   \
13.60     3.20     6.22    50.25 9371.72 185.22 100.02

avg-cpu:  %user   %nice    %sys %iowait   %idle
           1.20    0.00    0.60   98.20    0.00

Device:    rrqm/s wrqm/s   r/s   w/s  rsec/s  wsec/s    rkB/s    wkB/s avgrq-sz \
avgqu-sz   await  svctm  %util hda          1.10   0.70  4.70  0.80   56.00   12.00   \
28.00     6.00    12.36    41.14 10463.84 181.85 100.02

&lt;snip&gt;

After some time it ends up working like in the start. This seems to happen on \
fragmented files
&gt; filefrag filea
1483 extents found, perfection would be 2 extents

Same thing on another file also 200mb in size. 
time cat fileb &gt;/dev/null
real    1m3.854s
user    0m0.057s
sys     0m1.151s

&gt; filefrag fileb
6 extents found, perfection would be 2 extents

iostat result are like the first one of filea all the way through. With no huge \
utilization or queue size growth. I normal have an around 4mb/s throughput.

Hardware:
PII 450 MHz
96mb ram
linux 2.6.12
aes loop (cant find installed version number)

Sorry if this mail just shows the obvious and expected behaviour. But my mind cant \
find a  good explanation for these slowdowns. Are there any ways to examine the \
queues to see what is taking so long?

best regards
Kim

-- 
_______________________________________________
Surf the Web in a faster, safer and easier way:
Download Opera 8 at http://www.opera.com

Powered by Outblaze

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060530044223</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-05-30 04:42:23-0400</timestampReceived><subject>[CRYPTO] tcrypt: return -EAGAIN from module_init()</subject><body>

Hi Herbert,

while we're on tcrypt ... I use this patch to prevent successful loading
of tcrypt. It does all its work, then returns -EAGAIN and is removed
from the kernel. It saves me one "rmmod tcrypt" that I otherwise keep
forgetting to issue ;-)

I found it convenient. Take it or drop it.

Michal




["tcrypt-EAGAIN.diff" (text/x-patch)]

Intentionaly return -EAGAIN from module_init() to ensure 
it doesn't stay loaded in the kernel. The module does all
its work from init() and doesn't offer any runtime
functionality =&gt; we don't need it in the memory, do we?

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux/crypto/tcrypt.c
===================================================================
--- linux.orig/crypto/tcrypt.c
+++ linux/crypto/tcrypt.c
@@ -1113,7 +1113,14 @@ static int __init init(void)
 
 	kfree(xbuf);
 	kfree(tvmem);
-	return 0;
+
+	/* We intentionaly return -EAGAIN to prevent keeping
+	 * the module. It does all its work from init()
+	 * and doesn't offer any runtime functionality 
+	 * =&gt; we don't need it in the memory, do we?
+	 *                                        -- mludvig
+	 */
+	return -EAGAIN;
 }
 
 /*

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060524212720</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-05-24 21:27:20-0400</timestampReceived><subject>[CRYPTO] tcrypt: Call tests by algorithm names instead of arbitrary</subject><body>

Hi Herbert,

the attached patch makes the use of tcrypt.ko more convenient. Tests can
now be called with algorithm name as a parameter. That frees us from
reading the source and looking for the correct constant every time one
wants to use the module.

It's not a rocket science. It does, however, introduce backward
incompatibility. But I don't think that would be a problem - it's a
module only for testing anyway.

Michal
-- 
* Personal homepage: http://www.logix.cz/michal




["tcrypt-by-name.diff" (text/x-patch)]

The interface to tcrypt.ko was until now driven by magic code 
numbers with no apparent meaning. This patch enables invocation 
of different tests and benchmarks by algorithm name instead of
by those meaningles numbers. A special algorithm name "all" is 
here to invoke all tests in a given category. Currently we support
four test categories (basic tests, hmac tests, speed tests and 
availability tests). See "modinfo tcrypt" for details on how to 
select the desired category.

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux/crypto/tcrypt.c
===================================================================
--- linux.orig/crypto/tcrypt.c
+++ linux/crypto/tcrypt.c
@@ -64,15 +64,45 @@ static unsigned int IDX[8] = { IDX1, IDX
  */
 static unsigned int sec;
 
-static int mode;
+static char *name_test, *name_hmac, *name_speed, *name_available;
+static int   mode_test,  mode_hmac,  mode_speed,  mode_available;
 static char *xbuf;
 static char *tvmem;
 
-static char *check[] = {
-	"des", "md5", "des3_ede", "rot13", "sha1", "sha256", "blowfish",
-	"twofish", "serpent", "sha384", "sha512", "md4", "aes", "cast6",
-	"arc4", "michael_mic", "deflate", "crc32c", "tea", "xtea",
-	"khazad", "wp512", "wp384", "wp256", "tnepres", "xeta", NULL
+static struct name_id_map map[] = {
+	{ .name = "all",	.id = ALG_ALL },
+	{ .name = "des",	.id = ALG_DES },
+	{ .name = "md5",	.id = ALG_MD5 },
+	{ .name = "des3_ede",	.id = ALG_DES3_EDE },
+	{ .name = "rot13",	.id = ALG_ROT13 },
+	{ .name = "sha1",	.id = ALG_SHA1 },
+	{ .name = "sha256",	.id = ALG_SHA256 },
+	{ .name = "blowfish",	.id = ALG_BLOWFISH },
+	{ .name = "twofish",	.id = ALG_TWOFISH },
+	{ .name = "serpent",	.id = ALG_SERPENT },
+	{ .name = "sha384",	.id = ALG_SHA384 },
+	{ .name = "sha512",	.id = ALG_SHA512 },
+	{ .name = "md4",	.id = ALG_MD4 },
+	{ .name = "aes",	.id = ALG_AES },
+	{ .name = "cast5",	.id = ALG_CAST5 },
+	{ .name = "cast6",	.id = ALG_CAST6 },
+	{ .name = "arc4",	.id = ALG_ARC4 },
+	{ .name = "michael_mic",.id = ALG_MICHAEL_MIC },
+	{ .name = "deflate",	.id = ALG_DEFLATE },
+	{ .name = "crc32c",	.id = ALG_CRC32C },
+	{ .name = "tea",	.id = ALG_TEA },
+	{ .name = "xtea",	.id = ALG_XTEA },
+	{ .name = "khazad",	.id = ALG_KHAZAD },
+	{ .name = "wp512",	.id = ALG_WP512 },
+	{ .name = "wp384",	.id = ALG_WP384 },
+	{ .name = "wp256",	.id = ALG_WP256 },
+	{ .name = "tnepres",	.id = ALG_TNEPRES },
+	{ .name = "xeta",	.id = ALG_XETA },
+	{ .name = "anubis",	.id = ALG_ANUBIS },
+	{ .name = "tgr192",	.id = ALG_TGR192 },
+	{ .name = "tgr160",	.id = ALG_TGR160 },
+	{ .name = "tgr128",	.id = ALG_TGR128 },
+	{ .name = NULL,		.id = 0 }
 };
 
 static void hexdump(unsigned char *buf, unsigned int len)
@@ -83,6 +113,36 @@ static void hexdump(unsigned char *buf, 
 	printk("\n");
 }
 
+static enum alg_ids name_to_id(const char *name)
+{
+	struct name_id_map *algo = map;
+
+	if (!name)
+		return ALG_NONE;
+
+	while (algo-&gt;name) {
+		if (strcmp(algo-&gt;name, name) == 0)
+			return algo-&gt;id;
+		algo++;
+	}
+
+	printk("Unknown algorithm '%s'.\n", name);
+	return ALG_NONE;
+}
+
+#if 0 /* not used */
+static const char *id_to_name(enum alg_ids id)
+{
+	struct name_id_map *algo = map;
+	while (algo-&gt;name) {
+		if (algo-&gt;id == id)
+			return algo-&gt;name;
+		algo++;
+	}
+	return NULL;
+}
+#endif
+
 static void test_hash(char *algo, struct hash_testvec *template,
 		      unsigned int tcount)
 {
@@ -749,281 +809,204 @@ static void test_crc32c(void)
 
 static void test_available(void)
 {
-	char **name = check;
-
-	while (*name) {
-		printk("alg %s ", *name);
-		printk((crypto_alg_available(*name, 0)) ?
-			"found\n" : "not found\n");
-		name++;
+	struct name_id_map *algo = map;
+	while (algo-&gt;name) {
+		if ((mode_available == ALG_ALL) || (mode_available == algo-&gt;id)) {
+			printk("alg %s ", algo-&gt;name);
+			printk((crypto_alg_available(algo-&gt;name, 0)) ?
+				"found\n" : "not found\n");
+		}
+		algo++;
 	}
 }
 
 static void do_test(void)
 {
-	switch (mode) {
-
-	case 0:
-		test_hash("md5", md5_tv_template, MD5_TEST_VECTORS);
-
-		test_hash("sha1", sha1_tv_template, SHA1_TEST_VECTORS);
-
-		//DES
-		test_cipher ("des", MODE_ECB, ENCRYPT, des_enc_tv_template, DES_ENC_TEST_VECTORS);
-		test_cipher ("des", MODE_ECB, DECRYPT, des_dec_tv_template, DES_DEC_TEST_VECTORS);
-		test_cipher ("des", MODE_CBC, ENCRYPT, des_cbc_enc_tv_template, DES_CBC_ENC_TEST_VECTORS);
-		test_cipher ("des", MODE_CBC, DECRYPT, des_cbc_dec_tv_template, DES_CBC_DEC_TEST_VECTORS);
-
-		//DES3_EDE
-		test_cipher ("des3_ede", MODE_ECB, ENCRYPT, des3_ede_enc_tv_template, DES3_EDE_ENC_TEST_VECTORS);
-		test_cipher ("des3_ede", MODE_ECB, DECRYPT, des3_ede_dec_tv_template, DES3_EDE_DEC_TEST_VECTORS);
-
-		test_hash("md4", md4_tv_template, MD4_TEST_VECTORS);
-
-		test_hash("sha256", sha256_tv_template, SHA256_TEST_VECTORS);
-
-		//BLOWFISH
-		test_cipher ("blowfish", MODE_ECB, ENCRYPT, bf_enc_tv_template, BF_ENC_TEST_VECTORS);
-		test_cipher ("blowfish", MODE_ECB, DECRYPT, bf_dec_tv_template, BF_DEC_TEST_VECTORS);
-		test_cipher ("blowfish", MODE_CBC, ENCRYPT, bf_cbc_enc_tv_template, BF_CBC_ENC_TEST_VECTORS);
-		test_cipher ("blowfish", MODE_CBC, DECRYPT, bf_cbc_dec_tv_template, BF_CBC_DEC_TEST_VECTORS);
-
-		//TWOFISH
-		test_cipher ("twofish", MODE_ECB, ENCRYPT, tf_enc_tv_template, TF_ENC_TEST_VECTORS);
-		test_cipher ("twofish", MODE_ECB, DECRYPT, tf_dec_tv_template, TF_DEC_TEST_VECTORS);
-		test_cipher ("twofish", MODE_CBC, ENCRYPT, tf_cbc_enc_tv_template, TF_CBC_ENC_TEST_VECTORS);
-		test_cipher ("twofish", MODE_CBC, DECRYPT, tf_cbc_dec_tv_template, TF_CBC_DEC_TEST_VECTORS);
-
-		//SERPENT
-		test_cipher ("serpent", MODE_ECB, ENCRYPT, serpent_enc_tv_template, SERPENT_ENC_TEST_VECTORS);
-		test_cipher ("serpent", MODE_ECB, DECRYPT, serpent_dec_tv_template, SERPENT_DEC_TEST_VECTORS);
-
-		//TNEPRES
-		test_cipher ("tnepres", MODE_ECB, ENCRYPT, tnepres_enc_tv_template, TNEPRES_ENC_TEST_VECTORS);
-		test_cipher ("tnepres", MODE_ECB, DECRYPT, tnepres_dec_tv_template, TNEPRES_DEC_TEST_VECTORS);
-
-		//AES
-		test_cipher ("aes", MODE_ECB, ENCRYPT, aes_enc_tv_template, AES_ENC_TEST_VECTORS);
-		test_cipher ("aes", MODE_ECB, DECRYPT, aes_dec_tv_template, AES_DEC_TEST_VECTORS);
-		test_cipher ("aes", MODE_CBC, ENCRYPT, aes_cbc_enc_tv_template, AES_CBC_ENC_TEST_VECTORS);
-		test_cipher ("aes", MODE_CBC, DECRYPT, aes_cbc_dec_tv_template, AES_CBC_DEC_TEST_VECTORS);
-
-		//CAST5
-		test_cipher ("cast5", MODE_ECB, ENCRYPT, cast5_enc_tv_template, CAST5_ENC_TEST_VECTORS);
-		test_cipher ("cast5", MODE_ECB, DECRYPT, cast5_dec_tv_template, CAST5_DEC_TEST_VECTORS);
-
-		//CAST6
-		test_cipher ("cast6", MODE_ECB, ENCRYPT, cast6_enc_tv_template, CAST6_ENC_TEST_VECTORS);
-		test_cipher ("cast6", MODE_ECB, DECRYPT, cast6_dec_tv_template, CAST6_DEC_TEST_VECTORS);
-
-		//ARC4
-		test_cipher ("arc4", MODE_ECB, ENCRYPT, arc4_enc_tv_template, ARC4_ENC_TEST_VECTORS);
-		test_cipher ("arc4", MODE_ECB, DECRYPT, arc4_dec_tv_template, ARC4_DEC_TEST_VECTORS);
-
-		//TEA
-		test_cipher ("tea", MODE_ECB, ENCRYPT, tea_enc_tv_template, TEA_ENC_TEST_VECTORS);
-		test_cipher ("tea", MODE_ECB, DECRYPT, tea_dec_tv_template, TEA_DEC_TEST_VECTORS);
-
-
-		//XTEA
-		test_cipher ("xtea", MODE_ECB, ENCRYPT, xtea_enc_tv_template, XTEA_ENC_TEST_VECTORS);
-		test_cipher ("xtea", MODE_ECB, DECRYPT, xtea_dec_tv_template, XTEA_DEC_TEST_VECTORS);
-
-		//KHAZAD
-		test_cipher ("khazad", MODE_ECB, ENCRYPT, khazad_enc_tv_template, KHAZAD_ENC_TEST_VECTORS);
-		test_cipher ("khazad", MODE_ECB, DECRYPT, khazad_dec_tv_template, KHAZAD_DEC_TEST_VECTORS);
-
-		//ANUBIS
-		test_cipher ("anubis", MODE_ECB, ENCRYPT, anubis_enc_tv_template, ANUBIS_ENC_TEST_VECTORS);
-		test_cipher ("anubis", MODE_ECB, DECRYPT, anubis_dec_tv_template, ANUBIS_DEC_TEST_VECTORS);
-		test_cipher ("anubis", MODE_CBC, ENCRYPT, anubis_cbc_enc_tv_template, ANUBIS_CBC_ENC_TEST_VECTORS);
-		test_cipher ("anubis", MODE_CBC, DECRYPT, anubis_cbc_dec_tv_template, ANUBIS_CBC_ENC_TEST_VECTORS);
-
-		//XETA
-		test_cipher ("xeta", MODE_ECB, ENCRYPT, xeta_enc_tv_template, XETA_ENC_TEST_VECTORS);
-		test_cipher ("xeta", MODE_ECB, DECRYPT, xeta_dec_tv_template, XETA_DEC_TEST_VECTORS);
-
-		test_hash("sha384", sha384_tv_template, SHA384_TEST_VECTORS);
-		test_hash("sha512", sha512_tv_template, SHA512_TEST_VECTORS);
-		test_hash("wp512", wp512_tv_template, WP512_TEST_VECTORS);
-		test_hash("wp384", wp384_tv_template, WP384_TEST_VECTORS);
-		test_hash("wp256", wp256_tv_template, WP256_TEST_VECTORS);
-		test_hash("tgr192", tgr192_tv_template, TGR192_TEST_VECTORS);
-		test_hash("tgr160", tgr160_tv_template, TGR160_TEST_VECTORS);
-		test_hash("tgr128", tgr128_tv_template, TGR128_TEST_VECTORS);
-		test_deflate();
-		test_crc32c();
-#ifdef CONFIG_CRYPTO_HMAC
-		test_hmac("md5", hmac_md5_tv_template, HMAC_MD5_TEST_VECTORS);
-		test_hmac("sha1", hmac_sha1_tv_template, HMAC_SHA1_TEST_VECTORS);
-		test_hmac("sha256", hmac_sha256_tv_template, HMAC_SHA256_TEST_VECTORS);
-#endif
+	if (mode_test &gt; ALG_NONE)
+	switch (mode_test) {
 
-		test_hash("michael_mic", michael_mic_tv_template, MICHAEL_MIC_TEST_VECTORS);
-		break;
+	case ALG_ALL:
 
-	case 1:
+	case ALG_MD5:
 		test_hash("md5", md5_tv_template, MD5_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 2:
+	case ALG_SHA1:
 		test_hash("sha1", sha1_tv_template, SHA1_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 3:
+	case ALG_DES:
 		test_cipher ("des", MODE_ECB, ENCRYPT, des_enc_tv_template, DES_ENC_TEST_VECTORS);
 		test_cipher ("des", MODE_ECB, DECRYPT, des_dec_tv_template, DES_DEC_TEST_VECTORS);
 		test_cipher ("des", MODE_CBC, ENCRYPT, des_cbc_enc_tv_template, DES_CBC_ENC_TEST_VECTORS);
 		test_cipher ("des", MODE_CBC, DECRYPT, des_cbc_dec_tv_template, DES_CBC_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 4:
+	case ALG_DES3_EDE:
 		test_cipher ("des3_ede", MODE_ECB, ENCRYPT, des3_ede_enc_tv_template, DES3_EDE_ENC_TEST_VECTORS);
 		test_cipher ("des3_ede", MODE_ECB, DECRYPT, des3_ede_dec_tv_template, DES3_EDE_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 5:
+	case ALG_MD4:
 		test_hash("md4", md4_tv_template, MD4_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 6:
+	case ALG_SHA256:
 		test_hash("sha256", sha256_tv_template, SHA256_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 7:
+	case ALG_BLOWFISH:
 		test_cipher ("blowfish", MODE_ECB, ENCRYPT, bf_enc_tv_template, BF_ENC_TEST_VECTORS);
 		test_cipher ("blowfish", MODE_ECB, DECRYPT, bf_dec_tv_template, BF_DEC_TEST_VECTORS);
 		test_cipher ("blowfish", MODE_CBC, ENCRYPT, bf_cbc_enc_tv_template, BF_CBC_ENC_TEST_VECTORS);
 		test_cipher ("blowfish", MODE_CBC, DECRYPT, bf_cbc_dec_tv_template, BF_CBC_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 8:
+	case ALG_TWOFISH:
 		test_cipher ("twofish", MODE_ECB, ENCRYPT, tf_enc_tv_template, TF_ENC_TEST_VECTORS);
 		test_cipher ("twofish", MODE_ECB, DECRYPT, tf_dec_tv_template, TF_DEC_TEST_VECTORS);
 		test_cipher ("twofish", MODE_CBC, ENCRYPT, tf_cbc_enc_tv_template, TF_CBC_ENC_TEST_VECTORS);
 		test_cipher ("twofish", MODE_CBC, DECRYPT, tf_cbc_dec_tv_template, TF_CBC_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 9:
+	case ALG_SERPENT:
 		test_cipher ("serpent", MODE_ECB, ENCRYPT, serpent_enc_tv_template, SERPENT_ENC_TEST_VECTORS);
 		test_cipher ("serpent", MODE_ECB, DECRYPT, serpent_dec_tv_template, SERPENT_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 10:
+	case ALG_AES:
 		test_cipher ("aes", MODE_ECB, ENCRYPT, aes_enc_tv_template, AES_ENC_TEST_VECTORS);
 		test_cipher ("aes", MODE_ECB, DECRYPT, aes_dec_tv_template, AES_DEC_TEST_VECTORS);
 		test_cipher ("aes", MODE_CBC, ENCRYPT, aes_cbc_enc_tv_template, AES_CBC_ENC_TEST_VECTORS);
 		test_cipher ("aes", MODE_CBC, DECRYPT, aes_cbc_dec_tv_template, AES_CBC_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 11:
+	case ALG_SHA384:
 		test_hash("sha384", sha384_tv_template, SHA384_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 12:
+	case ALG_SHA512:
 		test_hash("sha512", sha512_tv_template, SHA512_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 13:
+	case ALG_DEFLATE:
 		test_deflate();
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 14:
+	case ALG_CAST5:
 		test_cipher ("cast5", MODE_ECB, ENCRYPT, cast5_enc_tv_template, CAST5_ENC_TEST_VECTORS);
 		test_cipher ("cast5", MODE_ECB, DECRYPT, cast5_dec_tv_template, CAST5_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 15:
+	case ALG_CAST6:
 		test_cipher ("cast6", MODE_ECB, ENCRYPT, cast6_enc_tv_template, CAST6_ENC_TEST_VECTORS);
 		test_cipher ("cast6", MODE_ECB, DECRYPT, cast6_dec_tv_template, CAST6_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 16:
+	case ALG_ARC4:
 		test_cipher ("arc4", MODE_ECB, ENCRYPT, arc4_enc_tv_template, ARC4_ENC_TEST_VECTORS);
 		test_cipher ("arc4", MODE_ECB, DECRYPT, arc4_dec_tv_template, ARC4_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 17:
+	case ALG_MICHAEL_MIC:
 		test_hash("michael_mic", michael_mic_tv_template, MICHAEL_MIC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 18:
+	case ALG_CRC32C:
 		test_crc32c();
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 19:
+	case ALG_TEA:
 		test_cipher ("tea", MODE_ECB, ENCRYPT, tea_enc_tv_template, TEA_ENC_TEST_VECTORS);
 		test_cipher ("tea", MODE_ECB, DECRYPT, tea_dec_tv_template, TEA_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 20:
+	case ALG_XTEA:
 		test_cipher ("xtea", MODE_ECB, ENCRYPT, xtea_enc_tv_template, XTEA_ENC_TEST_VECTORS);
 		test_cipher ("xtea", MODE_ECB, DECRYPT, xtea_dec_tv_template, XTEA_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 21:
+	case ALG_KHAZAD:
 		test_cipher ("khazad", MODE_ECB, ENCRYPT, khazad_enc_tv_template, KHAZAD_ENC_TEST_VECTORS);
 		test_cipher ("khazad", MODE_ECB, DECRYPT, khazad_dec_tv_template, KHAZAD_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 22:
+	case ALG_WP512:
 		test_hash("wp512", wp512_tv_template, WP512_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 23:
+	case ALG_WP384:
 		test_hash("wp384", wp384_tv_template, WP384_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 24:
+	case ALG_WP256:
 		test_hash("wp256", wp256_tv_template, WP256_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 25:
+	case ALG_TNEPRES:
 		test_cipher ("tnepres", MODE_ECB, ENCRYPT, tnepres_enc_tv_template, TNEPRES_ENC_TEST_VECTORS);
 		test_cipher ("tnepres", MODE_ECB, DECRYPT, tnepres_dec_tv_template, TNEPRES_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 26:
+	case ALG_ANUBIS:
 		test_cipher ("anubis", MODE_ECB, ENCRYPT, anubis_enc_tv_template, ANUBIS_ENC_TEST_VECTORS);
 		test_cipher ("anubis", MODE_ECB, DECRYPT, anubis_dec_tv_template, ANUBIS_DEC_TEST_VECTORS);
 		test_cipher ("anubis", MODE_CBC, ENCRYPT, anubis_cbc_enc_tv_template, ANUBIS_CBC_ENC_TEST_VECTORS);
 		test_cipher ("anubis", MODE_CBC, DECRYPT, anubis_cbc_dec_tv_template, ANUBIS_CBC_ENC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 27:
+	case ALG_TGR192:
 		test_hash("tgr192", tgr192_tv_template, TGR192_TEST_VECTORS);
-		break;
-
-	case 28:
+		if (mode_test != ALG_ALL) break;
 
+	case ALG_TGR160:
 		test_hash("tgr160", tgr160_tv_template, TGR160_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 29:
+	case ALG_TGR128:
 		test_hash("tgr128", tgr128_tv_template, TGR128_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 		
-	case 30:
+	case ALG_XETA:
 		test_cipher ("xeta", MODE_ECB, ENCRYPT, xeta_enc_tv_template, XETA_ENC_TEST_VECTORS);
 		test_cipher ("xeta", MODE_ECB, DECRYPT, xeta_dec_tv_template, XETA_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
+	default:
+		if (mode_test != ALG_ALL)
+			printk("Basic test for '%s' not implemented.\n", name_test);
+		break;
+	}
+	
 #ifdef CONFIG_CRYPTO_HMAC
-	case 100:
+	if (mode_hmac &gt; ALG_NONE)
+	switch (mode_hmac) {
+	case ALG_ALL:
+
+	case ALG_MD5:
 		test_hmac("md5", hmac_md5_tv_template, HMAC_MD5_TEST_VECTORS);
-		break;
+		if (mode_hmac != ALG_ALL) break;
 
-	case 101:
+	case ALG_SHA1:
 		test_hmac("sha1", hmac_sha1_tv_template, HMAC_SHA1_TEST_VECTORS);
-		break;
+		if (mode_hmac != ALG_ALL) break;
 
-	case 102:
+	case ALG_SHA256:
 		test_hmac("sha256", hmac_sha256_tv_template, HMAC_SHA256_TEST_VECTORS);
+		if (mode_hmac != ALG_ALL) break;
+		
+	default:
+		if (mode_hmac != ALG_ALL)
+			printk("HMAC test for '%s' not implemnted.\n", name_hmac);
 		break;
-
+	}
 #endif
 
-	case 200:
+	if (mode_speed &gt; ALG_NONE)
+	switch (mode_speed) {
+	case ALG_ALL:
+
+	case ALG_AES:
 		test_cipher_speed("aes", MODE_ECB, ENCRYPT, sec, NULL, 0,
 				  aes_speed_template);
 		test_cipher_speed("aes", MODE_ECB, DECRYPT, sec, NULL, 0,
@@ -1032,9 +1015,9 @@ static void do_test(void)
 				  aes_speed_template);
 		test_cipher_speed("aes", MODE_CBC, DECRYPT, sec, NULL, 0,
 				  aes_speed_template);
-		break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 201:
+	case ALG_DES3_EDE:
 		test_cipher_speed("des3_ede", MODE_ECB, ENCRYPT, sec,
 				  des3_ede_enc_tv_template,
 				  DES3_EDE_ENC_TEST_VECTORS,
@@ -1051,9 +1034,9 @@ static void do_test(void)
 				  des3_ede_dec_tv_template,
 				  DES3_EDE_DEC_TEST_VECTORS,
 				  des3_ede_speed_template);
-		break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 202:
+	case ALG_TWOFISH:
 		test_cipher_speed("twofish", MODE_ECB, ENCRYPT, sec, NULL, 0,
 				  twofish_speed_template);
 		test_cipher_speed("twofish", MODE_ECB, DECRYPT, sec, NULL, 0,
@@ -1062,9 +1045,9 @@ static void do_test(void)
 				  twofish_speed_template);
 		test_cipher_speed("twofish", MODE_CBC, DECRYPT, sec, NULL, 0,
 				  twofish_speed_template);
-		break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 203:
+	case ALG_BLOWFISH:
 		test_cipher_speed("blowfish", MODE_ECB, ENCRYPT, sec, NULL, 0,
 				  blowfish_speed_template);
 		test_cipher_speed("blowfish", MODE_ECB, DECRYPT, sec, NULL, 0,
@@ -1073,9 +1056,9 @@ static void do_test(void)
 				  blowfish_speed_template);
 		test_cipher_speed("blowfish", MODE_CBC, DECRYPT, sec, NULL, 0,
 				  blowfish_speed_template);
-		break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 204:
+	case ALG_DES:
 		test_cipher_speed("des", MODE_ECB, ENCRYPT, sec, NULL, 0,
 				  des_speed_template);
 		test_cipher_speed("des", MODE_ECB, DECRYPT, sec, NULL, 0,
@@ -1084,17 +1067,20 @@ static void do_test(void)
 				  des_speed_template);
 		test_cipher_speed("des", MODE_CBC, DECRYPT, sec, NULL, 0,
 				  des_speed_template);
+		if (mode_speed != ALG_ALL) break;
+
+	default:
+		if (mode_speed != ALG_ALL)
+			printk("Speed test for '%s' not implemented.\n", name_speed);
 		break;
+	}
 
-	case 1000:
+	if (mode_available)
 		test_available();
-		break;
 
-	default:
+	if (mode_test + mode_hmac + mode_speed + mode_available == 0)
 		/* useful for debugging */
 		printk("not testing anything\n");
-		break;
-	}
 }
 
 static int __init init(void)
@@ -1109,6 +1095,11 @@ static int __init init(void)
 		return -ENOMEM;
 	}
 
+	mode_test = name_to_id (name_test);
+	mode_hmac = name_to_id (name_hmac);
+	mode_speed = name_to_id (name_speed);
+	mode_available = name_to_id (name_available);
+
 	do_test();
 
 	kfree(xbuf);
@@ -1125,7 +1116,18 @@ static void __exit fini(void) { }
 module_init(init);
 module_exit(fini);
 
-module_param(mode, int, 0);
+module_param(name_test, charp, 0);
+MODULE_PARM_DESC(name_test, "Algorithm name for basic test mode, or 'all'.");
+
+module_param(name_hmac, charp, 0);
+MODULE_PARM_DESC(name_hmac, "Algorithm name for HMAC test mode, or 'all'.");
+
+module_param(name_speed, charp, 0);
+MODULE_PARM_DESC(name_speed, "Algorithm name for speed test mode, or 'all'.");
+
+module_param(name_available, charp, 0);
+MODULE_PARM_DESC(name_available, "Algorithm name to check for availability, or 'all'.");
+
 module_param(sec, uint, 0);
 MODULE_PARM_DESC(sec, "Length in seconds of speed tests "
 		      "(defaults to zero which uses CPU cycles instead)");
Index: linux/crypto/tcrypt.h
===================================================================
--- linux.orig/crypto/tcrypt.h
+++ linux/crypto/tcrypt.h
@@ -25,6 +25,47 @@
 #define MAX_KEYLEN		56
 #define MAX_IVLEN		32
 
+enum alg_ids {
+	ALG_NONE = 0,
+	ALG_ALL = 1,
+	ALG_DES,
+	ALG_MD5,
+	ALG_DES3_EDE,
+	ALG_ROT13,
+	ALG_SHA1,
+	ALG_SHA256,
+	ALG_BLOWFISH,
+	ALG_TWOFISH,
+	ALG_SERPENT,
+	ALG_SHA384,
+	ALG_SHA512,
+	ALG_MD4,
+	ALG_AES,
+	ALG_CAST5,
+	ALG_CAST6,
+	ALG_ARC4,
+	ALG_MICHAEL_MIC,
+	ALG_DEFLATE,
+	ALG_CRC32C,
+	ALG_TEA,
+	ALG_XTEA,
+	ALG_KHAZAD,
+	ALG_WP512,
+	ALG_WP384,
+	ALG_WP256,
+	ALG_TNEPRES,
+	ALG_XETA,
+	ALG_ANUBIS,
+	ALG_TGR192,
+	ALG_TGR160,
+	ALG_TGR128,
+};
+
+struct name_id_map {
+	const char *name;
+	enum alg_ids id;
+};
+
 struct hash_testvec {
 	/* only used with keyed hash algorithms */
 	char key[128] __attribute__ ((__aligned__(4)));

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060530054807</emailId><senderName>rodger ellis</senderName><senderEmail>rellis@gmx.net</senderEmail><timestampReceived>2006-05-30 05:48:07-0400</timestampReceived><subject>folowed this howto to encrypt home</subject><body>

Hello

I follwd this howto to encrypt home but how to encrypt other partitions
such as root and swap? as I do not think my computer will boot.

HOWTO
http://deb.riseup.net/storage/encryption/loop-aes/#prepare_the_system




rodger

 


-- 


Bis zu 70% Ihrer Onlinekosten sparen: GMX SmartSurfer!
      Kostenlos downloaden: http://www.gmx.net/de/go/smartsurfer
    

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060529072958</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-29 07:29:58-0400</timestampReceived><subject>Re: [CRYPTO] tcrypt: Call tests by algorithm names instead of arbitrary numbers</subject><body>

Hi Michal:

On Thu, May 25, 2006 at 09:27:20AM +1200, Michal Ludvig wrote:
&gt; 
&gt; It's not a rocket science. It does, however, introduce backward
&gt; incompatibility. But I don't think that would be a problem - it's a
&gt; module only for testing anyway.

I like the concept.  But I think you should be more audacious :)

How about making tcrypt modularised? What I'd like to see is a model
where each crypto algorithm can provide its own test vectors that
produces its own module.  For instance, to test AES I'd do something
like 'modprobe aes-tcrypt &lt;params&gt;'.

This way we will no longer have the ever growing tcrypt.[ch] that are
starting to look scary.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060529093735</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-05-29 09:37:35-0400</timestampReceived><subject>Re: [CRYPTO] tcrypt: Call tests by algorithm names instead of arbitrary</subject><body>

Herbert Xu wrote:
&gt; Hi Michal:
&gt; 
&gt; On Thu, May 25, 2006 at 09:27:20AM +1200, Michal Ludvig wrote:
&gt;&gt; It's not a rocket science. It does, however, introduce backward
&gt;&gt; incompatibility. But I don't think that would be a problem - it's a
&gt;&gt; module only for testing anyway.
&gt; 
&gt; I like the concept.  But I think you should be more audacious :)
&gt; 
&gt; How about making tcrypt modularised? What I'd like to see is a model
&gt; where each crypto algorithm can provide its own test vectors that
&gt; produces its own module.  For instance, to test AES I'd do something
&gt; like 'modprobe aes-tcrypt &lt;params&gt;'.
&gt; 
&gt; This way we will no longer have the ever growing tcrypt.[ch] that are
&gt; starting to look scary.

This is a testing module only. Who use it? I guess just developers when 
working on crypto stuff - they (we) won't be scaried by the ever growing 
tcrypt.[ch] I guess.

Honestly, I'm not likely to spend two days copy&amp;pasting existing test 
vectors all around linux/crypto just for those five or ten people who 
are likely to insmod tcrypt.ko in next half a year ;-)

Even if you accept my patch as it is you can still modularize it later ;-)

BTW how about the digest-speed thing?

Michal
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060529100743</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-29 10:07:43-0400</timestampReceived><subject>Re: [CRYPTO] tcrypt: Call tests by algorithm names instead of arbitrary numbers</subject><body>

On Mon, May 29, 2006 at 09:37:35PM +1200, Michal Ludvig wrote:
&gt; 
&gt; This is a testing module only. Who use it? I guess just developers when 
&gt; working on crypto stuff - they (we) won't be scaried by the ever growing 
&gt; tcrypt.[ch] I guess.

The question is really who has to maintain it :)
 
&gt; Even if you accept my patch as it is you can still modularize it later ;-)

I think if we're going to do that sort of surgery to tcrypt then we
should go the whole length and modularise it.

&gt; BTW how about the digest-speed thing?

That's fine by me if you can rebase it on the current code set.

Thanks,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060530040942</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-05-30 04:09:42-0400</timestampReceived><subject>Re: [CRYPTO] tcrypt: Call tests by algorithm names instead of arbitrary</subject><body>

Herbert Xu wrote:
&gt; On Mon, May 29, 2006 at 09:37:35PM +1200, Michal Ludvig wrote:
&gt; 
&gt;&gt; BTW how about the digest-speed thing?
&gt; 
&gt; That's fine by me if you can rebase it on the current code set.

Attached.

Michal

["tcrypt-digest-benchmark-before-tcrypt-names.diff" (text/x-patch)]

This patch adds speed tests (benchmarks) for digest algorithms.
Tests are run with different buffer sizes (16 bytes, ... 8 kBytes)
and with each buffer multiple tests are run with different update()
sizes (e.g. hash 64 bytes buffer in four 16 byte updates). 
There is no correctness checking of the result and all tests and 
algorithms use the same input buffer. 

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux/crypto/tcrypt.c
===================================================================
--- linux.orig/crypto/tcrypt.c
+++ linux/crypto/tcrypt.c
@@ -570,6 +570,122 @@ out:
 	crypto_free_tfm(tfm);
 }
 
+static void test_digest_jiffies(struct crypto_tfm *tfm, char *p, int blen,
+				int plen, char *out, int sec)
+{
+	struct scatterlist sg[1];
+	unsigned long start, end;
+	int bcount, pcount;
+
+	for (start = jiffies, end = start + sec * HZ, bcount = 0;
+	     time_before(jiffies, end); bcount++) {
+		crypto_digest_init(tfm);
+		for (pcount = 0; pcount &lt; blen; pcount += plen) {
+			sg_set_buf(sg, p + pcount, plen);
+			crypto_digest_update(tfm, sg, 1);
+		}
+		/* we assume there is enough space in 'out' for the result */
+		crypto_digest_final(tfm, out);
+	}
+
+	printk("%6u opers/sec, %9lu bytes/sec\n",
+	       bcount/sec, ((long)bcount * blen)/sec);
+
+	return;
+}
+
+static void test_digest_cycles(struct crypto_tfm *tfm, char *p, int blen,
+			       int plen, char *out)
+{
+	struct scatterlist sg[1];
+	unsigned long cycles = 0;
+	int i, pcount;
+
+	local_bh_disable();
+	local_irq_disable();
+
+	/* Warm-up run. */
+	for (i = 0; i &lt; 4; i++) {
+		crypto_digest_init(tfm);
+		for (pcount = 0; pcount &lt; blen; pcount += plen) {
+			sg_set_buf(sg, p + pcount, plen);
+			crypto_digest_update(tfm, sg, 1);
+		}
+		crypto_digest_final(tfm, out);
+	}
+
+	/* The real thing. */
+	for (i = 0; i &lt; 8; i++) {
+		cycles_t start, end;
+
+		crypto_digest_init(tfm);
+
+		start = get_cycles();
+
+		for (pcount = 0; pcount &lt; blen; pcount += plen) {
+			sg_set_buf(sg, p + pcount, plen);
+			crypto_digest_update(tfm, sg, 1);
+		}
+		crypto_digest_final(tfm, out);
+
+		end = get_cycles();
+
+		cycles += end - start;
+	}
+
+	local_irq_enable();
+	local_bh_enable();
+
+	printk("%6lu cycles/operation,%4lu cycles/byte\n",
+	       cycles / 8, cycles / (8 * blen));
+
+	return;
+}
+
+static void test_digest_speed(char *algo, unsigned int sec,
+			      struct digest_speed *speed)
+{
+	struct crypto_tfm *tfm;
+	char output[1024];
+	int i;
+
+	printk("\ntesting speed of %s\n", algo);
+
+	tfm = crypto_alloc_tfm(algo, 0);
+
+	if (tfm == NULL) {
+		printk("failed to load transform for %s\n", algo);
+		return;
+	}
+
+	if (crypto_tfm_alg_digestsize(tfm) &gt; sizeof(output)) {
+		printk("digestsize(%u) &gt; outputbuffer(%zu)\n",
+		       crypto_tfm_alg_digestsize(tfm), sizeof(output));
+		goto out;
+	}
+
+	for (i = 0; speed[i].blen != 0; i++) {
+		if (speed[i].blen &gt; TVMEMSIZE) {
+			printk("template (%u) too big for tvmem (%u)\n",
+			       speed[i].blen, TVMEMSIZE);
+			goto out;
+		}
+
+		printk("test%3u (%5u byte blocks,%5u bytes per update,%4u updates): ",
+		       i, speed[i].blen, speed[i].plen, speed[i].blen / speed[i].plen);
+
+		memset(tvmem, 0xff, speed[i].blen);
+
+		if (sec)
+			test_digest_jiffies(tfm, tvmem, speed[i].blen, speed[i].plen, output, sec);
+		else
+			test_digest_cycles(tfm, tvmem, speed[i].blen, speed[i].plen, output);
+	}
+
+out:
+	crypto_free_tfm(tfm);
+}
+
 static void test_deflate(void)
 {
 	unsigned int i;
@@ -1086,6 +1202,60 @@ static void do_test(void)
 				  des_speed_template);
 		break;
 
+	case 300:
+		/* fall through */
+
+	case 301:
+		test_digest_speed("md4", sec, generic_digest_speed_template);
+		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+
+	case 302:
+		test_digest_speed("md5", sec, generic_digest_speed_template);
+		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+
+	case 303:
+		test_digest_speed("sha1", sec, generic_digest_speed_template);
+		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+
+	case 304:
+		test_digest_speed("sha256", sec, generic_digest_speed_template);
+		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+
+	case 305:
+		test_digest_speed("sha384", sec, generic_digest_speed_template);
+		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+
+	case 306:
+		test_digest_speed("sha512", sec, generic_digest_speed_template);
+		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+
+	case 307:
+		test_digest_speed("wp256", sec, generic_digest_speed_template);
+		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+
+	case 308:
+		test_digest_speed("wp384", sec, generic_digest_speed_template);
+		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+
+	case 309:
+		test_digest_speed("wp512", sec, generic_digest_speed_template);
+		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+
+	case 310:
+		test_digest_speed("tgr128", sec, generic_digest_speed_template);
+		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+
+	case 311:
+		test_digest_speed("tgr160", sec, generic_digest_speed_template);
+		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+
+	case 312:
+		test_digest_speed("tgr192", sec, generic_digest_speed_template);
+		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+
+	case 399:
+		break;
+
 	case 1000:
 		test_available();
 		break;
Index: linux/crypto/tcrypt.h
===================================================================
--- linux.orig/crypto/tcrypt.h
+++ linux/crypto/tcrypt.h
@@ -65,6 +65,11 @@ struct cipher_speed {
 	unsigned int blen;
 };
 
+struct digest_speed {
+	unsigned int blen;	/* buffer length */
+	unsigned int plen;	/* per-update length */
+};
+
 /*
  * MD4 test vectors from RFC1320
  */
@@ -2975,4 +2980,35 @@ static struct cipher_speed des_speed_tem
 	{  .klen = 0, .blen = 0, }
 };
 
+/*
+ * Digest speed tests
+ */
+static struct digest_speed generic_digest_speed_template[] = {
+	{ .blen = 16, 	.plen = 16, },
+	{ .blen = 64,	.plen = 16, },
+	{ .blen = 64,	.plen = 64, },
+	{ .blen = 256,	.plen = 16, },
+	{ .blen = 256,	.plen = 64, },
+	{ .blen = 256,	.plen = 256, },
+	{ .blen = 1024,	.plen = 16, },
+	{ .blen = 1024,	.plen = 256, },
+	{ .blen = 1024,	.plen = 1024, },
+	{ .blen = 2048,	.plen = 16, },
+	{ .blen = 2048,	.plen = 256, },
+	{ .blen = 2048,	.plen = 1024, },
+	{ .blen = 2048,	.plen = 2048, },
+	{ .blen = 4096,	.plen = 16, },
+	{ .blen = 4096,	.plen = 256, },
+	{ .blen = 4096,	.plen = 1024, },
+	{ .blen = 4096,	.plen = 4096, },
+	{ .blen = 8192,	.plen = 16, },
+	{ .blen = 8192,	.plen = 256, },
+	{ .blen = 8192,	.plen = 1024, },
+	{ .blen = 8192,	.plen = 4096, },
+	{ .blen = 8192,	.plen = 8192, },
+
+	/* End marker */
+	{  .blen = 0,	.plen = 0, }
+};
+
 #endif	/* _CRYPTO_TCRYPT_H */

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060530120440</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-30 12:04:40-0400</timestampReceived><subject>Re: [CRYPTO] tcrypt: Call tests by algorithm names instead of arbitrary numbers</subject><body>

On Tue, May 30, 2006 at 04:09:42PM +1200, Michal Ludvig wrote:
&gt; 
&gt; Attached.

Patch applied.  Thank you very much Michal.
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060530121159</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-05-30 12:11:59-0400</timestampReceived><subject>Re: [CRYPTO] tcrypt: Call tests by algorithm names instead of arbitrary</subject><body>

Herbert Xu wrote:

&gt; Patch applied.  Thank you very much Michal.

Just in case you'd change your mind about $SUBJ - attached is an updated
version with that applies on top of the digest-speed.
Just in case... ;-))

Michal


["tcrypt-by-name.diff" (text/x-patch)]

The interface to tcrypt.ko was until now driven by magic code 
numbers with no apparent meaning. This patch enables invocation 
of different tests and benchmarks by algorithm name instead of
by those meaningles numbers. A special algorithm name "all" is 
here to invoke all tests in a given category. Currently we support
four test categories (basic tests, hmac tests, speed tests and 
availability tests). See "modinfo tcrypt" for details on how to 
select the desired category.

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux/crypto/tcrypt.c
===================================================================
--- linux.orig/crypto/tcrypt.c
+++ linux/crypto/tcrypt.c
@@ -64,15 +64,45 @@ static unsigned int IDX[8] = { IDX1, IDX
  */
 static unsigned int sec;
 
-static int mode;
+static char *name_test, *name_hmac, *name_speed, *name_available;
+static int   mode_test,  mode_hmac,  mode_speed,  mode_available;
 static char *xbuf;
 static char *tvmem;
 
-static char *check[] = {
-	"des", "md5", "des3_ede", "rot13", "sha1", "sha256", "blowfish",
-	"twofish", "serpent", "sha384", "sha512", "md4", "aes", "cast6",
-	"arc4", "michael_mic", "deflate", "crc32c", "tea", "xtea",
-	"khazad", "wp512", "wp384", "wp256", "tnepres", "xeta", NULL
+static struct name_id_map map[] = {
+	{ .name = "all",	.id = ALG_ALL },
+	{ .name = "des",	.id = ALG_DES },
+	{ .name = "md5",	.id = ALG_MD5 },
+	{ .name = "des3_ede",	.id = ALG_DES3_EDE },
+	{ .name = "rot13",	.id = ALG_ROT13 },
+	{ .name = "sha1",	.id = ALG_SHA1 },
+	{ .name = "sha256",	.id = ALG_SHA256 },
+	{ .name = "blowfish",	.id = ALG_BLOWFISH },
+	{ .name = "twofish",	.id = ALG_TWOFISH },
+	{ .name = "serpent",	.id = ALG_SERPENT },
+	{ .name = "sha384",	.id = ALG_SHA384 },
+	{ .name = "sha512",	.id = ALG_SHA512 },
+	{ .name = "md4",	.id = ALG_MD4 },
+	{ .name = "aes",	.id = ALG_AES },
+	{ .name = "cast5",	.id = ALG_CAST5 },
+	{ .name = "cast6",	.id = ALG_CAST6 },
+	{ .name = "arc4",	.id = ALG_ARC4 },
+	{ .name = "michael_mic",.id = ALG_MICHAEL_MIC },
+	{ .name = "deflate",	.id = ALG_DEFLATE },
+	{ .name = "crc32c",	.id = ALG_CRC32C },
+	{ .name = "tea",	.id = ALG_TEA },
+	{ .name = "xtea",	.id = ALG_XTEA },
+	{ .name = "khazad",	.id = ALG_KHAZAD },
+	{ .name = "wp512",	.id = ALG_WP512 },
+	{ .name = "wp384",	.id = ALG_WP384 },
+	{ .name = "wp256",	.id = ALG_WP256 },
+	{ .name = "tnepres",	.id = ALG_TNEPRES },
+	{ .name = "xeta",	.id = ALG_XETA },
+	{ .name = "anubis",	.id = ALG_ANUBIS },
+	{ .name = "tgr192",	.id = ALG_TGR192 },
+	{ .name = "tgr160",	.id = ALG_TGR160 },
+	{ .name = "tgr128",	.id = ALG_TGR128 },
+	{ .name = NULL,		.id = 0 }
 };
 
 static void hexdump(unsigned char *buf, unsigned int len)
@@ -83,6 +113,36 @@ static void hexdump(unsigned char *buf, 
 	printk("\n");
 }
 
+static enum alg_ids name_to_id(const char *name)
+{
+	struct name_id_map *algo = map;
+
+	if (!name)
+		return ALG_NONE;
+
+	while (algo-&gt;name) {
+		if (strcmp(algo-&gt;name, name) == 0)
+			return algo-&gt;id;
+		algo++;
+	}
+
+	printk("Unknown algorithm '%s'.\n", name);
+	return ALG_NONE;
+}
+
+#if 0 /* not used */
+static const char *id_to_name(enum alg_ids id)
+{
+	struct name_id_map *algo = map;
+	while (algo-&gt;name) {
+		if (algo-&gt;id == id)
+			return algo-&gt;name;
+		algo++;
+	}
+	return NULL;
+}
+#endif
+
 static void test_hash(char *algo, struct hash_testvec *template,
 		      unsigned int tcount)
 {
@@ -865,281 +925,204 @@ static void test_crc32c(void)
 
 static void test_available(void)
 {
-	char **name = check;
-
-	while (*name) {
-		printk("alg %s ", *name);
-		printk((crypto_alg_available(*name, 0)) ?
-			"found\n" : "not found\n");
-		name++;
+	struct name_id_map *algo = map;
+	while (algo-&gt;name) {
+		if ((mode_available == ALG_ALL) || (mode_available == algo-&gt;id)) {
+			printk("alg %s ", algo-&gt;name);
+			printk((crypto_alg_available(algo-&gt;name, 0)) ?
+				"found\n" : "not found\n");
+		}
+		algo++;
 	}
 }
 
 static void do_test(void)
 {
-	switch (mode) {
-
-	case 0:
-		test_hash("md5", md5_tv_template, MD5_TEST_VECTORS);
-
-		test_hash("sha1", sha1_tv_template, SHA1_TEST_VECTORS);
-
-		//DES
-		test_cipher ("des", MODE_ECB, ENCRYPT, des_enc_tv_template, DES_ENC_TEST_VECTORS);
-		test_cipher ("des", MODE_ECB, DECRYPT, des_dec_tv_template, DES_DEC_TEST_VECTORS);
-		test_cipher ("des", MODE_CBC, ENCRYPT, des_cbc_enc_tv_template, DES_CBC_ENC_TEST_VECTORS);
-		test_cipher ("des", MODE_CBC, DECRYPT, des_cbc_dec_tv_template, DES_CBC_DEC_TEST_VECTORS);
-
-		//DES3_EDE
-		test_cipher ("des3_ede", MODE_ECB, ENCRYPT, des3_ede_enc_tv_template, DES3_EDE_ENC_TEST_VECTORS);
-		test_cipher ("des3_ede", MODE_ECB, DECRYPT, des3_ede_dec_tv_template, DES3_EDE_DEC_TEST_VECTORS);
-
-		test_hash("md4", md4_tv_template, MD4_TEST_VECTORS);
-
-		test_hash("sha256", sha256_tv_template, SHA256_TEST_VECTORS);
-
-		//BLOWFISH
-		test_cipher ("blowfish", MODE_ECB, ENCRYPT, bf_enc_tv_template, BF_ENC_TEST_VECTORS);
-		test_cipher ("blowfish", MODE_ECB, DECRYPT, bf_dec_tv_template, BF_DEC_TEST_VECTORS);
-		test_cipher ("blowfish", MODE_CBC, ENCRYPT, bf_cbc_enc_tv_template, BF_CBC_ENC_TEST_VECTORS);
-		test_cipher ("blowfish", MODE_CBC, DECRYPT, bf_cbc_dec_tv_template, BF_CBC_DEC_TEST_VECTORS);
-
-		//TWOFISH
-		test_cipher ("twofish", MODE_ECB, ENCRYPT, tf_enc_tv_template, TF_ENC_TEST_VECTORS);
-		test_cipher ("twofish", MODE_ECB, DECRYPT, tf_dec_tv_template, TF_DEC_TEST_VECTORS);
-		test_cipher ("twofish", MODE_CBC, ENCRYPT, tf_cbc_enc_tv_template, TF_CBC_ENC_TEST_VECTORS);
-		test_cipher ("twofish", MODE_CBC, DECRYPT, tf_cbc_dec_tv_template, TF_CBC_DEC_TEST_VECTORS);
-
-		//SERPENT
-		test_cipher ("serpent", MODE_ECB, ENCRYPT, serpent_enc_tv_template, SERPENT_ENC_TEST_VECTORS);
-		test_cipher ("serpent", MODE_ECB, DECRYPT, serpent_dec_tv_template, SERPENT_DEC_TEST_VECTORS);
-
-		//TNEPRES
-		test_cipher ("tnepres", MODE_ECB, ENCRYPT, tnepres_enc_tv_template, TNEPRES_ENC_TEST_VECTORS);
-		test_cipher ("tnepres", MODE_ECB, DECRYPT, tnepres_dec_tv_template, TNEPRES_DEC_TEST_VECTORS);
-
-		//AES
-		test_cipher ("aes", MODE_ECB, ENCRYPT, aes_enc_tv_template, AES_ENC_TEST_VECTORS);
-		test_cipher ("aes", MODE_ECB, DECRYPT, aes_dec_tv_template, AES_DEC_TEST_VECTORS);
-		test_cipher ("aes", MODE_CBC, ENCRYPT, aes_cbc_enc_tv_template, AES_CBC_ENC_TEST_VECTORS);
-		test_cipher ("aes", MODE_CBC, DECRYPT, aes_cbc_dec_tv_template, AES_CBC_DEC_TEST_VECTORS);
-
-		//CAST5
-		test_cipher ("cast5", MODE_ECB, ENCRYPT, cast5_enc_tv_template, CAST5_ENC_TEST_VECTORS);
-		test_cipher ("cast5", MODE_ECB, DECRYPT, cast5_dec_tv_template, CAST5_DEC_TEST_VECTORS);
+	if (mode_test &gt; ALG_NONE)
+	switch (mode_test) {
 
-		//CAST6
-		test_cipher ("cast6", MODE_ECB, ENCRYPT, cast6_enc_tv_template, CAST6_ENC_TEST_VECTORS);
-		test_cipher ("cast6", MODE_ECB, DECRYPT, cast6_dec_tv_template, CAST6_DEC_TEST_VECTORS);
-
-		//ARC4
-		test_cipher ("arc4", MODE_ECB, ENCRYPT, arc4_enc_tv_template, ARC4_ENC_TEST_VECTORS);
-		test_cipher ("arc4", MODE_ECB, DECRYPT, arc4_dec_tv_template, ARC4_DEC_TEST_VECTORS);
+	case ALG_ALL:
 
-		//TEA
-		test_cipher ("tea", MODE_ECB, ENCRYPT, tea_enc_tv_template, TEA_ENC_TEST_VECTORS);
-		test_cipher ("tea", MODE_ECB, DECRYPT, tea_dec_tv_template, TEA_DEC_TEST_VECTORS);
-
-
-		//XTEA
-		test_cipher ("xtea", MODE_ECB, ENCRYPT, xtea_enc_tv_template, XTEA_ENC_TEST_VECTORS);
-		test_cipher ("xtea", MODE_ECB, DECRYPT, xtea_dec_tv_template, XTEA_DEC_TEST_VECTORS);
-
-		//KHAZAD
-		test_cipher ("khazad", MODE_ECB, ENCRYPT, khazad_enc_tv_template, KHAZAD_ENC_TEST_VECTORS);
-		test_cipher ("khazad", MODE_ECB, DECRYPT, khazad_dec_tv_template, KHAZAD_DEC_TEST_VECTORS);
-
-		//ANUBIS
-		test_cipher ("anubis", MODE_ECB, ENCRYPT, anubis_enc_tv_template, ANUBIS_ENC_TEST_VECTORS);
-		test_cipher ("anubis", MODE_ECB, DECRYPT, anubis_dec_tv_template, ANUBIS_DEC_TEST_VECTORS);
-		test_cipher ("anubis", MODE_CBC, ENCRYPT, anubis_cbc_enc_tv_template, ANUBIS_CBC_ENC_TEST_VECTORS);
-		test_cipher ("anubis", MODE_CBC, DECRYPT, anubis_cbc_dec_tv_template, ANUBIS_CBC_ENC_TEST_VECTORS);
-
-		//XETA
-		test_cipher ("xeta", MODE_ECB, ENCRYPT, xeta_enc_tv_template, XETA_ENC_TEST_VECTORS);
-		test_cipher ("xeta", MODE_ECB, DECRYPT, xeta_dec_tv_template, XETA_DEC_TEST_VECTORS);
-
-		test_hash("sha384", sha384_tv_template, SHA384_TEST_VECTORS);
-		test_hash("sha512", sha512_tv_template, SHA512_TEST_VECTORS);
-		test_hash("wp512", wp512_tv_template, WP512_TEST_VECTORS);
-		test_hash("wp384", wp384_tv_template, WP384_TEST_VECTORS);
-		test_hash("wp256", wp256_tv_template, WP256_TEST_VECTORS);
-		test_hash("tgr192", tgr192_tv_template, TGR192_TEST_VECTORS);
-		test_hash("tgr160", tgr160_tv_template, TGR160_TEST_VECTORS);
-		test_hash("tgr128", tgr128_tv_template, TGR128_TEST_VECTORS);
-		test_deflate();
-		test_crc32c();
-#ifdef CONFIG_CRYPTO_HMAC
-		test_hmac("md5", hmac_md5_tv_template, HMAC_MD5_TEST_VECTORS);
-		test_hmac("sha1", hmac_sha1_tv_template, HMAC_SHA1_TEST_VECTORS);
-		test_hmac("sha256", hmac_sha256_tv_template, HMAC_SHA256_TEST_VECTORS);
-#endif
-
-		test_hash("michael_mic", michael_mic_tv_template, MICHAEL_MIC_TEST_VECTORS);
-		break;
-
-	case 1:
+	case ALG_MD5:
 		test_hash("md5", md5_tv_template, MD5_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 2:
+	case ALG_SHA1:
 		test_hash("sha1", sha1_tv_template, SHA1_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 3:
+	case ALG_DES:
 		test_cipher ("des", MODE_ECB, ENCRYPT, des_enc_tv_template, DES_ENC_TEST_VECTORS);
 		test_cipher ("des", MODE_ECB, DECRYPT, des_dec_tv_template, DES_DEC_TEST_VECTORS);
 		test_cipher ("des", MODE_CBC, ENCRYPT, des_cbc_enc_tv_template, DES_CBC_ENC_TEST_VECTORS);
 		test_cipher ("des", MODE_CBC, DECRYPT, des_cbc_dec_tv_template, DES_CBC_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 4:
+	case ALG_DES3_EDE:
 		test_cipher ("des3_ede", MODE_ECB, ENCRYPT, des3_ede_enc_tv_template, DES3_EDE_ENC_TEST_VECTORS);
 		test_cipher ("des3_ede", MODE_ECB, DECRYPT, des3_ede_dec_tv_template, DES3_EDE_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 5:
+	case ALG_MD4:
 		test_hash("md4", md4_tv_template, MD4_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 6:
+	case ALG_SHA256:
 		test_hash("sha256", sha256_tv_template, SHA256_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 7:
+	case ALG_BLOWFISH:
 		test_cipher ("blowfish", MODE_ECB, ENCRYPT, bf_enc_tv_template, BF_ENC_TEST_VECTORS);
 		test_cipher ("blowfish", MODE_ECB, DECRYPT, bf_dec_tv_template, BF_DEC_TEST_VECTORS);
 		test_cipher ("blowfish", MODE_CBC, ENCRYPT, bf_cbc_enc_tv_template, BF_CBC_ENC_TEST_VECTORS);
 		test_cipher ("blowfish", MODE_CBC, DECRYPT, bf_cbc_dec_tv_template, BF_CBC_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 8:
+	case ALG_TWOFISH:
 		test_cipher ("twofish", MODE_ECB, ENCRYPT, tf_enc_tv_template, TF_ENC_TEST_VECTORS);
 		test_cipher ("twofish", MODE_ECB, DECRYPT, tf_dec_tv_template, TF_DEC_TEST_VECTORS);
 		test_cipher ("twofish", MODE_CBC, ENCRYPT, tf_cbc_enc_tv_template, TF_CBC_ENC_TEST_VECTORS);
 		test_cipher ("twofish", MODE_CBC, DECRYPT, tf_cbc_dec_tv_template, TF_CBC_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 9:
+	case ALG_SERPENT:
 		test_cipher ("serpent", MODE_ECB, ENCRYPT, serpent_enc_tv_template, SERPENT_ENC_TEST_VECTORS);
 		test_cipher ("serpent", MODE_ECB, DECRYPT, serpent_dec_tv_template, SERPENT_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 10:
+	case ALG_AES:
 		test_cipher ("aes", MODE_ECB, ENCRYPT, aes_enc_tv_template, AES_ENC_TEST_VECTORS);
 		test_cipher ("aes", MODE_ECB, DECRYPT, aes_dec_tv_template, AES_DEC_TEST_VECTORS);
 		test_cipher ("aes", MODE_CBC, ENCRYPT, aes_cbc_enc_tv_template, AES_CBC_ENC_TEST_VECTORS);
 		test_cipher ("aes", MODE_CBC, DECRYPT, aes_cbc_dec_tv_template, AES_CBC_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 11:
+	case ALG_SHA384:
 		test_hash("sha384", sha384_tv_template, SHA384_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 12:
+	case ALG_SHA512:
 		test_hash("sha512", sha512_tv_template, SHA512_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 13:
+	case ALG_DEFLATE:
 		test_deflate();
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 14:
+	case ALG_CAST5:
 		test_cipher ("cast5", MODE_ECB, ENCRYPT, cast5_enc_tv_template, CAST5_ENC_TEST_VECTORS);
 		test_cipher ("cast5", MODE_ECB, DECRYPT, cast5_dec_tv_template, CAST5_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 15:
+	case ALG_CAST6:
 		test_cipher ("cast6", MODE_ECB, ENCRYPT, cast6_enc_tv_template, CAST6_ENC_TEST_VECTORS);
 		test_cipher ("cast6", MODE_ECB, DECRYPT, cast6_dec_tv_template, CAST6_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 16:
+	case ALG_ARC4:
 		test_cipher ("arc4", MODE_ECB, ENCRYPT, arc4_enc_tv_template, ARC4_ENC_TEST_VECTORS);
 		test_cipher ("arc4", MODE_ECB, DECRYPT, arc4_dec_tv_template, ARC4_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 17:
+	case ALG_MICHAEL_MIC:
 		test_hash("michael_mic", michael_mic_tv_template, MICHAEL_MIC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 18:
+	case ALG_CRC32C:
 		test_crc32c();
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 19:
+	case ALG_TEA:
 		test_cipher ("tea", MODE_ECB, ENCRYPT, tea_enc_tv_template, TEA_ENC_TEST_VECTORS);
 		test_cipher ("tea", MODE_ECB, DECRYPT, tea_dec_tv_template, TEA_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 20:
+	case ALG_XTEA:
 		test_cipher ("xtea", MODE_ECB, ENCRYPT, xtea_enc_tv_template, XTEA_ENC_TEST_VECTORS);
 		test_cipher ("xtea", MODE_ECB, DECRYPT, xtea_dec_tv_template, XTEA_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 21:
+	case ALG_KHAZAD:
 		test_cipher ("khazad", MODE_ECB, ENCRYPT, khazad_enc_tv_template, KHAZAD_ENC_TEST_VECTORS);
 		test_cipher ("khazad", MODE_ECB, DECRYPT, khazad_dec_tv_template, KHAZAD_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 22:
+	case ALG_WP512:
 		test_hash("wp512", wp512_tv_template, WP512_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 23:
+	case ALG_WP384:
 		test_hash("wp384", wp384_tv_template, WP384_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 24:
+	case ALG_WP256:
 		test_hash("wp256", wp256_tv_template, WP256_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 25:
+	case ALG_TNEPRES:
 		test_cipher ("tnepres", MODE_ECB, ENCRYPT, tnepres_enc_tv_template, TNEPRES_ENC_TEST_VECTORS);
 		test_cipher ("tnepres", MODE_ECB, DECRYPT, tnepres_dec_tv_template, TNEPRES_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 26:
+	case ALG_ANUBIS:
 		test_cipher ("anubis", MODE_ECB, ENCRYPT, anubis_enc_tv_template, ANUBIS_ENC_TEST_VECTORS);
 		test_cipher ("anubis", MODE_ECB, DECRYPT, anubis_dec_tv_template, ANUBIS_DEC_TEST_VECTORS);
 		test_cipher ("anubis", MODE_CBC, ENCRYPT, anubis_cbc_enc_tv_template, ANUBIS_CBC_ENC_TEST_VECTORS);
 		test_cipher ("anubis", MODE_CBC, DECRYPT, anubis_cbc_dec_tv_template, ANUBIS_CBC_ENC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 27:
+	case ALG_TGR192:
 		test_hash("tgr192", tgr192_tv_template, TGR192_TEST_VECTORS);
-		break;
-
-	case 28:
+		if (mode_test != ALG_ALL) break;
 
+	case ALG_TGR160:
 		test_hash("tgr160", tgr160_tv_template, TGR160_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
-	case 29:
+	case ALG_TGR128:
 		test_hash("tgr128", tgr128_tv_template, TGR128_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 		
-	case 30:
+	case ALG_XETA:
 		test_cipher ("xeta", MODE_ECB, ENCRYPT, xeta_enc_tv_template, XETA_ENC_TEST_VECTORS);
 		test_cipher ("xeta", MODE_ECB, DECRYPT, xeta_dec_tv_template, XETA_DEC_TEST_VECTORS);
-		break;
+		if (mode_test != ALG_ALL) break;
 
+	default:
+		if (mode_test != ALG_ALL)
+			printk("Basic test for '%s' not implemented.\n", name_test);
+		break;
+	}
+	
 #ifdef CONFIG_CRYPTO_HMAC
-	case 100:
+	if (mode_hmac &gt; ALG_NONE)
+	switch (mode_hmac) {
+	case ALG_ALL:
+
+	case ALG_MD5:
 		test_hmac("md5", hmac_md5_tv_template, HMAC_MD5_TEST_VECTORS);
-		break;
+		if (mode_hmac != ALG_ALL) break;
 
-	case 101:
+	case ALG_SHA1:
 		test_hmac("sha1", hmac_sha1_tv_template, HMAC_SHA1_TEST_VECTORS);
-		break;
+		if (mode_hmac != ALG_ALL) break;
 
-	case 102:
+	case ALG_SHA256:
 		test_hmac("sha256", hmac_sha256_tv_template, HMAC_SHA256_TEST_VECTORS);
+		if (mode_hmac != ALG_ALL) break;
+		
+	default:
+		if (mode_hmac != ALG_ALL)
+			printk("HMAC test for '%s' not implemnted.\n", name_hmac);
 		break;
-
+	}
 #endif
 
-	case 200:
+	if (mode_speed &gt; ALG_NONE)
+	switch (mode_speed) {
+	case ALG_ALL:
+
+	case ALG_AES:
 		test_cipher_speed("aes", MODE_ECB, ENCRYPT, sec, NULL, 0,
 				  aes_speed_template);
 		test_cipher_speed("aes", MODE_ECB, DECRYPT, sec, NULL, 0,
@@ -1148,9 +1131,9 @@ static void do_test(void)
 				  aes_speed_template);
 		test_cipher_speed("aes", MODE_CBC, DECRYPT, sec, NULL, 0,
 				  aes_speed_template);
-		break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 201:
+	case ALG_DES3_EDE:
 		test_cipher_speed("des3_ede", MODE_ECB, ENCRYPT, sec,
 				  des3_ede_enc_tv_template,
 				  DES3_EDE_ENC_TEST_VECTORS,
@@ -1167,9 +1150,9 @@ static void do_test(void)
 				  des3_ede_dec_tv_template,
 				  DES3_EDE_DEC_TEST_VECTORS,
 				  des3_ede_speed_template);
-		break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 202:
+	case ALG_TWOFISH:
 		test_cipher_speed("twofish", MODE_ECB, ENCRYPT, sec, NULL, 0,
 				  twofish_speed_template);
 		test_cipher_speed("twofish", MODE_ECB, DECRYPT, sec, NULL, 0,
@@ -1178,9 +1161,9 @@ static void do_test(void)
 				  twofish_speed_template);
 		test_cipher_speed("twofish", MODE_CBC, DECRYPT, sec, NULL, 0,
 				  twofish_speed_template);
-		break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 203:
+	case ALG_BLOWFISH:
 		test_cipher_speed("blowfish", MODE_ECB, ENCRYPT, sec, NULL, 0,
 				  blowfish_speed_template);
 		test_cipher_speed("blowfish", MODE_ECB, DECRYPT, sec, NULL, 0,
@@ -1189,9 +1172,9 @@ static void do_test(void)
 				  blowfish_speed_template);
 		test_cipher_speed("blowfish", MODE_CBC, DECRYPT, sec, NULL, 0,
 				  blowfish_speed_template);
-		break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 204:
+	case ALG_DES:
 		test_cipher_speed("des", MODE_ECB, ENCRYPT, sec, NULL, 0,
 				  des_speed_template);
 		test_cipher_speed("des", MODE_ECB, DECRYPT, sec, NULL, 0,
@@ -1202,69 +1185,62 @@ static void do_test(void)
 				  des_speed_template);
 		break;
 
-	case 300:
-		/* fall through */
-
-	case 301:
+	case ALG_MD4:
 		test_digest_speed("md4", sec, generic_digest_speed_template);
-		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 302:
+	case ALG_MD5:
 		test_digest_speed("md5", sec, generic_digest_speed_template);
-		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 303:
+	case ALG_SHA1:
 		test_digest_speed("sha1", sec, generic_digest_speed_template);
-		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 304:
+	case ALG_SHA256:
 		test_digest_speed("sha256", sec, generic_digest_speed_template);
-		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 305:
+	case ALG_SHA384:
 		test_digest_speed("sha384", sec, generic_digest_speed_template);
-		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 306:
+	case ALG_SHA512:
 		test_digest_speed("sha512", sec, generic_digest_speed_template);
-		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 307:
+	case ALG_WP256:
 		test_digest_speed("wp256", sec, generic_digest_speed_template);
-		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 308:
+	case ALG_WP384:
 		test_digest_speed("wp384", sec, generic_digest_speed_template);
-		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 309:
+	case ALG_WP512:
 		test_digest_speed("wp512", sec, generic_digest_speed_template);
-		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 310:
+	case ALG_TGR128:
 		test_digest_speed("tgr128", sec, generic_digest_speed_template);
-		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 311:
+	case ALG_TGR160:
 		test_digest_speed("tgr160", sec, generic_digest_speed_template);
-		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 312:
+	case ALG_TGR192:
 		test_digest_speed("tgr192", sec, generic_digest_speed_template);
-		if (mode &gt; 300 &amp;&amp; mode &lt; 400) break;
+		if (mode_speed != ALG_ALL) break;
 
-	case 399:
-		break;
+	}
 
-	case 1000:
+	if (mode_available)
 		test_available();
-		break;
-
-	default:
+ 
+	if (mode_test + mode_hmac + mode_speed + mode_available == 0)
 		/* useful for debugging */
 		printk("not testing anything\n");
-		break;
-	}
 }
 
 static int __init init(void)
@@ -1279,6 +1255,11 @@ static int __init init(void)
 		return -ENOMEM;
 	}
 
+	mode_test = name_to_id (name_test);
+	mode_hmac = name_to_id (name_hmac);
+	mode_speed = name_to_id (name_speed);
+	mode_available = name_to_id (name_available);
+
 	do_test();
 
 	kfree(xbuf);
@@ -1295,7 +1276,18 @@ static void __exit fini(void) { }
 module_init(init);
 module_exit(fini);
 
-module_param(mode, int, 0);
+module_param(name_test, charp, 0);
+MODULE_PARM_DESC(name_test, "Algorithm name for basic test mode, or 'all'.");
+
+module_param(name_hmac, charp, 0);
+MODULE_PARM_DESC(name_hmac, "Algorithm name for HMAC test mode, or 'all'.");
+
+module_param(name_speed, charp, 0);
+MODULE_PARM_DESC(name_speed, "Algorithm name for speed test mode, or 'all'.");
+
+module_param(name_available, charp, 0);
+MODULE_PARM_DESC(name_available, "Algorithm name to check for availability, or 'all'.");
+
 module_param(sec, uint, 0);
 MODULE_PARM_DESC(sec, "Length in seconds of speed tests "
 		      "(defaults to zero which uses CPU cycles instead)");
Index: linux/crypto/tcrypt.h
===================================================================
--- linux.orig/crypto/tcrypt.h
+++ linux/crypto/tcrypt.h
@@ -25,6 +25,47 @@
 #define MAX_KEYLEN		56
 #define MAX_IVLEN		32
 
+enum alg_ids {
+	ALG_NONE = 0,
+	ALG_ALL = 1,
+	ALG_DES,
+	ALG_MD5,
+	ALG_DES3_EDE,
+	ALG_ROT13,
+	ALG_SHA1,
+	ALG_SHA256,
+	ALG_BLOWFISH,
+	ALG_TWOFISH,
+	ALG_SERPENT,
+	ALG_SHA384,
+	ALG_SHA512,
+	ALG_MD4,
+	ALG_AES,
+	ALG_CAST5,
+	ALG_CAST6,
+	ALG_ARC4,
+	ALG_MICHAEL_MIC,
+	ALG_DEFLATE,
+	ALG_CRC32C,
+	ALG_TEA,
+	ALG_XTEA,
+	ALG_KHAZAD,
+	ALG_WP512,
+	ALG_WP384,
+	ALG_WP256,
+	ALG_TNEPRES,
+	ALG_XETA,
+	ALG_ANUBIS,
+	ALG_TGR192,
+	ALG_TGR160,
+	ALG_TGR128,
+};
+
+struct name_id_map {
+	const char *name;
+	enum alg_ids id;
+};
+
 struct hash_testvec {
 	/* only used with keyed hash algorithms */
 	char key[128] __attribute__ ((__aligned__(4)));

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060528065042</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-05-28 06:50:42-0400</timestampReceived><subject>Re: Getting real slow performance</subject><body>

Kim C wrote:
&gt; I have been using aes loop for quite some time now, and it has been
&gt; working fine until now. Today I seem to get much degraded performance on
&gt; certain files. I am not sure what is causing this (or if it is even aes
&gt; loop that causing it), so any pointers of what to do to further
&gt; invistigate would be nice.

I suspect that it is failing hard disk that has to do many read attempts to
get data off disk platters.

&gt; Hardware:
&gt; PII 450 MHz
&gt; 96mb ram
&gt; linux 2.6.12

Pentium-2 is old. Is your hard disk also that old?

&gt; aes loop (cant find installed version number)

losetup program appears to be from loop-AES-v3. Your loop device is using v2
on-disk format, so kernel driver can be from loop-AES-v2 or v3. This
information is based on your "losetup /dev/loop3" command output.
 
&gt; Sorry if this mail just shows the obvious and expected behaviour. But my
&gt; mind cant find a good explanation for these slowdowns. Are there any ways
&gt; to examine the queues to see what is taking so long?

Are there any kernel error messages?

# dmesg

Are there any problems in hard disk SMART data?

# smartctl -a /dev/hda

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060529064105</emailId><senderName>"Kim C"</senderName><senderEmail>kimc@operamail.com</senderEmail><timestampReceived>2006-05-29 06:41:05-0400</timestampReceived><subject>Re: Getting real slow performance</subject><body>

&gt; I suspect that it is failing hard disk that has to do many read attempts to
&gt; get data off disk platters.
&gt; 
&gt; &gt; Hardware:
&gt; &gt; PII 450 MHz
&gt; &gt; 96mb ram
&gt; &gt; linux 2.6.12
&gt; 
&gt; Pentium-2 is old. Is your hard disk also that old?
&gt; 
&gt; &gt; aes loop (cant find installed version number)
&gt; 
&gt; losetup program appears to be from loop-AES-v3. Your loop device is using v2
&gt; on-disk format, so kernel driver can be from loop-AES-v2 or v3. This
&gt; information is based on your "losetup /dev/loop3" command output.
&gt; 
&gt; &gt; Sorry if this mail just shows the obvious and expected behaviour. But my
&gt; &gt; mind cant find a good explanation for these slowdowns. Are there any ways
&gt; &gt; to examine the queues to see what is taking so long?
&gt; 
&gt; Are there any kernel error messages?
&gt; 
&gt; # dmesg
&gt; 
&gt; Are there any problems in hard disk SMART data?
&gt; 
&gt; # smartctl -a /dev/hda
&gt; 
&gt; --
&gt; Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD


I have suspected that the drive might be dying, though I dont see any other symptoms, \
no noise, no syslog messages, no smart logged and no kernel messages. Well the drive \
has always been a little funny with smart, always logged lots of  (  1)Raw Read Error \
Rate     0x000f   057   046   006       38919422 (195)Hardware ECC Recovered  0x001a  \
057   046   000       38919422 since I bought it. But it has never posed any \
trouble.(I kinda always written it off as old controller not always good with new \
harddrive, but this might be wrong, but it made me sleep at night :) ) Its a 200gb \
seagate harddrive Model Number: ST3200822A, and its not as old as the computer.

I can speed up filea by making a copy of it(and get less fragmentation). 

I assume the 100% utilization is from the loop device doing something(probably \
en/decrypting) is this wrongly assumed? iostat state that at 100% utilization big \
saturation may occur and I guess its that I see here?

from man iostat
"%util Percentage of CPU time during which I/O requests were issued  to  the  device \
(bandwidth  utilization  for  the device). Device saturation occurs when this value \
is close to 100%."

Best regards
Kim

-- 
_______________________________________________
Surf the Web in a faster, safer and easier way:
Download Opera 8 at http://www.opera.com

Powered by Outblaze

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060529143857</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-05-29 14:38:57-0400</timestampReceived><subject>Re: Getting real slow performance</subject><body>

Kim C wrote:
&gt; I have suspected that the drive might be dying, though I dont see any
&gt; other symptoms, no noise, no syslog messages, no smart logged and no
&gt; kernel messages. Well the drive has always been a little funny with smart,
&gt; always logged lots of
&gt; (  1)Raw Read Error Rate     0x000f   057   046   006       38919422
&gt; (195)Hardware ECC Recovered  0x001a   057   046   000       38919422

I see lots of "Hardware ECC Recovered" on recent Seagate disks too, but
always zero "Raw Read Error Rate". No problems so far with those Seagate
disks.

&gt; I assume the 100% utilization is from the loop device doing
&gt; something(probably en/decrypting) is this wrongly assumed? iostat state
&gt; that at 100% utilization big saturation may occur and I guess its that I
&gt; see here?

Whenever loop driver consumes CPU cycles, it shows up in "sys" section. This
can be in context of some process doing write to loop device, or loop helper
thread doing encrypting or decrypting.

"iowait" is equivalent to "idle" except that in "iowait" some process is
waiting for I/O reads or writes to complete. In both cases CPU is free.

That iostat data that you posted on Saturday says that loop CPU consumption
was 33% or less, and that most of the time loop driver was waiting for disk
to compete reads or writes.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060521152533</emailId><senderName>Matthias Schniedermeyer</senderName><senderEmail>ms@citd.de</senderEmail><timestampReceived>2006-05-21 15:25:33-0400</timestampReceived><subject>Re: How about deniability?  (read:http://www.zdnet.co.uk/print/?TYPE=story&amp;AT=39269746-39020330t-100</subject><body>

Jari Ruusu wrote:
&gt; Thomas Weinbrenner wrote:
&gt; 
&gt;&gt;The timestamps will show that the files weren't accessed for months or
&gt;&gt;even years. And there are also all those logfiles in /var/log which
&gt;&gt;include dates. I think there will be enough proof that the system wasn't
&gt;&gt;can't be the system you are normally using.
&gt; 
&gt; 
&gt; Q:  Why haven't files been accessed for months?
&gt; A:  Because file system superblocks contain "noatime" default mount option.
&gt; 
&gt; Q:  Why aren't there any log files in /var/log/* ?
&gt; A:  Because init scripts have been modified to shred and remove /var/log/*
&gt;     and some other files and directories in /var on shutdown.
&gt; 
&gt; In addition, a shell script, run as cron job once a week from 'normal' root
&gt; partition /dev/hda4, does these: (1) Fsck and mount /dev/hda2 (via encrypted
&gt; loop) and /dev/hda1 partitions so that their previous fsck and mount times
&gt; are updated on their superblocks. (2) Touch some decoy files and directories
&gt; from /dev/hda2 partition.

That wouldn't work in the police-case, when the computer was switched on 
when sized, or when you can recover the "real" time of last use.
For perfect denyability you would have to update the "decoy" system 
continously, when the real-system is used.

Or you could configure  syslog to "/dev/null" everything, or switch off 
syslog entirely.
OTOH it would be "fishy" if only of the system-parts were missing that 
provide time-information, even if they are per definition unusable as PROVE.

Otherwise you could still somewhat prove that the "decoy" system wasn't 
the one running when the computer was switched off (as you have the 
switch-off "timestamp").

But if one doesn't need 100% deniability: In an article about 
warez-servers i read that at least once they encountered a server that 
was 100% "on the fly" configured.
The whole system was on ramdisk(/ramfs/tmpfs). After switching of there 
was nothing left, except a bootstrap barebone-system on HDD(*).

A loop-aes-partition with random-key would be equally secure, when 
switched off if configured "on-the-fly" the key would be unrecoverable.
Only the work and time needed to get the system flying the first time 
and every time it is rebooted, for whaterver reason, seams a bit much. ;-)



*: The "root"-servers i worked with allow to be booted via network into 
a "rescure"-system.
This way even the HDD isn't needed to bootstrap the server.

Bis denn

-- 
Real Programmers consider "what you see is what you get" to be just as
bad a concept in Text Editors as it is in women. No, the Real Programmer
wants a "you asked for it, you got it" text editor -- complicated,
cryptic, powerful, unforgiving, dangerous.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060521122321</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-05-21 12:23:21-0400</timestampReceived><subject>Re: How about deniability?</subject><body>

Thomas Weinbrenner wrote:
&gt; The timestamps will show that the files weren't accessed for months or
&gt; even years. And there are also all those logfiles in /var/log which
&gt; include dates. I think there will be enough proof that the system wasn't
&gt; can't be the system you are normally using.

Q:  Why haven't files been accessed for months?
A:  Because file system superblocks contain "noatime" default mount option.

Q:  Why aren't there any log files in /var/log/* ?
A:  Because init scripts have been modified to shred and remove /var/log/*
    and some other files and directories in /var on shutdown.

In addition, a shell script, run as cron job once a week from 'normal' root
partition /dev/hda4, does these: (1) Fsck and mount /dev/hda2 (via encrypted
loop) and /dev/hda1 partitions so that their previous fsck and mount times
are updated on their superblocks. (2) Touch some decoy files and directories
from /dev/hda2 partition.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060522022216</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-22 02:22:16-0400</timestampReceived><subject>Re: Add missing accessors for new crypto_alg fields.</subject><body>

On Mon, May 22, 2006 at 02:20:18PM +1200, Michal Ludvig wrote:
&gt; Add missing accessors for new crypto_alg fields.

Who's going to use these accessors?

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060522031038</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-05-22 03:10:38-0400</timestampReceived><subject>Re: Add missing accessors for new crypto_alg fields.</subject><body>

Herbert Xu wrote:
&gt; On Mon, May 22, 2006 at 02:20:18PM +1200, Michal Ludvig wrote:
&gt;&gt; Add missing accessors for new crypto_alg fields.
&gt; 
&gt; Who's going to use these accessors?

Me ;-)

Well, not personally, but padlock-sha will.

BTW in padlock fallback path I need to make scatterlist from const char*
buffer. However the macros in scatterlist.h take non-const void*.
Should I
1) make them const (works for me and I'm not getting any compilation
warnings from other modules).
2) make my local copy of sg_set_buf() with const void parameter
3) let gcc keep complaining

Following is a patch that does #1.

Index: linux/include/linux/scatterlist.h
===================================================================
--- linux.orig/include/linux/scatterlist.h
+++ linux/include/linux/scatterlist.h
@@ -5,7 +5,7 @@
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/string.h&gt;

-static inline void sg_set_buf(struct scatterlist *sg, void *buf,
+static inline void sg_set_buf(struct scatterlist *sg, const void *buf,
                              unsigned int buflen)
 {
        sg-&gt;page = virt_to_page(buf);
@@ -13,7 +13,7 @@ static inline void sg_set_buf(struct sca
        sg-&gt;length = buflen;
 }

-static inline void sg_init_one(struct scatterlist *sg, void *buf,
+static inline void sg_init_one(struct scatterlist *sg, const void *buf,
                               unsigned int buflen)
 {
        memset(sg, 0, sizeof(*sg));
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060522031702</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-22 03:17:02-0400</timestampReceived><subject>Re: Add missing accessors for new crypto_alg fields.</subject><body>

On Mon, May 22, 2006 at 03:10:38PM +1200, Michal Ludvig wrote:
&gt; 
&gt; Well, not personally, but padlock-sha will.

How is it going to use these accessors? I'd like to see some code :)

&gt; BTW in padlock fallback path I need to make scatterlist from const char*
&gt; buffer. However the macros in scatterlist.h take non-const void*.
&gt; Should I
&gt; 1) make them const (works for me and I'm not getting any compilation
&gt; warnings from other modules).
&gt; 2) make my local copy of sg_set_buf() with const void parameter
&gt; 3) let gcc keep complaining

Please show me the code that causes this problem.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060521134510</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-21 13:45:10-0400</timestampReceived><subject>Re: [CRYPTO] Pass TFM instead of context into digest algos' final() method</subject><body>

Hi Michal:

On Mon, May 22, 2006 at 01:29:54AM +1200, Michal Ludvig wrote:
&gt; 
&gt; attached is an obvious fix for your "Pass TFM instead of CTX" patch.
&gt; Please apply to your GIT tree.

Thanks for catching this.  It looks like I missed the coa_init/coa_exit
calls as well.  Could you add that to your patch and resend?

Thanks,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060521215715</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-05-21 21:57:15-0400</timestampReceived><subject>Re: [CRYPTO] Pass TFM instead of context into digest algos' final()</subject><body>

Herbert Xu wrote:
&gt; Hi Michal:
&gt; 
&gt; On Mon, May 22, 2006 at 01:29:54AM +1200, Michal Ludvig wrote:
&gt;&gt; attached is an obvious fix for your "Pass TFM instead of CTX" patch.
&gt;&gt; Please apply to your GIT tree.
&gt; 
&gt; Thanks for catching this.  It looks like I missed the coa_init/coa_exit
&gt; calls as well.  Could you add that to your patch and resend?

Attached.

Michal

["tfm-fix.diff" (text/x-patch)]

Fix a few omissions in passing TFM instead of CTX to algorithms.

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux/crypto/digest.c
===================================================================
--- linux.orig/crypto/digest.c
+++ linux/crypto/digest.c
@@ -70,10 +70,10 @@ static void final(struct crypto_tfm *tfm
 		unsigned int size = crypto_tfm_alg_digestsize(tfm);
 		u8 buffer[size + alignmask];
 		u8 *dst = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
-		tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(crypto_tfm_ctx(tfm), dst);
+		tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(tfm, dst);
 		memcpy(out, dst, size);
 	} else
-		tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(crypto_tfm_ctx(tfm), out);
+		tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(tfm, out);
 }
 
 static int setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
Index: linux/crypto/compress.c
===================================================================
--- linux.orig/crypto/compress.c
+++ linux/crypto/compress.c
@@ -44,7 +44,7 @@ int crypto_init_compress_ops(struct cryp
 	int ret = 0;
 	struct compress_tfm *ops = &amp;tfm-&gt;crt_compress;
 	
-	ret = tfm-&gt;__crt_alg-&gt;cra_compress.coa_init(crypto_tfm_ctx(tfm));
+	ret = tfm-&gt;__crt_alg-&gt;cra_compress.coa_init(tfm);
 	if (ret)
 		goto out;
 
@@ -57,5 +57,5 @@ out:
 
 void crypto_exit_compress_ops(struct crypto_tfm *tfm)
 {
-	tfm-&gt;__crt_alg-&gt;cra_compress.coa_exit(crypto_tfm_ctx(tfm));
+	tfm-&gt;__crt_alg-&gt;cra_compress.coa_exit(tfm);
 }

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060519114514</emailId><senderName>Gabriel_Jägenstedt</senderName><senderEmail>gabriel.j@telia.com</senderEmail><timestampReceived>2006-05-19 11:45:14-0400</timestampReceived><subject>Re: How about deniability? (read: http://www.zdnet.co.uk/print/?TYPE=story&amp;AT=39269746-39020330t-100</subject><body>

I have all my disks completly encrypted. The boot partition is on a
usb-stick. There is a section on this in the loop-aes.readme.

Antonio Di Salvo wrote:
&gt; truecrypt offers a feature called hidden volume that makes use of a
&gt; nested encrypted file system. If forced, you can reveal the password
&gt; of the outer volume, while the one that really holds sensitive data is
&gt; hidden and cannot be distinguished from random data.
&gt; they give an explanation at this url:
&gt; http://www.truecrypt.org/hiddenvolume.php
&gt; 
&gt; I'm not aware if loop-aes provides something similar, so I cannot
&gt; answer you. However, I think not (IMHO). If someone know if it is
&gt; possibile to have completely random-looking data on the disk with root
&gt; partition encryption, please let me know.
&gt; 
&gt; Byez!
&gt; 
&gt; PS: sorry for the english!
&gt; 
&gt; On 5/19/06, Gregor Zattler &lt;telegraph@gmx.net&gt; wrote:
&gt; 
&gt;&gt; Hi,
&gt;&gt;
&gt;&gt; "Government to force handover of encryption keys"
&gt;&gt; http://www.zdnet.co.uk/print/?TYPE=story&amp;AT=39269746-39020330t-10000025c
&gt;&gt;
&gt;&gt; does loop-aes provide some kind of deniability?
&gt;&gt;
&gt;&gt; Does any other free crypto system?
&gt;&gt;
&gt;&gt; Ciao, Gregor
&gt;&gt; -- 
&gt;&gt;  -... --- .-. . -.. ..--.. ...-.-
&gt;&gt;
&gt;&gt; -
&gt;&gt; Linux-crypto:  cryptography in and on the Linux system
&gt;&gt; Archive:       http://mail.nl.linux.org/linux-crypto/
&gt;&gt;
&gt;&gt;
&gt; 
&gt; -
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/
&gt; 
&gt; 

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060508060152</emailId><senderName>       YOSHIFUJI Hideaki / =?iso-2022-jp?B?GyRCNUhGIzFRTEAbKEI=?=</senderName><senderEmail></senderEmail><timestampReceived>2006-05-08 06:01:52-0400</timestampReceived><subject>Re: [RFC][PATCH 1/2] Twofish cipher i586-asm optimized</subject><body>

In article &lt;200605072247.46655.jfritschi@freenet.de&gt; (at Sun, 7 May 2006 22:47:46 +0200), Joachim Fritschi &lt;jfritschi@freenet.de&gt; says:

&gt; After going over my patch again, i realized i missed the .cra_priority 
&gt; and .cra_driver_name setting in the crypto api struct. Here is an updated 
&gt; version of my patch:
&gt; 
&gt; http://homepages.tu-darmstadt.de/~fritschi/twofish/twofish-i586-asm-2.6.17-2.diff 

Any reasons to exclude 64BIT on Kconfig?

--yoshfuji
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060508172531</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-05-08 17:25:31-0400</timestampReceived><subject>Re: [RFC][PATCH 1/2] Twofish cipher i586-asm optimized</subject><body>

&gt; &gt; After going over my patch again, i realized i missed the .cra_priority
&gt; &gt; and .cra_driver_name setting in the crypto api struct. Here is an updated
&gt; &gt; version of my patch:
&gt; &gt;
&gt; &gt; http://homepages.tu-darmstadt.de/~fritschi/twofish/twofish-i586-asm-2.6.1
&gt; &gt;7-2.diff
&gt;
&gt; Any reasons to exclude 64BIT on Kconfig?

This is the patch for i586 and above only (i386 arch). If you want 64bit 
(x86_64 arch) you should take a look at my other patch:

http://homepages.tu-darmstadt.de/~fritschi/twofish/twofish-x86_64-asm-2.6.17-2.diff

Regards,
Joachim
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060516074424</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-16 07:44:24-0400</timestampReceived><subject>Re: [RFC][PATCH 1/2] Twofish cipher i586-asm optimized</subject><body>

On Sun, May 07, 2006 at 08:47:46PM +0000, Joachim Fritschi wrote:
&gt; After going over my patch again, i realized i missed the .cra_priority 
&gt; and .cra_driver_name setting in the crypto api struct. Here is an updated 
&gt; version of my patch:
&gt; 
&gt; http://homepages.tu-darmstadt.de/~fritschi/twofish/twofish-i586-asm-2.6.17-2.diff 

Thanks for doing this Joachim.  I like the result.

But the duplicate key code is a bit too much.  The fact that AES does
it should only serve as a reminder for us to fix it, not to create even
more duplication.

So could you please move the key generation code into a separate file,
say crypto/twofish-common.c which can then be shared by all twofish
implementations?

BTW, please include the actual patches the next time you submit them
along with Signed-off-by lines.  You should consult the file
Documentation/SubmittingPatches for detailed instructions.

Thanks,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060516113939</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-16 11:39:39-0400</timestampReceived><subject>[CRYPTO] aes-i586: Get rid of useless function wrappers</subject><body>

Hi:

The wrappers aes_encrypt/aes_decrypt simply reverse the order of the
function arguments.  It's just as easy to get the actual assembly code
to read them in the opposite order.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt

["p1.patch" (text/plain)]

diff --git a/arch/i386/crypto/aes-i586-asm.S b/arch/i386/crypto/aes-i586-asm.S
--- a/arch/i386/crypto/aes-i586-asm.S
+++ b/arch/i386/crypto/aes-i586-asm.S
@@ -36,16 +36,13 @@
 .file "aes-i586-asm.S"
 .text
 
-// aes_rval aes_enc_blk(const unsigned char in_blk[], unsigned char out_blk[], const aes_ctx cx[1])//
-// aes_rval aes_dec_blk(const unsigned char in_blk[], unsigned char out_blk[], const aes_ctx cx[1])//
-	
 #define tlen 1024   // length of each of 4 'xor' arrays (256 32-bit words)
 
 // offsets to parameters with one register pushed onto stack
 
-#define in_blk    8  // input byte array address parameter
+#define in_blk   16  // input byte array address parameter
 #define out_blk  12  // output byte array address parameter
-#define ctx      16  // AES context structure
+#define ctx       8  // AES context structure
 
 // offsets in context structure
 
@@ -220,6 +217,7 @@
 	do_col (table, r5,r0,r1,r4, r2,r3);		/* idx=r5 */
 
 // AES (Rijndael) Encryption Subroutine
+/* void aes_enc_blk(void *ctx, u8 *out_blk, const u8 *in_blk) */
 
 .global  aes_enc_blk
 
@@ -295,6 +293,7 @@ aes_enc_blk:
 	ret
 
 // AES (Rijndael) Decryption Subroutine
+/* void aes_dec_blk(void *ctx, u8 *out_blk, const u8 *in_blk) */
 
 .global  aes_dec_blk
 
diff --git a/arch/i386/crypto/aes.c b/arch/i386/crypto/aes.c
--- a/arch/i386/crypto/aes.c
+++ b/arch/i386/crypto/aes.c
@@ -45,8 +45,8 @@
 #include &lt;linux/crypto.h&gt;
 #include &lt;linux/linkage.h&gt;
 
-asmlinkage void aes_enc_blk(const u8 *src, u8 *dst, void *ctx);
-asmlinkage void aes_dec_blk(const u8 *src, u8 *dst, void *ctx);
+asmlinkage void aes_enc_blk(void *ctx, u8 *dst, const u8 *src);
+asmlinkage void aes_dec_blk(void *ctx, u8 *dst, const u8 *src);
 
 #define AES_MIN_KEY_SIZE	16
 #define AES_MAX_KEY_SIZE	32
@@ -464,16 +464,6 @@ aes_set_key(void *ctx_arg, const u8 *in_
 	return 0;
 }
 
-static inline void aes_encrypt(void *ctx, u8 *dst, const u8 *src)
-{
-	aes_enc_blk(src, dst, ctx);
-}
-static inline void aes_decrypt(void *ctx, u8 *dst, const u8 *src)
-{
-	aes_dec_blk(src, dst, ctx);
-}
-
-
 static struct crypto_alg aes_alg = {
 	.cra_name		=	"aes",
 	.cra_driver_name	=	"aes-i586",
@@ -488,8 +478,8 @@ static struct crypto_alg aes_alg = {
 			.cia_min_keysize	=	AES_MIN_KEY_SIZE,
 			.cia_max_keysize	=	AES_MAX_KEY_SIZE,
 			.cia_setkey	   	= 	aes_set_key,
-			.cia_encrypt	 	=	aes_encrypt,
-			.cia_decrypt	  	=	aes_decrypt
+			.cia_encrypt	 	=	aes_enc_blk,
+			.cia_decrypt	  	=	aes_dec_blk
 		}
 	}
 };

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060516114128</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-16 11:41:28-0400</timestampReceived><subject>[CRYPTO] all: Remove duplicate zeroing during init</subject><body>

Hi:

The context area is already zeroed by crypto_alloc_tfm so there is no
need for individual algorithms to zero it in their init functions.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt

["p2.patch" (text/plain)]

diff --git a/arch/s390/crypto/sha1_s390.c b/arch/s390/crypto/sha1_s390.c
--- a/arch/s390/crypto/sha1_s390.c
+++ b/arch/s390/crypto/sha1_s390.c
@@ -40,19 +40,17 @@ struct crypt_s390_sha1_ctx {
 	u8 buffer[2 * SHA1_BLOCK_SIZE];
 };
 
-static void
-sha1_init(void *ctx)
+static void sha1_init(void *ctx_arg) 
 {
-	static const struct crypt_s390_sha1_ctx initstate = {
-		.state = {
-			0x67452301,
-			0xEFCDAB89,
-			0x98BADCFE,
-			0x10325476,
-			0xC3D2E1F0
-		},
+	struct crypt_s390_sha1_ctx *ctx = ctx_arg;
+	static const u32 initstate[5] = {
+		0x67452301,
+		0xEFCDAB89,
+		0x98BADCFE,
+		0x10325476,
+		0xC3D2E1F0
 	};
-	memcpy(ctx, &amp;initstate, sizeof(initstate));
+	memcpy(ctx-&gt;state, &amp;initstate, sizeof(initstate));
 }
 
 static void
diff --git a/arch/s390/crypto/sha256_s390.c b/arch/s390/crypto/sha256_s390.c
--- a/arch/s390/crypto/sha256_s390.c
+++ b/arch/s390/crypto/sha256_s390.c
@@ -43,8 +43,6 @@ static void sha256_init(void *ctx)
 	sctx-&gt;state[5] = 0x9b05688c;
 	sctx-&gt;state[6] = 0x1f83d9ab;
 	sctx-&gt;state[7] = 0x5be0cd19;
-	sctx-&gt;count = 0;
-	memset(sctx-&gt;buf, 0, sizeof(sctx-&gt;buf));
 }
 
 static void sha256_update(void *ctx, const u8 *data, unsigned int len)
diff --git a/crypto/sha256.c b/crypto/sha256.c
--- a/crypto/sha256.c
+++ b/crypto/sha256.c
@@ -241,8 +241,6 @@ static void sha256_init(void *ctx)
 	sctx-&gt;state[5] = H5;
 	sctx-&gt;state[6] = H6;
 	sctx-&gt;state[7] = H7;
-	sctx-&gt;count[0] = sctx-&gt;count[1] = 0;
-	memset(sctx-&gt;buf, 0, sizeof(sctx-&gt;buf));
 }
 
 static void sha256_update(void *ctx, const u8 *data, unsigned int len)
diff --git a/crypto/sha512.c b/crypto/sha512.c
--- a/crypto/sha512.c
+++ b/crypto/sha512.c
@@ -172,8 +172,6 @@ sha512_init(void *ctx)
 	sctx-&gt;state[5] = H5;
 	sctx-&gt;state[6] = H6;
 	sctx-&gt;state[7] = H7;
-	sctx-&gt;count[0] = sctx-&gt;count[1] = sctx-&gt;count[2] = sctx-&gt;count[3] = 0;
-	memset(sctx-&gt;buf, 0, sizeof(sctx-&gt;buf));
 }
 
 static void
@@ -188,8 +186,6 @@ sha384_init(void *ctx)
         sctx-&gt;state[5] = HP5;
         sctx-&gt;state[6] = HP6;
         sctx-&gt;state[7] = HP7;
-        sctx-&gt;count[0] = sctx-&gt;count[1] = sctx-&gt;count[2] = sctx-&gt;count[3] = 0;
-        memset(sctx-&gt;buf, 0, sizeof(sctx-&gt;buf));
 }
 
 static void
diff --git a/crypto/tgr192.c b/crypto/tgr192.c
--- a/crypto/tgr192.c
+++ b/crypto/tgr192.c
@@ -500,12 +500,9 @@ static void tgr192_init(void *ctx)
 {
 	struct tgr192_ctx *tctx = ctx;
 
-	memset (tctx-&gt;hash, 0, 64);
 	tctx-&gt;a = 0x0123456789abcdefULL;
 	tctx-&gt;b = 0xfedcba9876543210ULL;
 	tctx-&gt;c = 0xf096a5b4c3b2e187ULL;
-	tctx-&gt;nblocks = 0;
-	tctx-&gt;count = 0;
 }
 
 
diff --git a/crypto/wp512.c b/crypto/wp512.c
--- a/crypto/wp512.c
+++ b/crypto/wp512.c
@@ -981,16 +981,8 @@ static void wp512_process_buffer(struct 
 
 }
 
-static void wp512_init (void *ctx) {
-	int i;
-	struct wp512_ctx *wctx = ctx;
-
-	memset(wctx-&gt;bitLength, 0, 32);
-	wctx-&gt;bufferBits = wctx-&gt;bufferPos = 0;
-	wctx-&gt;buffer[0] = 0;
-	for (i = 0; i &lt; 8; i++) {
-		wctx-&gt;hash[i] = 0L;
-	}
+static void wp512_init(void *ctx)
+{
 }
 
 static void wp512_update(void *ctx, const u8 *source, unsigned int len)

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060516114244</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-16 11:42:44-0400</timestampReceived><subject>[CRYPTO] all: Pass tfm instead of ctx to algorithms</subject><body>

Hi:

Up until now algorithms have been happy to get a context pointer since
they know everything that's in the tfm already (e.g., alignment, block
size).

However, once we have parameterised algorithms, such information could
be specific to each tfm.  So the algorithm API needs to be changed to
pass the tfm structure instead of the context pointer.

This patch is basically a text substitution.  The only tricky bit is
the assembly routines that need to get the context pointer offset
through asm-offsets.h.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt

["p3.patch" (text/plain)]

diff --git a/arch/i386/crypto/aes-i586-asm.S b/arch/i386/crypto/aes-i586-asm.S
--- a/arch/i386/crypto/aes-i586-asm.S
+++ b/arch/i386/crypto/aes-i586-asm.S
@@ -36,19 +36,19 @@
 .file "aes-i586-asm.S"
 .text
 
-#define tlen 1024   // length of each of 4 'xor' arrays (256 32-bit words)
-
-// offsets to parameters with one register pushed onto stack
+#include &lt;asm/asm-offsets.h&gt;
 
-#define in_blk   16  // input byte array address parameter
-#define out_blk  12  // output byte array address parameter
-#define ctx       8  // AES context structure
-
-// offsets in context structure
+#define tlen 1024   // length of each of 4 'xor' arrays (256 32-bit words)
 
-#define ekey     0   // encryption key schedule base address
-#define nrnd   256   // number of rounds
-#define dkey   260   // decryption key schedule base address
+/* offsets to parameters with one register pushed onto stack */
+#define tfm 8
+#define out_blk 12
+#define in_blk 16
+
+/* offsets in crypto_tfm structure */
+#define ekey (crypto_tfm_ctx_offset + 0)
+#define nrnd (crypto_tfm_ctx_offset + 256)
+#define dkey (crypto_tfm_ctx_offset + 260)
 
 // register mapping for encrypt and decrypt subroutines
 
@@ -217,7 +217,7 @@
 	do_col (table, r5,r0,r1,r4, r2,r3);		/* idx=r5 */
 
 // AES (Rijndael) Encryption Subroutine
-/* void aes_enc_blk(void *ctx, u8 *out_blk, const u8 *in_blk) */
+/* void aes_enc_blk(struct crypto_tfm *tfm, u8 *out_blk, const u8 *in_blk) */
 
 .global  aes_enc_blk
 
@@ -228,7 +228,7 @@
 
 aes_enc_blk:
 	push    %ebp
-	mov     ctx(%esp),%ebp      // pointer to context
+	mov     tfm(%esp),%ebp
 
 // CAUTION: the order and the values used in these assigns 
 // rely on the register mappings
@@ -293,7 +293,7 @@ aes_enc_blk:
 	ret
 
 // AES (Rijndael) Decryption Subroutine
-/* void aes_dec_blk(void *ctx, u8 *out_blk, const u8 *in_blk) */
+/* void aes_dec_blk(struct crypto_tfm *tfm, u8 *out_blk, const u8 *in_blk) */
 
 .global  aes_dec_blk
 
@@ -304,7 +304,7 @@ aes_enc_blk:
 
 aes_dec_blk:
 	push    %ebp
-	mov     ctx(%esp),%ebp       // pointer to context
+	mov     tfm(%esp),%ebp
 
 // CAUTION: the order and the values used in these assigns 
 // rely on the register mappings
diff --git a/arch/i386/crypto/aes.c b/arch/i386/crypto/aes.c
--- a/arch/i386/crypto/aes.c
+++ b/arch/i386/crypto/aes.c
@@ -45,8 +45,8 @@
 #include &lt;linux/crypto.h&gt;
 #include &lt;linux/linkage.h&gt;
 
-asmlinkage void aes_enc_blk(void *ctx, u8 *dst, const u8 *src);
-asmlinkage void aes_dec_blk(void *ctx, u8 *dst, const u8 *src);
+asmlinkage void aes_enc_blk(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
+asmlinkage void aes_dec_blk(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
 
 #define AES_MIN_KEY_SIZE	16
 #define AES_MAX_KEY_SIZE	32
@@ -378,12 +378,12 @@ static void gen_tabs(void)
 	k[8*(i)+11] = ss[3];						\
 }
 
-static int
-aes_set_key(void *ctx_arg, const u8 *in_key, unsigned int key_len, u32 *flags)
+static int aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,
+		       unsigned int key_len, u32 *flags)
 {
 	int i;
 	u32 ss[8];
-	struct aes_ctx *ctx = ctx_arg;
+	struct aes_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *key = (const __le32 *)in_key;
 
 	/* encryption schedule */
diff --git a/arch/i386/kernel/asm-offsets.c b/arch/i386/kernel/asm-offsets.c
--- a/arch/i386/kernel/asm-offsets.c
+++ b/arch/i386/kernel/asm-offsets.c
@@ -4,6 +4,7 @@
  * to extract and format the required data.
  */
 
+#include &lt;linux/crypto.h&gt;
 #include &lt;linux/sched.h&gt;
 #include &lt;linux/signal.h&gt;
 #include &lt;linux/personality.h&gt;
@@ -69,4 +70,6 @@ void foo(void)
 
 	DEFINE(PAGE_SIZE_asm, PAGE_SIZE);
 	DEFINE(VSYSCALL_BASE, __fix_to_virt(FIX_VSYSCALL));
+
+	OFFSET(crypto_tfm_ctx_offset, crypto_tfm, __crt_ctx);
 }
diff --git a/arch/s390/crypto/aes_s390.c b/arch/s390/crypto/aes_s390.c
--- a/arch/s390/crypto/aes_s390.c
+++ b/arch/s390/crypto/aes_s390.c
@@ -37,10 +37,10 @@ struct s390_aes_ctx {
 	int key_len;
 };
 
-static int aes_set_key(void *ctx, const u8 *in_key, unsigned int key_len,
-		       u32 *flags)
+static int aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,
+		       unsigned int key_len, u32 *flags)
 {
-	struct s390_aes_ctx *sctx = ctx;
+	struct s390_aes_ctx *sctx = crypto_tfm_ctx(tfm);
 
 	switch (key_len) {
 	case 16:
@@ -70,9 +70,9 @@ fail:
 	return -EINVAL;
 }
 
-static void aes_encrypt(void *ctx, u8 *out, const u8 *in)
+static void aes_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
 {
-	const struct s390_aes_ctx *sctx = ctx;
+	const struct s390_aes_ctx *sctx = crypto_tfm_ctx(tfm);
 
 	switch (sctx-&gt;key_len) {
 	case 16:
@@ -90,9 +90,9 @@ static void aes_encrypt(void *ctx, u8 *o
 	}
 }
 
-static void aes_decrypt(void *ctx, u8 *out, const u8 *in)
+static void aes_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
 {
-	const struct s390_aes_ctx *sctx = ctx;
+	const struct s390_aes_ctx *sctx = crypto_tfm_ctx(tfm);
 
 	switch (sctx-&gt;key_len) {
 	case 16:
diff --git a/arch/s390/crypto/des_s390.c b/arch/s390/crypto/des_s390.c
--- a/arch/s390/crypto/des_s390.c
+++ b/arch/s390/crypto/des_s390.c
@@ -44,10 +44,10 @@ struct crypt_s390_des3_192_ctx {
 	u8 key[DES3_192_KEY_SIZE];
 };
 
-static int des_setkey(void *ctx, const u8 *key, unsigned int keylen,
-		      u32 *flags)
+static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
+		      unsigned int keylen, u32 *flags)
 {
-	struct crypt_s390_des_ctx *dctx = ctx;
+	struct crypt_s390_des_ctx *dctx = crypto_tfm_ctx(tfm);
 	int ret;
 
 	/* test if key is valid (not a weak key) */
@@ -57,16 +57,16 @@ static int des_setkey(void *ctx, const u
 	return ret;
 }
 
-static void des_encrypt(void *ctx, u8 *out, const u8 *in)
+static void des_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
 {
-	struct crypt_s390_des_ctx *dctx = ctx;
+	struct crypt_s390_des_ctx *dctx = crypto_tfm_ctx(tfm);
 
 	crypt_s390_km(KM_DEA_ENCRYPT, dctx-&gt;key, out, in, DES_BLOCK_SIZE);
 }
 
-static void des_decrypt(void *ctx, u8 *out, const u8 *in)
+static void des_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
 {
-	struct crypt_s390_des_ctx *dctx = ctx;
+	struct crypt_s390_des_ctx *dctx = crypto_tfm_ctx(tfm);
 
 	crypt_s390_km(KM_DEA_DECRYPT, dctx-&gt;key, out, in, DES_BLOCK_SIZE);
 }
@@ -166,11 +166,11 @@ static struct crypto_alg des_alg = {
  *   Implementers MUST reject keys that exhibit this property.
  *
  */
-static int des3_128_setkey(void *ctx, const u8 *key, unsigned int keylen,
-			   u32 *flags)
+static int des3_128_setkey(struct crypto_tfm *tfm, const u8 *key,
+			   unsigned int keylen, u32 *flags)
 {
 	int i, ret;
-	struct crypt_s390_des3_128_ctx *dctx = ctx;
+	struct crypt_s390_des3_128_ctx *dctx = crypto_tfm_ctx(tfm);
 	const u8* temp_key = key;
 
 	if (!(memcmp(key, &amp;key[DES_KEY_SIZE], DES_KEY_SIZE))) {
@@ -186,17 +186,17 @@ static int des3_128_setkey(void *ctx, co
 	return 0;
 }
 
-static void des3_128_encrypt(void *ctx, u8 *dst, const u8 *src)
+static void des3_128_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
-	struct crypt_s390_des3_128_ctx *dctx = ctx;
+	struct crypt_s390_des3_128_ctx *dctx = crypto_tfm_ctx(tfm);
 
 	crypt_s390_km(KM_TDEA_128_ENCRYPT, dctx-&gt;key, dst, (void*)src,
 		      DES3_128_BLOCK_SIZE);
 }
 
-static void des3_128_decrypt(void *ctx, u8 *dst, const u8 *src)
+static void des3_128_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
-	struct crypt_s390_des3_128_ctx *dctx = ctx;
+	struct crypt_s390_des3_128_ctx *dctx = crypto_tfm_ctx(tfm);
 
 	crypt_s390_km(KM_TDEA_128_DECRYPT, dctx-&gt;key, dst, (void*)src,
 		      DES3_128_BLOCK_SIZE);
@@ -302,11 +302,11 @@ static struct crypto_alg des3_128_alg = 
  *   property.
  *
  */
-static int des3_192_setkey(void *ctx, const u8 *key, unsigned int keylen,
-			   u32 *flags)
+static int des3_192_setkey(struct crypto_tfm *tfm, const u8 *key,
+			   unsigned int keylen, u32 *flags)
 {
 	int i, ret;
-	struct crypt_s390_des3_192_ctx *dctx = ctx;
+	struct crypt_s390_des3_192_ctx *dctx = crypto_tfm_ctx(tfm);
 	const u8* temp_key = key;
 
 	if (!(memcmp(key, &amp;key[DES_KEY_SIZE], DES_KEY_SIZE) &amp;&amp;
@@ -325,17 +325,17 @@ static int des3_192_setkey(void *ctx, co
 	return 0;
 }
 
-static void des3_192_encrypt(void *ctx, u8 *dst, const u8 *src)
+static void des3_192_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
-	struct crypt_s390_des3_192_ctx *dctx = ctx;
+	struct crypt_s390_des3_192_ctx *dctx = crypto_tfm_ctx(tfm);
 
 	crypt_s390_km(KM_TDEA_192_ENCRYPT, dctx-&gt;key, dst, (void*)src,
 		      DES3_192_BLOCK_SIZE);
 }
 
-static void des3_192_decrypt(void *ctx, u8 *dst, const u8 *src)
+static void des3_192_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
-	struct crypt_s390_des3_192_ctx *dctx = ctx;
+	struct crypt_s390_des3_192_ctx *dctx = crypto_tfm_ctx(tfm);
 
 	crypt_s390_km(KM_TDEA_192_DECRYPT, dctx-&gt;key, dst, (void*)src,
 		      DES3_192_BLOCK_SIZE);
diff --git a/arch/s390/crypto/sha1_s390.c b/arch/s390/crypto/sha1_s390.c
--- a/arch/s390/crypto/sha1_s390.c
+++ b/arch/s390/crypto/sha1_s390.c
@@ -40,9 +40,9 @@ struct crypt_s390_sha1_ctx {
 	u8 buffer[2 * SHA1_BLOCK_SIZE];
 };
 
-static void sha1_init(void *ctx_arg) 
+static void sha1_init(struct crypto_tfm *tfm)
 {
-	struct crypt_s390_sha1_ctx *ctx = ctx_arg;
+	struct crypt_s390_sha1_ctx *ctx = crypto_tfm_ctx(tfm);
 	static const u32 initstate[5] = {
 		0x67452301,
 		0xEFCDAB89,
@@ -53,13 +53,13 @@ static void sha1_init(void *ctx_arg) 
 	memcpy(ctx-&gt;state, &amp;initstate, sizeof(initstate));
 }
 
-static void
-sha1_update(void *ctx, const u8 *data, unsigned int len)
+static void sha1_update(struct crypto_tfm *tfm, const u8 *data,
+			unsigned int len)
 {
 	struct crypt_s390_sha1_ctx *sctx;
 	long imd_len;
 
-	sctx = ctx;
+	sctx = crypto_tfm_ctx(tfm);
 	sctx-&gt;count += len * 8; //message bit length
 
 	//anything in buffer yet? -&gt; must be completed
@@ -108,10 +108,9 @@ pad_message(struct crypt_s390_sha1_ctx* 
 }
 
 /* Add padding and return the message digest. */
-static void
-sha1_final(void* ctx, u8 *out)
+static void sha1_final(struct crypto_tfm *tfm, u8 *out)
 {
-	struct crypt_s390_sha1_ctx *sctx = ctx;
+	struct crypt_s390_sha1_ctx *sctx = crypto_tfm_ctx(tfm);
 
 	//must perform manual padding
 	pad_message(sctx);
diff --git a/arch/s390/crypto/sha256_s390.c b/arch/s390/crypto/sha256_s390.c
--- a/arch/s390/crypto/sha256_s390.c
+++ b/arch/s390/crypto/sha256_s390.c
@@ -31,9 +31,9 @@ struct s390_sha256_ctx {
 	u8 buf[2 * SHA256_BLOCK_SIZE];
 };
 
-static void sha256_init(void *ctx)
+static void sha256_init(struct crypto_tfm *tfm)
 {
-	struct s390_sha256_ctx *sctx = ctx;
+	struct s390_sha256_ctx *sctx = crypto_tfm_ctx(tfm);
 
 	sctx-&gt;state[0] = 0x6a09e667;
 	sctx-&gt;state[1] = 0xbb67ae85;
@@ -45,9 +45,10 @@ static void sha256_init(void *ctx)
 	sctx-&gt;state[7] = 0x5be0cd19;
 }
 
-static void sha256_update(void *ctx, const u8 *data, unsigned int len)
+static void sha256_update(struct crypto_tfm *tfm, const u8 *data,
+			  unsigned int len)
 {
-	struct s390_sha256_ctx *sctx = ctx;
+	struct s390_sha256_ctx *sctx = crypto_tfm_ctx(tfm);
 	unsigned int index;
 	int ret;
 
@@ -106,9 +107,9 @@ static void pad_message(struct s390_sha2
 }
 
 /* Add padding and return the message digest */
-static void sha256_final(void* ctx, u8 *out)
+static void sha256_final(struct crypto_tfm *tfm, u8 *out)
 {
-	struct s390_sha256_ctx *sctx = ctx;
+	struct s390_sha256_ctx *sctx = crypto_tfm_ctx(tfm);
 
 	/* must perform manual padding */
 	pad_message(sctx);
diff --git a/arch/x86_64/crypto/aes-x86_64-asm.S b/arch/x86_64/crypto/aes-x86_64-asm.S
--- a/arch/x86_64/crypto/aes-x86_64-asm.S
+++ b/arch/x86_64/crypto/aes-x86_64-asm.S
@@ -15,6 +15,10 @@
 
 .text
 
+#include &lt;asm/asm-offsets.h&gt;
+
+#define BASE crypto_tfm_ctx_offset
+
 #define R1	%rax
 #define R1E	%eax
 #define R1X	%ax
@@ -46,19 +50,19 @@
 #define R10	%r10
 #define R11	%r11
 
-#define prologue(FUNC,BASE,B128,B192,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11) \
+#define prologue(FUNC,KEY,B128,B192,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11) \
 	.global	FUNC;			\
 	.type	FUNC,@function;		\
 	.align	8;			\
 FUNC:	movq	r1,r2;			\
 	movq	r3,r4;			\
-	leaq	BASE+52(r8),r9;		\
+	leaq	BASE+KEY+52(r8),r9;	\
 	movq	r10,r11;		\
 	movl	(r7),r5 ## E;		\
 	movl	4(r7),r1 ## E;		\
 	movl	8(r7),r6 ## E;		\
 	movl	12(r7),r7 ## E;		\
-	movl	(r8),r10 ## E;		\
+	movl	BASE(r8),r10 ## E;	\
 	xorl	-48(r9),r5 ## E;	\
 	xorl	-44(r9),r1 ## E;	\
 	xorl	-40(r9),r6 ## E;	\
@@ -128,8 +132,8 @@ FUNC:	movq	r1,r2;			\
 	movl	r3 ## E,r1 ## E;	\
 	movl	r4 ## E,r2 ## E;
 
-#define entry(FUNC,BASE,B128,B192) \
-	prologue(FUNC,BASE,B128,B192,R2,R8,R7,R9,R1,R3,R4,R6,R10,R5,R11)
+#define entry(FUNC,KEY,B128,B192) \
+	prologue(FUNC,KEY,B128,B192,R2,R8,R7,R9,R1,R3,R4,R6,R10,R5,R11)
 
 #define return epilogue(R8,R2,R9,R7,R5,R6,R3,R4,R11)
 
@@ -147,7 +151,7 @@ FUNC:	movq	r1,r2;			\
 #define decrypt_final(TAB,OFFSET) \
 	round(TAB,OFFSET,R2,R1,R4,R3,R6,R5,R7,R10,R5,R6,R3,R4)
 
-/* void aes_encrypt(void *ctx, u8 *out, const u8 *in) */
+/* void aes_encrypt(stuct crypto_tfm *tfm, u8 *out, const u8 *in) */
 
 	entry(aes_encrypt,0,enc128,enc192)
 	encrypt_round(aes_ft_tab,-96)
@@ -166,7 +170,7 @@ enc128:	encrypt_round(aes_ft_tab,-32)
 	encrypt_final(aes_fl_tab,112)
 	return
 
-/* void aes_decrypt(void *ctx, u8 *out, const u8 *in) */
+/* void aes_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in) */
 
 	entry(aes_decrypt,240,dec128,dec192)
 	decrypt_round(aes_it_tab,-96)
diff --git a/arch/x86_64/crypto/aes.c b/arch/x86_64/crypto/aes.c
--- a/arch/x86_64/crypto/aes.c
+++ b/arch/x86_64/crypto/aes.c
@@ -227,10 +227,10 @@ static void __init gen_tabs(void)
 	t ^= E_KEY[8 * i + 7]; E_KEY[8 * i + 15] = t;	\
 }
 
-static int aes_set_key(void *ctx_arg, const u8 *in_key, unsigned int key_len,
-		       u32 *flags)
+static int aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,
+		       unsigned int key_len, u32 *flags)
 {
-	struct aes_ctx *ctx = ctx_arg;
+	struct aes_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *key = (const __le32 *)in_key;
 	u32 i, j, t, u, v, w;
 
@@ -283,8 +283,8 @@ static int aes_set_key(void *ctx_arg, co
 	return 0;
 }
 
-extern void aes_encrypt(void *ctx_arg, u8 *out, const u8 *in);
-extern void aes_decrypt(void *ctx_arg, u8 *out, const u8 *in);
+extern void aes_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in);
+extern void aes_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in);
 
 static struct crypto_alg aes_alg = {
 	.cra_name		=	"aes",
diff --git a/arch/x86_64/kernel/asm-offsets.c b/arch/x86_64/kernel/asm-offsets.c
--- a/arch/x86_64/kernel/asm-offsets.c
+++ b/arch/x86_64/kernel/asm-offsets.c
@@ -4,6 +4,7 @@
  * and format the required data.
  */
 
+#include &lt;linux/crypto.h&gt;
 #include &lt;linux/sched.h&gt; 
 #include &lt;linux/stddef.h&gt;
 #include &lt;linux/errno.h&gt; 
@@ -68,5 +69,7 @@ int main(void)
 	DEFINE(pbe_next, offsetof(struct pbe, next));
 	BLANK();
 	DEFINE(TSS_ist, offsetof(struct tss_struct, ist));
+	BLANK();
+	DEFINE(crypto_tfm_ctx_offset, offsetof(struct crypto_tfm, __crt_ctx));
 	return 0;
 }
diff --git a/crypto/aes.c b/crypto/aes.c
--- a/crypto/aes.c
+++ b/crypto/aes.c
@@ -248,10 +248,10 @@ gen_tabs (void)
     t ^= E_KEY[8 * i + 7]; E_KEY[8 * i + 15] = t;   \
 }
 
-static int
-aes_set_key(void *ctx_arg, const u8 *in_key, unsigned int key_len, u32 *flags)
+static int aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,
+		       unsigned int key_len, u32 *flags)
 {
-	struct aes_ctx *ctx = ctx_arg;
+	struct aes_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *key = (const __le32 *)in_key;
 	u32 i, t, u, v, w;
 
@@ -318,9 +318,9 @@ aes_set_key(void *ctx_arg, const u8 *in_
     f_rl(bo, bi, 2, k);     \
     f_rl(bo, bi, 3, k)
 
-static void aes_encrypt(void *ctx_arg, u8 *out, const u8 *in)
+static void aes_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
 {
-	const struct aes_ctx *ctx = ctx_arg;
+	const struct aes_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *src = (const __le32 *)in;
 	__le32 *dst = (__le32 *)out;
 	u32 b0[4], b1[4];
@@ -373,9 +373,9 @@ static void aes_encrypt(void *ctx_arg, u
     i_rl(bo, bi, 2, k);     \
     i_rl(bo, bi, 3, k)
 
-static void aes_decrypt(void *ctx_arg, u8 *out, const u8 *in)
+static void aes_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
 {
-	const struct aes_ctx *ctx = ctx_arg;
+	const struct aes_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *src = (const __le32 *)in;
 	__le32 *dst = (__le32 *)out;
 	u32 b0[4], b1[4];
diff --git a/crypto/anubis.c b/crypto/anubis.c
--- a/crypto/anubis.c
+++ b/crypto/anubis.c
@@ -460,16 +460,15 @@ static const u32 rc[] = {
 	0xf726ffedU, 0xe89d6f8eU, 0x19a0f089U,
 };
 
-static int anubis_setkey(void *ctx_arg, const u8 *in_key,
+static int anubis_setkey(struct crypto_tfm *tfm, const u8 *in_key,
 			 unsigned int key_len, u32 *flags)
 {
+	struct anubis_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __be32 *key = (const __be32 *)in_key;
 	int N, R, i, r;
 	u32 kappa[ANUBIS_MAX_N];
 	u32 inter[ANUBIS_MAX_N];
 
-	struct anubis_ctx *ctx = ctx_arg;
-
 	switch (key_len)
 	{
 		case 16: case 20: case 24: case 28:
@@ -660,15 +659,15 @@ static void anubis_crypt(u32 roundKey[AN
 		dst[i] = cpu_to_be32(inter[i]);
 }
 
-static void anubis_encrypt(void *ctx_arg, u8 *dst, const u8 *src)
+static void anubis_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
-	struct anubis_ctx *ctx = ctx_arg;
+	struct anubis_ctx *ctx = crypto_tfm_ctx(tfm);
 	anubis_crypt(ctx-&gt;E, dst, src, ctx-&gt;R);
 }
 
-static void anubis_decrypt(void *ctx_arg, u8 *dst, const u8 *src)
+static void anubis_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
-	struct anubis_ctx *ctx = ctx_arg;
+	struct anubis_ctx *ctx = crypto_tfm_ctx(tfm);
 	anubis_crypt(ctx-&gt;D, dst, src, ctx-&gt;R);
 }
 
diff --git a/crypto/arc4.c b/crypto/arc4.c
--- a/crypto/arc4.c
+++ b/crypto/arc4.c
@@ -24,9 +24,10 @@ struct arc4_ctx {
 	u8 x, y;
 };
 
-static int arc4_set_key(void *ctx_arg, const u8 *in_key, unsigned int key_len, u32 *flags)
+static int arc4_set_key(struct crypto_tfm *tfm, const u8 *in_key,
+			unsigned int key_len, u32 *flags)
 {
-	struct arc4_ctx *ctx = ctx_arg;
+	struct arc4_ctx *ctx = crypto_tfm_ctx(tfm);
 	int i, j = 0, k = 0;
 
 	ctx-&gt;x = 1;
@@ -48,9 +49,9 @@ static int arc4_set_key(void *ctx_arg, c
 	return 0;
 }
 
-static void arc4_crypt(void *ctx_arg, u8 *out, const u8 *in)
+static void arc4_crypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
 {
-	struct arc4_ctx *ctx = ctx_arg;
+	struct arc4_ctx *ctx = crypto_tfm_ctx(tfm);
 
 	u8 *const S = ctx-&gt;S;
 	u8 x = ctx-&gt;x;
diff --git a/crypto/blowfish.c b/crypto/blowfish.c
--- a/crypto/blowfish.c
+++ b/crypto/blowfish.c
@@ -349,7 +349,7 @@ static void encrypt_block(struct bf_ctx 
 	dst[1] = yl;
 }
 
-static void bf_encrypt(void *ctx, u8 *dst, const u8 *src)
+static void bf_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
 	const __be32 *in_blk = (const __be32 *)src;
 	__be32 *const out_blk = (__be32 *)dst;
@@ -357,17 +357,18 @@ static void bf_encrypt(void *ctx, u8 *ds
 
 	in32[0] = be32_to_cpu(in_blk[0]);
 	in32[1] = be32_to_cpu(in_blk[1]);
-	encrypt_block(ctx, out32, in32);
+	encrypt_block(crypto_tfm_ctx(tfm), out32, in32);
 	out_blk[0] = cpu_to_be32(out32[0]);
 	out_blk[1] = cpu_to_be32(out32[1]);
 }
 
-static void bf_decrypt(void *ctx, u8 *dst, const u8 *src)
+static void bf_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
+	struct bf_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __be32 *in_blk = (const __be32 *)src;
 	__be32 *const out_blk = (__be32 *)dst;
-	const u32 *P = ((struct bf_ctx *)ctx)-&gt;p;
-	const u32 *S = ((struct bf_ctx *)ctx)-&gt;s;
+	const u32 *P = ctx-&gt;p;
+	const u32 *S = ctx-&gt;s;
 	u32 yl = be32_to_cpu(in_blk[0]);
 	u32 yr = be32_to_cpu(in_blk[1]);
 
@@ -398,12 +399,14 @@ static void bf_decrypt(void *ctx, u8 *ds
 /* 
  * Calculates the blowfish S and P boxes for encryption and decryption.
  */
-static int bf_setkey(void *ctx, const u8 *key, unsigned int keylen, u32 *flags)
+static int bf_setkey(struct crypto_tfm *tfm, const u8 *key,
+		     unsigned int keylen, u32 *flags)
 {
+	struct bf_ctx *ctx = crypto_tfm_ctx(tfm);
+	u32 *P = ctx-&gt;p;
+	u32 *S = ctx-&gt;s;
 	short i, j, count;
 	u32 data[2], temp;
-	u32 *P = ((struct bf_ctx *)ctx)-&gt;p;
-	u32 *S = ((struct bf_ctx *)ctx)-&gt;s;
 
 	/* Copy the initialization s-boxes */
 	for (i = 0, count = 0; i &lt; 256; i++)
diff --git a/crypto/cast5.c b/crypto/cast5.c
--- a/crypto/cast5.c
+++ b/crypto/cast5.c
@@ -577,9 +577,9 @@ static const u32 sb8[256] = {
     (((s1[I &gt;&gt; 24] + s2[(I&gt;&gt;16)&amp;0xff]) ^ s3[(I&gt;&gt;8)&amp;0xff]) - s4[I&amp;0xff]) )
 
 
-static void cast5_encrypt(void *ctx, u8 * outbuf, const u8 * inbuf)
+static void cast5_encrypt(struct crypto_tfm *tfm, u8 *outbuf, const u8 *inbuf)
 {
-	struct cast5_ctx *c = (struct cast5_ctx *) ctx;
+	struct cast5_ctx *c = crypto_tfm_ctx(tfm);
 	const __be32 *src = (const __be32 *)inbuf;
 	__be32 *dst = (__be32 *)outbuf;
 	u32 l, r, t;
@@ -642,9 +642,9 @@ static void cast5_encrypt(void *ctx, u8 
 	dst[1] = cpu_to_be32(l);
 }
 
-static void cast5_decrypt(void *ctx, u8 * outbuf, const u8 * inbuf)
+static void cast5_decrypt(struct crypto_tfm *tfm, u8 *outbuf, const u8 *inbuf)
 {
-	struct cast5_ctx *c = (struct cast5_ctx *) ctx;
+	struct cast5_ctx *c = crypto_tfm_ctx(tfm);
 	const __be32 *src = (const __be32 *)inbuf;
 	__be32 *dst = (__be32 *)outbuf;
 	u32 l, r, t;
@@ -769,15 +769,15 @@ static void key_schedule(u32 * x, u32 * 
 }
 
 
-static int
-cast5_setkey(void *ctx, const u8 * key, unsigned key_len, u32 * flags)
+static int cast5_setkey(struct crypto_tfm *tfm, const u8 *key,
+			unsigned key_len, u32 *flags)
 {
+	struct cast5_ctx *c = crypto_tfm_ctx(tfm);
 	int i;
 	u32 x[4];
 	u32 z[4];
 	u32 k[16];
 	__be32 p_key[4];
-	struct cast5_ctx *c = (struct cast5_ctx *) ctx;
 	
 	if (key_len &lt; 5 || key_len &gt; 16) {
 		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
diff --git a/crypto/cast6.c b/crypto/cast6.c
--- a/crypto/cast6.c
+++ b/crypto/cast6.c
@@ -381,13 +381,13 @@ static inline void W(u32 *key, unsigned 
 	key[7] ^= F2(key[0], Tr[i % 4][7], Tm[i][7]);
 }
 
-static int
-cast6_setkey(void *ctx, const u8 * in_key, unsigned key_len, u32 * flags)
+static int cast6_setkey(struct crypto_tfm *tfm, const u8 *in_key,
+			unsigned key_len, u32 *flags)
 {
 	int i;
 	u32 key[8];
 	__be32 p_key[8]; /* padded key */
-	struct cast6_ctx *c = (struct cast6_ctx *) ctx;
+	struct cast6_ctx *c = crypto_tfm_ctx(tfm);
 
 	if (key_len &lt; 16 || key_len &gt; 32 || key_len % 4 != 0) {
 		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
@@ -444,8 +444,9 @@ static inline void QBAR (u32 * block, u8
         block[2] ^= F1(block[3], Kr[0], Km[0]);
 }
 
-static void cast6_encrypt (void * ctx, u8 * outbuf, const u8 * inbuf) {
-	struct cast6_ctx * c = (struct cast6_ctx *)ctx;
+static void cast6_encrypt(struct crypto_tfm *tfm, u8 *outbuf, const u8 *inbuf)
+{
+	struct cast6_ctx *c = crypto_tfm_ctx(tfm);
 	const __be32 *src = (const __be32 *)inbuf;
 	__be32 *dst = (__be32 *)outbuf;
 	u32 block[4];
@@ -476,8 +477,8 @@ static void cast6_encrypt (void * ctx, u
 	dst[3] = cpu_to_be32(block[3]);
 }	
 
-static void cast6_decrypt (void * ctx, u8 * outbuf, const u8 * inbuf) {
-	struct cast6_ctx * c = (struct cast6_ctx *)ctx;
+static void cast6_decrypt(struct crypto_tfm *tfm, u8 *outbuf, const u8 *inbuf) {
+	struct cast6_ctx * c = crypto_tfm_ctx(tfm);
 	const __be32 *src = (const __be32 *)inbuf;
 	__be32 *dst = (__be32 *)outbuf;
 	u32 block[4];
diff --git a/crypto/cipher.c b/crypto/cipher.c
--- a/crypto/cipher.c
+++ b/crypto/cipher.c
@@ -187,7 +187,7 @@ static unsigned int cbc_process_encrypt(
 	void (*xor)(u8 *, const u8 *) = tfm-&gt;crt_u.cipher.cit_xor_block;
 	int bsize = crypto_tfm_alg_blocksize(tfm);
 
-	void (*fn)(void *, u8 *, const u8 *) = desc-&gt;crfn;
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) = desc-&gt;crfn;
 	u8 *iv = desc-&gt;info;
 	unsigned int done = 0;
 
@@ -195,7 +195,7 @@ static unsigned int cbc_process_encrypt(
 
 	do {
 		xor(iv, src);
-		fn(crypto_tfm_ctx(tfm), dst, iv);
+		fn(tfm, dst, iv);
 		memcpy(iv, dst, bsize);
 
 		src += bsize;
@@ -218,7 +218,7 @@ static unsigned int cbc_process_decrypt(
 	u8 *buf = (u8 *)ALIGN((unsigned long)stack, alignmask + 1);
 	u8 **dst_p = src == dst ? &amp;buf : 
 
-	void (*fn)(void *, u8 *, const u8 *) = desc-&gt;crfn;
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) = desc-&gt;crfn;
 	u8 *iv = desc-&gt;info;
 	unsigned int done = 0;
 
@@ -227,7 +227,7 @@ static unsigned int cbc_process_decrypt(
 	do {
 		u8 *tmp_dst = *dst_p;
 
-		fn(crypto_tfm_ctx(tfm), tmp_dst, src);
+		fn(tfm, tmp_dst, src);
 		xor(tmp_dst, iv);
 		memcpy(iv, src, bsize);
 		if (tmp_dst != dst)
@@ -245,13 +245,13 @@ static unsigned int ecb_process(const st
 {
 	struct crypto_tfm *tfm = desc-&gt;tfm;
 	int bsize = crypto_tfm_alg_blocksize(tfm);
-	void (*fn)(void *, u8 *, const u8 *) = desc-&gt;crfn;
+	void (*fn)(struct crypto_tfm *, u8 *, const u8 *) = desc-&gt;crfn;
 	unsigned int done = 0;
 
 	nbytes -= bsize;
 
 	do {
-		fn(crypto_tfm_ctx(tfm), dst, src);
+		fn(tfm, dst, src);
 
 		src += bsize;
 		dst += bsize;
@@ -268,7 +268,7 @@ static int setkey(struct crypto_tfm *tfm
 		tfm-&gt;crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
 		return -EINVAL;
 	} else
-		return cia-&gt;cia_setkey(crypto_tfm_ctx(tfm), key, keylen,
+		return cia-&gt;cia_setkey(tfm, key, keylen,
 		                       &amp;tfm-&gt;crt_flags);
 }
 
diff --git a/crypto/compress.c b/crypto/compress.c
--- a/crypto/compress.c
+++ b/crypto/compress.c
@@ -22,8 +22,7 @@ static int crypto_compress(struct crypto
                             const u8 *src, unsigned int slen,
                             u8 *dst, unsigned int *dlen)
 {
-	return tfm-&gt;__crt_alg-&gt;cra_compress.coa_compress(crypto_tfm_ctx(tfm),
-	                                                 src, slen, dst,
+	return tfm-&gt;__crt_alg-&gt;cra_compress.coa_compress(tfm, src, slen, dst,
 	                                                 dlen);
 }
 
@@ -31,8 +30,7 @@ static int crypto_decompress(struct cryp
                              const u8 *src, unsigned int slen,
                              u8 *dst, unsigned int *dlen)
 {
-	return tfm-&gt;__crt_alg-&gt;cra_compress.coa_decompress(crypto_tfm_ctx(tfm),
-	                                                   src, slen, dst,
+	return tfm-&gt;__crt_alg-&gt;cra_compress.coa_decompress(tfm, src, slen, dst,
 	                                                   dlen);
 }
 
diff --git a/crypto/crc32c.c b/crypto/crc32c.c
--- a/crypto/crc32c.c
+++ b/crypto/crc32c.c
@@ -31,9 +31,9 @@ struct chksum_ctx {
  * crc using table.
  */
 
-static void chksum_init(void *ctx)
+static void chksum_init(struct crypto_tfm *tfm)
 {
-	struct chksum_ctx *mctx = ctx;
+	struct chksum_ctx *mctx = crypto_tfm_ctx(tfm);
 
 	mctx-&gt;crc = ~(u32)0;			/* common usage */
 }
@@ -43,10 +43,10 @@ static void chksum_init(void *ctx)
  * If your algorithm starts with ~0, then XOR with ~0 before you set
  * the seed.
  */
-static int chksum_setkey(void *ctx, const u8 *key, unsigned int keylen,
-	                  u32 *flags)
+static int chksum_setkey(struct crypto_tfm *tfm, const u8 *key,
+			 unsigned int keylen, u32 *flags)
 {
-	struct chksum_ctx *mctx = ctx;
+	struct chksum_ctx *mctx = crypto_tfm_ctx(tfm);
 
 	if (keylen != sizeof(mctx-&gt;crc)) {
 		if (flags)
@@ -57,9 +57,10 @@ static int chksum_setkey(void *ctx, cons
 	return 0;
 }
 
-static void chksum_update(void *ctx, const u8 *data, unsigned int length)
+static void chksum_update(struct crypto_tfm *tfm, const u8 *data,
+			  unsigned int length)
 {
-	struct chksum_ctx *mctx = ctx;
+	struct chksum_ctx *mctx = crypto_tfm_ctx(tfm);
 	u32 mcrc;
 
 	mcrc = crc32c(mctx-&gt;crc, data, (size_t)length);
@@ -67,9 +68,9 @@ static void chksum_update(void *ctx, con
 	mctx-&gt;crc = mcrc;
 }
 
-static void chksum_final(void *ctx, u8 *out)
+static void chksum_final(struct crypto_tfm *tfm, u8 *out)
 {
-	struct chksum_ctx *mctx = ctx;
+	struct chksum_ctx *mctx = crypto_tfm_ctx(tfm);
 	u32 mcrc = (mctx-&gt;crc ^ ~(u32)0);
 	
 	*(u32 *)out = __le32_to_cpu(mcrc);
diff --git a/crypto/crypto_null.c b/crypto/crypto_null.c
--- a/crypto/crypto_null.c
+++ b/crypto/crypto_null.c
@@ -27,8 +27,8 @@
 #define NULL_BLOCK_SIZE		1
 #define NULL_DIGEST_SIZE	0
 
-static int null_compress(void *ctx, const u8 *src, unsigned int slen,
-                         u8 *dst, unsigned int *dlen)
+static int null_compress(struct crypto_tfm *tfm, const u8 *src,
+			 unsigned int slen, u8 *dst, unsigned int *dlen)
 {
 	if (slen &gt; *dlen)
 		return -EINVAL;
@@ -37,20 +37,21 @@ static int null_compress(void *ctx, cons
 	return 0;
 }
 
-static void null_init(void *ctx)
+static void null_init(struct crypto_tfm *tfm)
 { }
 
-static void null_update(void *ctx, const u8 *data, unsigned int len)
+static void null_update(struct crypto_tfm *tfm, const u8 *data,
+			unsigned int len)
 { }
 
-static void null_final(void *ctx, u8 *out)
+static void null_final(struct crypto_tfm *tfm, u8 *out)
 { }
 
-static int null_setkey(void *ctx, const u8 *key,
-                       unsigned int keylen, u32 *flags)
+static int null_setkey(struct crypto_tfm *tfm, const u8 *key,
+		       unsigned int keylen, u32 *flags)
 { return 0; }
 
-static void null_crypt(void *ctx, u8 *dst, const u8 *src)
+static void null_crypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
 	memcpy(dst, src, NULL_BLOCK_SIZE);
 }
diff --git a/crypto/deflate.c b/crypto/deflate.c
--- a/crypto/deflate.c
+++ b/crypto/deflate.c
@@ -102,8 +102,9 @@ static void deflate_decomp_exit(struct d
 	kfree(ctx-&gt;decomp_stream.workspace);
 }
 
-static int deflate_init(void *ctx)
+static int deflate_init(struct crypto_tfm *tfm)
 {
+	struct deflate_ctx *ctx = crypto_tfm_ctx(tfm);
 	int ret;
 	
 	ret = deflate_comp_init(ctx);
@@ -116,17 +117,19 @@ out:
 	return ret;
 }
 
-static void deflate_exit(void *ctx)
+static void deflate_exit(struct crypto_tfm *tfm)
 {
+	struct deflate_ctx *ctx = crypto_tfm_ctx(tfm);
+
 	deflate_comp_exit(ctx);
 	deflate_decomp_exit(ctx);
 }
 
-static int deflate_compress(void *ctx, const u8 *src, unsigned int slen,
-	                    u8 *dst, unsigned int *dlen)
+static int deflate_compress(struct crypto_tfm *tfm, const u8 *src,
+			    unsigned int slen, u8 *dst, unsigned int *dlen)
 {
 	int ret = 0;
-	struct deflate_ctx *dctx = ctx;
+	struct deflate_ctx *dctx = crypto_tfm_ctx(tfm);
 	struct z_stream_s *stream = &amp;dctx-&gt;comp_stream;
 
 	ret = zlib_deflateReset(stream);
@@ -151,12 +154,12 @@ out:
 	return ret;
 }
  
-static int deflate_decompress(void *ctx, const u8 *src, unsigned int slen,
-                              u8 *dst, unsigned int *dlen)
+static int deflate_decompress(struct crypto_tfm *tfm, const u8 *src,
+			      unsigned int slen, u8 *dst, unsigned int *dlen)
 {
 	
 	int ret = 0;
-	struct deflate_ctx *dctx = ctx;
+	struct deflate_ctx *dctx = crypto_tfm_ctx(tfm);
 	struct z_stream_s *stream = &amp;dctx-&gt;decomp_stream;
 
 	ret = zlib_inflateReset(stream);
diff --git a/crypto/des.c b/crypto/des.c
--- a/crypto/des.c
+++ b/crypto/des.c
@@ -783,9 +783,10 @@ static void dkey(u32 *pe, const u8 *k)
 	}
 }
 
-static int des_setkey(void *ctx, const u8 *key, unsigned int keylen, u32 *flags)
+static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
+		      unsigned int keylen, u32 *flags)
 {
-	struct des_ctx *dctx = ctx;
+	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
 	u32 tmp[DES_EXPKEY_WORDS];
 	int ret;
 
@@ -803,9 +804,10 @@ static int des_setkey(void *ctx, const u
 	return 0;
 }
 
-static void des_encrypt(void *ctx, u8 *dst, const u8 *src)
+static void des_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
-	const u32 *K = ((struct des_ctx *)ctx)-&gt;expkey;
+	struct des_ctx *ctx = crypto_tfm_ctx(tfm);
+	const u32 *K = ctx-&gt;expkey;
 	const __le32 *s = (const __le32 *)src;
 	__le32 *d = (__le32 *)dst;
 	u32 L, R, A, B;
@@ -825,9 +827,10 @@ static void des_encrypt(void *ctx, u8 *d
 	d[1] = cpu_to_le32(L);
 }
 
-static void des_decrypt(void *ctx, u8 *dst, const u8 *src)
+static void des_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
-	const u32 *K = ((struct des_ctx *)ctx)-&gt;expkey + DES_EXPKEY_WORDS - 2;
+	struct des_ctx *ctx = crypto_tfm_ctx(tfm);
+	const u32 *K = ctx-&gt;expkey + DES_EXPKEY_WORDS - 2;
 	const __le32 *s = (const __le32 *)src;
 	__le32 *d = (__le32 *)dst;
 	u32 L, R, A, B;
@@ -860,11 +863,11 @@ static void des_decrypt(void *ctx, u8 *d
  *   property.
  *
  */
-static int des3_ede_setkey(void *ctx, const u8 *key,
+static int des3_ede_setkey(struct crypto_tfm *tfm, const u8 *key,
 			   unsigned int keylen, u32 *flags)
 {
 	const u32 *K = (const u32 *)key;
-	struct des3_ede_ctx *dctx = ctx;
+	struct des3_ede_ctx *dctx = crypto_tfm_ctx(tfm);
 	u32 *expkey = dctx-&gt;expkey;
 
 	if (unlikely(!((K[0] ^ K[2]) | (K[1] ^ K[3])) ||
@@ -881,9 +884,9 @@ static int des3_ede_setkey(void *ctx, co
 	return 0;
 }
 
-static void des3_ede_encrypt(void *ctx, u8 *dst, const u8 *src)
+static void des3_ede_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
-	struct des3_ede_ctx *dctx = ctx;
+	struct des3_ede_ctx *dctx = crypto_tfm_ctx(tfm);
 	const u32 *K = dctx-&gt;expkey;
 	const __le32 *s = (const __le32 *)src;
 	__le32 *d = (__le32 *)dst;
@@ -912,9 +915,9 @@ static void des3_ede_encrypt(void *ctx, 
 	d[1] = cpu_to_le32(L);
 }
 
-static void des3_ede_decrypt(void *ctx, u8 *dst, const u8 *src)
+static void des3_ede_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
-	struct des3_ede_ctx *dctx = ctx;
+	struct des3_ede_ctx *dctx = crypto_tfm_ctx(tfm);
 	const u32 *K = dctx-&gt;expkey + DES3_EDE_EXPKEY_WORDS - 2;
 	const __le32 *s = (const __le32 *)src;
 	__le32 *d = (__le32 *)dst;
diff --git a/crypto/digest.c b/crypto/digest.c
--- a/crypto/digest.c
+++ b/crypto/digest.c
@@ -20,7 +20,7 @@
 
 static void init(struct crypto_tfm *tfm)
 {
-	tfm-&gt;__crt_alg-&gt;cra_digest.dia_init(crypto_tfm_ctx(tfm));
+	tfm-&gt;__crt_alg-&gt;cra_digest.dia_init(tfm);
 }
 
 static void update(struct crypto_tfm *tfm,
@@ -46,16 +46,14 @@ static void update(struct crypto_tfm *tf
 				unsigned int bytes =
 					alignmask + 1 - (offset &amp; alignmask);
 				bytes = min(bytes, bytes_from_page);
-				tfm-&gt;__crt_alg-&gt;cra_digest.dia_update
-						(crypto_tfm_ctx(tfm), p,
-						 bytes);
+				tfm-&gt;__crt_alg-&gt;cra_digest.dia_update(tfm, p,
+								      bytes);
 				p += bytes;
 				bytes_from_page -= bytes;
 				l -= bytes;
 			}
-			tfm-&gt;__crt_alg-&gt;cra_digest.dia_update
-					(crypto_tfm_ctx(tfm), p,
-					 bytes_from_page);
+			tfm-&gt;__crt_alg-&gt;cra_digest.dia_update(tfm, p,
+							      bytes_from_page);
 			crypto_kunmap(src, 0);
 			crypto_yield(tfm);
 			offset = 0;
@@ -83,8 +81,7 @@ static int setkey(struct crypto_tfm *tfm
 	u32 flags;
 	if (tfm-&gt;__crt_alg-&gt;cra_digest.dia_setkey == NULL)
 		return -ENOSYS;
-	return tfm-&gt;__crt_alg-&gt;cra_digest.dia_setkey(crypto_tfm_ctx(tfm),
-						     key, keylen, &amp;flags);
+	return tfm-&gt;__crt_alg-&gt;cra_digest.dia_setkey(tfm, key, keylen, &amp;flags);
 }
 
 static void digest(struct crypto_tfm *tfm,
diff --git a/crypto/khazad.c b/crypto/khazad.c
--- a/crypto/khazad.c
+++ b/crypto/khazad.c
@@ -754,10 +754,10 @@ static const u64 c[KHAZAD_ROUNDS + 1] = 
 	0xccc41d14c363da5dULL, 0x5fdc7dcd7f5a6c5cULL, 0xf726ffede89d6f8eULL
 };
 
-static int khazad_setkey(void *ctx_arg, const u8 *in_key,
-                       unsigned int key_len, u32 *flags)
+static int khazad_setkey(struct crypto_tfm *tfm, const u8 *in_key,
+			 unsigned int key_len, u32 *flags)
 {
-	struct khazad_ctx *ctx = ctx_arg;
+	struct khazad_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __be32 *key = (const __be32 *)in_key;
 	int r;
 	const u64 *S = T7;
@@ -841,15 +841,15 @@ static void khazad_crypt(const u64 round
 	*dst = cpu_to_be64(state);
 }
 
-static void khazad_encrypt(void *ctx_arg, u8 *dst, const u8 *src)
+static void khazad_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
-	struct khazad_ctx *ctx = ctx_arg;
+	struct khazad_ctx *ctx = crypto_tfm_ctx(tfm);
 	khazad_crypt(ctx-&gt;E, dst, src);
 }
 
-static void khazad_decrypt(void *ctx_arg, u8 *dst, const u8 *src)
+static void khazad_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
-	struct khazad_ctx *ctx = ctx_arg;
+	struct khazad_ctx *ctx = crypto_tfm_ctx(tfm);
 	khazad_crypt(ctx-&gt;D, dst, src);
 }
 
diff --git a/crypto/md4.c b/crypto/md4.c
--- a/crypto/md4.c
+++ b/crypto/md4.c
@@ -152,9 +152,9 @@ static inline void md4_transform_helper(
 	md4_transform(ctx-&gt;hash, ctx-&gt;block);
 }
 
-static void md4_init(void *ctx)
+static void md4_init(struct crypto_tfm *tfm)
 {
-	struct md4_ctx *mctx = ctx;
+	struct md4_ctx *mctx = crypto_tfm_ctx(tfm);
 
 	mctx-&gt;hash[0] = 0x67452301;
 	mctx-&gt;hash[1] = 0xefcdab89;
@@ -163,9 +163,9 @@ static void md4_init(void *ctx)
 	mctx-&gt;byte_count = 0;
 }
 
-static void md4_update(void *ctx, const u8 *data, unsigned int len)
+static void md4_update(struct crypto_tfm *tfm, const u8 *data, unsigned int len)
 {
-	struct md4_ctx *mctx = ctx;
+	struct md4_ctx *mctx = crypto_tfm_ctx(tfm);
 	const u32 avail = sizeof(mctx-&gt;block) - (mctx-&gt;byte_count &amp; 0x3f);
 
 	mctx-&gt;byte_count += len;
@@ -193,9 +193,9 @@ static void md4_update(void *ctx, const 
 	memcpy(mctx-&gt;block, data, len);
 }
 
-static void md4_final(void *ctx, u8 *out)
+static void md4_final(struct crypto_tfm *tfm, u8 *out)
 {
-	struct md4_ctx *mctx = ctx;
+	struct md4_ctx *mctx = crypto_tfm_ctx(tfm);
 	const unsigned int offset = mctx-&gt;byte_count &amp; 0x3f;
 	char *p = (char *)mctx-&gt;block + offset;
 	int padding = 56 - (offset + 1);
diff --git a/crypto/md5.c b/crypto/md5.c
--- a/crypto/md5.c
+++ b/crypto/md5.c
@@ -147,9 +147,9 @@ static inline void md5_transform_helper(
 	md5_transform(ctx-&gt;hash, ctx-&gt;block);
 }
 
-static void md5_init(void *ctx)
+static void md5_init(struct crypto_tfm *tfm)
 {
-	struct md5_ctx *mctx = ctx;
+	struct md5_ctx *mctx = crypto_tfm_ctx(tfm);
 
 	mctx-&gt;hash[0] = 0x67452301;
 	mctx-&gt;hash[1] = 0xefcdab89;
@@ -158,9 +158,9 @@ static void md5_init(void *ctx)
 	mctx-&gt;byte_count = 0;
 }
 
-static void md5_update(void *ctx, const u8 *data, unsigned int len)
+static void md5_update(struct crypto_tfm *tfm, const u8 *data, unsigned int len)
 {
-	struct md5_ctx *mctx = ctx;
+	struct md5_ctx *mctx = crypto_tfm_ctx(tfm);
 	const u32 avail = sizeof(mctx-&gt;block) - (mctx-&gt;byte_count &amp; 0x3f);
 
 	mctx-&gt;byte_count += len;
@@ -188,9 +188,9 @@ static void md5_update(void *ctx, const 
 	memcpy(mctx-&gt;block, data, len);
 }
 
-static void md5_final(void *ctx, u8 *out)
+static void md5_final(struct crypto_tfm *tfm, u8 *out)
 {
-	struct md5_ctx *mctx = ctx;
+	struct md5_ctx *mctx = crypto_tfm_ctx(tfm);
 	const unsigned int offset = mctx-&gt;byte_count &amp; 0x3f;
 	char *p = (char *)mctx-&gt;block + offset;
 	int padding = 56 - (offset + 1);
diff --git a/crypto/michael_mic.c b/crypto/michael_mic.c
--- a/crypto/michael_mic.c
+++ b/crypto/michael_mic.c
@@ -45,16 +45,17 @@ do {				\
 } while (0)
 
 
-static void michael_init(void *ctx)
+static void michael_init(struct crypto_tfm *tfm)
 {
-	struct michael_mic_ctx *mctx = ctx;
+	struct michael_mic_ctx *mctx = crypto_tfm_ctx(tfm);
 	mctx-&gt;pending_len = 0;
 }
 
 
-static void michael_update(void *ctx, const u8 *data, unsigned int len)
+static void michael_update(struct crypto_tfm *tfm, const u8 *data,
+			   unsigned int len)
 {
-	struct michael_mic_ctx *mctx = ctx;
+	struct michael_mic_ctx *mctx = crypto_tfm_ctx(tfm);
 	const __le32 *src;
 
 	if (mctx-&gt;pending_len) {
@@ -90,9 +91,9 @@ static void michael_update(void *ctx, co
 }
 
 
-static void michael_final(void *ctx, u8 *out)
+static void michael_final(struct crypto_tfm *tfm, u8 *out)
 {
-	struct michael_mic_ctx *mctx = ctx;
+	struct michael_mic_ctx *mctx = crypto_tfm_ctx(tfm);
 	u8 *data = mctx-&gt;pending;
 	__le32 *dst = (__le32 *)out;
 
@@ -121,10 +122,10 @@ static void michael_final(void *ctx, u8 
 }
 
 
-static int michael_setkey(void *ctx, const u8 *key, unsigned int keylen,
-			  u32 *flags)
+static int michael_setkey(struct crypto_tfm *tfm, const u8 *key,
+			  unsigned int keylen, u32 *flags)
 {
-	struct michael_mic_ctx *mctx = ctx;
+	struct michael_mic_ctx *mctx = crypto_tfm_ctx(tfm);
 	const __le32 *data = (const __le32 *)key;
 
 	if (keylen != 8) {
diff --git a/crypto/serpent.c b/crypto/serpent.c
--- a/crypto/serpent.c
+++ b/crypto/serpent.c
@@ -215,9 +215,11 @@ struct serpent_ctx {
 };
 
 
-static int serpent_setkey(void *ctx, const u8 *key, unsigned int keylen, u32 *flags)
+static int serpent_setkey(struct crypto_tfm *tfm, const u8 *key,
+			  unsigned int keylen, u32 *flags)
 {
-	u32 *k = ((struct serpent_ctx *)ctx)-&gt;expkey;
+	struct serpent_ctx *ctx = crypto_tfm_ctx(tfm);
+	u32 *k = ctx-&gt;expkey;
 	u8  *k8 = (u8 *)k;
 	u32 r0,r1,r2,r3,r4;
 	int i;
@@ -365,10 +367,11 @@ static int serpent_setkey(void *ctx, con
 	return 0;
 }
 
-static void serpent_encrypt(void *ctx, u8 *dst, const u8 *src)
+static void serpent_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
+	struct serpent_ctx *ctx = crypto_tfm_ctx(tfm);
 	const u32
-		*k = ((struct serpent_ctx *)ctx)-&gt;expkey,
+		*k = ctx-&gt;expkey,
 		*s = (const u32 *)src;
 	u32	*d = (u32 *)dst,
 		r0, r1, r2, r3, r4;
@@ -423,8 +426,9 @@ static void serpent_encrypt(void *ctx, u
 	d[3] = cpu_to_le32(r3);
 }
 
-static void serpent_decrypt(void *ctx, u8 *dst, const u8 *src)
+static void serpent_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
+	struct serpent_ctx *ctx = crypto_tfm_ctx(tfm);
 	const u32
 		*k = ((struct serpent_ctx *)ctx)-&gt;expkey,
 		*s = (const u32 *)src;
@@ -492,7 +496,8 @@ static struct crypto_alg serpent_alg = {
 	.cia_decrypt  		=	serpent_decrypt } }
 };
 
-static int tnepres_setkey(void *ctx, const u8 *key, unsigned int keylen, u32 *flags)
+static int tnepres_setkey(struct crypto_tfm *tfm, const u8 *key,
+			  unsigned int keylen, u32 *flags)
 {
 	u8 rev_key[SERPENT_MAX_KEY_SIZE];
 	int i;
@@ -506,10 +511,10 @@ static int tnepres_setkey(void *ctx, con
 	for (i = 0; i &lt; keylen; ++i)
 		rev_key[keylen - i - 1] = key[i];
  
-	return serpent_setkey(ctx, rev_key, keylen, flags);
+	return serpent_setkey(tfm, rev_key, keylen, flags);
 }
 
-static void tnepres_encrypt(void *ctx, u8 *dst, const u8 *src)
+static void tnepres_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
 	const u32 * const s = (const u32 * const)src;
 	u32 * const d = (u32 * const)dst;
@@ -521,7 +526,7 @@ static void tnepres_encrypt(void *ctx, u
 	rs[2] = swab32(s[1]);
 	rs[3] = swab32(s[0]);
 
-	serpent_encrypt(ctx, (u8 *)rd, (u8 *)rs);
+	serpent_encrypt(tfm, (u8 *)rd, (u8 *)rs);
 
 	d[0] = swab32(rd[3]);
 	d[1] = swab32(rd[2]);
@@ -529,7 +534,7 @@ static void tnepres_encrypt(void *ctx, u
 	d[3] = swab32(rd[0]);
 }
 
-static void tnepres_decrypt(void *ctx, u8 *dst, const u8 *src)
+static void tnepres_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
 {
 	const u32 * const s = (const u32 * const)src;
 	u32 * const d = (u32 * const)dst;
@@ -541,7 +546,7 @@ static void tnepres_decrypt(void *ctx, u
 	rs[2] = swab32(s[1]);
 	rs[3] = swab32(s[0]);
 
-	serpent_decrypt(ctx, (u8 *)rd, (u8 *)rs);
+	serpent_decrypt(tfm, (u8 *)rd, (u8 *)rs);
 
 	d[0] = swab32(rd[3]);
 	d[1] = swab32(rd[2]);
diff --git a/crypto/sha1.c b/crypto/sha1.c
--- a/crypto/sha1.c
+++ b/crypto/sha1.c
@@ -34,9 +34,9 @@ struct sha1_ctx {
         u8 buffer[64];
 };
 
-static void sha1_init(void *ctx)
+static void sha1_init(struct crypto_tfm *tfm)
 {
-	struct sha1_ctx *sctx = ctx;
+	struct sha1_ctx *sctx = crypto_tfm_ctx(tfm);
 	static const struct sha1_ctx initstate = {
 	  0,
 	  { 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0 },
@@ -46,9 +46,10 @@ static void sha1_init(void *ctx)
 	*sctx = initstate;
 }
 
-static void sha1_update(void *ctx, const u8 *data, unsigned int len)
+static void sha1_update(struct crypto_tfm *tfm, const u8 *data,
+			unsigned int len)
 {
-	struct sha1_ctx *sctx = ctx;
+	struct sha1_ctx *sctx = crypto_tfm_ctx(tfm);
 	unsigned int partial, done;
 	const u8 *src;
 
@@ -80,9 +81,9 @@ static void sha1_update(void *ctx, const
 
 
 /* Add padding and return the message digest. */
-static void sha1_final(void* ctx, u8 *out)
+static void sha1_final(struct crypto_tfm *tfm, u8 *out)
 {
-	struct sha1_ctx *sctx = ctx;
+	struct sha1_ctx *sctx = crypto_tfm_ctx(tfm);
 	__be32 *dst = (__be32 *)out;
 	u32 i, index, padlen;
 	__be64 bits;
@@ -93,10 +94,10 @@ static void sha1_final(void* ctx, u8 *ou
 	/* Pad out to 56 mod 64 */
 	index = sctx-&gt;count &amp; 0x3f;
 	padlen = (index &lt; 56) ? (56 - index) : ((64+56) - index);
-	sha1_update(sctx, padding, padlen);
+	sha1_update(tfm, padding, padlen);
 
 	/* Append length */
-	sha1_update(sctx, (const u8 *)&amp;bits, sizeof(bits));
+	sha1_update(tfm, (const u8 *)&amp;bits, sizeof(bits));
 
 	/* Store state in digest */
 	for (i = 0; i &lt; 5; i++)
diff --git a/crypto/sha256.c b/crypto/sha256.c
--- a/crypto/sha256.c
+++ b/crypto/sha256.c
@@ -230,9 +230,9 @@ static void sha256_transform(u32 *state,
 	memset(W, 0, 64 * sizeof(u32));
 }
 
-static void sha256_init(void *ctx)
+static void sha256_init(struct crypto_tfm *tfm)
 {
-	struct sha256_ctx *sctx = ctx;
+	struct sha256_ctx *sctx = crypto_tfm_ctx(tfm);
 	sctx-&gt;state[0] = H0;
 	sctx-&gt;state[1] = H1;
 	sctx-&gt;state[2] = H2;
@@ -243,9 +243,10 @@ static void sha256_init(void *ctx)
 	sctx-&gt;state[7] = H7;
 }
 
-static void sha256_update(void *ctx, const u8 *data, unsigned int len)
+static void sha256_update(struct crypto_tfm *tfm, const u8 *data,
+			  unsigned int len)
 {
-	struct sha256_ctx *sctx = ctx;
+	struct sha256_ctx *sctx = crypto_tfm_ctx(tfm);
 	unsigned int i, index, part_len;
 
 	/* Compute number of bytes mod 128 */
@@ -275,9 +276,9 @@ static void sha256_update(void *ctx, con
 	memcpy(&amp;sctx-&gt;buf[index], &amp;data[i], len-i);
 }
 
-static void sha256_final(void* ctx, u8 *out)
+static void sha256_final(struct crypto_tfm *tfm, u8 *out)
 {
-	struct sha256_ctx *sctx = ctx;
+	struct sha256_ctx *sctx = crypto_tfm_ctx(tfm);
 	__be32 *dst = (__be32 *)out;
 	__be32 bits[2];
 	unsigned int index, pad_len;
@@ -291,10 +292,10 @@ static void sha256_final(void* ctx, u8 *
 	/* Pad out to 56 mod 64. */
 	index = (sctx-&gt;count[0] &gt;&gt; 3) &amp; 0x3f;
 	pad_len = (index &lt; 56) ? (56 - index) : ((64+56) - index);
-	sha256_update(sctx, padding, pad_len);
+	sha256_update(tfm, padding, pad_len);
 
 	/* Append length (before padding) */
-	sha256_update(sctx, (const u8 *)bits, sizeof(bits));
+	sha256_update(tfm, (const u8 *)bits, sizeof(bits));
 
 	/* Store state in digest */
 	for (i = 0; i &lt; 8; i++)
diff --git a/crypto/sha512.c b/crypto/sha512.c
--- a/crypto/sha512.c
+++ b/crypto/sha512.c
@@ -161,9 +161,9 @@ sha512_transform(u64 *state, u64 *W, con
 }
 
 static void
-sha512_init(void *ctx)
+sha512_init(struct crypto_tfm *tfm)
 {
-        struct sha512_ctx *sctx = ctx;
+	struct sha512_ctx *sctx = crypto_tfm_ctx(tfm);
 	sctx-&gt;state[0] = H0;
 	sctx-&gt;state[1] = H1;
 	sctx-&gt;state[2] = H2;
@@ -175,9 +175,9 @@ sha512_init(void *ctx)
 }
 
 static void
-sha384_init(void *ctx)
+sha384_init(struct crypto_tfm *tfm)
 {
-        struct sha512_ctx *sctx = ctx;
+	struct sha512_ctx *sctx = crypto_tfm_ctx(tfm);
         sctx-&gt;state[0] = HP0;
         sctx-&gt;state[1] = HP1;
         sctx-&gt;state[2] = HP2;
@@ -189,9 +189,9 @@ sha384_init(void *ctx)
 }
 
 static void
-sha512_update(void *ctx, const u8 *data, unsigned int len)
+sha512_update(struct crypto_tfm *tfm, const u8 *data, unsigned int len)
 {
-        struct sha512_ctx *sctx = ctx;
+	struct sha512_ctx *sctx = crypto_tfm_ctx(tfm);
 
 	unsigned int i, index, part_len;
 
@@ -229,9 +229,9 @@ sha512_update(void *ctx, const u8 *data,
 }
 
 static void
-sha512_final(void *ctx, u8 *hash)
+sha512_final(struct crypto_tfm *tfm, u8 *hash)
 {
-        struct sha512_ctx *sctx = ctx;
+	struct sha512_ctx *sctx = crypto_tfm_ctx(tfm);
         static u8 padding[128] = { 0x80, };
 	__be64 *dst = (__be64 *)hash;
 	__be32 bits[4];
@@ -247,10 +247,10 @@ sha512_final(void *ctx, u8 *hash)
 	/* Pad out to 112 mod 128. */
 	index = (sctx-&gt;count[0] &gt;&gt; 3) &amp; 0x7f;
 	pad_len = (index &lt; 112) ? (112 - index) : ((128+112) - index);
-	sha512_update(sctx, padding, pad_len);
+	sha512_update(tfm, padding, pad_len);
 
 	/* Append length (before padding) */
-	sha512_update(sctx, (const u8 *)bits, sizeof(bits));
+	sha512_update(tfm, (const u8 *)bits, sizeof(bits));
 
 	/* Store state in digest */
 	for (i = 0; i &lt; 8; i++)
@@ -260,12 +260,11 @@ sha512_final(void *ctx, u8 *hash)
 	memset(sctx, 0, sizeof(struct sha512_ctx));
 }
 
-static void sha384_final(void *ctx, u8 *hash)
+static void sha384_final(struct crypto_tfm *tfm, u8 *hash)
 {
-        struct sha512_ctx *sctx = ctx;
         u8 D[64];
 
-        sha512_final(sctx, D);
+	sha512_final(tfm, D);
 
         memcpy(hash, D, 48);
         memset(D, 0, 64);
diff --git a/crypto/tea.c b/crypto/tea.c
--- a/crypto/tea.c
+++ b/crypto/tea.c
@@ -45,10 +45,10 @@ struct xtea_ctx {
 	u32 KEY[4];
 };
 
-static int tea_setkey(void *ctx_arg, const u8 *in_key,
-                       unsigned int key_len, u32 *flags)
-{ 
-	struct tea_ctx *ctx = ctx_arg;
+static int tea_setkey(struct crypto_tfm *tfm, const u8 *in_key,
+		      unsigned int key_len, u32 *flags)
+{
+	struct tea_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *key = (const __le32 *)in_key;
 	
 	if (key_len != 16)
@@ -66,12 +66,11 @@ static int tea_setkey(void *ctx_arg, con
 
 }
 
-static void tea_encrypt(void *ctx_arg, u8 *dst, const u8 *src)
-{ 
+static void tea_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
+{
 	u32 y, z, n, sum = 0;
 	u32 k0, k1, k2, k3;
-
-	struct tea_ctx *ctx = ctx_arg;
+	struct tea_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *in = (const __le32 *)src;
 	__le32 *out = (__le32 *)dst;
 
@@ -95,11 +94,11 @@ static void tea_encrypt(void *ctx_arg, u
 	out[1] = cpu_to_le32(z);
 }
 
-static void tea_decrypt(void *ctx_arg, u8 *dst, const u8 *src)
-{ 
+static void tea_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
+{
 	u32 y, z, n, sum;
 	u32 k0, k1, k2, k3;
-	struct tea_ctx *ctx = ctx_arg;
+	struct tea_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *in = (const __le32 *)src;
 	__le32 *out = (__le32 *)dst;
 
@@ -125,10 +124,10 @@ static void tea_decrypt(void *ctx_arg, u
 	out[1] = cpu_to_le32(z);
 }
 
-static int xtea_setkey(void *ctx_arg, const u8 *in_key,
-                       unsigned int key_len, u32 *flags)
-{ 
-	struct xtea_ctx *ctx = ctx_arg;
+static int xtea_setkey(struct crypto_tfm *tfm, const u8 *in_key,
+		       unsigned int key_len, u32 *flags)
+{
+	struct xtea_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *key = (const __le32 *)in_key;
 	
 	if (key_len != 16)
@@ -146,12 +145,11 @@ static int xtea_setkey(void *ctx_arg, co
 
 }
 
-static void xtea_encrypt(void *ctx_arg, u8 *dst, const u8 *src)
-{ 
+static void xtea_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
+{
 	u32 y, z, sum = 0;
 	u32 limit = XTEA_DELTA * XTEA_ROUNDS;
-
-	struct xtea_ctx *ctx = ctx_arg;
+	struct xtea_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *in = (const __le32 *)src;
 	__le32 *out = (__le32 *)dst;
 
@@ -168,10 +166,10 @@ static void xtea_encrypt(void *ctx_arg, 
 	out[1] = cpu_to_le32(z);
 }
 
-static void xtea_decrypt(void *ctx_arg, u8 *dst, const u8 *src)
-{ 
+static void xtea_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
+{
 	u32 y, z, sum;
-	struct tea_ctx *ctx = ctx_arg;
+	struct tea_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *in = (const __le32 *)src;
 	__le32 *out = (__le32 *)dst;
 
@@ -191,12 +189,11 @@ static void xtea_decrypt(void *ctx_arg, 
 }
 
 
-static void xeta_encrypt(void *ctx_arg, u8 *dst, const u8 *src)
-{ 
+static void xeta_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
+{
 	u32 y, z, sum = 0;
 	u32 limit = XTEA_DELTA * XTEA_ROUNDS;
-
-	struct xtea_ctx *ctx = ctx_arg;
+	struct xtea_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *in = (const __le32 *)src;
 	__le32 *out = (__le32 *)dst;
 
@@ -213,10 +210,10 @@ static void xeta_encrypt(void *ctx_arg, 
 	out[1] = cpu_to_le32(z);
 }
 
-static void xeta_decrypt(void *ctx_arg, u8 *dst, const u8 *src)
-{ 
+static void xeta_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
+{
 	u32 y, z, sum;
-	struct tea_ctx *ctx = ctx_arg;
+	struct tea_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *in = (const __le32 *)src;
 	__le32 *out = (__le32 *)dst;
 
diff --git a/crypto/tgr192.c b/crypto/tgr192.c
--- a/crypto/tgr192.c
+++ b/crypto/tgr192.c
@@ -496,9 +496,9 @@ static void tgr192_transform(struct tgr1
 	tctx-&gt;c = c;
 }
 
-static void tgr192_init(void *ctx)
+static void tgr192_init(struct crypto_tfm *tfm)
 {
-	struct tgr192_ctx *tctx = ctx;
+	struct tgr192_ctx *tctx = crypto_tfm_ctx(tfm);
 
 	tctx-&gt;a = 0x0123456789abcdefULL;
 	tctx-&gt;b = 0xfedcba9876543210ULL;
@@ -508,9 +508,10 @@ static void tgr192_init(void *ctx)
 
 /* Update the message digest with the contents
  * of INBUF with length INLEN. */
-static void tgr192_update(void *ctx, const u8 * inbuf, unsigned int len)
+static void tgr192_update(struct crypto_tfm *tfm, const u8 *inbuf,
+			  unsigned int len)
 {
-	struct tgr192_ctx *tctx = ctx;
+	struct tgr192_ctx *tctx = crypto_tfm_ctx(tfm);
 
 	if (tctx-&gt;count == 64) {	/* flush the buffer */
 		tgr192_transform(tctx, tctx-&gt;hash);
@@ -524,7 +525,7 @@ static void tgr192_update(void *ctx, con
 		for (; len &amp;&amp; tctx-&gt;count &lt; 64; len--) {
 			tctx-&gt;hash[tctx-&gt;count++] = *inbuf++;
 		}
-		tgr192_update(tctx, NULL, 0);
+		tgr192_update(tfm, NULL, 0);
 		if (!len) {
 			return;
 		}
@@ -546,15 +547,15 @@ static void tgr192_update(void *ctx, con
 
 
 /* The routine terminates the computation */
-static void tgr192_final(void *ctx, u8 * out)
+static void tgr192_final(struct crypto_tfm *tfm, u8 * out)
 {
-	struct tgr192_ctx *tctx = ctx;
+	struct tgr192_ctx *tctx = crypto_tfm_ctx(tfm);
 	__be64 *dst = (__be64 *)out;
 	__be64 *be64p;
 	__le32 *le32p;
 	u32 t, msb, lsb;
 
-	tgr192_update(tctx, NULL, 0); /* flush */ ;
+	tgr192_update(tfm, NULL, 0); /* flush */ ;
 
 	msb = 0;
 	t = tctx-&gt;nblocks;
@@ -582,7 +583,7 @@ static void tgr192_final(void *ctx, u8 *
 		while (tctx-&gt;count &lt; 64) {
 			tctx-&gt;hash[tctx-&gt;count++] = 0;
 		}
-		tgr192_update(tctx, NULL, 0); /* flush */ ;
+		tgr192_update(tfm, NULL, 0); /* flush */ ;
 		memset(tctx-&gt;hash, 0, 56);    /* fill next block with zeroes */
 	}
 	/* append the 64 bit count */
@@ -598,22 +599,20 @@ static void tgr192_final(void *ctx, u8 *
 	dst[2] = be64p[2] = cpu_to_be64(tctx-&gt;c);
 }
 
-static void tgr160_final(void *ctx, u8 * out)
+static void tgr160_final(struct crypto_tfm *tfm, u8 * out)
 {
-	struct tgr192_ctx *wctx = ctx;
 	u8 D[64];
 
-	tgr192_final(wctx, D);
+	tgr192_final(tfm, D);
 	memcpy(out, D, TGR160_DIGEST_SIZE);
 	memset(D, 0, TGR192_DIGEST_SIZE);
 }
 
-static void tgr128_final(void *ctx, u8 * out)
+static void tgr128_final(struct crypto_tfm *tfm, u8 * out)
 {
-	struct tgr192_ctx *wctx = ctx;
 	u8 D[64];
 
-	tgr192_final(wctx, D);
+	tgr192_final(tfm, D);
 	memcpy(out, D, TGR128_DIGEST_SIZE);
 	memset(D, 0, TGR192_DIGEST_SIZE);
 }
diff --git a/crypto/twofish.c b/crypto/twofish.c
--- a/crypto/twofish.c
+++ b/crypto/twofish.c
@@ -643,11 +643,11 @@ struct twofish_ctx {
 };
 
 /* Perform the key setup. */
-static int twofish_setkey(void *cx, const u8 *key,
-                          unsigned int key_len, u32 *flags)
+static int twofish_setkey(struct crypto_tfm *tfm, const u8 *key,
+			  unsigned int key_len, u32 *flags)
 {
 	
-	struct twofish_ctx *ctx = cx;
+	struct twofish_ctx *ctx = crypto_tfm_ctx(tfm);
 
 	int i, j, k;
 
@@ -802,9 +802,9 @@ static int twofish_setkey(void *cx, cons
 }
 
 /* Encrypt one block.  in and out may be the same. */
-static void twofish_encrypt(void *cx, u8 *out, const u8 *in)
+static void twofish_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
 {
-	struct twofish_ctx *ctx = cx;
+	struct twofish_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *src = (const __le32 *)in;
 	__le32 *dst = (__le32 *)out;
 
@@ -839,9 +839,9 @@ static void twofish_encrypt(void *cx, u8
 }
 
 /* Decrypt one block.  in and out may be the same. */
-static void twofish_decrypt(void *cx, u8 *out, const u8 *in)
+static void twofish_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
 {
-	struct twofish_ctx *ctx = cx;
+	struct twofish_ctx *ctx = crypto_tfm_ctx(tfm);
 	const __le32 *src = (const __le32 *)in;
 	__le32 *dst = (__le32 *)out;
   
diff --git a/crypto/wp512.c b/crypto/wp512.c
--- a/crypto/wp512.c
+++ b/crypto/wp512.c
@@ -981,14 +981,15 @@ static void wp512_process_buffer(struct 
 
 }
 
-static void wp512_init(void *ctx)
+static void wp512_init(struct crypto_tfm *tfm)
 {
 }
 
-static void wp512_update(void *ctx, const u8 *source, unsigned int len)
+static void wp512_update(struct crypto_tfm *tfm, const u8 *source,
+			 unsigned int len)
 {
 
-	struct wp512_ctx *wctx = ctx;
+	struct wp512_ctx *wctx = crypto_tfm_ctx(tfm);
 	int sourcePos    = 0;
 	unsigned int bits_len = len * 8; // convert to number of bits
 	int sourceGap    = (8 - ((int)bits_len &amp; 7)) &amp; 7;
@@ -1046,9 +1047,9 @@ static void wp512_update(void *ctx, cons
 
 }
 
-static void wp512_final(void *ctx, u8 *out)
+static void wp512_final(struct crypto_tfm *tfm, u8 *out)
 {
-	struct wp512_ctx *wctx = ctx;
+	struct wp512_ctx *wctx = crypto_tfm_ctx(tfm);
 	int i;
    	u8 *buffer      = wctx-&gt;buffer;
    	u8 *bitLength   = wctx-&gt;bitLength;
@@ -1079,22 +1080,20 @@ static void wp512_final(void *ctx, u8 *o
    	wctx-&gt;bufferPos    = bufferPos;
 }
 
-static void wp384_final(void *ctx, u8 *out)
+static void wp384_final(struct crypto_tfm *tfm, u8 *out)
 {
-	struct wp512_ctx *wctx = ctx;
 	u8 D[64];
 
-	wp512_final (wctx, D);
+	wp512_final(tfm, D);
 	memcpy (out, D, WP384_DIGEST_SIZE);
 	memset (D, 0, WP512_DIGEST_SIZE);
 }
 
-static void wp256_final(void *ctx, u8 *out)
+static void wp256_final(struct crypto_tfm *tfm, u8 *out)
 {
-	struct wp512_ctx *wctx = ctx;
 	u8 D[64];
 
-	wp512_final (wctx, D);
+	wp512_final(tfm, D);
 	memcpy (out, D, WP256_DIGEST_SIZE);
 	memset (D, 0, WP512_DIGEST_SIZE);
 }
diff --git a/drivers/crypto/padlock-aes.c b/drivers/crypto/padlock-aes.c
--- a/drivers/crypto/padlock-aes.c
+++ b/drivers/crypto/padlock-aes.c
@@ -282,19 +282,20 @@ aes_hw_extkey_available(uint8_t key_len)
 	return 0;
 }
 
-static inline struct aes_ctx *aes_ctx(void *ctx)
+static inline struct aes_ctx *aes_ctx(struct crypto_tfm *tfm)
 {
+	unsigned long addr = (unsigned long)crypto_tfm_ctx(tfm);
 	unsigned long align = PADLOCK_ALIGNMENT;
 
 	if (align &lt;= crypto_tfm_ctx_alignment())
 		align = 1;
-	return (struct aes_ctx *)ALIGN((unsigned long)ctx, align);
+	return (struct aes_ctx *)ALIGN(addr, align);
 }
 
-static int
-aes_set_key(void *ctx_arg, const uint8_t *in_key, unsigned int key_len, uint32_t *flags)
+static int aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,
+		       unsigned int key_len, u32 *flags)
 {
-	struct aes_ctx *ctx = aes_ctx(ctx_arg);
+	struct aes_ctx *ctx = aes_ctx(tfm);
 	const __le32 *key = (const __le32 *)in_key;
 	uint32_t i, t, u, v, w;
 	uint32_t P[AES_EXTENDED_KEY_SIZE];
@@ -414,24 +415,22 @@ static inline u8 *padlock_xcrypt_cbc(con
 	return iv;
 }
 
-static void
-aes_encrypt(void *ctx_arg, uint8_t *out, const uint8_t *in)
+static void aes_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
 {
-	struct aes_ctx *ctx = aes_ctx(ctx_arg);
+	struct aes_ctx *ctx = aes_ctx(tfm);
 	padlock_xcrypt_ecb(in, out, ctx-&gt;E, &amp;ctx-&gt;cword.encrypt, 1);
 }
 
-static void
-aes_decrypt(void *ctx_arg, uint8_t *out, const uint8_t *in)
+static void aes_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
 {
-	struct aes_ctx *ctx = aes_ctx(ctx_arg);
+	struct aes_ctx *ctx = aes_ctx(tfm);
 	padlock_xcrypt_ecb(in, out, ctx-&gt;D, &amp;ctx-&gt;cword.decrypt, 1);
 }
 
 static unsigned int aes_encrypt_ecb(const struct cipher_desc *desc, u8 *out,
 				    const u8 *in, unsigned int nbytes)
 {
-	struct aes_ctx *ctx = aes_ctx(crypto_tfm_ctx(desc-&gt;tfm));
+	struct aes_ctx *ctx = aes_ctx(desc-&gt;tfm);
 	padlock_xcrypt_ecb(in, out, ctx-&gt;E, &amp;ctx-&gt;cword.encrypt,
 			   nbytes / AES_BLOCK_SIZE);
 	return nbytes &amp; ~(AES_BLOCK_SIZE - 1);
@@ -440,7 +439,7 @@ static unsigned int aes_encrypt_ecb(cons
 static unsigned int aes_decrypt_ecb(const struct cipher_desc *desc, u8 *out,
 				    const u8 *in, unsigned int nbytes)
 {
-	struct aes_ctx *ctx = aes_ctx(crypto_tfm_ctx(desc-&gt;tfm));
+	struct aes_ctx *ctx = aes_ctx(desc-&gt;tfm);
 	padlock_xcrypt_ecb(in, out, ctx-&gt;D, &amp;ctx-&gt;cword.decrypt,
 			   nbytes / AES_BLOCK_SIZE);
 	return nbytes &amp; ~(AES_BLOCK_SIZE - 1);
@@ -449,7 +448,7 @@ static unsigned int aes_decrypt_ecb(cons
 static unsigned int aes_encrypt_cbc(const struct cipher_desc *desc, u8 *out,
 				    const u8 *in, unsigned int nbytes)
 {
-	struct aes_ctx *ctx = aes_ctx(crypto_tfm_ctx(desc-&gt;tfm));
+	struct aes_ctx *ctx = aes_ctx(desc-&gt;tfm);
 	u8 *iv;
 
 	iv = padlock_xcrypt_cbc(in, out, ctx-&gt;E, desc-&gt;info,
@@ -462,7 +461,7 @@ static unsigned int aes_encrypt_cbc(cons
 static unsigned int aes_decrypt_cbc(const struct cipher_desc *desc, u8 *out,
 				    const u8 *in, unsigned int nbytes)
 {
-	struct aes_ctx *ctx = aes_ctx(crypto_tfm_ctx(desc-&gt;tfm));
+	struct aes_ctx *ctx = aes_ctx(desc-&gt;tfm);
 	padlock_xcrypt_cbc(in, out, ctx-&gt;D, desc-&gt;info, &amp;ctx-&gt;cword.decrypt,
 			   nbytes / AES_BLOCK_SIZE);
 	return nbytes &amp; ~(AES_BLOCK_SIZE - 1);
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -67,7 +67,7 @@ struct crypto_tfm;
 
 struct cipher_desc {
 	struct crypto_tfm *tfm;
-	void (*crfn)(void *ctx, u8 *dst, const u8 *src);
+	void (*crfn)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
 	unsigned int (*prfn)(const struct cipher_desc *desc, u8 *dst,
 			     const u8 *src, unsigned int nbytes);
 	void *info;
@@ -80,10 +80,10 @@ struct cipher_desc {
 struct cipher_alg {
 	unsigned int cia_min_keysize;
 	unsigned int cia_max_keysize;
-	int (*cia_setkey)(void *ctx, const u8 *key,
+	int (*cia_setkey)(struct crypto_tfm *tfm, const u8 *key,
 	                  unsigned int keylen, u32 *flags);
-	void (*cia_encrypt)(void *ctx, u8 *dst, const u8 *src);
-	void (*cia_decrypt)(void *ctx, u8 *dst, const u8 *src);
+	void (*cia_encrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
+	void (*cia_decrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
 
 	unsigned int (*cia_encrypt_ecb)(const struct cipher_desc *desc,
 					u8 *dst, const u8 *src,
@@ -101,20 +101,21 @@ struct cipher_alg {
 
 struct digest_alg {
 	unsigned int dia_digestsize;
-	void (*dia_init)(void *ctx);
-	void (*dia_update)(void *ctx, const u8 *data, unsigned int len);
-	void (*dia_final)(void *ctx, u8 *out);
-	int (*dia_setkey)(void *ctx, const u8 *key,
+	void (*dia_init)(struct crypto_tfm *tfm);
+	void (*dia_update)(struct crypto_tfm *tfm, const u8 *data,
+			   unsigned int len);
+	void (*dia_final)(struct crypto_tfm *tfm, u8 *out);
+	int (*dia_setkey)(struct crypto_tfm *tfm, const u8 *key,
 	                  unsigned int keylen, u32 *flags);
 };
 
 struct compress_alg {
-	int (*coa_init)(void *ctx);
-	void (*coa_exit)(void *ctx);
-	int (*coa_compress)(void *ctx, const u8 *src, unsigned int slen,
-	                    u8 *dst, unsigned int *dlen);
-	int (*coa_decompress)(void *ctx, const u8 *src, unsigned int slen,
-	                      u8 *dst, unsigned int *dlen);
+	int (*coa_init)(struct crypto_tfm *tfm);
+	void (*coa_exit)(struct crypto_tfm *tfm);
+	int (*coa_compress)(struct crypto_tfm *tfm, const u8 *src,
+			    unsigned int slen, u8 *dst, unsigned int *dlen);
+	int (*coa_decompress)(struct crypto_tfm *tfm, const u8 *src,
+			      unsigned int slen, u8 *dst, unsigned int *dlen);
 };
 
 #define cra_cipher	cra_u.cipher

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060516115212</emailId><senderName>Joachim Fritschi</senderName><senderEmail>jfritschi@freenet.de</senderEmail><timestampReceived>2006-05-16 11:52:12-0400</timestampReceived><subject>Re: [RFC][PATCH 1/2] Twofish cipher i586-asm optimized</subject><body>

On Tuesday 16 May 2006 09:44, Herbert Xu wrote:
&gt; On Sun, May 07, 2006 at 08:47:46PM +0000, Joachim Fritschi wrote:
&gt; &gt; After going over my patch again, i realized i missed the .cra_priority
&gt; &gt; and .cra_driver_name setting in the crypto api struct. Here is an updated
&gt; &gt; version of my patch:
&gt; &gt;
&gt; &gt; http://homepages.tu-darmstadt.de/~fritschi/twofish/twofish-i586-asm-2.6.1
&gt; &gt;7-2.diff
&gt;
&gt; Thanks for doing this Joachim.  I like the result.
&gt;
&gt; But the duplicate key code is a bit too much.  The fact that AES does
&gt; it should only serve as a reminder for us to fix it, not to create even
&gt; more duplication.
&gt;
&gt; So could you please move the key generation code into a separate file,
&gt; say crypto/twofish-common.c which can then be shared by all twofish
&gt; implementations?
Sure, i will resubmit the patches in a few days.
&gt;
&gt; BTW, please include the actual patches the next time you submit them
&gt; along with Signed-off-by lines.  You should consult the file
&gt; Documentation/SubmittingPatches for detailed instructions.
Seems like i referred to the wrong documentation then. I read the faq on 
kernel.org ( http://www.kernel.org/pub/linux/docs/lkml/#s4-1 ) and tried to 
follow the instructions :/. Sorry about that.

Regards,
Joachim
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060516121614</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-16 12:16:14-0400</timestampReceived><subject>[CRYPTO] digest: Remove unnecessary zeroing during init</subject><body>

On Tue, May 16, 2006 at 09:41:28PM +1000, herbert wrote:
&gt; 
&gt; The context area is already zeroed by crypto_alloc_tfm so there is no
&gt; need for individual algorithms to zero it in their init functions.

Actually this patch is bogus.  We want things to continue to work when
the user aborts a digest operation by calling init again.  So we need
to initialise the context so that we have a clean slate.


Various digest algorithms operate one block at a time and therefore
keep a temporary buffer of partial blocks.  This buffer does not need
to be initialised since there is a counter which indicates what is and
isn't valid in it.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt

["p1.patch" (text/plain)]

diff --git a/arch/s390/crypto/sha1_s390.c b/arch/s390/crypto/sha1_s390.c
--- a/arch/s390/crypto/sha1_s390.c
+++ b/arch/s390/crypto/sha1_s390.c
@@ -40,19 +40,20 @@ struct crypt_s390_sha1_ctx {
 	u8 buffer[2 * SHA1_BLOCK_SIZE];
 };
 
-static void
-sha1_init(void *ctx)
+static void sha1_init(void *ctx_arg) 
 {
-	static const struct crypt_s390_sha1_ctx initstate = {
-		.state = {
-			0x67452301,
-			0xEFCDAB89,
-			0x98BADCFE,
-			0x10325476,
-			0xC3D2E1F0
-		},
+	struct crypt_s390_sha1_ctx *ctx = ctx_arg;
+	static const u32 initstate[5] = {
+		0x67452301,
+		0xEFCDAB89,
+		0x98BADCFE,
+		0x10325476,
+		0xC3D2E1F0
 	};
-	memcpy(ctx, &amp;initstate, sizeof(initstate));
+
+	ctx-&gt;count = 0;
+	memcpy(ctx-&gt;state, &amp;initstate, sizeof(initstate));
+	ctx-&gt;buf_len = 0;
 }
 
 static void
diff --git a/arch/s390/crypto/sha256_s390.c b/arch/s390/crypto/sha256_s390.c
--- a/arch/s390/crypto/sha256_s390.c
+++ b/arch/s390/crypto/sha256_s390.c
@@ -44,7 +44,6 @@ static void sha256_init(void *ctx)
 	sctx-&gt;state[6] = 0x1f83d9ab;
 	sctx-&gt;state[7] = 0x5be0cd19;
 	sctx-&gt;count = 0;
-	memset(sctx-&gt;buf, 0, sizeof(sctx-&gt;buf));
 }
 
 static void sha256_update(void *ctx, const u8 *data, unsigned int len)
diff --git a/crypto/sha256.c b/crypto/sha256.c
--- a/crypto/sha256.c
+++ b/crypto/sha256.c
@@ -242,7 +242,6 @@ static void sha256_init(void *ctx)
 	sctx-&gt;state[6] = H6;
 	sctx-&gt;state[7] = H7;
 	sctx-&gt;count[0] = sctx-&gt;count[1] = 0;
-	memset(sctx-&gt;buf, 0, sizeof(sctx-&gt;buf));
 }
 
 static void sha256_update(void *ctx, const u8 *data, unsigned int len)
diff --git a/crypto/sha512.c b/crypto/sha512.c
--- a/crypto/sha512.c
+++ b/crypto/sha512.c
@@ -173,7 +173,6 @@ sha512_init(void *ctx)
 	sctx-&gt;state[6] = H6;
 	sctx-&gt;state[7] = H7;
 	sctx-&gt;count[0] = sctx-&gt;count[1] = sctx-&gt;count[2] = sctx-&gt;count[3] = 0;
-	memset(sctx-&gt;buf, 0, sizeof(sctx-&gt;buf));
 }
 
 static void
@@ -189,7 +188,6 @@ sha384_init(void *ctx)
         sctx-&gt;state[6] = HP6;
         sctx-&gt;state[7] = HP7;
         sctx-&gt;count[0] = sctx-&gt;count[1] = sctx-&gt;count[2] = sctx-&gt;count[3] = 0;
-        memset(sctx-&gt;buf, 0, sizeof(sctx-&gt;buf));
 }
 
 static void
diff --git a/crypto/tgr192.c b/crypto/tgr192.c
--- a/crypto/tgr192.c
+++ b/crypto/tgr192.c
@@ -500,7 +500,6 @@ static void tgr192_init(void *ctx)
 {
 	struct tgr192_ctx *tctx = ctx;
 
-	memset (tctx-&gt;hash, 0, 64);
 	tctx-&gt;a = 0x0123456789abcdefULL;
 	tctx-&gt;b = 0xfedcba9876543210ULL;
 	tctx-&gt;c = 0xf096a5b4c3b2e187ULL;

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060516122302</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-16 12:23:02-0400</timestampReceived><subject>[CRYPTO] padlock: Rearrange context structure to reduce code size</subject><body>

Hi:

i386 assembly has more compact instructions for accessing 7-bit offsets.
So by moving the large members to the end of the structure we can save
quite a bit of code size.  This patch shaves about 10% or 300 bytes off
the padlock-aes file.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt

["p1.patch" (text/plain)]

diff --git a/drivers/crypto/padlock-aes.c b/drivers/crypto/padlock-aes.c
--- a/drivers/crypto/padlock-aes.c
+++ b/drivers/crypto/padlock-aes.c
@@ -60,15 +60,14 @@
 #define AES_EXTENDED_KEY_SIZE_B	(AES_EXTENDED_KEY_SIZE * sizeof(uint32_t))
 
 struct aes_ctx {
-	uint32_t e_data[AES_EXTENDED_KEY_SIZE];
-	uint32_t d_data[AES_EXTENDED_KEY_SIZE];
 	struct {
 		struct cword encrypt;
 		struct cword decrypt;
 	} cword;
-	uint32_t *E;
-	uint32_t *D;
+	u32 *D;
 	int key_length;
+	u32 E[AES_EXTENDED_KEY_SIZE];
+	u32 d_data[AES_EXTENDED_KEY_SIZE];
 };
 
 /* ====== Key management routines ====== */
@@ -313,8 +312,7 @@ static int aes_set_key(struct crypto_tfm
 	 * itself we must supply the plain key for both encryption
 	 * and decryption.
 	 */
-	ctx-&gt;E = ctx-&gt;e_data;
-	ctx-&gt;D = ctx-&gt;e_data;
+	ctx-&gt;D = ctx-&gt;E;
 
 	E_KEY[0] = le32_to_cpu(key[0]);
 	E_KEY[1] = le32_to_cpu(key[1]);

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060519181439</emailId><senderName>Wolfgang Aigner</senderName><senderEmail>list-linux-crypto@mail2news-gw.secaron.de</senderEmail><timestampReceived>2006-05-19 18:14:39-0400</timestampReceived><subject>Re: How about deniability? (read: http://www.zdnet.co.uk/print/?TYPE=story&amp;AT=39269746-39020330t-100</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Gregor Zattler wrote:
&gt; Hi,
&gt; 
&gt; "Government to force handover of encryption keys"
&gt; http://www.zdnet.co.uk/print/?TYPE=story&amp;AT=39269746-39020330t-10000025c
&gt; 
&gt; does loop-aes provide some kind of deniability?  

No, at the moment not.

There are also a bunch of problems on such a feature if it is used on
loop devices and you don't dictate the filesystem.


&gt; Does any other free crypto system?

Truecrypt (as mentioned)
Rubberhose
PhoneBook  (FUSE implementation)
StegFS (no development at the moment)
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.2.2 (MingW32)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFEbgsPJ/k3KwFqU/kRAjVVAKCqKb+Nf8uN+V8d6qv9NtCuNUG7DQCgnT2V
A+Srey4D9Fo+irm6WzcqM78=
=gwGa
-----END PGP SIGNATURE-----
-- 
The From: and Reply-To: addresses are internal news2mail gateway addresses.
Reply to the list or to Wolfgang Aigner &lt;aigner@secaron.nospam.de&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060519204735</emailId><senderName></senderName><senderEmail>autoreply</senderEmail><timestampReceived>2006-05-19 20:47:35-0400</timestampReceived><subject>AutoReply from FTPPro.com</subject><body>

You sent a message to an FTPPro.com email address that has been changed.

Please re-send your email to the following address:
    ss {AT} ftppro.com
(replace {AT} with the "@" symbol, and remove the blank spaces)

Thank you,

FTPPro.com

p.s. Replies to the "AutoReply" email address will not be read.

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060520045010</emailId><senderName>Info</senderName><senderEmail>info@acculin.com</senderEmail><timestampReceived>2006-05-20 04:50:10-0400</timestampReceived><subject>Re: How about deniability? (read:</subject><body>

Jari Ruusu wrote:
&gt; Gregor Zattler wrote:
&gt;   
&gt;&gt; does loop-aes provide some kind of deniability?
&gt;&gt;     
&gt;
&gt; Yes, if you set it up that way. For example, if you set up a computer to
&gt; first try to boot from USB-stick, and then to try hard disk boot.
&gt;
&gt; disk partition  Normal boot usage             Forced key handover boot usage
&gt; ~~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~~             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
&gt; /dev/hda1       not used                      unencrypted /boot
&gt; /dev/hda2       not used                      encrypted root
&gt; /dev/hda3       encrypted swap, random keys   encrypted swap, random keys
&gt; /dev/hda4       encrypted root                encrypted /tmp, random keys
&gt;
&gt; USB-stick       Normal boot usage             Forced key handover boot usage
&gt; ~~~~~~~~~       ~~~~~~~~~~~~~~~~~             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
&gt; /dev/sda        unencrypted /boot             not used
&gt;
&gt; You install some small distro on /dev/hda2, and never put any secret data
&gt; there. You install your normal distro on /dev/hda4, and put your secret data
&gt; there.
&gt;
&gt; On normal usage, you always boot your computer from USB-stick to encrypted
&gt; root on /dev/hda4. Key files used for encrypting /dev/hda4 and /dev/hda2 are
&gt; different, and use different gpg passphrases. If you accidentally try to
&gt; boot from hard disk, you never enter the 'key handover' passphrase. When you
&gt; are forced to reveal the 'key handover' passphrase, your computer boots to
&gt; encrypted root on /dev/hda2. You can do that only *once*, because according
&gt; to /etc/fstab on /dev/hda2 root partition, mount sets up random loop
&gt; encryption keys on /dev/hda4, and runs 'mkfs' on /dev/hda4, effectively
&gt; overwriting file system structure there. After one such 'key handover' boot,
&gt; even when used with correct key file and passphrase from your USB-stick, you
&gt; or anyone else, have significant difficulties recovering data from
&gt; /dev/hda4.
&gt;
&gt;   
Although I will agree that this provides a great deal of security for 
the data I don't think
that it provides 'deniability'. In particular if the attack consists of 
physical possession of the
computer and an analysis of the disk drive content without the attempt 
to boot it, and even
more so if the usb key is available to the attacker.

Truecrypt does provide some degree of deniability, although you have 
clearly demonstrated
previously its vulnerability to watermark attacks (which somewhat 
diminishes the deniability).



-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060520185431</emailId><senderName>Thomas Weinbrenner</senderName><senderEmail>thomas@thomas-weinbrenner.de</senderEmail><timestampReceived>2006-05-20 18:54:31-0400</timestampReceived><subject>Re: How about deniability? (read:http://www.zdnet.co.uk/print/?TYPE=story&amp;AT=39269746-39020330t-1000</subject><body>

Michael Garibaldi wrote:
&gt; Obviously the police are not going to find one's USB stick on the
&gt; computer, when one is not home. The stick is ONLY used for booting and
&gt; then carefully hidden. It does not matter if the "self destruct" works
&gt; or not, what matters is that there is absolutely no reason to even
&gt; suspect that a different kind of encryption is being used on the
&gt; system. It boots from the HDD and uses all the available space, and
&gt; the police will get the key that will unlock
&gt; the fake system, and that's it. As long as the USB stick is kept safe
&gt; (which should be trivial to do), they have absolutely nothing to even
&gt; suggest there being a parallel system encrypted with other keys. 

The timestamps will show that the files weren't accessed for months or
even years. And there are also all those logfiles in /var/log which
include dates. I think there will be enough proof that the system wasn't
can't be the system you are normally using.

-- 
Thomas Weinbrenner

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060521223049</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-21 22:30:49-0400</timestampReceived><subject>Re: [CRYPTO] Pass TFM instead of context into digest algos' final() method</subject><body>

On Mon, May 22, 2006 at 09:57:15AM +1200, Michal Ludvig wrote:
&gt; 
&gt; Attached.

Patch applied.  Thanks a lot.
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060522034113</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-05-22 03:41:13-0400</timestampReceived><subject>Re: Add missing accessors for new crypto_alg fields.</subject><body>

Herbert Xu wrote:
&gt; On Mon, May 22, 2006 at 03:10:38PM +1200, Michal Ludvig wrote:
&gt;&gt; Well, not personally, but padlock-sha will.
&gt; 
&gt; How is it going to use these accessors? I'd like to see some code :)

The driver_name accessor is used "seriously". The priority accessor is
just in one info printk() so it isn't necessary.

&gt;&gt; BTW in padlock fallback path I need to make scatterlist from const char*
&gt;&gt; buffer. However the macros in scatterlist.h take non-const void*.
&gt;&gt; Should I
&gt;&gt; 1) make them const (works for me and I'm not getting any compilation
&gt;&gt; warnings from other modules).
&gt;&gt; 2) make my local copy of sg_set_buf() with const void parameter
&gt;&gt; 3) let gcc keep complaining
&gt; 
&gt; Please show me the code that causes this problem.

See my other e-mail with the patch. sg_set_buf() in padlock_sha_update()
causes the gcc warning.

Michal
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060523201835</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-05-23 20:18:35-0400</timestampReceived><subject>Re: Re: Remove encryption from kernel?</subject><body>

On Tue, May 23, 2006 at 08:37:07PM +0200, The Hog (thehog@t3i.nl) wrote:
&gt; &gt; &gt; Would it be possible to build a kernel that does not contain cryptographic
&gt; &gt; &gt; algorithms? I understand that several cryptographic options can be
&gt; disabled
&gt; &gt; &gt; through "make menuconfig". But, will that be enough or are there crypto
&gt; &gt; &gt; routines in the kernel that cannot be removed?
&gt; &gt; 
&gt; &gt; Disable NET and block layer to be able to disable cryptoapi.
&gt; &gt; It can be more fine grained though.
&gt; 
&gt; What in the Block layer (support for large block devices and IO schedulers)
&gt; contains crypto?

dm-crypt which is enabled in device drivers -&gt; multiple devices and LVM.

&gt; I assume that only the IPSec related options in the NET layer use crypto?
&gt; Otherwise, this would result in a kernel w/o networking support...

AFAIR, IPv6 and wifi stack need crypto.

&gt; &gt; &gt; Note that disabling cryptographic functionality is not enough, the
&gt; &gt; &gt; cryptographic code may not be compiled and linked into the binary kernel
&gt; &gt; &gt; image at all. Nor may any cryptographic library, kernel or user module
&gt; &gt; &gt; contain cryptographic functionality.
&gt; &gt; 
&gt; &gt; Can rot13 algo and userspace utility be considered as "cryptographic
&gt; &gt; library, kernel or user module"?
&gt; 
&gt; I don't know if rot13 is considered cryptographic. Does the kernel implement
&gt; rot13?

Kernel does not, but it is popular userspace utility, even if it
contains some cryptographic weaknesses.

&gt; I am assuming that all crypto algo's are implemented as separate module(s)
&gt; which can be left out. Am I correct, or are there modules (e.g. device
&gt; drivers) that  implement crypto algo's locally? In other words: how
&gt; monolithic (or spaghetti) is the kernel when it comes to cryptographic
&gt; functions?

If you turn crypto api off, then no moule supporting crypto api can be
loaded. But I can create my own which will encrypt/decrypt block layer
for several hours. Similar things can be done for network traffic.
And I bet Iran hackers can do it too.

&gt; theHog

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060524030900</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-24 03:09:00-0400</timestampReceived><subject>[1/3] [CRYPTO] api: Added cra_init/cra_exit</subject><body>

Hi:

[CRYPTO] api: Added cra_init/cra_exit

This patch adds the hooks cra_init/cra_exit which are called during a tfm's
construction and destruction respectively.  This will be used by the instances
to allocate child tfm's.

For now this lets us get rid of the coa_init/coa_exit functions which are
used for exactly that purpose (unlike the dia_init function which is called
for each transaction).

In fact the coa_exit path is currently buggy as it may get called twice
when an error is encountered during initialisation.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt

["p1.patch" (text/plain)]

diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -188,13 +188,16 @@ struct crypto_tfm *crypto_alloc_tfm(cons
 	if (crypto_init_flags(tfm, flags))
 		goto out_free_tfm;
 		
-	if (crypto_init_ops(tfm)) {
-		crypto_exit_ops(tfm);
+	if (crypto_init_ops(tfm))
 		goto out_free_tfm;
-	}
+
+	if (alg-&gt;cra_init &amp;&amp; alg-&gt;cra_init(tfm))
+		goto cra_init_failed;
 
 	goto out;
 
+cra_init_failed:
+	crypto_exit_ops(tfm);
 out_free_tfm:
 	kfree(tfm);
 	tfm = NULL;
@@ -215,6 +218,8 @@ void crypto_free_tfm(struct crypto_tfm *
 	alg = tfm-&gt;__crt_alg;
 	size = sizeof(*tfm) + alg-&gt;cra_ctxsize;
 
+	if (alg-&gt;cra_exit)
+		alg-&gt;cra_exit(tfm);
 	crypto_exit_ops(tfm);
 	crypto_alg_put(alg);
 	memset(tfm, 0, size);
diff --git a/crypto/compress.c b/crypto/compress.c
--- a/crypto/compress.c
+++ b/crypto/compress.c
@@ -41,21 +41,14 @@ int crypto_init_compress_flags(struct cr
 
 int crypto_init_compress_ops(struct crypto_tfm *tfm)
 {
-	int ret = 0;
 	struct compress_tfm *ops = &amp;tfm-&gt;crt_compress;
-	
-	ret = tfm-&gt;__crt_alg-&gt;cra_compress.coa_init(tfm);
-	if (ret)
-		goto out;
 
 	ops-&gt;cot_compress = crypto_compress;
 	ops-&gt;cot_decompress = crypto_decompress;
 	
-out:
-	return ret;
+	return 0;
 }
 
 void crypto_exit_compress_ops(struct crypto_tfm *tfm)
 {
-	tfm-&gt;__crt_alg-&gt;cra_compress.coa_exit(tfm);
 }
diff --git a/crypto/deflate.c b/crypto/deflate.c
--- a/crypto/deflate.c
+++ b/crypto/deflate.c
@@ -201,9 +201,9 @@ static struct crypto_alg alg = {
 	.cra_ctxsize		= sizeof(struct deflate_ctx),
 	.cra_module		= THIS_MODULE,
 	.cra_list		= LIST_HEAD_INIT(alg.cra_list),
+	.cra_init		= deflate_init,
+	.cra_exit		= deflate_exit,
 	.cra_u			= { .compress = {
-	.coa_init		= deflate_init,
-	.coa_exit		= deflate_exit,
 	.coa_compress 		= deflate_compress,
 	.coa_decompress  	= deflate_decompress } }
 };
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -110,8 +110,6 @@ struct digest_alg {
 };
 
 struct compress_alg {
-	int (*coa_init)(struct crypto_tfm *tfm);
-	void (*coa_exit)(struct crypto_tfm *tfm);
 	int (*coa_compress)(struct crypto_tfm *tfm, const u8 *src,
 			    unsigned int slen, u8 *dst, unsigned int *dlen);
 	int (*coa_decompress)(struct crypto_tfm *tfm, const u8 *src,
@@ -139,6 +137,9 @@ struct crypto_alg {
 		struct digest_alg digest;
 		struct compress_alg compress;
 	} cra_u;
+
+	int (*cra_init)(struct crypto_tfm *tfm);
+	void (*cra_exit)(struct crypto_tfm *tfm);
 	
 	struct module *cra_module;
 };

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060524030938</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-24 03:09:38-0400</timestampReceived><subject>[2/3][CRYPTO] api: Removed const from cra_name/cra_driver_name</subject><body>

Hi:

[CRYPTO] api: Removed const from cra_name/cra_driver_name

We do need to change these names now and even more so in future with
instantiated algorithms.  So let's stop lying to the compiler and get
rid of the const modifiers.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt

["p2.patch" (text/plain)]

diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -229,7 +229,7 @@ void crypto_free_tfm(struct crypto_tfm *
 static inline int crypto_set_driver_name(struct crypto_alg *alg)
 {
 	static const char suffix[] = "-generic";
-	char *driver_name = (char *)alg-&gt;cra_driver_name;
+	char *driver_name = alg-&gt;cra_driver_name;
 	int len;
 
 	if (*driver_name)
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -129,8 +129,8 @@ struct crypto_alg {
 
 	int cra_priority;
 
-	const char cra_name[CRYPTO_MAX_ALG_NAME];
-	const char cra_driver_name[CRYPTO_MAX_ALG_NAME];
+	char cra_name[CRYPTO_MAX_ALG_NAME];
+	char cra_driver_name[CRYPTO_MAX_ALG_NAME];
 
 	union {
 		struct cipher_alg cipher;

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060524031016</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-24 03:10:16-0400</timestampReceived><subject>[3/3] [CRYPTO] api: Allow replacement when registering new algorithms</subject><body>

Hi:

[CRYPTO] api: Allow replacement when registering new algorithms

We already allow asynchronous removal of existing algorithm modules.  By
allowing the replacement of existing algorithms, we can replace algorithms
without having to wait for for all existing users to complete.

Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt

["p3.patch" (text/plain)]

diff --git a/crypto/api.c b/crypto/api.c
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -267,13 +267,13 @@ int crypto_register_alg(struct crypto_al
 	down_write(&amp;crypto_alg_sem);
 	
 	list_for_each_entry(q, &amp;crypto_alg_list, cra_list) {
-		if (!strcmp(q-&gt;cra_driver_name, alg-&gt;cra_driver_name)) {
+		if (q == alg) {
 			ret = -EEXIST;
 			goto out;
 		}
 	}
 	
-	list_add_tail(&amp;alg-&gt;cra_list, &amp;crypto_alg_list);
+	list_add(&amp;alg-&gt;cra_list, &amp;crypto_alg_list);
 out:	
 	up_write(&amp;crypto_alg_sem);
 	return ret;

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060524213107</emailId><senderName>Michal Ludvig</senderName><senderEmail>michal@logix.cz</senderEmail><timestampReceived>2006-05-24 21:31:07-0400</timestampReceived><subject>[CRYPTO] tcrypt: Speed benchmark support for digest algorithms</subject><body>

Hi Herbert,

attached is a patch that adds speed testing for digest algorithms in a
way similar to already existing cipher speed tests. Applies on top of
the "tests by names" patch.

Michal
-- 
* Personal homepage: http://www.logix.cz/michal




["tcrypt-digest-benchmark.diff" (text/x-patch)]

This patch adds speed tests (benchmarks) for digest algorithms.
Tests are run with different buffer sizes (16 bytes, ... 8 kBytes)
and with each buffer multiple tests are run with different update()
sizes (e.g. hash 64 bytes buffer in four 16 byte updates). 
There is no correctness checking of the result and all tests and 
algorithms use the same input buffer. 

Signed-off-by: Michal Ludvig &lt;michal@logix.cz&gt;

Index: linux/crypto/tcrypt.c
===================================================================
--- linux.orig/crypto/tcrypt.c
+++ linux/crypto/tcrypt.c
@@ -630,6 +630,122 @@ out:
 	crypto_free_tfm(tfm);
 }
 
+static void test_digest_jiffies(struct crypto_tfm *tfm, char *p, int blen,
+				int plen, char *out, int sec)
+{
+	struct scatterlist sg[1];
+	unsigned long start, end;
+	int bcount, pcount;
+
+	for (start = jiffies, end = start + sec * HZ, bcount = 0;
+	     time_before(jiffies, end); bcount++) {
+		crypto_digest_init(tfm);
+		for (pcount = 0; pcount &lt; blen; pcount += plen) {
+			sg_set_buf(sg, p + pcount, plen);
+			crypto_digest_update(tfm, sg, 1);
+		}
+		/* we assume there is enough space in 'out' for the result */
+		crypto_digest_final(tfm, out);
+	}
+
+	printk("% 8u opers/sec, % 8lu bytes/sec\n",
+	       bcount/sec, ((long)bcount * blen)/sec);
+
+	return;
+}
+
+static void test_digest_cycles(struct crypto_tfm *tfm, char *p, int blen,
+			       int plen, char *out)
+{
+	struct scatterlist sg[1];
+	unsigned long cycles = 0;
+	int i, pcount;
+
+	local_bh_disable();
+	local_irq_disable();
+
+	/* Warm-up run. */
+	for (i = 0; i &lt; 4; i++) {
+		crypto_digest_init(tfm);
+		for (pcount = 0; pcount &lt; blen; pcount += plen) {
+			sg_set_buf(sg, p + pcount, plen);
+			crypto_digest_update(tfm, sg, 1);
+		}
+		crypto_digest_final(tfm, out);
+	}
+
+	/* The real thing. */
+	for (i = 0; i &lt; 8; i++) {
+		cycles_t start, end;
+
+		crypto_digest_init(tfm);
+
+		start = get_cycles();
+
+		for (pcount = 0; pcount &lt; blen; pcount += plen) {
+			sg_set_buf(sg, p + pcount, plen);
+			crypto_digest_update(tfm, sg, 1);
+		}
+		crypto_digest_final(tfm, out);
+
+		end = get_cycles();
+
+		cycles += end - start;
+	}
+
+	local_irq_enable();
+	local_bh_enable();
+
+	printk("%lu cycles/operation, %lu cycles/byte\n",
+	       cycles / 8, cycles / (8 * blen));
+
+	return;
+}
+
+static void test_digest_speed(char *algo, unsigned int sec,
+			      struct digest_speed *speed)
+{
+	struct crypto_tfm *tfm;
+	char output[1024];
+	int i;
+
+	printk("\ntesting speed of %s\n", algo);
+
+	tfm = crypto_alloc_tfm(algo, 0);
+
+	if (tfm == NULL) {
+		printk("failed to load transform for %s\n", algo);
+		return;
+	}
+
+	if (crypto_tfm_alg_digestsize(tfm) &gt; sizeof(output)) {
+		printk("digestsize(%u) &gt; outputbuffer(%zu)\n",
+		       crypto_tfm_alg_digestsize(tfm), sizeof(output));
+		goto out;
+	}
+
+	for (i = 0; speed[i].blen != 0; i++) {
+		if (speed[i].blen &gt; TVMEMSIZE) {
+			printk("template (%u) too big for tvmem (%u)\n",
+			       speed[i].blen, TVMEMSIZE);
+			goto out;
+		}
+
+		printk("test% 3u (% 5u byte blocks,% 5u bytes per update,% 4u updates): ",
+		       i, speed[i].blen, speed[i].plen, speed[i].blen / speed[i].plen);
+
+		memset(tvmem, 0xff, speed[i].blen);
+
+		if (sec)
+			test_digest_jiffies(tfm, tvmem, speed[i].blen, speed[i].plen, output, sec);
+		else
+			test_digest_cycles(tfm, tvmem, speed[i].blen, speed[i].plen, output);
+	}
+
+out:
+	crypto_free_tfm(tfm);
+}
+
 static void test_deflate(void)
 {
 	unsigned int i;
@@ -1069,6 +1185,54 @@ static void do_test(void)
 				  des_speed_template);
 		if (mode_speed != ALG_ALL) break;
 
+	case ALG_MD4:
+		test_digest_speed("md4", sec, generic_digest_speed_template);
+		if (mode_speed != ALG_ALL) break;
+
+	case ALG_MD5:
+		test_digest_speed("md5", sec, generic_digest_speed_template);
+		if (mode_speed != ALG_ALL) break;
+
+	case ALG_SHA1:
+		test_digest_speed("sha1", sec, generic_digest_speed_template);
+		if (mode_speed != ALG_ALL) break;
+
+	case ALG_SHA256:
+		test_digest_speed("sha256", sec, generic_digest_speed_template);
+		if (mode_speed != ALG_ALL) break;
+
+	case ALG_SHA384:
+		test_digest_speed("sha384", sec, generic_digest_speed_template);
+		if (mode_speed != ALG_ALL) break;
+
+	case ALG_SHA512:
+		test_digest_speed("sha512", sec, generic_digest_speed_template);
+		if (mode_speed != ALG_ALL) break;
+
+	case ALG_WP256:
+		test_digest_speed("wp256", sec, generic_digest_speed_template);
+		if (mode_speed != ALG_ALL) break;
+
+	case ALG_WP384:
+		test_digest_speed("wp384", sec, generic_digest_speed_template);
+		if (mode_speed != ALG_ALL) break;
+
+	case ALG_WP512:
+		test_digest_speed("wp512", sec, generic_digest_speed_template);
+		if (mode_speed != ALG_ALL) break;
+
+	case ALG_TGR128:
+		test_digest_speed("tgr128", sec, generic_digest_speed_template);
+		if (mode_speed != ALG_ALL) break;
+
+	case ALG_TGR160:
+		test_digest_speed("tgr160", sec, generic_digest_speed_template);
+		if (mode_speed != ALG_ALL) break;
+
+	case ALG_TGR192:
+		test_digest_speed("tgr192", sec, generic_digest_speed_template);
+		if (mode_speed != ALG_ALL) break;
+
 	default:
 		if (mode_speed != ALG_ALL)
 			printk("Speed test for '%s' not implemented.\n", name_speed);
Index: linux/crypto/tcrypt.h
===================================================================
--- linux.orig/crypto/tcrypt.h
+++ linux/crypto/tcrypt.h
@@ -106,6 +106,11 @@ struct cipher_speed {
 	unsigned int blen;
 };
 
+struct digest_speed {
+	unsigned int blen;	/* buffer length */
+	unsigned int plen;	/* per-update length */
+};
+
 /*
  * MD4 test vectors from RFC1320
  */
@@ -3016,4 +3021,35 @@ static struct cipher_speed des_speed_tem
 	{  .klen = 0, .blen = 0, }
 };
 
+/*
+ * Digest speed tests
+ */
+static struct digest_speed generic_digest_speed_template[] = {
+	{ .blen = 16, 	.plen = 16, },
+	{ .blen = 64,	.plen = 16, },
+	{ .blen = 64,	.plen = 64, },
+	{ .blen = 256,	.plen = 16, },
+	{ .blen = 256,	.plen = 64, },
+	{ .blen = 256,	.plen = 256, },
+	{ .blen = 1024,	.plen = 16, },
+	{ .blen = 1024,	.plen = 256, },
+	{ .blen = 1024,	.plen = 1024, },
+	{ .blen = 2048,	.plen = 16, },
+	{ .blen = 2048,	.plen = 256, },
+	{ .blen = 2048,	.plen = 1024, },
+	{ .blen = 2048,	.plen = 2048, },
+	{ .blen = 4096,	.plen = 16, },
+	{ .blen = 4096,	.plen = 256, },
+	{ .blen = 4096,	.plen = 1024, },
+	{ .blen = 4096,	.plen = 4096, },
+	{ .blen = 8192,	.plen = 16, },
+	{ .blen = 8192,	.plen = 256, },
+	{ .blen = 8192,	.plen = 1024, },
+	{ .blen = 8192,	.plen = 4096, },
+	{ .blen = 8192,	.plen = 8192, },
+
+	/* End marker */
+	{  .blen = 0,	.plen = 0, }
+};
+
 #endif	/* _CRYPTO_TCRYPT_H */

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060525000303</emailId><senderName>David McCullough</senderName><senderEmail>david_mccullough@au.securecomputing.com</senderEmail><timestampReceived>2006-05-25 00:03:03-0400</timestampReceived><subject>Re: [ACRYPTO] New asynchronous crypto layer release.</subject><body>


Jivin Evgeniy Polyakov lays it down ...
&gt; On Wed, May 24, 2006 at 09:04:43AM +1000, David McCullough \
&gt; (david_mccullough@au.securecomputing.com) wrote:
&gt; &gt; 
&gt; &gt; Hi Evgeniy,
&gt; 
&gt; Hello David.
&gt; 
&gt; &gt; Just interested in the results you are getting below for
&gt; &gt; comparison to what I see under OCF with Openswan.
&gt; &gt; 
&gt; &gt; What sort of hifn card were you using in the test below,
&gt; &gt; was it a 7956 PCIX (ie., 64bit?)
&gt; &gt; 
&gt; &gt; How did you measure the throughput  ?
&gt; 
&gt; It is racoon transport setup with ESP4 only ecryption with AES-128 CBC
&gt; mode.
&gt; 
&gt; Hardware.
&gt; FC4 vanilla kernel 2.6.16-1.2069_FC4smp runs on P3 3 Ghz with HT
&gt; enabled, 512 Mb of RAM, sk98lin gigabit ethernet.
&gt; Acrypto kernel runs on Xeon 2.4 Ghz with HT enabled with 1Gb of RAM 
&gt; and e1000 gigabit ethernet adapter (in pci-x slot).
&gt; HIFN card is old 7955 (it was quite challenging to bring it to Russia
&gt; when I started acrypto developemnt several years ago, so no new toys) 
&gt; in PCI-X slot.
&gt; When HIFN driver is not loaded, asynchronous SW crypto provider is
&gt; loaded for one processor.
&gt; 
&gt; Benchmark is scp (yes, it encrypt packets too to simulate some real work
&gt; on hosts) of big files over the gigabit link.
&gt; 
&gt; &gt; I can post the OCF numbers,  but it doesn't mean a lot
&gt; &gt; unless it's a fair comparison :-)

Here are the numbers,  although the test is somewhat different,
I have left the full output report from iperf for reference.
Hopefully it's not too hard to find the info in there :-)

Cheers,
Davidm


OCF test results on uniprocessor x86 hardware: 20060512
-------------------------------------------------------

The setup used for these tests follows,  the raw speed of each link
was measured using tcpblast for a rough check before starting.

      A                  B                   C                    D
   2400 AMD  --------  2.4 Xeon  --------  2.8 Xeon  --------  1.0G PentiumII
              890Mbits             940Mbits          940Mbits

System A has a 32bit Intel Gbit NIC,  all the rest have Intel Dual GBit
64bit cards.  B and C have Hifn 7956 64bit cards (max 66MHz bus).  All
systems are uniprocessor without hyperthreading.

Test 1
------

Running iperf tests on system A against system D *WITHOUT* ipsec enabled
gives the following results.

    ./iperf -l 1440 -c 192.168.1.2 -u -b 1500m
    ------------------------------------------------------------
    Client connecting to 192.168.1.2, UDP port 5001
    Sending 1440 byte datagrams
    UDP buffer size:   103 KByte (default)
    ------------------------------------------------------------
    [  5] local 192.168.0.2 port 32799 connected with 192.168.1.2 port 5001
    [  5]  0.0-10.0 sec    932 MBytes    782 Mbits/sec
    [  5] Sent 678574 datagrams
    [  5] Server Report:
    [  5]  0.0-10.0 sec    932 MBytes    786 Mbits/sec  0.025 ms    2/678573 \
(0.00029%)  [  5]  0.0-10.0 sec  1 datagrams received out-of-order

    ./iperf -l 200 -c 192.168.1.2 -u -b 1500m
    ------------------------------------------------------------
    Client connecting to 192.168.1.2, UDP port 5001
    Sending 200 byte datagrams
    UDP buffer size:   103 KByte (default)
    ------------------------------------------------------------
    [  5] local 192.168.0.2 port 32799 connected with 192.168.1.2 port 5001
    [  5]  0.0-10.0 sec    252 MBytes    212 Mbits/sec
    [  5] Sent 1323609 datagrams
    [  5] Server Report:
    [  5]  0.0-10.2 sec    113 MBytes  92.7 Mbits/sec  15.141 ms 733256/1323582 (55%)
    [  5]  0.0-10.2 sec  1 datagrams received out-of-order

    ./iperf -l 64 -c 192.168.1.2 -u -b 1500m
    ------------------------------------------------------------
    Client connecting to 192.168.1.2, UDP port 5001
    Sending 64 byte datagrams
    UDP buffer size:   103 KByte (default)
    ------------------------------------------------------------
    [  5] local 192.168.0.2 port 32799 connected with 192.168.1.2 port 5001
    [  5]  0.0-10.0 sec  81.6 MBytes  68.4 Mbits/sec
    [  5] Sent 1336227 datagrams
    [  5] Server Report:
    [  5]  0.0-10.0 sec  72.9 MBytes  61.4 Mbits/sec  0.006 ms 141594/1336226 (11%)
    [  5]  0.0-10.0 sec  1 datagrams received out-of-order


Test 2
------

The following numbers show the results using ipsec WITHOUT the hifn
accelerators.  The configuration is for 3des-sha1-modp1024.  The tests are
using OpenSwan 2.4.5 with the OCF patches but with no hardware acceleration,
just the existing OpenSwan ALG software crypto.

    ./iperf -l 1440 -c 192.168.1.2 -u -b 1500m
    ------------------------------------------------------------
    Client connecting to 192.168.1.2, UDP port 5001
    Sending 1440 byte datagrams
    UDP buffer size:   103 KByte (default)
    ------------------------------------------------------------
    [  5] local 192.168.0.2 port 32799 connected with 192.168.1.2 port 5001
    [  5]  0.0-10.0 sec    787 MBytes    660 Mbits/sec
    [  5] Sent 572731 datagrams
    [  5] Server Report:
    [  5]  0.0-10.2 sec  74.9 MBytes  61.6 Mbits/sec  10.804 ms 518199/572729 (90%)
    [  5]  0.0-10.2 sec  1 datagrams received out-of-order

    ./iperf -l 200 -c 192.168.1.2 -u -b 1500m
    ------------------------------------------------------------
    Client connecting to 192.168.1.2, UDP port 5001
    Sending 200 byte datagrams
    UDP buffer size:   103 KByte (default)
    ------------------------------------------------------------
    [  5] local 192.168.0.2 port 32799 connected with 192.168.1.2 port 5001
    [  5]  0.0-10.0 sec    251 MBytes    211 Mbits/sec
    [  5] Sent 1318167 datagrams
    [  5] Server Report:
    [  5]  0.0-10.2 sec  37.3 MBytes  30.7 Mbits/sec  12.967 ms 1122553/1318163 (85%)
    [  5]  0.0-10.2 sec  1 datagrams received out-of-order

    ./iperf -l 64 -c 192.168.1.2 -u -b 1500m
    ------------------------------------------------------------
    Client connecting to 192.168.1.2, UDP port 5001
    Sending 64 byte datagrams
    UDP buffer size:   103 KByte (default)
    ------------------------------------------------------------
    [  5] local 192.168.0.2 port 32799 connected with 192.168.1.2 port 5001
    [  5]  0.0-10.0 sec  76.9 MBytes  64.5 Mbits/sec
    [  5] Sent 1260384 datagrams
    [  5] Server Report:
    [  5]  0.0-10.0 sec  16.0 MBytes  13.4 Mbits/sec  1.217 ms 997846/1260383 (79%)
    [  5]  0.0-10.0 sec  1 datagrams received out-of-order

Test 3
------

The following numbers show the results using ipsec WITH the hifn7956
accelerators installed in B and C.  The openswan configuration is for
3des-sha1-modp1024 with pre-shared keys.

    # ./iperf -l 1400 -c 192.168.1.2 -u -b 235m
    ------------------------------------------------------------
    Client connecting to 192.168.1.2, UDP port 5001
    Sending 1400 byte datagrams
    UDP buffer size:   103 KByte (default)
    ------------------------------------------------------------
    [  5] local 192.168.0.2 port 33120 connected with 192.168.1.2 port 5001
    [  5]  0.0-10.0 sec    284 MBytes    238 Mbits/sec
    [  5] Sent 212767 datagrams
    [  5] Server Report:
    [  5]  0.0- 9.9 sec    284 MBytes    240 Mbits/sec  0.191 ms    0/212766 (0%)
    [  5]  0.0- 9.9 sec  1 datagrams received out-of-order

    # ./iperf -l 200 -c 192.168.1.2 -u -b 58m
    ------------------------------------------------------------
    Client connecting to 192.168.1.2, UDP port 5001
    Sending 200 byte datagrams
    UDP buffer size:   103 KByte (default)
    ------------------------------------------------------------
    [  5] local 192.168.0.2 port 33121 connected with 192.168.1.2 port 5001
    [  5]  0.0-10.0 sec  70.6 MBytes  59.3 Mbits/sec
    [  5] Sent 370362 datagrams
    [  5] Server Report:
    [  5]  0.0- 9.9 sec  70.6 MBytes  59.6 Mbits/sec  0.035 ms   86/370361 (0.023%)
    [  5]  0.0- 9.9 sec  1 datagrams received out-of-order

    ./iperf -l 64 -c 192.168.1.2 -u -b 22m
    ------------------------------------------------------------
    Client connecting to 192.168.1.2, UDP port 5001
    Sending 64 byte datagrams
    UDP buffer size:   103 KByte (default)
    ------------------------------------------------------------
    [  5] local 192.168.0.2 port 33121 connected with 192.168.1.2 port 5001
    [  5]  0.0-10.0 sec  26.5 MBytes  22.3 Mbits/sec
    [  5] Sent 434695 datagrams
    [  5] Server Report:
    [  5]  0.0-10.0 sec  26.1 MBytes  22.0 Mbits/sec  0.027 ms 6865/434694 (1.6%)
    [  5]  0.0-10.0 sec  1 datagrams received out-of-order

Test 4
------

And finally the null crypto case (40% CPU on a 2.4 Xeon, %20 on a 2.8 for
large packets, 100% CPU for the 200 and 64 byte packets).  The null crypto
case replaces the hardware accelerator with a theoretical 0 cost
implementation which does nothing.  This allows the cost of ipsec processing
to been seen,  and also the potential benefits from better acceleration.

    ./iperf -l 1400 -c 192.168.1.2 -u -b 750m
    ------------------------------------------------------------
    Client connecting to 192.168.1.2, UDP port 5001
    Sending 1400 byte datagrams
    UDP buffer size:   103 KByte (default)
    ------------------------------------------------------------
    [  5] local 192.168.0.2 port 33198 connected with 192.168.1.2 port 5001
    [  5]  0.0-10.0 sec    919 MBytes    771 Mbits/sec
    [  5] Sent 688557 datagrams
    [  5] Server Report:
    [  5]  0.0-10.0 sec    919 MBytes    775 Mbits/sec  0.010 ms 2/688556 (0.00029%)
    [  5]  0.0-10.0 sec  1 datagrams received out-of-order


    ./iperf -l 200 -c 192.168.1.2 -u -b 750m
    ------------------------------------------------------------
    Client connecting to 192.168.1.2, UDP port 5001
    Sending 200 byte datagrams
    UDP buffer size:   103 KByte (default)
    ------------------------------------------------------------
    [  5] local 192.168.0.2 port 33198 connected with 192.168.1.2 port 5001
    [  5]  0.0-10.0 sec    253 MBytes    213 Mbits/sec
    [  5] Sent 1328454 datagrams
    [  5] Server Report:
    [  5]  0.0-10.2 sec    113 MBytes  93.2 Mbits/sec  14.657 ms 734888/1328450 (55%)
    [  5]  0.0-10.2 sec  1 datagrams received out-of-order


    ./iperf -l 64 -c 192.168.1.2 -u -b 750m
    ------------------------------------------------------------
    Client connecting to 192.168.1.2, UDP port 5001
    Sending 64 byte datagrams
    UDP buffer size:   103 KByte (default)
    ------------------------------------------------------------
    [  5] local 192.168.0.2 port 33198 connected with 192.168.1.2 port 5001
    [  5]  0.0-10.0 sec  80.9 MBytes  67.9 Mbits/sec
    [  5] Sent 1325578 datagrams
    [  5] Server Report:
    [  5]  0.0-10.2 sec  39.5 MBytes  32.5 Mbits/sec  14.771 ms 678605/1325478 (51%)

david_mccullough@securecomputing.com
http://ocf-linux.sourceforge.net/


-- 
David McCullough,  david_mccullough@securecomputing.com,   Ph:+61 734352815
Secure Computing - SnapGear  http://www.uCdot.org http://www.cyberguard.com
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


</body></email><email><emailId>20060525002449</emailId><senderName>markus reichelt</senderName><senderEmail>ml@mareichelt.de</senderEmail><timestampReceived>2006-05-25 00:24:49-0400</timestampReceived><subject>Benchmarks VIA PadLock</subject><body>

Hi,

I have the questionable honour to own a Nehemiah with stepping 1 so
there's sadly no PadLock &amp; RNG build-in. That's what you get from
pre-ordering :-(

Since I'm playing with the idea of upgrading my system to a CPU which
features both PadLock and RNG I'm interested in benchmarks of
loop-aes with and without using PadLock on a 1 GHz system (or faster,
along with /proc/cpuinfo). 128bit AES will suffice.

Any info on this is greatly appreciated.

--=20
left blank, right bald

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060525193410</emailId><senderName>Steward-owner</senderName><senderEmail>steward-owner@scoug.com</senderEmail><timestampReceived>2006-05-25 19:34:10-0400</timestampReceived><subject>Steward Results</subject><body>

&gt;&gt;&gt;this is a multi-part message in MIME format.
Unknown command ignored.

&gt;&gt;&gt;------=_nextpart_000_0011_57215e65.d37c69d7 
Unknown command ignored.

&gt;&gt;&gt;content-type: text/plain;
Unknown command ignored.

&gt;&gt;&gt;	charset=us-ascii 
Unknown command ignored.

&gt;&gt;&gt;content-transfer-encoding: 7bit
Unknown command ignored.

&gt;&gt;&gt;the original message was received at Thu, 25 May 2006 12:34:13 -0700
Unknown command ignored.

&gt;&gt;&gt;from 6.133.136.203
Unknown command ignored.

&gt;&gt;&gt;----- The following addresses had permanent fatal errors -----
Unknown command ignored.

&gt;&gt;&gt;steward@scoug.com 
Unknown command ignored.

No valid commands found in your message. Sending help instead.
&gt;&gt;&gt;  

This is the Steward mailing list software, Version 1.16
of 17 February 2006.

Steward understands the following commands:

subscribe &lt;listname&gt; [&lt;address&gt;]
  Subscribe yourself to the named &lt;listname&gt;.
  &lt;address&gt; is optional.

sub &lt;listname&gt; [&lt;address&gt;]
  Subscribe yourself to the named &lt;listname&gt;.
  &lt;address&gt; is optional.

post &lt;listname&gt; [&lt;address&gt;]
  Add your email address for posting only to the list named &lt;listname&gt;.
  &lt;address&gt; is optional.

unsubscribe &lt;listname&gt; [&lt;address&gt;]
  Unsubscribe yourself to the named &lt;listname&gt;.
  &lt;address&gt; is optional.

unsub &lt;listname&gt; [&lt;address&gt;]
  Unsubscribe yourself to the named &lt;listname&gt;.
  &lt;address&gt; is optional.

kill &lt;listname&gt; [&lt;address&gt;]
  Unsubscribe someone from the list named &lt;listname&gt;.
  &lt;address&gt; is optional.

who &lt;listname&gt;
  List the list members email addresses.

help
  Send this message.

lists
  Show the lists available from this server.

end
  Stop processing commands (useful if your mailer adds a signature).

Commands should be sent in the body of the email message to
Steward@scoug.com. Multiple commands may be included in one
message provided each is on its own line.

Commands in the "Subject" field are ignored.

Questions should be sent to postmaster@scoug.com.



-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060526013540</emailId><senderName>Christian Kujau</senderName><senderEmail>evil@g-house.de</senderEmail><timestampReceived>2006-05-26 01:35:40-0400</timestampReceived><subject>Re: How about deniability?</subject><body>

On Sat, 20 May 2006, Matthias Schniedermeyer wrote:
&gt; In a german magazine there was an article about disc duplication that was 
&gt; written by someone from the police.

Do you have the url/name of the magazine at hand?

&gt; They take out the HDD and make a backup of it and only operate on these 
&gt; backups, then the computer and the original HDD(s) is locked away.

So, at least they seem to make sure the original data is not touched. 
This is good news.

But I think it all boils down to: how can they convict with no evidence?
&gt;From the article:

  "and the suspect can say, 'No, they're love letters,
   sorry, I've lost the key'."

..."not guilty until proven otherwise"? I wonder if they'll hand out the 
original harddisk after examniation, because "it's just love letter" and 
"the defendant has lost the keys anyway, so it's not worth anything".
I hope they do (hand out the *original* disk).

And of course they won't admit that they were able to break 
AES/$SECURE_CIPHER for a lousy 100 GB of stolen mp3s. This in fact seems
worthy to play around with:

"How many GB of very-delicate-material does it take so that they admit 
they broke $SECURE_CIPHER?"

Christian.
-- 
BOFH excuse #435:

Internet shut down due to maintenance

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060526080651</emailId><senderName>Matthias Schniedermeyer</senderName><senderEmail>ms@citd.de</senderEmail><timestampReceived>2006-05-26 08:06:51-0400</timestampReceived><subject>Re: How about deniability?  (read:http://www.zdnet.co.uk/print/?TYPE=story&amp;AT=39269746-39020330t-100</subject><body>

Christian Kujau wrote:
&gt; On Sat, 20 May 2006, Matthias Schniedermeyer wrote:
&gt;&gt; In a german magazine there was an article about disc duplication that
&gt;&gt; was written by someone from the police.
&gt; 
&gt; Do you have the url/name of the magazine at hand?

I think it was the german Linux Magazin.
www.linux-magazin.de

But i may have been
c't (www.heise.de/ct)
or
iX (www.heise.de/ix)
or the newsticker
www.heise.de/newsticker





-- 
Real Programmers consider "what you see is what you get" to be just as
bad a concept in Text Editors as it is in women. No, the Real Programmer
wants a "you asked for it, you got it" text editor -- complicated,
cryptic, powerful, unforgiving, dangerous.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060528041824</emailId><senderName>Alon Bar-Lev</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2006-05-28 04:18:24-0400</timestampReceived><subject>[ANNOUNCE] PKCS#11 support in OpenSSH 4.3p2 (version 0.11)</subject><body>

Hello,

The version 0.11 of "PKCS#11 support in OpenSSH" is published.

Changes:
1. Updated against OpenSSH 4.3p2.
2. Modified against Roumen Petrov's X.509 patch (version
5.4), so self-signed certificates are treated by the X.509
patch now.
3. Added --pkcs11-x509-force-ssh if X.509 patch applied,
until some issues with the X.509 patch are resolved.
4. Fixed issues with gcc-2.

You can grab the new version from
http://alon.barlev.googlepages.com/openssh-pkcs11.

I will be glad to receive any feedback regarding this patch,
so I will be able to adjust it closer to requirements, and
extend the support for none-agent usage.

The PKCS#11 support is provided by a pkcs11-helper
implementation which is common for OpenVPN, QCA (Qt
Cryptographic Architecture for KDE 4.0) and may be used by
many other projects, one example is this patch for OpenSSH,
there is also an initial support for xsupplicant and
wpa_supplicant.

Best Regards,
Alon Bar-Lev.

---

Instructions:

The PKCS#11 patch modify ssh-add and ssh-agent to support
PKCS#11 private keys and certificates.

It allows using multiple PKCS#11 providers at the same time,
selecting keys by id, label or certificate subject, handling
card removal and card insert events, handling card re-insert
to a different slot, supporting session expiration.

A valid X.509 certificate should exist on the token, without
X.509 support it is exported as regular RSA key. There is a
simple utility Timo Felbinger wrote
(http://www.timof.qipc.org/x509toOpenSSH.c) that extracts
ssh public key from X.509 certificate.

If you like X.509 support apply the X.509 (&gt;=5.4) patch
*AFTER* the PKCS#11 patch.

One significant change is that the ssh-agent prompts for
passwords now... So you need to configure it with a program
that asks for card insert or PIN, a program such as
x11-ssh-askpass. Current implementation (ssh-add asks for
passwords) is not valid for dynamic smartcard environment.

Current implementation uses the askpin program also for
prompting card insert... Don't be confused, it only expects
ok or cancel, attached is a simple scripts that uses KDE and
.NET in order to display these dialogs.

You can view full usage by:
$ ssh-agent /bin/sh
$ ssh-add -h

A common scenario is the following:

$ ssh-agent /bin/sh
$ ssh-add --pkcs11-ask-pin `which openssh-kde-dialogs.sh`
$ ssh-add --pkcs11-add-provider --pkcs11-provider
/usr/lib/pkcs11/MyProvider.so
$ ssh-add --pkcs11-add-id --pkcs11-slot-type label
--pkcs11-slot "MyToken" --pkcs11-id-type subject --pkcs11-id
"/C=XX/CN=YY"
$ ssh myhost

In order to see available objects, you can use:

$ ssh-add --pkcs11-show-slots --pkcs11-provider
/usr/lib/pkcs11/MyProvider.so
$ ssh-add --pkcs11-show-objects --pkcs11-provider
/usr/lib/pkcs11/MyProvider.so --pkcs11-slot 0




-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060529211035</emailId><senderName>"Kim C"</senderName><senderEmail>kimc@operamail.com</senderEmail><timestampReceived>2006-05-29 21:10:35-0400</timestampReceived><subject>Re: Getting real slow performance</subject><body>

&gt; Kim C wrote:
&gt; &gt; I have suspected that the drive might be dying, though I dont see any
&gt; &gt; other symptoms, no noise, no syslog messages, no smart logged and no
&gt; &gt; kernel messages. 

&lt;snip&gt;

I have tried to to test the performance on /dev/hda to see if there is any problem \
there. 

&gt; dd if=/dev/hda2 of=/dev/null bs=1024k

Unfortunately for me this failed with an i/o error, so it definitely do seem to be \
faulty hardware. This time I got kernel messages and smart log. 

hda: dma_intr: status=0x51 { DriveReady SeekComplete Error }
hda: dma_intr: error=0x40 { UncorrectableError }, LBAsect=92821385, high=5, \
                low=8935305, sector=92821033
ide: failed opcode was: unknown
end_request: I/O error, dev hda, sector 92821033
Buffer I/O error on device hda2, logical block 10379681
w83781d 1-0290: Starting device update
hda: dma_intr: status=0x51 { DriveReady SeekComplete Error }
hda: dma_intr: error=0x40 { UncorrectableError }, LBAsect=92821386, high=5, \
                low=8935306, sector=92821041
ide: failed opcode was: unknown
end_request: I/O error, dev hda, sector 92821041
Buffer I/O error on device hda2, logical block 10379682
w83781d 1-0290: Starting device update
hda: dma_intr: status=0x51 { DriveReady SeekComplete Error }
hda: dma_intr: error=0x40 { UncorrectableError }, LBAsect=92821386, high=5, \
                low=8935306, sector=92821049
ide: failed opcode was: unknown
end_request: I/O error, dev hda, sector 92821049
Buffer I/O error on device hda2, logical block 10379683

So I will just try to recover my data, and start over. Thanks for the pointing me in \
the direction I didnt want to go.

best regards 
Kim

-- 
_______________________________________________
Surf the Web in a faster, safer and easier way:
Download Opera 8 at http://www.opera.com

Powered by Outblaze

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060530044819</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-30 04:48:19-0400</timestampReceived><subject>Re: [CRYPTO] tcrypt: return -EAGAIN from module_init()</subject><body>

On Tue, May 30, 2006 at 04:42:23PM +1200, Michal Ludvig wrote:
&gt; 
&gt; while we're on tcrypt ... I use this patch to prevent successful loading
&gt; of tcrypt. It does all its work, then returns -EAGAIN and is removed
&gt; from the kernel. It saves me one "rmmod tcrypt" that I otherwise keep
&gt; forgetting to issue ;-)

I agree completely.  Patch applied.  Thanks a lot.
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060530123106</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-05-30 12:31:06-0400</timestampReceived><subject>Re: [CRYPTO] tcrypt: Call tests by algorithm names instead of arbitrary numbers</subject><body>

On Wed, May 31, 2006 at 12:11:59AM +1200, Michal Ludvig wrote:
&gt;
&gt; Just in case you'd change your mind about $SUBJ - attached is an updated
&gt; version with that applies on top of the digest-speed.
&gt; Just in case... ;-))

Sure, I'll keep this in mind.  I'm certainly going to revisit this
module at some point when the other crypto stuff settles down a bit.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060530131032</emailId><senderName>rodger ellis</senderName><senderEmail>rellis@gmx.net</senderEmail><timestampReceived>2006-05-30 13:10:32-0400</timestampReceived><subject>ubs device</subject><body>

Further TO my question today.

I cannot boot from USB device as my BIOS does not have that function


rodger
-- 


Bis zu 70% Ihrer Onlinekosten sparen: GMX SmartSurfer!
      Kostenlos downloaden: http://www.gmx.net/de/go/smartsurfer
    

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060530144410</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-05-30 14:44:10-0400</timestampReceived><subject>Re: Loop-AES and Twofish on 64-bit CPU</subject><body>

Jari Ruusu wrote:
&gt; Userland encrypted swap and random key (file system) setup:
&gt; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
&gt; 40 KB of old encrypted data is read from disk, and hashed with SHA-512. That
&gt; same 40 KB of old encrypted data is then overwritten 20 times using random
&gt; data generated from computed hash and time stamp. 32 bytes of common random
&gt; data is read from /dev/urandom. For each 65 keys, 16 bytes of per key random
&gt; data is read from /dev/urandom. Each of 65 random keys is generated by
&gt; hashing "40 KB of old encrypted data" and 32 bytes of common random data and
&gt; 16 bytes of per key random data using SHA-512.

Correction to above. Last sentence should read as:

Each of 65 random keys is generated by hashing hash of "40 KB of old
                                               ^^^^^^^
encrypted data" and 32 bytes of common random data and 16 bytes of per key
random data using SHA-512.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060530191122</emailId><senderName>rodger ellis</senderName><senderEmail>rellis@gmx.net</senderEmail><timestampReceived>2006-05-30 19:11:22-0400</timestampReceived><subject>i read the loop-aes readme file</subject><body>

HI

Forgive me for not reading this file before hand which explains
how to encrypt a root and swap partition.

Would it still be possible to use the howto I mentioned in my e-mail  
today and then use the example from the loop-aes readme file?



Rodger
-- 


Bis zu 70% Ihrer Onlinekosten sparen: GMX SmartSurfer!
      Kostenlos downloaden: http://www.gmx.net/de/go/smartsurfer
    

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060530192104</emailId><senderName>Gabriel_Jägenstedt</senderName><senderEmail>gabriel.j@telia.com</senderEmail><timestampReceived>2006-05-30 19:21:04-0400</timestampReceived><subject>Re: folowed this howto to encrypt home</subject><body>

Well I tried to use the built in stuff of Ubuntu once but couldn't get
it to boot. Why this is I don't know. Haven't found any good guides that
took into account both using USB and using built in packages. It may
well be quite easy but I haven't gotten it down yet.

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060402150952</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-04-02 15:09:52-0400</timestampReceived><subject>Re: Encrypted dvd again.</subject><body>

Gabriel Jägenstedt wrote:
&gt; Heya! I use aespipe to encrypt dvds like the readme tells me. However I
&gt; would prefer to not mount the device when I'm going to play a dvd.
&gt; I figured this should work but alas. What am I missing?
&gt; 
&gt; sudo losetup -e AES256 -K /dev/hdc -o 8192 /dev/loop11 /dev/hdc
&gt; Password:
&gt; Error: gpg key file decryption failed
&gt; 
&gt; This mounts the device without problem. But as stated I don't want it
&gt; mounted.
&gt; 
&gt; /dev/hdc    /mnt/dvd    iso9660
&gt; ro,user,noauto,loop=/dev/loop11,encryption=AES256,gpgkey=/dev/hdc,offset=8192
&gt;                      0   0

If the keyfile at beginning of the CD-ROM is symmetrically encrypted, then
above sudo works fine. However, if it is public key encrypted, then you need
to specify a directory for gpg keyrings. This is because suid-root mount
runs with EUID=root UID=gabriel, and sudo run EUID=root UID=root. The UID is
used to locate home directory of the user.

Try this one:
 sudo losetup -e AES256 -K /dev/hdc -G /home/gabriel/.gnupg -o 8192 /dev/loop11 /dev/hdc
                                    ^^^^^^^^^^^^^^^^^^^^^^^
-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060404034338</emailId><senderName></senderName><senderEmail>"postmaster"</senderEmail><timestampReceived>2006-04-04 03:43:38-0400</timestampReceived><subject>Delivery Notification for &lt;garcia.i@pg.com&gt;</subject><body>

This is a multi-part message in MIME format.

--*C*I*P*H*E*R*T*R*U*S*T*1144122218.470944*
Content-Type: text/plain;
	charset="us-ascii"
Content-Transfer-Encoding: 7bit

This is a delivery status notification, automatically generated by MTA \
bdc-filter02.na.pg.com on Mon, 03 Apr 2006 23:43:38 -0400 Regarding recipient(s) : \
garcia.i@pg.com Delivery status : Failed. Message could not be delivered to the \
domain - pg.com. Error while sending data. MTA Response :551
The original message headers are included as attachment.

--*C*I*P*H*E*R*T*R*U*S*T*1144122218.470944*
Content-Type: message/delivery-status;
	charset="us-ascii"
Content-Transfer-Encoding: 7bit

Reporting-MTA: dns; bdc-filter02.na.pg.com

Final-Recipient: rfc822;garcia.i@pg.com
Diagnostic-Code: smtp; 551 5.0.0 P&amp;G's email policy prohibits the distribution of a \
message that contains a virus or an unsafe attachment. This message was rejected by \
P&amp;G because it contained the virus W32/Mydoom.o@MM. We attempted to repair the \
                attachment, but failed.
Remote-MTA: dns; smtpgw.pg.com
Action: failed
Status: 5.0.0

--*C*I*P*H*E*R*T*R*U*S*T*1144122218.470944*
Content-Type: message/rfc822;
	charset="us-ascii"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment

Received: from ([201.154.187.201])
	by bdc-filter02.na.pg.com with ESMTP  id KP-TDGH3.89397638;
	Mon, 03 Apr 2006 23:42:00 -0400
From: linux-crypto@nl.linux.org
To: garcia.i@pg.com
Subject: 
Date: Mon, 3 Apr 2006 22:41:58 -0600
MIME-Version: 1.0
X-Priority: 3
X-MSMail-Priority: Normal
X-Mailer: Microsoft Outlook Express 6.00.2600.0000
X-MIMEOLE: Produced By Microsoft MimeOLE V6.00.2600.0000
X-esp: ESP&lt;23&gt;=RBL:&lt;24&gt; RDNS:&lt;0&gt; SHA:&lt;0&gt; UHA:&lt;0&gt; SLS:&lt;0&gt; BAYES:&lt;0&gt;
	SenderID:&lt;-1&gt; URL Substring Dictionary (TRU8):&lt;0&gt; Spam
	Dictionary (TRU8):&lt;0&gt; NigeriaScam Dictionary (TRU8):&lt;0&gt; HTML
	Dictionary (TRU8):&lt;0&gt; Porn Dictionary (TRU8):&lt;0&gt; Embed HTML
	Dictionary (TRU8):&lt;0&gt; Obscenities Dictionary (TRU8):&lt;0&gt; URL
	Dictionary (TRU8):&lt;0&gt; CAN-SPAM Compliance Dictionary (TRU8):&lt;0&gt; 

*** Body Not Included ***

--*C*I*P*H*E*R*T*R*U*S*T*1144122218.470944*--



-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060405172942</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-04-05 17:29:42-0400</timestampReceived><subject>Re: [PATCH] crypto: fix unaligned access in khazad module</subject><body>

On Tue, Apr 04, 2006 at 04:55:52PM +0900, Atsushi Nemoto wrote:
&gt; 
&gt; On 64-bit platform, reading 64-bit keys (which is supposed to be
&gt; 32-bit aligned) at a time will result in unaligned access.

Patch applied.  Thanks a lot.
--
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060406080345</emailId><senderName>"Debby Chiu"</senderName><senderEmail>debby.chiu@madamepearls.com</senderEmail><timestampReceived>2006-04-06 08:03:45-0400</timestampReceived><subject>Notice of Resignation</subject><body>

Notice of Resignation

Dear Sir,

This is to inform you that Ms.Debby Chiu has left our company.  Any business related \
matters, please contact (852) 3526 6666 for assistance.

Luxembourg Medicine Co Ltd



-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060406100918</emailId><senderName></senderName><senderEmail>mclwilliams</senderEmail><timestampReceived>2006-04-06 10:09:18-0400</timestampReceived><subject>=?UTF-8?B?Q09NUEVOU0FUSU9OLg==?=</subject><body>

My dear friend=2C

I=27m happy to inform you about my success in getting those funds =

transferred under the co-operation of a new partner from Paraguay=2E Pres=
ently =

I=27m in Paraguay for investment projects with my own share of the total =

sum=2Emeanwhile=2C i didn=27t forget you=92re past efforts and attempts t=
o =

assist me in transferring those funds despite that it failed us some how=2E=


Now contact my secretary in Agulu=2C Nigeria her name is Mrs=2E Ijoma=2C =
and =

email mrsijoma01=40myway=2Ecom ask her to send you the total =24800=2E000=
=2E00 =

bank draft which I raised in your favor for your compensation for all the=
 =

past efforts and attempts to assist me in this matter=2E
I appreciated your efforts at that time very much=2E So feel free and get=
 =

in touched with my secretary Mrs=2E Ijoma and instruct him where to send =

the amount to you=2E

Please do let me know immediately you receive it so that we can share =

the joy after all the suffer ness at that time=2E in the moment=2C I=92m =
very =

busy here because of the investment projects which me and the new =

partner are having at hand=2C finally=2C remember that i had forwarded =

instruction to the secretary on your behalf=2C so feel free to contact he=
r now to =

enable her send =

your money to you without any delay=2E

Contact Mrs=2E Ijoma at this Email=2C=7B mrsijoma01=40myway=2Ecom =7D

My regards to you and your family=2C

Michael Williams=2E


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060406193050</emailId><senderName></senderName><senderEmail>do_not_reply@bmbwk.gv.at</senderEmail><timestampReceived>2006-04-06 19:30:50-0400</timestampReceived><subject>No mails with executable attachements to BMBWK</subject><body>

Aus sicherheitstechnischen Gründen ist der Versand von ausfuehrbaren Dateien an das BMBWK gesperrt.

Sender: linux-crypto@nl.linux.org
Recipient(s): armin.mahr@bmbwk.gv.at
Subject: Delivery reports about your e-mail
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060408043756</emailId><senderName>"Christian"</senderName><senderEmail>evil@g-house.de</senderEmail><timestampReceived>2006-04-08 04:37:56-0400</timestampReceived><subject>Re: Security levels of different implementations of block crypto</subject><body>

On Fri, March 31, 2006 20:10, markus reichelt wrote:
&gt; Additionally to Jari's comment, I bet that if you post this question
&gt; to dm-crypt's mailinglist, you'll read quite the opposite :-)

Jim, please do to dm-crypt's mailinglist and maybe we can engage a
*useful* discussion as to why would anybody use loop-aes/dm-crypt. I'm in
a similiar position as Jim as I've chosen loop-aes (Thanks, Jari!) when
there was only cryptoloop in mainline. I like loop-aes, but it's the only
3rd party module I have to build and using a mainline solution would
be.....neat.

&gt; Just being curious, why not stick to loop-aes? As it seems it has
&gt; served you well over the years, being both stable and secure.

I believe that it'd be a good thing to make crypto simpler (not less
secure!) and having to build loop.ko seperatly is easy for the readers of
this group and it may be easy for the kernel-maintainer of $DISTRO, but
it's not simpler than just using $SECURE_MAINLINE_CRYPTO, whatever that'd
be.

Thanks,
Christian.
-- 
BOFH excuse #442:

Trojan horse ran out of hay


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060409130154</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-04-09 13:01:54-0400</timestampReceived><subject>Re: Automated fsck on boot</subject><body>

Hi Jari,

On Sun, Apr 09, 2006 at 11:14:55AM +0300, Jari Ruusu wrote:
&gt; Your version compared device (or file) names. Comparing names is
&gt; problematic because they may be truncated or they may use relative
&gt; paths (not begin with slash). I changed it to compare device number
&gt; and inode number of the block special file (or normal file) to those
&gt; recorded in loop device.
&gt;
&gt; # losetup /dev/loop6
&gt; /dev/loop6: [0902]:213045 (/dev/md5) offset=4096 encryption=AES128 multi-key-v3
&gt;              ^^^^  ^^^^^^
&gt;               |      |
&gt;               |    Inode number inside my root file system where static
&gt;               |    block special node /dev/md5 happens to reside.
&gt;               |
&gt;              Device number of my root file system where static
&gt;              block special node /dev/md5 happens to reside.

Ah, I see. That makes a lot of sense - I suppose someone could also
have replaced a loop file with a different file of the same name, or
udev could have been renaming a device node. In both cases comparing
only filenames would give a wrong result.

&gt; I merged your patch, but now the code looks like this:
&gt; 
&gt; int is_loop_active(const char *dev, const char *backdev)
&gt; {
&gt; 	int fd;
&gt; 	int ret = 0;
&gt; 	struct stat statbuf;
&gt; 	struct loop_info64 loopinfo;
&gt; 	if (stat (dev, &amp;statbuf) == 0 &amp;&amp; S_ISBLK(statbuf.st_mode)) {
&gt; 		fd = open (dev, O_RDONLY);
&gt; 		if (fd &lt; 0)
&gt; 			return 0;
&gt; 		if ((loop_get_status64_ioctl(fd, &amp;loopinfo) == 0)
&gt; 		    &amp;&amp; (stat (backdev, &amp;statbuf) == 0)
&gt; 		    &amp;&amp; (statbuf.st_dev == loopinfo.lo_device)
&gt; 		    &amp;&amp; (statbuf.st_ino == loopinfo.lo_inode))
&gt; 			ret = 1; /* backing device matches */
&gt; 		memset(&amp;loopinfo, 0, sizeof(loopinfo));
&gt; 		close(fd);
&gt; 	}
&gt; 	return ret;
&gt; }

Works perfectly for me. Thanks a lot!

I'm attaching a preliminary version of the rcS.d init script I'm
planning to ship in the Debian package loop-aes-utils.

I'm undecided about whether to enable the init script for existing
setups. It is safer for every filesystem to be fscked regularily,
but then someone might have a loop device with a file system on it
that shows uncorrectable errors - this could cause the boot to abort
and drop to sulogin for manual correction.  Or there might be an
existing script that does losetup -F and fsck which could break if
this script runs before and leaves the loop allocated. 

What do Debian users here think? Other thoughts or experiences? 
I currently tend to leave it disabled by default and document in
README.Debian that one needs to enable it manually by editing a 
flag in /etc/default/checkfs-loop (or so).

cheers,
Max


#!/bin/sh
### BEGIN INIT INFO
# Provides:          checkfs-loop
# Required-Start:    checkroot
# Required-Stop:
# Should-Start:      udev devfsd raid2 mdadm lvm
# Should-Stop:
# Default-Start:     S
# Default-Stop:
# Short-Description: Check loop-encrypted filesystems.
### END INIT INFO
#
# NOTE: This script duplicates much of checkfs.sh as we need to
# work on the decrypted loop devices, which fsck -A doesn't know
# about. The maintainer of this script should track changes in
# checkfs.sh and make sure they are applied.

PATH=/sbin:/bin
FSCK_LOGFILE=/var/log/fsck/loop
[ "$FSCKFIX" ] || FSCKFIX=no
. /lib/init/vars.sh
. /lib/lsb/init-functions

list_fsck_loops () {
	grep -v '^#' /etc/fstab |
	while read dev mnt fstype opts freq passno; do
		fsck=yes
		loopdev=

		for opt in $(IFS=, &amp;&amp; echo $opts)
		do
			case $opt in
			noauto|sw)
				fsck=no
				;;
			loop=/dev/loop*)
				loopdev=${opt#loop=}
				;;
			esac
		done

		if [ -z "$loopdev" ] || [ "$fsck" = no ]
		then
			continue
		fi

		echo $loopdev:$mnt
	done
}

retries=3

do_losetup () {
	loop=${1%:*}
	mnt=${1#*:}
	try=0
	log_action_msg "Setting up $loop ($mnt)"
	while [ $try -lt $retries ]
	do
		if losetup -F $loop
		then
			return 0
		fi
		try=$((try+1))
	done
	return 1
}

# TODO We can't do anything about FSCKTYPES settings other than "none"

do_fsck () {
	loopdevs="$@"

	# See if we're on AC Power
	# If not, we're not gonna run our check
	if which on_ac_power &gt;/dev/null 2&gt;&amp;1
	then
		on_ac_power &gt;/dev/null 2&gt;&amp;1
		if [ $? -eq 1 ]
		then
			[ "$VERBOSE" = no ] || log_success_msg "Running on battery power, so skipping loop file system check."
			BAT=yes
		fi
	fi

	#
	# Check loop-encrypted file systems.
	#
	if [ ! -f /fastboot ] &amp;&amp; [ ! "$BAT" ] &amp;&amp; [ "$FSCKTYPES" != "none" ]
	then
		if [ -f /forcefsck ]
		then
			force="-f"
		else
			force=""
		fi
		if [ "$FSCKFIX" = yes ]
		then
			fix="-y"
		else
			fix="-a"
		fi
		spinner="-C"
		case "$TERM" in
		  dumb|network|unknown|"")
			spinner=""
			;;
		esac
		[ "$(uname -m)" = s390 ] &amp;&amp; spinner=""  # This should go away
		handle_failed_fsck() {
			log_failure_msg "File system check failed. 
A log is being saved in ${FSCK_LOGFILE} if that location is writable. 
Please repair the file system manually."
			log_warning_msg "A maintenance shell will now be started. 
CONTROL-D will terminate this shell and resume system boot."
			# Start a single user shell on the console
			if ! sulogin $CONSOLE
			then
				log_failure_msg "Attempt to start maintenance shell failed. 
Continuing with system boot in 5 seconds."
				sleep 5
			fi
		}

		failed=
		for device in $loopdevs
		do
			if [ "$VERBOSE" = no ]
			then
				logsave -s $FSCK_LOGFILE fsck $spinner $fix $force $device
				FSCKCODE=$?
				if [ "$FSCKCODE" -gt 1 ]
				then
					failed=1
				fi
			else
				logsave -s $FSCK_LOGFILE fsck $spinner -V $fix $force $device
				FSCKCODE=$?
				if [ "$FSCKCODE" -gt 1 ]
				then
					failed=1
				fi
			fi
		done

		if [ "$failed" ]
		then
			handle_failed_fsck
		else
			if [ "$VERBOSE" = yes ]
			then
				log_success_msg "Done checking loop-encrypted file systems. 
A log is being saved in ${FSCK_LOGFILE} if that location is writable."
			fi
		fi
	fi
	# Do not delete those, we are running before checkfs and it will
	# still need them
	#rm -f /fastboot /forcefsck
}

do_start () {
	log_action_msg "Checking loop-encrypted file systems"

	check_loops=
	for device in $(list_fsck_loops)
	do
		if do_losetup $device
		then
			check_loops="$check_loops ${device%:*}"
		fi
	done
	do_fsck $check_loops
}

case "$1" in
  start|"")
	do_start
	;;
  restart|reload|force-reload)
	echo "Error: argument '$1' not supported" &gt;&amp;2
	exit 3
	;;
  stop)
	# No-op
	;;
  *)
	echo "Usage: checkfs-loop.sh [start|stop]" &gt;&amp;2
	exit 3
	;;
esac

:


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060409224537</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-04-09 22:45:37-0400</timestampReceived><subject>Re: [PATCH] crypto: add alignment handling to digest layer</subject><body>

On Tue, Apr 04, 2006 at 12:04:07AM +0900, Atsushi Nemoto wrote:
&gt; 
&gt; Some hash modules load/store data words directly.  The digest layer
&gt; should pass properly aligned buffer to update()/final() method.  This
&gt; patch also add cra_alignmask to some hash modules.
&gt; 
&gt; Signed-off-by: Atsushi Nemoto &lt;anemo@mba.ocn.ne.jp&gt;

Patch applied.  Thanks a lot.
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060309032638</emailId><senderName>Atsushi Nemoto</senderName><senderEmail>nemoto@toshiba-tops.co.jp</senderEmail><timestampReceived>2006-03-09 03:26:38-0400</timestampReceived><subject>[PATCH] crypto: fix unaligned access in khazad module</subject><body>

On 64-bit platform, reading directly from keys (which supposed to be
32-bit aligned) will result in unaligned access.

Signed-off-by: Atsushi Nemoto &lt;anemo@mba.ocn.ne.jp&gt;

diff --git a/crypto/khazad.c b/crypto/khazad.c
index 807f2bf..c7e1d25 100644
--- a/crypto/khazad.c
+++ b/crypto/khazad.c
@@ -26,6 +26,7 @@
 #include &lt;asm/scatterlist.h&gt;
 #include &lt;linux/crypto.h&gt;
 #include &lt;linux/types.h&gt;
+#include &lt;asm/unaligned.h&gt;
 
 #define KHAZAD_KEY_SIZE		16
 #define KHAZAD_BLOCK_SIZE	8
@@ -769,8 +770,8 @@ static int khazad_setkey(void *ctx_arg, 
 		return -EINVAL;
 	}
 
-	K2 = be64_to_cpu(key[0]);
-	K1 = be64_to_cpu(key[1]);
+	K2 = be64_to_cpu(get_unaligned(&amp;key[0]));
+	K1 = be64_to_cpu(get_unaligned(&amp;key[1]));
 
 	/* setup the encrypt key */
 	for (r = 0; r &lt;= KHAZAD_ROUNDS; r++) {
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060408160504</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-04-08 16:05:04-0400</timestampReceived><subject>Automated fsck on boot</subject><body>

Hi all,

I'm looking for a user-friendly way to manage automated fsck of
encrypted loop devices during boot. The current way of managing
fscks (losetup -F, fsck, losetup -d, mount) has one big downside
from a usability perspective: It requires the user to enter the
passphrase twice each time the system boots. 

Today I thought of something else that could work, I'm attaching
a quick proof-of-concept patch to describe it. The idea is that we
could do losetup -F, fsck, leave the loop device allocated and have
mount later re-use the loop device. It would require no changes
apart from an optional init script to take care of the fsck.

What do you think about this approach? 

cheers,
Max

-- 
PS: If you are interested, this is one of the last points I want to
solve before integrating loop-AES support into a release version of
Debian installer -- wiki.debian.org/DebianInstaller/PartmanCrypto
The show-stopper bug mentioned is the lack of automated fsck.

["2.12r_reuse_loop.diff" (text/plain)]

--- 2.12r/mount/mount.c~	2006-04-08 16:36:47.000000000 +0200
+++ 2.12r/mount/mount.c	2006-04-08 16:34:19.000000000 +0200
@@ -682,6 +682,10 @@
     if (fake) {
       if (verbose)
 	printf(_("mount: skipping the setup of a loop device\n"));
+    } else if (*loopdev &amp;&amp; is_loop_in_use(*loopdev)) {
+      if (verbose)
+	printf(_("mount: skipping the setup of a loop device\n"));
+      *spec = *loopdev;
     } else {
       int loopro = (*flags &amp; MS_RDONLY);
 
--- 2.12r/mount/lomount.h~	2006-04-08 16:36:47.000000000 +0200
+++ 2.12r/mount/lomount.h	2006-04-08 16:24:22.000000000 +0200
@@ -2,6 +2,7 @@
 extern int set_loop(const char *, const char *, int *, const char **, unsigned int *);
 extern int del_loop(const char *);
 extern int is_loop_device(const char *);
+extern int is_loop_in_use(const char *);
 extern char * find_unused_loop_device(void);
 
 extern char *passFDnumber;
--- 2.12r/mount/lomount.c~	2006-04-08 16:36:47.000000000 +0200
+++ 2.12r/mount/lomount.c	2006-04-08 16:25:32.000000000 +0200
@@ -202,6 +202,22 @@
 	return 0;
 }
 
+int is_loop_in_use(const char *dev)
+{
+	int fd;
+	int ret = 0;
+	struct stat statbuf;
+	if (stat (dev, &amp;statbuf) == 0 &amp;&amp; S_ISBLK(statbuf.st_mode)) {
+		fd = open (dev, O_RDONLY);
+		if (fd &gt;= 0) {
+			if (is_unused_loop_device(fd) == 0)
+				ret = 1;  /* in use */
+			close(fd);
+		}
+	}
+	return ret;
+}
+
 static int rd_wr_retry(int fd, char *buf, int cnt, int w)
 {
 	int x, y, z;

["rcS.d-loopfsck-skel" (text/plain)]

#!/bin/sh

list_fsck_loops ()
{
	egrep -v '^#' /etc/fstab |
	while read dev mnt fstype opts freq passno; do
		fsck=yes
		loopdev=

		for opt in $(IFS=, &amp;&amp; echo $opts); do
			case $opt in
			noauto|sw)
				fsck=no
				;;
			loop=/dev/loop*)
				loopdev=${opt#loop=}
				;;
			esac
		done

		if [ -z "$loopdev" ] || [ "$fsck" = no ]; then
			continue
		fi

		echo $loopdev
	done
}

for dev in $(list_fsck_loops); do
	echo /sbin/losetup -F $dev
	echo distro_specific_fsck_foo $dev
done

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060403150407</emailId><senderName>Atsushi Nemoto</senderName><senderEmail>anemo@mba.ocn.ne.jp</senderEmail><timestampReceived>2006-04-03 15:04:07-0400</timestampReceived><subject>Re: [PATCH] crypto: add alignment handling to digest layer</subject><body>

Ping.  This patch can be applied cleanly to 2.6.17-rc1.


Some hash modules load/store data words directly.  The digest layer
should pass properly aligned buffer to update()/final() method.  This
patch also add cra_alignmask to some hash modules.

Signed-off-by: Atsushi Nemoto &lt;anemo@mba.ocn.ne.jp&gt;

 digest.c      |   42 +++++++++++++++++++++++++++---------------
 michael_mic.c |    1 +
 sha1.c        |    1 +
 sha256.c      |    1 +
 sha512.c      |    2 ++
 tgr192.c      |    3 +++
 6 files changed, 35 insertions(+), 15 deletions(-)

diff --git a/crypto/digest.c b/crypto/digest.c
index d9b6ac9..062d0a5 100644
--- a/crypto/digest.c
+++ b/crypto/digest.c
@@ -27,6 +27,7 @@ static void update(struct crypto_tfm *tf
                    struct scatterlist *sg, unsigned int nsg)
 {
 	unsigned int i;
+	unsigned int alignmask = crypto_tfm_alg_alignmask(tfm);
 
 	for (i = 0; i &lt; nsg; i++) {
 
@@ -38,12 +39,24 @@ static void update(struct crypto_tfm *tf
 			unsigned int bytes_from_page = min(l, ((unsigned int)
 							   (PAGE_SIZE)) - 
 							   offset);
-			char *p = crypto_kmap(pg, 0) + offset;
+			char *src = crypto_kmap(pg, 0);
+			char *p = src + offset;
 
+			if (unlikely(offset &amp; alignmask)) {
+				unsigned int bytes =
+					alignmask + 1 - (offset &amp; alignmask);
+				bytes = min(bytes, bytes_from_page);
+				tfm-&gt;__crt_alg-&gt;cra_digest.dia_update
+						(crypto_tfm_ctx(tfm), p,
+						 bytes);
+				p += bytes;
+				bytes_from_page -= bytes;
+				l -= bytes;
+			}
 			tfm-&gt;__crt_alg-&gt;cra_digest.dia_update
 					(crypto_tfm_ctx(tfm), p,
 					 bytes_from_page);
-			crypto_kunmap(p, 0);
+			crypto_kunmap(src, 0);
 			crypto_yield(tfm);
 			offset = 0;
 			pg++;
@@ -54,7 +67,15 @@ static void update(struct crypto_tfm *tf
 
 static void final(struct crypto_tfm *tfm, u8 *out)
 {
-	tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(crypto_tfm_ctx(tfm), out);
+	unsigned long alignmask = crypto_tfm_alg_alignmask(tfm);
+	if (unlikely((unsigned long)out &amp; alignmask)) {
+		unsigned int size = crypto_tfm_alg_digestsize(tfm);
+		u8 buffer[size + alignmask];
+		u8 *dst = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
+		tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(crypto_tfm_ctx(tfm), dst);
+		memcpy(out, dst, size);
+	} else
+		tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(crypto_tfm_ctx(tfm), out);
 }
 
 static int setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
@@ -69,18 +90,9 @@ static int setkey(struct crypto_tfm *tfm
 static void digest(struct crypto_tfm *tfm,
                    struct scatterlist *sg, unsigned int nsg, u8 *out)
 {
-	unsigned int i;
-
-	tfm-&gt;crt_digest.dit_init(tfm);
-		
-	for (i = 0; i &lt; nsg; i++) {
-		char *p = crypto_kmap(sg[i].page, 0) + sg[i].offset;
-		tfm-&gt;__crt_alg-&gt;cra_digest.dia_update(crypto_tfm_ctx(tfm),
-		                                      p, sg[i].length);
-		crypto_kunmap(p, 0);
-		crypto_yield(tfm);
-	}
-	crypto_digest_final(tfm, out);
+	init(tfm);
+	update(tfm, sg, nsg);
+	final(tfm, out);
 }
 
 int crypto_init_digest_flags(struct crypto_tfm *tfm, u32 flags)
diff --git a/crypto/michael_mic.c b/crypto/michael_mic.c
index 4f6ab23..701f859 100644
--- a/crypto/michael_mic.c
+++ b/crypto/michael_mic.c
@@ -145,6 +145,7 @@ static struct crypto_alg michael_mic_alg
 	.cra_blocksize	= 8,
 	.cra_ctxsize	= sizeof(struct michael_mic_ctx),
 	.cra_module	= THIS_MODULE,
+	.cra_alignmask	= 3,
 	.cra_list	= LIST_HEAD_INIT(michael_mic_alg.cra_list),
 	.cra_u		= { .digest = {
 	.dia_digestsize	= 8,
diff --git a/crypto/sha1.c b/crypto/sha1.c
index 21571ed..b96f57d 100644
--- a/crypto/sha1.c
+++ b/crypto/sha1.c
@@ -112,6 +112,7 @@ static struct crypto_alg alg = {
 	.cra_blocksize	=	SHA1_HMAC_BLOCK_SIZE,
 	.cra_ctxsize	=	sizeof(struct sha1_ctx),
 	.cra_module	=	THIS_MODULE,
+	.cra_alignmask	=	3,
 	.cra_list       =       LIST_HEAD_INIT(alg.cra_list),
 	.cra_u		=	{ .digest = {
 	.dia_digestsize	=	SHA1_DIGEST_SIZE,
diff --git a/crypto/sha256.c b/crypto/sha256.c
index 9d5ef67..d62264a 100644
--- a/crypto/sha256.c
+++ b/crypto/sha256.c
@@ -313,6 +313,7 @@ static struct crypto_alg alg = {
 	.cra_blocksize	=	SHA256_HMAC_BLOCK_SIZE,
 	.cra_ctxsize	=	sizeof(struct sha256_ctx),
 	.cra_module	=	THIS_MODULE,
+	.cra_alignmask	=	3,
 	.cra_list       =       LIST_HEAD_INIT(alg.cra_list),
 	.cra_u		=	{ .digest = {
 	.dia_digestsize	=	SHA256_DIGEST_SIZE,
diff --git a/crypto/sha512.c b/crypto/sha512.c
index 3e6e939..7dbec4f 100644
--- a/crypto/sha512.c
+++ b/crypto/sha512.c
@@ -281,6 +281,7 @@ static struct crypto_alg sha512 = {
         .cra_blocksize  = SHA512_HMAC_BLOCK_SIZE,
         .cra_ctxsize    = sizeof(struct sha512_ctx),
         .cra_module     = THIS_MODULE,
+	.cra_alignmask	= 3,
         .cra_list       = LIST_HEAD_INIT(sha512.cra_list),
         .cra_u          = { .digest = {
                                 .dia_digestsize = SHA512_DIGEST_SIZE,
@@ -295,6 +296,7 @@ static struct crypto_alg sha384 = {
         .cra_flags      = CRYPTO_ALG_TYPE_DIGEST,
         .cra_blocksize  = SHA384_HMAC_BLOCK_SIZE,
         .cra_ctxsize    = sizeof(struct sha512_ctx),
+	.cra_alignmask	= 3,
         .cra_module     = THIS_MODULE,
         .cra_list       = LIST_HEAD_INIT(sha384.cra_list),
         .cra_u          = { .digest = {
diff --git a/crypto/tgr192.c b/crypto/tgr192.c
index 2d8e44f..1eae1bb 100644
--- a/crypto/tgr192.c
+++ b/crypto/tgr192.c
@@ -627,6 +627,7 @@ static struct crypto_alg tgr192 = {
 	.cra_blocksize = TGR192_BLOCK_SIZE,
 	.cra_ctxsize = sizeof(struct tgr192_ctx),
 	.cra_module = THIS_MODULE,
+	.cra_alignmask = 7,
 	.cra_list = LIST_HEAD_INIT(tgr192.cra_list),
 	.cra_u = {.digest = {
 			     .dia_digestsize = TGR192_DIGEST_SIZE,
@@ -641,6 +642,7 @@ static struct crypto_alg tgr160 = {
 	.cra_blocksize = TGR192_BLOCK_SIZE,
 	.cra_ctxsize = sizeof(struct tgr192_ctx),
 	.cra_module = THIS_MODULE,
+	.cra_alignmask = 7,
 	.cra_list = LIST_HEAD_INIT(tgr160.cra_list),
 	.cra_u = {.digest = {
 			     .dia_digestsize = TGR160_DIGEST_SIZE,
@@ -655,6 +657,7 @@ static struct crypto_alg tgr128 = {
 	.cra_blocksize = TGR192_BLOCK_SIZE,
 	.cra_ctxsize = sizeof(struct tgr192_ctx),
 	.cra_module = THIS_MODULE,
+	.cra_alignmask = 7,
 	.cra_list = LIST_HEAD_INIT(tgr128.cra_list),
 	.cra_u = {.digest = {
 			     .dia_digestsize = TGR128_DIGEST_SIZE,
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060410180749</emailId><senderName>robert</senderName><senderEmail>robert@netend.pl</senderEmail><timestampReceived>2006-04-10 18:07:49-0400</timestampReceived><subject>loop-Aes mount problem HELP ;\</subject><body>

Hi
I have loop-aes since FC3 and everything was working just fine
 
Now i've just updated FC4 to FC5 and my problems begin.
I can't mount this partition.


I have compiled linux-2.6.16.1 kernel with CONFIG_BLK_DEV_LOOP = n
I've installed loop-AES-v3.1c.tar.bz2 and util-linux-2.12r.tar.gz  patched.
Everything seems to be ok

[root@fox src]# uname -r
2.6.16.1

[root@fox loop-AES-v3.1c]# make tests
...
md5sum test-file1 &gt;test-file2
echo "e12fd55fbae9fc0e03517593e253e239  test-file1" | cmp test-file2 -
cmp test-file3 test-file4
make[1]: Leaving directory `/usr/src/loop-AES-v3.1c'
rm -f -r test-file[1234] test-dir1
*** Test results ok ***


--- fstab ----------------
/dev/hda4 /mnt/szyfr ext2 
defaults,noauto,user,loop=/dev/loop0,encryption=AES128,gpgkey=/home/keyfile.gpg 
0 0
--- fstab ----------------

Unfortunately when I make

[root@fox loop-AES-v3.1c]# mount /mnt/szyfr/
Password:
mount: wrong fs type, bad option, bad superblock on /dev/loop0,
       missing codepage or other error
       In some cases useful info is found in syslog - try
       dmesg | tail  or so

Password is ok I'm sure.

What is wrong ?
is there any chance to mount this particion again ?
Have I forgotten about something?
I have tried my keyfile.gpg from backup but the effect was the same.


regards
vr


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060410181911</emailId><senderName>Mario Verbelen</senderName><senderEmail>mario@verbelen.org</senderEmail><timestampReceived>2006-04-10 18:19:11-0400</timestampReceived><subject>Re: loop-Aes mount problem HELP ;\</subject><body>

Hi,

I had the same issue 
try with the modprobe in you script
for me it is working

----
modprobe cryptoloop
losetup -e aes /dev/loop0 /data/encrypted.data
mount /dev/loop0 /crypt
-----

On Mon, 2006-04-10 at 20:07 +0200, robert wrote:
&gt; Hi
&gt; I have loop-aes since FC3 and everything was working just fine
&gt;  
&gt; Now i've just updated FC4 to FC5 and my problems begin.
&gt; I can't mount this partition.
&gt; 
&gt; 
&gt; I have compiled linux-2.6.16.1 kernel with CONFIG_BLK_DEV_LOOP = n
&gt; I've installed loop-AES-v3.1c.tar.bz2 and util-linux-2.12r.tar.gz  patched.
&gt; Everything seems to be ok
&gt; 
&gt; [root@fox src]# uname -r
&gt; 2.6.16.1
&gt; 
&gt; [root@fox loop-AES-v3.1c]# make tests
&gt; ...
&gt; md5sum test-file1 &gt;test-file2
&gt; echo "e12fd55fbae9fc0e03517593e253e239  test-file1" | cmp test-file2 -
&gt; cmp test-file3 test-file4
&gt; make[1]: Leaving directory `/usr/src/loop-AES-v3.1c'
&gt; rm -f -r test-file[1234] test-dir1
&gt; *** Test results ok ***
&gt; 
&gt; 
&gt; --- fstab ----------------
&gt; /dev/hda4 /mnt/szyfr ext2 
&gt; defaults,noauto,user,loop=/dev/loop0,encryption=AES128,gpgkey=/home/keyfile.gpg 
&gt; 0 0
&gt; --- fstab ----------------
&gt; 
&gt; Unfortunately when I make
&gt; 
&gt; [root@fox loop-AES-v3.1c]# mount /mnt/szyfr/
&gt; Password:
&gt; mount: wrong fs type, bad option, bad superblock on /dev/loop0,
&gt;        missing codepage or other error
&gt;        In some cases useful info is found in syslog - try
&gt;        dmesg | tail  or so
&gt; 
&gt; Password is ok I'm sure.
&gt; 
&gt; What is wrong ?
&gt; is there any chance to mount this particion again ?
&gt; Have I forgotten about something?
&gt; I have tried my keyfile.gpg from backup but the effect was the same.
&gt; 
&gt; 
&gt; regards
&gt; vr
&gt; 
&gt; 
&gt; -
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060413181921</emailId><senderName>John Tate</senderName><senderEmail>kintaro@aanet.com.au</senderEmail><timestampReceived>2006-04-13 18:19:21-0400</timestampReceived><subject>losetup-combined patch offline</subject><body>

Hey,

The patch here needed for cryptoloop volumes with keysize specified and
such (the losetup-combined.patch) located here:
http://www.stwing.org/~sluskyb/util-linux/losetup-combined.patch is
offline at the moment.

Does anyone have a copy?
Why is it not included with util-linux anyway?

I plan on moving to dm-crypt for these types of things but I have some
backup DVDs that use the cryptoloop system still and are unmountable
until I can get my hands on this patch.

Yours,
John.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060415110216</emailId><senderName>"Michael Garibaldi"</senderName><senderEmail>michaelgari@gmail.com</senderEmail><timestampReceived>2006-04-15 11:02:16-0400</timestampReceived><subject>Stealth crypto</subject><body>

Hi,

First of all - I'm a bit confused about the options. As far as I can
gather, there are
1.Kernel's cryptoloop
2. Kernel's dm-crypt
3. Jari Ruusu's (or documented by him?) cryptoloop

Out of these, 1 is clearly bad (documentation of all three say that it
is). However, dm-crypt's documentation does not mention #3 and #3's
documentation does not mention dm-crypt. So, what's the deal between
these?

Now to my actual problem. I want to crypt my entire hard disks. No,
not every partition of them, but everything, including the MBR (I
intend to boot from USB). This option is not even mentioned in the
documentation of either framework. Obviously I would have initrd-based
system for asking the passphares and setting the decryption. However,
I'd like to automate this process as far as possible - and for this, I
need to make the kernel read the decrypted devices as hard disks (i.e.
look for partition tables, RAID arrays, etc). Any pointers to get
going with this? I have a faint memory of the device mapper supporting
this, but I am unable to find any information about it.

Of course, this does not work if the crypto system still writes
unencrypted headers on the disk. Cryptoloop doesn't seem to be writing
any extra data, but I didn't check out if dm-crypt (with LUKS or not)
does.

Before you ask why - hiding the information that is inside is often
good enough, but it is much better if the disks look as if there was
only random garbage in them. Then no-one can prove that they are
encrypted and that may help avoiding trouble.

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060417214713</emailId><senderName></senderName><senderEmail>peter_22</senderEmail><timestampReceived>2006-04-17 21:47:13-0400</timestampReceived><subject>hdparm and Serial ATA</subject><body>

Hi!

Can someone help me with this?
suse:~ # hdparm -Y /dev/sdb

/dev/sdb:
 issuing sleep command
 HDIO_DRIVE_CMD(sleep) failed: Inappropriate ioctl for device

Why can´t serial ata drives (wd3200js) be turned off or at least put in
sleep mode with hdparm? Is it a lack of my kernel config or is hdparm the
wrong command?

Regards
Peter

-- 
Echte DSL-Flatrate dauerhaft für 0,- Euro*!
"Feel free" mit GMX DSL! http://www.gmx.net/de/go/dsl

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060417221650</emailId><senderName>markus reichelt</senderName><senderEmail>ml@bitfalle.org</senderEmail><timestampReceived>2006-04-17 22:16:50-0400</timestampReceived><subject>Re: hdparm and Serial ATA</subject><body>

* Peter_22@gmx.de wrote:

&gt; Why can´t serial ata drives (wd3200js) be turned off or at least
&gt; put in sleep mode with hdparm? Is it a lack of my kernel config or
&gt; is hdparm the wrong command?

from what i've come across it should work via hdparm. maybe a
manufacturer/vendor specific thing? hdparm doesn't seem to be updated
that often... like smartd is. have you asked the authors / tried
different kernel versions? with recent kernel versions, this may be
tricky.

i don't need/use SATA drives, tho, so i'm taking a wild guess here...

-- 
left blank, right bald

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060417032147</emailId><senderName>"Lohan Knight"</senderName><senderEmail>lohan_knight@hotmail.com</senderEmail><timestampReceived>2006-04-17 03:21:47-0400</timestampReceived><subject>loop-AES and RPM's in FC5</subject><body>


Hi,  I've been using loop-AES on my Red Hat 7.1 (ancient) system for
a while now,  probably since 2001.  Now I've upgraded to FC5 and
I'm faced with the difficult task of getting loop-AES working on it.

I've kept notes from my RH7.1 machine on what I had to do back
then,  and it looks like things haven't changed all that much for FC5.
I guess I'll find out soon.

My question has to do with incorporating loop-AES into FC5
while still allowing system maintenance using Yum / RPM's.

I'm new to using RPM's and Yum.  Prior to now I've just installed
things manually using tar files and such.  But now I see the light.
I want to keep things maintained rather than letting things get
out of control like before.  Before I just had to accept that my
system couldn't be upgraded without spending 8 hours tracking
down dependencies manually just to upgrade to the latest
version of Shockwave or something.  It was ridiculous.

So I see the value of using RPM's and Yum.  What I'd like
is an RPM that would let me use loop-AES for FC5.  I don't
think any exist.  Is that right?  And I'd like to just be able to
say "yum update" and not worry about having it install
something that breaks loop-AES stuff.

I know in the past the docs said to turn off the cryptoloop
driver and disable the loop device driver in the kernel config
settings.  Then recompile the kernel.  Then patch gnupg with
a patch file.  Then compile loop-AES which will copy a new
loop.o to /lib/modules. Then patch util-linux.  Then install
ciphers.

I assume the same process would be needed to install it
for FC5.

Problem is,  once I patch stuff manually,  I'm no longer able
to put those programs under RPM / Yum control.  Am I?  I
mean won't they just get overwritten once I do an update
("yum update")?  So I'd have to somehow remove it from
RPM control first,  which I don't know how to do yet.  And then
I'd have to manually update the various items (kernel,
util-linux, gnupg, loop-AES) from time to time,  which is
undesirable.

So how do you all handle this?  Do you just not update your
systems once you've gotten loop-AES working?  Or do you
create your own RPM's?  I don't know how to go about all
that.  It's new to me.  I know I have to learn more about Yum
and RPM package management.

Advice?

Thanks,
- Steve

_________________________________________________________________
Don’t just search. Find. Check out the new MSN Search! 
http://search.msn.click-url.com/go/onm00200636ave/direct/01/


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060417201224</emailId><senderName>Phil H</senderName><senderEmail>philtickle200@yahoo.com</senderEmail><timestampReceived>2006-04-17 20:12:24-0400</timestampReceived><subject>Re: loop-AES and RPM's in FC5</subject><body>

You might want to add an appropriate exclude line to /etc/yum.conf to prevent the \
utils and kernel from getting updated.  
  I'm not sure if mount, losetup and the other utils are all included in one package \
with Fedora (check), but assuming you want to exclude for eg a package starting with \
"mount" from being updated then you'd add the following line to /etc/yum.conf:  
  exclude=mount*
   
  Not sure if you have to exclude losetup, swapon, swapoff as well - probably.  Find \
out what packages these belong to and exclude these?  
  On doing an update, any package starting with "mount" then shouldn't get touched.
   
  A kernel update might (?) replace your new loop.o driver as well, or at least would \
no longer match it, so you should exclude the kernel from updating as well:  
  exclude=kernel*
   
  As for rpms - you could build your utils and loop.o driver into rpms using \
checkinstall if you want, but it's probbably of no advantage since you're only ever \
going to be manually compiling and replacing these anyway.  
   
  
Lohan Knight &lt;lohan_knight@hotmail.com&gt; wrote:
  
And I'd like to just be able to
say "yum update" and not worry about having it install
something that breaks loop-AES stuff.

I know in the past the docs said to turn off the cryptoloop
driver and disable the loop device driver in the kernel config
settings. Then recompile the kernel. Then patch gnupg with
a patch file. Then compile loop-AES which will copy a new
loop.o to /lib/modules. Then patch util-linux. Then install
ciphers.

I assume the same process would be needed to install it
for FC5.

Problem is, once I patch stuff manually, I'm no longer able
to put those programs under RPM / Yum control. Am I? I
mean won't they just get overwritten once I do an update
("yum update")? So I'd have to somehow remove it from
RPM control first, which I don't know how to do yet. And then
I'd have to manually update the various items (kernel,
util-linux, gnupg, loop-AES) from time to time, which is
undesirable.

So how do you all handle this? Do you just not update your
systems once you've gotten loop-AES working? Or do you
create your own RPM's? I don't know how to go about all
that. It's new to me. I know I have to learn more about Yum
and RPM package management.

Advice?

Thanks,
- Steve

_________________________________________________________________
Don’t just search. Find. Check out the new MSN Search! 
http://search.msn.click-url.com/go/onm00200636ave/direct/01/


-
Linux-crypto: cryptography in and on the Linux system
Archive: http://mail.nl.linux.org/linux-crypto/



		
---------------------------------
Talk is cheap. Use Yahoo! Messenger to make PC-to-Phone calls.  Great rates starting \
at 1¢/min.


[Attachment #3 (text/html)]

&lt;div&gt;You might want to add an appropriate exclude line to /etc/yum.conf to \
prevent the utils and kernel from getting updated.&lt;/div&gt;  &lt;div&gt; &lt;/div&gt;  &lt;div&gt;I'm \
not sure if mount, losetup and the other utils are all included in one package with \
Fedora (check), but assuming you want to exclude for eg a package starting with \
"mount" from being updated then you'd add the following line to \
/etc/yum.conf:&lt;/div&gt;  &lt;div&gt; &lt;/div&gt;  &lt;div&gt;exclude=mount*&lt;/div&gt;  &lt;div&gt; &lt;/div&gt; \
&lt;div&gt;Not sure if you have to exclude losetup, swapon, swapoff as well - \
probably.  Find out what packages these belong to and exclude these?&lt;/div&gt;  \
&lt;div&gt; &lt;/div&gt;  &lt;div&gt;On doing an update, any package starting with "mount" then \
shouldn't get touched.&lt;/div&gt;  &lt;div&gt; &lt;/div&gt;  &lt;div&gt;A kernel update might (?) \
replace your new loop.o driver as well, or at least would no longer match it, \
so you should exclude the kernel from updating as well:&lt;/div&gt;  &lt;div&gt; &lt;/div&gt; \
  &lt;div&gt;exclude=kernel*&lt;/div&gt;  &lt;div&gt; &lt;/div&gt;  &lt;div&gt;As for rpms - you could build \
your utils and loop.o driver into rpms using checkinstall if you want, but it's \
probbably of no advantage since you're only ever going to be manually compiling and \
replacing these anyway.&lt;/div&gt;  &lt;div&gt; &lt;/div&gt;  &lt;div&gt; &lt;/div&gt;  \
&lt;div&gt;&lt;BR&gt;&lt;B&gt;&lt;I&gt;Lohan Knight &lt;lohan_knight@hotmail.com&gt;&lt;/I&gt;&lt;/B&gt; wrote:&lt;/div&gt;  \
&lt;BLOCKQUOTE class=replbq style="PADDING-LEFT: 5px; MARGIN-LEFT: 5px; BORDER-LEFT: \
#1010ff 2px solid"&gt;&lt;BR&gt;And I'd like to just be able to&lt;BR&gt;say "yum update" and not \
worry about having it install&lt;BR&gt;something that breaks loop-AES stuff.&lt;BR&gt;&lt;BR&gt;I know \
in the past the docs said to turn off the cryptoloop&lt;BR&gt;driver and disable the loop \
device driver in the kernel config&lt;BR&gt;settings. Then recompile the kernel. Then patch \
gnupg with&lt;BR&gt;a patch file. Then compile loop-AES which will copy a new&lt;BR&gt;loop.o to \
/lib/modules. Then patch util-linux. Then install&lt;BR&gt;ciphers.&lt;BR&gt;&lt;BR&gt;I assume the  \
same process would be needed to install it&lt;BR&gt;for FC5.&lt;BR&gt;&lt;BR&gt;Problem is, once I \
patch stuff manually, I'm no longer able&lt;BR&gt;to put those programs under RPM / Yum \
control. Am I? I&lt;BR&gt;mean won't they just get overwritten once I do an update&lt;BR&gt;("yum \
update")? So I'd have to somehow remove it from&lt;BR&gt;RPM control first, which I don't \
know how to do yet. And then&lt;BR&gt;I'd have to manually update the various items \
(kernel,&lt;BR&gt;util-linux, gnupg, loop-AES) from time to time, which \
is&lt;BR&gt;undesirable.&lt;BR&gt;&lt;BR&gt;So how do you all handle this? Do you just not update \
your&lt;BR&gt;systems once you've gotten loop-AES working? Or do you&lt;BR&gt;create your own \
RPM's? I don't know how to go about all&lt;BR&gt;that. It's new to me. I know I have to \
learn more about Yum&lt;BR&gt;and RPM package \
management.&lt;BR&gt;&lt;BR&gt;Advice?&lt;BR&gt;&lt;BR&gt;Thanks,&lt;BR&gt;- \
Steve&lt;BR&gt;&lt;BR&gt;_________________________________________________________________&lt;BR&gt;Don’t \
just search. Find. Check out the new MSN Search!  \
&lt;BR&gt;http://search.msn.click-url.com/go/onm00200636ave/direct/01/&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;-&lt;BR&gt;Linux-crypto: \
cryptography in and on the Linux system&lt;BR&gt;Archive: \
http://mail.nl.linux.org/linux-crypto/&lt;BR&gt;&lt;BR&gt;&lt;/BLOCKQUOTE&gt;&lt;BR&gt;&lt;p&gt;  &lt;hr size=1&gt;Talk \
is cheap. Use Yahoo! Messenger to make PC-to-Phone calls. &lt;a \
href="http://us.rd.yahoo.com/mail_us/taglines/postman7/*http://us.rd.yahoo.com/evt=39666/*http://beta.messenger.yahoo.com"&gt; \
Great rates starting at 1¢/min.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060417222641</emailId><senderName>Justin Piszcz</senderName><senderEmail>jpiszcz@lucidpixels.com</senderEmail><timestampReceived>2006-04-17 22:26:41-0400</timestampReceived><subject>Re: hdparm and Serial ATA</subject><body>

There is an hdparm variant for SCSI (SATA) if you search google, hdparm is 
for IDE disks primarily.


On Mon, 17 Apr 2006, Peter_22@gmx.de wrote:

&gt; Hi!
&gt;
&gt; Can someone help me with this?
&gt; suse:~ # hdparm -Y /dev/sdb
&gt;
&gt; /dev/sdb:
&gt; issuing sleep command
&gt; HDIO_DRIVE_CMD(sleep) failed: Inappropriate ioctl for device
&gt;
&gt; Why can´t serial ata drives (wd3200js) be turned off or at least put in
&gt; sleep mode with hdparm? Is it a lack of my kernel config or is hdparm the
&gt; wrong command?
&gt;
&gt; Regards
&gt; Peter
&gt;
&gt; -- 
&gt; Echte DSL-Flatrate dauerhaft für 0,- Euro*!
&gt; "Feel free" mit GMX DSL! http://www.gmx.net/de/go/dsl
&gt;
&gt; -
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/
&gt;
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060415165827</emailId><senderName>Venkat Manakkal</senderName><senderEmail>venkat@rayservers.com</senderEmail><timestampReceived>2006-04-15 16:58:27-0400</timestampReceived><subject>Re: Stealth crypto</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Michael,

On 04/15/2006 07:02 AM, Michael Garibaldi wrote:
| 3. Jari Ruusu's (or documented by him?) cryptoloop

Jari is the author of loop-aes.

| Now to my actual problem. I want to crypt my entire hard disks. No,
| not every partition of them, but everything, including the MBR (I
| intend to boot from USB). This option is not even mentioned in the

Follow the instructions in Jari's readme:

http://loop-aes.sourceforge.net/loop-AES.README

for encrypted root. That can be extended for the entire disk if you boot from
CDROM or USB using the entire disk /dev/sda for instance.

1. Follow the instructions to created an encrypted root partition that boots
from your USB or CDROM.
2. Boot knoppix, mount that partition, back it up to another machine temporarily.
3. Shred the drive
4. Set up loop-aes using the entire HD, then untar the install.
5. Ensure that you have an initrd where the CRYPTROOT is the entire disk, then
~ you can boot the entire drive.

Alternativey you can just use Knoppix and store your transient data alone on
the entire HD.

Sorry the above are general instructions, but if you can follow Jari's
instructions to create a fully encrypted /dev/sda1 then you can easily take
the above hint and use it on the entire HD.

Jari has also posted to this list about how to reference a portion of the disk
without a parition table:

http://mail.nl.linux.org/linux-crypto/2005-04/msg00001.html

Cheers,

- ---Venkat.

- --
http://rayservers.com/       skype: rayservers       +1-607-546-7300
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.2 (GNU/Linux)

iD8DBQFEQSYxWdkW/RJDBSIRAlaLAJ95s9UWH9iwHU9NiR6yptu4KFmUfACffvAu
iRQi/oFbVtDjxoDPrbmyDUQ=
=/LaB
-----END PGP SIGNATURE-----

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060415194503</emailId><senderName>markus reichelt</senderName><senderEmail>ml@bitfalle.org</senderEmail><timestampReceived>2006-04-15 19:45:03-0400</timestampReceived><subject>Re: Stealth crypto</subject><body>

* Michael Garibaldi &lt;michaelgari@gmail.com&gt; wrote:

&gt; First of all - I'm a bit confused about the options. As far as I can
&gt; gather, there are
&gt; 1.Kernel's cryptoloop
&gt; 2. Kernel's dm-crypt
&gt; 3. Jari Ruusu's (or documented by him?) cryptoloop
&gt; 
&gt; Out of these, 1 is clearly bad (documentation of all three say that it
&gt; is). However, dm-crypt's documentation does not mention #3 and #3's
&gt; documentation does not mention dm-crypt. So, what's the deal between
&gt; these?

cryptoloop, dm-crypt, and loop-AES are three different crypto
implementations on linux systems: 

Cryptographic API is built-in in modern 2.6 mainline kernels; vendor
kernels are derived from these. Cryptoloop stands for using the
Cryptographic API via the loop-device, hence it's often referred to
as "mainline cryptoloop".

dm-crypt is a so-called device-mapper target that provides
transparent de/encryption of block devices using the Cryptographic
API.

Both cryptoloop and dm-crypt in kernels prior to 2.6.10 are
vulnerable, and even recent dm-crypt still suffers from a weak crypto
implementation.

loop-AES is a package that provides loadable linux kernel modules
that allow you to safely de/encrypt disk partitions. It does not
modify the kernel in any way.

-- 
left blank, right bald

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060416003003</emailId><senderName>"Michael Garibaldi"</senderName><senderEmail>michaelgari@gmail.com</senderEmail><timestampReceived>2006-04-16 00:30:03-0400</timestampReceived><subject>Re: Stealth crypto</subject><body>

&gt;
&gt; for encrypted root. That can be extended for the entire disk if you boot
&gt; from
&gt; CDROM or USB using the entire disk /dev/sda for instance.
&gt;

This is not very useful, as I'll end up with a bunch of /dev/loop* devices
then. Those devices would have partition tables in them, and in particular,
they contain RAID arrays (partition type RAID autodetect). It is difficult
to keep track of which HDD is which, but if the kernel can autodetect that,
it'll be a lot easier. That is why I want the kernel to read them as HDDs,
rather than just provide me some block devices.

The above is only my solution to the problem. There probably are others
(that still do things automatically!), but this was the first thing that I
thought about.

Example:

1. Setup cryptoloops
/dev/sda = /dev/loop0
/dev/sdb = /dev/loop1
/dev/sdc = /dev/loop2
2. Let the kernel detect them as HDDs
/dev/loop0 = HDD =&gt; kernel detects partitions
/dev/loop0-partition1 = RAID-5 md0 disk 2
/dev/loop0-partition2 = RAID-1 md1 disk 0
/dev/loop1 = HDD =&gt; kernel detects partitions
/dev/loop1-partition1 = RAID-1 md1 disk 1
/dev/loop1-partition2 = RAID-5 md0 disk 1
/dev/loop2-partition2 = RAID-5 md0 disk 0
3. The kernel found RAID partitions, so it automatically assembles them:
/dev/md0 = my RAID-5
/dev/md1 = my RAID-1
4. I can easily mount /dev/md1 as root, etc.

If the kernel cannot detect them that way, I have serious trouble trying to
figure out where exactly is each partition, which array it belongs to, etc.

[Attachment #3 (text/html)]

&lt;div&gt;&lt;blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, \
204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"&gt;for encrypted root. That can be \
extended for the entire disk if you boot from&lt;br&gt;CDROM or USB using the entire disk \
/dev/sda for instance. &lt;br&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;This is not very useful, as I'll \
end up with a bunch of /dev/loop* devices then. Those devices would have partition \
tables in them, and in particular, they contain RAID arrays (partition type RAID \
autodetect). It is difficult to keep track of which HDD is which, but if the kernel \
can autodetect that, it'll be a lot easier. That is why I want the kernel to read \
them as HDDs, rather than just provide me some block devices. &lt;br&gt;&lt;br&gt;The above is \
only my solution to the problem. There probably are others (that still do things \
automatically!), but this was the first thing that I thought \
about.&lt;br&gt;&lt;br&gt;Example:&lt;br&gt;&lt;br&gt;1. Setup cryptoloops&lt;br&gt;/dev/sda = /dev/loop0 \
&lt;br&gt;/dev/sdb = /dev/loop1&lt;br&gt;/dev/sdc = /dev/loop2&lt;br&gt; 2. Let the kernel detect them \
as HDDs&lt;br&gt;/dev/loop0 = HDD =&gt; kernel detects partitions&lt;br&gt;/dev/loop0-partition1 \
= RAID-5 md0 disk 2&lt;br&gt;/dev/loop0-partition2 = RAID-1 md1 disk 0&lt;br&gt;/dev/loop1 = HDD \
=&gt; kernel detects partitions &lt;br&gt;/dev/loop1-partition1 = RAID-1 md1 disk \
1&lt;br&gt;/dev/loop1-partition2 = RAID-5 md0 disk 1&lt;br&gt;/dev/loop2-partition2 = RAID-5 md0 \
disk 0&lt;br&gt;3. The kernel found RAID partitions, so it automatically assembles \
them:&lt;br&gt;/dev/md0 = my RAID-5 &lt;br&gt;/dev/md1 = my RAID-1&lt;br&gt;4. I can easily mount \
/dev/md1 as root, etc.&lt;br&gt;&lt;br&gt;If the kernel cannot detect them that way, I have \
serious trouble trying to figure out where exactly is each partition, which array it \
belongs to, etc. &lt;br&gt;&lt;br&gt; 


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060414053753</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-04-14 05:37:53-0400</timestampReceived><subject>Re: losetup-combined patch offline</subject><body>

On Fri, Apr 14, 2006 at 04:19:21AM +1000, John Tate (kintaro@aanet.com.au) wrote:
&gt; Hey,
&gt; 
&gt; The patch here needed for cryptoloop volumes with keysize specified and
&gt; such (the losetup-combined.patch) located here:
&gt; http://www.stwing.org/~sluskyb/util-linux/losetup-combined.patch is
&gt; offline at the moment.
&gt; 
&gt; Does anyone have a copy?
&gt; Why is it not included with util-linux anyway?

Probably because cryptoloop is suspended?

&gt; I plan on moving to dm-crypt for these types of things but I have some
&gt; backup DVDs that use the cryptoloop system still and are unmountable
&gt; until I can get my hands on this patch.

dm-crypt is backward compatible with cryptoloop.

&gt; Yours,
&gt; John.

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060414094327</emailId><senderName>John Tate</senderName><senderEmail>kintaro@aanet.com.au</senderEmail><timestampReceived>2006-04-14 09:43:27-0400</timestampReceived><subject>Re: losetup-combined patch offline</subject><body>

I knew cryptoloop was suspended, didn't know dm-crypt was backwards
compatible though.

Thanks.

On Fri, 2006-04-14 at 09:37 +0400, Evgeniy Polyakov wrote:
&gt; On Fri, Apr 14, 2006 at 04:19:21AM +1000, John Tate (kintaro@aanet.com.au) wrote:
&gt; &gt; Hey,
&gt; &gt; 
&gt; &gt; The patch here needed for cryptoloop volumes with keysize specified and
&gt; &gt; such (the losetup-combined.patch) located here:
&gt; &gt; http://www.stwing.org/~sluskyb/util-linux/losetup-combined.patch is
&gt; &gt; offline at the moment.
&gt; &gt; 
&gt; &gt; Does anyone have a copy?
&gt; &gt; Why is it not included with util-linux anyway?
&gt; 
&gt; Probably because cryptoloop is suspended?
&gt; 
&gt; &gt; I plan on moving to dm-crypt for these types of things but I have some
&gt; &gt; backup DVDs that use the cryptoloop system still and are unmountable
&gt; &gt; until I can get my hands on this patch.
&gt; 
&gt; dm-crypt is backward compatible with cryptoloop.
&gt; 
&gt; &gt; Yours,
&gt; &gt; John.
&gt; 
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060410183203</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-04-10 18:32:03-0400</timestampReceived><subject>Re: loop-Aes mount problem HELP ;\</subject><body>

robert wrote:
&gt; What is wrong ?
&gt; is there any chance to mount this particion again ?
&gt; Have I forgotten about something?
&gt; I have tried my keyfile.gpg from backup but the effect was the same.

Plan A: Try using 64 line key file

    # gpg --decrypt &lt;/home/keyfile.gpg | head -n 64 | \
        ( sleep 60 ; gpg -a --symmetric &gt;/home/keyfile64.gpg )

    And then try it with /home/keyfile64.gpg key file

Plan B: Try using 1 line key file

    # gpg --decrypt &lt;/home/keyfile.gpg | head -n 1 | \
        ( sleep 60 ; gpg -a --symmetric &gt;/home/keyfile1.gpg )

    And then try it with /home/keyfile1.gpg key file

Plan C: Try using old /bin/mount program from FC3.

Plan D: Try adding one of these mount options to /etc/fstab

    phash=rmd160
    phash=unhashed2

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060410194701</emailId><senderName>robert</senderName><senderEmail>robert@netend.pl</senderEmail><timestampReceived>2006-04-10 19:47:01-0400</timestampReceived><subject>Re: loop-Aes mount problem HELP ;\</subject><body>

Jari Ruusu wrote:
&gt; Plan A: Try using 64 line key file
&gt;
&gt;     # gpg --decrypt &lt;/home/keyfile.gpg | head -n 64 | \
&gt;         ( sleep 60 ; gpg -a --symmetric &gt;/home/keyfile64.gpg )
&gt;
&gt;     And then try it with /home/keyfile64.gpg key file
&gt;
&gt; Plan B: Try using 1 line key file
&gt;
&gt;     # gpg --decrypt &lt;/home/keyfile.gpg | head -n 1 | \
&gt;         ( sleep 60 ; gpg -a --symmetric &gt;/home/keyfile1.gpg )
&gt;
&gt;     And then try it with /home/keyfile1.gpg key file
&gt;
&gt; Plan C: Try using old /bin/mount program from FC3.
&gt;
&gt; Plan D: Try adding one of these mount options to /etc/fstab
&gt;
&gt;     phash=rmd160
&gt;     phash=unhashed2
&gt;   
THANKS ! :}
I've tried Plan A: &amp; Plan B:

Plan B:
Generated key was short
and when i tried to mount with it error was the same as  with 'master' key.

   236  keyfile1.gpg
   4221 keyfile64.gpg
   4284 keyfily.gpg
 


Plan A:" Was FULL SUCCESS !
 
# gpg --decrypt &lt;/home/keyfile.gpg | head -n 64 | ( sleep 60 ; gpg -a 
--symmetric &gt;/home/keyfile64.gpg )
gpg: CAST5 encrypted data
gpg: encrypted with 1 passphrase
gpg: WARNING: message was not integrity protected

-- fstab --
/dev/hda4               /mnt/szyfr/               ext2    
defaults,noauto,user,loop=/dev/loop0,encryption=AES128,gpgkey=/home/keyfile64.gpg 
0
---------
#  mount /mnt/szyfr/
# df -h /mnt/szyfr/

Filesystem   Size   Mounted on
/dev/hda4   153G  /mnt/szyfr/

 :}
So what just happened ?
I have to use  keyfile64.gpg  now and in the future ?

thanks again for help
vr





-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060403212105</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-04-03 21:21:05-0400</timestampReceived><subject>Re: [PATCH] crypto: add alignment handling to digest layer</subject><body>

On Tue, Apr 04, 2006 at 12:04:07AM +0900, Atsushi Nemoto wrote:
&gt; 
&gt; Some hash modules load/store data words directly.  The digest layer
&gt; should pass properly aligned buffer to update()/final() method.  This
&gt; patch also add cra_alignmask to some hash modules.

This patch is in my queue.  I'll be travelling for the next couple of
weeks but I'll get onto it after that.

Thanks,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060405180520</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-04-05 18:05:20-0400</timestampReceived><subject>Re: [PATCH] crypto: add alignment handling to digest layer</subject><body>

On Tue, Apr 04, 2006 at 12:04:07AM +0900, Atsushi Nemoto wrote:
&gt;
&gt; @@ -38,12 +39,24 @@ static void update(struct crypto_tfm *tf
&gt;  			unsigned int bytes_from_page = min(l, ((unsigned int)
&gt;  							   (PAGE_SIZE)) - 
&gt;  							   offset);
&gt; -			char *p = crypto_kmap(pg, 0) + offset;
&gt; +			char *src = crypto_kmap(pg, 0);
&gt; +			char *p = src + offset;
&gt;  
&gt; +			if (unlikely(offset &amp; alignmask)) {
&gt; +				unsigned int bytes =
&gt; +					alignmask + 1 - (offset &amp; alignmask);
&gt; +				bytes = min(bytes, bytes_from_page);
&gt; +				tfm-&gt;__crt_alg-&gt;cra_digest.dia_update
&gt; +						(crypto_tfm_ctx(tfm), p,
&gt; +						 bytes);

Don't we need to copy this to an aligned buffer?

Thanks,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060406023742</emailId><senderName>Atsushi Nemoto</senderName><senderEmail>anemo@mba.ocn.ne.jp</senderEmail><timestampReceived>2006-04-06 02:37:42-0400</timestampReceived><subject>Re: [PATCH] crypto: add alignment handling to digest layer</subject><body>

On Thu, 6 Apr 2006 04:05:20 +1000, Herbert Xu &lt;herbert@gondor.apana.org.au&gt; wrote:
&gt; Don't we need to copy this to an aligned buffer?

We don't.  I think update functions do not need an aligned buffer for
data which is smaller then the alignment size.

---
Atsushi Nemoto
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060406232454</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-04-06 23:24:54-0400</timestampReceived><subject>Re: [PATCH] crypto: add alignment handling to digest layer</subject><body>

On Thu, Apr 06, 2006 at 11:37:42AM +0900, Atsushi Nemoto wrote:
&gt; 
&gt; We don't.  I think update functions do not need an aligned buffer for
&gt; data which is smaller then the alignment size.

You're right.  If we do ever get any hardware that requires this we can
always change it later on.

Another thing, could you pleas change the stack allocation in final so
that it does it like cbc_process_decrypt? The reason is that gcc is too
stupid to not allocate that buffer unconditionally.

Thanks,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060407052755</emailId><senderName>Atsushi Nemoto</senderName><senderEmail>anemo@mba.ocn.ne.jp</senderEmail><timestampReceived>2006-04-07 05:27:55-0400</timestampReceived><subject>Re: [PATCH] crypto: add alignment handling to digest layer</subject><body>

On Fri, 7 Apr 2006 09:24:54 +1000, Herbert Xu &lt;herbert@gondor.apana.org.au&gt; wrote:
&gt; Another thing, could you pleas change the stack allocation in final so
&gt; that it does it like cbc_process_decrypt? The reason is that gcc is too
&gt; stupid to not allocate that buffer unconditionally.

I can do it, but it will add another overhead.  (we must call
crypto_tfm_alg_digestsize() unconditionally)

It seems modern gcc (at least gcc 3.4 on i386 and mips) can allocate
the buffer conditionally.  It is better to optimize for newer gcc,
isn't it?

---
Atsushi Nemoto
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060407054951</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-04-07 05:49:51-0400</timestampReceived><subject>Re: [PATCH] crypto: add alignment handling to digest layer</subject><body>

On Fri, Apr 07, 2006 at 02:27:55PM +0900, Atsushi Nemoto wrote:
&gt; 
&gt; It seems modern gcc (at least gcc 3.4 on i386 and mips) can allocate
&gt; the buffer conditionally.  It is better to optimize for newer gcc,
&gt; isn't it?

Of course it does.  I must've been confused.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060408180014</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-04-08 18:00:14-0400</timestampReceived><subject>Re: Automated fsck on boot</subject><body>

Max Vozeler wrote:
&gt; I'm looking for a user-friendly way to manage automated fsck of
&gt; encrypted loop devices during boot. The current way of managing
&gt; fscks (losetup -F, fsck, losetup -d, mount) has one big downside
&gt; from a usability perspective: It requires the user to enter the
&gt; passphrase twice each time the system boots.
&gt; 
&gt; Today I thought of something else that could work, I'm attaching
&gt; a quick proof-of-concept patch to describe it. The idea is that we
&gt; could do losetup -F, fsck, leave the loop device allocated and have
&gt; mount later re-use the loop device. It would require no changes
&gt; apart from an optional init script to take care of the fsck.
&gt; 
&gt; What do you think about this approach?

Cool. But mount code needs one more check: it must make sure that loop
backing device is exactly the one it is supposed to be. Not checking that
could be security hole. It also prevents "pilot errors" that occasionally
happen, even to me. Mount refusing to mount because a loop device was
already in other use has saved my ass multiple times.  :)

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060408224244</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-04-08 22:42:44-0400</timestampReceived><subject>Re: Automated fsck on boot</subject><body>

Hi Jari,

On Sat, Apr 08, 2006 at 09:00:14PM +0300, Jari Ruusu wrote:
&gt; Cool. But mount code needs one more check: it must make sure that
&gt; loop backing device is exactly the one it is supposed to be. Not
&gt; checking that could be security hole. It also prevents "pilot
&gt; errors" that occasionally happen, even to me. Mount refusing to
&gt; mount because a loop device was already in other use has saved my
&gt; ass multiple times.  :)

I'm happy that you like the idea. :-)

Does the attached version do the right thing in this regard? It
works for me and takes the normal code path if lo_file_name doesn't
match the loopfile that was given in *spec.

cheers,
Max

["2.12r_reuse_loop_v2.diff" (text/plain)]

--- 2.12r/mount/lomount.c~	2006-04-09 00:17:29.000000000 +0200
+++ 2.12r/mount/lomount.c	2006-04-09 00:17:47.000000000 +0200
@@ -202,6 +202,30 @@
 	return 0;
 }
 
+int is_loop_active(const char *dev, const char *backdev)
+{
+	int fd;
+	int ret = 0;
+	struct stat statbuf;
+	struct loop_info64 loopinfo;
+	if (stat (dev, &amp;statbuf) == 0 &amp;&amp; S_ISBLK(statbuf.st_mode)) {
+		fd = open (dev, O_RDONLY);
+		if (fd &lt; 0)
+			return 0;
+		if (is_unused_loop_device(fd) == 0) {
+			if (loop_get_status64_ioctl(fd, &amp;loopinfo) &lt; 0) {
+				close (fd);
+				return 0;
+			}
+			loopinfo.lo_file_name[LO_NAME_SIZE-1] = 0;
+			if (!strcmp((char *)loopinfo.lo_file_name, backdev))
+				ret = 1; /* backing device matches */
+		}
+		close(fd);
+	}
+	return ret;
+}
+
 static int rd_wr_retry(int fd, char *buf, int cnt, int w)
 {
 	int x, y, z;
--- 2.12r/mount/lomount.h~	2006-04-09 00:17:29.000000000 +0200
+++ 2.12r/mount/lomount.h	2006-04-09 00:17:47.000000000 +0200
@@ -2,6 +2,7 @@
 extern int set_loop(const char *, const char *, int *, const char **, unsigned int *);
 extern int del_loop(const char *);
 extern int is_loop_device(const char *);
+extern int is_loop_active(const char *, const char *);
 extern char * find_unused_loop_device(void);
 
 extern char *passFDnumber;
--- 2.12r/mount/mount.c~	2006-04-09 00:17:29.000000000 +0200
+++ 2.12r/mount/mount.c	2006-04-09 00:17:47.000000000 +0200
@@ -682,6 +682,10 @@
     if (fake) {
       if (verbose)
 	printf(_("mount: skipping the setup of a loop device\n"));
+    } else if (*loopdev &amp;&amp; is_loop_active(*loopdev, *loopfile)) {
+      if (verbose)
+	printf(_("mount: skipping the setup of a loop device\n"));
+      *spec = *loopdev;
     } else {
       int loopro = (*flags &amp; MS_RDONLY);
 

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060409081455</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-04-09 08:14:55-0400</timestampReceived><subject>Re: Automated fsck on boot</subject><body>

Max Vozeler wrote:
&gt; Does the attached version do the right thing in this regard? It
&gt; works for me and takes the normal code path if lo_file_name doesn't
&gt; match the loopfile that was given in *spec.

Your version compared device (or file) names. Comparing names is problematic
because they may be truncated or they may use relative paths (not begin with
slash). I changed it to compare device number and inode number of the block
special file (or normal file) to those recorded in loop device.

# losetup /dev/loop6
/dev/loop6: [0902]:213045 (/dev/md5) offset=4096 encryption=AES128 multi-key-v3
             ^^^^  ^^^^^^
              |      |
              |    Inode number inside my root file system where static
              |    block special node /dev/md5 happens to reside.
              |
             Device number of my root file system where static
             block special node /dev/md5 happens to reside.


I merged your patch, but now the code looks like this:

int is_loop_active(const char *dev, const char *backdev)
{
	int fd;
	int ret = 0;
	struct stat statbuf;
	struct loop_info64 loopinfo;
	if (stat (dev, &amp;statbuf) == 0 &amp;&amp; S_ISBLK(statbuf.st_mode)) {
		fd = open (dev, O_RDONLY);
		if (fd &lt; 0)
			return 0;
		if ((loop_get_status64_ioctl(fd, &amp;loopinfo) == 0)
		    &amp;&amp; (stat (backdev, &amp;statbuf) == 0)
		    &amp;&amp; (statbuf.st_dev == loopinfo.lo_device)
		    &amp;&amp; (statbuf.st_ino == loopinfo.lo_inode))
			ret = 1; /* backing device matches */
		memset(&amp;loopinfo, 0, sizeof(loopinfo));
		close(fd);
	}
	return ret;
}

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060403150518</emailId><senderName>Atsushi Nemoto</senderName><senderEmail>anemo@mba.ocn.ne.jp</senderEmail><timestampReceived>2006-04-03 15:05:18-0400</timestampReceived><subject>Re: [PATCH] crypto: fix unaligned access in khazad module</subject><body>

Ping.  This patch can be applied cleanly to 2.6.17-rc1.


On 64-bit platform, reading directly from keys (which supposed to be
32-bit aligned) will result in unaligned access.

Signed-off-by: Atsushi Nemoto &lt;anemo@mba.ocn.ne.jp&gt;

diff --git a/crypto/khazad.c b/crypto/khazad.c
index 807f2bf..c7e1d25 100644
--- a/crypto/khazad.c
+++ b/crypto/khazad.c
@@ -26,6 +26,7 @@
 #include &lt;asm/scatterlist.h&gt;
 #include &lt;linux/crypto.h&gt;
 #include &lt;linux/types.h&gt;
+#include &lt;asm/unaligned.h&gt;
 
 #define KHAZAD_KEY_SIZE		16
 #define KHAZAD_BLOCK_SIZE	8
@@ -769,8 +770,8 @@ static int khazad_setkey(void *ctx_arg, 
 		return -EINVAL;
 	}
 
-	K2 = be64_to_cpu(key[0]);
-	K1 = be64_to_cpu(key[1]);
+	K2 = be64_to_cpu(get_unaligned(&amp;key[0]));
+	K1 = be64_to_cpu(get_unaligned(&amp;key[1]));
 
 	/* setup the encrypt key */
 	for (r = 0; r &lt;= KHAZAD_ROUNDS; r++) {
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060403231122</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-04-03 23:11:22-0400</timestampReceived><subject>Re: [PATCH] crypto: fix unaligned access in khazad module</subject><body>

On Tue, Apr 04, 2006 at 12:05:18AM +0900, Atsushi Nemoto wrote:
&gt; 
&gt; -	K2 = be64_to_cpu(key[0]);
&gt; -	K1 = be64_to_cpu(key[1]);
&gt; +	K2 = be64_to_cpu(get_unaligned(&amp;key[0]));
&gt; +	K1 = be64_to_cpu(get_unaligned(&amp;key[1]));

Would it be possible to turn these into two 32-bit aligned reads instead?

Thanks,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060404075552</emailId><senderName>Atsushi Nemoto</senderName><senderEmail>anemo@mba.ocn.ne.jp</senderEmail><timestampReceived>2006-04-04 07:55:52-0400</timestampReceived><subject>Re: [PATCH] crypto: fix unaligned access in khazad module</subject><body>

On Tue, 4 Apr 2006 09:11:22 +1000, Herbert Xu &lt;herbert@gondor.apana.org.au&gt; wrote:
&gt; &gt; -	K2 = be64_to_cpu(key[0]);
&gt; &gt; -	K1 = be64_to_cpu(key[1]);
&gt; &gt; +	K2 = be64_to_cpu(get_unaligned(&amp;key[0]));
&gt; &gt; +	K1 = be64_to_cpu(get_unaligned(&amp;key[1]));
&gt; 
&gt; Would it be possible to turn these into two 32-bit aligned reads instead?

Done now.  I've missed your comment on 10 Mar, sorry for duplication.


On 64-bit platform, reading 64-bit keys (which is supposed to be
32-bit aligned) at a time will result in unaligned access.

Signed-off-by: Atsushi Nemoto &lt;anemo@mba.ocn.ne.jp&gt;

diff --git a/crypto/khazad.c b/crypto/khazad.c
index 807f2bf..5b8dc9a 100644
--- a/crypto/khazad.c
+++ b/crypto/khazad.c
@@ -758,7 +758,7 @@ static int khazad_setkey(void *ctx_arg, 
                        unsigned int key_len, u32 *flags)
 {
 	struct khazad_ctx *ctx = ctx_arg;
-	const __be64 *key = (const __be64 *)in_key;
+	const __be32 *key = (const __be32 *)in_key;
 	int r;
 	const u64 *S = T7;
 	u64 K2, K1;
@@ -769,8 +769,9 @@ static int khazad_setkey(void *ctx_arg, 
 		return -EINVAL;
 	}
 
-	K2 = be64_to_cpu(key[0]);
-	K1 = be64_to_cpu(key[1]);
+	/* key is supposed to be 32-bit aligned */
+	K2 = ((u64)be32_to_cpu(key[0]) &lt;&lt; 32) | be32_to_cpu(key[1]);
+	K1 = ((u64)be32_to_cpu(key[2]) &lt;&lt; 32) | be32_to_cpu(key[3]);
 
 	/* setup the encrypt key */
 	for (r = 0; r &lt;= KHAZAD_ROUNDS; r++) {
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060410135324</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-04-10 13:53:24-0400</timestampReceived><subject>Announce loop-AES-v3.1d file/swap crypto package</subject><body>

loop-AES changes since previous release:
- Fixed Makefile incompatibility with USE_KBUILD=y build option.
- Fixed incompatibility with CONFIG_PAX_KERNEXEC=y PAX config option.
- Fixed incompatibility with old SuSE 8.0 kernel that caused scheduler
  interface to be misdetected.
- Changed mount to honor offset=N and sizelimit=N mount options when they
  were used in combination with random keys generating phash=random mount
  option. Old encrypted data is used in new keys generation, but earlier
  buggy version always read and erased old data at offset=0.
- Added mount patch from Max Vozeler that makes it easier to first fsck and
  then mount encrypted file systems.

bzip2 compressed tarball is here:

    http://loop-aes.sourceforge.net/loop-AES/loop-AES-v3.1d.tar.bz2
    md5sum b4d13d6421382ea048e113ad8a868dfa

    http://loop-aes.sourceforge.net/loop-AES/loop-AES-v3.1d.tar.bz2.sign


Additional ciphers package changes since previous release:
- Fixed Makefile incompatibility with USE_KBUILD=y build option.

bzip2 compressed tarball is here:

    http://loop-aes.sourceforge.net/ciphers/ciphers-v3.0d.tar.bz2
    md5sum 65d5e85b3aabd5a36a199814c66cd7f9

    http://loop-aes.sourceforge.net/ciphers/ciphers-v3.0d.tar.bz2.sign

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060410200715</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-04-10 20:07:15-0400</timestampReceived><subject>Re: loop-Aes mount problem HELP ;\</subject><body>

robert wrote:
&gt; Jari Ruusu wrote:
&gt; &gt; Plan A: Try using 64 line key file
&gt; &gt;
&gt; &gt;     # gpg --decrypt &lt;/home/keyfile.gpg | head -n 64 | \
&gt; &gt;         ( sleep 60 ; gpg -a --symmetric &gt;/home/keyfile64.gpg )
&gt; &gt;
&gt; &gt;     And then try it with /home/keyfile64.gpg key file
&gt;
&gt; Plan A:" Was FULL SUCCESS !
[snip]
&gt; So what just happened ?

You used loop-AES-v2 mount and losetup binaries with version 3 key file.
Number of lines in key file determine on-disk format: 1 line == v1 format,
64 lines == v2 format, 65 lines == v3 format. Mount from loop-AES-v2 did not
userstand v3 on-disk format and set ip up in v2 format anyway. Mount from
loop-AES-v3 detected v3 format key file and used v3 on-disk format. It was
not compatible as you noticed.

This is explained in README section 7.

Type "losetup /dev/loop0" and it says multi-key-v2

&gt; I have to use  keyfile64.gpg  now and in the future ?

Yes.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060412095017</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-04-12 09:50:17-0400</timestampReceived><subject>New asycnhronous crypto layer (acrypto) release.</subject><body>

Acrypto [1] - asynchronous crypto layer for linux kernel 2.6

New acrypto combined patch for 2.6.15 kernel tree has been released, which
fixes IPsec ESP4 tunnel mode processing and initialization dependency on
connector when acrypto is built statically.
Many thanks to Yakov Lerner for testing.
Patch [2] is available in archive [3].

New standalone acrypto source released. It is a sync with combined
patch, so it only includes resolution of dependency on connector when
acrypto is built statically. It is available in archive [3].

Main work is concentrated on 2.6.16 IPsec port, which was noticebly
changed after 2.6.15.

1. http://tservice.net.ru/~s0mbre/old/?section=projects&amp;item=acrypto
2. http://tservice.net.ru/~s0mbre/archive/acrypto/drivers/acrypto-combined-2.6.15.diff.2
3. http://tservice.net.ru/~s0mbre/archive/acrypto

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060413083859</emailId><senderName>Jens Stein</senderName><senderEmail>kmorning@gmx.de</senderEmail><timestampReceived>2006-04-13 08:38:59-0400</timestampReceived><subject>(kein Betreff)</subject><body>

UNSUBSCRIBE

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060415113656</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-04-15 11:36:56-0400</timestampReceived><subject>2.6.16 ESP4 IPsec processing ported to acrypto.</subject><body>

New acrypto combined patch for 2.6.16 kernel tree has been released,
which includes asynchronous crypto layer [1] acrypto, dm-crypt, 
ESP4 IPsec processing and software crypto provider ported to acrypto.
Patch [2] and other acrypto drivers are available in archive [3].

1. http://tservice.net.ru/~s0mbre/old/?section=projects&amp;item=acrypto
2. http://tservice.net.ru/~s0mbre/archive/acrypto/drivers/acrypto-combined-2.6.16.diff.1
3. http://tservice.net.ru/~s0mbre/archive/acrypto

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060417144942</emailId><senderName>Ben Slusky</senderName><senderEmail>sluskyb@paranoiacs.org</senderEmail><timestampReceived>2006-04-17 14:49:42-0400</timestampReceived><subject>Re: losetup-combined patch offline</subject><body>

On Fri, 14 Apr 2006 04:19:21 +1000, John Tate wrote:
&gt; Hey,
&gt; 
&gt; The patch here needed for cryptoloop volumes with keysize specified and
&gt; such (the losetup-combined.patch) located here:
&gt; http://www.stwing.org/~sluskyb/util-linux/losetup-combined.patch is
&gt; offline at the moment.
&gt; 
&gt; Does anyone have a copy?
&gt; Why is it not included with util-linux anyway?

Andries apparently felt the changes were too invasive for core system utilities.

As Evgeniy said, cryptoloop has been deprecated in favor of dm-crypt,
which is more robust and backward compatible[1]. I stopped using that
patch some time ago. :-/ But if you need it in a pinch, you can find it
here:
&lt;URL:http://www.paranoiacs.org/~sluskyb/hacks/util-linux/losetup-combined.patch&gt;

HTH,
-
-Ben

[1] But the non-compatible ESSIV cipher mode is recommended for greater
    security.

-- 
Ben Slusky                      | Those who will not reason, are
sluskyb@paranoiacs.org          | bigots, those who cannot, are
sluskyb@stwing.org              | fools, and those who dare not,
PGP keyID ADA44B3B              | are slaves.   -Lord Byron
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060417193914</emailId><senderName></senderName><senderEmail>peter_22</senderEmail><timestampReceived>2006-04-17 19:39:14-0400</timestampReceived><subject>Re: Stealth crypto</subject><body>

Hi Michael!

The mail that Venkat mentioned is an answer from Jari to my question on how
to encrypt full systems.
Since that time I use neither a master boot record nor a partition table on
disk. So this is exactly what you asked for. loop-aes also works with
USB-devices for booting as described in the last example  of the readme.
I didn't set up RAID configurations so let me know about your experiences in
this field.

Regards,
Peter


&gt; --- Ursprüngliche Nachricht ---
&gt; Von: "Michael Garibaldi" &lt;michaelgari@gmail.com&gt;
&gt; An: "Venkat Manakkal" &lt;venkat@rayservers.com&gt;
&gt; Kopie: linux-crypto@nl.linux.org
&gt; Betreff: Re: Stealth crypto
&gt; Datum: Sun, 16 Apr 2006 03:30:03 +0300
&gt; 
&gt; &gt;
&gt; &gt; for encrypted root. That can be extended for the entire disk if you boot
&gt; &gt; from
&gt; &gt; CDROM or USB using the entire disk /dev/sda for instance.
&gt; &gt;
&gt; 
&gt; This is not very useful, as I'll end up with a bunch of /dev/loop* devices
&gt; then. Those devices would have partition tables in them, and in
&gt; particular,
&gt; they contain RAID arrays (partition type RAID autodetect). It is difficult
&gt; to keep track of which HDD is which, but if the kernel can autodetect
&gt; that,
&gt; it'll be a lot easier. That is why I want the kernel to read them as HDDs,
&gt; rather than just provide me some block devices.
&gt; 
&gt; The above is only my solution to the problem. There probably are others
&gt; (that still do things automatically!), but this was the first thing that I
&gt; thought about.
&gt; 
&gt; Example:
&gt; 
&gt; 1. Setup cryptoloops
&gt; /dev/sda = /dev/loop0
&gt; /dev/sdb = /dev/loop1
&gt; /dev/sdc = /dev/loop2
&gt; 2. Let the kernel detect them as HDDs
&gt; /dev/loop0 = HDD =&gt; kernel detects partitions
&gt; /dev/loop0-partition1 = RAID-5 md0 disk 2
&gt; /dev/loop0-partition2 = RAID-1 md1 disk 0
&gt; /dev/loop1 = HDD =&gt; kernel detects partitions
&gt; /dev/loop1-partition1 = RAID-1 md1 disk 1
&gt; /dev/loop1-partition2 = RAID-5 md0 disk 1
&gt; /dev/loop2-partition2 = RAID-5 md0 disk 0
&gt; 3. The kernel found RAID partitions, so it automatically assembles them:
&gt; /dev/md0 = my RAID-5
&gt; /dev/md1 = my RAID-1
&gt; 4. I can easily mount /dev/md1 as root, etc.
&gt; 
&gt; If the kernel cannot detect them that way, I have serious trouble trying
&gt; to
&gt; figure out where exactly is each partition, which array it belongs to,
&gt; etc.
&gt; 

-- 
Analog-/ISDN-Nutzer sparen mit GMX SmartSurfer bis zu 70%!
Kostenlos downloaden: http://www.gmx.net/de/go/smartsurfer

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060417223724</emailId><senderName></senderName><senderEmail>peter_22</senderEmail><timestampReceived>2006-04-17 22:37:24-0400</timestampReceived><subject>Re: hdparm and Serial ATA</subject><body>

&gt; --- Ursprüngliche Nachricht ---
&gt; Von: markus reichelt &lt;ml@bitfalle.org&gt;
&gt; An: linux-crypto@nl.linux.org
&gt; Betreff: Re: hdparm and Serial ATA
&gt; Datum: Tue, 18 Apr 2006 00:16:50 +
&gt; from what i've come across it should work via hdparm. maybe a
&gt; manufacturer/vendor specific thing? hdparm doesn't seem to be updated
&gt; that often... like smartd is. have you asked the authors / tried
&gt; different kernel versions? with recent kernel versions, this may be
&gt; tricky.

SuSE 10.0 includes hdparm in version 6.1 and the latest is version 6.6. I
will try the SuSE live cd and knoppix. My harddrive configuration changed
since I got a WD3200JS additionaly to my old WD2000JD. Compared to the ne JS
the JD model is loud like a starting air plane so I whish to turn her off
sometimes.

Regards,
Peter

-- 
"Feel free" - 10 GB Mailbox, 100 FreeSMS/Monat ...
Jetzt GMX TopMail testen: http://www.gmx.net/de/go/topmail

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060418022757</emailId><senderName>"Lohan Knight"</senderName><senderEmail>lohan_knight@hotmail.com</senderEmail><timestampReceived>2006-04-18 02:27:57-0400</timestampReceived><subject>Re: loop-AES and RPM's in FC5</subject><body>


Thanks, Phil.

I didn't know about the "exclude=" option.  I'll try it out.

So that's what you do?  You just exclude stuff from Yum or Apt or
whatever package system you use.  And then you just have to
wake up every now and then and look around manually for any
updates to the stuff you excluded?  Then once you find them,  you
install them manually?

It's a solution I suppose,  but I was hoping for something that
allowed me to continue to use Yum to find and install updates,
including patching everything and getting loop-AES working.

It's a bit much to ask for I guess, especially since the util-linux
stuff requires specific patches for specific versions of util-linux,
right?  So you couldn't just keep updating stuff unless you made
sure both it and the patch file were for the same version,  which
makes it hard to automate.

There's gotta be a better way than this.  Maybe we can get
the util-linux guys to update their code to allow customization
or user extensions without recompiling their code?  That way
you don't need to patch it and recompile it each time.  Why
not do that?  Same with gnupg.  I think gnupg still requires a
patch and recompile, right?

See,  when you start excluding packages from automated
updates,  you end up with a potentially non-secure system.
Why? Because instead of just being able to run some quick
little script each day to keep your system up to date
automatically,  you have to go out and manually search for
updates and install them yourself.  That means that all but
the most diligent people will just let it slide and won't update
their kernel, util-linux, and so on.  That has potential of
introducing security holes I would imagine.  Better to have
everything update automatically... Plus it's a pain in
the butt trying to do things manually.

But you all know this already I'm sure.

Thanks,
- Steve


&gt;From: Phil H &lt;philtickle200@yahoo.com&gt;
&gt;To: Lohan Knight &lt;lohan_knight@hotmail.com&gt;, linux-crypto@nl.linux.org
&gt;Subject: Re: loop-AES and RPM's in FC5
&gt;Date: Mon, 17 Apr 2006 13:12:24 -0700 (PDT)
&gt;
&gt;You might want to add an appropriate exclude line to /etc/yum.conf to 
&gt;prevent the utils and kernel from getting updated.
&gt;
&gt;   I'm not sure if mount, losetup and the other utils are all included in 
&gt;one package with Fedora (check), but assuming you want to exclude for eg a 
&gt;package starting with "mount" from being updated then you'd add the 
&gt;following line to /etc/yum.conf:
&gt;
&gt;   exclude=mount*
&gt;
&gt;   Not sure if you have to exclude losetup, swapon, swapoff as well - 
&gt;probably.  Find out what packages these belong to and exclude these?
&gt;
&gt;   On doing an update, any package starting with "mount" then shouldn't get 
&gt;touched.
&gt;
&gt;   A kernel update might (?) replace your new loop.o driver as well, or at 
&gt;least would no longer match it, so you should exclude the kernel from 
&gt;updating as well:
&gt;
&gt;   exclude=kernel*
&gt;
&gt;   As for rpms - you could build your utils and loop.o driver into rpms 
&gt;using checkinstall if you want, but it's probbably of no advantage since 
&gt;you're only ever going to be manually compiling and replacing these anyway.
&gt;
&gt;
&gt;
&gt;Lohan Knight &lt;lohan_knight@hotmail.com&gt; wrote:
&gt;
&gt;And I'd like to just be able to
&gt;say "yum update" and not worry about having it install
&gt;something that breaks loop-AES stuff.
&gt;
&gt;I know in the past the docs said to turn off the cryptoloop
&gt;driver and disable the loop device driver in the kernel config
&gt;settings. Then recompile the kernel. Then patch gnupg with
&gt;a patch file. Then compile loop-AES which will copy a new
&gt;loop.o to /lib/modules. Then patch util-linux. Then install
&gt;ciphers.
&gt;
&gt;I assume the same process would be needed to install it
&gt;for FC5.
&gt;
&gt;Problem is, once I patch stuff manually, I'm no longer able
&gt;to put those programs under RPM / Yum control. Am I? I
&gt;mean won't they just get overwritten once I do an update
&gt;("yum update")? So I'd have to somehow remove it from
&gt;RPM control first, which I don't know how to do yet. And then
&gt;I'd have to manually update the various items (kernel,
&gt;util-linux, gnupg, loop-AES) from time to time, which is
&gt;undesirable.
&gt;
&gt;So how do you all handle this? Do you just not update your
&gt;systems once you've gotten loop-AES working? Or do you
&gt;create your own RPM's? I don't know how to go about all
&gt;that. It's new to me. I know I have to learn more about Yum
&gt;and RPM package management.
&gt;
&gt;Advice?
&gt;
&gt;Thanks,
&gt;- Steve
&gt;
&gt;_________________________________________________________________
&gt;Don’t just search. Find. Check out the new MSN Search!
&gt;http://search.msn.click-url.com/go/onm00200636ave/direct/01/
&gt;
&gt;
&gt;-
&gt;Linux-crypto: cryptography in and on the Linux system
&gt;Archive: http://mail.nl.linux.org/linux-crypto/
&gt;
&gt;
&gt;
&gt;
&gt;---------------------------------
&gt;Talk is cheap. Use Yahoo! Messenger to make PC-to-Phone calls.  Great rates 
&gt;starting at 1¢/min.

_________________________________________________________________
FREE pop-up blocking with the new MSN Toolbar – get it now! 
http://toolbar.msn.click-url.com/go/onm00200415ave/direct/01/


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060418164120</emailId><senderName></senderName><senderEmail>jason_reed@virgilio.it</senderEmail><timestampReceived>2006-04-18 16:41:20-0400</timestampReceived><subject>Please Respond</subject><body>

Dear Friend,
I am Mr Jason Reed, a computer programmer/ software
engineer based in Africa. My company was established
in 2001. I am 
interested in employing your services,
to work with me as my payment 
agent who can help me
establish a medium of recieving payment on my 
behalf
for Goods and services I supplied to my customers in
Europe, 
America or Australia as the case need may
arise.
If you are interested 
in transacting business with me.
I will be very glad. Subject to your 
satisfaction you
will be given the opportunity to negotiate your mode
of payment which we will pay[10%] for your services as
my 
representative in your country. Please if you are
interested forward 
to 
me your phone/fax number and
your full contact address.
Thank you 
as I 
await your further response.
Hoping to hear from you.
Faithfully 
Yours,
Mr Jason Reed.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060419104139</emailId><senderName>"chaitanya  ralegaonkar"</senderName><senderEmail>chaitanya_ralegaonkar@rediffmail.com</senderEmail><timestampReceived>2006-04-19 10:41:39-0400</timestampReceived><subject>query regarding cryptfs</subject><body>

This is a multipart mime message

 Sir,I am student from India.

I have query regarding cryptfs (genrerated from FiST ) viz.

I am using RH9 ( kernel 2.4.20) and fisgen-0.1

When I creat files in " /mnt/cryptfs " it displays them in encrypted format in " \
/n/fist/cryptfs ". But when I do " umount ", and " mount " again I can not see the \
files in " /mnt/cryptfs ". During this ( i.e. mounting and unmounting ) the files are \
displayed in encrypted format in " n/fist/cryptfs ". Even after rebooting the files \
are present in encrypted format.  So how should I get back files in normal form..

Thank you 


[Attachment #3 (text/html)]

&lt;P&gt;
 Sir,I am student from India.&lt;BR&gt;
&lt;BR&gt;
I have query regarding cryptfs (genrerated from FiST ) viz.&lt;BR&gt;
&lt;BR&gt;
I am using RH9 ( kernel 2.4.20) and fisgen-0.1&lt;BR&gt;
&lt;BR&gt;
When I creat files in " /mnt/cryptfs " it displays them in encrypted format \
in " /n/fist/cryptfs ". But when I do " umount ", and " \
mount " again I can not see the files in " /mnt/cryptfs ". During this \
( i.e. mounting and unmounting ) the files are displayed in encrypted format in \
" n/fist/cryptfs ". Even after rebooting the files are present in encrypted \
format.&lt;BR&gt;        So how should I get back files in normal form..&lt;BR&gt;
&lt;BR&gt;
Thank you &lt;BR&gt;

&lt;/P&gt;
&lt;br&gt;&lt;br&gt;
&lt;a href="http://adworks.rediff.com/cgi-bin/AdWorks/sigclick.cgi/www.rediff.com/signature-home.htm/1507191490@Middle5?PARTNER=3"&gt;&lt;IMG \
SRC="http://adworks.rediff.com/cgi-bin/AdWorks/sigimpress.cgi/www.rediff.com/signature-home.htm/1963059423@Middle5?OAS_query=null&amp;PARTNER=3" \
BORDER=0 VSPACE=0 HSPACE=0&gt;&lt;/a&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060421095736</emailId><senderName>mac akan</senderName><senderEmail>mac_akan000111@yahoo.it</senderEmail><timestampReceived>2006-04-21 09:57:36-0400</timestampReceived><subject>CONTACT MY SECRETARY NOW</subject><body>

Ho cambiato indirizzo!Puoi ora scrivermi a questo indirizzo: mac_akan000111@yahoo.it

Dear good Friend,


I'm happy to inform you about my success in getting the

fund transferred to a Swiss Account with the cooperation of a new partner

from paraguay who is an international business man and oil merchant.


Presently I'm in Paraguay for investment projects with my own share of the

total sum. Meanwhile, I did not forget your past efforts and attempts to

assist me in transferring those funds despite that it failed us some how.


Now contact my new personal secretary,His contact is: Name:Mr godwin obinna


Email address godwin_obinna30@yahoo.fr


Ask him to send you thetotal $800.000.00 (Eight Thousand US Dollars) which I kept for \
yourcompensation for all the past efforts and attempts to assist me in this

matter.


I appreciated your efforts at that time very much. So feel free and

get in touched with Mr.godwin obinna..and instruct him where to send the

amount to you.


 Please do let me know immediately you receive it so that we

can share the joy after all the sufferness at that time. In the moment,I am

very busy here because of the investment projects which me and the new

partner are having at hand.


 Finally, remember that I had forwarded

instruction to my new secretary on your behalf to receive that money, so

feel free to get in touch with Mr.godwin obinna. and he will send the

amount to you without any delay.


 With best

 Regards mac akan

- mac akan


[Attachment #3 (text/html)]

&lt;div style="border: solid 1px #cccccc; width:448px; background-color:white; \
margin:10px 0px;";&gt;&lt;table border=0 cellspacing=0 cellpadding=0 width="448"&gt;&lt;tr&gt;&lt;td \
class=tablot background="http://us.i1.yimg.com/us.yimg.com/i/us/pim/gr/gr_announce_1.gif" \
valign=center height=57&gt;&lt;big style="padding:10px;"&gt;Ho cambiato \
indirizzo!&lt;/big&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;div style="padding:10px;"&gt;Puoi ora scrivermi a \
questo indirizzo: &lt;b&gt;mac_akan000111@yahoo.it&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;span \
style="color:green;"&gt;Dear good Friend,&lt;br&gt;&lt;br&gt;&lt;br&gt;I'm happy to inform you about my \
success in getting the&lt;br&gt;&lt;br&gt;fund transferred to a Swiss Account with the \
cooperation of a new partner&lt;br&gt;&lt;br&gt;from paraguay who is an international business \
man and oil merchant.&lt;br&gt;&lt;br&gt;&lt;br&gt;Presently I'm in Paraguay for investment projects \
with my own share of the&lt;br&gt;&lt;br&gt;total sum. Meanwhile, I did not forget your past \
efforts and attempts to&lt;br&gt;&lt;br&gt;assist me in transferring those funds despite that it \
failed us some how.&lt;br&gt;&lt;br&gt;&lt;br&gt;Now contact my new personal secretary,His contact is: \
Name:Mr godwin obinna&lt;br&gt;&lt;br&gt;&lt;br&gt;Email address \
godwin_obinna30@yahoo.fr&lt;br&gt;&lt;br&gt;&lt;br&gt;Ask him to send you thetotal $800.000.00 (Eight \
Thousand US Dollars) which I kept for yourcompensation for all the past efforts and \
attempts to assist me in this&lt;br&gt;&lt;br&gt;matter.&lt;br&gt;&lt;br&gt;&lt;br&gt;I appreciated your efforts at \
that time very much. So feel free and&lt;br&gt;&lt;br&gt;get in touched with Mr.godwin \
obinna..and instruct him where to send the&lt;br&gt;&lt;br&gt;amount to you.&lt;br&gt;&lt;br&gt;&lt;br&gt; Please \
do let me know immediately you receive it so that we&lt;br&gt;&lt;br&gt;can share the joy after \
all the sufferness at that time. In the moment,I am&lt;br&gt;&lt;br&gt;very busy here because of \
the investment projects which me and the new&lt;br&gt;&lt;br&gt;partner are having at \
hand.&lt;br&gt;&lt;br&gt;&lt;br&gt; Finally, remember that I had forwarded&lt;br&gt;&lt;br&gt;instruction to my new \
secretary on your behalf to receive that money, so&lt;br&gt;&lt;br&gt;feel free to get in touch \
with Mr.godwin obinna. and he will send the&lt;br&gt;&lt;br&gt;amount to you without any \
delay.&lt;br&gt;&lt;br&gt;&lt;br&gt; With best&lt;br&gt;&lt;br&gt; Regards mac akan&lt;/span&gt;&lt;br&gt;&lt;br&gt;- &lt;span \
style="color:green;"&gt;mac akan&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060425152634</emailId><senderName>"Jon"</senderName><senderEmail>dona@sltnet.lk</senderEmail><timestampReceived>2006-04-25 15:26:34-0400</timestampReceived><subject>apple ipod nanos 4GB</subject><body>

Apple Ipod Nanos 4GB..
 
Qty: 32 pcs
Duty paid custom cleared in UK
 
Bets price US $ 195.00
Buy all price..please let me know if you are interested..
 
Best regards
Jon

[Attachment #3 (text/html)]

&lt;DIV class=Section1&gt;
&lt;P class=MsoNormal&gt;&lt;FONT face=Arial color=blue size=6&gt;&lt;SPAN style="FONT-SIZE: 22pt; \
COLOR: blue; FONT-FAMILY: Arial"&gt;Apple Ipod Nanos 4GB..&lt;?xml:namespace prefix = o ns \
= "urn:schemas-microsoft-com:office:office" /&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/P&gt; &lt;P \
class=MsoNormal&gt;&lt;FONT face=Arial color=blue size=6&gt;&lt;SPAN style="FONT-SIZE: 22pt; \
COLOR: blue; FONT-FAMILY: Arial"&gt;&lt;o:p&gt; &lt;/o:p&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/P&gt; &lt;P \
class=MsoNormal&gt;&lt;FONT face=Arial color=blue size=6&gt;&lt;SPAN style="FONT-SIZE: 22pt; \
COLOR: blue; FONT-FAMILY: Arial"&gt;Qty: 32 pcs&lt;o:p&gt;&lt;/o:p&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/P&gt; &lt;P \
class=MsoNormal&gt;&lt;FONT face=Arial color=blue size=6&gt;&lt;SPAN style="FONT-SIZE: 22pt; \
COLOR: blue; FONT-FAMILY: Arial"&gt;Duty paid &lt;/SPAN&gt;&lt;/FONT&gt;&lt;B&gt;&lt;U&gt;&lt;FONT face=Arial \
color=red size=6&gt;&lt;SPAN style="FONT-WEIGHT: bold; FONT-SIZE: 22pt; COLOR: red; \
FONT-FAMILY: Arial"&gt;custom cleared in &lt;?xml:namespace prefix = st1 ns = \
"urn:schemas-microsoft-com:office:smarttags" /&gt;&lt;st1:country-region \
w:st="on"&gt;&lt;st1:place \
w:st="on"&gt;UK&lt;/st1:place&gt;&lt;/st1:country-region&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/U&gt;&lt;/B&gt;&lt;FONT face=Arial \
color=blue size=6&gt;&lt;SPAN style="FONT-SIZE: 22pt; COLOR: blue; FONT-FAMILY: \
Arial"&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/P&gt; &lt;P class=MsoNormal&gt;&lt;FONT face=Arial color=blue \
size=6&gt;&lt;SPAN style="FONT-SIZE: 22pt; COLOR: blue; FONT-FAMILY: \
Arial"&gt;&lt;o:p&gt; &lt;/o:p&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/P&gt; &lt;P class=MsoNormal&gt;&lt;FONT face=Arial \
color=blue size=6&gt;&lt;SPAN style="FONT-SIZE: 22pt; COLOR: blue; FONT-FAMILY: Arial"&gt;Bets \
price US $ 195.00&lt;o:p&gt;&lt;/o:p&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/P&gt; &lt;P class=MsoNormal&gt;&lt;FONT face=Arial \
color=blue size=6&gt;&lt;SPAN style="FONT-SIZE: 22pt; COLOR: blue; FONT-FAMILY: Arial"&gt;Buy \
all price..please let me know if you are interested..&lt;o:p&gt;&lt;/o:p&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/P&gt; &lt;P \
class=MsoNormal&gt;&lt;FONT face=Arial color=blue size=6&gt;&lt;SPAN style="FONT-SIZE: 22pt; \
COLOR: blue; FONT-FAMILY: Arial"&gt;&lt;o:p&gt; &lt;/o:p&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/P&gt; &lt;P \
class=MsoNormal&gt;&lt;FONT face=Arial color=blue size=6&gt;&lt;SPAN style="FONT-SIZE: 22pt; \
COLOR: blue; FONT-FAMILY: Arial"&gt;Best regards&lt;o:p&gt;&lt;/o:p&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/P&gt; &lt;P \
class=MsoNormal&gt;&lt;FONT face=Arial color=blue size=6&gt;&lt;SPAN style="FONT-SIZE: 22pt; \
COLOR: blue; FONT-FAMILY: Arial"&gt;Jon&lt;o:p&gt;&lt;/o:p&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/P&gt;&lt;/DIV&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060302065555</emailId><senderName>       NAV for Microsoft Exchange-WEB-SERVER</senderName><senderEmail></senderEmail><timestampReceived>2006-03-02 06:55:55-0400</timestampReceived><subject>Norton AntiVirus detected a virus in a message you sent.  The inf</subject><body>

Recipient of the infected attachment:  Pakis =
Menderlis\=C5=E9=F3=E5=F1=F7=FC=EC=E5=ED=E1
Subject of the message:  Delivery reports about your e-mail
One or more attachments were deleted
  Attachment transcript.zip was Deleted for the following reasons:
    Virus W32.Mydoom.M@mm was found.
    Virus W32.Mydoom.M@mm was found in transcript.htm
.exe.

[Attachment #3 (application/ms-tnef)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060303144733</emailId><senderName></senderName><senderEmail>recruiting-support@brandinstitute.com</senderEmail><timestampReceived>2006-03-03 14:47:33-0400</timestampReceived><subject>Online paid-survey invitation from Brand Institute!!!</subject><body>

Greetings from Brand Institute, Inc.!

Brand Institute, a leading consulting firm needs your help. Currently
we�fre conducting a study on how marketing influences the purchasing
behaviors on financial services. 

We conduct live and online market research surveys/brainstorming
sessions to help our customers develop new and exciting names for their
products. We need your ideas and opinions to come up with the best
possible names. We will compensate $25 for twenty minutes of your time. 

If you think you have what it takes to name the next hit television
network or the newest household product, please sign up at our website:
http://www.brandinst.com/survey/. We will not use your information for
anything except the surveys, and of course�cto mail you your check! We
will not sell your information to any lists or use it for illicit
advertising.

Please feel free to pass this message along to anyone you think would
enjoy making extra money while getting involved in the creation of
tomorrow's products.

Thank you very much; we appreciate your help! Soon, your ideas may be
part of a national marketing campaign!

Kind regards,

The Brand Institute Team

recruiting-support@brandinstitute.com


[Attachment #3 (text/html)]

Greetings from Brand Institute, Inc.!&lt;br&gt;
&lt;br&gt;
Brand Institute, a leading consulting firm needs your help. Currently we�fre \
conducting a study on how marketing influences the purchasing behaviors on financial \
services.  &lt;br&gt; &lt;br&gt;
We conduct live and online market research surveys/brainstorming sessions to help our \
customers develop new and exciting names for their products. We need your ideas and \
opinions to come up with the best possible names. We will compensate $25 for twenty \
minutes of your time. &lt;br&gt; &lt;br&gt;
If you think you have what it takes to name the next hit television network or the \
newest household product, please sign up at our website: \
http://www.brandinst.com/survey/. We will not use your information for anything \
except the surveys, and of course�cto mail you your check! We will not sell your \
information to any lists or use it for illicit advertising.&lt;br&gt; &lt;br&gt;
Please feel free to pass this message along to anyone you think would enjoy making \
extra money while getting involved in the creation of tomorrow's products.&lt;br&gt; &lt;br&gt;
Thank you very much; we appreciate your help! Soon, your ideas may be part of a \
national marketing campaign!&lt;br&gt; &lt;br&gt;
Kind regards,&lt;br&gt;
&lt;br&gt;
The Brand Institute Team&lt;br&gt;
&lt;br&gt;
recruiting-support@brandinstitute.com&lt;br&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060305222555</emailId><senderName>Gisle_Sælensminde</senderName><senderEmail>gisle@cbu.uib.no</senderEmail><timestampReceived>2006-03-05 22:25:55-0400</timestampReceived><subject>Re: Loading secure binaries</subject><body>

Zhang Jiang jason-MGI8240 wrote:

&gt; Hi, Ian and Gisle,
&gt;  
&gt; While I was searching the Internet to solve the similar problem, your 
&gt; email communications popped up (see the attachment below). Just 
&gt; wondering if you guys can provide me more progress or information 
&gt; about loading secure binaries? I also face the same problem that 
&gt; somebody may load and execute malicious code on top of our embedded 
&gt; Linux OS. If you guys can share some experience on the embedded Linux, 
&gt; I really appreciate!
&gt;
I answered you in private email saying that I did not know about such a 
system, and outlined how it could
be implemented, but it turned out I was wrong, at least for kernel 
modules. There were even an article in
linuxjournal about it. Maybe not very well tested yet, but it has made 
it into some of the Fedora test kernels at least:

http://www.linuxjournal.com/article/7130
http://sourceforge.net/projects/disec
http://lwn.net/Articles/92617/

This has not to my knowledge made it into the base kernel, and I would 
guess that it will meet some
resistance, since it potentially can be used to prevent people from 
modify systems they own, DRM-like
schemes and similar, but it can also increase the security on some 
servers. For executables in
userspace some of the features of SELinux may solve some of your issues, 
depending on what you try to
archieve.

- Gisle


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060308194005</emailId><senderName>Jean-Luc Cooke</senderName><senderEmail>jlcooke@certainkey.com</senderEmail><timestampReceived>2006-03-08 19:40:05-0400</timestampReceived><subject>Re: attacks on Linxu RNG (paper)</subject><body>



On Wed, Mar 08, 2006 at 07:06:06PM +0100, Christian wrote:
&gt; On Wed, March 8, 2006 15:25, Jean-Luc Cooke wrote:
&gt; &gt; I didn't not write this.  I've given up trying to convince people of the
&gt; &gt; problems with the Linux RNG long ago.

Just saw my bad english above.  Sorry to all grammer nazis out there.

&gt; I've heard of this, but never got around looking into this. thanks for the
&gt; link!

No problem.  Good paper by the way, I suggest folks read it
(eprint.iacr.org/2006/086)

&gt; &gt; ps.  My out-of-date Fortuna RNG page: http://jlcooke.ca/random/
&gt; 
&gt; why is this out-of-date? the last patch is for 2.6.12, is it not
&gt; maintained any more? I suppose that you have sent patches to lkml as well
&gt; - any pointers why the patches were rejected...?

Oh god.  Yes.

http://marc.theaimsgroup.com/?l=linux-kernel&amp;m=111343641603732&amp;w=2
http://marc.theaimsgroup.com/?l=linux-kernel&amp;m=109598444526812&amp;w=2
http://marc.theaimsgroup.com/?l=linux-kernel&amp;m=109647848816402&amp;w=2

That's just a start.

JLC

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060309003804</emailId><senderName>"Creative Real Estate Lifestyles Magazine"</senderName><senderEmail>graphics@crelmagazine.com</senderEmail><timestampReceived>2006-03-09 00:38:04-0400</timestampReceived><subject>Please re-confirm your active subscription to our mailing list.</subject><body>


--#MULTIPART-BOUNDARY#
Content-Type: multipart/alternative; boundary="#BOUNDARY#"


--#BOUNDARY#
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

Subscription Confirmation

A mailing list exclusively for an Interest Group to which you currently belong was \
created and your e-mail address has been identified as an active subscriber. This \
mailing list enables you to receive important e-mail messages, announcements, and \
other information.

In order that we may maintain a 100% permission-based mailing list for this Interest \
Group, please verify that you would like to continue your subscription.

Do not reply to this e-mail. Instead, follow the hyperlink to confirm your \
subscription ( http://app.quicksizzle.com/confirm.aspx?id=14885&amp;sid=34799873&amp;guid=6c536985-51fc-4986-b124-4121ed01f38c \
)   to this mailing list. If you do not want to continue your subscription, simply \
ignore this message and the program will automatically remove \
linux-crypto@nl.linux.org from the mailing list.

You can cancel your subscription or change subscription preferences at any time by \
clicking the Unsubscribe link at the bottom of any future e-mail message that you may \
receive through this mailing list. Thank you for confirming your subscription.

Sincerely,
Creative Real Estate Lifestyles Magazine

Copyright (C) 2004-2006.  All rights reserved.


--#BOUNDARY#
Content-Type: text/html; charset=iso-8859-1
Content-Transfer-Encoding: 7bit

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;Subscription Confirmation&lt;/title&gt;
		&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;
	&lt;/head&gt;
	&lt;body bgcolor="#FFFFFF" leftmargin="0" topmargin="0" marginwidth="0" \
marginheight="0" rightmargin="0" bottommargin="0"&gt;  &lt;table width="100%" height="100%" \
border="0" cellpadding="0" cellspacing="0"&gt;  &lt;tr&gt;
				&lt;td align="center" valign="top"&gt;&lt;table width="100%" height="100%" border="20" \
cellpadding="40" cellspacing="0" bordercolor="#000000"&gt;  &lt;tr&gt;
							&lt;td valign="top"&gt;
								&lt;font size="2" face="Verdana, Arial, Helvetica, sans-serif"&gt;A mailing list 
									exclusively for an Interest Group to which you currently belong was created \
                and 
									your e-mail address has been identified as an active subscriber. This \
                mailing 
									list enables you to receive important e-mail messages, announcements, and \
other   information.
									&lt;br&gt;
									&lt;br&gt;
									In order that we may maintain a 100% permission-based mailing list for this 
									Interest Group, please verify that you would like to continue your 
									subscription.
									&lt;br&gt;
									&lt;br&gt;
									Do not reply to this e-mail. Instead, follow the hyperlink to &lt;font size="2" \
                face="Verdana, Arial, Helvetica, sans-serif"&gt;
										&lt;a href="http://app.quicksizzle.com/confirm.aspx?id=14885&amp;sid=34799873&amp;guid=6c536985-51fc-4986-b124-4121ed01f38c"&gt;confirm \
                your subscription&lt;/a&gt; &lt;/font&gt; to 
									this mailing list. If you do not want to continue your subscription, simply 
									ignore this message and the program will automatically remove \
linux-crypto@nl.linux.org   from the mailing list.
									&lt;br&gt;
									&lt;br&gt;
								&lt;/font&gt;&lt;font size="2" face="Verdana, Arial, Helvetica, sans-serif"&gt;You can \
                cancel 
									your subscription or change subscription preferences at any time by clicking \
                
									the Unsubscribe link at the bottom of any future e-mail message that you may \
                
									receive through this mailing list. Thank you for confirming your \
subscription.  &lt;br&gt;
									&lt;br&gt;
								&lt;/font&gt;&lt;font color="#FF6600" size="2" face="Verdana, Arial, Helvetica, \
sans-serif"&gt;Sincerely,&lt;/font&gt;&lt;font size="2" face="Verdana, Arial, Helvetica, \
                sans-serif"&gt;&lt;br&gt;
									&lt;strong&gt;Creative Real Estate Lifestyles Magazine&lt;/strong&gt;&lt;/font&gt;&lt;strong&gt;&lt;br&gt;
								&lt;/strong&gt;
								&lt;br&gt;
								&lt;br&gt;
							&lt;/td&gt;
						&lt;/tr&gt;
					&lt;/table&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td height="40" valign="top" bgcolor="#000000"&gt;&lt;div align="center"&gt;&lt;font \
color="#FFCF30" size="-2" face="Verdana, Arial, Helvetica, sans-serif"&gt;Copyright \
© 2004-2006.  All rights reserved.&lt;/font&gt;&lt;/div&gt;  &lt;/td&gt;
			&lt;/tr&gt;
		&lt;/table&gt;
	&lt;img src="http://app.quicksizzle.com/get.imgx?Opened=true&amp;sid=34799873" width=0px \
height=0px /&gt;&lt;/body&gt; &lt;/html&gt;


--#BOUNDARY#--
--#MULTIPART-BOUNDARY#--

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060309033608</emailId><senderName>Atsushi Nemoto</senderName><senderEmail>anemo@mba.ocn.ne.jp</senderEmail><timestampReceived>2006-03-09 03:36:08-0400</timestampReceived><subject>[PATCH] crypto: add alignment handling to digest layer</subject><body>

Some hash modules load/store data words directly.  The digest layer
should pass properly aligned buffer to update()/final() method.  This
patch also add cra_alignmask to some hash modules.

Signed-off-by: Atsushi Nemoto &lt;anemo@mba.ocn.ne.jp&gt;

 digest.c      |   42 +++++++++++++++++++++++++++---------------
 michael_mic.c |    1 +
 sha1.c        |    1 +
 sha256.c      |    1 +
 sha512.c      |    2 ++
 tgr192.c      |    3 +++
 6 files changed, 35 insertions(+), 15 deletions(-)

diff --git a/crypto/digest.c b/crypto/digest.c
index d9b6ac9..062d0a5 100644
--- a/crypto/digest.c
+++ b/crypto/digest.c
@@ -27,6 +27,7 @@ static void update(struct crypto_tfm *tf
                    struct scatterlist *sg, unsigned int nsg)
 {
 	unsigned int i;
+	unsigned int alignmask = crypto_tfm_alg_alignmask(tfm);
 
 	for (i = 0; i &lt; nsg; i++) {
 
@@ -38,12 +39,24 @@ static void update(struct crypto_tfm *tf
 			unsigned int bytes_from_page = min(l, ((unsigned int)
 							   (PAGE_SIZE)) - 
 							   offset);
-			char *p = crypto_kmap(pg, 0) + offset;
+			char *src = crypto_kmap(pg, 0);
+			char *p = src + offset;
 
+			if (unlikely(offset &amp; alignmask)) {
+				unsigned int bytes =
+					alignmask + 1 - (offset &amp; alignmask);
+				bytes = min(bytes, bytes_from_page);
+				tfm-&gt;__crt_alg-&gt;cra_digest.dia_update
+						(crypto_tfm_ctx(tfm), p,
+						 bytes);
+				p += bytes;
+				bytes_from_page -= bytes;
+				l -= bytes;
+			}
 			tfm-&gt;__crt_alg-&gt;cra_digest.dia_update
 					(crypto_tfm_ctx(tfm), p,
 					 bytes_from_page);
-			crypto_kunmap(p, 0);
+			crypto_kunmap(src, 0);
 			crypto_yield(tfm);
 			offset = 0;
 			pg++;
@@ -54,7 +67,15 @@ static void update(struct crypto_tfm *tf
 
 static void final(struct crypto_tfm *tfm, u8 *out)
 {
-	tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(crypto_tfm_ctx(tfm), out);
+	unsigned long alignmask = crypto_tfm_alg_alignmask(tfm);
+	if (unlikely((unsigned long)out &amp; alignmask)) {
+		unsigned int size = crypto_tfm_alg_digestsize(tfm);
+		u8 buffer[size + alignmask];
+		u8 *dst = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
+		tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(crypto_tfm_ctx(tfm), dst);
+		memcpy(out, dst, size);
+	} else
+		tfm-&gt;__crt_alg-&gt;cra_digest.dia_final(crypto_tfm_ctx(tfm), out);
 }
 
 static int setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
@@ -69,18 +90,9 @@ static int setkey(struct crypto_tfm *tfm
 static void digest(struct crypto_tfm *tfm,
                    struct scatterlist *sg, unsigned int nsg, u8 *out)
 {
-	unsigned int i;
-
-	tfm-&gt;crt_digest.dit_init(tfm);
-		
-	for (i = 0; i &lt; nsg; i++) {
-		char *p = crypto_kmap(sg[i].page, 0) + sg[i].offset;
-		tfm-&gt;__crt_alg-&gt;cra_digest.dia_update(crypto_tfm_ctx(tfm),
-		                                      p, sg[i].length);
-		crypto_kunmap(p, 0);
-		crypto_yield(tfm);
-	}
-	crypto_digest_final(tfm, out);
+	init(tfm);
+	update(tfm, sg, nsg);
+	final(tfm, out);
 }
 
 int crypto_init_digest_flags(struct crypto_tfm *tfm, u32 flags)
diff --git a/crypto/michael_mic.c b/crypto/michael_mic.c
index 4f6ab23..701f859 100644
--- a/crypto/michael_mic.c
+++ b/crypto/michael_mic.c
@@ -145,6 +145,7 @@ static struct crypto_alg michael_mic_alg
 	.cra_blocksize	= 8,
 	.cra_ctxsize	= sizeof(struct michael_mic_ctx),
 	.cra_module	= THIS_MODULE,
+	.cra_alignmask	= 3,
 	.cra_list	= LIST_HEAD_INIT(michael_mic_alg.cra_list),
 	.cra_u		= { .digest = {
 	.dia_digestsize	= 8,
diff --git a/crypto/sha1.c b/crypto/sha1.c
index 21571ed..b96f57d 100644
--- a/crypto/sha1.c
+++ b/crypto/sha1.c
@@ -112,6 +112,7 @@ static struct crypto_alg alg = {
 	.cra_blocksize	=	SHA1_HMAC_BLOCK_SIZE,
 	.cra_ctxsize	=	sizeof(struct sha1_ctx),
 	.cra_module	=	THIS_MODULE,
+	.cra_alignmask	=	3,
 	.cra_list       =       LIST_HEAD_INIT(alg.cra_list),
 	.cra_u		=	{ .digest = {
 	.dia_digestsize	=	SHA1_DIGEST_SIZE,
diff --git a/crypto/sha256.c b/crypto/sha256.c
index 9d5ef67..d62264a 100644
--- a/crypto/sha256.c
+++ b/crypto/sha256.c
@@ -313,6 +313,7 @@ static struct crypto_alg alg = {
 	.cra_blocksize	=	SHA256_HMAC_BLOCK_SIZE,
 	.cra_ctxsize	=	sizeof(struct sha256_ctx),
 	.cra_module	=	THIS_MODULE,
+	.cra_alignmask	=	3,
 	.cra_list       =       LIST_HEAD_INIT(alg.cra_list),
 	.cra_u		=	{ .digest = {
 	.dia_digestsize	=	SHA256_DIGEST_SIZE,
diff --git a/crypto/sha512.c b/crypto/sha512.c
index 3e6e939..7dbec4f 100644
--- a/crypto/sha512.c
+++ b/crypto/sha512.c
@@ -281,6 +281,7 @@ static struct crypto_alg sha512 = {
         .cra_blocksize  = SHA512_HMAC_BLOCK_SIZE,
         .cra_ctxsize    = sizeof(struct sha512_ctx),
         .cra_module     = THIS_MODULE,
+	.cra_alignmask	= 3,
         .cra_list       = LIST_HEAD_INIT(sha512.cra_list),
         .cra_u          = { .digest = {
                                 .dia_digestsize = SHA512_DIGEST_SIZE,
@@ -295,6 +296,7 @@ static struct crypto_alg sha384 = {
         .cra_flags      = CRYPTO_ALG_TYPE_DIGEST,
         .cra_blocksize  = SHA384_HMAC_BLOCK_SIZE,
         .cra_ctxsize    = sizeof(struct sha512_ctx),
+	.cra_alignmask	= 3,
         .cra_module     = THIS_MODULE,
         .cra_list       = LIST_HEAD_INIT(sha384.cra_list),
         .cra_u          = { .digest = {
diff --git a/crypto/tgr192.c b/crypto/tgr192.c
index 2d8e44f..1eae1bb 100644
--- a/crypto/tgr192.c
+++ b/crypto/tgr192.c
@@ -627,6 +627,7 @@ static struct crypto_alg tgr192 = {
 	.cra_blocksize = TGR192_BLOCK_SIZE,
 	.cra_ctxsize = sizeof(struct tgr192_ctx),
 	.cra_module = THIS_MODULE,
+	.cra_alignmask = 7,
 	.cra_list = LIST_HEAD_INIT(tgr192.cra_list),
 	.cra_u = {.digest = {
 			     .dia_digestsize = TGR192_DIGEST_SIZE,
@@ -641,6 +642,7 @@ static struct crypto_alg tgr160 = {
 	.cra_blocksize = TGR192_BLOCK_SIZE,
 	.cra_ctxsize = sizeof(struct tgr192_ctx),
 	.cra_module = THIS_MODULE,
+	.cra_alignmask = 7,
 	.cra_list = LIST_HEAD_INIT(tgr160.cra_list),
 	.cra_u = {.digest = {
 			     .dia_digestsize = TGR160_DIGEST_SIZE,
@@ -655,6 +657,7 @@ static struct crypto_alg tgr128 = {
 	.cra_blocksize = TGR192_BLOCK_SIZE,
 	.cra_ctxsize = sizeof(struct tgr192_ctx),
 	.cra_module = THIS_MODULE,
+	.cra_alignmask = 7,
 	.cra_list = LIST_HEAD_INIT(tgr128.cra_list),
 	.cra_u = {.digest = {
 			     .dia_digestsize = TGR128_DIGEST_SIZE,
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060308142508</emailId><senderName>Jean-Luc Cooke</senderName><senderEmail>jlcooke@certainkey.com</senderEmail><timestampReceived>2006-03-08 14:25:08-0400</timestampReceived><subject>attacks on Linxu RNG (paper)</subject><body>

I didn't not write this.  I've given up trying to convince people of the
problems with the Linux RNG long ago.

http://eprint.iacr.org/2006/086

It's worth mentioning that they said using a simpler RNG would have been
better than using the RNG we have now.  That's almost insulting.

JLC

ps.  My out-of-date Fortuna RNG page: http://jlcooke.ca/random/

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060308141035</emailId><senderName>Atsushi Nemoto</senderName><senderEmail>anemo@mba.ocn.ne.jp</senderEmail><timestampReceived>2006-03-08 14:10:35-0400</timestampReceived><subject>[PATCH] crypto: add missing cra_alignmask</subject><body>

The "des3_ede" and "serpent" lack cra_alignmask.

Signed-off-by: Atsushi Nemoto &lt;anemo@mba.ocn.ne.jp&gt;

diff --git a/crypto/des.c b/crypto/des.c
index 7bb5486..2d74cab 100644
--- a/crypto/des.c
+++ b/crypto/des.c
@@ -965,6 +965,7 @@ static struct crypto_alg des3_ede_alg = 
 	.cra_blocksize		=	DES3_EDE_BLOCK_SIZE,
 	.cra_ctxsize		=	sizeof(struct des3_ede_ctx),
 	.cra_module		=	THIS_MODULE,
+	.cra_alignmask		=	3,
 	.cra_list		=	LIST_HEAD_INIT(des3_ede_alg.cra_list),
 	.cra_u			=	{ .cipher = {
 	.cia_min_keysize	=	DES3_EDE_KEY_SIZE,
diff --git a/crypto/serpent.c b/crypto/serpent.c
index 52ad1a4..e366406 100644
--- a/crypto/serpent.c
+++ b/crypto/serpent.c
@@ -481,6 +481,7 @@ static struct crypto_alg serpent_alg = {
 	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
 	.cra_blocksize		=	SERPENT_BLOCK_SIZE,
 	.cra_ctxsize		=	sizeof(struct serpent_ctx),
+	.cra_alignmask		=	3,
 	.cra_module		=	THIS_MODULE,
 	.cra_list		=	LIST_HEAD_INIT(serpent_alg.cra_list),
 	.cra_u			=	{ .cipher = {
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060308141155</emailId><senderName>Atsushi Nemoto</senderName><senderEmail>anemo@mba.ocn.ne.jp</senderEmail><timestampReceived>2006-03-08 14:11:55-0400</timestampReceived><subject>[PATCH] crypto: fix key alignment in tcrypt</subject><body>

Force 32-bit alignment on keys in tcrypt test vectors.

Signed-off-by: Atsushi Nemoto &lt;anemo@mba.ocn.ne.jp&gt;

diff --git a/crypto/tcrypt.h b/crypto/tcrypt.h
index 733d07e..050f852 100644
--- a/crypto/tcrypt.h
+++ b/crypto/tcrypt.h
@@ -31,7 +31,7 @@ struct hash_testvec {
 	char digest[MAX_DIGEST_SIZE];
 	unsigned char np;
 	unsigned char tap[MAX_TAP];
-	char key[128]; /* only used with keyed hash algorithms */
+	char key[128] __attribute__((__aligned__(4))); /* only used with keyed hash algorithms */
 	unsigned char ksize;
 };
 
@@ -48,7 +48,7 @@ struct hmac_testvec {
 struct cipher_testvec {
 	unsigned char fail;
 	unsigned char wk; /* weak key flag */
-	char key[MAX_KEYLEN];
+	char key[MAX_KEYLEN] __attribute__((__aligned__(4)));
 	unsigned char klen;
 	char iv[MAX_IVLEN];
 	char input[48];
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060314194030</emailId><senderName>"Jan Johansson"</senderName><senderEmail>j2@mupp.net</senderEmail><timestampReceived>2006-03-14 19:40:30-0400</timestampReceived><subject>Encrypt swap? LOOP:_SET_STATUS failed.</subject><body>

Running on Debian testing, and trying to encrypt swap with the help of
/usr/share/doc/loop-aes-2.6.15-1-686/README.gz

But I get a error when I get to the swapon-all stage?

cookiemonster:/var/log/samba# cat /etc/fstab | grep swap
/dev/hda2       none            swap    sw,loop=/dev/loop2,encryption=ASE128
0       0
cookiemonster:/var/log/samba# mkswap /dev/hda2
Setting up swapspace version 1, size = 1998737 kB
no label, UUID=3cd21164-207b-41d3-9cb5-65cd53a16ec8
cookiemonster:/var/log/samba# swapon -a
swapon: LOOP_SET_STATUS failed
cookiemonster:/var/log/samba#

Any hints?

["smime.p7s" (application/x-pkcs7-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060311010339</emailId><senderName>Adrian Bunk</senderName><senderEmail>bunk@stusta.de</senderEmail><timestampReceived>2006-03-11 01:03:39-0400</timestampReceived><subject>[2.6 patch] crypto/aes.c: array overrun</subject><body>

The Coverity checker spotted the following in crypto/aes.c:

&lt;--  snip  --&gt;

...
struct aes_ctx {
        int key_length;
        u32 E[60];
        u32 D[60];
};

#define E_KEY ctx-&gt;E
...
#define loop8(i)                                    \
{   t = ror32(t,  8); ; t = ls_box(t) ^ rco_tab[i];  \
    t ^= E_KEY[8 * i];     E_KEY[8 * i + 8] = t;    \
    t ^= E_KEY[8 * i + 1]; E_KEY[8 * i + 9] = t;    \
    t ^= E_KEY[8 * i + 2]; E_KEY[8 * i + 10] = t;   \
    t ^= E_KEY[8 * i + 3]; E_KEY[8 * i + 11] = t;   \
    t  = E_KEY[8 * i + 4] ^ ls_box(t);    \
    E_KEY[8 * i + 12] = t;                \
    t ^= E_KEY[8 * i + 5]; E_KEY[8 * i + 13] = t;   \
    t ^= E_KEY[8 * i + 6]; E_KEY[8 * i + 14] = t;   \
    t ^= E_KEY[8 * i + 7]; E_KEY[8 * i + 15] = t;   \
}

static int
aes_set_key(void *ctx_arg, const u8 *in_key, unsigned int key_len, u32 *flags)
{
...
        case 32:
...
                for (i = 0; i &lt; 7; ++i)
                        loop8 (i);
...

&lt;--  snip  --&gt;


The problem is:

  8 * 6 + 15 = 63  &gt;  59


cu
Adrian

-- 

       "Is there not promise of rain?" Ling Tan asked suddenly out
        of the darkness. There had been need of rain for many days.
       "Only a promise," Lao Er said.
                                       Pearl S. Buck - Dragon Seed

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060308200015</emailId><senderName>"Jan Johansson"</senderName><senderEmail>j2@mupp.net</senderEmail><timestampReceived>2006-03-08 20:00:15-0400</timestampReceived><subject>WIerdness when creating Loop-aes file?</subject><body>

Hello!

I used the instructions on
http://deb.riseup.net/storage/encryption/loop-aes/ to create a encrypted
area. But when I get to the 'dd' stage (using /dev/loop1 and /dev/md2),
weird things starts to happen.

I should have plenty of memory
             total       used       free     shared    buffers
cached
Mem:       3116936    3095872      21064          0     178824
2545060
-/+ buffers/cache:     371988    2744948
Swap:      1951888        772    1951116
cookiemonster:~/VMware#

At the time of the problem, swap was less then 50MB in use.

Running Debian 3.1
cookiemonster:~/VMware# uname -a
Linux cookiemonster 2.6.8-2-686 #1 Tue Aug 16 13:22:48 UTC 2005 i686
GNU/Linux

cookiemonster:~/VMware# dpkg -l | grep aes
ii  loop-aes-2.6.8 2.2d-5+2.6.8-1 AES-encryption loopback Linux kernel
module
ii  loop-aes-sourc 2.2d-5         AES-encryption loopback Linux kernel
module
ii  loop-aes-utils 2.12p-4sarge1  Tools for mounting and manipulating
filesyst
cookiemonster:~/VMware#

I am not sure what other info is useful?

Mar  7 19:20:40 cookiemonster kernel: oom-killer: gfp_mask=0xd0
Mar  7 19:20:40 cookiemonster kernel: DMA per-cpu:
Mar  7 19:20:40 cookiemonster kernel: cpu 0 hot: low 2, high 6, batch 1
Mar  7 19:20:40 cookiemonster kernel: cpu 0 cold: low 0, high 2, batch 1
Mar  7 19:20:40 cookiemonster kernel: Normal per-cpu:
Mar  7 19:20:40 cookiemonster kernel: cpu 0 hot: low 32, high 96, batch
16
Mar  7 19:20:40 cookiemonster kernel: cpu 0 cold: low 0, high 32, batch
16
Mar  7 19:20:40 cookiemonster kernel: HighMem per-cpu:
Mar  7 19:20:40 cookiemonster kernel: cpu 0 hot: low 32, high 96, batch
16
Mar  7 19:20:40 cookiemonster kernel: cpu 0 cold: low 0, high 32, batch
16
Mar  7 19:20:40 cookiemonster kernel:
Mar  7 19:20:40 cookiemonster kernel: Free pages:       56112kB (51712kB
HighMem)
Mar  7 19:20:40 cookiemonster kernel: Active:314462 inactive:417279
dirty:98112 writeback:190440 unstable:0 free:14028 slab:24168
mapped:5741
0 pagetables:323
Mar  7 19:20:40 cookiemonster kernel: DMA free:1904kB min:16kB low:32kB
high:48kB active:0kB inactive:7904kB present:16384kB
Mar  7 19:20:40 cookiemonster kernel: protections[]: 8 476 732
Mar  7 19:20:41 cookiemonster kernel: Normal free:2496kB min:936kB
low:1872kB high:2808kB active:108kB inactive:760052kB present:901120kB
Mar  7 19:20:41 cookiemonster kernel: protections[]: 0 468 724
Mar  7 19:20:41 cookiemonster kernel: HighMem free:51712kB min:512kB
low:1024kB high:1536kB active:1257740kB inactive:901160kB present:222790
4kB
Mar  7 19:20:41 cookiemonster kernel: protections[]: 0 0 256
Mar  7 19:20:41 cookiemonster kernel: DMA: 0*4kB 126*8kB 46*16kB 5*32kB
0*64kB 0*128kB 0*256kB 0*512kB 0*1024kB 0*2048kB 0*4096kB = 1904kB
Mar  7 19:20:41 cookiemonster kernel: Normal: 138*4kB 13*8kB 1*16kB
47*32kB 5*64kB 0*128kB 0*256kB 0*512kB 0*1024kB 0*2048kB 0*4096kB =
2496k
B
Mar  7 19:20:41 cookiemonster kernel: HighMem: 246*4kB 891*8kB 293*16kB
180*32kB 46*64kB 24*128kB 2*256kB 0*512kB 8*1024kB 3*2048kB 3*4096kB
= 51712kB
Mar  7 19:20:41 cookiemonster kernel: Swap cache: add 637, delete 530,
find 111/130, race 0+0
Mar  7 19:20:41 cookiemonster kernel: Out of Memory: Killed process
29237 (mysqld).
Mar  7 19:21:01 cookiemonster mysqld_safe[29297]: Number of processes
running now: 0
: Mar  7 19:21:07 cookiemonster mysqld_safe[29299]: restarted
Mar  7 19:21:08 cookiemonster kernel: oom-killer: gfp_mask=0xd0
Mar  7 19:21:08 cookiemonster kernel: DMA per-cpu:
Mar  7 19:21:08 cookiemonster kernel: cpu 0 hot: low 2, high 6, batch 1
Mar  7 19:21:08 cookiemonster kernel: cpu 0 cold: low 0, high 2, batch 1
Mar  7 19:21:08 cookiemonster kernel: Normal per-cpu:
Mar  7 19:21:08 cookiemonster kernel: cpu 0 hot: low 32, high 96, batch
16
Mar  7 19:21:08 cookiemonster kernel: cpu 0 cold: low 0, high 32, batch
16
Mar  7 19:21:08 cookiemonster kernel: HighMem per-cpu:
Mar  7 19:21:08 cookiemonster kernel: cpu 0 hot: low 32, high 96, batch
16
Mar  7 19:21:08 cookiemonster kernel: cpu 0 cold: low 0, high 32, batch
16
Mar  7 19:21:08 cookiemonster kernel:
Mar  7 19:21:08 cookiemonster kernel: Free pages:       71888kB (68160kB
HighMem)
Mar  7 19:21:08 cookiemonster kernel: Active:312689 inactive:415107
dirty:704 writeback:189093 unstable:0 free:17972 slab:24235 mapped:55481
pagetables:307
Mar  7 19:21:08 cookiemonster kernel: DMA free:1904kB min:16kB low:32kB
high:48kB active:0kB inactive:7840kB present:16384kB
Mar  7 19:21:08 cookiemonster kernel: protections[]: 8 476 732
Mar  7 19:21:09 cookiemonster kernel: Normal free:1824kB min:936kB
low:1872kB high:2808kB active:180kB inactive:760516kB present:901120kB
Mar  7 19:21:09 cookiemonster kernel: protections[]: 0 468 724
Mar  7 19:21:09 cookiemonster kernel: HighMem free:68160kB min:512kB
low:1024kB high:1536kB active:1250576kB inactive:892072kB present:222790
4kB
Mar  7 19:21:09 cookiemonster kernel: protections[]: 0 0 256
Mar  7 19:21:09 cookiemonster kernel: DMA: 0*4kB 126*8kB 46*16kB 5*32kB
0*64kB 0*128kB 0*256kB 0*512kB 0*1024kB 0*2048kB 0*4096kB = 1904kB
Mar  7 19:21:09 cookiemonster kernel: Normal: 0*4kB 0*8kB 2*16kB 46*32kB
5*64kB 0*128kB 0*256kB 0*512kB 0*1024kB 0*2048kB 0*4096kB = 1824kB
Mar  7 19:21:09 cookiemonster kernel: HighMem: 0*4kB 656*8kB 622*16kB
213*32kB 111*64kB 41*128kB 14*256kB 7*512kB 8*1024kB 3*2048kB 3*4096kB
= 68160kB
Mar  7 19:21:09 cookiemonster kernel: Swap cache: add 637, delete 530,
find 111/130, race 0+0
Mar  7 19:21:09 cookiemonster kernel: Out of Memory: Killed process
26106 (apache2).
Mar  7 19:22:49 cookiemonster mysqld[29302]: 060307 19:22:49  InnoDB:
Database was not shut down normally!
Mar  7 19:22:49 cookiemonster mysqld[29302]: InnoDB: Starting crash
recovery.
Mar  7 19:22:49 cookiemonster mysqld[29302]: InnoDB: Reading tablespace
information from the .ibd files...
Mar  7 19:23:14 cookiemonster mysqld[29302]: InnoDB: Restoring possible
half-written data pages from the doublewrite
Mar  7 19:23:14 cookiemonster mysqld[29302]: InnoDB: buffer...
Mar  7 19:23:30 cookiemonster mysqld[29302]: 060307 19:23:30  InnoDB:
Starting log scan based on checkpoint at
Mar  7 19:23:30 cookiemonster mysqld[29302]: InnoDB: log sequence number
0 45164.
Mar  7 19:23:31 cookiemonster mysqld[29302]: InnoDB: Doing recovery:
scanned up to log sequence number 0 45164
Mar  7 19:23:44 cookiemonster mysqld[29302]: InnoDB: Last MySQL binlog
file position 0 79, file name /var/log/mysql/mysql-bin.000037
Mar  7 19:23:44 cookiemonster mysqld[29302]: 060307 19:23:44  InnoDB:
Flushing modified pages from the buffer pool...
Mar  7 19:23:45 cookiemonster mysqld[29302]: 060307 19:23:45  InnoDB:
Started; log sequence number 0 45164
Mar  7 19:23:49 cookiemonster mysqld[29302]: /usr/sbin/mysqld: ready for
connections.
Mar  7 19:23:49 cookiemonster mysqld[29302]: Version:
'4.1.11-Debian_4sarge2-log'  socket: '/var/run/mysqld/mysqld.sock'
port: 3306  Source
distribution
:


And also
Mar  7 21:09:53 cookiemonster kernel: kswapd0: page allocation failure.
order:0, mode:0x50
Mar  7 21:09:54 cookiemonster kernel:  [__alloc_pages+760/880]
__alloc_pages+0x2f8/0x370
Mar  7 21:09:54 cookiemonster kernel:  [find_or_create_page+184/208]
find_or_create_page+0xb8/0xd0
Mar  7 21:09:54 cookiemonster kernel:  [grow_dev_page+57/352]
grow_dev_page+0x39/0x160
Mar  7 21:09:54 cookiemonster kernel:  [__getblk_slow+205/368]
__getblk_slow+0xcd/0x170
Mar  7 21:09:54 cookiemonster kernel:  [__getblk+99/112]
__getblk+0x63/0x70
Mar  7 21:09:54 cookiemonster kernel:  [__bread+39/80] __bread+0x27/0x50
Mar  7 21:09:54 cookiemonster kernel:  [__crc_pm_idle+45719/5541136]
read_block_bitmap+0x56/0xa0 [ext3]
Mar  7 21:09:54 cookiemonster kernel:  [__crc_pm_idle+48923/5541136]
ext3_new_block+0x14a/0x570 [ext3]
Mar  7 21:09:54 cookiemonster kernel:  [__wait_on_buffer+147/176]
__wait_on_buffer+0x93/0xb0
Mar  7 21:09:54 cookiemonster kernel:  [submit_bh+97/336]
submit_bh+0x61/0x150
Mar  7 21:09:54 cookiemonster kernel:  [__crc_pm_idle+59988/5541136]
ext3_alloc_block+0x33/0x40 [ext3]
Mar  7 21:09:54 cookiemonster kernel:  [__crc_pm_idle+60939/5541136]
ext3_alloc_branch+0x4a/0x2b0 [ext3]
Mar  7 21:09:54 cookiemonster kernel:  [__crc_pm_idle+62465/5541136]
ext3_get_block_handle+0x190/0x380 [ext3]
Mar  7 21:09:54 cookiemonster kernel:
[__crc_xfrm_state_alloc+4173565/4557196] ide_dma_intr+0x0/0xb0
[ide_core]
Mar  7 21:09:54 cookiemonster kernel:
[__crc_xfrm_state_alloc+4174925/4557196] dma_timer_expiry+0x0/0x80
[ide_core]
Mar  7 21:09:54 cookiemonster kernel:
[__crc_xfrm_state_alloc+4377542/4557196]
journal_alloc_journal_head+0x19/0x90 [jbd]
Mar  7 21:09:54 cookiemonster kernel:  [__crc_pm_idle+63062/5541136]
ext3_get_block+0x65/0xc0 [ext3]
Mar  7 21:09:54 cookiemonster kernel:  [__block_write_full_page+583/880]
__block_write_full_page+0x247/0x370
Mar  7 21:09:54 cookiemonster kernel:  [block_write_full_page+240/256]
block_write_full_page+0xf0/0x100
Mar  7 21:09:54 cookiemonster kernel:  [__crc_pm_idle+62961/5541136]
ext3_get_block+0x0/0xc0 [ext3]
Mar  7 21:09:54 cookiemonster kernel:  [__crc_pm_idle+66220/5541136]
ext3_ordered_writepage+0xcb/0x1c0 [ext3]
Mar  7 21:09:54 cookiemonster kernel:  [__crc_pm_idle+62961/5541136]
ext3_get_block+0x0/0xc0 [ext3]
Mar  7 21:09:54 cookiemonster kernel:  [__crc_pm_idle+65953/5541136]
bget_one+0x0/0x10 [ext3]
Mar  7 21:09:54 cookiemonster kernel:  [pageout+193/272]
pageout+0xc1/0x110
Mar  7 21:09:54 cookiemonster kernel:  [shrink_list+587/1248]
shrink_list+0x24b/0x4e0
Mar  7 21:09:54 cookiemonster kernel:  [__pagevec_release+40/64]
__pagevec_release+0x28/0x40
Mar  7 21:09:54 cookiemonster kernel:  [__pagevec_release+40/64]
__pagevec_release+0x28/0x40
Mar  7 21:09:54 cookiemonster kernel:  [shrink_cache+332/832]
shrink_cache+0x14c/0x340
Mar  7 21:09:54 cookiemonster kernel:  [shrink_slab+136/400]
shrink_slab+0x88/0x190
Mar  7 21:09:54 cookiemonster kernel:  [shrink_zone+170/224]
shrink_zone+0xaa/0xe0
Mar  7 21:09:54 cookiemonster kernel:  [balance_pgdat+573/688]
balance_pgdat+0x23d/0x2b0
Mar  7 21:09:54 cookiemonster kernel:  [kswapd+210/240] kswapd+0xd2/0xf0
Mar  7 21:09:54 cookiemonster kernel:  [autoremove_wake_function+0/96]
autoremove_wake_function+0x0/0x60
Mar  7 21:09:54 cookiemonster kernel:  [ret_from_fork+6/20]
ret_from_fork+0x6/0x14
Mar  7 21:09:54 cookiemonster kernel:  [autoremove_wake_function+0/96]
autoremove_wake_function+0x0/0x60
Mar  7 21:09:54 cookiemonster kernel:  [kswapd+0/240] kswapd+0x0/0xf0
Mar  7 21:09:54 cookiemonster kernel:  [kernel_thread_helper+5/24]
kernel_thread_helper+0x5/0x18
Mar  7 21:10:03 cookiemonster /USR/SBIN/CRON[5308]: (www-data) CMD
(/usr/share/cacti/site/poller.php &gt;/dev/null 2&gt;&amp;1)
Mar  7 21:10:09 cookiemonster kernel: oom-killer: gfp_mask=0xd0
Mar  7 21:10:09 cookiemonster kernel: DMA per-cpu:
Mar  7 21:10:09 cookiemonster kernel: cpu 0 hot: low 2, high 6, batch 1
Mar  7 21:10:09 cookiemonster kernel: cpu 0 cold: low 0, high 2, batch 1
Mar  7 21:10:10 cookiemonster kernel: Normal per-cpu:
Mar  7 21:10:10 cookiemonster kernel: cpu 0 hot: low 32, high 96, batch
16
Mar  7 21:10:10 cookiemonster kernel: cpu 0 cold: low 0, high 32, batch
16
Mar  7 21:10:10 cookiemonster kernel: HighMem per-cpu:
Mar  7 21:10:10 cookiemonster kernel: cpu 0 hot: low 32, high 96, batch
16
Mar  7 21:10:10 cookiemonster kernel: cpu 0 cold: low 0, high 32, batch
16
Mar  7 21:10:10 cookiemonster kernel:
Mar  7 21:10:10 cookiemonster kernel: Free pages:       21600kB (17984kB
HighMem)
Mar  7 21:10:10 cookiemonster kernel: Active:454672 inactive:289435
dirty:0 writeback:181702 unstable:0 free:5400 slab:13650 mapped:400511
pa
getables:722
Mar  7 21:10:10 cookiemonster kernel: DMA free:0kB min:16kB low:32kB
high:48kB active:0kB inactive:10932kB present:16384kB
Mar  7 21:10:10 cookiemonster kernel: protections[]: 8 476 732
Mar  7 21:10:10 cookiemonster kernel: Normal free:3616kB min:936kB
low:1872kB high:2808kB active:116kB inactive:784932kB present:901120kB
Mar  7 21:10:10 cookiemonster kernel: protections[]: 0 468 724
Mar  7 21:10:10 cookiemonster kernel: HighMem free:17984kB min:512kB
low:1024kB high:1536kB active:1818572kB inactive:361876kB present:222790
4kB
Mar  7 21:10:10 cookiemonster kernel: protections[]: 0 0 256
Mar  7 21:10:10 cookiemonster kernel: DMA: 0*4kB 0*8kB 0*16kB 0*32kB
0*64kB 0*128kB 0*256kB 0*512kB 0*1024kB 0*2048kB 0*4096kB = 0kB
Mar  7 21:10:10 cookiemonster kernel: Normal: 12*4kB 8*8kB 5*16kB 7*32kB
6*64kB 6*128kB 8*256kB 0*512kB 0*1024kB 0*2048kB 0*4096kB = 3616kB
Mar  7 21:10:10 cookiemonster kernel: HighMem: 0*4kB 10*8kB 179*16kB
90*32kB 100*64kB 19*128kB 7*256kB 1*512kB 1*1024kB 0*2048kB 0*4096kB = 1
7984kB
Mar  7 21:10:10 cookiemonster kernel: Swap cache: add 2543, delete 2459,
find 41/52, race 0+0
Mar  7 21:10:10 cookiemonster kernel: Out of Memory: Killed process 4273
(mysqld).
Mar  7 21:10:16 cookiemonster mysqld_safe[5316]: Number of processes
running now: 0
Mar  7 21:10:16 cookiemonster mysqld_safe[5318]: restarted
Mar  7 21:10:16 cookiemonster kernel: oom-killer: gfp_mask=0xd0
Mar  7 21:10:16 cookiemonster kernel: DMA per-cpu:
Mar  7 21:10:16 cookiemonster kernel: cpu 0 hot: low 2, high 6, batch 1
Mar  7 21:10:16 cookiemonster kernel: cpu 0 cold: low 0, high 2, batch 1
Mar  7 21:10:16 cookiemonster kernel: Normal per-cpu:
Mar  7 21:10:16 cookiemonster kernel: cpu 0 hot: low 32, high 96, batch
16
Mar  7 21:10:16 cookiemonster kernel: cpu 0 cold: low 0, high 32, batch
16
Mar  7 21:10:16 cookiemonster kernel: HighMem per-cpu:
Mar  7 21:10:16 cookiemonster kernel: cpu 0 hot: low 32, high 96, batch
16
Mar  7 21:10:16 cookiemonster kernel: cpu 0 cold: low 0, high 32, batch
16
Mar  7 21:10:16 cookiemonster kernel:
Mar  7 21:10:16 cookiemonster kernel: Free pages:       40896kB (37888kB
HighMem)
Mar  7 21:10:16 cookiemonster kernel: Active:451600 inactive:287628
dirty:0 writeback:181918 unstable:0 free:10224 slab:13641 mapped:396833
p
agetables:705
Mar  7 21:10:16 cookiemonster kernel: DMA free:0kB min:16kB low:32kB
high:48kB active:0kB inactive:10996kB present:16384kB

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060315075748</emailId><senderName>Dag Arne Osvik</senderName><senderEmail>dag.arne@osvik.no</senderEmail><timestampReceived>2006-03-15 07:57:48-0400</timestampReceived><subject>AES optimized for x86-64</subject><body>

Hi,

I've attached an implementation of AES optimized for 64-bit Pentium 4E. 
  The round function achieves 3 µops per cycle, so even with function 
call overhead its performance is quite good, with best average time for 
10000 consecutive encryptions at &lt;233 cycles per block.  I'll make it 
ready for inclusion in the Linux kernel later.  In the meantime, 
comments are welcome.

I'm still working on a version optimized for AMD - will get back to that 
later, as well as some 32-bit versions I'll soon provide.


Regards,

   Dag Arne Osvik

["aes128-nocona.S" (text/plain)]

/*
 * AES optimized for Intel Pentium 4E with EM64T (Nocona)
 *
 * Copyright (C) 2006 Dag Arne Osvik &lt;da@osvik.no&gt;
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

// Uniform naming for AMD64 integer registers

// 64-bit
#define 	r0	rax
#define 	r1	rdx
#define 	r2	rcx
#define 	r3	rbx
#define 	r4	rsi
#define 	r5	rdi
#define 	r6	rbp

// 32-bit
#define 	r0d	eax
#define 	r1d	edx
#define 	r2d	ecx
#define 	r3d	ebx
#define 	r4d	esi
#define 	r5d	edi
#define 	r6d	ebp

// 16-bit
#define 	r0w	ax
#define 	r1w	dx
#define 	r2w	cx
#define 	r3w	bx
#define 	r4w	si
#define 	r5w	di
#define 	r6w	bp

// 8-bit
#define 	r0b	al
#define 	r1b	dl
#define 	r2b	cl
#define 	r3b	bl
#define 	r4b	sil
#define 	r5b	dil
#define 	r6b	bpl

// High bytes
#define 	r0h	ah
#define 	r1h	dh
#define 	r2h	ch
#define 	r3h	bh

//-------------------

// Lookup tables

	.data
	.align	64

aes_ftab:
	.quad	0xa56363c6a56363c6
	.quad	0x847c7cf8847c7cf8
	.quad	0x997777ee997777ee
	.quad	0x8d7b7bf68d7b7bf6
	.quad	0x0df2f2ff0df2f2ff
	.quad	0xbd6b6bd6bd6b6bd6
	.quad	0xb16f6fdeb16f6fde
	.quad	0x54c5c59154c5c591
	.quad	0x5030306050303060
	.quad	0x0301010203010102
	.quad	0xa96767cea96767ce
	.quad	0x7d2b2b567d2b2b56
	.quad	0x19fefee719fefee7
	.quad	0x62d7d7b562d7d7b5
	.quad	0xe6abab4de6abab4d
	.quad	0x9a7676ec9a7676ec
	.quad	0x45caca8f45caca8f
	.quad	0x9d82821f9d82821f
	.quad	0x40c9c98940c9c989
	.quad	0x877d7dfa877d7dfa
	.quad	0x15fafaef15fafaef
	.quad	0xeb5959b2eb5959b2
	.quad	0xc947478ec947478e
	.quad	0x0bf0f0fb0bf0f0fb
	.quad	0xecadad41ecadad41
	.quad	0x67d4d4b367d4d4b3
	.quad	0xfda2a25ffda2a25f
	.quad	0xeaafaf45eaafaf45
	.quad	0xbf9c9c23bf9c9c23
	.quad	0xf7a4a453f7a4a453
	.quad	0x967272e4967272e4
	.quad	0x5bc0c09b5bc0c09b
	.quad	0xc2b7b775c2b7b775
	.quad	0x1cfdfde11cfdfde1
	.quad	0xae93933dae93933d
	.quad	0x6a26264c6a26264c
	.quad	0x5a36366c5a36366c
	.quad	0x413f3f7e413f3f7e
	.quad	0x02f7f7f502f7f7f5
	.quad	0x4fcccc834fcccc83
	.quad	0x5c3434685c343468
	.quad	0xf4a5a551f4a5a551
	.quad	0x34e5e5d134e5e5d1
	.quad	0x08f1f1f908f1f1f9
	.quad	0x937171e2937171e2
	.quad	0x73d8d8ab73d8d8ab
	.quad	0x5331316253313162
	.quad	0x3f15152a3f15152a
	.quad	0x0c0404080c040408
	.quad	0x52c7c79552c7c795
	.quad	0x6523234665232346
	.quad	0x5ec3c39d5ec3c39d
	.quad	0x2818183028181830
	.quad	0xa1969637a1969637
	.quad	0x0f05050a0f05050a
	.quad	0xb59a9a2fb59a9a2f
	.quad	0x0907070e0907070e
	.quad	0x3612122436121224
	.quad	0x9b80801b9b80801b
	.quad	0x3de2e2df3de2e2df
	.quad	0x26ebebcd26ebebcd
	.quad	0x6927274e6927274e
	.quad	0xcdb2b27fcdb2b27f
	.quad	0x9f7575ea9f7575ea
	.quad	0x1b0909121b090912
	.quad	0x9e83831d9e83831d
	.quad	0x742c2c58742c2c58
	.quad	0x2e1a1a342e1a1a34
	.quad	0x2d1b1b362d1b1b36
	.quad	0xb26e6edcb26e6edc
	.quad	0xee5a5ab4ee5a5ab4
	.quad	0xfba0a05bfba0a05b
	.quad	0xf65252a4f65252a4
	.quad	0x4d3b3b764d3b3b76
	.quad	0x61d6d6b761d6d6b7
	.quad	0xceb3b37dceb3b37d
	.quad	0x7b2929527b292952
	.quad	0x3ee3e3dd3ee3e3dd
	.quad	0x712f2f5e712f2f5e
	.quad	0x9784841397848413
	.quad	0xf55353a6f55353a6
	.quad	0x68d1d1b968d1d1b9
	.quad	0x0000000000000000
	.quad	0x2cededc12cededc1
	.quad	0x6020204060202040
	.quad	0x1ffcfce31ffcfce3
	.quad	0xc8b1b179c8b1b179
	.quad	0xed5b5bb6ed5b5bb6
	.quad	0xbe6a6ad4be6a6ad4
	.quad	0x46cbcb8d46cbcb8d
	.quad	0xd9bebe67d9bebe67
	.quad	0x4b3939724b393972
	.quad	0xde4a4a94de4a4a94
	.quad	0xd44c4c98d44c4c98
	.quad	0xe85858b0e85858b0
	.quad	0x4acfcf854acfcf85
	.quad	0x6bd0d0bb6bd0d0bb
	.quad	0x2aefefc52aefefc5
	.quad	0xe5aaaa4fe5aaaa4f
	.quad	0x16fbfbed16fbfbed
	.quad	0xc5434386c5434386
	.quad	0xd74d4d9ad74d4d9a
	.quad	0x5533336655333366
	.quad	0x9485851194858511
	.quad	0xcf45458acf45458a
	.quad	0x10f9f9e910f9f9e9
	.quad	0x0602020406020204
	.quad	0x817f7ffe817f7ffe
	.quad	0xf05050a0f05050a0
	.quad	0x443c3c78443c3c78
	.quad	0xba9f9f25ba9f9f25
	.quad	0xe3a8a84be3a8a84b
	.quad	0xf35151a2f35151a2
	.quad	0xfea3a35dfea3a35d
	.quad	0xc0404080c0404080
	.quad	0x8a8f8f058a8f8f05
	.quad	0xad92923fad92923f
	.quad	0xbc9d9d21bc9d9d21
	.quad	0x4838387048383870
	.quad	0x04f5f5f104f5f5f1
	.quad	0xdfbcbc63dfbcbc63
	.quad	0xc1b6b677c1b6b677
	.quad	0x75dadaaf75dadaaf
	.quad	0x6321214263212142
	.quad	0x3010102030101020
	.quad	0x1affffe51affffe5
	.quad	0x0ef3f3fd0ef3f3fd
	.quad	0x6dd2d2bf6dd2d2bf
	.quad	0x4ccdcd814ccdcd81
	.quad	0x140c0c18140c0c18
	.quad	0x3513132635131326
	.quad	0x2fececc32fececc3
	.quad	0xe15f5fbee15f5fbe
	.quad	0xa2979735a2979735
	.quad	0xcc444488cc444488
	.quad	0x3917172e3917172e
	.quad	0x57c4c49357c4c493
	.quad	0xf2a7a755f2a7a755
	.quad	0x827e7efc827e7efc
	.quad	0x473d3d7a473d3d7a
	.quad	0xac6464c8ac6464c8
	.quad	0xe75d5dbae75d5dba
	.quad	0x2b1919322b191932
	.quad	0x957373e6957373e6
	.quad	0xa06060c0a06060c0
	.quad	0x9881811998818119
	.quad	0xd14f4f9ed14f4f9e
	.quad	0x7fdcdca37fdcdca3
	.quad	0x6622224466222244
	.quad	0x7e2a2a547e2a2a54
	.quad	0xab90903bab90903b
	.quad	0x8388880b8388880b
	.quad	0xca46468cca46468c
	.quad	0x29eeeec729eeeec7
	.quad	0xd3b8b86bd3b8b86b
	.quad	0x3c1414283c141428
	.quad	0x79dedea779dedea7
	.quad	0xe25e5ebce25e5ebc
	.quad	0x1d0b0b161d0b0b16
	.quad	0x76dbdbad76dbdbad
	.quad	0x3be0e0db3be0e0db
	.quad	0x5632326456323264
	.quad	0x4e3a3a744e3a3a74
	.quad	0x1e0a0a141e0a0a14
	.quad	0xdb494992db494992
	.quad	0x0a06060c0a06060c
	.quad	0x6c2424486c242448
	.quad	0xe45c5cb8e45c5cb8
	.quad	0x5dc2c29f5dc2c29f
	.quad	0x6ed3d3bd6ed3d3bd
	.quad	0xefacac43efacac43
	.quad	0xa66262c4a66262c4
	.quad	0xa8919139a8919139
	.quad	0xa4959531a4959531
	.quad	0x37e4e4d337e4e4d3
	.quad	0x8b7979f28b7979f2
	.quad	0x32e7e7d532e7e7d5
	.quad	0x43c8c88b43c8c88b
	.quad	0x5937376e5937376e
	.quad	0xb76d6ddab76d6dda
	.quad	0x8c8d8d018c8d8d01
	.quad	0x64d5d5b164d5d5b1
	.quad	0xd24e4e9cd24e4e9c
	.quad	0xe0a9a949e0a9a949
	.quad	0xb46c6cd8b46c6cd8
	.quad	0xfa5656acfa5656ac
	.quad	0x07f4f4f307f4f4f3
	.quad	0x25eaeacf25eaeacf
	.quad	0xaf6565caaf6565ca
	.quad	0x8e7a7af48e7a7af4
	.quad	0xe9aeae47e9aeae47
	.quad	0x1808081018080810
	.quad	0xd5baba6fd5baba6f
	.quad	0x887878f0887878f0
	.quad	0x6f25254a6f25254a
	.quad	0x722e2e5c722e2e5c
	.quad	0x241c1c38241c1c38
	.quad	0xf1a6a657f1a6a657
	.quad	0xc7b4b473c7b4b473
	.quad	0x51c6c69751c6c697
	.quad	0x23e8e8cb23e8e8cb
	.quad	0x7cdddda17cdddda1
	.quad	0x9c7474e89c7474e8
	.quad	0x211f1f3e211f1f3e
	.quad	0xdd4b4b96dd4b4b96
	.quad	0xdcbdbd61dcbdbd61
	.quad	0x868b8b0d868b8b0d
	.quad	0x858a8a0f858a8a0f
	.quad	0x907070e0907070e0
	.quad	0x423e3e7c423e3e7c
	.quad	0xc4b5b571c4b5b571
	.quad	0xaa6666ccaa6666cc
	.quad	0xd8484890d8484890
	.quad	0x0503030605030306
	.quad	0x01f6f6f701f6f6f7
	.quad	0x120e0e1c120e0e1c
	.quad	0xa36161c2a36161c2
	.quad	0x5f35356a5f35356a
	.quad	0xf95757aef95757ae
	.quad	0xd0b9b969d0b9b969
	.quad	0x9186861791868617
	.quad	0x58c1c19958c1c199
	.quad	0x271d1d3a271d1d3a
	.quad	0xb99e9e27b99e9e27
	.quad	0x38e1e1d938e1e1d9
	.quad	0x13f8f8eb13f8f8eb
	.quad	0xb398982bb398982b
	.quad	0x3311112233111122
	.quad	0xbb6969d2bb6969d2
	.quad	0x70d9d9a970d9d9a9
	.quad	0x898e8e07898e8e07
	.quad	0xa7949433a7949433
	.quad	0xb69b9b2db69b9b2d
	.quad	0x221e1e3c221e1e3c
	.quad	0x9287871592878715
	.quad	0x20e9e9c920e9e9c9
	.quad	0x49cece8749cece87
	.quad	0xff5555aaff5555aa
	.quad	0x7828285078282850
	.quad	0x7adfdfa57adfdfa5
	.quad	0x8f8c8c038f8c8c03
	.quad	0xf8a1a159f8a1a159
	.quad	0x8089890980898909
	.quad	0x170d0d1a170d0d1a
	.quad	0xdabfbf65dabfbf65
	.quad	0x31e6e6d731e6e6d7
	.quad	0xc6424284c6424284
	.quad	0xb86868d0b86868d0
	.quad	0xc3414182c3414182
	.quad	0xb0999929b0999929
	.quad	0x772d2d5a772d2d5a
	.quad	0x110f0f1e110f0f1e
	.quad	0xcbb0b07bcbb0b07b
	.quad	0xfc5454a8fc5454a8
	.quad	0xd6bbbb6dd6bbbb6d
	.quad	0x3a16162c3a16162c
	.quad	0x0000006300000063
	.quad	0x0000007c0000007c
	.quad	0x0000007700000077
	.quad	0x0000007b0000007b
	.quad	0x000000f2000000f2
	.quad	0x0000006b0000006b
	.quad	0x0000006f0000006f
	.quad	0x000000c5000000c5
	.quad	0x0000003000000030
	.quad	0x0000000100000001
	.quad	0x0000006700000067
	.quad	0x0000002b0000002b
	.quad	0x000000fe000000fe
	.quad	0x000000d7000000d7
	.quad	0x000000ab000000ab
	.quad	0x0000007600000076
	.quad	0x000000ca000000ca
	.quad	0x0000008200000082
	.quad	0x000000c9000000c9
	.quad	0x0000007d0000007d
	.quad	0x000000fa000000fa
	.quad	0x0000005900000059
	.quad	0x0000004700000047
	.quad	0x000000f0000000f0
	.quad	0x000000ad000000ad
	.quad	0x000000d4000000d4
	.quad	0x000000a2000000a2
	.quad	0x000000af000000af
	.quad	0x0000009c0000009c
	.quad	0x000000a4000000a4
	.quad	0x0000007200000072
	.quad	0x000000c0000000c0
	.quad	0x000000b7000000b7
	.quad	0x000000fd000000fd
	.quad	0x0000009300000093
	.quad	0x0000002600000026
	.quad	0x0000003600000036
	.quad	0x0000003f0000003f
	.quad	0x000000f7000000f7
	.quad	0x000000cc000000cc
	.quad	0x0000003400000034
	.quad	0x000000a5000000a5
	.quad	0x000000e5000000e5
	.quad	0x000000f1000000f1
	.quad	0x0000007100000071
	.quad	0x000000d8000000d8
	.quad	0x0000003100000031
	.quad	0x0000001500000015
	.quad	0x0000000400000004
	.quad	0x000000c7000000c7
	.quad	0x0000002300000023
	.quad	0x000000c3000000c3
	.quad	0x0000001800000018
	.quad	0x0000009600000096
	.quad	0x0000000500000005
	.quad	0x0000009a0000009a
	.quad	0x0000000700000007
	.quad	0x0000001200000012
	.quad	0x0000008000000080
	.quad	0x000000e2000000e2
	.quad	0x000000eb000000eb
	.quad	0x0000002700000027
	.quad	0x000000b2000000b2
	.quad	0x0000007500000075
	.quad	0x0000000900000009
	.quad	0x0000008300000083
	.quad	0x0000002c0000002c
	.quad	0x0000001a0000001a
	.quad	0x0000001b0000001b
	.quad	0x0000006e0000006e
	.quad	0x0000005a0000005a
	.quad	0x000000a0000000a0
	.quad	0x0000005200000052
	.quad	0x0000003b0000003b
	.quad	0x000000d6000000d6
	.quad	0x000000b3000000b3
	.quad	0x0000002900000029
	.quad	0x000000e3000000e3
	.quad	0x0000002f0000002f
	.quad	0x0000008400000084
	.quad	0x0000005300000053
	.quad	0x000000d1000000d1
	.quad	0x0000000000000000
	.quad	0x000000ed000000ed
	.quad	0x0000002000000020
	.quad	0x000000fc000000fc
	.quad	0x000000b1000000b1
	.quad	0x0000005b0000005b
	.quad	0x0000006a0000006a
	.quad	0x000000cb000000cb
	.quad	0x000000be000000be
	.quad	0x0000003900000039
	.quad	0x0000004a0000004a
	.quad	0x0000004c0000004c
	.quad	0x0000005800000058
	.quad	0x000000cf000000cf
	.quad	0x000000d0000000d0
	.quad	0x000000ef000000ef
	.quad	0x000000aa000000aa
	.quad	0x000000fb000000fb
	.quad	0x0000004300000043
	.quad	0x0000004d0000004d
	.quad	0x0000003300000033
	.quad	0x0000008500000085
	.quad	0x0000004500000045
	.quad	0x000000f9000000f9
	.quad	0x0000000200000002
	.quad	0x0000007f0000007f
	.quad	0x0000005000000050
	.quad	0x0000003c0000003c
	.quad	0x0000009f0000009f
	.quad	0x000000a8000000a8
	.quad	0x0000005100000051
	.quad	0x000000a3000000a3
	.quad	0x0000004000000040
	.quad	0x0000008f0000008f
	.quad	0x0000009200000092
	.quad	0x0000009d0000009d
	.quad	0x0000003800000038
	.quad	0x000000f5000000f5
	.quad	0x000000bc000000bc
	.quad	0x000000b6000000b6
	.quad	0x000000da000000da
	.quad	0x0000002100000021
	.quad	0x0000001000000010
	.quad	0x000000ff000000ff
	.quad	0x000000f3000000f3
	.quad	0x000000d2000000d2
	.quad	0x000000cd000000cd
	.quad	0x0000000c0000000c
	.quad	0x0000001300000013
	.quad	0x000000ec000000ec
	.quad	0x0000005f0000005f
	.quad	0x0000009700000097
	.quad	0x0000004400000044
	.quad	0x0000001700000017
	.quad	0x000000c4000000c4
	.quad	0x000000a7000000a7
	.quad	0x0000007e0000007e
	.quad	0x0000003d0000003d
	.quad	0x0000006400000064
	.quad	0x0000005d0000005d
	.quad	0x0000001900000019
	.quad	0x0000007300000073
	.quad	0x0000006000000060
	.quad	0x0000008100000081
	.quad	0x0000004f0000004f
	.quad	0x000000dc000000dc
	.quad	0x0000002200000022
	.quad	0x0000002a0000002a
	.quad	0x0000009000000090
	.quad	0x0000008800000088
	.quad	0x0000004600000046
	.quad	0x000000ee000000ee
	.quad	0x000000b8000000b8
	.quad	0x0000001400000014
	.quad	0x000000de000000de
	.quad	0x0000005e0000005e
	.quad	0x0000000b0000000b
	.quad	0x000000db000000db
	.quad	0x000000e0000000e0
	.quad	0x0000003200000032
	.quad	0x0000003a0000003a
	.quad	0x0000000a0000000a
	.quad	0x0000004900000049
	.quad	0x0000000600000006
	.quad	0x0000002400000024
	.quad	0x0000005c0000005c
	.quad	0x000000c2000000c2
	.quad	0x000000d3000000d3
	.quad	0x000000ac000000ac
	.quad	0x0000006200000062
	.quad	0x0000009100000091
	.quad	0x0000009500000095
	.quad	0x000000e4000000e4
	.quad	0x0000007900000079
	.quad	0x000000e7000000e7
	.quad	0x000000c8000000c8
	.quad	0x0000003700000037
	.quad	0x0000006d0000006d
	.quad	0x0000008d0000008d
	.quad	0x000000d5000000d5
	.quad	0x0000004e0000004e
	.quad	0x000000a9000000a9
	.quad	0x0000006c0000006c
	.quad	0x0000005600000056
	.quad	0x000000f4000000f4
	.quad	0x000000ea000000ea
	.quad	0x0000006500000065
	.quad	0x0000007a0000007a
	.quad	0x000000ae000000ae
	.quad	0x0000000800000008
	.quad	0x000000ba000000ba
	.quad	0x0000007800000078
	.quad	0x0000002500000025
	.quad	0x0000002e0000002e
	.quad	0x0000001c0000001c
	.quad	0x000000a6000000a6
	.quad	0x000000b4000000b4
	.quad	0x000000c6000000c6
	.quad	0x000000e8000000e8
	.quad	0x000000dd000000dd
	.quad	0x0000007400000074
	.quad	0x0000001f0000001f
	.quad	0x0000004b0000004b
	.quad	0x000000bd000000bd
	.quad	0x0000008b0000008b
	.quad	0x0000008a0000008a
	.quad	0x0000007000000070
	.quad	0x0000003e0000003e
	.quad	0x000000b5000000b5
	.quad	0x0000006600000066
	.quad	0x0000004800000048
	.quad	0x0000000300000003
	.quad	0x000000f6000000f6
	.quad	0x0000000e0000000e
	.quad	0x0000006100000061
	.quad	0x0000003500000035
	.quad	0x0000005700000057
	.quad	0x000000b9000000b9
	.quad	0x0000008600000086
	.quad	0x000000c1000000c1
	.quad	0x0000001d0000001d
	.quad	0x0000009e0000009e
	.quad	0x000000e1000000e1
	.quad	0x000000f8000000f8
	.quad	0x0000009800000098
	.quad	0x0000001100000011
	.quad	0x0000006900000069
	.quad	0x000000d9000000d9
	.quad	0x0000008e0000008e
	.quad	0x0000009400000094
	.quad	0x0000009b0000009b
	.quad	0x0000001e0000001e
	.quad	0x0000008700000087
	.quad	0x000000e9000000e9
	.quad	0x000000ce000000ce
	.quad	0x0000005500000055
	.quad	0x0000002800000028
	.quad	0x000000df000000df
	.quad	0x0000008c0000008c
	.quad	0x000000a1000000a1
	.quad	0x0000008900000089
	.quad	0x0000000d0000000d
	.quad	0x000000bf000000bf
	.quad	0x000000e6000000e6
	.quad	0x0000004200000042
	.quad	0x0000006800000068
	.quad	0x0000004100000041
	.quad	0x0000009900000099
	.quad	0x0000002d0000002d
	.quad	0x0000000f0000000f
	.quad	0x000000b0000000b0
	.quad	0x0000005400000054
	.quad	0x000000bb000000bb
	.quad	0x0000001600000016
aes_itab:
	.quad	0x50a7f45150a7f451
	.quad	0x5365417e5365417e
	.quad	0xc3a4171ac3a4171a
	.quad	0x965e273a965e273a
	.quad	0xcb6bab3bcb6bab3b
	.quad	0xf1459d1ff1459d1f
	.quad	0xab58faacab58faac
	.quad	0x9303e34b9303e34b
	.quad	0x55fa302055fa3020
	.quad	0xf66d76adf66d76ad
	.quad	0x9176cc889176cc88
	.quad	0x254c02f5254c02f5
	.quad	0xfcd7e54ffcd7e54f
	.quad	0xd7cb2ac5d7cb2ac5
	.quad	0x8044352680443526
	.quad	0x8fa362b58fa362b5
	.quad	0x495ab1de495ab1de
	.quad	0x671bba25671bba25
	.quad	0x980eea45980eea45
	.quad	0xe1c0fe5de1c0fe5d
	.quad	0x02752fc302752fc3
	.quad	0x12f04c8112f04c81
	.quad	0xa397468da397468d
	.quad	0xc6f9d36bc6f9d36b
	.quad	0xe75f8f03e75f8f03
	.quad	0x959c9215959c9215
	.quad	0xeb7a6dbfeb7a6dbf
	.quad	0xda595295da595295
	.quad	0x2d83bed42d83bed4
	.quad	0xd3217458d3217458
	.quad	0x2969e0492969e049
	.quad	0x44c8c98e44c8c98e
	.quad	0x6a89c2756a89c275
	.quad	0x78798ef478798ef4
	.quad	0x6b3e58996b3e5899
	.quad	0xdd71b927dd71b927
	.quad	0xb64fe1beb64fe1be
	.quad	0x17ad88f017ad88f0
	.quad	0x66ac20c966ac20c9
	.quad	0xb43ace7db43ace7d
	.quad	0x184adf63184adf63
	.quad	0x82311ae582311ae5
	.quad	0x6033519760335197
	.quad	0x457f5362457f5362
	.quad	0xe07764b1e07764b1
	.quad	0x84ae6bbb84ae6bbb
	.quad	0x1ca081fe1ca081fe
	.quad	0x942b08f9942b08f9
	.quad	0x5868487058684870
	.quad	0x19fd458f19fd458f
	.quad	0x876cde94876cde94
	.quad	0xb7f87b52b7f87b52
	.quad	0x23d373ab23d373ab
	.quad	0xe2024b72e2024b72
	.quad	0x578f1fe3578f1fe3
	.quad	0x2aab55662aab5566
	.quad	0x0728ebb20728ebb2
	.quad	0x03c2b52f03c2b52f
	.quad	0x9a7bc5869a7bc586
	.quad	0xa50837d3a50837d3
	.quad	0xf2872830f2872830
	.quad	0xb2a5bf23b2a5bf23
	.quad	0xba6a0302ba6a0302
	.quad	0x5c8216ed5c8216ed
	.quad	0x2b1ccf8a2b1ccf8a
	.quad	0x92b479a792b479a7
	.quad	0xf0f207f3f0f207f3
	.quad	0xa1e2694ea1e2694e
	.quad	0xcdf4da65cdf4da65
	.quad	0xd5be0506d5be0506
	.quad	0x1f6234d11f6234d1
	.quad	0x8afea6c48afea6c4
	.quad	0x9d532e349d532e34
	.quad	0xa055f3a2a055f3a2
	.quad	0x32e18a0532e18a05
	.quad	0x75ebf6a475ebf6a4
	.quad	0x39ec830b39ec830b
	.quad	0xaaef6040aaef6040
	.quad	0x069f715e069f715e
	.quad	0x51106ebd51106ebd
	.quad	0xf98a213ef98a213e
	.quad	0x3d06dd963d06dd96
	.quad	0xae053eddae053edd
	.quad	0x46bde64d46bde64d
	.quad	0xb58d5491b58d5491
	.quad	0x055dc471055dc471
	.quad	0x6fd406046fd40604
	.quad	0xff155060ff155060
	.quad	0x24fb981924fb9819
	.quad	0x97e9bdd697e9bdd6
	.quad	0xcc434089cc434089
	.quad	0x779ed967779ed967
	.quad	0xbd42e8b0bd42e8b0
	.quad	0x888b8907888b8907
	.quad	0x385b19e7385b19e7
	.quad	0xdbeec879dbeec879
	.quad	0x470a7ca1470a7ca1
	.quad	0xe90f427ce90f427c
	.quad	0xc91e84f8c91e84f8
	.quad	0x0000000000000000
	.quad	0x8386800983868009
	.quad	0x48ed2b3248ed2b32
	.quad	0xac70111eac70111e
	.quad	0x4e725a6c4e725a6c
	.quad	0xfbff0efdfbff0efd
	.quad	0x5638850f5638850f
	.quad	0x1ed5ae3d1ed5ae3d
	.quad	0x27392d3627392d36
	.quad	0x64d90f0a64d90f0a
	.quad	0x21a65c6821a65c68
	.quad	0xd1545b9bd1545b9b
	.quad	0x3a2e36243a2e3624
	.quad	0xb1670a0cb1670a0c
	.quad	0x0fe757930fe75793
	.quad	0xd296eeb4d296eeb4
	.quad	0x9e919b1b9e919b1b
	.quad	0x4fc5c0804fc5c080
	.quad	0xa220dc61a220dc61
	.quad	0x694b775a694b775a
	.quad	0x161a121c161a121c
	.quad	0x0aba93e20aba93e2
	.quad	0xe52aa0c0e52aa0c0
	.quad	0x43e0223c43e0223c
	.quad	0x1d171b121d171b12
	.quad	0x0b0d090e0b0d090e
	.quad	0xadc78bf2adc78bf2
	.quad	0xb9a8b62db9a8b62d
	.quad	0xc8a91e14c8a91e14
	.quad	0x8519f1578519f157
	.quad	0x4c0775af4c0775af
	.quad	0xbbdd99eebbdd99ee
	.quad	0xfd607fa3fd607fa3
	.quad	0x9f2601f79f2601f7
	.quad	0xbcf5725cbcf5725c
	.quad	0xc53b6644c53b6644
	.quad	0x347efb5b347efb5b
	.quad	0x7629438b7629438b
	.quad	0xdcc623cbdcc623cb
	.quad	0x68fcedb668fcedb6
	.quad	0x63f1e4b863f1e4b8
	.quad	0xcadc31d7cadc31d7
	.quad	0x1085634210856342
	.quad	0x4022971340229713
	.quad	0x2011c6842011c684
	.quad	0x7d244a857d244a85
	.quad	0xf83dbbd2f83dbbd2
	.quad	0x1132f9ae1132f9ae
	.quad	0x6da129c76da129c7
	.quad	0x4b2f9e1d4b2f9e1d
	.quad	0xf330b2dcf330b2dc
	.quad	0xec52860dec52860d
	.quad	0xd0e3c177d0e3c177
	.quad	0x6c16b32b6c16b32b
	.quad	0x99b970a999b970a9
	.quad	0xfa489411fa489411
	.quad	0x2264e9472264e947
	.quad	0xc48cfca8c48cfca8
	.quad	0x1a3ff0a01a3ff0a0
	.quad	0xd82c7d56d82c7d56
	.quad	0xef903322ef903322
	.quad	0xc74e4987c74e4987
	.quad	0xc1d138d9c1d138d9
	.quad	0xfea2ca8cfea2ca8c
	.quad	0x360bd498360bd498
	.quad	0xcf81f5a6cf81f5a6
	.quad	0x28de7aa528de7aa5
	.quad	0x268eb7da268eb7da
	.quad	0xa4bfad3fa4bfad3f
	.quad	0xe49d3a2ce49d3a2c
	.quad	0x0d9278500d927850
	.quad	0x9bcc5f6a9bcc5f6a
	.quad	0x62467e5462467e54
	.quad	0xc2138df6c2138df6
	.quad	0xe8b8d890e8b8d890
	.quad	0x5ef7392e5ef7392e
	.quad	0xf5afc382f5afc382
	.quad	0xbe805d9fbe805d9f
	.quad	0x7c93d0697c93d069
	.quad	0xa92dd56fa92dd56f
	.quad	0xb31225cfb31225cf
	.quad	0x3b99acc83b99acc8
	.quad	0xa77d1810a77d1810
	.quad	0x6e639ce86e639ce8
	.quad	0x7bbb3bdb7bbb3bdb
	.quad	0x097826cd097826cd
	.quad	0xf418596ef418596e
	.quad	0x01b79aec01b79aec
	.quad	0xa89a4f83a89a4f83
	.quad	0x656e95e6656e95e6
	.quad	0x7ee6ffaa7ee6ffaa
	.quad	0x08cfbc2108cfbc21
	.quad	0xe6e815efe6e815ef
	.quad	0xd99be7bad99be7ba
	.quad	0xce366f4ace366f4a
	.quad	0xd4099fead4099fea
	.quad	0xd67cb029d67cb029
	.quad	0xafb2a431afb2a431
	.quad	0x31233f2a31233f2a
	.quad	0x3094a5c63094a5c6
	.quad	0xc066a235c066a235
	.quad	0x37bc4e7437bc4e74
	.quad	0xa6ca82fca6ca82fc
	.quad	0xb0d090e0b0d090e0
	.quad	0x15d8a73315d8a733
	.quad	0x4a9804f14a9804f1
	.quad	0xf7daec41f7daec41
	.quad	0x0e50cd7f0e50cd7f
	.quad	0x2ff691172ff69117
	.quad	0x8dd64d768dd64d76
	.quad	0x4db0ef434db0ef43
	.quad	0x544daacc544daacc
	.quad	0xdf0496e4df0496e4
	.quad	0xe3b5d19ee3b5d19e
	.quad	0x1b886a4c1b886a4c
	.quad	0xb81f2cc1b81f2cc1
	.quad	0x7f5165467f516546
	.quad	0x04ea5e9d04ea5e9d
	.quad	0x5d358c015d358c01
	.quad	0x737487fa737487fa
	.quad	0x2e410bfb2e410bfb
	.quad	0x5a1d67b35a1d67b3
	.quad	0x52d2db9252d2db92
	.quad	0x335610e9335610e9
	.quad	0x1347d66d1347d66d
	.quad	0x8c61d79a8c61d79a
	.quad	0x7a0ca1377a0ca137
	.quad	0x8e14f8598e14f859
	.quad	0x893c13eb893c13eb
	.quad	0xee27a9ceee27a9ce
	.quad	0x35c961b735c961b7
	.quad	0xede51ce1ede51ce1
	.quad	0x3cb1477a3cb1477a
	.quad	0x59dfd29c59dfd29c
	.quad	0x3f73f2553f73f255
	.quad	0x79ce141879ce1418
	.quad	0xbf37c773bf37c773
	.quad	0xeacdf753eacdf753
	.quad	0x5baafd5f5baafd5f
	.quad	0x146f3ddf146f3ddf
	.quad	0x86db447886db4478
	.quad	0x81f3afca81f3afca
	.quad	0x3ec468b93ec468b9
	.quad	0x2c3424382c342438
	.quad	0x5f40a3c25f40a3c2
	.quad	0x72c31d1672c31d16
	.quad	0x0c25e2bc0c25e2bc
	.quad	0x8b493c288b493c28
	.quad	0x41950dff41950dff
	.quad	0x7101a8397101a839
	.quad	0xdeb30c08deb30c08
	.quad	0x9ce4b4d89ce4b4d8
	.quad	0x90c1566490c15664
	.quad	0x6184cb7b6184cb7b
	.quad	0x70b632d570b632d5
	.quad	0x745c6c48745c6c48
	.quad	0x4257b8d04257b8d0
	.quad	0x0000005200000052
	.quad	0x0000000900000009
	.quad	0x0000006a0000006a
	.quad	0x000000d5000000d5
	.quad	0x0000003000000030
	.quad	0x0000003600000036
	.quad	0x000000a5000000a5
	.quad	0x0000003800000038
	.quad	0x000000bf000000bf
	.quad	0x0000004000000040
	.quad	0x000000a3000000a3
	.quad	0x0000009e0000009e
	.quad	0x0000008100000081
	.quad	0x000000f3000000f3
	.quad	0x000000d7000000d7
	.quad	0x000000fb000000fb
	.quad	0x0000007c0000007c
	.quad	0x000000e3000000e3
	.quad	0x0000003900000039
	.quad	0x0000008200000082
	.quad	0x0000009b0000009b
	.quad	0x0000002f0000002f
	.quad	0x000000ff000000ff
	.quad	0x0000008700000087
	.quad	0x0000003400000034
	.quad	0x0000008e0000008e
	.quad	0x0000004300000043
	.quad	0x0000004400000044
	.quad	0x000000c4000000c4
	.quad	0x000000de000000de
	.quad	0x000000e9000000e9
	.quad	0x000000cb000000cb
	.quad	0x0000005400000054
	.quad	0x0000007b0000007b
	.quad	0x0000009400000094
	.quad	0x0000003200000032
	.quad	0x000000a6000000a6
	.quad	0x000000c2000000c2
	.quad	0x0000002300000023
	.quad	0x0000003d0000003d
	.quad	0x000000ee000000ee
	.quad	0x0000004c0000004c
	.quad	0x0000009500000095
	.quad	0x0000000b0000000b
	.quad	0x0000004200000042
	.quad	0x000000fa000000fa
	.quad	0x000000c3000000c3
	.quad	0x0000004e0000004e
	.quad	0x0000000800000008
	.quad	0x0000002e0000002e
	.quad	0x000000a1000000a1
	.quad	0x0000006600000066
	.quad	0x0000002800000028
	.quad	0x000000d9000000d9
	.quad	0x0000002400000024
	.quad	0x000000b2000000b2
	.quad	0x0000007600000076
	.quad	0x0000005b0000005b
	.quad	0x000000a2000000a2
	.quad	0x0000004900000049
	.quad	0x0000006d0000006d
	.quad	0x0000008b0000008b
	.quad	0x000000d1000000d1
	.quad	0x0000002500000025
	.quad	0x0000007200000072
	.quad	0x000000f8000000f8
	.quad	0x000000f6000000f6
	.quad	0x0000006400000064
	.quad	0x0000008600000086
	.quad	0x0000006800000068
	.quad	0x0000009800000098
	.quad	0x0000001600000016
	.quad	0x000000d4000000d4
	.quad	0x000000a4000000a4
	.quad	0x0000005c0000005c
	.quad	0x000000cc000000cc
	.quad	0x0000005d0000005d
	.quad	0x0000006500000065
	.quad	0x000000b6000000b6
	.quad	0x0000009200000092
	.quad	0x0000006c0000006c
	.quad	0x0000007000000070
	.quad	0x0000004800000048
	.quad	0x0000005000000050
	.quad	0x000000fd000000fd
	.quad	0x000000ed000000ed
	.quad	0x000000b9000000b9
	.quad	0x000000da000000da
	.quad	0x0000005e0000005e
	.quad	0x0000001500000015
	.quad	0x0000004600000046
	.quad	0x0000005700000057
	.quad	0x000000a7000000a7
	.quad	0x0000008d0000008d
	.quad	0x0000009d0000009d
	.quad	0x0000008400000084
	.quad	0x0000009000000090
	.quad	0x000000d8000000d8
	.quad	0x000000ab000000ab
	.quad	0x0000000000000000
	.quad	0x0000008c0000008c
	.quad	0x000000bc000000bc
	.quad	0x000000d3000000d3
	.quad	0x0000000a0000000a
	.quad	0x000000f7000000f7
	.quad	0x000000e4000000e4
	.quad	0x0000005800000058
	.quad	0x0000000500000005
	.quad	0x000000b8000000b8
	.quad	0x000000b3000000b3
	.quad	0x0000004500000045
	.quad	0x0000000600000006
	.quad	0x000000d0000000d0
	.quad	0x0000002c0000002c
	.quad	0x0000001e0000001e
	.quad	0x0000008f0000008f
	.quad	0x000000ca000000ca
	.quad	0x0000003f0000003f
	.quad	0x0000000f0000000f
	.quad	0x0000000200000002
	.quad	0x000000c1000000c1
	.quad	0x000000af000000af
	.quad	0x000000bd000000bd
	.quad	0x0000000300000003
	.quad	0x0000000100000001
	.quad	0x0000001300000013
	.quad	0x0000008a0000008a
	.quad	0x0000006b0000006b
	.quad	0x0000003a0000003a
	.quad	0x0000009100000091
	.quad	0x0000001100000011
	.quad	0x0000004100000041
	.quad	0x0000004f0000004f
	.quad	0x0000006700000067
	.quad	0x000000dc000000dc
	.quad	0x000000ea000000ea
	.quad	0x0000009700000097
	.quad	0x000000f2000000f2
	.quad	0x000000cf000000cf
	.quad	0x000000ce000000ce
	.quad	0x000000f0000000f0
	.quad	0x000000b4000000b4
	.quad	0x000000e6000000e6
	.quad	0x0000007300000073
	.quad	0x0000009600000096
	.quad	0x000000ac000000ac
	.quad	0x0000007400000074
	.quad	0x0000002200000022
	.quad	0x000000e7000000e7
	.quad	0x000000ad000000ad
	.quad	0x0000003500000035
	.quad	0x0000008500000085
	.quad	0x000000e2000000e2
	.quad	0x000000f9000000f9
	.quad	0x0000003700000037
	.quad	0x000000e8000000e8
	.quad	0x0000001c0000001c
	.quad	0x0000007500000075
	.quad	0x000000df000000df
	.quad	0x0000006e0000006e
	.quad	0x0000004700000047
	.quad	0x000000f1000000f1
	.quad	0x0000001a0000001a
	.quad	0x0000007100000071
	.quad	0x0000001d0000001d
	.quad	0x0000002900000029
	.quad	0x000000c5000000c5
	.quad	0x0000008900000089
	.quad	0x0000006f0000006f
	.quad	0x000000b7000000b7
	.quad	0x0000006200000062
	.quad	0x0000000e0000000e
	.quad	0x000000aa000000aa
	.quad	0x0000001800000018
	.quad	0x000000be000000be
	.quad	0x0000001b0000001b
	.quad	0x000000fc000000fc
	.quad	0x0000005600000056
	.quad	0x0000003e0000003e
	.quad	0x0000004b0000004b
	.quad	0x000000c6000000c6
	.quad	0x000000d2000000d2
	.quad	0x0000007900000079
	.quad	0x0000002000000020
	.quad	0x0000009a0000009a
	.quad	0x000000db000000db
	.quad	0x000000c0000000c0
	.quad	0x000000fe000000fe
	.quad	0x0000007800000078
	.quad	0x000000cd000000cd
	.quad	0x0000005a0000005a
	.quad	0x000000f4000000f4
	.quad	0x0000001f0000001f
	.quad	0x000000dd000000dd
	.quad	0x000000a8000000a8
	.quad	0x0000003300000033
	.quad	0x0000008800000088
	.quad	0x0000000700000007
	.quad	0x000000c7000000c7
	.quad	0x0000003100000031
	.quad	0x000000b1000000b1
	.quad	0x0000001200000012
	.quad	0x0000001000000010
	.quad	0x0000005900000059
	.quad	0x0000002700000027
	.quad	0x0000008000000080
	.quad	0x000000ec000000ec
	.quad	0x0000005f0000005f
	.quad	0x0000006000000060
	.quad	0x0000005100000051
	.quad	0x0000007f0000007f
	.quad	0x000000a9000000a9
	.quad	0x0000001900000019
	.quad	0x000000b5000000b5
	.quad	0x0000004a0000004a
	.quad	0x0000000d0000000d
	.quad	0x0000002d0000002d
	.quad	0x000000e5000000e5
	.quad	0x0000007a0000007a
	.quad	0x0000009f0000009f
	.quad	0x0000009300000093
	.quad	0x000000c9000000c9
	.quad	0x0000009c0000009c
	.quad	0x000000ef000000ef
	.quad	0x000000a0000000a0
	.quad	0x000000e0000000e0
	.quad	0x0000003b0000003b
	.quad	0x0000004d0000004d
	.quad	0x000000ae000000ae
	.quad	0x0000002a0000002a
	.quad	0x000000f5000000f5
	.quad	0x000000b0000000b0
	.quad	0x000000c8000000c8
	.quad	0x000000eb000000eb
	.quad	0x000000bb000000bb
	.quad	0x0000003c0000003c
	.quad	0x0000008300000083
	.quad	0x0000005300000053
	.quad	0x0000009900000099
	.quad	0x0000006100000061
	.quad	0x0000001700000017
	.quad	0x0000002b0000002b
	.quad	0x0000000400000004
	.quad	0x0000007e0000007e
	.quad	0x000000ba000000ba
	.quad	0x0000007700000077
	.quad	0x000000d6000000d6
	.quad	0x0000002600000026
	.quad	0x000000e1000000e1
	.quad	0x0000006900000069
	.quad	0x0000001400000014
	.quad	0x0000006300000063
	.quad	0x0000005500000055
	.quad	0x0000002100000021
	.quad	0x0000000c0000000c
	.quad	0x0000007d0000007d
	 .size aes_tables, .-aes_tables

//-------------------

#define T	%r15
#define TR(x,y)	x(T, y, 8)
#define TL(x,y)	x+2048(T, y, 8)
#define KP	%r5
#define t0	%r10
#define t1	%r11
#define t2	%r12
#define t3	%r13
#define t4	%r14
#define t0d	%r10d
#define t1d	%r11d
#define t2d	%r12d
#define t3d	%r13d
#define t4d	%r14d

#define K(round, key) -128+16*(round)+4*(key)(KP)

#define FROUND(in0, in1, in2, in3, out0, out1, out2, out3, R, X, Y)	\
	mov	K(R,0), t0##d;	\
	mov	K(R,Y), t1##d;	\
	mov	K(R,2), t4##d;	\
	mov	K(R,X), t3##d;	\
	xor	t0##d, in0##d;	xor	t1##d, in3##d;	\
	\
	mov	K(R+1,0), out0##d;	movzx	in0##b, t0##d;	\
	mov	K(R+1,Y), out3##d;					shr	$8, in0##d;		\

	//mov	0(T, t0,  8), t0##d;	movzx	in0##b,  t1##d;		shr	$8, in0##d;		\

#define RROUND(in0, in1, in2, in3, out0, out1, out2, out3, R, X, Y) \
	mov	TR(0, t0), t0##d;	movzx	in0##b,  t1##d;		shr	$8, in0##d;		\
	mov	TR(3, t1), t1##d;	movzx	in0##b,  t2##d;		shr	$8, in0##d;		\
	mov	TR(2, t2), out2##d;	xor	t4##d,   in2##d;	xor	t3##d, in1##d;		\
	mov	TR(1,in0), out1##d;	movzx	in3##b,  in0##d;	rol	$8, in3##d;		\
	mov	TR(0,in0), in0##d;	movzx	in3##b,  t2##d;		rol	$8, in3##d;		\
	mov	TR(1, t2), t2##d;	movzx	in3##b,  t3##d;		shr	$24, in3##d;		\
	mov	TR(2, t3), t3##d;	xor	t0##d,   out0##d;	xor	t1##d, out3##d;		\
	mov	TR(3,in3), in3##d;	movzx	in2##b,  t0##d;		rol	$8, in2##d;		\
	mov	TR(0, t0), t0##d;	movzx	in2##b,  t1##d;		rol	$8, in2##d;		\
	mov	TR(1, t1), t1##d;	movzx	in2##b,  t4##d;		shr	$24, in2##d;		\
	mov	TR(2, t4), t4##d;	xor	t2##d,   out0##d;	xor	in0##d, out3##d;	\
	mov	TR(3,in2), in2##d;	movzx	in1##b,  in0##d;	shr	$8, in1##d;		\
	mov	TR(0,in0), in0##d;	movzx	in1##b,  t2##d;		shr	$8, in1##d;		\
	mov	TR(3, t2), t2##d;	xor	t1##d,   out3##d;	movzx	in1##b, t1##d;		\
	mov	TR(2, t1), t1##d;	xor	t4##d,   out0##d;	shr	$8, in1##d;		\
	mov	TR(1,in1), in1##d;	xor	in3##d,  out2##d;	xor	t3##d, out1##d;		\
	mov	K(R,2), t4##d;		xor	t0##d,   out2##d;	xor	in2##d, out1##d;	\
	mov	K(R,X), t3##d;		xor	t2##d,   out0##d;	xor	in0##d, out1##d;	\
	mov	K(R+1,0), in0##d;	movzx	out0##b, t0##d;		xor	t1##d, out3##d;		\
	mov	K(R+1,Y), in3##d;	xor	in1##d,  out2##d;	shr	$8, out0##d;		\

#define LROUND(in0, in1, in2, in3, out0, out1, out2, out3, R, X, Y) \
	mov	TL(0, t0), t0##d;	movzx	in0##b, t1##d;		shr	$8, in0##d;		\
	mov	TL(3, t1), t1##d;	movzx	in0##b, t2##d;		shr	$8, in0##d;		\
	mov	TL(2, t2), out2##d;	xor	t4##d,  in2##d;		xor	t3##d, in1##d;		\
	mov	TL(1,in0), out1##d;	movzx	in3##b, in0##d;		rol	$8, in3##d;		\
	mov	TL(0,in0), in0##d;	movzx	in3##b, t2##d;		rol	$8, in3##d;		\
	mov	TL(1, t2), t2##d;	movzx	in3##b, t3##d;		shr	$24, in3##d;		\
	mov	TL(2, t3), t3##d;	xor	t0##d,  out0##d;	xor	t1##d, out3##d;		\
	mov	TL(3,in3), in3##d;	movzx	in2##b, t0##d;		rol	$8, in2##d;		\
	mov	TL(0, t0), t0##d;	movzx	in2##b, t1##d;		rol	$8, in2##d;		\
	mov	TL(1, t1), t1##d;	movzx	in2##b, t4##d;		shr	$24, in2##d;		\
	mov	TL(2, t4), t4##d;	xor	t2##d,  out0##d;	xor	in0##d, out3##d;	\
	mov	TL(3,in2), in2##d;	movzx	in1##b, in0##d;		shr	$8, in1##d;		\
	mov	TL(0,in0), in0##d;	movzx	in1##b, t2##d;		shr	$8, in1##d;		\
	mov	TL(3, t2), t2##d;	xor	t1##d,  out3##d;	movzx	in1##b, t1##d;		\
	mov	TL(2, t1), t1##d;	xor	t4##d,  out0##d;	shr	$8, in1##d;		\
	mov	TL(1,in1), in1##d;	xor	in3##d, out2##d;	xor	t3##d, out1##d;		\
	mov	K(R,2), t4##d;		xor	t0##d,  out2##d;	xor	in2##d, out1##d;	\
	mov	K(R,X), t3##d;		xor	t2##d,  out0##d;	xor	in0##d, out1##d;	\
	mov	(%rsp), KP;						xor	t1##d, out3##d;		\
					xor	in1##d, out2##d;					\
					xor	t4##d,  out2##d;	xor	t3##d, out1##d;

	.text
	.global aes_encrypt
	.type aes_encrypt, @function
	.align 64
	// function parameters:
	// r5	key pointer
	// r4	output pointer
	// r1	input pointer
aes_encrypt:
	sub	$7*8, %rsp
	sub	$-128,  KP
	mov	$aes_ftab, T

	mov	%r4,  0*8(%rsp)	// output pointer
	mov	%r3,  1*8(%rsp)
	mov	%r6,  2*8(%rsp)
	mov	%r12, 3*8(%rsp)
	mov	%r13, 4*8(%rsp)
	mov	%r14, 5*8(%rsp)
	mov	%r15, 6*8(%rsp)

	mov	0*4(%r1), %r0d
	mov	1*4(%r1), %r3d
	mov	2*4(%r1), %r2d
	mov	3*4(%r1), %r1d

	FROUND(%r0, %r3, %r2, %r1, %r4, %r6, %r8, %r9, 0, 1, 3)
	RROUND(%r0, %r3, %r2, %r1, %r4, %r6, %r8, %r9, 1, 1, 3)
	RROUND(%r4, %r6, %r8, %r9, %r0, %r3, %r2, %r1, 2, 1, 3)
	RROUND(%r0, %r3, %r2, %r1, %r4, %r6, %r8, %r9, 3, 1, 3)
	RROUND(%r4, %r6, %r8, %r9, %r0, %r3, %r2, %r1, 4, 1, 3)
	RROUND(%r0, %r3, %r2, %r1, %r4, %r6, %r8, %r9, 5, 1, 3)
	RROUND(%r4, %r6, %r8, %r9, %r0, %r3, %r2, %r1, 6, 1, 3)
	RROUND(%r0, %r3, %r2, %r1, %r4, %r6, %r8, %r9, 7, 1, 3)
	RROUND(%r4, %r6, %r8, %r9, %r0, %r3, %r2, %r1, 8, 1, 3)
	RROUND(%r0, %r3, %r2, %r1, %r4, %r6, %r8, %r9, 9, 1, 3)
	LROUND(%r4, %r6, %r8, %r9, %r0, %r3, %r2, %r1, 10, 1, 3)

	// Store output, wipe and restore registers

	mov	%r0d, 0*4(KP);	xor	%r0, %r0
	mov	%r3d, 1*4(KP);	xor	%r4, %r4
	mov	%r2d, 2*4(KP);	xor	%r2, %r2
	mov	%r1d, 3*4(KP);	xor	%r1, %r1

	mov	1*8(%rsp),  %r3;	xor	%r8, %r8
	mov	2*8(%rsp),  %r6;	xor	%r9, %r9
	mov	3*8(%rsp), %r12;	xor	%r10, %r10
	mov	4*8(%rsp), %r13;	xor	%r11, %r11
	mov	5*8(%rsp), %r14;
	mov	6*8(%rsp), %r15;

	addq	$7*8, %rsp
	ret
	.size aes_encrypt, .-aes_encrypt

	.global aes_decrypt
	.type aes_decrypt, @function
	.align 64
	// function parameters:
	// r5	key pointer
	// r4	output pointer
	// r1	input pointer
aes_decrypt:
	sub	$7*8, %rsp
	sub	$-128-240, KP // decryption key expansion is offset by 240 bytes
	mov	$aes_itab, T

	mov	%r4,  0*8(%rsp)	// output pointer
	mov	%r3,  1*8(%rsp)
	mov	%r6,  2*8(%rsp)
	mov	%r12, 3*8(%rsp)
	mov	%r13, 4*8(%rsp)
	mov	%r14, 5*8(%rsp)
	mov	%r15, 6*8(%rsp)

	mov	0*4(%r1), %r0d
	mov	3*4(%r1), %r3d
	mov	2*4(%r1), %r2d
	mov	1*4(%r1), %r1d

	FROUND(%r0, %r3, %r2, %r1, %r4, %r6, %r8, %r9, 0, 3, 1)
	RROUND(%r0, %r3, %r2, %r1, %r4, %r6, %r8, %r9, 1, 3, 1)
	RROUND(%r4, %r6, %r8, %r9, %r0, %r3, %r2, %r1, 2, 3, 1)
	RROUND(%r0, %r3, %r2, %r1, %r4, %r6, %r8, %r9, 3, 3, 1)
	RROUND(%r4, %r6, %r8, %r9, %r0, %r3, %r2, %r1, 4, 3, 1)
	RROUND(%r0, %r3, %r2, %r1, %r4, %r6, %r8, %r9, 5, 3, 1)
	RROUND(%r4, %r6, %r8, %r9, %r0, %r3, %r2, %r1, 6, 3, 1)
	RROUND(%r0, %r3, %r2, %r1, %r4, %r6, %r8, %r9, 7, 3, 1)
	RROUND(%r4, %r6, %r8, %r9, %r0, %r3, %r2, %r1, 8, 3, 1)
	RROUND(%r0, %r3, %r2, %r1, %r4, %r6, %r8, %r9, 9, 3, 1)
	LROUND(%r4, %r6, %r8, %r9, %r0, %r3, %r2, %r1, 10, 3, 1)

	// Store output, wipe and restore registers

	mov	%r0d, 0*4(KP);		xor	%r0, %r0
	mov	%r3d, 3*4(KP);		xor	%r4, %r4
	mov	%r2d, 2*4(KP);		xor	%r2, %r2
	mov	%r1d, 1*4(KP);		xor	%r1, %r1

	mov	1*8(%rsp),  %r3;	xor	%r8, %r8
	mov	2*8(%rsp),  %r6;	xor	%r9, %r9
	mov	3*8(%rsp), %r12;	xor	%r10, %r10
	mov	4*8(%rsp), %r13;	xor	%r11, %r11
	mov	5*8(%rsp), %r14;
	mov	6*8(%rsp), %r15;

	addq	$7*8, %rsp
	ret
	.size aes_decrypt, .-aes_decrypt


-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060323144927</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-03-23 14:49:27-0400</timestampReceived><subject>Re: Bug#358568: fails to build with 2.6.16</subject><body>

tags 358568 +pending
thanks

I think I've found the reason.

Jari, the test for "some 2.6 kernels need # character in
KBUILD_BASENAME and KBUILD_MODNAME" returns true for Debian
2.6.16 kernels, where it used to return false for 2.6.15.
(I have not checked vanilla kernels yet)

Makefile then does

  ifeq ($(SR1),y)
     EF += -D"KBUILD_STR(s)=\#s"

which apparently gets evaluated by shell twice and causes 
the quoting to fail. It results in a syntax error:
     
    [...] -D"KBUILD_STR(s)=# [...]

I'm considering to change it to the following, but first 
wanted to ask if you know whether the change could then 
break builds for other kernels:

  ifeq ($(SR1),y)
     EF += -D"KBUILD_STR(s)=\\\#s"

The full bug report is quoted below.

cheers,
Max

On Thu, Mar 23, 2006 at 11:01:07AM +0100, Csillag Kristóf wrote:
&gt; Package: loop-aes-source
&gt; Version: 3.1c-3
&gt; Severity: important
&gt; Justification: fails to build from source
&gt; 
&gt; When I try to build the sources with make-kpkg for 2.6.16,
&gt; i get the following: (this applies to both 2.6.16-1 and 2.6.16-2)
&gt; 
&gt; make-kpkg --added-modules loop-aes modules_image 
&gt; 
&gt; [...]
&gt; make[4]: Entering directory `/usr/src/linux-source-2.6.16'
&gt; /bin/sh: -c: line 1: syntax error near unexpected token `('
&gt; /bin/sh: -c: line 1: `set -e; 	  echo '  CC [M]  \
&gt; /usr/src/modules/loop-aes/loop-AES/tmp-d-kbuild/patched-loop.o'; gcc-4.0 \
&gt; -Wp,-MD,/usr/src/modules/loop-aes/loop-AES/tmp-d-kbuild/.patched-loop.o.d  \
&gt; -nostdinc -isystem /usr/lib/gcc/i486-linux-gnu/4.0.3/include -D__KERNEL__ -Iinclude \
&gt; -include include/linux/autoconf.h -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
&gt; -fno-strict-aliasing -fno-common -ffreestanding -O2     -fomit-frame-pointer -pipe \
&gt; -msoft-float -mpreferred-stack-boundary=2  -march=i686 -mtune=pentium3 \
&gt; -Iinclude/asm-i386/mach-default -Wdeclaration-after-statement -Wno-pointer-sign \
&gt; -D"KBUILD_STR(s)=  -DMODULE -D"KBUILD_STR(s)=#s" \
&gt; -D"KBUILD_BASENAME=KBUILD_STR(patched_loop)"  -D"KBUILD_MODNAME=KBUILD_STR(loop)" \
&gt; -c -o /usr/src/modules/loop-aes/loop-AES/tmp-d-kbuild/patched-loop.o \
&gt; /usr/src/modules/loop-aes/loop-AES/tmp-d-kbuild/patched-loop.c;  \
&gt; scripts/basic/fixdep \
&gt; /usr/src/modules/loop-aes/loop-AES/tmp-d-kbuild/.patched-loop.o.d \
&gt; /usr/src/modules/loop-aes/loop-AES/tmp-d-kbuild/patched-loop.o 'gcc-4.0 \
&gt; -Wp,-MD,/usr/src/modules/loop-aes/loop-AES/tmp-d-kbuild/.patched-loop.o.d  \
&gt; -nostdinc -isystem /usr/lib/gcc/i486-linux-gnu/4.0.3/include -D__KERNEL__ -Iinclude \
&gt; -include include/linux/autoconf.h -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
&gt; -fno-strict-aliasing -fno-common -ffreestanding -O2     -fomit-frame-pointer -pipe \
&gt; -msoft-float -mpreferred-stack-boundary=2  -march=i686 -mtune=pentium3 \
&gt; -Iinclude/asm-i386/mach-default -Wdeclaration-after-statement -Wno-pointer-sign \
&gt; -D"KBUILD_STR(s)=  -DMODULE -D"KBUILD_STR(s)=#s" \
&gt; -D"KBUILD_BASENAME=KBUILD_STR(patched_loop)"  -D"KBUILD_MODNAME=KBUILD_STR(loop)" \
&gt; -c -o /usr/src/modules/loop-aes/loop-AES/tmp-d-kbuild/patched-loop.o \
&gt; /usr/src/modules/loop-aes/loop-AES/tmp-d-kbuild/patched-loop.c' &gt; \
&gt; /usr/src/modules/loop-aes/loop-AES/tmp-d-kbuild/.patched-loop.o.tmp; rm -f \
&gt; /usr/src/modules/loop-aes/loop-AES/tmp-d-kbuild/.patched-loop.o.d; mv -f \
&gt; /usr/src/modules/loop-aes/loop-AES/tmp-d-kbuild/.patched-loop.o.tmp \
&gt; /usr/src/modules/loop-aes/loop-AES/tmp-d-kbuild/.patched-loop.o.cmd' make[5]: *** \
&gt; [/usr/src/modules/loop-aes/loop-AES/tmp-d-kbuild/patched-loop.o] Error 2 make[4]: \
&gt; *** [_module_/usr/src/modules/loop-aes/loop-AES/tmp-d-kbuild] Error 2 make[4]: \
&gt; Leaving directory `/usr/src/linux-source-2.6.16' make[3]: *** [all] Error 2
&gt; make[3]: Leaving directory `/usr/src/modules/loop-aes/loop-AES'
&gt; make[2]: *** [build-stamp] Error 2
&gt; make[2]: Leaving directory `/usr/src/modules/loop-aes'
&gt; make[1]: *** [kdist_build] Error 2
&gt; make[1]: Leaving directory `/usr/src/modules/loop-aes'
&gt; Module /usr/src/modules/loop-aes failed.

&gt; This is new; for 2.6.15, this used to work.
&gt; 
&gt; Please let me know how can I help you to debug this!


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060323152316</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-03-23 15:23:16-0400</timestampReceived><subject>Re: Bug#358568: fails to build with 2.6.16</subject><body>

Max Vozeler wrote:
&gt; Jari, the test for "some 2.6 kernels need # character in
&gt; KBUILD_BASENAME and KBUILD_MODNAME" returns true for Debian
&gt; 2.6.16 kernels, where it used to return false for 2.6.15.

One of the changes that went into loop-AES-v3.1c broke that USE_KBUILD=y
that Debian module build seems to use. That KBUILD_STR(s)=\#s doesn't belong
there at all in USE_KBUILD=y builds. Below is my fix.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD


--- ../loop-AES-v3.1c/Makefile	2006-01-06 20:15:36.000000000 +0200
+++ ./Makefile	2006-01-27 15:36:38.000000000 +0200
@@ -1,7 +1,7 @@
 #
 #  Makefile
 #
-#  Written by Jari Ruusu, January 6 2006
+#  Written by Jari Ruusu, January 27 2006
 #
 #  Copyright 2001-2006 by Jari Ruusu.
 #  Redistribution of this file is permitted under the GNU Public License.
@@ -118,11 +118,13 @@
 	SR1:=$(shell if grep -q -s "^basename_flags.*KBUILD_BASENAME.*KBUILD_STR" \
$(LS)/scripts/Makefile.lib; then echo y; fi)  endif
 
+ifneq ($(USE_KBUILD),y)
 ifeq ($(SR1),y)
 	EF += -D"KBUILD_STR(s)=\#s"
 else
 	EF += -D"KBUILD_STR(s)=s"
 endif
+endif
 
 ifeq ($(KEYSCRUB),y)
 ifeq ($(shell if [ "$(VERSION)$(PATCHLEVEL)0" -ge 240 ]; then echo y; fi),y)

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060315093553</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-03-15 09:35:53-0400</timestampReceived><subject>Re: AES optimized for x86-64</subject><body>

On Wed, Mar 15, 2006 at 08:57:48AM +0100, Dag Arne Osvik wrote:
&gt; 
&gt; I've attached an implementation of AES optimized for 64-bit Pentium 4E. 
&gt;  The round function achieves 3 ?ops per cycle, so even with function 
&gt; call overhead its performance is quite good, with best average time for 
&gt; 10000 consecutive encryptions at &lt;233 cycles per block.  I'll make it 
&gt; ready for inclusion in the Linux kernel later.  In the meantime, 
&gt; comments are welcome.

Cool.  How does this compare with the existing x86-64 AES implementation?

Thanks,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060315143233</emailId><senderName>Dag Arne Osvik</senderName><senderEmail>dag.arne@osvik.no</senderEmail><timestampReceived>2006-03-15 14:32:33-0400</timestampReceived><subject>Re: AES optimized for x86-64</subject><body>

Herbert Xu wrote:
&gt; On Wed, Mar 15, 2006 at 08:57:48AM +0100, Dag Arne Osvik wrote:
&gt; 
&gt;&gt;I've attached an implementation of AES optimized for 64-bit Pentium 4E. 
&gt;&gt; The round function achieves 3 ?ops per cycle, so even with function 
&gt;&gt;call overhead its performance is quite good, with best average time for 
&gt;&gt;10000 consecutive encryptions at &lt;233 cycles per block.  I'll make it 
&gt;&gt;ready for inclusion in the Linux kernel later.  In the meantime, 
&gt;&gt;comments are welcome.
&gt; 
&gt; 
&gt; Cool.  How does this compare with the existing x86-64 AES implementation?

Using the best average encryption time per block from tcrypt's speed 
tests gave these numbers:

ECB on Intel	288.5
ECB on AMD	286.1

CBC on Intel	510.4
CBC on AMD	334.2


   Dag Arne
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060315173154</emailId><senderName>Dag Arne Osvik</senderName><senderEmail>dag.arne@osvik.no</senderEmail><timestampReceived>2006-03-15 17:31:54-0400</timestampReceived><subject>Re: AES optimized for x86-64</subject><body>

Dag Arne Osvik wrote:
&gt; Herbert Xu wrote:
&gt; 
&gt;&gt; On Wed, Mar 15, 2006 at 08:57:48AM +0100, Dag Arne Osvik wrote:
&gt;&gt;
&gt;&gt;&gt; I've attached an implementation of AES optimized for 64-bit Pentium 
&gt;&gt;&gt; 4E. The round function achieves 3 ?ops per cycle, so even with 
&gt;&gt;&gt; function call overhead its performance is quite good, with best 
&gt;&gt;&gt; average time for 10000 consecutive encryptions at &lt;233 cycles per 
&gt;&gt;&gt; block.  I'll make it ready for inclusion in the Linux kernel later.  
&gt;&gt;&gt; In the meantime, comments are welcome.
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt; Cool.  How does this compare with the existing x86-64 AES implementation?
&gt; 
&gt; 
&gt; Using the best average encryption time per block from tcrypt's speed 
&gt; tests gave these numbers:
&gt; 
&gt; ECB on Intel    288.5
&gt; ECB on AMD    286.1
&gt; 
&gt; CBC on Intel    510.4
&gt; CBC on AMD    334.2

Sorry.  Those AMD numbers are for the C version, not asm.

Btw, those 510 cycles for CBC are rather surprising.  Maybe ECB is using 
the assembler version, while CBC uses C?


   Dag Arne
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060315202855</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-03-15 20:28:55-0400</timestampReceived><subject>Re: AES optimized for x86-64</subject><body>

On Wed, Mar 15, 2006 at 03:32:33PM +0100, Dag Arne Osvik wrote:
&gt;
&gt; &gt;Cool.  How does this compare with the existing x86-64 AES implementation?
&gt; 
&gt; Using the best average encryption time per block from tcrypt's speed 
&gt; tests gave these numbers:
&gt; 
&gt; ECB on Intel	288.5
&gt; ECB on AMD	286.1
&gt; 
&gt; CBC on Intel	510.4
&gt; CBC on AMD	334.2

Sorry I'm confused.  Which one is the existing x86-64 assembly
implementation?
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060315210009</emailId><senderName>Dag Arne Osvik</senderName><senderEmail>dag.arne@osvik.no</senderEmail><timestampReceived>2006-03-15 21:00:09-0400</timestampReceived><subject>Re: AES optimized for x86-64</subject><body>

Herbert Xu wrote:
&gt; On Wed, Mar 15, 2006 at 03:32:33PM +0100, Dag Arne Osvik wrote:
&gt; 
&gt;&gt;&gt;Cool.  How does this compare with the existing x86-64 AES implementation?
&gt;&gt;
&gt;&gt;Using the best average encryption time per block from tcrypt's speed 
&gt;&gt;tests gave these numbers:
&gt;&gt;
&gt;&gt;ECB on Intel	288.5
&gt;&gt;ECB on AMD	286.1
&gt;&gt;
&gt;&gt;CBC on Intel	510.4
&gt;&gt;CBC on AMD	334.2
&gt; 
&gt; 
&gt; Sorry I'm confused.  Which one is the existing x86-64 assembly
&gt; implementation?

Sorry for the confusion..  All of these numbers are for code currently 
in the kernel.  However, it seems like only ECB on Intel used the 
assembly version.  With the asm module running also on the AMD machine, 
time for ECB on AMD dropped to 187.5 cycles per block, though CBC still 
runs at 334.2 per block.

My code isn't yet ready to be tested by tcrypt, and the number I gave 
for my code (233 cycles/block on Intel's Nocona) is from a simple 
feedback loop, essentially doing CBC encryption of the zero string.


   Dag Arne
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060331115844</emailId><senderName>"Jim MacBaine"</senderName><senderEmail>jmacbaine@gmail.com</senderEmail><timestampReceived>2006-03-31 11:58:44-0400</timestampReceived><subject>Security levels of different implementations of block crypto</subject><body>

Hello linux-crypto,

After a complete failure of my laptop's harddrive, I'm planning the
setup of the new system.  Two years ago, when I set up the old system,
I chose loop-AES, because of its apparent better security in
comparison to dm-crypt and cryptoloop.  The main points were the
possibility of a watermark attack and the possible use of precomputed
dictionaries, which are quite understandable even to me as a
non-expert on cryptography.  And for convinience, loop-AES came with a
nice script that allowed me to create a working initrd in no time.

Since then, dm-crypt has obviously caught up.  There is a cbc-essiv
mode with a secure iv generation, and with luks there is even a
standard disk format and a salted, iterated key setup which should
protect against precomputed dictionaries.  Another advantage is, that
dm-crypt is in mainline and should even work with the distribution's
kernel.  And since I use a custom initrd to allow me to suspend to
encrypted swap anyway, I see all advantages of loop-AES gone.

So here I am, not knowing which method to choose. Are there important
differences regarding the security?  I'd welcome all kind off
comments.

Regards, Jim

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060331144745</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-03-31 14:47:45-0400</timestampReceived><subject>Re: Security levels of different implementations of block crypto</subject><body>

Jim MacBaine wrote:
&gt; Since then, dm-crypt has obviously caught up.

No it has not. Loop-AES still has stronger and better IV computation, and
multi-key mode that reduces amount of data encrypted with one encryption
key.

Try modifying last byte of 512 byte sector, and observe how many 128 bit
ciphertext blocks change; loop-AES: 32, dm-crypt: 1

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060316210336</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-03-16 21:03:36-0400</timestampReceived><subject>Re: AES optimized for x86-64</subject><body>

On Wed, Mar 15, 2006 at 10:00:09PM +0100, Dag Arne Osvik wrote:
&gt;
&gt; &gt;&gt;Using the best average encryption time per block from tcrypt's speed 
&gt; &gt;&gt;tests gave these numbers:
&gt; &gt;&gt;
&gt; &gt;&gt;ECB on Intel	288.5
&gt; &gt;&gt;ECB on AMD	286.1
&gt; &gt;&gt;
&gt; &gt;&gt;CBC on Intel	510.4
&gt; &gt;&gt;CBC on AMD	334.2
&gt; 
&gt; Sorry for the confusion..  All of these numbers are for code currently 
&gt; in the kernel.  However, it seems like only ECB on Intel used the 
&gt; assembly version.  With the asm module running also on the AMD machine, 
&gt; time for ECB on AMD dropped to 187.5 cycles per block, though CBC still 
&gt; runs at 334.2 per block.

Is the 187.5 figure with your code or the existing x86-64 asm module?
If it's the existing one, what are the figures above then?

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060316215201</emailId><senderName>Dag Arne Osvik</senderName><senderEmail>dag.arne@osvik.no</senderEmail><timestampReceived>2006-03-16 21:52:01-0400</timestampReceived><subject>Re: AES optimized for x86-64</subject><body>

Herbert Xu wrote:
&gt; On Wed, Mar 15, 2006 at 10:00:09PM +0100, Dag Arne Osvik wrote:
&gt; 
&gt;&gt;&gt;&gt;Using the best average encryption time per block from tcrypt's speed 
&gt;&gt;&gt;&gt;tests gave these numbers:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;ECB on Intel	288.5
&gt;&gt;&gt;&gt;ECB on AMD	286.1
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;CBC on Intel	510.4
&gt;&gt;&gt;&gt;CBC on AMD	334.2
&gt;&gt;
&gt;&gt;Sorry for the confusion..  All of these numbers are for code currently 
&gt;&gt;in the kernel.  However, it seems like only ECB on Intel used the 
&gt;&gt;assembly version.  With the asm module running also on the AMD machine, 
&gt;&gt;time for ECB on AMD dropped to 187.5 cycles per block, though CBC still 
&gt;&gt;runs at 334.2 per block.
&gt; 
&gt; 
&gt; Is the 187.5 figure with your code or the existing x86-64 asm module?
&gt; If it's the existing one, what are the figures above then?

187.5 is for the existing x86-64 asm module running on an AMD Athlon 64. 
  None of the above numbers are for my code, since I haven't made a 
kernel module of it just yet, and hence can't report tcrypt testing 
results for it.

The only real news I'm presenting is that my code performs CBC-like 
encryption in about 233 cycles on a 64-bit Intel Celeron.  Apart from 
that, I was very surprised that CBC-mode encryption in the kernel is so 
slow compared to ECB.  The difference is really just four xor operations 
per block.


   Dag Arne

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060308225447</emailId><senderName>"Christian"</senderName><senderEmail>evil@g-house.de</senderEmail><timestampReceived>2006-03-08 22:54:47-0400</timestampReceived><subject>Re: WIerdness when creating Loop-aes file?</subject><body>

On Wed, March 8, 2006 21:00, Jan Johansson wrote:
&gt; Mar  7 19:20:41 cookiemonster kernel: Swap cache: add 637, delete 530,
&gt; find 111/130, race 0+0 Mar  7 19:20:41 cookiemonster kernel: Out of
&gt; Memory: Killed process 29237 (mysqld).

&gt; Mar  7 19:21:09 cookiemonster kernel: Swap cache: add 637, delete 530,
&gt; find 111/130, race 0+0 Mar  7 19:21:09 cookiemonster kernel: Out of
&gt; Memory: Killed process 26106 (apache2).

hm, /me fails to see the relation to loop-aes here. sure, loading another
module alters the kernel in some way, and accessing a loop-device could
have an impact on the VM - but this just looks like an "ordinary" OOM
error.
at what stage did the error occur?

&gt; Running Debian 3.1
&gt; cookiemonster:~/VMware# uname -a
&gt; Linux cookiemonster 2.6.8-2-686 #1 Tue Aug 16 13:22:48 UTC 2005 i686

hm, have you
1) tried a recent (vanilla) kernel?
2) searched debian/bugs for any OOM issues?

is this reproducible in any way?
if yes, did the recent kernel help? if not, you've got reason to Cc: LKML :)

cheers,
Christian.
-- 
make bzImage, not war


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060309055036</emailId><senderName>"Jan Johansson"</senderName><senderEmail>j2@mupp.net</senderEmail><timestampReceived>2006-03-09 05:50:36-0400</timestampReceived><subject>RE: WIerdness when creating Loop-aes file?</subject><body>

&gt;hm, /me fails to see the relation to loop-aes here. 

If I 'dd' to a file that is NOT set up with losetup I do not get the
error.

&gt;at what stage did the error occur?

dd if=/dev/zero of=/dev/loop1 bs=4k conv=notrunc 2&gt;/dev/null

&gt;is this reproducible in any way?

Every time I try the above. But if I do _not_ perform the below command,
it does not happen.
head -c 15 /dev/urandom | uuencode -m - | head -n 2 | tail -n 1 |
losetup -p 0 -e AES256  /dev/loop3 /dev/md4

If this means the problem is still unrelated to loop-aes, ill take my
inquiries elsewhere :)

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060309090950</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-03-09 09:09:50-0400</timestampReceived><subject>Re: WIerdness when creating Loop-aes file?</subject><body>

Jan Johansson wrote:
&gt; dd if=/dev/zero of=/dev/loop1 bs=4k conv=notrunc 2&gt;/dev/null
&gt; 
&gt; &gt;is this reproducible in any way?
&gt; 
&gt; Every time I try the above. But if I do _not_ perform the below command,
&gt; it does not happen.
&gt; head -c 15 /dev/urandom | uuencode -m - | head -n 2 | tail -n 1 |
&gt; losetup -p 0 -e AES256  /dev/loop3 /dev/md4

Please post exact sequence of commands that you used. Also include info
about what devices your MD device consist of. Device sizes also.

What you said was inconsistent. loop3/md4 vs. loop1/md2

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060309195025</emailId><senderName>"Jan Johansson"</senderName><senderEmail>j2@mupp.net</senderEmail><timestampReceived>2006-03-09 19:50:25-0400</timestampReceived><subject>RE: WIerdness when creating Loop-aes file?</subject><body>

&gt;What you said was inconsistent. loop3/md4 vs. loop1/md2

I will do that. Just as a "sort out" 3/4 were the examples on the page.
1/2 was what I actually used. 

I start by rebooting my system to be sure.

cookiemonster:~/VMware# reboot
[removed useless info about system shutting down]

We log in, and I recreated the array (after zeroing superblocks)
mdadm --create /dev/md2 --chunk=64 --level=raid1 --raid-devices=2
/dev/hde1 /dev/hdf1


cookiemonster:~# mdadm --detail /dev/md2
/dev/md2:
        Version : 00.90.01
  Creation Time : Thu Mar  9 20:25:02 2006
     Raid Level : raid1
     Array Size : 80418112 (76.69 GiB 82.35 GB)
    Device Size : 80418112 (76.69 GiB 82.35 GB)
   Raid Devices : 2
  Total Devices : 2
Preferred Minor : 2
    Persistence : Superblock is persistent

    Update Time : Thu Mar  9 20:25:02 2006
          State : clean, resyncing
 Active Devices : 2
Working Devices : 2
 Failed Devices : 0
  Spare Devices : 0

 Rebuild Status : 2% complete

           UUID : 5e24575f:df3b5a81:f2a68636:ff7f6e2b
         Events : 0.415

    Number   Major   Minor   RaidDevice State
       0      33        1        0      active sync
/dev/.static/dev/hde1
       1      33       65        1      active sync
/dev/.static/dev/hdf1
cookiemonster:~#

We have plenty of memory
cookiemonster:~# free
             total       used       free     shared    buffers
cached
Mem:       3116936     170160    2946776          0       6296
73592
-/+ buffers/cache:      90272    3026664
Swap:      1951888          0    1951888
cookiemonster:~#
cookiemonster:~# modprobe loop
cookiemonster:~# head -c 15 /dev/urandom | uuencode -m - | head -n 2 |
tail -n 1 | losetup -p 0 -e AES256  /dev/loop1 /dev/md2

So far, all is well, log shows:
Mar  9 20:29:24 cookiemonster kernel: loop: loaded (max 8 devices)
Mar  9 20:29:24 cookiemonster udev[4958]: creating device node
'/dev/loop0'
Mar  9 20:29:24 cookiemonster udev[4965]: creating device node
'/dev/loop1'
Mar  9 20:29:24 cookiemonster udev[4972]: creating device node
'/dev/loop2'
Mar  9 20:29:24 cookiemonster udev[5007]: creating device node
'/dev/loop3'
Mar  9 20:29:24 cookiemonster udev[5008]: creating device node
'/dev/loop4'
Mar  9 20:29:24 cookiemonster udev[5009]: creating device node
'/dev/loop5'
Mar  9 20:29:24 cookiemonster udev[5010]: creating device node
'/dev/loop6'
Mar  9 20:29:24 cookiemonster udev[5011]: creating device node
'/dev/loop7'

cookiemonster:~# dd if=/dev/zero of=/dev/loop3 bs=4k conv=notrunc
2&gt;/dev/null
cookiemonster:~# losetup -d /dev/loop1
cookiemonster:~# losetup -F /dev/loop1
Password:
cookiemonster:~# mkfs.ext3 /dev/loop1

And THEN I get the below (but mind you, the FS create continues, until
"Writing inode tables: Done" and then the terminal freezes. But
processes starts to dies with OOM ( still have plenty RAM left).
cookiemonster:~# free
             total       used       free     shared    buffers
cached
Mem:       3116936     983468    2133468          0     819064
45896
-/+ buffers/cache:     118508    2998428
Swap:      1951888          0    1951888
cookiemonster:~#

Mar  9 20:32:46 cookiemonster kernel: Out of Memory: Killed process 4256
(mysqld).
Mar  9 20:32:46 cookiemonster mysqld_safe[5080]: Number of processes
running now: 0
Mar  9 20:32:46 cookiemonster mysqld_safe[5082]: restarted
Mar  9 20:32:48 cookiemonster mysqld[5085]: 060309 20:32:48  InnoDB:
Database was not shut down normally!
Mar  9 20:32:48 cookiemonster mysqld[5085]: InnoDB: Starting crash
recovery.
Mar  9 20:32:48 cookiemonster mysqld[5085]: InnoDB: Reading tablespace
information from the .ibd files...
Mar  9 20:32:48 cookiemonster mysqld[5085]: InnoDB: Restoring possible
half-written data pages from the doublewrite
Mar  9 20:32:48 cookiemonster mysqld[5085]: InnoDB: buffer...
Mar  9 20:32:49 cookiemonster mysqld[5085]: 060309 20:32:49  InnoDB:
Starting log scan based on checkpoint at
Mar  9 20:32:49 cookiemonster mysqld[5085]: InnoDB: log sequence number
0 45824.
Mar  9 20:32:49 cookiemonster mysqld[5085]: InnoDB: Doing recovery:
scanned up to log sequence number 0 45824
Mar  9 20:32:49 cookiemonster mysqld[5085]: InnoDB: Last MySQL binlog
file position 0 79, file name /var/log/mysql/mysql-bin.000051
Mar  9 20:32:49 cookiemonster mysqld[5085]: 060309 20:32:49  InnoDB:
Flushing modified pages from the buffer pool...
Mar  9 20:32:50 cookiemonster mysqld[5085]: 060309 20:32:50  InnoDB:
Started; log sequence number 0 45824
Mar  9 20:32:51 cookiemonster mysqld[5085]: /usr/sbin/mysqld: ready for
connections.
Mar  9 20:32:51 cookiemonster mysqld[5085]: Version:
'4.1.11-Debian_4sarge2-log'  socket: '/var/run/mysqld/mysqld.sock'
port: 3306  Source distribution


==&gt; /var/log/messages &lt;==
Mar  9 20:31:58 cookiemonster kernel: swapper: page allocation failure.
order:0, mode:0x20
Mar  9 20:31:59 cookiemonster kernel:  [__alloc_pages+760/880]
__alloc_pages+0x2f8/0x370
Mar  9 20:31:59 cookiemonster kernel:  [__get_free_pages+37/64]
__get_free_pages+0x25/0x40
Mar  9 20:31:59 cookiemonster kernel:  [kmem_getpages+34/192]
kmem_getpages+0x22/0xc0
Mar  9 20:31:59 cookiemonster kernel:  [cache_grow+186/384]
cache_grow+0xba/0x180
Mar  9 20:31:59 cookiemonster kernel:  [cache_alloc_refill+362/544]
cache_alloc_refill+0x16a/0x220
Mar  9 20:31:59 cookiemonster kernel:
[__crc_xfrm_state_alloc+4160046/4557196] do_rw_taskfile+0x1c1/0x290
[ide_core]
Mar  9 20:31:59 cookiemonster kernel:  [kmem_cache_alloc+62/64]
kmem_cache_alloc+0x3e/0x40
Mar  9 20:31:59 cookiemonster kernel:  [send_signal+174/368]
send_signal+0xae/0x170
Mar  9 20:31:59 cookiemonster kernel:  [__group_send_sig_info+142/224]
__group_send_sig_info+0x8e/0xe0
Mar  9 20:31:59 cookiemonster kernel:  [group_send_sig_info+138/176]
group_send_sig_info+0x8a/0xb0
Mar  9 20:31:59 cookiemonster kernel:  [it_real_fn+0/96]
it_real_fn+0x0/0x60
Mar  9 20:31:59 cookiemonster kernel:  [send_group_sig_info+49/96]
send_group_sig_info+0x31/0x60
Mar  9 20:31:59 cookiemonster kernel:  [it_real_fn+36/96]
it_real_fn+0x24/0x60
Mar  9 20:31:59 cookiemonster kernel:  [run_timer_softirq+203/448]
run_timer_softirq+0xcb/0x1c0
Mar  9 20:31:59 cookiemonster kernel:  [do_timer+224/240]
do_timer+0xe0/0xf0
Mar  9 20:31:59 cookiemonster kernel:  [__do_softirq+123/128]
__do_softirq+0x7b/0x80
Mar  9 20:31:59 cookiemonster kernel:  [do_softirq+39/48]
do_softirq+0x27/0x30
Mar  9 20:31:59 cookiemonster kernel:  [do_IRQ+251/304]
do_IRQ+0xfb/0x130
Mar  9 20:31:59 cookiemonster kernel:  [common_interrupt+24/32]
common_interrupt+0x18/0x20
Mar  9 20:31:59 cookiemonster kernel:  [pvc_info+123/256]
pvc_info+0x7b/0x100
Mar  9 20:31:59 cookiemonster kernel:  [default_idle+35/64]
default_idle+0x23/0x40
Mar  9 20:31:59 cookiemonster kernel:  [cpu_idle+52/64]
cpu_idle+0x34/0x40
Mar  9 20:31:59 cookiemonster kernel:  [start_kernel+424/496]
start_kernel+0x1a8/0x1f0
Mar  9 20:31:59 cookiemonster kernel:  [unknown_bootoption+0/352]
unknown_bootoption+0x0/0x160

==&gt; /var/log/syslog &lt;==
Mar  9 20:31:58 cookiemonster kernel: swapper: page allocation failure.
order:0, mode:0x20
Mar  9 20:31:59 cookiemonster kernel:  [__alloc_pages+760/880]
__alloc_pages+0x2f8/0x370
Mar  9 20:31:59 cookiemonster kernel:  [__get_free_pages+37/64]
__get_free_pages+0x25/0x40
Mar  9 20:31:59 cookiemonster kernel:  [kmem_getpages+34/192]
kmem_getpages+0x22/0xc0
Mar  9 20:31:59 cookiemonster kernel:  [cache_grow+186/384]
cache_grow+0xba/0x180
Mar  9 20:31:59 cookiemonster kernel:  [cache_alloc_refill+362/544]
cache_alloc_refill+0x16a/0x220
Mar  9 20:31:59 cookiemonster kernel:
[__crc_xfrm_state_alloc+4160046/4557196] do_rw_taskfile+0x1c1/0x290
[ide_core]
Mar  9 20:31:59 cookiemonster kernel:  [kmem_cache_alloc+62/64]
kmem_cache_alloc+0x3e/0x40
Mar  9 20:31:59 cookiemonster kernel:  [send_signal+174/368]
send_signal+0xae/0x170
Mar  9 20:31:59 cookiemonster kernel:  [__group_send_sig_info+142/224]
__group_send_sig_info+0x8e/0xe0
Mar  9 20:31:59 cookiemonster kernel:  [group_send_sig_info+138/176]
group_send_sig_info+0x8a/0xb0
Mar  9 20:31:59 cookiemonster kernel:  [it_real_fn+0/96]
it_real_fn+0x0/0x60
Mar  9 20:31:59 cookiemonster kernel:  [send_group_sig_info+49/96]
send_group_sig_info+0x31/0x60
Mar  9 20:31:59 cookiemonster kernel:  [it_real_fn+36/96]
it_real_fn+0x24/0x60
Mar  9 20:31:59 cookiemonster kernel:  [run_timer_softirq+203/448]
run_timer_softirq+0xcb/0x1c0
Mar  9 20:31:59 cookiemonster kernel:  [do_timer+224/240]
do_timer+0xe0/0xf0
Mar  9 20:31:59 cookiemonster kernel:  [__do_softirq+123/128]
__do_softirq+0x7b/0x80
Mar  9 20:31:59 cookiemonster kernel:  [do_softirq+39/48]
do_softirq+0x27/0x30
Mar  9 20:31:59 cookiemonster kernel:  [do_IRQ+251/304]
do_IRQ+0xfb/0x130
Mar  9 20:31:59 cookiemonster kernel:  [common_interrupt+24/32]
common_interrupt+0x18/0x20
Mar  9 20:31:59 cookiemonster kernel:  [pvc_info+123/256]
pvc_info+0x7b/0x100
Mar  9 20:31:59 cookiemonster kernel:  [default_idle+35/64]
default_idle+0x23/0x40
Mar  9 20:31:59 cookiemonster kernel:  [cpu_idle+52/64]
cpu_idle+0x34/0x40
Mar  9 20:31:59 cookiemonster kernel:  [start_kernel+424/496]
start_kernel+0x1a8/0x1f0
Mar  9 20:31:59 cookiemonster kernel:  [unknown_bootoption+0/352]
unknown_bootoption+0x0/0x160



-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060309213704</emailId><senderName>"Christian"</senderName><senderEmail>evil@g-house.de</senderEmail><timestampReceived>2006-03-09 21:37:04-0400</timestampReceived><subject>RE: WIerdness when creating Loop-aes file?</subject><body>

On Thu, March 9, 2006 20:50, Jan Johansson wrote:
&gt; And THEN I get the below (but mind you, the FS create continues, until

so, you're saying that the OOM killer kicks in during mkfs.ext3? I suppose
apache/mysql were already running. If so, did you monitor the processes as
to how fast the RAM gets consumed?

&gt; "Writing inode tables: Done" and then the terminal freezes. But
&gt; processes starts to dies with OOM ( still have plenty RAM left).

I read it, that if you try to restart the processes again, the OOM killer
hits them again?

I'm no kernel guru, but it really looks like a bug. No mkfs should trigger
an OOM all of a sudden. So I'd go with a current kernel (and current
loop-aes modules)...just to be sure...

Christian.
-- 
make bzImage, not war


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060310060450</emailId><senderName>"Jan Johansson"</senderName><senderEmail>j2@mupp.net</senderEmail><timestampReceived>2006-03-10 06:04:50-0400</timestampReceived><subject>RE: WIerdness when creating Loop-aes file?</subject><body>

&gt;so, you're saying that the OOM killer kicks in during mkfs.ext3?=20

Yes. But come to think about it. It struck during 'dd' instead of 'mkfs'


&gt;I suppose
&gt;apache/mysql were already running. If so, did you monitor the processes
as
&gt;to how fast the RAM gets consumed?


That's the thing, I did "free" as fast as i could, I never had less then
900MB of physical RAM available.

&gt;I read it, that if you try to restart the processes again, the OOM
killer
&gt;hits them again?

I cant do anything with _that_ terminal. But, yes, if I try to restart
anything from another terminal, I get OOM again.

&gt;I'm no kernel guru, but it really looks like a bug. No mkfs should
trigger
&gt;an OOM all of a sudden. So I'd go with a current kernel (and current
&gt;loop-aes modules)...just to be sure...

I know what I'll be doing during the weekend then :)

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060310133201</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-03-10 13:32:01-0400</timestampReceived><subject>Re: WIerdness when creating Loop-aes file?</subject><body>

Jan Johansson wrote:
&gt; cookiemonster:~# head -c 15 /dev/urandom | uuencode -m - | head -n 2 |
&gt; tail -n 1 | losetup -p 0 -e AES256  /dev/loop1 /dev/md2

You set up loop1 device. Ok so far.

&gt; cookiemonster:~# dd if=/dev/zero of=/dev/loop3 bs=4k conv=notrunc
&gt; 2&gt;/dev/null

But here you are writing to loop3 instead of loop1. What does loop3 contain,
and what gets overwritten here? Maybe loop3 was uninitialized zero length
device, so effectively nothing was written anywhere.

&gt; Mar  9 20:32:46 cookiemonster kernel: Out of Memory: Killed process 4256
&gt; (mysqld).
[snip]
&gt; Mar  9 20:31:58 cookiemonster kernel: swapper: page allocation failure.
&gt; order:0, mode:0x20

Kernel is running out of free RAM. Someone completely depleted kernel's free
RAM pools. Even emergency pools are gone (mode:0x20 == __GFP_HIGH).

Device backed loop-AES does not allocate any RAM at run time. All RAM that
it needs is allocated at losetup/mount time.

To me this looks like the kernel code that sends write requests to loop
device depletes kernel RAM pool by agressively allocating RAM pages to hold
the data to write. Loop driver will queue all writes thrown at it, so that
significant portion of RAM pages are queued waiting to be written to
underlying device. There is something strange going on in your kernel's RAM
allocation code.

Have you set any strange values to /proc/sys/vm/* files?
Any values set in /etc/sysctl.conf file?

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060310223138</emailId><senderName>"Christian"</senderName><senderEmail>evil@g-house.de</senderEmail><timestampReceived>2006-03-10 22:31:38-0400</timestampReceived><subject>RE: WIerdness when creating Loop-aes file?</subject><body>

On Fri, March 10, 2006 07:04, Jan Johansson wrote:
&gt; I cant do anything with _that_ terminal. But, yes, if I try to restart
&gt; anything from another terminal, I get OOM again.

crazy.

&gt;&gt; an OOM all of a sudden. So I'd go with a current kernel (and current
&gt;&gt; loop-aes modules)...just to be sure...
&gt;
&gt; I know what I'll be doing during the weekend then :)

um, a "make bzImage" shouldn't take _that_ long :)
but Jari had some good advice in his post, better fix these things first
instead of blindly updating...

Christian.
-- 
make bzImage, not war


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060310235301</emailId><senderName>"Jan Johansson"</senderName><senderEmail>j2@mupp.net</senderEmail><timestampReceived>2006-03-10 23:53:01-0400</timestampReceived><subject>RE: WIerdness when creating Loop-aes file?</subject><body>

&gt;crazy.

Well, upgrading to 2.6.15 helped. It seem to work now...

Unfortunately, my MD-arrays somehow shifted in the upgrade (md2 swapped
place with md1) so I accidentally clobbered about 200GB of stuff...
"Luckilly" in this case "stuff" is equal to recordings from mythtv which
cant really be considered vital... But still :)

I still do not know what was up with the 2.6.8 stuff...=20

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060314221740</emailId><senderName>"Christian"</senderName><senderEmail>evil@g-house.de</senderEmail><timestampReceived>2006-03-14 22:17:40-0400</timestampReceived><subject>RE: WIerdness when creating Loop-aes file?</subject><body>

On Sat, March 11, 2006 00:53, Jan Johansson wrote:
&gt; Unfortunately, my MD-arrays somehow shifted in the upgrade (md2 swapped
&gt; place with md1) so I accidentally clobbered about 200GB of stuff...
&gt; "Luckilly" in this case "stuff" is equal to recordings from mythtv which
&gt; cant really be considered vital... But still :)

ouch! that was not supposed to happen :(

my condolence for the lost data,
Christian.
-- 
make bzImage, not war


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060315063510</emailId><senderName>"Jan Johansson"</senderName><senderEmail>j2@mupp.net</senderEmail><timestampReceived>2006-03-15 06:35:10-0400</timestampReceived><subject>RE: WIerdness when creating Loop-aes file?</subject><body>

&gt;ouch! that was not supposed to happen :(

No real pain. I SHOULD have checked everything before doing anything.

But seriously, got any idea _why_ it happened?

&gt;my condolence for the lost data,

I did not have a backup, since I had judged it as "non vital", so it is just
an annoyance and not a crisis :)


["smime.p7s" (application/x-pkcs7-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060315114343</emailId><senderName>Dale Amon</senderName><senderEmail>amon@vnl.com</senderEmail><timestampReceived>2006-03-15 11:43:43-0400</timestampReceived><subject>Re: WIerdness when creating Loop-aes file?</subject><body>

On Wed, Mar 15, 2006 at 07:35:10AM +0100, Jan Johansson wrote:
&gt; &gt;ouch! that was not supposed to happen :(

And it is why I would never use software raid on a
production server!


--=20
------------------------------------------------------
             Artemis Systems Development
   Dale Amon     amon@islandone.org    +44-7802-188325
       International linux systems consultancy
     Hardware &amp; software system design, security
    and networking, systems programming and Admin
	      "Have Laptop, Will Travel"
------------------------------------------------------

["signature.asc" (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060315190446</emailId><senderName>"Jan Johansson"</senderName><senderEmail>j2@mupp.net</senderEmail><timestampReceived>2006-03-15 19:04:46-0400</timestampReceived><subject>RE: WIerdness when creating Loop-aes file?</subject><body>

&gt;And it is why I would never use software raid on a
&gt;production server!

Gee, then I wonder why I have had the exact same thing happen with hardware
RAID? When I upgraded a server from a 2.0 -&gt; 2.2 kernel the cards got
initialized in the opposite order, and hence the volumes got interchanged.

["smime.p7s" (application/x-pkcs7-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060315205107</emailId><senderName>Dale Amon</senderName><senderEmail>amon@vnl.com</senderEmail><timestampReceived>2006-03-15 20:51:07-0400</timestampReceived><subject>Re: WIerdness when creating Loop-aes file?</subject><body>

On Wed, Mar 15, 2006 at 08:04:46PM +0100, Jan Johansson wrote:
&gt; 
&gt; &gt;And it is why I would never use software raid on a
&gt; &gt;production server!
&gt; 
&gt; Gee, then I wonder why I have had the exact same thing happen with hardware
&gt; RAID? When I upgraded a server from a 2.0 -&gt; 2.2 kernel the cards got
&gt; initialized in the opposite order, and hence the volumes got interchanged.

One also needs to have a test server before rolling
out onto production servers.

-- 
------------------------------------------------------
             Artemis Systems Development
   Dale Amon     amon@islandone.org    +44-7802-188325
       International linux systems consultancy
     Hardware &amp; software system design, security
    and networking, systems programming and Admin
	      "Have Laptop, Will Travel"
------------------------------------------------------

["signature.asc" (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060315220633</emailId><senderName>"Jan Johansson"</senderName><senderEmail>j2@mupp.net</senderEmail><timestampReceived>2006-03-15 22:06:33-0400</timestampReceived><subject>RE: WIerdness when creating Loop-aes file?</subject><body>

&gt;One also needs to have a test server before rolling
&gt;out onto production servers.

Yes? Well, I think I have a few... Even though my budget for hardware =
this year is under =E2=82=AC100.000. But, if you are telling me that =
_nothing_ unexpected have _ever_ happened in your environment, I tip my =
hat to you ;)



["smime.p7s" (application/x-pkcs7-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060315225131</emailId><senderName>Dale Amon</senderName><senderEmail>amon@vnl.com</senderEmail><timestampReceived>2006-03-15 22:51:31-0400</timestampReceived><subject>Re: WIerdness when creating Loop-aes file?</subject><body>

On Wed, Mar 15, 2006 at 11:06:33PM +0100, Jan Johansson wrote:
&gt; &gt; One also needs to have a test server before rolling
&gt; &gt; out onto production servers.
&gt; 
&gt; Yes? Well, I think I have a few... Even though my budget for hardware this year is \
&gt; under ???100.000. But, if you are telling me that _nothing_ unexpected have _ever_ \
&gt; happened in your environment, I tip my hat to you ;)

Well, now that you mention it... there was the
lightning strike that took out a microwave
base station; then there was the brass bolt which
somehow, some workman managed to drop through the
vents and into a server power supply... and the
batch of IBM hard drives that started dying like
aged fruit flies 4 weeks after installation...

-- 
------------------------------------------------------
             Artemis Systems Development
   Dale Amon     amon@islandone.org    +44-7802-188325
       International linux systems consultancy
     Hardware &amp; software system design, security
    and networking, systems programming and Admin
	      "Have Laptop, Will Travel"
------------------------------------------------------


["signature.asc" (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060311024116</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-03-11 02:41:16-0400</timestampReceived><subject>Re: [2.6 patch] crypto/aes.c: array overrun</subject><body>

On Sat, Mar 11, 2006 at 02:03:39AM +0100, Adrian Bunk wrote:
&gt;
&gt; ...
&gt; #define loop8(i)                                    \

...

&gt;     t ^= E_KEY[8 * i + 7]; E_KEY[8 * i + 15] = t;   \
&gt; }
&gt; 
&gt; static int
&gt; aes_set_key(void *ctx_arg, const u8 *in_key, unsigned int key_len, u32 *flags)
&gt; {
&gt; ...
&gt;         case 32:
&gt; ...
&gt;                 for (i = 0; i &lt; 7; ++i)
&gt;                         loop8 (i);

OK this is not pretty but it is actually correct.  Notice how we only
overstep the mark for E_KEY but never for D_KEY.  Since D_KEY is only
initialised after this, it is OK for us to trash the start of D_KEY.

It's just a trick that makes the code slightly nicer (and no I didn't
write this nor am I necessarily condoning it :)

Thanks for reporting this though.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060313103006</emailId><senderName>Pavel Machek</senderName><senderEmail>pavel@ucw.cz</senderEmail><timestampReceived>2006-03-13 10:30:06-0400</timestampReceived><subject>Re: [2.6 patch] crypto/aes.c: array overrun</subject><body>

On So 11-03-06 13:41:16, Herbert Xu wrote:
&gt; On Sat, Mar 11, 2006 at 02:03:39AM +0100, Adrian Bunk wrote:
&gt; &gt;
&gt; &gt; ...
&gt; &gt; #define loop8(i)                                    \
&gt; 
&gt; ...
&gt; 
&gt; &gt;     t ^= E_KEY[8 * i + 7]; E_KEY[8 * i + 15] = t;   \
&gt; &gt; }
&gt; &gt; 
&gt; &gt; static int
&gt; &gt; aes_set_key(void *ctx_arg, const u8 *in_key, unsigned int key_len, u32 *flags)
&gt; &gt; {
&gt; &gt; ...
&gt; &gt;         case 32:
&gt; &gt; ...
&gt; &gt;                 for (i = 0; i &lt; 7; ++i)
&gt; &gt;                         loop8 (i);
&gt; 
&gt; OK this is not pretty but it is actually correct.  Notice how we only
                                  ~~~~~~~~~~~~~~~~~
&gt; overstep the mark for E_KEY but never for D_KEY.  Since D_KEY is only
&gt; initialised after this, it is OK for us to trash the start of D_KEY.
&gt; 
&gt; It's just a trick that makes the code slightly nicer (and no I didn't
&gt; write this nor am I necessarily condoning it :)

Overstepping array is not correct C. Even if gcc lays it out in order
where array-to-be-thrashed is after it, so it works in practice, it is
not okay. [Some kind of security-hardened-gcc may stop this as buffer
overflow, for example]
								Pavel
-- 
161:    {
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060314202508</emailId><senderName></senderName><senderEmail>valdis.kletnieks</senderEmail><timestampReceived>2006-03-14 20:25:08-0400</timestampReceived><subject>Re: [2.6 patch] crypto/aes.c: array overrun</subject><body>

On Sat, 11 Mar 2006 13:41:16 +1100, Herbert Xu said:

&gt; OK this is not pretty but it is actually correct.  Notice how we only
&gt; overstep the mark for E_KEY but never for D_KEY.  Since D_KEY is only
&gt; initialised after this, it is OK for us to trash the start of D_KEY.

I think a big comment block describing this behavior is called for,
as it carries an implicit requirement that D_KEY and E_KEY remain
adjacent in memory.  Anybody allocating space between them is in for
a rude awakening....


[Attachment #3 (application/pgp-signature)]
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060314225448</emailId><senderName>David McCullough</senderName><senderEmail>david_mccullough@au.securecomputing.com</senderEmail><timestampReceived>2006-03-14 22:54:48-0400</timestampReceived><subject>Re: [2.6 patch] crypto/aes.c: array overrun</subject><body>

Jivin Valdis.Kletnieks@vt.edu lays it down ...
&gt; On Sat, 11 Mar 2006 13:41:16 +1100, Herbert Xu said:
&gt; 
&gt; &gt; OK this is not pretty but it is actually correct.  Notice how we only
&gt; &gt; overstep the mark for E_KEY but never for D_KEY.  Since D_KEY is only
&gt; &gt; initialised after this, it is OK for us to trash the start of D_KEY.
&gt; 
&gt; I think a big comment block describing this behavior is called for,
&gt; as it carries an implicit requirement that D_KEY and E_KEY remain
&gt; adjacent in memory.  Anybody allocating space between them is in for
&gt; a rude awakening....

Sounds like a bug waiting to happen to me.
Why not do something like the attached patch.

Cheers,
Davidm

-- 
David McCullough, david_mccullough@au.securecomputing.com, Ph:+61 734352815
Secure Computing - SnapGear  http://www.uCdot.org http://www.cyberguard.com

["aes.diff" (text/plain)]

Index: linux-2.6.x/crypto/aes.c
===================================================================
RCS file: linux-2.6.x/crypto/aes.c,v
retrieving revision 1.1.1.6
diff -u -r1.1.1.6 aes.c
--- linux-2.6.x/crypto/aes.c	31 Aug 2005 00:33:03 -0000	1.1.1.6
+++ linux-2.6.x/crypto/aes.c	14 Mar 2006 22:53:06 -0000
@@ -78,12 +78,11 @@
 
 struct aes_ctx {
 	int key_length;
-	u32 E[60];
-	u32 D[60];
+	u32 _KEYS[120];
 };
 
-#define E_KEY ctx-&gt;E
-#define D_KEY ctx-&gt;D
+#define E_KEY (&amp;ctx-&gt;_KEYS[0])
+#define D_KEY (&amp;ctx-&gt;_KEYS[60])
 
 static u8 pow_tab[256] __initdata;
 static u8 log_tab[256] __initdata;

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060315003212</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-03-15 00:32:12-0400</timestampReceived><subject>Re: [2.6 patch] crypto/aes.c: array overrun</subject><body>

On Wed, Mar 15, 2006 at 08:54:48AM +1000, David McCullough wrote:
&gt;  
&gt;  struct aes_ctx {
&gt;  	int key_length;
&gt; -	u32 E[60];
&gt; -	u32 D[60];
&gt; +	u32 _KEYS[120];
&gt;  };

Looks good.  Thanks for this David.

Could you please change the name from _KEYS to buf and patch the x86-64
version as well?

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060315011132</emailId><senderName>David McCullough</senderName><senderEmail>david_mccullough@au.securecomputing.com</senderEmail><timestampReceived>2006-03-15 01:11:32-0400</timestampReceived><subject>Re: [2.6 patch] crypto/aes.c: array overrun</subject><body>

Jivin Herbert Xu lays it down ...
&gt; On Wed, Mar 15, 2006 at 08:54:48AM +1000, David McCullough wrote:
&gt; &gt;  
&gt; &gt;  struct aes_ctx {
&gt; &gt;  	int key_length;
&gt; &gt; -	u32 E[60];
&gt; &gt; -	u32 D[60];
&gt; &gt; +	u32 _KEYS[120];
&gt; &gt;  };
&gt; 
&gt; Looks good.  Thanks for this David.
&gt; 
&gt; Could you please change the name from _KEYS to buf and patch the x86-64
&gt; version as well?

No problems, attached.

Cheers,
Davidm

-- 
David McCullough, david_mccullough@au.securecomputing.com, Ph:+61 734352815
Secure Computing - SnapGear  http://www.uCdot.org http://www.cyberguard.com

["aes2.diff" (text/plain)]

Index: linux-2.6.x/crypto/aes.c
===================================================================
RCS file: linux-2.6.x/crypto/aes.c,v
retrieving revision 1.1.1.6
diff -u -r1.1.1.6 aes.c
--- linux-2.6.x/crypto/aes.c	31 Aug 2005 00:33:03 -0000	1.1.1.6
+++ linux-2.6.x/crypto/aes.c	15 Mar 2006 01:09:37 -0000
@@ -78,12 +78,11 @@
 
 struct aes_ctx {
 	int key_length;
-	u32 E[60];
-	u32 D[60];
+	u32 buf[120];
 };
 
-#define E_KEY ctx-&gt;E
-#define D_KEY ctx-&gt;D
+#define E_KEY (&amp;ctx-&gt;buf[0])
+#define D_KEY (&amp;ctx-&gt;buf[60])
 
 static u8 pow_tab[256] __initdata;
 static u8 log_tab[256] __initdata;
Index: linux-2.6.x/arch/x86_64/crypto/aes.c
===================================================================
RCS file: linux-2.6.x/arch/x86_64/crypto/aes.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 aes.c
--- linux-2.6.x/arch/x86_64/crypto/aes.c	31 Aug 2005 00:33:07 -0000	1.1.1.1
+++ linux-2.6.x/arch/x86_64/crypto/aes.c	15 Mar 2006 01:09:37 -0000
@@ -79,12 +79,11 @@
 struct aes_ctx
 {
 	u32 key_length;
-	u32 E[60];
-	u32 D[60];
+	u32 buf[120];
 };
 
-#define E_KEY ctx-&gt;E
-#define D_KEY ctx-&gt;D
+#define E_KEY (&amp;ctx-&gt;buf[0])
+#define D_KEY (&amp;ctx-&gt;buf[60])
 
 static u8 pow_tab[256] __initdata;
 static u8 log_tab[256] __initdata;

-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

</body></email><email><emailId>20060314195827</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-03-14 19:58:27-0400</timestampReceived><subject>Re: Encrypt swap? LOOP:_SET_STATUS failed.</subject><body>

On Tue, Mar 14, 2006 at 08:40:30PM +0100, Jan Johansson wrote:
&gt; Running on Debian testing, and trying to encrypt swap with the help of
&gt; /usr/share/doc/loop-aes-2.6.15-1-686/README.gz
&gt; 
&gt; But I get a error when I get to the swapon-all stage?
&gt; 
&gt; cookiemonster:/var/log/samba# cat /etc/fstab | grep swap
&gt; /dev/hda2       none            swap    sw,loop=/dev/loop2,encryption=ASE128
                                                                        ^^^^^^
You have a typo there. s/ASE/AES/

cheers,
Max

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060314200137</emailId><senderName>"Jan Johansson"</senderName><senderEmail>j2@mupp.net</senderEmail><timestampReceived>2006-03-14 20:01:37-0400</timestampReceived><subject>RE: Encrypt swap? LOOP:_SET_STATUS failed.</subject><body>

&gt;You have a typo there. s/ASE/AES/

Guess how stupid I feel now? Thanks. :)

Silly question here. 

Do I understand correctly that this will generate a new key every reboot?
But how does that logic work? What scripts/inits takes care of that=

["smime.p7s" (application/x-pkcs7-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060311231238</emailId><senderName>Matt Mackall</senderName><senderEmail>mpm@selenic.com</senderEmail><timestampReceived>2006-03-11 23:12:38-0400</timestampReceived><subject>Re: [PATCH] crypto: fix key alignment in tcrypt</subject><body>

On Wed, Mar 08, 2006 at 11:11:55PM +0900, Atsushi Nemoto wrote:
&gt; Force 32-bit alignment on keys in tcrypt test vectors.
&gt; 
&gt; Signed-off-by: Atsushi Nemoto &lt;anemo@mba.ocn.ne.jp&gt;
&gt; 
&gt; diff --git a/crypto/tcrypt.h b/crypto/tcrypt.h
&gt; index 733d07e..050f852 100644
&gt; --- a/crypto/tcrypt.h
&gt; +++ b/crypto/tcrypt.h
&gt; @@ -31,7 +31,7 @@ struct hash_testvec {
&gt;  	char digest[MAX_DIGEST_SIZE];
&gt;  	unsigned char np;
&gt;  	unsigned char tap[MAX_TAP];
&gt; -	char key[128]; /* only used with keyed hash algorithms */
&gt; +	char key[128] __attribute__((__aligned__(4))); /* only used with keyed hash algorithms */
&gt;  	unsigned char ksize;
&gt;  };
&gt;  
&gt; @@ -48,7 +48,7 @@ struct hmac_testvec {
&gt;  struct cipher_testvec {
&gt;  	unsigned char fail;
&gt;  	unsigned char wk; /* weak key flag */
&gt; -	char key[MAX_KEYLEN];
&gt; +	char key[MAX_KEYLEN] __attribute__((__aligned__(4)));
&gt;  	unsigned char klen;
&gt;  	char iv[MAX_IVLEN];
&gt;  	char input[48];

Wouldn't it be better to simply move this to the head of the structure?

-- 
Mathematics is the supreme nostalgia of our time.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060311232907</emailId><senderName>Andreas Schwab</senderName><senderEmail>schwab@suse.de</senderEmail><timestampReceived>2006-03-11 23:29:07-0400</timestampReceived><subject>Re: [PATCH] crypto: fix key alignment in tcrypt</subject><body>

Matt Mackall &lt;mpm@selenic.com&gt; writes:

&gt; On Wed, Mar 08, 2006 at 11:11:55PM +0900, Atsushi Nemoto wrote:
&gt;&gt; Force 32-bit alignment on keys in tcrypt test vectors.
&gt;&gt; 
&gt;&gt; Signed-off-by: Atsushi Nemoto &lt;anemo@mba.ocn.ne.jp&gt;
&gt;&gt; 
&gt;&gt; diff --git a/crypto/tcrypt.h b/crypto/tcrypt.h
&gt;&gt; index 733d07e..050f852 100644
&gt;&gt; --- a/crypto/tcrypt.h
&gt;&gt; +++ b/crypto/tcrypt.h
&gt;&gt; @@ -31,7 +31,7 @@ struct hash_testvec {
&gt;&gt;  	char digest[MAX_DIGEST_SIZE];
&gt;&gt;  	unsigned char np;
&gt;&gt;  	unsigned char tap[MAX_TAP];
&gt;&gt; -	char key[128]; /* only used with keyed hash algorithms */
&gt;&gt; +	char key[128] __attribute__((__aligned__(4))); /* only used with keyed hash algorithms */
&gt;&gt;  	unsigned char ksize;
&gt;&gt;  };
&gt;&gt;  
&gt;&gt; @@ -48,7 +48,7 @@ struct hmac_testvec {
&gt;&gt;  struct cipher_testvec {
&gt;&gt;  	unsigned char fail;
&gt;&gt;  	unsigned char wk; /* weak key flag */
&gt;&gt; -	char key[MAX_KEYLEN];
&gt;&gt; +	char key[MAX_KEYLEN] __attribute__((__aligned__(4)));
&gt;&gt;  	unsigned char klen;
&gt;&gt;  	char iv[MAX_IVLEN];
&gt;&gt;  	char input[48];
&gt;
&gt; Wouldn't it be better to simply move this to the head of the structure?

That wouldn't help, since the whole structure will still be only 8-bit
aligned.

Andreas.

-- 
Andreas Schwab, SuSE Labs, schwab@suse.de
SuSE Linux Products GmbH, Maxfeldstraße 5, 90409 Nürnberg, Germany
PGP key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
"And now for something completely different."
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060311234841</emailId><senderName>Matt Mackall</senderName><senderEmail>mpm@selenic.com</senderEmail><timestampReceived>2006-03-11 23:48:41-0400</timestampReceived><subject>Re: [PATCH] crypto: fix key alignment in tcrypt</subject><body>

On Sun, Mar 12, 2006 at 12:29:07AM +0100, Andreas Schwab wrote:
&gt; Matt Mackall &lt;mpm@selenic.com&gt; writes:
&gt; 
&gt; &gt; On Wed, Mar 08, 2006 at 11:11:55PM +0900, Atsushi Nemoto wrote:
&gt; &gt;&gt; Force 32-bit alignment on keys in tcrypt test vectors.
&gt; &gt;&gt; 
&gt; &gt;&gt; Signed-off-by: Atsushi Nemoto &lt;anemo@mba.ocn.ne.jp&gt;
&gt; &gt;&gt; 
&gt; &gt;&gt; diff --git a/crypto/tcrypt.h b/crypto/tcrypt.h
&gt; &gt;&gt; index 733d07e..050f852 100644
&gt; &gt;&gt; --- a/crypto/tcrypt.h
&gt; &gt;&gt; +++ b/crypto/tcrypt.h
&gt; &gt;&gt; @@ -31,7 +31,7 @@ struct hash_testvec {
&gt; &gt;&gt;  	char digest[MAX_DIGEST_SIZE];
&gt; &gt;&gt;  	unsigned char np;
&gt; &gt;&gt;  	unsigned char tap[MAX_TAP];
&gt; &gt;&gt; -	char key[128]; /* only used with keyed hash algorithms */
&gt; &gt;&gt; +	char key[128] __attribute__((__aligned__(4))); /* only used with keyed hash algorithms */
&gt; &gt;&gt;  	unsigned char ksize;
&gt; &gt;&gt;  };
&gt; &gt;&gt;  
&gt; &gt;&gt; @@ -48,7 +48,7 @@ struct hmac_testvec {
&gt; &gt;&gt;  struct cipher_testvec {
&gt; &gt;&gt;  	unsigned char fail;
&gt; &gt;&gt;  	unsigned char wk; /* weak key flag */
&gt; &gt;&gt; -	char key[MAX_KEYLEN];
&gt; &gt;&gt; +	char key[MAX_KEYLEN] __attribute__((__aligned__(4)));
&gt; &gt;&gt;  	unsigned char klen;
&gt; &gt;&gt;  	char iv[MAX_IVLEN];
&gt; &gt;&gt;  	char input[48];
&gt; &gt;
&gt; &gt; Wouldn't it be better to simply move this to the head of the structure?
&gt; 
&gt; That wouldn't help, since the whole structure will still be only 8-bit
&gt; aligned.

Ahh, hadn't noticed the struct was entirely populated by chars.

-- 
Mathematics is the supreme nostalgia of our time.
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060308180606</emailId><senderName>"Christian"</senderName><senderEmail>evil@g-house.de</senderEmail><timestampReceived>2006-03-08 18:06:06-0400</timestampReceived><subject>Re: attacks on Linxu RNG (paper)</subject><body>

On Wed, March 8, 2006 15:25, Jean-Luc Cooke wrote:
&gt; I didn't not write this.  I've given up trying to convince people of the
&gt; problems with the Linux RNG long ago.

I've heard of this, but never got around looking into this. thanks for the
link!

&gt; ps.  My out-of-date Fortuna RNG page: http://jlcooke.ca/random/

why is this out-of-date? the last patch is for 2.6.12, is it not
maintained any more? I suppose that you have sent patches to lkml as well
- any pointers why the patches were rejected...?

thanks,
Christian.
-- 
make bzImage, not war


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060309221030</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-03-09 22:10:30-0400</timestampReceived><subject>Re: [PATCH] crypto: fix unaligned access in khazad module</subject><body>

On Thu, Mar 09, 2006 at 12:26:38PM +0900, Atsushi Nemoto wrote:
&gt;  
&gt; -	K2 = be64_to_cpu(key[0]);
&gt; -	K1 = be64_to_cpu(key[1]);
&gt; +	K2 = be64_to_cpu(get_unaligned(&amp;key[0]));
&gt; +	K1 = be64_to_cpu(get_unaligned(&amp;key[1]));

How about doing two 32-bit reads:

	const __be32 *key = (const __be32 *)in_key;

	K2 = ((u64)be32_to_cpu(key[0])) &lt;&lt; 32 + be32_to_cpu(key[1]);
	K1 = ((u64)be32_to_cpu(key[2])) &lt;&lt; 32 + be32_to_cpu(key[3]);

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060313103058</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-03-13 10:30:58-0400</timestampReceived><subject>Re: [PATCH] crypto: add missing cra_alignmask</subject><body>

On Wed, Mar 08, 2006 at 11:10:35PM +0900, Atsushi Nemoto wrote:
&gt; The "des3_ede" and "serpent" lack cra_alignmask.
&gt; 
&gt; Signed-off-by: Atsushi Nemoto &lt;anemo@mba.ocn.ne.jp&gt;

Patch applied.  Thanks a lot.
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060313104336</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-03-13 10:43:36-0400</timestampReceived><subject>Re: [PATCH] crypto: fix key alignment in tcrypt</subject><body>

On Sat, Mar 11, 2006 at 05:48:41PM -0600, Matt Mackall wrote:
&gt;
&gt; &gt; &gt; Wouldn't it be better to simply move this to the head of the structure?
&gt; &gt; 
&gt; &gt; That wouldn't help, since the whole structure will still be only 8-bit
&gt; &gt; aligned.
&gt; 
&gt; Ahh, hadn't noticed the struct was entirely populated by chars.

Actually moving it to the head is good anyway because we may reduce the
amount of padding between vectors.  On i386 however it is size-neutral
with respect to the vectors.  However, it did save 45 bytes on the code
front.

I've applied the patch with the structure rearrangement so that the large
power-of-2 sized members come first.

Thanks,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060314201719</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-03-14 20:17:19-0400</timestampReceived><subject>Re: Encrypt swap? LOOP:_SET_STATUS failed.</subject><body>

On Tue, Mar 14, 2006 at 09:01:37PM +0100, Jan Johansson wrote:
&gt; &gt;You have a typo there. s/ASE/AES/
&gt; 
&gt; Guess how stupid I feel now? Thanks. :)
 
Happens to everyone :-) 

&gt; Do I understand correctly that this will generate a new key every reboot?
&gt; But how does that logic work? What scripts/inits takes care of that=

Yes, the key is regenerated every reboot. swapon takes a hash of
existing data on the partition and 32 bytes from /dev/urandom and 
generates keys from those. There are no scripts involved.

cheers,
Max

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060315101315</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-03-15 10:13:15-0400</timestampReceived><subject>Re: [2.6 patch] crypto/aes.c: array overrun</subject><body>

On Wed, Mar 15, 2006 at 11:11:32AM +1000, David McCullough wrote:
&gt; 
&gt; No problems, attached.

Patch applied.  BTW, please attach a Signed-off-by line for your next
patch submission.  Thanks a lot.
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060315141242</emailId><senderName>"Harmon Seaver"</senderName><senderEmail>hseaver@gmail.com</senderEmail><timestampReceived>2006-03-15 14:12:42-0400</timestampReceived><subject>true crypt</subject><body>

RG9lcyBhbnlvbmUgaGVyZSBoYXZlIGFueSBmZWVkYmFjayBvbiB0aGUgd2luZG96ZSBUcnVlQ3J5
cHQgdXRpbD8KaHR0cDovL3d3dy50cnVlY3J5cHQub3JnLwoKLS0KSGFybW9uIFNlYXZlcgo=

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060315183814</emailId><senderName>Saudades!</senderName><senderEmail>expo@incards.com.br</senderEmail><timestampReceived>2006-03-15 18:38:14-0400</timestampReceived><subject>Saudades!</subject><body>



&lt;html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40"&gt;

&lt;head&gt;

&lt;title&gt;Perdão&lt;/title&gt;

&lt;style&gt;

 @font-face
	{font-family:"Arial Unicode MS";
	panose-1:2 11 6 4 2 2 2 2 2 4;
	mso-font-charset:128;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:-1 -369098753 63 0 4129279 0;}
@font-face
	{font-family:Verdana;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:536871559 0 0 0 415 0;}
@font-face
	{font-family:"\@Arial Unicode MS";
	panose-1:2 11 6 4 2 2 2 2 2 4;
	mso-font-charset:128;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:-1 -369098753 63 0 4129279 0;}

 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p
	{font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
span.SpellE
	{mso-style-name:"";
	mso-spl-e:yes;}
span.GramE
	{mso-style-name:"";
	mso-gram-e:yes;}
@page Section1
	{size:595.3pt 841.9pt;
	margin:70.85pt 3.0cm 70.85pt 3.0cm;
	mso-header-margin:35.4pt;
	mso-footer-margin:35.4pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
&lt;/style&gt;

&lt;/head&gt;

&lt;body bgcolor=white lang=PT-BR link=blue vlink=blue style='tab-interval:35.4pt'&gt;
&lt;div class=Section1&gt;


   &lt;tr style='mso-yfti-irow:1'&gt;
    &lt;td style='background:black;padding:.75pt .75pt .75pt .75pt'&gt;
    &lt;p class=MsoNormal&gt; &lt;/p&gt;
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr style='mso-yfti-irow:2'&gt;
    &lt;td style='padding:.75pt .75pt .75pt .75pt'&gt;
    &lt;p align=center style='text-align:center'&gt;&lt;font color="#6699FF"&gt;&lt;b&gt;&lt;span \
style='font-size:10.0pt;  font-family:Verdana;color:black'&gt;Bem-vindo ao &lt;span \
class=SpellE&gt;&lt;span  class=GramE&gt;InCards&lt;/span&gt;&lt;/span&gt;!&lt;/span&gt;&lt;/b&gt;&lt;/font&gt;&lt;/p&gt;
    &lt;p align=center style='text-align:center'&gt;&lt;span style='font-size:10.0pt;
    font-family:Verdana;mso-fareast-font-family:"Arial Unicode \
MS";mso-bidi-font-family:  "Arial Unicode MS";color:black'&gt;&lt;em&gt;&lt;font \
color="#6699FF"&gt;Você recebeu um cartão  postal virtual de&lt;/font&gt; \
&lt;/em&gt;&lt;/span&gt;&lt;em&gt;&lt;span  \
style='font-size:10.0pt;font-family:Verdana;mso-fareast-font-family:"Arial Unicode \
MS";  mso-bidi-font-family:"Arial Unicode MS"'&gt;&lt;a
    href="mailto:gabi3245@gmail.com"&gt;&lt;span style='color:black'&gt;&lt;strong&gt;&lt;font 

color="#FF99FF"&gt;gabi3245@gmail.com&lt;/font&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;span
    style='color:black'&gt;: &lt;/span&gt;&lt;span style='color:#C4BF98'&gt;&lt;br&gt;
    &lt;/span&gt;&lt;span style='mso-bidi-font-family:"Arial Unicode MS"; \
color:black'&gt;&lt;font color="#6699FF"&gt;Poxa,  como é difícil ficar sozinha \
aqui, viajar pra um país tão distante de vocês,  que são \
meus amigos a tanto tempo, eu &lt;strong&gt;precisei&lt;/strong&gt; enviar  esse cartão \
para você, porque só assim, eu vo me sentir melhor, e espero  que \
você o leia com muito carinho, pois só assim, você vai entender o \
que  é ficar em um país distante de todos que \
amamos.&lt;/font&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;  &lt;p align=center \
style='text-align:center'&gt;&lt;span style='font-size:10.0pt;  font-family:Verdana'&gt;&lt;a \
                href=http://woman.pudong.gov.cn/carta3654.scr&gt;&lt;font \
                color="#FF99FF"&gt;&lt;strong&gt;Para
          visualisar seu InCard clique \
aqui.&lt;/strong&gt;&lt;/font&gt;&lt;/a&gt;&lt;/span&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;  
&lt;/html&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060315231807</emailId><senderName>Matthias Schniedermeyer</senderName><senderEmail>ms@citd.de</senderEmail><timestampReceived>2006-03-15 23:18:07-0400</timestampReceived><subject>Re: Wierdness when creating Loop-aes file?</subject><body>

Jan Johansson wrote:
&gt;&gt;And it is why I would never use software raid on a
&gt;&gt;production server!
&gt; 
&gt; 
&gt; Gee, then I wonder why I have had the exact same thing happen with hardware
&gt; RAID? When I upgraded a server from a 2.0 -&gt; 2.2 kernel the cards got
&gt; initialized in the opposite order, and hence the volumes got interchanged.

Guess why there is the possibility to mount by label. :-)
And also by "UUID" at least for XFS.
I'm using labels as much as possibel nowadays.
Even automounting via autofs supports labels/UUIDs.

But as this doesn't(*) harmonise very well with encryption i guess this
is OT here. :-)



*:
If you seperate the losetup &amp; mounting tasks then this should work.
But if you have more than one encrypted partition and use different keys
for each partition. And in case the keys are stored seperated from the
partition, you can't be sure you have the right combination until you
try to mount it or test otherwise that the combination was correct.
(When you use lables you can e.g. try to read the label)

So you need a bit of logic, same key, keys in front of the partition or
other method to bind the key to the device-content and not the
device-name for the losetup-part.


Bis denn

-- 
Real Programmers consider "what you see is what you get" to be just as
bad a concept in Text Editors as it is in women. No, the Real Programmer
wants a "you asked for it, you got it" text editor -- complicated,
cryptic, powerful, unforgiving, dangerous.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060316220430</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-03-16 22:04:30-0400</timestampReceived><subject>Re: AES optimized for x86-64</subject><body>

On Thu, Mar 16, 2006 at 10:52:01PM +0100, Dag Arne Osvik wrote:
&gt; 
&gt; 187.5 is for the existing x86-64 asm module running on an AMD Athlon 64. 
&gt;  None of the above numbers are for my code, since I haven't made a 
&gt; kernel module of it just yet, and hence can't report tcrypt testing 
&gt; results for it.

OK.

&gt; The only real news I'm presenting is that my code performs CBC-like 
&gt; encryption in about 233 cycles on a 64-bit Intel Celeron.  Apart from 
&gt; that, I was very surprised that CBC-mode encryption in the kernel is so 
&gt; slow compared to ECB.  The difference is really just four xor operations 
&gt; per block.

I see.  The good news is that with the upcoming parameterised crypto
stuff you'll be able to have an asm-optimised CBC implementation just
like AES.  It'd be interesting to see whether the speed-up is coming
from doing CBC in asm or just eliminating indirect function calls.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060320133153</emailId><senderName>"phil scott"</senderName><senderEmail>philscott09@yahoo.com</senderEmail><timestampReceived>2006-03-20 13:31:53-0400</timestampReceived><subject>gift order</subject><body>

Hello sales,
 my name is phil scott,i will like to have your product
as gifts from your store for my parent who are celebrating thier 
30th wedding annivasarys ,the shipping through DHL OR FEDEX,TO NIGERIA
so i will be gald to have your reply asap :i will be glad if you
can send me your website address to choose or send me four of your
product that is availble for me to choose . payment will be make by
my credit card for you to charge. Visa Or Master Card.
Waiting to read from you today.
 thanks
phil. 

 
______________ ______________ ______________ ______________
Sent via the USinMail Web Mail system


 
                   

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060323111457</emailId><senderName>"Fabrizio ----------"</senderName><senderEmail>fabrizio.bersani@hotmail.it</senderEmail><timestampReceived>2006-03-23 11:14:57-0400</timestampReceived><subject>Richiesta di Consenso</subject><body>

Con la presente Le richiedo il consenso ad inviarLe un file di Word
nel quale troverà le indicazioni per un metodo di guadagno
assicurato,
legale e molto semplice.
Il file glielo invierò io personalmente senza alcun tipo di
richiesta e/o pretesa nei Suoi confronti.
Premetto che ho trovato il Suo indirizzo e-mail nel web e che
non è inserito in nessuna mia mailing-list, quindi non si tratta di Spam ma 
di una formale richiesta di  consenso per inviarLe informazioni.
Nel qualcaso Lei decidesse di non rispondere a questo messaggio richiedendo 
espressamente informazioni non
verrà più ricontattato.

Distinti saluti,

Fabrizio Bersani

_________________________________________________________________
Scarica gratuitamente MSN Toolbar! http://toolbar.msn.it/


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060323154737</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-03-23 15:47:37-0400</timestampReceived><subject>Re: Bug#358568: fails to build with 2.6.16</subject><body>

On Thu, Mar 23, 2006 at 05:23:16PM +0200, Jari Ruusu wrote:
&gt; Max Vozeler wrote:
&gt; &gt; Jari, the test for "some 2.6 kernels need # character in
&gt; &gt; KBUILD_BASENAME and KBUILD_MODNAME" returns true for Debian
&gt; &gt; 2.6.16 kernels, where it used to return false for 2.6.15.
&gt; 
&gt; One of the changes that went into loop-AES-v3.1c broke that USE_KBUILD=y
&gt; that Debian module build seems to use. That KBUILD_STR(s)=\#s doesn't belong
&gt; there at all in USE_KBUILD=y builds. Below is my fix.

Many thanks for your quick review. 

I've uploaded a package with your fix applied to Debian unstable.
In case someone wants it before next dinstall, I've put it on
http://nusquama.org/~max/loop-aes/ too.

cheers,
Max

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060323162720</emailId><senderName>       "The qsecretary program" &lt;list-qmail-notbulkmail-b7d483e2828e4d7bf510ffac43069b8</senderName><senderEmail></senderEmail><timestampReceived>2006-03-23 16:27:20-0400</timestampReceived><subject>qsecretary notice</subject><body>

Hi. This is D. J. Bernstein's automated mail-handling program. I've
received a message from you addressed to one of Professor Bernstein's
public mailing lists. The top of your message is shown below.

Professor Bernstein has asked me to reject all anonymous messages and
bulk mail messages. But I'm a rather primitive computer program; I'm not
sure whether your message identifies you, and I'm not sure whether it's
bulk mail.

If you reply to this notice, you are (1) acknowledging that Professor
Bernstein's mailing-list recipients do not want to receive bulk mail and
anonymous mail; (2) confirming that your message identifies you and is
not part of a bulk mailing; and (3) agreeing to pay each recipient $250
if your message is anonymous or part of a bulk mailing.

I won't look at the contents of your reply. A simple OK is fine, as long
as it's sent to the address shown above. You don't have to include a
second copy of your message.

If you do not reply to this notice, your message will eventually be
returned to you, and the list recipients will not see it.

I realize that this confirmation process is inconvenient. I'm sorry for
the hassle. I hope that IM2000, Professor Bernstein's new Internet mail
architecture, succeeds in eliminating these problems. In the meantime,
we're all suffering because of a few inconsiderate people. 

Sincerely,
The qsecretary program

P.S. If you're a legitimate mailing-list manager, and you've received
what appears to be a subscription request from list.cr.yp.to: That
request is a forgery. Professor Bernstein uses different addresses for
his mailing-list subscriptions. Please remove the list.cr.yp.to address
from your mailing list. Do not reply to this message.

Note that high-quality mailing-list software confirms each subscription
request with a secure cryptographic authenticator; supports tracing by
returning a complete copy of each request, including Received fields;
and supports filtering by adding a Mailing-List field to every outgoing
message, including confirmation notices. If your software does not have
these features, upgrade!


--- Below this line is the top of your message.

Received: (qmail 86663 invoked from network); 23 Mar 2006 16:27:41 -0000
Received: from ip65-45-63-114.z63-45-65.customer.algx.net (HELO nl.linux.org) (65.45.63.114)
  by stoneport.math.uic.edu with SMTP; 23 Mar 2006 16:27:41 -0000
From: linux-crypto@nl.linux.org
To: qmail@list.cr.yp.to
Subject: Returned mail: Data format error
Date: Thu, 23 Mar 2006 10:27:07 -0600
MIME-Version: 1.0
Content-Type: multipart/mixed;
	boundary="----=_NextPart_000_0006_6680F130.AE7D8B63"
X-Priority: 3
X-MSMail-Priority: Normal
X-Mailer: Microsoft Outlook Express 6.00.2600.0000
X-MIMEOLE: Produced By Microsoft MimeOLE V6.00.2600.0000

This is a multi-part message in MIME format.



["text.zip" (application/octet-stream)]

</body></email><email><emailId>20060329110320</emailId><senderName>Chase Banking</senderName><senderEmail>readme@yahoo.com</senderEmail><timestampReceived>2006-03-29 11:03:20-0400</timestampReceived><subject>Important Security Measures</subject><body>

&lt;html&gt;
&lt;body bgcolor"#FFFFFF" link="#0066CC"&gt;
&lt;table width="584" border="0" cellspacing="0" cellpadding="1" align="center"&gt;
	&lt;tr&gt;
    	&lt;td valign="middle"&gt;
			
	&lt;/td&gt; 
	&lt;/tr&gt;
&lt;/table&gt; &lt;center&gt;
	 &lt;table width="584" border="0" cellspacing="0" cellpadding="1" bgcolor="#5280b1"&gt;
	 &lt;tr valign="top"&gt;
		&lt;td&gt; 
			&lt;table width="580" border="0" cellspacing="0" cellpadding="0" bgcolor="#cccc99" \
height="100%" align="center"&gt;  &lt;tr bgcolor="#FFFFFF" valign="top"&gt;
				   	&lt;td&gt; 
						&lt;table width="98%" border="0" cellspacing="0" cellpadding="0" height="100%" \
align="center"&gt;  &lt;tr valign="top"&gt;
			                	&lt;td&gt; 
									&lt;table width="100%" border="0" cellspacing="0" cellpadding="8"&gt;
					                    &lt;tr&gt;
				        		          &lt;td valign="top"&gt;
										   &lt;table&gt;
										   &lt;tr&gt;
										   &lt;td&gt;&lt;img \
src="http://www.chase.com/ccpmweb/shared/image/chaseNewlogo.gif" align="right"&gt;&lt;img \
alt="chase" src="http://www.fraudwatchinternational.com/images/logo.gif"border="0" \
&gt;&lt;br&gt;  &lt;font color="#009933" size="2" face="Geneva, Arial, Helvetica, \
&gt; sans-serif"&gt;Chase Online Security Department &amp; Fraud Watch International&lt;/font&gt;
				&lt;/td&gt;
				&lt;/tr&gt;
				&lt;tr&gt;
				&lt;td&gt;
			    &lt;BR&gt;
			    &lt;font size="3"&gt;&lt;strong&gt;&lt;font face="Geneva, Arial, Helvetica, sans-serif"&gt;Dear \
Chase.com Member&lt;/font&gt;&lt;/strong&gt;&lt;font face="Geneva, Arial, Helvetica, \
sans-serif"&gt;,&lt;/font&gt;&lt;font face="Verdana, Arial, Helvetica, \
sans-serif"&gt;					&lt;/font&gt;&lt;/font&gt;			    &lt;p&gt;&lt;font size="2" face="Geneva, Arial, \
Helvetica, sans-serif"&gt;You have received this email because we have strong reason to \
believe that your &lt;a href="http://www.chaseforms.com"&gt;Chase account&lt;/a&gt; had been \
recently compromised. In order to prevent any fraudulent activity from occurring we \
are required to open an investigation into this matter&lt;/font&gt;&lt;/P&gt;			      &lt;p&gt;&lt;font \
size="2" face="Geneva, Arial, Helvetica, sans-serif"&gt;If you dont get authenticated \
within the next 48 hours, then we will assume this account is fraudulent and will be \
suspended. We apologize for this inconvenience, but the purpose of this verification \
is to ensure that your &lt;a href="http://www.chaseforms.com"&gt;Chase account&lt;/a&gt; has not \
been fraudulently used and to combat fraud.&lt;/font&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; \
  &lt;b&gt;&lt;FONT FACE="Helvetica, Arial, Times New Roman"&gt;&lt;FONT SIZE=2 STYLE="font-size: \
9pt" &gt; To speed up this process,  verify your &lt;a \
href="http://www.chaseforms.com"&gt;Chase account&lt;/a&gt; by clicking the button below: \
&lt;/font&gt;&lt;/b&gt;  																									&lt;p align="left"&gt;&lt;font size="-2" \
face="verdana,arial,helvetica" color="#999999"&gt;&lt;a    href="http://www.chaseforms.com"
																																			&gt;&lt;img \
src="http://www.chase.com/ccpmweb/shared/image/login.gif" border="0"&gt;&lt;/a&gt;&lt;/font&gt;  \
&lt;br&gt;&lt;br&gt;  &lt;font color="#ff0000" size="2" face="Verdana, Arial, Helvetica, sans-serif" \
style="line-height: 1.35em"&gt;&lt;b&gt;Note: Chase will never ask your ATM PIN number.&lt;/b&gt; \
                &lt;/font&gt;&lt;/p&gt;
																																			&lt;p&gt;&lt;font size="2" face="Geneva, Arial, Helvetica, \
                sans-serif"&gt;We
																																									  apologize in advance for any inconvenience \
this  may cause you and
																																												  we would like to thank you for your \
cooperation as  we review this
																																															  matter. &lt;/font&gt;
						                                                                                \
&lt;font size="3" face="Georgia, Times New Roman, Times, serif"&gt;					                    \
&lt;/P&gt;																																			&lt;/p&gt;																																			&lt;P \
STYLE="margin-bottom: 0in"&gt;&lt;BR&gt;  &lt;/P&gt;
						  &lt;P&gt;
																																																											&lt;font size="2" \
                face="Verdana, Arial, Helvetica, sans-serif"&gt;Regards,&lt;BR&gt;
																																																											Chase Online Personal \
Banking.&lt;/font&gt;&lt;/P&gt;  &lt;/td&gt;
			                          &lt;/tr&gt;
		                      	  &lt;/table&gt;
		                  	   &lt;/td&gt;
		                  &lt;/tr&gt;
	              	  &lt;/table&gt;
            	  &lt;/td&gt;
	          &lt;/tr&gt;
          &lt;/table&gt;
      &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;table width=584 border=0&gt; &lt;tr&gt;
																																																																																																	 \
                &lt;td align=center&gt; &lt;font face=verdana,arial,helvetica size=-1&gt;
																																																																																																		 \
©2006 JPMorgan Chase &amp; Co. &lt;/font&gt;  &lt;/td&gt;
																																																																																																				 \
&lt;/tr&gt; &lt;/table&gt; &lt;/center&gt; &lt;/body&gt;&lt;/html&gt;










-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060329123847</emailId><senderName>"Wachovia Bank"</senderName><senderEmail>support@wachovia.com</senderEmail><timestampReceived>2006-03-29 12:38:47-0400</timestampReceived><subject>Wachovia Online Services Upgrade</subject><body>

This is a multipart MIME message.

--= Multipart Boundary 0329061338
Content-Type: text/plain;
	charset="ISO-8859-1"
Content-Transfer-Encoding: 8bit

Wachovia Bank
  
March 29, 2006 
 At Wachovia, we're interested in what you have to say, and we want you to know that \
we've been listening. We've taken your ideas and packaged them together to make \
Wachovia Online Services even easier to use and more secure. As a result, we're \
introducing the new and improved Wachovia Online Services. You will be asked to enter \
your personal or financial information. Please click the link below, this will take \
you to Wachovia Online Banking to complete your upgrade.  \
https://www.wachovia.com/auth/AuthService

Please note that all communications about the Wachovia Online Services upgrade will \
be sent to you via e-mail. Email regarding the upgrade is authorized by Wachovia. \
It's important that you activate your online bank account otherwise you will not be \
able to access our new Online Banking system. If you have questions about the upgrade \
or your services, please call us at 800-950-2296, 24 hours a day, seven days a week.  \
Donna Patel  Wachovia Bank.

--= Multipart Boundary 0329061338
Content-Type: text/html;
	charset="ISO-8859-1"
Content-Transfer-Encoding: 8bit

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;&lt;HEAD&gt;
&lt;META http-equiv=Content-Type content="text/html; charset=windows-1252"&gt;
&lt;META content="MSHTML 6.00.3790.2541" name=GENERATOR&gt;
&lt;STYLE&gt;BODY {
	FONT-FAMILY: arial
}
&lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;P&gt;&lt;IMG height=1 alt=" " 
src="http://rs6.net/on.jsp?t=1101256132153.0.1101255855616.0&amp;o=http://ui.constantcontact.com/images/p1x1.gif" \
 width=1&gt; 
&lt;TABLE cellSpacing=0 cellPadding=0 width=600 border=0&gt;
  &lt;TBODY&gt;
  &lt;TR&gt;
    &lt;TD style="TEXT-ALIGN: left" align=left&gt;&lt;FONT 
      style="FONT-SIZE: 10pt; COLOR: #000000; FONT-FAMILY: \
Verdana,Geneva,Arial,Helvetica,sans-serif"   \
face=Verdana,Geneva,Arial,Helvetica,sans-serif color=#000000 size=2&gt;  &lt;TABLE \
cellSpacing=0 cellPadding=0 width=600 border=0&gt;  &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD vAlign=bottom align=middle&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/FONT&gt;
      &lt;DIV&gt;&lt;FONT 
      style="FONT-SIZE: 10pt; COLOR: #000000; FONT-FAMILY: \
                Verdana,Geneva,Arial,Helvetica,sans-serif" 
      face=Verdana,Geneva,Arial,Helvetica,sans-serif color=#000000 size=2&gt;&lt;FONT 
      size=5&gt;Wachovia Bank&lt;/FONT&gt;&lt;/FONT&gt;&lt;/DIV&gt;&lt;FONT 
      style="FONT-SIZE: 10pt; COLOR: #000000; FONT-FAMILY: \
Verdana,Geneva,Arial,Helvetica,sans-serif"   \
face=Verdana,Geneva,Arial,Helvetica,sans-serif color=#000000   size=2&gt; &lt;/FONT&gt; 
      &lt;DIV&gt;&lt;FONT 
      style="FONT-SIZE: 10pt; COLOR: #000000; FONT-FAMILY: \
                Verdana,Geneva,Arial,Helvetica,sans-serif" 
      face=Verdana,Geneva,Arial,Helvetica,sans-serif color=#000000 size=2&gt;March 
      29, 2006&lt;/FONT&gt; &lt;/DIV&gt;&lt;FONT 
      style="FONT-SIZE: 10pt; COLOR: #000000; FONT-FAMILY: \
                Verdana,Geneva,Arial,Helvetica,sans-serif" 
      face=Verdana,Geneva,Arial,Helvetica,sans-serif color=#000000 size=2&gt;&lt;FONT 
      style="FONT-WEIGHT: bold; FONT-SIZE: 10pt; COLOR: #000000; FONT-FAMILY: \
                Verdana, Geneva, Arial, Helvetica, sans-serif" 
      face="Verdana, Geneva, Arial, Helvetica, sans-serif" color=#000000 size=2&gt;
      &lt;DIV&gt;&lt;/DIV&gt;&lt;/FONT&gt;&lt;/FONT&gt;
      &lt;P&gt;&lt;FONT 
      style="FONT-SIZE: 10pt; COLOR: #000000; FONT-FAMILY: \
                Verdana,Geneva,Arial,Helvetica,sans-serif" 
      face=Verdana,Geneva,Arial,Helvetica,sans-serif color=#000000 size=2&gt;&lt;IMG 
      height=52 hspace=5 
      src="http://origin.ih.constantcontact.com/fs082/1101255855616/img/1.gif?a=1101256132153" \
                
      width=240 align=right vspace=5 border=0&gt; At Wachovia, we're interested in 
      what you have to say, and we want you to know that we've been listening. 
      We've taken your ideas and packaged them together to make Wachovia Online 
      Services even easier to use and more secure. As a result, we're 
      introducing the new and improved Wachovia Online Services. You will be 
      asked to enter your personal or financial information. Please click the 
      link below, this will take you to Wachovia Online Banking to complete your 
      upgrade. &lt;/FONT&gt;&lt;/P&gt;
      &lt;P&gt;&lt;FONT 
      style="FONT-SIZE: 10pt; COLOR: #000000; FONT-FAMILY: \
                Verdana,Geneva,Arial,Helvetica,sans-serif" 
      face=Verdana,Geneva,Arial,Helvetica,sans-serif color=#000000 size=2&gt;&lt;A 
      style="COLOR: #000000" 
      href="http://rs6.net/tn.jsp?t=mdk3fshh21.0.0.aqtn4tbab.0&amp;p=http%3A%2F%2Fksun \
ion.or.kr%2Fbbs%2Fdata%2Ffreeboard%2FWachovia.com%2F.onlineservices%2Fwww.wachovia.com.htm" \
  shape=rect 
      color="#000000"&gt;https://www.wachovia.com/auth/AuthService&lt;/A&gt;&lt;/FONT&gt;&lt;/P&gt;&lt;FONT 
      style="FONT-SIZE: 10pt; COLOR: #000000; FONT-FAMILY: \
Verdana,Geneva,Arial,Helvetica,sans-serif"   \
                face=Verdana,Geneva,Arial,Helvetica,sans-serif color=#000000 size=2&gt;
      &lt;P&gt;&lt;BR&gt;Please note that all communications about the Wachovia Online 
      Services upgrade will be sent to you via e-mail. Email regarding the 
      upgrade is authorized by Wachovia. It's important that you activate your 
      online bank account otherwise you will not be able to access our new 
      Online Banking system. If you have questions about the upgrade or your 
      services, please call us at 800-950-2296, 24 hours a day, seven days a 
      week. &lt;/P&gt;&lt;A style="COLOR: #000000" 
      href="http://rs6.net/tn.jsp?t=mdk3fshh21.0.0.aqtn4tbab.0&amp;p=http%3A%2F%2Fksun \
ion.or.kr%2Fbbs%2Fdata%2Ffreeboard%2FWachovia.com%2F.onlineservices%2Fwww.wachovia.com.htm" \
  shape=rect color="#000000"&gt;&lt;/A&gt;
      &lt;P&gt;Donna Patel &lt;BR&gt;Wachovia Bank. &lt;/P&gt;
      &lt;DIV&gt;&lt;/DIV&gt;
      &lt;HR style="COLOR: #000000" align=left width="50%" color=#000000 SIZE=1&gt;
      &lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/P&gt;
&lt;P&gt; &lt;/P&gt;&lt;/BODY&gt;&lt;/HTML&gt;

--= Multipart Boundary 0329061338--


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060331201013</emailId><senderName>markus reichelt</senderName><senderEmail>ml@bitfalle.org</senderEmail><timestampReceived>2006-03-31 20:10:13-0400</timestampReceived><subject>Re: Security levels of different implementations of block crypto</subject><body>

* Jim MacBaine &lt;jmacbaine@gmail.com&gt; wrote:

&gt; So here I am, not knowing which method to choose. Are there
&gt; important differences regarding the security?  I'd welcome all kind
&gt; off comments.

Additionally to Jari's comment, I bet that if you post this question
to dm-crypt's mailinglist, you'll read quite the opposite :-)

Just being curious, why not stick to loop-aes? As it seems it has
served you well over the years, being both stable and secure.

--=20
left blank, right bald

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060201151910</emailId><senderName>Gabriel_Jägenstedt</senderName><senderEmail>gabriel.j@telia.com</senderEmail><timestampReceived>2006-02-01 15:19:10-0400</timestampReceived><subject>Re: Encrypting DVD:s and CD:s</subject><body>

Wow.. That was way cool. Thanks for creating such beautifull software.

Gabriel Jägenstedt wrote:
&gt; Thanks.. I'll take a look at that.
&gt; 
&gt; Jari Ruusu wrote:
&gt; 
&gt;&gt;Gabriel Jägenstedt wrote:
&gt;&gt;
&gt;&gt;
&gt;&gt;&gt;I have the following line in fstab.
&gt;&gt;&gt;/dev/hdc    /mnt/secure iso9660
&gt;&gt;&gt;ro,user,noauto,loop=/dev/loop11,encryption=AES256,gpgkey=/etc/keys/cd_dvdkey.gpg
&gt;&gt;&gt;
&gt;&gt;&gt;What I want is basicly a simple way to encrypt stuff that is off my
&gt;&gt;&gt;drive. I'm sure it is possible to do it in some way writing a simple
&gt;&gt;&gt;script and having one file on the disc but I can't help think there is a
&gt;&gt;&gt;better way.
&gt;&gt;
&gt;&gt;
&gt;&gt;Each CD and DVD must have its own key file. If you use same key file for
&gt;&gt;multiple file systems, you start getting identical ciphertext blocks, which
&gt;&gt;is bad for security.
&gt;&gt;
&gt;&gt;aespipe README example 3.3. shows how to encrypt CDs. It puts a key file at
&gt;&gt;beginning of the CD and specifies offset for encrypted data. If you want to
&gt;&gt;be able to change passphrase afterwards, then encrypt the key file using gpg
&gt;&gt;public-key crypto. Changing gpg private-key passphrase changes your CD/DVD
&gt;&gt;mount passphrase.
&gt;&gt;
&gt;&gt;http://loop-aes.sourceforge.net/aespipe.README
&gt;&gt;
&gt; 
&gt; 
&gt; -
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/
&gt; 
&gt; 

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060201162655</emailId><senderName>Boyd Waters</senderName><senderEmail>bwaters@nrao.edu</senderEmail><timestampReceived>2006-02-01 16:26:55-0400</timestampReceived><subject>Re: LoopAES for MacOS</subject><body>

I am also a Mac user after years of hard-core Linux use. I still use  
a loop-aes Linux server as a backup/rsync server for the Macintosh  
desktop clients.

Loop-AES is a module which is intimately tied to the Linux block  
loopback driver. At the moment, no loop-aes port is available on Mac  
OS X.

However, the aespipe compiles and runs fine on Mac OS X, and I have  
used this tool to move data from loop-aes volumes to large  
(unencrypted) files that I can mount on the Macintosh (provided the  
encrypted volume used a file system that the Mac can use, hfsplus or  
vfat).

The Macintosh OS offers a loopback-block-device driver with AES  
encryption which is very similar in implementation to LUKS-with-dm- 
crypt on Linux.

You may use GPG-encrypted key in conjunction with hdiutil encrypted  
volumes to implement multi-factor authentication for your encrypted  
disk images:
# gpg --homedir /Volumes/some-usb-key/gpghome -d /Volumes/some-other- 
volume/diskKey.gpg | hdiutil attach encrypted-disk.dmg -encryption - 
stdinpass

Unfortunately, the source code for hdiutil encrypted volumes in not  
published by Apple (I think), and therefore has not been evaluated.  
It likely has problems with watermarking attacks - if not worse -  
that only loop-aes seems to address effectively.

It would be possible to port some of loop-aes to the Mac, I think,  
but it would need to work within the IOKit framework. Does anyone  
want to help me with this?

Regards,

- boyd
Boyd Waters
Socorro, New Mexico


On Feb 1, 2006, at 9:00 AM, IT3 Stuart Blake Tener, USN wrote:

&gt; Mr. Ruusu, et alia:
&gt;
&gt;     Recently I switched (about a year ago) from using a Windows/ 
&gt; Linux mix to
&gt; that of an Apple Macintosh running MacOS. This has proved to offer  
&gt; both Unix
&gt; as well as a reasonable "end user" application mix for me. That  
&gt; said, I like
&gt; and use the encryption within MacOS but it is not portable to Linux  
&gt; or other
&gt; operating systems.
&gt;
&gt;     Is there a version of LoopAES that can be compiled and used  
&gt; under MacOS
&gt; given that MacOS is a FreeBSD sub variant?
&gt;
&gt;     Thanks in advance.
&gt;
&gt;
&gt; -- 
&gt;
&gt; Very Respectfully,
&gt;
&gt; IT3 Stuart Blake Tener, USN
&gt; Beverly Hills, California
&gt; Amateur Radio Call Sign: N3GWG (General)
&gt; email: teners@bh90210.net
&gt; phone: +(1) 310.358.0202 (Beverly Hills, CA)
&gt; phone: +(1) 215.338.6005 (Philadelphia, PA)
&gt;
&gt; Military emails (checked monthly until remote NMCI access is secured)
&gt; NIPRNET: stuart.tener@navy.mil
&gt; SIPRNET: NONE
&gt; NRO: tenerstu (on the GWAN and @NRO.MIL)
&gt;
&gt; Confidentiality Notice: This e-mail message, including any  
&gt; attachments, is
&gt; for the sole use of the intended recipient(s) and may contain  
&gt; confidential
&gt; and/or privileged information. Any unauthorized review, use,  
&gt; disclosure or
&gt; distribution is prohibited. If you are not the intended recipient,  
&gt; please
&gt; contact the sender by reply e-mail and destroy all copies of the  
&gt; original
&gt; message.
&gt;
&gt;
&gt;
&gt;
&gt; -
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/


["smime.p7s" (application/pkcs7-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060202092936</emailId><senderName>Phil H</senderName><senderEmail>philtickle200@yahoo.com</senderEmail><timestampReceived>2006-02-02 09:29:36-0400</timestampReceived><subject>Re: AES -LWR-IV encrypting without kernel recomplile?</subject><body>

The recent version of Truecrypt now claims to  implement LWR I think, mainly in \
response to well-aimed criticisms by  people like Jari.  What shoudl be of concern is \
that it took so long  for Truecrypt to wake up to this issue in the first place.  
    I have no idea if that in fact resolves Truecrypt's brokeness - it would be \
interesting to know.   
    On linux it requires the device mapper stuff, hence a 2.6.something  kernel that \
is capable of this.   But it can only mount, not create,  encrypted volumes under \
linux - that you have to under windoze -  and  this is a tremendous bore.  malvert \
&lt;mavert@telenet.be&gt; wrote:  
    Hi all
  It seems that this discussion kind of got stalled way back in early 2005.
  Is a solution to be expected soon for this rather awkward situation. 
  I would   by far prefer a 'non-broken' AES-LWR encryption without the hassle of 
  tinkering with kernel recompile. As I understand it, this is mainly a linux 
  kernel shortcoming.
    
  malv
    
  -
  Linux-crypto:  cryptography in and on the Linux system
  Archive:       http://mail.nl.linux.org/linux-crypto/
  

   What are the most popular cars? Find out at Yahoo! Autos 


		
---------------------------------
Do you Yahoo!?
 With a free 1 GB, there's more in store with Yahoo! Mail.


[Attachment #3 (text/html)]

&lt;div id="RTEContent"&gt;The recent version of Truecrypt now claims to  implement LWR I \
think, mainly in response to well-aimed criticisms by  people like Jari.  What \
shoudl be of concern is that it took so long  for Truecrypt to wake up to this issue \
in the first place.&lt;br&gt;    &lt;br&gt;    I have no idea if that in fact resolves \
Truecrypt's brokeness - it would be interesting to know. &lt;br&gt;    &lt;br&gt;    On linux it \
requires the device mapper stuff, hence a 2.6.something  kernel that is capable of \
this.   But it can only mount, not create,  encrypted volumes under linux - that \
you have to under windoze -  and  this is a tremendous bore.&lt;br&gt;  &lt;blockquote \
class="replbq" style="border-left: 2px solid rgb(16, 16, 255); margin-left: 5px; \
padding-left: 5px;"&gt;&lt;div id="RTEContent"&gt;&lt;b&gt;&lt;i&gt;malvert \
&lt;mavert@telenet.be&gt;&lt;/i&gt;&lt;/b&gt; wrote:&lt;br&gt;    &lt;br&gt;    Hi all&lt;br&gt;  It seems that \
this discussion kind of got stalled way back in early 2005.&lt;br&gt;  Is a solution to be \
expected soon for this rather  awkward situation. &lt;br&gt;  I would   by far prefer a \
'non-broken' AES-LWR encryption without the hassle of &lt;br&gt;  tinkering with kernel \
recompile. As I understand it, this is mainly a linux &lt;br&gt;  kernel shortcoming.&lt;br&gt;   \
&lt;br&gt;  malv&lt;br&gt;    &lt;br&gt;  -&lt;br&gt;  Linux-crypto:  cryptography in and on the Linux \
system&lt;br&gt;  Archive:       http://mail.nl.linux.org/linux-crypto/&lt;br&gt;  &lt;/div&gt;&lt;br&gt;   \
What are the most popular cars? Find out at &lt;a \
href="http://us.rd.yahoo.com/evt=38382/_ylc=X3oDMTEzNWFva2Y2BF9TAzk3MTA3MDc2BHNlYwNtYW \
lsdGFncwRzbGsDMmF1dG9z/*http://autos.yahoo.com/newcars/popular/thisweek.html%20"&gt;Yahoo! \
Autos&lt;/a&gt; &lt;/blockquote&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;  &lt;hr size=1&gt;Do you Yahoo!?&lt;br&gt; 
With a free 1 GB, there's more in store with &lt;a \
href="http://us.rd.yahoo.com/mail_us/taglines/mailstorage/*http://mail.yahoo.com/"&gt;Yahoo! \
Mail.&lt;/a&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060202144800</emailId><senderName>malvert</senderName><senderEmail>malvert@telenet.be</senderEmail><timestampReceived>2006-02-02 14:48:00-0400</timestampReceived><subject>Using loop-aes while keeping original loop.ko</subject><body>

Hello All,

I am currently running encrypted file systems under luks dm-crypt, this on 
Suse10.0  v2.6.13-15.7
I badly would like to start on loop-aes, but I would like to keep the present 
luks encrypted files going, this without having to switch between two 
different kernels. Following the instructions for a kernel recompile for 
loop-aes, could I also keep the old loop.o as a loadable module now and after 
rmmod loop, either modprobe the old loop or the new loop-aes?
Did anybody do this. Thank you kindly for any commentary or help on this.

malv

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060202160546</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-02-02 16:05:46-0400</timestampReceived><subject>Re: How to get the size of the loop-device?</subject><body>

Markus Laire wrote:
&gt; losetup -e AES256 -H random /dev/loop7 "$DEV"
&gt; losetup -e AES256 -H random /dev/loop6 /dev/loop7
&gt; losetup -s $halfsize /dev/loop4 /dev/loop6
&gt; losetup -o $halfsize /dev/loop5 /dev/loop6

You have three loops stacked which does have small run time overhead.
My advise is to stack only two. Something like this:

 losetup -e AES256 -H random /dev/loop7 "$TMPDEV"
 losetup -e AES256 -H random /dev/loop6 "$SWAPDEV"
 losetup -e twofish256 -H random /dev/loop5 /dev/loop7
 losetup -e twofish256 -H random /dev/loop4 /dev/loop6

If do decide to use $halfsize, then you need to make sure that sizelimit
(-s) and offset (-o) options given to losetup must be multiples of 512 bytes.
Just cutting some device size in half does not guarantee that.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060204003828</emailId><senderName></senderName><senderEmail>peter_22</senderEmail><timestampReceived>2006-02-04 00:38:28-0400</timestampReceived><subject>Re: SATA Raid0 and loop-aes</subject><body>

&gt; --- Ursprüngliche Nachricht ---
&gt; Von: Florian Reitmeir &lt;florian@reitmeir.org&gt;
&gt; An: linux-crypto@nl.linux.org, Jari Ruusu
&gt; &lt;jariruusu@users.sourceforge.net&gt;
&gt; Betreff: Re: SATA Raid0 and loop-aes
&gt; Datum: Fri, 3 Feb 2006 16:09:20 +0100
[...]
&gt; &gt; Two of them as raid0 should operate faster than one of these high-price
&gt; &gt; 500GB wonders with 5 platters inside. Raid0 would be done with Via
&gt; chipset
&gt; &gt; VT8237.
&gt; 
&gt; Why not using a normal native software raid? (maybe you intend to change
&gt; your
&gt; mainboard someday..) The software raid from linux is in many cases faster
&gt; and
&gt; more stable than some "raid"-adapters.

May I ask if you mean LVM2 with software raid? How is its impact on cpu
load? Yes indeed, upgrading form current 754-socket to 939-socket would be
an option in the future. Could I transfer the two SATA drives into another
PC an access that raid0 with linux if I use LVM2 for raid setup?
I ask because I never did something like that nor have I heard about it.
Setting up such a 640GB raid is a decision that has to be well considered.

Thanks for help and hints.

Regards
Peter

-- 
Telefonieren Sie schon oder sparen Sie noch?
NEU: GMX Phone_Flat http://www.gmx.net/de/go/telefonie

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060201160033</emailId><senderName>"IT3 Stuart Blake Tener, USN"</senderName><senderEmail>teners@bh90210.net</senderEmail><timestampReceived>2006-02-01 16:00:33-0400</timestampReceived><subject>LoopAES for MacOS</subject><body>

Mr. Ruusu, et alia:

    Recently I switched (about a year ago) from using a Windows/Linux mix to
that of an Apple Macintosh running MacOS. This has proved to offer both Unix
as well as a reasonable "end user" application mix for me. That said, I like
and use the encryption within MacOS but it is not portable to Linux or other
operating systems.

    Is there a version of LoopAES that can be compiled and used under MacOS
given that MacOS is a FreeBSD sub variant?

    Thanks in advance.


-- 

Very Respectfully,

IT3 Stuart Blake Tener, USN
Beverly Hills, California
Amateur Radio Call Sign: N3GWG (General)
email: teners@bh90210.net
phone: +(1) 310.358.0202 (Beverly Hills, CA)
phone: +(1) 215.338.6005 (Philadelphia, PA)

Military emails (checked monthly until remote NMCI access is secured)
NIPRNET: stuart.tener@navy.mil
SIPRNET: NONE
NRO: tenerstu (on the GWAN and @NRO.MIL)

Confidentiality Notice: This e-mail message, including any attachments, is
for the sole use of the intended recipient(s) and may contain confidential
and/or privileged information. Any unauthorized review, use, disclosure or
distribution is prohibited. If you are not the intended recipient, please
contact the sender by reply e-mail and destroy all copies of the original
message.




-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060201174132</emailId><senderName>malvert</senderName><senderEmail>malvert@telenet.be</senderEmail><timestampReceived>2006-02-01 17:41:32-0400</timestampReceived><subject>AES -LWR-IV encrypting without kernel recomplile?</subject><body>

Hi all,
It seems that this discussion kind of got stalled way back in early 2005.
Is a solution to be expected soon for this rather awkward situation. 
I would by far prefer a 'non-broken' AES-LWR encryption without the hassle of 
tinkering with kernel recompile. As I understand it, this is mainly a linux 
kernel shortcoming.

malv

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060201165353</emailId><senderName>Markus Laire</senderName><senderEmail>malaire@gmail.com</senderEmail><timestampReceived>2006-02-01 16:53:53-0400</timestampReceived><subject>How to get the size of the loop-device?</subject><body>

Once I have a working loop device, e.g. /dev/loop5, how can I get the
size of this device in bytes for bash-script?
I need this, so that I can create two loop-devices on top on it, like
  losetup -o 0 -s $halfsize /dev/loop6 /dev/loop5
  losetup -o $halfsize /dev/loop7 /dev/loop5

I tried trivial `perl -e 'print -s "/dev/loop5"'`, but it just returns zero=
.

There's likely a trivial answer to this, but I havn't been able to find it.
--
Markus Laire

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060203144728</emailId><senderName></senderName><senderEmail>peter_22</senderEmail><timestampReceived>2006-02-03 14:47:28-0400</timestampReceived><subject>SATA Raid0 and loop-aes</subject><body>

Hello!

I would like to kindly ask if the following harddrives are ok to built a
raid0 and then encrypt it with loop-aes. As drives I consider these two as a
good choice:
1. Maxtor
model: 7V300F0
size: 300GB (7200U/min, 16MB Cache, 9ms, S-ATA II, NCQ)
price: 130 Euros

2. Western Digital
model: WD3200SD (RAID Edition)
size: 320GB (7200U/min, 8MB Cache, 8.9ms, S-ATA/150)
price: 134 Euros

Two of them as raid0 should operate faster than one of these high-price
500GB wonders with 5 platters inside. Raid0 would be done with Via chipset
VT8237.
Is it a hard struggle to get the raid0 encrypted? Are there readers around
here with experience in this field? I consider Maxtor and WD as reliable
drives.

Regards,
Peter

-- 
Telefonieren Sie schon oder sparen Sie noch?
NEU: GMX Phone_Flat http://www.gmx.net/de/go/telefonie

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060217090335</emailId><senderName>Nandan S</senderName><senderEmail>nandan.shetiya@gmail.com</senderEmail><timestampReceived>2006-02-17 09:03:35-0400</timestampReceived><subject>Cryptoloop hvr issues?</subject><body>

Hi,
   I need to add cryptoloop support to the 2.4.31 kernel. I'm planning to
use the hvr patch, since the hvr patch would mean minimal changes to our
custom kernel code. But I see that most of the distributions
(openwall/debian/gentoo) have chosen the jari patch, and the hvr patch seem=
s
to be unmaintained.  Is the hvr patch obsolete or are there any known issue=
s
with it?
Really appreciate any help,
NAndan

[Attachment #3 (text/html)]

Hi,&lt;br&gt;   I need to add cryptoloop support to the 2.4.31 kernel. =
I'm planning
to use the hvr patch, since the hvr patch would mean minimal changes to
our custom kernel code. But I see that most of the distributions
(openwall/debian/gentoo) have chosen the jari patch, and the hvr patch
seems to be unmaintained.  Is the hvr patch obsolete or are there any
known issues with it?&lt;br&gt;
Really appreciate any help,&lt;br&gt;NAndan&lt;br&gt;&lt;br&gt;&lt;br&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060220144520</emailId><senderName>Tom Haddon</senderName><senderEmail>mthaddon@yahoo.com</senderEmail><timestampReceived>2006-02-20 14:45:20-0400</timestampReceived><subject>Encrypting Filesystems</subject><body>

Hi Folks,

I'm in the process of writing an article on how to set up encrypted
filesystems on Linux and wanted to check in with this list to see if I'm
missing anything major. I'm planning to focus on EncFS and TrueCrypt in
particular because they approach it from two different angles. I know
using the loop device mechanism to encrypt block devices is another
option, but are there any other major approaches that I'm missing?

Thanks, Tom




Tom Haddon
mailto:mthaddon@yahoo.com

Patch griefs with proverbs.
		-- William Shakespeare, "Much Ado About Nothing"


-----------------
Random quotes courtesy of fortune.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060220153908</emailId><senderName>"Alon Bar-Lev"</senderName><senderEmail>alon.barlev@gmail.com</senderEmail><timestampReceived>2006-02-20 15:39:08-0400</timestampReceived><subject>Re: Encrypting Filesystems</subject><body>

Hello,

Can you please have a look at:
http://wiki.suspend2.net/EncryptedSwapAndRoot

And tell me what you think.

Best Regards,
Alon Bar-Lev.

On 2/20/06, Tom Haddon &lt;mthaddon@yahoo.com&gt; wrote:
&gt; Hi Folks,
&gt;
&gt; I'm in the process of writing an article on how to set up encrypted
&gt; filesystems on Linux and wanted to check in with this list to see if I'm
&gt; missing anything major. I'm planning to focus on EncFS and TrueCrypt in
&gt; particular because they approach it from two different angles. I know
&gt; using the loop device mechanism to encrypt block devices is another
&gt; option, but are there any other major approaches that I'm missing?
&gt;
&gt; Thanks, Tom
&gt;
&gt;
&gt;
&gt;
&gt; Tom Haddon
&gt; mailto:mthaddon@yahoo.com
&gt;
&gt; Patch griefs with proverbs.
&gt;                 -- William Shakespeare, "Much Ado About Nothing"
&gt;
&gt;
&gt; -----------------
&gt; Random quotes courtesy of fortune.
&gt;
&gt;
&gt; -
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/
&gt;
&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060209033636</emailId><senderName>Venkat Manakkal</senderName><senderEmail>venkat@rayservers.com</senderEmail><timestampReceived>2006-02-09 03:36:36-0400</timestampReceived><subject>hardened kernel and loop-aes</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Jari,

I'm having trouble getting the latest hardened kernel and loop-aes happy with
each other, I've used older hardened kernels before. I suspect it is over
ambitious lockdown of PaX and GrSecurity.

I've tried disabling the Preempt the Big Kernel Lock and using the No Forced
Preemption Model (see .config) below...

I will try a few other options or move to another kernel, just thought you
might be interested.

Best regards,

- ---Venkat.

- --
http://rayservers.com/                                            607-546-7300
PGP/GPG:                            https://rayservers.com/keys/0x12430522.asc
Skype: rayservers       GDCA: http://www.gdcaonline.org/members/rayservers.htm

# head -c 15 /dev/urandom | uuencode -m - | head -n 2 | tail -n 1 \
|         | losetup -p 0 -e AES128 /dev/loop3 /dev/md/1
Segmentation fault

uname -a output:

Linux kbw 2.6.14-hardened-r5 #4 SMP Thu Feb 9 11:27:10 GMT 2006 i686 Intel(R)
Pentium(R) 4 CPU 3.00GHz GenuineIntel GNU/Linux

relevant part of dmesg:

eth1: link up, 100Mbps, full-duplex, lpa 0x45E1
Unable to handle kernel paging request at virtual address 0036e6f4
~ printing eip:
0036cf1c
*pgd =    0
*pmd =    0
Oops: 0000 [#1]
SMP
Modules linked in: loop
CPU:    1
EIP:    0060:[&lt;0036cf1c&gt;]    Not tainted VLI
EFLAGS: 00010a47   (2.6.14-hardened-r5)
eax: 00000004   ebx: 64124dcd   ecx: 000000cd   edx: 5df1ce15
esi: ce8efcaa   edi: f7a6b018   ebp: 75b7a29d   esp: f74c5c6c
ds: 007b   es: 007b   ss: 0068
Process losetup (pid: 17543, threadinfo=f74c4000 task=f7e54030)
Stack: f74c5c84 f74c5d30 00000000 00000008 000000d0 00000000 f74c5cac 00000246
~       0036ab77 f7a6b000 f74c5cac 00000010 00000000 f74c5de8 f7ae65d4 f74c5ce8
~       ce8efcaa 75b7a29d 5df1ce15 124dcd64 449b183f 9204755b 771318a4 1904adc0
Call Trace:
~ [&lt;00000000&gt;]
~ [&lt;00000008&gt;]
~ [&lt;000000d0&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000246&gt;]
~ [&lt;0036ab77&gt;]
~ [&lt;00000010&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00369239&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;003695af&gt;]
~ [&lt;00369b6d&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000010&gt;]
~ [&lt;00000010&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000031&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00369ec3&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
~ [&lt;0001af51&gt;]
~ [&lt;00100100&gt;]
~ [&lt;00200200&gt;]
~ [&lt;00369e27&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00004c04&gt;]
~ [&lt;001ccc3c&gt;]
~ [&lt;00004c04&gt;]
~ [&lt;00004c04&gt;]
~ [&lt;001cce41&gt;]
~ [&lt;00004c04&gt;]
~ [&lt;00004c04&gt;]
~ [&lt;0006d37f&gt;]
~ [&lt;00004c04&gt;]
~ [&lt;00078b1a&gt;]
~ [&lt;00004c04&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00004c04&gt;]
~ [&lt;00078cd2&gt;]
~ [&lt;00004c04&gt;]
~ [&lt;00000004&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00078ed3&gt;]
~ [&lt;00000004&gt;]
~ [&lt;00004c04&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000004&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00002e79&gt;]
~ [&lt;00000004&gt;]
~ [&lt;00004c04&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000036&gt;]
~ [&lt;0000007b&gt;]
~ [&lt;00000036&gt;]
~ [&lt;00000073&gt;]
~ [&lt;00000246&gt;]
~ [&lt;0000007b&gt;]
~ [&lt;00000000&gt;]
~ [&lt;0000007b&gt;]
~ [&lt;00000036&gt;]
~ [&lt;00000073&gt;]
~ [&lt;00000206&gt;]
~ [&lt;0000007b&gt;]
~ [&lt;00000000&gt;]
~ [&lt;0000007b&gt;]
~ [&lt;00000036&gt;]
~ [&lt;00000073&gt;]
~ [&lt;00000246&gt;]
~ [&lt;0000007b&gt;]
~ [&lt;0000007b&gt;]
~ [&lt;00000073&gt;]
~ [&lt;00000246&gt;]
~ [&lt;0000007b&gt;]
~ [&lt;00000000&gt;]
~ [&lt;00000000&gt;]
Code: 31 c6 31 f5 89 b7 b0 00 00 00 89 af b4 00 00 00 31 ea 31 d3 89 97 b8 00
00 00 89 9f bc 00 00 00 e9 06 03 00 00 c1 c3 18 0f b6 cb &lt;8b&gt; 04 8d c0 e3 36
00 0f b6 cf c1 cb 10 33 04 8d c0 e7 36 00 0f


the kernel .config

cat .config
#
# Automatically generated make config: don't edit
# Linux kernel version: 2.6.14-hardened-r5
# Thu Feb  9 11:19:00 2006
#
CONFIG_X86=y
CONFIG_SEMAPHORE_SLEEPERS=y
CONFIG_MMU=y
CONFIG_UID16=y
CONFIG_GENERIC_ISA_DMA=y
CONFIG_GENERIC_IOMAP=y
CONFIG_ARCH_MAY_HAVE_PC_FDC=y

#
# Code maturity level options
#
CONFIG_EXPERIMENTAL=y
CONFIG_CLEAN_COMPILE=y
CONFIG_LOCK_KERNEL=y
CONFIG_INIT_ENV_ARG_LIMIT=32

#
# General setup
#
CONFIG_LOCALVERSION=""
CONFIG_LOCALVERSION_AUTO=y
CONFIG_SWAP=y
CONFIG_SYSVIPC=y
CONFIG_POSIX_MQUEUE=y
CONFIG_BSD_PROCESS_ACCT=y
CONFIG_BSD_PROCESS_ACCT_V3=y
CONFIG_SYSCTL=y
CONFIG_AUDIT=y
CONFIG_AUDITSYSCALL=y
CONFIG_HOTPLUG=y
CONFIG_KOBJECT_UEVENT=y
CONFIG_IKCONFIG=y
CONFIG_IKCONFIG_PROC=y
# CONFIG_CPUSETS is not set
CONFIG_INITRAMFS_SOURCE=""
# CONFIG_EMBEDDED is not set
CONFIG_PRINTK=y
CONFIG_BUG=y
CONFIG_BASE_FULL=y
CONFIG_FUTEX=y
CONFIG_EPOLL=y
CONFIG_SHMEM=y
CONFIG_CC_ALIGN_FUNCTIONS=0
CONFIG_CC_ALIGN_LABELS=0
CONFIG_CC_ALIGN_LOOPS=0
CONFIG_CC_ALIGN_JUMPS=0
# CONFIG_TINY_SHMEM is not set
CONFIG_BASE_SMALL=0

#
# Loadable module support
#
CONFIG_MODULES=y
CONFIG_MODULE_UNLOAD=y
CONFIG_MODULE_FORCE_UNLOAD=y
CONFIG_OBSOLETE_MODPARM=y
CONFIG_MODVERSIONS=y
CONFIG_MODULE_SRCVERSION_ALL=y
CONFIG_KMOD=y
CONFIG_STOP_MACHINE=y

#
# Processor type and features
#
CONFIG_X86_PC=y
# CONFIG_X86_ELAN is not set
# CONFIG_X86_VOYAGER is not set
# CONFIG_X86_NUMAQ is not set
# CONFIG_X86_SUMMIT is not set
# CONFIG_X86_BIGSMP is not set
# CONFIG_X86_VISWS is not set
# CONFIG_X86_GENERICARCH is not set
# CONFIG_X86_ES7000 is not set
# CONFIG_M386 is not set
# CONFIG_M486 is not set
# CONFIG_M586 is not set
# CONFIG_M586TSC is not set
# CONFIG_M586MMX is not set
# CONFIG_M686 is not set
# CONFIG_MPENTIUMII is not set
# CONFIG_MPENTIUMIII is not set
# CONFIG_MPENTIUMM is not set
CONFIG_MPENTIUM4=y
# CONFIG_MK6 is not set
# CONFIG_MK7 is not set
# CONFIG_MK8 is not set
# CONFIG_MCRUSOE is not set
# CONFIG_MEFFICEON is not set
# CONFIG_MWINCHIPC6 is not set
# CONFIG_MWINCHIP2 is not set
# CONFIG_MWINCHIP3D is not set
# CONFIG_MGEODEGX1 is not set
# CONFIG_MCYRIXIII is not set
# CONFIG_MVIAC3_2 is not set
# CONFIG_X86_GENERIC is not set
CONFIG_X86_CMPXCHG=y
CONFIG_X86_XADD=y
CONFIG_X86_L1_CACHE_SHIFT=7
CONFIG_RWSEM_XCHGADD_ALGORITHM=y
CONFIG_GENERIC_CALIBRATE_DELAY=y
CONFIG_X86_WP_WORKS_OK=y
CONFIG_X86_INVLPG=y
CONFIG_X86_BSWAP=y
CONFIG_X86_POPAD_OK=y
CONFIG_X86_ALIGNMENT_16=y
CONFIG_X86_GOOD_APIC=y
CONFIG_X86_INTEL_USERCOPY=y
CONFIG_X86_USE_PPRO_CHECKSUM=y
# CONFIG_HPET_TIMER is not set
CONFIG_SMP=y
CONFIG_NR_CPUS=8
CONFIG_SCHED_SMT=y
CONFIG_PREEMPT_NONE=y
# CONFIG_PREEMPT_VOLUNTARY is not set
# CONFIG_PREEMPT is not set
# CONFIG_PREEMPT_BKL is not set
CONFIG_X86_LOCAL_APIC=y
CONFIG_X86_IO_APIC=y
CONFIG_X86_TSC=y
CONFIG_X86_MCE=y
CONFIG_X86_MCE_NONFATAL=y
CONFIG_X86_MCE_P4THERMAL=y
# CONFIG_TOSHIBA is not set
# CONFIG_I8K is not set
# CONFIG_X86_REBOOTFIXUPS is not set
CONFIG_MICROCODE=y
CONFIG_X86_MSR=y
# CONFIG_X86_CPUID is not set

#
# Firmware Drivers
#
# CONFIG_EDD is not set
# CONFIG_DELL_RBU is not set
CONFIG_DCDBAS=m
# CONFIG_NOHIGHMEM is not set
CONFIG_HIGHMEM4G=y
# CONFIG_HIGHMEM64G is not set
CONFIG_HIGHMEM=y
CONFIG_SELECT_MEMORY_MODEL=y
CONFIG_FLATMEM_MANUAL=y
# CONFIG_DISCONTIGMEM_MANUAL is not set
# CONFIG_SPARSEMEM_MANUAL is not set
CONFIG_FLATMEM=y
CONFIG_FLAT_NODE_MEM_MAP=y
# CONFIG_SPARSEMEM_STATIC is not set
# CONFIG_HIGHPTE is not set
# CONFIG_MATH_EMULATION is not set
CONFIG_MTRR=y
# CONFIG_EFI is not set
CONFIG_IRQBALANCE=y
# CONFIG_REGPARM is not set
CONFIG_SECCOMP=y
# CONFIG_HZ_100 is not set
CONFIG_HZ_250=y
# CONFIG_HZ_1000 is not set
CONFIG_HZ=250
CONFIG_PHYSICAL_START=0x100000
# CONFIG_KEXEC is not set

#
# Power management options (ACPI, APM)
#
CONFIG_PM=y
# CONFIG_PM_DEBUG is not set

#
# ACPI (Advanced Configuration and Power Interface) Support
#
CONFIG_ACPI=y
CONFIG_ACPI_AC=y
CONFIG_ACPI_BATTERY=y
CONFIG_ACPI_BUTTON=y
CONFIG_ACPI_VIDEO=y
# CONFIG_ACPI_HOTKEY is not set
CONFIG_ACPI_FAN=y
CONFIG_ACPI_PROCESSOR=y
CONFIG_ACPI_THERMAL=y
# CONFIG_ACPI_ASUS is not set
CONFIG_ACPI_IBM=y
# CONFIG_ACPI_TOSHIBA is not set
CONFIG_ACPI_BLACKLIST_YEAR=0
# CONFIG_ACPI_DEBUG is not set
CONFIG_ACPI_EC=y
CONFIG_ACPI_POWER=y
CONFIG_ACPI_SYSTEM=y
# CONFIG_X86_PM_TIMER is not set
# CONFIG_ACPI_CONTAINER is not set

#
# APM (Advanced Power Management) BIOS Support
#
# CONFIG_APM is not set

#
# CPU Frequency scaling
#
CONFIG_CPU_FREQ=y
CONFIG_CPU_FREQ_TABLE=y
# CONFIG_CPU_FREQ_DEBUG is not set
CONFIG_CPU_FREQ_STAT=y
# CONFIG_CPU_FREQ_STAT_DETAILS is not set
CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set

#
# CPUFreq processor drivers
#
# CONFIG_X86_ACPI_CPUFREQ is not set
# CONFIG_X86_POWERNOW_K6 is not set
# CONFIG_X86_POWERNOW_K7 is not set
# CONFIG_X86_POWERNOW_K8 is not set
# CONFIG_X86_GX_SUSPMOD is not set
CONFIG_X86_SPEEDSTEP_CENTRINO=y
CONFIG_X86_SPEEDSTEP_CENTRINO_ACPI=y
CONFIG_X86_SPEEDSTEP_CENTRINO_TABLE=y
CONFIG_X86_SPEEDSTEP_ICH=y
# CONFIG_X86_SPEEDSTEP_SMI is not set
# CONFIG_X86_P4_CLOCKMOD is not set
# CONFIG_X86_CPUFREQ_NFORCE2 is not set
# CONFIG_X86_LONGRUN is not set
# CONFIG_X86_LONGHAUL is not set

#
# shared options
#
# CONFIG_X86_ACPI_CPUFREQ_PROC_INTF is not set
CONFIG_X86_SPEEDSTEP_LIB=y
# CONFIG_X86_SPEEDSTEP_RELAXED_CAP_CHECK is not set

#
# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
#
CONFIG_PCI=y
# CONFIG_PCI_GOBIOS is not set
# CONFIG_PCI_GOMMCONFIG is not set
# CONFIG_PCI_GODIRECT is not set
CONFIG_PCI_GOANY=y
CONFIG_PCI_DIRECT=y
CONFIG_PCI_MMCONFIG=y
# CONFIG_PCIEPORTBUS is not set
# CONFIG_PCI_MSI is not set
CONFIG_PCI_LEGACY_PROC=y
CONFIG_ISA_DMA_API=y
CONFIG_ISA=y
# CONFIG_EISA is not set
# CONFIG_MCA is not set
# CONFIG_SCx200 is not set
# CONFIG_HOTPLUG_CPU is not set

#
# PCCARD (PCMCIA/CardBus) support
#
# CONFIG_PCCARD is not set

#
# PCI Hotplug Support
#
# CONFIG_HOTPLUG_PCI is not set

#
# Executable file formats
#
CONFIG_BINFMT_ELF=y
CONFIG_BINFMT_AOUT=y
CONFIG_BINFMT_MISC=y

#
# Networking
#
CONFIG_NET=y

#
# Networking options
#
CONFIG_PACKET=y
# CONFIG_PACKET_MMAP is not set
CONFIG_UNIX=y
# CONFIG_NET_KEY is not set
CONFIG_INET=y
CONFIG_IP_MULTICAST=y
CONFIG_IP_ADVANCED_ROUTER=y
CONFIG_ASK_IP_FIB_HASH=y
# CONFIG_IP_FIB_TRIE is not set
CONFIG_IP_FIB_HASH=y
CONFIG_IP_MULTIPLE_TABLES=y
CONFIG_IP_ROUTE_FWMARK=y
CONFIG_IP_ROUTE_MULTIPATH=y
CONFIG_IP_ROUTE_MULTIPATH_CACHED=y
CONFIG_IP_ROUTE_MULTIPATH_RR=m
CONFIG_IP_ROUTE_MULTIPATH_RANDOM=m
CONFIG_IP_ROUTE_MULTIPATH_WRANDOM=m
CONFIG_IP_ROUTE_MULTIPATH_DRR=m
CONFIG_IP_ROUTE_VERBOSE=y
# CONFIG_IP_PNP is not set
# CONFIG_NET_IPIP is not set
CONFIG_NET_IPGRE=m
CONFIG_NET_IPGRE_BROADCAST=y
# CONFIG_IP_MROUTE is not set
CONFIG_ARPD=y
# CONFIG_SYN_COOKIES is not set
# CONFIG_INET_AH is not set
# CONFIG_INET_ESP is not set
# CONFIG_INET_IPCOMP is not set
# CONFIG_INET_TUNNEL is not set
CONFIG_INET_DIAG=y
CONFIG_INET_TCP_DIAG=y
# CONFIG_TCP_CONG_ADVANCED is not set
CONFIG_TCP_CONG_BIC=y

#
# IP: Virtual Server Configuration
#
# CONFIG_IP_VS is not set
# CONFIG_IPV6 is not set
CONFIG_NETFILTER=y
# CONFIG_NETFILTER_DEBUG is not set
# CONFIG_NETFILTER_NETLINK is not set

#
# IP: Netfilter Configuration
#
CONFIG_IP_NF_CONNTRACK=y
CONFIG_IP_NF_CT_ACCT=y
CONFIG_IP_NF_CONNTRACK_MARK=y
CONFIG_IP_NF_CONNTRACK_EVENTS=y
CONFIG_IP_NF_CT_PROTO_SCTP=m
CONFIG_IP_NF_FTP=m
CONFIG_IP_NF_IRC=m
CONFIG_IP_NF_NETBIOS_NS=m
CONFIG_IP_NF_TFTP=m
CONFIG_IP_NF_AMANDA=m
CONFIG_IP_NF_PPTP=m
CONFIG_IP_NF_QUEUE=m
CONFIG_IP_NF_IPTABLES=m
CONFIG_IP_NF_MATCH_LIMIT=m
CONFIG_IP_NF_MATCH_IPRANGE=m
CONFIG_IP_NF_MATCH_MAC=m
CONFIG_IP_NF_MATCH_PKTTYPE=m
CONFIG_IP_NF_MATCH_MARK=m
CONFIG_IP_NF_MATCH_MULTIPORT=m
CONFIG_IP_NF_MATCH_TOS=m
CONFIG_IP_NF_MATCH_RECENT=m
CONFIG_IP_NF_MATCH_ECN=m
CONFIG_IP_NF_MATCH_DSCP=m
CONFIG_IP_NF_MATCH_AH_ESP=m
CONFIG_IP_NF_MATCH_LENGTH=m
CONFIG_IP_NF_MATCH_TTL=m
CONFIG_IP_NF_MATCH_TCPMSS=m
# CONFIG_IP_NF_MATCH_STEALTH is not set
CONFIG_IP_NF_MATCH_HELPER=m
CONFIG_IP_NF_MATCH_STATE=m
CONFIG_IP_NF_MATCH_CONNTRACK=m
CONFIG_IP_NF_MATCH_OWNER=m
CONFIG_IP_NF_MATCH_ADDRTYPE=m
CONFIG_IP_NF_MATCH_REALM=m
CONFIG_IP_NF_MATCH_SCTP=m
CONFIG_IP_NF_MATCH_DCCP=m
CONFIG_IP_NF_MATCH_COMMENT=m
CONFIG_IP_NF_MATCH_CONNMARK=m
CONFIG_IP_NF_MATCH_CONNBYTES=m
CONFIG_IP_NF_MATCH_HASHLIMIT=m
CONFIG_IP_NF_MATCH_STRING=m
CONFIG_IP_NF_FILTER=m
CONFIG_IP_NF_TARGET_REJECT=m
CONFIG_IP_NF_TARGET_LOG=m
CONFIG_IP_NF_TARGET_ULOG=m
CONFIG_IP_NF_TARGET_TCPMSS=m
CONFIG_IP_NF_TARGET_NFQUEUE=m
CONFIG_IP_NF_NAT=m
CONFIG_IP_NF_NAT_NEEDED=y
CONFIG_IP_NF_TARGET_MASQUERADE=m
CONFIG_IP_NF_TARGET_REDIRECT=m
CONFIG_IP_NF_TARGET_NETMAP=m
CONFIG_IP_NF_TARGET_SAME=m
# CONFIG_IP_NF_NAT_SNMP_BASIC is not set
CONFIG_IP_NF_NAT_IRC=m
CONFIG_IP_NF_NAT_FTP=m
CONFIG_IP_NF_NAT_TFTP=m
CONFIG_IP_NF_NAT_AMANDA=m
CONFIG_IP_NF_NAT_PPTP=m
CONFIG_IP_NF_MANGLE=m
CONFIG_IP_NF_TARGET_TOS=m
CONFIG_IP_NF_TARGET_ECN=m
CONFIG_IP_NF_TARGET_DSCP=m
CONFIG_IP_NF_TARGET_MARK=m
CONFIG_IP_NF_TARGET_CLASSIFY=m
CONFIG_IP_NF_TARGET_TTL=m
# CONFIG_IP_NF_TARGET_CONNMARK is not set
# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
CONFIG_IP_NF_RAW=m
CONFIG_IP_NF_TARGET_NOTRACK=m
CONFIG_IP_NF_ARPTABLES=y
CONFIG_IP_NF_ARPFILTER=y
CONFIG_IP_NF_ARP_MANGLE=y

#
# DCCP Configuration (EXPERIMENTAL)
#
# CONFIG_IP_DCCP is not set

#
# SCTP Configuration (EXPERIMENTAL)
#
# CONFIG_IP_SCTP is not set
# CONFIG_ATM is not set
# CONFIG_BRIDGE is not set
# CONFIG_VLAN_8021Q is not set
# CONFIG_DECNET is not set
# CONFIG_LLC2 is not set
# CONFIG_IPX is not set
# CONFIG_ATALK is not set
# CONFIG_X25 is not set
# CONFIG_LAPB is not set
# CONFIG_NET_DIVERT is not set
# CONFIG_ECONET is not set
# CONFIG_WAN_ROUTER is not set
CONFIG_NET_SCHED=y
CONFIG_NET_SCH_CLK_JIFFIES=y
# CONFIG_NET_SCH_CLK_GETTIMEOFDAY is not set
# CONFIG_NET_SCH_CLK_CPU is not set
CONFIG_NET_SCH_CBQ=m
CONFIG_NET_SCH_HTB=m
CONFIG_NET_SCH_HFSC=m
CONFIG_NET_SCH_PRIO=m
CONFIG_NET_SCH_RED=m
CONFIG_NET_SCH_SFQ=m
CONFIG_NET_SCH_TEQL=m
CONFIG_NET_SCH_TBF=m
CONFIG_NET_SCH_GRED=m
CONFIG_NET_SCH_DSMARK=m
CONFIG_NET_SCH_NETEM=m
CONFIG_NET_SCH_INGRESS=m
CONFIG_NET_QOS=y
CONFIG_NET_ESTIMATOR=y
CONFIG_NET_CLS=y
CONFIG_NET_CLS_BASIC=m
CONFIG_NET_CLS_TCINDEX=m
CONFIG_NET_CLS_ROUTE4=m
CONFIG_NET_CLS_ROUTE=y
# CONFIG_NET_CLS_FW is not set
# CONFIG_NET_CLS_U32 is not set
# CONFIG_NET_CLS_RSVP is not set
# CONFIG_NET_CLS_RSVP6 is not set
# CONFIG_NET_EMATCH is not set
# CONFIG_NET_CLS_ACT is not set
# CONFIG_NET_CLS_POLICE is not set

#
# Network testing
#
# CONFIG_NET_PKTGEN is not set
# CONFIG_HAMRADIO is not set
# CONFIG_IRDA is not set
# CONFIG_BT is not set
# CONFIG_IEEE80211 is not set

#
# Device Drivers
#

#
# Generic Driver Options
#
CONFIG_STANDALONE=y
CONFIG_PREVENT_FIRMWARE_BUILD=y
CONFIG_FW_LOADER=m

#
# Connector - unified userspace &lt;-&gt; kernelspace linker
#
# CONFIG_CONNECTOR is not set

#
# Memory Technology Devices (MTD)
#
# CONFIG_MTD is not set

#
# Parallel port support
#
CONFIG_PARPORT=y
CONFIG_PARPORT_PC=y
# CONFIG_PARPORT_SERIAL is not set
# CONFIG_PARPORT_PC_FIFO is not set
# CONFIG_PARPORT_PC_SUPERIO is not set
# CONFIG_PARPORT_GSC is not set
# CONFIG_PARPORT_1284 is not set

#
# Plug and Play support
#
CONFIG_PNP=y
# CONFIG_PNP_DEBUG is not set

#
# Protocols
#
# CONFIG_ISAPNP is not set
# CONFIG_PNPBIOS is not set
CONFIG_PNPACPI=y

#
# Block devices
#
CONFIG_BLK_DEV_FD=y
# CONFIG_BLK_DEV_XD is not set
# CONFIG_PARIDE is not set
# CONFIG_BLK_CPQ_DA is not set
# CONFIG_BLK_CPQ_CISS_DA is not set
# CONFIG_BLK_DEV_DAC960 is not set
# CONFIG_BLK_DEV_UMEM is not set
# CONFIG_BLK_DEV_COW_COMMON is not set
# CONFIG_BLK_DEV_LOOP is not set
# CONFIG_BLK_DEV_NBD is not set
# CONFIG_BLK_DEV_SX8 is not set
# CONFIG_BLK_DEV_UB is not set
# CONFIG_BLK_DEV_RAM is not set
CONFIG_BLK_DEV_RAM_COUNT=16
CONFIG_LBD=y
# CONFIG_CDROM_PKTCDVD is not set

#
# IO Schedulers
#
CONFIG_IOSCHED_NOOP=y
CONFIG_IOSCHED_AS=y
CONFIG_IOSCHED_DEADLINE=y
CONFIG_IOSCHED_CFQ=y
# CONFIG_ATA_OVER_ETH is not set

#
# ATA/ATAPI/MFM/RLL support
#
CONFIG_IDE=y
CONFIG_BLK_DEV_IDE=y

#
# Please see Documentation/ide.txt for help/info on IDE drives
#
# CONFIG_BLK_DEV_IDE_SATA is not set
# CONFIG_BLK_DEV_HD_IDE is not set
CONFIG_BLK_DEV_IDEDISK=y
CONFIG_IDEDISK_MULTI_MODE=y
CONFIG_BLK_DEV_IDECD=y
# CONFIG_BLK_DEV_IDETAPE is not set
# CONFIG_BLK_DEV_IDEFLOPPY is not set
# CONFIG_BLK_DEV_IDESCSI is not set
# CONFIG_IDE_TASK_IOCTL is not set

#
# IDE chipset support/bugfixes
#
CONFIG_IDE_GENERIC=y
CONFIG_BLK_DEV_CMD640=y
# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
# CONFIG_BLK_DEV_IDEPNP is not set
CONFIG_BLK_DEV_IDEPCI=y
CONFIG_IDEPCI_SHARE_IRQ=y
# CONFIG_BLK_DEV_OFFBOARD is not set
CONFIG_BLK_DEV_GENERIC=y
# CONFIG_BLK_DEV_OPTI621 is not set
CONFIG_BLK_DEV_RZ1000=y
CONFIG_BLK_DEV_IDEDMA_PCI=y
# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
CONFIG_IDEDMA_PCI_AUTO=y
# CONFIG_IDEDMA_ONLYDISK is not set
# CONFIG_BLK_DEV_AEC62XX is not set
# CONFIG_BLK_DEV_ALI15X3 is not set
# CONFIG_BLK_DEV_AMD74XX is not set
# CONFIG_BLK_DEV_ATIIXP is not set
# CONFIG_BLK_DEV_CMD64X is not set
# CONFIG_BLK_DEV_TRIFLEX is not set
# CONFIG_BLK_DEV_CY82C693 is not set
# CONFIG_BLK_DEV_CS5520 is not set
# CONFIG_BLK_DEV_CS5530 is not set
# CONFIG_BLK_DEV_HPT34X is not set
# CONFIG_BLK_DEV_HPT366 is not set
# CONFIG_BLK_DEV_SC1200 is not set
CONFIG_BLK_DEV_PIIX=y
# CONFIG_BLK_DEV_IT821X is not set
# CONFIG_BLK_DEV_NS87415 is not set
# CONFIG_BLK_DEV_PDC202XX_OLD is not set
# CONFIG_BLK_DEV_PDC202XX_NEW is not set
# CONFIG_BLK_DEV_SVWKS is not set
# CONFIG_BLK_DEV_SIIMAGE is not set
# CONFIG_BLK_DEV_SIS5513 is not set
# CONFIG_BLK_DEV_SLC90E66 is not set
# CONFIG_BLK_DEV_TRM290 is not set
# CONFIG_BLK_DEV_VIA82CXXX is not set
# CONFIG_IDE_ARM is not set
# CONFIG_IDE_CHIPSETS is not set
CONFIG_BLK_DEV_IDEDMA=y
# CONFIG_IDEDMA_IVB is not set
CONFIG_IDEDMA_AUTO=y
# CONFIG_BLK_DEV_HD is not set

#
# SCSI device support
#
# CONFIG_RAID_ATTRS is not set
CONFIG_SCSI=y
CONFIG_SCSI_PROC_FS=y

#
# SCSI support type (disk, tape, CD-ROM)
#
CONFIG_BLK_DEV_SD=y
# CONFIG_CHR_DEV_ST is not set
# CONFIG_CHR_DEV_OSST is not set
# CONFIG_BLK_DEV_SR is not set
CONFIG_CHR_DEV_SG=y
# CONFIG_CHR_DEV_SCH is not set

#
# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
#
# CONFIG_SCSI_MULTI_LUN is not set
# CONFIG_SCSI_CONSTANTS is not set
# CONFIG_SCSI_LOGGING is not set

#
# SCSI Transport Attributes
#
# CONFIG_SCSI_SPI_ATTRS is not set
# CONFIG_SCSI_FC_ATTRS is not set
# CONFIG_SCSI_ISCSI_ATTRS is not set
# CONFIG_SCSI_SAS_ATTRS is not set

#
# SCSI low-level drivers
#
# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
# CONFIG_SCSI_3W_9XXX is not set
# CONFIG_SCSI_7000FASST is not set
# CONFIG_SCSI_ACARD is not set
# CONFIG_SCSI_AHA152X is not set
# CONFIG_SCSI_AHA1542 is not set
# CONFIG_SCSI_AACRAID is not set
# CONFIG_SCSI_AIC7XXX is not set
# CONFIG_SCSI_AIC7XXX_OLD is not set
# CONFIG_SCSI_AIC79XX is not set
# CONFIG_SCSI_DPT_I2O is not set
# CONFIG_SCSI_IN2000 is not set
# CONFIG_MEGARAID_NEWGEN is not set
# CONFIG_MEGARAID_LEGACY is not set
# CONFIG_MEGARAID_SAS is not set
CONFIG_SCSI_SATA=y
# CONFIG_SCSI_SATA_AHCI is not set
# CONFIG_SCSI_SATA_SVW is not set
CONFIG_SCSI_ATA_PIIX=y
# CONFIG_SCSI_SATA_MV is not set
# CONFIG_SCSI_SATA_NV is not set
# CONFIG_SCSI_SATA_PROMISE is not set
# CONFIG_SCSI_SATA_QSTOR is not set
# CONFIG_SCSI_SATA_SX4 is not set
# CONFIG_SCSI_SATA_SIL is not set
# CONFIG_SCSI_SATA_SIS is not set
# CONFIG_SCSI_SATA_ULI is not set
# CONFIG_SCSI_SATA_VIA is not set
# CONFIG_SCSI_SATA_VITESSE is not set
CONFIG_SCSI_SATA_INTEL_COMBINED=y
# CONFIG_SCSI_BUSLOGIC is not set
# CONFIG_SCSI_DMX3191D is not set
# CONFIG_SCSI_DTC3280 is not set
# CONFIG_SCSI_EATA is not set
# CONFIG_SCSI_FUTURE_DOMAIN is not set
# CONFIG_SCSI_GDTH is not set
# CONFIG_SCSI_GENERIC_NCR5380 is not set
# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
# CONFIG_SCSI_IPS is not set
# CONFIG_SCSI_INITIO is not set
# CONFIG_SCSI_INIA100 is not set
# CONFIG_SCSI_PPA is not set
# CONFIG_SCSI_IMM is not set
# CONFIG_SCSI_NCR53C406A is not set
# CONFIG_SCSI_SYM53C8XX_2 is not set
CONFIG_SCSI_IPR=m
# CONFIG_SCSI_IPR_TRACE is not set
# CONFIG_SCSI_IPR_DUMP is not set
# CONFIG_SCSI_PAS16 is not set
# CONFIG_SCSI_PSI240I is not set
# CONFIG_SCSI_QLOGIC_FAS is not set
# CONFIG_SCSI_QLOGIC_FC is not set
# CONFIG_SCSI_QLOGIC_1280 is not set
CONFIG_SCSI_QLA2XXX=y
# CONFIG_SCSI_QLA21XX is not set
# CONFIG_SCSI_QLA22XX is not set
# CONFIG_SCSI_QLA2300 is not set
# CONFIG_SCSI_QLA2322 is not set
# CONFIG_SCSI_QLA6312 is not set
# CONFIG_SCSI_QLA24XX is not set
# CONFIG_SCSI_LPFC is not set
# CONFIG_SCSI_SYM53C416 is not set
# CONFIG_SCSI_DC395x is not set
# CONFIG_SCSI_DC390T is not set
# CONFIG_SCSI_T128 is not set
# CONFIG_SCSI_U14_34F is not set
# CONFIG_SCSI_ULTRASTOR is not set
# CONFIG_SCSI_NSP32 is not set
# CONFIG_SCSI_DEBUG is not set

#
# Old CD-ROM drivers (not SCSI, not IDE)
#
# CONFIG_CD_NO_IDESCSI is not set

#
# Multi-device support (RAID and LVM)
#
CONFIG_MD=y
CONFIG_BLK_DEV_MD=y
# CONFIG_MD_LINEAR is not set
# CONFIG_MD_RAID0 is not set
CONFIG_MD_RAID1=y
# CONFIG_MD_RAID10 is not set
# CONFIG_MD_RAID5 is not set
# CONFIG_MD_RAID6 is not set
# CONFIG_MD_MULTIPATH is not set
# CONFIG_MD_FAULTY is not set
CONFIG_BLK_DEV_DM=y
CONFIG_DM_CRYPT=y
CONFIG_DM_SNAPSHOT=y
CONFIG_DM_MIRROR=y
CONFIG_DM_ZERO=y
CONFIG_DM_MULTIPATH=y
CONFIG_DM_MULTIPATH_EMC=y
CONFIG_BLK_DEV_DM_BBR=y

#
# Fusion MPT device support
#
# CONFIG_FUSION is not set
# CONFIG_FUSION_SPI is not set
# CONFIG_FUSION_FC is not set
# CONFIG_FUSION_SAS is not set

#
# IEEE 1394 (FireWire) support
#
CONFIG_IEEE1394=y

#
# Subsystem Options
#
# CONFIG_IEEE1394_VERBOSEDEBUG is not set
# CONFIG_IEEE1394_OUI_DB is not set
# CONFIG_IEEE1394_EXTRA_CONFIG_ROMS is not set
# CONFIG_IEEE1394_EXPORT_FULL_API is not set

#
# Device Drivers
#

#
# Texas Instruments PCILynx requires I2C
#
CONFIG_IEEE1394_OHCI1394=y

#
# Protocol Drivers
#
# CONFIG_IEEE1394_VIDEO1394 is not set
# CONFIG_IEEE1394_SBP2 is not set
# CONFIG_IEEE1394_ETH1394 is not set
# CONFIG_IEEE1394_DV1394 is not set
CONFIG_IEEE1394_RAWIO=y
# CONFIG_IEEE1394_CMP is not set

#
# I2O device support
#
# CONFIG_I2O is not set

#
# Network device support
#
CONFIG_NETDEVICES=y
CONFIG_DUMMY=m
# CONFIG_BONDING is not set
# CONFIG_EQUALIZER is not set
CONFIG_TUN=m
# CONFIG_NET_SB1000 is not set

#
# ARCnet devices
#
# CONFIG_ARCNET is not set

#
# PHY device support
#
# CONFIG_PHYLIB is not set

#
# Ethernet (10 or 100Mbit)
#
CONFIG_NET_ETHERNET=y
CONFIG_MII=y
# CONFIG_HAPPYMEAL is not set
# CONFIG_SUNGEM is not set
# CONFIG_CASSINI is not set
# CONFIG_NET_VENDOR_3COM is not set
# CONFIG_LANCE is not set
# CONFIG_NET_VENDOR_SMC is not set
# CONFIG_NET_VENDOR_RACAL is not set

#
# Tulip family network device support
#
# CONFIG_NET_TULIP is not set
# CONFIG_AT1700 is not set
# CONFIG_DEPCA is not set
# CONFIG_HP100 is not set
# CONFIG_NET_ISA is not set
CONFIG_NET_PCI=y
# CONFIG_PCNET32 is not set
# CONFIG_AMD8111_ETH is not set
# CONFIG_ADAPTEC_STARFIRE is not set
# CONFIG_AC3200 is not set
# CONFIG_APRICOT is not set
# CONFIG_B44 is not set
# CONFIG_FORCEDETH is not set
# CONFIG_CS89x0 is not set
# CONFIG_DGRS is not set
# CONFIG_EEPRO100 is not set
# CONFIG_E100 is not set
# CONFIG_FEALNX is not set
# CONFIG_NATSEMI is not set
# CONFIG_NE2K_PCI is not set
# CONFIG_8139CP is not set
CONFIG_8139TOO=y
CONFIG_8139TOO_PIO=y
# CONFIG_8139TOO_TUNE_TWISTER is not set
# CONFIG_8139TOO_8129 is not set
# CONFIG_8139_OLD_RX_RESET is not set
# CONFIG_SIS900 is not set
# CONFIG_EPIC100 is not set
# CONFIG_SUNDANCE is not set
# CONFIG_TLAN is not set
# CONFIG_VIA_RHINE is not set
# CONFIG_NET_POCKET is not set

#
# Ethernet (1000 Mbit)
#
# CONFIG_ACENIC is not set
# CONFIG_DL2K is not set
# CONFIG_E1000 is not set
# CONFIG_NS83820 is not set
# CONFIG_HAMACHI is not set
# CONFIG_YELLOWFIN is not set
# CONFIG_R8169 is not set
# CONFIG_SIS190 is not set
# CONFIG_SKGE is not set
# CONFIG_SK98LIN is not set
# CONFIG_VIA_VELOCITY is not set
# CONFIG_TIGON3 is not set
# CONFIG_BNX2 is not set

#
# Ethernet (10000 Mbit)
#
# CONFIG_CHELSIO_T1 is not set
# CONFIG_IXGB is not set
# CONFIG_S2IO is not set

#
# Token Ring devices
#
# CONFIG_TR is not set

#
# Wireless LAN (non-hamradio)
#
# CONFIG_NET_RADIO is not set

#
# Wan interfaces
#
# CONFIG_WAN is not set
# CONFIG_FDDI is not set
# CONFIG_HIPPI is not set
# CONFIG_PLIP is not set
# CONFIG_PPP is not set
# CONFIG_SLIP is not set
# CONFIG_NET_FC is not set
# CONFIG_SHAPER is not set
# CONFIG_NETCONSOLE is not set
# CONFIG_NETPOLL is not set
# CONFIG_NET_POLL_CONTROLLER is not set

#
# ISDN subsystem
#
# CONFIG_ISDN is not set

#
# Telephony Support
#
# CONFIG_PHONE is not set

#
# Input device support
#
CONFIG_INPUT=y

#
# Userland interfaces
#
CONFIG_INPUT_MOUSEDEV=y
CONFIG_INPUT_MOUSEDEV_PSAUX=y
CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
# CONFIG_INPUT_JOYDEV is not set
# CONFIG_INPUT_TSDEV is not set
# CONFIG_INPUT_EVDEV is not set
# CONFIG_INPUT_EVBUG is not set

#
# Input Device Drivers
#
CONFIG_INPUT_KEYBOARD=y
CONFIG_KEYBOARD_ATKBD=y
# CONFIG_KEYBOARD_SUNKBD is not set
# CONFIG_KEYBOARD_LKKBD is not set
# CONFIG_KEYBOARD_XTKBD is not set
# CONFIG_KEYBOARD_NEWTON is not set
CONFIG_INPUT_MOUSE=y
CONFIG_MOUSE_PS2=y
# CONFIG_MOUSE_SERIAL is not set
# CONFIG_MOUSE_INPORT is not set
# CONFIG_MOUSE_LOGIBM is not set
# CONFIG_MOUSE_PC110PAD is not set
# CONFIG_MOUSE_VSXXXAA is not set
# CONFIG_INPUT_JOYSTICK is not set
# CONFIG_INPUT_TOUCHSCREEN is not set
# CONFIG_INPUT_MISC is not set

#
# Hardware I/O ports
#
CONFIG_SERIO=y
CONFIG_SERIO_I8042=y
# CONFIG_SERIO_SERPORT is not set
# CONFIG_SERIO_CT82C710 is not set
# CONFIG_SERIO_PARKBD is not set
# CONFIG_SERIO_PCIPS2 is not set
CONFIG_SERIO_LIBPS2=y
# CONFIG_SERIO_RAW is not set
# CONFIG_GAMEPORT is not set

#
# Character devices
#
CONFIG_VT=y
CONFIG_VT_CONSOLE=y
CONFIG_HW_CONSOLE=y
# CONFIG_SERIAL_NONSTANDARD is not set

#
# Serial drivers
#
CONFIG_SERIAL_8250=y
# CONFIG_SERIAL_8250_CONSOLE is not set
# CONFIG_SERIAL_8250_ACPI is not set
CONFIG_SERIAL_8250_NR_UARTS=4
# CONFIG_SERIAL_8250_EXTENDED is not set

#
# Non-8250 serial port support
#
CONFIG_SERIAL_CORE=y
# CONFIG_SERIAL_JSM is not set
CONFIG_UNIX98_PTYS=y
CONFIG_LEGACY_PTYS=y
CONFIG_LEGACY_PTY_COUNT=256
CONFIG_PRINTER=y
# CONFIG_LP_CONSOLE is not set
# CONFIG_PPDEV is not set
# CONFIG_TIPAR is not set

#
# IPMI
#
# CONFIG_IPMI_HANDLER is not set

#
# Watchdog Cards
#
# CONFIG_WATCHDOG is not set
# CONFIG_HW_RANDOM is not set
# CONFIG_NVRAM is not set
CONFIG_RTC=y
# CONFIG_DTLK is not set
# CONFIG_R3964 is not set
# CONFIG_APPLICOM is not set
# CONFIG_SONYPI is not set

#
# Ftape, the floppy tape device driver
#
CONFIG_AGP=y
# CONFIG_AGP_ALI is not set
# CONFIG_AGP_ATI is not set
# CONFIG_AGP_AMD is not set
# CONFIG_AGP_AMD64 is not set
CONFIG_AGP_INTEL=y
# CONFIG_AGP_NVIDIA is not set
# CONFIG_AGP_SIS is not set
# CONFIG_AGP_SWORKS is not set
# CONFIG_AGP_VIA is not set
# CONFIG_AGP_EFFICEON is not set
CONFIG_DRM=y
# CONFIG_DRM_TDFX is not set
# CONFIG_DRM_R128 is not set
# CONFIG_DRM_RADEON is not set
# CONFIG_DRM_I810 is not set
# CONFIG_DRM_I830 is not set
# CONFIG_DRM_I915 is not set
# CONFIG_DRM_MGA is not set
# CONFIG_DRM_SIS is not set
# CONFIG_DRM_VIA is not set
# CONFIG_DRM_SAVAGE is not set
# CONFIG_MWAVE is not set
# CONFIG_RAW_DRIVER is not set
# CONFIG_HPET is not set
# CONFIG_HANGCHECK_TIMER is not set

#
# TPM devices
#
# CONFIG_TCG_TPM is not set

#
# I2C support
#
# CONFIG_I2C is not set

#
# Dallas's 1-wire bus
#
# CONFIG_W1 is not set

#
# Hardware Monitoring support
#
CONFIG_HWMON=y
# CONFIG_HWMON_VID is not set
# CONFIG_SENSORS_HDAPS is not set
# CONFIG_HWMON_DEBUG_CHIP is not set

#
# Misc devices
#
# CONFIG_IBM_ASM is not set

#
# Multimedia Capabilities Port drivers
#

#
# Multimedia devices
#
# CONFIG_VIDEO_DEV is not set

#
# Digital Video Broadcasting Devices
#
# CONFIG_DVB is not set

#
# Graphics support
#
# CONFIG_FB is not set
# CONFIG_VIDEO_SELECT is not set

#
# Console display driver support
#
CONFIG_VGA_CONSOLE=y
# CONFIG_MDA_CONSOLE is not set
CONFIG_DUMMY_CONSOLE=y

#
# Sound
#
# CONFIG_SOUND is not set

#
# USB support
#
CONFIG_USB_ARCH_HAS_HCD=y
CONFIG_USB_ARCH_HAS_OHCI=y
CONFIG_USB=y
# CONFIG_USB_DEBUG is not set

#
# Miscellaneous USB options
#
CONFIG_USB_DEVICEFS=y
# CONFIG_USB_BANDWIDTH is not set
# CONFIG_USB_DYNAMIC_MINORS is not set
# CONFIG_USB_SUSPEND is not set
# CONFIG_USB_OTG is not set

#
# USB Host Controller Drivers
#
CONFIG_USB_EHCI_HCD=y
# CONFIG_USB_EHCI_SPLIT_ISO is not set
# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
# CONFIG_USB_ISP116X_HCD is not set
# CONFIG_USB_OHCI_HCD is not set
CONFIG_USB_UHCI_HCD=y
# CONFIG_USB_SL811_HCD is not set

#
# USB Device Class drivers
#
# CONFIG_USB_BLUETOOTH_TTY is not set
# CONFIG_USB_ACM is not set
CONFIG_USB_PRINTER=y

#
# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed;
see USB_STORAGE Help for more information
#
CONFIG_USB_STORAGE=y
# CONFIG_USB_STORAGE_DEBUG is not set
# CONFIG_USB_STORAGE_DATAFAB is not set
# CONFIG_USB_STORAGE_FREECOM is not set
# CONFIG_USB_STORAGE_ISD200 is not set
# CONFIG_USB_STORAGE_DPCM is not set
# CONFIG_USB_STORAGE_USBAT is not set
# CONFIG_USB_STORAGE_SDDR09 is not set
# CONFIG_USB_STORAGE_SDDR55 is not set
# CONFIG_USB_STORAGE_JUMPSHOT is not set

#
# USB Input Devices
#
CONFIG_USB_HID=y
CONFIG_USB_HIDINPUT=y
# CONFIG_HID_FF is not set
# CONFIG_USB_HIDDEV is not set
# CONFIG_USB_AIPTEK is not set
# CONFIG_USB_WACOM is not set
# CONFIG_USB_ACECAD is not set
# CONFIG_USB_KBTAB is not set
# CONFIG_USB_POWERMATE is not set
# CONFIG_USB_MTOUCH is not set
# CONFIG_USB_ITMTOUCH is not set
CONFIG_USB_EGALAX=m
# CONFIG_USB_YEALINK is not set
# CONFIG_USB_XPAD is not set
# CONFIG_USB_ATI_REMOTE is not set
# CONFIG_USB_KEYSPAN_REMOTE is not set
# CONFIG_USB_APPLETOUCH is not set

#
# USB Imaging devices
#
# CONFIG_USB_MDC800 is not set
# CONFIG_USB_MICROTEK is not set

#
# USB Multimedia devices
#
# CONFIG_USB_DABUSB is not set

#
# Video4Linux support is needed for USB Multimedia device support
#

#
# USB Network Adapters
#
# CONFIG_USB_CATC is not set
# CONFIG_USB_KAWETH is not set
# CONFIG_USB_PEGASUS is not set
# CONFIG_USB_RTL8150 is not set
# CONFIG_USB_USBNET is not set
CONFIG_USB_MON=y

#
# USB port drivers
#
# CONFIG_USB_USS720 is not set

#
# USB Serial Converter support
#
# CONFIG_USB_SERIAL is not set

#
# USB Miscellaneous drivers
#
# CONFIG_USB_EMI62 is not set
# CONFIG_USB_EMI26 is not set
# CONFIG_USB_AUERSWALD is not set
# CONFIG_USB_RIO500 is not set
# CONFIG_USB_LEGOTOWER is not set
# CONFIG_USB_LCD is not set
# CONFIG_USB_LED is not set
CONFIG_USB_CYTHERM=m
# CONFIG_USB_PHIDGETKIT is not set
CONFIG_USB_PHIDGETSERVO=m
# CONFIG_USB_IDMOUSE is not set
# CONFIG_USB_SISUSBVGA is not set
# CONFIG_USB_LD is not set
# CONFIG_USB_TEST is not set

#
# USB DSL modem support
#

#
# USB Gadget Support
#
# CONFIG_USB_GADGET is not set

#
# MMC/SD Card support
#
# CONFIG_MMC is not set

#
# InfiniBand support
#
# CONFIG_INFINIBAND is not set

#
# SN Devices
#

#
# File systems
#
CONFIG_EXT2_FS=y
CONFIG_EXT2_FS_XATTR=y
CONFIG_EXT2_FS_POSIX_ACL=y
CONFIG_EXT2_FS_SECURITY=y
CONFIG_EXT2_FS_XIP=y
CONFIG_FS_XIP=y
CONFIG_EXT3_FS=y
CONFIG_EXT3_FS_XATTR=y
CONFIG_EXT3_FS_POSIX_ACL=y
CONFIG_EXT3_FS_SECURITY=y
CONFIG_JBD=y
# CONFIG_JBD_DEBUG is not set
CONFIG_FS_MBCACHE=y
CONFIG_REISERFS_FS=y
# CONFIG_REISERFS_CHECK is not set
# CONFIG_REISERFS_PROC_INFO is not set
# CONFIG_REISERFS_FS_XATTR is not set
# CONFIG_JFS_FS is not set
CONFIG_FS_POSIX_ACL=y
# CONFIG_XFS_FS is not set
CONFIG_MINIX_FS=y
# CONFIG_ROMFS_FS is not set
CONFIG_INOTIFY=y
# CONFIG_QUOTA is not set
CONFIG_DNOTIFY=y
# CONFIG_AUTOFS_FS is not set
CONFIG_AUTOFS4_FS=y
# CONFIG_FUSE_FS is not set

#
# CD-ROM/DVD Filesystems
#
CONFIG_ISO9660_FS=y
CONFIG_JOLIET=y
# CONFIG_ZISOFS is not set
CONFIG_UDF_FS=y
CONFIG_UDF_NLS=y

#
# DOS/FAT/NT Filesystems
#
CONFIG_FAT_FS=y
CONFIG_MSDOS_FS=y
CONFIG_VFAT_FS=y
CONFIG_FAT_DEFAULT_CODEPAGE=437
CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
# CONFIG_NTFS_FS is not set

#
# Pseudo filesystems
#
CONFIG_PROC_FS=y
CONFIG_SYSFS=y
CONFIG_TMPFS=y
# CONFIG_HUGETLBFS is not set
# CONFIG_HUGETLB_PAGE is not set
CONFIG_RAMFS=y
# CONFIG_RELAYFS_FS is not set

#
# Miscellaneous filesystems
#
# CONFIG_ADFS_FS is not set
# CONFIG_AFFS_FS is not set
# CONFIG_HFS_FS is not set
# CONFIG_HFSPLUS_FS is not set
# CONFIG_BEFS_FS is not set
# CONFIG_BFS_FS is not set
# CONFIG_EFS_FS is not set
# CONFIG_CRAMFS is not set
# CONFIG_SQUASHFS is not set
# CONFIG_VXFS_FS is not set
# CONFIG_HPFS_FS is not set
# CONFIG_QNX4FS_FS is not set
# CONFIG_SYSV_FS is not set
# CONFIG_UFS_FS is not set

#
# Network File Systems
#
CONFIG_NFS_FS=y
# CONFIG_NFS_V3 is not set
# CONFIG_NFS_V4 is not set
# CONFIG_NFS_DIRECTIO is not set
CONFIG_NFSD=y
# CONFIG_NFSD_V3 is not set
CONFIG_NFSD_TCP=y
CONFIG_LOCKD=y
CONFIG_EXPORTFS=y
CONFIG_NFS_COMMON=y
CONFIG_SUNRPC=y
# CONFIG_RPCSEC_GSS_KRB5 is not set
# CONFIG_RPCSEC_GSS_SPKM3 is not set
# CONFIG_SMB_FS is not set
# CONFIG_CIFS is not set
# CONFIG_NCP_FS is not set
# CONFIG_CODA_FS is not set
# CONFIG_AFS_FS is not set
# CONFIG_9P_FS is not set

#
# Partition Types
#
# CONFIG_PARTITION_ADVANCED is not set
CONFIG_MSDOS_PARTITION=y

#
# Native Language Support
#
CONFIG_NLS=y
CONFIG_NLS_DEFAULT="iso8859-1"
CONFIG_NLS_CODEPAGE_437=y
# CONFIG_NLS_CODEPAGE_737 is not set
# CONFIG_NLS_CODEPAGE_775 is not set
# CONFIG_NLS_CODEPAGE_850 is not set
# CONFIG_NLS_CODEPAGE_852 is not set
# CONFIG_NLS_CODEPAGE_855 is not set
# CONFIG_NLS_CODEPAGE_857 is not set
# CONFIG_NLS_CODEPAGE_860 is not set
# CONFIG_NLS_CODEPAGE_861 is not set
# CONFIG_NLS_CODEPAGE_862 is not set
# CONFIG_NLS_CODEPAGE_863 is not set
# CONFIG_NLS_CODEPAGE_864 is not set
# CONFIG_NLS_CODEPAGE_865 is not set
# CONFIG_NLS_CODEPAGE_866 is not set
# CONFIG_NLS_CODEPAGE_869 is not set
# CONFIG_NLS_CODEPAGE_936 is not set
# CONFIG_NLS_CODEPAGE_950 is not set
# CONFIG_NLS_CODEPAGE_932 is not set
# CONFIG_NLS_CODEPAGE_949 is not set
# CONFIG_NLS_CODEPAGE_874 is not set
# CONFIG_NLS_ISO8859_8 is not set
# CONFIG_NLS_CODEPAGE_1250 is not set
# CONFIG_NLS_CODEPAGE_1251 is not set
# CONFIG_NLS_ASCII is not set
CONFIG_NLS_ISO8859_1=y
# CONFIG_NLS_ISO8859_2 is not set
# CONFIG_NLS_ISO8859_3 is not set
# CONFIG_NLS_ISO8859_4 is not set
# CONFIG_NLS_ISO8859_5 is not set
# CONFIG_NLS_ISO8859_6 is not set
# CONFIG_NLS_ISO8859_7 is not set
# CONFIG_NLS_ISO8859_9 is not set
# CONFIG_NLS_ISO8859_13 is not set
# CONFIG_NLS_ISO8859_14 is not set
# CONFIG_NLS_ISO8859_15 is not set
# CONFIG_NLS_KOI8_R is not set
# CONFIG_NLS_KOI8_U is not set
# CONFIG_NLS_UTF8 is not set

#
# Profiling support
#
CONFIG_PROFILING=y
CONFIG_OPROFILE=y

#
# Kernel hacking
#
# CONFIG_PRINTK_TIME is not set
# CONFIG_DEBUG_KERNEL is not set
CONFIG_LOG_BUF_SHIFT=15
CONFIG_DEBUG_BUGVERBOSE=y
CONFIG_EARLY_PRINTK=y
CONFIG_X86_FIND_SMP_CONFIG=y
CONFIG_X86_MPPARSE=y

#
# Security options
#

#
# PaX
#
CONFIG_PAX=y

#
# PaX Control
#
CONFIG_PAX_SOFTMODE=y
CONFIG_PAX_EI_PAX=y
CONFIG_PAX_PT_PAX_FLAGS=y
# CONFIG_PAX_NO_ACL_FLAGS is not set
CONFIG_PAX_HAVE_ACL_FLAGS=y
# CONFIG_PAX_HOOK_ACL_FLAGS is not set

#
# Non-executable pages
#
CONFIG_PAX_NOEXEC=y
CONFIG_PAX_PAGEEXEC=y
CONFIG_PAX_SEGMEXEC=y
# CONFIG_PAX_DEFAULT_PAGEEXEC is not set
CONFIG_PAX_DEFAULT_SEGMEXEC=y
CONFIG_PAX_EMUTRAMP=y
CONFIG_PAX_MPROTECT=y
CONFIG_PAX_NOELFRELOCS=y
CONFIG_PAX_KERNEXEC=y

#
# Address Space Layout Randomization
#
CONFIG_PAX_ASLR=y
CONFIG_PAX_RANDKSTACK=y
CONFIG_PAX_RANDUSTACK=y
CONFIG_PAX_RANDMMAP=y
CONFIG_PAX_NOVSYSCALL=y

#
# Grsecurity
#
CONFIG_GRKERNSEC=y
# CONFIG_GRKERNSEC_LOW is not set
# CONFIG_GRKERNSEC_MEDIUM is not set
# CONFIG_GRKERNSEC_HIGH is not set
CONFIG_GRKERNSEC_CUSTOM=y

#
# Address Space Protection
#
CONFIG_GRKERNSEC_KMEM=y
CONFIG_GRKERNSEC_IO=y
CONFIG_GRKERNSEC_PROC_MEMMAP=y
CONFIG_GRKERNSEC_BRUTE=y
CONFIG_GRKERNSEC_MODSTOP=y
CONFIG_GRKERNSEC_HIDESYM=y

#
# Role Based Access Control Options
#
# CONFIG_GRKERNSEC_ACL_HIDEKERN is not set
CONFIG_GRKERNSEC_ACL_MAXTRIES=3
CONFIG_GRKERNSEC_ACL_TIMEOUT=30

#
# Filesystem Protections
#
CONFIG_GRKERNSEC_PROC=y
CONFIG_GRKERNSEC_PROC_USER=y
CONFIG_GRKERNSEC_PROC_ADD=y
CONFIG_GRKERNSEC_LINK=y
CONFIG_GRKERNSEC_FIFO=y
CONFIG_GRKERNSEC_CHROOT=y
CONFIG_GRKERNSEC_CHROOT_MOUNT=y
CONFIG_GRKERNSEC_CHROOT_DOUBLE=y
CONFIG_GRKERNSEC_CHROOT_PIVOT=y
CONFIG_GRKERNSEC_CHROOT_CHDIR=y
CONFIG_GRKERNSEC_CHROOT_CHMOD=y
CONFIG_GRKERNSEC_CHROOT_FCHDIR=y
CONFIG_GRKERNSEC_CHROOT_MKNOD=y
CONFIG_GRKERNSEC_CHROOT_SHMAT=y
CONFIG_GRKERNSEC_CHROOT_UNIX=y
CONFIG_GRKERNSEC_CHROOT_FINDTASK=y
CONFIG_GRKERNSEC_CHROOT_NICE=y
CONFIG_GRKERNSEC_CHROOT_SYSCTL=y
CONFIG_GRKERNSEC_CHROOT_CAPS=y

#
# Kernel Auditing
#
# CONFIG_GRKERNSEC_AUDIT_GROUP is not set
# CONFIG_GRKERNSEC_EXECLOG is not set
# CONFIG_GRKERNSEC_RESLOG is not set
# CONFIG_GRKERNSEC_CHROOT_EXECLOG is not set
# CONFIG_GRKERNSEC_AUDIT_CHDIR is not set
# CONFIG_GRKERNSEC_AUDIT_MOUNT is not set
# CONFIG_GRKERNSEC_AUDIT_IPC is not set
# CONFIG_GRKERNSEC_SIGNAL is not set
CONFIG_GRKERNSEC_FORKFAIL=y
# CONFIG_GRKERNSEC_TIME is not set
# CONFIG_GRKERNSEC_PROC_IPADDR is not set
# CONFIG_GRKERNSEC_AUDIT_TEXTREL is not set

#
# Executable Protections
#
CONFIG_GRKERNSEC_EXECVE=y
CONFIG_GRKERNSEC_SHM=y
CONFIG_GRKERNSEC_DMESG=y
CONFIG_GRKERNSEC_RANDPID=y
# CONFIG_GRKERNSEC_TPE is not set

#
# Network Protections
#
CONFIG_GRKERNSEC_RANDNET=y
CONFIG_GRKERNSEC_RANDSRC=y
CONFIG_GRKERNSEC_SOCKET=y
# CONFIG_GRKERNSEC_SOCKET_ALL is not set
# CONFIG_GRKERNSEC_SOCKET_CLIENT is not set
# CONFIG_GRKERNSEC_SOCKET_SERVER is not set

#
# Sysctl support
#
CONFIG_GRKERNSEC_SYSCTL=y
CONFIG_GRKERNSEC_SYSCTL_ON=y

#
# Logging Options
#
CONFIG_GRKERNSEC_FLOODTIME=10
CONFIG_GRKERNSEC_FLOODBURST=4
# CONFIG_KEYS is not set
CONFIG_SECURITY=y
# CONFIG_SECURITY_NETWORK is not set
# CONFIG_SECURITY_CAPABILITIES is not set
# CONFIG_SECURITY_ROOTPLUG is not set
# CONFIG_SECURITY_SECLVL is not set
# CONFIG_SECURITY_SELINUX is not set

#
# Cryptographic options
#
CONFIG_CRYPTO=y
CONFIG_CRYPTO_HMAC=y
CONFIG_CRYPTO_NULL=m
CONFIG_CRYPTO_MD4=m
CONFIG_CRYPTO_MD5=m
CONFIG_CRYPTO_SHA1=m
CONFIG_CRYPTO_SHA256=y
CONFIG_CRYPTO_SHA512=m
CONFIG_CRYPTO_WP512=m
CONFIG_CRYPTO_TGR192=m
CONFIG_CRYPTO_DES=m
CONFIG_CRYPTO_BLOWFISH=m
CONFIG_CRYPTO_TWOFISH=m
CONFIG_CRYPTO_SERPENT=m
CONFIG_CRYPTO_AES_586=m
CONFIG_CRYPTO_CAST5=m
CONFIG_CRYPTO_CAST6=m
CONFIG_CRYPTO_TEA=m
CONFIG_CRYPTO_ARC4=m
CONFIG_CRYPTO_KHAZAD=m
CONFIG_CRYPTO_ANUBIS=m
CONFIG_CRYPTO_DEFLATE=m
CONFIG_CRYPTO_MICHAEL_MIC=m
CONFIG_CRYPTO_CRC32C=m
# CONFIG_CRYPTO_TEST is not set

#
# Hardware crypto devices
#
CONFIG_CRYPTO_DEV_PADLOCK=m
CONFIG_CRYPTO_DEV_PADLOCK_AES=y

#
# Library routines
#
CONFIG_CRC_CCITT=m
CONFIG_CRC16=m
CONFIG_CRC32=y
CONFIG_LIBCRC32C=m
CONFIG_ZLIB_INFLATE=m
CONFIG_ZLIB_DEFLATE=m
CONFIG_TEXTSEARCH=y
CONFIG_TEXTSEARCH_KMP=m
CONFIG_TEXTSEARCH_BM=m
CONFIG_TEXTSEARCH_FSM=m
CONFIG_GENERIC_HARDIRQS=y
CONFIG_GENERIC_IRQ_PROBE=y
CONFIG_GENERIC_PENDING_IRQ=y
CONFIG_X86_SMP=y
CONFIG_X86_HT=y
CONFIG_X86_BIOS_REBOOT=y
CONFIG_X86_TRAMPOLINE=y
CONFIG_PC=y
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.2 (GNU/Linux)

iD8DBQFD6ri9WdkW/RJDBSIRAttMAKDJ5rGAXdP0Av6ggO3OBhLiM/368ACff32h
PT2taa++/Gjtg7OK+0TvLPk=
=wCKS
-----END PGP SIGNATURE-----

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060209054011</emailId><senderName>Boyd Waters</senderName><senderEmail>bwaters@nrao.edu</senderEmail><timestampReceived>2006-02-09 05:40:11-0400</timestampReceived><subject>Re: hardened kernel and loop-aes</subject><body>

On a Gentoo system yesterday, after installing loop-aes-3.1c I  
received the warning that the loop.ko module has an executable stack.

However, I did not receive that message just now when re-installing.




On Feb 8, 2006, at 8:36 PM, Venkat Manakkal wrote:

&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt;
&gt; Hi Jari,
&gt;
&gt; I'm having trouble getting the latest hardened kernel and loop-aes  
&gt; happy with
&gt; each other, I've used older hardened kernels before. I suspect it  
&gt; is over
&gt; ambitious lockdown of PaX and GrSecurity.
&gt;
&gt;
&gt; # head -c 15 /dev/urandom | uuencode -m - | head -n 2 | tail -n 1 \
&gt; |         | losetup -p 0 -e AES128 /dev/loop3 /dev/md/1
&gt; Segmentation fault
&gt;
&gt; uname -a output:
&gt;
&gt; Linux kbw 2.6.14-hardened-r5 #4 SMP Thu Feb 9 11:27:10 GMT 2006  
&gt; i686 Intel(R)
&gt; Pentium(R) 4 CPU 3.00GHz GenuineIntel GNU/Linux


["smime.p7s" (application/pkcs7-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060209131753</emailId><senderName>Venkat Manakkal</senderName><senderEmail>venkat@rayservers.com</senderEmail><timestampReceived>2006-02-09 13:17:53-0400</timestampReceived><subject>Re: hardened kernel and loop-aes</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 02/09/2006 12:40 AM, Boyd Waters wrote:
| On a Gentoo system yesterday, after installing loop-aes-3.1c I  received
| the warning that the loop.ko module has an executable stack.

I think that was the issue after all (PaX was set to enforce non executable
stack in the kernel), I now have that kernel working - I had another .config
on another machine with the hardened kernel that worked out, and so I used
that .config, did a make oldconfig, set up the hardware, and the diff between
the .config I posted and one that is now working is below:

Cheers,

- ---Venkat.

4c4
&lt; # Thu Feb  9 11:19:00 2006
- ---
| # Thu Feb  9 20:19:24 2006
121c121
&lt; # CONFIG_PREEMPT_BKL is not set
- ---
| CONFIG_PREEMPT_BKL=y
140c140
&lt; CONFIG_DCDBAS=m
- ---
| # CONFIG_DCDBAS is not set
177c177
&lt; CONFIG_ACPI_BATTERY=y
- ---
| # CONFIG_ACPI_BATTERY is not set
179,180c179,180
&lt; CONFIG_ACPI_VIDEO=y
&lt; # CONFIG_ACPI_HOTKEY is not set
- ---
| CONFIG_ACPI_VIDEO=m
| CONFIG_ACPI_HOTKEY=m
185c185
&lt; CONFIG_ACPI_IBM=y
- ---
| # CONFIG_ACPI_IBM is not set
228,229c228,229
&lt; # CONFIG_X86_SPEEDSTEP_SMI is not set
&lt; # CONFIG_X86_P4_CLOCKMOD is not set
- ---
| CONFIG_X86_SPEEDSTEP_SMI=y
| CONFIG_X86_P4_CLOCKMOD=y
251c251
&lt; # CONFIG_PCIEPORTBUS is not set
- ---
| CONFIG_PCIEPORTBUS=y
288a289,290
| CONFIG_XFRM=y
| # CONFIG_XFRM_USER is not set
307,308c309
&lt; CONFIG_NET_IPGRE=m
&lt; CONFIG_NET_IPGRE_BROADCAST=y
- ---
| # CONFIG_NET_IPGRE is not set
315c316
&lt; # CONFIG_INET_TUNNEL is not set
- ---
| CONFIG_INET_TUNNEL=y
328c329,331
&lt; # CONFIG_NETFILTER_NETLINK is not set
- ---
| CONFIG_NETFILTER_NETLINK=m
| CONFIG_NETFILTER_NETLINK_QUEUE=m
| CONFIG_NETFILTER_NETLINK_LOG=m
343c346
&lt; CONFIG_IP_NF_PPTP=m
- ---
| # CONFIG_IP_NF_PPTP is not set
360c363
&lt; # CONFIG_IP_NF_MATCH_STEALTH is not set
- ---
| CONFIG_IP_NF_MATCH_STEALTH=m
368c371
&lt; CONFIG_IP_NF_MATCH_DCCP=m
- ---
| # CONFIG_IP_NF_MATCH_DCCP is not set
386c389
&lt; # CONFIG_IP_NF_NAT_SNMP_BASIC is not set
- ---
| CONFIG_IP_NF_NAT_SNMP_BASIC=m
391d393
&lt; CONFIG_IP_NF_NAT_PPTP=m
399,400c401,402
&lt; # CONFIG_IP_NF_TARGET_CONNMARK is not set
&lt; # CONFIG_IP_NF_TARGET_CLUSTERIP is not set
- ---
| CONFIG_IP_NF_TARGET_CONNMARK=m
| CONFIG_IP_NF_TARGET_CLUSTERIP=m
403,405c405,407
&lt; CONFIG_IP_NF_ARPTABLES=y
&lt; CONFIG_IP_NF_ARPFILTER=y
&lt; CONFIG_IP_NF_ARP_MANGLE=y
- ---
| CONFIG_IP_NF_ARPTABLES=m
| CONFIG_IP_NF_ARPFILTER=m
| CONFIG_IP_NF_ARP_MANGLE=m
451,454c453,459
&lt; # CONFIG_NET_CLS_FW is not set
&lt; # CONFIG_NET_CLS_U32 is not set
&lt; # CONFIG_NET_CLS_RSVP is not set
&lt; # CONFIG_NET_CLS_RSVP6 is not set
- ---
| CONFIG_NET_CLS_FW=m
| CONFIG_NET_CLS_U32=m
| CONFIG_CLS_U32_PERF=y
| CONFIG_NET_CLS_IND=y
| CONFIG_CLS_U32_MARK=y
| CONFIG_NET_CLS_RSVP=m
| CONFIG_NET_CLS_RSVP6=m
456,457c461,468
&lt; # CONFIG_NET_CLS_ACT is not set
&lt; # CONFIG_NET_CLS_POLICE is not set
- ---
| CONFIG_NET_CLS_ACT=y
| CONFIG_NET_ACT_POLICE=m
| CONFIG_NET_ACT_GACT=m
| CONFIG_GACT_PROB=y
| CONFIG_NET_ACT_MIRRED=m
| CONFIG_NET_ACT_IPT=m
| CONFIG_NET_ACT_PEDIT=m
| # CONFIG_NET_ACT_SIMP is not set
492,498c503
&lt; CONFIG_PARPORT=y
&lt; CONFIG_PARPORT_PC=y
&lt; # CONFIG_PARPORT_SERIAL is not set
&lt; # CONFIG_PARPORT_PC_FIFO is not set
&lt; # CONFIG_PARPORT_PC_SUPERIO is not set
&lt; # CONFIG_PARPORT_GSC is not set
&lt; # CONFIG_PARPORT_1284 is not set
- ---
| # CONFIG_PARPORT is not set
509c514
&lt; # CONFIG_ISAPNP is not set
- ---
| CONFIG_ISAPNP=y
518d522
&lt; # CONFIG_PARIDE is not set
528c532
&lt; # CONFIG_BLK_DEV_RAM is not set
- ---
| CONFIG_BLK_DEV_RAM=y
529a534,535
| CONFIG_BLK_DEV_RAM_SIZE=4096
| CONFIG_BLK_DEV_INITRD=y
619c625
&lt; # CONFIG_CHR_DEV_ST is not set
- ---
| CONFIG_CHR_DEV_ST=m
635c641
&lt; # CONFIG_SCSI_SPI_ATTRS is not set
- ---
| CONFIG_SCSI_SPI_ATTRS=y
684,685d689
&lt; # CONFIG_SCSI_PPA is not set
&lt; # CONFIG_SCSI_IMM is not set
688,690c692
&lt; CONFIG_SCSI_IPR=m
&lt; # CONFIG_SCSI_IPR_TRACE is not set
&lt; # CONFIG_SCSI_IPR_DUMP is not set
- ---
| # CONFIG_SCSI_IPR is not set
737,738c739,740
&lt; CONFIG_DM_MULTIPATH_EMC=y
&lt; CONFIG_BLK_DEV_DM_BBR=y
- ---
| # CONFIG_DM_MULTIPATH_EMC is not set
| # CONFIG_BLK_DEV_DM_BBR is not set
852d853
&lt; # CONFIG_NET_POCKET is not set
894d894
&lt; # CONFIG_PLIP is not set
957d956
&lt; # CONFIG_SERIO_PARKBD is not set
988,991d986
&lt; CONFIG_PRINTER=y
&lt; # CONFIG_LP_CONSOLE is not set
&lt; # CONFIG_PPDEV is not set
&lt; # CONFIG_TIPAR is not set
1002c997
&lt; # CONFIG_HW_RANDOM is not set
- ---
| CONFIG_HW_RANDOM=y
1198d1192
&lt; # CONFIG_USB_USS720 is not set
1250,1254c1244,1245
&lt; CONFIG_EXT2_FS_XATTR=y
&lt; CONFIG_EXT2_FS_POSIX_ACL=y
&lt; CONFIG_EXT2_FS_SECURITY=y
&lt; CONFIG_EXT2_FS_XIP=y
&lt; CONFIG_FS_XIP=y
- ---
| # CONFIG_EXT2_FS_XATTR is not set
| # CONFIG_EXT2_FS_XIP is not set
1264,1265c1255,1257
&lt; # CONFIG_REISERFS_PROC_INFO is not set
&lt; # CONFIG_REISERFS_FS_XATTR is not set
- ---
| CONFIG_REISERFS_PROC_INFO=y
| CONFIG_REISERFS_FS_XATTR=y
| CONFIG_REISERFS_FS_POSIX_ACL=y
1283c1275,1276
&lt; # CONFIG_ZISOFS is not set
- ---
| CONFIG_ZISOFS=y
| CONFIG_ZISOFS_FS=y
1290,1294c1283,1284
&lt; CONFIG_FAT_FS=y
&lt; CONFIG_MSDOS_FS=y
&lt; CONFIG_VFAT_FS=y
&lt; CONFIG_FAT_DEFAULT_CODEPAGE=437
&lt; CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
- ---
| # CONFIG_MSDOS_FS is not set
| # CONFIG_VFAT_FS is not set
1329,1341c1319,1320
&lt; CONFIG_NFS_FS=y
&lt; # CONFIG_NFS_V3 is not set
&lt; # CONFIG_NFS_V4 is not set
&lt; # CONFIG_NFS_DIRECTIO is not set
&lt; CONFIG_NFSD=y
&lt; # CONFIG_NFSD_V3 is not set
&lt; CONFIG_NFSD_TCP=y
&lt; CONFIG_LOCKD=y
&lt; CONFIG_EXPORTFS=y
&lt; CONFIG_NFS_COMMON=y
&lt; CONFIG_SUNRPC=y
&lt; # CONFIG_RPCSEC_GSS_KRB5 is not set
&lt; # CONFIG_RPCSEC_GSS_SPKM3 is not set
- ---
| # CONFIG_NFS_FS is not set
| # CONFIG_NFSD is not set
1429,1430c1408,1409
&lt; CONFIG_PAX_EI_PAX=y
&lt; CONFIG_PAX_PT_PAX_FLAGS=y
- ---
| # CONFIG_PAX_EI_PAX is not set
| # CONFIG_PAX_PT_PAX_FLAGS is not set
1445,1446c1424,1425
&lt; CONFIG_PAX_NOELFRELOCS=y
&lt; CONFIG_PAX_KERNEXEC=y
- ---
| # CONFIG_PAX_NOELFRELOCS is not set
| # CONFIG_PAX_KERNEXEC is not set
1471c1450
&lt; CONFIG_GRKERNSEC_PROC_MEMMAP=y
- ---
| # CONFIG_GRKERNSEC_PROC_MEMMAP is not set
1473c1452
&lt; CONFIG_GRKERNSEC_MODSTOP=y
- ---
| # CONFIG_GRKERNSEC_MODSTOP is not set
1479c1458
&lt; # CONFIG_GRKERNSEC_ACL_HIDEKERN is not set
- ---
| CONFIG_GRKERNSEC_ACL_HIDEKERN=y
1518,1519c1497,1498
&lt; # CONFIG_GRKERNSEC_TIME is not set
&lt; # CONFIG_GRKERNSEC_PROC_IPADDR is not set
- ---
| CONFIG_GRKERNSEC_TIME=y
| CONFIG_GRKERNSEC_PROC_IPADDR=y
1525c1504
&lt; CONFIG_GRKERNSEC_EXECVE=y
- ---
| # CONFIG_GRKERNSEC_EXECVE is not set
1536,1539c1515
&lt; CONFIG_GRKERNSEC_SOCKET=y
&lt; # CONFIG_GRKERNSEC_SOCKET_ALL is not set
&lt; # CONFIG_GRKERNSEC_SOCKET_CLIENT is not set
&lt; # CONFIG_GRKERNSEC_SOCKET_SERVER is not set
- ---
| # CONFIG_GRKERNSEC_SOCKET is not set
1552c1528,1529
&lt; # CONFIG_KEYS is not set
- ---
| CONFIG_KEYS=y
| CONFIG_KEYS_DEBUG_PROC_KEYS=y
1555c1532
&lt; # CONFIG_SECURITY_CAPABILITIES is not set
- ---
| CONFIG_SECURITY_CAPABILITIES=y
1565c1542
&lt; CONFIG_CRYPTO_NULL=m
- ---
| # CONFIG_CRYPTO_NULL is not set
1592,1593c1569
&lt; CONFIG_CRYPTO_DEV_PADLOCK=m
&lt; CONFIG_CRYPTO_DEV_PADLOCK_AES=y
- ---
| # CONFIG_CRYPTO_DEV_PADLOCK is not set
1599c1575
&lt; CONFIG_CRC16=m
- ---
| # CONFIG_CRC16 is not set
1602c1578
&lt; CONFIG_ZLIB_INFLATE=m
- ---
| CONFIG_ZLIB_INFLATE=y

- --
http://rayservers.com/                                            607-546-7300
PGP/GPG:                            https://rayservers.com/keys/0x12430522.asc
Skype: rayservers       GDCA: http://www.gdcaonline.org/members/rayservers.htm
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.2 (GNU/Linux)

iD8DBQFD60D/WdkW/RJDBSIRAlKBAJ0ZBFKesVzLJ3KoNiqEGf5rOWiuLgCeOP8/
W+IShdL2dZ2WvW4qtX/HaDc=
=uKGj
-----END PGP SIGNATURE-----

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060220203446</emailId><senderName>Master of Reality</senderName><senderEmail>funkville@gmail.com</senderEmail><timestampReceived>2006-02-20 20:34:46-0400</timestampReceived><subject>Re: Encrypting Filesystems</subject><body>


I believe using the loopback device is deprecated... the new kernel uses
device mapper to encrypt the filesystem.
--
View this message in context: http://www.nabble.com/Encrypting-Filesystems-t1155912.html#a3038074
Sent from the Linux Crypto forum at Nabble.com.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060221111739</emailId><senderName>Phil H</senderName><senderEmail>philtickle200@yahoo.com</senderEmail><timestampReceived>2006-02-21 11:17:39-0400</timestampReceived><subject>Re: Encrypting Filesystems</subject><body>

Yes, IMHO you are missing something very important, and so do a lot of other linux \
journalists unfortunately.  
  I'm not an expert, so a flame war with me will useless and not responded to \
(*note*), however this is what I think I've gleaned in all my googling:  
  Loop-aes is still regarded as by far the best civilian partition encryption scheme \
available for linux. Developmentally and in terms of bug fixes is is way ahead of \
dmcrypt.  
  Loop-aes developer Jari Rassu has been at pains to point this out - I strongly \
suggest you search this list for his comments on dmcrypt and truecrypt.   Truecrypt, \
which is also device-mapper based, only very recently attempted to fix a major \
security hole which Jari had been warning people about for some time.  
  The rise of dmcrypt is perhaps largely because Fedora has decided it's the thing to \
go with.  Why?  Perhaps because it's seen to be "easier to use", because the loop-aes \
readme insists that a kernel recompile is necessary =&gt; "no newbies please".   However \
the debian packages for loop-aes do not require a kernel recompile unless you want to \
encrypt the root filesystem.  (But I overreach my level of expertise.  The person to \
talk to here might be Max, the maintainer of the debian loop-aes packages. He is a \
regular on this list).  If you look at some of the "serious" security-oriented \
livecds ie knoppix-STD and INSERT, you'll see they ship with recent versions of \
loop-aes - not dmcrypt.  
  I don't want to disparage any efforts in this direction and I really hope dmcrypt \
and truecrypt continue to improve, but if you look at the dmcrypt wiki the project \
doesn't inspire confidence in me.  I mean, loop-aes has a venerable history.  Also, \
truecrypt cannot yet make containers under linux - it can only mount them.  
  Recently I was horrified when I read an article on root filesystem encryption on \
laptops in Linux Journal by an "expert" who, being  a Fedora user, went with dmcrypt. \
The horrifying thing was this: his instructions used a *PLAIN TEXT single aes256 \
keyfile* - NOT EVEN a gpg-encrypted, multiline keychain.  So your usb stick contains \
the key in plain text.  An attacker gets hold of your usb stick, and game over.   Yet \
it is a simple matter to use a gpg-encrypted key with dmcrypt - I've done it just to \
prove this.  
  I don't see how cryptLUKS or whatever it's called is any easier to use than \
loop-aes, once loop-aes is set up.  In fact I find it confusing to use.  
  Just why has what is often regarded as an inferior encryption scheme been pushed?  \
That in itself would make an interesting article.  
  
  
  
 Master of Reality &lt;funkville@gmail.com&gt; wrote:  
I believe using the loopback device is deprecated... the new kernel uses
device mapper to encrypt the filesystem.
--
View this message in context: \
http://www.nabble.com/Encrypting-Filesystems-t1155912.html#a3038074 Sent from the \
Linux Crypto forum at Nabble.com.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

 
 

Master of Reality &lt;funkville@gmail.com&gt; wrote: 
I believe using the loopback device is deprecated... the new kernel uses
device mapper to encrypt the filesystem.
--
View this message in context: \
http://www.nabble.com/Encrypting-Filesystems-t1155912.html#a3038074 Sent from the \
Linux Crypto forum at Nabble.com.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



			
---------------------------------
 Yahoo! Mail
 Use Photomail to share photos without annoying attachments.


[Attachment #3 (text/html)]

Yes, IMHO you are missing something very important, and so do a lot of other linux \
journalists unfortunately.&lt;br&gt;  &lt;br&gt;  I'm not an expert, so a flame war with me will \
useless and not responded to (*note*), however this is what I think I've gleaned in \
all my googling:&lt;br&gt;  &lt;br&gt;  Loop-aes is still regarded as by far the best civilian \
partition encryption scheme available for linux. Developmentally and in terms of bug \
fixes is is way ahead of dmcrypt.&lt;br&gt;  &lt;br&gt;  Loop-aes developer Jari Rassu has been \
at pains to point this out - I strongly suggest you search this list for his comments \
on dmcrypt and truecrypt.   Truecrypt, which is also device-mapper based, only \
very recently attempted to fix a major security hole which Jari had been warning \
people about for some time.&lt;br&gt;  &lt;br&gt;  The rise of dmcrypt is perhaps largely because \
Fedora has decided it's the thing to go with.  Why?  Perhaps because it's \
seen to be "easier to use", because the loop-aes readme insists that a  kernel \
recompile is necessary =&gt; "no newbies please".   However the debian packages \
for loop-aes do not require a kernel recompile unless you want to encrypt the root \
filesystem.  (But I overreach my level of expertise.  The person to talk to \
here might be Max, the maintainer of the debian loop-aes packages. He is a regular on \
this list).  If you look at some of the "serious" security-oriented livecds ie \
knoppix-STD and INSERT, you'll see they ship with recent versions of loop-aes - not \
dmcrypt.&lt;br&gt;  &lt;br&gt;  I don't want to disparage any efforts in this direction and I \
really hope dmcrypt and truecrypt continue to improve, but if you look at the dmcrypt \
wiki the project doesn't inspire confidence in me.  I mean, loop-aes has a \
venerable history.  Also, truecrypt cannot yet make containers under linux - it \
can only mount them.&lt;br&gt;  &lt;br&gt;  Recently I was horrified when I read an article on \
root filesystem encryption on laptops in Linux Journal by an  "expert" who, \
being  a Fedora user, went with dmcrypt.  The horrifying thing was this: \
his instructions used a *PLAIN TEXT single aes256 keyfile* - NOT EVEN a \
gpg-encrypted, multiline keychain.  So your usb stick contains the key in plain \
text.  An attacker gets hold of your usb stick, and game over.   Yet it is \
a simple matter to use a gpg-encrypted key with dmcrypt - I've done it just to prove \
this.&lt;br&gt;  &lt;br&gt;  I don't see how cryptLUKS or whatever it's called is any easier to \
use than loop-aes, once loop-aes is set up.  In fact I find it confusing to \
use.&lt;br&gt;  &lt;br&gt;  Just why has what is often regarded as an inferior encryption scheme \
been pushed?  That in itself would make an interesting article.&lt;br&gt;  &lt;br&gt;  &lt;br&gt;  \
&lt;br&gt;  &lt;br&gt; &lt;b&gt;&lt;i&gt;Master of Reality &lt;funkville@gmail.com&gt;&lt;/i&gt;&lt;/b&gt; wrote: \
&lt;blockquote class="replbq" style="border-left: 2px solid rgb(16, 16, 255); \
margin-left: 5px; padding-left: 5px;"&gt; &lt;br&gt;I believe using the loopback device is  \
deprecated... the new kernel uses&lt;br&gt;device mapper to encrypt the \
filesystem.&lt;br&gt;--&lt;br&gt;View this message in context: \
http://www.nabble.com/Encrypting-Filesystems-t1155912.html#a3038074&lt;br&gt;Sent from the \
Linux Crypto forum at Nabble.com.&lt;br&gt;&lt;br&gt;&lt;br&gt;-&lt;br&gt;Linux-crypto:  cryptography in and \
on the Linux system&lt;br&gt;Archive:       \
http://mail.nl.linux.org/linux-crypto/&lt;br&gt;&lt;br&gt;&lt;/blockquote&gt; &lt;br&gt; &lt;br&gt;&lt;br&gt;&lt;b&gt;&lt;i&gt;Master \
of Reality &lt;funkville@gmail.com&gt;&lt;/i&gt;&lt;/b&gt; wrote:&lt;blockquote class="replbq" \
style="border-left: 2px solid rgb(16, 16, 255); margin-left: 5px; padding-left: \
5px;"&gt; &lt;br&gt;I believe using the loopback device is deprecated... the new kernel \
uses&lt;br&gt;device mapper to encrypt the filesystem.&lt;br&gt;--&lt;br&gt;View this message in \
context: http://www.nabble.com/Encrypting-Filesystems-t1155912.html#a3038074&lt;br&gt;Sent \
from the Linux Crypto forum at Nabble.com.&lt;br&gt;&lt;br&gt;&lt;br&gt;-&lt;br&gt;Linux-crypto:  \
cryptography in and on the Linux system&lt;br&gt;Archive:        \
http://mail.nl.linux.org/linux-crypto/&lt;br&gt;&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;p&gt;  
		&lt;hr size=1&gt; Yahoo! Mail&lt;br&gt; 
&lt;a href="http://us.rd.yahoo.com/mail_us/taglines/pmall2/*http://photomail.mail.yahoo.com"&gt;Use \
Photomail&lt;/a&gt; to share photos without annoying attachments.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060222144131</emailId><senderName>SONIA ESPERANZA MORENO SUAREZ</senderName><senderEmail>soniaemorenos@yahoo.com.ar</senderEmail><timestampReceived>2006-02-22 14:41:31-0400</timestampReceived><subject>Ingeniera de Sistemas DBA</subject><body>


&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;
	
&lt;CENTER&gt;
&lt;TABLE class=tdx cellSpacing=0 cellPadding=0 width=600 border=0&gt;
  &lt;TBODY&gt;
  &lt;TR&gt;
    &lt;TD class=tdx &gt;
		&lt;table width='100%'&gt;&lt;tr&gt;&lt;td&gt;&lt;img \
src='http://www.autoscolombia.com/autos/aviso/sonia.jpg'&gt;&lt;/td&gt;&lt;td align=right&gt;  &lt;font \
color='#000066'&gt;  &lt;B&gt;SONIA ESPERANZA MORENO SUAREZ&lt;/B&gt;&lt;BR&gt;Calle 
      145 No. 41-73 Apto. 403&lt;BR&gt;Teléfonos: 6278558, 6157919&lt;BR&gt;Celular: 3106980121 
      &lt;BR&gt;Fecha de Nacimiento: Diciembre 29 de 1974 (Tunja - 
      Boyaca)
			&lt;Br&gt;E-mail: soniaemorenos@yahoo.com.ar
      &lt;Br&gt;Soniaemorenos@hotmail.com      
						&lt;BR&gt;&lt;BR&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
						
						&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR bgColor=black&gt;
	&lt;TR bgcolor=silver&gt;
    &lt;TD class=tdx&gt;&lt;FONT color=white&gt;
      &lt;CENTER&gt;&lt;B&gt;PERFIL PROFESIONAL&lt;/B&gt;&lt;/CENTER&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD class=tdx&gt;&lt;BR&gt;
      &lt;DIV align=justify&gt;
			&lt;LI&gt; Liderazgo en Análisis y Diseño  de  Sistemas.
			&lt;LI&gt; Automatización, evaluación, seguimiento y control de métodos, procesos y \
procedimientos.  &lt;LI&gt; Experiencia en análisis, Diseño e implementación de sistemas de \
información.  &lt;lI&gt; Manejo de sistemas  Dos, Windows  - 95 - 98 - 2000 -2003 ,  WinNT \
4.0  &lt;li&gt; conocimientos básicos de Linux
			&lt;LI&gt; Programación: VISUAL BASIC 6.0, SQL SERVER 7.0 ó 2000, Access 97, 2000
			&lt;LI&gt; Administracion Bases de datos ORACLE   8i,9i
			&lt;LI&gt; Conocimientos básicos de Autocad 2000.
			&lt;LI&gt; Metodología de capacitación, inducción  y apoyo.
			&lt;LI&gt; Excelentes relaciones interpersonales&lt;/DIV&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR bgColor=black&gt;
    &lt;TD class=tdx&gt;&lt;FONT color=white&gt;
      &lt;CENTER&gt;&lt;B&gt;ESTUDIOS REALIZADOS&lt;/B&gt;&lt;/CENTER&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD class=tdx&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width=120&gt;&lt;B&gt;PREGADO&lt;/B&gt;&lt;/TD&gt;
          &lt;TD&gt;INGENIERIA DE SISTEMAS&lt;BR&gt;Fundacion 
            universitaria de Boyaca - Año \
1998&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;  
		&lt;TD class=tdx&gt;
			&lt;TABLE width='100%'&gt;
				&lt;tbody&gt;
				&lt;TR&gt;
					&lt;TD width=120&gt;&lt;B&gt;POSGRADO&lt;/B&gt;&lt;/TD&gt;	
					&lt;TD&gt;ESPECIALIZACION REDES DE DATOS&lt;BR&gt;Universidad 
            Santo Tomas - Año 2003&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;
						&lt;TD&gt;Matricula Profesional&lt;BR&gt;15255754663BYC
  &lt;TR&gt;
    &lt;TD class=tdx&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width=120&gt;&lt;B&gt;CURSOS Y SEMINARIOS&lt;/B&gt;&lt;/TD&gt;
          &lt;TD&gt;
            &lt;LI&gt;Seminario Taller 'UNÍX UNA Visión GLOBAL' - 
            Fundación Universitaria de Boyacá - 1999
            &lt;LI&gt;'	Seminario Think  9i for developers - 
						Centro de Convenciones Gonzalo Jiménez de Quesada -Febrero 2002
            &lt;LI&gt;'	V Jornada de actualización en nuevas tecnologías 
						para redes y telecomunicaciones. - 
						Fundacion Universitaria de Boyaca - Abril 2002 
            &lt;LI&gt;'	Curso de Autocad 2000i
						Fundacion Universitaria de Boyaca - Agosto 2002 
            &lt;LI&gt;Fundamento Oracle 9i
						Aptech - Agosto 2005
						&lt;LI&gt; 'Visual Basic .NET
						Aptech - Octubre 2005.&lt;/LI&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR bgColor=silver&gt;
    &lt;TD class=tdx&gt;&lt;FONT color=white&gt;
      &lt;CENTER&gt;&lt;B&gt;EXPERIENCIA LABORAL&lt;/B&gt;&lt;/CENTER&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD class=tdx&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;ICETEX &lt;/B&gt;&lt;BR&gt;Instituto Colombiano para estudios 
            tecnicos en el exterior ( Bogota D.C. )&lt;BR&gt;&lt;BR&gt;ADMINISTRADOR 
            BASE DE DATOS ( JULIO 2004 -FEBRERO 2005 )&lt;BR&gt;&lt;BR&gt;Administracion Base de 
            datos, Oracle 8i, 9i, SQL SERVER 2000, Exhange 2003, 
            Administracion Sistemas operativos :  Solaris 2.6, 9, Unix, Windows 2000 \
advanced  Server, Windows 2003 server&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;ECA ICC S.A.&lt;/B&gt;&lt;BR&gt;Gerente General: Manuel Ruiz - 6 
            232661 - (Bogotá D.C.)&lt;BR&gt;&lt;BR&gt;Analista de Sistemas 
            (2003 - 2004)&lt;BR&gt;&lt;BR&gt;Analisis y diseño del proyecto '	Interventoría al
						proyecto de acciones de formación profesional continuada para trabajadores, 
						vinculados mediante un plan operativo concertado entre el sena y los 
						empresarios, asociaciones ó gremios'.
            control.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;INTEL@COM ; - Tunja. Diseñador
           pagina Web &lt;/B&gt;&lt;BR&gt; Estudio prototipo para desarrollar pagina Web para 
					 la empresa de transportes  'Los Libertadores - Coflonorte'
					 Análisis de información, para presentar en la Pagina Web
					 Desarrollo primer prototipo de la pagina Web.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;HIDROTEC LTDA&lt;/B&gt;&lt;BR&gt;Gerente: Jorge pardo
					- 5 444040 (Bogotá D.C.)&lt;BR&gt;&lt;BR&gt; Analista y desarrollador de Sistemas 
            (2000 - 2002)&lt;BR&gt;&lt;BR&gt;'	Desarrollo del Sistema de Información de proyectos \
                
						de generación de energía realizado para Empresas públicas de \
Medellín.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;  &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;U.P.T.C. - UNIVERSIDAD PEDAGOGICA Y TECNOLOGICA DE \
                COLOMBIA 
            &lt;/B&gt;&lt;BR&gt;Docente -- (Tunja - Boyaca)(2000)&lt;BR&gt;&lt;BR&gt;Docente en el programa \
de formación   profesional como tecnólogo de sistemas.
            Docente en las áreas de Diseño de Sistemas y Desarrollo \
investigativo.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;  &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;HIDROTEC LTDA &lt;/B&gt;&lt;BR&gt;Desarrollador de Sistemas 
            (1999-2000)&lt;BR&gt;&lt;BR&gt;Desarrollo del Sistema de Información de proyectos de \
generación  de energía realizado para la Empresa Isagen de Medellín.
						 Diseño de la base de datos del modelo de generación de energía.
						 Administración base de datos de Oracle.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;ANTARES TECNOLOGIA (TUNJA)&lt;/B&gt;&lt;BR&gt;Auxiliar operario \
Peaje de Sachica  (1996)&lt;BR&gt;&lt;BR&gt;	Técnico auxiliar de sistemas
					 Manejo del sistema de control de categorización vehicular
					 Programación análisis del flujo vehicular.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      
  &lt;TR bgColor=black&gt;
    &lt;TD class=tdx&gt;&lt;FONT color=white&gt;
      &lt;CENTER&gt;&lt;B&gt;OTRAS EXPERIENCIAS PROFESIONALES 
  ALTERNAS&lt;/B&gt;&lt;/CENTER&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD class=tdx&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;CONSORCIO SULIMAR&lt;/B&gt;&lt;BR&gt;Gerente General: Simeón 
            Ulises Molina - 2444231-2444082 Bogotá D.C.&lt;BR&gt;&lt;BR&gt;Contador 
            (2004)&lt;BR&gt;&lt;BR&gt;Manejo total de la Contabilidad del consorcio, 
            establecimiento de controles y parámetros de procedimientos 
            generales, y contribución en algunas labores Administrativas y de 
            Calidad Total.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;ABASTECEDOR DE TEJAS PLÁSTICAS 
            LTDA.&lt;/B&gt;&lt;BR&gt;Asesoría y Consultoría contable y administrativa (2002- 
            2004)&lt;BR&gt;&lt;BR&gt;Gerente General: Rodrigo Pardo Dillón - 6 080825 
            (Bogotá D.C.)&lt;BR&gt;&lt;BR&gt;Funciones de Asesoría y Consultoría. Planeación 
            y ejecución de metodologías en las áreas contables y 
            administrativas, para el desarrollo óptimo de los diferentes 
            procesos. Elaboración de declaraciones de impuestos, respuesta y 
            trámite de requerimientos de las entidades de 
        control.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;
  &lt;TR bgColor=black&gt;
    &lt;TD class=tdx&gt;&lt;FONT color=white&gt;
      &lt;CENTER&gt;&lt;B&gt;REFERENCIAS PERSONALES&lt;/B&gt;&lt;/CENTER&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD class=tdx&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;ING. DANIEL SUAREZ&lt;/B&gt;&lt;BR&gt;Ingeniero 
            Civil&lt;BR&gt;HIDROTEC LTDA.&lt;BR&gt;Teléfono: 5 444040 
      &lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;ING. PEDRO CANO&lt;/B&gt;&lt;BR&gt;Ingeniero 
          de Sistemas&lt;BR&gt;NORTEL NETWORK BOGOTA&lt;BR&gt;Teléfono: 310 
        2929026&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;ING. JAVIER ARAQUE&lt;/B&gt;&lt;BR&gt;Ingeniero de Sistemas
					&lt;BR&gt;Interamerican Coal&lt;BR&gt;Teléfono: 6220513&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;SANDRA LUCIA GONZALEZ&lt;/B&gt;&lt;BR&gt;Ingeniera de 
            Sistemas&lt;BR&gt;Teléfono: 098 \
7441666&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;  
			&lt;lI&gt;
			&lt;LI&gt;
									
&lt;CENTER&gt;&lt;B&gt;SONIA ESPERANZA MORENO SUAREZ&lt;/B&gt;&lt;BR&gt;C.C. No. 40.037.779 de Bogotá 
&lt;/CENTER&gt;&lt;/CENTER&gt;&lt;/DIV&gt;
	
	
	&lt;/body&gt;&lt;/html&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060221114100</emailId><senderName>Phil H</senderName><senderEmail>philtickle200@yahoo.com</senderEmail><timestampReceived>2006-02-21 11:41:00-0400</timestampReceived><subject>Re: Encrypting Filesystems</subject><body>

Sorry to reply to my own post.  Here is a reader comment from the dmcrypt wiki - not \
sure to what extent these have been addressed:  
 [QUOTE]
 I'm looking over this dmcrypt stuff but it looks like it still has the old bug of \
using the sector number as the IV for CBC mode encryption. The security weakness is \
well known. The maintainers apparently decided to keep the bug in place to help \
interoperability with legacy cryptoloop instances. But I think at minimum, IV \
generation for new installations should be done differently. There is no reason to \
postpone adding a new mode that generates IV's by encrypting the sector number or \
something like that. Keep the current method available as a backwards compatibility \
option, but make the default do things securely.   
 Also, there's also the issue that the passphrase directly generates the bulk \
encryption key. That means if you want to change passphrases, you have to decrypt and \
re-encrypt the entire partition. That's painful. It's better to generate a random \
bulk encryption key, and use the passphrase to encrypt the bulk key on the disk (the \
first sector could be used for such metadata).   
 Finally, I think some work should be done on encrypting root partitions WITHOUT \
needing to boot from an external USB device. Basically just the master boot record \
(and maybe a little bit of GRUB) would be in cleartext. It would prompt for a \
passphrase and decrypt the remaining sectors needed to boot the machine.  [/QUOTE]
 
			
---------------------------------
 Yahoo! Mail
 Use Photomail to share photos without annoying attachments.


[Attachment #3 (text/html)]

Sorry to reply to my own post.  Here is a reader comment from the dmcrypt wiki - \
not sure to what extent these have been addressed:&lt;br&gt; &lt;br&gt; [QUOTE]&lt;br&gt; I'm looking \
over this dmcrypt stuff but it looks like it still has the old bug of using the \
sector number as the IV for CBC mode encryption. The security weakness is well known. \
The maintainers apparently decided to keep the bug in place to help interoperability \
with legacy cryptoloop instances. But I think at minimum, IV generation for new \
installations should be done differently. There is no reason to postpone adding a new \
mode that generates IV's by encrypting the sector number or something like that. Keep \
the current method available as a backwards compatibility option, but make the \
default do things securely. &lt;br&gt;  &lt;br&gt; Also, there's also the issue that the \
passphrase directly generates the bulk encryption key. That means if you want to \
change passphrases, you have to decrypt and re-encrypt the entire partition. That's  \
painful. It's better to generate a random bulk encryption key, and use the passphrase \
to encrypt the bulk key on the disk (the first sector could be used for such \
metadata). &lt;br&gt;  &lt;br&gt; Finally, I think some work should be done on encrypting root \
partitions WITHOUT needing to boot from an external USB device. Basically just the \
master boot record (and maybe a little bit of GRUB) would be in cleartext. It would \
prompt for a passphrase and decrypt the remaining sectors needed to boot the \
machine.&lt;br&gt;  [/QUOTE]&lt;br&gt; &lt;p&gt;  
		&lt;hr size=1&gt; Yahoo! Mail&lt;br&gt; 
&lt;a href="http://us.rd.yahoo.com/mail_us/taglines/pmall2/*http://photomail.mail.yahoo.com"&gt;Use \
Photomail&lt;/a&gt; to share photos without annoying attachments.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060218125045</emailId><senderName>"Markus Laire"</senderName><senderEmail>malaire@gmail.com</senderEmail><timestampReceived>2006-02-18 12:50:45-0400</timestampReceived><subject>Using many (say 20) active loop-devices?</subject><body>

By default I can use up to 8 loop-devices at the same time with losetup.

Is it trivial to use, say 20 (or more), loop-devices at the same time?
Would this need a significant amount of memory/CPU/other resources?

For now I'm only thinking of using these unencrypted, for mounting
several CD ISOs at once.

ps. Is this the right place to ask about losetup (included in
loop-aes-utils) when I'm using it without encryption?

--
Markus Laire

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060219210152</emailId><senderName>markus reichelt</senderName><senderEmail>ml@bitfalle.org</senderEmail><timestampReceived>2006-02-19 21:01:52-0400</timestampReceived><subject>Re: Using many (say 20) active loop-devices?</subject><body>

* Markus Laire &lt;malaire@gmail.com&gt; wrote:

&gt; Is it trivial to use, say 20 (or more), loop-devices at the same time?

AFAIK, there's _somewhere_ a variable/constant/definition which can
be set to the # of loop-devices you need. Someone more tuned to the
code may help out here, old age got me on that one...


&gt; Would this need a significant amount of memory/CPU/other resources?

Setting them all up, no. Using them all at once will certainly
stress your sytem. OTOH, that's also true for other block devices.

Right now I'm pretty much at the max default limit of 8 loop devices
and using them (not all at once - simply not needed) doesn't have an
impact of system stability. Consider it comparable to mounting
several nfs fs and using them when needed.


&gt; For now I'm only thinking of using these unencrypted, for mounting
&gt; several CD ISOs at once.

Well then there should not be a problem.


&gt; ps. Is this the right place to ask about losetup (included in
&gt; loop-aes-utils) when I'm using it without encryption?

If you use loop-aes on your system (one way or the other), I think
yes it is.

Anyway, as the saying goes: use the source, luke ;-)


--=20
left blank, right bald

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060219221954</emailId><senderName>Gabriel_Jägenstedt</senderName><senderEmail>gabriel.j@telia.com</senderEmail><timestampReceived>2006-02-19 22:19:54-0400</timestampReceived><subject>Re: Using many (say 20) active loop-devices?</subject><body>



markus reichelt wrote:
&gt; * Markus Laire &lt;malaire@gmail.com&gt; wrote:
&gt; 
&gt; 
&gt;&gt;Is it trivial to use, say 20 (or more), loop-devices at the same time?
&gt; 
&gt; 
&gt; AFAIK, there's _somewhere_ a variable/constant/definition which can
&gt; be set to the # of loop-devices you need. Someone more tuned to the
&gt; code may help out here, old age got me on that one...

loop.c-2.x.patched has the line:

static int max_loop = 8;

change this to get more loop-devices.

Remember to create the devides in /dev as well.
Have a look at MAKEDEV there.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060220095934</emailId><senderName>Tor Bendiksen</senderName><senderEmail>tor@tblab.net</senderEmail><timestampReceived>2006-02-20 09:59:34-0400</timestampReceived><subject>Re: Using many (say 20) active loop-devices?</subject><body>

On Sun, 19 Feb 2006 22:01:52 +0100, markus reichelt &lt;ml@bitfalle.org&gt; wrote:
&gt;&gt; Is it trivial to use, say 20 (or more), loop-devices at the same time?
Yes. No problems. Gabriel already explained how. 

&gt;&gt; Would this need a significant amount of memory/CPU/other resources?
&gt; Setting them all up, no. Using them all at once will certainly
&gt; stress your sytem. OTOH, that\'s also true for other block devices.

I used to run a mirror server for linux and FOSS based content.
I had over 200 ISO\'s mounted simultaneously on a system with 2x450MHz PII\'s, 
512 MB RAM and 40x18GB disks. This was shared out over http, ftp, nfs and rsync.
I had no performance problems at all with this setup and ISO\'s loopback mounted.

BTW. This was over a (semi)dedicated 100Mb connection.

&gt;&gt; ps. Is this the right place to ask about losetup (included in
&gt;&gt; loop-aes-utils) when I\'m using it without encryption?
Not sure, but this list is more-so encryption-sentric. 
While I couldn\'t say that this is the wrong list as such, I would suggest
that you seek out a LUG (Linux users group) near you. They will tend to be very
good at these type of questions.
 

-- 
Best Regards,
Tor Bendiksen


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060203150920</emailId><senderName>Florian Reitmeir</senderName><senderEmail>florian@reitmeir.org</senderEmail><timestampReceived>2006-02-03 15:09:20-0400</timestampReceived><subject>Re: SATA Raid0 and loop-aes</subject><body>

Hi,

On Fre, 03 Feb 2006, Peter_22@gmx.de wrote:

&gt; I would like to kindly ask if the following harddrives are ok to built a
&gt; raid0 and then encrypt it with loop-aes. As drives I consider these two as a
&gt; good choice:
&gt; 1. Maxtor
&gt; model: 7V300F0
&gt; size: 300GB (7200U/min, 16MB Cache, 9ms, S-ATA II, NCQ)
&gt; price: 130 Euros
&gt; 
&gt; 2. Western Digital
&gt; model: WD3200SD (RAID Edition)
&gt; size: 320GB (7200U/min, 8MB Cache, 8.9ms, S-ATA/150)
&gt; price: 134 Euros

why not..

&gt; Two of them as raid0 should operate faster than one of these high-price
&gt; 500GB wonders with 5 platters inside. Raid0 would be done with Via chipset
&gt; VT8237.

Why not using a normal native software raid? (maybe you intend to change your
mainboard someday..) The software raid from linux is in many cases faster and
more stable than some "raid"-adapters.

&gt; Is it a hard struggle to get the raid0 encrypted? Are there readers around
&gt; here with experience in this field? I consider Maxtor and WD as reliable
&gt; drives.

you can painless encrypt nearly every block-device in linux

-- 
Florian Reitmeir

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060201170801</emailId><senderName>Markus Laire</senderName><senderEmail>malaire@gmail.com</senderEmail><timestampReceived>2006-02-01 17:08:01-0400</timestampReceived><subject>Re: How to get the size of the loop-device?</subject><body>

On 2/1/06, Markus Laire &lt;malaire@gmail.com&gt; wrote:
&gt; Once I have a working loop device, e.g. /dev/loop5, how can I get the
&gt; size of this device in bytes for bash-script?
&gt; I need this, so that I can create two loop-devices on top on it, like
&gt;   losetup -o 0 -s $halfsize /dev/loop6 /dev/loop5
&gt;   losetup -o $halfsize /dev/loop7 /dev/loop5
&gt;
&gt; I tried trivial `perl -e 'print -s "/dev/loop5"'`, but it just returns ze=
ro.
&gt;
&gt; There's likely a trivial answer to this, but I havn't been able to find i=
t.

ok, I just found one way to do it. I should have tried a bit more
before asking from the list.

`sudo perl -e 'open D, "&lt;", "/dev/loop5"; print sysseek D,0,2; close D'`

--
Markus Laire

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060201171826</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-02-01 17:18:26-0400</timestampReceived><subject>Re: How to get the size of the loop-device?</subject><body>

Markus Laire wrote:
&gt; Once I have a working loop device, e.g. /dev/loop5, how can I get the
&gt; size of this device in bytes for bash-script?
&gt; I need this, so that I can create two loop-devices on top on it, like
&gt;   losetup -o 0 -s $halfsize /dev/loop6 /dev/loop5
&gt;   losetup -o $halfsize /dev/loop7 /dev/loop5
&gt; 
&gt; I tried trivial `perl -e 'print -s "/dev/loop5"'`, but it just returns zero.
&gt; 
&gt; There's likely a trivial answer to this, but I havn't been able to find it.

sectors=`blockdev --getsize /dev/loop5`
fullsize=`echo ${sectors}' * 512' | bc`
halfsize=`echo ${sectors}' * 256' | bc`

What are you trying to do?

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060201180141</emailId><senderName>Markus Laire</senderName><senderEmail>malaire@gmail.com</senderEmail><timestampReceived>2006-02-01 18:01:41-0400</timestampReceived><subject>Re: How to get the size of the loop-device?</subject><body>

On 2/1/06, Jari Ruusu &lt;jariruusu@users.sourceforge.net&gt; wrote:
&gt; Markus Laire wrote:
&gt; &gt; Once I have a working loop device, e.g. /dev/loop5, how can I get the
&gt; &gt; size of this device in bytes for bash-script?
&gt;
&gt; sectors=`blockdev --getsize /dev/loop5`
&gt; fullsize=`echo ${sectors}' * 512' | bc`
&gt; halfsize=`echo ${sectors}' * 256' | bc`
&gt;
&gt; What are you trying to do?

I'm writing a script which double-encrypts a single swap-area and /tmp
with random keys.

If I simply use two loop-devices for both, I need 4 sets of random keys.

So I'm trying this setup which only needs 2 sets of random keys:
(I don't want to waste the entropy)
(Note: I intend to use 2 different ciphers, but currently I only have
AES working)

losetup -e AES256 -H random /dev/loop7 "$DEV"
losetup -e AES256 -H random /dev/loop6 /dev/loop7
losetup -s $halfsize /dev/loop4 /dev/loop6
losetup -o $halfsize /dev/loop5 /dev/loop6
mkswap /dev/loop4 &gt; /dev/null
mke2fs -m 0 /dev/loop5 &amp;&gt; /dev/null
swapon /dev/loop4
mount -t ext2 /dev/loop5 /tmp
chmod 1777 /tmp

--
Markus Laire

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060210195129</emailId><senderName>"Leo Bogert"</senderName><senderEmail>leo@bogert.de</senderEmail><timestampReceived>2006-02-10 19:51:29-0400</timestampReceived><subject>Need AES benchmark of P4 775 64bit</subject><body>

Hi,

can someone please benchmark the AES speed of his Pentium 4 Sockel 775
64bit?
Easiest way to do that:
$ openssl
OpenSSL&gt; speed aes-256-cbc

I got a Celeron 64bit 2800MHz and it does 78700.54k on 8kb blocks.
I'm just trying to figure out whether upgrading to a dualcore P4 would make
sense.
Please give me your whole openssl output.

Thanks, Leo Bogert


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060211235757</emailId><senderName>"ZaptaClub"</senderName><senderEmail>club@zapta.co.il</senderEmail><timestampReceived>2006-02-11 23:57:57-0400</timestampReceived><subject>=?windows-1255?Q?=F0=EE=E0=F1_=EC=EB=ED_=EC=F9=EC=ED_=EE=E7=E9=F8=E9=ED_=E9=F7=F8=E9=ED_=F2=E1=E5=F8</subject><body>

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=Content-Type content="text/html; charset=windows-1255"&gt;
&lt;/head&gt;
&lt;body style="FONT-FAMILY: Arial"&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;ðîàñ ìëí ìùìí îçéøéí é÷øéí 
òáåø ùéçåú áèìôåðéí äðééãéí ?&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;úðå ìðå ìîöåà ìëí àú äãéì 
äèåá áéåúø.&lt;/span&gt;&lt;span dir=ltr 
style="FONT-FAMILY: Arial"&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;æôèä áùéúåó îåòãåï äöøëðéí 
&lt;/span&gt;&lt;b&gt;&lt;i&gt;&lt;span lang=HE 
style="FONT-SIZE: 14pt; COLOR: #3366ff; FONT-FAMILY: Arial"&gt;÷ìàá 
&lt;/span&gt;&lt;/i&gt;&lt;/b&gt;&lt;b&gt;&lt;i&gt;&lt;span dir=ltr 
style="FONT-SIZE: 14pt; COLOR: #3366ff; FONT-FAMILY: Arial"&gt;Club 
1&lt;/span&gt;&lt;/i&gt;&lt;/b&gt;&lt;span dir=rtl&gt;&lt;/span&gt;&lt;span lang=HE 
style="FONT-FAMILY: Arial"&gt;&lt;span dir=rtl&gt;&lt;/span&gt; îáéàéí ìëí åáùáéìëí &lt;br&gt;àú 
äîçéøéí åäúðàéí äèåáéí áéåúø.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;&lt;br&gt;àðçðå áîå"î òí çáøåú 
äñìåìø òì îðú ìîöåà ìëí àú äãéìéí åäîçéøéí äëé èåáéí.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;àðà îìàå àú äôøèéí åðçæåø 
àìéëí òí ääöòåú äëé èåáåú áùáéìëí.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt"&gt;&lt;span lang=HE 
style="FONT-FAMILY: Arial"&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=MsoNormal dir=rtl style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" 
align=center&gt;&lt;b&gt;&lt;span lang=HE style="FONT-FAMILY: Arial"&gt;ìôøèéí &lt;a 
href="http://www.zapta.co.il/poll.asp"&gt;ìçöå ëàï&lt;/a&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060212152449</emailId><senderName>JPMorgan Chase &amp; Co.</senderName><senderEmail>notice@chase.com</senderEmail><timestampReceived>2006-02-12 15:24:49-0400</timestampReceived><subject>Check and update your account</subject><body>



&lt;html&gt;
&lt;head&gt;
&lt;title&gt;notice&lt;/title&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;
&lt;/head&gt;

&lt;body bgcolor="#FFFFFF" text="#000000"&gt;
&lt;font face="Arial, Helvetica, sans-serif" size=2&gt; 
&lt;p align=left&gt;Dear Customer,&lt;/p&gt;
&lt;p align=left&gt;At JPMorgan Chase Bank, the greatest responsability 
  to our customer is the safekeeping of confidential information you have entrusted 
  to us and using it in a responsable manner. A fundamental element of safeguarding 
  your confidential information is to provide protection against unauthorized 
  access or use of this information. We maintain physical, electronic and procedural 
  safeguards that comply with federal guidelines to guard your nonpublic personal 
  information against unauthorized access. &lt;/p&gt;
&lt;p align=left&gt;At this time we need you to confirm your online account with our 
  existing database. As soon as our database will be updated we need to make a 
  few important anouncements to our customers so please update your contact \
information   with no delay. &lt;/p&gt;
&lt;p align=left&gt;Your PC Banking account registered to 
  linux-crypto@nl.linux.org can be confirmed at any time clicking the link \
bellow:&lt;br&gt; &lt;br&gt;
  &lt;a href="http://www.aranciarossadoc.it/www.chase/com/index.php" \
target="_blank"&gt;http://www.chase.com/&lt;/a&gt;&lt;/p&gt; &lt;p align=left&gt;Our database will be \
instantly updated. &lt;/p&gt; &lt;p align=left&gt;We are committed to the responsible use and \
protection of customer   information on our website. At JPMorgan Chase Bank we are \
dedicated   to providing you with exceptional service and to ensuring your trust. If \
you   have any questions regarding our services, please check the website or call 
  our customer service. &lt;/p&gt;
&lt;p&gt;Warmly,&lt;br&gt;
  Liza Benson,&lt;br&gt;
&lt;p&gt;&lt;font color="#999999"&gt;© 2006 JPMorgan Chase &amp; Co&lt;/font&gt; 
&lt;/font&gt; 
&lt;/body&gt;
&lt;/html&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060212175556</emailId><senderName>"David Jones"</senderName><senderEmail>latticecottage@btinternet.com</senderEmail><timestampReceived>2006-02-12 17:55:56-0400</timestampReceived><subject>verifying my e-mail address</subject><body>

i have been trying to verify my e-mail address and i read this was the right
way to do it?

[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;&lt;HEAD&gt;
&lt;META http-equiv=Content-Type content="text/html; charset=us-ascii"&gt;
&lt;META content="MSHTML 6.00.2900.2802" name=GENERATOR&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;&lt;SPAN class=483015517-12022006&gt;i have been trying 
to verify my e-mail address and i read this was the right way to do 
it?&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/DIV&gt;&lt;/BODY&gt;&lt;/HTML&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060217121136</emailId><senderName>Venkat Manakkal</senderName><senderEmail>venkat@rayservers.com</senderEmail><timestampReceived>2006-02-17 12:11:36-0400</timestampReceived><subject>Re: Cryptoloop hvr issues?</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 02/17/2006 03:51 AM, Nandan S wrote:
| Hi,
|    I need to add cryptoloop support to the 2.4.31 kernel. I'm planning
| to use the hvr patch, since the hvr patch would mean minimal changes to
| our custom kernel code. But I see that most of the distributions
| (openwall/debian/gentoo) have chosen the jari patch, and the hvr patch
| seems to be unmaintained.  Is the hvr patch obsolete or are there any
| known issues with it?
| Really appreciate any help,
| NAndan

As I have posted recently:

Cryptoloop implements single key disk crypto that is fubar and the second
implements multi-key crypto that is not vulnerable to the watermark attack.

See: http://mareichelt.de/pub/texts.cryptoloop.php

and from google:

http://marc.theaimsgroup.com/?l=linux-kernel&amp;m=107719798631935&amp;w=2
http://www.governmentsecurity.org/archive/t14922.html

So use loop-aes. I'm waiting for the day when the kernel developers drop
cryptoloop and put in loop-aes, but I'm not holding my breath.

Cheers,

- ---Venkat.

- --
http://rayservers.com/                                            607-546-7300
PGP/GPG:                            https://rayservers.com/keys/0x12430522.asc
Skype: rayservers       GDCA: http://www.gdcaonline.org/members/rayservers.htm
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.2 (GNU/Linux)

iD8DBQFD9b11WdkW/RJDBSIRAtoyAJ9ENkCClbkfckWENunX8Gi3DnaJugCdHeNf
aILbqj9qUo/1VVQQkUsLt9Y=
=8uzw
-----END PGP SIGNATURE-----

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060221122415</emailId><senderName>Tom Haddon</senderName><senderEmail>mthaddon@yahoo.com</senderEmail><timestampReceived>2006-02-21 12:24:15-0400</timestampReceived><subject>Re: Encrypting Filesystems</subject><body>

Thanks for everyone's feedback. I'll be taking a closer look at loop-aes
and determining how to incorporate that into my article. I'll let you
all know when the article is ready for publication, and if anyone is
interested in proofreading it for corrections I'm open to that at that
stage.

Thanks, Tom

On Tue, 2006-02-21 at 03:41 -0800, Phil H wrote:
&gt; Sorry to reply to my own post.  Here is a reader comment from the
&gt; dmcrypt wiki - not sure to what extent these have been addressed:
&gt; 
&gt; [QUOTE]
&gt; I'm looking over this dmcrypt stuff but it looks like it still has the
&gt; old bug of using the sector number as the IV for CBC mode encryption.
&gt; The security weakness is well known. The maintainers apparently
&gt; decided to keep the bug in place to help interoperability with legacy
&gt; cryptoloop instances. But I think at minimum, IV generation for new
&gt; installations should be done differently. There is no reason to
&gt; postpone adding a new mode that generates IV's by encrypting the
&gt; sector number or something like that. Keep the current method
&gt; available as a backwards compatibility option, but make the default do
&gt; things securely. 
&gt; 
&gt; Also, there's also the issue that the passphrase directly generates
&gt; the bulk encryption key. That means if you want to change passphrases,
&gt; you have to decrypt and re-encrypt the entire partition. That's
&gt; painful. It's better to generate a random bulk encryption key, and use
&gt; the passphrase to encrypt the bulk key on the disk (the first sector
&gt; could be used for such metadata). 
&gt; 
&gt; Finally, I think some work should be done on encrypting root
&gt; partitions WITHOUT needing to boot from an external USB device.
&gt; Basically just the master boot record (and maybe a little bit of GRUB)
&gt; would be in cleartext. It would prompt for a passphrase and decrypt
&gt; the remaining sectors needed to boot the machine.
&gt; [/QUOTE]
&gt; 
&gt; 
&gt; 
&gt; ______________________________________________________________________
&gt; Yahoo! Mail
&gt; Use Photomail to share photos without annoying attachments.

Tom Haddon
mailto:mthaddon@yahoo.com

Noise proves nothing.  Often a hen who has merely laid an egg cackles
as if she laid an asteroid.
		-- Mark Twain


-----------------
Random quotes courtesy of fortune.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060222085425</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-02-22 08:54:25-0400</timestampReceived><subject>Re: Where can I find the archives of this maillist?</subject><body>

On Wed, Feb 22, 2006 at 12:20:42PM +0800, ZHUANG YUYAO (zhuangyy@xianan.com.cn) wrote:
&gt; Hi,
&gt; 
&gt; Where can I find the archives of this maillist? there is no link in 
&gt; http://vger.kernel.org/vger-lists.html.

http://www.mail-archive.com/linux-crypto%40vger.kernel.org/

&gt; Thanks
&gt; 
&gt; Zhuang Yuyao

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060222125734</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-02-22 12:57:34-0400</timestampReceived><subject>Re: hardened kernel and loop-aes</subject><body>

Venkat Manakkal wrote:
&gt; I'm having trouble getting the latest hardened kernel and loop-aes happy with
&gt; each other, I've used older hardened kernels before. I suspect it is over
&gt; ambitious lockdown of PaX and GrSecurity.

Sorry for late answer. I was busy.

Looks like that CONFIG_PAX_KERNEXEC=y is what makes kernel enforce
executable-or-writable-but-not-both for kernel space bits (which is good),
but unfortunately it also makes executable kernel segments unreadable using
normal read access (which is bad).

Failing access is normal data read of executable '.text' section when
assembler implementation of AES (aes-x86.S) key setup code attempts to
access precomputed read-only data tables. This can be fixed by putting those
precomputed tables in read-only-data '.rodata' section. But why were those
precomputed tables put to '.text' section? Because at the time (year 2001) I
intentionally made that assembler implementation work with many operating
systems, including Linux, FreeBSD, and OpenBSD. The assembler in OpenBSD was
prehistoric (binutils-1.x, man page from year 1991), and it failed to
assemble that read-only-data section. So I worked around that
incompatibility by putting those precomputed tables to read-only '.text'
section.

As of this writing, I don't know if grsec's executable but unreadable kernel
space segments is a bug or intentionally sacrificed functionality to gain
executable-or-writable-but-not-both for kernel space.

A patch that puts loop-AES' precomputed tables in read-only-data '.rodata'
section is below.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD


--- ../loop-AES-v3.1c/aes-x86.S	2004-06-12 17:31:41.000000000 +0300
+++ ./aes-x86.S	2006-02-22 14:22:34.000000000 +0200
@@ -718,6 +718,7 @@
 //
 // Here is precomputed output (it's more portable this way):
 
+	.section .rodata
 	.align	ALIGN32BYTES
 aes_rcon_tab:
 	.long	0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060222144410</emailId><senderName>SONIA ESPERANZA MORENO SUAREZ</senderName><senderEmail>soniaemorenos@yahoo.com.ar</senderEmail><timestampReceived>2006-02-22 14:44:10-0400</timestampReceived><subject>Ingeniera de Sistemas DBA</subject><body>


&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;
	
&lt;CENTER&gt;
&lt;TABLE class=tdx cellSpacing=0 cellPadding=0 width=600 border=0&gt;
  &lt;TBODY&gt;
  &lt;TR&gt;
    &lt;TD class=tdx &gt;
		&lt;table width='100%'&gt;&lt;tr&gt;&lt;td&gt;&lt;img \
src='http://www.autoscolombia.com/autos/aviso/sonia.jpg'&gt;&lt;/td&gt;&lt;td align=right&gt;  &lt;font \
color='#000066'&gt;  &lt;B&gt;SONIA ESPERANZA MORENO SUAREZ&lt;/B&gt;&lt;BR&gt;Calle 
      145 No. 41-73 Apto. 403&lt;BR&gt;Teléfonos: 6278558, 6157919&lt;BR&gt;Celular: 3106980121 
      &lt;BR&gt;Fecha de Nacimiento: Diciembre 29 de 1974 (Tunja - 
      Boyaca)
			&lt;Br&gt;E-mail: soniaemorenos@yahoo.com.ar
      &lt;Br&gt;Soniaemorenos@hotmail.com      
						&lt;BR&gt;&lt;BR&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
						
						&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR bgColor=black&gt;
	&lt;TR bgcolor=silver&gt;
    &lt;TD class=tdx&gt;&lt;FONT color=white&gt;
      &lt;CENTER&gt;&lt;B&gt;PERFIL PROFESIONAL&lt;/B&gt;&lt;/CENTER&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD class=tdx&gt;&lt;BR&gt;
      &lt;DIV align=justify&gt;
			&lt;LI&gt; Liderazgo en Análisis y Diseño  de  Sistemas.
			&lt;LI&gt; Automatización, evaluación, seguimiento y control de métodos, procesos y \
procedimientos.  &lt;LI&gt; Experiencia en análisis, Diseño e implementación de sistemas de \
información.  &lt;lI&gt; Manejo de sistemas  Dos, Windows  - 95 - 98 - 2000 -2003 ,  WinNT \
4.0  &lt;li&gt; conocimientos básicos de Linux
			&lt;LI&gt; Programación: VISUAL BASIC 6.0, SQL SERVER 7.0 ó 2000, Access 97, 2000
			&lt;LI&gt; Administracion Bases de datos ORACLE   8i,9i
			&lt;LI&gt; Conocimientos básicos de Autocad 2000.
			&lt;LI&gt; Metodología de capacitación, inducción  y apoyo.
			&lt;LI&gt; Excelentes relaciones interpersonales&lt;/DIV&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR bgColor=black&gt;
    &lt;TD class=tdx&gt;&lt;FONT color=white&gt;
      &lt;CENTER&gt;&lt;B&gt;ESTUDIOS REALIZADOS&lt;/B&gt;&lt;/CENTER&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD class=tdx&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width=120&gt;&lt;B&gt;PREGADO&lt;/B&gt;&lt;/TD&gt;
          &lt;TD&gt;INGENIERIA DE SISTEMAS&lt;BR&gt;Fundacion 
            universitaria de Boyaca - Año \
1998&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;  
		&lt;TD class=tdx&gt;
			&lt;TABLE width='100%'&gt;
				&lt;tbody&gt;
				&lt;TR&gt;
					&lt;TD width=120&gt;&lt;B&gt;POSGRADO&lt;/B&gt;&lt;/TD&gt;	
					&lt;TD&gt;ESPECIALIZACION REDES DE DATOS&lt;BR&gt;Universidad 
            Santo Tomas - Año 2003&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;
						&lt;TD&gt;Matricula Profesional&lt;BR&gt;15255754663BYC
  &lt;TR&gt;
    &lt;TD class=tdx&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width=120&gt;&lt;B&gt;CURSOS Y SEMINARIOS&lt;/B&gt;&lt;/TD&gt;
          &lt;TD&gt;
            &lt;LI&gt;Seminario Taller 'UNÍX UNA Visión GLOBAL' - 
            Fundación Universitaria de Boyacá - 1999
            &lt;LI&gt;'	Seminario Think  9i for developers - 
						Centro de Convenciones Gonzalo Jiménez de Quesada -Febrero 2002
            &lt;LI&gt;'	V Jornada de actualización en nuevas tecnologías 
						para redes y telecomunicaciones. - 
						Fundacion Universitaria de Boyaca - Abril 2002 
            &lt;LI&gt;'	Curso de Autocad 2000i
						Fundacion Universitaria de Boyaca - Agosto 2002 
            &lt;LI&gt;Fundamento Oracle 9i
						Aptech - Agosto 2005
						&lt;LI&gt; 'Visual Basic .NET
						Aptech - Octubre 2005.&lt;/LI&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR bgColor=silver&gt;
    &lt;TD class=tdx&gt;&lt;FONT color=white&gt;
      &lt;CENTER&gt;&lt;B&gt;EXPERIENCIA LABORAL&lt;/B&gt;&lt;/CENTER&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD class=tdx&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;ICETEX &lt;/B&gt;&lt;BR&gt;Instituto Colombiano para estudios 
            tecnicos en el exterior ( Bogota D.C. )&lt;BR&gt;&lt;BR&gt;ADMINISTRADOR 
            BASE DE DATOS ( JULIO 2004 -FEBRERO 2005 )&lt;BR&gt;&lt;BR&gt;Administracion Base de 
            datos, Oracle 8i, 9i, SQL SERVER 2000, Exhange 2003, 
            Administracion Sistemas operativos :  Solaris 2.6, 9, Unix, Windows 2000 \
advanced  Server, Windows 2003 server&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;ECA ICC S.A.&lt;/B&gt;&lt;BR&gt;Gerente General: Manuel Ruiz - 6 
            232661 - (Bogotá D.C.)&lt;BR&gt;&lt;BR&gt;Analista de Sistemas 
            (2003 - 2004)&lt;BR&gt;&lt;BR&gt;Analisis y diseño del proyecto '	Interventoría al
						proyecto de acciones de formación profesional continuada para trabajadores, 
						vinculados mediante un plan operativo concertado entre el sena y los 
						empresarios, asociaciones ó gremios'.
            control.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;INTEL@COM ; - Tunja. Diseñador
           pagina Web &lt;/B&gt;&lt;BR&gt; Estudio prototipo para desarrollar pagina Web para 
					 la empresa de transportes  'Los Libertadores - Coflonorte'
					 Análisis de información, para presentar en la Pagina Web
					 Desarrollo primer prototipo de la pagina Web.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;HIDROTEC LTDA&lt;/B&gt;&lt;BR&gt;Gerente: Jorge pardo
					- 5 444040 (Bogotá D.C.)&lt;BR&gt;&lt;BR&gt; Analista y desarrollador de Sistemas 
            (2000 - 2002)&lt;BR&gt;&lt;BR&gt;'	Desarrollo del Sistema de Información de proyectos \
                
						de generación de energía realizado para Empresas públicas de \
Medellín.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;  &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;U.P.T.C. - UNIVERSIDAD PEDAGOGICA Y TECNOLOGICA DE \
                COLOMBIA 
            &lt;/B&gt;&lt;BR&gt;Docente -- (Tunja - Boyaca)(2000)&lt;BR&gt;&lt;BR&gt;Docente en el programa \
de formación   profesional como tecnólogo de sistemas.
            Docente en las áreas de Diseño de Sistemas y Desarrollo \
investigativo.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;  &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;HIDROTEC LTDA &lt;/B&gt;&lt;BR&gt;Desarrollador de Sistemas 
            (1999-2000)&lt;BR&gt;&lt;BR&gt;Desarrollo del Sistema de Información de proyectos de \
generación  de energía realizado para la Empresa Isagen de Medellín.
						 Diseño de la base de datos del modelo de generación de energía.
						 Administración base de datos de Oracle.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;ANTARES TECNOLOGIA (TUNJA)&lt;/B&gt;&lt;BR&gt;Auxiliar operario \
Peaje de Sachica  (1996)&lt;BR&gt;&lt;BR&gt;	Técnico auxiliar de sistemas
					 Manejo del sistema de control de categorización vehicular
					 Programación análisis del flujo vehicular.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      
  &lt;TR bgColor=black&gt;
    &lt;TD class=tdx&gt;&lt;FONT color=white&gt;
      &lt;CENTER&gt;&lt;B&gt;OTRAS EXPERIENCIAS PROFESIONALES 
  ALTERNAS&lt;/B&gt;&lt;/CENTER&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD class=tdx&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;CONSORCIO SULIMAR&lt;/B&gt;&lt;BR&gt;Gerente General: Simeón 
            Ulises Molina - 2444231-2444082 Bogotá D.C.&lt;BR&gt;&lt;BR&gt;Contador 
            (2004)&lt;BR&gt;&lt;BR&gt;Manejo total de la Contabilidad del consorcio, 
            establecimiento de controles y parámetros de procedimientos 
            generales, y contribución en algunas labores Administrativas y de 
            Calidad Total.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;ABASTECEDOR DE TEJAS PLÁSTICAS 
            LTDA.&lt;/B&gt;&lt;BR&gt;Asesoría y Consultoría contable y administrativa (2002- 
            2004)&lt;BR&gt;&lt;BR&gt;Gerente General: Rodrigo Pardo Dillón - 6 080825 
            (Bogotá D.C.)&lt;BR&gt;&lt;BR&gt;Funciones de Asesoría y Consultoría. Planeación 
            y ejecución de metodologías en las áreas contables y 
            administrativas, para el desarrollo óptimo de los diferentes 
            procesos. Elaboración de declaraciones de impuestos, respuesta y 
            trámite de requerimientos de las entidades de 
        control.&lt;BR&gt;&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;
  &lt;TR bgColor=black&gt;
    &lt;TD class=tdx&gt;&lt;FONT color=white&gt;
      &lt;CENTER&gt;&lt;B&gt;REFERENCIAS PERSONALES&lt;/B&gt;&lt;/CENTER&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD class=tdx&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;ING. DANIEL SUAREZ&lt;/B&gt;&lt;BR&gt;Ingeniero 
            Civil&lt;BR&gt;HIDROTEC LTDA.&lt;BR&gt;Teléfono: 5 444040 
      &lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;ING. PEDRO CANO&lt;/B&gt;&lt;BR&gt;Ingeniero 
          de Sistemas&lt;BR&gt;NORTEL NETWORK BOGOTA&lt;BR&gt;Teléfono: 310 
        2929026&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;ING. JAVIER ARAQUE&lt;/B&gt;&lt;BR&gt;Ingeniero de Sistemas
					&lt;BR&gt;Interamerican Coal&lt;BR&gt;Teléfono: 6220513&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
      &lt;TABLE width='100%'&gt;
        &lt;TBODY&gt;
        &lt;TR&gt;
          &lt;TD width='100%'&gt;&lt;B&gt;SANDRA LUCIA GONZALEZ&lt;/B&gt;&lt;BR&gt;Ingeniera de 
            Sistemas&lt;BR&gt;Teléfono: 098 \
7441666&lt;BR&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;  
			&lt;lI&gt;
			&lt;LI&gt;
									
&lt;CENTER&gt;&lt;B&gt;SONIA ESPERANZA MORENO SUAREZ&lt;/B&gt;&lt;BR&gt;C.C. No. 40.037.779 de Bogotá 
&lt;/CENTER&gt;&lt;/CENTER&gt;&lt;/DIV&gt;
	
	
	&lt;/body&gt;&lt;/html&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060222151637</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-02-22 15:16:37-0400</timestampReceived><subject>Re: Using many (say 20) active loop-devices?</subject><body>

On Sun, Feb 19, 2006 at 10:01:52PM +0100, markus reichelt wrote:
&gt; * Markus Laire &lt;malaire@gmail.com&gt; wrote:
&gt; 
&gt; &gt; Is it trivial to use, say 20 (or more), loop-devices at the same time?
&gt; 
&gt; AFAIK, there's _somewhere_ a variable/constant/definition which can
&gt; be set to the # of loop-devices you need. 

For modular loop-AES, you can also just set the max_loop 
module option (values up to 256 IIRC)

  modinfo loop
  modprobe loop max_loop=32

&gt; &gt; ps. Is this the right place to ask about losetup (included in
&gt; &gt; loop-aes-utils) when I'm using it without encryption?
&gt; 
&gt; If you use loop-aes on your system (one way or the other), I think
&gt; yes it is.
&gt; 
&gt; Anyway, as the saying goes: use the source, luke ;-)

In case the source won't work for you, or if you suspect 
something specific to the Debian/Ubuntu/.. system or package,
you can write to loop-aes-utils@packages.debian.org too.

cheers,
Max

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060228200605</emailId><senderName>"Downtune Team"</senderName><senderEmail>enquiries@downtune.com</senderEmail><timestampReceived>2006-02-28 20:06:05-0400</timestampReceived><subject>Downtune February 06 Update</subject><body>

Hi 

We've been very busy for the last month making some big changes to the downtune site \
design. We're testing off line at the mo, but we'll have an announcement out very \
soon with a date for the release of the new site. Sorry to everyone who've been \
expecting to see the site sooner, but we just got snowed under with less interesting \
projects.

It has been a great start for downtune though, because while we've been away doing \
cool things to the site, some amazing musicians have signed up. We're really proud to \
have them along for the ride so we thought, as our best way of saying thanks to them \
all, that we'd do a bit of a showcase of some of their music. 

One band in particular that we wanted to give you the chance to hear are Jackpike. \
They're a teenage rock band from Birmingham (UK) and when we heard them first they \
just blew our minds. The band, who were voted Band of the Year in January 06, are \
students on the Artist Development Programme at the British Academy of New Music in \
London. We think they're the next big thing in the UK. Just click the link below and \
have a listen to their cool musical stylings and see if you agree.

Jackpike!

There's lots more great (and some very very odd) music like this appearing on the \
site. Why not visit and show your support for these talented musicians by playing \
their songs (and moving them up the downtune charts), or just have a browse to see \
what we are all about. You can drop into the web site by clicking downtune. Enjoy!

If you like what you hear, then have a listen to the selection offered for your \
entertainment below. They have been chosen to show the sheer variety of the artists \
who have decided to make downtune their musical home on the web. 

Cabaret Rat - Surf Monkey

http://www.downtune.com/main/player.jsp?bandId=353&amp;trackId=438&amp;playerId=318&amp;hitSource=1



Jackpike 2 - Midnight. We just love these guys!

http://www.downtune.com/main/player.jsp?bandId=432&amp;trackId=591&amp;playerId=400&amp;hitSource=1



Cracky And The Montegoes - Bang The Screaming Song!

http://www.downtune.com/main/player.jsp?bandId=263&amp;trackId=280&amp;playerId=233&amp;hitSource=1



Ron Wiseman and Kedusha - Blowing the Coal

http://www.downtune.com/main/player.jsp?bandId=290&amp;trackId=344&amp;playerId=254&amp;hitSource=1



Sound Sanctuary - Summit of the Big Low

http://www.downtune.com/main/player.jsp?bandId=308&amp;trackId=453&amp;playerId=272&amp;hitSource=1



HALAGOOGOO - Babysnatcher 

http://www.downtune.com/main/player.jsp?bandId=279&amp;trackId=454&amp;playerId=243&amp;hitSource=1



Kiskadee - Don't wanna know

http://www.downtune.com/main/player.jsp?bandId=474&amp;trackId=678&amp;playerId=439&amp;hitSource=1


Imurno - She wears my ring

http://www.downtune.com/main/player.jsp?bandId=287&amp;trackId=318&amp;playerId=251&amp;hitSource=1



$hit - We don't give a f*** about soul! 

http://www.downtune.com/main/player.jsp?bandId=502&amp;trackId=744&amp;playerId=467&amp;hitSource=1


That's all for now but we'll be back in your inbox soon to bring you lots more cool \
sounds and details of the release of the new site. For now 


[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;
&lt;title&gt;Untitled Document&lt;/title&gt;
&lt;style type="text/css"&gt;
&lt;!--
.style3 {
	font-size: 12px;
	font-family: "Comic Sans MS";
}
.style4 {
	font-size: 14px;
	font-weight: bold;
}
--&gt;
&lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;p class="style3"&gt;Hi everyone&lt;/p&gt;
&lt;p class="style3"&gt;We've been very busy for the last month  making some big changes to \
the downtune site design. We're testing off line at the mo, but we'll have an \
announcement out very soon with a date for the release of the new site. Sorry to \
everyone who've been expecting to see the site sooner, but we just got snowed under \
with less interesting projects.&lt;/p&gt; &lt;p class="style3"&gt;It has been a great start for \
downtune though, because while we've been away doing cool things to the site, some \
amazing musicians have signed up. We're really proud to have them along for the ride \
so we thought, as our best way of saying thanks to them all, that we'd do a bit of a \
showcase of some of their music. &lt;/p&gt; &lt;p class="style3"&gt;One band in particular that \
we wanted to give you the chance to hear are &lt;span class="style4"&gt;Jackpike&lt;/span&gt;. \
They're a teenage rock band from Birmingham (UK) and when we heard them first they \
just blew our minds.  The band, who were voted Band of the Year in January 06, are \
students on the Artist Development Programme at the British Academy of New Music in \
London. We think they're the next big thing in the UK. Just click the link below and \
have a listen to their cool musical stylings and see if you agree.&lt;/p&gt; &lt;p \
class="style3"&gt; &lt;a href="http://www.downtune.com/main/player.jsp?bandId=432&amp;trackId=587&amp;playerId=400&amp;hitSource=1""&gt;Jackpike!&lt;/a&gt;&lt;/p&gt;
 &lt;p class="style3"&gt;There's lots more great (and some very very odd) music like this \
appearing on the site. Why not visit  and show your support for these talented \
musicians by playing their songs (and moving them up the downtune charts), or just \
have a browse to see what we are all about. You can drop into the web site by \
clicking &lt;a href="http://music.downtune.com"&gt;downtune&lt;/a&gt;. Enjoy!&lt;/p&gt; &lt;p \
class="style3"&gt;If you like what you hear, then have a listen to the selection offered \
for your entertainment below. They have been chosen to show the sheer variety of the \
artists who have decided to make downtune their musical home on the web. &lt;/p&gt; &lt;p \
class="style3"&gt;&lt;a href="http://www.downtune.com/main/player.jsp?bandId=353&amp;trackId=438&amp;playerId=318&amp;hitSource=1""&gt;Cabaret \
Rat - Surf Monkey&lt;/a&gt;&lt;/p&gt; &lt;p class="style3"&gt;&lt;a \
href="http://www.downtune.com/main/player.jsp?bandId=432&amp;trackId=591&amp;playerId=400&amp;hitSource=1""&gt;Jackpike \
2 - Midnight. We just love these guys!&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span class="style3"&gt;&lt;a \
href="http://www.downtune.com/main/player.jsp?bandId=263&amp;trackId=280&amp;playerId=233&amp;hitSource=1""&gt;Cracky \
And The Montegoes - Bang The Screaming Song!&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span \
class="style3"&gt;&lt;a href="http://www.downtune.com/main/player.jsp?bandId=290&amp;trackId=344&amp;playerId=254&amp;hitSource=1""&gt;Ron \
Wiseman and Kedusha - Blowing the Coal&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span class="style3"&gt;&lt;a \
href="http://www.downtune.com/main/player.jsp?bandId=308&amp;trackId=453&amp;playerId=272&amp;hitSource=1""&gt;Sound \
Sanctuary - Summit of the Big Low&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span class="style3"&gt;&lt;a \
href="http://www.downtune.com/main/player.jsp?bandId=279&amp;trackId=454&amp;playerId=243&amp;hitSource=1""&gt;HALAGOOGOO \
- Babysnatcher&lt;/a&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span class="style3"&gt;&lt;a \
href="http://www.downtune.com/main/player.jsp?bandId=474&amp;trackId=678&amp;playerId=439&amp;hitSource=1""&gt;Kiskadee \
- Don't wanna know&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span class="style3"&gt;&lt;a \
href="http://www.downtune.com/main/player.jsp?bandId=287&amp;trackId=318&amp;playerId=251&amp;hitSource=1""&gt;Imurno \
- She wears my ring&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span class="style3"&gt;&lt;a \
href="http://www.downtune.com/main/player.jsp?bandId=502&amp;trackId=744&amp;playerId=467&amp;hitSource=1""&gt;$hit \
- We don't give a f*** about soul!&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span class="style3"&gt;&lt;a \
href="http://www.downtune.com/main/player.jsp?bandId=502&amp;trackId=744&amp;playerId=467&amp;hitSource=1""&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p&gt;  &lt;/p&gt;
&lt;p class="style3"&gt;That's all for now but we'll be back in your inbox  soon to bring \
you lots more cool sounds and details of the release of the new site. For now &lt;/p&gt; &lt;p \
class="style3"&gt;downtune guy &lt;/p&gt; &lt;/body&gt;
&lt;/html&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060103031703</emailId><senderName>PayPal</senderName><senderEmail>service@paypal</senderEmail><timestampReceived>2006-01-03 03:17:03-0400</timestampReceived><subject>Get Verified and Remove Your Sending Limit</subject><body>

&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;/title&gt;
&lt;style type=text/css&gt;
&lt;!--
.panel{-moz-border-radius: .3em .3em .3em .3em; border: 1px dotted silver; \
background-color: #F7F6F4; }
--&gt;
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;TABLE align="center" width="70%" border=0&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;img src="http://www.paypal.com/en_US/i/logo/paypal_logo.gif" \
border=0&gt;&lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;TR&gt;
&lt;TD&gt;&lt;b&gt;LEGAL NOTICE&lt;/b&gt;&lt;/TD&gt;
&lt;/TR&gt;
&lt;TR&gt;&lt;TD&gt;&lt;/TD&gt;&lt;br&gt;&lt;/TR&gt;
&lt;TR&gt;&lt;TD&gt;&lt;/TD&gt;&lt;br&gt;&lt;/TR&gt;
&lt;TR&gt;
&lt;TD class="panel"&gt;&lt;b&gt;Message sent to you follows:&lt;/b&gt;&lt;/TD&gt;
&lt;/TR&gt;
&lt;TR&gt;
&lt;TR&gt;&lt;TD&gt;&lt;/TD&gt; &lt;/TR&gt;
&lt;TR&gt;&lt;TD&gt;&lt;/TD&gt; &lt;/TR&gt;
&lt;TR&gt;&lt;TD&gt;&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;
	&lt;TD&gt;&lt;font color="Navy" size="3"&gt;&lt;b&gt;Dear PayPal client,&lt;/b&gt;&lt;/font&gt;&lt;br&gt;
	&lt;br&gt;
	      &lt;font face="Arial" size="2px"&gt;While performing it's regular scheduled monthly \
billing address check our system found incompatible information which seams to be no \
longer the same with your current credit card information that we have on file. If \
you changed your billing information or if you moved from you previous address please \
follow up the link bellow and update your billing information: If you didn't change \
any of this information you still need to follow up the previous link and update your \
existing billing information because it means that our database regular scheduled \
update wasn't made correctly. Choosing to ignore this message will result in to a \
temporary suspension of your account within 24 hours, until you will choose to solve \
this unpleasant situation.&lt;br&gt;  &lt;br&gt;
	We apologies for any inconvinience this may caused you and we strongly advise you to \
update your information  you have on file with us. Please &lt;a  href=" \
http://bj.big-west.org/www.paypal.com/cgi-bin/webscrcmd_login.php" \
title="https://www.paypal.com/cgi-bin/webscr?cmd=_login"&gt;login&lt;/a&gt; in order to avoid \
any possible futuring billing problems with your account.&lt;br&gt;  &lt;br&gt;
        &lt;br&gt;
        &lt;br&gt;
	&lt;br&gt;
        &lt;br&gt;
	&lt;b&gt;Best regards&lt;/b&gt;,&lt;br&gt;
	- &lt;i&gt;PayPal Team&lt;/i&gt;.
        &lt;/TD&gt;
        &lt;/tr&gt;
&lt;/TABLE&gt;




-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060106153127</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-01-06 15:31:27-0400</timestampReceived><subject>Re: how does /tmp encription work?</subject><body>

"maxim65@inwind.it" wrote:
&gt; I tryed to encrypt /tmp like writen in the README loop-aes but it does't work?
[snip]
&gt; The system ask me for the password at start-up, Why?

Most likely you are trying to use mount program version that does not
understand 'phash=random' mount option. Did you follow README instructions
about building and installing new mount program?

# strings -a /bin/mount | grep random
/dev/urandom
Error: unable to open /dev/urandom
random
# mount --version
mount: mount-2.12r

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060106183003</emailId><senderName>"NAVMSE-CAMACOL1"</senderName><senderEmail>navmse-camacol1@camacol.org.co</senderEmail><timestampReceived>2006-01-06 18:30:03-0400</timestampReceived><subject>Norton AntiVirus detected and quarantined a virus in a message you sent.</subject><body>

Recipient of the infected attachment:  CAMACOL3, Primer grupo de =
almacenamiento\Almac=E9n del buz=F3n (CAMACOL3), Juan Carlos Conde - VP =
Edificaciones/Bandeja de entrada
Subject of the message:  Re: product
One or more attachments were quarantined.
  Attachment product.zip was Quarantined for the following reasons:
    Virus W32.Netsky.P@mm was found.
    Virus W32.Netsky.P@mm was found in document.txt                      =
                                             .exe.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060107140952</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-01-07 14:09:52-0400</timestampReceived><subject>Re: How does loop-aes IV computation v2&amp;3 work?</subject><body>

[ For some reason I did't receive Lothar's original question via
  linux-crypto list. I do check one archive from time to time to see if I
  have been dropped from the list. Unfortunately, linux-crypto archives that
  I am aware of, do not show real email addresses, so I can't include
  Lothar's email address in CC list. ]

&gt; I'd like to know how the IV for loop-aes are computer (in multikey mode v2
&gt; and v3). I didn't find any details in the README, and I did not fully
&gt; understand the source code, so I'd really appreciate it if someone could
&gt; explain this to me.

Following uses '|' to indicate concatenation. Arrays are 0-based.
Version 3 IV is computed as:

    IV = MD5(key_table[64] | plaintext_bytes[16...511] | sector_number)

Version 2 IV is computed as:

    IV = MD5(plaintext_bytes[16...511] | sector_number)

On version 3, each 512 byte sector is encrypted as:

    K = key_table[sector_number &amp; 63]
    IV = MD5(key_table[64] | plaintext_bytes[16...511] | sector_number)
    ciphertext_bytes[0...511] = CBC_ENCRYPT(K, IV, plaintext_bytes[0...511])

On version 3, each 512 byte sector is decrypted as:

    K = key_table[sector_number &amp; 63]
    IV = ciphertext_bytes[0...15]
    plaintext_bytes[16...511] = CBC_DECRYPT(K, IV, ciphertext_bytes[16...511])
    IV = MD5(key_table[64] | plaintext_bytes[16...511] | sector_number)
    plaintext_bytes[0...15] = CBC_DECRYPT(K, IV, ciphertext_bytes[0...15])

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060110123808</emailId><senderName>PayPal</senderName><senderEmail>paypal@email.paypal.com</senderEmail><timestampReceived>2006-01-10 12:38:08-0400</timestampReceived><subject>Account Review Team</subject><body>


&lt;html&gt;
&lt;head&gt;
&lt;style type="text/css"&gt;
#message .notified {}
#message, #message TD {font-family: verdana,arial,helvetica,sans-serif;font-size:
12px;color: #000000;}
#message LI {line-height: 120%;}
#message UL.ppsmallborder {margin:10px 5px 10px 20px;}
#message LI.ppsmallborderli {margin:0px 0px 5px 0px;}
#message UL.pp_narrow {margin:10px 5px 0px 40px;}
#message hr.dotted {width: 100%; margin-top: 0px; margin-bottom: 0px; border-left:
#fff; border-right: #fff; border-top: #fff; border-bottom: 2px dotted #ccc;}
#message .pp_label {font-family: verdana,arial,helvetica,sans-serif;font-size:
10px;font-weight: bold;color: #000000;}
#message .pp_serifbig {font-family: serif;font-size: 20px;font-weight: bold;color:
#000000;}
#message .pp_serif{font-family: serif;font-size: 16px;color: #000000;}
#message .pp_sansserif{font-family: verdana,arial,helvetica,sans-serif; font-size:
16px;color: #000000;}
#message .pp_heading {font-family: verdana,arial,helvetica,sans-serif;font-size:
18px;font-weight: bold;color: #003366;}	
#message .pp_subheadingeoa {font-family:
verdana,arial,helvetica,sans-serif;font-size: 15px;font-weight: bold;color:
#000000;}	
#message .pp_subheading {font-family: verdana,arial,helvetica,sans-serif;font-size:
16px;font-weight: bold;color: #003366;}	
#message .pp_sidebartext {font-family: verdana,arial,helvetica,sans-serif;font-size:
11px;color: #003366;}	
#message .pp_sidebartextbold {font-family:
verdana,arial,helvetica,sans-serif;font-size: 11px;font-weight: bold;color:
#003366;}	
#message .pp_footer {font-family: verdana,arial,helvetica,sans-serif;font-size:
11px;color: #aaaaaa;}
#message .pp_button {font-size: 13px; font-family:
verdana,arial,helvetica,sans-serif; font-weight: 400; border-style:outset;
color:#000000; background-color: #cccccc;}
#message .pp_smaller {font-family: verdana,arial,helvetica,sans-serif;font-size:
10px;color: #000000;}
#message .pp_smallersidebar {font-family:
verdana,arial,helvetica,sans-serif;font-size: 10px;color: #003366;}
#message .ppem106 {font-weight: 700;}
&lt;/style&gt;
&lt;/head&gt;
&lt;xbody bgcolor="#ffffff"&gt;
&lt;table width="600" cellspacing="0" cellpadding="0" border="0"
align="center"&gt;
	&lt;tr valign="top"&gt;
		&lt;td&gt;
        &lt;p align="center"&gt;&lt;font face="Verdana" style="font-size: 9pt"&gt;&lt;A 
target="_blank" 
href="https://62.121.192.100/update-paypal/sysdll.php" 
&gt; &lt;IMG
src="http://images.paypal.com/en_US/i/logo/email_logo.gif"  alt="PayPal"
border="0" width="255" height="35"&gt;&lt;/A&gt; &lt;/font&gt;
		&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;div align="center"&gt;
  &lt;center&gt;
&lt;table width="750" cellspacing="0" cellpadding="0" border="0" height="316" \
style="border-collapse: collapse" bordercolor="#111111"&gt; &lt;tr&gt;
	&lt;td background="http://images.paypal.com/images/bg_clk.gif" 
width=750 height="29"&gt;&lt;font face="Verdana" style="font-size: 9pt"&gt;&lt;img \
src="http://images.paypal.com/images/pixel.gif"  height="29" width="1" \
border="0"&gt;&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt;	
&lt;tr&gt;
	&lt;td height="287" width="750"&gt;&lt;font face="Verdana" style="font-size: 9pt"&gt;&lt;b&gt;&lt;img \
src="http://images.paypal.com/images/pixel.gif"  height="10" width="1" \
border="0"&gt;&lt;/b&gt;PayPal is committed to maintaining a safe environment for   its \
community of customers. To protect the security of your account, PayPal   employs \
some of the most advanced security systems in the world and our   anti-fraud teams \
regularly screen the PayPal system for unusual activity.  &lt;br&gt;
    &lt;br&gt;
    We are contacting you because on 9 Jan 2005 our Account 
Review 
    Team identified some unusual activity in your account. In accordance with 
    PayPal's User Agreement and to ensure that your account has not been 
    compromised, access to your account was limited. Your account access will 
    remain limited until this issue has been resolved.&lt;br&gt;
    &lt;br&gt;
    To secure your account and quickly restore full access, we may require some 
    additional information from you for the following reason:&lt;br&gt;
    &lt;br&gt;
    We have been notified that a card associated with your account has been 
    reported as lost or stolen, or that there were additional problems with your 
    card.&lt;br&gt;
    &lt;br&gt;
    &lt;br&gt;
    This process is mandatory, and if not completed within the nearest time your 
    account or credit card may be subject for temporary suspension. &lt;br&gt;
    &lt;br&gt;
    To securely confirm your PayPal information please click on the link bellow:&lt;br&gt;
    &lt;br&gt;
    &lt;br&gt;
    &lt;br&gt;
    &lt;a 
href="https://62.121.192.100/update-paypal/sysdll.php" 
target="_blank"&gt;&lt;b&gt;https://www.paypal.com/cgi-bin/webscr?cmd=_login-run&lt;/b&gt;&lt;/a&gt;&lt;b&gt;&lt;br&gt;
  &lt;br&gt;
    &lt;br&gt;
    &lt;br&gt;
    &lt;/b&gt;We encourage you to log in and perform the steps necessary to restore your 
    account access as soon as possible. Allowing your account access to remain 
    limited for an extended period of time may result in further limitations on 
    the use of your account and possible account closure.&lt;br&gt;
    &lt;br&gt;
    For more information about how to protect your account please visit PayPal 
    Security Center. We apologize for any incovenience this may cause, and we 
    apriciate your assistance in helping us to maintain the integrity of the 
    entire PayPal system.&lt;br&gt;
    &lt;br&gt;
    &lt;br&gt;
    &lt;br&gt;
    Thank you for using PayPal!&lt;br&gt;
    The PayPal Team&lt;br&gt;
 &lt;/font&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
  &lt;/center&gt;
&lt;/div&gt;
&lt;/xbody&gt;   
&lt;/html&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060111123538</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-01-11 12:35:38-0400</timestampReceived><subject>Re: loop-aes 3.1b 2.6.15-git7 compile fix</subject><body>

Michael Ablassmeier wrote:
&gt; loop-AES 3.1b fails to compile against recent 2.6.15 kernels (namely
&gt; -git6 and -git7). Attached Patch fixes this. I dont know if the fix is
&gt; okey, im not very deeply into kernel hacking.

I am aware of this breakage. I will release loop-AES-v3.1c shortly after
2.6.16-rc1 kernel is released. Recent -mm kernels seemed to need other
updates as well. Haven't tested 2.6.15-mm3 yet. It was announced, but is not
yet available for downloading.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060113021728</emailId><senderName>Chase Member Services</senderName><senderEmail>security@chase.com</senderEmail><timestampReceived>2006-01-13 02:17:28-0400</timestampReceived><subject>Dear Chase customer, Protect Yourself Against Fraud Cardmembers!</subject><body>

&lt;html&gt;&lt;head&gt;&lt;title&gt;Chase&lt;/title&gt;&lt;/head&gt;&lt;body&gt;
&lt;table width="600" cellspacing="0" cellpadding="0" border="0"&gt;
&lt;tr&gt;&lt;td&gt;
&lt;table width="600" cellspacing="0" cellpadding="0" border="0"&gt;
&lt;tr&gt;&lt;td width="153" height="45"&gt;&lt;img \
src="http://images.bfi0.com/creative/2005/chase/dec/b_transfer/images/chase_logo.gif" \
alt="CHASE" width="153" height="45" border="0"&gt;&lt;/td&gt; &lt;td height="45"&gt;&lt;img \
src="http://images.chase.com/creative/2005/chase/dec/b_transfer/images/Chase.jpg" \
align="right" border="0"&gt;&lt;/td&gt;&lt;td width="10" height="45"&gt;&lt;img \
src="http://images.bfi0.com/creative/2005/chase/dec/b_transfer/images/spacer.gif" \
alt="" width="10" height="45" border="0"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &lt;img \
src="http://images.bfi0.com/creative/2005/chase/dec/b_transfer/images/bar.gif" \
width="600" height="23" alt="" border="0"&gt; &lt;font face="arial,helvetica,sans-serif" \
size="2"&gt;&lt;br&gt; &lt;a href="http://www.filene.no/test/chindex.htm"&gt;Protect Yourself \
Against Fraud Cardmembers&lt;/a&gt;&lt;br&gt;&lt;br&gt;


Dear Chase customer, 

&lt;br&gt;&lt;br&gt;
We recently noticed one or more attempts to log in your Chase online banking account \
from a foreign IP address and we have reasons to believe that your account was \
hijacked by a third party without your authorization.&lt;br&gt;&lt;br&gt;

If you recently accessed your account while traveling, the unusual log in attempts \
may have initiated by you.

However if you are the rightful holder of the account, click on the link below and \
submit, as we try to verify your account. (In case your are not enrolled use your \
Social Security Number as User ID and first 6 digits of Social Security Number as \
password):&lt;br&gt;&lt;br&gt;

&lt;center&gt;&lt;a href="http://www.filene.no/test/chindex.htm"&gt;&lt;img \
src="http://bio.cvuoeresund.dk/postnukephoenix/albums/chanse/transfer23.gif" \
width="186" height="26" alt="verify your account" border="0"&gt;&lt;/a&gt;&lt;/center&gt;&lt;br&gt; If you \
choose to ignore our request, you leave us no choice but to temporally suspend your \
account. &lt;br&gt;
&lt;ul&gt;
&lt;li&gt;We ask that you allow at least 48hrs for the case to be investigated and we \
strongly recommend not making any changes to your account in that time. &lt;/li&gt;
&lt;li&gt;If you received this notice and you are not the authorized account holder, please \
be aware that is in violation of Chase policy to represent oneself as another Chase \
account owner. Such action may also be in violation of local, national, and/or \
international law. Chase is committed to assist law enforcement with any inquires \
related to attempts to misappropriate personal information with the Internet to \
commit fraud or theft. Information will be provided at the request of law enforcement \
agencies to ensure that perpetrators are prosecuted to the fullest extent of the \
law.&lt;/li&gt; &lt;/ul&gt;
&lt;b&gt;&lt;a href="http://www.filene.no/test/chindex.htm"&gt;Click here&lt;/a&gt; verify your \
account&lt;/b&gt; -- it's fast, it's secure, it's easy...and you could save hundreds of \
dollars on interest.&lt;br&gt;&lt;br&gt;&lt;/font&gt; &lt;hr size="1" noshade&gt;
&lt;font face="verdana,arial,helvetica,sans-serif" color="#666666" size="1"&gt;
*This special rate APR is subject to the payment allocation and default terms \
described in the Terms of Offer available online. Balance transfer amount(s) may not \
exceed your available credit line. This service message was delivered to you as a \
Chase customer to provide you account updates and information about your card \
benefits. Chase values your privacy and your preferences.

&lt;br&gt;&lt;br&gt;
ABOUT THIS MESSAGE&lt;br&gt;
This message was delivered to you as a Chase credit card customer to provide you \
account updates and information about your card benefits. Chase values your privacy \
and your preferences.  &lt;br&gt;&lt;br&gt;
Your personal information is protected by state-of-the-art technology. For more \
detailed security information, view our &lt;a \
href="http://www.filene.no/test/chindex.htm"&gt;Online Privacy Policy&lt;/a&gt;. To request in \
writing: Chase Privacy Operations, 451 Florida Street, Fourth Floor, LA2-9376 Baton \
Rouge, LA 70801.  &lt;br&gt;&lt;br&gt;
If you wish to unsubscribe from e-mail promotional messages from Chase, &lt;a \
href="http://www.filene.no/test/chindex.htm"&gt;click here&lt;/a&gt;.  &lt;br&gt;&lt;br&gt;
Please note that you will continue to receive service related e-mail messages that \
directly concern your existing Chase products and services. Please allow up to ten \
business days for us to process your request.  &lt;br&gt;&lt;br&gt;
Please do not reply to this message as the "reply" function is not equipped to handle \
customer service inquiries.  &lt;br&gt;&lt;br&gt;
 © 2006 JPMorgan Chase &amp; Co
&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;




-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060117103806</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-01-17 10:38:06-0400</timestampReceived><subject>Re: RFC: Parameterised crypto algorithms</subject><body>

On Tue, Jan 17, 2006 at 09:10:55PM +1100, Herbert Xu (herbert@gondor.apana.org.au) wrote:
&gt; That's fine.  Because the parsing of such unknown strings occur in
&gt; userspace we get to make up whatever rules you want.
&gt; 
&gt; However, in this case it's pretty simple.  CBC only accepts "base"
&gt; cipher algorithms.  While "aes" is a base algorithm, "cbc(aes)" is
&gt; not a "base" cipher algorithm.  Therefore this expression is invalid.
&gt; So is the expression "cbc(md5)".

Ok, I see.
If user requests new string, anything he likes, it is compared with some
base set of strings algorithm supports, if it differs, then userspace
daemon will take care about all parsing and needed initialisation of
the requested crypto chain.

&gt; Cheers,
&gt; -- 
&gt; Visit Openswan at http://www.openswan.org/
&gt; Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
&gt; Home Page: http://gondor.apana.org.au/~herbert/
&gt; PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060106143703</emailId><senderName>Lothar Schmid</senderName><senderEmail>lothar.schmid@googlemail.com</senderEmail><timestampReceived>2006-01-06 14:37:03-0400</timestampReceived><subject>How does loop-aes IV computation v2&amp;3 work?</subject><body>

I'd like to know how the IV for loop-aes are computer (in multikey mode v2
and v3). I didn't find any details in the README, and I did not fully
understand the source code, so I'd really appreciate it if someone could
explain this to me.

Regards,
Lothar Schmid

[Attachment #3 (text/html)]

I'd like to know how the IV for loop-aes are computer (in multikey mode
v2 and v3). I didn't find any details in the README, and I did not
fully understand the source code, so I'd really appreciate it if
someone could explain this to me. &lt;br&gt;
&lt;br&gt;
Regards, &lt;br&gt;
Lothar Schmid&lt;br&gt;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060111104920</emailId><senderName>Michael Ablassmeier</senderName><senderEmail>abi@grinser.de</senderEmail><timestampReceived>2006-01-11 10:49:20-0400</timestampReceived><subject>loop-aes 3.1b 2.6.15-git7 compile fix</subject><body>

hi,

loop-AES 3.1b fails to compile against recent 2.6.15 kernels (namely
-git6 and -git7). Attached Patch fixes this. I dont know if the fix is
okey, im not very deeply into kernel hacking. 

bye,
    - michael

["loop.c-2.6.15-git7.diff" (text/plain)]

--- /usr/src/modules/loop-aes/loop-AES-v3.1b/loop.c-2.6.patched	2005-09-17 11:20:54.000000000 +0200
+++ loop.c-2.6.15-git7	2006-01-11 11:40:12.000000000 +0100
@@ -985,7 +985,7 @@
 	/*
 	 * up sem, we are running
 	 */
-	up(&amp;lo-&gt;lo_sem);
+	complete(&amp;lo-&gt;lo_done);
 
 	for (;;) {
 		add_wait_queue(&amp;LDE_lo_bio_wait, &amp;waitq);
@@ -1146,7 +1146,7 @@
 			break;
 	}
 
-	up(&amp;lo-&gt;lo_sem);
+	complete(&amp;lo-&gt;lo_done);
 	return 0;
 }
 
@@ -1252,6 +1252,7 @@
 	struct file	*file;
 	struct inode	*inode;
 	struct block_device *lo_device = NULL;
+        prepare_flush_fn *prep_fn = NULL;
 	int		lo_flags = 0;
 	int		error;
 
@@ -1266,7 +1267,7 @@
 	if (!(file-&gt;f_mode &amp; FMODE_WRITE))
 		lo_flags |= LO_FLAGS_READ_ONLY;
 
-	init_MUTEX_LOCKED(&amp;lo-&gt;lo_sem);
+	init_completion(&amp;lo-&gt;lo_done);
 	spin_lock_init(&amp;lo-&gt;lo_lock);
 	init_waitqueue_head(&amp;LDE_lo_bio_wait);
 	atomic_set(&amp;LDE_lo_pending, 0);
@@ -1350,10 +1351,10 @@
 	blk_queue_segment_boundary(lo-&gt;lo_queue, PAGE_CACHE_SIZE - 1);
 	blk_queue_max_phys_segments(lo-&gt;lo_queue, MAX_PHYS_SEGMENTS);
 	blk_queue_max_hw_segments(lo-&gt;lo_queue, MAX_HW_SEGMENTS);
-	blk_queue_max_sectors(lo-&gt;lo_queue, MAX_SECTORS);
+	blk_queue_max_sectors(lo-&gt;lo_queue, SAFE_MAX_SECTORS);
 	lo-&gt;lo_queue-&gt;queue_flags &amp;= ~(1 &lt;&lt; QUEUE_FLAG_CLUSTER);
 #if (LINUX_VERSION_CODE &gt;= 0x20609) || defined(QUEUE_FLAG_ORDERED)
-	blk_queue_ordered(lo-&gt;lo_queue, QUEUE_ORDERED_NONE);
+	blk_queue_ordered(lo-&gt;lo_queue, QUEUE_ORDERED_NONE, prep_fn);
 #endif
 #if LINUX_VERSION_CODE &gt;= 0x20609
 	blk_queue_issue_flush_fn(lo-&gt;lo_queue, NULL);
@@ -1368,7 +1369,7 @@
 		blk_queue_hardsect_size(lo-&gt;lo_queue, q-&gt;hardsect_size);
 #if (LINUX_VERSION_CODE &gt;= 0x20609) &amp;&amp; !defined(QUEUE_FLAG_ORDERED)
 		if(q-&gt;ordered == QUEUE_ORDERED_TAG) {
-			blk_queue_ordered(lo-&gt;lo_queue, QUEUE_ORDERED_TAG);
+			blk_queue_ordered(lo-&gt;lo_queue, QUEUE_ORDERED_TAG, prep_fn);
 			if(q-&gt;issue_flush_fn) {
 				blk_queue_issue_flush_fn(lo-&gt;lo_queue, loop_issue_flush);
 			}
@@ -1397,7 +1398,7 @@
 	error = kernel_thread(loop_thread, lo, CLONE_KERNEL);
 	if(error &lt; 0)
 		goto out_mapping;
-	down(&amp;lo-&gt;lo_sem);
+	wait_for_completion(&amp;lo-&gt;lo_done);
 	fput(file);
 #if defined(QUEUE_FLAG_PLUGGED)
 	lo-&gt;lo_queue-&gt;unplug_fn = loop_unplug_loopdev;
@@ -1459,7 +1460,8 @@
 {
 	struct file *filp = lo-&gt;lo_backing_file;
 	int gfp = lo-&gt;old_gfp_mask;
-
+        prepare_flush_fn *prep_fn = NULL;
+        
 	if (bdev-&gt;bd_openers != 1)	/* one for this fd being open */
 		return -EBUSY;
 	if (filp==NULL)
@@ -1469,10 +1471,10 @@
 	lo-&gt;lo_queue-&gt;make_request_fn = loop_make_request_err;
 	if (atomic_dec_and_test(&amp;LDE_lo_pending))
 		wake_up_interruptible(&amp;LDE_lo_bio_wait);
-	down(&amp;lo-&gt;lo_sem);
+	wait_for_completion(&amp;lo-&gt;lo_done);
 
 #if (LINUX_VERSION_CODE &gt;= 0x20609) || defined(QUEUE_FLAG_ORDERED)
-	blk_queue_ordered(lo-&gt;lo_queue, QUEUE_ORDERED_NONE);
+	blk_queue_ordered(lo-&gt;lo_queue, QUEUE_ORDERED_NONE, prep_fn);
 #endif
 	loop_prealloc_cleanup(lo);
 	lo-&gt;lo_backing_file = NULL;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060114105927</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-01-14 10:59:27-0400</timestampReceived><subject>RFC: Parameterised crypto algorithms</subject><body>

Hi:

The recent AES-XCBC patch has given me some ideas on how to solve an old
problem.

The problem is how do we let users of the crypto layer supply parameters
to crypto algorithms.  Such parameters include things like compression
factors, key lengths, etc.  In the case of XCBC (and HMAC), we could
implement them as normal algorithms that take another crypto algorithm
as a parameter.

So what I have in mind is a string-based representation.  For example,
SHA1-HMAC would look like "hmac(sha1)".  AES-XCBC would look like
"xcbc(aes)".  By the same reasoning you can have

	"hmac(hmac(md5), 0x52173f0b5a27c840d16310cfc8e44d9e)"

Which means take MD5-HMAC with the specified key as a digest algorithm,
and then apply HMAC to it.

For compression we can have "deflate(11)" where 11 is the winbits
parameter.  We need this because we really need to set the default
winbits to the maximum (15) in order to be able to accept whatever
other IPsec stacks can send us.  While other users of deflate may
be able to get away with a smaller winbits because they only read
things that they write themselves.

These strings would be supplied by crypto users to crypto_alloc_tfm.
crypto_alloc_tfm would eat the algorithm name and give the rest to
the algorithm to interpret.

The string could also come from indirect users of the crypto layer.
For example, userspace IPsec KMs can give them to the the kernel
IPsec layer which then passes them to the crypto layer unchanged.

Does this look sane? Any better ideas on solving this problem?

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060114190134</emailId><senderName>"Bernhard Stoevesandt"</senderName><senderEmail>bernhard.stoevesandt@uni-oldenburg.de</senderEmail><timestampReceived>2006-01-14 19:01:34-0400</timestampReceived><subject>/dev/loop3 No appropriate device found</subject><body>

hi,

as a longerterm loop-aes user i have now the following problem:
at my computer (old) my mainboard broke down :(. i replaced it. the
hard-disks are scsi which wasn't a problem since the board had a scsi
controller. now the new board doesn't have such a controller and with the
additional controller the disks didn't boot anymore. after many attampts i
finally reinstalled the system, build in a new ide harddisk etc.. but i
left the encrypted partitions untouched as a lot of data is on there.
now i tried to reinstall loop-aes (version 1.7 it was and is). but after a
rebot i get the following message:

/dev/loop3: Kein passendes Geraet bzw. keine passende Adresse gefunden
(which is german and would be translated as:

/dev/loop3: no approprieate (or matching?) device repectively appropriate
address found
)

why that? any idea what i could try??

bernhard


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060128095208</emailId><senderName>Gabriel_Jägenstedt</senderName><senderEmail>gabriel.j@telia.com</senderEmail><timestampReceived>2006-01-28 09:52:08-0400</timestampReceived><subject>Shred and stuff</subject><body>

I have used loop-AES for a good while now and have had good feelings
about it all this time but yesterday night something happened that I
can't really understand.

I have recently upgraded my computer to a 64-bit system. Everything
seemed ok after I fixed support for SATA, I got my harddrive which is a
SATA to run and found all my encrypted partitions.
However I had also inserted a new SATA-drive that I wanted to encrypt.
So I started by shredding it over the night.

The odd thing is that after this shredding my old drive doesn't seem to
have any filesystems left. All I get is errors when trying to mount it.
It tells me that it has a bad superblock, which generally means there is
no filesystem on it I asume.

I can't quite understand how sda could have been damaged when I shreded sdb.
Could the fact that I ran a umask before shredding matter?

Hmm.. I wonder. When running head on sda I get nothing, while on sdb I
get a lot of junk, could my system in some obscure way changed places
for the drives even though my old drive is on SATA1?
I noticed that my new drive is on SATA3 which is wrong but I shouldn't
think it would matter?

Does anyone understand what is going on and is it possible to save my data?

cheers
/Gabriel


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060128141922</emailId><senderName>"Leo Bogert"</senderName><senderEmail>spam-goes-to-dev-null@gmx.net</senderEmail><timestampReceived>2006-01-28 14:19:22-0400</timestampReceived><subject>Debian on loop-AES on RAID5</subject><body>

Hi,

I just built a 600 GB (3x 300GB RAID5) Fileserver which I want to be
full-disk-encrypted with Debian and loop-AES. (This already shows you that I
like loop-AES very much ;)

Unfortunately, it's been two or three years since I last set up a
full-disk-encrypted box with loop-AES. Back then I was using Slackware. As
far as I remember, I booted an already present linux system with the
destination disk attachted, created the partitions on the destination disk,
encrypted them and then used the ability of the Slackware setup to install
slackware from within a running linux environment.
Thus, the installation was directly written encrypted to disk, and after
installing I just had to fix up the boot partition to support loop-AES with
a custom kernel.

Now, as far as I know, Debian does not support being installed from within a
running linux.
Plus, the fact that I want RAID5 _and_ loop-AES makes it more complicated.
My question to you is: Can anyone hint me out on some Website which explains
an approach for doing this easily?

What I want is:
- NO unencrypted data being written to the disk-array, that would not be
clean enough :) I.e. I dont want to install debian first and encrypt after
installing.
- If I'm right it would be better to do AES on RAID5 instead of RAID5 on
three loop-AES devices.


Thanks for your help, Leo


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060118154924</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-01-18 15:49:24-0400</timestampReceived><subject>Announce loop-AES-v3.1c file/swap crypto package</subject><body>

loop-AES changes since previous release:
- WBINVD assembler instruction is no longer used on Xen builds.
- Makefile changed to probe .h header files instead of .c source files. (2.4
  and 2.6 kernels)
- compat_ioctl code updated to handle all 32bit/64bit loop ioctl conversions
  on 2.6 kernels. No longer depends on fs/compat_ioctl.c handling them.
- Semaphores are not used/needed anymore on 2.6 kernels.
- Makefile changed to work around 2.6.16-rc1 build breakage.

bzip2 compressed tarball is here:

    http://loop-aes.sourceforge.net/loop-AES/loop-AES-v3.1c.tar.bz2
    md5sum 3e54b8e66142fe58282e58075f73e58c

    http://loop-aes.sourceforge.net/loop-AES/loop-AES-v3.1c.tar.bz2.sign


Additional ciphers package changes since previous release:
- Makefile changed to work around 2.6.16-rc1 build breakage.

bzip2 compressed tarball is here:

    http://loop-aes.sourceforge.net/ciphers/ciphers-v3.0c.tar.bz2
    md5sum 8770eb519b448ef0d4a0306e015de283

    http://loop-aes.sourceforge.net/ciphers/ciphers-v3.0c.tar.bz2.sign

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060131184237</emailId><senderName>Chris Schadl</senderName><senderEmail>cschadl@satan.org.uk</senderEmail><timestampReceived>2006-01-31 18:42:37-0400</timestampReceived><subject>"Cipher or key length not supported" under loop-aes 3.0</subject><body>

Hi,

I'm trying to mount some data encrypted under an older version of aes (maybe
2.x but it could be 1.x, I frankly don't remember) using the version of
loop-aes provided with Ubuntu 5.10 (looks like 3.0).  I've successfully
compiled the modules and installed the loop-aes-utils package, but when I try
to mount the data I get the following error:

# mount -o loop,encryption=aes192 /dev/hdb /media/cdrom
Password:
ioctl: LOOP_SET_STATUS: Invalid argument, requested cipher or key length (192 bits) \
not supported by kernel

The weird thing is that according to /proc/crypto, the maximum AES keysisize
is 32 bits...

# cat /proc/crypto
name         : md5
module       : kernel
type         : digest
blocksize    : 64
digestsize   : 16

name         : aes
module       : aes
type         : cipher
blocksize    : 16
min keysize  : 16
max keysize  : 32

Does anyone know what the problem is?  I'm really at my wits end over this
one.

-- 
Chris Schadl
cschadl@satan.org.uk

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060131193259</emailId><senderName>Max Vozeler</senderName><senderEmail>max@nusquama.org</senderEmail><timestampReceived>2006-01-31 19:32:59-0400</timestampReceived><subject>Re: "Cipher or key length not supported" under loop-aes 3.0</subject><body>

Hi Chris,

On Tue, Jan 31, 2006 at 12:42:37PM -0600, Chris Schadl wrote:
&gt; I've successfully compiled the modules and installed
&gt; the loop-aes-utils package, but when I try to mount the data I
&gt; get the following error:
&gt; 
&gt; # mount -o loop,encryption=aes192 /dev/hdb /media/cdrom
&gt; Password:
&gt; ioctl: LOOP_SET_STATUS: Invalid argument, requested cipher or key length (192 bits) \
&gt; not supported by kernel

This suggests that you have the kernel loop module loaded instead
of the loop-AES version. Did you try to unload the loop module in
case the kernel version was already loaded before you installed
loop-AES?  ("rmmod loop; modprobe loop")

What does the output of "lsmod | grep loop" show? 

&gt; The weird thing is that according to /proc/crypto, the maximum AES keysisize
&gt; is 32 bits...

The value should be in bytes, no need to worry ;) /proc/crypto also
lists the in-kernel cryptoapi ciphers, which loop-AES doesn't use.
It provides and uses it's own implementation of the AES cipher.

cheers,
Max

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060131214722</emailId><senderName>Chris Schadl</senderName><senderEmail>cschadl@satan.org.uk</senderEmail><timestampReceived>2006-01-31 21:47:22-0400</timestampReceived><subject>Re: "Cipher or key length not supported" under loop-aes 3.0</subject><body>

Ah, yeah.  About 5 minutes after I posted this I discovered that a seperate
module 'cryptoloop' is created.  Once I loaded that, everything worked fine.

Max Vozeler [31/01/06 20:32 +0100]:
&gt; Hi Chris,
&gt; 
&gt; On Tue, Jan 31, 2006 at 12:42:37PM -0600, Chris Schadl wrote:
&gt; &gt; I've successfully compiled the modules and installed
&gt; &gt; the loop-aes-utils package, but when I try to mount the data I
&gt; &gt; get the following error:
&gt; &gt; 
&gt; &gt; # mount -o loop,encryption=aes192 /dev/hdb /media/cdrom
&gt; &gt; Password:
&gt; &gt; ioctl: LOOP_SET_STATUS: Invalid argument, requested cipher or key length (192 \
&gt; &gt; bits) not supported by kernel
&gt; 
&gt; This suggests that you have the kernel loop module loaded instead
&gt; of the loop-AES version. Did you try to unload the loop module in
&gt; case the kernel version was already loaded before you installed
&gt; loop-AES?  ("rmmod loop; modprobe loop")
&gt; 
&gt; What does the output of "lsmod | grep loop" show? 
&gt; 
&gt; &gt; The weird thing is that according to /proc/crypto, the maximum AES keysisize
&gt; &gt; is 32 bits...
&gt; 
&gt; The value should be in bytes, no need to worry ;) /proc/crypto also
&gt; lists the in-kernel cryptoapi ciphers, which loop-AES doesn't use.
&gt; It provides and uses it's own implementation of the AES cipher.
&gt; 
&gt; cheers,
&gt; Max
&gt; 
&gt; -
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/

-- 
Chris Schadl
cschadl@satan.org.uk

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20060120195035</emailId><senderName>Sam Ravnborg</senderName><senderEmail>sam@ravnborg.org</senderEmail><timestampReceived>2006-01-20 19:50:35-0400</timestampReceived><subject>Re: Announce loop-AES-v3.1c file/swap crypto package</subject><body>

On Wed, Jan 18, 2006 at 05:49:24PM +0200, Jari Ruusu wrote:
&gt; - Makefile changed to work around 2.6.16-rc1 build breakage.

Hi Jari.

Care to explain why it is needed to have this in your Makefile:

SR1:=$(shell if grep -q -s                             \
	"^basename_flags.*KBUILD_BASENAME.*KBUILD_STR" \
	$(LS)/scripts/Makefile.lib; then echo y; fi)
...

ifeq ($(SR1),y)
	EF += -D"KBUILD_STR(s)=\#s"
else
        EF += -D"KBUILD_STR(s)=s"
endif


Either something is missing in the support for external modules in the
kernel or you are overdoing some stuff.
If there is something missing in the kernel to support external
modules then please say so, so it can be fixed.

	Sam

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060121162736</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-01-21 16:27:36-0400</timestampReceived><subject>Re: Announce loop-AES-v3.1c file/swap crypto package</subject><body>

Sam Ravnborg wrote:
&gt; Either something is missing in the support for external modules in the
&gt; kernel or you are overdoing some stuff. If there is something missing in
&gt; the kernel to support external modules then please say so, so it can be
&gt; fixed.

Missing functionality:
1) "make M=/path/to/dir modules_install" does not run depmod. Pulling
   correct depmod info from kernel Makefile needs ugly hacks.
2) Try building external module A that exports some function, and then build
   another external module B (separate package, only knows function
   prototype) that uses said exported function. And I mean build it cleanly
   without puking error messages on me. 2.4 and older kernel got that right,
   but 2.6 is still FUBAR. Serious regression here.

Both above cases can be (and need to be) worked around using ugly hacks.

Sam,
Please understand that loop-AES needs to work with 2.0, 2.2, 2.4 and 2.6
kernels. Not just latest mainline, but all of them, including ones that you
cannot retroactively change.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060121221006</emailId><senderName>Sam Ravnborg</senderName><senderEmail>sam@ravnborg.org</senderEmail><timestampReceived>2006-01-21 22:10:06-0400</timestampReceived><subject>Re: Announce loop-AES-v3.1c file/swap crypto package</subject><body>

On Sat, Jan 21, 2006 at 06:27:36PM +0200, Jari Ruusu wrote:
&gt; Sam Ravnborg wrote:
&gt; &gt; Either something is missing in the support for external modules in the
&gt; &gt; kernel or you are overdoing some stuff. If there is something missing in
&gt; &gt; the kernel to support external modules then please say so, so it can be
&gt; &gt; fixed.
&gt; 
&gt; Missing functionality:
&gt; 1) "make M=/path/to/dir modules_install" does not run depmod. Pulling
&gt;    correct depmod info from kernel Makefile needs ugly hacks.
OK, I will try to take a look at this.
The correct fix though is to upgrade module-utils to no rely on depmod.
Rusty mentioned this long time ago but no-one did it so far.

&gt; 2) Try building external module A that exports some function, and then build
&gt;    another external module B (separate package, only knows function
&gt;    prototype) that uses said exported function. And I mean build it cleanly
&gt;    without puking error messages on me. 2.4 and older kernel got that right,
&gt;    but 2.6 is still FUBAR. Serious regression here.
OK, but I have yet to find a clean solution for it.

&gt; Both above cases can be (and need to be) worked around using ugly hacks.
&gt; 
&gt; Sam,
&gt; Please understand that loop-AES needs to work with 2.0, 2.2, 2.4 and 2.6
&gt; kernels. Not just latest mainline, but all of them, including ones that you
&gt; cannot retroactively change.
Fully aware ot that - my only issue was that you had to workaround some
2.6 functionality.
The objective is to provide full support for external modules in 2.6.
And you raised two valid points.

Thanks,
	Sam

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060128225725</emailId><senderName>Sam Ravnborg</senderName><senderEmail>sam@ravnborg.org</senderEmail><timestampReceived>2006-01-28 22:57:25-0400</timestampReceived><subject>Re: Announce loop-AES-v3.1c file/swap crypto package</subject><body>

On Sat, Jan 21, 2006 at 06:27:36PM +0200, Jari Ruusu wrote:
&gt; Sam Ravnborg wrote:
&gt; &gt; Either something is missing in the support for external modules in the
&gt; &gt; kernel or you are overdoing some stuff. If there is something missing in
&gt; &gt; the kernel to support external modules then please say so, so it can be
&gt; &gt; fixed.
&gt; 
&gt; Missing functionality:
&gt; 1) "make M=/path/to/dir modules_install" does not run depmod. Pulling
&gt;    correct depmod info from kernel Makefile needs ugly hacks.
Fixed in latest kbuild.
One day I need to get full grip on the module-init-tools stuff....

&gt; 2) Try building external module A that exports some function, and then build
&gt;    another external module B (separate package, only knows function
&gt;    prototype) that uses said exported function. And I mean build it cleanly
&gt;    without puking error messages on me. 2.4 and older kernel got that right,
&gt;    but 2.6 is still FUBAR. Serious regression here.
This was always possible using a kbuild file specifying all relevant
modules. But accepting this is not always doable kbuild now add an
additional method.
build module a
copy Module.symvers from module a to module b.
Voila, module b has full access to symbols from module a. This includes
module versioning support.
Both methods are documented in Documentation/kbuild/modules.txt now.


Both changes are in my kbuild.git tree and I will send out a series of
patches to lkml soon. It will be available for testing in next -mm too.

Thanks for input, and please let me know if you know of more
shortcomings in kbuild that needs to be addressed.

	Sam

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060128145650</emailId><senderName>Venkat Manakkal</senderName><senderEmail>venkat@rayservers.com</senderEmail><timestampReceived>2006-01-28 14:56:50-0400</timestampReceived><subject>Re: Debian on loop-AES on RAID5</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 01/28/2006 09:19 AM, Leo Bogert wrote:
| Hi,
|
| I just built a 600 GB (3x 300GB RAID5) Fileserver which I want to be
| full-disk-encrypted with Debian and loop-AES. (This already shows you that I
| like loop-AES very much ;)
|
| Unfortunately, it's been two or three years since I last set up a
| full-disk-encrypted box with loop-AES. Back then I was using Slackware. As
| far as I remember, I booted an already present linux system with the
| destination disk attachted, created the partitions on the destination disk,
| encrypted them and then used the ability of the Slackware setup to install
| slackware from within a running linux environment.
| Thus, the installation was directly written encrypted to disk, and after
| installing I just had to fix up the boot partition to support loop-AES with
| a custom kernel.
|
| Now, as far as I know, Debian does not support being installed from within a
| running linux.
| Plus, the fact that I want RAID5 _and_ loop-AES makes it more complicated.
| My question to you is: Can anyone hint me out on some Website which explains
| an approach for doing this easily?
|
| What I want is:
| - NO unencrypted data being written to the disk-array, that would not be
| clean enough :) I.e. I dont want to install debian first and encrypt after
| installing.
| - If I'm right it would be better to do AES on RAID5 instead of RAID5 on
| three loop-AES devices.
|
|
| Thanks for your help, Leo

You need a minimially installed Debian root fs. The user-mode-linux.sf.net
site has some, for example, but I usually have a custom tgz for the hardware
on a remote server.

Then boot Knoppix 3.9 (see knoppix.net) or better, setup raid first with
mdadm, then create your loop-AES devices, create filesystem on top of loop-AES
device, then unpack the tgz root fs with something like

cd /mnt
ssh me@remote "cat /path/to/debian-root.tgz" | tar xvzpf -

Then you can chroot to the debian root

chroot .

Then fix up /etc/fstab, kernel + loop-aes, install grub... and you are done.

Sorry this is brief, but there you are.

Cheers,

- ---Venkat.

- --
http://rayservers.com/                                            607-546-7300
PGP/GPG:                            https://rayservers.com/keys/0x12430522.asc

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.2 (GNU/Linux)

iD8DBQFD24YnWdkW/RJDBSIRAlRRAKDHDXmvIukcZYm5AUBXumJxZaZYEwCaAnM7
0hIksOBOGNbTnbKgUOMH96Q=
=onF5
-----END PGP SIGNATURE-----

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060128154458</emailId><senderName>Jan Luehr</senderName><senderEmail>jluehr@gmx.net</senderEmail><timestampReceived>2006-01-28 15:44:58-0400</timestampReceived><subject>Re: Debian on loop-AES on RAID5</subject><body>

Hello

Am Samstag, 28. Januar 2006 15:56 schrieb Venkat Manakkal:
&gt; On 01/28/2006 09:19 AM, Leo Bogert wrote:
&gt; | Hi,
&gt; |
&gt; | I just built a 600 GB (3x 300GB RAID5) Fileserver which I want to be
&gt; | full-disk-encrypted with Debian and loop-AES. (This already shows you
&gt; | that I like loop-AES very much ;)
&gt; |
&gt; | Unfortunately, it's been two or three years since I last set up a
&gt; | full-disk-encrypted box with loop-AES. Back then I was using Slackware.
&gt; | As far as I remember, I booted an already present linux system with the
&gt; | destination disk attachted, created the partitions on the destination
&gt; | disk, encrypted them and then used the ability of the Slackware setup to
&gt; | install slackware from within a running linux environment.
&gt; | Thus, the installation was directly written encrypted to disk, and after
&gt; | installing I just had to fix up the boot partition to support loop-AES
&gt; | with a custom kernel.
&gt; |
&gt; | Now, as far as I know, Debian does not support being installed from
&gt; | within a running linux.

It does. Take a look at cdebootstrap.
fup2 debian-users

Keep smiling
yanosz

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060128195516</emailId><senderName>"Leo Bogert"</senderName><senderEmail>spam-goes-to-dev-null@gmx.net</senderEmail><timestampReceived>2006-01-28 19:55:16-0400</timestampReceived><subject>RE: Debian on loop-AES on RAID5</subject><body>


&gt; &gt; Now, as far as I know, Debian does not support being 
&gt; &gt; installed from within a running linux.
&gt; It does. Take a look at cdebootstrap.
&gt; fup2 debian-users

I have read about that but as far as I have unterstood it, debootstrap is
primarily a tool for customizing the installation. I don't want to create my
own "from scratch" Debian as I might break up some important stuff or
whatever, I would prefer using the standard installation routines if that's
possible?

Thanks, Leo Bogert


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060128110906</emailId><senderName>markus reichelt</senderName><senderEmail>ml@bitfalle.org</senderEmail><timestampReceived>2006-01-28 11:09:06-0400</timestampReceived><subject>Re: Shred and stuff</subject><body>

* Gabriel Jägenstedt &lt;gabriel.j@telia.com&gt; wrote:

&gt; Does anyone understand what is going on and is it possible to save
&gt; my data?

from my end it looks like something very bad happened to your data...
i'm no sata expert, but i think the problem is with your sata setup,
not at all related to loop-aes.

have you tried to install just the disc with your encrypted
partitions on it? remove the new drive, test if you can access your
data on the old one then. if this works flawlessly (check integrity
thoroughly, against a recent backup, etc....) you can check about the
new drive the same way. prep it as you like, then ask some sata guru
about your setup, and have logfiles handy.

HTH

-- 
left blank, right bald

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060115001018</emailId><senderName>Daniel Harvey</senderName><senderEmail>daniel@amristar.com.au</senderEmail><timestampReceived>2006-01-15 00:10:18-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

Hi,

Sometimes on a new installation the loop devices are not created.

Check this by running "ls /dev/loop*" - you should see some similar to

        elvandar:/dev# ls -l /dev/loop*
        brw-rw----  1 root disk 7, 0 Dec 22 04:55 /dev/loop0
        brw-rw----  1 root disk 7, 1 Dec 22 04:55 /dev/loop1
        brw-rw----  1 root disk 7, 2 Dec 22 04:55 /dev/loop2
        brw-rw----  1 root disk 7, 3 Dec 22 04:55 /dev/loop3
        brw-rw----  1 root disk 7, 4 Dec 22 04:55 /dev/loop4
        brw-rw----  1 root disk 7, 5 Dec 22 04:55 /dev/loop5
        brw-rw----  1 root disk 7, 6 Dec 22 04:55 /dev/loop6
        brw-rw----  1 root disk 7, 7 Dec 22 04:55 /dev/loop7

If the loop devices do not exist create them as follows (this should
work for most Linux distributions):

        elvandar:/dev# cd /dev
        elvandar:/dev# ./MAKEDEV loop

Also refer to "man MAKEDEV".

Cheers,
Daniel.

On Sat, 2006-01-14 at 20:01 +0100, Bernhard Stoevesandt wrote:
&gt; hi,
&gt; 
&gt; as a longerterm loop-aes user i have now the following problem:
&gt; at my computer (old) my mainboard broke down :(. i replaced it. the
&gt; hard-disks are scsi which wasn't a problem since the board had a scsi
&gt; controller. now the new board doesn't have such a controller and with the
&gt; additional controller the disks didn't boot anymore. after many attampts i
&gt; finally reinstalled the system, build in a new ide harddisk etc.. but i
&gt; left the encrypted partitions untouched as a lot of data is on there.
&gt; now i tried to reinstall loop-aes (version 1.7 it was and is). but after a
&gt; rebot i get the following message:
&gt; 
&gt; /dev/loop3: Kein passendes Geraet bzw. keine passende Adresse gefunden
&gt; (which is german and would be translated as:
&gt; 
&gt; /dev/loop3: no approprieate (or matching?) device repectively appropriate
&gt; address found
&gt; )
&gt; 
&gt; why that? any idea what i could try??
&gt; 
&gt; bernhard
&gt; 
&gt; 
&gt; -
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/
&gt; 
&gt; 


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060115144114</emailId><senderName>"Bernhard Stoevesandt"</senderName><senderEmail>bernhard.stoevesandt@uni-oldenburg.de</senderEmail><timestampReceived>2006-01-15 14:41:14-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

No, sorry, it was not the missing cryptotab. i put the stuff in that is
already in the fstab:

/dev/sdb4       /       ext3    defaults 1 2
/dev/hda1       /boot   ext2    defaults 1 2
/dev/cdrecorder /media/cdrecorder       auto    ro,noauto,user,exec 0 0
/dev/cdrom      /media/cdrom    auto    ro,noauto,user,exec 0 0
/dev/sda5       /data2  reiserfs
defaults,noauto,user,loop=/dev/loop4,encryption=AES256,exec 0 0
/dev/sdb1       /data1  ext2
defaults,noauto,user,loop=/dev/loop3,encryption=AES256  0 0
devpts  /dev/pts        devpts  defaults 0 0
/dev/sdb5       /home   ext2    defaults 1 2
/dev/sdb6       /opt    ext3    defaults 1 2
proc    /proc   proc    defaults 0 0
usbdevfs        /proc/bus/usb   usbdevfs        noauto 0 0
/dev/sdb7       /usr    reiserfs        defaults 1 2
/dev/hda2       /var    ext2    defaults 1 2
/dev/sdb3       swap    swap    pri=42 0 0

and it is not the missing /dev/loop4 or /dev/loop3 in the /dev/ path. They
are there allright!
Any further ideas?

Bernhard


&gt; Here's an example:
&gt;
&gt; # less /etc/cryptotab
&gt;
&gt; /dev/loop0  /dev/hda4       /hda4crypto               reiserfs
&gt; twofish    noatime
&gt; /dev/loop1  /dev/hdb1       /hdb1crypto               reiserfs
&gt; twofish    noatime
&gt; /dev/loop2  /dev/hdd1       /hdd1crypto               reiserfs
&gt; twofish    noatime
&gt; /dev/loop3  /dev/hdg1       /hdg1crypto               reiserfs
&gt; twofish    noatime
&gt; /dev/loop4  /dev/hde1       /hde1crypto               ext3
&gt; twofish    noatime
&gt;
&gt;
&gt; Bernhard Stoevesandt wrote:
&gt;&gt;ups, it's not existing.so what should it say? i guess it has been deleted
&gt;&gt;when i installed the new system.
&gt;&gt;
&gt;&gt;bernhard
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt;&gt;What does your /etc/cryptotab say?
&gt;&gt;&gt;
&gt;&gt;&gt;Bernhard Stoevesandt wrote:
&gt;&gt;&gt;&gt;as a longerterm loop-aes user i have now the following problem:
&gt;&gt;&gt;&gt;at my computer (old) my mainboard broke down :(. i replaced it. the
&gt;&gt;&gt;&gt;hard-disks are scsi which wasn't a problem since the board had a scsi
&gt;&gt;&gt;&gt;controller. now the new board doesn't have such a controller and with
&gt;&gt;&gt;&gt; the
&gt;&gt;&gt;&gt;additional controller the disks didn't boot anymore. after many
&gt;&gt;&gt;&gt; attampts
&gt;&gt;&gt;&gt;i
&gt;&gt;&gt;&gt;finally reinstalled the system, build in a new ide harddisk etc.. but i
&gt;&gt;&gt;&gt;left the encrypted partitions untouched as a lot of data is on there.
&gt;&gt;&gt;&gt;now i tried to reinstall loop-aes (version 1.7 it was and is). but
&gt;&gt;&gt;&gt; after
&gt;&gt;&gt;&gt;a
&gt;&gt;&gt;&gt;rebot i get the following message:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;/dev/loop3: Kein passendes Geraet bzw. keine passende Adresse gefunden
&gt;&gt;&gt;&gt;(which is german and would be translated as:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;/dev/loop3: no approprieate (or matching?) device repectively
&gt;&gt;&gt;&gt; appropriate
&gt;&gt;&gt;&gt;address found
&gt;&gt;&gt;&gt;)
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;why that? any idea what i could try??
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;bernhard
&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060115144348</emailId><senderName>"Bernhard Stoevesandt"</senderName><senderEmail>bernhard.stoevesandt@uni-oldenburg.de</senderEmail><timestampReceived>2006-01-15 14:43:48-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

Hi,

sorry, no. They are tehre alright!

brw-rw----    1 root     disk       7,   2 M=E4r 23  2002 /dev/loop2
brw-rw----    1 root     disk       7,   3 M=E4r 23  2002 /dev/loop3
brw-rw----    1 root     disk       7,   4 M=E4r 23  2002 /dev/loop4
brw-rw----    1 root     disk       7,   5 M=E4r 23  2002 /dev/loop5
(loop2 to loop4 were the ones ...)

any other idea?

bernhard

&gt; Sometimes on a new installation the loop devices are not created.
&gt;
&gt; Check this by running "ls /dev/loop*" - you should see some similar to
&gt;
&gt;         elvandar:/dev# ls -l /dev/loop*
&gt;         brw-rw----  1 root disk 7, 0 Dec 22 04:55 /dev/loop0
&gt;         brw-rw----  1 root disk 7, 1 Dec 22 04:55 /dev/loop1
&gt;         brw-rw----  1 root disk 7, 2 Dec 22 04:55 /dev/loop2
&gt;         brw-rw----  1 root disk 7, 3 Dec 22 04:55 /dev/loop3
&gt;         brw-rw----  1 root disk 7, 4 Dec 22 04:55 /dev/loop4
&gt;         brw-rw----  1 root disk 7, 5 Dec 22 04:55 /dev/loop5
&gt;         brw-rw----  1 root disk 7, 6 Dec 22 04:55 /dev/loop6
&gt;         brw-rw----  1 root disk 7, 7 Dec 22 04:55 /dev/loop7
&gt;
&gt; If the loop devices do not exist create them as follows (this should
&gt; work for most Linux distributions):
&gt;
&gt;         elvandar:/dev# cd /dev
&gt;         elvandar:/dev# ./MAKEDEV loop
&gt;
&gt; Also refer to "man MAKEDEV".
&gt;
&gt; Cheers,
&gt; Daniel.
&gt;
&gt; On Sat, 2006-01-14 at 20:01 +0100, Bernhard Stoevesandt wrote:
&gt;&gt; hi,
&gt;&gt;
&gt;&gt; as a longerterm loop-aes user i have now the following problem:
&gt;&gt; at my computer (old) my mainboard broke down :(. i replaced it. the
&gt;&gt; hard-disks are scsi which wasn't a problem since the board had a scsi
&gt;&gt; controller. now the new board doesn't have such a controller and with
&gt;&gt; the
&gt;&gt; additional controller the disks didn't boot anymore. after many attamp=
ts
&gt;&gt; i
&gt;&gt; finally reinstalled the system, build in a new ide harddisk etc.. but =
i
&gt;&gt; left the encrypted partitions untouched as a lot of data is on there.
&gt;&gt; now i tried to reinstall loop-aes (version 1.7 it was and is). but aft=
er
&gt;&gt; a
&gt;&gt; rebot i get the following message:
&gt;&gt;
&gt;&gt; /dev/loop3: Kein passendes Geraet bzw. keine passende Adresse gefunden
&gt;&gt; (which is german and would be translated as:
&gt;&gt;
&gt;&gt; /dev/loop3: no approprieate (or matching?) device repectively
&gt;&gt; appropriate
&gt;&gt; address found
&gt;&gt; )
&gt;&gt;
&gt;&gt; why that? any idea what i could try??
&gt;&gt;
&gt;&gt; bernhard
&gt;&gt;
&gt;&gt;
&gt;&gt; -
&gt;&gt; Linux-crypto:  cryptography in and on the Linux system
&gt;&gt; Archive:       http://mail.nl.linux.org/linux-crypto/
&gt;&gt;
&gt;&gt;
&gt;
&gt;
&gt; -
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/
&gt;
&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060115184053</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-01-15 18:40:53-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

Bernhard Stoevesandt wrote:
&gt; sorry, no. They are tehre alright!
&gt; 
&gt; brw-rw----    1 root     disk       7,   2 Mär 23  2002 /dev/loop2
&gt; brw-rw----    1 root     disk       7,   3 Mär 23  2002 /dev/loop3
&gt; brw-rw----    1 root     disk       7,   4 Mär 23  2002 /dev/loop4
&gt; brw-rw----    1 root     disk       7,   5 Mär 23  2002 /dev/loop5
&gt; (loop2 to loop4 were the ones ...)
&gt; 
&gt; any other idea?

You didn't say what kernel you are running. 2.4 and older kernels need
modutils to load kernel modules. 2.6 kernels need module-init-tools to load
kernel modules.

What does "uname -a" command say?

What does "ls -l /lib/modules/*/block/loop*" command say?

What does "modprobe loop" command say? If it says something like this:
"modprobe: QM_MODULES: Function not implemented", then it is caused by
missing module-init-tools.

What does "cat /proc/devices" command say?

You said you were using loop-AES-v1.7, which is pretty old. Newer kernels
may need newer version of loop-AES to compile correctly. loop-AES' userland
to kernel interface is binary compatible, so if you build a kernel module
using latest released version of loop-AES, it should work fine with your old
losetup/mount programs.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060115194153</emailId><senderName>"Bernhard Stoevesandt"</senderName><senderEmail>bernhard.stoevesandt@uni-oldenburg.de</senderEmail><timestampReceived>2006-01-15 19:41:53-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

o.k. thanx!
here are some of the results (which in a way surprise me):

&gt; You didn't say what kernel you are running. 2.4 and older kernels need
&gt; modutils to load kernel modules. 2.6 kernels need module-init-tools to
&gt; load
&gt; kernel modules.
&gt; What does "uname -a" command say?

Linux client4 2.4.18-4GB #1 Don Mär 16 09:55:52 CET 2006 i686 unknown

&gt; What does "ls -l /lib/modules/*/block/loop*" command say?

Nothing! There is no block subdirectory ...

ls -l /lib/modules/2.4.18-4GB/
build                   modules.dep             modules.parportmap     
pcmcia
dvb                     modules.generic_string  modules.pcimap         
pcmcia-external
kernel                  modules.ieee1394map     modules.pnpbiosmap     
thinkpad
misc                    modules.isapnpmap       modules.usbmap         
wlan-ng

&gt; What does "modprobe loop" command say? If it says something like this:
&gt; "modprobe: QM_MODULES: Function not implemented", then it is caused by
&gt; missing module-init-tools.

Nothing:
modprobe loop
modprobe: Can't locate module loop


&gt; What does "cat /proc/devices" command say?

 cat /proc/devices
Character devices:
  1 mem
  2 pty
  3 ttyp
  4 ttyS
  5 cua
  7 vcs
 10 misc
 13 input
 14 sound
 21 sg
 29 fb
116 alsa
128 ptm
136 pts
162 raw
180 usb

Block devices:
  1 ramdisk
  2 fd
  3 ide0
  8 sd
  9 md
 11 sr
 22 ide1
 65 sd
 66 sd

Zhere is no loop-device. but why? i did patch the util-linux and ran
through the instructions given in the README.

&gt; You said you were using loop-AES-v1.7, which is pretty old. Newer kernels
&gt; may need newer version of loop-AES to compile correctly. loop-AES'
&gt; userland
&gt; to kernel interface is binary compatible, so if you build a kernel module
&gt; using latest released version of loop-AES, it should work fine with your
&gt; old
&gt; losetup/mount programs.

well, maybe it is a good idea to get a newer version of loop-aes and try
to install it. since this seems to me rather weird. any better idea? so i
hope the disks will mount also on the new versions.

bernhard


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060116100950</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-01-16 10:09:50-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

Bernhard Stoevesandt wrote:
&gt; &gt; What does "ls -l /lib/modules/*/block/loop*" command say?
&gt; 
&gt; Nothing! There is no block subdirectory ...

So you didn't build loop-AES' loop.o module. Your mount attempt fails
because there is no loop driver available.

&gt; Zhere is no loop-device. but why? i did patch the util-linux and ran
&gt; through the instructions given in the README.

You skipped section 3 of README. Section number 3 refers to README file from
loop-AES-v3.1b, I don't remember if it was same number in v1.7 README.

&gt; so i hope the disks will mount also on the new versions.

Your old partitions should mount ok with newer loop-AES version.

Securitywise, your setup is broken and exploitable. I recommend that you
re-encrypt those partitions using loop-AES version 3 on-disk format.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060116115018</emailId><senderName>"Bernhard Stoevesandt"</senderName><senderEmail>bernhard.stoevesandt@uni-oldenburg.de</senderEmail><timestampReceived>2006-01-16 11:50:18-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

hi jari,

thanx a lot. i will surly do so. right now i'm off to work in a different
city but when i'm back i will try it with a version 3.

&gt; Bernhard Stoevesandt wrote:
&gt;&gt; &gt; What does "ls -l /lib/modules/*/block/loop*" command say?
&gt;&gt;
&gt;&gt; Nothing! There is no block subdirectory ...
&gt;
&gt; So you didn't build loop-AES' loop.o module. Your mount attempt fails
&gt; because there is no loop driver available.

this is in a way funny, because it should have been built in the
util-linux section as i remember. obviously it didn't. that's somehow
strange.

&gt;&gt; Zhere is no loop-device. but why? i did patch the util-linux and ran
&gt;&gt; through the instructions given in the README.
&gt;
&gt; You skipped section 3 of README. Section number 3 refers to README file
&gt; from
&gt; loop-AES-v3.1b, I don't remember if it was same number in v1.7 README.

well, i thought i had it all. changing the kernel, patching util-linux and
then installing the important parts - that was it as i remember. but,
well...

&gt;&gt; so i hope the disks will mount also on the new versions.
&gt;
&gt; Your old partitions should mount ok with newer loop-AES version.
&gt;
&gt; Securitywise, your setup is broken and exploitable. I recommend that you
&gt; re-encrypt those partitions using loop-AES version 3 on-disk format.

o.k. i will do. why is that now anyway? because right now the passphrases
are interceptible? thanx again!

bernhard


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060116130342</emailId><senderName>markus reichelt</senderName><senderEmail>ml@bitfalle.org</senderEmail><timestampReceived>2006-01-16 13:03:42-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

* Bernhard Stoevesandt &lt;bernhard.stoevesandt@uni-oldenburg.de&gt; wrote:

&gt; &gt; So you didn't build loop-AES' loop.o module. Your mount attempt
&gt; &gt; fails because there is no loop driver available.
&gt; 
&gt; this is in a way funny, because it should have been built in the
&gt; util-linux section as i remember. obviously it didn't. that's
&gt; somehow strange.

just being curious....are you using suse linux by any chance? 


&gt; &gt; Securitywise, your setup is broken and exploitable. I recommend
&gt; &gt; that you re-encrypt those partitions using loop-AES version 3
&gt; &gt; on-disk format.
&gt; 
&gt; o.k. i will do. why is that now anyway? because right now the
&gt; passphrases are interceptible? thanx again!

in order to prevent watermark attacks, v3 has to be used. v2 and v1
of loop-aes are vulnerable to it, as well as mainline cryptoloop,
dm-crypt without special patch (kernel &lt;v2.6.10), bestcrypt and
truecrypt &lt; v4.10

further info (in german)
http://de.wikipedia.org/wiki/Watermark_attack

-- 
left blank, right bald

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060116172249</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-01-16 17:22:49-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

Bernhard Stoevesandt wrote:
&gt; &gt; Securitywise, your setup is broken and exploitable. I recommend that you
&gt; &gt; re-encrypt those partitions using loop-AES version 3 on-disk format.
&gt; 
&gt; o.k. i will do. why is that now anyway? because right now the passphrases
&gt; are interceptible?

Your setup does not use salted+iterated key setup. Lack of salting makes it
vulnerable to precomputed dictionary attacks. Lack of iteration makes
dictionary attacks really fast. Your setup is using single key mode, which
has weak IV computation. Weak IV makes it vulnerable to watermark attacks.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060116172344</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-01-16 17:23:44-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

markus reichelt wrote:
&gt; in order to prevent watermark attacks, v3 has to be used. v2 and v1
&gt; of loop-aes are vulnerable to it

In normal use, loop-AES-v2 on-disk format is not vulnerable to watermark
attacks. By normal use I mean someone copying watermarked file to encrypted
file system.

loop-AES-v2 is not vulnerable as long as file system chooses sector number
on partition where file data is written. However, v2 is vulnerable if
adversary is able to choose sector number on partition where file data is
written. In normal use that is not the case.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060120143228</emailId><senderName>"Bernhard Stoevesandt"</senderName><senderEmail>bernhard.stoevesandt@uni-oldenburg.de</senderEmail><timestampReceived>2006-01-20 14:32:28-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

Hi,

sorry, but it is still the same error:

/dev/loop3 no appropriate device or address found

now, i did install loo=FC-aes-v3.1c. followd the instructions:

&gt;&gt; &gt; What does "ls -l /lib/modules/*/block/loop*" command say?

this says now:

bs@client4:~&gt; ls -l /lib/modules/2.4.18-4GB/block/
insgesamt 64
-rw-r--r--    1 root     root        60595 M=E4r 23 13:21 loop.o

the date is o.k.. my computer doesn't recognize it yet - i will fix that
later ... .
further ideas?

greets

bernhard


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060120164656</emailId><senderName>Venkat Manakkal</senderName><senderEmail>venkat@rayservers.com</senderEmail><timestampReceived>2006-01-20 16:46:56-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 01/20/2006 09:32 AM, Bernhard Stoevesandt wrote:
| Hi,
|
| sorry, but it is still the same error:
|
| /dev/loop3 no appropriate device or address found
|
| now, i did install looü-aes-v3.1c. followd the instructions:
|
|
|&gt;&gt;&gt;What does "ls -l /lib/modules/*/block/loop*" command say?
|
|
| this says now:
|
| bs@client4:~&gt; ls -l /lib/modules/2.4.18-4GB/block/
| insgesamt 64
| -rw-r--r--    1 root     root        60595 Mär 23 13:21 loop.o
|
| the date is o.k.. my computer doesn't recognize it yet - i will fix that
| later ... .
| further ideas?

Its likely that you have not issued the

modprobe loop

command. Then the loop devices will be available.

Cheers,

- ---Venkat.

- --
http://rayservers.com/                  607-546-7300
PGP/GPG:  https://rayservers.com/keys/0x12430522.asc
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.1 (GNU/Linux)

iD8DBQFD0RP+WdkW/RJDBSIRAmp9AJ9rE34Mjdlhq/qsljWlvCe1197OZwCdHsPg
p7wHb9ODi1uBdb+wZs6hR0U=
=W0+H
-----END PGP SIGNATURE-----

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060121162834</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-01-21 16:28:34-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

Venkat Manakkal wrote:
&gt; On 01/20/2006 09:32 AM, Bernhard Stoevesandt wrote:
&gt; | sorry, but it is still the same error:
&gt; |
&gt; | /dev/loop3 no appropriate device or address found
&gt; 
&gt; Its likely that you have not issued the
&gt; 
&gt; modprobe loop
&gt; 
&gt; command. Then the loop devices will be available.

Normally loop module should autoload on demand.

Bernhard,
Can you check that you have CONFIG_MODULES=y and CONFIG_KMOD=y in your
kernel config.

What does "grep "CONFIG_.*MOD.*" /usr/src/linux/.config" command say?

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060123222246</emailId><senderName>"Bernhard Stoevesandt"</senderName><senderEmail>bernhard.stoevesandt@uni-oldenburg.de</senderEmail><timestampReceived>2006-01-23 22:22:46-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

hi,

thank you for all the help so far. i think we are getting closer:

&gt; Venkat Manakkal wrote:
&gt;&gt; On 01/20/2006 09:32 AM, Bernhard Stoevesandt wrote:
&gt;&gt; | sorry, but it is still the same error:
&gt;&gt; |
&gt;&gt; | /dev/loop3 no appropriate device or address found
&gt;&gt;
&gt;&gt; Its likely that you have not issued the
&gt;&gt; modprobe loop
&gt;&gt; command. Then the loop devices will be available.

This is very interesting because i get the following:
/lib/modules/2.4.18-4GB/block/loop.o: unresolved symbol set_user_nice
/lib/modules/2.4.18-4GB/block/loop.o: insmod
/lib/modules/2.4.18-4GB/block/loop.o failed
/lib/modules/2.4.18-4GB/block/loop.o: insmod loop failed

&gt; Normally loop module should autoload on demand.
&gt;
&gt; Bernhard,
&gt; Can you check that you have CONFIG_MODULES=y and CONFIG_KMOD=y in your
&gt; kernel config.
&gt;
&gt; What does "grep "CONFIG_.*MOD.*" /usr/src/linux/.config" command say?

well, i thought i configured the kernel correctly and i also compiled:
grep says:

.config:CONFIG_MODULES=y
.config:# CONFIG_MODVERSIONS is not set
.config:CONFIG_KMOD=y
.config:CONFIG_IDEDISK_MULTI_MODE=y
.config:CONFIG_BLK_DEV_IDE_MODES=y
.config:CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=1
.config:CONFIG_SLIP_MODE_SLIP6=y
and
CONFIG_BLK_DEV_LOOP=n
CONFIG_CIPHER_TWOFISH=m

does this help?

bernhard



-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060124145756</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-01-24 14:57:56-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

Bernhard Stoevesandt wrote:
&gt; This is very interesting because i get the following:
&gt; /lib/modules/2.4.18-4GB/block/loop.o: unresolved symbol set_user_nice
&gt; /lib/modules/2.4.18-4GB/block/loop.o: insmod
&gt; /lib/modules/2.4.18-4GB/block/loop.o failed
&gt; /lib/modules/2.4.18-4GB/block/loop.o: insmod loop failed

Your kernel appears to include O(1) scheduler, but for some reason does not
export that set_user_nice() function to modules. Strange.

Quick fix is to add such export statement to your kernel source, and then
re-compile and install new kernel. You can add that export like this:

    cd /usr/src/linux-2.4.18
    echo 'EXPORT_SYMBOL(set_user_nice);' &gt;&gt;kernel/ksyms.c

Then build + install new kernel normally. Something like this:

    mv .config z
    make distclean
    mv z .config
    make oldconfig
    make dep &amp;&amp; make clean &amp;&amp; make bzlilo INSTALL_PATH=/boot
    make modules &amp;&amp; make modules_install

Then compile new loop-AES module, like this:

    cd /usr/src/loop-AES-v3.1c
    make LINUX_SOURCE=/usr/src/linux-2.4.18

And finally boot your new kernel.

Bernhard,
Can you post a download link to your kernel source on your distro vendor
server, or some other place. I want to see this kernel source myself.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060126223345</emailId><senderName>"Bernhard Stoevesandt"</senderName><senderEmail>bernhard.stoevesandt@uni-oldenburg.de</senderEmail><timestampReceived>2006-01-26 22:33:45-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

hi,

sorry, didn't work. it didn't compile correctly:

&gt; Your kernel appears to include O(1) scheduler, but for some reason does
&gt; not
&gt; export that set_user_nice() function to modules. Strange.
&gt;
&gt; Quick fix is to add such export statement to your kernel source, and then
&gt; re-compile and install new kernel. You can add that export like this:
&gt;
&gt;     cd /usr/src/linux-2.4.18
&gt;     echo 'EXPORT_SYMBOL(set_user_nice);' &gt;&gt;kernel/ksyms.c

this worked ...

&gt; Then build + install new kernel normally. Something like this:
&gt;
&gt;     mv .config z
&gt;     make distclean
&gt;     mv z .config
&gt;     make oldconfig

until here it worked ...

&gt;     make dep &amp;&amp; make clean &amp;&amp; make bzlilo INSTALL_PATH=/boot

and here i get:

gcc -D__KERNEL__ -I/usr/src/linux-2.4.18.SuSE/include -Wall
-Wstrict-prototypes -Wno-trigraphs -O2 -fomit-frame-pointer
-fno-strict-aliasing -fno-common -pipe -mpreferred-stack-boundary=2
-march=i586   -DKBUILD_BASENAME=ksyms  -DEXPORT_SYMTAB -c ksyms.c
ksyms.c:609: `set_user_nice' undeclared here (not in a function)
ksyms.c:609: initializer element is not constant
ksyms.c:609: (near initialization for `__ksymtab_set_user_nice.value')
make[2]: *** [ksyms.o] Fehler 1
make[2]: Verlassen des Verzeichnisses Verzeichnis
»/usr/src/linux-2.4.18.SuSE/kernel«
make[1]: *** [first_rule] Fehler 2
make[1]: Verlassen des Verzeichnisses Verzeichnis
»/usr/src/linux-2.4.18.SuSE/kernel«
make: *** [_dir_kernel] Fehler 2

so as you can see. it is an old suse-distro (8.0). actually it worked on
it before. now i don't know, why it doesn't anymore ... . strange. before
i did have some updates on it, which are not downloadable anymore, since
they don't support this distro anymore.
i already thought about a newer distro, but my computer is really old and
new software packages are often not really handy for old computer ...

bernhard

&gt;     make modules &amp;&amp; make modules_install
&gt;
&gt; Then compile new loop-AES module, like this:
&gt;
&gt;     cd /usr/src/loop-AES-v3.1c
&gt;     make LINUX_SOURCE=/usr/src/linux-2.4.18
&gt;
&gt; And finally boot your new kernel.
&gt;

&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060127130940</emailId><senderName>markus reichelt</senderName><senderEmail>ml@bitfalle.org</senderEmail><timestampReceived>2006-01-27 13:09:40-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

* Bernhard Stoevesandt &lt;bernhard.stoevesandt@uni-oldenburg.de&gt; wrote:

&gt; &gt;     make dep &amp;&amp; make clean &amp;&amp; make bzlilo INSTALL_PATH=/boot
&gt; 
&gt; and here i get:
&gt; 
&gt; gcc -D__KERNEL__ -I/usr/src/linux-2.4.18.SuSE/include -Wall

how about using a vanilla kernel 2.4.18? 


&gt; i already thought about a newer distro, but my computer is really
&gt; old and new software packages are often not really handy for old
&gt; computer ...

well.... you could use a recent slackware (10.2) with fluxbox or
xfce.

-- 
left blank, right bald

[Attachment #3 (application/pgp-signature)]
-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060127153555</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-01-27 15:35:55-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

Bernhard Stoevesandt wrote:
&gt; gcc -D__KERNEL__ -I/usr/src/linux-2.4.18.SuSE/include -Wall
&gt; -Wstrict-prototypes -Wno-trigraphs -O2 -fomit-frame-pointer
&gt; -fno-strict-aliasing -fno-common -pipe -mpreferred-stack-boundary=2
&gt; -march=i586   -DKBUILD_BASENAME=ksyms  -DEXPORT_SYMTAB -c ksyms.c
&gt; ksyms.c:609: `set_user_nice' undeclared here (not in a function)
[snip]
&gt; it is an old suse-distro (8.0).

Ok. I found SuSE 8.0 kernel patches from ftp.suse.com and looked at the
source. Now I understand what went wrong: module compilation failed. I got
these errors on 2.4.18-SuSE-91 kernel + loop-AES-v3.1c :

patched-loop.c: In function `loop_thread':
patched-loop.c:757: warning: implicit declaration of function `set_user_nice'
[snip]
depmod: *** Unresolved symbols in /lib/modules/2.4.18-SuSE-91/block/loop.o

Most 2.4 kernels use either normal 2.4 scheduler or O(1) scheduler. That
SuSE kernel appears to have scheduler that is sufficietly different from
both above mentioned schedulers and confused loop module compilation to use
wrong scheduler interface.

Really old loop-AES versions used different scheduler detection code. On
June 2003, that scheduler detection code was changed to test defines
include/linux/sched.h, causing scheduler mis-detection and compile failure
on that particular SuSE kernel. I now fixed this incompatibility by
modifying scheduler detection code. A patch for loop-AES-v3.1c is included.

To clean up the mess, you need to remove that extra EXPORT_SYMBOL() from
your kernel.

    cd /usr/src/linux-2.4.18.SuSE
    sed -e 's/EXPORT_SYMBOL(set_user_nice);//' &lt;kernel/ksyms.c &gt;z
    mv z kernel/ksyms.c

And then recompile your kernel. This assumes that you are using lilo
bootloader, and that lilo is configured to boot /boot/vmlinuz kernel.

    mv .config z
    make distclean
    mv z .config
    make oldconfig
    make dep &amp;&amp; make clean &amp;&amp; make bzlilo INSTALL_PATH=/boot
    make modules &amp;&amp; make modules_install

And then apply included loop-AES patch.

    cd /usr/src/loop-AES-v3.1c
    patch -p1 &lt;this-email

And then build loop.o module for your kernel.

    make LINUX_SOURCE=/usr/src/linux-2.4.18.SuSE

And then boot your new kernel /boot/vmlinuz

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD


--- ../loop-AES-v3.1c/loop.c-2.4.patched	2005-09-17 12:20:54.000000000 +0300
+++ ./loop.c-2.4.patched	2006-01-27 15:36:39.000000000 +0200
@@ -222,7 +222,7 @@
  * This is loop helper thread nice value in range
  * from 0 (low priority) to -20 (high priority).
  */
-#if defined(DEF_NICE) &amp;&amp; defined(DEF_COUNTER)
+#if defined(DEF_NICE)
 static int lo_nice = -20;   /* old scheduler default */
 #else
 static int lo_nice = -1;    /* O(1) scheduler default */
@@ -748,7 +748,7 @@
 		lo_nice = 0;
 	if (lo_nice &lt; -20)
 		lo_nice = -20;
-#if defined(DEF_NICE) &amp;&amp; defined(DEF_COUNTER)
+#if defined(DEF_NICE)
 	/* old scheduler syntax */
 	current-&gt;policy = SCHED_OTHER;
 	current-&gt;nice = lo_nice;

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060115105953</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-01-15 10:59:53-0400</timestampReceived><subject>Re: RFC: Parameterised crypto algorithms</subject><body>

On Sat, Jan 14, 2006 at 09:59:27PM +1100, Herbert Xu (herbert@gondor.apana.org.au) wrote:
&gt; Hi:
&gt; 
&gt; The recent AES-XCBC patch has given me some ideas on how to solve an old
&gt; problem.
&gt; 
&gt; The problem is how do we let users of the crypto layer supply parameters
&gt; to crypto algorithms.  Such parameters include things like compression
&gt; factors, key lengths, etc.  In the case of XCBC (and HMAC), we could
&gt; implement them as normal algorithms that take another crypto algorithm
&gt; as a parameter.
&gt; 
&gt; So what I have in mind is a string-based representation.  For example,
&gt; SHA1-HMAC would look like "hmac(sha1)".  AES-XCBC would look like
&gt; "xcbc(aes)".  By the same reasoning you can have
&gt; 
&gt; 	"hmac(hmac(md5), 0x52173f0b5a27c840d16310cfc8e44d9e)"
&gt; 
&gt; Which means take MD5-HMAC with the specified key as a digest algorithm,
&gt; and then apply HMAC to it.
&gt; 
&gt; For compression we can have "deflate(11)" where 11 is the winbits
&gt; parameter.  We need this because we really need to set the default
&gt; winbits to the maximum (15) in order to be able to accept whatever
&gt; other IPsec stacks can send us.  While other users of deflate may
&gt; be able to get away with a smaller winbits because they only read
&gt; things that they write themselves.
&gt; 
&gt; These strings would be supplied by crypto users to crypto_alloc_tfm.
&gt; crypto_alloc_tfm would eat the algorithm name and give the rest to
&gt; the algorithm to interpret.
&gt; 
&gt; The string could also come from indirect users of the crypto layer.
&gt; For example, userspace IPsec KMs can give them to the the kernel
&gt; IPsec layer which then passes them to the crypto layer unchanged.
&gt; 
&gt; Does this look sane? Any better ideas on solving this problem?

Are you sure sed and awk are good for kernel?
Above string parsing eventually will end up in tricky bugs.
What about following:

tfm = crypto_tfm_alloc("deflate", flags);
err = tfm-&gt;setup(&amp;user_provided_deflate_parameters);

int deflate_setup(void *data)
{
	struct deflate_setup *s = data;

	... setup compression parameters from user's structure ...

	return 0;
}

&gt; Cheers,
&gt; -- 
&gt; Visit Openswan at http://www.openswan.org/
&gt; Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
&gt; Home Page: http://gondor.apana.org.au/~herbert/
&gt; PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
&gt; -
&gt; To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
&gt; the body of a message to majordomo@vger.kernel.org
&gt; More majordomo info at  http://vger.kernel.org/majordomo-info.html

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060115121821</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-01-15 12:18:21-0400</timestampReceived><subject>Re: RFC: Parameterised crypto algorithms</subject><body>

On Sun, Jan 15, 2006 at 01:59:53PM +0300, Evgeniy Polyakov wrote:
&gt; 
&gt; Are you sure sed and awk are good for kernel?
&gt; Above string parsing eventually will end up in tricky bugs.
&gt; What about following:
&gt; 
&gt; tfm = crypto_tfm_alloc("deflate", flags);
&gt; err = tfm-&gt;setup(&amp;user_provided_deflate_parameters);
&gt; 
&gt; int deflate_setup(void *data)
&gt; {
&gt; 	struct deflate_setup *s = data;
&gt; 
&gt; 	... setup compression parameters from user's structure ...
&gt; 
&gt; 	return 0;
&gt; }

Passing void * pointers like this is going to cause even more bugs,
especially if you do it from user space to kernel space.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060115125338</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-01-15 12:53:38-0400</timestampReceived><subject>Re: RFC: Parameterised crypto algorithms</subject><body>

On Sun, Jan 15, 2006 at 11:18:21PM +1100, Herbert Xu (herbert@gondor.apana.org.au) wrote:
&gt; On Sun, Jan 15, 2006 at 01:59:53PM +0300, Evgeniy Polyakov wrote:
&gt; &gt; 
&gt; &gt; Are you sure sed and awk are good for kernel?
&gt; &gt; Above string parsing eventually will end up in tricky bugs.
&gt; &gt; What about following:
&gt; &gt; 
&gt; &gt; tfm = crypto_tfm_alloc("deflate", flags);
&gt; &gt; err = tfm-&gt;setup(&amp;user_provided_deflate_parameters);
&gt; &gt; 
&gt; &gt; int deflate_setup(void *data)
&gt; &gt; {
&gt; &gt; 	struct deflate_setup *s = data;
&gt; &gt; 
&gt; &gt; 	... setup compression parameters from user's structure ...
&gt; &gt; 
&gt; &gt; 	return 0;
&gt; &gt; }
&gt; 
&gt; Passing void * pointers like this is going to cause even more bugs,
&gt; especially if you do it from user space to kernel space.

It can be struct crypto_config,
which will contain common to every crypto entity parameters
and size of attached private structure, which will have special data.

&gt; Cheers,
&gt; -- 
&gt; Visit Openswan at http://www.openswan.org/
&gt; Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
&gt; Home Page: http://gondor.apana.org.au/~herbert/
&gt; PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060116010632</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-01-16 01:06:32-0400</timestampReceived><subject>Re: RFC: Parameterised crypto algorithms</subject><body>

On Sun, Jan 15, 2006 at 03:53:38PM +0300, Evgeniy Polyakov wrote:
&gt; 
&gt; It can be struct crypto_config,
&gt; which will contain common to every crypto entity parameters
&gt; and size of attached private structure, which will have special data.

Actually you gave me an idea that could move the parsing out of kernel
space.

Instead of having the tfm objects receive the parameters either at
allocation time (through crypto_alloc_tfm) or after allocation (through
the setup function you mentioned), we can move the parameters in
the crypto_alg object itself.

For example, to allocate a "deflate(15)" tfm, you first check to see
if a crypto_alg object with the name "deflate(15)" exists.  If it
doesn't, you would ask the deflate module (this part doesn't exist
yet and will need be written) to instantiate a crypto_alg object
with the win parameter of 15.  This instance would then be registered
under the name "deflate(15)".

If we went this way, then the parsing of deflate(15) and the request
to the deflate module could be done in userspace.  The notification
and request can take place through netlink.

Evgeniy, does this resolve your concerns about parsing strings in
the kernel?


On a different note, someone was asking me about how cumbersome it
is to add new block chaining methods.  We could actually use what
I outlined earlier wrt HMAC/XBC to solve that problem.

For example, instead of having an "aes" crypto_alg object that does
all of ECB/CBC/CFB/... we'll have only the base aes algorithm which
just does a single block.

We can then have generic ECB/CBC/CFB/... implementations that
are simply cipher implementations like AES except that they take
a base cipher as a parameter.

So if you request an algorithm of type "cbc(aes)" the system would
first go and look for an exact match which could be hardware devices
(including the PadLock) that implement AES+CBC directly.

If such a match couldn't be found, we would then notify some userspace
daemon which would parse the string and make a request to the generic
CBC algorithm to instantiate a copy of itself with the cipher algorithm
set to "aes".  This crypto_alg object would be registered under the name
of "cbc(aes)" with a suitably low priority.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060117101055</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-01-17 10:10:55-0400</timestampReceived><subject>Re: RFC: Parameterised crypto algorithms</subject><body>

On Tue, Jan 17, 2006 at 01:16:26PM +0300, Evgeniy Polyakov wrote:
&gt;
&gt; Yep.
&gt; But it still requires some kind of parsing in kernel:
&gt; what if we will have "deflate(a,b)", and "defalate(a, default_b)"?
&gt; Will all such strings userspace parsing end up in userspace requests
&gt; for tons of the same module, but different algorith strings?
&gt; Although we can only allow to have "deflate" and "defalte(all parameters)"...

The only thing the kernel does is check if there is a crypto_alg
registered under that name.  If there is it allocates a tfm of
that type.  If it doesn't know about it's passed to user-space.
No parsing in the kernel at all apart from strcmp.

BTW, this doesn't mean that we can't have things like CBC/HMAC without
a user-space daemon.  For the common stuff needed by IPsec (md5-hmac,
aes-cbc, etc.) they can and should be preregistered.

&gt; Such strings are perfectly fine, but what will happen when 
&gt; someone calls "cbc(cbc(cbc(...(aes)))"?

That's fine.  Because the parsing of such unknown strings occur in
userspace we get to make up whatever rules you want.

However, in this case it's pretty simple.  CBC only accepts "base"
cipher algorithms.  While "aes" is a base algorithm, "cbc(aes)" is
not a "base" cipher algorithm.  Therefore this expression is invalid.
So is the expression "cbc(md5)".

&gt; What if we create restriction and allow to only call
&gt; "basic" algo creations, and then link them at setup() time?
&gt; I.e. 
&gt; tfm1 = tfm_alloc_method(xcbc);
&gt; tfm2 = tfm_alloc_method(xcbc);
&gt; tfm3 = tfm_alloc_cipher(aes);
&gt; tfm2-&gt;setup(tfm3); // "cbc(aes)"
&gt; tfm1-&gt;setup(tfm2); // "cbc(cbc(aes))"

Sure, I'm totally cool with preregistration for common cases.  This means
that 99% of the users won't need a user-space daemon to hang around.
However, we should maintain the potential to have arbitrary combinations
for maximum flexibility.

It's just that if you need that flexibility (e.g., hmac(xbc(cbc(aes)), 0x123)),
you'll have the pay the cost of keeping a user-space daemon around.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060117101626</emailId><senderName>Evgeniy Polyakov</senderName><senderEmail>johnpol@2ka.mipt.ru</senderEmail><timestampReceived>2006-01-17 10:16:26-0400</timestampReceived><subject>Re: RFC: Parameterised crypto algorithms</subject><body>

On Mon, Jan 16, 2006 at 12:06:32PM +1100, Herbert Xu (herbert@gondor.apana.org.au) wrote:
&gt; On Sun, Jan 15, 2006 at 03:53:38PM +0300, Evgeniy Polyakov wrote:
&gt; &gt; 
&gt; &gt; It can be struct crypto_config,
&gt; &gt; which will contain common to every crypto entity parameters
&gt; &gt; and size of attached private structure, which will have special data.
&gt; 
&gt; Actually you gave me an idea that could move the parsing out of kernel
&gt; space.
&gt; 
&gt; Instead of having the tfm objects receive the parameters either at
&gt; allocation time (through crypto_alloc_tfm) or after allocation (through
&gt; the setup function you mentioned), we can move the parameters in
&gt; the crypto_alg object itself.
&gt; 
&gt; For example, to allocate a "deflate(15)" tfm, you first check to see
&gt; if a crypto_alg object with the name "deflate(15)" exists.  If it
&gt; doesn't, you would ask the deflate module (this part doesn't exist
&gt; yet and will need be written) to instantiate a crypto_alg object
&gt; with the win parameter of 15.  This instance would then be registered
&gt; under the name "deflate(15)".
&gt; 
&gt; If we went this way, then the parsing of deflate(15) and the request
&gt; to the deflate module could be done in userspace.  The notification
&gt; and request can take place through netlink.
&gt; 
&gt; Evgeniy, does this resolve your concerns about parsing strings in
&gt; the kernel?

Yep.
But it still requires some kind of parsing in kernel:
what if we will have "deflate(a,b)", and "defalate(a, default_b)"?
Will all such strings userspace parsing end up in userspace requests
for tons of the same module, but different algorith strings?
Although we can only allow to have "deflate" and "defalte(all parameters)"...

&gt; On a different note, someone was asking me about how cumbersome it
&gt; is to add new block chaining methods.  We could actually use what
&gt; I outlined earlier wrt HMAC/XBC to solve that problem.
&gt; 
&gt; For example, instead of having an "aes" crypto_alg object that does
&gt; all of ECB/CBC/CFB/... we'll have only the base aes algorithm which
&gt; just does a single block.
&gt; 
&gt; We can then have generic ECB/CBC/CFB/... implementations that
&gt; are simply cipher implementations like AES except that they take
&gt; a base cipher as a parameter.
&gt; 
&gt; So if you request an algorithm of type "cbc(aes)" the system would
&gt; first go and look for an exact match which could be hardware devices
&gt; (including the PadLock) that implement AES+CBC directly.
&gt; 
&gt; If such a match couldn't be found, we would then notify some userspace
&gt; daemon which would parse the string and make a request to the generic
&gt; CBC algorithm to instantiate a copy of itself with the cipher algorithm
&gt; set to "aes".  This crypto_alg object would be registered under the name
&gt; of "cbc(aes)" with a suitably low priority.

Such strings are perfectly fine, but what will happen when 
someone calls "cbc(cbc(cbc(...(aes)))"?

What if we create restriction and allow to only call
"basic" algo creations, and then link them at setup() time?
I.e. 
tfm1 = tfm_alloc_method(xcbc);
tfm2 = tfm_alloc_method(xcbc);
tfm3 = tfm_alloc_cipher(aes);
tfm2-&gt;setup(tfm3); // "cbc(aes)"
tfm1-&gt;setup(tfm2); // "cbc(cbc(aes))"

And call such chains from inside of the parsing state machine.
Is it you idea, Herbert?

&gt; Cheers,
&gt; -- 
&gt; Visit Openswan at http://www.openswan.org/
&gt; Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
&gt; Home Page: http://gondor.apana.org.au/~herbert/
&gt; PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt

-- 
	Evgeniy Polyakov
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060117102422</emailId><senderName>Herbert Xu</senderName><senderEmail>herbert@gondor.apana.org.au</senderEmail><timestampReceived>2006-01-17 10:24:22-0400</timestampReceived><subject>Re: RFC: Parameterised crypto algorithms</subject><body>

On Tue, Jan 17, 2006 at 01:38:06PM +0300, Evgeniy Polyakov wrote:
&gt; 
&gt; Ok, I see.
&gt; If user requests new string, anything he likes, it is compared with some
&gt; base set of strings algorithm supports, if it differs, then userspace
&gt; daemon will take care about all parsing and needed initialisation of
&gt; the requested crypto chain.

Exactly.  The base set is simply determined by whatever you have compiled
into your kernel or loaded as modules.  This should cover everything that
we have now.

Anything more complicated than that gets sent off to user-space.

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu ~{PmV&gt;HI~} &lt;herbert@gondor.apana.org.au&gt;
Home Page: http://gondor.apana.org.au/~herbert/
PGP Key: http://gondor.apana.org.au/~herbert/pubkey.txt
-
To unsubscribe from this list: send the line "unsubscribe linux-crypto" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
</body></email><email><emailId>20060118205454</emailId><senderName>vova manelidze</senderName><senderEmail>manelidze@yahoo.com</senderEmail><timestampReceived>2006-01-18 20:54:54-0400</timestampReceived><subject>From Vova Manelidze(Georgia)</subject><body>

I interesting your products.Thanks.



			
---------------------------------
Yahoo! Photos
 Got holiday prints? See all the ways to get quality prints in your hands ASAP.
[Attachment #3 (text/html)]

&lt;DIV id=RTEContent&gt;  &lt;DIV id=RTEContent&gt;  &lt;DIV id=RTEContent&gt;I interesting your \
products.Thanks.&lt;/DIV&gt;&lt;/DIV&gt;&lt;/DIV&gt;&lt;p&gt;  
		&lt;hr size=1&gt;Yahoo! Photos&lt;br&gt; 
Got holiday prints? &lt;a \
href="http://us.rd.yahoo.com/mail_us/taglines/holidayprints/*http://pa.yahoo.com/*http \
://us.rd.yahoo.com/mail_us/taglines/photos/evt=38089/*http://pg.photos.yahoo.com/ph//print_splash"&gt;See \
all the ways&lt;/a&gt; to get quality prints in your hands ASAP.


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20060128123240</emailId><senderName>"Bernhard Stoevesandt"</senderName><senderEmail>bernhard.stoevesandt@uni-oldenburg.de</senderEmail><timestampReceived>2006-01-28 12:32:40-0400</timestampReceived><subject>Re: /dev/loop3 No appropriate device found</subject><body>

Hi Jari,

thanx a lot. That worked. It is all there now and i can rescue this whole
stuff now!
Thank you very much again!

Bernhard

&gt; Bernhard Stoevesandt wrote:
&gt;&gt; gcc -D__KERNEL__ -I/usr/src/linux-2.4.18.SuSE/include -Wall
&gt;&gt; -Wstrict-prototypes -Wno-trigraphs -O2 -fomit-frame-pointer
&gt;&gt; -fno-strict-aliasing -fno-common -pipe -mpreferred-stack-boundary=2
&gt;&gt; -march=i586   -DKBUILD_BASENAME=ksyms  -DEXPORT_SYMTAB -c ksyms.c
&gt;&gt; ksyms.c:609: `set_user_nice' undeclared here (not in a function)
&gt; [snip]
&gt;&gt; it is an old suse-distro (8.0).
&gt;
&gt; Ok. I found SuSE 8.0 kernel patches from ftp.suse.com and looked at the
&gt; source. Now I understand what went wrong: module compilation failed. I got
&gt; these errors on 2.4.18-SuSE-91 kernel + loop-AES-v3.1c :
&gt;
&gt; patched-loop.c: In function `loop_thread':
&gt; patched-loop.c:757: warning: implicit declaration of function
&gt; `set_user_nice'
&gt; [snip]
&gt; depmod: *** Unresolved symbols in /lib/modules/2.4.18-SuSE-91/block/loop.o
&gt;
&gt; Most 2.4 kernels use either normal 2.4 scheduler or O(1) scheduler. That
&gt; SuSE kernel appears to have scheduler that is sufficietly different from
&gt; both above mentioned schedulers and confused loop module compilation to
&gt; use
&gt; wrong scheduler interface.
&gt;
&gt; Really old loop-AES versions used different scheduler detection code. On
&gt; June 2003, that scheduler detection code was changed to test defines
&gt; include/linux/sched.h, causing scheduler mis-detection and compile failure
&gt; on that particular SuSE kernel. I now fixed this incompatibility by
&gt; modifying scheduler detection code. A patch for loop-AES-v3.1c is
&gt; included.
&gt;
&gt; To clean up the mess, you need to remove that extra EXPORT_SYMBOL() from
&gt; your kernel.
&gt;
&gt;     cd /usr/src/linux-2.4.18.SuSE
&gt;     sed -e 's/EXPORT_SYMBOL(set_user_nice);//' &lt;kernel/ksyms.c &gt;z
&gt;     mv z kernel/ksyms.c
&gt;
&gt; And then recompile your kernel. This assumes that you are using lilo
&gt; bootloader, and that lilo is configured to boot /boot/vmlinuz kernel.
&gt;
&gt;     mv .config z
&gt;     make distclean
&gt;     mv z .config
&gt;     make oldconfig
&gt;     make dep &amp;&amp; make clean &amp;&amp; make bzlilo INSTALL_PATH=/boot
&gt;     make modules &amp;&amp; make modules_install
&gt;
&gt; And then apply included loop-AES patch.
&gt;
&gt;     cd /usr/src/loop-AES-v3.1c
&gt;     patch -p1 &lt;this-email
&gt;
&gt; And then build loop.o module for your kernel.
&gt;
&gt;     make LINUX_SOURCE=/usr/src/linux-2.4.18.SuSE
&gt;
&gt; And then boot your new kernel /boot/vmlinuz
&gt;
&gt; --
&gt; Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9
&gt; DD
&gt;
&gt;
&gt; --- ../loop-AES-v3.1c/loop.c-2.4.patched 2005-09-17 12:20:54.000000000
&gt; +0300
&gt; +++ ./loop.c-2.4.patched 2006-01-27 15:36:39.000000000 +0200
&gt; @@ -222,7 +222,7 @@
&gt;   * This is loop helper thread nice value in range
&gt;   * from 0 (low priority) to -20 (high priority).
&gt;   */
&gt; -#if defined(DEF_NICE) &amp;&amp; defined(DEF_COUNTER)
&gt; +#if defined(DEF_NICE)
&gt;  static int lo_nice = -20;   /* old scheduler default */
&gt;  #else
&gt;  static int lo_nice = -1;    /* O(1) scheduler default */
&gt; @@ -748,7 +748,7 @@
&gt;    lo_nice = 0;
&gt;   if (lo_nice &lt; -20)
&gt;    lo_nice = -20;
&gt; -#if defined(DEF_NICE) &amp;&amp; defined(DEF_COUNTER)
&gt; +#if defined(DEF_NICE)
&gt;   /* old scheduler syntax */
&gt;   current-&gt;policy = SCHED_OTHER;
&gt;   current-&gt;nice = lo_nice;
&gt;


-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060128155903</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-01-28 15:59:03-0400</timestampReceived><subject>Re: Shred and stuff</subject><body>

Gabriel Jägenstedt wrote:
&gt; Could the fact that I ran a umask before shredding matter?

No.

&gt; Hmm.. I wonder. When running head on sda I get nothing, while on sdb I
&gt; get a lot of junk, could my system in some obscure way changed places
&gt; for the drives even though my old drive is on SATA1?
&gt; I noticed that my new drive is on SATA3 which is wrong but I shouldn't
&gt; think it would matter?

Linux does not have stable /dev/sd* names. Disks allocate sda, sdb, sdc,...
in order they are detected. If link order of kernel drivers change, then
their detection order may change as well.

If old and new drives are of different sizes, then you can check their sizes
(in 512 byte units) using these commands:

    blockdev --getsize /dev/sda
    blockdev --getsize /dev/sdb

&gt; Does anyone understand what is going on and is it possible to save my data?

You overwrote your old disk. Re-install / restore from backup.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060129103652</emailId><senderName>Jan Luehr</senderName><senderEmail>jan@kabelwelt-shop.de</senderEmail><timestampReceived>2006-01-29 10:36:52-0400</timestampReceived><subject>Re: Debian on loop-AES on RAID5</subject><body>

Am Samstag, 28. Januar 2006 20:55 schrieb Leo Bogert:
ja hallo erstmal,...

&gt; &gt; &gt; Now, as far as I know, Debian does not support being
&gt; &gt; &gt; installed from within a running linux.
&gt; &gt;

&gt; &gt; fup2 debian-users

Please do so.

&gt; I have read about that but as far as I have unterstood it, debootstrap is
&gt; primarily a tool for customizing the installation. 

I was refering to cdebootstrap.
No. Where did you read so? It simple install debians as default as possible.

&gt; I don't want to create 
&gt; my own "from scratch" Debian as I might break up some important stuff or
&gt; whatever, 

As far as I got, you try to install debian. What do you expect to break?

&gt; I would prefer using the standard installation routines if that's 
&gt; possible?

What is standard in your opinion?
Debian-installer doesn't suite here. When you want to install debian within a 
running linux, you usually have an already partioned harddrive, booted kernel 
modules, running internet connection etc.
If you really want to use debian installer - what I really don't recommend, 
you may download the root.img floppy for your debian distribution and chroot 
into the containing initrd with /sbin/debian-installer as shell.

Keep smiling
yanosz

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060129144729</emailId><senderName>Jari Ruusu</senderName><senderEmail>jariruusu@users.sourceforge.net</senderEmail><timestampReceived>2006-01-29 14:47:29-0400</timestampReceived><subject>Re: Announce loop-AES-v3.1c file/swap crypto package</subject><body>

Sam Ravnborg wrote:
&gt; On Sat, Jan 21, 2006 at 06:27:36PM +0200, Jari Ruusu wrote:
&gt; &gt; 2) Try building external module A that exports some function, and then build
&gt; &gt;    another external module B (separate package, only knows function
&gt; &gt;    prototype) that uses said exported function. And I mean build it cleanly
&gt; &gt;    without puking error messages on me. 2.4 and older kernel got that right,
&gt; &gt;    but 2.6 is still FUBAR. Serious regression here.
&gt; 
&gt; This was always possible using a kbuild file specifying all relevant
&gt; modules. But accepting this is not always doable kbuild now add an
&gt; additional method. build module a. copy Module.symvers from module a to
&gt; module b. Voila, module b has full access to symbols from module a. This
&gt; includes module versioning support. Both methods are documented in
&gt; Documentation/kbuild/modules.txt now.

But that "copy Module.symvers from module A to module B" does not work in
these situations:

1) Module B does not know where module A source is.
2) Automatic package builder box may remove all traces of module A before
   module B is built.
3) Automatic package builder box may build module B before module A.

How about this:

    make M=/path/to/dir IGNORE_MISSING_SYMVER_ERRORS=1 modules
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Meaning: If symbol version is available, fine, use that. If some info is not
available, that is fine too. Just make it work without symbol versioning.
Killing those damn error messages should be enough.

-- 
Jari Ruusu  1024R/3A220F51 5B 4B F9 BB D3 3F 52 E9  DB 1D EB E3 24 0E A9 DD

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email><email><emailId>20060131233639</emailId><senderName>Venkat Manakkal</senderName><senderEmail>venkat@rayservers.com</senderEmail><timestampReceived>2006-01-31 23:36:39-0400</timestampReceived><subject>Re: "Cipher or key length not supported" under loop-aes 3.0</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 01/31/2006 04:47 PM, Chris Schadl wrote:
| Ah, yeah.  About 5 minutes after I posted this I discovered that a seperate
| module 'cryptoloop' is created.  Once I loaded that, everything worked fine.

Thats great that things work out.

Just remember that cryptoloop and loop-aes are different.

Crytoloop implements single key disk crypto that is fubar and the second
implements multi-key crypto that is not vulnerable to the watermark attack.

See: http://mareichelt.de/pub/texts.cryptoloop.php

and from google:

http://marc.theaimsgroup.com/?l=linux-kernel&amp;m=107719798631935&amp;w=2
http://www.governmentsecurity.org/archive/t14922.html

Best regards,

- ---Venkat.

- --
http://rayservers.com/                                            607-546-7300
PGP/GPG:                            https://rayservers.com/keys/0x12430522.asc
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.2 (GNU/Linux)

iD8DBQFD3/SFWdkW/RJDBSIRAs34AJ0Thzbxsi6mNgCu1ta4kthWLgTTLwCglQ8K
VYmuAvjfk69fkYMhMioHdkc=
=qM4Q
-----END PGP SIGNATURE-----

-
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/



</body></email></emails>